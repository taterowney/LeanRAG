{"name":"CategoryTheory.Monad.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : SizeOf C\ntoFunctor : CategoryTheory.Functor C C\nη : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor\nμ : Quiver.Hom (toFunctor.comp toFunctor) toFunctor\nassoc : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (μ.app X)) (μ.app X)) (CategoryTheory.CategoryStruct.comp (μ.app (toFunctor.obj X)) (μ.app X))) _auto✝\nleft_unit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (η.app (toFunctor.obj X)) (μ.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor.obj X)))) _auto✝\nright_unit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (η.app X)) (μ.app X)) (CategoryTheory.CategoryStruct.id (toFunctor.obj ((CategoryTheory.Functor.id C).obj X)))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, η := η, μ := μ, assoc := assoc, left_unit := left_unit, right_unit := right_unit }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf η)) (SizeOf.sizeOf μ))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nη : 𝟭 C ⟶ T and μ : T ⋙ T ⟶ T satisfying three equations:\n- T μ_X ≫ μ_X = μ_(TX) ≫ μ_X (associativity)\n- η_(TX) ≫ μ_X = 1_X (left unit)\n- Tη_X ≫ μ_X = 1_X (right unit)\n-/\nstructure Monad extends C ⥤ C where\n  /-- The unit for the monad. -/\n  η : 𝟭 _ ⟶ toFunctor\n  /-- The multiplication for the monad. -/\n  μ : toFunctor ⋙ toFunctor ⟶ toFunctor\n  assoc : ∀ X, toFunctor.map (NatTrans.app μ X) ≫ μ.app _ = μ.app _ ≫ μ.app _ := by aesop_cat\n  left_unit : ∀ X : C, η.app (toFunctor.obj X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n  right_unit : ∀ X : C, toFunctor.map (η.app X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.right_unit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Monad C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.map (self.η.app X)) (self.μ.app X)) (CategoryTheory.CategoryStruct.id (self.obj ((CategoryTheory.Functor.id C).obj X)))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nη : 𝟭 C ⟶ T and μ : T ⋙ T ⟶ T satisfying three equations:\n- T μ_X ≫ μ_X = μ_(TX) ≫ μ_X (associativity)\n- η_(TX) ≫ μ_X = 1_X (left unit)\n- Tη_X ≫ μ_X = 1_X (right unit)\n-/\nstructure Monad extends C ⥤ C where\n  /-- The unit for the monad. -/\n  η : 𝟭 _ ⟶ toFunctor\n  /-- The multiplication for the monad. -/\n  μ : toFunctor ⋙ toFunctor ⟶ toFunctor\n  assoc : ∀ X, toFunctor.map (NatTrans.app μ X) ≫ μ.app _ = μ.app _ ≫ μ.app _ := by aesop_cat\n  left_unit : ∀ X : C, η.app (toFunctor.obj X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n  right_unit : ∀ X : C, toFunctor.map (η.app X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.left_unit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Monad C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.η.app (self.obj X)) (self.μ.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (self.obj X)))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nη : 𝟭 C ⟶ T and μ : T ⋙ T ⟶ T satisfying three equations:\n- T μ_X ≫ μ_X = μ_(TX) ≫ μ_X (associativity)\n- η_(TX) ≫ μ_X = 1_X (left unit)\n- Tη_X ≫ μ_X = 1_X (right unit)\n-/\nstructure Monad extends C ⥤ C where\n  /-- The unit for the monad. -/\n  η : 𝟭 _ ⟶ toFunctor\n  /-- The multiplication for the monad. -/\n  μ : toFunctor ⋙ toFunctor ⟶ toFunctor\n  assoc : ∀ X, toFunctor.map (NatTrans.app μ X) ≫ μ.app _ = μ.app _ ≫ μ.app _ := by aesop_cat\n  left_unit : ∀ X : C, η.app (toFunctor.obj X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n  right_unit : ∀ X : C, toFunctor.map (η.app X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\ntoFunctor✝ : CategoryTheory.Functor C C\nη✝ : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor✝\nμ✝ : Quiver.Hom (toFunctor✝.comp toFunctor✝) toFunctor✝\nassoc✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor✝.map (μ✝.app X)) (μ✝.app X)) (CategoryTheory.CategoryStruct.comp (μ✝.app (toFunctor✝.obj X)) (μ✝.app X))) _auto✝\nleft_unit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (η✝.app (toFunctor✝.obj X)) (μ✝.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor✝.obj X)))) _auto✝\nright_unit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor✝.map (η✝.app X)) (μ✝.app X)) (CategoryTheory.CategoryStruct.id (toFunctor✝.obj ((CategoryTheory.Functor.id C).obj X)))) _auto✝\ntoFunctor : CategoryTheory.Functor C C\nη : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor\nμ : Quiver.Hom (toFunctor.comp toFunctor) toFunctor\nassoc : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (μ.app X)) (μ.app X)) (CategoryTheory.CategoryStruct.comp (μ.app (toFunctor.obj X)) (μ.app X))) _auto✝\nleft_unit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (η.app (toFunctor.obj X)) (μ.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor.obj X)))) _auto✝\nright_unit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (η.app X)) (μ.app X)) (CategoryTheory.CategoryStruct.id (toFunctor.obj ((CategoryTheory.Functor.id C).obj X)))) _auto✝\nx✝ : Eq { toFunctor := toFunctor✝, η := η✝, μ := μ✝, assoc := assoc✝, left_unit := left_unit✝, right_unit := right_unit✝ } { toFunctor := toFunctor, η := η, μ := μ, assoc := assoc, left_unit := left_unit, right_unit := right_unit }\n⊢ And (Eq toFunctor✝ toFunctor) (And (HEq η✝ η) (HEq μ✝ μ))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nη : 𝟭 C ⟶ T and μ : T ⋙ T ⟶ T satisfying three equations:\n- T μ_X ≫ μ_X = μ_(TX) ≫ μ_X (associativity)\n- η_(TX) ≫ μ_X = 1_X (left unit)\n- Tη_X ≫ μ_X = 1_X (right unit)\n-/\nstructure Monad extends C ⥤ C where\n  /-- The unit for the monad. -/\n  η : 𝟭 _ ⟶ toFunctor\n  /-- The multiplication for the monad. -/\n  μ : toFunctor ⋙ toFunctor ⟶ toFunctor\n  assoc : ∀ X, toFunctor.map (NatTrans.app μ X) ≫ μ.app _ = μ.app _ ≫ μ.app _ := by aesop_cat\n  left_unit : ∀ X : C, η.app (toFunctor.obj X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n  right_unit : ∀ X : C, toFunctor.map (η.app X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\ntoFunctor✝ : CategoryTheory.Functor C C\nη✝ : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor✝\nμ✝ : Quiver.Hom (toFunctor✝.comp toFunctor✝) toFunctor✝\nassoc✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor✝.map (μ✝.app X)) (μ✝.app X)) (CategoryTheory.CategoryStruct.comp (μ✝.app (toFunctor✝.obj X)) (μ✝.app X))) _auto✝\nleft_unit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (η✝.app (toFunctor✝.obj X)) (μ✝.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor✝.obj X)))) _auto✝\nright_unit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor✝.map (η✝.app X)) (μ✝.app X)) (CategoryTheory.CategoryStruct.id (toFunctor✝.obj ((CategoryTheory.Functor.id C).obj X)))) _auto✝\ntoFunctor : CategoryTheory.Functor C C\nη : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor\nμ : Quiver.Hom (toFunctor.comp toFunctor) toFunctor\nassoc : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (μ.app X)) (μ.app X)) (CategoryTheory.CategoryStruct.comp (μ.app (toFunctor.obj X)) (μ.app X))) _auto✝\nleft_unit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (η.app (toFunctor.obj X)) (μ.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor.obj X)))) _auto✝\nright_unit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (η.app X)) (μ.app X)) (CategoryTheory.CategoryStruct.id (toFunctor.obj ((CategoryTheory.Functor.id C).obj X)))) _auto✝\n⊢ Eq (Eq { toFunctor := toFunctor✝, η := η✝, μ := μ✝, assoc := assoc✝, left_unit := left_unit✝, right_unit := right_unit✝ } { toFunctor := toFunctor, η := η, μ := μ, assoc := assoc, left_unit := left_unit, right_unit := right_unit }) (And (Eq toFunctor✝ toFunctor) (And (HEq η✝ η) (HEq μ✝ μ)))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nη : 𝟭 C ⟶ T and μ : T ⋙ T ⟶ T satisfying three equations:\n- T μ_X ≫ μ_X = μ_(TX) ≫ μ_X (associativity)\n- η_(TX) ≫ μ_X = 1_X (left unit)\n- Tη_X ≫ μ_X = 1_X (right unit)\n-/\nstructure Monad extends C ⥤ C where\n  /-- The unit for the monad. -/\n  η : 𝟭 _ ⟶ toFunctor\n  /-- The multiplication for the monad. -/\n  μ : toFunctor ⋙ toFunctor ⟶ toFunctor\n  assoc : ∀ X, toFunctor.map (NatTrans.app μ X) ≫ μ.app _ = μ.app _ ≫ μ.app _ := by aesop_cat\n  left_unit : ∀ X : C, η.app (toFunctor.obj X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n  right_unit : ∀ X : C, toFunctor.map (η.app X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Monad C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.map (self.μ.app X)) (self.μ.app X)) (CategoryTheory.CategoryStruct.comp (self.μ.app (self.obj X)) (self.μ.app X))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nη : 𝟭 C ⟶ T and μ : T ⋙ T ⟶ T satisfying three equations:\n- T μ_X ≫ μ_X = μ_(TX) ≫ μ_X (associativity)\n- η_(TX) ≫ μ_X = 1_X (left unit)\n- Tη_X ≫ μ_X = 1_X (right unit)\n-/\nstructure Monad extends C ⥤ C where\n  /-- The unit for the monad. -/\n  η : 𝟭 _ ⟶ toFunctor\n  /-- The multiplication for the monad. -/\n  μ : toFunctor ⋙ toFunctor ⟶ toFunctor\n  assoc : ∀ X, toFunctor.map (NatTrans.app μ X) ≫ μ.app _ = μ.app _ ≫ μ.app _ := by aesop_cat\n  left_unit : ∀ X : C, η.app (toFunctor.obj X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n  right_unit : ∀ X : C, toFunctor.map (η.app X) ≫ μ.app _ = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : SizeOf C\ntoFunctor : CategoryTheory.Functor C C\nε : Quiver.Hom toFunctor (CategoryTheory.Functor.id C)\nδ : Quiver.Hom toFunctor (toFunctor.comp toFunctor)\ncoassoc : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (toFunctor.map (δ.app X))) (CategoryTheory.CategoryStruct.comp (δ.app X) (δ.app (toFunctor.obj X)))) _auto✝\nleft_counit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (ε.app (toFunctor.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto✝\nright_counit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (toFunctor.map (ε.app X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, ε := ε, δ := δ, coassoc := coassoc, left_counit := left_counit, right_counit := right_counit }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf ε)) (SizeOf.sizeOf δ))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nε : G ⟶ 𝟭 C and δ : G ⟶ G ⋙ G satisfying three equations:\n- δ_X ≫ G δ_X = δ_X ≫ δ_(GX) (coassociativity)\n- δ_X ≫ ε_(GX) = 1_X (left counit)\n- δ_X ≫ G ε_X = 1_X (right counit)\n-/\nstructure Comonad extends C ⥤ C where\n  /-- The counit for the comonad. -/\n  ε : toFunctor ⟶ 𝟭 _\n  /-- The comultiplication for the comonad. -/\n  δ : toFunctor ⟶ toFunctor ⋙ toFunctor\n  coassoc : ∀ X, NatTrans.app δ _ ≫ toFunctor.map (δ.app X) = δ.app _ ≫ δ.app _ := by\n    aesop_cat\n  left_counit : ∀ X : C, δ.app X ≫ ε.app (toFunctor.obj X) = 𝟙 _ := by aesop_cat\n  right_counit : ∀ X : C, δ.app X ≫ toFunctor.map (ε.app X) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\ntoFunctor✝ : CategoryTheory.Functor C C\nε✝ : Quiver.Hom toFunctor✝ (CategoryTheory.Functor.id C)\nδ✝ : Quiver.Hom toFunctor✝ (toFunctor✝.comp toFunctor✝)\ncoassoc✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ✝.app X) (toFunctor✝.map (δ✝.app X))) (CategoryTheory.CategoryStruct.comp (δ✝.app X) (δ✝.app (toFunctor✝.obj X)))) _auto✝\nleft_counit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ✝.app X) (ε✝.app (toFunctor✝.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor✝.obj X))) _auto✝\nright_counit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ✝.app X) (toFunctor✝.map (ε✝.app X))) (CategoryTheory.CategoryStruct.id (toFunctor✝.obj X))) _auto✝\ntoFunctor : CategoryTheory.Functor C C\nε : Quiver.Hom toFunctor (CategoryTheory.Functor.id C)\nδ : Quiver.Hom toFunctor (toFunctor.comp toFunctor)\ncoassoc : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (toFunctor.map (δ.app X))) (CategoryTheory.CategoryStruct.comp (δ.app X) (δ.app (toFunctor.obj X)))) _auto✝\nleft_counit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (ε.app (toFunctor.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto✝\nright_counit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (toFunctor.map (ε.app X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto✝\n⊢ Eq (Eq { toFunctor := toFunctor✝, ε := ε✝, δ := δ✝, coassoc := coassoc✝, left_counit := left_counit✝, right_counit := right_counit✝ } { toFunctor := toFunctor, ε := ε, δ := δ, coassoc := coassoc, left_counit := left_counit, right_counit := right_counit }) (And (Eq toFunctor✝ toFunctor) (And (HEq ε✝ ε) (HEq δ✝ δ)))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nε : G ⟶ 𝟭 C and δ : G ⟶ G ⋙ G satisfying three equations:\n- δ_X ≫ G δ_X = δ_X ≫ δ_(GX) (coassociativity)\n- δ_X ≫ ε_(GX) = 1_X (left counit)\n- δ_X ≫ G ε_X = 1_X (right counit)\n-/\nstructure Comonad extends C ⥤ C where\n  /-- The counit for the comonad. -/\n  ε : toFunctor ⟶ 𝟭 _\n  /-- The comultiplication for the comonad. -/\n  δ : toFunctor ⟶ toFunctor ⋙ toFunctor\n  coassoc : ∀ X, NatTrans.app δ _ ≫ toFunctor.map (δ.app X) = δ.app _ ≫ δ.app _ := by\n    aesop_cat\n  left_counit : ∀ X : C, δ.app X ≫ ε.app (toFunctor.obj X) = 𝟙 _ := by aesop_cat\n  right_counit : ∀ X : C, δ.app X ≫ toFunctor.map (ε.app X) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.left_counit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Comonad C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.δ.app X) (self.ε.app (self.obj X))) (CategoryTheory.CategoryStruct.id (self.obj X))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nε : G ⟶ 𝟭 C and δ : G ⟶ G ⋙ G satisfying three equations:\n- δ_X ≫ G δ_X = δ_X ≫ δ_(GX) (coassociativity)\n- δ_X ≫ ε_(GX) = 1_X (left counit)\n- δ_X ≫ G ε_X = 1_X (right counit)\n-/\nstructure Comonad extends C ⥤ C where\n  /-- The counit for the comonad. -/\n  ε : toFunctor ⟶ 𝟭 _\n  /-- The comultiplication for the comonad. -/\n  δ : toFunctor ⟶ toFunctor ⋙ toFunctor\n  coassoc : ∀ X, NatTrans.app δ _ ≫ toFunctor.map (δ.app X) = δ.app _ ≫ δ.app _ := by\n    aesop_cat\n  left_counit : ∀ X : C, δ.app X ≫ ε.app (toFunctor.obj X) = 𝟙 _ := by aesop_cat\n  right_counit : ∀ X : C, δ.app X ≫ toFunctor.map (ε.app X) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\ntoFunctor✝ : CategoryTheory.Functor C C\nε✝ : Quiver.Hom toFunctor✝ (CategoryTheory.Functor.id C)\nδ✝ : Quiver.Hom toFunctor✝ (toFunctor✝.comp toFunctor✝)\ncoassoc✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ✝.app X) (toFunctor✝.map (δ✝.app X))) (CategoryTheory.CategoryStruct.comp (δ✝.app X) (δ✝.app (toFunctor✝.obj X)))) _auto✝\nleft_counit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ✝.app X) (ε✝.app (toFunctor✝.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor✝.obj X))) _auto✝\nright_counit✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ✝.app X) (toFunctor✝.map (ε✝.app X))) (CategoryTheory.CategoryStruct.id (toFunctor✝.obj X))) _auto✝\ntoFunctor : CategoryTheory.Functor C C\nε : Quiver.Hom toFunctor (CategoryTheory.Functor.id C)\nδ : Quiver.Hom toFunctor (toFunctor.comp toFunctor)\ncoassoc : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (toFunctor.map (δ.app X))) (CategoryTheory.CategoryStruct.comp (δ.app X) (δ.app (toFunctor.obj X)))) _auto✝\nleft_counit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (ε.app (toFunctor.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto✝\nright_counit : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (δ.app X) (toFunctor.map (ε.app X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto✝\nx✝ : Eq { toFunctor := toFunctor✝, ε := ε✝, δ := δ✝, coassoc := coassoc✝, left_counit := left_counit✝, right_counit := right_counit✝ } { toFunctor := toFunctor, ε := ε, δ := δ, coassoc := coassoc, left_counit := left_counit, right_counit := right_counit }\n⊢ And (Eq toFunctor✝ toFunctor) (And (HEq ε✝ ε) (HEq δ✝ δ))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nε : G ⟶ 𝟭 C and δ : G ⟶ G ⋙ G satisfying three equations:\n- δ_X ≫ G δ_X = δ_X ≫ δ_(GX) (coassociativity)\n- δ_X ≫ ε_(GX) = 1_X (left counit)\n- δ_X ≫ G ε_X = 1_X (right counit)\n-/\nstructure Comonad extends C ⥤ C where\n  /-- The counit for the comonad. -/\n  ε : toFunctor ⟶ 𝟭 _\n  /-- The comultiplication for the comonad. -/\n  δ : toFunctor ⟶ toFunctor ⋙ toFunctor\n  coassoc : ∀ X, NatTrans.app δ _ ≫ toFunctor.map (δ.app X) = δ.app _ ≫ δ.app _ := by\n    aesop_cat\n  left_counit : ∀ X : C, δ.app X ≫ ε.app (toFunctor.obj X) = 𝟙 _ := by aesop_cat\n  right_counit : ∀ X : C, δ.app X ≫ toFunctor.map (ε.app X) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.right_counit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Comonad C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.δ.app X) (self.map (self.ε.app X))) (CategoryTheory.CategoryStruct.id (self.obj X))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nε : G ⟶ 𝟭 C and δ : G ⟶ G ⋙ G satisfying three equations:\n- δ_X ≫ G δ_X = δ_X ≫ δ_(GX) (coassociativity)\n- δ_X ≫ ε_(GX) = 1_X (left counit)\n- δ_X ≫ G ε_X = 1_X (right counit)\n-/\nstructure Comonad extends C ⥤ C where\n  /-- The counit for the comonad. -/\n  ε : toFunctor ⟶ 𝟭 _\n  /-- The comultiplication for the comonad. -/\n  δ : toFunctor ⟶ toFunctor ⋙ toFunctor\n  coassoc : ∀ X, NatTrans.app δ _ ≫ toFunctor.map (δ.app X) = δ.app _ ≫ δ.app _ := by\n    aesop_cat\n  left_counit : ∀ X : C, δ.app X ≫ ε.app (toFunctor.obj X) = 𝟙 _ := by aesop_cat\n  right_counit : ∀ X : C, δ.app X ≫ toFunctor.map (ε.app X) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.coassoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Comonad C\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.δ.app X) (self.map (self.δ.app X))) (CategoryTheory.CategoryStruct.comp (self.δ.app X) (self.δ.app (self.obj X)))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nε : G ⟶ 𝟭 C and δ : G ⟶ G ⋙ G satisfying three equations:\n- δ_X ≫ G δ_X = δ_X ≫ δ_(GX) (coassociativity)\n- δ_X ≫ ε_(GX) = 1_X (left counit)\n- δ_X ≫ G ε_X = 1_X (right counit)\n-/\nstructure Comonad extends C ⥤ C where\n  /-- The counit for the comonad. -/\n  ε : toFunctor ⟶ 𝟭 _\n  /-- The comultiplication for the comonad. -/\n  δ : toFunctor ⟶ toFunctor ⋙ toFunctor\n  coassoc : ∀ X, NatTrans.app δ _ ≫ toFunctor.map (δ.app X) = δ.app _ ≫ δ.app _ := by\n    aesop_cat\n  left_counit : ∀ X : C, δ.app X ≫ ε.app (toFunctor.obj X) = 𝟙 _ := by aesop_cat\n  right_counit : ∀ X : C, δ.app X ≫ toFunctor.map (ε.app X) = 𝟙 _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.right_unit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Monad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.map (self.η.app X)) (CategoryTheory.CategoryStruct.comp (self.μ.app X) h)) h","decl":"attribute [reassoc (attr := simp)] Monad.left_unit Monad.right_unit\n"}
{"name":"CategoryTheory.Monad.left_unit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Monad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.η.app (self.obj X)) (CategoryTheory.CategoryStruct.comp (self.μ.app X) h)) h","decl":"attribute [reassoc (attr := simp)] Monad.left_unit Monad.right_unit\n"}
{"name":"CategoryTheory.Comonad.coassoc_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Comonad C\nX Z : C\nh : Quiver.Hom (self.obj (self.obj (self.obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.δ.app X) (CategoryTheory.CategoryStruct.comp (self.map (self.δ.app X)) h)) (CategoryTheory.CategoryStruct.comp (self.δ.app X) (CategoryTheory.CategoryStruct.comp (self.δ.app (self.obj X)) h))","decl":"attribute [reassoc (attr := simp)] Comonad.coassoc Comonad.left_counit Comonad.right_counit\n\n"}
{"name":"CategoryTheory.Comonad.right_counit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Comonad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.δ.app X) (CategoryTheory.CategoryStruct.comp (self.map (self.ε.app X)) h)) h","decl":"attribute [reassoc (attr := simp)] Comonad.coassoc Comonad.left_counit Comonad.right_counit\n\n"}
{"name":"CategoryTheory.Comonad.left_counit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.Comonad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.δ.app X) (CategoryTheory.CategoryStruct.comp (self.ε.app (self.obj X)) h)) h","decl":"attribute [reassoc (attr := simp)] Comonad.coassoc Comonad.left_counit Comonad.right_counit\n\n"}
{"name":"CategoryTheory.MonadHom.app_η","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T₁ T₂\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (self.app X)) (T₂.η.app X)","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nx y : CategoryTheory.MonadHom T₁ T₂\n⊢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.app_μ","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T₁ T₂\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (self.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T₁.map (self.app X)) (self.app (T₂.obj X))) (T₂.μ.app X))","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.ext","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nx y : CategoryTheory.MonadHom T₁ T₂\napp : Eq x.app y.app\n⊢ Eq x y","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\ntoNatTrans✝ : CategoryTheory.NatTrans T₁.toFunctor T₂.toFunctor\napp_η✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (toNatTrans✝.app X)) (T₂.η.app X)) _auto✝\napp_μ✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (toNatTrans✝.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T₁.map (toNatTrans✝.app X)) (toNatTrans✝.app (T₂.obj X))) (T₂.μ.app X))) _auto✝\ntoNatTrans : CategoryTheory.NatTrans T₁.toFunctor T₂.toFunctor\napp_η : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (toNatTrans.app X)) (T₂.η.app X)) _auto✝\napp_μ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (toNatTrans.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T₁.map (toNatTrans.app X)) (toNatTrans.app (T₂.obj X))) (T₂.μ.app X))) _auto✝\n⊢ Eq (Eq { toNatTrans := toNatTrans✝, app_η := app_η✝, app_μ := app_μ✝ } { toNatTrans := toNatTrans, app_η := app_η, app_μ := app_μ }) (Eq toNatTrans✝ toNatTrans)","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\ninst✝ : SizeOf C\ntoNatTrans : CategoryTheory.NatTrans T₁.toFunctor T₂.toFunctor\napp_η : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (toNatTrans.app X)) (T₂.η.app X)) _auto✝\napp_μ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (toNatTrans.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T₁.map (toNatTrans.app X)) (toNatTrans.app (T₂.obj X))) (T₂.μ.app X))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toNatTrans := toNatTrans, app_η := app_η, app_μ := app_μ }) (HAdd.hAdd 1 (SizeOf.sizeOf toNatTrans))","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\ntoNatTrans✝ : CategoryTheory.NatTrans T₁.toFunctor T₂.toFunctor\napp_η✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (toNatTrans✝.app X)) (T₂.η.app X)) _auto✝\napp_μ✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (toNatTrans✝.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T₁.map (toNatTrans✝.app X)) (toNatTrans✝.app (T₂.obj X))) (T₂.μ.app X))) _auto✝\ntoNatTrans : CategoryTheory.NatTrans T₁.toFunctor T₂.toFunctor\napp_η : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (toNatTrans.app X)) (T₂.η.app X)) _auto✝\napp_μ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (toNatTrans.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T₁.map (toNatTrans.app X)) (toNatTrans.app (T₂.obj X))) (T₂.μ.app X))) _auto✝\nx✝ : Eq { toNatTrans := toNatTrans✝, app_η := app_η✝, app_μ := app_μ✝ } { toNatTrans := toNatTrans, app_η := app_η, app_μ := app_μ }\n⊢ Eq toNatTrans✝ toNatTrans","decl":"/-- A morphism of monads is a natural transformation compatible with η and μ. -/\n@[ext]\nstructure MonadHom (T₁ T₂ : Monad C) extends NatTrans (T₁ : C ⥤ C) T₂ where\n  app_η : ∀ X, T₁.η.app X ≫ app X = T₂.η.app X := by aesop_cat\n  app_μ : ∀ X, T₁.μ.app X ≫ app X = (T₁.map (app X) ≫ app _) ≫ T₂.μ.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\ntoNatTrans✝ : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_ε✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans✝.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\napp_δ✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans✝.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans✝.app (M.obj X)) (N.map (toNatTrans✝.app X))))) _auto✝\ntoNatTrans : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_ε : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\napp_δ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans.app (M.obj X)) (N.map (toNatTrans.app X))))) _auto✝\n⊢ Eq (Eq { toNatTrans := toNatTrans✝, app_ε := app_ε✝, app_δ := app_δ✝ } { toNatTrans := toNatTrans, app_ε := app_ε, app_δ := app_δ }) (Eq toNatTrans✝ toNatTrans)","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\ntoNatTrans✝ : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_ε✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans✝.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\napp_δ✝ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans✝.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans✝.app (M.obj X)) (N.map (toNatTrans✝.app X))))) _auto✝\ntoNatTrans : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_ε : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\napp_δ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans.app (M.obj X)) (N.map (toNatTrans.app X))))) _auto✝\nx✝ : Eq { toNatTrans := toNatTrans✝, app_ε := app_ε✝, app_δ := app_δ✝ } { toNatTrans := toNatTrans, app_ε := app_ε, app_δ := app_δ }\n⊢ Eq toNatTrans✝ toNatTrans","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nx y : CategoryTheory.ComonadHom M N\n⊢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.app_δ","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (self.app (M.obj X)) (N.map (self.app X))))","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.ext","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nx y : CategoryTheory.ComonadHom M N\napp : Eq x.app y.app\n⊢ Eq x y","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\ninst✝ : SizeOf C\ntoNatTrans : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_ε : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\napp_δ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans.app (M.obj X)) (N.map (toNatTrans.app X))))) _auto✝\n⊢ Eq (SizeOf.sizeOf { toNatTrans := toNatTrans, app_ε := app_ε, app_δ := app_δ }) (HAdd.hAdd 1 (SizeOf.sizeOf toNatTrans))","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.app_ε","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (N.ε.app X)) (M.ε.app X)","decl":"/-- A morphism of comonads is a natural transformation compatible with ε and δ. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ⥤ C) N where\n  app_ε : ∀ X, app X ≫ N.ε.app X = M.ε.app X := by aesop_cat\n  app_δ : ∀ X, app X ≫ N.δ.app X = M.δ.app X ≫ app _ ≫ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.app_μ_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T₁ T₂\nX Z : C\nh : Quiver.Hom (T₂.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T₁.μ.app X) (CategoryTheory.CategoryStruct.comp (self.app X) h)) (CategoryTheory.CategoryStruct.comp (T₁.map (self.app X)) (CategoryTheory.CategoryStruct.comp (self.app (T₂.obj X)) (CategoryTheory.CategoryStruct.comp (T₂.μ.app X) h)))","decl":"attribute [reassoc (attr := simp)] MonadHom.app_η MonadHom.app_μ\n"}
{"name":"CategoryTheory.MonadHom.app_η_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T₁ T₂\nX Z : C\nh : Quiver.Hom (T₂.obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T₁.η.app X) (CategoryTheory.CategoryStruct.comp (self.app X) h)) (CategoryTheory.CategoryStruct.comp (T₂.η.app X) h)","decl":"attribute [reassoc (attr := simp)] MonadHom.app_η MonadHom.app_μ\n"}
{"name":"CategoryTheory.ComonadHom.app_δ_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX Z : C\nh : Quiver.Hom (N.obj (N.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (CategoryTheory.CategoryStruct.comp (N.δ.app X) h)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (self.app (M.obj X)) (CategoryTheory.CategoryStruct.comp (N.map (self.app X)) h)))","decl":"attribute [reassoc (attr := simp)] ComonadHom.app_ε ComonadHom.app_δ\n\n"}
{"name":"CategoryTheory.ComonadHom.app_ε_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX Z : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (CategoryTheory.CategoryStruct.comp (N.ε.app X) h)) (CategoryTheory.CategoryStruct.comp (M.ε.app X) h)","decl":"attribute [reassoc (attr := simp)] ComonadHom.app_ε ComonadHom.app_δ\n\n"}
{"name":"CategoryTheory.MonadHom.ext'","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nf g : Quiver.Hom T₁ T₂\nh : Eq f.app g.app\n⊢ Eq f g","decl":"@[ext]\nlemma MonadHom.ext' {T₁ T₂ : Monad C} (f g : T₁ ⟶ T₂) (h : f.app = g.app) : f = g :=\n  MonadHom.ext h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.MonadHom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nf g : Quiver.Hom T₁ T₂\n⊢ Iff (Eq f g) (Eq f.app g.app)","decl":"@[ext]\nlemma MonadHom.ext' {T₁ T₂ : Monad C} (f g : T₁ ⟶ T₂) (h : f.app = g.app) : f = g :=\n  MonadHom.ext h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.ComonadHom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Comonad C\nf g : Quiver.Hom T₁ T₂\n⊢ Iff (Eq f g) (Eq f.app g.app)","decl":"@[ext]\nlemma ComonadHom.ext' {T₁ T₂ : Comonad C} (f g : T₁ ⟶ T₂) (h : f.app = g.app) : f = g :=\n  ComonadHom.ext h\n\n"}
{"name":"CategoryTheory.ComonadHom.ext'","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Comonad C\nf g : Quiver.Hom T₁ T₂\nh : Eq f.app g.app\n⊢ Eq f g","decl":"@[ext]\nlemma ComonadHom.ext' {T₁ T₂ : Comonad C} (f g : T₁ ⟶ T₂) (h : f.app = g.app) : f = g :=\n  ComonadHom.ext h\n\n"}
{"name":"CategoryTheory.MonadHom.id_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ Eq (CategoryTheory.CategoryStruct.id T).toNatTrans (CategoryTheory.CategoryStruct.id T.toFunctor)","decl":"@[simp]\ntheorem MonadHom.id_toNatTrans (T : Monad C) : (𝟙 T : T ⟶ T).toNatTrans = 𝟙 (T : C ⥤ C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonadHom.comp_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ T₃ : CategoryTheory.Monad C\nf : Quiver.Hom T₁ T₂\ng : Quiver.Hom T₂ T₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).toNatTrans (CategoryTheory.CategoryStruct.comp f.toNatTrans g.toNatTrans)","decl":"@[simp]\ntheorem MonadHom.comp_toNatTrans {T₁ T₂ T₃ : Monad C} (f : T₁ ⟶ T₂) (g : T₂ ⟶ T₃) :\n    (f ≫ g).toNatTrans = ((f.toNatTrans : _ ⟶ (T₂ : C ⥤ C)) ≫ g.toNatTrans : (T₁ : C ⥤ C) ⟶ T₃) :=\n  rfl\n\n"}
{"name":"CategoryTheory.ComonadHom.id_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\n⊢ Eq (CategoryTheory.CategoryStruct.id T).toNatTrans (CategoryTheory.CategoryStruct.id T.toFunctor)","decl":"@[simp]\ntheorem ComonadHom.id_toNatTrans (T : Comonad C) : (𝟙 T : T ⟶ T).toNatTrans = 𝟙 (T : C ⥤ C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.comp_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ T₃ : CategoryTheory.Comonad C\nf : Quiver.Hom T₁ T₂\ng : Quiver.Hom T₂ T₃\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).toNatTrans (CategoryTheory.CategoryStruct.comp f.toNatTrans g.toNatTrans)","decl":"@[simp]\ntheorem comp_toNatTrans {T₁ T₂ T₃ : Comonad C} (f : T₁ ⟶ T₂) (g : T₂ ⟶ T₃) :\n    (f ≫ g).toNatTrans = ((f.toNatTrans : _ ⟶ (T₂ : C ⥤ C)) ≫ g.toNatTrans : (T₁ : C ⥤ C) ⟶ T₃) :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonadIso.mk_inv_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Monad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_η : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.η.app X) (f.hom.app X)) (N.η.app X)) _auto✝\nf_μ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.μ.app X) (f.hom.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X))) (N.μ.app X))) _auto✝\n⊢ Eq (CategoryTheory.MonadIso.mk f f_η f_μ).inv.toNatTrans f.inv","decl":"/-- Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. -/\n@[simps]\ndef MonadIso.mk {M N : Monad C} (f : (M : C ⥤ C) ≅ N)\n    (f_η : ∀ (X : C), M.η.app X ≫ f.hom.app X = N.η.app X := by aesop_cat)\n    (f_μ : ∀ (X : C), M.μ.app X ≫ f.hom.app X =\n    (M.map (f.hom.app X) ≫ f.hom.app (N.obj X)) ≫ N.μ.app X := by aesop_cat) : M ≅ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_η := f_η\n      app_μ := f_μ }\n  inv :=\n    { toNatTrans := f.inv\n      app_η := fun X => by simp [← f_η]\n      app_μ := fun X => by\n        rw [← NatIso.cancel_natIso_hom_right f]\n        simp only [NatTrans.naturality, Iso.inv_hom_id_app, assoc, comp_id, f_μ,\n          NatTrans.naturality_assoc, Iso.inv_hom_id_app_assoc, ← Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.MonadIso.mk_hom_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Monad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_η : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.η.app X) (f.hom.app X)) (N.η.app X)) _auto✝\nf_μ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.μ.app X) (f.hom.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X))) (N.μ.app X))) _auto✝\n⊢ Eq (CategoryTheory.MonadIso.mk f f_η f_μ).hom.toNatTrans f.hom","decl":"/-- Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. -/\n@[simps]\ndef MonadIso.mk {M N : Monad C} (f : (M : C ⥤ C) ≅ N)\n    (f_η : ∀ (X : C), M.η.app X ≫ f.hom.app X = N.η.app X := by aesop_cat)\n    (f_μ : ∀ (X : C), M.μ.app X ≫ f.hom.app X =\n    (M.map (f.hom.app X) ≫ f.hom.app (N.obj X)) ≫ N.μ.app X := by aesop_cat) : M ≅ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_η := f_η\n      app_μ := f_μ }\n  inv :=\n    { toNatTrans := f.inv\n      app_η := fun X => by simp [← f_η]\n      app_μ := fun X => by\n        rw [← NatIso.cancel_natIso_hom_right f]\n        simp only [NatTrans.naturality, Iso.inv_hom_id_app, assoc, comp_id, f_μ,\n          NatTrans.naturality_assoc, Iso.inv_hom_id_app_assoc, ← Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.ComonadIso.mk_hom_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_ε : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\nf_δ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (f.hom.app (M.obj X)) (N.map (f.hom.app X))))) _auto✝\n⊢ Eq (CategoryTheory.ComonadIso.mk f f_ε f_δ).hom.toNatTrans f.hom","decl":"/-- Construct a comonad isomorphism from a natural isomorphism of functors where the forward\ndirection is a comonad morphism. -/\n@[simps]\ndef ComonadIso.mk {M N : Comonad C} (f : (M : C ⥤ C) ≅ N)\n    (f_ε : ∀ (X : C), f.hom.app X ≫ N.ε.app X = M.ε.app X := by aesop_cat)\n    (f_δ : ∀ (X : C), f.hom.app X ≫ N.δ.app X =\n    M.δ.app X ≫ f.hom.app (M.obj X) ≫ N.map (f.hom.app X) := by aesop_cat) : M ≅ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_ε := f_ε\n      app_δ := f_δ }\n  inv :=\n    { toNatTrans := f.inv\n      app_ε := fun X => by simp [← f_ε]\n      app_δ := fun X => by\n        rw [← NatIso.cancel_natIso_hom_left f]\n        simp only [reassoc_of% (f_δ X), Iso.hom_inv_id_app_assoc, NatTrans.naturality_assoc]\n        rw [← Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n        apply (comp_id _).symm }\n\n"}
{"name":"CategoryTheory.ComonadIso.mk_inv_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_ε : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.ε.app X)) (M.ε.app X)) _auto✝\nf_δ : autoParam (∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (f.hom.app (M.obj X)) (N.map (f.hom.app X))))) _auto✝\n⊢ Eq (CategoryTheory.ComonadIso.mk f f_ε f_δ).inv.toNatTrans f.inv","decl":"/-- Construct a comonad isomorphism from a natural isomorphism of functors where the forward\ndirection is a comonad morphism. -/\n@[simps]\ndef ComonadIso.mk {M N : Comonad C} (f : (M : C ⥤ C) ≅ N)\n    (f_ε : ∀ (X : C), f.hom.app X ≫ N.ε.app X = M.ε.app X := by aesop_cat)\n    (f_δ : ∀ (X : C), f.hom.app X ≫ N.δ.app X =\n    M.δ.app X ≫ f.hom.app (M.obj X) ≫ N.map (f.hom.app X) := by aesop_cat) : M ≅ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_ε := f_ε\n      app_δ := f_δ }\n  inv :=\n    { toNatTrans := f.inv\n      app_ε := fun X => by simp [← f_ε]\n      app_δ := fun X => by\n        rw [← NatIso.cancel_natIso_hom_left f]\n        simp only [reassoc_of% (f_δ X), Iso.hom_inv_id_app_assoc, NatTrans.naturality_assoc]\n        rw [← Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n        apply (comp_id _).symm }\n\n"}
{"name":"CategoryTheory.monadToFunctor_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ Eq ((CategoryTheory.monadToFunctor C).obj T) T.toFunctor","decl":"/-- The forgetful functor from the category of monads to the category of endofunctors.\n-/\n@[simps!]\ndef monadToFunctor : Monad C ⥤ C ⥤ C where\n  obj T := T\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.monadToFunctor_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.Monad C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.monadToFunctor C).map f) f.toNatTrans","decl":"/-- The forgetful functor from the category of monads to the category of endofunctors.\n-/\n@[simps!]\ndef monadToFunctor : Monad C ⥤ C ⥤ C where\n  obj T := T\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.instFaithfulMonadFunctorMonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.monadToFunctor C).Faithful","decl":"instance : (monadToFunctor C).Faithful where\n\n"}
{"name":"CategoryTheory.monadToFunctor_mapIso_monad_iso_mk","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Monad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_η : ∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.η.app X) (f.hom.app X)) (N.η.app X)\nf_μ : ∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.μ.app X) (f.hom.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X))) (N.μ.app X))\n⊢ Eq ((CategoryTheory.monadToFunctor C).mapIso (CategoryTheory.MonadIso.mk f f_η f_μ)) f","decl":"theorem monadToFunctor_mapIso_monad_iso_mk {M N : Monad C} (f : (M : C ⥤ C) ≅ N) (f_η f_μ) :\n    (monadToFunctor _).mapIso (MonadIso.mk f f_η f_μ) = f := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsMonadFunctorMonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.monadToFunctor C).ReflectsIsomorphisms","decl":"instance : (monadToFunctor C).ReflectsIsomorphisms where\n  reflects f _ := (MonadIso.mk (asIso ((monadToFunctor C).map f)) f.app_η f.app_μ).isIso_hom\n\n"}
{"name":"CategoryTheory.comonadToFunctor_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\n⊢ Eq ((CategoryTheory.comonadToFunctor C).obj G) G.toFunctor","decl":"/-- The forgetful functor from the category of comonads to the category of endofunctors.\n-/\n@[simps!]\ndef comonadToFunctor : Comonad C ⥤ C ⥤ C where\n  obj G := G\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.comonadToFunctor_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.Comonad C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.comonadToFunctor C).map f) f.toNatTrans","decl":"/-- The forgetful functor from the category of comonads to the category of endofunctors.\n-/\n@[simps!]\ndef comonadToFunctor : Comonad C ⥤ C ⥤ C where\n  obj G := G\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.instFaithfulComonadFunctorComonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.comonadToFunctor C).Faithful","decl":"instance : (comonadToFunctor C).Faithful where\n\n"}
{"name":"CategoryTheory.comonadToFunctor_mapIso_comonad_iso_mk","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_ε : ∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.ε.app X)) (M.ε.app X)\nf_δ : ∀ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.δ.app X)) (CategoryTheory.CategoryStruct.comp (M.δ.app X) (CategoryTheory.CategoryStruct.comp (f.hom.app (M.obj X)) (N.map (f.hom.app X))))\n⊢ Eq ((CategoryTheory.comonadToFunctor C).mapIso (CategoryTheory.ComonadIso.mk f f_ε f_δ)) f","decl":"theorem comonadToFunctor_mapIso_comonad_iso_mk {M N : Comonad C} (f : (M : C ⥤ C) ≅ N) (f_ε f_δ) :\n    (comonadToFunctor _).mapIso (ComonadIso.mk f f_ε f_δ) = f := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsComonadFunctorComonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.comonadToFunctor C).ReflectsIsomorphisms","decl":"instance : (comonadToFunctor C).ReflectsIsomorphisms where\n  reflects f _ := (ComonadIso.mk (asIso ((comonadToFunctor C).map f)) f.app_ε f.app_δ).isIso_hom\n\n"}
{"name":"CategoryTheory.MonadIso.toNatIso_hom","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Monad C\nh : CategoryTheory.Iso M N\n⊢ Eq (CategoryTheory.MonadIso.toNatIso h).hom h.hom.toNatTrans","decl":"/-- An isomorphism of monads gives a natural isomorphism of the underlying functors.\n-/\n/- Porting note: removed\n`@[simps (config := { rhsMd := semireducible })]`\nand replaced with `@[simps]` in the two declarations below -/\n@[simps!]\ndef MonadIso.toNatIso {M N : Monad C} (h : M ≅ N) : (M : C ⥤ C) ≅ N :=\n  (monadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.MonadIso.toNatIso_inv","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Monad C\nh : CategoryTheory.Iso M N\n⊢ Eq (CategoryTheory.MonadIso.toNatIso h).inv h.inv.toNatTrans","decl":"/-- An isomorphism of monads gives a natural isomorphism of the underlying functors.\n-/\n/- Porting note: removed\n`@[simps (config := { rhsMd := semireducible })]`\nand replaced with `@[simps]` in the two declarations below -/\n@[simps!]\ndef MonadIso.toNatIso {M N : Monad C} (h : M ≅ N) : (M : C ⥤ C) ≅ N :=\n  (monadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.ComonadIso.toNatIso_hom","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nh : CategoryTheory.Iso M N\n⊢ Eq (CategoryTheory.ComonadIso.toNatIso h).hom h.hom.toNatTrans","decl":"/-- An isomorphism of comonads gives a natural isomorphism of the underlying functors.\n-/\n@[simps!]\ndef ComonadIso.toNatIso {M N : Comonad C} (h : M ≅ N) : (M : C ⥤ C) ≅ N :=\n  (comonadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.ComonadIso.toNatIso_inv","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nM N : CategoryTheory.Comonad C\nh : CategoryTheory.Iso M N\n⊢ Eq (CategoryTheory.ComonadIso.toNatIso h).inv h.inv.toNatTrans","decl":"/-- An isomorphism of comonads gives a natural isomorphism of the underlying functors.\n-/\n@[simps!]\ndef ComonadIso.toNatIso {M N : Comonad C} (h : M ≅ N) : (M : C ⥤ C) ≅ N :=\n  (comonadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.Monad.id_μ_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.Monad.id C).μ.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := 𝟭 C\n  η := 𝟙 (𝟭 C)\n  μ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Monad.id_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Monad.id C).map f) f","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := 𝟭 C\n  η := 𝟙 (𝟭 C)\n  μ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Monad.id_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.Monad.id C).obj X) X","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := 𝟭 C\n  η := 𝟙 (𝟭 C)\n  μ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Monad.id_η_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.Monad.id C).η.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := 𝟭 C\n  η := 𝟙 (𝟭 C)\n  μ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Comonad.id_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.Comonad.id C).obj X) X","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := 𝟭 _\n  ε := 𝟙 (𝟭 C)\n  δ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Comonad.id_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Comonad.id C).map f) f","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := 𝟭 _\n  ε := 𝟙 (𝟭 C)\n  δ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Comonad.id_δ_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.Comonad.id C).δ.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := 𝟭 _\n  ε := 𝟙 (𝟭 C)\n  δ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Comonad.id_ε_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq ((CategoryTheory.Comonad.id C).ε.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := 𝟭 _\n  ε := 𝟙 (𝟭 C)\n  δ := 𝟙 (𝟭 C)\n\n"}
{"name":"CategoryTheory.Monad.map_unit_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : C\ninst✝ : CategoryTheory.IsIso T.μ\n⊢ Eq (T.map (T.η.app X)) (T.η.app (T.obj X))","decl":"lemma map_unit_app (T : Monad C) (X : C) [IsIso T.μ] :\n    T.map (T.η.app X) = T.η.app (T.obj X) := by\n  simp [← cancel_mono (T.μ.app _)]\n\n"}
{"name":"CategoryTheory.Monad.isSplitMono_iff_isIso_unit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : C\ninst✝ : CategoryTheory.IsIso T.μ\n⊢ Iff (CategoryTheory.IsSplitMono (T.η.app X)) (CategoryTheory.IsIso (T.η.app X))","decl":"lemma isSplitMono_iff_isIso_unit (T : Monad C) (X : C) [IsIso T.μ] :\n    IsSplitMono (T.η.app X) ↔ IsIso (T.η.app X) := by\n  refine ⟨fun _ ↦ ⟨retraction (T.η.app X), by simp, ?_⟩, fun _ ↦ inferInstance⟩\n  erw [← map_id, ← IsSplitMono.id (T.η.app X), map_comp, T.map_unit_app X, T.η.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.map_counit_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : C\ninst✝ : CategoryTheory.IsIso T.δ\n⊢ Eq (T.map (T.ε.app X)) (T.ε.app (T.obj X))","decl":"lemma map_counit_app (T : Comonad C) (X : C) [IsIso T.δ] :\n    T.map (T.ε.app X) = T.ε.app (T.obj X) := by\n  simp [← cancel_epi (T.δ.app _)]\n\n"}
{"name":"CategoryTheory.Comonad.isSplitEpi_iff_isIso_counit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Comonad C\nX : C\ninst✝ : CategoryTheory.IsIso T.δ\n⊢ Iff (CategoryTheory.IsSplitEpi (T.ε.app X)) (CategoryTheory.IsIso (T.ε.app X))","decl":"lemma isSplitEpi_iff_isIso_counit (T : Comonad C) (X : C) [IsIso T.δ] :\n    IsSplitEpi (T.ε.app X) ↔ IsIso (T.ε.app X) := by\n  refine ⟨fun _ ↦ ⟨section_ (T.ε.app X), ?_, by simp⟩, fun _ ↦ inferInstance⟩\n  erw [← map_id, ← IsSplitEpi.id (T.ε.app X), map_comp, T.map_counit_app X, T.ε.naturality]\n  rfl\n\n"}
