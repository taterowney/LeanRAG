{"name":"CategoryTheory.Monad.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : SizeOf C\ntoFunctor : CategoryTheory.Functor C C\nŒ∑ : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor\nŒº : Quiver.Hom (toFunctor.comp toFunctor) toFunctor\nassoc : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (Œº.app X)) (Œº.app X)) (CategoryTheory.CategoryStruct.comp (Œº.app (toFunctor.obj X)) (Œº.app X))) _auto‚úù\nleft_unit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ∑.app (toFunctor.obj X)) (Œº.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor.obj X)))) _auto‚úù\nright_unit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (Œ∑.app X)) (Œº.app X)) (CategoryTheory.CategoryStruct.id (toFunctor.obj ((CategoryTheory.Functor.id C).obj X)))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, Œ∑ := Œ∑, Œº := Œº, assoc := assoc, left_unit := left_unit, right_unit := right_unit }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf Œ∑)) (SizeOf.sizeOf Œº))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nŒ∑ : ùü≠ C ‚ü∂ T and Œº : T ‚ãô T ‚ü∂ T satisfying three equations:\n- T Œº_X ‚â´ Œº_X = Œº_(TX) ‚â´ Œº_X (associativity)\n- Œ∑_(TX) ‚â´ Œº_X = 1_X (left unit)\n- TŒ∑_X ‚â´ Œº_X = 1_X (right unit)\n-/\nstructure Monad extends C ‚•§ C where\n  /-- The unit for the monad. -/\n  Œ∑ : ùü≠ _ ‚ü∂ toFunctor\n  /-- The multiplication for the monad. -/\n  Œº : toFunctor ‚ãô toFunctor ‚ü∂ toFunctor\n  assoc : ‚àÄ X, toFunctor.map (NatTrans.app Œº X) ‚â´ Œº.app _ = Œº.app _ ‚â´ Œº.app _ := by aesop_cat\n  left_unit : ‚àÄ X : C, Œ∑.app (toFunctor.obj X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n  right_unit : ‚àÄ X : C, toFunctor.map (Œ∑.app X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.right_unit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map (self.Œ∑.app X)) (self.Œº.app X)) (CategoryTheory.CategoryStruct.id (self.obj ((CategoryTheory.Functor.id C).obj X)))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nŒ∑ : ùü≠ C ‚ü∂ T and Œº : T ‚ãô T ‚ü∂ T satisfying three equations:\n- T Œº_X ‚â´ Œº_X = Œº_(TX) ‚â´ Œº_X (associativity)\n- Œ∑_(TX) ‚â´ Œº_X = 1_X (left unit)\n- TŒ∑_X ‚â´ Œº_X = 1_X (right unit)\n-/\nstructure Monad extends C ‚•§ C where\n  /-- The unit for the monad. -/\n  Œ∑ : ùü≠ _ ‚ü∂ toFunctor\n  /-- The multiplication for the monad. -/\n  Œº : toFunctor ‚ãô toFunctor ‚ü∂ toFunctor\n  assoc : ‚àÄ X, toFunctor.map (NatTrans.app Œº X) ‚â´ Œº.app _ = Œº.app _ ‚â´ Œº.app _ := by aesop_cat\n  left_unit : ‚àÄ X : C, Œ∑.app (toFunctor.obj X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n  right_unit : ‚àÄ X : C, toFunctor.map (Œ∑.app X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.left_unit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ∑.app (self.obj X)) (self.Œº.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (self.obj X)))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nŒ∑ : ùü≠ C ‚ü∂ T and Œº : T ‚ãô T ‚ü∂ T satisfying three equations:\n- T Œº_X ‚â´ Œº_X = Œº_(TX) ‚â´ Œº_X (associativity)\n- Œ∑_(TX) ‚â´ Œº_X = 1_X (left unit)\n- TŒ∑_X ‚â´ Œº_X = 1_X (right unit)\n-/\nstructure Monad extends C ‚•§ C where\n  /-- The unit for the monad. -/\n  Œ∑ : ùü≠ _ ‚ü∂ toFunctor\n  /-- The multiplication for the monad. -/\n  Œº : toFunctor ‚ãô toFunctor ‚ü∂ toFunctor\n  assoc : ‚àÄ X, toFunctor.map (NatTrans.app Œº X) ‚â´ Œº.app _ = Œº.app _ ‚â´ Œº.app _ := by aesop_cat\n  left_unit : ‚àÄ X : C, Œ∑.app (toFunctor.obj X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n  right_unit : ‚àÄ X : C, toFunctor.map (Œ∑.app X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ntoFunctor‚úù : CategoryTheory.Functor C C\nŒ∑‚úù : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor‚úù\nŒº‚úù : Quiver.Hom (toFunctor‚úù.comp toFunctor‚úù) toFunctor‚úù\nassoc‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor‚úù.map (Œº‚úù.app X)) (Œº‚úù.app X)) (CategoryTheory.CategoryStruct.comp (Œº‚úù.app (toFunctor‚úù.obj X)) (Œº‚úù.app X))) _auto‚úù\nleft_unit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ∑‚úù.app (toFunctor‚úù.obj X)) (Œº‚úù.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor‚úù.obj X)))) _auto‚úù\nright_unit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor‚úù.map (Œ∑‚úù.app X)) (Œº‚úù.app X)) (CategoryTheory.CategoryStruct.id (toFunctor‚úù.obj ((CategoryTheory.Functor.id C).obj X)))) _auto‚úù\ntoFunctor : CategoryTheory.Functor C C\nŒ∑ : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor\nŒº : Quiver.Hom (toFunctor.comp toFunctor) toFunctor\nassoc : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (Œº.app X)) (Œº.app X)) (CategoryTheory.CategoryStruct.comp (Œº.app (toFunctor.obj X)) (Œº.app X))) _auto‚úù\nleft_unit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ∑.app (toFunctor.obj X)) (Œº.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor.obj X)))) _auto‚úù\nright_unit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (Œ∑.app X)) (Œº.app X)) (CategoryTheory.CategoryStruct.id (toFunctor.obj ((CategoryTheory.Functor.id C).obj X)))) _auto‚úù\nx‚úù : Eq { toFunctor := toFunctor‚úù, Œ∑ := Œ∑‚úù, Œº := Œº‚úù, assoc := assoc‚úù, left_unit := left_unit‚úù, right_unit := right_unit‚úù } { toFunctor := toFunctor, Œ∑ := Œ∑, Œº := Œº, assoc := assoc, left_unit := left_unit, right_unit := right_unit }\n‚ä¢ And (Eq toFunctor‚úù toFunctor) (And (HEq Œ∑‚úù Œ∑) (HEq Œº‚úù Œº))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nŒ∑ : ùü≠ C ‚ü∂ T and Œº : T ‚ãô T ‚ü∂ T satisfying three equations:\n- T Œº_X ‚â´ Œº_X = Œº_(TX) ‚â´ Œº_X (associativity)\n- Œ∑_(TX) ‚â´ Œº_X = 1_X (left unit)\n- TŒ∑_X ‚â´ Œº_X = 1_X (right unit)\n-/\nstructure Monad extends C ‚•§ C where\n  /-- The unit for the monad. -/\n  Œ∑ : ùü≠ _ ‚ü∂ toFunctor\n  /-- The multiplication for the monad. -/\n  Œº : toFunctor ‚ãô toFunctor ‚ü∂ toFunctor\n  assoc : ‚àÄ X, toFunctor.map (NatTrans.app Œº X) ‚â´ Œº.app _ = Œº.app _ ‚â´ Œº.app _ := by aesop_cat\n  left_unit : ‚àÄ X : C, Œ∑.app (toFunctor.obj X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n  right_unit : ‚àÄ X : C, toFunctor.map (Œ∑.app X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ntoFunctor‚úù : CategoryTheory.Functor C C\nŒ∑‚úù : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor‚úù\nŒº‚úù : Quiver.Hom (toFunctor‚úù.comp toFunctor‚úù) toFunctor‚úù\nassoc‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor‚úù.map (Œº‚úù.app X)) (Œº‚úù.app X)) (CategoryTheory.CategoryStruct.comp (Œº‚úù.app (toFunctor‚úù.obj X)) (Œº‚úù.app X))) _auto‚úù\nleft_unit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ∑‚úù.app (toFunctor‚úù.obj X)) (Œº‚úù.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor‚úù.obj X)))) _auto‚úù\nright_unit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor‚úù.map (Œ∑‚úù.app X)) (Œº‚úù.app X)) (CategoryTheory.CategoryStruct.id (toFunctor‚úù.obj ((CategoryTheory.Functor.id C).obj X)))) _auto‚úù\ntoFunctor : CategoryTheory.Functor C C\nŒ∑ : Quiver.Hom (CategoryTheory.Functor.id C) toFunctor\nŒº : Quiver.Hom (toFunctor.comp toFunctor) toFunctor\nassoc : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (Œº.app X)) (Œº.app X)) (CategoryTheory.CategoryStruct.comp (Œº.app (toFunctor.obj X)) (Œº.app X))) _auto‚úù\nleft_unit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ∑.app (toFunctor.obj X)) (Œº.app X)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id C).obj (toFunctor.obj X)))) _auto‚úù\nright_unit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toFunctor.map (Œ∑.app X)) (Œº.app X)) (CategoryTheory.CategoryStruct.id (toFunctor.obj ((CategoryTheory.Functor.id C).obj X)))) _auto‚úù\n‚ä¢ Eq (Eq { toFunctor := toFunctor‚úù, Œ∑ := Œ∑‚úù, Œº := Œº‚úù, assoc := assoc‚úù, left_unit := left_unit‚úù, right_unit := right_unit‚úù } { toFunctor := toFunctor, Œ∑ := Œ∑, Œº := Œº, assoc := assoc, left_unit := left_unit, right_unit := right_unit }) (And (Eq toFunctor‚úù toFunctor) (And (HEq Œ∑‚úù Œ∑) (HEq Œº‚úù Œº)))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nŒ∑ : ùü≠ C ‚ü∂ T and Œº : T ‚ãô T ‚ü∂ T satisfying three equations:\n- T Œº_X ‚â´ Œº_X = Œº_(TX) ‚â´ Œº_X (associativity)\n- Œ∑_(TX) ‚â´ Œº_X = 1_X (left unit)\n- TŒ∑_X ‚â´ Œº_X = 1_X (right unit)\n-/\nstructure Monad extends C ‚•§ C where\n  /-- The unit for the monad. -/\n  Œ∑ : ùü≠ _ ‚ü∂ toFunctor\n  /-- The multiplication for the monad. -/\n  Œº : toFunctor ‚ãô toFunctor ‚ü∂ toFunctor\n  assoc : ‚àÄ X, toFunctor.map (NatTrans.app Œº X) ‚â´ Œº.app _ = Œº.app _ ‚â´ Œº.app _ := by aesop_cat\n  left_unit : ‚àÄ X : C, Œ∑.app (toFunctor.obj X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n  right_unit : ‚àÄ X : C, toFunctor.map (Œ∑.app X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map (self.Œº.app X)) (self.Œº.app X)) (CategoryTheory.CategoryStruct.comp (self.Œº.app (self.obj X)) (self.Œº.app X))","decl":"/-- The data of a monad on C consists of an endofunctor T together with natural transformations\nŒ∑ : ùü≠ C ‚ü∂ T and Œº : T ‚ãô T ‚ü∂ T satisfying three equations:\n- T Œº_X ‚â´ Œº_X = Œº_(TX) ‚â´ Œº_X (associativity)\n- Œ∑_(TX) ‚â´ Œº_X = 1_X (left unit)\n- TŒ∑_X ‚â´ Œº_X = 1_X (right unit)\n-/\nstructure Monad extends C ‚•§ C where\n  /-- The unit for the monad. -/\n  Œ∑ : ùü≠ _ ‚ü∂ toFunctor\n  /-- The multiplication for the monad. -/\n  Œº : toFunctor ‚ãô toFunctor ‚ü∂ toFunctor\n  assoc : ‚àÄ X, toFunctor.map (NatTrans.app Œº X) ‚â´ Œº.app _ = Œº.app _ ‚â´ Œº.app _ := by aesop_cat\n  left_unit : ‚àÄ X : C, Œ∑.app (toFunctor.obj X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n  right_unit : ‚àÄ X : C, toFunctor.map (Œ∑.app X) ‚â´ Œº.app _ = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : SizeOf C\ntoFunctor : CategoryTheory.Functor C C\nŒµ : Quiver.Hom toFunctor (CategoryTheory.Functor.id C)\nŒ¥ : Quiver.Hom toFunctor (toFunctor.comp toFunctor)\ncoassoc : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (toFunctor.map (Œ¥.app X))) (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (Œ¥.app (toFunctor.obj X)))) _auto‚úù\nleft_counit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (Œµ.app (toFunctor.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto‚úù\nright_counit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (toFunctor.map (Œµ.app X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toFunctor := toFunctor, Œµ := Œµ, Œ¥ := Œ¥, coassoc := coassoc, left_counit := left_counit, right_counit := right_counit }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toFunctor)) (SizeOf.sizeOf Œµ)) (SizeOf.sizeOf Œ¥))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nŒµ : G ‚ü∂ ùü≠ C and Œ¥ : G ‚ü∂ G ‚ãô G satisfying three equations:\n- Œ¥_X ‚â´ G Œ¥_X = Œ¥_X ‚â´ Œ¥_(GX) (coassociativity)\n- Œ¥_X ‚â´ Œµ_(GX) = 1_X (left counit)\n- Œ¥_X ‚â´ G Œµ_X = 1_X (right counit)\n-/\nstructure Comonad extends C ‚•§ C where\n  /-- The counit for the comonad. -/\n  Œµ : toFunctor ‚ü∂ ùü≠ _\n  /-- The comultiplication for the comonad. -/\n  Œ¥ : toFunctor ‚ü∂ toFunctor ‚ãô toFunctor\n  coassoc : ‚àÄ X, NatTrans.app Œ¥ _ ‚â´ toFunctor.map (Œ¥.app X) = Œ¥.app _ ‚â´ Œ¥.app _ := by\n    aesop_cat\n  left_counit : ‚àÄ X : C, Œ¥.app X ‚â´ Œµ.app (toFunctor.obj X) = ùüô _ := by aesop_cat\n  right_counit : ‚àÄ X : C, Œ¥.app X ‚â´ toFunctor.map (Œµ.app X) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ntoFunctor‚úù : CategoryTheory.Functor C C\nŒµ‚úù : Quiver.Hom toFunctor‚úù (CategoryTheory.Functor.id C)\nŒ¥‚úù : Quiver.Hom toFunctor‚úù (toFunctor‚úù.comp toFunctor‚úù)\ncoassoc‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (toFunctor‚úù.map (Œ¥‚úù.app X))) (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (Œ¥‚úù.app (toFunctor‚úù.obj X)))) _auto‚úù\nleft_counit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (Œµ‚úù.app (toFunctor‚úù.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor‚úù.obj X))) _auto‚úù\nright_counit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (toFunctor‚úù.map (Œµ‚úù.app X))) (CategoryTheory.CategoryStruct.id (toFunctor‚úù.obj X))) _auto‚úù\ntoFunctor : CategoryTheory.Functor C C\nŒµ : Quiver.Hom toFunctor (CategoryTheory.Functor.id C)\nŒ¥ : Quiver.Hom toFunctor (toFunctor.comp toFunctor)\ncoassoc : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (toFunctor.map (Œ¥.app X))) (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (Œ¥.app (toFunctor.obj X)))) _auto‚úù\nleft_counit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (Œµ.app (toFunctor.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto‚úù\nright_counit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (toFunctor.map (Œµ.app X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto‚úù\n‚ä¢ Eq (Eq { toFunctor := toFunctor‚úù, Œµ := Œµ‚úù, Œ¥ := Œ¥‚úù, coassoc := coassoc‚úù, left_counit := left_counit‚úù, right_counit := right_counit‚úù } { toFunctor := toFunctor, Œµ := Œµ, Œ¥ := Œ¥, coassoc := coassoc, left_counit := left_counit, right_counit := right_counit }) (And (Eq toFunctor‚úù toFunctor) (And (HEq Œµ‚úù Œµ) (HEq Œ¥‚úù Œ¥)))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nŒµ : G ‚ü∂ ùü≠ C and Œ¥ : G ‚ü∂ G ‚ãô G satisfying three equations:\n- Œ¥_X ‚â´ G Œ¥_X = Œ¥_X ‚â´ Œ¥_(GX) (coassociativity)\n- Œ¥_X ‚â´ Œµ_(GX) = 1_X (left counit)\n- Œ¥_X ‚â´ G Œµ_X = 1_X (right counit)\n-/\nstructure Comonad extends C ‚•§ C where\n  /-- The counit for the comonad. -/\n  Œµ : toFunctor ‚ü∂ ùü≠ _\n  /-- The comultiplication for the comonad. -/\n  Œ¥ : toFunctor ‚ü∂ toFunctor ‚ãô toFunctor\n  coassoc : ‚àÄ X, NatTrans.app Œ¥ _ ‚â´ toFunctor.map (Œ¥.app X) = Œ¥.app _ ‚â´ Œ¥.app _ := by\n    aesop_cat\n  left_counit : ‚àÄ X : C, Œ¥.app X ‚â´ Œµ.app (toFunctor.obj X) = ùüô _ := by aesop_cat\n  right_counit : ‚àÄ X : C, Œ¥.app X ‚â´ toFunctor.map (Œµ.app X) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.left_counit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (self.Œµ.app (self.obj X))) (CategoryTheory.CategoryStruct.id (self.obj X))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nŒµ : G ‚ü∂ ùü≠ C and Œ¥ : G ‚ü∂ G ‚ãô G satisfying three equations:\n- Œ¥_X ‚â´ G Œ¥_X = Œ¥_X ‚â´ Œ¥_(GX) (coassociativity)\n- Œ¥_X ‚â´ Œµ_(GX) = 1_X (left counit)\n- Œ¥_X ‚â´ G Œµ_X = 1_X (right counit)\n-/\nstructure Comonad extends C ‚•§ C where\n  /-- The counit for the comonad. -/\n  Œµ : toFunctor ‚ü∂ ùü≠ _\n  /-- The comultiplication for the comonad. -/\n  Œ¥ : toFunctor ‚ü∂ toFunctor ‚ãô toFunctor\n  coassoc : ‚àÄ X, NatTrans.app Œ¥ _ ‚â´ toFunctor.map (Œ¥.app X) = Œ¥.app _ ‚â´ Œ¥.app _ := by\n    aesop_cat\n  left_counit : ‚àÄ X : C, Œ¥.app X ‚â´ Œµ.app (toFunctor.obj X) = ùüô _ := by aesop_cat\n  right_counit : ‚àÄ X : C, Œ¥.app X ‚â´ toFunctor.map (Œµ.app X) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ntoFunctor‚úù : CategoryTheory.Functor C C\nŒµ‚úù : Quiver.Hom toFunctor‚úù (CategoryTheory.Functor.id C)\nŒ¥‚úù : Quiver.Hom toFunctor‚úù (toFunctor‚úù.comp toFunctor‚úù)\ncoassoc‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (toFunctor‚úù.map (Œ¥‚úù.app X))) (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (Œ¥‚úù.app (toFunctor‚úù.obj X)))) _auto‚úù\nleft_counit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (Œµ‚úù.app (toFunctor‚úù.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor‚úù.obj X))) _auto‚úù\nright_counit‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥‚úù.app X) (toFunctor‚úù.map (Œµ‚úù.app X))) (CategoryTheory.CategoryStruct.id (toFunctor‚úù.obj X))) _auto‚úù\ntoFunctor : CategoryTheory.Functor C C\nŒµ : Quiver.Hom toFunctor (CategoryTheory.Functor.id C)\nŒ¥ : Quiver.Hom toFunctor (toFunctor.comp toFunctor)\ncoassoc : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (toFunctor.map (Œ¥.app X))) (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (Œ¥.app (toFunctor.obj X)))) _auto‚úù\nleft_counit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (Œµ.app (toFunctor.obj X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto‚úù\nright_counit : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (Œ¥.app X) (toFunctor.map (Œµ.app X))) (CategoryTheory.CategoryStruct.id (toFunctor.obj X))) _auto‚úù\nx‚úù : Eq { toFunctor := toFunctor‚úù, Œµ := Œµ‚úù, Œ¥ := Œ¥‚úù, coassoc := coassoc‚úù, left_counit := left_counit‚úù, right_counit := right_counit‚úù } { toFunctor := toFunctor, Œµ := Œµ, Œ¥ := Œ¥, coassoc := coassoc, left_counit := left_counit, right_counit := right_counit }\n‚ä¢ And (Eq toFunctor‚úù toFunctor) (And (HEq Œµ‚úù Œµ) (HEq Œ¥‚úù Œ¥))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nŒµ : G ‚ü∂ ùü≠ C and Œ¥ : G ‚ü∂ G ‚ãô G satisfying three equations:\n- Œ¥_X ‚â´ G Œ¥_X = Œ¥_X ‚â´ Œ¥_(GX) (coassociativity)\n- Œ¥_X ‚â´ Œµ_(GX) = 1_X (left counit)\n- Œ¥_X ‚â´ G Œµ_X = 1_X (right counit)\n-/\nstructure Comonad extends C ‚•§ C where\n  /-- The counit for the comonad. -/\n  Œµ : toFunctor ‚ü∂ ùü≠ _\n  /-- The comultiplication for the comonad. -/\n  Œ¥ : toFunctor ‚ü∂ toFunctor ‚ãô toFunctor\n  coassoc : ‚àÄ X, NatTrans.app Œ¥ _ ‚â´ toFunctor.map (Œ¥.app X) = Œ¥.app _ ‚â´ Œ¥.app _ := by\n    aesop_cat\n  left_counit : ‚àÄ X : C, Œ¥.app X ‚â´ Œµ.app (toFunctor.obj X) = ùüô _ := by aesop_cat\n  right_counit : ‚àÄ X : C, Œ¥.app X ‚â´ toFunctor.map (Œµ.app X) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.right_counit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (self.map (self.Œµ.app X))) (CategoryTheory.CategoryStruct.id (self.obj X))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nŒµ : G ‚ü∂ ùü≠ C and Œ¥ : G ‚ü∂ G ‚ãô G satisfying three equations:\n- Œ¥_X ‚â´ G Œ¥_X = Œ¥_X ‚â´ Œ¥_(GX) (coassociativity)\n- Œ¥_X ‚â´ Œµ_(GX) = 1_X (left counit)\n- Œ¥_X ‚â´ G Œµ_X = 1_X (right counit)\n-/\nstructure Comonad extends C ‚•§ C where\n  /-- The counit for the comonad. -/\n  Œµ : toFunctor ‚ü∂ ùü≠ _\n  /-- The comultiplication for the comonad. -/\n  Œ¥ : toFunctor ‚ü∂ toFunctor ‚ãô toFunctor\n  coassoc : ‚àÄ X, NatTrans.app Œ¥ _ ‚â´ toFunctor.map (Œ¥.app X) = Œ¥.app _ ‚â´ Œ¥.app _ := by\n    aesop_cat\n  left_counit : ‚àÄ X : C, Œ¥.app X ‚â´ Œµ.app (toFunctor.obj X) = ùüô _ := by aesop_cat\n  right_counit : ‚àÄ X : C, Œ¥.app X ‚â´ toFunctor.map (Œµ.app X) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Comonad.coassoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (self.map (self.Œ¥.app X))) (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (self.Œ¥.app (self.obj X)))","decl":"/-- The data of a comonad on C consists of an endofunctor G together with natural transformations\nŒµ : G ‚ü∂ ùü≠ C and Œ¥ : G ‚ü∂ G ‚ãô G satisfying three equations:\n- Œ¥_X ‚â´ G Œ¥_X = Œ¥_X ‚â´ Œ¥_(GX) (coassociativity)\n- Œ¥_X ‚â´ Œµ_(GX) = 1_X (left counit)\n- Œ¥_X ‚â´ G Œµ_X = 1_X (right counit)\n-/\nstructure Comonad extends C ‚•§ C where\n  /-- The counit for the comonad. -/\n  Œµ : toFunctor ‚ü∂ ùü≠ _\n  /-- The comultiplication for the comonad. -/\n  Œ¥ : toFunctor ‚ü∂ toFunctor ‚ãô toFunctor\n  coassoc : ‚àÄ X, NatTrans.app Œ¥ _ ‚â´ toFunctor.map (Œ¥.app X) = Œ¥.app _ ‚â´ Œ¥.app _ := by\n    aesop_cat\n  left_counit : ‚àÄ X : C, Œ¥.app X ‚â´ Œµ.app (toFunctor.obj X) = ùüô _ := by aesop_cat\n  right_counit : ‚àÄ X : C, Œ¥.app X ‚â´ toFunctor.map (Œµ.app X) = ùüô _ := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.right_unit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Monad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.map (self.Œ∑.app X)) (CategoryTheory.CategoryStruct.comp (self.Œº.app X) h)) h","decl":"attribute [reassoc (attr := simp)] Monad.left_unit Monad.right_unit\n"}
{"name":"CategoryTheory.Monad.left_unit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Monad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ∑.app (self.obj X)) (CategoryTheory.CategoryStruct.comp (self.Œº.app X) h)) h","decl":"attribute [reassoc (attr := simp)] Monad.left_unit Monad.right_unit\n"}
{"name":"CategoryTheory.Comonad.coassoc_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Comonad C\nX Z : C\nh : Quiver.Hom (self.obj (self.obj (self.obj X))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (self.map (self.Œ¥.app X)) h)) (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (self.Œ¥.app (self.obj X)) h))","decl":"attribute [reassoc (attr := simp)] Comonad.coassoc Comonad.left_counit Comonad.right_counit\n\n"}
{"name":"CategoryTheory.Comonad.right_counit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Comonad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (self.map (self.Œµ.app X)) h)) h","decl":"attribute [reassoc (attr := simp)] Comonad.coassoc Comonad.left_counit Comonad.right_counit\n\n"}
{"name":"CategoryTheory.Comonad.left_counit_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nself : CategoryTheory.Comonad C\nX Z : C\nh : Quiver.Hom (self.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (self.Œµ.app (self.obj X)) h)) h","decl":"attribute [reassoc (attr := simp)] Comonad.coassoc Comonad.left_counit Comonad.right_counit\n\n"}
{"name":"CategoryTheory.MonadHom.app_Œ∑","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (self.app X)) (T‚ÇÇ.Œ∑.app X)","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nx y : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ\n‚ä¢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.app_Œº","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (self.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (self.app X)) (self.app (T‚ÇÇ.obj X))) (T‚ÇÇ.Œº.app X))","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.ext","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nx y : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ\napp : Eq x.app y.app\n‚ä¢ Eq x y","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\ntoNatTrans‚úù : CategoryTheory.NatTrans T‚ÇÅ.toFunctor T‚ÇÇ.toFunctor\napp_Œ∑‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (toNatTrans‚úù.app X)) (T‚ÇÇ.Œ∑.app X)) _auto‚úù\napp_Œº‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (toNatTrans‚úù.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (toNatTrans‚úù.app X)) (toNatTrans‚úù.app (T‚ÇÇ.obj X))) (T‚ÇÇ.Œº.app X))) _auto‚úù\ntoNatTrans : CategoryTheory.NatTrans T‚ÇÅ.toFunctor T‚ÇÇ.toFunctor\napp_Œ∑ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (toNatTrans.app X)) (T‚ÇÇ.Œ∑.app X)) _auto‚úù\napp_Œº : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (toNatTrans.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (toNatTrans.app X)) (toNatTrans.app (T‚ÇÇ.obj X))) (T‚ÇÇ.Œº.app X))) _auto‚úù\n‚ä¢ Eq (Eq { toNatTrans := toNatTrans‚úù, app_Œ∑ := app_Œ∑‚úù, app_Œº := app_Œº‚úù } { toNatTrans := toNatTrans, app_Œ∑ := app_Œ∑, app_Œº := app_Œº }) (Eq toNatTrans‚úù toNatTrans)","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\ninst‚úù : SizeOf C\ntoNatTrans : CategoryTheory.NatTrans T‚ÇÅ.toFunctor T‚ÇÇ.toFunctor\napp_Œ∑ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (toNatTrans.app X)) (T‚ÇÇ.Œ∑.app X)) _auto‚úù\napp_Œº : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (toNatTrans.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (toNatTrans.app X)) (toNatTrans.app (T‚ÇÇ.obj X))) (T‚ÇÇ.Œº.app X))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toNatTrans := toNatTrans, app_Œ∑ := app_Œ∑, app_Œº := app_Œº }) (HAdd.hAdd 1 (SizeOf.sizeOf toNatTrans))","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\ntoNatTrans‚úù : CategoryTheory.NatTrans T‚ÇÅ.toFunctor T‚ÇÇ.toFunctor\napp_Œ∑‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (toNatTrans‚úù.app X)) (T‚ÇÇ.Œ∑.app X)) _auto‚úù\napp_Œº‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (toNatTrans‚úù.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (toNatTrans‚úù.app X)) (toNatTrans‚úù.app (T‚ÇÇ.obj X))) (T‚ÇÇ.Œº.app X))) _auto‚úù\ntoNatTrans : CategoryTheory.NatTrans T‚ÇÅ.toFunctor T‚ÇÇ.toFunctor\napp_Œ∑ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (toNatTrans.app X)) (T‚ÇÇ.Œ∑.app X)) _auto‚úù\napp_Œº : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (toNatTrans.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (toNatTrans.app X)) (toNatTrans.app (T‚ÇÇ.obj X))) (T‚ÇÇ.Œº.app X))) _auto‚úù\nx‚úù : Eq { toNatTrans := toNatTrans‚úù, app_Œ∑ := app_Œ∑‚úù, app_Œº := app_Œº‚úù } { toNatTrans := toNatTrans, app_Œ∑ := app_Œ∑, app_Œº := app_Œº }\n‚ä¢ Eq toNatTrans‚úù toNatTrans","decl":"/-- A morphism of monads is a natural transformation compatible with Œ∑ and Œº. -/\n@[ext]\nstructure MonadHom (T‚ÇÅ T‚ÇÇ : Monad C) extends NatTrans (T‚ÇÅ : C ‚•§ C) T‚ÇÇ where\n  app_Œ∑ : ‚àÄ X, T‚ÇÅ.Œ∑.app X ‚â´ app X = T‚ÇÇ.Œ∑.app X := by aesop_cat\n  app_Œº : ‚àÄ X, T‚ÇÅ.Œº.app X ‚â´ app X = (T‚ÇÅ.map (app X) ‚â´ app _) ‚â´ T‚ÇÇ.Œº.app X := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\ntoNatTrans‚úù : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_Œµ‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans‚úù.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\napp_Œ¥‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans‚úù.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans‚úù.app (M.obj X)) (N.map (toNatTrans‚úù.app X))))) _auto‚úù\ntoNatTrans : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_Œµ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\napp_Œ¥ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans.app (M.obj X)) (N.map (toNatTrans.app X))))) _auto‚úù\n‚ä¢ Eq (Eq { toNatTrans := toNatTrans‚úù, app_Œµ := app_Œµ‚úù, app_Œ¥ := app_Œ¥‚úù } { toNatTrans := toNatTrans, app_Œµ := app_Œµ, app_Œ¥ := app_Œ¥ }) (Eq toNatTrans‚úù toNatTrans)","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\ntoNatTrans‚úù : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_Œµ‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans‚úù.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\napp_Œ¥‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans‚úù.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans‚úù.app (M.obj X)) (N.map (toNatTrans‚úù.app X))))) _auto‚úù\ntoNatTrans : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_Œµ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\napp_Œ¥ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans.app (M.obj X)) (N.map (toNatTrans.app X))))) _auto‚úù\nx‚úù : Eq { toNatTrans := toNatTrans‚úù, app_Œµ := app_Œµ‚úù, app_Œ¥ := app_Œ¥‚úù } { toNatTrans := toNatTrans, app_Œµ := app_Œµ, app_Œ¥ := app_Œ¥ }\n‚ä¢ Eq toNatTrans‚úù toNatTrans","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nx y : CategoryTheory.ComonadHom M N\n‚ä¢ Iff (Eq x y) (Eq x.app y.app)","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.app_Œ¥","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (self.app (M.obj X)) (N.map (self.app X))))","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.ext","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nx y : CategoryTheory.ComonadHom M N\napp : Eq x.app y.app\n‚ä¢ Eq x y","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\ninst‚úù : SizeOf C\ntoNatTrans : CategoryTheory.NatTrans M.toFunctor N.toFunctor\napp_Œµ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\napp_Œ¥ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (toNatTrans.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (toNatTrans.app (M.obj X)) (N.map (toNatTrans.app X))))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toNatTrans := toNatTrans, app_Œµ := app_Œµ, app_Œ¥ := app_Œ¥ }) (HAdd.hAdd 1 (SizeOf.sizeOf toNatTrans))","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.ComonadHom.app_Œµ","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (N.Œµ.app X)) (M.Œµ.app X)","decl":"/-- A morphism of comonads is a natural transformation compatible with Œµ and Œ¥. -/\n@[ext]\nstructure ComonadHom (M N : Comonad C) extends NatTrans (M : C ‚•§ C) N where\n  app_Œµ : ‚àÄ X, app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat\n  app_Œ¥ : ‚àÄ X, app X ‚â´ N.Œ¥.app X = M.Œ¥.app X ‚â´ app _ ‚â´ N.map (app X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.MonadHom.app_Œº_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ\nX Z : C\nh : Quiver.Hom (T‚ÇÇ.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œº.app X) (CategoryTheory.CategoryStruct.comp (self.app X) h)) (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.map (self.app X)) (CategoryTheory.CategoryStruct.comp (self.app (T‚ÇÇ.obj X)) (CategoryTheory.CategoryStruct.comp (T‚ÇÇ.Œº.app X) h)))","decl":"attribute [reassoc (attr := simp)] MonadHom.app_Œ∑ MonadHom.app_Œº\n"}
{"name":"CategoryTheory.MonadHom.app_Œ∑_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nself : CategoryTheory.MonadHom T‚ÇÅ T‚ÇÇ\nX Z : C\nh : Quiver.Hom (T‚ÇÇ.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T‚ÇÅ.Œ∑.app X) (CategoryTheory.CategoryStruct.comp (self.app X) h)) (CategoryTheory.CategoryStruct.comp (T‚ÇÇ.Œ∑.app X) h)","decl":"attribute [reassoc (attr := simp)] MonadHom.app_Œ∑ MonadHom.app_Œº\n"}
{"name":"CategoryTheory.ComonadHom.app_Œ¥_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX Z : C\nh : Quiver.Hom (N.obj (N.obj X)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (CategoryTheory.CategoryStruct.comp (N.Œ¥.app X) h)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (self.app (M.obj X)) (CategoryTheory.CategoryStruct.comp (N.map (self.app X)) h)))","decl":"attribute [reassoc (attr := simp)] ComonadHom.app_Œµ ComonadHom.app_Œ¥\n\n"}
{"name":"CategoryTheory.ComonadHom.app_Œµ_assoc","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nself : CategoryTheory.ComonadHom M N\nX Z : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.app X) (CategoryTheory.CategoryStruct.comp (N.Œµ.app X) h)) (CategoryTheory.CategoryStruct.comp (M.Œµ.app X) h)","decl":"attribute [reassoc (attr := simp)] ComonadHom.app_Œµ ComonadHom.app_Œ¥\n\n"}
{"name":"CategoryTheory.MonadHom.ext'","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nf g : Quiver.Hom T‚ÇÅ T‚ÇÇ\nh : Eq f.app g.app\n‚ä¢ Eq f g","decl":"@[ext]\nlemma MonadHom.ext' {T‚ÇÅ T‚ÇÇ : Monad C} (f g : T‚ÇÅ ‚ü∂ T‚ÇÇ) (h : f.app = g.app) : f = g :=\n  MonadHom.ext h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.MonadHom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nf g : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Iff (Eq f g) (Eq f.app g.app)","decl":"@[ext]\nlemma MonadHom.ext' {T‚ÇÅ T‚ÇÇ : Monad C} (f g : T‚ÇÅ ‚ü∂ T‚ÇÇ) (h : f.app = g.app) : f = g :=\n  MonadHom.ext h\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): added to ease automation\n"}
{"name":"CategoryTheory.ComonadHom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Comonad C\nf g : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Iff (Eq f g) (Eq f.app g.app)","decl":"@[ext]\nlemma ComonadHom.ext' {T‚ÇÅ T‚ÇÇ : Comonad C} (f g : T‚ÇÅ ‚ü∂ T‚ÇÇ) (h : f.app = g.app) : f = g :=\n  ComonadHom.ext h\n\n"}
{"name":"CategoryTheory.ComonadHom.ext'","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Comonad C\nf g : Quiver.Hom T‚ÇÅ T‚ÇÇ\nh : Eq f.app g.app\n‚ä¢ Eq f g","decl":"@[ext]\nlemma ComonadHom.ext' {T‚ÇÅ T‚ÇÇ : Comonad C} (f g : T‚ÇÅ ‚ü∂ T‚ÇÇ) (h : f.app = g.app) : f = g :=\n  ComonadHom.ext h\n\n"}
{"name":"CategoryTheory.MonadHom.id_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id T).toNatTrans (CategoryTheory.CategoryStruct.id T.toFunctor)","decl":"@[simp]\ntheorem MonadHom.id_toNatTrans (T : Monad C) : (ùüô T : T ‚ü∂ T).toNatTrans = ùüô (T : C ‚•§ C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonadHom.comp_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ T‚ÇÉ : CategoryTheory.Monad C\nf : Quiver.Hom T‚ÇÅ T‚ÇÇ\ng : Quiver.Hom T‚ÇÇ T‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).toNatTrans (CategoryTheory.CategoryStruct.comp f.toNatTrans g.toNatTrans)","decl":"@[simp]\ntheorem MonadHom.comp_toNatTrans {T‚ÇÅ T‚ÇÇ T‚ÇÉ : Monad C} (f : T‚ÇÅ ‚ü∂ T‚ÇÇ) (g : T‚ÇÇ ‚ü∂ T‚ÇÉ) :\n    (f ‚â´ g).toNatTrans = ((f.toNatTrans : _ ‚ü∂ (T‚ÇÇ : C ‚•§ C)) ‚â´ g.toNatTrans : (T‚ÇÅ : C ‚•§ C) ‚ü∂ T‚ÇÉ) :=\n  rfl\n\n"}
{"name":"CategoryTheory.ComonadHom.id_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Comonad C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id T).toNatTrans (CategoryTheory.CategoryStruct.id T.toFunctor)","decl":"@[simp]\ntheorem ComonadHom.id_toNatTrans (T : Comonad C) : (ùüô T : T ‚ü∂ T).toNatTrans = ùüô (T : C ‚•§ C) :=\n  rfl\n\n"}
{"name":"CategoryTheory.comp_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ T‚ÇÉ : CategoryTheory.Comonad C\nf : Quiver.Hom T‚ÇÅ T‚ÇÇ\ng : Quiver.Hom T‚ÇÇ T‚ÇÉ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).toNatTrans (CategoryTheory.CategoryStruct.comp f.toNatTrans g.toNatTrans)","decl":"@[simp]\ntheorem comp_toNatTrans {T‚ÇÅ T‚ÇÇ T‚ÇÉ : Comonad C} (f : T‚ÇÅ ‚ü∂ T‚ÇÇ) (g : T‚ÇÇ ‚ü∂ T‚ÇÉ) :\n    (f ‚â´ g).toNatTrans = ((f.toNatTrans : _ ‚ü∂ (T‚ÇÇ : C ‚•§ C)) ‚â´ g.toNatTrans : (T‚ÇÅ : C ‚•§ C) ‚ü∂ T‚ÇÉ) :=\n  rfl\n\n"}
{"name":"CategoryTheory.MonadIso.mk_inv_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Monad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_Œ∑ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.Œ∑.app X) (f.hom.app X)) (N.Œ∑.app X)) _auto‚úù\nf_Œº : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.Œº.app X) (f.hom.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X))) (N.Œº.app X))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MonadIso.mk f f_Œ∑ f_Œº).inv.toNatTrans f.inv","decl":"/-- Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. -/\n@[simps]\ndef MonadIso.mk {M N : Monad C} (f : (M : C ‚•§ C) ‚âÖ N)\n    (f_Œ∑ : ‚àÄ (X : C), M.Œ∑.app X ‚â´ f.hom.app X = N.Œ∑.app X := by aesop_cat)\n    (f_Œº : ‚àÄ (X : C), M.Œº.app X ‚â´ f.hom.app X =\n    (M.map (f.hom.app X) ‚â´ f.hom.app (N.obj X)) ‚â´ N.Œº.app X := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_Œ∑ := f_Œ∑\n      app_Œº := f_Œº }\n  inv :=\n    { toNatTrans := f.inv\n      app_Œ∑ := fun X => by simp [‚Üê f_Œ∑]\n      app_Œº := fun X => by\n        rw [‚Üê NatIso.cancel_natIso_hom_right f]\n        simp only [NatTrans.naturality, Iso.inv_hom_id_app, assoc, comp_id, f_Œº,\n          NatTrans.naturality_assoc, Iso.inv_hom_id_app_assoc, ‚Üê Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.MonadIso.mk_hom_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Monad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_Œ∑ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.Œ∑.app X) (f.hom.app X)) (N.Œ∑.app X)) _auto‚úù\nf_Œº : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.Œº.app X) (f.hom.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X))) (N.Œº.app X))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.MonadIso.mk f f_Œ∑ f_Œº).hom.toNatTrans f.hom","decl":"/-- Construct a monad isomorphism from a natural isomorphism of functors where the forward\ndirection is a monad morphism. -/\n@[simps]\ndef MonadIso.mk {M N : Monad C} (f : (M : C ‚•§ C) ‚âÖ N)\n    (f_Œ∑ : ‚àÄ (X : C), M.Œ∑.app X ‚â´ f.hom.app X = N.Œ∑.app X := by aesop_cat)\n    (f_Œº : ‚àÄ (X : C), M.Œº.app X ‚â´ f.hom.app X =\n    (M.map (f.hom.app X) ‚â´ f.hom.app (N.obj X)) ‚â´ N.Œº.app X := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_Œ∑ := f_Œ∑\n      app_Œº := f_Œº }\n  inv :=\n    { toNatTrans := f.inv\n      app_Œ∑ := fun X => by simp [‚Üê f_Œ∑]\n      app_Œº := fun X => by\n        rw [‚Üê NatIso.cancel_natIso_hom_right f]\n        simp only [NatTrans.naturality, Iso.inv_hom_id_app, assoc, comp_id, f_Œº,\n          NatTrans.naturality_assoc, Iso.inv_hom_id_app_assoc, ‚Üê Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.ComonadIso.mk_hom_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_Œµ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\nf_Œ¥ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (f.hom.app (M.obj X)) (N.map (f.hom.app X))))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.ComonadIso.mk f f_Œµ f_Œ¥).hom.toNatTrans f.hom","decl":"/-- Construct a comonad isomorphism from a natural isomorphism of functors where the forward\ndirection is a comonad morphism. -/\n@[simps]\ndef ComonadIso.mk {M N : Comonad C} (f : (M : C ‚•§ C) ‚âÖ N)\n    (f_Œµ : ‚àÄ (X : C), f.hom.app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat)\n    (f_Œ¥ : ‚àÄ (X : C), f.hom.app X ‚â´ N.Œ¥.app X =\n    M.Œ¥.app X ‚â´ f.hom.app (M.obj X) ‚â´ N.map (f.hom.app X) := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_Œµ := f_Œµ\n      app_Œ¥ := f_Œ¥ }\n  inv :=\n    { toNatTrans := f.inv\n      app_Œµ := fun X => by simp [‚Üê f_Œµ]\n      app_Œ¥ := fun X => by\n        rw [‚Üê NatIso.cancel_natIso_hom_left f]\n        simp only [reassoc_of% (f_Œ¥ X), Iso.hom_inv_id_app_assoc, NatTrans.naturality_assoc]\n        rw [‚Üê Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n        apply (comp_id _).symm }\n\n"}
{"name":"CategoryTheory.ComonadIso.mk_inv_toNatTrans","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_Œµ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.Œµ.app X)) (M.Œµ.app X)) _auto‚úù\nf_Œ¥ : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (f.hom.app (M.obj X)) (N.map (f.hom.app X))))) _auto‚úù\n‚ä¢ Eq (CategoryTheory.ComonadIso.mk f f_Œµ f_Œ¥).inv.toNatTrans f.inv","decl":"/-- Construct a comonad isomorphism from a natural isomorphism of functors where the forward\ndirection is a comonad morphism. -/\n@[simps]\ndef ComonadIso.mk {M N : Comonad C} (f : (M : C ‚•§ C) ‚âÖ N)\n    (f_Œµ : ‚àÄ (X : C), f.hom.app X ‚â´ N.Œµ.app X = M.Œµ.app X := by aesop_cat)\n    (f_Œ¥ : ‚àÄ (X : C), f.hom.app X ‚â´ N.Œ¥.app X =\n    M.Œ¥.app X ‚â´ f.hom.app (M.obj X) ‚â´ N.map (f.hom.app X) := by aesop_cat) : M ‚âÖ N where\n  hom :=\n    { toNatTrans := f.hom\n      app_Œµ := f_Œµ\n      app_Œ¥ := f_Œ¥ }\n  inv :=\n    { toNatTrans := f.inv\n      app_Œµ := fun X => by simp [‚Üê f_Œµ]\n      app_Œ¥ := fun X => by\n        rw [‚Üê NatIso.cancel_natIso_hom_left f]\n        simp only [reassoc_of% (f_Œ¥ X), Iso.hom_inv_id_app_assoc, NatTrans.naturality_assoc]\n        rw [‚Üê Functor.map_comp, Iso.hom_inv_id_app, Functor.map_id]\n        apply (comp_id _).symm }\n\n"}
{"name":"CategoryTheory.monadToFunctor_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ Eq ((CategoryTheory.monadToFunctor C).obj T) T.toFunctor","decl":"/-- The forgetful functor from the category of monads to the category of endofunctors.\n-/\n@[simps!]\ndef monadToFunctor : Monad C ‚•§ C ‚•§ C where\n  obj T := T\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.monadToFunctor_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.Monad C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.monadToFunctor C).map f) f.toNatTrans","decl":"/-- The forgetful functor from the category of monads to the category of endofunctors.\n-/\n@[simps!]\ndef monadToFunctor : Monad C ‚•§ C ‚•§ C where\n  obj T := T\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.instFaithfulMonadFunctorMonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.monadToFunctor C).Faithful","decl":"instance : (monadToFunctor C).Faithful where\n\n"}
{"name":"CategoryTheory.monadToFunctor_mapIso_monad_iso_mk","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Monad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_Œ∑ : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.Œ∑.app X) (f.hom.app X)) (N.Œ∑.app X)\nf_Œº : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (M.Œº.app X) (f.hom.app X)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp (M.map (f.hom.app X)) (f.hom.app (N.obj X))) (N.Œº.app X))\n‚ä¢ Eq ((CategoryTheory.monadToFunctor C).mapIso (CategoryTheory.MonadIso.mk f f_Œ∑ f_Œº)) f","decl":"theorem monadToFunctor_mapIso_monad_iso_mk {M N : Monad C} (f : (M : C ‚•§ C) ‚âÖ N) (f_Œ∑ f_Œº) :\n    (monadToFunctor _).mapIso (MonadIso.mk f f_Œ∑ f_Œº) = f := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsMonadFunctorMonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.monadToFunctor C).ReflectsIsomorphisms","decl":"instance : (monadToFunctor C).ReflectsIsomorphisms where\n  reflects f _ := (MonadIso.mk (asIso ((monadToFunctor C).map f)) f.app_Œ∑ f.app_Œº).isIso_hom\n\n"}
{"name":"CategoryTheory.comonadToFunctor_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ Eq ((CategoryTheory.comonadToFunctor C).obj G) G.toFunctor","decl":"/-- The forgetful functor from the category of comonads to the category of endofunctors.\n-/\n@[simps!]\ndef comonadToFunctor : Comonad C ‚•§ C ‚•§ C where\n  obj G := G\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.comonadToFunctor_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : CategoryTheory.Comonad C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.comonadToFunctor C).map f) f.toNatTrans","decl":"/-- The forgetful functor from the category of comonads to the category of endofunctors.\n-/\n@[simps!]\ndef comonadToFunctor : Comonad C ‚•§ C ‚•§ C where\n  obj G := G\n  map f := f.toNatTrans\n\n"}
{"name":"CategoryTheory.instFaithfulComonadFunctorComonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.comonadToFunctor C).Faithful","decl":"instance : (comonadToFunctor C).Faithful where\n\n"}
{"name":"CategoryTheory.comonadToFunctor_mapIso_comonad_iso_mk","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nf : CategoryTheory.Iso M.toFunctor N.toFunctor\nf_Œµ : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.Œµ.app X)) (M.Œµ.app X)\nf_Œ¥ : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (f.hom.app X) (N.Œ¥.app X)) (CategoryTheory.CategoryStruct.comp (M.Œ¥.app X) (CategoryTheory.CategoryStruct.comp (f.hom.app (M.obj X)) (N.map (f.hom.app X))))\n‚ä¢ Eq ((CategoryTheory.comonadToFunctor C).mapIso (CategoryTheory.ComonadIso.mk f f_Œµ f_Œ¥)) f","decl":"theorem comonadToFunctor_mapIso_comonad_iso_mk {M N : Comonad C} (f : (M : C ‚•§ C) ‚âÖ N) (f_Œµ f_Œ¥) :\n    (comonadToFunctor _).mapIso (ComonadIso.mk f f_Œµ f_Œ¥) = f := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.instReflectsIsomorphismsComonadFunctorComonadToFunctor","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.comonadToFunctor C).ReflectsIsomorphisms","decl":"instance : (comonadToFunctor C).ReflectsIsomorphisms where\n  reflects f _ := (ComonadIso.mk (asIso ((comonadToFunctor C).map f)) f.app_Œµ f.app_Œ¥).isIso_hom\n\n"}
{"name":"CategoryTheory.MonadIso.toNatIso_hom","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Monad C\nh : CategoryTheory.Iso M N\n‚ä¢ Eq (CategoryTheory.MonadIso.toNatIso h).hom h.hom.toNatTrans","decl":"/-- An isomorphism of monads gives a natural isomorphism of the underlying functors.\n-/\n/- Porting note: removed\n`@[simps (config := { rhsMd := semireducible })]`\nand replaced with `@[simps]` in the two declarations below -/\n@[simps!]\ndef MonadIso.toNatIso {M N : Monad C} (h : M ‚âÖ N) : (M : C ‚•§ C) ‚âÖ N :=\n  (monadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.MonadIso.toNatIso_inv","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Monad C\nh : CategoryTheory.Iso M N\n‚ä¢ Eq (CategoryTheory.MonadIso.toNatIso h).inv h.inv.toNatTrans","decl":"/-- An isomorphism of monads gives a natural isomorphism of the underlying functors.\n-/\n/- Porting note: removed\n`@[simps (config := { rhsMd := semireducible })]`\nand replaced with `@[simps]` in the two declarations below -/\n@[simps!]\ndef MonadIso.toNatIso {M N : Monad C} (h : M ‚âÖ N) : (M : C ‚•§ C) ‚âÖ N :=\n  (monadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.ComonadIso.toNatIso_hom","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nh : CategoryTheory.Iso M N\n‚ä¢ Eq (CategoryTheory.ComonadIso.toNatIso h).hom h.hom.toNatTrans","decl":"/-- An isomorphism of comonads gives a natural isomorphism of the underlying functors.\n-/\n@[simps!]\ndef ComonadIso.toNatIso {M N : Comonad C} (h : M ‚âÖ N) : (M : C ‚•§ C) ‚âÖ N :=\n  (comonadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.ComonadIso.toNatIso_inv","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nM N : CategoryTheory.Comonad C\nh : CategoryTheory.Iso M N\n‚ä¢ Eq (CategoryTheory.ComonadIso.toNatIso h).inv h.inv.toNatTrans","decl":"/-- An isomorphism of comonads gives a natural isomorphism of the underlying functors.\n-/\n@[simps!]\ndef ComonadIso.toNatIso {M N : Comonad C} (h : M ‚âÖ N) : (M : C ‚•§ C) ‚âÖ N :=\n  (comonadToFunctor C).mapIso h\n\n"}
{"name":"CategoryTheory.Monad.id_Œº_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Monad.id C).Œº.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := ùü≠ C\n  Œ∑ := ùüô (ùü≠ C)\n  Œº := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Monad.id_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Monad.id C).map f) f","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := ùü≠ C\n  Œ∑ := ùüô (ùü≠ C)\n  Œº := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Monad.id_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Monad.id C).obj X) X","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := ùü≠ C\n  Œ∑ := ùüô (ùü≠ C)\n  Œº := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Monad.id_Œ∑_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Monad.id C).Œ∑.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity monad. -/\n@[simps!]\ndef id : Monad C where\n  toFunctor := ùü≠ C\n  Œ∑ := ùüô (ùü≠ C)\n  Œº := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Comonad.id_obj","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Comonad.id C).obj X) X","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := ùü≠ _\n  Œµ := ùüô (ùü≠ C)\n  Œ¥ := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Comonad.id_map","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Comonad.id C).map f) f","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := ùü≠ _\n  Œµ := ùüô (ùü≠ C)\n  Œ¥ := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Comonad.id_Œ¥_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Comonad.id C).Œ¥.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := ùü≠ _\n  Œµ := ùüô (ùü≠ C)\n  Œ¥ := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Comonad.id_Œµ_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq ((CategoryTheory.Comonad.id C).Œµ.app X) (CategoryTheory.CategoryStruct.id X)","decl":"/-- The identity comonad. -/\n@[simps!]\ndef id : Comonad C where\n  toFunctor := ùü≠ _\n  Œµ := ùüô (ùü≠ C)\n  Œ¥ := ùüô (ùü≠ C)\n\n"}
{"name":"CategoryTheory.Monad.map_unit_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX : C\ninst‚úù : CategoryTheory.IsIso T.Œº\n‚ä¢ Eq (T.map (T.Œ∑.app X)) (T.Œ∑.app (T.obj X))","decl":"lemma map_unit_app (T : Monad C) (X : C) [IsIso T.Œº] :\n    T.map (T.Œ∑.app X) = T.Œ∑.app (T.obj X) := by\n  simp [‚Üê cancel_mono (T.Œº.app _)]\n\n"}
{"name":"CategoryTheory.Monad.isSplitMono_iff_isIso_unit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX : C\ninst‚úù : CategoryTheory.IsIso T.Œº\n‚ä¢ Iff (CategoryTheory.IsSplitMono (T.Œ∑.app X)) (CategoryTheory.IsIso (T.Œ∑.app X))","decl":"lemma isSplitMono_iff_isIso_unit (T : Monad C) (X : C) [IsIso T.Œº] :\n    IsSplitMono (T.Œ∑.app X) ‚Üî IsIso (T.Œ∑.app X) := by\n  refine ‚ü®fun _ ‚Ü¶ ‚ü®retraction (T.Œ∑.app X), by simp, ?_‚ü©, fun _ ‚Ü¶ inferInstance‚ü©\n  erw [‚Üê map_id, ‚Üê IsSplitMono.id (T.Œ∑.app X), map_comp, T.map_unit_app X, T.Œ∑.naturality]\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.map_counit_app","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Comonad C\nX : C\ninst‚úù : CategoryTheory.IsIso T.Œ¥\n‚ä¢ Eq (T.map (T.Œµ.app X)) (T.Œµ.app (T.obj X))","decl":"lemma map_counit_app (T : Comonad C) (X : C) [IsIso T.Œ¥] :\n    T.map (T.Œµ.app X) = T.Œµ.app (T.obj X) := by\n  simp [‚Üê cancel_epi (T.Œ¥.app _)]\n\n"}
{"name":"CategoryTheory.Comonad.isSplitEpi_iff_isIso_counit","module":"Mathlib.CategoryTheory.Monad.Basic","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Comonad C\nX : C\ninst‚úù : CategoryTheory.IsIso T.Œ¥\n‚ä¢ Iff (CategoryTheory.IsSplitEpi (T.Œµ.app X)) (CategoryTheory.IsIso (T.Œµ.app X))","decl":"lemma isSplitEpi_iff_isIso_counit (T : Comonad C) (X : C) [IsIso T.Œ¥] :\n    IsSplitEpi (T.Œµ.app X) ‚Üî IsIso (T.Œµ.app X) := by\n  refine ‚ü®fun _ ‚Ü¶ ‚ü®section_ (T.Œµ.app X), ?_, by simp‚ü©, fun _ ‚Ü¶ inferInstance‚ü©\n  erw [‚Üê map_id, ‚Üê IsSplitEpi.id (T.Œµ.app X), map_comp, T.map_counit_app X, T.Œµ.naturality]\n  rfl\n\n"}
