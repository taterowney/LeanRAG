{"name":"Multiset.sections_zero","module":"Mathlib.Data.Multiset.Sections","initialProofState":"α : Type u_1\n⊢ Eq (Multiset.Sections 0) (Singleton.singleton 0)","decl":"@[simp]\ntheorem sections_zero : Sections (0 : Multiset (Multiset α)) = {0} :=\n  rfl\n\n"}
{"name":"Multiset.sections_cons","module":"Mathlib.Data.Multiset.Sections","initialProofState":"α : Type u_1\ns : Multiset (Multiset α)\nm : Multiset α\n⊢ Eq (Multiset.cons m s).Sections (m.bind fun a => Multiset.map (Multiset.cons a) s.Sections)","decl":"@[simp]\ntheorem sections_cons (s : Multiset (Multiset α)) (m : Multiset α) :\n    Sections (m ::ₘ s) = m.bind fun a => (Sections s).map (Multiset.cons a) :=\n  recOn_cons m s\n\n"}
{"name":"Multiset.coe_sections","module":"Mathlib.Data.Multiset.Sections","initialProofState":"α : Type u_1\nl : List (List α)\n⊢ Eq (↑(List.map (fun l => ↑l) l)).Sections ↑(List.map (fun l => ↑l) l.sections)","decl":"theorem coe_sections :\n    ∀ l : List (List α),\n      Sections (l.map fun l : List α => (l : Multiset α) : Multiset (Multiset α)) =\n        (l.sections.map fun l : List α => (l : Multiset α) : Multiset (Multiset α))\n  | [] => rfl\n  | a :: l => by\n    simp only [List.map_cons, List.sections]\n    rw [← cons_coe, sections_cons, bind_map_comm, coe_sections l]\n    simp [List.sections, Function.comp_def, List.flatMap]\n\n"}
{"name":"Multiset.sections_add","module":"Mathlib.Data.Multiset.Sections","initialProofState":"α : Type u_1\ns t : Multiset (Multiset α)\n⊢ Eq (HAdd.hAdd s t).Sections (s.Sections.bind fun m => Multiset.map (fun x => HAdd.hAdd m x) t.Sections)","decl":"@[simp]\ntheorem sections_add (s t : Multiset (Multiset α)) :\n    Sections (s + t) = (Sections s).bind fun m => (Sections t).map (m + ·) :=\n  Multiset.induction_on s (by simp) fun a s ih => by\n    simp [ih, bind_assoc, map_bind, bind_map]\n\n"}
{"name":"Multiset.mem_sections","module":"Mathlib.Data.Multiset.Sections","initialProofState":"α : Type u_1\ns : Multiset (Multiset α)\na : Multiset α\n⊢ Iff (Membership.mem s.Sections a) (Multiset.Rel (fun s a => Membership.mem s a) s a)","decl":"theorem mem_sections {s : Multiset (Multiset α)} :\n    ∀ {a}, a ∈ Sections s ↔ s.Rel (fun s a => a ∈ s) a := by\n  induction s using Multiset.induction_on with\n  | empty => simp\n  | cons _ _ ih => simp [ih, rel_cons_left, eq_comm]\n\n"}
{"name":"Multiset.card_sections","module":"Mathlib.Data.Multiset.Sections","initialProofState":"α : Type u_1\ns : Multiset (Multiset α)\n⊢ Eq s.Sections.card (Multiset.map Multiset.card s).prod","decl":"theorem card_sections {s : Multiset (Multiset α)} : card (Sections s) = prod (s.map card) :=\n  Multiset.induction_on s (by simp) (by simp +contextual)\n\n"}
