{"name":"AntilipschitzWith.edist_lt_top","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nh : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ LT.lt (EDist.edist x y) Top.top","decl":"protected lemma AntilipschitzWith.edist_lt_top [PseudoEMetricSpace Œ±] [PseudoMetricSpace Œ≤]\n    {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} (h : AntilipschitzWith K f) (x y : Œ±) : edist x y < ‚ä§ :=\n  (h x y).trans_lt <| ENNReal.mul_lt_top ENNReal.coe_lt_top (edist_lt_top _ _)\n\n"}
{"name":"AntilipschitzWith.edist_ne_top","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nh : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ Ne (EDist.edist x y) Top.top","decl":"theorem AntilipschitzWith.edist_ne_top [PseudoEMetricSpace Œ±] [PseudoMetricSpace Œ≤] {K : ‚Ñù‚â•0}\n    {f : Œ± ‚Üí Œ≤} (h : AntilipschitzWith K f) (x y : Œ±) : edist x y ‚â† ‚ä§ :=\n  (h.edist_lt_top x y).ne\n\n"}
{"name":"antilipschitzWith_iff_le_mul_nndist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (AntilipschitzWith K f) (‚àÄ (x y : Œ±), LE.le (NNDist.nndist x y) (HMul.hMul K (NNDist.nndist (f x) (f y))))","decl":"theorem antilipschitzWith_iff_le_mul_nndist :\n    AntilipschitzWith K f ‚Üî ‚àÄ x y, nndist x y ‚â§ K * nndist (f x) (f y) := by\n  simp only [AntilipschitzWith, edist_nndist]\n  norm_cast\n\n"}
{"name":"AntilipschitzWith.le_mul_nndist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\na‚úù : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (NNDist.nndist x y) (HMul.hMul K (NNDist.nndist (f x) (f y)))","decl":"alias ‚ü®AntilipschitzWith.le_mul_nndist, AntilipschitzWith.of_le_mul_nndist‚ü© :=\n  antilipschitzWith_iff_le_mul_nndist\n\n"}
{"name":"AntilipschitzWith.of_le_mul_nndist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\na‚úù : ‚àÄ (x y : Œ±), LE.le (NNDist.nndist x y) (HMul.hMul K (NNDist.nndist (f x) (f y)))\n‚ä¢ AntilipschitzWith K f","decl":"alias ‚ü®AntilipschitzWith.le_mul_nndist, AntilipschitzWith.of_le_mul_nndist‚ü© :=\n  antilipschitzWith_iff_le_mul_nndist\n\n"}
{"name":"antilipschitzWith_iff_le_mul_dist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\n‚ä¢ Iff (AntilipschitzWith K f) (‚àÄ (x y : Œ±), LE.le (Dist.dist x y) (HMul.hMul (‚ÜëK) (Dist.dist (f x) (f y))))","decl":"theorem antilipschitzWith_iff_le_mul_dist :\n    AntilipschitzWith K f ‚Üî ‚àÄ x y, dist x y ‚â§ K * dist (f x) (f y) := by\n  simp only [antilipschitzWith_iff_le_mul_nndist, dist_nndist]\n  norm_cast\n\n"}
{"name":"AntilipschitzWith.le_mul_dist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\na‚úù : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (Dist.dist x y) (HMul.hMul (‚ÜëK) (Dist.dist (f x) (f y)))","decl":"alias ‚ü®AntilipschitzWith.le_mul_dist, AntilipschitzWith.of_le_mul_dist‚ü© :=\n  antilipschitzWith_iff_le_mul_dist\n\n"}
{"name":"AntilipschitzWith.of_le_mul_dist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\na‚úù : ‚àÄ (x y : Œ±), LE.le (Dist.dist x y) (HMul.hMul (‚ÜëK) (Dist.dist (f x) (f y)))\n‚ä¢ AntilipschitzWith K f","decl":"alias ‚ü®AntilipschitzWith.le_mul_dist, AntilipschitzWith.of_le_mul_dist‚ü© :=\n  antilipschitzWith_iff_le_mul_dist\n\n"}
{"name":"AntilipschitzWith.mul_le_nndist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (HMul.hMul (Inv.inv K) (NNDist.nndist x y)) (NNDist.nndist (f x) (f y))","decl":"theorem mul_le_nndist (hf : AntilipschitzWith K f) (x y : Œ±) :\n    K‚Åª¬π * nndist x y ‚â§ nndist (f x) (f y) := by\n  simpa only [div_eq_inv_mul] using NNReal.div_le_of_le_mul' (hf.le_mul_nndist x y)\n\n"}
{"name":"AntilipschitzWith.mul_le_dist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (HMul.hMul (‚Üë(Inv.inv K)) (Dist.dist x y)) (Dist.dist (f x) (f y))","decl":"theorem mul_le_dist (hf : AntilipschitzWith K f) (x y : Œ±) :\n    (K‚Åª¬π * dist x y : ‚Ñù) ‚â§ dist (f x) (f y) := mod_cast hf.mul_le_nndist x y\n\n"}
{"name":"AntilipschitzWith.injective","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬π : EMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\n‚ä¢ Function.Injective f","decl":"protected theorem injective {Œ± : Type*} {Œ≤ : Type*} [EMetricSpace Œ±] [PseudoEMetricSpace Œ≤]\n    {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} (hf : AntilipschitzWith K f) : Function.Injective f := fun x y h => by\n  simpa only [h, edist_self, mul_zero, edist_le_zero] using hf x y\n\n"}
{"name":"AntilipschitzWith.mul_le_edist","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nx y : Œ±\n‚ä¢ LE.le (HMul.hMul (Inv.inv ‚ÜëK) (EDist.edist x y)) (EDist.edist (f x) (f y))","decl":"theorem mul_le_edist (hf : AntilipschitzWith K f) (x y : Œ±) :\n    (K : ‚Ñù‚â•0‚àû)‚Åª¬π * edist x y ‚â§ edist (f x) (f y) := by\n  rw [mul_comm, ‚Üê div_eq_mul_inv]\n  exact ENNReal.div_le_of_le_mul' (hf x y)\n\n"}
{"name":"AntilipschitzWith.ediam_preimage_le","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ns : Set Œ≤\n‚ä¢ LE.le (EMetric.diam (Set.preimage f s)) (HMul.hMul (‚ÜëK) (EMetric.diam s))","decl":"theorem ediam_preimage_le (hf : AntilipschitzWith K f) (s : Set Œ≤) : diam (f ‚Åª¬π' s) ‚â§ K * diam s :=\n  diam_le fun x hx y hy => (hf x y).trans <|\n    mul_le_mul_left' (edist_le_diam_of_mem (mem_preimage.1 hx) hy) K\n\n"}
{"name":"AntilipschitzWith.le_mul_ediam_image","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ns : Set Œ±\n‚ä¢ LE.le (EMetric.diam s) (HMul.hMul (‚ÜëK) (EMetric.diam (Set.image f s)))","decl":"theorem le_mul_ediam_image (hf : AntilipschitzWith K f) (s : Set Œ±) : diam s ‚â§ K * diam (f '' s) :=\n  (diam_mono (subset_preimage_image _ _)).trans (hf.ediam_preimage_le (f '' s))\n\n"}
{"name":"AntilipschitzWith.id","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\n‚ä¢ AntilipschitzWith 1 id","decl":"protected theorem id : AntilipschitzWith 1 (id : Œ± ‚Üí Œ±) := fun x y => by\n  simp only [ENNReal.coe_one, one_mul, id, le_refl]\n\n"}
{"name":"AntilipschitzWith.comp","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\ninst‚úù : PseudoEMetricSpace Œ≥\nKg : NNReal\ng : Œ≤ ‚Üí Œ≥\nhg : AntilipschitzWith Kg g\nKf : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith Kf f\n‚ä¢ AntilipschitzWith (HMul.hMul Kf Kg) (Function.comp g f)","decl":"theorem comp {Kg : ‚Ñù‚â•0} {g : Œ≤ ‚Üí Œ≥} (hg : AntilipschitzWith Kg g) {Kf : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤}\n    (hf : AntilipschitzWith Kf f) : AntilipschitzWith (Kf * Kg) (g ‚àò f) := fun x y =>\n  calc\n    edist x y ‚â§ Kf * edist (f x) (f y) := hf x y\n    _ ‚â§ Kf * (Kg * edist (g (f x)) (g (f y))) := mul_left_mono (hg _ _)\n    _ = _ := by rw [ENNReal.coe_mul, mul_assoc]; rfl\n\n"}
{"name":"AntilipschitzWith.restrict","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ns : Set Œ±\n‚ä¢ AntilipschitzWith K (s.restrict f)","decl":"theorem restrict (hf : AntilipschitzWith K f) (s : Set Œ±) : AntilipschitzWith K (s.restrict f) :=\n  fun x y => hf x y\n\n"}
{"name":"AntilipschitzWith.codRestrict","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ns : Set Œ≤\nhs : ‚àÄ (x : Œ±), Membership.mem s (f x)\n‚ä¢ AntilipschitzWith K (Set.codRestrict f s hs)","decl":"theorem codRestrict (hf : AntilipschitzWith K f) {s : Set Œ≤} (hs : ‚àÄ x, f x ‚àà s) :\n    AntilipschitzWith K (s.codRestrict f hs) := fun x y => hf x y\n\n"}
{"name":"AntilipschitzWith.to_rightInvOn'","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\ns : Set Œ±\nhf : AntilipschitzWith K (s.restrict f)\ng : Œ≤ ‚Üí Œ±\nt : Set Œ≤\ng_maps : Set.MapsTo g t s\ng_inv : Set.RightInvOn g f t\n‚ä¢ LipschitzWith K (t.restrict g)","decl":"theorem to_rightInvOn' {s : Set Œ±} (hf : AntilipschitzWith K (s.restrict f)) {g : Œ≤ ‚Üí Œ±}\n    {t : Set Œ≤} (g_maps : MapsTo g t s) (g_inv : RightInvOn g f t) :\n    LipschitzWith K (t.restrict g) := fun x y => by\n  simpa only [restrict_apply, g_inv x.mem, g_inv y.mem, Subtype.edist_mk_mk]\n    using hf ‚ü®g x, g_maps x.mem‚ü© ‚ü®g y, g_maps y.mem‚ü©\n\n"}
{"name":"AntilipschitzWith.to_rightInvOn","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ng : Œ≤ ‚Üí Œ±\nt : Set Œ≤\nh : Set.RightInvOn g f t\n‚ä¢ LipschitzWith K (t.restrict g)","decl":"theorem to_rightInvOn (hf : AntilipschitzWith K f) {g : Œ≤ ‚Üí Œ±} {t : Set Œ≤} (h : RightInvOn g f t) :\n    LipschitzWith K (t.restrict g) :=\n  (hf.restrict univ).to_rightInvOn' (mapsTo_univ g t) h\n\n"}
{"name":"AntilipschitzWith.to_rightInverse","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ng : Œ≤ ‚Üí Œ±\nhg : Function.RightInverse g f\n‚ä¢ LipschitzWith K g","decl":"theorem to_rightInverse (hf : AntilipschitzWith K f) {g : Œ≤ ‚Üí Œ±} (hg : Function.RightInverse g f) :\n    LipschitzWith K g := by\n  intro x y\n  have := hf (g x) (g y)\n  rwa [hg x, hg y] at this\n\n"}
{"name":"AntilipschitzWith.comap_uniformity_le","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\n‚ä¢ LE.le (Filter.comap (Prod.map f f) (uniformity Œ≤)) (uniformity Œ±)","decl":"theorem comap_uniformity_le (hf : AntilipschitzWith K f) : (ùì§ Œ≤).comap (Prod.map f f) ‚â§ ùì§ Œ± := by\n  refine ((uniformity_basis_edist.comap _).le_basis_iff uniformity_basis_edist).2 fun Œµ h‚ÇÄ => ?_\n  refine ‚ü®(‚ÜëK)‚Åª¬π * Œµ, ENNReal.mul_pos (ENNReal.inv_ne_zero.2 ENNReal.coe_ne_top) h‚ÇÄ.ne', ?_‚ü©\n  refine fun x hx => (hf x.1 x.2).trans_lt ?_\n  rw [mul_comm, ‚Üê div_eq_mul_inv] at hx\n  rw [mul_comm]\n  exact ENNReal.mul_lt_of_lt_div hx\n\n"}
{"name":"AntilipschitzWith.isUniformInducing","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ IsUniformInducing f","decl":"theorem isUniformInducing (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    IsUniformInducing f :=\n  ‚ü®le_antisymm hf.comap_uniformity_le hfc.le_comap‚ü©\n\n"}
{"name":"AntilipschitzWith.uniformInducing","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ IsUniformInducing f","decl":"@[deprecated (since := \"2024-10-05\")]\nalias uniformInducing := isUniformInducing\n\n"}
{"name":"AntilipschitzWith.isUniformEmbedding","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬π : EMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ IsUniformEmbedding f","decl":"lemma isUniformEmbedding {Œ± Œ≤ : Type*} [EMetricSpace Œ±] [PseudoEMetricSpace Œ≤] {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤}\n    (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) : IsUniformEmbedding f :=\n  ‚ü®hf.isUniformInducing hfc, hf.injective‚ü©\n\n"}
{"name":"AntilipschitzWith.uniformEmbedding","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬π : EMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ IsUniformEmbedding f","decl":"@[deprecated (since := \"2024-10-01\")] alias uniformEmbedding := isUniformEmbedding\n\n"}
{"name":"AntilipschitzWith.isComplete_range","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ±\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ IsComplete (Set.range f)","decl":"theorem isComplete_range [CompleteSpace Œ±] (hf : AntilipschitzWith K f)\n    (hfc : UniformContinuous f) : IsComplete (range f) :=\n  (hf.isUniformInducing hfc).isComplete_range\n\n"}
{"name":"AntilipschitzWith.isClosed_range","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : EMetricSpace Œ≤\ninst‚úù : CompleteSpace Œ±\nf : Œ± ‚Üí Œ≤\nK : NNReal\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ IsClosed (Set.range f)","decl":"theorem isClosed_range {Œ± Œ≤ : Type*} [PseudoEMetricSpace Œ±] [EMetricSpace Œ≤] [CompleteSpace Œ±]\n    {f : Œ± ‚Üí Œ≤} {K : ‚Ñù‚â•0} (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    IsClosed (range f) :=\n  (hf.isComplete_range hfc).isClosed\n\n"}
{"name":"AntilipschitzWith.isClosedEmbedding","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬≤ : EMetricSpace Œ±\ninst‚úù¬π : EMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ±\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"theorem isClosedEmbedding {Œ± : Type*} {Œ≤ : Type*} [EMetricSpace Œ±] [EMetricSpace Œ≤] {K : ‚Ñù‚â•0}\n    {f : Œ± ‚Üí Œ≤} [CompleteSpace Œ±] (hf : AntilipschitzWith K f) (hfc : UniformContinuous f) :\n    IsClosedEmbedding f :=\n  { (hf.isUniformEmbedding hfc).isEmbedding with isClosed_range := hf.isClosed_range hfc }\n\n"}
{"name":"AntilipschitzWith.closedEmbedding","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬≤ : EMetricSpace Œ±\ninst‚úù¬π : EMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\ninst‚úù : CompleteSpace Œ±\nhf : AntilipschitzWith K f\nhfc : UniformContinuous f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"AntilipschitzWith.subtype_coe","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\ninst‚úù : PseudoEMetricSpace Œ±\ns : Set Œ±\n‚ä¢ AntilipschitzWith 1 Subtype.val","decl":"theorem subtype_coe (s : Set Œ±) : AntilipschitzWith 1 ((‚Üë) : s ‚Üí Œ±) :=\n  AntilipschitzWith.id.restrict s\n\n"}
{"name":"AntilipschitzWith.of_subsingleton","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : PseudoEMetricSpace Œ±\ninst‚úù¬π : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\ninst‚úù : Subsingleton Œ±\nK : NNReal\n‚ä¢ AntilipschitzWith K f","decl":"@[nontriviality] -- Porting note: added `nontriviality`\ntheorem of_subsingleton [Subsingleton Œ±] {K : ‚Ñù‚â•0} : AntilipschitzWith K f := fun x y => by\n  simp only [Subsingleton.elim x y, edist_self, zero_le]\n\n"}
{"name":"AntilipschitzWith.subsingleton","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_4\nŒ≤ : Type u_5\ninst‚úù¬π : EMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nf : Œ± ‚Üí Œ≤\nh : AntilipschitzWith 0 f\n‚ä¢ Subsingleton Œ±","decl":"/-- If `f : Œ± ‚Üí Œ≤` is `0`-antilipschitz, then `Œ±` is a `subsingleton`. -/\nprotected theorem subsingleton {Œ± Œ≤} [EMetricSpace Œ±] [PseudoEMetricSpace Œ≤] {f : Œ± ‚Üí Œ≤}\n    (h : AntilipschitzWith 0 f) : Subsingleton Œ± :=\n  ‚ü®fun x y => edist_le_zero.1 <| (h x y).trans_eq <| zero_mul _‚ü©\n\n"}
{"name":"AntilipschitzWith.isBounded_preimage","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\ns : Set Œ≤\nhs : Bornology.IsBounded s\n‚ä¢ Bornology.IsBounded (Set.preimage f s)","decl":"theorem isBounded_preimage (hf : AntilipschitzWith K f) {s : Set Œ≤} (hs : IsBounded s) :\n    IsBounded (f ‚Åª¬π' s) :=\n  isBounded_iff_ediam_ne_top.2 <| ne_top_of_le_ne_top\n    (ENNReal.mul_ne_top ENNReal.coe_ne_top hs.ediam_ne_top) (hf.ediam_preimage_le _)\n\n"}
{"name":"AntilipschitzWith.tendsto_cobounded","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoMetricSpace Œ±\ninst‚úù : PseudoMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : AntilipschitzWith K f\n‚ä¢ Filter.Tendsto f (Bornology.cobounded Œ±) (Bornology.cobounded Œ≤)","decl":"theorem tendsto_cobounded (hf : AntilipschitzWith K f) : Tendsto f (cobounded Œ±) (cobounded Œ≤) :=\n  compl_surjective.forall.2 fun _ ‚Ü¶ hf.isBounded_preimage\n\n"}
{"name":"AntilipschitzWith.properSpace","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ≤ : Type u_2\ninst‚úù¬≤ : PseudoMetricSpace Œ≤\nŒ± : Type u_4\ninst‚úù¬π : MetricSpace Œ±\nK : NNReal\nf : Œ± ‚Üí Œ≤\ninst‚úù : ProperSpace Œ±\nhK : AntilipschitzWith K f\nf_cont : Continuous f\nhf : Function.Surjective f\n‚ä¢ ProperSpace Œ≤","decl":"/-- The image of a proper space under an expanding onto map is proper. -/\nprotected theorem properSpace {Œ± : Type*} [MetricSpace Œ±] {K : ‚Ñù‚â•0} {f : Œ± ‚Üí Œ≤} [ProperSpace Œ±]\n    (hK : AntilipschitzWith K f) (f_cont : Continuous f) (hf : Function.Surjective f) :\n    ProperSpace Œ≤ := by\n  refine ‚ü®fun x‚ÇÄ r => ?_‚ü©\n  let K := f ‚Åª¬π' closedBall x‚ÇÄ r\n  have A : IsClosed K := isClosed_ball.preimage f_cont\n  have B : IsBounded K := hK.isBounded_preimage isBounded_closedBall\n  have : IsCompact K := isCompact_iff_isClosed_bounded.2 ‚ü®A, B‚ü©\n  convert this.image f_cont\n  exact (hf.image_preimage _).symm\n\n"}
{"name":"AntilipschitzWith.isBounded_of_image2_left","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : PseudoMetricSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nK‚ÇÅ : NNReal\nhf : ‚àÄ (b : Œ≤), AntilipschitzWith K‚ÇÅ fun a => f a b\ns : Set Œ±\nt : Set Œ≤\nhst : Bornology.IsBounded (Set.image2 f s t)\n‚ä¢ Or (Bornology.IsBounded s) (Bornology.IsBounded t)","decl":"theorem isBounded_of_image2_left (f : Œ± ‚Üí Œ≤ ‚Üí Œ≥) {K‚ÇÅ : ‚Ñù‚â•0}\n    (hf : ‚àÄ b, AntilipschitzWith K‚ÇÅ fun a => f a b) {s : Set Œ±} {t : Set Œ≤}\n    (hst : IsBounded (Set.image2 f s t)) : IsBounded s ‚à® IsBounded t := by\n  contrapose! hst\n  obtain ‚ü®b, hb‚ü© : t.Nonempty := nonempty_of_not_isBounded hst.2\n  have : ¬¨IsBounded (Set.image2 f s {b}) := by\n    intro h\n    apply hst.1\n    rw [Set.image2_singleton_right] at h\n    replace h := (hf b).isBounded_preimage h\n    exact h.subset (subset_preimage_image _ _)\n  exact mt (IsBounded.subset ¬∑ (image2_subset subset_rfl (singleton_subset_iff.mpr hb))) this\n\n"}
{"name":"AntilipschitzWith.isBounded_of_image2_right","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒ≥ : Type u_3\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : PseudoMetricSpace Œ≤\ninst‚úù : PseudoMetricSpace Œ≥\nf : Œ± ‚Üí Œ≤ ‚Üí Œ≥\nK‚ÇÇ : NNReal\nhf : ‚àÄ (a : Œ±), AntilipschitzWith K‚ÇÇ (f a)\ns : Set Œ±\nt : Set Œ≤\nhst : Bornology.IsBounded (Set.image2 f s t)\n‚ä¢ Or (Bornology.IsBounded s) (Bornology.IsBounded t)","decl":"theorem isBounded_of_image2_right {f : Œ± ‚Üí Œ≤ ‚Üí Œ≥} {K‚ÇÇ : ‚Ñù‚â•0} (hf : ‚àÄ a, AntilipschitzWith K‚ÇÇ (f a))\n    {s : Set Œ±} {t : Set Œ≤} (hst : IsBounded (Set.image2 f s t)) : IsBounded s ‚à® IsBounded t :=\n  Or.symm <| isBounded_of_image2_left (flip f) hf <| image2_swap f s t ‚ñ∏ hst\n\n"}
{"name":"LipschitzWith.to_rightInverse","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬π : PseudoEMetricSpace Œ±\ninst‚úù : PseudoEMetricSpace Œ≤\nK : NNReal\nf : Œ± ‚Üí Œ≤\nhf : LipschitzWith K f\ng : Œ≤ ‚Üí Œ±\nhg : Function.RightInverse g f\n‚ä¢ AntilipschitzWith K g","decl":"theorem LipschitzWith.to_rightInverse [PseudoEMetricSpace Œ±] [PseudoEMetricSpace Œ≤] {K : ‚Ñù‚â•0}\n    {f : Œ± ‚Üí Œ≤} (hf : LipschitzWith K f) {g : Œ≤ ‚Üí Œ±} (hg : Function.RightInverse g f) :\n    AntilipschitzWith K g := fun x y => by simpa only [hg _] using hf (g x) (g y)\n\n"}
{"name":"LipschitzWith.properSpace","module":"Mathlib.Topology.MetricSpace.Antilipschitz","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù¬≤ : PseudoMetricSpace Œ±\ninst‚úù¬π : MetricSpace Œ≤\ninst‚úù : ProperSpace Œ≤\nK : NNReal\nf : Homeomorph Œ± Œ≤\nhK : LipschitzWith K ‚áëf\n‚ä¢ ProperSpace Œ±","decl":"/-- The preimage of a proper space under a Lipschitz homeomorphism is proper. -/\nprotected theorem LipschitzWith.properSpace [PseudoMetricSpace Œ±] [MetricSpace Œ≤] [ProperSpace Œ≤]\n    {K : ‚Ñù‚â•0} {f : Œ± ‚âÉ‚Çú Œ≤} (hK : LipschitzWith K f) : ProperSpace Œ± :=\n  (hK.to_rightInverse f.right_inv).properSpace f.symm.continuous f.symm.surjective\n"}
