{"name":"Equiv.Perm.default_eq","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\n⊢ Eq Inhabited.default 1","decl":"@[simp]\ntheorem default_eq : (default : Perm α) = 1 :=\n  rfl\n\n"}
{"name":"Equiv.Perm.equivUnitsEnd_symm_apply_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nu : Units (Function.End α)\n⊢ Eq ⇑(Equiv.Perm.equivUnitsEnd.symm u) ↑u","decl":"/-- The permutation of a type is equivalent to the units group of the endomorphisms monoid of this\ntype. -/\n@[simps]\ndef equivUnitsEnd : Perm α ≃* Units (Function.End α) where\n  -- Porting note: needed to add `.toFun`.\n  toFun e := ⟨e.toFun, e.symm.toFun, e.self_comp_symm, e.symm_comp_self⟩\n  invFun u :=\n    ⟨(u : Function.End α), (↑u⁻¹ : Function.End α), congr_fun u.inv_val, congr_fun u.val_inv⟩\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Equiv.Perm.val_inv_equivUnitsEnd_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\na✝ : α\n⊢ Eq (↑(Inv.inv (Equiv.Perm.equivUnitsEnd e)) a✝) ((Equiv.symm e).toFun a✝)","decl":"/-- The permutation of a type is equivalent to the units group of the endomorphisms monoid of this\ntype. -/\n@[simps]\ndef equivUnitsEnd : Perm α ≃* Units (Function.End α) where\n  -- Porting note: needed to add `.toFun`.\n  toFun e := ⟨e.toFun, e.symm.toFun, e.self_comp_symm, e.symm_comp_self⟩\n  invFun u :=\n    ⟨(u : Function.End α), (↑u⁻¹ : Function.End α), congr_fun u.inv_val, congr_fun u.val_inv⟩\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Equiv.Perm.val_equivUnitsEnd_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\na✝ : α\n⊢ Eq (↑(Equiv.Perm.equivUnitsEnd e) a✝) (e.toFun a✝)","decl":"/-- The permutation of a type is equivalent to the units group of the endomorphisms monoid of this\ntype. -/\n@[simps]\ndef equivUnitsEnd : Perm α ≃* Units (Function.End α) where\n  -- Porting note: needed to add `.toFun`.\n  toFun e := ⟨e.toFun, e.symm.toFun, e.self_comp_symm, e.symm_comp_self⟩\n  invFun u :=\n    ⟨(u : Function.End α), (↑u⁻¹ : Function.End α), congr_fun u.inv_val, congr_fun u.val_inv⟩\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Equiv.Perm.equivUnitsEnd_symm_apply_symm_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nu : Units (Function.End α)\n⊢ Eq ⇑(Equiv.symm (Equiv.Perm.equivUnitsEnd.symm u)) ↑(Inv.inv u)","decl":"/-- The permutation of a type is equivalent to the units group of the endomorphisms monoid of this\ntype. -/\n@[simps]\ndef equivUnitsEnd : Perm α ≃* Units (Function.End α) where\n  -- Porting note: needed to add `.toFun`.\n  toFun e := ⟨e.toFun, e.symm.toFun, e.self_comp_symm, e.symm_comp_self⟩\n  invFun u :=\n    ⟨(u : Function.End α), (↑u⁻¹ : Function.End α), congr_fun u.inv_val, congr_fun u.val_inv⟩\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := Units.ext rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MonoidHom.toHomPerm_apply_symm_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nG : Type u_1\ninst✝ : Group G\nf : MonoidHom G (Function.End α)\na✝ : G\n⊢ Eq ⇑(Equiv.symm (f.toHomPerm a✝)) ↑(Inv.inv (f.toHomUnits a✝))","decl":"/-- Lift a monoid homomorphism `f : G →* Function.End α` to a monoid homomorphism\n`f : G →* Equiv.Perm α`. -/\n@[simps!]\ndef _root_.MonoidHom.toHomPerm {G : Type*} [Group G] (f : G →* Function.End α) : G →* Perm α :=\n  equivUnitsEnd.symm.toMonoidHom.comp f.toHomUnits\n\n"}
{"name":"MonoidHom.toHomPerm_apply_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nG : Type u_1\ninst✝ : Group G\nf : MonoidHom G (Function.End α)\na✝ : G\n⊢ Eq (⇑(f.toHomPerm a✝)) (f a✝)","decl":"/-- Lift a monoid homomorphism `f : G →* Function.End α` to a monoid homomorphism\n`f : G →* Equiv.Perm α`. -/\n@[simps!]\ndef _root_.MonoidHom.toHomPerm {G : Type*} [Group G] (f : G →* Function.End α) : G →* Perm α :=\n  equivUnitsEnd.symm.toMonoidHom.comp f.toHomUnits\n\n"}
{"name":"Equiv.Perm.mul_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf g : Equiv.Perm α\nx : α\n⊢ Eq ((HMul.hMul f g) x) (f (g x))","decl":"theorem mul_apply (f g : Perm α) (x) : (f * g) x = f (g x) :=\n  Equiv.trans_apply _ _ _\n\n"}
{"name":"Equiv.Perm.one_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nx : α\n⊢ Eq (1 x) x","decl":"theorem one_apply (x) : (1 : Perm α) x = x :=\n  rfl\n\n"}
{"name":"Equiv.Perm.inv_apply_self","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\nx : α\n⊢ Eq ((Inv.inv f) (f x)) x","decl":"@[simp]\ntheorem inv_apply_self (f : Perm α) (x) : f⁻¹ (f x) = x :=\n  f.symm_apply_apply x\n\n"}
{"name":"Equiv.Perm.apply_inv_self","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\nx : α\n⊢ Eq (f ((Inv.inv f) x)) x","decl":"@[simp]\ntheorem apply_inv_self (f : Perm α) (x) : f (f⁻¹ x) = x :=\n  f.apply_symm_apply x\n\n"}
{"name":"Equiv.Perm.one_def","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\n⊢ Eq 1 (Equiv.refl α)","decl":"theorem one_def : (1 : Perm α) = Equiv.refl α :=\n  rfl\n\n"}
{"name":"Equiv.Perm.mul_def","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf g : Equiv.Perm α\n⊢ Eq (HMul.hMul f g) (Equiv.trans g f)","decl":"theorem mul_def (f g : Perm α) : f * g = g.trans f :=\n  rfl\n\n"}
{"name":"Equiv.Perm.inv_def","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\n⊢ Eq (Inv.inv f) (Equiv.symm f)","decl":"theorem inv_def (f : Perm α) : f⁻¹ = f.symm :=\n  rfl\n\n"}
{"name":"Equiv.Perm.coe_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\n⊢ Eq (⇑1) id","decl":"@[simp, norm_cast] lemma coe_one : ⇑(1 : Perm α) = id := rfl\n\n"}
{"name":"Equiv.Perm.coe_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf g : Equiv.Perm α\n⊢ Eq (⇑(HMul.hMul f g)) (Function.comp ⇑f ⇑g)","decl":"@[simp, norm_cast] lemma coe_mul (f g : Perm α) : ⇑(f * g) = f ∘ g := rfl\n\n"}
{"name":"Equiv.Perm.coe_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\nn : Nat\n⊢ Eq (⇑(HPow.hPow f n)) (Nat.iterate (⇑f) n)","decl":"@[norm_cast] lemma coe_pow (f : Perm α) (n : ℕ) : ⇑(f ^ n) = f^[n] := rfl\n\n"}
{"name":"Equiv.Perm.iterate_eq_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\nn : Nat\n⊢ Eq (Nat.iterate (⇑f) n) ⇑(HPow.hPow f n)","decl":"@[simp] lemma iterate_eq_pow (f : Perm α) (n : ℕ) : f^[n] = ⇑(f ^ n) := rfl\n\n"}
{"name":"Equiv.Perm.eq_inv_iff_eq","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\nx y : α\n⊢ Iff (Eq x ((Inv.inv f) y)) (Eq (f x) y)","decl":"theorem eq_inv_iff_eq {f : Perm α} {x y : α} : x = f⁻¹ y ↔ f x = y :=\n  f.eq_symm_apply\n\n"}
{"name":"Equiv.Perm.inv_eq_iff_eq","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\nx y : α\n⊢ Iff (Eq ((Inv.inv f) x) y) (Eq x (f y))","decl":"theorem inv_eq_iff_eq {f : Perm α} {x y : α} : f⁻¹ x = y ↔ x = f y :=\n  f.symm_apply_eq\n\n"}
{"name":"Equiv.Perm.zpow_apply_comm","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nσ : Equiv.Perm α\nm n : Int\nx : α\n⊢ Eq ((HPow.hPow σ m) ((HPow.hPow σ n) x)) ((HPow.hPow σ n) ((HPow.hPow σ m) x))","decl":"theorem zpow_apply_comm {α : Type*} (σ : Perm α) (m n : ℤ) {x : α} :\n    (σ ^ m) ((σ ^ n) x) = (σ ^ n) ((σ ^ m) x) := by\n  rw [← Equiv.Perm.mul_apply, ← Equiv.Perm.mul_apply, zpow_mul_comm]\n\n"}
{"name":"Equiv.Perm.image_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\ns : Set α\n⊢ Eq (Set.image (⇑(Inv.inv f)) s) (Set.preimage (⇑f) s)","decl":"@[simp] lemma image_inv (f : Perm α) (s : Set α) : ↑f⁻¹ '' s = f ⁻¹' s := f⁻¹.image_eq_preimage _\n\n"}
{"name":"Equiv.Perm.preimage_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nf : Equiv.Perm α\ns : Set α\n⊢ Eq (Set.preimage (⇑(Inv.inv f)) s) (Set.image (⇑f) s)","decl":"@[simp] lemma preimage_inv (f : Perm α) (s : Set α) : ↑f⁻¹ ⁻¹' s = f '' s :=\n  (f.image_eq_preimage _).symm\n\n"}
{"name":"Equiv.Perm.trans_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Sort u_1\nβ : Type u_2\ne : Equiv α β\n⊢ Eq (e.trans 1) e","decl":"@[simp]\ntheorem trans_one {α : Sort*} {β : Type*} (e : α ≃ β) : e.trans (1 : Perm β) = e :=\n  Equiv.trans_refl e\n\n"}
{"name":"Equiv.Perm.mul_refl","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\n⊢ Eq (HMul.hMul e (Equiv.refl α)) e","decl":"@[simp]\ntheorem mul_refl (e : Perm α) : e * Equiv.refl α = e :=\n  Equiv.trans_refl e\n\n"}
{"name":"Equiv.Perm.one_symm","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\n⊢ Eq (Equiv.symm 1) 1","decl":"@[simp]\ntheorem one_symm : (1 : Perm α).symm = 1 :=\n  Equiv.refl_symm\n\n"}
{"name":"Equiv.Perm.refl_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\n⊢ Eq (Inv.inv (Equiv.refl α)) 1","decl":"@[simp]\ntheorem refl_inv : (Equiv.refl α : Perm α)⁻¹ = 1 :=\n  Equiv.refl_symm\n\n"}
{"name":"Equiv.Perm.one_trans","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Sort u_2\ne : Equiv α β\n⊢ Eq (Equiv.trans 1 e) e","decl":"@[simp]\ntheorem one_trans {α : Type*} {β : Sort*} (e : α ≃ β) : (1 : Perm α).trans e = e :=\n  Equiv.refl_trans e\n\n"}
{"name":"Equiv.Perm.refl_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\n⊢ Eq (HMul.hMul (Equiv.refl α) e) e","decl":"@[simp]\ntheorem refl_mul (e : Perm α) : Equiv.refl α * e = e :=\n  Equiv.refl_trans e\n\n"}
{"name":"Equiv.Perm.inv_trans_self","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\n⊢ Eq (Equiv.trans (Inv.inv e) e) 1","decl":"@[simp]\ntheorem inv_trans_self (e : Perm α) : e⁻¹.trans e = 1 :=\n  Equiv.symm_trans_self e\n\n"}
{"name":"Equiv.Perm.mul_symm","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\n⊢ Eq (HMul.hMul e (Equiv.symm e)) 1","decl":"@[simp]\ntheorem mul_symm (e : Perm α) : e * e.symm = 1 :=\n  Equiv.symm_trans_self e\n\n"}
{"name":"Equiv.Perm.self_trans_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\n⊢ Eq (Equiv.trans e (Inv.inv e)) 1","decl":"@[simp]\ntheorem self_trans_inv (e : Perm α) : e.trans e⁻¹ = 1 :=\n  Equiv.self_trans_symm e\n\n"}
{"name":"Equiv.Perm.symm_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne : Equiv.Perm α\n⊢ Eq (HMul.hMul (Equiv.symm e) e) 1","decl":"@[simp]\ntheorem symm_mul (e : Perm α) : e.symm * e = 1 :=\n  Equiv.self_trans_symm e\n\n"}
{"name":"Equiv.Perm.sumCongr_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv.Perm α\nf : Equiv.Perm β\ng : Equiv.Perm α\nh : Equiv.Perm β\n⊢ Eq (HMul.hMul (e.sumCongr f) (g.sumCongr h)) ((HMul.hMul e g).sumCongr (HMul.hMul f h))","decl":"@[simp]\ntheorem sumCongr_mul {α β : Type*} (e : Perm α) (f : Perm β) (g : Perm α) (h : Perm β) :\n    sumCongr e f * sumCongr g h = sumCongr (e * g) (f * h) :=\n  sumCongr_trans g h e f\n\n"}
{"name":"Equiv.Perm.sumCongr_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ne : Equiv.Perm α\nf : Equiv.Perm β\n⊢ Eq (Inv.inv (e.sumCongr f)) ((Inv.inv e).sumCongr (Inv.inv f))","decl":"@[simp]\ntheorem sumCongr_inv {α β : Type*} (e : Perm α) (f : Perm β) :\n    (sumCongr e f)⁻¹ = sumCongr e⁻¹ f⁻¹ :=\n  sumCongr_symm e f\n\n"}
{"name":"Equiv.Perm.sumCongr_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq (Equiv.Perm.sumCongr 1 1) 1","decl":"@[simp]\ntheorem sumCongr_one {α β : Type*} : sumCongr (1 : Perm α) (1 : Perm β) = 1 :=\n  sumCongr_refl\n\n"}
{"name":"Equiv.Perm.sumCongrHom_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\na : Prod (Equiv.Perm α) (Equiv.Perm β)\n⊢ Eq ((Equiv.Perm.sumCongrHom α β) a) (a.1.sumCongr a.2)","decl":"/-- `Equiv.Perm.sumCongr` as a `MonoidHom`, with its two arguments bundled into a single `Prod`.\n\nThis is particularly useful for its `MonoidHom.range` projection, which is the subgroup of\npermutations which do not exchange elements between `α` and `β`. -/\n@[simps]\ndef sumCongrHom (α β : Type*) : Perm α × Perm β →* Perm (α ⊕ β) where\n  toFun a := sumCongr a.1 a.2\n  map_one' := sumCongr_one\n  map_mul' _ _ := (sumCongr_mul _ _ _ _).symm\n\n"}
{"name":"Equiv.Perm.sumCongrHom_injective","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Function.Injective ⇑(Equiv.Perm.sumCongrHom α β)","decl":"theorem sumCongrHom_injective {α β : Type*} : Function.Injective (sumCongrHom α β) := by\n  rintro ⟨⟩ ⟨⟩ h\n  rw [Prod.mk.inj_iff]\n  constructor <;> ext i\n  · simpa using Equiv.congr_fun h (Sum.inl i)\n  · simpa using Equiv.congr_fun h (Sum.inr i)\n\n"}
{"name":"Equiv.Perm.sumCongr_swap_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ni j : α\n⊢ Eq ((Equiv.swap i j).sumCongr 1) (Equiv.swap (Sum.inl i) (Sum.inl j))","decl":"@[simp]\ntheorem sumCongr_swap_one {α β : Type*} [DecidableEq α] [DecidableEq β] (i j : α) :\n    sumCongr (Equiv.swap i j) (1 : Perm β) = Equiv.swap (Sum.inl i) (Sum.inl j) :=\n  sumCongr_swap_refl i j\n\n"}
{"name":"Equiv.Perm.sumCongr_one_swap","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : DecidableEq β\ni j : β\n⊢ Eq (Equiv.Perm.sumCongr 1 (Equiv.swap i j)) (Equiv.swap (Sum.inr i) (Sum.inr j))","decl":"@[simp]\ntheorem sumCongr_one_swap {α β : Type*} [DecidableEq α] [DecidableEq β] (i j : β) :\n    sumCongr (1 : Perm α) (Equiv.swap i j) = Equiv.swap (Sum.inr i) (Sum.inr j) :=\n  sumCongr_refl_swap i j\n\n"}
{"name":"Equiv.Perm.sigmaCongrRight_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nF G : (a : α) → Equiv.Perm (β a)\n⊢ Eq (HMul.hMul (Equiv.Perm.sigmaCongrRight F) (Equiv.Perm.sigmaCongrRight G)) (Equiv.Perm.sigmaCongrRight (HMul.hMul F G))","decl":"@[simp]\ntheorem sigmaCongrRight_mul {α : Type*} {β : α → Type*} (F : ∀ a, Perm (β a))\n    (G : ∀ a, Perm (β a)) : sigmaCongrRight F * sigmaCongrRight G = sigmaCongrRight (F * G) :=\n  sigmaCongrRight_trans G F\n\n"}
{"name":"Equiv.Perm.sigmaCongrRight_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nF : (a : α) → Equiv.Perm (β a)\n⊢ Eq (Inv.inv (Equiv.Perm.sigmaCongrRight F)) (Equiv.Perm.sigmaCongrRight fun a => Inv.inv (F a))","decl":"@[simp]\ntheorem sigmaCongrRight_inv {α : Type*} {β : α → Type*} (F : ∀ a, Perm (β a)) :\n    (sigmaCongrRight F)⁻¹ = sigmaCongrRight fun a => (F a)⁻¹ :=\n  sigmaCongrRight_symm F\n\n"}
{"name":"Equiv.Perm.sigmaCongrRight_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\n⊢ Eq (Equiv.Perm.sigmaCongrRight 1) 1","decl":"@[simp]\ntheorem sigmaCongrRight_one {α : Type*} {β : α → Type*} :\n    sigmaCongrRight (1 : ∀ a, Equiv.Perm <| β a) = 1 :=\n  sigmaCongrRight_refl\n\n"}
{"name":"Equiv.Perm.sigmaCongrRightHom_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nF : (a : α) → Equiv.Perm (β a)\n⊢ Eq ((Equiv.Perm.sigmaCongrRightHom β) F) (Equiv.Perm.sigmaCongrRight F)","decl":"/-- `Equiv.Perm.sigmaCongrRight` as a `MonoidHom`.\n\nThis is particularly useful for its `MonoidHom.range` projection, which is the subgroup of\npermutations which do not exchange elements between fibers. -/\n@[simps]\ndef sigmaCongrRightHom {α : Type*} (β : α → Type*) : (∀ a, Perm (β a)) →* Perm (Σa, β a) where\n  toFun := sigmaCongrRight\n  map_one' := sigmaCongrRight_one\n  map_mul' _ _ := (sigmaCongrRight_mul _ _).symm\n\n"}
{"name":"Equiv.Perm.sigmaCongrRightHom_injective","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\n⊢ Function.Injective ⇑(Equiv.Perm.sigmaCongrRightHom β)","decl":"theorem sigmaCongrRightHom_injective {α : Type*} {β : α → Type*} :\n    Function.Injective (sigmaCongrRightHom β) := by\n  intro x y h\n  ext a b\n  simpa using Equiv.congr_fun h ⟨a, b⟩\n\n"}
{"name":"Equiv.Perm.subtypeCongrHom_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\npair : Prod (Equiv.Perm (Subtype fun a => p a)) (Equiv.Perm (Subtype fun a => Not (p a)))\n⊢ Eq ((Equiv.Perm.subtypeCongrHom p) pair) (pair.1.subtypeCongr pair.2)","decl":"/-- `Equiv.Perm.subtypeCongr` as a `MonoidHom`. -/\n@[simps]\ndef subtypeCongrHom (p : α → Prop) [DecidablePred p] :\n    Perm { a // p a } × Perm { a // ¬p a } →* Perm α where\n  toFun pair := Perm.subtypeCongr pair.fst pair.snd\n  map_one' := Perm.subtypeCongr.refl\n  map_mul' _ _ := (Perm.subtypeCongr.trans _ _ _ _).symm\n\n"}
{"name":"Equiv.Perm.subtypeCongrHom_injective","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Function.Injective ⇑(Equiv.Perm.subtypeCongrHom p)","decl":"theorem subtypeCongrHom_injective (p : α → Prop) [DecidablePred p] :\n    Function.Injective (subtypeCongrHom p) := by\n  rintro ⟨⟩ ⟨⟩ h\n  rw [Prod.mk.inj_iff]\n  constructor <;> ext i <;> simpa using Equiv.congr_fun h i\n\n"}
{"name":"Equiv.Perm.permCongr_eq_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ne p : Equiv.Perm α\n⊢ Eq ((Equiv.permCongr e) p) (HMul.hMul (HMul.hMul e p) (Inv.inv e))","decl":"/-- If `e` is also a permutation, we can write `permCongr`\ncompletely in terms of the group structure. -/\n@[simp]\ntheorem permCongr_eq_mul (e p : Perm α) : e.permCongr p = e * p * e⁻¹ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.extendDomain_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\n⊢ Eq (Equiv.Perm.extendDomain 1 f) 1","decl":"@[simp]\ntheorem extendDomain_one : extendDomain 1 f = 1 :=\n  extendDomain_refl f\n\n"}
{"name":"Equiv.Perm.extendDomain_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv.Perm α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\n⊢ Eq (Inv.inv (e.extendDomain f)) ((Inv.inv e).extendDomain f)","decl":"@[simp]\ntheorem extendDomain_inv : (e.extendDomain f)⁻¹ = e⁻¹.extendDomain f :=\n  rfl\n\n"}
{"name":"Equiv.Perm.extendDomain_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ne e' : Equiv.Perm α\n⊢ Eq (HMul.hMul (e.extendDomain f) (e'.extendDomain f)) ((HMul.hMul e e').extendDomain f)","decl":"@[simp]\ntheorem extendDomain_mul (e e' : Perm α) :\n    e.extendDomain f * e'.extendDomain f = (e * e').extendDomain f :=\n  extendDomain_trans _ _ _\n\n"}
{"name":"Equiv.Perm.extendDomainHom_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\ne : Equiv.Perm α\n⊢ Eq ((Equiv.Perm.extendDomainHom f) e) (e.extendDomain f)","decl":"/-- `extendDomain` as a group homomorphism -/\n@[simps]\ndef extendDomainHom : Perm α →* Perm β where\n  toFun e := extendDomain e f\n  map_one' := extendDomain_one f\n  map_mul' e e' := (extendDomain_mul f e e').symm\n\n"}
{"name":"Equiv.Perm.extendDomainHom_injective","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\n⊢ Function.Injective ⇑(Equiv.Perm.extendDomainHom f)","decl":"theorem extendDomainHom_injective : Function.Injective (extendDomainHom f) :=\n  (injective_iff_map_eq_one (extendDomainHom f)).mpr fun e he =>\n    ext fun x => f.injective <|\n      Subtype.ext ((extendDomain_apply_image e f x).symm.trans (Perm.ext_iff.mp he (f x)))\n\n"}
{"name":"Equiv.Perm.extendDomain_eq_one_iff","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\np : β → Prop\ninst✝ : DecidablePred p\ne : Equiv.Perm α\nf : Equiv α (Subtype p)\n⊢ Iff (Eq (e.extendDomain f) 1) (Eq e 1)","decl":"@[simp]\ntheorem extendDomain_eq_one_iff {e : Perm α} {f : α ≃ Subtype p} : e.extendDomain f = 1 ↔ e = 1 :=\n  (injective_iff_map_eq_one' (extendDomainHom f)).mp (extendDomainHom_injective f) e\n\n"}
{"name":"Equiv.Perm.extendDomain_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv.Perm α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\nn : Nat\n⊢ Eq ((HPow.hPow e n).extendDomain f) (HPow.hPow (e.extendDomain f) n)","decl":"@[simp]\nlemma extendDomain_pow (n : ℕ) : (e ^ n).extendDomain f = e.extendDomain f ^ n :=\n  map_pow (extendDomainHom f) _ _\n\n"}
{"name":"Equiv.Perm.extendDomain_zpow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\ne : Equiv.Perm α\np : β → Prop\ninst✝ : DecidablePred p\nf : Equiv α (Subtype p)\nn : Int\n⊢ Eq ((HPow.hPow e n).extendDomain f) (HPow.hPow (e.extendDomain f) n)","decl":"@[simp]\nlemma extendDomain_zpow (n : ℤ) : (e ^ n).extendDomain f = e.extendDomain f ^ n :=\n  map_zpow (extendDomainHom f) _ _\n\n"}
{"name":"Equiv.Perm.subtypePerm_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Equiv.Perm α\nh : ∀ (x : α), Iff (p x) (p (f x))\nx : Subtype fun x => p x\n⊢ Eq ((f.subtypePerm h) x) ⟨f ↑x, ⋯⟩","decl":"@[simp]\ntheorem subtypePerm_apply (f : Perm α) (h : ∀ x, p x ↔ p (f x)) (x : { x // p x }) :\n    subtypePerm f h x = ⟨f x, (h _).1 x.2⟩ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.subtypePerm_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nh : optParam (∀ (x : α), Iff (p x) (p x)) ⋯\n⊢ Eq (Equiv.Perm.subtypePerm 1 h) 1","decl":"@[simp]\ntheorem subtypePerm_one (p : α → Prop) (h := fun _ => Iff.rfl) : @subtypePerm α p 1 h = 1 :=\n  rfl\n\n"}
{"name":"Equiv.Perm.subtypePerm_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nf g : Equiv.Perm α\nhf : ∀ (x : α), Iff (p x) (p (f x))\nhg : ∀ (x : α), Iff (p x) (p (g x))\n⊢ Eq (HMul.hMul (f.subtypePerm hf) (g.subtypePerm hg)) ((HMul.hMul f g).subtypePerm ⋯)","decl":"@[simp]\ntheorem subtypePerm_mul (f g : Perm α) (hf hg) :\n    (f.subtypePerm hf * g.subtypePerm hg : Perm { x // p x }) =\n      (f * g).subtypePerm fun _ => (hg _).trans <| hf _ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.subtypePerm_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Equiv.Perm α\nhf : ∀ (x : α), Iff (p x) (p ((Inv.inv f) x))\n⊢ Eq ((Inv.inv f).subtypePerm hf) (Inv.inv (f.subtypePerm ⋯))","decl":"/-- See `Equiv.Perm.inv_subtypePerm`-/\ntheorem subtypePerm_inv (f : Perm α) (hf) :\n    f⁻¹.subtypePerm hf = (f.subtypePerm <| inv_aux.2 hf : Perm { x // p x })⁻¹ :=\n  rfl\n\n"}
{"name":"Equiv.Perm.inv_subtypePerm","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Equiv.Perm α\nhf : ∀ (x : α), Iff (p x) (p (f x))\n⊢ Eq (Inv.inv (f.subtypePerm hf)) ((Inv.inv f).subtypePerm ⋯)","decl":"/-- See `Equiv.Perm.subtypePerm_inv`-/\n@[simp]\ntheorem inv_subtypePerm (f : Perm α) (hf) :\n    (f.subtypePerm hf : Perm { x // p x })⁻¹ = f⁻¹.subtypePerm (inv_aux.1 hf) :=\n  rfl\n\n"}
{"name":"Equiv.Perm.subtypePerm_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Equiv.Perm α\nn : Nat\nhf : ∀ (x : α), Iff (p x) (p (f x))\n⊢ Eq (HPow.hPow (f.subtypePerm hf) n) ((HPow.hPow f n).subtypePerm ⋯)","decl":"@[simp]\ntheorem subtypePerm_pow (f : Perm α) (n : ℕ) (hf) :\n    (f.subtypePerm hf : Perm { x // p x }) ^ n = (f ^ n).subtypePerm (pow_aux hf) := by\n  induction n with\n  | zero => simp\n  | succ n ih => simp_rw [pow_succ', ih, subtypePerm_mul]\n\n"}
{"name":"Equiv.Perm.subtypePerm_zpow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\nf : Equiv.Perm α\nn : Int\nhf : ∀ (x : α), Iff (p x) (p (f x))\n⊢ Eq (HPow.hPow (f.subtypePerm hf) n) ((HPow.hPow f n).subtypePerm ⋯)","decl":"@[simp]\ntheorem subtypePerm_zpow (f : Perm α) (n : ℤ) (hf) :\n    (f.subtypePerm hf ^ n : Perm { x // p x }) = (f ^ n).subtypePerm (zpow_aux hf) := by\n  induction n with\n  | ofNat n => exact subtypePerm_pow _ _ _\n  | negSucc n => simp only [zpow_negSucc, subtypePerm_pow, subtypePerm_inv]\n\n"}
{"name":"Equiv.Perm.ofSubtype_subtypePerm","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm α\nh₁ : ∀ (x : α), Iff (p x) (p (f x))\nh₂ : ∀ (x : α), Ne (f x) x → p x\n⊢ Eq (Equiv.Perm.ofSubtype (f.subtypePerm h₁)) f","decl":"theorem ofSubtype_subtypePerm {f : Perm α} (h₁ : ∀ x, p x ↔ p (f x)) (h₂ : ∀ x, f x ≠ x → p x) :\n    ofSubtype (subtypePerm f h₁) = f :=\n  Equiv.ext fun x => by\n    by_cases hx : p x\n    · exact (subtypePerm f h₁).extendDomain_apply_subtype _ hx\n    · rw [ofSubtype, MonoidHom.coe_mk]\n      -- Porting note: added `dsimp`\n      dsimp only [OneHom.coe_mk]\n      rw [Equiv.Perm.extendDomain_apply_not_subtype _ _ hx]\n      exact not_not.mp fun h => hx (h₂ x (Ne.symm h))\n\n"}
{"name":"Equiv.Perm.ofSubtype_apply_of_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\na : α\nf : Equiv.Perm (Subtype p)\nha : p a\n⊢ Eq ((Equiv.Perm.ofSubtype f) a) ↑(f ⟨a, ha⟩)","decl":"theorem ofSubtype_apply_of_mem (f : Perm (Subtype p)) (ha : p a) : ofSubtype f a = f ⟨a, ha⟩ :=\n  extendDomain_apply_subtype _ _ ha\n\n"}
{"name":"Equiv.Perm.ofSubtype_apply_coe","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm (Subtype p)\nx : Subtype p\n⊢ Eq ((Equiv.Perm.ofSubtype f) ↑x) ↑(f x)","decl":"@[simp]\ntheorem ofSubtype_apply_coe (f : Perm (Subtype p)) (x : Subtype p) : ofSubtype f x = f x :=\n  Subtype.casesOn x fun _ => ofSubtype_apply_of_mem f\n\n"}
{"name":"Equiv.Perm.ofSubtype_apply_of_not_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\na : α\nf : Equiv.Perm (Subtype p)\nha : Not (p a)\n⊢ Eq ((Equiv.Perm.ofSubtype f) a) a","decl":"theorem ofSubtype_apply_of_not_mem (f : Perm (Subtype p)) (ha : ¬p a) : ofSubtype f a = a :=\n  extendDomain_apply_not_subtype _ _ ha\n\n"}
{"name":"Equiv.Perm.mem_iff_ofSubtype_apply_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm (Subtype p)\nx : α\n⊢ Iff (p x) (p ((Equiv.Perm.ofSubtype f) x))","decl":"theorem mem_iff_ofSubtype_apply_mem (f : Perm (Subtype p)) (x : α) :\n    p x ↔ p ((ofSubtype f : α → α) x) :=\n  if h : p x then by\n    simpa only [h, true_iff, MonoidHom.coe_mk, ofSubtype_apply_of_mem f h] using (f ⟨x, h⟩).2\n  else by simp [h, ofSubtype_apply_of_not_mem f h]\n\n"}
{"name":"Equiv.Perm.ofSubtype_injective","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Function.Injective ⇑Equiv.Perm.ofSubtype","decl":"theorem ofSubtype_injective : Function.Injective (ofSubtype : Perm (Subtype p) → Perm α) := by\n  intro x y h\n  rw [Perm.ext_iff] at h ⊢\n  intro a\n  specialize h a\n  rwa [ofSubtype_apply_coe, ofSubtype_apply_coe, SetCoe.ext_iff] at h\n\n"}
{"name":"Equiv.Perm.subtypePerm_ofSubtype","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm (Subtype p)\n⊢ Eq ((Equiv.Perm.ofSubtype f).subtypePerm ⋯) f","decl":"@[simp]\ntheorem subtypePerm_ofSubtype (f : Perm (Subtype p)) :\n    subtypePerm (ofSubtype f) (mem_iff_ofSubtype_apply_mem f) = f :=\n  Equiv.ext fun x => Subtype.coe_injective (ofSubtype_apply_coe f x)\n\n"}
{"name":"Equiv.Perm.ofSubtype_subtypePerm_of_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\ng : Equiv.Perm α\nhg : ∀ (x : α), Iff (p x) (p (g x))\na : α\nha : p a\n⊢ Eq ((Equiv.Perm.ofSubtype (g.subtypePerm hg)) a) (g a)","decl":"theorem ofSubtype_subtypePerm_of_mem {p : α → Prop} [DecidablePred p]\n    {g : Perm α} (hg : ∀ (x : α), p x ↔ p (g x))\n    {a : α} (ha : p a) : (ofSubtype (g.subtypePerm hg)) a = g a :=\n  ofSubtype_apply_of_mem (g.subtypePerm hg) ha\n\n"}
{"name":"Equiv.Perm.ofSubtype_subtypePerm_of_not_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\ng : Equiv.Perm α\nhg : ∀ (x : α), Iff (p x) (p (g x))\na : α\nha : Not (p a)\n⊢ Eq ((Equiv.Perm.ofSubtype (g.subtypePerm hg)) a) a","decl":"theorem ofSubtype_subtypePerm_of_not_mem {p : α → Prop} [DecidablePred p]\n    {g : Perm α} (hg : ∀ (x : α), p x ↔ p (g x))\n    {a : α} (ha : ¬ p a) : (ofSubtype (g.subtypePerm hg)) a = a :=\n  ofSubtype_apply_of_not_mem (g.subtypePerm hg) ha\n\n"}
{"name":"Equiv.Perm.subtypeEquivSubtypePerm_symm_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nf : Subtype fun f => ∀ (a : α), Not (p a) → Eq (f a) a\n⊢ Eq ((Equiv.Perm.subtypeEquivSubtypePerm p).symm f) ((↑f).subtypePerm ⋯)","decl":"/-- Permutations on a subtype are equivalent to permutations on the original type that fix pointwise\nthe rest. -/\n@[simps]\nprotected def subtypeEquivSubtypePerm (p : α → Prop) [DecidablePred p] :\n    Perm (Subtype p) ≃ { f : Perm α // ∀ a, ¬p a → f a = a } where\n  toFun f := ⟨ofSubtype f, fun _ => f.ofSubtype_apply_of_not_mem⟩\n  invFun f :=\n    (f : Perm α).subtypePerm fun a =>\n      ⟨Decidable.not_imp_not.1 fun hfa => f.val.injective (f.prop _ hfa) ▸ hfa,\n        Decidable.not_imp_not.1 fun ha hfa => ha <| f.prop a ha ▸ hfa⟩\n  left_inv := Equiv.Perm.subtypePerm_ofSubtype\n  right_inv f :=\n    Subtype.ext ((Equiv.Perm.ofSubtype_subtypePerm _) fun a => Not.decidable_imp_symm <| f.prop a)\n\n"}
{"name":"Equiv.Perm.subtypeEquivSubtypePerm_apply_coe","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\nf : Equiv.Perm (Subtype p)\n⊢ Eq (↑((Equiv.Perm.subtypeEquivSubtypePerm p) f)) (Equiv.Perm.ofSubtype f)","decl":"/-- Permutations on a subtype are equivalent to permutations on the original type that fix pointwise\nthe rest. -/\n@[simps]\nprotected def subtypeEquivSubtypePerm (p : α → Prop) [DecidablePred p] :\n    Perm (Subtype p) ≃ { f : Perm α // ∀ a, ¬p a → f a = a } where\n  toFun f := ⟨ofSubtype f, fun _ => f.ofSubtype_apply_of_not_mem⟩\n  invFun f :=\n    (f : Perm α).subtypePerm fun a =>\n      ⟨Decidable.not_imp_not.1 fun hfa => f.val.injective (f.prop _ hfa) ▸ hfa,\n        Decidable.not_imp_not.1 fun ha hfa => ha <| f.prop a ha ▸ hfa⟩\n  left_inv := Equiv.Perm.subtypePerm_ofSubtype\n  right_inv f :=\n    Subtype.ext ((Equiv.Perm.ofSubtype_subtypePerm _) fun a => Not.decidable_imp_symm <| f.prop a)\n\n"}
{"name":"Equiv.Perm.subtypeEquivSubtypePerm_apply_of_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\na : α\nf : Equiv.Perm (Subtype p)\nh : p a\n⊢ Eq (↑((Equiv.Perm.subtypeEquivSubtypePerm p).toFun f) a) ↑(f ⟨a, h⟩)","decl":"theorem subtypeEquivSubtypePerm_apply_of_mem (f : Perm (Subtype p)) (h : p a) :\n    -- Porting note: was `Perm.subtypeEquivSubtypePerm p f a`\n    ((Perm.subtypeEquivSubtypePerm p).toFun f).1 a = f ⟨a, h⟩ :=\n  f.ofSubtype_apply_of_mem h\n\n"}
{"name":"Equiv.Perm.subtypeEquivSubtypePerm_apply_of_not_mem","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\np : α → Prop\ninst✝ : DecidablePred p\na : α\nf : Equiv.Perm (Subtype p)\nh : Not (p a)\n⊢ Eq (↑((Equiv.Perm.subtypeEquivSubtypePerm p).toFun f) a) a","decl":"theorem subtypeEquivSubtypePerm_apply_of_not_mem (f : Perm (Subtype p)) (h : ¬p a) :\n    -- Porting note: was `Perm.subtypeEquivSubtypePerm p f a`\n    ((Perm.subtypeEquivSubtypePerm p).toFun f).1 a = a :=\n  f.ofSubtype_apply_of_not_mem h\n\n"}
{"name":"Equiv.swap_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nx y : α\n⊢ Eq (Inv.inv (Equiv.swap x y)) (Equiv.swap x y)","decl":"@[simp]\ntheorem swap_inv (x y : α) : (swap x y)⁻¹ = swap x y :=\n  rfl\n\n"}
{"name":"Equiv.swap_mul_self","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\n⊢ Eq (HMul.hMul (Equiv.swap i j) (Equiv.swap i j)) 1","decl":"@[simp]\ntheorem swap_mul_self (i j : α) : swap i j * swap i j = 1 :=\n  swap_swap i j\n\n"}
{"name":"Equiv.swap_mul_eq_mul_swap","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx y : α\n⊢ Eq (HMul.hMul (Equiv.swap x y) f) (HMul.hMul f (Equiv.swap ((Inv.inv f) x) ((Inv.inv f) y)))","decl":"theorem swap_mul_eq_mul_swap (f : Perm α) (x y : α) : swap x y * f = f * swap (f⁻¹ x) (f⁻¹ y) :=\n  Equiv.ext fun z => by\n    simp only [Perm.mul_apply, swap_apply_def]\n    split_ifs <;>\n      simp_all only [Perm.apply_inv_self, Perm.eq_inv_iff_eq, eq_self_iff_true, not_true]\n\n"}
{"name":"Equiv.mul_swap_eq_swap_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx y : α\n⊢ Eq (HMul.hMul f (Equiv.swap x y)) (HMul.hMul (Equiv.swap (f x) (f y)) f)","decl":"theorem mul_swap_eq_swap_mul (f : Perm α) (x y : α) : f * swap x y = swap (f x) (f y) * f := by\n  rw [swap_mul_eq_mul_swap, Perm.inv_apply_self, Perm.inv_apply_self]\n\n"}
{"name":"Equiv.swap_apply_apply","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nf : Equiv.Perm α\nx y : α\n⊢ Eq (Equiv.swap (f x) (f y)) (HMul.hMul (HMul.hMul f (Equiv.swap x y)) (Inv.inv f))","decl":"theorem swap_apply_apply (f : Perm α) (x y : α) : swap (f x) (f y) = f * swap x y * f⁻¹ := by\n  rw [mul_swap_eq_swap_mul, mul_inv_cancel_right]\n\n"}
{"name":"Equiv.swap_smul_self_smul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : MulAction (Equiv.Perm α) β\ni j : α\nx : β\n⊢ Eq (HSMul.hSMul (Equiv.swap i j) (HSMul.hSMul (Equiv.swap i j) x)) x","decl":"@[simp]\ntheorem swap_smul_self_smul [MulAction (Perm α) β] (i j : α) (x : β) :\n    swap i j • swap i j • x = x := by simp [smul_smul]\n\n"}
{"name":"Equiv.swap_smul_involutive","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : DecidableEq α\ninst✝ : MulAction (Equiv.Perm α) β\ni j : α\n⊢ Function.Involutive fun x => HSMul.hSMul (Equiv.swap i j) x","decl":"theorem swap_smul_involutive [MulAction (Perm α) β] (i j : α) :\n    Function.Involutive (swap i j • · : β → β) := swap_smul_self_smul i j\n\n"}
{"name":"Equiv.swap_mul_self_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\nσ : Equiv.Perm α\n⊢ Eq (HMul.hMul (Equiv.swap i j) (HMul.hMul (Equiv.swap i j) σ)) σ","decl":"/-- Left-multiplying a permutation with `swap i j` twice gives the original permutation.\n\n  This specialization of `swap_mul_self` is useful when using cosets of permutations.\n-/\n@[simp]\ntheorem swap_mul_self_mul (i j : α) (σ : Perm α) : Equiv.swap i j * (Equiv.swap i j * σ) = σ :=\n  swap_smul_self_smul i j σ\n\n"}
{"name":"Equiv.mul_swap_mul_self","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\nσ : Equiv.Perm α\n⊢ Eq (HMul.hMul (HMul.hMul σ (Equiv.swap i j)) (Equiv.swap i j)) σ","decl":"/-- Right-multiplying a permutation with `swap i j` twice gives the original permutation.\n\n  This specialization of `swap_mul_self` is useful when using cosets of permutations.\n-/\n@[simp]\ntheorem mul_swap_mul_self (i j : α) (σ : Perm α) : σ * Equiv.swap i j * Equiv.swap i j = σ := by\n  rw [mul_assoc, swap_mul_self, mul_one]\n\n"}
{"name":"Equiv.swap_mul_involutive","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\n⊢ Function.Involutive fun x => HMul.hMul (Equiv.swap i j) x","decl":"/-- A stronger version of `mul_right_injective` -/\n@[simp]\ntheorem swap_mul_involutive (i j : α) : Function.Involutive (Equiv.swap i j * ·) :=\n  swap_mul_self_mul i j\n\n"}
{"name":"Equiv.mul_swap_involutive","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\n⊢ Function.Involutive fun x => HMul.hMul x (Equiv.swap i j)","decl":"/-- A stronger version of `mul_left_injective` -/\n@[simp]\ntheorem mul_swap_involutive (i j : α) : Function.Involutive (· * Equiv.swap i j) :=\n  mul_swap_mul_self i j\n\n"}
{"name":"Equiv.swap_eq_one_iff","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\n⊢ Iff (Eq (Equiv.swap i j) 1) (Eq i j)","decl":"@[simp]\ntheorem swap_eq_one_iff {i j : α} : swap i j = (1 : Perm α) ↔ i = j :=\n  swap_eq_refl_iff\n\n"}
{"name":"Equiv.swap_mul_eq_iff","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\nσ : Equiv.Perm α\n⊢ Iff (Eq (HMul.hMul (Equiv.swap i j) σ) σ) (Eq i j)","decl":"theorem swap_mul_eq_iff {i j : α} {σ : Perm α} : swap i j * σ = σ ↔ i = j := by\n  rw [mul_left_eq_self, swap_eq_one_iff]\n\n"}
{"name":"Equiv.mul_swap_eq_iff","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\ni j : α\nσ : Equiv.Perm α\n⊢ Iff (Eq (HMul.hMul σ (Equiv.swap i j)) σ) (Eq i j)","decl":"theorem mul_swap_eq_iff {i j : α} {σ : Perm α} : σ * swap i j = σ ↔ i = j := by\n  rw [mul_right_eq_self, swap_eq_one_iff]\n\n"}
{"name":"Equiv.swap_mul_swap_mul_swap","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : DecidableEq α\nx y z : α\nhxy : Ne x y\nhxz : Ne x z\n⊢ Eq (HMul.hMul (HMul.hMul (Equiv.swap y z) (Equiv.swap x y)) (Equiv.swap y z)) (Equiv.swap z x)","decl":"theorem swap_mul_swap_mul_swap {x y z : α} (hxy : x ≠ y) (hxz : x ≠ z) :\n    swap y z * swap x y * swap y z = swap z x := by\n  nth_rewrite 3 [← swap_inv]\n  rw [← swap_apply_apply, swap_apply_left, swap_apply_of_ne_of_ne hxy hxz, swap_comm]\n\n"}
{"name":"Equiv.addLeft_zero","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\n⊢ Eq (Equiv.addLeft 0) 1","decl":"@[simp] lemma addLeft_zero : Equiv.addLeft (0 : α) = 1 := ext zero_add\n\n"}
{"name":"Equiv.addRight_zero","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\n⊢ Eq (Equiv.addRight 0) 1","decl":"@[simp] lemma addRight_zero : Equiv.addRight (0 : α) = 1 := ext add_zero\n\n"}
{"name":"Equiv.addLeft_add","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na b : α\n⊢ Eq (Equiv.addLeft (HAdd.hAdd a b)) (HMul.hMul (Equiv.addLeft a) (Equiv.addLeft b))","decl":"@[simp] lemma addLeft_add : Equiv.addLeft (a + b) = Equiv.addLeft a * Equiv.addLeft b :=\n  ext <| add_assoc _ _\n\n"}
{"name":"Equiv.addRight_add","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na b : α\n⊢ Eq (Equiv.addRight (HAdd.hAdd a b)) (HMul.hMul (Equiv.addRight b) (Equiv.addRight a))","decl":"@[simp] lemma addRight_add : Equiv.addRight (a + b) = Equiv.addRight b * Equiv.addRight a :=\n  ext fun _ ↦ (add_assoc _ _ _).symm\n\n"}
{"name":"Equiv.inv_addLeft","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\n⊢ Eq (Inv.inv (Equiv.addLeft a)) (Equiv.addLeft (Neg.neg a))","decl":"@[simp] lemma inv_addLeft : (Equiv.addLeft a)⁻¹ = Equiv.addLeft (-a) := Equiv.coe_inj.1 rfl\n\n"}
{"name":"Equiv.inv_addRight","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\n⊢ Eq (Inv.inv (Equiv.addRight a)) (Equiv.addRight (Neg.neg a))","decl":"@[simp] lemma inv_addRight : (Equiv.addRight a)⁻¹ = Equiv.addRight (-a) := Equiv.coe_inj.1 rfl\n\n"}
{"name":"Equiv.pow_addLeft","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Equiv.addLeft a) n) (Equiv.addLeft (HSMul.hSMul n a))","decl":"@[simp] lemma pow_addLeft (n : ℕ) : Equiv.addLeft a ^ n = Equiv.addLeft (n • a) := by\n  ext; simp [Perm.coe_pow]\n\n"}
{"name":"Equiv.pow_addRight","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Equiv.addRight a) n) (Equiv.addRight (HSMul.hSMul n a))","decl":"@[simp] lemma pow_addRight (n : ℕ) : Equiv.addRight a ^ n = Equiv.addRight (n • a) := by\n  ext; simp [Perm.coe_pow]\n\n"}
{"name":"Equiv.zpow_addLeft","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Equiv.addLeft a) n) (Equiv.addLeft (HSMul.hSMul n a))","decl":"@[simp] lemma zpow_addLeft (n : ℤ) : Equiv.addLeft a ^ n = Equiv.addLeft (n • a) :=\n  (map_zsmul ({ toFun := Equiv.addLeft, map_zero' := addLeft_zero, map_add' := addLeft_add } :\n    α →+ Additive (Perm α)) _ _).symm\n\n"}
{"name":"Equiv.zpow_addRight","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : AddGroup α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Equiv.addRight a) n) (Equiv.addRight (HSMul.hSMul n a))","decl":"@[simp] lemma zpow_addRight : ∀ (n : ℤ), Equiv.addRight a ^ n = Equiv.addRight (n • a)\n  | Int.ofNat n => by simp\n  | Int.negSucc n => by simp\n\n"}
{"name":"Equiv.mulLeft_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\n⊢ Eq (Equiv.mulLeft 1) 1","decl":"@[to_additive existing (attr := simp)]\nlemma mulLeft_one : Equiv.mulLeft (1 : α) = 1 := ext one_mul\n\n"}
{"name":"Equiv.mulRight_one","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\n⊢ Eq (Equiv.mulRight 1) 1","decl":"@[to_additive existing (attr := simp)]\nlemma mulRight_one : Equiv.mulRight (1 : α) = 1 := ext mul_one\n\n"}
{"name":"Equiv.mulLeft_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na b : α\n⊢ Eq (Equiv.mulLeft (HMul.hMul a b)) (HMul.hMul (Equiv.mulLeft a) (Equiv.mulLeft b))","decl":"@[to_additive existing (attr := simp)]\nlemma mulLeft_mul : Equiv.mulLeft (a * b) = Equiv.mulLeft a * Equiv.mulLeft b :=\n  ext <| mul_assoc _ _\n\n"}
{"name":"Equiv.mulRight_mul","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na b : α\n⊢ Eq (Equiv.mulRight (HMul.hMul a b)) (HMul.hMul (Equiv.mulRight b) (Equiv.mulRight a))","decl":"@[to_additive existing (attr := simp)]\nlemma mulRight_mul : Equiv.mulRight (a * b) = Equiv.mulRight b * Equiv.mulRight a :=\n  ext fun _ ↦ (mul_assoc _ _ _).symm\n\n"}
{"name":"Equiv.inv_mulLeft","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na : α\n⊢ Eq (Inv.inv (Equiv.mulLeft a)) (Equiv.mulLeft (Inv.inv a))","decl":"@[to_additive existing (attr := simp) inv_addLeft]\nlemma inv_mulLeft : (Equiv.mulLeft a)⁻¹ = Equiv.mulLeft a⁻¹ := Equiv.coe_inj.1 rfl\n\n"}
{"name":"Equiv.inv_mulRight","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na : α\n⊢ Eq (Inv.inv (Equiv.mulRight a)) (Equiv.mulRight (Inv.inv a))","decl":"@[to_additive existing (attr := simp) inv_addRight]\nlemma inv_mulRight : (Equiv.mulRight a)⁻¹ = Equiv.mulRight a⁻¹ := Equiv.coe_inj.1 rfl\n\n"}
{"name":"Equiv.pow_mulLeft","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Equiv.mulLeft a) n) (Equiv.mulLeft (HPow.hPow a n))","decl":"@[to_additive existing (attr := simp) pow_addLeft]\nlemma pow_mulLeft (n : ℕ) : Equiv.mulLeft a ^ n = Equiv.mulLeft (a ^ n) := by\n  ext; simp [Perm.coe_pow]\n\n"}
{"name":"Equiv.pow_mulRight","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na : α\nn : Nat\n⊢ Eq (HPow.hPow (Equiv.mulRight a) n) (Equiv.mulRight (HPow.hPow a n))","decl":"@[to_additive existing (attr := simp) pow_addRight]\nlemma pow_mulRight (n : ℕ) : Equiv.mulRight a ^ n = Equiv.mulRight (a ^ n) := by\n  ext; simp [Perm.coe_pow]\n\n"}
{"name":"Equiv.zpow_mulLeft","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Equiv.mulLeft a) n) (Equiv.mulLeft (HPow.hPow a n))","decl":"@[to_additive existing (attr := simp) zpow_addLeft]\nlemma zpow_mulLeft (n : ℤ) : Equiv.mulLeft a ^ n = Equiv.mulLeft (a ^ n) :=\n  (map_zpow ({ toFun := Equiv.mulLeft, map_one' := mulLeft_one, map_mul' := mulLeft_mul } :\n              α →* Perm α) _ _).symm\n\n"}
{"name":"Equiv.zpow_mulRight","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u\ninst✝ : Group α\na : α\nn : Int\n⊢ Eq (HPow.hPow (Equiv.mulRight a) n) (Equiv.mulRight (HPow.hPow a n))","decl":"@[to_additive existing (attr := simp) zpow_addRight]\nlemma zpow_mulRight : ∀ n : ℤ, Equiv.mulRight a ^ n = Equiv.mulRight (a ^ n)\n  | Int.ofNat n => by simp\n  | Int.negSucc n => by simp\n\n"}
{"name":"Set.BijOn.perm_inv","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nf : Equiv.Perm α\ns : Set α\nhf : Set.BijOn (⇑f) s s\n⊢ Set.BijOn (⇑(Inv.inv f)) s s","decl":"lemma BijOn.perm_inv (hf : BijOn f s s) : BijOn ↑(f⁻¹) s s := hf.symm f.invOn\n\n"}
{"name":"Set.MapsTo.perm_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nf : Equiv.Perm α\ns : Set α\na✝ : Set.MapsTo (⇑f) s s\nn : Nat\n⊢ Set.MapsTo (⇑(HPow.hPow f n)) s s","decl":"lemma MapsTo.perm_pow : MapsTo f s s → ∀ n : ℕ, MapsTo (f ^ n) s s := by\n  simp_rw [Equiv.Perm.coe_pow]; exact MapsTo.iterate\n"}
{"name":"Set.SurjOn.perm_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nf : Equiv.Perm α\ns : Set α\na✝ : Set.SurjOn (⇑f) s s\nn : Nat\n⊢ Set.SurjOn (⇑(HPow.hPow f n)) s s","decl":"lemma SurjOn.perm_pow : SurjOn f s s → ∀ n : ℕ, SurjOn (f ^ n) s s := by\n  simp_rw [Equiv.Perm.coe_pow]; exact SurjOn.iterate\n"}
{"name":"Set.BijOn.perm_pow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nf : Equiv.Perm α\ns : Set α\na✝ : Set.BijOn (⇑f) s s\nn : Nat\n⊢ Set.BijOn (⇑(HPow.hPow f n)) s s","decl":"lemma BijOn.perm_pow : BijOn f s s → ∀ n : ℕ, BijOn (f ^ n) s s := by\n  simp_rw [Equiv.Perm.coe_pow]; exact BijOn.iterate\n\n"}
{"name":"Set.BijOn.perm_zpow","module":"Mathlib.GroupTheory.Perm.Basic","initialProofState":"α : Type u_1\nf : Equiv.Perm α\ns : Set α\nhf : Set.BijOn (⇑f) s s\nn : Int\n⊢ Set.BijOn (⇑(HPow.hPow f n)) s s","decl":"lemma BijOn.perm_zpow (hf : BijOn f s s) : ∀ n : ℤ, BijOn (f ^ n) s s\n  | Int.ofNat n => hf.perm_pow n\n  | Int.negSucc n => (hf.perm_pow (n + 1)).perm_inv\n\n"}
