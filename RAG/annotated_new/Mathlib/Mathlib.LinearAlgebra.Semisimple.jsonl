{"name":"Module.End.isSemisimple_iff'","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Iff f.IsSemisimple (∀ (p : Subtype fun x => Membership.mem f.invtSubmodule x), Exists fun q => IsCompl p q)","decl":"/-- A linear endomorphism is semisimple if every invariant submodule has in invariant complement.\n\nSee also `Module.End.isSemisimple_iff`. -/\nlemma isSemisimple_iff' :\n    f.IsSemisimple ↔ ∀ p : invtSubmodule f, ∃ q : invtSubmodule f, IsCompl p q := by\n  rw [IsSemisimple, IsSemisimpleModule, (AEval.mapSubmodule R M f).symm.complementedLattice_iff,\n    complementedLattice_iff]\n  rfl\n\n"}
{"name":"Module.End.isSemisimple_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Iff f.IsSemisimple (∀ (p : Submodule R M), Membership.mem f.invtSubmodule p → Exists fun q => And (Membership.mem f.invtSubmodule q) (IsCompl p q))","decl":"lemma isSemisimple_iff :\n    f.IsSemisimple ↔ ∀ p ∈ invtSubmodule f, ∃ q ∈ invtSubmodule f, IsCompl p q := by\n  simp [isSemisimple_iff']\n\n"}
{"name":"Module.End.isSemisimple_restrict_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : Membership.mem f.invtSubmodule p\n⊢ Iff (Module.End.IsSemisimple (LinearMap.restrict f hp)) (∀ (q : Submodule R M), Membership.mem f.invtSubmodule q → LE.le q p → Exists fun r => And (LE.le r p) (And (Membership.mem f.invtSubmodule r) (And (Disjoint q r) (Eq (Max.max q r) p))))","decl":"lemma isSemisimple_restrict_iff (p) (hp : p ∈ invtSubmodule f) :\n    IsSemisimple (LinearMap.restrict f hp) ↔\n    ∀ q ∈ f.invtSubmodule, q ≤ p → ∃ r ≤ p, r ∈ f.invtSubmodule ∧ Disjoint q r ∧ q ⊔ r = p := by\n  let e : Submodule R[X] (AEval' (f.restrict hp)) ≃o Iic (AEval.mapSubmodule R M f ⟨p, hp⟩) :=\n    (Submodule.orderIsoMapComap <| AEval.restrict_equiv_mapSubmodule f p hp).trans\n      (Submodule.mapIic _)\n  simp_rw [IsSemisimple, IsSemisimpleModule, e.complementedLattice_iff, disjoint_iff,\n    ← (OrderIso.Iic _ _).complementedLattice_iff, Iic.complementedLattice_iff, Subtype.forall,\n    Subtype.exists, Subtype.mk_le_mk, Sublattice.mk_inf_mk, Sublattice.mk_sup_mk, Subtype.mk.injEq,\n    exists_and_left, exists_and_right, invtSubmodule.mk_eq_bot_iff, exists_prop, and_assoc]\n  rfl\n\n"}
{"name":"Module.End.isFinitelySemisimple_iff'","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Iff f.IsFinitelySemisimple (∀ (p : Submodule R M) (hp : Membership.mem f.invtSubmodule p), Module.Finite R (Subtype fun x => Membership.mem p x) → Module.End.IsSemisimple (LinearMap.restrict f hp))","decl":"/-- A linear endomorphism is finitely semisimple if it is semisimple on every finitely-generated\ninvariant submodule.\n\nSee also `Module.End.isFinitelySemisimple_iff`. -/\nlemma isFinitelySemisimple_iff' :\n    f.IsFinitelySemisimple ↔ ∀ p (hp : p ∈ invtSubmodule f),\n      Module.Finite R p → IsSemisimple (LinearMap.restrict f hp) :=\n  Iff.rfl\n\n"}
{"name":"Module.End.isFinitelySemisimple_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Iff f.IsFinitelySemisimple (∀ (p : Submodule R M), Membership.mem f.invtSubmodule p → Module.Finite R (Subtype fun x => Membership.mem p x) → ∀ (q : Submodule R M), Membership.mem f.invtSubmodule q → LE.le q p → Exists fun r => And (LE.le r p) (And (Membership.mem f.invtSubmodule r) (And (Disjoint q r) (Eq (Max.max q r) p))))","decl":"/-- A characterisation of `Module.End.IsFinitelySemisimple` using only the lattice of submodules of\n`M` (thus avoiding submodules of submodules). -/\nlemma isFinitelySemisimple_iff :\n    f.IsFinitelySemisimple ↔ ∀ p ∈ invtSubmodule f, Module.Finite R p → ∀ q ∈ invtSubmodule f,\n      q ≤ p → ∃ r, r ≤ p ∧ r ∈ invtSubmodule f ∧ Disjoint q r ∧ q ⊔ r = p := by\n  simp_rw [isFinitelySemisimple_iff', isSemisimple_restrict_iff]\n\n"}
{"name":"Module.End.isSemisimple_zero","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ Module.End.IsSemisimple 0","decl":"@[simp]\nlemma isSemisimple_zero [IsSemisimpleModule R M] : IsSemisimple (0 : Module.End R M) := by\n  simpa [isSemisimple_iff] using exists_isCompl\n\n"}
{"name":"Module.End.isSemisimple_id","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ Module.End.IsSemisimple LinearMap.id","decl":"@[simp]\nlemma isSemisimple_id [IsSemisimpleModule R M] : IsSemisimple (LinearMap.id : Module.End R M) := by\n  simpa [isSemisimple_iff] using exists_isCompl\n\n"}
{"name":"Module.End.isSemisimple_neg","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\n⊢ Iff (Neg.neg f).IsSemisimple f.IsSemisimple","decl":"@[simp] lemma isSemisimple_neg : (-f).IsSemisimple ↔ f.IsSemisimple := by\n  simp [isSemisimple_iff, mem_invtSubmodule]\n\n"}
{"name":"LinearEquiv.isSemisimple_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\nf : Module.End R M\nM₂ : Type u_3\ninst✝¹ : AddCommGroup M₂\ninst✝ : Module R M₂\ng : Module.End R M₂\ne : LinearEquiv (RingHom.id R) M M₂\nhe : Eq ((↑e).comp f) (LinearMap.comp g ↑e)\n⊢ Iff f.IsSemisimple g.IsSemisimple","decl":"variable (f) in\nprotected lemma _root_.LinearEquiv.isSemisimple_iff {M₂ : Type*} [AddCommGroup M₂] [Module R M₂]\n    (g : End R M₂) (e : M ≃ₗ[R] M₂) (he : e ∘ₗ f = g ∘ₗ e) :\n    f.IsSemisimple ↔ g.IsSemisimple := by\n  let e : AEval' f ≃ₗ[R[X]] AEval' g := LinearEquiv.ofAEval _ (e.trans (AEval'.of g)) fun x ↦ by\n    simpa [AEval'.X_smul_of] using LinearMap.congr_fun he x\n  exact (Submodule.orderIsoMapComap e).complementedLattice_iff\n\n"}
{"name":"Module.End.eq_zero_of_isNilpotent_isSemisimple","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nhn : IsNilpotent f\nhs : f.IsSemisimple\n⊢ Eq f 0","decl":"lemma eq_zero_of_isNilpotent_isSemisimple (hn : IsNilpotent f) (hs : f.IsSemisimple) : f = 0 := by\n  have ⟨n, h0⟩ := hn\n  rw [← aeval_X (R := R) f]; rw [← aeval_X_pow (R := R) f] at h0\n  rw [← RingHom.mem_ker, ← AEval.annihilator_eq_ker_aeval (M := M)] at h0 ⊢\n  exact hs.annihilator_isRadical _ _ ⟨n, h0⟩\n\n"}
{"name":"Module.End.eq_zero_of_isNilpotent_of_isFinitelySemisimple","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nhn : IsNilpotent f\nhs : f.IsFinitelySemisimple\n⊢ Eq f 0","decl":"lemma eq_zero_of_isNilpotent_of_isFinitelySemisimple\n    (hn : IsNilpotent f) (hs : IsFinitelySemisimple f) : f = 0 := by\n  have (p) (hp₁ : p ∈ f.invtSubmodule) (hp₂ : Module.Finite R p) : f.restrict hp₁ = 0 := by\n    specialize hs p hp₁ hp₂\n    replace hn : IsNilpotent (f.restrict hp₁) := isNilpotent.restrict hp₁ hn\n    exact eq_zero_of_isNilpotent_isSemisimple hn hs\n  ext x\n  obtain ⟨k : ℕ, hk : f ^ k = 0⟩ := hn\n  let p := Submodule.span R {(f ^ i) x | (i : ℕ) (_ : i ≤ k)}\n  have hp₁ : p ∈ f.invtSubmodule := by\n    simp only [mem_invtSubmodule, p, Submodule.span_le]\n    rintro - ⟨i, hi, rfl⟩\n    apply Submodule.subset_span\n    rcases lt_or_eq_of_le hi with hik | rfl\n    · exact ⟨i + 1, hik, by simpa [LinearMap.pow_apply] using iterate_succ_apply' f i x⟩\n    · exact ⟨i, by simp [hk]⟩\n  have hp₂ : Module.Finite R p := by\n    let g : ℕ → M := fun i ↦ (f ^ i) x\n    have hg : {(f ^ i) x | (i : ℕ) (_ : i ≤ k)} = g '' Iic k := by ext; simp [g]\n    exact Module.Finite.span_of_finite _ <| hg ▸ toFinite (g '' Iic k)\n  simpa [LinearMap.restrict_apply, Subtype.ext_iff] using\n    LinearMap.congr_fun (this p hp₁ hp₂) ⟨x, Submodule.subset_span ⟨0, k.zero_le, rfl⟩⟩\n\n"}
{"name":"Module.End.isSemisimple_sub_algebraMap_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Iff (HSub.hSub f ((algebraMap R (Module.End R M)) μ)).IsSemisimple f.IsSemisimple","decl":"@[simp]\nlemma isSemisimple_sub_algebraMap_iff {μ : R} :\n    (f - algebraMap R (End R M) μ).IsSemisimple ↔ f.IsSemisimple := by\n  suffices ∀ p : Submodule R M, p ≤ p.comap (f - algebraMap R (Module.End R M) μ) ↔ p ≤ p.comap f by\n    simp [mem_invtSubmodule, isSemisimple_iff, this]\n  refine fun p ↦ ⟨fun h x hx ↦ ?_, fun h x hx ↦ p.sub_mem (h hx) (p.smul_mem μ hx)⟩\n  simpa using p.add_mem (h hx) (p.smul_mem μ hx)\n\n"}
{"name":"Module.End.IsSemisimple.restrict","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhf : f.IsSemisimple\n⊢ Module.End.IsSemisimple (LinearMap.restrict f hp)","decl":"lemma IsSemisimple.restrict {p : Submodule R M} (hp : p ∈ f.invtSubmodule) (hf : f.IsSemisimple) :\n    IsSemisimple (f.restrict hp) := by\n  rw [IsSemisimple] at hf ⊢\n  let e : Submodule R[X] (AEval' (LinearMap.restrict f hp)) ≃o\n      Iic (AEval.mapSubmodule R M f ⟨p, hp⟩) :=\n    (Submodule.orderIsoMapComap <| AEval.restrict_equiv_mapSubmodule f p hp).trans <|\n      Submodule.mapIic _\n  exact e.complementedLattice_iff.mpr inferInstance\n\n"}
{"name":"Module.End.IsSemisimple.isFinitelySemisimple","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nhf : f.IsSemisimple\n⊢ f.IsFinitelySemisimple","decl":"lemma IsSemisimple.isFinitelySemisimple (hf : f.IsSemisimple) :\n    f.IsFinitelySemisimple :=\n  isFinitelySemisimple_iff'.mp fun _ _ _ ↦ hf.restrict _\n\n"}
{"name":"Module.End.isFinitelySemisimple_iff_isSemisimple","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nf : Module.End R M\ninst✝ : Module.Finite R M\n⊢ Iff f.IsFinitelySemisimple f.IsSemisimple","decl":"@[simp]\nlemma isFinitelySemisimple_iff_isSemisimple [Module.Finite R M] :\n    f.IsFinitelySemisimple ↔ f.IsSemisimple := by\n  refine ⟨fun hf ↦ isSemisimple_iff.mpr fun p hp ↦ ?_, IsSemisimple.isFinitelySemisimple⟩\n  obtain ⟨q, -, hq₁, hq₂, hq₃⟩ :=\n    isFinitelySemisimple_iff.mp hf ⊤ (invtSubmodule.top_mem f) inferInstance p hp le_top\n  exact ⟨q, hq₁, hq₂, codisjoint_iff.mpr hq₃⟩\n\n"}
{"name":"Module.End.isFinitelySemisimple_sub_algebraMap_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\nμ : R\n⊢ Iff (HSub.hSub f ((algebraMap R (Module.End R M)) μ)).IsFinitelySemisimple f.IsFinitelySemisimple","decl":"@[simp]\nlemma isFinitelySemisimple_sub_algebraMap_iff {μ : R} :\n    (f - algebraMap R (End R M) μ).IsFinitelySemisimple ↔ f.IsFinitelySemisimple := by\n  suffices ∀ p : Submodule R M, p ≤ p.comap (f - algebraMap R (Module.End R M) μ) ↔ p ≤ p.comap f by\n    simp_rw [isFinitelySemisimple_iff, mem_invtSubmodule, this]\n  refine fun p ↦ ⟨fun h x hx ↦ ?_, fun h x hx ↦ p.sub_mem (h hx) (p.smul_mem μ hx)⟩\n  simpa using p.add_mem (h hx) (p.smul_mem μ hx)\n\n"}
{"name":"Module.End.IsFinitelySemisimple.restrict","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nf : Module.End R M\np : Submodule R M\nhp : Membership.mem f.invtSubmodule p\nhf : f.IsFinitelySemisimple\n⊢ Module.End.IsFinitelySemisimple (LinearMap.restrict f hp)","decl":"lemma IsFinitelySemisimple.restrict {p : Submodule R M} (hp : p ∈ f.invtSubmodule)\n    (hf : f.IsFinitelySemisimple) :\n    IsFinitelySemisimple (f.restrict hp) := by\n  intro q hq₁ hq₂\n  have := invtSubmodule.map_subtype_mem_of_mem_invtSubmodule f hp hq₁\n  let e : q ≃ₗ[R] q.map p.subtype := p.equivSubtypeMap q\n  rw [e.isSemisimple_iff ((LinearMap.restrict f hp).restrict hq₁) (LinearMap.restrict f this) rfl]\n  exact hf _ this (Finite.map q p.subtype)\n\n"}
{"name":"Module.End.IsSemisimple_smul_iff","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Module K M\nf : Module.End K M\nt : K\nht : Ne t 0\n⊢ Iff (HSMul.hSMul t f).IsSemisimple f.IsSemisimple","decl":"lemma IsSemisimple_smul_iff {t : K} (ht : t ≠ 0) :\n    (t • f).IsSemisimple ↔ f.IsSemisimple := by\n  simp [isSemisimple_iff, mem_invtSubmodule, Submodule.comap_smul f (h := ht)]\n\n"}
{"name":"Module.End.IsSemisimple_smul","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Module K M\nf : Module.End K M\nt : K\nh : f.IsSemisimple\n⊢ (HSMul.hSMul t f).IsSemisimple","decl":"lemma IsSemisimple_smul (t : K) (h : f.IsSemisimple) :\n    (t • f).IsSemisimple := by\n  wlog ht : t ≠ 0; · simp [not_not.mp ht]\n  rwa [IsSemisimple_smul_iff ht]\n\n"}
{"name":"Module.End.isSemisimple_of_squarefree_aeval_eq_zero","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝² : AddCommGroup M\nK : Type u_3\ninst✝¹ : Field K\ninst✝ : Module K M\nf : Module.End K M\np : Polynomial K\nhp : Squarefree p\nhpf : Eq ((Polynomial.aeval f) p) 0\n⊢ f.IsSemisimple","decl":"theorem isSemisimple_of_squarefree_aeval_eq_zero {p : K[X]}\n    (hp : Squarefree p) (hpf : aeval f p = 0) : f.IsSemisimple := by\n  rw [← RingHom.mem_ker, ← AEval.annihilator_eq_ker_aeval (M := M), mem_annihilator,\n      ← IsTorsionBy, ← isTorsionBySet_singleton_iff, isTorsionBySet_iff_is_torsion_by_span] at hpf\n  let R := K[X] ⧸ Ideal.span {p}\n  have : IsReduced R :=\n    (Ideal.isRadical_iff_quotient_reduced _).mp (isRadical_iff_span_singleton.mp hp.isRadical)\n  have : FiniteDimensional K R := (AdjoinRoot.powerBasis hp.ne_zero).finite\n  have : IsArtinianRing R := .of_finite K R\n  have : IsSemisimpleRing R := IsArtinianRing.isSemisimpleRing_of_isReduced R\n  letI : Module R (AEval' f) := Module.IsTorsionBySet.module hpf\n  let e : AEval' f →ₛₗ[Ideal.Quotient.mk (Ideal.span {p})] AEval' f :=\n    { AddMonoidHom.id _ with map_smul' := fun _ _ ↦ rfl }\n  exact (e.isSemisimpleModule_iff_of_bijective bijective_id).mpr inferInstance\n\n"}
{"name":"Module.End.IsSemisimple.minpoly_squarefree","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Module K M\nf : Module.End K M\ninst✝ : FiniteDimensional K M\nhf : f.IsSemisimple\n⊢ Squarefree (minpoly K f)","decl":"/-- The minimal polynomial of a semisimple endomorphism is square free -/\ntheorem IsSemisimple.minpoly_squarefree : Squarefree (minpoly K f) :=\n  IsRadical.squarefree (minpoly.ne_zero <| Algebra.IsIntegral.isIntegral _) <| by\n    rw [isRadical_iff_span_singleton, span_minpoly_eq_annihilator]; exact hf.annihilator_isRadical\n\n"}
{"name":"Module.End.IsSemisimple.aeval","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Module K M\nf : Module.End K M\ninst✝ : FiniteDimensional K M\nhf : f.IsSemisimple\np : Polynomial K\n⊢ ((Polynomial.aeval f) p).IsSemisimple","decl":"protected theorem IsSemisimple.aeval (p : K[X]) : (aeval f p).IsSemisimple :=\n  let R := K[X] ⧸ Ideal.span {minpoly K f}\n  have : Module.Finite K R :=\n    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite\n  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|\n    span_minpoly_eq_annihilator K f ▸ hf.annihilator_isRadical\n  isSemisimple_of_squarefree_aeval_eq_zero ((minpoly.isRadical K _).squarefree <|\n    minpoly.ne_zero <| .of_finite K <| Ideal.Quotient.mkₐ K (.span {minpoly K f}) p) <| by\n      rw [← Ideal.Quotient.liftₐ_comp (.span {minpoly K f}) (aeval f)\n        fun a h ↦ by rwa [Ideal.span, ← minpoly.ker_aeval_eq_span_minpoly] at h, aeval_algHom,\n        AlgHom.comp_apply, AlgHom.comp_apply, ← aeval_algHom_apply, minpoly.aeval, map_zero]\n\n"}
{"name":"Module.End.IsSemisimple.of_mem_adjoin_singleton","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Module K M\nf : Module.End K M\ninst✝ : FiniteDimensional K M\nhf : f.IsSemisimple\na : Module.End K M\nha : Membership.mem (Algebra.adjoin K (Singleton.singleton f)) a\n⊢ a.IsSemisimple","decl":"theorem IsSemisimple.of_mem_adjoin_singleton {a : End K M}\n    (ha : a ∈ Algebra.adjoin K {f}) : a.IsSemisimple := by\n  rw [Algebra.adjoin_singleton_eq_range_aeval] at ha; obtain ⟨p, rfl⟩ := ha; exact .aeval hf _\n\n"}
{"name":"Module.End.IsSemisimple.pow","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝³ : AddCommGroup M\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : Module K M\nf : Module.End K M\ninst✝ : FiniteDimensional K M\nhf : f.IsSemisimple\nn : Nat\n⊢ (HPow.hPow f n).IsSemisimple","decl":"protected theorem IsSemisimple.pow (n : ℕ) : (f ^ n).IsSemisimple :=\n  .of_mem_adjoin_singleton hf (pow_mem (Algebra.self_mem_adjoin_singleton _ _) _)\n\n"}
{"name":"Module.End.IsSemisimple.of_mem_adjoin_pair","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Module K M\nf g : Module.End K M\ninst✝¹ : FiniteDimensional K M\ninst✝ : PerfectField K\ncomm : Commute f g\nhf : f.IsSemisimple\nhg : g.IsSemisimple\na : Module.End K M\nha : Membership.mem (Algebra.adjoin K (Insert.insert f (Singleton.singleton g))) a\n⊢ a.IsSemisimple","decl":"attribute [local simp] Submodule.Quotient.quot_mk_eq_mk in\ntheorem IsSemisimple.of_mem_adjoin_pair {a : End K M} (ha : a ∈ Algebra.adjoin K {f, g}) :\n    a.IsSemisimple := by\n  let R := K[X] ⧸ Ideal.span {minpoly K f}\n  let S := AdjoinRoot ((minpoly K g).map <| algebraMap K R)\n  have : Module.Finite K R :=\n    (AdjoinRoot.powerBasis' <| minpoly.monic <| Algebra.IsIntegral.isIntegral f).finite\n  have : Module.Finite R S :=\n    (AdjoinRoot.powerBasis' <| (minpoly.monic <| Algebra.IsIntegral.isIntegral g).map _).finite\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/4119\n  we either need to specify the `(S := R)` argument, or use `set_option maxSynthPendingDepth 2 in`.\n\n  In either case this step is too slow! -/\n  set_option maxSynthPendingDepth 2 in\n  have : IsScalarTower K R S := .of_algebraMap_eq fun _ ↦ rfl\n  have : Module.Finite K S := .trans R S\n  have : IsArtinianRing R := .of_finite K R\n  have : IsReduced R := (Ideal.isRadical_iff_quotient_reduced _).mp <|\n    span_minpoly_eq_annihilator K f ▸ hf.annihilator_isRadical\n  have : IsReduced S := by\n    simp_rw [S, AdjoinRoot, ← Ideal.isRadical_iff_quotient_reduced, ← isRadical_iff_span_singleton]\n    exact (PerfectField.separable_iff_squarefree.mpr hg.minpoly_squarefree).map.squarefree.isRadical\n  let φ : S →ₐ[K] End K M := Ideal.Quotient.liftₐ _ (eval₂AlgHom' (Ideal.Quotient.liftₐ _ (aeval f)\n    fun a ↦ ?_) g ?_) ((Ideal.span_singleton_le_iff_mem _).mpr ?_ : _ ≤ RingHom.ker _)\n  rotate_left 1\n  · rw [Ideal.span, ← minpoly.ker_aeval_eq_span_minpoly]; exact id\n  · rintro ⟨p⟩; exact p.induction_on (fun k ↦ by simp [R, Algebra.commute_algebraMap_left])\n      (fun p q hp hq ↦ by simpa [R] using hp.add_left hq)\n      fun n k ↦ by simpa [R, pow_succ, ← mul_assoc _ _ X] using (·.mul_left comm)\n  · simpa only [RingHom.mem_ker, eval₂AlgHom'_apply, eval₂_map, AlgHom.comp_algebraMap_of_tower]\n      using minpoly.aeval K g\n  have : Algebra.adjoin K {f, g} ≤ φ.range := Algebra.adjoin_le fun x ↦ by\n    rintro (hx | hx) <;> rw [hx]\n    · exact ⟨AdjoinRoot.of _ (AdjoinRoot.root _), (eval₂_C _ _).trans (aeval_X f)⟩\n    · exact ⟨AdjoinRoot.root _, eval₂_X _ _⟩\n  obtain ⟨p, rfl⟩ := (AlgHom.mem_range _).mp (this ha)\n  refine isSemisimple_of_squarefree_aeval_eq_zero\n    ((minpoly.isRadical K p).squarefree <| minpoly.ne_zero <| .of_finite K p) ?_\n  rw [aeval_algHom, φ.comp_apply, minpoly.aeval, map_zero]\n\n"}
{"name":"Module.End.IsSemisimple.add_of_commute","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Module K M\nf g : Module.End K M\ninst✝¹ : FiniteDimensional K M\ninst✝ : PerfectField K\ncomm : Commute f g\nhf : f.IsSemisimple\nhg : g.IsSemisimple\n⊢ (HAdd.hAdd f g).IsSemisimple","decl":"theorem IsSemisimple.add_of_commute : (f + g).IsSemisimple := .of_mem_adjoin_pair\n  comm hf hg <| add_mem (Algebra.subset_adjoin <| .inl rfl) (Algebra.subset_adjoin <| .inr rfl)\n\n"}
{"name":"Module.End.IsSemisimple.sub_of_commute","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Module K M\nf g : Module.End K M\ninst✝¹ : FiniteDimensional K M\ninst✝ : PerfectField K\ncomm : Commute f g\nhf : f.IsSemisimple\nhg : g.IsSemisimple\n⊢ (HSub.hSub f g).IsSemisimple","decl":"theorem IsSemisimple.sub_of_commute : (f - g).IsSemisimple := .of_mem_adjoin_pair\n  comm hf hg <| sub_mem (Algebra.subset_adjoin <| .inl rfl) (Algebra.subset_adjoin <| .inr rfl)\n\n"}
{"name":"Module.End.IsSemisimple.mul_of_commute","module":"Mathlib.LinearAlgebra.Semisimple","initialProofState":"M : Type u_2\ninst✝⁴ : AddCommGroup M\nK : Type u_3\ninst✝³ : Field K\ninst✝² : Module K M\nf g : Module.End K M\ninst✝¹ : FiniteDimensional K M\ninst✝ : PerfectField K\ncomm : Commute f g\nhf : f.IsSemisimple\nhg : g.IsSemisimple\n⊢ (HMul.hMul f g).IsSemisimple","decl":"theorem IsSemisimple.mul_of_commute : (f * g).IsSemisimple := .of_mem_adjoin_pair\n  comm hf hg <| mul_mem (Algebra.subset_adjoin <| .inl rfl) (Algebra.subset_adjoin <| .inr rfl)\n\n"}
