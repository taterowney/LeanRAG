{"name":"id_tensor_π_preserves_coequalizer_inv_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\nW X Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y) W\nwh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z g) h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorLeft Z) f g).inv (CategoryTheory.Limits.coequalizer.desc h wh))) h","decl":"theorem id_tensor_π_preserves_coequalizer_inv_desc {W X Y Z : C} (f g : X ⟶ Y) (h : Z ⊗ Y ⟶ W)\n    (wh : (Z ◁ f) ≫ h = (Z ◁ g) ≫ h) :\n    (Z ◁ coequalizer.π f g) ≫\n        (PreservesCoequalizer.iso (tensorLeft Z) f g).inv ≫ coequalizer.desc h wh =\n      h :=\n  map_π_preserves_coequalizer_inv_desc (tensorLeft Z) f g h wh\n\n"}
{"name":"id_tensor_π_preserves_coequalizer_inv_colimMap_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\nX Y Z X' Y' Z' : C\nf g : Quiver.Hom X Y\nf' g' : Quiver.Hom X' Y'\np : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z X) X'\nq : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z g) q) (CategoryTheory.CategoryStruct.comp p g')\nh : Quiver.Hom Y' Z'\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h) (CategoryTheory.CategoryStruct.comp g' h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.coequalizer.π f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorLeft Z) f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z g) f' g' p q wf wg)) (CategoryTheory.Limits.coequalizer.desc h wh)))) (CategoryTheory.CategoryStruct.comp q h)","decl":"theorem id_tensor_π_preserves_coequalizer_inv_colimMap_desc {X Y Z X' Y' Z' : C} (f g : X ⟶ Y)\n    (f' g' : X' ⟶ Y') (p : Z ⊗ X ⟶ X') (q : Z ⊗ Y ⟶ Y') (wf : (Z ◁ f) ≫ q = p ≫ f')\n    (wg : (Z ◁ g) ≫ q = p ≫ g') (h : Y' ⟶ Z') (wh : f' ≫ h = g' ≫ h) :\n    (Z ◁ coequalizer.π f g) ≫\n        (PreservesCoequalizer.iso (tensorLeft Z) f g).inv ≫\n          colimMap (parallelPairHom (Z ◁ f) (Z ◁ g) f' g' p q wf wg) ≫ coequalizer.desc h wh =\n      q ≫ h :=\n  map_π_preserves_coequalizer_inv_colimMap_desc (tensorLeft Z) f g f' g' p q wf wg h wh\n\n"}
{"name":"π_tensor_id_preserves_coequalizer_inv_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z) W\nwh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z) h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.coequalizer.π f g) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorRight Z) f g).inv (CategoryTheory.Limits.coequalizer.desc h wh))) h","decl":"theorem π_tensor_id_preserves_coequalizer_inv_desc {W X Y Z : C} (f g : X ⟶ Y) (h : Y ⊗ Z ⟶ W)\n    (wh : (f ▷ Z) ≫ h = (g ▷ Z) ≫ h) :\n    (coequalizer.π f g ▷ Z) ≫\n        (PreservesCoequalizer.iso (tensorRight Z) f g).inv ≫ coequalizer.desc h wh =\n      h :=\n  map_π_preserves_coequalizer_inv_desc (tensorRight Z) f g h wh\n\n"}
{"name":"π_tensor_id_preserves_coequalizer_inv_colimMap_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z X' Y' Z' : C\nf g : Quiver.Hom X Y\nf' g' : Quiver.Hom X' Y'\np : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z) X'\nq : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z) q) (CategoryTheory.CategoryStruct.comp p g')\nh : Quiver.Hom Y' Z'\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h) (CategoryTheory.CategoryStruct.comp g' h)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.coequalizer.π f g) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorRight Z) f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z) f' g' p q wf wg)) (CategoryTheory.Limits.coequalizer.desc h wh)))) (CategoryTheory.CategoryStruct.comp q h)","decl":"theorem π_tensor_id_preserves_coequalizer_inv_colimMap_desc {X Y Z X' Y' Z' : C} (f g : X ⟶ Y)\n    (f' g' : X' ⟶ Y') (p : X ⊗ Z ⟶ X') (q : Y ⊗ Z ⟶ Y') (wf : (f ▷ Z) ≫ q = p ≫ f')\n    (wg : (g ▷ Z) ≫ q = p ≫ g') (h : Y' ⟶ Z') (wh : f' ≫ h = g' ≫ h) :\n    (coequalizer.π f g ▷ Z) ≫\n        (PreservesCoequalizer.iso (tensorRight Z) f g).inv ≫\n          colimMap (parallelPairHom (f ▷ Z) (g ▷ Z) f' g' p q wf wg) ≫ coequalizer.desc h wh =\n      q ≫ h :=\n  map_π_preserves_coequalizer_inv_colimMap_desc (tensorRight Z) f g f' g' p q wf wg h wh\n\n"}
{"name":"Bimod.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nX✝ : C\nactLeft✝ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X✝) X✝\none_actLeft✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X✝) actLeft✝) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X✝).hom) _auto✝\nleft_assoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X✝) actLeft✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft✝) actLeft✝))) _auto✝\nactRight✝ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X✝ B.X) X✝\nactRight_one✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X✝ B.one) actRight✝) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X✝).hom) _auto✝\nright_assoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X✝ B.mul) actRight✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X✝ B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight✝ B.X) actRight✝))) _auto✝\nmiddle_assoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft✝ B.X) actRight✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X✝ B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight✝) actLeft✝))) _auto✝\nX : C\nactLeft : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_actLeft : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto✝\nleft_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft) actLeft))) _auto✝\nactRight : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X B.X) X\nactRight_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.one) actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _auto✝\nright_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.mul) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight B.X) actRight))) _auto✝\nmiddle_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft B.X) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight) actLeft))) _auto✝\n⊢ Eq (Eq { X := X✝, actLeft := actLeft✝, one_actLeft := one_actLeft✝, left_assoc := left_assoc✝, actRight := actRight✝, actRight_one := actRight_one✝, right_assoc := right_assoc✝, middle_assoc := middle_assoc✝ } { X := X, actLeft := actLeft, one_actLeft := one_actLeft, left_assoc := left_assoc, actRight := actRight, actRight_one := actRight_one, right_assoc := right_assoc, middle_assoc := middle_assoc }) (And (Eq X✝ X) (And (HEq actLeft✝ actLeft) (HEq actRight✝ actRight)))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nX✝ : C\nactLeft✝ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X✝) X✝\none_actLeft✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X✝) actLeft✝) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X✝).hom) _auto✝\nleft_assoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X✝) actLeft✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X✝).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft✝) actLeft✝))) _auto✝\nactRight✝ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X✝ B.X) X✝\nactRight_one✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X✝ B.one) actRight✝) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X✝).hom) _auto✝\nright_assoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X✝ B.mul) actRight✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X✝ B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight✝ B.X) actRight✝))) _auto✝\nmiddle_assoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft✝ B.X) actRight✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X✝ B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight✝) actLeft✝))) _auto✝\nX : C\nactLeft : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_actLeft : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto✝\nleft_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft) actLeft))) _auto✝\nactRight : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X B.X) X\nactRight_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.one) actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _auto✝\nright_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.mul) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight B.X) actRight))) _auto✝\nmiddle_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft B.X) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight) actLeft))) _auto✝\nx✝ : Eq { X := X✝, actLeft := actLeft✝, one_actLeft := one_actLeft✝, left_assoc := left_assoc✝, actRight := actRight✝, actRight_one := actRight_one✝, right_assoc := right_assoc✝, middle_assoc := middle_assoc✝ } { X := X, actLeft := actLeft, one_actLeft := one_actLeft, left_assoc := left_assoc, actRight := actRight, actRight_one := actRight_one, right_assoc := right_assoc, middle_assoc := middle_assoc }\n⊢ And (Eq X✝ X) (And (HEq actLeft✝ actLeft) (HEq actRight✝ actRight))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) self.actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actLeft) self.actLeft))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\ninst✝ : SizeOf C\nX : C\nactLeft : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_actLeft : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _auto✝\nleft_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft) actLeft))) _auto✝\nactRight : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X B.X) X\nactRight_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.one) actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _auto✝\nright_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.mul) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight B.X) actRight))) _auto✝\nmiddle_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft B.X) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight) actLeft))) _auto✝\n⊢ Eq (SizeOf.sizeOf { X := X, actLeft := actLeft, one_actLeft := one_actLeft, left_assoc := left_assoc, actRight := actRight, actRight_one := actRight_one, right_assoc := right_assoc, middle_assoc := middle_assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf actLeft)) (SizeOf.sizeOf one_actLeft)) (SizeOf.sizeOf left_assoc)) (SizeOf.sizeOf actRight)) (SizeOf.sizeOf actRight_one)) (SizeOf.sizeOf right_assoc)) (SizeOf.sizeOf middle_assoc))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.actRight_one","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.one) self.actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).hom","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.one_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) self.actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.mul) self.actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actRight B.X) self.actRight))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.middle_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actLeft B.X) self.actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X self.X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actRight) self.actLeft))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X ⊗ X ⟶ X\n  one_actLeft : (A.one ▷ X) ≫ actLeft = (λ_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul ▷ X) ≫ actLeft = (α_ A.X A.X X).hom ≫ (A.X ◁ actLeft) ≫ actLeft := by aesop_cat\n  actRight : X ⊗ B.X ⟶ X\n  actRight_one : (X ◁ B.one) ≫ actRight = (ρ_ X).hom := by aesop_cat\n  right_assoc :\n    (X ◁ B.mul) ≫ actRight = (α_ X B.X B.X).inv ≫ (actRight ▷ B.X) ≫ actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft ▷ B.X) ≫ actRight = (α_ A.X X B.X).hom ≫ (A.X ◁ actRight) ≫ actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.one_actLeft_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) (CategoryTheory.CategoryStruct.comp self.actLeft h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom h)","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.actRight_one_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.one) (CategoryTheory.CategoryStruct.comp self.actRight h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).hom h)","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.right_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.mul) (CategoryTheory.CategoryStruct.comp self.actRight h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actRight B.X) (CategoryTheory.CategoryStruct.comp self.actRight h)))","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.middle_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actLeft B.X) (CategoryTheory.CategoryStruct.comp self.actRight h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X self.X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actRight) (CategoryTheory.CategoryStruct.comp self.actLeft h)))","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.left_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) (CategoryTheory.CategoryStruct.comp self.actLeft h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actLeft) (CategoryTheory.CategoryStruct.comp self.actLeft h)))","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nx y : M.Hom N\nhom : Eq x.hom y.hom\n⊢ Eq x y","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nhom✝ : Quiver.Hom M.X N.X\nleft_act_hom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom✝) N.actLeft)) _auto✝\nright_act_hom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom✝ B.X) N.actRight)) _auto✝\nhom : Quiver.Hom M.X N.X\nleft_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.actLeft)) _auto✝\nright_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom B.X) N.actRight)) _auto✝\n⊢ Eq (Eq { hom := hom✝, left_act_hom := left_act_hom✝, right_act_hom := right_act_hom✝ } { hom := hom, left_act_hom := left_act_hom, right_act_hom := right_act_hom }) (Eq hom✝ hom)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\ninst✝ : SizeOf C\nhom : Quiver.Hom M.X N.X\nleft_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.actLeft)) _auto✝\nright_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom B.X) N.actRight)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, left_act_hom := left_act_hom, right_act_hom := right_act_hom }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf left_act_hom)) (SizeOf.sizeOf right_act_hom))","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nhom✝ : Quiver.Hom M.X N.X\nleft_act_hom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom✝) N.actLeft)) _auto✝\nright_act_hom✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom✝) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom✝ B.X) N.actRight)) _auto✝\nhom : Quiver.Hom M.X N.X\nleft_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.actLeft)) _auto✝\nright_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom B.X) N.actRight)) _auto✝\nx✝ : Eq { hom := hom✝, left_act_hom := left_act_hom✝, right_act_hom := right_act_hom✝ } { hom := hom, left_act_hom := left_act_hom, right_act_hom := right_act_hom }\n⊢ Eq hom✝ hom","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.right_act_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.actRight self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.hom B.X) N.actRight)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nx y : M.Hom N\n⊢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.left_act_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.actLeft self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) N.actLeft)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X ⟶ N.X\n  left_act_hom : M.actLeft ≫ hom = (A.X ◁ hom) ≫ N.actLeft := by aesop_cat\n  right_act_hom : M.actRight ≫ hom = (hom ▷ B.X) ≫ N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.right_act_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.actRight (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.hom B.X) (CategoryTheory.CategoryStruct.comp N.actRight h))","decl":"attribute [reassoc (attr := simp)] Hom.left_act_hom Hom.right_act_hom\n\n"}
{"name":"Bimod.Hom.left_act_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp M.actLeft (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) (CategoryTheory.CategoryStruct.comp N.actLeft h))","decl":"attribute [reassoc (attr := simp)] Hom.left_act_hom Hom.right_act_hom\n\n"}
{"name":"Bimod.id'_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM : Bimod A B\n⊢ Eq M.id'.hom (CategoryTheory.CategoryStruct.id M.X)","decl":"/-- The identity morphism on a bimodule object. -/\n@[simps]\ndef id' (M : Bimod A B) : Hom M M where hom := 𝟙 M.X\n\n"}
{"name":"Bimod.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N O : Bimod A B\nf : M.Hom N\ng : N.Hom O\n⊢ Eq (Bimod.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- Composition of bimodule object morphisms. -/\n@[simps]\ndef comp {M N O : Bimod A B} (f : Hom M N) (g : Hom N O) : Hom M O where hom := f.hom ≫ g.hom\n\n"}
{"name":"Bimod.hom_ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nf g : Quiver.Hom M N\n⊢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\nlemma hom_ext {M N : Bimod A B} (f g : M ⟶ N) (h : f.hom = g.hom) : f = g :=\n  Hom.ext h\n\n"}
{"name":"Bimod.hom_ext","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nf g : Quiver.Hom M N\nh : Eq f.hom g.hom\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {M N : Bimod A B} (f g : M ⟶ N) (h : f.hom = g.hom) : f = g :=\n  Hom.ext h\n\n"}
{"name":"Bimod.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM : Bimod A B\n⊢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp]\ntheorem id_hom' (M : Bimod A B) : (𝟙 M : Hom M M).hom = 𝟙 M.X :=\n  rfl\n\n"}
{"name":"Bimod.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N K : Bimod A B\nf : Quiver.Hom M N\ng : Quiver.Hom N K\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Bimod A B} (f : M ⟶ N) (g : N ⟶ K) :\n    (f ≫ g : Hom M K).hom = f.hom ≫ g.hom :=\n  rfl\n\n"}
{"name":"Bimod.isoOfIso_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : Mon_ C\nP Q : Bimod X Y\nf : CategoryTheory.Iso P.X Q.X\nf_left_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actLeft f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X f.hom) Q.actLeft)\nf_right_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actRight f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Y.X) Q.actRight)\n⊢ Eq (Bimod.isoOfIso f f_left_act_hom f_right_act_hom).inv.hom f.inv","decl":"/-- Construct an isomorphism of bimodules by giving an isomorphism between the underlying objects\nand checking compatibility with left and right actions only in the forward direction.\n-/\n@[simps]\ndef isoOfIso {X Y : Mon_ C} {P Q : Bimod X Y} (f : P.X ≅ Q.X)\n    (f_left_act_hom : P.actLeft ≫ f.hom = (X.X ◁ f.hom) ≫ Q.actLeft)\n    (f_right_act_hom : P.actRight ≫ f.hom = (f.hom ▷ Y.X) ≫ Q.actRight) : P ≅ Q where\n  hom :=\n    { hom := f.hom }\n  inv :=\n    { hom := f.inv\n      left_act_hom := by\n        rw [← cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_left_act_hom, ← Category.assoc, ← MonoidalCategory.whiskerLeft_comp, Iso.inv_hom_id,\n          MonoidalCategory.whiskerLeft_id, Category.id_comp]\n      right_act_hom := by\n        rw [← cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_right_act_hom, ← Category.assoc, ← comp_whiskerRight, Iso.inv_hom_id,\n          MonoidalCategory.id_whiskerRight, Category.id_comp] }\n  hom_inv_id := by ext; dsimp; rw [Iso.hom_inv_id]\n  inv_hom_id := by ext; dsimp; rw [Iso.inv_hom_id]\n\n"}
{"name":"Bimod.isoOfIso_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nX Y : Mon_ C\nP Q : Bimod X Y\nf : CategoryTheory.Iso P.X Q.X\nf_left_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actLeft f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X f.hom) Q.actLeft)\nf_right_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actRight f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Y.X) Q.actRight)\n⊢ Eq (Bimod.isoOfIso f f_left_act_hom f_right_act_hom).hom.hom f.hom","decl":"/-- Construct an isomorphism of bimodules by giving an isomorphism between the underlying objects\nand checking compatibility with left and right actions only in the forward direction.\n-/\n@[simps]\ndef isoOfIso {X Y : Mon_ C} {P Q : Bimod X Y} (f : P.X ≅ Q.X)\n    (f_left_act_hom : P.actLeft ≫ f.hom = (X.X ◁ f.hom) ≫ Q.actLeft)\n    (f_right_act_hom : P.actRight ≫ f.hom = (f.hom ▷ Y.X) ≫ Q.actRight) : P ≅ Q where\n  hom :=\n    { hom := f.hom }\n  inv :=\n    { hom := f.inv\n      left_act_hom := by\n        rw [← cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_left_act_hom, ← Category.assoc, ← MonoidalCategory.whiskerLeft_comp, Iso.inv_hom_id,\n          MonoidalCategory.whiskerLeft_id, Category.id_comp]\n      right_act_hom := by\n        rw [← cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_right_act_hom, ← Category.assoc, ← comp_whiskerRight, Iso.inv_hom_id,\n          MonoidalCategory.id_whiskerRight, Category.id_comp] }\n  hom_inv_id := by ext; dsimp; rw [Iso.hom_inv_id]\n  inv_hom_id := by ext; dsimp; rw [Iso.inv_hom_id]\n\n"}
{"name":"Bimod.regular_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n⊢ Eq (Bimod.regular A).actLeft A.mul","decl":"/-- A monoid object as a bimodule over itself. -/\n@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul\n\n"}
{"name":"Bimod.regular_X","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n⊢ Eq (Bimod.regular A).X A.X","decl":"/-- A monoid object as a bimodule over itself. -/\n@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul\n\n"}
{"name":"Bimod.regular_actRight","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\n⊢ Eq (Bimod.regular A).actRight A.mul","decl":"/-- A monoid object as a bimodule over itself. -/\n@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul\n\n"}
{"name":"Bimod.TensorBimod.whiskerLeft_π_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (CategoryTheory.Limits.coequalizer.π (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft)))) (Bimod.TensorBimod.actLeft P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator R.X P.X Q.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actLeft Q.X) (CategoryTheory.Limits.coequalizer.π (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft)))))","decl":"theorem whiskerLeft_π_actLeft :\n    (R.X ◁ coequalizer.π _ _) ≫ actLeft P Q =\n      (α_ _ _ _).inv ≫ (P.actLeft ▷ Q.X) ≫ coequalizer.π _ _ := by\n  erw [map_π_preserves_coequalizer_inv_colimMap (tensorLeft _)]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.TensorBimod.one_act_left'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight R.one (Bimod.TensorBimod.X P Q)) (Bimod.TensorBimod.actLeft P Q)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (Bimod.TensorBimod.X P Q)).hom","decl":"theorem one_act_left' : (R.one ▷ _) ≫ actLeft P Q = (λ_ _).hom := by\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  dsimp [X]\n  -- Porting note: had to replace `rw` by `erw`\n  slice_lhs 1 2 => erw [whisker_exchange]\n  slice_lhs 2 3 => rw [whiskerLeft_π_actLeft]\n  slice_lhs 1 2 => rw [associator_inv_naturality_left]\n  slice_lhs 2 3 => rw [← comp_whiskerRight, one_actLeft]\n  slice_rhs 1 2 => rw [leftUnitor_naturality]\n  monoidal\n\n"}
{"name":"Bimod.TensorBimod.left_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight R.mul (Bimod.TensorBimod.X P Q)) (Bimod.TensorBimod.actLeft P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator R.X R.X (Bimod.TensorBimod.X P Q)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.TensorBimod.actLeft P Q)) (Bimod.TensorBimod.actLeft P Q)))","decl":"theorem left_assoc' :\n    (R.mul ▷ _) ≫ actLeft P Q = (α_ R.X R.X _).hom ≫ (R.X ◁ actLeft P Q) ≫ actLeft P Q := by\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  dsimp [X]\n  slice_lhs 1 2 => rw [whisker_exchange]\n  slice_lhs 2 3 => rw [whiskerLeft_π_actLeft]\n  slice_lhs 1 2 => rw [associator_inv_naturality_left]\n  slice_lhs 2 3 => rw [← comp_whiskerRight, left_assoc, comp_whiskerRight, comp_whiskerRight]\n  slice_rhs 1 2 => rw [associator_naturality_right]\n  slice_rhs 2 3 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, whiskerLeft_π_actLeft,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 4 5 => rw [whiskerLeft_π_actLeft]\n  slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n  monoidal\n\n"}
{"name":"Bimod.TensorBimod.π_tensor_id_actRight","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.coequalizer.π (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft))) T.X) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X Q.X T.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actRight) (CategoryTheory.Limits.coequalizer.π (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft)))))","decl":"theorem π_tensor_id_actRight :\n    (coequalizer.π _ _ ▷ T.X) ≫ actRight P Q =\n      (α_ _ _ _).hom ≫ (P.X ◁ Q.actRight) ≫ coequalizer.π _ _ := by\n  erw [map_π_preserves_coequalizer_inv_colimMap (tensorRight _)]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.TensorBimod.actRight_one'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (Bimod.TensorBimod.X P Q) T.one) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (Bimod.TensorBimod.X P Q)).hom","decl":"theorem actRight_one' : (_ ◁ T.one) ≫ actRight P Q = (ρ_ _).hom := by\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp [X]\n  -- Porting note: had to replace `rw` by `erw`\n  slice_lhs 1 2 =>erw [← whisker_exchange]\n  slice_lhs 2 3 => rw [π_tensor_id_actRight]\n  slice_lhs 1 2 => rw [associator_naturality_right]\n  slice_lhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, actRight_one]\n  simp\n\n"}
{"name":"Bimod.TensorBimod.right_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\ninst✝² : CategoryTheory.MonoidalCategory C\ninst✝¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (Bimod.TensorBimod.X P Q) T.mul) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (Bimod.TensorBimod.X P Q) T.X T.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.TensorBimod.actRight P Q) T.X) (Bimod.TensorBimod.actRight P Q)))","decl":"theorem right_assoc' :\n    (_ ◁ T.mul) ≫ actRight P Q =\n      (α_ _ T.X T.X).inv ≫ (actRight P Q ▷ T.X) ≫ actRight P Q := by\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp [X]\n  -- Porting note: had to replace some `rw` by `erw`\n  slice_lhs 1 2 => rw [← whisker_exchange]\n  slice_lhs 2 3 => rw [π_tensor_id_actRight]\n  slice_lhs 1 2 => rw [associator_naturality_right]\n  slice_lhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, right_assoc,\n    MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 1 2 => rw [associator_inv_naturality_left]\n  slice_rhs 2 3 => rw [← comp_whiskerRight, π_tensor_id_actRight, comp_whiskerRight,\n    comp_whiskerRight]\n  slice_rhs 4 5 => rw [π_tensor_id_actRight]\n  simp\n\n"}
{"name":"Bimod.TensorBimod.middle_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.TensorBimod.actLeft P Q) T.X) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator R.X (Bimod.TensorBimod.X P Q) T.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.TensorBimod.actRight P Q)) (Bimod.TensorBimod.actLeft P Q)))","decl":"theorem middle_assoc' :\n    (actLeft P Q ▷ T.X) ≫ actRight P Q =\n      (α_ R.X _ T.X).hom ≫ (R.X ◁ actRight P Q) ≫ actLeft P Q := by\n  refine (cancel_epi ((tensorLeft _ ⋙ tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp [X]\n  slice_lhs 1 2 => rw [← comp_whiskerRight, whiskerLeft_π_actLeft, comp_whiskerRight,\n    comp_whiskerRight]\n  slice_lhs 3 4 => rw [π_tensor_id_actRight]\n  slice_lhs 2 3 => rw [associator_naturality_left]\n  -- Porting note: had to replace `rw` by `erw`\n  slice_rhs 1 2 => rw [associator_naturality_middle]\n  slice_rhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, π_tensor_id_actRight,\n    MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 4 5 => rw [whiskerLeft_π_actLeft]\n  slice_rhs 3 4 => rw [associator_inv_naturality_right]\n  slice_rhs 4 5 => rw [whisker_exchange]\n  simp\n\n"}
{"name":"Bimod.tensorBimod_actRight","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\n⊢ Eq (M.tensorBimod N).actRight (Bimod.TensorBimod.actRight M N)","decl":"/-- Tensor product of two bimodule objects as a bimodule object. -/\n@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N\n\n"}
{"name":"Bimod.tensorBimod_X","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\n⊢ Eq (M.tensorBimod N).X (Bimod.TensorBimod.X M N)","decl":"/-- Tensor product of two bimodule objects as a bimodule object. -/\n@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N\n\n"}
{"name":"Bimod.tensorBimod_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\n⊢ Eq (M.tensorBimod N).actLeft (Bimod.TensorBimod.actLeft M N)","decl":"/-- Tensor product of two bimodule objects as a bimodule object. -/\n@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N\n\n"}
{"name":"Bimod.whiskerLeft_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN₁ N₂ : Bimod Y Z\nf : Quiver.Hom N₁ N₂\n⊢ Eq (M.whiskerLeft f).hom (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.actRight N₁.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X Y.X N₁.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X N₁.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.actRight N₂.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X Y.X N₂.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X N₂.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X Y.X) f.hom) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X f.hom) ⋯ ⋯))","decl":"/-- Left whiskering for morphisms of bimodule objects. -/\n@[simps]\nnoncomputable def whiskerLeft {X Y Z : Mon_ C} (M : Bimod X Y) {N₁ N₂ : Bimod Y Z} (f : N₁ ⟶ N₂) :\n    M.tensorBimod N₁ ⟶ M.tensorBimod N₂ where\n  hom :=\n    colimMap\n      (parallelPairHom _ _ _ _ (_ ◁ f.hom) (_ ◁ f.hom)\n        (by rw [whisker_exchange])\n        (by\n          simp only [Category.assoc, tensor_whiskerLeft, Iso.inv_hom_id_assoc,\n            Iso.cancel_iso_hom_left]\n          slice_lhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, Hom.left_act_hom]\n          simp))\n  left_act_hom := by\n    refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.whiskerLeft_π_actLeft]\n    slice_lhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n    slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, ι_colimMap, parallelPairHom_app_one,\n      MonoidalCategory.whiskerLeft_comp]\n    slice_rhs 2 3 => rw [TensorBimod.whiskerLeft_π_actLeft]\n    slice_rhs 1 2 => rw [associator_inv_naturality_right]\n    slice_rhs 2 3 => rw [whisker_exchange]\n    simp\n  right_act_hom := by\n    refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.π_tensor_id_actRight]\n    slice_lhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, Hom.right_act_hom]\n    slice_rhs 1 2 =>\n      rw [← comp_whiskerRight, ι_colimMap, parallelPairHom_app_one, comp_whiskerRight]\n    slice_rhs 2 3 => rw [TensorBimod.π_tensor_id_actRight]\n    simp\n\n"}
{"name":"Bimod.whiskerRight_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM₁ M₂ : Bimod X Y\nf : Quiver.Hom M₁ M₂\nN : Bimod Y Z\n⊢ Eq (Bimod.whiskerRight f N).hom (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M₁.actRight N.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M₁.X Y.X N.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M₁.X N.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight M₂.actRight N.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M₂.X Y.X N.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M₂.X N.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Y.X) N.X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom N.X) ⋯ ⋯))","decl":"/-- Right whiskering for morphisms of bimodule objects. -/\n@[simps]\nnoncomputable def whiskerRight {X Y Z : Mon_ C} {M₁ M₂ : Bimod X Y} (f : M₁ ⟶ M₂) (N : Bimod Y Z) :\n    M₁.tensorBimod N ⟶ M₂.tensorBimod N where\n  hom :=\n    colimMap\n      (parallelPairHom _ _ _ _ (f.hom ▷ _ ▷ _) (f.hom ▷ _)\n        (by rw [← comp_whiskerRight, Hom.right_act_hom, comp_whiskerRight])\n        (by\n          slice_lhs 2 3 => rw [whisker_exchange]\n          simp))\n  left_act_hom := by\n    refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.whiskerLeft_π_actLeft]\n    slice_lhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [← comp_whiskerRight, Hom.left_act_hom]\n    slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, ι_colimMap, parallelPairHom_app_one,\n      MonoidalCategory.whiskerLeft_comp]\n    slice_rhs 2 3 => rw [TensorBimod.whiskerLeft_π_actLeft]\n    slice_rhs 1 2 => rw [associator_inv_naturality_middle]\n    simp\n  right_act_hom := by\n    refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.π_tensor_id_actRight]\n    slice_lhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [whisker_exchange]\n    slice_rhs 1 2 => rw [← comp_whiskerRight, ι_colimMap, parallelPairHom_app_one,\n      comp_whiskerRight]\n    slice_rhs 2 3 => rw [TensorBimod.π_tensor_id_actRight]\n    simp\n\n"}
{"name":"Bimod.AssociatorBimod.hom_left_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((P.tensorBimod Q).tensorBimod L).actLeft (Bimod.AssociatorBimod.hom P Q L)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.AssociatorBimod.hom P Q L)) (P.tensorBimod (Q.tensorBimod L)).actLeft)","decl":"theorem hom_left_act_hom' :\n    ((P.tensorBimod Q).tensorBimod L).actLeft ≫ hom P Q L =\n      (R.X ◁ hom P Q L) ≫ (P.tensorBimod (Q.tensorBimod L)).actLeft := by\n  dsimp; dsimp [hom, homAux]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorLeft_map]\n  slice_lhs 1 2 => rw [TensorBimod.whiskerLeft_π_actLeft]\n  slice_lhs 3 4 => rw [coequalizer.π_desc]\n  slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, coequalizer.π_desc,\n    MonoidalCategory.whiskerLeft_comp]\n  refine (cancel_epi ((tensorRight _ ⋙ tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  dsimp; dsimp [TensorBimod.X]\n  slice_lhs 1 2 => rw [associator_inv_naturality_middle]\n  slice_lhs 2 3 =>\n    rw [← comp_whiskerRight, TensorBimod.whiskerLeft_π_actLeft,\n      comp_whiskerRight, comp_whiskerRight]\n  slice_lhs 4 6 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [associator_naturality_left]\n  slice_rhs 1 3 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, ← MonoidalCategory.whiskerLeft_comp,\n      π_tensor_id_preserves_coequalizer_inv_desc, MonoidalCategory.whiskerLeft_comp,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 3 4 => erw [TensorBimod.whiskerLeft_π_actLeft P (Q.tensorBimod L)]\n  slice_rhs 2 3 => erw [associator_inv_naturality_right]\n  slice_rhs 3 4 => erw [whisker_exchange]\n  monoidal\n\n"}
{"name":"Bimod.AssociatorBimod.hom_right_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((P.tensorBimod Q).tensorBimod L).actRight (Bimod.AssociatorBimod.hom P Q L)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.AssociatorBimod.hom P Q L) U.X) (P.tensorBimod (Q.tensorBimod L)).actRight)","decl":"theorem hom_right_act_hom' :\n    ((P.tensorBimod Q).tensorBimod L).actRight ≫ hom P Q L =\n      (hom P Q L ▷ U.X) ≫ (P.tensorBimod (Q.tensorBimod L)).actRight := by\n  dsimp; dsimp [hom, homAux]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_lhs 1 2 => rw [TensorBimod.π_tensor_id_actRight]\n  slice_lhs 3 4 => rw [coequalizer.π_desc]\n  slice_rhs 1 2 => rw [← comp_whiskerRight, coequalizer.π_desc, comp_whiskerRight]\n  refine (cancel_epi ((tensorRight _ ⋙ tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp; dsimp [TensorBimod.X]\n  slice_lhs 1 2 => rw [associator_naturality_left]\n  slice_lhs 2 3 => rw [← whisker_exchange]\n  slice_lhs 3 5 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 2 3 => rw [associator_naturality_right]\n  slice_rhs 1 3 =>\n    rw [← comp_whiskerRight, ← comp_whiskerRight, π_tensor_id_preserves_coequalizer_inv_desc,\n      comp_whiskerRight, comp_whiskerRight]\n  slice_rhs 3 4 => erw [TensorBimod.π_tensor_id_actRight P (Q.tensorBimod L)]\n  slice_rhs 2 3 => erw [associator_naturality_middle]\n  dsimp\n  slice_rhs 3 4 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, TensorBimod.π_tensor_id_actRight,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  monoidal\n\n"}
{"name":"Bimod.AssociatorBimod.hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.AssociatorBimod.hom P Q L) (Bimod.AssociatorBimod.inv P Q L)) (CategoryTheory.CategoryStruct.id ((P.tensorBimod Q).tensorBimod L).X)","decl":"theorem hom_inv_id : hom P Q L ≫ inv P Q L = 𝟙 _ := by\n  dsimp [hom, homAux, inv, invAux]\n  apply coequalizer.hom_ext\n  slice_lhs 1 2 => rw [coequalizer.π_desc]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_lhs 1 3 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [coequalizer.π_desc]\n  slice_lhs 2 4 => rw [id_tensor_π_preserves_coequalizer_inv_desc]\n  slice_lhs 1 3 => rw [Iso.hom_inv_id_assoc]\n  dsimp only [TensorBimod.X]\n  slice_rhs 2 3 => rw [Category.comp_id]\n  rfl\n\n"}
{"name":"Bimod.AssociatorBimod.inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.AssociatorBimod.inv P Q L) (Bimod.AssociatorBimod.hom P Q L)) (CategoryTheory.CategoryStruct.id (P.tensorBimod (Q.tensorBimod L)).X)","decl":"theorem inv_hom_id : inv P Q L ≫ hom P Q L = 𝟙 _ := by\n  dsimp [hom, homAux, inv, invAux]\n  apply coequalizer.hom_ext\n  slice_lhs 1 2 => rw [coequalizer.π_desc]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorLeft_map]\n  slice_lhs 1 3 => rw [id_tensor_π_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [coequalizer.π_desc]\n  slice_lhs 2 4 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]\n  dsimp only [TensorBimod.X]\n  slice_rhs 2 3 => rw [Category.comp_id]\n  rfl\n\n"}
{"name":"Bimod.LeftUnitorBimod.hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.LeftUnitorBimod.hom P) (Bimod.LeftUnitorBimod.inv P)) (CategoryTheory.CategoryStruct.id (Bimod.TensorBimod.X (Bimod.regular R) P))","decl":"theorem hom_inv_id : hom P ≫ inv P = 𝟙 _ := by\n  dsimp only [hom, inv, TensorBimod.X]\n  ext; dsimp\n  slice_lhs 1 2 => rw [coequalizer.π_desc]\n  slice_lhs 1 2 => rw [leftUnitor_inv_naturality]\n  slice_lhs 2 3 => rw [whisker_exchange]\n  slice_lhs 3 3 => rw [← Iso.inv_hom_id_assoc (α_ R.X R.X P.X) (R.X ◁ P.actLeft)]\n  slice_lhs 4 6 => rw [← Category.assoc, ← coequalizer.condition]\n  slice_lhs 2 3 => rw [associator_inv_naturality_left]\n  slice_lhs 3 4 => rw [← comp_whiskerRight, Mon_.one_mul]\n  slice_rhs 1 2 => rw [Category.comp_id]\n  monoidal\n\n"}
{"name":"Bimod.LeftUnitorBimod.inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.LeftUnitorBimod.inv P) (Bimod.LeftUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.id P.X)","decl":"theorem inv_hom_id : inv P ≫ hom P = 𝟙 _ := by\n  dsimp [hom, inv]\n  slice_lhs 3 4 => rw [coequalizer.π_desc]\n  rw [one_actLeft, Iso.inv_hom_id]\n\n"}
{"name":"Bimod.LeftUnitorBimod.hom_left_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((Bimod.regular R).tensorBimod P).actLeft (Bimod.LeftUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.LeftUnitorBimod.hom P)) P.actLeft)","decl":"theorem hom_left_act_hom' :\n    ((regular R).tensorBimod P).actLeft ≫ hom P = (R.X ◁ hom P) ≫ P.actLeft := by\n  dsimp; dsimp [hom, TensorBimod.actLeft, regular]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [id_tensor_π_preserves_coequalizer_inv_colimMap_desc]\n  slice_lhs 2 3 => rw [left_assoc]\n  slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, coequalizer.π_desc]\n  rw [Iso.inv_hom_id_assoc]\n\n"}
{"name":"Bimod.LeftUnitorBimod.hom_right_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((Bimod.regular R).tensorBimod P).actRight (Bimod.LeftUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.LeftUnitorBimod.hom P) S.X) P.actRight)","decl":"theorem hom_right_act_hom' :\n    ((regular R).tensorBimod P).actRight ≫ hom P = (hom P ▷ S.X) ≫ P.actRight := by\n  dsimp; dsimp [hom, TensorBimod.actRight, regular]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [π_tensor_id_preserves_coequalizer_inv_colimMap_desc]\n  slice_rhs 1 2 => rw [← comp_whiskerRight, coequalizer.π_desc]\n  slice_rhs 1 2 => rw [middle_assoc]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.RightUnitorBimod.hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.RightUnitorBimod.hom P) (Bimod.RightUnitorBimod.inv P)) (CategoryTheory.CategoryStruct.id (Bimod.TensorBimod.X P (Bimod.regular S)))","decl":"theorem hom_inv_id : hom P ≫ inv P = 𝟙 _ := by\n  dsimp only [hom, inv, TensorBimod.X]\n  ext; dsimp\n  slice_lhs 1 2 => rw [coequalizer.π_desc]\n  slice_lhs 1 2 => rw [rightUnitor_inv_naturality]\n  slice_lhs 2 3 => rw [← whisker_exchange]\n  slice_lhs 3 4 => rw [coequalizer.condition]\n  slice_lhs 2 3 => rw [associator_naturality_right]\n  slice_lhs 3 4 => rw [← MonoidalCategory.whiskerLeft_comp, Mon_.mul_one]\n  slice_rhs 1 2 => rw [Category.comp_id]\n  monoidal\n\n"}
{"name":"Bimod.RightUnitorBimod.inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\ninst✝¹ : CategoryTheory.MonoidalCategory C\ninst✝ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.RightUnitorBimod.inv P) (Bimod.RightUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.id P.X)","decl":"theorem inv_hom_id : inv P ≫ hom P = 𝟙 _ := by\n  dsimp [hom, inv]\n  slice_lhs 3 4 => rw [coequalizer.π_desc]\n  rw [actRight_one, Iso.inv_hom_id]\n\n"}
{"name":"Bimod.RightUnitorBimod.hom_left_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.tensorBimod (Bimod.regular S)).actLeft (Bimod.RightUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.RightUnitorBimod.hom P)) P.actLeft)","decl":"theorem hom_left_act_hom' :\n    (P.tensorBimod (regular S)).actLeft ≫ hom P = (R.X ◁ hom P) ≫ P.actLeft := by\n  dsimp; dsimp [hom, TensorBimod.actLeft, regular]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [id_tensor_π_preserves_coequalizer_inv_colimMap_desc]\n  slice_lhs 2 3 => rw [middle_assoc]\n  slice_rhs 1 2 => rw [← MonoidalCategory.whiskerLeft_comp, coequalizer.π_desc]\n  rw [Iso.inv_hom_id_assoc]\n\n"}
{"name":"Bimod.RightUnitorBimod.hom_right_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (P.tensorBimod (Bimod.regular S)).actRight (Bimod.RightUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.RightUnitorBimod.hom P) S.X) P.actRight)","decl":"theorem hom_right_act_hom' :\n    (P.tensorBimod (regular S)).actRight ≫ hom P = (hom P ▷ S.X) ≫ P.actRight := by\n  dsimp; dsimp [hom, TensorBimod.actRight, regular]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [π_tensor_id_preserves_coequalizer_inv_colimMap_desc]\n  slice_lhs 2 3 => rw [right_assoc]\n  slice_rhs 1 2 => rw [← comp_whiskerRight, coequalizer.π_desc]\n  rw [Iso.hom_inv_id_assoc]\n\n"}
{"name":"Bimod.whiskerLeft_id_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\n⊢ Eq (M.whiskerLeft (CategoryTheory.CategoryStruct.id N)) (CategoryTheory.CategoryStruct.id (M.tensorBimod N))","decl":"theorem whiskerLeft_id_bimod {X Y Z : Mon_ C} {M : Bimod X Y} {N : Bimod Y Z} :\n    whiskerLeft M (𝟙 N) = 𝟙 (M.tensorBimod N) := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  dsimp only [tensorBimod_X, whiskerLeft_hom, id_hom']\n  simp only [MonoidalCategory.whiskerLeft_id, ι_colimMap, parallelPair_obj_one,\n    parallelPairHom_app_one, Category.id_comp]\n  erw [Category.comp_id]\n\n"}
{"name":"Bimod.id_whiskerRight_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\n⊢ Eq (Bimod.whiskerRight (CategoryTheory.CategoryStruct.id M) N) (CategoryTheory.CategoryStruct.id (M.tensorBimod N))","decl":"theorem id_whiskerRight_bimod {X Y Z : Mon_ C} {M : Bimod X Y} {N : Bimod Y Z} :\n    whiskerRight (𝟙 M) N = 𝟙 (M.tensorBimod N) := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  dsimp only [tensorBimod_X, whiskerRight_hom, id_hom']\n  simp only [MonoidalCategory.id_whiskerRight, ι_colimMap, parallelPair_obj_one,\n    parallelPairHom_app_one, Category.id_comp]\n  erw [Category.comp_id]\n\n"}
{"name":"Bimod.whiskerLeft_comp_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN P Q : Bimod Y Z\nf : Quiver.Hom N P\ng : Quiver.Hom P Q\n⊢ Eq (M.whiskerLeft (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (M.whiskerLeft f) (M.whiskerLeft g))","decl":"theorem whiskerLeft_comp_bimod {X Y Z : Mon_ C} (M : Bimod X Y) {N P Q : Bimod Y Z} (f : N ⟶ P)\n    (g : P ⟶ Q) : whiskerLeft M (f ≫ g) = whiskerLeft M f ≫ whiskerLeft M g := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  simp\n\n"}
{"name":"Bimod.id_whiskerLeft_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y : Mon_ C\nM N : Bimod X Y\nf : Quiver.Hom M N\n⊢ Eq ((Bimod.regular X).whiskerLeft f) (CategoryTheory.CategoryStruct.comp M.leftUnitorBimod.hom (CategoryTheory.CategoryStruct.comp f N.leftUnitorBimod.inv))","decl":"theorem id_whiskerLeft_bimod {X Y : Mon_ C} {M N : Bimod X Y} (f : M ⟶ N) :\n    whiskerLeft (regular X) f = (leftUnitorBimod M).hom ≫ f ≫ (leftUnitorBimod N).inv := by\n  dsimp [tensorHom, regular, leftUnitorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [LeftUnitorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [LeftUnitorBimod.inv]\n  slice_rhs 1 2 => rw [Hom.left_act_hom]\n  slice_rhs 2 3 => rw [leftUnitor_inv_naturality]\n  slice_rhs 3 4 => rw [whisker_exchange]\n  slice_rhs 4 4 => rw [← Iso.inv_hom_id_assoc (α_ X.X X.X N.X) (X.X ◁ N.actLeft)]\n  slice_rhs 5 7 => rw [← Category.assoc, ← coequalizer.condition]\n  slice_rhs 3 4 => rw [associator_inv_naturality_left]\n  slice_rhs 4 5 => rw [← comp_whiskerRight, Mon_.one_mul]\n  have : (λ_ (X.X ⊗ N.X)).inv ≫ (α_ (𝟙_ C) X.X N.X).inv ≫ ((λ_ X.X).hom ▷ N.X) = 𝟙 _ := by\n    monoidal\n  slice_rhs 2 4 => rw [this]\n  slice_rhs 1 2 => rw [Category.comp_id]\n\n"}
{"name":"Bimod.comp_whiskerLeft_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : Mon_ C\nM : Bimod W X\nN : Bimod X Y\nP P' : Bimod Y Z\nf : Quiver.Hom P P'\n⊢ Eq ((M.tensorBimod N).whiskerLeft f) (CategoryTheory.CategoryStruct.comp (M.associatorBimod N P).hom (CategoryTheory.CategoryStruct.comp (M.whiskerLeft (N.whiskerLeft f)) (M.associatorBimod N P').inv))","decl":"theorem comp_whiskerLeft_bimod {W X Y Z : Mon_ C} (M : Bimod W X) (N : Bimod X Y)\n    {P P' : Bimod Y Z} (f : P ⟶ P') :\n    whiskerLeft (M.tensorBimod N) f =\n      (associatorBimod M N P).hom ≫\n        whiskerLeft M (whiskerLeft N f) ≫ (associatorBimod M N P').inv := by\n  dsimp [tensorHom, tensorBimod, associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [TensorBimod.X, AssociatorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.homAux, AssociatorBimod.inv]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_rhs 1 3 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 3 4 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.invAux]\n  slice_rhs 2 2 => rw [MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 3 5 => rw [id_tensor_π_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_inv_naturality_right]\n  slice_rhs 1 3 => rw [Iso.hom_inv_id_assoc]\n  slice_lhs 1 2 => rw [← whisker_exchange]\n  rfl\n\n"}
{"name":"Bimod.comp_whiskerRight_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM N P : Bimod X Y\nf : Quiver.Hom M N\ng : Quiver.Hom N P\nQ : Bimod Y Z\n⊢ Eq (Bimod.whiskerRight (CategoryTheory.CategoryStruct.comp f g) Q) (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight f Q) (Bimod.whiskerRight g Q))","decl":"theorem comp_whiskerRight_bimod {X Y Z : Mon_ C} {M N P : Bimod X Y} (f : M ⟶ N) (g : N ⟶ P)\n    (Q : Bimod Y Z) : whiskerRight (f ≫ g) Q = whiskerRight f Q ≫ whiskerRight g Q := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  simp\n\n"}
{"name":"Bimod.whiskerRight_id_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y : Mon_ C\nM N : Bimod X Y\nf : Quiver.Hom M N\n⊢ Eq (Bimod.whiskerRight f (Bimod.regular Y)) (CategoryTheory.CategoryStruct.comp M.rightUnitorBimod.hom (CategoryTheory.CategoryStruct.comp f N.rightUnitorBimod.inv))","decl":"theorem whiskerRight_id_bimod {X Y : Mon_ C} {M N : Bimod X Y} (f : M ⟶ N) :\n    whiskerRight f (regular Y) = (rightUnitorBimod M).hom ≫ f ≫ (rightUnitorBimod N).inv := by\n  dsimp [tensorHom, regular, rightUnitorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [RightUnitorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [RightUnitorBimod.inv]\n  slice_rhs 1 2 => rw [Hom.right_act_hom]\n  slice_rhs 2 3 => rw [rightUnitor_inv_naturality]\n  slice_rhs 3 4 => rw [← whisker_exchange]\n  slice_rhs 4 5 => rw [coequalizer.condition]\n  slice_rhs 3 4 => rw [associator_naturality_right]\n  slice_rhs 4 5 => rw [← MonoidalCategory.whiskerLeft_comp, Mon_.mul_one]\n  simp\n\n"}
{"name":"Bimod.whiskerRight_comp_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : Mon_ C\nM M' : Bimod W X\nf : Quiver.Hom M M'\nN : Bimod X Y\nP : Bimod Y Z\n⊢ Eq (Bimod.whiskerRight f (N.tensorBimod P)) (CategoryTheory.CategoryStruct.comp (M.associatorBimod N P).inv (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight (Bimod.whiskerRight f N) P) (M'.associatorBimod N P).hom))","decl":"theorem whiskerRight_comp_bimod {W X Y Z : Mon_ C} {M M' : Bimod W X} (f : M ⟶ M') (N : Bimod X Y)\n    (P : Bimod Y Z) :\n    whiskerRight f (N.tensorBimod P) =\n      (associatorBimod M N P).inv ≫\n        whiskerRight (whiskerRight f N) P ≫ (associatorBimod M' N P).hom := by\n  dsimp [tensorHom, tensorBimod, associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [TensorBimod.X, AssociatorBimod.inv]\n  slice_rhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.invAux, AssociatorBimod.hom]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorLeft_map]\n  slice_rhs 1 3 => rw [id_tensor_π_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [← comp_whiskerRight, ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 3 4 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.homAux]\n  slice_rhs 2 2 => rw [comp_whiskerRight]\n  slice_rhs 3 5 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_naturality_left]\n  slice_rhs 1 3 => rw [Iso.inv_hom_id_assoc]\n  slice_lhs 1 2 => rw [whisker_exchange]\n  rfl\n\n"}
{"name":"Bimod.whisker_assoc_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : Mon_ C\nM : Bimod W X\nN N' : Bimod X Y\nf : Quiver.Hom N N'\nP : Bimod Y Z\n⊢ Eq (Bimod.whiskerRight (M.whiskerLeft f) P) (CategoryTheory.CategoryStruct.comp (M.associatorBimod N P).hom (CategoryTheory.CategoryStruct.comp (M.whiskerLeft (Bimod.whiskerRight f P)) (M.associatorBimod N' P).inv))","decl":"theorem whisker_assoc_bimod {W X Y Z : Mon_ C} (M : Bimod W X) {N N' : Bimod X Y} (f : N ⟶ N')\n    (P : Bimod Y Z) :\n    whiskerRight (whiskerLeft M f) P =\n      (associatorBimod M N P).hom ≫\n        whiskerLeft M (whiskerRight f P) ≫ (associatorBimod M N' P).inv := by\n  dsimp [tensorHom, tensorBimod, associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [AssociatorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.homAux]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_lhs 1 2 => rw [← comp_whiskerRight, ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 1 3 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, ι_colimMap, parallelPairHom_app_one]\n  dsimp [AssociatorBimod.inv]\n  slice_rhs 3 4 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.invAux]\n  slice_rhs 2 2 => rw [MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 3 5 => rw [id_tensor_π_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_inv_naturality_middle]\n  slice_rhs 1 3 => rw [Iso.hom_inv_id_assoc]\n  slice_lhs 1 1 => rw [comp_whiskerRight]\n\n"}
{"name":"Bimod.whisker_exchange_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM N : Bimod X Y\nP Q : Bimod Y Z\nf : Quiver.Hom M N\ng : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.CategoryStruct.comp (M.whiskerLeft g) (Bimod.whiskerRight f Q)) (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight f P) (N.whiskerLeft g))","decl":"theorem whisker_exchange_bimod {X Y Z : Mon_ C} {M N : Bimod X Y} {P Q : Bimod Y Z} (f : M ⟶ N)\n    (g : P ⟶ Q) : whiskerLeft M g ≫ whiskerRight f Q =\n      whiskerRight f P ≫ whiskerLeft N g := by\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_lhs 2 3 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_lhs 1 2 => rw [whisker_exchange]\n  slice_rhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [ι_colimMap, parallelPairHom_app_one]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.pentagon_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nV W X Y Z : Mon_ C\nM : Bimod V W\nN : Bimod W X\nP : Bimod X Y\nQ : Bimod Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight (M.associatorBimod N P).hom Q) (CategoryTheory.CategoryStruct.comp (M.associatorBimod (N.tensorBimod P) Q).hom (M.whiskerLeft (N.associatorBimod P Q).hom))) (CategoryTheory.CategoryStruct.comp ((M.tensorBimod N).associatorBimod P Q).hom (M.associatorBimod N (P.tensorBimod Q)).hom)","decl":"theorem pentagon_bimod {V W X Y Z : Mon_ C} (M : Bimod V W) (N : Bimod W X) (P : Bimod X Y)\n    (Q : Bimod Y Z) :\n    whiskerRight (associatorBimod M N P).hom Q ≫\n      (associatorBimod M (N.tensorBimod P) Q).hom ≫\n        whiskerLeft M (associatorBimod N P Q).hom =\n      (associatorBimod (M.tensorBimod N) P Q).hom ≫\n        (associatorBimod M N (P.tensorBimod Q)).hom := by\n  dsimp [associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  dsimp only [AssociatorBimod.hom]\n  slice_lhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_lhs 2 3 => rw [coequalizer.π_desc]\n  slice_rhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.homAux]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp\n  slice_lhs 1 2 => rw [← comp_whiskerRight, coequalizer.π_desc]\n  slice_rhs 1 3 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [coequalizer.π_desc]\n  refine (cancel_epi ((tensorRight _ ⋙ tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp\n  slice_lhs 1 2 =>\n    rw [← comp_whiskerRight, π_tensor_id_preserves_coequalizer_inv_desc, comp_whiskerRight,\n      comp_whiskerRight]\n  slice_lhs 3 5 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  dsimp only [TensorBimod.X]\n  slice_lhs 2 3 => rw [associator_naturality_middle]\n  slice_lhs 5 6 => rw [ι_colimMap, parallelPairHom_app_one]\n  slice_lhs 4 5 => rw [← MonoidalCategory.whiskerLeft_comp, coequalizer.π_desc]\n  slice_lhs 3 4 =>\n    rw [← MonoidalCategory.whiskerLeft_comp, π_tensor_id_preserves_coequalizer_inv_desc,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 1 2 => rw [associator_naturality_left]\n  slice_rhs 2 3 =>\n    rw [← whisker_exchange]\n  slice_rhs 3 5 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_naturality_right]\n  monoidal\n\n"}
{"name":"Bimod.triangle_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\ninst✝³ : CategoryTheory.MonoidalCategory C\ninst✝² : CategoryTheory.Limits.HasCoequalizers C\ninst✝¹ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninst✝ : ∀ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, v₁, v₁, u₁, u₁} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (M.associatorBimod (Bimod.regular Y) N).hom (M.whiskerLeft N.leftUnitorBimod.hom)) (Bimod.whiskerRight M.rightUnitorBimod.hom N)","decl":"theorem triangle_bimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) :\n    (associatorBimod M (regular Y) N).hom ≫ whiskerLeft M (leftUnitorBimod N).hom =\n      whiskerRight (rightUnitorBimod M).hom N := by\n  dsimp [associatorBimod, leftUnitorBimod, rightUnitorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  dsimp [AssociatorBimod.hom]\n  slice_lhs 1 2 => rw [coequalizer.π_desc]\n  dsimp [AssociatorBimod.homAux]\n  slice_rhs 1 2 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [RightUnitorBimod.hom]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.π _ _))).1 ?_\n  dsimp [regular]\n  slice_lhs 1 3 => rw [π_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [ι_colimMap, parallelPairHom_app_one]\n  dsimp [LeftUnitorBimod.hom]\n  slice_lhs 2 3 => rw [← MonoidalCategory.whiskerLeft_comp, coequalizer.π_desc]\n  slice_rhs 1 2 => rw [← comp_whiskerRight, coequalizer.π_desc]\n  slice_rhs 1 2 => rw [coequalizer.condition]\n  simp only [Category.assoc]\n\n"}
