{"name":"id_tensor_Ï€_preserves_coequalizer_inv_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\nW X Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y) W\nwh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z g) h)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.coequalizer.Ï€ f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorLeft Z) f g).inv (CategoryTheory.Limits.coequalizer.desc h wh))) h","decl":"theorem id_tensor_Ï€_preserves_coequalizer_inv_desc {W X Y Z : C} (f g : X âŸ¶ Y) (h : Z âŠ— Y âŸ¶ W)\n    (wh : (Z â— f) â‰« h = (Z â— g) â‰« h) :\n    (Z â— coequalizer.Ï€ f g) â‰«\n        (PreservesCoequalizer.iso (tensorLeft Z) f g).inv â‰« coequalizer.desc h wh =\n      h :=\n  map_Ï€_preserves_coequalizer_inv_desc (tensorLeft Z) f g h wh\n\n"}
{"name":"id_tensor_Ï€_preserves_coequalizer_inv_colimMap_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\nX Y Z X' Y' Z' : C\nf g : Quiver.Hom X Y\nf' g' : Quiver.Hom X' Y'\np : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z X) X'\nq : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Z Y) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z g) q) (CategoryTheory.CategoryStruct.comp p g')\nh : Quiver.Hom Y' Z'\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h) (CategoryTheory.CategoryStruct.comp g' h)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z (CategoryTheory.Limits.coequalizer.Ï€ f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorLeft Z) f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z f) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Z g) f' g' p q wf wg)) (CategoryTheory.Limits.coequalizer.desc h wh)))) (CategoryTheory.CategoryStruct.comp q h)","decl":"theorem id_tensor_Ï€_preserves_coequalizer_inv_colimMap_desc {X Y Z X' Y' Z' : C} (f g : X âŸ¶ Y)\n    (f' g' : X' âŸ¶ Y') (p : Z âŠ— X âŸ¶ X') (q : Z âŠ— Y âŸ¶ Y') (wf : (Z â— f) â‰« q = p â‰« f')\n    (wg : (Z â— g) â‰« q = p â‰« g') (h : Y' âŸ¶ Z') (wh : f' â‰« h = g' â‰« h) :\n    (Z â— coequalizer.Ï€ f g) â‰«\n        (PreservesCoequalizer.iso (tensorLeft Z) f g).inv â‰«\n          colimMap (parallelPairHom (Z â— f) (Z â— g) f' g' p q wf wg) â‰« coequalizer.desc h wh =\n      q â‰« h :=\n  map_Ï€_preserves_coequalizer_inv_colimMap_desc (tensorLeft Z) f g f' g' p q wf wg h wh\n\n"}
{"name":"Ï€_tensor_id_preserves_coequalizer_inv_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : C\nf g : Quiver.Hom X Y\nh : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z) W\nwh : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) h) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z) h)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.coequalizer.Ï€ f g) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorRight Z) f g).inv (CategoryTheory.Limits.coequalizer.desc h wh))) h","decl":"theorem Ï€_tensor_id_preserves_coequalizer_inv_desc {W X Y Z : C} (f g : X âŸ¶ Y) (h : Y âŠ— Z âŸ¶ W)\n    (wh : (f â–· Z) â‰« h = (g â–· Z) â‰« h) :\n    (coequalizer.Ï€ f g â–· Z) â‰«\n        (PreservesCoequalizer.iso (tensorRight Z) f g).inv â‰« coequalizer.desc h wh =\n      h :=\n  map_Ï€_preserves_coequalizer_inv_desc (tensorRight Z) f g h wh\n\n"}
{"name":"Ï€_tensor_id_preserves_coequalizer_inv_colimMap_desc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z X' Y' Z' : C\nf g : Quiver.Hom X Y\nf' g' : Quiver.Hom X' Y'\np : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X Z) X'\nq : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Y Z) Y'\nwf : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) q) (CategoryTheory.CategoryStruct.comp p f')\nwg : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z) q) (CategoryTheory.CategoryStruct.comp p g')\nh : Quiver.Hom Y' Z'\nwh : Eq (CategoryTheory.CategoryStruct.comp f' h) (CategoryTheory.CategoryStruct.comp g' h)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.coequalizer.Ï€ f g) Z) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.PreservesCoequalizer.iso (CategoryTheory.MonoidalCategory.tensorRight Z) f g).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight f Z) (CategoryTheory.MonoidalCategoryStruct.whiskerRight g Z) f' g' p q wf wg)) (CategoryTheory.Limits.coequalizer.desc h wh)))) (CategoryTheory.CategoryStruct.comp q h)","decl":"theorem Ï€_tensor_id_preserves_coequalizer_inv_colimMap_desc {X Y Z X' Y' Z' : C} (f g : X âŸ¶ Y)\n    (f' g' : X' âŸ¶ Y') (p : X âŠ— Z âŸ¶ X') (q : Y âŠ— Z âŸ¶ Y') (wf : (f â–· Z) â‰« q = p â‰« f')\n    (wg : (g â–· Z) â‰« q = p â‰« g') (h : Y' âŸ¶ Z') (wh : f' â‰« h = g' â‰« h) :\n    (coequalizer.Ï€ f g â–· Z) â‰«\n        (PreservesCoequalizer.iso (tensorRight Z) f g).inv â‰«\n          colimMap (parallelPairHom (f â–· Z) (g â–· Z) f' g' p q wf wg) â‰« coequalizer.desc h wh =\n      q â‰« h :=\n  map_Ï€_preserves_coequalizer_inv_colimMap_desc (tensorRight Z) f g f' g' p q wf wg h wh\n\n"}
{"name":"Bimod.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nXâœ : C\nactLeftâœ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X Xâœ) Xâœ\none_actLeftâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one Xâœ) actLeftâœ) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Xâœ).hom) _autoâœ\nleft_assocâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul Xâœ) actLeftâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X Xâœ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeftâœ) actLeftâœ))) _autoâœ\nactRightâœ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Xâœ B.X) Xâœ\nactRight_oneâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Xâœ B.one) actRightâœ) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Xâœ).hom) _autoâœ\nright_assocâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Xâœ B.mul) actRightâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Xâœ B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRightâœ B.X) actRightâœ))) _autoâœ\nmiddle_assocâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeftâœ B.X) actRightâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X Xâœ B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRightâœ) actLeftâœ))) _autoâœ\nX : C\nactLeft : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_actLeft : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _autoâœ\nleft_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft) actLeft))) _autoâœ\nactRight : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X B.X) X\nactRight_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.one) actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _autoâœ\nright_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.mul) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight B.X) actRight))) _autoâœ\nmiddle_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft B.X) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight) actLeft))) _autoâœ\nâŠ¢ Eq (Eq { X := Xâœ, actLeft := actLeftâœ, one_actLeft := one_actLeftâœ, left_assoc := left_assocâœ, actRight := actRightâœ, actRight_one := actRight_oneâœ, right_assoc := right_assocâœ, middle_assoc := middle_assocâœ } { X := X, actLeft := actLeft, one_actLeft := one_actLeft, left_assoc := left_assoc, actRight := actRight, actRight_one := actRight_one, right_assoc := right_assoc, middle_assoc := middle_assoc }) (And (Eq Xâœ X) (And (HEq actLeftâœ actLeft) (HEq actRightâœ actRight)))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nXâœ : C\nactLeftâœ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X Xâœ) Xâœ\none_actLeftâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one Xâœ) actLeftâœ) (CategoryTheory.MonoidalCategoryStruct.leftUnitor Xâœ).hom) _autoâœ\nleft_assocâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul Xâœ) actLeftâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X Xâœ).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeftâœ) actLeftâœ))) _autoâœ\nactRightâœ : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj Xâœ B.X) Xâœ\nactRight_oneâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Xâœ B.one) actRightâœ) (CategoryTheory.MonoidalCategoryStruct.rightUnitor Xâœ).hom) _autoâœ\nright_assocâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Xâœ B.mul) actRightâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Xâœ B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRightâœ B.X) actRightâœ))) _autoâœ\nmiddle_assocâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeftâœ B.X) actRightâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X Xâœ B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRightâœ) actLeftâœ))) _autoâœ\nX : C\nactLeft : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_actLeft : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _autoâœ\nleft_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft) actLeft))) _autoâœ\nactRight : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X B.X) X\nactRight_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.one) actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _autoâœ\nright_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.mul) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight B.X) actRight))) _autoâœ\nmiddle_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft B.X) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight) actLeft))) _autoâœ\nxâœ : Eq { X := Xâœ, actLeft := actLeftâœ, one_actLeft := one_actLeftâœ, left_assoc := left_assocâœ, actRight := actRightâœ, actRight_one := actRight_oneâœ, right_assoc := right_assocâœ, middle_assoc := middle_assocâœ } { X := X, actLeft := actLeft, one_actLeft := one_actLeft, left_assoc := left_assoc, actRight := actRight, actRight_one := actRight_one, right_assoc := right_assoc, middle_assoc := middle_assoc }\nâŠ¢ And (Eq Xâœ X) (And (HEq actLeftâœ actLeft) (HEq actRightâœ actRight))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.left_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) self.actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actLeft) self.actLeft))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\ninstâœ : SizeOf C\nX : C\nactLeft : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A.X X) X\none_actLeft : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one X) actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor X).hom) _autoâœ\nleft_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul X) actLeft) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actLeft) actLeft))) _autoâœ\nactRight : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj X B.X) X\nactRight_one : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.one) actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor X).hom) _autoâœ\nright_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X B.mul) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actRight B.X) actRight))) _autoâœ\nmiddle_assoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight actLeft B.X) actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X actRight) actLeft))) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { X := X, actLeft := actLeft, one_actLeft := one_actLeft, left_assoc := left_assoc, actRight := actRight, actRight_one := actRight_one, right_assoc := right_assoc, middle_assoc := middle_assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf X)) (SizeOf.sizeOf actLeft)) (SizeOf.sizeOf one_actLeft)) (SizeOf.sizeOf left_assoc)) (SizeOf.sizeOf actRight)) (SizeOf.sizeOf actRight_one)) (SizeOf.sizeOf right_assoc)) (SizeOf.sizeOf middle_assoc))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.actRight_one","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.one) self.actRight) (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).hom","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.one_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) self.actLeft) (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.right_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.mul) self.actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actRight B.X) self.actRight))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.middle_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actLeft B.X) self.actRight) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X self.X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actRight) self.actLeft))","decl":"/-- A bimodule object for a pair of monoid objects, all internal to some monoidal category. -/\nstructure Bimod (A B : Mon_ C) where\n  X : C\n  actLeft : A.X âŠ— X âŸ¶ X\n  one_actLeft : (A.one â–· X) â‰« actLeft = (Î»_ X).hom := by aesop_cat\n  left_assoc :\n    (A.mul â–· X) â‰« actLeft = (Î±_ A.X A.X X).hom â‰« (A.X â— actLeft) â‰« actLeft := by aesop_cat\n  actRight : X âŠ— B.X âŸ¶ X\n  actRight_one : (X â— B.one) â‰« actRight = (Ï_ X).hom := by aesop_cat\n  right_assoc :\n    (X â— B.mul) â‰« actRight = (Î±_ X B.X B.X).inv â‰« (actRight â–· B.X) â‰« actRight := by\n    aesop_cat\n  middle_assoc :\n    (actLeft â–· B.X) â‰« actRight = (Î±_ A.X X B.X).hom â‰« (A.X â— actRight) â‰« actLeft := by\n    aesop_cat\n\n"}
{"name":"Bimod.one_actLeft_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.one self.X) (CategoryTheory.CategoryStruct.comp self.actLeft h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.leftUnitor self.X).hom h)","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.actRight_one_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.one) (CategoryTheory.CategoryStruct.comp self.actRight h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.rightUnitor self.X).hom h)","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.right_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft self.X B.mul) (CategoryTheory.CategoryStruct.comp self.actRight h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator self.X B.X B.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actRight B.X) (CategoryTheory.CategoryStruct.comp self.actRight h)))","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.middle_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.actLeft B.X) (CategoryTheory.CategoryStruct.comp self.actRight h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X self.X B.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actRight) (CategoryTheory.CategoryStruct.comp self.actLeft h)))","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.left_assoc_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nself : Bimod A B\nZ : C\nh : Quiver.Hom self.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight A.mul self.X) (CategoryTheory.CategoryStruct.comp self.actLeft h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator A.X A.X self.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.actLeft) (CategoryTheory.CategoryStruct.comp self.actLeft h)))","decl":"attribute [reassoc (attr := simp)] Bimod.one_actLeft Bimod.actRight_one Bimod.left_assoc\n  Bimod.right_assoc Bimod.middle_assoc\n\n"}
{"name":"Bimod.Hom.ext","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nx y : M.Hom N\nhom : Eq x.hom y.hom\nâŠ¢ Eq x y","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nhomâœ : Quiver.Hom M.X N.X\nleft_act_homâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft homâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X homâœ) N.actLeft)) _autoâœ\nright_act_homâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight homâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight homâœ B.X) N.actRight)) _autoâœ\nhom : Quiver.Hom M.X N.X\nleft_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.actLeft)) _autoâœ\nright_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom B.X) N.actRight)) _autoâœ\nâŠ¢ Eq (Eq { hom := homâœ, left_act_hom := left_act_homâœ, right_act_hom := right_act_homâœ } { hom := hom, left_act_hom := left_act_hom, right_act_hom := right_act_hom }) (Eq homâœ hom)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\ninstâœ : SizeOf C\nhom : Quiver.Hom M.X N.X\nleft_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.actLeft)) _autoâœ\nright_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom B.X) N.actRight)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { hom := hom, left_act_hom := left_act_hom, right_act_hom := right_act_hom }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf left_act_hom)) (SizeOf.sizeOf right_act_hom))","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nhomâœ : Quiver.Hom M.X N.X\nleft_act_homâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft homâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X homâœ) N.actLeft)) _autoâœ\nright_act_homâœ : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight homâœ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight homâœ B.X) N.actRight)) _autoâœ\nhom : Quiver.Hom M.X N.X\nleft_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actLeft hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X hom) N.actLeft)) _autoâœ\nright_act_hom : autoParam (Eq (CategoryTheory.CategoryStruct.comp M.actRight hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight hom B.X) N.actRight)) _autoâœ\nxâœ : Eq { hom := homâœ, left_act_hom := left_act_homâœ, right_act_hom := right_act_homâœ } { hom := hom, left_act_hom := left_act_hom, right_act_hom := right_act_hom }\nâŠ¢ Eq homâœ hom","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.right_act_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp M.actRight self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.hom B.X) N.actRight)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nx y : M.Hom N\nâŠ¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.left_act_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp M.actLeft self.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) N.actLeft)","decl":"/-- A morphism of bimodule objects. -/\n@[ext]\nstructure Hom (M N : Bimod A B) where\n  hom : M.X âŸ¶ N.X\n  left_act_hom : M.actLeft â‰« hom = (A.X â— hom) â‰« N.actLeft := by aesop_cat\n  right_act_hom : M.actRight â‰« hom = (hom â–· B.X) â‰« N.actRight := by aesop_cat\n\n"}
{"name":"Bimod.Hom.right_act_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp M.actRight (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight self.hom B.X) (CategoryTheory.CategoryStruct.comp N.actRight h))","decl":"attribute [reassoc (attr := simp)] Hom.left_act_hom Hom.right_act_hom\n\n"}
{"name":"Bimod.Hom.left_act_hom_assoc","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nself : M.Hom N\nZ : C\nh : Quiver.Hom N.X Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp M.actLeft (CategoryTheory.CategoryStruct.comp self.hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft A.X self.hom) (CategoryTheory.CategoryStruct.comp N.actLeft h))","decl":"attribute [reassoc (attr := simp)] Hom.left_act_hom Hom.right_act_hom\n\n"}
{"name":"Bimod.id'_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM : Bimod A B\nâŠ¢ Eq M.id'.hom (CategoryTheory.CategoryStruct.id M.X)","decl":"/-- The identity morphism on a bimodule object. -/\n@[simps]\ndef id' (M : Bimod A B) : Hom M M where hom := ğŸ™ M.X\n\n"}
{"name":"Bimod.comp_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N O : Bimod A B\nf : M.Hom N\ng : N.Hom O\nâŠ¢ Eq (Bimod.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"/-- Composition of bimodule object morphisms. -/\n@[simps]\ndef comp {M N O : Bimod A B} (f : Hom M N) (g : Hom N O) : Hom M O where hom := f.hom â‰« g.hom\n\n"}
{"name":"Bimod.hom_ext_iff","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nf g : Quiver.Hom M N\nâŠ¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\nlemma hom_ext {M N : Bimod A B} (f g : M âŸ¶ N) (h : f.hom = g.hom) : f = g :=\n  Hom.ext h\n\n"}
{"name":"Bimod.hom_ext","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N : Bimod A B\nf g : Quiver.Hom M N\nh : Eq f.hom g.hom\nâŠ¢ Eq f g","decl":"@[ext]\nlemma hom_ext {M N : Bimod A B} (f g : M âŸ¶ N) (h : f.hom = g.hom) : f = g :=\n  Hom.ext h\n\n"}
{"name":"Bimod.id_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM : Bimod A B\nâŠ¢ Eq (CategoryTheory.CategoryStruct.id M).hom (CategoryTheory.CategoryStruct.id M.X)","decl":"@[simp]\ntheorem id_hom' (M : Bimod A B) : (ğŸ™ M : Hom M M).hom = ğŸ™ M.X :=\n  rfl\n\n"}
{"name":"Bimod.comp_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA B : Mon_ C\nM N K : Bimod A B\nf : Quiver.Hom M N\ng : Quiver.Hom N K\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).hom (CategoryTheory.CategoryStruct.comp f.hom g.hom)","decl":"@[simp]\ntheorem comp_hom' {M N K : Bimod A B} (f : M âŸ¶ N) (g : N âŸ¶ K) :\n    (f â‰« g : Hom M K).hom = f.hom â‰« g.hom :=\n  rfl\n\n"}
{"name":"Bimod.isoOfIso_inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : Mon_ C\nP Q : Bimod X Y\nf : CategoryTheory.Iso P.X Q.X\nf_left_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actLeft f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X f.hom) Q.actLeft)\nf_right_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actRight f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Y.X) Q.actRight)\nâŠ¢ Eq (Bimod.isoOfIso f f_left_act_hom f_right_act_hom).inv.hom f.inv","decl":"/-- Construct an isomorphism of bimodules by giving an isomorphism between the underlying objects\nand checking compatibility with left and right actions only in the forward direction.\n-/\n@[simps]\ndef isoOfIso {X Y : Mon_ C} {P Q : Bimod X Y} (f : P.X â‰… Q.X)\n    (f_left_act_hom : P.actLeft â‰« f.hom = (X.X â— f.hom) â‰« Q.actLeft)\n    (f_right_act_hom : P.actRight â‰« f.hom = (f.hom â–· Y.X) â‰« Q.actRight) : P â‰… Q where\n  hom :=\n    { hom := f.hom }\n  inv :=\n    { hom := f.inv\n      left_act_hom := by\n        rw [â† cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_left_act_hom, â† Category.assoc, â† MonoidalCategory.whiskerLeft_comp, Iso.inv_hom_id,\n          MonoidalCategory.whiskerLeft_id, Category.id_comp]\n      right_act_hom := by\n        rw [â† cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_right_act_hom, â† Category.assoc, â† comp_whiskerRight, Iso.inv_hom_id,\n          MonoidalCategory.id_whiskerRight, Category.id_comp] }\n  hom_inv_id := by ext; dsimp; rw [Iso.hom_inv_id]\n  inv_hom_id := by ext; dsimp; rw [Iso.inv_hom_id]\n\n"}
{"name":"Bimod.isoOfIso_hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nX Y : Mon_ C\nP Q : Bimod X Y\nf : CategoryTheory.Iso P.X Q.X\nf_left_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actLeft f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft X.X f.hom) Q.actLeft)\nf_right_act_hom : Eq (CategoryTheory.CategoryStruct.comp P.actRight f.hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Y.X) Q.actRight)\nâŠ¢ Eq (Bimod.isoOfIso f f_left_act_hom f_right_act_hom).hom.hom f.hom","decl":"/-- Construct an isomorphism of bimodules by giving an isomorphism between the underlying objects\nand checking compatibility with left and right actions only in the forward direction.\n-/\n@[simps]\ndef isoOfIso {X Y : Mon_ C} {P Q : Bimod X Y} (f : P.X â‰… Q.X)\n    (f_left_act_hom : P.actLeft â‰« f.hom = (X.X â— f.hom) â‰« Q.actLeft)\n    (f_right_act_hom : P.actRight â‰« f.hom = (f.hom â–· Y.X) â‰« Q.actRight) : P â‰… Q where\n  hom :=\n    { hom := f.hom }\n  inv :=\n    { hom := f.inv\n      left_act_hom := by\n        rw [â† cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_left_act_hom, â† Category.assoc, â† MonoidalCategory.whiskerLeft_comp, Iso.inv_hom_id,\n          MonoidalCategory.whiskerLeft_id, Category.id_comp]\n      right_act_hom := by\n        rw [â† cancel_mono f.hom, Category.assoc, Category.assoc, Iso.inv_hom_id, Category.comp_id,\n          f_right_act_hom, â† Category.assoc, â† comp_whiskerRight, Iso.inv_hom_id,\n          MonoidalCategory.id_whiskerRight, Category.id_comp] }\n  hom_inv_id := by ext; dsimp; rw [Iso.hom_inv_id]\n  inv_hom_id := by ext; dsimp; rw [Iso.inv_hom_id]\n\n"}
{"name":"Bimod.regular_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nâŠ¢ Eq (Bimod.regular A).actLeft A.mul","decl":"/-- A monoid object as a bimodule over itself. -/\n@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul\n\n"}
{"name":"Bimod.regular_X","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nâŠ¢ Eq (Bimod.regular A).X A.X","decl":"/-- A monoid object as a bimodule over itself. -/\n@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul\n\n"}
{"name":"Bimod.regular_actRight","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœ : CategoryTheory.MonoidalCategory C\nA : Mon_ C\nâŠ¢ Eq (Bimod.regular A).actRight A.mul","decl":"/-- A monoid object as a bimodule over itself. -/\n@[simps]\ndef regular : Bimod A A where\n  X := A.X\n  actLeft := A.mul\n  actRight := A.mul\n\n"}
{"name":"Bimod.TensorBimod.whiskerLeft_Ï€_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (CategoryTheory.Limits.coequalizer.Ï€ (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft)))) (Bimod.TensorBimod.actLeft P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator R.X P.X Q.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actLeft Q.X) (CategoryTheory.Limits.coequalizer.Ï€ (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft)))))","decl":"theorem whiskerLeft_Ï€_actLeft :\n    (R.X â— coequalizer.Ï€ _ _) â‰« actLeft P Q =\n      (Î±_ _ _ _).inv â‰« (P.actLeft â–· Q.X) â‰« coequalizer.Ï€ _ _ := by\n  erw [map_Ï€_preserves_coequalizer_inv_colimMap (tensorLeft _)]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.TensorBimod.one_act_left'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight R.one (Bimod.TensorBimod.X P Q)) (Bimod.TensorBimod.actLeft P Q)) (CategoryTheory.MonoidalCategoryStruct.leftUnitor (Bimod.TensorBimod.X P Q)).hom","decl":"theorem one_act_left' : (R.one â–· _) â‰« actLeft P Q = (Î»_ _).hom := by\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp [X]\n  -- Porting note: had to replace `rw` by `erw`\n  slice_lhs 1 2 => erw [whisker_exchange]\n  slice_lhs 2 3 => rw [whiskerLeft_Ï€_actLeft]\n  slice_lhs 1 2 => rw [associator_inv_naturality_left]\n  slice_lhs 2 3 => rw [â† comp_whiskerRight, one_actLeft]\n  slice_rhs 1 2 => rw [leftUnitor_naturality]\n  monoidal\n\n"}
{"name":"Bimod.TensorBimod.left_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight R.mul (Bimod.TensorBimod.X P Q)) (Bimod.TensorBimod.actLeft P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator R.X R.X (Bimod.TensorBimod.X P Q)).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.TensorBimod.actLeft P Q)) (Bimod.TensorBimod.actLeft P Q)))","decl":"theorem left_assoc' :\n    (R.mul â–· _) â‰« actLeft P Q = (Î±_ R.X R.X _).hom â‰« (R.X â— actLeft P Q) â‰« actLeft P Q := by\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp [X]\n  slice_lhs 1 2 => rw [whisker_exchange]\n  slice_lhs 2 3 => rw [whiskerLeft_Ï€_actLeft]\n  slice_lhs 1 2 => rw [associator_inv_naturality_left]\n  slice_lhs 2 3 => rw [â† comp_whiskerRight, left_assoc, comp_whiskerRight, comp_whiskerRight]\n  slice_rhs 1 2 => rw [associator_naturality_right]\n  slice_rhs 2 3 =>\n    rw [â† MonoidalCategory.whiskerLeft_comp, whiskerLeft_Ï€_actLeft,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 4 5 => rw [whiskerLeft_Ï€_actLeft]\n  slice_rhs 3 4 => rw [associator_inv_naturality_middle]\n  monoidal\n\n"}
{"name":"Bimod.TensorBimod.Ï€_tensor_id_actRight","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.Limits.coequalizer.Ï€ (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft))) T.X) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X Q.X T.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actRight) (CategoryTheory.Limits.coequalizer.Ï€ (CategoryTheory.MonoidalCategoryStruct.whiskerRight P.actRight Q.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator P.X S.X Q.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft P.X Q.actLeft)))))","decl":"theorem Ï€_tensor_id_actRight :\n    (coequalizer.Ï€ _ _ â–· T.X) â‰« actRight P Q =\n      (Î±_ _ _ _).hom â‰« (P.X â— Q.actRight) â‰« coequalizer.Ï€ _ _ := by\n  erw [map_Ï€_preserves_coequalizer_inv_colimMap (tensorRight _)]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.TensorBimod.actRight_one'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (Bimod.TensorBimod.X P Q) T.one) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.MonoidalCategoryStruct.rightUnitor (Bimod.TensorBimod.X P Q)).hom","decl":"theorem actRight_one' : (_ â— T.one) â‰« actRight P Q = (Ï_ _).hom := by\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp [X]\n  -- Porting note: had to replace `rw` by `erw`\n  slice_lhs 1 2 =>erw [â† whisker_exchange]\n  slice_lhs 2 3 => rw [Ï€_tensor_id_actRight]\n  slice_lhs 1 2 => rw [associator_naturality_right]\n  slice_lhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, actRight_one]\n  simp\n\n"}
{"name":"Bimod.TensorBimod.right_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ² : CategoryTheory.MonoidalCategory C\ninstâœÂ¹ : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (Bimod.TensorBimod.X P Q) T.mul) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator (Bimod.TensorBimod.X P Q) T.X T.X).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.TensorBimod.actRight P Q) T.X) (Bimod.TensorBimod.actRight P Q)))","decl":"theorem right_assoc' :\n    (_ â— T.mul) â‰« actRight P Q =\n      (Î±_ _ T.X T.X).inv â‰« (actRight P Q â–· T.X) â‰« actRight P Q := by\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp [X]\n  -- Porting note: had to replace some `rw` by `erw`\n  slice_lhs 1 2 => rw [â† whisker_exchange]\n  slice_lhs 2 3 => rw [Ï€_tensor_id_actRight]\n  slice_lhs 1 2 => rw [associator_naturality_right]\n  slice_lhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, right_assoc,\n    MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 1 2 => rw [associator_inv_naturality_left]\n  slice_rhs 2 3 => rw [â† comp_whiskerRight, Ï€_tensor_id_actRight, comp_whiskerRight,\n    comp_whiskerRight]\n  slice_rhs 4 5 => rw [Ï€_tensor_id_actRight]\n  simp\n\n"}
{"name":"Bimod.TensorBimod.middle_assoc'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\nR S T : Mon_ C\nP : Bimod R S\nQ : Bimod S T\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.TensorBimod.actLeft P Q) T.X) (Bimod.TensorBimod.actRight P Q)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator R.X (Bimod.TensorBimod.X P Q) T.X).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.TensorBimod.actRight P Q)) (Bimod.TensorBimod.actLeft P Q)))","decl":"theorem middle_assoc' :\n    (actLeft P Q â–· T.X) â‰« actRight P Q =\n      (Î±_ R.X _ T.X).hom â‰« (R.X â— actRight P Q) â‰« actLeft P Q := by\n  refine (cancel_epi ((tensorLeft _ â‹™ tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp [X]\n  slice_lhs 1 2 => rw [â† comp_whiskerRight, whiskerLeft_Ï€_actLeft, comp_whiskerRight,\n    comp_whiskerRight]\n  slice_lhs 3 4 => rw [Ï€_tensor_id_actRight]\n  slice_lhs 2 3 => rw [associator_naturality_left]\n  -- Porting note: had to replace `rw` by `erw`\n  slice_rhs 1 2 => rw [associator_naturality_middle]\n  slice_rhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, Ï€_tensor_id_actRight,\n    MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 4 5 => rw [whiskerLeft_Ï€_actLeft]\n  slice_rhs 3 4 => rw [associator_inv_naturality_right]\n  slice_rhs 4 5 => rw [whisker_exchange]\n  simp\n\n"}
{"name":"Bimod.tensorBimod_actRight","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\nâŠ¢ Eq (M.tensorBimod N).actRight (Bimod.TensorBimod.actRight M N)","decl":"/-- Tensor product of two bimodule objects as a bimodule object. -/\n@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N\n\n"}
{"name":"Bimod.tensorBimod_X","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\nâŠ¢ Eq (M.tensorBimod N).X (Bimod.TensorBimod.X M N)","decl":"/-- Tensor product of two bimodule objects as a bimodule object. -/\n@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N\n\n"}
{"name":"Bimod.tensorBimod_actLeft","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\nâŠ¢ Eq (M.tensorBimod N).actLeft (Bimod.TensorBimod.actLeft M N)","decl":"/-- Tensor product of two bimodule objects as a bimodule object. -/\n@[simps]\nnoncomputable def tensorBimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) : Bimod X Z where\n  X := TensorBimod.X M N\n  actLeft := TensorBimod.actLeft M N\n  actRight := TensorBimod.actRight M N\n  one_actLeft := TensorBimod.one_act_left' M N\n  actRight_one := TensorBimod.actRight_one' M N\n  left_assoc := TensorBimod.left_assoc' M N\n  right_assoc := TensorBimod.right_assoc' M N\n  middle_assoc := TensorBimod.middle_assoc' M N\n\n"}
{"name":"Bimod.whiskerLeft_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nNâ‚ Nâ‚‚ : Bimod Y Z\nf : Quiver.Hom Nâ‚ Nâ‚‚\nâŠ¢ Eq (M.whiskerLeft f).hom (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.actRight Nâ‚.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X Y.X Nâ‚.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X Nâ‚.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight M.actRight Nâ‚‚.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator M.X Y.X Nâ‚‚.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X Nâ‚‚.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft (CategoryTheory.MonoidalCategoryStruct.tensorObj M.X Y.X) f.hom) (CategoryTheory.MonoidalCategoryStruct.whiskerLeft M.X f.hom) â‹¯ â‹¯))","decl":"/-- Left whiskering for morphisms of bimodule objects. -/\n@[simps]\nnoncomputable def whiskerLeft {X Y Z : Mon_ C} (M : Bimod X Y) {Nâ‚ Nâ‚‚ : Bimod Y Z} (f : Nâ‚ âŸ¶ Nâ‚‚) :\n    M.tensorBimod Nâ‚ âŸ¶ M.tensorBimod Nâ‚‚ where\n  hom :=\n    colimMap\n      (parallelPairHom _ _ _ _ (_ â— f.hom) (_ â— f.hom)\n        (by rw [whisker_exchange])\n        (by\n          simp only [Category.assoc, tensor_whiskerLeft, Iso.inv_hom_id_assoc,\n            Iso.cancel_iso_hom_left]\n          slice_lhs 1 2 => rw [â† MonoidalCategory.whiskerLeft_comp, Hom.left_act_hom]\n          simp))\n  left_act_hom := by\n    refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.whiskerLeft_Ï€_actLeft]\n    slice_lhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n    slice_rhs 1 2 => rw [â† MonoidalCategory.whiskerLeft_comp, Î¹_colimMap, parallelPairHom_app_one,\n      MonoidalCategory.whiskerLeft_comp]\n    slice_rhs 2 3 => rw [TensorBimod.whiskerLeft_Ï€_actLeft]\n    slice_rhs 1 2 => rw [associator_inv_naturality_right]\n    slice_rhs 2 3 => rw [whisker_exchange]\n    simp\n  right_act_hom := by\n    refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.Ï€_tensor_id_actRight]\n    slice_lhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, Hom.right_act_hom]\n    slice_rhs 1 2 =>\n      rw [â† comp_whiskerRight, Î¹_colimMap, parallelPairHom_app_one, comp_whiskerRight]\n    slice_rhs 2 3 => rw [TensorBimod.Ï€_tensor_id_actRight]\n    simp\n\n"}
{"name":"Bimod.whiskerRight_hom","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nMâ‚ Mâ‚‚ : Bimod X Y\nf : Quiver.Hom Mâ‚ Mâ‚‚\nN : Bimod Y Z\nâŠ¢ Eq (Bimod.whiskerRight f N).hom (CategoryTheory.Limits.colimMap (CategoryTheory.Limits.parallelPairHom (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mâ‚.actRight N.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Mâ‚.X Y.X N.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Mâ‚.X N.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight Mâ‚‚.actRight N.X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.associator Mâ‚‚.X Y.X N.X).hom (CategoryTheory.MonoidalCategoryStruct.whiskerLeft Mâ‚‚.X N.actLeft)) (CategoryTheory.MonoidalCategoryStruct.whiskerRight (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom Y.X) N.X) (CategoryTheory.MonoidalCategoryStruct.whiskerRight f.hom N.X) â‹¯ â‹¯))","decl":"/-- Right whiskering for morphisms of bimodule objects. -/\n@[simps]\nnoncomputable def whiskerRight {X Y Z : Mon_ C} {Mâ‚ Mâ‚‚ : Bimod X Y} (f : Mâ‚ âŸ¶ Mâ‚‚) (N : Bimod Y Z) :\n    Mâ‚.tensorBimod N âŸ¶ Mâ‚‚.tensorBimod N where\n  hom :=\n    colimMap\n      (parallelPairHom _ _ _ _ (f.hom â–· _ â–· _) (f.hom â–· _)\n        (by rw [â† comp_whiskerRight, Hom.right_act_hom, comp_whiskerRight])\n        (by\n          slice_lhs 2 3 => rw [whisker_exchange]\n          simp))\n  left_act_hom := by\n    refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.whiskerLeft_Ï€_actLeft]\n    slice_lhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [â† comp_whiskerRight, Hom.left_act_hom]\n    slice_rhs 1 2 => rw [â† MonoidalCategory.whiskerLeft_comp, Î¹_colimMap, parallelPairHom_app_one,\n      MonoidalCategory.whiskerLeft_comp]\n    slice_rhs 2 3 => rw [TensorBimod.whiskerLeft_Ï€_actLeft]\n    slice_rhs 1 2 => rw [associator_inv_naturality_middle]\n    simp\n  right_act_hom := by\n    refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n    dsimp\n    slice_lhs 1 2 => rw [TensorBimod.Ï€_tensor_id_actRight]\n    slice_lhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n    slice_lhs 2 3 => rw [whisker_exchange]\n    slice_rhs 1 2 => rw [â† comp_whiskerRight, Î¹_colimMap, parallelPairHom_app_one,\n      comp_whiskerRight]\n    slice_rhs 2 3 => rw [TensorBimod.Ï€_tensor_id_actRight]\n    simp\n\n"}
{"name":"Bimod.AssociatorBimod.hom_left_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((P.tensorBimod Q).tensorBimod L).actLeft (Bimod.AssociatorBimod.hom P Q L)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.AssociatorBimod.hom P Q L)) (P.tensorBimod (Q.tensorBimod L)).actLeft)","decl":"theorem hom_left_act_hom' :\n    ((P.tensorBimod Q).tensorBimod L).actLeft â‰« hom P Q L =\n      (R.X â— hom P Q L) â‰« (P.tensorBimod (Q.tensorBimod L)).actLeft := by\n  dsimp; dsimp [hom, homAux]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorLeft_map]\n  slice_lhs 1 2 => rw [TensorBimod.whiskerLeft_Ï€_actLeft]\n  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]\n  slice_rhs 1 2 => rw [â† MonoidalCategory.whiskerLeft_comp, coequalizer.Ï€_desc,\n    MonoidalCategory.whiskerLeft_comp]\n  refine (cancel_epi ((tensorRight _ â‹™ tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp; dsimp [TensorBimod.X]\n  slice_lhs 1 2 => rw [associator_inv_naturality_middle]\n  slice_lhs 2 3 =>\n    rw [â† comp_whiskerRight, TensorBimod.whiskerLeft_Ï€_actLeft,\n      comp_whiskerRight, comp_whiskerRight]\n  slice_lhs 4 6 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [associator_naturality_left]\n  slice_rhs 1 3 =>\n    rw [â† MonoidalCategory.whiskerLeft_comp, â† MonoidalCategory.whiskerLeft_comp,\n      Ï€_tensor_id_preserves_coequalizer_inv_desc, MonoidalCategory.whiskerLeft_comp,\n      MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 3 4 => erw [TensorBimod.whiskerLeft_Ï€_actLeft P (Q.tensorBimod L)]\n  slice_rhs 2 3 => erw [associator_inv_naturality_right]\n  slice_rhs 3 4 => erw [whisker_exchange]\n  monoidal\n\n"}
{"name":"Bimod.AssociatorBimod.hom_right_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((P.tensorBimod Q).tensorBimod L).actRight (Bimod.AssociatorBimod.hom P Q L)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.AssociatorBimod.hom P Q L) U.X) (P.tensorBimod (Q.tensorBimod L)).actRight)","decl":"theorem hom_right_act_hom' :\n    ((P.tensorBimod Q).tensorBimod L).actRight â‰« hom P Q L =\n      (hom P Q L â–· U.X) â‰« (P.tensorBimod (Q.tensorBimod L)).actRight := by\n  dsimp; dsimp [hom, homAux]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_lhs 1 2 => rw [TensorBimod.Ï€_tensor_id_actRight]\n  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]\n  slice_rhs 1 2 => rw [â† comp_whiskerRight, coequalizer.Ï€_desc, comp_whiskerRight]\n  refine (cancel_epi ((tensorRight _ â‹™ tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp; dsimp [TensorBimod.X]\n  slice_lhs 1 2 => rw [associator_naturality_left]\n  slice_lhs 2 3 => rw [â† whisker_exchange]\n  slice_lhs 3 5 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 2 3 => rw [associator_naturality_right]\n  slice_rhs 1 3 =>\n    rw [â† comp_whiskerRight, â† comp_whiskerRight, Ï€_tensor_id_preserves_coequalizer_inv_desc,\n      comp_whiskerRight, comp_whiskerRight]\n  slice_rhs 3 4 => erw [TensorBimod.Ï€_tensor_id_actRight P (Q.tensorBimod L)]\n  slice_rhs 2 3 => erw [associator_naturality_middle]\n  dsimp\n  slice_rhs 3 4 =>\n    rw [â† MonoidalCategory.whiskerLeft_comp, TensorBimod.Ï€_tensor_id_actRight,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  monoidal\n\n"}
{"name":"Bimod.AssociatorBimod.hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.AssociatorBimod.hom P Q L) (Bimod.AssociatorBimod.inv P Q L)) (CategoryTheory.CategoryStruct.id ((P.tensorBimod Q).tensorBimod L).X)","decl":"theorem hom_inv_id : hom P Q L â‰« inv P Q L = ğŸ™ _ := by\n  dsimp [hom, homAux, inv, invAux]\n  apply coequalizer.hom_ext\n  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_lhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]\n  slice_lhs 2 4 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]\n  slice_lhs 1 3 => rw [Iso.hom_inv_id_assoc]\n  dsimp only [TensorBimod.X]\n  slice_rhs 2 3 => rw [Category.comp_id]\n  rfl\n\n"}
{"name":"Bimod.AssociatorBimod.inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nR S T U : Mon_ C\nP : Bimod R S\nQ : Bimod S T\nL : Bimod T U\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.AssociatorBimod.inv P Q L) (Bimod.AssociatorBimod.hom P Q L)) (CategoryTheory.CategoryStruct.id (P.tensorBimod (Q.tensorBimod L)).X)","decl":"theorem inv_hom_id : inv P Q L â‰« hom P Q L = ğŸ™ _ := by\n  dsimp [hom, homAux, inv, invAux]\n  apply coequalizer.hom_ext\n  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorLeft_map]\n  slice_lhs 1 3 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]\n  slice_lhs 2 4 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 1 3 => rw [Iso.inv_hom_id_assoc]\n  dsimp only [TensorBimod.X]\n  slice_rhs 2 3 => rw [Category.comp_id]\n  rfl\n\n"}
{"name":"Bimod.LeftUnitorBimod.hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.LeftUnitorBimod.hom P) (Bimod.LeftUnitorBimod.inv P)) (CategoryTheory.CategoryStruct.id (Bimod.TensorBimod.X (Bimod.regular R) P))","decl":"theorem hom_inv_id : hom P â‰« inv P = ğŸ™ _ := by\n  dsimp only [hom, inv, TensorBimod.X]\n  ext; dsimp\n  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]\n  slice_lhs 1 2 => rw [leftUnitor_inv_naturality]\n  slice_lhs 2 3 => rw [whisker_exchange]\n  slice_lhs 3 3 => rw [â† Iso.inv_hom_id_assoc (Î±_ R.X R.X P.X) (R.X â— P.actLeft)]\n  slice_lhs 4 6 => rw [â† Category.assoc, â† coequalizer.condition]\n  slice_lhs 2 3 => rw [associator_inv_naturality_left]\n  slice_lhs 3 4 => rw [â† comp_whiskerRight, Mon_.one_mul]\n  slice_rhs 1 2 => rw [Category.comp_id]\n  monoidal\n\n"}
{"name":"Bimod.LeftUnitorBimod.inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.LeftUnitorBimod.inv P) (Bimod.LeftUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.id P.X)","decl":"theorem inv_hom_id : inv P â‰« hom P = ğŸ™ _ := by\n  dsimp [hom, inv]\n  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]\n  rw [one_actLeft, Iso.inv_hom_id]\n\n"}
{"name":"Bimod.LeftUnitorBimod.hom_left_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((Bimod.regular R).tensorBimod P).actLeft (Bimod.LeftUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.LeftUnitorBimod.hom P)) P.actLeft)","decl":"theorem hom_left_act_hom' :\n    ((regular R).tensorBimod P).actLeft â‰« hom P = (R.X â— hom P) â‰« P.actLeft := by\n  dsimp; dsimp [hom, TensorBimod.actLeft, regular]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [id_tensor_Ï€_preserves_coequalizer_inv_colimMap_desc]\n  slice_lhs 2 3 => rw [left_assoc]\n  slice_rhs 1 2 => rw [â† MonoidalCategory.whiskerLeft_comp, coequalizer.Ï€_desc]\n  rw [Iso.inv_hom_id_assoc]\n\n"}
{"name":"Bimod.LeftUnitorBimod.hom_right_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((Bimod.regular R).tensorBimod P).actRight (Bimod.LeftUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.LeftUnitorBimod.hom P) S.X) P.actRight)","decl":"theorem hom_right_act_hom' :\n    ((regular R).tensorBimod P).actRight â‰« hom P = (hom P â–· S.X) â‰« P.actRight := by\n  dsimp; dsimp [hom, TensorBimod.actRight, regular]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [Ï€_tensor_id_preserves_coequalizer_inv_colimMap_desc]\n  slice_rhs 1 2 => rw [â† comp_whiskerRight, coequalizer.Ï€_desc]\n  slice_rhs 1 2 => rw [middle_assoc]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.RightUnitorBimod.hom_inv_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.RightUnitorBimod.hom P) (Bimod.RightUnitorBimod.inv P)) (CategoryTheory.CategoryStruct.id (Bimod.TensorBimod.X P (Bimod.regular S)))","decl":"theorem hom_inv_id : hom P â‰« inv P = ğŸ™ _ := by\n  dsimp only [hom, inv, TensorBimod.X]\n  ext; dsimp\n  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]\n  slice_lhs 1 2 => rw [rightUnitor_inv_naturality]\n  slice_lhs 2 3 => rw [â† whisker_exchange]\n  slice_lhs 3 4 => rw [coequalizer.condition]\n  slice_lhs 2 3 => rw [associator_naturality_right]\n  slice_lhs 3 4 => rw [â† MonoidalCategory.whiskerLeft_comp, Mon_.mul_one]\n  slice_rhs 1 2 => rw [Category.comp_id]\n  monoidal\n\n"}
{"name":"Bimod.RightUnitorBimod.inv_hom_id","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ¹ : CategoryTheory.MonoidalCategory C\ninstâœ : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.RightUnitorBimod.inv P) (Bimod.RightUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.id P.X)","decl":"theorem inv_hom_id : inv P â‰« hom P = ğŸ™ _ := by\n  dsimp [hom, inv]\n  slice_lhs 3 4 => rw [coequalizer.Ï€_desc]\n  rw [actRight_one, Iso.inv_hom_id]\n\n"}
{"name":"Bimod.RightUnitorBimod.hom_left_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (P.tensorBimod (Bimod.regular S)).actLeft (Bimod.RightUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerLeft R.X (Bimod.RightUnitorBimod.hom P)) P.actLeft)","decl":"theorem hom_left_act_hom' :\n    (P.tensorBimod (regular S)).actLeft â‰« hom P = (R.X â— hom P) â‰« P.actLeft := by\n  dsimp; dsimp [hom, TensorBimod.actLeft, regular]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [id_tensor_Ï€_preserves_coequalizer_inv_colimMap_desc]\n  slice_lhs 2 3 => rw [middle_assoc]\n  slice_rhs 1 2 => rw [â† MonoidalCategory.whiskerLeft_comp, coequalizer.Ï€_desc]\n  rw [Iso.inv_hom_id_assoc]\n\n"}
{"name":"Bimod.RightUnitorBimod.hom_right_act_hom'","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\nR S : Mon_ C\nP : Bimod R S\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (P.tensorBimod (Bimod.regular S)).actRight (Bimod.RightUnitorBimod.hom P)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.MonoidalCategoryStruct.whiskerRight (Bimod.RightUnitorBimod.hom P) S.X) P.actRight)","decl":"theorem hom_right_act_hom' :\n    (P.tensorBimod (regular S)).actRight â‰« hom P = (hom P â–· S.X) â‰« P.actRight := by\n  dsimp; dsimp [hom, TensorBimod.actRight, regular]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp\n  slice_lhs 1 4 => rw [Ï€_tensor_id_preserves_coequalizer_inv_colimMap_desc]\n  slice_lhs 2 3 => rw [right_assoc]\n  slice_rhs 1 2 => rw [â† comp_whiskerRight, coequalizer.Ï€_desc]\n  rw [Iso.hom_inv_id_assoc]\n\n"}
{"name":"Bimod.whiskerLeft_id_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\nâŠ¢ Eq (M.whiskerLeft (CategoryTheory.CategoryStruct.id N)) (CategoryTheory.CategoryStruct.id (M.tensorBimod N))","decl":"theorem whiskerLeft_id_bimod {X Y Z : Mon_ C} {M : Bimod X Y} {N : Bimod Y Z} :\n    whiskerLeft M (ğŸ™ N) = ğŸ™ (M.tensorBimod N) := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  dsimp only [tensorBimod_X, whiskerLeft_hom, id_hom']\n  simp only [MonoidalCategory.whiskerLeft_id, Î¹_colimMap, parallelPair_obj_one,\n    parallelPairHom_app_one, Category.id_comp]\n  erw [Category.comp_id]\n\n"}
{"name":"Bimod.id_whiskerRight_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\nâŠ¢ Eq (Bimod.whiskerRight (CategoryTheory.CategoryStruct.id M) N) (CategoryTheory.CategoryStruct.id (M.tensorBimod N))","decl":"theorem id_whiskerRight_bimod {X Y Z : Mon_ C} {M : Bimod X Y} {N : Bimod Y Z} :\n    whiskerRight (ğŸ™ M) N = ğŸ™ (M.tensorBimod N) := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  dsimp only [tensorBimod_X, whiskerRight_hom, id_hom']\n  simp only [MonoidalCategory.id_whiskerRight, Î¹_colimMap, parallelPair_obj_one,\n    parallelPairHom_app_one, Category.id_comp]\n  erw [Category.comp_id]\n\n"}
{"name":"Bimod.whiskerLeft_comp_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN P Q : Bimod Y Z\nf : Quiver.Hom N P\ng : Quiver.Hom P Q\nâŠ¢ Eq (M.whiskerLeft (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (M.whiskerLeft f) (M.whiskerLeft g))","decl":"theorem whiskerLeft_comp_bimod {X Y Z : Mon_ C} (M : Bimod X Y) {N P Q : Bimod Y Z} (f : N âŸ¶ P)\n    (g : P âŸ¶ Q) : whiskerLeft M (f â‰« g) = whiskerLeft M f â‰« whiskerLeft M g := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  simp\n\n"}
{"name":"Bimod.id_whiskerLeft_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y : Mon_ C\nM N : Bimod X Y\nf : Quiver.Hom M N\nâŠ¢ Eq ((Bimod.regular X).whiskerLeft f) (CategoryTheory.CategoryStruct.comp M.leftUnitorBimod.hom (CategoryTheory.CategoryStruct.comp f N.leftUnitorBimod.inv))","decl":"theorem id_whiskerLeft_bimod {X Y : Mon_ C} {M N : Bimod X Y} (f : M âŸ¶ N) :\n    whiskerLeft (regular X) f = (leftUnitorBimod M).hom â‰« f â‰« (leftUnitorBimod N).inv := by\n  dsimp [tensorHom, regular, leftUnitorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [LeftUnitorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [LeftUnitorBimod.inv]\n  slice_rhs 1 2 => rw [Hom.left_act_hom]\n  slice_rhs 2 3 => rw [leftUnitor_inv_naturality]\n  slice_rhs 3 4 => rw [whisker_exchange]\n  slice_rhs 4 4 => rw [â† Iso.inv_hom_id_assoc (Î±_ X.X X.X N.X) (X.X â— N.actLeft)]\n  slice_rhs 5 7 => rw [â† Category.assoc, â† coequalizer.condition]\n  slice_rhs 3 4 => rw [associator_inv_naturality_left]\n  slice_rhs 4 5 => rw [â† comp_whiskerRight, Mon_.one_mul]\n  have : (Î»_ (X.X âŠ— N.X)).inv â‰« (Î±_ (ğŸ™_ C) X.X N.X).inv â‰« ((Î»_ X.X).hom â–· N.X) = ğŸ™ _ := by\n    monoidal\n  slice_rhs 2 4 => rw [this]\n  slice_rhs 1 2 => rw [Category.comp_id]\n\n"}
{"name":"Bimod.comp_whiskerLeft_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : Mon_ C\nM : Bimod W X\nN : Bimod X Y\nP P' : Bimod Y Z\nf : Quiver.Hom P P'\nâŠ¢ Eq ((M.tensorBimod N).whiskerLeft f) (CategoryTheory.CategoryStruct.comp (M.associatorBimod N P).hom (CategoryTheory.CategoryStruct.comp (M.whiskerLeft (N.whiskerLeft f)) (M.associatorBimod N P').inv))","decl":"theorem comp_whiskerLeft_bimod {W X Y Z : Mon_ C} (M : Bimod W X) (N : Bimod X Y)\n    {P P' : Bimod Y Z} (f : P âŸ¶ P') :\n    whiskerLeft (M.tensorBimod N) f =\n      (associatorBimod M N P).hom â‰«\n        whiskerLeft M (whiskerLeft N f) â‰« (associatorBimod M N P').inv := by\n  dsimp [tensorHom, tensorBimod, associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [TensorBimod.X, AssociatorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.homAux, AssociatorBimod.inv]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_rhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 3 4 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.invAux]\n  slice_rhs 2 2 => rw [MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 3 5 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_inv_naturality_right]\n  slice_rhs 1 3 => rw [Iso.hom_inv_id_assoc]\n  slice_lhs 1 2 => rw [â† whisker_exchange]\n  rfl\n\n"}
{"name":"Bimod.comp_whiskerRight_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM N P : Bimod X Y\nf : Quiver.Hom M N\ng : Quiver.Hom N P\nQ : Bimod Y Z\nâŠ¢ Eq (Bimod.whiskerRight (CategoryTheory.CategoryStruct.comp f g) Q) (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight f Q) (Bimod.whiskerRight g Q))","decl":"theorem comp_whiskerRight_bimod {X Y Z : Mon_ C} {M N P : Bimod X Y} (f : M âŸ¶ N) (g : N âŸ¶ P)\n    (Q : Bimod Y Z) : whiskerRight (f â‰« g) Q = whiskerRight f Q â‰« whiskerRight g Q := by\n  ext\n  apply Limits.coequalizer.hom_ext\n  simp\n\n"}
{"name":"Bimod.whiskerRight_id_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y : Mon_ C\nM N : Bimod X Y\nf : Quiver.Hom M N\nâŠ¢ Eq (Bimod.whiskerRight f (Bimod.regular Y)) (CategoryTheory.CategoryStruct.comp M.rightUnitorBimod.hom (CategoryTheory.CategoryStruct.comp f N.rightUnitorBimod.inv))","decl":"theorem whiskerRight_id_bimod {X Y : Mon_ C} {M N : Bimod X Y} (f : M âŸ¶ N) :\n    whiskerRight f (regular Y) = (rightUnitorBimod M).hom â‰« f â‰« (rightUnitorBimod N).inv := by\n  dsimp [tensorHom, regular, rightUnitorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [RightUnitorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [RightUnitorBimod.inv]\n  slice_rhs 1 2 => rw [Hom.right_act_hom]\n  slice_rhs 2 3 => rw [rightUnitor_inv_naturality]\n  slice_rhs 3 4 => rw [â† whisker_exchange]\n  slice_rhs 4 5 => rw [coequalizer.condition]\n  slice_rhs 3 4 => rw [associator_naturality_right]\n  slice_rhs 4 5 => rw [â† MonoidalCategory.whiskerLeft_comp, Mon_.mul_one]\n  simp\n\n"}
{"name":"Bimod.whiskerRight_comp_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : Mon_ C\nM M' : Bimod W X\nf : Quiver.Hom M M'\nN : Bimod X Y\nP : Bimod Y Z\nâŠ¢ Eq (Bimod.whiskerRight f (N.tensorBimod P)) (CategoryTheory.CategoryStruct.comp (M.associatorBimod N P).inv (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight (Bimod.whiskerRight f N) P) (M'.associatorBimod N P).hom))","decl":"theorem whiskerRight_comp_bimod {W X Y Z : Mon_ C} {M M' : Bimod W X} (f : M âŸ¶ M') (N : Bimod X Y)\n    (P : Bimod Y Z) :\n    whiskerRight f (N.tensorBimod P) =\n      (associatorBimod M N P).inv â‰«\n        whiskerRight (whiskerRight f N) P â‰« (associatorBimod M' N P).hom := by\n  dsimp [tensorHom, tensorBimod, associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [TensorBimod.X, AssociatorBimod.inv]\n  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.invAux, AssociatorBimod.hom]\n  refine (cancel_epi ((tensorLeft _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorLeft_map]\n  slice_rhs 1 3 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [â† comp_whiskerRight, Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 3 4 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.homAux]\n  slice_rhs 2 2 => rw [comp_whiskerRight]\n  slice_rhs 3 5 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_naturality_left]\n  slice_rhs 1 3 => rw [Iso.inv_hom_id_assoc]\n  slice_lhs 1 2 => rw [whisker_exchange]\n  rfl\n\n"}
{"name":"Bimod.whisker_assoc_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nW X Y Z : Mon_ C\nM : Bimod W X\nN N' : Bimod X Y\nf : Quiver.Hom N N'\nP : Bimod Y Z\nâŠ¢ Eq (Bimod.whiskerRight (M.whiskerLeft f) P) (CategoryTheory.CategoryStruct.comp (M.associatorBimod N P).hom (CategoryTheory.CategoryStruct.comp (M.whiskerLeft (Bimod.whiskerRight f P)) (M.associatorBimod N' P).inv))","decl":"theorem whisker_assoc_bimod {W X Y Z : Mon_ C} (M : Bimod W X) {N N' : Bimod X Y} (f : N âŸ¶ N')\n    (P : Bimod Y Z) :\n    whiskerRight (whiskerLeft M f) P =\n      (associatorBimod M N P).hom â‰«\n        whiskerLeft M (whiskerRight f P) â‰« (associatorBimod M N' P).inv := by\n  dsimp [tensorHom, tensorBimod, associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [AssociatorBimod.hom]\n  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.homAux]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  rw [tensorRight_map]\n  slice_lhs 1 2 => rw [â† comp_whiskerRight, Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [AssociatorBimod.inv]\n  slice_rhs 3 4 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.invAux]\n  slice_rhs 2 2 => rw [MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 3 5 => rw [id_tensor_Ï€_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_inv_naturality_middle]\n  slice_rhs 1 3 => rw [Iso.hom_inv_id_assoc]\n  slice_lhs 1 1 => rw [comp_whiskerRight]\n\n"}
{"name":"Bimod.whisker_exchange_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM N : Bimod X Y\nP Q : Bimod Y Z\nf : Quiver.Hom M N\ng : Quiver.Hom P Q\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (M.whiskerLeft g) (Bimod.whiskerRight f Q)) (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight f P) (N.whiskerLeft g))","decl":"theorem whisker_exchange_bimod {X Y Z : Mon_ C} {M N : Bimod X Y} {P Q : Bimod Y Z} (f : M âŸ¶ N)\n    (g : P âŸ¶ Q) : whiskerLeft M g â‰« whiskerRight f Q =\n      whiskerRight f P â‰« whiskerLeft N g := by\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_lhs 2 3 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_lhs 1 2 => rw [whisker_exchange]\n  slice_rhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_rhs 2 3 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  simp only [Category.assoc]\n\n"}
{"name":"Bimod.pentagon_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nV W X Y Z : Mon_ C\nM : Bimod V W\nN : Bimod W X\nP : Bimod X Y\nQ : Bimod Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (Bimod.whiskerRight (M.associatorBimod N P).hom Q) (CategoryTheory.CategoryStruct.comp (M.associatorBimod (N.tensorBimod P) Q).hom (M.whiskerLeft (N.associatorBimod P Q).hom))) (CategoryTheory.CategoryStruct.comp ((M.tensorBimod N).associatorBimod P Q).hom (M.associatorBimod N (P.tensorBimod Q)).hom)","decl":"theorem pentagon_bimod {V W X Y Z : Mon_ C} (M : Bimod V W) (N : Bimod W X) (P : Bimod X Y)\n    (Q : Bimod Y Z) :\n    whiskerRight (associatorBimod M N P).hom Q â‰«\n      (associatorBimod M (N.tensorBimod P) Q).hom â‰«\n        whiskerLeft M (associatorBimod N P Q).hom =\n      (associatorBimod (M.tensorBimod N) P Q).hom â‰«\n        (associatorBimod M N (P.tensorBimod Q)).hom := by\n  dsimp [associatorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  dsimp only [AssociatorBimod.hom]\n  slice_lhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_lhs 2 3 => rw [coequalizer.Ï€_desc]\n  slice_rhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.homAux]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp\n  slice_lhs 1 2 => rw [â† comp_whiskerRight, coequalizer.Ï€_desc]\n  slice_rhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 3 4 => rw [coequalizer.Ï€_desc]\n  refine (cancel_epi ((tensorRight _ â‹™ tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp\n  slice_lhs 1 2 =>\n    rw [â† comp_whiskerRight, Ï€_tensor_id_preserves_coequalizer_inv_desc, comp_whiskerRight,\n      comp_whiskerRight]\n  slice_lhs 3 5 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  dsimp only [TensorBimod.X]\n  slice_lhs 2 3 => rw [associator_naturality_middle]\n  slice_lhs 5 6 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  slice_lhs 4 5 => rw [â† MonoidalCategory.whiskerLeft_comp, coequalizer.Ï€_desc]\n  slice_lhs 3 4 =>\n    rw [â† MonoidalCategory.whiskerLeft_comp, Ï€_tensor_id_preserves_coequalizer_inv_desc,\n      MonoidalCategory.whiskerLeft_comp, MonoidalCategory.whiskerLeft_comp]\n  slice_rhs 1 2 => rw [associator_naturality_left]\n  slice_rhs 2 3 =>\n    rw [â† whisker_exchange]\n  slice_rhs 3 5 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_rhs 2 3 => rw [associator_naturality_right]\n  monoidal\n\n"}
{"name":"Bimod.triangle_bimod","module":"Mathlib.CategoryTheory.Monoidal.Bimod","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\ninstâœÂ³ : CategoryTheory.MonoidalCategory C\ninstâœÂ² : CategoryTheory.Limits.HasCoequalizers C\ninstâœÂ¹ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorLeft X)\ninstâœ : âˆ€ (X : C), CategoryTheory.Limits.PreservesColimitsOfSize.{0, 0, vâ‚, vâ‚, uâ‚, uâ‚} (CategoryTheory.MonoidalCategory.tensorRight X)\nX Y Z : Mon_ C\nM : Bimod X Y\nN : Bimod Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (M.associatorBimod (Bimod.regular Y) N).hom (M.whiskerLeft N.leftUnitorBimod.hom)) (Bimod.whiskerRight M.rightUnitorBimod.hom N)","decl":"theorem triangle_bimod {X Y Z : Mon_ C} (M : Bimod X Y) (N : Bimod Y Z) :\n    (associatorBimod M (regular Y) N).hom â‰« whiskerLeft M (leftUnitorBimod N).hom =\n      whiskerRight (rightUnitorBimod M).hom N := by\n  dsimp [associatorBimod, leftUnitorBimod, rightUnitorBimod]\n  ext\n  apply coequalizer.hom_ext\n  dsimp\n  dsimp [AssociatorBimod.hom]\n  slice_lhs 1 2 => rw [coequalizer.Ï€_desc]\n  dsimp [AssociatorBimod.homAux]\n  slice_rhs 1 2 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [RightUnitorBimod.hom]\n  refine (cancel_epi ((tensorRight _).map (coequalizer.Ï€ _ _))).1 ?_\n  dsimp [regular]\n  slice_lhs 1 3 => rw [Ï€_tensor_id_preserves_coequalizer_inv_desc]\n  slice_lhs 3 4 => rw [Î¹_colimMap, parallelPairHom_app_one]\n  dsimp [LeftUnitorBimod.hom]\n  slice_lhs 2 3 => rw [â† MonoidalCategory.whiskerLeft_comp, coequalizer.Ï€_desc]\n  slice_rhs 1 2 => rw [â† comp_whiskerRight, coequalizer.Ï€_desc]\n  slice_rhs 1 2 => rw [coequalizer.condition]\n  simp only [Category.assoc]\n\n"}
