{"name":"CategoryTheory.Pretriangulated.instIsHomologicalAddCommGrpObjOppositeFunctorPreadditiveCoyoneda","module":"Mathlib.CategoryTheory.Triangulated.Yoneda","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nA : Opposite C\n⊢ (CategoryTheory.preadditiveCoyoneda.obj A).IsHomological","decl":"instance (A : Cᵒᵖ) : (preadditiveCoyoneda.obj A).IsHomological where\n  exact T hT := by\n    rw [ShortComplex.ab_exact_iff]\n    intro (x₂ : A.unop ⟶ T.obj₂) (hx₂ : x₂ ≫ T.mor₂ = 0)\n    obtain ⟨x₁, hx₁⟩ := T.coyoneda_exact₂ hT x₂ hx₂\n    exact ⟨x₁, hx₁.symm⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.instIsHomologicalOppositeAddCommGrpObjFunctorPreadditiveYoneda","module":"Mathlib.CategoryTheory.Triangulated.Yoneda","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nB : C\n⊢ (CategoryTheory.preadditiveYoneda.obj B).IsHomological","decl":"instance (B : C) : (preadditiveYoneda.obj B).IsHomological where\n  exact T hT := by\n    rw [ShortComplex.ab_exact_iff]\n    intro (x₂ : T.obj₂.unop ⟶ B) (hx₂ : T.mor₂.unop ≫ x₂ = 0)\n    obtain ⟨x₃, hx₃⟩ := Triangle.yoneda_exact₂ _ (unop_distinguished T hT) x₂ hx₂\n    exact ⟨x₃, hx₃.symm⟩\n\n"}
{"name":"CategoryTheory.Pretriangulated.preadditiveYoneda_map_distinguished","module":"Mathlib.CategoryTheory.Triangulated.Yoneda","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_2, u_1} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.HasShift C Int\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nT : CategoryTheory.Pretriangulated.Triangle C\nhT : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T\nB : C\n⊢ ((CategoryTheory.Pretriangulated.shortComplexOfDistTriangle T hT).op.map (CategoryTheory.preadditiveYoneda.obj B)).Exact","decl":"lemma preadditiveYoneda_map_distinguished\n    (T : Triangle C) (hT : T ∈ distTriang C) (B : C) :\n    ((shortComplexOfDistTriangle T hT).op.map (preadditiveYoneda.obj B)).Exact :=\n  (preadditiveYoneda.obj B).map_distinguished_op_exact T hT\n\n"}
{"name":"CategoryTheory.Pretriangulated.preadditiveCoyoneda_homologySequenceδ_apply","module":"Mathlib.CategoryTheory.Triangulated.Yoneda","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.HasShift C Int\nT : CategoryTheory.Pretriangulated.Triangle C\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\nA : Opposite C\nx : Quiver.Hom (Opposite.unop A) ((CategoryTheory.shiftFunctor C n₀).obj T.obj₃)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.preadditiveCoyoneda.obj A).homologySequenceδ T n₀ n₁ h)) x) (CategoryTheory.CategoryStruct.comp x (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C n₀).map T.mor₃) ((CategoryTheory.shiftFunctorAdd' C 1 n₀ n₁ ⋯).inv.app T.obj₁)))","decl":"lemma preadditiveCoyoneda_homologySequenceδ_apply\n    (T : Triangle C) (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) {A : Cᵒᵖ} (x : A.unop ⟶ T.obj₃⟦n₀⟧) :\n    (preadditiveCoyoneda.obj A).homologySequenceδ T n₀ n₁ h x =\n      x ≫ T.mor₃⟦n₀⟧' ≫ (shiftFunctorAdd' C 1 n₀ n₁ (by omega)).inv.app _ := by\n  apply Category.assoc\n\n"}
{"name":"CategoryTheory.Pretriangulated.preadditiveYoneda_shiftMap_apply","module":"Mathlib.CategoryTheory.Triangulated.Yoneda","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.HasShift C Int\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nB : C\nX Y : Opposite C\nn : Int\nf : Quiver.Hom X ((CategoryTheory.shiftFunctor (Opposite C) n).obj Y)\na a' : Int\nh : Eq (HAdd.hAdd n a) a'\nz : Quiver.Hom (Opposite.unop X) ((CategoryTheory.shiftFunctor C a).obj B)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.preadditiveYoneda.obj B).shiftMap f a a' h)) z) (((CategoryTheory.ShiftedHom.opEquiv n).symm f).comp z ⋯)","decl":"lemma preadditiveYoneda_shiftMap_apply (B : C) {X Y : Cᵒᵖ} (n : ℤ) (f : X ⟶ Y⟦n⟧)\n    (a a' : ℤ) (h : n + a = a') (z : X.unop ⟶ B⟦a⟧) :\n    (preadditiveYoneda.obj B).shiftMap f a a' h z =\n      ((ShiftedHom.opEquiv _).symm f).comp z (show a + n = a' by omega) := by\n  symm\n  apply ShiftedHom.opEquiv_symm_apply_comp\n\n"}
{"name":"CategoryTheory.Pretriangulated.preadditiveYoneda_homologySequenceδ_apply","module":"Mathlib.CategoryTheory.Triangulated.Yoneda","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.HasShift C Int\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\nT : CategoryTheory.Pretriangulated.Triangle C\nn₀ n₁ : Int\nh : Eq (HAdd.hAdd n₀ 1) n₁\nB : C\nx : Quiver.Hom T.obj₁ ((CategoryTheory.shiftFunctor C n₀).obj B)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.preadditiveYoneda.obj B).homologySequenceδ ((CategoryTheory.Pretriangulated.triangleOpEquivalence C).functor.obj { unop := T }) n₀ n₁ h)) x) (CategoryTheory.CategoryStruct.comp T.mor₃ (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor C 1).map x) ((CategoryTheory.shiftFunctorAdd' C n₀ 1 n₁ h).inv.app B)))","decl":"lemma preadditiveYoneda_homologySequenceδ_apply\n    (T : Triangle C) (n₀ n₁ : ℤ) (h : n₀ + 1 = n₁) {B : C} (x : T.obj₁ ⟶ B⟦n₀⟧) :\n    (preadditiveYoneda.obj B).homologySequenceδ\n      ((triangleOpEquivalence _).functor.obj (op T)) n₀ n₁ h x =\n      T.mor₃ ≫ x⟦(1 : ℤ)⟧' ≫ (shiftFunctorAdd' C n₀ 1 n₁ h).inv.app B := by\n  simp only [Functor.homologySequenceδ, preadditiveYoneda_shiftMap_apply,\n    ShiftedHom.comp, ← Category.assoc]\n  congr 2\n  apply (ShiftedHom.opEquiv _).injective\n  rw [Equiv.apply_symm_apply]\n  rfl\n\n"}
