{"name":"ZMod.χ₄_apply","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"a : ZMod 4\n⊢ Eq (ZMod.χ₄ a) (ZMod.χ₄.match_1 (fun a => Int) a (fun _ => 0) (fun _ => 0) (fun _ => 1) fun _ => -1)","decl":"/-- Define the nontrivial quadratic character on `ZMod 4`, `χ₄`.\nIt corresponds to the extension `ℚ(√-1)/ℚ`. -/\n@[simps]\ndef χ₄ : MulChar (ZMod 4) ℤ where\n  toFun a :=\n    match a with\n    | 0 | 2 => 0\n    | 1 => 1\n    | 3 => -1\n  map_one' := rfl\n  map_mul' := by decide\n  map_nonunit' := by decide\n\n"}
{"name":"ZMod.isQuadratic_χ₄","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"⊢ ZMod.χ₄.IsQuadratic","decl":"/-- `χ₄` takes values in `{0, 1, -1}` -/\ntheorem isQuadratic_χ₄ : χ₄.IsQuadratic := by\n  unfold MulChar.IsQuadratic\n  decide\n\n"}
{"name":"ZMod.χ₄_nat_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\n⊢ Eq (ZMod.χ₄ ↑n) (ZMod.χ₄ ↑(HMod.hMod n 4))","decl":"/-- The value of `χ₄ n`, for `n : ℕ`, depends only on `n % 4`. -/\ntheorem χ₄_nat_mod_four (n : ℕ) : χ₄ n = χ₄ (n % 4 : ℕ) := by\n  rw [← ZMod.natCast_mod n 4]\n\n"}
{"name":"ZMod.χ₄_int_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\n⊢ Eq (ZMod.χ₄ ↑n) (ZMod.χ₄ ↑(HMod.hMod n 4))","decl":"/-- The value of `χ₄ n`, for `n : ℤ`, depends only on `n % 4`. -/\ntheorem χ₄_int_mod_four (n : ℤ) : χ₄ n = χ₄ (n % 4 : ℤ) := by\n  rw [← ZMod.intCast_mod n 4, Nat.cast_ofNat]\n\n"}
{"name":"ZMod.χ₄_int_eq_if_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\n⊢ Eq (ZMod.χ₄ ↑n) (ite (Eq (HMod.hMod n 2) 0) 0 (ite (Eq (HMod.hMod n 4) 1) 1 (-1)))","decl":"/-- An explicit description of `χ₄` on integers / naturals -/\ntheorem χ₄_int_eq_if_mod_four (n : ℤ) :\n    χ₄ n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1 := by\n  have help : ∀ m : ℤ, 0 ≤ m → m < 4 → χ₄ m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1 := by\n    decide\n  rw [← Int.emod_emod_of_dvd n (by omega : (2 : ℤ) ∣ 4), ← ZMod.intCast_mod n 4]\n  exact help (n % 4) (Int.emod_nonneg n (by omega)) (Int.emod_lt n (by omega))\n\n"}
{"name":"ZMod.χ₄_nat_eq_if_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\n⊢ Eq (ZMod.χ₄ ↑n) (ite (Eq (HMod.hMod n 2) 0) 0 (ite (Eq (HMod.hMod n 4) 1) 1 (-1)))","decl":"theorem χ₄_nat_eq_if_mod_four (n : ℕ) :\n    χ₄ n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1 :=\n  mod_cast χ₄_int_eq_if_mod_four n\n\n"}
{"name":"ZMod.χ₄_eq_neg_one_pow","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\nhn : Eq (HMod.hMod n 2) 1\n⊢ Eq (ZMod.χ₄ ↑n) (HPow.hPow (-1) (HDiv.hDiv n 2))","decl":"/-- Alternative description of `χ₄ n` for odd `n : ℕ` in terms of powers of `-1` -/\ntheorem χ₄_eq_neg_one_pow {n : ℕ} (hn : n % 2 = 1) : χ₄ n = (-1) ^ (n / 2) := by\n  rw [χ₄_nat_eq_if_mod_four]\n  simp only [hn, Nat.one_ne_zero, if_false]\n  nth_rewrite 3 [← Nat.div_add_mod n 4]\n  nth_rewrite 3 [show 4 = 2 * 2 by omega]\n  rw [mul_assoc, add_comm, Nat.add_mul_div_left _ _ zero_lt_two, pow_add, pow_mul,\n    neg_one_sq, one_pow, mul_one]\n  have help : ∀ m : ℕ, m < 4 → m % 2 = 1 → ite (m = 1) (1 : ℤ) (-1) = (-1) ^ (m / 2) := by decide\n  exact help _ (Nat.mod_lt n (by omega)) <| (Nat.mod_mod_of_dvd n (by omega : 2 ∣ 4)).trans hn\n\n"}
{"name":"ZMod.χ₄_nat_one_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\nhn : Eq (HMod.hMod n 4) 1\n⊢ Eq (ZMod.χ₄ ↑n) 1","decl":"/-- If `n % 4 = 1`, then `χ₄ n = 1`. -/\ntheorem χ₄_nat_one_mod_four {n : ℕ} (hn : n % 4 = 1) : χ₄ n = 1 := by\n  rw [χ₄_nat_mod_four, hn]\n  rfl\n\n"}
{"name":"ZMod.χ₄_nat_three_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\nhn : Eq (HMod.hMod n 4) 3\n⊢ Eq (ZMod.χ₄ ↑n) (-1)","decl":"/-- If `n % 4 = 3`, then `χ₄ n = -1`. -/\ntheorem χ₄_nat_three_mod_four {n : ℕ} (hn : n % 4 = 3) : χ₄ n = -1 := by\n  rw [χ₄_nat_mod_four, hn]\n  rfl\n\n"}
{"name":"ZMod.χ₄_int_one_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\nhn : Eq (HMod.hMod n 4) 1\n⊢ Eq (ZMod.χ₄ ↑n) 1","decl":"/-- If `n % 4 = 1`, then `χ₄ n = 1`. -/\ntheorem χ₄_int_one_mod_four {n : ℤ} (hn : n % 4 = 1) : χ₄ n = 1 := by\n  rw [χ₄_int_mod_four, hn]\n  rfl\n\n"}
{"name":"ZMod.χ₄_int_three_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\nhn : Eq (HMod.hMod n 4) 3\n⊢ Eq (ZMod.χ₄ ↑n) (-1)","decl":"/-- If `n % 4 = 3`, then `χ₄ n = -1`. -/\ntheorem χ₄_int_three_mod_four {n : ℤ} (hn : n % 4 = 3) : χ₄ n = -1 := by\n  rw [χ₄_int_mod_four, hn]\n  rfl\n\n"}
{"name":"ZMod.neg_one_pow_div_two_of_one_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\nhn : Eq (HMod.hMod n 4) 1\n⊢ Eq (HPow.hPow (-1) (HDiv.hDiv n 2)) 1","decl":"/-- If `n % 4 = 1`, then `(-1)^(n/2) = 1`. -/\ntheorem neg_one_pow_div_two_of_one_mod_four {n : ℕ} (hn : n % 4 = 1) : (-1 : ℤ) ^ (n / 2) = 1 :=\n  χ₄_eq_neg_one_pow (Nat.odd_of_mod_four_eq_one hn) ▸ χ₄_nat_one_mod_four hn\n\n"}
{"name":"ZMod.neg_one_pow_div_two_of_three_mod_four","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\nhn : Eq (HMod.hMod n 4) 3\n⊢ Eq (HPow.hPow (-1) (HDiv.hDiv n 2)) (-1)","decl":"/-- If `n % 4 = 3`, then `(-1)^(n/2) = -1`. -/\ntheorem neg_one_pow_div_two_of_three_mod_four {n : ℕ} (hn : n % 4 = 3) : (-1 : ℤ) ^ (n / 2) = -1 :=\n  χ₄_eq_neg_one_pow (Nat.odd_of_mod_four_eq_three hn) ▸ χ₄_nat_three_mod_four hn\n\n"}
{"name":"ZMod.χ₈_apply","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"a : ZMod 8\n⊢ Eq (ZMod.χ₈ a) (ZMod.χ₈.match_1 (fun a => Int) a (fun _ => 0) (fun _ => 0) (fun _ => 0) (fun _ => 0) (fun _ => 1) (fun _ => 1) (fun _ => -1) fun _ => -1)","decl":"/-- Define the first primitive quadratic character on `ZMod 8`, `χ₈`.\nIt corresponds to the extension `ℚ(√2)/ℚ`. -/\n@[simps]\ndef χ₈ : MulChar (ZMod 8) ℤ where\n  toFun a :=\n    match a with\n    | 0 | 2 | 4 | 6 => 0\n    | 1 | 7 => 1\n    | 3 | 5 => -1\n  map_one' := rfl\n  map_mul' := by decide\n  map_nonunit' := by decide\n\n"}
{"name":"ZMod.isQuadratic_χ₈","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"⊢ ZMod.χ₈.IsQuadratic","decl":"/-- `χ₈` takes values in `{0, 1, -1}` -/\ntheorem isQuadratic_χ₈ : χ₈.IsQuadratic := by\n  unfold MulChar.IsQuadratic\n  decide\n\n"}
{"name":"ZMod.χ₈_nat_mod_eight","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\n⊢ Eq (ZMod.χ₈ ↑n) (ZMod.χ₈ ↑(HMod.hMod n 8))","decl":"/-- The value of `χ₈ n`, for `n : ℕ`, depends only on `n % 8`. -/\ntheorem χ₈_nat_mod_eight (n : ℕ) : χ₈ n = χ₈ (n % 8 : ℕ) := by\n  rw [← ZMod.natCast_mod n 8]\n\n"}
{"name":"ZMod.χ₈_int_mod_eight","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\n⊢ Eq (ZMod.χ₈ ↑n) (ZMod.χ₈ ↑(HMod.hMod n 8))","decl":"/-- The value of `χ₈ n`, for `n : ℤ`, depends only on `n % 8`. -/\ntheorem χ₈_int_mod_eight (n : ℤ) : χ₈ n = χ₈ (n % 8 : ℤ) := by\n  rw [← ZMod.intCast_mod n 8, Nat.cast_ofNat]\n\n"}
{"name":"ZMod.χ₈_int_eq_if_mod_eight","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\n⊢ Eq (ZMod.χ₈ ↑n) (ite (Eq (HMod.hMod n 2) 0) 0 (ite (Or (Eq (HMod.hMod n 8) 1) (Eq (HMod.hMod n 8) 7)) 1 (-1)))","decl":"/-- An explicit description of `χ₈` on integers / naturals -/\ntheorem χ₈_int_eq_if_mod_eight (n : ℤ) :\n    χ₈ n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 7 then 1 else -1 := by\n  have help :\n    ∀ m : ℤ, 0 ≤ m → m < 8 → χ₈ m = if m % 2 = 0 then 0 else if m = 1 ∨ m = 7 then 1 else -1 := by\n    decide\n  rw [← Int.emod_emod_of_dvd n (by omega : (2 : ℤ) ∣ 8), ← ZMod.intCast_mod n 8]\n  exact help (n % 8) (Int.emod_nonneg n (by omega)) (Int.emod_lt n (by omega))\n\n"}
{"name":"ZMod.χ₈_nat_eq_if_mod_eight","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\n⊢ Eq (ZMod.χ₈ ↑n) (ite (Eq (HMod.hMod n 2) 0) 0 (ite (Or (Eq (HMod.hMod n 8) 1) (Eq (HMod.hMod n 8) 7)) 1 (-1)))","decl":"theorem χ₈_nat_eq_if_mod_eight (n : ℕ) :\n    χ₈ n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 7 then 1 else -1 :=\n  mod_cast χ₈_int_eq_if_mod_eight n\n\n"}
{"name":"ZMod.χ₈'_apply","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"a : ZMod 8\n⊢ Eq (ZMod.χ₈' a) (ZMod.χ₈'.match_1 (fun a => Int) a (fun _ => 0) (fun _ => 0) (fun _ => 0) (fun _ => 0) (fun _ => 1) (fun _ => 1) (fun _ => -1) fun _ => -1)","decl":"/-- Define the second primitive quadratic character on `ZMod 8`, `χ₈'`.\nIt corresponds to the extension `ℚ(√-2)/ℚ`. -/\n@[simps]\ndef χ₈' : MulChar (ZMod 8) ℤ where\n  toFun a :=\n    match a with\n    | 0 | 2 | 4 | 6 => 0\n    | 1 | 3 => 1\n    | 5 | 7 => -1\n  map_one' := rfl\n  map_mul' := by decide\n  map_nonunit' := by decide\n\n"}
{"name":"ZMod.isQuadratic_χ₈'","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"⊢ ZMod.χ₈'.IsQuadratic","decl":"/-- `χ₈'` takes values in `{0, 1, -1}` -/\ntheorem isQuadratic_χ₈' : χ₈'.IsQuadratic := by\n  unfold MulChar.IsQuadratic\n  decide\n\n"}
{"name":"ZMod.χ₈'_int_eq_if_mod_eight","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Int\n⊢ Eq (ZMod.χ₈' ↑n) (ite (Eq (HMod.hMod n 2) 0) 0 (ite (Or (Eq (HMod.hMod n 8) 1) (Eq (HMod.hMod n 8) 3)) 1 (-1)))","decl":"/-- An explicit description of `χ₈'` on integers / naturals -/\ntheorem χ₈'_int_eq_if_mod_eight (n : ℤ) :\n    χ₈' n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 3 then 1 else -1 := by\n  have help :\n    ∀ m : ℤ, 0 ≤ m → m < 8 → χ₈' m = if m % 2 = 0 then 0 else if m = 1 ∨ m = 3 then 1 else -1 := by\n    decide\n  rw [← Int.emod_emod_of_dvd n (by omega : (2 : ℤ) ∣ 8), ← ZMod.intCast_mod n 8]\n  exact help (n % 8) (Int.emod_nonneg n (by omega)) (Int.emod_lt n (by omega))\n\n"}
{"name":"ZMod.χ₈'_nat_eq_if_mod_eight","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"n : Nat\n⊢ Eq (ZMod.χ₈' ↑n) (ite (Eq (HMod.hMod n 2) 0) 0 (ite (Or (Eq (HMod.hMod n 8) 1) (Eq (HMod.hMod n 8) 3)) 1 (-1)))","decl":"theorem χ₈'_nat_eq_if_mod_eight (n : ℕ) :\n    χ₈' n = if n % 2 = 0 then 0 else if n % 8 = 1 ∨ n % 8 = 3 then 1 else -1 :=\n  mod_cast χ₈'_int_eq_if_mod_eight n\n\n"}
{"name":"ZMod.χ₈'_eq_χ₄_mul_χ₈","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"a : ZMod 8\n⊢ Eq (ZMod.χ₈' a) (HMul.hMul (ZMod.χ₄ a.cast) (ZMod.χ₈ a))","decl":"/-- The relation between `χ₄`, `χ₈` and `χ₈'` -/\ntheorem χ₈'_eq_χ₄_mul_χ₈ : ∀ a : ZMod 8, χ₈' a = χ₄ (cast a) * χ₈ a := by\n  decide\n\n"}
{"name":"ZMod.χ₈'_int_eq_χ₄_mul_χ₈","module":"Mathlib.NumberTheory.LegendreSymbol.ZModChar","initialProofState":"a : Int\n⊢ Eq (ZMod.χ₈' ↑a) (HMul.hMul (ZMod.χ₄ ↑a) (ZMod.χ₈ ↑a))","decl":"theorem χ₈'_int_eq_χ₄_mul_χ₈ (a : ℤ) : χ₈' a = χ₄ a * χ₈ a := by\n  rw [← @cast_intCast 8 (ZMod 4) _ 4 _ (by omega) a]\n  exact χ₈'_eq_χ₄_mul_χ₈ a\n\n"}
