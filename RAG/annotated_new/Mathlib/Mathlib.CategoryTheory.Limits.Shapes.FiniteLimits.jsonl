{"name":"CategoryTheory.Limits.HasFiniteLimits.out","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasFiniteLimits C\nJ : Type\n𝒥 : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"/-- A category has all finite limits if every functor `J ⥤ C` with a `FinCategory J`\ninstance and `J : Type` has a limit.\n\nThis is often called 'finitely complete'.\n-/\nclass HasFiniteLimits : Prop where\n  /-- `C` has all limits over any type `J` whose objects and morphisms lie in the same universe\n  and which has `FinType` objects and morphisms -/\n  out (J : Type) [𝒥 : SmallCategory J] [@FinCategory J 𝒥] : @HasLimitsOfShape J 𝒥 C _\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_of_hasFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : CategoryTheory.SmallCategory J\ninst✝¹ : CategoryTheory.FinCategory J\ninst✝ : CategoryTheory.Limits.HasFiniteLimits C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J C","decl":"instance (priority := 100) hasLimitsOfShape_of_hasFiniteLimits (J : Type w) [SmallCategory J]\n    [FinCategory J] [HasFiniteLimits C] : HasLimitsOfShape J C := by\n  apply @hasLimitsOfShape_of_equivalence _ _ _ _ _ _ (FinCategory.equivAsType J) ?_\n  apply HasFiniteLimits.out\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v', u', v, u} C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"lemma hasFiniteLimits_of_hasLimitsOfSize [HasLimitsOfSize.{v', u'} C] :\n    HasFiniteLimits C where\n  out := fun J hJ hJ' =>\n    haveI := hasLimitsOfSizeShrink.{0, 0} C\n    let F := @FinCategory.equivAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ'\n    @hasLimitsOfShape_of_equivalence (@FinCategory.AsType J (@FinCategory.fintypeObj J hJ hJ'))\n    (@FinCategory.categoryAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ') _ _ J hJ F _\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"/-- If `C` has all limits, it has finite limits. -/\ninstance (priority := 100) hasFiniteLimits_of_hasLimits [HasLimits C] : HasFiniteLimits C :=\n  hasFiniteLimits_of_hasLimitsOfSize C\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasLimitsOfSize₀","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{0, 0, v, u} C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"instance (priority := 90) hasFiniteLimits_of_hasLimitsOfSize₀ [HasLimitsOfSize.{0, 0} C] :\n    HasFiniteLimits C :=\n  hasFiniteLimits_of_hasLimitsOfSize C\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteLimits_of_hasFiniteLimits_of_size","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nh : ∀ (J : Type w) {𝒥 : CategoryTheory.SmallCategory J}, CategoryTheory.FinCategory J → CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"/-- We can always derive `HasFiniteLimits C` by providing limits at an\narbitrary universe. -/\ntheorem hasFiniteLimits_of_hasFiniteLimits_of_size\n    (h : ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasLimitsOfShape J C) :\n    HasFiniteLimits C where\n  out := fun J hJ hhJ => by\n    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ\n    have l : @Equivalence J (ULiftHom (ULift J)) hJ\n                          (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=\n      @ULiftHomULiftCategory.equiv J hJ\n    apply @hasLimitsOfShape_of_equivalence (ULiftHom (ULift J))\n      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ\n      (@Equivalence.symm J hJ (ULiftHom (ULift J))\n      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _\n    /- Porting note: tried to factor out (@instCategoryULiftHom (ULift J) (@uliftCategory J hJ)\n    but when doing that would then find the instance and say it was not definitionally equal to\n    the provided one (the same thing factored out) -/\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteColimits.out","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasFiniteColimits C\nJ : Type\n𝒥 : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.FinCategory J\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"/-- A category has all finite colimits if every functor `J ⥤ C` with a `FinCategory J`\ninstance and `J : Type` has a colimit.\n\nThis is often called 'finitely cocomplete'.\n-/\nclass HasFiniteColimits : Prop where\n  /-- `C` has all colimits over any type `J` whose objects and morphisms lie in the same universe\n  and which has `Fintype` objects and morphisms -/\n  out (J : Type) [𝒥 : SmallCategory J] [@FinCategory J 𝒥] : @HasColimitsOfShape J 𝒥 C _\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_of_hasFiniteColimits","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : CategoryTheory.SmallCategory J\ninst✝¹ : CategoryTheory.FinCategory J\ninst✝ : CategoryTheory.Limits.HasFiniteColimits C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J C","decl":"instance (priority := 100) hasColimitsOfShape_of_hasFiniteColimits (J : Type w) [SmallCategory J]\n    [FinCategory J] [HasFiniteColimits C] : HasColimitsOfShape J C := by\n  refine @hasColimitsOfShape_of_equivalence _ _ _ _ _ _ (FinCategory.equivAsType J) ?_\n  apply HasFiniteColimits.out\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v', u', v, u} C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"lemma hasFiniteColimits_of_hasColimitsOfSize [HasColimitsOfSize.{v', u'} C] :\n    HasFiniteColimits C where\n  out := fun J hJ hJ' =>\n    haveI := hasColimitsOfSizeShrink.{0, 0} C\n    let F := @FinCategory.equivAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ'\n    @hasColimitsOfShape_of_equivalence (@FinCategory.AsType J (@FinCategory.fintypeObj J hJ hJ'))\n    (@FinCategory.categoryAsType J (@FinCategory.fintypeObj J hJ hJ') hJ hJ') _ _ J hJ F _\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasColimits","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"instance (priority := 100) hasFiniteColimits_of_hasColimits [HasColimits C] : HasFiniteColimits C :=\n  hasFiniteColimits_of_hasColimitsOfSize C\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasColimitsOfSize₀","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{0, 0, v, u} C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"instance (priority := 90) hasFiniteColimits_of_hasColimitsOfSize₀ [HasColimitsOfSize.{0, 0} C] :\n    HasFiniteColimits C :=\n  hasFiniteColimits_of_hasColimitsOfSize C\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteColimits_of_hasFiniteColimits_of_size","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nh : ∀ (J : Type w) {𝒥 : CategoryTheory.SmallCategory J}, CategoryTheory.FinCategory J → CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"/-- We can always derive `HasFiniteColimits C` by providing colimits at an\narbitrary universe. -/\ntheorem hasFiniteColimits_of_hasFiniteColimits_of_size\n    (h : ∀ (J : Type w) {𝒥 : SmallCategory J} (_ : @FinCategory J 𝒥), HasColimitsOfShape J C) :\n    HasFiniteColimits C where\n  out := fun J hJ hhJ => by\n    haveI := h (ULiftHom.{w} (ULift.{w} J)) <| @CategoryTheory.finCategoryUlift J hJ hhJ\n    have l : @Equivalence J (ULiftHom (ULift J)) hJ\n                           (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) :=\n      @ULiftHomULiftCategory.equiv J hJ\n    apply @hasColimitsOfShape_of_equivalence (ULiftHom (ULift J))\n      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) C _ J hJ\n      (@Equivalence.symm J hJ (ULiftHom (ULift J))\n      (@ULiftHom.category (ULift J) (@uliftCategory J hJ)) l) _\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteWidePullbacks.out","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasFiniteWidePullbacks C\nJ : Type\ninst✝ : Finite J\n⊢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C","decl":"/-- `HasFiniteWidePullbacks` represents a choice of wide pullback\nfor every finite collection of morphisms\n-/\nclass HasFiniteWidePullbacks : Prop where\n  /-- `C` has all wide pullbacks any Fintype `J`-/\n  out (J : Type) [Finite J] : HasLimitsOfShape (WidePullbackShape J) C\n\n"}
{"name":"CategoryTheory.Limits.hasLimitsOfShape_widePullbackShape","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type\ninst✝¹ : Finite J\ninst✝ : CategoryTheory.Limits.HasFiniteWidePullbacks C\n⊢ CategoryTheory.Limits.HasLimitsOfShape (CategoryTheory.Limits.WidePullbackShape J) C","decl":"instance hasLimitsOfShape_widePullbackShape (J : Type) [Finite J] [HasFiniteWidePullbacks C] :\n    HasLimitsOfShape (WidePullbackShape J) C := by\n  haveI := @HasFiniteWidePullbacks.out C _ _ J\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.HasFiniteWidePushouts.out","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Limits.HasFiniteWidePushouts C\nJ : Type\ninst✝ : Finite J\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Limits.WidePushoutShape J) C","decl":"/-- `HasFiniteWidePushouts` represents a choice of wide pushout\nfor every finite collection of morphisms\n-/\nclass HasFiniteWidePushouts : Prop where\n  /-- `C` has all wide pushouts any Fintype `J`-/\n  out (J : Type) [Finite J] : HasColimitsOfShape (WidePushoutShape J) C\n\n"}
{"name":"CategoryTheory.Limits.hasColimitsOfShape_widePushoutShape","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type\ninst✝¹ : Finite J\ninst✝ : CategoryTheory.Limits.HasFiniteWidePushouts C\n⊢ CategoryTheory.Limits.HasColimitsOfShape (CategoryTheory.Limits.WidePushoutShape J) C","decl":"instance hasColimitsOfShape_widePushoutShape (J : Type) [Finite J] [HasFiniteWidePushouts C] :\n    HasColimitsOfShape (WidePushoutShape J) C := by\n  haveI := @HasFiniteWidePushouts.out C _ _ J\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteWidePullbacks_of_hasFiniteLimits","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteLimits C\n⊢ CategoryTheory.Limits.HasFiniteWidePullbacks C","decl":"/-- Finite wide pullbacks are finite limits, so if `C` has all finite limits,\nit also has finite wide pullbacks\n-/\ninstance (priority := 900) hasFiniteWidePullbacks_of_hasFiniteLimits [HasFiniteLimits C] :\n    HasFiniteWidePullbacks C :=\n  ⟨fun J _ => by cases nonempty_fintype J; exact HasFiniteLimits.out _⟩\n\n"}
{"name":"CategoryTheory.Limits.hasFiniteWidePushouts_of_has_finite_limits","module":"Mathlib.CategoryTheory.Limits.Shapes.FiniteLimits","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasFiniteColimits C\n⊢ CategoryTheory.Limits.HasFiniteWidePushouts C","decl":"/-- Finite wide pushouts are finite colimits, so if `C` has all finite colimits,\nit also has finite wide pushouts\n-/\ninstance (priority := 900) hasFiniteWidePushouts_of_has_finite_limits [HasFiniteColimits C] :\n    HasFiniteWidePushouts C :=\n  ⟨fun J _ => by cases nonempty_fintype J; exact HasFiniteColimits.out _⟩\n\n"}
