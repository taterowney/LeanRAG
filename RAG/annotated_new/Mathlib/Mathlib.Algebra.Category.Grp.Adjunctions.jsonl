{"name":"AddCommGrp.free_obj_coe","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"α : Type u\n⊢ Eq (↑(AddCommGrp.free.obj α)) (FreeAbelianGroup α)","decl":"@[simp]\ntheorem free_obj_coe {α : Type u} : (free.obj α : Type u) = FreeAbelianGroup α :=\n  rfl\n\n-- This currently can't be a `simp` lemma,\n-- because `free_obj_coe` will simplify implicit arguments in the LHS.\n-- (The `simpNF` linter will, correctly, complain.)\n"}
{"name":"AddCommGrp.free_map_coe","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"α β : Type u\nf : α → β\nx : FreeAbelianGroup α\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (AddCommGrp.free.map f)) x) (Functor.map f x)","decl":"theorem free_map_coe {α β : Type u} {f : α → β} (x : FreeAbelianGroup α) :\n    (free.map f) x = f <$> x :=\n  rfl\n\n"}
{"name":"AddCommGrp.instIsLeftAdjointFree","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ AddCommGrp.free.IsLeftAdjoint","decl":"instance : free.{u}.IsLeftAdjoint :=\n  ⟨_, ⟨adj⟩⟩\n\n"}
{"name":"AddCommGrp.instIsRightAdjointForget","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ (CategoryTheory.forget AddCommGrp).IsRightAdjoint","decl":"instance : (forget AddCommGrp.{u}).IsRightAdjoint :=\n  ⟨_, ⟨adj⟩⟩\n\n"}
{"name":"AddCommGrp.instIsLeftAdjointFree_1","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ AddCommGrp.free.IsLeftAdjoint","decl":"instance : AddCommGrp.free.{u}.IsLeftAdjoint :=\n  ⟨_, ⟨adj⟩⟩\n\n"}
{"name":"AddCommGrp.instPreservesMonomorphismsFree","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ AddCommGrp.free.PreservesMonomorphisms","decl":"instance : (free.{u}).PreservesMonomorphisms where\n  preserves {X Y} f _ := by\n    by_cases hX : IsEmpty X\n    · constructor\n      intros\n      apply (IsInitial.isInitialObj free _\n        ((Types.initial_iff_empty X).2 hX).some).isZero.eq_of_tgt\n    · simp only [not_isEmpty_iff] at hX\n      have hf : Function.Injective f := by rwa [← mono_iff_injective]\n      obtain ⟨g, hg⟩ := hf.hasLeftInverse\n      have : IsSplitMono f := IsSplitMono.mk' { retraction := g }\n      infer_instance\n\n"}
{"name":"Grp.instIsRightAdjointForget","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ (CategoryTheory.forget Grp).IsRightAdjoint","decl":"instance : (forget Grp.{u}).IsRightAdjoint  :=\n  ⟨_, ⟨adj⟩⟩\n\n"}
{"name":"MonCat.val_inv_units_map_hom_apply","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"X✝ Y✝ : MonCat\nf : Quiver.Hom X✝ Y✝\nu : Units ↑X✝\n⊢ Eq (↑(Inv.inv ((Grp.Hom.hom (MonCat.units.map f)) u))) ((MonCat.Hom.hom f) ↑(Inv.inv u))","decl":"/-- The functor taking a monoid to its subgroup of units. -/\n@[simps!]\ndef MonCat.units : MonCat.{u} ⥤ Grp.{u} where\n  obj R := Grp.of Rˣ\n  map f := Grp.ofHom <| Units.map f.hom\n  map_id _ := Grp.ext fun _ => Units.ext rfl\n  map_comp _ _ := Grp.ext fun _ => Units.ext rfl\n\n"}
{"name":"MonCat.val_units_map_hom_apply","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"X✝ Y✝ : MonCat\nf : Quiver.Hom X✝ Y✝\nu : Units ↑X✝\n⊢ Eq (↑((Grp.Hom.hom (MonCat.units.map f)) u)) ((MonCat.Hom.hom f) ↑u)","decl":"/-- The functor taking a monoid to its subgroup of units. -/\n@[simps!]\ndef MonCat.units : MonCat.{u} ⥤ Grp.{u} where\n  obj R := Grp.of Rˣ\n  map f := Grp.ofHom <| Units.map f.hom\n  map_id _ := Grp.ext fun _ => Units.ext rfl\n  map_comp _ _ := Grp.ext fun _ => Units.ext rfl\n\n"}
{"name":"MonCat.units_obj_coe","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"R : MonCat\n⊢ Eq (↑(MonCat.units.obj R)) (Units ↑R)","decl":"/-- The functor taking a monoid to its subgroup of units. -/\n@[simps!]\ndef MonCat.units : MonCat.{u} ⥤ Grp.{u} where\n  obj R := Grp.of Rˣ\n  map f := Grp.ofHom <| Units.map f.hom\n  map_id _ := Grp.ext fun _ => Units.ext rfl\n  map_comp _ _ := Grp.ext fun _ => Units.ext rfl\n\n"}
{"name":"instIsRightAdjointGrpMonCatUnits","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ MonCat.units.IsRightAdjoint","decl":"instance : MonCat.units.{u}.IsRightAdjoint :=\n  ⟨_, ⟨Grp.forget₂MonAdj⟩⟩\n\n"}
{"name":"CommMonCat.val_units_map_hom_apply","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"X✝ Y✝ : CommMonCat\nf : Quiver.Hom X✝ Y✝\nu : Units ↑X✝\n⊢ Eq (↑((CommGrp.Hom.hom (CommMonCat.units.map f)) u)) ((CommMonCat.Hom.hom f) ↑u)","decl":"/-- The functor taking a monoid to its subgroup of units. -/\n@[simps!]\ndef CommMonCat.units : CommMonCat.{u} ⥤ CommGrp.{u} where\n  obj R := CommGrp.of Rˣ\n  map f := CommGrp.ofHom <| Units.map f.hom\n  map_id _ := CommGrp.ext fun _ => Units.ext rfl\n  map_comp _ _ := CommGrp.ext fun _ => Units.ext rfl\n\n"}
{"name":"CommMonCat.val_inv_units_map_hom_apply","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"X✝ Y✝ : CommMonCat\nf : Quiver.Hom X✝ Y✝\nu : Units ↑X✝\n⊢ Eq (↑(Inv.inv ((CommGrp.Hom.hom (CommMonCat.units.map f)) u))) ((CommMonCat.Hom.hom f) ↑(Inv.inv u))","decl":"/-- The functor taking a monoid to its subgroup of units. -/\n@[simps!]\ndef CommMonCat.units : CommMonCat.{u} ⥤ CommGrp.{u} where\n  obj R := CommGrp.of Rˣ\n  map f := CommGrp.ofHom <| Units.map f.hom\n  map_id _ := CommGrp.ext fun _ => Units.ext rfl\n  map_comp _ _ := CommGrp.ext fun _ => Units.ext rfl\n\n"}
{"name":"CommMonCat.units_obj_coe","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"R : CommMonCat\n⊢ Eq (↑(CommMonCat.units.obj R)) (Units ↑R)","decl":"/-- The functor taking a monoid to its subgroup of units. -/\n@[simps!]\ndef CommMonCat.units : CommMonCat.{u} ⥤ CommGrp.{u} where\n  obj R := CommGrp.of Rˣ\n  map f := CommGrp.ofHom <| Units.map f.hom\n  map_id _ := CommGrp.ext fun _ => Units.ext rfl\n  map_comp _ _ := CommGrp.ext fun _ => Units.ext rfl\n\n"}
{"name":"instIsRightAdjointCommGrpCommMonCatUnits","module":"Mathlib.Algebra.Category.Grp.Adjunctions","initialProofState":"⊢ CommMonCat.units.IsRightAdjoint","decl":"instance : CommMonCat.units.{u}.IsRightAdjoint :=\n  ⟨_, ⟨CommGrp.forget₂CommMonAdj⟩⟩\n"}
