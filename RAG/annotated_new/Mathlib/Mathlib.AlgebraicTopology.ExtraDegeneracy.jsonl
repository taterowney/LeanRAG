{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s₀_comp_δ₁","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s 0) (X.left.δ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) self.s')","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.ext_iff","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nx y : SimplicialObject.Augmented.ExtraDegeneracy X\n⊢ Iff (Eq x y) (And (Eq x.s' y.s') (Eq x.s y.s))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.ext","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nx y : SimplicialObject.Augmented.ExtraDegeneracy X\ns' : Eq x.s' y.s'\ns : Eq x.s y.s\n⊢ Eq x y","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.mk.injEq","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\ns'✝ : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns✝ : (n : Nat) → Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_ε✝ : Eq (CategoryTheory.CategoryStruct.comp s'✝ (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\ns₀_comp_δ₁✝ : Eq (CategoryTheory.CategoryStruct.comp (s✝ 0) (X.left.δ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s'✝)\ns_comp_δ₀✝ : ∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s✝ n) (X.left.δ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_δ✝ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s✝ (HAdd.hAdd n 1)) (X.left.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (s✝ n))\ns_comp_σ✝ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s✝ n) (X.left.σ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (s✝ (HAdd.hAdd n 1)))\ns' : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns : (n : Nat) → Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_ε : Eq (CategoryTheory.CategoryStruct.comp s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\ns₀_comp_δ₁ : Eq (CategoryTheory.CategoryStruct.comp (s 0) (X.left.δ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s')\ns_comp_δ₀ : ∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.δ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_δ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s (HAdd.hAdd n 1)) (X.left.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (s n))\ns_comp_σ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.σ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (s (HAdd.hAdd n 1)))\n⊢ Eq (Eq { s' := s'✝, s := s✝, s'_comp_ε := s'_comp_ε✝, s₀_comp_δ₁ := s₀_comp_δ₁✝, s_comp_δ₀ := s_comp_δ₀✝, s_comp_δ := s_comp_δ✝, s_comp_σ := s_comp_σ✝ } { s' := s', s := s, s'_comp_ε := s'_comp_ε, s₀_comp_δ₁ := s₀_comp_δ₁, s_comp_δ₀ := s_comp_δ₀, s_comp_δ := s_comp_δ, s_comp_σ := s_comp_σ }) (And (Eq s'✝ s') (Eq s✝ s))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.mk.inj","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\ns'✝ : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns✝ : (n : Nat) → Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_ε✝ : Eq (CategoryTheory.CategoryStruct.comp s'✝ (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\ns₀_comp_δ₁✝ : Eq (CategoryTheory.CategoryStruct.comp (s✝ 0) (X.left.δ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s'✝)\ns_comp_δ₀✝ : ∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s✝ n) (X.left.δ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_δ✝ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s✝ (HAdd.hAdd n 1)) (X.left.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (s✝ n))\ns_comp_σ✝ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s✝ n) (X.left.σ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (s✝ (HAdd.hAdd n 1)))\ns' : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns : (n : Nat) → Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_ε : Eq (CategoryTheory.CategoryStruct.comp s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\ns₀_comp_δ₁ : Eq (CategoryTheory.CategoryStruct.comp (s 0) (X.left.δ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s')\ns_comp_δ₀ : ∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.δ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_δ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s (HAdd.hAdd n 1)) (X.left.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (s n))\ns_comp_σ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.σ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (s (HAdd.hAdd n 1)))\nx✝ : Eq { s' := s'✝, s := s✝, s'_comp_ε := s'_comp_ε✝, s₀_comp_δ₁ := s₀_comp_δ₁✝, s_comp_δ₀ := s_comp_δ₀✝, s_comp_δ := s_comp_δ✝, s_comp_σ := s_comp_σ✝ } { s' := s', s := s, s'_comp_ε := s'_comp_ε, s₀_comp_δ₁ := s₀_comp_δ₁, s_comp_δ₀ := s_comp_δ₀, s_comp_δ := s_comp_δ, s_comp_σ := s_comp_σ }\n⊢ And (Eq s'✝ s') (Eq s✝ s)","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_δ₀","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (X.left.δ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_σ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (X.left.σ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (self.s (HAdd.hAdd n 1)))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_δ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s (HAdd.hAdd n 1)) (X.left.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (self.s n))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\ninst✝ : SizeOf C\ns' : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns : (n : Nat) → Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_ε : Eq (CategoryTheory.CategoryStruct.comp s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\ns₀_comp_δ₁ : Eq (CategoryTheory.CategoryStruct.comp (s 0) (X.left.δ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s')\ns_comp_δ₀ : ∀ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.δ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_δ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s (HAdd.hAdd n 1)) (X.left.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (s n))\ns_comp_σ : ∀ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.σ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (s (HAdd.hAdd n 1)))\n⊢ Eq (SizeOf.sizeOf { s' := s', s := s, s'_comp_ε := s'_comp_ε, s₀_comp_δ₁ := s₀_comp_δ₁, s_comp_δ₀ := s_comp_δ₀, s_comp_δ := s_comp_δ, s_comp_σ := s_comp_σ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf s')) (SizeOf.sizeOf s'_comp_ε)) (SizeOf.sizeOf s₀_comp_δ₁))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s'_comp_ε","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `σ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X ⟶ drop.obj X _[0]\n  s : ∀ n : ℕ, drop.obj X _[n] ⟶ drop.obj X _[n + 1]\n  s'_comp_ε : s' ≫ X.hom.app (op [0]) = 𝟙 _\n  s₀_comp_δ₁ : s 0 ≫ X.left.δ 1 = X.hom.app (op [0]) ≫ s'\n  s_comp_δ₀ : ∀ n : ℕ, s n ≫ X.left.δ 0 = 𝟙 _\n  s_comp_δ :\n    ∀ (n : ℕ) (i : Fin (n + 2)), s (n + 1) ≫ X.left.δ i.succ = X.left.δ i ≫ s n\n  s_comp_σ :\n    ∀ (n : ℕ) (i : Fin (n + 1)), s n ≫ X.left.σ i.succ = X.left.σ i ≫ s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_σ_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (CategoryTheory.CategoryStruct.comp (X.left.σ i.succ) h)) (CategoryTheory.CategoryStruct.comp (X.left.σ i) (CategoryTheory.CategoryStruct.comp (self.s (HAdd.hAdd n 1)) h))","decl":"attribute [reassoc] s₀_comp_δ₁ s_comp_δ s_comp_σ\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s₀_comp_δ₁_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk 0 }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s 0) (CategoryTheory.CategoryStruct.comp (X.left.δ 1) h)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.CategoryStruct.comp self.s' h))","decl":"attribute [reassoc] s₀_comp_δ₁ s_comp_δ s_comp_σ\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_δ_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s (HAdd.hAdd n 1)) (CategoryTheory.CategoryStruct.comp (X.left.δ i.succ) h)) (CategoryTheory.CategoryStruct.comp (X.left.δ i) (CategoryTheory.CategoryStruct.comp (self.s n) h))","decl":"attribute [reassoc] s₀_comp_δ₁ s_comp_δ s_comp_σ\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_δ₀_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (CategoryTheory.CategoryStruct.comp (X.left.δ 0) h)) h","decl":"attribute [reassoc (attr := simp)] s'_comp_ε s_comp_δ₀\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s'_comp_ε_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nZ : C\nh : Quiver.Hom (((CategoryTheory.SimplicialObject.const C).obj X.right).obj { unop := SimplexCategory.mk 0 }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.s' (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) h)) h","decl":"attribute [reassoc (attr := simp)] s'_comp_ε s_comp_δ₀\n\n"}
{"name":"SSet.Augmented.StandardSimplex.shiftFun_0","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"n : Nat\nX : Type u_1\ninst✝ : Zero X\nf : Fin n → X\n⊢ Eq (SSet.Augmented.StandardSimplex.shiftFun f 0) 0","decl":"@[simp]\ntheorem shiftFun_0 {n : ℕ} {X : Type*} [Zero X] (f : Fin n → X) : shiftFun f 0 = 0 :=\n  rfl\n\n"}
{"name":"SSet.Augmented.StandardSimplex.shiftFun_succ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"n : Nat\nX : Type u_1\ninst✝ : Zero X\nf : Fin n → X\ni : Fin n\n⊢ Eq (SSet.Augmented.StandardSimplex.shiftFun f i.succ) (f i)","decl":"@[simp]\ntheorem shiftFun_succ {n : ℕ} {X : Type*} [Zero X] (f : Fin n → X) (i : Fin n) :\n    shiftFun f i.succ = f i := by\n  dsimp [shiftFun]\n  split_ifs with h\n  · exfalso\n    simp only [Fin.ext_iff, Fin.val_succ, Fin.val_zero, add_eq_zero, and_false, reduceCtorEq] at h\n  · simp only [Fin.pred_succ]\n\n"}
{"name":"SSet.Augmented.StandardSimplex.nonempty_extraDegeneracy_stdSimplex","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"Δ : SimplexCategory\n⊢ Nonempty (SimplicialObject.Augmented.ExtraDegeneracy (SSet.Augmented.stdSimplex.obj Δ))","decl":"instance nonempty_extraDegeneracy_stdSimplex (Δ : SimplexCategory) :\n    Nonempty (SimplicialObject.Augmented.ExtraDegeneracy (stdSimplex.obj Δ)) :=\n  ⟨StandardSimplex.extraDegeneracy Δ⟩\n\n"}
{"name":"CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_π_0","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nS : CategoryTheory.SplitEpi f.hom\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s f S n) (CategoryTheory.Limits.WidePullback.π (fun x => f.hom) 0)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base fun x => f.hom) S.section_)","decl":"theorem ExtraDegeneracy.s_comp_π_0 (n : ℕ) :\n    ExtraDegeneracy.s f S n ≫ WidePullback.π _ 0 =\n      @WidePullback.base _ _ _ f.right (fun _ : Fin (n + 1) => f.left) (fun _ => f.hom) _ ≫\n        S.section_ := by\n  dsimp [ExtraDegeneracy.s]\n  simp only [WidePullback.lift_π]\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed as the linter complains the LHS is not in normal form\n"}
{"name":"CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_π_succ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nS : CategoryTheory.SplitEpi f.hom\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s f S n) (CategoryTheory.Limits.WidePullback.π (fun x => f.hom) i.succ)) (CategoryTheory.Limits.WidePullback.π (fun x => f.hom) i)","decl":"theorem ExtraDegeneracy.s_comp_π_succ (n : ℕ) (i : Fin (n + 1)) :\n    ExtraDegeneracy.s f S n ≫ WidePullback.π _ i.succ =\n      @WidePullback.π _ _ _ f.right (fun _ : Fin (n + 1) => f.left) (fun _ => f.hom) _ i := by\n  dsimp [ExtraDegeneracy.s]\n  simp only [WidePullback.lift_π]\n  split_ifs with h\n  · simp only [Fin.ext_iff, Fin.val_succ, Fin.val_zero, add_eq_zero, and_false, reduceCtorEq] at h\n  · simp only [Fin.pred_succ]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed as the linter complains the LHS is not in normal form\n"}
{"name":"CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_base","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nf : CategoryTheory.Arrow C\ninst✝ : ∀ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nS : CategoryTheory.SplitEpi f.hom\nn : Nat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s f S n) (CategoryTheory.Limits.WidePullback.base fun x => f.hom)) (CategoryTheory.Limits.WidePullback.base fun x => f.hom)","decl":"theorem ExtraDegeneracy.s_comp_base (n : ℕ) :\n    ExtraDegeneracy.s f S n ≫ WidePullback.base _ = WidePullback.base _ := by\n  apply WidePullback.lift_base\n\n"}
