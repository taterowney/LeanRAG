{"name":"SimplicialObject.Augmented.ExtraDegeneracy.sâ‚€_comp_Î´â‚","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s 0) (X.left.Î´ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) self.s')","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.ext_iff","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nx y : SimplicialObject.Augmented.ExtraDegeneracy X\nâŠ¢ Iff (Eq x y) (And (Eq x.s' y.s') (Eq x.s y.s))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.ext","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nx y : SimplicialObject.Augmented.ExtraDegeneracy X\ns' : Eq x.s' y.s'\ns : Eq x.s y.s\nâŠ¢ Eq x y","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.mk.injEq","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\ns'âœ : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\nsâœ : (n : Nat) â†’ Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_Îµâœ : Eq (CategoryTheory.CategoryStruct.comp s'âœ (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\nsâ‚€_comp_Î´â‚âœ : Eq (CategoryTheory.CategoryStruct.comp (sâœ 0) (X.left.Î´ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s'âœ)\ns_comp_Î´â‚€âœ : âˆ€ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (sâœ n) (X.left.Î´ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_Î´âœ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (sâœ (HAdd.hAdd n 1)) (X.left.Î´ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (sâœ n))\ns_comp_Ïƒâœ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (sâœ n) (X.left.Ïƒ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (sâœ (HAdd.hAdd n 1)))\ns' : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns : (n : Nat) â†’ Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_Îµ : Eq (CategoryTheory.CategoryStruct.comp s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\nsâ‚€_comp_Î´â‚ : Eq (CategoryTheory.CategoryStruct.comp (s 0) (X.left.Î´ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s')\ns_comp_Î´â‚€ : âˆ€ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.Î´ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_Î´ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s (HAdd.hAdd n 1)) (X.left.Î´ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (s n))\ns_comp_Ïƒ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.Ïƒ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (s (HAdd.hAdd n 1)))\nâŠ¢ Eq (Eq { s' := s'âœ, s := sâœ, s'_comp_Îµ := s'_comp_Îµâœ, sâ‚€_comp_Î´â‚ := sâ‚€_comp_Î´â‚âœ, s_comp_Î´â‚€ := s_comp_Î´â‚€âœ, s_comp_Î´ := s_comp_Î´âœ, s_comp_Ïƒ := s_comp_Ïƒâœ } { s' := s', s := s, s'_comp_Îµ := s'_comp_Îµ, sâ‚€_comp_Î´â‚ := sâ‚€_comp_Î´â‚, s_comp_Î´â‚€ := s_comp_Î´â‚€, s_comp_Î´ := s_comp_Î´, s_comp_Ïƒ := s_comp_Ïƒ }) (And (Eq s'âœ s') (Eq sâœ s))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.mk.inj","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\ns'âœ : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\nsâœ : (n : Nat) â†’ Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_Îµâœ : Eq (CategoryTheory.CategoryStruct.comp s'âœ (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\nsâ‚€_comp_Î´â‚âœ : Eq (CategoryTheory.CategoryStruct.comp (sâœ 0) (X.left.Î´ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s'âœ)\ns_comp_Î´â‚€âœ : âˆ€ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (sâœ n) (X.left.Î´ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_Î´âœ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (sâœ (HAdd.hAdd n 1)) (X.left.Î´ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (sâœ n))\ns_comp_Ïƒâœ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (sâœ n) (X.left.Ïƒ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (sâœ (HAdd.hAdd n 1)))\ns' : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns : (n : Nat) â†’ Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_Îµ : Eq (CategoryTheory.CategoryStruct.comp s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\nsâ‚€_comp_Î´â‚ : Eq (CategoryTheory.CategoryStruct.comp (s 0) (X.left.Î´ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s')\ns_comp_Î´â‚€ : âˆ€ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.Î´ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_Î´ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s (HAdd.hAdd n 1)) (X.left.Î´ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (s n))\ns_comp_Ïƒ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.Ïƒ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (s (HAdd.hAdd n 1)))\nxâœ : Eq { s' := s'âœ, s := sâœ, s'_comp_Îµ := s'_comp_Îµâœ, sâ‚€_comp_Î´â‚ := sâ‚€_comp_Î´â‚âœ, s_comp_Î´â‚€ := s_comp_Î´â‚€âœ, s_comp_Î´ := s_comp_Î´âœ, s_comp_Ïƒ := s_comp_Ïƒâœ } { s' := s', s := s, s'_comp_Îµ := s'_comp_Îµ, sâ‚€_comp_Î´â‚ := sâ‚€_comp_Î´â‚, s_comp_Î´â‚€ := s_comp_Î´â‚€, s_comp_Î´ := s_comp_Î´, s_comp_Ïƒ := s_comp_Ïƒ }\nâŠ¢ And (Eq s'âœ s') (Eq sâœ s)","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_Î´â‚€","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (X.left.Î´ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_Ïƒ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (X.left.Ïƒ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (self.s (HAdd.hAdd n 1)))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_Î´","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s (HAdd.hAdd n 1)) (X.left.Î´ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (self.s n))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.mk.sizeOf_spec","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\ninstâœ : SizeOf C\ns' : Quiver.Hom (CategoryTheory.SimplicialObject.Augmented.point.obj X) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })\ns : (n : Nat) â†’ Quiver.Hom ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }) ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) })\ns'_comp_Îµ : Eq (CategoryTheory.CategoryStruct.comp s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))\nsâ‚€_comp_Î´â‚ : Eq (CategoryTheory.CategoryStruct.comp (s 0) (X.left.Î´ 1)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) s')\ns_comp_Î´â‚€ : âˆ€ (n : Nat), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.Î´ 0)) (CategoryTheory.CategoryStruct.id ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk n }))\ns_comp_Î´ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 2)), Eq (CategoryTheory.CategoryStruct.comp (s (HAdd.hAdd n 1)) (X.left.Î´ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (s n))\ns_comp_Ïƒ : âˆ€ (n : Nat) (i : Fin (HAdd.hAdd n 1)), Eq (CategoryTheory.CategoryStruct.comp (s n) (X.left.Ïƒ i.succ)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (s (HAdd.hAdd n 1)))\nâŠ¢ Eq (SizeOf.sizeOf { s' := s', s := s, s'_comp_Îµ := s'_comp_Îµ, sâ‚€_comp_Î´â‚ := sâ‚€_comp_Î´â‚, s_comp_Î´â‚€ := s_comp_Î´â‚€, s_comp_Î´ := s_comp_Î´, s_comp_Ïƒ := s_comp_Ïƒ }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf s')) (SizeOf.sizeOf s'_comp_Îµ)) (SizeOf.sizeOf sâ‚€_comp_Î´â‚))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s'_comp_Îµ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.s' (X.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.id (CategoryTheory.SimplicialObject.Augmented.point.obj X))","decl":"/-- The datum of an extra degeneracy is a technical condition on\naugmented simplicial objects. The morphisms `s'` and `s n` of the\nstructure formally behave like extra degeneracies `Ïƒ (-1)`. -/\n@[ext]\nstructure ExtraDegeneracy (X : SimplicialObject.Augmented C) where\n  s' : point.obj X âŸ¶ drop.obj X _[0]\n  s : âˆ€ n : â„•, drop.obj X _[n] âŸ¶ drop.obj X _[n + 1]\n  s'_comp_Îµ : s' â‰« X.hom.app (op [0]) = ðŸ™ _\n  sâ‚€_comp_Î´â‚ : s 0 â‰« X.left.Î´ 1 = X.hom.app (op [0]) â‰« s'\n  s_comp_Î´â‚€ : âˆ€ n : â„•, s n â‰« X.left.Î´ 0 = ðŸ™ _\n  s_comp_Î´ :\n    âˆ€ (n : â„•) (i : Fin (n + 2)), s (n + 1) â‰« X.left.Î´ i.succ = X.left.Î´ i â‰« s n\n  s_comp_Ïƒ :\n    âˆ€ (n : â„•) (i : Fin (n + 1)), s n â‰« X.left.Ïƒ i.succ = X.left.Ïƒ i â‰« s (n + 1)\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_Ïƒ_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1) }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i.succ) h)) (CategoryTheory.CategoryStruct.comp (X.left.Ïƒ i) (CategoryTheory.CategoryStruct.comp (self.s (HAdd.hAdd n 1)) h))","decl":"attribute [reassoc] sâ‚€_comp_Î´â‚ s_comp_Î´ s_comp_Ïƒ\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.sâ‚€_comp_Î´â‚_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk 0 }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s 0) (CategoryTheory.CategoryStruct.comp (X.left.Î´ 1) h)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.CategoryStruct.comp self.s' h))","decl":"attribute [reassoc] sâ‚€_comp_Î´â‚ s_comp_Î´ s_comp_Ïƒ\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_Î´_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s (HAdd.hAdd n 1)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i.succ) h)) (CategoryTheory.CategoryStruct.comp (X.left.Î´ i) (CategoryTheory.CategoryStruct.comp (self.s n) h))","decl":"attribute [reassoc] sâ‚€_comp_Î´â‚ s_comp_Î´ s_comp_Ïƒ\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s_comp_Î´â‚€_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nn : Nat\nZ : C\nh : Quiver.Hom (X.left.obj { unop := SimplexCategory.mk n }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (self.s n) (CategoryTheory.CategoryStruct.comp (X.left.Î´ 0) h)) h","decl":"attribute [reassoc (attr := simp)] s'_comp_Îµ s_comp_Î´â‚€\n\n"}
{"name":"SimplicialObject.Augmented.ExtraDegeneracy.s'_comp_Îµ_assoc","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœ : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject.Augmented C\nself : SimplicialObject.Augmented.ExtraDegeneracy X\nZ : C\nh : Quiver.Hom (((CategoryTheory.SimplicialObject.const C).obj X.right).obj { unop := SimplexCategory.mk 0 }) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp self.s' (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) h)) h","decl":"attribute [reassoc (attr := simp)] s'_comp_Îµ s_comp_Î´â‚€\n\n"}
{"name":"SSet.Augmented.StandardSimplex.shiftFun_0","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"n : Nat\nX : Type u_1\ninstâœ : Zero X\nf : Fin n â†’ X\nâŠ¢ Eq (SSet.Augmented.StandardSimplex.shiftFun f 0) 0","decl":"@[simp]\ntheorem shiftFun_0 {n : â„•} {X : Type*} [Zero X] (f : Fin n â†’ X) : shiftFun f 0 = 0 :=\n  rfl\n\n"}
{"name":"SSet.Augmented.StandardSimplex.shiftFun_succ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"n : Nat\nX : Type u_1\ninstâœ : Zero X\nf : Fin n â†’ X\ni : Fin n\nâŠ¢ Eq (SSet.Augmented.StandardSimplex.shiftFun f i.succ) (f i)","decl":"@[simp]\ntheorem shiftFun_succ {n : â„•} {X : Type*} [Zero X] (f : Fin n â†’ X) (i : Fin n) :\n    shiftFun f i.succ = f i := by\n  dsimp [shiftFun]\n  split_ifs with h\n  Â· exfalso\n    simp only [Fin.ext_iff, Fin.val_succ, Fin.val_zero, add_eq_zero, and_false, reduceCtorEq] at h\n  Â· simp only [Fin.pred_succ]\n\n"}
{"name":"SSet.Augmented.StandardSimplex.nonempty_extraDegeneracy_stdSimplex","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"Î” : SimplexCategory\nâŠ¢ Nonempty (SimplicialObject.Augmented.ExtraDegeneracy (SSet.Augmented.stdSimplex.obj Î”))","decl":"instance nonempty_extraDegeneracy_stdSimplex (Î” : SimplexCategory) :\n    Nonempty (SimplicialObject.Augmented.ExtraDegeneracy (stdSimplex.obj Î”)) :=\n  âŸ¨StandardSimplex.extraDegeneracy Î”âŸ©\n\n"}
{"name":"CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_Ï€_0","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\nf : CategoryTheory.Arrow C\ninstâœ : âˆ€ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nS : CategoryTheory.SplitEpi f.hom\nn : Nat\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s f S n) (CategoryTheory.Limits.WidePullback.Ï€ (fun x => f.hom) 0)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.WidePullback.base fun x => f.hom) S.section_)","decl":"theorem ExtraDegeneracy.s_comp_Ï€_0 (n : â„•) :\n    ExtraDegeneracy.s f S n â‰« WidePullback.Ï€ _ 0 =\n      @WidePullback.base _ _ _ f.right (fun _ : Fin (n + 1) => f.left) (fun _ => f.hom) _ â‰«\n        S.section_ := by\n  dsimp [ExtraDegeneracy.s]\n  simp only [WidePullback.lift_Ï€]\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed as the linter complains the LHS is not in normal form\n"}
{"name":"CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_Ï€_succ","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\nf : CategoryTheory.Arrow C\ninstâœ : âˆ€ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nS : CategoryTheory.SplitEpi f.hom\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s f S n) (CategoryTheory.Limits.WidePullback.Ï€ (fun x => f.hom) i.succ)) (CategoryTheory.Limits.WidePullback.Ï€ (fun x => f.hom) i)","decl":"theorem ExtraDegeneracy.s_comp_Ï€_succ (n : â„•) (i : Fin (n + 1)) :\n    ExtraDegeneracy.s f S n â‰« WidePullback.Ï€ _ i.succ =\n      @WidePullback.Ï€ _ _ _ f.right (fun _ : Fin (n + 1) => f.left) (fun _ => f.hom) _ i := by\n  dsimp [ExtraDegeneracy.s]\n  simp only [WidePullback.lift_Ï€]\n  split_ifs with h\n  Â· simp only [Fin.ext_iff, Fin.val_succ, Fin.val_zero, add_eq_zero, and_false, reduceCtorEq] at h\n  Â· simp only [Fin.pred_succ]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11119): @[simp] removed as the linter complains the LHS is not in normal form\n"}
{"name":"CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s_comp_base","module":"Mathlib.AlgebraicTopology.ExtraDegeneracy","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\nf : CategoryTheory.Arrow C\ninstâœ : âˆ€ (n : Nat), CategoryTheory.Limits.HasWidePullback f.right (fun x => f.left) fun x => f.hom\nS : CategoryTheory.SplitEpi f.hom\nn : Nat\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Arrow.AugmentedCechNerve.ExtraDegeneracy.s f S n) (CategoryTheory.Limits.WidePullback.base fun x => f.hom)) (CategoryTheory.Limits.WidePullback.base fun x => f.hom)","decl":"theorem ExtraDegeneracy.s_comp_base (n : â„•) :\n    ExtraDegeneracy.s f S n â‰« WidePullback.base _ = WidePullback.base _ := by\n  apply WidePullback.lift_base\n\n"}
