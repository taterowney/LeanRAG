{"name":"IsIntegral.isUnit","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Field R\ninst✝² : Ring S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nx : S\nint : IsIntegral R x\nh0 : Ne x 0\n⊢ IsUnit x","decl":"/-- A nonzero element in a domain integral over a field is a unit. -/\ntheorem IsIntegral.isUnit [Field R] [Ring S] [IsDomain S] [Algebra R S] {x : S}\n    (int : IsIntegral R x) (h0 : x ≠ 0) : IsUnit x :=\n  have : FiniteDimensional R (adjoin R {x}) := ⟨(Submodule.fg_top _).mpr int.fg_adjoin_singleton⟩\n  (FiniteDimensional.isUnit R (K := adjoin R {x})\n    (x := ⟨x, subset_adjoin rfl⟩) <| mt Subtype.ext_iff.mp h0).map (adjoin R {x}).val\n\n"}
{"name":"isField_of_isIntegral_of_isField'","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsIntegral R S\nhR : IsField R\n⊢ IsField S","decl":"/-- A commutative domain that is an integral algebra over a field is a field. -/\ntheorem isField_of_isIntegral_of_isField' [CommRing R] [CommRing S] [IsDomain S]\n    [Algebra R S] [Algebra.IsIntegral R S] (hR : IsField R) : IsField S where\n  exists_pair_ne := ⟨0, 1, zero_ne_one⟩\n  mul_comm := mul_comm\n  mul_inv_cancel {x} hx := by\n    letI := hR.toField\n    obtain ⟨y, rfl⟩ := (Algebra.IsIntegral.isIntegral (R := R) x).isUnit hx\n    exact ⟨y.inv, y.val_inv⟩\n\n"}
{"name":"IsIntegral.inv_mem_adjoin","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Field R\ninst✝¹ : DivisionRing S\ninst✝ : Algebra R S\nx : S\nint : IsIntegral R x\n⊢ Membership.mem (Algebra.adjoin R (Singleton.singleton x)) (Inv.inv x)","decl":"theorem IsIntegral.inv_mem_adjoin (int : IsIntegral R x) : x⁻¹ ∈ adjoin R {x} := by\n  obtain rfl | h0 := eq_or_ne x 0\n  · rw [inv_zero]; exact Subalgebra.zero_mem _\n  have : FiniteDimensional R (adjoin R {x}) := ⟨(Submodule.fg_top _).mpr int.fg_adjoin_singleton⟩\n  obtain ⟨⟨y, hy⟩, h1⟩ := FiniteDimensional.exists_mul_eq_one R\n    (K := adjoin R {x}) (x := ⟨x, subset_adjoin rfl⟩) (mt Subtype.ext_iff.mp h0)\n  rwa [← mul_left_cancel₀ h0 ((Subtype.ext_iff.mp h1).trans (mul_inv_cancel₀ h0).symm)]\n\n"}
{"name":"IsIntegral.inv_mem","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Field R\ninst✝¹ : DivisionRing S\ninst✝ : Algebra R S\nx : S\nA : Subalgebra R S\nint : IsIntegral R x\nhx : Membership.mem A x\n⊢ Membership.mem A (Inv.inv x)","decl":"/-- The inverse of an integral element in a subalgebra of a division ring over a field\n  also lies in that subalgebra. -/\ntheorem IsIntegral.inv_mem (int : IsIntegral R x) (hx : x ∈ A) : x⁻¹ ∈ A :=\n  adjoin_le (Set.singleton_subset_iff.mpr hx) int.inv_mem_adjoin\n\n"}
{"name":"Algebra.IsIntegral.inv_mem","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : Field R\ninst✝² : DivisionRing S\ninst✝¹ : Algebra R S\nx : S\nA : Subalgebra R S\ninst✝ : Algebra.IsIntegral R (Subtype fun x => Membership.mem A x)\nhx : Membership.mem A x\n⊢ Membership.mem A (Inv.inv x)","decl":"/-- An integral subalgebra of a division ring over a field is closed under inverses. -/\ntheorem Algebra.IsIntegral.inv_mem [Algebra.IsIntegral R A] (hx : x ∈ A) : x⁻¹ ∈ A :=\n  ((isIntegral_algHom_iff A.val Subtype.val_injective).mpr <|\n    Algebra.IsIntegral.isIntegral (⟨x, hx⟩ : A)).inv_mem hx\n\n"}
{"name":"IsIntegral.inv","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Field R\ninst✝¹ : DivisionRing S\ninst✝ : Algebra R S\nx : S\nint : IsIntegral R x\n⊢ IsIntegral R (Inv.inv x)","decl":"/-- The inverse of an integral element in a division ring over a field is also integral. -/\ntheorem IsIntegral.inv (int : IsIntegral R x) : IsIntegral R x⁻¹ :=\n  .of_mem_of_fg _ int.fg_adjoin_singleton _ int.inv_mem_adjoin\n\n"}
{"name":"IsIntegral.mem_of_inv_mem","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝² : Field R\ninst✝¹ : DivisionRing S\ninst✝ : Algebra R S\nx : S\nA : Subalgebra R S\nint : IsIntegral R x\ninv_mem : Membership.mem A (Inv.inv x)\n⊢ Membership.mem A x","decl":"theorem IsIntegral.mem_of_inv_mem (int : IsIntegral R x) (inv_mem : x⁻¹ ∈ A) : x ∈ A := by\n  rw [← inv_inv x]; exact int.inv.inv_mem inv_mem\n\n"}
{"name":"Algebra.IsIntegral.finite","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Algebra.IsIntegral R A\nh' : Algebra.FiniteType R A\n⊢ Module.Finite R A","decl":"/-- The [Kurosh problem](https://en.wikipedia.org/wiki/Kurosh_problem) asks to show that\n  this is still true when `A` is not necessarily commutative and `R` is a field, but it has\n  been solved in the negative. See https://arxiv.org/pdf/1706.02383.pdf for criteria for a\n  finitely generated algebraic (= integral) algebra over a field to be finite dimensional.\n\nThis could be an `instance`, but we tend to go from `Module.Finite` to `IsIntegral`/`IsAlgebraic`,\nand making it an instance will cause the search to be complicated a lot.\n-/\ntheorem Algebra.IsIntegral.finite [Algebra.IsIntegral R A] [h' : Algebra.FiniteType R A] :\n    Module.Finite R A :=\n  have ⟨s, hs⟩ := h'\n  ⟨by apply hs ▸ fg_adjoin_of_finite s.finite_toSet fun x _ ↦ Algebra.IsIntegral.isIntegral x⟩\n\n"}
{"name":"Algebra.finite_iff_isIntegral_and_finiteType","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (Module.Finite R A) (And (Algebra.IsIntegral R A) (Algebra.FiniteType R A))","decl":"/-- finite = integral + finite type -/\ntheorem Algebra.finite_iff_isIntegral_and_finiteType :\n    Module.Finite R A ↔ Algebra.IsIntegral R A ∧ Algebra.FiniteType R A :=\n  ⟨fun _ ↦ ⟨⟨.of_finite R⟩, inferInstance⟩, fun ⟨h, _⟩ ↦ h.finite⟩\n\n"}
{"name":"RingHom.IsIntegral.to_finite","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nh : f.IsIntegral\nh' : f.FiniteType\n⊢ f.Finite","decl":"theorem RingHom.IsIntegral.to_finite (h : f.IsIntegral) (h' : f.FiniteType) : f.Finite :=\n  let _ := f.toAlgebra\n  let _ : Algebra.IsIntegral R S := ⟨h⟩\n  Algebra.IsIntegral.finite (h' := h')\n\n"}
{"name":"RingHom.Finite.of_isIntegral_of_finiteType","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nh : f.IsIntegral\nh' : f.FiniteType\n⊢ f.Finite","decl":"alias RingHom.Finite.of_isIntegral_of_finiteType := RingHom.IsIntegral.to_finite\n\n"}
{"name":"RingHom.finite_iff_isIntegral_and_finiteType","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\n⊢ Iff f.Finite (And f.IsIntegral f.FiniteType)","decl":"/-- finite = integral + finite type -/\ntheorem RingHom.finite_iff_isIntegral_and_finiteType : f.Finite ↔ f.IsIntegral ∧ f.FiniteType :=\n  ⟨fun h ↦ ⟨h.to_isIntegral, h.to_finiteType⟩, fun ⟨h, h'⟩ ↦ h.to_finite h'⟩\n\n"}
{"name":"mem_integralClosure_iff_mem_fg","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nr : A\n⊢ Iff (Membership.mem (integralClosure R A) r) (Exists fun M => And (Subalgebra.toSubmodule M).FG (Membership.mem M r))","decl":"theorem mem_integralClosure_iff_mem_fg {r : A} :\n    r ∈ integralClosure R A ↔ ∃ M : Subalgebra R A, M.toSubmodule.FG ∧ r ∈ M :=\n  ⟨fun hr =>\n    ⟨Algebra.adjoin R {r}, hr.fg_adjoin_singleton, Algebra.subset_adjoin rfl⟩,\n    fun ⟨M, Hf, hrM⟩ => .of_mem_of_fg M Hf _ hrM⟩\n\n"}
{"name":"adjoin_le_integralClosure","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : A\nhx : IsIntegral R x\n⊢ LE.le (Algebra.adjoin R (Singleton.singleton x)) (integralClosure R A)","decl":"theorem adjoin_le_integralClosure {x : A} (hx : IsIntegral R x) :\n    Algebra.adjoin R {x} ≤ integralClosure R A := by\n  rw [Algebra.adjoin_le_iff]\n  simp only [SetLike.mem_coe, Set.singleton_subset_iff]\n  exact hx\n\n"}
{"name":"le_integralClosure_iff_isIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nS : Subalgebra R A\n⊢ Iff (LE.le S (integralClosure R A)) (Algebra.IsIntegral R (Subtype fun x => Membership.mem S x))","decl":"theorem le_integralClosure_iff_isIntegral {S : Subalgebra R A} :\n    S ≤ integralClosure R A ↔ Algebra.IsIntegral R S :=\n  SetLike.forall.symm.trans <|\n    (forall_congr' fun x =>\n      show IsIntegral R (algebraMap S A x) ↔ IsIntegral R x from\n        isIntegral_algebraMap_iff Subtype.coe_injective).trans\n      Algebra.isIntegral_def.symm\n\n"}
{"name":"Algebra.IsIntegral.adjoin","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nS : Set A\nhS : ∀ (x : A), Membership.mem S x → IsIntegral R x\n⊢ Algebra.IsIntegral R (Subtype fun x => Membership.mem (Algebra.adjoin R S) x)","decl":"theorem Algebra.IsIntegral.adjoin {S : Set A} (hS : ∀ x ∈ S, IsIntegral R x) :\n    Algebra.IsIntegral R (adjoin R S) :=\n  le_integralClosure_iff_isIntegral.mp <| adjoin_le hS\n\n"}
{"name":"integralClosure_eq_top_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Iff (Eq (integralClosure R A) Top.top) (Algebra.IsIntegral R A)","decl":"theorem integralClosure_eq_top_iff : integralClosure R A = ⊤ ↔ Algebra.IsIntegral R A := by\n  rw [← top_le_iff, le_integralClosure_iff_isIntegral,\n      (Subalgebra.topEquiv (R := R) (A := A)).isIntegral_iff] -- explicit arguments for speedup\n\n"}
{"name":"Algebra.isIntegral_sup","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nS T : Subalgebra R A\n⊢ Iff (Algebra.IsIntegral R (Subtype fun x => Membership.mem (Max.max S T) x)) (And (Algebra.IsIntegral R (Subtype fun x => Membership.mem S x)) (Algebra.IsIntegral R (Subtype fun x => Membership.mem T x)))","decl":"theorem Algebra.isIntegral_sup {S T : Subalgebra R A} :\n    Algebra.IsIntegral R (S ⊔ T : Subalgebra R A) ↔\n      Algebra.IsIntegral R S ∧ Algebra.IsIntegral R T := by\n  simp_rw [← le_integralClosure_iff_isIntegral, sup_le_iff]\n\n"}
{"name":"Algebra.isIntegral_iSup","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nι : Sort u_5\nS : ι → Subalgebra R A\n⊢ Iff (Algebra.IsIntegral R (Subtype fun x => Membership.mem (iSup S) x)) (∀ (i : ι), Algebra.IsIntegral R (Subtype fun x => Membership.mem (S i) x))","decl":"theorem Algebra.isIntegral_iSup {ι} (S : ι → Subalgebra R A) :\n    Algebra.IsIntegral R ↑(iSup S) ↔ ∀ i, Algebra.IsIntegral R (S i) := by\n  simp_rw [← le_integralClosure_iff_isIntegral, iSup_le_iff]\n\n"}
{"name":"integralClosure_map_algEquiv","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nS : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing S\ninst✝¹ : Algebra R A\ninst✝ : Algebra R S\nf : AlgEquiv R A S\n⊢ Eq (Subalgebra.map (↑f) (integralClosure R A)) (integralClosure R S)","decl":"/-- Mapping an integral closure along an `AlgEquiv` gives the integral closure. -/\ntheorem integralClosure_map_algEquiv [Algebra R S] (f : A ≃ₐ[R] S) :\n    (integralClosure R A).map (f : A →ₐ[R] S) = integralClosure R S := by\n  ext y\n  rw [Subalgebra.mem_map]\n  constructor\n  · rintro ⟨x, hx, rfl⟩\n    exact hx.map f\n  · intro hy\n    use f.symm y, hy.map (f.symm : S →ₐ[R] A)\n    simp\n\n"}
{"name":"AlgHom.coe_mapIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nS : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing S\ninst✝¹ : Algebra R A\ninst✝ : Algebra R S\nf : AlgHom R A S\nx : Subtype fun x => Membership.mem (integralClosure R A) x\n⊢ Eq (↑(f.mapIntegralClosure x)) (f ↑x)","decl":"@[simp]\ntheorem AlgHom.coe_mapIntegralClosure [Algebra R S] (f : A →ₐ[R] S)\n    (x : integralClosure R A) : (f.mapIntegralClosure x : S) = f (x : A) := rfl\n\n"}
{"name":"AlgEquiv.coe_mapIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nS : Type u_4\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing S\ninst✝¹ : Algebra R A\ninst✝ : Algebra R S\nf : AlgEquiv R A S\nx : Subtype fun x => Membership.mem (integralClosure R A) x\n⊢ Eq (↑(f.mapIntegralClosure x)) (f ↑x)","decl":"@[simp]\ntheorem AlgEquiv.coe_mapIntegralClosure [Algebra R S] (f : A ≃ₐ[R] S)\n    (x : integralClosure R A) : (f.mapIntegralClosure x : S) = f (x : A) := rfl\n\n"}
{"name":"integralClosure.isIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : Subtype fun x => Membership.mem (integralClosure R A) x\n⊢ IsIntegral R x","decl":"theorem integralClosure.isIntegral (x : integralClosure R A) : IsIntegral R x :=\n  let ⟨p, hpm, hpx⟩ := x.2\n  ⟨p, hpm,\n    Subtype.eq <| by\n      rwa [← aeval_def, ← Subalgebra.val_apply, aeval_algHom_apply] at hpx⟩\n\n"}
{"name":"integralClosure.AlgebraIsIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Algebra.IsIntegral R (Subtype fun x => Membership.mem (integralClosure R A) x)","decl":"instance integralClosure.AlgebraIsIntegral : Algebra.IsIntegral R (integralClosure R A) :=\n  ⟨integralClosure.isIntegral⟩\n\n"}
{"name":"IsIntegral.of_mul_unit","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx y : B\nr : R\nhr : Eq (HMul.hMul ((algebraMap R B) r) y) 1\nhx : IsIntegral R (HMul.hMul x y)\n⊢ IsIntegral R x","decl":"theorem IsIntegral.of_mul_unit {x y : B} {r : R} (hr : algebraMap R B r * y = 1)\n    (hx : IsIntegral R (x * y)) : IsIntegral R x := by\n  obtain ⟨p, p_monic, hp⟩ := hx\n  refine ⟨scaleRoots p r, (monic_scaleRoots_iff r).2 p_monic, ?_⟩\n  convert scaleRoots_aeval_eq_zero hp\n  rw [Algebra.commutes] at hr ⊢\n  rw [mul_assoc, hr, mul_one]; rfl\n\n"}
{"name":"RingHom.IsIntegralElem.of_mul_unit","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nx y : S\nr : R\nhr : Eq (HMul.hMul (f r) y) 1\nhx : f.IsIntegralElem (HMul.hMul x y)\n⊢ f.IsIntegralElem x","decl":"theorem RingHom.IsIntegralElem.of_mul_unit (x y : S) (r : R) (hr : f r * y = 1)\n    (hx : f.IsIntegralElem (x * y)) : f.IsIntegralElem x :=\n  letI : Algebra R S := f.toAlgebra\n  IsIntegral.of_mul_unit hr hx\n\n"}
{"name":"IsIntegral.of_mem_closure'","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nG : Set A\nhG : ∀ (x : A), Membership.mem G x → IsIntegral R x\nx : A\na✝ : Membership.mem (Subring.closure G) x\n⊢ IsIntegral R x","decl":"/-- Generalization of `IsIntegral.of_mem_closure` bootstrapped up from that lemma -/\ntheorem IsIntegral.of_mem_closure' (G : Set A) (hG : ∀ x ∈ G, IsIntegral R x) :\n    ∀ x ∈ Subring.closure G, IsIntegral R x := fun _ hx ↦\n  Subring.closure_induction hG isIntegral_zero isIntegral_one (fun _ _ _ _ ↦ IsIntegral.add)\n    (fun _ _ ↦ IsIntegral.neg) (fun _ _ _ _ ↦ IsIntegral.mul) hx\n\n"}
{"name":"IsIntegral.of_mem_closure''","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommRing R\nS : Type u_5\ninst✝ : CommRing S\nf : RingHom R S\nG : Set S\nhG : ∀ (x : S), Membership.mem G x → f.IsIntegralElem x\nx : S\na✝ : Membership.mem (Subring.closure G) x\n⊢ f.IsIntegralElem x","decl":"theorem IsIntegral.of_mem_closure'' {S : Type*} [CommRing S] {f : R →+* S} (G : Set S)\n    (hG : ∀ x ∈ G, f.IsIntegralElem x) : ∀ x ∈ Subring.closure G, f.IsIntegralElem x := fun x hx =>\n  @IsIntegral.of_mem_closure' R S _ _ f.toAlgebra G hG x hx\n\n"}
{"name":"IsIntegral.pow","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nh : IsIntegral R x\nn : Nat\n⊢ IsIntegral R (HPow.hPow x n)","decl":"theorem IsIntegral.pow {x : B} (h : IsIntegral R x) (n : ℕ) : IsIntegral R (x ^ n) :=\n  .of_mem_of_fg _ h.fg_adjoin_singleton _ <|\n    Subalgebra.pow_mem _ (by exact Algebra.subset_adjoin rfl) _\n\n"}
{"name":"IsIntegral.nsmul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nh : IsIntegral R x\nn : Nat\n⊢ IsIntegral R (HSMul.hSMul n x)","decl":"theorem IsIntegral.nsmul {x : B} (h : IsIntegral R x) (n : ℕ) : IsIntegral R (n • x) :=\n  h.smul n\n\n"}
{"name":"IsIntegral.zsmul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nB : Type u_3\ninst✝² : CommRing R\ninst✝¹ : Ring B\ninst✝ : Algebra R B\nx : B\nh : IsIntegral R x\nn : Int\n⊢ IsIntegral R (HSMul.hSMul n x)","decl":"theorem IsIntegral.zsmul {x : B} (h : IsIntegral R x) (n : ℤ) : IsIntegral R (n • x) :=\n  h.smul n\n\n"}
{"name":"IsIntegral.multiset_prod","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Multiset A\nh : ∀ (x : A), Membership.mem s x → IsIntegral R x\n⊢ IsIntegral R s.prod","decl":"theorem IsIntegral.multiset_prod {s : Multiset A} (h : ∀ x ∈ s, IsIntegral R x) :\n    IsIntegral R s.prod :=\n  (integralClosure R A).multiset_prod_mem h\n\n"}
{"name":"IsIntegral.multiset_sum","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\ns : Multiset A\nh : ∀ (x : A), Membership.mem s x → IsIntegral R x\n⊢ IsIntegral R s.sum","decl":"theorem IsIntegral.multiset_sum {s : Multiset A} (h : ∀ x ∈ s, IsIntegral R x) :\n    IsIntegral R s.sum :=\n  (integralClosure R A).multiset_sum_mem h\n\n"}
{"name":"IsIntegral.prod","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nα : Type u_5\ns : Finset α\nf : α → A\nh : ∀ (x : α), Membership.mem s x → IsIntegral R (f x)\n⊢ IsIntegral R (s.prod fun x => f x)","decl":"theorem IsIntegral.prod {α : Type*} {s : Finset α} (f : α → A) (h : ∀ x ∈ s, IsIntegral R (f x)) :\n    IsIntegral R (∏ x ∈ s, f x) :=\n  (integralClosure R A).prod_mem h\n\n"}
{"name":"IsIntegral.sum","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nα : Type u_5\ns : Finset α\nf : α → A\nh : ∀ (x : α), Membership.mem s x → IsIntegral R (f x)\n⊢ IsIntegral R (s.sum fun x => f x)","decl":"theorem IsIntegral.sum {α : Type*} {s : Finset α} (f : α → A) (h : ∀ x ∈ s, IsIntegral R (f x)) :\n    IsIntegral R (∑ x ∈ s, f x) :=\n  (integralClosure R A).sum_mem h\n\n"}
{"name":"IsIntegral.det","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\nn : Type u_5\ninst✝¹ : Fintype n\ninst✝ : DecidableEq n\nM : Matrix n n A\nh : ∀ (i j : n), IsIntegral R (M i j)\n⊢ IsIntegral R M.det","decl":"theorem IsIntegral.det {n : Type*} [Fintype n] [DecidableEq n] {M : Matrix n n A}\n    (h : ∀ i j, IsIntegral R (M i j)) : IsIntegral R M.det := by\n  rw [Matrix.det_apply]\n  exact IsIntegral.sum _ fun σ _hσ ↦ (IsIntegral.prod _ fun i _hi => h _ _).zsmul _\n\n"}
{"name":"IsIntegral.pow_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nx : A\nn : Nat\nhn : LT.lt 0 n\n⊢ Iff (IsIntegral R (HPow.hPow x n)) (IsIntegral R x)","decl":"@[simp]\ntheorem IsIntegral.pow_iff {x : A} {n : ℕ} (hn : 0 < n) : IsIntegral R (x ^ n) ↔ IsIntegral R x :=\n  ⟨IsIntegral.of_pow hn, fun hx ↦ hx.pow n⟩\n\n"}
{"name":"IsIntegral.tmul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nx : A\ny : B\nh : IsIntegral R y\n⊢ IsIntegral A (TensorProduct.tmul R x y)","decl":"theorem IsIntegral.tmul (x : A) {y : B} (h : IsIntegral R y) : IsIntegral A (x ⊗ₜ[R] y) := by\n  rw [← mul_one x, ← smul_eq_mul, ← smul_tmul']\n  exact smul _ (h.map_of_comp_eq (algebraMap R A)\n    (Algebra.TensorProduct.includeRight (R := R) (A := A) (B := B)).toRingHom\n    Algebra.TensorProduct.includeLeftRingHom_comp_algebraMap)\n\n"}
{"name":"normalizeScaleRoots_coeff_mul_leadingCoeff_pow","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\ni : Nat\nhp : LE.le 1 p.natDegree\n⊢ Eq (HMul.hMul (p.integralNormalization.coeff i) (HPow.hPow p.leadingCoeff i)) (HMul.hMul (p.coeff i) (HPow.hPow p.leadingCoeff (HSub.hSub p.natDegree 1)))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias normalizeScaleRoots_coeff_mul_leadingCoeff_pow :=\n  integralNormalization_coeff_mul_leadingCoeff_pow\n\n"}
{"name":"leadingCoeff_smul_normalizeScaleRoots","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"S : Type v\ninst✝ : CommSemiring S\np : Polynomial S\n⊢ Eq (HSMul.hSMul p.leadingCoeff p.integralNormalization) (p.scaleRoots p.leadingCoeff)","decl":"@[deprecated (since := \"2024-11-30\")]\nalias leadingCoeff_smul_normalizeScaleRoots := leadingCoeff_smul_integralNormalization\n\n"}
{"name":"normalizeScaleRoots_support","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ HasSubset.Subset p.integralNormalization.support p.support","decl":"@[deprecated (since := \"2024-11-30\")]\nalias normalizeScaleRoots_support := support_integralNormalization_subset\n\n"}
{"name":"normalizeScaleRoots_degree","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq p.integralNormalization.degree p.degree","decl":"@[deprecated (since := \"2024-11-30\")]\nalias normalizeScaleRoots_degree := integralNormalization_degree\n\n"}
{"name":"normalizeScaleRoots_eval₂_leadingCoeff_mul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : Semiring R\np : Polynomial R\ninst✝ : CommSemiring S\nh : LE.le 1 p.natDegree\nf : RingHom R S\nx : S\n⊢ Eq (Polynomial.eval₂ f (HMul.hMul (f p.leadingCoeff) x) p.integralNormalization) (HMul.hMul (HPow.hPow (f p.leadingCoeff) (HSub.hSub p.natDegree 1)) (Polynomial.eval₂ f x p))","decl":"@[deprecated (since := \"2024-11-30\")]\nalias normalizeScaleRoots_eval₂_leadingCoeff_mul := integralNormalization_eval₂_leadingCoeff_mul\n\n"}
{"name":"normalizeScaleRoots_monic","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u\ninst✝ : Semiring R\np : Polynomial R\nhp : Ne p 0\n⊢ p.integralNormalization.Monic","decl":"@[deprecated (since := \"2024-11-30\")]\nalias normalizeScaleRoots_monic := monic_integralNormalization\n\n"}
{"name":"RingHom.isIntegralElem_leadingCoeff_mul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\np : Polynomial R\nx : S\nh : Eq (Polynomial.eval₂ f x p) 0\n⊢ f.IsIntegralElem (HMul.hMul (f p.leadingCoeff) x)","decl":"/-- Given a `p : R[X]` and a `x : S` such that `p.eval₂ f x = 0`,\n`f p.leadingCoeff * x` is integral. -/\ntheorem RingHom.isIntegralElem_leadingCoeff_mul (h : p.eval₂ f x = 0) :\n    f.IsIntegralElem (f p.leadingCoeff * x) := by\n  by_cases h' : 1 ≤ p.natDegree\n  · use integralNormalization p\n    have : p ≠ 0 := fun h'' => by\n      rw [h'', natDegree_zero] at h'\n      exact Nat.not_succ_le_zero 0 h'\n    use monic_integralNormalization this\n    rw [integralNormalization_eval₂_leadingCoeff_mul h' f x, h, mul_zero]\n  · by_cases hp : p.map f = 0\n    · apply_fun fun q => coeff q p.natDegree at hp\n      rw [coeff_map, coeff_zero, coeff_natDegree] at hp\n      rw [hp, zero_mul]\n      exact f.isIntegralElem_zero\n    · rw [Nat.one_le_iff_ne_zero, Classical.not_not] at h'\n      rw [eq_C_of_natDegree_eq_zero h', eval₂_C] at h\n      suffices p.map f = 0 by exact (hp this).elim\n      rw [eq_C_of_natDegree_eq_zero h', map_C, h, C_eq_zero]\n\n"}
{"name":"isIntegral_leadingCoeff_smul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝² : CommRing R\ninst✝¹ : CommRing S\np : Polynomial R\nx : S\ninst✝ : Algebra R S\nh : Eq ((Polynomial.aeval x) p) 0\n⊢ IsIntegral R (HSMul.hSMul p.leadingCoeff x)","decl":"/-- Given a `p : R[X]` and a root `x : S`,\nthen `p.leadingCoeff • x : S` is integral over `R`. -/\ntheorem isIntegral_leadingCoeff_smul [Algebra R S] (h : aeval x p = 0) :\n    IsIntegral R (p.leadingCoeff • x) := by\n  rw [aeval_def] at h\n  rw [Algebra.smul_def]\n  exact (algebraMap R S).isIntegralElem_leadingCoeff_mul p x h\n\n"}
{"name":"Polynomial.Monic.quotient_isIntegralElem","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"S : Type u_4\ninst✝ : CommRing S\ng : Polynomial S\nmon : g.Monic\nI : Ideal (Polynomial S)\nh : Membership.mem I g\n⊢ ((Ideal.Quotient.mk I).comp (algebraMap S (Polynomial S))).IsIntegralElem ((Ideal.Quotient.mk I) Polynomial.X)","decl":"lemma Polynomial.Monic.quotient_isIntegralElem {g : S[X]} (mon : g.Monic) {I : Ideal S[X]}\n    (h : g ∈ I) :\n    ((Ideal.Quotient.mk I).comp (algebraMap S S[X])).IsIntegralElem (Ideal.Quotient.mk I X) := by\n  exact ⟨g, mon, by\n  rw [← (Ideal.Quotient.eq_zero_iff_mem.mpr h), eval₂_eq_sum_range]\n  nth_rw 3 [(as_sum_range_C_mul_X_pow g)]\n  simp only [map_sum, algebraMap_eq, RingHom.coe_comp, Function.comp_apply, map_mul, map_pow]⟩\n\n/- If `I` is an ideal of the polynomial ring `S[X]` and contains a monic polynomial `f`,\nthen `S[X]/I` is integral over `S`. -/\n"}
{"name":"Polynomial.Monic.quotient_isIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"S : Type u_4\ninst✝ : CommRing S\ng : Polynomial S\nmon : g.Monic\nI : Ideal (Polynomial S)\nh : Membership.mem I g\n⊢ ((Ideal.Quotient.mkₐ S I).comp (Algebra.ofId S (Polynomial S))).IsIntegral","decl":"lemma Polynomial.Monic.quotient_isIntegral {g : S[X]} (mon : g.Monic) {I : Ideal S[X]} (h : g ∈ I) :\n    ((Ideal.Quotient.mkₐ S I).comp (Algebra.ofId S S[X])).IsIntegral := by\n  have eq_top : Algebra.adjoin S {(Ideal.Quotient.mkₐ S I) X} = ⊤ := by\n    ext g\n    constructor\n    · simp only [Algebra.mem_top, implies_true]\n    · intro _\n      obtain ⟨g', hg⟩ := Ideal.Quotient.mkₐ_surjective S I g\n      have : g = (Polynomial.aeval ((Ideal.Quotient.mkₐ S I) X)) g' := by\n        nth_rw 1 [← hg, aeval_eq_sum_range' (lt_add_one _),\n          as_sum_range_C_mul_X_pow g', map_sum]\n        simp only [Polynomial.C_mul', ← map_pow, map_smul]\n      exact this ▸ (aeval_mem_adjoin_singleton S ((Ideal.Quotient.mk I) Polynomial.X))\n  exact fun a ↦ (eq_top ▸ (adjoin_le_integralClosure (mon.quotient_isIntegralElem h)))\n    Algebra.mem_top\n\n"}
{"name":"integralClosure.isIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ IsIntegralClosure (Subtype fun x => Membership.mem (integralClosure R A) x) R A","decl":"instance integralClosure.isIntegralClosure (R A : Type*) [CommRing R] [CommRing A] [Algebra R A] :\n    IsIntegralClosure (integralClosure R A) R A where\n  algebraMap_injective' := Subtype.coe_injective\n  isIntegral_iff {x} := ⟨fun h => ⟨⟨x, h⟩, rfl⟩, by rintro ⟨⟨_, h⟩, rfl⟩; exact h⟩\n\n"}
{"name":"IsIntegralClosure.algebraMap_injective","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"A : Type u_1\nR : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommSemiring A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsIntegralClosure A R B\n⊢ Function.Injective ⇑(algebraMap A B)","decl":"theorem algebraMap_injective (A R B : Type*) [CommRing R] [CommSemiring A] [CommRing B]\n    [Algebra R B] [Algebra A B] [IsIntegralClosure A R B] : Function.Injective (algebraMap A B) :=\n  algebraMap_injective' R\n\n"}
{"name":"IsIntegralClosure.isIntegral","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsIntegralClosure A R B\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A B\nx : A\n⊢ IsIntegral R x","decl":"protected theorem isIntegral [Algebra R A] [IsScalarTower R A B] (x : A) : IsIntegral R x :=\n  (isIntegral_algebraMap_iff (algebraMap_injective A R B)).mp <|\n    show IsIntegral R (algebraMap A B x) from isIntegral_iff.mpr ⟨x, rfl⟩\n\n"}
{"name":"IsIntegralClosure.isIntegral_algebra","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsIntegralClosure A R B\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A B\n⊢ Algebra.IsIntegral R A","decl":"theorem isIntegral_algebra [Algebra R A] [IsScalarTower R A B] : Algebra.IsIntegral R A :=\n  ⟨fun x => IsIntegralClosure.isIntegral R B x⟩\n\n"}
{"name":"IsIntegralClosure.noZeroSMulDivisors","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : IsIntegralClosure A R B\ninst✝² : Algebra R A\ninst✝¹ : IsScalarTower R A B\ninst✝ : NoZeroSMulDivisors R B\n⊢ NoZeroSMulDivisors R A","decl":"theorem noZeroSMulDivisors [Algebra R A] [IsScalarTower R A B] [NoZeroSMulDivisors R B] :\n    NoZeroSMulDivisors R A := by\n  refine\n    Function.Injective.noZeroSMulDivisors _ (IsIntegralClosure.algebraMap_injective A R B)\n      (map_zero _) fun _ _ => ?_\n  simp only [Algebra.algebraMap_eq_smul_one, IsScalarTower.smul_assoc]\n\n"}
{"name":"IsIntegralClosure.algebraMap_mk'","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsIntegralClosure A R B\nx : B\nhx : IsIntegral R x\n⊢ Eq ((algebraMap A B) (IsIntegralClosure.mk' A x hx)) x","decl":"@[simp]\ntheorem algebraMap_mk' (x : B) (hx : IsIntegral R x) : algebraMap A B (mk' A x hx) = x :=\n  Classical.choose_spec (isIntegral_iff.mp hx)\n\n"}
{"name":"IsIntegralClosure.mk'_one","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsIntegralClosure A R B\nh : optParam (IsIntegral R 1) ⋯\n⊢ Eq (IsIntegralClosure.mk' A 1 h) 1","decl":"@[simp]\ntheorem mk'_one (h : IsIntegral R (1 : B) := isIntegral_one) : mk' A 1 h = 1 :=\n  algebraMap_injective A R B <| by rw [algebraMap_mk', RingHom.map_one]\n\n"}
{"name":"IsIntegralClosure.mk'_zero","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsIntegralClosure A R B\nh : optParam (IsIntegral R 0) ⋯\n⊢ Eq (IsIntegralClosure.mk' A 0 h) 0","decl":"@[simp]\ntheorem mk'_zero (h : IsIntegral R (0 : B) := isIntegral_zero) : mk' A 0 h = 0 :=\n  algebraMap_injective A R B <| by rw [algebraMap_mk', RingHom.map_zero]\n\n-- Porting note: Left-hand side does not simplify @[simp]\n"}
{"name":"IsIntegralClosure.mk'_add","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsIntegralClosure A R B\nx y : B\nhx : IsIntegral R x\nhy : IsIntegral R y\n⊢ Eq (IsIntegralClosure.mk' A (HAdd.hAdd x y) ⋯) (HAdd.hAdd (IsIntegralClosure.mk' A x hx) (IsIntegralClosure.mk' A y hy))","decl":"theorem mk'_add (x y : B) (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    mk' A (x + y) (hx.add hy) = mk' A x hx + mk' A y hy :=\n  algebraMap_injective A R B <| by simp only [algebraMap_mk', RingHom.map_add]\n\n-- Porting note: Left-hand side does not simplify @[simp]\n"}
{"name":"IsIntegralClosure.mk'_mul","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing A\ninst✝³ : CommRing B\ninst✝² : Algebra R B\ninst✝¹ : Algebra A B\ninst✝ : IsIntegralClosure A R B\nx y : B\nhx : IsIntegral R x\nhy : IsIntegral R y\n⊢ Eq (IsIntegralClosure.mk' A (HMul.hMul x y) ⋯) (HMul.hMul (IsIntegralClosure.mk' A x hx) (IsIntegralClosure.mk' A y hy))","decl":"theorem mk'_mul (x y : B) (hx : IsIntegral R x) (hy : IsIntegral R y) :\n    mk' A (x * y) (hx.mul hy) = mk' A x hx * mk' A y hy :=\n  algebraMap_injective A R B <| by simp only [algebraMap_mk', RingHom.map_mul]\n\n"}
{"name":"IsIntegralClosure.mk'_algebraMap","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : CommRing B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsIntegralClosure A R B\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A B\nx : R\nh : optParam (IsIntegral R ((algebraMap R B) x)) ⋯\n⊢ Eq (IsIntegralClosure.mk' A ((algebraMap R B) x) h) ((algebraMap R A) x)","decl":"@[simp]\ntheorem mk'_algebraMap [Algebra R A] [IsScalarTower R A B] (x : R)\n    (h : IsIntegral R (algebraMap R B x) := isIntegral_algebraMap) :\n    IsIntegralClosure.mk' A (algebraMap R B x) h = algebraMap R A x :=\n  algebraMap_injective A R B <| by rw [algebraMap_mk', ← IsScalarTower.algebraMap_apply]\n\n"}
{"name":"IsIntegralClosure.isField","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : IsIntegralClosure A R B\ninst✝² : Algebra R A\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsDomain A\nhR : IsField R\n⊢ IsField A","decl":"/-- The integral closure of a field in a commutative domain is always a field. -/\ntheorem isField [Algebra R A] [IsScalarTower R A B] [IsDomain A] (hR : IsField R) :\n    IsField A :=\n  have := IsIntegralClosure.isIntegral_algebra R (A := A) B\n  isField_of_isIntegral_of_isField' hR\n\n"}
{"name":"IsIntegralClosure.algebraMap_lift","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : CommRing A\ninst✝⁹ : CommRing B\ninst✝⁸ : Algebra R B\ninst✝⁷ : Algebra A B\ninst✝⁶ : IsIntegralClosure A R B\nS : Type u_4\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\ninst✝³ : Algebra S B\ninst✝² : IsScalarTower R S B\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A B\nisIntegral : Algebra.IsIntegral R S\nx : S\n⊢ Eq ((algebraMap A B) ((IsIntegralClosure.lift R A B) x)) ((algebraMap S B) x)","decl":"@[simp]\ntheorem algebraMap_lift (x : S) : algebraMap A B (lift R A B x) = algebraMap S B x :=\n  algebraMap_mk' A (algebraMap S B x) (IsIntegral.algebraMap\n    (Algebra.IsIntegral.isIntegral (R := R) x))\n\n"}
{"name":"IsIntegralClosure.algebraMap_equiv","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝¹² : CommRing R\ninst✝¹¹ : CommRing A\ninst✝¹⁰ : CommRing B\ninst✝⁹ : Algebra R B\ninst✝⁸ : Algebra A B\ninst✝⁷ : IsIntegralClosure A R B\nA' : Type u_4\ninst✝⁶ : CommRing A'\ninst✝⁵ : Algebra A' B\ninst✝⁴ : IsIntegralClosure A' R B\ninst✝³ : Algebra R A\ninst✝² : Algebra R A'\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsScalarTower R A' B\nx : A\n⊢ Eq ((algebraMap A' B) ((IsIntegralClosure.equiv R A B A') x)) ((algebraMap A B) x)","decl":"@[simp]\ntheorem algebraMap_equiv (x : A) : algebraMap A' B (equiv R A B A' x) = algebraMap A B x :=\n  algebraMap_lift R A' B (isIntegral := isIntegral_algebra R B) x\n\n"}
{"name":"isIntegral_trans","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing A\ninst✝⁵ : Ring B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra R B\ninst✝² : Algebra R A\ninst✝¹ : IsScalarTower R A B\ninst✝ : Algebra.IsIntegral R A\nx : B\nhx : IsIntegral A x\n⊢ IsIntegral R x","decl":"/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R. -/\ntheorem isIntegral_trans [Algebra.IsIntegral R A] (x : B) (hx : IsIntegral A x) :\n    IsIntegral R x := by\n  rcases hx with ⟨p, pmonic, hp⟩\n  let S := adjoin R (p.coeffs : Set A)\n  have : Module.Finite R S := ⟨(Subalgebra.toSubmodule S).fg_top.mpr <|\n    fg_adjoin_of_finite p.coeffs.finite_toSet fun a _ ↦ Algebra.IsIntegral.isIntegral a⟩\n  let p' : S[X] := p.toSubring S.toSubring subset_adjoin\n  have hSx : IsIntegral S x := ⟨p', (p.monic_toSubring _ _).mpr pmonic, by\n    rw [IsScalarTower.algebraMap_eq S A B, ← eval₂_map]\n    convert hp; apply p.map_toSubring S.toSubring⟩\n  let Sx := Subalgebra.toSubmodule (adjoin S {x})\n  let MSx : Module S Sx := SMulMemClass.toModule _ -- the next line times out without this\n  have : Module.Finite S Sx := ⟨(Submodule.fg_top _).mpr hSx.fg_adjoin_singleton⟩\n  refine .of_mem_of_fg ((adjoin S {x}).restrictScalars R) ?_ _\n    ((Subalgebra.mem_restrictScalars R).mpr <| subset_adjoin rfl)\n  rw [← Submodule.fg_top, ← Module.finite_def]\n  letI : SMul S Sx := { MSx with } -- need this even though MSx is there\n  have : IsScalarTower R S Sx :=\n    Submodule.isScalarTower Sx -- Lean looks for `Module A Sx` without this\n  exact Module.Finite.trans S Sx\n\n"}
{"name":"Algebra.IsIntegral.trans","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing A\ninst✝⁶ : Ring B\ninst✝⁵ : Algebra A B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra R A\ninst✝² : IsScalarTower R A B\ninst✝¹ : Algebra.IsIntegral R A\ninst✝ : Algebra.IsIntegral A B\n⊢ Algebra.IsIntegral R B","decl":"variable (A) in\n/-- If A is an R-algebra all of whose elements are integral over R,\nand B is an A-algebra all of whose elements are integral over A,\nthen all elements of B are integral over R. -/\nprotected theorem Algebra.IsIntegral.trans\n    [Algebra.IsIntegral R A] [Algebra.IsIntegral A B] : Algebra.IsIntegral R B :=\n  ⟨fun x ↦ isIntegral_trans x (Algebra.IsIntegral.isIntegral (R := A) x)⟩\n\n"}
{"name":"RingHom.IsIntegral.trans","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nT : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : CommRing T\nf : RingHom R S\ng : RingHom S T\nhf : f.IsIntegral\nhg : g.IsIntegral\n⊢ (g.comp f).IsIntegral","decl":"protected theorem RingHom.IsIntegral.trans\n    (hf : f.IsIntegral) (hg : g.IsIntegral) : (g.comp f).IsIntegral :=\n  let _ := f.toAlgebra; let _ := g.toAlgebra; let _ := (g.comp f).toAlgebra\n  have : IsScalarTower R S T := IsScalarTower.of_algebraMap_eq fun _ ↦ rfl\n  have : Algebra.IsIntegral R S := ⟨hf⟩\n  have : Algebra.IsIntegral S T := ⟨hg⟩\n  have : Algebra.IsIntegral R T := Algebra.IsIntegral.trans S\n  Algebra.IsIntegral.isIntegral\n\n"}
{"name":"IsIntegralClosure.tower_top","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing A\ninst✝⁸ : Algebra R A\nB : Type u_6\nC : Type u_7\ninst✝⁷ : CommRing C\ninst✝⁶ : CommRing B\ninst✝⁵ : Algebra R B\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra C B\ninst✝² : IsScalarTower R A B\ninst✝¹ : IsIntegralClosure C R B\ninst✝ : Algebra.IsIntegral R A\n⊢ IsIntegralClosure C A B","decl":"/-- If `R → A → B` is an algebra tower, `C` is the integral closure of `R` in `B`\nand `A` is integral over `R`, then `C` is the integral closure of `A` in `B`. -/\nlemma IsIntegralClosure.tower_top {B C : Type*} [CommRing C] [CommRing B]\n    [Algebra R B] [Algebra A B] [Algebra C B] [IsScalarTower R A B]\n    [IsIntegralClosure C R B] [Algebra.IsIntegral R A] :\n    IsIntegralClosure C A B :=\n  ⟨IsIntegralClosure.algebraMap_injective _ R _,\n   fun hx => (IsIntegralClosure.isIntegral_iff).mp (isIntegral_trans (R := R) _ hx),\n   fun hx => ((IsIntegralClosure.isIntegral_iff (R := R)).mpr hx).tower_top⟩\n\n"}
{"name":"RingHom.isIntegral_of_surjective","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ f.IsIntegral","decl":"theorem RingHom.isIntegral_of_surjective (hf : Function.Surjective f) : f.IsIntegral :=\n  fun x ↦ (hf x).recOn fun _y hy ↦ hy ▸ f.isIntegralElem_map\n\n"}
{"name":"Algebra.isIntegral_of_surjective","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\nh : Function.Surjective ⇑(algebraMap R A)\n⊢ Algebra.IsIntegral R A","decl":"theorem Algebra.isIntegral_of_surjective (h : Function.Surjective (algebraMap R A)) :\n    Algebra.IsIntegral R A :=\n  ⟨(algebraMap R A).isIntegral_of_surjective h⟩\n\n"}
{"name":"IsIntegral.tower_bot","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : Ring B\ninst✝³ : Algebra A B\ninst✝² : Algebra R B\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A B\nH : Function.Injective ⇑(algebraMap A B)\nx : A\nh : IsIntegral R ((algebraMap A B) x)\n⊢ IsIntegral R x","decl":"/-- If `R → A → B` is an algebra tower with `A → B` injective,\nthen if the entire tower is an integral extension so is `R → A` -/\ntheorem IsIntegral.tower_bot (H : Function.Injective (algebraMap A B)) {x : A}\n    (h : IsIntegral R (algebraMap A B x)) : IsIntegral R x :=\n  (isIntegral_algHom_iff (IsScalarTower.toAlgHom R A B) H).mp h\n\n"}
{"name":"RingHom.IsIntegral.tower_bot","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nT : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : CommRing T\nf : RingHom R S\ng : RingHom S T\nhg : Function.Injective ⇑g\nhfg : (g.comp f).IsIntegral\n⊢ f.IsIntegral","decl":"nonrec theorem RingHom.IsIntegral.tower_bot (hg : Function.Injective g)\n    (hfg : (g.comp f).IsIntegral) : f.IsIntegral :=\n  letI := f.toAlgebra; letI := g.toAlgebra; letI := (g.comp f).toAlgebra\n  haveI : IsScalarTower R S T := IsScalarTower.of_algebraMap_eq fun _ ↦ rfl\n  fun x ↦ IsIntegral.tower_bot hg (hfg (g x))\n\n"}
{"name":"Algebra.IsIntegral.tower_bot","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nT : Type u_5\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : CommRing T\ninst✝⁵ : Algebra R S\ninst✝⁴ : Algebra R T\ninst✝³ : Algebra S T\ninst✝² : NoZeroSMulDivisors S T\ninst✝¹ : Nontrivial T\ninst✝ : IsScalarTower R S T\nh : Algebra.IsIntegral R T\n⊢ Algebra.IsIntegral R S","decl":"variable (T) in\n/-- Let `T / S / R` be a tower of algebras, `T` is non-trivial and is a torsion free `S`-module,\n  then if `T` is an integral `R`-algebra, then `S` is an integral `R`-algebra. -/\ntheorem Algebra.IsIntegral.tower_bot [Algebra R S] [Algebra R T] [Algebra S T]\n    [NoZeroSMulDivisors S T] [Nontrivial T] [IsScalarTower R S T]\n    [h : Algebra.IsIntegral R T] : Algebra.IsIntegral R S where\n  isIntegral := by\n    apply RingHom.IsIntegral.tower_bot (algebraMap R S) (algebraMap S T)\n      (NoZeroSMulDivisors.algebraMap_injective S T)\n    rw [← IsScalarTower.algebraMap_eq R S T]\n    exact h.isIntegral\n\n"}
{"name":"IsIntegral.tower_bot_of_field","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_6\nA : Type u_7\nB : Type u_8\ninst✝⁷ : CommRing R\ninst✝⁶ : Field A\ninst✝⁵ : CommRing B\ninst✝⁴ : Nontrivial B\ninst✝³ : Algebra R A\ninst✝² : Algebra A B\ninst✝¹ : Algebra R B\ninst✝ : IsScalarTower R A B\nx : A\nh : IsIntegral R ((algebraMap A B) x)\n⊢ IsIntegral R x","decl":"theorem IsIntegral.tower_bot_of_field {R A B : Type*} [CommRing R] [Field A]\n    [CommRing B] [Nontrivial B] [Algebra R A] [Algebra A B] [Algebra R B] [IsScalarTower R A B]\n    {x : A} (h : IsIntegral R (algebraMap A B x)) : IsIntegral R x :=\n  h.tower_bot (algebraMap A B).injective\n\n"}
{"name":"RingHom.isIntegralElem.of_comp","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nT : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : CommRing T\nf : RingHom R S\ng : RingHom S T\nx : T\nh : (g.comp f).IsIntegralElem x\n⊢ g.IsIntegralElem x","decl":"theorem RingHom.isIntegralElem.of_comp {x : T} (h : (g.comp f).IsIntegralElem x) :\n    g.IsIntegralElem x :=\n  let ⟨p, hp, hp'⟩ := h\n  ⟨p.map f, hp.map f, by rwa [← eval₂_map] at hp'⟩\n\n"}
{"name":"RingHom.IsIntegral.tower_top","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nT : Type u_5\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : CommRing T\nf : RingHom R S\ng : RingHom S T\nh : (g.comp f).IsIntegral\n⊢ g.IsIntegral","decl":"theorem RingHom.IsIntegral.tower_top (h : (g.comp f).IsIntegral) : g.IsIntegral :=\n  fun x ↦ RingHom.isIntegralElem.of_comp f g (h x)\n\n"}
{"name":"Algebra.IsIntegral.tower_top","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\nT : Type u_5\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : CommRing T\ninst✝³ : Algebra R S\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nh : Algebra.IsIntegral R T\n⊢ Algebra.IsIntegral S T","decl":"variable (R) in\n/-- Let `T / S / R` be a tower of algebras, `T` is an integral `R`-algebra, then it is integral\n  as an `S`-algebra. -/\ntheorem Algebra.IsIntegral.tower_top [Algebra R S] [Algebra R T] [Algebra S T] [IsScalarTower R S T]\n    [h : Algebra.IsIntegral R T] : Algebra.IsIntegral S T where\n  isIntegral := by\n    apply RingHom.IsIntegral.tower_top (algebraMap R S) (algebraMap S T)\n    rw [← IsScalarTower.algebraMap_eq R S T]\n    exact h.isIntegral\n\n"}
{"name":"RingHom.IsIntegral.quotient","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nI : Ideal S\nhf : f.IsIntegral\n⊢ (Ideal.quotientMap I f ⋯).IsIntegral","decl":"theorem RingHom.IsIntegral.quotient {I : Ideal S} (hf : f.IsIntegral) :\n    (Ideal.quotientMap I f le_rfl).IsIntegral := by\n  rintro ⟨x⟩\n  obtain ⟨p, p_monic, hpx⟩ := hf x\n  refine ⟨p.map (Ideal.Quotient.mk _), p_monic.map _, ?_⟩\n  simpa only [hom_eval₂, eval₂_map] using congr_arg (Ideal.Quotient.mk I) hpx\n\n"}
{"name":"instIsIntegralQuotientIdeal","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nI : Ideal A\ninst✝ : Algebra.IsIntegral R A\n⊢ Algebra.IsIntegral R (HasQuotient.Quotient A I)","decl":"instance {I : Ideal A} [Algebra.IsIntegral R A] : Algebra.IsIntegral R (A ⧸ I) :=\n  Algebra.IsIntegral.trans A\n\n"}
{"name":"Algebra.IsIntegral.quotient","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\nI : Ideal A\ninst✝ : Algebra.IsIntegral R A\n⊢ Algebra.IsIntegral (HasQuotient.Quotient R (Ideal.comap (algebraMap R A) I)) (HasQuotient.Quotient A I)","decl":"instance Algebra.IsIntegral.quotient {I : Ideal A} [Algebra.IsIntegral R A] :\n    Algebra.IsIntegral (R ⧸ I.comap (algebraMap R A)) (A ⧸ I) :=\n  ⟨RingHom.IsIntegral.quotient (algebraMap R A) Algebra.IsIntegral.isIntegral⟩\n\n"}
{"name":"isIntegral_quotientMap_iff","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝¹ : CommRing R\ninst✝ : CommRing S\nf : RingHom R S\nI : Ideal S\n⊢ Iff (Ideal.quotientMap I f ⋯).IsIntegral ((Ideal.Quotient.mk I).comp f).IsIntegral","decl":"theorem isIntegral_quotientMap_iff {I : Ideal S} :\n    (Ideal.quotientMap I f le_rfl).IsIntegral ↔\n      ((Ideal.Quotient.mk I).comp f : R →+* S ⧸ I).IsIntegral := by\n  let g := Ideal.Quotient.mk (I.comap f)\n  -- Porting note: added type ascription\n  have : (Ideal.quotientMap I f le_rfl).comp g = (Ideal.Quotient.mk I).comp f :=\n    Ideal.quotientMap_comp_mk le_rfl\n  refine ⟨fun h => ?_, fun h => RingHom.IsIntegral.tower_top g _ (this ▸ h)⟩\n  refine this ▸ RingHom.IsIntegral.trans g (Ideal.quotientMap I f le_rfl) ?_ h\n  exact g.isIntegral_of_surjective Ideal.Quotient.mk_surjective\n\n"}
{"name":"isField_of_isIntegral_of_isField","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_6\nS : Type u_7\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsIntegral R S\nhRS : Function.Injective ⇑(algebraMap R S)\nhS : IsField S\n⊢ IsField R","decl":"/-- If the integral extension `R → S` is injective, and `S` is a field, then `R` is also a field. -/\ntheorem isField_of_isIntegral_of_isField {R S : Type*} [CommRing R] [CommRing S]\n    [Algebra R S] [Algebra.IsIntegral R S]\n    (hRS : Function.Injective (algebraMap R S)) (hS : IsField S) : IsField R := by\n  have := hS.nontrivial; have := Module.nontrivial R S\n  refine ⟨⟨0, 1, zero_ne_one⟩, mul_comm, fun {a} ha ↦ ?_⟩\n  -- Let `a_inv` be the inverse of `algebraMap R S a`,\n  -- then we need to show that `a_inv` is of the form `algebraMap R S b`.\n  obtain ⟨a_inv, ha_inv⟩ := hS.mul_inv_cancel fun h ↦ ha (hRS (h.trans (RingHom.map_zero _).symm))\n  letI : Invertible a_inv := (Units.mkOfMulEqOne a_inv _ <| mul_comm _ a_inv ▸ ha_inv).invertible\n  -- Let `p : R[X]` be monic with root `a_inv`,\n  obtain ⟨p, p_monic, hp⟩ := Algebra.IsIntegral.isIntegral (R := R) a_inv\n  -- and `q` be `p` with coefficients reversed (so `q(a) = q'(a) * a + 1`).\n  -- We have `q(a) = 0`, so `-q'(a)` is the inverse of `a`.\n  use -p.reverse.divX.eval a -- -q'(a)\n  nth_rewrite 1 [mul_neg, ← eval_X (x := a), ← eval_mul, ← p_monic, ← coeff_zero_reverse,\n    ← add_eq_zero_iff_neg_eq, ← eval_C (a := p.reverse.coeff 0), ← eval_add, X_mul_divX_add,\n    ← (injective_iff_map_eq_zero' _).mp hRS, ← aeval_algebraMap_apply_eq_algebraMap_eval]\n  rwa [← eval₂_reverse_eq_zero_iff] at hp\n\n"}
{"name":"Algebra.IsIntegral.isField_iff_isField","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_6\nS : Type u_7\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : IsDomain S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.IsIntegral R S\nhRS : Function.Injective ⇑(algebraMap R S)\n⊢ Iff (IsField R) (IsField S)","decl":"theorem Algebra.IsIntegral.isField_iff_isField {R S : Type*} [CommRing R]\n    [CommRing S] [IsDomain S] [Algebra R S] [Algebra.IsIntegral R S]\n    (hRS : Function.Injective (algebraMap R S)) : IsField R ↔ IsField S :=\n  ⟨isField_of_isIntegral_of_isField', isField_of_isIntegral_of_isField hRS⟩\n\n"}
{"name":"integralClosure_idem","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ Eq (integralClosure (Subtype fun x => Membership.mem (integralClosure R A) x) A) Bot.bot","decl":"theorem integralClosure_idem {R A : Type*} [CommRing R] [CommRing A] [Algebra R A] :\n    integralClosure (integralClosure R A) A = ⊥ :=\n  letI := (integralClosure R A).algebra\n  eq_bot_iff.2 fun x hx ↦ Algebra.mem_bot.2\n    ⟨⟨x, isIntegral_trans (A := integralClosure R A) x hx⟩, rfl⟩\n\n"}
{"name":"instIsDomainSubtypeMemSubalgebraIntegralClosure","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\n⊢ IsDomain (Subtype fun x => Membership.mem (integralClosure R S) x)","decl":"instance : IsDomain (integralClosure R S) :=\n  inferInstance\n\n"}
{"name":"roots_mem_integralClosure","module":"Mathlib.RingTheory.IntegralClosure.IsIntegralClosure.Basic","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : IsDomain S\ninst✝ : Algebra R S\nf : Polynomial R\nhf : f.Monic\na : S\nha : Membership.mem (f.aroots S) a\n⊢ Membership.mem (integralClosure R S) a","decl":"theorem roots_mem_integralClosure {f : R[X]} (hf : f.Monic) {a : S}\n    (ha : a ∈ f.aroots S) : a ∈ integralClosure R S :=\n  ⟨f, hf, (eval₂_eq_eval_map _).trans <| (mem_roots <| (hf.map _).ne_zero).1 ha⟩\n\n"}
