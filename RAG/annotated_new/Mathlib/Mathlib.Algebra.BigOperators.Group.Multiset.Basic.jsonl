{"name":"Multiset.sum_erase","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : AddCommMonoid α\ns : Multiset α\na : α\ninst✝ : DecidableEq α\nh : Membership.mem s a\n⊢ Eq (HAdd.hAdd a (s.erase a).sum) s.sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_erase [DecidableEq α] (h : a ∈ s) : a * (s.erase a).prod = s.prod := by\n  rw [← s.coe_toList, coe_erase, prod_coe, prod_coe, List.prod_erase (mem_toList.2 h)]\n\n"}
{"name":"Multiset.prod_erase","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : CommMonoid α\ns : Multiset α\na : α\ninst✝ : DecidableEq α\nh : Membership.mem s a\n⊢ Eq (HMul.hMul a (s.erase a).prod) s.prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_erase [DecidableEq α] (h : a ∈ s) : a * (s.erase a).prod = s.prod := by\n  rw [← s.coe_toList, coe_erase, prod_coe, prod_coe, List.prod_erase (mem_toList.2 h)]\n\n"}
{"name":"Multiset.sum_map_erase","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝¹ : AddCommMonoid α\nm : Multiset ι\nf : ι → α\ninst✝ : DecidableEq ι\na : ι\nh : Membership.mem m a\n⊢ Eq (HAdd.hAdd (f a) (Multiset.map f (m.erase a)).sum) (Multiset.map f m).sum","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_erase [DecidableEq ι] {a : ι} (h : a ∈ m) :\n    f a * ((m.erase a).map f).prod = (m.map f).prod := by\n  rw [← m.coe_toList, coe_erase, map_coe, map_coe, prod_coe, prod_coe,\n    List.prod_map_erase f (mem_toList.2 h)]\n\n"}
{"name":"Multiset.prod_map_erase","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝¹ : CommMonoid α\nm : Multiset ι\nf : ι → α\ninst✝ : DecidableEq ι\na : ι\nh : Membership.mem m a\n⊢ Eq (HMul.hMul (f a) (Multiset.map f (m.erase a)).prod) (Multiset.map f m).prod","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_erase [DecidableEq ι] {a : ι} (h : a ∈ m) :\n    f a * ((m.erase a).map f).prod = (m.map f).prod := by\n  rw [← m.coe_toList, coe_erase, map_coe, map_coe, prod_coe, prod_coe,\n    List.prod_map_erase f (mem_toList.2 h)]\n\n"}
{"name":"Multiset.sum_add","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s t).sum (HAdd.hAdd s.sum t.sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_add (s t : Multiset α) : prod (s + t) = prod s * prod t :=\n  Quotient.inductionOn₂ s t fun l₁ l₂ => by simp\n\n"}
{"name":"Multiset.prod_add","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns t : Multiset α\n⊢ Eq (HAdd.hAdd s t).prod (HMul.hMul s.prod t.prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_add (s t : Multiset α) : prod (s + t) = prod s * prod t :=\n  Quotient.inductionOn₂ s t fun l₁ l₂ => by simp\n\n"}
{"name":"Multiset.sum_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\nm : Multiset α\nn : Nat\n⊢ Eq (HSMul.hSMul n m).sum (HSMul.hSMul n m.sum)","decl":"@[to_additive]\ntheorem prod_nsmul (m : Multiset α) : ∀ n : ℕ, (n • m).prod = m.prod ^ n\n  | 0 => by\n    rw [zero_nsmul, pow_zero]\n    rfl\n  | n + 1 => by rw [add_nsmul, one_nsmul, pow_add, pow_one, prod_add, prod_nsmul m n]\n\n"}
{"name":"Multiset.prod_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\nm : Multiset α\nn : Nat\n⊢ Eq (HSMul.hSMul n m).prod (HPow.hPow m.prod n)","decl":"@[to_additive]\ntheorem prod_nsmul (m : Multiset α) : ∀ n : ℕ, (n • m).prod = m.prod ^ n\n  | 0 => by\n    rw [zero_nsmul, pow_zero]\n    rfl\n  | n + 1 => by rw [add_nsmul, one_nsmul, pow_add, pow_one, prod_add, prod_nsmul m n]\n\n"}
{"name":"Multiset.prod_filter_mul_prod_filter_not","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : CommMonoid α\ns : Multiset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (HMul.hMul (Multiset.filter p s).prod (Multiset.filter (fun a => Not (p a)) s).prod) s.prod","decl":"@[to_additive]\ntheorem prod_filter_mul_prod_filter_not (p) [DecidablePred p] :\n    (s.filter p).prod * (s.filter (fun a ↦ ¬ p a)).prod = s.prod := by\n  rw [← prod_add, filter_add_not]\n\n"}
{"name":"Multiset.sum_filter_add_sum_filter_not","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : AddCommMonoid α\ns : Multiset α\np : α → Prop\ninst✝ : DecidablePred p\n⊢ Eq (HAdd.hAdd (Multiset.filter p s).sum (Multiset.filter (fun a => Not (p a)) s).sum) s.sum","decl":"@[to_additive]\ntheorem prod_filter_mul_prod_filter_not (p) [DecidablePred p] :\n    (s.filter p).prod * (s.filter (fun a ↦ ¬ p a)).prod = s.prod := by\n  rw [← prod_add, filter_add_not]\n\n"}
{"name":"Multiset.prod_map_eq_pow_single","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝¹ : CommMonoid α\nm : Multiset ι\nf : ι → α\ninst✝ : DecidableEq ι\ni : ι\nhf : ∀ (i' : ι), Ne i' i → Membership.mem m i' → Eq (f i') 1\n⊢ Eq (Multiset.map f m).prod (HPow.hPow (f i) (Multiset.count i m))","decl":"@[to_additive]\ntheorem prod_map_eq_pow_single [DecidableEq ι] (i : ι)\n    (hf : ∀ i' ≠ i, i' ∈ m → f i' = 1) : (m.map f).prod = f i ^ m.count i := by\n  induction m using Quotient.inductionOn\n  simp [List.prod_map_eq_pow_single i f hf]\n\n"}
{"name":"Multiset.sum_map_eq_nsmul_single","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝¹ : AddCommMonoid α\nm : Multiset ι\nf : ι → α\ninst✝ : DecidableEq ι\ni : ι\nhf : ∀ (i' : ι), Ne i' i → Membership.mem m i' → Eq (f i') 0\n⊢ Eq (Multiset.map f m).sum (HSMul.hSMul (Multiset.count i m) (f i))","decl":"@[to_additive]\ntheorem prod_map_eq_pow_single [DecidableEq ι] (i : ι)\n    (hf : ∀ i' ≠ i, i' ∈ m → f i' = 1) : (m.map f).prod = f i ^ m.count i := by\n  induction m using Quotient.inductionOn\n  simp [List.prod_map_eq_pow_single i f hf]\n\n"}
{"name":"Multiset.prod_eq_pow_single","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : CommMonoid α\ns : Multiset α\ninst✝ : DecidableEq α\na : α\nh : ∀ (a' : α), Ne a' a → Membership.mem s a' → Eq a' 1\n⊢ Eq s.prod (HPow.hPow a (Multiset.count a s))","decl":"@[to_additive]\ntheorem prod_eq_pow_single [DecidableEq α] (a : α) (h : ∀ a' ≠ a, a' ∈ s → a' = 1) :\n    s.prod = a ^ s.count a := by\n  induction s using Quotient.inductionOn; simp [List.prod_eq_pow_single a h]\n\n"}
{"name":"Multiset.sum_eq_nsmul_single","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝¹ : AddCommMonoid α\ns : Multiset α\ninst✝ : DecidableEq α\na : α\nh : ∀ (a' : α), Ne a' a → Membership.mem s a' → Eq a' 0\n⊢ Eq s.sum (HSMul.hSMul (Multiset.count a s) a)","decl":"@[to_additive]\ntheorem prod_eq_pow_single [DecidableEq α] (a : α) (h : ∀ a' ≠ a, a' ∈ s → a' = 1) :\n    s.prod = a ^ s.count a := by\n  induction s using Quotient.inductionOn; simp [List.prod_eq_pow_single a h]\n\n"}
{"name":"Multiset.prod_eq_one","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\nh : ∀ (x : α), Membership.mem s x → Eq x 1\n⊢ Eq s.prod 1","decl":"@[to_additive]\nlemma prod_eq_one (h : ∀ x ∈ s, x = (1 : α)) : s.prod = 1 := by\n  induction s using Quotient.inductionOn; simp [List.prod_eq_one h]\n\n"}
{"name":"Multiset.sum_eq_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\ns : Multiset α\nh : ∀ (x : α), Membership.mem s x → Eq x 0\n⊢ Eq s.sum 0","decl":"@[to_additive]\nlemma prod_eq_one (h : ∀ x ∈ s, x = (1 : α)) : s.prod = 1 := by\n  induction s using Quotient.inductionOn; simp [List.prod_eq_one h]\n\n"}
{"name":"Multiset.sum_hom_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ns : Multiset α\nhs : Ne s 0\nF : Type u_7\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nf : F\n⊢ Eq (Multiset.map (⇑f) s).sum (f s.sum)","decl":"@[to_additive]\ntheorem prod_hom_ne_zero {s : Multiset α} (hs : s ≠ 0) {F : Type*} [FunLike F α β]\n    [MulHomClass F α β] (f : F) :\n    (s.map f).prod = f s.prod := by\n  induction s using Quot.inductionOn; aesop (add simp List.prod_hom_nonempty)\n\n"}
{"name":"Multiset.prod_hom_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\ns : Multiset α\nhs : Ne s 0\nF : Type u_7\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nf : F\n⊢ Eq (Multiset.map (⇑f) s).prod (f s.prod)","decl":"@[to_additive]\ntheorem prod_hom_ne_zero {s : Multiset α} (hs : s ≠ 0) {F : Type*} [FunLike F α β]\n    [MulHomClass F α β] (f : F) :\n    (s.map f).prod = f s.prod := by\n  induction s using Quot.inductionOn; aesop (add simp List.prod_hom_nonempty)\n\n"}
{"name":"Multiset.prod_hom","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\ns : Multiset α\nF : Type u_7\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\n⊢ Eq (Multiset.map (⇑f) s).prod (f s.prod)","decl":"@[to_additive]\ntheorem prod_hom (s : Multiset α) {F : Type*} [FunLike F α β]\n    [MonoidHomClass F α β] (f : F) :\n    (s.map f).prod = f s.prod :=\n  Quotient.inductionOn s fun l => by simp only [l.prod_hom f, quot_mk_to_coe, map_coe, prod_coe]\n\n"}
{"name":"Multiset.sum_hom","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ns : Multiset α\nF : Type u_7\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\n⊢ Eq (Multiset.map (⇑f) s).sum (f s.sum)","decl":"@[to_additive]\ntheorem prod_hom (s : Multiset α) {F : Type*} [FunLike F α β]\n    [MonoidHomClass F α β] (f : F) :\n    (s.map f).prod = f s.prod :=\n  Quotient.inductionOn s fun l => by simp only [l.prod_hom f, quot_mk_to_coe, map_coe, prod_coe]\n\n"}
{"name":"Multiset.prod_hom'","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\ns : Multiset ι\nF : Type u_7\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ng : ι → α\n⊢ Eq (Multiset.map (fun i => f (g i)) s).prod (f (Multiset.map g s).prod)","decl":"@[to_additive]\ntheorem prod_hom' (s : Multiset ι) {F : Type*} [FunLike F α β]\n    [MonoidHomClass F α β] (f : F)\n    (g : ι → α) : (s.map fun i => f <| g i).prod = f (s.map g).prod := by\n  convert (s.map g).prod_hom f\n  exact (map_map _ _ _).symm\n\n"}
{"name":"Multiset.sum_hom'","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ns : Multiset ι\nF : Type u_7\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\ng : ι → α\n⊢ Eq (Multiset.map (fun i => f (g i)) s).sum (f (Multiset.map g s).sum)","decl":"@[to_additive]\ntheorem prod_hom' (s : Multiset ι) {F : Type*} [FunLike F α β]\n    [MonoidHomClass F α β] (f : F)\n    (g : ι → α) : (s.map fun i => f <| g i).prod = f (s.map g).prod := by\n  convert (s.map g).prod_hom f\n  exact (map_map _ _ _).symm\n\n"}
{"name":"Multiset.sum_hom₂_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\nγ : Type u_6\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : AddCommMonoid γ\ns : Multiset ι\nhs : Ne s 0\nf : α → β → γ\nhf : ∀ (a b : α) (c d : β), Eq (f (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (f a c) (f b d))\nf₁ : ι → α\nf₂ : ι → β\n⊢ Eq (Multiset.map (fun i => f (f₁ i) (f₂ i)) s).sum (f (Multiset.map f₁ s).sum (Multiset.map f₂ s).sum)","decl":"@[to_additive]\ntheorem prod_hom₂_ne_zero [CommMonoid γ] {s : Multiset ι} (hs : s ≠ 0) (f : α → β → γ)\n    (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d) (f₁ : ι → α) (f₂ : ι → β) :\n    (s.map fun i => f (f₁ i) (f₂ i)).prod = f (s.map f₁).prod (s.map f₂).prod := by\n  induction s using Quotient.inductionOn; aesop (add simp List.prod_hom₂_nonempty)\n\n"}
{"name":"Multiset.prod_hom₂_ne_zero","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\nγ : Type u_6\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : CommMonoid γ\ns : Multiset ι\nhs : Ne s 0\nf : α → β → γ\nhf : ∀ (a b : α) (c d : β), Eq (f (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (f a c) (f b d))\nf₁ : ι → α\nf₂ : ι → β\n⊢ Eq (Multiset.map (fun i => f (f₁ i) (f₂ i)) s).prod (f (Multiset.map f₁ s).prod (Multiset.map f₂ s).prod)","decl":"@[to_additive]\ntheorem prod_hom₂_ne_zero [CommMonoid γ] {s : Multiset ι} (hs : s ≠ 0) (f : α → β → γ)\n    (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d) (f₁ : ι → α) (f₂ : ι → β) :\n    (s.map fun i => f (f₁ i) (f₂ i)).prod = f (s.map f₁).prod (s.map f₂).prod := by\n  induction s using Quotient.inductionOn; aesop (add simp List.prod_hom₂_nonempty)\n\n"}
{"name":"Multiset.sum_hom₂","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\nγ : Type u_6\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : AddCommMonoid γ\ns : Multiset ι\nf : α → β → γ\nhf : ∀ (a b : α) (c d : β), Eq (f (HAdd.hAdd a b) (HAdd.hAdd c d)) (HAdd.hAdd (f a c) (f b d))\nhf' : Eq (f 0 0) 0\nf₁ : ι → α\nf₂ : ι → β\n⊢ Eq (Multiset.map (fun i => f (f₁ i) (f₂ i)) s).sum (f (Multiset.map f₁ s).sum (Multiset.map f₂ s).sum)","decl":"@[to_additive]\ntheorem prod_hom₂ [CommMonoid γ] (s : Multiset ι) (f : α → β → γ)\n    (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d) (hf' : f 1 1 = 1) (f₁ : ι → α)\n    (f₂ : ι → β) : (s.map fun i => f (f₁ i) (f₂ i)).prod = f (s.map f₁).prod (s.map f₂).prod :=\n  Quotient.inductionOn s fun l => by\n    simp only [l.prod_hom₂ f hf hf', quot_mk_to_coe, map_coe, prod_coe]\n\n"}
{"name":"Multiset.prod_hom₂","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\nβ : Type u_4\nγ : Type u_6\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : CommMonoid γ\ns : Multiset ι\nf : α → β → γ\nhf : ∀ (a b : α) (c d : β), Eq (f (HMul.hMul a b) (HMul.hMul c d)) (HMul.hMul (f a c) (f b d))\nhf' : Eq (f 1 1) 1\nf₁ : ι → α\nf₂ : ι → β\n⊢ Eq (Multiset.map (fun i => f (f₁ i) (f₂ i)) s).prod (f (Multiset.map f₁ s).prod (Multiset.map f₂ s).prod)","decl":"@[to_additive]\ntheorem prod_hom₂ [CommMonoid γ] (s : Multiset ι) (f : α → β → γ)\n    (hf : ∀ a b c d, f (a * b) (c * d) = f a c * f b d) (hf' : f 1 1 = 1) (f₁ : ι → α)\n    (f₂ : ι → β) : (s.map fun i => f (f₁ i) (f₂ i)).prod = f (s.map f₁).prod (s.map f₂).prod :=\n  Quotient.inductionOn s fun l => by\n    simp only [l.prod_hom₂ f hf hf', quot_mk_to_coe, map_coe, prod_coe]\n\n"}
{"name":"Multiset.prod_map_mul","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : CommMonoid α\nm : Multiset ι\nf g : ι → α\n⊢ Eq (Multiset.map (fun i => HMul.hMul (f i) (g i)) m).prod (HMul.hMul (Multiset.map f m).prod (Multiset.map g m).prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_mul : (m.map fun i => f i * g i).prod = (m.map f).prod * (m.map g).prod :=\n  m.prod_hom₂ (· * ·) mul_mul_mul_comm (mul_one _) _ _\n\n"}
{"name":"Multiset.sum_map_add","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : AddCommMonoid α\nm : Multiset ι\nf g : ι → α\n⊢ Eq (Multiset.map (fun i => HAdd.hAdd (f i) (g i)) m).sum (HAdd.hAdd (Multiset.map f m).sum (Multiset.map g m).sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_mul : (m.map fun i => f i * g i).prod = (m.map f).prod * (m.map g).prod :=\n  m.prod_hom₂ (· * ·) mul_mul_mul_comm (mul_one _) _ _\n\n"}
{"name":"Multiset.prod_map_pow","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : CommMonoid α\nm : Multiset ι\nf : ι → α\nn : Nat\n⊢ Eq (Multiset.map (fun i => HPow.hPow (f i) n) m).prod (HPow.hPow (Multiset.map f m).prod n)","decl":"@[to_additive]\ntheorem prod_map_pow {n : ℕ} : (m.map fun i => f i ^ n).prod = (m.map f).prod ^ n :=\n  m.prod_hom' (powMonoidHom n : α →* α) f\n\n"}
{"name":"Multiset.sum_map_nsmul","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : AddCommMonoid α\nm : Multiset ι\nf : ι → α\nn : Nat\n⊢ Eq (Multiset.map (fun i => HSMul.hSMul n (f i)) m).sum (HSMul.hSMul n (Multiset.map f m).sum)","decl":"@[to_additive]\ntheorem prod_map_pow {n : ℕ} : (m.map fun i => f i ^ n).prod = (m.map f).prod ^ n :=\n  m.prod_hom' (powMonoidHom n : α →* α) f\n\n"}
{"name":"Multiset.prod_map_prod_map","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ' : Type u_5\nγ : Type u_6\ninst✝ : CommMonoid α\nm : Multiset β'\nn : Multiset γ\nf : β' → γ → α\n⊢ Eq (Multiset.map (fun a => (Multiset.map (fun b => f a b) n).prod) m).prod (Multiset.map (fun b => (Multiset.map (fun a => f a b) m).prod) n).prod","decl":"@[to_additive]\ntheorem prod_map_prod_map (m : Multiset β') (n : Multiset γ) {f : β' → γ → α} :\n    prod (m.map fun a => prod <| n.map fun b => f a b) =\n      prod (n.map fun b => prod <| m.map fun a => f a b) :=\n  Multiset.induction_on m (by simp) fun a m ih => by simp [ih]\n\n"}
{"name":"Multiset.sum_map_sum_map","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ' : Type u_5\nγ : Type u_6\ninst✝ : AddCommMonoid α\nm : Multiset β'\nn : Multiset γ\nf : β' → γ → α\n⊢ Eq (Multiset.map (fun a => (Multiset.map (fun b => f a b) n).sum) m).sum (Multiset.map (fun b => (Multiset.map (fun a => f a b) m).sum) n).sum","decl":"@[to_additive]\ntheorem prod_map_prod_map (m : Multiset β') (n : Multiset γ) {f : β' → γ → α} :\n    prod (m.map fun a => prod <| n.map fun b => f a b) =\n      prod (n.map fun b => prod <| m.map fun a => f a b) :=\n  Multiset.induction_on m (by simp) fun a m ih => by simp [ih]\n\n"}
{"name":"Multiset.prod_dvd_prod_of_le","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns t : Multiset α\nh : LE.le s t\n⊢ Dvd.dvd s.prod t.prod","decl":"theorem prod_dvd_prod_of_le (h : s ≤ t) : s.prod ∣ t.prod := by\n  obtain ⟨z, rfl⟩ := exists_add_of_le h\n  simp only [prod_add, dvd_mul_right]\n\n"}
{"name":"map_multiset_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MonoidHomClass F α β\nf : F\ns : Multiset α\n⊢ Eq (f s.prod) (Multiset.map (⇑f) s).prod","decl":"@[to_additive]\nlemma _root_.map_multiset_prod [FunLike F α β] [MonoidHomClass F α β] (f : F) (s : Multiset α) :\n    f s.prod = (s.map f).prod := (s.prod_hom f).symm\n\n"}
{"name":"map_multiset_sum","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddMonoidHomClass F α β\nf : F\ns : Multiset α\n⊢ Eq (f s.sum) (Multiset.map (⇑f) s).sum","decl":"@[to_additive]\nlemma _root_.map_multiset_prod [FunLike F α β] [MonoidHomClass F α β] (f : F) (s : Multiset α) :\n    f s.prod = (s.map f).prod := (s.prod_hom f).symm\n\n"}
{"name":"map_multiset_ne_zero_sum","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nf : F\ns : Multiset α\nhs : Ne s 0\n⊢ Eq (f s.sum) (Multiset.map (⇑f) s).sum","decl":"@[to_additive]\nlemma _root_.map_multiset_ne_zero_prod [FunLike F α β] [MulHomClass F α β] (f : F)\n    {s : Multiset α} (hs : s ≠ 0):\n    f s.prod = (s.map f).prod := (s.prod_hom_ne_zero hs f).symm\n\n"}
{"name":"map_multiset_ne_zero_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"F : Type u_1\nα : Type u_3\nβ : Type u_4\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nf : F\ns : Multiset α\nhs : Ne s 0\n⊢ Eq (f s.prod) (Multiset.map (⇑f) s).prod","decl":"@[to_additive]\nlemma _root_.map_multiset_ne_zero_prod [FunLike F α β] [MulHomClass F α β] (f : F)\n    {s : Multiset α} (hs : s ≠ 0):\n    f s.prod = (s.map f).prod := (s.prod_hom_ne_zero hs f).symm\n\n"}
{"name":"AddMonoidHom.map_multiset_sum","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nf : AddMonoidHom α β\ns : Multiset α\n⊢ Eq (f s.sum) (Multiset.map (⇑f) s).sum","decl":"@[to_additive]\nprotected lemma _root_.MonoidHom.map_multiset_prod (f : α →* β) (s : Multiset α) :\n    f s.prod = (s.map f).prod := (s.prod_hom f).symm\n\n"}
{"name":"MonoidHom.map_multiset_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nf : MonoidHom α β\ns : Multiset α\n⊢ Eq (f s.prod) (Multiset.map (⇑f) s).prod","decl":"@[to_additive]\nprotected lemma _root_.MonoidHom.map_multiset_prod (f : α →* β) (s : Multiset α) :\n    f s.prod = (s.map f).prod := (s.prod_hom f).symm\n\n"}
{"name":"AddHom.map_multiset_ne_zero_sum","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\nf : AddHom α β\ns : Multiset α\nhs : Ne s 0\n⊢ Eq (f s.sum) (Multiset.map (⇑f) s).sum","decl":"@[to_additive]\nprotected lemma _root_.MulHom.map_multiset_ne_zero_prod (f : α →ₙ* β) (s : Multiset α)\n    (hs : s ≠ 0) : f s.prod = (s.map f).prod := (s.prod_hom_ne_zero hs f).symm\n\n"}
{"name":"MulHom.map_multiset_ne_zero_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\nf : MulHom α β\ns : Multiset α\nhs : Ne s 0\n⊢ Eq (f s.prod) (Multiset.map (⇑f) s).prod","decl":"@[to_additive]\nprotected lemma _root_.MulHom.map_multiset_ne_zero_prod (f : α →ₙ* β) (s : Multiset α)\n    (hs : s ≠ 0) : f s.prod = (s.map f).prod := (s.prod_hom_ne_zero hs f).symm\n\n"}
{"name":"Multiset.dvd_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : CommMonoid α\ns : Multiset α\na : α\na✝ : Membership.mem s a\n⊢ Dvd.dvd a s.prod","decl":"lemma dvd_prod : a ∈ s → a ∣ s.prod :=\n  Quotient.inductionOn s (fun l a h ↦ by simpa using List.dvd_prod h) a\n\n"}
{"name":"Multiset.fst_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Multiset (Prod α β)\n⊢ Eq s.prod.1 (Multiset.map Prod.fst s).prod","decl":"@[to_additive] lemma fst_prod (s : Multiset (α × β)) : s.prod.1 = (s.map Prod.fst).prod :=\n  map_multiset_prod (MonoidHom.fst _ _) _\n\n"}
{"name":"Multiset.fst_sum","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Multiset (Prod α β)\n⊢ Eq s.sum.1 (Multiset.map Prod.fst s).sum","decl":"@[to_additive] lemma fst_prod (s : Multiset (α × β)) : s.prod.1 = (s.map Prod.fst).prod :=\n  map_multiset_prod (MonoidHom.fst _ _) _\n\n"}
{"name":"Multiset.snd_prod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Multiset (Prod α β)\n⊢ Eq s.prod.2 (Multiset.map Prod.snd s).prod","decl":"@[to_additive] lemma snd_prod (s : Multiset (α × β)) : s.prod.2 = (s.map Prod.snd).prod :=\n  map_multiset_prod (MonoidHom.snd _ _) _\n\n"}
{"name":"Multiset.snd_sum","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Multiset (Prod α β)\n⊢ Eq s.sum.2 (Multiset.map Prod.snd s).sum","decl":"@[to_additive] lemma snd_prod (s : Multiset (α × β)) : s.prod.2 = (s.map Prod.snd).prod :=\n  map_multiset_prod (MonoidHom.snd _ _) _\n\n"}
{"name":"Multiset.prod_dvd_prod_of_dvd","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : CommMonoid β\nS : Multiset α\ng1 g2 : α → β\nh : ∀ (a : α), Membership.mem S a → Dvd.dvd (g1 a) (g2 a)\n⊢ Dvd.dvd (Multiset.map g1 S).prod (Multiset.map g2 S).prod","decl":"theorem prod_dvd_prod_of_dvd [CommMonoid β] {S : Multiset α} (g1 g2 : α → β)\n    (h : ∀ a ∈ S, g1 a ∣ g2 a) : (Multiset.map g1 S).prod ∣ (Multiset.map g2 S).prod := by\n  apply Multiset.induction_on' S\n  · simp\n  intro a T haS _ IH\n  simp [mul_dvd_mul (h a haS) IH]\n\n"}
{"name":"Multiset.coe_sumAddMonoidHom","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : AddCommMonoid α\n⊢ Eq (⇑Multiset.sumAddMonoidHom) Multiset.sum","decl":"@[simp]\ntheorem coe_sumAddMonoidHom : (sumAddMonoidHom : Multiset α → α) = sum :=\n  rfl\n\n"}
{"name":"Multiset.sum_map_neg'","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : SubtractionCommMonoid α\nm : Multiset α\n⊢ Eq (Multiset.map Neg.neg m).sum (Neg.neg m.sum)","decl":"@[to_additive]\ntheorem prod_map_inv' (m : Multiset α) : (m.map Inv.inv).prod = m.prod⁻¹ :=\n  m.prod_hom (invMonoidHom : α →* α)\n\n"}
{"name":"Multiset.prod_map_inv'","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ninst✝ : DivisionCommMonoid α\nm : Multiset α\n⊢ Eq (Multiset.map Inv.inv m).prod (Inv.inv m.prod)","decl":"@[to_additive]\ntheorem prod_map_inv' (m : Multiset α) : (m.map Inv.inv).prod = m.prod⁻¹ :=\n  m.prod_hom (invMonoidHom : α →* α)\n\n"}
{"name":"Multiset.prod_map_inv","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : DivisionCommMonoid α\nm : Multiset ι\nf : ι → α\n⊢ Eq (Multiset.map (fun i => Inv.inv (f i)) m).prod (Inv.inv (Multiset.map f m).prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_inv : (m.map fun i => (f i)⁻¹).prod = (m.map f).prod⁻¹ := by\n  rw [← (m.map f).prod_map_inv', map_map, Function.comp_def]\n\n"}
{"name":"Multiset.sum_map_neg","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : SubtractionCommMonoid α\nm : Multiset ι\nf : ι → α\n⊢ Eq (Multiset.map (fun i => Neg.neg (f i)) m).sum (Neg.neg (Multiset.map f m).sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_inv : (m.map fun i => (f i)⁻¹).prod = (m.map f).prod⁻¹ := by\n  rw [← (m.map f).prod_map_inv', map_map, Function.comp_def]\n\n"}
{"name":"Multiset.sum_map_sub","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : SubtractionCommMonoid α\nm : Multiset ι\nf g : ι → α\n⊢ Eq (Multiset.map (fun i => HSub.hSub (f i) (g i)) m).sum (HSub.hSub (Multiset.map f m).sum (Multiset.map g m).sum)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_div : (m.map fun i => f i / g i).prod = (m.map f).prod / (m.map g).prod :=\n  m.prod_hom₂ (· / ·) mul_div_mul_comm (div_one _) _ _\n\n"}
{"name":"Multiset.prod_map_div","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : DivisionCommMonoid α\nm : Multiset ι\nf g : ι → α\n⊢ Eq (Multiset.map (fun i => HDiv.hDiv (f i) (g i)) m).prod (HDiv.hDiv (Multiset.map f m).prod (Multiset.map g m).prod)","decl":"@[to_additive (attr := simp)]\ntheorem prod_map_div : (m.map fun i => f i / g i).prod = (m.map f).prod / (m.map g).prod :=\n  m.prod_hom₂ (· / ·) mul_div_mul_comm (div_one _) _ _\n\n"}
{"name":"Multiset.sum_map_zsmul","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : SubtractionCommMonoid α\nm : Multiset ι\nf : ι → α\nn : Int\n⊢ Eq (Multiset.map (fun i => HSMul.hSMul n (f i)) m).sum (HSMul.hSMul n (Multiset.map f m).sum)","decl":"@[to_additive]\ntheorem prod_map_zpow {n : ℤ} : (m.map fun i => f i ^ n).prod = (m.map f).prod ^ n := by\n  convert (m.map f).prod_hom (zpowGroupHom n : α →* α)\n  simp only [map_map, Function.comp_apply, zpowGroupHom_apply]\n\n"}
{"name":"Multiset.prod_map_zpow","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝ : DivisionCommMonoid α\nm : Multiset ι\nf : ι → α\nn : Int\n⊢ Eq (Multiset.map (fun i => HPow.hPow (f i) n) m).prod (HPow.hPow (Multiset.map f m).prod n)","decl":"@[to_additive]\ntheorem prod_map_zpow {n : ℤ} : (m.map fun i => f i ^ n).prod = (m.map f).prod ^ n := by\n  convert (m.map f).prod_hom (zpowGroupHom n : α →* α)\n  simp only [map_map, Function.comp_apply, zpowGroupHom_apply]\n\n"}
{"name":"Multiset.sum_map_singleton","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"α : Type u_3\ns : Multiset α\n⊢ Eq (Multiset.map (fun a => Singleton.singleton a) s).sum s","decl":"@[simp]\ntheorem sum_map_singleton (s : Multiset α) : (s.map fun a => ({a} : Multiset α)).sum = s :=\n  Multiset.induction_on s (by simp) (by simp)\n\n"}
{"name":"Multiset.sum_nat_mod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"s : Multiset Nat\nn : Nat\n⊢ Eq (HMod.hMod s.sum n) (HMod.hMod (Multiset.map (fun x => HMod.hMod x n) s).sum n)","decl":"theorem sum_nat_mod (s : Multiset ℕ) (n : ℕ) : s.sum % n = (s.map (· % n)).sum % n := by\n  induction s using Multiset.induction <;> simp [Nat.add_mod, *]\n\n"}
{"name":"Multiset.prod_nat_mod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"s : Multiset Nat\nn : Nat\n⊢ Eq (HMod.hMod s.prod n) (HMod.hMod (Multiset.map (fun x => HMod.hMod x n) s).prod n)","decl":"theorem prod_nat_mod (s : Multiset ℕ) (n : ℕ) : s.prod % n = (s.map (· % n)).prod % n := by\n  induction s using Multiset.induction <;> simp [Nat.mul_mod, *]\n\n"}
{"name":"Multiset.sum_int_mod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"s : Multiset Int\nn : Int\n⊢ Eq (HMod.hMod s.sum n) (HMod.hMod (Multiset.map (fun x => HMod.hMod x n) s).sum n)","decl":"theorem sum_int_mod (s : Multiset ℤ) (n : ℤ) : s.sum % n = (s.map (· % n)).sum % n := by\n  induction s using Multiset.induction <;> simp [Int.add_emod, *]\n\n"}
{"name":"Multiset.prod_int_mod","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"s : Multiset Int\nn : Int\n⊢ Eq (HMod.hMod s.prod n) (HMod.hMod (Multiset.map (fun x => HMod.hMod x n) s).prod n)","decl":"theorem prod_int_mod (s : Multiset ℤ) (n : ℤ) : s.prod % n = (s.map (· % n)).prod % n := by\n  induction s using Multiset.induction <;> simp [Int.mul_emod, *]\n\n"}
{"name":"Multiset.sum_map_tsub","module":"Mathlib.Algebra.BigOperators.Group.Multiset.Basic","initialProofState":"ι : Type u_2\nα : Type u_3\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : PartialOrder α\ninst✝⁴ : ExistsAddOfLE α\ninst✝³ : CovariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\ninst✝² : ContravariantClass α α (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2\ninst✝¹ : Sub α\ninst✝ : OrderedSub α\nl : Multiset ι\nf g : ι → α\nhfg : ∀ (x : ι), Membership.mem l x → LE.le (g x) (f x)\n⊢ Eq (Multiset.map (fun x => HSub.hSub (f x) (g x)) l).sum (HSub.hSub (Multiset.map f l).sum (Multiset.map g l).sum)","decl":"theorem sum_map_tsub [AddCommMonoid α] [PartialOrder α] [ExistsAddOfLE α]\n    [CovariantClass α α (· + ·) (· ≤ ·)] [ContravariantClass α α (· + ·) (· ≤ ·)] [Sub α]\n    [OrderedSub α] (l : Multiset ι) {f g : ι → α} (hfg : ∀ x ∈ l, g x ≤ f x) :\n    (l.map fun x ↦ f x - g x).sum = (l.map f).sum - (l.map g).sum :=\n  eq_tsub_of_add_eq <| by\n    rw [← sum_map_add]\n    congr 1\n    exact map_congr rfl fun x hx => tsub_add_cancel_of_le <| hfg _ hx\n\n"}
