{"name":"EuclideanGeometry.Sphere.ext","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nx y : EuclideanGeometry.Sphere P\ncenter : Eq x.center y.center\nradius : Eq x.radius y.radius\n⊢ Eq x y","decl":"/-- A `Sphere P` bundles a `center` and `radius`. This definition does not require the radius to\nbe positive; that should be given as a hypothesis to lemmas that require it. -/\n@[ext]\nstructure Sphere [MetricSpace P] where\n  /-- center of this sphere -/\n  center : P\n  /-- radius of the sphere: not required to be positive -/\n  radius : ℝ\n\n"}
{"name":"EuclideanGeometry.Sphere.mk.injEq","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ncenter✝ : P\nradius✝ : Real\ncenter : P\nradius : Real\n⊢ Eq (Eq { center := center✝, radius := radius✝ } { center := center, radius := radius }) (And (Eq center✝ center) (Eq radius✝ radius))","decl":"/-- A `Sphere P` bundles a `center` and `radius`. This definition does not require the radius to\nbe positive; that should be given as a hypothesis to lemmas that require it. -/\n@[ext]\nstructure Sphere [MetricSpace P] where\n  /-- center of this sphere -/\n  center : P\n  /-- radius of the sphere: not required to be positive -/\n  radius : ℝ\n\n"}
{"name":"EuclideanGeometry.Sphere.mk.sizeOf_spec","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝¹ : MetricSpace P\ninst✝ : SizeOf P\ncenter : P\nradius : Real\n⊢ Eq (SizeOf.sizeOf { center := center, radius := radius }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf center)) (SizeOf.sizeOf radius))","decl":"/-- A `Sphere P` bundles a `center` and `radius`. This definition does not require the radius to\nbe positive; that should be given as a hypothesis to lemmas that require it. -/\n@[ext]\nstructure Sphere [MetricSpace P] where\n  /-- center of this sphere -/\n  center : P\n  /-- radius of the sphere: not required to be positive -/\n  radius : ℝ\n\n"}
{"name":"EuclideanGeometry.Sphere.mk.inj","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ncenter✝ : P\nradius✝ : Real\ncenter : P\nradius : Real\nx✝ : Eq { center := center✝, radius := radius✝ } { center := center, radius := radius }\n⊢ And (Eq center✝ center) (Eq radius✝ radius)","decl":"/-- A `Sphere P` bundles a `center` and `radius`. This definition does not require the radius to\nbe positive; that should be given as a hypothesis to lemmas that require it. -/\n@[ext]\nstructure Sphere [MetricSpace P] where\n  /-- center of this sphere -/\n  center : P\n  /-- radius of the sphere: not required to be positive -/\n  radius : ℝ\n\n"}
{"name":"EuclideanGeometry.Sphere.ext_iff","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nx y : EuclideanGeometry.Sphere P\n⊢ Iff (Eq x y) (And (Eq x.center y.center) (Eq x.radius y.radius))","decl":"/-- A `Sphere P` bundles a `center` and `radius`. This definition does not require the radius to\nbe positive; that should be given as a hypothesis to lemmas that require it. -/\n@[ext]\nstructure Sphere [MetricSpace P] where\n  /-- center of this sphere -/\n  center : P\n  /-- radius of the sphere: not required to be positive -/\n  radius : ℝ\n\n"}
{"name":"EuclideanGeometry.instNonemptySphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝¹ : MetricSpace P\ninst✝ : Nonempty P\n⊢ Nonempty (EuclideanGeometry.Sphere P)","decl":"instance [Nonempty P] : Nonempty (Sphere P) :=\n  ⟨⟨Classical.arbitrary P, 0⟩⟩\n\n"}
{"name":"EuclideanGeometry.Sphere.mk_center","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nc : P\nr : Real\n⊢ Eq { center := c, radius := r }.center c","decl":"theorem Sphere.mk_center (c : P) (r : ℝ) : (⟨c, r⟩ : Sphere P).center = c :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.Sphere.mk_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nc : P\nr : Real\n⊢ Eq { center := c, radius := r }.radius r","decl":"theorem Sphere.mk_radius (c : P) (r : ℝ) : (⟨c, r⟩ : Sphere P).radius = r :=\n  rfl\n\n"}
{"name":"EuclideanGeometry.Sphere.mk_center_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ns : EuclideanGeometry.Sphere P\n⊢ Eq { center := s.center, radius := s.radius } s","decl":"@[simp]\ntheorem Sphere.mk_center_radius (s : Sphere P) : (⟨s.center, s.radius⟩ : Sphere P) = s := by\n  ext <;> rfl\n\n/- Porting note: is a syntactic tautology\ntheorem Sphere.coe_def (s : Sphere P) : (s : Set P) = Metric.sphere s.center s.radius :=\n  rfl -/\n\n"}
{"name":"EuclideanGeometry.Sphere.coe_mk","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nc : P\nr : Real\n⊢ Eq (Metric.sphere { center := c, radius := r }.center { center := c, radius := r }.radius) (Metric.sphere c r)","decl":"@[simp]\ntheorem Sphere.coe_mk (c : P) (r : ℝ) : ↑(⟨c, r⟩ : Sphere P) = Metric.sphere c r :=\n  rfl\n\n-- @[simp] -- Porting note: simp-normal form is `Sphere.mem_coe'`\n"}
{"name":"EuclideanGeometry.Sphere.mem_coe","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np : P\ns : EuclideanGeometry.Sphere P\n⊢ Iff (Membership.mem (Metric.sphere s.center s.radius) p) (Membership.mem s p)","decl":"theorem Sphere.mem_coe {p : P} {s : Sphere P} : p ∈ (s : Set P) ↔ p ∈ s :=\n  Iff.rfl\n\n"}
{"name":"EuclideanGeometry.Sphere.mem_coe'","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np : P\ns : EuclideanGeometry.Sphere P\n⊢ Iff (Eq (Dist.dist p s.center) s.radius) (Membership.mem s p)","decl":"@[simp]\ntheorem Sphere.mem_coe' {p : P} {s : Sphere P} : dist p s.center = s.radius ↔ p ∈ s :=\n  Iff.rfl\n\n"}
{"name":"EuclideanGeometry.mem_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np : P\ns : EuclideanGeometry.Sphere P\n⊢ Iff (Membership.mem s p) (Eq (Dist.dist p s.center) s.radius)","decl":"theorem mem_sphere {p : P} {s : Sphere P} : p ∈ s ↔ dist p s.center = s.radius :=\n  Iff.rfl\n\n"}
{"name":"EuclideanGeometry.mem_sphere'","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np : P\ns : EuclideanGeometry.Sphere P\n⊢ Iff (Membership.mem s p) (Eq (Dist.dist s.center p) s.radius)","decl":"theorem mem_sphere' {p : P} {s : Sphere P} : p ∈ s ↔ dist s.center p = s.radius :=\n  Metric.mem_sphere'\n\n"}
{"name":"EuclideanGeometry.subset_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nps : Set P\ns : EuclideanGeometry.Sphere P\n⊢ Iff (HasSubset.Subset ps (Metric.sphere s.center s.radius)) (∀ (p : P), Membership.mem ps p → Membership.mem s p)","decl":"theorem subset_sphere {ps : Set P} {s : Sphere P} : ps ⊆ s ↔ ∀ p ∈ ps, p ∈ s :=\n  Iff.rfl\n\n"}
{"name":"EuclideanGeometry.dist_of_mem_subset_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np : P\nps : Set P\ns : EuclideanGeometry.Sphere P\nhp : Membership.mem ps p\nhps : HasSubset.Subset ps (Metric.sphere s.center s.radius)\n⊢ Eq (Dist.dist p s.center) s.radius","decl":"theorem dist_of_mem_subset_sphere {p : P} {ps : Set P} {s : Sphere P} (hp : p ∈ ps)\n    (hps : ps ⊆ (s : Set P)) : dist p s.center = s.radius :=\n  mem_sphere.1 (Sphere.mem_coe.1 (Set.mem_of_mem_of_subset hp hps))\n\n"}
{"name":"EuclideanGeometry.dist_of_mem_subset_mk_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np c : P\nps : Set P\nr : Real\nhp : Membership.mem ps p\nhps : HasSubset.Subset ps (Metric.sphere { center := c, radius := r }.center { center := c, radius := r }.radius)\n⊢ Eq (Dist.dist p c) r","decl":"theorem dist_of_mem_subset_mk_sphere {p c : P} {ps : Set P} {r : ℝ} (hp : p ∈ ps)\n    (hps : ps ⊆ ↑(⟨c, r⟩ : Sphere P)) : dist p c = r :=\n  dist_of_mem_subset_sphere hp hps\n\n"}
{"name":"EuclideanGeometry.Sphere.ne_iff","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ns₁ s₂ : EuclideanGeometry.Sphere P\n⊢ Iff (Ne s₁ s₂) (Or (Ne s₁.center s₂.center) (Ne s₁.radius s₂.radius))","decl":"theorem Sphere.ne_iff {s₁ s₂ : Sphere P} :\n    s₁ ≠ s₂ ↔ s₁.center ≠ s₂.center ∨ s₁.radius ≠ s₂.radius := by\n  rw [← not_and_or, ← Sphere.ext_iff]\n\n"}
{"name":"EuclideanGeometry.Sphere.center_eq_iff_eq_of_mem","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ns₁ s₂ : EuclideanGeometry.Sphere P\np : P\nhs₁ : Membership.mem s₁ p\nhs₂ : Membership.mem s₂ p\n⊢ Iff (Eq s₁.center s₂.center) (Eq s₁ s₂)","decl":"theorem Sphere.center_eq_iff_eq_of_mem {s₁ s₂ : Sphere P} {p : P} (hs₁ : p ∈ s₁) (hs₂ : p ∈ s₂) :\n    s₁.center = s₂.center ↔ s₁ = s₂ := by\n  refine ⟨fun h => Sphere.ext h ?_, fun h => h ▸ rfl⟩\n  rw [mem_sphere] at hs₁ hs₂\n  rw [← hs₁, ← hs₂, h]\n\n"}
{"name":"EuclideanGeometry.Sphere.center_ne_iff_ne_of_mem","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ns₁ s₂ : EuclideanGeometry.Sphere P\np : P\nhs₁ : Membership.mem s₁ p\nhs₂ : Membership.mem s₂ p\n⊢ Iff (Ne s₁.center s₂.center) (Ne s₁ s₂)","decl":"theorem Sphere.center_ne_iff_ne_of_mem {s₁ s₂ : Sphere P} {p : P} (hs₁ : p ∈ s₁) (hs₂ : p ∈ s₂) :\n    s₁.center ≠ s₂.center ↔ s₁ ≠ s₂ :=\n  (Sphere.center_eq_iff_eq_of_mem hs₁ hs₂).not\n\n"}
{"name":"EuclideanGeometry.dist_center_eq_dist_center_of_mem_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np₁ p₂ : P\ns : EuclideanGeometry.Sphere P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\n⊢ Eq (Dist.dist p₁ s.center) (Dist.dist p₂ s.center)","decl":"theorem dist_center_eq_dist_center_of_mem_sphere {p₁ p₂ : P} {s : Sphere P} (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) : dist p₁ s.center = dist p₂ s.center := by\n  rw [mem_sphere.1 hp₁, mem_sphere.1 hp₂]\n\n"}
{"name":"EuclideanGeometry.dist_center_eq_dist_center_of_mem_sphere'","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np₁ p₂ : P\ns : EuclideanGeometry.Sphere P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\n⊢ Eq (Dist.dist s.center p₁) (Dist.dist s.center p₂)","decl":"theorem dist_center_eq_dist_center_of_mem_sphere' {p₁ p₂ : P} {s : Sphere P} (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) : dist s.center p₁ = dist s.center p₂ := by\n  rw [mem_sphere'.1 hp₁, mem_sphere'.1 hp₂]\n\n"}
{"name":"EuclideanGeometry.cospherical_def","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nps : Set P\n⊢ Iff (EuclideanGeometry.Cospherical ps) (Exists fun center => Exists fun radius => ∀ (p : P), Membership.mem ps p → Eq (Dist.dist p center) radius)","decl":"/-- The definition of `Cospherical`. -/\ntheorem cospherical_def (ps : Set P) :\n    Cospherical ps ↔ ∃ (center : P) (radius : ℝ), ∀ p ∈ ps, dist p center = radius :=\n  Iff.rfl\n\n"}
{"name":"EuclideanGeometry.cospherical_iff_exists_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nps : Set P\n⊢ Iff (EuclideanGeometry.Cospherical ps) (Exists fun s => HasSubset.Subset ps (Metric.sphere s.center s.radius))","decl":"/-- A set of points is cospherical if and only if they lie in some sphere. -/\ntheorem cospherical_iff_exists_sphere {ps : Set P} :\n    Cospherical ps ↔ ∃ s : Sphere P, ps ⊆ (s : Set P) := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with ⟨c, r, h⟩\n    exact ⟨⟨c, r⟩, h⟩\n  · rcases h with ⟨s, h⟩\n    exact ⟨s.center, s.radius, h⟩\n\n"}
{"name":"EuclideanGeometry.Sphere.cospherical","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\ns : EuclideanGeometry.Sphere P\n⊢ EuclideanGeometry.Cospherical (Metric.sphere s.center s.radius)","decl":"/-- The set of points in a sphere is cospherical. -/\ntheorem Sphere.cospherical (s : Sphere P) : Cospherical (s : Set P) :=\n  cospherical_iff_exists_sphere.2 ⟨s, Set.Subset.rfl⟩\n\n"}
{"name":"EuclideanGeometry.Cospherical.subset","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\nps₁ ps₂ : Set P\nhs : HasSubset.Subset ps₁ ps₂\nhc : EuclideanGeometry.Cospherical ps₂\n⊢ EuclideanGeometry.Cospherical ps₁","decl":"/-- A subset of a cospherical set is cospherical. -/\ntheorem Cospherical.subset {ps₁ ps₂ : Set P} (hs : ps₁ ⊆ ps₂) (hc : Cospherical ps₂) :\n    Cospherical ps₁ := by\n  rcases hc with ⟨c, r, hcr⟩\n  exact ⟨c, r, fun p hp => hcr p (hs hp)⟩\n\n"}
{"name":"EuclideanGeometry.cospherical_empty","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝¹ : MetricSpace P\ninst✝ : Nonempty P\n⊢ EuclideanGeometry.Cospherical EmptyCollection.emptyCollection","decl":"/-- The empty set is cospherical. -/\ntheorem cospherical_empty [Nonempty P] : Cospherical (∅ : Set P) :=\n  let ⟨p⟩ := ‹Nonempty P›\n  ⟨p, 0, fun _ => False.elim⟩\n\n"}
{"name":"EuclideanGeometry.cospherical_singleton","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"P : Type u_2\ninst✝ : MetricSpace P\np : P\n⊢ EuclideanGeometry.Cospherical (Singleton.singleton p)","decl":"/-- A single point is cospherical. -/\ntheorem cospherical_singleton (p : P) : Cospherical ({p} : Set P) := by\n  use p\n  simp\n\n"}
{"name":"EuclideanGeometry.cospherical_pair","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ : P\n⊢ EuclideanGeometry.Cospherical (Insert.insert p₁ (Singleton.singleton p₂))","decl":"include V in\n/-- Two points are cospherical. -/\ntheorem cospherical_pair (p₁ p₂ : P) : Cospherical ({p₁, p₂} : Set P) :=\n  ⟨midpoint ℝ p₁ p₂, ‖(2 : ℝ)‖⁻¹ * dist p₁ p₂, by\n    rintro p (rfl | rfl | _)\n    · rw [dist_comm, dist_midpoint_left (𝕜 := ℝ)]\n    · rw [dist_comm, dist_midpoint_right (𝕜 := ℝ)]⟩\n\n"}
{"name":"EuclideanGeometry.Concyclic.Coplanar","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nps : Set P\nself : EuclideanGeometry.Concyclic ps\n⊢ Coplanar Real ps","decl":"/-- A set of points is concyclic if it is cospherical and coplanar. (Most results are stated\ndirectly in terms of `Cospherical` instead of using `Concyclic`.) -/\nstructure Concyclic (ps : Set P) : Prop where\n  Cospherical : Cospherical ps\n  Coplanar : Coplanar ℝ ps\n\n"}
{"name":"EuclideanGeometry.Concyclic.Cospherical","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nps : Set P\nself : EuclideanGeometry.Concyclic ps\n⊢ EuclideanGeometry.Cospherical ps","decl":"/-- A set of points is concyclic if it is cospherical and coplanar. (Most results are stated\ndirectly in terms of `Cospherical` instead of using `Concyclic`.) -/\nstructure Concyclic (ps : Set P) : Prop where\n  Cospherical : Cospherical ps\n  Coplanar : Coplanar ℝ ps\n\n"}
{"name":"EuclideanGeometry.Concyclic.subset","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nps₁ ps₂ : Set P\nhs : HasSubset.Subset ps₁ ps₂\nh : EuclideanGeometry.Concyclic ps₂\n⊢ EuclideanGeometry.Concyclic ps₁","decl":"/-- A subset of a concyclic set is concyclic. -/\ntheorem Concyclic.subset {ps₁ ps₂ : Set P} (hs : ps₁ ⊆ ps₂) (h : Concyclic ps₂) : Concyclic ps₁ :=\n  ⟨h.1.subset hs, h.2.subset hs⟩\n\n"}
{"name":"EuclideanGeometry.concyclic_empty","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\n⊢ EuclideanGeometry.Concyclic EmptyCollection.emptyCollection","decl":"/-- The empty set is concyclic. -/\ntheorem concyclic_empty : Concyclic (∅ : Set P) :=\n  ⟨cospherical_empty, coplanar_empty ℝ P⟩\n\n"}
{"name":"EuclideanGeometry.concyclic_singleton","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np : P\n⊢ EuclideanGeometry.Concyclic (Singleton.singleton p)","decl":"/-- A single point is concyclic. -/\ntheorem concyclic_singleton (p : P) : Concyclic ({p} : Set P) :=\n  ⟨cospherical_singleton p, coplanar_singleton ℝ p⟩\n\n"}
{"name":"EuclideanGeometry.concyclic_pair","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : NormedSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ : P\n⊢ EuclideanGeometry.Concyclic (Insert.insert p₁ (Singleton.singleton p₂))","decl":"/-- Two points are concyclic. -/\ntheorem concyclic_pair (p₁ p₂ : P) : Concyclic ({p₁, p₂} : Set P) :=\n  ⟨cospherical_pair p₁ p₂, coplanar_pair ℝ p₁ p₂⟩\n\n"}
{"name":"EuclideanGeometry.Cospherical.affineIndependent","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\nhs : EuclideanGeometry.Cospherical s\np : Fin 3 → P\nhps : HasSubset.Subset (Set.range p) s\nhpi : Function.Injective p\n⊢ AffineIndependent Real p","decl":"/-- Any three points in a cospherical set are affinely independent. -/\ntheorem Cospherical.affineIndependent {s : Set P} (hs : Cospherical s) {p : Fin 3 → P}\n    (hps : Set.range p ⊆ s) (hpi : Function.Injective p) : AffineIndependent ℝ p := by\n  rw [affineIndependent_iff_not_collinear]\n  intro hc\n  rw [collinear_iff_of_mem (Set.mem_range_self (0 : Fin 3))] at hc\n  rcases hc with ⟨v, hv⟩\n  rw [Set.forall_mem_range] at hv\n  have hv0 : v ≠ 0 := by\n    intro h\n    have he : p 1 = p 0 := by simpa [h] using hv 1\n    exact (by decide : (1 : Fin 3) ≠ 0) (hpi he)\n  rcases hs with ⟨c, r, hs⟩\n  have hs' := fun i => hs (p i) (Set.mem_of_mem_of_subset (Set.mem_range_self _) hps)\n  choose f hf using hv\n  have hsd : ∀ i, dist (f i • v +ᵥ p 0) c = r := by\n    intro i\n    rw [← hf]\n    exact hs' i\n  have hf0 : f 0 = 0 := by\n    have hf0' := hf 0\n    rw [eq_comm, ← @vsub_eq_zero_iff_eq V, vadd_vsub, smul_eq_zero] at hf0'\n    simpa [hv0] using hf0'\n  have hfi : Function.Injective f := by\n    intro i j h\n    have hi := hf i\n    rw [h, ← hf j] at hi\n    exact hpi hi\n  simp_rw [← hsd 0, hf0, zero_smul, zero_vadd, dist_smul_vadd_eq_dist (p 0) c hv0] at hsd\n  have hfn0 : ∀ i, i ≠ 0 → f i ≠ 0 := fun i => (hfi.ne_iff' hf0).2\n  have hfn0' : ∀ i, i ≠ 0 → f i = -2 * ⟪v, p 0 -ᵥ c⟫ / ⟪v, v⟫ := by\n    intro i hi\n    have hsdi := hsd i\n    simpa [hfn0, hi] using hsdi\n  have hf12 : f 1 = f 2 := by rw [hfn0' 1 (by decide), hfn0' 2 (by decide)]\n  exact (by decide : (1 : Fin 3) ≠ 2) (hfi hf12)\n\n"}
{"name":"EuclideanGeometry.Cospherical.affineIndependent_of_mem_of_ne","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : Set P\nhs : EuclideanGeometry.Cospherical s\np₁ p₂ p₃ : P\nh₁ : Membership.mem s p₁\nh₂ : Membership.mem s p₂\nh₃ : Membership.mem s p₃\nh₁₂ : Ne p₁ p₂\nh₁₃ : Ne p₁ p₃\nh₂₃ : Ne p₂ p₃\n⊢ AffineIndependent Real (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))","decl":"/-- Any three points in a cospherical set are affinely independent. -/\ntheorem Cospherical.affineIndependent_of_mem_of_ne {s : Set P} (hs : Cospherical s) {p₁ p₂ p₃ : P}\n    (h₁ : p₁ ∈ s) (h₂ : p₂ ∈ s) (h₃ : p₃ ∈ s) (h₁₂ : p₁ ≠ p₂) (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) :\n    AffineIndependent ℝ ![p₁, p₂, p₃] := by\n  refine hs.affineIndependent ?_ ?_\n  · simp [h₁, h₂, h₃, Set.insert_subset_iff]\n  · erw [Fin.cons_injective_iff, Fin.cons_injective_iff]\n    simp [h₁₂, h₁₃, h₂₃, Function.Injective, eq_iff_true_of_subsingleton]\n\n"}
{"name":"EuclideanGeometry.Cospherical.affineIndependent_of_ne","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nhs : EuclideanGeometry.Cospherical (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))\nh₁₂ : Ne p₁ p₂\nh₁₃ : Ne p₁ p₃\nh₂₃ : Ne p₂ p₃\n⊢ AffineIndependent Real (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))","decl":"/-- The three points of a cospherical set are affinely independent. -/\ntheorem Cospherical.affineIndependent_of_ne {p₁ p₂ p₃ : P} (hs : Cospherical ({p₁, p₂, p₃} : Set P))\n    (h₁₂ : p₁ ≠ p₂) (h₁₃ : p₁ ≠ p₃) (h₂₃ : p₂ ≠ p₃) : AffineIndependent ℝ ![p₁, p₂, p₃] :=\n  hs.affineIndependent_of_mem_of_ne (Set.mem_insert _ _)\n    (Set.mem_insert_of_mem _ (Set.mem_insert _ _))\n    (Set.mem_insert_of_mem _ (Set.mem_insert_of_mem _ (Set.mem_singleton _))) h₁₂ h₁₃ h₂₃\n\n"}
{"name":"EuclideanGeometry.inner_vsub_vsub_of_mem_sphere_of_mem_sphere","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ : P\ns₁ s₂ : EuclideanGeometry.Sphere P\nhp₁s₁ : Membership.mem s₁ p₁\nhp₂s₁ : Membership.mem s₁ p₂\nhp₁s₂ : Membership.mem s₂ p₁\nhp₂s₂ : Membership.mem s₂ p₂\n⊢ Eq (Inner.inner (VSub.vsub s₂.center s₁.center) (VSub.vsub p₂ p₁)) 0","decl":"/-- Suppose that `p₁` and `p₂` lie in spheres `s₁` and `s₂`. Then the vector between the centers\nof those spheres is orthogonal to that between `p₁` and `p₂`; this is a version of\n`inner_vsub_vsub_of_dist_eq_of_dist_eq` for bundled spheres. (In two dimensions, this says that\nthe diagonals of a kite are orthogonal.) -/\ntheorem inner_vsub_vsub_of_mem_sphere_of_mem_sphere {p₁ p₂ : P} {s₁ s₂ : Sphere P} (hp₁s₁ : p₁ ∈ s₁)\n    (hp₂s₁ : p₂ ∈ s₁) (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂) :\n    ⟪s₂.center -ᵥ s₁.center, p₂ -ᵥ p₁⟫ = 0 :=\n  inner_vsub_vsub_of_dist_eq_of_dist_eq (dist_center_eq_dist_center_of_mem_sphere hp₁s₁ hp₂s₁)\n    (dist_center_eq_dist_center_of_mem_sphere hp₁s₂ hp₂s₂)\n\n"}
{"name":"EuclideanGeometry.eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\ns : AffineSubspace Real P\ninst✝ : FiniteDimensional Real (Subtype fun x => Membership.mem s.direction x)\nhd : Eq (Module.finrank Real (Subtype fun x => Membership.mem s.direction x)) 2\ns₁ s₂ : EuclideanGeometry.Sphere P\np₁ p₂ p : P\nhs₁ : Membership.mem s s₁.center\nhs₂ : Membership.mem s s₂.center\nhp₁s : Membership.mem s p₁\nhp₂s : Membership.mem s p₂\nhps : Membership.mem s p\nhs : Ne s₁ s₂\nhp : Ne p₁ p₂\nhp₁s₁ : Membership.mem s₁ p₁\nhp₂s₁ : Membership.mem s₁ p₂\nhps₁ : Membership.mem s₁ p\nhp₁s₂ : Membership.mem s₂ p₁\nhp₂s₂ : Membership.mem s₂ p₂\nhps₂ : Membership.mem s₂ p\n⊢ Or (Eq p p₁) (Eq p p₂)","decl":"/-- Two spheres intersect in at most two points in a two-dimensional subspace containing their\ncenters; this is a version of `eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two` for bundled\nspheres. -/\ntheorem eq_of_mem_sphere_of_mem_sphere_of_mem_of_finrank_eq_two {s : AffineSubspace ℝ P}\n    [FiniteDimensional ℝ s.direction] (hd : finrank ℝ s.direction = 2) {s₁ s₂ : Sphere P}\n    {p₁ p₂ p : P} (hs₁ : s₁.center ∈ s) (hs₂ : s₂.center ∈ s) (hp₁s : p₁ ∈ s) (hp₂s : p₂ ∈ s)\n    (hps : p ∈ s) (hs : s₁ ≠ s₂) (hp : p₁ ≠ p₂) (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁) (hps₁ : p ∈ s₁)\n    (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂) (hps₂ : p ∈ s₂) : p = p₁ ∨ p = p₂ :=\n  eq_of_dist_eq_of_dist_eq_of_mem_of_finrank_eq_two hd hs₁ hs₂ hp₁s hp₂s hps\n    ((Sphere.center_ne_iff_ne_of_mem hps₁ hps₂).2 hs) hp hp₁s₁ hp₂s₁ hps₁ hp₁s₂ hp₂s₂ hps₂\n\n"}
{"name":"EuclideanGeometry.eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁴ : NormedAddCommGroup V\ninst✝³ : InnerProductSpace Real V\ninst✝² : MetricSpace P\ninst✝¹ : NormedAddTorsor V P\ninst✝ : FiniteDimensional Real V\nhd : Eq (Module.finrank Real V) 2\ns₁ s₂ : EuclideanGeometry.Sphere P\np₁ p₂ p : P\nhs : Ne s₁ s₂\nhp : Ne p₁ p₂\nhp₁s₁ : Membership.mem s₁ p₁\nhp₂s₁ : Membership.mem s₁ p₂\nhps₁ : Membership.mem s₁ p\nhp₁s₂ : Membership.mem s₂ p₁\nhp₂s₂ : Membership.mem s₂ p₂\nhps₂ : Membership.mem s₂ p\n⊢ Or (Eq p p₁) (Eq p p₂)","decl":"/-- Two spheres intersect in at most two points in two-dimensional space; this is a version of\n`eq_of_dist_eq_of_dist_eq_of_finrank_eq_two` for bundled spheres. -/\ntheorem eq_of_mem_sphere_of_mem_sphere_of_finrank_eq_two [FiniteDimensional ℝ V]\n    (hd : finrank ℝ V = 2) {s₁ s₂ : Sphere P} {p₁ p₂ p : P} (hs : s₁ ≠ s₂) (hp : p₁ ≠ p₂)\n    (hp₁s₁ : p₁ ∈ s₁) (hp₂s₁ : p₂ ∈ s₁) (hps₁ : p ∈ s₁) (hp₁s₂ : p₁ ∈ s₂) (hp₂s₂ : p₂ ∈ s₂)\n    (hps₂ : p ∈ s₂) : p = p₁ ∨ p = p₂ :=\n  eq_of_dist_eq_of_dist_eq_of_finrank_eq_two hd ((Sphere.center_ne_iff_ne_of_mem hps₁ hps₂).2 hs) hp\n    hp₁s₁ hp₂s₁ hps₁ hp₁s₂ hp₂s₂ hps₂\n\n"}
{"name":"EuclideanGeometry.inner_pos_or_eq_of_dist_le_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np₁ p₂ : P\nhp₁ : Membership.mem s p₁\nhp₂ : LE.le (Dist.dist p₂ s.center) s.radius\n⊢ Or (LT.lt 0 (Inner.inner (VSub.vsub p₁ p₂) (VSub.vsub p₁ s.center))) (Eq p₁ p₂)","decl":"/-- Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is positive unless the points are equal. -/\ntheorem inner_pos_or_eq_of_dist_le_radius {s : Sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : dist p₂ s.center ≤ s.radius) : 0 < ⟪p₁ -ᵥ p₂, p₁ -ᵥ s.center⟫ ∨ p₁ = p₂ := by\n  by_cases h : p₁ = p₂; · exact Or.inr h\n  refine Or.inl ?_\n  rw [mem_sphere] at hp₁\n  rw [← vsub_sub_vsub_cancel_right p₁ p₂ s.center, inner_sub_left,\n    real_inner_self_eq_norm_mul_norm, sub_pos]\n  refine lt_of_le_of_ne\n    ((real_inner_le_norm _ _).trans (mul_le_mul_of_nonneg_right ?_ (norm_nonneg _))) ?_\n  · rwa [← dist_eq_norm_vsub, ← dist_eq_norm_vsub, hp₁]\n  · rcases hp₂.lt_or_eq with (hp₂' | hp₂')\n    · refine ((real_inner_le_norm _ _).trans_lt (mul_lt_mul_of_pos_right ?_ ?_)).ne\n      · rwa [← hp₁, @dist_eq_norm_vsub V, @dist_eq_norm_vsub V] at hp₂'\n      · rw [norm_pos_iff, vsub_ne_zero]\n        rintro rfl\n        rw [← hp₁] at hp₂'\n        refine (dist_nonneg.not_lt : ¬dist p₂ s.center < 0) ?_\n        simpa using hp₂'\n    · rw [← hp₁, @dist_eq_norm_vsub V, @dist_eq_norm_vsub V] at hp₂'\n      nth_rw 1 [← hp₂']\n      rw [Ne, inner_eq_norm_mul_iff_real, hp₂', ← sub_eq_zero, ← smul_sub,\n        vsub_sub_vsub_cancel_right, ← Ne, smul_ne_zero_iff, vsub_ne_zero,\n        and_iff_left (Ne.symm h), norm_ne_zero_iff, vsub_ne_zero]\n      rintro rfl\n      refine h (Eq.symm ?_)\n      simpa using hp₂'\n\n"}
{"name":"EuclideanGeometry.inner_nonneg_of_dist_le_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np₁ p₂ : P\nhp₁ : Membership.mem s p₁\nhp₂ : LE.le (Dist.dist p₂ s.center) s.radius\n⊢ LE.le 0 (Inner.inner (VSub.vsub p₁ p₂) (VSub.vsub p₁ s.center))","decl":"/-- Given a point on a sphere and a point not outside it, the inner product between the\ndifference of those points and the radius vector is nonnegative. -/\ntheorem inner_nonneg_of_dist_le_radius {s : Sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : dist p₂ s.center ≤ s.radius) : 0 ≤ ⟪p₁ -ᵥ p₂, p₁ -ᵥ s.center⟫ := by\n  rcases inner_pos_or_eq_of_dist_le_radius hp₁ hp₂ with (h | rfl)\n  · exact h.le\n  · simp\n\n"}
{"name":"EuclideanGeometry.inner_pos_of_dist_lt_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np₁ p₂ : P\nhp₁ : Membership.mem s p₁\nhp₂ : LT.lt (Dist.dist p₂ s.center) s.radius\n⊢ LT.lt 0 (Inner.inner (VSub.vsub p₁ p₂) (VSub.vsub p₁ s.center))","decl":"/-- Given a point on a sphere and a point inside it, the inner product between the difference of\nthose points and the radius vector is positive. -/\ntheorem inner_pos_of_dist_lt_radius {s : Sphere P} {p₁ p₂ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : dist p₂ s.center < s.radius) : 0 < ⟪p₁ -ᵥ p₂, p₁ -ᵥ s.center⟫ := by\n  by_cases h : p₁ = p₂\n  · rw [h, mem_sphere] at hp₁\n    exact False.elim (hp₂.ne hp₁)\n  exact (inner_pos_or_eq_of_dist_le_radius hp₁ hp₂.le).resolve_right h\n\n"}
{"name":"EuclideanGeometry.wbtw_of_collinear_of_dist_center_le_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np₁ p₂ p₃ : P\nh : Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))\nhp₁ : Membership.mem s p₁\nhp₂ : LE.le (Dist.dist p₂ s.center) s.radius\nhp₃ : Membership.mem s p₃\nhp₁p₃ : Ne p₁ p₃\n⊢ Wbtw Real p₁ p₂ p₃","decl":"/-- Given three collinear points, two on a sphere and one not outside it, the one not outside it\nis weakly between the other two points. -/\ntheorem wbtw_of_collinear_of_dist_center_le_radius {s : Sphere P} {p₁ p₂ p₃ : P}\n    (h : Collinear ℝ ({p₁, p₂, p₃} : Set P)) (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center ≤ s.radius)\n    (hp₃ : p₃ ∈ s) (hp₁p₃ : p₁ ≠ p₃) : Wbtw ℝ p₁ p₂ p₃ :=\n  h.wbtw_of_dist_eq_of_dist_le hp₁ hp₂ hp₃ hp₁p₃\n\n"}
{"name":"EuclideanGeometry.sbtw_of_collinear_of_dist_center_lt_radius","module":"Mathlib.Geometry.Euclidean.Sphere.Basic","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : EuclideanGeometry.Sphere P\np₁ p₂ p₃ : P\nh : Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))\nhp₁ : Membership.mem s p₁\nhp₂ : LT.lt (Dist.dist p₂ s.center) s.radius\nhp₃ : Membership.mem s p₃\nhp₁p₃ : Ne p₁ p₃\n⊢ Sbtw Real p₁ p₂ p₃","decl":"/-- Given three collinear points, two on a sphere and one inside it, the one inside it is\nstrictly between the other two points. -/\ntheorem sbtw_of_collinear_of_dist_center_lt_radius {s : Sphere P} {p₁ p₂ p₃ : P}\n    (h : Collinear ℝ ({p₁, p₂, p₃} : Set P)) (hp₁ : p₁ ∈ s) (hp₂ : dist p₂ s.center < s.radius)\n    (hp₃ : p₃ ∈ s) (hp₁p₃ : p₁ ≠ p₃) : Sbtw ℝ p₁ p₂ p₃ :=\n  h.sbtw_of_dist_eq_of_dist_lt hp₁ hp₂ hp₃ hp₁p₃\n\n"}
