{"name":"Function.Periodic.funext","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : Add α\nh : Function.Periodic f c\n⊢ Eq (fun x => f (HAdd.hAdd x c)) f","decl":"protected theorem Periodic.funext [Add α] (h : Periodic f c) : (fun x => f (x + c)) = f :=\n  funext h\n\n"}
{"name":"Function.Periodic.comp","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝ : Add α\nh : Function.Periodic f c\ng : β → γ\n⊢ Function.Periodic (Function.comp g f) c","decl":"protected theorem Periodic.comp [Add α] (h : Periodic f c) (g : β → γ) : Periodic (g ∘ f) c := by\n  simp_all\n\n"}
{"name":"Function.Periodic.comp_addHom","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : Add γ\nh : Function.Periodic f c\ng : AddHom γ α\ng_inv : α → γ\nhg : Function.RightInverse g_inv ⇑g\n⊢ Function.Periodic (Function.comp f ⇑g) (g_inv c)","decl":"theorem Periodic.comp_addHom [Add α] [Add γ] (h : Periodic f c) (g : AddHom γ α) (g_inv : α → γ)\n    (hg : RightInverse g_inv g) : Periodic (f ∘ g) (g_inv c) := fun x => by\n  simp only [hg c, h (g x), map_add, comp_apply]\n\n"}
{"name":"Function.Periodic.mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : Mul β\nhf : Function.Periodic f c\nhg : Function.Periodic g c\n⊢ Function.Periodic (HMul.hMul f g) c","decl":"@[to_additive]\nprotected theorem Periodic.mul [Add α] [Mul β] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f * g) c := by simp_all\n\n"}
{"name":"Function.Periodic.add","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : Add β\nhf : Function.Periodic f c\nhg : Function.Periodic g c\n⊢ Function.Periodic (HAdd.hAdd f g) c","decl":"@[to_additive]\nprotected theorem Periodic.mul [Add α] [Mul β] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f * g) c := by simp_all\n\n"}
{"name":"Function.Periodic.sub","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : Sub β\nhf : Function.Periodic f c\nhg : Function.Periodic g c\n⊢ Function.Periodic (HSub.hSub f g) c","decl":"@[to_additive]\nprotected theorem Periodic.div [Add α] [Div β] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f / g) c := by simp_all\n\n"}
{"name":"Function.Periodic.div","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : Div β\nhf : Function.Periodic f c\nhg : Function.Periodic g c\n⊢ Function.Periodic (HDiv.hDiv f g) c","decl":"@[to_additive]\nprotected theorem Periodic.div [Add α] [Div β] (hf : Periodic f c) (hg : Periodic g c) :\n    Periodic (f / g) c := by simp_all\n\n"}
{"name":"List.periodic_sum","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nc : α\ninst✝¹ : Add α\ninst✝ : AddMonoid β\nl : List (α → β)\nhl : ∀ (f : α → β), Membership.mem l f → Function.Periodic f c\n⊢ Function.Periodic l.sum c","decl":"@[to_additive]\ntheorem _root_.List.periodic_prod [Add α] [Monoid β] (l : List (α → β))\n    (hl : ∀ f ∈ l, Periodic f c) : Periodic l.prod c := by\n  induction l with\n  | nil => simp\n  | cons g l ih =>\n    rw [List.forall_mem_cons] at hl\n    simpa only [List.prod_cons] using hl.1.mul (ih hl.2)\n\n"}
{"name":"List.periodic_prod","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nc : α\ninst✝¹ : Add α\ninst✝ : Monoid β\nl : List (α → β)\nhl : ∀ (f : α → β), Membership.mem l f → Function.Periodic f c\n⊢ Function.Periodic l.prod c","decl":"@[to_additive]\ntheorem _root_.List.periodic_prod [Add α] [Monoid β] (l : List (α → β))\n    (hl : ∀ f ∈ l, Periodic f c) : Periodic l.prod c := by\n  induction l with\n  | nil => simp\n  | cons g l ih =>\n    rw [List.forall_mem_cons] at hl\n    simpa only [List.prod_cons] using hl.1.mul (ih hl.2)\n\n"}
{"name":"Multiset.periodic_sum","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nc : α\ninst✝¹ : Add α\ninst✝ : AddCommMonoid β\ns : Multiset (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → Function.Periodic f c\n⊢ Function.Periodic s.sum c","decl":"@[to_additive]\ntheorem _root_.Multiset.periodic_prod [Add α] [CommMonoid β] (s : Multiset (α → β))\n    (hs : ∀ f ∈ s, Periodic f c) : Periodic s.prod c :=\n  (s.prod_toList ▸ s.toList.periodic_prod) fun f hf => hs f <| Multiset.mem_toList.mp hf\n\n"}
{"name":"Multiset.periodic_prod","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nc : α\ninst✝¹ : Add α\ninst✝ : CommMonoid β\ns : Multiset (α → β)\nhs : ∀ (f : α → β), Membership.mem s f → Function.Periodic f c\n⊢ Function.Periodic s.prod c","decl":"@[to_additive]\ntheorem _root_.Multiset.periodic_prod [Add α] [CommMonoid β] (s : Multiset (α → β))\n    (hs : ∀ f ∈ s, Periodic f c) : Periodic s.prod c :=\n  (s.prod_toList ▸ s.toList.periodic_prod) fun f hf => hs f <| Multiset.mem_toList.mp hf\n\n"}
{"name":"Finset.periodic_sum","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nc : α\ninst✝¹ : Add α\ninst✝ : AddCommMonoid β\nι : Type u_4\nf : ι → α → β\ns : Finset ι\nhs : ∀ (i : ι), Membership.mem s i → Function.Periodic (f i) c\n⊢ Function.Periodic (s.sum fun i => f i) c","decl":"@[to_additive]\ntheorem _root_.Finset.periodic_prod [Add α] [CommMonoid β] {ι : Type*} {f : ι → α → β}\n    (s : Finset ι) (hs : ∀ i ∈ s, Periodic (f i) c) : Periodic (∏ i ∈ s, f i) c :=\n  s.prod_to_list f ▸ (s.toList.map f).periodic_prod (by simpa [-Periodic] )\n\n"}
{"name":"Finset.periodic_prod","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nc : α\ninst✝¹ : Add α\ninst✝ : CommMonoid β\nι : Type u_4\nf : ι → α → β\ns : Finset ι\nhs : ∀ (i : ι), Membership.mem s i → Function.Periodic (f i) c\n⊢ Function.Periodic (s.prod fun i => f i) c","decl":"@[to_additive]\ntheorem _root_.Finset.periodic_prod [Add α] [CommMonoid β] {ι : Type*} {f : ι → α → β}\n    (s : Finset ι) (hs : ∀ i ∈ s, Periodic (f i) c) : Periodic (∏ i ∈ s, f i) c :=\n  s.prod_to_list f ▸ (s.toList.map f).periodic_prod (by simpa [-Periodic] )\n\n"}
{"name":"Function.Periodic.smul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : SMul γ β\nh : Function.Periodic f c\na : γ\n⊢ Function.Periodic (HSMul.hSMul a f) c","decl":"@[to_additive]\nprotected theorem Periodic.smul [Add α] [SMul γ β] (h : Periodic f c) (a : γ) :\n    Periodic (a • f) c := by simp_all\n\n"}
{"name":"Function.Periodic.vadd","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : VAdd γ β\nh : Function.Periodic f c\na : γ\n⊢ Function.Periodic (HVAdd.hVAdd a f) c","decl":"@[to_additive]\nprotected theorem Periodic.smul [Add α] [SMul γ β] (h : Periodic f c) (a : γ) :\n    Periodic (a • f) c := by simp_all\n\n"}
{"name":"Function.Periodic.const_smul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝² : AddMonoid α\ninst✝¹ : Group γ\ninst✝ : DistribMulAction γ α\nh : Function.Periodic f c\na : γ\n⊢ Function.Periodic (fun x => f (HSMul.hSMul a x)) (HSMul.hSMul (Inv.inv a) c)","decl":"protected theorem Periodic.const_smul [AddMonoid α] [Group γ] [DistribMulAction γ α]\n    (h : Periodic f c) (a : γ) : Periodic (fun x => f (a • x)) (a⁻¹ • c) := fun x => by\n  simpa only [smul_add, smul_inv_smul] using h (a • x)\n\n"}
{"name":"Function.Periodic.const_smul₀","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝² : AddCommMonoid α\ninst✝¹ : DivisionSemiring γ\ninst✝ : Module γ α\nh : Function.Periodic f c\na : γ\n⊢ Function.Periodic (fun x => f (HSMul.hSMul a x)) (HSMul.hSMul (Inv.inv a) c)","decl":"protected theorem Periodic.const_smul₀ [AddCommMonoid α] [DivisionSemiring γ] [Module γ α]\n    (h : Periodic f c) (a : γ) : Periodic (fun x => f (a • x)) (a⁻¹ • c) := fun x => by\n  by_cases ha : a = 0\n  · simp only [ha, zero_smul]\n  · simpa only [smul_add, smul_inv_smul₀ ha] using h (a • x)\n\n"}
{"name":"Function.Periodic.const_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : DivisionSemiring α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HMul.hMul a x)) (HMul.hMul (Inv.inv a) c)","decl":"protected theorem Periodic.const_mul [DivisionSemiring α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (a * x)) (a⁻¹ * c) :=\n  Periodic.const_smul₀ h a\n\n"}
{"name":"Function.Periodic.const_inv_smul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝² : AddMonoid α\ninst✝¹ : Group γ\ninst✝ : DistribMulAction γ α\nh : Function.Periodic f c\na : γ\n⊢ Function.Periodic (fun x => f (HSMul.hSMul (Inv.inv a) x)) (HSMul.hSMul a c)","decl":"theorem Periodic.const_inv_smul [AddMonoid α] [Group γ] [DistribMulAction γ α] (h : Periodic f c)\n    (a : γ) : Periodic (fun x => f (a⁻¹ • x)) (a • c) := by\n  simpa only [inv_inv] using h.const_smul a⁻¹\n\n"}
{"name":"Function.Periodic.const_inv_smul₀","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝² : AddCommMonoid α\ninst✝¹ : DivisionSemiring γ\ninst✝ : Module γ α\nh : Function.Periodic f c\na : γ\n⊢ Function.Periodic (fun x => f (HSMul.hSMul (Inv.inv a) x)) (HSMul.hSMul a c)","decl":"theorem Periodic.const_inv_smul₀ [AddCommMonoid α] [DivisionSemiring γ] [Module γ α]\n    (h : Periodic f c) (a : γ) : Periodic (fun x => f (a⁻¹ • x)) (a • c) := by\n  simpa only [inv_inv] using h.const_smul₀ a⁻¹\n\n"}
{"name":"Function.Periodic.const_inv_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : DivisionSemiring α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HMul.hMul (Inv.inv a) x)) (HMul.hMul a c)","decl":"theorem Periodic.const_inv_mul [DivisionSemiring α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (a⁻¹ * x)) (a * c) :=\n  h.const_inv_smul₀ a\n\n"}
{"name":"Function.Periodic.mul_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : DivisionSemiring α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HMul.hMul x a)) (HMul.hMul c (Inv.inv a))","decl":"theorem Periodic.mul_const [DivisionSemiring α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (x * a)) (c * a⁻¹) :=\n  h.const_smul₀ (MulOpposite.op a)\n\n"}
{"name":"Function.Periodic.mul_const'","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : DivisionSemiring α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HMul.hMul x a)) (HDiv.hDiv c a)","decl":"theorem Periodic.mul_const' [DivisionSemiring α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (x * a)) (c / a) := by simpa only [div_eq_mul_inv] using h.mul_const a\n\n"}
{"name":"Function.Periodic.mul_const_inv","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : DivisionSemiring α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HMul.hMul x (Inv.inv a))) (HMul.hMul c a)","decl":"theorem Periodic.mul_const_inv [DivisionSemiring α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (x * a⁻¹)) (c * a) :=\n  h.const_inv_smul₀ (MulOpposite.op a)\n\n"}
{"name":"Function.Periodic.div_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : DivisionSemiring α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HDiv.hDiv x a)) (HMul.hMul c a)","decl":"theorem Periodic.div_const [DivisionSemiring α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (x / a)) (c * a) := by simpa only [div_eq_mul_inv] using h.mul_const_inv a\n\n"}
{"name":"Function.Periodic.add_period","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝ : AddSemigroup α\nh1 : Function.Periodic f c₁\nh2 : Function.Periodic f c₂\n⊢ Function.Periodic f (HAdd.hAdd c₁ c₂)","decl":"theorem Periodic.add_period [AddSemigroup α] (h1 : Periodic f c₁) (h2 : Periodic f c₂) :\n    Periodic f (c₁ + c₂) := by simp_all [← add_assoc]\n\n"}
{"name":"Function.Periodic.sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\nx : α\n⊢ Eq (f (HSub.hSub x c)) (f x)","decl":"theorem Periodic.sub_eq [AddGroup α] (h : Periodic f c) (x : α) : f (x - c) = f x := by\n  simpa only [sub_add_cancel] using (h (x - c)).symm\n\n"}
{"name":"Function.Periodic.sub_eq'","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : AddCommGroup α\nh : Function.Periodic f c\n⊢ Eq (f (HSub.hSub c x)) (f (Neg.neg x))","decl":"theorem Periodic.sub_eq' [AddCommGroup α] (h : Periodic f c) : f (c - x) = f (-x) := by\n  simpa only [sub_eq_neg_add] using h (-x)\n\n"}
{"name":"Function.Periodic.neg","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\n⊢ Function.Periodic f (Neg.neg c)","decl":"protected theorem Periodic.neg [AddGroup α] (h : Periodic f c) : Periodic f (-c) := by\n  simpa only [sub_eq_add_neg, Periodic] using h.sub_eq\n\n"}
{"name":"Function.Periodic.sub_period","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝ : AddGroup α\nh1 : Function.Periodic f c₁\nh2 : Function.Periodic f c₂\n⊢ Function.Periodic f (HSub.hSub c₁ c₂)","decl":"theorem Periodic.sub_period [AddGroup α] (h1 : Periodic f c₁) (h2 : Periodic f c₂) :\n    Periodic f (c₁ - c₂) := fun x => by\n  rw [sub_eq_add_neg, ← add_assoc, h2.neg, h1]\n\n"}
{"name":"Function.Periodic.const_add","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddSemigroup α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HAdd.hAdd a x)) c","decl":"theorem Periodic.const_add [AddSemigroup α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (a + x)) c := fun x => by simpa [add_assoc] using h (a + x)\n\n"}
{"name":"Function.Periodic.add_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddCommSemigroup α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HAdd.hAdd x a)) c","decl":"theorem Periodic.add_const [AddCommSemigroup α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (x + a)) c := fun x => by\n  simpa only [add_right_comm] using h (x + a)\n\n"}
{"name":"Function.Periodic.const_sub","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddCommGroup α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HSub.hSub a x)) c","decl":"theorem Periodic.const_sub [AddCommGroup α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (a - x)) c := fun x => by\n  simp only [← sub_sub, h.sub_eq]\n\n"}
{"name":"Function.Periodic.sub_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddCommGroup α\nh : Function.Periodic f c\na : α\n⊢ Function.Periodic (fun x => f (HSub.hSub x a)) c","decl":"theorem Periodic.sub_const [AddCommGroup α] (h : Periodic f c) (a : α) :\n    Periodic (fun x => f (x - a)) c := by\n  simpa only [sub_eq_add_neg] using h.add_const (-a)\n\n"}
{"name":"Function.Periodic.nsmul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddMonoid α\nh : Function.Periodic f c\nn : Nat\n⊢ Function.Periodic f (HSMul.hSMul n c)","decl":"theorem Periodic.nsmul [AddMonoid α] (h : Periodic f c) (n : ℕ) : Periodic f (n • c) := by\n  induction n <;> simp_all [add_nsmul, ← add_assoc, zero_nsmul]\n\n"}
{"name":"Function.Periodic.nat_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : Semiring α\nh : Function.Periodic f c\nn : Nat\n⊢ Function.Periodic f (HMul.hMul (↑n) c)","decl":"theorem Periodic.nat_mul [Semiring α] (h : Periodic f c) (n : ℕ) : Periodic f (n * c) := by\n  simpa only [nsmul_eq_mul] using h.nsmul n\n\n"}
{"name":"Function.Periodic.neg_nsmul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\nn : Nat\n⊢ Function.Periodic f (Neg.neg (HSMul.hSMul n c))","decl":"theorem Periodic.neg_nsmul [AddGroup α] (h : Periodic f c) (n : ℕ) : Periodic f (-(n • c)) :=\n  (h.nsmul n).neg\n\n"}
{"name":"Function.Periodic.neg_nat_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Nat\n⊢ Function.Periodic f (Neg.neg (HMul.hMul (↑n) c))","decl":"theorem Periodic.neg_nat_mul [Ring α] (h : Periodic f c) (n : ℕ) : Periodic f (-(n * c)) :=\n  (h.nat_mul n).neg\n\n"}
{"name":"Function.Periodic.sub_nsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub x (HSMul.hSMul n c))) (f x)","decl":"theorem Periodic.sub_nsmul_eq [AddGroup α] (h : Periodic f c) (n : ℕ) : f (x - n • c) = f x := by\n  simpa only [sub_eq_add_neg] using h.neg_nsmul n x\n\n"}
{"name":"Function.Periodic.sub_nat_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub x (HMul.hMul (↑n) c))) (f x)","decl":"theorem Periodic.sub_nat_mul_eq [Ring α] (h : Periodic f c) (n : ℕ) : f (x - n * c) = f x := by\n  simpa only [nsmul_eq_mul] using h.sub_nsmul_eq n\n\n"}
{"name":"Function.Periodic.nsmul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : AddCommGroup α\nh : Function.Periodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub (HSMul.hSMul n c) x)) (f (Neg.neg x))","decl":"theorem Periodic.nsmul_sub_eq [AddCommGroup α] (h : Periodic f c) (n : ℕ) :\n    f (n • c - x) = f (-x) :=\n  (h.nsmul n).sub_eq'\n\n"}
{"name":"Function.Periodic.nat_mul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub (HMul.hMul (↑n) c) x)) (f (Neg.neg x))","decl":"theorem Periodic.nat_mul_sub_eq [Ring α] (h : Periodic f c) (n : ℕ) : f (n * c - x) = f (-x) := by\n  simpa only [sub_eq_neg_add] using h.nat_mul n (-x)\n\n"}
{"name":"Function.Periodic.zsmul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\nn : Int\n⊢ Function.Periodic f (HSMul.hSMul n c)","decl":"protected theorem Periodic.zsmul [AddGroup α] (h : Periodic f c) (n : ℤ) : Periodic f (n • c) := by\n  rcases n with n | n\n  · simpa only [Int.ofNat_eq_coe, natCast_zsmul] using h.nsmul n\n  · simpa only [negSucc_zsmul] using (h.nsmul (n + 1)).neg\n\n"}
{"name":"Function.Periodic.int_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Int\n⊢ Function.Periodic f (HMul.hMul (↑n) c)","decl":"protected theorem Periodic.int_mul [Ring α] (h : Periodic f c) (n : ℤ) : Periodic f (n * c) := by\n  simpa only [zsmul_eq_mul] using h.zsmul n\n\n"}
{"name":"Function.Periodic.sub_zsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\nn : Int\n⊢ Eq (f (HSub.hSub x (HSMul.hSMul n c))) (f x)","decl":"theorem Periodic.sub_zsmul_eq [AddGroup α] (h : Periodic f c) (n : ℤ) : f (x - n • c) = f x :=\n  (h.zsmul n).sub_eq x\n\n"}
{"name":"Function.Periodic.sub_int_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Int\n⊢ Eq (f (HSub.hSub x (HMul.hMul (↑n) c))) (f x)","decl":"theorem Periodic.sub_int_mul_eq [Ring α] (h : Periodic f c) (n : ℤ) : f (x - n * c) = f x :=\n  (h.int_mul n).sub_eq x\n\n"}
{"name":"Function.Periodic.zsmul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : AddCommGroup α\nh : Function.Periodic f c\nn : Int\n⊢ Eq (f (HSub.hSub (HSMul.hSMul n c) x)) (f (Neg.neg x))","decl":"theorem Periodic.zsmul_sub_eq [AddCommGroup α] (h : Periodic f c) (n : ℤ) :\n    f (n • c - x) = f (-x) :=\n  (h.zsmul _).sub_eq'\n\n"}
{"name":"Function.Periodic.int_mul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Int\n⊢ Eq (f (HSub.hSub (HMul.hMul (↑n) c) x)) (f (Neg.neg x))","decl":"theorem Periodic.int_mul_sub_eq [Ring α] (h : Periodic f c) (n : ℤ) : f (n * c - x) = f (-x) :=\n  (h.int_mul _).sub_eq'\n\n"}
{"name":"Function.Periodic.eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddZeroClass α\nh : Function.Periodic f c\n⊢ Eq (f c) (f 0)","decl":"protected theorem Periodic.eq [AddZeroClass α] (h : Periodic f c) : f c = f 0 := by\n  simpa only [zero_add] using h 0\n\n"}
{"name":"Function.Periodic.neg_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\n⊢ Eq (f (Neg.neg c)) (f 0)","decl":"protected theorem Periodic.neg_eq [AddGroup α] (h : Periodic f c) : f (-c) = f 0 :=\n  h.neg.eq\n\n"}
{"name":"Function.Periodic.nsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddMonoid α\nh : Function.Periodic f c\nn : Nat\n⊢ Eq (f (HSMul.hSMul n c)) (f 0)","decl":"protected theorem Periodic.nsmul_eq [AddMonoid α] (h : Periodic f c) (n : ℕ) : f (n • c) = f 0 :=\n  (h.nsmul n).eq\n\n"}
{"name":"Function.Periodic.nat_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : Semiring α\nh : Function.Periodic f c\nn : Nat\n⊢ Eq (f (HMul.hMul (↑n) c)) (f 0)","decl":"theorem Periodic.nat_mul_eq [Semiring α] (h : Periodic f c) (n : ℕ) : f (n * c) = f 0 :=\n  (h.nat_mul n).eq\n\n"}
{"name":"Function.Periodic.zsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\nn : Int\n⊢ Eq (f (HSMul.hSMul n c)) (f 0)","decl":"theorem Periodic.zsmul_eq [AddGroup α] (h : Periodic f c) (n : ℤ) : f (n • c) = f 0 :=\n  (h.zsmul n).eq\n\n"}
{"name":"Function.Periodic.int_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : Ring α\nh : Function.Periodic f c\nn : Int\n⊢ Eq (f (HMul.hMul (↑n) c)) (f 0)","decl":"theorem Periodic.int_mul_eq [Ring α] (h : Periodic f c) (n : ℤ) : f (n * c) = f 0 :=\n  (h.int_mul n).eq\n\n"}
{"name":"Function.Periodic.exists_mem_Ico₀","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\nh : Function.Periodic f c\nhc : LT.lt 0 c\nx : α\n⊢ Exists fun y => And (Membership.mem (Set.Ico 0 c) y) (Eq (f x) (f y))","decl":"/-- If a function `f` is `Periodic` with positive period `c`, then for all `x` there exists some\n  `y ∈ Ico 0 c` such that `f x = f y`. -/\ntheorem Periodic.exists_mem_Ico₀ [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)\n    (hc : 0 < c) (x) : ∃ y ∈ Ico 0 c, f x = f y :=\n  let ⟨n, H, _⟩ := existsUnique_zsmul_near_of_pos' hc x\n  ⟨x - n • c, H, (h.sub_zsmul_eq n).symm⟩\n\n"}
{"name":"Function.Periodic.exists_mem_Ico","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\nh : Function.Periodic f c\nhc : LT.lt 0 c\nx a : α\n⊢ Exists fun y => And (Membership.mem (Set.Ico a (HAdd.hAdd a c)) y) (Eq (f x) (f y))","decl":"/-- If a function `f` is `Periodic` with positive period `c`, then for all `x` there exists some\n  `y ∈ Ico a (a + c)` such that `f x = f y`. -/\ntheorem Periodic.exists_mem_Ico [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)\n    (hc : 0 < c) (x a) : ∃ y ∈ Ico a (a + c), f x = f y :=\n  let ⟨n, H, _⟩ := existsUnique_add_zsmul_mem_Ico hc x a\n  ⟨x + n • c, H, (h.zsmul n x).symm⟩\n\n"}
{"name":"Function.Periodic.exists_mem_Ioc","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\nh : Function.Periodic f c\nhc : LT.lt 0 c\nx a : α\n⊢ Exists fun y => And (Membership.mem (Set.Ioc a (HAdd.hAdd a c)) y) (Eq (f x) (f y))","decl":"/-- If a function `f` is `Periodic` with positive period `c`, then for all `x` there exists some\n  `y ∈ Ioc a (a + c)` such that `f x = f y`. -/\ntheorem Periodic.exists_mem_Ioc [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)\n    (hc : 0 < c) (x a) : ∃ y ∈ Ioc a (a + c), f x = f y :=\n  let ⟨n, H, _⟩ := existsUnique_add_zsmul_mem_Ioc hc x a\n  ⟨x + n • c, H, (h.zsmul n x).symm⟩\n\n"}
{"name":"Function.Periodic.image_Ioc","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\nh : Function.Periodic f c\nhc : LT.lt 0 c\na : α\n⊢ Eq (Set.image f (Set.Ioc a (HAdd.hAdd a c))) (Set.range f)","decl":"theorem Periodic.image_Ioc [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)\n    (hc : 0 < c) (a : α) : f '' Ioc a (a + c) = range f :=\n  (image_subset_range _ _).antisymm <| range_subset_iff.2 fun x =>\n    let ⟨y, hy, hyx⟩ := h.exists_mem_Ioc hc x a\n    ⟨y, hy, hyx.symm⟩\n\n"}
{"name":"Function.Periodic.image_Icc","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\nh : Function.Periodic f c\nhc : LT.lt 0 c\na : α\n⊢ Eq (Set.image f (Set.Icc a (HAdd.hAdd a c))) (Set.range f)","decl":"theorem Periodic.image_Icc [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)\n    (hc : 0 < c) (a : α) : f '' Icc a (a + c) = range f :=\n  (image_subset_range _ _).antisymm <| h.image_Ioc hc a ▸ image_subset _ Ioc_subset_Icc_self\n\n"}
{"name":"Function.Periodic.image_uIcc","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : LinearOrderedAddCommGroup α\ninst✝ : Archimedean α\nh : Function.Periodic f c\nhc : Ne c 0\na : α\n⊢ Eq (Set.image f (Set.uIcc a (HAdd.hAdd a c))) (Set.range f)","decl":"theorem Periodic.image_uIcc [LinearOrderedAddCommGroup α] [Archimedean α] (h : Periodic f c)\n    (hc : c ≠ 0) (a : α) : f '' uIcc a (a + c) = range f := by\n  cases hc.lt_or_lt with\n  | inl hc =>\n    rw [uIcc_of_ge (add_le_of_nonpos_right hc.le), ← h.neg.image_Icc (neg_pos.2 hc) (a + c),\n      add_neg_cancel_right]\n  | inr hc => rw [uIcc_of_le (le_add_of_nonneg_right hc.le), h.image_Icc hc]\n\n"}
{"name":"Function.periodic_with_period_zero","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : AddZeroClass α\nf : α → β\n⊢ Function.Periodic f 0","decl":"theorem periodic_with_period_zero [AddZeroClass α] (f : α → β) : Periodic f 0 := fun x => by\n  rw [add_zero]\n\n"}
{"name":"Function.Periodic.map_vadd_zmultiples","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddCommGroup α\nhf : Function.Periodic f c\na : Subtype fun x => Membership.mem (AddSubgroup.zmultiples c) x\nx : α\n⊢ Eq (f (HVAdd.hVAdd a x)) (f x)","decl":"theorem Periodic.map_vadd_zmultiples [AddCommGroup α] (hf : Periodic f c)\n    (a : AddSubgroup.zmultiples c) (x : α) : f (a +ᵥ x) = f x := by\n  rcases a with ⟨_, m, rfl⟩\n  simp [AddSubgroup.vadd_def, add_comm _ x, hf.zsmul m x]\n\n"}
{"name":"Function.Periodic.map_vadd_multiples","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddCommMonoid α\nhf : Function.Periodic f c\na : Subtype fun x => Membership.mem (AddSubmonoid.multiples c) x\nx : α\n⊢ Eq (f (HVAdd.hVAdd a x)) (f x)","decl":"theorem Periodic.map_vadd_multiples [AddCommMonoid α] (hf : Periodic f c)\n    (a : AddSubmonoid.multiples c) (x : α) : f (a +ᵥ x) = f x := by\n  rcases a with ⟨_, m, rfl⟩\n  simp [AddSubmonoid.vadd_def, add_comm _ x, hf.nsmul m x]\n\n"}
{"name":"Function.Periodic.lift_coe","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝ : AddGroup α\nh : Function.Periodic f c\na : α\n⊢ Eq (h.lift ↑a) (f a)","decl":"@[simp]\ntheorem Periodic.lift_coe [AddGroup α] (h : Periodic f c) (a : α) :\n    h.lift (a : α ⧸ AddSubgroup.zmultiples c) = f a :=\n  rfl\n\n"}
{"name":"Function.Periodic.not_injective","module":"Mathlib.Algebra.Periodic","initialProofState":"R : Type u_4\nX : Type u_5\ninst✝ : AddZeroClass R\nf : R → X\nc : R\nhf : Function.Periodic f c\nhc : Ne c 0\n⊢ Not (Function.Injective f)","decl":"/-- A periodic function `f : R → X` on a semiring (or, more generally, `AddZeroClass`)\nof non-zero period is not injective. -/\nlemma Periodic.not_injective {R X : Type*} [AddZeroClass R] {f : R → X} {c : R}\n    (hf : Periodic f c) (hc : c ≠ 0) : ¬ Injective f := fun h ↦ hc <| h hf.eq\n\n"}
{"name":"Function.Antiperiodic.funext","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\n⊢ Eq (fun x => f (HAdd.hAdd x c)) (Neg.neg f)","decl":"protected theorem Antiperiodic.funext [Add α] [Neg β] (h : Antiperiodic f c) :\n    (fun x => f (x + c)) = -f :=\n  funext h\n\n"}
{"name":"Function.Antiperiodic.funext'","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Add α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\n⊢ Eq (fun x => Neg.neg (f (HAdd.hAdd x c))) f","decl":"protected theorem Antiperiodic.funext' [Add α] [InvolutiveNeg β] (h : Antiperiodic f c) :\n    (fun x => -f (x + c)) = f :=\n  neg_eq_iff_eq_neg.mpr h.funext\n\n"}
{"name":"Function.Antiperiodic.periodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddMonoid α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\n⊢ Function.Periodic f (HSMul.hSMul 2 c)","decl":"/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `Periodic` with period\n`2 • c`. -/\nprotected theorem Antiperiodic.periodic [AddMonoid α] [InvolutiveNeg β]\n    (h : Antiperiodic f c) : Periodic f (2 • c) := by simp [two_nsmul, ← add_assoc, h _]\n\n"}
{"name":"Function.Antiperiodic.periodic_two_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Semiring α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\n⊢ Function.Periodic f (HMul.hMul 2 c)","decl":"/-- If a function is `antiperiodic` with antiperiod `c`, then it is also `Periodic` with period\n  `2 * c`. -/\nprotected theorem Antiperiodic.periodic_two_mul [Semiring α] [InvolutiveNeg β]\n    (h : Antiperiodic f c) : Periodic f (2 * c) := nsmul_eq_mul 2 c ▸ h.periodic\n\n"}
{"name":"Function.Antiperiodic.eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddZeroClass α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\n⊢ Eq (f c) (Neg.neg (f 0))","decl":"protected theorem Antiperiodic.eq [AddZeroClass α] [Neg β] (h : Antiperiodic f c) : f c = -f 0 := by\n  simpa only [zero_add] using h 0\n\n"}
{"name":"Function.Antiperiodic.even_nsmul_periodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddMonoid α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Function.Periodic f (HSMul.hSMul (HMul.hMul 2 n) c)","decl":"theorem Antiperiodic.even_nsmul_periodic [AddMonoid α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℕ) : Periodic f ((2 * n) • c) := mul_nsmul c 2 n ▸ h.periodic.nsmul n\n\n"}
{"name":"Function.Antiperiodic.nat_even_mul_periodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Semiring α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Function.Periodic f (HMul.hMul (↑n) (HMul.hMul 2 c))","decl":"theorem Antiperiodic.nat_even_mul_periodic [Semiring α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℕ) : Periodic f (n * (2 * c)) :=\n  h.periodic_two_mul.nat_mul n\n\n"}
{"name":"Function.Antiperiodic.odd_nsmul_antiperiodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddMonoid α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Function.Antiperiodic f (HSMul.hSMul (HAdd.hAdd (HMul.hMul 2 n) 1) c)","decl":"theorem Antiperiodic.odd_nsmul_antiperiodic [AddMonoid α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℕ) : Antiperiodic f ((2 * n + 1) • c) := fun x => by\n  rw [add_nsmul, one_nsmul, ← add_assoc, h, h.even_nsmul_periodic]\n\n"}
{"name":"Function.Antiperiodic.nat_odd_mul_antiperiodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Semiring α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Function.Antiperiodic f (HAdd.hAdd (HMul.hMul (↑n) (HMul.hMul 2 c)) c)","decl":"theorem Antiperiodic.nat_odd_mul_antiperiodic [Semiring α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℕ) : Antiperiodic f (n * (2 * c) + c) := fun x => by\n  rw [← add_assoc, h, h.nat_even_mul_periodic]\n\n"}
{"name":"Function.Antiperiodic.even_zsmul_periodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Function.Periodic f (HSMul.hSMul (HMul.hMul 2 n) c)","decl":"theorem Antiperiodic.even_zsmul_periodic [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℤ) : Periodic f ((2 * n) • c) := by\n  rw [mul_comm, mul_zsmul, two_zsmul, ← two_nsmul]\n  exact h.periodic.zsmul n\n\n"}
{"name":"Function.Antiperiodic.int_even_mul_periodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Ring α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Function.Periodic f (HMul.hMul (↑n) (HMul.hMul 2 c))","decl":"theorem Antiperiodic.int_even_mul_periodic [Ring α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℤ) : Periodic f (n * (2 * c)) :=\n  h.periodic_two_mul.int_mul n\n\n"}
{"name":"Function.Antiperiodic.odd_zsmul_antiperiodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Function.Antiperiodic f (HSMul.hSMul (HAdd.hAdd (HMul.hMul 2 n) 1) c)","decl":"theorem Antiperiodic.odd_zsmul_antiperiodic [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℤ) : Antiperiodic f ((2 * n + 1) • c) := by\n  intro x\n  rw [add_zsmul, one_zsmul, ← add_assoc, h, h.even_zsmul_periodic]\n\n"}
{"name":"Function.Antiperiodic.int_odd_mul_antiperiodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Ring α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Function.Antiperiodic f (HAdd.hAdd (HMul.hMul (↑n) (HMul.hMul 2 c)) c)","decl":"theorem Antiperiodic.int_odd_mul_antiperiodic [Ring α] [InvolutiveNeg β] (h : Antiperiodic f c)\n    (n : ℤ) : Antiperiodic f (n * (2 * c) + c) := fun x => by\n  rw [← add_assoc, h, h.int_even_mul_periodic]\n\n"}
{"name":"Function.Antiperiodic.sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\nx : α\n⊢ Eq (f (HSub.hSub x c)) (Neg.neg (f x))","decl":"theorem Antiperiodic.sub_eq [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) (x : α) :\n    f (x - c) = -f x := by simp only [← neg_eq_iff_eq_neg, ← h (x - c), sub_add_cancel]\n\n"}
{"name":"Function.Antiperiodic.sub_eq'","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddCommGroup α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\n⊢ Eq (f (HSub.hSub c x)) (Neg.neg (f (Neg.neg x)))","decl":"theorem Antiperiodic.sub_eq' [AddCommGroup α] [Neg β] (h : Antiperiodic f c) :\n    f (c - x) = -f (-x) := by simpa only [sub_eq_neg_add] using h (-x)\n\n"}
{"name":"Function.Antiperiodic.neg","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\n⊢ Function.Antiperiodic f (Neg.neg c)","decl":"protected theorem Antiperiodic.neg [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) :\n    Antiperiodic f (-c) := by simpa only [sub_eq_add_neg, Antiperiodic] using h.sub_eq\n\n"}
{"name":"Function.Antiperiodic.neg_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\n⊢ Eq (f (Neg.neg c)) (Neg.neg (f 0))","decl":"theorem Antiperiodic.neg_eq [AddGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) :\n    f (-c) = -f 0 := by\n  simpa only [zero_add] using h.neg 0\n\n"}
{"name":"Function.Antiperiodic.nat_mul_eq_of_eq_zero","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Semiring α\ninst✝ : NegZeroClass β\nh : Function.Antiperiodic f c\nhi : Eq (f 0) 0\nn : Nat\n⊢ Eq (f (HMul.hMul (↑n) c)) 0","decl":"theorem Antiperiodic.nat_mul_eq_of_eq_zero [Semiring α] [NegZeroClass β] (h : Antiperiodic f c)\n    (hi : f 0 = 0) : ∀ n : ℕ, f (n * c) = 0\n  | 0 => by rwa [Nat.cast_zero, zero_mul]\n  | n + 1 => by simp [add_mul, h _, Antiperiodic.nat_mul_eq_of_eq_zero h hi n]\n\n"}
{"name":"Function.Antiperiodic.int_mul_eq_of_eq_zero","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : Ring α\ninst✝ : SubtractionMonoid β\nh : Function.Antiperiodic f c\nhi : Eq (f 0) 0\nn : Int\n⊢ Eq (f (HMul.hMul (↑n) c)) 0","decl":"theorem Antiperiodic.int_mul_eq_of_eq_zero [Ring α] [SubtractionMonoid β] (h : Antiperiodic f c)\n    (hi : f 0 = 0) : ∀ n : ℤ, f (n * c) = 0\n  | (n : ℕ) => by rw [Int.cast_natCast, h.nat_mul_eq_of_eq_zero hi n]\n  | .negSucc n => by rw [Int.cast_negSucc, neg_mul, ← mul_neg, h.neg.nat_mul_eq_of_eq_zero hi]\n\n"}
{"name":"Function.Antiperiodic.add_zsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddGroup α\ninst✝ : AddGroup β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Eq (f (HAdd.hAdd x (HSMul.hSMul n c))) (HSMul.hSMul (↑n.negOnePow) (f x))","decl":"theorem Antiperiodic.add_zsmul_eq [AddGroup α] [AddGroup β] (h : Antiperiodic f c) (n : ℤ) :\n    f (x + n • c) = (n.negOnePow : ℤ) • f x := by\n  rcases Int.even_or_odd' n with ⟨k, rfl | rfl⟩\n  · rw [h.even_zsmul_periodic, Int.negOnePow_two_mul, Units.val_one, one_zsmul]\n  · rw [h.odd_zsmul_antiperiodic, Int.negOnePow_two_mul_add_one, Units.val_neg,\n      Units.val_one, neg_zsmul, one_zsmul]\n\n"}
{"name":"Function.Antiperiodic.sub_zsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddGroup α\ninst✝ : AddGroup β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Eq (f (HSub.hSub x (HSMul.hSMul n c))) (HSMul.hSMul (↑n.negOnePow) (f x))","decl":"theorem Antiperiodic.sub_zsmul_eq [AddGroup α] [AddGroup β] (h : Antiperiodic f c) (n : ℤ) :\n    f (x - n • c) = (n.negOnePow : ℤ) • f x := by\n  simpa only [sub_eq_add_neg, neg_zsmul, Int.negOnePow_neg] using h.add_zsmul_eq (-n)\n\n"}
{"name":"Function.Antiperiodic.zsmul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddCommGroup α\ninst✝ : AddGroup β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Eq (f (HSub.hSub (HSMul.hSMul n c) x)) (HSMul.hSMul (↑n.negOnePow) (f (Neg.neg x)))","decl":"theorem Antiperiodic.zsmul_sub_eq [AddCommGroup α] [AddGroup β] (h : Antiperiodic f c) (n : ℤ) :\n    f (n • c - x) = (n.negOnePow : ℤ) • f (-x) := by\n  rw [sub_eq_add_neg, add_comm]\n  exact h.add_zsmul_eq n\n\n"}
{"name":"Function.Antiperiodic.add_int_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : Ring α\ninst✝ : Ring β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Eq (f (HAdd.hAdd x (HMul.hMul (↑n) c))) (HMul.hMul (↑↑n.negOnePow) (f x))","decl":"theorem Antiperiodic.add_int_mul_eq [Ring α] [Ring β] (h : Antiperiodic f c) (n : ℤ) :\n    f (x + n * c) = (n.negOnePow : ℤ) * f x := by simpa only [zsmul_eq_mul] using h.add_zsmul_eq n\n\n"}
{"name":"Function.Antiperiodic.sub_int_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : Ring α\ninst✝ : Ring β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Eq (f (HSub.hSub x (HMul.hMul (↑n) c))) (HMul.hMul (↑↑n.negOnePow) (f x))","decl":"theorem Antiperiodic.sub_int_mul_eq [Ring α] [Ring β] (h : Antiperiodic f c) (n : ℤ) :\n    f (x - n * c) = (n.negOnePow : ℤ) * f x := by simpa only [zsmul_eq_mul] using h.sub_zsmul_eq n\n\n"}
{"name":"Function.Antiperiodic.int_mul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : Ring α\ninst✝ : Ring β\nh : Function.Antiperiodic f c\nn : Int\n⊢ Eq (f (HSub.hSub (HMul.hMul (↑n) c) x)) (HMul.hMul (↑↑n.negOnePow) (f (Neg.neg x)))","decl":"theorem Antiperiodic.int_mul_sub_eq [Ring α] [Ring β] (h : Antiperiodic f c) (n : ℤ) :\n    f (n * c - x) = (n.negOnePow : ℤ) * f (-x) := by\n  simpa only [zsmul_eq_mul] using h.zsmul_sub_eq n\n\n"}
{"name":"Function.Antiperiodic.add_nsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddMonoid α\ninst✝ : AddGroup β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Eq (f (HAdd.hAdd x (HSMul.hSMul n c))) (HSMul.hSMul (HPow.hPow (-1) n) (f x))","decl":"theorem Antiperiodic.add_nsmul_eq [AddMonoid α] [AddGroup β] (h : Antiperiodic f c) (n : ℕ) :\n    f (x + n • c) = (-1) ^ n • f x := by\n  rcases Nat.even_or_odd' n with ⟨k, rfl | rfl⟩\n  · rw [h.even_nsmul_periodic, pow_mul, (by norm_num : (-1) ^ 2 = 1), one_pow, one_zsmul]\n  · rw [h.odd_nsmul_antiperiodic, pow_add, pow_mul, (by norm_num : (-1) ^ 2 = 1), one_pow,\n      pow_one, one_mul, neg_zsmul, one_zsmul]\n\n"}
{"name":"Function.Antiperiodic.sub_nsmul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddGroup α\ninst✝ : AddGroup β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub x (HSMul.hSMul n c))) (HSMul.hSMul (HPow.hPow (-1) n) (f x))","decl":"theorem Antiperiodic.sub_nsmul_eq [AddGroup α] [AddGroup β] (h : Antiperiodic f c) (n : ℕ) :\n    f (x - n • c) = (-1) ^ n • f x := by\n  simpa only [Int.reduceNeg, natCast_zsmul] using h.sub_zsmul_eq n\n\n"}
{"name":"Function.Antiperiodic.nsmul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : AddCommGroup α\ninst✝ : AddGroup β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub (HSMul.hSMul n c) x)) (HSMul.hSMul (HPow.hPow (-1) n) (f (Neg.neg x)))","decl":"theorem Antiperiodic.nsmul_sub_eq [AddCommGroup α] [AddGroup β] (h : Antiperiodic f c) (n : ℕ) :\n    f (n • c - x) = (-1) ^ n • f (-x) := by\n  simpa only [Int.reduceNeg, natCast_zsmul] using h.zsmul_sub_eq n\n\n"}
{"name":"Function.Antiperiodic.add_nat_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : Semiring α\ninst✝ : Ring β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Eq (f (HAdd.hAdd x (HMul.hMul (↑n) c))) (HMul.hMul (HPow.hPow (-1) n) (f x))","decl":"theorem Antiperiodic.add_nat_mul_eq [Semiring α] [Ring β] (h : Antiperiodic f c) (n : ℕ) :\n    f (x + n * c) = (-1) ^ n * f x := by\n  simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.add_nsmul_eq n\n\n"}
{"name":"Function.Antiperiodic.sub_nat_mul_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : Ring α\ninst✝ : Ring β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub x (HMul.hMul (↑n) c))) (HMul.hMul (HPow.hPow (-1) n) (f x))","decl":"theorem Antiperiodic.sub_nat_mul_eq [Ring α] [Ring β] (h : Antiperiodic f c) (n : ℕ) :\n    f (x - n * c) = (-1) ^ n * f x := by\n  simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.sub_nsmul_eq n\n\n"}
{"name":"Function.Antiperiodic.nat_mul_sub_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc x : α\ninst✝¹ : Ring α\ninst✝ : Ring β\nh : Function.Antiperiodic f c\nn : Nat\n⊢ Eq (f (HSub.hSub (HMul.hMul (↑n) c) x)) (HMul.hMul (HPow.hPow (-1) n) (f (Neg.neg x)))","decl":"theorem Antiperiodic.nat_mul_sub_eq [Ring α] [Ring β] (h : Antiperiodic f c) (n : ℕ) :\n    f (n * c - x) = (-1) ^ n * f (-x) := by\n  simpa only [nsmul_eq_mul, zsmul_eq_mul, Int.cast_pow, Int.cast_neg,\n    Int.cast_one] using h.nsmul_sub_eq n\n\n"}
{"name":"Function.Antiperiodic.const_add","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddSemigroup α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\n⊢ Function.Antiperiodic (fun x => f (HAdd.hAdd a x)) c","decl":"theorem Antiperiodic.const_add [AddSemigroup α] [Neg β] (h : Antiperiodic f c) (a : α) :\n    Antiperiodic (fun x => f (a + x)) c := fun x => by simpa [add_assoc] using h (a + x)\n\n"}
{"name":"Function.Antiperiodic.add_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddCommSemigroup α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\n⊢ Function.Antiperiodic (fun x => f (HAdd.hAdd x a)) c","decl":"theorem Antiperiodic.add_const [AddCommSemigroup α] [Neg β] (h : Antiperiodic f c) (a : α) :\n    Antiperiodic (fun x => f (x + a)) c := fun x => by\n  simpa only [add_right_comm] using h (x + a)\n\n"}
{"name":"Function.Antiperiodic.const_sub","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddCommGroup α\ninst✝ : InvolutiveNeg β\nh : Function.Antiperiodic f c\na : α\n⊢ Function.Antiperiodic (fun x => f (HSub.hSub a x)) c","decl":"theorem Antiperiodic.const_sub [AddCommGroup α] [InvolutiveNeg β] (h : Antiperiodic f c) (a : α) :\n    Antiperiodic (fun x => f (a - x)) c := fun x => by\n  simp only [← sub_sub, h.sub_eq]\n\n"}
{"name":"Function.Antiperiodic.sub_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : AddCommGroup α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\n⊢ Function.Antiperiodic (fun x => f (HSub.hSub x a)) c","decl":"theorem Antiperiodic.sub_const [AddCommGroup α] [Neg β] (h : Antiperiodic f c) (a : α) :\n    Antiperiodic (fun x => f (x - a)) c := by\n  simpa only [sub_eq_add_neg] using h.add_const (-a)\n\n"}
{"name":"Function.Antiperiodic.smul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝³ : Add α\ninst✝² : Monoid γ\ninst✝¹ : AddGroup β\ninst✝ : DistribMulAction γ β\nh : Function.Antiperiodic f c\na : γ\n⊢ Function.Antiperiodic (HSMul.hSMul a f) c","decl":"theorem Antiperiodic.smul [Add α] [Monoid γ] [AddGroup β] [DistribMulAction γ β]\n    (h : Antiperiodic f c) (a : γ) : Antiperiodic (a • f) c := by simp_all\n\n"}
{"name":"Function.Antiperiodic.const_smul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝³ : AddMonoid α\ninst✝² : Neg β\ninst✝¹ : Group γ\ninst✝ : DistribMulAction γ α\nh : Function.Antiperiodic f c\na : γ\n⊢ Function.Antiperiodic (fun x => f (HSMul.hSMul a x)) (HSMul.hSMul (Inv.inv a) c)","decl":"theorem Antiperiodic.const_smul [AddMonoid α] [Neg β] [Group γ] [DistribMulAction γ α]\n    (h : Antiperiodic f c) (a : γ) : Antiperiodic (fun x => f (a • x)) (a⁻¹ • c) := fun x => by\n  simpa only [smul_add, smul_inv_smul] using h (a • x)\n\n"}
{"name":"Function.Antiperiodic.const_smul₀","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝³ : AddCommMonoid α\ninst✝² : Neg β\ninst✝¹ : DivisionSemiring γ\ninst✝ : Module γ α\nh : Function.Antiperiodic f c\na : γ\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HSMul.hSMul a x)) (HSMul.hSMul (Inv.inv a) c)","decl":"theorem Antiperiodic.const_smul₀ [AddCommMonoid α] [Neg β] [DivisionSemiring γ] [Module γ α]\n    (h : Antiperiodic f c) {a : γ} (ha : a ≠ 0) : Antiperiodic (fun x => f (a • x)) (a⁻¹ • c) :=\n  fun x => by simpa only [smul_add, smul_inv_smul₀ ha] using h (a • x)\n\n"}
{"name":"Function.Antiperiodic.const_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : DivisionSemiring α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HMul.hMul a x)) (HMul.hMul (Inv.inv a) c)","decl":"theorem Antiperiodic.const_mul [DivisionSemiring α] [Neg β] (h : Antiperiodic f c) {a : α}\n    (ha : a ≠ 0) : Antiperiodic (fun x => f (a * x)) (a⁻¹ * c) :=\n  h.const_smul₀ ha\n\n"}
{"name":"Function.Antiperiodic.const_inv_smul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝³ : AddMonoid α\ninst✝² : Neg β\ninst✝¹ : Group γ\ninst✝ : DistribMulAction γ α\nh : Function.Antiperiodic f c\na : γ\n⊢ Function.Antiperiodic (fun x => f (HSMul.hSMul (Inv.inv a) x)) (HSMul.hSMul a c)","decl":"theorem Antiperiodic.const_inv_smul [AddMonoid α] [Neg β] [Group γ] [DistribMulAction γ α]\n    (h : Antiperiodic f c) (a : γ) : Antiperiodic (fun x => f (a⁻¹ • x)) (a • c) := by\n  simpa only [inv_inv] using h.const_smul a⁻¹\n\n"}
{"name":"Function.Antiperiodic.const_inv_smul₀","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nf : α → β\nc : α\ninst✝³ : AddCommMonoid α\ninst✝² : Neg β\ninst✝¹ : DivisionSemiring γ\ninst✝ : Module γ α\nh : Function.Antiperiodic f c\na : γ\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HSMul.hSMul (Inv.inv a) x)) (HSMul.hSMul a c)","decl":"theorem Antiperiodic.const_inv_smul₀ [AddCommMonoid α] [Neg β] [DivisionSemiring γ] [Module γ α]\n    (h : Antiperiodic f c) {a : γ} (ha : a ≠ 0) : Antiperiodic (fun x => f (a⁻¹ • x)) (a • c) := by\n  simpa only [inv_inv] using h.const_smul₀ (inv_ne_zero ha)\n\n"}
{"name":"Function.Antiperiodic.const_inv_mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : DivisionSemiring α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HMul.hMul (Inv.inv a) x)) (HMul.hMul a c)","decl":"theorem Antiperiodic.const_inv_mul [DivisionSemiring α] [Neg β] (h : Antiperiodic f c) {a : α}\n    (ha : a ≠ 0) : Antiperiodic (fun x => f (a⁻¹ * x)) (a * c) :=\n  h.const_inv_smul₀ ha\n\n"}
{"name":"Function.Antiperiodic.mul_const","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : DivisionSemiring α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HMul.hMul x a)) (HMul.hMul c (Inv.inv a))","decl":"theorem Antiperiodic.mul_const [DivisionSemiring α] [Neg β] (h : Antiperiodic f c) {a : α}\n    (ha : a ≠ 0) : Antiperiodic (fun x => f (x * a)) (c * a⁻¹) :=\n  h.const_smul₀ <| (MulOpposite.op_ne_zero_iff a).mpr ha\n\n"}
{"name":"Function.Antiperiodic.mul_const'","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : DivisionSemiring α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HMul.hMul x a)) (HDiv.hDiv c a)","decl":"theorem Antiperiodic.mul_const' [DivisionSemiring α] [Neg β] (h : Antiperiodic f c) {a : α}\n    (ha : a ≠ 0) : Antiperiodic (fun x => f (x * a)) (c / a) := by\n  simpa only [div_eq_mul_inv] using h.mul_const ha\n\n"}
{"name":"Function.Antiperiodic.mul_const_inv","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : DivisionSemiring α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HMul.hMul x (Inv.inv a))) (HMul.hMul c a)","decl":"theorem Antiperiodic.mul_const_inv [DivisionSemiring α] [Neg β] (h : Antiperiodic f c) {a : α}\n    (ha : a ≠ 0) : Antiperiodic (fun x => f (x * a⁻¹)) (c * a) :=\n  h.const_inv_smul₀ <| (MulOpposite.op_ne_zero_iff a).mpr ha\n\n"}
{"name":"Function.Antiperiodic.div_inv","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc : α\ninst✝¹ : DivisionSemiring α\ninst✝ : Neg β\nh : Function.Antiperiodic f c\na : α\nha : Ne a 0\n⊢ Function.Antiperiodic (fun x => f (HDiv.hDiv x a)) (HMul.hMul c a)","decl":"theorem Antiperiodic.div_inv [DivisionSemiring α] [Neg β] (h : Antiperiodic f c) {a : α}\n    (ha : a ≠ 0) : Antiperiodic (fun x => f (x / a)) (c * a) := by\n  simpa only [div_eq_mul_inv] using h.mul_const_inv ha\n\n"}
{"name":"Function.Antiperiodic.add","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh1 : Function.Antiperiodic f c₁\nh2 : Function.Antiperiodic f c₂\n⊢ Function.Periodic f (HAdd.hAdd c₁ c₂)","decl":"theorem Antiperiodic.add [AddGroup α] [InvolutiveNeg β] (h1 : Antiperiodic f c₁)\n    (h2 : Antiperiodic f c₂) : Periodic f (c₁ + c₂) := by simp_all [← add_assoc]\n\n"}
{"name":"Function.Antiperiodic.sub","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh1 : Function.Antiperiodic f c₁\nh2 : Function.Antiperiodic f c₂\n⊢ Function.Periodic f (HSub.hSub c₁ c₂)","decl":"theorem Antiperiodic.sub [AddGroup α] [InvolutiveNeg β] (h1 : Antiperiodic f c₁)\n    (h2 : Antiperiodic f c₂) : Periodic f (c₁ - c₂) := by\n  simpa only [sub_eq_add_neg] using h1.add h2.neg\n\n"}
{"name":"Function.Periodic.add_antiperiod","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝¹ : AddGroup α\ninst✝ : Neg β\nh1 : Function.Periodic f c₁\nh2 : Function.Antiperiodic f c₂\n⊢ Function.Antiperiodic f (HAdd.hAdd c₁ c₂)","decl":"theorem Periodic.add_antiperiod [AddGroup α] [Neg β] (h1 : Periodic f c₁) (h2 : Antiperiodic f c₂) :\n    Antiperiodic f (c₁ + c₂) := by simp_all [← add_assoc]\n\n"}
{"name":"Function.Periodic.sub_antiperiod","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh1 : Function.Periodic f c₁\nh2 : Function.Antiperiodic f c₂\n⊢ Function.Antiperiodic f (HSub.hSub c₁ c₂)","decl":"theorem Periodic.sub_antiperiod [AddGroup α] [InvolutiveNeg β] (h1 : Periodic f c₁)\n    (h2 : Antiperiodic f c₂) : Antiperiodic f (c₁ - c₂) := by\n  simpa only [sub_eq_add_neg] using h1.add_antiperiod h2.neg\n\n"}
{"name":"Function.Periodic.add_antiperiod_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝¹ : AddGroup α\ninst✝ : Neg β\nh1 : Function.Periodic f c₁\nh2 : Function.Antiperiodic f c₂\n⊢ Eq (f (HAdd.hAdd c₁ c₂)) (Neg.neg (f 0))","decl":"theorem Periodic.add_antiperiod_eq [AddGroup α] [Neg β] (h1 : Periodic f c₁)\n    (h2 : Antiperiodic f c₂) : f (c₁ + c₂) = -f 0 :=\n  (h1.add_antiperiod h2).eq\n\n"}
{"name":"Function.Periodic.sub_antiperiod_eq","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf : α → β\nc₁ c₂ : α\ninst✝¹ : AddGroup α\ninst✝ : InvolutiveNeg β\nh1 : Function.Periodic f c₁\nh2 : Function.Antiperiodic f c₂\n⊢ Eq (f (HSub.hSub c₁ c₂)) (Neg.neg (f 0))","decl":"theorem Periodic.sub_antiperiod_eq [AddGroup α] [InvolutiveNeg β] (h1 : Periodic f c₁)\n    (h2 : Antiperiodic f c₂) : f (c₁ - c₂) = -f 0 :=\n  (h1.sub_antiperiod h2).eq\n\n"}
{"name":"Function.Antiperiodic.mul","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nc : α\ninst✝² : Add α\ninst✝¹ : Mul β\ninst✝ : HasDistribNeg β\nhf : Function.Antiperiodic f c\nhg : Function.Antiperiodic g c\n⊢ Function.Periodic (HMul.hMul f g) c","decl":"theorem Antiperiodic.mul [Add α] [Mul β] [HasDistribNeg β] (hf : Antiperiodic f c)\n    (hg : Antiperiodic g c) : Periodic (f * g) c := by simp_all\n\n"}
{"name":"Function.Antiperiodic.div","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_1\nβ : Type u_2\nf g : α → β\nc : α\ninst✝² : Add α\ninst✝¹ : DivisionMonoid β\ninst✝ : HasDistribNeg β\nhf : Function.Antiperiodic f c\nhg : Function.Antiperiodic g c\n⊢ Function.Periodic (HDiv.hDiv f g) c","decl":"theorem Antiperiodic.div [Add α] [DivisionMonoid β] [HasDistribNeg β] (hf : Antiperiodic f c)\n    (hg : Antiperiodic g c) : Periodic (f / g) c := by simp_all [neg_div_neg_eq]\n\n"}
{"name":"Int.fract_periodic","module":"Mathlib.Algebra.Periodic","initialProofState":"α : Type u_4\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Function.Periodic Int.fract 1","decl":"theorem Int.fract_periodic (α) [LinearOrderedRing α] [FloorRing α] :\n    Function.Periodic Int.fract (1 : α) := fun a => mod_cast Int.fract_add_int a 1\n"}
