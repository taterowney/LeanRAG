{"name":"HasStrictDerivAt.map_nhds_eq","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ð•œ\ninstâœ : CompleteSpace ð•œ\nf : ð•œ â†’ ð•œ\nf' a : ð•œ\nhf : HasStrictDerivAt f f' a\nhf' : Ne f' 0\nâŠ¢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_eq : map f (ð“ a) = ð“ (f a) :=\n  (hf.hasStrictFDerivAt_equiv hf').map_nhds_eq_of_equiv\n\n"}
{"name":"HasStrictDerivAt.to_localInverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ð•œ\ninstâœ : CompleteSpace ð•œ\nf : ð•œ â†’ ð•œ\nf' a : ð•œ\nhf : HasStrictDerivAt f f' a\nhf' : Ne f' 0\nâŠ¢ HasStrictDerivAt (HasStrictDerivAt.localInverse f f' a hf hf') (Inv.inv f') (f a)","decl":"theorem to_localInverse : HasStrictDerivAt (hf.localInverse f f' a hf') f'â»Â¹ (f a) :=\n  (hf.hasStrictFDerivAt_equiv hf').to_localInverse\n\n"}
{"name":"HasStrictDerivAt.to_local_left_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ð•œ\ninstâœ : CompleteSpace ð•œ\nf : ð•œ â†’ ð•œ\nf' a : ð•œ\nhf : HasStrictDerivAt f f' a\nhf' : Ne f' 0\ng : ð•œ â†’ ð•œ\nhg : Filter.Eventually (fun x => Eq (g (f x)) x) (nhds a)\nâŠ¢ HasStrictDerivAt g (Inv.inv f') (f a)","decl":"theorem to_local_left_inverse {g : ð•œ â†’ ð•œ} (hg : âˆ€á¶  x in ð“ a, g (f x) = x) :\n    HasStrictDerivAt g f'â»Â¹ (f a) :=\n  (hf.hasStrictFDerivAt_equiv hf').to_local_left_inverse hg\n\n"}
{"name":"isOpenMap_of_hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"ð•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ð•œ\ninstâœ : CompleteSpace ð•œ\nf f' : ð•œ â†’ ð•œ\nhf : âˆ€ (x : ð•œ), HasStrictDerivAt f (f' x) x\nh0 : âˆ€ (x : ð•œ), Ne (f' x) 0\nâŠ¢ IsOpenMap f","decl":"/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem isOpenMap_of_hasStrictDerivAt {f' : ð•œ â†’ ð•œ}\n    (hf : âˆ€ x, HasStrictDerivAt f (f' x) x) (h0 : âˆ€ x, f' x â‰  0) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => ((hf x).map_nhds_eq (h0 x)).ge\n"}
