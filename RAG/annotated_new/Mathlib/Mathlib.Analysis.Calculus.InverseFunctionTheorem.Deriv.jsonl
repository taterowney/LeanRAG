{"name":"HasStrictDerivAt.map_nhds_eq","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : CompleteSpace 𝕜\nf : 𝕜 → 𝕜\nf' a : 𝕜\nhf : HasStrictDerivAt f f' a\nhf' : Ne f' 0\n⊢ Eq (Filter.map f (nhds a)) (nhds (f a))","decl":"theorem map_nhds_eq : map f (𝓝 a) = 𝓝 (f a) :=\n  (hf.hasStrictFDerivAt_equiv hf').map_nhds_eq_of_equiv\n\n"}
{"name":"HasStrictDerivAt.to_localInverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : CompleteSpace 𝕜\nf : 𝕜 → 𝕜\nf' a : 𝕜\nhf : HasStrictDerivAt f f' a\nhf' : Ne f' 0\n⊢ HasStrictDerivAt (HasStrictDerivAt.localInverse f f' a hf hf') (Inv.inv f') (f a)","decl":"theorem to_localInverse : HasStrictDerivAt (hf.localInverse f f' a hf') f'⁻¹ (f a) :=\n  (hf.hasStrictFDerivAt_equiv hf').to_localInverse\n\n"}
{"name":"HasStrictDerivAt.to_local_left_inverse","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : CompleteSpace 𝕜\nf : 𝕜 → 𝕜\nf' a : 𝕜\nhf : HasStrictDerivAt f f' a\nhf' : Ne f' 0\ng : 𝕜 → 𝕜\nhg : Filter.Eventually (fun x => Eq (g (f x)) x) (nhds a)\n⊢ HasStrictDerivAt g (Inv.inv f') (f a)","decl":"theorem to_local_left_inverse {g : 𝕜 → 𝕜} (hg : ∀ᶠ x in 𝓝 a, g (f x) = x) :\n    HasStrictDerivAt g f'⁻¹ (f a) :=\n  (hf.hasStrictFDerivAt_equiv hf').to_local_left_inverse hg\n\n"}
{"name":"isOpenMap_of_hasStrictDerivAt","module":"Mathlib.Analysis.Calculus.InverseFunctionTheorem.Deriv","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜\ninst✝ : CompleteSpace 𝕜\nf f' : 𝕜 → 𝕜\nhf : ∀ (x : 𝕜), HasStrictDerivAt f (f' x) x\nh0 : ∀ (x : 𝕜), Ne (f' x) 0\n⊢ IsOpenMap f","decl":"/-- If a function has a non-zero strict derivative at all points, then it is an open map. -/\ntheorem isOpenMap_of_hasStrictDerivAt {f' : 𝕜 → 𝕜}\n    (hf : ∀ x, HasStrictDerivAt f (f' x) x) (h0 : ∀ x, f' x ≠ 0) : IsOpenMap f :=\n  isOpenMap_iff_nhds_le.2 fun x => ((hf x).map_nhds_eq (h0 x)).ge\n"}
