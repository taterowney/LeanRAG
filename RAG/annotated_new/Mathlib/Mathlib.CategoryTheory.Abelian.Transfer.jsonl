{"name":"CategoryTheory.AbelianOfAdjunction.hasKernels","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù‚Å¥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst‚úù¬π : G.PreservesZeroMorphisms\ninst‚úù : CategoryTheory.Limits.PreservesFiniteLimits G\ni : CategoryTheory.Iso (F.comp G) (CategoryTheory.Functor.id C)\n‚ä¢ CategoryTheory.Limits.HasKernels C","decl":"/-- No point making this an instance, as it requires `i`. -/\ntheorem hasKernels [PreservesFiniteLimits G] (i : F ‚ãô G ‚âÖ ùü≠ C) : HasKernels C :=\n  { has_limit := fun f => by\n      have := NatIso.naturality_1 i f\n      simp? at this says\n        simp only [Functor.id_obj, Functor.comp_obj, Functor.comp_map, Functor.id_map] at this\n      rw [‚Üê this]\n      haveI : HasKernel (G.map (F.map f) ‚â´ i.hom.app _) := Limits.hasKernel_comp_mono _ _\n      apply Limits.hasKernel_iso_comp }\n\n"}
{"name":"CategoryTheory.AbelianOfAdjunction.hasCokernels","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : CategoryTheory.Abelian D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\ninst‚úù : G.PreservesZeroMorphisms\ni : CategoryTheory.Iso (F.comp G) (CategoryTheory.Functor.id C)\nadj : CategoryTheory.Adjunction G F\n‚ä¢ CategoryTheory.Limits.HasCokernels C","decl":"/-- No point making this an instance, as it requires `i` and `adj`. -/\ntheorem hasCokernels (i : F ‚ãô G ‚âÖ ùü≠ C) (adj : G ‚ä£ F) : HasCokernels C :=\n  { has_colimit := fun f => by\n      have : PreservesColimits G := adj.leftAdjoint_preservesColimits\n      have := NatIso.naturality_1 i f\n      simp? at this says\n        simp only [Functor.id_obj, Functor.comp_obj, Functor.comp_map, Functor.id_map] at this\n      rw [‚Üê this]\n      haveI : HasCokernel (G.map (F.map f) ‚â´ i.hom.app _) := Limits.hasCokernel_comp_iso _ _\n      apply Limits.hasCokernel_epi_comp }\n\n"}
{"name":"CategoryTheory.ShrinkHoms.functor_map_add","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nP Q : C\nf g : Quiver.Hom P Q\n‚ä¢ Eq ((CategoryTheory.ShrinkHoms.functor C).map (HAdd.hAdd f g)) (HAdd.hAdd ((CategoryTheory.ShrinkHoms.functor C).map f) ((CategoryTheory.ShrinkHoms.functor C).map g))","decl":"lemma functor_map_add {P Q : C} (f g : P ‚ü∂ Q) :\n    (functor C).map (f + g) =\n      (functor C).map f + (functor C).map g := by\n  exact map_add (equivShrink.{w} (P ‚ü∂ Q)).symm.addEquiv.symm f g\n\n"}
{"name":"CategoryTheory.ShrinkHoms.inverse_map_add","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nP Q : CategoryTheory.ShrinkHoms.{u_1} C\nf g : Quiver.Hom P Q\n‚ä¢ Eq ((CategoryTheory.ShrinkHoms.inverse C).map (HAdd.hAdd f g)) (HAdd.hAdd ((CategoryTheory.ShrinkHoms.inverse C).map f) ((CategoryTheory.ShrinkHoms.inverse C).map g))","decl":"lemma inverse_map_add {P Q : ShrinkHoms C} (f g : P ‚ü∂ Q) :\n    (inverse C).map (f + g) =\n      (inverse C).map f + (ShrinkHoms.inverse C).map g :=\n  map_add (equivShrink.{w} (P.fromShrinkHoms ‚ü∂ Q.fromShrinkHoms)).symm.addEquiv f g\n\n"}
{"name":"CategoryTheory.ShrinkHoms.instAdditiveInverse","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (CategoryTheory.ShrinkHoms.inverse C).Additive","decl":"instance : (inverse C).Additive :=\n  (equivalence C).symm.fullyFaithfulFunctor.additive_ofFullyFaithful\n\n"}
{"name":"CategoryTheory.ShrinkHoms.instAdditiveFunctor","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\n‚ä¢ (CategoryTheory.ShrinkHoms.functor C).Additive","decl":"instance : (functor C).Additive :=\n  (equivalence C).symm.additive_inverse_of_FullyFaithful\n\n"}
{"name":"CategoryTheory.ShrinkHoms.hasLimitsOfShape","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_1} C\ninst‚úù¬≤ : CategoryTheory.LocallySmall.{w, u_4, u_1} C\nJ : Type u_2\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_2} J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.ShrinkHoms.{u_1} C)","decl":"instance hasLimitsOfShape (J : Type*) [Category J]\n    [HasLimitsOfShape J C] : HasLimitsOfShape.{_, _, w} J (ShrinkHoms C) :=\n  Adjunction.hasLimitsOfShape_of_equivalence (inverse C)\n\n"}
{"name":"CategoryTheory.ShrinkHoms.hasFiniteLimits","module":"Mathlib.CategoryTheory.Abelian.Transfer","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù¬π : CategoryTheory.LocallySmall.{w, u_2, u_1} C\ninst‚úù : CategoryTheory.Limits.HasFiniteLimits C\n‚ä¢ CategoryTheory.Limits.HasFiniteLimits (CategoryTheory.ShrinkHoms.{u_1} C)","decl":"instance hasFiniteLimits [HasFiniteLimits C] :\n    HasFiniteLimits.{w} (ShrinkHoms C) := ‚ü®fun _ => inferInstance‚ü©\n\n"}
