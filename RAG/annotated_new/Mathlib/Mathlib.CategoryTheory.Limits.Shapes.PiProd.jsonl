{"name":"CategoryTheory.Limits.hasBinaryProduct_of_products","module":"Mathlib.CategoryTheory.Limits.Shapes.PiProd","initialProofState":"C : Type u_1\nI : Type u_2\ninst✝³ : CategoryTheory.Category.{u_3, u_1} C\nX : I → C\nP : I → Prop\ninst✝² : CategoryTheory.Limits.HasProduct X\ninst✝¹ : CategoryTheory.Limits.HasProduct fun i => X ↑i\ninst✝ : CategoryTheory.Limits.HasProduct fun i => X ↑i\n⊢ CategoryTheory.Limits.HasBinaryProduct (CategoryTheory.Limits.piObj fun i => X ↑i) (CategoryTheory.Limits.piObj fun i => X ↑i)","decl":"lemma hasBinaryProduct_of_products : HasBinaryProduct (∏ᶜ (fun (i : {x : I // P x}) ↦ X i.val))\n    (∏ᶜ (fun (i : {x : I // ¬ P x}) ↦ X i.val)) := by\n  classical exact ⟨Pi.binaryFanOfProp X P, Pi.binaryFanOfPropIsLimit X P⟩\n\n"}
{"name":"CategoryTheory.Limits.Pi.map_eq_prod_map","module":"Mathlib.CategoryTheory.Limits.Shapes.PiProd","initialProofState":"C : Type u_1\nI : Type u_2\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\nX Y : I → C\nf : (i : I) → Quiver.Hom (X i) (Y i)\nP : I → Prop\ninst✝⁶ : CategoryTheory.Limits.HasProduct X\ninst✝⁵ : CategoryTheory.Limits.HasProduct Y\ninst✝⁴ : CategoryTheory.Limits.HasProduct fun i => X ↑i\ninst✝³ : CategoryTheory.Limits.HasProduct fun i => X ↑i\ninst✝² : CategoryTheory.Limits.HasProduct fun i => Y ↑i\ninst✝¹ : CategoryTheory.Limits.HasProduct fun i => Y ↑i\ninst✝ : (i : I) → Decidable (P i)\n⊢ Eq (CategoryTheory.Limits.Pi.map f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.Pi.binaryFanOfPropIsLimit X P).conePointUniqueUpToIso (CategoryTheory.Limits.prodIsProd (CategoryTheory.Limits.piObj fun i => X ↑i) (CategoryTheory.Limits.piObj fun i => X ↑i))).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.prod.map (CategoryTheory.Limits.Pi.map fun i => f ↑i) (CategoryTheory.Limits.Pi.map fun i => f ↑i)) ((CategoryTheory.Limits.Pi.binaryFanOfPropIsLimit Y P).conePointUniqueUpToIso (CategoryTheory.Limits.prodIsProd (CategoryTheory.Limits.piObj fun i => Y ↑i) (CategoryTheory.Limits.piObj fun i => Y ↑i))).inv))","decl":"lemma Pi.map_eq_prod_map [∀ i, Decidable (P i)] : Pi.map f =\n    ((Pi.binaryFanOfPropIsLimit X P).conePointUniqueUpToIso (prodIsProd _ _)).hom ≫\n      prod.map (Pi.map (fun (i : {x : I // P x}) ↦ f i.val))\n      (Pi.map (fun (i : {x : I // ¬ P x}) ↦ f i.val)) ≫\n        ((Pi.binaryFanOfPropIsLimit Y P).conePointUniqueUpToIso (prodIsProd _ _)).inv := by\n  rw [← Category.assoc, Iso.eq_comp_inv]\n  dsimp only [IsLimit.conePointUniqueUpToIso, binaryFanOfProp, prodIsProd]\n  apply prod.hom_ext\n  all_goals aesop_cat\n\n"}
