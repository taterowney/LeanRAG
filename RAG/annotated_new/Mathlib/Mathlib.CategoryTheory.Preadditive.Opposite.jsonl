{"name":"CategoryTheory.unop_add","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : Opposite C\nf g : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd f g).unop (HAdd.hAdd f.unop g.unop)","decl":"@[simp]\ntheorem unop_add {X Y : Cᵒᵖ} (f g : X ⟶ Y) : (f + g).unop = f.unop + g.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.unop_zsmul","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : Opposite C\nk : Int\nf : Quiver.Hom X Y\n⊢ Eq (HSMul.hSMul k f).unop (HSMul.hSMul k f.unop)","decl":"@[simp]\ntheorem unop_zsmul {X Y : Cᵒᵖ} (k : ℤ) (f : X ⟶ Y) : (k • f).unop = k • f.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.unop_neg","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : Opposite C\nf : Quiver.Hom X Y\n⊢ Eq (Neg.neg f).unop (Neg.neg f.unop)","decl":"@[simp]\ntheorem unop_neg {X Y : Cᵒᵖ} (f : X ⟶ Y) : (-f).unop = -f.unop :=\n  rfl\n\n"}
{"name":"CategoryTheory.op_add","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf g : Quiver.Hom X Y\n⊢ Eq (HAdd.hAdd f g).op (HAdd.hAdd f.op g.op)","decl":"@[simp]\ntheorem op_add {X Y : C} (f g : X ⟶ Y) : (f + g).op = f.op + g.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.op_zsmul","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nk : Int\nf : Quiver.Hom X Y\n⊢ Eq (HSMul.hSMul k f).op (HSMul.hSMul k f.op)","decl":"@[simp]\ntheorem op_zsmul {X Y : C} (k : ℤ) (f : X ⟶ Y) : (k • f).op = k • f.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.op_neg","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (Neg.neg f).op (Neg.neg f.op)","decl":"@[simp]\ntheorem op_neg {X Y : C} (f : X ⟶ Y) : (-f).op = -f.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.unopHom_apply","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : Opposite C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.unopHom X Y) f) f.unop","decl":"/-- `unop` induces morphisms of monoids on hom groups of a preadditive category -/\n@[simps!]\ndef unopHom (X Y : Cᵒᵖ) : (X ⟶ Y) →+ (Opposite.unop Y ⟶ Opposite.unop X) :=\n  AddMonoidHom.mk' (fun f => f.unop) fun f g => unop_add _ f g\n\n"}
{"name":"CategoryTheory.unop_sum","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : Opposite C\nι : Type u_2\ns : Finset ι\nf : ι → Quiver.Hom X Y\n⊢ Eq (s.sum f).unop (s.sum fun i => (f i).unop)","decl":"@[simp]\ntheorem unop_sum (X Y : Cᵒᵖ) {ι : Type*} (s : Finset ι) (f : ι → (X ⟶ Y)) :\n    (s.sum f).unop = s.sum fun i => (f i).unop :=\n  map_sum (unopHom X Y) _ _\n\n"}
{"name":"CategoryTheory.opHom_apply","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq ((CategoryTheory.opHom X Y) f) f.op","decl":"/-- `op` induces morphisms of monoids on hom groups of a preadditive category -/\n@[simps!]\ndef opHom (X Y : C) : (X ⟶ Y) →+ (Opposite.op Y ⟶ Opposite.op X) :=\n  AddMonoidHom.mk' (fun f => f.op) fun f g => op_add _ f g\n\n"}
{"name":"CategoryTheory.op_sum","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nX Y : C\nι : Type u_2\ns : Finset ι\nf : ι → Quiver.Hom X Y\n⊢ Eq (s.sum f).op (s.sum fun i => (f i).op)","decl":"@[simp]\ntheorem op_sum (X Y : C) {ι : Type*} (s : Finset ι) (f : ι → (X ⟶ Y)) :\n    (s.sum f).op = s.sum fun i => (f i).op :=\n  map_sum (opHom X Y) _ _\n\n"}
{"name":"CategoryTheory.Functor.op_additive","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝ : F.Additive\n⊢ F.op.Additive","decl":"instance Functor.op_additive (F : C ⥤ D) [F.Additive] : F.op.Additive where\n\n"}
{"name":"CategoryTheory.Functor.rightOp_additive","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (Opposite C) D\ninst✝ : F.Additive\n⊢ F.rightOp.Additive","decl":"instance Functor.rightOp_additive (F : Cᵒᵖ ⥤ D) [F.Additive] : F.rightOp.Additive where\n\n"}
{"name":"CategoryTheory.Functor.leftOp_additive","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C (Opposite D)\ninst✝ : F.Additive\n⊢ F.leftOp.Additive","decl":"instance Functor.leftOp_additive (F : C ⥤ Dᵒᵖ) [F.Additive] : F.leftOp.Additive where\n\n"}
{"name":"CategoryTheory.Functor.unop_additive","module":"Mathlib.CategoryTheory.Preadditive.Opposite","initialProofState":"C : Type u_1\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Preadditive C\nD : Type u_2\ninst✝² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor (Opposite C) (Opposite D)\ninst✝ : F.Additive\n⊢ F.unop.Additive","decl":"instance Functor.unop_additive (F : Cᵒᵖ ⥤ Dᵒᵖ) [F.Additive] : F.unop.Additive where\n\n"}
