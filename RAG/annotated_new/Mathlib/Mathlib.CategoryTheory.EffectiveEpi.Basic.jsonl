{"name":"CategoryTheory.EffectiveEpiStruct.uniq","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\nself : CategoryTheory.EffectiveEpiStruct f\nW : C\ne : Quiver.Hom Y W\nh : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)\nm : Quiver.Hom X W\na✝ : Eq (CategoryTheory.CategoryStruct.comp f m) e\n⊢ Eq m (self.desc e ⋯)","decl":"/--\nThis structure encodes the data required for a morphism to be an effective epimorphism.\n-/\nstructure EffectiveEpiStruct {X Y : C} (f : Y ⟶ X) where\n  /--\n  For every `W` with a morphism `e : Y ⟶ W` that coequalizes every pair of morphisms\n  `g₁ g₂ : Z ⟶ Y` which `f` coequalizes, `desc e h` is a morphism `X ⟶ W`...\n  -/\n  desc : ∀ {W : C} (e : Y ⟶ W),\n    (∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) → (X ⟶ W)\n  /-- ...factorizing `e` through `f`... -/\n  fac : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e),\n    f ≫ desc e h = e\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e)\n    (m : X ⟶ W), f ≫ m = e → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiStruct.mk.inj","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\ndesc✝ : {W : C} → (e : Quiver.Hom Y W) → (∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) → Quiver.Hom X W\nfac✝ : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)), Eq (CategoryTheory.CategoryStruct.comp f (desc✝ e ⋯)) e\nuniq✝ : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) (m : Quiver.Hom X W), Eq (CategoryTheory.CategoryStruct.comp f m) e → Eq m (desc✝ e ⋯)\ndesc : {W : C} → (e : Quiver.Hom Y W) → (∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) → Quiver.Hom X W\nfac : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)), Eq (CategoryTheory.CategoryStruct.comp f (desc e ⋯)) e\nuniq : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) (m : Quiver.Hom X W), Eq (CategoryTheory.CategoryStruct.comp f m) e → Eq m (desc e ⋯)\nx✝ : Eq { desc := desc✝, fac := fac✝, uniq := uniq✝ } { desc := desc, fac := fac, uniq := uniq }\n⊢ Eq desc✝ desc","decl":"/--\nThis structure encodes the data required for a morphism to be an effective epimorphism.\n-/\nstructure EffectiveEpiStruct {X Y : C} (f : Y ⟶ X) where\n  /--\n  For every `W` with a morphism `e : Y ⟶ W` that coequalizes every pair of morphisms\n  `g₁ g₂ : Z ⟶ Y` which `f` coequalizes, `desc e h` is a morphism `X ⟶ W`...\n  -/\n  desc : ∀ {W : C} (e : Y ⟶ W),\n    (∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) → (X ⟶ W)\n  /-- ...factorizing `e` through `f`... -/\n  fac : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e),\n    f ≫ desc e h = e\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e)\n    (m : X ⟶ W), f ≫ m = e → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\ninst✝ : SizeOf C\ndesc : {W : C} → (e : Quiver.Hom Y W) → (∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) → Quiver.Hom X W\nfac : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)), Eq (CategoryTheory.CategoryStruct.comp f (desc e ⋯)) e\nuniq : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) (m : Quiver.Hom X W), Eq (CategoryTheory.CategoryStruct.comp f m) e → Eq m (desc e ⋯)\n⊢ Eq (SizeOf.sizeOf { desc := desc, fac := fac, uniq := uniq }) 1","decl":"/--\nThis structure encodes the data required for a morphism to be an effective epimorphism.\n-/\nstructure EffectiveEpiStruct {X Y : C} (f : Y ⟶ X) where\n  /--\n  For every `W` with a morphism `e : Y ⟶ W` that coequalizes every pair of morphisms\n  `g₁ g₂ : Z ⟶ Y` which `f` coequalizes, `desc e h` is a morphism `X ⟶ W`...\n  -/\n  desc : ∀ {W : C} (e : Y ⟶ W),\n    (∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) → (X ⟶ W)\n  /-- ...factorizing `e` through `f`... -/\n  fac : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e),\n    f ≫ desc e h = e\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e)\n    (m : X ⟶ W), f ≫ m = e → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiStruct.fac","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\nself : CategoryTheory.EffectiveEpiStruct f\nW : C\ne : Quiver.Hom Y W\nh : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (self.desc e ⋯)) e","decl":"/--\nThis structure encodes the data required for a morphism to be an effective epimorphism.\n-/\nstructure EffectiveEpiStruct {X Y : C} (f : Y ⟶ X) where\n  /--\n  For every `W` with a morphism `e : Y ⟶ W` that coequalizes every pair of morphisms\n  `g₁ g₂ : Z ⟶ Y` which `f` coequalizes, `desc e h` is a morphism `X ⟶ W`...\n  -/\n  desc : ∀ {W : C} (e : Y ⟶ W),\n    (∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) → (X ⟶ W)\n  /-- ...factorizing `e` through `f`... -/\n  fac : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e),\n    f ≫ desc e h = e\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e)\n    (m : X ⟶ W), f ≫ m = e → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiStruct.mk.injEq","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\ndesc✝ : {W : C} → (e : Quiver.Hom Y W) → (∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) → Quiver.Hom X W\nfac✝ : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)), Eq (CategoryTheory.CategoryStruct.comp f (desc✝ e ⋯)) e\nuniq✝ : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) (m : Quiver.Hom X W), Eq (CategoryTheory.CategoryStruct.comp f m) e → Eq m (desc✝ e ⋯)\ndesc : {W : C} → (e : Quiver.Hom Y W) → (∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) → Quiver.Hom X W\nfac : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)), Eq (CategoryTheory.CategoryStruct.comp f (desc e ⋯)) e\nuniq : ∀ {W : C} (e : Quiver.Hom Y W) (h : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)) (m : Quiver.Hom X W), Eq (CategoryTheory.CategoryStruct.comp f m) e → Eq m (desc e ⋯)\n⊢ Eq (Eq { desc := desc✝, fac := fac✝, uniq := uniq✝ } { desc := desc, fac := fac, uniq := uniq }) (Eq desc✝ desc)","decl":"/--\nThis structure encodes the data required for a morphism to be an effective epimorphism.\n-/\nstructure EffectiveEpiStruct {X Y : C} (f : Y ⟶ X) where\n  /--\n  For every `W` with a morphism `e : Y ⟶ W` that coequalizes every pair of morphisms\n  `g₁ g₂ : Z ⟶ Y` which `f` coequalizes, `desc e h` is a morphism `X ⟶ W`...\n  -/\n  desc : ∀ {W : C} (e : Y ⟶ W),\n    (∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) → (X ⟶ W)\n  /-- ...factorizing `e` through `f`... -/\n  fac : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e),\n    f ≫ desc e h = e\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W : C} (e : Y ⟶ W)\n    (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e)\n    (m : X ⟶ W), f ≫ m = e → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpi.effectiveEpi","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\nself : CategoryTheory.EffectiveEpi f\n⊢ Nonempty (CategoryTheory.EffectiveEpiStruct f)","decl":"/--\nA morphism `f : Y ⟶ X` is an effective epimorphism provided that `f` exhibits `X` as a colimit\nof the diagram of all \"relations\" `R ⇉ Y`.\nIf `f` has a kernel pair, then this is equivalent to showing that the corresponding cofork is\na colimit.\n-/\nclass EffectiveEpi {X Y : C} (f : Y ⟶ X) : Prop where\n  /-- `f` is an effective epimorphism if there exists an `EffectiveEpiStruct` for `f`. -/\n  effectiveEpi : Nonempty (EffectiveEpiStruct f)\n\n"}
{"name":"CategoryTheory.EffectiveEpi.fac_assoc","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y W : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.EffectiveEpi f\ne : Quiver.Hom Y W\nh✝ : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.EffectiveEpi.desc f e ⋯) h)) (CategoryTheory.CategoryStruct.comp e h)","decl":"@[reassoc (attr := simp)]\nlemma EffectiveEpi.fac {X Y W : C} (f : Y ⟶ X) [EffectiveEpi f]\n    (e : Y ⟶ W) (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) :\n    f ≫ EffectiveEpi.desc f e h = e :=\n  (EffectiveEpi.getStruct f).fac e h\n\n"}
{"name":"CategoryTheory.EffectiveEpi.fac","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y W : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.EffectiveEpi f\ne : Quiver.Hom Y W\nh : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.EffectiveEpi.desc f e ⋯)) e","decl":"@[reassoc (attr := simp)]\nlemma EffectiveEpi.fac {X Y W : C} (f : Y ⟶ X) [EffectiveEpi f]\n    (e : Y ⟶ W) (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e) :\n    f ≫ EffectiveEpi.desc f e h = e :=\n  (EffectiveEpi.getStruct f).fac e h\n\n"}
{"name":"CategoryTheory.EffectiveEpi.uniq","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y W : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.EffectiveEpi f\ne : Quiver.Hom Y W\nh : ∀ {Z : C} (g₁ g₂ : Quiver.Hom Z Y), Eq (CategoryTheory.CategoryStruct.comp g₁ f) (CategoryTheory.CategoryStruct.comp g₂ f) → Eq (CategoryTheory.CategoryStruct.comp g₁ e) (CategoryTheory.CategoryStruct.comp g₂ e)\nm : Quiver.Hom X W\nhm : Eq (CategoryTheory.CategoryStruct.comp f m) e\n⊢ Eq m (CategoryTheory.EffectiveEpi.desc f e ⋯)","decl":"lemma EffectiveEpi.uniq {X Y W : C} (f : Y ⟶ X) [EffectiveEpi f]\n    (e : Y ⟶ W) (h : ∀ {Z : C} (g₁ g₂ : Z ⟶ Y), g₁ ≫ f = g₂ ≫ f → g₁ ≫ e = g₂ ≫ e)\n    (m : X ⟶ W) (hm : f ≫ m = e) :\n    m = EffectiveEpi.desc f e h :=\n  (EffectiveEpi.getStruct f).uniq e h _ hm\n\n"}
{"name":"CategoryTheory.epiOfEffectiveEpi","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.EffectiveEpi f\n⊢ CategoryTheory.Epi f","decl":"instance epiOfEffectiveEpi {X Y : C} (f : Y ⟶ X) [EffectiveEpi f] : Epi f := by\n  constructor\n  intro W m₁ m₂ h\n  have : m₂ = EffectiveEpi.desc f (f ≫ m₂)\n    (fun {Z} g₁ g₂ h => by simp only [← Category.assoc, h]) := EffectiveEpi.uniq _ _ _ _ rfl\n  rw [this]\n  exact EffectiveEpi.uniq _ _ _ _ h\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamilyStruct.mk.inj","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ndesc✝ : {W : C} → (e : (a : α) → Quiver.Hom (X a) W) → (∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) → Quiver.Hom B W\nfac✝ : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) (desc✝ e ⋯)) (e a)\nuniq✝ : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (m : Quiver.Hom B W), (∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)) → Eq m (desc✝ e ⋯)\ndesc : {W : C} → (e : (a : α) → Quiver.Hom (X a) W) → (∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) → Quiver.Hom B W\nfac : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) (desc e ⋯)) (e a)\nuniq : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (m : Quiver.Hom B W), (∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)) → Eq m (desc e ⋯)\nx✝ : Eq { desc := desc✝, fac := fac✝, uniq := uniq✝ } { desc := desc, fac := fac, uniq := uniq }\n⊢ Eq desc✝ desc","decl":"/--\nThis structure encodes the data required for a family of morphisms to be effective epimorphic.\n-/\nstructure EffectiveEpiFamilyStruct {B : C} {α : Type*}\n    (X : α → C) (π : (a : α) → (X a ⟶ B)) where\n  /--\n  For every `W` with a family of morphisms `e a : Y a ⟶ W` that coequalizes every pair of morphisms\n  `g₁ : Z ⟶ Y a₁`, `g₂ : Z ⟶ Y a₂` which the family `π` coequalizes, `desc e h` is a morphism\n  `X ⟶ W`...\n  -/\n  desc : ∀ {W} (e : (a : α) → (X a ⟶ W)),\n          (∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) → (B ⟶ W)\n  /-- ...factorizing the components of `e` through the components of `π`... -/\n  fac : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (a : α), π a ≫ desc e h = e a\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (m : B ⟶ W), (∀ (a : α), π a ≫ m = e a) → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamilyStruct.mk.injEq","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ndesc✝ : {W : C} → (e : (a : α) → Quiver.Hom (X a) W) → (∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) → Quiver.Hom B W\nfac✝ : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) (desc✝ e ⋯)) (e a)\nuniq✝ : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (m : Quiver.Hom B W), (∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)) → Eq m (desc✝ e ⋯)\ndesc : {W : C} → (e : (a : α) → Quiver.Hom (X a) W) → (∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) → Quiver.Hom B W\nfac : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) (desc e ⋯)) (e a)\nuniq : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (m : Quiver.Hom B W), (∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)) → Eq m (desc e ⋯)\n⊢ Eq (Eq { desc := desc✝, fac := fac✝, uniq := uniq✝ } { desc := desc, fac := fac, uniq := uniq }) (Eq desc✝ desc)","decl":"/--\nThis structure encodes the data required for a family of morphisms to be effective epimorphic.\n-/\nstructure EffectiveEpiFamilyStruct {B : C} {α : Type*}\n    (X : α → C) (π : (a : α) → (X a ⟶ B)) where\n  /--\n  For every `W` with a family of morphisms `e a : Y a ⟶ W` that coequalizes every pair of morphisms\n  `g₁ : Z ⟶ Y a₁`, `g₂ : Z ⟶ Y a₂` which the family `π` coequalizes, `desc e h` is a morphism\n  `X ⟶ W`...\n  -/\n  desc : ∀ {W} (e : (a : α) → (X a ⟶ W)),\n          (∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) → (B ⟶ W)\n  /-- ...factorizing the components of `e` through the components of `π`... -/\n  fac : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (a : α), π a ≫ desc e h = e a\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (m : B ⟶ W), (∀ (a : α), π a ≫ m = e a) → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamilyStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝¹ : SizeOf C\ninst✝ : SizeOf α\ndesc : {W : C} → (e : (a : α) → Quiver.Hom (X a) W) → (∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) → Quiver.Hom B W\nfac : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) (desc e ⋯)) (e a)\nuniq : ∀ {W : C} (e : (a : α) → Quiver.Hom (X a) W) (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))) (m : Quiver.Hom B W), (∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)) → Eq m (desc e ⋯)\n⊢ Eq (SizeOf.sizeOf { desc := desc, fac := fac, uniq := uniq }) 1","decl":"/--\nThis structure encodes the data required for a family of morphisms to be effective epimorphic.\n-/\nstructure EffectiveEpiFamilyStruct {B : C} {α : Type*}\n    (X : α → C) (π : (a : α) → (X a ⟶ B)) where\n  /--\n  For every `W` with a family of morphisms `e a : Y a ⟶ W` that coequalizes every pair of morphisms\n  `g₁ : Z ⟶ Y a₁`, `g₂ : Z ⟶ Y a₂` which the family `π` coequalizes, `desc e h` is a morphism\n  `X ⟶ W`...\n  -/\n  desc : ∀ {W} (e : (a : α) → (X a ⟶ W)),\n          (∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) → (B ⟶ W)\n  /-- ...factorizing the components of `e` through the components of `π`... -/\n  fac : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (a : α), π a ≫ desc e h = e a\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (m : B ⟶ W), (∀ (a : α), π a ≫ m = e a) → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamilyStruct.fac","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\nself : CategoryTheory.EffectiveEpiFamilyStruct X π\nW : C\ne : (a : α) → Quiver.Hom (X a) W\nh : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))\na : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (π a) (self.desc e ⋯)) (e a)","decl":"/--\nThis structure encodes the data required for a family of morphisms to be effective epimorphic.\n-/\nstructure EffectiveEpiFamilyStruct {B : C} {α : Type*}\n    (X : α → C) (π : (a : α) → (X a ⟶ B)) where\n  /--\n  For every `W` with a family of morphisms `e a : Y a ⟶ W` that coequalizes every pair of morphisms\n  `g₁ : Z ⟶ Y a₁`, `g₂ : Z ⟶ Y a₂` which the family `π` coequalizes, `desc e h` is a morphism\n  `X ⟶ W`...\n  -/\n  desc : ∀ {W} (e : (a : α) → (X a ⟶ W)),\n          (∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) → (B ⟶ W)\n  /-- ...factorizing the components of `e` through the components of `π`... -/\n  fac : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (a : α), π a ≫ desc e h = e a\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (m : B ⟶ W), (∀ (a : α), π a ≫ m = e a) → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamilyStruct.uniq","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\nself : CategoryTheory.EffectiveEpiFamilyStruct X π\nW : C\ne : (a : α) → Quiver.Hom (X a) W\nh : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))\nm : Quiver.Hom B W\na✝ : ∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)\n⊢ Eq m (self.desc e ⋯)","decl":"/--\nThis structure encodes the data required for a family of morphisms to be effective epimorphic.\n-/\nstructure EffectiveEpiFamilyStruct {B : C} {α : Type*}\n    (X : α → C) (π : (a : α) → (X a ⟶ B)) where\n  /--\n  For every `W` with a family of morphisms `e a : Y a ⟶ W` that coequalizes every pair of morphisms\n  `g₁ : Z ⟶ Y a₁`, `g₂ : Z ⟶ Y a₂` which the family `π` coequalizes, `desc e h` is a morphism\n  `X ⟶ W`...\n  -/\n  desc : ∀ {W} (e : (a : α) → (X a ⟶ W)),\n          (∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) → (B ⟶ W)\n  /-- ...factorizing the components of `e` through the components of `π`... -/\n  fac : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (a : α), π a ≫ desc e h = e a\n  /-- ...and as such, unique. -/\n  uniq : ∀ {W} (e : (a : α) → (X a ⟶ W))\n          (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n            g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n          (m : B ⟶ W), (∀ (a : α), π a ≫ m = e a) → m = desc e h\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.effectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\nself : CategoryTheory.EffectiveEpiFamily X π\n⊢ Nonempty (CategoryTheory.EffectiveEpiFamilyStruct X π)","decl":"/--\nA family of morphisms `π a : X a ⟶ B` indexed by `α` is effective epimorphic\nprovided that the `π a` exhibit `B` as a colimit of the diagram of all \"relations\"\n`R → X a₁`, `R ⟶ X a₂` for all `a₁ a₂ : α`.\n-/\nclass EffectiveEpiFamily {B : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B)) : Prop where\n  /-- `π` is an effective epimorphic family if there exists an `EffectiveEpiFamilyStruct` for `π` -/\n  effectiveEpiFamily : Nonempty (EffectiveEpiFamilyStruct X π)\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.fac_assoc","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nB W : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\ne : (a : α) → Quiver.Hom (X a) W\nh✝ : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))\na : α\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (π a) (CategoryTheory.CategoryStruct.comp (CategoryTheory.EffectiveEpiFamily.desc X π e ⋯) h)) (CategoryTheory.CategoryStruct.comp (e a) h)","decl":"@[reassoc (attr := simp)]\nlemma EffectiveEpiFamily.fac {B W : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    [EffectiveEpiFamily X π] (e : (a : α) → (X a ⟶ W))\n    (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) (a : α) :\n    π a ≫ EffectiveEpiFamily.desc X π e h = e a :=\n  (EffectiveEpiFamily.getStruct X π).fac e h a\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.fac","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nB W : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\ne : (a : α) → Quiver.Hom (X a) W\nh : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))\na : α\n⊢ Eq (CategoryTheory.CategoryStruct.comp (π a) (CategoryTheory.EffectiveEpiFamily.desc X π e ⋯)) (e a)","decl":"@[reassoc (attr := simp)]\nlemma EffectiveEpiFamily.fac {B W : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    [EffectiveEpiFamily X π] (e : (a : α) → (X a ⟶ W))\n    (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _) (a : α) :\n    π a ≫ EffectiveEpiFamily.desc X π e h = e a :=\n  (EffectiveEpiFamily.getStruct X π).fac e h a\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.uniq","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nB W : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\ne : (a : α) → Quiver.Hom (X a) W\nh : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Quiver.Hom Z (X a₁)) (g₂ : Quiver.Hom Z (X a₂)), Eq (CategoryTheory.CategoryStruct.comp g₁ (π a₁)) (CategoryTheory.CategoryStruct.comp g₂ (π a₂)) → Eq (CategoryTheory.CategoryStruct.comp g₁ (e a₁)) (CategoryTheory.CategoryStruct.comp g₂ (e a₂))\nm : Quiver.Hom B W\nhm : ∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m) (e a)\n⊢ Eq m (CategoryTheory.EffectiveEpiFamily.desc X π e ⋯)","decl":"lemma EffectiveEpiFamily.uniq {B W : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    [EffectiveEpiFamily X π] (e : (a : α) → (X a ⟶ W))\n    (h : ∀ {Z : C} (a₁ a₂ : α) (g₁ : Z ⟶ X a₁) (g₂ : Z ⟶ X a₂),\n      g₁ ≫ π _ = g₂ ≫ π _ → g₁ ≫ e _ = g₂ ≫ e _)\n    (m : B ⟶ W) (hm : ∀ a, π a ≫ m = e a) :\n    m = EffectiveEpiFamily.desc X π e h :=\n  (EffectiveEpiFamily.getStruct X π).uniq e h m hm\n\n-- TODO: Once we have \"jointly epimorphic families\", we could rephrase this as such a property.\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.hom_ext","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nB W : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : CategoryTheory.EffectiveEpiFamily X π\nm₁ m₂ : Quiver.Hom B W\nh : ∀ (a : α), Eq (CategoryTheory.CategoryStruct.comp (π a) m₁) (CategoryTheory.CategoryStruct.comp (π a) m₂)\n⊢ Eq m₁ m₂","decl":"lemma EffectiveEpiFamily.hom_ext {B W : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B))\n    [EffectiveEpiFamily X π] (m₁ m₂ : B ⟶ W) (h : ∀ a, π a ≫ m₁ = π a ≫ m₂) :\n    m₁ = m₂ := by\n  have : m₂ = EffectiveEpiFamily.desc X π (fun a => π a ≫ m₂)\n      (fun a₁ a₂ g₁ g₂ h => by simp only [← Category.assoc, h]) := by\n    apply EffectiveEpiFamily.uniq; intro; rfl\n  rw [this]\n  exact EffectiveEpiFamily.uniq _ _ _ _ _ h\n\n"}
{"name":"CategoryTheory.instEffectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nB X : C\nf : Quiver.Hom X B\ninst✝ : CategoryTheory.EffectiveEpi f\n⊢ CategoryTheory.EffectiveEpiFamily (fun x => X) fun x => CategoryTheory.effectiveEpiFamilyStructSingletonOfEffectiveEpi.match_1 (fun x => Quiver.Hom ((fun x => X) x) B) x fun _ => f","decl":"instance {B X : C} (f : X ⟶ B) [EffectiveEpi f] : EffectiveEpiFamily (fun () ↦ X) (fun () ↦ f) :=\n  ⟨⟨effectiveEpiFamilyStructSingletonOfEffectiveEpi f⟩⟩\n\n"}
{"name":"CategoryTheory.instEffectiveEpiOfEffectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nB X : C\nf : Quiver.Hom X B\ninst✝ : CategoryTheory.EffectiveEpiFamily (fun x => X) fun x => CategoryTheory.effectiveEpiFamilyStructSingletonOfEffectiveEpi.match_1 (fun x => Quiver.Hom ((fun x => X) x) B) x fun _ => f\n⊢ CategoryTheory.EffectiveEpi f","decl":"instance {B X : C} (f : X ⟶ B) [EffectiveEpiFamily (fun () ↦ X) (fun () ↦ f)] :\n    EffectiveEpi f :=\n  ⟨⟨effectiveEpiStructOfEffectiveEpiFamilySingleton f⟩⟩\n\n"}
{"name":"CategoryTheory.effectiveEpi_iff_effectiveEpiFamily","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nB X : C\nf : Quiver.Hom X B\n⊢ Iff (CategoryTheory.EffectiveEpi f) (CategoryTheory.EffectiveEpiFamily (fun x => X) fun x => CategoryTheory.effectiveEpiFamilyStructSingletonOfEffectiveEpi.match_1 (fun x => Quiver.Hom ((fun x => X) x) B) x fun _ => f)","decl":"theorem effectiveEpi_iff_effectiveEpiFamily {B X : C} (f : X ⟶ B) :\n    EffectiveEpi f ↔ EffectiveEpiFamily (fun () ↦ X) (fun () ↦ f) :=\n  ⟨fun _ ↦ inferInstance, fun _ ↦ inferInstance⟩\n\n"}
{"name":"CategoryTheory.instEffectiveEpiFamilyOfIsIsoDesc","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nB : C\nα : Type u_2\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝¹ : CategoryTheory.Limits.HasCoproduct X\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.Sigma.desc π)\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"instance {B : C} {α : Type*} (X : α → C) (π : (a : α) → (X a ⟶ B)) [HasCoproduct X]\n    [IsIso (Sigma.desc π)] : EffectiveEpiFamily X π :=\n  ⟨⟨effectiveEpiFamilyStructOfIsIsoDesc X π⟩⟩\n\n"}
{"name":"CategoryTheory.instEffectiveEpiOfIsIso","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\n⊢ CategoryTheory.EffectiveEpi f","decl":"instance {X Y : C} (f : X ⟶ Y) [IsIso f] : EffectiveEpi f := ⟨⟨effectiveEpiStructOfIsIso f⟩⟩\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.reindex","module":"Mathlib.CategoryTheory.EffectiveEpi.Basic","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_4, u_1} C\nB : C\nα : Type u_2\nα' : Type u_3\nX : α → C\nπ : (a : α) → Quiver.Hom (X a) B\ne : Equiv α' α\nh : CategoryTheory.EffectiveEpiFamily (fun a => X (e a)) fun a => π (e a)\n⊢ CategoryTheory.EffectiveEpiFamily X π","decl":"/--\nReindex the indexing type of an effective epi family.\n-/\nlemma EffectiveEpiFamily.reindex\n    {B : C} {α α' : Type*}\n    (X : α → C)\n    (π : (a : α) → (X a ⟶ B))\n    (e : α' ≃ α)\n    (h : EffectiveEpiFamily (fun a => X (e a)) (fun a => π (e a))) :\n    EffectiveEpiFamily X π :=\n  .mk <| .intro <| @EffectiveEpiFamily.getStruct _ _ _ _ _ _ h |>.reindex _ _ e\n\n"}
