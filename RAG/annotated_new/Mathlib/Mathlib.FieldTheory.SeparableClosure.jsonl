{"name":"mem_separableClosure_iff","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nx : E\n⊢ Iff (Membership.mem (separableClosure F E) x) (IsSeparable F x)","decl":"/-- An element is contained in the separable closure of `F` in `E` if and only if\nit is a separable element. -/\ntheorem mem_separableClosure_iff {x : E} :\n    x ∈ separableClosure F E ↔ IsSeparable F x := Iff.rfl\n\n"}
{"name":"map_mem_separableClosure_iff","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\nx : E\n⊢ Iff (Membership.mem (separableClosure F K) (i x)) (Membership.mem (separableClosure F E) x)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then `i x` is contained in\n`separableClosure F K` if and only if `x` is contained in `separableClosure F E`. -/\ntheorem map_mem_separableClosure_iff (i : E →ₐ[F] K) {x : E} :\n    i x ∈ separableClosure F K ↔ x ∈ separableClosure F E := by\n  simp_rw [mem_separableClosure_iff, IsSeparable, minpoly.algHom_eq i i.injective]\n\n"}
{"name":"separableClosure.comap_eq_of_algHom","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\n⊢ Eq (IntermediateField.comap i (separableClosure F K)) (separableClosure F E)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then the preimage of\n`separableClosure F K` under the map `i` is equal to `separableClosure F E`. -/\ntheorem separableClosure.comap_eq_of_algHom (i : E →ₐ[F] K) :\n    (separableClosure F K).comap i = separableClosure F E := by\n  ext x\n  exact map_mem_separableClosure_iff i\n\n"}
{"name":"separableClosure.map_le_of_algHom","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgHom F E K\n⊢ LE.le (IntermediateField.map i (separableClosure F E)) (separableClosure F K)","decl":"/-- If `i` is an `F`-algebra homomorphism from `E` to `K`, then the image of `separableClosure F E`\nunder the map `i` is contained in `separableClosure F K`. -/\ntheorem separableClosure.map_le_of_algHom (i : E →ₐ[F] K) :\n    (separableClosure F E).map i ≤ separableClosure F K :=\n  map_le_iff_le_comap.2 (comap_eq_of_algHom i).ge\n\n"}
{"name":"separableClosure.map_eq_of_separableClosure_eq_bot","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\nh : Eq (separableClosure E K) Bot.bot\n⊢ Eq (IntermediateField.map (IsScalarTower.toAlgHom F E K) (separableClosure F E)) (separableClosure F K)","decl":"variable (F) in\n/-- If `K / E / F` is a field extension tower, such that `K / E` has no non-trivial separable\nsubextensions (when `K / E` is algebraic, this means that it is purely inseparable),\nthen the image of `separableClosure F E` in `K` is equal to `separableClosure F K`. -/\ntheorem separableClosure.map_eq_of_separableClosure_eq_bot [Algebra E K] [IsScalarTower F E K]\n    (h : separableClosure E K = ⊥) :\n    (separableClosure F E).map (IsScalarTower.toAlgHom F E K) = separableClosure F K := by\n  refine le_antisymm (map_le_of_algHom _) (fun x hx ↦ ?_)\n  obtain ⟨y, rfl⟩ := mem_bot.1 <| h ▸ mem_separableClosure_iff.2\n    (IsSeparable.tower_top E <| mem_separableClosure_iff.1 hx)\n  exact ⟨y, (map_mem_separableClosure_iff <| IsScalarTower.toAlgHom F E K).mp hx, rfl⟩\n\n"}
{"name":"separableClosure.map_eq_of_algEquiv","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (IntermediateField.map (↑i) (separableClosure F E)) (separableClosure F K)","decl":"/-- If `i` is an `F`-algebra isomorphism of `E` and `K`, then the image of `separableClosure F E`\nunder the map `i` is equal to `separableClosure F K`. -/\ntheorem separableClosure.map_eq_of_algEquiv (i : E ≃ₐ[F] K) :\n    (separableClosure F E).map i = separableClosure F K :=\n  (map_le_of_algHom i.toAlgHom).antisymm\n    (fun x h ↦ ⟨_, (map_mem_separableClosure_iff i.symm).2 h, by simp⟩)\n\n"}
{"name":"separableClosure.isAlgebraic","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Algebra.IsAlgebraic F (Subtype fun x => Membership.mem (separableClosure F E) x)","decl":"/-- The separable closure of `F` in `E` is algebraic over `F`. -/\ninstance separableClosure.isAlgebraic : Algebra.IsAlgebraic F (separableClosure F E) :=\n  ⟨fun x ↦ isAlgebraic_iff.2 (IsSeparable.isIntegral x.2).isAlgebraic⟩\n\n"}
{"name":"separableClosure.isSeparable","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Algebra.IsSeparable F (Subtype fun x => Membership.mem (separableClosure F E) x)","decl":"/-- The separable closure of `F` in `E` is separable over `F`. -/\n@[stacks 030K \"$E_{sep}/F$ is separable\"]\ninstance separableClosure.isSeparable : Algebra.IsSeparable F (separableClosure F E) :=\n  ⟨fun x ↦ by simpa only [IsSeparable, minpoly_eq] using x.2⟩\n\n"}
{"name":"le_separableClosure'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\nhs : ∀ (x : Subtype fun x => Membership.mem L x), IsSeparable F x\n⊢ LE.le L (separableClosure F E)","decl":"/-- An intermediate field of `E / F` is contained in the separable closure of `F` in `E`\nif all of its elements are separable over `F`. -/\ntheorem le_separableClosure' {L : IntermediateField F E} (hs : ∀ x : L, IsSeparable F x) :\n    L ≤ separableClosure F E := fun x h ↦ by simpa only [IsSeparable, minpoly_eq] using hs ⟨x, h⟩\n\n"}
{"name":"le_separableClosure","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\nL : IntermediateField F E\ninst✝ : Algebra.IsSeparable F (Subtype fun x => Membership.mem L x)\n⊢ LE.le L (separableClosure F E)","decl":"/-- An intermediate field of `E / F` is contained in the separable closure of `F` in `E`\nif it is separable over `F`. -/\ntheorem le_separableClosure (L : IntermediateField F E) [Algebra.IsSeparable F L] :\n    L ≤ separableClosure F E := le_separableClosure' F E (Algebra.IsSeparable.isSeparable F)\n\n"}
{"name":"le_separableClosure_iff","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL : IntermediateField F E\n⊢ Iff (LE.le L (separableClosure F E)) (Algebra.IsSeparable F (Subtype fun x => Membership.mem L x))","decl":"/-- An intermediate field of `E / F` is contained in the separable closure of `F` in `E`\nif and only if it is separable over `F`. -/\ntheorem le_separableClosure_iff (L : IntermediateField F E) :\n    L ≤ separableClosure F E ↔ Algebra.IsSeparable F L :=\n  ⟨fun h ↦ ⟨fun x ↦ by simpa only [IsSeparable, minpoly_eq] using h x.2⟩,\n    fun _ ↦ le_separableClosure _ _ _⟩\n\n"}
{"name":"separableClosure.separableClosure_eq_bot","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (separableClosure (Subtype fun x => Membership.mem (separableClosure F E) x) E) Bot.bot","decl":"/-- The separable closure in `E` of the separable closure of `F` in `E` is equal to itself. -/\ntheorem separableClosure.separableClosure_eq_bot :\n    separableClosure (separableClosure F E) E = ⊥ :=\n  bot_unique fun x hx ↦ mem_bot.2\n    ⟨⟨x, IsSeparable.of_algebra_isSeparable_of_isSeparable F (mem_separableClosure_iff.1 hx)⟩, rfl⟩\n\n"}
{"name":"separableClosure.normalClosure_eq_self","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (normalClosure F (Subtype fun x => Membership.mem (separableClosure F E) x) E) (separableClosure F E)","decl":"/-- The normal closure in `E/F` of the separable closure of `F` in `E` is equal to itself. -/\ntheorem separableClosure.normalClosure_eq_self :\n    normalClosure F (separableClosure F E) E = separableClosure F E :=\n  le_antisymm (normalClosure_le_iff.2 fun i ↦\n    have : Algebra.IsSeparable F i.fieldRange :=\n      (AlgEquiv.Algebra.isSeparable (AlgEquiv.ofInjectiveField i))\n    le_separableClosure F E _) (le_normalClosure _)\n\n"}
{"name":"separableClosure.isGalois","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Normal F E\n⊢ IsGalois F (Subtype fun x => Membership.mem (separableClosure F E) x)","decl":"/-- If `E` is normal over `F`, then the separable closure of `F` in `E` is Galois (i.e.\nnormal and separable) over `F`. -/\n@[stacks 0EXK]\ninstance separableClosure.isGalois [Normal F E] : IsGalois F (separableClosure F E) where\n  to_isSeparable := separableClosure.isSeparable F E\n  to_normal := by\n    rw [← separableClosure.normalClosure_eq_self]\n    exact normalClosure.normal F _ E\n\n"}
{"name":"IsSepClosed.separableClosure_eq_bot_iff","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsSepClosed E\n⊢ Iff (Eq (separableClosure F E) Bot.bot) (IsSepClosed F)","decl":"/-- If `E / F` is a field extension and `E` is separably closed, then the separable closure\nof `F` in `E` is equal to `F` if and only if `F` is separably closed. -/\ntheorem IsSepClosed.separableClosure_eq_bot_iff [IsSepClosed E] :\n    separableClosure F E = ⊥ ↔ IsSepClosed F := by\n  refine ⟨fun h ↦ IsSepClosed.of_exists_root _ fun p _ hirr hsep ↦ ?_,\n    fun _ ↦ IntermediateField.eq_bot_of_isSepClosed_of_isSeparable _⟩\n  obtain ⟨x, hx⟩ := IsSepClosed.exists_aeval_eq_zero E p (degree_pos_of_irreducible hirr).ne' hsep\n  obtain ⟨x, rfl⟩ := h ▸ mem_separableClosure_iff.2 (hsep.of_dvd <| minpoly.dvd _ x hx)\n  exact ⟨x, by simpa [Algebra.ofId_apply] using hx⟩\n\n"}
{"name":"separableClosure.isSepClosure","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : IsSepClosed E\n⊢ IsSepClosure F (Subtype fun x => Membership.mem (separableClosure F E) x)","decl":"/-- If `E` is separably closed, then the separable closure of `F` in `E` is an absolute\nseparable closure of `F`. -/\ninstance separableClosure.isSepClosure [IsSepClosed E] : IsSepClosure F (separableClosure F E) :=\n  ⟨(IsSepClosed.separableClosure_eq_bot_iff _ E).mp (separableClosure.separableClosure_eq_bot F E),\n    isSeparable F E⟩\n\n"}
{"name":"IntermediateField.isSeparable_adjoin_iff_isSeparable","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nS : Set E\n⊢ Iff (Algebra.IsSeparable F (Subtype fun x => Membership.mem (IntermediateField.adjoin F S) x)) (∀ (x : E), Membership.mem S x → IsSeparable F x)","decl":"/-- `F(S) / F` is a separable extension if and only if all elements of `S` are\nseparable elements. -/\ntheorem IntermediateField.isSeparable_adjoin_iff_isSeparable {S : Set E} :\n    Algebra.IsSeparable F (adjoin F S) ↔ ∀ x ∈ S, IsSeparable F x :=\n  (le_separableClosure_iff F E _).symm.trans adjoin_le_iff\n\n"}
{"name":"separableClosure.eq_top_iff","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Iff (Eq (separableClosure F E) Top.top) (Algebra.IsSeparable F E)","decl":"/-- The separable closure of `F` in `E` is equal to `E` if and only if `E / F` is\nseparable. -/\ntheorem separableClosure.eq_top_iff : separableClosure F E = ⊤ ↔ Algebra.IsSeparable F E :=\n  ⟨fun h ↦ ⟨fun _ ↦ mem_separableClosure_iff.1 (h ▸ mem_top)⟩,\n    fun _ ↦ top_unique fun x _ ↦ mem_separableClosure_iff.2 (Algebra.IsSeparable.isSeparable _ x)⟩\n\n"}
{"name":"separableClosure.le_restrictScalars","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ LE.le (separableClosure F K) (IntermediateField.restrictScalars F (separableClosure E K))","decl":"/-- If `K / E / F` is a field extension tower, then `separableClosure F K` is contained in\n`separableClosure E K`. -/\ntheorem separableClosure.le_restrictScalars [Algebra E K] [IsScalarTower F E K] :\n    separableClosure F K ≤ (separableClosure E K).restrictScalars F :=\n  fun _ ↦ IsSeparable.tower_top E\n\n"}
{"name":"separableClosure.eq_restrictScalars_of_isSeparable","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁷ : Field F\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\nK : Type w\ninst✝⁴ : Field K\ninst✝³ : Algebra F K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (separableClosure F K) (IntermediateField.restrictScalars F (separableClosure E K))","decl":"/-- If `K / E / F` is a field extension tower, such that `E / F` is separable, then\n`separableClosure F K` is equal to `separableClosure E K`. -/\ntheorem separableClosure.eq_restrictScalars_of_isSeparable [Algebra E K] [IsScalarTower F E K]\n    [Algebra.IsSeparable F E] : separableClosure F K = (separableClosure E K).restrictScalars F :=\n  (separableClosure.le_restrictScalars F E K).antisymm fun _ h ↦\n    IsSeparable.of_algebra_isSeparable_of_isSeparable F h\n\n"}
{"name":"separableClosure.adjoin_le","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ LE.le (IntermediateField.adjoin E ↑(separableClosure F K)) (separableClosure E K)","decl":"/-- If `K / E / F` is a field extension tower, then `E` adjoin `separableClosure F K` is contained\nin `separableClosure E K`. -/\ntheorem separableClosure.adjoin_le [Algebra E K] [IsScalarTower F E K] :\n    adjoin E (separableClosure F K) ≤ separableClosure E K :=\n  adjoin_le_iff.2 <| le_restrictScalars F E K\n\n"}
{"name":"IntermediateField.isSeparable_sup","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nL1 L2 : IntermediateField F E\nh1 : Algebra.IsSeparable F (Subtype fun x => Membership.mem L1 x)\nh2 : Algebra.IsSeparable F (Subtype fun x => Membership.mem L2 x)\n⊢ Algebra.IsSeparable F (Subtype fun x => Membership.mem (Max.max L1 L2) x)","decl":"/-- A compositum of two separable extensions is separable. -/\ninstance IntermediateField.isSeparable_sup (L1 L2 : IntermediateField F E)\n    [h1 : Algebra.IsSeparable F L1] [h2 : Algebra.IsSeparable F L2] :\n    Algebra.IsSeparable F (L1 ⊔ L2 : IntermediateField F E) := by\n  rw [← le_separableClosure_iff] at h1 h2 ⊢\n  exact sup_le h1 h2\n\n"}
{"name":"IntermediateField.isSeparable_iSup","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nι : Type u_1\nt : ι → IntermediateField F E\nh : ∀ (i : ι), Algebra.IsSeparable F (Subtype fun x => Membership.mem (t i) x)\n⊢ Algebra.IsSeparable F (Subtype fun x => Membership.mem (iSup fun i => t i) x)","decl":"/-- A compositum of separable extensions is separable. -/\ninstance IntermediateField.isSeparable_iSup {ι : Type*} {t : ι → IntermediateField F E}\n    [h : ∀ i, Algebra.IsSeparable F (t i)] :\n    Algebra.IsSeparable F (⨆ i, t i : IntermediateField F E) := by\n  simp_rw [← le_separableClosure_iff] at h ⊢\n  exact iSup_le h\n\n"}
{"name":"Field.finInsepDegree_def'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Field.finInsepDegree F E) (Cardinal.toNat (Field.insepDegree F E))","decl":"theorem finInsepDegree_def' : finInsepDegree F E = Cardinal.toNat (insepDegree F E) := rfl\n\n"}
{"name":"Field.instNeZeroSepDegree","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ NeZero (Field.sepDegree F E)","decl":"instance instNeZeroSepDegree : NeZero (sepDegree F E) := ⟨rank_pos.ne'⟩\n\n"}
{"name":"Field.instNeZeroInsepDegree","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ NeZero (Field.insepDegree F E)","decl":"instance instNeZeroInsepDegree : NeZero (insepDegree F E) := ⟨rank_pos.ne'⟩\n\n"}
{"name":"Field.instNeZeroFinInsepDegree","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : FiniteDimensional F E\n⊢ NeZero (Field.finInsepDegree F E)","decl":"instance instNeZeroFinInsepDegree [FiniteDimensional F E] :\n    NeZero (finInsepDegree F E) := ⟨finrank_pos.ne'⟩\n\n"}
{"name":"Field.lift_sepDegree_eq_of_equiv","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (Cardinal.lift.{w, v} (Field.sepDegree F E)) (Cardinal.lift.{v, w} (Field.sepDegree F K))","decl":"/-- If `E` and `K` are isomorphic as `F`-algebras, then they have the same\nseparable degree over `F`. -/\ntheorem lift_sepDegree_eq_of_equiv (i : E ≃ₐ[F] K) :\n    Cardinal.lift.{w} (sepDegree F E) = Cardinal.lift.{v} (sepDegree F K) :=\n  i.separableClosure.toLinearEquiv.lift_rank_eq\n\n"}
{"name":"Field.sepDegree_eq_of_equiv","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (Field.sepDegree F E) (Field.sepDegree F K)","decl":"/-- The same-universe version of `Field.lift_sepDegree_eq_of_equiv`. -/\ntheorem sepDegree_eq_of_equiv (K : Type v) [Field K] [Algebra F K] (i : E ≃ₐ[F] K) :\n    sepDegree F E = sepDegree F K :=\n  i.separableClosure.toLinearEquiv.rank_eq\n\n"}
{"name":"Field.sepDegree_mul_insepDegree","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (HMul.hMul (Field.sepDegree F E) (Field.insepDegree F E)) (Module.rank F E)","decl":"/-- The separable degree multiplied by the inseparable degree is equal\nto the (infinite) field extension degree. -/\ntheorem sepDegree_mul_insepDegree : sepDegree F E * insepDegree F E = Module.rank F E :=\n  rank_mul_rank F (separableClosure F E) E\n\n"}
{"name":"Field.lift_insepDegree_eq_of_equiv","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (Cardinal.lift.{w, v} (Field.insepDegree F E)) (Cardinal.lift.{v, w} (Field.insepDegree F K))","decl":"/-- If `E` and `K` are isomorphic as `F`-algebras, then they have the same\ninseparable degree over `F`. -/\ntheorem lift_insepDegree_eq_of_equiv (i : E ≃ₐ[F] K) :\n    Cardinal.lift.{w} (insepDegree F E) = Cardinal.lift.{v} (insepDegree F K) :=\n  Algebra.lift_rank_eq_of_equiv_equiv i.separableClosure i rfl\n\n"}
{"name":"Field.insepDegree_eq_of_equiv","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type v\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (Field.insepDegree F E) (Field.insepDegree F K)","decl":"/-- The same-universe version of `Field.lift_insepDegree_eq_of_equiv`. -/\ntheorem insepDegree_eq_of_equiv (K : Type v) [Field K] [Algebra F K] (i : E ≃ₐ[F] K) :\n    insepDegree F E = insepDegree F K :=\n  Algebra.rank_eq_of_equiv_equiv i.separableClosure i rfl\n\n"}
{"name":"Field.finInsepDegree_eq_of_equiv","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nK : Type w\ninst✝¹ : Field K\ninst✝ : Algebra F K\ni : AlgEquiv F E K\n⊢ Eq (Field.finInsepDegree F E) (Field.finInsepDegree F K)","decl":"/-- If `E` and `K` are isomorphic as `F`-algebras, then they have the same finite\ninseparable degree over `F`. -/\ntheorem finInsepDegree_eq_of_equiv (i : E ≃ₐ[F] K) :\n    finInsepDegree F E = finInsepDegree F K := by\n  simpa only [Cardinal.toNat_lift] using congr_arg Cardinal.toNat\n    (lift_insepDegree_eq_of_equiv F E K i)\n\n"}
{"name":"Field.sepDegree_self","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (Field.sepDegree F F) 1","decl":"@[simp]\ntheorem sepDegree_self : sepDegree F F = 1 := by\n  rw [sepDegree, Subsingleton.elim (separableClosure F F) ⊥, IntermediateField.rank_bot]\n\n"}
{"name":"Field.insepDegree_self","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (Field.insepDegree F F) 1","decl":"@[simp]\ntheorem insepDegree_self : insepDegree F F = 1 := by\n  rw [insepDegree, Subsingleton.elim (separableClosure F F) ⊤, IntermediateField.rank_top]\n\n"}
{"name":"Field.finInsepDegree_self","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\ninst✝ : Field F\n⊢ Eq (Field.finInsepDegree F F) 1","decl":"@[simp]\ntheorem finInsepDegree_self : finInsepDegree F F = 1 := by\n  rw [finInsepDegree_def', insepDegree_self, Cardinal.one_toNat]\n\n"}
{"name":"IntermediateField.sepDegree_bot","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Field.sepDegree F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\ntheorem sepDegree_bot : sepDegree F (⊥ : IntermediateField F E) = 1 := by\n  have := lift_sepDegree_eq_of_equiv _ _ _ (botEquiv F E)\n  rwa [sepDegree_self, Cardinal.lift_one, ← Cardinal.lift_one.{v, u}, Cardinal.lift_inj] at this\n\n"}
{"name":"IntermediateField.insepDegree_bot","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Field.insepDegree F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\ntheorem insepDegree_bot : insepDegree F (⊥ : IntermediateField F E) = 1 := by\n  have := lift_insepDegree_eq_of_equiv _ _ _ (botEquiv F E)\n  rwa [insepDegree_self, Cardinal.lift_one, ← Cardinal.lift_one.{v, u}, Cardinal.lift_inj] at this\n\n"}
{"name":"IntermediateField.finInsepDegree_bot","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\n⊢ Eq (Field.finInsepDegree F (Subtype fun x => Membership.mem Bot.bot x)) 1","decl":"@[simp]\ntheorem finInsepDegree_bot : finInsepDegree F (⊥ : IntermediateField F E) = 1 := by\n  rw [finInsepDegree_eq_of_equiv _ _ _ (botEquiv F E), finInsepDegree_self]\n\n"}
{"name":"IntermediateField.lift_sepDegree_bot'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Cardinal.lift.{v, w} (Field.sepDegree F (Subtype fun x => Membership.mem Bot.bot x))) (Cardinal.lift.{w, v} (Field.sepDegree F E))","decl":"theorem lift_sepDegree_bot' : Cardinal.lift.{v} (sepDegree F (⊥ : IntermediateField E K)) =\n    Cardinal.lift.{w} (sepDegree F E) :=\n  lift_sepDegree_eq_of_equiv _ _ _ ((botEquiv E K).restrictScalars F)\n\n"}
{"name":"IntermediateField.lift_insepDegree_bot'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Cardinal.lift.{v, w} (Field.insepDegree F (Subtype fun x => Membership.mem Bot.bot x))) (Cardinal.lift.{w, v} (Field.insepDegree F E))","decl":"theorem lift_insepDegree_bot' : Cardinal.lift.{v} (insepDegree F (⊥ : IntermediateField E K)) =\n    Cardinal.lift.{w} (insepDegree F E) :=\n  lift_insepDegree_eq_of_equiv _ _ _ ((botEquiv E K).restrictScalars F)\n\n"}
{"name":"IntermediateField.finInsepDegree_bot'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.finInsepDegree F (Subtype fun x => Membership.mem Bot.bot x)) (Field.finInsepDegree F E)","decl":"@[simp]\ntheorem finInsepDegree_bot' :\n    finInsepDegree F (⊥ : IntermediateField E K) = finInsepDegree F E := by\n  simpa only [Cardinal.toNat_lift] using congr_arg Cardinal.toNat (lift_insepDegree_bot' F E K)\n\n"}
{"name":"IntermediateField.sepDegree_top","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.sepDegree F (Subtype fun x => Membership.mem Top.top x)) (Field.sepDegree F K)","decl":"@[simp]\ntheorem sepDegree_top : sepDegree F (⊤ : IntermediateField E K) = sepDegree F K :=\n  sepDegree_eq_of_equiv _ _ _ ((topEquiv (F := E) (E := K)).restrictScalars F)\n\n"}
{"name":"IntermediateField.insepDegree_top","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.insepDegree F (Subtype fun x => Membership.mem Top.top x)) (Field.insepDegree F K)","decl":"@[simp]\ntheorem insepDegree_top : insepDegree F (⊤ : IntermediateField E K) = insepDegree F K :=\n  insepDegree_eq_of_equiv _ _ _ ((topEquiv (F := E) (E := K)).restrictScalars F)\n\n"}
{"name":"IntermediateField.finInsepDegree_top","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type w\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.finInsepDegree F (Subtype fun x => Membership.mem Top.top x)) (Field.finInsepDegree F K)","decl":"@[simp]\ntheorem finInsepDegree_top : finInsepDegree F (⊤ : IntermediateField E K) = finInsepDegree F K := by\n  rw [finInsepDegree_def', insepDegree_top, ← finInsepDegree_def']\n\n"}
{"name":"IntermediateField.sepDegree_bot'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type v\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.sepDegree F (Subtype fun x => Membership.mem Bot.bot x)) (Field.sepDegree F E)","decl":"@[simp]\ntheorem sepDegree_bot' : sepDegree F (⊥ : IntermediateField E K) = sepDegree F E :=\n  sepDegree_eq_of_equiv _ _ _ ((botEquiv E K).restrictScalars F)\n\n"}
{"name":"IntermediateField.insepDegree_bot'","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nK : Type v\ninst✝³ : Field K\ninst✝² : Algebra F K\ninst✝¹ : Algebra E K\ninst✝ : IsScalarTower F E K\n⊢ Eq (Field.insepDegree F (Subtype fun x => Membership.mem Bot.bot x)) (Field.insepDegree F E)","decl":"@[simp]\ntheorem insepDegree_bot' : insepDegree F (⊥ : IntermediateField E K) = insepDegree F E :=\n  insepDegree_eq_of_equiv _ _ _ ((botEquiv E K).restrictScalars F)\n\n"}
{"name":"Algebra.IsSeparable.sepDegree_eq","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (Field.sepDegree F E) (Module.rank F E)","decl":"/-- A separable extension has separable degree equal to degree. -/\ntheorem Algebra.IsSeparable.sepDegree_eq [Algebra.IsSeparable F E] :\n    sepDegree F E = Module.rank F E := by\n  rw [sepDegree, (separableClosure.eq_top_iff F E).2 ‹_›, IntermediateField.rank_top']\n\n"}
{"name":"Algebra.IsSeparable.insepDegree_eq","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (Field.insepDegree F E) 1","decl":"/-- A separable extension has inseparable degree one. -/\ntheorem Algebra.IsSeparable.insepDegree_eq [Algebra.IsSeparable F E] : insepDegree F E = 1 := by\n  rw [insepDegree, (separableClosure.eq_top_iff F E).2 ‹_›, IntermediateField.rank_top]\n\n"}
{"name":"Algebra.IsSeparable.finInsepDegree_eq","module":"Mathlib.FieldTheory.SeparableClosure","initialProofState":"F : Type u\nE : Type v\ninst✝³ : Field F\ninst✝² : Field E\ninst✝¹ : Algebra F E\ninst✝ : Algebra.IsSeparable F E\n⊢ Eq (Field.finInsepDegree F E) 1","decl":"/-- A separable extension has finite inseparable degree one. -/\ntheorem Algebra.IsSeparable.finInsepDegree_eq [Algebra.IsSeparable F E] : finInsepDegree F E = 1 :=\n  Cardinal.one_toNat ▸ congr(Cardinal.toNat $(insepDegree_eq F E))\n"}
