{"name":"Matrix.inv_pow'","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Nat\n⊢ Eq (HPow.hPow (Inv.inv A) n) (Inv.inv (HPow.hPow A n))","decl":"@[simp]\ntheorem inv_pow' (A : M) (n : ℕ) : A⁻¹ ^ n = (A ^ n)⁻¹ := by\n  induction' n with n ih\n  · simp\n  · rw [pow_succ A, mul_inv_rev, ← ih, ← pow_succ']\n\n"}
{"name":"Matrix.pow_sub'","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nm n : Nat\nha : IsUnit A.det\nh : LE.le n m\n⊢ Eq (HPow.hPow A (HSub.hSub m n)) (HMul.hMul (HPow.hPow A m) (Inv.inv (HPow.hPow A n)))","decl":"theorem pow_sub' (A : M) {m n : ℕ} (ha : IsUnit A.det) (h : n ≤ m) :\n    A ^ (m - n) = A ^ m * (A ^ n)⁻¹ := by\n  rw [← tsub_add_cancel_of_le h, pow_add, Matrix.mul_assoc, mul_nonsing_inv,\n    tsub_add_cancel_of_le h, Matrix.mul_one]\n  simpa using ha.pow n\n\n"}
{"name":"Matrix.pow_inv_comm'","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nm n : Nat\n⊢ Eq (HMul.hMul (HPow.hPow (Inv.inv A) m) (HPow.hPow A n)) (HMul.hMul (HPow.hPow A n) (HPow.hPow (Inv.inv A) m))","decl":"theorem pow_inv_comm' (A : M) (m n : ℕ) : A⁻¹ ^ m * A ^ n = A ^ n * A⁻¹ ^ m := by\n  induction' n with n IH generalizing m\n  · simp\n  cases' m with m m\n  · simp\n  rcases nonsing_inv_cancel_or_zero A with (⟨h, h'⟩ | h)\n  · calc\n       A⁻¹ ^ (m + 1) * A ^ (n + 1) = A⁻¹ ^ m * (A⁻¹ * A) * A ^ n := by\n        simp only [pow_succ A⁻¹, pow_succ' A, Matrix.mul_assoc]\n      _ = A ^ n * A⁻¹ ^ m := by simp only [h, Matrix.mul_one, Matrix.one_mul, IH m]\n      _ = A ^ n * (A * A⁻¹) * A⁻¹ ^ m := by simp only [h', Matrix.mul_one, Matrix.one_mul]\n      _ = A ^ (n + 1) * A⁻¹ ^ (m + 1) := by\n        simp only [pow_succ A, pow_succ' A⁻¹, Matrix.mul_assoc]\n  · simp [h]\n\n"}
{"name":"Matrix.one_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HPow.hPow 1 n) 1","decl":"@[simp]\ntheorem one_zpow : ∀ n : ℤ, (1 : M) ^ n = 1\n  | (n : ℕ) => by rw [zpow_natCast, one_pow]\n  | -[n+1] => by rw [zpow_negSucc, one_pow, inv_one]\n\n"}
{"name":"Matrix.zero_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nz : Int\na✝ : Ne z 0\n⊢ Eq (HPow.hPow 0 z) 0","decl":"theorem zero_zpow : ∀ z : ℤ, z ≠ 0 → (0 : M) ^ z = 0\n  | (n : ℕ), h => by\n    rw [zpow_natCast, zero_pow]\n    exact mod_cast h\n  | -[n+1], _ => by simp [zero_pow n.succ_ne_zero]\n\n"}
{"name":"Matrix.zero_zpow_eq","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nn : Int\n⊢ Eq (HPow.hPow 0 n) (ite (Eq n 0) 1 0)","decl":"theorem zero_zpow_eq (n : ℤ) : (0 : M) ^ n = if n = 0 then 1 else 0 := by\n  split_ifs with h\n  · rw [h, zpow_zero]\n  · rw [zero_zpow _ h]\n\n"}
{"name":"Matrix.inv_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Int\n⊢ Eq (HPow.hPow (Inv.inv A) n) (Inv.inv (HPow.hPow A n))","decl":"theorem inv_zpow (A : M) : ∀ n : ℤ, A⁻¹ ^ n = (A ^ n)⁻¹\n  | (n : ℕ) => by rw [zpow_natCast, zpow_natCast, inv_pow']\n  | -[n+1] => by rw [zpow_negSucc, zpow_negSucc, inv_pow']\n\n"}
{"name":"Matrix.zpow_neg_one","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\n⊢ Eq (HPow.hPow A (-1)) (Inv.inv A)","decl":"@[simp]\ntheorem zpow_neg_one (A : M) : A ^ (-1 : ℤ) = A⁻¹ := by\n  convert DivInvMonoid.zpow_neg' 0 A\n  simp only [zpow_one, Int.ofNat_zero, Int.ofNat_succ, zpow_eq_pow, zero_add]\n\n"}
{"name":"Matrix.zpow_neg_natCast","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Nat\n⊢ Eq (HPow.hPow A (Neg.neg ↑n)) (Inv.inv (HPow.hPow A n))","decl":"@[simp]\ntheorem zpow_neg_natCast (A : M) (n : ℕ) : A ^ (-n : ℤ) = (A ^ n)⁻¹ := by\n  cases n\n  · simp\n  · exact DivInvMonoid.zpow_neg' _ _\n\n"}
{"name":"IsUnit.det_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nn : Int\n⊢ IsUnit (HPow.hPow A n).det","decl":"theorem _root_.IsUnit.det_zpow {A : M} (h : IsUnit A.det) (n : ℤ) : IsUnit (A ^ n).det := by\n  cases' n with n n\n  · simpa using h.pow n\n  · simpa using h.pow n.succ\n\n"}
{"name":"Matrix.isUnit_det_zpow_iff","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nz : Int\n⊢ Iff (IsUnit (HPow.hPow A z).det) (Or (IsUnit A.det) (Eq z 0))","decl":"theorem isUnit_det_zpow_iff {A : M} {z : ℤ} : IsUnit (A ^ z).det ↔ IsUnit A.det ∨ z = 0 := by\n  induction z using Int.induction_on with\n  | hz => simp\n  | hp z =>\n    rw [← Int.ofNat_succ, zpow_natCast, det_pow, isUnit_pow_succ_iff, ← Int.ofNat_zero,\n      Int.ofNat_inj]\n    simp\n  | hn z =>\n    rw [← neg_add', ← Int.ofNat_succ, zpow_neg_natCast, isUnit_nonsing_inv_det_iff, det_pow,\n      isUnit_pow_succ_iff, neg_eq_zero, ← Int.ofNat_zero, Int.ofNat_inj]\n    simp\n\n"}
{"name":"Matrix.zpow_neg","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nn : Int\n⊢ Eq (HPow.hPow A (Neg.neg n)) (Inv.inv (HPow.hPow A n))","decl":"theorem zpow_neg {A : M} (h : IsUnit A.det) : ∀ n : ℤ, A ^ (-n) = (A ^ n)⁻¹\n  | (n : ℕ) => zpow_neg_natCast _ _\n  | -[n+1] => by\n    rw [zpow_negSucc, neg_negSucc, zpow_natCast, nonsing_inv_nonsing_inv]\n    rw [det_pow]\n    exact h.pow _\n\n"}
{"name":"Matrix.inv_zpow'","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nn : Int\n⊢ Eq (HPow.hPow (Inv.inv A) n) (HPow.hPow A (Neg.neg n))","decl":"theorem inv_zpow' {A : M} (h : IsUnit A.det) (n : ℤ) : A⁻¹ ^ n = A ^ (-n) := by\n  rw [zpow_neg h, inv_zpow]\n\n"}
{"name":"Matrix.zpow_add_one","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nn : Int\n⊢ Eq (HPow.hPow A (HAdd.hAdd n 1)) (HMul.hMul (HPow.hPow A n) A)","decl":"theorem zpow_add_one {A : M} (h : IsUnit A.det) : ∀ n : ℤ, A ^ (n + 1) = A ^ n * A\n  | (n : ℕ) => by simp only [← Nat.cast_succ, pow_succ, zpow_natCast]\n  | -[n+1] =>\n    calc\n      A ^ (-(n + 1) + 1 : ℤ) = (A ^ n)⁻¹ := by\n        rw [neg_add, neg_add_cancel_right, zpow_neg h, zpow_natCast]\n      _ = (A * A ^ n)⁻¹ * A := by\n        rw [mul_inv_rev, Matrix.mul_assoc, nonsing_inv_mul _ h, Matrix.mul_one]\n      _ = A ^ (-(n + 1 : ℤ)) * A := by\n        rw [zpow_neg h, ← Int.ofNat_succ, zpow_natCast, pow_succ']\n\n"}
{"name":"Matrix.zpow_sub_one","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nn : Int\n⊢ Eq (HPow.hPow A (HSub.hSub n 1)) (HMul.hMul (HPow.hPow A n) (Inv.inv A))","decl":"theorem zpow_sub_one {A : M} (h : IsUnit A.det) (n : ℤ) : A ^ (n - 1) = A ^ n * A⁻¹ :=\n  calc\n    A ^ (n - 1) = A ^ (n - 1) * A * A⁻¹ := by\n      rw [mul_assoc, mul_nonsing_inv _ h, mul_one]\n    _ = A ^ n * A⁻¹ := by rw [← zpow_add_one h, sub_add_cancel]\n\n"}
{"name":"Matrix.zpow_add","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nha : IsUnit A.det\nm n : Int\n⊢ Eq (HPow.hPow A (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow A m) (HPow.hPow A n))","decl":"theorem zpow_add {A : M} (ha : IsUnit A.det) (m n : ℤ) : A ^ (m + n) = A ^ m * A ^ n := by\n  induction n using Int.induction_on with\n  | hz => simp\n  | hp n ihn => simp only [← add_assoc, zpow_add_one ha, ihn, mul_assoc]\n  | hn n ihn => rw [zpow_sub_one ha, ← mul_assoc, ← ihn, ← zpow_sub_one ha, add_sub_assoc]\n\n"}
{"name":"Matrix.zpow_add_of_nonpos","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nm n : Int\nhm : LE.le m 0\nhn : LE.le n 0\n⊢ Eq (HPow.hPow A (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow A m) (HPow.hPow A n))","decl":"theorem zpow_add_of_nonpos {A : M} {m n : ℤ} (hm : m ≤ 0) (hn : n ≤ 0) :\n    A ^ (m + n) = A ^ m * A ^ n := by\n  rcases nonsing_inv_cancel_or_zero A with (⟨h, _⟩ | h)\n  · exact zpow_add (isUnit_det_of_left_inverse h) m n\n  · obtain ⟨k, rfl⟩ := exists_eq_neg_ofNat hm\n    obtain ⟨l, rfl⟩ := exists_eq_neg_ofNat hn\n    simp_rw [← neg_add, ← Int.ofNat_add, zpow_neg_natCast, ← inv_pow', h, pow_add]\n\n"}
{"name":"Matrix.zpow_add_of_nonneg","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nm n : Int\nhm : LE.le 0 m\nhn : LE.le 0 n\n⊢ Eq (HPow.hPow A (HAdd.hAdd m n)) (HMul.hMul (HPow.hPow A m) (HPow.hPow A n))","decl":"theorem zpow_add_of_nonneg {A : M} {m n : ℤ} (hm : 0 ≤ m) (hn : 0 ≤ n) :\n    A ^ (m + n) = A ^ m * A ^ n := by\n  obtain ⟨k, rfl⟩ := eq_ofNat_of_zero_le hm\n  obtain ⟨l, rfl⟩ := eq_ofNat_of_zero_le hn\n  rw [← Int.ofNat_add, zpow_natCast, zpow_natCast, zpow_natCast, pow_add]\n\n"}
{"name":"Matrix.zpow_one_add","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\ni : Int\n⊢ Eq (HPow.hPow A (HAdd.hAdd 1 i)) (HMul.hMul A (HPow.hPow A i))","decl":"theorem zpow_one_add {A : M} (h : IsUnit A.det) (i : ℤ) : A ^ (1 + i) = A * A ^ i := by\n  rw [zpow_add h, zpow_one]\n\n"}
{"name":"Matrix.SemiconjBy.zpow_right","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA X Y : Matrix n' n' R\nhx : IsUnit X.det\nhy : IsUnit Y.det\nh : SemiconjBy A X Y\nm : Int\n⊢ SemiconjBy A (HPow.hPow X m) (HPow.hPow Y m)","decl":"theorem SemiconjBy.zpow_right {A X Y : M} (hx : IsUnit X.det) (hy : IsUnit Y.det)\n    (h : SemiconjBy A X Y) : ∀ m : ℤ, SemiconjBy A (X ^ m) (Y ^ m)\n  | (n : ℕ) => by simp [h.pow_right n]\n  | -[n+1] => by\n    have hx' : IsUnit (X ^ n.succ).det := by\n      rw [det_pow]\n      exact hx.pow n.succ\n    have hy' : IsUnit (Y ^ n.succ).det := by\n      rw [det_pow]\n      exact hy.pow n.succ\n    rw [zpow_negSucc, zpow_negSucc, nonsing_inv_apply _ hx', nonsing_inv_apply _ hy', SemiconjBy]\n    refine (isRegular_of_isLeftRegular_det hy'.isRegular.left).left ?_\n    dsimp only\n    rw [← mul_assoc, ← (h.pow_right n.succ).eq, mul_assoc, mul_smul,\n      mul_adjugate, ← Matrix.mul_assoc,\n      mul_smul (Y ^ _) (↑hy'.unit⁻¹ : R), mul_adjugate, smul_smul, smul_smul, hx'.val_inv_mul,\n      hy'.val_inv_mul, one_smul, Matrix.mul_one, Matrix.one_mul]\n\n"}
{"name":"Matrix.Commute.zpow_right","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA B : Matrix n' n' R\nh : Commute A B\nm : Int\n⊢ Commute A (HPow.hPow B m)","decl":"theorem Commute.zpow_right {A B : M} (h : Commute A B) (m : ℤ) : Commute A (B ^ m) := by\n  rcases nonsing_inv_cancel_or_zero B with (⟨hB, _⟩ | hB)\n  · refine SemiconjBy.zpow_right ?_ ?_ h _ <;> exact isUnit_det_of_left_inverse hB\n  · cases m\n    · simpa using h.pow_right _\n    · simp [← inv_pow', hB]\n\n"}
{"name":"Matrix.Commute.zpow_left","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA B : Matrix n' n' R\nh : Commute A B\nm : Int\n⊢ Commute (HPow.hPow A m) B","decl":"theorem Commute.zpow_left {A B : M} (h : Commute A B) (m : ℤ) : Commute (A ^ m) B :=\n  (Commute.zpow_right h.symm m).symm\n\n"}
{"name":"Matrix.Commute.zpow_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA B : Matrix n' n' R\nh : Commute A B\nm n : Int\n⊢ Commute (HPow.hPow A m) (HPow.hPow B n)","decl":"theorem Commute.zpow_zpow {A B : M} (h : Commute A B) (m n : ℤ) : Commute (A ^ m) (B ^ n) :=\n  Commute.zpow_right (Commute.zpow_left h _) _\n\n"}
{"name":"Matrix.Commute.zpow_self","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Int\n⊢ Commute (HPow.hPow A n) A","decl":"theorem Commute.zpow_self (A : M) (n : ℤ) : Commute (A ^ n) A :=\n  Commute.zpow_left (Commute.refl A) _\n\n"}
{"name":"Matrix.Commute.self_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Int\n⊢ Commute A (HPow.hPow A n)","decl":"theorem Commute.self_zpow (A : M) (n : ℤ) : Commute A (A ^ n) :=\n  Commute.zpow_right (Commute.refl A) _\n\n"}
{"name":"Matrix.Commute.zpow_zpow_self","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nm n : Int\n⊢ Commute (HPow.hPow A m) (HPow.hPow A n)","decl":"theorem Commute.zpow_zpow_self (A : M) (m n : ℤ) : Commute (A ^ m) (A ^ n) :=\n  Commute.zpow_zpow (Commute.refl A) _ _\n\n"}
{"name":"Matrix.zpow_add_one_of_ne_neg_one","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Int\na✝ : Ne n (-1)\n⊢ Eq (HPow.hPow A (HAdd.hAdd n 1)) (HMul.hMul (HPow.hPow A n) A)","decl":"theorem zpow_add_one_of_ne_neg_one {A : M} : ∀ n : ℤ, n ≠ -1 → A ^ (n + 1) = A ^ n * A\n  | (n : ℕ), _ => by simp only [pow_succ, ← Nat.cast_succ, zpow_natCast]\n  | -1, h => absurd rfl h\n  | -((n : ℕ) + 2), _ => by\n    rcases nonsing_inv_cancel_or_zero A with (⟨h, _⟩ | h)\n    · apply zpow_add_one (isUnit_det_of_left_inverse h)\n    · show A ^ (-((n + 1 : ℕ) : ℤ)) = A ^ (-((n + 2 : ℕ) : ℤ)) * A\n      simp_rw [zpow_neg_natCast, ← inv_pow', h, zero_pow <| Nat.succ_ne_zero _, zero_mul]\n\n"}
{"name":"Matrix.zpow_mul","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nm n : Int\n⊢ Eq (HPow.hPow A (HMul.hMul m n)) (HPow.hPow (HPow.hPow A m) n)","decl":"theorem zpow_mul (A : M) (h : IsUnit A.det) : ∀ m n : ℤ, A ^ (m * n) = (A ^ m) ^ n\n  | (m : ℕ), (n : ℕ) => by rw [zpow_natCast, zpow_natCast, ← pow_mul, ← zpow_natCast, Int.ofNat_mul]\n  | (m : ℕ), -[n+1] => by\n    rw [zpow_natCast, zpow_negSucc, ← pow_mul, ofNat_mul_negSucc, zpow_neg_natCast]\n  | -[m+1], (n : ℕ) => by\n    rw [zpow_natCast, zpow_negSucc, ← inv_pow', ← pow_mul, negSucc_mul_ofNat, zpow_neg_natCast,\n        inv_pow']\n  | -[m+1], -[n+1] => by\n    rw [zpow_negSucc, zpow_negSucc, negSucc_mul_negSucc, ← Int.ofNat_mul, zpow_natCast, inv_pow', ←\n      pow_mul, nonsing_inv_nonsing_inv]\n    rw [det_pow]\n    exact h.pow _\n\n"}
{"name":"Matrix.zpow_mul'","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : IsUnit A.det\nm n : Int\n⊢ Eq (HPow.hPow A (HMul.hMul m n)) (HPow.hPow (HPow.hPow A n) m)","decl":"theorem zpow_mul' (A : M) (h : IsUnit A.det) (m n : ℤ) : A ^ (m * n) = (A ^ n) ^ m := by\n  rw [mul_comm, zpow_mul _ h]\n\n\n"}
{"name":"Matrix.coe_units_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nu : Units (Matrix n' n' R)\nn : Int\n⊢ Eq (↑(HPow.hPow u n)) (HPow.hPow (↑u) n)","decl":"@[simp, norm_cast]\ntheorem coe_units_zpow (u : Mˣ) : ∀ n : ℤ, ((u ^ n : Mˣ) : M) = (u : M) ^ n\n  | (n : ℕ) => by rw [zpow_natCast, zpow_natCast, Units.val_pow_eq_pow_val]\n  | -[k+1] => by\n    rw [zpow_negSucc, zpow_negSucc, ← inv_pow, u⁻¹.val_pow_eq_pow_val, ← inv_pow', coe_units_inv]\n\n"}
{"name":"Matrix.zpow_ne_zero_of_isUnit_det","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝⁴ : DecidableEq n'\ninst✝³ : Fintype n'\nR : Type u_2\ninst✝² : CommRing R\ninst✝¹ : Nonempty n'\ninst✝ : Nontrivial R\nA : Matrix n' n' R\nha : IsUnit A.det\nz : Int\n⊢ Ne (HPow.hPow A z) 0","decl":"theorem zpow_ne_zero_of_isUnit_det [Nonempty n'] [Nontrivial R] {A : M} (ha : IsUnit A.det)\n    (z : ℤ) : A ^ z ≠ 0 := by\n  have := ha.det_zpow z\n  contrapose! this\n  rw [this, det_zero ‹_›]\n  exact not_isUnit_zero\n\n"}
{"name":"Matrix.zpow_sub","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nha : IsUnit A.det\nz1 z2 : Int\n⊢ Eq (HPow.hPow A (HSub.hSub z1 z2)) (HDiv.hDiv (HPow.hPow A z1) (HPow.hPow A z2))","decl":"theorem zpow_sub {A : M} (ha : IsUnit A.det) (z1 z2 : ℤ) : A ^ (z1 - z2) = A ^ z1 / A ^ z2 := by\n  rw [sub_eq_add_neg, zpow_add ha, zpow_neg ha, div_eq_mul_inv]\n\n"}
{"name":"Matrix.Commute.mul_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA B : Matrix n' n' R\nh : Commute A B\ni : Int\n⊢ Eq (HPow.hPow (HMul.hMul A B) i) (HMul.hMul (HPow.hPow A i) (HPow.hPow B i))","decl":"theorem Commute.mul_zpow {A B : M} (h : Commute A B) : ∀ i : ℤ, (A * B) ^ i = A ^ i * B ^ i\n  | (n : ℕ) => by simp [h.mul_pow n]\n  | -[n+1] => by\n    rw [zpow_negSucc, zpow_negSucc, zpow_negSucc, ← mul_inv_rev,\n      h.mul_pow n.succ, (h.pow_pow _ _).eq]\n\n"}
{"name":"Matrix.zpow_neg_mul_zpow_self","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nn : Int\nA : Matrix n' n' R\nh : IsUnit A.det\n⊢ Eq (HMul.hMul (HPow.hPow A (Neg.neg n)) (HPow.hPow A n)) 1","decl":"theorem zpow_neg_mul_zpow_self (n : ℤ) {A : M} (h : IsUnit A.det) : A ^ (-n) * A ^ n = 1 := by\n  rw [zpow_neg h, nonsing_inv_mul _ (h.det_zpow _)]\n\n"}
{"name":"Matrix.one_div_pow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Nat\n⊢ Eq (HPow.hPow (HDiv.hDiv 1 A) n) (HDiv.hDiv 1 (HPow.hPow A n))","decl":"theorem one_div_pow {A : M} (n : ℕ) : (1 / A) ^ n = 1 / A ^ n := by simp only [one_div, inv_pow']\n\n"}
{"name":"Matrix.one_div_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Int\n⊢ Eq (HPow.hPow (HDiv.hDiv 1 A) n) (HDiv.hDiv 1 (HPow.hPow A n))","decl":"theorem one_div_zpow {A : M} (n : ℤ) : (1 / A) ^ n = 1 / A ^ n := by simp only [one_div, inv_zpow]\n\n"}
{"name":"Matrix.transpose_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nn : Int\n⊢ Eq (HPow.hPow A n).transpose (HPow.hPow A.transpose n)","decl":"@[simp]\ntheorem transpose_zpow (A : M) : ∀ n : ℤ, (A ^ n)ᵀ = Aᵀ ^ n\n  | (n : ℕ) => by rw [zpow_natCast, zpow_natCast, transpose_pow]\n  | -[n+1] => by rw [zpow_negSucc, zpow_negSucc, transpose_nonsing_inv, transpose_pow]\n\n"}
{"name":"Matrix.conjTranspose_zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝³ : DecidableEq n'\ninst✝² : Fintype n'\nR : Type u_2\ninst✝¹ : CommRing R\ninst✝ : StarRing R\nA : Matrix n' n' R\nn : Int\n⊢ Eq (HPow.hPow A n).conjTranspose (HPow.hPow A.conjTranspose n)","decl":"@[simp]\ntheorem conjTranspose_zpow [StarRing R] (A : M) : ∀ n : ℤ, (A ^ n)ᴴ = Aᴴ ^ n\n  | (n : ℕ) => by rw [zpow_natCast, zpow_natCast, conjTranspose_pow]\n  | -[n+1] => by rw [zpow_negSucc, zpow_negSucc, conjTranspose_nonsing_inv, conjTranspose_pow]\n\n"}
{"name":"Matrix.IsSymm.zpow","module":"Mathlib.LinearAlgebra.Matrix.ZPow","initialProofState":"n' : Type u_1\ninst✝² : DecidableEq n'\ninst✝¹ : Fintype n'\nR : Type u_2\ninst✝ : CommRing R\nA : Matrix n' n' R\nh : A.IsSymm\nk : Int\n⊢ (HPow.hPow A k).IsSymm","decl":"theorem IsSymm.zpow {A : M} (h : A.IsSymm) (k : ℤ) :\n    (A ^ k).IsSymm := by\n  rw [IsSymm, transpose_zpow, h]\n\n"}
