{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù¬≤ : SizeOf C\ninst‚úù¬π : ‚¶ÉX Y : C‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W‚ÇÅ x)\ninst‚úù : ‚¶ÉX Y : C‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W‚ÇÇ x)\nZ : C\ni : Quiver.Hom X Z\np : Quiver.Hom Z Y\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) f) _auto‚úù\nhi : W‚ÇÅ i\nhp : W‚ÇÇ p\n‚ä¢ Eq (SizeOf.sizeOf { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Z)) (SizeOf.sizeOf i)) (SizeOf.sizeOf p)) (SizeOf.sizeOf fac)) (SizeOf.sizeOf hi)) (SizeOf.sizeOf hp))","decl":"/-- Given two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ‚ü∂ Y` as `i ‚â´ p` with\n`W‚ÇÅ i` and `W‚ÇÇ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ‚ü∂ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ‚ü∂ Z\n  /-- the second morphism in the factorization -/\n  p : Z ‚ü∂ Y\n  fac : i ‚â´ p = f := by aesop_cat\n  hi : W‚ÇÅ i\n  hp : W‚ÇÇ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nZ‚úù : C\ni‚úù : Quiver.Hom X Z‚úù\np‚úù : Quiver.Hom Z‚úù Y\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp i‚úù p‚úù) f) _auto‚úù\nhi‚úù : W‚ÇÅ i‚úù\nhp‚úù : W‚ÇÇ p‚úù\nZ : C\ni : Quiver.Hom X Z\np : Quiver.Hom Z Y\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) f) _auto‚úù\nhi : W‚ÇÅ i\nhp : W‚ÇÇ p\n‚ä¢ Eq (Eq { Z := Z‚úù, i := i‚úù, p := p‚úù, fac := fac‚úù, hi := hi‚úù, hp := hp‚úù } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (And (Eq Z‚úù Z) (And (HEq i‚úù i) (HEq p‚úù p)))","decl":"/-- Given two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ‚ü∂ Y` as `i ‚â´ p` with\n`W‚ÇÅ i` and `W‚ÇÇ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ‚ü∂ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ‚ü∂ Z\n  /-- the second morphism in the factorization -/\n  p : Z ‚ü∂ Y\n  fac : i ‚â´ p = f := by aesop_cat\n  hi : W‚ÇÅ i\n  hp : W‚ÇÇ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.fac","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W‚ÇÅ.MapFactorizationData W‚ÇÇ f\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i self.p) f","decl":"/-- Given two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ‚ü∂ Y` as `i ‚â´ p` with\n`W‚ÇÅ i` and `W‚ÇÇ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ‚ü∂ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ‚ü∂ Z\n  /-- the second morphism in the factorization -/\n  p : Z ‚ü∂ Y\n  fac : i ‚â´ p = f := by aesop_cat\n  hi : W‚ÇÅ i\n  hp : W‚ÇÇ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nZ‚úù : C\ni‚úù : Quiver.Hom X Z‚úù\np‚úù : Quiver.Hom Z‚úù Y\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp i‚úù p‚úù) f) _auto‚úù\nhi‚úù : W‚ÇÅ i‚úù\nhp‚úù : W‚ÇÇ p‚úù\nZ : C\ni : Quiver.Hom X Z\np : Quiver.Hom Z Y\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) f) _auto‚úù\nhi : W‚ÇÅ i\nhp : W‚ÇÇ p\nx‚úù : Eq { Z := Z‚úù, i := i‚úù, p := p‚úù, fac := fac‚úù, hi := hi‚úù, hp := hp‚úù } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }\n‚ä¢ And (Eq Z‚úù Z) (And (HEq i‚úù i) (HEq p‚úù p))","decl":"/-- Given two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ‚ü∂ Y` as `i ‚â´ p` with\n`W‚ÇÅ i` and `W‚ÇÇ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ‚ü∂ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ‚ü∂ Z\n  /-- the second morphism in the factorization -/\n  p : Z ‚ü∂ Y\n  fac : i ‚â´ p = f := by aesop_cat\n  hi : W‚ÇÅ i\n  hp : W‚ÇÇ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.hp","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W‚ÇÅ.MapFactorizationData W‚ÇÇ f\n‚ä¢ W‚ÇÇ self.p","decl":"/-- Given two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ‚ü∂ Y` as `i ‚â´ p` with\n`W‚ÇÅ i` and `W‚ÇÇ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ‚ü∂ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ‚ü∂ Z\n  /-- the second morphism in the factorization -/\n  p : Z ‚ü∂ Y\n  fac : i ‚â´ p = f := by aesop_cat\n  hi : W‚ÇÅ i\n  hp : W‚ÇÇ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.hi","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W‚ÇÅ.MapFactorizationData W‚ÇÇ f\n‚ä¢ W‚ÇÅ self.i","decl":"/-- Given two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ‚ü∂ Y` as `i ‚â´ p` with\n`W‚ÇÅ i` and `W‚ÇÇ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ‚ü∂ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ‚ü∂ Z\n  /-- the second morphism in the factorization -/\n  p : Z ‚ü∂ Y\n  fac : i ‚â´ p = f := by aesop_cat\n  hi : W‚ÇÅ i\n  hp : W‚ÇÇ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.fac_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W‚ÇÅ.MapFactorizationData W‚ÇÇ f\nZ : C\nh : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp self.p h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"attribute [reassoc (attr := simp)] MapFactorizationData.fac\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasFactorization.nonempty_mapFactorizationData","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nself : W‚ÇÅ.HasFactorization W‚ÇÇ\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Nonempty (W‚ÇÅ.MapFactorizationData W‚ÇÇ f)","decl":"/-- The factorization axiom for two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` in a category `C`. It\nasserts that any morphism can be factored as a morphism in `W‚ÇÅ` followed by a morphism\nin `W‚ÇÇ`. -/\nclass HasFactorization : Prop where\n  nonempty_mapFactorizationData {X Y : C} (f : X ‚ü∂ Y) : Nonempty (MapFactorizationData W‚ÇÅ W‚ÇÇ f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.comp_eq_top_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\n‚ä¢ Iff (Eq (W‚ÇÅ.comp W‚ÇÇ) Top.top) (W‚ÇÅ.HasFactorization W‚ÇÇ)","decl":"lemma comp_eq_top_iff : W‚ÇÅ.comp W‚ÇÇ = ‚ä§ ‚Üî HasFactorization W‚ÇÅ W‚ÇÇ := by\n  constructor\n  ¬∑ intro h\n    refine ‚ü®fun f => ?_‚ü©\n    have : W‚ÇÅ.comp W‚ÇÇ f := by simp only [h, top_apply]\n    exact ‚ü®this.some‚ü©\n  ¬∑ intro\n    ext X Y f\n    simp only [top_apply, iff_true]\n    exact ‚ü®factorizationData W‚ÇÅ W‚ÇÇ f‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nZ‚úù : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni‚úù : Quiver.Hom CategoryTheory.Arrow.leftFunc Z‚úù\np‚úù : Quiver.Hom Z‚úù CategoryTheory.Arrow.rightFunc\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp i‚úù p‚úù) CategoryTheory.Arrow.leftToRight) _auto‚úù\nhi‚úù : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÅ (i‚úù.app f)\nhp‚úù : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÇ (p‚úù.app f)\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni : Quiver.Hom CategoryTheory.Arrow.leftFunc Z\np : Quiver.Hom Z CategoryTheory.Arrow.rightFunc\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) CategoryTheory.Arrow.leftToRight) _auto‚úù\nhi : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÅ (i.app f)\nhp : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÇ (p.app f)\n‚ä¢ Eq (Eq { Z := Z‚úù, i := i‚úù, p := p‚úù, fac := fac‚úù, hi := hi‚úù, hp := hp‚úù } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (And (Eq Z‚úù Z) (And (HEq i‚úù i) (HEq p‚úù p)))","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W‚ÇÅ`\nfollowed by a morphism in `W‚ÇÇ`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ‚•§ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ‚ü∂ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ‚ü∂ Arrow.rightFunc\n  fac : i ‚â´ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W‚ÇÅ (i.app f)\n  hp (f : Arrow C) : W‚ÇÇ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.hi","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nself : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nf : CategoryTheory.Arrow C\n‚ä¢ W‚ÇÅ (self.i.app f)","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W‚ÇÅ`\nfollowed by a morphism in `W‚ÇÇ`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ‚•§ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ‚ü∂ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ‚ü∂ Arrow.rightFunc\n  fac : i ‚â´ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W‚ÇÅ (i.app f)\n  hp (f : Arrow C) : W‚ÇÇ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬≥ : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ninst‚úù¬≤ : SizeOf C\ninst‚úù¬π : ‚¶ÉX Y : C‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W‚ÇÅ x)\ninst‚úù : ‚¶ÉX Y : C‚¶Ñ ‚Üí (x : Quiver.Hom X Y) ‚Üí SizeOf (W‚ÇÇ x)\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni : Quiver.Hom CategoryTheory.Arrow.leftFunc Z\np : Quiver.Hom Z CategoryTheory.Arrow.rightFunc\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) CategoryTheory.Arrow.leftToRight) _auto‚úù\nhi : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÅ (i.app f)\nhp : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÇ (p.app f)\n‚ä¢ Eq (SizeOf.sizeOf { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Z)) (SizeOf.sizeOf i)) (SizeOf.sizeOf p)) (SizeOf.sizeOf fac))","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W‚ÇÅ`\nfollowed by a morphism in `W‚ÇÇ`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ‚•§ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ‚ü∂ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ‚ü∂ Arrow.rightFunc\n  fac : i ‚â´ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W‚ÇÅ (i.app f)\n  hp (f : Arrow C) : W‚ÇÇ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.hp","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nself : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nf : CategoryTheory.Arrow C\n‚ä¢ W‚ÇÇ (self.p.app f)","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W‚ÇÅ`\nfollowed by a morphism in `W‚ÇÇ`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ‚•§ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ‚ü∂ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ‚ü∂ Arrow.rightFunc\n  fac : i ‚â´ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W‚ÇÅ (i.app f)\n  hp (f : Arrow C) : W‚ÇÇ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nself : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i self.p) CategoryTheory.Arrow.leftToRight","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W‚ÇÅ`\nfollowed by a morphism in `W‚ÇÇ`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ‚•§ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ‚ü∂ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ‚ü∂ Arrow.rightFunc\n  fac : i ‚â´ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W‚ÇÅ (i.app f)\n  hp (f : Arrow C) : W‚ÇÇ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nZ‚úù : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni‚úù : Quiver.Hom CategoryTheory.Arrow.leftFunc Z‚úù\np‚úù : Quiver.Hom Z‚úù CategoryTheory.Arrow.rightFunc\nfac‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp i‚úù p‚úù) CategoryTheory.Arrow.leftToRight) _auto‚úù\nhi‚úù : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÅ (i‚úù.app f)\nhp‚úù : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÇ (p‚úù.app f)\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni : Quiver.Hom CategoryTheory.Arrow.leftFunc Z\np : Quiver.Hom Z CategoryTheory.Arrow.rightFunc\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) CategoryTheory.Arrow.leftToRight) _auto‚úù\nhi : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÅ (i.app f)\nhp : ‚àÄ (f : CategoryTheory.Arrow C), W‚ÇÇ (p.app f)\nx‚úù : Eq { Z := Z‚úù, i := i‚úù, p := p‚úù, fac := fac‚úù, hi := hi‚úù, hp := hp‚úù } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }\n‚ä¢ And (Eq Z‚úù Z) (And (HEq i‚úù i) (HEq p‚úù p))","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W‚ÇÅ`\nfollowed by a morphism in `W‚ÇÇ`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ‚•§ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ‚ü∂ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ‚ü∂ Arrow.rightFunc\n  fac : i ‚â´ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W‚ÇÅ (i.app f)\n  hp (f : Arrow C) : W‚ÇÇ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nself : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\nh : Quiver.Hom CategoryTheory.Arrow.rightFunc Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp self.p h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Arrow.leftToRight h)","decl":"attribute [reassoc (attr := simp)] fac\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac_app_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nf : CategoryTheory.Arrow C\nZ : C\nh : Quiver.Hom (CategoryTheory.Arrow.rightFunc.obj f) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.i.app f) (CategoryTheory.CategoryStruct.comp (data.p.app f) h)) (CategoryTheory.CategoryStruct.comp f.hom h)","decl":"@[reassoc (attr := simp)]\nlemma fac_app {f : Arrow C} : data.i.app f ‚â´ data.p.app f = f.hom := by\n  rw [‚Üê NatTrans.comp_app, fac,Arrow.leftToRight_app]\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac_app","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nf : CategoryTheory.Arrow C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.i.app f) (data.p.app f)) f.hom","decl":"@[reassoc (attr := simp)]\nlemma fac_app {f : Arrow C} : data.i.app f ‚â´ data.p.app f = f.hom := by\n  rw [‚Üê NatTrans.comp_app, fac,Arrow.leftToRight_app]\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.i_mapZ_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nZ : C\nh : Quiver.Hom (data.factorizationData g).Z Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.factorizationData f).i (CategoryTheory.CategoryStruct.comp (data.mapZ œÜ) h)) (CategoryTheory.CategoryStruct.comp œÜ.left (CategoryTheory.CategoryStruct.comp (data.factorizationData g).i h))","decl":"@[reassoc (attr := simp)]\nlemma i_mapZ :\n    (data.factorizationData f).i ‚â´ data.mapZ œÜ = œÜ.left ‚â´ (data.factorizationData g).i :=\n  (data.i.naturality œÜ).symm\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.i_mapZ","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.factorizationData f).i (data.mapZ œÜ)) (CategoryTheory.CategoryStruct.comp œÜ.left (data.factorizationData g).i)","decl":"@[reassoc (attr := simp)]\nlemma i_mapZ :\n    (data.factorizationData f).i ‚â´ data.mapZ œÜ = œÜ.left ‚â´ (data.factorizationData g).i :=\n  (data.i.naturality œÜ).symm\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_p","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.mapZ œÜ) (data.factorizationData g).p) (CategoryTheory.CategoryStruct.comp (data.factorizationData f).p œÜ.right)","decl":"@[reassoc (attr := simp)]\nlemma mapZ_p :\n    data.mapZ œÜ ‚â´ (data.factorizationData g).p = (data.factorizationData f).p ‚â´ œÜ.right :=\n  data.p.naturality œÜ\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_p_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nZ : C\nh : Quiver.Hom Y' Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.mapZ œÜ) (CategoryTheory.CategoryStruct.comp (data.factorizationData g).p h)) (CategoryTheory.CategoryStruct.comp (data.factorizationData f).p (CategoryTheory.CategoryStruct.comp œÜ.right h))","decl":"@[reassoc (attr := simp)]\nlemma mapZ_p :\n    data.mapZ œÜ ‚â´ (data.factorizationData g).p = (data.factorizationData f).p ‚â´ œÜ.right :=\n  data.p.naturality œÜ\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_id","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (data.mapZ (CategoryTheory.CategoryStruct.id (CategoryTheory.Arrow.mk f))) (CategoryTheory.CategoryStruct.id (data.factorizationData f).Z)","decl":"variable (f) in\n@[simp]\nlemma mapZ_id : data.mapZ (ùüô (Arrow.mk f)) = ùüô _ :=\n  data.Z.map_id _\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_comp_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nX'' Y'' : C\nh‚úù : Quiver.Hom X'' Y''\nœà : Quiver.Hom (CategoryTheory.Arrow.mk g) (CategoryTheory.Arrow.mk h‚úù)\nZ : C\nh : Quiver.Hom (data.factorizationData h‚úù).Z Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (data.mapZ (CategoryTheory.CategoryStruct.comp œÜ œà)) h) (CategoryTheory.CategoryStruct.comp (data.mapZ œÜ) (CategoryTheory.CategoryStruct.comp (data.mapZ œà) h))","decl":"@[reassoc, simp]\nlemma mapZ_comp {X'' Y'' : C} {h : X'' ‚ü∂ Y''} (œà : Arrow.mk g ‚ü∂ Arrow.mk h) :\n    data.mapZ (œÜ ‚â´ œà) = data.mapZ œÜ ‚â´ data.mapZ œà :=\n  data.Z.map_comp _ _\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_comp","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nœÜ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nX'' Y'' : C\nh : Quiver.Hom X'' Y''\nœà : Quiver.Hom (CategoryTheory.Arrow.mk g) (CategoryTheory.Arrow.mk h)\n‚ä¢ Eq (data.mapZ (CategoryTheory.CategoryStruct.comp œÜ œà)) (CategoryTheory.CategoryStruct.comp (data.mapZ œÜ) (data.mapZ œà))","decl":"@[reassoc, simp]\nlemma mapZ_comp {X'' Y'' : C} {h : X'' ‚ü∂ Y''} (œà : Arrow.mk g ‚ü∂ Arrow.mk h) :\n    data.mapZ (œÜ ‚â´ œà) = data.mapZ œÜ ‚â´ data.mapZ œà :=\n  data.Z.map_comp _ _\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z_obj_map","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nJ : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} J\nf : CategoryTheory.Arrow (CategoryTheory.Functor J C)\nX‚úù Y‚úù : J\nœÜ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z data J).obj f).map œÜ) (data.mapZ { left := f.left.map œÜ, right := f.right.map œÜ, w := ‚ãØ })","decl":"/-- Auxiliary definition for `FunctorialFactorizationData.functorCategory`. -/\n@[simps]\ndef functorCategory.Z : Arrow (J ‚•§ C) ‚•§ J ‚•§ C where\n  obj f :=\n    { obj := fun j => (data.factorizationData (f.hom.app j)).Z\n      map := fun œÜ => data.mapZ\n        { left := f.left.map œÜ\n          right := f.right.map œÜ }\n      map_id := fun j => by\n        dsimp\n        rw [‚Üê data.mapZ_id (f.hom.app j)]\n        congr <;> simp\n      map_comp := fun _ _ => by\n        dsimp\n        rw [‚Üê data.mapZ_comp]\n        congr <;> simp }\n  map œÑ :=\n    { app := fun j => data.mapZ\n        { left := œÑ.left.app j\n          right := œÑ.right.app j\n          w := congr_app œÑ.w j }\n      naturality := fun _ _ Œ± => by\n        dsimp\n        rw [‚Üê data.mapZ_comp, ‚Üê data.mapZ_comp]\n        congr 1\n        ext <;> simp }\n  map_id f := by\n    ext j\n    dsimp\n    rw [‚Üê data.mapZ_id]\n    congr 1\n  map_comp f g := by\n    ext j\n    dsimp\n    rw [‚Üê data.mapZ_comp]\n    congr 1\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z_map_app","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nJ : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} J\nX‚úù Y‚úù : CategoryTheory.Arrow (CategoryTheory.Functor J C)\nœÑ : Quiver.Hom X‚úù Y‚úù\nj : J\n‚ä¢ Eq (((CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z data J).map œÑ).app j) (data.mapZ { left := œÑ.left.app j, right := œÑ.right.app j, w := ‚ãØ })","decl":"/-- Auxiliary definition for `FunctorialFactorizationData.functorCategory`. -/\n@[simps]\ndef functorCategory.Z : Arrow (J ‚•§ C) ‚•§ J ‚•§ C where\n  obj f :=\n    { obj := fun j => (data.factorizationData (f.hom.app j)).Z\n      map := fun œÜ => data.mapZ\n        { left := f.left.map œÜ\n          right := f.right.map œÜ }\n      map_id := fun j => by\n        dsimp\n        rw [‚Üê data.mapZ_id (f.hom.app j)]\n        congr <;> simp\n      map_comp := fun _ _ => by\n        dsimp\n        rw [‚Üê data.mapZ_comp]\n        congr <;> simp }\n  map œÑ :=\n    { app := fun j => data.mapZ\n        { left := œÑ.left.app j\n          right := œÑ.right.app j\n          w := congr_app œÑ.w j }\n      naturality := fun _ _ Œ± => by\n        dsimp\n        rw [‚Üê data.mapZ_comp, ‚Üê data.mapZ_comp]\n        congr 1\n        ext <;> simp }\n  map_id f := by\n    ext j\n    dsimp\n    rw [‚Üê data.mapZ_id]\n    congr 1\n  map_comp f g := by\n    ext j\n    dsimp\n    rw [‚Üê data.mapZ_comp]\n    congr 1\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z_obj_obj","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ndata : W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ\nJ : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} J\nf : CategoryTheory.Arrow (CategoryTheory.Functor J C)\nj : J\n‚ä¢ Eq (((CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z data J).obj f).obj j) (data.factorizationData (f.hom.app j)).Z","decl":"/-- Auxiliary definition for `FunctorialFactorizationData.functorCategory`. -/\n@[simps]\ndef functorCategory.Z : Arrow (J ‚•§ C) ‚•§ J ‚•§ C where\n  obj f :=\n    { obj := fun j => (data.factorizationData (f.hom.app j)).Z\n      map := fun œÜ => data.mapZ\n        { left := f.left.map œÜ\n          right := f.right.map œÜ }\n      map_id := fun j => by\n        dsimp\n        rw [‚Üê data.mapZ_id (f.hom.app j)]\n        congr <;> simp\n      map_comp := fun _ _ => by\n        dsimp\n        rw [‚Üê data.mapZ_comp]\n        congr <;> simp }\n  map œÑ :=\n    { app := fun j => data.mapZ\n        { left := œÑ.left.app j\n          right := œÑ.right.app j\n          w := congr_app œÑ.w j }\n      naturality := fun _ _ Œ± => by\n        dsimp\n        rw [‚Üê data.mapZ_comp, ‚Üê data.mapZ_comp]\n        congr 1\n        ext <;> simp }\n  map_id f := by\n    ext j\n    dsimp\n    rw [‚Üê data.mapZ_id]\n    congr 1\n  map_comp f g := by\n    ext j\n    dsimp\n    rw [‚Üê data.mapZ_comp]\n    congr 1\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasFunctorialFactorization.nonempty_functorialFactorizationData","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\nself : W‚ÇÅ.HasFunctorialFactorization W‚ÇÇ\n‚ä¢ Nonempty (W‚ÇÅ.FunctorialFactorizationData W‚ÇÇ)","decl":"/-- The functorial factorization axiom for two classes of morphisms `W‚ÇÅ` and `W‚ÇÇ` in a\ncategory `C`. It asserts that any morphism can be factored in a functorial manner\nas a morphism in `W‚ÇÅ` followed by a morphism in `W‚ÇÇ`. -/\nclass HasFunctorialFactorization : Prop where\n  nonempty_functorialFactorizationData : Nonempty (FunctorialFactorizationData W‚ÇÅ W‚ÇÇ)\n\n"}
{"name":"CategoryTheory.MorphismProperty.instHasFactorizationOfHasFunctorialFactorization","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ninst‚úù : W‚ÇÅ.HasFunctorialFactorization W‚ÇÇ\n‚ä¢ W‚ÇÅ.HasFactorization W‚ÇÇ","decl":"instance [HasFunctorialFactorization W‚ÇÅ W‚ÇÇ] : HasFactorization W‚ÇÅ W‚ÇÇ where\n  nonempty_mapFactorizationData f := ‚ü®(functorialFactorizationData W‚ÇÅ W‚ÇÇ).factorizationData f‚ü©\n\n"}
{"name":"CategoryTheory.MorphismProperty.instHasFunctorialFactorizationFunctorFunctorCategory","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_1} C\nW‚ÇÅ W‚ÇÇ : CategoryTheory.MorphismProperty C\ninst‚úù¬π : W‚ÇÅ.HasFunctorialFactorization W‚ÇÇ\nJ : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} J\n‚ä¢ (W‚ÇÅ.functorCategory J).HasFunctorialFactorization (W‚ÇÇ.functorCategory J)","decl":"instance [HasFunctorialFactorization W‚ÇÅ W‚ÇÇ] (J : Type*) [Category J] :\n    HasFunctorialFactorization (W‚ÇÅ.functorCategory J) (W‚ÇÇ.functorCategory J) :=\n  ‚ü®‚ü®(functorialFactorizationData W‚ÇÅ W‚ÇÇ).functorCategory J‚ü©‚ü©\n\n"}
