{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\ninst✝² : SizeOf C\ninst✝¹ : ⦃X Y : C⦄ → (x : Quiver.Hom X Y) → SizeOf (W₁ x)\ninst✝ : ⦃X Y : C⦄ → (x : Quiver.Hom X Y) → SizeOf (W₂ x)\nZ : C\ni : Quiver.Hom X Z\np : Quiver.Hom Z Y\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) f) _auto✝\nhi : W₁ i\nhp : W₂ p\n⊢ Eq (SizeOf.sizeOf { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Z)) (SizeOf.sizeOf i)) (SizeOf.sizeOf p)) (SizeOf.sizeOf fac)) (SizeOf.sizeOf hi)) (SizeOf.sizeOf hp))","decl":"/-- Given two classes of morphisms `W₁` and `W₂` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ⟶ Y` as `i ≫ p` with\n`W₁ i` and `W₂ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ⟶ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ⟶ Z\n  /-- the second morphism in the factorization -/\n  p : Z ⟶ Y\n  fac : i ≫ p = f := by aesop_cat\n  hi : W₁ i\n  hp : W₂ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\ni✝ : Quiver.Hom X Z✝\np✝ : Quiver.Hom Z✝ Y\nfac✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i✝ p✝) f) _auto✝\nhi✝ : W₁ i✝\nhp✝ : W₂ p✝\nZ : C\ni : Quiver.Hom X Z\np : Quiver.Hom Z Y\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) f) _auto✝\nhi : W₁ i\nhp : W₂ p\n⊢ Eq (Eq { Z := Z✝, i := i✝, p := p✝, fac := fac✝, hi := hi✝, hp := hp✝ } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (And (Eq Z✝ Z) (And (HEq i✝ i) (HEq p✝ p)))","decl":"/-- Given two classes of morphisms `W₁` and `W₂` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ⟶ Y` as `i ≫ p` with\n`W₁ i` and `W₂ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ⟶ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ⟶ Z\n  /-- the second morphism in the factorization -/\n  p : Z ⟶ Y\n  fac : i ≫ p = f := by aesop_cat\n  hi : W₁ i\n  hp : W₂ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.fac","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W₁.MapFactorizationData W₂ f\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i self.p) f","decl":"/-- Given two classes of morphisms `W₁` and `W₂` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ⟶ Y` as `i ≫ p` with\n`W₁ i` and `W₂ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ⟶ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ⟶ Z\n  /-- the second morphism in the factorization -/\n  p : Z ⟶ Y\n  fac : i ≫ p = f := by aesop_cat\n  hi : W₁ i\n  hp : W₂ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nZ✝ : C\ni✝ : Quiver.Hom X Z✝\np✝ : Quiver.Hom Z✝ Y\nfac✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i✝ p✝) f) _auto✝\nhi✝ : W₁ i✝\nhp✝ : W₂ p✝\nZ : C\ni : Quiver.Hom X Z\np : Quiver.Hom Z Y\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) f) _auto✝\nhi : W₁ i\nhp : W₂ p\nx✝ : Eq { Z := Z✝, i := i✝, p := p✝, fac := fac✝, hi := hi✝, hp := hp✝ } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }\n⊢ And (Eq Z✝ Z) (And (HEq i✝ i) (HEq p✝ p))","decl":"/-- Given two classes of morphisms `W₁` and `W₂` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ⟶ Y` as `i ≫ p` with\n`W₁ i` and `W₂ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ⟶ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ⟶ Z\n  /-- the second morphism in the factorization -/\n  p : Z ⟶ Y\n  fac : i ≫ p = f := by aesop_cat\n  hi : W₁ i\n  hp : W₂ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.hp","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W₁.MapFactorizationData W₂ f\n⊢ W₂ self.p","decl":"/-- Given two classes of morphisms `W₁` and `W₂` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ⟶ Y` as `i ≫ p` with\n`W₁ i` and `W₂ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ⟶ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ⟶ Z\n  /-- the second morphism in the factorization -/\n  p : Z ⟶ Y\n  fac : i ≫ p = f := by aesop_cat\n  hi : W₁ i\n  hp : W₂ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.hi","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W₁.MapFactorizationData W₂ f\n⊢ W₁ self.i","decl":"/-- Given two classes of morphisms `W₁` and `W₂` on a category `C`, this is\nthe data of the factorization of a morphism `f : X ⟶ Y` as `i ≫ p` with\n`W₁ i` and `W₂ p`. -/\nstructure MapFactorizationData {X Y : C} (f : X ⟶ Y) where\n  /-- the intermediate object in the factorization -/\n  Z : C\n  /-- the first morphism in the factorization -/\n  i : X ⟶ Z\n  /-- the second morphism in the factorization -/\n  p : Z ⟶ Y\n  fac : i ≫ p = f := by aesop_cat\n  hi : W₁ i\n  hp : W₂ p\n\n"}
{"name":"CategoryTheory.MorphismProperty.MapFactorizationData.fac_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nX Y : C\nf : Quiver.Hom X Y\nself : W₁.MapFactorizationData W₂ f\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp self.p h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"attribute [reassoc (attr := simp)] MapFactorizationData.fac\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasFactorization.nonempty_mapFactorizationData","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nself : W₁.HasFactorization W₂\nX Y : C\nf : Quiver.Hom X Y\n⊢ Nonempty (W₁.MapFactorizationData W₂ f)","decl":"/-- The factorization axiom for two classes of morphisms `W₁` and `W₂` in a category `C`. It\nasserts that any morphism can be factored as a morphism in `W₁` followed by a morphism\nin `W₂`. -/\nclass HasFactorization : Prop where\n  nonempty_mapFactorizationData {X Y : C} (f : X ⟶ Y) : Nonempty (MapFactorizationData W₁ W₂ f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.comp_eq_top_iff","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\n⊢ Iff (Eq (W₁.comp W₂) Top.top) (W₁.HasFactorization W₂)","decl":"lemma comp_eq_top_iff : W₁.comp W₂ = ⊤ ↔ HasFactorization W₁ W₂ := by\n  constructor\n  · intro h\n    refine ⟨fun f => ?_⟩\n    have : W₁.comp W₂ f := by simp only [h, top_apply]\n    exact ⟨this.some⟩\n  · intro\n    ext X Y f\n    simp only [top_apply, iff_true]\n    exact ⟨factorizationData W₁ W₂ f⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mk.injEq","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nZ✝ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni✝ : Quiver.Hom CategoryTheory.Arrow.leftFunc Z✝\np✝ : Quiver.Hom Z✝ CategoryTheory.Arrow.rightFunc\nfac✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i✝ p✝) CategoryTheory.Arrow.leftToRight) _auto✝\nhi✝ : ∀ (f : CategoryTheory.Arrow C), W₁ (i✝.app f)\nhp✝ : ∀ (f : CategoryTheory.Arrow C), W₂ (p✝.app f)\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni : Quiver.Hom CategoryTheory.Arrow.leftFunc Z\np : Quiver.Hom Z CategoryTheory.Arrow.rightFunc\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) CategoryTheory.Arrow.leftToRight) _auto✝\nhi : ∀ (f : CategoryTheory.Arrow C), W₁ (i.app f)\nhp : ∀ (f : CategoryTheory.Arrow C), W₂ (p.app f)\n⊢ Eq (Eq { Z := Z✝, i := i✝, p := p✝, fac := fac✝, hi := hi✝, hp := hp✝ } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (And (Eq Z✝ Z) (And (HEq i✝ i) (HEq p✝ p)))","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W₁`\nfollowed by a morphism in `W₂`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ⥤ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ⟶ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ⟶ Arrow.rightFunc\n  fac : i ≫ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W₁ (i.app f)\n  hp (f : Arrow C) : W₂ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.hi","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nself : W₁.FunctorialFactorizationData W₂\nf : CategoryTheory.Arrow C\n⊢ W₁ (self.i.app f)","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W₁`\nfollowed by a morphism in `W₂`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ⥤ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ⟶ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ⟶ Arrow.rightFunc\n  fac : i ≫ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W₁ (i.app f)\n  hp (f : Arrow C) : W₂ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ninst✝² : SizeOf C\ninst✝¹ : ⦃X Y : C⦄ → (x : Quiver.Hom X Y) → SizeOf (W₁ x)\ninst✝ : ⦃X Y : C⦄ → (x : Quiver.Hom X Y) → SizeOf (W₂ x)\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni : Quiver.Hom CategoryTheory.Arrow.leftFunc Z\np : Quiver.Hom Z CategoryTheory.Arrow.rightFunc\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) CategoryTheory.Arrow.leftToRight) _auto✝\nhi : ∀ (f : CategoryTheory.Arrow C), W₁ (i.app f)\nhp : ∀ (f : CategoryTheory.Arrow C), W₂ (p.app f)\n⊢ Eq (SizeOf.sizeOf { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Z)) (SizeOf.sizeOf i)) (SizeOf.sizeOf p)) (SizeOf.sizeOf fac))","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W₁`\nfollowed by a morphism in `W₂`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ⥤ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ⟶ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ⟶ Arrow.rightFunc\n  fac : i ≫ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W₁ (i.app f)\n  hp (f : Arrow C) : W₂ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.hp","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nself : W₁.FunctorialFactorizationData W₂\nf : CategoryTheory.Arrow C\n⊢ W₂ (self.p.app f)","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W₁`\nfollowed by a morphism in `W₂`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ⥤ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ⟶ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ⟶ Arrow.rightFunc\n  fac : i ≫ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W₁ (i.app f)\n  hp (f : Arrow C) : W₂ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nself : W₁.FunctorialFactorizationData W₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i self.p) CategoryTheory.Arrow.leftToRight","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W₁`\nfollowed by a morphism in `W₂`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ⥤ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ⟶ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ⟶ Arrow.rightFunc\n  fac : i ≫ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W₁ (i.app f)\n  hp (f : Arrow C) : W₂ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mk.inj","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nZ✝ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni✝ : Quiver.Hom CategoryTheory.Arrow.leftFunc Z✝\np✝ : Quiver.Hom Z✝ CategoryTheory.Arrow.rightFunc\nfac✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp i✝ p✝) CategoryTheory.Arrow.leftToRight) _auto✝\nhi✝ : ∀ (f : CategoryTheory.Arrow C), W₁ (i✝.app f)\nhp✝ : ∀ (f : CategoryTheory.Arrow C), W₂ (p✝.app f)\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\ni : Quiver.Hom CategoryTheory.Arrow.leftFunc Z\np : Quiver.Hom Z CategoryTheory.Arrow.rightFunc\nfac : autoParam (Eq (CategoryTheory.CategoryStruct.comp i p) CategoryTheory.Arrow.leftToRight) _auto✝\nhi : ∀ (f : CategoryTheory.Arrow C), W₁ (i.app f)\nhp : ∀ (f : CategoryTheory.Arrow C), W₂ (p.app f)\nx✝ : Eq { Z := Z✝, i := i✝, p := p✝, fac := fac✝, hi := hi✝, hp := hp✝ } { Z := Z, i := i, p := p, fac := fac, hi := hi, hp := hp }\n⊢ And (Eq Z✝ Z) (And (HEq i✝ i) (HEq p✝ p))","decl":"/-- The data of a functorial factorization of any morphism in `C` as a morphism in `W₁`\nfollowed by a morphism in `W₂`. -/\nstructure FunctorialFactorizationData where\n  /-- the intermediate objects in the factorizations -/\n  Z : Arrow C ⥤ C\n  /-- the first morphism in the factorizations -/\n  i : Arrow.leftFunc ⟶ Z\n  /-- the second morphism in the factorizations -/\n  p : Z ⟶ Arrow.rightFunc\n  fac : i ≫ p = Arrow.leftToRight := by aesop_cat\n  hi (f : Arrow C) : W₁ (i.app f)\n  hp (f : Arrow C) : W₂ (p.app f)\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nself : W₁.FunctorialFactorizationData W₂\nZ : CategoryTheory.Functor (CategoryTheory.Arrow C) C\nh : Quiver.Hom CategoryTheory.Arrow.rightFunc Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.i (CategoryTheory.CategoryStruct.comp self.p h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Arrow.leftToRight h)","decl":"attribute [reassoc (attr := simp)] fac\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac_app_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nf : CategoryTheory.Arrow C\nZ : C\nh : Quiver.Hom (CategoryTheory.Arrow.rightFunc.obj f) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.i.app f) (CategoryTheory.CategoryStruct.comp (data.p.app f) h)) (CategoryTheory.CategoryStruct.comp f.hom h)","decl":"@[reassoc (attr := simp)]\nlemma fac_app {f : Arrow C} : data.i.app f ≫ data.p.app f = f.hom := by\n  rw [← NatTrans.comp_app, fac,Arrow.leftToRight_app]\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.fac_app","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nf : CategoryTheory.Arrow C\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.i.app f) (data.p.app f)) f.hom","decl":"@[reassoc (attr := simp)]\nlemma fac_app {f : Arrow C} : data.i.app f ≫ data.p.app f = f.hom := by\n  rw [← NatTrans.comp_app, fac,Arrow.leftToRight_app]\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.i_mapZ_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nφ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nZ : C\nh : Quiver.Hom (data.factorizationData g).Z Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.factorizationData f).i (CategoryTheory.CategoryStruct.comp (data.mapZ φ) h)) (CategoryTheory.CategoryStruct.comp φ.left (CategoryTheory.CategoryStruct.comp (data.factorizationData g).i h))","decl":"@[reassoc (attr := simp)]\nlemma i_mapZ :\n    (data.factorizationData f).i ≫ data.mapZ φ = φ.left ≫ (data.factorizationData g).i :=\n  (data.i.naturality φ).symm\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.i_mapZ","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nφ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.factorizationData f).i (data.mapZ φ)) (CategoryTheory.CategoryStruct.comp φ.left (data.factorizationData g).i)","decl":"@[reassoc (attr := simp)]\nlemma i_mapZ :\n    (data.factorizationData f).i ≫ data.mapZ φ = φ.left ≫ (data.factorizationData g).i :=\n  (data.i.naturality φ).symm\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_p","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nφ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.mapZ φ) (data.factorizationData g).p) (CategoryTheory.CategoryStruct.comp (data.factorizationData f).p φ.right)","decl":"@[reassoc (attr := simp)]\nlemma mapZ_p :\n    data.mapZ φ ≫ (data.factorizationData g).p = (data.factorizationData f).p ≫ φ.right :=\n  data.p.naturality φ\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_p_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nφ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nZ : C\nh : Quiver.Hom Y' Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.mapZ φ) (CategoryTheory.CategoryStruct.comp (data.factorizationData g).p h)) (CategoryTheory.CategoryStruct.comp (data.factorizationData f).p (CategoryTheory.CategoryStruct.comp φ.right h))","decl":"@[reassoc (attr := simp)]\nlemma mapZ_p :\n    data.mapZ φ ≫ (data.factorizationData g).p = (data.factorizationData f).p ≫ φ.right :=\n  data.p.naturality φ\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_id","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (data.mapZ (CategoryTheory.CategoryStruct.id (CategoryTheory.Arrow.mk f))) (CategoryTheory.CategoryStruct.id (data.factorizationData f).Z)","decl":"variable (f) in\n@[simp]\nlemma mapZ_id : data.mapZ (𝟙 (Arrow.mk f)) = 𝟙 _ :=\n  data.Z.map_id _\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_comp_assoc","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nφ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nX'' Y'' : C\nh✝ : Quiver.Hom X'' Y''\nψ : Quiver.Hom (CategoryTheory.Arrow.mk g) (CategoryTheory.Arrow.mk h✝)\nZ : C\nh : Quiver.Hom (data.factorizationData h✝).Z Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (data.mapZ (CategoryTheory.CategoryStruct.comp φ ψ)) h) (CategoryTheory.CategoryStruct.comp (data.mapZ φ) (CategoryTheory.CategoryStruct.comp (data.mapZ ψ) h))","decl":"@[reassoc, simp]\nlemma mapZ_comp {X'' Y'' : C} {h : X'' ⟶ Y''} (ψ : Arrow.mk g ⟶ Arrow.mk h) :\n    data.mapZ (φ ≫ ψ) = data.mapZ φ ≫ data.mapZ ψ :=\n  data.Z.map_comp _ _\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.mapZ_comp","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nX Y X' Y' : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X' Y'\nφ : Quiver.Hom (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk g)\nX'' Y'' : C\nh : Quiver.Hom X'' Y''\nψ : Quiver.Hom (CategoryTheory.Arrow.mk g) (CategoryTheory.Arrow.mk h)\n⊢ Eq (data.mapZ (CategoryTheory.CategoryStruct.comp φ ψ)) (CategoryTheory.CategoryStruct.comp (data.mapZ φ) (data.mapZ ψ))","decl":"@[reassoc, simp]\nlemma mapZ_comp {X'' Y'' : C} {h : X'' ⟶ Y''} (ψ : Arrow.mk g ⟶ Arrow.mk h) :\n    data.mapZ (φ ≫ ψ) = data.mapZ φ ≫ data.mapZ ψ :=\n  data.Z.map_comp _ _\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z_obj_map","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nJ : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} J\nf : CategoryTheory.Arrow (CategoryTheory.Functor J C)\nX✝ Y✝ : J\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z data J).obj f).map φ) (data.mapZ { left := f.left.map φ, right := f.right.map φ, w := ⋯ })","decl":"/-- Auxiliary definition for `FunctorialFactorizationData.functorCategory`. -/\n@[simps]\ndef functorCategory.Z : Arrow (J ⥤ C) ⥤ J ⥤ C where\n  obj f :=\n    { obj := fun j => (data.factorizationData (f.hom.app j)).Z\n      map := fun φ => data.mapZ\n        { left := f.left.map φ\n          right := f.right.map φ }\n      map_id := fun j => by\n        dsimp\n        rw [← data.mapZ_id (f.hom.app j)]\n        congr <;> simp\n      map_comp := fun _ _ => by\n        dsimp\n        rw [← data.mapZ_comp]\n        congr <;> simp }\n  map τ :=\n    { app := fun j => data.mapZ\n        { left := τ.left.app j\n          right := τ.right.app j\n          w := congr_app τ.w j }\n      naturality := fun _ _ α => by\n        dsimp\n        rw [← data.mapZ_comp, ← data.mapZ_comp]\n        congr 1\n        ext <;> simp }\n  map_id f := by\n    ext j\n    dsimp\n    rw [← data.mapZ_id]\n    congr 1\n  map_comp f g := by\n    ext j\n    dsimp\n    rw [← data.mapZ_comp]\n    congr 1\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z_map_app","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nJ : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} J\nX✝ Y✝ : CategoryTheory.Arrow (CategoryTheory.Functor J C)\nτ : Quiver.Hom X✝ Y✝\nj : J\n⊢ Eq (((CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z data J).map τ).app j) (data.mapZ { left := τ.left.app j, right := τ.right.app j, w := ⋯ })","decl":"/-- Auxiliary definition for `FunctorialFactorizationData.functorCategory`. -/\n@[simps]\ndef functorCategory.Z : Arrow (J ⥤ C) ⥤ J ⥤ C where\n  obj f :=\n    { obj := fun j => (data.factorizationData (f.hom.app j)).Z\n      map := fun φ => data.mapZ\n        { left := f.left.map φ\n          right := f.right.map φ }\n      map_id := fun j => by\n        dsimp\n        rw [← data.mapZ_id (f.hom.app j)]\n        congr <;> simp\n      map_comp := fun _ _ => by\n        dsimp\n        rw [← data.mapZ_comp]\n        congr <;> simp }\n  map τ :=\n    { app := fun j => data.mapZ\n        { left := τ.left.app j\n          right := τ.right.app j\n          w := congr_app τ.w j }\n      naturality := fun _ _ α => by\n        dsimp\n        rw [← data.mapZ_comp, ← data.mapZ_comp]\n        congr 1\n        ext <;> simp }\n  map_id f := by\n    ext j\n    dsimp\n    rw [← data.mapZ_id]\n    congr 1\n  map_comp f g := by\n    ext j\n    dsimp\n    rw [← data.mapZ_comp]\n    congr 1\n\n"}
{"name":"CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z_obj_obj","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_3, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ndata : W₁.FunctorialFactorizationData W₂\nJ : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} J\nf : CategoryTheory.Arrow (CategoryTheory.Functor J C)\nj : J\n⊢ Eq (((CategoryTheory.MorphismProperty.FunctorialFactorizationData.functorCategory.Z data J).obj f).obj j) (data.factorizationData (f.hom.app j)).Z","decl":"/-- Auxiliary definition for `FunctorialFactorizationData.functorCategory`. -/\n@[simps]\ndef functorCategory.Z : Arrow (J ⥤ C) ⥤ J ⥤ C where\n  obj f :=\n    { obj := fun j => (data.factorizationData (f.hom.app j)).Z\n      map := fun φ => data.mapZ\n        { left := f.left.map φ\n          right := f.right.map φ }\n      map_id := fun j => by\n        dsimp\n        rw [← data.mapZ_id (f.hom.app j)]\n        congr <;> simp\n      map_comp := fun _ _ => by\n        dsimp\n        rw [← data.mapZ_comp]\n        congr <;> simp }\n  map τ :=\n    { app := fun j => data.mapZ\n        { left := τ.left.app j\n          right := τ.right.app j\n          w := congr_app τ.w j }\n      naturality := fun _ _ α => by\n        dsimp\n        rw [← data.mapZ_comp, ← data.mapZ_comp]\n        congr 1\n        ext <;> simp }\n  map_id f := by\n    ext j\n    dsimp\n    rw [← data.mapZ_id]\n    congr 1\n  map_comp f g := by\n    ext j\n    dsimp\n    rw [← data.mapZ_comp]\n    congr 1\n\n"}
{"name":"CategoryTheory.MorphismProperty.HasFunctorialFactorization.nonempty_functorialFactorizationData","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\nself : W₁.HasFunctorialFactorization W₂\n⊢ Nonempty (W₁.FunctorialFactorizationData W₂)","decl":"/-- The functorial factorization axiom for two classes of morphisms `W₁` and `W₂` in a\ncategory `C`. It asserts that any morphism can be factored in a functorial manner\nas a morphism in `W₁` followed by a morphism in `W₂`. -/\nclass HasFunctorialFactorization : Prop where\n  nonempty_functorialFactorizationData : Nonempty (FunctorialFactorizationData W₁ W₂)\n\n"}
{"name":"CategoryTheory.MorphismProperty.instHasFactorizationOfHasFunctorialFactorization","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ninst✝ : W₁.HasFunctorialFactorization W₂\n⊢ W₁.HasFactorization W₂","decl":"instance [HasFunctorialFactorization W₁ W₂] : HasFactorization W₁ W₂ where\n  nonempty_mapFactorizationData f := ⟨(functorialFactorizationData W₁ W₂).factorizationData f⟩\n\n"}
{"name":"CategoryTheory.MorphismProperty.instHasFunctorialFactorizationFunctorFunctorCategory","module":"Mathlib.CategoryTheory.MorphismProperty.Factorization","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_3, u_1} C\nW₁ W₂ : CategoryTheory.MorphismProperty C\ninst✝¹ : W₁.HasFunctorialFactorization W₂\nJ : Type u_2\ninst✝ : CategoryTheory.Category.{u_4, u_2} J\n⊢ (W₁.functorCategory J).HasFunctorialFactorization (W₂.functorCategory J)","decl":"instance [HasFunctorialFactorization W₁ W₂] (J : Type*) [Category J] :\n    HasFunctorialFactorization (W₁.functorCategory J) (W₂.functorCategory J) :=\n  ⟨⟨(functorialFactorizationData W₁ W₂).functorCategory J⟩⟩\n\n"}
