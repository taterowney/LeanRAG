{"name":"CategoryTheory.ShortComplex.zero_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.HasForget C\ninst✝² : CategoryTheory.HasForget₂ C Ab\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : (CategoryTheory.forget₂ C Ab).PreservesZeroMorphisms\nS : CategoryTheory.ShortComplex C\nx : ↑((CategoryTheory.forget₂ C Ab).obj S.X₁)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.g)) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.f)) x)) 0","decl":"@[simp]\nlemma ShortComplex.zero_apply\n    [Limits.HasZeroMorphisms C] [(forget₂ C Ab).PreservesZeroMorphisms]\n    (S : ShortComplex C) (x : (forget₂ C Ab).obj S.X₁) :\n    ((forget₂ C Ab).map S.g) (((forget₂ C Ab).map S.f) x) = 0 := by\n  rw [← ConcreteCategory.comp_apply, ← Functor.map_comp, S.zero, Functor.map_zero]\n  rfl\n\n"}
{"name":"CategoryTheory.Preadditive.mono_iff_injective","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map f)))","decl":"lemma Preadditive.mono_iff_injective {X Y : C} (f : X ⟶ Y) :\n    Mono f ↔ Function.Injective ((forget₂ C Ab).map f) := by\n  rw [← AddCommGrp.mono_iff_injective]\n  constructor\n  · intro\n    infer_instance\n  · apply Functor.mono_of_mono_map\n\n"}
{"name":"CategoryTheory.Preadditive.mono_iff_injective'","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Mono f) (Function.Injective ((CategoryTheory.forget C).map f))","decl":"lemma Preadditive.mono_iff_injective' {X Y : C} (f : X ⟶ Y) :\n    Mono f ↔ Function.Injective ((forget C).map f) := by\n  simp only [mono_iff_injective, ← CategoryTheory.mono_iff_injective]\n  apply (MorphismProperty.monomorphisms (Type w)).arrow_mk_iso_iff\n  have e : forget₂ C Ab ⋙ forget Ab ≅ forget C := eqToIso (HasForget₂.forget_comp)\n  exact Arrow.isoOfNatIso e (Arrow.mk f)\n\n"}
{"name":"CategoryTheory.Preadditive.epi_iff_surjective","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map f)))","decl":"lemma Preadditive.epi_iff_surjective {X Y : C} (f : X ⟶ Y) :\n    Epi f ↔ Function.Surjective ((forget₂ C Ab).map f) := by\n  rw [← AddCommGrp.epi_iff_surjective]\n  constructor\n  · intro\n    infer_instance\n  · apply Functor.epi_of_epi_map\n\n"}
{"name":"CategoryTheory.Preadditive.epi_iff_surjective'","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Iff (CategoryTheory.Epi f) (Function.Surjective ((CategoryTheory.forget C).map f))","decl":"lemma Preadditive.epi_iff_surjective' {X Y : C} (f : X ⟶ Y) :\n    Epi f ↔ Function.Surjective ((forget C).map f) := by\n  simp only [epi_iff_surjective, ← CategoryTheory.epi_iff_surjective]\n  apply (MorphismProperty.epimorphisms (Type w)).arrow_mk_iso_iff\n  have e : forget₂ C Ab ⋙ forget Ab ≅ forget C := eqToIso (HasForget₂.forget_comp)\n  exact Arrow.isoOfNatIso e (Arrow.mk f)\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_exact_map_forget₂","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (S.map (CategoryTheory.forget₂ C Ab)).Exact","decl":"lemma exact_iff_exact_map_forget₂ [S.HasHomology] :\n    S.Exact ↔ (S.map (forget₂ C Ab)).Exact :=\n  (S.exact_map_iff_of_faithful (forget₂ C Ab)).symm\n\n"}
{"name":"CategoryTheory.ShortComplex.exact_iff_of_hasForget","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Iff S.Exact (∀ (x₂ : ↑((CategoryTheory.forget₂ C Ab).obj S.X₂)), Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.g)) x₂) 0 → Exists fun x₁ => Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.f)) x₁) x₂)","decl":"lemma exact_iff_of_hasForget [S.HasHomology] :\n    S.Exact ↔ ∀ (x₂ : (forget₂ C Ab).obj S.X₂) (_ : ((forget₂ C Ab).map S.g) x₂ = 0),\n      ∃ (x₁ : (forget₂ C Ab).obj S.X₁), ((forget₂ C Ab).map S.f) x₁ = x₂ := by\n  rw [S.exact_iff_exact_map_forget₂, ab_exact_iff]\n  rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.injective_f","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nhS : S.ShortExact\n⊢ Function.Injective ⇑(CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.f))","decl":"lemma ShortExact.injective_f [HasZeroObject C] (hS : S.ShortExact) :\n    Function.Injective ((forget₂ C Ab).map S.f) := by\n  rw [← Preadditive.mono_iff_injective]\n  exact hS.mono_f\n\n"}
{"name":"CategoryTheory.ShortComplex.ShortExact.surjective_g","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nS : CategoryTheory.ShortComplex C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\nhS : S.ShortExact\n⊢ Function.Surjective ⇑(CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.g))","decl":"lemma ShortExact.surjective_g [HasZeroObject C] (hS : S.ShortExact) :\n    Function.Surjective ((forget₂ C Ab).map S.g) := by\n  rw [← Preadditive.epi_iff_surjective]\n  exact hS.epi_g\n\n"}
{"name":"CategoryTheory.ShortComplex.i_cyclesMk","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.HasForget C\ninst✝⁴ : CategoryTheory.HasForget₂ C Ab\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : (CategoryTheory.forget₂ C Ab).Additive\ninst✝¹ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nx₂ : ↑((CategoryTheory.forget₂ C Ab).obj S.X₂)\nhx₂ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.g)) x₂) 0\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map S.iCycles)) (S.cyclesMk x₂ hx₂)) x₂","decl":"@[simp]\nlemma i_cyclesMk [S.HasHomology] (x₂ : (forget₂ C Ab).obj S.X₂)\n    (hx₂ : ((forget₂ C Ab).map S.g) x₂ = 0) :\n    (forget₂ C Ab).map S.iCycles (S.cyclesMk x₂ hx₂) = x₂ := by\n  dsimp [cyclesMk]\n  erw [← ConcreteCategory.comp_apply, S.mapCyclesIso_hom_iCycles (forget₂ C Ab),\n    ← ConcreteCategory.comp_apply, abCyclesIso_inv_apply_iCycles]\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.δ_apply","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.HasForget₂ C Ab\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : (CategoryTheory.forget₂ C Ab).Additive\ninst✝ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nD : CategoryTheory.ShortComplex.SnakeInput C\nx₃ : (CategoryTheory.forget C).obj D.L₀.X₃\nx₂ : (CategoryTheory.forget C).obj D.L₁.X₂\nx₁ : (CategoryTheory.forget C).obj D.L₂.X₁\nh₂ : Eq (D.L₁.g x₂) (D.v₀₁.τ₃ x₃)\nh₁ : Eq (D.L₂.f x₁) (D.v₁₂.τ₂ x₂)\n⊢ Eq (D.δ x₃) (D.v₂₃.τ₁ x₁)","decl":"/-- This lemma allows the computation of the connecting homomorphism\n`D.δ` when `D : SnakeInput C` and `C` is a concrete category. -/\nlemma δ_apply (x₃ : D.L₀.X₃) (x₂ : D.L₁.X₂) (x₁ : D.L₂.X₁)\n    (h₂ : D.L₁.g x₂ = D.v₀₁.τ₃ x₃) (h₁ : D.L₂.f x₁ = D.v₁₂.τ₂ x₂) :\n    D.δ x₃ = D.v₂₃.τ₁ x₁ := by\n  have := (forget₂ C Ab).preservesFiniteLimits_of_preservesHomology\n  have : PreservesFiniteLimits (forget C) := by\n    have : forget₂ C Ab ⋙ forget Ab = forget C := HasForget₂.forget_comp\n    simpa only [← this] using comp_preservesFiniteLimits _ _\n  have eq := congr_fun ((forget C).congr_map D.snd_δ)\n    (Limits.Concrete.pullbackMk D.L₁.g D.v₀₁.τ₃ x₂ x₃ h₂)\n  have eq₁ := Concrete.pullbackMk_fst D.L₁.g D.v₀₁.τ₃ x₂ x₃ h₂\n  have eq₂ := Concrete.pullbackMk_snd D.L₁.g D.v₀₁.τ₃ x₂ x₃ h₂\n  dsimp [DFunLike.coe] at eq₁ eq₂\n  rw [Functor.map_comp, types_comp_apply, FunctorToTypes.map_comp_apply] at eq\n  rw [eq₂] at eq\n  refine eq.trans (congr_arg ((forget C).map D.v₂₃.τ₁) ?_)\n  apply (Preadditive.mono_iff_injective' D.L₂.f).1 inferInstance\n  rw [← FunctorToTypes.map_comp_apply, φ₁_L₂_f]\n  dsimp [φ₂]\n  rw [Functor.map_comp, types_comp_apply, eq₁]\n  exact h₁.symm\n\n"}
{"name":"CategoryTheory.ShortComplex.SnakeInput.δ_apply'","module":"Mathlib.Algebra.Homology.ShortComplex.ConcreteCategory","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.HasForget C\ninst✝³ : CategoryTheory.HasForget₂ C Ab\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : (CategoryTheory.forget₂ C Ab).Additive\ninst✝ : (CategoryTheory.forget₂ C Ab).PreservesHomology\nD : CategoryTheory.ShortComplex.SnakeInput C\nx₃ : ↑((CategoryTheory.forget₂ C Ab).obj D.L₀.X₃)\nx₂ : ↑((CategoryTheory.forget₂ C Ab).obj D.L₁.X₂)\nx₁ : ↑((CategoryTheory.forget₂ C Ab).obj D.L₂.X₁)\nh₂ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map D.L₁.g)) x₂) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map D.v₀₁.τ₃)) x₃)\nh₁ : Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map D.L₂.f)) x₁) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map D.v₁₂.τ₂)) x₂)\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map D.δ)) x₃) ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.forget₂ C Ab).map D.v₂₃.τ₁)) x₁)","decl":"/-- This lemma allows the computation of the connecting homomorphism\n`D.δ` when `D : SnakeInput C` and `C` is a concrete category. -/\nlemma δ_apply' (x₃ : (forget₂ C Ab).obj D.L₀.X₃)\n    (x₂ : (forget₂ C Ab).obj D.L₁.X₂) (x₁ : (forget₂ C Ab).obj D.L₂.X₁)\n    (h₂ : (forget₂ C Ab).map D.L₁.g x₂ = (forget₂ C Ab).map D.v₀₁.τ₃ x₃)\n    (h₁ : (forget₂ C Ab).map D.L₂.f x₁ = (forget₂ C Ab).map D.v₁₂.τ₂ x₂) :\n    (forget₂ C Ab).map D.δ x₃ = (forget₂ C Ab).map D.v₂₃.τ₁ x₁ := by\n  have e : forget₂ C Ab ⋙ forget Ab ≅ forget C := eqToIso (HasForget₂.forget_comp)\n  apply (mono_iff_injective (e.hom.app _)).1 inferInstance\n  refine (congr_hom (e.hom.naturality D.δ) x₃).trans\n    ((D.δ_apply (e.hom.app _ x₃) (e.hom.app _ x₂) (e.hom.app _ x₁) ?_ ?_ ).trans\n    (congr_hom (e.hom.naturality D.v₂₃.τ₁).symm x₁))\n  · refine ((congr_hom (e.hom.naturality D.L₁.g) x₂).symm.trans ?_).trans\n      (congr_hom (e.hom.naturality D.v₀₁.τ₃) x₃)\n    dsimp\n    rw [CategoryTheory.comp_apply, CategoryTheory.comp_apply]\n    erw [h₂]\n    rfl\n  · refine ((congr_hom (e.hom.naturality D.L₂.f) x₁).symm.trans ?_).trans\n      (congr_hom (e.hom.naturality D.v₁₂.τ₂) x₂)\n    dsimp\n    rw [CategoryTheory.comp_apply, CategoryTheory.comp_apply]\n    erw [h₁]\n    rfl\n\n"}
