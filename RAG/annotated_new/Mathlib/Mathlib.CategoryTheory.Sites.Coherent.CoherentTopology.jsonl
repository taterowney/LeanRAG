{"name":"CategoryTheory.coherentTopology.mem_sieves_of_hasEffectiveEpiFamily","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Precoherent C\nX : C\nS : CategoryTheory.Sieve X\na✝ : Exists fun α => Exists fun x => Exists fun Y => Exists fun π => And (CategoryTheory.EffectiveEpiFamily Y π) (∀ (a : α), S.arrows (π a))\n⊢ Membership.mem ((CategoryTheory.coherentTopology C) X) S","decl":"/--\nFor a precoherent category, any sieve that contains an `EffectiveEpiFamily` is a sieve of the\ncoherent topology.\nNote: This is one direction of `mem_sieves_iff_hasEffectiveEpiFamily`, but is needed for the proof.\n-/\ntheorem coherentTopology.mem_sieves_of_hasEffectiveEpiFamily (S : Sieve X) :\n    (∃ (α : Type) (_ : Finite α) (Y : α → C) (π : (a : α) → (Y a ⟶ X)),\n      EffectiveEpiFamily Y π ∧ (∀ a : α, (S.arrows) (π a)) ) →\n        (S ∈ (coherentTopology C) X) := by\n  intro ⟨α, _, Y, π, hπ⟩\n  apply (coherentCoverage C).mem_toGrothendieck_sieves_of_superset (R := Presieve.ofArrows Y π)\n  · exact fun _ _ h ↦ by cases h; exact hπ.2 _\n  · exact ⟨_, inferInstance, Y, π, rfl, hπ.1⟩\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.transitive_of_finite","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Precoherent C\nX : C\nα : Type\ninst✝¹ : Finite α\nY : α → C\nπ : (a : α) → Quiver.Hom (Y a) X\nh : CategoryTheory.EffectiveEpiFamily Y π\nβ : α → Type\ninst✝ : ∀ (a : α), Finite (β a)\nY_n : (a : α) → β a → C\nπ_n : (a : α) → (b : β a) → Quiver.Hom (Y_n a b) (Y a)\nH : ∀ (a : α), CategoryTheory.EffectiveEpiFamily (Y_n a) (π_n a)\n⊢ CategoryTheory.EffectiveEpiFamily (fun c => Y_n c.fst c.snd) fun c => CategoryTheory.CategoryStruct.comp (π_n c.fst c.snd) (π c.fst)","decl":"/--\nEffective epi families in a precoherent category are transitive, in the sense that an\n`EffectiveEpiFamily` and an `EffectiveEpiFamily` over each member, the composition is an\n`EffectiveEpiFamily`.\nNote: The finiteness condition is an artifact of the proof and is probably unnecessary.\n-/\ntheorem EffectiveEpiFamily.transitive_of_finite {α : Type} [Finite α] {Y : α → C}\n    (π : (a : α) → (Y a ⟶ X)) (h : EffectiveEpiFamily Y π) {β : α → Type} [∀ (a : α), Finite (β a)]\n    {Y_n : (a : α) → β a → C} (π_n : (a : α) → (b : β a) → (Y_n a b ⟶ Y a))\n    (H : ∀ a, EffectiveEpiFamily (Y_n a) (π_n a)) :\n    EffectiveEpiFamily\n      (fun (c : Σ a, β a) => Y_n c.fst c.snd) (fun c => π_n c.fst c.snd ≫ π c.fst) := by\n  rw [← Sieve.effectiveEpimorphic_family]\n  suffices h₂ : (Sieve.generate (Presieve.ofArrows (fun (⟨a, b⟩ : Σ _, β _) => Y_n a b)\n        (fun ⟨a,b⟩ => π_n a b ≫ π a))) ∈ (coherentTopology C) X by\n    change Nonempty _\n    rw [← Sieve.forallYonedaIsSheaf_iff_colimit]\n    exact fun W => coherentTopology.isSheaf_yoneda_obj W _ h₂\n  -- Show that a covering sieve is a colimit, which implies the original set of arrows is regular\n  -- epimorphic. We use the transitivity property of saturation\n  apply Coverage.Saturate.transitive X (Sieve.generate (Presieve.ofArrows Y π))\n  · apply Coverage.Saturate.of\n    use α, inferInstance, Y, π\n  · intro V f ⟨Y₁, h, g, ⟨hY, hf⟩⟩\n    rw [← hf, Sieve.pullback_comp]\n    apply (coherentTopology C).pullback_stable'\n    apply coherentTopology.mem_sieves_of_hasEffectiveEpiFamily\n    -- Need to show that the pullback of the family `π_n` to a given `Y i` is effective epimorphic\n    obtain ⟨i⟩ := hY\n    exact ⟨β i, inferInstance, Y_n i, π_n i, H i, fun b ↦\n      ⟨Y_n i b, (𝟙 _), π_n i b ≫ π i, ⟨(⟨i, b⟩ : Σ (i : α), β i)⟩, by simp⟩⟩\n\n"}
{"name":"CategoryTheory.precoherentEffectiveEpiFamilyCompEffectiveEpis","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\nX : C\nα : Type\ninst✝¹ : Finite α\nY Z : α → C\nπ : (a : α) → Quiver.Hom (Y a) X\ninst✝ : CategoryTheory.EffectiveEpiFamily Y π\nf : (a : α) → Quiver.Hom (Z a) (Y a)\nh : ∀ (a : α), CategoryTheory.EffectiveEpi (f a)\n⊢ CategoryTheory.EffectiveEpiFamily Z fun a => CategoryTheory.CategoryStruct.comp (f a) (π a)","decl":"instance precoherentEffectiveEpiFamilyCompEffectiveEpis\n    {α : Type} [Finite α] {Y Z : α → C} (π : (a : α) → (Y a ⟶ X)) [EffectiveEpiFamily Y π]\n    (f : (a : α) → Z a ⟶ Y a) [h : ∀ a, EffectiveEpi (f a)] :\n    EffectiveEpiFamily _ fun a ↦ f a ≫ π a := by\n  simp_rw [effectiveEpi_iff_effectiveEpiFamily] at h\n  exact EffectiveEpiFamily.reindex (e := Equiv.sigmaPUnit α) _ _\n    (EffectiveEpiFamily.transitive_of_finite (β := fun _ ↦ Unit) _ inferInstance _ h)\n\n"}
{"name":"CategoryTheory.coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Precoherent C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (Membership.mem ((CategoryTheory.coherentTopology C) X) S) (Exists fun α => Exists fun x => Exists fun Y => Exists fun π => And (CategoryTheory.EffectiveEpiFamily Y π) (∀ (a : α), S.arrows (π a)))","decl":"/--\nA sieve belongs to the coherent topology if and only if it contains a finite\n`EffectiveEpiFamily`.\n-/\ntheorem coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily (S : Sieve X) :\n    (S ∈ (coherentTopology C) X) ↔\n    (∃ (α : Type) (_ : Finite α) (Y : α → C) (π : (a : α) → (Y a ⟶ X)),\n        EffectiveEpiFamily Y π ∧ (∀ a : α, (S.arrows) (π a)) )  := by\n  constructor\n  · intro h\n    induction h with\n    | of Y T hS =>\n      obtain ⟨a, h, Y', π, h', _⟩ := hS\n      refine ⟨a, h, Y', π, inferInstance, fun a' ↦ ?_⟩\n      obtain ⟨rfl, _⟩ := h'\n      exact ⟨Y' a', 𝟙 Y' a', π a', Presieve.ofArrows.mk a', by simp⟩\n    | top Y =>\n      exact ⟨Unit, inferInstance, fun _ => Y, fun _ => (𝟙 Y), inferInstance, by simp⟩\n    | transitive Y R S _ _ a b =>\n      obtain ⟨α, w, Y₁, π, ⟨h₁,h₂⟩⟩ := a\n      choose β _ Y_n π_n H using fun a => b (h₂ a)\n      exact ⟨(Σ a, β a), inferInstance, fun ⟨a,b⟩ => Y_n a b, fun ⟨a, b⟩ => (π_n a b) ≫ (π a),\n        EffectiveEpiFamily.transitive_of_finite _ h₁ _ (fun a => (H a).1),\n        fun c => (H c.fst).2 c.snd⟩\n  · exact coherentTopology.mem_sieves_of_hasEffectiveEpiFamily S\n\n"}
