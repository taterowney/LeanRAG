{"name":"CategoryTheory.coherentTopology.mem_sieves_of_hasEffectiveEpiFamily","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Precoherent C\nX : C\nS : CategoryTheory.Sieve X\naâœ : Exists fun Î± => Exists fun x => Exists fun Y => Exists fun Ï€ => And (CategoryTheory.EffectiveEpiFamily Y Ï€) (âˆ€ (a : Î±), S.arrows (Ï€ a))\nâŠ¢ Membership.mem ((CategoryTheory.coherentTopology C) X) S","decl":"/--\nFor a precoherent category, any sieve that contains an `EffectiveEpiFamily` is a sieve of the\ncoherent topology.\nNote: This is one direction of `mem_sieves_iff_hasEffectiveEpiFamily`, but is needed for the proof.\n-/\ntheorem coherentTopology.mem_sieves_of_hasEffectiveEpiFamily (S : Sieve X) :\n    (âˆƒ (Î± : Type) (_ : Finite Î±) (Y : Î± â†’ C) (Ï€ : (a : Î±) â†’ (Y a âŸ¶ X)),\n      EffectiveEpiFamily Y Ï€ âˆ§ (âˆ€ a : Î±, (S.arrows) (Ï€ a)) ) â†’\n        (S âˆˆ (coherentTopology C) X) := by\n  intro âŸ¨Î±, _, Y, Ï€, hÏ€âŸ©\n  apply (coherentCoverage C).mem_toGrothendieck_sieves_of_superset (R := Presieve.ofArrows Y Ï€)\n  Â· exact fun _ _ h â†¦ by cases h; exact hÏ€.2 _\n  Â· exact âŸ¨_, inferInstance, Y, Ï€, rfl, hÏ€.1âŸ©\n\n"}
{"name":"CategoryTheory.EffectiveEpiFamily.transitive_of_finite","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninstâœÂ³ : CategoryTheory.Category.{u_2, u_1} C\ninstâœÂ² : CategoryTheory.Precoherent C\nX : C\nÎ± : Type\ninstâœÂ¹ : Finite Î±\nY : Î± â†’ C\nÏ€ : (a : Î±) â†’ Quiver.Hom (Y a) X\nh : CategoryTheory.EffectiveEpiFamily Y Ï€\nÎ² : Î± â†’ Type\ninstâœ : âˆ€ (a : Î±), Finite (Î² a)\nY_n : (a : Î±) â†’ Î² a â†’ C\nÏ€_n : (a : Î±) â†’ (b : Î² a) â†’ Quiver.Hom (Y_n a b) (Y a)\nH : âˆ€ (a : Î±), CategoryTheory.EffectiveEpiFamily (Y_n a) (Ï€_n a)\nâŠ¢ CategoryTheory.EffectiveEpiFamily (fun c => Y_n c.fst c.snd) fun c => CategoryTheory.CategoryStruct.comp (Ï€_n c.fst c.snd) (Ï€ c.fst)","decl":"/--\nEffective epi families in a precoherent category are transitive, in the sense that an\n`EffectiveEpiFamily` and an `EffectiveEpiFamily` over each member, the composition is an\n`EffectiveEpiFamily`.\nNote: The finiteness condition is an artifact of the proof and is probably unnecessary.\n-/\ntheorem EffectiveEpiFamily.transitive_of_finite {Î± : Type} [Finite Î±] {Y : Î± â†’ C}\n    (Ï€ : (a : Î±) â†’ (Y a âŸ¶ X)) (h : EffectiveEpiFamily Y Ï€) {Î² : Î± â†’ Type} [âˆ€ (a : Î±), Finite (Î² a)]\n    {Y_n : (a : Î±) â†’ Î² a â†’ C} (Ï€_n : (a : Î±) â†’ (b : Î² a) â†’ (Y_n a b âŸ¶ Y a))\n    (H : âˆ€ a, EffectiveEpiFamily (Y_n a) (Ï€_n a)) :\n    EffectiveEpiFamily\n      (fun (c : Î£ a, Î² a) => Y_n c.fst c.snd) (fun c => Ï€_n c.fst c.snd â‰« Ï€ c.fst) := by\n  rw [â† Sieve.effectiveEpimorphic_family]\n  suffices hâ‚‚ : (Sieve.generate (Presieve.ofArrows (fun (âŸ¨a, bâŸ© : Î£ _, Î² _) => Y_n a b)\n        (fun âŸ¨a,bâŸ© => Ï€_n a b â‰« Ï€ a))) âˆˆ (coherentTopology C) X by\n    change Nonempty _\n    rw [â† Sieve.forallYonedaIsSheaf_iff_colimit]\n    exact fun W => coherentTopology.isSheaf_yoneda_obj W _ hâ‚‚\n  -- Show that a covering sieve is a colimit, which implies the original set of arrows is regular\n  -- epimorphic. We use the transitivity property of saturation\n  apply Coverage.Saturate.transitive X (Sieve.generate (Presieve.ofArrows Y Ï€))\n  Â· apply Coverage.Saturate.of\n    use Î±, inferInstance, Y, Ï€\n  Â· intro V f âŸ¨Yâ‚, h, g, âŸ¨hY, hfâŸ©âŸ©\n    rw [â† hf, Sieve.pullback_comp]\n    apply (coherentTopology C).pullback_stable'\n    apply coherentTopology.mem_sieves_of_hasEffectiveEpiFamily\n    -- Need to show that the pullback of the family `Ï€_n` to a given `Y i` is effective epimorphic\n    obtain âŸ¨iâŸ© := hY\n    exact âŸ¨Î² i, inferInstance, Y_n i, Ï€_n i, H i, fun b â†¦\n      âŸ¨Y_n i b, (ðŸ™ _), Ï€_n i b â‰« Ï€ i, âŸ¨(âŸ¨i, bâŸ© : Î£ (i : Î±), Î² i)âŸ©, by simpâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.precoherentEffectiveEpiFamilyCompEffectiveEpis","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\nX : C\nÎ± : Type\ninstâœÂ¹ : Finite Î±\nY Z : Î± â†’ C\nÏ€ : (a : Î±) â†’ Quiver.Hom (Y a) X\ninstâœ : CategoryTheory.EffectiveEpiFamily Y Ï€\nf : (a : Î±) â†’ Quiver.Hom (Z a) (Y a)\nh : âˆ€ (a : Î±), CategoryTheory.EffectiveEpi (f a)\nâŠ¢ CategoryTheory.EffectiveEpiFamily Z fun a => CategoryTheory.CategoryStruct.comp (f a) (Ï€ a)","decl":"instance precoherentEffectiveEpiFamilyCompEffectiveEpis\n    {Î± : Type} [Finite Î±] {Y Z : Î± â†’ C} (Ï€ : (a : Î±) â†’ (Y a âŸ¶ X)) [EffectiveEpiFamily Y Ï€]\n    (f : (a : Î±) â†’ Z a âŸ¶ Y a) [h : âˆ€ a, EffectiveEpi (f a)] :\n    EffectiveEpiFamily _ fun a â†¦ f a â‰« Ï€ a := by\n  simp_rw [effectiveEpi_iff_effectiveEpiFamily] at h\n  exact EffectiveEpiFamily.reindex (e := Equiv.sigmaPUnit Î±) _ _\n    (EffectiveEpiFamily.transitive_of_finite (Î² := fun _ â†¦ Unit) _ inferInstance _ h)\n\n"}
{"name":"CategoryTheory.coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily","module":"Mathlib.CategoryTheory.Sites.Coherent.CoherentTopology","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Precoherent C\nX : C\nS : CategoryTheory.Sieve X\nâŠ¢ Iff (Membership.mem ((CategoryTheory.coherentTopology C) X) S) (Exists fun Î± => Exists fun x => Exists fun Y => Exists fun Ï€ => And (CategoryTheory.EffectiveEpiFamily Y Ï€) (âˆ€ (a : Î±), S.arrows (Ï€ a)))","decl":"/--\nA sieve belongs to the coherent topology if and only if it contains a finite\n`EffectiveEpiFamily`.\n-/\ntheorem coherentTopology.mem_sieves_iff_hasEffectiveEpiFamily (S : Sieve X) :\n    (S âˆˆ (coherentTopology C) X) â†”\n    (âˆƒ (Î± : Type) (_ : Finite Î±) (Y : Î± â†’ C) (Ï€ : (a : Î±) â†’ (Y a âŸ¶ X)),\n        EffectiveEpiFamily Y Ï€ âˆ§ (âˆ€ a : Î±, (S.arrows) (Ï€ a)) )  := by\n  constructor\n  Â· intro h\n    induction h with\n    | of Y T hS =>\n      obtain âŸ¨a, h, Y', Ï€, h', _âŸ© := hS\n      refine âŸ¨a, h, Y', Ï€, inferInstance, fun a' â†¦ ?_âŸ©\n      obtain âŸ¨rfl, _âŸ© := h'\n      exact âŸ¨Y' a', ðŸ™ Y' a', Ï€ a', Presieve.ofArrows.mk a', by simpâŸ©\n    | top Y =>\n      exact âŸ¨Unit, inferInstance, fun _ => Y, fun _ => (ðŸ™ Y), inferInstance, by simpâŸ©\n    | transitive Y R S _ _ a b =>\n      obtain âŸ¨Î±, w, Yâ‚, Ï€, âŸ¨hâ‚,hâ‚‚âŸ©âŸ© := a\n      choose Î² _ Y_n Ï€_n H using fun a => b (hâ‚‚ a)\n      exact âŸ¨(Î£ a, Î² a), inferInstance, fun âŸ¨a,bâŸ© => Y_n a b, fun âŸ¨a, bâŸ© => (Ï€_n a b) â‰« (Ï€ a),\n        EffectiveEpiFamily.transitive_of_finite _ hâ‚ _ (fun a => (H a).1),\n        fun c => (H c.fst).2 c.sndâŸ©\n  Â· exact coherentTopology.mem_sieves_of_hasEffectiveEpiFamily S\n\n"}
