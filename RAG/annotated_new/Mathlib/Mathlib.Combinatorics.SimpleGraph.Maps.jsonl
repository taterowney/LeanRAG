{"name":"SimpleGraph.map_adj","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\nG : SimpleGraph V\nu v : W\n⊢ Iff ((SimpleGraph.map f G).Adj u v) (Exists fun u' => Exists fun v' => And (G.Adj u' v') (And (Eq (f u') u) (Eq (f v') v)))","decl":"@[simp]\ntheorem map_adj (f : V ↪ W) (G : SimpleGraph V) (u v : W) :\n    (G.map f).Adj u v ↔ ∃ u' v' : V, G.Adj u' v' ∧ f u' = u ∧ f v' = v :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.map_adj_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nf : Function.Embedding V W\na b : V\n⊢ Iff ((SimpleGraph.map f G).Adj (f a) (f b)) (G.Adj a b)","decl":"lemma map_adj_apply {G : SimpleGraph V} {f : V ↪ W} {a b : V} :\n    (G.map f).Adj (f a) (f b) ↔ G.Adj a b := by simp\n\n"}
{"name":"SimpleGraph.map_monotone","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\n⊢ Monotone (SimpleGraph.map f)","decl":"theorem map_monotone (f : V ↪ W) : Monotone (SimpleGraph.map f) := by\n  rintro G G' h _ _ ⟨u, v, ha, rfl, rfl⟩\n  exact ⟨_, _, h ha, rfl, rfl⟩\n\n"}
{"name":"SimpleGraph.map_id","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\n⊢ Eq (SimpleGraph.map (Function.Embedding.refl V) G) G","decl":"@[simp] lemma map_id : G.map (Function.Embedding.refl _) = G :=\n  SimpleGraph.ext <| Relation.map_id_id _\n\n"}
{"name":"SimpleGraph.map_map","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\nG : SimpleGraph V\nf : Function.Embedding V W\ng : Function.Embedding W X\n⊢ Eq (SimpleGraph.map g (SimpleGraph.map f G)) (SimpleGraph.map (f.trans g) G)","decl":"@[simp] lemma map_map (f : V ↪ W) (g : W ↪ X) : (G.map f).map g = G.map (f.trans g) :=\n  SimpleGraph.ext <| Relation.map_map _ _ _ _ _\n\n"}
{"name":"SimpleGraph.comap_adj","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nu v : V\nG : SimpleGraph W\nf : V → W\n⊢ Iff ((SimpleGraph.comap f G).Adj u v) (G.Adj (f u) (f v))","decl":"@[simp] lemma comap_adj {G : SimpleGraph W} {f : V → W} :\n    (G.comap f).Adj u v ↔ G.Adj (f u) (f v) := Iff.rfl\n\n"}
{"name":"SimpleGraph.comap_id","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\n⊢ Eq (SimpleGraph.comap id G) G","decl":"@[simp] lemma comap_id {G : SimpleGraph V} : G.comap id = G := SimpleGraph.ext rfl\n\n"}
{"name":"SimpleGraph.comap_comap","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\nG : SimpleGraph X\nf : V → W\ng : W → X\n⊢ Eq (SimpleGraph.comap f (SimpleGraph.comap g G)) (SimpleGraph.comap (Function.comp g f) G)","decl":"@[simp] lemma comap_comap {G : SimpleGraph X} (f : V → W) (g : W → X) :\n  (G.comap g).comap f = G.comap (g ∘ f) := rfl\n\n"}
{"name":"SimpleGraph.comap_symm","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\ne : Equiv V W\n⊢ Eq (SimpleGraph.comap (⇑e.symm.toEmbedding) G) (SimpleGraph.map e.toEmbedding G)","decl":"lemma comap_symm (G : SimpleGraph V) (e : V ≃ W) :\n    G.comap e.symm.toEmbedding = G.map e.toEmbedding := by\n  ext; simp only [Equiv.apply_eq_iff_eq_symm_apply, comap_adj, map_adj, Equiv.toEmbedding_apply,\n    exists_eq_right_right, exists_eq_right]\n\n"}
{"name":"SimpleGraph.map_symm","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph W\ne : Equiv V W\n⊢ Eq (SimpleGraph.map e.symm.toEmbedding G) (SimpleGraph.comap (⇑e.toEmbedding) G)","decl":"lemma map_symm (G : SimpleGraph W) (e : V ≃ W) :\n    G.map e.symm.toEmbedding = G.comap e.toEmbedding := by rw [← comap_symm, e.symm_symm]\n\n"}
{"name":"SimpleGraph.comap_monotone","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\n⊢ Monotone (SimpleGraph.comap ⇑f)","decl":"theorem comap_monotone (f : V ↪ W) : Monotone (SimpleGraph.comap f) := by\n  intro G G' h _ _ ha\n  exact h ha\n\n"}
{"name":"SimpleGraph.comap_map_eq","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\nG : SimpleGraph V\n⊢ Eq (SimpleGraph.comap (⇑f) (SimpleGraph.map f G)) G","decl":"@[simp]\ntheorem comap_map_eq (f : V ↪ W) (G : SimpleGraph V) : (G.map f).comap f = G := by\n  ext\n  simp\n\n"}
{"name":"SimpleGraph.leftInverse_comap_map","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\n⊢ Function.LeftInverse (SimpleGraph.comap ⇑f) (SimpleGraph.map f)","decl":"theorem leftInverse_comap_map (f : V ↪ W) :\n    Function.LeftInverse (SimpleGraph.comap f) (SimpleGraph.map f) :=\n  comap_map_eq f\n\n"}
{"name":"SimpleGraph.map_injective","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\n⊢ Function.Injective (SimpleGraph.map f)","decl":"theorem map_injective (f : V ↪ W) : Function.Injective (SimpleGraph.map f) :=\n  (leftInverse_comap_map f).injective\n\n"}
{"name":"SimpleGraph.comap_surjective","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\n⊢ Function.Surjective (SimpleGraph.comap ⇑f)","decl":"theorem comap_surjective (f : V ↪ W) : Function.Surjective (SimpleGraph.comap f) :=\n  (leftInverse_comap_map f).surjective\n\n"}
{"name":"SimpleGraph.map_le_iff_le_comap","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\nG : SimpleGraph V\nG' : SimpleGraph W\n⊢ Iff (LE.le (SimpleGraph.map f G) G') (LE.le G (SimpleGraph.comap (⇑f) G'))","decl":"theorem map_le_iff_le_comap (f : V ↪ W) (G : SimpleGraph V) (G' : SimpleGraph W) :\n    G.map f ≤ G' ↔ G ≤ G'.comap f :=\n  ⟨fun h _ _ ha => h ⟨_, _, ha, rfl, rfl⟩, by\n    rintro h _ _ ⟨u, v, ha, rfl, rfl⟩\n    exact h ha⟩\n\n"}
{"name":"SimpleGraph.map_comap_le","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\nG : SimpleGraph W\n⊢ LE.le (SimpleGraph.map f (SimpleGraph.comap (⇑f) G)) G","decl":"theorem map_comap_le (f : V ↪ W) (G : SimpleGraph W) : (G.comap f).map f ≤ G := by\n  rw [map_le_iff_le_comap]\n\n"}
{"name":"SimpleGraph.le_comap_of_subsingleton","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : V → W\ninst✝ : Subsingleton V\n⊢ LE.le G (SimpleGraph.comap f G')","decl":"lemma le_comap_of_subsingleton (f : V → W) [Subsingleton V] : G ≤ G'.comap f := by\n  intros v w; simp [Subsingleton.elim v w]\n\n"}
{"name":"SimpleGraph.map_le_of_subsingleton","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : Function.Embedding V W\ninst✝ : Subsingleton V\n⊢ LE.le (SimpleGraph.map f G) G'","decl":"lemma map_le_of_subsingleton (f : V ↪ W) [Subsingleton V] : G.map f ≤ G' := by\n  rw [map_le_iff_le_comap]; apply le_comap_of_subsingleton\n\n"}
{"name":"Equiv.simpleGraph_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\ne : Equiv V W\nG : SimpleGraph V\n⊢ Eq (e.simpleGraph G) (SimpleGraph.comap (⇑e.symm) G)","decl":"/-- Equivalent types have equivalent simple graphs. -/\n@[simps apply]\nprotected def _root_.Equiv.simpleGraph (e : V ≃ W) : SimpleGraph V ≃ SimpleGraph W where\n  toFun := SimpleGraph.comap e.symm\n  invFun := SimpleGraph.comap e\n  left_inv _ := by simp\n  right_inv _ := by simp\n\n"}
{"name":"Equiv.simpleGraph_refl","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\n⊢ Eq (Equiv.refl V).simpleGraph (Equiv.refl (SimpleGraph V))","decl":"@[simp] lemma _root_.Equiv.simpleGraph_refl : (Equiv.refl V).simpleGraph = Equiv.refl _ := by\n  ext; rfl\n\n"}
{"name":"Equiv.simpleGraph_trans","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\ne₁ : Equiv V W\ne₂ : Equiv W X\n⊢ Eq (e₁.trans e₂).simpleGraph (e₁.simpleGraph.trans e₂.simpleGraph)","decl":"@[simp] lemma _root_.Equiv.simpleGraph_trans (e₁ : V ≃ W) (e₂ : W ≃ X) :\n  (e₁.trans e₂).simpleGraph = e₁.simpleGraph.trans e₂.simpleGraph := rfl\n\n"}
{"name":"Equiv.symm_simpleGraph","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\ne : Equiv V W\n⊢ Eq e.simpleGraph.symm e.symm.simpleGraph","decl":"@[simp]\nlemma _root_.Equiv.symm_simpleGraph (e : V ≃ W) : e.simpleGraph.symm = e.symm.simpleGraph := rfl\n\n"}
{"name":"SimpleGraph.induce_singleton_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\n⊢ Eq (SimpleGraph.induce (Singleton.singleton v) G) Top.top","decl":"@[simp] lemma induce_singleton_eq_top (v : V) : G.induce {v} = ⊤ := by\n  rw [eq_top_iff]; apply le_comap_of_subsingleton\n\n"}
{"name":"SimpleGraph.induce_spanningCoe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\ns : Set V\nG : SimpleGraph ↑s\n⊢ Eq (SimpleGraph.induce s G.spanningCoe) G","decl":"theorem induce_spanningCoe {s : Set V} {G : SimpleGraph s} : G.spanningCoe.induce s = G :=\n  comap_map_eq _ _\n\n"}
{"name":"SimpleGraph.spanningCoe_induce_le","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns : Set V\n⊢ LE.le (SimpleGraph.induce s G).spanningCoe G","decl":"theorem spanningCoe_induce_le (s : Set V) : (G.induce s).spanningCoe ≤ G :=\n  map_comap_le _ _\n\n"}
{"name":"SimpleGraph.Hom.coe_id","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\n⊢ Eq (⇑SimpleGraph.Hom.id) id","decl":"@[simp, norm_cast] lemma coe_id : ⇑(Hom.id : G →g G) = id := rfl\n\n"}
{"name":"SimpleGraph.Hom.instSubsingletonOfForall","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nH : SimpleGraph W\ninst✝ : Subsingleton (V → W)\n⊢ Subsingleton (G.Hom H)","decl":"instance [Subsingleton (V → W)] : Subsingleton (G →g H) := DFunLike.coe_injective.subsingleton\n\n"}
{"name":"SimpleGraph.Hom.instFinite","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nH : SimpleGraph W\ninst✝¹ : Finite V\ninst✝ : Finite W\n⊢ Finite (G.Hom H)","decl":"instance [Finite V] [Finite W] : Finite (G →g H) := DFunLike.finite _\n\n"}
{"name":"SimpleGraph.Hom.map_adj","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nv w : V\nh : G.Adj v w\n⊢ G'.Adj (f v) (f w)","decl":"theorem map_adj {v w : V} (h : G.Adj v w) : G'.Adj (f v) (f w) :=\n  f.map_rel' h\n\n"}
{"name":"SimpleGraph.Hom.map_mem_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\ne : Sym2 V\nh : Membership.mem G.edgeSet e\n⊢ Membership.mem G'.edgeSet (Sym2.map (⇑f) e)","decl":"theorem map_mem_edgeSet {e : Sym2 V} (h : e ∈ G.edgeSet) : e.map f ∈ G'.edgeSet :=\n  Sym2.ind (fun _ _ => f.map_rel') e h\n\n"}
{"name":"SimpleGraph.Hom.apply_mem_neighborSet","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nv w : V\nh : Membership.mem (G.neighborSet v) w\n⊢ Membership.mem (G'.neighborSet (f v)) (f w)","decl":"theorem apply_mem_neighborSet {v w : V} (h : w ∈ G.neighborSet v) : f w ∈ G'.neighborSet (f v) :=\n  map_adj f h\n\n"}
{"name":"SimpleGraph.Hom.mapEdgeSet_coe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\ne : ↑G.edgeSet\n⊢ Eq (↑(f.mapEdgeSet e)) (Sym2.map ⇑f ↑e)","decl":"/-- The map between edge sets induced by a homomorphism.\nThe underlying map on edges is given by `Sym2.map`. -/\n@[simps]\ndef mapEdgeSet (e : G.edgeSet) : G'.edgeSet :=\n  ⟨Sym2.map f e, f.map_mem_edgeSet e.property⟩\n\n"}
{"name":"SimpleGraph.Hom.mapNeighborSet_coe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nv : V\nw : ↑(G.neighborSet v)\n⊢ Eq (↑(f.mapNeighborSet v w)) (f ↑w)","decl":"/-- The map between neighbor sets induced by a homomorphism. -/\n@[simps]\ndef mapNeighborSet (v : V) (w : G.neighborSet v) : G'.neighborSet (f v) :=\n  ⟨f w, f.apply_mem_neighborSet w.property⟩\n\n"}
{"name":"SimpleGraph.Hom.mapDart_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nd : G.Dart\n⊢ Eq (f.mapDart d) { toProd := Prod.map (⇑f) (⇑f) d.toProd, adj := ⋯ }","decl":"@[simp]\ntheorem mapDart_apply (d : G.Dart) : f.mapDart d = ⟨d.1.map f f, f.map_adj d.2⟩ :=\n  rfl\n\n"}
{"name":"SimpleGraph.Hom.mapSpanningSubgraphs_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG G' : SimpleGraph V\nh : LE.le G G'\nx : V\n⊢ Eq ((SimpleGraph.Hom.mapSpanningSubgraphs h) x) x","decl":"/-- The induced map for spanning subgraphs, which is the identity on vertices. -/\n@[simps]\ndef mapSpanningSubgraphs {G G' : SimpleGraph V} (h : G ≤ G') : G →g G' where\n  toFun x := x\n  map_rel' ha := h ha\n\n"}
{"name":"SimpleGraph.Hom.mapEdgeSet.injective","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Hom G'\nhinj : Function.Injective ⇑f\n⊢ Function.Injective f.mapEdgeSet","decl":"theorem mapEdgeSet.injective (hinj : Function.Injective f) : Function.Injective f.mapEdgeSet := by\n  rintro ⟨e₁, h₁⟩ ⟨e₂, h₂⟩\n  dsimp [Hom.mapEdgeSet]\n  repeat rw [Subtype.mk_eq_mk]\n  apply Sym2.map.injective hinj\n\n"}
{"name":"SimpleGraph.Hom.injective_of_top_hom","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG' : SimpleGraph W\nf : Top.top.Hom G'\n⊢ Function.Injective ⇑f","decl":"/-- Every graph homomorphism from a complete graph is injective. -/\ntheorem injective_of_top_hom (f : (⊤ : SimpleGraph V) →g G') : Function.Injective f := by\n  intro v w h\n  contrapose! h\n  exact G'.ne_of_adj (map_adj _ ((top_adj _ _).mpr h))\n\n"}
{"name":"SimpleGraph.Hom.comap_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : V → W\nG : SimpleGraph W\na✝ : V\n⊢ Eq ((SimpleGraph.Hom.comap f G) a✝) (f a✝)","decl":"/-- There is a homomorphism to a graph from a comapped graph.\nWhen the function is injective, this is an embedding (see `SimpleGraph.Embedding.comap`). -/\n@[simps]\nprotected def comap (f : V → W) (G : SimpleGraph W) : G.comap f →g G where\n  toFun := f\n  map_rel' := by simp\n\n"}
{"name":"SimpleGraph.Hom.coe_comp","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\nG : SimpleGraph V\nG' : SimpleGraph W\nG'' : SimpleGraph X\nf' : G'.Hom G''\nf : G.Hom G'\n⊢ Eq (⇑(f'.comp f)) (Function.comp ⇑f' ⇑f)","decl":"@[simp]\ntheorem coe_comp (f' : G' →g G'') (f : G →g G') : ⇑(f'.comp f) = f' ∘ f :=\n  rfl\n\n"}
{"name":"SimpleGraph.Hom.coe_ofLE","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG₁ G₂ : SimpleGraph V\nh : LE.le G₁ G₂\n⊢ Eq (⇑(SimpleGraph.Hom.ofLE h)) id","decl":"@[simp, norm_cast] lemma coe_ofLE (h : G₁ ≤ G₂) : ⇑(ofLE h) = id := rfl\n\n"}
{"name":"SimpleGraph.Embedding.coe_toHom","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nH : SimpleGraph W\nf : G.Embedding H\n⊢ Eq ⇑f.toHom ⇑f","decl":"@[simp] lemma coe_toHom (f : G ↪g H) : ⇑f.toHom = f := rfl\n\n"}
{"name":"SimpleGraph.Embedding.map_adj_iff","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Embedding G'\nv w : V\n⊢ Iff (G'.Adj (f v) (f w)) (G.Adj v w)","decl":"@[simp] theorem map_adj_iff {v w : V} : G'.Adj (f v) (f w) ↔ G.Adj v w :=\n  f.map_rel_iff\n\n"}
{"name":"SimpleGraph.Embedding.map_mem_edgeSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Embedding G'\ne : Sym2 V\n⊢ Iff (Membership.mem G'.edgeSet (Sym2.map (⇑f) e)) (Membership.mem G.edgeSet e)","decl":"theorem map_mem_edgeSet_iff {e : Sym2 V} : e.map f ∈ G'.edgeSet ↔ e ∈ G.edgeSet :=\n  Sym2.ind (fun _ _ => f.map_adj_iff) e\n\n"}
{"name":"SimpleGraph.Embedding.apply_mem_neighborSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Embedding G'\nv w : V\n⊢ Iff (Membership.mem (G'.neighborSet (f v)) (f w)) (Membership.mem (G.neighborSet v) w)","decl":"theorem apply_mem_neighborSet_iff {v w : V} : f w ∈ G'.neighborSet (f v) ↔ w ∈ G.neighborSet v :=\n  map_adj_iff f\n\n"}
{"name":"SimpleGraph.Embedding.mapEdgeSet_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Embedding G'\ne : ↑G.edgeSet\n⊢ Eq (f.mapEdgeSet e) (SimpleGraph.Hom.mapEdgeSet (RelEmbedding.toRelHom f) e)","decl":"/-- A graph embedding induces an embedding of edge sets. -/\n@[simps]\ndef mapEdgeSet : G.edgeSet ↪ G'.edgeSet where\n  toFun := Hom.mapEdgeSet f\n  inj' := Hom.mapEdgeSet.injective f.toRelHom f.injective\n\n"}
{"name":"SimpleGraph.Embedding.mapNeighborSet_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Embedding G'\nv : V\nw : ↑(G.neighborSet v)\n⊢ Eq (↑((f.mapNeighborSet v) w)) (f ↑w)","decl":"/-- A graph embedding induces an embedding of neighbor sets. -/\n@[simps]\ndef mapNeighborSet (v : V) : G.neighborSet v ↪ G'.neighborSet (f v) where\n  toFun w := ⟨f w, f.apply_mem_neighborSet_iff.mpr w.2⟩\n  inj' := by\n    rintro ⟨w₁, h₁⟩ ⟨w₂, h₂⟩ h\n    rw [Subtype.mk_eq_mk] at h ⊢\n    exact f.inj' h\n\n"}
{"name":"SimpleGraph.Embedding.comap_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\nG : SimpleGraph W\nv : V\n⊢ Eq ((SimpleGraph.Embedding.comap f G) v) (f v)","decl":"@[simp]\ntheorem comap_apply (f : V ↪ W) (G : SimpleGraph W) (v : V) :\n    SimpleGraph.Embedding.comap f G v = f v := rfl\n\n"}
{"name":"SimpleGraph.Embedding.map_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Function.Embedding V W\nG : SimpleGraph V\nv : V\n⊢ Eq ((SimpleGraph.Embedding.map f G) v) (f v)","decl":"@[simp]\ntheorem map_apply (f : V ↪ W) (G : SimpleGraph V) (v : V) :\n    SimpleGraph.Embedding.map f G v = f v := rfl\n\n"}
{"name":"SimpleGraph.Embedding.coe_completeGraph","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"α : Type u_4\nβ : Type u_5\nf : Function.Embedding α β\n⊢ Eq ⇑(SimpleGraph.Embedding.completeGraph f) ⇑f","decl":"@[simp] lemma coe_completeGraph {α β : Type*} (f : α ↪ β) : ⇑(Embedding.completeGraph f) = f := rfl\n\n"}
{"name":"SimpleGraph.Embedding.coe_comp","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\nG : SimpleGraph V\nG' : SimpleGraph W\nG'' : SimpleGraph X\nf' : G'.Embedding G''\nf : G.Embedding G'\n⊢ Eq (⇑(f'.comp f)) (Function.comp ⇑f' ⇑f)","decl":"@[simp]\ntheorem coe_comp (f' : G' ↪g G'') (f : G ↪g G') : ⇑(f'.comp f) = f' ∘ f :=\n  rfl\n\n"}
{"name":"SimpleGraph.coe_induceHom","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\ns : Set V\nt : Set W\nφ : G.Hom G'\nφst : Set.MapsTo (⇑φ) s t\n⊢ Eq (⇑(SimpleGraph.induceHom φ φst)) (Set.MapsTo.restrict (⇑φ) s t φst)","decl":"@[simp, norm_cast] lemma coe_induceHom : ⇑(induceHom φ φst) = Set.MapsTo.restrict φ s t φst :=\n  rfl\n\n"}
{"name":"SimpleGraph.induceHom_id","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns : Set V\n⊢ Eq (SimpleGraph.induceHom SimpleGraph.Hom.id ⋯) SimpleGraph.Hom.id","decl":"@[simp] lemma induceHom_id (G : SimpleGraph V) (s) :\n    induceHom (Hom.id : G →g G) (Set.mapsTo_id s) = Hom.id := by\n  ext x\n  rfl\n\n"}
{"name":"SimpleGraph.induceHom_comp","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\nG : SimpleGraph V\nG' : SimpleGraph W\nG'' : SimpleGraph X\ns : Set V\nt : Set W\nr : Set X\nφ : G.Hom G'\nφst : Set.MapsTo (⇑φ) s t\nψ : G'.Hom G''\nψtr : Set.MapsTo (⇑ψ) t r\n⊢ Eq ((SimpleGraph.induceHom ψ ψtr).comp (SimpleGraph.induceHom φ φst)) (SimpleGraph.induceHom (ψ.comp φ) ⋯)","decl":"@[simp] lemma induceHom_comp :\n    (induceHom ψ ψtr).comp (induceHom φ φst) = induceHom (ψ.comp φ) (ψtr.comp φst) := by\n  ext x\n  rfl\n\n"}
{"name":"SimpleGraph.induceHom_injective","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\ns : Set V\nt : Set W\nφ : G.Hom G'\nφst : Set.MapsTo (⇑φ) s t\nhi : Set.InjOn (⇑φ) s\n⊢ Function.Injective ⇑(SimpleGraph.induceHom φ φst)","decl":"lemma induceHom_injective (hi : Set.InjOn φ s) :\n    Function.Injective (induceHom φ φst) := by\n  erw [Set.MapsTo.restrict_inj] <;> assumption\n\n"}
{"name":"SimpleGraph.induceHomOfLE_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns s' : Set V\nh : LE.le s s'\nv : ↑s\n⊢ Eq ((G.induceHomOfLE h) v) (Set.inclusion h v)","decl":"@[simp] lemma induceHomOfLE_apply (v : s) : (G.induceHomOfLE h) v = Set.inclusion h v := rfl\n\n"}
{"name":"SimpleGraph.induceHomOfLE_toHom","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\ns s' : Set V\nh : LE.le s s'\n⊢ Eq (G.induceHomOfLE h).toHom (SimpleGraph.induceHom SimpleGraph.Hom.id ⋯)","decl":"@[simp] lemma induceHomOfLE_toHom :\n    (G.induceHomOfLE h).toHom = induceHom (.id : G →g G) ((Set.mapsTo_id s).mono_right h) := by\n  ext; simp\n\n"}
{"name":"SimpleGraph.Iso.map_adj_iff","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\nv w : V\n⊢ Iff (G'.Adj (f v) (f w)) (G.Adj v w)","decl":"theorem map_adj_iff {v w : V} : G'.Adj (f v) (f w) ↔ G.Adj v w :=\n  f.map_rel_iff\n\n"}
{"name":"SimpleGraph.Iso.map_mem_edgeSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\ne : Sym2 V\n⊢ Iff (Membership.mem G'.edgeSet (Sym2.map (⇑f) e)) (Membership.mem G.edgeSet e)","decl":"theorem map_mem_edgeSet_iff {e : Sym2 V} : e.map f ∈ G'.edgeSet ↔ e ∈ G.edgeSet :=\n  Sym2.ind (fun _ _ => f.map_adj_iff) e\n\n"}
{"name":"SimpleGraph.Iso.apply_mem_neighborSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\nv w : V\n⊢ Iff (Membership.mem (G'.neighborSet (f v)) (f w)) (Membership.mem (G.neighborSet v) w)","decl":"theorem apply_mem_neighborSet_iff {v w : V} : f w ∈ G'.neighborSet (f v) ↔ w ∈ G.neighborSet v :=\n  map_adj_iff f\n\n"}
{"name":"SimpleGraph.Iso.symm_toHom_comp_toHom","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\n⊢ Eq (f.symm.toHom.comp f.toHom) SimpleGraph.Hom.id","decl":"@[simp]\ntheorem symm_toHom_comp_toHom : f.symm.toHom.comp f.toHom = Hom.id := by\n  ext v\n  simp only [RelHom.comp_apply, RelEmbedding.coe_toRelHom, RelIso.coe_toRelEmbedding,\n    RelIso.symm_apply_apply, RelHom.id_apply]\n\n"}
{"name":"SimpleGraph.Iso.toHom_comp_symm_toHom","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\n⊢ Eq (f.toHom.comp f.symm.toHom) SimpleGraph.Hom.id","decl":"@[simp]\ntheorem toHom_comp_symm_toHom : f.toHom.comp f.symm.toHom = Hom.id := by\n  ext v\n  simp only [RelHom.comp_apply, RelEmbedding.coe_toRelHom, RelIso.coe_toRelEmbedding,\n    RelIso.apply_symm_apply, RelHom.id_apply]\n\n"}
{"name":"SimpleGraph.Iso.mapEdgeSet_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\ne : ↑G.edgeSet\n⊢ Eq (f.mapEdgeSet e) (SimpleGraph.Hom.mapEdgeSet (RelIso.toRelEmbedding f).toRelHom e)","decl":"/-- An isomorphism of graphs induces an equivalence of edge sets. -/\n@[simps]\ndef mapEdgeSet : G.edgeSet ≃ G'.edgeSet where\n  toFun := Hom.mapEdgeSet f\n  invFun := Hom.mapEdgeSet f.symm\n  left_inv := by\n    rintro ⟨e, h⟩\n    simp only [Hom.mapEdgeSet, RelEmbedding.toRelHom, Embedding.toFun_eq_coe,\n      RelEmbedding.coe_toEmbedding, RelIso.coe_toRelEmbedding, Sym2.map_map, comp_apply,\n      Subtype.mk.injEq]\n    convert congr_fun Sym2.map_id e\n    exact RelIso.symm_apply_apply _ _\n  right_inv := by\n    rintro ⟨e, h⟩\n    simp only [Hom.mapEdgeSet, RelEmbedding.toRelHom, Embedding.toFun_eq_coe,\n      RelEmbedding.coe_toEmbedding, RelIso.coe_toRelEmbedding, Sym2.map_map, comp_apply,\n      Subtype.mk.injEq]\n    convert congr_fun Sym2.map_id e\n    exact RelIso.apply_symm_apply _ _\n\n"}
{"name":"SimpleGraph.Iso.mapEdgeSet_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\ne : ↑G'.edgeSet\n⊢ Eq (f.mapEdgeSet.symm e) (SimpleGraph.Hom.mapEdgeSet (RelIso.toRelEmbedding f.symm).toRelHom e)","decl":"/-- An isomorphism of graphs induces an equivalence of edge sets. -/\n@[simps]\ndef mapEdgeSet : G.edgeSet ≃ G'.edgeSet where\n  toFun := Hom.mapEdgeSet f\n  invFun := Hom.mapEdgeSet f.symm\n  left_inv := by\n    rintro ⟨e, h⟩\n    simp only [Hom.mapEdgeSet, RelEmbedding.toRelHom, Embedding.toFun_eq_coe,\n      RelEmbedding.coe_toEmbedding, RelIso.coe_toRelEmbedding, Sym2.map_map, comp_apply,\n      Subtype.mk.injEq]\n    convert congr_fun Sym2.map_id e\n    exact RelIso.symm_apply_apply _ _\n  right_inv := by\n    rintro ⟨e, h⟩\n    simp only [Hom.mapEdgeSet, RelEmbedding.toRelHom, Embedding.toFun_eq_coe,\n      RelEmbedding.coe_toEmbedding, RelIso.coe_toRelEmbedding, Sym2.map_map, comp_apply,\n      Subtype.mk.injEq]\n    convert congr_fun Sym2.map_id e\n    exact RelIso.apply_symm_apply _ _\n\n"}
{"name":"SimpleGraph.Iso.mapNeighborSet_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\nv : V\nw : ↑(G.neighborSet v)\n⊢ Eq (↑((f.mapNeighborSet v) w)) (f ↑w)","decl":"/-- A graph isomorphism induces an equivalence of neighbor sets. -/\n@[simps]\ndef mapNeighborSet (v : V) : G.neighborSet v ≃ G'.neighborSet (f v) where\n  toFun w := ⟨f w, f.apply_mem_neighborSet_iff.mpr w.2⟩\n  invFun w :=\n    ⟨f.symm w, by\n      simpa [RelIso.symm_apply_apply] using f.symm.apply_mem_neighborSet_iff.mpr w.2⟩\n  left_inv w := by simp\n  right_inv w := by simp\n\n"}
{"name":"SimpleGraph.Iso.mapNeighborSet_symm_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\nv : V\nw : ↑(G'.neighborSet (f v))\n⊢ Eq (↑((f.mapNeighborSet v).symm w)) (f.symm ↑w)","decl":"/-- A graph isomorphism induces an equivalence of neighbor sets. -/\n@[simps]\ndef mapNeighborSet (v : V) : G.neighborSet v ≃ G'.neighborSet (f v) where\n  toFun w := ⟨f w, f.apply_mem_neighborSet_iff.mpr w.2⟩\n  invFun w :=\n    ⟨f.symm w, by\n      simpa [RelIso.symm_apply_apply] using f.symm.apply_mem_neighborSet_iff.mpr w.2⟩\n  left_inv w := by simp\n  right_inv w := by simp\n\n"}
{"name":"SimpleGraph.Iso.card_eq","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nG : SimpleGraph V\nG' : SimpleGraph W\nf : G.Iso G'\ninst✝¹ : Fintype V\ninst✝ : Fintype W\n⊢ Eq (Fintype.card V) (Fintype.card W)","decl":"include f in\ntheorem card_eq [Fintype V] [Fintype W] : Fintype.card V = Fintype.card W := by\n  rw [← Fintype.ofEquiv_card f.toEquiv]\n  convert rfl\n\n"}
{"name":"SimpleGraph.Iso.comap_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Equiv V W\nG : SimpleGraph W\nv : V\n⊢ Eq ((SimpleGraph.Iso.comap f G) v) (f v)","decl":"@[simp]\nlemma comap_apply (f : V ≃ W) (G : SimpleGraph W) (v : V) :\n    SimpleGraph.Iso.comap f G v = f v := rfl\n\n"}
{"name":"SimpleGraph.Iso.comap_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Equiv V W\nG : SimpleGraph W\nw : W\n⊢ Eq ((SimpleGraph.Iso.comap f G).symm w) (f.symm w)","decl":"@[simp]\nlemma comap_symm_apply (f : V ≃ W) (G : SimpleGraph W) (w : W) :\n    (SimpleGraph.Iso.comap f G).symm w = f.symm w := rfl\n\n"}
{"name":"SimpleGraph.Iso.map_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Equiv V W\nG : SimpleGraph V\nv : V\n⊢ Eq ((SimpleGraph.Iso.map f G) v) (f v)","decl":"@[simp]\nlemma map_apply (f : V ≃ W) (G : SimpleGraph V) (v : V) :\n    SimpleGraph.Iso.map f G v = f v := rfl\n\n"}
{"name":"SimpleGraph.Iso.map_symm_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nf : Equiv V W\nG : SimpleGraph V\nw : W\n⊢ Eq ((SimpleGraph.Iso.map f G).symm w) (f.symm w)","decl":"@[simp]\nlemma map_symm_apply (f : V ≃ W) (G : SimpleGraph V) (w : W) :\n    (SimpleGraph.Iso.map f G).symm w = f.symm w := rfl\n\n"}
{"name":"SimpleGraph.Iso.toEmbedding_completeGraph","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"α : Type u_4\nβ : Type u_5\nf : Equiv α β\n⊢ Eq (SimpleGraph.Iso.completeGraph f).toEmbedding (SimpleGraph.Embedding.completeGraph f.toEmbedding)","decl":"theorem toEmbedding_completeGraph {α β : Type*} (f : α ≃ β) :\n    (Iso.completeGraph f).toEmbedding = Embedding.completeGraph f.toEmbedding :=\n  rfl\n\n"}
{"name":"SimpleGraph.Iso.coe_comp","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nW : Type u_2\nX : Type u_3\nG : SimpleGraph V\nG' : SimpleGraph W\nG'' : SimpleGraph X\nf' : G'.Iso G''\nf : G.Iso G'\n⊢ Eq (⇑(f'.comp f)) (Function.comp ⇑f' ⇑f)","decl":"@[simp]\ntheorem coe_comp (f' : G' ≃g G'') (f : G ≃g G') : ⇑(f'.comp f) = f' ∘ f :=\n  rfl\n\n"}
{"name":"SimpleGraph.induceUnivIso_apply","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\nself : Subtype fun x => Membership.mem Set.univ x\n⊢ Eq (G.induceUnivIso self) ↑self","decl":"/-- The graph induced on `Set.univ` is isomorphic to the original graph. -/\n@[simps!]\ndef induceUnivIso (G : SimpleGraph V) : G.induce Set.univ ≃g G where\n  toEquiv := Equiv.Set.univ V\n  map_rel_iff' := by simp only [Equiv.Set.univ, Equiv.coe_fn_mk, comap_adj, Embedding.coe_subtype,\n                                Subtype.forall, Set.mem_univ, forall_true_left, implies_true]\n\n"}
{"name":"SimpleGraph.induceUnivIso_symm_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Maps","initialProofState":"V : Type u_1\nG : SimpleGraph V\na : V\n⊢ Eq (↑((RelIso.symm G.induceUnivIso) a)) a","decl":"/-- The graph induced on `Set.univ` is isomorphic to the original graph. -/\n@[simps!]\ndef induceUnivIso (G : SimpleGraph V) : G.induce Set.univ ≃g G where\n  toEquiv := Equiv.Set.univ V\n  map_rel_iff' := by simp only [Equiv.Set.univ, Equiv.coe_fn_mk, comap_adj, Embedding.coe_subtype,\n                                Subtype.forall, Set.mem_univ, forall_true_left, implies_true]\n\n"}
