{"name":"IsNormalClosure.adjoin_rootSet","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nself : IsNormalClosure F K L\n⊢ Eq (iSup fun x => IntermediateField.adjoin F ((minpoly F x).rootSet L)) Top.top","decl":"/-- `L/F` is a normal closure of `K/F` if the minimal polynomial of every element of `K` over `F`\n  splits in `L`, and `L` is generated by roots of such minimal polynomials over `F`.\n  (Since the minimal polynomial of a transcendental element is 0,\n  the normal closure of `K/F` is the same as the normal closure over `F`\n  of the algebraic closure of `F` in `K`.) -/\n@[stacks 0BMF \"Predicate version\"]\nclass IsNormalClosure : Prop where\n  splits (x : K) : (minpoly F x).Splits (algebraMap F L)\n  adjoin_rootSet : ⨆ x : K, adjoin F ((minpoly F x).rootSet L) = ⊤\n/- TODO: show `IsNormalClosure F K L ↔ IsNormalClosure F (integralClosure F K) L`; we can't state\n  this yet because `integralClosure F K` needs to have a `Field` instance. -/\n\n"}
{"name":"IsNormalClosure.splits","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nself : IsNormalClosure F K L\nx : K\n⊢ Polynomial.Splits (algebraMap F L) (minpoly F x)","decl":"/-- `L/F` is a normal closure of `K/F` if the minimal polynomial of every element of `K` over `F`\n  splits in `L`, and `L` is generated by roots of such minimal polynomials over `F`.\n  (Since the minimal polynomial of a transcendental element is 0,\n  the normal closure of `K/F` is the same as the normal closure over `F`\n  of the algebraic closure of `F` in `K`.) -/\n@[stacks 0BMF \"Predicate version\"]\nclass IsNormalClosure : Prop where\n  splits (x : K) : (minpoly F x).Splits (algebraMap F L)\n  adjoin_rootSet : ⨆ x : K, adjoin F ((minpoly F x).rootSet L) = ⊤\n/- TODO: show `IsNormalClosure F K L ↔ IsNormalClosure F (integralClosure F K) L`; we can't state\n  this yet because `integralClosure F K` needs to have a `Field` instance. -/\n\n"}
{"name":"normalClosure_def","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\n⊢ Eq (normalClosure F K L) (iSup fun f => f.fieldRange)","decl":"lemma normalClosure_def : normalClosure F K L = ⨆ f : K →ₐ[F] L, f.fieldRange :=\n  rfl\n\n"}
{"name":"IsNormalClosure.normal","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nh : IsNormalClosure F K L\n⊢ Normal F L","decl":"/-- A normal closure is always normal. -/\nlemma IsNormalClosure.normal [h : IsNormalClosure F K L] : Normal F L :=\n  Normal.of_algEquiv topEquiv (h := h.adjoin_rootSet ▸ IntermediateField.normal_iSup (h :=\n    fun _ ↦ Normal.of_isSplittingField (hFEp := adjoin_rootSet_isSplittingField <| h.splits _)))\n\n"}
{"name":"normalClosure_le_iff","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nK' : IntermediateField F L\n⊢ Iff (LE.le (normalClosure F K L) K') (∀ (f : AlgHom F K L), LE.le f.fieldRange K')","decl":"lemma normalClosure_le_iff {K' : IntermediateField F L} :\n    normalClosure F K L ≤ K' ↔ ∀ f : K →ₐ[F] L, f.fieldRange ≤ K' :=\n  iSup_le_iff\n\n"}
{"name":"AlgHom.fieldRange_le_normalClosure","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nf : AlgHom F K L\n⊢ LE.le f.fieldRange (normalClosure F K L)","decl":"lemma AlgHom.fieldRange_le_normalClosure (f : K →ₐ[F] L) : f.fieldRange ≤ normalClosure F K L :=\n  le_iSup AlgHom.fieldRange f\n\n"}
{"name":"Algebra.IsAlgebraic.normalClosure_le_iSup_adjoin","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra F K\ninst✝¹ : Algebra F L\ninst✝ : Algebra.IsAlgebraic F K\n⊢ LE.le (normalClosure F K L) (iSup fun x => IntermediateField.adjoin F ((minpoly F x).rootSet L))","decl":"lemma normalClosure_le_iSup_adjoin :\n    normalClosure F K L ≤ ⨆ x : K, IntermediateField.adjoin F ((minpoly F x).rootSet L) :=\n  iSup_le fun f _ ⟨x, hx⟩ ↦ le_iSup (α := IntermediateField F L) _ x <|\n    IntermediateField.subset_adjoin F _ <| by\n      rw [mem_rootSet_of_ne (minpoly.ne_zero (Algebra.IsIntegral.isIntegral x)), ← hx,\n        AlgHom.toRingHom_eq_coe, AlgHom.coe_toRingHom, aeval_algHom_apply, minpoly.aeval, map_zero]\n\n"}
{"name":"Algebra.IsAlgebraic.normalClosure_eq_iSup_adjoin_of_splits","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra F K\ninst✝¹ : Algebra F L\ninst✝ : Algebra.IsAlgebraic F K\nsplits : ∀ (x : K), Polynomial.Splits (algebraMap F L) (minpoly F x)\n⊢ Eq (normalClosure F K L) (iSup fun x => IntermediateField.adjoin F ((minpoly F x).rootSet L))","decl":"include splits in\nlemma normalClosure_eq_iSup_adjoin_of_splits :\n    normalClosure F K L = ⨆ x : K, IntermediateField.adjoin F ((minpoly F x).rootSet L) :=\n  normalClosure_le_iSup_adjoin.antisymm <|\n    iSup_le fun x ↦ IntermediateField.adjoin_le_iff.mpr fun _ hy ↦\n      let ⟨φ, hφ⟩ := IntermediateField.exists_algHom_of_splits_of_aeval\n        (fun x ↦ ⟨Algebra.IsIntegral.isIntegral x, splits x⟩) (mem_rootSet.mp hy).2\n      le_iSup AlgHom.fieldRange φ ⟨x, hφ⟩\n\n"}
{"name":"Algebra.IsAlgebraic.isNormalClosure_iff","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra F K\ninst✝¹ : Algebra F L\ninst✝ : Algebra.IsAlgebraic F K\n⊢ Iff (IsNormalClosure F K L) (And (∀ (x : K), Polynomial.Splits (algebraMap F L) (minpoly F x)) (Eq (normalClosure F K L) Top.top))","decl":"/-- If `K/F` is algebraic, the \"generated by roots\" condition in IsNormalClosure can be replaced\n  by \"generated by images of embeddings\". -/\nlemma isNormalClosure_iff : IsNormalClosure F K L ↔\n    (∀ x : K, (minpoly F x).Splits (algebraMap F L)) ∧ normalClosure F K L = ⊤ := by\n  refine ⟨fun ⟨splits, h⟩ ↦ ⟨splits, ?_⟩, fun ⟨splits, h⟩ ↦ ⟨splits, ?_⟩⟩ <;>\n    simpa only [normalClosure_eq_iSup_adjoin_of_splits splits] using h\n-- TODO: IntermediateField.isNormalClosure_iff similar to IntermediateField.isSplittingField_iff\n\n"}
{"name":"Algebra.IsAlgebraic.isNormalClosure_normalClosure","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra F K\ninst✝¹ : Algebra F L\ninst✝ : Algebra.IsAlgebraic F K\nsplits : ∀ (x : K), Polynomial.Splits (algebraMap F L) (minpoly F x)\n⊢ IsNormalClosure F K (Subtype fun x => Membership.mem (normalClosure F K L) x)","decl":"include splits in\n/-- `normalClosure F K L` is a valid normal closure if `K/F` is algebraic\n  and all minimal polynomials of `K/F` splits in `L/F`. -/\nlemma isNormalClosure_normalClosure : IsNormalClosure F K (normalClosure F K L) := by\n  rw [isNormalClosure_iff]; constructor\n  · rw [normalClosure_eq_iSup_adjoin_of_splits splits]\n    exact fun x ↦ splits_of_splits (splits x) ((IntermediateField.subset_adjoin F _).trans <|\n      SetLike.coe_subset_coe.mpr <| by apply le_iSup _ x)\n  simp_rw [normalClosure, ← top_le_iff]\n  refine fun x _ ↦ ((⨆ f : K →ₐ[F] L, f.fieldRange).val).injective.mem_set_image |>.mp ?_\n  rw [AlgHom.toRingHom_eq_coe, RingHom.coe_coe, coe_val, ← IntermediateField.coe_val,\n    ← IntermediateField.coe_map, IntermediateField.map_iSup]\n  refine (iSup_le fun f ↦ ?_ : normalClosure F K L ≤ _) x.2\n  refine le_iSup_of_le (f.codRestrict _ fun x ↦ f.fieldRange_le_normalClosure ⟨x, rfl⟩) ?_\n  rw [AlgHom.map_fieldRange, val, AlgHom.val_comp_codRestrict]\n\n"}
{"name":"isNormalClosure_normalClosure","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nne : Nonempty (AlgHom F K L)\nh : Normal F L\n⊢ IsNormalClosure F K (Subtype fun x => Membership.mem (normalClosure F K L) x)","decl":"instance isNormalClosure_normalClosure [ne : Nonempty (K →ₐ[F] L)] [h : Normal F L] :\n    IsNormalClosure F K (normalClosure F K L) := by\n  have ⟨φ⟩ := ne\n  apply (h.toIsAlgebraic.of_injective φ φ.injective).isNormalClosure_normalClosure\n  simp_rw [← minpoly.algHom_eq _ φ.injective]\n  exact fun _ ↦ h.splits _\n\n"}
{"name":"normalClosure_eq_iSup_adjoin'","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nne : Nonempty (AlgHom F K L)\nh : Normal F L\n⊢ Eq (normalClosure F K L) (iSup fun x => IntermediateField.adjoin F ((minpoly F x).rootSet L))","decl":"theorem normalClosure_eq_iSup_adjoin' [ne : Nonempty (K →ₐ[F] L)] [h : Normal F L] :\n    normalClosure F K L = ⨆ x : K, adjoin F ((minpoly F x).rootSet L) := by\n  have ⟨φ⟩ := ne\n  refine h.toIsAlgebraic.of_injective φ φ.injective\n    |>.normalClosure_eq_iSup_adjoin_of_splits fun x ↦ ?_\n  rw [← minpoly.algHom_eq _ φ.injective]\n  apply h.splits\n\n"}
{"name":"normalClosure_eq_iSup_adjoin","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁷ : Field F\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra F K\ninst✝³ : Algebra F L\ninst✝² : Algebra K L\ninst✝¹ : IsScalarTower F K L\ninst✝ : Normal F L\n⊢ Eq (normalClosure F K L) (iSup fun x => IntermediateField.adjoin F ((minpoly F x).rootSet L))","decl":"theorem normalClosure_eq_iSup_adjoin [Algebra K L] [IsScalarTower F K L] [Normal F L] :\n    normalClosure F K L = ⨆ x : K, adjoin F ((minpoly F x).rootSet L) :=\n  normalClosure_eq_iSup_adjoin' (ne := ⟨IsScalarTower.toAlgHom F K L⟩)\n\n"}
{"name":"normalClosure.normal","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra F K\ninst✝ : Algebra F L\nh : Normal F L\n⊢ Normal F (Subtype fun x => Membership.mem (normalClosure F K L) x)","decl":"@[stacks 0BMG \"(1) normality.\"]\ninstance normal [h : Normal F L] : Normal F (normalClosure F K L) := by\n  obtain _ | φ := isEmpty_or_nonempty (K →ₐ[F] L)\n  · rw [normalClosure, iSup_of_empty]; exact Normal.of_algEquiv (botEquiv F L).symm\n  · exact (isNormalClosure_normalClosure F K L).normal\n\n"}
{"name":"normalClosure.is_finiteDimensional","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁵ : Field F\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra F K\ninst✝¹ : Algebra F L\ninst✝ : FiniteDimensional F K\n⊢ FiniteDimensional F (Subtype fun x => Membership.mem (normalClosure F K L) x)","decl":"@[stacks 0BMG \"When `L` is normal over `K`, this agrees with 0BMG (1) finiteness.\"]\ninstance is_finiteDimensional [FiniteDimensional F K] :\n    FiniteDimensional F (normalClosure F K L) := by\n  haveI : ∀ f : K →ₐ[F] L, FiniteDimensional F f.fieldRange := fun f ↦\n    f.toLinearMap.finiteDimensional_range\n  apply IntermediateField.finiteDimensional_iSup_of_finite\n\n"}
{"name":"normalClosure.instIsScalarTowerSubtypeMemIntermediateField","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra F K\ninst✝² : Algebra F L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower F K L\n⊢ IsScalarTower F K (Subtype fun x => Membership.mem (normalClosure F K L) x)","decl":"instance : IsScalarTower F K (normalClosure F K L) := by\n  apply of_algebraMap_eq'\n  ext x\n  exact algebraMap_apply F K L x\n\n"}
{"name":"normalClosure.instIsScalarTowerSubtypeMemIntermediateField_1","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra F K\ninst✝² : Algebra F L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower F K L\n⊢ IsScalarTower K (Subtype fun x => Membership.mem (normalClosure F K L) x) L","decl":"instance : IsScalarTower K (normalClosure F K L) L :=\n  of_algebraMap_eq' rfl\n\n"}
{"name":"normalClosure.restrictScalars_eq","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nK : Type u_2\nL : Type u_3\ninst✝⁶ : Field F\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra F K\ninst✝² : Algebra F L\ninst✝¹ : Algebra K L\ninst✝ : IsScalarTower F K L\n⊢ Eq (IntermediateField.restrictScalars F (IsScalarTower.toAlgHom K (Subtype fun x => Membership.mem (normalClosure F K L) x) L).fieldRange) (normalClosure F K L)","decl":"lemma restrictScalars_eq :\n    (toAlgHom K (normalClosure F K L) L).fieldRange.restrictScalars F = normalClosure F K L :=\n  SetLike.ext' Subtype.range_val\n\n"}
{"name":"IntermediateField.le_normalClosure","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝² : Field F\ninst✝¹ : Field L\ninst✝ : Algebra F L\nK : IntermediateField F L\n⊢ LE.le K (normalClosure F (Subtype fun x => Membership.mem K x) L)","decl":"lemma le_normalClosure : K ≤ normalClosure F K L :=\n  K.fieldRange_val.symm.trans_le K.val.fieldRange_le_normalClosure\n\n"}
{"name":"IntermediateField.normalClosure_of_normal","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\nK : IntermediateField F L\ninst✝ : Normal F (Subtype fun x => Membership.mem K x)\n⊢ Eq (normalClosure F (Subtype fun x => Membership.mem K x) L) K","decl":"lemma normalClosure_of_normal [Normal F K] : normalClosure F K L = K := by\n  simp only [normalClosure_def, AlgHom.fieldRange_of_normal, iSup_const]\n\n"}
{"name":"IntermediateField.normalClosure_def'","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\nK : IntermediateField F L\ninst✝ : Normal F L\n⊢ Eq (normalClosure F (Subtype fun x => Membership.mem K x) L) (iSup fun f => IntermediateField.map f K)","decl":"lemma normalClosure_def' : normalClosure F K L = ⨆ f : L →ₐ[F] L, K.map f := by\n  refine (normalClosure_def F K L).trans (le_antisymm (iSup_le (fun f ↦ ?_)) (iSup_le (fun f ↦ ?_)))\n  · exact le_iSup_of_le (f.liftNormal L) (fun b ⟨a, h⟩ ↦ ⟨a, a.2, h ▸ f.liftNormal_commutes L a⟩)\n  · exact le_iSup_of_le (f.comp K.val) (fun b ⟨a, h⟩ ↦ ⟨⟨a, h.1⟩, h.2⟩)\n\n"}
{"name":"IntermediateField.normalClosure_def''","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\nK : IntermediateField F L\ninst✝ : Normal F L\n⊢ Eq (normalClosure F (Subtype fun x => Membership.mem K x) L) (iSup fun f => IntermediateField.map (↑f) K)","decl":"lemma normalClosure_def'' : normalClosure F K L = ⨆ f : L ≃ₐ[F] L, K.map f := by\n  refine (normalClosure_def' K).trans (le_antisymm (iSup_le (fun f ↦ ?_)) (iSup_le (fun f ↦ ?_)))\n  · exact le_iSup_of_le (f.restrictNormal' L)\n      (fun b ⟨a, h⟩ ↦ ⟨a, h.1, h.2 ▸ f.restrictNormal_commutes L a⟩)\n  · exact le_iSup_of_le f le_rfl\n\n"}
{"name":"IntermediateField.normalClosure_mono","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\nK K' : IntermediateField F L\ninst✝ : Normal F L\nh : LE.le K K'\n⊢ LE.le (normalClosure F (Subtype fun x => Membership.mem K x) L) (normalClosure F (Subtype fun x => Membership.mem K' x) L)","decl":"lemma normalClosure_mono (h : K ≤ K') : normalClosure F K L ≤ normalClosure F K' L := by\n  rw [normalClosure_def', normalClosure_def']\n  exact iSup_mono (fun f ↦ map_mono f h)\n\n"}
{"name":"IntermediateField.closureOperator_isClosed","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nx : IntermediateField F L\n⊢ Eq ((IntermediateField.closureOperator F L).IsClosed x) (Eq (normalClosure F (Subtype fun x_1 => Membership.mem x x_1) L) x)","decl":"/-- `normalClosure` as a `ClosureOperator`. -/\n@[simps]\nnoncomputable def closureOperator : ClosureOperator (IntermediateField F L) where\n  toFun := fun K ↦ normalClosure F K L\n  monotone' := fun K K' ↦ normalClosure_mono K K'\n  le_closure' := le_normalClosure\n  idempotent' := fun K ↦ normalClosure_of_normal (normalClosure F K L)\n\n"}
{"name":"IntermediateField.closureOperator_apply","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Eq ((IntermediateField.closureOperator F L) K) (normalClosure F (Subtype fun x => Membership.mem K x) L)","decl":"/-- `normalClosure` as a `ClosureOperator`. -/\n@[simps]\nnoncomputable def closureOperator : ClosureOperator (IntermediateField F L) where\n  toFun := fun K ↦ normalClosure F K L\n  monotone' := fun K K' ↦ normalClosure_mono K K'\n  le_closure' := le_normalClosure\n  idempotent' := fun K ↦ normalClosure_of_normal (normalClosure F K L)\n\n"}
{"name":"IntermediateField.normal_iff_normalClosure_eq","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (Eq (normalClosure F (Subtype fun x => Membership.mem K x) L) K)","decl":"lemma normal_iff_normalClosure_eq : Normal F K ↔ normalClosure F K L = K :=\n⟨@normalClosure_of_normal (K := K), fun h ↦ h ▸ normalClosure.normal F K L⟩\n\n"}
{"name":"IntermediateField.normal_iff_normalClosure_le","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (LE.le (normalClosure F (Subtype fun x => Membership.mem K x) L) K)","decl":"lemma normal_iff_normalClosure_le : Normal F K ↔ normalClosure F K L ≤ K :=\nnormal_iff_normalClosure_eq.trans (le_normalClosure K).le_iff_eq.symm\n\n"}
{"name":"IntermediateField.normal_iff_forall_fieldRange_le","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (∀ (σ : AlgHom F (Subtype fun x => Membership.mem K x) L), LE.le σ.fieldRange K)","decl":"lemma normal_iff_forall_fieldRange_le : Normal F K ↔ ∀ σ : K →ₐ[F] L, σ.fieldRange ≤ K := by\n  rw [normal_iff_normalClosure_le, normalClosure_def, iSup_le_iff]\n\n"}
{"name":"IntermediateField.normal_iff_forall_map_le","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (∀ (σ : AlgHom F L L), LE.le (IntermediateField.map σ K) K)","decl":"lemma normal_iff_forall_map_le : Normal F K ↔ ∀ σ : L →ₐ[F] L, K.map σ ≤ K := by\n  rw [normal_iff_normalClosure_le, normalClosure_def', iSup_le_iff]\n\n"}
{"name":"IntermediateField.normal_iff_forall_map_le'","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (∀ (σ : AlgEquiv F L L), LE.le (IntermediateField.map (↑σ) K) K)","decl":"lemma normal_iff_forall_map_le' : Normal F K ↔ ∀ σ : L ≃ₐ[F] L, K.map ↑σ ≤ K := by\n  rw [normal_iff_normalClosure_le, normalClosure_def'', iSup_le_iff]\n\n"}
{"name":"IntermediateField.normal_iff_forall_fieldRange_eq","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (∀ (σ : AlgHom F (Subtype fun x => Membership.mem K x) L), Eq σ.fieldRange K)","decl":"/-- If `L/K/F` is a field tower where `L/F` is normal, then\n`K` is normal over `F` if and only if `σ(K) = K` for every `σ ∈ K →ₐ[F] L`. -/\n@[stacks 09HQ \"stronger version replacing an algebraic closure by a normal extension\"]\nlemma normal_iff_forall_fieldRange_eq : Normal F K ↔ ∀ σ : K →ₐ[F] L, σ.fieldRange = K :=\n⟨@AlgHom.fieldRange_of_normal (E := K), normal_iff_forall_fieldRange_le.2 ∘ fun h σ ↦ (h σ).le⟩\n\n"}
{"name":"IntermediateField.normal_iff_forall_map_eq","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (∀ (σ : AlgHom F L L), Eq (IntermediateField.map σ K) K)","decl":"lemma normal_iff_forall_map_eq : Normal F K ↔ ∀ σ : L →ₐ[F] L, K.map σ = K :=\n⟨fun h σ ↦ (K.fieldRange_val ▸ AlgHom.map_fieldRange K.val σ).trans\n  (normal_iff_forall_fieldRange_eq.1 h _), fun h ↦ normal_iff_forall_map_le.2 (fun σ ↦ (h σ).le)⟩\n\n"}
{"name":"IntermediateField.normal_iff_forall_map_eq'","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\n⊢ Iff (Normal F (Subtype fun x => Membership.mem K x)) (∀ (σ : AlgEquiv F L L), Eq (IntermediateField.map (↑σ) K) K)","decl":"lemma normal_iff_forall_map_eq' : Normal F K ↔ ∀ σ : L ≃ₐ[F] L, K.map ↑σ = K :=\n⟨fun h σ ↦ normal_iff_forall_map_eq.1 h σ, fun h ↦ normal_iff_forall_map_le'.2 (fun σ ↦ (h σ).le)⟩\n\n"}
{"name":"IntermediateField.normalClosure_map_eq","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝³ : Field F\ninst✝² : Field L\ninst✝¹ : Algebra F L\ninst✝ : Normal F L\nK : IntermediateField F L\nσ : AlgHom F L L\n⊢ Eq (normalClosure F (Subtype fun x => Membership.mem (IntermediateField.map σ K) x) L) (normalClosure F (Subtype fun x => Membership.mem K x) L)","decl":"@[simp]\nlemma normalClosure_map_eq (K : IntermediateField F L) (σ : L →ₐ[F] L) :\n    normalClosure F (K.map σ) L = normalClosure F K L := by\n  have (σ : L ≃ₐ[F] L) : normalClosure F (K.map (σ : L →ₐ[F] L)) L = normalClosure F K L := by\n    simp_rw [normalClosure_def'', map_map]\n    exact (Equiv.mulRight σ).iSup_congr fun _ ↦ rfl\n  exact this ((Algebra.IsAlgebraic.algEquivEquivAlgHom _ _).symm σ)\n\n"}
{"name":"IntermediateField.normalClosure_le_iff_of_normal","module":"Mathlib.FieldTheory.Normal.Closure","initialProofState":"F : Type u_1\nL : Type u_3\ninst✝⁴ : Field F\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Normal F L\nK₁ K₂ : IntermediateField F L\ninst✝ : Normal F (Subtype fun x => Membership.mem K₂ x)\n⊢ Iff (LE.le (normalClosure F (Subtype fun x => Membership.mem K₁ x) L) K₂) (LE.le K₁ K₂)","decl":"@[simp]\ntheorem normalClosure_le_iff_of_normal {K₁ K₂ : IntermediateField F L} [Normal F K₂] :\n    normalClosure F K₁ L ≤ K₂ ↔ K₁ ≤ K₂ := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rw [normalClosure_le_iff] at h\n    simpa only [fieldRange_val] using h K₁.val\n  · rw [← normalClosure_of_normal K₂]\n    exact normalClosure_mono K₁ K₂ h\n\n"}
