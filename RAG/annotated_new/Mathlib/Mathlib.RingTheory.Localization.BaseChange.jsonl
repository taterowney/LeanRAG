{"name":"IsLocalizedModule.isBaseChange","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝⁹ : CommSemiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : IsLocalization S A\nM : Type u_3\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nM' : Type u_4\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\ninst✝² : Module A M'\ninst✝¹ : IsScalarTower R A M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ IsBaseChange A f","decl":"/-- The forward direction of `isLocalizedModule_iff_isBaseChange`. It is also used to prove the\nother direction. -/\ntheorem IsLocalizedModule.isBaseChange [IsLocalizedModule S f] : IsBaseChange A f :=\n  .of_lift_unique _ fun Q _ _ _ _ g ↦ by\n    obtain ⟨ℓ, rfl, h₂⟩ := IsLocalizedModule.is_universal S f g fun s ↦ by\n      rw [← (Algebra.lsmul R (A := A) R Q).commutes]; exact (IsLocalization.map_units A s).map _\n    refine ⟨ℓ.extendScalarsOfIsLocalization S A, by simp, fun g'' h ↦ ?_⟩\n    cases h₂ (LinearMap.restrictScalars R g'') h; rfl\n\n"}
{"name":"isLocalizedModule_iff_isBaseChange","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝⁹ : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : IsLocalization S A\nM : Type u_3\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\nM' : Type u_4\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M'\ninst✝¹ : Module A M'\ninst✝ : IsScalarTower R A M'\nf : LinearMap (RingHom.id R) M M'\n⊢ Iff (IsLocalizedModule S f) (IsBaseChange A f)","decl":"/-- The map `(f : M →ₗ[R] M')` is a localization of modules iff the map\n`(Localization S) × M → N, (s, m) ↦ s • f m` is the tensor product (insomuch as it is the universal\nbilinear map).\nIn particular, there is an isomorphism between `LocalizedModule S M` and `(Localization S) ⊗[R] M`\ngiven by `m/s ↦ (1/s) ⊗ₜ m`.\n-/\ntheorem isLocalizedModule_iff_isBaseChange : IsLocalizedModule S f ↔ IsBaseChange A f := by\n  refine ⟨fun _ ↦ IsLocalizedModule.isBaseChange S A f, fun h ↦ ?_⟩\n  have : IsBaseChange A (LocalizedModule.mkLinearMap S M) := IsLocalizedModule.isBaseChange S A _\n  let e := (this.equiv.symm.trans h.equiv).restrictScalars R\n  convert IsLocalizedModule.of_linearEquiv S (LocalizedModule.mkLinearMap S M) e\n  ext\n  rw [LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n    LinearEquiv.restrictScalars_apply, LinearEquiv.trans_apply, IsBaseChange.equiv_symm_apply,\n    IsBaseChange.equiv_tmul, one_smul]\n\n"}
{"name":"IsLocalization.tensorProduct_isLocalizedModule","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝⁴ : CommSemiring A\ninst✝³ : Algebra R A\ninst✝² : IsLocalization S A\nM : Type u_3\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ IsLocalizedModule S ((TensorProduct.mk R A M) 1)","decl":"instance tensorProduct_isLocalizedModule : IsLocalizedModule S (TensorProduct.mk R A M 1) :=\n  (isLocalizedModule_iff_isBaseChange _ A _).mpr (TensorProduct.isBaseChange _ _ _)\n\n"}
{"name":"IsLocalization.tensorProduct_compatibleSMul","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝¹⁰ : CommSemiring A\ninst✝⁹ : Algebra R A\ninst✝⁸ : IsLocalization S A\nM₁ : Type u_5\nM₂ : Type u_6\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : Module R M₁\ninst✝⁴ : Module R M₂\ninst✝³ : Module A M₁\ninst✝² : Module A M₂\ninst✝¹ : IsScalarTower R A M₁\ninst✝ : IsScalarTower R A M₂\n⊢ TensorProduct.CompatibleSMul R A M₁ M₂","decl":"theorem tensorProduct_compatibleSMul : CompatibleSMul R A M₁ M₂ where\n  smul_tmul a _ _ := by\n    obtain ⟨r, s, rfl⟩ := mk'_surjective S a\n    rw [← (map_units A s).smul_left_cancel]\n    simp_rw [algebraMap_smul, smul_tmul', ← smul_assoc, smul_tmul, ← smul_assoc, smul_mk'_self,\n      algebraMap_smul, smul_tmul]\n\n"}
{"name":"IsLocalization.bijective_linearMap_mul'","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝² : CommSemiring A\ninst✝¹ : Algebra R A\ninst✝ : IsLocalization S A\n⊢ Function.Bijective ⇑(LinearMap.mul' R A)","decl":"set_option linter.docPrime false in\ntheorem bijective_linearMap_mul' : Function.Bijective (LinearMap.mul' R A) :=\n  have := tensorProduct_compatibleSMul S A A A\n  (Algebra.TensorProduct.lmulEquiv R A).bijective\n\n"}
{"name":"Algebra.isPushout_of_isLocalization","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝¹¹ : CommSemiring A\ninst✝¹⁰ : Algebra R A\ninst✝⁹ : IsLocalization S A\nT : Type u_5\nB : Type u_6\ninst✝⁸ : CommSemiring T\ninst✝⁷ : CommSemiring B\ninst✝⁶ : Algebra R T\ninst✝⁵ : Algebra T B\ninst✝⁴ : Algebra R B\ninst✝³ : Algebra A B\ninst✝² : IsScalarTower R T B\ninst✝¹ : IsScalarTower R A B\ninst✝ : IsLocalization (Algebra.algebraMapSubmonoid T S) B\n⊢ Algebra.IsPushout R T A B","decl":"lemma Algebra.isPushout_of_isLocalization [IsLocalization (Algebra.algebraMapSubmonoid T S) B] :\n    Algebra.IsPushout R T A B := by\n  rw [Algebra.IsPushout.comm, Algebra.isPushout_iff]\n  apply IsLocalizedModule.isBaseChange S\n\n"}
{"name":"instIsLocalizedModuleFinsuppLinearMap","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_7\nM : Type u_8\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nα : Type u_9\nS : Submonoid R\nMₛ : Type u_10\ninst✝² : AddCommGroup Mₛ\ninst✝¹ : Module R Mₛ\nf : LinearMap (RingHom.id R) M Mₛ\ninst✝ : IsLocalizedModule S f\n⊢ IsLocalizedModule S (Finsupp.mapRange.linearMap f)","decl":"open TensorProduct in\ninstance (R M : Type*) [CommRing R] [AddCommGroup M] [Module R M]\n    {α} (S : Submonoid R) {Mₛ} [AddCommGroup Mₛ] [Module R Mₛ] (f : M →ₗ[R] Mₛ)\n    [IsLocalizedModule S f] : IsLocalizedModule S (Finsupp.mapRange.linearMap (α := α) f) := by\n  classical\n  let e : Localization S ⊗[R] M ≃ₗ[R] Mₛ :=\n    (IsLocalizedModule.isBaseChange S (Localization S)\n      (LocalizedModule.mkLinearMap S M)).equiv.restrictScalars R ≪≫ₗ IsLocalizedModule.iso S f\n  let e' : Localization S ⊗[R] (α →₀ M) ≃ₗ[R] (α →₀ Mₛ) :=\n    finsuppRight R (Localization S) M α ≪≫ₗ Finsupp.mapRange.linearEquiv e\n  suffices IsLocalizedModule S (e'.symm.toLinearMap ∘ₗ Finsupp.mapRange.linearMap f) by\n    convert this.of_linearEquiv (e := e')\n    ext\n    simp\n  rw [isLocalizedModule_iff_isBaseChange S (Localization S)]\n  convert TensorProduct.isBaseChange R (α →₀ M) (Localization S) using 1\n  ext a m\n  apply (finsuppRight R (Localization S) M α).injective\n  ext b\n  apply e.injective\n  suffices (if a = b then f m else 0) = e (1 ⊗ₜ[R] if a = b then m else 0) by\n    simpa [e', Finsupp.single_apply, -EmbeddingLike.apply_eq_iff_eq, apply_ite e]\n  split_ifs with h\n  · simp [e, IsBaseChange.equiv_tmul]\n  · simp only [tmul_zero, LinearEquiv.trans_apply, LinearEquiv.restrictScalars_apply, map_zero]\n\n"}
{"name":"IsLocalizedModule.rTensor","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nA : Type u_2\ninst✝¹¹ : CommSemiring A\ninst✝¹⁰ : Algebra R A\nM : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nM' : Type u_4\ninst✝⁷ : AddCommMonoid M'\ninst✝⁶ : Module R M'\ninst✝⁵ : Module A M'\ninst✝⁴ : IsScalarTower R A M'\nS : Submonoid A\nN : Type u_7\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\ng : LinearMap (RingHom.id A) M M'\nh : IsLocalizedModule S g\n⊢ IsLocalizedModule S ((TensorProduct.AlgebraTensorModule.rTensor R N) g)","decl":"/-- `S⁻¹M ⊗[R] N = S⁻¹(M ⊗[R] N)`. -/\ninstance IsLocalizedModule.rTensor (g : M →ₗ[A] M') [h : IsLocalizedModule S g] :\n    IsLocalizedModule S (AlgebraTensorModule.rTensor R N g) := by\n  let Aₚ := Localization S\n  letI : Module Aₚ M' := (IsLocalizedModule.iso S g).symm.toAddEquiv.module Aₚ\n  haveI : IsScalarTower A Aₚ M' := (IsLocalizedModule.iso S g).symm.isScalarTower Aₚ\n  haveI : IsScalarTower R Aₚ M' :=\n    IsScalarTower.of_algebraMap_smul <| fun r x ↦ by simp [IsScalarTower.algebraMap_apply R A Aₚ]\n  rw [isLocalizedModule_iff_isBaseChange (S := S) (A := Aₚ)] at h ⊢\n  exact isBaseChange_tensorProduct_map _ h\n\n"}
{"name":"IsLocalizedModule.map_lTensor","module":"Mathlib.RingTheory.Localization.BaseChange","initialProofState":"R : Type u_1\ninst✝¹⁴ : CommSemiring R\nA : Type u_2\ninst✝¹³ : CommSemiring A\ninst✝¹² : Algebra R A\nM : Type u_3\ninst✝¹¹ : AddCommMonoid M\ninst✝¹⁰ : Module R M\nM' : Type u_4\ninst✝⁹ : AddCommMonoid M'\ninst✝⁸ : Module R M'\ninst✝⁷ : Module A M'\ninst✝⁶ : IsScalarTower R A M'\nS : Submonoid A\nN : Type u_7\ninst✝⁵ : AddCommMonoid N\ninst✝⁴ : Module R N\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\nP : Type u_8\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) N P\ng : LinearMap (RingHom.id A) M M'\nh : IsLocalizedModule S g\n⊢ Eq ((IsLocalizedModule.map S ((TensorProduct.AlgebraTensorModule.rTensor R N) g) ((TensorProduct.AlgebraTensorModule.rTensor R P) g)) ((TensorProduct.AlgebraTensorModule.lTensor A M) f)) ((TensorProduct.AlgebraTensorModule.lTensor A M') f)","decl":"lemma IsLocalizedModule.map_lTensor (g : M →ₗ[A] M') [h : IsLocalizedModule S g] :\n    IsLocalizedModule.map S (AlgebraTensorModule.rTensor R N g) (AlgebraTensorModule.rTensor R P g)\n      (AlgebraTensorModule.lTensor A M f) = AlgebraTensorModule.lTensor A M' f := by\n  apply linearMap_ext S (AlgebraTensorModule.rTensor R N g) (AlgebraTensorModule.rTensor R P g)\n  rw [map_comp]\n  ext\n  simp\n\n"}
