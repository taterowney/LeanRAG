{"name":"Fin.insertNth_one_right","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → One (α j)\ni : Fin (HAdd.hAdd n 1)\nx : α i\n⊢ Eq (i.insertNth x 1) (Pi.mulSingle i x)","decl":"@[to_additive (attr := simp)]\nlemma insertNth_one_right [∀ j, One (α j)] (i : Fin (n + 1)) (x : α i) :\n    i.insertNth x 1 = Pi.mulSingle i x :=\n  insertNth_eq_iff.2 <| by unfold removeNth; simp [succAbove_ne, Pi.one_def]\n\n"}
{"name":"Fin.insertNth_zero_right","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → Zero (α j)\ni : Fin (HAdd.hAdd n 1)\nx : α i\n⊢ Eq (i.insertNth x 0) (Pi.single i x)","decl":"@[to_additive (attr := simp)]\nlemma insertNth_one_right [∀ j, One (α j)] (i : Fin (n + 1)) (x : α i) :\n    i.insertNth x 1 = Pi.mulSingle i x :=\n  insertNth_eq_iff.2 <| by unfold removeNth; simp [succAbove_ne, Pi.one_def]\n\n"}
{"name":"Fin.insertNth_mul","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → Mul (α j)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np q : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (i.insertNth (HMul.hMul x y) (HMul.hMul p q)) (HMul.hMul (i.insertNth x p) (i.insertNth y q))","decl":"@[to_additive (attr := simp)]\nlemma insertNth_mul [∀ j, Mul (α j)] (i : Fin (n + 1)) (x y : α i) (p q : ∀ j, α (i.succAbove j)) :\n    i.insertNth (x * y) (p * q) = i.insertNth x p * i.insertNth y q :=\n  insertNth_binop (fun _ ↦ (· * ·)) i x y p q\n\n"}
{"name":"Fin.insertNth_add","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → Add (α j)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np q : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (i.insertNth (HAdd.hAdd x y) (HAdd.hAdd p q)) (HAdd.hAdd (i.insertNth x p) (i.insertNth y q))","decl":"@[to_additive (attr := simp)]\nlemma insertNth_mul [∀ j, Mul (α j)] (i : Fin (n + 1)) (x y : α i) (p q : ∀ j, α (i.succAbove j)) :\n    i.insertNth (x * y) (p * q) = i.insertNth x p * i.insertNth y q :=\n  insertNth_binop (fun _ ↦ (· * ·)) i x y p q\n\n"}
{"name":"Fin.insertNth_sub","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → Sub (α j)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np q : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (i.insertNth (HSub.hSub x y) (HSub.hSub p q)) (HSub.hSub (i.insertNth x p) (i.insertNth y q))","decl":"@[to_additive (attr := simp)]\nlemma insertNth_div [∀ j, Div (α j)] (i : Fin (n + 1)) (x y : α i)(p q : ∀ j, α (i.succAbove j)) :\n    i.insertNth (x / y) (p / q) = i.insertNth x p / i.insertNth y q :=\n  insertNth_binop (fun _ ↦ (· / ·)) i x y p q\n\n"}
{"name":"Fin.insertNth_div","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → Div (α j)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np q : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (i.insertNth (HDiv.hDiv x y) (HDiv.hDiv p q)) (HDiv.hDiv (i.insertNth x p) (i.insertNth y q))","decl":"@[to_additive (attr := simp)]\nlemma insertNth_div [∀ j, Div (α j)] (i : Fin (n + 1)) (x y : α i)(p q : ∀ j, α (i.succAbove j)) :\n    i.insertNth (x / y) (p / q) = i.insertNth x p / i.insertNth y q :=\n  insertNth_binop (fun _ ↦ (· / ·)) i x y p q\n\n"}
{"name":"Fin.insertNth_sub_same","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → AddGroup (α j)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (HSub.hSub (i.insertNth x p) (i.insertNth y p)) (Pi.single i (HSub.hSub x y))","decl":"@[to_additive (attr := simp)]\nlemma insertNth_div_same [∀ j, Group (α j)] (i : Fin (n + 1)) (x y : α i)\n    (p : ∀ j, α (i.succAbove j)) : i.insertNth x p / i.insertNth y p = Pi.mulSingle i (x / y) := by\n  simp_rw [← insertNth_div, ← insertNth_one_right, Pi.div_def, div_self', Pi.one_def]\n\n"}
{"name":"Fin.insertNth_div_same","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"n : Nat\nα : Fin (HAdd.hAdd n 1) → Type u_1\ninst✝ : (j : Fin (HAdd.hAdd n 1)) → Group (α j)\ni : Fin (HAdd.hAdd n 1)\nx y : α i\np : (j : Fin n) → α (i.succAbove j)\n⊢ Eq (HDiv.hDiv (i.insertNth x p) (i.insertNth y p)) (Pi.mulSingle i (HDiv.hDiv x y))","decl":"@[to_additive (attr := simp)]\nlemma insertNth_div_same [∀ j, Group (α j)] (i : Fin (n + 1)) (x y : α i)\n    (p : ∀ j, α (i.succAbove j)) : i.insertNth x p / i.insertNth y p = Pi.mulSingle i (x / y) := by\n  simp_rw [← insertNth_div, ← insertNth_one_right, Pi.div_def, div_self', Pi.one_def]\n\n"}
{"name":"Matrix.smul_empty","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : SMul M α\nx : M\nv : Fin 0 → α\n⊢ Eq (HSMul.hSMul x v) Matrix.vecEmpty","decl":"@[simp] lemma smul_empty (x : M) (v : Fin 0 → α) : x • v = ![] := empty_eq _\n\n"}
{"name":"Matrix.smul_cons","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nM : Type u_2\nn : Nat\ninst✝ : SMul M α\nx : M\ny : α\nv : Fin n → α\n⊢ Eq (HSMul.hSMul x (Matrix.vecCons y v)) (Matrix.vecCons (HSMul.hSMul x y) (HSMul.hSMul x v))","decl":"@[simp] lemma smul_cons (x : M) (y : α) (v : Fin n → α) :\n    x • vecCons y v = vecCons (x • y) (x • v) := by ext i; refine i.cases ?_ ?_ <;> simp\n\n"}
{"name":"Matrix.empty_add_empty","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Add α\nv w : Fin 0 → α\n⊢ Eq (HAdd.hAdd v w) Matrix.vecEmpty","decl":"@[simp] lemma empty_add_empty (v w : Fin 0 → α) : v + w = ![] := empty_eq _\n\n"}
{"name":"Matrix.cons_add","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Add α\nx : α\nv : Fin n → α\nw : Fin n.succ → α\n⊢ Eq (HAdd.hAdd (Matrix.vecCons x v) w) (Matrix.vecCons (HAdd.hAdd x (Matrix.vecHead w)) (HAdd.hAdd v (Matrix.vecTail w)))","decl":"@[simp] lemma cons_add (x : α) (v : Fin n → α) (w : Fin n.succ → α) :\n    vecCons x v + w = vecCons (x + vecHead w) (v + vecTail w) := by\n  ext i; refine i.cases ?_ ?_ <;> simp [vecHead, vecTail]\n\n"}
{"name":"Matrix.add_cons","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Add α\nv : Fin n.succ → α\ny : α\nw : Fin n → α\n⊢ Eq (HAdd.hAdd v (Matrix.vecCons y w)) (Matrix.vecCons (HAdd.hAdd (Matrix.vecHead v) y) (HAdd.hAdd (Matrix.vecTail v) w))","decl":"@[simp] lemma add_cons (v : Fin n.succ → α) (y : α) (w : Fin n → α) :\n    v + vecCons y w = vecCons (vecHead v + y) (vecTail v + w) := by\n  ext i; refine i.cases ?_ ?_ <;> simp [vecHead, vecTail]\n\n"}
{"name":"Matrix.cons_add_cons","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Add α\nx : α\nv : Fin n → α\ny : α\nw : Fin n → α\n⊢ Eq (HAdd.hAdd (Matrix.vecCons x v) (Matrix.vecCons y w)) (Matrix.vecCons (HAdd.hAdd x y) (HAdd.hAdd v w))","decl":"lemma cons_add_cons (x : α) (v : Fin n → α) (y : α) (w : Fin n → α) :\n    vecCons x v + vecCons y w = vecCons (x + y) (v + w) := by simp\n\n"}
{"name":"Matrix.head_add","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Add α\na b : Fin n.succ → α\n⊢ Eq (Matrix.vecHead (HAdd.hAdd a b)) (HAdd.hAdd (Matrix.vecHead a) (Matrix.vecHead b))","decl":"@[simp] lemma head_add (a b : Fin n.succ → α) : vecHead (a + b) = vecHead a + vecHead b := rfl\n\n"}
{"name":"Matrix.tail_add","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Add α\na b : Fin n.succ → α\n⊢ Eq (Matrix.vecTail (HAdd.hAdd a b)) (HAdd.hAdd (Matrix.vecTail a) (Matrix.vecTail b))","decl":"@[simp] lemma tail_add (a b : Fin n.succ → α) : vecTail (a + b) = vecTail a + vecTail b := rfl\n\n"}
{"name":"Matrix.empty_sub_empty","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Sub α\nv w : Fin 0 → α\n⊢ Eq (HSub.hSub v w) Matrix.vecEmpty","decl":"@[simp] lemma empty_sub_empty (v w : Fin 0 → α) : v - w = ![] := empty_eq _\n\n"}
{"name":"Matrix.cons_sub","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Sub α\nx : α\nv : Fin n → α\nw : Fin n.succ → α\n⊢ Eq (HSub.hSub (Matrix.vecCons x v) w) (Matrix.vecCons (HSub.hSub x (Matrix.vecHead w)) (HSub.hSub v (Matrix.vecTail w)))","decl":"@[simp] lemma cons_sub (x : α) (v : Fin n → α) (w : Fin n.succ → α) :\n    vecCons x v - w = vecCons (x - vecHead w) (v - vecTail w) := by\n  ext i; refine i.cases ?_ ?_ <;> simp [vecHead, vecTail]\n\n"}
{"name":"Matrix.sub_cons","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Sub α\nv : Fin n.succ → α\ny : α\nw : Fin n → α\n⊢ Eq (HSub.hSub v (Matrix.vecCons y w)) (Matrix.vecCons (HSub.hSub (Matrix.vecHead v) y) (HSub.hSub (Matrix.vecTail v) w))","decl":"@[simp] lemma sub_cons (v : Fin n.succ → α) (y : α) (w : Fin n → α) :\n    v - vecCons y w = vecCons (vecHead v - y) (vecTail v - w) := by\n  ext i; refine i.cases ?_ ?_ <;> simp [vecHead, vecTail]\n\n"}
{"name":"Matrix.cons_sub_cons","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Sub α\nx : α\nv : Fin n → α\ny : α\nw : Fin n → α\n⊢ Eq (HSub.hSub (Matrix.vecCons x v) (Matrix.vecCons y w)) (Matrix.vecCons (HSub.hSub x y) (HSub.hSub v w))","decl":"lemma cons_sub_cons (x : α) (v : Fin n → α) (y : α) (w : Fin n → α) :\n    vecCons x v - vecCons y w = vecCons (x - y) (v - w) := by simp\n\n"}
{"name":"Matrix.head_sub","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Sub α\na b : Fin n.succ → α\n⊢ Eq (Matrix.vecHead (HSub.hSub a b)) (HSub.hSub (Matrix.vecHead a) (Matrix.vecHead b))","decl":"@[simp] lemma head_sub (a b : Fin n.succ → α) : vecHead (a - b) = vecHead a - vecHead b := rfl\n\n"}
{"name":"Matrix.tail_sub","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Sub α\na b : Fin n.succ → α\n⊢ Eq (Matrix.vecTail (HSub.hSub a b)) (HSub.hSub (Matrix.vecTail a) (Matrix.vecTail b))","decl":"@[simp] lemma tail_sub (a b : Fin n.succ → α) : vecTail (a - b) = vecTail a - vecTail b := rfl\n\n"}
{"name":"Matrix.zero_empty","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Zero α\n⊢ Eq 0 Matrix.vecEmpty","decl":"@[simp] lemma zero_empty : (0 : Fin 0 → α) = ![] := empty_eq _\n\n"}
{"name":"Matrix.cons_zero_zero","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Zero α\n⊢ Eq (Matrix.vecCons 0 0) 0","decl":"@[simp] lemma cons_zero_zero : vecCons (0 : α) (0 : Fin n → α) = 0 := by\n  ext i; exact i.cases rfl (by simp)\n\n"}
{"name":"Matrix.head_zero","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Zero α\n⊢ Eq (Matrix.vecHead 0) 0","decl":"@[simp] lemma head_zero : vecHead (0 : Fin n.succ → α) = 0 := rfl\n\n"}
{"name":"Matrix.tail_zero","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Zero α\n⊢ Eq (Matrix.vecTail 0) 0","decl":"@[simp] lemma tail_zero : vecTail (0 : Fin n.succ → α) = 0 := rfl\n\n"}
{"name":"Matrix.cons_eq_zero_iff","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Zero α\nv : Fin n → α\nx : α\n⊢ Iff (Eq (Matrix.vecCons x v) 0) (And (Eq x 0) (Eq v 0))","decl":"@[simp] lemma cons_eq_zero_iff {v : Fin n → α} {x : α} : vecCons x v = 0 ↔ x = 0 ∧ v = 0 where\n  mp h := ⟨congr_fun h 0, by convert congr_arg vecTail h⟩\n  mpr := fun ⟨hx, hv⟩ ↦ by simp [hx, hv]\n\n"}
{"name":"Matrix.cons_nonzero_iff","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Zero α\nv : Fin n → α\nx : α\n⊢ Iff (Ne (Matrix.vecCons x v) 0) (Or (Ne x 0) (Ne v 0))","decl":"lemma cons_nonzero_iff {v : Fin n → α} {x : α} : vecCons x v ≠ 0 ↔ x ≠ 0 ∨ v ≠ 0 where\n  mp h := not_and_or.mp (h ∘ cons_eq_zero_iff.mpr)\n  mpr h := mt cons_eq_zero_iff.mp (not_and_or.mpr h)\n\n"}
{"name":"Matrix.neg_empty","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\ninst✝ : Neg α\nv : Fin 0 → α\n⊢ Eq (Neg.neg v) Matrix.vecEmpty","decl":"@[simp] lemma neg_empty (v : Fin 0 → α) : -v = ![] := empty_eq _\n\n"}
{"name":"Matrix.neg_cons","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Neg α\nx : α\nv : Fin n → α\n⊢ Eq (Neg.neg (Matrix.vecCons x v)) (Matrix.vecCons (Neg.neg x) (Neg.neg v))","decl":"@[simp] lemma neg_cons (x : α) (v : Fin n → α) : -vecCons x v = vecCons (-x) (-v) := by\n  ext i; refine i.cases ?_ ?_ <;> simp\n\n"}
{"name":"Matrix.head_neg","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Neg α\na : Fin n.succ → α\n⊢ Eq (Matrix.vecHead (Neg.neg a)) (Neg.neg (Matrix.vecHead a))","decl":"@[simp] lemma head_neg (a : Fin n.succ → α) : vecHead (-a) = -vecHead a := rfl\n\n"}
{"name":"Matrix.tail_neg","module":"Mathlib.Algebra.Group.Fin.Tuple","initialProofState":"α : Type u_1\nn : Nat\ninst✝ : Neg α\na : Fin n.succ → α\n⊢ Eq (Matrix.vecTail (Neg.neg a)) (Neg.neg (Matrix.vecTail a))","decl":"@[simp] lemma tail_neg (a : Fin n.succ → α) : vecTail (-a) = -vecTail a := rfl\n\n"}
