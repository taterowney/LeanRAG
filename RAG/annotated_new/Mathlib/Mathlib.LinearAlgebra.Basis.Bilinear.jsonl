{"name":"LinearMap.ext_basis","module":"Mathlib.LinearAlgebra.Basis.Bilinear","initialProofState":"ι₁ : Type u_1\nι₂ : Type u_2\nR : Type u_3\nR₂ : Type u_4\nS : Type u_5\nS₂ : Type u_6\nM : Type u_7\nN : Type u_8\nP : Type u_9\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring S\ninst✝⁹ : Semiring R₂\ninst✝⁸ : Semiring S₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M\ninst✝³ : Module S N\ninst✝² : Module R₂ P\ninst✝¹ : Module S₂ P\ninst✝ : SMulCommClass S₂ R₂ P\nρ₁₂ : RingHom R R₂\nσ₁₂ : RingHom S S₂\nb₁ : Basis ι₁ R M\nb₂ : Basis ι₂ S N\nB B' : LinearMap ρ₁₂ M (LinearMap σ₁₂ N P)\nh : ∀ (i : ι₁) (j : ι₂), Eq ((B (b₁ i)) (b₂ j)) ((B' (b₁ i)) (b₂ j))\n⊢ Eq B B'","decl":"/-- Two bilinear maps are equal when they are equal on all basis vectors. -/\ntheorem ext_basis {B B' : M →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (h : ∀ i j, B (b₁ i) (b₂ j) = B' (b₁ i) (b₂ j)) :\n    B = B' :=\n  b₁.ext fun i => b₂.ext fun j => h i j\n\n"}
{"name":"LinearMap.sum_repr_mul_repr_mulₛₗ","module":"Mathlib.LinearAlgebra.Basis.Bilinear","initialProofState":"ι₁ : Type u_1\nι₂ : Type u_2\nR : Type u_3\nR₂ : Type u_4\nS : Type u_5\nS₂ : Type u_6\nM : Type u_7\nN : Type u_8\nP : Type u_9\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : Semiring S\ninst✝⁹ : Semiring R₂\ninst✝⁸ : Semiring S₂\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : AddCommMonoid N\ninst✝⁵ : AddCommMonoid P\ninst✝⁴ : Module R M\ninst✝³ : Module S N\ninst✝² : Module R₂ P\ninst✝¹ : Module S₂ P\ninst✝ : SMulCommClass S₂ R₂ P\nρ₁₂ : RingHom R R₂\nσ₁₂ : RingHom S S₂\nb₁ : Basis ι₁ R M\nb₂ : Basis ι₂ S N\nB : LinearMap ρ₁₂ M (LinearMap σ₁₂ N P)\nx : M\ny : N\n⊢ Eq ((b₁.repr x).sum fun i xi => (b₂.repr y).sum fun j yj => HSMul.hSMul (ρ₁₂ xi) (HSMul.hSMul (σ₁₂ yj) ((B (b₁ i)) (b₂ j)))) ((B x) y)","decl":"/-- Write out `B x y` as a sum over `B (b i) (b j)` if `b` is a basis.\n\nVersion for semi-bilinear maps, see `sum_repr_mul_repr_mul` for the bilinear version. -/\ntheorem sum_repr_mul_repr_mulₛₗ {B : M →ₛₗ[ρ₁₂] N →ₛₗ[σ₁₂] P} (x y) :\n    ((b₁.repr x).sum fun i xi => (b₂.repr y).sum fun j yj => ρ₁₂ xi • σ₁₂ yj • B (b₁ i) (b₂ j)) =\n      B x y := by\n  conv_rhs => rw [← b₁.linearCombination_repr x, ← b₂.linearCombination_repr y]\n  simp_rw [Finsupp.linearCombination_apply, Finsupp.sum, map_sum₂, map_sum, LinearMap.map_smulₛₗ₂,\n    LinearMap.map_smulₛₗ]\n\n"}
{"name":"LinearMap.sum_repr_mul_repr_mul","module":"Mathlib.LinearAlgebra.Basis.Bilinear","initialProofState":"ι₁ : Type u_1\nι₂ : Type u_2\nRₗ : Type u_10\nMₗ : Type u_11\nNₗ : Type u_12\nPₗ : Type u_13\ninst✝⁶ : CommSemiring Rₗ\ninst✝⁵ : AddCommMonoid Mₗ\ninst✝⁴ : AddCommMonoid Nₗ\ninst✝³ : AddCommMonoid Pₗ\ninst✝² : Module Rₗ Mₗ\ninst✝¹ : Module Rₗ Nₗ\ninst✝ : Module Rₗ Pₗ\nb₁' : Basis ι₁ Rₗ Mₗ\nb₂' : Basis ι₂ Rₗ Nₗ\nB : LinearMap (RingHom.id Rₗ) Mₗ (LinearMap (RingHom.id Rₗ) Nₗ Pₗ)\nx : Mₗ\ny : Nₗ\n⊢ Eq ((b₁'.repr x).sum fun i xi => (b₂'.repr y).sum fun j yj => HSMul.hSMul xi (HSMul.hSMul yj ((B (b₁' i)) (b₂' j)))) ((B x) y)","decl":"/-- Write out `B x y` as a sum over `B (b i) (b j)` if `b` is a basis.\n\nVersion for bilinear maps, see `sum_repr_mul_repr_mulₛₗ` for the semi-bilinear version. -/\ntheorem sum_repr_mul_repr_mul {B : Mₗ →ₗ[Rₗ] Nₗ →ₗ[Rₗ] Pₗ} (x y) :\n    ((b₁'.repr x).sum fun i xi => (b₂'.repr y).sum fun j yj => xi • yj • B (b₁' i) (b₂' j)) =\n      B x y := by\n  conv_rhs => rw [← b₁'.linearCombination_repr x, ← b₂'.linearCombination_repr y]\n  simp_rw [Finsupp.linearCombination_apply, Finsupp.sum, map_sum₂, map_sum, LinearMap.map_smul₂,\n    LinearMap.map_smul]\n\n"}
