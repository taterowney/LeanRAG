{"name":"MeasureTheory.tilted_of_not_integrable","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : Not (MeasureTheory.Integrable (fun x => Real.exp (f x)) μ)\n⊢ Eq (μ.tilted f) 0","decl":"@[simp]\nlemma tilted_of_not_integrable (hf : ¬ Integrable (fun x ↦ exp (f x)) μ) : μ.tilted f = 0 := by\n  rw [Measure.tilted, integral_undef hf]\n  simp\n\n"}
{"name":"MeasureTheory.tilted_of_not_aemeasurable","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : Not (AEMeasurable f μ)\n⊢ Eq (μ.tilted f) 0","decl":"@[simp]\nlemma tilted_of_not_aemeasurable (hf : ¬ AEMeasurable f μ) : μ.tilted f = 0 := by\n  refine tilted_of_not_integrable ?_\n  suffices ¬ AEMeasurable (fun x ↦ exp (f x)) μ by exact fun h ↦ this h.1.aemeasurable\n  exact fun h ↦ hf (aemeasurable_of_aemeasurable_exp h)\n\n"}
{"name":"MeasureTheory.tilted_zero_measure","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nf : α → Real\n⊢ Eq (MeasureTheory.Measure.tilted 0 f) 0","decl":"@[simp]\nlemma tilted_zero_measure (f : α → ℝ) : (0 : Measure α).tilted f = 0 := by simp [Measure.tilted]\n\n"}
{"name":"MeasureTheory.tilted_const'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nc : Real\n⊢ Eq (μ.tilted fun x => c) (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"@[simp]\nlemma tilted_const' (μ : Measure α) (c : ℝ) :\n    μ.tilted (fun _ ↦ c) = (μ Set.univ)⁻¹ • μ := by\n  cases eq_zero_or_neZero μ with\n  | inl h => rw [h]; simp\n  | inr h0 =>\n    simp only [Measure.tilted, withDensity_const, integral_const, smul_eq_mul]\n    by_cases h_univ : μ Set.univ = ∞\n    · simp only [h_univ, ENNReal.top_toReal, zero_mul, log_zero, div_zero, ENNReal.ofReal_zero,\n        zero_smul, ENNReal.inv_top]\n    congr\n    rw [div_eq_mul_inv, mul_inv, mul_comm, mul_assoc, inv_mul_cancel₀ (exp_pos _).ne', mul_one,\n      ← ENNReal.toReal_inv, ENNReal.ofReal_toReal]\n    simp [h0.out]\n\n"}
{"name":"MeasureTheory.tilted_const","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nc : Real\n⊢ Eq (μ.tilted fun x => c) μ","decl":"lemma tilted_const (μ : Measure α) [IsProbabilityMeasure μ] (c : ℝ) :\n    μ.tilted (fun _ ↦ c) = μ := by simp\n\n"}
{"name":"MeasureTheory.tilted_zero'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (μ.tilted 0) (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"@[simp]\nlemma tilted_zero' (μ : Measure α) : μ.tilted 0 = (μ Set.univ)⁻¹ • μ := by\n  change μ.tilted (fun _ ↦ 0) = (μ Set.univ)⁻¹ • μ\n  simp\n\n"}
{"name":"MeasureTheory.tilted_zero","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (μ.tilted 0) μ","decl":"lemma tilted_zero (μ : Measure α) [IsProbabilityMeasure μ] : μ.tilted 0 = μ := by simp\n\n"}
{"name":"MeasureTheory.tilted_congr","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (μ.tilted f) (μ.tilted g)","decl":"lemma tilted_congr {g : α → ℝ} (hfg : f =ᵐ[μ] g) :\n    μ.tilted f = μ.tilted g := by\n  have h_int_eq : ∫ x, exp (f x) ∂μ = ∫ x, exp (g x) ∂μ := by\n    refine integral_congr_ae ?_\n    filter_upwards [hfg] with x hx\n    rw [hx]\n  refine withDensity_congr_ae ?_\n  filter_upwards [hfg] with x hx\n  rw [h_int_eq, hx]\n\n"}
{"name":"MeasureTheory.tilted_eq_withDensity_nnreal","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ Eq (μ.tilted f) (μ.withDensity fun x => ↑⟨HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x)), ⋯⟩)","decl":"lemma tilted_eq_withDensity_nnreal (μ : Measure α) (f : α → ℝ) :\n    μ.tilted f = μ.withDensity (fun x ↦ ((↑) : ℝ≥0 → ℝ≥0∞)\n      (⟨exp (f x) / ∫ x, exp (f x) ∂μ, by positivity⟩ : ℝ≥0)) := by\n  rw [Measure.tilted]\n  congr with x\n  rw [ENNReal.ofReal_eq_coe_nnreal]\n\n"}
{"name":"MeasureTheory.tilted_apply'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ns : Set α\nhs : MeasurableSet s\n⊢ Eq ((μ.tilted f) s) (MeasureTheory.lintegral (μ.restrict s) fun a => ENNReal.ofReal (HDiv.hDiv (Real.exp (f a)) (MeasureTheory.integral μ fun x => Real.exp (f x))))","decl":"lemma tilted_apply' (μ : Measure α) (f : α → ℝ) {s : Set α} (hs : MeasurableSet s) :\n    μ.tilted f s = ∫⁻ a in s, ENNReal.ofReal (exp (f a) / ∫ x, exp (f x) ∂μ) ∂μ := by\n  rw [Measure.tilted, withDensity_apply _ hs]\n\n"}
{"name":"MeasureTheory.tilted_apply","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → Real\ns : Set α\n⊢ Eq ((μ.tilted f) s) (MeasureTheory.lintegral (μ.restrict s) fun a => ENNReal.ofReal (HDiv.hDiv (Real.exp (f a)) (MeasureTheory.integral μ fun x => Real.exp (f x))))","decl":"lemma tilted_apply (μ : Measure α) [SFinite μ] (f : α → ℝ) (s : Set α) :\n    μ.tilted f s = ∫⁻ a in s, ENNReal.ofReal (exp (f a) / ∫ x, exp (f x) ∂μ) ∂μ := by\n  rw [Measure.tilted, withDensity_apply' _ s]\n\n"}
{"name":"MeasureTheory.tilted_apply_eq_ofReal_integral'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ns : Set α\nf : α → Real\nhs : MeasurableSet s\n⊢ Eq ((μ.tilted f) s) (ENNReal.ofReal (MeasureTheory.integral (μ.restrict s) fun a => HDiv.hDiv (Real.exp (f a)) (MeasureTheory.integral μ fun x => Real.exp (f x))))","decl":"lemma tilted_apply_eq_ofReal_integral' {s : Set α} (f : α → ℝ) (hs : MeasurableSet s) :\n    μ.tilted f s = ENNReal.ofReal (∫ a in s, exp (f a) / ∫ x, exp (f x) ∂μ ∂μ) := by\n  by_cases hf : Integrable (fun x ↦ exp (f x)) μ\n  · rw [tilted_apply' _ _ hs, ← ofReal_integral_eq_lintegral_ofReal]\n    · exact hf.integrableOn.div_const _\n    · exact ae_of_all _ (fun _ ↦ by positivity)\n  · simp only [hf, not_false_eq_true, tilted_of_not_integrable, Measure.coe_zero,\n      Pi.zero_apply, integral_undef hf, div_zero, integral_zero, ENNReal.ofReal_zero]\n\n"}
{"name":"MeasureTheory.tilted_apply_eq_ofReal_integral","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → Real\ns : Set α\n⊢ Eq ((μ.tilted f) s) (ENNReal.ofReal (MeasureTheory.integral (μ.restrict s) fun a => HDiv.hDiv (Real.exp (f a)) (MeasureTheory.integral μ fun x => Real.exp (f x))))","decl":"lemma tilted_apply_eq_ofReal_integral [SFinite μ] (f : α → ℝ) (s : Set α) :\n    μ.tilted f s = ENNReal.ofReal (∫ a in s, exp (f a) / ∫ x, exp (f x) ∂μ ∂μ) := by\n  by_cases hf : Integrable (fun x ↦ exp (f x)) μ\n  · rw [tilted_apply _ _, ← ofReal_integral_eq_lintegral_ofReal]\n    · exact hf.integrableOn.div_const _\n    · exact ae_of_all _ (fun _ ↦ by positivity)\n  · simp [tilted_of_not_integrable hf, integral_undef hf]\n\n"}
{"name":"MeasureTheory.isProbabilityMeasure_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : NeZero μ\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\n⊢ MeasureTheory.IsProbabilityMeasure (μ.tilted f)","decl":"lemma isProbabilityMeasure_tilted [NeZero μ] (hf : Integrable (fun x ↦ exp (f x)) μ) :\n    IsProbabilityMeasure (μ.tilted f) := by\n  constructor\n  simp_rw [tilted_apply' _ _ MeasurableSet.univ, setLIntegral_univ,\n    ENNReal.ofReal_div_of_pos (integral_exp_pos hf), div_eq_mul_inv]\n  rw [lintegral_mul_const'' _ hf.1.aemeasurable.ennreal_ofReal,\n    ← ofReal_integral_eq_lintegral_ofReal hf (ae_of_all _ fun _ ↦ (exp_pos _).le),\n    ENNReal.mul_inv_cancel]\n  · simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]\n    exact integral_exp_pos hf\n  · simp\n\n"}
{"name":"MeasureTheory.isZeroOrProbabilityMeasure_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (μ.tilted f)","decl":"instance isZeroOrProbabilityMeasure_tilted : IsZeroOrProbabilityMeasure (μ.tilted f) := by\n  rcases eq_zero_or_neZero μ with hμ | hμ\n  · simp only [hμ, tilted_zero_measure]\n    infer_instance\n  by_cases hf : Integrable (fun x ↦ exp (f x)) μ\n  · have := isProbabilityMeasure_tilted hf\n    infer_instance\n  · simp only [hf, not_false_eq_true, tilted_of_not_integrable]\n    infer_instance\n\n"}
{"name":"MeasureTheory.setLIntegral_tilted'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ng : α → ENNReal\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.lintegral ((μ.tilted f).restrict s) fun x => g x) (MeasureTheory.lintegral (μ.restrict s) fun x => HMul.hMul (ENNReal.ofReal (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x)))) (g x))","decl":"lemma setLIntegral_tilted' (f : α → ℝ) (g : α → ℝ≥0∞) {s : Set α} (hs : MeasurableSet s) :\n    ∫⁻ x in s, g x ∂(μ.tilted f)\n      = ∫⁻ x in s, ENNReal.ofReal (exp (f x) / ∫ x, exp (f x) ∂μ) * g x ∂μ := by\n  by_cases hf : AEMeasurable f μ\n  · rw [Measure.tilted, setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀]\n    · simp only [Pi.mul_apply]\n    · refine AEMeasurable.restrict ?_\n      exact ((measurable_exp.comp_aemeasurable hf).div_const _).ennreal_ofReal\n    · exact hs\n    · filter_upwards\n      simp only [ENNReal.ofReal_lt_top, implies_true]\n  · have hf' : ¬ Integrable (fun x ↦ exp (f x)) μ := by\n      exact fun h ↦ hf (aemeasurable_of_aemeasurable_exp h.1.aemeasurable)\n    simp only [hf, not_false_eq_true, tilted_of_not_aemeasurable, Measure.restrict_zero,\n      lintegral_zero_measure]\n    rw [integral_undef hf']\n    simp\n\n"}
{"name":"MeasureTheory.setLIntegral_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf : α → Real\ng : α → ENNReal\ns : Set α\n⊢ Eq (MeasureTheory.lintegral ((μ.tilted f).restrict s) fun x => g x) (MeasureTheory.lintegral (μ.restrict s) fun x => HMul.hMul (ENNReal.ofReal (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x)))) (g x))","decl":"lemma setLIntegral_tilted [SFinite μ] (f : α → ℝ) (g : α → ℝ≥0∞) (s : Set α) :\n    ∫⁻ x in s, g x ∂(μ.tilted f)\n      = ∫⁻ x in s, ENNReal.ofReal (exp (f x) / ∫ x, exp (f x) ∂μ) * g x ∂μ := by\n  by_cases hf : AEMeasurable f μ\n  · rw [Measure.tilted, setLIntegral_withDensity_eq_setLIntegral_mul_non_measurable₀']\n    · simp only [Pi.mul_apply]\n    · refine AEMeasurable.restrict ?_\n      exact ((measurable_exp.comp_aemeasurable hf).div_const _).ennreal_ofReal\n    · filter_upwards\n      simp only [ENNReal.ofReal_lt_top, implies_true]\n  · have hf' : ¬ Integrable (fun x ↦ exp (f x)) μ := by\n      exact fun h ↦ hf (aemeasurable_of_aemeasurable_exp h.1.aemeasurable)\n    simp only [hf, not_false_eq_true, tilted_of_not_aemeasurable, Measure.restrict_zero,\n      lintegral_zero_measure]\n    rw [integral_undef hf']\n    simp\n\n"}
{"name":"MeasureTheory.lintegral_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ng : α → ENNReal\n⊢ Eq (MeasureTheory.lintegral (μ.tilted f) fun x => g x) (MeasureTheory.lintegral μ fun x => HMul.hMul (ENNReal.ofReal (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x)))) (g x))","decl":"lemma lintegral_tilted (f : α → ℝ) (g : α → ℝ≥0∞) :\n    ∫⁻ x, g x ∂(μ.tilted f)\n      = ∫⁻ x, ENNReal.ofReal (exp (f x) / ∫ x, exp (f x) ∂μ) * (g x) ∂μ := by\n  rw [← setLIntegral_univ, setLIntegral_tilted' f g MeasurableSet.univ, setLIntegral_univ]\n\n"}
{"name":"MeasureTheory.setIntegral_tilted'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → Real\ng : α → E\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.integral ((μ.tilted f).restrict s) fun x => g x) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x))) (g x))","decl":"lemma setIntegral_tilted' (f : α → ℝ) (g : α → E) {s : Set α} (hs : MeasurableSet s) :\n    ∫ x in s, g x ∂(μ.tilted f) = ∫ x in s, (exp (f x) / ∫ x, exp (f x) ∂μ) • (g x) ∂μ := by\n  by_cases hf : AEMeasurable f μ\n  · rw [tilted_eq_withDensity_nnreal, setIntegral_withDensity_eq_setIntegral_smul₀ _ _ hs]\n    · congr\n    · suffices AEMeasurable (fun x ↦ exp (f x) / ∫ x, exp (f x) ∂μ) μ by\n        rw [← aemeasurable_coe_nnreal_real_iff]\n        refine AEMeasurable.restrict ?_\n        simpa only [NNReal.coe_mk]\n      exact (measurable_exp.comp_aemeasurable hf).div_const _\n  · have hf' : ¬ Integrable (fun x ↦ exp (f x)) μ := by\n      exact fun h ↦ hf (aemeasurable_of_aemeasurable_exp h.1.aemeasurable)\n    simp only [hf, not_false_eq_true, tilted_of_not_aemeasurable, Measure.restrict_zero,\n      integral_zero_measure]\n    rw [integral_undef hf']\n    simp\n\n"}
{"name":"MeasureTheory.setIntegral_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace Real E\ninst✝ : MeasureTheory.SFinite μ\nf : α → Real\ng : α → E\ns : Set α\n⊢ Eq (MeasureTheory.integral ((μ.tilted f).restrict s) fun x => g x) (MeasureTheory.integral (μ.restrict s) fun x => HSMul.hSMul (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x))) (g x))","decl":"lemma setIntegral_tilted [SFinite μ] (f : α → ℝ) (g : α → E) (s : Set α) :\n    ∫ x in s, g x ∂(μ.tilted f) = ∫ x in s, (exp (f x) / ∫ x, exp (f x) ∂μ) • (g x) ∂μ := by\n  by_cases hf : AEMeasurable f μ\n  · rw [tilted_eq_withDensity_nnreal, setIntegral_withDensity_eq_setIntegral_smul₀']\n    · congr\n    · suffices AEMeasurable (fun x ↦ exp (f x) / ∫ x, exp (f x) ∂μ) μ by\n        rw [← aemeasurable_coe_nnreal_real_iff]\n        refine AEMeasurable.restrict ?_\n        simpa only [NNReal.coe_mk]\n      exact (measurable_exp.comp_aemeasurable hf).div_const _\n  · have hf' : ¬ Integrable (fun x ↦ exp (f x)) μ := by\n      exact fun h ↦ hf (aemeasurable_of_aemeasurable_exp h.1.aemeasurable)\n    simp only [hf, not_false_eq_true, tilted_of_not_aemeasurable, Measure.restrict_zero,\n      integral_zero_measure]\n    rw [integral_undef hf']\n    simp\n\n"}
{"name":"MeasureTheory.integral_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → Real\ng : α → E\n⊢ Eq (MeasureTheory.integral (μ.tilted f) fun x => g x) (MeasureTheory.integral μ fun x => HSMul.hSMul (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x))) (g x))","decl":"lemma integral_tilted (f : α → ℝ) (g : α → E) :\n    ∫ x, g x ∂(μ.tilted f) = ∫ x, (exp (f x) / ∫ x, exp (f x) ∂μ) • (g x) ∂μ := by\n  rw [← setIntegral_univ, setIntegral_tilted' f g MeasurableSet.univ, setIntegral_univ]\n\n"}
{"name":"MeasureTheory.integral_exp_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\n⊢ Eq (MeasureTheory.integral (μ.tilted f) fun x => Real.exp (g x)) (HDiv.hDiv (MeasureTheory.integral μ fun x => Real.exp (HAdd.hAdd f g x)) (MeasureTheory.integral μ fun x => Real.exp (f x)))","decl":"lemma integral_exp_tilted (f g : α → ℝ) :\n    ∫ x, exp (g x) ∂(μ.tilted f) = (∫ x, exp ((f + g) x) ∂μ) / ∫ x, exp (f x) ∂μ := by\n  cases eq_zero_or_neZero μ with\n  | inl h => rw [h]; simp\n  | inr h0 =>\n    rw [integral_tilted f]\n    simp_rw [smul_eq_mul]\n    have : ∀ x, (rexp (f x) / ∫ (x : α), rexp (f x) ∂μ) * rexp (g x)\n        = (rexp ((f + g) x) / ∫ (x : α), rexp (f x) ∂μ) := by\n      intro x\n      rw [Pi.add_apply, exp_add]\n      ring\n    simp_rw [this, div_eq_mul_inv]\n    rw [integral_mul_right]\n\n"}
{"name":"MeasureTheory.tilted_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\ng : α → Real\n⊢ Eq ((μ.tilted f).tilted g) (μ.tilted (HAdd.hAdd f g))","decl":"lemma tilted_tilted (hf : Integrable (fun x ↦ exp (f x)) μ) (g : α → ℝ) :\n    (μ.tilted f).tilted g = μ.tilted (f + g) := by\n  cases eq_zero_or_neZero μ with\n  | inl h => simp [h]\n  | inr h0 =>\n    ext1 s hs\n    rw [tilted_apply' _ _ hs, tilted_apply' _ _ hs, setLIntegral_tilted' f _ hs]\n    congr with x\n    rw [← ENNReal.ofReal_mul (by positivity),\n      integral_exp_tilted f, Pi.add_apply, exp_add]\n    congr 1\n    simp only [Pi.add_apply]\n    field_simp\n    ring_nf\n    congr 1\n    rw [mul_assoc, mul_inv_cancel₀, mul_one]\n    exact (integral_exp_pos hf).ne'\n\n"}
{"name":"MeasureTheory.tilted_comm","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\ng : α → Real\nhg : MeasureTheory.Integrable (fun x => Real.exp (g x)) μ\n⊢ Eq ((μ.tilted f).tilted g) ((μ.tilted g).tilted f)","decl":"lemma tilted_comm (hf : Integrable (fun x ↦ exp (f x)) μ) {g : α → ℝ}\n    (hg : Integrable (fun x ↦ exp (g x)) μ) :\n    (μ.tilted f).tilted g = (μ.tilted g).tilted f := by\n  rw [tilted_tilted hf, add_comm, tilted_tilted hg]\n\n"}
{"name":"MeasureTheory.tilted_neg_same'","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\n⊢ Eq ((μ.tilted f).tilted (Neg.neg f)) (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"@[simp]\nlemma tilted_neg_same' (hf : Integrable (fun x ↦ exp (f x)) μ) :\n    (μ.tilted f).tilted (-f) = (μ Set.univ)⁻¹ • μ := by\n  rw [tilted_tilted hf]; simp\n\n"}
{"name":"MeasureTheory.tilted_neg_same","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\n⊢ Eq ((μ.tilted f).tilted (Neg.neg f)) μ","decl":"@[simp]\nlemma tilted_neg_same [IsProbabilityMeasure μ] (hf : Integrable (fun x ↦ exp (f x)) μ) :\n    (μ.tilted f).tilted (-f) = μ := by\n  simp [hf]\n\n"}
{"name":"MeasureTheory.tilted_absolutelyContinuous","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\n⊢ (μ.tilted f).AbsolutelyContinuous μ","decl":"lemma tilted_absolutelyContinuous (μ : Measure α) (f : α → ℝ) : μ.tilted f ≪ μ :=\n  withDensity_absolutelyContinuous _ _\n\n"}
{"name":"MeasureTheory.absolutelyContinuous_tilted","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\n⊢ μ.AbsolutelyContinuous (μ.tilted f)","decl":"lemma absolutelyContinuous_tilted (hf : Integrable (fun x ↦ exp (f x)) μ) : μ ≪ μ.tilted f := by\n  cases eq_zero_or_neZero μ with\n  | inl h => simp only [h, tilted_zero_measure]; exact fun _ _ ↦ by simp\n  | inr h0 =>\n    refine withDensity_absolutelyContinuous' ?_ ?_\n    · exact (hf.1.aemeasurable.div_const _).ennreal_ofReal\n    · filter_upwards\n      simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]\n      exact fun _ ↦ div_pos (exp_pos _) (integral_exp_pos hf)\n\n"}
{"name":"MeasureTheory.rnDeriv_tilted_right","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nf : α → Real\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) ν\n⊢ (MeasureTheory.ae ν).EventuallyEq (μ.rnDeriv (ν.tilted f)) fun x => HMul.hMul (ENNReal.ofReal (HMul.hMul (Real.exp (Neg.neg (f x))) (MeasureTheory.integral ν fun x => Real.exp (f x)))) (μ.rnDeriv ν x)","decl":"lemma rnDeriv_tilted_right (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]\n    (hf : Integrable (fun x ↦ exp (f x)) ν) :\n    μ.rnDeriv (ν.tilted f)\n      =ᵐ[ν] fun x ↦ ENNReal.ofReal (exp (- f x) * ∫ x, exp (f x) ∂ν) * μ.rnDeriv ν x := by\n  cases eq_zero_or_neZero ν with\n  | inl h => simp_rw [h, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot\n  | inr h0 =>\n    refine (Measure.rnDeriv_withDensity_right μ ν ?_ ?_ ?_).trans ?_\n    · exact (hf.1.aemeasurable.div_const _).ennreal_ofReal\n    · filter_upwards\n      simp only [ne_eq, ENNReal.ofReal_eq_zero, not_le]\n      exact fun _ ↦ div_pos (exp_pos _) (integral_exp_pos hf)\n    · refine ae_of_all _ (by simp)\n    · filter_upwards with x\n      congr\n      rw [← ENNReal.ofReal_inv_of_pos, inv_div', ← exp_neg, div_eq_mul_inv, inv_inv]\n      exact div_pos (exp_pos _) (integral_exp_pos hf)\n\n"}
{"name":"MeasureTheory.toReal_rnDeriv_tilted_right","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nf : α → Real\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) ν\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => (μ.rnDeriv (ν.tilted f) x).toReal) fun x => HMul.hMul (HMul.hMul (Real.exp (Neg.neg (f x))) (MeasureTheory.integral ν fun x => Real.exp (f x))) (μ.rnDeriv ν x).toReal","decl":"lemma toReal_rnDeriv_tilted_right (μ ν : Measure α) [SigmaFinite μ] [SigmaFinite ν]\n    (hf : Integrable (fun x ↦ exp (f x)) ν) :\n    (fun x ↦ (μ.rnDeriv (ν.tilted f) x).toReal)\n      =ᵐ[ν] fun x ↦ exp (- f x) * (∫ x, exp (f x) ∂ν) * (μ.rnDeriv ν x).toReal := by\n  filter_upwards [rnDeriv_tilted_right μ ν hf] with x hx\n  rw [hx]\n  simp only [ENNReal.toReal_mul, gt_iff_lt, mul_eq_mul_right_iff, ENNReal.toReal_ofReal_eq_iff]\n  exact Or.inl (by positivity)\n\n"}
{"name":"MeasureTheory.rnDeriv_tilted_left","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhfν : AEMeasurable f ν\n⊢ (MeasureTheory.ae ν).EventuallyEq ((μ.tilted f).rnDeriv ν) fun x => HMul.hMul (ENNReal.ofReal (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x)))) (μ.rnDeriv ν x)","decl":"variable (μ) in\nlemma rnDeriv_tilted_left {ν : Measure α} [SigmaFinite μ] [SigmaFinite ν] (hfν : AEMeasurable f ν) :\n    (μ.tilted f).rnDeriv ν\n      =ᵐ[ν] fun x ↦ ENNReal.ofReal (exp (f x) / (∫ x, exp (f x) ∂μ)) * μ.rnDeriv ν x := by\n  let g := fun x ↦ ENNReal.ofReal (exp (f x) / (∫ x, exp (f x) ∂μ))\n  refine Measure.rnDeriv_withDensity_left (μ := μ) (ν := ν) (f := g) ?_ ?_\n  · exact ((measurable_exp.comp_aemeasurable hfν).div_const _).ennreal_ofReal\n  · exact ae_of_all _ (fun x ↦ by simp [g])\n\n"}
{"name":"MeasureTheory.toReal_rnDeriv_tilted_left","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SigmaFinite μ\ninst✝ : MeasureTheory.SigmaFinite ν\nhfν : AEMeasurable f ν\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun x => ((μ.tilted f).rnDeriv ν x).toReal) fun x => HMul.hMul (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x))) (μ.rnDeriv ν x).toReal","decl":"variable (μ) in\nlemma toReal_rnDeriv_tilted_left {ν : Measure α} [SigmaFinite μ] [SigmaFinite ν]\n    (hfν : AEMeasurable f ν) :\n    (fun x ↦ ((μ.tilted f).rnDeriv ν x).toReal)\n      =ᵐ[ν] fun x ↦ exp (f x) / (∫ x, exp (f x) ∂μ) * (μ.rnDeriv ν x).toReal := by\n  filter_upwards [rnDeriv_tilted_left μ hfν] with x hx\n  rw [hx]\n  simp only [ENNReal.toReal_mul, mul_eq_mul_right_iff, ENNReal.toReal_ofReal_eq_iff]\n  exact Or.inl (by positivity)\n\n"}
{"name":"MeasureTheory.rnDeriv_tilted_left_self","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.SigmaFinite μ\nhf : AEMeasurable f μ\n⊢ (MeasureTheory.ae μ).EventuallyEq ((μ.tilted f).rnDeriv μ) fun x => ENNReal.ofReal (HDiv.hDiv (Real.exp (f x)) (MeasureTheory.integral μ fun x => Real.exp (f x)))","decl":"lemma rnDeriv_tilted_left_self [SigmaFinite μ] (hf : AEMeasurable f μ) :\n    (μ.tilted f).rnDeriv μ =ᵐ[μ] fun x ↦ ENNReal.ofReal (exp (f x) / ∫ x, exp (f x) ∂μ) := by\n  refine (rnDeriv_tilted_left μ hf).trans ?_\n  filter_upwards [Measure.rnDeriv_self μ] with x hx\n  rw [hx, mul_one]\n\n"}
{"name":"MeasureTheory.log_rnDeriv_tilted_left_self","module":"Mathlib.MeasureTheory.Measure.Tilted","initialProofState":"α : Type u_1\nmα : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\ninst✝ : MeasureTheory.SigmaFinite μ\nhf : MeasureTheory.Integrable (fun x => Real.exp (f x)) μ\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => Real.log ((μ.tilted f).rnDeriv μ x).toReal) fun x => HSub.hSub (f x) (Real.log (MeasureTheory.integral μ fun x => Real.exp (f x)))","decl":"lemma log_rnDeriv_tilted_left_self [SigmaFinite μ] (hf : Integrable (fun x ↦ exp (f x)) μ) :\n    (fun x ↦ log ((μ.tilted f).rnDeriv μ x).toReal)\n      =ᵐ[μ] fun x ↦ f x - log (∫ x, exp (f x) ∂μ) := by\n  cases eq_zero_or_neZero μ with\n  | inl h => simp_rw [h, ae_zero, Filter.EventuallyEq]; exact Filter.eventually_bot\n  | inr h0 =>\n    have hf' : AEMeasurable f μ := aemeasurable_of_aemeasurable_exp hf.1.aemeasurable\n    filter_upwards [rnDeriv_tilted_left_self hf'] with x hx\n    rw [hx, ENNReal.toReal_ofReal (by positivity), log_div (exp_pos _).ne', log_exp]\n    exact (integral_exp_pos hf).ne'\n\n"}
