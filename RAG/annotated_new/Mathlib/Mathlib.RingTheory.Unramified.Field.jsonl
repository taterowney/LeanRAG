{"name":"Algebra.FormallyUnramified.of_isSeparable","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K L : Type u\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Algebra.IsSeparable K L\n⊢ Algebra.FormallyUnramified K L","decl":"theorem of_isSeparable [Algebra.IsSeparable K L] : FormallyUnramified K L := by\n  rw [iff_comp_injective]\n  intros B _ _ I hI f₁ f₂ e\n  ext x\n  have : f₁ x - f₂ x ∈ I := by\n    simpa [Ideal.Quotient.mk_eq_mk_iff_sub_mem] using AlgHom.congr_fun e x\n  have := Polynomial.eval_add_of_sq_eq_zero ((minpoly K x).map (algebraMap K B)) (f₂ x)\n    (f₁ x - f₂ x) (show (f₁ x - f₂ x) ^ 2 ∈ ⊥ from hI ▸ Ideal.pow_mem_pow this 2)\n  simp only [add_sub_cancel, eval_map_algebraMap, aeval_algHom_apply, minpoly.aeval, map_zero,\n    derivative_map, zero_add] at this\n  rwa [eq_comm, ((isUnit_iff_ne_zero.mpr\n    ((Algebra.IsSeparable.isSeparable K x).aeval_derivative_ne_zero\n      (minpoly.aeval K x))).map f₂).mul_right_eq_zero, sub_eq_zero] at this\n\n"}
{"name":"Algebra.FormallyUnramified.bijective_of_isAlgClosed_of_isLocalRing","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K A : Type u\ninst✝⁶ : Field K\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra K A\ninst✝³ : Algebra.FormallyUnramified K A\ninst✝² : Algebra.EssFiniteType K A\ninst✝¹ : IsAlgClosed K\ninst✝ : IsLocalRing A\n⊢ Function.Bijective ⇑(algebraMap K A)","decl":"theorem bijective_of_isAlgClosed_of_isLocalRing\n    [IsAlgClosed K] [IsLocalRing A] :\n    Function.Bijective (algebraMap K A) := by\n  have := finite_of_free (R := K) (S := A)\n  have : IsArtinianRing A := isArtinian_of_tower K inferInstance\n  have hA : IsNilpotent (IsLocalRing.maximalIdeal A) := by\n    rw [← IsLocalRing.jacobson_eq_maximalIdeal ⊥]\n    · exact IsArtinianRing.isNilpotent_jacobson_bot\n    · exact bot_ne_top\n  have : Function.Bijective (Algebra.ofId K (A ⧸ IsLocalRing.maximalIdeal A)) :=\n    ⟨RingHom.injective _, IsAlgClosed.algebraMap_surjective_of_isIntegral⟩\n  let e : K ≃ₐ[K] A ⧸ IsLocalRing.maximalIdeal A := {\n    __ := Algebra.ofId K (A ⧸ IsLocalRing.maximalIdeal A)\n    __ := Equiv.ofBijective _ this }\n  let e' : A ⊗[K] (A ⧸ IsLocalRing.maximalIdeal A) ≃ₐ[A] A :=\n    (Algebra.TensorProduct.congr AlgEquiv.refl e.symm).trans (Algebra.TensorProduct.rid K A A)\n  let f : A ⧸ IsLocalRing.maximalIdeal A →ₗ[A] A := e'.toLinearMap.comp (sec K A _)\n  have hf : (Algebra.ofId _ _).toLinearMap ∘ₗ f = LinearMap.id := by\n    dsimp [f]\n    rw [← LinearMap.comp_assoc, ← comp_sec K A]\n    congr 1\n    apply LinearMap.restrictScalars_injective K\n    apply _root_.TensorProduct.ext'\n    intros r s\n    obtain ⟨s, rfl⟩ := e.surjective s\n    suffices s • (Ideal.Quotient.mk (IsLocalRing.maximalIdeal A)) r = r • e s by\n      simpa [ofId, e']\n    simp [Algebra.smul_def, e, ofId, mul_comm]\n  have hf₁ : f 1 • (1 : A ⧸ IsLocalRing.maximalIdeal A) = 1 := by\n    rw [← algebraMap_eq_smul_one]\n    exact LinearMap.congr_fun hf 1\n  have hf₂ : 1 - f 1 ∈ IsLocalRing.maximalIdeal A := by\n    rw [← Ideal.Quotient.eq_zero_iff_mem, map_sub, map_one, ← Ideal.Quotient.algebraMap_eq,\n     algebraMap_eq_smul_one, hf₁, sub_self]\n  have hf₃ : IsIdempotentElem (1 - f 1) := by\n    apply IsIdempotentElem.one_sub\n    rw [IsIdempotentElem, ← smul_eq_mul, ← map_smul, hf₁]\n  have hf₄ : f 1 = 1 := by\n    obtain ⟨n, hn⟩ := hA\n    have : (1 - f 1) ^ n = 0 := by\n      rw [← Ideal.mem_bot, ← Ideal.zero_eq_bot, ← hn]\n      exact Ideal.pow_mem_pow hf₂ n\n    rw [eq_comm, ← sub_eq_zero, ← hf₃.pow_succ_eq n, pow_succ, this, zero_mul]\n  refine Equiv.bijective ⟨algebraMap K A, ⇑e.symm ∘ ⇑(algebraMap A _), fun x ↦ by simp, fun x ↦ ?_⟩\n  have : ⇑(algebraMap K A) = ⇑f ∘ ⇑e := by\n    ext k\n    conv_rhs => rw [← mul_one k, ← smul_eq_mul, Function.comp_apply, map_smul,\n      LinearMap.map_smul_of_tower, map_one, hf₄, ← algebraMap_eq_smul_one]\n  rw [this]\n  simp only [Function.comp_apply, AlgEquiv.apply_symm_apply, algebraMap_eq_smul_one,\n    map_smul, hf₄, smul_eq_mul, mul_one]\n\n"}
{"name":"Algebra.FormallyUnramified.isField_of_isAlgClosed_of_isLocalRing","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K A : Type u\ninst✝⁶ : Field K\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra K A\ninst✝³ : Algebra.FormallyUnramified K A\ninst✝² : Algebra.EssFiniteType K A\ninst✝¹ : IsAlgClosed K\ninst✝ : IsLocalRing A\n⊢ IsField A","decl":"theorem isField_of_isAlgClosed_of_isLocalRing\n    [IsAlgClosed K] [IsLocalRing A] : IsField A := by\n  rw [IsLocalRing.isField_iff_maximalIdeal_eq, eq_bot_iff]\n  intro x hx\n  obtain ⟨x, rfl⟩ := (bijective_of_isAlgClosed_of_isLocalRing K A).surjective x\n  show _ = 0\n  rw [← (algebraMap K A).map_zero]\n  by_contra hx'\n  exact hx ((isUnit_iff_ne_zero.mpr\n    (fun e ↦ hx' ((algebraMap K A).congr_arg e))).map (algebraMap K A))\n\n"}
{"name":"Algebra.FormallyUnramified.bijective_of_isAlgClosed_of_localRing","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K A : Type u\ninst✝⁶ : Field K\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra K A\ninst✝³ : Algebra.FormallyUnramified K A\ninst✝² : Algebra.EssFiniteType K A\ninst✝¹ : IsAlgClosed K\ninst✝ : IsLocalRing A\n⊢ Function.Bijective ⇑(algebraMap K A)","decl":"@[deprecated (since := \"2024-11-12\")]\nalias bijective_of_isAlgClosed_of_localRing := bijective_of_isAlgClosed_of_isLocalRing\n\n"}
{"name":"Algebra.FormallyUnramified.isField_of_isAlgClosed_of_localRing","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K A : Type u\ninst✝⁶ : Field K\ninst✝⁵ : CommRing A\ninst✝⁴ : Algebra K A\ninst✝³ : Algebra.FormallyUnramified K A\ninst✝² : Algebra.EssFiniteType K A\ninst✝¹ : IsAlgClosed K\ninst✝ : IsLocalRing A\n⊢ IsField A","decl":"@[deprecated (since := \"2024-11-12\")]\nalias isField_of_isAlgClosed_of_localRing := isField_of_isAlgClosed_of_isLocalRing\n\n"}
{"name":"Algebra.FormallyUnramified.isReduced_of_field","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K A : Type u\ninst✝⁴ : Field K\ninst✝³ : CommRing A\ninst✝² : Algebra K A\ninst✝¹ : Algebra.FormallyUnramified K A\ninst✝ : Algebra.EssFiniteType K A\n⊢ IsReduced A","decl":"include K in\ntheorem isReduced_of_field :\n    IsReduced A := by\n  constructor\n  intro x hx\n  let f := (Algebra.TensorProduct.includeRight (R := K) (A := AlgebraicClosure K) (B := A))\n  have : Function.Injective f := by\n    have : ⇑f = (LinearMap.rTensor A (Algebra.ofId K (AlgebraicClosure K)).toLinearMap).comp\n        (Algebra.TensorProduct.lid K A).symm.toLinearMap := by\n      ext x; simp [f]\n    rw [this]\n    suffices Function.Injective\n        (LinearMap.rTensor A (Algebra.ofId K (AlgebraicClosure K)).toLinearMap) by\n      exact this.comp (Algebra.TensorProduct.lid K A).symm.injective\n    apply Module.Flat.rTensor_preserves_injective_linearMap\n    exact (algebraMap K _).injective\n  apply this\n  rw [map_zero]\n  apply eq_zero_of_localization\n  intro M hM\n  have hy := (hx.map f).map (algebraMap _ (Localization.AtPrime M))\n  generalize algebraMap _ (Localization.AtPrime M) (f x) = y at *\n  have := EssFiniteType.of_isLocalization (Localization.AtPrime M) M.primeCompl\n  have := of_isLocalization (Rₘ := Localization.AtPrime M) M.primeCompl\n  have := EssFiniteType.comp (AlgebraicClosure K) (AlgebraicClosure K ⊗[K] A)\n    (Localization.AtPrime M)\n  have := comp (AlgebraicClosure K) (AlgebraicClosure K ⊗[K] A)\n    (Localization.AtPrime M)\n  letI := (isField_of_isAlgClosed_of_isLocalRing (AlgebraicClosure K)\n    (A := Localization.AtPrime M)).toField\n  exact hy.eq_zero\n\n"}
{"name":"Algebra.FormallyUnramified.range_eq_top_of_isPurelyInseparable","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K L : Type u\ninst✝⁵ : Field K\ninst✝⁴ : Field L\ninst✝³ : Algebra K L\ninst✝² : Algebra.FormallyUnramified K L\ninst✝¹ : Algebra.EssFiniteType K L\ninst✝ : IsPurelyInseparable K L\n⊢ Eq (algebraMap K L).range Top.top","decl":"theorem range_eq_top_of_isPurelyInseparable\n    [IsPurelyInseparable K L] : (algebraMap K L).range = ⊤ := by\n  classical\n  have : Nontrivial (L ⊗[K] L) := by\n    rw [← not_subsingleton_iff_nontrivial, ← rank_zero_iff (R := K), rank_tensorProduct',\n      mul_eq_zero, or_self, rank_zero_iff, not_subsingleton_iff_nontrivial]\n    infer_instance\n  rw [← top_le_iff]\n  intro x _\n  obtain ⟨n, hn⟩ := IsPurelyInseparable.pow_mem K (ringExpChar K) x\n  have : ExpChar (L ⊗[K] L) (ringExpChar K) := by\n    refine expChar_of_injective_ringHom (algebraMap K _).injective (ringExpChar K)\n  have : (1 ⊗ₜ x - x ⊗ₜ 1 : L ⊗[K] L) ^ (ringExpChar K) ^ n = 0 := by\n    rw [sub_pow_expChar_pow, TensorProduct.tmul_pow, one_pow, TensorProduct.tmul_pow, one_pow]\n    obtain ⟨r, hr⟩ := hn\n    rw [← hr, algebraMap_eq_smul_one, TensorProduct.smul_tmul, sub_self]\n  have H : (1 ⊗ₜ x : L ⊗[K] L) = x ⊗ₜ 1 := by\n    have inst : IsReduced (L ⊗[K] L) := isReduced_of_field L _\n    exact sub_eq_zero.mp (IsNilpotent.eq_zero ⟨_, this⟩)\n  by_cases h' : LinearIndependent K ![1, x]\n  · have h := h'.coe_range\n    let S := h.extend (Set.subset_univ _)\n    let a : S := ⟨1, h.subset_extend _ (by simp)⟩\n    have ha : Basis.extend h a = 1 := by simp [a]\n    let b : S := ⟨x, h.subset_extend _ (by simp)⟩\n    have hb : Basis.extend h b = x := by simp [b]\n    by_cases e : a = b\n    · obtain rfl : 1 = x := congr_arg Subtype.val e\n      exact ⟨1, map_one _⟩\n    have := DFunLike.congr_fun\n      (DFunLike.congr_arg ((Basis.extend h).tensorProduct (Basis.extend h)).repr H) (a, b)\n    simp only [Basis.tensorProduct_repr_tmul_apply, ← ha, ← hb, Basis.repr_self, smul_eq_mul,\n      Finsupp.single_apply, e, Ne.symm e, ↓reduceIte, mul_one, mul_zero, one_ne_zero] at this\n  · rw [LinearIndependent.pair_iff] at h'\n    simp only [not_forall, not_and, exists_prop] at h'\n    obtain ⟨a, b, e, hab⟩ := h'\n    have : IsUnit b := by\n      rw [isUnit_iff_ne_zero]\n      rintro rfl\n      rw [zero_smul, ← algebraMap_eq_smul_one, add_zero,\n        (injective_iff_map_eq_zero' _).mp (algebraMap K L).injective] at e\n      cases hab e rfl\n    use (-this.unit⁻¹ * a)\n    rw [map_mul, ← Algebra.smul_def, algebraMap_eq_smul_one, eq_neg_iff_add_eq_zero.mpr e,\n      smul_neg, neg_smul, neg_neg, smul_smul, this.val_inv_mul, one_smul]\n\n"}
{"name":"Algebra.FormallyUnramified.isSeparable","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K L : Type u\ninst✝⁴ : Field K\ninst✝³ : Field L\ninst✝² : Algebra K L\ninst✝¹ : Algebra.FormallyUnramified K L\ninst✝ : Algebra.EssFiniteType K L\n⊢ Algebra.IsSeparable K L","decl":"theorem isSeparable : Algebra.IsSeparable K L := by\n  have := finite_of_free (R := K) (S := L)\n  rw [← separableClosure.eq_top_iff]\n  have := of_comp K (separableClosure K L) L\n  have := EssFiniteType.of_comp K (separableClosure K L) L\n  ext\n  show _ ↔ _ ∈ (⊤ : Subring _)\n  rw [← range_eq_top_of_isPurelyInseparable (separableClosure K L) L]\n  simp\n\n"}
{"name":"Algebra.FormallyUnramified.iff_isSeparable","module":"Mathlib.RingTheory.Unramified.Field","initialProofState":"K : Type u\ninst✝³ : Field K\nL : Type u\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Algebra.EssFiniteType K L\n⊢ Iff (Algebra.FormallyUnramified K L) (Algebra.IsSeparable K L)","decl":"theorem iff_isSeparable (L : Type u) [Field L] [Algebra K L] [EssFiniteType K L] :\n    FormallyUnramified K L ↔ Algebra.IsSeparable K L :=\n  ⟨fun _ ↦ isSeparable K L, fun _ ↦ of_isSeparable K L⟩\n\n"}
