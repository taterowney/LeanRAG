{"name":"Tree.nil.sizeOf_spec","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\ninst✝ : SizeOf α\n⊢ Eq (SizeOf.sizeOf Tree.nil) 1","decl":"/-- A binary tree with values stored in non-leaf nodes. -/\ninductive Tree.{u} (α : Type u) : Type u\n  | nil : Tree α\n  | node : α → Tree α → Tree α → Tree α\n  deriving DecidableEq, Repr -- Porting note: Removed `has_reflect`, added `Repr`.\n\n"}
{"name":"Tree.node.inj","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\na✝⁵ : α\na✝⁴ a✝³ : Tree α\na✝² : α\na✝¹ a✝ : Tree α\nx✝ : Eq (Tree.node a✝⁵ a✝⁴ a✝³) (Tree.node a✝² a✝¹ a✝)\n⊢ And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝))","decl":"/-- A binary tree with values stored in non-leaf nodes. -/\ninductive Tree.{u} (α : Type u) : Type u\n  | nil : Tree α\n  | node : α → Tree α → Tree α → Tree α\n  deriving DecidableEq, Repr -- Porting note: Removed `has_reflect`, added `Repr`.\n\n"}
{"name":"Tree.node.sizeOf_spec","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\ninst✝ : SizeOf α\na✝² : α\na✝¹ a✝ : Tree α\n⊢ Eq (SizeOf.sizeOf (Tree.node a✝² a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝²)) (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- A binary tree with values stored in non-leaf nodes. -/\ninductive Tree.{u} (α : Type u) : Type u\n  | nil : Tree α\n  | node : α → Tree α → Tree α → Tree α\n  deriving DecidableEq, Repr -- Porting note: Removed `has_reflect`, added `Repr`.\n\n"}
{"name":"Tree.node.injEq","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\na✝⁵ : α\na✝⁴ a✝³ : Tree α\na✝² : α\na✝¹ a✝ : Tree α\n⊢ Eq (Eq (Tree.node a✝⁵ a✝⁴ a✝³) (Tree.node a✝² a✝¹ a✝)) (And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝)))","decl":"/-- A binary tree with values stored in non-leaf nodes. -/\ninductive Tree.{u} (α : Type u) : Type u\n  | nil : Tree α\n  | node : α → Tree α → Tree α → Tree α\n  deriving DecidableEq, Repr -- Porting note: Removed `has_reflect`, added `Repr`.\n\n"}
{"name":"Tree.id_map","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\nt : Tree α\n⊢ Eq (Tree.map id t) t","decl":"theorem id_map (t : Tree α) : t.map id = t := by\n  induction t with\n  | nil => rw [map]\n  | node v l r hl hr => rw [map, hl, hr, id_eq]\n\n"}
{"name":"Tree.comp_map","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\nβ : Type u_1\nγ : Type u_2\nf : α → β\ng : β → γ\nt : Tree α\n⊢ Eq (Tree.map (Function.comp g f) t) (Tree.map g (Tree.map f t))","decl":"theorem comp_map {β γ : Type*} (f : α → β) (g : β → γ) (t : Tree α) :\n    t.map (g ∘ f) = (t.map f).map g := by\n  induction t with\n  | nil => rw [map, map, map]\n  | node v l r hl hr => rw [map, map, map, hl, hr, Function.comp_apply]\n\n"}
{"name":"Tree.traverse_pure","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\nt : Tree α\nm : Type u → Type u_1\ninst✝¹ : Applicative m\ninst✝ : LawfulApplicative m\n⊢ Eq (Tree.traverse Pure.pure t) (Pure.pure t)","decl":"theorem traverse_pure (t : Tree α) {m : Type u → Type*} [Applicative m] [LawfulApplicative m] :\n    t.traverse (pure : α → m α) = pure t := by\n  induction t with\n  | nil => rw [traverse]\n  | node v l r hl hr =>\n    rw [traverse, hl, hr, map_pure, pure_seq, seq_pure, map_pure, map_pure]\n\n"}
{"name":"Tree.numLeaves_eq_numNodes_succ","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\nx : Tree α\n⊢ Eq x.numLeaves (HAdd.hAdd x.numNodes 1)","decl":"theorem numLeaves_eq_numNodes_succ (x : Tree α) : x.numLeaves = x.numNodes + 1 := by\n  induction x <;> simp [*, Nat.add_comm, Nat.add_assoc, Nat.add_left_comm]\n\n"}
{"name":"Tree.numLeaves_pos","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\nx : Tree α\n⊢ LT.lt 0 x.numLeaves","decl":"theorem numLeaves_pos (x : Tree α) : 0 < x.numLeaves := by\n  rw [numLeaves_eq_numNodes_succ]\n  exact x.numNodes.zero_lt_succ\n\n"}
{"name":"Tree.height_le_numNodes","module":"Mathlib.Data.Tree.Basic","initialProofState":"α : Type u\nx : Tree α\n⊢ LE.le x.height x.numNodes","decl":"theorem height_le_numNodes : ∀ x : Tree α, x.height ≤ x.numNodes\n  | nil => Nat.le_refl _\n  | node _ a b => Nat.succ_le_succ <|\n    Nat.max_le.2 ⟨Nat.le_trans a.height_le_numNodes <| a.numNodes.le_add_right _,\n      Nat.le_trans b.height_le_numNodes <| b.numNodes.le_add_left _⟩\n\n"}
{"name":"Tree.left_node_right_eq_self","module":"Mathlib.Data.Tree.Basic","initialProofState":"x : Tree Unit\n_hx : Ne x Tree.nil\n⊢ Eq (Tree.node Unit.unit x.left x.right) x","decl":"theorem left_node_right_eq_self : ∀ {x : Tree Unit} (_hx : x ≠ nil), x.left △ x.right = x\n  | nil, h => by trivial\n  | node _ _ _, _ => rfl  -- Porting note: `a △ b` no longer works in pattern matching\n\n"}
