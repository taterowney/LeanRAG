{"name":"WType.mk.sizeOf_spec","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\ninst✝¹ : SizeOf α\ninst✝ : (a : α) → SizeOf (β a)\na : α\nf : β a → WType β\n⊢ Eq (SizeOf.sizeOf (WType.mk a f)) (HAdd.hAdd 1 (SizeOf.sizeOf a))","decl":"/--\nGiven `β : α → Type*`, `WType β` is the type of finitely branching trees where nodes are labeled by\nelements of `α` and the children of a node labeled `a` are indexed by elements of `β a`.\n-/\ninductive WType {α : Type*} (β : α → Type*)\n  | mk (a : α) (f : β a → WType β) : WType β\n\n"}
{"name":"WType.mk.inj","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\na✝ : α\nf✝ : β a✝ → WType β\na : α\nf : β a → WType β\nx✝ : Eq (WType.mk a✝ f✝) (WType.mk a f)\n⊢ And (Eq a✝ a) (HEq f✝ f)","decl":"/--\nGiven `β : α → Type*`, `WType β` is the type of finitely branching trees where nodes are labeled by\nelements of `α` and the children of a node labeled `a` are indexed by elements of `β a`.\n-/\ninductive WType {α : Type*} (β : α → Type*)\n  | mk (a : α) (f : β a → WType β) : WType β\n\n"}
{"name":"WType.mk.injEq","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\na✝ : α\nf✝ : β a✝ → WType β\na : α\nf : β a → WType β\n⊢ Eq (Eq (WType.mk a✝ f✝) (WType.mk a f)) (And (Eq a✝ a) (HEq f✝ f))","decl":"/--\nGiven `β : α → Type*`, `WType β` is the type of finitely branching trees where nodes are labeled by\nelements of `α` and the children of a node labeled `a` are indexed by elements of `β a`.\n-/\ninductive WType {α : Type*} (β : α → Type*)\n  | mk (a : α) (f : β a → WType β) : WType β\n\n"}
{"name":"WType.ofSigma_toSigma","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nw : WType β\n⊢ Eq (WType.ofSigma w.toSigma) w","decl":"@[simp]\ntheorem ofSigma_toSigma : ∀ w : WType β, ofSigma (toSigma w) = w\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"WType.toSigma_ofSigma","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\ns : Sigma fun a => β a → WType β\n⊢ Eq (WType.ofSigma s).toSigma s","decl":"@[simp]\ntheorem toSigma_ofSigma : ∀ s : Σa : α, β a → WType β, toSigma (ofSigma s) = s\n  | ⟨_, _⟩ => rfl\n\n"}
{"name":"WType.equivSigma_apply","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\na✝ : WType β\n⊢ Eq ((WType.equivSigma β) a✝) a✝.toSigma","decl":"/-- The canonical bijection with the sigma type, showing that `WType` is a fixed point of\n  the polynomial functor `X ↦ Σ a : α, β a → X`. -/\n@[simps]\ndef equivSigma : WType β ≃ Σa : α, β a → WType β where\n  toFun := toSigma\n  invFun := ofSigma\n  left_inv := ofSigma_toSigma\n  right_inv := toSigma_ofSigma\n\n"}
{"name":"WType.equivSigma_symm_apply","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\na✝ : Sigma fun a => β a → WType β\n⊢ Eq ((WType.equivSigma β).symm a✝) (WType.ofSigma a✝)","decl":"/-- The canonical bijection with the sigma type, showing that `WType` is a fixed point of\n  the polynomial functor `X ↦ Σ a : α, β a → X`. -/\n@[simps]\ndef equivSigma : WType β ≃ Σa : α, β a → WType β where\n  toFun := toSigma\n  invFun := ofSigma\n  left_inv := ofSigma_toSigma\n  right_inv := toSigma_ofSigma\n\n"}
{"name":"WType.elim_injective","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nγ : Type u_3\nfγ : (Sigma fun a => β a → γ) → γ\nfγ_injective : Function.Injective fγ\n⊢ Function.Injective (WType.elim γ fγ)","decl":"theorem elim_injective (γ : Type*) (fγ : (Σa : α, β a → γ) → γ)\n    (fγ_injective : Function.Injective fγ) : Function.Injective (elim γ fγ)\n  | ⟨a₁, f₁⟩, ⟨a₂, f₂⟩, h => by\n    obtain ⟨rfl, h⟩ := Sigma.mk.inj_iff.mp (fγ_injective h)\n    congr with x\n    exact elim_injective γ fγ fγ_injective (congr_fun (eq_of_heq h) x :)\n\n"}
{"name":"WType.instIsEmpty","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\nhα : IsEmpty α\n⊢ IsEmpty (WType β)","decl":"instance [hα : IsEmpty α] : IsEmpty (WType β) :=\n  ⟨fun w => WType.recOn w (IsEmpty.elim hα)⟩\n\n"}
{"name":"WType.infinite_of_nonempty_of_isEmpty","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\na b : α\nha : Nonempty (β a)\nhe : IsEmpty (β b)\n⊢ Infinite (WType β)","decl":"theorem infinite_of_nonempty_of_isEmpty (a b : α) [ha : Nonempty (β a)] [he : IsEmpty (β b)] :\n    Infinite (WType β) :=\n  ⟨by\n    intro hf\n    have hba : b ≠ a := fun h => ha.elim (IsEmpty.elim' (show IsEmpty (β a) from h ▸ he))\n    refine\n      not_injective_infinite_finite\n        (fun n : ℕ =>\n          show WType β from Nat.recOn n ⟨b, IsEmpty.elim' he⟩ fun _ ih => ⟨a, fun _ => ih⟩)\n        ?_\n    intro n m h\n    induction' n with n ih generalizing m\n    · cases' m with m <;> simp_all\n    · cases' m with m\n      · simp_all\n      · refine congr_arg Nat.succ (ih ?_)\n        simp_all [funext_iff]⟩\n\n"}
{"name":"WType.depth_pos","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\ninst✝ : (a : α) → Fintype (β a)\nt : WType β\n⊢ LT.lt 0 t.depth","decl":"theorem depth_pos (t : WType β) : 0 < t.depth := by\n  cases t\n  apply Nat.succ_pos\n\n"}
{"name":"WType.depth_lt_depth_mk","module":"Mathlib.Data.W.Basic","initialProofState":"α : Type u_1\nβ : α → Type u_2\ninst✝ : (a : α) → Fintype (β a)\na : α\nf : β a → WType β\ni : β a\n⊢ LT.lt (f i).depth (WType.mk a f).depth","decl":"theorem depth_lt_depth_mk (a : α) (f : β a → WType β) (i : β a) : depth (f i) < depth ⟨a, f⟩ :=\n  Nat.lt_succ_of_le (Finset.le_sup (f := (depth <| f ·)) (Finset.mem_univ i))\n\n/-\nShow that W types are encodable when `α` is an encodable fintype and for every `a : α`, `β a` is\nencodable.\n\nWe define an auxiliary type `WType' β n` of trees of depth at most `n`, and then we show by\ninduction on `n` that these are all encodable. These auxiliary constructions are not interesting in\nand of themselves, so we mark them as `private`.\n-/\n"}
