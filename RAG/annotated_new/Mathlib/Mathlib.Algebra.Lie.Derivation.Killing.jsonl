{"name":"LieDerivation.IsKilling.killingForm_restrict_range_ad","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : Field R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : Module.Finite R L\n⊢ Eq ((killingForm R (LieDerivation R L L)).restrict (LieDerivation.ad R L).range.toSubmodule) (killingForm R (Subtype fun x => Membership.mem (LieDerivation.ad R L).range x))","decl":"lemma killingForm_restrict_range_ad [Module.Finite R L] :\n    (killingForm R 𝔻).restrict 𝕀 = killingForm R 𝕀 := by\n  rw [← (ad_isIdealMorphism R L).eq, ← LieIdeal.killingForm_eq]\n  rfl\n\n"}
{"name":"LieDerivation.IsKilling.rangeAdOrthogonal_carrier","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : Field R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (↑(LieDerivation.IsKilling.rangeAdOrthogonal R L)) (setOf fun m => ∀ (a : L), (killingForm R (LieDerivation R L L)).IsOrtho ((LieDerivation.ad R L) a) m)","decl":"/-- The orthogonal complement of the inner derivations is a Lie submodule of all derivations. -/\n@[simps!] noncomputable def rangeAdOrthogonal : LieSubmodule R L (LieDerivation R L L) where\n  __ := 𝕀ᗮ\n  lie_mem := by\n    intro x D hD\n    have : 𝕀ᗮ = (ad R L).idealRange.killingCompl := by simp [← (ad_isIdealMorphism R L).eq]\n    change D ∈ 𝕀ᗮ at hD\n    change ⁅x, D⁆ ∈ 𝕀ᗮ\n    rw [this] at hD ⊢\n    rw [← lie_ad]\n    exact lie_mem_right _ _ (ad R L).idealRange.killingCompl _ _ hD\n\n"}
{"name":"LieDerivation.IsKilling.ad_mem_orthogonal_of_mem_orthogonal","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝² : Field R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nD : LieDerivation R L L\nhD : Membership.mem ((killingForm R (LieDerivation R L L)).orthogonal (LieDerivation.ad R L).range.toSubmodule) D\nx : L\n⊢ Membership.mem ((killingForm R (LieDerivation R L L)).orthogonal (LieDerivation.ad R L).range.toSubmodule) ((LieDerivation.ad R L) (D x))","decl":"/-- If a derivation `D` is in the Killing orthogonal of the range of the adjoint action, then, for\nany `x : L`, `ad (D x)` is also in this orthogonal. -/\nlemma ad_mem_orthogonal_of_mem_orthogonal {D : LieDerivation R L L} (hD : D ∈ 𝕀ᗮ) (x : L) :\n    ad R L (D x) ∈ 𝕀ᗮ := by\n  simp only [ad_apply_lieDerivation, LieHom.range_toSubmodule, neg_mem_iff]\n  exact (rangeAdOrthogonal R L).lie_mem hD\n\n"}
{"name":"LieDerivation.IsKilling.ad_mem_ker_killingForm_ad_range_of_mem_orthogonal","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : Field R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : Module.Finite R L\nD : LieDerivation R L L\nhD : Membership.mem ((killingForm R (LieDerivation R L L)).orthogonal (LieDerivation.ad R L).range.toSubmodule) D\nx : L\n⊢ Membership.mem (Submodule.map (LieDerivation.ad R L).range.subtype (LinearMap.ker (killingForm R (Subtype fun x => Membership.mem (LieDerivation.ad R L).range x)))) ((LieDerivation.ad R L) (D x))","decl":"lemma ad_mem_ker_killingForm_ad_range_of_mem_orthogonal\n    {D : LieDerivation R L L} (hD : D ∈ 𝕀ᗮ) (x : L) :\n    ad R L (D x) ∈ (LinearMap.ker (killingForm R 𝕀)).map (LieHom.range (ad R L)).subtype := by\n  rw [← killingForm_restrict_range_ad]\n  exact LinearMap.BilinForm.inf_orthogonal_self_le_ker_restrict\n    (LieModule.traceForm_isSymm R 𝔻 𝔻).isRefl ⟨by simp, ad_mem_orthogonal_of_mem_orthogonal hD x⟩\n\n"}
{"name":"LieDerivation.IsKilling.ad_apply_eq_zero_iff","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : Field R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : Module.Finite R L\ninst✝ : LieAlgebra.IsKilling R L\nx : L\n⊢ Iff (Eq ((LieDerivation.ad R L) x) 0) (Eq x 0)","decl":"@[simp] lemma ad_apply_eq_zero_iff (x : L) : ad R L x = 0 ↔ x = 0 := by\n  refine ⟨fun h ↦ ?_, fun h ↦ by simp [h]⟩\n  rwa [← LieHom.mem_ker, ad_ker_eq_center, LieAlgebra.HasTrivialRadical.center_eq_bot,\n    LieSubmodule.mem_bot] at h\n\n"}
{"name":"LieDerivation.IsKilling.instIsKilling_range_ad","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝³ : Field R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : LieAlgebra.IsKilling R L\n⊢ LieAlgebra.IsKilling R (Subtype fun x => Membership.mem (LieDerivation.ad R L).range x)","decl":"instance instIsKilling_range_ad : LieAlgebra.IsKilling R 𝕀 :=\n  (LieEquiv.ofInjective (ad R L) (injective_ad_of_center_eq_bot <| by simp)).isKilling\n\n"}
{"name":"LieDerivation.IsKilling.killingForm_restrict_range_ad_nondegenerate","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : Field R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : Module.Finite R L\ninst✝ : LieAlgebra.IsKilling R L\n⊢ ((killingForm R (LieDerivation R L L)).restrict (LieDerivation.ad R L).range.toSubmodule).Nondegenerate","decl":"/-- The restriction of the Killing form of a finite-dimensional Killing Lie algebra to the range of\nthe adjoint action is nondegenerate. -/\nlemma killingForm_restrict_range_ad_nondegenerate :\n    ((killingForm R 𝔻).restrict 𝕀).Nondegenerate := by\n  convert LieAlgebra.IsKilling.killingForm_nondegenerate R 𝕀\n  exact killingForm_restrict_range_ad R L\n\n"}
{"name":"LieDerivation.IsKilling.range_ad_eq_top","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : Field R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : Module.Finite R L\ninst✝ : LieAlgebra.IsKilling R L\n⊢ Eq (LieDerivation.ad R L).range Top.top","decl":"/-- The range of the adjoint action on a finite-dimensional Killing Lie algebra is full. -/\n@[simp]\nlemma range_ad_eq_top : 𝕀 = ⊤ := by\n  rw [← LieSubalgebra.toSubmodule_inj]\n  apply LinearMap.BilinForm.eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot\n    (LieModule.traceForm_isSymm R 𝔻 𝔻).isRefl (killingForm_restrict_range_ad_nondegenerate R L)\n  refine (Submodule.eq_bot_iff _).mpr fun D hD ↦ ext fun x ↦ ?_\n  simpa using ad_mem_ker_killingForm_ad_range_of_mem_orthogonal hD x\n\n"}
{"name":"LieDerivation.IsKilling.exists_eq_ad","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁴ : Field R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : Module.Finite R L\ninst✝ : LieAlgebra.IsKilling R L\nD : LieDerivation R L L\n⊢ Exists fun x => Eq ((LieDerivation.ad R L) x) D","decl":"variable {R L} in\n/-- Every derivation of a finite-dimensional Killing Lie algebra is an inner derivation. -/\nlemma exists_eq_ad (D : 𝔻) : ∃ x, ad R L x = D := by\n  change D ∈ 𝕀\n  rw [range_ad_eq_top R L]\n  exact Submodule.mem_top\n\n"}
