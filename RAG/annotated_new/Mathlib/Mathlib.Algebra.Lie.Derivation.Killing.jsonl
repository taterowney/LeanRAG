{"name":"LieDerivation.IsKilling.killingForm_restrict_range_ad","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœÂ³ : Field R\ninstâœÂ² : LieRing L\ninstâœÂ¹ : LieAlgebra R L\ninstâœ : Module.Finite R L\nâŠ¢ Eq ((killingForm R (LieDerivation R L L)).restrict (LieDerivation.ad R L).range.toSubmodule) (killingForm R (Subtype fun x => Membership.mem (LieDerivation.ad R L).range x))","decl":"lemma killingForm_restrict_range_ad [Module.Finite R L] :\n    (killingForm R ğ”»).restrict ğ•€ = killingForm R ğ•€ := by\n  rw [â† (ad_isIdealMorphism R L).eq, â† LieIdeal.killingForm_eq]\n  rfl\n\n"}
{"name":"LieDerivation.IsKilling.rangeAdOrthogonal_carrier","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœÂ² : Field R\ninstâœÂ¹ : LieRing L\ninstâœ : LieAlgebra R L\nâŠ¢ Eq (â†‘(LieDerivation.IsKilling.rangeAdOrthogonal R L)) (setOf fun m => âˆ€ (a : L), (killingForm R (LieDerivation R L L)).IsOrtho ((LieDerivation.ad R L) a) m)","decl":"/-- The orthogonal complement of the inner derivations is a Lie submodule of all derivations. -/\n@[simps!] noncomputable def rangeAdOrthogonal : LieSubmodule R L (LieDerivation R L L) where\n  __ := ğ•€á—®\n  lie_mem := by\n    intro x D hD\n    have : ğ•€á—® = (ad R L).idealRange.killingCompl := by simp [â† (ad_isIdealMorphism R L).eq]\n    change D âˆˆ ğ•€á—® at hD\n    change â…x, Dâ† âˆˆ ğ•€á—®\n    rw [this] at hD âŠ¢\n    rw [â† lie_ad]\n    exact lie_mem_right _ _ (ad R L).idealRange.killingCompl _ _ hD\n\n"}
{"name":"LieDerivation.IsKilling.ad_mem_orthogonal_of_mem_orthogonal","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœÂ² : Field R\ninstâœÂ¹ : LieRing L\ninstâœ : LieAlgebra R L\nD : LieDerivation R L L\nhD : Membership.mem ((killingForm R (LieDerivation R L L)).orthogonal (LieDerivation.ad R L).range.toSubmodule) D\nx : L\nâŠ¢ Membership.mem ((killingForm R (LieDerivation R L L)).orthogonal (LieDerivation.ad R L).range.toSubmodule) ((LieDerivation.ad R L) (D x))","decl":"/-- If a derivation `D` is in the Killing orthogonal of the range of the adjoint action, then, for\nany `x : L`, `ad (D x)` is also in this orthogonal. -/\nlemma ad_mem_orthogonal_of_mem_orthogonal {D : LieDerivation R L L} (hD : D âˆˆ ğ•€á—®) (x : L) :\n    ad R L (D x) âˆˆ ğ•€á—® := by\n  simp only [ad_apply_lieDerivation, LieHom.range_toSubmodule, neg_mem_iff]\n  exact (rangeAdOrthogonal R L).lie_mem hD\n\n"}
{"name":"LieDerivation.IsKilling.ad_mem_ker_killingForm_ad_range_of_mem_orthogonal","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœÂ³ : Field R\ninstâœÂ² : LieRing L\ninstâœÂ¹ : LieAlgebra R L\ninstâœ : Module.Finite R L\nD : LieDerivation R L L\nhD : Membership.mem ((killingForm R (LieDerivation R L L)).orthogonal (LieDerivation.ad R L).range.toSubmodule) D\nx : L\nâŠ¢ Membership.mem (Submodule.map (LieDerivation.ad R L).range.subtype (LinearMap.ker (killingForm R (Subtype fun x => Membership.mem (LieDerivation.ad R L).range x)))) ((LieDerivation.ad R L) (D x))","decl":"lemma ad_mem_ker_killingForm_ad_range_of_mem_orthogonal\n    {D : LieDerivation R L L} (hD : D âˆˆ ğ•€á—®) (x : L) :\n    ad R L (D x) âˆˆ (LinearMap.ker (killingForm R ğ•€)).map (LieHom.range (ad R L)).subtype := by\n  rw [â† killingForm_restrict_range_ad]\n  exact LinearMap.BilinForm.inf_orthogonal_self_le_ker_restrict\n    (LieModule.traceForm_isSymm R ğ”» ğ”»).isRefl âŸ¨by simp, ad_mem_orthogonal_of_mem_orthogonal hD xâŸ©\n\n"}
{"name":"LieDerivation.IsKilling.ad_apply_eq_zero_iff","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœâ´ : Field R\ninstâœÂ³ : LieRing L\ninstâœÂ² : LieAlgebra R L\ninstâœÂ¹ : Module.Finite R L\ninstâœ : LieAlgebra.IsKilling R L\nx : L\nâŠ¢ Iff (Eq ((LieDerivation.ad R L) x) 0) (Eq x 0)","decl":"@[simp] lemma ad_apply_eq_zero_iff (x : L) : ad R L x = 0 â†” x = 0 := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ by simp [h]âŸ©\n  rwa [â† LieHom.mem_ker, ad_ker_eq_center, LieAlgebra.HasTrivialRadical.center_eq_bot,\n    LieSubmodule.mem_bot] at h\n\n"}
{"name":"LieDerivation.IsKilling.instIsKilling_range_ad","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœÂ³ : Field R\ninstâœÂ² : LieRing L\ninstâœÂ¹ : LieAlgebra R L\ninstâœ : LieAlgebra.IsKilling R L\nâŠ¢ LieAlgebra.IsKilling R (Subtype fun x => Membership.mem (LieDerivation.ad R L).range x)","decl":"instance instIsKilling_range_ad : LieAlgebra.IsKilling R ğ•€ :=\n  (LieEquiv.ofInjective (ad R L) (injective_ad_of_center_eq_bot <| by simp)).isKilling\n\n"}
{"name":"LieDerivation.IsKilling.killingForm_restrict_range_ad_nondegenerate","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœâ´ : Field R\ninstâœÂ³ : LieRing L\ninstâœÂ² : LieAlgebra R L\ninstâœÂ¹ : Module.Finite R L\ninstâœ : LieAlgebra.IsKilling R L\nâŠ¢ ((killingForm R (LieDerivation R L L)).restrict (LieDerivation.ad R L).range.toSubmodule).Nondegenerate","decl":"/-- The restriction of the Killing form of a finite-dimensional Killing Lie algebra to the range of\nthe adjoint action is nondegenerate. -/\nlemma killingForm_restrict_range_ad_nondegenerate :\n    ((killingForm R ğ”»).restrict ğ•€).Nondegenerate := by\n  convert LieAlgebra.IsKilling.killingForm_nondegenerate R ğ•€\n  exact killingForm_restrict_range_ad R L\n\n"}
{"name":"LieDerivation.IsKilling.range_ad_eq_top","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœâ´ : Field R\ninstâœÂ³ : LieRing L\ninstâœÂ² : LieAlgebra R L\ninstâœÂ¹ : Module.Finite R L\ninstâœ : LieAlgebra.IsKilling R L\nâŠ¢ Eq (LieDerivation.ad R L).range Top.top","decl":"/-- The range of the adjoint action on a finite-dimensional Killing Lie algebra is full. -/\n@[simp]\nlemma range_ad_eq_top : ğ•€ = âŠ¤ := by\n  rw [â† LieSubalgebra.toSubmodule_inj]\n  apply LinearMap.BilinForm.eq_top_of_restrict_nondegenerate_of_orthogonal_eq_bot\n    (LieModule.traceForm_isSymm R ğ”» ğ”»).isRefl (killingForm_restrict_range_ad_nondegenerate R L)\n  refine (Submodule.eq_bot_iff _).mpr fun D hD â†¦ ext fun x â†¦ ?_\n  simpa using ad_mem_ker_killingForm_ad_range_of_mem_orthogonal hD x\n\n"}
{"name":"LieDerivation.IsKilling.exists_eq_ad","module":"Mathlib.Algebra.Lie.Derivation.Killing","initialProofState":"R : Type u_1\nL : Type u_2\ninstâœâ´ : Field R\ninstâœÂ³ : LieRing L\ninstâœÂ² : LieAlgebra R L\ninstâœÂ¹ : Module.Finite R L\ninstâœ : LieAlgebra.IsKilling R L\nD : LieDerivation R L L\nâŠ¢ Exists fun x => Eq ((LieDerivation.ad R L) x) D","decl":"variable {R L} in\n/-- Every derivation of a finite-dimensional Killing Lie algebra is an inner derivation. -/\nlemma exists_eq_ad (D : ğ”») : âˆƒ x, ad R L x = D := by\n  change D âˆˆ ğ•€\n  rw [range_ad_eq_top R L]\n  exact Submodule.mem_top\n\n"}
