{"name":"TypeVec.Arrow.ext","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\nf g : α.Arrow β\na✝ : ∀ (i : Fin2 n), Eq (f i) (g i)\n⊢ Eq f g","decl":"/-- Extensionality for arrows -/\n@[ext]\ntheorem Arrow.ext {α β : TypeVec n} (f g : α ⟹ β) :\n    (∀ i, f i = g i) → f = g := by\n  intro h; funext i; apply h\n\n"}
{"name":"TypeVec.Arrow.ext_iff","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\nf g : α.Arrow β\n⊢ Iff (Eq f g) (∀ (i : Fin2 n), Eq (f i) (g i))","decl":"/-- Extensionality for arrows -/\n@[ext]\ntheorem Arrow.ext {α β : TypeVec n} (f g : α ⟹ β) :\n    (∀ i, f i = g i) → f = g := by\n  intro h; funext i; apply h\n\n"}
{"name":"TypeVec.id_comp","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\nf : α.Arrow β\n⊢ Eq (TypeVec.comp TypeVec.id f) f","decl":"@[simp]\ntheorem id_comp {α β : TypeVec n} (f : α ⟹ β) : id ⊚ f = f :=\n  rfl\n\n"}
{"name":"TypeVec.comp_id","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\nf : α.Arrow β\n⊢ Eq (TypeVec.comp f TypeVec.id) f","decl":"@[simp]\ntheorem comp_id {α β : TypeVec n} (f : α ⟹ β) : f ⊚ id = f :=\n  rfl\n\n"}
{"name":"TypeVec.comp_assoc","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\nγ : TypeVec.{u_3} n\nδ : TypeVec.{u_4} n\nh : γ.Arrow δ\ng : β.Arrow γ\nf : α.Arrow β\n⊢ Eq (TypeVec.comp (TypeVec.comp h g) f) (TypeVec.comp h (TypeVec.comp g f))","decl":"theorem comp_assoc {α β γ δ : TypeVec n} (h : γ ⟹ δ) (g : β ⟹ γ) (f : α ⟹ β) :\n    (h ⊚ g) ⊚ f = h ⊚ g ⊚ f :=\n  rfl\n\n"}
{"name":"TypeVec.drop_append1","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : Type u_1\ni : Fin2 n\n⊢ Eq ((α.append1 β).drop i) (α i)","decl":"theorem drop_append1 {α : TypeVec n} {β : Type*} {i : Fin2 n} : drop (append1 α β) i = α i :=\n  rfl\n\n"}
{"name":"TypeVec.drop_append1'","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : Type u_1\n⊢ Eq (α.append1 β).drop α","decl":"theorem drop_append1' {α : TypeVec n} {β : Type*} : drop (append1 α β) = α :=\n  funext fun _ => drop_append1\n\n"}
{"name":"TypeVec.last_append1","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : Type u_1\n⊢ Eq (α.append1 β).last β","decl":"theorem last_append1 {α : TypeVec n} {β : Type*} : last (append1 α β) = β :=\n  rfl\n\n"}
{"name":"TypeVec.append1_drop_last","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\n⊢ Eq (α.drop.append1 α.last) α","decl":"@[simp]\ntheorem append1_drop_last (α : TypeVec (n + 1)) : append1 (drop α) (last α) = α :=\n  funext fun i => by cases i <;> rfl\n\n"}
{"name":"TypeVec.append1_cases_append1","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nC : TypeVec.{u_1} (HAdd.hAdd n 1) → Sort u\nH : (α : TypeVec.{u_1} n) → (β : Type u_1) → C (α.append1 β)\nα : TypeVec.{u_1} n\nβ : Type u_1\n⊢ Eq (TypeVec.append1Cases H (α.append1 β)) (H α β)","decl":"@[simp]\ntheorem append1_cases_append1 {C : TypeVec (n + 1) → Sort u} (H : ∀ α β, C (append1 α β)) (α β) :\n    @append1Cases _ C H (append1 α β) = H α β :=\n  rfl\n\n"}
{"name":"TypeVec.eq_of_drop_last_eq","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\nβ : TypeVec.{u_2} (HAdd.hAdd n 1)\nf g : α.Arrow β\nh₀ : Eq (TypeVec.dropFun f) (TypeVec.dropFun g)\nh₁ : Eq (TypeVec.lastFun f) (TypeVec.lastFun g)\n⊢ Eq f g","decl":"theorem eq_of_drop_last_eq {α β : TypeVec (n + 1)} {f g : α ⟹ β} (h₀ : dropFun f = dropFun g)\n    (h₁ : lastFun f = lastFun g) : f = g := by\n  -- Porting note: FIXME: congr_fun h₀ <;> ext1 ⟨⟩ <;> apply_assumption\n  refine funext (fun x => ?_)\n  cases x\n  · apply h₁\n  · apply congr_fun h₀\n\n"}
{"name":"TypeVec.dropFun_splitFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\nα' : TypeVec.{u_2} (HAdd.hAdd n 1)\nf : α.drop.Arrow α'.drop\ng : α.last → α'.last\n⊢ Eq (TypeVec.dropFun (TypeVec.splitFun f g)) f","decl":"@[simp]\ntheorem dropFun_splitFun {α α' : TypeVec (n + 1)} (f : drop α ⟹ drop α') (g : last α → last α') :\n    dropFun (splitFun f g) = f :=\n  rfl\n\n"}
{"name":"TypeVec.lastFun_splitFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\nα' : TypeVec.{u_2} (HAdd.hAdd n 1)\nf : α.drop.Arrow α'.drop\ng : α.last → α'.last\n⊢ Eq (TypeVec.lastFun (TypeVec.splitFun f g)) g","decl":"@[simp]\ntheorem lastFun_splitFun {α α' : TypeVec (n + 1)} (f : drop α ⟹ drop α') (g : last α → last α') :\n    lastFun (splitFun f g) = g :=\n  rfl\n\n"}
{"name":"TypeVec.dropFun_appendFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nα' : TypeVec.{u_2} n\nβ : Type u_1\nβ' : Type u_2\nf : α.Arrow α'\ng : β → β'\n⊢ Eq (TypeVec.dropFun (TypeVec.appendFun f g)) f","decl":"@[simp]\ntheorem dropFun_appendFun {α α' : TypeVec n} {β β' : Type*} (f : α ⟹ α') (g : β → β') :\n    dropFun (f ::: g) = f :=\n  rfl\n\n"}
{"name":"TypeVec.lastFun_appendFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nα' : TypeVec.{u_2} n\nβ : Type u_1\nβ' : Type u_2\nf : α.Arrow α'\ng : β → β'\n⊢ Eq (TypeVec.lastFun (TypeVec.appendFun f g)) g","decl":"@[simp]\ntheorem lastFun_appendFun {α α' : TypeVec n} {β β' : Type*} (f : α ⟹ α') (g : β → β') :\n    lastFun (f ::: g) = g :=\n  rfl\n\n"}
{"name":"TypeVec.split_dropFun_lastFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\nα' : TypeVec.{u_2} (HAdd.hAdd n 1)\nf : α.Arrow α'\n⊢ Eq (TypeVec.splitFun (TypeVec.dropFun f) (TypeVec.lastFun f)) f","decl":"theorem split_dropFun_lastFun {α α' : TypeVec (n + 1)} (f : α ⟹ α') :\n    splitFun (dropFun f) (lastFun f) = f :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.splitFun_inj","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\nα' : TypeVec.{u_2} (HAdd.hAdd n 1)\nf f' : α.drop.Arrow α'.drop\ng g' : α.last → α'.last\nH : Eq (TypeVec.splitFun f g) (TypeVec.splitFun f' g')\n⊢ And (Eq f f') (Eq g g')","decl":"theorem splitFun_inj {α α' : TypeVec (n + 1)} {f f' : drop α ⟹ drop α'} {g g' : last α → last α'}\n    (H : splitFun f g = splitFun f' g') : f = f' ∧ g = g' := by\n  rw [← dropFun_splitFun f g, H, ← lastFun_splitFun f g, H]; simp\n\n"}
{"name":"TypeVec.appendFun_inj","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nα' : TypeVec.{u_2} n\nβ : Type u_1\nβ' : Type u_2\nf f' : α.Arrow α'\ng g' : β → β'\na✝ : Eq (TypeVec.appendFun f g) (TypeVec.appendFun f' g')\n⊢ And (Eq f f') (Eq g g')","decl":"theorem appendFun_inj {α α' : TypeVec n} {β β' : Type*} {f f' : α ⟹ α'} {g g' : β → β'} :\n    (f ::: g : (α ::: β) ⟹ _) = (f' ::: g' : (α ::: β) ⟹ _)\n    → f = f' ∧ g = g' :=\n  splitFun_inj\n\n"}
{"name":"TypeVec.splitFun_comp","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα₀ : TypeVec.{u_1} (HAdd.hAdd n 1)\nα₁ : TypeVec.{u_2} (HAdd.hAdd n 1)\nα₂ : TypeVec.{u_3} (HAdd.hAdd n 1)\nf₀ : α₀.drop.Arrow α₁.drop\nf₁ : α₁.drop.Arrow α₂.drop\ng₀ : α₀.last → α₁.last\ng₁ : α₁.last → α₂.last\n⊢ Eq (TypeVec.splitFun (TypeVec.comp f₁ f₀) (Function.comp g₁ g₀)) (TypeVec.comp (TypeVec.splitFun f₁ g₁) (TypeVec.splitFun f₀ g₀))","decl":"theorem splitFun_comp {α₀ α₁ α₂ : TypeVec (n + 1)} (f₀ : drop α₀ ⟹ drop α₁)\n    (f₁ : drop α₁ ⟹ drop α₂) (g₀ : last α₀ → last α₁) (g₁ : last α₁ → last α₂) :\n    splitFun (f₁ ⊚ f₀) (g₁ ∘ g₀) = splitFun f₁ g₁ ⊚ splitFun f₀ g₀ :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.appendFun_comp_splitFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nγ : TypeVec.{u_2} n\nβ : Type u_1\nδ : Type u_2\nε : TypeVec.{u_3} (HAdd.hAdd n 1)\nf₀ : ε.drop.Arrow α\nf₁ : α.Arrow γ\ng₀ : ε.last → β\ng₁ : β → δ\n⊢ Eq (TypeVec.comp (TypeVec.appendFun f₁ g₁) (TypeVec.splitFun f₀ g₀)) (TypeVec.splitFun (TypeVec.comp f₁ f₀) (Function.comp g₁ g₀))","decl":"theorem appendFun_comp_splitFun {α γ : TypeVec n} {β δ : Type*} {ε : TypeVec (n + 1)}\n    (f₀ : drop ε ⟹ α) (f₁ : α ⟹ γ) (g₀ : last ε → β) (g₁ : β → δ) :\n    appendFun f₁ g₁ ⊚ splitFun f₀ g₀ = splitFun (α' := γ.append1 δ) (f₁ ⊚ f₀) (g₁ ∘ g₀) :=\n  (splitFun_comp _ _ _ _).symm\n\n"}
{"name":"TypeVec.appendFun_comp","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα₀ : TypeVec.{u_1} n\nα₁ : TypeVec.{u_2} n\nα₂ : TypeVec.{u_3} n\nβ₀ : Type u_1\nβ₁ : Type u_2\nβ₂ : Type u_3\nf₀ : α₀.Arrow α₁\nf₁ : α₁.Arrow α₂\ng₀ : β₀ → β₁\ng₁ : β₁ → β₂\n⊢ Eq (TypeVec.appendFun (TypeVec.comp f₁ f₀) (Function.comp g₁ g₀)) (TypeVec.comp (TypeVec.appendFun f₁ g₁) (TypeVec.appendFun f₀ g₀))","decl":"theorem appendFun_comp  {α₀ α₁ α₂ : TypeVec n}\n    {β₀ β₁ β₂ : Type*}\n    (f₀ : α₀ ⟹ α₁) (f₁ : α₁ ⟹ α₂)\n    (g₀ : β₀ → β₁) (g₁ : β₁ → β₂) :\n    (f₁ ⊚ f₀ ::: g₁ ∘ g₀) = (f₁ ::: g₁) ⊚ (f₀ ::: g₀) :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.appendFun_comp'","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα₀ : TypeVec.{u_1} n\nα₁ : TypeVec.{u_2} n\nα₂ : TypeVec.{u_3} n\nβ₀ : Type u_1\nβ₁ : Type u_2\nβ₂ : Type u_3\nf₀ : α₀.Arrow α₁\nf₁ : α₁.Arrow α₂\ng₀ : β₀ → β₁\ng₁ : β₁ → β₂\n⊢ Eq (TypeVec.comp (TypeVec.appendFun f₁ g₁) (TypeVec.appendFun f₀ g₀)) (TypeVec.appendFun (TypeVec.comp f₁ f₀) (Function.comp g₁ g₀))","decl":"theorem appendFun_comp' {α₀ α₁ α₂ : TypeVec n} {β₀ β₁ β₂ : Type*}\n    (f₀ : α₀ ⟹ α₁) (f₁ : α₁ ⟹ α₂) (g₀ : β₀ → β₁) (g₁ : β₁ → β₂) :\n    (f₁ ::: g₁) ⊚ (f₀ ::: g₀) = (f₁ ⊚ f₀ ::: g₁ ∘ g₀) :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.nilFun_comp","module":"Mathlib.Data.TypeVec","initialProofState":"α₀ : TypeVec.{u_1} 0\nf₀ : α₀.Arrow Fin2.elim0\n⊢ Eq (TypeVec.comp TypeVec.nilFun f₀) f₀","decl":"theorem nilFun_comp {α₀ : TypeVec 0} (f₀ : α₀ ⟹ Fin2.elim0) : nilFun ⊚ f₀ = f₀ :=\n  funext fun x => by apply Fin2.elim0 x -- Porting note: `by apply` is necessary?\n\n"}
{"name":"TypeVec.appendFun_comp_id","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u} n\nβ₀ β₁ β₂ : Type u\ng₀ : β₀ → β₁\ng₁ : β₁ → β₂\n⊢ Eq (TypeVec.appendFun TypeVec.id (Function.comp g₁ g₀)) (TypeVec.comp (TypeVec.appendFun TypeVec.id g₁) (TypeVec.appendFun TypeVec.id g₀))","decl":"theorem appendFun_comp_id {α : TypeVec n} {β₀ β₁ β₂ : Type u} (g₀ : β₀ → β₁) (g₁ : β₁ → β₂) :\n    (@id _ α ::: g₁ ∘ g₀) = (id ::: g₁) ⊚ (id ::: g₀) :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.dropFun_comp","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα₀ : TypeVec.{u_1} (HAdd.hAdd n 1)\nα₁ : TypeVec.{u_2} (HAdd.hAdd n 1)\nα₂ : TypeVec.{u_3} (HAdd.hAdd n 1)\nf₀ : α₀.Arrow α₁\nf₁ : α₁.Arrow α₂\n⊢ Eq (TypeVec.dropFun (TypeVec.comp f₁ f₀)) (TypeVec.comp (TypeVec.dropFun f₁) (TypeVec.dropFun f₀))","decl":"@[simp]\ntheorem dropFun_comp {α₀ α₁ α₂ : TypeVec (n + 1)} (f₀ : α₀ ⟹ α₁) (f₁ : α₁ ⟹ α₂) :\n    dropFun (f₁ ⊚ f₀) = dropFun f₁ ⊚ dropFun f₀ :=\n  rfl\n\n"}
{"name":"TypeVec.lastFun_comp","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα₀ : TypeVec.{u_1} (HAdd.hAdd n 1)\nα₁ : TypeVec.{u_2} (HAdd.hAdd n 1)\nα₂ : TypeVec.{u_3} (HAdd.hAdd n 1)\nf₀ : α₀.Arrow α₁\nf₁ : α₁.Arrow α₂\n⊢ Eq (TypeVec.lastFun (TypeVec.comp f₁ f₀)) (Function.comp (TypeVec.lastFun f₁) (TypeVec.lastFun f₀))","decl":"@[simp]\ntheorem lastFun_comp {α₀ α₁ α₂ : TypeVec (n + 1)} (f₀ : α₀ ⟹ α₁) (f₁ : α₁ ⟹ α₂) :\n    lastFun (f₁ ⊚ f₀) = lastFun f₁ ∘ lastFun f₀ :=\n  rfl\n\n"}
{"name":"TypeVec.appendFun_aux","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nα' : TypeVec.{u_2} n\nβ : Type u_1\nβ' : Type u_2\nf : (α.append1 β).Arrow (α'.append1 β')\n⊢ Eq (TypeVec.appendFun (TypeVec.dropFun f) (TypeVec.lastFun f)) f","decl":"theorem appendFun_aux {α α' : TypeVec n} {β β' : Type*} (f : (α ::: β) ⟹ (α' ::: β')) :\n    (dropFun f ::: lastFun f) = f :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.appendFun_id_id","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : Type u_1\n⊢ Eq (TypeVec.appendFun TypeVec.id id) TypeVec.id","decl":"theorem appendFun_id_id {α : TypeVec n} {β : Type*} :\n    (@TypeVec.id n α ::: @_root_.id β) = TypeVec.id :=\n  eq_of_drop_last_eq rfl rfl\n\n"}
{"name":"TypeVec.subsingleton0","module":"Mathlib.Data.TypeVec","initialProofState":"⊢ Subsingleton (TypeVec.{u_1} 0)","decl":"instance subsingleton0 : Subsingleton (TypeVec 0) :=\n  ⟨fun a b => funext fun a => by apply Fin2.elim0 a⟩ -- Porting note: `by apply` necessary?\n\n-- Porting note: `simp` attribute `TypeVec` moved to file `Tactic/Attr/Register.lean`\n\n"}
{"name":"TypeVec.casesNil_append1","module":"Mathlib.Data.TypeVec","initialProofState":"β : TypeVec.{u_2} 0 → Sort u_1\nf : β Fin2.elim0\n⊢ Eq (TypeVec.casesNil f Fin2.elim0) f","decl":"protected theorem casesNil_append1 {β : TypeVec 0 → Sort*} (f : β Fin2.elim0) :\n    TypeVec.casesNil f Fin2.elim0 = f :=\n  rfl\n\n"}
{"name":"TypeVec.casesCons_append1","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nβ : TypeVec.{u_2} (HAdd.hAdd n 1) → Sort u_1\nf : (t : Type u_2) → (v : TypeVec.{u_2} n) → β (v.append1 t)\nv : TypeVec.{u_2} n\nα : Type u_2\n⊢ Eq (TypeVec.casesCons n f (v.append1 α)) (f α v)","decl":"protected theorem casesCons_append1 (n : ℕ) {β : TypeVec (n + 1) → Sort*}\n    (f : ∀ (t) (v : TypeVec n), β (v ::: t)) (v : TypeVec n) (α) :\n    TypeVec.casesCons n f (v ::: α) = f α v :=\n  rfl\n\n"}
{"name":"TypeVec.typevecCasesNil₂_appendFun","module":"Mathlib.Data.TypeVec","initialProofState":"β : TypeVec.Arrow Fin2.elim0 Fin2.elim0 → Sort u_1\nf : β TypeVec.nilFun\n⊢ Eq (TypeVec.typevecCasesNil₂ f TypeVec.nilFun) f","decl":"theorem typevecCasesNil₂_appendFun {β : Fin2.elim0 ⟹ Fin2.elim0 → Sort*} (f : β nilFun) :\n    typevecCasesNil₂ f nilFun = f :=\n  rfl\n\n"}
{"name":"TypeVec.typevecCasesCons₂_appendFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nt : Type u_1\nt' : Type u_2\nv : TypeVec.{u_1} n\nv' : TypeVec.{u_2} n\nβ : (v.append1 t).Arrow (v'.append1 t') → Sort u_3\nF : (f : t → t') → (fs : v.Arrow v') → β (TypeVec.appendFun fs f)\nf : t → t'\nfs : v.Arrow v'\n⊢ Eq (TypeVec.typevecCasesCons₂ n t t' v v' F (TypeVec.appendFun fs f)) (F f fs)","decl":"theorem typevecCasesCons₂_appendFun (n : ℕ) (t t' : Type*) (v v' : TypeVec n)\n    {β : (v ::: t) ⟹ (v' ::: t') → Sort*}\n    (F : ∀ (f : t → t') (fs : v ⟹ v'), β (fs ::: f))\n    (f fs) :\n    typevecCasesCons₂ n t t' v v' F (fs ::: f) = F f fs :=\n  rfl\n\n-- for lifting predicates and relations\n"}
{"name":"TypeVec.const_append1","module":"Mathlib.Data.TypeVec","initialProofState":"β : Type u_1\nγ : Type u_2\nx : γ\nn : Nat\nα : TypeVec.{u_1} n\n⊢ Eq (TypeVec.const x (α.append1 β)) (TypeVec.appendFun (TypeVec.const x α) fun x_1 => x)","decl":"theorem const_append1 {β γ} (x : γ) {n} (α : TypeVec n) :\n    TypeVec.const x (α ::: β) = appendFun (TypeVec.const x α) fun _ => x := by\n  ext i : 1; cases i <;> rfl\n\n"}
{"name":"TypeVec.eq_nilFun","module":"Mathlib.Data.TypeVec","initialProofState":"α : TypeVec.{u_1} 0\nβ : TypeVec.{u_2} 0\nf : α.Arrow β\n⊢ Eq f TypeVec.nilFun","decl":"theorem eq_nilFun {α β : TypeVec 0} (f : α ⟹ β) : f = nilFun := by\n  ext x; cases x\n\n"}
{"name":"TypeVec.id_eq_nilFun","module":"Mathlib.Data.TypeVec","initialProofState":"α : TypeVec.{u_1} 0\n⊢ Eq TypeVec.id TypeVec.nilFun","decl":"theorem id_eq_nilFun {α : TypeVec 0} : @id _ α = nilFun := by\n  ext x; cases x\n\n"}
{"name":"TypeVec.const_nil","module":"Mathlib.Data.TypeVec","initialProofState":"β : Type u_1\nx : β\nα : TypeVec.{u_2} 0\n⊢ Eq (TypeVec.const x α) TypeVec.nilFun","decl":"theorem const_nil {β} (x : β) (α : TypeVec 0) : TypeVec.const x α = nilFun := by\n  ext i : 1; cases i\n\n"}
{"name":"TypeVec.repeat_eq_append1","module":"Mathlib.Data.TypeVec","initialProofState":"β : Type u_1\nn : Nat\nα : TypeVec.{u_1} n\n⊢ Eq (α.append1 β).repeatEq (TypeVec.splitFun α.repeatEq (Function.uncurry Eq))","decl":"@[typevec]\ntheorem repeat_eq_append1 {β} {n} (α : TypeVec n) :\n    repeatEq (α ::: β) = splitFun (α := (α ⊗ α) ::: _)\n    (α' := («repeat» n Prop) ::: _) (repeatEq α) (uncurry Eq) := by\n  induction n <;> rfl\n\n"}
{"name":"TypeVec.repeat_eq_nil","module":"Mathlib.Data.TypeVec","initialProofState":"α : TypeVec.{u_1} 0\n⊢ Eq α.repeatEq TypeVec.nilFun","decl":"@[typevec]\ntheorem repeat_eq_nil (α : TypeVec 0) : repeatEq α = nilFun := by ext i; cases i\n\n"}
{"name":"TypeVec.const_iff_true","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\ni : Fin2 n\nx : α i\np : Prop\n⊢ Iff (TypeVec.ofRepeat (TypeVec.const p α i x)) p","decl":"theorem const_iff_true {α : TypeVec n} {i x p} : ofRepeat (TypeVec.const p α i x) ↔ p := by\n  induction i with\n  | fz      => rfl\n  | fs _ ih => erw [TypeVec.const, @ih (drop α) x]\n\n\n"}
{"name":"TypeVec.prod_fst_mk","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα β : TypeVec.{u_1} n\ni : Fin2 n\na : α i\nb : β i\n⊢ Eq (TypeVec.prod.fst i (TypeVec.prod.mk i a b)) a","decl":"@[simp]\ntheorem prod_fst_mk {α β : TypeVec n} (i : Fin2 n) (a : α i) (b : β i) :\n    TypeVec.prod.fst i (prod.mk i a b) = a := by\n  induction i with\n  | fz => simp_all only [prod.fst, prod.mk]\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.prod_snd_mk","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα β : TypeVec.{u_1} n\ni : Fin2 n\na : α i\nb : β i\n⊢ Eq (TypeVec.prod.snd i (TypeVec.prod.mk i a b)) b","decl":"@[simp]\ntheorem prod_snd_mk {α β : TypeVec n} (i : Fin2 n) (a : α i) (b : β i) :\n    TypeVec.prod.snd i (prod.mk i a b) = b := by\n  induction i with\n  | fz => simp_all [prod.snd, prod.mk]\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.fst_prod_mk","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα α' β β' : TypeVec.{u_1} n\nf : α.Arrow β\ng : α'.Arrow β'\n⊢ Eq (TypeVec.comp TypeVec.prod.fst (TypeVec.prod.map f g)) (TypeVec.comp f TypeVec.prod.fst)","decl":"theorem fst_prod_mk {α α' β β' : TypeVec n} (f : α ⟹ β) (g : α' ⟹ β') :\n    TypeVec.prod.fst ⊚ (f ⊗' g) = f ⊚ TypeVec.prod.fst := by\n  funext i; induction i with\n  | fz => rfl\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.snd_prod_mk","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα α' β β' : TypeVec.{u_1} n\nf : α.Arrow β\ng : α'.Arrow β'\n⊢ Eq (TypeVec.comp TypeVec.prod.snd (TypeVec.prod.map f g)) (TypeVec.comp g TypeVec.prod.snd)","decl":"theorem snd_prod_mk {α α' β β' : TypeVec n} (f : α ⟹ β) (g : α' ⟹ β') :\n    TypeVec.prod.snd ⊚ (f ⊗' g) = g ⊚ TypeVec.prod.snd := by\n  funext i; induction i with\n  | fz => rfl\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.fst_diag","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\n⊢ Eq (TypeVec.comp TypeVec.prod.fst TypeVec.prod.diag) TypeVec.id","decl":"theorem fst_diag {α : TypeVec n} : TypeVec.prod.fst ⊚ (prod.diag : α ⟹ _) = id := by\n  funext i; induction i with\n  | fz => rfl\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.snd_diag","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\n⊢ Eq (TypeVec.comp TypeVec.prod.snd TypeVec.prod.diag) TypeVec.id","decl":"theorem snd_diag {α : TypeVec n} : TypeVec.prod.snd ⊚ (prod.diag : α ⟹ _) = id := by\n  funext i; induction i with\n  | fz => rfl\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.repeatEq_iff_eq","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\ni : Fin2 n\nx y : α i\n⊢ Iff (TypeVec.ofRepeat (α.repeatEq i (TypeVec.prod.mk i x y))) (Eq x y)","decl":"theorem repeatEq_iff_eq {α : TypeVec n} {i x y} :\n    ofRepeat (repeatEq α i (prod.mk _ x y)) ↔ x = y := by\n  induction i with\n  | fz => rfl\n  | fs _ i_ih => erw [repeatEq, i_ih]\n\n"}
{"name":"TypeVec.subtypeVal_nil","module":"Mathlib.Data.TypeVec","initialProofState":"α : TypeVec.{u} 0\nps : α.Arrow (TypeVec.repeat 0 Prop)\n⊢ Eq (TypeVec.subtypeVal ps) TypeVec.nilFun","decl":"theorem subtypeVal_nil {α : TypeVec.{u} 0} (ps : α ⟹ «repeat» 0 Prop) :\n    TypeVec.subtypeVal ps = nilFun :=\n  funext <| by rintro ⟨⟩\n\n"}
{"name":"TypeVec.diag_sub_val","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u} n\n⊢ Eq (TypeVec.comp (TypeVec.subtypeVal α.repeatEq) TypeVec.diagSub) TypeVec.prod.diag","decl":"theorem diag_sub_val {n} {α : TypeVec.{u} n} : subtypeVal (repeatEq α) ⊚ diagSub = prod.diag := by\n  ext i x\n  induction i with\n  | fz => simp only [comp, subtypeVal, repeatEq.eq_2, diagSub, prod.diag]\n  | fs _ i_ih => apply @i_ih (drop α)\n\n"}
{"name":"TypeVec.prod_id","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα β : TypeVec.{u} n\n⊢ Eq (TypeVec.prod.map TypeVec.id TypeVec.id) TypeVec.id","decl":"theorem prod_id : ∀ {n} {α β : TypeVec.{u} n}, (id ⊗' id) = (id : α ⊗ β ⟹ _) := by\n  intros\n  ext i a\n  induction i with\n  | fz => cases a; rfl\n  | fs _ i_ih => apply i_ih\n\n"}
{"name":"TypeVec.append_prod_appendFun","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα α' β β' : TypeVec.{u} n\nφ φ' ψ ψ' : Type u\nf₀ : α.Arrow α'\ng₀ : β.Arrow β'\nf₁ : φ → φ'\ng₁ : ψ → ψ'\n⊢ Eq (TypeVec.appendFun (TypeVec.prod.map f₀ g₀) (Prod.map f₁ g₁)) (TypeVec.prod.map (TypeVec.appendFun f₀ f₁) (TypeVec.appendFun g₀ g₁))","decl":"theorem append_prod_appendFun {n} {α α' β β' : TypeVec.{u} n} {φ φ' ψ ψ' : Type u}\n    {f₀ : α ⟹ α'} {g₀ : β ⟹ β'} {f₁ : φ → φ'} {g₁ : ψ → ψ'} :\n    ((f₀ ⊗' g₀) ::: (_root_.Prod.map f₁ g₁)) = ((f₀ ::: f₁) ⊗' (g₀ ::: g₁)) := by\n  ext i a\n  cases i\n  · cases a\n    rfl\n  · rfl\n\n"}
{"name":"TypeVec.dropFun_diag","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\n⊢ Eq (TypeVec.dropFun TypeVec.prod.diag) TypeVec.prod.diag","decl":"@[simp]\ntheorem dropFun_diag {α} : dropFun (@prod.diag (n + 1) α) = prod.diag := by\n  ext i : 2\n  induction i <;> simp [dropFun, *] <;> rfl\n\n"}
{"name":"TypeVec.dropFun_subtypeVal","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\np : α.Arrow (TypeVec.repeat (HAdd.hAdd n 1) Prop)\n⊢ Eq (TypeVec.dropFun (TypeVec.subtypeVal p)) (TypeVec.subtypeVal (TypeVec.dropFun p))","decl":"@[simp]\ntheorem dropFun_subtypeVal {α} (p : α ⟹ «repeat» (n + 1) Prop) :\n    dropFun (subtypeVal p) = subtypeVal _ :=\n  rfl\n\n"}
{"name":"TypeVec.lastFun_subtypeVal","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\np : α.Arrow (TypeVec.repeat (HAdd.hAdd n 1) Prop)\n⊢ Eq (TypeVec.lastFun (TypeVec.subtypeVal p)) Subtype.val","decl":"@[simp]\ntheorem lastFun_subtypeVal {α} (p : α ⟹ «repeat» (n + 1) Prop) :\n    lastFun (subtypeVal p) = Subtype.val :=\n  rfl\n\n"}
{"name":"TypeVec.dropFun_toSubtype","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\np : α.Arrow (TypeVec.repeat (HAdd.hAdd n 1) Prop)\n⊢ Eq (TypeVec.dropFun (TypeVec.toSubtype p)) (TypeVec.toSubtype fun i => p i.fs)","decl":"@[simp]\ntheorem dropFun_toSubtype {α} (p : α ⟹ «repeat» (n + 1) Prop) :\n    dropFun (toSubtype p) = toSubtype _ := by\n  ext i\n  induction i <;> simp [dropFun, *] <;> rfl\n\n"}
{"name":"TypeVec.lastFun_toSubtype","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\np : α.Arrow (TypeVec.repeat (HAdd.hAdd n 1) Prop)\n⊢ Eq (TypeVec.lastFun (TypeVec.toSubtype p)) id","decl":"@[simp]\ntheorem lastFun_toSubtype {α} (p : α ⟹ «repeat» (n + 1) Prop) :\n    lastFun (toSubtype p) = _root_.id := by\n  ext i : 2\n  induction i; simp [dropFun, *]; rfl\n\n"}
{"name":"TypeVec.dropFun_of_subtype","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\np : α.Arrow (TypeVec.repeat (HAdd.hAdd n 1) Prop)\n⊢ Eq (TypeVec.dropFun (TypeVec.ofSubtype p)) (TypeVec.ofSubtype (TypeVec.dropFun p))","decl":"@[simp]\ntheorem dropFun_of_subtype {α} (p : α ⟹ «repeat» (n + 1) Prop) :\n    dropFun (ofSubtype p) = ofSubtype _ := by\n  ext i : 2\n  induction i <;> simp [dropFun, *] <;> rfl\n\n"}
{"name":"TypeVec.lastFun_of_subtype","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\np : α.Arrow (TypeVec.repeat (HAdd.hAdd n 1) Prop)\n⊢ Eq (TypeVec.lastFun (TypeVec.ofSubtype p)) id","decl":"@[simp]\ntheorem lastFun_of_subtype {α} (p : α ⟹ «repeat» (n + 1) Prop) :\n    lastFun (ofSubtype p) = _root_.id := rfl\n\n"}
{"name":"TypeVec.dropFun_RelLast'","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : Type u_1\nR : β → β → Prop\n⊢ Eq (TypeVec.dropFun (α.RelLast' R)) α.repeatEq","decl":"@[simp]\ntheorem dropFun_RelLast' {α : TypeVec n} {β} (R : β → β → Prop) :\n    dropFun (RelLast' α R) = repeatEq α :=\n  rfl\n\n"}
{"name":"TypeVec.dropFun_prod","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα α' β β' : TypeVec.{u_1} (HAdd.hAdd n 1)\nf : α.Arrow β\nf' : α'.Arrow β'\n⊢ Eq (TypeVec.dropFun (TypeVec.prod.map f f')) (TypeVec.prod.map (TypeVec.dropFun f) (TypeVec.dropFun f'))","decl":"@[simp]\ntheorem dropFun_prod {α α' β β' : TypeVec (n + 1)} (f : α ⟹ β) (f' : α' ⟹ β') :\n    dropFun (f ⊗' f') = (dropFun f ⊗' dropFun f') := by\n  ext i : 2\n  induction i <;> simp [dropFun, *] <;> rfl\n\n"}
{"name":"TypeVec.lastFun_prod","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα α' β β' : TypeVec.{u_1} (HAdd.hAdd n 1)\nf : α.Arrow β\nf' : α'.Arrow β'\n⊢ Eq (TypeVec.lastFun (TypeVec.prod.map f f')) (Prod.map (TypeVec.lastFun f) (TypeVec.lastFun f'))","decl":"@[simp]\ntheorem lastFun_prod {α α' β β' : TypeVec (n + 1)} (f : α ⟹ β) (f' : α' ⟹ β') :\n    lastFun (f ⊗' f') = Prod.map (lastFun f) (lastFun f') := by\n  ext i : 1\n  induction i; simp [lastFun, *]; rfl\n\n"}
{"name":"TypeVec.dropFun_from_append1_drop_last","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\n⊢ Eq (TypeVec.dropFun TypeVec.fromAppend1DropLast) TypeVec.id","decl":"@[simp]\ntheorem dropFun_from_append1_drop_last {α : TypeVec (n + 1)} :\n    dropFun (@fromAppend1DropLast _ α) = id :=\n  rfl\n\n"}
{"name":"TypeVec.lastFun_from_append1_drop_last","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\n⊢ Eq (TypeVec.lastFun TypeVec.fromAppend1DropLast) id","decl":"@[simp]\ntheorem lastFun_from_append1_drop_last {α : TypeVec (n + 1)} :\n    lastFun (@fromAppend1DropLast _ α) = _root_.id :=\n  rfl\n\n"}
{"name":"TypeVec.dropFun_id","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} (HAdd.hAdd n 1)\n⊢ Eq (TypeVec.dropFun TypeVec.id) TypeVec.id","decl":"@[simp]\ntheorem dropFun_id {α : TypeVec (n + 1)} : dropFun (@TypeVec.id _ α) = id :=\n  rfl\n\n"}
{"name":"TypeVec.prod_map_id","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα β : TypeVec.{u_1} n\n⊢ Eq (TypeVec.prod.map TypeVec.id TypeVec.id) TypeVec.id","decl":"@[simp]\ntheorem prod_map_id {α β : TypeVec n} : (@TypeVec.id _ α ⊗' @TypeVec.id _ β) = id := by\n  ext i x : 2\n  induction i <;> simp only [TypeVec.prod.map, *, dropFun_id]\n  cases x\n  · rfl\n  · rfl\n\n"}
{"name":"TypeVec.subtypeVal_diagSub","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\n⊢ Eq (TypeVec.comp (TypeVec.subtypeVal α.repeatEq) TypeVec.diagSub) TypeVec.prod.diag","decl":"@[simp]\ntheorem subtypeVal_diagSub {α : TypeVec n} : subtypeVal (repeatEq α) ⊚ diagSub = prod.diag := by\n  ext i x\n  induction i with\n  | fz => simp [comp, diagSub, subtypeVal, prod.diag]\n  | fs _ i_ih =>\n    simp only [comp, subtypeVal, diagSub, prod.diag] at *\n    apply i_ih\n\n"}
{"name":"TypeVec.toSubtype_of_subtype","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\np : α.Arrow (TypeVec.repeat n Prop)\n⊢ Eq (TypeVec.comp (TypeVec.toSubtype p) (TypeVec.ofSubtype p)) TypeVec.id","decl":"@[simp]\ntheorem toSubtype_of_subtype {α : TypeVec n} (p : α ⟹ «repeat» n Prop) :\n    toSubtype p ⊚ ofSubtype p = id := by\n  ext i x\n  induction i <;> simp only [id, toSubtype, comp, ofSubtype] at *\n  simp [*]\n\n"}
{"name":"TypeVec.subtypeVal_toSubtype","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\np : α.Arrow (TypeVec.repeat n Prop)\n⊢ Eq (TypeVec.comp (TypeVec.subtypeVal p) (TypeVec.toSubtype p)) fun x => Subtype.val","decl":"@[simp]\ntheorem subtypeVal_toSubtype {α : TypeVec n} (p : α ⟹ «repeat» n Prop) :\n    subtypeVal p ⊚ toSubtype p = fun _ => Subtype.val := by\n  ext i x\n  induction i <;> simp only [toSubtype, comp, subtypeVal] at *\n  simp [*]\n\n"}
{"name":"TypeVec.toSubtype_of_subtype_assoc","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nβ : TypeVec.{u_2} n\np : α.Arrow (TypeVec.repeat n Prop)\nf : β.Arrow (TypeVec.Subtype_ p)\n⊢ Eq (TypeVec.comp (TypeVec.toSubtype p) (TypeVec.comp (TypeVec.ofSubtype p) f)) f","decl":"@[simp]\ntheorem toSubtype_of_subtype_assoc\n    {α β : TypeVec n} (p : α ⟹ «repeat» n Prop) (f : β ⟹ Subtype_ p) :\n    @toSubtype n _ p ⊚ ofSubtype _ ⊚ f = f := by\n  rw [← comp_assoc, toSubtype_of_subtype]; simp\n\n"}
{"name":"TypeVec.toSubtype'_of_subtype'","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nr : (α.prod α).Arrow (TypeVec.repeat n Prop)\n⊢ Eq (TypeVec.comp (TypeVec.toSubtype' r) (TypeVec.ofSubtype' r)) TypeVec.id","decl":"@[simp]\ntheorem toSubtype'_of_subtype' {α : TypeVec n} (r : α ⊗ α ⟹ «repeat» n Prop) :\n    toSubtype' r ⊚ ofSubtype' r = id := by\n  ext i x\n  induction i\n  <;> dsimp only [id, toSubtype', comp, ofSubtype'] at *\n  <;> simp [Subtype.eta, *]\n\n"}
{"name":"TypeVec.subtypeVal_toSubtype'","module":"Mathlib.Data.TypeVec","initialProofState":"n : Nat\nα : TypeVec.{u_1} n\nr : (α.prod α).Arrow (TypeVec.repeat n Prop)\n⊢ Eq (TypeVec.comp (TypeVec.subtypeVal r) (TypeVec.toSubtype' r)) fun i x => TypeVec.prod.mk i (↑x).1 (↑x).2","decl":"theorem subtypeVal_toSubtype' {α : TypeVec n} (r : α ⊗ α ⟹ «repeat» n Prop) :\n    subtypeVal r ⊚ toSubtype' r = fun i x => prod.mk i x.1.fst x.1.snd := by\n  ext i x\n  induction i <;> simp only [id, toSubtype', comp, subtypeVal, prod.mk] at *\n  simp [*]\n\n"}
