{"name":"CategoryTheory.hom_inl_inr_false","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX : C\nY : D\nf : Quiver.Hom (Sum.inl X) (Sum.inr Y)\n⊢ False","decl":"@[aesop norm -10 destruct (rule_sets := [CategoryTheory])]\ntheorem hom_inl_inr_false {X : C} {Y : D} (f : Sum.inl X ⟶ Sum.inr Y) : False := by\n  cases f\n\n"}
{"name":"CategoryTheory.hom_inr_inl_false","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX : C\nY : D\nf : Quiver.Hom (Sum.inr X) (Sum.inl Y)\n⊢ False","decl":"@[aesop norm -10 destruct (rule_sets := [CategoryTheory])]\ntheorem hom_inr_inl_false {X : C} {Y : D} (f : Sum.inr X ⟶ Sum.inl Y) : False := by\n  cases f\n\n"}
{"name":"CategoryTheory.sum_comp_inl","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nP Q R : C\nf : Quiver.Hom (Sum.inl P) (Sum.inl Q)\ng : Quiver.Hom (Sum.inl Q) (Sum.inl R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"theorem sum_comp_inl {P Q R : C} (f : (inl P : C ⊕ D) ⟶ inl Q) (g : (inl Q : C ⊕ D) ⟶ inl R) :\n    @CategoryStruct.comp _ _ P Q R (f : P ⟶ Q) (g : Q ⟶ R) =\n      @CategoryStruct.comp _ _ (inl P) (inl Q) (inl R) (f : P ⟶ Q) (g : Q ⟶ R) :=\n  rfl\n\n"}
{"name":"CategoryTheory.sum_comp_inr","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nP Q R : D\nf : Quiver.Hom (Sum.inr P) (Sum.inr Q)\ng : Quiver.Hom (Sum.inr Q) (Sum.inr R)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"theorem sum_comp_inr {P Q R : D} (f : (inr P : C ⊕ D) ⟶ inr Q) (g : (inr Q : C ⊕ D) ⟶ inr R) :\n    @CategoryStruct.comp _ _ P Q R (f : P ⟶ Q) (g : Q ⟶ R) =\n      @CategoryStruct.comp _ _ (inr P) (inr Q) (inr R) (f : P ⟶ Q) (g : Q ⟶ R) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sum.inl__map","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nx✝¹ x✝ : C\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Sum.inl_ C D).map f) f","decl":"/-- `inl_` is the functor `X ↦ inl X`. -/\n@[simps]\ndef inl_ : C ⥤ C ⊕ D where\n  obj X := inl X\n  map {_ _} f := f\n\n"}
{"name":"CategoryTheory.Sum.inl__obj","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX : C\n⊢ Eq ((CategoryTheory.Sum.inl_ C D).obj X) (Sum.inl X)","decl":"/-- `inl_` is the functor `X ↦ inl X`. -/\n@[simps]\ndef inl_ : C ⥤ C ⊕ D where\n  obj X := inl X\n  map {_ _} f := f\n\n"}
{"name":"CategoryTheory.Sum.inr__obj","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX : D\n⊢ Eq ((CategoryTheory.Sum.inr_ C D).obj X) (Sum.inr X)","decl":"/-- `inr_` is the functor `X ↦ inr X`. -/\n@[simps]\ndef inr_ : D ⥤ C ⊕ D where\n  obj X := inr X\n  map {_ _} f := f\n\n/- Porting note: `aesop_cat` not firing on `map_comp` where autotac in Lean 3 did\nbut `map_id` was ok. -/\n\n"}
{"name":"CategoryTheory.Sum.inr__map","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nx✝¹ x✝ : D\nf : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.Sum.inr_ C D).map f) f","decl":"/-- `inr_` is the functor `X ↦ inr X`. -/\n@[simps]\ndef inr_ : D ⥤ C ⊕ D where\n  obj X := inr X\n  map {_ _} f := f\n\n/- Porting note: `aesop_cat` not firing on `map_comp` where autotac in Lean 3 did\nbut `map_id` was ok. -/\n\n"}
{"name":"CategoryTheory.Sum.swap_obj_inl","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX : C\n⊢ Eq ((CategoryTheory.Sum.swap C D).obj (Sum.inl X)) (Sum.inr X)","decl":"@[simp]\ntheorem swap_obj_inl (X : C) : (swap C D).obj (inl X) = inr X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sum.swap_obj_inr","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX : D\n⊢ Eq ((CategoryTheory.Sum.swap C D).obj (Sum.inr X)) (Sum.inl X)","decl":"@[simp]\ntheorem swap_obj_inr (X : D) : (swap C D).obj (inr X) = inl X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sum.swap_map_inl","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX Y : C\nf : Quiver.Hom (Sum.inl X) (Sum.inl Y)\n⊢ Eq ((CategoryTheory.Sum.swap C D).map f) f","decl":"@[simp]\ntheorem swap_map_inl {X Y : C} {f : inl X ⟶ inl Y} : (swap C D).map f = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sum.swap_map_inr","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nX Y : D\nf : Quiver.Hom (Sum.inr X) (Sum.inr Y)\n⊢ Eq ((CategoryTheory.Sum.swap C D).map f) f","decl":"@[simp]\ntheorem swap_map_inr {X Y : D} {f : inr X ⟶ inr Y} : (swap C D).map f = f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sum.Swap.equivalence_inverse","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\n⊢ Eq (CategoryTheory.Sum.Swap.equivalence C D).inverse (CategoryTheory.Sum.swap D C)","decl":"/-- `swap` gives an equivalence between `C ⊕ D` and `D ⊕ C`. -/\n@[simps functor inverse]\ndef equivalence : C ⊕ D ≌ D ⊕ C where\n  functor := swap C D\n  inverse := swap D C\n  unitIso := NatIso.ofComponents (by rintro (_|_) <;> exact Iso.refl _)\n  counitIso := NatIso.ofComponents (by rintro (_|_) <;> exact Iso.refl _)\n\n"}
{"name":"CategoryTheory.Sum.Swap.equivalence_functor","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\n⊢ Eq (CategoryTheory.Sum.Swap.equivalence C D).functor (CategoryTheory.Sum.swap C D)","decl":"/-- `swap` gives an equivalence between `C ⊕ D` and `D ⊕ C`. -/\n@[simps functor inverse]\ndef equivalence : C ⊕ D ≌ D ⊕ C where\n  functor := swap C D\n  inverse := swap D C\n  unitIso := NatIso.ofComponents (by rintro (_|_) <;> exact Iso.refl _)\n  counitIso := NatIso.ofComponents (by rintro (_|_) <;> exact Iso.refl _)\n\n"}
{"name":"CategoryTheory.Sum.Swap.isEquivalence","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\n⊢ (CategoryTheory.Sum.swap C D).IsEquivalence","decl":"instance isEquivalence : (swap C D).IsEquivalence :=\n  (by infer_instance : (equivalence C D).functor.IsEquivalence)\n\n"}
{"name":"CategoryTheory.Functor.inlCompSum'_inv_app","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor A C\nG : CategoryTheory.Functor B C\nX : A\n⊢ Eq ((F.inlCompSum' G).inv.app X) (CategoryTheory.CategoryStruct.id ((F.sum' G).obj (Sum.inl X)))","decl":"/-- The sum `F.sum' G` precomposed with the left inclusion functor is isomorphic to `F` -/\n@[simps!]\ndef inlCompSum' (F : A ⥤ C) (G : B ⥤ C) : Sum.inl_ A B ⋙ F.sum' G ≅ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.inlCompSum'_hom_app","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor A C\nG : CategoryTheory.Functor B C\nX : A\n⊢ Eq ((F.inlCompSum' G).hom.app X) (CategoryTheory.CategoryStruct.id ((F.sum' G).obj (Sum.inl X)))","decl":"/-- The sum `F.sum' G` precomposed with the left inclusion functor is isomorphic to `F` -/\n@[simps!]\ndef inlCompSum' (F : A ⥤ C) (G : B ⥤ C) : Sum.inl_ A B ⋙ F.sum' G ≅ F :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.inrCompSum'_inv_app","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor A C\nG : CategoryTheory.Functor B C\nX : B\n⊢ Eq ((F.inrCompSum' G).inv.app X) (CategoryTheory.CategoryStruct.id ((F.sum' G).obj (Sum.inr X)))","decl":"/-- The sum `F.sum' G` precomposed with the right inclusion functor is isomorphic to `G` -/\n@[simps!]\ndef inrCompSum' (F : A ⥤ C) (G : B ⥤ C) : Sum.inr_ A B ⋙ F.sum' G ≅ G :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.inrCompSum'_hom_app","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nF : CategoryTheory.Functor A C\nG : CategoryTheory.Functor B C\nX : B\n⊢ Eq ((F.inrCompSum' G).hom.app X) (CategoryTheory.CategoryStruct.id ((F.sum' G).obj (Sum.inr X)))","decl":"/-- The sum `F.sum' G` precomposed with the right inclusion functor is isomorphic to `G` -/\n@[simps!]\ndef inrCompSum' (F : A ⥤ C) (G : B ⥤ C) : Sum.inr_ A B ⋙ F.sum' G ≅ G :=\n  NatIso.ofComponents fun _ => Iso.refl _\n\n"}
{"name":"CategoryTheory.Functor.sum_obj_inl","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor C D\na : A\n⊢ Eq ((F.sum G).obj (Sum.inl a)) (Sum.inl (F.obj a))","decl":"@[simp]\ntheorem sum_obj_inl (F : A ⥤ B) (G : C ⥤ D) (a : A) : (F.sum G).obj (inl a) = inl (F.obj a) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.sum_obj_inr","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor C D\nc : C\n⊢ Eq ((F.sum G).obj (Sum.inr c)) (Sum.inr (G.obj c))","decl":"@[simp]\ntheorem sum_obj_inr (F : A ⥤ B) (G : C ⥤ D) (c : C) : (F.sum G).obj (inr c) = inr (G.obj c) :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.sum_map_inl","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor C D\na a' : A\nf : Quiver.Hom (Sum.inl a) (Sum.inl a')\n⊢ Eq ((F.sum G).map f) (F.map f)","decl":"@[simp]\ntheorem sum_map_inl (F : A ⥤ B) (G : C ⥤ D) {a a' : A} (f : inl a ⟶ inl a') :\n    (F.sum G).map f = F.map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.sum_map_inr","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF : CategoryTheory.Functor A B\nG : CategoryTheory.Functor C D\nc c' : C\nf : Quiver.Hom (Sum.inr c) (Sum.inr c')\n⊢ Eq ((F.sum G).map f) (G.map f)","decl":"@[simp]\ntheorem sum_map_inr (F : A ⥤ B) (G : C ⥤ D) {c c' : C} (f : inr c ⟶ inr c') :\n    (F.sum G).map f = G.map f :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.sum_app_inl","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF G : CategoryTheory.Functor A B\nH I : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom H I\na : A\n⊢ Eq ((CategoryTheory.NatTrans.sum α β).app (Sum.inl a)) (α.app a)","decl":"@[simp]\ntheorem sum_app_inl {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) (a : A) :\n    (sum α β).app (inl a) = α.app a :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.sum_app_inr","module":"Mathlib.CategoryTheory.Sums.Basic","initialProofState":"A : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} A\nB : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} B\nC : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} D\nF G : CategoryTheory.Functor A B\nH I : CategoryTheory.Functor C D\nα : Quiver.Hom F G\nβ : Quiver.Hom H I\nc : C\n⊢ Eq ((CategoryTheory.NatTrans.sum α β).app (Sum.inr c)) (β.app c)","decl":"@[simp]\ntheorem sum_app_inr {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) (c : C) :\n    (sum α β).app (inr c) = β.app c :=\n  rfl\n\n"}
