{"name":"unitary.spectrum_subset_circle","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : NormedField ùïú\nE : Type u_2\ninst‚úù‚Å¥ : NormedRing E\ninst‚úù¬≥ : StarRing E\ninst‚úù¬≤ : CStarRing E\ninst‚úù¬π : NormedAlgebra ùïú E\ninst‚úù : CompleteSpace E\nu : Subtype fun x => Membership.mem (unitary E) x\n‚ä¢ HasSubset.Subset (spectrum ùïú ‚Üëu) (Metric.sphere 0 1)","decl":"theorem unitary.spectrum_subset_circle (u : unitary E) :\n    spectrum ùïú (u : E) ‚äÜ Metric.sphere 0 1 := by\n  nontriviality E\n  refine fun k hk => mem_sphere_zero_iff_norm.mpr (le_antisymm ?_ ?_)\n  ¬∑ simpa only [CStarRing.norm_coe_unitary u] using norm_le_norm_of_mem hk\n  ¬∑ rw [‚Üê unitary.val_toUnits_apply u] at hk\n    have hnk := ne_zero_of_mem_of_unit hk\n    rw [‚Üê inv_inv (unitary.toUnits u), ‚Üê spectrum.map_inv, Set.mem_inv] at hk\n    have : ‚Äñk‚Äñ‚Åª¬π ‚â§ ‚Äñ(‚Üë(unitary.toUnits u)‚Åª¬π : E)‚Äñ := by\n      simpa only [norm_inv] using norm_le_norm_of_mem hk\n    simpa using inv_le_of_inv_le‚ÇÄ (norm_pos_iff.mpr hnk) this\n\n"}
{"name":"spectrum.subset_circle_of_unitary","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"ùïú : Type u_1\ninst‚úù‚Åµ : NormedField ùïú\nE : Type u_2\ninst‚úù‚Å¥ : NormedRing E\ninst‚úù¬≥ : StarRing E\ninst‚úù¬≤ : CStarRing E\ninst‚úù¬π : NormedAlgebra ùïú E\ninst‚úù : CompleteSpace E\nu : E\nh : Membership.mem (unitary E) u\n‚ä¢ HasSubset.Subset (spectrum ùïú u) (Metric.sphere 0 1)","decl":"theorem spectrum.subset_circle_of_unitary {u : E} (h : u ‚àà unitary E) :\n    spectrum ùïú u ‚äÜ Metric.sphere 0 1 :=\n  unitary.spectrum_subset_circle ‚ü®u, h‚ü©\n\n"}
{"name":"CStarAlgebra.le_nnnorm_of_mem_quasispectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù : NonUnitalCStarAlgebra A\na : A\nx : NNReal\nhx : Membership.mem (quasispectrum NNReal a) x\n‚ä¢ LE.le x (NNNorm.nnnorm a)","decl":"open scoped NNReal in\nlemma CStarAlgebra.le_nnnorm_of_mem_quasispectrum {A : Type*} [NonUnitalCStarAlgebra A]\n    {a : A} {x : ‚Ñù‚â•0} (hx : x ‚àà quasispectrum ‚Ñù‚â•0 a) : x ‚â§ ‚Äña‚Äñ‚Çä := by\n  rw [Unitization.quasispectrum_eq_spectrum_inr' ‚Ñù‚â•0 ‚ÑÇ] at hx\n  simpa [Unitization.nnnorm_inr] using spectrum.le_nnnorm_of_mem hx\n\n"}
{"name":"IsSelfAdjoint.spectralRadius_eq_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\n‚ä¢ Eq (spectralRadius Complex a) ‚Üë(NNNorm.nnnorm a)","decl":"theorem IsSelfAdjoint.spectralRadius_eq_nnnorm {a : A} (ha : IsSelfAdjoint a) :\n    spectralRadius ‚ÑÇ a = ‚Äña‚Äñ‚Çä := by\n  have hconst : Tendsto (fun _n : ‚Ñï => (‚Äña‚Äñ‚Çä : ‚Ñù‚â•0‚àû)) atTop _ := tendsto_const_nhds\n  refine tendsto_nhds_unique ?_ hconst\n  convert\n    (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a : A)).comp\n      (Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two) using 1\n  refine funext fun n => ?_\n  rw [Function.comp_apply, ha.nnnorm_pow_two_pow, ENNReal.coe_pow, ‚Üê rpow_natCast, ‚Üê rpow_mul]\n  simp\n\n"}
{"name":"IsSelfAdjoint.toReal_spectralRadius_complex_eq_norm","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\n‚ä¢ Eq (spectralRadius Complex a).toReal (Norm.norm a)","decl":"/-- In a C‚ãÜ-algebra, the spectral radius of a self-adjoint element is equal to its norm.\nSee `IsSelfAdjoint.toReal_spectralRadius_eq_norm` for a version involving\n`spectralRadius ‚Ñù a`. -/\nlemma IsSelfAdjoint.toReal_spectralRadius_complex_eq_norm {a : A} (ha : IsSelfAdjoint a) :\n    (spectralRadius ‚ÑÇ a).toReal = ‚Äña‚Äñ := by\n  simp [ha.spectralRadius_eq_nnnorm]\n\n"}
{"name":"IsStarNormal.spectralRadius_eq_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\na : A\ninst‚úù : IsStarNormal a\n‚ä¢ Eq (spectralRadius Complex a) ‚Üë(NNNorm.nnnorm a)","decl":"theorem IsStarNormal.spectralRadius_eq_nnnorm (a : A) [IsStarNormal a] :\n    spectralRadius ‚ÑÇ a = ‚Äña‚Äñ‚Çä := by\n  refine (ENNReal.pow_right_strictMono two_ne_zero).injective ?_\n  have heq :\n    (fun n : ‚Ñï => (‚Äñ(a‚ãÜ * a) ^ n‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ (1 / n : ‚Ñù)) =\n      (fun x => x ^ 2) ‚àò fun n : ‚Ñï => (‚Äña ^ n‚Äñ‚Çä : ‚Ñù‚â•0‚àû) ^ (1 / n : ‚Ñù) := by\n    funext n\n    rw [Function.comp_apply, ‚Üê rpow_natCast, ‚Üê rpow_mul, mul_comm, rpow_mul, rpow_natCast, ‚Üê\n      coe_pow, sq, ‚Üê nnnorm_star_mul_self, Commute.mul_pow (star_comm_self' a), star_pow]\n  have h‚ÇÇ :=\n    ((ENNReal.continuous_pow 2).tendsto (spectralRadius ‚ÑÇ a)).comp\n      (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius a)\n  rw [‚Üê heq] at h‚ÇÇ\n  convert tendsto_nhds_unique h‚ÇÇ (pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a‚ãÜ * a))\n  rw [(IsSelfAdjoint.star_mul_self a).spectralRadius_eq_nnnorm, sq, nnnorm_star_mul_self, coe_mul]\n\n"}
{"name":"IsSelfAdjoint.mem_spectrum_eq_re","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\na : A\nha : IsSelfAdjoint a\nz : Complex\nhz : Membership.mem (spectrum Complex a) z\n‚ä¢ Eq z ‚Üëz.re","decl":"/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem IsSelfAdjoint.mem_spectrum_eq_re {a : A} (ha : IsSelfAdjoint a) {z : ‚ÑÇ}\n    (hz : z ‚àà spectrum ‚ÑÇ a) : z = z.re := by\n  have hu := exp_mem_unitary_of_mem_skewAdjoint ‚ÑÇ (ha.smul_mem_skewAdjoint conj_I)\n  let Iu := Units.mk0 I I_ne_zero\n  have : NormedSpace.exp ‚ÑÇ (I ‚Ä¢ z) ‚àà spectrum ‚ÑÇ (NormedSpace.exp ‚ÑÇ (I ‚Ä¢ a)) := by\n    simpa only [Units.smul_def, Units.val_mk0] using\n      spectrum.exp_mem_exp (Iu ‚Ä¢ a) (smul_mem_smul_iff.mpr hz)\n  exact Complex.ext (ofReal_re _) <| by\n    simpa only [‚Üê Complex.exp_eq_exp_‚ÑÇ, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,\n      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using\n      spectrum.subset_circle_of_unitary hu this\n\n"}
{"name":"selfAdjoint.mem_spectrum_eq_re","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\na : Subtype fun x => Membership.mem (selfAdjoint A) x\nz : Complex\nhz : Membership.mem (spectrum Complex ‚Üëa) z\n‚ä¢ Eq z ‚Üëz.re","decl":"/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem selfAdjoint.mem_spectrum_eq_re (a : selfAdjoint A) {z : ‚ÑÇ}\n    (hz : z ‚àà spectrum ‚ÑÇ (a : A)) : z = z.re :=\n  a.prop.mem_spectrum_eq_re hz\n\n"}
{"name":"IsSelfAdjoint.im_eq_zero_of_mem_spectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\na : A\nha : IsSelfAdjoint a\nz : Complex\nhz : Membership.mem (spectrum Complex a) z\n‚ä¢ Eq z.im 0","decl":"/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem IsSelfAdjoint.im_eq_zero_of_mem_spectrum {a : A} (ha : IsSelfAdjoint a)\n    {z : ‚ÑÇ} (hz : z ‚àà spectrum ‚ÑÇ a) : z.im = 0 := by\n  rw [ha.mem_spectrum_eq_re hz, ofReal_im]\n\n"}
{"name":"IsSelfAdjoint.val_re_map_spectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\na : A\nha : IsSelfAdjoint a\n‚ä¢ Eq (spectrum Complex a) (Set.image (Function.comp Complex.ofReal Complex.re) (spectrum Complex a))","decl":"/-- The spectrum of a selfadjoint is real -/\ntheorem IsSelfAdjoint.val_re_map_spectrum {a : A} (ha : IsSelfAdjoint a) :\n    spectrum ‚ÑÇ a = ((‚Üë) ‚àò re '' spectrum ‚ÑÇ a : Set ‚ÑÇ) :=\n  le_antisymm (fun z hz => ‚ü®z, hz, (ha.mem_spectrum_eq_re hz).symm‚ü©) fun z => by\n    rintro ‚ü®z, hz, rfl‚ü©\n    simpa only [(ha.mem_spectrum_eq_re hz).symm, Function.comp_apply] using hz\n\n"}
{"name":"selfAdjoint.val_re_map_spectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\na : Subtype fun x => Membership.mem (selfAdjoint A) x\n‚ä¢ Eq (spectrum Complex ‚Üëa) (Set.image (Function.comp Complex.ofReal Complex.re) (spectrum Complex ‚Üëa))","decl":"/-- The spectrum of a selfadjoint is real -/\ntheorem selfAdjoint.val_re_map_spectrum (a : selfAdjoint A) :\n    spectrum ‚ÑÇ (a : A) = ((‚Üë) ‚àò re '' spectrum ‚ÑÇ (a : A) : Set ‚ÑÇ) :=\n  a.property.val_re_map_spectrum\n\n"}
{"name":"IsSelfAdjoint.isConnected_spectrum_compl","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\na : A\nha : IsSelfAdjoint a\n‚ä¢ IsConnected (HasCompl.compl (spectrum Complex a))","decl":"/-- The complement of the spectrum of a selfadjoint element in a C‚ãÜ-algebra is connected. -/\nlemma IsSelfAdjoint.isConnected_spectrum_compl {a : A} (ha : IsSelfAdjoint a) :\n    IsConnected (œÉ ‚ÑÇ a)·∂ú := by\n  suffices IsConnected (((œÉ ‚ÑÇ a)·∂ú ‚à© {z | 0 ‚â§ z.im}) ‚à™ (œÉ ‚ÑÇ a)·∂ú ‚à© {z | z.im ‚â§ 0}) by\n    rw [‚Üê Set.inter_union_distrib_left, ‚Üê Set.setOf_or] at this\n    rw [‚Üê Set.inter_univ (œÉ ‚ÑÇ a)·∂ú]\n    convert this using 2\n    exact Eq.symm <| Set.eq_univ_of_forall (fun z ‚Ü¶ le_total 0 z.im)\n  refine IsConnected.union ?nonempty ?upper ?lower\n  case nonempty =>\n    have := Filter.NeBot.nonempty_of_mem inferInstance <| Filter.mem_map.mp <|\n      Complex.isometry_ofReal.antilipschitz.tendsto_cobounded (spectrum.isBounded a |>.compl)\n    exact this.image Complex.ofReal |>.mono <| by simp\n  case' upper => apply Complex.isConnected_of_upperHalfPlane ?_ <| Set.inter_subset_right\n  case' lower => apply Complex.isConnected_of_lowerHalfPlane ?_ <| Set.inter_subset_right\n  all_goals\n    refine Set.subset_inter (fun z hz hz' ‚Ü¶ ?_) (fun _ ‚Ü¶ by simpa using le_of_lt)\n    rw [Set.mem_setOf_eq, ha.im_eq_zero_of_mem_spectrum hz'] at hz\n    simp_all\n\n"}
{"name":"StarSubalgebra.coe_isUnit","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\nS : StarSubalgebra Complex A\nhS : IsClosed ‚ÜëS\na : Subtype fun x => Membership.mem S x\n‚ä¢ Iff (IsUnit ‚Üëa) (IsUnit a)","decl":"/-- For a unital C‚ãÜ-subalgebra `S` of `A` and `x : S`, if `‚Üëx : A` is invertible in `A`, then\n`x` is invertible in `S`. -/\nlemma coe_isUnit {a : S} : IsUnit (a : A) ‚Üî IsUnit a := by\n  refine ‚ü®fun ha ‚Ü¶ ?_, IsUnit.map S.subtype‚ü©\n  have ha‚ÇÅ := ha.star.mul ha\n  have ha‚ÇÇ := ha.mul ha.star\n  have spec_eq {x : S} (hx : IsSelfAdjoint x) : spectrum ‚ÑÇ x = spectrum ‚ÑÇ (x : A) :=\n    Subalgebra.spectrum_eq_of_isPreconnected_compl S _ <|\n      (hx.map S.subtype).isConnected_spectrum_compl.isPreconnected\n  rw [‚Üê StarMemClass.coe_star, ‚Üê MulMemClass.coe_mul, ‚Üê spectrum.zero_not_mem_iff ‚ÑÇ, ‚Üê spec_eq,\n    spectrum.zero_not_mem_iff] at ha‚ÇÅ ha‚ÇÇ\n  ¬∑ have h‚ÇÅ : ha‚ÇÅ.unit‚Åª¬π * star a * a = 1 := mul_assoc _ _ a ‚ñ∏ ha‚ÇÅ.val_inv_mul\n    have h‚ÇÇ : a * (star a * ha‚ÇÇ.unit‚Åª¬π) = 1 := (mul_assoc a _ _).symm ‚ñ∏ ha‚ÇÇ.mul_val_inv\n    exact ‚ü®‚ü®a, ha‚ÇÅ.unit‚Åª¬π * star a, left_inv_eq_right_inv h‚ÇÅ h‚ÇÇ ‚ñ∏ h‚ÇÇ, h‚ÇÅ‚ü©, rfl‚ü©\n  ¬∑ exact IsSelfAdjoint.mul_star_self a\n  ¬∑ exact IsSelfAdjoint.star_mul_self a\n\n"}
{"name":"StarSubalgebra.mem_spectrum_iff","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\nS : StarSubalgebra Complex A\nhS : IsClosed ‚ÜëS\na : Subtype fun x => Membership.mem S x\nz : Complex\n‚ä¢ Iff (Membership.mem (spectrum Complex a) z) (Membership.mem (spectrum Complex ‚Üëa) z)","decl":"lemma mem_spectrum_iff {a : S} {z : ‚ÑÇ} : z ‚àà spectrum ‚ÑÇ a ‚Üî z ‚àà spectrum ‚ÑÇ (a : A) :=\n  not_iff_not.mpr S.coe_isUnit.symm\n\n"}
{"name":"StarSubalgebra.spectrum_eq","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : StarModule Complex A\nS : StarSubalgebra Complex A\nhS : IsClosed ‚ÜëS\na : Subtype fun x => Membership.mem S x\n‚ä¢ Eq (spectrum Complex a) (spectrum Complex ‚Üëa)","decl":"/-- **Spectral permanence.** The spectrum of an element is invariant of the (closed)\n`StarSubalgebra` in which it is contained. -/\nlemma spectrum_eq {a : S} : spectrum ‚ÑÇ a = spectrum ‚ÑÇ (a : A) :=\n  Set.ext fun _ ‚Ü¶ S.mem_spectrum_iff\n\n"}
{"name":"NonUnitalStarAlgHom.nnnorm_apply_le","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù‚Å¥ : NonUnitalCStarAlgebra A\ninst‚úù¬≥ : NonUnitalCStarAlgebra B\ninst‚úù¬≤ : FunLike F A B\ninst‚úù¬π : NonUnitalAlgHomClass F Complex A B\ninst‚úù : StarHomClass F A B\nœÜ : F\na : A\n‚ä¢ LE.le (NNNorm.nnnorm (œÜ a)) (NNNorm.nnnorm a)","decl":"/-- A non-unital star algebra homomorphism of complex C‚ãÜ-algebras is norm contractive. -/\nlemma nnnorm_apply_le (œÜ : F) (a : A) : ‚ÄñœÜ a‚Äñ‚Çä ‚â§ ‚Äña‚Äñ‚Çä := by\n  have h (œà : Unitization ‚ÑÇ A ‚Üí‚ãÜ‚Çê[‚ÑÇ] Unitization ‚ÑÇ B) (x : Unitization ‚ÑÇ A) :\n      ‚Äñœà x‚Äñ‚Çä ‚â§ ‚Äñx‚Äñ‚Çä := by\n    suffices ‚àÄ {s}, IsSelfAdjoint s ‚Üí ‚Äñœà s‚Äñ‚Çä ‚â§ ‚Äñs‚Äñ‚Çä by\n      refine nonneg_le_nonneg_of_sq_le_sq zero_le' ?_\n      simp_rw [‚Üê nnnorm_star_mul_self, ‚Üê map_star, ‚Üê map_mul]\n      exact this <| .star_mul_self x\n    intro s hs\n    suffices this : spectralRadius ‚ÑÇ (œà s) ‚â§ spectralRadius ‚ÑÇ s by\n      rwa [(hs.map œà).spectralRadius_eq_nnnorm, hs.spectralRadius_eq_nnnorm, coe_le_coe]\n        at this\n    exact iSup_le_iSup_of_subset (AlgHom.spectrum_apply_subset œà s)\n  simpa [nnnorm_inr] using h (starLift (inrNonUnitalStarAlgHom ‚ÑÇ B |>.comp (œÜ : A ‚Üí‚ãÜ‚Çô‚Çê[‚ÑÇ] B))) a\n\n"}
{"name":"NonUnitalStarAlgHom.norm_apply_le","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù‚Å¥ : NonUnitalCStarAlgebra A\ninst‚úù¬≥ : NonUnitalCStarAlgebra B\ninst‚úù¬≤ : FunLike F A B\ninst‚úù¬π : NonUnitalAlgHomClass F Complex A B\ninst‚úù : StarHomClass F A B\nœÜ : F\na : A\n‚ä¢ LE.le (Norm.norm (œÜ a)) (Norm.norm a)","decl":"/-- A non-unital star algebra homomorphism of complex C‚ãÜ-algebras is norm contractive. -/\nlemma norm_apply_le (œÜ : F) (a : A) : ‚ÄñœÜ a‚Äñ ‚â§ ‚Äña‚Äñ := by\n  exact_mod_cast nnnorm_apply_le œÜ a\n\n"}
{"name":"NonUnitalStarAlgHom.instContinuousLinearMapClassComplex","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù‚Å¥ : NonUnitalCStarAlgebra A\ninst‚úù¬≥ : NonUnitalCStarAlgebra B\ninst‚úù¬≤ : FunLike F A B\ninst‚úù¬π : NonUnitalAlgHomClass F Complex A B\ninst‚úù : StarHomClass F A B\n‚ä¢ ContinuousLinearMapClass F Complex A B","decl":"/-- Non-unital star algebra homomorphisms between C‚ãÜ-algebras are continuous linear maps.\nSee note [lower instance priority] -/\nlemma instContinuousLinearMapClassComplex : ContinuousLinearMapClass F ‚ÑÇ A B :=\n  { NonUnitalAlgHomClass.instLinearMapClass with\n    map_continuous := fun œÜ =>\n      AddMonoidHomClass.continuous_of_bound œÜ 1 (by simpa only [one_mul] using nnnorm_apply_le œÜ) }\n\n"}
{"name":"StarAlgEquiv.nnnorm_map","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù‚Å¥ : NonUnitalCStarAlgebra A\ninst‚úù¬≥ : NonUnitalCStarAlgebra B\ninst‚úù¬≤ : EquivLike F A B\ninst‚úù¬π : NonUnitalAlgEquivClass F Complex A B\ninst‚úù : StarHomClass F A B\nœÜ : F\na : A\n‚ä¢ Eq (NNNorm.nnnorm (œÜ a)) (NNNorm.nnnorm a)","decl":"lemma nnnorm_map (œÜ : F) (a : A) : ‚ÄñœÜ a‚Äñ‚Çä = ‚Äña‚Äñ‚Çä :=\n  le_antisymm (NonUnitalStarAlgHom.nnnorm_apply_le œÜ a) <| by\n    simpa using NonUnitalStarAlgHom.nnnorm_apply_le (symm (œÜ : A ‚âÉ‚ãÜ‚Çê[‚ÑÇ] B)) ((œÜ : A ‚âÉ‚ãÜ‚Çê[‚ÑÇ] B) a)\n\n"}
{"name":"StarAlgEquiv.norm_map","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù‚Å¥ : NonUnitalCStarAlgebra A\ninst‚úù¬≥ : NonUnitalCStarAlgebra B\ninst‚úù¬≤ : EquivLike F A B\ninst‚úù¬π : NonUnitalAlgEquivClass F Complex A B\ninst‚úù : StarHomClass F A B\nœÜ : F\na : A\n‚ä¢ Eq (Norm.norm (œÜ a)) (Norm.norm a)","decl":"lemma norm_map (œÜ : F) (a : A) : ‚ÄñœÜ a‚Äñ = ‚Äña‚Äñ :=\n  congr_arg NNReal.toReal (nnnorm_map œÜ a)\n\n"}
{"name":"StarAlgEquiv.isometry","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninst‚úù‚Å¥ : NonUnitalCStarAlgebra A\ninst‚úù¬≥ : NonUnitalCStarAlgebra B\ninst‚úù¬≤ : EquivLike F A B\ninst‚úù¬π : NonUnitalAlgEquivClass F Complex A B\ninst‚úù : StarHomClass F A B\nœÜ : F\n‚ä¢ Isometry ‚áëœÜ","decl":"lemma isometry (œÜ : F) : Isometry œÜ :=\n  AddMonoidHomClass.isometry_of_norm œÜ (norm_map œÜ)\n\n"}
{"name":"WeakDual.Complex.instStarHomClass","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : FunLike F A Complex\n‚ä¢ StarHomClass F A Complex","decl":"/-- This instance is provided instead of `StarHomClass` to avoid type class inference loops.\nSee note [lower instance priority] -/\nnoncomputable instance (priority := 100) Complex.instStarHomClass : StarHomClass F A ‚ÑÇ where\n  map_star œÜ a := by\n    suffices hsa : ‚àÄ s : selfAdjoint A, (œÜ s)‚ãÜ = œÜ s by\n      rw [‚Üê realPart_add_I_smul_imaginaryPart a]\n      simp only [map_add, map_smul, star_add, star_smul, hsa, selfAdjoint.star_val_eq]\n    intro s\n    have := AlgHom.apply_mem_spectrum œÜ (s : A)\n    rw [selfAdjoint.val_re_map_spectrum s] at this\n    rcases this with ‚ü®‚ü®_, _‚ü©, _, heq‚ü©\n    simp only [Function.comp_apply] at heq\n    rw [‚Üê heq, RCLike.star_def]\n    exact RCLike.conj_ofReal _\n\n"}
{"name":"AlgHomClass.instStarHomClass","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : FunLike F A Complex\nhF : AlgHomClass F Complex A Complex\n‚ä¢ StarHomClass F A Complex","decl":"/-- This is not an instance to avoid type class inference loops. See\n`WeakDual.Complex.instStarHomClass`. -/\nlemma _root_.AlgHomClass.instStarHomClass : StarHomClass F A ‚ÑÇ :=\n  { WeakDual.Complex.instStarHomClass, hF with }\n\n"}
{"name":"WeakDual.CharacterSpace.instStarHomClass","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_2\ninst‚úù : CStarAlgebra A\n‚ä¢ StarHomClass (‚Üë(WeakDual.characterSpace Complex A)) A Complex","decl":"noncomputable instance instStarHomClass : StarHomClass (characterSpace ‚ÑÇ A) A ‚ÑÇ :=\n  { AlgHomClass.instStarHomClass with }\n\n"}
