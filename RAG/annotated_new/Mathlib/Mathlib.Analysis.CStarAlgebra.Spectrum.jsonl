{"name":"unitary.spectrum_subset_circle","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedRing E\ninstâœÂ³ : StarRing E\ninstâœÂ² : CStarRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\ninstâœ : CompleteSpace E\nu : Subtype fun x => Membership.mem (unitary E) x\nâŠ¢ HasSubset.Subset (spectrum ğ•œ â†‘u) (Metric.sphere 0 1)","decl":"theorem unitary.spectrum_subset_circle (u : unitary E) :\n    spectrum ğ•œ (u : E) âŠ† Metric.sphere 0 1 := by\n  nontriviality E\n  refine fun k hk => mem_sphere_zero_iff_norm.mpr (le_antisymm ?_ ?_)\n  Â· simpa only [CStarRing.norm_coe_unitary u] using norm_le_norm_of_mem hk\n  Â· rw [â† unitary.val_toUnits_apply u] at hk\n    have hnk := ne_zero_of_mem_of_unit hk\n    rw [â† inv_inv (unitary.toUnits u), â† spectrum.map_inv, Set.mem_inv] at hk\n    have : â€–kâ€–â»Â¹ â‰¤ â€–(â†‘(unitary.toUnits u)â»Â¹ : E)â€– := by\n      simpa only [norm_inv] using norm_le_norm_of_mem hk\n    simpa using inv_le_of_inv_leâ‚€ (norm_pos_iff.mpr hnk) this\n\n"}
{"name":"spectrum.subset_circle_of_unitary","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedRing E\ninstâœÂ³ : StarRing E\ninstâœÂ² : CStarRing E\ninstâœÂ¹ : NormedAlgebra ğ•œ E\ninstâœ : CompleteSpace E\nu : E\nh : Membership.mem (unitary E) u\nâŠ¢ HasSubset.Subset (spectrum ğ•œ u) (Metric.sphere 0 1)","decl":"theorem spectrum.subset_circle_of_unitary {u : E} (h : u âˆˆ unitary E) :\n    spectrum ğ•œ u âŠ† Metric.sphere 0 1 :=\n  unitary.spectrum_subset_circle âŸ¨u, hâŸ©\n\n"}
{"name":"CStarAlgebra.le_nnnorm_of_mem_quasispectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœ : NonUnitalCStarAlgebra A\na : A\nx : NNReal\nhx : Membership.mem (quasispectrum NNReal a) x\nâŠ¢ LE.le x (NNNorm.nnnorm a)","decl":"open scoped NNReal in\nlemma CStarAlgebra.le_nnnorm_of_mem_quasispectrum {A : Type*} [NonUnitalCStarAlgebra A]\n    {a : A} {x : â„â‰¥0} (hx : x âˆˆ quasispectrum â„â‰¥0 a) : x â‰¤ â€–aâ€–â‚Š := by\n  rw [Unitization.quasispectrum_eq_spectrum_inr' â„â‰¥0 â„‚] at hx\n  simpa [Unitization.nnnorm_inr] using spectrum.le_nnnorm_of_mem hx\n\n"}
{"name":"IsSelfAdjoint.spectralRadius_eq_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœ : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\nâŠ¢ Eq (spectralRadius Complex a) â†‘(NNNorm.nnnorm a)","decl":"theorem IsSelfAdjoint.spectralRadius_eq_nnnorm {a : A} (ha : IsSelfAdjoint a) :\n    spectralRadius â„‚ a = â€–aâ€–â‚Š := by\n  have hconst : Tendsto (fun _n : â„• => (â€–aâ€–â‚Š : â„â‰¥0âˆ)) atTop _ := tendsto_const_nhds\n  refine tendsto_nhds_unique ?_ hconst\n  convert\n    (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a : A)).comp\n      (Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two) using 1\n  refine funext fun n => ?_\n  rw [Function.comp_apply, ha.nnnorm_pow_two_pow, ENNReal.coe_pow, â† rpow_natCast, â† rpow_mul]\n  simp\n\n"}
{"name":"IsSelfAdjoint.toReal_spectralRadius_complex_eq_norm","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœ : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\nâŠ¢ Eq (spectralRadius Complex a).toReal (Norm.norm a)","decl":"/-- In a Câ‹†-algebra, the spectral radius of a self-adjoint element is equal to its norm.\nSee `IsSelfAdjoint.toReal_spectralRadius_eq_norm` for a version involving\n`spectralRadius â„ a`. -/\nlemma IsSelfAdjoint.toReal_spectralRadius_complex_eq_norm {a : A} (ha : IsSelfAdjoint a) :\n    (spectralRadius â„‚ a).toReal = â€–aâ€– := by\n  simp [ha.spectralRadius_eq_nnnorm]\n\n"}
{"name":"IsStarNormal.spectralRadius_eq_nnnorm","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\na : A\ninstâœ : IsStarNormal a\nâŠ¢ Eq (spectralRadius Complex a) â†‘(NNNorm.nnnorm a)","decl":"theorem IsStarNormal.spectralRadius_eq_nnnorm (a : A) [IsStarNormal a] :\n    spectralRadius â„‚ a = â€–aâ€–â‚Š := by\n  refine (ENNReal.pow_right_strictMono two_ne_zero).injective ?_\n  have heq :\n    (fun n : â„• => (â€–(aâ‹† * a) ^ nâ€–â‚Š : â„â‰¥0âˆ) ^ (1 / n : â„)) =\n      (fun x => x ^ 2) âˆ˜ fun n : â„• => (â€–a ^ nâ€–â‚Š : â„â‰¥0âˆ) ^ (1 / n : â„) := by\n    funext n\n    rw [Function.comp_apply, â† rpow_natCast, â† rpow_mul, mul_comm, rpow_mul, rpow_natCast, â†\n      coe_pow, sq, â† nnnorm_star_mul_self, Commute.mul_pow (star_comm_self' a), star_pow]\n  have hâ‚‚ :=\n    ((ENNReal.continuous_pow 2).tendsto (spectralRadius â„‚ a)).comp\n      (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius a)\n  rw [â† heq] at hâ‚‚\n  convert tendsto_nhds_unique hâ‚‚ (pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (aâ‹† * a))\n  rw [(IsSelfAdjoint.star_mul_self a).spectralRadius_eq_nnnorm, sq, nnnorm_star_mul_self, coe_mul]\n\n"}
{"name":"IsSelfAdjoint.mem_spectrum_eq_re","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\na : A\nha : IsSelfAdjoint a\nz : Complex\nhz : Membership.mem (spectrum Complex a) z\nâŠ¢ Eq z â†‘z.re","decl":"/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem IsSelfAdjoint.mem_spectrum_eq_re {a : A} (ha : IsSelfAdjoint a) {z : â„‚}\n    (hz : z âˆˆ spectrum â„‚ a) : z = z.re := by\n  have hu := exp_mem_unitary_of_mem_skewAdjoint â„‚ (ha.smul_mem_skewAdjoint conj_I)\n  let Iu := Units.mk0 I I_ne_zero\n  have : NormedSpace.exp â„‚ (I â€¢ z) âˆˆ spectrum â„‚ (NormedSpace.exp â„‚ (I â€¢ a)) := by\n    simpa only [Units.smul_def, Units.val_mk0] using\n      spectrum.exp_mem_exp (Iu â€¢ a) (smul_mem_smul_iff.mpr hz)\n  exact Complex.ext (ofReal_re _) <| by\n    simpa only [â† Complex.exp_eq_exp_â„‚, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,\n      Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using\n      spectrum.subset_circle_of_unitary hu this\n\n"}
{"name":"selfAdjoint.mem_spectrum_eq_re","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\na : Subtype fun x => Membership.mem (selfAdjoint A) x\nz : Complex\nhz : Membership.mem (spectrum Complex â†‘a) z\nâŠ¢ Eq z â†‘z.re","decl":"/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem selfAdjoint.mem_spectrum_eq_re (a : selfAdjoint A) {z : â„‚}\n    (hz : z âˆˆ spectrum â„‚ (a : A)) : z = z.re :=\n  a.prop.mem_spectrum_eq_re hz\n\n"}
{"name":"IsSelfAdjoint.im_eq_zero_of_mem_spectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\na : A\nha : IsSelfAdjoint a\nz : Complex\nhz : Membership.mem (spectrum Complex a) z\nâŠ¢ Eq z.im 0","decl":"/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem IsSelfAdjoint.im_eq_zero_of_mem_spectrum {a : A} (ha : IsSelfAdjoint a)\n    {z : â„‚} (hz : z âˆˆ spectrum â„‚ a) : z.im = 0 := by\n  rw [ha.mem_spectrum_eq_re hz, ofReal_im]\n\n"}
{"name":"IsSelfAdjoint.val_re_map_spectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\na : A\nha : IsSelfAdjoint a\nâŠ¢ Eq (spectrum Complex a) (Set.image (Function.comp Complex.ofReal Complex.re) (spectrum Complex a))","decl":"/-- The spectrum of a selfadjoint is real -/\ntheorem IsSelfAdjoint.val_re_map_spectrum {a : A} (ha : IsSelfAdjoint a) :\n    spectrum â„‚ a = ((â†‘) âˆ˜ re '' spectrum â„‚ a : Set â„‚) :=\n  le_antisymm (fun z hz => âŸ¨z, hz, (ha.mem_spectrum_eq_re hz).symmâŸ©) fun z => by\n    rintro âŸ¨z, hz, rflâŸ©\n    simpa only [(ha.mem_spectrum_eq_re hz).symm, Function.comp_apply] using hz\n\n"}
{"name":"selfAdjoint.val_re_map_spectrum","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\na : Subtype fun x => Membership.mem (selfAdjoint A) x\nâŠ¢ Eq (spectrum Complex â†‘a) (Set.image (Function.comp Complex.ofReal Complex.re) (spectrum Complex â†‘a))","decl":"/-- The spectrum of a selfadjoint is real -/\ntheorem selfAdjoint.val_re_map_spectrum (a : selfAdjoint A) :\n    spectrum â„‚ (a : A) = ((â†‘) âˆ˜ re '' spectrum â„‚ (a : A) : Set â„‚) :=\n  a.property.val_re_map_spectrum\n\n"}
{"name":"IsSelfAdjoint.isConnected_spectrum_compl","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\na : A\nha : IsSelfAdjoint a\nâŠ¢ IsConnected (HasCompl.compl (spectrum Complex a))","decl":"/-- The complement of the spectrum of a selfadjoint element in a Câ‹†-algebra is connected. -/\nlemma IsSelfAdjoint.isConnected_spectrum_compl {a : A} (ha : IsSelfAdjoint a) :\n    IsConnected (Ïƒ â„‚ a)á¶œ := by\n  suffices IsConnected (((Ïƒ â„‚ a)á¶œ âˆ© {z | 0 â‰¤ z.im}) âˆª (Ïƒ â„‚ a)á¶œ âˆ© {z | z.im â‰¤ 0}) by\n    rw [â† Set.inter_union_distrib_left, â† Set.setOf_or] at this\n    rw [â† Set.inter_univ (Ïƒ â„‚ a)á¶œ]\n    convert this using 2\n    exact Eq.symm <| Set.eq_univ_of_forall (fun z â†¦ le_total 0 z.im)\n  refine IsConnected.union ?nonempty ?upper ?lower\n  case nonempty =>\n    have := Filter.NeBot.nonempty_of_mem inferInstance <| Filter.mem_map.mp <|\n      Complex.isometry_ofReal.antilipschitz.tendsto_cobounded (spectrum.isBounded a |>.compl)\n    exact this.image Complex.ofReal |>.mono <| by simp\n  case' upper => apply Complex.isConnected_of_upperHalfPlane ?_ <| Set.inter_subset_right\n  case' lower => apply Complex.isConnected_of_lowerHalfPlane ?_ <| Set.inter_subset_right\n  all_goals\n    refine Set.subset_inter (fun z hz hz' â†¦ ?_) (fun _ â†¦ by simpa using le_of_lt)\n    rw [Set.mem_setOf_eq, ha.im_eq_zero_of_mem_spectrum hz'] at hz\n    simp_all\n\n"}
{"name":"StarSubalgebra.coe_isUnit","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\nS : StarSubalgebra Complex A\nhS : IsClosed â†‘S\na : Subtype fun x => Membership.mem S x\nâŠ¢ Iff (IsUnit â†‘a) (IsUnit a)","decl":"/-- For a unital Câ‹†-subalgebra `S` of `A` and `x : S`, if `â†‘x : A` is invertible in `A`, then\n`x` is invertible in `S`. -/\nlemma coe_isUnit {a : S} : IsUnit (a : A) â†” IsUnit a := by\n  refine âŸ¨fun ha â†¦ ?_, IsUnit.map S.subtypeâŸ©\n  have haâ‚ := ha.star.mul ha\n  have haâ‚‚ := ha.mul ha.star\n  have spec_eq {x : S} (hx : IsSelfAdjoint x) : spectrum â„‚ x = spectrum â„‚ (x : A) :=\n    Subalgebra.spectrum_eq_of_isPreconnected_compl S _ <|\n      (hx.map S.subtype).isConnected_spectrum_compl.isPreconnected\n  rw [â† StarMemClass.coe_star, â† MulMemClass.coe_mul, â† spectrum.zero_not_mem_iff â„‚, â† spec_eq,\n    spectrum.zero_not_mem_iff] at haâ‚ haâ‚‚\n  Â· have hâ‚ : haâ‚.unitâ»Â¹ * star a * a = 1 := mul_assoc _ _ a â–¸ haâ‚.val_inv_mul\n    have hâ‚‚ : a * (star a * haâ‚‚.unitâ»Â¹) = 1 := (mul_assoc a _ _).symm â–¸ haâ‚‚.mul_val_inv\n    exact âŸ¨âŸ¨a, haâ‚.unitâ»Â¹ * star a, left_inv_eq_right_inv hâ‚ hâ‚‚ â–¸ hâ‚‚, hâ‚âŸ©, rflâŸ©\n  Â· exact IsSelfAdjoint.mul_star_self a\n  Â· exact IsSelfAdjoint.star_mul_self a\n\n"}
{"name":"StarSubalgebra.mem_spectrum_iff","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\nS : StarSubalgebra Complex A\nhS : IsClosed â†‘S\na : Subtype fun x => Membership.mem S x\nz : Complex\nâŠ¢ Iff (Membership.mem (spectrum Complex a) z) (Membership.mem (spectrum Complex â†‘a) z)","decl":"lemma mem_spectrum_iff {a : S} {z : â„‚} : z âˆˆ spectrum â„‚ a â†” z âˆˆ spectrum â„‚ (a : A) :=\n  not_iff_not.mpr S.coe_isUnit.symm\n\n"}
{"name":"StarSubalgebra.spectrum_eq","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_1\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : StarModule Complex A\nS : StarSubalgebra Complex A\nhS : IsClosed â†‘S\na : Subtype fun x => Membership.mem S x\nâŠ¢ Eq (spectrum Complex a) (spectrum Complex â†‘a)","decl":"/-- **Spectral permanence.** The spectrum of an element is invariant of the (closed)\n`StarSubalgebra` in which it is contained. -/\nlemma spectrum_eq {a : S} : spectrum â„‚ a = spectrum â„‚ (a : A) :=\n  Set.ext fun _ â†¦ S.mem_spectrum_iff\n\n"}
{"name":"NonUnitalStarAlgHom.nnnorm_apply_le","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\na : A\nâŠ¢ LE.le (NNNorm.nnnorm (Ï† a)) (NNNorm.nnnorm a)","decl":"/-- A non-unital star algebra homomorphism of complex Câ‹†-algebras is norm contractive. -/\nlemma nnnorm_apply_le (Ï† : F) (a : A) : â€–Ï† aâ€–â‚Š â‰¤ â€–aâ€–â‚Š := by\n  have h (Ïˆ : Unitization â„‚ A â†’â‹†â‚[â„‚] Unitization â„‚ B) (x : Unitization â„‚ A) :\n      â€–Ïˆ xâ€–â‚Š â‰¤ â€–xâ€–â‚Š := by\n    suffices âˆ€ {s}, IsSelfAdjoint s â†’ â€–Ïˆ sâ€–â‚Š â‰¤ â€–sâ€–â‚Š by\n      refine nonneg_le_nonneg_of_sq_le_sq zero_le' ?_\n      simp_rw [â† nnnorm_star_mul_self, â† map_star, â† map_mul]\n      exact this <| .star_mul_self x\n    intro s hs\n    suffices this : spectralRadius â„‚ (Ïˆ s) â‰¤ spectralRadius â„‚ s by\n      rwa [(hs.map Ïˆ).spectralRadius_eq_nnnorm, hs.spectralRadius_eq_nnnorm, coe_le_coe]\n        at this\n    exact iSup_le_iSup_of_subset (AlgHom.spectrum_apply_subset Ïˆ s)\n  simpa [nnnorm_inr] using h (starLift (inrNonUnitalStarAlgHom â„‚ B |>.comp (Ï† : A â†’â‹†â‚™â‚[â„‚] B))) a\n\n"}
{"name":"NonUnitalStarAlgHom.norm_apply_le","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\na : A\nâŠ¢ LE.le (Norm.norm (Ï† a)) (Norm.norm a)","decl":"/-- A non-unital star algebra homomorphism of complex Câ‹†-algebras is norm contractive. -/\nlemma norm_apply_le (Ï† : F) (a : A) : â€–Ï† aâ€– â‰¤ â€–aâ€– := by\n  exact_mod_cast nnnorm_apply_le Ï† a\n\n"}
{"name":"NonUnitalStarAlgHom.instContinuousLinearMapClassComplex","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F Complex A B\ninstâœ : StarHomClass F A B\nâŠ¢ ContinuousLinearMapClass F Complex A B","decl":"/-- Non-unital star algebra homomorphisms between Câ‹†-algebras are continuous linear maps.\nSee note [lower instance priority] -/\nlemma instContinuousLinearMapClassComplex : ContinuousLinearMapClass F â„‚ A B :=\n  { NonUnitalAlgHomClass.instLinearMapClass with\n    map_continuous := fun Ï† =>\n      AddMonoidHomClass.continuous_of_bound Ï† 1 (by simpa only [one_mul] using nnnorm_apply_le Ï†) }\n\n"}
{"name":"StarAlgEquiv.nnnorm_map","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : EquivLike F A B\ninstâœÂ¹ : NonUnitalAlgEquivClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\na : A\nâŠ¢ Eq (NNNorm.nnnorm (Ï† a)) (NNNorm.nnnorm a)","decl":"lemma nnnorm_map (Ï† : F) (a : A) : â€–Ï† aâ€–â‚Š = â€–aâ€–â‚Š :=\n  le_antisymm (NonUnitalStarAlgHom.nnnorm_apply_le Ï† a) <| by\n    simpa using NonUnitalStarAlgHom.nnnorm_apply_le (symm (Ï† : A â‰ƒâ‹†â‚[â„‚] B)) ((Ï† : A â‰ƒâ‹†â‚[â„‚] B) a)\n\n"}
{"name":"StarAlgEquiv.norm_map","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : EquivLike F A B\ninstâœÂ¹ : NonUnitalAlgEquivClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\na : A\nâŠ¢ Eq (Norm.norm (Ï† a)) (Norm.norm a)","decl":"lemma norm_map (Ï† : F) (a : A) : â€–Ï† aâ€– = â€–aâ€– :=\n  congr_arg NNReal.toReal (nnnorm_map Ï† a)\n\n"}
{"name":"StarAlgEquiv.isometry","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\nB : Type u_3\ninstâœâ´ : NonUnitalCStarAlgebra A\ninstâœÂ³ : NonUnitalCStarAlgebra B\ninstâœÂ² : EquivLike F A B\ninstâœÂ¹ : NonUnitalAlgEquivClass F Complex A B\ninstâœ : StarHomClass F A B\nÏ† : F\nâŠ¢ Isometry â‡‘Ï†","decl":"lemma isometry (Ï† : F) : Isometry Ï† :=\n  AddMonoidHomClass.isometry_of_norm Ï† (norm_map Ï†)\n\n"}
{"name":"WeakDual.Complex.instStarHomClass","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : FunLike F A Complex\nâŠ¢ StarHomClass F A Complex","decl":"/-- This instance is provided instead of `StarHomClass` to avoid type class inference loops.\nSee note [lower instance priority] -/\nnoncomputable instance (priority := 100) Complex.instStarHomClass : StarHomClass F A â„‚ where\n  map_star Ï† a := by\n    suffices hsa : âˆ€ s : selfAdjoint A, (Ï† s)â‹† = Ï† s by\n      rw [â† realPart_add_I_smul_imaginaryPart a]\n      simp only [map_add, map_smul, star_add, star_smul, hsa, selfAdjoint.star_val_eq]\n    intro s\n    have := AlgHom.apply_mem_spectrum Ï† (s : A)\n    rw [selfAdjoint.val_re_map_spectrum s] at this\n    rcases this with âŸ¨âŸ¨_, _âŸ©, _, heqâŸ©\n    simp only [Function.comp_apply] at heq\n    rw [â† heq, RCLike.star_def]\n    exact RCLike.conj_ofReal _\n\n"}
{"name":"AlgHomClass.instStarHomClass","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"F : Type u_1\nA : Type u_2\ninstâœÂ¹ : CStarAlgebra A\ninstâœ : FunLike F A Complex\nhF : AlgHomClass F Complex A Complex\nâŠ¢ StarHomClass F A Complex","decl":"/-- This is not an instance to avoid type class inference loops. See\n`WeakDual.Complex.instStarHomClass`. -/\nlemma _root_.AlgHomClass.instStarHomClass : StarHomClass F A â„‚ :=\n  { WeakDual.Complex.instStarHomClass, hF with }\n\n"}
{"name":"WeakDual.CharacterSpace.instStarHomClass","module":"Mathlib.Analysis.CStarAlgebra.Spectrum","initialProofState":"A : Type u_2\ninstâœ : CStarAlgebra A\nâŠ¢ StarHomClass (â†‘(WeakDual.characterSpace Complex A)) A Complex","decl":"noncomputable instance instStarHomClass : StarHomClass (characterSpace â„‚ A) A â„‚ :=\n  { AlgHomClass.instStarHomClass with }\n\n"}
