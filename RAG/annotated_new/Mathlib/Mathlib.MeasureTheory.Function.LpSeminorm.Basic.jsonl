{"name":"MeasureTheory.eLpNorm'_eq_lintegral_enorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nx✝ : MeasurableSpace α\nf : α → F\nq : Real\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) q) (HDiv.hDiv 1 q))","decl":"lemma eLpNorm'_eq_lintegral_enorm {_ : MeasurableSpace α} (f : α → F) (q : ℝ) (μ : Measure α) :\n    eLpNorm' f q μ = (∫⁻ a, ‖f a‖ₑ ^ q ∂μ) ^ (1 / q) :=\n  rfl\n\n"}
{"name":"MeasureTheory.eLpNorm'_eq_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nx✝ : MeasurableSpace α\nf : α → F\nq : Real\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) (HPow.hPow (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) q) (HDiv.hDiv 1 q))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias eLpNorm'_eq_lintegral_nnnorm := eLpNorm'_eq_lintegral_enorm\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_eq_essSup_enorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nx✝ : MeasurableSpace α\nf : α → F\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNormEssSup f μ) (essSup (fun x => ENorm.enorm (f x)) μ)","decl":"lemma eLpNormEssSup_eq_essSup_enorm {_ : MeasurableSpace α} (f : α → F) (μ : Measure α) :\n    eLpNormEssSup f μ = essSup (‖f ·‖ₑ) μ := rfl\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_eq_essSup_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nx✝ : MeasurableSpace α\nf : α → F\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNormEssSup f μ) (essSup (fun x => ENorm.enorm (f x)) μ)","decl":"@[deprecated (since := \"2025-01-17\")]\nalias eLpNormEssSup_eq_essSup_nnnorm := eLpNormEssSup_eq_essSup_enorm\n\n"}
{"name":"MeasureTheory.eLpNorm_eq_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm' f p.toReal μ)","decl":"theorem eLpNorm_eq_eLpNorm' (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) {f : α → F} :\n    eLpNorm f p μ = eLpNorm' f (ENNReal.toReal p) μ := by simp [eLpNorm, hp_ne_zero, hp_ne_top]\n\n"}
{"name":"MeasureTheory.eLpNorm_nnreal_eq_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\np : NNReal\nhp : Ne p 0\n⊢ Eq (MeasureTheory.eLpNorm f (↑p) μ) (MeasureTheory.eLpNorm' f (↑p) μ)","decl":"lemma eLpNorm_nnreal_eq_eLpNorm' {f : α → F} {p : ℝ≥0} (hp : p ≠ 0) :\n    eLpNorm f p μ = eLpNorm' f p μ :=\n  eLpNorm_eq_eLpNorm' (by exact_mod_cast hp) ENNReal.coe_ne_top\n\n"}
{"name":"MeasureTheory.eLpNorm_eq_lintegral_rpow_enorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f p μ) (HPow.hPow (MeasureTheory.lintegral μ fun x => HPow.hPow (ENorm.enorm (f x)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"theorem eLpNorm_eq_lintegral_rpow_enorm (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) {f : α → F} :\n    eLpNorm f p μ = (∫⁻ x, ‖f x‖ₑ ^ p.toReal ∂μ) ^ (1 / p.toReal) := by\n  rw [eLpNorm_eq_eLpNorm' hp_ne_zero hp_ne_top, eLpNorm'_eq_lintegral_enorm]\n\n"}
{"name":"MeasureTheory.eLpNorm_eq_lintegral_rpow_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f p μ) (HPow.hPow (MeasureTheory.lintegral μ fun x => HPow.hPow (ENorm.enorm (f x)) p.toReal) (HDiv.hDiv 1 p.toReal))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias eLpNorm_eq_lintegral_rpow_nnnorm := eLpNorm_eq_lintegral_rpow_enorm\n\n"}
{"name":"MeasureTheory.eLpNorm_nnreal_eq_lintegral","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\np : NNReal\nhp : Ne p 0\n⊢ Eq (MeasureTheory.eLpNorm f (↑p) μ) (HPow.hPow (MeasureTheory.lintegral μ fun x => HPow.hPow (ENorm.enorm (f x)) ↑p) (HDiv.hDiv 1 ↑p))","decl":"lemma eLpNorm_nnreal_eq_lintegral {f : α → F} {p : ℝ≥0} (hp : p ≠ 0) :\n    eLpNorm f p μ = (∫⁻ x, ‖f x‖ₑ ^ (p : ℝ) ∂μ) ^ (1 / (p : ℝ)) :=\n  eLpNorm_nnreal_eq_eLpNorm' hp\n\n"}
{"name":"MeasureTheory.eLpNorm_one_eq_lintegral_enorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f 1 μ) (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x))","decl":"theorem eLpNorm_one_eq_lintegral_enorm {f : α → F} : eLpNorm f 1 μ = ∫⁻ x, ‖f x‖ₑ ∂μ := by\n  simp_rw [eLpNorm_eq_lintegral_rpow_enorm one_ne_zero ENNReal.coe_ne_top, ENNReal.one_toReal,\n    one_div_one, ENNReal.rpow_one]\n\n"}
{"name":"MeasureTheory.eLpNorm_one_eq_lintegral_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f 1 μ) (MeasureTheory.lintegral μ fun x => ENorm.enorm (f x))","decl":"@[deprecated (since := \"2025-01-17\")]\nalias eLpNorm_one_eq_lintegral_nnnorm := eLpNorm_one_eq_lintegral_enorm\n\n"}
{"name":"MeasureTheory.eLpNorm_exponent_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f Top.top μ) (MeasureTheory.eLpNormEssSup f μ)","decl":"@[simp]\ntheorem eLpNorm_exponent_top {f : α → F} : eLpNorm f ∞ μ = eLpNormEssSup f μ := by simp [eLpNorm]\n\n"}
{"name":"MeasureTheory.Memℒp.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\np : ENNReal\nh : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.AEStronglyMeasurable f μ","decl":"theorem Memℒp.aestronglyMeasurable {f : α → E} {p : ℝ≥0∞} (h : Memℒp f p μ) :\n    AEStronglyMeasurable f μ :=\n  h.1\n\n"}
{"name":"MeasureTheory.lintegral_rpow_enorm_eq_rpow_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhq0_lt : LT.lt 0 q\n⊢ Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) q) (HPow.hPow (MeasureTheory.eLpNorm' f q μ) q)","decl":"theorem lintegral_rpow_enorm_eq_rpow_eLpNorm' {f : α → F} (hq0_lt : 0 < q) :\n    ∫⁻ a, ‖f a‖ₑ ^ q ∂μ = eLpNorm' f q μ ^ q := by\n  rw [eLpNorm'_eq_lintegral_enorm, ← ENNReal.rpow_mul, one_div, inv_mul_cancel₀, ENNReal.rpow_one]\n  exact hq0_lt.ne'\n\n"}
{"name":"MeasureTheory.lintegral_rpow_nnnorm_eq_rpow_eLpNorm'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhq0_lt : LT.lt 0 q\n⊢ Eq (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) q) (HPow.hPow (MeasureTheory.eLpNorm' f q μ) q)","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_rpow_nnnorm_eq_rpow_eLpNorm' := lintegral_rpow_enorm_eq_rpow_eLpNorm'\n\n"}
{"name":"MeasureTheory.eLpNorm_nnreal_pow_eq_lintegral","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\np : NNReal\nhp : Ne p 0\n⊢ Eq (HPow.hPow (MeasureTheory.eLpNorm f (↑p) μ) ↑p) (MeasureTheory.lintegral μ fun x => HPow.hPow (ENorm.enorm (f x)) ↑p)","decl":"lemma eLpNorm_nnreal_pow_eq_lintegral {f : α → F} {p : ℝ≥0} (hp : p ≠ 0) :\n    eLpNorm f p μ ^ (p : ℝ) = ∫⁻ x, ‖f x‖ₑ ^ (p : ℝ) ∂μ := by\n  simp [eLpNorm_eq_eLpNorm' (by exact_mod_cast hp) ENNReal.coe_ne_top,\n    lintegral_rpow_enorm_eq_rpow_eLpNorm' ((NNReal.coe_pos.trans pos_iff_ne_zero).mpr hp)]\n\n"}
{"name":"MeasureTheory.Memℒp.eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhfp : MeasureTheory.Memℒp f p μ\n⊢ LT.lt (MeasureTheory.eLpNorm f p μ) Top.top","decl":"theorem Memℒp.eLpNorm_lt_top {f : α → E} (hfp : Memℒp f p μ) : eLpNorm f p μ < ∞ :=\n  hfp.2\n\n"}
{"name":"MeasureTheory.Memℒp.eLpNorm_ne_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhfp : MeasureTheory.Memℒp f p μ\n⊢ Ne (MeasureTheory.eLpNorm f p μ) Top.top","decl":"theorem Memℒp.eLpNorm_ne_top {f : α → E} (hfp : Memℒp f p μ) : eLpNorm f p μ ≠ ∞ :=\n  ne_of_lt hfp.2\n\n"}
{"name":"MeasureTheory.lintegral_rpow_enorm_lt_top_of_eLpNorm'_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhq0_lt : LT.lt 0 q\nhfq : LT.lt (MeasureTheory.eLpNorm' f q μ) Top.top\n⊢ LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) q) Top.top","decl":"theorem lintegral_rpow_enorm_lt_top_of_eLpNorm'_lt_top {f : α → F} (hq0_lt : 0 < q)\n    (hfq : eLpNorm' f q μ < ∞) : ∫⁻ a, ‖f a‖ₑ ^ q ∂μ < ∞ := by\n  rw [lintegral_rpow_enorm_eq_rpow_eLpNorm' hq0_lt]\n  exact ENNReal.rpow_lt_top_of_nonneg (le_of_lt hq0_lt) (ne_of_lt hfq)\n\n"}
{"name":"MeasureTheory.lintegral_rpow_nnnorm_lt_top_of_eLpNorm'_lt_top'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhq0_lt : LT.lt 0 q\nhfq : LT.lt (MeasureTheory.eLpNorm' f q μ) Top.top\n⊢ LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) q) Top.top","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_rpow_nnnorm_lt_top_of_eLpNorm'_lt_top' :=\n  lintegral_rpow_enorm_lt_top_of_eLpNorm'_lt_top\n\n"}
{"name":"MeasureTheory.lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhfp : LT.lt (MeasureTheory.eLpNorm f p μ) Top.top\n⊢ LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) p.toReal) Top.top","decl":"theorem lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top {f : α → F} (hp_ne_zero : p ≠ 0)\n    (hp_ne_top : p ≠ ∞) (hfp : eLpNorm f p μ < ∞) : ∫⁻ a, ‖f a‖ₑ ^ p.toReal ∂μ < ∞ := by\n  apply lintegral_rpow_enorm_lt_top_of_eLpNorm'_lt_top\n  · exact ENNReal.toReal_pos hp_ne_zero hp_ne_top\n  · simpa [eLpNorm_eq_eLpNorm' hp_ne_zero hp_ne_top] using hfp\n\n"}
{"name":"MeasureTheory.lintegral_rpow_nnnorm_lt_top_of_eLpNorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nhfp : LT.lt (MeasureTheory.eLpNorm f p μ) Top.top\n⊢ LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) p.toReal) Top.top","decl":"@[deprecated (since := \"2025-01-17\")]\nalias lintegral_rpow_nnnorm_lt_top_of_eLpNorm_lt_top :=\n  lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top\n\n"}
{"name":"MeasureTheory.eLpNorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Iff (LT.lt (MeasureTheory.eLpNorm f p μ) Top.top) (LT.lt (MeasureTheory.lintegral μ fun a => HPow.hPow (ENorm.enorm (f a)) p.toReal) Top.top)","decl":"theorem eLpNorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top {f : α → F} (hp_ne_zero : p ≠ 0)\n    (hp_ne_top : p ≠ ∞) : eLpNorm f p μ < ∞ ↔ ∫⁻ a, (‖f a‖ₑ) ^ p.toReal ∂μ < ∞ :=\n  ⟨lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp_ne_zero hp_ne_top, by\n    intro h\n    have hp' := ENNReal.toReal_pos hp_ne_zero hp_ne_top\n    have : 0 < 1 / p.toReal := div_pos zero_lt_one hp'\n    simpa [eLpNorm_eq_lintegral_rpow_enorm hp_ne_zero hp_ne_top] using\n      ENNReal.rpow_lt_top_of_nonneg (le_of_lt this) (ne_of_lt h)⟩\n\n"}
{"name":"MeasureTheory.eLpNorm'_exponent_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm' f 0 μ) 1","decl":"@[simp]\ntheorem eLpNorm'_exponent_zero {f : α → F} : eLpNorm' f 0 μ = 1 := by\n  rw [eLpNorm', div_zero, ENNReal.rpow_zero]\n\n"}
{"name":"MeasureTheory.eLpNorm_exponent_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f 0 μ) 0","decl":"@[simp]\ntheorem eLpNorm_exponent_zero {f : α → F} : eLpNorm f 0 μ = 0 := by simp [eLpNorm]\n\n"}
{"name":"MeasureTheory.memℒp_zero_iff_aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\n⊢ Iff (MeasureTheory.Memℒp f 0 μ) (MeasureTheory.AEStronglyMeasurable f μ)","decl":"@[simp]\ntheorem memℒp_zero_iff_aestronglyMeasurable {f : α → E} :\n    Memℒp f 0 μ ↔ AEStronglyMeasurable f μ := by simp [Memℒp, eLpNorm_exponent_zero]\n\n"}
{"name":"MeasureTheory.eLpNorm'_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhp0_lt : LT.lt 0 q\n⊢ Eq (MeasureTheory.eLpNorm' 0 q μ) 0","decl":"@[simp]\ntheorem eLpNorm'_zero (hp0_lt : 0 < q) : eLpNorm' (0 : α → F) q μ = 0 := by\n  simp [eLpNorm'_eq_lintegral_enorm, hp0_lt]\n\n"}
{"name":"MeasureTheory.eLpNorm'_zero'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhq0_ne : Ne q 0\nhμ : Ne μ 0\n⊢ Eq (MeasureTheory.eLpNorm' 0 q μ) 0","decl":"@[simp]\ntheorem eLpNorm'_zero' (hq0_ne : q ≠ 0) (hμ : μ ≠ 0) : eLpNorm' (0 : α → F) q μ = 0 := by\n  rcases le_or_lt 0 q with hq0 | hq_neg\n  · exact eLpNorm'_zero (lt_of_le_of_ne hq0 hq0_ne.symm)\n  · simp [eLpNorm'_eq_lintegral_enorm, ENNReal.rpow_eq_zero_iff, hμ, hq_neg]\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\n⊢ Eq (MeasureTheory.eLpNormEssSup 0 μ) 0","decl":"@[simp]\ntheorem eLpNormEssSup_zero : eLpNormEssSup (0 : α → F) μ = 0 := by\n  simp [eLpNormEssSup, ← bot_eq_zero', essSup_const_bot]\n\n"}
{"name":"MeasureTheory.eLpNorm_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\n⊢ Eq (MeasureTheory.eLpNorm 0 p μ) 0","decl":"@[simp]\ntheorem eLpNorm_zero : eLpNorm (0 : α → F) p μ = 0 := by\n  by_cases h0 : p = 0\n  · simp [h0]\n  by_cases h_top : p = ∞\n  · simp only [h_top, eLpNorm_exponent_top, eLpNormEssSup_zero]\n  rw [← Ne] at h0\n  simp [eLpNorm_eq_eLpNorm' h0 h_top, ENNReal.toReal_pos h0 h_top]\n\n"}
{"name":"MeasureTheory.eLpNorm_zero'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\n⊢ Eq (MeasureTheory.eLpNorm (fun x => 0) p μ) 0","decl":"@[simp]\ntheorem eLpNorm_zero' : eLpNorm (fun _ : α => (0 : F)) p μ = 0 := by convert eLpNorm_zero (F := F)\n\n"}
{"name":"MeasureTheory.Memℒp.zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ MeasureTheory.Memℒp 0 p μ","decl":"@[simp] lemma Memℒp.zero : Memℒp (0 : α → E) p μ :=\n  ⟨aestronglyMeasurable_zero, by rw [eLpNorm_zero]; exact ENNReal.coe_lt_top⟩\n\n"}
{"name":"MeasureTheory.Memℒp.zero'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ MeasureTheory.Memℒp (fun x => 0) p μ","decl":"@[simp] lemma Memℒp.zero' : Memℒp (fun _ : α => (0 : E)) p μ := Memℒp.zero\n\n"}
{"name":"MeasureTheory.zero_memℒp","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ MeasureTheory.Memℒp 0 p μ","decl":"@[deprecated (since := \"2025-01-21\")] alias zero_memℒp := Memℒp.zero\n"}
{"name":"MeasureTheory.zero_mem_ℒp","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\n⊢ MeasureTheory.Memℒp (fun x => 0) p μ","decl":"@[deprecated (since := \"2025-01-21\")] alias zero_mem_ℒp := Memℒp.zero'\n\n"}
{"name":"MeasureTheory.eLpNorm'_measure_zero_of_pos","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nq : Real\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasurableSpace α\nf : α → F\nhq_pos : LT.lt 0 q\n⊢ Eq (MeasureTheory.eLpNorm' f q 0) 0","decl":"theorem eLpNorm'_measure_zero_of_pos {f : α → F} (hq_pos : 0 < q) :\n    eLpNorm' f q (0 : Measure α) = 0 := by simp [eLpNorm', hq_pos]\n\n"}
{"name":"MeasureTheory.eLpNorm'_measure_zero_of_exponent_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasurableSpace α\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm' f 0 0) 1","decl":"theorem eLpNorm'_measure_zero_of_exponent_zero {f : α → F} : eLpNorm' f 0 (0 : Measure α) = 1 := by\n  simp [eLpNorm']\n\n"}
{"name":"MeasureTheory.eLpNorm'_measure_zero_of_neg","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nq : Real\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasurableSpace α\nf : α → F\nhq_neg : LT.lt q 0\n⊢ Eq (MeasureTheory.eLpNorm' f q 0) Top.top","decl":"theorem eLpNorm'_measure_zero_of_neg {f : α → F} (hq_neg : q < 0) :\n    eLpNorm' f q (0 : Measure α) = ∞ := by simp [eLpNorm', hq_neg]\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_measure_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasurableSpace α\nf : α → F\n⊢ Eq (MeasureTheory.eLpNormEssSup f 0) 0","decl":"@[simp]\ntheorem eLpNormEssSup_measure_zero {f : α → F} : eLpNormEssSup f (0 : Measure α) = 0 := by\n  simp [eLpNormEssSup]\n\n"}
{"name":"MeasureTheory.eLpNorm_measure_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\np : ENNReal\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasurableSpace α\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f p 0) 0","decl":"@[simp]\ntheorem eLpNorm_measure_zero {f : α → F} : eLpNorm f p (0 : Measure α) = 0 := by\n  by_cases h0 : p = 0\n  · simp [h0]\n  by_cases h_top : p = ∞\n  · simp [h_top]\n  rw [← Ne] at h0\n  simp [eLpNorm_eq_eLpNorm' h0 h_top, eLpNorm', ENNReal.toReal_pos h0 h_top]\n\n"}
{"name":"MeasureTheory.memℒp_measure_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\np : ENNReal\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasurableSpace α\nf : α → F\n⊢ MeasureTheory.Memℒp f p 0","decl":"@[simp] lemma memℒp_measure_zero {f : α → F} : Memℒp f p (0 : Measure α) := by simp [Memℒp]\n\n"}
{"name":"MeasureTheory.eLpNorm'_neg","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : α → F\nq : Real\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm' (Neg.neg f) q μ) (MeasureTheory.eLpNorm' f q μ)","decl":"@[simp]\ntheorem eLpNorm'_neg (f : α → F) (q : ℝ) (μ : Measure α) : eLpNorm' (-f) q μ = eLpNorm' f q μ := by\n  simp [eLpNorm'_eq_lintegral_enorm]\n\n"}
{"name":"MeasureTheory.eLpNorm_neg","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : α → F\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm (Neg.neg f) p μ) (MeasureTheory.eLpNorm f p μ)","decl":"@[simp]\ntheorem eLpNorm_neg (f : α → F) (p : ℝ≥0∞) (μ : Measure α) : eLpNorm (-f) p μ = eLpNorm f p μ := by\n  by_cases h0 : p = 0\n  · simp [h0]\n  by_cases h_top : p = ∞\n  · simp [h_top, eLpNormEssSup_eq_essSup_enorm]\n  simp [eLpNorm_eq_eLpNorm' h0 h_top]\n\n"}
{"name":"MeasureTheory.eLpNorm_sub_comm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup E\nf g : α → E\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm (HSub.hSub f g) p μ) (MeasureTheory.eLpNorm (HSub.hSub g f) p μ)","decl":"lemma eLpNorm_sub_comm (f g : α → E) (p : ℝ≥0∞) (μ : Measure α) :\n    eLpNorm (f - g) p μ = eLpNorm (g - f) p μ := by simp [← eLpNorm_neg (f := f - g)]\n\n"}
{"name":"MeasureTheory.Memℒp.neg","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (Neg.neg f) p μ","decl":"theorem Memℒp.neg {f : α → E} (hf : Memℒp f p μ) : Memℒp (-f) p μ :=\n  ⟨AEStronglyMeasurable.neg hf.1, by simp [hf.right]⟩\n\n"}
{"name":"MeasureTheory.memℒp_neg_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\n⊢ Iff (MeasureTheory.Memℒp (Neg.neg f) p μ) (MeasureTheory.Memℒp f p μ)","decl":"theorem memℒp_neg_iff {f : α → E} : Memℒp (-f) p μ ↔ Memℒp f p μ :=\n  ⟨fun h => neg_neg f ▸ h.neg, Memℒp.neg⟩\n\n"}
{"name":"MeasureTheory.eLpNorm'_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\nhq_pos : LT.lt 0 q\n⊢ Eq (MeasureTheory.eLpNorm' (fun x => c) q μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ Set.univ) (HDiv.hDiv 1 q)))","decl":"theorem eLpNorm'_const (c : F) (hq_pos : 0 < q) :\n    eLpNorm' (fun _ : α => c) q μ = ‖c‖ₑ * μ Set.univ ^ (1 / q) := by\n  rw [eLpNorm'_eq_lintegral_enorm, lintegral_const,\n    ENNReal.mul_rpow_of_nonneg _ _ (by simp [hq_pos.le] : 0 ≤ 1 / q)]\n  congr\n  rw [← ENNReal.rpow_mul]\n  suffices hq_cancel : q * (1 / q) = 1 by rw [hq_cancel, ENNReal.rpow_one]\n  rw [one_div, mul_inv_cancel₀ (ne_of_lt hq_pos).symm]\n\n"}
{"name":"MeasureTheory.eLpNorm'_const'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : F\nhc_ne_zero : Ne c 0\nhq_ne_zero : Ne q 0\n⊢ Eq (MeasureTheory.eLpNorm' (fun x => c) q μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ Set.univ) (HDiv.hDiv 1 q)))","decl":"theorem eLpNorm'_const' [IsFiniteMeasure μ] (c : F) (hc_ne_zero : c ≠ 0) (hq_ne_zero : q ≠ 0) :\n    eLpNorm' (fun _ : α => c) q μ = ‖c‖ₑ * μ Set.univ ^ (1 / q) := by\n  rw [eLpNorm'_eq_lintegral_enorm, lintegral_const,\n    ENNReal.mul_rpow_of_ne_top _ (measure_ne_top μ Set.univ)]\n  · congr\n    rw [← ENNReal.rpow_mul]\n    suffices hp_cancel : q * (1 / q) = 1 by rw [hp_cancel, ENNReal.rpow_one]\n    rw [one_div, mul_inv_cancel₀ hq_ne_zero]\n  · rw [Ne, ENNReal.rpow_eq_top_iff, not_or, not_and_or, not_and_or]\n    simp [hc_ne_zero]\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\nhμ : Ne μ 0\n⊢ Eq (MeasureTheory.eLpNormEssSup (fun x => c) μ) (ENorm.enorm c)","decl":"theorem eLpNormEssSup_const (c : F) (hμ : μ ≠ 0) : eLpNormEssSup (fun _ : α => c) μ = ‖c‖ₑ := by\n  rw [eLpNormEssSup_eq_essSup_enorm, essSup_const _ hμ]\n\n"}
{"name":"MeasureTheory.eLpNorm'_const_of_isProbabilityMeasure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\nc : F\nhq_pos : LT.lt 0 q\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\n⊢ Eq (MeasureTheory.eLpNorm' (fun x => c) q μ) (ENorm.enorm c)","decl":"theorem eLpNorm'_const_of_isProbabilityMeasure (c : F) (hq_pos : 0 < q) [IsProbabilityMeasure μ] :\n    eLpNorm' (fun _ : α => c) q μ = ‖c‖ₑ := by simp [eLpNorm'_const c hq_pos, measure_univ]\n\n"}
{"name":"MeasureTheory.eLpNorm_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\nh0 : Ne p 0\nhμ : Ne μ 0\n⊢ Eq (MeasureTheory.eLpNorm (fun x => c) p μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ Set.univ) (HDiv.hDiv 1 p.toReal)))","decl":"theorem eLpNorm_const (c : F) (h0 : p ≠ 0) (hμ : μ ≠ 0) :\n    eLpNorm (fun _ : α => c) p μ = ‖c‖ₑ * μ Set.univ ^ (1 / ENNReal.toReal p) := by\n  by_cases h_top : p = ∞\n  · simp [h_top, eLpNormEssSup_const c hμ]\n  simp [eLpNorm_eq_eLpNorm' h0 h_top, eLpNorm'_const, ENNReal.toReal_pos h0 h_top]\n\n"}
{"name":"MeasureTheory.eLpNorm_const'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\nh0 : Ne p 0\nh_top : Ne p Top.top\n⊢ Eq (MeasureTheory.eLpNorm (fun x => c) p μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ Set.univ) (HDiv.hDiv 1 p.toReal)))","decl":"theorem eLpNorm_const' (c : F) (h0 : p ≠ 0) (h_top : p ≠ ∞) :\n    eLpNorm (fun _ : α => c) p μ = ‖c‖ₑ * μ Set.univ ^ (1 / ENNReal.toReal p) := by\n  simp [eLpNorm_eq_eLpNorm' h0 h_top, eLpNorm'_const, ENNReal.toReal_pos h0 h_top]\n\n"}
{"name":"MeasureTheory.eLpNorm_const_lt_top_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\np : ENNReal\nc : F\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Iff (LT.lt (MeasureTheory.eLpNorm (fun x => c) p μ) Top.top) (Or (Eq c 0) (LT.lt (μ Set.univ) Top.top))","decl":"theorem eLpNorm_const_lt_top_iff {p : ℝ≥0∞} {c : F} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    eLpNorm (fun _ : α => c) p μ < ∞ ↔ c = 0 ∨ μ Set.univ < ∞ := by\n  have hp : 0 < p.toReal := ENNReal.toReal_pos hp_ne_zero hp_ne_top\n  by_cases hμ : μ = 0\n  · simp only [hμ, Measure.coe_zero, Pi.zero_apply, or_true, ENNReal.zero_lt_top,\n      eLpNorm_measure_zero]\n  by_cases hc : c = 0\n  · simp only [hc, true_or, eq_self_iff_true, ENNReal.zero_lt_top, eLpNorm_zero']\n  rw [eLpNorm_const' c hp_ne_zero hp_ne_top]\n  obtain hμ_top | hμ_top := eq_or_ne (μ .univ) ∞\n  · simp [hc, hμ_top, hp]\n  rw [ENNReal.mul_lt_top_iff]\n  simpa [hμ, hc, hμ_top, hμ_top.lt_top] using\n    ENNReal.rpow_lt_top_of_nonneg (inv_nonneg.mpr hp.le) hμ_top\n\n"}
{"name":"MeasureTheory.memℒp_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\nc : E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.Memℒp (fun x => c) p μ","decl":"theorem memℒp_const (c : E) [IsFiniteMeasure μ] : Memℒp (fun _ : α => c) p μ := by\n  refine ⟨aestronglyMeasurable_const, ?_⟩\n  by_cases h0 : p = 0\n  · simp [h0]\n  by_cases hμ : μ = 0\n  · simp [hμ]\n  rw [eLpNorm_const c h0 hμ]\n  refine ENNReal.mul_lt_top ENNReal.coe_lt_top ?_\n  refine ENNReal.rpow_lt_top_of_nonneg ?_ (measure_ne_top μ Set.univ)\n  simp\n\n"}
{"name":"MeasureTheory.memℒp_top_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nc : E\n⊢ MeasureTheory.Memℒp (fun x => c) Top.top μ","decl":"theorem memℒp_top_const (c : E) : Memℒp (fun _ : α => c) ∞ μ :=\n  ⟨aestronglyMeasurable_const, by by_cases h : μ = 0 <;> simp [eLpNorm_const _, h]⟩\n\n"}
{"name":"MeasureTheory.memℒp_const_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\np : ENNReal\nc : E\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ Iff (MeasureTheory.Memℒp (fun x => c) p μ) (Or (Eq c 0) (LT.lt (μ Set.univ) Top.top))","decl":"theorem memℒp_const_iff {p : ℝ≥0∞} {c : E} (hp_ne_zero : p ≠ 0) (hp_ne_top : p ≠ ∞) :\n    Memℒp (fun _ : α => c) p μ ↔ c = 0 ∨ μ Set.univ < ∞ := by\n  rw [← eLpNorm_const_lt_top_iff hp_ne_zero hp_ne_top]\n  exact ⟨fun h => h.2, fun h => ⟨aestronglyMeasurable_const, h⟩⟩\n\n"}
{"name":"MeasureTheory.eLpNorm'_mono_nnnorm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nhq : LE.le 0 q\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNorm' g q μ)","decl":"lemma eLpNorm'_mono_nnnorm_ae {f : α → F} {g : α → G} (hq : 0 ≤ q) (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ ‖g x‖₊) :\n    eLpNorm' f q μ ≤ eLpNorm' g q μ := by\n  simp only [eLpNorm'_eq_lintegral_enorm]\n  gcongr ?_ ^ (1/q)\n  refine lintegral_mono_ae (h.mono fun x hx => ?_)\n  dsimp [enorm]\n  gcongr\n\n"}
{"name":"MeasureTheory.eLpNorm'_mono_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nhq : LE.le 0 q\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (Norm.norm (g x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNorm' g q μ)","decl":"theorem eLpNorm'_mono_ae {f : α → F} {g : α → G} (hq : 0 ≤ q) (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ ‖g x‖) :\n    eLpNorm' f q μ ≤ eLpNorm' g q μ :=\n  eLpNorm'_mono_nnnorm_ae hq h\n\n"}
{"name":"MeasureTheory.eLpNorm'_congr_nnnorm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf g : α → F\nhfg : Filter.Eventually (fun x => Eq (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x))) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNorm' g q μ)","decl":"theorem eLpNorm'_congr_nnnorm_ae {f g : α → F} (hfg : ∀ᵐ x ∂μ, ‖f x‖₊ = ‖g x‖₊) :\n    eLpNorm' f q μ = eLpNorm' g q μ := by\n  have : (‖f ·‖ₑ ^ q) =ᵐ[μ] (‖g ·‖ₑ ^ q) := hfg.mono fun x hx ↦ by simp [enorm, hx]\n  simp only [eLpNorm'_eq_lintegral_enorm, lintegral_congr_ae this]\n\n"}
{"name":"MeasureTheory.eLpNorm'_congr_norm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf g : α → F\nhfg : Filter.Eventually (fun x => Eq (Norm.norm (f x)) (Norm.norm (g x))) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNorm' g q μ)","decl":"theorem eLpNorm'_congr_norm_ae {f g : α → F} (hfg : ∀ᵐ x ∂μ, ‖f x‖ = ‖g x‖) :\n    eLpNorm' f q μ = eLpNorm' g q μ :=\n  eLpNorm'_congr_nnnorm_ae <| hfg.mono fun _x hx => NNReal.eq hx\n\n"}
{"name":"MeasureTheory.eLpNorm'_congr_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf g : α → F\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) (MeasureTheory.eLpNorm' g q μ)","decl":"theorem eLpNorm'_congr_ae {f g : α → F} (hfg : f =ᵐ[μ] g) : eLpNorm' f q μ = eLpNorm' g q μ :=\n  eLpNorm'_congr_nnnorm_ae (hfg.fun_comp _)\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_congr_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf g : α → F\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.eLpNormEssSup f μ) (MeasureTheory.eLpNormEssSup g μ)","decl":"theorem eLpNormEssSup_congr_ae {f g : α → F} (hfg : f =ᵐ[μ] g) :\n    eLpNormEssSup f μ = eLpNormEssSup g μ :=\n  essSup_congr_ae (hfg.fun_comp (((↑) : ℝ≥0 → ℝ≥0∞) ∘ nnnorm))\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_mono_nnnorm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf g : α → F\nhfg : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNormEssSup f μ) (MeasureTheory.eLpNormEssSup g μ)","decl":"theorem eLpNormEssSup_mono_nnnorm_ae {f g : α → F} (hfg : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ ‖g x‖₊) :\n    eLpNormEssSup f μ ≤ eLpNormEssSup g μ :=\n  essSup_mono_ae <| hfg.mono fun _x hx => ENNReal.coe_le_coe.mpr hx\n\n"}
{"name":"MeasureTheory.eLpNorm_mono_nnnorm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_mono_nnnorm_ae {f : α → F} {g : α → G} (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ ‖g x‖₊) :\n    eLpNorm f p μ ≤ eLpNorm g p μ := by\n  simp only [eLpNorm]\n  split_ifs\n  · exact le_rfl\n  · exact essSup_mono_ae (h.mono fun x hx => ENNReal.coe_le_coe.mpr hx)\n  · exact eLpNorm'_mono_nnnorm_ae ENNReal.toReal_nonneg h\n\n"}
{"name":"MeasureTheory.eLpNorm_mono_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (Norm.norm (g x))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_mono_ae {f : α → F} {g : α → G} (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ ‖g x‖) :\n    eLpNorm f p μ ≤ eLpNorm g p μ :=\n  eLpNorm_mono_nnnorm_ae h\n\n"}
{"name":"MeasureTheory.eLpNorm_mono_ae_real","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ng : α → Real\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (g x)) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_mono_ae_real {f : α → F} {g : α → ℝ} (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ g x) :\n    eLpNorm f p μ ≤ eLpNorm g p μ :=\n  eLpNorm_mono_ae <| h.mono fun _x hx =>\n    hx.trans ((le_abs_self _).trans (Real.norm_eq_abs _).symm.le)\n\n"}
{"name":"MeasureTheory.eLpNorm_mono_nnnorm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nh : ∀ (x : α), LE.le (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x))\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_mono_nnnorm {f : α → F} {g : α → G} (h : ∀ x, ‖f x‖₊ ≤ ‖g x‖₊) :\n    eLpNorm f p μ ≤ eLpNorm g p μ :=\n  eLpNorm_mono_nnnorm_ae (Eventually.of_forall fun x => h x)\n\n"}
{"name":"MeasureTheory.eLpNorm_mono","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nh : ∀ (x : α), LE.le (Norm.norm (f x)) (Norm.norm (g x))\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_mono {f : α → F} {g : α → G} (h : ∀ x, ‖f x‖ ≤ ‖g x‖) :\n    eLpNorm f p μ ≤ eLpNorm g p μ :=\n  eLpNorm_mono_ae (Eventually.of_forall fun x => h x)\n\n"}
{"name":"MeasureTheory.eLpNorm_mono_real","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ng : α → Real\nh : ∀ (x : α), LE.le (Norm.norm (f x)) (g x)\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_mono_real {f : α → F} {g : α → ℝ} (h : ∀ x, ‖f x‖ ≤ g x) :\n    eLpNorm f p μ ≤ eLpNorm g p μ :=\n  eLpNorm_mono_ae_real (Eventually.of_forall fun x => h x)\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_le_of_ae_nnnorm_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNormEssSup f μ) ↑C","decl":"theorem eLpNormEssSup_le_of_ae_nnnorm_bound {f : α → F} {C : ℝ≥0} (hfC : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ C) :\n    eLpNormEssSup f μ ≤ C :=\n  essSup_le_of_ae_le (C : ℝ≥0∞) <| hfC.mono fun _x hx => ENNReal.coe_le_coe.mpr hx\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_le_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNormEssSup f μ) (ENNReal.ofReal C)","decl":"theorem eLpNormEssSup_le_of_ae_bound {f : α → F} {C : ℝ} (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) :\n    eLpNormEssSup f μ ≤ ENNReal.ofReal C :=\n  eLpNormEssSup_le_of_ae_nnnorm_bound <| hfC.mono fun _x hx => hx.trans C.le_coe_toNNReal\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_lt_top_of_ae_nnnorm_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) C) (MeasureTheory.ae μ)\n⊢ LT.lt (MeasureTheory.eLpNormEssSup f μ) Top.top","decl":"theorem eLpNormEssSup_lt_top_of_ae_nnnorm_bound {f : α → F} {C : ℝ≥0} (hfC : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ C) :\n    eLpNormEssSup f μ < ∞ :=\n  (eLpNormEssSup_le_of_ae_nnnorm_bound hfC).trans_lt ENNReal.coe_lt_top\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_lt_top_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ LT.lt (MeasureTheory.eLpNormEssSup f μ) Top.top","decl":"theorem eLpNormEssSup_lt_top_of_ae_bound {f : α → F} {C : ℝ} (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) :\n    eLpNormEssSup f μ < ∞ :=\n  (eLpNormEssSup_le_of_ae_bound hfC).trans_lt ENNReal.ofReal_lt_top\n\n"}
{"name":"MeasureTheory.eLpNorm_le_of_ae_nnnorm_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nC : NNReal\nhfC : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (HSMul.hSMul C (HPow.hPow (μ Set.univ) (Inv.inv p.toReal)))","decl":"theorem eLpNorm_le_of_ae_nnnorm_bound {f : α → F} {C : ℝ≥0} (hfC : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ C) :\n    eLpNorm f p μ ≤ C • μ Set.univ ^ p.toReal⁻¹ := by\n  rcases eq_zero_or_neZero μ with rfl | hμ\n  · simp\n  by_cases hp : p = 0\n  · simp [hp]\n  have : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ ‖(C : ℝ)‖₊ := hfC.mono fun x hx => hx.trans_eq C.nnnorm_eq.symm\n  refine (eLpNorm_mono_ae this).trans_eq ?_\n  rw [eLpNorm_const _ hp (NeZero.ne μ), C.enorm_eq, one_div, ENNReal.smul_def, smul_eq_mul]\n\n"}
{"name":"MeasureTheory.eLpNorm_le_of_ae_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (HMul.hMul (HPow.hPow (μ Set.univ) (Inv.inv p.toReal)) (ENNReal.ofReal C))","decl":"theorem eLpNorm_le_of_ae_bound {f : α → F} {C : ℝ} (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) :\n    eLpNorm f p μ ≤ μ Set.univ ^ p.toReal⁻¹ * ENNReal.ofReal C := by\n  rw [← mul_comm]\n  exact eLpNorm_le_of_ae_nnnorm_bound (hfC.mono fun x hx => hx.trans C.le_coe_toNNReal)\n\n"}
{"name":"MeasureTheory.eLpNorm_congr_nnnorm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nhfg : Filter.Eventually (fun x => Eq (NNNorm.nnnorm (f x)) (NNNorm.nnnorm (g x))) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_congr_nnnorm_ae {f : α → F} {g : α → G} (hfg : ∀ᵐ x ∂μ, ‖f x‖₊ = ‖g x‖₊) :\n    eLpNorm f p μ = eLpNorm g p μ :=\n  le_antisymm (eLpNorm_mono_nnnorm_ae <| EventuallyEq.le hfg)\n    (eLpNorm_mono_nnnorm_ae <| (EventuallyEq.symm hfg).le)\n\n"}
{"name":"MeasureTheory.eLpNorm_congr_norm_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nhfg : Filter.Eventually (fun x => Eq (Norm.norm (f x)) (Norm.norm (g x))) (MeasureTheory.ae μ)\n⊢ Eq (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_congr_norm_ae {f : α → F} {g : α → G} (hfg : ∀ᵐ x ∂μ, ‖f x‖ = ‖g x‖) :\n    eLpNorm f p μ = eLpNorm g p μ :=\n  eLpNorm_congr_nnnorm_ae <| hfg.mono fun _x hx => NNReal.eq hx\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_sub_indicator","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns t : Set α\nf : α → E\n⊢ Eq (MeasureTheory.eLpNorm (HSub.hSub (s.indicator f) (t.indicator f)) p μ) (MeasureTheory.eLpNorm ((symmDiff s t).indicator f) p μ)","decl":"open scoped symmDiff in\ntheorem eLpNorm_indicator_sub_indicator (s t : Set α) (f : α → E) :\n    eLpNorm (s.indicator f - t.indicator f) p μ = eLpNorm ((s ∆ t).indicator f) p μ :=\n  eLpNorm_congr_norm_ae <| ae_of_all _ fun x ↦ by\n    simp only [Pi.sub_apply, Set.apply_indicator_symmDiff norm_neg]\n\n"}
{"name":"MeasureTheory.eLpNorm'_norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm' (fun a => Norm.norm (f a)) q μ) (MeasureTheory.eLpNorm' f q μ)","decl":"@[simp]\ntheorem eLpNorm'_norm {f : α → F} :\n    eLpNorm' (fun a => ‖f a‖) q μ = eLpNorm' f q μ := by simp [eLpNorm'_eq_lintegral_enorm]\n\n"}
{"name":"MeasureTheory.eLpNorm_norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm (fun x => Norm.norm (f x)) p μ) (MeasureTheory.eLpNorm f p μ)","decl":"@[simp]\ntheorem eLpNorm_norm (f : α → F) : eLpNorm (fun x => ‖f x‖) p μ = eLpNorm f p μ :=\n  eLpNorm_congr_norm_ae <| Eventually.of_forall fun _ => norm_norm _\n\n"}
{"name":"MeasureTheory.eLpNorm'_norm_rpow","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\np q : Real\nhq_pos : LT.lt 0 q\n⊢ Eq (MeasureTheory.eLpNorm' (fun x => HPow.hPow (Norm.norm (f x)) q) p μ) (HPow.hPow (MeasureTheory.eLpNorm' f (HMul.hMul p q) μ) q)","decl":"theorem eLpNorm'_norm_rpow (f : α → F) (p q : ℝ) (hq_pos : 0 < q) :\n    eLpNorm' (fun x => ‖f x‖ ^ q) p μ = eLpNorm' f (p * q) μ ^ q := by\n  simp_rw [eLpNorm', ← ENNReal.rpow_mul, ← one_div_mul_one_div, one_div,\n    mul_assoc, inv_mul_cancel₀ hq_pos.ne.symm, mul_one, ← ofReal_norm_eq_enorm,\n    Real.norm_eq_abs, abs_eq_self.mpr (Real.rpow_nonneg (norm_nonneg _) _), mul_comm p,\n    ← ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) hq_pos.le, ENNReal.rpow_mul]\n\n"}
{"name":"MeasureTheory.eLpNorm_norm_rpow","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhq_pos : LT.lt 0 q\n⊢ Eq (MeasureTheory.eLpNorm (fun x => HPow.hPow (Norm.norm (f x)) q) p μ) (HPow.hPow (MeasureTheory.eLpNorm f (HMul.hMul p (ENNReal.ofReal q)) μ) q)","decl":"theorem eLpNorm_norm_rpow (f : α → F) (hq_pos : 0 < q) :\n    eLpNorm (fun x => ‖f x‖ ^ q) p μ = eLpNorm f (p * ENNReal.ofReal q) μ ^ q := by\n  by_cases h0 : p = 0\n  · simp [h0, ENNReal.zero_rpow_of_pos hq_pos]\n  by_cases hp_top : p = ∞\n  · simp only [hp_top, eLpNorm_exponent_top, ENNReal.top_mul', hq_pos.not_le,\n      ENNReal.ofReal_eq_zero, if_false, eLpNorm_exponent_top, eLpNormEssSup_eq_essSup_enorm]\n    have h_rpow : essSup (‖‖f ·‖ ^ q‖ₑ) μ = essSup (‖f ·‖ₑ ^ q) μ := by\n      congr\n      ext1 x\n      conv_rhs => rw [← enorm_norm]\n      rw [← Real.enorm_rpow_of_nonneg (norm_nonneg _) hq_pos.le]\n    rw [h_rpow]\n    have h_rpow_mono := ENNReal.strictMono_rpow_of_pos hq_pos\n    have h_rpow_surj := (ENNReal.rpow_left_bijective hq_pos.ne.symm).2\n    let iso := h_rpow_mono.orderIsoOfSurjective _ h_rpow_surj\n    exact (iso.essSup_apply (fun x => ‖f x‖ₑ) μ).symm\n  rw [eLpNorm_eq_eLpNorm' h0 hp_top, eLpNorm_eq_eLpNorm' _ _]\n  swap\n  · refine mul_ne_zero h0 ?_\n    rwa [Ne, ENNReal.ofReal_eq_zero, not_le]\n  swap; · exact ENNReal.mul_ne_top hp_top ENNReal.ofReal_ne_top\n  rw [ENNReal.toReal_mul, ENNReal.toReal_ofReal hq_pos.le]\n  exact eLpNorm'_norm_rpow f p.toReal q hq_pos\n\n"}
{"name":"MeasureTheory.eLpNorm_congr_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf g : α → F\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Eq (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm g p μ)","decl":"theorem eLpNorm_congr_ae {f g : α → F} (hfg : f =ᵐ[μ] g) : eLpNorm f p μ = eLpNorm g p μ :=\n  eLpNorm_congr_norm_ae <| hfg.mono fun _x hx => hx ▸ rfl\n\n"}
{"name":"MeasureTheory.memℒp_congr_ae","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Iff (MeasureTheory.Memℒp f p μ) (MeasureTheory.Memℒp g p μ)","decl":"theorem memℒp_congr_ae {f g : α → E} (hfg : f =ᵐ[μ] g) : Memℒp f p μ ↔ Memℒp g p μ := by\n  simp only [Memℒp, eLpNorm_congr_ae hfg, aestronglyMeasurable_congr hfg]\n\n"}
{"name":"MeasureTheory.Memℒp.ae_eq","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf g : α → E\nhfg : (MeasureTheory.ae μ).EventuallyEq f g\nhf_Lp : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp g p μ","decl":"theorem Memℒp.ae_eq {f g : α → E} (hfg : f =ᵐ[μ] g) (hf_Lp : Memℒp f p μ) : Memℒp g p μ :=\n  (memℒp_congr_ae hfg).1 hf_Lp\n\n"}
{"name":"MeasureTheory.Memℒp.of_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : α → F\nhg : MeasureTheory.Memℒp g p μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfg : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (Norm.norm (g x))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.of_le {f : α → E} {g : α → F} (hg : Memℒp g p μ) (hf : AEStronglyMeasurable f μ)\n    (hfg : ∀ᵐ x ∂μ, ‖f x‖ ≤ ‖g x‖) : Memℒp f p μ :=\n  ⟨hf, (eLpNorm_mono_ae hfg).trans_lt hg.eLpNorm_lt_top⟩\n\n"}
{"name":"MeasureTheory.Memℒp.mono","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : α → F\nhg : MeasureTheory.Memℒp g p μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfg : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (Norm.norm (g x))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"alias Memℒp.mono := Memℒp.of_le\n\n"}
{"name":"MeasureTheory.Memℒp.mono'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\ng : α → Real\nhg : MeasureTheory.Memℒp g p μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (g a)) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.mono' {f : α → E} {g : α → ℝ} (hg : Memℒp g p μ) (hf : AEStronglyMeasurable f μ)\n    (h : ∀ᵐ a ∂μ, ‖f a‖ ≤ g a) : Memℒp f p μ :=\n  hg.mono hf <| h.mono fun _x hx => le_trans hx (le_abs_self _)\n\n"}
{"name":"MeasureTheory.Memℒp.congr_norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : α → F\nhf : MeasureTheory.Memℒp f p μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp g p μ","decl":"theorem Memℒp.congr_norm {f : α → E} {g : α → F} (hf : Memℒp f p μ) (hg : AEStronglyMeasurable g μ)\n    (h : ∀ᵐ a ∂μ, ‖f a‖ = ‖g a‖) : Memℒp g p μ :=\n  hf.mono hg <| EventuallyEq.le <| EventuallyEq.symm h\n\n"}
{"name":"MeasureTheory.memℒp_congr_norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : α → F\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae μ)\n⊢ Iff (MeasureTheory.Memℒp f p μ) (MeasureTheory.Memℒp g p μ)","decl":"theorem memℒp_congr_norm {f : α → E} {g : α → F} (hf : AEStronglyMeasurable f μ)\n    (hg : AEStronglyMeasurable g μ) (h : ∀ᵐ a ∂μ, ‖f a‖ = ‖g a‖) : Memℒp f p μ ↔ Memℒp g p μ :=\n  ⟨fun h2f => h2f.congr_norm hg h, fun h2g => h2g.congr_norm hf <| EventuallyEq.symm h⟩\n\n"}
{"name":"MeasureTheory.memℒp_top_of_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f Top.top μ","decl":"theorem memℒp_top_of_bound {f : α → E} (hf : AEStronglyMeasurable f μ) (C : ℝ)\n    (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) : Memℒp f ∞ μ :=\n  ⟨hf, by\n    rw [eLpNorm_exponent_top]\n    exact eLpNormEssSup_lt_top_of_ae_bound hfC⟩\n\n"}
{"name":"MeasureTheory.Memℒp.of_bound","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\nC : Real\nhfC : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) C) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.of_bound [IsFiniteMeasure μ] {f : α → E} (hf : AEStronglyMeasurable f μ) (C : ℝ)\n    (hfC : ∀ᵐ x ∂μ, ‖f x‖ ≤ C) : Memℒp f p μ :=\n  (memℒp_const C).of_le hf (hfC.mono fun _x hx => le_trans hx (le_abs_self _))\n\n"}
{"name":"MeasureTheory.memℒp_of_bounded","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\na b : Real\nf : α → Real\nh : Filter.Eventually (fun x => Membership.mem (Set.Icc a b) (f x)) (MeasureTheory.ae μ)\nhX : MeasureTheory.AEStronglyMeasurable f μ\np : ENNReal\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem memℒp_of_bounded [IsFiniteMeasure μ]\n    {a b : ℝ} {f : α → ℝ} (h : ∀ᵐ x ∂μ, f x ∈ Set.Icc a b)\n    (hX : AEStronglyMeasurable f μ) (p : ENNReal) : Memℒp f p μ :=\n  have ha : ∀ᵐ x ∂μ, a ≤ f x := h.mono fun ω h => h.1\n  have hb : ∀ᵐ x ∂μ, f x ≤ b := h.mono fun ω h => h.2\n  (memℒp_const (max |a| |b|)).mono' hX (by filter_upwards [ha, hb] with x using abs_le_max_abs_abs)\n\n"}
{"name":"MeasureTheory.eLpNorm'_mono_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhμν : LE.le ν μ\nhq : LE.le 0 q\n⊢ LE.le (MeasureTheory.eLpNorm' f q ν) (MeasureTheory.eLpNorm' f q μ)","decl":"@[gcongr, mono]\ntheorem eLpNorm'_mono_measure (f : α → F) (hμν : ν ≤ μ) (hq : 0 ≤ q) :\n    eLpNorm' f q ν ≤ eLpNorm' f q μ := by\n  simp_rw [eLpNorm']\n  gcongr\n  exact lintegral_mono' hμν le_rfl\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_mono_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhμν : ν.AbsolutelyContinuous μ\n⊢ LE.le (MeasureTheory.eLpNormEssSup f ν) (MeasureTheory.eLpNormEssSup f μ)","decl":"@[gcongr, mono]\ntheorem eLpNormEssSup_mono_measure (f : α → F) (hμν : ν ≪ μ) :\n    eLpNormEssSup f ν ≤ eLpNormEssSup f μ := by\n  simp_rw [eLpNormEssSup]\n  exact essSup_mono_measure hμν\n\n"}
{"name":"MeasureTheory.eLpNorm_mono_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhμν : LE.le ν μ\n⊢ LE.le (MeasureTheory.eLpNorm f p ν) (MeasureTheory.eLpNorm f p μ)","decl":"@[gcongr, mono]\ntheorem eLpNorm_mono_measure (f : α → F) (hμν : ν ≤ μ) : eLpNorm f p ν ≤ eLpNorm f p μ := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  by_cases hp_top : p = ∞\n  · simp [hp_top, eLpNormEssSup_mono_measure f (Measure.absolutelyContinuous_of_le hμν)]\n  simp_rw [eLpNorm_eq_eLpNorm' hp0 hp_top]\n  exact eLpNorm'_mono_measure f hμν ENNReal.toReal_nonneg\n\n"}
{"name":"MeasureTheory.Memℒp.mono_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhμν : LE.le ν μ\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp f p ν","decl":"theorem Memℒp.mono_measure {f : α → E} (hμν : ν ≤ μ) (hf : Memℒp f p μ) : Memℒp f p ν :=\n  ⟨hf.1.mono_measure hμν, (eLpNorm_mono_measure f hμν).trans_lt hf.2⟩\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_eq_eLpNorm_restrict","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.eLpNorm (s.indicator f) p μ) (MeasureTheory.eLpNorm f p (μ.restrict s))","decl":"lemma eLpNorm_indicator_eq_eLpNorm_restrict (hs : MeasurableSet s) :\n    eLpNorm (s.indicator f) p μ = eLpNorm f p (μ.restrict s) := by\n  by_cases hp_zero : p = 0\n  · simp only [hp_zero, eLpNorm_exponent_zero]\n  by_cases hp_top : p = ∞\n  · simp_rw [hp_top, eLpNorm_exponent_top, eLpNormEssSup_eq_essSup_enorm,\n       enorm_indicator_eq_indicator_enorm, ENNReal.essSup_indicator_eq_essSup_restrict hs]\n  simp_rw [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp_top]\n  suffices (∫⁻ x, (‖s.indicator f x‖ₑ) ^ p.toReal ∂μ) =\n      ∫⁻ x in s, ‖f x‖ₑ ^ p.toReal ∂μ by rw [this]\n  rw [← lintegral_indicator hs]\n  congr\n  simp_rw [enorm_indicator_eq_indicator_enorm]\n  have h_zero : (fun x => x ^ p.toReal) (0 : ℝ≥0∞) = 0 := by\n    simp [ENNReal.toReal_pos hp_zero hp_top]\n  -- Porting note: The implicit argument should be specified because the elaborator can't deal with\n  --               `∘` well.\n  exact (Set.indicator_comp_of_zero (g := fun x : ℝ≥0∞ => x ^ p.toReal) h_zero).symm\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_eq_restrict","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.eLpNorm (s.indicator f) p μ) (MeasureTheory.eLpNorm f p (μ.restrict s))","decl":"@[deprecated (since := \"2025-01-07\")]\nalias eLpNorm_indicator_eq_restrict := eLpNorm_indicator_eq_eLpNorm_restrict\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_indicator_eq_eLpNormEssSup_restrict","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ns : Set α\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.eLpNormEssSup (s.indicator f) μ) (MeasureTheory.eLpNormEssSup f (μ.restrict s))","decl":"lemma eLpNormEssSup_indicator_eq_eLpNormEssSup_restrict (hs : MeasurableSet s) :\n    eLpNormEssSup (s.indicator f) μ = eLpNormEssSup f (μ.restrict s) := by\n  simp_rw [← eLpNorm_exponent_top, eLpNorm_indicator_eq_eLpNorm_restrict hs]\n\n"}
{"name":"MeasureTheory.eLpNorm_restrict_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : α → F\np : ENNReal\nμ : MeasureTheory.Measure α\ns : Set α\n⊢ LE.le (MeasureTheory.eLpNorm f p (μ.restrict s)) (MeasureTheory.eLpNorm f p μ)","decl":"lemma eLpNorm_restrict_le (f : α → F) (p : ℝ≥0∞) (μ : Measure α) (s : Set α) :\n    eLpNorm f p (μ.restrict s) ≤ eLpNorm f p μ :=\n  eLpNorm_mono_measure f Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nf : α → E\n⊢ LE.le (MeasureTheory.eLpNorm (s.indicator f) p μ) (MeasureTheory.eLpNorm f p μ)","decl":"lemma eLpNorm_indicator_le (f : α → E) : eLpNorm (s.indicator f) p μ ≤ eLpNorm f p μ := by\n  refine eLpNorm_mono_ae <| .of_forall fun x ↦ ?_\n  suffices ‖s.indicator f x‖₊ ≤ ‖f x‖₊ by exact NNReal.coe_mono this\n  rw [nnnorm_indicator_eq_indicator_nnnorm]\n  exact s.indicator_le_self _ x\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_indicator_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup G\ns : Set α\nf : α → G\n⊢ LE.le (MeasureTheory.eLpNormEssSup (s.indicator f) μ) (MeasureTheory.eLpNormEssSup f μ)","decl":"lemma eLpNormEssSup_indicator_le (s : Set α) (f : α → G) :\n    eLpNormEssSup (s.indicator f) μ ≤ eLpNormEssSup f μ := by\n  refine essSup_mono_ae (Eventually.of_forall fun x => ?_)\n  simp_rw [enorm_eq_nnnorm, ENNReal.coe_le_coe, nnnorm_indicator_eq_indicator_nnnorm]\n  exact Set.indicator_le_self s _ x\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_indicator_const_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup G\ns : Set α\nc : G\n⊢ LE.le (MeasureTheory.eLpNormEssSup (s.indicator fun x => c) μ) (ENorm.enorm c)","decl":"lemma eLpNormEssSup_indicator_const_le (s : Set α) (c : G) :\n    eLpNormEssSup (s.indicator fun _ : α => c) μ ≤ ‖c‖ₑ := by\n  by_cases hμ0 : μ = 0\n  · rw [hμ0, eLpNormEssSup_measure_zero]\n    exact zero_le _\n  · exact (eLpNormEssSup_indicator_le s fun _ => c).trans (eLpNormEssSup_const c hμ0).le\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_indicator_const_eq","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup G\ns : Set α\nc : G\nhμs : Ne (μ s) 0\n⊢ Eq (MeasureTheory.eLpNormEssSup (s.indicator fun x => c) μ) (ENorm.enorm c)","decl":"lemma eLpNormEssSup_indicator_const_eq (s : Set α) (c : G) (hμs : μ s ≠ 0) :\n    eLpNormEssSup (s.indicator fun _ : α => c) μ = ‖c‖ₑ := by\n  refine le_antisymm (eLpNormEssSup_indicator_const_le s c) ?_\n  by_contra! h\n  have h' := ae_iff.mp (ae_lt_of_essSup_lt h)\n  push_neg at h'\n  refine hμs (measure_mono_null (fun x hx_mem => ?_) h')\n  rw [Set.mem_setOf_eq, Set.indicator_of_mem hx_mem, enorm_eq_nnnorm]\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_const₀","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nhp : Ne p 0\nhp_top : Ne p Top.top\n⊢ Eq (MeasureTheory.eLpNorm (s.indicator fun x => c) p μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal)))","decl":"lemma eLpNorm_indicator_const₀ (hs : NullMeasurableSet s μ) (hp : p ≠ 0) (hp_top : p ≠ ∞) :\n    eLpNorm (s.indicator fun _ => c) p μ = ‖c‖ₑ * μ s ^ (1 / p.toReal) :=\n  have hp_pos : 0 < p.toReal := ENNReal.toReal_pos hp hp_top\n  calc\n    eLpNorm (s.indicator fun _ => c) p μ\n      = (∫⁻ x, (‖(s.indicator fun _ ↦ c) x‖ₑ ^ p.toReal) ∂μ) ^ (1 / p.toReal) :=\n          eLpNorm_eq_lintegral_rpow_enorm hp hp_top\n    _ = (∫⁻ x, (s.indicator fun _ ↦ ‖c‖ₑ ^ p.toReal) x ∂μ) ^ (1 / p.toReal) := by\n      congr 2\n      refine (Set.comp_indicator_const c (fun x ↦ (‖x‖ₑ) ^ p.toReal) ?_)\n      simp [hp_pos]\n    _ = ‖c‖ₑ * μ s ^ (1 / p.toReal) := by\n      rw [lintegral_indicator_const₀ hs, ENNReal.mul_rpow_of_nonneg, ← ENNReal.rpow_mul,\n        mul_one_div_cancel hp_pos.ne', ENNReal.rpow_one]\n      positivity\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\ns : Set α\nhs : MeasurableSet s\nhp : Ne p 0\nhp_top : Ne p Top.top\n⊢ Eq (MeasureTheory.eLpNorm (s.indicator fun x => c) p μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal)))","decl":"lemma eLpNorm_indicator_const (hs : MeasurableSet s) (hp : p ≠ 0) (hp_top : p ≠ ∞) :\n    eLpNorm (s.indicator fun _ => c) p μ = ‖c‖ₑ * μ s ^ (1 / p.toReal) :=\n  eLpNorm_indicator_const₀ hs.nullMeasurableSet hp hp_top\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_const'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nc : F\ns : Set α\nhs : MeasurableSet s\nhμs : Ne (μ s) 0\nhp : Ne p 0\n⊢ Eq (MeasureTheory.eLpNorm (s.indicator fun x => c) p μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal)))","decl":"lemma eLpNorm_indicator_const' (hs : MeasurableSet s) (hμs : μ s ≠ 0) (hp : p ≠ 0) :\n    eLpNorm (s.indicator fun _ => c) p μ = ‖c‖ₑ * μ s ^ (1 / p.toReal) := by\n  by_cases hp_top : p = ∞\n  · simp [hp_top, eLpNormEssSup_indicator_const_eq s c hμs]\n  · exact eLpNorm_indicator_const hs hp hp_top\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_const_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup G\ns : Set α\nc : G\np : ENNReal\n⊢ LE.le (MeasureTheory.eLpNorm (s.indicator fun x => c) p μ) (HMul.hMul (ENorm.enorm c) (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal)))","decl":"lemma eLpNorm_indicator_const_le (c : G) (p : ℝ≥0∞) :\n    eLpNorm (s.indicator fun _ => c) p μ ≤ ‖c‖ₑ * μ s ^ (1 / p.toReal) := by\n  obtain rfl | hp := eq_or_ne p 0\n  · simp only [eLpNorm_exponent_zero, zero_le']\n  obtain rfl | h'p := eq_or_ne p ∞\n  · simp only [eLpNorm_exponent_top, ENNReal.top_toReal, _root_.div_zero, ENNReal.rpow_zero,\n      mul_one]\n    exact eLpNormEssSup_indicator_const_le _ _\n  let t := toMeasurable μ s\n  calc\n    eLpNorm (s.indicator fun _ => c) p μ ≤ eLpNorm (t.indicator fun _ => c) p μ :=\n      eLpNorm_mono (norm_indicator_le_of_subset (subset_toMeasurable _ _) _)\n    _ = ‖c‖ₑ * μ t ^ (1 / p.toReal) :=\n      eLpNorm_indicator_const (measurableSet_toMeasurable ..) hp h'p\n    _ = ‖c‖ₑ * μ s ^ (1 / p.toReal) := by rw [measure_toMeasurable]\n\n"}
{"name":"MeasureTheory.Memℒp.indicator","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ns : Set α\nhs : MeasurableSet s\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (s.indicator f) p μ","decl":"lemma Memℒp.indicator (hs : MeasurableSet s) (hf : Memℒp f p μ) : Memℒp (s.indicator f) p μ :=\n  ⟨hf.aestronglyMeasurable.indicator hs, lt_of_le_of_lt (eLpNorm_indicator_le f) hf.eLpNorm_lt_top⟩\n\n"}
{"name":"MeasureTheory.memℒp_indicator_iff_restrict","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\ns : Set α\nhs : MeasurableSet s\n⊢ Iff (MeasureTheory.Memℒp (s.indicator f) p μ) (MeasureTheory.Memℒp f p (μ.restrict s))","decl":"lemma memℒp_indicator_iff_restrict (hs : MeasurableSet s) :\n    Memℒp (s.indicator f) p μ ↔ Memℒp f p (μ.restrict s) := by\n  simp [Memℒp, aestronglyMeasurable_indicator_iff hs, eLpNorm_indicator_eq_eLpNorm_restrict hs]\n\n"}
{"name":"MeasureTheory.memℒp_indicator_const","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\np : ENNReal\nhs : MeasurableSet s\nc : E\nhμsc : Or (Eq c 0) (Ne (μ s) Top.top)\n⊢ MeasureTheory.Memℒp (s.indicator fun x => c) p μ","decl":"lemma memℒp_indicator_const (p : ℝ≥0∞) (hs : MeasurableSet s) (c : E) (hμsc : c = 0 ∨ μ s ≠ ∞) :\n    Memℒp (s.indicator fun _ => c) p μ := by\n  rw [memℒp_indicator_iff_restrict hs]\n  obtain rfl | hμ := hμsc\n  · exact Memℒp.zero\n  · have := Fact.mk hμ.lt_top\n    apply memℒp_const\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_piecewise","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ns : Set α\nf g : α → E\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.eLpNormEssSup (s.piecewise f g) μ) (Max.max (MeasureTheory.eLpNormEssSup f (μ.restrict s)) (MeasureTheory.eLpNormEssSup g (μ.restrict (HasCompl.compl s))))","decl":"lemma eLpNormEssSup_piecewise (f g : α → E) [DecidablePred (· ∈ s)] (hs : MeasurableSet s) :\n    eLpNormEssSup (Set.piecewise s f g) μ\n      = max (eLpNormEssSup f (μ.restrict s)) (eLpNormEssSup g (μ.restrict sᶜ)) := by\n  simp only [eLpNormEssSup, ← ENNReal.essSup_piecewise hs]\n  congr with x\n  by_cases hx : x ∈ s <;> simp [hx]\n\n"}
{"name":"MeasureTheory.eLpNorm_top_piecewise","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ns : Set α\nf g : α → E\ninst✝ : DecidablePred fun x => Membership.mem s x\nhs : MeasurableSet s\n⊢ Eq (MeasureTheory.eLpNorm (s.piecewise f g) Top.top μ) (Max.max (MeasureTheory.eLpNorm f Top.top (μ.restrict s)) (MeasureTheory.eLpNorm g Top.top (μ.restrict (HasCompl.compl s))))","decl":"lemma eLpNorm_top_piecewise (f g : α → E) [DecidablePred (· ∈ s)] (hs : MeasurableSet s) :\n    eLpNorm (Set.piecewise s f g) ∞ μ\n      = max (eLpNorm f ∞ (μ.restrict s)) (eLpNorm g ∞ (μ.restrict sᶜ)) :=\n  eLpNormEssSup_piecewise f g hs\n\n"}
{"name":"MeasureTheory.Memℒp.piecewise","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\nf : α → F\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\ng : α → F\nhs : MeasurableSet s\nhf : MeasureTheory.Memℒp f p (μ.restrict s)\nhg : MeasureTheory.Memℒp g p (μ.restrict (HasCompl.compl s))\n⊢ MeasureTheory.Memℒp (s.piecewise f g) p μ","decl":"protected lemma Memℒp.piecewise [DecidablePred (· ∈ s)] {g} (hs : MeasurableSet s)\n   (hf : Memℒp f p (μ.restrict s)) (hg : Memℒp g p (μ.restrict sᶜ)) :\n    Memℒp (s.piecewise f g) p μ := by\n  by_cases hp_zero : p = 0\n  · simp only [hp_zero, memℒp_zero_iff_aestronglyMeasurable]\n    exact AEStronglyMeasurable.piecewise hs hf.1 hg.1\n  refine ⟨AEStronglyMeasurable.piecewise hs hf.1 hg.1, ?_⟩\n  obtain rfl | hp_top := eq_or_ne p ∞\n  · rw [eLpNorm_top_piecewise f g hs]\n    exact max_lt hf.2 hg.2\n  rw [eLpNorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top hp_zero hp_top, ← lintegral_add_compl _ hs,\n    ENNReal.add_lt_top]\n  constructor\n  · have h : ∀ᵐ x ∂μ, x ∈ s → ‖Set.piecewise s f g x‖ₑ ^ p.toReal = ‖f x‖ₑ ^ p.toReal := by\n      filter_upwards with a ha using by simp [ha]\n    rw [setLIntegral_congr_fun hs h]\n    exact lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp_zero hp_top hf.2\n  · have h : ∀ᵐ x ∂μ, x ∈ sᶜ → ‖Set.piecewise s f g x‖ₑ ^ p.toReal = ‖g x‖ₑ ^ p.toReal := by\n      filter_upwards with a ha\n      have ha' : a ∉ s := ha\n      simp [ha']\n    rw [setLIntegral_congr_fun hs.compl h]\n    exact lintegral_rpow_enorm_lt_top_of_eLpNorm_lt_top hp_zero hp_top hg.2\n\n"}
{"name":"MeasureTheory.eLpNorm_restrict_eq_of_support_subset","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\ns : Set α\nf : α → F\nhsf : HasSubset.Subset (Function.support f) s\n⊢ Eq (MeasureTheory.eLpNorm f p (μ.restrict s)) (MeasureTheory.eLpNorm f p μ)","decl":"/-- For a function `f` with support in `s`, the Lᵖ norms of `f` with respect to `μ` and\n`μ.restrict s` are the same. -/\ntheorem eLpNorm_restrict_eq_of_support_subset {s : Set α} {f : α → F} (hsf : f.support ⊆ s) :\n    eLpNorm f p (μ.restrict s) = eLpNorm f p μ := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  by_cases hp_top : p = ∞\n  · simp only [hp_top, eLpNorm_exponent_top, eLpNormEssSup_eq_essSup_enorm]\n    exact ENNReal.essSup_restrict_eq_of_support_subset fun x hx ↦ hsf <| enorm_ne_zero.1 hx\n  · simp_rw [eLpNorm_eq_eLpNorm' hp0 hp_top, eLpNorm'_eq_lintegral_enorm]\n    congr 1\n    apply setLIntegral_eq_of_support_subset\n    have : ¬(p.toReal ≤ 0) := by simpa only [not_le] using ENNReal.toReal_pos hp0 hp_top\n    simpa [this] using hsf\n\n"}
{"name":"MeasureTheory.Memℒp.restrict","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\ns : Set α\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp f p (μ.restrict s)","decl":"theorem Memℒp.restrict (s : Set α) {f : α → E} (hf : Memℒp f p μ) : Memℒp f p (μ.restrict s) :=\n  hf.mono_measure Measure.restrict_le_self\n\n"}
{"name":"MeasureTheory.eLpNorm'_smul_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\np : Real\nhp : LE.le 0 p\nf : α → F\nc : ENNReal\n⊢ Eq (MeasureTheory.eLpNorm' f p (HSMul.hSMul c μ)) (HMul.hMul (HPow.hPow c (HDiv.hDiv 1 p)) (MeasureTheory.eLpNorm' f p μ))","decl":"theorem eLpNorm'_smul_measure {p : ℝ} (hp : 0 ≤ p) {f : α → F} (c : ℝ≥0∞) :\n    eLpNorm' f p (c • μ) = c ^ (1 / p) * eLpNorm' f p μ := by\n  rw [eLpNorm', lintegral_smul_measure, ENNReal.mul_rpow_of_nonneg, eLpNorm']\n  simp [hp]\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_smul_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝⁴ : NormedAddCommGroup F\nR : Type u_6\ninst✝³ : Zero R\ninst✝² : SMulWithZero R ENNReal\ninst✝¹ : IsScalarTower R ENNReal ENNReal\ninst✝ : NoZeroSMulDivisors R ENNReal\nc : R\nhc : Ne c 0\nf : α → F\n⊢ Eq (MeasureTheory.eLpNormEssSup f (HSMul.hSMul c μ)) (MeasureTheory.eLpNormEssSup f μ)","decl":"@[simp] lemma eLpNormEssSup_smul_measure (hc : c ≠ 0) (f : α → F) :\n    eLpNormEssSup f (c • μ) = eLpNormEssSup f μ := by\n  simp_rw [eLpNormEssSup]\n  exact essSup_smul_measure hc _\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_measure_of_ne_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nc : ENNReal\nhc : Ne c 0\nf : α → F\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm f p (HSMul.hSMul c μ)) (HSMul.hSMul (HPow.hPow c (HDiv.hDiv 1 p).toReal) (MeasureTheory.eLpNorm f p μ))","decl":"/-- See `eLpNorm_smul_measure_of_ne_zero'` for a version with scalar multiplication by `ℝ≥0`. -/\ntheorem eLpNorm_smul_measure_of_ne_zero {c : ℝ≥0∞} (hc : c ≠ 0) (f : α → F) (p : ℝ≥0∞)\n    (μ : Measure α) : eLpNorm f p (c • μ) = c ^ (1 / p).toReal • eLpNorm f p μ := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  by_cases hp_top : p = ∞\n  · simp [hp_top, eLpNormEssSup_smul_measure hc]\n  exact eLpNorm_smul_measure_of_ne_zero_of_ne_top hp0 hp_top c\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_measure_of_ne_zero'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nc : NNReal\nhc : Ne c 0\nf : α → F\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm f p (HSMul.hSMul c μ)) (HSMul.hSMul (HPow.hPow c (Inv.inv p.toReal)) (MeasureTheory.eLpNorm f p μ))","decl":"/-- See `eLpNorm_smul_measure_of_ne_zero` for a version with scalar multiplication by `ℝ≥0∞`. -/\nlemma eLpNorm_smul_measure_of_ne_zero' {c : ℝ≥0} (hc : c ≠ 0) (f : α → F) (p : ℝ≥0∞)\n    (μ : Measure α) : eLpNorm f p (c • μ) = c ^ p.toReal⁻¹ • eLpNorm f p μ :=\n  (eLpNorm_smul_measure_of_ne_zero (ENNReal.coe_ne_zero.2 hc) ..).trans (by simp; norm_cast)\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_measure_of_ne_top","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\np : ENNReal\nhp_ne_top : Ne p Top.top\nf : α → F\nc : ENNReal\n⊢ Eq (MeasureTheory.eLpNorm f p (HSMul.hSMul c μ)) (HSMul.hSMul (HPow.hPow c (HDiv.hDiv 1 p).toReal) (MeasureTheory.eLpNorm f p μ))","decl":"/-- See `eLpNorm_smul_measure_of_ne_top'` for a version with scalar multiplication by `ℝ≥0`. -/\ntheorem eLpNorm_smul_measure_of_ne_top {p : ℝ≥0∞} (hp_ne_top : p ≠ ∞) (f : α → F) (c : ℝ≥0∞) :\n    eLpNorm f p (c • μ) = c ^ (1 / p).toReal • eLpNorm f p μ := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  · exact eLpNorm_smul_measure_of_ne_zero_of_ne_top hp0 hp_ne_top c\n\n"}
{"name":"MeasureTheory.eLpNorm_smul_measure_of_ne_top'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhp : Ne p Top.top\nc : NNReal\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm f p (HSMul.hSMul c μ)) (HSMul.hSMul (HPow.hPow c (Inv.inv p.toReal)) (MeasureTheory.eLpNorm f p μ))","decl":"/-- See `eLpNorm_smul_measure_of_ne_top'` for a version with scalar multiplication by `ℝ≥0∞`. -/\nlemma eLpNorm_smul_measure_of_ne_top' (hp : p ≠ ∞) (c : ℝ≥0) (f : α → F) :\n    eLpNorm f p (c • μ) = c ^ p.toReal⁻¹ • eLpNorm f p μ := by\n  have : 0 ≤ p.toReal⁻¹ := by positivity\n  refine (eLpNorm_smul_measure_of_ne_top hp ..).trans ?_\n  simp [ENNReal.smul_def, ENNReal.coe_rpow_of_nonneg, this]\n"}
{"name":"MeasureTheory.eLpNorm_one_smul_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nc : ENNReal\n⊢ Eq (MeasureTheory.eLpNorm f 1 (HSMul.hSMul c μ)) (HMul.hMul c (MeasureTheory.eLpNorm f 1 μ))","decl":"theorem eLpNorm_one_smul_measure {f : α → F} (c : ℝ≥0∞) :\n    eLpNorm f 1 (c • μ) = c * eLpNorm f 1 μ := by\n  rw [@eLpNorm_smul_measure_of_ne_top _ _ _ μ _ 1 (@ENNReal.coe_ne_top 1) f c]\n  simp\n\n"}
{"name":"MeasureTheory.Memℒp.of_measure_le_smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nμ' : MeasureTheory.Measure α\nc : ENNReal\nhc : Ne c Top.top\nhμ'_le : LE.le μ' (HSMul.hSMul c μ)\nf : α → E\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp f p μ'","decl":"theorem Memℒp.of_measure_le_smul {μ' : Measure α} (c : ℝ≥0∞) (hc : c ≠ ∞) (hμ'_le : μ' ≤ c • μ)\n    {f : α → E} (hf : Memℒp f p μ) : Memℒp f p μ' := by\n  refine ⟨hf.1.mono_ac (Measure.absolutelyContinuous_of_le_smul hμ'_le), ?_⟩\n  refine (eLpNorm_mono_measure f hμ'_le).trans_lt ?_\n  by_cases hc0 : c = 0\n  · simp [hc0]\n  rw [eLpNorm_smul_measure_of_ne_zero hc0, smul_eq_mul]\n  refine ENNReal.mul_lt_top (Ne.lt_top ?_) hf.2\n  simp [hc, hc0]\n\n"}
{"name":"MeasureTheory.Memℒp.smul_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nc : ENNReal\nhf : MeasureTheory.Memℒp f p μ\nhc : Ne c Top.top\n⊢ MeasureTheory.Memℒp f p (HSMul.hSMul c μ)","decl":"theorem Memℒp.smul_measure {f : α → E} {c : ℝ≥0∞} (hf : Memℒp f p μ) (hc : c ≠ ∞) :\n    Memℒp f p (c • μ) :=\n  hf.of_measure_le_smul c hc le_rfl\n\n"}
{"name":"MeasureTheory.eLpNorm_one_add_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : α → F\nμ ν : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm f 1 (HAdd.hAdd μ ν)) (HAdd.hAdd (MeasureTheory.eLpNorm f 1 μ) (MeasureTheory.eLpNorm f 1 ν))","decl":"theorem eLpNorm_one_add_measure (f : α → F) (μ ν : Measure α) :\n    eLpNorm f 1 (μ + ν) = eLpNorm f 1 μ + eLpNorm f 1 ν := by\n  simp_rw [eLpNorm_one_eq_lintegral_enorm]\n  rw [lintegral_add_measure _ μ ν]\n\n"}
{"name":"MeasureTheory.eLpNorm_le_add_measure_right","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : α → F\nμ ν : MeasureTheory.Measure α\np : ENNReal\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (MeasureTheory.eLpNorm f p (HAdd.hAdd μ ν))","decl":"theorem eLpNorm_le_add_measure_right (f : α → F) (μ ν : Measure α) {p : ℝ≥0∞} :\n    eLpNorm f p μ ≤ eLpNorm f p (μ + ν) :=\n  eLpNorm_mono_measure f <| Measure.le_add_right <| le_refl _\n\n"}
{"name":"MeasureTheory.eLpNorm_le_add_measure_left","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝ : NormedAddCommGroup F\nf : α → F\nμ ν : MeasureTheory.Measure α\np : ENNReal\n⊢ LE.le (MeasureTheory.eLpNorm f p ν) (MeasureTheory.eLpNorm f p (HAdd.hAdd μ ν))","decl":"theorem eLpNorm_le_add_measure_left (f : α → F) (μ ν : Measure α) {p : ℝ≥0∞} :\n    eLpNorm f p ν ≤ eLpNorm f p (μ + ν) :=\n  eLpNorm_mono_measure f <| Measure.le_add_left <| le_refl _\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_eq_iSup","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nhμ : ∀ (a : α), Ne (μ (Singleton.singleton a)) 0\nf : α → E\n⊢ Eq (MeasureTheory.eLpNormEssSup f μ) (iSup fun a => ENorm.enorm (f a))","decl":"lemma eLpNormEssSup_eq_iSup (hμ : ∀ a, μ {a} ≠ 0) (f : α → E) : eLpNormEssSup f μ = ⨆ a, ‖f a‖ₑ :=\n  essSup_eq_iSup hμ _\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_count","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasurableSingletonClass α\nf : α → E\n⊢ Eq (MeasureTheory.eLpNormEssSup f MeasureTheory.Measure.count) (iSup fun a => ENorm.enorm (f a))","decl":"@[simp] lemma eLpNormEssSup_count [MeasurableSingletonClass α] (f : α → E) :\n    eLpNormEssSup f .count = ⨆ a, ‖f a‖ₑ := essSup_count _\n\n"}
{"name":"MeasureTheory.Memℒp.left_of_add_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nh : MeasureTheory.Memℒp f p (HAdd.hAdd μ ν)\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.left_of_add_measure {f : α → E} (h : Memℒp f p (μ + ν)) : Memℒp f p μ :=\n  h.mono_measure <| Measure.le_add_right <| le_refl _\n\n"}
{"name":"MeasureTheory.Memℒp.right_of_add_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nh : MeasureTheory.Memℒp f p (HAdd.hAdd μ ν)\n⊢ MeasureTheory.Memℒp f p ν","decl":"theorem Memℒp.right_of_add_measure {f : α → E} (h : Memℒp f p (μ + ν)) : Memℒp f p ν :=\n  h.mono_measure <| Measure.le_add_left <| le_refl _\n\n"}
{"name":"MeasureTheory.Memℒp.norm","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nh : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun x => Norm.norm (f x)) p μ","decl":"theorem Memℒp.norm {f : α → E} (h : Memℒp f p μ) : Memℒp (fun x => ‖f x‖) p μ :=\n  h.of_le h.aestronglyMeasurable.norm (Eventually.of_forall fun x => by simp)\n\n"}
{"name":"MeasureTheory.memℒp_norm_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Iff (MeasureTheory.Memℒp (fun x => Norm.norm (f x)) p μ) (MeasureTheory.Memℒp f p μ)","decl":"theorem memℒp_norm_iff {f : α → E} (hf : AEStronglyMeasurable f μ) :\n    Memℒp (fun x => ‖f x‖) p μ ↔ Memℒp f p μ :=\n  ⟨fun h => ⟨hf, by rw [← eLpNorm_norm]; exact h.2⟩, fun h => h.norm⟩\n\n"}
{"name":"MeasureTheory.eLpNorm'_eq_zero_of_ae_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\nhq0_lt : LT.lt 0 q\nhf_zero : (MeasureTheory.ae μ).EventuallyEq f 0\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) 0","decl":"theorem eLpNorm'_eq_zero_of_ae_zero {f : α → F} (hq0_lt : 0 < q) (hf_zero : f =ᵐ[μ] 0) :\n    eLpNorm' f q μ = 0 := by rw [eLpNorm'_congr_ae hf_zero, eLpNorm'_zero hq0_lt]\n\n"}
{"name":"MeasureTheory.eLpNorm'_eq_zero_of_ae_zero'","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhq0_ne : Ne q 0\nhμ : Ne μ 0\nf : α → F\nhf_zero : (MeasureTheory.ae μ).EventuallyEq f 0\n⊢ Eq (MeasureTheory.eLpNorm' f q μ) 0","decl":"theorem eLpNorm'_eq_zero_of_ae_zero' (hq0_ne : q ≠ 0) (hμ : μ ≠ 0) {f : α → F}\n    (hf_zero : f =ᵐ[μ] 0) :\n    eLpNorm' f q μ = 0 := by rw [eLpNorm'_congr_ae hf_zero, eLpNorm'_zero' hq0_ne hμ]\n\n"}
{"name":"MeasureTheory.ae_eq_zero_of_eLpNorm'_eq_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhq0 : LE.le 0 q\nhf : MeasureTheory.AEStronglyMeasurable f μ\nh : Eq (MeasureTheory.eLpNorm' f q μ) 0\n⊢ (MeasureTheory.ae μ).EventuallyEq f 0","decl":"theorem ae_eq_zero_of_eLpNorm'_eq_zero {f : α → E} (hq0 : 0 ≤ q) (hf : AEStronglyMeasurable f μ)\n    (h : eLpNorm' f q μ = 0) : f =ᵐ[μ] 0 := by\n  simp only [eLpNorm'_eq_lintegral_enorm, lintegral_eq_zero_iff' (hf.enorm.pow_const q), one_div,\n    ENNReal.rpow_eq_zero_iff, inv_pos, inv_neg'', hq0.not_lt, and_false, or_false] at h\n  refine h.left.mono fun x hx ↦ ?_\n  simp only [Pi.zero_apply, ENNReal.rpow_eq_zero_iff, enorm_eq_zero, enorm_ne_top, false_and,\n    or_false] at hx\n  exact hx.1\n\n"}
{"name":"MeasureTheory.eLpNorm'_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nhq0_lt : LT.lt 0 q\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Iff (Eq (MeasureTheory.eLpNorm' f q μ) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"theorem eLpNorm'_eq_zero_iff (hq0_lt : 0 < q) {f : α → E} (hf : AEStronglyMeasurable f μ) :\n    eLpNorm' f q μ = 0 ↔ f =ᵐ[μ] 0 :=\n  ⟨ae_eq_zero_of_eLpNorm'_eq_zero (le_of_lt hq0_lt) hf, eLpNorm'_eq_zero_of_ae_zero hq0_lt⟩\n\n"}
{"name":"MeasureTheory.coe_nnnorm_ae_le_eLpNormEssSup","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\ninst✝ : NormedAddCommGroup F\nx✝ : MeasurableSpace α\nf : α → F\nμ : MeasureTheory.Measure α\n⊢ Filter.Eventually (fun x => LE.le (ENorm.enorm (f x)) (MeasureTheory.eLpNormEssSup f μ)) (MeasureTheory.ae μ)","decl":"theorem coe_nnnorm_ae_le_eLpNormEssSup {_ : MeasurableSpace α} (f : α → F) (μ : Measure α) :\n    ∀ᵐ x ∂μ, ‖f x‖ₑ ≤ eLpNormEssSup f μ :=\n  ENNReal.ae_le_essSup fun x => ‖f x‖ₑ\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Iff (Eq (MeasureTheory.eLpNormEssSup f μ) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"@[simp]\ntheorem eLpNormEssSup_eq_zero_iff {f : α → F} : eLpNormEssSup f μ = 0 ↔ f =ᵐ[μ] 0 := by\n  simp [EventuallyEq, eLpNormEssSup_eq_essSup_enorm]\n\n"}
{"name":"MeasureTheory.eLpNorm_eq_zero_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.AEStronglyMeasurable f μ\nh0 : Ne p 0\n⊢ Iff (Eq (MeasureTheory.eLpNorm f p μ) 0) ((MeasureTheory.ae μ).EventuallyEq f 0)","decl":"theorem eLpNorm_eq_zero_iff {f : α → E} (hf : AEStronglyMeasurable f μ) (h0 : p ≠ 0) :\n    eLpNorm f p μ = 0 ↔ f =ᵐ[μ] 0 := by\n  by_cases h_top : p = ∞\n  · rw [h_top, eLpNorm_exponent_top, eLpNormEssSup_eq_zero_iff]\n  rw [eLpNorm_eq_eLpNorm' h0 h_top]\n  exact eLpNorm'_eq_zero_iff (ENNReal.toReal_pos h0 h_top) hf\n\n"}
{"name":"MeasureTheory.eLpNorm_eq_zero_of_ae_zero","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : (MeasureTheory.ae μ).EventuallyEq f 0\n⊢ Eq (MeasureTheory.eLpNorm f p μ) 0","decl":"theorem eLpNorm_eq_zero_of_ae_zero {f : α → E} (hf : f =ᵐ[μ] 0) : eLpNorm f p μ = 0 := by\n  rw [← eLpNorm_zero (p := p) (μ := μ) (α := α) (F := E)]\n  exact eLpNorm_congr_ae hf\n\n"}
{"name":"MeasureTheory.ae_le_eLpNormEssSup","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Filter.Eventually (fun y => LE.le (ENorm.enorm (f y)) (MeasureTheory.eLpNormEssSup f μ)) (MeasureTheory.ae μ)","decl":"theorem ae_le_eLpNormEssSup {f : α → F} : ∀ᵐ y ∂μ, ‖f y‖ₑ ≤ eLpNormEssSup f μ :=\n  ae_le_essSup\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_lt_top_iff_isBoundedUnder","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Iff (LT.lt (MeasureTheory.eLpNormEssSup f μ) Top.top) (Filter.IsBoundedUnder (fun x1 x2 => LE.le x1 x2) (MeasureTheory.ae μ) fun x => NNNorm.nnnorm (f x))","decl":"lemma eLpNormEssSup_lt_top_iff_isBoundedUnder :\n    eLpNormEssSup f μ < ⊤ ↔ IsBoundedUnder (· ≤ ·) (ae μ) fun x ↦ ‖f x‖₊ where\n  mp h := ⟨(eLpNormEssSup f μ).toNNReal, by\n    simp_rw [← ENNReal.coe_le_coe, ENNReal.coe_toNNReal h.ne]; exact ae_le_eLpNormEssSup⟩\n  mpr := by rintro ⟨C, hC⟩; exact eLpNormEssSup_lt_top_of_ae_nnnorm_bound (C := C) hC\n\n"}
{"name":"MeasureTheory.meas_eLpNormEssSup_lt","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nf : α → F\n⊢ Eq (μ (setOf fun y => LT.lt (MeasureTheory.eLpNormEssSup f μ) (ENorm.enorm (f y)))) 0","decl":"theorem meas_eLpNormEssSup_lt {f : α → F} : μ { y | eLpNormEssSup f μ < ‖f y‖ₑ } = 0 :=\n  meas_essSup_lt\n\n"}
{"name":"MeasureTheory.eLpNorm_lt_top_of_finite","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup F\nf : α → F\ninst✝¹ : Finite α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ LT.lt (MeasureTheory.eLpNorm f p μ) Top.top","decl":"lemma eLpNorm_lt_top_of_finite [Finite α] [IsFiniteMeasure μ] : eLpNorm f p μ < ∞ := by\n  obtain rfl | hp₀ := eq_or_ne p 0\n  · simp\n  obtain rfl | hp := eq_or_ne p ∞\n  · simp only [eLpNorm_exponent_top, eLpNormEssSup_lt_top_iff_isBoundedUnder]\n    exact .le_of_finite\n  rw [eLpNorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top hp₀ hp]\n  refine IsFiniteMeasure.lintegral_lt_top_of_bounded_to_ennreal μ ?_\n  simp_rw [enorm, ← ENNReal.coe_rpow_of_nonneg _ ENNReal.toReal_nonneg]\n  norm_cast\n  exact Finite.exists_le _\n\n"}
{"name":"MeasureTheory.Memℒp.of_discrete","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\nf : α → F\ninst✝² : DiscreteMeasurableSpace α\ninst✝¹ : Finite α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.Memℒp f p μ","decl":"@[simp] lemma Memℒp.of_discrete [DiscreteMeasurableSpace α] [Finite α] [IsFiniteMeasure μ] :\n    Memℒp f p μ :=\n  let ⟨C, hC⟩ := Finite.exists_le (‖f ·‖₊); .of_bound .of_finite C <| .of_forall hC\n\n"}
{"name":"MeasureTheory.eLpNorm_of_isEmpty","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : IsEmpty α\nf : α → E\np : ENNReal\n⊢ Eq (MeasureTheory.eLpNorm f p μ) 0","decl":"@[simp] lemma eLpNorm_of_isEmpty [IsEmpty α] (f : α → E) (p : ℝ≥0∞) : eLpNorm f p μ = 0 := by\n  simp [Subsingleton.elim f 0]\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_map_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → E\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.eLpNormEssSup g (MeasureTheory.Measure.map f μ)) (MeasureTheory.eLpNormEssSup (Function.comp g f) μ)","decl":"theorem eLpNormEssSup_map_measure (hg : AEStronglyMeasurable g (Measure.map f μ))\n    (hf : AEMeasurable f μ) : eLpNormEssSup g (Measure.map f μ) = eLpNormEssSup (g ∘ f) μ :=\n  essSup_map_measure hg.enorm hf\n\n"}
{"name":"MeasureTheory.eLpNorm_map_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → E\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ Eq (MeasureTheory.eLpNorm g p (MeasureTheory.Measure.map f μ)) (MeasureTheory.eLpNorm (Function.comp g f) p μ)","decl":"theorem eLpNorm_map_measure (hg : AEStronglyMeasurable g (Measure.map f μ))\n    (hf : AEMeasurable f μ) : eLpNorm g p (Measure.map f μ) = eLpNorm (g ∘ f) p μ := by\n  by_cases hp_zero : p = 0\n  · simp only [hp_zero, eLpNorm_exponent_zero]\n  by_cases hp_top : p = ∞\n  · simp_rw [hp_top, eLpNorm_exponent_top]\n    exact eLpNormEssSup_map_measure hg hf\n  simp_rw [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp_top]\n  rw [lintegral_map' (hg.enorm.pow_const p.toReal) hf]\n  rfl\n\n"}
{"name":"MeasureTheory.memℒp_map_measure_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → E\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ Iff (MeasureTheory.Memℒp g p (MeasureTheory.Measure.map f μ)) (MeasureTheory.Memℒp (Function.comp g f) p μ)","decl":"theorem memℒp_map_measure_iff (hg : AEStronglyMeasurable g (Measure.map f μ))\n    (hf : AEMeasurable f μ) : Memℒp g p (Measure.map f μ) ↔ Memℒp (g ∘ f) p μ := by\n  simp [Memℒp, eLpNorm_map_measure hg hf, hg.comp_aemeasurable hf, hg]\n\n"}
{"name":"MeasureTheory.Memℒp.comp_of_map","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → E\nhg : MeasureTheory.Memℒp g p (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ MeasureTheory.Memℒp (Function.comp g f) p μ","decl":"theorem Memℒp.comp_of_map (hg : Memℒp g p (Measure.map f μ)) (hf : AEMeasurable f μ) :\n    Memℒp (g ∘ f) p μ :=\n  (memℒp_map_measure_iff hg.aestronglyMeasurable hf).1 hg\n\n"}
{"name":"MeasureTheory.eLpNorm_comp_measurePreserving","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → E\nν : MeasureTheory.Measure β\nhg : MeasureTheory.AEStronglyMeasurable g ν\nhf : MeasureTheory.MeasurePreserving f μ ν\n⊢ Eq (MeasureTheory.eLpNorm (Function.comp g f) p μ) (MeasureTheory.eLpNorm g p ν)","decl":"theorem eLpNorm_comp_measurePreserving {ν : MeasureTheory.Measure β} (hg : AEStronglyMeasurable g ν)\n    (hf : MeasurePreserving f μ ν) : eLpNorm (g ∘ f) p μ = eLpNorm g p ν :=\n  Eq.symm <| hf.map_eq ▸ eLpNorm_map_measure (hf.map_eq ▸ hg) hf.aemeasurable\n\n"}
{"name":"MeasureTheory.AEEqFun.eLpNorm_compMeasurePreserving","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\nν : MeasureTheory.Measure β\ng : MeasureTheory.AEEqFun β E ν\nhf : MeasureTheory.MeasurePreserving f μ ν\n⊢ Eq (MeasureTheory.eLpNorm (↑(g.compMeasurePreserving f hf)) p μ) (MeasureTheory.eLpNorm (↑g) p ν)","decl":"theorem AEEqFun.eLpNorm_compMeasurePreserving {ν : MeasureTheory.Measure β} (g : β →ₘ[ν] E)\n    (hf : MeasurePreserving f μ ν) :\n    eLpNorm (g.compMeasurePreserving f hf) p μ = eLpNorm g p ν := by\n  rw [eLpNorm_congr_ae (g.coeFn_compMeasurePreserving _)]\n  exact eLpNorm_comp_measurePreserving g.aestronglyMeasurable hf\n\n"}
{"name":"MeasureTheory.Memℒp.comp_measurePreserving","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup E\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → E\nν : MeasureTheory.Measure β\nhg : MeasureTheory.Memℒp g p ν\nhf : MeasureTheory.MeasurePreserving f μ ν\n⊢ MeasureTheory.Memℒp (Function.comp g f) p μ","decl":"theorem Memℒp.comp_measurePreserving {ν : MeasureTheory.Measure β} (hg : Memℒp g p ν)\n    (hf : MeasurePreserving f μ ν) : Memℒp (g ∘ f) p μ :=\n  .comp_of_map (hf.map_eq.symm ▸ hg) hf.aemeasurable\n\n"}
{"name":"MeasurableEmbedding.eLpNormEssSup_map_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → F\nhf : MeasurableEmbedding f\n⊢ Eq (MeasureTheory.eLpNormEssSup g (MeasureTheory.Measure.map f μ)) (MeasureTheory.eLpNormEssSup (Function.comp g f) μ)","decl":"theorem _root_.MeasurableEmbedding.eLpNormEssSup_map_measure {g : β → F}\n    (hf : MeasurableEmbedding f) : eLpNormEssSup g (Measure.map f μ) = eLpNormEssSup (g ∘ f) μ :=\n  hf.essSup_map_measure\n\n"}
{"name":"MeasurableEmbedding.eLpNorm_map_measure","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → F\nhf : MeasurableEmbedding f\n⊢ Eq (MeasureTheory.eLpNorm g p (MeasureTheory.Measure.map f μ)) (MeasureTheory.eLpNorm (Function.comp g f) p μ)","decl":"theorem _root_.MeasurableEmbedding.eLpNorm_map_measure {g : β → F} (hf : MeasurableEmbedding f) :\n    eLpNorm g p (Measure.map f μ) = eLpNorm (g ∘ f) p μ := by\n  by_cases hp_zero : p = 0\n  · simp only [hp_zero, eLpNorm_exponent_zero]\n  by_cases hp : p = ∞\n  · simp_rw [hp, eLpNorm_exponent_top]\n    exact hf.essSup_map_measure\n  · simp_rw [eLpNorm_eq_lintegral_rpow_enorm hp_zero hp]\n    rw [hf.lintegral_map]\n    rfl\n\n"}
{"name":"MeasurableEmbedding.memℒp_map_measure_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nβ : Type u_6\nmβ : MeasurableSpace β\nf : α → β\ng : β → F\nhf : MeasurableEmbedding f\n⊢ Iff (MeasureTheory.Memℒp g p (MeasureTheory.Measure.map f μ)) (MeasureTheory.Memℒp (Function.comp g f) p μ)","decl":"theorem _root_.MeasurableEmbedding.memℒp_map_measure_iff {g : β → F} (hf : MeasurableEmbedding f) :\n    Memℒp g p (Measure.map f μ) ↔ Memℒp (g ∘ f) p μ := by\n  simp_rw [Memℒp, hf.aestronglyMeasurable_map_iff, hf.eLpNorm_map_measure]\n\n"}
{"name":"MeasurableEquiv.memℒp_map_measure_iff","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nβ : Type u_6\nmβ : MeasurableSpace β\nf : MeasurableEquiv α β\ng : β → F\n⊢ Iff (MeasureTheory.Memℒp g p (MeasureTheory.Measure.map (⇑f) μ)) (MeasureTheory.Memℒp (Function.comp g ⇑f) p μ)","decl":"theorem _root_.MeasurableEquiv.memℒp_map_measure_iff (f : α ≃ᵐ β) {g : β → F} :\n    Memℒp g p (Measure.map f μ) ↔ Memℒp (g ∘ f) p μ :=\n  f.measurableEmbedding.memℒp_map_measure_iff\n\n"}
{"name":"MeasureTheory.eLpNorm'_le_nnreal_smul_eLpNorm'_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nc : NNReal\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (HMul.hMul c (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\np : Real\nhp : LT.lt 0 p\n⊢ LE.le (MeasureTheory.eLpNorm' f p μ) (HSMul.hSMul c (MeasureTheory.eLpNorm' g p μ))","decl":"theorem eLpNorm'_le_nnreal_smul_eLpNorm'_of_ae_le_mul {f : α → F} {g : α → G} {c : ℝ≥0}\n    (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ c * ‖g x‖₊) {p : ℝ} (hp : 0 < p) :\n    eLpNorm' f p μ ≤ c • eLpNorm' g p μ := by\n  simp_rw [eLpNorm'_eq_lintegral_enorm]\n  rw [← ENNReal.rpow_le_rpow_iff hp, ENNReal.smul_def, smul_eq_mul,\n    ENNReal.mul_rpow_of_nonneg _ _ hp.le]\n  simp_rw [← ENNReal.rpow_mul, one_div, inv_mul_cancel₀ hp.ne.symm, ENNReal.rpow_one, enorm,\n    ← ENNReal.coe_rpow_of_nonneg _ hp.le, ← lintegral_const_mul' _ _ ENNReal.coe_ne_top,\n    ← ENNReal.coe_mul]\n  apply lintegral_mono_ae\n  simp_rw [ENNReal.coe_le_coe, ← NNReal.mul_rpow, NNReal.rpow_le_rpow_iff hp]\n  exact h\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_le_nnreal_smul_eLpNormEssSup_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nc : NNReal\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (HMul.hMul c (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\n⊢ LE.le (MeasureTheory.eLpNormEssSup f μ) (HSMul.hSMul c (MeasureTheory.eLpNormEssSup g μ))","decl":"theorem eLpNormEssSup_le_nnreal_smul_eLpNormEssSup_of_ae_le_mul {f : α → F} {g : α → G} {c : ℝ≥0}\n    (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ c * ‖g x‖₊) : eLpNormEssSup f μ ≤ c • eLpNormEssSup g μ :=\n  calc\n    essSup (‖f ·‖ₑ) μ ≤ essSup (fun x => (↑(c * ‖g x‖₊) : ℝ≥0∞)) μ :=\n      essSup_mono_ae <| h.mono fun _ hx => ENNReal.coe_le_coe.mpr hx\n    _ = essSup (c * ‖g ·‖ₑ) μ := by simp_rw [ENNReal.coe_mul, enorm]\n    _ = c • essSup (‖g ·‖ₑ) μ := ENNReal.essSup_const_mul\n\n"}
{"name":"MeasureTheory.eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nc : NNReal\nh : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (HMul.hMul c (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\np : ENNReal\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (HSMul.hSMul c (MeasureTheory.eLpNorm g p μ))","decl":"theorem eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul {f : α → F} {g : α → G} {c : ℝ≥0}\n    (h : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ c * ‖g x‖₊) (p : ℝ≥0∞) : eLpNorm f p μ ≤ c • eLpNorm g p μ := by\n  by_cases h0 : p = 0\n  · simp [h0]\n  by_cases h_top : p = ∞\n  · rw [h_top]\n    exact eLpNormEssSup_le_nnreal_smul_eLpNormEssSup_of_ae_le_mul h\n  simp_rw [eLpNorm_eq_eLpNorm' h0 h_top]\n  exact eLpNorm'_le_nnreal_smul_eLpNorm'_of_ae_le_mul h (ENNReal.toReal_pos h0 h_top)\n\n-- TODO: add the whole family of lemmas?\n"}
{"name":"MeasureTheory.eLpNorm_eq_zero_and_zero_of_ae_le_mul_neg","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nc : Real\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm (g x)))) (MeasureTheory.ae μ)\nhc : LT.lt c 0\np : ENNReal\n⊢ And (Eq (MeasureTheory.eLpNorm f p μ) 0) (Eq (MeasureTheory.eLpNorm g p μ) 0)","decl":"/-- When `c` is negative, `‖f x‖ ≤ c * ‖g x‖` is nonsense and forces both `f` and `g` to have an\n`eLpNorm` of `0`. -/\ntheorem eLpNorm_eq_zero_and_zero_of_ae_le_mul_neg {f : α → F} {g : α → G} {c : ℝ}\n    (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ c * ‖g x‖) (hc : c < 0) (p : ℝ≥0∞) :\n    eLpNorm f p μ = 0 ∧ eLpNorm g p μ = 0 := by\n  simp_rw [le_mul_iff_eq_zero_of_nonneg_of_neg_of_nonneg (norm_nonneg _) hc (norm_nonneg _),\n    norm_eq_zero, eventually_and] at h\n  change f =ᵐ[μ] 0 ∧ g =ᵐ[μ] 0 at h\n  simp [eLpNorm_congr_ae h.1, eLpNorm_congr_ae h.2]\n\n"}
{"name":"MeasureTheory.eLpNorm_le_mul_eLpNorm_of_ae_le_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nG : Type u_5\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedAddCommGroup G\nf : α → F\ng : α → G\nc : Real\nh : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm (g x)))) (MeasureTheory.ae μ)\np : ENNReal\n⊢ LE.le (MeasureTheory.eLpNorm f p μ) (HMul.hMul (ENNReal.ofReal c) (MeasureTheory.eLpNorm g p μ))","decl":"theorem eLpNorm_le_mul_eLpNorm_of_ae_le_mul {f : α → F} {g : α → G} {c : ℝ}\n    (h : ∀ᵐ x ∂μ, ‖f x‖ ≤ c * ‖g x‖) (p : ℝ≥0∞) :\n    eLpNorm f p μ ≤ ENNReal.ofReal c * eLpNorm g p μ :=\n  eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul\n    (h.mono fun _x hx => hx.trans <| mul_le_mul_of_nonneg_right c.le_coe_toNNReal (norm_nonneg _)) _\n\n"}
{"name":"MeasureTheory.Memℒp.of_nnnorm_le_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : α → F\nc : NNReal\nhg : MeasureTheory.Memℒp g p μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfg : Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (f x)) (HMul.hMul c (NNNorm.nnnorm (g x)))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.of_nnnorm_le_mul {f : α → E} {g : α → F} {c : ℝ≥0} (hg : Memℒp g p μ)\n    (hf : AEStronglyMeasurable f μ) (hfg : ∀ᵐ x ∂μ, ‖f x‖₊ ≤ c * ‖g x‖₊) : Memℒp f p μ :=\n  ⟨hf,\n    (eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul hfg p).trans_lt <|\n      ENNReal.mul_lt_top ENNReal.coe_lt_top hg.eLpNorm_lt_top⟩\n\n"}
{"name":"MeasureTheory.Memℒp.of_le_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedAddCommGroup F\nf : α → E\ng : α → F\nc : Real\nhg : MeasureTheory.Memℒp g p μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhfg : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) (HMul.hMul c (Norm.norm (g x)))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Memℒp f p μ","decl":"theorem Memℒp.of_le_mul {f : α → E} {g : α → F} {c : ℝ} (hg : Memℒp g p μ)\n    (hf : AEStronglyMeasurable f μ) (hfg : ∀ᵐ x ∂μ, ‖f x‖ ≤ c * ‖g x‖) : Memℒp f p μ :=\n  ⟨hf,\n    (eLpNorm_le_mul_eLpNorm_of_ae_le_mul hfg p).trans_lt <|\n      ENNReal.mul_lt_top ENNReal.ofReal_lt_top hg.eLpNorm_lt_top⟩\n\n"}
{"name":"MeasureTheory.eLpNorm'_const_smul_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : MulActionWithZero 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nc : 𝕜\nf : α → F\nhq : LT.lt 0 q\n⊢ LE.le (MeasureTheory.eLpNorm' (HSMul.hSMul c f) q μ) (HMul.hMul (ENorm.enorm c) (MeasureTheory.eLpNorm' f q μ))","decl":"theorem eLpNorm'_const_smul_le (hq : 0 < q) : eLpNorm' (c • f) q μ ≤ ‖c‖ₑ * eLpNorm' f q μ :=\n  eLpNorm'_le_nnreal_smul_eLpNorm'_of_ae_le_mul (Eventually.of_forall fun _ => nnnorm_smul_le ..) hq\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_const_smul_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : MulActionWithZero 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nc : 𝕜\nf : α → F\n⊢ LE.le (MeasureTheory.eLpNormEssSup (HSMul.hSMul c f) μ) (HMul.hMul (ENorm.enorm c) (MeasureTheory.eLpNormEssSup f μ))","decl":"theorem eLpNormEssSup_const_smul_le : eLpNormEssSup (c • f) μ ≤ ‖c‖ₑ * eLpNormEssSup f μ :=\n  eLpNormEssSup_le_nnreal_smul_eLpNormEssSup_of_ae_le_mul\n    (Eventually.of_forall fun _ => by simp [nnnorm_smul_le])\n\n"}
{"name":"MeasureTheory.eLpNorm_const_smul_le","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : MulActionWithZero 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nc : 𝕜\nf : α → F\n⊢ LE.le (MeasureTheory.eLpNorm (HSMul.hSMul c f) p μ) (HMul.hMul (ENorm.enorm c) (MeasureTheory.eLpNorm f p μ))","decl":"theorem eLpNorm_const_smul_le : eLpNorm (c • f) p μ ≤ ‖c‖ₑ * eLpNorm f p μ :=\n  eLpNorm_le_nnreal_smul_eLpNorm_of_ae_le_mul\n    (Eventually.of_forall fun _ => by simp [nnnorm_smul_le]) _\n\n"}
{"name":"MeasureTheory.Memℒp.const_smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : MulActionWithZero 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nf : α → F\nhf : MeasureTheory.Memℒp f p μ\nc : 𝕜\n⊢ MeasureTheory.Memℒp (HSMul.hSMul c f) p μ","decl":"theorem Memℒp.const_smul (hf : Memℒp f p μ) (c : 𝕜) : Memℒp (c • f) p μ :=\n  ⟨AEStronglyMeasurable.const_smul hf.1 c,\n    eLpNorm_const_smul_le.trans_lt (ENNReal.mul_lt_top ENNReal.coe_lt_top hf.2)⟩\n\n"}
{"name":"MeasureTheory.Memℒp.const_mul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf : α → 𝕜\nhf : MeasureTheory.Memℒp f p μ\nc : 𝕜\n⊢ MeasureTheory.Memℒp (fun x => HMul.hMul c (f x)) p μ","decl":"theorem Memℒp.const_mul {f : α → 𝕜} (hf : Memℒp f p μ) (c : 𝕜) : Memℒp (fun x => c * f x) p μ :=\n  hf.const_smul c\n\n"}
{"name":"MeasureTheory.eLpNorm'_const_smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nq : Real\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : Module 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nf : α → F\nc : 𝕜\nhq_pos : LT.lt 0 q\n⊢ Eq (MeasureTheory.eLpNorm' (HSMul.hSMul c f) q μ) (HMul.hMul (ENorm.enorm c) (MeasureTheory.eLpNorm' f q μ))","decl":"theorem eLpNorm'_const_smul {f : α → F} (c : 𝕜) (hq_pos : 0 < q) :\n    eLpNorm' (c • f) q μ = ‖c‖ₑ * eLpNorm' f q μ := by\n  obtain rfl | hc := eq_or_ne c 0\n  · simp [eLpNorm'_eq_lintegral_enorm, hq_pos]\n  refine le_antisymm (eLpNorm'_const_smul_le hq_pos) <| ENNReal.mul_le_of_le_div' ?_\n  simpa [enorm_inv, hc, ENNReal.div_eq_inv_mul]\n    using eLpNorm'_const_smul_le (c := c⁻¹) (f := c • f) hq_pos\n\n"}
{"name":"MeasureTheory.eLpNormEssSup_const_smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : Module 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nc : 𝕜\nf : α → F\n⊢ Eq (MeasureTheory.eLpNormEssSup (HSMul.hSMul c f) μ) (HMul.hMul (ENorm.enorm c) (MeasureTheory.eLpNormEssSup f μ))","decl":"theorem eLpNormEssSup_const_smul (c : 𝕜) (f : α → F) :\n    eLpNormEssSup (c • f) μ = ‖c‖ₑ * eLpNormEssSup f μ := by\n  simp_rw [eLpNormEssSup_eq_essSup_enorm, Pi.smul_apply, enorm_smul,\n    ENNReal.essSup_const_mul]\n\n"}
{"name":"MeasureTheory.eLpNorm_const_smul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\ninst✝³ : NormedAddCommGroup F\n𝕜 : Type u_6\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : Module 𝕜 F\ninst✝ : BoundedSMul 𝕜 F\nc : 𝕜\nf : α → F\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm (HSMul.hSMul c f) p μ) (HMul.hMul (ENorm.enorm c) (MeasureTheory.eLpNorm f p μ))","decl":"theorem eLpNorm_const_smul (c : 𝕜) (f : α → F) (p : ℝ≥0∞) (μ : Measure α):\n    eLpNorm (c • f) p μ = ‖c‖ₑ * eLpNorm f p μ := by\n  obtain rfl | hc := eq_or_ne c 0\n  · simp\n  refine le_antisymm eLpNorm_const_smul_le <| ENNReal.mul_le_of_le_div' ?_\n  simpa [enorm_inv, hc, ENNReal.div_eq_inv_mul]\n    using eLpNorm_const_smul_le (c := c⁻¹) (f := c • f)\n\n"}
{"name":"MeasureTheory.eLpNorm_nsmul","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nn : Nat\nf : α → F\n⊢ Eq (MeasureTheory.eLpNorm (HSMul.hSMul n f) p μ) (HMul.hMul (↑n) (MeasureTheory.eLpNorm f p μ))","decl":"lemma eLpNorm_nsmul [NormedSpace ℝ F] (n : ℕ) (f : α → F) :\n    eLpNorm (n • f) p μ = n * eLpNorm f p μ := by\n  simpa [Nat.cast_smul_eq_nsmul] using eLpNorm_const_smul (n : ℝ) f ..\n\n"}
{"name":"MeasureTheory.le_eLpNorm_of_bddBelow","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nF : Type u_4\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup F\nhp : Ne p 0\nhp' : Ne p Top.top\nf : α → F\nC : NNReal\ns : Set α\nhs : MeasurableSet s\nhf : Filter.Eventually (fun x => Membership.mem s x → LE.le C (NNNorm.nnnorm (f x))) (MeasureTheory.ae μ)\n⊢ LE.le (HSMul.hSMul C (HPow.hPow (μ s) (HDiv.hDiv 1 p.toReal))) (MeasureTheory.eLpNorm f p μ)","decl":"theorem le_eLpNorm_of_bddBelow (hp : p ≠ 0) (hp' : p ≠ ∞) {f : α → F} (C : ℝ≥0) {s : Set α}\n    (hs : MeasurableSet s) (hf : ∀ᵐ x ∂μ, x ∈ s → C ≤ ‖f x‖₊) :\n    C • μ s ^ (1 / p.toReal) ≤ eLpNorm f p μ := by\n  rw [ENNReal.smul_def, smul_eq_mul, eLpNorm_eq_lintegral_rpow_enorm hp hp',\n    one_div, ENNReal.le_rpow_inv_iff (ENNReal.toReal_pos hp hp'),\n    ENNReal.mul_rpow_of_nonneg _ _ ENNReal.toReal_nonneg, ← ENNReal.rpow_mul,\n    inv_mul_cancel₀ (ENNReal.toReal_pos hp hp').ne.symm, ENNReal.rpow_one, ← setLIntegral_const,\n    ← lintegral_indicator hs]\n  refine lintegral_mono_ae ?_\n  filter_upwards [hf] with x hx\n  by_cases hxs : x ∈ s\n  · simp only [Set.indicator_of_mem, hxs, true_implies] at hx ⊢\n    gcongr\n    rwa [coe_le_enorm]\n  · simp [Set.indicator_of_not_mem hxs]\n\n"}
{"name":"MeasureTheory.eLpNorm_conj","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → 𝕜\np : ENNReal\nμ : MeasureTheory.Measure α\n⊢ Eq (MeasureTheory.eLpNorm ((starRingEnd (α → 𝕜)) f) p μ) (MeasureTheory.eLpNorm f p μ)","decl":"@[simp] lemma eLpNorm_conj (f : α → 𝕜) (p : ℝ≥0∞) (μ : Measure α) :\n    eLpNorm (conj f) p μ = eLpNorm f p μ := by simp [← eLpNorm_norm]\n\n"}
{"name":"MeasureTheory.Memℒp.re","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → 𝕜\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun x => RCLike.re (f x)) p μ","decl":"theorem Memℒp.re (hf : Memℒp f p μ) : Memℒp (fun x => RCLike.re (f x)) p μ := by\n  have : ∀ x, ‖RCLike.re (f x)‖ ≤ 1 * ‖f x‖ := by\n    intro x\n    rw [one_mul]\n    exact RCLike.norm_re_le_norm (f x)\n  refine hf.of_le_mul ?_ (Eventually.of_forall this)\n  exact RCLike.continuous_re.comp_aestronglyMeasurable hf.1\n\n"}
{"name":"MeasureTheory.Memℒp.im","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → 𝕜\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Memℒp (fun x => RCLike.im (f x)) p μ","decl":"theorem Memℒp.im (hf : Memℒp f p μ) : Memℒp (fun x => RCLike.im (f x)) p μ := by\n  have : ∀ x, ‖RCLike.im (f x)‖ ≤ 1 * ‖f x‖ := by\n    intro x\n    rw [one_mul]\n    exact RCLike.norm_im_le_norm (f x)\n  refine hf.of_le_mul ?_ (Eventually.of_forall this)\n  exact RCLike.continuous_im.comp_aestronglyMeasurable hf.1\n\n"}
{"name":"MeasureTheory.ae_bdd_liminf_atTop_rpow_of_eLpNorm_bdd","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nR : NNReal\np : ENNReal\nf : Nat → α → E\nhfmeas : ∀ (n : Nat), Measurable (f n)\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) p μ) ↑R\n⊢ Filter.Eventually (fun x => LT.lt (Filter.liminf (fun n => HPow.hPow (ENorm.enorm (f n x)) p.toReal) Filter.atTop) Top.top) (MeasureTheory.ae μ)","decl":"theorem ae_bdd_liminf_atTop_rpow_of_eLpNorm_bdd {p : ℝ≥0∞} {f : ℕ → α → E}\n    (hfmeas : ∀ n, Measurable (f n)) (hbdd : ∀ n, eLpNorm (f n) p μ ≤ R) :\n    ∀ᵐ x ∂μ, liminf (fun n => ((‖f n x‖ₑ) ^ p.toReal : ℝ≥0∞)) atTop < ∞ := by\n  by_cases hp0 : p.toReal = 0\n  · simp only [hp0, ENNReal.rpow_zero]\n    filter_upwards with _\n    rw [liminf_const (1 : ℝ≥0∞)]\n    exact ENNReal.one_lt_top\n  have hp : p ≠ 0 := fun h => by simp [h] at hp0\n  have hp' : p ≠ ∞ := fun h => by simp [h] at hp0\n  refine\n    ae_lt_top (.liminf fun n => (hfmeas n).nnnorm.coe_nnreal_ennreal.pow_const p.toReal)\n      (lt_of_le_of_lt\n          (lintegral_liminf_le fun n => (hfmeas n).nnnorm.coe_nnreal_ennreal.pow_const p.toReal)\n          (lt_of_le_of_lt ?_\n            (ENNReal.rpow_lt_top_of_nonneg ENNReal.toReal_nonneg ENNReal.coe_ne_top :\n              (R : ℝ≥0∞) ^ p.toReal < ∞))).ne\n  simp_rw [eLpNorm_eq_lintegral_rpow_enorm hp hp', one_div] at hbdd\n  simp_rw [liminf_eq, eventually_atTop]\n  exact\n    sSup_le fun b ⟨a, ha⟩ =>\n      (ha a le_rfl).trans ((ENNReal.rpow_inv_le_iff (ENNReal.toReal_pos hp hp')).1 (hbdd _))\n\n"}
{"name":"MeasureTheory.ae_bdd_liminf_atTop_of_eLpNorm_bdd","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nE : Type u_3\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup E\ninst✝¹ : MeasurableSpace E\ninst✝ : OpensMeasurableSpace E\nR : NNReal\np : ENNReal\nhp : Ne p 0\nf : Nat → α → E\nhfmeas : ∀ (n : Nat), Measurable (f n)\nhbdd : ∀ (n : Nat), LE.le (MeasureTheory.eLpNorm (f n) p μ) ↑R\n⊢ Filter.Eventually (fun x => LT.lt (Filter.liminf (fun n => ENorm.enorm (f n x)) Filter.atTop) Top.top) (MeasureTheory.ae μ)","decl":"theorem ae_bdd_liminf_atTop_of_eLpNorm_bdd {p : ℝ≥0∞} (hp : p ≠ 0) {f : ℕ → α → E}\n    (hfmeas : ∀ n, Measurable (f n)) (hbdd : ∀ n, eLpNorm (f n) p μ ≤ R) :\n    ∀ᵐ x ∂μ, liminf (fun n => (‖f n x‖ₑ)) atTop < ∞ := by\n  by_cases hp' : p = ∞\n  · subst hp'\n    simp_rw [eLpNorm_exponent_top] at hbdd\n    have : ∀ n, ∀ᵐ x ∂μ, (‖f n x‖ₑ) < R + 1 := fun n =>\n      ae_lt_of_essSup_lt\n        (lt_of_le_of_lt (hbdd n) <| ENNReal.lt_add_right ENNReal.coe_ne_top one_ne_zero)\n    rw [← ae_all_iff] at this\n    filter_upwards [this] with x hx using lt_of_le_of_lt\n        (liminf_le_of_frequently_le' <| Frequently.of_forall fun n => (hx n).le)\n        (ENNReal.add_lt_top.2 ⟨ENNReal.coe_lt_top, ENNReal.one_lt_top⟩)\n  filter_upwards [ae_bdd_liminf_atTop_rpow_of_eLpNorm_bdd hfmeas hbdd] with x hx\n  have hppos : 0 < p.toReal := ENNReal.toReal_pos hp hp'\n  have :\n    liminf (fun n => (‖f n x‖ₑ) ^ p.toReal) atTop =\n      liminf (fun n => (‖f n x‖ₑ)) atTop ^ p.toReal := by\n    change\n      liminf (fun n => ENNReal.orderIsoRpow p.toReal hppos (‖f n x‖ₑ)) atTop =\n        ENNReal.orderIsoRpow p.toReal hppos (liminf (fun n => (‖f n x‖ₑ)) atTop)\n    refine (OrderIso.liminf_apply (ENNReal.orderIsoRpow p.toReal _) ?_ ?_ ?_ ?_).symm <;>\n      isBoundedDefault\n  rw [this] at hx\n  rw [← ENNReal.rpow_one (liminf (‖f · x‖ₑ) atTop), ← mul_inv_cancel₀ hppos.ne.symm,\n    ENNReal.rpow_mul]\n  exact ENNReal.rpow_lt_top_of_nonneg (inv_nonneg.2 hppos.le) hx.ne\n\n"}
{"name":"Continuous.memℒp_top_of_hasCompactSupport","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"E : Type u_3\ninst✝³ : NormedAddCommGroup E\nX : Type u_6\ninst✝² : TopologicalSpace X\ninst✝¹ : MeasurableSpace X\ninst✝ : OpensMeasurableSpace X\nf : X → E\nhf : Continuous f\nh'f : HasCompactSupport f\nμ : MeasureTheory.Measure X\n⊢ MeasureTheory.Memℒp f Top.top μ","decl":"/-- A continuous function with compact support belongs to `L^∞`.\nSee `Continuous.memℒp_of_hasCompactSupport` for a version for `L^p`. -/\ntheorem _root_.Continuous.memℒp_top_of_hasCompactSupport\n    {X : Type*} [TopologicalSpace X] [MeasurableSpace X] [OpensMeasurableSpace X]\n    {f : X → E} (hf : Continuous f) (h'f : HasCompactSupport f) (μ : Measure X) : Memℒp f ⊤ μ := by\n  borelize E\n  rcases hf.bounded_above_of_compact_support h'f with ⟨C, hC⟩\n  apply memℒp_top_of_bound ?_ C (Filter.Eventually.of_forall hC)\n  exact (hf.stronglyMeasurable_of_hasCompactSupport h'f).aestronglyMeasurable\n\n"}
{"name":"MeasureTheory.Memℒp.exists_eLpNorm_indicator_compl_lt","module":"Mathlib.MeasureTheory.Function.LpSeminorm.Basic","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\np : ENNReal\nμ : MeasureTheory.Measure α\nβ : Type u_6\ninst✝ : NormedAddCommGroup β\nhp_top : Ne p Top.top\nf : α → β\nhf : MeasureTheory.Memℒp f p μ\nε : ENNReal\nhε : Ne ε 0\n⊢ Exists fun s => And (MeasurableSet s) (And (LT.lt (μ s) Top.top) (LT.lt (MeasureTheory.eLpNorm ((HasCompl.compl s).indicator f) p μ) ε))","decl":"/-- A single function that is `Memℒp f p μ` is tight with respect to `μ`. -/\ntheorem Memℒp.exists_eLpNorm_indicator_compl_lt {β : Type*} [NormedAddCommGroup β] (hp_top : p ≠ ∞)\n    {f : α → β} (hf : Memℒp f p μ) {ε : ℝ≥0∞} (hε : ε ≠ 0) :\n    ∃ s : Set α, MeasurableSet s ∧ μ s < ∞ ∧ eLpNorm (sᶜ.indicator f) p μ < ε := by\n  rcases eq_or_ne p 0 with rfl | hp₀\n  · use ∅; simp [pos_iff_ne_zero.2 hε] -- first take care of `p = 0`\n  · obtain ⟨s, hsm, hs, hε⟩ :\n        ∃ s, MeasurableSet s ∧ μ s < ∞ ∧ ∫⁻ a in sᶜ, (‖f a‖ₑ) ^ p.toReal ∂μ < ε ^ p.toReal := by\n      apply exists_setLintegral_compl_lt\n      · exact ((eLpNorm_lt_top_iff_lintegral_rpow_nnnorm_lt_top hp₀ hp_top).1 hf.2).ne\n      · simp [*]\n    refine ⟨s, hsm, hs, ?_⟩\n    rwa [eLpNorm_indicator_eq_eLpNorm_restrict hsm.compl,\n      eLpNorm_eq_lintegral_rpow_enorm hp₀ hp_top, one_div, ENNReal.rpow_inv_lt_iff]\n    simp [ENNReal.toReal_pos, *]\n\n"}
