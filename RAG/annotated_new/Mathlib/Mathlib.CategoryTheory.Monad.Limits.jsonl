{"name":"CategoryTheory.Monad.ForgetCreatesLimits.γ_app","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nj : J\n⊢ Eq ((CategoryTheory.Monad.ForgetCreatesLimits.γ D).app j) (D.obj j).a","decl":"/-- (Impl) The natural transformation used to define the new cone -/\n@[simps]\ndef γ : D ⋙ T.forget ⋙ ↑T ⟶ D ⋙ T.forget where app j := (D.obj j).a\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesLimits.newCone_π_app","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nX : J\n⊢ Eq ((CategoryTheory.Monad.ForgetCreatesLimits.newCone D c).π.app X) (CategoryTheory.CategoryStruct.comp (T.map (c.π.app X)) (D.obj X).a)","decl":"/-- (Impl) This new cone is used to construct the algebra structure -/\n@[simps! π_app]\ndef newCone : Cone (D ⋙ forget T) where\n  pt := T.obj c.pt\n  π := (Functor.constComp _ _ (T : C ⥤ C)).inv ≫ whiskerRight c.π (T : C ⥤ C) ≫ γ D\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesLimits.conePoint_a","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesLimits.conePoint D c t).a (t.lift (CategoryTheory.Monad.ForgetCreatesLimits.newCone D c))","decl":"/-- The algebra structure which will be the apex of the new limit cone for `D`. -/\n@[simps]\ndef conePoint : Algebra T where\n  A := c.pt\n  a := t.lift (newCone D c)\n  unit :=\n    t.hom_ext fun j => by\n      rw [Category.assoc, t.fac, newCone_π_app, ← T.η.naturality_assoc, Functor.id_map,\n        (D.obj j).unit]\n      dsimp; simp\n  -- See library note [dsimp, simp]\n  assoc :=\n    t.hom_ext fun j => by\n      rw [Category.assoc, Category.assoc, t.fac (newCone D c), newCone_π_app, ←\n        Functor.map_comp_assoc, t.fac (newCone D c), newCone_π_app, ← T.μ.naturality_assoc,\n        (D.obj j).assoc, Functor.map_comp, Category.assoc]\n      rfl\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesLimits.conePoint_A","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesLimits.conePoint D c t).A c.pt","decl":"/-- The algebra structure which will be the apex of the new limit cone for `D`. -/\n@[simps]\ndef conePoint : Algebra T where\n  A := c.pt\n  a := t.lift (newCone D c)\n  unit :=\n    t.hom_ext fun j => by\n      rw [Category.assoc, t.fac, newCone_π_app, ← T.η.naturality_assoc, Functor.id_map,\n        (D.obj j).unit]\n      dsimp; simp\n  -- See library note [dsimp, simp]\n  assoc :=\n    t.hom_ext fun j => by\n      rw [Category.assoc, Category.assoc, t.fac (newCone D c), newCone_π_app, ←\n        Functor.map_comp_assoc, t.fac (newCone D c), newCone_π_app, ← T.μ.naturality_assoc,\n        (D.obj j).assoc, Functor.map_comp, Category.assoc]\n      rfl\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedCone_π_app_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\nj : J\n⊢ Eq ((CategoryTheory.Monad.ForgetCreatesLimits.liftedCone D c t).π.app j).f (c.π.app j)","decl":"/-- (Impl) Construct the lifted cone in `Algebra T` which will be limiting. -/\n@[simps]\ndef liftedCone : Cone D where\n  pt := conePoint D c t\n  π :=\n    { app := fun j => { f := c.π.app j }\n      naturality := fun X Y f => by\n        ext1\n        dsimp\n        erw [c.w f]\n        simp }\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedCone_pt","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesLimits.liftedCone D c t).pt (CategoryTheory.Monad.ForgetCreatesLimits.conePoint D c t)","decl":"/-- (Impl) Construct the lifted cone in `Algebra T` which will be limiting. -/\n@[simps]\ndef liftedCone : Cone D where\n  pt := conePoint D c t\n  π :=\n    { app := fun j => { f := c.π.app j }\n      naturality := fun X Y f => by\n        ext1\n        dsimp\n        erw [c.w f]\n        simp }\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesLimits.liftedConeIsLimit_lift_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ns : CategoryTheory.Limits.Cone D\n⊢ Eq ((CategoryTheory.Monad.ForgetCreatesLimits.liftedConeIsLimit D c t).lift s).f (t.lift (T.forget.mapCone s))","decl":"/-- (Impl) Prove that the lifted cone is limiting. -/\n@[simps]\ndef liftedConeIsLimit : IsLimit (liftedCone D c t) where\n  lift s :=\n    { f := t.lift ((forget T).mapCone s)\n      h :=\n        t.hom_ext fun j => by\n          dsimp\n          rw [Category.assoc, Category.assoc, t.fac, newCone_π_app, ← Functor.map_comp_assoc,\n            t.fac, Functor.mapCone_π_app]\n          apply (s.π.app j).h }\n  uniq s m J := by\n    ext1\n    apply t.hom_ext\n    intro j\n    simpa [t.fac ((forget T).mapCone s) j] using congr_arg Algebra.Hom.f (J j)\n\n"}
{"name":"CategoryTheory.Monad.hasLimit_of_comp_forget_hasLimit","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\ninst✝ : CategoryTheory.Limits.HasLimit (D.comp T.forget)\n⊢ CategoryTheory.Limits.HasLimit D","decl":"/-- `D ⋙ forget T` has a limit, then `D` has a limit. -/\ntheorem hasLimit_of_comp_forget_hasLimit (D : J ⥤ Algebra T) [HasLimit (D ⋙ forget T)] :\n    HasLimit D :=\n  hasLimit_of_created D (forget T)\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.γ_app","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nj : J\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesColimits.γ.app j) (D.obj j).a","decl":"/-- (Impl)\nThe natural transformation given by the algebra structure maps, used to construct a cocone `c` with\npoint `colimit (D ⋙ forget T)`.\n -/\n@[simps]\ndef γ : (D ⋙ forget T) ⋙ ↑T ⟶ D ⋙ forget T where app j := (D.obj j).a\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.newCocone_ι","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesColimits.newCocone c).ι (CategoryTheory.CategoryStruct.comp CategoryTheory.Monad.ForgetCreatesColimits.γ c.ι)","decl":"/-- (Impl)\nA cocone for the diagram `(D ⋙ forget T) ⋙ T` found by composing the natural transformation `γ`\nwith the colimiting cocone for `D ⋙ forget T`.\n-/\n@[simps]\ndef newCocone : Cocone ((D ⋙ forget T) ⋙ (T : C ⥤ C)) where\n  pt := c.pt\n  ι := γ ≫ c.ι\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.newCocone_pt","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesColimits.newCocone c).pt c.pt","decl":"/-- (Impl)\nA cocone for the diagram `(D ⋙ forget T) ⋙ T` found by composing the natural transformation `γ`\nwith the colimiting cocone for `D ⋙ forget T`.\n-/\n@[simps]\ndef newCocone : Cocone ((D ⋙ forget T) ⋙ (T : C ⥤ C)) where\n  pt := c.pt\n  ι := γ ≫ c.ι\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.commuting","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ninst✝ : CategoryTheory.Limits.PreservesColimit (D.comp T.forget) T.toFunctor\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.map (c.ι.app j)) (CategoryTheory.Monad.ForgetCreatesColimits.lambda c t)) (CategoryTheory.CategoryStruct.comp (D.obj j).a (c.ι.app j))","decl":"/-- (Impl) The key property defining the map `λ : TL ⟶ L`. -/\ntheorem commuting (j : J) : (T : C ⥤ C).map (c.ι.app j) ≫ lambda c t = (D.obj j).a ≫ c.ι.app j :=\n  (isColimitOfPreserves _ t).fac (newCocone c) j\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.coconePoint_a","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ninst✝ : CategoryTheory.Limits.PreservesColimit (D.comp T.forget) T.toFunctor\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesColimits.coconePoint c t).a (CategoryTheory.Monad.ForgetCreatesColimits.lambda c t)","decl":"/-- (Impl)\nConstruct the colimiting algebra from the map `λ : TL ⟶ L` given by `lambda`. We are required to\nshow it satisfies the two algebra laws, which follow from the algebra laws for the image of `D` and\nour `commuting` lemma.\n-/\n@[simps]\nnoncomputable def coconePoint : Algebra T where\n  A := c.pt\n  a := lambda c t\n  unit := by\n    apply t.hom_ext\n    intro j\n    rw [show c.ι.app j ≫ T.η.app c.pt ≫ _ = T.η.app (D.obj j).A ≫ _ ≫ _ from\n        T.η.naturality_assoc _ _,\n      commuting, Algebra.unit_assoc (D.obj j)]\n    dsimp; simp\n  -- See library note [dsimp, simp]\n  assoc := by\n    refine (isColimitOfPreserves _ (isColimitOfPreserves _ t)).hom_ext fun j => ?_\n    rw [Functor.mapCocone_ι_app, Functor.mapCocone_ι_app,\n      show (T : C ⥤ C).map ((T : C ⥤ C).map _) ≫ _ ≫ _ = _ from T.μ.naturality_assoc _ _, ←\n      Functor.map_comp_assoc, commuting, Functor.map_comp, Category.assoc, commuting]\n    apply (D.obj j).assoc_assoc _\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.coconePoint_A","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ninst✝ : CategoryTheory.Limits.PreservesColimit (D.comp T.forget) T.toFunctor\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesColimits.coconePoint c t).A c.pt","decl":"/-- (Impl)\nConstruct the colimiting algebra from the map `λ : TL ⟶ L` given by `lambda`. We are required to\nshow it satisfies the two algebra laws, which follow from the algebra laws for the image of `D` and\nour `commuting` lemma.\n-/\n@[simps]\nnoncomputable def coconePoint : Algebra T where\n  A := c.pt\n  a := lambda c t\n  unit := by\n    apply t.hom_ext\n    intro j\n    rw [show c.ι.app j ≫ T.η.app c.pt ≫ _ = T.η.app (D.obj j).A ≫ _ ≫ _ from\n        T.η.naturality_assoc _ _,\n      commuting, Algebra.unit_assoc (D.obj j)]\n    dsimp; simp\n  -- See library note [dsimp, simp]\n  assoc := by\n    refine (isColimitOfPreserves _ (isColimitOfPreserves _ t)).hom_ext fun j => ?_\n    rw [Functor.mapCocone_ι_app, Functor.mapCocone_ι_app,\n      show (T : C ⥤ C).map ((T : C ⥤ C).map _) ≫ _ ≫ _ = _ from T.μ.naturality_assoc _ _, ←\n      Functor.map_comp_assoc, commuting, Functor.map_comp, Category.assoc, commuting]\n    apply (D.obj j).assoc_assoc _\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone_ι_app_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ninst✝ : CategoryTheory.Limits.PreservesColimit (D.comp T.forget) T.toFunctor\nj : J\n⊢ Eq ((CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone c t).ι.app j).f (c.ι.app j)","decl":"/-- (Impl) Construct the lifted cocone in `Algebra T` which will be colimiting. -/\n@[simps]\nnoncomputable def liftedCocone : Cocone D where\n  pt := coconePoint c t\n  ι :=\n    { app := fun j =>\n        { f := c.ι.app j\n          h := commuting _ _ _ }\n      naturality := fun A B f => by\n        ext1\n        dsimp\n        rw [comp_id]\n        apply c.w }\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone_pt","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ninst✝ : CategoryTheory.Limits.PreservesColimit (D.comp T.forget) T.toFunctor\n⊢ Eq (CategoryTheory.Monad.ForgetCreatesColimits.liftedCocone c t).pt (CategoryTheory.Monad.ForgetCreatesColimits.coconePoint c t)","decl":"/-- (Impl) Construct the lifted cocone in `Algebra T` which will be colimiting. -/\n@[simps]\nnoncomputable def liftedCocone : Cocone D where\n  pt := coconePoint c t\n  ι :=\n    { app := fun j =>\n        { f := c.ι.app j\n          h := commuting _ _ _ }\n      naturality := fun A B f => by\n        ext1\n        dsimp\n        rw [comp_id]\n        apply c.w }\n\n"}
{"name":"CategoryTheory.Monad.ForgetCreatesColimits.liftedCoconeIsColimit_desc_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nD : CategoryTheory.Functor J T.Algebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ninst✝ : CategoryTheory.Limits.PreservesColimit (D.comp T.forget) T.toFunctor\ns : CategoryTheory.Limits.Cocone D\n⊢ Eq ((CategoryTheory.Monad.ForgetCreatesColimits.liftedCoconeIsColimit c t).desc s).f (t.desc (T.forget.mapCocone s))","decl":"/-- (Impl) Prove that the lifted cocone is colimiting. -/\n@[simps]\nnoncomputable def liftedCoconeIsColimit : IsColimit (liftedCocone c t) where\n  desc s :=\n    { f := t.desc ((forget T).mapCocone s)\n      h :=\n        (isColimitOfPreserves (T : C ⥤ C) t).hom_ext fun j => by\n          dsimp\n          rw [← Functor.map_comp_assoc, ← Category.assoc, t.fac, commuting, Category.assoc, t.fac]\n          apply Algebra.Hom.h }\n  uniq s m J := by\n    ext1\n    apply t.hom_ext\n    intro j\n    simpa using congr_arg Algebra.Hom.f (J j)\n\n"}
{"name":"CategoryTheory.Monad.forget_creates_colimits_of_monad_preserves","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.PreservesColimitsOfShape J T.toFunctor\nD : CategoryTheory.Functor J T.Algebra\ninst✝ : CategoryTheory.Limits.HasColimit (D.comp T.forget)\n⊢ CategoryTheory.Limits.HasColimit D","decl":"/-- For `D : J ⥤ Algebra T`, `D ⋙ forget T` has a colimit, then `D` has a colimit provided colimits\nof shape `J` are preserved by `T`.\n-/\ntheorem forget_creates_colimits_of_monad_preserves [PreservesColimitsOfShape J (T : C ⥤ C)]\n    (D : J ⥤ Algebra T) [HasColimit (D ⋙ forget T)] : HasColimit D :=\n  hasColimit_of_created D (forget T)\n\n"}
{"name":"CategoryTheory.comp_comparison_forget_hasLimit","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.MonadicRightAdjoint R\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp R)\n⊢ CategoryTheory.Limits.HasLimit ((F.comp (CategoryTheory.Monad.comparison (CategoryTheory.monadicAdjunction R))).comp (CategoryTheory.monadicAdjunction R).toMonad.forget)","decl":"instance comp_comparison_forget_hasLimit (F : J ⥤ D) (R : D ⥤ C) [MonadicRightAdjoint R]\n    [HasLimit (F ⋙ R)] :\n    HasLimit ((F ⋙ Monad.comparison (monadicAdjunction R)) ⋙ Monad.forget _) :=\n  @hasLimitOfIso _ _ _ _ (F ⋙ R) _ _\n    (isoWhiskerLeft F (Monad.comparisonForget (monadicAdjunction R)).symm)\n\n"}
{"name":"CategoryTheory.comp_comparison_hasLimit","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.MonadicRightAdjoint R\ninst✝ : CategoryTheory.Limits.HasLimit (F.comp R)\n⊢ CategoryTheory.Limits.HasLimit (F.comp (CategoryTheory.Monad.comparison (CategoryTheory.monadicAdjunction R)))","decl":"instance comp_comparison_hasLimit (F : J ⥤ D) (R : D ⥤ C) [MonadicRightAdjoint R]\n    [HasLimit (F ⋙ R)] : HasLimit (F ⋙ Monad.comparison (monadicAdjunction R)) :=\n  Monad.hasLimit_of_comp_forget_hasLimit (F ⋙ Monad.comparison (monadicAdjunction R))\n\n"}
{"name":"CategoryTheory.hasLimit_of_reflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Limits.HasLimit (F.comp R)\ninst✝ : CategoryTheory.Reflective R\n⊢ CategoryTheory.Limits.HasLimit F","decl":"theorem hasLimit_of_reflective (F : J ⥤ D) (R : D ⥤ C) [HasLimit (F ⋙ R)] [Reflective R] :\n    HasLimit F :=\n  haveI := monadicCreatesLimits.{v, u} R\n  hasLimit_of_created F R\n\n"}
{"name":"CategoryTheory.hasLimitsOfShape_of_reflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfShape J C\nR : CategoryTheory.Functor D C\ninst✝ : CategoryTheory.Reflective R\n⊢ CategoryTheory.Limits.HasLimitsOfShape J D","decl":"/-- If `C` has limits of shape `J` then any reflective subcategory has limits of shape `J`. -/\ntheorem hasLimitsOfShape_of_reflective [HasLimitsOfShape J C] (R : D ⥤ C) [Reflective R] :\n    HasLimitsOfShape J D :=\n  ⟨fun F => hasLimit_of_reflective F R⟩\n\n"}
{"name":"CategoryTheory.hasLimits_of_reflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Limits.HasLimitsOfSize.{v, u, v₁, u₁} C\ninst✝ : CategoryTheory.Reflective R\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v, u, v₂, u₂} D","decl":"/-- If `C` has limits then any reflective subcategory has limits. -/\ntheorem hasLimits_of_reflective (R : D ⥤ C) [HasLimitsOfSize.{v, u} C] [Reflective R] :\n    HasLimitsOfSize.{v, u} D :=\n  ⟨fun _ => hasLimitsOfShape_of_reflective R⟩\n\n"}
{"name":"CategoryTheory.hasColimitsOfShape_of_reflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Reflective R\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J D","decl":"/-- If `C` has colimits of shape `J` then any reflective subcategory has colimits of shape `J`. -/\ntheorem hasColimitsOfShape_of_reflective (R : D ⥤ C) [Reflective R] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J D where\n  has_colimit := fun F => by\n      let c := (monadicLeftAdjoint R).mapCocone (colimit.cocone (F ⋙ R))\n      letI : PreservesColimitsOfShape J _ :=\n        (monadicAdjunction R).leftAdjoint_preservesColimits.1\n      let t : IsColimit c := isColimitOfPreserves (monadicLeftAdjoint R) (colimit.isColimit _)\n      apply HasColimit.mk ⟨_, (IsColimit.precomposeInvEquiv _ _).symm t⟩\n      apply\n        (isoWhiskerLeft F (asIso (monadicAdjunction R).counit) :) ≪≫ F.rightUnitor\n\n"}
{"name":"CategoryTheory.hasColimits_of_reflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Reflective R\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v, u, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v, u, v₂, u₂} D","decl":"/-- If `C` has colimits then any reflective subcategory has colimits. -/\ntheorem hasColimits_of_reflective (R : D ⥤ C) [Reflective R] [HasColimitsOfSize.{v, u} C] :\n    HasColimitsOfSize.{v, u} D :=\n  ⟨fun _ => hasColimitsOfShape_of_reflective R⟩\n\n"}
{"name":"CategoryTheory.leftAdjoint_preservesTerminal_of_reflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝ : CategoryTheory.Reflective R\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{v + 1}) (CategoryTheory.monadicLeftAdjoint R)","decl":"/-- The reflector always preserves terminal objects. Note this in general doesn't apply to any other\nlimit.\n-/\nlemma leftAdjoint_preservesTerminal_of_reflective (R : D ⥤ C) [Reflective R] :\n    PreservesLimitsOfShape (Discrete.{v} PEmpty) (monadicLeftAdjoint R) where\n  preservesLimit {K} := by\n    let F := Functor.empty.{v} D\n    letI : PreservesLimit (F ⋙ R) (monadicLeftAdjoint R) := by\n      constructor\n      intro c h\n      haveI : HasLimit (F ⋙ R) := ⟨⟨⟨c, h⟩⟩⟩\n      haveI : HasLimit F := hasLimit_of_reflective F R\n      constructor\n      apply isLimitChangeEmptyCone D (limit.isLimit F)\n      apply (asIso ((monadicAdjunction R).counit.app _)).symm.trans\n      apply (monadicLeftAdjoint R).mapIso\n      letI := monadicCreatesLimits.{v, v} R\n      let A := CategoryTheory.preservesLimit_of_createsLimit_and_hasLimit F R\n      apply (isLimitOfPreserves _ (limit.isLimit F)).conePointUniqueUpToIso h\n    apply preservesLimit_of_iso_diagram _ (Functor.emptyExt (F ⋙ R) _)\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.γ_app","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nj : J\n⊢ Eq ((CategoryTheory.Comonad.ForgetCreatesColimits'.γ D).app j) (D.obj j).a","decl":"/-- (Impl) The natural transformation used to define the new cocone -/\n@[simps]\ndef γ : D ⋙ T.forget ⟶ D ⋙ T.forget ⋙ ↑T  where app j := (D.obj j).a\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.newCocone_ι_app","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nX : J\n⊢ Eq ((CategoryTheory.Comonad.ForgetCreatesColimits'.newCocone D c).ι.app X) (CategoryTheory.CategoryStruct.comp (D.obj X).a (T.map (c.ι.app X)))","decl":"/-- (Impl) This new cocone is used to construct the coalgebra structure -/\n@[simps! ι_app]\ndef newCocone : Cocone (D ⋙ forget T) where\n  pt := T.obj c.pt\n  ι := γ D ≫ whiskerRight c.ι (T : C ⥤ C) ≫ (Functor.constComp J _ (T : C ⥤ C)).hom\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.coconePoint_A","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesColimits'.coconePoint D c t).A c.pt","decl":"/-- The coalgebra structure which will be the point of the new colimit cone for `D`. -/\n@[simps]\ndef coconePoint : Coalgebra T where\n  A := c.pt\n  a := t.desc (newCocone D c)\n  counit := t.hom_ext fun j ↦ by\n    simp only [Functor.comp_obj, forget_obj, Functor.id_obj, Functor.const_obj_obj,\n      IsColimit.fac_assoc, newCocone_ι_app, assoc, NatTrans.naturality, Functor.id_map, comp_id]\n    rw [← Category.assoc, (D.obj j).counit, Category.id_comp]\n  coassoc := t.hom_ext fun j ↦ by\n    simp only [Functor.comp_obj, forget_obj, Functor.const_obj_obj, IsColimit.fac_assoc,\n      newCocone_ι_app, assoc, NatTrans.naturality, Functor.comp_map]\n    rw [← Category.assoc, (D.obj j).coassoc, ← Functor.map_comp, t.fac (newCocone D c) j,\n      newCocone_ι_app, Functor.map_comp, assoc]\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.coconePoint_a","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesColimits'.coconePoint D c t).a (t.desc (CategoryTheory.Comonad.ForgetCreatesColimits'.newCocone D c))","decl":"/-- The coalgebra structure which will be the point of the new colimit cone for `D`. -/\n@[simps]\ndef coconePoint : Coalgebra T where\n  A := c.pt\n  a := t.desc (newCocone D c)\n  counit := t.hom_ext fun j ↦ by\n    simp only [Functor.comp_obj, forget_obj, Functor.id_obj, Functor.const_obj_obj,\n      IsColimit.fac_assoc, newCocone_ι_app, assoc, NatTrans.naturality, Functor.id_map, comp_id]\n    rw [← Category.assoc, (D.obj j).counit, Category.id_comp]\n  coassoc := t.hom_ext fun j ↦ by\n    simp only [Functor.comp_obj, forget_obj, Functor.const_obj_obj, IsColimit.fac_assoc,\n      newCocone_ι_app, assoc, NatTrans.naturality, Functor.comp_map]\n    rw [← Category.assoc, (D.obj j).coassoc, ← Functor.map_comp, t.fac (newCocone D c) j,\n      newCocone_ι_app, Functor.map_comp, assoc]\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.liftedCocone_pt","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesColimits'.liftedCocone D c t).pt (CategoryTheory.Comonad.ForgetCreatesColimits'.coconePoint D c t)","decl":"/-- (Impl) Construct the lifted cocone in `Coalgebra T` which will be colimiting. -/\n@[simps]\ndef liftedCocone : Cocone D where\n  pt := coconePoint D c t\n  ι :=\n    { app := fun j => { f := c.ι.app j }\n      naturality := fun X Y f => by\n        ext1\n        dsimp\n        erw [c.w f]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.liftedCocone_ι_app_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\nj : J\n⊢ Eq ((CategoryTheory.Comonad.ForgetCreatesColimits'.liftedCocone D c t).ι.app j).f (c.ι.app j)","decl":"/-- (Impl) Construct the lifted cocone in `Coalgebra T` which will be colimiting. -/\n@[simps]\ndef liftedCocone : Cocone D where\n  pt := coconePoint D c t\n  ι :=\n    { app := fun j => { f := c.ι.app j }\n      naturality := fun X Y f => by\n        ext1\n        dsimp\n        erw [c.w f]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesColimits'.liftedCoconeIsColimit_desc_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cocone (D.comp T.forget)\nt : CategoryTheory.Limits.IsColimit c\ns : CategoryTheory.Limits.Cocone D\n⊢ Eq ((CategoryTheory.Comonad.ForgetCreatesColimits'.liftedCoconeIsColimit D c t).desc s).f (t.desc (T.forget.mapCocone s))","decl":"/-- (Impl) Prove that the lifted cocone is colimiting. -/\n@[simps]\ndef liftedCoconeIsColimit : IsColimit (liftedCocone D c t) where\n  desc s :=\n    { f := t.desc ((forget T).mapCocone s)\n      h :=\n        t.hom_ext fun j => by\n          dsimp\n          rw [← Category.assoc, ← Category.assoc, t.fac, newCocone_ι_app, t.fac,\n            Functor.mapCocone_ι_app, Category.assoc, ← Functor.map_comp, t.fac]\n          apply (s.ι.app j).h }\n  uniq s m J := by\n    ext1\n    apply t.hom_ext\n    intro j\n    simpa [t.fac ((forget T).mapCocone s) j] using congr_arg Coalgebra.Hom.f (J j)\n\n"}
{"name":"CategoryTheory.Comonad.hasColimit_of_comp_forget_hasColimit","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\ninst✝ : CategoryTheory.Limits.HasColimit (D.comp T.forget)\n⊢ CategoryTheory.Limits.HasColimit D","decl":"/-- If `D ⋙ forget T` has a colimit, then `D` has a colimit. -/\ntheorem hasColimit_of_comp_forget_hasColimit (D : J ⥤ Coalgebra T) [HasColimit (D ⋙ forget T)] :\n    HasColimit D :=\n  hasColimit_of_created D (forget T)\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.γ_app","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nj : J\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesLimits'.γ.app j) (D.obj j).a","decl":"/-- (Impl)\nThe natural transformation given by the coalgebra structure maps, used to construct a cone `c` with\npoint `limit (D ⋙ forget T)`.\n -/\n@[simps]\ndef γ : D ⋙ forget T ⟶ (D ⋙ forget T) ⋙ ↑T where app j := (D.obj j).a\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.newCone_pt","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesLimits'.newCone c).pt c.pt","decl":"/-- (Impl)\nA cone for the diagram `(D ⋙ forget T) ⋙ T` found by composing the natural transformation `γ`\nwith the limiting cone for `D ⋙ forget T`.\n-/\n@[simps]\ndef newCone : Cone ((D ⋙ forget T) ⋙ (T : C ⥤ C)) where\n  pt := c.pt\n  π := c.π ≫ γ\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.newCone_π","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesLimits'.newCone c).π (CategoryTheory.CategoryStruct.comp c.π CategoryTheory.Comonad.ForgetCreatesLimits'.γ)","decl":"/-- (Impl)\nA cone for the diagram `(D ⋙ forget T) ⋙ T` found by composing the natural transformation `γ`\nwith the limiting cone for `D ⋙ forget T`.\n-/\n@[simps]\ndef newCone : Cone ((D ⋙ forget T) ⋙ (T : C ⥤ C)) where\n  pt := c.pt\n  π := c.π ≫ γ\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.commuting","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ninst✝ : CategoryTheory.Limits.PreservesLimit (D.comp T.forget) T.toFunctor\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Comonad.ForgetCreatesLimits'.lambda c t) (T.map (c.π.app j))) (CategoryTheory.CategoryStruct.comp (c.π.app j) (D.obj j).a)","decl":"/-- (Impl) The key property defining the map `λ : L ⟶ TL`. -/\ntheorem commuting (j : J) : lambda c t ≫ (T : C ⥤ C).map (c.π.app j) = c.π.app j ≫ (D.obj j).a :=\n  (isLimitOfPreserves _ t).fac (newCone c) j\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.conePoint_a","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ninst✝ : CategoryTheory.Limits.PreservesLimit (D.comp T.forget) T.toFunctor\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesLimits'.conePoint c t).a (CategoryTheory.Comonad.ForgetCreatesLimits'.lambda c t)","decl":"/-- (Impl)\nConstruct the limiting coalgebra from the map `λ : L ⟶ TL` given by `lambda`. We are required to\nshow it satisfies the two coalgebra laws, which follow from the coalgebra laws for the image of `D`\nand our `commuting` lemma.\n-/\n@[simps]\nnoncomputable def conePoint : Coalgebra T where\n  A := c.pt\n  a := lambda c t\n  counit := t.hom_ext fun j ↦ by\n    rw [assoc, ← show _ = _ ≫ c.π.app j from T.ε.naturality _, ← assoc, commuting, assoc]\n    simp [Coalgebra.counit (D.obj j)]\n  coassoc := by\n    refine (isLimitOfPreserves _ (isLimitOfPreserves _ t)).hom_ext fun j => ?_\n    rw [Functor.mapCone_π_app, Functor.mapCone_π_app, assoc,\n      ← show _ = _ ≫ T.map (T.map _) from T.δ.naturality _, assoc, ← Functor.map_comp, commuting,\n      Functor.map_comp, ← assoc, commuting]\n    simp only [Functor.comp_obj, forget_obj, Functor.const_obj_obj, assoc]\n    rw [(D.obj j).coassoc,  ← assoc, ← assoc, commuting]\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.conePoint_A","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ninst✝ : CategoryTheory.Limits.PreservesLimit (D.comp T.forget) T.toFunctor\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesLimits'.conePoint c t).A c.pt","decl":"/-- (Impl)\nConstruct the limiting coalgebra from the map `λ : L ⟶ TL` given by `lambda`. We are required to\nshow it satisfies the two coalgebra laws, which follow from the coalgebra laws for the image of `D`\nand our `commuting` lemma.\n-/\n@[simps]\nnoncomputable def conePoint : Coalgebra T where\n  A := c.pt\n  a := lambda c t\n  counit := t.hom_ext fun j ↦ by\n    rw [assoc, ← show _ = _ ≫ c.π.app j from T.ε.naturality _, ← assoc, commuting, assoc]\n    simp [Coalgebra.counit (D.obj j)]\n  coassoc := by\n    refine (isLimitOfPreserves _ (isLimitOfPreserves _ t)).hom_ext fun j => ?_\n    rw [Functor.mapCone_π_app, Functor.mapCone_π_app, assoc,\n      ← show _ = _ ≫ T.map (T.map _) from T.δ.naturality _, assoc, ← Functor.map_comp, commuting,\n      Functor.map_comp, ← assoc, commuting]\n    simp only [Functor.comp_obj, forget_obj, Functor.const_obj_obj, assoc]\n    rw [(D.obj j).coassoc,  ← assoc, ← assoc, commuting]\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.liftedCone_pt","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ninst✝ : CategoryTheory.Limits.PreservesLimit (D.comp T.forget) T.toFunctor\n⊢ Eq (CategoryTheory.Comonad.ForgetCreatesLimits'.liftedCone c t).pt (CategoryTheory.Comonad.ForgetCreatesLimits'.conePoint c t)","decl":"/-- (Impl) Construct the lifted cone in `Coalgebra T` which will be limiting. -/\n@[simps]\nnoncomputable def liftedCone : Cone D where\n  pt := conePoint c t\n  π :=\n    { app := fun j =>\n        { f := c.π.app j\n          h := commuting _ _ _ }\n      naturality := fun A B f => by\n        ext1\n        dsimp\n        rw [id_comp, ← c.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.liftedCone_π_app_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ninst✝ : CategoryTheory.Limits.PreservesLimit (D.comp T.forget) T.toFunctor\nj : J\n⊢ Eq ((CategoryTheory.Comonad.ForgetCreatesLimits'.liftedCone c t).π.app j).f (c.π.app j)","decl":"/-- (Impl) Construct the lifted cone in `Coalgebra T` which will be limiting. -/\n@[simps]\nnoncomputable def liftedCone : Cone D where\n  pt := conePoint c t\n  π :=\n    { app := fun j =>\n        { f := c.π.app j\n          h := commuting _ _ _ }\n      naturality := fun A B f => by\n        ext1\n        dsimp\n        rw [id_comp, ← c.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.Comonad.ForgetCreatesLimits'.liftedConeIsLimit_lift_f","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\nD : CategoryTheory.Functor J T.Coalgebra\nc : CategoryTheory.Limits.Cone (D.comp T.forget)\nt : CategoryTheory.Limits.IsLimit c\ninst✝ : CategoryTheory.Limits.PreservesLimit (D.comp T.forget) T.toFunctor\ns : CategoryTheory.Limits.Cone D\n⊢ Eq ((CategoryTheory.Comonad.ForgetCreatesLimits'.liftedConeIsLimit c t).lift s).f (t.lift (T.forget.mapCone s))","decl":"/-- (Impl) Prove that the lifted cone is limiting. -/\n@[simps]\nnoncomputable def liftedConeIsLimit : IsLimit (liftedCone c t) where\n  lift s :=\n    { f := t.lift ((forget T).mapCone s)\n      h :=\n        (isLimitOfPreserves (T : C ⥤ C) t).hom_ext fun j => by\n          dsimp\n          rw [Category.assoc, ← t.fac, Category.assoc, t.fac, commuting, ← assoc, ← assoc, t.fac,\n            assoc, ← Functor.map_comp, t.fac]\n          exact (s.π.app j).h }\n  uniq s m J := by\n    ext1\n    apply t.hom_ext\n    intro j\n    simpa using congr_arg Coalgebra.Hom.f (J j)\n\n"}
{"name":"CategoryTheory.Comonad.forget_creates_limits_of_comonad_preserves","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nT : CategoryTheory.Comonad C\ninst✝¹ : CategoryTheory.Limits.PreservesLimitsOfShape J T.toFunctor\nD : CategoryTheory.Functor J T.Coalgebra\ninst✝ : CategoryTheory.Limits.HasLimit (D.comp T.forget)\n⊢ CategoryTheory.Limits.HasLimit D","decl":"/-- For `D : J ⥤ Coalgebra T`, `D ⋙ forget T` has a limit, then `D` has a limit provided limits\nof shape `J` are preserved by `T`.\n-/\ntheorem forget_creates_limits_of_comonad_preserves [PreservesLimitsOfShape J (T : C ⥤ C)]\n    (D : J ⥤ Coalgebra T) [HasLimit (D ⋙ forget T)] : HasLimit D :=\n  hasLimit_of_created D (forget T)\n\n"}
{"name":"CategoryTheory.comp_comparison_forget_hasColimit","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.ComonadicLeftAdjoint R\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp R)\n⊢ CategoryTheory.Limits.HasColimit ((F.comp (CategoryTheory.Comonad.comparison (CategoryTheory.comonadicAdjunction R))).comp (CategoryTheory.comonadicAdjunction R).toComonad.forget)","decl":"instance comp_comparison_forget_hasColimit (F : J ⥤ D) (R : D ⥤ C) [ComonadicLeftAdjoint R]\n    [HasColimit (F ⋙ R)] :\n    HasColimit ((F ⋙ Comonad.comparison (comonadicAdjunction R)) ⋙ Comonad.forget _) :=\n  @hasColimitOfIso _ _ _ _ (F ⋙ R) _ _\n    (isoWhiskerLeft F (Comonad.comparisonForget (comonadicAdjunction R)).symm)\n\n"}
{"name":"CategoryTheory.comp_comparison_hasColimit","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.ComonadicLeftAdjoint R\ninst✝ : CategoryTheory.Limits.HasColimit (F.comp R)\n⊢ CategoryTheory.Limits.HasColimit (F.comp (CategoryTheory.Comonad.comparison (CategoryTheory.comonadicAdjunction R)))","decl":"instance comp_comparison_hasColimit (F : J ⥤ D) (R : D ⥤ C) [ComonadicLeftAdjoint R]\n    [HasColimit (F ⋙ R)] : HasColimit (F ⋙ Comonad.comparison (comonadicAdjunction R)) :=\n  Comonad.hasColimit_of_comp_forget_hasColimit (F ⋙ Comonad.comparison (comonadicAdjunction R))\n\n"}
{"name":"CategoryTheory.hasColimit_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Limits.HasColimit (F.comp R)\ninst✝ : CategoryTheory.Coreflective R\n⊢ CategoryTheory.Limits.HasColimit F","decl":"theorem hasColimit_of_coreflective (F : J ⥤ D) (R : D ⥤ C) [HasColimit (F ⋙ R)] [Coreflective R] :\n    HasColimit F :=\n  haveI := comonadicCreatesColimits.{v, u} R\n  hasColimit_of_created F R\n\n"}
{"name":"CategoryTheory.hasColimitsOfShape_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfShape J C\nR : CategoryTheory.Functor D C\ninst✝ : CategoryTheory.Coreflective R\n⊢ CategoryTheory.Limits.HasColimitsOfShape J D","decl":"/-- If `C` has colimits of shape `J` then any coreflective subcategory has colimits of shape `J`. -/\ntheorem hasColimitsOfShape_of_coreflective [HasColimitsOfShape J C] (R : D ⥤ C) [Coreflective R] :\n    HasColimitsOfShape J D :=\n  ⟨fun F => hasColimit_of_coreflective F R⟩\n\n"}
{"name":"CategoryTheory.hasColimits_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Limits.HasColimitsOfSize.{v, u, v₁, u₁} C\ninst✝ : CategoryTheory.Coreflective R\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v, u, v₂, u₂} D","decl":"/-- If `C` has colimits then any coreflective subcategory has colimits. -/\ntheorem hasColimits_of_coreflective (R : D ⥤ C) [HasColimitsOfSize.{v, u} C] [Coreflective R] :\n    HasColimitsOfSize.{v, u} D :=\n  ⟨fun _ => hasColimitsOfShape_of_coreflective R⟩\n\n"}
{"name":"CategoryTheory.hasLimitsOfShape_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nJ : Type u\ninst✝² : CategoryTheory.Category.{v, u} J\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Coreflective R\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J D","decl":"/-- If `C` has limits of shape `J` then any coreflective subcategory has limits of shape `J`. -/\ntheorem hasLimitsOfShape_of_coreflective (R : D ⥤ C) [Coreflective R] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J D where\n  has_limit := fun F => by\n      let c := (comonadicRightAdjoint R).mapCone (limit.cone (F ⋙ R))\n      letI : PreservesLimitsOfShape J _ :=\n        (comonadicAdjunction R).rightAdjoint_preservesLimits.1\n      let t : IsLimit c := isLimitOfPreserves (comonadicRightAdjoint R) (limit.isLimit _)\n      apply HasLimit.mk ⟨_, (IsLimit.postcomposeHomEquiv _ _).symm t⟩\n      apply\n        (F.rightUnitor ≪≫ (isoWhiskerLeft F ((asIso (comonadicAdjunction R).unit) :) )).symm\n\n"}
{"name":"CategoryTheory.hasLimits_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝¹ : CategoryTheory.Coreflective R\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v, u, v₁, u₁} C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v, u, v₂, u₂} D","decl":"/-- If `C` has limits then any coreflective subcategory has limits. -/\ntheorem hasLimits_of_coreflective (R : D ⥤ C) [Coreflective R] [HasLimitsOfSize.{v, u} C] :\n    HasLimitsOfSize.{v, u} D :=\n  ⟨fun _ => hasLimitsOfShape_of_coreflective R⟩\n\n"}
{"name":"CategoryTheory.rightAdjoint_preservesInitial_of_coreflective","module":"Mathlib.CategoryTheory.Monad.Limits","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nR : CategoryTheory.Functor D C\ninst✝ : CategoryTheory.Coreflective R\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{v + 1}) (CategoryTheory.comonadicRightAdjoint R)","decl":"/-- The coreflector always preserves initial objects. Note this in general doesn't apply to any\nother colimit.\n-/\nlemma rightAdjoint_preservesInitial_of_coreflective (R : D ⥤ C) [Coreflective R] :\n    PreservesColimitsOfShape (Discrete.{v} PEmpty) (comonadicRightAdjoint R) where\n  preservesColimit {K} := by\n    let F := Functor.empty.{v} D\n    letI : PreservesColimit (F ⋙ R) (comonadicRightAdjoint R) := by\n      constructor\n      intro c h\n      haveI : HasColimit (F ⋙ R) := ⟨⟨⟨c, h⟩⟩⟩\n      haveI : HasColimit F := hasColimit_of_coreflective F R\n      constructor\n      apply isColimitChangeEmptyCocone D (colimit.isColimit F)\n      apply (asIso ((comonadicAdjunction R).unit.app _)).trans\n      apply (comonadicRightAdjoint R).mapIso\n      letI := comonadicCreatesColimits.{v, v} R\n      let A := CategoryTheory.preservesColimit_of_createsColimit_and_hasColimit F R\n      apply (isColimitOfPreserves _ (colimit.isColimit F)).coconePointUniqueUpToIso h\n    apply preservesColimit_of_iso_diagram _ (Functor.emptyExt (F ⋙ R) _)\n\n"}
