{"name":"mapClusterPt_atTop_zsmul_iff_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝¹ : SubNegMonoid G\ninst✝ : TopologicalSpace G\nx y : G\n⊢ Iff (MapClusterPt x Filter.atTop fun x => HSMul.hSMul x y) (MapClusterPt x Filter.atTop fun x => HSMul.hSMul x y)","decl":"@[to_additive]\ntheorem mapClusterPt_atTop_zpow_iff_pow [DivInvMonoid G] [TopologicalSpace G] {x y : G} :\n    MapClusterPt x atTop (y ^ · : ℤ → G) ↔ MapClusterPt x atTop (y ^ · : ℕ → G) := by\n  simp_rw [MapClusterPt, ← Nat.map_cast_int_atTop, map_map, comp_def, zpow_natCast]\n\n"}
{"name":"mapClusterPt_atTop_zpow_iff_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝¹ : DivInvMonoid G\ninst✝ : TopologicalSpace G\nx y : G\n⊢ Iff (MapClusterPt x Filter.atTop fun x => HPow.hPow y x) (MapClusterPt x Filter.atTop fun x => HPow.hPow y x)","decl":"@[to_additive]\ntheorem mapClusterPt_atTop_zpow_iff_pow [DivInvMonoid G] [TopologicalSpace G] {x y : G} :\n    MapClusterPt x atTop (y ^ · : ℤ → G) ↔ MapClusterPt x atTop (y ^ · : ℕ → G) := by\n  simp_rw [MapClusterPt, ← Nat.map_cast_int_atTop, map_map, comp_def, zpow_natCast]\n\n"}
{"name":"mapClusterPt_self_zsmul_atTop_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx : G\nm : Int\n⊢ MapClusterPt (HSMul.hSMul m x) Filter.atTop fun x_1 => HSMul.hSMul x_1 x","decl":"@[to_additive]\ntheorem mapClusterPt_self_zpow_atTop_pow (x : G) (m : ℤ) :\n    MapClusterPt (x ^ m) atTop (x ^ · : ℕ → G) := by\n  obtain ⟨y, hy⟩ : ∃ y, MapClusterPt y atTop (x ^ · : ℤ → G) :=\n    exists_clusterPt_of_compactSpace _\n  rw [← mapClusterPt_atTop_zpow_iff_pow]\n  have H : MapClusterPt (x ^ m) (atTop.curry atTop) ↿(fun a b ↦ x ^ (m + b - a)) := by\n    have : ContinuousAt (fun yz ↦ x ^ m * yz.2 / yz.1) (y, y) := by fun_prop\n    simpa only [comp_def, ← zpow_sub, ← zpow_add, div_eq_mul_inv, Prod.map, mul_inv_cancel_right]\n      using (hy.curry_prodMap hy).continuousAt_comp this\n  suffices Tendsto ↿(fun a b ↦ m + b - a) (atTop.curry atTop) atTop from H.of_comp this\n  refine Tendsto.curry <| .of_forall fun a ↦ ?_\n  simp only [sub_eq_add_neg] -- TODO: add `Tendsto.atTop_sub_const` etc\n  exact tendsto_atTop_add_const_right _ _ (tendsto_atTop_add_const_left atTop m tendsto_id)\n\n"}
{"name":"mapClusterPt_self_zpow_atTop_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx : G\nm : Int\n⊢ MapClusterPt (HPow.hPow x m) Filter.atTop fun x_1 => HPow.hPow x x_1","decl":"@[to_additive]\ntheorem mapClusterPt_self_zpow_atTop_pow (x : G) (m : ℤ) :\n    MapClusterPt (x ^ m) atTop (x ^ · : ℕ → G) := by\n  obtain ⟨y, hy⟩ : ∃ y, MapClusterPt y atTop (x ^ · : ℤ → G) :=\n    exists_clusterPt_of_compactSpace _\n  rw [← mapClusterPt_atTop_zpow_iff_pow]\n  have H : MapClusterPt (x ^ m) (atTop.curry atTop) ↿(fun a b ↦ x ^ (m + b - a)) := by\n    have : ContinuousAt (fun yz ↦ x ^ m * yz.2 / yz.1) (y, y) := by fun_prop\n    simpa only [comp_def, ← zpow_sub, ← zpow_add, div_eq_mul_inv, Prod.map, mul_inv_cancel_right]\n      using (hy.curry_prodMap hy).continuousAt_comp this\n  suffices Tendsto ↿(fun a b ↦ m + b - a) (atTop.curry atTop) atTop from H.of_comp this\n  refine Tendsto.curry <| .of_forall fun a ↦ ?_\n  simp only [sub_eq_add_neg] -- TODO: add `Tendsto.atTop_sub_const` etc\n  exact tendsto_atTop_add_const_right _ _ (tendsto_atTop_add_const_left atTop m tendsto_id)\n\n"}
{"name":"mapClusterPt_one_atTop_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx : G\n⊢ MapClusterPt 1 Filter.atTop fun x_1 => HPow.hPow x x_1","decl":"@[to_additive]\ntheorem mapClusterPt_one_atTop_pow (x : G) : MapClusterPt 1 atTop (x ^ · : ℕ → G) := by\n  simpa using mapClusterPt_self_zpow_atTop_pow x 0\n\n"}
{"name":"mapClusterPt_zero_atTop_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx : G\n⊢ MapClusterPt 0 Filter.atTop fun x_1 => HSMul.hSMul x_1 x","decl":"@[to_additive]\ntheorem mapClusterPt_one_atTop_pow (x : G) : MapClusterPt 1 atTop (x ^ · : ℕ → G) := by\n  simpa using mapClusterPt_self_zpow_atTop_pow x 0\n\n"}
{"name":"mapClusterPt_self_atTop_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx : G\n⊢ MapClusterPt x Filter.atTop fun x_1 => HPow.hPow x x_1","decl":"@[to_additive]\ntheorem mapClusterPt_self_atTop_pow (x : G) : MapClusterPt x atTop (x ^ · : ℕ → G) := by\n  simpa using mapClusterPt_self_zpow_atTop_pow x 1\n\n"}
{"name":"mapClusterPt_self_atTop_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx : G\n⊢ MapClusterPt x Filter.atTop fun x_1 => HSMul.hSMul x_1 x","decl":"@[to_additive]\ntheorem mapClusterPt_self_atTop_pow (x : G) : MapClusterPt x atTop (x ^ · : ℕ → G) := by\n  simpa using mapClusterPt_self_zpow_atTop_pow x 1\n\n"}
{"name":"mapClusterPt_atTop_pow_tfae","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx y : G\n⊢ (List.cons (MapClusterPt x Filter.atTop fun x => HPow.hPow y x) (List.cons (MapClusterPt x Filter.atTop fun x => HPow.hPow y x) (List.cons (Membership.mem (closure (Set.range fun x => HPow.hPow y x)) x) (List.cons (Membership.mem (closure (Set.range fun x => HPow.hPow y x)) x) List.nil)))).TFAE","decl":"@[to_additive]\ntheorem mapClusterPt_atTop_pow_tfae (x y : G) :\n    List.TFAE [\n      MapClusterPt x atTop (y ^ · : ℕ → G),\n      MapClusterPt x atTop (y ^ · : ℤ → G),\n      x ∈ closure (range (y ^ · : ℕ → G)),\n      x ∈ closure (range (y ^ · : ℤ → G)),\n    ] := by\n  tfae_have 2 ↔ 1 := mapClusterPt_atTop_zpow_iff_pow\n  tfae_have 3 → 4 := by\n    refine fun h ↦ closure_mono (range_subset_iff.2 fun n ↦ ?_) h\n    exact ⟨n, zpow_natCast _ _⟩\n  tfae_have 4 → 1 := by\n    refine fun h ↦ closure_minimal ?_ isClosed_setOf_clusterPt h\n    exact range_subset_iff.2 (mapClusterPt_self_zpow_atTop_pow _)\n  tfae_have 1 → 3 := by\n    rw [mem_closure_iff_clusterPt]\n    exact (ClusterPt.mono · (le_principal_iff.2 range_mem_map))\n  tfae_finish\n\n"}
{"name":"mapClusterPt_atTop_nsmul_tfae","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx y : G\n⊢ (List.cons (MapClusterPt x Filter.atTop fun x => HSMul.hSMul x y) (List.cons (MapClusterPt x Filter.atTop fun x => HSMul.hSMul x y) (List.cons (Membership.mem (closure (Set.range fun x => HSMul.hSMul x y)) x) (List.cons (Membership.mem (closure (Set.range fun x => HSMul.hSMul x y)) x) List.nil)))).TFAE","decl":"@[to_additive]\ntheorem mapClusterPt_atTop_pow_tfae (x y : G) :\n    List.TFAE [\n      MapClusterPt x atTop (y ^ · : ℕ → G),\n      MapClusterPt x atTop (y ^ · : ℤ → G),\n      x ∈ closure (range (y ^ · : ℕ → G)),\n      x ∈ closure (range (y ^ · : ℤ → G)),\n    ] := by\n  tfae_have 2 ↔ 1 := mapClusterPt_atTop_zpow_iff_pow\n  tfae_have 3 → 4 := by\n    refine fun h ↦ closure_mono (range_subset_iff.2 fun n ↦ ?_) h\n    exact ⟨n, zpow_natCast _ _⟩\n  tfae_have 4 → 1 := by\n    refine fun h ↦ closure_minimal ?_ isClosed_setOf_clusterPt h\n    exact range_subset_iff.2 (mapClusterPt_self_zpow_atTop_pow _)\n  tfae_have 1 → 3 := by\n    rw [mem_closure_iff_clusterPt]\n    exact (ClusterPt.mono · (le_principal_iff.2 range_mem_map))\n  tfae_finish\n\n"}
{"name":"mapClusterPt_atTop_pow_iff_mem_topologicalClosure_zpowers","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx y : G\n⊢ Iff (MapClusterPt x Filter.atTop fun x => HPow.hPow y x) (Membership.mem (Subgroup.zpowers y).topologicalClosure x)","decl":"@[to_additive]\ntheorem mapClusterPt_atTop_pow_iff_mem_topologicalClosure_zpowers {x y : G} :\n    MapClusterPt x atTop (y ^ · : ℕ → G) ↔ x ∈ (Subgroup.zpowers y).topologicalClosure :=\n  (mapClusterPt_atTop_pow_tfae x y).out 0 3\n\n"}
{"name":"mapClusterPt_atTop_nsmul_iff_mem_topologicalClosure_zmultiples","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx y : G\n⊢ Iff (MapClusterPt x Filter.atTop fun x => HSMul.hSMul x y) (Membership.mem (AddSubgroup.zmultiples y).topologicalClosure x)","decl":"@[to_additive]\ntheorem mapClusterPt_atTop_pow_iff_mem_topologicalClosure_zpowers {x y : G} :\n    MapClusterPt x atTop (y ^ · : ℕ → G) ↔ x ∈ (Subgroup.zpowers y).topologicalClosure :=\n  (mapClusterPt_atTop_pow_tfae x y).out 0 3\n\n"}
{"name":"mapClusterPt_neg_atTop_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx y : G\n⊢ Iff (MapClusterPt (Neg.neg x) Filter.atTop fun x => HSMul.hSMul x y) (MapClusterPt x Filter.atTop fun x => HSMul.hSMul x y)","decl":"@[to_additive (attr := simp)]\ntheorem mapClusterPt_inv_atTop_pow {x y : G} :\n    MapClusterPt x⁻¹ atTop (y ^ · : ℕ → G) ↔ MapClusterPt x atTop (y ^ · : ℕ → G) := by\n  simp only [mapClusterPt_atTop_pow_iff_mem_topologicalClosure_zpowers, inv_mem_iff]\n\n"}
{"name":"mapClusterPt_inv_atTop_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx y : G\n⊢ Iff (MapClusterPt (Inv.inv x) Filter.atTop fun x => HPow.hPow y x) (MapClusterPt x Filter.atTop fun x => HPow.hPow y x)","decl":"@[to_additive (attr := simp)]\ntheorem mapClusterPt_inv_atTop_pow {x y : G} :\n    MapClusterPt x⁻¹ atTop (y ^ · : ℕ → G) ↔ MapClusterPt x atTop (y ^ · : ℕ → G) := by\n  simp only [mapClusterPt_atTop_pow_iff_mem_topologicalClosure_zpowers, inv_mem_iff]\n\n"}
{"name":"closure_range_zpow_eq_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx : G\n⊢ Eq (closure (Set.range fun x_1 => HPow.hPow x x_1)) (closure (Set.range fun x_1 => HPow.hPow x x_1))","decl":"@[to_additive]\ntheorem closure_range_zpow_eq_pow (x : G) :\n    closure (range (x ^ · : ℤ → G)) = closure (range (x ^ · : ℕ → G)) := by\n  ext y\n  exact (mapClusterPt_atTop_pow_tfae y x).out 3 2\n\n"}
{"name":"closure_range_zsmul_eq_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx : G\n⊢ Eq (closure (Set.range fun x_1 => HSMul.hSMul x_1 x)) (closure (Set.range fun x_1 => HSMul.hSMul x_1 x))","decl":"@[to_additive]\ntheorem closure_range_zpow_eq_pow (x : G) :\n    closure (range (x ^ · : ℤ → G)) = closure (range (x ^ · : ℕ → G)) := by\n  ext y\n  exact (mapClusterPt_atTop_pow_tfae y x).out 3 2\n\n"}
{"name":"denseRange_zpow_iff_pow","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\nx : G\n⊢ Iff (DenseRange fun x_1 => HPow.hPow x x_1) (DenseRange fun x_1 => HPow.hPow x x_1)","decl":"@[to_additive]\ntheorem denseRange_zpow_iff_pow {x : G} :\n    DenseRange (x ^ · : ℤ → G) ↔ DenseRange (x ^ · : ℕ → G) := by\n  simp only [DenseRange, dense_iff_closure_eq, closure_range_zpow_eq_pow]\n\n"}
{"name":"denseRange_zsmul_iff_nsmul","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\nx : G\n⊢ Iff (DenseRange fun x_1 => HSMul.hSMul x_1 x) (DenseRange fun x_1 => HSMul.hSMul x_1 x)","decl":"@[to_additive]\ntheorem denseRange_zpow_iff_pow {x : G} :\n    DenseRange (x ^ · : ℤ → G) ↔ DenseRange (x ^ · : ℕ → G) := by\n  simp only [DenseRange, dense_iff_closure_eq, closure_range_zpow_eq_pow]\n\n"}
{"name":"topologicalClosure_subgroupClosure_toSubmonoid","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\ns : Set G\n⊢ Eq (Subgroup.closure s).topologicalClosure (Submonoid.closure s).topologicalClosure","decl":"@[to_additive]\ntheorem topologicalClosure_subgroupClosure_toSubmonoid (s : Set G) :\n    (Subgroup.closure s).toSubmonoid.topologicalClosure =\n      (Submonoid.closure s).topologicalClosure := by\n  refine le_antisymm ?_ (closure_mono <| Subgroup.le_closure_toSubmonoid _)\n  refine Submonoid.topologicalClosure_minimal _ ?_ isClosed_closure\n  rw [Subgroup.closure_toSubmonoid, Submonoid.closure_le]\n  refine union_subset (Submonoid.subset_closure.trans subset_closure) fun x hx ↦ ?_\n  refine closure_mono (Submonoid.powers_le.2 (Submonoid.subset_closure <| Set.mem_inv.1 hx)) ?_\n  rw [Submonoid.coe_powers, ← closure_range_zpow_eq_pow, ← Subgroup.coe_zpowers,\n    ← Subgroup.topologicalClosure_coe, SetLike.mem_coe, ← inv_mem_iff]\n  exact subset_closure <| Subgroup.mem_zpowers _\n\n"}
{"name":"topologicalClosure_addSubgroupClosure_toAddSubmonoid","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\ns : Set G\n⊢ Eq (AddSubgroup.closure s).topologicalClosure (AddSubmonoid.closure s).topologicalClosure","decl":"@[to_additive]\ntheorem topologicalClosure_subgroupClosure_toSubmonoid (s : Set G) :\n    (Subgroup.closure s).toSubmonoid.topologicalClosure =\n      (Submonoid.closure s).topologicalClosure := by\n  refine le_antisymm ?_ (closure_mono <| Subgroup.le_closure_toSubmonoid _)\n  refine Submonoid.topologicalClosure_minimal _ ?_ isClosed_closure\n  rw [Subgroup.closure_toSubmonoid, Submonoid.closure_le]\n  refine union_subset (Submonoid.subset_closure.trans subset_closure) fun x hx ↦ ?_\n  refine closure_mono (Submonoid.powers_le.2 (Submonoid.subset_closure <| Set.mem_inv.1 hx)) ?_\n  rw [Submonoid.coe_powers, ← closure_range_zpow_eq_pow, ← Subgroup.coe_zpowers,\n    ← Subgroup.topologicalClosure_coe, SetLike.mem_coe, ← inv_mem_iff]\n  exact subset_closure <| Subgroup.mem_zpowers _\n\n"}
{"name":"closure_submonoidClosure_eq_closure_subgroupClosure","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\ns : Set G\n⊢ Eq (closure ↑(Submonoid.closure s)) (closure ↑(Subgroup.closure s))","decl":"@[to_additive]\ntheorem closure_submonoidClosure_eq_closure_subgroupClosure (s : Set G) :\n    closure (Submonoid.closure s : Set G) = closure (Subgroup.closure s) :=\n  congrArg SetLike.coe (topologicalClosure_subgroupClosure_toSubmonoid s).symm\n\n"}
{"name":"closure_addSubmonoidClosure_eq_closure_addSubgroupClosure","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\ns : Set G\n⊢ Eq (closure ↑(AddSubmonoid.closure s)) (closure ↑(AddSubgroup.closure s))","decl":"@[to_additive]\ntheorem closure_submonoidClosure_eq_closure_subgroupClosure (s : Set G) :\n    closure (Submonoid.closure s : Set G) = closure (Subgroup.closure s) :=\n  congrArg SetLike.coe (topologicalClosure_subgroupClosure_toSubmonoid s).symm\n\n"}
{"name":"dense_submonoidClosure_iff_subgroupClosure","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : Group G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalGroup G\ns : Set G\n⊢ Iff (Dense ↑(Submonoid.closure s)) (Dense ↑(Subgroup.closure s))","decl":"@[to_additive]\ntheorem dense_submonoidClosure_iff_subgroupClosure {s : Set G} :\n    Dense (Submonoid.closure s : Set G) ↔ Dense (Subgroup.closure s : Set G) := by\n  simp only [dense_iff_closure_eq, closure_submonoidClosure_eq_closure_subgroupClosure]\n"}
{"name":"dense_addSubmonoidClosure_iff_addSubgroupClosure","module":"Mathlib.Topology.Algebra.Group.SubmonoidClosure","initialProofState":"G : Type u_1\ninst✝³ : AddGroup G\ninst✝² : TopologicalSpace G\ninst✝¹ : CompactSpace G\ninst✝ : TopologicalAddGroup G\ns : Set G\n⊢ Iff (Dense ↑(AddSubmonoid.closure s)) (Dense ↑(AddSubgroup.closure s))","decl":"@[to_additive]\ntheorem dense_submonoidClosure_iff_subgroupClosure {s : Set G} :\n    Dense (Submonoid.closure s : Set G) ↔ Dense (Subgroup.closure s : Set G) := by\n  simp only [dense_iff_closure_eq, closure_submonoidClosure_eq_closure_subgroupClosure]\n"}
