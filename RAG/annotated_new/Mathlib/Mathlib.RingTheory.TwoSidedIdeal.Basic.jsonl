{"name":"TwoSidedIdeal.mk.injEq","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nringCon✝ ringCon : RingCon R\n⊢ Eq (Eq { ringCon := ringCon✝ } { ringCon := ringCon }) (Eq ringCon✝ ringCon)","decl":"/--\nA two-sided ideal of a ring `R` is a subset of `R` that contains `0` and is closed under addition,\nnegation, and absorbs multiplication on both sides.\n-/\nstructure TwoSidedIdeal (R : Type*) [NonUnitalNonAssocRing R] where\n  /-- every two-sided-ideal is induced by a congruence relation on the ring. -/\n  ringCon : RingCon R\n\n"}
{"name":"TwoSidedIdeal.mk.inj","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nringCon✝ ringCon : RingCon R\nx✝ : Eq { ringCon := ringCon✝ } { ringCon := ringCon }\n⊢ Eq ringCon✝ ringCon","decl":"/--\nA two-sided ideal of a ring `R` is a subset of `R` that contains `0` and is closed under addition,\nnegation, and absorbs multiplication on both sides.\n-/\nstructure TwoSidedIdeal (R : Type*) [NonUnitalNonAssocRing R] where\n  /-- every two-sided-ideal is induced by a congruence relation on the ring. -/\n  ringCon : RingCon R\n\n"}
{"name":"TwoSidedIdeal.mk.sizeOf_spec","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : SizeOf R\nringCon : RingCon R\n⊢ Eq (SizeOf.sizeOf { ringCon := ringCon }) (HAdd.hAdd 1 (SizeOf.sizeOf ringCon))","decl":"/--\nA two-sided ideal of a ring `R` is a subset of `R` that contains `0` and is closed under addition,\nnegation, and absorbs multiplication on both sides.\n-/\nstructure TwoSidedIdeal (R : Type*) [NonUnitalNonAssocRing R] where\n  /-- every two-sided-ideal is induced by a congruence relation on the ring. -/\n  ringCon : RingCon R\n\n"}
{"name":"TwoSidedIdeal.instNontrivial","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalNonAssocRing R\ninst✝ : Nontrivial R\n⊢ Nontrivial (TwoSidedIdeal R)","decl":"instance [Nontrivial R] : Nontrivial (TwoSidedIdeal R) := by\n  obtain ⟨I, J, h⟩ : Nontrivial (RingCon R) := inferInstance\n  exact ⟨⟨I⟩, ⟨J⟩, by contrapose! h; aesop⟩\n\n"}
{"name":"TwoSidedIdeal.mem_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx : R\n⊢ Iff (Membership.mem I x) (I.ringCon x 0)","decl":"lemma mem_iff (x : R) : x ∈ I ↔ I.ringCon x 0 := Iff.rfl\n\n"}
{"name":"TwoSidedIdeal.rel_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\n⊢ Iff (I.ringCon x y) (Membership.mem I (HSub.hSub x y))","decl":"lemma rel_iff (x y : R) : I.ringCon x y ↔ x - y ∈ I := by\n  rw [mem_iff]\n  constructor\n  · intro h; convert I.ringCon.sub h (I.ringCon.refl y); abel\n  · intro h; convert I.ringCon.add h (I.ringCon.refl y) <;> abel\n\n"}
{"name":"TwoSidedIdeal.coeOrderEmbedding_apply","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\na✝ : TwoSidedIdeal R\n⊢ Eq (TwoSidedIdeal.coeOrderEmbedding a✝) ↑a✝","decl":"/--\nthe coercion from two-sided-ideals to sets is an order embedding\n-/\n@[simps]\ndef coeOrderEmbedding : TwoSidedIdeal R ↪o Set R where\n  toFun := SetLike.coe\n  inj' := SetLike.coe_injective\n  map_rel_iff' {I J} := ⟨fun (h : (I : Set R) ⊆ (J : Set R)) _ h' ↦ h h', fun h _ h' ↦ h h'⟩\n\n"}
{"name":"TwoSidedIdeal.le_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\n⊢ Iff (LE.le I J) (HasSubset.Subset ↑I ↑J)","decl":"lemma le_iff {I J : TwoSidedIdeal R} : I ≤ J ↔ (I : Set R) ⊆ (J : Set R) := Iff.rfl\n\n"}
{"name":"TwoSidedIdeal.ringCon_injective","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\n⊢ Function.Injective TwoSidedIdeal.ringCon","decl":"lemma ringCon_injective : Function.Injective (TwoSidedIdeal.ringCon (R := R)) := by\n  rintro ⟨x⟩ ⟨y⟩ rfl; rfl\n\n"}
{"name":"TwoSidedIdeal.ringCon_le_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\n⊢ Iff (LE.le I J) (LE.le I.ringCon J.ringCon)","decl":"lemma ringCon_le_iff {I J : TwoSidedIdeal R} : I ≤ J ↔ I.ringCon ≤ J.ringCon :=\n  orderIsoRingCon.map_rel_iff.symm\n\n"}
{"name":"TwoSidedIdeal.ext_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\n⊢ Iff (Eq I J) (∀ (x : R), Iff (Membership.mem I x) (Membership.mem J x))","decl":"@[ext]\nlemma ext {I J : TwoSidedIdeal R} (h : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  coeOrderEmbedding.injective (Set.ext h)\n\n"}
{"name":"TwoSidedIdeal.ext","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\nh : ∀ (x : R), Iff (Membership.mem I x) (Membership.mem J x)\n⊢ Eq I J","decl":"@[ext]\nlemma ext {I J : TwoSidedIdeal R} (h : ∀ x, x ∈ I ↔ x ∈ J) : I = J :=\n  coeOrderEmbedding.injective (Set.ext h)\n\n"}
{"name":"TwoSidedIdeal.lt_iff","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI J : TwoSidedIdeal R\n⊢ Iff (LT.lt I J) (HasSSubset.SSubset ↑I ↑J)","decl":"lemma lt_iff (I J : TwoSidedIdeal R) : I < J ↔ (I : Set R) ⊂ (J : Set R) := by\n  rw [lt_iff_le_and_ne, Set.ssubset_iff_subset_ne, le_iff]\n  simp\n\n"}
{"name":"TwoSidedIdeal.zero_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\n⊢ Membership.mem I 0","decl":"@[simp]\nlemma zero_mem : 0 ∈ I := I.ringCon.refl 0\n\n"}
{"name":"TwoSidedIdeal.add_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhx : Membership.mem I x\nhy : Membership.mem I y\n⊢ Membership.mem I (HAdd.hAdd x y)","decl":"lemma add_mem {x y} (hx : x ∈ I) (hy : y ∈ I) : x + y ∈ I := by simpa using I.ringCon.add hx hy\n\n"}
{"name":"TwoSidedIdeal.neg_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx : R\nhx : Membership.mem I x\n⊢ Membership.mem I (Neg.neg x)","decl":"lemma neg_mem {x} (hx : x ∈ I) : -x ∈ I := by simpa using I.ringCon.neg hx\n\n"}
{"name":"TwoSidedIdeal.instAddSubgroupClass","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\n⊢ AddSubgroupClass (TwoSidedIdeal R) R","decl":"instance : AddSubgroupClass (TwoSidedIdeal R) R where\n  zero_mem := zero_mem\n  add_mem := @add_mem _ _\n  neg_mem := @neg_mem _ _\n\n"}
{"name":"TwoSidedIdeal.sub_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhx : Membership.mem I x\nhy : Membership.mem I y\n⊢ Membership.mem I (HSub.hSub x y)","decl":"lemma sub_mem {x y} (hx : x ∈ I) (hy : y ∈ I) : x - y ∈ I := _root_.sub_mem hx hy\n\n"}
{"name":"TwoSidedIdeal.mul_mem_left","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhy : Membership.mem I y\n⊢ Membership.mem I (HMul.hMul x y)","decl":"lemma mul_mem_left (x y) (hy : y ∈ I) : x * y ∈ I := by\n  simpa using I.ringCon.mul (I.ringCon.refl x) hy\n\n"}
{"name":"TwoSidedIdeal.mul_mem_right","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx y : R\nhx : Membership.mem I x\n⊢ Membership.mem I (HMul.hMul x y)","decl":"lemma mul_mem_right (x y) (hx : x ∈ I) : x * y ∈ I := by\n  simpa using I.ringCon.mul hx (I.ringCon.refl y)\n\n"}
{"name":"TwoSidedIdeal.nsmul_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx : R\nn : Nat\nhx : Membership.mem I x\n⊢ Membership.mem I (HSMul.hSMul n x)","decl":"lemma nsmul_mem {x} (n : ℕ) (hx : x ∈ I) : n • x ∈ I := _root_.nsmul_mem hx _\n\n"}
{"name":"TwoSidedIdeal.zsmul_mem","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\nI : TwoSidedIdeal R\nx : R\nn : Int\nhx : Membership.mem I x\n⊢ Membership.mem I (HSMul.hSMul n x)","decl":"lemma zsmul_mem {x} (n : ℤ) (hx : x ∈ I) : n • x ∈ I := _root_.zsmul_mem hx _\n\n"}
{"name":"TwoSidedIdeal.mem_mk'","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\ncarrier : Set R\nzero_mem : Membership.mem carrier 0\nadd_mem : ∀ {x y : R}, Membership.mem carrier x → Membership.mem carrier y → Membership.mem carrier (HAdd.hAdd x y)\nneg_mem : ∀ {x : R}, Membership.mem carrier x → Membership.mem carrier (Neg.neg x)\nmul_mem_left : ∀ {x y : R}, Membership.mem carrier y → Membership.mem carrier (HMul.hMul x y)\nmul_mem_right : ∀ {x y : R}, Membership.mem carrier x → Membership.mem carrier (HMul.hMul x y)\nx : R\n⊢ Iff (Membership.mem (TwoSidedIdeal.mk' carrier zero_mem add_mem neg_mem mul_mem_left mul_mem_right) x) (Membership.mem carrier x)","decl":"@[simp]\nlemma mem_mk' (carrier : Set R) (zero_mem add_mem neg_mem mul_mem_left mul_mem_right) (x : R) :\n    x ∈ mk' carrier zero_mem add_mem neg_mem mul_mem_left mul_mem_right ↔ x ∈ carrier := by\n  rw [mem_iff]\n  simp [mk']\n\n"}
{"name":"TwoSidedIdeal.coe_mk'","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\ncarrier : Set R\nzero_mem : Membership.mem carrier 0\nadd_mem : ∀ {x y : R}, Membership.mem carrier x → Membership.mem carrier y → Membership.mem carrier (HAdd.hAdd x y)\nneg_mem : ∀ {x : R}, Membership.mem carrier x → Membership.mem carrier (Neg.neg x)\nmul_mem_left : ∀ {x y : R}, Membership.mem carrier y → Membership.mem carrier (HMul.hMul x y)\nmul_mem_right : ∀ {x y : R}, Membership.mem carrier x → Membership.mem carrier (HMul.hMul x y)\n⊢ Eq (↑(TwoSidedIdeal.mk' carrier zero_mem add_mem neg_mem mul_mem_left mul_mem_right)) carrier","decl":"set_option linter.docPrime false in\n@[simp]\nlemma coe_mk' (carrier : Set R) (zero_mem add_mem neg_mem mul_mem_left mul_mem_right) :\n    (mk' carrier zero_mem add_mem neg_mem mul_mem_left mul_mem_right : Set R) = carrier :=\n  Set.ext <| mem_mk' carrier zero_mem add_mem neg_mem mul_mem_left mul_mem_right\n\n"}
{"name":"TwoSidedIdeal.instSMulMemClass","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\n⊢ SMulMemClass (TwoSidedIdeal R) R R","decl":"instance : SMulMemClass (TwoSidedIdeal R) R R where\n  smul_mem _ _ h := TwoSidedIdeal.mul_mem_left _ _ _ h\n\n"}
{"name":"TwoSidedIdeal.instSMulMemClassMulOpposite","module":"Mathlib.RingTheory.TwoSidedIdeal.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocRing R\n⊢ SMulMemClass (TwoSidedIdeal R) (MulOpposite R) R","decl":"instance : SMulMemClass (TwoSidedIdeal R) Rᵐᵒᵖ R where\n  smul_mem _ _ h := TwoSidedIdeal.mul_mem_right _ _ _ h\n\n"}
