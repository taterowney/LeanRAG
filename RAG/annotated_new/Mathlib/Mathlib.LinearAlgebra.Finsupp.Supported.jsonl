{"name":"Finsupp.mem_supported","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\np : Finsupp α M\n⊢ Iff (Membership.mem (Finsupp.supported M R s) p) (HasSubset.Subset (↑p.support) s)","decl":"theorem mem_supported {s : Set α} (p : α →₀ M) : p ∈ supported M R s ↔ ↑p.support ⊆ s :=\n  Iff.rfl\n\n"}
{"name":"Finsupp.mem_supported'","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\np : Finsupp α M\n⊢ Iff (Membership.mem (Finsupp.supported M R s) p) (∀ (x : α), Not (Membership.mem s x) → Eq (p x) 0)","decl":"theorem mem_supported' {s : Set α} (p : α →₀ M) :\n    p ∈ supported M R s ↔ ∀ x ∉ s, p x = 0 := by\n  haveI := Classical.decPred fun x : α => x ∈ s; simp [mem_supported, Set.subset_def, not_imp_comm]\n\n"}
{"name":"Finsupp.mem_supported_support","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\np : Finsupp α M\n⊢ Membership.mem (Finsupp.supported M R ↑p.support) p","decl":"theorem mem_supported_support (p : α →₀ M) : p ∈ Finsupp.supported M R (p.support : Set α) := by\n  rw [Finsupp.mem_supported]\n\n"}
{"name":"Finsupp.single_mem_supported","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\na : α\nb : M\nh : Membership.mem s a\n⊢ Membership.mem (Finsupp.supported M R s) (Finsupp.single a b)","decl":"theorem single_mem_supported {s : Set α} {a : α} (b : M) (h : a ∈ s) :\n    single a b ∈ supported M R s :=\n  Set.Subset.trans support_single_subset (Finset.singleton_subset_set_iff.2 h)\n\n"}
{"name":"Finsupp.supported_eq_span_single","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nR : Type u_5\ninst✝ : Semiring R\ns : Set α\n⊢ Eq (Finsupp.supported R R s) (Submodule.span R (Set.image (fun i => Finsupp.single i 1) s))","decl":"theorem supported_eq_span_single (s : Set α) :\n    supported R R s = span R ((fun i => single i 1) '' s) := by\n  refine (span_eq_of_le _ ?_ (SetLike.le_def.2 fun l hl => ?_)).symm\n  · rintro _ ⟨_, hp, rfl⟩\n    exact single_mem_supported R 1 hp\n  · rw [← l.sum_single]\n    refine sum_mem fun i il => ?_\n  -- Porting note: Needed to help this convert quite a bit replacing underscores\n    convert smul_mem (M := α →₀ R) (x := single i 1) (span R ((fun i => single i 1) '' s)) (l i) ?_\n    · simp [span]\n    · apply subset_span\n      apply Set.mem_image_of_mem _ (hl il)\n\n"}
{"name":"Finsupp.restrictDom_apply","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ns : Set α\nl : Finsupp α M\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (↑((Finsupp.restrictDom M R s) l)) (Finsupp.filter (fun x => Membership.mem s x) l)","decl":"@[simp]\ntheorem restrictDom_apply (s : Set α) (l : α →₀ M) [DecidablePred (· ∈ s)] :\n    (restrictDom M R s l : α →₀ M) = Finsupp.filter (· ∈ s) l := rfl\n\n"}
{"name":"Finsupp.restrictDom_comp_subtype","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq ((Finsupp.restrictDom M R s).comp (Finsupp.supported M R s).subtype) LinearMap.id","decl":"theorem restrictDom_comp_subtype (s : Set α) [DecidablePred (· ∈ s)] :\n    (restrictDom M R s).comp (Submodule.subtype _) = LinearMap.id := by\n  ext l a\n  by_cases h : a ∈ s\n  · simp [h]\n  simpa [h] using ((mem_supported' R l.1).1 l.2 a h).symm\n\n"}
{"name":"Finsupp.range_restrictDom","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (LinearMap.range (Finsupp.restrictDom M R s)) Top.top","decl":"theorem range_restrictDom (s : Set α) [DecidablePred (· ∈ s)] :\n    LinearMap.range (restrictDom M R s) = ⊤ :=\n  range_eq_top.2 <|\n    Function.RightInverse.surjective <| LinearMap.congr_fun (restrictDom_comp_subtype s)\n\n"}
{"name":"Finsupp.supported_mono","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set α\nst : HasSubset.Subset s t\n⊢ LE.le (Finsupp.supported M R s) (Finsupp.supported M R t)","decl":"theorem supported_mono {s t : Set α} (st : s ⊆ t) : supported M R s ≤ supported M R t := fun _ h =>\n  Set.Subset.trans h st\n\n"}
{"name":"Finsupp.supported_empty","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Finsupp.supported M R EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem supported_empty : supported M R (∅ : Set α) = ⊥ :=\n  eq_bot_iff.2 fun l h => (Submodule.mem_bot R).2 <| by ext; simp_all [mem_supported']\n\n"}
{"name":"Finsupp.supported_univ","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (Finsupp.supported M R Set.univ) Top.top","decl":"@[simp]\ntheorem supported_univ : supported M R (Set.univ : Set α) = ⊤ :=\n  eq_top_iff.2 fun _ _ => Set.subset_univ _\n\n"}
{"name":"Finsupp.supported_iUnion","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nδ : Type u_7\ns : δ → Set α\n⊢ Eq (Finsupp.supported M R (Set.iUnion fun i => s i)) (iSup fun i => Finsupp.supported M R (s i))","decl":"theorem supported_iUnion {δ : Type*} (s : δ → Set α) :\n    supported M R (⋃ i, s i) = ⨆ i, supported M R (s i) := by\n  refine le_antisymm ?_ (iSup_le fun i => supported_mono <| Set.subset_iUnion _ _)\n  haveI := Classical.decPred fun x => x ∈ ⋃ i, s i\n  suffices\n    LinearMap.range ((Submodule.subtype _).comp (restrictDom M R (⋃ i, s i))) ≤\n      ⨆ i, supported M R (s i) by\n    rwa [LinearMap.range_comp, range_restrictDom, Submodule.map_top, range_subtype] at this\n  rw [range_le_iff_comap, eq_top_iff]\n  rintro l ⟨⟩\n  -- Porting note: Was ported as `induction l using Finsupp.induction`\n  refine Finsupp.induction l ?_ ?_\n  · exact zero_mem _\n  · refine fun x a l _ _ => add_mem ?_\n    by_cases h : ∃ i, x ∈ s i\n    · simp only [mem_comap, coe_comp, coe_subtype, Function.comp_apply, restrictDom_apply,\n        mem_iUnion, h, filter_single_of_pos]\n      cases' h with i hi\n      exact le_iSup (fun i => supported M R (s i)) i (single_mem_supported R _ hi)\n    · simp [h]\n\n"}
{"name":"Finsupp.supported_union","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set α\n⊢ Eq (Finsupp.supported M R (Union.union s t)) (Max.max (Finsupp.supported M R s) (Finsupp.supported M R t))","decl":"theorem supported_union (s t : Set α) :\n    supported M R (s ∪ t) = supported M R s ⊔ supported M R t := by\n  rw [Set.union_eq_iUnion, supported_iUnion, iSup_bool_eq, cond_true, cond_false]\n\n"}
{"name":"Finsupp.supported_iInter","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_7\ns : ι → Set α\n⊢ Eq (Finsupp.supported M R (Set.iInter fun i => s i)) (iInf fun i => Finsupp.supported M R (s i))","decl":"theorem supported_iInter {ι : Type*} (s : ι → Set α) :\n    supported M R (⋂ i, s i) = ⨅ i, supported M R (s i) :=\n  Submodule.ext fun x => by simp [mem_supported, subset_iInter_iff]\n\n"}
{"name":"Finsupp.supported_inter","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set α\n⊢ Eq (Finsupp.supported M R (Inter.inter s t)) (Min.min (Finsupp.supported M R s) (Finsupp.supported M R t))","decl":"theorem supported_inter (s t : Set α) :\n    supported M R (s ∩ t) = supported M R s ⊓ supported M R t := by\n  rw [Set.inter_eq_iInter, supported_iInter, iInf_bool_eq]; rfl\n\n"}
{"name":"Finsupp.disjoint_supported_supported","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns t : Set α\nh : Disjoint s t\n⊢ Disjoint (Finsupp.supported M R s) (Finsupp.supported M R t)","decl":"theorem disjoint_supported_supported {s t : Set α} (h : Disjoint s t) :\n    Disjoint (supported M R s) (supported M R t) :=\n  disjoint_iff.2 <| by rw [← supported_inter, disjoint_iff_inter_eq_empty.1 h, supported_empty]\n\n"}
{"name":"Finsupp.disjoint_supported_supported_iff","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Nontrivial M\ns t : Set α\n⊢ Iff (Disjoint (Finsupp.supported M R s) (Finsupp.supported M R t)) (Disjoint s t)","decl":"theorem disjoint_supported_supported_iff [Nontrivial M] {s t : Set α} :\n    Disjoint (supported M R s) (supported M R t) ↔ Disjoint s t := by\n  refine ⟨fun h => Set.disjoint_left.mpr fun x hx1 hx2 => ?_, disjoint_supported_supported⟩\n  rcases exists_ne (0 : M) with ⟨y, hy⟩\n  have := h.le_bot ⟨single_mem_supported R y hx1, single_mem_supported R y hx2⟩\n  rw [mem_bot, single_eq_zero] at this\n  exact hy this\n\n"}
{"name":"Finsupp.supportedEquivFinsupp_symm_apply_coe_toFun","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\na✝ : Finsupp (↑s) M\na : α\n⊢ Eq (↑((Finsupp.supportedEquivFinsupp s).symm a✝) a) (dite (Membership.mem s a) (fun h => a✝ ⟨a, h⟩) fun h => 0)","decl":"/-- Interpret `Finsupp.restrictSupportEquiv` as a linear equivalence between\n`supported M R s` and `s →₀ M`. -/\n@[simps!] def supportedEquivFinsupp (s : Set α) : supported M R s ≃ₗ[R] s →₀ M := by\n  let F : supported M R s ≃ (s →₀ M) := restrictSupportEquiv s M\n  refine F.toLinearEquiv ?_\n  have :\n    (F : supported M R s → ↥s →₀ M) =\n      (lsubtypeDomain s : (α →₀ M) →ₗ[R] s →₀ M).comp (Submodule.subtype (supported M R s)) :=\n    rfl\n  rw [this]\n  exact LinearMap.isLinear _\n\n"}
{"name":"Finsupp.supportedEquivFinsupp_apply_support_val","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\na✝ : Subtype fun x => Membership.mem (Finsupp.supported M R s) x\n⊢ Eq ((Finsupp.supportedEquivFinsupp s) a✝).support.val (Multiset.map (fun x => ⟨↑x, ⋯⟩) (Multiset.filter (fun x => Membership.mem s x) (↑a✝).support.val).attach)","decl":"/-- Interpret `Finsupp.restrictSupportEquiv` as a linear equivalence between\n`supported M R s` and `s →₀ M`. -/\n@[simps!] def supportedEquivFinsupp (s : Set α) : supported M R s ≃ₗ[R] s →₀ M := by\n  let F : supported M R s ≃ (s →₀ M) := restrictSupportEquiv s M\n  refine F.toLinearEquiv ?_\n  have :\n    (F : supported M R s → ↥s →₀ M) =\n      (lsubtypeDomain s : (α →₀ M) →ₗ[R] s →₀ M).comp (Submodule.subtype (supported M R s)) :=\n    rfl\n  rw [this]\n  exact LinearMap.isLinear _\n\n"}
{"name":"Finsupp.supportedEquivFinsupp_apply_toFun","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\na✝¹ : Subtype fun x => Membership.mem (Finsupp.supported M R s) x\na✝ : Subtype fun x => Membership.mem s x\n⊢ Eq (((Finsupp.supportedEquivFinsupp s) a✝¹) a✝) (↑a✝¹ ↑a✝)","decl":"/-- Interpret `Finsupp.restrictSupportEquiv` as a linear equivalence between\n`supported M R s` and `s →₀ M`. -/\n@[simps!] def supportedEquivFinsupp (s : Set α) : supported M R s ≃ₗ[R] s →₀ M := by\n  let F : supported M R s ≃ (s →₀ M) := restrictSupportEquiv s M\n  refine F.toLinearEquiv ?_\n  have :\n    (F : supported M R s → ↥s →₀ M) =\n      (lsubtypeDomain s : (α →₀ M) →ₗ[R] s →₀ M).comp (Submodule.subtype (supported M R s)) :=\n    rfl\n  rw [this]\n  exact LinearMap.isLinear _\n\n"}
{"name":"Finsupp.supportedEquivFinsupp_symm_apply_coe_support_val","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set α\na✝ : Finsupp (↑s) M\n⊢ Eq (↑((Finsupp.supportedEquivFinsupp s).symm a✝)).support.val (Multiset.map Subtype.val a✝.support.val)","decl":"/-- Interpret `Finsupp.restrictSupportEquiv` as a linear equivalence between\n`supported M R s` and `s →₀ M`. -/\n@[simps!] def supportedEquivFinsupp (s : Set α) : supported M R s ≃ₗ[R] s →₀ M := by\n  let F : supported M R s ≃ (s →₀ M) := restrictSupportEquiv s M\n  refine F.toLinearEquiv ?_\n  have :\n    (F : supported M R s → ↥s →₀ M) =\n      (lsubtypeDomain s : (α →₀ M) →ₗ[R] s →₀ M).comp (Submodule.subtype (supported M R s)) :=\n    rfl\n  rw [this]\n  exact LinearMap.isLinear _\n\n"}
{"name":"Finsupp.supportedEquivFinsupp_symm_apply_coe","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ns : Set α\ninst✝ : DecidablePred fun x => Membership.mem s x\nf : Finsupp (↑s) M\n⊢ Eq (↑((Finsupp.supportedEquivFinsupp s).symm f)) f.extendDomain","decl":"@[simp] theorem supportedEquivFinsupp_symm_apply_coe (s : Set α) [DecidablePred (· ∈ s)]\n    (f : s →₀ M) : (supportedEquivFinsupp (R := R) s).symm f = f.extendDomain := by\n  convert restrictSupportEquiv_symm_apply_coe ..\n\n"}
{"name":"Finsupp.supported_comap_lmapDomain","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα' : Type u_7\nf : α → α'\ns : Set α'\n⊢ LE.le (Finsupp.supported M R (Set.preimage f s)) (Submodule.comap (Finsupp.lmapDomain M R f) (Finsupp.supported M R s))","decl":"theorem supported_comap_lmapDomain (f : α → α') (s : Set α') :\n    supported M R (f ⁻¹' s) ≤ (supported M R s).comap (lmapDomain M R f) := by\n  classical\n  intro l (hl : (l.support : Set α) ⊆ f ⁻¹' s)\n  show ↑(mapDomain f l).support ⊆ s\n  rw [← Set.image_subset_iff, ← Finset.coe_image] at hl\n  exact Set.Subset.trans mapDomain_support hl\n\n"}
{"name":"Finsupp.lmapDomain_supported","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα' : Type u_7\nf : α → α'\ns : Set α\n⊢ Eq (Submodule.map (Finsupp.lmapDomain M R f) (Finsupp.supported M R s)) (Finsupp.supported M R (Set.image f s))","decl":"theorem lmapDomain_supported (f : α → α') (s : Set α) :\n    (supported M R s).map (lmapDomain M R f) = supported M R (f '' s) := by\n  classical\n  cases isEmpty_or_nonempty α\n  · simp [s.eq_empty_of_isEmpty]\n  refine\n    le_antisymm\n      (map_le_iff_le_comap.2 <|\n        le_trans (supported_mono <| Set.subset_preimage_image _ _)\n          (supported_comap_lmapDomain M R _ _))\n      ?_\n  intro l hl\n  refine ⟨(lmapDomain M R (Function.invFunOn f s) : (α' →₀ M) →ₗ[R] α →₀ M) l, fun x hx => ?_, ?_⟩\n  · rcases Finset.mem_image.1 (mapDomain_support hx) with ⟨c, hc, rfl⟩\n    exact Function.invFunOn_mem (by simpa using hl hc)\n  · rw [← LinearMap.comp_apply, ← lmapDomain_comp]\n    refine (mapDomain_congr fun c hc => ?_).trans mapDomain_id\n    exact Function.invFunOn_eq (by simpa using hl hc)\n\n"}
{"name":"Finsupp.lmapDomain_disjoint_ker","module":"Mathlib.LinearAlgebra.Finsupp.Supported","initialProofState":"α : Type u_1\nM : Type u_2\nR : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα' : Type u_7\nf : α → α'\ns : Set α\nH : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → Eq (f a) (f b) → Eq a b\n⊢ Disjoint (Finsupp.supported M R s) (LinearMap.ker (Finsupp.lmapDomain M R f))","decl":"theorem lmapDomain_disjoint_ker (f : α → α') {s : Set α}\n    (H : ∀ a ∈ s, ∀ b ∈ s, f a = f b → a = b) :\n    Disjoint (supported M R s) (ker (lmapDomain M R f)) := by\n  rw [disjoint_iff_inf_le]\n  rintro l ⟨h₁, h₂⟩\n  rw [SetLike.mem_coe, mem_ker, lmapDomain_apply, mapDomain] at h₂\n  simp only [mem_bot]; ext x\n  haveI := Classical.decPred fun x => x ∈ s\n  by_cases xs : x ∈ s\n  · have : Finsupp.sum l (fun a => Finsupp.single (f a)) (f x) = 0 := by\n      rw [h₂]\n      rfl\n    rw [Finsupp.sum_apply, Finsupp.sum_eq_single x, single_eq_same] at this\n    · simpa\n    · intro y hy xy\n      simp only [SetLike.mem_coe, mem_supported, subset_def, Finset.mem_coe, mem_support_iff] at h₁\n      simp [mt (H _ (h₁ _ hy) _ xs) xy]\n    · simp +contextual\n  · by_contra h\n    exact xs (h₁ <| Finsupp.mem_support_iff.2 h)\n\n"}
