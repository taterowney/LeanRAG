{"name":"CategoryTheory.instCategorySimplicialObject_id_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nX : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simps!]\ninstance : Category (SimplicialObject C) := by\n  dsimp only [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instCategorySimplicialObject_comp_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Functor (Opposite SimplexCategory) C\nα : Quiver.Hom X✝ Y✝\nβ : Quiver.Hom Y✝ Z✝\nX : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.comp α β).app X) (CategoryTheory.CategoryStruct.comp (α.app X) (β.app X))","decl":"@[simps!]\ninstance : Category (SimplicialObject C) := by\n  dsimp only [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.SimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (SimplicialObject C) := by\n  dsimp [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasLimits (CategoryTheory.SimplicialObject C)","decl":"instance [HasLimits C] : HasLimits (SimplicialObject C) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.SimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (SimplicialObject C) := by\n  dsimp [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasColimits (CategoryTheory.SimplicialObject C)","decl":"instance [HasColimits C] : HasColimits (SimplicialObject C) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.SimplicialObject.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject C\nf g : Quiver.Hom X Y\nh : ∀ (n : Opposite SimplexCategory), Eq (f.app n) (g.app n)\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : SimplicialObject C} (f g : X ⟶ Y)\n    (h : ∀ (n : SimplexCategoryᵒᵖ), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.SimplicialObject.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (∀ (n : Opposite SimplexCategory), Eq (f.app n) (g.app n))","decl":"@[ext]\nlemma hom_ext {X Y : SimplicialObject C} (f g : X ⟶ Y)\n    (h : ∀ (n : SimplexCategoryᵒᵖ), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.SimplicialObject.eqToIso_refl","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nh : Eq n n\n⊢ Eq (X.eqToIso h) (CategoryTheory.Iso.refl (X.obj { unop := SimplexCategory.mk n }))","decl":"@[simp]\ntheorem eqToIso_refl {n : ℕ} (h : n = n) : X.eqToIso h = Iso.refl _ := by\n  ext\n  simp [eqToIso]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j.succ) (X.δ i)) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (X.δ j))","decl":"/-- The generic case of the first simplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ {n} {i j : Fin (n + 2)} (H : i ≤ j) :\n    X.δ j.succ ≫ X.δ i = X.δ (Fin.castSucc i) ≫ X.δ j := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j.succ) (CategoryTheory.CategoryStruct.comp (X.δ i) h)) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.δ j) h))","decl":"/-- The generic case of the first simplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ {n} {i j : Fin (n + 2)} (H : i ≤ j) :\n    X.δ j.succ ≫ X.δ i = X.δ (Fin.castSucc i) ≫ X.δ j := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (CategoryTheory.CategoryStruct.comp (X.δ i) h)) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.δ (j.pred ⋯)) h))","decl":"@[reassoc]\ntheorem δ_comp_δ' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.δ j ≫ X.δ i =\n      X.δ (Fin.castSucc i) ≫\n        X.δ (j.pred fun (hj : j = 0) => by simp [hj, Fin.not_lt_zero] at H) := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ' H]\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (X.δ i)) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (X.δ (j.pred ⋯)))","decl":"@[reassoc]\ntheorem δ_comp_δ' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.δ j ≫ X.δ i =\n      X.δ (Fin.castSucc i) ≫\n        X.δ (j.pred fun (hj : j = 0) => by simp [hj, Fin.not_lt_zero] at H) := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ' H]\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ''_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j.succ) (CategoryTheory.CategoryStruct.comp (X.δ (i.castLT ⋯)) h)) (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ j) h))","decl":"@[reassoc]\ntheorem δ_comp_δ'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ≤ Fin.castSucc j) :\n    X.δ j.succ ≫ X.δ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) =\n      X.δ i ≫ X.δ j := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ'' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ''","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j.succ) (X.δ (i.castLT ⋯))) (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ j))","decl":"@[reassoc]\ntheorem δ_comp_δ'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ≤ Fin.castSucc j) :\n    X.δ j.succ ≫ X.δ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) =\n      X.δ i ≫ X.δ j := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ'' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.δ i) h)) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (CategoryTheory.CategoryStruct.comp (X.δ i) h))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ_self {n} {i : Fin (n + 2)} :\n    X.δ (Fin.castSucc i) ≫ X.δ i = X.δ i.succ ≫ X.δ i := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (X.δ i)) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (X.δ i))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ_self {n} {i : Fin (n + 2)} :\n    X.δ (Fin.castSucc i) ≫ X.δ i = X.δ i.succ ≫ X.δ i := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 3)\ni : Fin (HAdd.hAdd n 2)\nH : Eq j i.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (X.δ i)) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (X.δ i))","decl":"@[reassoc]\ntheorem δ_comp_δ_self' {n} {j : Fin (n + 3)} {i : Fin (n + 2)} (H : j = Fin.castSucc i) :\n    X.δ j ≫ X.δ i = X.δ i.succ ≫ X.δ i := by\n  subst H\n  rw [δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_δ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 3)\ni : Fin (HAdd.hAdd n 2)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (CategoryTheory.CategoryStruct.comp (X.δ i) h)) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (CategoryTheory.CategoryStruct.comp (X.δ i) h))","decl":"@[reassoc]\ntheorem δ_comp_δ_self' {n} {j : Fin (n + 3)} {i : Fin (n + 2)} (H : j = Fin.castSucc i) :\n    X.δ j ≫ X.δ i = X.δ i.succ ≫ X.δ i := by\n  subst H\n  rw [δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_of_le_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j.succ) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.σ j) h))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :\n    X.σ j.succ ≫ X.δ (Fin.castSucc i) = X.δ i ≫ X.σ j := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_le H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_of_le","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j.succ) (X.δ i.castSucc)) (CategoryTheory.CategoryStruct.comp (X.δ i) (X.σ j))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :\n    X.σ j.succ ≫ X.δ (Fin.castSucc i) = X.δ i ≫ X.σ j := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_le H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (X.δ i.castSucc)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_self {n} {i : Fin (n + 1)} : X.σ i ≫ X.δ (Fin.castSucc i) = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_self, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) h)) h","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_self {n} {i : Fin (n + 1)} : X.σ i ≫ X.δ (Fin.castSucc i) = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_self, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (X.δ j)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"@[reassoc]\ntheorem δ_comp_σ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.σ i ≫ X.δ j = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (X.δ j) h)) h","decl":"@[reassoc]\ntheorem δ_comp_σ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.σ i ≫ X.δ j = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_succ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (X.δ i.succ)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : X.σ i ≫ X.δ i.succ = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_succ, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_succ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) h)) h","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : X.σ i ≫ X.δ i.succ = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_succ, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_succ'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (X.δ j) h)) h","decl":"@[reassoc]\ntheorem δ_comp_σ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.σ i ≫ X.δ j = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_succ]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_succ'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (X.δ j)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"@[reassoc]\ntheorem δ_comp_σ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.σ i ≫ X.δ j = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_succ]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_of_gt","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j.castSucc) (X.δ i.succ)) (CategoryTheory.CategoryStruct.comp (X.δ i) (X.σ j))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.σ (Fin.castSucc j) ≫ X.δ i.succ = X.δ i ≫ X.σ j := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_of_gt_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j.castSucc) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) h)) (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.σ j) h))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.σ (Fin.castSucc j) ≫ X.δ i.succ = X.δ i ≫ X.σ j := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_of_gt'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j) (X.δ i)) (CategoryTheory.CategoryStruct.comp (X.δ (i.pred ⋯)) (X.σ (j.castLT ⋯)))","decl":"@[reassoc]\ntheorem δ_comp_σ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.σ j ≫ X.δ i =\n      X.δ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) ≫\n        X.σ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_comp_σ_of_gt'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j) (CategoryTheory.CategoryStruct.comp (X.δ i) h)) (CategoryTheory.CategoryStruct.comp (X.δ (i.pred ⋯)) (CategoryTheory.CategoryStruct.comp (X.σ (j.castLT ⋯)) h))","decl":"@[reassoc]\ntheorem δ_comp_σ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.σ j ≫ X.δ i =\n      X.δ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) ≫\n        X.σ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.σ_comp_σ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j) (X.σ i.castSucc)) (CategoryTheory.CategoryStruct.comp (X.σ i) (X.σ j.succ))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :\n    X.σ j ≫ X.σ (Fin.castSucc i) = X.σ i ≫ X.σ j.succ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.σ_comp_σ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.σ_comp_σ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ j) (CategoryTheory.CategoryStruct.comp (X.σ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (X.σ j.succ) h))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :\n    X.σ j ≫ X.σ (Fin.castSucc i) = X.σ i ≫ X.σ j.succ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.σ_comp_σ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (f.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) (X'.δ i))","decl":"@[reassoc (attr := simp)]\ntheorem δ_naturality {X' X : SimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 2)) :\n    X.δ i ≫ f.app (op [n]) = f.app (op [n + 1]) ≫ X'.δ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.δ_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X'.obj { unop := SimplexCategory.mk n }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk n }) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) (CategoryTheory.CategoryStruct.comp (X'.δ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem δ_naturality {X' X : SimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 2)) :\n    X.δ i ≫ f.app (op [n]) = f.app (op [n + 1]) ≫ X'.δ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.σ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) })) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk n }) (X'.σ i))","decl":"@[reassoc (attr := simp)]\ntheorem σ_naturality {X' X : SimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 1)) :\n    X.σ i ≫ f.app (op [n + 1]) = f.app (op [n]) ≫ X'.σ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.σ_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X'.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk n }) (CategoryTheory.CategoryStruct.comp (X'.σ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem σ_naturality {X' X : SimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 1)) :\n    X.σ i ≫ f.app (op [n + 1]) = f.app (op [n]) ≫ X'.σ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nX : Opposite SimplexCategory\n⊢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ SimplicialObject C ⥤ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Functor (Opposite SimplexCategory) C\nα : Quiver.Hom X✝ Y✝\nX : Opposite SimplexCategory\n⊢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).obj H).map α).app X) (H.map (α.app X))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ SimplicialObject C ⥤ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nX✝ Y✝ : Opposite SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ SimplicialObject C ⥤ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nX✝ Y✝ : CategoryTheory.Functor C D\nτ : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nc : Opposite SimplexCategory\n⊢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).map τ).app F).app c) (τ.app (F.obj c))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ SimplicialObject C ⥤ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (SimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasLimits (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} [HasLimits C] : HasLimits (SimplicialObject.Truncated C n) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (SimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasColimits (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} [HasColimits C] : HasColimits (SimplicialObject.Truncated C n) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nX : Opposite (SimplexCategory.Truncated n)\n⊢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nα : Quiver.Hom X✝ Y✝\nX : Opposite (SimplexCategory.Truncated n)\n⊢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).obj H).map α).app X) (H.map (α.app X))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nX✝ Y✝ : CategoryTheory.Functor C D\nτ : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nc : Opposite (SimplexCategory.Truncated n)\n⊢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).map τ).app F).app c) (τ.app (F.obj c))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nX✝ Y✝ : Opposite (SimplexCategory.Truncated n)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.instIsLeftKanExtensionOppositeTruncatedSimplexCategoryObjSkAppTruncatedUnitSkAdjTruncation","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\n⊢ CategoryTheory.Functor.IsLeftKanExtension ((CategoryTheory.SimplicialObject.sk n).obj X) ((CategoryTheory.SimplicialObject.skAdj n).unit.app ((CategoryTheory.SimplicialObject.truncation n).obj X))","decl":"instance : ((sk n).obj X).IsLeftKanExtension ((skAdj n).unit.app _) := by\n  dsimp [sk, skAdj]\n  rw [lanAdjunction_unit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instIsRightKanExtensionOppositeTruncatedSimplexCategoryObjCoskAppTruncatedCounitCoskAdjTruncation","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\n⊢ CategoryTheory.Functor.IsRightKanExtension ((CategoryTheory.SimplicialObject.cosk n).obj X) ((CategoryTheory.SimplicialObject.coskAdj n).counit.app ((CategoryTheory.SimplicialObject.truncation n).obj X))","decl":"instance : ((cosk n).obj X).IsRightKanExtension ((coskAdj n).counit.app _) := by\n  dsimp [cosk, coskAdj]\n  rw [ranAdjunction_counit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.cosk_reflective","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝¹ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseRightKanExtension F\n⊢ CategoryTheory.IsIso (CategoryTheory.SimplicialObject.coskAdj n).counit","decl":"instance cosk_reflective : IsIso (coskAdj (C := C) n).counit :=\n  reflective' (SimplexCategory.Truncated.inclusion n).op\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.sk_coreflective","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝¹ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseLeftKanExtension F\n⊢ CategoryTheory.IsIso (CategoryTheory.SimplicialObject.skAdj n).unit","decl":"instance sk_coreflective : IsIso (skAdj (C := C) n).unit :=\n  coreflective' (SimplexCategory.Truncated.inclusion n).op\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.cosk.full","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝¹ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseRightKanExtension F\n⊢ (CategoryTheory.SimplicialObject.Truncated.cosk n).Full","decl":"instance cosk.full : (Truncated.cosk (C := C) n).Full := FullyFaithful.full (cosk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.cosk.faithful","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝¹ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseRightKanExtension F\n⊢ (CategoryTheory.SimplicialObject.Truncated.cosk n).Faithful","decl":"instance cosk.faithful : (Truncated.cosk (C := C) n).Faithful :=\n  FullyFaithful.faithful (cosk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.sk.full","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝¹ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseLeftKanExtension F\n⊢ (CategoryTheory.SimplicialObject.Truncated.sk n).Full","decl":"instance sk.full : (Truncated.sk (C := C) n).Full := FullyFaithful.full (sk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.sk.faithful","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝¹ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\ninst✝ : ∀ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseLeftKanExtension F\n⊢ (CategoryTheory.SimplicialObject.Truncated.sk n).Faithful","decl":"instance sk.faithful : (Truncated.sk (C := C) n).Faithful :=\n  FullyFaithful.faithful (sk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_id_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nX : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.id X✝).left.app X) (CategoryTheory.CategoryStruct.id (X✝.left.obj X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_comp_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_id_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\n⊢ Eq (CategoryTheory.CategoryStruct.id X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_comp_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\nX : Opposite SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).left.app X) (CategoryTheory.CategoryStruct.comp (f.left.app X) (g.left.app X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ⟶ Y) (h₁ : f.left = g.left) (h₂ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h₁ h₂\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf g : Quiver.Hom X Y\nh₁ : Eq f.left g.left\nh₂ : Eq f.right g.right\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ⟶ Y) (h₁ : f.left = g.left) (h₂ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h₁ h₂\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.drop_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.drop.map f) f.left","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ⥤ SimplicialObject C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.drop_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.drop.obj X) X.left","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ⥤ SimplicialObject C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.point_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.point.obj X) X.right","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ⥤ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.point_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.point.map f) f.right","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ⥤ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_obj_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X).right (CategoryTheory.SimplicialObject.Augmented.point.obj X)","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map η :=\n    { left := (drop.map η).app _\n      right := point.map η\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_obj_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X).left ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map η :=\n    { left := (drop.map η).app _\n      right := point.map η\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_map_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.SimplicialObject.Augmented C\nη : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.map η).right (CategoryTheory.SimplicialObject.Augmented.point.map η)","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map η :=\n    { left := (drop.map η).app _\n      right := point.map η\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_obj_hom","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X).hom (X.hom.app { unop := SimplexCategory.mk 0 })","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map η :=\n    { left := (drop.map η).app _\n      right := point.map η\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_map_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.SimplicialObject.Augmented C\nη : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.map η).left ((CategoryTheory.SimplicialObject.Augmented.drop.map η).app { unop := SimplexCategory.mk 0 })","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map η :=\n    { left := (drop.map η).app _\n      right := point.map η\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.w₀_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (((CategoryTheory.SimplicialObject.const C).obj Y.right).obj { unop := SimplexCategory.mk 0 }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.SimplicialObject.Augmented.drop.map f).app { unop := SimplexCategory.mk 0 }) (CategoryTheory.CategoryStruct.comp (Y.hom.app { unop := SimplexCategory.mk 0 }) h)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SimplicialObject.Augmented.point.map f) h))","decl":"/-- The compatibility of a morphism with the augmentation, on 0-simplices -/\n@[reassoc]\ntheorem w₀ {X Y : Augmented C} (f : X ⟶ Y) :\n    (Augmented.drop.map f).app (op (SimplexCategory.mk 0)) ≫ Y.hom.app (op (SimplexCategory.mk 0)) =\n      X.hom.app (op (SimplexCategory.mk 0)) ≫ Augmented.point.map f := by\n  convert congr_app f.w (op (SimplexCategory.mk 0))\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.w₀","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.SimplicialObject.Augmented.drop.map f).app { unop := SimplexCategory.mk 0 }) (Y.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.SimplicialObject.Augmented.point.map f))","decl":"/-- The compatibility of a morphism with the augmentation, on 0-simplices -/\n@[reassoc]\ntheorem w₀ {X Y : Augmented C} (f : X ⟶ Y) :\n    (Augmented.drop.map f).app (op (SimplexCategory.mk 0)) ≫ Y.hom.app (op (SimplexCategory.mk 0)) =\n      X.hom.app (op (SimplexCategory.mk 0)) ≫ Augmented.point.map f := by\n  convert congr_app f.w (op (SimplexCategory.mk 0))\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.whiskering_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\n⊢ Eq ((CategoryTheory.SimplicialObject.Augmented.whiskering C D).obj F) (CategoryTheory.SimplicialObject.Augmented.whiskeringObj C D F)","decl":"/-- Functor composition induces a functor on augmented simplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ⥤ D) ⥤ Augmented C ⥤ Augmented D where\n  obj := whiskeringObj _ _\n  map η :=\n    { app := fun A =>\n        { left := whiskerLeft _ η\n          right := η.app _\n          w := by\n            ext n\n            dsimp\n            rw [Category.comp_id, Category.comp_id, η.naturality] } }\n  map_comp := fun _ _ => by ext <;> rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.whiskering_map_app_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX✝ Y✝ : CategoryTheory.Functor C D\nη : Quiver.Hom X✝ Y✝\nA : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq (((CategoryTheory.SimplicialObject.Augmented.whiskering C D).map η).app A).right (η.app (CategoryTheory.SimplicialObject.Augmented.point.obj A))","decl":"/-- Functor composition induces a functor on augmented simplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ⥤ D) ⥤ Augmented C ⥤ Augmented D where\n  obj := whiskeringObj _ _\n  map η :=\n    { app := fun A =>\n        { left := whiskerLeft _ η\n          right := η.app _\n          w := by\n            ext n\n            dsimp\n            rw [Category.comp_id, Category.comp_id, η.naturality] } }\n  map_comp := fun _ _ => by ext <;> rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.whiskering_map_app_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX✝ Y✝ : CategoryTheory.Functor C D\nη : Quiver.Hom X✝ Y✝\nA : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq (((CategoryTheory.SimplicialObject.Augmented.whiskering C D).map η).app A).left (CategoryTheory.whiskerLeft (CategoryTheory.SimplicialObject.Augmented.drop.obj A) η)","decl":"/-- Functor composition induces a functor on augmented simplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ⥤ D) ⥤ Augmented C ⥤ Augmented D where\n  obj := whiskeringObj _ _\n  map η :=\n    { app := fun A =>\n        { left := whiskerLeft _ η\n          right := η.app _\n          w := by\n            ext n\n            dsimp\n            rw [Category.comp_id, Category.comp_id, η.naturality] } }\n  map_comp := fun _ _ => by ext <;> rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.augment_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX₀ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X₀\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g₁.op) f) (CategoryTheory.CategoryStruct.comp (X.map g₂.op) f)\nx✝ : Opposite SimplexCategory\n⊢ Eq ((X.augment X₀ f w).hom.app x✝) (CategoryTheory.CategoryStruct.comp (X.map ((SimplexCategory.mk 0).const (Opposite.unop x✝) 0).op) f)","decl":"/-- Augment a simplicial object with an object. -/\n@[simps]\ndef augment (X : SimplicialObject C) (X₀ : C) (f : X _[0] ⟶ X₀)\n    (w : ∀ (i : SimplexCategory) (g₁ g₂ : ([0] : SimplexCategory) ⟶ i),\n      X.map g₁.op ≫ f = X.map g₂.op ≫ f) :\n    SimplicialObject.Augmented C where\n  left := X\n  right := X₀\n  hom :=\n    { app := fun _ => X.map (SimplexCategory.const _ _ 0).op ≫ f\n      naturality := by\n        intro i j g\n        dsimp\n        rw [← g.op_unop]\n        simpa only [← X.map_comp, ← Category.assoc, Category.comp_id, ← op_comp] using w _ _ _ }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.SimplicialObject.augment_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX₀ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X₀\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g₁.op) f) (CategoryTheory.CategoryStruct.comp (X.map g₂.op) f)\n⊢ Eq (X.augment X₀ f w).left X","decl":"/-- Augment a simplicial object with an object. -/\n@[simps]\ndef augment (X : SimplicialObject C) (X₀ : C) (f : X _[0] ⟶ X₀)\n    (w : ∀ (i : SimplexCategory) (g₁ g₂ : ([0] : SimplexCategory) ⟶ i),\n      X.map g₁.op ≫ f = X.map g₂.op ≫ f) :\n    SimplicialObject.Augmented C where\n  left := X\n  right := X₀\n  hom :=\n    { app := fun _ => X.map (SimplexCategory.const _ _ 0).op ≫ f\n      naturality := by\n        intro i j g\n        dsimp\n        rw [← g.op_unop]\n        simpa only [← X.map_comp, ← Category.assoc, Category.comp_id, ← op_comp] using w _ _ _ }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.SimplicialObject.augment_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX₀ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X₀\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g₁.op) f) (CategoryTheory.CategoryStruct.comp (X.map g₂.op) f)\n⊢ Eq (X.augment X₀ f w).right X₀","decl":"/-- Augment a simplicial object with an object. -/\n@[simps]\ndef augment (X : SimplicialObject C) (X₀ : C) (f : X _[0] ⟶ X₀)\n    (w : ∀ (i : SimplexCategory) (g₁ g₂ : ([0] : SimplexCategory) ⟶ i),\n      X.map g₁.op ≫ f = X.map g₂.op ≫ f) :\n    SimplicialObject.Augmented C where\n  left := X\n  right := X₀\n  hom :=\n    { app := fun _ => X.map (SimplexCategory.const _ _ 0).op ≫ f\n      naturality := by\n        intro i j g\n        dsimp\n        rw [← g.op_unop]\n        simpa only [← X.map_comp, ← Category.assoc, Category.comp_id, ← op_comp] using w _ _ _ }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.SimplicialObject.augment_hom_zero","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX₀ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X₀\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g₁.op) f) (CategoryTheory.CategoryStruct.comp (X.map g₂.op) f)\n⊢ Eq ((X.augment X₀ f w).hom.app { unop := SimplexCategory.mk 0 }) f","decl":"theorem augment_hom_zero (X : SimplicialObject C) (X₀ : C) (f : X _[0] ⟶ X₀) (w) :\n    (X.augment X₀ f w).hom.app (op [0]) = f := by simp\n\n"}
{"name":"CategoryTheory.instCategoryCosimplicialObject_comp_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Functor SimplexCategory C\nα : Quiver.Hom X✝ Y✝\nβ : Quiver.Hom Y✝ Z✝\nX : SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.comp α β).app X) (CategoryTheory.CategoryStruct.comp (α.app X) (β.app X))","decl":"@[simps!]\ninstance : Category (CosimplicialObject C) := by\n  dsimp only [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instCategoryCosimplicialObject_id_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor SimplexCategory C\nX : SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simps!]\ninstance : Category (CosimplicialObject C) := by\n  dsimp only [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.CosimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (CosimplicialObject C) := by\n  dsimp [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasLimits (CategoryTheory.CosimplicialObject C)","decl":"instance [HasLimits C] : HasLimits (CosimplicialObject C) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.CosimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (CosimplicialObject C) := by\n  dsimp [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasColimits (CategoryTheory.CosimplicialObject C)","decl":"instance [HasColimits C] : HasColimits (CosimplicialObject C) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.CosimplicialObject.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject C\nf g : Quiver.Hom X Y\nh : ∀ (n : SimplexCategory), Eq (f.app n) (g.app n)\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : CosimplicialObject C} (f g : X ⟶ Y)\n    (h : ∀ (n : SimplexCategory), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (∀ (n : SimplexCategory), Eq (f.app n) (g.app n))","decl":"@[ext]\nlemma hom_ext {X Y : CosimplicialObject C} (f g : X ⟶ Y)\n    (h : ∀ (n : SimplexCategory), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.eqToIso_refl","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nh : Eq n n\n⊢ Eq (X.eqToIso h) (CategoryTheory.Iso.refl (X.obj (SimplexCategory.mk n)))","decl":"@[simp]\ntheorem eqToIso_refl {n : ℕ} (h : n = n) : X.eqToIso h = Iso.refl _ := by\n  ext\n  simp [eqToIso]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ j.succ)) (CategoryTheory.CategoryStruct.comp (X.δ j) (X.δ i.castSucc))","decl":"/-- The generic case of the first cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ {n} {i j : Fin (n + 2)} (H : i ≤ j) :\n    X.δ i ≫ X.δ j.succ = X.δ j ≫ X.δ (Fin.castSucc i) := by\n  dsimp [δ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_δ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ j.succ) h)) (CategoryTheory.CategoryStruct.comp (X.δ j) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) h))","decl":"/-- The generic case of the first cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ {n} {i j : Fin (n + 2)} (H : i ≤ j) :\n    X.δ i ≫ X.δ j.succ = X.δ j ≫ X.δ (Fin.castSucc i) := by\n  dsimp [δ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_δ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ j)) (CategoryTheory.CategoryStruct.comp (X.δ (j.pred ⋯)) (X.δ i.castSucc))","decl":"@[reassoc]\ntheorem δ_comp_δ' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.δ i ≫ X.δ j =\n      X.δ (j.pred fun (hj : j = 0) => by simp only [hj, Fin.not_lt_zero] at H) ≫\n        X.δ (Fin.castSucc i) := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ j) h)) (CategoryTheory.CategoryStruct.comp (X.δ (j.pred ⋯)) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) h))","decl":"@[reassoc]\ntheorem δ_comp_δ' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.δ i ≫ X.δ j =\n      X.δ (j.pred fun (hj : j = 0) => by simp only [hj, Fin.not_lt_zero] at H) ≫\n        X.δ (Fin.castSucc i) := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ''","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ (i.castLT ⋯)) (X.δ j.succ)) (CategoryTheory.CategoryStruct.comp (X.δ j) (X.δ i))","decl":"@[reassoc]\ntheorem δ_comp_δ'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ≤ Fin.castSucc j) :\n    X.δ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) ≫ X.δ j.succ =\n      X.δ j ≫ X.δ i := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ'' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ''_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ (i.castLT ⋯)) (CategoryTheory.CategoryStruct.comp (X.δ j.succ) h)) (CategoryTheory.CategoryStruct.comp (X.δ j) (CategoryTheory.CategoryStruct.comp (X.δ i) h))","decl":"@[reassoc]\ntheorem δ_comp_δ'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ≤ Fin.castSucc j) :\n    X.δ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) ≫ X.δ j.succ =\n      X.δ j ≫ X.δ i := by\n  dsimp [δ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_δ'' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) h))","decl":"/-- The special case of the first cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ_self {n} {i : Fin (n + 2)} :\n    X.δ i ≫ X.δ (Fin.castSucc i) = X.δ i ≫ X.δ i.succ := by\n  dsimp [δ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ i.castSucc)) (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ i.succ))","decl":"/-- The special case of the first cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_δ_self {n} {i : Fin (n + 2)} :\n    X.δ i ≫ X.δ (Fin.castSucc i) = X.δ i ≫ X.δ i.succ := by\n  dsimp [δ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ j)) (CategoryTheory.CategoryStruct.comp (X.δ i) (X.δ i.succ))","decl":"@[reassoc]\ntheorem δ_comp_δ_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = Fin.castSucc i) :\n    X.δ i ≫ X.δ j = X.δ i ≫ X.δ i.succ := by\n  subst H\n  rw [δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_δ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ j) h)) (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.δ i.succ) h))","decl":"@[reassoc]\ntheorem δ_comp_δ_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = Fin.castSucc i) :\n    X.δ i ≫ X.δ j = X.δ i ≫ X.δ i.succ := by\n  subst H\n  rw [δ_comp_δ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_of_le","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (X.σ j.succ)) (CategoryTheory.CategoryStruct.comp (X.σ j) (X.δ i))","decl":"/-- The second cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :\n    X.δ (Fin.castSucc i) ≫ X.σ j.succ = X.σ j ≫ X.δ i := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_of_le H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_of_le_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.σ j.succ) h)) (CategoryTheory.CategoryStruct.comp (X.σ j) (CategoryTheory.CategoryStruct.comp (X.δ i) h))","decl":"/-- The second cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ≤ Fin.castSucc j) :\n    X.δ (Fin.castSucc i) ≫ X.σ j.succ = X.σ j ≫ X.δ i := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_of_le H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.σ i) h)) h","decl":"/-- The first part of the third cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_self {n} {i : Fin (n + 1)} : X.δ (Fin.castSucc i) ≫ X.σ i = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_self, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.castSucc) (X.σ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"/-- The first part of the third cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_self {n} {i : Fin (n + 1)} : X.δ (Fin.castSucc i) ≫ X.σ i = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_self, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (CategoryTheory.CategoryStruct.comp (X.σ i) h)) h","decl":"@[reassoc]\ntheorem δ_comp_σ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.δ j ≫ X.σ i = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (X.σ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"@[reassoc]\ntheorem δ_comp_σ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.δ j ≫ X.σ i = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_succ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (CategoryTheory.CategoryStruct.comp (X.σ i) h)) h","decl":"/-- The second part of the third cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : X.δ i.succ ≫ X.σ i = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_succ, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_succ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (X.σ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"/-- The second part of the third cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_succ {n} {i : Fin (n + 1)} : X.δ i.succ ≫ X.σ i = 𝟙 _ := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_succ, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_succ'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (X.σ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"@[reassoc]\ntheorem δ_comp_σ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.δ j ≫ X.σ i = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_succ]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_succ'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ j) (CategoryTheory.CategoryStruct.comp (X.σ i) h)) h","decl":"@[reassoc]\ntheorem δ_comp_σ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.δ j ≫ X.σ i = 𝟙 _ := by\n  subst H\n  rw [δ_comp_σ_succ]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_of_gt","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (X.σ j.castSucc)) (CategoryTheory.CategoryStruct.comp (X.σ j) (X.δ i))","decl":"/-- The fourth cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.δ i.succ ≫ X.σ (Fin.castSucc j) = X.σ j ≫ X.δ i := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_of_gt H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_of_gt_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i.succ) (CategoryTheory.CategoryStruct.comp (X.σ j.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.σ j) (CategoryTheory.CategoryStruct.comp (X.δ i) h))","decl":"/-- The fourth cosimplicial identity -/\n@[reassoc]\ntheorem δ_comp_σ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.δ i.succ ≫ X.σ (Fin.castSucc j) = X.σ j ≫ X.δ i := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.δ_comp_σ_of_gt H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_of_gt'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (X.σ j)) (CategoryTheory.CategoryStruct.comp (X.σ (j.castLT ⋯)) (X.δ (i.pred ⋯)))","decl":"@[reassoc]\ntheorem δ_comp_σ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.δ i ≫ X.σ j =\n      X.σ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ≫\n        X.δ (i.pred <|\n          fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_comp_σ_of_gt'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (X.σ j) h)) (CategoryTheory.CategoryStruct.comp (X.σ (j.castLT ⋯)) (CategoryTheory.CategoryStruct.comp (X.δ (i.pred ⋯)) h))","decl":"@[reassoc]\ntheorem δ_comp_σ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.δ i ≫ X.σ j =\n      X.σ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ≫\n        X.δ (i.pred <|\n          fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, ← op_comp, SimplexCategory.δ_comp_σ_of_gt' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.σ_comp_σ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.σ j) h)) (CategoryTheory.CategoryStruct.comp (X.σ j.succ) (CategoryTheory.CategoryStruct.comp (X.σ i) h))","decl":"/-- The fifth cosimplicial identity -/\n@[reassoc]\ntheorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :\n    X.σ (Fin.castSucc i) ≫ X.σ j = X.σ j.succ ≫ X.σ i := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.σ_comp_σ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.σ_comp_σ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i.castSucc) (X.σ j)) (CategoryTheory.CategoryStruct.comp (X.σ j.succ) (X.σ i))","decl":"/-- The fifth cosimplicial identity -/\n@[reassoc]\ntheorem σ_comp_σ {n} {i j : Fin (n + 1)} (H : i ≤ j) :\n    X.σ (Fin.castSucc i) ≫ X.σ j = X.σ j.succ ≫ X.σ i := by\n  dsimp [δ, σ]\n  simp only [← X.map_comp, SimplexCategory.σ_comp_σ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X'.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk (HAdd.hAdd n 1))) h)) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk n)) (CategoryTheory.CategoryStruct.comp (X'.δ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem δ_naturality {X' X : CosimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 2)) :\n    X.δ i ≫ f.app (SimplexCategory.mk (n + 1)) = f.app (SimplexCategory.mk n) ≫ X'.δ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.δ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.δ i) (f.app (SimplexCategory.mk (HAdd.hAdd n 1)))) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk n)) (X'.δ i))","decl":"@[reassoc (attr := simp)]\ntheorem δ_naturality {X' X : CosimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 2)) :\n    X.δ i ≫ f.app (SimplexCategory.mk (n + 1)) = f.app (SimplexCategory.mk n) ≫ X'.δ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.σ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (f.app (SimplexCategory.mk n))) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk (HAdd.hAdd n 1))) (X'.σ i))","decl":"@[reassoc (attr := simp)]\ntheorem σ_naturality {X' X : CosimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 1)) :\n    X.σ i ≫ f.app (SimplexCategory.mk n) = f.app (SimplexCategory.mk (n + 1)) ≫ X'.σ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.σ_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X'.obj (SimplexCategory.mk n)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.σ i) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk n)) h)) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (X'.σ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem σ_naturality {X' X : CosimplicialObject C} (f : X ⟶ X') {n : ℕ} (i : Fin (n + 1)) :\n    X.σ i ≫ f.app (SimplexCategory.mk n) = f.app (SimplexCategory.mk (n + 1)) ≫ X'.σ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor SimplexCategory C\nX : SimplexCategory\n⊢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ CosimplicialObject C ⥤ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nX✝ Y✝ : CategoryTheory.Functor C D\nτ : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor SimplexCategory C\nc : SimplexCategory\n⊢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).map τ).app F).app c) (τ.app (F.obj c))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ CosimplicialObject C ⥤ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Functor SimplexCategory C\nα : Quiver.Hom X✝ Y✝\nX : SimplexCategory\n⊢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).obj H).map α).app X) (H.map (α.app X))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ CosimplicialObject C ⥤ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor SimplexCategory C\nX✝ Y✝ : SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ⥤ D) ⥤ CosimplicialObject C ⥤ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (CosimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝ : CategoryTheory.Limits.HasLimits C\n⊢ CategoryTheory.Limits.HasLimits (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} [HasLimits C] : HasLimits (CosimplicialObject.Truncated C n) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (CosimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst✝ : CategoryTheory.Limits.HasColimits C\n⊢ CategoryTheory.Limits.HasColimits (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} [HasColimits C] : HasColimits (CosimplicialObject.Truncated C n) :=\n  ⟨inferInstance⟩\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX✝ Y✝ : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nα : Quiver.Hom X✝ Y✝\nX : SimplexCategory.Truncated n\n⊢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).obj H).map α).app X) (H.map (α.app X))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nX✝ Y✝ : SimplexCategory.Truncated n\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nX✝ Y✝ : CategoryTheory.Functor C D\nτ : Quiver.Hom X✝ Y✝\nF : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nc : SimplexCategory.Truncated n\n⊢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).map τ).app F).app c) (τ.app (F.obj c))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nX : SimplexCategory.Truncated n\n⊢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ⥤ D) ⥤ Truncated C n ⥤ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_id_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nX : SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.id X✝).right.app X) (CategoryTheory.CategoryStruct.id (X✝.right.obj X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_comp_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_comp_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ Z✝ : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X✝ Y✝\ng : Quiver.Hom Y✝ Z✝\nX : SimplexCategory\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).right.app X) (CategoryTheory.CategoryStruct.comp (f.right.app X) (g.right.app X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_id_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\n⊢ Eq (CategoryTheory.CategoryStruct.id X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject.Augmented C\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ⟶ Y) (h₁ : f.left = g.left) (h₂ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h₁ h₂\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject.Augmented C\nf g : Quiver.Hom X Y\nh₁ : Eq f.left g.left\nh₂ : Eq f.right g.right\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ⟶ Y) (h₁ : f.left = g.left) (h₂ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h₁ h₂\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.drop_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.drop.obj X) X.right","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ⥤ CosimplicialObject C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.drop_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.drop.map f) f.right","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ⥤ CosimplicialObject C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.point_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.point.obj X) X.left","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ⥤ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.point_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.point.map f) f.left","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ⥤ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_map_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.CosimplicialObject.Augmented C\nη : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.map η).left η.left","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map η :=\n    { left := point.map η\n      right := (drop.map η).app _\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [← η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_map_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.CosimplicialObject.Augmented C\nη : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.map η).right (η.right.app (SimplexCategory.mk 0))","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map η :=\n    { left := point.map η\n      right := (drop.map η).app _\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [← η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_obj_hom","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented C\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X).hom (X.hom.app (SimplexCategory.mk 0))","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map η :=\n    { left := point.map η\n      right := (drop.map η).app _\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [← η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_obj_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented C\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X).left X.left","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map η :=\n    { left := point.map η\n      right := (drop.map η).app _\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [← η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_obj_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented C\n⊢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X).right (X.right.obj (SimplexCategory.mk 0))","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ⥤ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map η :=\n    { left := point.map η\n      right := (drop.map η).app _\n      w := by\n        dsimp\n        rw [← NatTrans.comp_app]\n        erw [← η.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.whiskering_map_app_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX✝ Y✝ : CategoryTheory.Functor C D\nη : Quiver.Hom X✝ Y✝\nA : CategoryTheory.CosimplicialObject.Augmented C\n⊢ Eq (((CategoryTheory.CosimplicialObject.Augmented.whiskering C D).map η).app A).left (η.app (CategoryTheory.CosimplicialObject.Augmented.point.obj A))","decl":"/-- Functor composition induces a functor on augmented cosimplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ⥤ D) ⥤ Augmented C ⥤ Augmented D where\n  obj := whiskeringObj _ _\n  map η :=\n    { app := fun A =>\n        { left := η.app _\n          right := whiskerLeft _ η\n          w := by\n            ext n\n            dsimp\n            rw [Category.id_comp, Category.id_comp, η.naturality] }\n      naturality := fun _ _ f => by ext <;> dsimp <;> simp }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.whiskering_map_app_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nX✝ Y✝ : CategoryTheory.Functor C D\nη : Quiver.Hom X✝ Y✝\nA : CategoryTheory.CosimplicialObject.Augmented C\n⊢ Eq (((CategoryTheory.CosimplicialObject.Augmented.whiskering C D).map η).app A).right (CategoryTheory.whiskerLeft (CategoryTheory.CosimplicialObject.Augmented.drop.obj A) η)","decl":"/-- Functor composition induces a functor on augmented cosimplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ⥤ D) ⥤ Augmented C ⥤ Augmented D where\n  obj := whiskeringObj _ _\n  map η :=\n    { app := fun A =>\n        { left := η.app _\n          right := whiskerLeft _ η\n          w := by\n            ext n\n            dsimp\n            rw [Category.id_comp, Category.id_comp, η.naturality] }\n      naturality := fun _ _ f => by ext <;> dsimp <;> simp }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.whiskering_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\n⊢ Eq ((CategoryTheory.CosimplicialObject.Augmented.whiskering C D).obj F) (CategoryTheory.CosimplicialObject.Augmented.whiskeringObj C D F)","decl":"/-- Functor composition induces a functor on augmented cosimplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ⥤ D) ⥤ Augmented C ⥤ Augmented D where\n  obj := whiskeringObj _ _\n  map η :=\n    { app := fun A =>\n        { left := η.app _\n          right := whiskerLeft _ η\n          w := by\n            ext n\n            dsimp\n            rw [Category.id_comp, Category.id_comp, η.naturality] }\n      naturality := fun _ _ f => by ext <;> dsimp <;> simp }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX₀ : C\nf : Quiver.Hom X₀ (X.obj (SimplexCategory.mk 0))\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g₁)) (CategoryTheory.CategoryStruct.comp f (X.map g₂))\n⊢ Eq (X.augment X₀ f w).left X₀","decl":"/-- Augment a cosimplicial object with an object. -/\n@[simps]\ndef augment (X : CosimplicialObject C) (X₀ : C) (f : X₀ ⟶ X.obj [0])\n    (w : ∀ (i : SimplexCategory) (g₁ g₂ : ([0] : SimplexCategory) ⟶ i),\n      f ≫ X.map g₁ = f ≫ X.map g₂) : CosimplicialObject.Augmented C where\n  left := X₀\n  right := X\n  hom :=\n    { app := fun _ => f ≫ X.map (SimplexCategory.const _ _ 0)\n      naturality := by\n        intro i j g\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← X.map_comp, w] }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX₀ : C\nf : Quiver.Hom X₀ (X.obj (SimplexCategory.mk 0))\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g₁)) (CategoryTheory.CategoryStruct.comp f (X.map g₂))\n⊢ Eq (X.augment X₀ f w).right X","decl":"/-- Augment a cosimplicial object with an object. -/\n@[simps]\ndef augment (X : CosimplicialObject C) (X₀ : C) (f : X₀ ⟶ X.obj [0])\n    (w : ∀ (i : SimplexCategory) (g₁ g₂ : ([0] : SimplexCategory) ⟶ i),\n      f ≫ X.map g₁ = f ≫ X.map g₂) : CosimplicialObject.Augmented C where\n  left := X₀\n  right := X\n  hom :=\n    { app := fun _ => f ≫ X.map (SimplexCategory.const _ _ 0)\n      naturality := by\n        intro i j g\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← X.map_comp, w] }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX₀ : C\nf : Quiver.Hom X₀ (X.obj (SimplexCategory.mk 0))\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g₁)) (CategoryTheory.CategoryStruct.comp f (X.map g₂))\nx✝ : SimplexCategory\n⊢ Eq ((X.augment X₀ f w).hom.app x✝) (CategoryTheory.CategoryStruct.comp f (X.map ((SimplexCategory.mk 0).const x✝ 0)))","decl":"/-- Augment a cosimplicial object with an object. -/\n@[simps]\ndef augment (X : CosimplicialObject C) (X₀ : C) (f : X₀ ⟶ X.obj [0])\n    (w : ∀ (i : SimplexCategory) (g₁ g₂ : ([0] : SimplexCategory) ⟶ i),\n      f ≫ X.map g₁ = f ≫ X.map g₂) : CosimplicialObject.Augmented C where\n  left := X₀\n  right := X\n  hom :=\n    { app := fun _ => f ≫ X.map (SimplexCategory.const _ _ 0)\n      naturality := by\n        intro i j g\n        dsimp\n        rw [Category.id_comp, Category.assoc, ← X.map_comp, w] }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_hom_zero","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX₀ : C\nf : Quiver.Hom X₀ (X.obj (SimplexCategory.mk 0))\nw : ∀ (i : SimplexCategory) (g₁ g₂ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g₁)) (CategoryTheory.CategoryStruct.comp f (X.map g₂))\n⊢ Eq ((X.augment X₀ f w).hom.app (SimplexCategory.mk 0)) f","decl":"theorem augment_hom_zero (X : CosimplicialObject C) (X₀ : C) (f : X₀ ⟶ X.obj [0]) (w) :\n    (X.augment X₀ f w).hom.app [0] = f := by simp\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_functor_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\nX : SimplexCategory\n⊢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).functor.obj F).obj X) { unop := (Opposite.unop F).obj { unop := X } }","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_counitIso_inv_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Functor SimplexCategory (Opposite C)\nX : SimplexCategory\n⊢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).counitIso.inv.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj X))","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_functor_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\nη : Quiver.Hom X✝ Y✝\nx✝ : SimplexCategory\n⊢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).functor.map η).app x✝) (η.unop.app { unop := x✝ }).op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_counitIso_hom_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Functor SimplexCategory (Opposite C)\nX : SimplexCategory\n⊢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).counitIso.hom.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj X))","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_unitIso_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\n⊢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).unitIso.hom.app X) (Opposite.unop X).rightOpLeftOpIso.hom.op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_inverse_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Functor SimplexCategory (Opposite C)\nη : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).inverse.map η) (CategoryTheory.NatTrans.leftOp η).op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_inverse_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor SimplexCategory (Opposite C)\n⊢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).inverse.obj F) { unop := F.leftOp }","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_unitIso_inv_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\n⊢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).unitIso.inv.app X) (Opposite.unop X).rightOpLeftOpIso.inv.op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_functor_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\nX✝ Y✝ : SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).functor.obj F).map f) ((Opposite.unop F).map f.op).op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)ᵒᵖ ≌ CosimplicialObject Cᵒᵖ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_functor_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.Functor SimplexCategory C)\nα : Quiver.Hom X✝ Y✝\nX : Opposite SimplexCategory\n⊢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).functor.map α).app X) (α.unop.app (Opposite.unop X)).op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_counitIso_inv_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\nX : Opposite SimplexCategory\n⊢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).counitIso.inv.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj X))","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_functor_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor SimplexCategory C)\nX : Opposite SimplexCategory\n⊢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).functor.obj F).obj X) { unop := (Opposite.unop F).obj (Opposite.unop X) }","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_unitIso_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor SimplexCategory C)\n⊢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).unitIso.hom.app X) (Opposite.unop X).opUnopIso.hom.op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_unitIso_inv_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor SimplexCategory C)\n⊢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).unitIso.inv.app X) (Opposite.unop X).opUnopIso.inv.op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_counitIso_hom_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\nX : Opposite SimplexCategory\n⊢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).counitIso.hom.app X✝).app X) (CategoryTheory.CategoryStruct.id (X✝.obj X))","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_inverse_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\nα : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).inverse.map α) (Quiver.Hom.op { app := fun X => (α.app { unop := X }).unop, naturality := ⋯ })","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_functor_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor SimplexCategory C)\nX✝ Y✝ : Opposite SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).functor.obj F).map f) ((Opposite.unop F).map f.unop).op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_inverse_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\n⊢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).inverse.obj F) { unop := F.unop }","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)ᵒᵖ ≌ SimplicialObject Cᵒᵖ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_right_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.SimplicialObject.Augmented C\nX : SimplexCategory\n⊢ Eq (X✝.rightOp.right.obj X) { unop := X✝.left.obj { unop := X } }","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented Cᵒᵖ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_right_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\nX✝ Y✝ : SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (X.rightOp.right.map f) (X.left.map f.op).op","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented Cᵒᵖ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq X.rightOp.left { unop := X.right }","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented Cᵒᵖ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\nx✝ : SimplexCategory\n⊢ Eq (X.rightOp.hom.app x✝) (X.hom.app { unop := x✝ }).op","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented Cᵒᵖ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n⊢ Eq X.leftOp.right (Opposite.unop X.left)","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_left_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX✝ Y✝ : Opposite SimplexCategory\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (X.leftOp.left.map f) (X.right.map f.unop).unop","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_left_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : Opposite SimplexCategory\n⊢ Eq (X✝.leftOp.left.obj X) (Opposite.unop (X✝.right.obj (Opposite.unop X)))","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : Opposite SimplexCategory\n⊢ Eq (X✝.leftOp.hom.app X) (X✝.hom.app (Opposite.unop X)).unop","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_inv_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.SimplicialObject.Augmented C\nX : Opposite SimplexCategory\n⊢ Eq (X✝.rightOpLeftOpIso.inv.left.app X) (CategoryTheory.CategoryStruct.id (X✝.left.obj X))","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ≅ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_hom_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq X.rightOpLeftOpIso.hom.right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ≅ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_inv_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n⊢ Eq X.rightOpLeftOpIso.inv.right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ≅ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_hom_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.SimplicialObject.Augmented C\nX : Opposite SimplexCategory\n⊢ Eq (X✝.rightOpLeftOpIso.hom.left.app X) (CategoryTheory.CategoryStruct.id (X✝.left.obj X))","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ≅ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_inv_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : SimplexCategory\n⊢ Eq (X✝.leftOpRightOpIso.inv.right.app X) (CategoryTheory.CategoryStruct.id (X✝.right.obj X))","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    X.leftOp.rightOp ≅ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_hom_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n⊢ Eq X.leftOpRightOpIso.hom.left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    X.leftOp.rightOp ≅ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_hom_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : SimplexCategory\n⊢ Eq (X✝.leftOpRightOpIso.hom.right.app X) (CategoryTheory.CategoryStruct.id (X✝.right.obj X))","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    X.leftOp.rightOp ≅ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_inv_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n⊢ Eq X.leftOpRightOpIso.inv.left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented Cᵒᵖ) :\n    X.leftOp.rightOp ≅ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.simplicialToCosimplicialAugmented_map_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.SimplicialObject.Augmented C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).right (CategoryTheory.NatTrans.rightOp f.unop.left)","decl":"/-- A functorial version of `SimplicialObject.Augmented.rightOp`. -/\n@[simps]\ndef simplicialToCosimplicialAugmented :\n    (SimplicialObject.Augmented C)ᵒᵖ ⥤ CosimplicialObject.Augmented Cᵒᵖ where\n  obj X := X.unop.rightOp\n  map f :=\n    { left := f.unop.right.op\n      right := NatTrans.rightOp f.unop.left\n      w := by\n        ext x\n        dsimp\n        simp_rw [← op_comp]\n        congr 1\n        exact (congr_app f.unop.w (op x)).symm }\n\n"}
{"name":"CategoryTheory.simplicialToCosimplicialAugmented_map_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : Opposite (CategoryTheory.SimplicialObject.Augmented C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).left f.unop.right.op","decl":"/-- A functorial version of `SimplicialObject.Augmented.rightOp`. -/\n@[simps]\ndef simplicialToCosimplicialAugmented :\n    (SimplicialObject.Augmented C)ᵒᵖ ⥤ CosimplicialObject.Augmented Cᵒᵖ where\n  obj X := X.unop.rightOp\n  map f :=\n    { left := f.unop.right.op\n      right := NatTrans.rightOp f.unop.left\n      w := by\n        ext x\n        dsimp\n        simp_rw [← op_comp]\n        congr 1\n        exact (congr_app f.unop.w (op x)).symm }\n\n"}
{"name":"CategoryTheory.simplicialToCosimplicialAugmented_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.SimplicialObject.Augmented C)\n⊢ Eq ((CategoryTheory.simplicialToCosimplicialAugmented C).obj X) (Opposite.unop X).rightOp","decl":"/-- A functorial version of `SimplicialObject.Augmented.rightOp`. -/\n@[simps]\ndef simplicialToCosimplicialAugmented :\n    (SimplicialObject.Augmented C)ᵒᵖ ⥤ CosimplicialObject.Augmented Cᵒᵖ where\n  obj X := X.unop.rightOp\n  map f :=\n    { left := f.unop.right.op\n      right := NatTrans.rightOp f.unop.left\n      w := by\n        ext x\n        dsimp\n        simp_rw [← op_comp]\n        congr 1\n        exact (congr_app f.unop.w (op x)).symm }\n\n"}
{"name":"CategoryTheory.cosimplicialToSimplicialAugmented_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX✝ Y✝ : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.cosimplicialToSimplicialAugmented C).map f) (Quiver.Hom.op { left := CategoryTheory.NatTrans.leftOp f.right, right := f.left.unop, w := ⋯ })","decl":"/-- A functorial version of `Cosimplicial_object.Augmented.leftOp`. -/\n@[simps]\ndef cosimplicialToSimplicialAugmented :\n    CosimplicialObject.Augmented Cᵒᵖ ⥤ (SimplicialObject.Augmented C)ᵒᵖ where\n  obj X := Opposite.op X.leftOp\n  map f :=\n    Quiver.Hom.op <|\n      { left := NatTrans.leftOp f.right\n        right := f.left.unop\n        w := by\n          ext x\n          dsimp\n          simp_rw [← unop_comp]\n          congr 1\n          exact (congr_app f.w (unop x)).symm }\n\n"}
{"name":"CategoryTheory.cosimplicialToSimplicialAugmented_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n⊢ Eq ((CategoryTheory.cosimplicialToSimplicialAugmented C).obj X) { unop := X.leftOp }","decl":"/-- A functorial version of `Cosimplicial_object.Augmented.leftOp`. -/\n@[simps]\ndef cosimplicialToSimplicialAugmented :\n    CosimplicialObject.Augmented Cᵒᵖ ⥤ (SimplicialObject.Augmented C)ᵒᵖ where\n  obj X := Opposite.op X.leftOp\n  map f :=\n    Quiver.Hom.op <|\n      { left := NatTrans.leftOp f.right\n        right := f.left.unop\n        w := by\n          ext x\n          dsimp\n          simp_rw [← unop_comp]\n          congr 1\n          exact (congr_app f.w (unop x)).symm }\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialAugmentedEquiv_functor","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.simplicialCosimplicialAugmentedEquiv C).functor (CategoryTheory.simplicialToCosimplicialAugmented C)","decl":"/-- The contravariant categorical equivalence between augmented simplicial\nobjects and augmented cosimplicial objects in the opposite category. -/\n@[simps! functor inverse]\ndef simplicialCosimplicialAugmentedEquiv :\n    (SimplicialObject.Augmented C)ᵒᵖ ≌ CosimplicialObject.Augmented Cᵒᵖ where\n  functor := simplicialToCosimplicialAugmented _\n  inverse := cosimplicialToSimplicialAugmented _\n  unitIso := NatIso.ofComponents (fun X => X.unop.rightOpLeftOpIso.op) fun f => by\n      dsimp\n      rw [← f.op_unop]\n      simp_rw [← op_comp]\n      congr 1\n      aesop_cat\n  counitIso := NatIso.ofComponents fun X => X.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialAugmentedEquiv_inverse","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\n⊢ Eq (CategoryTheory.simplicialCosimplicialAugmentedEquiv C).inverse (CategoryTheory.cosimplicialToSimplicialAugmented C)","decl":"/-- The contravariant categorical equivalence between augmented simplicial\nobjects and augmented cosimplicial objects in the opposite category. -/\n@[simps! functor inverse]\ndef simplicialCosimplicialAugmentedEquiv :\n    (SimplicialObject.Augmented C)ᵒᵖ ≌ CosimplicialObject.Augmented Cᵒᵖ where\n  functor := simplicialToCosimplicialAugmented _\n  inverse := cosimplicialToSimplicialAugmented _\n  unitIso := NatIso.ofComponents (fun X => X.unop.rightOpLeftOpIso.op) fun f => by\n      dsimp\n      rw [← f.op_unop]\n      simp_rw [← op_comp]\n      congr 1\n      aesop_cat\n  counitIso := NatIso.ofComponents fun X => X.leftOpRightOpIso\n\n"}
