{"name":"CategoryTheory.instCategorySimplicialObject_id_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nX : Opposite SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simps!]\ninstance : Category (SimplicialObject C) := by\n  dsimp only [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instCategorySimplicialObject_comp_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Functor (Opposite SimplexCategory) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nŒ≤ : Quiver.Hom Y‚úù Z‚úù\nX : Opposite SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ±.app X) (Œ≤.app X))","decl":"@[simps!]\ninstance : Category (SimplicialObject C) := by\n  dsimp only [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.SimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (SimplicialObject C) := by\n  dsimp [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimits C\n‚ä¢ CategoryTheory.Limits.HasLimits (CategoryTheory.SimplicialObject C)","decl":"instance [HasLimits C] : HasLimits (SimplicialObject C) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.SimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (SimplicialObject C) := by\n  dsimp [SimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\n‚ä¢ CategoryTheory.Limits.HasColimits (CategoryTheory.SimplicialObject C)","decl":"instance [HasColimits C] : HasColimits (SimplicialObject C) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.SimplicialObject.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject C\nf g : Quiver.Hom X Y\nh : ‚àÄ (n : Opposite SimplexCategory), Eq (f.app n) (g.app n)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : SimplicialObject C} (f g : X ‚ü∂ Y)\n    (h : ‚àÄ (n : SimplexCategory·µí·µñ), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.SimplicialObject.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (n : Opposite SimplexCategory), Eq (f.app n) (g.app n))","decl":"@[ext]\nlemma hom_ext {X Y : SimplicialObject C} (f g : X ‚ü∂ Y)\n    (h : ‚àÄ (n : SimplexCategory·µí·µñ), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.SimplicialObject.eqToIso_refl","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nh : Eq n n\n‚ä¢ Eq (X.eqToIso h) (CategoryTheory.Iso.refl (X.obj { unop := SimplexCategory.mk n }))","decl":"@[simp]\ntheorem eqToIso_refl {n : ‚Ñï} (h : n = n) : X.eqToIso h = Iso.refl _ := by\n  ext\n  simp [eqToIso]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j.succ) (X.Œ¥ i)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (X.Œ¥ j))","decl":"/-- The generic case of the first simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥ {n} {i j : Fin (n + 2)} (H : i ‚â§ j) :\n    X.Œ¥ j.succ ‚â´ X.Œ¥ i = X.Œ¥ (Fin.castSucc i) ‚â´ X.Œ¥ j := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j.succ) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) h))","decl":"/-- The generic case of the first simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥ {n} {i j : Fin (n + 2)} (H : i ‚â§ j) :\n    X.Œ¥ j.succ ‚â´ X.Œ¥ i = X.Œ¥ (Fin.castSucc i) ‚â´ X.Œ¥ j := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (j.pred ‚ãØ)) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.Œ¥ j ‚â´ X.Œ¥ i =\n      X.Œ¥ (Fin.castSucc i) ‚â´\n        X.Œ¥ (j.pred fun (hj : j = 0) => by simp [hj, Fin.not_lt_zero] at H) := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥' H]\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (X.Œ¥ i)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (X.Œ¥ (j.pred ‚ãØ)))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.Œ¥ j ‚â´ X.Œ¥ i =\n      X.Œ¥ (Fin.castSucc i) ‚â´\n        X.Œ¥ (j.pred fun (hj : j = 0) => by simp [hj, Fin.not_lt_zero] at H) := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥' H]\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥''_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j.succ) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (i.castLT ‚ãØ)) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ‚â§ Fin.castSucc j) :\n    X.Œ¥ j.succ ‚â´ X.Œ¥ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) =\n      X.Œ¥ i ‚â´ X.Œ¥ j := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥'' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥''","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j.succ) (X.Œ¥ (i.castLT ‚ãØ))) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ j))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ‚â§ Fin.castSucc j) :\n    X.Œ¥ j.succ ‚â´ X.Œ¥ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) =\n      X.Œ¥ i ‚â´ X.Œ¥ j := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥'' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥_self {n} {i : Fin (n + 2)} :\n    X.Œ¥ (Fin.castSucc i) ‚â´ X.Œ¥ i = X.Œ¥ i.succ ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (X.Œ¥ i)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (X.Œ¥ i))","decl":"/-- The special case of the first simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥_self {n} {i : Fin (n + 2)} :\n    X.Œ¥ (Fin.castSucc i) ‚â´ X.Œ¥ i = X.Œ¥ i.succ ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 3)\ni : Fin (HAdd.hAdd n 2)\nH : Eq j i.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (X.Œ¥ i)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (X.Œ¥ i))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥_self' {n} {j : Fin (n + 3)} {i : Fin (n + 2)} (H : j = Fin.castSucc i) :\n    X.Œ¥ j ‚â´ X.Œ¥ i = X.Œ¥ i.succ ‚â´ X.Œ¥ i := by\n  subst H\n  rw [Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_Œ¥_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 3)\ni : Fin (HAdd.hAdd n 2)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥_self' {n} {j : Fin (n + 3)} {i : Fin (n + 2)} (H : j = Fin.castSucc i) :\n    X.Œ¥ j ‚â´ X.Œ¥ i = X.Œ¥ i.succ ‚â´ X.Œ¥ i := by\n  subst H\n  rw [Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_le_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j.succ) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.œÉ j) h))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ Fin.castSucc j) :\n    X.œÉ j.succ ‚â´ X.Œ¥ (Fin.castSucc i) = X.Œ¥ i ‚â´ X.œÉ j := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_le H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_le","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j.succ) (X.Œ¥ i.castSucc)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.œÉ j))","decl":"/-- The second simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ Fin.castSucc j) :\n    X.œÉ j.succ ‚â´ X.Œ¥ (Fin.castSucc i) = X.Œ¥ i ‚â´ X.œÉ j := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_le H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (X.Œ¥ i.castSucc)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} : X.œÉ i ‚â´ X.Œ¥ (Fin.castSucc i) = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_self, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) h)) h","decl":"/-- The first part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} : X.œÉ i ‚â´ X.Œ¥ (Fin.castSucc i) = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_self, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (X.Œ¥ j)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.œÉ i ‚â´ X.Œ¥ j = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) h)) h","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.œÉ i ‚â´ X.Œ¥ j = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_self]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_succ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (X.Œ¥ i.succ)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : X.œÉ i ‚â´ X.Œ¥ i.succ = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_succ, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_succ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) h)) h","decl":"/-- The second part of the third simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : X.œÉ i ‚â´ X.Œ¥ i.succ = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_succ, op_id, X.map_id]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_succ'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) h)) h","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.œÉ i ‚â´ X.Œ¥ j = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_succ]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_succ'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (X.Œ¥ j)) (CategoryTheory.CategoryStruct.id (X.obj { unop := SimplexCategory.mk n }))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.œÉ i ‚â´ X.Œ¥ j = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_succ]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_gt","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j.castSucc) (X.Œ¥ i.succ)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.œÉ j))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.œÉ (Fin.castSucc j) ‚â´ X.Œ¥ i.succ = X.Œ¥ i ‚â´ X.œÉ j := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_gt_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j.castSucc) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.œÉ j) h))","decl":"/-- The fourth simplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.œÉ (Fin.castSucc j) ‚â´ X.Œ¥ i.succ = X.Œ¥ i ‚â´ X.œÉ j := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_gt'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j) (X.Œ¥ i)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (i.pred ‚ãØ)) (X.œÉ (j.castLT ‚ãØ)))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.œÉ j ‚â´ X.Œ¥ i =\n      X.Œ¥ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) ‚â´\n        X.œÉ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_comp_œÉ_of_gt'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (i.pred ‚ãØ)) (CategoryTheory.CategoryStruct.comp (X.œÉ (j.castLT ‚ãØ)) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.œÉ j ‚â´ X.Œ¥ i =\n      X.Œ¥ (i.pred fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) ‚â´\n        X.œÉ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt' H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.œÉ_comp_œÉ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j) (X.œÉ i.castSucc)) (CategoryTheory.CategoryStruct.comp (X.œÉ i) (X.œÉ j.succ))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :\n    X.œÉ j ‚â´ X.œÉ (Fin.castSucc i) = X.œÉ i ‚â´ X.œÉ j.succ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.œÉ_comp_œÉ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.œÉ_comp_œÉ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj { unop := SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1) }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ j) (CategoryTheory.CategoryStruct.comp (X.œÉ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (X.œÉ j.succ) h))","decl":"/-- The fifth simplicial identity -/\n@[reassoc]\ntheorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :\n    X.œÉ j ‚â´ X.œÉ (Fin.castSucc i) = X.œÉ i ‚â´ X.œÉ j.succ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.œÉ_comp_œÉ H]\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (f.app { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) (X'.Œ¥ i))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality {X' X : SimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 2)) :\n    X.Œ¥ i ‚â´ f.app (op [n]) = f.app (op [n + 1]) ‚â´ X'.Œ¥ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Œ¥_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X'.obj { unop := SimplexCategory.mk n }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk n }) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) (CategoryTheory.CategoryStruct.comp (X'.Œ¥ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality {X' X : SimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 2)) :\n    X.Œ¥ i ‚â´ f.app (op [n]) = f.app (op [n + 1]) ‚â´ X'.Œ¥ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.œÉ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) })) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk n }) (X'.œÉ i))","decl":"@[reassoc (attr := simp)]\ntheorem œÉ_naturality {X' X : SimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 1)) :\n    X.œÉ i ‚â´ f.app (op [n + 1]) = f.app (op [n]) ‚â´ X'.œÉ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.œÉ_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.SimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X'.obj { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk (HAdd.hAdd n 1) }) h)) (CategoryTheory.CategoryStruct.comp (f.app { unop := SimplexCategory.mk n }) (CategoryTheory.CategoryStruct.comp (X'.œÉ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem œÉ_naturality {X' X : SimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 1)) :\n    X.œÉ i ‚â´ f.app (op [n + 1]) = f.app (op [n]) ‚â´ X'.œÉ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nX : Opposite SimplexCategory\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ SimplicialObject C ‚•§ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite SimplexCategory) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite SimplexCategory\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).obj H).map Œ±).app X) (H.map (Œ±.app X))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ SimplicialObject C ‚•§ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nX‚úù Y‚úù : Opposite SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ SimplicialObject C ‚•§ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor (Opposite SimplexCategory) C\nc : Opposite SimplexCategory\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.whiskering C D).map œÑ).app F).app c) (œÑ.app (F.obj c))","decl":"/-- Functor composition induces a functor on simplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ SimplicialObject C ‚•§ SimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (SimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù : CategoryTheory.Limits.HasLimits C\n‚ä¢ CategoryTheory.Limits.HasLimits (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} [HasLimits C] : HasLimits (SimplicialObject.Truncated C n) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (SimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù : CategoryTheory.Limits.HasColimits C\n‚ä¢ CategoryTheory.Limits.HasColimits (CategoryTheory.SimplicialObject.Truncated C n)","decl":"instance {n} [HasColimits C] : HasColimits (SimplicialObject.Truncated C n) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nX : Opposite (SimplexCategory.Truncated n)\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite (SimplexCategory.Truncated n)\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).obj H).map Œ±).app X) (H.map (Œ±.app X))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nc : Opposite (SimplexCategory.Truncated n)\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).map œÑ).app F).app c) (œÑ.app (F.obj c))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C\nX‚úù Y‚úù : Opposite (SimplexCategory.Truncated n)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((CategoryTheory.SimplicialObject.Truncated.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on truncated simplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.instIsLeftKanExtensionOppositeTruncatedSimplexCategoryObjSkAppTruncatedUnitSkAdjTruncation","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\n‚ä¢ CategoryTheory.Functor.IsLeftKanExtension ((CategoryTheory.SimplicialObject.sk n).obj X) ((CategoryTheory.SimplicialObject.skAdj n).unit.app ((CategoryTheory.SimplicialObject.truncation n).obj X))","decl":"instance : ((sk n).obj X).IsLeftKanExtension ((skAdj n).unit.app _) := by\n  dsimp [sk, skAdj]\n  rw [lanAdjunction_unit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instIsRightKanExtensionOppositeTruncatedSimplexCategoryObjCoskAppTruncatedCounitCoskAdjTruncation","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nn : Nat\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\n‚ä¢ CategoryTheory.Functor.IsRightKanExtension ((CategoryTheory.SimplicialObject.cosk n).obj X) ((CategoryTheory.SimplicialObject.coskAdj n).counit.app ((CategoryTheory.SimplicialObject.truncation n).obj X))","decl":"instance : ((cosk n).obj X).IsRightKanExtension ((coskAdj n).counit.app _) := by\n  dsimp [cosk, coskAdj]\n  rw [ranAdjunction_counit]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.cosk_reflective","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseRightKanExtension F\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.SimplicialObject.coskAdj n).counit","decl":"instance cosk_reflective : IsIso (coskAdj (C := C) n).counit :=\n  reflective' (SimplexCategory.Truncated.inclusion n).op\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.sk_coreflective","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseLeftKanExtension F\n‚ä¢ CategoryTheory.IsIso (CategoryTheory.SimplicialObject.skAdj n).unit","decl":"instance sk_coreflective : IsIso (skAdj (C := C) n).unit :=\n  coreflective' (SimplexCategory.Truncated.inclusion n).op\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.cosk.full","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseRightKanExtension F\n‚ä¢ (CategoryTheory.SimplicialObject.Truncated.cosk n).Full","decl":"instance cosk.full : (Truncated.cosk (C := C) n).Full := FullyFaithful.full (cosk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.cosk.faithful","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasRightKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseRightKanExtension F\n‚ä¢ (CategoryTheory.SimplicialObject.Truncated.cosk n).Faithful","decl":"instance cosk.faithful : (Truncated.cosk (C := C) n).Faithful :=\n  FullyFaithful.faithful (cosk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.sk.full","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseLeftKanExtension F\n‚ä¢ (CategoryTheory.SimplicialObject.Truncated.sk n).Full","decl":"instance sk.full : (Truncated.sk (C := C) n).Full := FullyFaithful.full (sk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Truncated.sk.faithful","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù¬π : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasLeftKanExtension F\ninst‚úù : ‚àÄ (F : CategoryTheory.Functor (Opposite (SimplexCategory.Truncated n)) C), (SimplexCategory.Truncated.inclusion n).op.HasPointwiseLeftKanExtension F\n‚ä¢ (CategoryTheory.SimplicialObject.Truncated.sk n).Faithful","decl":"instance sk.faithful : (Truncated.sk (C := C) n).Faithful :=\n  FullyFaithful.faithful (sk.fullyFaithful _)\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_id_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nX : Opposite SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id X‚úù).left.app X) (CategoryTheory.CategoryStruct.id (X‚úù.left.obj X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_comp_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).right (CategoryTheory.CategoryStruct.comp f.right g.right)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_id_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).right (CategoryTheory.CategoryStruct.id X.right)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.instCategoryAugmented_comp_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\nX : Opposite SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g).left.app X) (CategoryTheory.CategoryStruct.comp (f.left.app X) (g.left.app X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ‚ü∂ Y) (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf g : Quiver.Hom X Y\nh‚ÇÅ : Eq f.left g.left\nh‚ÇÇ : Eq f.right g.right\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ‚ü∂ Y) (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.drop_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.drop.map f) f.left","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ‚•§ SimplicialObject C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.drop_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.drop.obj X) X.left","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ‚•§ SimplicialObject C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.point_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.point.obj X) X.right","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ‚•§ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.point_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.Functor.id (CategoryTheory.SimplicialObject C)) (CategoryTheory.SimplicialObject.const C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.point.map f) f.right","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ‚•§ C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_obj_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X).right (CategoryTheory.SimplicialObject.Augmented.point.obj X)","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := (drop.map Œ∑).app _\n      right := point.map Œ∑\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_obj_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X).left ((CategoryTheory.SimplicialObject.Augmented.drop.obj X).obj { unop := SimplexCategory.mk 0 })","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := (drop.map Œ∑).app _\n      right := point.map Œ∑\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_map_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.SimplicialObject.Augmented C\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.map Œ∑).right (CategoryTheory.SimplicialObject.Augmented.point.map Œ∑)","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := (drop.map Œ∑).app _\n      right := point.map Œ∑\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_obj_hom","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.obj X).hom (X.hom.app { unop := SimplexCategory.mk 0 })","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := (drop.map Œ∑).app _\n      right := point.map Œ∑\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.toArrow_map_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.SimplicialObject.Augmented C\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.SimplicialObject.Augmented.toArrow.map Œ∑).left ((CategoryTheory.SimplicialObject.Augmented.drop.map Œ∑).app { unop := SimplexCategory.mk 0 })","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := drop.obj X _[0]\n      right := point.obj X\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := (drop.map Œ∑).app _\n      right := point.map Œ∑\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.w‚ÇÄ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (((CategoryTheory.SimplicialObject.const C).obj Y.right).obj { unop := SimplexCategory.mk 0 }) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.SimplicialObject.Augmented.drop.map f).app { unop := SimplexCategory.mk 0 }) (CategoryTheory.CategoryStruct.comp (Y.hom.app { unop := SimplexCategory.mk 0 }) h)) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.CategoryStruct.comp (CategoryTheory.SimplicialObject.Augmented.point.map f) h))","decl":"/-- The compatibility of a morphism with the augmentation, on 0-simplices -/\n@[reassoc]\ntheorem w‚ÇÄ {X Y : Augmented C} (f : X ‚ü∂ Y) :\n    (Augmented.drop.map f).app (op (SimplexCategory.mk 0)) ‚â´ Y.hom.app (op (SimplexCategory.mk 0)) =\n      X.hom.app (op (SimplexCategory.mk 0)) ‚â´ Augmented.point.map f := by\n  convert congr_app f.w (op (SimplexCategory.mk 0))\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.w‚ÇÄ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.SimplicialObject.Augmented C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.SimplicialObject.Augmented.drop.map f).app { unop := SimplexCategory.mk 0 }) (Y.hom.app { unop := SimplexCategory.mk 0 })) (CategoryTheory.CategoryStruct.comp (X.hom.app { unop := SimplexCategory.mk 0 }) (CategoryTheory.SimplicialObject.Augmented.point.map f))","decl":"/-- The compatibility of a morphism with the augmentation, on 0-simplices -/\n@[reassoc]\ntheorem w‚ÇÄ {X Y : Augmented C} (f : X ‚ü∂ Y) :\n    (Augmented.drop.map f).app (op (SimplexCategory.mk 0)) ‚â´ Y.hom.app (op (SimplexCategory.mk 0)) =\n      X.hom.app (op (SimplexCategory.mk 0)) ‚â´ Augmented.point.map f := by\n  convert congr_app f.w (op (SimplexCategory.mk 0))\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.whiskering_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq ((CategoryTheory.SimplicialObject.Augmented.whiskering C D).obj F) (CategoryTheory.SimplicialObject.Augmented.whiskeringObj C D F)","decl":"/-- Functor composition induces a functor on augmented simplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ‚•§ D) ‚•§ Augmented C ‚•§ Augmented D where\n  obj := whiskeringObj _ _\n  map Œ∑ :=\n    { app := fun A =>\n        { left := whiskerLeft _ Œ∑\n          right := Œ∑.app _\n          w := by\n            ext n\n            dsimp\n            rw [Category.comp_id, Category.comp_id, Œ∑.naturality] } }\n  map_comp := fun _ _ => by ext <;> rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.whiskering_map_app_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\nA : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq (((CategoryTheory.SimplicialObject.Augmented.whiskering C D).map Œ∑).app A).right (Œ∑.app (CategoryTheory.SimplicialObject.Augmented.point.obj A))","decl":"/-- Functor composition induces a functor on augmented simplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ‚•§ D) ‚•§ Augmented C ‚•§ Augmented D where\n  obj := whiskeringObj _ _\n  map Œ∑ :=\n    { app := fun A =>\n        { left := whiskerLeft _ Œ∑\n          right := Œ∑.app _\n          w := by\n            ext n\n            dsimp\n            rw [Category.comp_id, Category.comp_id, Œ∑.naturality] } }\n  map_comp := fun _ _ => by ext <;> rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.whiskering_map_app_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\nA : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq (((CategoryTheory.SimplicialObject.Augmented.whiskering C D).map Œ∑).app A).left (CategoryTheory.whiskerLeft (CategoryTheory.SimplicialObject.Augmented.drop.obj A) Œ∑)","decl":"/-- Functor composition induces a functor on augmented simplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ‚•§ D) ‚•§ Augmented C ‚•§ Augmented D where\n  obj := whiskeringObj _ _\n  map Œ∑ :=\n    { app := fun A =>\n        { left := whiskerLeft _ Œ∑\n          right := Œ∑.app _\n          w := by\n            ext n\n            dsimp\n            rw [Category.comp_id, Category.comp_id, Œ∑.naturality] } }\n  map_comp := fun _ _ => by ext <;> rfl\n\n"}
{"name":"CategoryTheory.SimplicialObject.augment_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X‚ÇÄ\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÅ.op) f) (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÇ.op) f)\nx‚úù : Opposite SimplexCategory\n‚ä¢ Eq ((X.augment X‚ÇÄ f w).hom.app x‚úù) (CategoryTheory.CategoryStruct.comp (X.map ((SimplexCategory.mk 0).const (Opposite.unop x‚úù) 0).op) f)","decl":"/-- Augment a simplicial object with an object. -/\n@[simps]\ndef augment (X : SimplicialObject C) (X‚ÇÄ : C) (f : X _[0] ‚ü∂ X‚ÇÄ)\n    (w : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : ([0] : SimplexCategory) ‚ü∂ i),\n      X.map g‚ÇÅ.op ‚â´ f = X.map g‚ÇÇ.op ‚â´ f) :\n    SimplicialObject.Augmented C where\n  left := X\n  right := X‚ÇÄ\n  hom :=\n    { app := fun _ => X.map (SimplexCategory.const _ _ 0).op ‚â´ f\n      naturality := by\n        intro i j g\n        dsimp\n        rw [‚Üê g.op_unop]\n        simpa only [‚Üê X.map_comp, ‚Üê Category.assoc, Category.comp_id, ‚Üê op_comp] using w _ _ _ }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.SimplicialObject.augment_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X‚ÇÄ\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÅ.op) f) (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÇ.op) f)\n‚ä¢ Eq (X.augment X‚ÇÄ f w).left X","decl":"/-- Augment a simplicial object with an object. -/\n@[simps]\ndef augment (X : SimplicialObject C) (X‚ÇÄ : C) (f : X _[0] ‚ü∂ X‚ÇÄ)\n    (w : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : ([0] : SimplexCategory) ‚ü∂ i),\n      X.map g‚ÇÅ.op ‚â´ f = X.map g‚ÇÇ.op ‚â´ f) :\n    SimplicialObject.Augmented C where\n  left := X\n  right := X‚ÇÄ\n  hom :=\n    { app := fun _ => X.map (SimplexCategory.const _ _ 0).op ‚â´ f\n      naturality := by\n        intro i j g\n        dsimp\n        rw [‚Üê g.op_unop]\n        simpa only [‚Üê X.map_comp, ‚Üê Category.assoc, Category.comp_id, ‚Üê op_comp] using w _ _ _ }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.SimplicialObject.augment_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X‚ÇÄ\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÅ.op) f) (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÇ.op) f)\n‚ä¢ Eq (X.augment X‚ÇÄ f w).right X‚ÇÄ","decl":"/-- Augment a simplicial object with an object. -/\n@[simps]\ndef augment (X : SimplicialObject C) (X‚ÇÄ : C) (f : X _[0] ‚ü∂ X‚ÇÄ)\n    (w : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : ([0] : SimplexCategory) ‚ü∂ i),\n      X.map g‚ÇÅ.op ‚â´ f = X.map g‚ÇÇ.op ‚â´ f) :\n    SimplicialObject.Augmented C where\n  left := X\n  right := X‚ÇÄ\n  hom :=\n    { app := fun _ => X.map (SimplexCategory.const _ _ 0).op ‚â´ f\n      naturality := by\n        intro i j g\n        dsimp\n        rw [‚Üê g.op_unop]\n        simpa only [‚Üê X.map_comp, ‚Üê Category.assoc, Category.comp_id, ‚Üê op_comp] using w _ _ _ }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.SimplicialObject.augment_hom_zero","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom (X.obj { unop := SimplexCategory.mk 0 }) X‚ÇÄ\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÅ.op) f) (CategoryTheory.CategoryStruct.comp (X.map g‚ÇÇ.op) f)\n‚ä¢ Eq ((X.augment X‚ÇÄ f w).hom.app { unop := SimplexCategory.mk 0 }) f","decl":"theorem augment_hom_zero (X : SimplicialObject C) (X‚ÇÄ : C) (f : X _[0] ‚ü∂ X‚ÇÄ) (w) :\n    (X.augment X‚ÇÄ f w).hom.app (op [0]) = f := by simp\n\n"}
{"name":"CategoryTheory.instCategoryCosimplicialObject_comp_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Functor SimplexCategory C\nŒ± : Quiver.Hom X‚úù Y‚úù\nŒ≤ : Quiver.Hom Y‚úù Z‚úù\nX : SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp Œ± Œ≤).app X) (CategoryTheory.CategoryStruct.comp (Œ±.app X) (Œ≤.app X))","decl":"@[simps!]\ninstance : Category (CosimplicialObject C) := by\n  dsimp only [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.instCategoryCosimplicialObject_id_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor SimplexCategory C\nX : SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id F).app X) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[simps!]\ninstance : Category (CosimplicialObject C) := by\n  dsimp only [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.CosimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (CosimplicialObject C) := by\n  dsimp [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasLimits C\n‚ä¢ CategoryTheory.Limits.HasLimits (CategoryTheory.CosimplicialObject C)","decl":"instance [HasLimits C] : HasLimits (CosimplicialObject C) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.CosimplicialObject C)","decl":"instance {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (CosimplicialObject C) := by\n  dsimp [CosimplicialObject]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasColimits C\n‚ä¢ CategoryTheory.Limits.HasColimits (CategoryTheory.CosimplicialObject C)","decl":"instance [HasColimits C] : HasColimits (CosimplicialObject C) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.CosimplicialObject.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject C\nf g : Quiver.Hom X Y\nh : ‚àÄ (n : SimplexCategory), Eq (f.app n) (g.app n)\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : CosimplicialObject C} (f g : X ‚ü∂ Y)\n    (h : ‚àÄ (n : SimplexCategory), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (‚àÄ (n : SimplexCategory), Eq (f.app n) (g.app n))","decl":"@[ext]\nlemma hom_ext {X Y : CosimplicialObject C} (f g : X ‚ü∂ Y)\n    (h : ‚àÄ (n : SimplexCategory), f.app n = g.app n) : f = g :=\n  NatTrans.ext (by ext; apply h)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.eqToIso_refl","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nh : Eq n n\n‚ä¢ Eq (X.eqToIso h) (CategoryTheory.Iso.refl (X.obj (SimplexCategory.mk n)))","decl":"@[simp]\ntheorem eqToIso_refl {n : ‚Ñï} (h : n = n) : X.eqToIso h = Iso.refl _ := by\n  ext\n  simp [eqToIso]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ j.succ)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (X.Œ¥ i.castSucc))","decl":"/-- The generic case of the first cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥ {n} {i j : Fin (n + 2)} (H : i ‚â§ j) :\n    X.Œ¥ i ‚â´ X.Œ¥ j.succ = X.Œ¥ j ‚â´ X.Œ¥ (Fin.castSucc i) := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_Œ¥ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 2)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j.succ) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) h))","decl":"/-- The generic case of the first cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥ {n} {i j : Fin (n + 2)} (H : i ‚â§ j) :\n    X.Œ¥ i ‚â´ X.Œ¥ j.succ = X.Œ¥ j ‚â´ X.Œ¥ (Fin.castSucc i) := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_Œ¥ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ j)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (j.pred ‚ãØ)) (X.Œ¥ i.castSucc))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.Œ¥ i ‚â´ X.Œ¥ j =\n      X.Œ¥ (j.pred fun (hj : j = 0) => by simp only [hj, Fin.not_lt_zero] at H) ‚â´\n        X.Œ¥ (Fin.castSucc i) := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : LT.lt i.castSucc j\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (j.pred ‚ãØ)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : Fin.castSucc i < j) :\n    X.Œ¥ i ‚â´ X.Œ¥ j =\n      X.Œ¥ (j.pred fun (hj : j = 0) => by simp only [hj, Fin.not_lt_zero] at H) ‚â´\n        X.Œ¥ (Fin.castSucc i) := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥''","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ (i.castLT ‚ãØ)) (X.Œ¥ j.succ)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (X.Œ¥ i))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ‚â§ Fin.castSucc j) :\n    X.Œ¥ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) ‚â´ X.Œ¥ j.succ =\n      X.Œ¥ j ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥'' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥''_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ (i.castLT ‚ãØ)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j.succ) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥'' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : i ‚â§ Fin.castSucc j) :\n    X.Œ¥ (i.castLT (Nat.lt_of_le_of_lt (Fin.le_iff_val_le_val.mp H) j.is_lt)) ‚â´ X.Œ¥ j.succ =\n      X.Œ¥ j ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_Œ¥'' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) h))","decl":"/-- The special case of the first cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥_self {n} {i : Fin (n + 2)} :\n    X.Œ¥ i ‚â´ X.Œ¥ (Fin.castSucc i) = X.Œ¥ i ‚â´ X.Œ¥ i.succ := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ i.castSucc)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ i.succ))","decl":"/-- The special case of the first cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_Œ¥_self {n} {i : Fin (n + 2)} :\n    X.Œ¥ i ‚â´ X.Œ¥ (Fin.castSucc i) = X.Œ¥ i ‚â´ X.Œ¥ i.succ := by\n  dsimp [Œ¥]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ j)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.Œ¥ i.succ))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = Fin.castSucc i) :\n    X.Œ¥ i ‚â´ X.Œ¥ j = X.Œ¥ i ‚â´ X.Œ¥ i.succ := by\n  subst H\n  rw [Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_Œ¥_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 3)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd (HAdd.hAdd n 1) 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) h)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_Œ¥_self' {n} {i : Fin (n + 2)} {j : Fin (n + 3)} (H : j = Fin.castSucc i) :\n    X.Œ¥ i ‚â´ X.Œ¥ j = X.Œ¥ i ‚â´ X.Œ¥ i.succ := by\n  subst H\n  rw [Œ¥_comp_Œ¥_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_le","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (X.œÉ j.succ)) (CategoryTheory.CategoryStruct.comp (X.œÉ j) (X.Œ¥ i))","decl":"/-- The second cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ Fin.castSucc j) :\n    X.Œ¥ (Fin.castSucc i) ‚â´ X.œÉ j.succ = X.œÉ j ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_of_le H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_le_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LE.le i j.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.œÉ j.succ) h)) (CategoryTheory.CategoryStruct.comp (X.œÉ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h))","decl":"/-- The second cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_le {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : i ‚â§ Fin.castSucc j) :\n    X.Œ¥ (Fin.castSucc i) ‚â´ X.œÉ j.succ = X.œÉ j ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_of_le H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_self_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.œÉ i) h)) h","decl":"/-- The first part of the third cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} : X.Œ¥ (Fin.castSucc i) ‚â´ X.œÉ i = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_self, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_self","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.castSucc) (X.œÉ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"/-- The first part of the third cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_self {n} {i : Fin (n + 1)} : X.Œ¥ (Fin.castSucc i) ‚â´ X.œÉ i = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_self, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_self'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (CategoryTheory.CategoryStruct.comp (X.œÉ i) h)) h","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.Œ¥ j ‚â´ X.œÉ i = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_self'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.castSucc\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (X.œÉ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_self' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = Fin.castSucc i) :\n    X.Œ¥ j ‚â´ X.œÉ i = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_self]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (CategoryTheory.CategoryStruct.comp (X.œÉ i) h)) h","decl":"/-- The second part of the third cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : X.Œ¥ i.succ ‚â´ X.œÉ i = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_succ, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (X.œÉ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"/-- The second part of the third cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_succ {n} {i : Fin (n + 1)} : X.Œ¥ i.succ ‚â´ X.œÉ i = ùüô _ := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_succ, X.map_id]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (X.œÉ i)) (CategoryTheory.CategoryStruct.id (X.obj (SimplexCategory.mk n)))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.Œ¥ j ‚â´ X.œÉ i = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_succ]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_succ'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\nj : Fin (HAdd.hAdd n 2)\ni : Fin (HAdd.hAdd n 1)\nH : Eq j i.succ\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ j) (CategoryTheory.CategoryStruct.comp (X.œÉ i) h)) h","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_succ' {n} {j : Fin (n + 2)} {i : Fin (n + 1)} (H : j = i.succ) :\n    X.Œ¥ j ‚â´ X.œÉ i = ùüô _ := by\n  subst H\n  rw [Œ¥_comp_œÉ_succ]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_gt","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (X.œÉ j.castSucc)) (CategoryTheory.CategoryStruct.comp (X.œÉ j) (X.Œ¥ i))","decl":"/-- The fourth cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.Œ¥ i.succ ‚â´ X.œÉ (Fin.castSucc j) = X.œÉ j ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_gt_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nj : Fin (HAdd.hAdd n 1)\nH : LT.lt j.castSucc i\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i.succ) (CategoryTheory.CategoryStruct.comp (X.œÉ j.castSucc) h)) (CategoryTheory.CategoryStruct.comp (X.œÉ j) (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) h))","decl":"/-- The fourth cosimplicial identity -/\n@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt {n} {i : Fin (n + 2)} {j : Fin (n + 1)} (H : Fin.castSucc j < i) :\n    X.Œ¥ i.succ ‚â´ X.œÉ (Fin.castSucc j) = X.œÉ j ‚â´ X.Œ¥ i := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_gt'","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (X.œÉ j)) (CategoryTheory.CategoryStruct.comp (X.œÉ (j.castLT ‚ãØ)) (X.Œ¥ (i.pred ‚ãØ)))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.Œ¥ i ‚â´ X.œÉ j =\n      X.œÉ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ‚â´\n        X.Œ¥ (i.pred <|\n          fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_comp_œÉ_of_gt'_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni : Fin (HAdd.hAdd n 3)\nj : Fin (HAdd.hAdd n 2)\nH : LT.lt j.succ i\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (X.œÉ j) h)) (CategoryTheory.CategoryStruct.comp (X.œÉ (j.castLT ‚ãØ)) (CategoryTheory.CategoryStruct.comp (X.Œ¥ (i.pred ‚ãØ)) h))","decl":"@[reassoc]\ntheorem Œ¥_comp_œÉ_of_gt' {n} {i : Fin (n + 3)} {j : Fin (n + 2)} (H : j.succ < i) :\n    X.Œ¥ i ‚â´ X.œÉ j =\n      X.œÉ (j.castLT ((add_lt_add_iff_right 1).mp (lt_of_lt_of_le H i.is_le))) ‚â´\n        X.Œ¥ (i.pred <|\n          fun (hi : i = 0) => by simp only [Fin.not_lt_zero, hi] at H) := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, ‚Üê op_comp, SimplexCategory.Œ¥_comp_œÉ_of_gt' H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.œÉ_comp_œÉ_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\nZ : C\nh : Quiver.Hom (X.obj (SimplexCategory.mk n)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i.castSucc) (CategoryTheory.CategoryStruct.comp (X.œÉ j) h)) (CategoryTheory.CategoryStruct.comp (X.œÉ j.succ) (CategoryTheory.CategoryStruct.comp (X.œÉ i) h))","decl":"/-- The fifth cosimplicial identity -/\n@[reassoc]\ntheorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :\n    X.œÉ (Fin.castSucc i) ‚â´ X.œÉ j = X.œÉ j.succ ‚â´ X.œÉ i := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.œÉ_comp_œÉ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.œÉ_comp_œÉ","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nn : Nat\ni j : Fin (HAdd.hAdd n 1)\nH : LE.le i j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i.castSucc) (X.œÉ j)) (CategoryTheory.CategoryStruct.comp (X.œÉ j.succ) (X.œÉ i))","decl":"/-- The fifth cosimplicial identity -/\n@[reassoc]\ntheorem œÉ_comp_œÉ {n} {i j : Fin (n + 1)} (H : i ‚â§ j) :\n    X.œÉ (Fin.castSucc i) ‚â´ X.œÉ j = X.œÉ j.succ ‚â´ X.œÉ i := by\n  dsimp [Œ¥, œÉ]\n  simp only [‚Üê X.map_comp, SimplexCategory.œÉ_comp_œÉ H]\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\nZ : C\nh : Quiver.Hom (X'.obj (SimplexCategory.mk (HAdd.hAdd n 1))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk (HAdd.hAdd n 1))) h)) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk n)) (CategoryTheory.CategoryStruct.comp (X'.Œ¥ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality {X' X : CosimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 2)) :\n    X.Œ¥ i ‚â´ f.app (SimplexCategory.mk (n + 1)) = f.app (SimplexCategory.mk n) ‚â´ X'.Œ¥ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Œ¥_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 2)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.Œ¥ i) (f.app (SimplexCategory.mk (HAdd.hAdd n 1)))) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk n)) (X'.Œ¥ i))","decl":"@[reassoc (attr := simp)]\ntheorem Œ¥_naturality {X' X : CosimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 2)) :\n    X.Œ¥ i ‚â´ f.app (SimplexCategory.mk (n + 1)) = f.app (SimplexCategory.mk n) ‚â´ X'.Œ¥ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.œÉ_naturality","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (f.app (SimplexCategory.mk n))) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk (HAdd.hAdd n 1))) (X'.œÉ i))","decl":"@[reassoc (attr := simp)]\ntheorem œÉ_naturality {X' X : CosimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 1)) :\n    X.œÉ i ‚â´ f.app (SimplexCategory.mk n) = f.app (SimplexCategory.mk (n + 1)) ‚â´ X'.œÉ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.œÉ_naturality_assoc","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX' X : CategoryTheory.CosimplicialObject C\nf : Quiver.Hom X X'\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (X'.obj (SimplexCategory.mk n)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk n)) h)) (CategoryTheory.CategoryStruct.comp (f.app (SimplexCategory.mk (HAdd.hAdd n 1))) (CategoryTheory.CategoryStruct.comp (X'.œÉ i) h))","decl":"@[reassoc (attr := simp)]\ntheorem œÉ_naturality {X' X : CosimplicialObject C} (f : X ‚ü∂ X') {n : ‚Ñï} (i : Fin (n + 1)) :\n    X.œÉ i ‚â´ f.app (SimplexCategory.mk n) = f.app (SimplexCategory.mk (n + 1)) ‚â´ X'.œÉ i :=\n  f.naturality _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor SimplexCategory C\nX : SimplexCategory\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ CosimplicialObject C ‚•§ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor SimplexCategory C\nc : SimplexCategory\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).map œÑ).app F).app c) (œÑ.app (F.obj c))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ CosimplicialObject C ‚•§ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Functor SimplexCategory C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : SimplexCategory\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).obj H).map Œ±).app X) (H.map (Œ±.app X))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ CosimplicialObject C ‚•§ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor SimplexCategory C\nX‚úù Y‚úù : SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on cosimplicial objects. -/\n@[simps!]\ndef whiskering (D : Type*) [Category D] : (C ‚•§ D) ‚•§ CosimplicialObject C ‚•§ CosimplicialObject D :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasLimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasLimitsOfShape J C] :\n    HasLimitsOfShape J (CosimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasLimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù : CategoryTheory.Limits.HasLimits C\n‚ä¢ CategoryTheory.Limits.HasLimits (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} [HasLimits C] : HasLimits (CosimplicialObject.Truncated C n) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasColimitsOfShape","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nn : Nat\nJ : Type v\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J C\n‚ä¢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} {J : Type v} [SmallCategory J] [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (CosimplicialObject.Truncated C n) := by\n  dsimp [Truncated]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.instHasColimits","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\ninst‚úù : CategoryTheory.Limits.HasColimits C\n‚ä¢ CategoryTheory.Limits.HasColimits (CategoryTheory.CosimplicialObject.Truncated C n)","decl":"instance {n} [HasColimits C] : HasColimits (CosimplicialObject.Truncated C n) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_obj_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nX‚úù Y‚úù : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : SimplexCategory.Truncated n\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).obj H).map Œ±).app X) (H.map (Œ±.app X))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_obj_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nX‚úù Y‚úù : SimplexCategory.Truncated n\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).obj H).obj F).map f) (H.map (F.map f))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_map_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nœÑ : Quiver.Hom X‚úù Y‚úù\nF : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nc : SimplexCategory.Truncated n\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).map œÑ).app F).app c) (œÑ.app (F.obj c))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Truncated.whiskering_obj_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nn : Nat\nD : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} D\nH : CategoryTheory.Functor C D\nF : CategoryTheory.Functor (SimplexCategory.Truncated n) C\nX : SimplexCategory.Truncated n\n‚ä¢ Eq ((((CategoryTheory.CosimplicialObject.Truncated.whiskering C D).obj H).obj F).obj X) (H.obj (F.obj X))","decl":"/-- Functor composition induces a functor on truncated cosimplicial objects. -/\n@[simps!]\ndef whiskering {n} (D : Type*) [Category D] : (C ‚•§ D) ‚•§ Truncated C n ‚•§ Truncated D n :=\n  whiskeringRight _ _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_id_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nX : SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.id X‚úù).right.app X) (CategoryTheory.CategoryStruct.id (X‚úù.right.obj X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_comp_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).left (CategoryTheory.CategoryStruct.comp f.left g.left)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_comp_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù Z‚úù : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X‚úù Y‚úù\ng : Quiver.Hom Y‚úù Z‚úù\nX : SimplexCategory\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp f g).right.app X) (CategoryTheory.CategoryStruct.comp (f.right.app X) (g.right.app X))","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.instCategoryAugmented_id_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X).left (CategoryTheory.CategoryStruct.id X.left)","decl":"@[simps!]\ninstance : Category (Augmented C) := by\n  dsimp only [Augmented]\n  infer_instance\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.hom_ext_iff","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject.Augmented C\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (And (Eq f.left g.left) (Eq f.right g.right))","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ‚ü∂ Y) (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX Y : CategoryTheory.CosimplicialObject.Augmented C\nf g : Quiver.Hom X Y\nh‚ÇÅ : Eq f.left g.left\nh‚ÇÇ : Eq f.right g.right\n‚ä¢ Eq f g","decl":"@[ext]\nlemma hom_ext {X Y : Augmented C} (f g : X ‚ü∂ Y) (h‚ÇÅ : f.left = g.left) (h‚ÇÇ : f.right = g.right) :\n    f = g :=\n  Comma.hom_ext _ _ h‚ÇÅ h‚ÇÇ\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.drop_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.drop.obj X) X.right","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ‚•§ CosimplicialObject C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.drop_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.drop.map f) f.right","decl":"/-- Drop the augmentation. -/\n@[simps!]\ndef drop : Augmented C ‚•§ CosimplicialObject C :=\n  Comma.snd _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.point_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.point.obj X) X.left","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ‚•§ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.point_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Comma (CategoryTheory.CosimplicialObject.const C) (CategoryTheory.Functor.id (CategoryTheory.CosimplicialObject C))\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.point.map f) f.left","decl":"/-- The point of the augmentation. -/\n@[simps!]\ndef point : Augmented C ‚•§ C :=\n  Comma.fst _ _\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_map_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.CosimplicialObject.Augmented C\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.map Œ∑).left Œ∑.left","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := point.map Œ∑\n      right := (drop.map Œ∑).app _\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [‚Üê Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_map_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.CosimplicialObject.Augmented C\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.map Œ∑).right (Œ∑.right.app (SimplexCategory.mk 0))","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := point.map Œ∑\n      right := (drop.map Œ∑).app _\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [‚Üê Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_obj_hom","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented C\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X).hom (X.hom.app (SimplexCategory.mk 0))","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := point.map Œ∑\n      right := (drop.map Œ∑).app _\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [‚Üê Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_obj_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented C\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X).left X.left","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := point.map Œ∑\n      right := (drop.map Œ∑).app _\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [‚Üê Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.toArrow_obj_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented C\n‚ä¢ Eq (CategoryTheory.CosimplicialObject.Augmented.toArrow.obj X).right (X.right.obj (SimplexCategory.mk 0))","decl":"/-- The functor from augmented objects to arrows. -/\n@[simps!]\ndef toArrow : Augmented C ‚•§ Arrow C where\n  obj X :=\n    { left := point.obj X\n      right := drop.obj X _[0]\n      hom := X.hom.app _ }\n  map Œ∑ :=\n    { left := point.map Œ∑\n      right := (drop.map Œ∑).app _\n      w := by\n        dsimp\n        rw [‚Üê NatTrans.comp_app]\n        erw [‚Üê Œ∑.w]\n        rfl }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.whiskering_map_app_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\nA : CategoryTheory.CosimplicialObject.Augmented C\n‚ä¢ Eq (((CategoryTheory.CosimplicialObject.Augmented.whiskering C D).map Œ∑).app A).left (Œ∑.app (CategoryTheory.CosimplicialObject.Augmented.point.obj A))","decl":"/-- Functor composition induces a functor on augmented cosimplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ‚•§ D) ‚•§ Augmented C ‚•§ Augmented D where\n  obj := whiskeringObj _ _\n  map Œ∑ :=\n    { app := fun A =>\n        { left := Œ∑.app _\n          right := whiskerLeft _ Œ∑\n          w := by\n            ext n\n            dsimp\n            rw [Category.id_comp, Category.id_comp, Œ∑.naturality] }\n      naturality := fun _ _ f => by ext <;> dsimp <;> simp }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.whiskering_map_app_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nX‚úù Y‚úù : CategoryTheory.Functor C D\nŒ∑ : Quiver.Hom X‚úù Y‚úù\nA : CategoryTheory.CosimplicialObject.Augmented C\n‚ä¢ Eq (((CategoryTheory.CosimplicialObject.Augmented.whiskering C D).map Œ∑).app A).right (CategoryTheory.whiskerLeft (CategoryTheory.CosimplicialObject.Augmented.drop.obj A) Œ∑)","decl":"/-- Functor composition induces a functor on augmented cosimplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ‚•§ D) ‚•§ Augmented C ‚•§ Augmented D where\n  obj := whiskeringObj _ _\n  map Œ∑ :=\n    { app := fun A =>\n        { left := Œ∑.app _\n          right := whiskerLeft _ Œ∑\n          w := by\n            ext n\n            dsimp\n            rw [Category.id_comp, Category.id_comp, Œ∑.naturality] }\n      naturality := fun _ _ f => by ext <;> dsimp <;> simp }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.whiskering_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\n‚ä¢ Eq ((CategoryTheory.CosimplicialObject.Augmented.whiskering C D).obj F) (CategoryTheory.CosimplicialObject.Augmented.whiskeringObj C D F)","decl":"/-- Functor composition induces a functor on augmented cosimplicial objects. -/\n@[simps]\ndef whiskering (D : Type u') [Category.{v'} D] : (C ‚•§ D) ‚•§ Augmented C ‚•§ Augmented D where\n  obj := whiskeringObj _ _\n  map Œ∑ :=\n    { app := fun A =>\n        { left := Œ∑.app _\n          right := whiskerLeft _ Œ∑\n          w := by\n            ext n\n            dsimp\n            rw [Category.id_comp, Category.id_comp, Œ∑.naturality] }\n      naturality := fun _ _ f => by ext <;> dsimp <;> simp }\n\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom X‚ÇÄ (X.obj (SimplexCategory.mk 0))\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÅ)) (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÇ))\n‚ä¢ Eq (X.augment X‚ÇÄ f w).left X‚ÇÄ","decl":"/-- Augment a cosimplicial object with an object. -/\n@[simps]\ndef augment (X : CosimplicialObject C) (X‚ÇÄ : C) (f : X‚ÇÄ ‚ü∂ X.obj [0])\n    (w : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : ([0] : SimplexCategory) ‚ü∂ i),\n      f ‚â´ X.map g‚ÇÅ = f ‚â´ X.map g‚ÇÇ) : CosimplicialObject.Augmented C where\n  left := X‚ÇÄ\n  right := X\n  hom :=\n    { app := fun _ => f ‚â´ X.map (SimplexCategory.const _ _ 0)\n      naturality := by\n        intro i j g\n        dsimp\n        rw [Category.id_comp, Category.assoc, ‚Üê X.map_comp, w] }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom X‚ÇÄ (X.obj (SimplexCategory.mk 0))\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÅ)) (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÇ))\n‚ä¢ Eq (X.augment X‚ÇÄ f w).right X","decl":"/-- Augment a cosimplicial object with an object. -/\n@[simps]\ndef augment (X : CosimplicialObject C) (X‚ÇÄ : C) (f : X‚ÇÄ ‚ü∂ X.obj [0])\n    (w : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : ([0] : SimplexCategory) ‚ü∂ i),\n      f ‚â´ X.map g‚ÇÅ = f ‚â´ X.map g‚ÇÇ) : CosimplicialObject.Augmented C where\n  left := X‚ÇÄ\n  right := X\n  hom :=\n    { app := fun _ => f ‚â´ X.map (SimplexCategory.const _ _ 0)\n      naturality := by\n        intro i j g\n        dsimp\n        rw [Category.id_comp, Category.assoc, ‚Üê X.map_comp, w] }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom X‚ÇÄ (X.obj (SimplexCategory.mk 0))\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÅ)) (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÇ))\nx‚úù : SimplexCategory\n‚ä¢ Eq ((X.augment X‚ÇÄ f w).hom.app x‚úù) (CategoryTheory.CategoryStruct.comp f (X.map ((SimplexCategory.mk 0).const x‚úù 0)))","decl":"/-- Augment a cosimplicial object with an object. -/\n@[simps]\ndef augment (X : CosimplicialObject C) (X‚ÇÄ : C) (f : X‚ÇÄ ‚ü∂ X.obj [0])\n    (w : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : ([0] : SimplexCategory) ‚ü∂ i),\n      f ‚â´ X.map g‚ÇÅ = f ‚â´ X.map g‚ÇÇ) : CosimplicialObject.Augmented C where\n  left := X‚ÇÄ\n  right := X\n  hom :=\n    { app := fun _ => f ‚â´ X.map (SimplexCategory.const _ _ 0)\n      naturality := by\n        intro i j g\n        dsimp\n        rw [Category.id_comp, Category.assoc, ‚Üê X.map_comp, w] }\n\n-- Porting note: removed @[simp] as the linter complains\n"}
{"name":"CategoryTheory.CosimplicialObject.augment_hom_zero","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject C\nX‚ÇÄ : C\nf : Quiver.Hom X‚ÇÄ (X.obj (SimplexCategory.mk 0))\nw : ‚àÄ (i : SimplexCategory) (g‚ÇÅ g‚ÇÇ : Quiver.Hom (SimplexCategory.mk 0) i), Eq (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÅ)) (CategoryTheory.CategoryStruct.comp f (X.map g‚ÇÇ))\n‚ä¢ Eq ((X.augment X‚ÇÄ f w).hom.app (SimplexCategory.mk 0)) f","decl":"theorem augment_hom_zero (X : CosimplicialObject C) (X‚ÇÄ : C) (f : X‚ÇÄ ‚ü∂ X.obj [0]) (w) :\n    (X.augment X‚ÇÄ f w).hom.app [0] = f := by simp\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_functor_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\nX : SimplexCategory\n‚ä¢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).functor.obj F).obj X) { unop := (Opposite.unop F).obj { unop := X } }","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_counitIso_inv_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.Functor SimplexCategory (Opposite C)\nX : SimplexCategory\n‚ä¢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).counitIso.inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_functor_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\nŒ∑ : Quiver.Hom X‚úù Y‚úù\nx‚úù : SimplexCategory\n‚ä¢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).functor.map Œ∑).app x‚úù) (Œ∑.unop.app { unop := x‚úù }).op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_counitIso_hom_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.Functor SimplexCategory (Opposite C)\nX : SimplexCategory\n‚ä¢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).counitIso.hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_unitIso_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\n‚ä¢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).unitIso.hom.app X) (Opposite.unop X).rightOpLeftOpIso.hom.op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_inverse_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Functor SimplexCategory (Opposite C)\nŒ∑ : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).inverse.map Œ∑) (CategoryTheory.NatTrans.leftOp Œ∑).op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_inverse_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor SimplexCategory (Opposite C)\n‚ä¢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).inverse.obj F) { unop := F.leftOp }","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_unitIso_inv_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\n‚ä¢ Eq ((CategoryTheory.simplicialCosimplicialEquiv C).unitIso.inv.app X) (Opposite.unop X).rightOpLeftOpIso.inv.op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialEquiv_functor_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor (Opposite SimplexCategory) C)\nX‚úù Y‚úù : SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.simplicialCosimplicialEquiv C).functor.obj F).map f) ((Opposite.unop F).map f.op).op","decl":"/-- The anti-equivalence between simplicial objects and cosimplicial objects. -/\n@[simps!]\ndef simplicialCosimplicialEquiv : (SimplicialObject C)·µí·µñ ‚âå CosimplicialObject C·µí·µñ :=\n  Functor.leftOpRightOpEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_functor_map_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.Functor SimplexCategory C)\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Opposite SimplexCategory\n‚ä¢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).functor.map Œ±).app X) (Œ±.unop.app (Opposite.unop X)).op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_counitIso_inv_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\nX : Opposite SimplexCategory\n‚ä¢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).counitIso.inv.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_functor_obj_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor SimplexCategory C)\nX : Opposite SimplexCategory\n‚ä¢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).functor.obj F).obj X) { unop := (Opposite.unop F).obj (Opposite.unop X) }","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_unitIso_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor SimplexCategory C)\n‚ä¢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).unitIso.hom.app X) (Opposite.unop X).opUnopIso.hom.op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_unitIso_inv_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.Functor SimplexCategory C)\n‚ä¢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).unitIso.inv.app X) (Opposite.unop X).opUnopIso.inv.op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_counitIso_hom_app_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\nX : Opposite SimplexCategory\n‚ä¢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).counitIso.hom.app X‚úù).app X) (CategoryTheory.CategoryStruct.id (X‚úù.obj X))","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_inverse_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\nŒ± : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).inverse.map Œ±) (Quiver.Hom.op { app := fun X => (Œ±.app { unop := X }).unop, naturality := ‚ãØ })","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_functor_obj_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : Opposite (CategoryTheory.Functor SimplexCategory C)\nX‚úù Y‚úù : Opposite SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.cosimplicialSimplicialEquiv C).functor.obj F).map f) ((Opposite.unop F).map f.unop).op","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.cosimplicialSimplicialEquiv_inverse_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite SimplexCategory) (Opposite C)\n‚ä¢ Eq ((CategoryTheory.cosimplicialSimplicialEquiv C).inverse.obj F) { unop := F.unop }","decl":"/-- The anti-equivalence between cosimplicial objects and simplicial objects. -/\n@[simps!]\ndef cosimplicialSimplicialEquiv : (CosimplicialObject C)·µí·µñ ‚âå SimplicialObject C·µí·µñ :=\n  Functor.opUnopEquiv _ _\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_right_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.SimplicialObject.Augmented C\nX : SimplexCategory\n‚ä¢ Eq (X‚úù.rightOp.right.obj X) { unop := X‚úù.left.obj { unop := X } }","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented C·µí·µñ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_right_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\nX‚úù Y‚úù : SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (X.rightOp.right.map f) (X.left.map f.op).op","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented C·µí·µñ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq X.rightOp.left { unop := X.right }","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented C·µí·µñ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOp_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\nx‚úù : SimplexCategory\n‚ä¢ Eq (X.rightOp.hom.app x‚úù) (X.hom.app { unop := x‚úù }).op","decl":"/-- Construct an augmented cosimplicial object in the opposite\ncategory from an augmented simplicial object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOp (X : SimplicialObject.Augmented C) :\n    CosimplicialObject.Augmented C·µí·µñ where\n  left := Opposite.op X.right\n  right := X.left.rightOp\n  hom := NatTrans.rightOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n‚ä¢ Eq X.leftOp.right (Opposite.unop X.left)","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented C·µí·µñ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_left_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX‚úù Y‚úù : Opposite SimplexCategory\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (X.leftOp.left.map f) (X.right.map f.unop).unop","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented C·µí·µñ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_left_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : Opposite SimplexCategory\n‚ä¢ Eq (X‚úù.leftOp.left.obj X) (Opposite.unop (X‚úù.right.obj (Opposite.unop X)))","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented C·µí·µñ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOp_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : Opposite SimplexCategory\n‚ä¢ Eq (X‚úù.leftOp.hom.app X) (X‚úù.hom.app (Opposite.unop X)).unop","decl":"/-- Construct an augmented simplicial object from an augmented cosimplicial\nobject in the opposite category. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOp (X : CosimplicialObject.Augmented C·µí·µñ) :\n    SimplicialObject.Augmented C where\n  left := X.right.leftOp\n  right := X.left.unop\n  hom := NatTrans.leftOp X.hom\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_inv_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.SimplicialObject.Augmented C\nX : Opposite SimplexCategory\n‚ä¢ Eq (X‚úù.rightOpLeftOpIso.inv.left.app X) (CategoryTheory.CategoryStruct.id (X‚úù.left.obj X))","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ‚âÖ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_hom_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq X.rightOpLeftOpIso.hom.right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ‚âÖ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_inv_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.SimplicialObject.Augmented C\n‚ä¢ Eq X.rightOpLeftOpIso.inv.right (CategoryTheory.CategoryStruct.id X.right)","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ‚âÖ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.SimplicialObject.Augmented.rightOpLeftOpIso_hom_left_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.SimplicialObject.Augmented C\nX : Opposite SimplexCategory\n‚ä¢ Eq (X‚úù.rightOpLeftOpIso.hom.left.app X) (CategoryTheory.CategoryStruct.id (X‚úù.left.obj X))","decl":"/-- Converting an augmented simplicial object to an augmented cosimplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef SimplicialObject.Augmented.rightOpLeftOpIso (X : SimplicialObject.Augmented C) :\n    X.rightOp.leftOp ‚âÖ X :=\n  Comma.isoMk X.left.rightOpLeftOpIso (CategoryTheory.eqToIso <| by simp)\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_inv_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : SimplexCategory\n‚ä¢ Eq (X‚úù.leftOpRightOpIso.inv.right.app X) (CategoryTheory.CategoryStruct.id (X‚úù.right.obj X))","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented C·µí·µñ) :\n    X.leftOp.rightOp ‚âÖ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_hom_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n‚ä¢ Eq X.leftOpRightOpIso.hom.left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented C·µí·µñ) :\n    X.leftOp.rightOp ‚âÖ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_hom_right_app","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nX : SimplexCategory\n‚ä¢ Eq (X‚úù.leftOpRightOpIso.hom.right.app X) (CategoryTheory.CategoryStruct.id (X‚úù.right.obj X))","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented C·µí·µñ) :\n    X.leftOp.rightOp ‚âÖ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.CosimplicialObject.Augmented.leftOpRightOpIso_inv_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n‚ä¢ Eq X.leftOpRightOpIso.inv.left (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- Converting an augmented cosimplicial object to an augmented simplicial\nobject and back is isomorphic to the given object. -/\n@[simps!]\ndef CosimplicialObject.Augmented.leftOpRightOpIso (X : CosimplicialObject.Augmented C·µí·µñ) :\n    X.leftOp.rightOp ‚âÖ X :=\n  Comma.isoMk (CategoryTheory.eqToIso <| by simp) X.right.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.simplicialToCosimplicialAugmented_map_right","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.SimplicialObject.Augmented C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).right (CategoryTheory.NatTrans.rightOp f.unop.left)","decl":"/-- A functorial version of `SimplicialObject.Augmented.rightOp`. -/\n@[simps]\ndef simplicialToCosimplicialAugmented :\n    (SimplicialObject.Augmented C)·µí·µñ ‚•§ CosimplicialObject.Augmented C·µí·µñ where\n  obj X := X.unop.rightOp\n  map f :=\n    { left := f.unop.right.op\n      right := NatTrans.rightOp f.unop.left\n      w := by\n        ext x\n        dsimp\n        simp_rw [‚Üê op_comp]\n        congr 1\n        exact (congr_app f.unop.w (op x)).symm }\n\n"}
{"name":"CategoryTheory.simplicialToCosimplicialAugmented_map_left","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : Opposite (CategoryTheory.SimplicialObject.Augmented C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.simplicialToCosimplicialAugmented C).map f).left f.unop.right.op","decl":"/-- A functorial version of `SimplicialObject.Augmented.rightOp`. -/\n@[simps]\ndef simplicialToCosimplicialAugmented :\n    (SimplicialObject.Augmented C)·µí·µñ ‚•§ CosimplicialObject.Augmented C·µí·µñ where\n  obj X := X.unop.rightOp\n  map f :=\n    { left := f.unop.right.op\n      right := NatTrans.rightOp f.unop.left\n      w := by\n        ext x\n        dsimp\n        simp_rw [‚Üê op_comp]\n        congr 1\n        exact (congr_app f.unop.w (op x)).symm }\n\n"}
{"name":"CategoryTheory.simplicialToCosimplicialAugmented_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : Opposite (CategoryTheory.SimplicialObject.Augmented C)\n‚ä¢ Eq ((CategoryTheory.simplicialToCosimplicialAugmented C).obj X) (Opposite.unop X).rightOp","decl":"/-- A functorial version of `SimplicialObject.Augmented.rightOp`. -/\n@[simps]\ndef simplicialToCosimplicialAugmented :\n    (SimplicialObject.Augmented C)·µí·µñ ‚•§ CosimplicialObject.Augmented C·µí·µñ where\n  obj X := X.unop.rightOp\n  map f :=\n    { left := f.unop.right.op\n      right := NatTrans.rightOp f.unop.left\n      w := by\n        ext x\n        dsimp\n        simp_rw [‚Üê op_comp]\n        congr 1\n        exact (congr_app f.unop.w (op x)).symm }\n\n"}
{"name":"CategoryTheory.cosimplicialToSimplicialAugmented_map","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.cosimplicialToSimplicialAugmented C).map f) (Quiver.Hom.op { left := CategoryTheory.NatTrans.leftOp f.right, right := f.left.unop, w := ‚ãØ })","decl":"/-- A functorial version of `Cosimplicial_object.Augmented.leftOp`. -/\n@[simps]\ndef cosimplicialToSimplicialAugmented :\n    CosimplicialObject.Augmented C·µí·µñ ‚•§ (SimplicialObject.Augmented C)·µí·µñ where\n  obj X := Opposite.op X.leftOp\n  map f :=\n    Quiver.Hom.op <|\n      { left := NatTrans.leftOp f.right\n        right := f.left.unop\n        w := by\n          ext x\n          dsimp\n          simp_rw [‚Üê unop_comp]\n          congr 1\n          exact (congr_app f.w (unop x)).symm }\n\n"}
{"name":"CategoryTheory.cosimplicialToSimplicialAugmented_obj","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : CategoryTheory.CosimplicialObject.Augmented (Opposite C)\n‚ä¢ Eq ((CategoryTheory.cosimplicialToSimplicialAugmented C).obj X) { unop := X.leftOp }","decl":"/-- A functorial version of `Cosimplicial_object.Augmented.leftOp`. -/\n@[simps]\ndef cosimplicialToSimplicialAugmented :\n    CosimplicialObject.Augmented C·µí·µñ ‚•§ (SimplicialObject.Augmented C)·µí·µñ where\n  obj X := Opposite.op X.leftOp\n  map f :=\n    Quiver.Hom.op <|\n      { left := NatTrans.leftOp f.right\n        right := f.left.unop\n        w := by\n          ext x\n          dsimp\n          simp_rw [‚Üê unop_comp]\n          congr 1\n          exact (congr_app f.w (unop x)).symm }\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialAugmentedEquiv_functor","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq (CategoryTheory.simplicialCosimplicialAugmentedEquiv C).functor (CategoryTheory.simplicialToCosimplicialAugmented C)","decl":"/-- The contravariant categorical equivalence between augmented simplicial\nobjects and augmented cosimplicial objects in the opposite category. -/\n@[simps! functor inverse]\ndef simplicialCosimplicialAugmentedEquiv :\n    (SimplicialObject.Augmented C)·µí·µñ ‚âå CosimplicialObject.Augmented C·µí·µñ where\n  functor := simplicialToCosimplicialAugmented _\n  inverse := cosimplicialToSimplicialAugmented _\n  unitIso := NatIso.ofComponents (fun X => X.unop.rightOpLeftOpIso.op) fun f => by\n      dsimp\n      rw [‚Üê f.op_unop]\n      simp_rw [‚Üê op_comp]\n      congr 1\n      aesop_cat\n  counitIso := NatIso.ofComponents fun X => X.leftOpRightOpIso\n\n"}
{"name":"CategoryTheory.simplicialCosimplicialAugmentedEquiv_inverse","module":"Mathlib.AlgebraicTopology.SimplicialObject.Basic","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ Eq (CategoryTheory.simplicialCosimplicialAugmentedEquiv C).inverse (CategoryTheory.cosimplicialToSimplicialAugmented C)","decl":"/-- The contravariant categorical equivalence between augmented simplicial\nobjects and augmented cosimplicial objects in the opposite category. -/\n@[simps! functor inverse]\ndef simplicialCosimplicialAugmentedEquiv :\n    (SimplicialObject.Augmented C)·µí·µñ ‚âå CosimplicialObject.Augmented C·µí·µñ where\n  functor := simplicialToCosimplicialAugmented _\n  inverse := cosimplicialToSimplicialAugmented _\n  unitIso := NatIso.ofComponents (fun X => X.unop.rightOpLeftOpIso.op) fun f => by\n      dsimp\n      rw [‚Üê f.op_unop]\n      simp_rw [‚Üê op_comp]\n      congr 1\n      aesop_cat\n  counitIso := NatIso.ofComponents fun X => X.leftOpRightOpIso\n\n"}
