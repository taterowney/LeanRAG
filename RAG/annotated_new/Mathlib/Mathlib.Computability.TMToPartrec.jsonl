{"name":"Turing.ToPartrec.Code.cons.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ a✝² a✝¹ a✝ : Turing.ToPartrec.Code\nx✝ : Eq (a✝³.cons a✝²) (a✝¹.cons a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.comp.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ a✝² a✝¹ a✝ : Turing.ToPartrec.Code\nx✝ : Eq (a✝³.comp a✝²) (a✝¹.comp a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.cons.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ a✝² a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (Eq (a✝³.cons a✝²) (a✝¹.cons a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.case.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (SizeOf.sizeOf (a✝¹.case a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.comp.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ a✝² a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (Eq (a✝³.comp a✝²) (a✝¹.comp a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.fix.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝ : Turing.ToPartrec.Code\n⊢ Eq (SizeOf.sizeOf a✝.fix) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.tail.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.ToPartrec.Code.tail) 1","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.succ.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.ToPartrec.Code.succ) 1","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.zero'.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.ToPartrec.Code.zero') 1","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.comp.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (SizeOf.sizeOf (a✝¹.comp a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.case.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ a✝² a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (Eq (a✝³.case a✝²) (a✝¹.case a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.cons.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (SizeOf.sizeOf (a✝¹.cons a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.case.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ a✝² a✝¹ a✝ : Turing.ToPartrec.Code\nx✝ : Eq (a✝³.case a✝²) (a✝¹.case a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.fix.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.ToPartrec.Code\nx✝ : Eq a✝¹.fix a✝.fix\n⊢ Eq a✝¹ a✝","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.fix.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.ToPartrec.Code\n⊢ Eq (Eq a✝¹.fix a✝.fix) (Eq a✝¹ a✝)","decl":"/-- The type of codes for primitive recursive functions. Unlike `Nat.Partrec.Code`, this uses a set\nof operations on `List ℕ`. See `Code.eval` for a description of the behavior of the primitives. -/\ninductive Code\n  | zero'\n  | succ\n  | tail\n  | cons : Code → Code → Code\n  | comp : Code → Code → Code\n  | case : Code → Code → Code\n  | fix : Code → Code\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.ToPartrec.Code.zero'_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq Turing.ToPartrec.Code.zero'.eval fun v => Pure.pure (List.cons 0 v)","decl":"@[simp]\ntheorem zero'_eval : zero'.eval = fun v => pure (0 :: v) := by simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.succ_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq Turing.ToPartrec.Code.succ.eval fun v => Pure.pure (List.cons v.headI.succ List.nil)","decl":"@[simp]\ntheorem succ_eval : succ.eval = fun v => pure [v.headI.succ] := by simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.tail_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq Turing.ToPartrec.Code.tail.eval fun v => Pure.pure v.tail","decl":"@[simp]\ntheorem tail_eval : tail.eval = fun v => pure v.tail := by simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.cons_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f fs : Turing.ToPartrec.Code\n⊢ Eq (f.cons fs).eval fun v => Bind.bind (f.eval v) fun n => Bind.bind (fs.eval v) fun ns => Pure.pure (List.cons n.headI ns)","decl":"@[simp]\ntheorem cons_eval (f fs) : (cons f fs).eval = fun v => do {\n    let n ← Code.eval f v\n    let ns ← Code.eval fs v\n    pure (n.headI :: ns) } := by simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.comp_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f g : Turing.ToPartrec.Code\n⊢ Eq (f.comp g).eval fun v => Bind.bind (g.eval v) f.eval","decl":"@[simp]\ntheorem comp_eval (f g) : (comp f g).eval = fun v => g.eval v >>= f.eval := by simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.case_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f g : Turing.ToPartrec.Code\n⊢ Eq (f.case g).eval fun v => Nat.rec (f.eval v.tail) (fun y x => g.eval (List.cons y v.tail)) v.headI","decl":"@[simp]\ntheorem case_eval (f g) :\n    (case f g).eval = fun v => v.headI.rec (f.eval v.tail) fun y _ => g.eval (y::v.tail) := by\n  simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.fix_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\n⊢ Eq f.fix.eval (PFun.fix fun v => Part.map (fun v => ite (Eq v.headI 0) (Sum.inl v.tail) (Sum.inr v.tail)) (f.eval v))","decl":"@[simp]\ntheorem fix_eval (f) : (fix f).eval =\n    PFun.fix fun v => (f.eval v).map fun v =>\n      if v.headI = 0 then Sum.inl v.tail else Sum.inr v.tail := by\n  simp [eval]\n\n"}
{"name":"Turing.ToPartrec.Code.nil_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"v : List Nat\n⊢ Eq (Turing.ToPartrec.Code.nil.eval v) (Pure.pure List.nil)","decl":"@[simp]\ntheorem nil_eval (v) : nil.eval v = pure [] := by simp [nil]\n\n"}
{"name":"Turing.ToPartrec.Code.id_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"v : List Nat\n⊢ Eq (Turing.ToPartrec.Code.id.eval v) (Pure.pure v)","decl":"@[simp]\ntheorem id_eval (v) : id.eval v = pure v := by simp [id]\n\n"}
{"name":"Turing.ToPartrec.Code.head_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"v : List Nat\n⊢ Eq (Turing.ToPartrec.Code.head.eval v) (Pure.pure (List.cons v.headI List.nil))","decl":"@[simp]\ntheorem head_eval (v) : head.eval v = pure [v.headI] := by simp [head]\n\n"}
{"name":"Turing.ToPartrec.Code.zero_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"v : List Nat\n⊢ Eq (Turing.ToPartrec.Code.zero.eval v) (Pure.pure (List.cons 0 List.nil))","decl":"@[simp]\ntheorem zero_eval (v) : zero.eval v = pure [0] := by simp [zero]\n\n"}
{"name":"Turing.ToPartrec.Code.pred_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"v : List Nat\n⊢ Eq (Turing.ToPartrec.Code.pred.eval v) (Pure.pure (List.cons v.headI.pred List.nil))","decl":"@[simp]\ntheorem pred_eval (v) : pred.eval v = pure [v.headI.pred] := by\n  simp [pred]; cases v.headI <;> simp\n\n"}
{"name":"Turing.ToPartrec.Code.exists_code.comp","module":"Mathlib.Computability.TMToPartrec","initialProofState":"m n : Nat\nf : PFun (List.Vector Nat n) Nat\ng : Fin n → PFun (List.Vector Nat m) Nat\nhf : Exists fun c => ∀ (v : List.Vector Nat n), Eq (c.eval ↑v) (Functor.map Pure.pure (f v))\nhg : ∀ (i : Fin n), Exists fun c => ∀ (v : List.Vector Nat m), Eq (c.eval ↑v) (Functor.map Pure.pure (g i v))\n⊢ Exists fun c => ∀ (v : List.Vector Nat m), Eq (c.eval ↑v) (Functor.map Pure.pure (Bind.bind (List.Vector.mOfFn fun i => g i v) f))","decl":"theorem exists_code.comp {m n} {f : List.Vector ℕ n →. ℕ} {g : Fin n → List.Vector ℕ m →. ℕ}\n    (hf : ∃ c : Code, ∀ v : List.Vector ℕ n, c.eval v.1 = pure <$> f v)\n    (hg : ∀ i, ∃ c : Code, ∀ v : List.Vector ℕ m, c.eval v.1 = pure <$> g i v) :\n    ∃ c : Code, ∀ v : List.Vector ℕ m,\n      c.eval v.1 = pure <$> ((List.Vector.mOfFn fun i => g i v) >>= f) := by\n  rsuffices ⟨cg, hg⟩ :\n    ∃ c : Code, ∀ v : List.Vector ℕ m,\n      c.eval v.1 = Subtype.val <$> List.Vector.mOfFn fun i => g i v\n  · obtain ⟨cf, hf⟩ := hf\n    exact\n      ⟨cf.comp cg, fun v => by\n        simp [hg, hf, map_bind, seq_bind_eq, Function.comp_def]\n        rfl⟩\n  clear hf f; induction' n with n IH\n  · exact ⟨nil, fun v => by simp [Vector.mOfFn, Bind.bind]; rfl⟩\n  · obtain ⟨cg, hg₁⟩ := hg 0\n    obtain ⟨cl, hl⟩ := IH fun i => hg i.succ\n    exact\n      ⟨cons cg cl, fun v => by\n        simp [Vector.mOfFn, hg₁, map_bind, seq_bind_eq, bind_assoc, (· ∘ ·), hl]\n        rfl⟩\n\n"}
{"name":"Turing.ToPartrec.Code.exists_code","module":"Mathlib.Computability.TMToPartrec","initialProofState":"n : Nat\nf : PFun (List.Vector Nat n) Nat\nhf : Nat.Partrec' f\n⊢ Exists fun c => ∀ (v : List.Vector Nat n), Eq (c.eval ↑v) (Functor.map Pure.pure (f v))","decl":"theorem exists_code {n} {f : List.Vector ℕ n →. ℕ} (hf : Nat.Partrec' f) :\n    ∃ c : Code, ∀ v : List.Vector ℕ n, c.eval v.1 = pure <$> f v := by\n  induction hf with\n  | prim hf =>\n    induction hf with\n    | zero => exact ⟨zero', fun ⟨[], _⟩ => rfl⟩\n    | succ => exact ⟨succ, fun ⟨[v], _⟩ => rfl⟩\n    | get i =>\n      refine Fin.succRec (fun n => ?_) (fun n i IH => ?_) i\n      · exact ⟨head, fun ⟨List.cons a as, _⟩ => by simp [Bind.bind]; rfl⟩\n      · obtain ⟨c, h⟩ := IH\n        exact ⟨c.comp tail, fun v => by simpa [← Vector.get_tail, Bind.bind] using h v.tail⟩\n    | comp g hf hg IHf IHg =>\n      simpa [Part.bind_eq_bind] using exists_code.comp IHf IHg\n    | @prec n f g _ _ IHf IHg =>\n      obtain ⟨cf, hf⟩ := IHf\n      obtain ⟨cg, hg⟩ := IHg\n      simp only [Part.map_eq_map, Part.map_some, PFun.coe_val] at hf hg\n      refine ⟨prec cf cg, fun v => ?_⟩\n      rw [← v.cons_head_tail]\n      specialize hf v.tail\n      replace hg := fun a b => hg (a ::ᵥ b ::ᵥ v.tail)\n      simp only [Vector.cons_val, Vector.tail_val] at hf hg\n      simp only [Part.map_eq_map, Part.map_some, Vector.cons_val, Vector.tail_cons,\n        Vector.head_cons, PFun.coe_val, Vector.tail_val]\n      simp only [← Part.pure_eq_some] at hf hg ⊢\n      induction' v.head with n _ <;>\n        simp [prec, hf, Part.bind_assoc, ← Part.bind_some_eq_map, Part.bind_some,\n          show ∀ x, pure x = [x] from fun _ => rfl, Bind.bind, Functor.map]\n      suffices ∀ a b, a + b = n →\n        (n.succ :: 0 ::\n          g (n ::ᵥ Nat.rec (f v.tail) (fun y IH => g (y ::ᵥ IH ::ᵥ v.tail)) n ::ᵥ v.tail) ::\n              v.val.tail : List ℕ) ∈\n          PFun.fix\n            (fun v : List ℕ => Part.bind (cg.eval (v.headI :: v.tail.tail))\n              (fun x => Part.some (if v.tail.headI = 0\n                then Sum.inl\n                  (v.headI.succ :: v.tail.headI.pred :: x.headI :: v.tail.tail.tail : List ℕ)\n                else Sum.inr\n                  (v.headI.succ :: v.tail.headI.pred :: x.headI :: v.tail.tail.tail))))\n            (a :: b :: Nat.rec (f v.tail) (fun y IH => g (y ::ᵥ IH ::ᵥ v.tail)) a :: v.val.tail) by\n        erw [Part.eq_some_iff.2 (this 0 n (zero_add n))]\n        simp only [List.headI, Part.bind_some, List.tail_cons]\n      intro a b e\n      induction' b with b IH generalizing a\n      · refine PFun.mem_fix_iff.2 (Or.inl <| Part.eq_some_iff.1 ?_)\n        simp only [hg, ← e, Part.bind_some, List.tail_cons, pure]\n        rfl\n      · refine PFun.mem_fix_iff.2 (Or.inr ⟨_, ?_, IH (a + 1) (by rwa [add_right_comm])⟩)\n        simp only [hg, eval, Part.bind_some, Nat.rec_add_one, List.tail_nil, List.tail_cons, pure]\n        exact Part.mem_some_iff.2 rfl\n  | comp g _ _ IHf IHg => exact exists_code.comp IHf IHg\n  | @rfind n f _ IHf =>\n    obtain ⟨cf, hf⟩ := IHf; refine ⟨rfind cf, fun v => ?_⟩\n    replace hf := fun a => hf (a ::ᵥ v)\n    simp only [Part.map_eq_map, Part.map_some, Vector.cons_val, PFun.coe_val,\n      show ∀ x, pure x = [x] from fun _ => rfl] at hf ⊢\n    refine Part.ext fun x => ?_\n    simp only [rfind, Part.bind_eq_bind, Part.pure_eq_some, Part.map_eq_map, Part.bind_some,\n      exists_prop, cons_eval, comp_eval, fix_eval, tail_eval, succ_eval, zero'_eval,\n      List.headI_nil, List.headI_cons, pred_eval, Part.map_some, false_eq_decide_iff,\n      Part.mem_bind_iff, List.length, Part.mem_map_iff, Nat.mem_rfind, List.tail_nil,\n      List.tail_cons, true_eq_decide_iff, Part.mem_some_iff, Part.map_bind]\n    constructor\n    · rintro ⟨v', h1, rfl⟩\n      suffices ∀ v₁ : List ℕ, v' ∈ PFun.fix\n        (fun v => (cf.eval v).bind fun y => Part.some <|\n          if y.headI = 0 then Sum.inl (v.headI.succ :: v.tail)\n            else Sum.inr (v.headI.succ :: v.tail)) v₁ →\n        ∀ n, (v₁ = n :: v.val) → (∀ m < n, ¬f (m ::ᵥ v) = 0) →\n          ∃ a : ℕ,\n            (f (a ::ᵥ v) = 0 ∧ ∀ {m : ℕ}, m < a → ¬f (m ::ᵥ v) = 0) ∧ [a] = [v'.headI.pred]\n        by exact this _ h1 0 rfl (by rintro _ ⟨⟩)\n      clear h1\n      intro v₀ h1\n      refine PFun.fixInduction h1 fun v₁ h2 IH => ?_\n      clear h1\n      rintro n rfl hm\n      have := PFun.mem_fix_iff.1 h2\n      simp only [hf, Part.bind_some] at this\n      split_ifs at this with h\n      · simp only [List.headI_nil, List.headI_cons, exists_false, or_false, Part.mem_some_iff,\n          List.tail_cons, false_and, Sum.inl.injEq, reduceCtorEq] at this\n        subst this\n        exact ⟨_, ⟨h, @(hm)⟩, rfl⟩\n      · refine IH (n.succ::v.val) (by simp_all) _ rfl fun m h' => ?_\n        obtain h | rfl := Nat.lt_succ_iff_lt_or_eq.1 h'\n        exacts [hm _ h, h]\n    · rintro ⟨n, ⟨hn, hm⟩, rfl⟩\n      refine ⟨n.succ::v.1, ?_, rfl⟩\n      have : (n.succ::v.1 : List ℕ) ∈\n        PFun.fix (fun v =>\n          (cf.eval v).bind fun y =>\n            Part.some <|\n              if y.headI = 0 then Sum.inl (v.headI.succ :: v.tail)\n                else Sum.inr (v.headI.succ :: v.tail))\n            (n::v.val) :=\n        PFun.mem_fix_iff.2 (Or.inl (by simp [hf, hn]))\n      generalize (n.succ :: v.1 : List ℕ) = w at this ⊢\n      clear hn\n      induction n with\n      | zero => exact this\n      | succ n IH =>\n        refine IH (fun {m} h' => hm (Nat.lt_succ_of_lt h'))\n          (PFun.mem_fix_iff.2 (Or.inr ⟨_, ?_, this⟩))\n        simp only [hf, hm n.lt_succ_self, Part.bind_some, List.headI, eq_self_iff_true, if_false,\n          Part.mem_some_iff, and_self_iff, List.tail_cons]\n\n"}
{"name":"Turing.ToPartrec.Cont.comp.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : Turing.ToPartrec.Code\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (SizeOf.sizeOf (Turing.ToPartrec.Cont.comp a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.comp.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.ToPartrec.Cont\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.ToPartrec.Cont\nx✝ : Eq (Turing.ToPartrec.Cont.comp a✝³ a✝²) (Turing.ToPartrec.Cont.comp a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.fix.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : Turing.ToPartrec.Code\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (SizeOf.sizeOf (Turing.ToPartrec.Cont.fix a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.comp.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.ToPartrec.Cont\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (Eq (Turing.ToPartrec.Cont.comp a✝³ a✝²) (Turing.ToPartrec.Cont.comp a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.fix.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.ToPartrec.Cont\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.ToPartrec.Cont\nx✝ : Eq (Turing.ToPartrec.Cont.fix a✝³ a✝²) (Turing.ToPartrec.Cont.fix a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.cons₁.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝⁵ : Turing.ToPartrec.Code\na✝⁴ : List Nat\na✝³ : Turing.ToPartrec.Cont\na✝² : Turing.ToPartrec.Code\na✝¹ : List Nat\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (Eq (Turing.ToPartrec.Cont.cons₁ a✝⁵ a✝⁴ a✝³) (Turing.ToPartrec.Cont.cons₁ a✝² a✝¹ a✝)) (And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝)))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.fix.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.ToPartrec.Cont\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (Eq (Turing.ToPartrec.Cont.fix a✝³ a✝²) (Turing.ToPartrec.Cont.fix a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.cons₂.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : List Nat\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (SizeOf.sizeOf (Turing.ToPartrec.Cont.cons₂ a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.cons₁.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝⁵ : Turing.ToPartrec.Code\na✝⁴ : List Nat\na✝³ : Turing.ToPartrec.Cont\na✝² : Turing.ToPartrec.Code\na✝¹ : List Nat\na✝ : Turing.ToPartrec.Cont\nx✝ : Eq (Turing.ToPartrec.Cont.cons₁ a✝⁵ a✝⁴ a✝³) (Turing.ToPartrec.Cont.cons₁ a✝² a✝¹ a✝)\n⊢ And (Eq a✝⁵ a✝²) (And (Eq a✝⁴ a✝¹) (Eq a✝³ a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.halt.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.ToPartrec.Cont.halt) 1","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.cons₂.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : List Nat\na✝² : Turing.ToPartrec.Cont\na✝¹ : List Nat\na✝ : Turing.ToPartrec.Cont\nx✝ : Eq (Turing.ToPartrec.Cont.cons₂ a✝³ a✝²) (Turing.ToPartrec.Cont.cons₂ a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.cons₂.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : List Nat\na✝² : Turing.ToPartrec.Cont\na✝¹ : List Nat\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (Eq (Turing.ToPartrec.Cont.cons₂ a✝³ a✝²) (Turing.ToPartrec.Cont.cons₂ a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.cons₁.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝² : Turing.ToPartrec.Code\na✝¹ : List Nat\na✝ : Turing.ToPartrec.Cont\n⊢ Eq (SizeOf.sizeOf (Turing.ToPartrec.Cont.cons₁ a✝² a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝²)) (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The type of continuations, built up during evaluation of a `Code` expression. -/\ninductive Cont\n  | halt\n  | cons₁ : Code → List ℕ → Cont → Cont\n  | cons₂ : List ℕ → Cont → Cont\n  | comp : Code → Cont → Cont\n  | fix : Code → Cont → Cont\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cfg.halt.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝ : List Nat\n⊢ Eq (SizeOf.sizeOf (Turing.ToPartrec.Cfg.halt a✝)) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : Cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. -/\ninductive Cfg\n  | halt : List ℕ → Cfg\n  | ret : Cont → List ℕ → Cfg\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cfg.ret.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Cont\na✝² : List Nat\na✝¹ : Turing.ToPartrec.Cont\na✝ : List Nat\nx✝ : Eq (Turing.ToPartrec.Cfg.ret a✝³ a✝²) (Turing.ToPartrec.Cfg.ret a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : Cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. -/\ninductive Cfg\n  | halt : List ℕ → Cfg\n  | ret : Cont → List ℕ → Cfg\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cfg.ret.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Cont\na✝² : List Nat\na✝¹ : Turing.ToPartrec.Cont\na✝ : List Nat\n⊢ Eq (Eq (Turing.ToPartrec.Cfg.ret a✝³ a✝²) (Turing.ToPartrec.Cfg.ret a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : Cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. -/\ninductive Cfg\n  | halt : List ℕ → Cfg\n  | ret : Cont → List ℕ → Cfg\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cfg.halt.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : List Nat\n⊢ Eq (Eq (Turing.ToPartrec.Cfg.halt a✝¹) (Turing.ToPartrec.Cfg.halt a✝)) (Eq a✝¹ a✝)","decl":"/-- The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : Cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. -/\ninductive Cfg\n  | halt : List ℕ → Cfg\n  | ret : Cont → List ℕ → Cfg\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cfg.halt.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : List Nat\nx✝ : Eq (Turing.ToPartrec.Cfg.halt a✝¹) (Turing.ToPartrec.Cfg.halt a✝)\n⊢ Eq a✝¹ a✝","decl":"/-- The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : Cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. -/\ninductive Cfg\n  | halt : List ℕ → Cfg\n  | ret : Cont → List ℕ → Cfg\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cfg.ret.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : Turing.ToPartrec.Cont\na✝ : List Nat\n⊢ Eq (SizeOf.sizeOf (Turing.ToPartrec.Cfg.ret a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- The set of configurations of the machine:\n\n* `halt v`: The machine is about to stop and `v : List ℕ` is the result.\n* `ret k v`: The machine is about to pass `v : List ℕ` to continuation `k : Cont`.\n\nWe don't have a state corresponding to normal evaluation because these are evaluated immediately\nto a `ret` \"in zero steps\" using the `stepNormal` function. -/\ninductive Cfg\n  | halt : List ℕ → Cfg\n  | ret : Cont → List ℕ → Cfg\n  deriving Inhabited\n\n"}
{"name":"Turing.ToPartrec.Cont.then_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k k' : Turing.ToPartrec.Cont\nv : List Nat\n⊢ Eq ((k.then k').eval v) (Bind.bind (k.eval v) k'.eval)","decl":"theorem Cont.then_eval {k k' : Cont} {v} : (k.then k').eval v = k.eval v >>= k'.eval := by\n  induction k generalizing v with\n  | halt => simp only [Cont.eval, Cont.then, pure_bind]\n  | cons₁ => simp only [Cont.eval, Cont.then, bind_assoc, *]\n  | cons₂ => simp only [Cont.eval, Cont.then, *]\n  | comp _ _ k_ih => simp only [Cont.eval, Cont.then, bind_assoc, ← k_ih]\n  | fix _ _ k_ih =>\n    simp only [Cont.eval, Cont.then, *]\n    split_ifs <;> [rfl; simp only [← k_ih, bind_assoc]]\n\n"}
{"name":"Turing.ToPartrec.stepNormal_then","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nk k' : Turing.ToPartrec.Cont\nv : List Nat\n⊢ Eq (Turing.ToPartrec.stepNormal c (k.then k') v) ((Turing.ToPartrec.stepNormal c k v).then k')","decl":"/-- The `stepNormal` function respects the `then k'` homomorphism. Note that this is an exact\nequality, not a simulation; the original and embedded machines move in lock-step until the\nembedded machine reaches the halt state. -/\ntheorem stepNormal_then (c) (k k' : Cont) (v) :\n    stepNormal c (k.then k') v = (stepNormal c k v).then k' := by\n  induction c generalizing k v with simp only [Cont.then, stepNormal, *]\n  | cons c c' ih _ => rw [← ih, Cont.then]\n  | comp c c' _ ih' => rw [← ih', Cont.then]\n  | case => cases v.headI <;> simp only [Nat.rec_zero]\n  | fix c ih => rw [← ih, Cont.then]\n  | _ => simp only [Cfg.then]\n\n"}
{"name":"Turing.ToPartrec.stepRet_then","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k k' : Turing.ToPartrec.Cont\nv : List Nat\n⊢ Eq (Turing.ToPartrec.stepRet (k.then k') v) ((Turing.ToPartrec.stepRet k v).then k')","decl":"/-- The `stepRet` function respects the `then k'` homomorphism. Note that this is an exact\nequality, not a simulation; the original and embedded machines move in lock-step until the\nembedded machine reaches the halt state. -/\ntheorem stepRet_then {k k' : Cont} {v} : stepRet (k.then k') v = (stepRet k v).then k' := by\n  induction k generalizing v with simp only [Cont.then, stepRet, *]\n  | cons₁ =>\n    rw [← stepNormal_then]\n    rfl\n  | comp =>\n    rw [← stepNormal_then]\n  | fix _ _ k_ih =>\n    split_ifs\n    · rw [← k_ih]\n    · rw [← stepNormal_then]\n      rfl\n  | _ => simp only [Cfg.then]\n\n"}
{"name":"Turing.ToPartrec.Code.Ok.zero","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nh : c.Ok\nv : List Nat\n⊢ Eq (Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.stepNormal c Turing.ToPartrec.Cont.halt v)) (Functor.map Turing.ToPartrec.Cfg.halt (c.eval v))","decl":"theorem Code.Ok.zero {c} (h : Code.Ok c) {v} :\n    Turing.eval step (stepNormal c Cont.halt v) = Cfg.halt <$> Code.eval c v := by\n  rw [h, ← bind_pure_comp]; congr; funext v\n  exact Part.eq_some_iff.2 (mem_eval.2 ⟨ReflTransGen.single rfl, rfl⟩)\n\n"}
{"name":"Turing.ToPartrec.stepNormal.is_ret","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nk : Turing.ToPartrec.Cont\nv : List Nat\n⊢ Exists fun k' => Exists fun v' => Eq (Turing.ToPartrec.stepNormal c k v) (Turing.ToPartrec.Cfg.ret k' v')","decl":"theorem stepNormal.is_ret (c k v) : ∃ k' v', stepNormal c k v = Cfg.ret k' v' := by\n  induction c generalizing k v with\n  | cons _f fs IHf _IHfs => apply IHf\n  | comp f _g _IHf IHg => apply IHg\n  | case f g IHf IHg =>\n    rw [stepNormal]\n    simp only []\n    cases v.headI <;> [apply IHf; apply IHg]\n  | fix f IHf => apply IHf\n  | _ => exact ⟨_, _, rfl⟩\n\n"}
{"name":"Turing.ToPartrec.cont_eval_fix","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\nk : Turing.ToPartrec.Cont\nv : List Nat\nfok : f.Ok\n⊢ Eq (Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.stepNormal f (Turing.ToPartrec.Cont.fix f k) v)) (Bind.bind (f.fix.eval v) fun v => Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.Cfg.ret k v))","decl":"theorem cont_eval_fix {f k v} (fok : Code.Ok f) :\n    Turing.eval step (stepNormal f (Cont.fix f k) v) =\n      f.fix.eval v >>= fun v => Turing.eval step (Cfg.ret k v) := by\n  refine Part.ext fun x => ?_\n  simp only [Part.bind_eq_bind, Part.mem_bind_iff]\n  constructor\n  · suffices ∀ c, x ∈ eval step c → ∀ v c', c = Cfg.then c' (Cont.fix f k) →\n      Reaches step (stepNormal f Cont.halt v) c' →\n        ∃ v₁ ∈ f.eval v, ∃ v₂ ∈ if List.headI v₁ = 0 then pure v₁.tail else f.fix.eval v₁.tail,\n          x ∈ eval step (Cfg.ret k v₂) by\n      intro h\n      obtain ⟨v₁, hv₁, v₂, hv₂, h₃⟩ :=\n        this _ h _ _ (stepNormal_then _ Cont.halt _ _) ReflTransGen.refl\n      refine ⟨v₂, PFun.mem_fix_iff.2 ?_, h₃⟩\n      simp only [Part.eq_some_iff.2 hv₁, Part.map_some]\n      split_ifs at hv₂ ⊢\n      · rw [Part.mem_some_iff.1 hv₂]\n        exact Or.inl (Part.mem_some _)\n      · exact Or.inr ⟨_, Part.mem_some _, hv₂⟩\n    refine fun c he => evalInduction he fun y h IH => ?_\n    rintro v (⟨v'⟩ | ⟨k', v'⟩) rfl hr <;> rw [Cfg.then] at h IH <;> simp only [] at h IH\n    · have := mem_eval.2 ⟨hr, rfl⟩\n      rw [fok, Part.bind_eq_bind, Part.mem_bind_iff] at this\n      obtain ⟨v'', h₁, h₂⟩ := this\n      rw [reaches_eval] at h₂\n      swap\n      · exact ReflTransGen.single rfl\n      cases Part.mem_unique h₂ (mem_eval.2 ⟨ReflTransGen.refl, rfl⟩)\n      refine ⟨v', h₁, ?_⟩\n      rw [stepRet] at h\n      revert h\n      by_cases he : v'.headI = 0 <;> simp only [exists_prop, if_pos, if_false, he] <;> intro h\n      · refine ⟨_, Part.mem_some _, ?_⟩\n        rw [reaches_eval]\n        · exact h\n        exact ReflTransGen.single rfl\n      · obtain ⟨k₀, v₀, e₀⟩ := stepNormal.is_ret f Cont.halt v'.tail\n        have e₁ := stepNormal_then f Cont.halt (Cont.fix f k) v'.tail\n        rw [e₀, Cont.then, Cfg.then] at e₁\n        simp only [] at e₁\n        obtain ⟨v₁, hv₁, v₂, hv₂, h₃⟩ :=\n          IH (stepRet (k₀.then (Cont.fix f k)) v₀) (by rw [stepRet, if_neg he, e₁]; rfl)\n            v'.tail _ stepRet_then (by apply ReflTransGen.single; rw [e₀]; rfl)\n        refine ⟨_, PFun.mem_fix_iff.2 ?_, h₃⟩\n        simp only [Part.eq_some_iff.2 hv₁, Part.map_some, Part.mem_some_iff]\n        split_ifs at hv₂ ⊢ <;> [exact Or.inl (congr_arg Sum.inl (Part.mem_some_iff.1 hv₂));\n          exact Or.inr ⟨_, rfl, hv₂⟩]\n    · exact IH _ rfl _ _ stepRet_then (ReflTransGen.tail hr rfl)\n  · rintro ⟨v', he, hr⟩\n    rw [reaches_eval] at hr\n    swap\n    · exact ReflTransGen.single rfl\n    refine PFun.fixInduction he fun v (he : v' ∈ f.fix.eval v) IH => ?_\n    rw [fok, Part.bind_eq_bind, Part.mem_bind_iff]\n    obtain he | ⟨v'', he₁', _⟩ := PFun.mem_fix_iff.1 he\n    · obtain ⟨v', he₁, he₂⟩ := (Part.mem_map_iff _).1 he\n      split_ifs at he₂ with h; cases he₂\n      refine ⟨_, he₁, ?_⟩\n      rw [reaches_eval]\n      swap\n      · exact ReflTransGen.single rfl\n      rwa [stepRet, if_pos h]\n    · obtain ⟨v₁, he₁, he₂⟩ := (Part.mem_map_iff _).1 he₁'\n      split_ifs at he₂ with h; cases he₂\n      clear he₁'\n      refine ⟨_, he₁, ?_⟩\n      rw [reaches_eval]\n      swap\n      · exact ReflTransGen.single rfl\n      rw [stepRet, if_neg h]\n      exact IH v₁.tail ((Part.mem_map_iff _).2 ⟨_, he₁, if_neg h⟩)\n\n"}
{"name":"Turing.ToPartrec.code_is_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\n⊢ c.Ok","decl":"theorem code_is_ok (c) : Code.Ok c := by\n  induction c with (intro k v; rw [stepNormal])\n  | cons f fs IHf IHfs =>\n    rw [Code.eval, IHf]\n    simp only [bind_assoc, Cont.eval, pure_bind]; congr; funext v\n    rw [reaches_eval]; swap\n    · exact ReflTransGen.single rfl\n    rw [stepRet, IHfs]; congr; funext v'\n    refine Eq.trans (b := eval step (stepRet (Cont.cons₂ v k) v')) ?_ (Eq.symm ?_) <;>\n      exact reaches_eval (ReflTransGen.single rfl)\n  | comp f g IHf IHg =>\n    rw [Code.eval, IHg]\n    simp only [bind_assoc, Cont.eval, pure_bind]; congr; funext v\n    rw [reaches_eval]; swap\n    · exact ReflTransGen.single rfl\n    rw [stepRet, IHf]\n  | case f g IHf IHg =>\n    simp only [Code.eval]\n    cases v.headI <;> simp only [Nat.rec_zero, Part.bind_eq_bind] <;> [apply IHf; apply IHg]\n  | fix f IHf => rw [cont_eval_fix IHf]\n  | _ => simp only [Code.eval, pure_bind]\n\n"}
{"name":"Turing.ToPartrec.stepNormal_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nv : List Nat\n⊢ Eq (Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.stepNormal c Turing.ToPartrec.Cont.halt v)) (Functor.map Turing.ToPartrec.Cfg.halt (c.eval v))","decl":"theorem stepNormal_eval (c v) : eval step (stepNormal c Cont.halt v) = Cfg.halt <$> c.eval v :=\n  (code_is_ok c).zero\n\n"}
{"name":"Turing.ToPartrec.stepRet_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.ToPartrec.Cont\nv : List Nat\n⊢ Eq (Turing.eval Turing.ToPartrec.step (Turing.ToPartrec.stepRet k v)) (Functor.map Turing.ToPartrec.Cfg.halt (k.eval v))","decl":"theorem stepRet_eval {k v} : eval step (stepRet k v) = Cfg.halt <$> k.eval v := by\n  induction k generalizing v with\n  | halt =>\n    simp only [mem_eval, Cont.eval, map_pure]\n    exact Part.eq_some_iff.2 (mem_eval.2 ⟨ReflTransGen.refl, rfl⟩)\n  | cons₁ fs as k IH =>\n    rw [Cont.eval, stepRet, code_is_ok]\n    simp only [← bind_pure_comp, bind_assoc]; congr; funext v'\n    rw [reaches_eval]; swap\n    · exact ReflTransGen.single rfl\n    rw [stepRet, IH, bind_pure_comp]\n  | cons₂ ns k IH => rw [Cont.eval, stepRet]; exact IH\n  | comp f k IH =>\n    rw [Cont.eval, stepRet, code_is_ok]\n    simp only [← bind_pure_comp, bind_assoc]; congr; funext v'\n    rw [reaches_eval]; swap\n    · exact ReflTransGen.single rfl\n    rw [IH, bind_pure_comp]\n  | fix f k IH =>\n    rw [Cont.eval, stepRet]; simp only [bind_pure_comp]\n    split_ifs; · exact IH\n    simp only [← bind_pure_comp, bind_assoc, cont_eval_fix (code_is_ok _)]\n    congr; funext; rw [bind_pure_comp, ← IH]\n    exact reaches_eval (ReflTransGen.single rfl)\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.consₗ.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.Γ'.consₗ) 1","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.bit0.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.Γ'.bit0) 1","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.cons.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.Γ'.cons) 1","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.enumList_get?_to_CtorIdx_eq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"x✝ : Turing.PartrecToTM2.Γ'\n⊢ Eq (Turing.PartrecToTM2.Γ'.enumList.get? x✝.toCtorIdx) (Option.some x✝)","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.bit1.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.Γ'.bit1) 1","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.enumList_nodup","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Turing.PartrecToTM2.Γ'.enumList.Nodup","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.Γ'.ofNat_toCtorIdx","module":"Mathlib.Computability.TMToPartrec","initialProofState":"x : Turing.PartrecToTM2.Γ'\n⊢ Eq (Turing.PartrecToTM2.Γ'.ofNat x.toCtorIdx) x","decl":"/-- The alphabet for the stacks in the program. `bit0` and `bit1` are used to represent `ℕ` values\nas lists of binary digits, `cons` is used to separate `List ℕ` values, and `consₗ` is used to\nseparate `List (List ℕ)` values. See the section documentation. -/\ninductive Γ'\n  | consₗ\n  | cons\n  | bit0\n  | bit1\n  deriving DecidableEq, Inhabited, Fintype\n\n"}
{"name":"Turing.PartrecToTM2.K'.stack.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.K'.stack) 1","decl":"/-- The four stacks used by the program. `main` is used to store the input value in `trNormal`\nmode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the\ncontinuations. `rev` is used to store reversed lists when transferring values between stacks, and\n`aux` is only used once in `cons₁`. See the section documentation. -/\ninductive K'\n  | main\n  | rev\n  | aux\n  | stack\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.K'.aux.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.K'.aux) 1","decl":"/-- The four stacks used by the program. `main` is used to store the input value in `trNormal`\nmode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the\ncontinuations. `rev` is used to store reversed lists when transferring values between stacks, and\n`aux` is only used once in `cons₁`. See the section documentation. -/\ninductive K'\n  | main\n  | rev\n  | aux\n  | stack\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.K'.main.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.K'.main) 1","decl":"/-- The four stacks used by the program. `main` is used to store the input value in `trNormal`\nmode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the\ncontinuations. `rev` is used to store reversed lists when transferring values between stacks, and\n`aux` is only used once in `cons₁`. See the section documentation. -/\ninductive K'\n  | main\n  | rev\n  | aux\n  | stack\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.K'.ofNat_toCtorIdx","module":"Mathlib.Computability.TMToPartrec","initialProofState":"x : Turing.PartrecToTM2.K'\n⊢ Eq (Turing.PartrecToTM2.K'.ofNat x.toCtorIdx) x","decl":"/-- The four stacks used by the program. `main` is used to store the input value in `trNormal`\nmode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the\ncontinuations. `rev` is used to store reversed lists when transferring values between stacks, and\n`aux` is only used once in `cons₁`. See the section documentation. -/\ninductive K'\n  | main\n  | rev\n  | aux\n  | stack\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.K'.rev.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.K'.rev) 1","decl":"/-- The four stacks used by the program. `main` is used to store the input value in `trNormal`\nmode and the output value in `Λ'.ret` mode, while `stack` is used to keep all the data for the\ncontinuations. `rev` is used to store reversed lists when transferring values between stacks, and\n`aux` is only used once in `cons₁`. See the section documentation. -/\ninductive K'\n  | main\n  | rev\n  | aux\n  | stack\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.comp.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.PartrecToTM2.Cont'\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (Eq (Turing.PartrecToTM2.Cont'.comp a✝³ a✝²) (Turing.PartrecToTM2.Cont'.comp a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.cons₁.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.PartrecToTM2.Cont'\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (Eq (Turing.PartrecToTM2.Cont'.cons₁ a✝³ a✝²) (Turing.PartrecToTM2.Cont'.cons₁ a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.cons₂.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (SizeOf.sizeOf a✝.cons₂) (HAdd.hAdd 1 (SizeOf.sizeOf a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.cons₁.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.PartrecToTM2.Cont'\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\nx✝ : Eq (Turing.PartrecToTM2.Cont'.cons₁ a✝³ a✝²) (Turing.PartrecToTM2.Cont'.cons₁ a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.halt.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (SizeOf.sizeOf Turing.PartrecToTM2.Cont'.halt) 1","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.cons₂.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.PartrecToTM2.Cont'\nx✝ : Eq a✝¹.cons₂ a✝.cons₂\n⊢ Eq a✝¹ a✝","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.cons₂.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ a✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (Eq a✝¹.cons₂ a✝.cons₂) (Eq a✝¹ a✝)","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.fix.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Cont'.fix a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.cons₁.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Cont'.cons₁ a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.fix.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.PartrecToTM2.Cont'\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\nx✝ : Eq (Turing.PartrecToTM2.Cont'.fix a✝³ a✝²) (Turing.PartrecToTM2.Cont'.fix a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.comp.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Cont'.comp a✝¹ a✝)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf a✝¹)) (SizeOf.sizeOf a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.fix.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.PartrecToTM2.Cont'\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\n⊢ Eq (Eq (Turing.PartrecToTM2.Cont'.fix a✝³ a✝²) (Turing.PartrecToTM2.Cont'.fix a✝¹ a✝)) (And (Eq a✝³ a✝¹) (Eq a✝² a✝))","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Cont'.comp.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a✝³ : Turing.ToPartrec.Code\na✝² : Turing.PartrecToTM2.Cont'\na✝¹ : Turing.ToPartrec.Code\na✝ : Turing.PartrecToTM2.Cont'\nx✝ : Eq (Turing.PartrecToTM2.Cont'.comp a✝³ a✝²) (Turing.PartrecToTM2.Cont'.comp a✝¹ a✝)\n⊢ And (Eq a✝³ a✝¹) (Eq a✝² a✝)","decl":"/-- Continuations as in `ToPartrec.Cont` but with the data removed. This is done because we want\nthe set of all continuations in the program to be finite (so that it can ultimately be encoded into\nthe finite state machine of a Turing machine), but a continuation can handle a potentially infinite\nnumber of data values during execution. -/\ninductive Cont'\n  | halt\n  | cons₁ : Code → Cont' → Cont'\n  | cons₂ : Cont' → Cont'\n  | comp : Code → Cont' → Cont'\n  | fix : Code → Cont' → Cont'\n  deriving DecidableEq, Inhabited\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.push.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.K'\ns : Option Turing.PartrecToTM2.Γ' → Option Turing.PartrecToTM2.Γ'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Λ'.push k s q)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.ret.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k✝ k : Turing.PartrecToTM2.Cont'\nx✝ : Eq (Turing.PartrecToTM2.Λ'.ret k✝) (Turing.PartrecToTM2.Λ'.ret k)\n⊢ Eq k✝ k","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.pred.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q₁✝ q₂✝ q₁ q₂ : Turing.PartrecToTM2.Λ'\nx✝ : Eq (q₁✝.pred q₂✝) (q₁.pred q₂)\n⊢ And (Eq q₁✝ q₁) (Eq q₂✝ q₂)","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.clear.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Λ'.clear p k q)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k)) (SizeOf.sizeOf q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.read.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f✝ f : Option Turing.PartrecToTM2.Γ' → Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq (Turing.PartrecToTM2.Λ'.read f✝) (Turing.PartrecToTM2.Λ'.read f)) (Eq f✝ f)","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.clear.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p✝ : Turing.PartrecToTM2.Γ' → Bool\nk✝ : Turing.PartrecToTM2.K'\nq✝ : Turing.PartrecToTM2.Λ'\np : Turing.PartrecToTM2.Γ' → Bool\nk : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\nx✝ : Eq (Turing.PartrecToTM2.Λ'.clear p✝ k✝ q✝) (Turing.PartrecToTM2.Λ'.clear p k q)\n⊢ And (Eq p✝ p) (And (Eq k✝ k) (Eq q✝ q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.read.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Option Turing.PartrecToTM2.Γ' → Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Λ'.read f)) 1","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.copy.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q✝ q : Turing.PartrecToTM2.Λ'\nx✝ : Eq q✝.copy q.copy\n⊢ Eq q✝ q","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.move.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk₁ k₂ : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Λ'.move p k₁ k₂ q)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf k₁)) (SizeOf.sizeOf k₂)) (SizeOf.sizeOf q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.succ.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q✝ q : Turing.PartrecToTM2.Λ'\nx✝ : Eq q✝.succ q.succ\n⊢ Eq q✝ q","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.pred.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q₁ q₂ : Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf (q₁.pred q₂)) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf q₁)) (SizeOf.sizeOf q₂))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.clear.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p✝ : Turing.PartrecToTM2.Γ' → Bool\nk✝ : Turing.PartrecToTM2.K'\nq✝ : Turing.PartrecToTM2.Λ'\np : Turing.PartrecToTM2.Γ' → Bool\nk : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq (Turing.PartrecToTM2.Λ'.clear p✝ k✝ q✝) (Turing.PartrecToTM2.Λ'.clear p k q)) (And (Eq p✝ p) (And (Eq k✝ k) (Eq q✝ q)))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.read.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f✝ f : Option Turing.PartrecToTM2.Γ' → Turing.PartrecToTM2.Λ'\nx✝ : Eq (Turing.PartrecToTM2.Λ'.read f✝) (Turing.PartrecToTM2.Λ'.read f)\n⊢ Eq f✝ f","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.succ.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q✝ q : Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq q✝.succ q.succ) (Eq q✝ q)","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.copy.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q✝ q : Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq q✝.copy q.copy) (Eq q✝ q)","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.push.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k✝ : Turing.PartrecToTM2.K'\ns✝ : Option Turing.PartrecToTM2.Γ' → Option Turing.PartrecToTM2.Γ'\nq✝ : Turing.PartrecToTM2.Λ'\nk : Turing.PartrecToTM2.K'\ns : Option Turing.PartrecToTM2.Γ' → Option Turing.PartrecToTM2.Γ'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq (Turing.PartrecToTM2.Λ'.push k✝ s✝ q✝) (Turing.PartrecToTM2.Λ'.push k s q)) (And (Eq k✝ k) (And (Eq s✝ s) (Eq q✝ q)))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.move.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p✝ : Turing.PartrecToTM2.Γ' → Bool\nk₁✝ k₂✝ : Turing.PartrecToTM2.K'\nq✝ : Turing.PartrecToTM2.Λ'\np : Turing.PartrecToTM2.Γ' → Bool\nk₁ k₂ : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\nx✝ : Eq (Turing.PartrecToTM2.Λ'.move p✝ k₁✝ k₂✝ q✝) (Turing.PartrecToTM2.Λ'.move p k₁ k₂ q)\n⊢ And (Eq p✝ p) (And (Eq k₁✝ k₁) (And (Eq k₂✝ k₂) (Eq q✝ q)))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.copy.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf q.copy) (HAdd.hAdd 1 (SizeOf.sizeOf q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.succ.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\n⊢ Eq (SizeOf.sizeOf q.succ) (HAdd.hAdd 1 (SizeOf.sizeOf q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.ret.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k✝ k : Turing.PartrecToTM2.Cont'\n⊢ Eq (Eq (Turing.PartrecToTM2.Λ'.ret k✝) (Turing.PartrecToTM2.Λ'.ret k)) (Eq k✝ k)","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.ret.sizeOf_spec","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.Cont'\n⊢ Eq (SizeOf.sizeOf (Turing.PartrecToTM2.Λ'.ret k)) (HAdd.hAdd 1 (SizeOf.sizeOf k))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.push.inj","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k✝ : Turing.PartrecToTM2.K'\ns✝ : Option Turing.PartrecToTM2.Γ' → Option Turing.PartrecToTM2.Γ'\nq✝ : Turing.PartrecToTM2.Λ'\nk : Turing.PartrecToTM2.K'\ns : Option Turing.PartrecToTM2.Γ' → Option Turing.PartrecToTM2.Γ'\nq : Turing.PartrecToTM2.Λ'\nx✝ : Eq (Turing.PartrecToTM2.Λ'.push k✝ s✝ q✝) (Turing.PartrecToTM2.Λ'.push k s q)\n⊢ And (Eq k✝ k) (And (Eq s✝ s) (Eq q✝ q))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.pred.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q₁✝ q₂✝ q₁ q₂ : Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq (q₁✝.pred q₂✝) (q₁.pred q₂)) (And (Eq q₁✝ q₁) (Eq q₂✝ q₂))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.Λ'.move.injEq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p✝ : Turing.PartrecToTM2.Γ' → Bool\nk₁✝ k₂✝ : Turing.PartrecToTM2.K'\nq✝ : Turing.PartrecToTM2.Λ'\np : Turing.PartrecToTM2.Γ' → Bool\nk₁ k₂ : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (Eq (Turing.PartrecToTM2.Λ'.move p✝ k₁✝ k₂✝ q✝) (Turing.PartrecToTM2.Λ'.move p k₁ k₂ q)) (And (Eq p✝ p) (And (Eq k₁✝ k₁) (And (Eq k₂✝ k₂) (Eq q✝ q))))","decl":"/-- The set of program positions. We make extensive use of inductive types here to let us describe\n\"subroutines\"; for example `clear p k q` is a program that clears stack `k`, then does `q` where\n`q` is another label. In order to prevent this from resulting in an infinite number of distinct\naccessible states, we are careful to be non-recursive (although loops are okay). See the section\ndocumentation for a description of all the programs. -/\ninductive Λ'\n  | move (p : Γ' → Bool) (k₁ k₂ : K') (q : Λ')\n  | clear (p : Γ' → Bool) (k : K') (q : Λ')\n  | copy (q : Λ')\n  | push (k : K') (s : Option Γ' → Option Γ') (q : Λ')\n  | read (f : Option Γ' → Λ')\n  | succ (q : Λ')\n  | pred (q₁ q₂ : Λ')\n  | ret (k : Cont')\n\n"}
{"name":"Turing.PartrecToTM2.tr_move","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk₁ k₂ : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.move p k₁ k₂ q)) (Turing.PartrecToTM2.pop' k₁ (Turing.TM2.Stmt.branch (fun s => s.elim Bool.true p) (Turing.TM2.Stmt.goto fun x => q) (Turing.PartrecToTM2.push' k₂ (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.Λ'.move p k₁ k₂ q))))","decl":"@[simp]\ntheorem tr_move (p k₁ k₂ q) : tr (Λ'.move p k₁ k₂ q) =\n    pop' k₁ (branch (fun s => s.elim true p) (goto fun _ => q)\n      (push' k₂ <| goto fun _ => Λ'.move p k₁ k₂ q)) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_push","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.K'\nf : Option Turing.PartrecToTM2.Γ' → Option Turing.PartrecToTM2.Γ'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.push k f q)) (Turing.TM2.Stmt.branch (fun s => (f s).isSome) (Turing.TM2.Stmt.push k (fun s => (f s).iget) (Turing.TM2.Stmt.goto fun x => q)) (Turing.TM2.Stmt.goto fun x => q))","decl":"@[simp]\ntheorem tr_push (k f q) : tr (Λ'.push k f q) = branch (fun s => (f s).isSome)\n    ((push k fun s => (f s).iget) <| goto fun _ => q) (goto fun _ => q) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_read","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Option Turing.PartrecToTM2.Γ' → Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.read q)) (Turing.TM2.Stmt.goto q)","decl":"@[simp]\ntheorem tr_read (q) : tr (Λ'.read q) = goto q := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_clear","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.clear p k q)) (Turing.PartrecToTM2.pop' k (Turing.TM2.Stmt.branch (fun s => s.elim Bool.true p) (Turing.TM2.Stmt.goto fun x => q) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.Λ'.clear p k q)))","decl":"@[simp]\ntheorem tr_clear (p k q) : tr (Λ'.clear p k q) = pop' k (branch\n    (fun s => s.elim true p) (goto fun _ => q) (goto fun _ => Λ'.clear p k q)) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_copy","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr q.copy) (Turing.PartrecToTM2.pop' Turing.PartrecToTM2.K'.rev (Turing.TM2.Stmt.branch Option.isSome (Turing.PartrecToTM2.push' Turing.PartrecToTM2.K'.main (Turing.PartrecToTM2.push' Turing.PartrecToTM2.K'.stack (Turing.TM2.Stmt.goto fun x => q.copy))) (Turing.TM2.Stmt.goto fun x => q)))","decl":"@[simp]\ntheorem tr_copy (q) : tr (Λ'.copy q) = pop' rev (branch Option.isSome\n    (push' main <| push' stack <| goto fun _ => Λ'.copy q) (goto fun _ => q)) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_succ","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr q.succ) (Turing.PartrecToTM2.pop' Turing.PartrecToTM2.K'.main (Turing.TM2.Stmt.branch (fun s => Decidable.decide (Eq s (Option.some Turing.PartrecToTM2.Γ'.bit1))) (Turing.TM2.Stmt.push Turing.PartrecToTM2.K'.rev (fun x => Turing.PartrecToTM2.Γ'.bit0) (Turing.TM2.Stmt.goto fun x => q.succ)) (Turing.TM2.Stmt.branch (fun s => Decidable.decide (Eq s (Option.some Turing.PartrecToTM2.Γ'.cons))) (Turing.TM2.Stmt.push Turing.PartrecToTM2.K'.main (fun x => Turing.PartrecToTM2.Γ'.cons) (Turing.TM2.Stmt.push Turing.PartrecToTM2.K'.main (fun x => Turing.PartrecToTM2.Γ'.bit1) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.unrev q))) (Turing.TM2.Stmt.push Turing.PartrecToTM2.K'.main (fun x => Turing.PartrecToTM2.Γ'.bit1) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.unrev q)))))","decl":"@[simp]\ntheorem tr_succ (q) : tr (Λ'.succ q) = pop' main (branch (fun s => s = some Γ'.bit1)\n    ((push rev fun _ => Γ'.bit0) <| goto fun _ => Λ'.succ q) <|\n      branch (fun s => s = some Γ'.cons)\n        ((push main fun _ => Γ'.cons) <| (push main fun _ => Γ'.bit1) <| goto fun _ => unrev q)\n        ((push main fun _ => Γ'.bit1) <| goto fun _ => unrev q)) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_pred","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q₁ q₂ : Turing.PartrecToTM2.Λ'\n⊢ Eq (Turing.PartrecToTM2.tr (q₁.pred q₂)) (Turing.PartrecToTM2.pop' Turing.PartrecToTM2.K'.main (Turing.TM2.Stmt.branch (fun s => Decidable.decide (Eq s (Option.some Turing.PartrecToTM2.Γ'.bit0))) (Turing.TM2.Stmt.push Turing.PartrecToTM2.K'.rev (fun x => Turing.PartrecToTM2.Γ'.bit1) (Turing.TM2.Stmt.goto fun x => q₁.pred q₂)) (Turing.TM2.Stmt.branch (fun s => Turing.PartrecToTM2.natEnd s.iget) (Turing.TM2.Stmt.goto fun x => q₁) (Turing.PartrecToTM2.peek' Turing.PartrecToTM2.K'.main (Turing.TM2.Stmt.branch (fun s => Turing.PartrecToTM2.natEnd s.iget) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.unrev q₂) (Turing.TM2.Stmt.push Turing.PartrecToTM2.K'.rev (fun x => Turing.PartrecToTM2.Γ'.bit0) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.unrev q₂)))))))","decl":"@[simp]\ntheorem tr_pred (q₁ q₂) : tr (Λ'.pred q₁ q₂) = pop' main (branch (fun s => s = some Γ'.bit0)\n    ((push rev fun _ => Γ'.bit1) <| goto fun _ => Λ'.pred q₁ q₂) <|\n    branch (fun s => natEnd s.iget) (goto fun _ => q₁)\n      (peek' main <|\n        branch (fun s => natEnd s.iget) (goto fun _ => unrev q₂)\n          ((push rev fun _ => Γ'.bit0) <| goto fun _ => unrev q₂))) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_ret_cons₁","module":"Mathlib.Computability.TMToPartrec","initialProofState":"fs : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.ret (Turing.PartrecToTM2.Cont'.cons₁ fs k))) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.move₂ (fun x => Bool.false) Turing.PartrecToTM2.K'.main Turing.PartrecToTM2.K'.aux (Turing.PartrecToTM2.move₂ (fun s => Decidable.decide (Eq s Turing.PartrecToTM2.Γ'.consₗ)) Turing.PartrecToTM2.K'.stack Turing.PartrecToTM2.K'.main (Turing.PartrecToTM2.move₂ (fun x => Bool.false) Turing.PartrecToTM2.K'.aux Turing.PartrecToTM2.K'.stack (Turing.PartrecToTM2.trNormal fs k.cons₂))))","decl":"@[simp]\ntheorem tr_ret_cons₁ (fs k) : tr (Λ'.ret (Cont'.cons₁ fs k)) = goto fun _ =>\n    move₂ (fun _ => false) main aux <|\n      move₂ (fun s => s = Γ'.consₗ) stack main <|\n        move₂ (fun _ => false) aux stack <| trNormal fs (Cont'.cons₂ k) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_ret_cons₂","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.ret k.cons₂)) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.head Turing.PartrecToTM2.K'.stack (Turing.PartrecToTM2.Λ'.ret k))","decl":"@[simp]\ntheorem tr_ret_cons₂ (k) : tr (Λ'.ret (Cont'.cons₂ k)) =\n    goto fun _ => head stack <| Λ'.ret k := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_ret_comp","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.ret (Turing.PartrecToTM2.Cont'.comp f k))) (Turing.TM2.Stmt.goto fun x => Turing.PartrecToTM2.trNormal f k)","decl":"@[simp]\ntheorem tr_ret_comp (f k) : tr (Λ'.ret (Cont'.comp f k)) = goto fun _ => trNormal f k := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_ret_fix","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.ret (Turing.PartrecToTM2.Cont'.fix f k))) (Turing.PartrecToTM2.pop' Turing.PartrecToTM2.K'.main (Turing.TM2.Stmt.goto fun s => cond (Turing.PartrecToTM2.natEnd s.iget) (Turing.PartrecToTM2.Λ'.ret k) (Turing.PartrecToTM2.Λ'.clear Turing.PartrecToTM2.natEnd Turing.PartrecToTM2.K'.main (Turing.PartrecToTM2.trNormal f (Turing.PartrecToTM2.Cont'.fix f k)))))","decl":"@[simp]\ntheorem tr_ret_fix (f k) : tr (Λ'.ret (Cont'.fix f k)) = pop' main (goto fun s =>\n    cond (natEnd s.iget) (Λ'.ret k) <| Λ'.clear natEnd main <| trNormal f (Cont'.fix f k)) := rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_ret_halt","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.ret Turing.PartrecToTM2.Cont'.halt)) (Turing.TM2.Stmt.load (fun x => Option.none) Turing.TM2.Stmt.halt)","decl":"@[simp]\ntheorem tr_ret_halt : tr (Λ'.ret Cont'.halt) = (load fun _ => none) halt := rfl\n\n"}
{"name":"Turing.PartrecToTM2.trNat_zero","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (Turing.PartrecToTM2.trNat 0) List.nil","decl":"@[simp]\ntheorem trNat_zero : trNat 0 = [] := by rw [trNat, Nat.cast_zero]; rfl\n\n"}
{"name":"Turing.PartrecToTM2.trNat_default","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (Turing.PartrecToTM2.trNat Inhabited.default) List.nil","decl":"theorem trNat_default : trNat default = [] :=\n  trNat_zero\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_main","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Turing.PartrecToTM2.K'.elim a b c d Turing.PartrecToTM2.K'.main) a","decl":"theorem K'.elim_main (a b c d) : K'.elim a b c d K'.main = a := rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_rev","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Turing.PartrecToTM2.K'.elim a b c d Turing.PartrecToTM2.K'.rev) b","decl":"theorem K'.elim_rev (a b c d) : K'.elim a b c d K'.rev = b := rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_aux","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Turing.PartrecToTM2.K'.elim a b c d Turing.PartrecToTM2.K'.aux) c","decl":"theorem K'.elim_aux (a b c d) : K'.elim a b c d K'.aux = c := rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_stack","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Turing.PartrecToTM2.K'.elim a b c d Turing.PartrecToTM2.K'.stack) d","decl":"theorem K'.elim_stack (a b c d) : K'.elim a b c d K'.stack = d := rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_update_main","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d a' : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Function.update (Turing.PartrecToTM2.K'.elim a b c d) Turing.PartrecToTM2.K'.main a') (Turing.PartrecToTM2.K'.elim a' b c d)","decl":"@[simp]\ntheorem K'.elim_update_main {a b c d a'} : update (K'.elim a b c d) main a' = K'.elim a' b c d := by\n  funext x; cases x <;> rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_update_rev","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d b' : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Function.update (Turing.PartrecToTM2.K'.elim a b c d) Turing.PartrecToTM2.K'.rev b') (Turing.PartrecToTM2.K'.elim a b' c d)","decl":"@[simp]\ntheorem K'.elim_update_rev {a b c d b'} : update (K'.elim a b c d) rev b' = K'.elim a b' c d := by\n  funext x; cases x <;> rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_update_aux","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d c' : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Function.update (Turing.PartrecToTM2.K'.elim a b c d) Turing.PartrecToTM2.K'.aux c') (Turing.PartrecToTM2.K'.elim a b c' d)","decl":"@[simp]\ntheorem K'.elim_update_aux {a b c d c'} : update (K'.elim a b c d) aux c' = K'.elim a b c' d := by\n  funext x; cases x <;> rfl\n\n"}
{"name":"Turing.PartrecToTM2.K'.elim_update_stack","module":"Mathlib.Computability.TMToPartrec","initialProofState":"a b c d d' : List Turing.PartrecToTM2.Γ'\n⊢ Eq (Function.update (Turing.PartrecToTM2.K'.elim a b c d) Turing.PartrecToTM2.K'.stack d') (Turing.PartrecToTM2.K'.elim a b c d')","decl":"@[simp]\ntheorem K'.elim_update_stack {a b c d d'} :\n    update (K'.elim a b c d) stack d' = K'.elim a b c d' := by funext x; cases x <;> rfl\n\n"}
{"name":"Turing.PartrecToTM2.splitAtPred_eq","module":"Mathlib.Computability.TMToPartrec","initialProofState":"α : Type u_1\np : α → Bool\nL l₁ : List α\no : Option α\nl₂ : List α\na✝¹ : ∀ (x : α), Membership.mem l₁ x → Eq (p x) Bool.false\na✝ : Option.elim' (And (Eq L l₁) (Eq l₂ List.nil)) (fun a => And (Eq (p a) Bool.true) (Eq L (HAppend.hAppend l₁ (List.cons a l₂)))) o\n⊢ Eq (Turing.PartrecToTM2.splitAtPred p L) { fst := l₁, snd := { fst := o, snd := l₂ } }","decl":"theorem splitAtPred_eq {α} (p : α → Bool) :\n    ∀ L l₁ o l₂,\n      (∀ x ∈ l₁, p x = false) →\n        Option.elim' (L = l₁ ∧ l₂ = []) (fun a => p a = true ∧ L = l₁ ++ a::l₂) o →\n          splitAtPred p L = (l₁, o, l₂)\n  | [], _, none, _, _, ⟨rfl, rfl⟩ => rfl\n  | [], l₁, some o, l₂, _, ⟨_, h₃⟩ => by simp at h₃\n  | a :: L, l₁, o, l₂, h₁, h₂ => by\n    rw [splitAtPred]\n    have IH := splitAtPred_eq p L\n    cases' o with o\n    · cases' l₁ with a' l₁ <;> rcases h₂ with ⟨⟨⟩, rfl⟩\n      rw [h₁ a (List.Mem.head _), cond, IH L none [] _ ⟨rfl, rfl⟩]\n      exact fun x h => h₁ x (List.Mem.tail _ h)\n    · cases' l₁ with a' l₁ <;> rcases h₂ with ⟨h₂, ⟨⟩⟩\n      · rw [h₂, cond]\n      rw [h₁ a (List.Mem.head _), cond, IH l₁ (some o) l₂ _ ⟨h₂, _⟩] <;> try rfl\n      exact fun x h => h₁ x (List.Mem.tail _ h)\n\n"}
{"name":"Turing.PartrecToTM2.splitAtPred_false","module":"Mathlib.Computability.TMToPartrec","initialProofState":"α : Type u_1\nL : List α\n⊢ Eq (Turing.PartrecToTM2.splitAtPred (fun x => Bool.false) L) { fst := L, snd := { fst := Option.none, snd := List.nil } }","decl":"theorem splitAtPred_false {α} (L : List α) : splitAtPred (fun _ => false) L = (L, none, []) :=\n  splitAtPred_eq _ _ _ _ _ (fun _ _ => rfl) ⟨rfl, rfl⟩\n\n"}
{"name":"Turing.PartrecToTM2.move_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk₁ k₂ : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nL₁ : List Turing.PartrecToTM2.Γ'\no : Option Turing.PartrecToTM2.Γ'\nL₂ : List Turing.PartrecToTM2.Γ'\nS : Turing.PartrecToTM2.K' → List Turing.PartrecToTM2.Γ'\nh₁ : Ne k₁ k₂\ne : Eq (Turing.PartrecToTM2.splitAtPred p (S k₁)) { fst := L₁, snd := { fst := o, snd := L₂ } }\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.Λ'.move p k₁ k₂ q), var := s, stk := S } { l := Option.some q, var := o, stk := Function.update (Function.update S k₁ L₂) k₂ (L₁.reverseAux (S k₂)) }","decl":"theorem move_ok {p k₁ k₂ q s L₁ o L₂} {S : K' → List Γ'} (h₁ : k₁ ≠ k₂)\n    (e : splitAtPred p (S k₁) = (L₁, o, L₂)) :\n    Reaches₁ (TM2.step tr) ⟨some (Λ'.move p k₁ k₂ q), s, S⟩\n      ⟨some q, o, update (update S k₁ L₂) k₂ (L₁.reverseAux (S k₂))⟩ := by\n  induction' L₁ with a L₁ IH generalizing S s\n  · rw [(_ : [].reverseAux _ = _), Function.update_eq_self]\n    swap\n    · rw [Function.update_of_ne h₁.symm, List.reverseAux_nil]\n    refine TransGen.head' rfl ?_\n    rw [tr]; simp only [pop', TM2.stepAux]\n    revert e; cases' S k₁ with a Sk <;> intro e\n    · cases e\n      rfl\n    simp only [splitAtPred, Option.elim, List.head?, List.tail_cons, Option.iget_some] at e ⊢\n    revert e; cases p a <;> intro e <;>\n      simp only [cond_false, cond_true, Prod.mk.injEq, true_and, false_and, reduceCtorEq] at e ⊢\n    simp only [e]\n    rfl\n  · refine TransGen.head rfl ?_\n    rw [tr]; simp only [pop', Option.elim, TM2.stepAux, push']\n    cases' e₁ : S k₁ with a' Sk <;> rw [e₁, splitAtPred] at e\n    · cases e\n    cases e₂ : p a' <;> simp only [e₂, cond] at e\n    swap\n    · cases e\n    rcases e₃ : splitAtPred p Sk with ⟨_, _, _⟩\n    rw [e₃] at e\n    cases e\n    simp only [List.head?_cons, e₂, List.tail_cons, ne_eq, cond_false]\n    convert @IH _ (update (update S k₁ Sk) k₂ (a :: S k₂)) _ using 2 <;>\n      simp [Function.update_of_ne, h₁, h₁.symm, e₃, List.reverseAux]\n    simp [Function.update_comm h₁.symm]\n\n"}
{"name":"Turing.PartrecToTM2.unrev_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nS : Turing.PartrecToTM2.K' → List Turing.PartrecToTM2.Γ'\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.unrev q), var := s, stk := S } { l := Option.some q, var := Option.none, stk := Function.update (Function.update S Turing.PartrecToTM2.K'.rev List.nil) Turing.PartrecToTM2.K'.main ((S Turing.PartrecToTM2.K'.rev).reverseAux (S Turing.PartrecToTM2.K'.main)) }","decl":"theorem unrev_ok {q s} {S : K' → List Γ'} :\n    Reaches₁ (TM2.step tr) ⟨some (unrev q), s, S⟩\n      ⟨some q, none, update (update S rev []) main (List.reverseAux (S rev) (S main))⟩ :=\n  move_ok (by decide) <| splitAtPred_false _\n\n"}
{"name":"Turing.PartrecToTM2.move₂_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk₁ k₂ : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nL₁ : List Turing.PartrecToTM2.Γ'\no : Option Turing.PartrecToTM2.Γ'\nL₂ : List Turing.PartrecToTM2.Γ'\nS : Turing.PartrecToTM2.K' → List Turing.PartrecToTM2.Γ'\nh₁ : And (Ne k₁ Turing.PartrecToTM2.K'.rev) (And (Ne k₂ Turing.PartrecToTM2.K'.rev) (Ne k₁ k₂))\nh₂ : Eq (S Turing.PartrecToTM2.K'.rev) List.nil\ne : Eq (Turing.PartrecToTM2.splitAtPred p (S k₁)) { fst := L₁, snd := { fst := o, snd := L₂ } }\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.move₂ p k₁ k₂ q), var := s, stk := S } { l := Option.some q, var := Option.none, stk := Function.update (Function.update S k₁ (o.elim id List.cons L₂)) k₂ (HAppend.hAppend L₁ (S k₂)) }","decl":"theorem move₂_ok {p k₁ k₂ q s L₁ o L₂} {S : K' → List Γ'} (h₁ : k₁ ≠ rev ∧ k₂ ≠ rev ∧ k₁ ≠ k₂)\n    (h₂ : S rev = []) (e : splitAtPred p (S k₁) = (L₁, o, L₂)) :\n    Reaches₁ (TM2.step tr) ⟨some (move₂ p k₁ k₂ q), s, S⟩\n      ⟨some q, none, update (update S k₁ (o.elim id List.cons L₂)) k₂ (L₁ ++ S k₂)⟩ := by\n  refine (move_ok h₁.1 e).trans (TransGen.head rfl ?_)\n  simp only [TM2.step, Option.mem_def, TM2.stepAux, id_eq, ne_eq, Option.elim]\n  cases o <;> simp only [Option.elim] <;> rw [tr]\n    <;> simp only [id, TM2.stepAux, Option.isSome, cond_true, cond_false]\n  · convert move_ok h₁.2.1.symm (splitAtPred_false _) using 2\n    simp only [Function.update_comm h₁.1, Function.update_idem]\n    rw [show update S rev [] = S by rw [← h₂, Function.update_eq_self]]\n    simp only [Function.update_of_ne h₁.2.2.symm, Function.update_of_ne h₁.2.1,\n      Function.update_of_ne h₁.1.symm, List.reverseAux_eq, h₂, Function.update_self,\n      List.append_nil, List.reverse_reverse]\n  · convert move_ok h₁.2.1.symm (splitAtPred_false _) using 2\n    simp only [h₂, Function.update_comm h₁.1, List.reverseAux_eq, Function.update_self,\n      List.append_nil, Function.update_idem]\n    rw [show update S rev [] = S by rw [← h₂, Function.update_eq_self]]\n    simp only [Function.update_of_ne h₁.1.symm, Function.update_of_ne h₁.2.2.symm,\n      Function.update_of_ne h₁.2.1, Function.update_self, List.reverse_reverse]\n\n"}
{"name":"Turing.PartrecToTM2.clear_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"p : Turing.PartrecToTM2.Γ' → Bool\nk : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nL₁ : List Turing.PartrecToTM2.Γ'\no : Option Turing.PartrecToTM2.Γ'\nL₂ : List Turing.PartrecToTM2.Γ'\nS : Turing.PartrecToTM2.K' → List Turing.PartrecToTM2.Γ'\ne : Eq (Turing.PartrecToTM2.splitAtPred p (S k)) { fst := L₁, snd := { fst := o, snd := L₂ } }\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.Λ'.clear p k q), var := s, stk := S } { l := Option.some q, var := o, stk := Function.update S k L₂ }","decl":"theorem clear_ok {p k q s L₁ o L₂} {S : K' → List Γ'} (e : splitAtPred p (S k) = (L₁, o, L₂)) :\n    Reaches₁ (TM2.step tr) ⟨some (Λ'.clear p k q), s, S⟩ ⟨some q, o, update S k L₂⟩ := by\n  induction' L₁ with a L₁ IH generalizing S s\n  · refine TransGen.head' rfl ?_\n    rw [tr]; simp only [pop', TM2.step, Option.mem_def, TM2.stepAux, Option.elim]\n    revert e; cases' S k with a Sk <;> intro e\n    · cases e\n      rfl\n    simp only [splitAtPred, Option.elim, List.head?, List.tail_cons] at e ⊢\n    revert e; cases p a <;> intro e <;>\n      simp only [cond_false, cond_true, Prod.mk.injEq, true_and, false_and, reduceCtorEq] at e ⊢\n    rcases e with ⟨e₁, e₂⟩\n    rw [e₁, e₂]\n  · refine TransGen.head rfl ?_\n    rw [tr]; simp only [pop', TM2.step, Option.mem_def, TM2.stepAux, Option.elim]\n    cases' e₁ : S k with a' Sk <;> rw [e₁, splitAtPred] at e\n    · cases e\n    cases e₂ : p a' <;> simp only [e₂, cond] at e\n    swap\n    · cases e\n    rcases e₃ : splitAtPred p Sk with ⟨_, _, _⟩\n    rw [e₃] at e\n    cases e\n    simp only [List.head?_cons, e₂, List.tail_cons, cond_false]\n    convert @IH _ (update S k Sk) _ using 2 <;> simp [e₃]\n\n"}
{"name":"Turing.PartrecToTM2.copy_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\na b c d : List Turing.PartrecToTM2.Γ'\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some q.copy, var := s, stk := Turing.PartrecToTM2.K'.elim a b c d } { l := Option.some q, var := Option.none, stk := Turing.PartrecToTM2.K'.elim (b.reverseAux a) List.nil c (b.reverseAux d) }","decl":"theorem copy_ok (q s a b c d) :\n    Reaches₁ (TM2.step tr) ⟨some (Λ'.copy q), s, K'.elim a b c d⟩\n      ⟨some q, none, K'.elim (List.reverseAux b a) [] c (List.reverseAux b d)⟩ := by\n  induction' b with x b IH generalizing a d s\n  · refine TransGen.single ?_\n    simp\n  refine TransGen.head rfl ?_\n  rw [tr]\n  simp only [TM2.step, Option.mem_def, TM2.stepAux, elim_rev, List.head?_cons, Option.isSome_some,\n    List.tail_cons, elim_update_rev, ne_eq, Function.update_of_ne, elim_main, elim_update_main,\n    elim_stack, elim_update_stack, cond_true, List.reverseAux_cons, pop', push']\n  exact IH _ _ _\n\n"}
{"name":"Turing.PartrecToTM2.trPosNum_natEnd","module":"Mathlib.Computability.TMToPartrec","initialProofState":"n : PosNum\nx : Turing.PartrecToTM2.Γ'\na✝ : Membership.mem (Turing.PartrecToTM2.trPosNum n) x\n⊢ Eq (Turing.PartrecToTM2.natEnd x) Bool.false","decl":"theorem trPosNum_natEnd : ∀ (n), ∀ x ∈ trPosNum n, natEnd x = false\n  | PosNum.one, _, List.Mem.head _ => rfl\n  | PosNum.bit0 _, _, List.Mem.head _ => rfl\n  | PosNum.bit0 n, _, List.Mem.tail _ h => trPosNum_natEnd n _ h\n  | PosNum.bit1 _, _, List.Mem.head _ => rfl\n  | PosNum.bit1 n, _, List.Mem.tail _ h => trPosNum_natEnd n _ h\n\n"}
{"name":"Turing.PartrecToTM2.trNum_natEnd","module":"Mathlib.Computability.TMToPartrec","initialProofState":"n : Num\nx : Turing.PartrecToTM2.Γ'\na✝ : Membership.mem (Turing.PartrecToTM2.trNum n) x\n⊢ Eq (Turing.PartrecToTM2.natEnd x) Bool.false","decl":"theorem trNum_natEnd : ∀ (n), ∀ x ∈ trNum n, natEnd x = false\n  | Num.pos n, x, h => trPosNum_natEnd n x h\n\n"}
{"name":"Turing.PartrecToTM2.trNat_natEnd","module":"Mathlib.Computability.TMToPartrec","initialProofState":"n : Nat\nx : Turing.PartrecToTM2.Γ'\na✝ : Membership.mem (Turing.PartrecToTM2.trNat n) x\n⊢ Eq (Turing.PartrecToTM2.natEnd x) Bool.false","decl":"theorem trNat_natEnd (n) : ∀ x ∈ trNat n, natEnd x = false :=\n  trNum_natEnd _\n\n"}
{"name":"Turing.PartrecToTM2.trList_ne_consₗ","module":"Mathlib.Computability.TMToPartrec","initialProofState":"l : List Nat\nx : Turing.PartrecToTM2.Γ'\na✝ : Membership.mem (Turing.PartrecToTM2.trList l) x\n⊢ Ne x Turing.PartrecToTM2.Γ'.consₗ","decl":"theorem trList_ne_consₗ : ∀ (l), ∀ x ∈ trList l, x ≠ Γ'.consₗ\n  | a :: l, x, h => by\n    simp only [trList, List.mem_append, List.mem_cons] at h\n    obtain h | rfl | h := h\n    · rintro rfl\n      cases trNat_natEnd _ _ h\n    · rintro ⟨⟩\n    · exact trList_ne_consₗ l _ h\n\n"}
{"name":"Turing.PartrecToTM2.head_main_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nL : List Nat\nc d : List Turing.PartrecToTM2.Γ'\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.head Turing.PartrecToTM2.K'.main q), var := s, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList L) List.nil c d } { l := Option.some q, var := Option.none, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList (List.cons L.headI List.nil)) List.nil c d }","decl":"theorem head_main_ok {q s L} {c d : List Γ'} :\n    Reaches₁ (TM2.step tr) ⟨some (head main q), s, K'.elim (trList L) [] c d⟩\n      ⟨some q, none, K'.elim (trList [L.headI]) [] c d⟩ := by\n  let o : Option Γ' := List.casesOn L none fun _ _ => some Γ'.cons\n  refine\n    (move_ok (by decide)\n          (splitAtPred_eq _ _ (trNat L.headI) o (trList L.tail) (trNat_natEnd _) ?_)).trans\n      (TransGen.head rfl (TransGen.head rfl ?_))\n  · cases L <;> simp [o]\n  rw [tr]\n  simp only [TM2.step, Option.mem_def, TM2.stepAux, elim_update_main, elim_rev, elim_update_rev,\n    Function.update_self, trList]\n  rw [if_neg (show o ≠ some Γ'.consₗ by cases L <;> simp [o])]\n  refine (clear_ok (splitAtPred_eq _ _ _ none [] ?_ ⟨rfl, rfl⟩)).trans ?_\n  · exact fun x h => Bool.decide_false (trList_ne_consₗ _ _ h)\n  convert unrev_ok using 2; simp [List.reverseAux_eq]\n\n"}
{"name":"Turing.PartrecToTM2.head_stack_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nL₁ L₂ : List Nat\nL₃ : List Turing.PartrecToTM2.Γ'\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.head Turing.PartrecToTM2.K'.stack q), var := s, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList L₁) List.nil List.nil (HAppend.hAppend (Turing.PartrecToTM2.trList L₂) (List.cons Turing.PartrecToTM2.Γ'.consₗ L₃)) } { l := Option.some q, var := Option.none, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList (List.cons L₂.headI L₁)) List.nil List.nil L₃ }","decl":"theorem head_stack_ok {q s L₁ L₂ L₃} :\n    Reaches₁ (TM2.step tr)\n      ⟨some (head stack q), s, K'.elim (trList L₁) [] [] (trList L₂ ++ Γ'.consₗ :: L₃)⟩\n      ⟨some q, none, K'.elim (trList (L₂.headI :: L₁)) [] [] L₃⟩ := by\n  cases' L₂ with a L₂\n  · refine\n      TransGen.trans\n        (move_ok (by decide)\n          (splitAtPred_eq _ _ [] (some Γ'.consₗ) L₃ (by rintro _ ⟨⟩) ⟨rfl, rfl⟩))\n        (TransGen.head rfl (TransGen.head rfl ?_))\n    rw [tr]\n    simp only [TM2.step, Option.mem_def, TM2.stepAux, ite_true, id_eq, trList, List.nil_append,\n      elim_update_stack, elim_rev, List.reverseAux_nil, elim_update_rev, Function.update_self,\n      List.headI_nil, trNat_default]\n    convert unrev_ok using 2\n    simp\n  · refine\n      TransGen.trans\n        (move_ok (by decide)\n          (splitAtPred_eq _ _ (trNat a) (some Γ'.cons) (trList L₂ ++ Γ'.consₗ :: L₃)\n            (trNat_natEnd _) ⟨rfl, by simp⟩))\n        (TransGen.head rfl (TransGen.head rfl ?_))\n    simp only [TM2.step, Option.mem_def, TM2.stepAux, ite_false, trList, List.append_assoc,\n      List.cons_append, elim_update_stack, elim_rev, elim_update_rev, Function.update_self,\n      List.headI_cons]\n    refine\n      TransGen.trans\n        (clear_ok\n          (splitAtPred_eq _ _ (trList L₂) (some Γ'.consₗ) L₃\n            (fun x h => Bool.decide_false (trList_ne_consₗ _ _ h)) ⟨rfl, by simp⟩))\n        ?_\n    convert unrev_ok using 2\n    simp [List.reverseAux_eq]\n\n"}
{"name":"Turing.PartrecToTM2.succ_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nn : Nat\nc d : List Turing.PartrecToTM2.Γ'\n⊢ Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some q.succ, var := s, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList (List.cons n List.nil)) List.nil c d } { l := Option.some q, var := Option.none, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList (List.cons n.succ List.nil)) List.nil c d }","decl":"theorem succ_ok {q s n} {c d : List Γ'} :\n    Reaches₁ (TM2.step tr) ⟨some (Λ'.succ q), s, K'.elim (trList [n]) [] c d⟩\n      ⟨some q, none, K'.elim (trList [n.succ]) [] c d⟩ := by\n  simp only [TM2.step, trList, trNat.eq_1, Nat.cast_succ, Num.add_one]\n  cases' (n : Num) with a\n  · refine TransGen.head rfl ?_\n    simp only [Option.mem_def, TM2.stepAux, elim_main, decide_false, elim_update_main, ne_eq,\n      Function.update_of_ne, elim_rev, elim_update_rev, decide_true, Function.update_self,\n      cond_true, cond_false]\n    convert unrev_ok using 1\n    simp only [elim_update_rev, elim_rev, elim_main, List.reverseAux_nil, elim_update_main]\n    rfl\n  simp only [trNum, Num.succ, Num.succ']\n  suffices ∀ l₁, ∃ l₁' l₂' s',\n      List.reverseAux l₁ (trPosNum a.succ) = List.reverseAux l₁' l₂' ∧\n        Reaches₁ (TM2.step tr) ⟨some q.succ, s, K'.elim (trPosNum a ++ [Γ'.cons]) l₁ c d⟩\n          ⟨some (unrev q), s', K'.elim (l₂' ++ [Γ'.cons]) l₁' c d⟩ by\n    obtain ⟨l₁', l₂', s', e, h⟩ := this []\n    simp? [List.reverseAux] at e says simp only [List.reverseAux, List.reverseAux_eq] at e\n    refine h.trans ?_\n    convert unrev_ok using 2\n    simp [e, List.reverseAux_eq]\n  induction' a with m IH m _ generalizing s <;> intro l₁\n  · refine ⟨Γ'.bit0 :: l₁, [Γ'.bit1], some Γ'.cons, rfl, TransGen.head rfl (TransGen.single ?_)⟩\n    simp [trPosNum]\n  · obtain ⟨l₁', l₂', s', e, h⟩ := IH (Γ'.bit0 :: l₁)\n    refine ⟨l₁', l₂', s', e, TransGen.head ?_ h⟩\n    simp [PosNum.succ, trPosNum]\n    rfl\n  · refine ⟨l₁, _, some Γ'.bit0, rfl, TransGen.single ?_⟩\n    simp only [TM2.step]; rw [tr]\n    simp only [TM2.stepAux, pop', elim_main, elim_update_main, ne_eq, Function.update_of_ne,\n      elim_rev, elim_update_rev, Function.update_self, Option.mem_def, Option.some.injEq]\n    rfl\n\n"}
{"name":"Turing.PartrecToTM2.pred_ok","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q₁ q₂ : Turing.PartrecToTM2.Λ'\ns : Option Turing.PartrecToTM2.Γ'\nv : List Nat\nc d : List Turing.PartrecToTM2.Γ'\n⊢ Exists fun s' => Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (q₁.pred q₂), var := s, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList v) List.nil c d } (Nat.rec { l := Option.some q₁, var := s', stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList v.tail) List.nil c d } (fun n x => { l := Option.some q₂, var := s', stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList (List.cons n v.tail)) List.nil c d }) v.headI)","decl":"theorem pred_ok (q₁ q₂ s v) (c d : List Γ') : ∃ s',\n    Reaches₁ (TM2.step tr) ⟨some (Λ'.pred q₁ q₂), s, K'.elim (trList v) [] c d⟩\n      (v.headI.rec ⟨some q₁, s', K'.elim (trList v.tail) [] c d⟩ fun n _ =>\n        ⟨some q₂, s', K'.elim (trList (n::v.tail)) [] c d⟩) := by\n  rcases v with (_ | ⟨_ | n, v⟩)\n  · refine ⟨none, TransGen.single ?_⟩\n    simp\n  · refine ⟨some Γ'.cons, TransGen.single ?_⟩\n    simp\n  refine ⟨none, ?_⟩\n  simp only [TM2.step, trList, trNat.eq_1, trNum, Nat.cast_succ, Num.add_one, Num.succ,\n    List.tail_cons, List.headI_cons]\n  cases' (n : Num) with a\n  · simp only [trPosNum, Num.succ', List.singleton_append, List.nil_append]\n    refine TransGen.head rfl ?_\n    rw [tr]; simp only [pop', TM2.stepAux, cond_false]\n    convert unrev_ok using 2\n    simp\n  simp only [Num.succ']\n  suffices ∀ l₁, ∃ l₁' l₂' s',\n    List.reverseAux l₁ (trPosNum a) = List.reverseAux l₁' l₂' ∧\n      Reaches₁ (TM2.step tr)\n        ⟨some (q₁.pred q₂), s, K'.elim (trPosNum a.succ ++ Γ'.cons :: trList v) l₁ c d⟩\n        ⟨some (unrev q₂), s', K'.elim (l₂' ++ Γ'.cons :: trList v) l₁' c d⟩ by\n    obtain ⟨l₁', l₂', s', e, h⟩ := this []\n    simp only [List.reverseAux] at e\n    refine h.trans ?_\n    convert unrev_ok using 2\n    simp [e, List.reverseAux_eq]\n  induction' a with m IH m IH generalizing s <;> intro l₁\n  · refine ⟨Γ'.bit1::l₁, [], some Γ'.cons, rfl, TransGen.head rfl (TransGen.single ?_)⟩\n    simp [trPosNum, show PosNum.one.succ = PosNum.one.bit0 from rfl]\n  · obtain ⟨l₁', l₂', s', e, h⟩ := IH (some Γ'.bit0) (Γ'.bit1 :: l₁)\n    refine ⟨l₁', l₂', s', e, TransGen.head ?_ h⟩\n    simp\n    rfl\n  · obtain ⟨a, l, e, h⟩ : ∃ a l, (trPosNum m = a::l) ∧ natEnd a = false := by\n      cases m <;> refine ⟨_, _, rfl, rfl⟩\n    refine ⟨Γ'.bit0 :: l₁, _, some a, rfl, TransGen.single ?_⟩\n    simp [trPosNum, PosNum.succ, e, h, show some Γ'.bit1 ≠ some Γ'.bit0 by decide,\n      Option.iget, -natEnd]\n    rfl\n\n"}
{"name":"Turing.PartrecToTM2.trNormal_respects","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nk : Turing.ToPartrec.Cont\nv : List Nat\ns : Option Turing.PartrecToTM2.Γ'\n⊢ Exists fun b₂ => And (Turing.PartrecToTM2.TrCfg (Turing.ToPartrec.stepNormal c k v) b₂) (Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.trNormal c (Turing.PartrecToTM2.trCont k)), var := s, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList v) List.nil List.nil (Turing.PartrecToTM2.trContStack k) } b₂)","decl":"theorem trNormal_respects (c k v s) :\n    ∃ b₂,\n      TrCfg (stepNormal c k v) b₂ ∧\n        Reaches₁ (TM2.step tr)\n          ⟨some (trNormal c (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)⟩ b₂ := by\n  induction c generalizing k v s with\n  | zero' => refine ⟨_, ⟨s, rfl⟩, TransGen.single ?_⟩; simp\n  | succ => refine ⟨_, ⟨none, rfl⟩, head_main_ok.trans succ_ok⟩\n  | tail =>\n    let o : Option Γ' := List.casesOn v none fun _ _ => some Γ'.cons\n    refine ⟨_, ⟨o, rfl⟩, ?_⟩; convert clear_ok _ using 2\n    · simp; rfl\n    swap\n    refine splitAtPred_eq _ _ (trNat v.headI) _ _ (trNat_natEnd _) ?_\n    cases v <;> simp [o]\n  | cons f fs IHf _ =>\n    obtain ⟨c, h₁, h₂⟩ := IHf (Cont.cons₁ fs v k) v none\n    refine ⟨c, h₁, TransGen.head rfl <| (move_ok (by decide) (splitAtPred_false _)).trans ?_⟩\n    simp only [TM2.step, Option.mem_def, elim_stack, elim_update_stack, elim_update_main, ne_eq,\n      Function.update_of_ne, elim_main, elim_rev, elim_update_rev]\n    refine (copy_ok _ none [] (trList v).reverse _ _).trans ?_\n    convert h₂ using 2\n    simp [List.reverseAux_eq, trContStack]\n  | comp f _ _ IHg => exact IHg (Cont.comp f k) v s\n  | case f g IHf IHg =>\n    rw [stepNormal]\n    simp only\n    obtain ⟨s', h⟩ := pred_ok _ _ s v _ _\n    revert h; cases' v.headI with n <;> intro h\n    · obtain ⟨c, h₁, h₂⟩ := IHf k _ s'\n      exact ⟨_, h₁, h.trans h₂⟩\n    · obtain ⟨c, h₁, h₂⟩ := IHg k _ s'\n      exact ⟨_, h₁, h.trans h₂⟩\n  | fix f IH => apply IH\n\n"}
{"name":"Turing.PartrecToTM2.tr_ret_respects","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.ToPartrec.Cont\nv : List Nat\ns : Option Turing.PartrecToTM2.Γ'\n⊢ Exists fun b₂ => And (Turing.PartrecToTM2.TrCfg (Turing.ToPartrec.stepRet k v) b₂) (Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) { l := Option.some (Turing.PartrecToTM2.Λ'.ret (Turing.PartrecToTM2.trCont k)), var := s, stk := Turing.PartrecToTM2.K'.elim (Turing.PartrecToTM2.trList v) List.nil List.nil (Turing.PartrecToTM2.trContStack k) } b₂)","decl":"theorem tr_ret_respects (k v s) : ∃ b₂,\n    TrCfg (stepRet k v) b₂ ∧\n      Reaches₁ (TM2.step tr)\n        ⟨some (Λ'.ret (trCont k)), s, K'.elim (trList v) [] [] (trContStack k)⟩ b₂ := by\n  induction k generalizing v s with\n  | halt => exact ⟨_, rfl, TransGen.single rfl⟩\n  | cons₁ fs as k _ =>\n    obtain ⟨s', h₁, h₂⟩ := trNormal_respects fs (Cont.cons₂ v k) as none\n    refine ⟨s', h₁, TransGen.head rfl ?_⟩; simp\n    refine (move₂_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; · rfl\n    simp only [TM2.step, Option.mem_def, Option.elim, id_eq, elim_update_main, elim_main, elim_aux,\n      List.append_nil, elim_update_aux]\n    refine (move₂_ok (L₁ := ?_) (o := ?_) (L₂ := ?_) (by decide) rfl ?_).trans ?_\n    pick_goal 4\n    · exact splitAtPred_eq _ _ _ (some Γ'.consₗ) _\n        (fun x h => Bool.decide_false (trList_ne_consₗ _ _ h)) ⟨rfl, rfl⟩\n    refine (move₂_ok (by decide) ?_ (splitAtPred_false _)).trans ?_; · rfl\n    simp only [TM2.step, Option.mem_def, Option.elim, elim_update_stack, elim_main,\n      List.append_nil, elim_update_main,  id_eq, elim_update_aux, ne_eq, Function.update_of_ne,\n      elim_aux, elim_stack]\n    exact h₂\n  | cons₂ ns k IH =>\n    obtain ⟨c, h₁, h₂⟩ := IH (ns.headI :: v) none\n    exact ⟨c, h₁, TransGen.head rfl <| head_stack_ok.trans h₂⟩\n  | comp f k _ =>\n    obtain ⟨s', h₁, h₂⟩ := trNormal_respects f k v s\n    exact ⟨_, h₁, TransGen.head rfl h₂⟩\n  | fix f k IH =>\n    rw [stepRet]\n    have :\n      if v.headI = 0 then natEnd (trList v).head?.iget = true ∧ (trList v).tail = trList v.tail\n      else\n        natEnd (trList v).head?.iget = false ∧\n          (trList v).tail = (trNat v.headI).tail ++ Γ'.cons :: trList v.tail := by\n      cases' v with n\n      · exact ⟨rfl, rfl⟩\n      cases' n with n\n      · simp\n      rw [trList, List.headI, trNat, Nat.cast_succ, Num.add_one, Num.succ, List.tail]\n      cases (n : Num).succ' <;> exact ⟨rfl, rfl⟩\n    by_cases h : v.headI = 0 <;> simp only [h, ite_true, ite_false] at this ⊢\n    · obtain ⟨c, h₁, h₂⟩ := IH v.tail (trList v).head?\n      refine ⟨c, h₁, TransGen.head rfl ?_⟩\n      rw [trCont, tr]; simp only [pop', TM2.stepAux, elim_main, this, elim_update_main]\n      exact h₂\n    · obtain ⟨s', h₁, h₂⟩ := trNormal_respects f (Cont.fix f k) v.tail (some Γ'.cons)\n      refine ⟨_, h₁, TransGen.head rfl <| TransGen.trans ?_ h₂⟩\n      rw [trCont, tr]; simp only [pop', TM2.stepAux, elim_main, this.1]\n      convert clear_ok (splitAtPred_eq _ _ (trNat v.headI).tail (some Γ'.cons) _ _ _) using 2\n      · simp\n        convert rfl\n      · exact fun x h => trNat_natEnd _ _ (List.tail_subset _ h)\n      · exact ⟨rfl, this.2⟩\n\n"}
{"name":"Turing.PartrecToTM2.tr_respects","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Turing.Respects Turing.ToPartrec.step (Turing.TM2.step Turing.PartrecToTM2.tr) Turing.PartrecToTM2.TrCfg","decl":"theorem tr_respects : Respects step (TM2.step tr) TrCfg\n  | Cfg.ret _ _, _, ⟨_, rfl⟩ => tr_ret_respects _ _ _\n  | Cfg.halt _, _, rfl => rfl\n\n"}
{"name":"Turing.PartrecToTM2.tr_init","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nv : List Nat\n⊢ Exists fun b => And (Turing.PartrecToTM2.TrCfg (Turing.ToPartrec.stepNormal c Turing.ToPartrec.Cont.halt v) b) (Turing.Reaches₁ (Turing.TM2.step Turing.PartrecToTM2.tr) (Turing.PartrecToTM2.init c v) b)","decl":"theorem tr_init (c v) :\n    ∃ b, TrCfg (stepNormal c Cont.halt v) b ∧ Reaches₁ (TM2.step tr) (init c v) b :=\n  trNormal_respects _ _ _ _\n\n"}
{"name":"Turing.PartrecToTM2.tr_eval","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nv : List Nat\n⊢ Eq (Turing.eval (Turing.TM2.step Turing.PartrecToTM2.tr) (Turing.PartrecToTM2.init c v)) (Functor.map Turing.PartrecToTM2.halt (c.eval v))","decl":"theorem tr_eval (c v) : eval (TM2.step tr) (init c v) = halt <$> Code.eval c v := by\n  obtain ⟨i, h₁, h₂⟩ := tr_init c v\n  refine Part.ext fun x => ?_\n  rw [reaches_eval h₂.to_reflTransGen]; simp only [Part.map_eq_map, Part.mem_map_iff]\n  refine ⟨fun h => ?_, ?_⟩\n  · obtain ⟨c, hc₁, hc₂⟩ := tr_eval_rev tr_respects h₁ h\n    simp [stepNormal_eval] at hc₂\n    obtain ⟨v', hv, rfl⟩ := hc₂\n    exact ⟨_, hv, hc₁.symm⟩\n  · rintro ⟨v', hv, rfl⟩\n    have := Turing.tr_eval (b₁ := Cfg.halt v') tr_respects h₁\n    simp only [stepNormal_eval, Part.map_eq_map, Part.mem_map_iff, Cfg.halt.injEq,\n      exists_eq_right] at this\n    obtain ⟨_, ⟨⟩, h⟩ := this hv\n    exact h\n\n"}
{"name":"Turing.PartrecToTM2.trStmts₁_trans","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q q' : Turing.PartrecToTM2.Λ'\na✝ : Membership.mem (Turing.PartrecToTM2.trStmts₁ q) q'\n⊢ HasSubset.Subset (Turing.PartrecToTM2.trStmts₁ q') (Turing.PartrecToTM2.trStmts₁ q)","decl":"theorem trStmts₁_trans {q q'} : q' ∈ trStmts₁ q → trStmts₁ q' ⊆ trStmts₁ q := by\n  induction q with\n  | move _ _ _ q q_ih => _ | clear _ _ q q_ih => _ | copy q q_ih => _ | push _ _ q q_ih => _\n  | read q q_ih => _ | succ q q_ih => _ | pred q₁ q₂ q₁_ih q₂_ih => _ | ret => _ <;>\n  all_goals\n    simp +contextual only [trStmts₁, Finset.mem_insert, Finset.mem_union,\n      or_imp, Finset.mem_singleton, Finset.Subset.refl, imp_true_iff, true_and]\n    repeat exact fun h => Finset.Subset.trans (q_ih h) (Finset.subset_insert _ _)\n  · simp\n    intro s h x h'\n    simp only [Finset.mem_biUnion, Finset.mem_univ, true_and, Finset.mem_insert]\n    exact Or.inr ⟨_, q_ih s h h'⟩\n  · constructor\n    · rintro rfl\n      apply Finset.subset_insert\n    · intro h x h'\n      simp only [Finset.mem_insert]\n      exact Or.inr (Or.inr <| q_ih h h')\n  · refine ⟨fun h x h' => ?_, fun _ x h' => ?_, fun h x h' => ?_⟩ <;> simp\n    · exact Or.inr (Or.inr <| Or.inl <| q₁_ih h h')\n    · cases' Finset.mem_insert.1 h' with h' h' <;> simp [h', unrev]\n    · exact Or.inr (Or.inr <| Or.inr <| q₂_ih h h')\n\n"}
{"name":"Turing.PartrecToTM2.trStmts₁_self","module":"Mathlib.Computability.TMToPartrec","initialProofState":"q : Turing.PartrecToTM2.Λ'\n⊢ Membership.mem (Turing.PartrecToTM2.trStmts₁ q) q","decl":"theorem trStmts₁_self (q) : q ∈ trStmts₁ q := by\n  induction q <;> · first |apply Finset.mem_singleton_self|apply Finset.mem_insert_self\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp'_self","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ HasSubset.Subset (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal c k)) (Turing.PartrecToTM2.codeSupp' c k)","decl":"@[simp]\ntheorem codeSupp'_self (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp' c k := by\n  cases c <;> first | rfl | exact Finset.union_subset_left (fun _ a ↦ a)\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_self","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ HasSubset.Subset (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal c k)) (Turing.PartrecToTM2.codeSupp c k)","decl":"@[simp]\ntheorem codeSupp_self (c k) : trStmts₁ (trNormal c k) ⊆ codeSupp c k :=\n  Finset.Subset.trans (codeSupp'_self _ _) (Finset.union_subset_left fun _ a ↦ a)\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_zero","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp Turing.ToPartrec.Code.zero' k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal Turing.ToPartrec.Code.zero' k)) (Turing.PartrecToTM2.contSupp k))","decl":"@[simp]\ntheorem codeSupp_zero (k) : codeSupp Code.zero' k = trStmts₁ (trNormal Code.zero' k) ∪ contSupp k :=\n  rfl\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_succ","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp Turing.ToPartrec.Code.succ k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal Turing.ToPartrec.Code.succ k)) (Turing.PartrecToTM2.contSupp k))","decl":"@[simp]\ntheorem codeSupp_succ (k) : codeSupp Code.succ k = trStmts₁ (trNormal Code.succ k) ∪ contSupp k :=\n  rfl\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_tail","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp Turing.ToPartrec.Code.tail k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal Turing.ToPartrec.Code.tail k)) (Turing.PartrecToTM2.contSupp k))","decl":"@[simp]\ntheorem codeSupp_tail (k) : codeSupp Code.tail k = trStmts₁ (trNormal Code.tail k) ∪ contSupp k :=\n  rfl\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_cons","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f fs : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp (f.cons fs) k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal (f.cons fs) k)) (Turing.PartrecToTM2.codeSupp f (Turing.PartrecToTM2.Cont'.cons₁ fs k)))","decl":"@[simp]\ntheorem codeSupp_cons (f fs k) :\n    codeSupp (Code.cons f fs) k =\n      trStmts₁ (trNormal (Code.cons f fs) k) ∪ codeSupp f (Cont'.cons₁ fs k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc]\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_comp","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f g : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp (f.comp g) k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal (f.comp g) k)) (Turing.PartrecToTM2.codeSupp g (Turing.PartrecToTM2.Cont'.comp f k)))","decl":"@[simp]\ntheorem codeSupp_comp (f g k) :\n    codeSupp (Code.comp f g) k =\n      trStmts₁ (trNormal (Code.comp f g) k) ∪ codeSupp g (Cont'.comp f k) := by\n  simp only [codeSupp, codeSupp', trNormal, Finset.union_assoc, contSupp]\n  rw [← Finset.union_assoc _ _ (contSupp k),\n    Finset.union_eq_right.2 (codeSupp'_self _ _)]\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_case","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f g : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp (f.case g) k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal (f.case g) k)) (Union.union (Turing.PartrecToTM2.codeSupp f k) (Turing.PartrecToTM2.codeSupp g k)))","decl":"@[simp]\ntheorem codeSupp_case (f g k) :\n    codeSupp (Code.case f g) k =\n      trStmts₁ (trNormal (Code.case f g) k) ∪ (codeSupp f k ∪ codeSupp g k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc, Finset.union_left_comm]\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_fix","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.codeSupp f.fix k) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.trNormal f.fix k)) (Turing.PartrecToTM2.codeSupp f (Turing.PartrecToTM2.Cont'.fix f k)))","decl":"@[simp]\ntheorem codeSupp_fix (f k) :\n    codeSupp (Code.fix f) k = trStmts₁ (trNormal (Code.fix f) k) ∪ codeSupp f (Cont'.fix f k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc, Finset.union_left_comm,\n    Finset.union_left_idem]\n\n"}
{"name":"Turing.PartrecToTM2.contSupp_cons₁","module":"Mathlib.Computability.TMToPartrec","initialProofState":"fs : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.contSupp (Turing.PartrecToTM2.Cont'.cons₁ fs k)) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.move₂ (fun x => Bool.false) Turing.PartrecToTM2.K'.main Turing.PartrecToTM2.K'.aux (Turing.PartrecToTM2.move₂ (fun s => Decidable.decide (Eq s Turing.PartrecToTM2.Γ'.consₗ)) Turing.PartrecToTM2.K'.stack Turing.PartrecToTM2.K'.main (Turing.PartrecToTM2.move₂ (fun x => Bool.false) Turing.PartrecToTM2.K'.aux Turing.PartrecToTM2.K'.stack (Turing.PartrecToTM2.trNormal fs k.cons₂))))) (Turing.PartrecToTM2.codeSupp fs k.cons₂))","decl":"@[simp]\ntheorem contSupp_cons₁ (fs k) :\n    contSupp (Cont'.cons₁ fs k) =\n      trStmts₁\n          (move₂ (fun _ => false) main aux <|\n            move₂ (fun s => s = Γ'.consₗ) stack main <|\n              move₂ (fun _ => false) aux stack <| trNormal fs (Cont'.cons₂ k)) ∪\n        codeSupp fs (Cont'.cons₂ k) := by\n  simp [codeSupp, codeSupp', contSupp, Finset.union_assoc]\n\n"}
{"name":"Turing.PartrecToTM2.contSupp_cons₂","module":"Mathlib.Computability.TMToPartrec","initialProofState":"k : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.contSupp k.cons₂) (Union.union (Turing.PartrecToTM2.trStmts₁ (Turing.PartrecToTM2.head Turing.PartrecToTM2.K'.stack (Turing.PartrecToTM2.Λ'.ret k))) (Turing.PartrecToTM2.contSupp k))","decl":"@[simp]\ntheorem contSupp_cons₂ (k) :\n    contSupp (Cont'.cons₂ k) = trStmts₁ (head stack <| Λ'.ret k) ∪ contSupp k :=\n  rfl\n\n"}
{"name":"Turing.PartrecToTM2.contSupp_comp","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.contSupp (Turing.PartrecToTM2.Cont'.comp f k)) (Turing.PartrecToTM2.codeSupp f k)","decl":"@[simp]\ntheorem contSupp_comp (f k) : contSupp (Cont'.comp f k) = codeSupp f k :=\n  rfl\n\n"}
{"name":"Turing.PartrecToTM2.contSupp_fix","module":"Mathlib.Computability.TMToPartrec","initialProofState":"f : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Eq (Turing.PartrecToTM2.contSupp (Turing.PartrecToTM2.Cont'.fix f k)) (Turing.PartrecToTM2.codeSupp f (Turing.PartrecToTM2.Cont'.fix f k))","decl":"theorem contSupp_fix (f k) : contSupp (Cont'.fix f k) = codeSupp f (Cont'.fix f k) := by\n  simp +contextual [codeSupp, codeSupp', contSupp, Finset.union_assoc,\n    Finset.subset_iff]\n\n"}
{"name":"Turing.PartrecToTM2.contSupp_halt","module":"Mathlib.Computability.TMToPartrec","initialProofState":"⊢ Eq (Turing.PartrecToTM2.contSupp Turing.PartrecToTM2.Cont'.halt) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem contSupp_halt : contSupp Cont'.halt = ∅ :=\n  rfl\n\n"}
{"name":"Turing.PartrecToTM2.supports_insert","module":"Mathlib.Computability.TMToPartrec","initialProofState":"K S : Finset Turing.PartrecToTM2.Λ'\nq : Turing.PartrecToTM2.Λ'\n⊢ Iff (Turing.PartrecToTM2.Supports (Insert.insert q K) S) (And (Turing.TM2.SupportsStmt S (Turing.PartrecToTM2.tr q)) (Turing.PartrecToTM2.Supports K S))","decl":"theorem supports_insert {K S q} :\n    Supports (insert q K) S ↔ TM2.SupportsStmt S (tr q) ∧ Supports K S := by simp [Supports]\n\n"}
{"name":"Turing.PartrecToTM2.supports_singleton","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nq : Turing.PartrecToTM2.Λ'\n⊢ Iff (Turing.PartrecToTM2.Supports (Singleton.singleton q) S) (Turing.TM2.SupportsStmt S (Turing.PartrecToTM2.tr q))","decl":"theorem supports_singleton {S q} : Supports {q} S ↔ TM2.SupportsStmt S (tr q) := by simp [Supports]\n\n"}
{"name":"Turing.PartrecToTM2.supports_union","module":"Mathlib.Computability.TMToPartrec","initialProofState":"K₁ K₂ S : Finset Turing.PartrecToTM2.Λ'\n⊢ Iff (Turing.PartrecToTM2.Supports (Union.union K₁ K₂) S) (And (Turing.PartrecToTM2.Supports K₁ S) (Turing.PartrecToTM2.Supports K₂ S))","decl":"theorem supports_union {K₁ K₂ S} : Supports (K₁ ∪ K₂) S ↔ Supports K₁ S ∧ Supports K₂ S := by\n  simp [Supports, or_imp, forall_and]\n\n"}
{"name":"Turing.PartrecToTM2.supports_biUnion","module":"Mathlib.Computability.TMToPartrec","initialProofState":"K : Option Turing.PartrecToTM2.Γ' → Finset Turing.PartrecToTM2.Λ'\nS : Finset Turing.PartrecToTM2.Λ'\n⊢ Iff (Turing.PartrecToTM2.Supports (Finset.univ.biUnion K) S) (∀ (a : Option Turing.PartrecToTM2.Γ'), Turing.PartrecToTM2.Supports (K a) S)","decl":"theorem supports_biUnion {K : Option Γ' → Finset Λ'} {S} :\n    Supports (Finset.univ.biUnion K) S ↔ ∀ a, Supports (K a) S := by\n  simpa [Supports] using forall_swap\n\n"}
{"name":"Turing.PartrecToTM2.head_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nk : Turing.PartrecToTM2.K'\nq : Turing.PartrecToTM2.Λ'\nH : Turing.PartrecToTM2.Λ'.Supports S q\n⊢ Turing.PartrecToTM2.Λ'.Supports S (Turing.PartrecToTM2.head k q)","decl":"theorem head_supports {S k q} (H : (q : Λ').Supports S) : (head k q).Supports S := fun _ => by\n  dsimp only; split_ifs <;> exact H\n\n"}
{"name":"Turing.PartrecToTM2.ret_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nk : Turing.PartrecToTM2.Cont'\nH₁ : HasSubset.Subset (Turing.PartrecToTM2.contSupp k) S\n⊢ Turing.TM2.SupportsStmt S (Turing.PartrecToTM2.tr (Turing.PartrecToTM2.Λ'.ret k))","decl":"theorem ret_supports {S k} (H₁ : contSupp k ⊆ S) : TM2.SupportsStmt S (tr (Λ'.ret k)) := by\n  have W := fun {q} => trStmts₁_self q\n  cases k with\n  | halt => trivial\n  | cons₁ => rw [contSupp_cons₁, Finset.union_subset_iff] at H₁; exact fun _ => H₁.1 W\n  | cons₂ => rw [contSupp_cons₂, Finset.union_subset_iff] at H₁; exact fun _ => H₁.1 W\n  | comp => rw [contSupp_comp] at H₁; exact fun _ => H₁ (codeSupp_self _ _ W)\n  | fix =>\n    rw [contSupp_fix] at H₁\n    have L := @Finset.mem_union_left; have R := @Finset.mem_union_right\n    intro s; dsimp only; cases natEnd s.iget\n    · refine H₁ (R _ <| L _ <| R _ <| R _ <| L _ W)\n    · exact H₁ (R _ <| L _ <| R _ <| R _ <| R _ <| Finset.mem_singleton_self _)\n\n"}
{"name":"Turing.PartrecToTM2.trStmts₁_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nq : Turing.PartrecToTM2.Λ'\nH₁ : Turing.PartrecToTM2.Λ'.Supports S q\nHS₁ : HasSubset.Subset (Turing.PartrecToTM2.trStmts₁ q) S\n⊢ Turing.PartrecToTM2.Supports (Turing.PartrecToTM2.trStmts₁ q) S","decl":"theorem trStmts₁_supports {S q} (H₁ : (q : Λ').Supports S) (HS₁ : trStmts₁ q ⊆ S) :\n    Supports (trStmts₁ q) S := by\n  have W := fun {q} => trStmts₁_self q\n  induction q with\n  | move _ _ _ q q_ih => _ | clear _ _ q q_ih => _ | copy q q_ih => _ | push _ _ q q_ih => _\n  | read q q_ih => _ | succ q q_ih => _ | pred q₁ q₂ q₁_ih q₂_ih => _ | ret => _ <;>\n    simp [trStmts₁, -Finset.singleton_subset_iff] at HS₁ ⊢\n  any_goals\n    cases' Finset.insert_subset_iff.1 HS₁ with h₁ h₂\n    first | have h₃ := h₂ W | try simp [Finset.subset_iff] at h₂\n  · exact supports_insert.2 ⟨⟨fun _ => h₃, fun _ => h₁⟩, q_ih H₁ h₂⟩ -- move\n  · exact supports_insert.2 ⟨⟨fun _ => h₃, fun _ => h₁⟩, q_ih H₁ h₂⟩ -- clear\n  · exact supports_insert.2 ⟨⟨fun _ => h₁, fun _ => h₃⟩, q_ih H₁ h₂⟩ -- copy\n  · exact supports_insert.2 ⟨⟨fun _ => h₃, fun _ => h₃⟩, q_ih H₁ h₂⟩ -- push\n  · refine supports_insert.2 ⟨fun _ => h₂ _ W, ?_⟩ -- read\n    exact supports_biUnion.2 fun _ => q_ih _ (H₁ _) fun _ h => h₂ _ h\n  · refine supports_insert.2 ⟨⟨fun _ => h₁, fun _ => h₂.1, fun _ => h₂.1⟩, ?_⟩ -- succ\n    exact supports_insert.2 ⟨⟨fun _ => h₂.2 _ W, fun _ => h₂.1⟩, q_ih H₁ h₂.2⟩\n  · refine -- pred\n      supports_insert.2 ⟨⟨fun _ => h₁, fun _ => h₂.2 _ (Or.inl W),\n                          fun _ => h₂.1, fun _ => h₂.1⟩, ?_⟩\n    refine supports_insert.2 ⟨⟨fun _ => h₂.2 _ (Or.inr W), fun _ => h₂.1⟩, ?_⟩\n    refine supports_union.2 ⟨?_, ?_⟩\n    · exact q₁_ih H₁.1 fun _ h => h₂.2 _ (Or.inl h)\n    · exact q₂_ih H₁.2 fun _ h => h₂.2 _ (Or.inr h)\n  · exact supports_singleton.2 (ret_supports H₁)  -- ret\n\n"}
{"name":"Turing.PartrecToTM2.trStmts₁_supports'","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nq : Turing.PartrecToTM2.Λ'\nK : Finset Turing.PartrecToTM2.Λ'\nH₁ : Turing.PartrecToTM2.Λ'.Supports S q\nH₂ : HasSubset.Subset (Union.union (Turing.PartrecToTM2.trStmts₁ q) K) S\nH₃ : HasSubset.Subset K S → Turing.PartrecToTM2.Supports K S\n⊢ Turing.PartrecToTM2.Supports (Union.union (Turing.PartrecToTM2.trStmts₁ q) K) S","decl":"theorem trStmts₁_supports' {S q K} (H₁ : (q : Λ').Supports S) (H₂ : trStmts₁ q ∪ K ⊆ S)\n    (H₃ : K ⊆ S → Supports K S) : Supports (trStmts₁ q ∪ K) S := by\n  simp only [Finset.union_subset_iff] at H₂\n  exact supports_union.2 ⟨trStmts₁_supports H₁ H₂.1, H₃ H₂.2⟩\n\n"}
{"name":"Turing.PartrecToTM2.trNormal_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nc : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\nHk : HasSubset.Subset (Turing.PartrecToTM2.codeSupp c k) S\n⊢ Turing.PartrecToTM2.Λ'.Supports S (Turing.PartrecToTM2.trNormal c k)","decl":"theorem trNormal_supports {S c k} (Hk : codeSupp c k ⊆ S) : (trNormal c k).Supports S := by\n  induction c generalizing k with simp [Λ'.Supports, head]\n  | zero' => exact Finset.union_subset_right Hk\n  | succ => intro; split_ifs <;> exact Finset.union_subset_right Hk\n  | tail => exact Finset.union_subset_right Hk\n  | cons f fs IHf _ =>\n    apply IHf\n    rw [codeSupp_cons] at Hk\n    exact Finset.union_subset_right Hk\n  | comp f g _ IHg => apply IHg; rw [codeSupp_comp] at Hk; exact Finset.union_subset_right Hk\n  | case f g IHf IHg =>\n    simp only [codeSupp_case, Finset.union_subset_iff] at Hk\n    exact ⟨IHf Hk.2.1, IHg Hk.2.2⟩\n  | fix f IHf => apply IHf; rw [codeSupp_fix] at Hk; exact Finset.union_subset_right Hk\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp'_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nc : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\nH : HasSubset.Subset (Turing.PartrecToTM2.codeSupp c k) S\n⊢ Turing.PartrecToTM2.Supports (Turing.PartrecToTM2.codeSupp' c k) S","decl":"theorem codeSupp'_supports {S c k} (H : codeSupp c k ⊆ S) : Supports (codeSupp' c k) S := by\n  induction c generalizing k with\n  | cons f fs IHf IHfs =>\n    have H' := H; simp only [codeSupp_cons, Finset.union_subset_iff] at H'\n    refine trStmts₁_supports' (trNormal_supports H) (Finset.union_subset_left H) fun h => ?_\n    refine supports_union.2 ⟨IHf H'.2, ?_⟩\n    refine trStmts₁_supports' (trNormal_supports ?_) (Finset.union_subset_right h) fun h => ?_\n    · simp only [codeSupp, Finset.union_subset_iff, contSupp] at h H ⊢\n      exact ⟨h.2.2.1, h.2.2.2, H.2⟩\n    refine supports_union.2 ⟨IHfs ?_, ?_⟩\n    · rw [codeSupp, contSupp_cons₁] at H'\n      exact Finset.union_subset_right (Finset.union_subset_right H'.2)\n    exact\n      trStmts₁_supports (head_supports <| Finset.union_subset_right H)\n        (Finset.union_subset_right h)\n  | comp f g IHf IHg =>\n    have H' := H; rw [codeSupp_comp] at H'; have H' := Finset.union_subset_right H'\n    refine trStmts₁_supports' (trNormal_supports H) (Finset.union_subset_left H) fun h => ?_\n    refine supports_union.2 ⟨IHg H', ?_⟩\n    refine trStmts₁_supports' (trNormal_supports ?_) (Finset.union_subset_right h) fun _ => ?_\n    · simp only [codeSupp', codeSupp, Finset.union_subset_iff, contSupp] at h H ⊢\n      exact ⟨h.2.2, H.2⟩\n    exact IHf (Finset.union_subset_right H')\n  | case f g IHf IHg =>\n    have H' := H; simp only [codeSupp_case, Finset.union_subset_iff] at H'\n    refine trStmts₁_supports' (trNormal_supports H) (Finset.union_subset_left H) fun _ => ?_\n    exact supports_union.2 ⟨IHf H'.2.1, IHg H'.2.2⟩\n  | fix f IHf =>\n    have H' := H; simp only [codeSupp_fix, Finset.union_subset_iff] at H'\n    refine trStmts₁_supports' (trNormal_supports H) (Finset.union_subset_left H) fun h => ?_\n    refine supports_union.2 ⟨IHf H'.2, ?_⟩\n    refine trStmts₁_supports' (trNormal_supports ?_) (Finset.union_subset_right h) fun _ => ?_\n    · simp only [codeSupp', codeSupp, Finset.union_subset_iff, contSupp, trStmts₁,\n        Finset.insert_subset_iff] at h H ⊢\n      exact ⟨h.1, ⟨H.1.1, h⟩, H.2⟩\n    exact supports_singleton.2 (ret_supports <| Finset.union_subset_right H)\n  | _ => exact trStmts₁_supports (trNormal_supports H) (Finset.Subset.trans (codeSupp_self _ _) H)\n\n"}
{"name":"Turing.PartrecToTM2.contSupp_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nk : Turing.PartrecToTM2.Cont'\nH : HasSubset.Subset (Turing.PartrecToTM2.contSupp k) S\n⊢ Turing.PartrecToTM2.Supports (Turing.PartrecToTM2.contSupp k) S","decl":"theorem contSupp_supports {S k} (H : contSupp k ⊆ S) : Supports (contSupp k) S := by\n  induction k with\n  | halt => simp [contSupp_halt, Supports]\n  | cons₁ f k IH =>\n    have H₁ := H; rw [contSupp_cons₁] at H₁; have H₂ := Finset.union_subset_right H₁\n    refine trStmts₁_supports' (trNormal_supports H₂) H₁ fun h => ?_\n    refine supports_union.2 ⟨codeSupp'_supports H₂, ?_⟩\n    simp only [codeSupp, contSupp_cons₂, Finset.union_subset_iff] at H₂\n    exact trStmts₁_supports' (head_supports H₂.2.2) (Finset.union_subset_right h) IH\n  | cons₂ k IH =>\n    have H' := H; rw [contSupp_cons₂] at H'\n    exact trStmts₁_supports' (head_supports <| Finset.union_subset_right H') H' IH\n  | comp f k IH =>\n    have H' := H; rw [contSupp_comp] at H'; have H₂ := Finset.union_subset_right H'\n    exact supports_union.2 ⟨codeSupp'_supports H', IH H₂⟩\n  | fix f k IH =>\n    rw [contSupp] at H\n    exact supports_union.2 ⟨codeSupp'_supports H, IH (Finset.union_subset_right H)⟩\n\n"}
{"name":"Turing.PartrecToTM2.codeSupp_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"S : Finset Turing.PartrecToTM2.Λ'\nc : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\nH : HasSubset.Subset (Turing.PartrecToTM2.codeSupp c k) S\n⊢ Turing.PartrecToTM2.Supports (Turing.PartrecToTM2.codeSupp c k) S","decl":"theorem codeSupp_supports {S c k} (H : codeSupp c k ⊆ S) : Supports (codeSupp c k) S :=\n  supports_union.2 ⟨codeSupp'_supports H, contSupp_supports (Finset.union_subset_right H)⟩\n\n"}
{"name":"Turing.PartrecToTM2.tr_supports","module":"Mathlib.Computability.TMToPartrec","initialProofState":"c : Turing.ToPartrec.Code\nk : Turing.PartrecToTM2.Cont'\n⊢ Turing.TM2.Supports Turing.PartrecToTM2.tr (Turing.PartrecToTM2.codeSupp c k)","decl":"/-- The set `codeSupp c k` is a finite set that witnesses the effective finiteness of the `tr`\nTuring machine. Starting from the initial state `trNormal c k`, forward simulation uses only\nstates in `codeSupp c k`, so this is a finite state machine. Even though the underlying type of\nstate labels `Λ'` is infinite, for a given partial recursive function `c` and continuation `k`,\nonly finitely many states are accessed, corresponding roughly to subterms of `c`. -/\ntheorem tr_supports (c k) : @TM2.Supports _ _ _ _ ⟨trNormal c k⟩ tr (codeSupp c k) :=\n  ⟨codeSupp_self _ _ (trStmts₁_self _), fun _ => codeSupp_supports (Finset.Subset.refl _) _⟩\n\n"}
