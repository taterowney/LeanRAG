{"name":"AddGroupSeminorm.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoFun✝ : G → Real\nmap_zero'✝ : Eq (toFun✝ 0) 0\nadd_le'✝ : ∀ (r s : G), LE.le (toFun✝ (HAdd.hAdd r s)) (HAdd.hAdd (toFun✝ r) (toFun✝ s))\nneg'✝ : ∀ (r : G), Eq (toFun✝ (Neg.neg r)) (toFun✝ r)\ntoFun : G → Real\nmap_zero' : Eq (toFun 0) 0\nadd_le' : ∀ (r s : G), LE.le (toFun (HAdd.hAdd r s)) (HAdd.hAdd (toFun r) (toFun s))\nneg' : ∀ (r : G), Eq (toFun (Neg.neg r)) (toFun r)\n⊢ Eq (Eq { toFun := toFun✝, map_zero' := map_zero'✝, add_le' := add_le'✝, neg' := neg'✝ } { toFun := toFun, map_zero' := map_zero', add_le' := add_le', neg' := neg' }) (Eq toFun✝ toFun)","decl":"/-- A seminorm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nsubadditive and such that `f (-x) = f x` for all `x`. -/\nstructure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  -- Porting note: can't extend `ZeroHom G ℝ` because otherwise `to_additive` won't work since\n  -- we aren't using old structures\n  /-- The bare function of an `AddGroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of zero is zero. -/\n  protected map_zero' : toFun 0 = 0\n  /-- The seminorm is subadditive. -/\n  protected add_le' : ∀ r s, toFun (r + s) ≤ toFun r + toFun s\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"AddGroupSeminorm.add_le'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : AddGroupSeminorm G\nr s : G\n⊢ LE.le (self.toFun (HAdd.hAdd r s)) (HAdd.hAdd (self.toFun r) (self.toFun s))","decl":"/-- A seminorm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nsubadditive and such that `f (-x) = f x` for all `x`. -/\nstructure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  -- Porting note: can't extend `ZeroHom G ℝ` because otherwise `to_additive` won't work since\n  -- we aren't using old structures\n  /-- The bare function of an `AddGroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of zero is zero. -/\n  protected map_zero' : toFun 0 = 0\n  /-- The seminorm is subadditive. -/\n  protected add_le' : ∀ r s, toFun (r + s) ≤ toFun r + toFun s\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"AddGroupSeminorm.mk.inj","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoFun✝ : G → Real\nmap_zero'✝ : Eq (toFun✝ 0) 0\nadd_le'✝ : ∀ (r s : G), LE.le (toFun✝ (HAdd.hAdd r s)) (HAdd.hAdd (toFun✝ r) (toFun✝ s))\nneg'✝ : ∀ (r : G), Eq (toFun✝ (Neg.neg r)) (toFun✝ r)\ntoFun : G → Real\nmap_zero' : Eq (toFun 0) 0\nadd_le' : ∀ (r s : G), LE.le (toFun (HAdd.hAdd r s)) (HAdd.hAdd (toFun r) (toFun s))\nneg' : ∀ (r : G), Eq (toFun (Neg.neg r)) (toFun r)\nx✝ : Eq { toFun := toFun✝, map_zero' := map_zero'✝, add_le' := add_le'✝, neg' := neg'✝ } { toFun := toFun, map_zero' := map_zero', add_le' := add_le', neg' := neg' }\n⊢ Eq toFun✝ toFun","decl":"/-- A seminorm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nsubadditive and such that `f (-x) = f x` for all `x`. -/\nstructure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  -- Porting note: can't extend `ZeroHom G ℝ` because otherwise `to_additive` won't work since\n  -- we aren't using old structures\n  /-- The bare function of an `AddGroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of zero is zero. -/\n  protected map_zero' : toFun 0 = 0\n  /-- The seminorm is subadditive. -/\n  protected add_le' : ∀ r s, toFun (r + s) ≤ toFun r + toFun s\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"AddGroupSeminorm.neg'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : AddGroupSeminorm G\nr : G\n⊢ Eq (self.toFun (Neg.neg r)) (self.toFun r)","decl":"/-- A seminorm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nsubadditive and such that `f (-x) = f x` for all `x`. -/\nstructure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  -- Porting note: can't extend `ZeroHom G ℝ` because otherwise `to_additive` won't work since\n  -- we aren't using old structures\n  /-- The bare function of an `AddGroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of zero is zero. -/\n  protected map_zero' : toFun 0 = 0\n  /-- The seminorm is subadditive. -/\n  protected add_le' : ∀ r s, toFun (r + s) ≤ toFun r + toFun s\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"AddGroupSeminorm.map_zero'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : AddGroupSeminorm G\n⊢ Eq (self.toFun 0) 0","decl":"/-- A seminorm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nsubadditive and such that `f (-x) = f x` for all `x`. -/\nstructure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  -- Porting note: can't extend `ZeroHom G ℝ` because otherwise `to_additive` won't work since\n  -- we aren't using old structures\n  /-- The bare function of an `AddGroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of zero is zero. -/\n  protected map_zero' : toFun 0 = 0\n  /-- The seminorm is subadditive. -/\n  protected add_le' : ∀ r s, toFun (r + s) ≤ toFun r + toFun s\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"AddGroupSeminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : SizeOf G\ntoFun : G → Real\nmap_zero' : Eq (toFun 0) 0\nadd_le' : ∀ (r s : G), LE.le (toFun (HAdd.hAdd r s)) (HAdd.hAdd (toFun r) (toFun s))\nneg' : ∀ (r : G), Eq (toFun (Neg.neg r)) (toFun r)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_zero' := map_zero', add_le' := add_le', neg' := neg' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_zero'))","decl":"/-- A seminorm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nsubadditive and such that `f (-x) = f x` for all `x`. -/\nstructure AddGroupSeminorm (G : Type*) [AddGroup G] where\n  -- Porting note: can't extend `ZeroHom G ℝ` because otherwise `to_additive` won't work since\n  -- we aren't using old structures\n  /-- The bare function of an `AddGroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of zero is zero. -/\n  protected map_zero' : toFun 0 = 0\n  /-- The seminorm is subadditive. -/\n  protected add_le' : ∀ r s, toFun (r + s) ≤ toFun r + toFun s\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"GroupSeminorm.inv'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\nself : GroupSeminorm G\nx : G\n⊢ Eq (self.toFun (Inv.inv x)) (self.toFun x)","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` for all `x`. -/\n@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  /-- The bare function of a `GroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of one is zero. -/\n  protected map_one' : toFun 1 = 0\n  /-- The seminorm applied to a product is dominated by the sum of the seminorm applied to the\n  factors. -/\n  protected mul_le' : ∀ x y, toFun (x * y) ≤ toFun x + toFun y\n  /-- The seminorm is invariant under inversion. -/\n  protected inv' : ∀ x, toFun x⁻¹ = toFun x\n\n"}
{"name":"GroupSeminorm.mul_le'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\nself : GroupSeminorm G\nx y : G\n⊢ LE.le (self.toFun (HMul.hMul x y)) (HAdd.hAdd (self.toFun x) (self.toFun y))","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` for all `x`. -/\n@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  /-- The bare function of a `GroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of one is zero. -/\n  protected map_one' : toFun 1 = 0\n  /-- The seminorm applied to a product is dominated by the sum of the seminorm applied to the\n  factors. -/\n  protected mul_le' : ∀ x y, toFun (x * y) ≤ toFun x + toFun y\n  /-- The seminorm is invariant under inversion. -/\n  protected inv' : ∀ x, toFun x⁻¹ = toFun x\n\n"}
{"name":"GroupSeminorm.map_one'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\nself : GroupSeminorm G\n⊢ Eq (self.toFun 1) 0","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` for all `x`. -/\n@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  /-- The bare function of a `GroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of one is zero. -/\n  protected map_one' : toFun 1 = 0\n  /-- The seminorm applied to a product is dominated by the sum of the seminorm applied to the\n  factors. -/\n  protected mul_le' : ∀ x y, toFun (x * y) ≤ toFun x + toFun y\n  /-- The seminorm is invariant under inversion. -/\n  protected inv' : ∀ x, toFun x⁻¹ = toFun x\n\n"}
{"name":"GroupSeminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝¹ : Group G\ninst✝ : SizeOf G\ntoFun : G → Real\nmap_one' : Eq (toFun 1) 0\nmul_le' : ∀ (x y : G), LE.le (toFun (HMul.hMul x y)) (HAdd.hAdd (toFun x) (toFun y))\ninv' : ∀ (x : G), Eq (toFun (Inv.inv x)) (toFun x)\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_one' := map_one', mul_le' := mul_le', inv' := inv' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_one'))","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` for all `x`. -/\n@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  /-- The bare function of a `GroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of one is zero. -/\n  protected map_one' : toFun 1 = 0\n  /-- The seminorm applied to a product is dominated by the sum of the seminorm applied to the\n  factors. -/\n  protected mul_le' : ∀ x y, toFun (x * y) ≤ toFun x + toFun y\n  /-- The seminorm is invariant under inversion. -/\n  protected inv' : ∀ x, toFun x⁻¹ = toFun x\n\n"}
{"name":"GroupSeminorm.mk.inj","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\ntoFun✝ : G → Real\nmap_one'✝ : Eq (toFun✝ 1) 0\nmul_le'✝ : ∀ (x y : G), LE.le (toFun✝ (HMul.hMul x y)) (HAdd.hAdd (toFun✝ x) (toFun✝ y))\ninv'✝ : ∀ (x : G), Eq (toFun✝ (Inv.inv x)) (toFun✝ x)\ntoFun : G → Real\nmap_one' : Eq (toFun 1) 0\nmul_le' : ∀ (x y : G), LE.le (toFun (HMul.hMul x y)) (HAdd.hAdd (toFun x) (toFun y))\ninv' : ∀ (x : G), Eq (toFun (Inv.inv x)) (toFun x)\nx✝ : Eq { toFun := toFun✝, map_one' := map_one'✝, mul_le' := mul_le'✝, inv' := inv'✝ } { toFun := toFun, map_one' := map_one', mul_le' := mul_le', inv' := inv' }\n⊢ Eq toFun✝ toFun","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` for all `x`. -/\n@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  /-- The bare function of a `GroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of one is zero. -/\n  protected map_one' : toFun 1 = 0\n  /-- The seminorm applied to a product is dominated by the sum of the seminorm applied to the\n  factors. -/\n  protected mul_le' : ∀ x y, toFun (x * y) ≤ toFun x + toFun y\n  /-- The seminorm is invariant under inversion. -/\n  protected inv' : ∀ x, toFun x⁻¹ = toFun x\n\n"}
{"name":"GroupSeminorm.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\ntoFun✝ : G → Real\nmap_one'✝ : Eq (toFun✝ 1) 0\nmul_le'✝ : ∀ (x y : G), LE.le (toFun✝ (HMul.hMul x y)) (HAdd.hAdd (toFun✝ x) (toFun✝ y))\ninv'✝ : ∀ (x : G), Eq (toFun✝ (Inv.inv x)) (toFun✝ x)\ntoFun : G → Real\nmap_one' : Eq (toFun 1) 0\nmul_le' : ∀ (x y : G), LE.le (toFun (HMul.hMul x y)) (HAdd.hAdd (toFun x) (toFun y))\ninv' : ∀ (x : G), Eq (toFun (Inv.inv x)) (toFun x)\n⊢ Eq (Eq { toFun := toFun✝, map_one' := map_one'✝, mul_le' := mul_le'✝, inv' := inv'✝ } { toFun := toFun, map_one' := map_one', mul_le' := mul_le', inv' := inv' }) (Eq toFun✝ toFun)","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` for all `x`. -/\n@[to_additive]\nstructure GroupSeminorm (G : Type*) [Group G] where\n  /-- The bare function of a `GroupSeminorm`. -/\n  protected toFun : G → ℝ\n  /-- The image of one is zero. -/\n  protected map_one' : toFun 1 = 0\n  /-- The seminorm applied to a product is dominated by the sum of the seminorm applied to the\n  factors. -/\n  protected mul_le' : ∀ x y, toFun (x * y) ≤ toFun x + toFun y\n  /-- The seminorm is invariant under inversion. -/\n  protected inv' : ∀ x, toFun x⁻¹ = toFun x\n\n"}
{"name":"NonarchAddGroupSeminorm.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoZeroHom✝ : ZeroHom G Real\nadd_le_max'✝ : ∀ (r s : G), LE.le (toZeroHom✝.toFun (HAdd.hAdd r s)) (Max.max (toZeroHom✝.toFun r) (toZeroHom✝.toFun s))\nneg'✝ : ∀ (r : G), Eq (toZeroHom✝.toFun (Neg.neg r)) (toZeroHom✝.toFun r)\ntoZeroHom : ZeroHom G Real\nadd_le_max' : ∀ (r s : G), LE.le (toZeroHom.toFun (HAdd.hAdd r s)) (Max.max (toZeroHom.toFun r) (toZeroHom.toFun s))\nneg' : ∀ (r : G), Eq (toZeroHom.toFun (Neg.neg r)) (toZeroHom.toFun r)\n⊢ Eq (Eq { toZeroHom := toZeroHom✝, add_le_max' := add_le_max'✝, neg' := neg'✝ } { toZeroHom := toZeroHom, add_le_max' := add_le_max', neg' := neg' }) (Eq toZeroHom✝ toZeroHom)","decl":"/-- A nonarchimedean seminorm on an additive group `G` is a function `f : G → ℝ` that preserves\nzero, is nonarchimedean and such that `f (-x) = f x` for all `x`. -/\nstructure NonarchAddGroupSeminorm (G : Type*) [AddGroup G] extends ZeroHom G ℝ where\n  /-- The seminorm applied to a sum is dominated by the maximum of the function applied to the\n  addends. -/\n  protected add_le_max' : ∀ r s, toFun (r + s) ≤ max (toFun r) (toFun s)\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"NonarchAddGroupSeminorm.mk.inj","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoZeroHom✝ : ZeroHom G Real\nadd_le_max'✝ : ∀ (r s : G), LE.le (toZeroHom✝.toFun (HAdd.hAdd r s)) (Max.max (toZeroHom✝.toFun r) (toZeroHom✝.toFun s))\nneg'✝ : ∀ (r : G), Eq (toZeroHom✝.toFun (Neg.neg r)) (toZeroHom✝.toFun r)\ntoZeroHom : ZeroHom G Real\nadd_le_max' : ∀ (r s : G), LE.le (toZeroHom.toFun (HAdd.hAdd r s)) (Max.max (toZeroHom.toFun r) (toZeroHom.toFun s))\nneg' : ∀ (r : G), Eq (toZeroHom.toFun (Neg.neg r)) (toZeroHom.toFun r)\nx✝ : Eq { toZeroHom := toZeroHom✝, add_le_max' := add_le_max'✝, neg' := neg'✝ } { toZeroHom := toZeroHom, add_le_max' := add_le_max', neg' := neg' }\n⊢ Eq toZeroHom✝ toZeroHom","decl":"/-- A nonarchimedean seminorm on an additive group `G` is a function `f : G → ℝ` that preserves\nzero, is nonarchimedean and such that `f (-x) = f x` for all `x`. -/\nstructure NonarchAddGroupSeminorm (G : Type*) [AddGroup G] extends ZeroHom G ℝ where\n  /-- The seminorm applied to a sum is dominated by the maximum of the function applied to the\n  addends. -/\n  protected add_le_max' : ∀ r s, toFun (r + s) ≤ max (toFun r) (toFun s)\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"NonarchAddGroupSeminorm.neg'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : NonarchAddGroupSeminorm G\nr : G\n⊢ Eq (self.toFun (Neg.neg r)) (self.toFun r)","decl":"/-- A nonarchimedean seminorm on an additive group `G` is a function `f : G → ℝ` that preserves\nzero, is nonarchimedean and such that `f (-x) = f x` for all `x`. -/\nstructure NonarchAddGroupSeminorm (G : Type*) [AddGroup G] extends ZeroHom G ℝ where\n  /-- The seminorm applied to a sum is dominated by the maximum of the function applied to the\n  addends. -/\n  protected add_le_max' : ∀ r s, toFun (r + s) ≤ max (toFun r) (toFun s)\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"NonarchAddGroupSeminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : SizeOf G\ntoZeroHom : ZeroHom G Real\nadd_le_max' : ∀ (r s : G), LE.le (toZeroHom.toFun (HAdd.hAdd r s)) (Max.max (toZeroHom.toFun r) (toZeroHom.toFun s))\nneg' : ∀ (r : G), Eq (toZeroHom.toFun (Neg.neg r)) (toZeroHom.toFun r)\n⊢ Eq (SizeOf.sizeOf { toZeroHom := toZeroHom, add_le_max' := add_le_max', neg' := neg' }) (HAdd.hAdd 1 (SizeOf.sizeOf toZeroHom))","decl":"/-- A nonarchimedean seminorm on an additive group `G` is a function `f : G → ℝ` that preserves\nzero, is nonarchimedean and such that `f (-x) = f x` for all `x`. -/\nstructure NonarchAddGroupSeminorm (G : Type*) [AddGroup G] extends ZeroHom G ℝ where\n  /-- The seminorm applied to a sum is dominated by the maximum of the function applied to the\n  addends. -/\n  protected add_le_max' : ∀ r s, toFun (r + s) ≤ max (toFun r) (toFun s)\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"NonarchAddGroupSeminorm.add_le_max'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : NonarchAddGroupSeminorm G\nr s : G\n⊢ LE.le (self.toFun (HAdd.hAdd r s)) (Max.max (self.toFun r) (self.toFun s))","decl":"/-- A nonarchimedean seminorm on an additive group `G` is a function `f : G → ℝ` that preserves\nzero, is nonarchimedean and such that `f (-x) = f x` for all `x`. -/\nstructure NonarchAddGroupSeminorm (G : Type*) [AddGroup G] extends ZeroHom G ℝ where\n  /-- The seminorm applied to a sum is dominated by the maximum of the function applied to the\n  addends. -/\n  protected add_le_max' : ∀ r s, toFun (r + s) ≤ max (toFun r) (toFun s)\n  /-- The seminorm is invariant under negation. -/\n  protected neg' : ∀ r, toFun (-r) = toFun r\n\n"}
{"name":"AddGroupNorm.eq_zero_of_map_eq_zero'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : AddGroupNorm G\nx : G\na✝ : Eq (self.toFun x) 0\n⊢ Eq x 0","decl":"/-- A norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is subadditive\nand such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure AddGroupNorm (G : Type*) [AddGroup G] extends AddGroupSeminorm G where\n  /-- If the image under the seminorm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"AddGroupNorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : SizeOf G\ntoAddGroupSeminorm : AddGroupSeminorm G\neq_zero_of_map_eq_zero' : ∀ (x : G), Eq (toAddGroupSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (SizeOf.sizeOf { toAddGroupSeminorm := toAddGroupSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupSeminorm))","decl":"/-- A norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is subadditive\nand such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure AddGroupNorm (G : Type*) [AddGroup G] extends AddGroupSeminorm G where\n  /-- If the image under the seminorm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"AddGroupNorm.mk.inj","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoAddGroupSeminorm✝ : AddGroupSeminorm G\neq_zero_of_map_eq_zero'✝ : ∀ (x : G), Eq (toAddGroupSeminorm✝.toFun x) 0 → Eq x 0\ntoAddGroupSeminorm : AddGroupSeminorm G\neq_zero_of_map_eq_zero' : ∀ (x : G), Eq (toAddGroupSeminorm.toFun x) 0 → Eq x 0\nx✝ : Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }\n⊢ Eq toAddGroupSeminorm✝ toAddGroupSeminorm","decl":"/-- A norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is subadditive\nand such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure AddGroupNorm (G : Type*) [AddGroup G] extends AddGroupSeminorm G where\n  /-- If the image under the seminorm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"AddGroupNorm.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoAddGroupSeminorm✝ : AddGroupSeminorm G\neq_zero_of_map_eq_zero'✝ : ∀ (x : G), Eq (toAddGroupSeminorm✝.toFun x) 0 → Eq x 0\ntoAddGroupSeminorm : AddGroupSeminorm G\neq_zero_of_map_eq_zero' : ∀ (x : G), Eq (toAddGroupSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (Eq toAddGroupSeminorm✝ toAddGroupSeminorm)","decl":"/-- A norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is subadditive\nand such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure AddGroupNorm (G : Type*) [AddGroup G] extends AddGroupSeminorm G where\n  /-- If the image under the seminorm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"GroupNorm.mk.inj","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\ntoGroupSeminorm✝ : GroupSeminorm G\neq_one_of_map_eq_zero'✝ : ∀ (x : G), Eq (toGroupSeminorm✝.toFun x) 0 → Eq x 1\ntoGroupSeminorm : GroupSeminorm G\neq_one_of_map_eq_zero' : ∀ (x : G), Eq (toGroupSeminorm.toFun x) 0 → Eq x 1\nx✝ : Eq { toGroupSeminorm := toGroupSeminorm✝, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero'✝ } { toGroupSeminorm := toGroupSeminorm, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero' }\n⊢ Eq toGroupSeminorm✝ toGroupSeminorm","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` and `f x = 0 → x = 1` for all `x`. -/\n@[to_additive]\nstructure GroupNorm (G : Type*) [Group G] extends GroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is one. -/\n  protected eq_one_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 1\n\n"}
{"name":"GroupNorm.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\ntoGroupSeminorm✝ : GroupSeminorm G\neq_one_of_map_eq_zero'✝ : ∀ (x : G), Eq (toGroupSeminorm✝.toFun x) 0 → Eq x 1\ntoGroupSeminorm : GroupSeminorm G\neq_one_of_map_eq_zero' : ∀ (x : G), Eq (toGroupSeminorm.toFun x) 0 → Eq x 1\n⊢ Eq (Eq { toGroupSeminorm := toGroupSeminorm✝, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero'✝ } { toGroupSeminorm := toGroupSeminorm, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero' }) (Eq toGroupSeminorm✝ toGroupSeminorm)","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` and `f x = 0 → x = 1` for all `x`. -/\n@[to_additive]\nstructure GroupNorm (G : Type*) [Group G] extends GroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is one. -/\n  protected eq_one_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 1\n\n"}
{"name":"GroupNorm.eq_one_of_map_eq_zero'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : Group G\nself : GroupNorm G\nx : G\na✝ : Eq (self.toFun x) 0\n⊢ Eq x 1","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` and `f x = 0 → x = 1` for all `x`. -/\n@[to_additive]\nstructure GroupNorm (G : Type*) [Group G] extends GroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is one. -/\n  protected eq_one_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 1\n\n"}
{"name":"GroupNorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝¹ : Group G\ninst✝ : SizeOf G\ntoGroupSeminorm : GroupSeminorm G\neq_one_of_map_eq_zero' : ∀ (x : G), Eq (toGroupSeminorm.toFun x) 0 → Eq x 1\n⊢ Eq (SizeOf.sizeOf { toGroupSeminorm := toGroupSeminorm, eq_one_of_map_eq_zero' := eq_one_of_map_eq_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf toGroupSeminorm))","decl":"/-- A seminorm on a group `G` is a function `f : G → ℝ` that sends one to zero, is submultiplicative\nand such that `f x⁻¹ = f x` and `f x = 0 → x = 1` for all `x`. -/\n@[to_additive]\nstructure GroupNorm (G : Type*) [Group G] extends GroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is one. -/\n  protected eq_one_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 1\n\n"}
{"name":"NonarchAddGroupNorm.mk.injEq","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoNonarchAddGroupSeminorm✝ : NonarchAddGroupSeminorm G\neq_zero_of_map_eq_zero'✝ : ∀ (x : G), Eq (toNonarchAddGroupSeminorm✝.toFun x) 0 → Eq x 0\ntoNonarchAddGroupSeminorm : NonarchAddGroupSeminorm G\neq_zero_of_map_eq_zero' : ∀ (x : G), Eq (toNonarchAddGroupSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (Eq { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (Eq toNonarchAddGroupSeminorm✝ toNonarchAddGroupSeminorm)","decl":"/-- A nonarchimedean norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nnonarchimedean and such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure NonarchAddGroupNorm (G : Type*) [AddGroup G] extends NonarchAddGroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"NonarchAddGroupNorm.mk.inj","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\ntoNonarchAddGroupSeminorm✝ : NonarchAddGroupSeminorm G\neq_zero_of_map_eq_zero'✝ : ∀ (x : G), Eq (toNonarchAddGroupSeminorm✝.toFun x) 0 → Eq x 0\ntoNonarchAddGroupSeminorm : NonarchAddGroupSeminorm G\neq_zero_of_map_eq_zero' : ∀ (x : G), Eq (toNonarchAddGroupSeminorm.toFun x) 0 → Eq x 0\nx✝ : Eq { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm✝, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero'✝ } { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }\n⊢ Eq toNonarchAddGroupSeminorm✝ toNonarchAddGroupSeminorm","decl":"/-- A nonarchimedean norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nnonarchimedean and such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure NonarchAddGroupNorm (G : Type*) [AddGroup G] extends NonarchAddGroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"NonarchAddGroupNorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝¹ : AddGroup G\ninst✝ : SizeOf G\ntoNonarchAddGroupSeminorm : NonarchAddGroupSeminorm G\neq_zero_of_map_eq_zero' : ∀ (x : G), Eq (toNonarchAddGroupSeminorm.toFun x) 0 → Eq x 0\n⊢ Eq (SizeOf.sizeOf { toNonarchAddGroupSeminorm := toNonarchAddGroupSeminorm, eq_zero_of_map_eq_zero' := eq_zero_of_map_eq_zero' }) (HAdd.hAdd 1 (SizeOf.sizeOf toNonarchAddGroupSeminorm))","decl":"/-- A nonarchimedean norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nnonarchimedean and such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure NonarchAddGroupNorm (G : Type*) [AddGroup G] extends NonarchAddGroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"NonarchAddGroupNorm.eq_zero_of_map_eq_zero'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"G : Type u_6\ninst✝ : AddGroup G\nself : NonarchAddGroupNorm G\nx : G\na✝ : Eq (self.toFun x) 0\n⊢ Eq x 0","decl":"/-- A nonarchimedean norm on an additive group `G` is a function `f : G → ℝ` that preserves zero, is\nnonarchimedean and such that `f (-x) = f x` and `f x = 0 → x = 0` for all `x`. -/\nstructure NonarchAddGroupNorm (G : Type*) [AddGroup G] extends NonarchAddGroupSeminorm G where\n  /-- If the image under the norm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero' : ∀ x, toFun x = 0 → x = 0\n\n"}
{"name":"NonarchAddGroupSeminormClass.map_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\ninst✝¹ : AddGroup α\ninst✝ : FunLike F α Real\nself : NonarchAddGroupSeminormClass F α\nf : F\n⊢ Eq (f 0) 0","decl":"/-- `NonarchAddGroupSeminormClass F α` states that `F` is a type of nonarchimedean seminorms on\nthe additive group `α`.\n\nYou should extend this class when you extend `NonarchAddGroupSeminorm`. -/\nclass NonarchAddGroupSeminormClass (F : Type*) (α : outParam Type*) [AddGroup α] [FunLike F α ℝ]\n    extends NonarchimedeanHomClass F α ℝ : Prop where\n  /-- The image of zero is zero. -/\n  protected map_zero (f : F) : f 0 = 0\n  /-- The seminorm is invariant under negation. -/\n  protected map_neg_eq_map' (f : F) (a : α) : f (-a) = f a\n\n"}
{"name":"NonarchAddGroupSeminormClass.map_neg_eq_map'","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\ninst✝¹ : AddGroup α\ninst✝ : FunLike F α Real\nself : NonarchAddGroupSeminormClass F α\nf : F\na : α\n⊢ Eq (f (Neg.neg a)) (f a)","decl":"/-- `NonarchAddGroupSeminormClass F α` states that `F` is a type of nonarchimedean seminorms on\nthe additive group `α`.\n\nYou should extend this class when you extend `NonarchAddGroupSeminorm`. -/\nclass NonarchAddGroupSeminormClass (F : Type*) (α : outParam Type*) [AddGroup α] [FunLike F α ℝ]\n    extends NonarchimedeanHomClass F α ℝ : Prop where\n  /-- The image of zero is zero. -/\n  protected map_zero (f : F) : f 0 = 0\n  /-- The seminorm is invariant under negation. -/\n  protected map_neg_eq_map' (f : F) (a : α) : f (-a) = f a\n\n"}
{"name":"NonarchAddGroupSeminormClass.toNonarchimedeanHomClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\ninst✝¹ : AddGroup α\ninst✝ : FunLike F α Real\nself : NonarchAddGroupSeminormClass F α\n⊢ NonarchimedeanHomClass F α Real","decl":"/-- `NonarchAddGroupSeminormClass F α` states that `F` is a type of nonarchimedean seminorms on\nthe additive group `α`.\n\nYou should extend this class when you extend `NonarchAddGroupSeminorm`. -/\nclass NonarchAddGroupSeminormClass (F : Type*) (α : outParam Type*) [AddGroup α] [FunLike F α ℝ]\n    extends NonarchimedeanHomClass F α ℝ : Prop where\n  /-- The image of zero is zero. -/\n  protected map_zero (f : F) : f 0 = 0\n  /-- The seminorm is invariant under negation. -/\n  protected map_neg_eq_map' (f : F) (a : α) : f (-a) = f a\n\n"}
{"name":"NonarchAddGroupNormClass.toNonarchAddGroupSeminormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\ninst✝¹ : AddGroup α\ninst✝ : FunLike F α Real\nself : NonarchAddGroupNormClass F α\n⊢ NonarchAddGroupSeminormClass F α","decl":"/-- `NonarchAddGroupNormClass F α` states that `F` is a type of nonarchimedean norms on the\nadditive group `α`.\n\nYou should extend this class when you extend `NonarchAddGroupNorm`. -/\nclass NonarchAddGroupNormClass (F : Type*) (α : outParam Type*) [AddGroup α] [FunLike F α ℝ]\n    extends NonarchAddGroupSeminormClass F α : Prop where\n  /-- If the image under the norm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero (f : F) {a : α} : f a = 0 → a = 0\n\n"}
{"name":"NonarchAddGroupNormClass.eq_zero_of_map_eq_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\ninst✝¹ : AddGroup α\ninst✝ : FunLike F α Real\nself : NonarchAddGroupNormClass F α\nf : F\na : α\na✝ : Eq (f a) 0\n⊢ Eq a 0","decl":"/-- `NonarchAddGroupNormClass F α` states that `F` is a type of nonarchimedean norms on the\nadditive group `α`.\n\nYou should extend this class when you extend `NonarchAddGroupNorm`. -/\nclass NonarchAddGroupNormClass (F : Type*) (α : outParam Type*) [AddGroup α] [FunLike F α ℝ]\n    extends NonarchAddGroupSeminormClass F α : Prop where\n  /-- If the image under the norm is zero, then the argument is zero. -/\n  protected eq_zero_of_map_eq_zero (f : F) {a : α} : f a = 0 → a = 0\n\n"}
{"name":"map_sub_le_max","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝² : AddGroup E\ninst✝¹ : FunLike F E Real\ninst✝ : NonarchAddGroupSeminormClass F E\nf : F\nx y : E\n⊢ LE.le (f (HSub.hSub x y)) (Max.max (f x) (f y))","decl":"theorem map_sub_le_max : f (x - y) ≤ max (f x) (f y) := by\n  rw [sub_eq_add_neg, ← NonarchAddGroupSeminormClass.map_neg_eq_map' f y]\n  exact map_add_le_max _ _ _\n\n"}
{"name":"NonarchAddGroupSeminormClass.toAddGroupSeminormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝² : FunLike F E Real\ninst✝¹ : AddGroup E\ninst✝ : NonarchAddGroupSeminormClass F E\n⊢ AddGroupSeminormClass F E Real","decl":"instance (priority := 100) NonarchAddGroupSeminormClass.toAddGroupSeminormClass\n    [FunLike F E ℝ] [AddGroup E] [NonarchAddGroupSeminormClass F E] : AddGroupSeminormClass F E ℝ :=\n  { ‹NonarchAddGroupSeminormClass F E› with\n    map_add_le_add := fun f _ _ =>\n      haveI h_nonneg : ∀ a, 0 ≤ f a := by\n        intro a\n        rw [← NonarchAddGroupSeminormClass.map_zero f, ← sub_self a]\n        exact le_trans (map_sub_le_max _ _ _) (by rw [max_self (f a)])\n      le_trans (map_add_le_max _ _ _)\n        (max_le (le_add_of_nonneg_right (h_nonneg _)) (le_add_of_nonneg_left (h_nonneg _)))\n    map_neg_eq_map := NonarchAddGroupSeminormClass.map_neg_eq_map' }\n\n-- See note [lower instance priority]\n"}
{"name":"NonarchAddGroupNormClass.toAddGroupNormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝² : FunLike F E Real\ninst✝¹ : AddGroup E\ninst✝ : NonarchAddGroupNormClass F E\n⊢ AddGroupNormClass F E Real","decl":"instance (priority := 100) NonarchAddGroupNormClass.toAddGroupNormClass\n    [FunLike F E ℝ] [AddGroup E] [NonarchAddGroupNormClass F E] : AddGroupNormClass F E ℝ :=\n  { ‹NonarchAddGroupNormClass F E› with\n    map_add_le_add := map_add_le_add\n    map_neg_eq_map := NonarchAddGroupSeminormClass.map_neg_eq_map' }\n\n"}
{"name":"GroupSeminorm.groupSeminormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\n⊢ GroupSeminormClass (GroupSeminorm E) E Real","decl":"@[to_additive]\ninstance groupSeminormClass : GroupSeminormClass (GroupSeminorm E) E ℝ where\n  map_one_eq_zero f := f.map_one'\n  map_mul_le_add f := f.mul_le'\n  map_inv_eq_map f := f.inv'\n\n"}
{"name":"AddGroupSeminorm.addGroupSeminormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\n⊢ AddGroupSeminormClass (AddGroupSeminorm E) E Real","decl":"@[to_additive]\ninstance groupSeminormClass : GroupSeminormClass (GroupSeminorm E) E ℝ where\n  map_one_eq_zero f := f.map_one'\n  map_mul_le_add f := f.mul_le'\n  map_inv_eq_map f := f.inv'\n\n"}
{"name":"AddGroupSeminorm.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np : AddGroupSeminorm E\n⊢ Eq p.toFun ⇑p","decl":"@[to_additive (attr := simp)]\ntheorem toFun_eq_coe : p.toFun = p :=\n  rfl\n\n"}
{"name":"GroupSeminorm.toFun_eq_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np : GroupSeminorm E\n⊢ Eq p.toFun ⇑p","decl":"@[to_additive (attr := simp)]\ntheorem toFun_eq_coe : p.toFun = p :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.ext_iff","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"GroupSeminorm.ext_iff","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"AddGroupSeminorm.ext","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\na✝ : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"GroupSeminorm.ext","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\na✝ : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"GroupSeminorm.le_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Iff (LE.le p q) (LE.le ⇑p ⇑q)","decl":"@[to_additive]\ntheorem le_def : p ≤ q ↔ (p : E → ℝ) ≤ q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupSeminorm.le_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Iff (LE.le p q) (LE.le ⇑p ⇑q)","decl":"@[to_additive]\ntheorem le_def : p ≤ q ↔ (p : E → ℝ) ≤ q :=\n  Iff.rfl\n\n"}
{"name":"GroupSeminorm.lt_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Iff (LT.lt p q) (LT.lt ⇑p ⇑q)","decl":"@[to_additive]\ntheorem lt_def : p < q ↔ (p : E → ℝ) < q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupSeminorm.lt_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Iff (LT.lt p q) (LT.lt ⇑p ⇑q)","decl":"@[to_additive]\ntheorem lt_def : p < q ↔ (p : E → ℝ) < q :=\n  Iff.rfl\n\n"}
{"name":"GroupSeminorm.coe_le_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_le_coe : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupSeminorm.coe_le_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_le_coe : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"GroupSeminorm.coe_lt_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_lt_coe : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupSeminorm.coe_lt_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_lt_coe : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"GroupSeminorm.coe_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\n⊢ Eq (⇑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_zero : ⇑(0 : GroupSeminorm E) = 0 :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.coe_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\n⊢ Eq (⇑0) 0","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_zero : ⇑(0 : GroupSeminorm E) = 0 :=\n  rfl\n\n"}
{"name":"GroupSeminorm.zero_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\nx : E\n⊢ Eq (0 x) 0","decl":"@[to_additive (attr := simp)]\ntheorem zero_apply (x : E) : (0 : GroupSeminorm E) x = 0 :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.zero_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\nx : E\n⊢ Eq (0 x) 0","decl":"@[to_additive (attr := simp)]\ntheorem zero_apply (x : E) : (0 : GroupSeminorm E) x = 0 :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.coe_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Eq (⇑(HAdd.hAdd p q)) (HAdd.hAdd ⇑p ⇑q)","decl":"@[to_additive (attr := simp)]\ntheorem coe_add : ⇑(p + q) = p + q :=\n  rfl\n\n"}
{"name":"GroupSeminorm.coe_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Eq (⇑(HAdd.hAdd p q)) (HAdd.hAdd ⇑p ⇑q)","decl":"@[to_additive (attr := simp)]\ntheorem coe_add : ⇑(p + q) = p + q :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.add_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\nx : E\n⊢ Eq ((HAdd.hAdd p q) x) (HAdd.hAdd (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345\n"}
{"name":"GroupSeminorm.add_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\nx : E\n⊢ Eq ((HAdd.hAdd p q) x) (HAdd.hAdd (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet` too, from the skeleton at\n-- https://github.com/leanprover-community/mathlib/pull/11329#issuecomment-1008915345\n"}
{"name":"AddGroupSeminorm.coe_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sup : ⇑(p ⊔ q) = ⇑p ⊔ ⇑q :=\n  rfl\n\n"}
{"name":"GroupSeminorm.coe_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sup : ⇑(p ⊔ q) = ⇑p ⊔ ⇑q :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.sup_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupSeminorm E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem sup_apply (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"GroupSeminorm.sup_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupSeminorm E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem sup_apply (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.coe_comp","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddGroup E\ninst✝ : AddGroup F\np : AddGroupSeminorm E\nf : AddMonoidHom F E\n⊢ Eq (⇑(p.comp f)) (Function.comp ⇑p ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comp : ⇑(p.comp f) = p ∘ f :=\n  rfl\n\n"}
{"name":"GroupSeminorm.coe_comp","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : Group E\ninst✝ : Group F\np : GroupSeminorm E\nf : MonoidHom F E\n⊢ Eq (⇑(p.comp f)) (Function.comp ⇑p ⇑f)","decl":"@[to_additive (attr := simp)]\ntheorem coe_comp : ⇑(p.comp f) = p ∘ f :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.comp_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddGroup E\ninst✝ : AddGroup F\np : AddGroupSeminorm E\nf : AddMonoidHom F E\nx : F\n⊢ Eq ((p.comp f) x) (p (f x))","decl":"@[to_additive (attr := simp)]\ntheorem comp_apply (x : F) : (p.comp f) x = p (f x) :=\n  rfl\n\n"}
{"name":"GroupSeminorm.comp_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : Group E\ninst✝ : Group F\np : GroupSeminorm E\nf : MonoidHom F E\nx : F\n⊢ Eq ((p.comp f) x) (p (f x))","decl":"@[to_additive (attr := simp)]\ntheorem comp_apply (x : F) : (p.comp f) x = p (f x) :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.comp_id","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np : AddGroupSeminorm E\n⊢ Eq (p.comp (AddMonoidHom.id E)) p","decl":"@[to_additive (attr := simp)]\ntheorem comp_id : p.comp (MonoidHom.id _) = p :=\n  ext fun _ => rfl\n\n"}
{"name":"GroupSeminorm.comp_id","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np : GroupSeminorm E\n⊢ Eq (p.comp (MonoidHom.id E)) p","decl":"@[to_additive (attr := simp)]\ntheorem comp_id : p.comp (MonoidHom.id _) = p :=\n  ext fun _ => rfl\n\n"}
{"name":"GroupSeminorm.comp_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : Group E\ninst✝ : Group F\np : GroupSeminorm E\n⊢ Eq (p.comp 1) 0","decl":"@[to_additive (attr := simp)]\ntheorem comp_zero : p.comp (1 : F →* E) = 0 :=\n  ext fun _ => map_one_eq_zero p\n\n"}
{"name":"AddGroupSeminorm.comp_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddGroup E\ninst✝ : AddGroup F\np : AddGroupSeminorm E\n⊢ Eq (p.comp 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem comp_zero : p.comp (1 : F →* E) = 0 :=\n  ext fun _ => map_one_eq_zero p\n\n"}
{"name":"GroupSeminorm.zero_comp","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : Group E\ninst✝ : Group F\nf : MonoidHom F E\n⊢ Eq (GroupSeminorm.comp 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem zero_comp : (0 : GroupSeminorm E).comp f = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"AddGroupSeminorm.zero_comp","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddGroup E\ninst✝ : AddGroup F\nf : AddMonoidHom F E\n⊢ Eq (AddGroupSeminorm.comp 0 f) 0","decl":"@[to_additive (attr := simp)]\ntheorem zero_comp : (0 : GroupSeminorm E).comp f = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"GroupSeminorm.comp_assoc","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝² : Group E\ninst✝¹ : Group F\ninst✝ : Group G\np : GroupSeminorm E\ng : MonoidHom F E\nf : MonoidHom G F\n⊢ Eq (p.comp (g.comp f)) ((p.comp g).comp f)","decl":"@[to_additive]\ntheorem comp_assoc (g : F →* E) (f : G →* F) : p.comp (g.comp f) = (p.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"AddGroupSeminorm.comp_assoc","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\nG : Type u_5\ninst✝² : AddGroup E\ninst✝¹ : AddGroup F\ninst✝ : AddGroup G\np : AddGroupSeminorm E\ng : AddMonoidHom F E\nf : AddMonoidHom G F\n⊢ Eq (p.comp (g.comp f)) ((p.comp g).comp f)","decl":"@[to_additive]\ntheorem comp_assoc (g : F →* E) (f : G →* F) : p.comp (g.comp f) = (p.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"AddGroupSeminorm.add_comp","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddGroup E\ninst✝ : AddGroup F\np q : AddGroupSeminorm E\nf : AddMonoidHom F E\n⊢ Eq ((HAdd.hAdd p q).comp f) (HAdd.hAdd (p.comp f) (q.comp f))","decl":"@[to_additive]\ntheorem add_comp (f : F →* E) : (p + q).comp f = p.comp f + q.comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"GroupSeminorm.add_comp","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : Group E\ninst✝ : Group F\np q : GroupSeminorm E\nf : MonoidHom F E\n⊢ Eq ((HAdd.hAdd p q).comp f) (HAdd.hAdd (p.comp f) (q.comp f))","decl":"@[to_additive]\ntheorem add_comp (f : F →* E) : (p + q).comp f = p.comp f + q.comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"GroupSeminorm.comp_mono","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : Group E\ninst✝ : Group F\np q : GroupSeminorm E\nf : MonoidHom F E\nhp : LE.le p q\n⊢ LE.le (p.comp f) (q.comp f)","decl":"@[to_additive]\ntheorem comp_mono (hp : p ≤ q) : p.comp f ≤ q.comp f := fun _ => hp _\n\n"}
{"name":"AddGroupSeminorm.comp_mono","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddGroup E\ninst✝ : AddGroup F\np q : AddGroupSeminorm E\nf : AddMonoidHom F E\nhp : LE.le p q\n⊢ LE.le (p.comp f) (q.comp f)","decl":"@[to_additive]\ntheorem comp_mono (hp : p ≤ q) : p.comp f ≤ q.comp f := fun _ => hp _\n\n"}
{"name":"AddGroupSeminorm.comp_add_le","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : AddCommGroup E\ninst✝ : AddCommGroup F\np : AddGroupSeminorm E\nf g : AddMonoidHom F E\n⊢ LE.le (p.comp (HAdd.hAdd f g)) (HAdd.hAdd (p.comp f) (p.comp g))","decl":"@[to_additive]\ntheorem comp_mul_le (f g : F →* E) : p.comp (f * g) ≤ p.comp f + p.comp g := fun _ =>\n  map_mul_le_add p _ _\n\n"}
{"name":"GroupSeminorm.comp_mul_le","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\nF : Type u_4\ninst✝¹ : CommGroup E\ninst✝ : CommGroup F\np : GroupSeminorm E\nf g : MonoidHom F E\n⊢ LE.le (p.comp (HMul.hMul f g)) (HAdd.hAdd (p.comp f) (p.comp g))","decl":"@[to_additive]\ntheorem comp_mul_le (f g : F →* E) : p.comp (f * g) ≤ p.comp f + p.comp g := fun _ =>\n  map_mul_le_add p _ _\n\n"}
{"name":"AddGroupSeminorm.add_bddBelow_range_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddCommGroup E\np q : AddGroupSeminorm E\nx : E\n⊢ BddBelow (Set.range fun y => HAdd.hAdd (p y) (q (HSub.hSub x y)))","decl":"@[to_additive]\ntheorem mul_bddBelow_range_add {p q : GroupSeminorm E} {x : E} :\n    BddBelow (range fun y => p y + q (x / y)) :=\n  ⟨0, by\n    rintro _ ⟨x, rfl⟩\n    dsimp\n    positivity⟩\n\n"}
{"name":"GroupSeminorm.mul_bddBelow_range_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : CommGroup E\np q : GroupSeminorm E\nx : E\n⊢ BddBelow (Set.range fun y => HAdd.hAdd (p y) (q (HDiv.hDiv x y)))","decl":"@[to_additive]\ntheorem mul_bddBelow_range_add {p q : GroupSeminorm E} {x : E} :\n    BddBelow (range fun y => p y + q (x / y)) :=\n  ⟨0, by\n    rintro _ ⟨x, rfl⟩\n    dsimp\n    positivity⟩\n\n"}
{"name":"GroupSeminorm.inf_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : CommGroup E\np q : GroupSeminorm E\nx : E\n⊢ Eq ((Min.min p q) x) (iInf fun y => HAdd.hAdd (p y) (q (HDiv.hDiv x y)))","decl":"@[to_additive (attr := simp)]\ntheorem inf_apply : (p ⊓ q) x = ⨅ y, p y + q (x / y) :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.inf_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddCommGroup E\np q : AddGroupSeminorm E\nx : E\n⊢ Eq ((Min.min p q) x) (iInf fun y => HAdd.hAdd (p y) (q (HSub.hSub x y)))","decl":"@[to_additive (attr := simp)]\ntheorem inf_apply : (p ⊓ q) x = ⨅ y, p y + q (x / y) :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.apply_one","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝¹ : AddGroup E\ninst✝ : DecidableEq E\nx : E\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one [DecidableEq E] (x : E) : (1 : AddGroupSeminorm E) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.coe_smul","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : AddGroup E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : AddGroupSeminorm E\n⊢ Eq (⇑(HSMul.hSMul r p)) (HSMul.hSMul r ⇑p)","decl":"@[simp, norm_cast]\ntheorem coe_smul (r : R) (p : AddGroupSeminorm E) : ⇑(r • p) = r • ⇑p :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.smul_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : AddGroup E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : AddGroupSeminorm E\nx : E\n⊢ Eq ((HSMul.hSMul r p) x) (HSMul.hSMul r (p x))","decl":"@[simp]\ntheorem smul_apply (r : R) (p : AddGroupSeminorm E) (x : E) : (r • p) x = r • p x :=\n  rfl\n\n"}
{"name":"AddGroupSeminorm.isScalarTower","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nR' : Type u_2\nE : Type u_3\ninst✝⁶ : AddGroup E\ninst✝⁵ : SMul R Real\ninst✝⁴ : SMul R' Real\ninst✝³ : SMul R' NNReal\ninst✝² : IsScalarTower R' NNReal Real\ninst✝¹ : SMul R R'\ninst✝ : IsScalarTower R R' Real\n⊢ IsScalarTower R R' (AddGroupSeminorm E)","decl":"instance isScalarTower [SMul R' ℝ] [SMul R' ℝ≥0] [IsScalarTower R' ℝ≥0 ℝ] [SMul R R']\n    [IsScalarTower R R' ℝ] : IsScalarTower R R' (AddGroupSeminorm E) :=\n  ⟨fun r a p => ext fun x => smul_assoc r a (p x)⟩\n\n"}
{"name":"AddGroupSeminorm.smul_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : AddGroup E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np q : AddGroupSeminorm E\n⊢ Eq (HSMul.hSMul r (Max.max p q)) (Max.max (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"theorem smul_sup (r : R) (p q : AddGroupSeminorm E) : r • (p ⊔ q) = r • p ⊔ r • q :=\n  have Real.smul_max : ∀ x y : ℝ, r • max x y = max (r • x) (r • y) := fun x y => by\n    simpa only [← smul_eq_mul, ← NNReal.smul_def, smul_one_smul ℝ≥0 r (_ : ℝ)] using\n      mul_max_of_nonneg x y (r • (1 : ℝ≥0) : ℝ≥0).coe_nonneg\n  ext fun _ => Real.smul_max _ _\n\n"}
{"name":"NonarchAddGroupSeminorm.nonarchAddGroupSeminormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\n⊢ NonarchAddGroupSeminormClass (NonarchAddGroupSeminorm E) E","decl":"instance nonarchAddGroupSeminormClass :\n    NonarchAddGroupSeminormClass (NonarchAddGroupSeminorm E) E where\n  map_add_le_max f := f.add_le_max'\n  map_zero f := f.map_zero'\n  map_neg_eq_map' f := f.neg'\n\n"}
{"name":"NonarchAddGroupSeminorm.toZeroHom_eq_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np : NonarchAddGroupSeminorm E\n⊢ Eq ⇑p.toZeroHom ⇑p","decl":"@[simp]\ntheorem toZeroHom_eq_coe : ⇑p.toZeroHom = p := by\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.ext_iff","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"NonarchAddGroupSeminorm.ext","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\na✝ : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"NonarchAddGroupSeminorm.le_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\n⊢ Iff (LE.le p q) (LE.le ⇑p ⇑q)","decl":"theorem le_def : p ≤ q ↔ (p : E → ℝ) ≤ q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.lt_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\n⊢ Iff (LT.lt p q) (LT.lt ⇑p ⇑q)","decl":"theorem lt_def : p < q ↔ (p : E → ℝ) < q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.coe_le_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.coe_lt_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.coe_zero","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast]\ntheorem coe_zero : ⇑(0 : NonarchAddGroupSeminorm E) = 0 :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.zero_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\nx : E\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : E) : (0 : NonarchAddGroupSeminorm E) x = 0 :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.coe_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[simp, norm_cast]\ntheorem coe_sup : ⇑(p ⊔ q) = ⇑p ⊔ ⇑q :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.sup_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupSeminorm E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"@[simp]\ntheorem sup_apply (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.add_bddBelow_range_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddCommGroup E\np q : NonarchAddGroupSeminorm E\nx : E\n⊢ BddBelow (Set.range fun y => HAdd.hAdd (p y) (q (HSub.hSub x y)))","decl":"theorem add_bddBelow_range_add {p q : NonarchAddGroupSeminorm E} {x : E} :\n    BddBelow (range fun y => p y + q (x - y)) :=\n  ⟨0, by\n    rintro _ ⟨x, rfl⟩\n    dsimp\n    positivity⟩\n\n"}
{"name":"GroupSeminorm.apply_one","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝¹ : Group E\ninst✝ : DecidableEq E\nx : E\n⊢ Eq (1 x) (ite (Eq x 1) 0 1)","decl":"@[to_additive (attr := simp) existing AddGroupSeminorm.apply_one]\ntheorem apply_one [DecidableEq E] (x : E) : (1 : GroupSeminorm E) x = if x = 1 then 0 else 1 :=\n  rfl\n\n"}
{"name":"GroupSeminorm.instIsScalarTowerOfNNRealOfReal","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nR' : Type u_2\nE : Type u_3\ninst✝⁶ : Group E\ninst✝⁵ : SMul R Real\ninst✝⁴ : SMul R' Real\ninst✝³ : SMul R' NNReal\ninst✝² : IsScalarTower R' NNReal Real\ninst✝¹ : SMul R R'\ninst✝ : IsScalarTower R R' Real\n⊢ IsScalarTower R R' (GroupSeminorm E)","decl":"@[to_additive existing AddGroupSeminorm.isScalarTower]\ninstance [SMul R' ℝ] [SMul R' ℝ≥0] [IsScalarTower R' ℝ≥0 ℝ] [SMul R R'] [IsScalarTower R R' ℝ] :\n    IsScalarTower R R' (GroupSeminorm E) :=\n  ⟨fun r a p => ext fun x => smul_assoc r a <| p x⟩\n\n"}
{"name":"GroupSeminorm.coe_smul","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : Group E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : GroupSeminorm E\n⊢ Eq (⇑(HSMul.hSMul r p)) (HSMul.hSMul r ⇑p)","decl":"@[to_additive (attr := simp, norm_cast) existing AddGroupSeminorm.coe_smul]\ntheorem coe_smul (r : R) (p : GroupSeminorm E) : ⇑(r • p) = r • ⇑p :=\n  rfl\n\n"}
{"name":"GroupSeminorm.smul_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : Group E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : GroupSeminorm E\nx : E\n⊢ Eq ((HSMul.hSMul r p) x) (HSMul.hSMul r (p x))","decl":"@[to_additive (attr := simp) existing AddGroupSeminorm.smul_apply]\ntheorem smul_apply (r : R) (p : GroupSeminorm E) (x : E) : (r • p) x = r • p x :=\n  rfl\n\n"}
{"name":"GroupSeminorm.smul_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : Group E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np q : GroupSeminorm E\n⊢ Eq (HSMul.hSMul r (Max.max p q)) (Max.max (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"@[to_additive existing AddGroupSeminorm.smul_sup]\ntheorem smul_sup (r : R) (p q : GroupSeminorm E) : r • (p ⊔ q) = r • p ⊔ r • q :=\n  have Real.smul_max : ∀ x y : ℝ, r • max x y = max (r • x) (r • y) := fun x y => by\n    simpa only [← smul_eq_mul, ← NNReal.smul_def, smul_one_smul ℝ≥0 r (_ : ℝ)] using\n      mul_max_of_nonneg x y (r • (1 : ℝ≥0) : ℝ≥0).coe_nonneg\n  ext fun _ => Real.smul_max _ _\n\n"}
{"name":"NonarchAddGroupSeminorm.apply_one","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝¹ : AddGroup E\ninst✝ : DecidableEq E\nx : E\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one [DecidableEq E] (x : E) :\n    (1 : NonarchAddGroupSeminorm E) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.instIsScalarTowerOfNNRealOfReal","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nR' : Type u_2\nE : Type u_3\ninst✝⁶ : AddGroup E\ninst✝⁵ : SMul R Real\ninst✝⁴ : SMul R' Real\ninst✝³ : SMul R' NNReal\ninst✝² : IsScalarTower R' NNReal Real\ninst✝¹ : SMul R R'\ninst✝ : IsScalarTower R R' Real\n⊢ IsScalarTower R R' (NonarchAddGroupSeminorm E)","decl":"instance [SMul R' ℝ] [SMul R' ℝ≥0] [IsScalarTower R' ℝ≥0 ℝ] [SMul R R'] [IsScalarTower R R' ℝ] :\n    IsScalarTower R R' (NonarchAddGroupSeminorm E) :=\n  ⟨fun r a p => ext fun x => smul_assoc r a <| p x⟩\n\n"}
{"name":"NonarchAddGroupSeminorm.coe_smul","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : AddGroup E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : NonarchAddGroupSeminorm E\n⊢ Eq (⇑(HSMul.hSMul r p)) (HSMul.hSMul r ⇑p)","decl":"@[simp, norm_cast]\ntheorem coe_smul (r : R) (p : NonarchAddGroupSeminorm E) : ⇑(r • p) = r • ⇑p :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.smul_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : AddGroup E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : NonarchAddGroupSeminorm E\nx : E\n⊢ Eq ((HSMul.hSMul r p) x) (HSMul.hSMul r (p x))","decl":"@[simp]\ntheorem smul_apply (r : R) (p : NonarchAddGroupSeminorm E) (x : E) : (r • p) x = r • p x :=\n  rfl\n\n"}
{"name":"NonarchAddGroupSeminorm.smul_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"R : Type u_1\nE : Type u_3\ninst✝³ : AddGroup E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np q : NonarchAddGroupSeminorm E\n⊢ Eq (HSMul.hSMul r (Max.max p q)) (Max.max (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"theorem smul_sup (r : R) (p q : NonarchAddGroupSeminorm E) : r • (p ⊔ q) = r • p ⊔ r • q :=\n  have Real.smul_max : ∀ x y : ℝ, r • max x y = max (r • x) (r • y) := fun x y => by\n    simpa only [← smul_eq_mul, ← NNReal.smul_def, smul_one_smul ℝ≥0 r (_ : ℝ)] using\n      mul_max_of_nonneg x y (r • (1 : ℝ≥0) : ℝ≥0).coe_nonneg\n  ext fun _ => Real.smul_max _ _\n\n"}
{"name":"GroupNorm.groupNormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\n⊢ GroupNormClass (GroupNorm E) E Real","decl":"@[to_additive]\ninstance groupNormClass : GroupNormClass (GroupNorm E) E ℝ where\n  map_one_eq_zero f := f.map_one'\n  map_mul_le_add f := f.mul_le'\n  map_inv_eq_map f := f.inv'\n  eq_one_of_map_eq_zero f := f.eq_one_of_map_eq_zero' _\n\n"}
{"name":"AddGroupNorm.addGroupNormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\n⊢ AddGroupNormClass (AddGroupNorm E) E Real","decl":"@[to_additive]\ninstance groupNormClass : GroupNormClass (GroupNorm E) E ℝ where\n  map_one_eq_zero f := f.map_one'\n  map_mul_le_add f := f.mul_le'\n  map_inv_eq_map f := f.inv'\n  eq_one_of_map_eq_zero f := f.eq_one_of_map_eq_zero' _\n\n"}
{"name":"AddGroupNorm.toAddGroupSeminorm_eq_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np : AddGroupNorm E\n⊢ Eq ⇑p.toAddGroupSeminorm ⇑p","decl":"@[to_additive (attr := simp)]\ntheorem toGroupSeminorm_eq_coe : ⇑p.toGroupSeminorm = p :=\n  rfl\n\n"}
{"name":"GroupNorm.toGroupSeminorm_eq_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np : GroupNorm E\n⊢ Eq ⇑p.toGroupSeminorm ⇑p","decl":"@[to_additive (attr := simp)]\ntheorem toGroupSeminorm_eq_coe : ⇑p.toGroupSeminorm = p :=\n  rfl\n\n"}
{"name":"AddGroupNorm.ext_iff","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"GroupNorm.ext_iff","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"GroupNorm.ext","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\na✝ : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"AddGroupNorm.ext","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\na✝ : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[to_additive (attr := ext)]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"GroupNorm.le_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Iff (LE.le p q) (LE.le ⇑p ⇑q)","decl":"@[to_additive]\ntheorem le_def : p ≤ q ↔ (p : E → ℝ) ≤ q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupNorm.le_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Iff (LE.le p q) (LE.le ⇑p ⇑q)","decl":"@[to_additive]\ntheorem le_def : p ≤ q ↔ (p : E → ℝ) ≤ q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupNorm.lt_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Iff (LT.lt p q) (LT.lt ⇑p ⇑q)","decl":"@[to_additive]\ntheorem lt_def : p < q ↔ (p : E → ℝ) < q :=\n  Iff.rfl\n\n"}
{"name":"GroupNorm.lt_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Iff (LT.lt p q) (LT.lt ⇑p ⇑q)","decl":"@[to_additive]\ntheorem lt_def : p < q ↔ (p : E → ℝ) < q :=\n  Iff.rfl\n\n"}
{"name":"GroupNorm.coe_le_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_le_coe : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupNorm.coe_le_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_le_coe : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"GroupNorm.coe_lt_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_lt_coe : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupNorm.coe_lt_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_lt_coe : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"AddGroupNorm.coe_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Eq (⇑(HAdd.hAdd p q)) (HAdd.hAdd ⇑p ⇑q)","decl":"@[to_additive (attr := simp)]\ntheorem coe_add : ⇑(p + q) = p + q :=\n  rfl\n\n"}
{"name":"GroupNorm.coe_add","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Eq (⇑(HAdd.hAdd p q)) (HAdd.hAdd ⇑p ⇑q)","decl":"@[to_additive (attr := simp)]\ntheorem coe_add : ⇑(p + q) = p + q :=\n  rfl\n\n"}
{"name":"GroupNorm.add_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\nx : E\n⊢ Eq ((HAdd.hAdd p q) x) (HAdd.hAdd (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet`\n"}
{"name":"AddGroupNorm.add_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\nx : E\n⊢ Eq ((HAdd.hAdd p q) x) (HAdd.hAdd (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem add_apply (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n-- TODO: define `SupSet`\n"}
{"name":"GroupNorm.coe_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sup : ⇑(p ⊔ q) = ⇑p ⊔ ⇑q :=\n  rfl\n\n"}
{"name":"AddGroupNorm.coe_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem coe_sup : ⇑(p ⊔ q) = ⇑p ⊔ ⇑q :=\n  rfl\n\n"}
{"name":"AddGroupNorm.sup_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : AddGroupNorm E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem sup_apply (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"GroupNorm.sup_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : Group E\np q : GroupNorm E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"@[to_additive (attr := simp)]\ntheorem sup_apply (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"AddGroupNorm.apply_one","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝¹ : AddGroup E\ninst✝ : DecidableEq E\nx : E\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one (x : E) : (1 : AddGroupNorm E) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
{"name":"GroupNorm.apply_one","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝¹ : Group E\ninst✝ : DecidableEq E\nx : E\n⊢ Eq (1 x) (ite (Eq x 1) 0 1)","decl":"@[to_additive (attr := simp) existing AddGroupNorm.apply_one]\ntheorem apply_one (x : E) : (1 : GroupNorm E) x = if x = 1 then 0 else 1 :=\n  rfl\n\n"}
{"name":"NonarchAddGroupNorm.nonarchAddGroupNormClass","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\n⊢ NonarchAddGroupNormClass (NonarchAddGroupNorm E) E","decl":"instance nonarchAddGroupNormClass : NonarchAddGroupNormClass (NonarchAddGroupNorm E) E where\n  map_add_le_max f := f.add_le_max'\n  map_zero f := f.map_zero'\n  map_neg_eq_map' f := f.neg'\n  eq_zero_of_map_eq_zero f := f.eq_zero_of_map_eq_zero' _\n\n"}
{"name":"NonarchAddGroupNorm.toNonarchAddGroupSeminorm_eq_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np : NonarchAddGroupNorm E\n⊢ Eq ⇑p.toNonarchAddGroupSeminorm ⇑p","decl":"@[simp]\ntheorem toNonarchAddGroupSeminorm_eq_coe : ⇑p.toNonarchAddGroupSeminorm = p :=\n  rfl\n\n"}
{"name":"NonarchAddGroupNorm.ext","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\na✝ : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"NonarchAddGroupNorm.ext_iff","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext : (∀ x, p x = q x) → p = q :=\n  DFunLike.ext p q\n\n"}
{"name":"NonarchAddGroupNorm.le_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\n⊢ Iff (LE.le p q) (LE.le ⇑p ⇑q)","decl":"theorem le_def : p ≤ q ↔ (p : E → ℝ) ≤ q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupNorm.lt_def","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\n⊢ Iff (LT.lt p q) (LT.lt ⇑p ⇑q)","decl":"theorem lt_def : p < q ↔ (p : E → ℝ) < q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupNorm.coe_le_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupNorm.coe_lt_coe","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"NonarchAddGroupNorm.coe_sup","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[simp, norm_cast]\ntheorem coe_sup : ⇑(p ⊔ q) = ⇑p ⊔ ⇑q :=\n  rfl\n\n"}
{"name":"NonarchAddGroupNorm.sup_apply","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝ : AddGroup E\np q : NonarchAddGroupNorm E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"@[simp]\ntheorem sup_apply (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"NonarchAddGroupNorm.apply_one","module":"Mathlib.Analysis.Normed.Group.Seminorm","initialProofState":"E : Type u_3\ninst✝¹ : AddGroup E\ninst✝ : DecidableEq E\nx : E\n⊢ Eq (1 x) (ite (Eq x 0) 0 1)","decl":"@[simp]\ntheorem apply_one [DecidableEq E] (x : E) :\n    (1 : NonarchAddGroupNorm E) x = if x = 0 then 0 else 1 :=\n  rfl\n\n"}
