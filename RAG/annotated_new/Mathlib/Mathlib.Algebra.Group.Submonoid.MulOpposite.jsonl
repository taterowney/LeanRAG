{"name":"AddSubmonoid.coe_op","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : AddSubmonoid M\n⊢ Eq (↑x.op) (Set.preimage AddOpposite.unop ↑x)","decl":"/-- Pull a submonoid back to an opposite submonoid along `MulOpposite.unop`-/\n@[to_additive (attr := simps) \"Pull an additive submonoid back to an opposite submonoid along\n`AddOpposite.unop`\"]\nprotected def op (x : Submonoid M) : Submonoid Mᵐᵒᵖ where\n  carrier := MulOpposite.unop ⁻¹' x\n  mul_mem' ha hb := x.mul_mem hb ha\n  one_mem' := Submonoid.one_mem' _\n\n"}
{"name":"Submonoid.coe_op","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : Submonoid M\n⊢ Eq (↑x.op) (Set.preimage MulOpposite.unop ↑x)","decl":"/-- Pull a submonoid back to an opposite submonoid along `MulOpposite.unop`-/\n@[to_additive (attr := simps) \"Pull an additive submonoid back to an opposite submonoid along\n`AddOpposite.unop`\"]\nprotected def op (x : Submonoid M) : Submonoid Mᵐᵒᵖ where\n  carrier := MulOpposite.unop ⁻¹' x\n  mul_mem' ha hb := x.mul_mem hb ha\n  one_mem' := Submonoid.one_mem' _\n\n"}
{"name":"Submonoid.mem_op","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : MulOpposite M\nS : Submonoid M\n⊢ Iff (Membership.mem S.op x) (Membership.mem S (MulOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_op {x : Mᵐᵒᵖ} {S : Submonoid M} : x ∈ S.op ↔ x.unop ∈ S := Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_op","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : AddOpposite M\nS : AddSubmonoid M\n⊢ Iff (Membership.mem S.op x) (Membership.mem S (AddOpposite.unop x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_op {x : Mᵐᵒᵖ} {S : Submonoid M} : x ∈ S.op ↔ x.unop ∈ S := Iff.rfl\n\n"}
{"name":"Submonoid.coe_unop","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : Submonoid (MulOpposite M)\n⊢ Eq (↑x.unop) (Set.preimage MulOpposite.op ↑x)","decl":"/-- Pull an opposite submonoid back to a submonoid along `MulOpposite.op`-/\n@[to_additive (attr := simps) \"Pull an opposite additive submonoid back to a submonoid along\n`AddOpposite.op`\"]\nprotected def unop (x : Submonoid Mᵐᵒᵖ) : Submonoid M where\n  carrier := MulOpposite.op ⁻¹' x\n  mul_mem' ha hb := x.mul_mem hb ha\n  one_mem' := Submonoid.one_mem' _\n\n"}
{"name":"AddSubmonoid.coe_unop","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : AddSubmonoid (AddOpposite M)\n⊢ Eq (↑x.unop) (Set.preimage AddOpposite.op ↑x)","decl":"/-- Pull an opposite submonoid back to a submonoid along `MulOpposite.op`-/\n@[to_additive (attr := simps) \"Pull an opposite additive submonoid back to a submonoid along\n`AddOpposite.op`\"]\nprotected def unop (x : Submonoid Mᵐᵒᵖ) : Submonoid M where\n  carrier := MulOpposite.op ⁻¹' x\n  mul_mem' ha hb := x.mul_mem hb ha\n  one_mem' := Submonoid.one_mem' _\n\n"}
{"name":"Submonoid.mem_unop","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : M\nS : Submonoid (MulOpposite M)\n⊢ Iff (Membership.mem S.unop x) (Membership.mem S (MulOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_unop {x : M} {S : Submonoid Mᵐᵒᵖ} : x ∈ S.unop ↔ MulOpposite.op x ∈ S := Iff.rfl\n\n"}
{"name":"AddSubmonoid.mem_unop","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : M\nS : AddSubmonoid (AddOpposite M)\n⊢ Iff (Membership.mem S.unop x) (Membership.mem S (AddOpposite.op x))","decl":"@[to_additive (attr := simp)]\ntheorem mem_unop {x : M} {S : Submonoid Mᵐᵒᵖ} : x ∈ S.unop ↔ MulOpposite.op x ∈ S := Iff.rfl\n\n"}
{"name":"AddSubmonoid.unop_op","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Eq S.op.unop S","decl":"@[to_additive (attr := simp)]\ntheorem unop_op (S : Submonoid M) : S.op.unop = S := rfl\n\n"}
{"name":"Submonoid.unop_op","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Eq S.op.unop S","decl":"@[to_additive (attr := simp)]\ntheorem unop_op (S : Submonoid M) : S.op.unop = S := rfl\n\n"}
{"name":"AddSubmonoid.op_unop","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : AddSubmonoid (AddOpposite M)\n⊢ Eq S.unop.op S","decl":"@[to_additive (attr := simp)]\ntheorem op_unop (S : Submonoid Mᵐᵒᵖ) : S.unop.op = S := rfl\n\n"}
{"name":"Submonoid.op_unop","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Submonoid (MulOpposite M)\n⊢ Eq S.unop.op S","decl":"@[to_additive (attr := simp)]\ntheorem op_unop (S : Submonoid Mᵐᵒᵖ) : S.unop.op = S := rfl\n\n"}
{"name":"AddSubmonoid.op_le_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ : AddSubmonoid M\nS₂ : AddSubmonoid (AddOpposite M)\n⊢ Iff (LE.le S₁.op S₂) (LE.le S₁ S₂.unop)","decl":"@[to_additive]\ntheorem op_le_iff {S₁ : Submonoid M} {S₂ : Submonoid Mᵐᵒᵖ} : S₁.op ≤ S₂ ↔ S₁ ≤ S₂.unop :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Submonoid.op_le_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ : Submonoid M\nS₂ : Submonoid (MulOpposite M)\n⊢ Iff (LE.le S₁.op S₂) (LE.le S₁ S₂.unop)","decl":"@[to_additive]\ntheorem op_le_iff {S₁ : Submonoid M} {S₂ : Submonoid Mᵐᵒᵖ} : S₁.op ≤ S₂ ↔ S₁ ≤ S₂.unop :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"AddSubmonoid.le_op_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ : AddSubmonoid (AddOpposite M)\nS₂ : AddSubmonoid M\n⊢ Iff (LE.le S₁ S₂.op) (LE.le S₁.unop S₂)","decl":"@[to_additive]\ntheorem le_op_iff {S₁ : Submonoid Mᵐᵒᵖ} {S₂ : Submonoid M} : S₁ ≤ S₂.op ↔ S₁.unop ≤ S₂ :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Submonoid.le_op_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ : Submonoid (MulOpposite M)\nS₂ : Submonoid M\n⊢ Iff (LE.le S₁ S₂.op) (LE.le S₁.unop S₂)","decl":"@[to_additive]\ntheorem le_op_iff {S₁ : Submonoid Mᵐᵒᵖ} {S₂ : Submonoid M} : S₁ ≤ S₂.op ↔ S₁.unop ≤ S₂ :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"AddSubmonoid.op_le_op_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ S₂ : AddSubmonoid M\n⊢ Iff (LE.le S₁.op S₂.op) (LE.le S₁ S₂)","decl":"@[to_additive (attr := simp)]\ntheorem op_le_op_iff {S₁ S₂ : Submonoid M} : S₁.op ≤ S₂.op ↔ S₁ ≤ S₂ :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Submonoid.op_le_op_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ S₂ : Submonoid M\n⊢ Iff (LE.le S₁.op S₂.op) (LE.le S₁ S₂)","decl":"@[to_additive (attr := simp)]\ntheorem op_le_op_iff {S₁ S₂ : Submonoid M} : S₁.op ≤ S₂.op ↔ S₁ ≤ S₂ :=\n  MulOpposite.op_surjective.forall\n\n"}
{"name":"Submonoid.unop_le_unop_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ S₂ : Submonoid (MulOpposite M)\n⊢ Iff (LE.le S₁.unop S₂.unop) (LE.le S₁ S₂)","decl":"@[to_additive (attr := simp)]\ntheorem unop_le_unop_iff {S₁ S₂ : Submonoid Mᵐᵒᵖ} : S₁.unop ≤ S₂.unop ↔ S₁ ≤ S₂ :=\n  MulOpposite.unop_surjective.forall\n\n"}
{"name":"AddSubmonoid.unop_le_unop_iff","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ S₂ : AddSubmonoid (AddOpposite M)\n⊢ Iff (LE.le S₁.unop S₂.unop) (LE.le S₁ S₂)","decl":"@[to_additive (attr := simp)]\ntheorem unop_le_unop_iff {S₁ S₂ : Submonoid Mᵐᵒᵖ} : S₁.unop ≤ S₂.unop ↔ S₁ ≤ S₂ :=\n  MulOpposite.unop_surjective.forall\n\n"}
{"name":"Submonoid.opEquiv_apply","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : Submonoid M\n⊢ Eq (Submonoid.opEquiv x) x.op","decl":"/-- A submonoid `H` of `G` determines a submonoid `H.op` of the opposite group `Gᵐᵒᵖ`. -/\n@[to_additive (attr := simps) \"A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `Gᵐᵒᵖ`.\"]\ndef opEquiv : Submonoid M ≃o Submonoid Mᵐᵒᵖ where\n  toFun := Submonoid.op\n  invFun := Submonoid.unop\n  left_inv := unop_op\n  right_inv := op_unop\n  map_rel_iff' := op_le_op_iff\n\n"}
{"name":"AddSubmonoid.opEquiv_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : AddSubmonoid (AddOpposite M)\n⊢ Eq ((RelIso.symm AddSubmonoid.opEquiv) x) x.unop","decl":"/-- A submonoid `H` of `G` determines a submonoid `H.op` of the opposite group `Gᵐᵒᵖ`. -/\n@[to_additive (attr := simps) \"A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `Gᵐᵒᵖ`.\"]\ndef opEquiv : Submonoid M ≃o Submonoid Mᵐᵒᵖ where\n  toFun := Submonoid.op\n  invFun := Submonoid.unop\n  left_inv := unop_op\n  right_inv := op_unop\n  map_rel_iff' := op_le_op_iff\n\n"}
{"name":"Submonoid.opEquiv_symm_apply","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nx : Submonoid (MulOpposite M)\n⊢ Eq ((RelIso.symm Submonoid.opEquiv) x) x.unop","decl":"/-- A submonoid `H` of `G` determines a submonoid `H.op` of the opposite group `Gᵐᵒᵖ`. -/\n@[to_additive (attr := simps) \"A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `Gᵐᵒᵖ`.\"]\ndef opEquiv : Submonoid M ≃o Submonoid Mᵐᵒᵖ where\n  toFun := Submonoid.op\n  invFun := Submonoid.unop\n  left_inv := unop_op\n  right_inv := op_unop\n  map_rel_iff' := op_le_op_iff\n\n"}
{"name":"AddSubmonoid.opEquiv_apply","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nx : AddSubmonoid M\n⊢ Eq (AddSubmonoid.opEquiv x) x.op","decl":"/-- A submonoid `H` of `G` determines a submonoid `H.op` of the opposite group `Gᵐᵒᵖ`. -/\n@[to_additive (attr := simps) \"A additive submonoid `H` of `G` determines an additive submonoid\n`H.op` of the opposite group `Gᵐᵒᵖ`.\"]\ndef opEquiv : Submonoid M ≃o Submonoid Mᵐᵒᵖ where\n  toFun := Submonoid.op\n  invFun := Submonoid.unop\n  left_inv := unop_op\n  right_inv := op_unop\n  map_rel_iff' := op_le_op_iff\n\n"}
{"name":"Submonoid.op_injective","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Function.Injective Submonoid.op","decl":"@[to_additive]\ntheorem op_injective : (@Submonoid.op M _).Injective := opEquiv.injective\n\n"}
{"name":"AddSubmonoid.op_injective","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Function.Injective AddSubmonoid.op","decl":"@[to_additive]\ntheorem op_injective : (@Submonoid.op M _).Injective := opEquiv.injective\n\n"}
{"name":"Submonoid.unop_injective","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Function.Injective Submonoid.unop","decl":"@[to_additive]\ntheorem unop_injective : (@Submonoid.unop M _).Injective := opEquiv.symm.injective\n\n"}
{"name":"AddSubmonoid.unop_injective","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Function.Injective AddSubmonoid.unop","decl":"@[to_additive]\ntheorem unop_injective : (@Submonoid.unop M _).Injective := opEquiv.symm.injective\n\n"}
{"name":"Submonoid.op_inj","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS T : Submonoid M\n⊢ Iff (Eq S.op T.op) (Eq S T)","decl":"@[to_additive (attr := simp)]\ntheorem op_inj {S T : Submonoid M} : S.op = T.op ↔ S = T := opEquiv.eq_iff_eq\n\n"}
{"name":"AddSubmonoid.op_inj","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS T : AddSubmonoid M\n⊢ Iff (Eq S.op T.op) (Eq S T)","decl":"@[to_additive (attr := simp)]\ntheorem op_inj {S T : Submonoid M} : S.op = T.op ↔ S = T := opEquiv.eq_iff_eq\n\n"}
{"name":"Submonoid.unop_inj","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS T : Submonoid (MulOpposite M)\n⊢ Iff (Eq S.unop T.unop) (Eq S T)","decl":"@[to_additive (attr := simp)]\ntheorem unop_inj {S T : Submonoid Mᵐᵒᵖ} : S.unop = T.unop ↔ S = T := opEquiv.symm.eq_iff_eq\n\n"}
{"name":"AddSubmonoid.unop_inj","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS T : AddSubmonoid (AddOpposite M)\n⊢ Iff (Eq S.unop T.unop) (Eq S T)","decl":"@[to_additive (attr := simp)]\ntheorem unop_inj {S T : Submonoid Mᵐᵒᵖ} : S.unop = T.unop ↔ S = T := opEquiv.symm.eq_iff_eq\n\n"}
{"name":"Submonoid.op_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Eq Bot.bot.op Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem op_bot : (⊥ : Submonoid M).op = ⊥ := opEquiv.map_bot\n\n"}
{"name":"AddSubmonoid.op_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Eq Bot.bot.op Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem op_bot : (⊥ : Submonoid M).op = ⊥ := opEquiv.map_bot\n\n"}
{"name":"AddSubmonoid.op_eq_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Iff (Eq S.op Bot.bot) (Eq S Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem op_eq_bot {S : Submonoid M} : S.op = ⊥ ↔ S = ⊥ := op_injective.eq_iff' op_bot\n\n"}
{"name":"Submonoid.op_eq_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Iff (Eq S.op Bot.bot) (Eq S Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem op_eq_bot {S : Submonoid M} : S.op = ⊥ ↔ S = ⊥ := op_injective.eq_iff' op_bot\n\n"}
{"name":"AddSubmonoid.unop_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Eq Bot.bot.unop Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem unop_bot : (⊥ : Submonoid Mᵐᵒᵖ).unop = ⊥ := opEquiv.symm.map_bot\n\n"}
{"name":"Submonoid.unop_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Eq Bot.bot.unop Bot.bot","decl":"@[to_additive (attr := simp)]\ntheorem unop_bot : (⊥ : Submonoid Mᵐᵒᵖ).unop = ⊥ := opEquiv.symm.map_bot\n\n"}
{"name":"Submonoid.unop_eq_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Submonoid (MulOpposite M)\n⊢ Iff (Eq S.unop Bot.bot) (Eq S Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem unop_eq_bot {S : Submonoid Mᵐᵒᵖ} : S.unop = ⊥ ↔ S = ⊥ := unop_injective.eq_iff' unop_bot\n\n"}
{"name":"AddSubmonoid.unop_eq_bot","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : AddSubmonoid (AddOpposite M)\n⊢ Iff (Eq S.unop Bot.bot) (Eq S Bot.bot)","decl":"@[to_additive (attr := simp)]\ntheorem unop_eq_bot {S : Submonoid Mᵐᵒᵖ} : S.unop = ⊥ ↔ S = ⊥ := unop_injective.eq_iff' unop_bot\n\n"}
{"name":"Submonoid.op_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Eq Top.top.op Top.top","decl":"@[to_additive (attr := simp)]\ntheorem op_top : (⊤ : Submonoid M).op = ⊤ := rfl\n\n"}
{"name":"AddSubmonoid.op_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Eq Top.top.op Top.top","decl":"@[to_additive (attr := simp)]\ntheorem op_top : (⊤ : Submonoid M).op = ⊤ := rfl\n\n"}
{"name":"Submonoid.op_eq_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Submonoid M\n⊢ Iff (Eq S.op Top.top) (Eq S Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem op_eq_top {S : Submonoid M} : S.op = ⊤ ↔ S = ⊤ := op_injective.eq_iff' op_top\n\n"}
{"name":"AddSubmonoid.op_eq_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : AddSubmonoid M\n⊢ Iff (Eq S.op Top.top) (Eq S Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem op_eq_top {S : Submonoid M} : S.op = ⊤ ↔ S = ⊤ := op_injective.eq_iff' op_top\n\n"}
{"name":"Submonoid.unop_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\n⊢ Eq Top.top.unop Top.top","decl":"@[to_additive (attr := simp)]\ntheorem unop_top : (⊤ : Submonoid Mᵐᵒᵖ).unop = ⊤ := rfl\n\n"}
{"name":"AddSubmonoid.unop_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\n⊢ Eq Top.top.unop Top.top","decl":"@[to_additive (attr := simp)]\ntheorem unop_top : (⊤ : Submonoid Mᵐᵒᵖ).unop = ⊤ := rfl\n\n"}
{"name":"AddSubmonoid.unop_eq_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : AddSubmonoid (AddOpposite M)\n⊢ Iff (Eq S.unop Top.top) (Eq S Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem unop_eq_top {S : Submonoid Mᵐᵒᵖ} : S.unop = ⊤ ↔ S = ⊤ := unop_injective.eq_iff' unop_top\n\n"}
{"name":"Submonoid.unop_eq_top","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Submonoid (MulOpposite M)\n⊢ Iff (Eq S.unop Top.top) (Eq S Top.top)","decl":"@[to_additive (attr := simp)]\ntheorem unop_eq_top {S : Submonoid Mᵐᵒᵖ} : S.unop = ⊤ ↔ S = ⊤ := unop_injective.eq_iff' unop_top\n\n"}
{"name":"AddSubmonoid.op_sup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ S₂ : AddSubmonoid M\n⊢ Eq (Max.max S₁ S₂).op (Max.max S₁.op S₂.op)","decl":"@[to_additive]\ntheorem op_sup (S₁ S₂ : Submonoid M) : (S₁ ⊔ S₂).op = S₁.op ⊔ S₂.op :=\n  opEquiv.map_sup _ _\n\n"}
{"name":"Submonoid.op_sup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ S₂ : Submonoid M\n⊢ Eq (Max.max S₁ S₂).op (Max.max S₁.op S₂.op)","decl":"@[to_additive]\ntheorem op_sup (S₁ S₂ : Submonoid M) : (S₁ ⊔ S₂).op = S₁.op ⊔ S₂.op :=\n  opEquiv.map_sup _ _\n\n"}
{"name":"AddSubmonoid.unop_sup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ S₂ : AddSubmonoid (AddOpposite M)\n⊢ Eq (Max.max S₁ S₂).unop (Max.max S₁.unop S₂.unop)","decl":"@[to_additive]\ntheorem unop_sup (S₁ S₂ : Submonoid Mᵐᵒᵖ) : (S₁ ⊔ S₂).unop = S₁.unop ⊔ S₂.unop :=\n  opEquiv.symm.map_sup _ _\n\n"}
{"name":"Submonoid.unop_sup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ S₂ : Submonoid (MulOpposite M)\n⊢ Eq (Max.max S₁ S₂).unop (Max.max S₁.unop S₂.unop)","decl":"@[to_additive]\ntheorem unop_sup (S₁ S₂ : Submonoid Mᵐᵒᵖ) : (S₁ ⊔ S₂).unop = S₁.unop ⊔ S₂.unop :=\n  opEquiv.symm.map_sup _ _\n\n"}
{"name":"AddSubmonoid.op_inf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ S₂ : AddSubmonoid M\n⊢ Eq (Min.min S₁ S₂).op (Min.min S₁.op S₂.op)","decl":"@[to_additive]\ntheorem op_inf (S₁ S₂ : Submonoid M) : (S₁ ⊓ S₂).op = S₁.op ⊓ S₂.op := rfl\n\n"}
{"name":"Submonoid.op_inf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ S₂ : Submonoid M\n⊢ Eq (Min.min S₁ S₂).op (Min.min S₁.op S₂.op)","decl":"@[to_additive]\ntheorem op_inf (S₁ S₂ : Submonoid M) : (S₁ ⊓ S₂).op = S₁.op ⊓ S₂.op := rfl\n\n"}
{"name":"AddSubmonoid.unop_inf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS₁ S₂ : AddSubmonoid (AddOpposite M)\n⊢ Eq (Min.min S₁ S₂).unop (Min.min S₁.unop S₂.unop)","decl":"@[to_additive]\ntheorem unop_inf (S₁ S₂ : Submonoid Mᵐᵒᵖ) : (S₁ ⊓ S₂).unop = S₁.unop ⊓ S₂.unop := rfl\n\n"}
{"name":"Submonoid.unop_inf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS₁ S₂ : Submonoid (MulOpposite M)\n⊢ Eq (Min.min S₁ S₂).unop (Min.min S₁.unop S₂.unop)","decl":"@[to_additive]\ntheorem unop_inf (S₁ S₂ : Submonoid Mᵐᵒᵖ) : (S₁ ⊓ S₂).unop = S₁.unop ⊓ S₂.unop := rfl\n\n"}
{"name":"AddSubmonoid.op_sSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\n⊢ Eq (SupSet.sSup S).op (SupSet.sSup (Set.preimage AddSubmonoid.unop S))","decl":"@[to_additive]\ntheorem op_sSup (S : Set (Submonoid M)) : (sSup S).op = sSup (.unop ⁻¹' S) :=\n  opEquiv.map_sSup_eq_sSup_symm_preimage _\n\n"}
{"name":"Submonoid.op_sSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\n⊢ Eq (SupSet.sSup S).op (SupSet.sSup (Set.preimage Submonoid.unop S))","decl":"@[to_additive]\ntheorem op_sSup (S : Set (Submonoid M)) : (sSup S).op = sSup (.unop ⁻¹' S) :=\n  opEquiv.map_sSup_eq_sSup_symm_preimage _\n\n"}
{"name":"AddSubmonoid.unop_sSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid (AddOpposite M))\n⊢ Eq (SupSet.sSup S).unop (SupSet.sSup (Set.preimage AddSubmonoid.op S))","decl":"@[to_additive]\ntheorem unop_sSup (S : Set (Submonoid Mᵐᵒᵖ)) : (sSup S).unop = sSup (.op ⁻¹' S) :=\n  opEquiv.symm.map_sSup_eq_sSup_symm_preimage _\n\n"}
{"name":"Submonoid.unop_sSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Set (Submonoid (MulOpposite M))\n⊢ Eq (SupSet.sSup S).unop (SupSet.sSup (Set.preimage Submonoid.op S))","decl":"@[to_additive]\ntheorem unop_sSup (S : Set (Submonoid Mᵐᵒᵖ)) : (sSup S).unop = sSup (.op ⁻¹' S) :=\n  opEquiv.symm.map_sSup_eq_sSup_symm_preimage _\n\n"}
{"name":"Submonoid.op_sInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Set (Submonoid M)\n⊢ Eq (InfSet.sInf S).op (InfSet.sInf (Set.preimage Submonoid.unop S))","decl":"@[to_additive]\ntheorem op_sInf (S : Set (Submonoid M)) : (sInf S).op = sInf (.unop ⁻¹' S) :=\n  opEquiv.map_sInf_eq_sInf_symm_preimage _\n\n"}
{"name":"AddSubmonoid.op_sInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid M)\n⊢ Eq (InfSet.sInf S).op (InfSet.sInf (Set.preimage AddSubmonoid.unop S))","decl":"@[to_additive]\ntheorem op_sInf (S : Set (Submonoid M)) : (sInf S).op = sInf (.unop ⁻¹' S) :=\n  opEquiv.map_sInf_eq_sInf_symm_preimage _\n\n"}
{"name":"Submonoid.unop_sInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nS : Set (Submonoid (MulOpposite M))\n⊢ Eq (InfSet.sInf S).unop (InfSet.sInf (Set.preimage Submonoid.op S))","decl":"@[to_additive]\ntheorem unop_sInf (S : Set (Submonoid Mᵐᵒᵖ)) : (sInf S).unop = sInf (.op ⁻¹' S) :=\n  opEquiv.symm.map_sInf_eq_sInf_symm_preimage _\n\n"}
{"name":"AddSubmonoid.unop_sInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nS : Set (AddSubmonoid (AddOpposite M))\n⊢ Eq (InfSet.sInf S).unop (InfSet.sInf (Set.preimage AddSubmonoid.op S))","decl":"@[to_additive]\ntheorem unop_sInf (S : Set (Submonoid Mᵐᵒᵖ)) : (sInf S).unop = sInf (.op ⁻¹' S) :=\n  opEquiv.symm.map_sInf_eq_sInf_symm_preimage _\n\n"}
{"name":"AddSubmonoid.op_iSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : AddZeroClass M\nS : ι → AddSubmonoid M\n⊢ Eq (iSup S).op (iSup fun i => (S i).op)","decl":"@[to_additive]\ntheorem op_iSup (S : ι → Submonoid M) : (iSup S).op = ⨆ i, (S i).op := opEquiv.map_iSup _\n\n"}
{"name":"Submonoid.op_iSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : MulOneClass M\nS : ι → Submonoid M\n⊢ Eq (iSup S).op (iSup fun i => (S i).op)","decl":"@[to_additive]\ntheorem op_iSup (S : ι → Submonoid M) : (iSup S).op = ⨆ i, (S i).op := opEquiv.map_iSup _\n\n"}
{"name":"AddSubmonoid.unop_iSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : AddZeroClass M\nS : ι → AddSubmonoid (AddOpposite M)\n⊢ Eq (iSup S).unop (iSup fun i => (S i).unop)","decl":"@[to_additive]\ntheorem unop_iSup (S : ι → Submonoid Mᵐᵒᵖ) : (iSup S).unop = ⨆ i, (S i).unop :=\n  opEquiv.symm.map_iSup _\n\n"}
{"name":"Submonoid.unop_iSup","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : MulOneClass M\nS : ι → Submonoid (MulOpposite M)\n⊢ Eq (iSup S).unop (iSup fun i => (S i).unop)","decl":"@[to_additive]\ntheorem unop_iSup (S : ι → Submonoid Mᵐᵒᵖ) : (iSup S).unop = ⨆ i, (S i).unop :=\n  opEquiv.symm.map_iSup _\n\n"}
{"name":"Submonoid.op_iInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : MulOneClass M\nS : ι → Submonoid M\n⊢ Eq (iInf S).op (iInf fun i => (S i).op)","decl":"@[to_additive]\ntheorem op_iInf (S : ι → Submonoid M) : (iInf S).op = ⨅ i, (S i).op := opEquiv.map_iInf _\n\n"}
{"name":"AddSubmonoid.op_iInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : AddZeroClass M\nS : ι → AddSubmonoid M\n⊢ Eq (iInf S).op (iInf fun i => (S i).op)","decl":"@[to_additive]\ntheorem op_iInf (S : ι → Submonoid M) : (iInf S).op = ⨅ i, (S i).op := opEquiv.map_iInf _\n\n"}
{"name":"AddSubmonoid.unop_iInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : AddZeroClass M\nS : ι → AddSubmonoid (AddOpposite M)\n⊢ Eq (iInf S).unop (iInf fun i => (S i).unop)","decl":"@[to_additive]\ntheorem unop_iInf (S : ι → Submonoid Mᵐᵒᵖ) : (iInf S).unop = ⨅ i, (S i).unop :=\n  opEquiv.symm.map_iInf _\n\n"}
{"name":"Submonoid.unop_iInf","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"ι : Sort u_1\nM : Type u_2\ninst✝ : MulOneClass M\nS : ι → Submonoid (MulOpposite M)\n⊢ Eq (iInf S).unop (iInf fun i => (S i).unop)","decl":"@[to_additive]\ntheorem unop_iInf (S : ι → Submonoid Mᵐᵒᵖ) : (iInf S).unop = ⨅ i, (S i).unop :=\n  opEquiv.symm.map_iInf _\n\n"}
{"name":"AddSubmonoid.op_closure","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\ns : Set M\n⊢ Eq (AddSubmonoid.closure s).op (AddSubmonoid.closure (Set.preimage AddOpposite.unop s))","decl":"@[to_additive]\ntheorem op_closure (s : Set M) : (closure s).op = closure (MulOpposite.unop ⁻¹' s) := by\n  simp_rw [closure, op_sInf, Set.preimage_setOf_eq, Submonoid.coe_unop]\n  congr with a\n  exact MulOpposite.unop_surjective.forall\n\n"}
{"name":"Submonoid.op_closure","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\ns : Set M\n⊢ Eq (Submonoid.closure s).op (Submonoid.closure (Set.preimage MulOpposite.unop s))","decl":"@[to_additive]\ntheorem op_closure (s : Set M) : (closure s).op = closure (MulOpposite.unop ⁻¹' s) := by\n  simp_rw [closure, op_sInf, Set.preimage_setOf_eq, Submonoid.coe_unop]\n  congr with a\n  exact MulOpposite.unop_surjective.forall\n\n"}
{"name":"Submonoid.unop_closure","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\ns : Set (MulOpposite M)\n⊢ Eq (Submonoid.closure s).unop (Submonoid.closure (Set.preimage MulOpposite.op s))","decl":"@[to_additive]\ntheorem unop_closure (s : Set Mᵐᵒᵖ) : (closure s).unop = closure (MulOpposite.op ⁻¹' s) := by\n  rw [← op_inj, op_unop, op_closure]\n  simp_rw [Set.preimage_preimage, MulOpposite.op_unop, Set.preimage_id']\n\n"}
{"name":"AddSubmonoid.unop_closure","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\ns : Set (AddOpposite M)\n⊢ Eq (AddSubmonoid.closure s).unop (AddSubmonoid.closure (Set.preimage AddOpposite.op s))","decl":"@[to_additive]\ntheorem unop_closure (s : Set Mᵐᵒᵖ) : (closure s).unop = closure (MulOpposite.op ⁻¹' s) := by\n  rw [← op_inj, op_unop, op_closure]\n  simp_rw [Set.preimage_preimage, MulOpposite.op_unop, Set.preimage_id']\n\n"}
{"name":"AddSubmonoid.equivOp_symm_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nH : AddSubmonoid M\nb : Subtype fun b => Membership.mem H.op b\n⊢ Eq (↑(H.equivOp.symm b)) (AddOpposite.unop ↑b)","decl":"/-- Bijection between a submonoid `H` and its opposite. -/\n@[to_additive (attr := simps!) \"Bijection between an additive submonoid `H` and its opposite.\"]\ndef equivOp (H : Submonoid M) : H ≃ H.op :=\n  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl\n\n"}
{"name":"Submonoid.equivOp_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nH : Submonoid M\na : Subtype fun a => Membership.mem H a\n⊢ Eq (↑(H.equivOp a)) (MulOpposite.op ↑a)","decl":"/-- Bijection between a submonoid `H` and its opposite. -/\n@[to_additive (attr := simps!) \"Bijection between an additive submonoid `H` and its opposite.\"]\ndef equivOp (H : Submonoid M) : H ≃ H.op :=\n  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl\n\n"}
{"name":"Submonoid.equivOp_symm_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : MulOneClass M\nH : Submonoid M\nb : Subtype fun b => Membership.mem H.op b\n⊢ Eq (↑(H.equivOp.symm b)) (MulOpposite.unop ↑b)","decl":"/-- Bijection between a submonoid `H` and its opposite. -/\n@[to_additive (attr := simps!) \"Bijection between an additive submonoid `H` and its opposite.\"]\ndef equivOp (H : Submonoid M) : H ≃ H.op :=\n  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl\n\n"}
{"name":"AddSubmonoid.equivOp_apply_coe","module":"Mathlib.Algebra.Group.Submonoid.MulOpposite","initialProofState":"M : Type u_2\ninst✝ : AddZeroClass M\nH : AddSubmonoid M\na : Subtype fun a => Membership.mem H a\n⊢ Eq (↑(H.equivOp a)) (AddOpposite.op ↑a)","decl":"/-- Bijection between a submonoid `H` and its opposite. -/\n@[to_additive (attr := simps!) \"Bijection between an additive submonoid `H` and its opposite.\"]\ndef equivOp (H : Submonoid M) : H ≃ H.op :=\n  MulOpposite.opEquiv.subtypeEquiv fun _ => Iff.rfl\n\n"}
