{"name":"IsWeakUpperModularLattice.covBy_sup_of_inf_covBy_covBy","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : IsWeakUpperModularLattice α\na b : α\na✝¹ : CovBy (Min.min a b) a\na✝ : CovBy (Min.min a b) b\n⊢ CovBy a (Max.max a b)","decl":"/-- A weakly upper modular lattice is a lattice where `a ⊔ b` covers `a` and `b` if `a` and `b` both\ncover `a ⊓ b`. -/\nclass IsWeakUpperModularLattice (α : Type*) [Lattice α] : Prop where\n/-- `a ⊔ b` covers `a` and `b` if `a` and `b` both cover `a ⊓ b`. -/\n  covBy_sup_of_inf_covBy_covBy {a b : α} : a ⊓ b ⋖ a → a ⊓ b ⋖ b → a ⋖ a ⊔ b\n\n"}
{"name":"IsWeakLowerModularLattice.inf_covBy_of_covBy_covBy_sup","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : IsWeakLowerModularLattice α\na b : α\na✝¹ : CovBy a (Max.max a b)\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) a","decl":"/-- A weakly lower modular lattice is a lattice where `a` and `b` cover `a ⊓ b` if `a ⊔ b` covers\nboth `a` and `b`. -/\nclass IsWeakLowerModularLattice (α : Type*) [Lattice α] : Prop where\n/-- `a` and `b` cover `a ⊓ b` if `a ⊔ b` covers both `a` and `b` -/\n  inf_covBy_of_covBy_covBy_sup {a b : α} : a ⋖ a ⊔ b → b ⋖ a ⊔ b → a ⊓ b ⋖ a\n\n"}
{"name":"IsUpperModularLattice.covBy_sup_of_inf_covBy","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : IsUpperModularLattice α\na b : α\na✝ : CovBy (Min.min a b) a\n⊢ CovBy b (Max.max a b)","decl":"/-- An upper modular lattice, aka semimodular lattice, is a lattice where `a ⊔ b` covers `a` and `b`\nif either `a` or `b` covers `a ⊓ b`. -/\nclass IsUpperModularLattice (α : Type*) [Lattice α] : Prop where\n/-- `a ⊔ b` covers `a` and `b` if either `a` or `b` covers `a ⊓ b` -/\n  covBy_sup_of_inf_covBy {a b : α} : a ⊓ b ⋖ a → b ⋖ a ⊔ b\n\n"}
{"name":"IsLowerModularLattice.inf_covBy_of_covBy_sup","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : IsLowerModularLattice α\na b : α\na✝ : CovBy a (Max.max a b)\n⊢ CovBy (Min.min a b) b","decl":"/-- A lower modular lattice is a lattice where `a` and `b` both cover `a ⊓ b` if `a ⊔ b` covers\neither `a` or `b`. -/\nclass IsLowerModularLattice (α : Type*) [Lattice α] : Prop where\n/-- `a` and `b` both cover `a ⊓ b` if `a ⊔ b` covers either `a` or `b` -/\n  inf_covBy_of_covBy_sup {a b : α} : a ⋖ a ⊔ b → a ⊓ b ⋖ b\n\n"}
{"name":"IsModularLattice.sup_inf_le_assoc_of_le","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_2\ninst✝ : Lattice α\nself : IsModularLattice α\nx y z : α\na✝ : LE.le x z\n⊢ LE.le (Min.min (Max.max x y) z) (Max.max x (Min.min y z))","decl":"/-- A modular lattice is one with a limited associativity between `⊓` and `⊔`. -/\nclass IsModularLattice (α : Type*) [Lattice α] : Prop where\n/-- Whenever `x ≤ z`, then for any `y`, `(x ⊔ y) ⊓ z ≤ x ⊔ (y ⊓ z)`  -/\n  sup_inf_le_assoc_of_le : ∀ {x : α} (y : α) {z : α}, x ≤ z → (x ⊔ y) ⊓ z ≤ x ⊔ y ⊓ z\n\n"}
{"name":"covBy_sup_of_inf_covBy_of_inf_covBy_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakUpperModularLattice α\na b : α\na✝¹ : CovBy (Min.min a b) a\na✝ : CovBy (Min.min a b) b\n⊢ CovBy a (Max.max a b)","decl":"theorem covBy_sup_of_inf_covBy_of_inf_covBy_left : a ⊓ b ⋖ a → a ⊓ b ⋖ b → a ⋖ a ⊔ b :=\n  IsWeakUpperModularLattice.covBy_sup_of_inf_covBy_covBy\n\n"}
{"name":"covBy_sup_of_inf_covBy_of_inf_covBy_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakUpperModularLattice α\na b : α\na✝¹ : CovBy (Min.min a b) a\na✝ : CovBy (Min.min a b) b\n⊢ CovBy b (Max.max a b)","decl":"theorem covBy_sup_of_inf_covBy_of_inf_covBy_right : a ⊓ b ⋖ a → a ⊓ b ⋖ b → b ⋖ a ⊔ b := by\n  rw [inf_comm, sup_comm]\n  exact fun ha hb => covBy_sup_of_inf_covBy_of_inf_covBy_left hb ha\n\n"}
{"name":"CovBy.sup_of_inf_of_inf_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakUpperModularLattice α\na b : α\na✝¹ : CovBy (Min.min a b) a\na✝ : CovBy (Min.min a b) b\n⊢ CovBy a (Max.max a b)","decl":"alias CovBy.sup_of_inf_of_inf_left := covBy_sup_of_inf_covBy_of_inf_covBy_left\n\n"}
{"name":"CovBy.sup_of_inf_of_inf_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakUpperModularLattice α\na b : α\na✝¹ : CovBy (Min.min a b) a\na✝ : CovBy (Min.min a b) b\n⊢ CovBy b (Max.max a b)","decl":"alias CovBy.sup_of_inf_of_inf_right := covBy_sup_of_inf_covBy_of_inf_covBy_right\n\n"}
{"name":"instIsWeakLowerModularLatticeOrderDual","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakUpperModularLattice α\n⊢ IsWeakLowerModularLattice (OrderDual α)","decl":"instance : IsWeakLowerModularLattice (OrderDual α) :=\n  ⟨fun ha hb => (ha.ofDual.sup_of_inf_of_inf_left hb.ofDual).toDual⟩\n\n"}
{"name":"inf_covBy_of_covBy_sup_of_covBy_sup_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakLowerModularLattice α\na b : α\na✝¹ : CovBy a (Max.max a b)\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) a","decl":"theorem inf_covBy_of_covBy_sup_of_covBy_sup_left : a ⋖ a ⊔ b → b ⋖ a ⊔ b → a ⊓ b ⋖ a :=\n  IsWeakLowerModularLattice.inf_covBy_of_covBy_covBy_sup\n\n"}
{"name":"inf_covBy_of_covBy_sup_of_covBy_sup_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakLowerModularLattice α\na b : α\na✝¹ : CovBy a (Max.max a b)\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) b","decl":"theorem inf_covBy_of_covBy_sup_of_covBy_sup_right : a ⋖ a ⊔ b → b ⋖ a ⊔ b → a ⊓ b ⋖ b := by\n  rw [sup_comm, inf_comm]\n  exact fun ha hb => inf_covBy_of_covBy_sup_of_covBy_sup_left hb ha\n\n"}
{"name":"CovBy.inf_of_sup_of_sup_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakLowerModularLattice α\na b : α\na✝¹ : CovBy a (Max.max a b)\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) a","decl":"alias CovBy.inf_of_sup_of_sup_left := inf_covBy_of_covBy_sup_of_covBy_sup_left\n\n"}
{"name":"CovBy.inf_of_sup_of_sup_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakLowerModularLattice α\na b : α\na✝¹ : CovBy a (Max.max a b)\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) b","decl":"alias CovBy.inf_of_sup_of_sup_right := inf_covBy_of_covBy_sup_of_covBy_sup_right\n\n"}
{"name":"instIsWeakUpperModularLatticeOrderDual","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsWeakLowerModularLattice α\n⊢ IsWeakUpperModularLattice (OrderDual α)","decl":"instance : IsWeakUpperModularLattice (OrderDual α) :=\n  ⟨fun ha hb => (ha.ofDual.inf_of_sup_of_sup_left hb.ofDual).toDual⟩\n\n"}
{"name":"covBy_sup_of_inf_covBy_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsUpperModularLattice α\na b : α\na✝ : CovBy (Min.min a b) a\n⊢ CovBy b (Max.max a b)","decl":"theorem covBy_sup_of_inf_covBy_left : a ⊓ b ⋖ a → b ⋖ a ⊔ b :=\n  IsUpperModularLattice.covBy_sup_of_inf_covBy\n\n"}
{"name":"covBy_sup_of_inf_covBy_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsUpperModularLattice α\na b : α\na✝ : CovBy (Min.min a b) b\n⊢ CovBy a (Max.max a b)","decl":"theorem covBy_sup_of_inf_covBy_right : a ⊓ b ⋖ b → a ⋖ a ⊔ b := by\n  rw [sup_comm, inf_comm]\n  exact covBy_sup_of_inf_covBy_left\n\n"}
{"name":"CovBy.sup_of_inf_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsUpperModularLattice α\na b : α\na✝ : CovBy (Min.min a b) a\n⊢ CovBy b (Max.max a b)","decl":"alias CovBy.sup_of_inf_left := covBy_sup_of_inf_covBy_left\n\n"}
{"name":"CovBy.sup_of_inf_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsUpperModularLattice α\na b : α\na✝ : CovBy (Min.min a b) b\n⊢ CovBy a (Max.max a b)","decl":"alias CovBy.sup_of_inf_right := covBy_sup_of_inf_covBy_right\n\n-- See note [lower instance priority]\n"}
{"name":"IsUpperModularLattice.to_isWeakUpperModularLattice","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsUpperModularLattice α\n⊢ IsWeakUpperModularLattice α","decl":"instance (priority := 100) IsUpperModularLattice.to_isWeakUpperModularLattice :\n    IsWeakUpperModularLattice α :=\n  ⟨fun _ => CovBy.sup_of_inf_right⟩\n\n"}
{"name":"instIsLowerModularLatticeOrderDual","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsUpperModularLattice α\n⊢ IsLowerModularLattice (OrderDual α)","decl":"instance : IsLowerModularLattice (OrderDual α) :=\n  ⟨fun h => h.ofDual.sup_of_inf_left.toDual⟩\n\n"}
{"name":"inf_covBy_of_covBy_sup_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsLowerModularLattice α\na b : α\na✝ : CovBy a (Max.max a b)\n⊢ CovBy (Min.min a b) b","decl":"theorem inf_covBy_of_covBy_sup_left : a ⋖ a ⊔ b → a ⊓ b ⋖ b :=\n  IsLowerModularLattice.inf_covBy_of_covBy_sup\n\n"}
{"name":"inf_covBy_of_covBy_sup_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsLowerModularLattice α\na b : α\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) a","decl":"theorem inf_covBy_of_covBy_sup_right : b ⋖ a ⊔ b → a ⊓ b ⋖ a := by\n  rw [inf_comm, sup_comm]\n  exact inf_covBy_of_covBy_sup_left\n\n"}
{"name":"CovBy.inf_of_sup_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsLowerModularLattice α\na b : α\na✝ : CovBy a (Max.max a b)\n⊢ CovBy (Min.min a b) b","decl":"alias CovBy.inf_of_sup_left := inf_covBy_of_covBy_sup_left\n\n"}
{"name":"CovBy.inf_of_sup_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsLowerModularLattice α\na b : α\na✝ : CovBy b (Max.max a b)\n⊢ CovBy (Min.min a b) a","decl":"alias CovBy.inf_of_sup_right := inf_covBy_of_covBy_sup_right\n\n-- See note [lower instance priority]\n"}
{"name":"IsLowerModularLattice.to_isWeakLowerModularLattice","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsLowerModularLattice α\n⊢ IsWeakLowerModularLattice α","decl":"instance (priority := 100) IsLowerModularLattice.to_isWeakLowerModularLattice :\n    IsWeakLowerModularLattice α :=\n  ⟨fun _ => CovBy.inf_of_sup_right⟩\n\n"}
{"name":"instIsUpperModularLatticeOrderDual","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsLowerModularLattice α\n⊢ IsUpperModularLattice (OrderDual α)","decl":"instance : IsUpperModularLattice (OrderDual α) :=\n  ⟨fun h => h.ofDual.inf_of_sup_left.toDual⟩\n\n"}
{"name":"sup_inf_assoc_of_le","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\nh : LE.le x z\n⊢ Eq (Min.min (Max.max x y) z) (Max.max x (Min.min y z))","decl":"theorem sup_inf_assoc_of_le {x : α} (y : α) {z : α} (h : x ≤ z) : (x ⊔ y) ⊓ z = x ⊔ y ⊓ z :=\n  le_antisymm (IsModularLattice.sup_inf_le_assoc_of_le y h)\n    (le_inf (sup_le_sup_left inf_le_left _) (sup_le h inf_le_right))\n\n"}
{"name":"IsModularLattice.inf_sup_inf_assoc","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\n⊢ Eq (Max.max (Min.min x z) (Min.min y z)) (Min.min (Max.max (Min.min x z) y) z)","decl":"theorem IsModularLattice.inf_sup_inf_assoc {x y z : α} : x ⊓ z ⊔ y ⊓ z = (x ⊓ z ⊔ y) ⊓ z :=\n  (sup_inf_assoc_of_le y inf_le_right).symm\n\n"}
{"name":"inf_sup_assoc_of_le","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\nh : LE.le z x\n⊢ Eq (Max.max (Min.min x y) z) (Min.min x (Max.max y z))","decl":"theorem inf_sup_assoc_of_le {x : α} (y : α) {z : α} (h : z ≤ x) : x ⊓ y ⊔ z = x ⊓ (y ⊔ z) := by\n  rw [inf_comm, sup_comm, ← sup_inf_assoc_of_le y h, inf_comm, sup_comm]\n\n"}
{"name":"instIsModularLatticeOrderDual","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : Lattice α\n⊢ IsModularLattice (OrderDual α)","decl":"instance : IsModularLattice αᵒᵈ :=\n  ⟨fun y z xz =>\n    le_of_eq\n      (by\n        rw [inf_comm, sup_comm, eq_comm, inf_comm, sup_comm]\n        exact @sup_inf_assoc_of_le α _ _ _ y _ xz)⟩\n\n"}
{"name":"IsModularLattice.sup_inf_sup_assoc","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\n⊢ Eq (Min.min (Max.max x z) (Max.max y z)) (Max.max (Min.min (Max.max x z) y) z)","decl":"theorem IsModularLattice.sup_inf_sup_assoc : (x ⊔ z) ⊓ (y ⊔ z) = (x ⊔ z) ⊓ y ⊔ z :=\n  @IsModularLattice.inf_sup_inf_assoc αᵒᵈ _ _ _ _ _\n\n"}
{"name":"eq_of_le_of_inf_le_of_le_sup","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\nhxy : LE.le x y\nhinf : LE.le (Min.min y z) x\nhsup : LE.le y (Max.max x z)\n⊢ Eq x y","decl":"theorem eq_of_le_of_inf_le_of_le_sup (hxy : x ≤ y) (hinf : y ⊓ z ≤ x) (hsup : y ≤ x ⊔ z) :\n    x = y := by\n  refine hxy.antisymm ?_\n  rw [← inf_eq_right, sup_inf_assoc_of_le _ hxy] at hsup\n  rwa [← hsup, sup_le_iff, and_iff_right rfl.le, inf_comm]\n\n"}
{"name":"eq_of_le_of_inf_le_of_sup_le","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\nhxy : LE.le x y\nhinf : LE.le (Min.min y z) (Min.min x z)\nhsup : LE.le (Max.max y z) (Max.max x z)\n⊢ Eq x y","decl":"theorem eq_of_le_of_inf_le_of_sup_le (hxy : x ≤ y) (hinf : y ⊓ z ≤ x ⊓ z) (hsup : y ⊔ z ≤ x ⊔ z) :\n    x = y :=\n  eq_of_le_of_inf_le_of_le_sup hxy (hinf.trans inf_le_left) (le_sup_left.trans hsup)\n\n"}
{"name":"sup_lt_sup_of_lt_of_inf_le_inf","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\nhxy : LT.lt x y\nhinf : LE.le (Min.min y z) (Min.min x z)\n⊢ LT.lt (Max.max x z) (Max.max y z)","decl":"theorem sup_lt_sup_of_lt_of_inf_le_inf (hxy : x < y) (hinf : y ⊓ z ≤ x ⊓ z) : x ⊔ z < y ⊔ z :=\n  lt_of_le_of_ne (sup_le_sup_right (le_of_lt hxy) _) fun hsup =>\n    ne_of_lt hxy <| eq_of_le_of_inf_le_of_sup_le (le_of_lt hxy) hinf (le_of_eq hsup.symm)\n\n"}
{"name":"inf_lt_inf_of_lt_of_sup_le_sup","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nx y z : α\nhxy : LT.lt x y\nhinf : LE.le (Max.max y z) (Max.max x z)\n⊢ LT.lt (Min.min x z) (Min.min y z)","decl":"theorem inf_lt_inf_of_lt_of_sup_le_sup (hxy : x < y) (hinf : y ⊔ z ≤ x ⊔ z) : x ⊓ z < y ⊓ z :=\n  sup_lt_sup_of_lt_of_inf_le_inf (α := αᵒᵈ) hxy hinf\n\n"}
{"name":"strictMono_inf_prod_sup","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\nz : α\n⊢ StrictMono fun x => { fst := Min.min x z, snd := Max.max x z }","decl":"theorem strictMono_inf_prod_sup : StrictMono fun x ↦ (x ⊓ z, x ⊔ z) := fun _x _y hxy ↦\n  ⟨⟨inf_le_inf_right _ hxy.le, sup_le_sup_right hxy.le _⟩,\n    fun ⟨inf_le, sup_le⟩ ↦ (sup_lt_sup_of_lt_of_inf_le_inf hxy inf_le).not_le sup_le⟩\n\n"}
{"name":"wellFounded_lt_exact_sequence","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝³ : Lattice α\ninst✝² : IsModularLattice α\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : PartialOrder β\ninst✝ : Preorder γ\nh₁ : WellFoundedLT β\nh₂ : WellFoundedLT γ\nK : α\nf₁ : β → α\nf₂ : α → β\ng₁ : γ → α\ng₂ : α → γ\ngci : GaloisCoinsertion f₁ f₂\ngi : GaloisInsertion g₂ g₁\nhf : ∀ (a : α), Eq (f₁ (f₂ a)) (Min.min a K)\nhg : ∀ (a : α), Eq (g₁ (g₂ a)) (Max.max a K)\n⊢ WellFoundedLT α","decl":"/-- A generalization of the theorem that if `N` is a submodule of `M` and\n  `N` and `M / N` are both Artinian, then `M` is Artinian. -/\ntheorem wellFounded_lt_exact_sequence {β γ : Type*} [PartialOrder β] [Preorder γ]\n    [h₁ : WellFoundedLT β] [h₂ : WellFoundedLT γ] (K : α)\n    (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : GaloisCoinsertion f₁ f₂)\n    (gi : GaloisInsertion g₂ g₁) (hf : ∀ a, f₁ (f₂ a) = a ⊓ K) (hg : ∀ a, g₁ (g₂ a) = a ⊔ K) :\n    WellFoundedLT α :=\n  StrictMono.wellFoundedLT (f := fun A ↦ (f₂ A, g₂ A)) fun A B hAB ↦ by\n    simp only [Prod.le_def, lt_iff_le_not_le, ← gci.l_le_l_iff, ← gi.u_le_u_iff, hf, hg]\n    exact strictMono_inf_prod_sup hAB\n\n"}
{"name":"wellFounded_gt_exact_sequence","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝⁵ : Lattice α\ninst✝⁴ : IsModularLattice α\nβ : Type u_2\nγ : Type u_3\ninst✝³ : Preorder β\ninst✝² : PartialOrder γ\ninst✝¹ : WellFoundedGT β\ninst✝ : WellFoundedGT γ\nK : α\nf₁ : β → α\nf₂ : α → β\ng₁ : γ → α\ng₂ : α → γ\ngci : GaloisCoinsertion f₁ f₂\ngi : GaloisInsertion g₂ g₁\nhf : ∀ (a : α), Eq (f₁ (f₂ a)) (Min.min a K)\nhg : ∀ (a : α), Eq (g₁ (g₂ a)) (Max.max a K)\n⊢ WellFoundedGT α","decl":"/-- A generalization of the theorem that if `N` is a submodule of `M` and\n  `N` and `M / N` are both Noetherian, then `M` is Noetherian. -/\ntheorem wellFounded_gt_exact_sequence {β γ : Type*} [Preorder β] [PartialOrder γ]\n    [WellFoundedGT β] [WellFoundedGT γ] (K : α)\n    (f₁ : β → α) (f₂ : α → β) (g₁ : γ → α) (g₂ : α → γ) (gci : GaloisCoinsertion f₁ f₂)\n    (gi : GaloisInsertion g₂ g₁) (hf : ∀ a, f₁ (f₂ a) = a ⊓ K) (hg : ∀ a, g₁ (g₂ a) = a ⊔ K) :\n    WellFoundedGT α :=\n  wellFounded_lt_exact_sequence (α := αᵒᵈ) (β := γᵒᵈ) (γ := βᵒᵈ)\n    K g₁ g₂ f₁ f₂ gi.dual gci.dual hg hf\n\n"}
{"name":"infIccOrderIsoIccSup_symm_apply_coe","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\nx : ↑(Set.Icc b (Max.max a b))\n⊢ Eq (↑((RelIso.symm (infIccOrderIsoIccSup a b)) x)) (Min.min a ↑x)","decl":"/-- The diamond isomorphism between the intervals `[a ⊓ b, a]` and `[b, a ⊔ b]` -/\n@[simps]\ndef infIccOrderIsoIccSup (a b : α) : Set.Icc (a ⊓ b) a ≃o Set.Icc b (a ⊔ b) where\n  toFun x := ⟨x ⊔ b, ⟨le_sup_right, sup_le_sup_right x.prop.2 b⟩⟩\n  invFun x := ⟨a ⊓ x, ⟨inf_le_inf_left a x.prop.1, inf_le_left⟩⟩\n  left_inv x :=\n    Subtype.ext\n      (by\n        change a ⊓ (↑x ⊔ b) = ↑x\n        rw [sup_comm, ← inf_sup_assoc_of_le _ x.prop.2, sup_eq_right.2 x.prop.1])\n  right_inv x :=\n    Subtype.ext\n      (by\n        change a ⊓ ↑x ⊔ b = ↑x\n        rw [inf_comm, inf_sup_assoc_of_le _ x.prop.1, inf_eq_left.2 x.prop.2])\n  map_rel_iff' {x y} := by\n    simp only [Subtype.mk_le_mk, Equiv.coe_fn_mk, le_sup_right]\n    rw [← Subtype.coe_le_coe]\n    refine ⟨fun h => ?_, fun h => sup_le_sup_right h _⟩\n    rw [← sup_eq_right.2 x.prop.1, inf_sup_assoc_of_le _ x.prop.2, sup_comm, ←\n      sup_eq_right.2 y.prop.1, inf_sup_assoc_of_le _ y.prop.2, sup_comm b]\n    exact inf_le_inf_left _ h\n\n"}
{"name":"infIccOrderIsoIccSup_apply_coe","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b : α\nx : ↑(Set.Icc (Min.min a b) a)\n⊢ Eq (↑((infIccOrderIsoIccSup a b) x)) (Max.max (↑x) b)","decl":"/-- The diamond isomorphism between the intervals `[a ⊓ b, a]` and `[b, a ⊔ b]` -/\n@[simps]\ndef infIccOrderIsoIccSup (a b : α) : Set.Icc (a ⊓ b) a ≃o Set.Icc b (a ⊔ b) where\n  toFun x := ⟨x ⊔ b, ⟨le_sup_right, sup_le_sup_right x.prop.2 b⟩⟩\n  invFun x := ⟨a ⊓ x, ⟨inf_le_inf_left a x.prop.1, inf_le_left⟩⟩\n  left_inv x :=\n    Subtype.ext\n      (by\n        change a ⊓ (↑x ⊔ b) = ↑x\n        rw [sup_comm, ← inf_sup_assoc_of_le _ x.prop.2, sup_eq_right.2 x.prop.1])\n  right_inv x :=\n    Subtype.ext\n      (by\n        change a ⊓ ↑x ⊔ b = ↑x\n        rw [inf_comm, inf_sup_assoc_of_le _ x.prop.1, inf_eq_left.2 x.prop.2])\n  map_rel_iff' {x y} := by\n    simp only [Subtype.mk_le_mk, Equiv.coe_fn_mk, le_sup_right]\n    rw [← Subtype.coe_le_coe]\n    refine ⟨fun h => ?_, fun h => sup_le_sup_right h _⟩\n    rw [← sup_eq_right.2 x.prop.1, inf_sup_assoc_of_le _ x.prop.2, sup_comm, ←\n      sup_eq_right.2 y.prop.1, inf_sup_assoc_of_le _ y.prop.2, sup_comm b]\n    exact inf_le_inf_left _ h\n\n"}
{"name":"inf_strictMonoOn_Icc_sup","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\na b : α\n⊢ StrictMonoOn (fun c => Min.min a c) (Set.Icc b (Max.max a b))","decl":"theorem inf_strictMonoOn_Icc_sup {a b : α} : StrictMonoOn (fun c => a ⊓ c) (Icc b (a ⊔ b)) :=\n  StrictMono.of_restrict (infIccOrderIsoIccSup a b).symm.strictMono\n\n"}
{"name":"sup_strictMonoOn_Icc_inf","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\na b : α\n⊢ StrictMonoOn (fun c => Max.max c b) (Set.Icc (Min.min a b) a)","decl":"theorem sup_strictMonoOn_Icc_inf {a b : α} : StrictMonoOn (fun c => c ⊔ b) (Icc (a ⊓ b) a) :=\n  StrictMono.of_restrict (infIccOrderIsoIccSup a b).strictMono\n\n"}
{"name":"infIooOrderIsoIooSup_apply_coe","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\na b : α\nc : ↑(Set.Ioo (Min.min a b) a)\n⊢ Eq (↑((infIooOrderIsoIooSup a b) c)) (Max.max (↑c) b)","decl":"/-- The diamond isomorphism between the intervals `]a ⊓ b, a[` and `}b, a ⊔ b[`. -/\n@[simps]\ndef infIooOrderIsoIooSup (a b : α) : Ioo (a ⊓ b) a ≃o Ioo b (a ⊔ b) where\n  toFun c :=\n    ⟨c ⊔ b,\n      le_sup_right.trans_lt <|\n        sup_strictMonoOn_Icc_inf (left_mem_Icc.2 inf_le_left) (Ioo_subset_Icc_self c.2) c.2.1,\n      sup_strictMonoOn_Icc_inf (Ioo_subset_Icc_self c.2) (right_mem_Icc.2 inf_le_left) c.2.2⟩\n  invFun c :=\n    ⟨a ⊓ c,\n      inf_strictMonoOn_Icc_sup (left_mem_Icc.2 le_sup_right) (Ioo_subset_Icc_self c.2) c.2.1,\n      inf_le_left.trans_lt' <|\n        inf_strictMonoOn_Icc_sup (Ioo_subset_Icc_self c.2) (right_mem_Icc.2 le_sup_right) c.2.2⟩\n  left_inv c :=\n    Subtype.ext <| by\n      dsimp\n      rw [sup_comm, ← inf_sup_assoc_of_le _ c.prop.2.le, sup_eq_right.2 c.prop.1.le]\n  right_inv c :=\n    Subtype.ext <| by\n      dsimp\n      rw [inf_comm, inf_sup_assoc_of_le _ c.prop.1.le, inf_eq_left.2 c.prop.2.le]\n  map_rel_iff' := @fun c d =>\n    @OrderIso.le_iff_le _ _ _ _ (infIccOrderIsoIccSup _ _) ⟨c.1, Ioo_subset_Icc_self c.2⟩\n      ⟨d.1, Ioo_subset_Icc_self d.2⟩\n\n-- See note [lower instance priority]\n"}
{"name":"infIooOrderIsoIooSup_symm_apply_coe","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\na b : α\nc : ↑(Set.Ioo b (Max.max a b))\n⊢ Eq (↑((RelIso.symm (infIooOrderIsoIooSup a b)) c)) (Min.min a ↑c)","decl":"/-- The diamond isomorphism between the intervals `]a ⊓ b, a[` and `}b, a ⊔ b[`. -/\n@[simps]\ndef infIooOrderIsoIooSup (a b : α) : Ioo (a ⊓ b) a ≃o Ioo b (a ⊔ b) where\n  toFun c :=\n    ⟨c ⊔ b,\n      le_sup_right.trans_lt <|\n        sup_strictMonoOn_Icc_inf (left_mem_Icc.2 inf_le_left) (Ioo_subset_Icc_self c.2) c.2.1,\n      sup_strictMonoOn_Icc_inf (Ioo_subset_Icc_self c.2) (right_mem_Icc.2 inf_le_left) c.2.2⟩\n  invFun c :=\n    ⟨a ⊓ c,\n      inf_strictMonoOn_Icc_sup (left_mem_Icc.2 le_sup_right) (Ioo_subset_Icc_self c.2) c.2.1,\n      inf_le_left.trans_lt' <|\n        inf_strictMonoOn_Icc_sup (Ioo_subset_Icc_self c.2) (right_mem_Icc.2 le_sup_right) c.2.2⟩\n  left_inv c :=\n    Subtype.ext <| by\n      dsimp\n      rw [sup_comm, ← inf_sup_assoc_of_le _ c.prop.2.le, sup_eq_right.2 c.prop.1.le]\n  right_inv c :=\n    Subtype.ext <| by\n      dsimp\n      rw [inf_comm, inf_sup_assoc_of_le _ c.prop.1.le, inf_eq_left.2 c.prop.2.le]\n  map_rel_iff' := @fun c d =>\n    @OrderIso.le_iff_le _ _ _ _ (infIccOrderIsoIccSup _ _) ⟨c.1, Ioo_subset_Icc_self c.2⟩\n      ⟨d.1, Ioo_subset_Icc_self d.2⟩\n\n-- See note [lower instance priority]\n"}
{"name":"IsModularLattice.to_isLowerModularLattice","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : Lattice α\n⊢ IsLowerModularLattice α","decl":"instance (priority := 100) IsModularLattice.to_isLowerModularLattice : IsLowerModularLattice α :=\n  ⟨fun {a b} => by\n    simp_rw [covBy_iff_Ioo_eq, sup_comm a, inf_comm a, ← isEmpty_coe_sort, right_lt_sup,\n      inf_lt_left, (infIooOrderIsoIooSup b a).symm.toEquiv.isEmpty_congr]\n    exact id⟩\n\n-- See note [lower instance priority]\n"}
{"name":"IsModularLattice.to_isUpperModularLattice","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : Lattice α\n⊢ IsUpperModularLattice α","decl":"instance (priority := 100) IsModularLattice.to_isUpperModularLattice : IsUpperModularLattice α :=\n  ⟨fun {a b} => by\n    simp_rw [covBy_iff_Ioo_eq, ← isEmpty_coe_sort, right_lt_sup, inf_lt_left,\n      (infIooOrderIsoIooSup a b).toEquiv.isEmpty_congr]\n    exact id⟩\n\n"}
{"name":"isModularLattice_iff_inf_sup_inf_assoc","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : Lattice α\n⊢ Iff (IsModularLattice α) (∀ (x y z : α), Eq (Max.max (Min.min x z) (Min.min y z)) (Min.min (Max.max (Min.min x z) y) z))","decl":"theorem isModularLattice_iff_inf_sup_inf_assoc [Lattice α] :\n    IsModularLattice α ↔ ∀ x y z : α, x ⊓ z ⊔ y ⊓ z = (x ⊓ z ⊔ y) ⊓ z :=\n  ⟨fun h => @IsModularLattice.inf_sup_inf_assoc _ _ h, fun h =>\n    ⟨fun y z xz => by rw [← inf_eq_left.2 xz, h]⟩⟩\n\n"}
{"name":"DistribLattice.instIsModularLattice","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝ : DistribLattice α\n⊢ IsModularLattice α","decl":"instance (priority := 100) [DistribLattice α] : IsModularLattice α :=\n  ⟨fun y z xz => by rw [inf_sup_right, inf_eq_left.2 xz]⟩\n\n"}
{"name":"Disjoint.disjoint_sup_right_of_disjoint_sup_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\na b c : α\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\ninst✝ : IsModularLattice α\nh : Disjoint a b\nhsup : Disjoint (Max.max a b) c\n⊢ Disjoint a (Max.max b c)","decl":"theorem disjoint_sup_right_of_disjoint_sup_left [Lattice α] [OrderBot α]\n    [IsModularLattice α] (h : Disjoint a b) (hsup : Disjoint (a ⊔ b) c) :\n    Disjoint a (b ⊔ c) := by\n  rw [disjoint_iff_inf_le, ← h.eq_bot, sup_comm]\n  apply le_inf inf_le_left\n  apply (inf_le_inf_right (c ⊔ b) le_sup_right).trans\n  rw [sup_comm, IsModularLattice.sup_inf_sup_assoc, hsup.eq_bot, bot_sup_eq]\n\n"}
{"name":"Disjoint.disjoint_sup_left_of_disjoint_sup_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\na b c : α\ninst✝² : Lattice α\ninst✝¹ : OrderBot α\ninst✝ : IsModularLattice α\nh : Disjoint b c\nhsup : Disjoint a (Max.max b c)\n⊢ Disjoint (Max.max a b) c","decl":"theorem disjoint_sup_left_of_disjoint_sup_right [Lattice α] [OrderBot α]\n    [IsModularLattice α] (h : Disjoint b c) (hsup : Disjoint a (b ⊔ c)) :\n    Disjoint (a ⊔ b) c := by\n  rw [disjoint_comm, sup_comm]\n  apply Disjoint.disjoint_sup_right_of_disjoint_sup_left h.symm\n  rwa [sup_comm, disjoint_comm] at hsup\n\n"}
{"name":"Disjoint.isCompl_sup_right_of_isCompl_sup_left","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\na b c : α\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsModularLattice α\nh : Disjoint a b\nhcomp : IsCompl (Max.max a b) c\n⊢ IsCompl a (Max.max b c)","decl":"theorem isCompl_sup_right_of_isCompl_sup_left [Lattice α] [BoundedOrder α] [IsModularLattice α]\n    (h : Disjoint a b) (hcomp : IsCompl (a ⊔ b) c) :\n    IsCompl a (b ⊔ c) :=\n  ⟨h.disjoint_sup_right_of_disjoint_sup_left hcomp.disjoint, codisjoint_assoc.mp hcomp.codisjoint⟩\n\n"}
{"name":"Disjoint.isCompl_sup_left_of_isCompl_sup_right","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\na b c : α\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsModularLattice α\nh : Disjoint b c\nhcomp : IsCompl a (Max.max b c)\n⊢ IsCompl (Max.max a b) c","decl":"theorem isCompl_sup_left_of_isCompl_sup_right [Lattice α] [BoundedOrder α] [IsModularLattice α]\n    (h : Disjoint b c) (hcomp : IsCompl a (b ⊔ c)) :\n    IsCompl (a ⊔ b) c :=\n  ⟨h.disjoint_sup_left_of_disjoint_sup_right hcomp.disjoint, codisjoint_assoc.mpr hcomp.codisjoint⟩\n\n"}
{"name":"Set.Iic.isCompl_inf_inf_of_isCompl_of_le","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝² : Lattice α\ninst✝¹ : BoundedOrder α\ninst✝ : IsModularLattice α\na b c : α\nh₁ : IsCompl b c\nh₂ : LE.le b a\n⊢ IsCompl ⟨Min.min a b, ⋯⟩ ⟨Min.min a c, ⋯⟩","decl":"lemma Set.Iic.isCompl_inf_inf_of_isCompl_of_le [Lattice α] [BoundedOrder α] [IsModularLattice α]\n    {a b c : α} (h₁ : IsCompl b c) (h₂ : b ≤ a) :\n    IsCompl (⟨a ⊓ b, inf_le_left⟩ : Iic a) (⟨a ⊓ c, inf_le_left⟩ : Iic a) := by\n  constructor\n  · simp [disjoint_iff, Subtype.ext_iff, inf_comm a c, inf_assoc a, ← inf_assoc b, h₁.inf_eq_bot]\n  · simp only [Iic.codisjoint_iff, inf_comm a, IsModularLattice.inf_sup_inf_assoc]\n    simp [inf_of_le_left h₂, h₁.sup_eq_top]\n\n"}
{"name":"IsModularLattice.isModularLattice_Iic","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\na : α\n⊢ IsModularLattice ↑(Set.Iic a)","decl":"instance isModularLattice_Iic : IsModularLattice (Set.Iic a) :=\n  ⟨@fun x y z xz => (sup_inf_le_assoc_of_le (y : α) xz : (↑x ⊔ ↑y) ⊓ ↑z ≤ ↑x ⊔ ↑y ⊓ ↑z)⟩\n\n"}
{"name":"IsModularLattice.isModularLattice_Ici","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝¹ : Lattice α\ninst✝ : IsModularLattice α\na : α\n⊢ IsModularLattice ↑(Set.Ici a)","decl":"instance isModularLattice_Ici : IsModularLattice (Set.Ici a) :=\n  ⟨@fun x y z xz => (sup_inf_le_assoc_of_le (y : α) xz : (↑x ⊔ ↑y) ⊓ ↑z ≤ ↑x ⊔ ↑y ⊓ ↑z)⟩\n\n"}
{"name":"IsModularLattice.complementedLattice_Iic","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝² : Lattice α\na : α\ninst✝¹ : BoundedOrder α\ninst✝ : ComplementedLattice α\n⊢ ComplementedLattice ↑(Set.Iic a)","decl":"instance complementedLattice_Iic : ComplementedLattice (Set.Iic a) :=\n  ⟨fun ⟨x, hx⟩ =>\n    let ⟨y, hy⟩ := exists_isCompl x\n    ⟨⟨y ⊓ a, Set.mem_Iic.2 inf_le_right⟩, by\n      constructor\n      · rw [disjoint_iff_inf_le]\n        change x ⊓ (y ⊓ a) ≤ ⊥\n        -- improve lattice subtype API\n        rw [← inf_assoc]\n        exact le_trans inf_le_left hy.1.le_bot\n      · rw [codisjoint_iff_le_sup]\n        change a ≤ x ⊔ y ⊓ a\n        -- improve lattice subtype API\n        rw [← sup_inf_assoc_of_le _ (Set.mem_Iic.1 hx), hy.2.eq_top, top_inf_eq]⟩⟩\n\n"}
{"name":"IsModularLattice.complementedLattice_Ici","module":"Mathlib.Order.ModularLattice","initialProofState":"α : Type u_1\ninst✝² : Lattice α\na : α\ninst✝¹ : BoundedOrder α\ninst✝ : ComplementedLattice α\n⊢ ComplementedLattice ↑(Set.Ici a)","decl":"instance complementedLattice_Ici : ComplementedLattice (Set.Ici a) :=\n  ⟨fun ⟨x, hx⟩ =>\n    let ⟨y, hy⟩ := exists_isCompl x\n    ⟨⟨y ⊔ a, Set.mem_Ici.2 le_sup_right⟩, by\n      constructor\n      · rw [disjoint_iff_inf_le]\n        change x ⊓ (y ⊔ a) ≤ a\n        -- improve lattice subtype API\n        rw [← inf_sup_assoc_of_le _ (Set.mem_Ici.1 hx), hy.1.eq_bot, bot_sup_eq]\n      · rw [codisjoint_iff_le_sup]\n        change ⊤ ≤ x ⊔ (y ⊔ a)\n        -- improve lattice subtype API\n        rw [← sup_assoc]\n        exact le_trans hy.2.top_le le_sup_left⟩⟩\n\n"}
