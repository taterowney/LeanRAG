{"name":"HahnSeries.ext","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx y : HahnSeries Γ R\ncoeff : Eq x.coeff y.coeff\n⊢ Eq x y","decl":"/-- If `Γ` is linearly ordered and `R` has zero, then `HahnSeries Γ R` consists of\n  formal series over `Γ` with coefficients in `R`, whose supports are well-founded. -/\n@[ext]\nstructure HahnSeries (Γ : Type*) (R : Type*) [PartialOrder Γ] [Zero R] where\n  /-- The coefficient function of a Hahn Series. -/\n  coeff : Γ → R\n  isPWO_support' : (Function.support coeff).IsPWO\n\n"}
{"name":"HahnSeries.mk.inj","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\ncoeff✝ : Γ → R\nisPWO_support'✝ : (Function.support coeff✝).IsPWO\ncoeff : Γ → R\nisPWO_support' : (Function.support coeff).IsPWO\nx✝ : Eq { coeff := coeff✝, isPWO_support' := isPWO_support'✝ } { coeff := coeff, isPWO_support' := isPWO_support' }\n⊢ Eq coeff✝ coeff","decl":"/-- If `Γ` is linearly ordered and `R` has zero, then `HahnSeries Γ R` consists of\n  formal series over `Γ` with coefficients in `R`, whose supports are well-founded. -/\n@[ext]\nstructure HahnSeries (Γ : Type*) (R : Type*) [PartialOrder Γ] [Zero R] where\n  /-- The coefficient function of a Hahn Series. -/\n  coeff : Γ → R\n  isPWO_support' : (Function.support coeff).IsPWO\n\n"}
{"name":"HahnSeries.ext_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx y : HahnSeries Γ R\n⊢ Iff (Eq x y) (Eq x.coeff y.coeff)","decl":"/-- If `Γ` is linearly ordered and `R` has zero, then `HahnSeries Γ R` consists of\n  formal series over `Γ` with coefficients in `R`, whose supports are well-founded. -/\n@[ext]\nstructure HahnSeries (Γ : Type*) (R : Type*) [PartialOrder Γ] [Zero R] where\n  /-- The coefficient function of a Hahn Series. -/\n  coeff : Γ → R\n  isPWO_support' : (Function.support coeff).IsPWO\n\n"}
{"name":"HahnSeries.mk.sizeOf_spec","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝³ : PartialOrder Γ\ninst✝² : Zero R\ninst✝¹ : SizeOf Γ\ninst✝ : SizeOf R\ncoeff : Γ → R\nisPWO_support' : (Function.support coeff).IsPWO\n⊢ Eq (SizeOf.sizeOf { coeff := coeff, isPWO_support' := isPWO_support' }) 1","decl":"/-- If `Γ` is linearly ordered and `R` has zero, then `HahnSeries Γ R` consists of\n  formal series over `Γ` with coefficients in `R`, whose supports are well-founded. -/\n@[ext]\nstructure HahnSeries (Γ : Type*) (R : Type*) [PartialOrder Γ] [Zero R] where\n  /-- The coefficient function of a Hahn Series. -/\n  coeff : Γ → R\n  isPWO_support' : (Function.support coeff).IsPWO\n\n"}
{"name":"HahnSeries.mk.injEq","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\ncoeff✝ : Γ → R\nisPWO_support'✝ : (Function.support coeff✝).IsPWO\ncoeff : Γ → R\nisPWO_support' : (Function.support coeff).IsPWO\n⊢ Eq (Eq { coeff := coeff✝, isPWO_support' := isPWO_support'✝ } { coeff := coeff, isPWO_support' := isPWO_support' }) (Eq coeff✝ coeff)","decl":"/-- If `Γ` is linearly ordered and `R` has zero, then `HahnSeries Γ R` consists of\n  formal series over `Γ` with coefficients in `R`, whose supports are well-founded. -/\n@[ext]\nstructure HahnSeries (Γ : Type*) (R : Type*) [PartialOrder Γ] [Zero R] where\n  /-- The coefficient function of a Hahn Series. -/\n  coeff : Γ → R\n  isPWO_support' : (Function.support coeff).IsPWO\n\n"}
{"name":"HahnSeries.isPWO_support'","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_2\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nself : HahnSeries Γ R\n⊢ (Function.support self.coeff).IsPWO","decl":"/-- If `Γ` is linearly ordered and `R` has zero, then `HahnSeries Γ R` consists of\n  formal series over `Γ` with coefficients in `R`, whose supports are well-founded. -/\n@[ext]\nstructure HahnSeries (Γ : Type*) (R : Type*) [PartialOrder Γ] [Zero R] where\n  /-- The coefficient function of a Hahn Series. -/\n  coeff : Γ → R\n  isPWO_support' : (Function.support coeff).IsPWO\n\n"}
{"name":"HahnSeries.coeff_injective","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\n⊢ Function.Injective HahnSeries.coeff","decl":"theorem coeff_injective : Injective (coeff : HahnSeries Γ R → Γ → R) :=\n  fun _ _ => HahnSeries.ext\n\n"}
{"name":"HahnSeries.coeff_inj","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx y : HahnSeries Γ R\n⊢ Iff (Eq x.coeff y.coeff) (Eq x y)","decl":"@[simp]\ntheorem coeff_inj {x y : HahnSeries Γ R} : x.coeff = y.coeff ↔ x = y :=\n  coeff_injective.eq_iff\n\n"}
{"name":"HahnSeries.isPWO_support","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ x.support.IsPWO","decl":"@[simp]\ntheorem isPWO_support (x : HahnSeries Γ R) : x.support.IsPWO :=\n  x.isPWO_support'\n\n"}
{"name":"HahnSeries.isWF_support","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ x.support.IsWF","decl":"@[simp]\ntheorem isWF_support (x : HahnSeries Γ R) : x.support.IsWF :=\n  x.isPWO_support.isWF\n\n"}
{"name":"HahnSeries.mem_support","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\na : Γ\n⊢ Iff (Membership.mem x.support a) (Ne (x.coeff a) 0)","decl":"@[simp]\ntheorem mem_support (x : HahnSeries Γ R) (a : Γ) : a ∈ x.support ↔ x.coeff a ≠ 0 :=\n  Iff.refl _\n\n"}
{"name":"HahnSeries.instSubsingleton","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Subsingleton R\n⊢ Subsingleton (HahnSeries Γ R)","decl":"instance [Subsingleton R] : Subsingleton (HahnSeries Γ R) :=\n  ⟨fun _ _ => HahnSeries.ext (by subsingleton)⟩\n\n"}
{"name":"HahnSeries.coeff_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\n⊢ Eq (HahnSeries.coeff 0 a) 0","decl":"@[simp]\ntheorem coeff_zero {a : Γ} : (0 : HahnSeries Γ R).coeff a = 0 :=\n  rfl\n\n"}
{"name":"HahnSeries.zero_coeff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\n⊢ Eq (HahnSeries.coeff 0 a) 0","decl":"@[deprecated (since := \"2025-01-31\")] alias zero_coeff := coeff_zero\n\n"}
{"name":"HahnSeries.coeff_fun_eq_zero_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff (Eq x.coeff 0) (Eq x 0)","decl":"@[simp]\ntheorem coeff_fun_eq_zero_iff {x : HahnSeries Γ R} : x.coeff = 0 ↔ x = 0 :=\n  coeff_injective.eq_iff' rfl\n\n"}
{"name":"HahnSeries.ne_zero_of_coeff_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\ng : Γ\nh : Ne (x.coeff g) 0\n⊢ Ne x 0","decl":"theorem ne_zero_of_coeff_ne_zero {x : HahnSeries Γ R} {g : Γ} (h : x.coeff g ≠ 0) : x ≠ 0 :=\n  mt (fun x0 => (x0.symm ▸ coeff_zero : x.coeff g = 0)) h\n\n"}
{"name":"HahnSeries.support_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\n⊢ Eq (HahnSeries.support 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem support_zero : support (0 : HahnSeries Γ R) = ∅ :=\n  Function.support_zero\n\n"}
{"name":"HahnSeries.support_nonempty_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff x.support.Nonempty (Ne x 0)","decl":"@[simp]\nnonrec theorem support_nonempty_iff {x : HahnSeries Γ R} : x.support.Nonempty ↔ x ≠ 0 := by\n  rw [support, support_nonempty_iff, Ne, coeff_fun_eq_zero_iff]\n\n"}
{"name":"HahnSeries.support_eq_empty_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff (Eq x.support EmptyCollection.emptyCollection) (Eq x 0)","decl":"@[simp]\ntheorem support_eq_empty_iff {x : HahnSeries Γ R} : x.support = ∅ ↔ x = 0 :=\n  Function.support_eq_empty_iff.trans coeff_fun_eq_zero_iff\n\n"}
{"name":"HahnSeries.map_coeff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝⁴ : PartialOrder Γ\ninst✝³ : Zero R\ninst✝² : Zero S\nx : HahnSeries Γ R\nF : Type u_5\ninst✝¹ : FunLike F R S\ninst✝ : ZeroHomClass F R S\nf : F\ng : Γ\n⊢ Eq ((x.map f).coeff g) (f (x.coeff g))","decl":"/-- The map of Hahn series induced by applying a zero-preserving map to each coefficient. -/\n@[simps]\ndef map [Zero S] (x : HahnSeries Γ R) {F : Type*} [FunLike F R S] [ZeroHomClass F R S] (f : F) :\n    HahnSeries Γ S where\n  coeff g := f (x.coeff g)\n  isPWO_support' := x.isPWO_support.mono <| Function.support_comp_subset (ZeroHomClass.map_zero f) _\n\n"}
{"name":"HahnSeries.map_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero S\nf : ZeroHom R S\n⊢ Eq (HahnSeries.map 0 f) 0","decl":"@[simp]\nprotected lemma map_zero [Zero S] (f : ZeroHom R S) :\n    (0 : HahnSeries Γ R).map f = 0 := by\n  ext; simp\n\n"}
{"name":"HahnSeries.mk_eq_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nf : Γ → R\nh : (Function.support f).IsPWO\n⊢ Iff (Eq { coeff := f, isPWO_support' := h } 0) (Eq f 0)","decl":"@[simp]\nlemma mk_eq_zero (f : Γ → R) (h) : HahnSeries.mk f h = 0 ↔ f = 0 := by\n  rw [HahnSeries.ext_iff]\n  rfl\n\n"}
{"name":"HahnSeries.iterateEquiv_apply","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nx : HahnSeries Γ (HahnSeries Γ' R)\n⊢ Eq (HahnSeries.iterateEquiv x) x.ofIterate","decl":"/-- The equivalence between iterated Hahn series and Hahn series on the lex product. -/\n@[simps]\ndef iterateEquiv [PartialOrder Γ'] :\n    HahnSeries Γ (HahnSeries Γ' R) ≃ HahnSeries (Γ ×ₗ Γ') R where\n  toFun := ofIterate\n  invFun := toIterate\n  left_inv := congrFun rfl\n  right_inv := congrFun rfl\n\n"}
{"name":"HahnSeries.iterateEquiv_symm_apply","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nx : HahnSeries (Lex (Prod Γ Γ')) R\n⊢ Eq (HahnSeries.iterateEquiv.symm x) x.toIterate","decl":"/-- The equivalence between iterated Hahn series and Hahn series on the lex product. -/\n@[simps]\ndef iterateEquiv [PartialOrder Γ'] :\n    HahnSeries Γ (HahnSeries Γ' R) ≃ HahnSeries (Γ ×ₗ Γ') R where\n  toFun := ofIterate\n  invFun := toIterate\n  left_inv := congrFun rfl\n  right_inv := congrFun rfl\n\n"}
{"name":"HahnSeries.coeff_single_same","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\n⊢ Eq (((HahnSeries.single a) r).coeff a) r","decl":"@[simp]\ntheorem coeff_single_same (a : Γ) (r : R) : (single a r).coeff a = r := by\n  classical exact Pi.single_eq_same (f := fun _ => R) a r\n\n"}
{"name":"HahnSeries.single_coeff_same","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\n⊢ Eq (((HahnSeries.single a) r).coeff a) r","decl":"@[deprecated (since := \"2025-01-31\")] alias single_coeff_same := coeff_single_same\n\n"}
{"name":"HahnSeries.coeff_single_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na b : Γ\nr : R\nh : Ne b a\n⊢ Eq (((HahnSeries.single a) r).coeff b) 0","decl":"@[simp]\ntheorem coeff_single_of_ne (h : b ≠ a) : (single a r).coeff b = 0 := by\n  classical exact Pi.single_eq_of_ne (f := fun _ => R) h r\n\n"}
{"name":"HahnSeries.single_coeff_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na b : Γ\nr : R\nh : Ne b a\n⊢ Eq (((HahnSeries.single a) r).coeff b) 0","decl":"@[deprecated (since := \"2025-01-31\")] alias single_coeff_of_ne := coeff_single_of_ne\n\n"}
{"name":"HahnSeries.coeff_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na b : Γ\nr : R\n⊢ Eq (((HahnSeries.single a) r).coeff b) (ite (Eq b a) r 0)","decl":"open Classical in\ntheorem coeff_single : (single a r).coeff b = if b = a then r else 0 := by\n  split_ifs with h <;> simp [h]\n\n"}
{"name":"HahnSeries.single_coeff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na b : Γ\nr : R\n⊢ Eq (((HahnSeries.single a) r).coeff b) (ite (Eq b a) r 0)","decl":"@[deprecated (since := \"2025-01-31\")] alias single_coeff := coeff_single\n\n"}
{"name":"HahnSeries.support_single_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\nh : Ne r 0\n⊢ Eq ((HahnSeries.single a) r).support (Singleton.singleton a)","decl":"@[simp]\ntheorem support_single_of_ne (h : r ≠ 0) : support (single a r) = {a} := by\n  classical exact Pi.support_single_of_ne h\n\n"}
{"name":"HahnSeries.support_single_subset","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\n⊢ HasSubset.Subset ((HahnSeries.single a) r).support (Singleton.singleton a)","decl":"theorem support_single_subset : support (single a r) ⊆ {a} := by\n  classical exact Pi.support_single_subset\n\n"}
{"name":"HahnSeries.eq_of_mem_support_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\nb : Γ\nh : Membership.mem ((HahnSeries.single a) r).support b\n⊢ Eq b a","decl":"theorem eq_of_mem_support_single {b : Γ} (h : b ∈ support (single a r)) : b = a :=\n  support_single_subset h\n\n"}
{"name":"HahnSeries.single_eq_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\n⊢ Eq ((HahnSeries.single a) 0) 0","decl":"theorem single_eq_zero : single a (0 : R) = 0 :=\n  (single a).map_zero\n\n"}
{"name":"HahnSeries.single_injective","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\n⊢ Function.Injective ⇑(HahnSeries.single a)","decl":"theorem single_injective (a : Γ) : Function.Injective (single a : R → HahnSeries Γ R) :=\n  fun r s rs => by rw [← coeff_single_same a r, ← coeff_single_same a s, rs]\n\n"}
{"name":"HahnSeries.single_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\nh : Ne r 0\n⊢ Ne ((HahnSeries.single a) r) 0","decl":"theorem single_ne_zero (h : r ≠ 0) : single a r ≠ 0 := fun con =>\n  h (single_injective a (con.trans single_eq_zero.symm))\n\n"}
{"name":"HahnSeries.single_eq_zero_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\n⊢ Iff (Eq ((HahnSeries.single a) r) 0) (Eq r 0)","decl":"@[simp]\ntheorem single_eq_zero_iff {a : Γ} {r : R} : single a r = 0 ↔ r = 0 :=\n  map_eq_zero_iff _ <| single_injective a\n\n"}
{"name":"HahnSeries.map_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\na : Γ\nr : R\ninst✝ : Zero S\nf : ZeroHom R S\n⊢ Eq (((HahnSeries.single a) r).map f) ((HahnSeries.single a) (f r))","decl":"@[simp]\nprotected lemma map_single [Zero S] (f : ZeroHom R S) : (single a r).map f = single a (f r) := by\n  ext g\n  by_cases h : g = a <;> simp [h]\n\n"}
{"name":"HahnSeries.instNontrivialOfNonempty","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : PartialOrder Γ\ninst✝² : Zero R\ninst✝¹ : Nonempty Γ\ninst✝ : Nontrivial R\n⊢ Nontrivial (HahnSeries Γ R)","decl":"instance [Nonempty Γ] [Nontrivial R] : Nontrivial (HahnSeries Γ R) :=\n  ⟨by\n    obtain ⟨r, s, rs⟩ := exists_pair_ne R\n    inhabit Γ\n    refine ⟨single default r, single default s, fun con => rs ?_⟩\n    rw [← coeff_single_same (default : Γ) r, con, coeff_single_same]⟩\n\n"}
{"name":"HahnSeries.orderTop_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\n⊢ Eq (HahnSeries.orderTop 0) Top.top","decl":"@[simp]\ntheorem orderTop_zero : orderTop (0 : HahnSeries Γ R) = ⊤ :=\n  dif_pos rfl\n\n"}
{"name":"HahnSeries.orderTop_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Eq x.orderTop ↑(⋯.min ⋯)","decl":"theorem orderTop_of_ne {x : HahnSeries Γ R} (hx : x ≠ 0) :\n    orderTop x = x.isWF_support.min (support_nonempty_iff.2 hx) :=\n  dif_neg hx\n\n"}
{"name":"HahnSeries.ne_zero_iff_orderTop","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff (Ne x 0) (Ne x.orderTop Top.top)","decl":"@[simp]\ntheorem ne_zero_iff_orderTop {x : HahnSeries Γ R} : x ≠ 0 ↔ orderTop x ≠ ⊤ := by\n  constructor\n  · exact fun hx => Eq.mpr (congrArg (fun h ↦ h ≠ ⊤) (orderTop_of_ne hx)) WithTop.coe_ne_top\n  · contrapose!\n    simp_all only [orderTop_zero, implies_true]\n\n"}
{"name":"HahnSeries.orderTop_eq_top_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff (Eq x.orderTop Top.top) (Eq x 0)","decl":"theorem orderTop_eq_top_iff {x : HahnSeries Γ R} : orderTop x = ⊤ ↔ x = 0 := by\n  constructor\n  · contrapose!\n    exact ne_zero_iff_orderTop.mp\n  · simp_all only [orderTop_zero, implies_true]\n\n"}
{"name":"HahnSeries.orderTop_eq_of_le","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\ng : Γ\nhg : Membership.mem x.support g\nhx : ∀ (g' : Γ), Membership.mem x.support g' → LE.le g g'\n⊢ Eq x.orderTop ↑g","decl":"theorem orderTop_eq_of_le {x : HahnSeries Γ R} {g : Γ} (hg : g ∈ x.support)\n    (hx : ∀ g' ∈ x.support, g ≤ g') : orderTop x = g := by\n  rw [orderTop_of_ne <| support_nonempty_iff.mp <| Set.nonempty_of_mem hg,\n    x.isWF_support.min_eq_of_le hg hx]\n\n"}
{"name":"HahnSeries.untop_orderTop_of_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Eq (x.orderTop.untop ⋯) (⋯.min ⋯)","decl":"theorem untop_orderTop_of_ne_zero {x : HahnSeries Γ R} (hx : x ≠ 0) :\n    WithTop.untop x.orderTop (ne_zero_iff_orderTop.mp hx) =\n      x.isWF_support.min (support_nonempty_iff.2 hx) :=\n    WithTop.coe_inj.mp ((WithTop.coe_untop (orderTop x) (ne_zero_iff_orderTop.mp hx)).trans\n      (orderTop_of_ne hx))\n\n"}
{"name":"HahnSeries.coeff_orderTop_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\ng : Γ\nhg : Eq x.orderTop ↑g\n⊢ Ne (x.coeff g) 0","decl":"theorem coeff_orderTop_ne {x : HahnSeries Γ R} {g : Γ} (hg : x.orderTop = g) :\n    x.coeff g ≠ 0 := by\n  have h : orderTop x ≠ ⊤ := by simp_all only [ne_eq, WithTop.coe_ne_top, not_false_eq_true]\n  have hx : x ≠ 0 := ne_zero_iff_orderTop.mpr h\n  rw [orderTop_of_ne hx, WithTop.coe_eq_coe] at hg\n  rw [← hg]\n  exact x.isWF_support.min_mem (support_nonempty_iff.2 hx)\n\n"}
{"name":"HahnSeries.orderTop_le_of_coeff_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"R : Type u_3\ninst✝¹ : Zero R\nΓ : Type u_5\ninst✝ : LinearOrder Γ\nx : HahnSeries Γ R\ng : Γ\nh : Ne (x.coeff g) 0\n⊢ LE.le x.orderTop ↑g","decl":"theorem orderTop_le_of_coeff_ne_zero {Γ} [LinearOrder Γ] {x : HahnSeries Γ R}\n    {g : Γ} (h : x.coeff g ≠ 0) : x.orderTop ≤ g := by\n  rw [orderTop_of_ne (ne_zero_of_coeff_ne_zero h), WithTop.coe_le_coe]\n  exact Set.IsWF.min_le _ _ ((mem_support _ _).2 h)\n\n"}
{"name":"HahnSeries.orderTop_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\nh : Ne r 0\n⊢ Eq ((HahnSeries.single a) r).orderTop ↑a","decl":"@[simp]\ntheorem orderTop_single (h : r ≠ 0) : (single a r).orderTop = a :=\n  (orderTop_of_ne (single_ne_zero h)).trans\n    (WithTop.coe_inj.mpr (support_single_subset\n      ((single a r).isWF_support.min_mem (support_nonempty_iff.2 (single_ne_zero h)))))\n\n"}
{"name":"HahnSeries.orderTop_single_le","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\n⊢ LE.le (↑a) ((HahnSeries.single a) r).orderTop","decl":"theorem orderTop_single_le : a ≤ (single a r).orderTop := by\n  by_cases hr : r = 0\n  · simp only [hr, map_zero, orderTop_zero, le_top]\n  · rw [orderTop_single hr]\n\n"}
{"name":"HahnSeries.lt_orderTop_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nr : R\ng g' : Γ\nhgg' : LT.lt g g'\n⊢ LT.lt (↑g) ((HahnSeries.single g') r).orderTop","decl":"theorem lt_orderTop_single {g g' : Γ} (hgg' : g < g') : g < (single g' r).orderTop :=\n  lt_of_lt_of_le (WithTop.coe_lt_coe.mpr hgg') orderTop_single_le\n\n"}
{"name":"HahnSeries.coeff_eq_zero_of_lt_orderTop","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\ni : Γ\nhi : LT.lt (↑i) x.orderTop\n⊢ Eq (x.coeff i) 0","decl":"theorem coeff_eq_zero_of_lt_orderTop {x : HahnSeries Γ R} {i : Γ} (hi : i < x.orderTop) :\n    x.coeff i = 0 := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · exact coeff_zero\n  contrapose! hi\n  rw [← mem_support] at hi\n  rw [orderTop_of_ne hx, WithTop.coe_lt_coe]\n  exact Set.IsWF.not_lt_min _ _ hi\n\n"}
{"name":"HahnSeries.leadingCoeff_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\n⊢ Eq (HahnSeries.leadingCoeff 0) 0","decl":"@[simp]\ntheorem leadingCoeff_zero : leadingCoeff (0 : HahnSeries Γ R) = 0 :=\n  dif_pos rfl\n\n"}
{"name":"HahnSeries.leadingCoeff_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Eq x.leadingCoeff (x.coeff (⋯.min ⋯))","decl":"theorem leadingCoeff_of_ne {x : HahnSeries Γ R} (hx : x ≠ 0) :\n    x.leadingCoeff = x.coeff (x.isWF_support.min (support_nonempty_iff.2 hx)) :=\n  dif_neg hx\n\n"}
{"name":"HahnSeries.leadingCoeff_eq_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff (Eq x.leadingCoeff 0) (Eq x 0)","decl":"theorem leadingCoeff_eq_iff {x : HahnSeries Γ R} : x.leadingCoeff = 0 ↔ x = 0 := by\n  refine { mp := ?_, mpr := fun hx => hx ▸ leadingCoeff_zero }\n  contrapose!\n  exact fun hx => (leadingCoeff_of_ne hx) ▸ coeff_orderTop_ne (orderTop_of_ne hx)\n\n"}
{"name":"HahnSeries.leadingCoeff_ne_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\nx : HahnSeries Γ R\n⊢ Iff (Ne x.leadingCoeff 0) (Ne x 0)","decl":"theorem leadingCoeff_ne_iff {x : HahnSeries Γ R} : x.leadingCoeff ≠ 0 ↔ x ≠ 0 :=\n  leadingCoeff_eq_iff.not\n\n"}
{"name":"HahnSeries.leadingCoeff_of_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : PartialOrder Γ\ninst✝ : Zero R\na : Γ\nr : R\n⊢ Eq ((HahnSeries.single a) r).leadingCoeff r","decl":"theorem leadingCoeff_of_single {a : Γ} {r : R} : leadingCoeff (single a r) = r := by\n  simp only [leadingCoeff, single_eq_zero_iff]\n  by_cases h : r = 0 <;> simp [h]\n\n"}
{"name":"HahnSeries.order_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\n⊢ Eq (HahnSeries.order 0) 0","decl":"@[simp]\ntheorem order_zero : order (0 : HahnSeries Γ R) = 0 :=\n  dif_pos rfl\n\n"}
{"name":"HahnSeries.order_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Eq x.order (⋯.min ⋯)","decl":"theorem order_of_ne {x : HahnSeries Γ R} (hx : x ≠ 0) :\n    order x = x.isWF_support.min (support_nonempty_iff.2 hx) :=\n  dif_neg hx\n\n"}
{"name":"HahnSeries.order_eq_orderTop_of_ne","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Eq (↑x.order) x.orderTop","decl":"theorem order_eq_orderTop_of_ne {x : HahnSeries Γ R} (hx : x ≠ 0) : order x = orderTop x := by\n  rw [order_of_ne hx, orderTop_of_ne hx]\n\n"}
{"name":"HahnSeries.coeff_order_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Ne (x.coeff x.order) 0","decl":"theorem coeff_order_ne_zero {x : HahnSeries Γ R} (hx : x ≠ 0) : x.coeff x.order ≠ 0 := by\n  rw [order_of_ne hx]\n  exact x.isWF_support.min_mem (support_nonempty_iff.2 hx)\n\n"}
{"name":"HahnSeries.order_le_of_coeff_ne_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"R : Type u_3\ninst✝² : Zero R\nΓ : Type u_5\ninst✝¹ : AddMonoid Γ\ninst✝ : LinearOrder Γ\nx : HahnSeries Γ R\ng : Γ\nh : Ne (x.coeff g) 0\n⊢ LE.le x.order g","decl":"theorem order_le_of_coeff_ne_zero {Γ} [AddMonoid Γ] [LinearOrder Γ] {x : HahnSeries Γ R}\n    {g : Γ} (h : x.coeff g ≠ 0) : x.order ≤ g :=\n  le_trans (le_of_eq (order_of_ne (ne_zero_of_coeff_ne_zero h)))\n    (Set.IsWF.min_le _ _ ((mem_support _ _).2 h))\n\n"}
{"name":"HahnSeries.order_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\na : Γ\nr : R\ninst✝ : Zero Γ\nh : Ne r 0\n⊢ Eq ((HahnSeries.single a) r).order a","decl":"@[simp]\ntheorem order_single (h : r ≠ 0) : (single a r).order = a :=\n  (order_of_ne (single_ne_zero h)).trans\n    (support_single_subset\n      ((single a r).isWF_support.min_mem (support_nonempty_iff.2 (single_ne_zero h))))\n\n"}
{"name":"HahnSeries.coeff_eq_zero_of_lt_order","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\ni : Γ\nhi : LT.lt i x.order\n⊢ Eq (x.coeff i) 0","decl":"theorem coeff_eq_zero_of_lt_order {x : HahnSeries Γ R} {i : Γ} (hi : i < x.order) :\n    x.coeff i = 0 := by\n  rcases eq_or_ne x 0 with (rfl | hx)\n  · simp\n  contrapose! hi\n  rw [← mem_support] at hi\n  rw [order_of_ne hx]\n  exact Set.IsWF.not_lt_min _ _ hi\n\n"}
{"name":"HahnSeries.zero_lt_orderTop_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\nhx : Ne x 0\n⊢ Iff (LT.lt 0 x.orderTop) (LT.lt 0 x.order)","decl":"theorem zero_lt_orderTop_iff {x : HahnSeries Γ R} (hx : x ≠ 0) :\n    0 < x.orderTop ↔ 0 < x.order := by\n  simp_all [orderTop_of_ne hx, order_of_ne hx]\n\n"}
{"name":"HahnSeries.zero_lt_orderTop_of_order","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\nhx : LT.lt 0 x.order\n⊢ LT.lt 0 x.orderTop","decl":"theorem zero_lt_orderTop_of_order {x : HahnSeries Γ R} (hx : 0 < x.order) : 0 < x.orderTop := by\n  by_cases h : x = 0\n  · simp_all only [order_zero, lt_self_iff_false]\n  · exact (zero_lt_orderTop_iff h).mpr hx\n\n"}
{"name":"HahnSeries.zero_le_orderTop_iff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\n⊢ Iff (LE.le 0 x.orderTop) (LE.le 0 x.order)","decl":"theorem zero_le_orderTop_iff {x : HahnSeries Γ R} : 0 ≤ x.orderTop ↔ 0 ≤ x.order := by\n  by_cases h : x = 0\n  · simp_all\n  · simp_all [order_of_ne h, orderTop_of_ne h, zero_lt_orderTop_iff]\n\n"}
{"name":"HahnSeries.leadingCoeff_eq","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : Zero Γ\nx : HahnSeries Γ R\n⊢ Eq x.leadingCoeff (x.coeff x.order)","decl":"theorem leadingCoeff_eq {x : HahnSeries Γ R} : x.leadingCoeff = x.coeff x.order := by\n  by_cases h : x = 0\n  · rw [h, leadingCoeff_zero, coeff_zero]\n  · rw [leadingCoeff_of_ne h, order_of_ne h]\n\n"}
{"name":"HahnSeries.embDomain_coeff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((HahnSeries.embDomain f x).coeff (f a)) (x.coeff a)","decl":"@[simp]\ntheorem embDomain_coeff {f : Γ ↪o Γ'} {x : HahnSeries Γ R} {a : Γ} :\n    (embDomain f x).coeff (f a) = x.coeff a := by\n  rw [embDomain]\n  dsimp only\n  by_cases ha : a ∈ x.support\n  · rw [dif_pos (Set.mem_image_of_mem f ha)]\n    exact congr rfl (f.injective (Classical.choose_spec (Set.mem_image_of_mem f ha)).2)\n  · rw [dif_neg, Classical.not_not.1 fun c => ha ((mem_support _ _).2 c)]\n    contrapose! ha\n    obtain ⟨b, hb1, hb2⟩ := (Set.mem_image _ _ _).1 ha\n    rwa [f.injective hb2] at hb1\n\n"}
{"name":"HahnSeries.embDomain_mk_coeff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : Γ → Γ'\nhfi : Function.Injective f\nhf : ∀ (g g' : Γ), Iff (LE.le (f g) (f g')) (LE.le g g')\nx : HahnSeries Γ R\na : Γ\n⊢ Eq ((HahnSeries.embDomain { toFun := f, inj' := hfi, map_rel_iff' := ⋯ } x).coeff (f a)) (x.coeff a)","decl":"@[simp]\ntheorem embDomain_mk_coeff {f : Γ → Γ'} (hfi : Function.Injective f)\n    (hf : ∀ g g' : Γ, f g ≤ f g' ↔ g ≤ g') {x : HahnSeries Γ R} {a : Γ} :\n    (embDomain ⟨⟨f, hfi⟩, hf _ _⟩ x).coeff (f a) = x.coeff a :=\n  embDomain_coeff\n\n"}
{"name":"HahnSeries.embDomain_notin_image_support","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\nx : HahnSeries Γ R\nb : Γ'\nhb : Not (Membership.mem (Set.image (⇑f) x.support) b)\n⊢ Eq ((HahnSeries.embDomain f x).coeff b) 0","decl":"theorem embDomain_notin_image_support {f : Γ ↪o Γ'} {x : HahnSeries Γ R} {b : Γ'}\n    (hb : b ∉ f '' x.support) : (embDomain f x).coeff b = 0 :=\n  dif_neg hb\n\n"}
{"name":"HahnSeries.support_embDomain_subset","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\nx : HahnSeries Γ R\n⊢ HasSubset.Subset (HahnSeries.embDomain f x).support (Set.image (⇑f) x.support)","decl":"theorem support_embDomain_subset {f : Γ ↪o Γ'} {x : HahnSeries Γ R} :\n    support (embDomain f x) ⊆ f '' x.support := by\n  intro g hg\n  contrapose! hg\n  rw [mem_support, embDomain_notin_image_support hg, Classical.not_not]\n\n"}
{"name":"HahnSeries.embDomain_notin_range","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\nx : HahnSeries Γ R\nb : Γ'\nhb : Not (Membership.mem (Set.range ⇑f) b)\n⊢ Eq ((HahnSeries.embDomain f x).coeff b) 0","decl":"theorem embDomain_notin_range {f : Γ ↪o Γ'} {x : HahnSeries Γ R} {b : Γ'} (hb : b ∉ Set.range f) :\n    (embDomain f x).coeff b = 0 :=\n  embDomain_notin_image_support fun con => hb (Set.image_subset_range _ _ con)\n\n"}
{"name":"HahnSeries.embDomain_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\n⊢ Eq (HahnSeries.embDomain f 0) 0","decl":"@[simp]\ntheorem embDomain_zero {f : Γ ↪o Γ'} : embDomain f (0 : HahnSeries Γ R) = 0 := by\n  ext\n  simp [embDomain_notin_image_support]\n\n"}
{"name":"HahnSeries.embDomain_single","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\ng : Γ\nr : R\n⊢ Eq (HahnSeries.embDomain f ((HahnSeries.single g) r)) ((HahnSeries.single (f g)) r)","decl":"@[simp]\ntheorem embDomain_single {f : Γ ↪o Γ'} {g : Γ} {r : R} :\n    embDomain f (single g r) = single (f g) r := by\n  ext g'\n  by_cases h : g' = f g\n  · simp [h]\n  rw [embDomain_notin_image_support, coeff_single_of_ne h]\n  by_cases hr : r = 0\n  · simp [hr]\n  rwa [support_single_of_ne hr, Set.image_singleton, Set.mem_singleton_iff]\n\n"}
{"name":"HahnSeries.embDomain_injective","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nΓ' : Type u_2\nR : Type u_3\ninst✝² : PartialOrder Γ\ninst✝¹ : Zero R\ninst✝ : PartialOrder Γ'\nf : OrderEmbedding Γ Γ'\n⊢ Function.Injective (HahnSeries.embDomain f)","decl":"theorem embDomain_injective {f : Γ ↪o Γ'} :\n    Function.Injective (embDomain f : HahnSeries Γ R → HahnSeries Γ' R) := fun x y xy => by\n  ext g\n  rw [HahnSeries.ext_iff, funext_iff] at xy\n  have xyg := xy (f g)\n  rwa [embDomain_coeff, embDomain_coeff] at xyg\n\n"}
{"name":"HahnSeries.forallLTEqZero_supp_BddBelow","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝¹ : Zero R\ninst✝ : LinearOrder Γ\nf : Γ → R\nn : Γ\nhn : ∀ (m : Γ), LT.lt m n → Eq (f m) 0\n⊢ BddBelow (Function.support f)","decl":"theorem forallLTEqZero_supp_BddBelow (f : Γ → R) (n : Γ) (hn : ∀(m : Γ), m < n → f m = 0) :\n    BddBelow (Function.support f) := by\n  simp only [BddBelow, Set.Nonempty, lowerBounds]\n  use n\n  intro m hm\n  rw [Function.mem_support, ne_eq] at hm\n  exact not_lt.mp (mt (hn m) hm)\n\n"}
{"name":"HahnSeries.BddBelow_zero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : Zero R\ninst✝¹ : LinearOrder Γ\ninst✝ : Nonempty Γ\n⊢ BddBelow (Function.support 0)","decl":"theorem BddBelow_zero [Nonempty Γ] : BddBelow (Function.support (0 : Γ → R)) := by\n  simp only [support_zero', bddBelow_empty]\n\n"}
{"name":"HahnSeries.suppBddBelow_supp_PWO","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : Zero R\ninst✝¹ : LinearOrder Γ\ninst✝ : LocallyFiniteOrder Γ\nf : Γ → R\nhf : BddBelow (Function.support f)\n⊢ (Function.support f).IsPWO","decl":"theorem suppBddBelow_supp_PWO (f : Γ → R) (hf : BddBelow (Function.support f)) :\n    (Function.support f).IsPWO :=\n  hf.isWF.isPWO\n\n"}
{"name":"HahnSeries.ofSuppBddBelow_coeff","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝² : Zero R\ninst✝¹ : LinearOrder Γ\ninst✝ : LocallyFiniteOrder Γ\nf : Γ → R\nhf : BddBelow (Function.support f)\na✝ : Γ\n⊢ Eq ((HahnSeries.ofSuppBddBelow f hf).coeff a✝) (f a✝)","decl":"/-- Construct a Hahn series from any function whose support is bounded below. -/\n@[simps]\ndef ofSuppBddBelow (f : Γ → R) (hf : BddBelow (Function.support f)) : HahnSeries Γ R where\n  coeff := f\n  isPWO_support' := suppBddBelow_supp_PWO f hf\n\n"}
{"name":"HahnSeries.zero_ofSuppBddBelow","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero R\ninst✝² : LinearOrder Γ\ninst✝¹ : LocallyFiniteOrder Γ\ninst✝ : Nonempty Γ\n⊢ Eq (HahnSeries.ofSuppBddBelow 0 ⋯) 0","decl":"@[simp]\ntheorem zero_ofSuppBddBelow [Nonempty Γ] : ofSuppBddBelow 0 BddBelow_zero = (0 : HahnSeries Γ R) :=\n  rfl\n\n"}
{"name":"HahnSeries.order_ofForallLtEqZero","module":"Mathlib.RingTheory.HahnSeries.Basic","initialProofState":"Γ : Type u_1\nR : Type u_3\ninst✝³ : Zero R\ninst✝² : LinearOrder Γ\ninst✝¹ : LocallyFiniteOrder Γ\ninst✝ : Zero Γ\nf : Γ → R\nhf : Ne f 0\nn : Γ\nhn : ∀ (m : Γ), LT.lt m n → Eq (f m) 0\n⊢ LE.le n (HahnSeries.ofSuppBddBelow f ⋯).order","decl":"theorem order_ofForallLtEqZero [Zero Γ] (f : Γ → R) (hf : f ≠ 0) (n : Γ)\n    (hn : ∀(m : Γ), m < n → f m = 0) :\n    n ≤ order (ofSuppBddBelow f (forallLTEqZero_supp_BddBelow f n hn)) := by\n  dsimp only [order]\n  by_cases h : ofSuppBddBelow f (forallLTEqZero_supp_BddBelow f n hn) = 0\n  cases h\n  · exact (hf rfl).elim\n  simp_all only [dite_false]\n  rw [Set.IsWF.le_min_iff]\n  intro m hm\n  rw [HahnSeries.support, Function.mem_support, ne_eq] at hm\n  exact not_lt.mp (mt (hn m) hm)\n\n"}
