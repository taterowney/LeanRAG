{"name":"Nonneg.coe_zero","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : Preorder α\n⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\nprotected theorem coe_zero [Zero α] [Preorder α] : ((0 : { x : α // 0 ≤ x }) : α) = 0 :=\n  rfl\n\n"}
{"name":"Nonneg.mk_eq_zero","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : Preorder α\nx : α\nhx : LE.le 0 x\n⊢ Iff (Eq ⟨x, hx⟩ 0) (Eq x 0)","decl":"@[simp]\ntheorem mk_eq_zero [Zero α] [Preorder α] {x : α} (hx : 0 ≤ x) :\n    (⟨x, hx⟩ : { x : α // 0 ≤ x }) = 0 ↔ x = 0 :=\n  Subtype.ext_iff\n\n"}
{"name":"Nonneg.mk_add_mk","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\nx y : α\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Eq (HAdd.hAdd ⟨x, hx⟩ ⟨y, hy⟩) ⟨HAdd.hAdd x y, ⋯⟩","decl":"@[simp]\ntheorem mk_add_mk [AddZeroClass α] [Preorder α] [AddLeftMono α] {x y : α}\n    (hx : 0 ≤ x) (hy : 0 ≤ y) :\n    (⟨x, hx⟩ : { x : α // 0 ≤ x }) + ⟨y, hy⟩ = ⟨x + y, add_nonneg hx hy⟩ :=\n  rfl\n\n"}
{"name":"Nonneg.coe_add","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\na b : Subtype fun x => LE.le 0 x\n⊢ Eq (↑(HAdd.hAdd a b)) (HAdd.hAdd ↑a ↑b)","decl":"@[simp, norm_cast]\nprotected theorem coe_add [AddZeroClass α] [Preorder α] [AddLeftMono α]\n    (a b : { x : α // 0 ≤ x }) : ((a + b : { x : α // 0 ≤ x }) : α) = a + b :=\n  rfl\n\n"}
{"name":"Nonneg.nsmul_mk","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : AddMonoid α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\nn : Nat\nx : α\nhx : LE.le 0 x\n⊢ Eq (HSMul.hSMul n ⟨x, hx⟩) ⟨HSMul.hSMul n x, ⋯⟩","decl":"@[simp]\ntheorem nsmul_mk [AddMonoid α] [Preorder α] [AddLeftMono α] (n : ℕ) {x : α}\n    (hx : 0 ≤ x) : (n • (⟨x, hx⟩ : { x : α // 0 ≤ x })) = ⟨n • x, nsmul_nonneg hx n⟩ :=\n  rfl\n\n"}
{"name":"Nonneg.coe_nsmul","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : AddMonoid α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\nn : Nat\na : Subtype fun x => LE.le 0 x\n⊢ Eq (↑(HSMul.hSMul n a)) (HSMul.hSMul n ↑a)","decl":"@[simp, norm_cast]\nprotected theorem coe_nsmul [AddMonoid α] [Preorder α] [AddLeftMono α]\n    (n : ℕ) (a : { x : α // 0 ≤ x }) : ((n • a : { x : α // 0 ≤ x }) : α) = n • (a : α) :=\n  rfl\n\n"}
{"name":"Nonneg.coe_one","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : LE α\ninst✝ : ZeroLEOneClass α\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\nprotected theorem coe_one : ((1 : { x : α // 0 ≤ x }) : α) = 1 :=\n  rfl\n\n"}
{"name":"Nonneg.mk_eq_one","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : One α\ninst✝¹ : LE α\ninst✝ : ZeroLEOneClass α\nx : α\nhx : LE.le 0 x\n⊢ Iff (Eq ⟨x, hx⟩ 1) (Eq x 1)","decl":"@[simp]\ntheorem mk_eq_one {x : α} (hx : 0 ≤ x) :\n    (⟨x, hx⟩ : { x : α // 0 ≤ x }) = 1 ↔ x = 1 :=\n  Subtype.ext_iff\n\n"}
{"name":"Nonneg.coe_mul","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : PosMulMono α\na b : Subtype fun x => LE.le 0 x\n⊢ Eq (↑(HMul.hMul a b)) (HMul.hMul ↑a ↑b)","decl":"@[simp, norm_cast]\nprotected theorem coe_mul (a b : { x : α // 0 ≤ x }) :\n    ((a * b : { x : α // 0 ≤ x }) : α) = a * b :=\n  rfl\n\n"}
{"name":"Nonneg.mk_mul_mk","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : MulZeroClass α\ninst✝¹ : Preorder α\ninst✝ : PosMulMono α\nx y : α\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Eq (HMul.hMul ⟨x, hx⟩ ⟨y, hy⟩) ⟨HMul.hMul x y, ⋯⟩","decl":"@[simp]\ntheorem mk_mul_mk {x y : α} (hx : 0 ≤ x) (hy : 0 ≤ y) :\n    (⟨x, hx⟩ : { x : α // 0 ≤ x }) * ⟨y, hy⟩ = ⟨x * y, mul_nonneg hx hy⟩ :=\n  rfl\n\n"}
{"name":"Nonneg.nsmul_coe","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : AddMonoid α\ninst✝¹ : Preorder α\ninst✝ : AddLeftMono α\nn : Nat\nr : Subtype fun x => LE.le 0 x\n⊢ Eq (↑(HSMul.hSMul n r)) (HSMul.hSMul n ↑r)","decl":"@[norm_cast]\ntheorem nsmul_coe (n : ℕ) (r : { x : α // 0 ≤ x }) :\n    ↑(n • r) = n • (r : α) :=\n  Nonneg.coeAddMonoidHom.map_nsmul _ _\n\n"}
{"name":"Nonneg.coe_natCast","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddMonoidWithOne α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : ZeroLEOneClass α\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\nprotected theorem coe_natCast (n : ℕ) : ((↑n : { x : α // 0 ≤ x }) : α) = n :=\n  rfl\n\n"}
{"name":"Nonneg.mk_natCast","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : AddMonoidWithOne α\ninst✝² : PartialOrder α\ninst✝¹ : AddLeftMono α\ninst✝ : ZeroLEOneClass α\nn : Nat\n⊢ Eq ⟨↑n, ⋯⟩ ↑n","decl":"@[simp]\ntheorem mk_natCast (n : ℕ) : (⟨n, n.cast_nonneg'⟩ : { x : α // 0 ≤ x }) = n :=\n  rfl\n\n"}
{"name":"Nonneg.pow_nonneg","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : MonoidWithZero α\ninst✝² : Preorder α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : PosMulMono α\na : α\nH : LE.le 0 a\nn : Nat\n⊢ LE.le 0 (HPow.hPow a n)","decl":"@[simp]\ntheorem pow_nonneg {a : α} (H : 0 ≤ a) : ∀ n : ℕ, 0 ≤ a ^ n\n  | 0 => by\n    rw [pow_zero]\n    exact zero_le_one\n  | n + 1 => by\n    rw [pow_succ]\n    exact mul_nonneg (pow_nonneg H _) H\n\n"}
{"name":"Nonneg.coe_pow","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : MonoidWithZero α\ninst✝² : Preorder α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : PosMulMono α\na : Subtype fun x => LE.le 0 x\nn : Nat\n⊢ Eq (↑(HPow.hPow a n)) (HPow.hPow (↑a) n)","decl":"@[simp, norm_cast]\nprotected theorem coe_pow (a : { x : α // 0 ≤ x }) (n : ℕ) :\n    (↑(a ^ n) : α) = (a : α) ^ n :=\n  rfl\n\n"}
{"name":"Nonneg.mk_pow","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝³ : MonoidWithZero α\ninst✝² : Preorder α\ninst✝¹ : ZeroLEOneClass α\ninst✝ : PosMulMono α\nx : α\nhx : LE.le 0 x\nn : Nat\n⊢ Eq (HPow.hPow ⟨x, hx⟩ n) ⟨HPow.hPow x n, ⋯⟩","decl":"@[simp]\ntheorem mk_pow {x : α} (hx : 0 ≤ x) (n : ℕ) :\n    (⟨x, hx⟩ : { x : α // 0 ≤ x }) ^ n = ⟨x ^ n, pow_nonneg hx n⟩ :=\n  rfl\n\n"}
{"name":"Nonneg.coe_toNonneg","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : SemilatticeSup α\na : α\n⊢ Eq (↑(Nonneg.toNonneg a)) (Max.max a 0)","decl":"@[simp]\ntheorem coe_toNonneg {a : α} : (toNonneg a : α) = max a 0 :=\n  rfl\n\n"}
{"name":"Nonneg.toNonneg_of_nonneg","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : SemilatticeSup α\na : α\nh : LE.le 0 a\n⊢ Eq (Nonneg.toNonneg a) ⟨a, h⟩","decl":"@[simp]\ntheorem toNonneg_of_nonneg {a : α} (h : 0 ≤ a) : toNonneg a = ⟨a, h⟩ := by simp [toNonneg, h]\n\n"}
{"name":"Nonneg.toNonneg_coe","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : SemilatticeSup α\na : Subtype fun x => LE.le 0 x\n⊢ Eq (Nonneg.toNonneg ↑a) a","decl":"@[simp]\ntheorem toNonneg_coe {a : { x : α // 0 ≤ x }} : toNonneg (a : α) = a :=\n  toNonneg_of_nonneg a.2\n\n"}
{"name":"Nonneg.toNonneg_le","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : SemilatticeSup α\na : α\nb : Subtype fun x => LE.le 0 x\n⊢ Iff (LE.le (Nonneg.toNonneg a) b) (LE.le a ↑b)","decl":"@[simp]\ntheorem toNonneg_le {a : α} {b : { x : α // 0 ≤ x }} : toNonneg a ≤ b ↔ a ≤ b := by\n  cases' b with b hb\n  simp [toNonneg, hb]\n\n"}
{"name":"Nonneg.mk_sub_mk","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝² : Zero α\ninst✝¹ : SemilatticeSup α\ninst✝ : Sub α\nx y : α\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Eq (HSub.hSub ⟨x, hx⟩ ⟨y, hy⟩) (Nonneg.toNonneg (HSub.hSub x y))","decl":"@[simp]\ntheorem mk_sub_mk [Sub α] {x y : α} (hx : 0 ≤ x) (hy : 0 ≤ y) :\n    (⟨x, hx⟩ : { x : α // 0 ≤ x }) - ⟨y, hy⟩ = toNonneg (x - y) :=\n  rfl\n\n"}
{"name":"Nonneg.toNonneg_lt","module":"Mathlib.Algebra.Order.Nonneg.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Zero α\ninst✝ : LinearOrder α\na : Subtype fun x => LE.le 0 x\nb : α\n⊢ Iff (LT.lt a (Nonneg.toNonneg b)) (LT.lt (↑a) b)","decl":"@[simp]\ntheorem toNonneg_lt {a : { x : α // 0 ≤ x }} {b : α} : a < toNonneg b ↔ ↑a < b := by\n  cases' a with a ha\n  simp [toNonneg, ha.not_lt]\n\n"}
