{"name":"Nimber.instNoMaxOrder","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ NoMaxOrder Nimber","decl":"instance Nimber.instNoMaxOrder : NoMaxOrder Nimber := Ordinal.instNoMaxOrder\n"}
{"name":"Nimber.instZeroLEOneClass","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ ZeroLEOneClass Nimber","decl":"instance Nimber.instZeroLEOneClass : ZeroLEOneClass Nimber := Ordinal.instZeroLEOneClass\n"}
{"name":"Nimber.instNeZeroOne","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ NeZero 1","decl":"instance Nimber.instNeZeroOne : NeZero (1 : Nimber) := Ordinal.instNeZeroOne\n\n"}
{"name":"Nimber.toOrdinal_symm_eq","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq Nimber.toOrdinal.symm Ordinal.toNimber","decl":"@[simp]\ntheorem toOrdinal_symm_eq : Nimber.toOrdinal.symm = Ordinal.toNimber :=\n  rfl\n\n"}
{"name":"Nimber.toOrdinal_toNimber","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Eq (Ordinal.toNimber (Nimber.toOrdinal a)) a","decl":"@[simp]\ntheorem toOrdinal_toNimber (a : Nimber) : ∗(Nimber.toOrdinal a) = a :=\n  rfl\n\n"}
{"name":"Nimber.lt_wf","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"theorem lt_wf : @WellFounded Nimber (· < ·) :=\n  Ordinal.lt_wf\n\n"}
{"name":"Nimber.instWellFoundedLT","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ WellFoundedLT Nimber","decl":"instance : WellFoundedLT Nimber :=\n  Ordinal.wellFoundedLT\n\n"}
{"name":"Nimber.bot_eq_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq Bot.bot 0","decl":"@[simp]\ntheorem bot_eq_zero : ⊥ = 0 :=\n  rfl\n\n"}
{"name":"Nimber.toOrdinal_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq (Nimber.toOrdinal 0) 0","decl":"@[simp]\ntheorem toOrdinal_zero : toOrdinal 0 = 0 :=\n  rfl\n\n"}
{"name":"Nimber.toOrdinal_one","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq (Nimber.toOrdinal 1) 1","decl":"@[simp]\ntheorem toOrdinal_one : toOrdinal 1 = 1 :=\n  rfl\n\n"}
{"name":"Nimber.toOrdinal_eq_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Iff (Eq (Nimber.toOrdinal a) 0) (Eq a 0)","decl":"@[simp]\ntheorem toOrdinal_eq_zero {a} : toOrdinal a = 0 ↔ a = 0 :=\n  Iff.rfl\n\n"}
{"name":"Nimber.toOrdinal_eq_one","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Iff (Eq (Nimber.toOrdinal a) 1) (Eq a 1)","decl":"@[simp]\ntheorem toOrdinal_eq_one {a} : toOrdinal a = 1 ↔ a = 1 :=\n  Iff.rfl\n\n"}
{"name":"Nimber.toOrdinal_max","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Eq (Nimber.toOrdinal (Max.max a b)) (Max.max (Nimber.toOrdinal a) (Nimber.toOrdinal b))","decl":"@[simp]\ntheorem toOrdinal_max (a b : Nimber) : toOrdinal (max a b) = max (toOrdinal a) (toOrdinal b) :=\n  rfl\n\n"}
{"name":"Nimber.toOrdinal_min","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Eq (Nimber.toOrdinal (Min.min a b)) (Min.min (Nimber.toOrdinal a) (Nimber.toOrdinal b))","decl":"@[simp]\ntheorem toOrdinal_min (a b : Nimber) : toOrdinal (min a b) = min (toOrdinal a) (toOrdinal b) :=\n  rfl\n\n"}
{"name":"Nimber.succ_def","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Eq (Order.succ a) (Ordinal.toNimber (HAdd.hAdd (Nimber.toOrdinal a) 1))","decl":"theorem succ_def (a : Nimber) : succ a = ∗(toOrdinal a + 1) :=\n  rfl\n\n"}
{"name":"Nimber.induction","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"p : Nimber → Prop\ni : Nimber\nx✝ : ∀ (j : Nimber), (∀ (k : Nimber), LT.lt k j → p k) → p j\n⊢ p i","decl":"/-- `Ordinal.induction` but for `Nimber`. -/\ntheorem induction {p : Nimber → Prop} : ∀ (i) (_ : ∀ j, (∀ k, k < j → p k) → p j), p i :=\n  Ordinal.induction\n\n"}
{"name":"Nimber.le_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Iff (LE.le a 0) (Eq a 0)","decl":"protected theorem le_zero {a : Nimber} : a ≤ 0 ↔ a = 0 :=\n  Ordinal.le_zero\n\n"}
{"name":"Nimber.not_lt_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Not (LT.lt a 0)","decl":"protected theorem not_lt_zero (a : Nimber) : ¬ a < 0 :=\n  Ordinal.not_lt_zero a\n\n"}
{"name":"Nimber.pos_iff_ne_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Iff (LT.lt 0 a) (Ne a 0)","decl":"protected theorem pos_iff_ne_zero {a : Nimber} : 0 < a ↔ a ≠ 0 :=\n  Ordinal.pos_iff_ne_zero\n\n"}
{"name":"Nimber.lt_one_iff_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Iff (LT.lt a 1) (Eq a 0)","decl":"theorem lt_one_iff_zero {a : Nimber} : a < 1 ↔ a = 0 :=\n  Ordinal.lt_one_iff_zero\n\n"}
{"name":"Nimber.eq_nat_of_le_nat","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\nb : Nat\nh : LE.le a (Ordinal.toNimber ↑b)\n⊢ Exists fun c => Eq a (Ordinal.toNimber ↑c)","decl":"theorem eq_nat_of_le_nat {a : Nimber} {b : ℕ} (h : a ≤ ∗b) : ∃ c : ℕ, a = ∗c :=\n  Ordinal.lt_omega0.1 (h.trans_lt (nat_lt_omega0 b))\n\n"}
{"name":"Nimber.small_Iio","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Small.{u, u + 1} ↑(Set.Iio a)","decl":"instance small_Iio (a : Nimber.{u}) : Small.{u} (Set.Iio a) := Ordinal.small_Iio a\n"}
{"name":"Nimber.small_Iic","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Small.{u, u + 1} ↑(Set.Iic a)","decl":"instance small_Iic (a : Nimber.{u}) : Small.{u} (Set.Iic a) := Ordinal.small_Iic a\n"}
{"name":"Nimber.small_Ico","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Small.{u, u + 1} ↑(Set.Ico a b)","decl":"instance small_Ico (a b : Nimber.{u}) : Small.{u} (Set.Ico a b) := Ordinal.small_Ico a b\n"}
{"name":"Nimber.small_Icc","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Small.{u, u + 1} ↑(Set.Icc a b)","decl":"instance small_Icc (a b : Nimber.{u}) : Small.{u} (Set.Icc a b) := Ordinal.small_Icc a b\n"}
{"name":"Nimber.small_Ioo","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Small.{u, u + 1} ↑(Set.Ioo a b)","decl":"instance small_Ioo (a b : Nimber.{u}) : Small.{u} (Set.Ioo a b) := Ordinal.small_Ioo a b\n"}
{"name":"Nimber.small_Ioc","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Small.{u, u + 1} ↑(Set.Ioc a b)","decl":"instance small_Ioc (a b : Nimber.{u}) : Small.{u} (Set.Ioc a b) := Ordinal.small_Ioc a b\n\n"}
{"name":"Nimber.not_bddAbove_compl_of_small","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"s : Set Nimber\ninst✝ : Small.{u, u + 1} ↑s\n⊢ Not (BddAbove (HasCompl.compl s))","decl":"theorem not_bddAbove_compl_of_small (s : Set Nimber.{u}) [Small.{u} s] : ¬ BddAbove sᶜ :=\n  Ordinal.not_bddAbove_compl_of_small s\n\n"}
{"name":"not_small_nimber","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Not (Small.{u, max (u + 1) (v + 1)} Nimber)","decl":"theorem not_small_nimber : ¬ Small.{u} Nimber.{max u v} :=\n  not_small_ordinal\n\n"}
{"name":"Ordinal.toNimber_symm_eq","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq Ordinal.toNimber.symm Nimber.toOrdinal","decl":"@[simp]\ntheorem toNimber_symm_eq : toNimber.symm = Nimber.toOrdinal :=\n  rfl\n\n"}
{"name":"Ordinal.toNimber_toOrdinal","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Eq (Nimber.toOrdinal (Ordinal.toNimber a)) a","decl":"@[simp]\ntheorem toNimber_toOrdinal (a : Ordinal) : Nimber.toOrdinal (∗a) = a :=\n  rfl\n\n"}
{"name":"Ordinal.toNimber_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq (Ordinal.toNimber 0) 0","decl":"@[simp]\ntheorem toNimber_zero : ∗0 = 0 :=\n  rfl\n\n"}
{"name":"Ordinal.toNimber_one","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ Eq (Ordinal.toNimber 1) 1","decl":"@[simp]\ntheorem toNimber_one : ∗1 = 1 :=\n  rfl\n\n"}
{"name":"Ordinal.toNimber_eq_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.toNimber a) 0) (Eq a 0)","decl":"@[simp]\ntheorem toNimber_eq_zero {a} : ∗a = 0 ↔ a = 0 :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.toNimber_eq_one","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Ordinal.{u_1}\n⊢ Iff (Eq (Ordinal.toNimber a) 1) (Eq a 1)","decl":"@[simp]\ntheorem toNimber_eq_one {a} : ∗a = 1 ↔ a = 1 :=\n  Iff.rfl\n\n"}
{"name":"Ordinal.toNimber_max","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (Ordinal.toNimber (Max.max a b)) (Max.max (Ordinal.toNimber a) (Ordinal.toNimber b))","decl":"@[simp]\ntheorem toNimber_max (a b : Ordinal) : ∗(max a b) = max (∗a) (∗b) :=\n  rfl\n\n"}
{"name":"Ordinal.toNimber_min","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Ordinal.{u_1}\n⊢ Eq (Ordinal.toNimber (Min.min a b)) (Min.min (Ordinal.toNimber a) (Ordinal.toNimber b))","decl":"@[simp]\ntheorem toNimber_min (a b : Ordinal) : ∗(min a b) = min (∗a) (∗b) :=\n  rfl\n\n"}
{"name":"Nimber.add_def","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Eq (HAdd.hAdd a b) (InfSet.sInf (HasCompl.compl (setOf fun x => Or (Exists fun a' => And (LT.lt a' a) (Eq (HAdd.hAdd a' b) x)) (Exists fun b' => And (LT.lt b' b) (Eq (HAdd.hAdd a b') x)))))","decl":"theorem add_def (a b : Nimber) :\n    a + b = sInf {x | (∃ a' < a, a' + b = x) ∨ ∃ b' < b, a + b' = x}ᶜ := by\n  change Nimber.add a b = _\n  rw [Nimber.add]\n  simp_rw [exists_prop]\n  rfl\n\n"}
{"name":"Nimber.exists_of_lt_add","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b c : Nimber\nh : LT.lt c (HAdd.hAdd a b)\n⊢ Or (Exists fun a' => And (LT.lt a' a) (Eq (HAdd.hAdd a' b) c)) (Exists fun b' => And (LT.lt b' b) (Eq (HAdd.hAdd a b') c))","decl":"theorem exists_of_lt_add (h : c < a + b) : (∃ a' < a, a' + b = c) ∨ ∃ b' < b, a + b' = c := by\n  rw [add_def] at h\n  have := not_mem_of_lt_csInf' h\n  rwa [Set.mem_compl_iff, not_not] at this\n\n"}
{"name":"Nimber.add_le_of_forall_ne","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b c : Nimber\nh₁ : ∀ (a' : Nimber), LT.lt a' a → Ne (HAdd.hAdd a' b) c\nh₂ : ∀ (b' : Nimber), LT.lt b' b → Ne (HAdd.hAdd a b') c\n⊢ LE.le (HAdd.hAdd a b) c","decl":"theorem add_le_of_forall_ne (h₁ : ∀ a' < a, a' + b ≠ c) (h₂ : ∀ b' < b, a + b' ≠ c) :\n    a + b ≤ c := by\n  by_contra! h\n  have := exists_of_lt_add h\n  tauto\n\n"}
{"name":"Nimber.instIsLeftCancelAdd","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ IsLeftCancelAdd Nimber","decl":"instance : IsLeftCancelAdd Nimber := by\n  constructor\n  intro a b c h\n  apply le_antisymm <;>\n  apply le_of_not_lt\n  · exact fun hc => (add_ne_of_lt a b).2 c hc h.symm\n  · exact fun hb => (add_ne_of_lt a c).2 b hb h\n\n"}
{"name":"Nimber.instIsRightCancelAdd","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"⊢ IsRightCancelAdd Nimber","decl":"instance : IsRightCancelAdd Nimber := by\n  constructor\n  intro a b c h\n  apply le_antisymm <;>\n  apply le_of_not_lt\n  · exact fun hc => (add_ne_of_lt a b).1 c hc h.symm\n  · exact fun ha => (add_ne_of_lt c b).1 a ha h\n\n"}
{"name":"Nimber.add_comm","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Eq (HAdd.hAdd a b) (HAdd.hAdd b a)","decl":"protected theorem add_comm (a b : Nimber) : a + b = b + a := by\n  rw [add_def, add_def]\n  simp_rw [or_comm]\n  congr! 7 <;>\n    (rw [and_congr_right_iff]; intro; rw [Nimber.add_comm])\ntermination_by (a, b)\n\n"}
{"name":"Nimber.add_eq_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Iff (Eq (HAdd.hAdd a b) 0) (Eq a b)","decl":"theorem add_eq_zero {a b : Nimber} : a + b = 0 ↔ a = b := by\n  constructor <;>\n    intro hab\n  · obtain h | rfl | h := lt_trichotomy a b\n    · have ha : a + a = 0 := add_eq_zero.2 rfl\n      rwa [← ha, add_right_inj, eq_comm] at hab\n    · rfl\n    · have hb : b + b = 0 := add_eq_zero.2 rfl\n      rwa [← hb, add_left_inj] at hab\n  · rw [← Nimber.le_zero]\n    apply add_le_of_forall_ne <;>\n    simp_rw [ne_eq] <;>\n    intro x hx\n    · rw [add_eq_zero, ← hab]\n      exact hx.ne\n    · rw [add_eq_zero, hab]\n      exact hx.ne'\ntermination_by (a, b)\n\n"}
{"name":"Nimber.add_ne_zero_iff","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Iff (Ne (HAdd.hAdd a b) 0) (Ne a b)","decl":"theorem add_ne_zero_iff : a + b ≠ 0 ↔ a ≠ b :=\n  add_eq_zero.not\n\n"}
{"name":"Nimber.add_self","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Eq (HAdd.hAdd a a) 0","decl":"@[simp]\ntheorem add_self (a : Nimber) : a + a = 0 :=\n  add_eq_zero.2 rfl\n\n"}
{"name":"Nimber.add_assoc","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b c : Nimber\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) c) (HAdd.hAdd a (HAdd.hAdd b c))","decl":"protected theorem add_assoc (a b c : Nimber) : a + b + c = a + (b + c) := by\n  apply le_antisymm <;>\n    apply add_le_of_forall_ne <;>\n    intro x hx <;>\n    try obtain ⟨y, hy, rfl⟩ | ⟨y, hy, rfl⟩ := exists_of_lt_add hx\n  on_goal 1 => rw [Nimber.add_assoc y, add_ne_add_left]\n  on_goal 2 => rw [Nimber.add_assoc _ y, add_ne_add_right, add_ne_add_left]\n  on_goal 3 => rw [Nimber.add_assoc _ _ x, add_ne_add_right, add_ne_add_right]\n  on_goal 4 => rw [← Nimber.add_assoc x, add_ne_add_left, add_ne_add_left]\n  on_goal 5 => rw [← Nimber.add_assoc _ y, add_ne_add_left, add_ne_add_right]\n  on_goal 6 => rw [← Nimber.add_assoc _ _ y, add_ne_add_right]\n  all_goals apply ne_of_lt; assumption\ntermination_by (a, b, c)\n\n"}
{"name":"Nimber.add_zero","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Eq (HAdd.hAdd a 0) a","decl":"protected theorem add_zero (a : Nimber) : a + 0 = a := by\n  apply le_antisymm\n  · apply add_le_of_forall_ne\n    · intro a' ha\n      rw [Nimber.add_zero]\n      exact ha.ne\n    · intro _ h\n      exact (Nimber.not_lt_zero _ h).elim\n  · by_contra! h\n    replace h := h -- needed to remind `termination_by`\n    have := Nimber.add_zero (a + 0)\n    rw [add_left_inj] at this\n    exact this.not_lt h\ntermination_by a\n\n"}
{"name":"Nimber.zero_add","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Eq (HAdd.hAdd 0 a) a","decl":"protected theorem zero_add (a : Nimber) : 0 + a = a := by\n  rw [Nimber.add_comm, Nimber.add_zero]\n\n"}
{"name":"Nimber.neg_eq","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a : Nimber\n⊢ Eq (Neg.neg a) a","decl":"@[simp]\nprotected theorem neg_eq (a : Nimber) : -a = a :=\n  rfl\n\n"}
{"name":"Nimber.add_cancel_right","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Eq (HAdd.hAdd (HAdd.hAdd a b) b) a","decl":"@[simp]\ntheorem add_cancel_right (a b : Nimber) : a + b + b = a := by\n  rw [add_assoc, add_self, add_zero]\n\n"}
{"name":"Nimber.add_cancel_left","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nimber\n⊢ Eq (HAdd.hAdd a (HAdd.hAdd a b)) b","decl":"@[simp]\ntheorem add_cancel_left (a b : Nimber) : a + (a + b) = b := by\n  rw [← add_assoc, add_self, zero_add]\n\n"}
{"name":"Nimber.add_trichotomy","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b c : Nimber\nh : Ne (HAdd.hAdd (HAdd.hAdd a b) c) 0\n⊢ Or (LT.lt (HAdd.hAdd b c) a) (Or (LT.lt (HAdd.hAdd c a) b) (LT.lt (HAdd.hAdd a b) c))","decl":"theorem add_trichotomy {a b c : Nimber} (h : a + b + c ≠ 0) :\n    b + c < a ∨ c + a < b ∨ a + b < c := by\n  rw [← Nimber.pos_iff_ne_zero] at h\n  obtain ⟨x, hx, hx'⟩ | ⟨x, hx, hx'⟩ := exists_of_lt_add h <;>\n  rw [add_eq_zero] at hx'\n  · obtain ⟨x, hx, hx'⟩ | ⟨x, hx, hx'⟩ := exists_of_lt_add (hx' ▸ hx)\n    · rw [← hx', add_comm, add_cancel_right]\n      exact Or.inl hx\n    · rw [← hx', add_comm a, add_cancel_right]\n      exact Or.inr <| Or.inl hx\n  · rw [← hx'] at hx\n    exact Or.inr <| Or.inr hx\n\n"}
{"name":"Nimber.lt_add_cases","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b c : Nimber\nh : LT.lt a (HAdd.hAdd b c)\n⊢ Or (LT.lt (HAdd.hAdd a c) b) (LT.lt (HAdd.hAdd a b) c)","decl":"theorem lt_add_cases {a b c : Nimber} (h : a < b + c) : a + c < b ∨ a + b < c := by\n  obtain ha | hb | hc := add_trichotomy <| add_assoc a b c ▸ add_ne_zero_iff.2 h.ne\n  exacts [(h.asymm ha).elim, Or.inl <| add_comm c a ▸ hb, Or.inr hc]\n\n"}
{"name":"Nimber.add_nat","module":"Mathlib.SetTheory.Nimber.Basic","initialProofState":"a b : Nat\n⊢ Eq (HAdd.hAdd (Ordinal.toNimber ↑a) (Ordinal.toNimber ↑b)) (Ordinal.toNimber ↑(HXor.hXor a b))","decl":"/-- Nimber addition of naturals corresponds to the bitwise XOR operation. -/\ntheorem add_nat (a b : ℕ) : ∗a + ∗b = ∗(a ^^^ b) := by\n  apply le_antisymm\n  · apply add_le_of_forall_ne\n    all_goals\n      intro c hc\n      obtain ⟨c, rfl⟩ := eq_nat_of_le_nat hc.le\n      rw [OrderIso.lt_iff_lt] at hc\n      replace hc := Nat.cast_lt.1 hc\n      rw [add_nat]\n      simpa using hc.ne\n  · apply le_of_not_lt\n    intro hc\n    obtain ⟨c, hc'⟩ := eq_nat_of_le_nat hc.le\n    rw [hc', OrderIso.lt_iff_lt, Nat.cast_lt] at hc\n    obtain h | h := Nat.lt_xor_cases hc\n    · apply h.ne\n      simpa [Nat.xor_comm, Nat.xor_cancel_left, ← hc'] using add_nat (c ^^^ b) b\n    · apply h.ne\n      simpa [Nat.xor_comm, Nat.xor_cancel_left, ← hc'] using add_nat a (c ^^^ a)\n\n"}
