{"name":"AlgebraicClosure.Monics.splits_finsetProd","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\ns : Finset (AlgebraicClosure.Monics k)\nf : AlgebraicClosure.Monics k\nhf : Membership.mem s f\n⊢ Polynomial.Splits (algebraMap k (s.prod fun f => ↑f).SplittingField) ↑f","decl":"lemma Monics.splits_finsetProd {s : Finset (Monics k)} {f : Monics k} (hf : f ∈ s) :\n    f.1.Splits (algebraMap k (SplittingField (∏ f ∈ s, f.1))) :=\n  (splits_prod_iff _ fun j _ ↦ j.2.ne_zero).1 (SplittingField.splits _) _ hf\n\n"}
{"name":"AlgebraicClosure.toSplittingField_coeff","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\ns : Finset (AlgebraicClosure.Monics k)\nf : AlgebraicClosure.Monics k\nh : Membership.mem s f\nn : Nat\n⊢ Eq ((AlgebraicClosure.toSplittingField s) ((AlgebraicClosure.subProdXSubC f).coeff n)) 0","decl":"theorem toSplittingField_coeff {s : Finset (Monics k)} {f} (h : f ∈ s) (n) :\n    toSplittingField s ((subProdXSubC f).coeff n) = 0 := by\n  classical\n  simp_rw [← AlgHom.coe_toRingHom, ← coeff_map, subProdXSubC, Polynomial.map_sub,\n    Polynomial.map_prod, Polynomial.map_sub, map_X, map_C, toSplittingField,\n    AlgHom.coe_toRingHom, MvPolynomial.aeval_X, dif_pos h,\n    ← (finEquivRoots (Monics.splits_finsetProd h)).symm.prod_comp, Equiv.apply_symm_apply]\n  rw [Finset.prod_coe_sort (f := fun x : _ × ℕ ↦ X - C x.1), (Multiset.toEnumFinset _)\n    |>.prod_eq_multiset_prod, ← Function.comp_def (X - C ·) Prod.fst, ← Multiset.map_map,\n    Multiset.map_toEnumFinset_fst, map_map, AlgHom.comp_algebraMap]\n  conv in map _ _ => rw [eq_prod_roots_of_splits (Monics.splits_finsetProd h)]\n  rw [f.2, map_one, C_1, one_mul, sub_self, coeff_zero]\n\n"}
{"name":"AlgebraicClosure.spanCoeffs_ne_top","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\n⊢ Ne (AlgebraicClosure.spanCoeffs k) Top.top","decl":"theorem spanCoeffs_ne_top : spanCoeffs k ≠ ⊤ := by\n  rw [Ideal.ne_top_iff_one, spanCoeffs, Ideal.span, ← Set.image_univ,\n    Finsupp.mem_span_image_iff_linearCombination]\n  rintro ⟨v, _, hv⟩\n  classical\n  replace hv := congr_arg (toSplittingField <| v.support.image Prod.fst) hv\n  rw [map_one, Finsupp.linearCombination_apply, Finsupp.sum, map_sum, Finset.sum_eq_zero] at hv\n  · exact zero_ne_one hv\n  intro j hj\n  rw [smul_eq_mul, map_mul, toSplittingField_coeff (Finset.mem_image_of_mem _ hj), mul_zero]\n\n"}
{"name":"AlgebraicClosure.maxIdeal.isMaximal","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\n⊢ (AlgebraicClosure.maxIdeal k).IsMaximal","decl":"instance maxIdeal.isMaximal : (maxIdeal k).IsMaximal :=\n  (Classical.choose_spec <| Ideal.exists_le_maximal _ <| spanCoeffs_ne_top k).1\n\n"}
{"name":"AlgebraicClosure.le_maxIdeal","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\n⊢ LE.le (AlgebraicClosure.spanCoeffs k) (AlgebraicClosure.maxIdeal k)","decl":"theorem le_maxIdeal : spanCoeffs k ≤ maxIdeal k :=\n  (Classical.choose_spec <| Ideal.exists_le_maximal _ <| spanCoeffs_ne_top k).2\n\n"}
{"name":"AlgebraicClosure.instIsScalarTower","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝⁶ : Field k\nR : Type u_1\nS : Type u_2\ninst✝⁵ : CommSemiring R\ninst✝⁴ : CommSemiring S\ninst✝³ : Algebra R S\ninst✝² : Algebra S k\ninst✝¹ : Algebra R k\ninst✝ : IsScalarTower R S k\n⊢ IsScalarTower R S (AlgebraicClosure k)","decl":"instance {R S : Type*} [CommSemiring R] [CommSemiring S] [Algebra R S] [Algebra S k] [Algebra R k]\n    [IsScalarTower R S k] : IsScalarTower R S (AlgebraicClosure k) :=\n  Ideal.Quotient.isScalarTower _ _ _\n\n"}
{"name":"AlgebraicClosure.Monics.map_eq_prod","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\nf : AlgebraicClosure.Monics k\n⊢ Eq (Polynomial.map (algebraMap k (AlgebraicClosure k)) ↑f) (Finset.univ.prod fun i => Polynomial.map (Ideal.Quotient.mk (AlgebraicClosure.maxIdeal k)) (HSub.hSub Polynomial.X (Polynomial.C (MvPolynomial.X ⟨f, i⟩))))","decl":"theorem Monics.map_eq_prod {f : Monics k} :\n    f.1.map (algebraMap k (AlgebraicClosure k)) =\n      ∏ i, map (Ideal.Quotient.mk <| maxIdeal k) (X - C (MvPolynomial.X ⟨f, i⟩)) := by\n  ext\n  dsimp [AlgebraicClosure]\n  rw [← Ideal.Quotient.mk_comp_algebraMap, ← map_map, ← Polynomial.map_prod, ← sub_eq_zero,\n    ← coeff_sub, ← Polynomial.map_sub, ← subProdXSubC, coeff_map, Ideal.Quotient.eq_zero_iff_mem]\n  refine le_maxIdeal _ (Ideal.subset_span ⟨⟨f, _⟩, rfl⟩)\n\n"}
{"name":"AlgebraicClosure.isAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\n⊢ Algebra.IsAlgebraic k (AlgebraicClosure k)","decl":"instance isAlgebraic : Algebra.IsAlgebraic k (AlgebraicClosure k) :=\n  ⟨fun z =>\n    IsIntegral.isAlgebraic <| by\n      let ⟨p, hp⟩ := Ideal.Quotient.mk_surjective z\n      rw [← hp]\n      induction p using MvPolynomial.induction_on generalizing z with\n        | h_C => exact isIntegral_algebraMap\n        | h_add _ _ ha hb => exact (ha _ rfl).add (hb _ rfl)\n        | h_X p fi ih =>\n          rw [map_mul]\n          refine (ih _ rfl).mul ⟨_, fi.1.2, ?_⟩\n          simp_rw [← eval_map, Monics.map_eq_prod, eval_prod, Polynomial.map_sub, eval_sub]\n          apply Finset.prod_eq_zero (Finset.mem_univ fi.2)\n          erw [map_C, eval_C]\n          simp⟩\n\n"}
{"name":"AlgebraicClosure.instIsAlgClosure","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\n⊢ IsAlgClosure k (AlgebraicClosure k)","decl":"instance : IsAlgClosure k (AlgebraicClosure k) := .of_splits fun f hf _ ↦ by\n  rw [show f = (⟨f, hf⟩ : Monics k) from rfl, ← splits_id_iff_splits, Monics.map_eq_prod]\n  exact splits_prod _ fun _ _ ↦ (splits_id_iff_splits _).mpr (splits_X_sub_C _)\n\n"}
{"name":"AlgebraicClosure.isAlgClosed","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝ : Field k\n⊢ IsAlgClosed (AlgebraicClosure k)","decl":"instance isAlgClosed : IsAlgClosed (AlgebraicClosure k) := IsAlgClosure.isAlgClosed k\n\n"}
{"name":"AlgebraicClosure.instCharZero","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝¹ : Field k\ninst✝ : CharZero k\n⊢ CharZero (AlgebraicClosure k)","decl":"instance [CharZero k] : CharZero (AlgebraicClosure k) :=\n  charZero_of_injective_algebraMap (RingHom.injective (algebraMap k (AlgebraicClosure k)))\n\n"}
{"name":"AlgebraicClosure.instCharP","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\ninst✝¹ : Field k\np : Nat\ninst✝ : CharP k p\n⊢ CharP (AlgebraicClosure k) p","decl":"instance {p : ℕ} [CharP k p] : CharP (AlgebraicClosure k) p :=\n  charP_of_injective_algebraMap (RingHom.injective (algebraMap k (AlgebraicClosure k))) p\n\n"}
{"name":"AlgebraicClosure.instIsAlgClosureOfIsAlgebraic","module":"Mathlib.FieldTheory.IsAlgClosed.AlgebraicClosure","initialProofState":"k : Type u\nL : Type u_1\ninst✝³ : Field k\ninst✝² : Field L\ninst✝¹ : Algebra k L\ninst✝ : Algebra.IsAlgebraic k L\n⊢ IsAlgClosure k (AlgebraicClosure L)","decl":"instance {L : Type*} [Field k] [Field L] [Algebra k L] [Algebra.IsAlgebraic k L] :\n    IsAlgClosure k (AlgebraicClosure L) where\n  isAlgebraic := .trans (L := L)\n  isAlgClosed := inferInstance\n\n"}
