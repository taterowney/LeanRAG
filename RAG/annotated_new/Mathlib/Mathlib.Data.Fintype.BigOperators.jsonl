{"name":"Fintype.prod_bool","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nf : Bool → α\n⊢ Eq (Finset.univ.prod fun b => f b) (HMul.hMul (f Bool.true) (f Bool.false))","decl":"@[to_additive]\ntheorem prod_bool [CommMonoid α] (f : Bool → α) : ∏ b, f b = f true * f false := by simp\n\n"}
{"name":"Fintype.sum_bool","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nf : Bool → α\n⊢ Eq (Finset.univ.sum fun b => f b) (HAdd.hAdd (f Bool.true) (f Bool.false))","decl":"@[to_additive]\ntheorem prod_bool [CommMonoid α] (f : Bool → α) : ∏ b, f b = f true * f false := by simp\n\n"}
{"name":"Fintype.card_eq_sum_ones","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_4\ninst✝ : Fintype α\n⊢ Eq (Fintype.card α) (Finset.univ.sum fun _a => 1)","decl":"theorem card_eq_sum_ones {α} [Fintype α] : Fintype.card α = ∑ _a : α, 1 :=\n  Finset.card_eq_sum_ones _\n\n"}
{"name":"Fintype.sum_extend_by_zero","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : AddCommMonoid α\ns : Finset ι\nf : ι → α\n⊢ Eq (Finset.univ.sum fun i => ite (Membership.mem s i) (f i) 0) (s.sum fun i => f i)","decl":"@[to_additive]\ntheorem prod_extend_by_one [CommMonoid α] (s : Finset ι) (f : ι → α) :\n    ∏ i, (if i ∈ s then f i else 1) = ∏ i ∈ s, f i := by\n  rw [← prod_filter, filter_mem_eq_inter, univ_inter]\n\n"}
{"name":"Fintype.prod_extend_by_one","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nι : Type u_4\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : CommMonoid α\ns : Finset ι\nf : ι → α\n⊢ Eq (Finset.univ.prod fun i => ite (Membership.mem s i) (f i) 1) (s.prod fun i => f i)","decl":"@[to_additive]\ntheorem prod_extend_by_one [CommMonoid α] (s : Finset ι) (f : ι → α) :\n    ∏ i, (if i ∈ s then f i else 1) = ∏ i ∈ s, f i := by\n  rw [← prod_filter, filter_mem_eq_inter, univ_inter]\n\n"}
{"name":"Fintype.prod_eq_one","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : CommMonoid M\nf : α → M\nh : ∀ (a : α), Eq (f a) 1\n⊢ Eq (Finset.univ.prod fun a => f a) 1","decl":"@[to_additive]\ntheorem prod_eq_one (f : α → M) (h : ∀ a, f a = 1) : ∏ a, f a = 1 :=\n  Finset.prod_eq_one fun a _ha => h a\n\n"}
{"name":"Fintype.sum_eq_zero","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf : α → M\nh : ∀ (a : α), Eq (f a) 0\n⊢ Eq (Finset.univ.sum fun a => f a) 0","decl":"@[to_additive]\ntheorem prod_eq_one (f : α → M) (h : ∀ a, f a = 1) : ∏ a, f a = 1 :=\n  Finset.prod_eq_one fun a _ha => h a\n\n"}
{"name":"Fintype.sum_congr","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf g : α → M\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq (Finset.univ.sum fun a => f a) (Finset.univ.sum fun a => g a)","decl":"@[to_additive]\ntheorem prod_congr (f g : α → M) (h : ∀ a, f a = g a) : ∏ a, f a = ∏ a, g a :=\n  Finset.prod_congr rfl fun a _ha => h a\n\n"}
{"name":"Fintype.prod_congr","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : CommMonoid M\nf g : α → M\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq (Finset.univ.prod fun a => f a) (Finset.univ.prod fun a => g a)","decl":"@[to_additive]\ntheorem prod_congr (f g : α → M) (h : ∀ a, f a = g a) : ∏ a, f a = ∏ a, g a :=\n  Finset.prod_congr rfl fun a _ha => h a\n\n"}
{"name":"Fintype.prod_eq_single","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : CommMonoid M\nf : α → M\na : α\nh : ∀ (x : α), Ne x a → Eq (f x) 1\n⊢ Eq (Finset.univ.prod fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_eq_single {f : α → M} (a : α) (h : ∀ x ≠ a, f x = 1) : ∏ x, f x = f a :=\n  Finset.prod_eq_single a (fun x _ hx => h x hx) fun ha => (ha (Finset.mem_univ a)).elim\n\n"}
{"name":"Fintype.sum_eq_single","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf : α → M\na : α\nh : ∀ (x : α), Ne x a → Eq (f x) 0\n⊢ Eq (Finset.univ.sum fun x => f x) (f a)","decl":"@[to_additive]\ntheorem prod_eq_single {f : α → M} (a : α) (h : ∀ x ≠ a, f x = 1) : ∏ x, f x = f a :=\n  Finset.prod_eq_single a (fun x _ hx => h x hx) fun ha => (ha (Finset.mem_univ a)).elim\n\n"}
{"name":"Fintype.sum_eq_add","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf : α → M\na b : α\nh₁ : Ne a b\nh₂ : ∀ (x : α), And (Ne x a) (Ne x b) → Eq (f x) 0\n⊢ Eq (Finset.univ.sum fun x => f x) (HAdd.hAdd (f a) (f b))","decl":"@[to_additive]\ntheorem prod_eq_mul {f : α → M} (a b : α) (h₁ : a ≠ b) (h₂ : ∀ x, x ≠ a ∧ x ≠ b → f x = 1) :\n    ∏ x, f x = f a * f b := by\n  apply Finset.prod_eq_mul a b h₁ fun x _ hx => h₂ x hx <;>\n    exact fun hc => (hc (Finset.mem_univ _)).elim\n\n"}
{"name":"Fintype.prod_eq_mul","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : CommMonoid M\nf : α → M\na b : α\nh₁ : Ne a b\nh₂ : ∀ (x : α), And (Ne x a) (Ne x b) → Eq (f x) 1\n⊢ Eq (Finset.univ.prod fun x => f x) (HMul.hMul (f a) (f b))","decl":"@[to_additive]\ntheorem prod_eq_mul {f : α → M} (a b : α) (h₁ : a ≠ b) (h₂ : ∀ x, x ≠ a ∧ x ≠ b → f x = 1) :\n    ∏ x, f x = f a * f b := by\n  apply Finset.prod_eq_mul a b h₁ fun x _ hx => h₂ x hx <;>\n    exact fun hc => (hc (Finset.mem_univ _)).elim\n\n"}
{"name":"Fintype.eq_of_subsingleton_of_sum_eq","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"M : Type u_4\ninst✝¹ : AddCommMonoid M\nι : Type u_5\ninst✝ : Subsingleton ι\ns : Finset ι\nf : ι → M\nb : M\nh : Eq (s.sum fun i => f i) b\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (f i) b","decl":"/-- If a product of a `Finset` of a subsingleton type has a given\nvalue, so do the terms in that product. -/\n@[to_additive \"If a sum of a `Finset` of a subsingleton type has a given\n  value, so do the terms in that sum.\"]\ntheorem eq_of_subsingleton_of_prod_eq {ι : Type*} [Subsingleton ι] {s : Finset ι} {f : ι → M}\n    {b : M} (h : ∏ i ∈ s, f i = b) : ∀ i ∈ s, f i = b :=\n  Finset.eq_of_card_le_one_of_prod_eq (Finset.card_le_one_of_subsingleton s) h\n\n"}
{"name":"Fintype.eq_of_subsingleton_of_prod_eq","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"M : Type u_4\ninst✝¹ : CommMonoid M\nι : Type u_5\ninst✝ : Subsingleton ι\ns : Finset ι\nf : ι → M\nb : M\nh : Eq (s.prod fun i => f i) b\ni : ι\na✝ : Membership.mem s i\n⊢ Eq (f i) b","decl":"/-- If a product of a `Finset` of a subsingleton type has a given\nvalue, so do the terms in that product. -/\n@[to_additive \"If a sum of a `Finset` of a subsingleton type has a given\n  value, so do the terms in that sum.\"]\ntheorem eq_of_subsingleton_of_prod_eq {ι : Type*} [Subsingleton ι] {s : Finset ι} {f : ι → M}\n    {b : M} (h : ∏ i ∈ s, f i = b) : ∀ i ∈ s, f i = b :=\n  Finset.eq_of_card_le_one_of_prod_eq (Finset.card_le_one_of_subsingleton s) h\n\n"}
{"name":"Fintype.prod_option","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : CommMonoid M\nf : Option α → M\n⊢ Eq (Finset.univ.prod fun i => f i) (HMul.hMul (f Option.none) (Finset.univ.prod fun i => f (Option.some i)))","decl":"@[to_additive (attr := simp)]\ntheorem Fintype.prod_option (f : Option α → M) : ∏ i, f i = f none * ∏ i, f (some i) :=\n  Finset.prod_insertNone f univ\n\n"}
{"name":"Fintype.sum_option","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝¹ : Fintype α\ninst✝ : AddCommMonoid M\nf : Option α → M\n⊢ Eq (Finset.univ.sum fun i => f i) (HAdd.hAdd (f Option.none) (Finset.univ.sum fun i => f (Option.some i)))","decl":"@[to_additive (attr := simp)]\ntheorem Fintype.prod_option (f : Option α → M) : ∏ i, f i = f none * ∏ i, f (some i) :=\n  Finset.prod_insertNone f univ\n\n"}
{"name":"Finset.card_pi","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nα : ι → Type u_6\ninst✝ : DecidableEq ι\ns : Finset ι\nt : (i : ι) → Finset (α i)\n⊢ Eq (s.pi t).card (s.prod fun i => (t i).card)","decl":"@[simp] lemma Finset.card_pi (s : Finset ι) (t : ∀ i, Finset (α i)) :\n    #(s.pi t) = ∏ i ∈ s, #(t i) := Multiset.card_pi _ _\n\n"}
{"name":"Fintype.card_piFinset","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nα : ι → Type u_6\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\ns : (i : ι) → Finset (α i)\n⊢ Eq (Fintype.piFinset s).card (Finset.univ.prod fun i => (s i).card)","decl":"@[simp] lemma card_piFinset (s : ∀ i, Finset (α i)) :\n    #(piFinset s) = ∏ i, #(s i) := by simp [piFinset, card_map]\n\n"}
{"name":"Fintype.card_piFinset_const","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_7\ns : Finset α\nn : Nat\n⊢ Eq (Fintype.piFinset fun x => s).card (HPow.hPow s.card n)","decl":"/-- This lemma is specifically designed to be used backwards, whence the specialisation to `Fin n`\nas the indexing type doesn't matter in practice. The more general forward direction lemma here is\n`Fintype.card_piFinset`. -/\nlemma card_piFinset_const {α : Type*} (s : Finset α) (n : ℕ) :\n    #(piFinset fun _ : Fin n ↦ s) = #s ^ n := by simp\n\n"}
{"name":"Fintype.card_pi","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nα : ι → Type u_6\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → Fintype (α i)\n⊢ Eq (Fintype.card ((i : ι) → α i)) (Finset.univ.prod fun i => Fintype.card (α i))","decl":"@[simp] lemma card_pi [∀ i, Fintype (α i)] : card (∀ i, α i) = ∏ i, card (α i) :=\n  card_piFinset _\n\n"}
{"name":"Fintype.card_pi_const","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_7\ninst✝ : Fintype α\nn : Nat\n⊢ Eq (Fintype.card (Fin n → α)) (HPow.hPow (Fintype.card α) n)","decl":"/-- This lemma is specifically designed to be used backwards, whence the specialisation to `Fin n`\nas the indexing type doesn't matter in practice. The more general forward direction lemma here is\n`Fintype.card_pi`. -/\nlemma card_pi_const (α : Type*) [Fintype α] (n : ℕ) : card (Fin n → α) = card α ^ n :=\n  card_piFinset_const _ _\n\n"}
{"name":"Fintype.card_sigma","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_8\nα : ι → Type u_7\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → Fintype (α i)\n⊢ Eq (Fintype.card (Sigma α)) (Finset.univ.sum fun i => Fintype.card (α i))","decl":"@[simp] nonrec lemma card_sigma {ι} {α : ι → Type*} [Fintype ι] [∀ i, Fintype (α i)] :\n    card (Sigma α) = ∑ i, card (α i) := card_sigma _ _\n\n"}
{"name":"Fintype.card_filter_piFinset_eq_of_mem","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nα : ι → Type u_6\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → DecidableEq (α i)\ns : (i : ι) → Finset (α i)\ni : ι\na : α i\nha : Membership.mem (s i) a\n⊢ Eq (Finset.filter (fun f => Eq (f i) a) (Fintype.piFinset s)).card ((Finset.univ.erase i).prod fun j => (s j).card)","decl":"/-- The number of dependent maps `f : Π j, s j` for which the `i` component is `a` is the product\nover all `j ≠ i` of `#(s j)`.\n\nNote that this is just a composition of easier lemmas, but there's some glue missing to make that\nsmooth enough not to need this lemma. -/\nlemma card_filter_piFinset_eq_of_mem [∀ i, DecidableEq (α i)]\n    (s : ∀ i, Finset (α i)) (i : ι) {a : α i} (ha : a ∈ s i) :\n    #{f ∈ piFinset s | f i = a} = ∏ j ∈ univ.erase i, #(s j) := by\n  calc\n    _ = ∏ j, #(Function.update s i {a} j) := by\n      rw [← piFinset_update_singleton_eq_filter_piFinset_eq _ _ ha, Fintype.card_piFinset]\n    _ = ∏ j, Function.update (fun j ↦ #(s j)) i 1 j :=\n      Fintype.prod_congr _ _ fun j ↦ by obtain rfl | hji := eq_or_ne j i <;> simp [*]\n    _ = _ := by simp [prod_update_of_mem, erase_eq]\n\n"}
{"name":"Fintype.card_filter_piFinset_const_eq_of_mem","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nκ : Type u_5\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype ι\ns : Finset κ\ni : ι\nx : κ\nhx : Membership.mem s x\n⊢ Eq (Finset.filter (fun f => Eq (f i) x) (Fintype.piFinset fun x => s)).card (HPow.hPow s.card (HSub.hSub (Fintype.card ι) 1))","decl":"lemma card_filter_piFinset_const_eq_of_mem (s : Finset κ) (i : ι) {x : κ} (hx : x ∈ s) :\n    #{f ∈ piFinset fun _ ↦ s | f i = x} = #s ^ (card ι - 1) :=\n  (card_filter_piFinset_eq_of_mem _ _ hx).trans <| by\n    rw [prod_const #s, card_erase_of_mem (mem_univ _), card_univ]\n\n"}
{"name":"Fintype.card_filter_piFinset_eq","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nα : ι → Type u_6\ninst✝² : DecidableEq ι\ninst✝¹ : Fintype ι\ninst✝ : (i : ι) → DecidableEq (α i)\ns : (i : ι) → Finset (α i)\ni : ι\na : α i\n⊢ Eq (Finset.filter (fun f => Eq (f i) a) (Fintype.piFinset s)).card (ite (Membership.mem (s i) a) ((Finset.univ.erase i).prod fun b => (s b).card) 0)","decl":"lemma card_filter_piFinset_eq [∀ i, DecidableEq (α i)] (s : ∀ i, Finset (α i)) (i : ι) (a : α i) :\n    #{f ∈ piFinset s | f i = a} = if a ∈ s i then ∏ b ∈ univ.erase i, #(s b) else 0 := by\n  split_ifs with h\n  · rw [card_filter_piFinset_eq_of_mem _ _ h]\n  · rw [filter_piFinset_of_not_mem _ _ _ h, Finset.card_empty]\n\n"}
{"name":"Fintype.card_filter_piFinset_const","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"ι : Type u_4\nκ : Type u_5\ninst✝² : DecidableEq ι\ninst✝¹ : DecidableEq κ\ninst✝ : Fintype ι\ns : Finset κ\ni : ι\nj : κ\n⊢ Eq (Finset.filter (fun f => Eq (f i) j) (Fintype.piFinset fun x => s)).card (ite (Membership.mem s j) (HPow.hPow s.card (HSub.hSub (Fintype.card ι) 1)) 0)","decl":"lemma card_filter_piFinset_const (s : Finset κ) (i : ι) (j : κ) :\n    #{f ∈ piFinset fun _ ↦ s | f i = j} = if j ∈ s then #s ^ (card ι - 1) else 0 :=\n  (card_filter_piFinset_eq _ _ _).trans <| by\n    rw [prod_const #s, card_erase_of_mem (mem_univ _), card_univ]\n\n"}
{"name":"Fintype.card_fun","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : DecidableEq α\ninst✝¹ : Fintype α\ninst✝ : Fintype β\n⊢ Eq (Fintype.card (α → β)) (HPow.hPow (Fintype.card β) (Fintype.card α))","decl":"theorem Fintype.card_fun [DecidableEq α] [Fintype α] [Fintype β] :\n    Fintype.card (α → β) = Fintype.card β ^ Fintype.card α := by\n  simp\n\n"}
{"name":"card_vector","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\ninst✝ : Fintype α\nn : Nat\n⊢ Eq (Fintype.card (List.Vector α n)) (HPow.hPow (Fintype.card α) n)","decl":"@[simp]\ntheorem card_vector [Fintype α] (n : ℕ) :\n    Fintype.card (List.Vector α n) = Fintype.card α ^ n := by\n  rw [Fintype.ofEquiv_card]; simp\n\n"}
{"name":"Fin.sum_univ_eq_sum_range","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nf : Nat → α\nn : Nat\n⊢ Eq (Finset.univ.sum fun i => f ↑i) ((Finset.range n).sum fun i => f i)","decl":"/-- It is equivalent to compute the product of a function over `Fin n` or `Finset.range n`. -/\n@[to_additive \"It is equivalent to sum a function over `fin n` or `finset.range n`.\"]\ntheorem Fin.prod_univ_eq_prod_range [CommMonoid α] (f : ℕ → α) (n : ℕ) :\n    ∏ i : Fin n, f i = ∏ i ∈ range n, f i :=\n  calc\n    ∏ i : Fin n, f i = ∏ i : { x // x ∈ range n }, f i :=\n      Fintype.prod_equiv (Fin.equivSubtype.trans (Equiv.subtypeEquivRight (by simp))) _ _ (by simp)\n    _ = ∏ i ∈ range n, f i := by rw [← attach_eq_univ, prod_attach]\n\n"}
{"name":"Fin.prod_univ_eq_prod_range","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nf : Nat → α\nn : Nat\n⊢ Eq (Finset.univ.prod fun i => f ↑i) ((Finset.range n).prod fun i => f i)","decl":"/-- It is equivalent to compute the product of a function over `Fin n` or `Finset.range n`. -/\n@[to_additive \"It is equivalent to sum a function over `fin n` or `finset.range n`.\"]\ntheorem Fin.prod_univ_eq_prod_range [CommMonoid α] (f : ℕ → α) (n : ℕ) :\n    ∏ i : Fin n, f i = ∏ i ∈ range n, f i :=\n  calc\n    ∏ i : Fin n, f i = ∏ i : { x // x ∈ range n }, f i :=\n      Fintype.prod_equiv (Fin.equivSubtype.trans (Equiv.subtypeEquivRight (by simp))) _ _ (by simp)\n    _ = ∏ i ∈ range n, f i := by rw [← attach_eq_univ, prod_attach]\n\n"}
{"name":"Finset.sum_fin_eq_sum_range","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"β : Type u_2\ninst✝ : AddCommMonoid β\nn : Nat\nc : Fin n → β\n⊢ Eq (Finset.univ.sum fun i => c i) ((Finset.range n).sum fun i => dite (LT.lt i n) (fun h => c ⟨i, h⟩) fun h => 0)","decl":"@[to_additive]\ntheorem Finset.prod_fin_eq_prod_range [CommMonoid β] {n : ℕ} (c : Fin n → β) :\n    ∏ i, c i = ∏ i ∈ Finset.range n, if h : i < n then c ⟨i, h⟩ else 1 := by\n  rw [← Fin.prod_univ_eq_prod_range, Finset.prod_congr rfl]\n  rintro ⟨i, hi⟩ _\n  simp only [hi, dif_pos]\n\n"}
{"name":"Finset.prod_fin_eq_prod_range","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"β : Type u_2\ninst✝ : CommMonoid β\nn : Nat\nc : Fin n → β\n⊢ Eq (Finset.univ.prod fun i => c i) ((Finset.range n).prod fun i => dite (LT.lt i n) (fun h => c ⟨i, h⟩) fun h => 1)","decl":"@[to_additive]\ntheorem Finset.prod_fin_eq_prod_range [CommMonoid β] {n : ℕ} (c : Fin n → β) :\n    ∏ i, c i = ∏ i ∈ Finset.range n, if h : i < n then c ⟨i, h⟩ else 1 := by\n  rw [← Fin.prod_univ_eq_prod_range, Finset.prod_congr rfl]\n  rintro ⟨i, hi⟩ _\n  simp only [hi, dif_pos]\n\n"}
{"name":"Finset.sum_toFinset_eq_subtype","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nf : α → M\n⊢ Eq ((setOf fun x => p x).toFinset.sum fun a => f a) (Finset.univ.sum fun a => f ↑a)","decl":"@[to_additive]\ntheorem Finset.prod_toFinset_eq_subtype {M : Type*} [CommMonoid M] [Fintype α] (p : α → Prop)\n    [DecidablePred p] (f : α → M) : ∏ a ∈ { x | p x }.toFinset, f a = ∏ a : Subtype p, f a := by\n  rw [← Finset.prod_subtype]\n  simp_rw [Set.mem_toFinset]; intro; rfl\n\n"}
{"name":"Finset.prod_toFinset_eq_subtype","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nM : Type u_4\ninst✝² : CommMonoid M\ninst✝¹ : Fintype α\np : α → Prop\ninst✝ : DecidablePred p\nf : α → M\n⊢ Eq ((setOf fun x => p x).toFinset.prod fun a => f a) (Finset.univ.prod fun a => f ↑a)","decl":"@[to_additive]\ntheorem Finset.prod_toFinset_eq_subtype {M : Type*} [CommMonoid M] [Fintype α] (p : α → Prop)\n    [DecidablePred p] (f : α → M) : ∏ a ∈ { x | p x }.toFinset, f a = ∏ a : Subtype p, f a := by\n  rw [← Finset.prod_subtype]\n  simp_rw [Set.mem_toFinset]; intro; rfl\n\n"}
{"name":"Fintype.prod_dite","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : Fintype α\np : α → Prop\ninst✝¹ : DecidablePred p\ninst✝ : CommMonoid β\nf : (a : α) → p a → β\ng : (a : α) → Not (p a) → β\n⊢ Eq (Finset.univ.prod fun a => dite (p a) (f a) (g a)) (HMul.hMul (Finset.univ.prod fun a => f ↑a ⋯) (Finset.univ.prod fun a => g ↑a ⋯))","decl":"nonrec theorem Fintype.prod_dite [Fintype α] {p : α → Prop} [DecidablePred p] [CommMonoid β]\n    (f : ∀ a, p a → β) (g : ∀ a, ¬p a → β) :\n    (∏ a, dite (p a) (f a) (g a)) =\n    (∏ a : { a // p a }, f a a.2) * ∏ a : { a // ¬p a }, g a a.2 := by\n  simp only [prod_dite, attach_eq_univ]\n  congr 1\n  · exact (Equiv.subtypeEquivRight <| by simp).prod_comp fun x : { x // p x } => f x x.2\n  · exact (Equiv.subtypeEquivRight <| by simp).prod_comp fun x : { x // ¬p x } => g x x.2\n\n"}
{"name":"Fintype.sum_sum_elim","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α₁ : Type u_4\nα₂ : Type u_5\nM : Type u_6\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : AddCommMonoid M\nf : α₁ → M\ng : α₂ → M\n⊢ Eq (Finset.univ.sum fun x => Sum.elim f g x) (HAdd.hAdd (Finset.univ.sum fun a₁ => f a₁) (Finset.univ.sum fun a₂ => g a₂))","decl":"@[to_additive]\ntheorem Fintype.prod_sum_elim (f : α₁ → M) (g : α₂ → M) :\n    ∏ x, Sum.elim f g x = (∏ a₁, f a₁) * ∏ a₂, g a₂ :=\n  prod_disj_sum _ _ _\n\n"}
{"name":"Fintype.prod_sum_elim","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α₁ : Type u_4\nα₂ : Type u_5\nM : Type u_6\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : CommMonoid M\nf : α₁ → M\ng : α₂ → M\n⊢ Eq (Finset.univ.prod fun x => Sum.elim f g x) (HMul.hMul (Finset.univ.prod fun a₁ => f a₁) (Finset.univ.prod fun a₂ => g a₂))","decl":"@[to_additive]\ntheorem Fintype.prod_sum_elim (f : α₁ → M) (g : α₂ → M) :\n    ∏ x, Sum.elim f g x = (∏ a₁, f a₁) * ∏ a₂, g a₂ :=\n  prod_disj_sum _ _ _\n\n"}
{"name":"Fintype.prod_sum_type","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α₁ : Type u_4\nα₂ : Type u_5\nM : Type u_6\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : CommMonoid M\nf : Sum α₁ α₂ → M\n⊢ Eq (Finset.univ.prod fun x => f x) (HMul.hMul (Finset.univ.prod fun a₁ => f (Sum.inl a₁)) (Finset.univ.prod fun a₂ => f (Sum.inr a₂)))","decl":"@[to_additive (attr := simp)]\ntheorem Fintype.prod_sum_type (f : α₁ ⊕ α₂ → M) :\n    ∏ x, f x = (∏ a₁, f (Sum.inl a₁)) * ∏ a₂, f (Sum.inr a₂) :=\n  prod_disj_sum _ _ _\n\n"}
{"name":"Fintype.sum_sum_type","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"α₁ : Type u_4\nα₂ : Type u_5\nM : Type u_6\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : AddCommMonoid M\nf : Sum α₁ α₂ → M\n⊢ Eq (Finset.univ.sum fun x => f x) (HAdd.hAdd (Finset.univ.sum fun a₁ => f (Sum.inl a₁)) (Finset.univ.sum fun a₂ => f (Sum.inr a₂)))","decl":"@[to_additive (attr := simp)]\ntheorem Fintype.prod_sum_type (f : α₁ ⊕ α₂ → M) :\n    ∏ x, f x = (∏ a₁, f (Sum.inl a₁)) * ∏ a₂, f (Sum.inr a₂) :=\n  prod_disj_sum _ _ _\n\n"}
{"name":"Fintype.prod_prod_type","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : CommMonoid γ\nf : Prod α₁ α₂ → γ\n⊢ Eq (Finset.univ.prod fun x => f x) (Finset.univ.prod fun x => Finset.univ.prod fun y => f { fst := x, snd := y })","decl":"/-- The product over a product type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Fintype.prod_prod_type'`. -/\n@[to_additive Fintype.sum_prod_type \"The sum over a product type equals the sum of fiberwise sums.\nFor rewriting in the reverse direction, use `Fintype.sum_prod_type'`.\"]\ntheorem Fintype.prod_prod_type [CommMonoid γ] (f : α₁ × α₂ → γ) :\n    ∏ x, f x = ∏ x, ∏ y, f (x, y) :=\n  Finset.prod_product ..\n\n"}
{"name":"Fintype.sum_prod_type","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : AddCommMonoid γ\nf : Prod α₁ α₂ → γ\n⊢ Eq (Finset.univ.sum fun x => f x) (Finset.univ.sum fun x => Finset.univ.sum fun y => f { fst := x, snd := y })","decl":"/-- The product over a product type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Fintype.prod_prod_type'`. -/\n@[to_additive Fintype.sum_prod_type \"The sum over a product type equals the sum of fiberwise sums.\nFor rewriting in the reverse direction, use `Fintype.sum_prod_type'`.\"]\ntheorem Fintype.prod_prod_type [CommMonoid γ] (f : α₁ × α₂ → γ) :\n    ∏ x, f x = ∏ x, ∏ y, f (x, y) :=\n  Finset.prod_product ..\n\n"}
{"name":"Fintype.prod_prod_type'","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : CommMonoid γ\nf : α₁ → α₂ → γ\n⊢ Eq (Finset.univ.prod fun x => f x.1 x.2) (Finset.univ.prod fun x => Finset.univ.prod fun y => f x y)","decl":"/-- The product over a product type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Fintype.prod_prod_type`. -/\n@[to_additive Fintype.sum_prod_type' \"The sum over a product type equals the sum of fiberwise sums.\nFor rewriting in the reverse direction, use `Fintype.sum_prod_type`.\"]\ntheorem Fintype.prod_prod_type' [CommMonoid γ] (f : α₁ → α₂ → γ) :\n    ∏ x : α₁ × α₂, f x.1 x.2 = ∏ x, ∏ y, f x y :=\n  Finset.prod_product' ..\n\n"}
{"name":"Fintype.sum_prod_type'","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : AddCommMonoid γ\nf : α₁ → α₂ → γ\n⊢ Eq (Finset.univ.sum fun x => f x.1 x.2) (Finset.univ.sum fun x => Finset.univ.sum fun y => f x y)","decl":"/-- The product over a product type equals the product of the fiberwise products. For rewriting\nin the reverse direction, use `Fintype.prod_prod_type`. -/\n@[to_additive Fintype.sum_prod_type' \"The sum over a product type equals the sum of fiberwise sums.\nFor rewriting in the reverse direction, use `Fintype.sum_prod_type`.\"]\ntheorem Fintype.prod_prod_type' [CommMonoid γ] (f : α₁ → α₂ → γ) :\n    ∏ x : α₁ × α₂, f x.1 x.2 = ∏ x, ∏ y, f x y :=\n  Finset.prod_product' ..\n\n"}
{"name":"Fintype.sum_prod_type_right","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : AddCommMonoid γ\nf : Prod α₁ α₂ → γ\n⊢ Eq (Finset.univ.sum fun x => f x) (Finset.univ.sum fun y => Finset.univ.sum fun x => f { fst := x, snd := y })","decl":"@[to_additive Fintype.sum_prod_type_right]\ntheorem Fintype.prod_prod_type_right [CommMonoid γ] (f : α₁ × α₂ → γ) :\n    ∏ x, f x = ∏ y, ∏ x, f (x, y) :=\n  Finset.prod_product_right ..\n\n"}
{"name":"Fintype.prod_prod_type_right","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : CommMonoid γ\nf : Prod α₁ α₂ → γ\n⊢ Eq (Finset.univ.prod fun x => f x) (Finset.univ.prod fun y => Finset.univ.prod fun x => f { fst := x, snd := y })","decl":"@[to_additive Fintype.sum_prod_type_right]\ntheorem Fintype.prod_prod_type_right [CommMonoid γ] (f : α₁ × α₂ → γ) :\n    ∏ x, f x = ∏ y, ∏ x, f (x, y) :=\n  Finset.prod_product_right ..\n\n"}
{"name":"Fintype.prod_prod_type_right'","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : CommMonoid γ\nf : α₁ → α₂ → γ\n⊢ Eq (Finset.univ.prod fun x => f x.1 x.2) (Finset.univ.prod fun y => Finset.univ.prod fun x => f x y)","decl":"/-- An uncurried version of `Finset.prod_prod_type_right`. -/\n@[to_additive Fintype.sum_prod_type_right' \"An uncurried version of `Finset.sum_prod_type_right`\"]\ntheorem Fintype.prod_prod_type_right' [CommMonoid γ] (f : α₁ → α₂ → γ) :\n    ∏ x : α₁ × α₂, f x.1 x.2 = ∏ y, ∏ x, f x y :=\n  Finset.prod_product_right' ..\n\n"}
{"name":"Fintype.sum_prod_type_right'","module":"Mathlib.Data.Fintype.BigOperators","initialProofState":"γ : Type u_3\nα₁ : Type u_4\nα₂ : Type u_5\ninst✝² : Fintype α₁\ninst✝¹ : Fintype α₂\ninst✝ : AddCommMonoid γ\nf : α₁ → α₂ → γ\n⊢ Eq (Finset.univ.sum fun x => f x.1 x.2) (Finset.univ.sum fun y => Finset.univ.sum fun x => f x y)","decl":"/-- An uncurried version of `Finset.prod_prod_type_right`. -/\n@[to_additive Fintype.sum_prod_type_right' \"An uncurried version of `Finset.sum_prod_type_right`\"]\ntheorem Fintype.prod_prod_type_right' [CommMonoid γ] (f : α₁ → α₂ → γ) :\n    ∏ x : α₁ × α₂, f x.1 x.2 = ∏ y, ∏ x, f x y :=\n  Finset.prod_product_right' ..\n\n"}
