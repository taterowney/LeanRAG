{"name":"CategoryTheory.regularTopology.mem_sieves_of_hasEffectiveEpi","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularTopology","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preregular C\nX : C\nS : CategoryTheory.Sieve X\naâœ : Exists fun Y => Exists fun Ï€ => And (CategoryTheory.EffectiveEpi Ï€) (S.arrows Ï€)\nâŠ¢ Membership.mem ((CategoryTheory.regularTopology C) X) S","decl":"/--\nFor a preregular category, any sieve that contains an `EffectiveEpi` is a covering sieve of the\nregular topology.\nNote: This is one direction of `mem_sieves_iff_hasEffectiveEpi`, but is needed for the proof.\n-/\ntheorem mem_sieves_of_hasEffectiveEpi (S : Sieve X) :\n    (âˆƒ (Y : C) (Ï€ : Y âŸ¶ X), EffectiveEpi Ï€ âˆ§ S.arrows Ï€) â†’ (S âˆˆ (regularTopology C) X) := by\n  rintro âŸ¨Y, Ï€, hâŸ©\n  have h_le : Sieve.generate (Presieve.ofArrows (fun () â†¦ Y) (fun _ â†¦ Ï€)) â‰¤ S := by\n    rw [Sieve.generate_le_iff (Presieve.ofArrows _ _) S]\n    apply Presieve.le_of_factorsThru_sieve (Presieve.ofArrows _ _) S _\n    intro W g f\n    refine âŸ¨W, ğŸ™ W, ?_âŸ©\n    cases f\n    exact âŸ¨Ï€, âŸ¨h.2, Category.id_comp Ï€âŸ©âŸ©\n  apply Coverage.saturate_of_superset (regularCoverage C) h_le\n  exact Coverage.Saturate.of X _ âŸ¨Y, Ï€, rfl, h.1âŸ©\n\n"}
{"name":"CategoryTheory.regularTopology.instEffectiveEpiComp","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularTopology","initialProofState":"C : Type u_1\ninstâœÂ² : CategoryTheory.Category.{u_2, u_1} C\nX Y Y' : C\nÏ€ : Quiver.Hom Y X\ninstâœÂ¹ : CategoryTheory.EffectiveEpi Ï€\nÏ€' : Quiver.Hom Y' Y\ninstâœ : CategoryTheory.EffectiveEpi Ï€'\nâŠ¢ CategoryTheory.EffectiveEpi (CategoryTheory.CategoryStruct.comp Ï€' Ï€)","decl":"/-- Effective epis in a preregular category are stable under composition. -/\ninstance {Y Y' : C} (Ï€ : Y âŸ¶ X) [EffectiveEpi Ï€]\n    (Ï€' : Y' âŸ¶ Y) [EffectiveEpi Ï€'] : EffectiveEpi (Ï€' â‰« Ï€) := by\n  rw [effectiveEpi_iff_effectiveEpiFamily, â† Sieve.effectiveEpimorphic_family]\n  suffices hâ‚‚ : (Sieve.generate (Presieve.ofArrows _ _)) âˆˆ (regularTopology C) X by\n    change Nonempty _\n    rw [â† Sieve.forallYonedaIsSheaf_iff_colimit]\n    exact fun W => regularTopology.isSheaf_yoneda_obj W _ hâ‚‚\n  apply Coverage.Saturate.transitive X (Sieve.generate (Presieve.ofArrows (fun () â†¦ Y)\n      (fun () â†¦ Ï€)))\n  Â· apply Coverage.Saturate.of\n    use Y, Ï€\n  Â· intro V f âŸ¨Yâ‚, h, g, âŸ¨hY, hfâŸ©âŸ©\n    rw [â† hf, Sieve.pullback_comp]\n    apply (regularTopology C).pullback_stable'\n    apply regularTopology.mem_sieves_of_hasEffectiveEpi\n    cases hY\n    exact âŸ¨Y', Ï€', inferInstance, Y', (ğŸ™ _), Ï€' â‰« Ï€, Presieve.ofArrows.mk (), (by simp)âŸ©\n\n"}
{"name":"CategoryTheory.regularTopology.mem_sieves_iff_hasEffectiveEpi","module":"Mathlib.CategoryTheory.Sites.Coherent.RegularTopology","initialProofState":"C : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_2, u_1} C\ninstâœ : CategoryTheory.Preregular C\nX : C\nS : CategoryTheory.Sieve X\nâŠ¢ Iff (Membership.mem ((CategoryTheory.regularTopology C) X) S) (Exists fun Y => Exists fun Ï€ => And (CategoryTheory.EffectiveEpi Ï€) (S.arrows Ï€))","decl":"/-- A sieve is a cover for the regular topology if and only if it contains an `EffectiveEpi`. -/\ntheorem mem_sieves_iff_hasEffectiveEpi (S : Sieve X) :\n    (S âˆˆ (regularTopology C) X) â†”\n    âˆƒ (Y : C) (Ï€ : Y âŸ¶ X), EffectiveEpi Ï€ âˆ§ (S.arrows Ï€) := by\n  constructor\n  Â· intro h\n    induction h with\n    | of Y T hS =>\n      rcases hS with âŸ¨Y', Ï€, h'âŸ©\n      refine âŸ¨Y', Ï€, h'.2, ?_âŸ©\n      rcases h' with âŸ¨rfl, _âŸ©\n      exact âŸ¨Y', ğŸ™ Y', Ï€, Presieve.ofArrows.mk (), (by simp)âŸ©\n    | top Y => exact âŸ¨Y, (ğŸ™ Y), inferInstance, by simp only [Sieve.top_apply, forall_const]âŸ©\n    | transitive Y R S _ _ a b =>\n      rcases a with âŸ¨Yâ‚, Ï€, âŸ¨hâ‚,hâ‚‚âŸ©âŸ©\n      choose Y' Ï€' _ H using b hâ‚‚\n      exact âŸ¨Y', Ï€' â‰« Ï€, inferInstance, (by simpa using H)âŸ©\n  Â· exact regularTopology.mem_sieves_of_hasEffectiveEpi S\n\n"}
