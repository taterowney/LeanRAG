{"name":"WittVector.frobenius_verschiebung","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx : WittVector p R\nâŠ¢ Eq (WittVector.frobenius (WittVector.verschiebung x)) (HMul.hMul x â†‘p)","decl":"/-- The composition of Frobenius and Verschiebung is multiplication by `p`. -/\ntheorem frobenius_verschiebung (x : ğ• R) : frobenius (verschiebung x) = x * p := by\n  have : IsPoly p fun {R} [CommRing R] x â†¦ frobenius (verschiebung x) :=\n    IsPoly.comp (hg := frobenius_isPoly p) (hf := verschiebung_isPoly)\n  have : IsPoly p fun {R} [CommRing R] x â†¦ x * p := mulN_isPoly p p\n  ghost_calc x\n  ghost_simp [mul_comm]\n\n"}
{"name":"WittVector.verschiebung_zmod","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : WittVector p (ZMod p)\nâŠ¢ Eq (WittVector.verschiebung x) (HMul.hMul x â†‘p)","decl":"/-- Verschiebung is the same as multiplication by `p` on the ring of Witt vectors of `ZMod p`. -/\ntheorem verschiebung_zmod (x : ğ• (ZMod p)) : verschiebung x = x * p := by\n  rw [â† frobenius_verschiebung, frobenius_zmodp]\n\n"}
{"name":"WittVector.coeff_p_pow","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\ni : Nat\nâŠ¢ Eq ((HPow.hPow (â†‘p) i).coeff i) 1","decl":"theorem coeff_p_pow [CharP R p] (i : â„•) : ((p : ğ• R) ^ i).coeff i = 1 := by\n  induction' i with i h\n  Â· simp only [one_coeff_zero, Ne, pow_zero]\n  Â· rw [pow_succ, â† frobenius_verschiebung, coeff_frobenius_charP,\n      verschiebung_coeff_succ, h, one_pow]\n\n"}
{"name":"WittVector.coeff_p_pow_eq_zero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\ni j : Nat\nhj : Ne j i\nâŠ¢ Eq ((HPow.hPow (â†‘p) i).coeff j) 0","decl":"theorem coeff_p_pow_eq_zero [CharP R p] {i j : â„•} (hj : j â‰  i) : ((p : ğ• R) ^ i).coeff j = 0 := by\n  induction' i with i hi generalizing j\n  Â· rw [pow_zero, one_coeff_eq_of_pos]\n    exact Nat.pos_of_ne_zero hj\n  Â· rw [pow_succ, â† frobenius_verschiebung, coeff_frobenius_charP]\n    cases j\n    Â· rw [verschiebung_coeff_zero, zero_pow hp.out.ne_zero]\n    Â· rw [verschiebung_coeff_succ, hi (ne_of_apply_ne _ hj), zero_pow hp.out.ne_zero]\n\n"}
{"name":"WittVector.coeff_p","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\ni : Nat\nâŠ¢ Eq ((â†‘p).coeff i) (ite (Eq i 1) 1 0)","decl":"theorem coeff_p [CharP R p] (i : â„•) : (p : ğ• R).coeff i = if i = 1 then 1 else 0 := by\n  split_ifs with hi\n  Â· simpa only [hi, pow_one] using coeff_p_pow p R 1\n  Â· simpa only [pow_one] using coeff_p_pow_eq_zero p R hi\n\n"}
{"name":"WittVector.coeff_p_zero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nâŠ¢ Eq ((â†‘p).coeff 0) 0","decl":"@[simp]\ntheorem coeff_p_zero [CharP R p] : (p : ğ• R).coeff 0 = 0 := by\n  rw [coeff_p, if_neg]\n  exact zero_ne_one\n\n"}
{"name":"WittVector.coeff_p_one","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nâŠ¢ Eq ((â†‘p).coeff 1) 1","decl":"@[simp]\ntheorem coeff_p_one [CharP R p] : (p : ğ• R).coeff 1 = 1 := by rw [coeff_p, if_pos rfl]\n\n"}
{"name":"WittVector.p_nonzero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Nontrivial R\ninstâœ : CharP R p\nâŠ¢ Ne (â†‘p) 0","decl":"theorem p_nonzero [Nontrivial R] [CharP R p] : (p : ğ• R) â‰  0 := by\n  intro h\n  simpa only [h, zero_coeff, zero_ne_one] using coeff_p_one p R\n\n"}
{"name":"WittVector.FractionRing.p_nonzero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ² : CommRing R\ninstâœÂ¹ : Nontrivial R\ninstâœ : CharP R p\nâŠ¢ Ne (â†‘p) 0","decl":"theorem FractionRing.p_nonzero [Nontrivial R] [CharP R p] : (p : FractionRing (ğ• R)) â‰  0 := by\n  simpa using (IsFractionRing.injective (ğ• R) (FractionRing (ğ• R))).ne (WittVector.p_nonzero _ _)\n\n"}
{"name":"WittVector.verschiebung_mul_frobenius","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx y : WittVector p R\nâŠ¢ Eq (WittVector.verschiebung (HMul.hMul x (WittVector.frobenius y))) (HMul.hMul (WittVector.verschiebung x) y)","decl":"/-- The â€œprojection formulaâ€ for Frobenius and Verschiebung. -/\ntheorem verschiebung_mul_frobenius (x y : ğ• R) :\n    verschiebung (x * frobenius y) = verschiebung x * y := by\n  have : IsPolyâ‚‚ p fun {R} [Rcr : CommRing R] x y â†¦ verschiebung (x * frobenius y) :=\n    IsPoly.compâ‚‚ (hg := verschiebung_isPoly)\n      (hf := IsPolyâ‚‚.comp (hh := mulIsPolyâ‚‚) (hf := idIsPolyI' p) (hg := frobenius_isPoly p))\n  have : IsPolyâ‚‚ p fun {R} [CommRing R] x y â†¦ verschiebung x * y :=\n    IsPolyâ‚‚.comp (hh := mulIsPolyâ‚‚) (hf := verschiebung_isPoly) (hg := idIsPolyI' p)\n  ghost_calc x y\n  rintro âŸ¨âŸ© <;> ghost_simp [mul_assoc]\n\n"}
{"name":"WittVector.mul_charP_coeff_zero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\nâŠ¢ Eq ((HMul.hMul x â†‘p).coeff 0) 0","decl":"theorem mul_charP_coeff_zero [CharP R p] (x : ğ• R) : (x * p).coeff 0 = 0 := by\n  rw [â† frobenius_verschiebung, coeff_frobenius_charP, verschiebung_coeff_zero,\n    zero_pow hp.out.ne_zero]\n\n"}
{"name":"WittVector.mul_charP_coeff_succ","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\ni : Nat\nâŠ¢ Eq ((HMul.hMul x â†‘p).coeff (HAdd.hAdd i 1)) (HPow.hPow (x.coeff i) p)","decl":"theorem mul_charP_coeff_succ [CharP R p] (x : ğ• R) (i : â„•) :\n    (x * p).coeff (i + 1) = x.coeff i ^ p := by\n  rw [â† frobenius_verschiebung, coeff_frobenius_charP, verschiebung_coeff_succ]\n\n"}
{"name":"WittVector.mul_pow_charP_coeff_zero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\nm n : Nat\nh : LT.lt m n\nâŠ¢ Eq ((HMul.hMul x (HPow.hPow (â†‘p) n)).coeff m) 0","decl":"theorem mul_pow_charP_coeff_zero [CharP R p] (x : ğ• R) {m n : â„•} (h : m < n) :\n    (x * p ^ n).coeff m = 0 := by\n  induction' n with n ih generalizing m\n  Â· contradiction\n  Â· rw [pow_succ, â† mul_assoc]\n    cases m with\n    | zero => exact mul_charP_coeff_zero _\n    | succ m' =>\n      rw [mul_charP_coeff_succ, ih, zero_pow hp.out.ne_zero]\n      simpa using h\n\n"}
{"name":"WittVector.mul_pow_charP_coeff_succ","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\nm n : Nat\nâŠ¢ Eq ((HMul.hMul x (HPow.hPow (â†‘p) n)).coeff (HAdd.hAdd m n)) (HPow.hPow (x.coeff m) (HPow.hPow p n))","decl":"theorem mul_pow_charP_coeff_succ [CharP R p] (x : ğ• R) {m n : â„•} :\n    (x * p ^ n).coeff (m + n) = x.coeff m ^ (p ^ n) := by\n  induction' n with n ih generalizing m\n  Â· simp\n  Â· rw [pow_succ, â† mul_assoc, â† add_assoc,mul_charP_coeff_succ, pow_succ, pow_mul]\n    congr\n    exact ih\n\n"}
{"name":"WittVector.verschiebung_frobenius","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\nâŠ¢ Eq (WittVector.verschiebung (WittVector.frobenius x)) (HMul.hMul x â†‘p)","decl":"theorem verschiebung_frobenius [CharP R p] (x : ğ• R) : verschiebung (frobenius x) = x * p := by\n  ext âŸ¨iâŸ©\n  Â· rw [mul_charP_coeff_zero, verschiebung_coeff_zero]\n  Â· rw [mul_charP_coeff_succ, verschiebung_coeff_succ, coeff_frobenius_charP]\n\n"}
{"name":"WittVector.verschiebung_frobenius_comm","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nâŠ¢ Function.Commute â‡‘WittVector.verschiebung â‡‘WittVector.frobenius","decl":"theorem verschiebung_frobenius_comm [CharP R p] :\n    Function.Commute (verschiebung : ğ• R â†’ ğ• R) frobenius := fun x => by\n  rw [verschiebung_frobenius, frobenius_verschiebung]\n\n"}
{"name":"WittVector.iterate_verschiebung_coeff_eq_zero","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx : WittVector p R\nn m : Nat\nh : LT.lt m n\nâŠ¢ Eq ((Nat.iterate (â‡‘WittVector.verschiebung) n x).coeff m) 0","decl":"theorem iterate_verschiebung_coeff_eq_zero (x : ğ• R) {n : â„•} {m : â„•} (h : m < n) :\n    (verschiebung^[n] x).coeff m = 0 := by\n  induction' n with n ih generalizing m\n  Â· contradiction\n  Â· rw [iterate_succ_apply']\n    cases m with\n    | zero => exact verschiebung_coeff_zero _\n    | succ m' =>\n      rw [verschiebung_coeff_succ, ih]\n      simpa using h\n\n"}
{"name":"WittVector.iterate_verschiebung_coeff","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx : WittVector p R\nn k : Nat\nâŠ¢ Eq ((Nat.iterate (â‡‘WittVector.verschiebung) n x).coeff (HAdd.hAdd k n)) (x.coeff k)","decl":"theorem iterate_verschiebung_coeff (x : ğ• R) (n k : â„•) :\n    (verschiebung^[n] x).coeff (k + n) = x.coeff k := by\n  induction' n with k ih\n  Â· simp\n  Â· rw [iterate_succ_apply', Nat.add_succ, verschiebung_coeff_succ]\n    exact ih\n\n"}
{"name":"WittVector.iterate_verschiebung_mul_left","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœ : CommRing R\nx y : WittVector p R\ni : Nat\nâŠ¢ Eq (HMul.hMul (Nat.iterate (â‡‘WittVector.verschiebung) i x) y) (Nat.iterate (â‡‘WittVector.verschiebung) i (HMul.hMul x (Nat.iterate (â‡‘WittVector.frobenius) i y)))","decl":"theorem iterate_verschiebung_mul_left (x y : ğ• R) (i : â„•) :\n    verschiebung^[i] x * y = verschiebung^[i] (x * frobenius^[i] y) := by\n  induction' i with i ih generalizing y\n  Â· simp\n  Â· rw [iterate_succ_apply', â† verschiebung_mul_frobenius, ih, iterate_succ_apply']; rfl\n\n"}
{"name":"WittVector.iterate_verschiebung_mul","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx y : WittVector p R\ni j : Nat\nâŠ¢ Eq (HMul.hMul (Nat.iterate (â‡‘WittVector.verschiebung) i x) (Nat.iterate (â‡‘WittVector.verschiebung) j y)) (Nat.iterate (â‡‘WittVector.verschiebung) (HAdd.hAdd i j) (HMul.hMul (Nat.iterate (â‡‘WittVector.frobenius) j x) (Nat.iterate (â‡‘WittVector.frobenius) i y)))","decl":"theorem iterate_verschiebung_mul (x y : ğ• R) (i j : â„•) :\n    verschiebung^[i] x * verschiebung^[j] y =\n      verschiebung^[i + j] (frobenius^[j] x * frobenius^[i] y) := by\n  calc\n    _ = verschiebung^[i] (x * frobenius^[i] (verschiebung^[j] y)) := ?_\n    _ = verschiebung^[i] (x * verschiebung^[j] (frobenius^[i] y)) := ?_\n    _ = verschiebung^[i] (verschiebung^[j] (frobenius^[i] y) * x) := ?_\n    _ = verschiebung^[i] (verschiebung^[j] (frobenius^[i] y * frobenius^[j] x)) := ?_\n    _ = verschiebung^[i + j] (frobenius^[i] y * frobenius^[j] x) := ?_\n    _ = _ := ?_\n  Â· apply iterate_verschiebung_mul_left\n  Â· rw [verschiebung_frobenius_comm.iterate_iterate]\n  Â· rw [mul_comm]\n  Â· rw [iterate_verschiebung_mul_left]\n  Â· rw [iterate_add_apply]\n  Â· rw [mul_comm]\n\n-- Porting note: `ring_nf` doesn't handle powers yet; needed to add `Nat.pow_succ` rewrite\n"}
{"name":"WittVector.iterate_frobenius_coeff","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\ni k : Nat\nâŠ¢ Eq ((Nat.iterate (â‡‘WittVector.frobenius) i x).coeff k) (HPow.hPow (x.coeff k) (HPow.hPow p i))","decl":"theorem iterate_frobenius_coeff (x : ğ• R) (i k : â„•) :\n    (frobenius^[i] x).coeff k = x.coeff k ^ p ^ i := by\n  induction' i with i ih\n  Â· simp\n  Â· rw [iterate_succ_apply', coeff_frobenius_charP, ih, Nat.pow_succ]\n    ring_nf\n\n"}
{"name":"WittVector.iterate_verschiebung_mul_coeff","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx y : WittVector p R\ni j : Nat\nâŠ¢ Eq ((HMul.hMul (Nat.iterate (â‡‘WittVector.verschiebung) i x) (Nat.iterate (â‡‘WittVector.verschiebung) j y)).coeff (HAdd.hAdd i j)) (HMul.hMul (HPow.hPow (x.coeff 0) (HPow.hPow p j)) (HPow.hPow (y.coeff 0) (HPow.hPow p i)))","decl":"/-- This is a slightly specialized form of [Hazewinkel, *Witt Vectors*][Haze09] 6.2 equation 5. -/\ntheorem iterate_verschiebung_mul_coeff (x y : ğ• R) (i j : â„•) :\n    (verschiebung^[i] x * verschiebung^[j] y).coeff (i + j) =\n      x.coeff 0 ^ p ^ j * y.coeff 0 ^ p ^ i := by\n  calc\n    _ = (verschiebung^[i + j] (frobenius^[j] x * frobenius^[i] y)).coeff (i + j) := ?_\n    _ = (frobenius^[j] x * frobenius^[i] y).coeff 0 := ?_\n    _ = (frobenius^[j] x).coeff 0 * (frobenius^[i] y).coeff 0 := ?_\n    _ = _ := ?_\n  Â· rw [iterate_verschiebung_mul]\n  Â· convert iterate_verschiebung_coeff (p := p) (R := R) _ _ _ using 2\n    rw [zero_add]\n  Â· apply mul_coeff_zero\n  Â· simp only [iterate_frobenius_coeff]\n\n"}
{"name":"WittVector.iterate_verschiebung_iterate_frobenius","module":"Mathlib.RingTheory.WittVector.Identities","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninstâœÂ¹ : CommRing R\ninstâœ : CharP R p\nx : WittVector p R\nn : Nat\nâŠ¢ Eq (Nat.iterate (â‡‘WittVector.verschiebung) n (Nat.iterate (â‡‘WittVector.frobenius) n x)) (HMul.hMul x (HPow.hPow (â†‘p) n))","decl":"theorem iterate_verschiebung_iterate_frobenius (x : ğ• R) (n : â„•) :\n    verschiebung^[n] (frobenius^[n] x) = x * (p ^ n) := by\n  rw [â† comp_apply (f := verschiebung^[n]),\n      â† Function.Commute.comp_iterate verschiebung_frobenius_comm]\n  induction' n with n ih\n  Â· simp\n  Â· rw [iterate_succ_apply', ih, pow_succ, comp_apply, verschiebung_frobenius, mul_assoc]\n\n"}
