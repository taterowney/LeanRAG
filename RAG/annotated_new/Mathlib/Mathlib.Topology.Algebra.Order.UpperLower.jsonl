{"name":"HasUpperLowerClosure.isLowerSet_closure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\nself : HasUpperLowerClosure α\ns : Set α\na✝ : IsLowerSet s\n⊢ IsLowerSet (closure s)","decl":"/-- Ad hoc class stating that the closure of an upper set is an upper set. This is used to state\nlemmas that do not mention algebraic operations for both the additive and multiplicative versions\nsimultaneously. If you find a satisfying replacement for this typeclass, please remove it! -/\nclass HasUpperLowerClosure (α : Type*) [TopologicalSpace α] [Preorder α] : Prop where\n  isUpperSet_closure : ∀ s : Set α, IsUpperSet s → IsUpperSet (closure s)\n  isLowerSet_closure : ∀ s : Set α, IsLowerSet s → IsLowerSet (closure s)\n  isOpen_upperClosure : ∀ s : Set α, IsOpen s → IsOpen (upperClosure s : Set α)\n  isOpen_lowerClosure : ∀ s : Set α, IsOpen s → IsOpen (lowerClosure s : Set α)\n\n"}
{"name":"HasUpperLowerClosure.isUpperSet_closure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\nself : HasUpperLowerClosure α\ns : Set α\na✝ : IsUpperSet s\n⊢ IsUpperSet (closure s)","decl":"/-- Ad hoc class stating that the closure of an upper set is an upper set. This is used to state\nlemmas that do not mention algebraic operations for both the additive and multiplicative versions\nsimultaneously. If you find a satisfying replacement for this typeclass, please remove it! -/\nclass HasUpperLowerClosure (α : Type*) [TopologicalSpace α] [Preorder α] : Prop where\n  isUpperSet_closure : ∀ s : Set α, IsUpperSet s → IsUpperSet (closure s)\n  isLowerSet_closure : ∀ s : Set α, IsLowerSet s → IsLowerSet (closure s)\n  isOpen_upperClosure : ∀ s : Set α, IsOpen s → IsOpen (upperClosure s : Set α)\n  isOpen_lowerClosure : ∀ s : Set α, IsOpen s → IsOpen (lowerClosure s : Set α)\n\n"}
{"name":"HasUpperLowerClosure.isOpen_lowerClosure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\nself : HasUpperLowerClosure α\ns : Set α\na✝ : IsOpen s\n⊢ IsOpen ↑(lowerClosure s)","decl":"/-- Ad hoc class stating that the closure of an upper set is an upper set. This is used to state\nlemmas that do not mention algebraic operations for both the additive and multiplicative versions\nsimultaneously. If you find a satisfying replacement for this typeclass, please remove it! -/\nclass HasUpperLowerClosure (α : Type*) [TopologicalSpace α] [Preorder α] : Prop where\n  isUpperSet_closure : ∀ s : Set α, IsUpperSet s → IsUpperSet (closure s)\n  isLowerSet_closure : ∀ s : Set α, IsLowerSet s → IsLowerSet (closure s)\n  isOpen_upperClosure : ∀ s : Set α, IsOpen s → IsOpen (upperClosure s : Set α)\n  isOpen_lowerClosure : ∀ s : Set α, IsOpen s → IsOpen (lowerClosure s : Set α)\n\n"}
{"name":"HasUpperLowerClosure.isOpen_upperClosure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝¹ : TopologicalSpace α\ninst✝ : Preorder α\nself : HasUpperLowerClosure α\ns : Set α\na✝ : IsOpen s\n⊢ IsOpen ↑(upperClosure s)","decl":"/-- Ad hoc class stating that the closure of an upper set is an upper set. This is used to state\nlemmas that do not mention algebraic operations for both the additive and multiplicative versions\nsimultaneously. If you find a satisfying replacement for this typeclass, please remove it! -/\nclass HasUpperLowerClosure (α : Type*) [TopologicalSpace α] [Preorder α] : Prop where\n  isUpperSet_closure : ∀ s : Set α, IsUpperSet s → IsUpperSet (closure s)\n  isLowerSet_closure : ∀ s : Set α, IsLowerSet s → IsLowerSet (closure s)\n  isOpen_upperClosure : ∀ s : Set α, IsOpen s → IsOpen (upperClosure s : Set α)\n  isOpen_lowerClosure : ∀ s : Set α, IsOpen s → IsOpen (lowerClosure s : Set α)\n\n"}
{"name":"OrderedCommGroup.to_hasUpperLowerClosure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderedCommGroup α\ninst✝ : ContinuousConstSMul α α\n⊢ HasUpperLowerClosure α","decl":"@[to_additive]\ninstance (priority := 100) OrderedCommGroup.to_hasUpperLowerClosure [OrderedCommGroup α]\n    [ContinuousConstSMul α α] : HasUpperLowerClosure α where\n  isUpperSet_closure s h x y hxy hx :=\n    closure_mono (h.smul_subset <| one_le_div'.2 hxy) <| by\n      rw [closure_smul]\n      exact ⟨x, hx, div_mul_cancel _ _⟩\n  isLowerSet_closure s h x y hxy hx :=\n    closure_mono (h.smul_subset <| div_le_one'.2 hxy) <| by\n      rw [closure_smul]\n      exact ⟨x, hx, div_mul_cancel _ _⟩\n  isOpen_upperClosure s hs := by\n    rw [← mul_one s, ← mul_upperClosure]\n    exact hs.mul_right\n  isOpen_lowerClosure s hs := by\n    rw [← mul_one s, ← mul_lowerClosure]\n    exact hs.mul_right\n\n"}
{"name":"OrderedAddCommGroup.to_hasUpperLowerClosure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : OrderedAddCommGroup α\ninst✝ : ContinuousConstVAdd α α\n⊢ HasUpperLowerClosure α","decl":"@[to_additive]\ninstance (priority := 100) OrderedCommGroup.to_hasUpperLowerClosure [OrderedCommGroup α]\n    [ContinuousConstSMul α α] : HasUpperLowerClosure α where\n  isUpperSet_closure s h x y hxy hx :=\n    closure_mono (h.smul_subset <| one_le_div'.2 hxy) <| by\n      rw [closure_smul]\n      exact ⟨x, hx, div_mul_cancel _ _⟩\n  isLowerSet_closure s h x y hxy hx :=\n    closure_mono (h.smul_subset <| div_le_one'.2 hxy) <| by\n      rw [closure_smul]\n      exact ⟨x, hx, div_mul_cancel _ _⟩\n  isOpen_upperClosure s hs := by\n    rw [← mul_one s, ← mul_upperClosure]\n    exact hs.mul_right\n  isOpen_lowerClosure s hs := by\n    rw [← mul_one s, ← mul_lowerClosure]\n    exact hs.mul_right\n\n"}
{"name":"IsUpperSet.closure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\na✝ : IsUpperSet s\n⊢ IsUpperSet (closure s)","decl":"protected theorem IsUpperSet.closure : IsUpperSet s → IsUpperSet (closure s) :=\n  HasUpperLowerClosure.isUpperSet_closure _\n\n"}
{"name":"IsLowerSet.closure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\na✝ : IsLowerSet s\n⊢ IsLowerSet (closure s)","decl":"protected theorem IsLowerSet.closure : IsLowerSet s → IsLowerSet (closure s) :=\n  HasUpperLowerClosure.isLowerSet_closure _\n\n"}
{"name":"IsOpen.upperClosure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\na✝ : IsOpen s\n⊢ IsOpen ↑(upperClosure s)","decl":"protected theorem IsOpen.upperClosure : IsOpen s → IsOpen (upperClosure s : Set α) :=\n  HasUpperLowerClosure.isOpen_upperClosure _\n\n"}
{"name":"IsOpen.lowerClosure","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\na✝ : IsOpen s\n⊢ IsOpen ↑(lowerClosure s)","decl":"protected theorem IsOpen.lowerClosure : IsOpen s → IsOpen (lowerClosure s : Set α) :=\n  HasUpperLowerClosure.isOpen_lowerClosure _\n\n"}
{"name":"instHasUpperLowerClosureOrderDual","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\n⊢ HasUpperLowerClosure (OrderDual α)","decl":"instance : HasUpperLowerClosure αᵒᵈ where\n  isUpperSet_closure := @IsLowerSet.closure α _ _ _\n  isLowerSet_closure := @IsUpperSet.closure α _ _ _\n  isOpen_upperClosure := @IsOpen.lowerClosure α _ _ _\n  isOpen_lowerClosure := @IsOpen.upperClosure α _ _ _\n\n/-\nNote: `s.OrdConnected` does not imply `(closure s).OrdConnected`, as we can see by taking\n`s := Ioo 0 1 × Ioo 1 2 ∪ Ioo 2 3 × Ioo 0 1` because then\n`closure s = Icc 0 1 × Icc 1 2 ∪ Icc 2 3 × Icc 0 1` is not order-connected as\n`(1, 1) ∈ closure s`, `(2, 1) ∈ closure s` but `Icc (1, 1) (2, 1) ⊈ closure s`.\n\n`s` looks like\n```\nxxooooo\nxxooooo\noooooxx\noooooxx\n```\n-/\n"}
{"name":"IsUpperSet.interior","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\nh : IsUpperSet s\n⊢ IsUpperSet (interior s)","decl":"protected theorem IsUpperSet.interior (h : IsUpperSet s) : IsUpperSet (interior s) := by\n  rw [← isLowerSet_compl, ← closure_compl]\n  exact h.compl.closure\n\n"}
{"name":"IsLowerSet.interior","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\nh : IsLowerSet s\n⊢ IsLowerSet (interior s)","decl":"protected theorem IsLowerSet.interior (h : IsLowerSet s) : IsLowerSet (interior s) :=\n  h.toDual.interior\n\n"}
{"name":"Set.OrdConnected.interior","module":"Mathlib.Topology.Algebra.Order.UpperLower","initialProofState":"α : Type u_1\ninst✝² : TopologicalSpace α\ninst✝¹ : Preorder α\ninst✝ : HasUpperLowerClosure α\ns : Set α\nh : s.OrdConnected\n⊢ (interior s).OrdConnected","decl":"protected theorem Set.OrdConnected.interior (h : s.OrdConnected) : (interior s).OrdConnected := by\n  rw [← h.upperClosure_inter_lowerClosure, interior_inter]\n  exact\n    (upperClosure s).upper.interior.ordConnected.inter (lowerClosure s).lower.interior.ordConnected\n"}
