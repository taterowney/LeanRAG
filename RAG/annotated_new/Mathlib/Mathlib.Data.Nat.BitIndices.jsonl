{"name":"Nat.bitIndices_zero","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"⊢ Eq (Nat.bitIndices 0) List.nil","decl":"@[simp] theorem bitIndices_zero : bitIndices 0 = [] := by simp [bitIndices]\n\n"}
{"name":"Nat.bitIndices_one","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"⊢ Eq (Nat.bitIndices 1) (List.cons 0 List.nil)","decl":"@[simp] theorem bitIndices_one : bitIndices 1 = [0] := by simp [bitIndices]\n\n"}
{"name":"Nat.bitIndices_bit_true","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ Eq (Nat.bit Bool.true n).bitIndices (List.cons 0 (List.map (fun x => HAdd.hAdd x 1) n.bitIndices))","decl":"theorem bitIndices_bit_true (n : ℕ) :\n    bitIndices (bit true n) = 0 :: ((bitIndices n).map (· + 1)) :=\n  binaryRec_eq _ _ (.inl rfl)\n\n"}
{"name":"Nat.bitIndices_bit_false","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ Eq (Nat.bit Bool.false n).bitIndices (List.map (fun x => HAdd.hAdd x 1) n.bitIndices)","decl":"theorem bitIndices_bit_false (n : ℕ) :\n    bitIndices (bit false n) = (bitIndices n).map (· + 1) :=\n  binaryRec_eq _ _ (.inl rfl)\n\n"}
{"name":"Nat.bitIndices_two_mul_add_one","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd (HMul.hMul 2 n) 1).bitIndices (List.cons 0 (List.map (fun x => HAdd.hAdd x 1) n.bitIndices))","decl":"@[simp] theorem bitIndices_two_mul_add_one (n : ℕ) :\n    bitIndices (2 * n + 1) = 0 :: (bitIndices n).map (· + 1) := by\n   rw [← bitIndices_bit_true, bit_true]\n\n"}
{"name":"Nat.bitIndices_two_mul","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ Eq (HMul.hMul 2 n).bitIndices (List.map (fun x => HAdd.hAdd x 1) n.bitIndices)","decl":"@[simp] theorem bitIndices_two_mul (n : ℕ) :\n    bitIndices (2 * n) = (bitIndices n).map (· + 1) := by\n  rw [← bitIndices_bit_false, bit_false]\n\n"}
{"name":"Nat.bitIndices_sorted","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ List.Sorted (fun x1 x2 => LT.lt x1 x2) n.bitIndices","decl":"@[simp] theorem bitIndices_sorted {n : ℕ} : n.bitIndices.Sorted (· < ·) := by\n  induction' n using binaryRec with b n hs\n  · simp\n  suffices List.Pairwise (fun a b ↦ a < b) n.bitIndices by\n    cases b <;> simpa [List.Sorted, bit_false, bit_true, List.pairwise_map]\n  exact List.Pairwise.imp (by simp) hs\n\n"}
{"name":"Nat.bitIndices_two_pow_mul","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"k n : Nat\n⊢ Eq (HMul.hMul (HPow.hPow 2 k) n).bitIndices (List.map (fun x => HAdd.hAdd x k) n.bitIndices)","decl":"@[simp] theorem bitIndices_two_pow_mul (k n : ℕ) :\n    bitIndices (2^k * n) = (bitIndices n).map (· + k) := by\n  induction' k with k ih\n  · simp\n  rw [add_comm, pow_add, pow_one, mul_assoc, bitIndices_two_mul, ih, List.map_map, comp_add_right]\n  simp [add_comm (a := 1)]\n\n"}
{"name":"Nat.bitIndices_two_pow","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"k : Nat\n⊢ Eq (HPow.hPow 2 k).bitIndices (List.cons k List.nil)","decl":"@[simp] theorem bitIndices_two_pow (k : ℕ) : bitIndices (2^k) = [k] := by\n  rw [← mul_one (a := 2^k), bitIndices_two_pow_mul]; simp\n\n"}
{"name":"Nat.twoPowSum_bitIndices","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ Eq (List.map (fun i => HPow.hPow 2 i) n.bitIndices).sum n","decl":"@[simp] theorem twoPowSum_bitIndices (n : ℕ) : (n.bitIndices.map (fun i ↦ 2 ^ i)).sum = n := by\n  induction' n using binaryRec with b n hs\n  · simp\n  have hrw : (fun i ↦ 2^i) ∘ (fun x ↦ x+1) = fun i ↦ 2 * 2 ^ i := by\n    ext i; simp [pow_add, mul_comm]\n  cases b\n  · simpa [hrw, List.sum_map_mul_left]\n  simp [hrw, List.sum_map_mul_left, hs, add_comm (a := 1)]\n\n"}
{"name":"Nat.bitIndices_twoPowsum","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"L : List Nat\nhL : List.Sorted (fun x1 x2 => LT.lt x1 x2) L\n⊢ Eq (List.map (fun i => HPow.hPow 2 i) L).sum.bitIndices L","decl":"/-- Together with `Nat.twoPowSum_bitIndices`, this implies a bijection between `ℕ` and `Finset ℕ`.\nSee `Finset.equivBitIndices` for this bijection. -/\ntheorem bitIndices_twoPowsum {L : List ℕ} (hL : List.Sorted (· < ·) L) :\n    (L.map (fun i ↦ 2^i)).sum.bitIndices = L := by\n  cases' L with a L\n  · simp\n  obtain ⟨haL, hL⟩ := sorted_cons.1 hL\n  simp_rw [Nat.lt_iff_add_one_le] at haL\n  have h' : ∃ (L₀ : List ℕ), L₀.Sorted (· < ·) ∧ L = L₀.map (· + a + 1) := by\n    refine ⟨L.map (· - (a+1)), ?_, ?_⟩\n    · rwa [Sorted, pairwise_map, Pairwise.and_mem,\n        Pairwise.iff (S := fun x y ↦ x ∈ L ∧ y ∈ L ∧ x < y), ← Pairwise.and_mem]\n      simp only [and_congr_right_iff]\n      exact fun x y hx _ ↦ by rw [tsub_lt_tsub_iff_right (haL _ hx)]\n    have h' : ∀ x ∈ L, ((fun x ↦ x + a + 1) ∘ (fun x ↦ x - (a + 1))) x = x := fun x hx ↦ by\n      simp only [add_assoc, Function.comp_apply]; rw [tsub_add_cancel_of_le (haL _ hx)]\n    simp [List.map_congr_left h']\n  obtain ⟨L₀, hL₀, rfl⟩ := h'\n  have _ : L₀.length < (a :: (L₀.map (· + a + 1))).length := by simp\n  have hrw : (2^·) ∘ (· + a + 1) = fun i ↦ 2^a * (2 * 2^i) := by\n    ext x; simp only [Function.comp_apply, pow_add, pow_one]; ac_rfl\n  simp only [List.map_cons, List.map_map, List.sum_map_mul_left, List.sum_cons, hrw]\n  nth_rw 1 [← mul_one (a := 2^a)]\n  rw [← mul_add, bitIndices_two_pow_mul, add_comm, bitIndices_two_mul_add_one,\n    bitIndices_twoPowsum hL₀]\n  simp [add_comm (a := 1), add_assoc]\ntermination_by L.length\n\n"}
{"name":"Nat.two_pow_le_of_mem_bitIndices","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"a n : Nat\nha : Membership.mem n.bitIndices a\n⊢ LE.le (HPow.hPow 2 a) n","decl":"theorem two_pow_le_of_mem_bitIndices (ha : a ∈ n.bitIndices) : 2^a ≤ n := by\n  rw [← twoPowSum_bitIndices n]\n  exact List.single_le_sum (by simp) _ <| mem_map_of_mem _ ha\n\n"}
{"name":"Nat.not_mem_bitIndices_self","module":"Mathlib.Data.Nat.BitIndices","initialProofState":"n : Nat\n⊢ Not (Membership.mem n.bitIndices n)","decl":"theorem not_mem_bitIndices_self (n : ℕ) : n ∉ n.bitIndices :=\n  fun h ↦ (n.lt_two_pow_self).not_le <| two_pow_le_of_mem_bitIndices h\n\n"}
