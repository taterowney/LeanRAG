{"name":"powMonoidHom_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\nn : Nat\nx✝ : α\n⊢ Eq ((powMonoidHom n) x✝) (HPow.hPow x✝ n)","decl":"/-- The `n`th power map on a commutative monoid for a natural `n`, considered as a morphism of\nmonoids. -/\n@[to_additive (attr := simps) \"Multiplication by a natural `n` on a commutative additive monoid,\nconsidered as a morphism of additive monoids.\"]\ndef powMonoidHom (n : ℕ) : α →* α where\n  toFun := (· ^ n)\n  map_one' := one_pow _\n  map_mul' a b := mul_pow a b n\n\n"}
{"name":"nsmulAddMonoidHom_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"α : Type u_1\ninst✝ : AddCommMonoid α\nn : Nat\nx✝ : α\n⊢ Eq ((nsmulAddMonoidHom n) x✝) (HSMul.hSMul n x✝)","decl":"/-- The `n`th power map on a commutative monoid for a natural `n`, considered as a morphism of\nmonoids. -/\n@[to_additive (attr := simps) \"Multiplication by a natural `n` on a commutative additive monoid,\nconsidered as a morphism of additive monoids.\"]\ndef powMonoidHom (n : ℕ) : α →* α where\n  toFun := (· ^ n)\n  map_one' := one_pow _\n  map_mul' a b := mul_pow a b n\n\n"}
{"name":"zsmulAddGroupHom_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"α : Type u_1\ninst✝ : SubtractionCommMonoid α\nn : Int\nx✝ : α\n⊢ Eq ((zsmulAddGroupHom n) x✝) (HSMul.hSMul n x✝)","decl":"/-- The `n`-th power map (for an integer `n`) on a commutative group, considered as a group\nhomomorphism. -/\n@[to_additive (attr := simps) \"Multiplication by an integer `n` on a commutative additive group,\nconsidered as an additive group homomorphism.\"]\ndef zpowGroupHom (n : ℤ) : α →* α where\n  toFun := (· ^ n)\n  map_one' := one_zpow n\n  map_mul' a b := mul_zpow a b n\n\n"}
{"name":"zpowGroupHom_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\nn : Int\nx✝ : α\n⊢ Eq ((zpowGroupHom n) x✝) (HPow.hPow x✝ n)","decl":"/-- The `n`-th power map (for an integer `n`) on a commutative group, considered as a group\nhomomorphism. -/\n@[to_additive (attr := simps) \"Multiplication by an integer `n` on a commutative additive group,\nconsidered as an additive group homomorphism.\"]\ndef zpowGroupHom (n : ℤ) : α →* α where\n  toFun := (· ^ n)\n  map_one' := one_zpow n\n  map_mul' a b := mul_zpow a b n\n\n"}
{"name":"coe_invMonoidHom","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\n⊢ Eq (⇑invMonoidHom) Inv.inv","decl":"@[simp]\ntheorem coe_invMonoidHom : (invMonoidHom : α → α) = Inv.inv := rfl\n\n"}
{"name":"invMonoidHom_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"α : Type u_1\ninst✝ : DivisionCommMonoid α\na : α\n⊢ Eq (invMonoidHom a) (Inv.inv a)","decl":"@[simp]\ntheorem invMonoidHom_apply (a : α) : invMonoidHom a = a⁻¹ := rfl\n\n"}
{"name":"MulHom.mul_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_8\nN : Type u_9\ninst✝¹ : Mul M\ninst✝ : CommSemigroup N\nf g : MulHom M N\nx : M\n⊢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply {M N} [Mul M] [CommSemigroup N] (f g : M →ₙ* N) (x : M) :\n    (f * g) x = f x * g x := rfl\n\n"}
{"name":"AddHom.add_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_8\nN : Type u_9\ninst✝¹ : Add M\ninst✝ : AddCommSemigroup N\nf g : AddHom M N\nx : M\n⊢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"@[to_additive (attr := simp)]\ntheorem mul_apply {M N} [Mul M] [CommSemigroup N] (f g : M →ₙ* N) (x : M) :\n    (f * g) x = f x * g x := rfl\n\n"}
{"name":"MulHom.mul_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : Mul M\ninst✝¹ : Mul N\ninst✝ : CommSemigroup P\ng₁ g₂ : MulHom N P\nf : MulHom M N\n⊢ Eq ((HMul.hMul g₁ g₂).comp f) (HMul.hMul (g₁.comp f) (g₂.comp f))","decl":"@[to_additive]\ntheorem mul_comp [Mul M] [Mul N] [CommSemigroup P] (g₁ g₂ : N →ₙ* P) (f : M →ₙ* N) :\n    (g₁ * g₂).comp f = g₁.comp f * g₂.comp f := rfl\n\n"}
{"name":"AddHom.add_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : Add M\ninst✝¹ : Add N\ninst✝ : AddCommSemigroup P\ng₁ g₂ : AddHom N P\nf : AddHom M N\n⊢ Eq ((HAdd.hAdd g₁ g₂).comp f) (HAdd.hAdd (g₁.comp f) (g₂.comp f))","decl":"@[to_additive]\ntheorem mul_comp [Mul M] [Mul N] [CommSemigroup P] (g₁ g₂ : N →ₙ* P) (f : M →ₙ* N) :\n    (g₁ * g₂).comp f = g₁.comp f * g₂.comp f := rfl\n\n"}
{"name":"MulHom.comp_mul","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : Mul M\ninst✝¹ : CommSemigroup N\ninst✝ : CommSemigroup P\ng : MulHom N P\nf₁ f₂ : MulHom M N\n⊢ Eq (g.comp (HMul.hMul f₁ f₂)) (HMul.hMul (g.comp f₁) (g.comp f₂))","decl":"@[to_additive]\ntheorem comp_mul [Mul M] [CommSemigroup N] [CommSemigroup P] (g : N →ₙ* P) (f₁ f₂ : M →ₙ* N) :\n    g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by\n  ext\n  simp only [mul_apply, Function.comp_apply, map_mul, coe_comp]\n\n"}
{"name":"AddHom.comp_add","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : Add M\ninst✝¹ : AddCommSemigroup N\ninst✝ : AddCommSemigroup P\ng : AddHom N P\nf₁ f₂ : AddHom M N\n⊢ Eq (g.comp (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (g.comp f₁) (g.comp f₂))","decl":"@[to_additive]\ntheorem comp_mul [Mul M] [CommSemigroup N] [CommSemigroup P] (g : N →ₙ* P) (f₁ f₂ : M →ₙ* N) :\n    g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by\n  ext\n  simp only [mul_apply, Function.comp_apply, map_mul, coe_comp]\n\n"}
{"name":"injective_iff_map_eq_zero","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"F : Type u_7\nG : Type u_8\nH : Type u_9\ninst✝³ : AddGroup G\ninst✝² : AddZeroClass H\ninst✝¹ : FunLike F G H\ninst✝ : AddMonoidHomClass F G H\nf : F\n⊢ Iff (Function.Injective ⇑f) (∀ (a : G), Eq (f a) 0 → Eq a 0)","decl":"/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`. -/\n@[to_additive\n  \"A homomorphism from an additive group to an additive monoid is injective iff\n  its kernel is trivial. For the iff statement on the triviality of the kernel,\n  see `injective_iff_map_eq_zero'`.\"]\ntheorem _root_.injective_iff_map_eq_one {G H} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H]\n    (f : F) : Function.Injective f ↔ ∀ a, f a = 1 → a = 1 :=\n  ⟨fun h _ => (map_eq_one_iff f h).mp, fun h x y hxy =>\n    mul_inv_eq_one.1 <| h _ <| by rw [map_mul, hxy, ← map_mul, mul_inv_cancel, map_one]⟩\n\n"}
{"name":"injective_iff_map_eq_one","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"F : Type u_7\nG : Type u_8\nH : Type u_9\ninst✝³ : Group G\ninst✝² : MulOneClass H\ninst✝¹ : FunLike F G H\ninst✝ : MonoidHomClass F G H\nf : F\n⊢ Iff (Function.Injective ⇑f) (∀ (a : G), Eq (f a) 1 → Eq a 1)","decl":"/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial.\nFor the iff statement on the triviality of the kernel, see `injective_iff_map_eq_one'`. -/\n@[to_additive\n  \"A homomorphism from an additive group to an additive monoid is injective iff\n  its kernel is trivial. For the iff statement on the triviality of the kernel,\n  see `injective_iff_map_eq_zero'`.\"]\ntheorem _root_.injective_iff_map_eq_one {G H} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H]\n    (f : F) : Function.Injective f ↔ ∀ a, f a = 1 → a = 1 :=\n  ⟨fun h _ => (map_eq_one_iff f h).mp, fun h x y hxy =>\n    mul_inv_eq_one.1 <| h _ <| by rw [map_mul, hxy, ← map_mul, mul_inv_cancel, map_one]⟩\n\n"}
{"name":"injective_iff_map_eq_zero'","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"F : Type u_7\nG : Type u_8\nH : Type u_9\ninst✝³ : AddGroup G\ninst✝² : AddZeroClass H\ninst✝¹ : FunLike F G H\ninst✝ : AddMonoidHomClass F G H\nf : F\n⊢ Iff (Function.Injective ⇑f) (∀ (a : G), Iff (Eq (f a) 0) (Eq a 0))","decl":"/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`. -/\n@[to_additive\n  \"A homomorphism from an additive group to an additive monoid is injective iff its\n  kernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\n  `injective_iff_map_eq_zero`.\"]\ntheorem _root_.injective_iff_map_eq_one' {G H} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H]\n    (f : F) : Function.Injective f ↔ ∀ a, f a = 1 ↔ a = 1 :=\n  (injective_iff_map_eq_one f).trans <|\n    forall_congr' fun _ => ⟨fun h => ⟨h, fun H => H.symm ▸ map_one f⟩, Iff.mp⟩\n\n"}
{"name":"injective_iff_map_eq_one'","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"F : Type u_7\nG : Type u_8\nH : Type u_9\ninst✝³ : Group G\ninst✝² : MulOneClass H\ninst✝¹ : FunLike F G H\ninst✝ : MonoidHomClass F G H\nf : F\n⊢ Iff (Function.Injective ⇑f) (∀ (a : G), Iff (Eq (f a) 1) (Eq a 1))","decl":"/-- A homomorphism from a group to a monoid is injective iff its kernel is trivial,\nstated as an iff on the triviality of the kernel.\nFor the implication, see `injective_iff_map_eq_one`. -/\n@[to_additive\n  \"A homomorphism from an additive group to an additive monoid is injective iff its\n  kernel is trivial, stated as an iff on the triviality of the kernel. For the implication, see\n  `injective_iff_map_eq_zero`.\"]\ntheorem _root_.injective_iff_map_eq_one' {G H} [Group G] [MulOneClass H]\n    [FunLike F G H] [MonoidHomClass F G H]\n    (f : F) : Function.Injective f ↔ ∀ a, f a = 1 ↔ a = 1 :=\n  (injective_iff_map_eq_one f).trans <|\n    forall_congr' fun _ => ⟨fun h => ⟨h, fun H => H.symm ▸ map_one f⟩, Iff.mp⟩\n\n"}
{"name":"AddMonoidHom.coe_of_map_add_neg","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"G : Type u_5\ninst✝¹ : AddGroup G\nH : Type u_8\ninst✝ : AddGroup H\nf : G → H\nmap_div : ∀ (a b : G), Eq (f (HAdd.hAdd a (Neg.neg b))) (HAdd.hAdd (f a) (Neg.neg (f b)))\n⊢ Eq (⇑(AddMonoidHom.ofMapAddNeg f map_div)) f","decl":"@[to_additive (attr := simp)]\ntheorem coe_of_map_mul_inv {H : Type*} [Group H] (f : G → H)\n    (map_div : ∀ a b : G, f (a * b⁻¹) = f a * (f b)⁻¹) :\n  ↑(ofMapMulInv f map_div) = f := rfl\n\n"}
{"name":"MonoidHom.coe_of_map_mul_inv","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"G : Type u_5\ninst✝¹ : Group G\nH : Type u_8\ninst✝ : Group H\nf : G → H\nmap_div : ∀ (a b : G), Eq (f (HMul.hMul a (Inv.inv b))) (HMul.hMul (f a) (Inv.inv (f b)))\n⊢ Eq (⇑(MonoidHom.ofMapMulInv f map_div)) f","decl":"@[to_additive (attr := simp)]\ntheorem coe_of_map_mul_inv {H : Type*} [Group H] (f : G → H)\n    (map_div : ∀ a b : G, f (a * b⁻¹) = f a * (f b)⁻¹) :\n  ↑(ofMapMulInv f map_div) = f := rfl\n\n"}
{"name":"AddMonoidHom.coe_of_map_sub","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"G : Type u_5\ninst✝¹ : AddGroup G\nH : Type u_8\ninst✝ : AddGroup H\nf : G → H\nhf : ∀ (x y : G), Eq (f (HSub.hSub x y)) (HSub.hSub (f x) (f y))\n⊢ Eq (⇑(AddMonoidHom.ofMapSub f hf)) f","decl":"@[to_additive (attr := simp)]\ntheorem coe_of_map_div {H : Type*} [Group H] (f : G → H) (hf : ∀ x y, f (x / y) = f x / f y) :\n    ↑(ofMapDiv f hf) = f := rfl\n\n"}
{"name":"MonoidHom.coe_of_map_div","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"G : Type u_5\ninst✝¹ : Group G\nH : Type u_8\ninst✝ : Group H\nf : G → H\nhf : ∀ (x y : G), Eq (f (HDiv.hDiv x y)) (HDiv.hDiv (f x) (f y))\n⊢ Eq (⇑(MonoidHom.ofMapDiv f hf)) f","decl":"@[to_additive (attr := simp)]\ntheorem coe_of_map_div {H : Type*} [Group H] (f : G → H) (hf : ∀ x y, f (x / y) = f x / f y) :\n    ↑(ofMapDiv f hf) = f := rfl\n\n"}
{"name":"AddMonoidHom.add_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommMonoid N\nf g : AddMonoidHom M N\nx : M\n⊢ Eq ((HAdd.hAdd f g) x) (HAdd.hAdd (f x) (g x))","decl":"@[to_additive (attr := simp)] lemma mul_apply (f g : M →* N) (x : M) : (f * g) x = f x * g x := rfl\n\n"}
{"name":"MonoidHom.mul_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\ninst✝¹ : MulOneClass M\ninst✝ : CommMonoid N\nf g : MonoidHom M N\nx : M\n⊢ Eq ((HMul.hMul f g) x) (HMul.hMul (f x) (g x))","decl":"@[to_additive (attr := simp)] lemma mul_apply (f g : M →* N) (x : M) : (f * g) x = f x * g x := rfl\n\n"}
{"name":"MonoidHom.mul_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : MulOneClass M\ninst✝¹ : CommMonoid N\ninst✝ : MulOneClass P\ng₁ g₂ : MonoidHom M N\nf : MonoidHom P M\n⊢ Eq ((HMul.hMul g₁ g₂).comp f) (HMul.hMul (g₁.comp f) (g₂.comp f))","decl":"@[to_additive]\nlemma mul_comp [MulOneClass P] (g₁ g₂ : M →* N) (f : P →* M) :\n    (g₁ * g₂).comp f = g₁.comp f * g₂.comp f := rfl\n\n"}
{"name":"AddMonoidHom.add_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : AddZeroClass M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddZeroClass P\ng₁ g₂ : AddMonoidHom M N\nf : AddMonoidHom P M\n⊢ Eq ((HAdd.hAdd g₁ g₂).comp f) (HAdd.hAdd (g₁.comp f) (g₂.comp f))","decl":"@[to_additive]\nlemma mul_comp [MulOneClass P] (g₁ g₂ : M →* N) (f : P →* M) :\n    (g₁ * g₂).comp f = g₁.comp f * g₂.comp f := rfl\n\n"}
{"name":"MonoidHom.comp_mul","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : MulOneClass M\ninst✝¹ : CommMonoid N\ninst✝ : CommMonoid P\ng : MonoidHom N P\nf₁ f₂ : MonoidHom M N\n⊢ Eq (g.comp (HMul.hMul f₁ f₂)) (HMul.hMul (g.comp f₁) (g.comp f₂))","decl":"@[to_additive]\nlemma comp_mul [CommMonoid P] (g : N →* P) (f₁ f₂ : M →* N) :\n    g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by\n  ext; simp only [mul_apply, Function.comp_apply, map_mul, coe_comp]\n\n"}
{"name":"AddMonoidHom.comp_add","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nP : Type u_4\ninst✝² : AddZeroClass M\ninst✝¹ : AddCommMonoid N\ninst✝ : AddCommMonoid P\ng : AddMonoidHom N P\nf₁ f₂ : AddMonoidHom M N\n⊢ Eq (g.comp (HAdd.hAdd f₁ f₂)) (HAdd.hAdd (g.comp f₁) (g.comp f₂))","decl":"@[to_additive]\nlemma comp_mul [CommMonoid P] (g : N →* P) (f₁ f₂ : M →* N) :\n    g.comp (f₁ * f₂) = g.comp f₁ * g.comp f₂ := by\n  ext; simp only [mul_apply, Function.comp_apply, map_mul, coe_comp]\n\n"}
{"name":"MonoidHom.inv_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : CommGroup G\nf : MonoidHom M G\nx : M\n⊢ Eq ((Inv.inv f) x) (Inv.inv (f x))","decl":"@[to_additive (attr := simp)] lemma inv_apply (f : M →* G) (x : M) : f⁻¹ x = (f x)⁻¹ := rfl\n\n"}
{"name":"AddMonoidHom.neg_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommGroup G\nf : AddMonoidHom M G\nx : M\n⊢ Eq ((Neg.neg f) x) (Neg.neg (f x))","decl":"@[to_additive (attr := simp)] lemma inv_apply (f : M →* G) (x : M) : f⁻¹ x = (f x)⁻¹ := rfl\n\n"}
{"name":"MonoidHom.inv_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nG : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommGroup G\nφ : MonoidHom N G\nψ : MonoidHom M N\n⊢ Eq ((Inv.inv φ).comp ψ) (Inv.inv (φ.comp ψ))","decl":"@[to_additive (attr := simp)]\ntheorem inv_comp (φ : N →* G) (ψ : M →* N) : φ⁻¹.comp ψ = (φ.comp ψ)⁻¹ := rfl\n\n"}
{"name":"AddMonoidHom.neg_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nG : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommGroup G\nφ : AddMonoidHom N G\nψ : AddMonoidHom M N\n⊢ Eq ((Neg.neg φ).comp ψ) (Neg.neg (φ.comp ψ))","decl":"@[to_additive (attr := simp)]\ntheorem inv_comp (φ : N →* G) (ψ : M →* N) : φ⁻¹.comp ψ = (φ.comp ψ)⁻¹ := rfl\n\n"}
{"name":"MonoidHom.comp_inv","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\nH : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : CommGroup G\ninst✝ : CommGroup H\nφ : MonoidHom G H\nψ : MonoidHom M G\n⊢ Eq (φ.comp (Inv.inv ψ)) (Inv.inv (φ.comp ψ))","decl":"@[to_additive (attr := simp)]\ntheorem comp_inv (φ : G →* H) (ψ : M →* G) : φ.comp ψ⁻¹ = (φ.comp ψ)⁻¹ := by\n  ext\n  simp only [Function.comp_apply, inv_apply, map_inv, coe_comp]\n\n"}
{"name":"AddMonoidHom.comp_neg","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\nH : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddCommGroup G\ninst✝ : AddCommGroup H\nφ : AddMonoidHom G H\nψ : AddMonoidHom M G\n⊢ Eq (φ.comp (Neg.neg ψ)) (Neg.neg (φ.comp ψ))","decl":"@[to_additive (attr := simp)]\ntheorem comp_inv (φ : G →* H) (ψ : M →* G) : φ.comp ψ⁻¹ = (φ.comp ψ)⁻¹ := by\n  ext\n  simp only [Function.comp_apply, inv_apply, map_inv, coe_comp]\n\n"}
{"name":"AddMonoidHom.sub_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\ninst✝¹ : AddZeroClass M\ninst✝ : AddCommGroup G\nf g : AddMonoidHom M G\nx : M\n⊢ Eq ((HSub.hSub f g) x) (HSub.hSub (f x) (g x))","decl":"@[to_additive (attr := simp)] lemma div_apply (f g : M →* G) (x : M) : (f / g) x = f x / g x := rfl\n\n"}
{"name":"MonoidHom.div_apply","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\ninst✝¹ : MulOneClass M\ninst✝ : CommGroup G\nf g : MonoidHom M G\nx : M\n⊢ Eq ((HDiv.hDiv f g) x) (HDiv.hDiv (f x) (g x))","decl":"@[to_additive (attr := simp)] lemma div_apply (f g : M →* G) (x : M) : (f / g) x = f x / g x := rfl\n\n"}
{"name":"MonoidHom.div_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nG : Type u_5\ninst✝² : MulOneClass M\ninst✝¹ : MulOneClass N\ninst✝ : CommGroup G\nf g : MonoidHom N G\nh : MonoidHom M N\n⊢ Eq ((HDiv.hDiv f g).comp h) (HDiv.hDiv (f.comp h) (g.comp h))","decl":"@[to_additive (attr := simp)]\nlemma div_comp (f g : N →* G) (h : M →* N) : (f / g).comp h = f.comp h / g.comp h := rfl\n\n"}
{"name":"AddMonoidHom.sub_comp","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nN : Type u_3\nG : Type u_5\ninst✝² : AddZeroClass M\ninst✝¹ : AddZeroClass N\ninst✝ : AddCommGroup G\nf g : AddMonoidHom N G\nh : AddMonoidHom M N\n⊢ Eq ((HSub.hSub f g).comp h) (HSub.hSub (f.comp h) (g.comp h))","decl":"@[to_additive (attr := simp)]\nlemma div_comp (f g : N →* G) (h : M →* N) : (f / g).comp h = f.comp h / g.comp h := rfl\n\n"}
{"name":"AddMonoidHom.comp_sub","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\nH : Type u_6\ninst✝² : AddZeroClass M\ninst✝¹ : AddCommGroup G\ninst✝ : AddCommGroup H\nf : AddMonoidHom G H\ng h : AddMonoidHom M G\n⊢ Eq (f.comp (HSub.hSub g h)) (HSub.hSub (f.comp g) (f.comp h))","decl":"@[to_additive (attr := simp)]\nlemma comp_div (f : G →* H) (g h : M →* G) : f.comp (g / h) = f.comp g / f.comp h := by\n  ext; simp only [Function.comp_apply, div_apply, map_div, coe_comp]\n\n"}
{"name":"MonoidHom.comp_div","module":"Mathlib.Algebra.Group.Hom.Basic","initialProofState":"M : Type u_2\nG : Type u_5\nH : Type u_6\ninst✝² : MulOneClass M\ninst✝¹ : CommGroup G\ninst✝ : CommGroup H\nf : MonoidHom G H\ng h : MonoidHom M G\n⊢ Eq (f.comp (HDiv.hDiv g h)) (HDiv.hDiv (f.comp g) (f.comp h))","decl":"@[to_additive (attr := simp)]\nlemma comp_div (f : G →* H) (g h : M →* G) : f.comp (g / h) = f.comp g / f.comp h := by\n  ext; simp only [Function.comp_apply, div_apply, map_div, coe_comp]\n\n"}
