{"name":"Function.iterate_zero","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\n⊢ Eq (Nat.iterate f 0) id","decl":"@[simp]\ntheorem iterate_zero : f^[0] = id :=\n  rfl\n\n"}
{"name":"Function.iterate_zero_apply","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nx : α\n⊢ Eq (Nat.iterate f 0 x) x","decl":"theorem iterate_zero_apply (x : α) : f^[0] x = x :=\n  rfl\n\n"}
{"name":"Function.iterate_succ","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\n⊢ Eq (Nat.iterate f n.succ) (Function.comp (Nat.iterate f n) f)","decl":"@[simp]\ntheorem iterate_succ (n : ℕ) : f^[n.succ] = f^[n] ∘ f :=\n  rfl\n\n"}
{"name":"Function.iterate_succ_apply","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\nx : α\n⊢ Eq (Nat.iterate f n.succ x) (Nat.iterate f n (f x))","decl":"theorem iterate_succ_apply (n : ℕ) (x : α) : f^[n.succ] x = f^[n] (f x) :=\n  rfl\n\n"}
{"name":"Function.iterate_id","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nn : Nat\n⊢ Eq (Nat.iterate id n) id","decl":"@[simp]\ntheorem iterate_id (n : ℕ) : (id : α → α)^[n] = id :=\n  Nat.recOn n rfl fun n ihn ↦ by rw [iterate_succ, ihn, id_comp]\n\n"}
{"name":"Function.iterate_add","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\n⊢ Eq (Nat.iterate f (HAdd.hAdd m n)) (Function.comp (Nat.iterate f m) (Nat.iterate f n))","decl":"theorem iterate_add (m : ℕ) : ∀ n : ℕ, f^[m + n] = f^[m] ∘ f^[n]\n  | 0 => rfl\n  | Nat.succ n => by rw [Nat.add_succ, iterate_succ, iterate_succ, iterate_add m n]; rfl\n\n"}
{"name":"Function.iterate_add_apply","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\nx : α\n⊢ Eq (Nat.iterate f (HAdd.hAdd m n) x) (Nat.iterate f m (Nat.iterate f n x))","decl":"theorem iterate_add_apply (m n : ℕ) (x : α) : f^[m + n] x = f^[m] (f^[n] x) := by\n  rw [iterate_add f m n]\n  rfl\n\n-- can be proved by simp but this is shorter and more natural\n"}
{"name":"Function.iterate_one","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\n⊢ Eq (Nat.iterate f 1) f","decl":"@[simp high]\ntheorem iterate_one : f^[1] = f :=\n  funext fun _ ↦ rfl\n\n"}
{"name":"Function.iterate_mul","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\n⊢ Eq (Nat.iterate f (HMul.hMul m n)) (Nat.iterate (Nat.iterate f m) n)","decl":"theorem iterate_mul (m : ℕ) : ∀ n, f^[m * n] = f^[m]^[n]\n  | 0 => by simp only [Nat.mul_zero, iterate_zero]\n  | n + 1 => by simp only [Nat.mul_succ, Nat.mul_one, iterate_one, iterate_add, iterate_mul m n]\n\n"}
{"name":"Function.iterate_fixed","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nx : α\nh : Eq (f x) x\nn : Nat\n⊢ Eq (Nat.iterate f n x) x","decl":"theorem iterate_fixed {x} (h : f x = x) (n : ℕ) : f^[n] x = x :=\n  Nat.recOn n rfl fun n ihn ↦ by rw [iterate_succ_apply, h, ihn]\n\n"}
{"name":"Function.Injective.iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nHinj : Function.Injective f\nn : Nat\n⊢ Function.Injective (Nat.iterate f n)","decl":"theorem Injective.iterate (Hinj : Injective f) (n : ℕ) : Injective f^[n] :=\n  Nat.recOn n injective_id fun _ ihn ↦ ihn.comp Hinj\n\n"}
{"name":"Function.Surjective.iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nHsurj : Function.Surjective f\nn : Nat\n⊢ Function.Surjective (Nat.iterate f n)","decl":"theorem Surjective.iterate (Hsurj : Surjective f) (n : ℕ) : Surjective f^[n] :=\n  Nat.recOn n surjective_id fun _ ihn ↦ ihn.comp Hsurj\n\n"}
{"name":"Function.Bijective.iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nHbij : Function.Bijective f\nn : Nat\n⊢ Function.Bijective (Nat.iterate f n)","decl":"theorem Bijective.iterate (Hbij : Bijective f) (n : ℕ) : Bijective f^[n] :=\n  ⟨Hbij.1.iterate n, Hbij.2.iterate n⟩\n\n"}
{"name":"Function.Semiconj.iterate_right","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nβ : Type v\nf : α → β\nga : α → α\ngb : β → β\nh : Function.Semiconj f ga gb\nn : Nat\n⊢ Function.Semiconj f (Nat.iterate ga n) (Nat.iterate gb n)","decl":"theorem iterate_right {f : α → β} {ga : α → α} {gb : β → β} (h : Semiconj f ga gb) (n : ℕ) :\n    Semiconj f ga^[n] gb^[n] :=\n  Nat.recOn n id_right fun _ ihn ↦ ihn.comp_right h\n\n"}
{"name":"Function.Semiconj.iterate_left","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\ng : Nat → α → α\nH : ∀ (n : Nat), Function.Semiconj f (g n) (g (HAdd.hAdd n 1))\nn k : Nat\n⊢ Function.Semiconj (Nat.iterate f n) (g k) (g (HAdd.hAdd n k))","decl":"theorem iterate_left {g : ℕ → α → α} (H : ∀ n, Semiconj f (g n) (g <| n + 1)) (n k : ℕ) :\n    Semiconj f^[n] (g k) (g <| n + k) := by\n  induction n generalizing k with\n  | zero =>\n    rw [Nat.zero_add]\n    exact id_left\n  | succ n ihn =>\n    rw [Nat.add_right_comm, Nat.add_assoc]\n    exact (H k).trans (ihn (k + 1))\n\n"}
{"name":"Function.Commute.iterate_right","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\nn : Nat\n⊢ Function.Commute f (Nat.iterate g n)","decl":"theorem iterate_right (h : Commute f g) (n : ℕ) : Commute f g^[n] :=\n  Semiconj.iterate_right h n\n\n"}
{"name":"Function.Commute.iterate_left","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\nn : Nat\n⊢ Function.Commute (Nat.iterate f n) g","decl":"theorem iterate_left (h : Commute f g) (n : ℕ) : Commute f^[n] g :=\n  (h.symm.iterate_right n).symm\n\n"}
{"name":"Function.Commute.iterate_iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\nm n : Nat\n⊢ Function.Commute (Nat.iterate f m) (Nat.iterate g n)","decl":"theorem iterate_iterate (h : Commute f g) (m n : ℕ) : Commute f^[m] g^[n] :=\n  (h.iterate_left m).iterate_right n\n\n"}
{"name":"Function.Commute.iterate_eq_of_map_eq","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\nn : Nat\nx : α\nhx : Eq (f x) (g x)\n⊢ Eq (Nat.iterate f n x) (Nat.iterate g n x)","decl":"theorem iterate_eq_of_map_eq (h : Commute f g) (n : ℕ) {x} (hx : f x = g x) :\n    f^[n] x = g^[n] x :=\n  Nat.recOn n rfl fun n ihn ↦ by\n    simp only [iterate_succ_apply, hx, (h.iterate_left n).eq, ihn, ((refl g).iterate_right n).eq]\n\n"}
{"name":"Function.Commute.comp_iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nh : Function.Commute f g\nn : Nat\n⊢ Eq (Nat.iterate (Function.comp f g) n) (Function.comp (Nat.iterate f n) (Nat.iterate g n))","decl":"theorem comp_iterate (h : Commute f g) (n : ℕ) : (f ∘ g)^[n] = f^[n] ∘ g^[n] := by\n  induction n with\n  | zero => rfl\n  | succ n ihn =>\n    funext x\n    simp only [ihn, (h.iterate_right n).eq, iterate_succ, comp_apply]\n\n"}
{"name":"Function.Commute.iterate_self","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\n⊢ Function.Commute (Nat.iterate f n) f","decl":"theorem iterate_self (n : ℕ) : Commute f^[n] f :=\n  (refl f).iterate_left n\n\n"}
{"name":"Function.Commute.self_iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\n⊢ Function.Commute f (Nat.iterate f n)","decl":"theorem self_iterate (n : ℕ) : Commute f f^[n] :=\n  (refl f).iterate_right n\n\n"}
{"name":"Function.Commute.iterate_iterate_self","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\n⊢ Function.Commute (Nat.iterate f m) (Nat.iterate f n)","decl":"theorem iterate_iterate_self (m n : ℕ) : Commute f^[m] f^[n] :=\n  (refl f).iterate_iterate m n\n\n"}
{"name":"Function.Semiconj₂.iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nop : α → α → α\nhf : Function.Semiconj₂ f op op\nn : Nat\n⊢ Function.Semiconj₂ (Nat.iterate f n) op op","decl":"theorem Semiconj₂.iterate {f : α → α} {op : α → α → α} (hf : Semiconj₂ f op op) (n : ℕ) :\n    Semiconj₂ f^[n] op op :=\n  Nat.recOn n (Semiconj₂.id_left op) fun _ ihn ↦ ihn.comp hf\n\n"}
{"name":"Function.iterate_succ'","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\n⊢ Eq (Nat.iterate f n.succ) (Function.comp f (Nat.iterate f n))","decl":"theorem iterate_succ' (n : ℕ) : f^[n.succ] = f ∘ f^[n] := by\n  rw [iterate_succ, (Commute.self_iterate f n).comp_eq]\n\n"}
{"name":"Function.iterate_succ_apply'","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\nx : α\n⊢ Eq (Nat.iterate f n.succ x) (f (Nat.iterate f n x))","decl":"theorem iterate_succ_apply' (n : ℕ) (x : α) : f^[n.succ] x = f (f^[n] x) := by\n  rw [iterate_succ']\n  rfl\n\n"}
{"name":"Function.iterate_pred_comp_of_pos","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq (Function.comp (Nat.iterate f n.pred) f) (Nat.iterate f n)","decl":"theorem iterate_pred_comp_of_pos {n : ℕ} (hn : 0 < n) : f^[n.pred] ∘ f = f^[n] := by\n  rw [← iterate_succ, Nat.succ_pred_eq_of_pos hn]\n\n"}
{"name":"Function.comp_iterate_pred_of_pos","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nn : Nat\nhn : LT.lt 0 n\n⊢ Eq (Function.comp f (Nat.iterate f n.pred)) (Nat.iterate f n)","decl":"theorem comp_iterate_pred_of_pos {n : ℕ} (hn : 0 < n) : f ∘ f^[n.pred] = f^[n] := by\n  rw [← iterate_succ', Nat.succ_pred_eq_of_pos hn]\n\n"}
{"name":"Function.Iterate.rec_zero","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\np : α → Sort u_1\nf : α → α\nh : (a : α) → p a → p (f a)\na : α\nha : p a\n⊢ Eq (Function.Iterate.rec p h ha 0) ha","decl":"theorem Iterate.rec_zero (p : α → Sort*) {f : α → α} (h : ∀ a, p a → p (f a)) {a : α} (ha : p a) :\n    Iterate.rec p h ha 0 = ha :=\n  rfl\n\n"}
{"name":"Function.LeftInverse.iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nhg : Function.LeftInverse g f\nn : Nat\n⊢ Function.LeftInverse (Nat.iterate g n) (Nat.iterate f n)","decl":"theorem LeftInverse.iterate {g : α → α} (hg : LeftInverse g f) (n : ℕ) :\n    LeftInverse g^[n] f^[n] :=\n  Nat.recOn n (fun _ ↦ rfl) fun n ihn ↦ by\n    rw [iterate_succ', iterate_succ]\n    exact ihn.comp hg\n\n"}
{"name":"Function.RightInverse.iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf g : α → α\nhg : Function.RightInverse g f\nn : Nat\n⊢ Function.RightInverse (Nat.iterate g n) (Nat.iterate f n)","decl":"theorem RightInverse.iterate {g : α → α} (hg : RightInverse g f) (n : ℕ) :\n    RightInverse g^[n] f^[n] :=\n  LeftInverse.iterate hg n\n\n"}
{"name":"Function.iterate_comm","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\n⊢ Eq (Nat.iterate (Nat.iterate f n) m) (Nat.iterate (Nat.iterate f m) n)","decl":"theorem iterate_comm (f : α → α) (m n : ℕ) : f^[n]^[m] = f^[m]^[n] :=\n  (iterate_mul _ _ _).symm.trans (Eq.trans (by rw [Nat.mul_comm]) (iterate_mul _ _ _))\n\n"}
{"name":"Function.iterate_commute","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nm n : Nat\n⊢ Function.Commute (fun f => Nat.iterate f m) fun f => Nat.iterate f n","decl":"theorem iterate_commute (m n : ℕ) : Commute (fun f : α → α ↦ f^[m]) fun f ↦ f^[n] :=\n  fun f ↦ iterate_comm f m n\n\n"}
{"name":"Function.iterate_add_eq_iterate","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\na : α\nhf : Function.Injective f\n⊢ Iff (Eq (Nat.iterate f (HAdd.hAdd m n) a) (Nat.iterate f n a)) (Eq (Nat.iterate f m a) a)","decl":"lemma iterate_add_eq_iterate (hf : Injective f) : f^[m + n] a = f^[n] a ↔ f^[m] a = a :=\n  Iff.trans (by rw [← iterate_add_apply, Nat.add_comm]) (hf.iterate n).eq_iff\n\n"}
{"name":"Function.iterate_cancel_of_add","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\na : α\nhf : Function.Injective f\na✝ : Eq (Nat.iterate f (HAdd.hAdd m n) a) (Nat.iterate f n a)\n⊢ Eq (Nat.iterate f m a) a","decl":"alias ⟨iterate_cancel_of_add, _⟩ := iterate_add_eq_iterate\n\n"}
{"name":"Function.iterate_cancel","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nf : α → α\nm n : Nat\na : α\nhf : Function.Injective f\nha : Eq (Nat.iterate f m a) (Nat.iterate f n a)\n⊢ Eq (Nat.iterate f (HSub.hSub m n) a) a","decl":"lemma iterate_cancel (hf : Injective f) (ha : f^[m] a = f^[n] a) : f^[m - n] a = a := by\n  obtain h | h := Nat.le_total m n\n  { simp [Nat.sub_eq_zero_of_le h] }\n  { exact iterate_cancel_of_add hf (by rwa [Nat.sub_add_cancel h]) }\n\n"}
{"name":"Function.involutive_iff_iter_2_eq_id","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Sort u_1\nf : α → α\n⊢ Iff (Function.Involutive f) (Eq (Nat.iterate f 2) id)","decl":"theorem involutive_iff_iter_2_eq_id {α} {f : α → α} : Involutive f ↔ f^[2] = id :=\n  funext_iff.symm\n\n"}
{"name":"List.foldl_const","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nβ : Type v\nf : α → α\na : α\nl : List β\n⊢ Eq (List.foldl (fun b x => f b) a l) (Nat.iterate f l.length a)","decl":"theorem foldl_const (f : α → α) (a : α) (l : List β) :\n    l.foldl (fun b _ ↦ f b) a = f^[l.length] a := by\n  induction l generalizing a with\n  | nil => rfl\n  | cons b l H => rw [length_cons, foldl, iterate_succ_apply, H]\n\n"}
{"name":"List.foldr_const","module":"Mathlib.Logic.Function.Iterate","initialProofState":"α : Type u\nβ : Type v\nf : β → β\nb : β\nl : List α\n⊢ Eq (List.foldr (fun x => f) b l) (Nat.iterate f l.length b)","decl":"theorem foldr_const (f : β → β) (b : β) : ∀ l : List α, l.foldr (fun _ ↦ f) b = f^[l.length] b\n  | [] => rfl\n  | a :: l => by rw [length_cons, foldr, foldr_const f b l, iterate_succ_apply']\n\n"}
