{"name":"LieSubmodule.Quotient.isCentralScalar","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝¹² : CommRing R\ninst✝¹¹ : LieRing L\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : LieRingModule L M\nN : LieSubmodule R L M\nS : Type u_1\ninst✝⁷ : Semiring S\ninst✝⁶ : SMul S R\ninst✝⁵ : Module S M\ninst✝⁴ : IsScalarTower S R M\ninst✝³ : SMul (MulOpposite S) R\ninst✝² : Module (MulOpposite S) M\ninst✝¹ : IsScalarTower (MulOpposite S) R M\ninst✝ : IsCentralScalar S M\n⊢ IsCentralScalar S (HasQuotient.Quotient M N)","decl":"instance isCentralScalar {S : Type*} [Semiring S] [SMul S R] [Module S M] [IsScalarTower S R M]\n    [SMul Sᵐᵒᵖ R] [Module Sᵐᵒᵖ M] [IsScalarTower Sᵐᵒᵖ R M] [IsCentralScalar S M] :\n    IsCentralScalar S (M ⧸ N) :=\n  Submodule.Quotient.isCentralScalar _\n\n"}
{"name":"LieSubmodule.Quotient.mk_eq_zero'","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nm : M\n⊢ Iff (Eq (LieSubmodule.Quotient.mk m) 0) (Membership.mem N m)","decl":"@[simp]\ntheorem mk_eq_zero' {m : M} : mk (N := N) m = 0 ↔ m ∈ N :=\n  Submodule.Quotient.mk_eq_zero N.toSubmodule\n\n"}
{"name":"LieSubmodule.Quotient.is_quotient_mk","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : LieRingModule L M\nN : LieSubmodule R L M\nm : M\n⊢ Eq (Quotient.mk'' m) (LieSubmodule.Quotient.mk m)","decl":"theorem is_quotient_mk (m : M) : Quotient.mk'' m = (mk m : M ⧸ N) :=\n  rfl\n\n"}
{"name":"LieSubmodule.Quotient.lieQuotientLieModule","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\n⊢ LieModule R L (HasQuotient.Quotient M N)","decl":"/-- The quotient of a Lie module by a Lie submodule, is a Lie module. -/\ninstance lieQuotientLieModule : LieModule R L (M ⧸ N) :=\n  LieModule.compLieHom _ (actionAsEndoMap N)\n\n"}
{"name":"LieSubmodule.Quotient.mk_bracket","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nI : LieIdeal R L\nx y : L\n⊢ Eq (LieSubmodule.Quotient.mk (Bracket.bracket x y)) (Bracket.bracket (LieSubmodule.Quotient.mk x) (LieSubmodule.Quotient.mk y))","decl":"@[simp]\ntheorem mk_bracket (x y : L) : mk ⁅x, y⁆ = ⁅(mk x : L ⧸ I), (mk y : L ⧸ I)⁆ :=\n  rfl\n\n"}
{"name":"LieSubmodule.Quotient.mk'_apply","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\na✝ : M\n⊢ Eq ((LieSubmodule.Quotient.mk' N) a✝) (LieSubmodule.Quotient.mk a✝)","decl":"/-- `LieSubmodule.Quotient.mk` as a `LieModuleHom`. -/\n@[simps]\ndef mk' : M →ₗ⁅R,L⁆ M ⧸ N :=\n  { N.toSubmodule.mkQ with\n    toFun := mk\n    map_lie' := fun {_ _} => rfl }\n\n"}
{"name":"LieSubmodule.Quotient.surjective_mk'","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\n⊢ Function.Surjective ⇑(LieSubmodule.Quotient.mk' N)","decl":"@[simp]\ntheorem surjective_mk' : Function.Surjective (mk' N) := Quot.mk_surjective\n\n"}
{"name":"LieSubmodule.Quotient.range_mk'","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\n⊢ Eq (LieSubmodule.Quotient.mk' N).range Top.top","decl":"@[simp]\ntheorem range_mk' : LieModuleHom.range (mk' N) = ⊤ := by\n  simp [LieModuleHom.range_eq_top]\n\n"}
{"name":"LieSubmodule.Quotient.isNoetherian","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁵ : CommRing R\ninst✝⁴ : LieRing L\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : LieRingModule L M\nN : LieSubmodule R L M\ninst✝ : IsNoetherian R M\n⊢ IsNoetherian R (HasQuotient.Quotient M N)","decl":"instance isNoetherian [IsNoetherian R M] : IsNoetherian R (M ⧸ N) :=\n  inferInstanceAs (IsNoetherian R (M ⧸ (N : Submodule R M)))\n\n-- Porting note: LHS simplifies @[simp]\n"}
{"name":"LieSubmodule.Quotient.mk_eq_zero","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\nm : M\n⊢ Iff (Eq ((LieSubmodule.Quotient.mk' N) m) 0) (Membership.mem N m)","decl":"theorem mk_eq_zero {m : M} : mk' N m = 0 ↔ m ∈ N :=\n  Submodule.Quotient.mk_eq_zero N.toSubmodule\n\n"}
{"name":"LieSubmodule.Quotient.mk'_ker","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\n⊢ Eq (LieSubmodule.Quotient.mk' N).ker N","decl":"@[simp]\ntheorem mk'_ker : (mk' N).ker = N := by ext; simp\n\n"}
{"name":"LieSubmodule.Quotient.map_mk'_eq_bot_le","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN N' : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\n⊢ Iff (Eq (LieSubmodule.map (LieSubmodule.Quotient.mk' N) N') Bot.bot) (LE.le N' N)","decl":"@[simp]\ntheorem map_mk'_eq_bot_le : map (mk' N) N' = ⊥ ↔ N' ≤ N := by\n  rw [← LieModuleHom.le_ker_iff_map, mk'_ker]\n\n"}
{"name":"LieSubmodule.Quotient.lieModuleHom_ext","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\nf g : LieModuleHom R L (HasQuotient.Quotient M N) M\nh : Eq (f.comp (LieSubmodule.Quotient.mk' N)) (g.comp (LieSubmodule.Quotient.mk' N))\n⊢ Eq f g","decl":"/-- Two `LieModuleHom`s from a quotient lie module are equal if their compositions with\n`LieSubmodule.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem lieModuleHom_ext ⦃f g : M ⧸ N →ₗ⁅R,L⁆ M⦄ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=\n  LieModuleHom.ext fun x => Quotient.inductionOn' x <| LieModuleHom.congr_fun h\n\n"}
{"name":"LieSubmodule.Quotient.lieModuleHom_ext_iff","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\nf g : LieModuleHom R L (HasQuotient.Quotient M N) M\n⊢ Iff (Eq f g) (Eq (f.comp (LieSubmodule.Quotient.mk' N)) (g.comp (LieSubmodule.Quotient.mk' N)))","decl":"/-- Two `LieModuleHom`s from a quotient lie module are equal if their compositions with\n`LieSubmodule.Quotient.mk'` are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem lieModuleHom_ext ⦃f g : M ⧸ N →ₗ⁅R,L⁆ M⦄ (h : f.comp (mk' N) = g.comp (mk' N)) : f = g :=\n  LieModuleHom.ext fun x => Quotient.inductionOn' x <| LieModuleHom.congr_fun h\n\n"}
{"name":"LieSubmodule.Quotient.toEnd_comp_mk'","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u\nL : Type v\nM : Type w\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\nN : LieSubmodule R L M\ninst✝¹ : LieAlgebra R L\ninst✝ : LieModule R L M\nx : L\n⊢ Eq (LinearMap.comp ((LieModule.toEnd R L (HasQuotient.Quotient M N)) x) ↑(LieSubmodule.Quotient.mk' N)) ((↑(LieSubmodule.Quotient.mk' N)).comp ((LieModule.toEnd R L M) x))","decl":"lemma toEnd_comp_mk' (x : L) :\n    LieModule.toEnd R L (M ⧸ N) x ∘ₗ mk' N = mk' N ∘ₗ LieModule.toEnd R L M x :=\n  rfl\n\n"}
{"name":"LieHom.quotKerEquivRange_toFun","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\na : HasQuotient.Quotient L (LinearMap.ker ↑f)\n⊢ Eq (f.quotKerEquivRange a) ((↑f).quotKerEquivRange a)","decl":"/-- The first isomorphism theorem for morphisms of Lie algebras. -/\n@[simps]\nnoncomputable def quotKerEquivRange : (L ⧸ f.ker) ≃ₗ⁅R⁆ f.range :=\n  { (f : L →ₗ[R] L').quotKerEquivRange with\n    toFun := (f : L →ₗ[R] L').quotKerEquivRange\n    map_lie' := by\n      rintro ⟨x⟩ ⟨y⟩\n      rw [← SetLike.coe_eq_coe, LieSubalgebra.coe_bracket]\n      simp only [Submodule.Quotient.quot_mk_eq_mk, LinearMap.quotKerEquivRange_apply_mk, ←\n        LieSubmodule.Quotient.mk_bracket, coe_toLinearMap, map_lie] }\n\n"}
{"name":"LieHom.quotKerEquivRange_invFun","module":"Mathlib.Algebra.Lie.Quotient","initialProofState":"R : Type u_1\nL : Type u_2\nL' : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : LieRing L'\ninst✝ : LieAlgebra R L'\nf : LieHom R L L'\na✝ : Subtype fun x => Membership.mem (LinearMap.range ↑f) x\n⊢ Eq (f.quotKerEquivRange.invFun a✝) ((↑f).quotKerEquivRange.invFun a✝)","decl":"/-- The first isomorphism theorem for morphisms of Lie algebras. -/\n@[simps]\nnoncomputable def quotKerEquivRange : (L ⧸ f.ker) ≃ₗ⁅R⁆ f.range :=\n  { (f : L →ₗ[R] L').quotKerEquivRange with\n    toFun := (f : L →ₗ[R] L').quotKerEquivRange\n    map_lie' := by\n      rintro ⟨x⟩ ⟨y⟩\n      rw [← SetLike.coe_eq_coe, LieSubalgebra.coe_bracket]\n      simp only [Submodule.Quotient.quot_mk_eq_mk, LinearMap.quotKerEquivRange_apply_mk, ←\n        LieSubmodule.Quotient.mk_bracket, coe_toLinearMap, map_lie] }\n\n"}
