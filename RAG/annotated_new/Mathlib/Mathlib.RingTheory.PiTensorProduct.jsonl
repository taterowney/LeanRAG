{"name":"PiTensorProduct.one_def","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → AddCommMonoidWithOne (A i)\ninst✝ : (i : ι) → Module R (A i)\n⊢ Eq 1 ((PiTensorProduct.tprod R) 1)","decl":"lemma one_def : 1 = tprod R (1 : Π i, A i) := rfl\n\n"}
{"name":"PiTensorProduct.mul_tprod_tprod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalNonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nx y : (i : ι) → A i\n⊢ Eq ((PiTensorProduct.mul ((PiTensorProduct.tprod R) x)) ((PiTensorProduct.tprod R) y)) ((PiTensorProduct.tprod R) (HMul.hMul x y))","decl":"@[simp] lemma mul_tprod_tprod (x y : (i : ι) → A i) :\n    mul (tprod R x) (tprod R y) = tprod R (x * y) := by\n  simp only [mul, piTensorHomMap₂_tprod_tprod_tprod, LinearMap.mul_apply', Pi.mul_def]\n\n"}
{"name":"PiTensorProduct.mul_def","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalNonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nx y : PiTensorProduct R fun i => A i\n⊢ Eq (HMul.hMul x y) ((PiTensorProduct.mul x) y)","decl":"lemma mul_def (x y : ⨂[R] i, A i) : x * y = mul x y := rfl\n\n"}
{"name":"PiTensorProduct.tprod_mul_tprod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalNonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nx y : (i : ι) → A i\n⊢ Eq (HMul.hMul ((PiTensorProduct.tprod R) x) ((PiTensorProduct.tprod R) y)) ((PiTensorProduct.tprod R) (HMul.hMul x y))","decl":"@[simp] lemma tprod_mul_tprod (x y : (i : ι) → A i) :\n    tprod R x * tprod R y = tprod R (x * y) :=\n  mul_tprod_tprod x y\n\n"}
{"name":"SemiconjBy.tprod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalNonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\na₁ a₂ a₃ : (i : ι) → A i\nha : SemiconjBy a₁ a₂ a₃\n⊢ SemiconjBy ((PiTensorProduct.tprod R) a₁) ((PiTensorProduct.tprod R) a₂) ((PiTensorProduct.tprod R) a₃)","decl":"theorem _root_.SemiconjBy.tprod {a₁ a₂ a₃ : Π i, A i}\n    (ha : SemiconjBy a₁ a₂ a₃) :\n    SemiconjBy (tprod R a₁) (tprod R a₂) (tprod R a₃) := by\n  rw [SemiconjBy, tprod_mul_tprod, tprod_mul_tprod, ha]\n\n"}
{"name":"Commute.tprod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalNonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\na₁ a₂ : (i : ι) → A i\nha : Commute a₁ a₂\n⊢ Commute ((PiTensorProduct.tprod R) a₁) ((PiTensorProduct.tprod R) a₂)","decl":"nonrec theorem _root_.Commute.tprod {a₁ a₂ : Π i, A i} (ha : Commute a₁ a₂) :\n    Commute (tprod R a₁) (tprod R a₂) :=\n  ha.tprod\n\n"}
{"name":"PiTensorProduct.smul_tprod_mul_smul_tprod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalNonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nr s : R\nx y : (i : ι) → A i\n⊢ Eq (HMul.hMul (HSMul.hSMul r ((PiTensorProduct.tprod R) x)) (HSMul.hSMul s ((PiTensorProduct.tprod R) y))) (HSMul.hSMul (HMul.hMul r s) ((PiTensorProduct.tprod R) (HMul.hMul x y)))","decl":"lemma smul_tprod_mul_smul_tprod (r s : R) (x y : Π i, A i) :\n    (r • tprod R x) * (s • tprod R y) = (r * s) • tprod R (x * y) := by\n  simp only [mul_def, map_smul, LinearMap.smul_apply, mul_tprod_tprod, mul_comm r s, mul_smul]\n\n"}
{"name":"PiTensorProduct.one_mul","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nx : PiTensorProduct R fun i => A i\n⊢ Eq ((PiTensorProduct.mul ((PiTensorProduct.tprod R) 1)) x) x","decl":"protected lemma one_mul (x : ⨂[R] i, A i) : mul (tprod R 1) x = x := by\n  induction x using PiTensorProduct.induction_on with\n  | smul_tprod => simp\n  | add _ _ h1 h2 => simp [map_add, h1, h2]\n\n"}
{"name":"PiTensorProduct.mul_one","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nx : PiTensorProduct R fun i => A i\n⊢ Eq ((PiTensorProduct.mul x) ((PiTensorProduct.tprod R) 1)) x","decl":"protected lemma mul_one (x : ⨂[R] i, A i) : mul x (tprod R 1) = x := by\n  induction x using PiTensorProduct.induction_on with\n  | smul_tprod => simp\n  | add _ _ h1 h2 => simp [h1, h2]\n\n"}
{"name":"PiTensorProduct.tprodMonoidHom_apply","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonAssocSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\na : (i : ι) → A i\n⊢ Eq ((PiTensorProduct.tprodMonoidHom R) a) ((PiTensorProduct.tprod R) a)","decl":"variable (R) in\n/-- `PiTensorProduct.tprod` as a `MonoidHom`. -/\n@[simps]\ndef tprodMonoidHom : (Π i, A i) →* ⨂[R] i, A i where\n  toFun := tprod R\n  map_one' := rfl\n  map_mul' x y := (tprod_mul_tprod x y).symm\n\n"}
{"name":"PiTensorProduct.mul_assoc","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → NonUnitalSemiring (A i)\ninst✝² : (i : ι) → Module R (A i)\ninst✝¹ : ∀ (i : ι), SMulCommClass R (A i) (A i)\ninst✝ : ∀ (i : ι), IsScalarTower R (A i) (A i)\nx y z : PiTensorProduct R fun i => A i\n⊢ Eq ((PiTensorProduct.mul ((PiTensorProduct.mul x) y)) z) ((PiTensorProduct.mul x) ((PiTensorProduct.mul y) z))","decl":"protected lemma mul_assoc (x y z : ⨂[R] i, A i) : mul (mul x y) z = mul x (mul y z) := by\n  -- restate as an equality of morphisms so that we can use `ext`\n  suffices LinearMap.llcomp R _ _ _ mul ∘ₗ mul =\n      (LinearMap.llcomp R _ _ _ LinearMap.lflip <| LinearMap.llcomp R _ _ _ mul.flip ∘ₗ mul).flip by\n    exact DFunLike.congr_fun (DFunLike.congr_fun (DFunLike.congr_fun this x) y) z\n  ext x y z\n  dsimp [← mul_def]\n  simpa only [tprod_mul_tprod] using congr_arg (tprod R) (mul_assoc x y z)\n\n"}
{"name":"PiTensorProduct.algebraMap_apply","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR' : Type u_2\nR : Type u_3\nA : ι → Type u_4\ninst✝⁷ : CommSemiring R'\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → Semiring (A i)\ninst✝⁴ : Algebra R' R\ninst✝³ : (i : ι) → Algebra R (A i)\ninst✝² : (i : ι) → Algebra R' (A i)\ninst✝¹ : ∀ (i : ι), IsScalarTower R' R (A i)\nr : R'\ni : ι\ninst✝ : DecidableEq ι\n⊢ Eq ((algebraMap R' (PiTensorProduct R fun i => A i)) r) ((PiTensorProduct.tprod R) (Pi.mulSingle i ((algebraMap R' (A i)) r)))","decl":"lemma algebraMap_apply (r : R') (i : ι) [DecidableEq ι] :\n    algebraMap R' (⨂[R] i, A i) r = tprod R (Pi.mulSingle i (algebraMap R' (A i) r)) := by\n  change r • tprod R 1 = _\n  have : Pi.mulSingle i (algebraMap R' (A i) r) = update (fun i ↦ 1) i (r • 1) := by\n    rw [Algebra.algebraMap_eq_smul_one]; rfl\n  rw [this, ← smul_one_smul R r (1 : A i), MultilinearMap.map_update_smul, update_eq_self,\n    smul_one_smul, Pi.one_def]\n\n"}
{"name":"PiTensorProduct.singleAlgHom_apply","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝³ : CommSemiring R\ninst✝² : (i : ι) → Semiring (A i)\ninst✝¹ : (i : ι) → Algebra R (A i)\ninst✝ : DecidableEq ι\ni : ι\na : A i\n⊢ Eq ((PiTensorProduct.singleAlgHom i) a) ((PiTensorProduct.tprod R) ((MonoidHom.mulSingle A i) a))","decl":"/--\nThe map `Aᵢ ⟶ ⨂ᵢ Aᵢ` given by `a ↦ 1 ⊗ ... ⊗ a ⊗ 1 ⊗ ...`\n-/\n@[simps]\ndef singleAlgHom [DecidableEq ι] (i : ι) : A i →ₐ[R] ⨂[R] i, A i where\n  toFun a := tprod R (MonoidHom.mulSingle _ i a)\n  map_one' := by simp only [_root_.map_one]; rfl\n  map_mul' a a' := by simp [_root_.map_mul]\n  map_zero' := MultilinearMap.map_update_zero _ _ _\n  map_add' _ _ := MultilinearMap.map_update_add _ _ _ _ _\n  commutes' r := show tprodCoeff R _ _ = r • tprodCoeff R _ _ by\n    rw [Algebra.algebraMap_eq_smul_one]\n    erw [smul_tprodCoeff]\n    rfl\n\n"}
{"name":"PiTensorProduct.liftAlgHom_apply","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁴ : CommSemiring R\ninst✝³ : (i : ι) → Semiring (A i)\ninst✝² : (i : ι) → Algebra R (A i)\nS : Type u_5\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf : MultilinearMap R A S\none : Eq (f 1) 1\nmul : ∀ (x y : (i : ι) → A i), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\na : PiTensorProduct R fun i => A i\n⊢ Eq ((PiTensorProduct.liftAlgHom f one mul) a) ((PiTensorProduct.lift f) a)","decl":"/--\nLifting a multilinear map to an algebra homomorphism from tensor product\n-/\n@[simps!]\ndef liftAlgHom {S : Type*} [Semiring S] [Algebra R S]\n    (f : MultilinearMap R A S)\n    (one : f 1 = 1) (mul : ∀ x y, f (x * y) = f x * f y) : (⨂[R] i, A i) →ₐ[R] S :=\n  AlgHom.ofLinearMap (lift f) (show lift f (tprod R 1) = 1 by simp [one]) <|\n    LinearMap.map_mul_iff _ |>.mpr <| by aesop\n\n"}
{"name":"PiTensorProduct.tprod_noncommProd","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → Semiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\nκ : Type u_5\ns : Finset κ\nx : κ → (i : ι) → A i\nhx : (↑s).Pairwise (Function.onFun Commute x)\n⊢ Eq ((PiTensorProduct.tprod R) (s.noncommProd x hx)) (s.noncommProd (fun k => (PiTensorProduct.tprod R) (x k)) ⋯)","decl":"@[simp] lemma tprod_noncommProd {κ : Type*} (s : Finset κ) (x : κ → Π i, A i) (hx) :\n    tprod R (s.noncommProd x hx) = s.noncommProd (fun k => tprod R (x k))\n      (hx.imp fun _ _ => Commute.tprod) :=\n  Finset.map_noncommProd s x _ (tprodMonoidHom R)\n\n"}
{"name":"PiTensorProduct.algHom_ext","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → Semiring (A i)\ninst✝⁴ : (i : ι) → Algebra R (A i)\nS : Type u_5\ninst✝³ : Finite ι\ninst✝² : DecidableEq ι\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf g : AlgHom R (PiTensorProduct R fun i => A i) S\nh : ∀ (i : ι), Eq (f.comp (PiTensorProduct.singleAlgHom i)) (g.comp (PiTensorProduct.singleAlgHom i))\n⊢ Eq f g","decl":"/-- To show two algebra morphisms from finite tensor products are equal, it suffices to show that\nthey agree on elements of the form $1 ⊗ ⋯ ⊗ a ⊗ 1 ⊗ ⋯$. -/\n@[ext high]\ntheorem algHom_ext {S : Type*} [Finite ι] [DecidableEq ι] [Semiring S] [Algebra R S]\n    ⦃f g : (⨂[R] i, A i) →ₐ[R] S⦄ (h : ∀ i, f.comp (singleAlgHom i) = g.comp (singleAlgHom i)) :\n    f = g :=\n  AlgHom.toLinearMap_injective <| PiTensorProduct.ext <| MultilinearMap.ext fun x =>\n    suffices f.toMonoidHom.comp (tprodMonoidHom R) = g.toMonoidHom.comp (tprodMonoidHom R) from\n      DFunLike.congr_fun this x\n    MonoidHom.pi_ext fun i xi => DFunLike.congr_fun (h i) xi\n\n"}
{"name":"PiTensorProduct.algHom_ext_iff","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝⁶ : CommSemiring R\ninst✝⁵ : (i : ι) → Semiring (A i)\ninst✝⁴ : (i : ι) → Algebra R (A i)\nS : Type u_5\ninst✝³ : Finite ι\ninst✝² : DecidableEq ι\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nf g : AlgHom R (PiTensorProduct R fun i => A i) S\n⊢ Iff (Eq f g) (∀ (i : ι), Eq (f.comp (PiTensorProduct.singleAlgHom i)) (g.comp (PiTensorProduct.singleAlgHom i)))","decl":"/-- To show two algebra morphisms from finite tensor products are equal, it suffices to show that\nthey agree on elements of the form $1 ⊗ ⋯ ⊗ a ⊗ 1 ⊗ ⋯$. -/\n@[ext high]\ntheorem algHom_ext {S : Type*} [Finite ι] [DecidableEq ι] [Semiring S] [Algebra R S]\n    ⦃f g : (⨂[R] i, A i) →ₐ[R] S⦄ (h : ∀ i, f.comp (singleAlgHom i) = g.comp (singleAlgHom i)) :\n    f = g :=\n  AlgHom.toLinearMap_injective <| PiTensorProduct.ext <| MultilinearMap.ext fun x =>\n    suffices f.toMonoidHom.comp (tprodMonoidHom R) = g.toMonoidHom.comp (tprodMonoidHom R) from\n      DFunLike.congr_fun this x\n    MonoidHom.pi_ext fun i xi => DFunLike.congr_fun (h i) xi\n\n"}
{"name":"PiTensorProduct.mul_comm","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → CommSemiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\nx y : PiTensorProduct R fun i => A i\n⊢ Eq ((PiTensorProduct.mul x) y) ((PiTensorProduct.mul y) x)","decl":"protected lemma mul_comm (x y : ⨂[R] i, A i) : mul x y = mul y x := by\n  suffices mul (R := R) (A := A) = mul.flip from\n    DFunLike.congr_fun (DFunLike.congr_fun this x) y\n  ext x y\n  dsimp\n  simp only [mul_tprod_tprod, mul_tprod_tprod, mul_comm x y]\n\n"}
{"name":"PiTensorProduct.tprod_prod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\nA : ι → Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : (i : ι) → CommSemiring (A i)\ninst✝ : (i : ι) → Algebra R (A i)\nκ : Type u_5\ns : Finset κ\nx : κ → (i : ι) → A i\n⊢ Eq ((PiTensorProduct.tprod R) (s.prod fun k => x k)) (s.prod fun k => (PiTensorProduct.tprod R) (x k))","decl":"@[simp] lemma tprod_prod {κ : Type*} (s : Finset κ) (x : κ → Π i, A i) :\n    tprod R (∏ k ∈ s, x k) = ∏ k ∈ s, tprod R (x k) :=\n  map_prod (tprodMonoidHom R) x s\n\n"}
{"name":"PiTensorProduct.constantBaseRingEquiv_tprod","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : Fintype ι\nx : ι → R\n⊢ Eq ((PiTensorProduct.constantBaseRingEquiv ι R) ((PiTensorProduct.tprod R) x)) (Finset.univ.prod fun i => x i)","decl":"@[simp]\ntheorem constantBaseRingEquiv_tprod (x : ι → R) :\n    constantBaseRingEquiv ι R (tprod R x) = ∏ i, x i := by\n  simp [constantBaseRingEquiv]\n\n"}
{"name":"PiTensorProduct.constantBaseRingEquiv_symm","module":"Mathlib.RingTheory.PiTensorProduct","initialProofState":"ι : Type u_1\nR : Type u_3\ninst✝¹ : CommSemiring R\ninst✝ : Fintype ι\nr : R\n⊢ Eq ((PiTensorProduct.constantBaseRingEquiv ι R).symm r) ((algebraMap R (PiTensorProduct R fun x => R)) r)","decl":"@[simp]\ntheorem constantBaseRingEquiv_symm (r : R) :\n    (constantBaseRingEquiv ι R).symm r = algebraMap _ _ r := rfl\n\n"}
