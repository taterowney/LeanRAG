{"name":"hasFDerivAt_jacobiThetaâ‚‚_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz Ï„ : Complex\nâŠ¢ HasFDerivAt (fun p => jacobiThetaâ‚‚_term n p.1 p.2) (jacobiThetaâ‚‚_term_fderiv n z Ï„) { fst := z, snd := Ï„ }","decl":"lemma hasFDerivAt_jacobiThetaâ‚‚_term (n : â„¤) (z Ï„ : â„‚) :\n    HasFDerivAt (fun p : â„‚ Ã— â„‚ â†¦ jacobiThetaâ‚‚_term n p.1 p.2)\n    (jacobiThetaâ‚‚_term_fderiv n z Ï„) (z, Ï„) := by\n  let f : â„‚ Ã— â„‚ â†’ â„‚ := fun p â†¦ 2 * Ï€ * I * n * p.1 + Ï€ * I * n ^ 2 * p.2\n  suffices HasFDerivAt f ((2 * Ï€ * I * n) â€¢ (ContinuousLinearMap.fst â„‚ â„‚ â„‚)\n    + (Ï€ * I * n ^ 2) â€¢ (ContinuousLinearMap.snd â„‚ â„‚ â„‚)) (z, Ï„) from this.cexp\n  exact (hasFDerivAt_fst.const_mul _).add (hasFDerivAt_snd.const_mul _)\n\n"}
{"name":"norm_jacobiThetaâ‚‚_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz Ï„ : Complex\nâŠ¢ Eq (Norm.norm (jacobiThetaâ‚‚_term n z Ï„)) (Real.exp (HSub.hSub (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (â†‘n) 2)) Ï„.im) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) â†‘n) z.im)))","decl":"lemma norm_jacobiThetaâ‚‚_term (n : â„¤) (z Ï„ : â„‚) :\n    â€–jacobiThetaâ‚‚_term n z Ï„â€– = rexp (-Ï€ * n ^ 2 * Ï„.im - 2 * Ï€ * n * z.im) := by\n  rw [jacobiThetaâ‚‚_term, Complex.norm_eq_abs, Complex.abs_exp, (by push_cast; ring :\n    (2 * Ï€ : â„‚) * I * n * z + Ï€ * I * n ^ 2 * Ï„ = (Ï€ * (2 * n):) * z * I + (Ï€ * n ^ 2 :) * Ï„ * I),\n    add_re, mul_I_re, im_ofReal_mul, mul_I_re, im_ofReal_mul]\n  ring_nf\n\n"}
{"name":"norm_jacobiThetaâ‚‚_term_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"S T : Real\nhT : LT.lt 0 T\nz Ï„ : Complex\nhz : LE.le (abs z.im) S\nhÏ„ : LE.le T Ï„.im\nn : Int\nâŠ¢ LE.le (Norm.norm (jacobiThetaâ‚‚_term n z Ï„)) (Real.exp (HMul.hMul (Neg.neg Real.pi) (HSub.hSub (HMul.hMul T (HPow.hPow (â†‘n) 2)) (HMul.hMul (HMul.hMul 2 S) â†‘(abs n)))))","decl":"/-- A uniform upper bound for `jacobiThetaâ‚‚_term` on compact subsets. -/\nlemma norm_jacobiThetaâ‚‚_term_le {S T : â„} (hT : 0 < T) {z Ï„ : â„‚}\n    (hz : |im z| â‰¤ S) (hÏ„ : T â‰¤ im Ï„) (n : â„¤) :\n    â€–jacobiThetaâ‚‚_term n z Ï„â€– â‰¤ rexp (-Ï€ * (T * n ^ 2 - 2 * S * |n|)) := by\n  simp_rw [norm_jacobiThetaâ‚‚_term, Real.exp_le_exp, sub_eq_add_neg, neg_mul, â† neg_add,\n    neg_le_neg_iff, mul_comm (2 : â„), mul_assoc Ï€, â† mul_add, mul_le_mul_left pi_pos,\n    mul_comm T, mul_comm S]\n  refine add_le_add (mul_le_mul le_rfl hÏ„ hT.le (sq_nonneg _)) ?_\n  rw [â† mul_neg, mul_assoc, mul_assoc, mul_le_mul_left two_pos, mul_comm, neg_mul, â† mul_neg]\n  refine le_trans ?_ (neg_abs_le _)\n  rw [mul_neg, neg_le_neg_iff, abs_mul, Int.cast_abs]\n  exact mul_le_mul_of_nonneg_left hz (abs_nonneg _)\n\n"}
{"name":"norm_jacobiThetaâ‚‚'_term_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"S T : Real\nhT : LT.lt 0 T\nz Ï„ : Complex\nhz : LE.le (abs z.im) S\nhÏ„ : LE.le T Ï„.im\nn : Int\nâŠ¢ LE.le (Norm.norm (jacobiThetaâ‚‚'_term n z Ï„)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) â†‘(abs n)) (Real.exp (HMul.hMul (Neg.neg Real.pi) (HSub.hSub (HMul.hMul T (HPow.hPow (â†‘n) 2)) (HMul.hMul (HMul.hMul 2 S) â†‘(abs n))))))","decl":"/-- A uniform upper bound for `jacobiThetaâ‚‚'_term` on compact subsets. -/\nlemma norm_jacobiThetaâ‚‚'_term_le {S T : â„} (hT : 0 < T) {z Ï„ : â„‚}\n    (hz : |im z| â‰¤ S) (hÏ„ : T â‰¤ im Ï„) (n : â„¤) :\n    â€–jacobiThetaâ‚‚'_term n z Ï„â€– â‰¤ 2 * Ï€ * |n| * rexp (-Ï€ * (T * n ^ 2 - 2 * S * |n|)) := by\n  rw [jacobiThetaâ‚‚'_term, norm_mul]\n  refine mul_le_mul (le_of_eq ?_) (norm_jacobiThetaâ‚‚_term_le hT hz hÏ„ n)\n    (norm_nonneg _) (by positivity)\n  simp only [norm_mul, Complex.norm_eq_abs, Complex.abs_two, abs_I,\n    Complex.abs_of_nonneg pi_pos.le, abs_intCast, mul_one, Int.cast_abs]\n\n"}
{"name":"summable_pow_mul_jacobiThetaâ‚‚_term_bound","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"S T : Real\nhT : LT.lt 0 T\nk : Nat\nâŠ¢ Summable fun n => HMul.hMul (HPow.hPow (â†‘(abs n)) k) (Real.exp (HMul.hMul (Neg.neg Real.pi) (HSub.hSub (HMul.hMul T (HPow.hPow (â†‘n) 2)) (HMul.hMul (HMul.hMul 2 S) â†‘(abs n)))))","decl":"/-- The uniform bound we have given is summable, and remains so after multiplying by any fixed\npower of `|n|` (we shall need this for `k = 0, 1, 2`). -/\nlemma summable_pow_mul_jacobiThetaâ‚‚_term_bound (S : â„) {T : â„} (hT : 0 < T) (k : â„•) :\n    Summable (fun n : â„¤ â†¦ (|n| ^ k : â„) * Real.exp (-Ï€ * (T * n ^ 2 - 2 * S * |n|))) := by\n  suffices Summable (fun n : â„• â†¦ (n ^ k : â„) * Real.exp (-Ï€ * (T * n ^ 2 - 2 * S * n))) by\n    apply Summable.of_nat_of_neg <;>\n    simpa only [Int.cast_neg, neg_sq, abs_neg, Int.cast_natCast, Nat.abs_cast]\n  apply summable_of_isBigO_nat (summable_pow_mul_exp_neg_nat_mul k zero_lt_one)\n  apply IsBigO.mul (isBigO_refl _ _)\n  refine Real.isBigO_exp_comp_exp_comp.mpr (Tendsto.isBoundedUnder_le_atBot ?_)\n  simp_rw [â† tendsto_neg_atTop_iff, Pi.sub_apply]\n  conv =>\n    enter [1, n]\n    rw [show -(-Ï€ * (T * n ^ 2 - 2 * S * n) - -1 * n) = n * (Ï€ * T * n - (2 * Ï€ * S + 1)) by ring]\n  refine tendsto_natCast_atTop_atTop.atTop_mul_atTop (tendsto_atTop_add_const_right _ _ ?_)\n  exact tendsto_natCast_atTop_atTop.const_mul_atTop (mul_pos pi_pos hT)\n\n"}
{"name":"summable_jacobiThetaâ‚‚_term_iff","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Iff (Summable fun x => jacobiThetaâ‚‚_term x z Ï„) (LT.lt 0 Ï„.im)","decl":"/-- The series defining the theta function is summable if and only if `0 < im Ï„`. -/\nlemma summable_jacobiThetaâ‚‚_term_iff (z Ï„ : â„‚) : Summable (jacobiThetaâ‚‚_term Â· z Ï„) â†” 0 < im Ï„ := by\n  -- NB. This is a statement of no great mathematical interest; it is included largely to avoid\n  -- having to impose `0 < im Ï„` as a hypothesis on many later lemmas.\n  refine Iff.symm âŸ¨fun hÏ„ â†¦ ?_, fun h â†¦ ?_âŸ© -- do quicker implication first!\n  Â· refine (summable_pow_mul_jacobiThetaâ‚‚_term_bound |im z| hÏ„ 0).of_norm_bounded _ ?_\n    simpa only [pow_zero, one_mul] using norm_jacobiThetaâ‚‚_term_le hÏ„ le_rfl le_rfl\n  Â· by_contra! hÏ„\n    rcases lt_or_eq_of_le hÏ„ with hÏ„ | hÏ„\n    Â· -- easy case `im Ï„ < 0`\n      suffices Tendsto (fun n : â„• â†¦ â€–jacobiThetaâ‚‚_term â†‘n z Ï„â€–) atTop atTop by\n        replace h := (h.comp_injective (fun a b â†¦ Int.ofNat_inj.mp)).tendsto_atTop_zero.norm\n        exact atTop_neBot.ne (disjoint_self.mp <| h.disjoint (disjoint_nhds_atTop _) this)\n      simp only [norm_zero, Function.comp_def, norm_jacobiThetaâ‚‚_term, Int.cast_natCast]\n      conv =>\n        enter [1, n]\n        rw [show -Ï€ * n ^ 2 * Ï„.im - 2 * Ï€ * n * z.im =\n              n * (n * (-Ï€ * Ï„.im) - 2 * Ï€ * z.im) by ring]\n      refine tendsto_exp_atTop.comp (tendsto_natCast_atTop_atTop.atTop_mul_atTop ?_)\n      exact tendsto_atTop_add_const_right _ _ (tendsto_natCast_atTop_atTop.atTop_mul_const\n        (mul_pos_of_neg_of_neg (neg_lt_zero.mpr pi_pos) hÏ„))\n    Â· -- case im Ï„ = 0: 3-way split according to `im z`\n      simp_rw [â† summable_norm_iff (E := â„‚), norm_jacobiThetaâ‚‚_term, hÏ„, mul_zero, zero_sub] at h\n      rcases lt_trichotomy (im z) 0 with hz | hz | hz\n      Â· replace h := (h.comp_injective (fun a b â†¦ Int.ofNat_inj.mp)).tendsto_atTop_zero\n        simp_rw [Function.comp_def, Int.cast_natCast] at h\n        refine atTop_neBot.ne (disjoint_self.mp <| h.disjoint (disjoint_nhds_atTop 0) ?_)\n        refine tendsto_exp_atTop.comp ?_\n        simp only [tendsto_neg_atTop_iff, mul_assoc]\n        apply Filter.Tendsto.const_mul_atBot two_pos\n        exact (tendsto_natCast_atTop_atTop.atTop_mul_const_of_neg hz).const_mul_atBot pi_pos\n      Â· revert h\n        simpa only [hz, mul_zero, neg_zero, Real.exp_zero, summable_const_iff] using one_ne_zero\n      Â· have : ((-â†‘Â·) : â„• â†’ â„¤).Injective := fun _ _ â†¦ by simp only [neg_inj, Nat.cast_inj, imp_self]\n        replace h := (h.comp_injective this).tendsto_atTop_zero\n        simp_rw [Function.comp_def, Int.cast_neg, Int.cast_natCast, mul_neg, neg_mul, neg_neg] at h\n        refine atTop_neBot.ne (disjoint_self.mp <| h.disjoint (disjoint_nhds_atTop 0) ?_)\n        exact tendsto_exp_atTop.comp ((tendsto_natCast_atTop_atTop.const_mul_atTop\n          (mul_pos two_pos pi_pos)).atTop_mul_const hz)\n\n"}
{"name":"norm_jacobiThetaâ‚‚_term_fderiv_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz Ï„ : Complex\nâŠ¢ LE.le (Norm.norm (jacobiThetaâ‚‚_term_fderiv n z Ï„)) (HMul.hMul (HMul.hMul (HMul.hMul 3 Real.pi) (HPow.hPow (â†‘(abs n)) 2)) (Norm.norm (jacobiThetaâ‚‚_term n z Ï„)))","decl":"lemma norm_jacobiThetaâ‚‚_term_fderiv_le (n : â„¤) (z Ï„ : â„‚) :\n    â€–jacobiThetaâ‚‚_term_fderiv n z Ï„â€– â‰¤ 3 * Ï€ * |n| ^ 2 * â€–jacobiThetaâ‚‚_term n z Ï„â€– := by\n  -- this is slow to elaborate so do it once and reuse:\n  have hns (a : â„‚) (f : (â„‚ Ã— â„‚) â†’L[â„‚] â„‚) : â€–a â€¢ fâ€– = â€–aâ€– * â€–fâ€– := norm_smul a f\n  rw [jacobiThetaâ‚‚_term_fderiv, jacobiThetaâ‚‚_term, hns,\n    mul_comm _ â€–cexp _â€–, (by norm_num : (3 : â„) = 2 + 1), add_mul, add_mul]\n  refine mul_le_mul_of_nonneg_left ((norm_add_le _ _).trans (add_le_add ?_ ?_)) (norm_nonneg _)\n  Â· simp_rw [hns, norm_mul, â† ofReal_ofNat, â† ofReal_intCast,\n      norm_real, norm_of_nonneg zero_le_two, Real.norm_of_nonneg pi_pos.le, norm_I, mul_one,\n      Real.norm_eq_abs, Int.cast_abs, mul_assoc]\n    refine mul_le_mul_of_nonneg_left (mul_le_mul_of_nonneg_left ?_ pi_pos.le) two_pos.le\n    refine le_trans ?_ (?_ : |(n : â„)| â‰¤ |(n : â„)| ^ 2)\n    Â· exact mul_le_of_le_one_right (abs_nonneg _) (ContinuousLinearMap.norm_fst_le ..)\n    Â· exact_mod_cast Int.le_self_sq |n|\n  Â· simp_rw [hns, norm_mul, one_mul, norm_I, mul_one,\n      norm_real, norm_of_nonneg pi_pos.le, â† ofReal_intCast, â† ofReal_pow, norm_real,\n      Real.norm_eq_abs, Int.cast_abs, _root_.abs_pow]\n    apply mul_le_of_le_one_right (mul_nonneg pi_pos.le (pow_nonneg (abs_nonneg _) _))\n    exact ContinuousLinearMap.norm_snd_le ..\n\n"}
{"name":"norm_jacobiThetaâ‚‚_term_fderiv_ge","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz Ï„ : Complex\nâŠ¢ LE.le (HMul.hMul (HMul.hMul Real.pi (HPow.hPow (â†‘(abs n)) 2)) (Norm.norm (jacobiThetaâ‚‚_term n z Ï„))) (Norm.norm (jacobiThetaâ‚‚_term_fderiv n z Ï„))","decl":"lemma norm_jacobiThetaâ‚‚_term_fderiv_ge (n : â„¤) (z Ï„ : â„‚) :\n    Ï€ * |n| ^ 2 * â€–jacobiThetaâ‚‚_term n z Ï„â€– â‰¤ â€–jacobiThetaâ‚‚_term_fderiv n z Ï„â€– := by\n  have : â€–(jacobiThetaâ‚‚_term_fderiv n z Ï„) (0, 1)â€– â‰¤ â€–jacobiThetaâ‚‚_term_fderiv n z Ï„â€– := by\n    refine (ContinuousLinearMap.le_opNorm _ _).trans ?_\n    simp_rw [Prod.norm_def, norm_one, norm_zero, max_eq_right zero_le_one, mul_one, le_refl]\n  refine le_trans ?_ this\n  simp_rw [jacobiThetaâ‚‚_term_fderiv, jacobiThetaâ‚‚_term, ContinuousLinearMap.coe_smul',\n    Pi.smul_apply, ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',\n    ContinuousLinearMap.coe_fst', ContinuousLinearMap.coe_snd', Pi.smul_apply, smul_zero, zero_add,\n    smul_eq_mul, mul_one, mul_comm _ â€–cexp _â€–, norm_mul]\n  refine mul_le_mul_of_nonneg_left (le_of_eq ?_) (norm_nonneg _)\n  simp_rw [norm_real, norm_of_nonneg pi_pos.le, norm_I, mul_one,\n    Int.cast_abs, â† abs_intCast, Complex.norm_eq_abs, Complex.abs_pow]\n\n"}
{"name":"summable_jacobiThetaâ‚‚_term_fderiv_iff","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Iff (Summable fun x => jacobiThetaâ‚‚_term_fderiv x z Ï„) (LT.lt 0 Ï„.im)","decl":"lemma summable_jacobiThetaâ‚‚_term_fderiv_iff (z Ï„ : â„‚) :\n    Summable (jacobiThetaâ‚‚_term_fderiv Â· z Ï„) â†” 0 < im Ï„ := by\n  constructor\n  Â· rw [â† summable_jacobiThetaâ‚‚_term_iff (z := z)]\n    intro h\n    have := h.norm\n    refine this.of_norm_bounded_eventually _ ?_\n    have : âˆ€á¶  (n : â„¤) in cofinite, n â‰  0 :=\n      Int.cofinite_eq â–¸ (mem_sup.mpr âŸ¨eventually_ne_atBot 0, eventually_ne_atTop 0âŸ©)\n    filter_upwards [this] with n hn\n    refine le_trans ?_ (norm_jacobiThetaâ‚‚_term_fderiv_ge n z Ï„)\n    apply le_mul_of_one_le_left (norm_nonneg _)\n    refine one_le_pi_div_two.trans (mul_le_mul_of_nonneg_left ?_ pi_pos.le)\n    refine (by norm_num : 2â»Â¹ â‰¤ (1 : â„)).trans ?_\n    rw [one_le_sq_iff_one_le_abs, â† Int.cast_abs, _root_.abs_abs, â† Int.cast_one, Int.cast_le]\n    exact Int.one_le_abs hn\n  Â· intro hÏ„\n    refine ((summable_pow_mul_jacobiThetaâ‚‚_term_bound\n      |z.im| hÏ„ 2).mul_left (3 * Ï€)).of_norm_bounded _ (fun n â†¦ ?_)\n    refine (norm_jacobiThetaâ‚‚_term_fderiv_le n z Ï„).trans\n      (?_ : 3 * Ï€ * |n| ^ 2 * â€–jacobiThetaâ‚‚_term n z Ï„â€– â‰¤ _)\n    simp_rw [mul_assoc (3 * Ï€)]\n    refine mul_le_mul_of_nonneg_left ?_ (mul_pos (by norm_num : 0 < (3 : â„)) pi_pos).le\n    refine mul_le_mul_of_nonneg_left ?_ (pow_nonneg (Int.cast_nonneg.mpr (abs_nonneg _)) _)\n    exact norm_jacobiThetaâ‚‚_term_le hÏ„ le_rfl le_rfl n\n\n"}
{"name":"summable_jacobiThetaâ‚‚'_term_iff","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Iff (Summable fun x => jacobiThetaâ‚‚'_term x z Ï„) (LT.lt 0 Ï„.im)","decl":"lemma summable_jacobiThetaâ‚‚'_term_iff (z Ï„ : â„‚) :\n    Summable (jacobiThetaâ‚‚'_term Â· z Ï„) â†” 0 < im Ï„ := by\n  constructor\n  Â· rw [â† summable_jacobiThetaâ‚‚_term_iff (z := z)]\n    refine fun h â†¦ (h.norm.mul_left (2 * Ï€)â»Â¹).of_norm_bounded_eventually _  ?_\n    have : âˆ€á¶  (n : â„¤) in cofinite, n â‰  0 :=\n      Int.cofinite_eq â–¸ (mem_sup.mpr âŸ¨eventually_ne_atBot 0, eventually_ne_atTop 0âŸ©)\n    filter_upwards [this] with n hn\n    rw [jacobiThetaâ‚‚'_term, norm_mul, â† mul_assoc]\n    refine le_mul_of_one_le_left (norm_nonneg _) ?_\n    simp_rw [norm_mul, norm_I, norm_real, mul_one, norm_of_nonneg pi_pos.le,\n      â† ofReal_ofNat, norm_real, norm_of_nonneg two_pos.le, â† ofReal_intCast, norm_real,\n      Real.norm_eq_abs, â† Int.cast_abs, â† mul_assoc _ (2 * Ï€),\n      inv_mul_cancelâ‚€ (mul_pos two_pos pi_pos).ne', one_mul]\n    rw [â† Int.cast_one, Int.cast_le]\n    exact Int.one_le_abs hn\n  Â· refine fun hÏ„ â†¦ ((summable_pow_mul_jacobiThetaâ‚‚_term_bound\n      |z.im| hÏ„ 1).mul_left (2 * Ï€)).of_norm_bounded _ (fun n â†¦ ?_)\n    rw [jacobiThetaâ‚‚'_term, norm_mul, â† mul_assoc, pow_one]\n    refine mul_le_mul (le_of_eq ?_) (norm_jacobiThetaâ‚‚_term_le hÏ„ le_rfl le_rfl n)\n      (norm_nonneg _) (by positivity)\n    simp_rw [norm_mul, Complex.norm_eq_abs, Complex.abs_two, abs_I,\n      Complex.abs_of_nonneg pi_pos.le, abs_intCast, mul_one, Int.cast_abs]\n\n"}
{"name":"hasSum_jacobiThetaâ‚‚_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ HasSum (fun n => jacobiThetaâ‚‚_term n z Ï„) (jacobiThetaâ‚‚ z Ï„)","decl":"lemma hasSum_jacobiThetaâ‚‚_term (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    HasSum (fun n â†¦ jacobiThetaâ‚‚_term n z Ï„) (jacobiThetaâ‚‚ z Ï„) :=\n  ((summable_jacobiThetaâ‚‚_term_iff z Ï„).mpr hÏ„).hasSum\n\n"}
{"name":"hasSum_jacobiThetaâ‚‚_term_fderiv","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ HasSum (fun n => jacobiThetaâ‚‚_term_fderiv n z Ï„) (jacobiThetaâ‚‚_fderiv z Ï„)","decl":"lemma hasSum_jacobiThetaâ‚‚_term_fderiv (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    HasSum (fun n â†¦ jacobiThetaâ‚‚_term_fderiv n z Ï„) (jacobiThetaâ‚‚_fderiv z Ï„) :=\n  ((summable_jacobiThetaâ‚‚_term_fderiv_iff z Ï„).mpr hÏ„).hasSum\n\n"}
{"name":"hasSum_jacobiThetaâ‚‚'_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ HasSum (fun n => jacobiThetaâ‚‚'_term n z Ï„) (jacobiThetaâ‚‚' z Ï„)","decl":"lemma hasSum_jacobiThetaâ‚‚'_term (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    HasSum (fun n â†¦ jacobiThetaâ‚‚'_term n z Ï„) (jacobiThetaâ‚‚' z Ï„) :=\n  ((summable_jacobiThetaâ‚‚'_term_iff z Ï„).mpr hÏ„).hasSum\n\n"}
{"name":"jacobiThetaâ‚‚_undef","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LE.le Ï„.im 0\nâŠ¢ Eq (jacobiThetaâ‚‚ z Ï„) 0","decl":"lemma jacobiThetaâ‚‚_undef (z : â„‚) {Ï„ : â„‚} (hÏ„ : im Ï„ â‰¤ 0) : jacobiThetaâ‚‚ z Ï„ = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiThetaâ‚‚_term_iff]\n  exact not_lt.mpr hÏ„\n\n"}
{"name":"jacobiThetaâ‚‚_fderiv_undef","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LE.le Ï„.im 0\nâŠ¢ Eq (jacobiThetaâ‚‚_fderiv z Ï„) 0","decl":"lemma jacobiThetaâ‚‚_fderiv_undef (z : â„‚) {Ï„ : â„‚} (hÏ„ : im Ï„ â‰¤ 0) : jacobiThetaâ‚‚_fderiv z Ï„ = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiThetaâ‚‚_term_fderiv_iff]\n  exact not_lt.mpr hÏ„\n\n"}
{"name":"jacobiThetaâ‚‚'_undef","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LE.le Ï„.im 0\nâŠ¢ Eq (jacobiThetaâ‚‚' z Ï„) 0","decl":"lemma jacobiThetaâ‚‚'_undef (z : â„‚) {Ï„ : â„‚} (hÏ„ : im Ï„ â‰¤ 0) : jacobiThetaâ‚‚' z Ï„ = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiThetaâ‚‚'_term_iff]\n  exact not_lt.mpr hÏ„\n\n"}
{"name":"hasFDerivAt_jacobiThetaâ‚‚","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ HasFDerivAt (fun p => jacobiThetaâ‚‚ p.1 p.2) (jacobiThetaâ‚‚_fderiv z Ï„) { fst := z, snd := Ï„ }","decl":"lemma hasFDerivAt_jacobiThetaâ‚‚ (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    HasFDerivAt (fun p : â„‚ Ã— â„‚ â†¦ jacobiThetaâ‚‚ p.1 p.2) (jacobiThetaâ‚‚_fderiv z Ï„) (z, Ï„) := by\n  obtain âŸ¨T, hT, hÏ„'âŸ© := exists_between hÏ„\n  obtain âŸ¨S, hzâŸ© := exists_gt |im z|\n  let V := {u | |im u| < S} Ã—Ë¢ {v | T < im v}\n  have hVo : IsOpen V := by\n    refine ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _ isOpen_Iio).prod ?_\n    exact continuous_im.isOpen_preimage _ isOpen_Ioi\n  have hVmem : (z, Ï„) âˆˆ V := âŸ¨hz, hÏ„'âŸ©\n  have hVp : IsPreconnected V := by\n    refine (Convex.isPreconnected ?_).prod (convex_halfSpace_im_gt T).isPreconnected\n    simpa only [abs_lt] using (convex_halfSpace_im_gt _).inter (convex_halfSpace_im_lt _)\n  let f : â„¤ â†’ â„‚ Ã— â„‚ â†’ â„‚ := fun n p â†¦ jacobiThetaâ‚‚_term n p.1 p.2\n  let f' : â„¤ â†’ â„‚ Ã— â„‚ â†’ â„‚ Ã— â„‚ â†’L[â„‚] â„‚ := fun n p â†¦ jacobiThetaâ‚‚_term_fderiv n p.1 p.2\n  have hf (n : â„¤) : âˆ€ p âˆˆ V, HasFDerivAt (f n) (f' n p) p :=\n    fun p _ â†¦ hasFDerivAt_jacobiThetaâ‚‚_term n p.1 p.2\n  let u : â„¤ â†’ â„ := fun n â†¦ 3 * Ï€ * |n| ^ 2 * Real.exp (-Ï€ * (T * n ^ 2 - 2 * S * |n|))\n  have hu : âˆ€ (n : â„¤), âˆ€ x âˆˆ V, â€–f' n xâ€– â‰¤ u n := by\n    refine fun n p hp â†¦ (norm_jacobiThetaâ‚‚_term_fderiv_le n p.1 p.2).trans ?_\n    refine mul_le_mul_of_nonneg_left ?_ (by positivity)\n    exact norm_jacobiThetaâ‚‚_term_le hT (le_of_lt hp.1) (le_of_lt hp.2) n\n  have hu_sum : Summable u := by\n    simp_rw [u, mul_assoc (3 * Ï€)]\n    exact (summable_pow_mul_jacobiThetaâ‚‚_term_bound S hT 2).mul_left _\n  have hf_sum : Summable fun n : â„¤ â†¦ f n (z, Ï„) := by\n    refine (summable_pow_mul_jacobiThetaâ‚‚_term_bound S hT 0).of_norm_bounded _ ?_\n    simpa only [pow_zero, one_mul] using norm_jacobiThetaâ‚‚_term_le hT hz.le hÏ„'.le\n  simpa only [jacobiThetaâ‚‚, jacobiThetaâ‚‚_fderiv, f, f'] using\n    hasFDerivAt_tsum_of_isPreconnected hu_sum hVo hVp hf hu hVmem hf_sum hVmem\n\n"}
{"name":"continuousAt_jacobiThetaâ‚‚","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ ContinuousAt (fun p => jacobiThetaâ‚‚ p.1 p.2) { fst := z, snd := Ï„ }","decl":"lemma continuousAt_jacobiThetaâ‚‚ (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    ContinuousAt (fun p : â„‚ Ã— â„‚ â†¦ jacobiThetaâ‚‚ p.1 p.2) (z, Ï„) :=\n  (hasFDerivAt_jacobiThetaâ‚‚ z hÏ„).continuousAt\n\n"}
{"name":"differentiableAt_jacobiThetaâ‚‚_fst","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ DifferentiableAt Complex (fun x => jacobiThetaâ‚‚ x Ï„) z","decl":"/-- Differentiability of `Î˜ z Ï„` in `z`, for fixed `Ï„`. -/\nlemma differentiableAt_jacobiThetaâ‚‚_fst (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    DifferentiableAt â„‚ (jacobiThetaâ‚‚ Â· Ï„) z :=\n ((hasFDerivAt_jacobiThetaâ‚‚ z hÏ„).comp (ğ•œ := â„‚) z (hasFDerivAt_prod_mk_left z Ï„) :).differentiableAt\n\n"}
{"name":"differentiableAt_jacobiThetaâ‚‚_snd","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ DifferentiableAt Complex (jacobiThetaâ‚‚ z) Ï„","decl":"/-- Differentiability of `Î˜ z Ï„` in `Ï„`, for fixed `z`. -/\nlemma differentiableAt_jacobiThetaâ‚‚_snd (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    DifferentiableAt â„‚ (jacobiThetaâ‚‚ z) Ï„ :=\n  ((hasFDerivAt_jacobiThetaâ‚‚ z hÏ„).comp Ï„ (hasFDerivAt_prod_mk_right z Ï„)).differentiableAt\n\n"}
{"name":"hasDerivAt_jacobiThetaâ‚‚_fst","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ HasDerivAt (fun x => jacobiThetaâ‚‚ x Ï„) (jacobiThetaâ‚‚' z Ï„) z","decl":"lemma hasDerivAt_jacobiThetaâ‚‚_fst (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    HasDerivAt (jacobiThetaâ‚‚ Â· Ï„) (jacobiThetaâ‚‚' z Ï„) z := by\n  -- This proof is annoyingly fiddly, because of the need to commute \"evaluation at a point\"\n  -- through infinite sums of continuous linear maps.\n  let eval_fst_CLM : (â„‚ Ã— â„‚ â†’L[â„‚] â„‚) â†’L[â„‚] â„‚ :=\n  { toFun := fun f â†¦ f (1, 0)\n    cont := continuous_id'.clm_apply continuous_const\n    map_add' := by simp only [ContinuousLinearMap.add_apply, forall_const]\n    map_smul' := by simp only [ContinuousLinearMap.coe_smul', Pi.smul_apply, smul_eq_mul,\n      RingHom.id_apply, forall_const] }\n  have step1 : HasSum (fun n â†¦ (jacobiThetaâ‚‚_term_fderiv n z Ï„) (1, 0))\n      ((jacobiThetaâ‚‚_fderiv z Ï„) (1, 0)) := by\n    apply eval_fst_CLM.hasSum (hasSum_jacobiThetaâ‚‚_term_fderiv z hÏ„)\n  have step2 (n : â„¤) : (jacobiThetaâ‚‚_term_fderiv n z Ï„) (1, 0) = jacobiThetaâ‚‚'_term n z Ï„ := by\n    simp only [jacobiThetaâ‚‚_term_fderiv, smul_add, ContinuousLinearMap.add_apply,\n      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_fst', Pi.smul_apply, smul_eq_mul,\n      mul_one, ContinuousLinearMap.coe_snd', mul_zero, add_zero, jacobiThetaâ‚‚'_term,\n      jacobiThetaâ‚‚_term, mul_comm _ (cexp _)]\n  rw [funext step2] at step1\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n    need `by exact` to bypass unification failure -/\n  have step3 : HasDerivAt (fun x â†¦ jacobiThetaâ‚‚ x Ï„) ((jacobiThetaâ‚‚_fderiv z Ï„) (1, 0)) z := by\n    exact ((hasFDerivAt_jacobiThetaâ‚‚ z hÏ„).comp z (hasFDerivAt_prod_mk_left z Ï„)).hasDerivAt\n  rwa [â† step1.tsum_eq] at step3\n\n"}
{"name":"continuousAt_jacobiThetaâ‚‚'","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nhÏ„ : LT.lt 0 Ï„.im\nâŠ¢ ContinuousAt (fun p => jacobiThetaâ‚‚' p.1 p.2) { fst := z, snd := Ï„ }","decl":"lemma continuousAt_jacobiThetaâ‚‚' (z : â„‚) {Ï„ : â„‚} (hÏ„ : 0 < im Ï„) :\n    ContinuousAt (fun p : â„‚ Ã— â„‚ â†¦ jacobiThetaâ‚‚' p.1 p.2) (z, Ï„) := by\n  obtain âŸ¨T, hT, hÏ„'âŸ© := exists_between hÏ„\n  obtain âŸ¨S, hzâŸ© := exists_gt |im z|\n  let V := {u | |im u| < S} Ã—Ë¢ {v | T < im v}\n  have hVo : IsOpen V := ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _\n    isOpen_Iio).prod (continuous_im.isOpen_preimage _ isOpen_Ioi)\n  refine ContinuousOn.continuousAt ?_ (hVo.mem_nhds âŸ¨hz, hÏ„'âŸ©)\n  let u (n : â„¤) : â„ := 2 * Ï€ * |n| * rexp (-Ï€ * (T * n ^ 2 - 2 * S * |n|))\n  have hu : Summable u  := by simpa only [u, mul_assoc, pow_one]\n      using (summable_pow_mul_jacobiThetaâ‚‚_term_bound S hT 1).mul_left (2 * Ï€)\n  refine continuousOn_tsum (fun n â†¦ ?_) hu (fun n âŸ¨z', Ï„'âŸ© âŸ¨hz', hÏ„'âŸ© â†¦ ?_)\n  Â· apply Continuous.continuousOn\n    unfold jacobiThetaâ‚‚'_term jacobiThetaâ‚‚_term\n    fun_prop\n  Â· exact norm_jacobiThetaâ‚‚'_term_le hT (le_of_lt hz') (le_of_lt hÏ„') n\n\n"}
{"name":"jacobiThetaâ‚‚_add_right","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚ z (HAdd.hAdd Ï„ 2)) (jacobiThetaâ‚‚ z Ï„)","decl":"/-- The two-variable Jacobi theta function is periodic in `Ï„` with period 2. -/\nlemma jacobiThetaâ‚‚_add_right (z Ï„ : â„‚) : jacobiThetaâ‚‚ z (Ï„ + 2) = jacobiThetaâ‚‚ z Ï„ := by\n  refine tsum_congr (fun n â†¦ ?_)\n  simp_rw [jacobiThetaâ‚‚_term, Complex.exp_add]\n  suffices cexp (Ï€ * I * n ^ 2 * 2 : â„‚) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]\n  rw [(by push_cast; ring : (Ï€ * I * n ^ 2 * 2 : â„‚) = (n ^ 2 :) * (2 * Ï€ * I)), exp_int_mul,\n    exp_two_pi_mul_I, one_zpow]\n\n"}
{"name":"jacobiThetaâ‚‚_add_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚ (HAdd.hAdd z 1) Ï„) (jacobiThetaâ‚‚ z Ï„)","decl":"/-- The two-variable Jacobi theta function is periodic in `z` with period 1. -/\nlemma jacobiThetaâ‚‚_add_left (z Ï„ : â„‚) : jacobiThetaâ‚‚ (z + 1) Ï„ = jacobiThetaâ‚‚ z Ï„ := by\n  refine tsum_congr (fun n â†¦ ?_)\n  simp_rw [jacobiThetaâ‚‚_term, mul_add, Complex.exp_add, mul_one, mul_comm _ (n : â„‚),\n    exp_int_mul_two_pi_mul_I, mul_one]\n\n"}
{"name":"jacobiThetaâ‚‚_add_left'","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚ (HAdd.hAdd z Ï„) Ï„) (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg â†‘Real.pi) Complex.I) (HAdd.hAdd Ï„ (HMul.hMul 2 z)))) (jacobiThetaâ‚‚ z Ï„))","decl":"/-- The two-variable Jacobi theta function is quasi-periodic in `z` with period `Ï„`. -/\nlemma jacobiThetaâ‚‚_add_left' (z Ï„ : â„‚) :\n    jacobiThetaâ‚‚ (z + Ï„) Ï„ = cexp (-Ï€ * I * (Ï„ + 2 * z)) * jacobiThetaâ‚‚ z Ï„ := by\n  conv_rhs => erw [â† tsum_mul_left, â† (Equiv.addRight 1).tsum_eq]\n  refine tsum_congr (fun n â†¦ ?_)\n  simp_rw [jacobiThetaâ‚‚_term, â† Complex.exp_add, Equiv.coe_addRight, Int.cast_add]\n  ring_nf\n\n"}
{"name":"jacobiThetaâ‚‚_neg_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚ (Neg.neg z) Ï„) (jacobiThetaâ‚‚ z Ï„)","decl":"/-- The two-variable Jacobi theta function is even in `z`. -/\n@[simp]\nlemma jacobiThetaâ‚‚_neg_left (z Ï„ : â„‚) : jacobiThetaâ‚‚ (-z) Ï„ = jacobiThetaâ‚‚ z Ï„ := by\n  conv_lhs => rw [jacobiThetaâ‚‚, â† Equiv.tsum_eq (Equiv.neg â„¤)]\n  refine tsum_congr (fun n â†¦ ?_)\n  simp_rw [jacobiThetaâ‚‚_term, Equiv.neg_apply, Int.cast_neg, neg_sq, mul_assoc, neg_mul_neg]\n\n"}
{"name":"jacobiThetaâ‚‚_conj","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq ((starRingEnd Complex) (jacobiThetaâ‚‚ z Ï„)) (jacobiThetaâ‚‚ ((starRingEnd Complex) z) (Neg.neg ((starRingEnd Complex) Ï„)))","decl":"lemma jacobiThetaâ‚‚_conj (z Ï„ : â„‚) :\n    conj (jacobiThetaâ‚‚ z Ï„) = jacobiThetaâ‚‚ (conj z) (-conj Ï„) := by\n  rw [â† jacobiThetaâ‚‚_neg_left, jacobiThetaâ‚‚, conj_tsum]\n  congr 2 with n\n  simp only [jacobiThetaâ‚‚_term, mul_neg, â† exp_conj, map_add, map_neg, map_mul, map_ofNat,\n    conj_ofReal, conj_I, map_intCast, neg_mul, neg_neg, map_pow]\n\n"}
{"name":"jacobiThetaâ‚‚'_add_right","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚' z (HAdd.hAdd Ï„ 2)) (jacobiThetaâ‚‚' z Ï„)","decl":"lemma jacobiThetaâ‚‚'_add_right (z Ï„ : â„‚) : jacobiThetaâ‚‚' z (Ï„ + 2) = jacobiThetaâ‚‚' z Ï„ := by\n  refine tsum_congr (fun n â†¦ ?_)\n  simp_rw [jacobiThetaâ‚‚'_term, jacobiThetaâ‚‚_term, Complex.exp_add]\n  suffices cexp (Ï€ * I * n ^ 2 * 2 : â„‚) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]\n  rw [(by push_cast; ring : (Ï€ * I * n ^ 2 * 2 : â„‚) = (n ^ 2 :) * (2 * Ï€ * I)), exp_int_mul,\n    exp_two_pi_mul_I, one_zpow]\n\n"}
{"name":"jacobiThetaâ‚‚'_add_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚' (HAdd.hAdd z 1) Ï„) (jacobiThetaâ‚‚' z Ï„)","decl":"lemma jacobiThetaâ‚‚'_add_left (z Ï„ : â„‚) : jacobiThetaâ‚‚' (z + 1) Ï„ = jacobiThetaâ‚‚' z Ï„ := by\n  unfold jacobiThetaâ‚‚' jacobiThetaâ‚‚'_term jacobiThetaâ‚‚_term\n  refine tsum_congr (fun n â†¦ ?_)\n  simp only [mul_add, Complex.exp_add, mul_one, mul_comm _ (n : â„‚), exp_int_mul_two_pi_mul_I,\n    mul_one]\n\n"}
{"name":"jacobiThetaâ‚‚'_add_left'","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚' (HAdd.hAdd z Ï„) Ï„) (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg â†‘Real.pi) Complex.I) (HAdd.hAdd Ï„ (HMul.hMul 2 z)))) (HSub.hSub (jacobiThetaâ‚‚' z Ï„) (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I) (jacobiThetaâ‚‚ z Ï„))))","decl":"lemma jacobiThetaâ‚‚'_add_left' (z Ï„ : â„‚) :\n    jacobiThetaâ‚‚' (z + Ï„) Ï„ =\n      cexp (-Ï€ * I * (Ï„ + 2 * z)) * (jacobiThetaâ‚‚' z Ï„ - 2 * Ï€ * I * jacobiThetaâ‚‚ z Ï„) := by\n  rcases le_or_lt Ï„.im 0 with hÏ„ | hÏ„\n  Â· simp_rw [jacobiThetaâ‚‚_undef _ hÏ„, jacobiThetaâ‚‚'_undef _ hÏ„, mul_zero, sub_zero, mul_zero]\n  have (n : â„¤) : jacobiThetaâ‚‚'_term n (z + Ï„) Ï„ =\n      cexp (-Ï€ * I * (Ï„ + 2 * z)) * (jacobiThetaâ‚‚'_term (n + 1) z Ï„ -\n      2 * Ï€ * I * jacobiThetaâ‚‚_term (n + 1) z Ï„) := by\n    simp only [jacobiThetaâ‚‚'_term, jacobiThetaâ‚‚_term]\n    conv_rhs => rw [â† sub_mul, mul_comm, mul_assoc, â† Complex.exp_add, Int.cast_add, Int.cast_one,\n      mul_add, mul_one, add_sub_cancel_right]\n    congr 2\n    ring\n  rw [jacobiThetaâ‚‚', funext this, tsum_mul_left, â† (Equiv.subRight (1 : â„¤)).tsum_eq]\n  simp only [jacobiThetaâ‚‚, jacobiThetaâ‚‚', Equiv.subRight_apply, sub_add_cancel,\n    tsum_sub (hasSum_jacobiThetaâ‚‚'_term z hÏ„).summable\n    ((hasSum_jacobiThetaâ‚‚_term z hÏ„).summable.mul_left _), tsum_mul_left]\n\n"}
{"name":"jacobiThetaâ‚‚'_neg_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚' (Neg.neg z) Ï„) (Neg.neg (jacobiThetaâ‚‚' z Ï„))","decl":"lemma jacobiThetaâ‚‚'_neg_left (z Ï„ : â„‚) : jacobiThetaâ‚‚' (-z) Ï„ = -jacobiThetaâ‚‚' z Ï„ := by\n  rw [jacobiThetaâ‚‚', jacobiThetaâ‚‚', â† tsum_neg, â† (Equiv.neg â„¤).tsum_eq]\n  congr 1 with n\n  simp only [jacobiThetaâ‚‚'_term, jacobiThetaâ‚‚_term]\n  rw [Equiv.neg_apply, â† neg_mul]\n  push_cast\n  ring_nf\n\n"}
{"name":"jacobiThetaâ‚‚'_conj","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq ((starRingEnd Complex) (jacobiThetaâ‚‚' z Ï„)) (jacobiThetaâ‚‚' ((starRingEnd Complex) z) (Neg.neg ((starRingEnd Complex) Ï„)))","decl":"lemma jacobiThetaâ‚‚'_conj (z Ï„ : â„‚) :\n    conj (jacobiThetaâ‚‚' z Ï„) = jacobiThetaâ‚‚' (conj z) (-conj Ï„) := by\n  rw [â† neg_inj, â† jacobiThetaâ‚‚'_neg_left, jacobiThetaâ‚‚', jacobiThetaâ‚‚', conj_tsum, â† tsum_neg]\n  congr 1 with n\n  simp_rw [jacobiThetaâ‚‚'_term, jacobiThetaâ‚‚_term, map_mul, â† Complex.exp_conj, map_add, map_mul,\n    â† ofReal_intCast,â† ofReal_ofNat, map_pow, conj_ofReal, conj_I]\n  ring_nf\n\n"}
{"name":"jacobiThetaâ‚‚_functional_equation","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚ z Ï„) (HMul.hMul (HMul.hMul (HDiv.hDiv 1 (HPow.hPow (HMul.hMul (Neg.neg Complex.I) Ï„) (1 / 2))) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg â†‘Real.pi) Complex.I) (HPow.hPow z 2)) Ï„))) (jacobiThetaâ‚‚ (HDiv.hDiv z Ï„) (HDiv.hDiv (-1) Ï„)))","decl":"/-- The functional equation for the Jacobi theta function: `jacobiThetaâ‚‚ z Ï„` is an explicit factor\ntimes `jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„)`. This is the key lemma behind the proof of the functional\nequation for L-series of even Dirichlet characters. -/\ntheorem jacobiThetaâ‚‚_functional_equation (z Ï„ : â„‚) : jacobiThetaâ‚‚ z Ï„ =\n    1 / (-I * Ï„) ^ (1 / 2 : â„‚) * cexp (-Ï€ * I * z ^ 2 / Ï„) * jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„) := by\n  rcases le_or_lt (im Ï„) 0 with hÏ„ | hÏ„\n  Â· have : (-1 / Ï„).im â‰¤ 0 := by\n      rw [neg_div, neg_im, one_div, inv_im, neg_nonpos]\n      exact div_nonneg (neg_nonneg.mpr hÏ„) (normSq_nonneg Ï„)\n    rw [jacobiThetaâ‚‚_undef z hÏ„, jacobiThetaâ‚‚_undef _ this, mul_zero]\n  unfold jacobiThetaâ‚‚ jacobiThetaâ‚‚_term\n  have h0 : Ï„ â‰  0 := by contrapose! hÏ„; rw [hÏ„, zero_im]\n  have h2 : 0 < (-I * Ï„).re := by\n    simpa only [neg_mul, neg_re, mul_re, I_re, zero_mul, I_im, one_mul, zero_sub, neg_neg] using hÏ„\n  calc\n  _ = âˆ‘' n : â„¤, cexp (-Ï€ * (-I * Ï„) * â†‘n ^ 2 + 2 * Ï€ * (I * z) * â†‘n) :=\n    tsum_congr (fun n â†¦ by ring_nf)\n  _ = 1 / (-I * Ï„) ^ (1 / 2 : â„‚) * âˆ‘' (n : â„¤), cexp (-Ï€ / (-I * Ï„) * (n + I * (I * z)) ^ 2) := by\n    rw [tsum_exp_neg_quadratic h2]\n  _ = 1 / (-I * Ï„) ^ (1 / 2 : â„‚) * cexp (Ï€ * I * (-1 / Ï„) * z ^ 2) *\n      âˆ‘' (n : â„¤), cexp (2 * Ï€ * I * n * (z / Ï„) + Ï€ * I * n ^ 2 * (-1 / Ï„)) := by\n    simp_rw [mul_assoc _ (cexp _), â† tsum_mul_left (a := cexp _), â† Complex.exp_add]\n    congr 2 with n : 1; congr 1\n    field_simp [I_ne_zero]\n    ring_nf\n    simp_rw [I_sq, I_pow_four]\n    ring_nf\n  _ = _ := by\n    congr 3\n    ring\n\n"}
{"name":"jacobiThetaâ‚‚'_functional_equation","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z Ï„ : Complex\nâŠ¢ Eq (jacobiThetaâ‚‚' z Ï„) (HMul.hMul (HDiv.hDiv (HMul.hMul (HDiv.hDiv 1 (HPow.hPow (HMul.hMul (Neg.neg Complex.I) Ï„) (1 / 2))) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg â†‘Real.pi) Complex.I) (HPow.hPow z 2)) Ï„))) Ï„) (HSub.hSub (jacobiThetaâ‚‚' (HDiv.hDiv z Ï„) (HDiv.hDiv (-1) Ï„)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 â†‘Real.pi) Complex.I) z) (jacobiThetaâ‚‚ (HDiv.hDiv z Ï„) (HDiv.hDiv (-1) Ï„)))))","decl":"/-- The functional equation for the derivative of the Jacobi theta function, relating\n`jacobiThetaâ‚‚' z Ï„` to `jacobiThetaâ‚‚' (z / Ï„) (-1 / Ï„)`. This is the key lemma behind the proof of\nthe functional equation for L-series of odd Dirichlet characters. -/\ntheorem jacobiThetaâ‚‚'_functional_equation (z Ï„ : â„‚) :\n    jacobiThetaâ‚‚' z Ï„ = 1 / (-I * Ï„) ^ (1 / 2 : â„‚) * cexp (-Ï€ * I * z ^ 2 / Ï„) / Ï„ *\n      (jacobiThetaâ‚‚' (z / Ï„) (-1 / Ï„) - 2 * Ï€ * I * z * jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„)) := by\n  rcases le_or_lt (im Ï„) 0 with hÏ„ | hÏ„\n  Â· rw [jacobiThetaâ‚‚'_undef z hÏ„, jacobiThetaâ‚‚'_undef, jacobiThetaâ‚‚_undef, mul_zero,\n      sub_zero, mul_zero] <;>\n    rw [neg_div, neg_im, one_div, inv_im, neg_nonpos] <;>\n    exact div_nonneg (neg_nonneg.mpr hÏ„) (normSq_nonneg Ï„)\n  have hÏ„' : 0 < (-1 / Ï„).im := by\n    rw [div_eq_mul_inv, neg_one_mul, neg_im, inv_im, neg_div, neg_neg]\n    exact div_pos hÏ„ (normSq_pos.mpr (fun h â†¦ lt_irrefl 0 (zero_im â–¸ h â–¸ hÏ„)))\n  have hj : HasDerivAt (fun w â†¦ jacobiThetaâ‚‚ (w / Ï„) (-1 / Ï„))\n      ((1 / Ï„) * jacobiThetaâ‚‚' (z / Ï„) (-1 / Ï„)) z := by\n    have := hasDerivAt_jacobiThetaâ‚‚_fst (z / Ï„) hÏ„'\n    simpa only [mul_comm, one_div] using this.comp z (hasDerivAt_mul_const Ï„â»Â¹)\n  calc\n  _ = deriv (jacobiThetaâ‚‚ Â· Ï„) z := (hasDerivAt_jacobiThetaâ‚‚_fst z hÏ„).deriv.symm\n  _ = deriv (fun z â†¦ 1 / (-I * Ï„) ^ (1 / 2 : â„‚) *\n        cexp (-Ï€ * I * z ^ 2 / Ï„) * jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„)) z := by\n    rw [funext (jacobiThetaâ‚‚_functional_equation Â· Ï„)]\n  _ = 1 / (-I * Ï„) ^ (1 / 2 : â„‚) *\n        deriv (fun z â†¦ cexp (-Ï€ * I * z ^ 2 / Ï„) * jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„)) z := by\n    simp_rw [mul_assoc, deriv_const_mul_field]\n  _ = 1 / (-I * Ï„) ^ (1 / 2 : â„‚) *\n        (deriv (fun z â†¦ cexp (-Ï€ * I * z ^ 2 / Ï„)) z * jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„)\n         + cexp (-Ï€ * I * z ^ 2 / Ï„) * deriv (fun z â†¦ jacobiThetaâ‚‚ (z / Ï„) (-1 / Ï„)) z) := by\n    rw [deriv_mul _ hj.differentiableAt]\n    exact (((differentiableAt_pow 2).const_mul _).mul_const _).cexp\n  _ = _ := by\n    rw [hj.deriv]\n    erw [deriv_cexp (((differentiableAt_pow _).const_mul _).mul_const _)]\n    rw [mul_comm, deriv_mul_const_field, deriv_const_mul_field, deriv_pow]\n    ring_nf\n"}
