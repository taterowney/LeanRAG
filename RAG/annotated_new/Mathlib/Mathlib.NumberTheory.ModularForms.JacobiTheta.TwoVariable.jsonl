{"name":"hasFDerivAt_jacobiTheta₂_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz τ : Complex\n⊢ HasFDerivAt (fun p => jacobiTheta₂_term n p.1 p.2) (jacobiTheta₂_term_fderiv n z τ) { fst := z, snd := τ }","decl":"lemma hasFDerivAt_jacobiTheta₂_term (n : ℤ) (z τ : ℂ) :\n    HasFDerivAt (fun p : ℂ × ℂ ↦ jacobiTheta₂_term n p.1 p.2)\n    (jacobiTheta₂_term_fderiv n z τ) (z, τ) := by\n  let f : ℂ × ℂ → ℂ := fun p ↦ 2 * π * I * n * p.1 + π * I * n ^ 2 * p.2\n  suffices HasFDerivAt f ((2 * π * I * n) • (ContinuousLinearMap.fst ℂ ℂ ℂ)\n    + (π * I * n ^ 2) • (ContinuousLinearMap.snd ℂ ℂ ℂ)) (z, τ) from this.cexp\n  exact (hasFDerivAt_fst.const_mul _).add (hasFDerivAt_snd.const_mul _)\n\n"}
{"name":"norm_jacobiTheta₂_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz τ : Complex\n⊢ Eq (Norm.norm (jacobiTheta₂_term n z τ)) (Real.exp (HSub.hSub (HMul.hMul (HMul.hMul (Neg.neg Real.pi) (HPow.hPow (↑n) 2)) τ.im) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) ↑n) z.im)))","decl":"lemma norm_jacobiTheta₂_term (n : ℤ) (z τ : ℂ) :\n    ‖jacobiTheta₂_term n z τ‖ = rexp (-π * n ^ 2 * τ.im - 2 * π * n * z.im) := by\n  rw [jacobiTheta₂_term, Complex.norm_eq_abs, Complex.abs_exp, (by push_cast; ring :\n    (2 * π : ℂ) * I * n * z + π * I * n ^ 2 * τ = (π * (2 * n):) * z * I + (π * n ^ 2 :) * τ * I),\n    add_re, mul_I_re, im_ofReal_mul, mul_I_re, im_ofReal_mul]\n  ring_nf\n\n"}
{"name":"norm_jacobiTheta₂_term_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"S T : Real\nhT : LT.lt 0 T\nz τ : Complex\nhz : LE.le (abs z.im) S\nhτ : LE.le T τ.im\nn : Int\n⊢ LE.le (Norm.norm (jacobiTheta₂_term n z τ)) (Real.exp (HMul.hMul (Neg.neg Real.pi) (HSub.hSub (HMul.hMul T (HPow.hPow (↑n) 2)) (HMul.hMul (HMul.hMul 2 S) ↑(abs n)))))","decl":"/-- A uniform upper bound for `jacobiTheta₂_term` on compact subsets. -/\nlemma norm_jacobiTheta₂_term_le {S T : ℝ} (hT : 0 < T) {z τ : ℂ}\n    (hz : |im z| ≤ S) (hτ : T ≤ im τ) (n : ℤ) :\n    ‖jacobiTheta₂_term n z τ‖ ≤ rexp (-π * (T * n ^ 2 - 2 * S * |n|)) := by\n  simp_rw [norm_jacobiTheta₂_term, Real.exp_le_exp, sub_eq_add_neg, neg_mul, ← neg_add,\n    neg_le_neg_iff, mul_comm (2 : ℝ), mul_assoc π, ← mul_add, mul_le_mul_left pi_pos,\n    mul_comm T, mul_comm S]\n  refine add_le_add (mul_le_mul le_rfl hτ hT.le (sq_nonneg _)) ?_\n  rw [← mul_neg, mul_assoc, mul_assoc, mul_le_mul_left two_pos, mul_comm, neg_mul, ← mul_neg]\n  refine le_trans ?_ (neg_abs_le _)\n  rw [mul_neg, neg_le_neg_iff, abs_mul, Int.cast_abs]\n  exact mul_le_mul_of_nonneg_left hz (abs_nonneg _)\n\n"}
{"name":"norm_jacobiTheta₂'_term_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"S T : Real\nhT : LT.lt 0 T\nz τ : Complex\nhz : LE.le (abs z.im) S\nhτ : LE.le T τ.im\nn : Int\n⊢ LE.le (Norm.norm (jacobiTheta₂'_term n z τ)) (HMul.hMul (HMul.hMul (HMul.hMul 2 Real.pi) ↑(abs n)) (Real.exp (HMul.hMul (Neg.neg Real.pi) (HSub.hSub (HMul.hMul T (HPow.hPow (↑n) 2)) (HMul.hMul (HMul.hMul 2 S) ↑(abs n))))))","decl":"/-- A uniform upper bound for `jacobiTheta₂'_term` on compact subsets. -/\nlemma norm_jacobiTheta₂'_term_le {S T : ℝ} (hT : 0 < T) {z τ : ℂ}\n    (hz : |im z| ≤ S) (hτ : T ≤ im τ) (n : ℤ) :\n    ‖jacobiTheta₂'_term n z τ‖ ≤ 2 * π * |n| * rexp (-π * (T * n ^ 2 - 2 * S * |n|)) := by\n  rw [jacobiTheta₂'_term, norm_mul]\n  refine mul_le_mul (le_of_eq ?_) (norm_jacobiTheta₂_term_le hT hz hτ n)\n    (norm_nonneg _) (by positivity)\n  simp only [norm_mul, Complex.norm_eq_abs, Complex.abs_two, abs_I,\n    Complex.abs_of_nonneg pi_pos.le, abs_intCast, mul_one, Int.cast_abs]\n\n"}
{"name":"summable_pow_mul_jacobiTheta₂_term_bound","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"S T : Real\nhT : LT.lt 0 T\nk : Nat\n⊢ Summable fun n => HMul.hMul (HPow.hPow (↑(abs n)) k) (Real.exp (HMul.hMul (Neg.neg Real.pi) (HSub.hSub (HMul.hMul T (HPow.hPow (↑n) 2)) (HMul.hMul (HMul.hMul 2 S) ↑(abs n)))))","decl":"/-- The uniform bound we have given is summable, and remains so after multiplying by any fixed\npower of `|n|` (we shall need this for `k = 0, 1, 2`). -/\nlemma summable_pow_mul_jacobiTheta₂_term_bound (S : ℝ) {T : ℝ} (hT : 0 < T) (k : ℕ) :\n    Summable (fun n : ℤ ↦ (|n| ^ k : ℝ) * Real.exp (-π * (T * n ^ 2 - 2 * S * |n|))) := by\n  suffices Summable (fun n : ℕ ↦ (n ^ k : ℝ) * Real.exp (-π * (T * n ^ 2 - 2 * S * n))) by\n    apply Summable.of_nat_of_neg <;>\n    simpa only [Int.cast_neg, neg_sq, abs_neg, Int.cast_natCast, Nat.abs_cast]\n  apply summable_of_isBigO_nat (summable_pow_mul_exp_neg_nat_mul k zero_lt_one)\n  apply IsBigO.mul (isBigO_refl _ _)\n  refine Real.isBigO_exp_comp_exp_comp.mpr (Tendsto.isBoundedUnder_le_atBot ?_)\n  simp_rw [← tendsto_neg_atTop_iff, Pi.sub_apply]\n  conv =>\n    enter [1, n]\n    rw [show -(-π * (T * n ^ 2 - 2 * S * n) - -1 * n) = n * (π * T * n - (2 * π * S + 1)) by ring]\n  refine tendsto_natCast_atTop_atTop.atTop_mul_atTop (tendsto_atTop_add_const_right _ _ ?_)\n  exact tendsto_natCast_atTop_atTop.const_mul_atTop (mul_pos pi_pos hT)\n\n"}
{"name":"summable_jacobiTheta₂_term_iff","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Iff (Summable fun x => jacobiTheta₂_term x z τ) (LT.lt 0 τ.im)","decl":"/-- The series defining the theta function is summable if and only if `0 < im τ`. -/\nlemma summable_jacobiTheta₂_term_iff (z τ : ℂ) : Summable (jacobiTheta₂_term · z τ) ↔ 0 < im τ := by\n  -- NB. This is a statement of no great mathematical interest; it is included largely to avoid\n  -- having to impose `0 < im τ` as a hypothesis on many later lemmas.\n  refine Iff.symm ⟨fun hτ ↦ ?_, fun h ↦ ?_⟩ -- do quicker implication first!\n  · refine (summable_pow_mul_jacobiTheta₂_term_bound |im z| hτ 0).of_norm_bounded _ ?_\n    simpa only [pow_zero, one_mul] using norm_jacobiTheta₂_term_le hτ le_rfl le_rfl\n  · by_contra! hτ\n    rcases lt_or_eq_of_le hτ with hτ | hτ\n    · -- easy case `im τ < 0`\n      suffices Tendsto (fun n : ℕ ↦ ‖jacobiTheta₂_term ↑n z τ‖) atTop atTop by\n        replace h := (h.comp_injective (fun a b ↦ Int.ofNat_inj.mp)).tendsto_atTop_zero.norm\n        exact atTop_neBot.ne (disjoint_self.mp <| h.disjoint (disjoint_nhds_atTop _) this)\n      simp only [norm_zero, Function.comp_def, norm_jacobiTheta₂_term, Int.cast_natCast]\n      conv =>\n        enter [1, n]\n        rw [show -π * n ^ 2 * τ.im - 2 * π * n * z.im =\n              n * (n * (-π * τ.im) - 2 * π * z.im) by ring]\n      refine tendsto_exp_atTop.comp (tendsto_natCast_atTop_atTop.atTop_mul_atTop ?_)\n      exact tendsto_atTop_add_const_right _ _ (tendsto_natCast_atTop_atTop.atTop_mul_const\n        (mul_pos_of_neg_of_neg (neg_lt_zero.mpr pi_pos) hτ))\n    · -- case im τ = 0: 3-way split according to `im z`\n      simp_rw [← summable_norm_iff (E := ℂ), norm_jacobiTheta₂_term, hτ, mul_zero, zero_sub] at h\n      rcases lt_trichotomy (im z) 0 with hz | hz | hz\n      · replace h := (h.comp_injective (fun a b ↦ Int.ofNat_inj.mp)).tendsto_atTop_zero\n        simp_rw [Function.comp_def, Int.cast_natCast] at h\n        refine atTop_neBot.ne (disjoint_self.mp <| h.disjoint (disjoint_nhds_atTop 0) ?_)\n        refine tendsto_exp_atTop.comp ?_\n        simp only [tendsto_neg_atTop_iff, mul_assoc]\n        apply Filter.Tendsto.const_mul_atBot two_pos\n        exact (tendsto_natCast_atTop_atTop.atTop_mul_const_of_neg hz).const_mul_atBot pi_pos\n      · revert h\n        simpa only [hz, mul_zero, neg_zero, Real.exp_zero, summable_const_iff] using one_ne_zero\n      · have : ((-↑·) : ℕ → ℤ).Injective := fun _ _ ↦ by simp only [neg_inj, Nat.cast_inj, imp_self]\n        replace h := (h.comp_injective this).tendsto_atTop_zero\n        simp_rw [Function.comp_def, Int.cast_neg, Int.cast_natCast, mul_neg, neg_mul, neg_neg] at h\n        refine atTop_neBot.ne (disjoint_self.mp <| h.disjoint (disjoint_nhds_atTop 0) ?_)\n        exact tendsto_exp_atTop.comp ((tendsto_natCast_atTop_atTop.const_mul_atTop\n          (mul_pos two_pos pi_pos)).atTop_mul_const hz)\n\n"}
{"name":"norm_jacobiTheta₂_term_fderiv_le","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz τ : Complex\n⊢ LE.le (Norm.norm (jacobiTheta₂_term_fderiv n z τ)) (HMul.hMul (HMul.hMul (HMul.hMul 3 Real.pi) (HPow.hPow (↑(abs n)) 2)) (Norm.norm (jacobiTheta₂_term n z τ)))","decl":"lemma norm_jacobiTheta₂_term_fderiv_le (n : ℤ) (z τ : ℂ) :\n    ‖jacobiTheta₂_term_fderiv n z τ‖ ≤ 3 * π * |n| ^ 2 * ‖jacobiTheta₂_term n z τ‖ := by\n  -- this is slow to elaborate so do it once and reuse:\n  have hns (a : ℂ) (f : (ℂ × ℂ) →L[ℂ] ℂ) : ‖a • f‖ = ‖a‖ * ‖f‖ := norm_smul a f\n  rw [jacobiTheta₂_term_fderiv, jacobiTheta₂_term, hns,\n    mul_comm _ ‖cexp _‖, (by norm_num : (3 : ℝ) = 2 + 1), add_mul, add_mul]\n  refine mul_le_mul_of_nonneg_left ((norm_add_le _ _).trans (add_le_add ?_ ?_)) (norm_nonneg _)\n  · simp_rw [hns, norm_mul, ← ofReal_ofNat, ← ofReal_intCast,\n      norm_real, norm_of_nonneg zero_le_two, Real.norm_of_nonneg pi_pos.le, norm_I, mul_one,\n      Real.norm_eq_abs, Int.cast_abs, mul_assoc]\n    refine mul_le_mul_of_nonneg_left (mul_le_mul_of_nonneg_left ?_ pi_pos.le) two_pos.le\n    refine le_trans ?_ (?_ : |(n : ℝ)| ≤ |(n : ℝ)| ^ 2)\n    · exact mul_le_of_le_one_right (abs_nonneg _) (ContinuousLinearMap.norm_fst_le ..)\n    · exact_mod_cast Int.le_self_sq |n|\n  · simp_rw [hns, norm_mul, one_mul, norm_I, mul_one,\n      norm_real, norm_of_nonneg pi_pos.le, ← ofReal_intCast, ← ofReal_pow, norm_real,\n      Real.norm_eq_abs, Int.cast_abs, _root_.abs_pow]\n    apply mul_le_of_le_one_right (mul_nonneg pi_pos.le (pow_nonneg (abs_nonneg _) _))\n    exact ContinuousLinearMap.norm_snd_le ..\n\n"}
{"name":"norm_jacobiTheta₂_term_fderiv_ge","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"n : Int\nz τ : Complex\n⊢ LE.le (HMul.hMul (HMul.hMul Real.pi (HPow.hPow (↑(abs n)) 2)) (Norm.norm (jacobiTheta₂_term n z τ))) (Norm.norm (jacobiTheta₂_term_fderiv n z τ))","decl":"lemma norm_jacobiTheta₂_term_fderiv_ge (n : ℤ) (z τ : ℂ) :\n    π * |n| ^ 2 * ‖jacobiTheta₂_term n z τ‖ ≤ ‖jacobiTheta₂_term_fderiv n z τ‖ := by\n  have : ‖(jacobiTheta₂_term_fderiv n z τ) (0, 1)‖ ≤ ‖jacobiTheta₂_term_fderiv n z τ‖ := by\n    refine (ContinuousLinearMap.le_opNorm _ _).trans ?_\n    simp_rw [Prod.norm_def, norm_one, norm_zero, max_eq_right zero_le_one, mul_one, le_refl]\n  refine le_trans ?_ this\n  simp_rw [jacobiTheta₂_term_fderiv, jacobiTheta₂_term, ContinuousLinearMap.coe_smul',\n    Pi.smul_apply, ContinuousLinearMap.add_apply, ContinuousLinearMap.coe_smul',\n    ContinuousLinearMap.coe_fst', ContinuousLinearMap.coe_snd', Pi.smul_apply, smul_zero, zero_add,\n    smul_eq_mul, mul_one, mul_comm _ ‖cexp _‖, norm_mul]\n  refine mul_le_mul_of_nonneg_left (le_of_eq ?_) (norm_nonneg _)\n  simp_rw [norm_real, norm_of_nonneg pi_pos.le, norm_I, mul_one,\n    Int.cast_abs, ← abs_intCast, Complex.norm_eq_abs, Complex.abs_pow]\n\n"}
{"name":"summable_jacobiTheta₂_term_fderiv_iff","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Iff (Summable fun x => jacobiTheta₂_term_fderiv x z τ) (LT.lt 0 τ.im)","decl":"lemma summable_jacobiTheta₂_term_fderiv_iff (z τ : ℂ) :\n    Summable (jacobiTheta₂_term_fderiv · z τ) ↔ 0 < im τ := by\n  constructor\n  · rw [← summable_jacobiTheta₂_term_iff (z := z)]\n    intro h\n    have := h.norm\n    refine this.of_norm_bounded_eventually _ ?_\n    have : ∀ᶠ (n : ℤ) in cofinite, n ≠ 0 :=\n      Int.cofinite_eq ▸ (mem_sup.mpr ⟨eventually_ne_atBot 0, eventually_ne_atTop 0⟩)\n    filter_upwards [this] with n hn\n    refine le_trans ?_ (norm_jacobiTheta₂_term_fderiv_ge n z τ)\n    apply le_mul_of_one_le_left (norm_nonneg _)\n    refine one_le_pi_div_two.trans (mul_le_mul_of_nonneg_left ?_ pi_pos.le)\n    refine (by norm_num : 2⁻¹ ≤ (1 : ℝ)).trans ?_\n    rw [one_le_sq_iff_one_le_abs, ← Int.cast_abs, _root_.abs_abs, ← Int.cast_one, Int.cast_le]\n    exact Int.one_le_abs hn\n  · intro hτ\n    refine ((summable_pow_mul_jacobiTheta₂_term_bound\n      |z.im| hτ 2).mul_left (3 * π)).of_norm_bounded _ (fun n ↦ ?_)\n    refine (norm_jacobiTheta₂_term_fderiv_le n z τ).trans\n      (?_ : 3 * π * |n| ^ 2 * ‖jacobiTheta₂_term n z τ‖ ≤ _)\n    simp_rw [mul_assoc (3 * π)]\n    refine mul_le_mul_of_nonneg_left ?_ (mul_pos (by norm_num : 0 < (3 : ℝ)) pi_pos).le\n    refine mul_le_mul_of_nonneg_left ?_ (pow_nonneg (Int.cast_nonneg.mpr (abs_nonneg _)) _)\n    exact norm_jacobiTheta₂_term_le hτ le_rfl le_rfl n\n\n"}
{"name":"summable_jacobiTheta₂'_term_iff","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Iff (Summable fun x => jacobiTheta₂'_term x z τ) (LT.lt 0 τ.im)","decl":"lemma summable_jacobiTheta₂'_term_iff (z τ : ℂ) :\n    Summable (jacobiTheta₂'_term · z τ) ↔ 0 < im τ := by\n  constructor\n  · rw [← summable_jacobiTheta₂_term_iff (z := z)]\n    refine fun h ↦ (h.norm.mul_left (2 * π)⁻¹).of_norm_bounded_eventually _  ?_\n    have : ∀ᶠ (n : ℤ) in cofinite, n ≠ 0 :=\n      Int.cofinite_eq ▸ (mem_sup.mpr ⟨eventually_ne_atBot 0, eventually_ne_atTop 0⟩)\n    filter_upwards [this] with n hn\n    rw [jacobiTheta₂'_term, norm_mul, ← mul_assoc]\n    refine le_mul_of_one_le_left (norm_nonneg _) ?_\n    simp_rw [norm_mul, norm_I, norm_real, mul_one, norm_of_nonneg pi_pos.le,\n      ← ofReal_ofNat, norm_real, norm_of_nonneg two_pos.le, ← ofReal_intCast, norm_real,\n      Real.norm_eq_abs, ← Int.cast_abs, ← mul_assoc _ (2 * π),\n      inv_mul_cancel₀ (mul_pos two_pos pi_pos).ne', one_mul]\n    rw [← Int.cast_one, Int.cast_le]\n    exact Int.one_le_abs hn\n  · refine fun hτ ↦ ((summable_pow_mul_jacobiTheta₂_term_bound\n      |z.im| hτ 1).mul_left (2 * π)).of_norm_bounded _ (fun n ↦ ?_)\n    rw [jacobiTheta₂'_term, norm_mul, ← mul_assoc, pow_one]\n    refine mul_le_mul (le_of_eq ?_) (norm_jacobiTheta₂_term_le hτ le_rfl le_rfl n)\n      (norm_nonneg _) (by positivity)\n    simp_rw [norm_mul, Complex.norm_eq_abs, Complex.abs_two, abs_I,\n      Complex.abs_of_nonneg pi_pos.le, abs_intCast, mul_one, Int.cast_abs]\n\n"}
{"name":"hasSum_jacobiTheta₂_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ HasSum (fun n => jacobiTheta₂_term n z τ) (jacobiTheta₂ z τ)","decl":"lemma hasSum_jacobiTheta₂_term (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    HasSum (fun n ↦ jacobiTheta₂_term n z τ) (jacobiTheta₂ z τ) :=\n  ((summable_jacobiTheta₂_term_iff z τ).mpr hτ).hasSum\n\n"}
{"name":"hasSum_jacobiTheta₂_term_fderiv","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ HasSum (fun n => jacobiTheta₂_term_fderiv n z τ) (jacobiTheta₂_fderiv z τ)","decl":"lemma hasSum_jacobiTheta₂_term_fderiv (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    HasSum (fun n ↦ jacobiTheta₂_term_fderiv n z τ) (jacobiTheta₂_fderiv z τ) :=\n  ((summable_jacobiTheta₂_term_fderiv_iff z τ).mpr hτ).hasSum\n\n"}
{"name":"hasSum_jacobiTheta₂'_term","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ HasSum (fun n => jacobiTheta₂'_term n z τ) (jacobiTheta₂' z τ)","decl":"lemma hasSum_jacobiTheta₂'_term (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    HasSum (fun n ↦ jacobiTheta₂'_term n z τ) (jacobiTheta₂' z τ) :=\n  ((summable_jacobiTheta₂'_term_iff z τ).mpr hτ).hasSum\n\n"}
{"name":"jacobiTheta₂_undef","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LE.le τ.im 0\n⊢ Eq (jacobiTheta₂ z τ) 0","decl":"lemma jacobiTheta₂_undef (z : ℂ) {τ : ℂ} (hτ : im τ ≤ 0) : jacobiTheta₂ z τ = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiTheta₂_term_iff]\n  exact not_lt.mpr hτ\n\n"}
{"name":"jacobiTheta₂_fderiv_undef","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LE.le τ.im 0\n⊢ Eq (jacobiTheta₂_fderiv z τ) 0","decl":"lemma jacobiTheta₂_fderiv_undef (z : ℂ) {τ : ℂ} (hτ : im τ ≤ 0) : jacobiTheta₂_fderiv z τ = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiTheta₂_term_fderiv_iff]\n  exact not_lt.mpr hτ\n\n"}
{"name":"jacobiTheta₂'_undef","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LE.le τ.im 0\n⊢ Eq (jacobiTheta₂' z τ) 0","decl":"lemma jacobiTheta₂'_undef (z : ℂ) {τ : ℂ} (hτ : im τ ≤ 0) : jacobiTheta₂' z τ = 0 := by\n  apply tsum_eq_zero_of_not_summable\n  rw [summable_jacobiTheta₂'_term_iff]\n  exact not_lt.mpr hτ\n\n"}
{"name":"hasFDerivAt_jacobiTheta₂","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ HasFDerivAt (fun p => jacobiTheta₂ p.1 p.2) (jacobiTheta₂_fderiv z τ) { fst := z, snd := τ }","decl":"lemma hasFDerivAt_jacobiTheta₂ (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    HasFDerivAt (fun p : ℂ × ℂ ↦ jacobiTheta₂ p.1 p.2) (jacobiTheta₂_fderiv z τ) (z, τ) := by\n  obtain ⟨T, hT, hτ'⟩ := exists_between hτ\n  obtain ⟨S, hz⟩ := exists_gt |im z|\n  let V := {u | |im u| < S} ×ˢ {v | T < im v}\n  have hVo : IsOpen V := by\n    refine ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _ isOpen_Iio).prod ?_\n    exact continuous_im.isOpen_preimage _ isOpen_Ioi\n  have hVmem : (z, τ) ∈ V := ⟨hz, hτ'⟩\n  have hVp : IsPreconnected V := by\n    refine (Convex.isPreconnected ?_).prod (convex_halfSpace_im_gt T).isPreconnected\n    simpa only [abs_lt] using (convex_halfSpace_im_gt _).inter (convex_halfSpace_im_lt _)\n  let f : ℤ → ℂ × ℂ → ℂ := fun n p ↦ jacobiTheta₂_term n p.1 p.2\n  let f' : ℤ → ℂ × ℂ → ℂ × ℂ →L[ℂ] ℂ := fun n p ↦ jacobiTheta₂_term_fderiv n p.1 p.2\n  have hf (n : ℤ) : ∀ p ∈ V, HasFDerivAt (f n) (f' n p) p :=\n    fun p _ ↦ hasFDerivAt_jacobiTheta₂_term n p.1 p.2\n  let u : ℤ → ℝ := fun n ↦ 3 * π * |n| ^ 2 * Real.exp (-π * (T * n ^ 2 - 2 * S * |n|))\n  have hu : ∀ (n : ℤ), ∀ x ∈ V, ‖f' n x‖ ≤ u n := by\n    refine fun n p hp ↦ (norm_jacobiTheta₂_term_fderiv_le n p.1 p.2).trans ?_\n    refine mul_le_mul_of_nonneg_left ?_ (by positivity)\n    exact norm_jacobiTheta₂_term_le hT (le_of_lt hp.1) (le_of_lt hp.2) n\n  have hu_sum : Summable u := by\n    simp_rw [u, mul_assoc (3 * π)]\n    exact (summable_pow_mul_jacobiTheta₂_term_bound S hT 2).mul_left _\n  have hf_sum : Summable fun n : ℤ ↦ f n (z, τ) := by\n    refine (summable_pow_mul_jacobiTheta₂_term_bound S hT 0).of_norm_bounded _ ?_\n    simpa only [pow_zero, one_mul] using norm_jacobiTheta₂_term_le hT hz.le hτ'.le\n  simpa only [jacobiTheta₂, jacobiTheta₂_fderiv, f, f'] using\n    hasFDerivAt_tsum_of_isPreconnected hu_sum hVo hVp hf hu hVmem hf_sum hVmem\n\n"}
{"name":"continuousAt_jacobiTheta₂","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ ContinuousAt (fun p => jacobiTheta₂ p.1 p.2) { fst := z, snd := τ }","decl":"lemma continuousAt_jacobiTheta₂ (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    ContinuousAt (fun p : ℂ × ℂ ↦ jacobiTheta₂ p.1 p.2) (z, τ) :=\n  (hasFDerivAt_jacobiTheta₂ z hτ).continuousAt\n\n"}
{"name":"differentiableAt_jacobiTheta₂_fst","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ DifferentiableAt Complex (fun x => jacobiTheta₂ x τ) z","decl":"/-- Differentiability of `Θ z τ` in `z`, for fixed `τ`. -/\nlemma differentiableAt_jacobiTheta₂_fst (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    DifferentiableAt ℂ (jacobiTheta₂ · τ) z :=\n ((hasFDerivAt_jacobiTheta₂ z hτ).comp (𝕜 := ℂ) z (hasFDerivAt_prod_mk_left z τ) :).differentiableAt\n\n"}
{"name":"differentiableAt_jacobiTheta₂_snd","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ DifferentiableAt Complex (jacobiTheta₂ z) τ","decl":"/-- Differentiability of `Θ z τ` in `τ`, for fixed `z`. -/\nlemma differentiableAt_jacobiTheta₂_snd (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    DifferentiableAt ℂ (jacobiTheta₂ z) τ :=\n  ((hasFDerivAt_jacobiTheta₂ z hτ).comp τ (hasFDerivAt_prod_mk_right z τ)).differentiableAt\n\n"}
{"name":"hasDerivAt_jacobiTheta₂_fst","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ HasDerivAt (fun x => jacobiTheta₂ x τ) (jacobiTheta₂' z τ) z","decl":"lemma hasDerivAt_jacobiTheta₂_fst (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    HasDerivAt (jacobiTheta₂ · τ) (jacobiTheta₂' z τ) z := by\n  -- This proof is annoyingly fiddly, because of the need to commute \"evaluation at a point\"\n  -- through infinite sums of continuous linear maps.\n  let eval_fst_CLM : (ℂ × ℂ →L[ℂ] ℂ) →L[ℂ] ℂ :=\n  { toFun := fun f ↦ f (1, 0)\n    cont := continuous_id'.clm_apply continuous_const\n    map_add' := by simp only [ContinuousLinearMap.add_apply, forall_const]\n    map_smul' := by simp only [ContinuousLinearMap.coe_smul', Pi.smul_apply, smul_eq_mul,\n      RingHom.id_apply, forall_const] }\n  have step1 : HasSum (fun n ↦ (jacobiTheta₂_term_fderiv n z τ) (1, 0))\n      ((jacobiTheta₂_fderiv z τ) (1, 0)) := by\n    apply eval_fst_CLM.hasSum (hasSum_jacobiTheta₂_term_fderiv z hτ)\n  have step2 (n : ℤ) : (jacobiTheta₂_term_fderiv n z τ) (1, 0) = jacobiTheta₂'_term n z τ := by\n    simp only [jacobiTheta₂_term_fderiv, smul_add, ContinuousLinearMap.add_apply,\n      ContinuousLinearMap.coe_smul', ContinuousLinearMap.coe_fst', Pi.smul_apply, smul_eq_mul,\n      mul_one, ContinuousLinearMap.coe_snd', mul_zero, add_zero, jacobiTheta₂'_term,\n      jacobiTheta₂_term, mul_comm _ (cexp _)]\n  rw [funext step2] at step1\n  #adaptation_note /-- https://github.com/leanprover/lean4/pull/6024\n    need `by exact` to bypass unification failure -/\n  have step3 : HasDerivAt (fun x ↦ jacobiTheta₂ x τ) ((jacobiTheta₂_fderiv z τ) (1, 0)) z := by\n    exact ((hasFDerivAt_jacobiTheta₂ z hτ).comp z (hasFDerivAt_prod_mk_left z τ)).hasDerivAt\n  rwa [← step1.tsum_eq] at step3\n\n"}
{"name":"continuousAt_jacobiTheta₂'","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\nhτ : LT.lt 0 τ.im\n⊢ ContinuousAt (fun p => jacobiTheta₂' p.1 p.2) { fst := z, snd := τ }","decl":"lemma continuousAt_jacobiTheta₂' (z : ℂ) {τ : ℂ} (hτ : 0 < im τ) :\n    ContinuousAt (fun p : ℂ × ℂ ↦ jacobiTheta₂' p.1 p.2) (z, τ) := by\n  obtain ⟨T, hT, hτ'⟩ := exists_between hτ\n  obtain ⟨S, hz⟩ := exists_gt |im z|\n  let V := {u | |im u| < S} ×ˢ {v | T < im v}\n  have hVo : IsOpen V := ((_root_.continuous_abs.comp continuous_im).isOpen_preimage _\n    isOpen_Iio).prod (continuous_im.isOpen_preimage _ isOpen_Ioi)\n  refine ContinuousOn.continuousAt ?_ (hVo.mem_nhds ⟨hz, hτ'⟩)\n  let u (n : ℤ) : ℝ := 2 * π * |n| * rexp (-π * (T * n ^ 2 - 2 * S * |n|))\n  have hu : Summable u  := by simpa only [u, mul_assoc, pow_one]\n      using (summable_pow_mul_jacobiTheta₂_term_bound S hT 1).mul_left (2 * π)\n  refine continuousOn_tsum (fun n ↦ ?_) hu (fun n ⟨z', τ'⟩ ⟨hz', hτ'⟩ ↦ ?_)\n  · apply Continuous.continuousOn\n    unfold jacobiTheta₂'_term jacobiTheta₂_term\n    fun_prop\n  · exact norm_jacobiTheta₂'_term_le hT (le_of_lt hz') (le_of_lt hτ') n\n\n"}
{"name":"jacobiTheta₂_add_right","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂ z (HAdd.hAdd τ 2)) (jacobiTheta₂ z τ)","decl":"/-- The two-variable Jacobi theta function is periodic in `τ` with period 2. -/\nlemma jacobiTheta₂_add_right (z τ : ℂ) : jacobiTheta₂ z (τ + 2) = jacobiTheta₂ z τ := by\n  refine tsum_congr (fun n ↦ ?_)\n  simp_rw [jacobiTheta₂_term, Complex.exp_add]\n  suffices cexp (π * I * n ^ 2 * 2 : ℂ) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]\n  rw [(by push_cast; ring : (π * I * n ^ 2 * 2 : ℂ) = (n ^ 2 :) * (2 * π * I)), exp_int_mul,\n    exp_two_pi_mul_I, one_zpow]\n\n"}
{"name":"jacobiTheta₂_add_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂ (HAdd.hAdd z 1) τ) (jacobiTheta₂ z τ)","decl":"/-- The two-variable Jacobi theta function is periodic in `z` with period 1. -/\nlemma jacobiTheta₂_add_left (z τ : ℂ) : jacobiTheta₂ (z + 1) τ = jacobiTheta₂ z τ := by\n  refine tsum_congr (fun n ↦ ?_)\n  simp_rw [jacobiTheta₂_term, mul_add, Complex.exp_add, mul_one, mul_comm _ (n : ℂ),\n    exp_int_mul_two_pi_mul_I, mul_one]\n\n"}
{"name":"jacobiTheta₂_add_left'","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂ (HAdd.hAdd z τ) τ) (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg ↑Real.pi) Complex.I) (HAdd.hAdd τ (HMul.hMul 2 z)))) (jacobiTheta₂ z τ))","decl":"/-- The two-variable Jacobi theta function is quasi-periodic in `z` with period `τ`. -/\nlemma jacobiTheta₂_add_left' (z τ : ℂ) :\n    jacobiTheta₂ (z + τ) τ = cexp (-π * I * (τ + 2 * z)) * jacobiTheta₂ z τ := by\n  conv_rhs => erw [← tsum_mul_left, ← (Equiv.addRight 1).tsum_eq]\n  refine tsum_congr (fun n ↦ ?_)\n  simp_rw [jacobiTheta₂_term, ← Complex.exp_add, Equiv.coe_addRight, Int.cast_add]\n  ring_nf\n\n"}
{"name":"jacobiTheta₂_neg_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂ (Neg.neg z) τ) (jacobiTheta₂ z τ)","decl":"/-- The two-variable Jacobi theta function is even in `z`. -/\n@[simp]\nlemma jacobiTheta₂_neg_left (z τ : ℂ) : jacobiTheta₂ (-z) τ = jacobiTheta₂ z τ := by\n  conv_lhs => rw [jacobiTheta₂, ← Equiv.tsum_eq (Equiv.neg ℤ)]\n  refine tsum_congr (fun n ↦ ?_)\n  simp_rw [jacobiTheta₂_term, Equiv.neg_apply, Int.cast_neg, neg_sq, mul_assoc, neg_mul_neg]\n\n"}
{"name":"jacobiTheta₂_conj","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq ((starRingEnd Complex) (jacobiTheta₂ z τ)) (jacobiTheta₂ ((starRingEnd Complex) z) (Neg.neg ((starRingEnd Complex) τ)))","decl":"lemma jacobiTheta₂_conj (z τ : ℂ) :\n    conj (jacobiTheta₂ z τ) = jacobiTheta₂ (conj z) (-conj τ) := by\n  rw [← jacobiTheta₂_neg_left, jacobiTheta₂, conj_tsum]\n  congr 2 with n\n  simp only [jacobiTheta₂_term, mul_neg, ← exp_conj, map_add, map_neg, map_mul, map_ofNat,\n    conj_ofReal, conj_I, map_intCast, neg_mul, neg_neg, map_pow]\n\n"}
{"name":"jacobiTheta₂'_add_right","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂' z (HAdd.hAdd τ 2)) (jacobiTheta₂' z τ)","decl":"lemma jacobiTheta₂'_add_right (z τ : ℂ) : jacobiTheta₂' z (τ + 2) = jacobiTheta₂' z τ := by\n  refine tsum_congr (fun n ↦ ?_)\n  simp_rw [jacobiTheta₂'_term, jacobiTheta₂_term, Complex.exp_add]\n  suffices cexp (π * I * n ^ 2 * 2 : ℂ) = 1 by rw [mul_add, Complex.exp_add, this, mul_one]\n  rw [(by push_cast; ring : (π * I * n ^ 2 * 2 : ℂ) = (n ^ 2 :) * (2 * π * I)), exp_int_mul,\n    exp_two_pi_mul_I, one_zpow]\n\n"}
{"name":"jacobiTheta₂'_add_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂' (HAdd.hAdd z 1) τ) (jacobiTheta₂' z τ)","decl":"lemma jacobiTheta₂'_add_left (z τ : ℂ) : jacobiTheta₂' (z + 1) τ = jacobiTheta₂' z τ := by\n  unfold jacobiTheta₂' jacobiTheta₂'_term jacobiTheta₂_term\n  refine tsum_congr (fun n ↦ ?_)\n  simp only [mul_add, Complex.exp_add, mul_one, mul_comm _ (n : ℂ), exp_int_mul_two_pi_mul_I,\n    mul_one]\n\n"}
{"name":"jacobiTheta₂'_add_left'","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂' (HAdd.hAdd z τ) τ) (HMul.hMul (Complex.exp (HMul.hMul (HMul.hMul (Neg.neg ↑Real.pi) Complex.I) (HAdd.hAdd τ (HMul.hMul 2 z)))) (HSub.hSub (jacobiTheta₂' z τ) (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) (jacobiTheta₂ z τ))))","decl":"lemma jacobiTheta₂'_add_left' (z τ : ℂ) :\n    jacobiTheta₂' (z + τ) τ =\n      cexp (-π * I * (τ + 2 * z)) * (jacobiTheta₂' z τ - 2 * π * I * jacobiTheta₂ z τ) := by\n  rcases le_or_lt τ.im 0 with hτ | hτ\n  · simp_rw [jacobiTheta₂_undef _ hτ, jacobiTheta₂'_undef _ hτ, mul_zero, sub_zero, mul_zero]\n  have (n : ℤ) : jacobiTheta₂'_term n (z + τ) τ =\n      cexp (-π * I * (τ + 2 * z)) * (jacobiTheta₂'_term (n + 1) z τ -\n      2 * π * I * jacobiTheta₂_term (n + 1) z τ) := by\n    simp only [jacobiTheta₂'_term, jacobiTheta₂_term]\n    conv_rhs => rw [← sub_mul, mul_comm, mul_assoc, ← Complex.exp_add, Int.cast_add, Int.cast_one,\n      mul_add, mul_one, add_sub_cancel_right]\n    congr 2\n    ring\n  rw [jacobiTheta₂', funext this, tsum_mul_left, ← (Equiv.subRight (1 : ℤ)).tsum_eq]\n  simp only [jacobiTheta₂, jacobiTheta₂', Equiv.subRight_apply, sub_add_cancel,\n    tsum_sub (hasSum_jacobiTheta₂'_term z hτ).summable\n    ((hasSum_jacobiTheta₂_term z hτ).summable.mul_left _), tsum_mul_left]\n\n"}
{"name":"jacobiTheta₂'_neg_left","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂' (Neg.neg z) τ) (Neg.neg (jacobiTheta₂' z τ))","decl":"lemma jacobiTheta₂'_neg_left (z τ : ℂ) : jacobiTheta₂' (-z) τ = -jacobiTheta₂' z τ := by\n  rw [jacobiTheta₂', jacobiTheta₂', ← tsum_neg, ← (Equiv.neg ℤ).tsum_eq]\n  congr 1 with n\n  simp only [jacobiTheta₂'_term, jacobiTheta₂_term]\n  rw [Equiv.neg_apply, ← neg_mul]\n  push_cast\n  ring_nf\n\n"}
{"name":"jacobiTheta₂'_conj","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq ((starRingEnd Complex) (jacobiTheta₂' z τ)) (jacobiTheta₂' ((starRingEnd Complex) z) (Neg.neg ((starRingEnd Complex) τ)))","decl":"lemma jacobiTheta₂'_conj (z τ : ℂ) :\n    conj (jacobiTheta₂' z τ) = jacobiTheta₂' (conj z) (-conj τ) := by\n  rw [← neg_inj, ← jacobiTheta₂'_neg_left, jacobiTheta₂', jacobiTheta₂', conj_tsum, ← tsum_neg]\n  congr 1 with n\n  simp_rw [jacobiTheta₂'_term, jacobiTheta₂_term, map_mul, ← Complex.exp_conj, map_add, map_mul,\n    ← ofReal_intCast,← ofReal_ofNat, map_pow, conj_ofReal, conj_I]\n  ring_nf\n\n"}
{"name":"jacobiTheta₂_functional_equation","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂ z τ) (HMul.hMul (HMul.hMul (HDiv.hDiv 1 (HPow.hPow (HMul.hMul (Neg.neg Complex.I) τ) (1 / 2))) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg ↑Real.pi) Complex.I) (HPow.hPow z 2)) τ))) (jacobiTheta₂ (HDiv.hDiv z τ) (HDiv.hDiv (-1) τ)))","decl":"/-- The functional equation for the Jacobi theta function: `jacobiTheta₂ z τ` is an explicit factor\ntimes `jacobiTheta₂ (z / τ) (-1 / τ)`. This is the key lemma behind the proof of the functional\nequation for L-series of even Dirichlet characters. -/\ntheorem jacobiTheta₂_functional_equation (z τ : ℂ) : jacobiTheta₂ z τ =\n    1 / (-I * τ) ^ (1 / 2 : ℂ) * cexp (-π * I * z ^ 2 / τ) * jacobiTheta₂ (z / τ) (-1 / τ) := by\n  rcases le_or_lt (im τ) 0 with hτ | hτ\n  · have : (-1 / τ).im ≤ 0 := by\n      rw [neg_div, neg_im, one_div, inv_im, neg_nonpos]\n      exact div_nonneg (neg_nonneg.mpr hτ) (normSq_nonneg τ)\n    rw [jacobiTheta₂_undef z hτ, jacobiTheta₂_undef _ this, mul_zero]\n  unfold jacobiTheta₂ jacobiTheta₂_term\n  have h0 : τ ≠ 0 := by contrapose! hτ; rw [hτ, zero_im]\n  have h2 : 0 < (-I * τ).re := by\n    simpa only [neg_mul, neg_re, mul_re, I_re, zero_mul, I_im, one_mul, zero_sub, neg_neg] using hτ\n  calc\n  _ = ∑' n : ℤ, cexp (-π * (-I * τ) * ↑n ^ 2 + 2 * π * (I * z) * ↑n) :=\n    tsum_congr (fun n ↦ by ring_nf)\n  _ = 1 / (-I * τ) ^ (1 / 2 : ℂ) * ∑' (n : ℤ), cexp (-π / (-I * τ) * (n + I * (I * z)) ^ 2) := by\n    rw [tsum_exp_neg_quadratic h2]\n  _ = 1 / (-I * τ) ^ (1 / 2 : ℂ) * cexp (π * I * (-1 / τ) * z ^ 2) *\n      ∑' (n : ℤ), cexp (2 * π * I * n * (z / τ) + π * I * n ^ 2 * (-1 / τ)) := by\n    simp_rw [mul_assoc _ (cexp _), ← tsum_mul_left (a := cexp _), ← Complex.exp_add]\n    congr 2 with n : 1; congr 1\n    field_simp [I_ne_zero]\n    ring_nf\n    simp_rw [I_sq, I_pow_four]\n    ring_nf\n  _ = _ := by\n    congr 3\n    ring\n\n"}
{"name":"jacobiTheta₂'_functional_equation","module":"Mathlib.NumberTheory.ModularForms.JacobiTheta.TwoVariable","initialProofState":"z τ : Complex\n⊢ Eq (jacobiTheta₂' z τ) (HMul.hMul (HDiv.hDiv (HMul.hMul (HDiv.hDiv 1 (HPow.hPow (HMul.hMul (Neg.neg Complex.I) τ) (1 / 2))) (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg ↑Real.pi) Complex.I) (HPow.hPow z 2)) τ))) τ) (HSub.hSub (jacobiTheta₂' (HDiv.hDiv z τ) (HDiv.hDiv (-1) τ)) (HMul.hMul (HMul.hMul (HMul.hMul (HMul.hMul 2 ↑Real.pi) Complex.I) z) (jacobiTheta₂ (HDiv.hDiv z τ) (HDiv.hDiv (-1) τ)))))","decl":"/-- The functional equation for the derivative of the Jacobi theta function, relating\n`jacobiTheta₂' z τ` to `jacobiTheta₂' (z / τ) (-1 / τ)`. This is the key lemma behind the proof of\nthe functional equation for L-series of odd Dirichlet characters. -/\ntheorem jacobiTheta₂'_functional_equation (z τ : ℂ) :\n    jacobiTheta₂' z τ = 1 / (-I * τ) ^ (1 / 2 : ℂ) * cexp (-π * I * z ^ 2 / τ) / τ *\n      (jacobiTheta₂' (z / τ) (-1 / τ) - 2 * π * I * z * jacobiTheta₂ (z / τ) (-1 / τ)) := by\n  rcases le_or_lt (im τ) 0 with hτ | hτ\n  · rw [jacobiTheta₂'_undef z hτ, jacobiTheta₂'_undef, jacobiTheta₂_undef, mul_zero,\n      sub_zero, mul_zero] <;>\n    rw [neg_div, neg_im, one_div, inv_im, neg_nonpos] <;>\n    exact div_nonneg (neg_nonneg.mpr hτ) (normSq_nonneg τ)\n  have hτ' : 0 < (-1 / τ).im := by\n    rw [div_eq_mul_inv, neg_one_mul, neg_im, inv_im, neg_div, neg_neg]\n    exact div_pos hτ (normSq_pos.mpr (fun h ↦ lt_irrefl 0 (zero_im ▸ h ▸ hτ)))\n  have hj : HasDerivAt (fun w ↦ jacobiTheta₂ (w / τ) (-1 / τ))\n      ((1 / τ) * jacobiTheta₂' (z / τ) (-1 / τ)) z := by\n    have := hasDerivAt_jacobiTheta₂_fst (z / τ) hτ'\n    simpa only [mul_comm, one_div] using this.comp z (hasDerivAt_mul_const τ⁻¹)\n  calc\n  _ = deriv (jacobiTheta₂ · τ) z := (hasDerivAt_jacobiTheta₂_fst z hτ).deriv.symm\n  _ = deriv (fun z ↦ 1 / (-I * τ) ^ (1 / 2 : ℂ) *\n        cexp (-π * I * z ^ 2 / τ) * jacobiTheta₂ (z / τ) (-1 / τ)) z := by\n    rw [funext (jacobiTheta₂_functional_equation · τ)]\n  _ = 1 / (-I * τ) ^ (1 / 2 : ℂ) *\n        deriv (fun z ↦ cexp (-π * I * z ^ 2 / τ) * jacobiTheta₂ (z / τ) (-1 / τ)) z := by\n    simp_rw [mul_assoc, deriv_const_mul_field]\n  _ = 1 / (-I * τ) ^ (1 / 2 : ℂ) *\n        (deriv (fun z ↦ cexp (-π * I * z ^ 2 / τ)) z * jacobiTheta₂ (z / τ) (-1 / τ)\n         + cexp (-π * I * z ^ 2 / τ) * deriv (fun z ↦ jacobiTheta₂ (z / τ) (-1 / τ)) z) := by\n    rw [deriv_mul _ hj.differentiableAt]\n    exact (((differentiableAt_pow 2).const_mul _).mul_const _).cexp\n  _ = _ := by\n    rw [hj.deriv]\n    erw [deriv_cexp (((differentiableAt_pow _).const_mul _).mul_const _)]\n    rw [mul_comm, deriv_mul_const_field, deriv_const_mul_field, deriv_pow]\n    ring_nf\n"}
