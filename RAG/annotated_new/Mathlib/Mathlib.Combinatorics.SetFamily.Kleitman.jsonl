{"name":"Finset.card_biUnion_le_of_intersecting","module":"Mathlib.Combinatorics.SetFamily.Kleitman","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝² : Fintype α\ninst✝¹ : DecidableEq α\ninst✝ : Nonempty α\ns : Finset ι\nf : ι → Finset (Finset α)\nhf : ∀ (i : ι), Membership.mem s i → (↑(f i)).Intersecting\n⊢ LE.le (s.biUnion f).card (HSub.hSub (HPow.hPow 2 (Fintype.card α)) (HPow.hPow 2 (HSub.hSub (Fintype.card α) s.card)))","decl":"/-- **Kleitman's theorem**. An intersecting family on `n` elements contains at most `2ⁿ⁻¹` sets, and\neach further intersecting family takes at most half of the sets that are in no previous family. -/\ntheorem Finset.card_biUnion_le_of_intersecting (s : Finset ι) (f : ι → Finset (Finset α))\n    (hf : ∀ i ∈ s, (f i : Set (Finset α)).Intersecting) :\n    #(s.biUnion f) ≤ 2 ^ Fintype.card α - 2 ^ (Fintype.card α - #s) := by\n  have : DecidableEq ι := by\n    classical\n    infer_instance\n  obtain hs | hs := le_total (Fintype.card α) #s\n  · rw [tsub_eq_zero_of_le hs, pow_zero]\n    refine (card_le_card <| biUnion_subset.2 fun i hi a ha ↦\n      mem_compl.2 <| not_mem_singleton.2 <| (hf _ hi).ne_bot ha).trans_eq ?_\n    rw [card_compl, Fintype.card_finset, card_singleton]\n  induction' s using Finset.cons_induction with i s hi ih generalizing f\n  · simp\n  set f' : ι → Finset (Finset α) :=\n    fun j ↦ if hj : j ∈ cons i s hi then (hf j hj).exists_card_eq.choose else ∅\n  have hf₁ : ∀ j, j ∈ cons i s hi → f j ⊆ f' j ∧ 2 * #(f' j) =\n      2 ^ Fintype.card α ∧ (f' j : Set (Finset α)).Intersecting := by\n    rintro j hj\n    simp_rw [f', dif_pos hj, ← Fintype.card_finset]\n    exact Classical.choose_spec (hf j hj).exists_card_eq\n  have hf₂ : ∀ j, j ∈ cons i s hi → IsUpperSet (f' j : Set (Finset α)) := by\n    refine fun j hj ↦ (hf₁ _ hj).2.2.isUpperSet' ((hf₁ _ hj).2.2.is_max_iff_card_eq.2 ?_)\n    rw [Fintype.card_finset]\n    exact (hf₁ _ hj).2.1\n  refine (card_le_card <| biUnion_mono fun j hj ↦ (hf₁ _ hj).1).trans ?_\n  nth_rw 1 [cons_eq_insert i]\n  rw [biUnion_insert]\n  refine (card_mono <| @le_sup_sdiff _ _ _ <| f' i).trans ((card_union_le _ _).trans ?_)\n  rw [union_sdiff_left, sdiff_eq_inter_compl]\n  refine le_of_mul_le_mul_left ?_ (pow_pos (zero_lt_two' ℕ) <| Fintype.card α + 1)\n  rw [pow_succ, mul_add, mul_assoc, mul_comm _ 2, mul_assoc]\n  refine (add_le_add\n      ((mul_le_mul_left <| pow_pos (zero_lt_two' ℕ) _).2\n      (hf₁ _ <| mem_cons_self _ _).2.2.card_le) <|\n      (mul_le_mul_left <| zero_lt_two' ℕ).2 <| IsUpperSet.card_inter_le_finset ?_ ?_).trans ?_\n  · rw [coe_biUnion]\n    exact isUpperSet_iUnion₂ fun i hi ↦ hf₂ _ <| subset_cons _ hi\n  · rw [coe_compl]\n    exact (hf₂ _ <| mem_cons_self _ _).compl\n  rw [mul_tsub, card_compl, Fintype.card_finset, mul_left_comm, mul_tsub,\n    (hf₁ _ <| mem_cons_self _ _).2.1, two_mul, add_tsub_cancel_left, ← mul_tsub, ← mul_two,\n    mul_assoc, ← add_mul, mul_comm]\n  refine mul_le_mul_left' ?_ _\n  refine (add_le_add_left\n    (ih _ (fun i hi ↦ (hf₁ _ <| subset_cons _ hi).2.2)\n    ((card_le_card <| subset_cons _).trans hs)) _).trans ?_\n  rw [mul_tsub, two_mul, ← pow_succ',\n    ← add_tsub_assoc_of_le (pow_right_mono₀ (one_le_two : (1 : ℕ) ≤ 2) tsub_le_self),\n    tsub_add_eq_add_tsub hs, card_cons, add_tsub_add_eq_tsub_right]\n"}
