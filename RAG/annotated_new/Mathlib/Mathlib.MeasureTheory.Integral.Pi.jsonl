{"name":"MeasureTheory.Integrable.fin_nat_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Nat\nE : Fin n → Type u_2\ninst✝¹ : (i : Fin n) → MeasureTheory.MeasureSpace (E i)\ninst✝ : ∀ (i : Fin n), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nf : (i : Fin n) → E i → 𝕜\nhf : ∀ (i : Fin n), MeasureTheory.Integrable (f i) MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.Integrable (fun x => Finset.univ.prod fun i => f i (x i)) MeasureTheory.MeasureSpace.volume","decl":"/-- On a finite product space in `n` variables, for a natural number `n`, a product of integrable\nfunctions depending on each coordinate is integrable. -/\ntheorem Integrable.fin_nat_prod {n : ℕ} {E : Fin n → Type*}\n    [∀ i, MeasureSpace (E i)] [∀ i, SigmaFinite (volume : Measure (E i))]\n    {f : (i : Fin n) → E i → 𝕜} (hf : ∀ i, Integrable (f i)) :\n    Integrable (fun (x : (i : Fin n) → E i) ↦ ∏ i, f i (x i)) := by\n  induction n with\n  | zero => simp only [Finset.univ_eq_empty, Finset.prod_empty, volume_pi, isFiniteMeasure_iff,\n      integrable_const_iff, one_ne_zero, pi_empty_univ, ENNReal.one_lt_top, or_true]\n  | succ n n_ih =>\n      have := ((measurePreserving_piFinSuccAbove (fun i => (volume : Measure (E i))) 0).symm)\n      rw [volume_pi, ← this.integrable_comp_emb (MeasurableEquiv.measurableEmbedding _)]\n      simp_rw [MeasurableEquiv.piFinSuccAbove_symm_apply, Fin.insertNthEquiv,\n        Fin.prod_univ_succ, Fin.insertNth_zero]\n      simp only [Fin.zero_succAbove, cast_eq, Function.comp_def, Fin.cons_zero, Fin.cons_succ]\n      have : Integrable (fun (x : (j : Fin n) → E (Fin.succ j)) ↦ ∏ j, f (Fin.succ j) (x j)) :=\n        n_ih (fun i ↦ hf _)\n      exact Integrable.prod_mul (hf 0) this\n\n"}
{"name":"MeasureTheory.Integrable.fintype_prod_dep","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nι : Type u_2\ninst✝² : Fintype ι\nE : ι → Type u_3\nf : (i : ι) → E i → 𝕜\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (E i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nhf : ∀ (i : ι), MeasureTheory.Integrable (f i) MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.Integrable (fun x => Finset.univ.prod fun i => f i (x i)) MeasureTheory.MeasureSpace.volume","decl":"/-- On a finite product space, a product of integrable functions depending on each coordinate is\nintegrable. Version with dependent target. -/\ntheorem Integrable.fintype_prod_dep {ι : Type*} [Fintype ι] {E : ι → Type*}\n    {f : (i : ι) → E i → 𝕜} [∀ i, MeasureSpace (E i)] [∀ i, SigmaFinite (volume : Measure (E i))]\n    (hf : ∀ i, Integrable (f i)) :\n    Integrable (fun (x : (i : ι) → E i) ↦ ∏ i, f i (x i)) := by\n  let e := (equivFin ι).symm\n  simp_rw [← (volume_measurePreserving_piCongrLeft _ e).integrable_comp_emb\n    (MeasurableEquiv.measurableEmbedding _),\n    ← e.prod_comp, MeasurableEquiv.coe_piCongrLeft, Function.comp_def,\n    Equiv.piCongrLeft_apply_apply]\n  exact .fin_nat_prod (fun i ↦ hf _)\n\n"}
{"name":"MeasureTheory.Integrable.fintype_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nι : Type u_2\ninst✝² : Fintype ι\nE : Type u_3\nf : ι → E → 𝕜\ninst✝¹ : MeasureTheory.MeasureSpace E\ninst✝ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nhf : ∀ (i : ι), MeasureTheory.Integrable (f i) MeasureTheory.MeasureSpace.volume\n⊢ MeasureTheory.Integrable (fun x => Finset.univ.prod fun i => f i (x i)) MeasureTheory.MeasureSpace.volume","decl":"/-- On a finite product space, a product of integrable functions depending on each coordinate is\nintegrable. -/\ntheorem Integrable.fintype_prod {ι : Type*} [Fintype ι] {E : Type*}\n    {f : ι → E → 𝕜} [MeasureSpace E] [SigmaFinite (volume : Measure E)]\n    (hf : ∀ i, Integrable (f i)) :\n    Integrable (fun (x : ι → E) ↦ ∏ i, f i (x i)) :=\n  Integrable.fintype_prod_dep hf\n\n"}
{"name":"MeasureTheory.integral_fin_nat_prod_eq_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"𝕜 : Type u_1\ninst✝² : RCLike 𝕜\nn : Nat\nE : Fin n → Type u_2\ninst✝¹ : (i : Fin n) → MeasureTheory.MeasureSpace (E i)\ninst✝ : ∀ (i : Fin n), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nf : (i : Fin n) → E i → 𝕜\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Finset.univ.prod fun i => f i (x i)) (Finset.univ.prod fun i => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f i x)","decl":"/-- A version of **Fubini's theorem** in `n` variables, for a natural number `n`. -/\ntheorem integral_fin_nat_prod_eq_prod {n : ℕ} {E : Fin n → Type*}\n    [∀ i, MeasureSpace (E i)] [∀ i, SigmaFinite (volume : Measure (E i))]\n    (f : (i : Fin n) → E i → 𝕜) :\n    ∫ x : (i : Fin n) → E i, ∏ i, f i (x i) = ∏ i, ∫ x, f i x := by\n  induction n with\n  | zero =>\n      simp only [volume_pi, Finset.univ_eq_empty, Finset.prod_empty, integral_const,\n        pi_empty_univ, ENNReal.one_toReal, smul_eq_mul, mul_one, pow_zero, one_smul]\n  | succ n n_ih =>\n      calc\n        _ = ∫ x : E 0 × ((i : Fin n) → E (Fin.succ i)),\n            f 0 x.1 * ∏ i : Fin n, f (Fin.succ i) (x.2 i) := by\n          rw [volume_pi, ← ((measurePreserving_piFinSuccAbove\n            (fun i => (volume : Measure (E i))) 0).symm).integral_comp']\n          simp_rw [MeasurableEquiv.piFinSuccAbove_symm_apply, Fin.insertNthEquiv,\n            Fin.prod_univ_succ, Fin.insertNth_zero, Equiv.coe_fn_mk, Fin.cons_succ, volume_eq_prod,\n            volume_pi, Fin.zero_succAbove, cast_eq, Fin.cons_zero]\n        _ = (∫ x, f 0 x) * ∏ i : Fin n, ∫ (x : E (Fin.succ i)), f (Fin.succ i) x := by\n          rw [← n_ih, ← integral_prod_mul, volume_eq_prod]\n        _ = ∏ i, ∫ x, f i x := by rw [Fin.prod_univ_succ]\n\n"}
{"name":"MeasureTheory.integral_fintype_prod_eq_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nι : Type u_2\ninst✝² : Fintype ι\nE : ι → Type u_3\nf : (i : ι) → E i → 𝕜\ninst✝¹ : (i : ι) → MeasureTheory.MeasureSpace (E i)\ninst✝ : ∀ (i : ι), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Finset.univ.prod fun i => f i (x i)) (Finset.univ.prod fun i => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f i x)","decl":"/-- A version of **Fubini's theorem** with the variables indexed by a general finite type. -/\ntheorem integral_fintype_prod_eq_prod (ι : Type*) [Fintype ι] {E : ι → Type*}\n    (f : (i : ι) → E i → 𝕜) [∀ i, MeasureSpace (E i)] [∀ i, SigmaFinite (volume : Measure (E i))] :\n    ∫ x : (i : ι) → E i, ∏ i, f i (x i) = ∏ i, ∫ x, f i x := by\n  let e := (equivFin ι).symm\n  rw [← (volume_measurePreserving_piCongrLeft _ e).integral_comp']\n  simp_rw [← e.prod_comp, MeasurableEquiv.coe_piCongrLeft, Equiv.piCongrLeft_apply_apply,\n    MeasureTheory.integral_fin_nat_prod_eq_prod]\n\n"}
{"name":"MeasureTheory.integral_fintype_prod_eq_pow","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"𝕜 : Type u_1\ninst✝³ : RCLike 𝕜\nE : Type u_2\nι : Type u_3\ninst✝² : Fintype ι\nf : E → 𝕜\ninst✝¹ : MeasureTheory.MeasureSpace E\ninst✝ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Finset.univ.prod fun i => f (x i)) (HPow.hPow (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f x) (Fintype.card ι))","decl":"theorem integral_fintype_prod_eq_pow {E : Type*} (ι : Type*) [Fintype ι] (f : E → 𝕜)\n    [MeasureSpace E] [SigmaFinite (volume : Measure E)] :\n    ∫ x : ι → E, ∏ i, f (x i) = (∫ x, f x) ^ (card ι) := by\n  rw [integral_fintype_prod_eq_prod, Finset.prod_const, card]\n\n"}
