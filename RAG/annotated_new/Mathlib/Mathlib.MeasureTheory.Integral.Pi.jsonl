{"name":"MeasureTheory.Integrable.fin_nat_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nn : Nat\nE : Fin n â†’ Type u_2\ninstâœÂ¹ : (i : Fin n) â†’ MeasureTheory.MeasureSpace (E i)\ninstâœ : âˆ€ (i : Fin n), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nf : (i : Fin n) â†’ E i â†’ ğ•œ\nhf : âˆ€ (i : Fin n), MeasureTheory.Integrable (f i) MeasureTheory.MeasureSpace.volume\nâŠ¢ MeasureTheory.Integrable (fun x => Finset.univ.prod fun i => f i (x i)) MeasureTheory.MeasureSpace.volume","decl":"/-- On a finite product space in `n` variables, for a natural number `n`, a product of integrable\nfunctions depending on each coordinate is integrable. -/\ntheorem Integrable.fin_nat_prod {n : â„•} {E : Fin n â†’ Type*}\n    [âˆ€ i, MeasureSpace (E i)] [âˆ€ i, SigmaFinite (volume : Measure (E i))]\n    {f : (i : Fin n) â†’ E i â†’ ğ•œ} (hf : âˆ€ i, Integrable (f i)) :\n    Integrable (fun (x : (i : Fin n) â†’ E i) â†¦ âˆ i, f i (x i)) := by\n  induction n with\n  | zero => simp only [Finset.univ_eq_empty, Finset.prod_empty, volume_pi, isFiniteMeasure_iff,\n      integrable_const_iff, one_ne_zero, pi_empty_univ, ENNReal.one_lt_top, or_true]\n  | succ n n_ih =>\n      have := ((measurePreserving_piFinSuccAbove (fun i => (volume : Measure (E i))) 0).symm)\n      rw [volume_pi, â† this.integrable_comp_emb (MeasurableEquiv.measurableEmbedding _)]\n      simp_rw [MeasurableEquiv.piFinSuccAbove_symm_apply, Fin.insertNthEquiv,\n        Fin.prod_univ_succ, Fin.insertNth_zero]\n      simp only [Fin.zero_succAbove, cast_eq, Function.comp_def, Fin.cons_zero, Fin.cons_succ]\n      have : Integrable (fun (x : (j : Fin n) â†’ E (Fin.succ j)) â†¦ âˆ j, f (Fin.succ j) (x j)) :=\n        n_ih (fun i â†¦ hf _)\n      exact Integrable.prod_mul (hf 0) this\n\n"}
{"name":"MeasureTheory.Integrable.fintype_prod_dep","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : Fintype Î¹\nE : Î¹ â†’ Type u_3\nf : (i : Î¹) â†’ E i â†’ ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ MeasureTheory.MeasureSpace (E i)\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nhf : âˆ€ (i : Î¹), MeasureTheory.Integrable (f i) MeasureTheory.MeasureSpace.volume\nâŠ¢ MeasureTheory.Integrable (fun x => Finset.univ.prod fun i => f i (x i)) MeasureTheory.MeasureSpace.volume","decl":"/-- On a finite product space, a product of integrable functions depending on each coordinate is\nintegrable. Version with dependent target. -/\ntheorem Integrable.fintype_prod_dep {Î¹ : Type*} [Fintype Î¹] {E : Î¹ â†’ Type*}\n    {f : (i : Î¹) â†’ E i â†’ ğ•œ} [âˆ€ i, MeasureSpace (E i)] [âˆ€ i, SigmaFinite (volume : Measure (E i))]\n    (hf : âˆ€ i, Integrable (f i)) :\n    Integrable (fun (x : (i : Î¹) â†’ E i) â†¦ âˆ i, f i (x i)) := by\n  let e := (equivFin Î¹).symm\n  simp_rw [â† (volume_measurePreserving_piCongrLeft _ e).integrable_comp_emb\n    (MeasurableEquiv.measurableEmbedding _),\n    â† e.prod_comp, MeasurableEquiv.coe_piCongrLeft, Function.comp_def,\n    Equiv.piCongrLeft_apply_apply]\n  exact .fin_nat_prod (fun i â†¦ hf _)\n\n"}
{"name":"MeasureTheory.Integrable.fintype_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : Fintype Î¹\nE : Type u_3\nf : Î¹ â†’ E â†’ ğ•œ\ninstâœÂ¹ : MeasureTheory.MeasureSpace E\ninstâœ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nhf : âˆ€ (i : Î¹), MeasureTheory.Integrable (f i) MeasureTheory.MeasureSpace.volume\nâŠ¢ MeasureTheory.Integrable (fun x => Finset.univ.prod fun i => f i (x i)) MeasureTheory.MeasureSpace.volume","decl":"/-- On a finite product space, a product of integrable functions depending on each coordinate is\nintegrable. -/\ntheorem Integrable.fintype_prod {Î¹ : Type*} [Fintype Î¹] {E : Type*}\n    {f : Î¹ â†’ E â†’ ğ•œ} [MeasureSpace E] [SigmaFinite (volume : Measure E)]\n    (hf : âˆ€ i, Integrable (f i)) :\n    Integrable (fun (x : Î¹ â†’ E) â†¦ âˆ i, f i (x i)) :=\n  Integrable.fintype_prod_dep hf\n\n"}
{"name":"MeasureTheory.integral_fin_nat_prod_eq_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : RCLike ğ•œ\nn : Nat\nE : Fin n â†’ Type u_2\ninstâœÂ¹ : (i : Fin n) â†’ MeasureTheory.MeasureSpace (E i)\ninstâœ : âˆ€ (i : Fin n), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nf : (i : Fin n) â†’ E i â†’ ğ•œ\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Finset.univ.prod fun i => f i (x i)) (Finset.univ.prod fun i => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f i x)","decl":"/-- A version of **Fubini's theorem** in `n` variables, for a natural number `n`. -/\ntheorem integral_fin_nat_prod_eq_prod {n : â„•} {E : Fin n â†’ Type*}\n    [âˆ€ i, MeasureSpace (E i)] [âˆ€ i, SigmaFinite (volume : Measure (E i))]\n    (f : (i : Fin n) â†’ E i â†’ ğ•œ) :\n    âˆ« x : (i : Fin n) â†’ E i, âˆ i, f i (x i) = âˆ i, âˆ« x, f i x := by\n  induction n with\n  | zero =>\n      simp only [volume_pi, Finset.univ_eq_empty, Finset.prod_empty, integral_const,\n        pi_empty_univ, ENNReal.one_toReal, smul_eq_mul, mul_one, pow_zero, one_smul]\n  | succ n n_ih =>\n      calc\n        _ = âˆ« x : E 0 Ã— ((i : Fin n) â†’ E (Fin.succ i)),\n            f 0 x.1 * âˆ i : Fin n, f (Fin.succ i) (x.2 i) := by\n          rw [volume_pi, â† ((measurePreserving_piFinSuccAbove\n            (fun i => (volume : Measure (E i))) 0).symm).integral_comp']\n          simp_rw [MeasurableEquiv.piFinSuccAbove_symm_apply, Fin.insertNthEquiv,\n            Fin.prod_univ_succ, Fin.insertNth_zero, Equiv.coe_fn_mk, Fin.cons_succ, volume_eq_prod,\n            volume_pi, Fin.zero_succAbove, cast_eq, Fin.cons_zero]\n        _ = (âˆ« x, f 0 x) * âˆ i : Fin n, âˆ« (x : E (Fin.succ i)), f (Fin.succ i) x := by\n          rw [â† n_ih, â† integral_prod_mul, volume_eq_prod]\n        _ = âˆ i, âˆ« x, f i x := by rw [Fin.prod_univ_succ]\n\n"}
{"name":"MeasureTheory.integral_fintype_prod_eq_prod","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nÎ¹ : Type u_2\ninstâœÂ² : Fintype Î¹\nE : Î¹ â†’ Type u_3\nf : (i : Î¹) â†’ E i â†’ ğ•œ\ninstâœÂ¹ : (i : Î¹) â†’ MeasureTheory.MeasureSpace (E i)\ninstâœ : âˆ€ (i : Î¹), MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Finset.univ.prod fun i => f i (x i)) (Finset.univ.prod fun i => MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f i x)","decl":"/-- A version of **Fubini's theorem** with the variables indexed by a general finite type. -/\ntheorem integral_fintype_prod_eq_prod (Î¹ : Type*) [Fintype Î¹] {E : Î¹ â†’ Type*}\n    (f : (i : Î¹) â†’ E i â†’ ğ•œ) [âˆ€ i, MeasureSpace (E i)] [âˆ€ i, SigmaFinite (volume : Measure (E i))] :\n    âˆ« x : (i : Î¹) â†’ E i, âˆ i, f i (x i) = âˆ i, âˆ« x, f i x := by\n  let e := (equivFin Î¹).symm\n  rw [â† (volume_measurePreserving_piCongrLeft _ e).integral_comp']\n  simp_rw [â† e.prod_comp, MeasurableEquiv.coe_piCongrLeft, Equiv.piCongrLeft_apply_apply,\n    MeasureTheory.integral_fin_nat_prod_eq_prod]\n\n"}
{"name":"MeasureTheory.integral_fintype_prod_eq_pow","module":"Mathlib.MeasureTheory.Integral.Pi","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : RCLike ğ•œ\nE : Type u_2\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nf : E â†’ ğ•œ\ninstâœÂ¹ : MeasureTheory.MeasureSpace E\ninstâœ : MeasureTheory.SigmaFinite MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => Finset.univ.prod fun i => f (x i)) (HPow.hPow (MeasureTheory.integral MeasureTheory.MeasureSpace.volume fun x => f x) (Fintype.card Î¹))","decl":"theorem integral_fintype_prod_eq_pow {E : Type*} (Î¹ : Type*) [Fintype Î¹] (f : E â†’ ğ•œ)\n    [MeasureSpace E] [SigmaFinite (volume : Measure E)] :\n    âˆ« x : Î¹ â†’ E, âˆ i, f (x i) = (âˆ« x, f x) ^ (card Î¹) := by\n  rw [integral_fintype_prod_eq_prod, Finset.prod_const, card]\n\n"}
