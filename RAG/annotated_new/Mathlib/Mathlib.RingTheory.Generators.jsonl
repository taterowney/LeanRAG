{"name":"Algebra.Generators.mk.injEq","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nvars✝ : Type w\nval✝ : vars✝ → S\nσ'✝ : S → MvPolynomial vars✝ R\naeval_val_σ'✝ : ∀ (s : S), Eq ((MvPolynomial.aeval val✝) (σ'✝ s)) s\nalgebra✝ : Algebra (MvPolynomial vars✝ R) S\nalgebraMap_eq✝ : autoParam (Eq (algebraMap (MvPolynomial vars✝ R) S) ↑(MvPolynomial.aeval val✝)) _auto✝\nvars : Type w\nval : vars → S\nσ' : S → MvPolynomial vars R\naeval_val_σ' : ∀ (s : S), Eq ((MvPolynomial.aeval val) (σ' s)) s\nalgebra : Algebra (MvPolynomial vars R) S\nalgebraMap_eq : autoParam (Eq (algebraMap (MvPolynomial vars R) S) ↑(MvPolynomial.aeval val)) _auto✝\n⊢ Eq (Eq { vars := vars✝, val := val✝, σ' := σ'✝, aeval_val_σ' := aeval_val_σ'✝, algebra := algebra✝, algebraMap_eq := algebraMap_eq✝ } { vars := vars, val := val, σ' := σ', aeval_val_σ' := aeval_val_σ', algebra := algebra, algebraMap_eq := algebraMap_eq }) (And (Eq vars✝ vars) (And (HEq val✝ val) (And (HEq σ'✝ σ') (HEq algebra✝ algebra))))","decl":"/-- A family of generators of a `R`-algebra `S` consists of\n1. `vars`: The type of variables.\n2. `val : vars → S`: The assignment of each variable to a value in `S`.\n3. `σ`: A section of `R[X] → S`. -/\nstructure Algebra.Generators where\n  /-- The type of variables. -/\n  vars : Type w\n  /-- The assignment of each variable to a value in `S`. -/\n  val : vars → S\n  /-- A section of `R[X] → S`. -/\n  σ' : S → MvPolynomial vars R\n  aeval_val_σ' : ∀ s, aeval val (σ' s) = s\n  /-- An `R[X]`-algebra instance on `S`. The default is the one induced by the map `R[X] → S`,\n  but this causes a diamond if there is an existing instance. -/\n  algebra : Algebra (MvPolynomial vars R) S := (aeval val).toAlgebra\n  algebraMap_eq :\n    algebraMap (MvPolynomial vars R) S = aeval (R := R) val := by rfl\n\n"}
{"name":"Algebra.Generators.mk.sizeOf_spec","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\nvars : Type w\nval : vars → S\nσ' : S → MvPolynomial vars R\naeval_val_σ' : ∀ (s : S), Eq ((MvPolynomial.aeval val) (σ' s)) s\nalgebra : Algebra (MvPolynomial vars R) S\nalgebraMap_eq : autoParam (Eq (algebraMap (MvPolynomial vars R) S) ↑(MvPolynomial.aeval val)) _auto✝\n⊢ Eq (SizeOf.sizeOf { vars := vars, val := val, σ' := σ', aeval_val_σ' := aeval_val_σ', algebra := algebra, algebraMap_eq := algebraMap_eq }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf vars)) (SizeOf.sizeOf algebra)) (SizeOf.sizeOf algebraMap_eq))","decl":"/-- A family of generators of a `R`-algebra `S` consists of\n1. `vars`: The type of variables.\n2. `val : vars → S`: The assignment of each variable to a value in `S`.\n3. `σ`: A section of `R[X] → S`. -/\nstructure Algebra.Generators where\n  /-- The type of variables. -/\n  vars : Type w\n  /-- The assignment of each variable to a value in `S`. -/\n  val : vars → S\n  /-- A section of `R[X] → S`. -/\n  σ' : S → MvPolynomial vars R\n  aeval_val_σ' : ∀ s, aeval val (σ' s) = s\n  /-- An `R[X]`-algebra instance on `S`. The default is the one induced by the map `R[X] → S`,\n  but this causes a diamond if there is an existing instance. -/\n  algebra : Algebra (MvPolynomial vars R) S := (aeval val).toAlgebra\n  algebraMap_eq :\n    algebraMap (MvPolynomial vars R) S = aeval (R := R) val := by rfl\n\n"}
{"name":"Algebra.Generators.mk.inj","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nvars✝ : Type w\nval✝ : vars✝ → S\nσ'✝ : S → MvPolynomial vars✝ R\naeval_val_σ'✝ : ∀ (s : S), Eq ((MvPolynomial.aeval val✝) (σ'✝ s)) s\nalgebra✝ : Algebra (MvPolynomial vars✝ R) S\nalgebraMap_eq✝ : autoParam (Eq (algebraMap (MvPolynomial vars✝ R) S) ↑(MvPolynomial.aeval val✝)) _auto✝\nvars : Type w\nval : vars → S\nσ' : S → MvPolynomial vars R\naeval_val_σ' : ∀ (s : S), Eq ((MvPolynomial.aeval val) (σ' s)) s\nalgebra : Algebra (MvPolynomial vars R) S\nalgebraMap_eq : autoParam (Eq (algebraMap (MvPolynomial vars R) S) ↑(MvPolynomial.aeval val)) _auto✝\nx✝ : Eq { vars := vars✝, val := val✝, σ' := σ'✝, aeval_val_σ' := aeval_val_σ'✝, algebra := algebra✝, algebraMap_eq := algebraMap_eq✝ } { vars := vars, val := val, σ' := σ', aeval_val_σ' := aeval_val_σ', algebra := algebra, algebraMap_eq := algebraMap_eq }\n⊢ And (Eq vars✝ vars) (And (HEq val✝ val) (And (HEq σ'✝ σ') (HEq algebra✝ algebra)))","decl":"/-- A family of generators of a `R`-algebra `S` consists of\n1. `vars`: The type of variables.\n2. `val : vars → S`: The assignment of each variable to a value in `S`.\n3. `σ`: A section of `R[X] → S`. -/\nstructure Algebra.Generators where\n  /-- The type of variables. -/\n  vars : Type w\n  /-- The assignment of each variable to a value in `S`. -/\n  val : vars → S\n  /-- A section of `R[X] → S`. -/\n  σ' : S → MvPolynomial vars R\n  aeval_val_σ' : ∀ s, aeval val (σ' s) = s\n  /-- An `R[X]`-algebra instance on `S`. The default is the one induced by the map `R[X] → S`,\n  but this causes a diamond if there is an existing instance. -/\n  algebra : Algebra (MvPolynomial vars R) S := (aeval val).toAlgebra\n  algebraMap_eq :\n    algebraMap (MvPolynomial vars R) S = aeval (R := R) val := by rfl\n\n"}
{"name":"Algebra.Generators.aeval_val_σ'","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.Generators R S\ns : S\n⊢ Eq ((MvPolynomial.aeval self.val) (self.σ' s)) s","decl":"/-- A family of generators of a `R`-algebra `S` consists of\n1. `vars`: The type of variables.\n2. `val : vars → S`: The assignment of each variable to a value in `S`.\n3. `σ`: A section of `R[X] → S`. -/\nstructure Algebra.Generators where\n  /-- The type of variables. -/\n  vars : Type w\n  /-- The assignment of each variable to a value in `S`. -/\n  val : vars → S\n  /-- A section of `R[X] → S`. -/\n  σ' : S → MvPolynomial vars R\n  aeval_val_σ' : ∀ s, aeval val (σ' s) = s\n  /-- An `R[X]`-algebra instance on `S`. The default is the one induced by the map `R[X] → S`,\n  but this causes a diamond if there is an existing instance. -/\n  algebra : Algebra (MvPolynomial vars R) S := (aeval val).toAlgebra\n  algebraMap_eq :\n    algebraMap (MvPolynomial vars R) S = aeval (R := R) val := by rfl\n\n"}
{"name":"Algebra.Generators.algebraMap_eq","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.Generators R S\n⊢ Eq (algebraMap (MvPolynomial self.vars R) S) ↑(MvPolynomial.aeval self.val)","decl":"/-- A family of generators of a `R`-algebra `S` consists of\n1. `vars`: The type of variables.\n2. `val : vars → S`: The assignment of each variable to a value in `S`.\n3. `σ`: A section of `R[X] → S`. -/\nstructure Algebra.Generators where\n  /-- The type of variables. -/\n  vars : Type w\n  /-- The assignment of each variable to a value in `S`. -/\n  val : vars → S\n  /-- A section of `R[X] → S`. -/\n  σ' : S → MvPolynomial vars R\n  aeval_val_σ' : ∀ s, aeval val (σ' s) = s\n  /-- An `R[X]`-algebra instance on `S`. The default is the one induced by the map `R[X] → S`,\n  but this causes a diamond if there is an existing instance. -/\n  algebra : Algebra (MvPolynomial vars R) S := (aeval val).toAlgebra\n  algebraMap_eq :\n    algebraMap (MvPolynomial vars R) S = aeval (R := R) val := by rfl\n\n"}
{"name":"Algebra.Generators.aeval_val_σ","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\ns : S\n⊢ Eq ((MvPolynomial.aeval P.val) (P.σ s)) s","decl":"@[simp]\nlemma aeval_val_σ (s) : aeval P.val (P.σ s) = s := P.aeval_val_σ' s\n\n"}
{"name":"Algebra.Generators.instIsScalarTowerRing","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR₀ : Type u_1\ninst✝³ : CommRing R₀\ninst✝² : Algebra R₀ R\ninst✝¹ : Algebra R₀ S\ninst✝ : IsScalarTower R₀ R S\n⊢ IsScalarTower R₀ P.Ring S","decl":"noncomputable instance {R₀} [CommRing R₀] [Algebra R₀ R] [Algebra R₀ S] [IsScalarTower R₀ R S] :\n    IsScalarTower R₀ P.Ring S := IsScalarTower.of_algebraMap_eq' <|\n  P.algebraMap_eq ▸ ((aeval (R := R) P.val).comp_algebraMap_of_tower R₀).symm\n\n"}
{"name":"Algebra.Generators.algebraMap_apply","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\nx : P.Ring\n⊢ Eq ((algebraMap P.Ring S) x) ((MvPolynomial.aeval P.val) x)","decl":"@[simp]\nlemma algebraMap_apply (x) : algebraMap P.Ring S x = aeval (R := R) P.val x := by\n  simp [algebraMap_eq]\n\n"}
{"name":"Algebra.Generators.σ_smul","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\nx y : S\n⊢ Eq (HSMul.hSMul (P.σ x) y) (HMul.hMul x y)","decl":"@[simp]\nlemma σ_smul (x y) : P.σ x • y = x * y := by\n  rw [Algebra.smul_def, algebraMap_apply, aeval_val_σ]\n\n"}
{"name":"Algebra.Generators.σ_injective","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Function.Injective P.σ","decl":"lemma σ_injective : P.σ.Injective := by\n  intro x y e\n  rw [← P.aeval_val_σ x, ← P.aeval_val_σ y, e]\n\n"}
{"name":"Algebra.Generators.algebraMap_surjective","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Function.Surjective ⇑(algebraMap P.Ring S)","decl":"lemma algebraMap_surjective : Function.Surjective (algebraMap P.Ring S) :=\n  (⟨_, P.algebraMap_apply _ ▸ P.aeval_val_σ ·⟩)\n\n"}
{"name":"Algebra.Generators.ofSurjective_vars","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nvars : Type u_1\nval : vars → S\nh : Function.Surjective ⇑(MvPolynomial.aeval val)\n⊢ Eq (Algebra.Generators.ofSurjective val h).vars vars","decl":"/-- Construct `Generators` from an assignment `I → S` such that `R[X] → S` is surjective. -/\n@[simps val, simps (config := .lemmasOnly) vars]\nnoncomputable\ndef ofSurjective {vars} (val : vars → S) (h : Function.Surjective (aeval (R := R) val)) :\n    Generators R S where\n  vars := vars\n  val := val\n  σ' x := (h x).choose\n  aeval_val_σ' x := (h x).choose_spec\n\n"}
{"name":"Algebra.Generators.ofSurjective_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nvars : Type u_1\nval : vars → S\nh : Function.Surjective ⇑(MvPolynomial.aeval val)\na✝ : vars\n⊢ Eq ((Algebra.Generators.ofSurjective val h).val a✝) (val a✝)","decl":"/-- Construct `Generators` from an assignment `I → S` such that `R[X] → S` is surjective. -/\n@[simps val, simps (config := .lemmasOnly) vars]\nnoncomputable\ndef ofSurjective {vars} (val : vars → S) (h : Function.Surjective (aeval (R := R) val)) :\n    Generators R S where\n  vars := vars\n  val := val\n  σ' x := (h x).choose\n  aeval_val_σ' x := (h x).choose_spec\n\n"}
{"name":"Algebra.Generators.self_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\na : S\n⊢ Eq ((Algebra.Generators.self R S).val a) (id a)","decl":"variable (R S) in\n/-- The `Generators` containing the whole algebra, which induces the canonical map  `R[S] → S`. -/\n@[simps]\nnoncomputable\ndef self : Generators R S where\n  vars := S\n  val := _root_.id\n  σ' := X\n  aeval_val_σ' := aeval_X _\n\n"}
{"name":"Algebra.Generators.self_algebra","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (Algebra.Generators.self R S).algebra (MvPolynomial.aeval id).toAlgebra","decl":"variable (R S) in\n/-- The `Generators` containing the whole algebra, which induces the canonical map  `R[S] → S`. -/\n@[simps]\nnoncomputable\ndef self : Generators R S where\n  vars := S\n  val := _root_.id\n  σ' := X\n  aeval_val_σ' := aeval_X _\n\n"}
{"name":"Algebra.Generators.self_σ","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nn : S\n⊢ Eq ((Algebra.Generators.self R S).σ n) (MvPolynomial.X n)","decl":"variable (R S) in\n/-- The `Generators` containing the whole algebra, which induces the canonical map  `R[S] → S`. -/\n@[simps]\nnoncomputable\ndef self : Generators R S where\n  vars := S\n  val := _root_.id\n  σ' := X\n  aeval_val_σ' := aeval_X _\n\n"}
{"name":"Algebra.Generators.self_vars","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\n⊢ Eq (Algebra.Generators.self R S).vars S","decl":"variable (R S) in\n/-- The `Generators` containing the whole algebra, which induces the canonical map  `R[S] → S`. -/\n@[simps]\nnoncomputable\ndef self : Generators R S where\n  vars := S\n  val := _root_.id\n  σ' := X\n  aeval_val_σ' := aeval_X _\n\n"}
{"name":"Algebra.Generators.toExtension_σ","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\na✝ : S\n⊢ Eq (P.toExtension.σ a✝) (P.σ a✝)","decl":"/-- The extension `R[X₁,...,Xₙ] → S` given a family of generators. -/\n@[simps]\nnoncomputable\ndef toExtension : Extension R S where\n  Ring := P.Ring\n  σ := P.σ\n  algebraMap_σ := by simp\n\n"}
{"name":"Algebra.Generators.toExtension_algebra₁","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq P.toExtension.algebra₁ MvPolynomial.algebra","decl":"/-- The extension `R[X₁,...,Xₙ] → S` given a family of generators. -/\n@[simps]\nnoncomputable\ndef toExtension : Extension R S where\n  Ring := P.Ring\n  σ := P.σ\n  algebraMap_σ := by simp\n\n"}
{"name":"Algebra.Generators.toExtension_commRing","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq P.toExtension.commRing MvPolynomial.instCommRingMvPolynomial","decl":"/-- The extension `R[X₁,...,Xₙ] → S` given a family of generators. -/\n@[simps]\nnoncomputable\ndef toExtension : Extension R S where\n  Ring := P.Ring\n  σ := P.σ\n  algebraMap_σ := by simp\n\n"}
{"name":"Algebra.Generators.toExtension_Ring","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq P.toExtension.Ring P.Ring","decl":"/-- The extension `R[X₁,...,Xₙ] → S` given a family of generators. -/\n@[simps]\nnoncomputable\ndef toExtension : Extension R S where\n  Ring := P.Ring\n  σ := P.σ\n  algebraMap_σ := by simp\n\n"}
{"name":"Algebra.Generators.toExtension_algebra₂","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq P.toExtension.algebra₂ P.algebra","decl":"/-- The extension `R[X₁,...,Xₙ] → S` given a family of generators. -/\n@[simps]\nnoncomputable\ndef toExtension : Extension R S where\n  Ring := P.Ring\n  σ := P.σ\n  algebraMap_σ := by simp\n\n"}
{"name":"Algebra.Generators.localizationAway_vars","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Eq (Algebra.Generators.localizationAway r).vars Unit","decl":"/-- If `S` is the localization of `R` away from `r`, we obtain a canonical generator mapping\nto the inverse of `r`. -/\n@[simps val, simps (config := .lemmasOnly) vars σ]\nnoncomputable\ndef localizationAway : Generators R S where\n  vars := Unit\n  val _ := IsLocalization.Away.invSelf r\n  σ' s :=\n    letI a : R := (IsLocalization.Away.sec r s).1\n    letI n : ℕ := (IsLocalization.Away.sec r s).2\n    C a * X () ^ n\n  aeval_val_σ' s := by\n    rw [map_mul, algHom_C, map_pow, aeval_X]\n    simp only [← IsLocalization.Away.sec_spec, map_pow, IsLocalization.Away.invSelf]\n    rw [← IsLocalization.mk'_pow, one_pow, ← IsLocalization.mk'_one (M := Submonoid.powers r) S r]\n    rw [← IsLocalization.mk'_pow, one_pow, mul_assoc, ← IsLocalization.mk'_mul]\n    rw [mul_one, one_mul, IsLocalization.mk'_pow]\n    simp\n\n"}
{"name":"Algebra.Generators.localizationAway_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\nx✝ : Unit\n⊢ Eq ((Algebra.Generators.localizationAway r).val x✝) (IsLocalization.Away.invSelf r)","decl":"/-- If `S` is the localization of `R` away from `r`, we obtain a canonical generator mapping\nto the inverse of `r`. -/\n@[simps val, simps (config := .lemmasOnly) vars σ]\nnoncomputable\ndef localizationAway : Generators R S where\n  vars := Unit\n  val _ := IsLocalization.Away.invSelf r\n  σ' s :=\n    letI a : R := (IsLocalization.Away.sec r s).1\n    letI n : ℕ := (IsLocalization.Away.sec r s).2\n    C a * X () ^ n\n  aeval_val_σ' s := by\n    rw [map_mul, algHom_C, map_pow, aeval_X]\n    simp only [← IsLocalization.Away.sec_spec, map_pow, IsLocalization.Away.invSelf]\n    rw [← IsLocalization.mk'_pow, one_pow, ← IsLocalization.mk'_one (M := Submonoid.powers r) S r]\n    rw [← IsLocalization.mk'_pow, one_pow, mul_assoc, ← IsLocalization.mk'_mul]\n    rw [mul_one, one_mul, IsLocalization.mk'_pow]\n    simp\n\n"}
{"name":"Algebra.Generators.localizationAway_σ","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\ns : S\n⊢ Eq ((Algebra.Generators.localizationAway r).σ s) (HMul.hMul (MvPolynomial.C (IsLocalization.Away.sec r s).1) (HPow.hPow (MvPolynomial.X Unit.unit) (IsLocalization.Away.sec r s).2))","decl":"/-- If `S` is the localization of `R` away from `r`, we obtain a canonical generator mapping\nto the inverse of `r`. -/\n@[simps val, simps (config := .lemmasOnly) vars σ]\nnoncomputable\ndef localizationAway : Generators R S where\n  vars := Unit\n  val _ := IsLocalization.Away.invSelf r\n  σ' s :=\n    letI a : R := (IsLocalization.Away.sec r s).1\n    letI n : ℕ := (IsLocalization.Away.sec r s).2\n    C a * X () ^ n\n  aeval_val_σ' s := by\n    rw [map_mul, algHom_C, map_pow, aeval_X]\n    simp only [← IsLocalization.Away.sec_spec, map_pow, IsLocalization.Away.invSelf]\n    rw [← IsLocalization.mk'_pow, one_pow, ← IsLocalization.mk'_one (M := Submonoid.powers r) S r]\n    rw [← IsLocalization.mk'_pow, one_pow, mul_assoc, ← IsLocalization.mk'_mul]\n    rw [mul_one, one_mul, IsLocalization.mk'_pow]\n    simp\n\n"}
{"name":"Algebra.Generators.comp_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\na✝ : Sum Q.vars P.vars\n⊢ Eq ((Q.comp P).val a✝) (Sum.elim Q.val (Function.comp (⇑(algebraMap S T)) P.val) a✝)","decl":"/-- Given two families of generators `S[X] → T` and `R[Y] → S`,\nwe may construct the family of generators `R[X, Y] → T`. -/\n@[simps val, simps (config := .lemmasOnly) vars σ]\nnoncomputable\ndef comp (Q : Generators S T) (P : Generators R S) : Generators R T where\n  vars := Q.vars ⊕ P.vars\n  val := Sum.elim Q.val (algebraMap S T ∘ P.val)\n  σ' x := (Q.σ x).sum (fun n r ↦ rename Sum.inr (P.σ r) * monomial (n.mapDomain Sum.inl) 1)\n  aeval_val_σ' s := by\n    have (x : P.Ring) : aeval (algebraMap S T ∘ P.val) x = algebraMap S T (aeval P.val x) := by\n      rw [map_aeval, aeval_def, coe_eval₂Hom, ← IsScalarTower.algebraMap_eq, Function.comp_def]\n    conv_rhs => rw [← Q.aeval_val_σ s, ← (Q.σ s).sum_single]\n    simp only [map_finsupp_sum, map_mul, aeval_rename, Sum.elim_comp_inr, this, aeval_val_σ,\n      aeval_monomial, map_one, Finsupp.prod_mapDomain_index_inj Sum.inl_injective, Sum.elim_inl,\n      one_mul, single_eq_monomial]\n\n"}
{"name":"Algebra.Generators.comp_vars","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq (Q.comp P).vars (Sum Q.vars P.vars)","decl":"/-- Given two families of generators `S[X] → T` and `R[Y] → S`,\nwe may construct the family of generators `R[X, Y] → T`. -/\n@[simps val, simps (config := .lemmasOnly) vars σ]\nnoncomputable\ndef comp (Q : Generators S T) (P : Generators R S) : Generators R T where\n  vars := Q.vars ⊕ P.vars\n  val := Sum.elim Q.val (algebraMap S T ∘ P.val)\n  σ' x := (Q.σ x).sum (fun n r ↦ rename Sum.inr (P.σ r) * monomial (n.mapDomain Sum.inl) 1)\n  aeval_val_σ' s := by\n    have (x : P.Ring) : aeval (algebraMap S T ∘ P.val) x = algebraMap S T (aeval P.val x) := by\n      rw [map_aeval, aeval_def, coe_eval₂Hom, ← IsScalarTower.algebraMap_eq, Function.comp_def]\n    conv_rhs => rw [← Q.aeval_val_σ s, ← (Q.σ s).sum_single]\n    simp only [map_finsupp_sum, map_mul, aeval_rename, Sum.elim_comp_inr, this, aeval_val_σ,\n      aeval_monomial, map_one, Finsupp.prod_mapDomain_index_inj Sum.inl_injective, Sum.elim_inl,\n      one_mul, single_eq_monomial]\n\n"}
{"name":"Algebra.Generators.comp_σ","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nx : T\n⊢ Eq ((Q.comp P).σ x) (Finsupp.sum (Q.σ x) fun n r => HMul.hMul ((MvPolynomial.rename Sum.inr) (P.σ r)) ((MvPolynomial.monomial (Finsupp.mapDomain Sum.inl n)) 1))","decl":"/-- Given two families of generators `S[X] → T` and `R[Y] → S`,\nwe may construct the family of generators `R[X, Y] → T`. -/\n@[simps val, simps (config := .lemmasOnly) vars σ]\nnoncomputable\ndef comp (Q : Generators S T) (P : Generators R S) : Generators R T where\n  vars := Q.vars ⊕ P.vars\n  val := Sum.elim Q.val (algebraMap S T ∘ P.val)\n  σ' x := (Q.σ x).sum (fun n r ↦ rename Sum.inr (P.σ r) * monomial (n.mapDomain Sum.inl) 1)\n  aeval_val_σ' s := by\n    have (x : P.Ring) : aeval (algebraMap S T ∘ P.val) x = algebraMap S T (aeval P.val x) := by\n      rw [map_aeval, aeval_def, coe_eval₂Hom, ← IsScalarTower.algebraMap_eq, Function.comp_def]\n    conv_rhs => rw [← Q.aeval_val_σ s, ← (Q.σ s).sum_single]\n    simp only [map_finsupp_sum, map_mul, aeval_rename, Sum.elim_comp_inr, this, aeval_val_σ,\n      aeval_monomial, map_one, Finsupp.prod_mapDomain_index_inj Sum.inl_injective, Sum.elim_inl,\n      one_mul, single_eq_monomial]\n\n"}
{"name":"Algebra.Generators.extendScalars_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nP : Algebra.Generators R T\na✝ : P.vars\n⊢ Eq ((Algebra.Generators.extendScalars S P).val a✝) (P.val a✝)","decl":"variable (S) in\n/-- If `R → S → T` is a tower of algebras, a family of generators `R[X] → T`\ngives a family of generators `S[X] → T`. -/\n@[simps val, simps (config := .lemmasOnly) vars]\nnoncomputable\ndef extendScalars (P : Generators R T) : Generators S T where\n  vars := P.vars\n  val := P.val\n  σ' x := map (algebraMap R S) (P.σ x)\n  aeval_val_σ' s := by simp [@aeval_def S, ← IsScalarTower.algebraMap_eq, ← @aeval_def R]\n\n"}
{"name":"Algebra.Generators.extendScalars_vars","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nP : Algebra.Generators R T\n⊢ Eq (Algebra.Generators.extendScalars S P).vars P.vars","decl":"variable (S) in\n/-- If `R → S → T` is a tower of algebras, a family of generators `R[X] → T`\ngives a family of generators `S[X] → T`. -/\n@[simps val, simps (config := .lemmasOnly) vars]\nnoncomputable\ndef extendScalars (P : Generators R T) : Generators S T where\n  vars := P.vars\n  val := P.val\n  σ' x := map (algebraMap R S) (P.σ x)\n  aeval_val_σ' s := by simp [@aeval_def S, ← IsScalarTower.algebraMap_eq, ← @aeval_def R]\n\n"}
{"name":"Algebra.Generators.baseChange_vars","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nP : Algebra.Generators R S\n⊢ Eq P.baseChange.vars P.vars","decl":"/-- If `P` is a family of generators of `S` over `R` and `T` is an `R`-algebra, we\nobtain a natural family of generators of `T ⊗[R] S` over `T`. -/\n@[simps! val, simps! (config := .lemmasOnly) vars]\nnoncomputable\ndef baseChange {T} [CommRing T] [Algebra R T] (P : Generators R S) : Generators T (T ⊗[R] S) := by\n  apply Generators.ofSurjective (fun x ↦ 1 ⊗ₜ[R] P.val x)\n  intro x\n  induction x using TensorProduct.induction_on with\n  | zero => exact ⟨0, map_zero _⟩\n  | tmul a b =>\n    let X := P.σ b\n    use a • MvPolynomial.map (algebraMap R T) X\n    simp only [LinearMapClass.map_smul, X, aeval_map_algebraMap]\n    have : ∀ y : P.Ring,\n      aeval (fun x ↦ (1 ⊗ₜ[R] P.val x : T ⊗[R] S)) y = 1 ⊗ₜ aeval (fun x ↦ P.val x) y := by\n      intro y\n      induction y using MvPolynomial.induction_on with\n      | h_C a =>\n        rw [aeval_C, aeval_C, TensorProduct.algebraMap_apply, algebraMap_eq_smul_one, smul_tmul,\n          algebraMap_eq_smul_one]\n      | h_add p q hp hq => simp [map_add, tmul_add, hp, hq]\n      | h_X p i hp => simp [hp]\n    rw [this, P.aeval_val_σ, smul_tmul', smul_eq_mul, mul_one]\n  | add x y ex ey =>\n    obtain ⟨a, ha⟩ := ex\n    obtain ⟨b, hb⟩ := ey\n    use (a + b)\n    rw [map_add, ha, hb]\n\n"}
{"name":"Algebra.Generators.baseChange_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nP : Algebra.Generators R S\nx : P.vars\n⊢ Eq (P.baseChange.val x) (TensorProduct.tmul R 1 (P.val x))","decl":"/-- If `P` is a family of generators of `S` over `R` and `T` is an `R`-algebra, we\nobtain a natural family of generators of `T ⊗[R] S` over `T`. -/\n@[simps! val, simps! (config := .lemmasOnly) vars]\nnoncomputable\ndef baseChange {T} [CommRing T] [Algebra R T] (P : Generators R S) : Generators T (T ⊗[R] S) := by\n  apply Generators.ofSurjective (fun x ↦ 1 ⊗ₜ[R] P.val x)\n  intro x\n  induction x using TensorProduct.induction_on with\n  | zero => exact ⟨0, map_zero _⟩\n  | tmul a b =>\n    let X := P.σ b\n    use a • MvPolynomial.map (algebraMap R T) X\n    simp only [LinearMapClass.map_smul, X, aeval_map_algebraMap]\n    have : ∀ y : P.Ring,\n      aeval (fun x ↦ (1 ⊗ₜ[R] P.val x : T ⊗[R] S)) y = 1 ⊗ₜ aeval (fun x ↦ P.val x) y := by\n      intro y\n      induction y using MvPolynomial.induction_on with\n      | h_C a =>\n        rw [aeval_C, aeval_C, TensorProduct.algebraMap_apply, algebraMap_eq_smul_one, smul_tmul,\n          algebraMap_eq_smul_one]\n      | h_add p q hp hq => simp [map_add, tmul_add, hp, hq]\n      | h_X p i hp => simp [hp]\n    rw [this, P.aeval_val_σ, smul_tmul', smul_eq_mul, mul_one]\n  | add x y ex ey =>\n    obtain ⟨a, ha⟩ := ex\n    obtain ⟨b, hb⟩ := ey\n    use (a + b)\n    rw [map_add, ha, hb]\n\n"}
{"name":"Algebra.Generators.Hom.mk.injEq","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\nval✝ : P.vars → P'.Ring\naeval_val✝ : ∀ (i : P.vars), Eq ((MvPolynomial.aeval P'.val) (val✝ i)) ((algebraMap S S') (P.val i))\nval : P.vars → P'.Ring\naeval_val : ∀ (i : P.vars), Eq ((MvPolynomial.aeval P'.val) (val i)) ((algebraMap S S') (P.val i))\n⊢ Eq (Eq { val := val✝, aeval_val := aeval_val✝ } { val := val, aeval_val := aeval_val }) (Eq val✝ val)","decl":"/-- Given a commuting square\nR --→ P = R[X] ---→ S\n|                   |\n↓                   ↓\nR' -→ P' = R'[X'] → S\nA hom between `P` and `P'` is an assignment `I → P'` such that the arrows commute.\nAlso see `Algebra.Generators.Hom.equivAlgHom`.\n-/\n@[ext]\nstructure Hom where\n  /-- The assignment of each variable in `I` to a value in `P' = R'[X']`. -/\n  val : P.vars → P'.Ring\n  aeval_val : ∀ i, aeval P'.val (val i) = algebraMap S S' (P.val i)\n\n"}
{"name":"Algebra.Generators.Hom.mk.inj","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\nval✝ : P.vars → P'.Ring\naeval_val✝ : ∀ (i : P.vars), Eq ((MvPolynomial.aeval P'.val) (val✝ i)) ((algebraMap S S') (P.val i))\nval : P.vars → P'.Ring\naeval_val : ∀ (i : P.vars), Eq ((MvPolynomial.aeval P'.val) (val i)) ((algebraMap S S') (P.val i))\nx✝ : Eq { val := val✝, aeval_val := aeval_val✝ } { val := val, aeval_val := aeval_val }\n⊢ Eq val✝ val","decl":"/-- Given a commuting square\nR --→ P = R[X] ---→ S\n|                   |\n↓                   ↓\nR' -→ P' = R'[X'] → S\nA hom between `P` and `P'` is an assignment `I → P'` such that the arrows commute.\nAlso see `Algebra.Generators.Hom.equivAlgHom`.\n-/\n@[ext]\nstructure Hom where\n  /-- The assignment of each variable in `I` to a value in `P' = R'[X']`. -/\n  val : P.vars → P'.Ring\n  aeval_val : ∀ i, aeval P'.val (val i) = algebraMap S S' (P.val i)\n\n"}
{"name":"Algebra.Generators.Hom.ext","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\nx y : P.Hom P'\nval : Eq x.val y.val\n⊢ Eq x y","decl":"/-- Given a commuting square\nR --→ P = R[X] ---→ S\n|                   |\n↓                   ↓\nR' -→ P' = R'[X'] → S\nA hom between `P` and `P'` is an assignment `I → P'` such that the arrows commute.\nAlso see `Algebra.Generators.Hom.equivAlgHom`.\n-/\n@[ext]\nstructure Hom where\n  /-- The assignment of each variable in `I` to a value in `P' = R'[X']`. -/\n  val : P.vars → P'.Ring\n  aeval_val : ∀ i, aeval P'.val (val i) = algebraMap S S' (P.val i)\n\n"}
{"name":"Algebra.Generators.Hom.mk.sizeOf_spec","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra S S'\ninst✝³ : SizeOf R\ninst✝² : SizeOf S\ninst✝¹ : SizeOf R'\ninst✝ : SizeOf S'\nval : P.vars → P'.Ring\naeval_val : ∀ (i : P.vars), Eq ((MvPolynomial.aeval P'.val) (val i)) ((algebraMap S S') (P.val i))\n⊢ Eq (SizeOf.sizeOf { val := val, aeval_val := aeval_val }) 1","decl":"/-- Given a commuting square\nR --→ P = R[X] ---→ S\n|                   |\n↓                   ↓\nR' -→ P' = R'[X'] → S\nA hom between `P` and `P'` is an assignment `I → P'` such that the arrows commute.\nAlso see `Algebra.Generators.Hom.equivAlgHom`.\n-/\n@[ext]\nstructure Hom where\n  /-- The assignment of each variable in `I` to a value in `P' = R'[X']`. -/\n  val : P.vars → P'.Ring\n  aeval_val : ∀ i, aeval P'.val (val i) = algebraMap S S' (P.val i)\n\n"}
{"name":"Algebra.Generators.Hom.aeval_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\nself : P.Hom P'\ni : P.vars\n⊢ Eq ((MvPolynomial.aeval P'.val) (self.val i)) ((algebraMap S S') (P.val i))","decl":"/-- Given a commuting square\nR --→ P = R[X] ---→ S\n|                   |\n↓                   ↓\nR' -→ P' = R'[X'] → S\nA hom between `P` and `P'` is an assignment `I → P'` such that the arrows commute.\nAlso see `Algebra.Generators.Hom.equivAlgHom`.\n-/\n@[ext]\nstructure Hom where\n  /-- The assignment of each variable in `I` to a value in `P' = R'[X']`. -/\n  val : P.vars → P'.Ring\n  aeval_val : ∀ i, aeval P'.val (val i) = algebraMap S S' (P.val i)\n\n"}
{"name":"Algebra.Generators.Hom.ext_iff","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\nx y : P.Hom P'\n⊢ Iff (Eq x y) (Eq x.val y.val)","decl":"/-- Given a commuting square\nR --→ P = R[X] ---→ S\n|                   |\n↓                   ↓\nR' -→ P' = R'[X'] → S\nA hom between `P` and `P'` is an assignment `I → P'` such that the arrows commute.\nAlso see `Algebra.Generators.Hom.equivAlgHom`.\n-/\n@[ext]\nstructure Hom where\n  /-- The assignment of each variable in `I` to a value in `P' = R'[X']`. -/\n  val : P.vars → P'.Ring\n  aeval_val : ∀ i, aeval P'.val (val i) = algebraMap S S' (P.val i)\n\n"}
{"name":"Algebra.Generators.Hom.algebraMap_toAlgHom","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf : P.Hom P'\nx : P.Ring\n⊢ Eq ((MvPolynomial.aeval P'.val) (f.toAlgHom x)) ((algebraMap S S') ((MvPolynomial.aeval P.val) x))","decl":"variable [Algebra R S'] [IsScalarTower R R' S'] [IsScalarTower R S S'] in\n@[simp]\nlemma Hom.algebraMap_toAlgHom (f : Hom P P') (x) : MvPolynomial.aeval P'.val (f.toAlgHom x) =\n    algebraMap S S' (MvPolynomial.aeval P.val x) := by\n  suffices ((MvPolynomial.aeval P'.val).restrictScalars R).comp f.toAlgHom =\n      (IsScalarTower.toAlgHom R S S').comp (MvPolynomial.aeval P.val) from\n    DFunLike.congr_fun this x\n  apply MvPolynomial.algHom_ext\n  intro i\n  simp [Hom.toAlgHom]\n\n"}
{"name":"Algebra.Generators.Hom.toAlgHom_X","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nf : P.Hom P'\ni : P.vars\n⊢ Eq (f.toAlgHom (MvPolynomial.X i)) (f.val i)","decl":"@[simp]\nlemma Hom.toAlgHom_X (f : Hom P P') (i) : f.toAlgHom (.X i) = f.val i :=\n  MvPolynomial.aeval_X f.val i\n\n"}
{"name":"Algebra.Generators.Hom.toAlgHom_C","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nf : P.Hom P'\nr : R\n⊢ Eq (f.toAlgHom (MvPolynomial.C r)) (MvPolynomial.C ((algebraMap R R') r))","decl":"lemma Hom.toAlgHom_C (f : Hom P P') (r) : f.toAlgHom (.C r) = .C (algebraMap _ _ r) :=\n  MvPolynomial.aeval_C f.val r\n\n"}
{"name":"Algebra.Generators.Hom.toAlgHom_monomial","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁷ : CommRing R\ninst✝⁶ : CommRing S\ninst✝⁵ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁴ : CommRing R'\ninst✝³ : CommRing S'\ninst✝² : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝¹ : Algebra R R'\ninst✝ : Algebra S S'\nf : P.Hom P'\nv : Finsupp P.vars Nat\nr : R\n⊢ Eq (f.toAlgHom ((MvPolynomial.monomial v) r)) (HSMul.hSMul r (v.prod fun x1 x2 => HPow.hPow (f.val x1) x2))","decl":"lemma Hom.toAlgHom_monomial (f : Generators.Hom P P') (v r) :\n    f.toAlgHom (monomial v r) = r • v.prod (f.val · ^ ·) := by\n  rw [toAlgHom, aeval_monomial, Algebra.smul_def]\n\n"}
{"name":"Algebra.Generators.Hom.equivAlgHom_symm_apply_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf : Subtype fun f => ∀ (x : P.Ring), Eq ((MvPolynomial.aeval P'.val) (f x)) ((algebraMap S S') ((MvPolynomial.aeval P.val) x))\ni : P.vars\n⊢ Eq ((Algebra.Generators.Hom.equivAlgHom.symm f).val i) (↑f (MvPolynomial.X i))","decl":"variable [Algebra R S'] [IsScalarTower R R' S'] [IsScalarTower R S S'] in\n/-- Giving a hom between two families of generators is equivalent to\ngiving an algebra homomorphism between the polynomial rings. -/\n@[simps]\nnoncomputable\ndef Hom.equivAlgHom :\n    Hom P P' ≃ { f : P.Ring →ₐ[R] P'.Ring //\n      ∀ x, aeval P'.val (f x) = algebraMap S S' (aeval P.val x) } where\n  toFun f := ⟨f.toAlgHom, f.algebraMap_toAlgHom⟩\n  invFun f := ⟨fun i ↦ f.1 (.X i), fun i ↦ by simp [f.2]⟩\n  left_inv f := by ext; simp\n  right_inv f := by ext; simp\n\n"}
{"name":"Algebra.Generators.Hom.equivAlgHom_apply_coe","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf : P.Hom P'\n⊢ Eq (↑(Algebra.Generators.Hom.equivAlgHom f)) f.toAlgHom","decl":"variable [Algebra R S'] [IsScalarTower R R' S'] [IsScalarTower R S S'] in\n/-- Giving a hom between two families of generators is equivalent to\ngiving an algebra homomorphism between the polynomial rings. -/\n@[simps]\nnoncomputable\ndef Hom.equivAlgHom :\n    Hom P P' ≃ { f : P.Ring →ₐ[R] P'.Ring //\n      ∀ x, aeval P'.val (f x) = algebraMap S S' (aeval P.val x) } where\n  toFun f := ⟨f.toAlgHom, f.algebraMap_toAlgHom⟩\n  invFun f := ⟨fun i ↦ f.1 (.X i), fun i ↦ by simp [f.2]⟩\n  left_inv f := by ext; simp\n  right_inv f := by ext; simp\n\n"}
{"name":"Algebra.Generators.defaultHom_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\na✝ : P.vars\n⊢ Eq ((P.defaultHom P').val a✝) (Function.comp P'.σ (Function.comp (⇑(algebraMap S S')) P.val) a✝)","decl":"/-- The hom from `P` to `P'` given by the designated section of `P'`. -/\n@[simps]\ndef defaultHom : Hom P P' := ⟨P'.σ ∘ algebraMap S S' ∘ P.val, fun x ↦ by simp⟩\n\n"}
{"name":"Algebra.Generators.Hom.id_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\nn : P.vars\n⊢ Eq ((Algebra.Generators.Hom.id P).val n) (MvPolynomial.X n)","decl":"/-- The identity hom. -/\n@[simps]\nprotected noncomputable def Hom.id : Hom P P := ⟨X, by simp⟩\n\n"}
{"name":"Algebra.Generators.Hom.toAlgHom_id","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq (Algebra.Generators.Hom.id P).toAlgHom (AlgHom.id R P.Ring)","decl":"@[simp]\nlemma Hom.toAlgHom_id : Hom.toAlgHom (.id P) = AlgHom.id _ _ := by ext1; simp\n\n"}
{"name":"Algebra.Generators.Hom.comp_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁶ : CommRing R\ninst✝¹⁵ : CommRing S\ninst✝¹⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝¹³ : CommRing R'\ninst✝¹² : CommRing S'\ninst✝¹¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\nR'' : Type u_4\nS'' : Type u_5\ninst✝¹⁰ : CommRing R''\ninst✝⁹ : CommRing S''\ninst✝⁸ : Algebra R'' S''\nP'' : Algebra.Generators R'' S''\ninst✝⁷ : Algebra R' R''\ninst✝⁶ : Algebra R' S''\ninst✝⁵ : Algebra S S'\ninst✝⁴ : Algebra S' S''\ninst✝³ : Algebra S S''\ninst✝² : IsScalarTower R' R'' S''\ninst✝¹ : IsScalarTower R' S' S''\ninst✝ : IsScalarTower S S' S''\nf : P'.Hom P''\ng : P.Hom P'\nx : P.vars\n⊢ Eq ((f.comp g).val x) ((MvPolynomial.aeval f.val) (g.val x))","decl":"/-- The composition of two homs. -/\n@[simps]\nnoncomputable def Hom.comp [IsScalarTower R' R'' S''] [IsScalarTower R' S' S'']\n    [IsScalarTower S S' S''] (f : Hom P' P'') (g : Hom P P') : Hom P P'' where\n  val x := aeval f.val (g.val x)\n  aeval_val x := by\n    simp only\n    rw [IsScalarTower.algebraMap_apply S S' S'', ← g.aeval_val]\n    induction g.val x using MvPolynomial.induction_on with\n    | h_C r => simp [← IsScalarTower.algebraMap_apply]\n    | h_add x y hx hy => simp only [map_add, hx, hy]\n    | h_X p i hp => simp only [map_mul, hp, aeval_X, aeval_val]\n\n"}
{"name":"Algebra.Generators.Hom.comp_id","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_2\nS' : Type u_1\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf : P.Hom P'\n⊢ Eq (f.comp (Algebra.Generators.Hom.id P)) f","decl":"@[simp]\nlemma Hom.comp_id [Algebra R S'] [IsScalarTower R R' S'] [IsScalarTower R S S'] (f : Hom P P') :\n    f.comp (Hom.id P) = f := by ext; simp\n\n"}
{"name":"Algebra.Generators.Hom.id_comp","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_2\nS' : Type u_1\ninst✝³ : CommRing R'\ninst✝² : CommRing S'\ninst✝¹ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝ : Algebra S S'\nf : P.Hom P'\n⊢ Eq ((Algebra.Generators.Hom.id P').comp f) f","decl":"@[simp]\nlemma Hom.id_comp [Algebra S S'] (f : Hom P P') : (Hom.id P').comp f = f := by\n  ext; simp [Hom.id, aeval_X_left]\n\n"}
{"name":"Algebra.Generators.Hom.toAlgHom_comp_apply","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁹ : CommRing R\ninst✝¹⁸ : CommRing S\ninst✝¹⁷ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_2\nS' : Type u_4\ninst✝¹⁶ : CommRing R'\ninst✝¹⁵ : CommRing S'\ninst✝¹⁴ : Algebra R' S'\nP' : Algebra.Generators R' S'\nR'' : Type u_1\nS'' : Type u_3\ninst✝¹³ : CommRing R''\ninst✝¹² : CommRing S''\ninst✝¹¹ : Algebra R'' S''\nP'' : Algebra.Generators R'' S''\ninst✝¹⁰ : Algebra R R'\ninst✝⁹ : Algebra R' R''\ninst✝⁸ : Algebra R' S''\ninst✝⁷ : Algebra S S'\ninst✝⁶ : Algebra S' S''\ninst✝⁵ : Algebra S S''\ninst✝⁴ : Algebra R R''\ninst✝³ : IsScalarTower R R' R''\ninst✝² : IsScalarTower R' R'' S''\ninst✝¹ : IsScalarTower R' S' S''\ninst✝ : IsScalarTower S S' S''\nf : P.Hom P'\ng : P'.Hom P''\nx : P.Ring\n⊢ Eq ((g.comp f).toAlgHom x) (g.toAlgHom (f.toAlgHom x))","decl":"@[simp]\nlemma Hom.toAlgHom_comp_apply\n    [Algebra R R''] [IsScalarTower R R' R''] [IsScalarTower R' R'' S'']\n    [IsScalarTower R' S' S''] [IsScalarTower S S' S'']\n    (f : Hom P P') (g : Hom P' P'') (x) :\n    (g.comp f).toAlgHom x = g.toAlgHom (f.toAlgHom x) := by\n  induction x using MvPolynomial.induction_on with\n  | h_C r => simp only [← MvPolynomial.algebraMap_eq, AlgHom.map_algebraMap]\n  | h_add x y hx hy => simp only [map_add, hx, hy]\n  | h_X p i hp => simp only [map_mul, hp, toAlgHom_X, comp_val]; rfl\n\n"}
{"name":"Algebra.Generators.toComp_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\ni : P.vars\n⊢ Eq ((Q.toComp P).val i) (MvPolynomial.X (Sum.inr i))","decl":"/-- Given families of generators `X ⊆ T` over `S` and `Y ⊆ S` over `R`,\nthere is a map of generators `R[Y] → R[X, Y]`. -/\n@[simps]\nnoncomputable\ndef toComp (Q : Generators S T) (P : Generators R S) : Hom P (Q.comp P) where\n  val i := X (.inr i)\n  aeval_val i := by simp\n\n"}
{"name":"Algebra.Generators.toComp_toAlgHom","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_2\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq (Q.toComp P).toAlgHom (MvPolynomial.rename Sum.inr)","decl":"lemma toComp_toAlgHom (Q : Generators S T) (P : Generators R S) :\n    (Q.toComp P).toAlgHom = rename Sum.inr := rfl\n\n"}
{"name":"Algebra.Generators.ofComp_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\ni : (Q.comp P).vars\n⊢ Eq ((Q.ofComp P).val i) (Sum.elim MvPolynomial.X (Function.comp (⇑MvPolynomial.C) P.val) i)","decl":"/-- Given families of generators `X ⊆ T` over `S` and `Y ⊆ S` over `R`,\nthere is a map of generators `R[X, Y] → S[X]`. -/\n@[simps]\nnoncomputable\ndef ofComp (Q : Generators S T) (P : Generators R S) : Hom (Q.comp P) Q where\n  val i := i.elim X (C ∘ P.val)\n  aeval_val i := by cases i <;> simp\n\n"}
{"name":"Algebra.Generators.ofComp_toAlgHom_monomial_sumElim","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_2\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nv₁ : Finsupp Q.vars Nat\nv₂ : Finsupp P.vars Nat\na : R\n⊢ Eq ((Q.ofComp P).toAlgHom ((MvPolynomial.monomial (v₁.sumElim v₂)) a)) ((MvPolynomial.monomial v₁) ((MvPolynomial.aeval P.val) ((MvPolynomial.monomial v₂) a)))","decl":"lemma ofComp_toAlgHom_monomial_sumElim (Q : Generators S T) (P : Generators R S) (v₁ v₂ a) :\n    (Q.ofComp P).toAlgHom (monomial (Finsupp.sumElim v₁ v₂) a) =\n      monomial v₁ (aeval P.val (monomial v₂ a)) := by\n  erw [Hom.toAlgHom_monomial]\n  rw [monomial_eq]\n  simp only [MvPolynomial.algebraMap_apply, ofComp_val, aeval_monomial]\n  rw [Finsupp.prod_sumElim]\n  simp only [Function.comp_def, Sum.elim_inl, Sum.elim_inr, ← map_pow, ← map_finsupp_prod,\n    C_mul, Algebra.smul_def, MvPolynomial.algebraMap_apply, mul_assoc]\n  nth_rw 2 [mul_comm]\n\n"}
{"name":"Algebra.Generators.toComp_toAlgHom_monomial","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_2\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\nj : Finsupp P.vars Nat\na : R\n⊢ Eq ((Q.toComp P).toAlgHom ((MvPolynomial.monomial j) a)) ((MvPolynomial.monomial (Finsupp.sumElim 0 j)) a)","decl":"lemma toComp_toAlgHom_monomial (Q : Generators S T) (P : Generators R S) (j a) :\n    (Q.toComp P).toAlgHom (monomial j a) =\n      monomial (Finsupp.sumElim 0 j) a := by\n  convert rename_monomial _ _ _\n  ext f (i₁ | i₂) <;>\n    simp [Finsupp.mapDomain_notin_range, Finsupp.mapDomain_apply Sum.inr_injective]\n\n"}
{"name":"Algebra.Generators.toExtendScalars_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_1\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\ninst✝ : Algebra S T\nP : Algebra.Generators R T\nn : P.vars\n⊢ Eq (P.toExtendScalars.val n) (MvPolynomial.X n)","decl":"/-- Given families of generators `X ⊆ T`, there is a map `R[X] → S[X]`. -/\n@[simps]\nnoncomputable\ndef toExtendScalars (P : Generators R T) : Hom P (P.extendScalars S) where\n  val := X\n  aeval_val i := by simp\n\n"}
{"name":"Algebra.Generators.Hom.toExtensionHom_toRingHom","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : CommRing S\ninst✝⁸ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_1\nS' : Type u_2\ninst✝⁷ : CommRing R'\ninst✝⁶ : CommRing S'\ninst✝⁵ : Algebra R' S'\nP' : Algebra.Generators R' S'\ninst✝⁴ : Algebra R R'\ninst✝³ : Algebra S S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nf : P.Hom P'\n⊢ Eq f.toExtensionHom.toRingHom f.toAlgHom.toRingHom","decl":"variable {P P'} in\n/-- Reinterpret a hom between generators as a hom between extensions. -/\n@[simps]\nnoncomputable\ndef Hom.toExtensionHom [Algebra R S'] [IsScalarTower R R' S'] [IsScalarTower R S S']\n    (f : P.Hom P') : P.toExtension.Hom P'.toExtension where\n  toRingHom := f.toAlgHom.toRingHom\n  toRingHom_algebraMap x := by simp\n  algebraMap_toRingHom x := by simp\n\n"}
{"name":"Algebra.Generators.Hom.toExtensionHom_id","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq (Algebra.Generators.Hom.id P).toExtensionHom (Algebra.Extension.Hom.id P.toExtension)","decl":"@[simp]\nlemma Hom.toExtensionHom_id : Hom.toExtensionHom (.id P) = .id _ := by ext; simp\n\n"}
{"name":"Algebra.Generators.Hom.toExtensionHom_comp","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝²⁵ : CommRing R\ninst✝²⁴ : CommRing S\ninst✝²³ : Algebra R S\nP : Algebra.Generators R S\nR' : Type u_4\nS' : Type u_1\ninst✝²² : CommRing R'\ninst✝²¹ : CommRing S'\ninst✝²⁰ : Algebra R' S'\nP' : Algebra.Generators R' S'\nR'' : Type u_2\nS'' : Type u_3\ninst✝¹⁹ : CommRing R''\ninst✝¹⁸ : CommRing S''\ninst✝¹⁷ : Algebra R'' S''\nP'' : Algebra.Generators R'' S''\ninst✝¹⁶ : Algebra R R'\ninst✝¹⁵ : Algebra R' R''\ninst✝¹⁴ : Algebra R' S''\ninst✝¹³ : Algebra S S'\ninst✝¹² : Algebra S' S''\ninst✝¹¹ : Algebra S S''\ninst✝¹⁰ : Algebra R S'\ninst✝⁹ : IsScalarTower R S S'\ninst✝⁸ : Algebra R R''\ninst✝⁷ : Algebra R S''\ninst✝⁶ : IsScalarTower R R'' S''\ninst✝⁵ : IsScalarTower R S S''\ninst✝⁴ : IsScalarTower R' R'' S''\ninst✝³ : IsScalarTower R' S' S''\ninst✝² : IsScalarTower S S' S''\ninst✝¹ : IsScalarTower R R' R''\ninst✝ : IsScalarTower R R' S'\nf : P'.Hom P''\ng : P.Hom P'\n⊢ Eq (f.comp g).toExtensionHom (f.toExtensionHom.comp g.toExtensionHom)","decl":"@[simp]\nlemma Hom.toExtensionHom_comp [Algebra R S'] [IsScalarTower R S S']\n    [Algebra R R''] [Algebra R S''] [IsScalarTower R R'' S'']\n    [IsScalarTower R S S''] [IsScalarTower R' R'' S''] [IsScalarTower R' S' S'']\n    [IsScalarTower S S' S''] [IsScalarTower R R' R''] [IsScalarTower R R' S']\n    (f : P'.Hom P'') (g : P.Hom P') :\n    toExtensionHom (f.comp g) = f.toExtensionHom.comp g.toExtensionHom := by ext; simp\n\n"}
{"name":"Algebra.Generators.ker_eq_ker_aeval_val","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\n⊢ Eq P.ker (RingHom.ker (MvPolynomial.aeval P.val))","decl":"lemma ker_eq_ker_aeval_val : P.ker = RingHom.ker (aeval P.val) := by\n  simp only [ker, Extension.ker, toExtension_Ring, algebraMap_eq]\n  rfl\n\n"}
{"name":"Algebra.Generators.aeval_val_eq_zero","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Generators R S\nx : P.Ring\nhx : Membership.mem P.ker x\n⊢ Eq ((MvPolynomial.aeval P.val) x) 0","decl":"variable {P} in\nlemma aeval_val_eq_zero {x} (hx : x ∈ P.ker) : aeval P.val x = 0 := by rwa [← algebraMap_apply]\n\n"}
{"name":"Algebra.Generators.map_toComp_ker","module":"Mathlib.RingTheory.Generators","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_2\ninst✝³ : CommRing T\ninst✝² : Algebra R T\ninst✝¹ : Algebra S T\ninst✝ : IsScalarTower R S T\nQ : Algebra.Generators S T\nP : Algebra.Generators R S\n⊢ Eq (Ideal.map (Q.toComp P).toAlgHom.toRingHom P.ker) (RingHom.ker (Q.ofComp P).toAlgHom)","decl":"lemma map_toComp_ker (Q : Generators S T) (P : Generators R S) :\n    P.ker.map (Q.toComp P).toAlgHom.toRingHom = RingHom.ker (Q.ofComp P).toAlgHom := by\n  letI : DecidableEq (Q.vars →₀ ℕ) := Classical.decEq _\n  apply le_antisymm\n  · rw [Ideal.map_le_iff_le_comap]\n    rintro x (hx : algebraMap P.Ring S x = 0)\n    have : (Q.ofComp P).toAlgHom.comp (Q.toComp P).toAlgHom = IsScalarTower.toAlgHom R _ _ := by\n      ext1; simp\n    simp only [comp_vars, AlgHom.toRingHom_eq_coe, Ideal.mem_comap, RingHom.coe_coe,\n      RingHom.mem_ker, ← AlgHom.comp_apply, this, IsScalarTower.toAlgHom_apply]\n    rw [IsScalarTower.algebraMap_apply P.Ring S, hx, map_zero]\n  · rintro x (h₂ : (Q.ofComp P).toAlgHom x = 0)\n    let e : ((Q.comp P).vars →₀ ℕ) ≃+ (Q.vars →₀ ℕ) × (P.vars →₀ ℕ) :=\n      Finsupp.sumFinsuppAddEquivProdFinsupp\n    suffices ∑ v ∈ (support x).map e, (monomial (e.symm v)) (coeff (e.symm v) x) ∈\n        Ideal.map (Q.toComp P).toAlgHom.toRingHom P.ker by\n      simpa only [AlgHom.toRingHom_eq_coe, Finset.sum_map, Equiv.coe_toEmbedding,\n        EquivLike.coe_coe, AddEquiv.symm_apply_apply, support_sum_monomial_coeff] using this\n    rw [← Finset.sum_fiberwise_of_maps_to (fun i ↦ Finset.mem_image_of_mem Prod.fst)]\n    refine sum_mem fun i hi ↦ ?_\n    convert_to monomial (e.symm (i, 0)) 1 * (Q.toComp P).toAlgHom.toRingHom\n      (∑ j ∈ ((support x).map e.toEmbedding).filter (fun x ↦ x.1 = i),\n        monomial j.2 (coeff (e.symm j) x)) ∈ _\n    · rw [map_sum, Finset.mul_sum]\n      refine Finset.sum_congr rfl fun j hj ↦ ?_\n      obtain rfl := (Finset.mem_filter.mp hj).2\n      obtain ⟨i, j⟩ := j\n      clear hj hi\n      have : (Q.toComp P).toAlgHom (monomial j (coeff (e.symm (i, j)) x)) =\n          monomial (e.symm (0, j)) (coeff (e.symm (i, j)) x) :=\n        toComp_toAlgHom_monomial ..\n      simp only [AlgHom.toRingHom_eq_coe, monomial_zero', RingHom.coe_coe, algHom_C,\n          MvPolynomial.algebraMap_eq, this]\n      rw [monomial_mul, ← map_add, Prod.mk_add_mk, add_zero, zero_add, one_mul]\n    · apply Ideal.mul_mem_left\n      refine Ideal.mem_map_of_mem _ ?_\n      simp only [ker_eq_ker_aeval_val, AddEquiv.toEquiv_eq_coe, RingHom.mem_ker, map_sum]\n      rw [← coeff_zero i, ← h₂]\n      clear h₂ hi\n      have (x : (Q.comp P).Ring) : (Function.support fun a ↦ if a.1 = i then aeval P.val\n          (monomial a.2 (coeff (e.symm a) x)) else 0) ⊆ ((support x).map e).toSet := by\n        rw [← Set.compl_subset_compl]\n        intro j\n        obtain ⟨j, rfl⟩ := e.surjective j\n        simp_all\n      rw [Finset.sum_filter, ← finsum_eq_sum_of_support_subset _ (this x)]\n      induction x using MvPolynomial.induction_on' with\n      | h1 v a =>\n        rw [finsum_eq_sum_of_support_subset _ (this _), ← Finset.sum_filter]\n        obtain ⟨v, rfl⟩ := e.symm.surjective v\n        erw [ofComp_toAlgHom_monomial_sumElim]\n        classical\n        simp only [comp_vars, coeff_monomial, ← e.injective.eq_iff,\n          map_zero, AddEquiv.apply_symm_apply, apply_ite]\n        rw [← apply_ite, Finset.sum_ite_eq]\n        simp only [Finset.mem_filter, Finset.mem_map_equiv, AddEquiv.coe_toEquiv_symm, comp_vars,\n          mem_support_iff, coeff_monomial, ↓reduceIte, ne_eq, ite_and, ite_not]\n        split\n        · simp only [zero_smul, coeff_zero, *, map_zero, ite_self]\n        · congr\n      | h2 p q hp hq =>\n        simp only [coeff_add, map_add, ite_add_zero]\n        rw [finsum_add_distrib, hp, hq]\n        · refine (((support p).map e).finite_toSet.subset ?_)\n          convert this p\n        · refine (((support q).map e).finite_toSet.subset ?_)\n          convert this q\n\n"}
