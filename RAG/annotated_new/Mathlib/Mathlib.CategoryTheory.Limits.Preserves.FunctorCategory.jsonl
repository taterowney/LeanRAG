{"name":"CategoryTheory.FunctorCategory.prod_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u\ninstâœâ´ : CategoryTheory.Category.{vâ‚, u} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{u, uâ‚‚} D\ninstâœÂ² : CategoryTheory.Limits.HasBinaryProducts D\ninstâœÂ¹ : CategoryTheory.Limits.HasColimits D\ninstâœ : âˆ€ (X : D), CategoryTheory.Limits.PreservesColimits (CategoryTheory.Limits.prod.functor.obj X)\nF : CategoryTheory.Functor C D\nâŠ¢ CategoryTheory.Limits.PreservesColimits (CategoryTheory.Limits.prod.functor.obj F)","decl":"/-- If `X Ã— -` preserves colimits in `D` for any `X : D`, then the product functor `F â¨¯ -` for\n`F : C â¥¤ D` also preserves colimits.\n\nNote this is (mathematically) a special case of the statement that\n\"if limits commute with colimits in `D`, then they do as well in `C â¥¤ D`\"\nbut the story in Lean is a bit more complex, and this statement isn't directly a special case.\nThat is, even with a formalised proof of the general statement, there would still need to be some\nwork to convert to this version: namely, the natural isomorphism\n`(evaluation C D).obj k â‹™ prod.functor.obj (F.obj k) â‰…\n  prod.functor.obj F â‹™ (evaluation C D).obj k`\n-/\nlemma FunctorCategory.prod_preservesColimits [HasBinaryProducts D] [HasColimits D]\n    [âˆ€ X : D, PreservesColimits (prod.functor.obj X)] (F : C â¥¤ D) :\n    PreservesColimits (prod.functor.obj F) where\n  preservesColimitsOfShape {J : Type u} [Category.{u, u} J] :=\n    {\n      preservesColimit := fun {K : J â¥¤ C â¥¤ D} => ({\n          preserves := fun {c : Cocone K} (t : IsColimit c) => âŸ¨by\n            apply evaluationJointlyReflectsColimits _ fun {k} => ?_\n            change IsColimit ((prod.functor.obj F â‹™ (evaluation _ _).obj k).mapCocone c)\n            let this :=\n              isColimitOfPreserves ((evaluation C D).obj k â‹™ prod.functor.obj (F.obj k)) t\n            apply IsColimit.mapCoconeEquiv _ this\n            apply (NatIso.ofComponents _ _).symm\n            Â· intro G\n              apply asIso (prodComparison ((evaluation C D).obj k) F G)\n            Â· intro G G'\n              apply prodComparison_natural ((evaluation C D).obj k) (ğŸ™ F)âŸ© } ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor C E\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape J ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesLimitsOfShape (J : Type u) [Category.{v} J]\n    [HasLimitsOfShape J D] (F : C â¥¤ E) :\n    PreservesLimitsOfShape J ((whiskeringLeft C E D).obj F) :=\n  âŸ¨fun {K} =>\n    âŸ¨fun c {hc} => âŸ¨by\n      apply evaluationJointlyReflectsLimits\n      intro Y\n      change IsLimit (((evaluation E D).obj (F.obj Y)).mapCone c)\n      exact isLimitOfPreserves _ hcâŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type uâ‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ² : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\nJ : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} J\ninstâœ : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor C E\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape J ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesColimitsOfShape (J : Type u) [Category.{v} J]\n    [HasColimitsOfShape J D] (F : C â¥¤ E) :\n    PreservesColimitsOfShape J ((whiskeringLeft C E D).obj F) :=\n  âŸ¨fun {K} =>\n    âŸ¨fun c {hc} => âŸ¨by\n      apply evaluationJointlyReflectsColimits\n      intro Y\n      change IsColimit (((evaluation E D).obj (F.obj Y)).mapCocone c)\n      exact isColimitOfPreserves _ hcâŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C E\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', max uâ‚ƒ vâ‚‚, max uâ‚ vâ‚‚, max (max (max uâ‚‚ uâ‚ƒ) vâ‚‚) vâ‚ƒ, max (max (max uâ‚ uâ‚‚) vâ‚) vâ‚‚} ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesLimits [HasLimitsOfSize.{w, w'} D] (F : C â¥¤ E) :\n    PreservesLimitsOfSize.{w, w'} ((whiskeringLeft C E D).obj F) :=\n  âŸ¨fun {J} _ => whiskeringLeft_preservesLimitsOfShape J FâŸ©\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type uâ‚\ninstâœÂ³ : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type uâ‚‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚‚, uâ‚‚} D\nE : Type uâ‚ƒ\ninstâœÂ¹ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} E\ninstâœ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', vâ‚‚, uâ‚‚} D\nF : CategoryTheory.Functor C E\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', max uâ‚ƒ vâ‚‚, max uâ‚ vâ‚‚, max (max (max uâ‚‚ uâ‚ƒ) vâ‚‚) vâ‚ƒ, max (max (max uâ‚ uâ‚‚) vâ‚) vâ‚‚} ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesColimit [HasColimitsOfSize.{w, w'} D] (F : C â¥¤ E) :\n    PreservesColimitsOfSize.{w, w'} ((whiskeringLeft C E D).obj F) :=\n  âŸ¨fun {J} _ => whiskeringLeft_preservesColimitsOfShape J FâŸ©\n\n"}
{"name":"CategoryTheory.whiskeringRight_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J F\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape J ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRight_preservesLimitsOfShape {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D â¥¤ E) [PreservesLimitsOfShape J F] :\n    PreservesLimitsOfShape J ((whiskeringRight C D E).obj F) :=\n  âŸ¨fun {K} =>\n    âŸ¨fun c {hc} => âŸ¨by\n      apply evaluationJointlyReflectsLimits _ (fun k => ?_)\n      change IsLimit (((evaluation _ _).obj k â‹™ F).mapCone c)\n      exact isLimitOfPreserves _ hcâŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_inv_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (((CategoryTheory.whiskeringRight C D E).obj F).obj (G.obj j)) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.Ï€ G j) F) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_inv_Ï€ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D â¥¤ E) [PreservesLimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).inv â‰«\n      limit.Ï€ (G â‹™ (whiskeringRight _ _ _).obj F) j = whiskerRight (limit.Ï€ G j) F := by\n  simp [limitCompWhiskeringRightIsoLimitComp]\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_inv_Ï€","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).inv (CategoryTheory.Limits.limit.Ï€ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j)) (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.Ï€ G j) F)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_inv_Ï€ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D â¥¤ E) [PreservesLimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).inv â‰«\n      limit.Ï€ (G â‹™ (whiskeringRight _ _ _).obj F) j = whiskerRight (limit.Ï€ G j) F := by\n  simp [limitCompWhiskeringRightIsoLimitComp]\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_Ï€","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).hom (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.Ï€ G j) F)) (CategoryTheory.Limits.limit.Ï€ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_Ï€ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D â¥¤ E) [PreservesLimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).hom â‰« whiskerRight (limit.Ï€ G j) F =\n      limit.Ï€ (G â‹™ (whiskeringRight _ _ _).obj F) j := by\n  simp [â† Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_Ï€_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom ((G.obj j).comp F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.Ï€ G j) F) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.Ï€ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_Ï€ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D â¥¤ E) [PreservesLimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).hom â‰« whiskerRight (limit.Ï€ G j) F =\n      limit.Ï€ (G â‹™ (whiskeringRight _ _ _).obj F) j := by\n  simp [â† Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.whiskeringRight_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape J F\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape J ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRight_preservesColimitsOfShape {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D â¥¤ E) [PreservesColimitsOfShape J F] :\n    PreservesColimitsOfShape J ((whiskeringRight C D E).obj F) :=\n  âŸ¨fun {K} =>\n    âŸ¨fun c {hc} => âŸ¨by\n      apply evaluationJointlyReflectsColimits _ (fun k => ?_)\n      change IsColimit (((evaluation _ _).obj k â‹™ F).mapCocone c)\n      exact isColimitOfPreserves _ hcâŸ©âŸ©âŸ©\n\n"}
{"name":"CategoryTheory.Î¹_colimitCompWhiskeringRightIsoColimitComp_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom ((CategoryTheory.Limits.colimit G).comp F) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Î¹ G j) F) h)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitCompWhiskeringRightIsoColimitComp_hom {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D â¥¤ E) [PreservesColimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    colimit.Î¹ (G â‹™ (whiskeringRight _ _ _).obj F) j â‰«\n      (colimitCompWhiskeringRightIsoColimitComp F G).hom = whiskerRight (colimit.Î¹ G j) F := by\n  simp [colimitCompWhiskeringRightIsoColimitComp]\n\n"}
{"name":"CategoryTheory.Î¹_colimitCompWhiskeringRightIsoColimitComp_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).hom) (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Î¹ G j) F)","decl":"@[reassoc (attr := simp)]\ntheorem Î¹_colimitCompWhiskeringRightIsoColimitComp_hom {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D â¥¤ E) [PreservesColimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    colimit.Î¹ (G â‹™ (whiskeringRight _ _ _).obj F) j â‰«\n      (colimitCompWhiskeringRightIsoColimitComp F G).hom = whiskerRight (colimit.Î¹ G j) F := by\n  simp [colimitCompWhiskeringRightIsoColimitComp]\n\n"}
{"name":"CategoryTheory.whiskerRight_Î¹_colimitCompWhiskeringRightIsoColimitComp_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (CategoryTheory.Limits.colimit (G.comp ((CategoryTheory.whiskeringRight C D E).obj F))) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Î¹ G j) F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Î¹ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_Î¹_colimitCompWhiskeringRightIsoColimitComp_inv {C : Type*} [Category C]\n    {D : Type*} [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D â¥¤ E) [PreservesColimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    whiskerRight (colimit.Î¹ G j) F â‰« (colimitCompWhiskeringRightIsoColimitComp F G).inv =\n      colimit.Î¹ (G â‹™ (whiskeringRight _ _ _).obj F) j := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.whiskerRight_Î¹_colimitCompWhiskeringRightIsoColimitComp_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninstâœÂ² : CategoryTheory.Category.{u_8, u_4} J\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Î¹ G j) F) (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).inv) (CategoryTheory.Limits.colimit.Î¹ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_Î¹_colimitCompWhiskeringRightIsoColimitComp_inv {C : Type*} [Category C]\n    {D : Type*} [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D â¥¤ E) [PreservesColimitsOfShape J F] (G : J â¥¤ C â¥¤ D) (j : J) :\n    whiskerRight (colimit.Î¹ G j) F â‰« (colimitCompWhiskeringRightIsoColimitComp F G).inv =\n      colimit.Î¹ (G â‹™ (whiskeringRight _ _ _).obj F) j := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.whiskeringRightPreservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\nE : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} E\nF : CategoryTheory.Functor D E\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfSize.{w, w', u_5, u_2} D\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', u_5, u_6, u_2, u_3} F\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', max u_1 u_5, max u_1 u_6, max (max (max u_1 u_2) u_4) u_5, max (max (max u_1 u_3) u_4) u_6} ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRightPreservesLimits {C : Type*} [Category C] {D : Type*} [Category D]\n    {E : Type*} [Category E] (F : D â¥¤ E) [HasLimitsOfSize.{w, w'} D]\n    [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} ((whiskeringRight C D E).obj F) :=\n  âŸ¨inferInstanceâŸ©\n\n"}
{"name":"CategoryTheory.whiskeringRightPreservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninstâœâ´ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_5, u_2} D\nE : Type u_3\ninstâœÂ² : CategoryTheory.Category.{u_6, u_3} E\nF : CategoryTheory.Functor D E\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfSize.{w, w', u_5, u_2} D\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', u_5, u_6, u_2, u_3} F\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', max u_1 u_5, max u_1 u_6, max (max (max u_1 u_2) u_4) u_5, max (max (max u_1 u_3) u_4) u_6} ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRightPreservesColimits {C : Type*} [Category C] {D : Type*} [Category D]\n    {E : Type*} [Category E] (F : D â¥¤ E) [HasColimitsOfSize.{w, w'} D]\n    [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} ((whiskeringRight C D E).obj F) :=\n  âŸ¨inferInstanceâŸ©\n\n-- Porting note: fixed spelling mistake in def\n"}
{"name":"CategoryTheory.preservesLimit_of_lan_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C D : Type u\ninstâœÂ³ : CategoryTheory.SmallCategory C\ninstâœÂ² : CategoryTheory.SmallCategory D\nF : CategoryTheory.Functor C D\nJ : Type u\ninstâœÂ¹ : CategoryTheory.SmallCategory J\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J F.op.lan\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- If `Lan F.op : (Cáµ’áµ– â¥¤ Type*) â¥¤ (Dáµ’áµ– â¥¤ Type*)` preserves limits of shape `J`, so will `F`. -/\nlemma preservesLimit_of_lan_preservesLimit {C D : Type u} [SmallCategory C]\n    [SmallCategory D] (F : C â¥¤ D) (J : Type u) [SmallCategory J]\n    [PreservesLimitsOfShape J (F.op.lan : _ â¥¤ Dáµ’áµ– â¥¤ Type u)] : PreservesLimitsOfShape J F := by\n  apply @preservesLimitsOfShape_of_reflects_of_preserves _ _ _ _ _ _ _ _ F yoneda ?_\n  exact preservesLimitsOfShape_of_natIso (Presheaf.compYonedaIsoYonedaCompLan F).symm\n\n"}
{"name":"CategoryTheory.preservesFiniteLimits_of_evaluation","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} D\nE : Type u_2\ninstâœ : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nh : âˆ€ (d : D), CategoryTheory.Limits.PreservesFiniteLimits (F.comp ((CategoryTheory.evaluation D E).obj d))\nâŠ¢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- `F : C â¥¤ D â¥¤ E` preserves finite limits if it does for each `d : D`. -/\nlemma preservesFiniteLimits_of_evaluation {D : Type*} [Category D] {E : Type*} [Category E]\n    (F : C â¥¤ D â¥¤ E) (h : âˆ€ d : D, PreservesFiniteLimits (F â‹™ (evaluation D E).obj d)) :\n    PreservesFiniteLimits F :=\n  âŸ¨fun J _ _ => preservesLimitsOfShape_of_evaluation F J fun k => (h k).preservesFiniteLimits _âŸ©\n\n"}
{"name":"CategoryTheory.preservesFiniteColimits_of_evaluation","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type uâ‚\ninstâœÂ² : CategoryTheory.Category.{vâ‚, uâ‚} C\nD : Type u_1\ninstâœÂ¹ : CategoryTheory.Category.{u_3, u_1} D\nE : Type u_2\ninstâœ : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nh : âˆ€ (d : D), CategoryTheory.Limits.PreservesFiniteColimits (F.comp ((CategoryTheory.evaluation D E).obj d))\nâŠ¢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- `F : C â¥¤ D â¥¤ E` preserves finite limits if it does for each `d : D`. -/\nlemma preservesFiniteColimits_of_evaluation {D : Type*} [Category D] {E : Type*} [Category E]\n    (F : C â¥¤ D â¥¤ E) (h : âˆ€ d : D, PreservesFiniteColimits (F â‹™ (evaluation D E).obj d)) :\n    PreservesFiniteColimits F :=\n  âŸ¨fun J _ _ => preservesColimitsOfShape_of_evaluation F J fun k => (h k).preservesFiniteColimits _âŸ©\n\n"}
{"name":"CategoryTheory.instPreservesLimitsOfShapeFunctorColim","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nD : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\ninstâœÂ² : CategoryTheory.Limits.HasLimitsOfShape J C\ninstâœÂ¹ : CategoryTheory.Limits.HasColimitsOfShape K C\ninstâœ : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\nâŠ¢ CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim","decl":"noncomputable instance : PreservesLimitsOfShape J (colim : (K â¥¤ D â¥¤ C) â¥¤ _) :=\n  preservesLimitsOfShape_of_evaluation _ _ (fun d =>\n    let i : (colim : (K â¥¤ D â¥¤ C) â¥¤ _) â‹™ (evaluation D C).obj d â‰…\n        colimit ((whiskeringRight K (D â¥¤ C) C).obj ((evaluation D C).obj d)).flip :=\n      NatIso.ofComponents (fun X => (colimitObjIsoColimitCompEvaluation _ _) â‰ªâ‰«\n          (by exact HasColimit.isoOfNatIso (Iso.refl _)) â‰ªâ‰«\n          (colimitObjIsoColimitCompEvaluation _ _).symm)\n        (fun {F G} Î· => colimit_obj_ext (fun j => by simp [â† NatTrans.comp_app_assoc]))\n    preservesLimitsOfShape_of_natIso (i â‰ªâ‰« colimitFlipIsoCompColim _).symm)\n\n"}
{"name":"CategoryTheory.instPreservesColimitsOfShapeFunctorLim","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u\ninstâœâ¶ : CategoryTheory.Category.{v, u} C\nJ : Type uâ‚\ninstâœâµ : CategoryTheory.Category.{vâ‚, uâ‚} J\nK : Type uâ‚‚\ninstâœâ´ : CategoryTheory.Category.{vâ‚‚, uâ‚‚} K\nD : Type uâ‚ƒ\ninstâœÂ³ : CategoryTheory.Category.{vâ‚ƒ, uâ‚ƒ} D\ninstâœÂ² : CategoryTheory.Limits.HasColimitsOfShape J C\ninstâœÂ¹ : CategoryTheory.Limits.HasLimitsOfShape K C\ninstâœ : CategoryTheory.Limits.PreservesColimitsOfShape J CategoryTheory.Limits.lim\nâŠ¢ CategoryTheory.Limits.PreservesColimitsOfShape J CategoryTheory.Limits.lim","decl":"noncomputable instance : PreservesColimitsOfShape J (lim : (K â¥¤ D â¥¤ C) â¥¤ _) :=\n  preservesColimitsOfShape_of_evaluation _ _ (fun d =>\n    let i : (lim : (K â¥¤ D â¥¤ C) â¥¤ _) â‹™ (evaluation D C).obj d â‰…\n        limit ((whiskeringRight K (D â¥¤ C) C).obj ((evaluation D C).obj d)).flip :=\n      NatIso.ofComponents (fun X => (limitObjIsoLimitCompEvaluation _ _) â‰ªâ‰«\n          (by exact HasLimit.isoOfNatIso (Iso.refl _)) â‰ªâ‰«\n          (limitObjIsoLimitCompEvaluation _ _).symm)\n        (fun {F G} Î· => limit_obj_ext (fun j => by simp [â† NatTrans.comp_app]))\n    preservesColimitsOfShape_of_natIso (i â‰ªâ‰« limitFlipIsoCompLim _).symm)\n\n"}
