{"name":"CategoryTheory.FunctorCategory.prod_preservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{u, u‚ÇÇ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryProducts D\ninst‚úù¬π : CategoryTheory.Limits.HasColimits D\ninst‚úù : ‚àÄ (X : D), CategoryTheory.Limits.PreservesColimits (CategoryTheory.Limits.prod.functor.obj X)\nF : CategoryTheory.Functor C D\n‚ä¢ CategoryTheory.Limits.PreservesColimits (CategoryTheory.Limits.prod.functor.obj F)","decl":"/-- If `X √ó -` preserves colimits in `D` for any `X : D`, then the product functor `F ‚®Ø -` for\n`F : C ‚•§ D` also preserves colimits.\n\nNote this is (mathematically) a special case of the statement that\n\"if limits commute with colimits in `D`, then they do as well in `C ‚•§ D`\"\nbut the story in Lean is a bit more complex, and this statement isn't directly a special case.\nThat is, even with a formalised proof of the general statement, there would still need to be some\nwork to convert to this version: namely, the natural isomorphism\n`(evaluation C D).obj k ‚ãô prod.functor.obj (F.obj k) ‚âÖ\n  prod.functor.obj F ‚ãô (evaluation C D).obj k`\n-/\nlemma FunctorCategory.prod_preservesColimits [HasBinaryProducts D] [HasColimits D]\n    [‚àÄ X : D, PreservesColimits (prod.functor.obj X)] (F : C ‚•§ D) :\n    PreservesColimits (prod.functor.obj F) where\n  preservesColimitsOfShape {J : Type u} [Category.{u, u} J] :=\n    {\n      preservesColimit := fun {K : J ‚•§ C ‚•§ D} => ({\n          preserves := fun {c : Cocone K} (t : IsColimit c) => ‚ü®by\n            apply evaluationJointlyReflectsColimits _ fun {k} => ?_\n            change IsColimit ((prod.functor.obj F ‚ãô (evaluation _ _).obj k).mapCocone c)\n            let this :=\n              isColimitOfPreserves ((evaluation C D).obj k ‚ãô prod.functor.obj (F.obj k)) t\n            apply IsColimit.mapCoconeEquiv _ this\n            apply (NatIso.ofComponents _ _).symm\n            ¬∑ intro G\n              apply asIso (prodComparison ((evaluation C D).obj k) F G)\n            ¬∑ intro G G'\n              apply prodComparison_natural ((evaluation C D).obj k) (ùüô F)‚ü© } ) }\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor C E\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesLimitsOfShape (J : Type u) [Category.{v} J]\n    [HasLimitsOfShape J D] (F : C ‚•§ E) :\n    PreservesLimitsOfShape J ((whiskeringLeft C E D).obj F) :=\n  ‚ü®fun {K} =>\n    ‚ü®fun c {hc} => ‚ü®by\n      apply evaluationJointlyReflectsLimits\n      intro Y\n      change IsLimit (((evaluation E D).obj (F.obj Y)).mapCone c)\n      exact isLimitOfPreserves _ hc‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nJ : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} J\ninst‚úù : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor C E\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesColimitsOfShape (J : Type u) [Category.{v} J]\n    [HasColimitsOfShape J D] (F : C ‚•§ E) :\n    PreservesColimitsOfShape J ((whiskeringLeft C E D).obj F) :=\n  ‚ü®fun {K} =>\n    ‚ü®fun c {hc} => ‚ü®by\n      apply evaluationJointlyReflectsColimits\n      intro Y\n      change IsColimit (((evaluation E D).obj (F.obj Y)).mapCocone c)\n      exact isColimitOfPreserves _ hc‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Limits.HasLimitsOfSize.{w, w', v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C E\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', max u‚ÇÉ v‚ÇÇ, max u‚ÇÅ v‚ÇÇ, max (max (max u‚ÇÇ u‚ÇÉ) v‚ÇÇ) v‚ÇÉ, max (max (max u‚ÇÅ u‚ÇÇ) v‚ÇÅ) v‚ÇÇ} ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesLimits [HasLimitsOfSize.{w, w'} D] (F : C ‚•§ E) :\n    PreservesLimitsOfSize.{w, w'} ((whiskeringLeft C E D).obj F) :=\n  ‚ü®fun {J} _ => whiskeringLeft_preservesLimitsOfShape J F‚ü©\n\n"}
{"name":"CategoryTheory.whiskeringLeft_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ninst‚úù : CategoryTheory.Limits.HasColimitsOfSize.{w, w', v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C E\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', max u‚ÇÉ v‚ÇÇ, max u‚ÇÅ v‚ÇÇ, max (max (max u‚ÇÇ u‚ÇÉ) v‚ÇÇ) v‚ÇÉ, max (max (max u‚ÇÅ u‚ÇÇ) v‚ÇÅ) v‚ÇÇ} ((CategoryTheory.whiskeringLeft C E D).obj F)","decl":"instance whiskeringLeft_preservesColimit [HasColimitsOfSize.{w, w'} D] (F : C ‚•§ E) :\n    PreservesColimitsOfSize.{w, w'} ((whiskeringLeft C E D).obj F) :=\n  ‚ü®fun {J} _ => whiskeringLeft_preservesColimitsOfShape J F‚ü©\n\n"}
{"name":"CategoryTheory.whiskeringRight_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRight_preservesLimitsOfShape {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D ‚•§ E) [PreservesLimitsOfShape J F] :\n    PreservesLimitsOfShape J ((whiskeringRight C D E).obj F) :=\n  ‚ü®fun {K} =>\n    ‚ü®fun c {hc} => ‚ü®by\n      apply evaluationJointlyReflectsLimits _ (fun k => ?_)\n      change IsLimit (((evaluation _ _).obj k ‚ãô F).mapCone c)\n      exact isLimitOfPreserves _ hc‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_inv_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (((CategoryTheory.whiskeringRight C D E).obj F).obj (G.obj j)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.œÄ G j) F) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_inv_œÄ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D ‚•§ E) [PreservesLimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).inv ‚â´\n      limit.œÄ (G ‚ãô (whiskeringRight _ _ _).obj F) j = whiskerRight (limit.œÄ G j) F := by\n  simp [limitCompWhiskeringRightIsoLimitComp]\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_inv_œÄ","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).inv (CategoryTheory.Limits.limit.œÄ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j)) (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.œÄ G j) F)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_inv_œÄ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D ‚•§ E) [PreservesLimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).inv ‚â´\n      limit.œÄ (G ‚ãô (whiskeringRight _ _ _).obj F) j = whiskerRight (limit.œÄ G j) F := by\n  simp [limitCompWhiskeringRightIsoLimitComp]\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_œÄ","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).hom (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.œÄ G j) F)) (CategoryTheory.Limits.limit.œÄ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_œÄ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D ‚•§ E) [PreservesLimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).hom ‚â´ whiskerRight (limit.œÄ G j) F =\n      limit.œÄ (G ‚ãô (whiskeringRight _ _ _).obj F) j := by\n  simp [‚Üê Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_œÄ_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom ((G.obj j).comp F) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.limitCompWhiskeringRightIsoLimitComp F G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.limit.œÄ G j) F) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.œÄ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringRightIsoLimitComp_hom_whiskerRight_œÄ {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasLimitsOfShape J D] (F : D ‚•§ E) [PreservesLimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    (limitCompWhiskeringRightIsoLimitComp F G).hom ‚â´ whiskerRight (limit.œÄ G j) F =\n      limit.œÄ (G ‚ãô (whiskeringRight _ _ _).obj F) j := by\n  simp [‚Üê Iso.eq_inv_comp]\n\n"}
{"name":"CategoryTheory.whiskeringRight_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRight_preservesColimitsOfShape {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D ‚•§ E) [PreservesColimitsOfShape J F] :\n    PreservesColimitsOfShape J ((whiskeringRight C D E).obj F) :=\n  ‚ü®fun {K} =>\n    ‚ü®fun c {hc} => ‚ü®by\n      apply evaluationJointlyReflectsColimits _ (fun k => ?_)\n      change IsColimit (((evaluation _ _).obj k ‚ãô F).mapCocone c)\n      exact isColimitOfPreserves _ hc‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Œπ_colimitCompWhiskeringRightIsoColimitComp_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom ((CategoryTheory.Limits.colimit G).comp F) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Œπ G j) F) h)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_colimitCompWhiskeringRightIsoColimitComp_hom {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D ‚•§ E) [PreservesColimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    colimit.Œπ (G ‚ãô (whiskeringRight _ _ _).obj F) j ‚â´\n      (colimitCompWhiskeringRightIsoColimitComp F G).hom = whiskerRight (colimit.Œπ G j) F := by\n  simp [colimitCompWhiskeringRightIsoColimitComp]\n\n"}
{"name":"CategoryTheory.Œπ_colimitCompWhiskeringRightIsoColimitComp_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).hom) (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Œπ G j) F)","decl":"@[reassoc (attr := simp)]\ntheorem Œπ_colimitCompWhiskeringRightIsoColimitComp_hom {C : Type*} [Category C] {D : Type*}\n    [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D ‚•§ E) [PreservesColimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    colimit.Œπ (G ‚ãô (whiskeringRight _ _ _).obj F) j ‚â´\n      (colimitCompWhiskeringRightIsoColimitComp F G).hom = whiskerRight (colimit.Œπ G j) F := by\n  simp [colimitCompWhiskeringRightIsoColimitComp]\n\n"}
{"name":"CategoryTheory.whiskerRight_Œπ_colimitCompWhiskeringRightIsoColimitComp_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\nZ : CategoryTheory.Functor C E\nh : Quiver.Hom (CategoryTheory.Limits.colimit (G.comp ((CategoryTheory.whiskeringRight C D E).obj F))) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Œπ G j) F) (CategoryTheory.CategoryStruct.comp (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.Œπ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_Œπ_colimitCompWhiskeringRightIsoColimitComp_inv {C : Type*} [Category C]\n    {D : Type*} [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D ‚•§ E) [PreservesColimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    whiskerRight (colimit.Œπ G j) F ‚â´ (colimitCompWhiskeringRightIsoColimitComp F G).inv =\n      colimit.Œπ (G ‚ãô (whiskeringRight _ _ _).obj F) j := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.whiskerRight_Œπ_colimitCompWhiskeringRightIsoColimitComp_inv","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Åµ : CategoryTheory.Category.{u_5, u_1} C\nD : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_6, u_2} D\nE : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_7, u_3} E\nJ : Type u_4\ninst‚úù¬≤ : CategoryTheory.Category.{u_8, u_4} J\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape J D\nF : CategoryTheory.Functor D E\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J F\nG : CategoryTheory.Functor J (CategoryTheory.Functor C D)\nj : J\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (CategoryTheory.Limits.colimit.Œπ G j) F) (CategoryTheory.colimitCompWhiskeringRightIsoColimitComp F G).inv) (CategoryTheory.Limits.colimit.Œπ (G.comp ((CategoryTheory.whiskeringRight C D E).obj F)) j)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerRight_Œπ_colimitCompWhiskeringRightIsoColimitComp_inv {C : Type*} [Category C]\n    {D : Type*} [Category D] {E : Type*} [Category E] {J : Type*} [Category J]\n    [HasColimitsOfShape J D] (F : D ‚•§ E) [PreservesColimitsOfShape J F] (G : J ‚•§ C ‚•§ D) (j : J) :\n    whiskerRight (colimit.Œπ G j) F ‚â´ (colimitCompWhiskeringRightIsoColimitComp F G).inv =\n      colimit.Œπ (G ‚ãô (whiskeringRight _ _ _).obj F) j := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.whiskeringRightPreservesLimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nE : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} E\nF : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfSize.{w, w', u_5, u_2} D\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', u_5, u_6, u_2, u_3} F\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfSize.{w, w', max u_1 u_5, max u_1 u_6, max (max (max u_1 u_2) u_4) u_5, max (max (max u_1 u_3) u_4) u_6} ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRightPreservesLimits {C : Type*} [Category C] {D : Type*} [Category D]\n    {E : Type*} [Category E] (F : D ‚•§ E) [HasLimitsOfSize.{w, w'} D]\n    [PreservesLimitsOfSize.{w, w'} F] :\n    PreservesLimitsOfSize.{w, w'} ((whiskeringRight C D E).obj F) :=\n  ‚ü®inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.whiskeringRightPreservesColimits","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u_1\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_1} C\nD : Type u_2\ninst‚úù¬≥ : CategoryTheory.Category.{u_5, u_2} D\nE : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_6, u_3} E\nF : CategoryTheory.Functor D E\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfSize.{w, w', u_5, u_2} D\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', u_5, u_6, u_2, u_3} F\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfSize.{w, w', max u_1 u_5, max u_1 u_6, max (max (max u_1 u_2) u_4) u_5, max (max (max u_1 u_3) u_4) u_6} ((CategoryTheory.whiskeringRight C D E).obj F)","decl":"instance whiskeringRightPreservesColimits {C : Type*} [Category C] {D : Type*} [Category D]\n    {E : Type*} [Category E] (F : D ‚•§ E) [HasColimitsOfSize.{w, w'} D]\n    [PreservesColimitsOfSize.{w, w'} F] :\n    PreservesColimitsOfSize.{w, w'} ((whiskeringRight C D E).obj F) :=\n  ‚ü®inferInstance‚ü©\n\n-- Porting note: fixed spelling mistake in def\n"}
{"name":"CategoryTheory.preservesLimit_of_lan_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C D : Type u\ninst‚úù¬≥ : CategoryTheory.SmallCategory C\ninst‚úù¬≤ : CategoryTheory.SmallCategory D\nF : CategoryTheory.Functor C D\nJ : Type u\ninst‚úù¬π : CategoryTheory.SmallCategory J\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J F.op.lan\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- If `Lan F.op : (C·µí·µñ ‚•§ Type*) ‚•§ (D·µí·µñ ‚•§ Type*)` preserves limits of shape `J`, so will `F`. -/\nlemma preservesLimit_of_lan_preservesLimit {C D : Type u} [SmallCategory C]\n    [SmallCategory D] (F : C ‚•§ D) (J : Type u) [SmallCategory J]\n    [PreservesLimitsOfShape J (F.op.lan : _ ‚•§ D·µí·µñ ‚•§ Type u)] : PreservesLimitsOfShape J F := by\n  apply @preservesLimitsOfShape_of_reflects_of_preserves _ _ _ _ _ _ _ _ F yoneda ?_\n  exact preservesLimitsOfShape_of_natIso (Presheaf.compYonedaIsoYonedaCompLan F).symm\n\n"}
{"name":"CategoryTheory.preservesFiniteLimits_of_evaluation","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\nE : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nh : ‚àÄ (d : D), CategoryTheory.Limits.PreservesFiniteLimits (F.comp ((CategoryTheory.evaluation D E).obj d))\n‚ä¢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- `F : C ‚•§ D ‚•§ E` preserves finite limits if it does for each `d : D`. -/\nlemma preservesFiniteLimits_of_evaluation {D : Type*} [Category D] {E : Type*} [Category E]\n    (F : C ‚•§ D ‚•§ E) (h : ‚àÄ d : D, PreservesFiniteLimits (F ‚ãô (evaluation D E).obj d)) :\n    PreservesFiniteLimits F :=\n  ‚ü®fun J _ _ => preservesLimitsOfShape_of_evaluation F J fun k => (h k).preservesFiniteLimits _‚ü©\n\n"}
{"name":"CategoryTheory.preservesFiniteColimits_of_evaluation","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} D\nE : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} E\nF : CategoryTheory.Functor C (CategoryTheory.Functor D E)\nh : ‚àÄ (d : D), CategoryTheory.Limits.PreservesFiniteColimits (F.comp ((CategoryTheory.evaluation D E).obj d))\n‚ä¢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- `F : C ‚•§ D ‚•§ E` preserves finite limits if it does for each `d : D`. -/\nlemma preservesFiniteColimits_of_evaluation {D : Type*} [Category D] {E : Type*} [Category E]\n    (F : C ‚•§ D ‚•§ E) (h : ‚àÄ d : D, PreservesFiniteColimits (F ‚ãô (evaluation D E).obj d)) :\n    PreservesFiniteColimits F :=\n  ‚ü®fun J _ _ => preservesColimitsOfShape_of_evaluation F J fun k => (h k).preservesFiniteColimits _‚ü©\n\n"}
{"name":"CategoryTheory.instPreservesLimitsOfShapeFunctorColim","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nD : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasLimitsOfShape J C\ninst‚úù¬π : CategoryTheory.Limits.HasColimitsOfShape K C\ninst‚úù : CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim\n‚ä¢ CategoryTheory.Limits.PreservesLimitsOfShape J CategoryTheory.Limits.colim","decl":"noncomputable instance : PreservesLimitsOfShape J (colim : (K ‚•§ D ‚•§ C) ‚•§ _) :=\n  preservesLimitsOfShape_of_evaluation _ _ (fun d =>\n    let i : (colim : (K ‚•§ D ‚•§ C) ‚•§ _) ‚ãô (evaluation D C).obj d ‚âÖ\n        colimit ((whiskeringRight K (D ‚•§ C) C).obj ((evaluation D C).obj d)).flip :=\n      NatIso.ofComponents (fun X => (colimitObjIsoColimitCompEvaluation _ _) ‚â™‚â´\n          (by exact HasColimit.isoOfNatIso (Iso.refl _)) ‚â™‚â´\n          (colimitObjIsoColimitCompEvaluation _ _).symm)\n        (fun {F G} Œ∑ => colimit_obj_ext (fun j => by simp [‚Üê NatTrans.comp_app_assoc]))\n    preservesLimitsOfShape_of_natIso (i ‚â™‚â´ colimitFlipIsoCompColim _).symm)\n\n"}
{"name":"CategoryTheory.instPreservesColimitsOfShapeFunctorLim","module":"Mathlib.CategoryTheory.Limits.Preserves.FunctorCategory","initialProofState":"C : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} C\nJ : Type u‚ÇÅ\ninst‚úù‚Åµ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} J\nK : Type u‚ÇÇ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} K\nD : Type u‚ÇÉ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} D\ninst‚úù¬≤ : CategoryTheory.Limits.HasColimitsOfShape J C\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape K C\ninst‚úù : CategoryTheory.Limits.PreservesColimitsOfShape J CategoryTheory.Limits.lim\n‚ä¢ CategoryTheory.Limits.PreservesColimitsOfShape J CategoryTheory.Limits.lim","decl":"noncomputable instance : PreservesColimitsOfShape J (lim : (K ‚•§ D ‚•§ C) ‚•§ _) :=\n  preservesColimitsOfShape_of_evaluation _ _ (fun d =>\n    let i : (lim : (K ‚•§ D ‚•§ C) ‚•§ _) ‚ãô (evaluation D C).obj d ‚âÖ\n        limit ((whiskeringRight K (D ‚•§ C) C).obj ((evaluation D C).obj d)).flip :=\n      NatIso.ofComponents (fun X => (limitObjIsoLimitCompEvaluation _ _) ‚â™‚â´\n          (by exact HasLimit.isoOfNatIso (Iso.refl _)) ‚â™‚â´\n          (limitObjIsoLimitCompEvaluation _ _).symm)\n        (fun {F G} Œ∑ => limit_obj_ext (fun j => by simp [‚Üê NatTrans.comp_app]))\n    preservesColimitsOfShape_of_natIso (i ‚â™‚â´ limitFlipIsoCompLim _).symm)\n\n"}
