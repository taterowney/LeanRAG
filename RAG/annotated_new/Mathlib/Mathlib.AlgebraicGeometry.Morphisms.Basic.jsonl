{"name":"AlgebraicGeometry.IsLocalAtTarget.iff_of_openCover'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\n‚ä¢ Iff (P f) (‚àÄ (i : ùí∞.1), P (AlgebraicGeometry.Scheme.Cover.pullbackHom ùí∞ f i))","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the target if\n1. `P` respects isomorphisms.\n2. `P` holds for `f ‚à£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`.\nAlso see `IsLocalAtTarget.mk'` for a convenient constructor.\n-/\nclass IsLocalAtTarget (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f ‚à£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y),\n      P f ‚Üî ‚àÄ i, P (ùí∞.pullbackHom f i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtTarget P\n‚ä¢ P.RespectsIso","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the target if\n1. `P` respects isomorphisms.\n2. `P` holds for `f ‚à£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`.\nAlso see `IsLocalAtTarget.mk'` for a convenient constructor.\n-/\nclass IsLocalAtTarget (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f ‚à£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} Y),\n      P f ‚Üî ‚àÄ i, P (ùí∞.pullbackHom f i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.mk'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : P.RespectsIso\nrestrict : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) (U : Y.Opens), P f ‚Üí P (AlgebraicGeometry.morphismRestrict f U)\nof_sSup_eq_top : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) {Œπ : Type u} (U : Œπ ‚Üí Y.Opens), Eq (iSup U) Top.top ‚Üí (‚àÄ (i : Œπ), P (AlgebraicGeometry.morphismRestrict f (U i))) ‚Üí P f\n‚ä¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"/--\n`P` is local at the target if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.\n3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.\n-/\nprotected lemma mk' {P : MorphismProperty Scheme} [P.RespectsIso]\n    (restrict : ‚àÄ {X Y : Scheme} (f : X ‚ü∂ Y) (U : Y.Opens), P f ‚Üí P (f ‚à£_ U))\n    (of_sSup_eq_top :\n      ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {Œπ : Type u} (U : Œπ ‚Üí Y.Opens), iSup U = ‚ä§ ‚Üí\n        (‚àÄ i, P (f ‚à£_ U i)) ‚Üí P f) :\n    IsLocalAtTarget P := by\n  refine ‚ü®inferInstance, fun {X Y} f ùí∞ ‚Ü¶ ‚ü®?_, fun H ‚Ü¶ of_sSup_eq_top f _ ùí∞.iSup_opensRange ?_‚ü©‚ü©\n  ¬∑ exact fun H i ‚Ü¶ (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mp (restrict _ _ H)\n  ¬∑ exact fun i ‚Ü¶ (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr (H i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.inf","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtTarget P\ninst‚úù : AlgebraicGeometry.IsLocalAtTarget Q\n‚ä¢ AlgebraicGeometry.IsLocalAtTarget (Min.min P Q)","decl":"/-- The intersection of two morphism properties that are local at the target is again local at\nthe target. -/\ninstance inf (P Q : MorphismProperty Scheme) [IsLocalAtTarget P] [IsLocalAtTarget Q] :\n    IsLocalAtTarget (P ‚äì Q) where\n  iff_of_openCover' {_ _} f ùí∞ :=\n    ‚ü®fun h i ‚Ü¶ ‚ü®(iff_of_openCover' f ùí∞).mp h.left i, (iff_of_openCover' f ùí∞).mp h.right i‚ü©,\n     fun h ‚Ü¶ ‚ü®(iff_of_openCover' f ùí∞).mpr (fun i ‚Ü¶ (h i).left),\n      (iff_of_openCover' f ùí∞).mpr (fun i ‚Ü¶ (h i).right)‚ü©‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nUX UY : AlgebraicGeometry.Scheme\niY : Quiver.Hom UY Y\ninst‚úù : AlgebraicGeometry.IsOpenImmersion iY\niX : Quiver.Hom UX X\nf' : Quiver.Hom UX UY\nh : CategoryTheory.IsPullback iX f' f iY\nH : P f\n‚ä¢ P f'","decl":"lemma of_isPullback {UX UY : Scheme.{u}} {iY : UY ‚ü∂ Y} [IsOpenImmersion iY]\n    {iX : UX ‚ü∂ X} {f' : UX ‚ü∂ UY} (h : IsPullback iX f' f iY) (H : P f) : P f' := by\n  rw [‚Üê P.cancel_left_of_respectsIso h.isoPullback.inv, h.isoPullback_inv_snd]\n  exact (iff_of_openCover' f (Y.affineCover.add iY)).mp H .none\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.restrict","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : P f\nU : Y.Opens\n‚ä¢ P (AlgebraicGeometry.morphismRestrict f U)","decl":"theorem restrict (hf : P f) (U : Y.Opens) : P (f ‚à£_ U) :=\n  of_isPullback (isPullback_morphismRestrict f U).flip hf\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nŒπ : Sort u_1\nU : Œπ ‚Üí Y.Opens\nhU : Eq (iSup U) Top.top\nH : ‚àÄ (i : Œπ), P (AlgebraicGeometry.morphismRestrict f (U i))\n‚ä¢ P f","decl":"lemma of_iSup_eq_top {Œπ} (U : Œπ ‚Üí Y.Opens) (hU : iSup U = ‚ä§)\n    (H : ‚àÄ i, P (f ‚à£_ U i)) : P f := by\n  refine (IsLocalAtTarget.iff_of_openCover' f\n    (Y.openCoverOfISupEqTop (s := Set.range U) Subtype.val (by ext; simp [‚Üê hU]))).mpr fun i ‚Ü¶ ?_\n  obtain ‚ü®_, i, rfl‚ü© := i\n  refine (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mp ?_\n  show P (f ‚à£_ (U i).Œπ.opensRange)\n  rw [Scheme.Opens.opensRange_Œπ]\n  exact H i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nŒπ : Sort u_1\nU : Œπ ‚Üí Y.Opens\nhU : Eq (iSup U) Top.top\n‚ä¢ Iff (P f) (‚àÄ (i : Œπ), P (AlgebraicGeometry.morphismRestrict f (U i)))","decl":"theorem iff_of_iSup_eq_top {Œπ} (U : Œπ ‚Üí Y.Opens) (hU : iSup U = ‚ä§) :\n    P f ‚Üî ‚àÄ i, P (f ‚à£_ U i) :=\n  ‚ü®fun H _ ‚Ü¶ restrict H _, of_iSup_eq_top U hU‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\nH : ‚àÄ (i : ùí∞.1), P (AlgebraicGeometry.Scheme.Cover.pullbackHom ùí∞ f i)\n‚ä¢ P f","decl":"lemma of_openCover (H : ‚àÄ i, P (ùí∞.pullbackHom f i)) : P f := by\n  apply of_iSup_eq_top (fun i ‚Ü¶ (ùí∞.map i).opensRange) ùí∞.iSup_opensRange\n  exact fun i ‚Ü¶ (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr (H i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.iff_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\n‚ä¢ Iff (P f) (‚àÄ (i : ùí∞.1), P (AlgebraicGeometry.Scheme.Cover.pullbackHom ùí∞ f i))","decl":"theorem iff_of_openCover (ùí∞ : Y.OpenCover) :\n    P f ‚Üî ‚àÄ i, P (ùí∞.pullbackHom f i) :=\n  ‚ü®fun H _ ‚Ü¶ of_isPullback (.of_hasPullback _ _) H, of_openCover _‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtSource P\n‚ä¢ P.RespectsIso","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the source if\n1. `P` respects isomorphisms.\n2. `P` holds for `ùí∞.map i ‚â´ f` for an open cover `ùí∞` of `X` iff `P` holds for `f : X ‚ü∂ Y`.\nAlso see `IsLocalAtSource.mk'` for a convenient constructor.\n-/\nclass IsLocalAtSource (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f ‚à£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} X),\n      P f ‚Üî ‚àÄ i, P (ùí∞.map i ‚â´ f)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_of_openCover'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : X.OpenCover\n‚ä¢ Iff (P f) (‚àÄ (i : ùí∞.J), P (CategoryTheory.CategoryStruct.comp (ùí∞.map i) f))","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the source if\n1. `P` respects isomorphisms.\n2. `P` holds for `ùí∞.map i ‚â´ f` for an open cover `ùí∞` of `X` iff `P` holds for `f : X ‚ü∂ Y`.\nAlso see `IsLocalAtSource.mk'` for a convenient constructor.\n-/\nclass IsLocalAtSource (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f ‚à£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) (ùí∞ : Scheme.OpenCover.{u} X),\n      P f ‚Üî ‚àÄ i, P (ùí∞.map i ‚â´ f)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.mk'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : P.RespectsIso\nrestrict : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) (U : X.Opens), P f ‚Üí P (CategoryTheory.CategoryStruct.comp U.Œπ f)\nof_sSup_eq_top : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) {Œπ : Type u} (U : Œπ ‚Üí X.Opens), Eq (iSup U) Top.top ‚Üí (‚àÄ (i : Œπ), P (CategoryTheory.CategoryStruct.comp (U i).Œπ f)) ‚Üí P f\n‚ä¢ AlgebraicGeometry.IsLocalAtSource P","decl":"/--\n`P` is local at the target if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ U` for any `U`.\n3. If `P` holds for `f ‚à£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.\n-/\nprotected lemma mk' {P : MorphismProperty Scheme} [P.RespectsIso]\n    (restrict : ‚àÄ {X Y : Scheme} (f : X ‚ü∂ Y) (U : X.Opens), P f ‚Üí P (U.Œπ ‚â´ f))\n    (of_sSup_eq_top :\n      ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) {Œπ : Type u} (U : Œπ ‚Üí X.Opens), iSup U = ‚ä§ ‚Üí\n        (‚àÄ i, P ((U i).Œπ ‚â´ f)) ‚Üí P f) :\n    IsLocalAtSource P := by\n  refine ‚ü®inferInstance, fun {X Y} f ùí∞ ‚Ü¶\n    ‚ü®fun H i ‚Ü¶ ?_, fun H ‚Ü¶ of_sSup_eq_top f _ ùí∞.iSup_opensRange fun i ‚Ü¶ ?_‚ü©‚ü©\n  ¬∑ rw [‚Üê IsOpenImmersion.isoOfRangeEq_hom_fac (ùí∞.map i) (Scheme.Opens.Œπ _)\n      (congr_arg Opens.carrier (ùí∞.map i).opensRange.opensRange_Œπ.symm), Category.assoc,\n      P.cancel_left_of_respectsIso]\n    exact restrict _ _ H\n  ¬∑ rw [‚Üê IsOpenImmersion.isoOfRangeEq_inv_fac (ùí∞.map i) (Scheme.Opens.Œπ _)\n      (congr_arg Opens.carrier (ùí∞.map i).opensRange.opensRange_Œπ.symm), Category.assoc,\n      P.cancel_left_of_respectsIso]\n    exact H _\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.inf","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtSource P\ninst‚úù : AlgebraicGeometry.IsLocalAtSource Q\n‚ä¢ AlgebraicGeometry.IsLocalAtSource (Min.min P Q)","decl":"/-- The intersection of two morphism properties that are local at the target is again local at\nthe target. -/\ninstance inf (P Q : MorphismProperty Scheme) [IsLocalAtSource P] [IsLocalAtSource Q] :\n    IsLocalAtSource (P ‚äì Q) where\n  iff_of_openCover' {_ _} f ùí∞ :=\n    ‚ü®fun h i ‚Ü¶ ‚ü®(iff_of_openCover' f ùí∞).mp h.left i, (iff_of_openCover' f ùí∞).mp h.right i‚ü©,\n     fun h ‚Ü¶ ‚ü®(iff_of_openCover' f ùí∞).mpr (fun i ‚Ü¶ (h i).left),\n      (iff_of_openCover' f ùí∞).mpr (fun i ‚Ü¶ (h i).right)‚ü©‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nUX : AlgebraicGeometry.Scheme\nH : P f\ni : Quiver.Hom UX X\ninst‚úù : AlgebraicGeometry.IsOpenImmersion i\n‚ä¢ P (CategoryTheory.CategoryStruct.comp i f)","decl":"lemma comp {UX : Scheme.{u}} (H : P f) (i : UX ‚ü∂ X) [IsOpenImmersion i] :\n    P (i ‚â´ f) :=\n  (iff_of_openCover' f (X.affineCover.add i)).mp H .none\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.respectsLeft_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\n‚ä¢ P.RespectsLeft @AlgebraicGeometry.IsOpenImmersion","decl":"/-- If `P` is local at the source, then it respects composition on the left with open immersions. -/\ninstance respectsLeft_isOpenImmersion {P : MorphismProperty Scheme}\n    [IsLocalAtSource P] : P.RespectsLeft @IsOpenImmersion where\n  precomp i _ _ hf := IsLocalAtSource.comp hf i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nŒπ : Sort u_1\nU : Œπ ‚Üí X.Opens\nhU : Eq (iSup U) Top.top\nH : ‚àÄ (i : Œπ), P (CategoryTheory.CategoryStruct.comp (U i).Œπ f)\n‚ä¢ P f","decl":"lemma of_iSup_eq_top {Œπ} (U : Œπ ‚Üí X.Opens) (hU : iSup U = ‚ä§)\n    (H : ‚àÄ i, P ((U i).Œπ ‚â´ f)) : P f := by\n  refine (iff_of_openCover' f\n    (X.openCoverOfISupEqTop (s := Set.range U) Subtype.val (by ext; simp [‚Üê hU]))).mpr fun i ‚Ü¶ ?_\n  obtain ‚ü®_, i, rfl‚ü© := i\n  exact H i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nŒπ : Sort u_1\nU : Œπ ‚Üí X.Opens\nhU : Eq (iSup U) Top.top\n‚ä¢ Iff (P f) (‚àÄ (i : Œπ), P (CategoryTheory.CategoryStruct.comp (U i).Œπ f))","decl":"theorem iff_of_iSup_eq_top {Œπ} (U : Œπ ‚Üí X.Opens) (hU : iSup U = ‚ä§) :\n    P f ‚Üî ‚àÄ i, P ((U i).Œπ ‚â´ f) :=\n  ‚ü®fun H _ ‚Ü¶ comp H _, of_iSup_eq_top U hU‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : X.OpenCover\nH : ‚àÄ (i : ùí∞.J), P (CategoryTheory.CategoryStruct.comp (ùí∞.map i) f)\n‚ä¢ P f","decl":"lemma of_openCover (H : ‚àÄ i, P (ùí∞.map i ‚â´ f)) : P f := by\n  refine of_iSup_eq_top (fun i ‚Ü¶ (ùí∞.map i).opensRange) ùí∞.iSup_opensRange fun i ‚Ü¶ ?_\n  rw [‚Üê IsOpenImmersion.isoOfRangeEq_inv_fac (ùí∞.map i) (Scheme.Opens.Œπ _)\n    (congr_arg Opens.carrier (ùí∞.map i).opensRange.opensRange_Œπ.symm), Category.assoc,\n    P.cancel_left_of_respectsIso]\n  exact H i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : X.OpenCover\n‚ä¢ Iff (P f) (‚àÄ (i : ùí∞.J), P (CategoryTheory.CategoryStruct.comp (ùí∞.map i) f))","decl":"theorem iff_of_openCover :\n    P f ‚Üî ‚àÄ i, P (ùí∞.map i ‚â´ f) :=\n  ‚ü®fun H _ ‚Ü¶ comp H _, of_openCover _‚ü©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬π : P.ContainsIdentities\ninst‚úù : AlgebraicGeometry.IsOpenImmersion f\n‚ä¢ P f","decl":"variable (f) in\nlemma of_isOpenImmersion [P.ContainsIdentities] [IsOpenImmersion f] : P f :=\n  Category.comp_id f ‚ñ∏ comp (P.id_mem Y) f\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtSource P\ninst‚úù : P.IsMultiplicative\nhP : ‚àÄ {X Y Z : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z) [inst : AlgebraicGeometry.IsOpenImmersion g], P (CategoryTheory.CategoryStruct.comp f g) ‚Üí P f\n‚ä¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"lemma isLocalAtTarget [P.IsMultiplicative]\n    (hP : ‚àÄ {X Y Z : Scheme.{u}} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsOpenImmersion g], P (f ‚â´ g) ‚Üí P f) :\n    IsLocalAtTarget P where\n  iff_of_openCover' {X Y} f ùí∞ := by\n    refine (iff_of_openCover (ùí∞.pullbackCover f)).trans (forall_congr' fun i ‚Ü¶ ?_)\n    rw [‚Üê Scheme.Cover.pullbackHom_map]\n    constructor\n    ¬∑ exact hP _ _\n    ¬∑ exact fun H ‚Ü¶ P.comp_mem _ _ H (of_isOpenImmersion _)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.resLE","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsLocalAtTarget P\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nhf : P f\n‚ä¢ P (AlgebraicGeometry.Scheme.Hom.resLE f U V e)","decl":"/-- If `P` is local at the source and the target, then restriction on both source and target\npreserves `P`. -/\nlemma resLE [IsLocalAtTarget P] {U : Y.Opens} {V : X.Opens} (e : V ‚â§ f ‚Åª¬π·µÅ U)\n    (hf : P f) : P (f.resLE U V e) :=\n  IsLocalAtSource.comp (IsLocalAtTarget.restrict hf U) _\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_exists_resLE","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù¬≤ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù¬π : AlgebraicGeometry.IsLocalAtTarget P\ninst‚úù : P.RespectsRight @AlgebraicGeometry.IsOpenImmersion\n‚ä¢ Iff (P f) (‚àÄ (x : ‚Üë‚ÜëX.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => P (AlgebraicGeometry.Scheme.Hom.resLE f U V e))","decl":"/-- If `P` is local at the source, local at the target and is stable under post-composition with\nopen immersions, then `P` can be checked locally around points. -/\nlemma iff_exists_resLE [IsLocalAtTarget P] [P.RespectsRight @IsOpenImmersion] :\n    P f ‚Üî ‚àÄ x : X, ‚àÉ (U : Y.Opens) (V : X.Opens) (_ : x ‚àà V.1) (e : V ‚â§ f ‚Åª¬π·µÅ U),\n      P (f.resLE U V e) := by\n  refine ‚ü®fun hf x ‚Ü¶ ‚ü®‚ä§, ‚ä§, trivial, by simp, resLE _ hf‚ü©, fun hf ‚Ü¶ ?_‚ü©\n  choose U V hxU e hf using hf\n  rw [IsLocalAtSource.iff_of_iSup_eq_top (fun x : X ‚Ü¶ V x) (P := P)]\n  ¬∑ intro x\n    rw [‚Üê Scheme.Hom.resLE_comp_Œπ _ (e x)]\n    exact MorphismProperty.RespectsRight.postcomp (Q := @IsOpenImmersion) _ inferInstance _ (hf x)\n  ¬∑ rw [eq_top_iff]\n    rintro x -\n    simp only [Opens.coe_iSup, Set.mem_iUnion, SetLike.mem_coe]\n    use x, hxU x\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.ext","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : AlgebraicGeometry.AffineTargetMorphismProperty\nH : ‚àÄ ‚¶ÉX Y : AlgebraicGeometry.Scheme‚¶Ñ (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y], Iff (P f) (Q f)\n‚ä¢ Eq P Q","decl":"@[ext]\nlemma ext {P Q : AffineTargetMorphismProperty}\n    (H : ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (f : X ‚ü∂ Y) [IsAffine Y], P f ‚Üî Q f) : P = Q := by\n  delta AffineTargetMorphismProperty; ext; exact H _\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.ext_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : AlgebraicGeometry.AffineTargetMorphismProperty\n‚ä¢ Iff (Eq P Q) (‚àÄ ‚¶ÉX Y : AlgebraicGeometry.Scheme‚¶Ñ (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y], Iff (P f) (Q f))","decl":"@[ext]\nlemma ext {P Q : AffineTargetMorphismProperty}\n    (H : ‚àÄ ‚¶ÉX Y : Scheme‚¶Ñ (f : X ‚ü∂ Y) [IsAffine Y], P f ‚Üî Q f) : P = Q := by\n  delta AffineTargetMorphismProperty; ext; exact H _\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.toProperty_apply","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ni : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (P.toProperty f) (P f)","decl":"theorem toProperty_apply (P : AffineTargetMorphismProperty)\n    {X Y : Scheme} (f : X ‚ü∂ Y) [i : IsAffine Y] : P.toProperty f ‚Üî P f := by\n  delta AffineTargetMorphismProperty.toProperty; simp [*]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.cancel_left_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬≤ : P.toProperty.RespectsIso\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬π : CategoryTheory.IsIso f\ninst‚úù : AlgebraicGeometry.IsAffine Z\n‚ä¢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P g)","decl":"theorem cancel_left_of_respectsIso\n    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso f] [IsAffine Z] : P (f ‚â´ g) ‚Üî P g := by\n  rw [‚Üê P.toProperty_apply, ‚Üê P.toProperty_apply, P.toProperty.cancel_left_of_respectsIso]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.cancel_right_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬≥ : P.toProperty.RespectsIso\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninst‚úù¬≤ : CategoryTheory.IsIso g\ninst‚úù¬π : AlgebraicGeometry.IsAffine Z\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P f)","decl":"theorem cancel_right_of_respectsIso\n    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    {X Y Z : Scheme} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) [IsIso g] [IsAffine Z] [IsAffine Y] :\n    P (f ‚â´ g) ‚Üî P f := by rw [‚Üê P.toProperty_apply, ‚Üê P.toProperty_apply,\n      P.toProperty.cancel_right_of_respectsIso]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.arrow_mk_iso_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : P.toProperty.RespectsIso\nX Y X' Y' : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nf' : Quiver.Hom X' Y'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nh : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (P f) (P f')","decl":"theorem arrow_mk_iso_iff\n    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    {X Y X' Y' : Scheme} {f : X ‚ü∂ Y} {f' : X' ‚ü∂ Y'}\n    (e : Arrow.mk f ‚âÖ Arrow.mk f') {h : IsAffine Y} :\n    letI : IsAffine Y' := isAffine_of_isIso (Y := Y) e.inv.right\n    P f ‚Üî P f' := by\n  rw [‚Üê P.toProperty_apply, ‚Üê P.toProperty_apply, P.toProperty.arrow_mk_iso_iff e]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_mk","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nh‚ÇÅ : ‚àÄ {X Y Z : AlgebraicGeometry.Scheme} (e : CategoryTheory.Iso X Y) (f : Quiver.Hom Y Z) [inst : AlgebraicGeometry.IsAffine Z], P f ‚Üí P (CategoryTheory.CategoryStruct.comp e.hom f)\nh‚ÇÇ : ‚àÄ {X Y Z : AlgebraicGeometry.Scheme} (e : CategoryTheory.Iso Y Z) (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y], P f ‚Üí P (CategoryTheory.CategoryStruct.comp f e.hom)\n‚ä¢ P.toProperty.RespectsIso","decl":"theorem respectsIso_mk {P : AffineTargetMorphismProperty}\n    (h‚ÇÅ : ‚àÄ {X Y Z} (e : X ‚âÖ Y) (f : Y ‚ü∂ Z) [IsAffine Z], P f ‚Üí P (e.hom ‚â´ f))\n    (h‚ÇÇ : ‚àÄ {X Y Z} (e : Y ‚âÖ Z) (f : X ‚ü∂ Y) [IsAffine Y],\n      P f ‚Üí @P _ _ (f ‚â´ e.hom) (isAffine_of_isIso e.inv)) :\n    P.toProperty.RespectsIso := by\n  apply MorphismProperty.RespectsIso.mk\n  ¬∑ rintro X Y Z e f ‚ü®a, h‚ü©; exact ‚ü®a, h‚ÇÅ e f h‚ü©\n  ¬∑ rintro X Y Z e f ‚ü®a, h‚ü©; exact ‚ü®isAffine_of_isIso e.inv, h‚ÇÇ e f h‚ü©\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_of","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : P.RespectsIso\n‚ä¢ (AlgebraicGeometry.AffineTargetMorphismProperty.of P).toProperty.RespectsIso","decl":"instance respectsIso_of\n    (P : MorphismProperty Scheme) [P.RespectsIso] :\n    (of P).toProperty.RespectsIso := by\n  apply respectsIso_mk\n  ¬∑ intro _ _ _ _ _ _; apply MorphismProperty.RespectsIso.precomp\n  ¬∑ intro _ _ _ _ _ _; apply MorphismProperty.RespectsIso.postcomp\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nself : P.IsLocal\n‚ä¢ P.toProperty.RespectsIso","decl":"/-- We say that `P : AffineTargetMorphismProperty` is a local property if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basicOpen r` for any\n  global section `r`.\n3. If `P` holds for `f ‚à£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,\n  then `P` holds for `f`.\n-/\nclass IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  /-- `P` as a morphism property respects isomorphisms -/\n  respectsIso : P.toProperty.RespectsIso\n  /-- `P` is stable under restriction to basic open set of global sections. -/\n  to_basicOpen :\n    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (r : Œì(Y, ‚ä§)), P f ‚Üí P (f ‚à£_ Y.basicOpen r)\n  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\n    sections -/\n  of_basicOpenCover :\n    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (s : Finset Œì(Y, ‚ä§))\n      (_ : Ideal.span (s : Set Œì(Y, ‚ä§)) = ‚ä§), (‚àÄ r : s, P (f ‚à£_ Y.basicOpen r.1)) ‚Üí P f\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.to_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nself : P.IsLocal\nX Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nr : ‚Üë(Y.presheaf.obj { unop := Top.top })\na‚úù : P f\n‚ä¢ P (AlgebraicGeometry.morphismRestrict f (Y.basicOpen r))","decl":"/-- We say that `P : AffineTargetMorphismProperty` is a local property if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basicOpen r` for any\n  global section `r`.\n3. If `P` holds for `f ‚à£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,\n  then `P` holds for `f`.\n-/\nclass IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  /-- `P` as a morphism property respects isomorphisms -/\n  respectsIso : P.toProperty.RespectsIso\n  /-- `P` is stable under restriction to basic open set of global sections. -/\n  to_basicOpen :\n    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (r : Œì(Y, ‚ä§)), P f ‚Üí P (f ‚à£_ Y.basicOpen r)\n  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\n    sections -/\n  of_basicOpenCover :\n    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (s : Finset Œì(Y, ‚ä§))\n      (_ : Ideal.span (s : Set Œì(Y, ‚ä§)) = ‚ä§), (‚àÄ r : s, P (f ‚à£_ Y.basicOpen r.1)) ‚Üí P f\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.of_basicOpenCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nself : P.IsLocal\nX Y : AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ns : Finset ‚Üë(Y.presheaf.obj { unop := Top.top })\nx‚úù : Eq (Ideal.span ‚Üës) Top.top\na‚úù : ‚àÄ (r : Subtype fun x => Membership.mem s x), P (AlgebraicGeometry.morphismRestrict f (Y.basicOpen ‚Üër))\n‚ä¢ P f","decl":"/-- We say that `P : AffineTargetMorphismProperty` is a local property if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X ‚ü∂ Y`, then `P` holds for `f ‚à£_ Y.basicOpen r` for any\n  global section `r`.\n3. If `P` holds for `f ‚à£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,\n  then `P` holds for `f`.\n-/\nclass IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  /-- `P` as a morphism property respects isomorphisms -/\n  respectsIso : P.toProperty.RespectsIso\n  /-- `P` is stable under restriction to basic open set of global sections. -/\n  to_basicOpen :\n    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (r : Œì(Y, ‚ä§)), P f ‚Üí P (f ‚à£_ Y.basicOpen r)\n  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\n    sections -/\n  of_basicOpenCover :\n    ‚àÄ {X Y : Scheme} [IsAffine Y] (f : X ‚ü∂ Y) (s : Finset Œì(Y, ‚ä§))\n      (_ : Ideal.span (s : Set Œì(Y, ‚ä§)) = ‚ä§), (‚àÄ r : s, P (f ‚à£_ Y.basicOpen r.1)) ‚Üí P f\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.instIsLocalOfOfIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtTarget P\n‚ä¢ (AlgebraicGeometry.AffineTargetMorphismProperty.of P).IsLocal","decl":"open AffineTargetMorphismProperty in\ninstance (P : MorphismProperty Scheme) [IsLocalAtTarget P] : (of P).IsLocal where\n  respectsIso := inferInstance\n  to_basicOpen _ _ H := IsLocalAtTarget.restrict H _\n  of_basicOpenCover {_ Y} _ _ _ hs := IsLocalAtTarget.of_iSup_eq_top _\n    (((isAffineOpen_top Y).basicOpen_union_eq_self_iff _).mpr hs)\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsStableUnderBaseChange.mk","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : P.toProperty.RespectsIso\nH : ‚àÄ ‚¶ÉX Y S : AlgebraicGeometry.Scheme‚¶Ñ [inst : AlgebraicGeometry.IsAffine S] [inst_1 : AlgebraicGeometry.IsAffine X] (f : Quiver.Hom X S) (g : Quiver.Hom Y S), P g ‚Üí P (CategoryTheory.Limits.pullback.fst f g)\n‚ä¢ P.IsStableUnderBaseChange","decl":"lemma IsStableUnderBaseChange.mk (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    (H : ‚àÄ ‚¶ÉX Y S : Scheme‚¶Ñ [IsAffine S] [IsAffine X] (f : X ‚ü∂ S) (g : Y ‚ü∂ S),\n      P g ‚Üí P (pullback.fst f g)) : P.IsStableUnderBaseChange := by\n  intros Z X Y S _ _ f g f' g' h hg\n  rw [‚Üê P.cancel_left_of_respectsIso h.isoPullback.inv, h.isoPullback_inv_fst]\n  exact H f g hg\n\n"}
{"name":"AlgebraicGeometry.of_targetAffineLocally_of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬≤ : P.IsLocal\nX Y UX UY : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine UY\nf : Quiver.Hom X Y\niY : Quiver.Hom UY Y\ninst‚úù : AlgebraicGeometry.IsOpenImmersion iY\niX : Quiver.Hom UX X\nf' : Quiver.Hom UX UY\nh : CategoryTheory.IsPullback iX f' f iY\nhf : AlgebraicGeometry.targetAffineLocally P f\n‚ä¢ P f'","decl":"theorem of_targetAffineLocally_of_isPullback\n    {P : AffineTargetMorphismProperty} [P.IsLocal]\n    {X Y UX UY : Scheme.{u}} [IsAffine UY] {f : X ‚ü∂ Y} {iY : UY ‚ü∂ Y} [IsOpenImmersion iY]\n    {iX : UX ‚ü∂ X} {f' : UX ‚ü∂ UY} (h : IsPullback iX f' f iY) (hf : targetAffineLocally P f) :\n    P f' := by\n  rw [‚Üê P.cancel_left_of_respectsIso h.isoPullback.inv, h.isoPullback_inv_snd]\n  exact (P.arrow_mk_iso_iff\n    (morphismRestrictOpensRange f _)).mp (hf ‚ü®_, isAffineOpen_opensRange iY‚ü©)\n\n"}
{"name":"AlgebraicGeometry.instRespectsIsoSchemeTargetAffineLocallyOfToProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : P.toProperty.RespectsIso\n‚ä¢ (AlgebraicGeometry.targetAffineLocally P).RespectsIso","decl":"instance (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso] :\n    (targetAffineLocally P).RespectsIso := by\n  apply MorphismProperty.RespectsIso.mk\n  ¬∑ introv H U\n    rw [morphismRestrict_comp, P.cancel_left_of_respectsIso]\n    exact H U\n  ¬∑ introv H\n    rintro ‚ü®U, hU : IsAffineOpen U‚ü©; dsimp\n    haveI : IsAffine _ := hU.preimage_of_isIso e.hom\n    rw [morphismRestrict_comp, P.cancel_right_of_respectsIso]\n    exact H ‚ü®(Opens.map e.hom.base).obj U, hU.preimage_of_isIso e.hom‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.eq_targetAffineLocally'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam AlgebraicGeometry.AffineTargetMorphismProperty\nself : AlgebraicGeometry.HasAffineProperty P Q\n‚ä¢ Eq P (AlgebraicGeometry.targetAffineLocally Q)","decl":"/--\n`HasAffineProperty P Q` is a type class asserting that `P` is local at the target, and over affine\nschemes, it is equivalent to `Q : AffineTargetMorphismProperty`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local at the target\n2. `P f` if and only if `‚àÄ U, Q (f ‚à£_ U)` ranging over all affine opens of `U`.\nSee `HasAffineProperty.iff`.\n-/\nclass HasAffineProperty (P : MorphismProperty Scheme)\n    (Q : outParam AffineTargetMorphismProperty) : Prop where\n  isLocal_affineProperty : Q.IsLocal\n  eq_targetAffineLocally' : P = targetAffineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.isLocal_affineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam AlgebraicGeometry.AffineTargetMorphismProperty\nself : AlgebraicGeometry.HasAffineProperty P Q\n‚ä¢ AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal Q","decl":"/--\n`HasAffineProperty P Q` is a type class asserting that `P` is local at the target, and over affine\nschemes, it is equivalent to `Q : AffineTargetMorphismProperty`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local at the target\n2. `P f` if and only if `‚àÄ U, Q (f ‚à£_ U)` ranging over all affine opens of `U`.\nSee `HasAffineProperty.iff`.\n-/\nclass HasAffineProperty (P : MorphismProperty Scheme)\n    (Q : outParam AffineTargetMorphismProperty) : Prop where\n  isLocal_affineProperty : Q.IsLocal\n  eq_targetAffineLocally' : P = targetAffineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.instTargetAffineLocallyOfIsLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"Q : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : Q.IsLocal\n‚ä¢ AlgebraicGeometry.HasAffineProperty (AlgebraicGeometry.targetAffineLocally Q) Q","decl":"instance (Q : AffineTargetMorphismProperty) [Q.IsLocal] :\n    HasAffineProperty (targetAffineLocally Q) Q :=\n  ‚ü®inferInstance, rfl‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.eq_targetAffineLocally","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\n‚ä¢ Eq P (AlgebraicGeometry.targetAffineLocally Q)","decl":"lemma eq_targetAffineLocally : P = targetAffineLocally Q := eq_targetAffineLocally'\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninst‚úù : AlgebraicGeometry.IsLocalAtTarget P\n‚ä¢ AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.AffineTargetMorphismProperty.of P)","decl":"/-- Every property local at the target can be associated with an affine target property.\nThis is not an instance as the associated property can often take on simpler forms. -/\nlemma of_isLocalAtTarget (P) [IsLocalAtTarget P] :\n    HasAffineProperty P (AffineTargetMorphismProperty.of P) where\n  isLocal_affineProperty := inferInstance\n  eq_targetAffineLocally' := by\n    ext X Y f\n    constructor\n    ¬∑ intro hf ‚ü®U, hU‚ü©\n      exact IsLocalAtTarget.restrict hf _\n    ¬∑ intro hf\n      exact IsLocalAtTarget.of_openCover (P := P) Y.affineCover\n        fun i ‚Ü¶ of_targetAffineLocally_of_isPullback (.of_hasPullback _ _) hf\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.copy","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P P' : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ Q' : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\ne : Eq P P'\ne' : Eq Q Q'\n‚ä¢ AlgebraicGeometry.HasAffineProperty P' Q'","decl":"lemma copy {P P'} {Q Q'} [HasAffineProperty P Q]\n    (e : P = P') (e' : Q = Q') : HasAffineProperty P' Q' where\n  isLocal_affineProperty := e' ‚ñ∏ isLocal_affineProperty P\n  eq_targetAffineLocally' := e' ‚ñ∏ e.symm ‚ñ∏ eq_targetAffineLocally P\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬≤ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nUX UY : AlgebraicGeometry.Scheme\ninst‚úù¬π : AlgebraicGeometry.IsAffine UY\niY : Quiver.Hom UY Y\ninst‚úù : AlgebraicGeometry.IsOpenImmersion iY\niX : Quiver.Hom UX X\nf' : Quiver.Hom UX UY\nh : CategoryTheory.IsPullback iX f' f iY\nhf : P f\n‚ä¢ Q f'","decl":"theorem of_isPullback {UX UY : Scheme.{u}} [IsAffine UY] {iY : UY ‚ü∂ Y} [IsOpenImmersion iY]\n    {iX : UX ‚ü∂ X} {f' : UX ‚ü∂ UY} (h : IsPullback iX f' f iY) (hf : P f) :\n    Q f' :=\n  letI := isLocal_affineProperty P\n  of_targetAffineLocally_of_isPullback h (eq_targetAffineLocally (P := P) ‚ñ∏ hf)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.restrict","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : P f\nU : ‚ÜëY.affineOpens\n‚ä¢ Q (AlgebraicGeometry.morphismRestrict f ‚ÜëU)","decl":"theorem restrict (hf : P f) (U : Y.affineOpens) :\n    Q (f ‚à£_ U) :=\n  of_isPullback (isPullback_morphismRestrict f U).flip hf\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.instRespectsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\n‚ä¢ P.RespectsIso","decl":"instance (priority := 900) : P.RespectsIso := by\n  letI := isLocal_affineProperty P\n  rw [eq_targetAffineLocally P]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nŒπ : Sort u_1\nU : Œπ ‚Üí ‚ÜëY.affineOpens\nhU : Eq (iSup fun i => ‚Üë(U i)) Top.top\nhU' : ‚àÄ (i : Œπ), Q (AlgebraicGeometry.morphismRestrict f ‚Üë(U i))\n‚ä¢ P f","decl":"theorem of_iSup_eq_top\n    {Œπ} (U : Œπ ‚Üí Y.affineOpens) (hU : ‚®Ü i, (U i : Y.Opens) = ‚ä§)\n    (hU' : ‚àÄ i, Q (f ‚à£_ U i)) :\n    P f := by\n  letI := isLocal_affineProperty P\n  rw [eq_targetAffineLocally P]\n  classical\n  intro V\n  induction V using of_affine_open_cover U hU  with\n  | basicOpen U r h =>\n    haveI : IsAffine _ := U.2\n    have := AffineTargetMorphismProperty.IsLocal.to_basicOpen (f ‚à£_ U.1) (U.1.topIso.inv r) h\n    exact (Q.arrow_mk_iso_iff\n      (morphismRestrictRestrictBasicOpen f _ r)).mp this\n  | openCover U s hs H =>\n    apply AffineTargetMorphismProperty.IsLocal.of_basicOpenCover _\n      (s.image (Scheme.Opens.topIso _).inv) (by simp [‚Üê Ideal.map_span, hs, Ideal.map_top])\n    intro ‚ü®r, hr‚ü©\n    obtain ‚ü®r, hr', rfl‚ü© := Finset.mem_image.mp hr\n    exact (Q.arrow_mk_iso_iff\n      (morphismRestrictRestrictBasicOpen f _ r).symm).mp (H ‚ü®r, hr'‚ü©)\n  | hU i => exact hU' i\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nŒπ : Sort u_1\nU : Œπ ‚Üí ‚ÜëY.affineOpens\nhU : Eq (iSup fun i => ‚Üë(U i)) Top.top\n‚ä¢ Iff (P f) (‚àÄ (i : Œπ), Q (AlgebraicGeometry.morphismRestrict f ‚Üë(U i)))","decl":"theorem iff_of_iSup_eq_top\n    {Œπ} (U : Œπ ‚Üí Y.affineOpens) (hU : ‚®Ü i, (U i : Y.Opens) = ‚ä§) :\n    P f ‚Üî ‚àÄ i, Q (f ‚à£_ U i) :=\n  ‚ü®fun H _ ‚Ü¶ restrict H _, fun H ‚Ü¶ HasAffineProperty.of_iSup_eq_top U hU H‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬π : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\ninst‚úù : ‚àÄ (i : ùí∞.J), AlgebraicGeometry.IsAffine (ùí∞.obj i)\nhùí∞ : ‚àÄ (i : ùí∞.1), Q (AlgebraicGeometry.Scheme.Cover.pullbackHom ùí∞ f i)\n‚ä¢ P f","decl":"theorem of_openCover\n    (ùí∞ : Y.OpenCover) [‚àÄ i, IsAffine (ùí∞.obj i)] (hùí∞ : ‚àÄ i, Q (ùí∞.pullbackHom f i)) :\n    P f :=\n  letI := isLocal_affineProperty P\n  of_iSup_eq_top\n    (fun i ‚Ü¶ ‚ü®_, isAffineOpen_opensRange (ùí∞.map i)‚ü©) ùí∞.iSup_opensRange\n    (fun i ‚Ü¶ (Q.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr (hùí∞ i))\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬π : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nùí∞ : Y.OpenCover\ninst‚úù : ‚àÄ (i : ùí∞.J), AlgebraicGeometry.IsAffine (ùí∞.obj i)\n‚ä¢ Iff (P f) (‚àÄ (i : ùí∞.1), Q (AlgebraicGeometry.Scheme.Cover.pullbackHom ùí∞ f i))","decl":"theorem iff_of_openCover (ùí∞ : Y.OpenCover) [‚àÄ i, IsAffine (ùí∞.obj i)] :\n    P f ‚Üî ‚àÄ i, Q (ùí∞.pullbackHom f i) := by\n  letI := isLocal_affineProperty P\n  rw [iff_of_iSup_eq_top (P := P)\n    (fun i ‚Ü¶ ‚ü®_, isAffineOpen_opensRange _‚ü©) ùí∞.iSup_opensRange]\n  exact forall_congr' fun i ‚Ü¶ Q.arrow_mk_iso_iff\n    (morphismRestrictOpensRange f _)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù¬π : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst‚úù : AlgebraicGeometry.IsAffine Y\n‚ä¢ Iff (P f) (Q f)","decl":"theorem iff_of_isAffine [IsAffine Y] : P f ‚Üî Q f := by\n  letI := isLocal_affineProperty P\n  haveI : ‚àÄ i, IsAffine (Scheme.Cover.obj\n      (Scheme.coverOfIsIso (P := @IsOpenImmersion) (ùüô Y)) i) := fun i => by\n    dsimp; infer_instance\n  rw [iff_of_openCover (P := P) (Scheme.coverOfIsIso.{0} (ùüô Y))]\n  trans Q (pullback.snd f (ùüô _))\n  ¬∑ exact ‚ü®fun H => H PUnit.unit, fun H _ => H‚ü©\n  rw [‚Üê Category.comp_id (pullback.snd _ _), ‚Üê pullback.condition,\n    Q.cancel_left_of_respectsIso]\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\n‚ä¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"instance (priority := 900) : IsLocalAtTarget P := by\n  letI := isLocal_affineProperty P\n  apply IsLocalAtTarget.mk'\n  ¬∑ rw [eq_targetAffineLocally P]\n    intro X Y f U H V\n    rw [Q.arrow_mk_iso_iff (morphismRestrictRestrict f _ _)]\n    exact H ‚ü®_, V.2.image_of_isOpenImmersion (Y.ofRestrict _)‚ü©\n  ¬∑ rintro X Y f Œπ U hU H\n    let ùí∞ := Y.openCoverOfISupEqTop U hU\n    apply of_openCover ùí∞.affineRefinement.openCover\n    rintro ‚ü®i, j‚ü©\n    have : P (ùí∞.pullbackHom f i) := by\n      refine (P.arrow_mk_iso_iff\n        (morphismRestrictEq _ ?_ ‚â™‚â´ morphismRestrictOpensRange f (ùí∞.map i))).mp (H i)\n      exact (Scheme.Opens.opensRange_Œπ _).symm\n    rw [‚Üê Q.cancel_left_of_respectsIso (ùí∞.pullbackCoverAffineRefinementObjIso f _).inv,\n      ùí∞.pullbackCoverAffineRefinementObjIso_inv_pullbackHom]\n    exact of_isPullback (.of_hasPullback _ _) this\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\n‚ä¢ Iff (AlgebraicGeometry.HasAffineProperty P Q) (And (AlgebraicGeometry.IsLocalAtTarget P) (Eq Q (AlgebraicGeometry.AffineTargetMorphismProperty.of P)))","decl":"open AffineTargetMorphismProperty in\nprotected theorem iff {P : MorphismProperty Scheme} {Q : AffineTargetMorphismProperty} :\n    HasAffineProperty P Q ‚Üî IsLocalAtTarget P ‚àß Q = of P :=\n  ‚ü®fun _ ‚Ü¶ ‚ü®inferInstance, ext fun _ _ _ ‚Ü¶ iff_of_isAffine.symm‚ü©,\n    fun ‚ü®_, e‚ü© ‚Ü¶ e ‚ñ∏ of_isLocalAtTarget P‚ü©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\nhP' : Q.IsStableUnderBaseChange\n‚ä¢ P.IsStableUnderBaseChange","decl":"theorem isStableUnderBaseChange (hP' : Q.IsStableUnderBaseChange) :\n    P.IsStableUnderBaseChange :=\n  MorphismProperty.IsStableUnderBaseChange.mk'\n    (fun X Y S f g _ H => by\n      rw [IsLocalAtTarget.iff_of_openCover (P := P) (S.affineCover.pullbackCover f)]\n      intro i\n      let e : pullback (pullback.fst f g) ((S.affineCover.pullbackCover f).map i) ‚âÖ\n          _ := by\n        refine pullbackSymmetry _ _ ‚â™‚â´ pullbackRightPullbackFstIso f g _ ‚â™‚â´ ?_ ‚â™‚â´\n          (pullbackRightPullbackFstIso (S.affineCover.map i) g\n            (pullback.snd f (S.affineCover.map i))).symm\n        exact asIso\n          (pullback.map _ _ _ _ (ùüô _) (ùüô _) (ùüô _) (by simpa using pullback.condition) (by simp))\n      have : e.hom ‚â´ pullback.fst _ _ =\n          (S.affineCover.pullbackCover f).pullbackHom (pullback.fst _ _) i := by\n        simp [e, Scheme.Cover.pullbackHom]\n      rw [‚Üê this, P.cancel_left_of_respectsIso]\n      apply HasAffineProperty.pullback_fst_of_right hP'\n      letI := isLocal_affineProperty P\n      rw [‚Üê pullbackSymmetry_hom_comp_snd, Q.cancel_left_of_respectsIso]\n      apply of_isPullback (.of_hasPullback _ _) H)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.isLocalAtSource","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninst‚úù : AlgebraicGeometry.HasAffineProperty P Q\nH : ‚àÄ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y] (ùí∞ : X.OpenCover), Iff (Q f) (‚àÄ (i : ùí∞.J), Q (CategoryTheory.CategoryStruct.comp (ùí∞.map i) f))\n‚ä¢ AlgebraicGeometry.IsLocalAtSource P","decl":"lemma isLocalAtSource\n    (H : ‚àÄ {X Y : Scheme.{u}} (f : X ‚ü∂ Y) [IsAffine Y] (ùí∞ : Scheme.OpenCover.{u} X),\n        Q f ‚Üî ‚àÄ i, Q (ùí∞.map i ‚â´ f)) : IsLocalAtSource P where\n  iff_of_openCover' {X Y} f ùí∞ := by\n    simp_rw [IsLocalAtTarget.iff_of_iSup_eq_top _ (iSup_affineOpens_eq_top Y)]\n    rw [forall_comm]\n    refine forall_congr' fun U ‚Ü¶ ?_\n    simp_rw [HasAffineProperty.iff_of_isAffine, morphismRestrict_comp]\n    exact @H _ _ (f ‚à£_ U.1) U.2 (ùí∞.restrict (f ‚Åª¬π·µÅ U.1))\n\n"}
