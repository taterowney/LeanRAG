{"name":"AlgebraicGeometry.IsLocalAtTarget.iff_of_openCover'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nâŠ¢ Iff (P f) (âˆ€ (i : ğ’°.1), P (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i))","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the target if\n1. `P` respects isomorphisms.\n2. `P` holds for `f âˆ£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`.\nAlso see `IsLocalAtTarget.mk'` for a convenient constructor.\n-/\nclass IsLocalAtTarget (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f âˆ£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) (ğ’° : Scheme.OpenCover.{u} Y),\n      P f â†” âˆ€ i, P (ğ’°.pullbackHom f i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtTarget P\nâŠ¢ P.RespectsIso","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the target if\n1. `P` respects isomorphisms.\n2. `P` holds for `f âˆ£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`.\nAlso see `IsLocalAtTarget.mk'` for a convenient constructor.\n-/\nclass IsLocalAtTarget (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f âˆ£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) (ğ’° : Scheme.OpenCover.{u} Y),\n      P f â†” âˆ€ i, P (ğ’°.pullbackHom f i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.mk'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.RespectsIso\nrestrict : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) (U : Y.Opens), P f â†’ P (AlgebraicGeometry.morphismRestrict f U)\nof_sSup_eq_top : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) {Î¹ : Type u} (U : Î¹ â†’ Y.Opens), Eq (iSup U) Top.top â†’ (âˆ€ (i : Î¹), P (AlgebraicGeometry.morphismRestrict f (U i))) â†’ P f\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"/--\n`P` is local at the target if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`.\n3. If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.\n-/\nprotected lemma mk' {P : MorphismProperty Scheme} [P.RespectsIso]\n    (restrict : âˆ€ {X Y : Scheme} (f : X âŸ¶ Y) (U : Y.Opens), P f â†’ P (f âˆ£_ U))\n    (of_sSup_eq_top :\n      âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) {Î¹ : Type u} (U : Î¹ â†’ Y.Opens), iSup U = âŠ¤ â†’\n        (âˆ€ i, P (f âˆ£_ U i)) â†’ P f) :\n    IsLocalAtTarget P := by\n  refine âŸ¨inferInstance, fun {X Y} f ğ’° â†¦ âŸ¨?_, fun H â†¦ of_sSup_eq_top f _ ğ’°.iSup_opensRange ?_âŸ©âŸ©\n  Â· exact fun H i â†¦ (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mp (restrict _ _ H)\n  Â· exact fun i â†¦ (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr (H i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.inf","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsLocalAtTarget P\ninstâœ : AlgebraicGeometry.IsLocalAtTarget Q\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget (Min.min P Q)","decl":"/-- The intersection of two morphism properties that are local at the target is again local at\nthe target. -/\ninstance inf (P Q : MorphismProperty Scheme) [IsLocalAtTarget P] [IsLocalAtTarget Q] :\n    IsLocalAtTarget (P âŠ“ Q) where\n  iff_of_openCover' {_ _} f ğ’° :=\n    âŸ¨fun h i â†¦ âŸ¨(iff_of_openCover' f ğ’°).mp h.left i, (iff_of_openCover' f ğ’°).mp h.right iâŸ©,\n     fun h â†¦ âŸ¨(iff_of_openCover' f ğ’°).mpr (fun i â†¦ (h i).left),\n      (iff_of_openCover' f ğ’°).mpr (fun i â†¦ (h i).right)âŸ©âŸ©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nUX UY : AlgebraicGeometry.Scheme\niY : Quiver.Hom UY Y\ninstâœ : AlgebraicGeometry.IsOpenImmersion iY\niX : Quiver.Hom UX X\nf' : Quiver.Hom UX UY\nh : CategoryTheory.IsPullback iX f' f iY\nH : P f\nâŠ¢ P f'","decl":"lemma of_isPullback {UX UY : Scheme.{u}} {iY : UY âŸ¶ Y} [IsOpenImmersion iY]\n    {iX : UX âŸ¶ X} {f' : UX âŸ¶ UY} (h : IsPullback iX f' f iY) (H : P f) : P f' := by\n  rw [â† P.cancel_left_of_respectsIso h.isoPullback.inv, h.isoPullback_inv_snd]\n  exact (iff_of_openCover' f (Y.affineCover.add iY)).mp H .none\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.restrict","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : P f\nU : Y.Opens\nâŠ¢ P (AlgebraicGeometry.morphismRestrict f U)","decl":"theorem restrict (hf : P f) (U : Y.Opens) : P (f âˆ£_ U) :=\n  of_isPullback (isPullback_morphismRestrict f U).flip hf\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nÎ¹ : Sort u_1\nU : Î¹ â†’ Y.Opens\nhU : Eq (iSup U) Top.top\nH : âˆ€ (i : Î¹), P (AlgebraicGeometry.morphismRestrict f (U i))\nâŠ¢ P f","decl":"lemma of_iSup_eq_top {Î¹} (U : Î¹ â†’ Y.Opens) (hU : iSup U = âŠ¤)\n    (H : âˆ€ i, P (f âˆ£_ U i)) : P f := by\n  refine (IsLocalAtTarget.iff_of_openCover' f\n    (Y.openCoverOfISupEqTop (s := Set.range U) Subtype.val (by ext; simp [â† hU]))).mpr fun i â†¦ ?_\n  obtain âŸ¨_, i, rflâŸ© := i\n  refine (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mp ?_\n  show P (f âˆ£_ (U i).Î¹.opensRange)\n  rw [Scheme.Opens.opensRange_Î¹]\n  exact H i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nÎ¹ : Sort u_1\nU : Î¹ â†’ Y.Opens\nhU : Eq (iSup U) Top.top\nâŠ¢ Iff (P f) (âˆ€ (i : Î¹), P (AlgebraicGeometry.morphismRestrict f (U i)))","decl":"theorem iff_of_iSup_eq_top {Î¹} (U : Î¹ â†’ Y.Opens) (hU : iSup U = âŠ¤) :\n    P f â†” âˆ€ i, P (f âˆ£_ U i) :=\n  âŸ¨fun H _ â†¦ restrict H _, of_iSup_eq_top U hUâŸ©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nH : âˆ€ (i : ğ’°.1), P (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i)\nâŠ¢ P f","decl":"lemma of_openCover (H : âˆ€ i, P (ğ’°.pullbackHom f i)) : P f := by\n  apply of_iSup_eq_top (fun i â†¦ (ğ’°.map i).opensRange) ğ’°.iSup_opensRange\n  exact fun i â†¦ (P.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr (H i)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtTarget.iff_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nhP : AlgebraicGeometry.IsLocalAtTarget P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\nâŠ¢ Iff (P f) (âˆ€ (i : ğ’°.1), P (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i))","decl":"theorem iff_of_openCover (ğ’° : Y.OpenCover) :\n    P f â†” âˆ€ i, P (ğ’°.pullbackHom f i) :=\n  âŸ¨fun H _ â†¦ of_isPullback (.of_hasPullback _ _) H, of_openCover _âŸ©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtSource P\nâŠ¢ P.RespectsIso","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the source if\n1. `P` respects isomorphisms.\n2. `P` holds for `ğ’°.map i â‰« f` for an open cover `ğ’°` of `X` iff `P` holds for `f : X âŸ¶ Y`.\nAlso see `IsLocalAtSource.mk'` for a convenient constructor.\n-/\nclass IsLocalAtSource (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f âˆ£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) (ğ’° : Scheme.OpenCover.{u} X),\n      P f â†” âˆ€ i, P (ğ’°.map i â‰« f)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_of_openCover'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nself : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : X.OpenCover\nâŠ¢ Iff (P f) (âˆ€ (i : ğ’°.J), P (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f))","decl":"/--\nWe say that `P : MorphismProperty Scheme` is local at the source if\n1. `P` respects isomorphisms.\n2. `P` holds for `ğ’°.map i â‰« f` for an open cover `ğ’°` of `X` iff `P` holds for `f : X âŸ¶ Y`.\nAlso see `IsLocalAtSource.mk'` for a convenient constructor.\n-/\nclass IsLocalAtSource (P : MorphismProperty Scheme) : Prop where\n  /-- `P` respects isomorphisms. -/\n  respectsIso : P.RespectsIso := by infer_instance\n  /-- `P` holds for `f âˆ£_ U` for an open cover `U` of `Y` if and only if `P` holds for `f`. -/\n  iff_of_openCover' :\n    âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) (ğ’° : Scheme.OpenCover.{u} X),\n      P f â†” âˆ€ i, P (ğ’°.map i â‰« f)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.mk'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.RespectsIso\nrestrict : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) (U : X.Opens), P f â†’ P (CategoryTheory.CategoryStruct.comp U.Î¹ f)\nof_sSup_eq_top : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) {Î¹ : Type u} (U : Î¹ â†’ X.Opens), Eq (iSup U) Top.top â†’ (âˆ€ (i : Î¹), P (CategoryTheory.CategoryStruct.comp (U i).Î¹ f)) â†’ P f\nâŠ¢ AlgebraicGeometry.IsLocalAtSource P","decl":"/--\n`P` is local at the target if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ U` for any `U`.\n3. If `P` holds for `f âˆ£_ U` for an open cover `U` of `Y`, then `P` holds for `f`.\n-/\nprotected lemma mk' {P : MorphismProperty Scheme} [P.RespectsIso]\n    (restrict : âˆ€ {X Y : Scheme} (f : X âŸ¶ Y) (U : X.Opens), P f â†’ P (U.Î¹ â‰« f))\n    (of_sSup_eq_top :\n      âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) {Î¹ : Type u} (U : Î¹ â†’ X.Opens), iSup U = âŠ¤ â†’\n        (âˆ€ i, P ((U i).Î¹ â‰« f)) â†’ P f) :\n    IsLocalAtSource P := by\n  refine âŸ¨inferInstance, fun {X Y} f ğ’° â†¦\n    âŸ¨fun H i â†¦ ?_, fun H â†¦ of_sSup_eq_top f _ ğ’°.iSup_opensRange fun i â†¦ ?_âŸ©âŸ©\n  Â· rw [â† IsOpenImmersion.isoOfRangeEq_hom_fac (ğ’°.map i) (Scheme.Opens.Î¹ _)\n      (congr_arg Opens.carrier (ğ’°.map i).opensRange.opensRange_Î¹.symm), Category.assoc,\n      P.cancel_left_of_respectsIso]\n    exact restrict _ _ H\n  Â· rw [â† IsOpenImmersion.isoOfRangeEq_inv_fac (ğ’°.map i) (Scheme.Opens.Î¹ _)\n      (congr_arg Opens.carrier (ğ’°.map i).opensRange.opensRange_Î¹.symm), Category.assoc,\n      P.cancel_left_of_respectsIso]\n    exact H _\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.inf","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsLocalAtSource P\ninstâœ : AlgebraicGeometry.IsLocalAtSource Q\nâŠ¢ AlgebraicGeometry.IsLocalAtSource (Min.min P Q)","decl":"/-- The intersection of two morphism properties that are local at the target is again local at\nthe target. -/\ninstance inf (P Q : MorphismProperty Scheme) [IsLocalAtSource P] [IsLocalAtSource Q] :\n    IsLocalAtSource (P âŠ“ Q) where\n  iff_of_openCover' {_ _} f ğ’° :=\n    âŸ¨fun h i â†¦ âŸ¨(iff_of_openCover' f ğ’°).mp h.left i, (iff_of_openCover' f ğ’°).mp h.right iâŸ©,\n     fun h â†¦ âŸ¨(iff_of_openCover' f ğ’°).mpr (fun i â†¦ (h i).left),\n      (iff_of_openCover' f ğ’°).mpr (fun i â†¦ (h i).right)âŸ©âŸ©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.comp","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nUX : AlgebraicGeometry.Scheme\nH : P f\ni : Quiver.Hom UX X\ninstâœ : AlgebraicGeometry.IsOpenImmersion i\nâŠ¢ P (CategoryTheory.CategoryStruct.comp i f)","decl":"lemma comp {UX : Scheme.{u}} (H : P f) (i : UX âŸ¶ X) [IsOpenImmersion i] :\n    P (i â‰« f) :=\n  (iff_of_openCover' f (X.affineCover.add i)).mp H .none\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.respectsLeft_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtSource P\nâŠ¢ P.RespectsLeft @AlgebraicGeometry.IsOpenImmersion","decl":"/-- If `P` is local at the source, then it respects composition on the left with open immersions. -/\ninstance respectsLeft_isOpenImmersion {P : MorphismProperty Scheme}\n    [IsLocalAtSource P] : P.RespectsLeft @IsOpenImmersion where\n  precomp i _ _ hf := IsLocalAtSource.comp hf i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nÎ¹ : Sort u_1\nU : Î¹ â†’ X.Opens\nhU : Eq (iSup U) Top.top\nH : âˆ€ (i : Î¹), P (CategoryTheory.CategoryStruct.comp (U i).Î¹ f)\nâŠ¢ P f","decl":"lemma of_iSup_eq_top {Î¹} (U : Î¹ â†’ X.Opens) (hU : iSup U = âŠ¤)\n    (H : âˆ€ i, P ((U i).Î¹ â‰« f)) : P f := by\n  refine (iff_of_openCover' f\n    (X.openCoverOfISupEqTop (s := Set.range U) Subtype.val (by ext; simp [â† hU]))).mpr fun i â†¦ ?_\n  obtain âŸ¨_, i, rflâŸ© := i\n  exact H i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nÎ¹ : Sort u_1\nU : Î¹ â†’ X.Opens\nhU : Eq (iSup U) Top.top\nâŠ¢ Iff (P f) (âˆ€ (i : Î¹), P (CategoryTheory.CategoryStruct.comp (U i).Î¹ f))","decl":"theorem iff_of_iSup_eq_top {Î¹} (U : Î¹ â†’ X.Opens) (hU : iSup U = âŠ¤) :\n    P f â†” âˆ€ i, P ((U i).Î¹ â‰« f) :=\n  âŸ¨fun H _ â†¦ comp H _, of_iSup_eq_top U hUâŸ©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : X.OpenCover\nH : âˆ€ (i : ğ’°.J), P (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f)\nâŠ¢ P f","decl":"lemma of_openCover (H : âˆ€ i, P (ğ’°.map i â‰« f)) : P f := by\n  refine of_iSup_eq_top (fun i â†¦ (ğ’°.map i).opensRange) ğ’°.iSup_opensRange fun i â†¦ ?_\n  rw [â† IsOpenImmersion.isoOfRangeEq_inv_fac (ğ’°.map i) (Scheme.Opens.Î¹ _)\n    (congr_arg Opens.carrier (ğ’°.map i).opensRange.opensRange_Î¹.symm), Category.assoc,\n    P.cancel_left_of_respectsIso]\n  exact H i\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : X.OpenCover\nâŠ¢ Iff (P f) (âˆ€ (i : ğ’°.J), P (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f))","decl":"theorem iff_of_openCover :\n    P f â†” âˆ€ i, P (ğ’°.map i â‰« f) :=\n  âŸ¨fun H _ â†¦ comp H _, of_openCover _âŸ©\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.of_isOpenImmersion","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœÂ¹ : P.ContainsIdentities\ninstâœ : AlgebraicGeometry.IsOpenImmersion f\nâŠ¢ P f","decl":"variable (f) in\nlemma of_isOpenImmersion [P.ContainsIdentities] [IsOpenImmersion f] : P f :=\n  Category.comp_id f â–¸ comp (P.id_mem Y) f\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsLocalAtSource P\ninstâœ : P.IsMultiplicative\nhP : âˆ€ {X Y Z : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) (g : Quiver.Hom Y Z) [inst : AlgebraicGeometry.IsOpenImmersion g], P (CategoryTheory.CategoryStruct.comp f g) â†’ P f\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"lemma isLocalAtTarget [P.IsMultiplicative]\n    (hP : âˆ€ {X Y Z : Scheme.{u}} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsOpenImmersion g], P (f â‰« g) â†’ P f) :\n    IsLocalAtTarget P where\n  iff_of_openCover' {X Y} f ğ’° := by\n    refine (iff_of_openCover (ğ’°.pullbackCover f)).trans (forall_congr' fun i â†¦ ?_)\n    rw [â† Scheme.Cover.pullbackHom_map]\n    constructor\n    Â· exact hP _ _\n    Â· exact fun H â†¦ P.comp_mem _ _ H (of_isOpenImmersion _)\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.resLE","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : AlgebraicGeometry.IsLocalAtTarget P\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nhf : P f\nâŠ¢ P (AlgebraicGeometry.Scheme.Hom.resLE f U V e)","decl":"/-- If `P` is local at the source and the target, then restriction on both source and target\npreserves `P`. -/\nlemma resLE [IsLocalAtTarget P] {U : Y.Opens} {V : X.Opens} (e : V â‰¤ f â»Â¹áµ U)\n    (hf : P f) : P (f.resLE U V e) :=\n  IsLocalAtSource.comp (IsLocalAtTarget.restrict hf U) _\n\n"}
{"name":"AlgebraicGeometry.IsLocalAtSource.iff_exists_resLE","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœÂ² : AlgebraicGeometry.IsLocalAtSource P\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœÂ¹ : AlgebraicGeometry.IsLocalAtTarget P\ninstâœ : P.RespectsRight @AlgebraicGeometry.IsOpenImmersion\nâŠ¢ Iff (P f) (âˆ€ (x : â†‘â†‘X.toPresheafedSpace), Exists fun U => Exists fun V => Exists fun x => Exists fun e => P (AlgebraicGeometry.Scheme.Hom.resLE f U V e))","decl":"/-- If `P` is local at the source, local at the target and is stable under post-composition with\nopen immersions, then `P` can be checked locally around points. -/\nlemma iff_exists_resLE [IsLocalAtTarget P] [P.RespectsRight @IsOpenImmersion] :\n    P f â†” âˆ€ x : X, âˆƒ (U : Y.Opens) (V : X.Opens) (_ : x âˆˆ V.1) (e : V â‰¤ f â»Â¹áµ U),\n      P (f.resLE U V e) := by\n  refine âŸ¨fun hf x â†¦ âŸ¨âŠ¤, âŠ¤, trivial, by simp, resLE _ hfâŸ©, fun hf â†¦ ?_âŸ©\n  choose U V hxU e hf using hf\n  rw [IsLocalAtSource.iff_of_iSup_eq_top (fun x : X â†¦ V x) (P := P)]\n  Â· intro x\n    rw [â† Scheme.Hom.resLE_comp_Î¹ _ (e x)]\n    exact MorphismProperty.RespectsRight.postcomp (Q := @IsOpenImmersion) _ inferInstance _ (hf x)\n  Â· rw [eq_top_iff]\n    rintro x -\n    simp only [Opens.coe_iSup, Set.mem_iUnion, SetLike.mem_coe]\n    use x, hxU x\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.ext","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : AlgebraicGeometry.AffineTargetMorphismProperty\nH : âˆ€ â¦ƒX Y : AlgebraicGeometry.Schemeâ¦„ (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y], Iff (P f) (Q f)\nâŠ¢ Eq P Q","decl":"@[ext]\nlemma ext {P Q : AffineTargetMorphismProperty}\n    (H : âˆ€ â¦ƒX Y : Schemeâ¦„ (f : X âŸ¶ Y) [IsAffine Y], P f â†” Q f) : P = Q := by\n  delta AffineTargetMorphismProperty; ext; exact H _\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.ext_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P Q : AlgebraicGeometry.AffineTargetMorphismProperty\nâŠ¢ Iff (Eq P Q) (âˆ€ â¦ƒX Y : AlgebraicGeometry.Schemeâ¦„ (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y], Iff (P f) (Q f))","decl":"@[ext]\nlemma ext {P Q : AffineTargetMorphismProperty}\n    (H : âˆ€ â¦ƒX Y : Schemeâ¦„ (f : X âŸ¶ Y) [IsAffine Y], P f â†” Q f) : P = Q := by\n  delta AffineTargetMorphismProperty; ext; exact H _\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.toProperty_apply","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ni : AlgebraicGeometry.IsAffine Y\nâŠ¢ Iff (P.toProperty f) (P f)","decl":"theorem toProperty_apply (P : AffineTargetMorphismProperty)\n    {X Y : Scheme} (f : X âŸ¶ Y) [i : IsAffine Y] : P.toProperty f â†” P f := by\n  delta AffineTargetMorphismProperty.toProperty; simp [*]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.cancel_left_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ² : P.toProperty.RespectsIso\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ¹ : CategoryTheory.IsIso f\ninstâœ : AlgebraicGeometry.IsAffine Z\nâŠ¢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P g)","decl":"theorem cancel_left_of_respectsIso\n    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    {X Y Z : Scheme} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsIso f] [IsAffine Z] : P (f â‰« g) â†” P g := by\n  rw [â† P.toProperty_apply, â† P.toProperty_apply, P.toProperty.cancel_left_of_respectsIso]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.cancel_right_of_respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ³ : P.toProperty.RespectsIso\nX Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\ninstâœÂ² : CategoryTheory.IsIso g\ninstâœÂ¹ : AlgebraicGeometry.IsAffine Z\ninstâœ : AlgebraicGeometry.IsAffine Y\nâŠ¢ Iff (P (CategoryTheory.CategoryStruct.comp f g)) (P f)","decl":"theorem cancel_right_of_respectsIso\n    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    {X Y Z : Scheme} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) [IsIso g] [IsAffine Z] [IsAffine Y] :\n    P (f â‰« g) â†” P f := by rw [â† P.toProperty_apply, â† P.toProperty_apply,\n      P.toProperty.cancel_right_of_respectsIso]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.arrow_mk_iso_iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : P.toProperty.RespectsIso\nX Y X' Y' : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nf' : Quiver.Hom X' Y'\ne : CategoryTheory.Iso (CategoryTheory.Arrow.mk f) (CategoryTheory.Arrow.mk f')\nh : AlgebraicGeometry.IsAffine Y\nâŠ¢ Iff (P f) (P f')","decl":"theorem arrow_mk_iso_iff\n    (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    {X Y X' Y' : Scheme} {f : X âŸ¶ Y} {f' : X' âŸ¶ Y'}\n    (e : Arrow.mk f â‰… Arrow.mk f') {h : IsAffine Y} :\n    letI : IsAffine Y' := isAffine_of_isIso (Y := Y) e.inv.right\n    P f â†” P f' := by\n  rw [â† P.toProperty_apply, â† P.toProperty_apply, P.toProperty.arrow_mk_iso_iff e]\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_mk","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nhâ‚ : âˆ€ {X Y Z : AlgebraicGeometry.Scheme} (e : CategoryTheory.Iso X Y) (f : Quiver.Hom Y Z) [inst : AlgebraicGeometry.IsAffine Z], P f â†’ P (CategoryTheory.CategoryStruct.comp e.hom f)\nhâ‚‚ : âˆ€ {X Y Z : AlgebraicGeometry.Scheme} (e : CategoryTheory.Iso Y Z) (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y], P f â†’ P (CategoryTheory.CategoryStruct.comp f e.hom)\nâŠ¢ P.toProperty.RespectsIso","decl":"theorem respectsIso_mk {P : AffineTargetMorphismProperty}\n    (hâ‚ : âˆ€ {X Y Z} (e : X â‰… Y) (f : Y âŸ¶ Z) [IsAffine Z], P f â†’ P (e.hom â‰« f))\n    (hâ‚‚ : âˆ€ {X Y Z} (e : Y â‰… Z) (f : X âŸ¶ Y) [IsAffine Y],\n      P f â†’ @P _ _ (f â‰« e.hom) (isAffine_of_isIso e.inv)) :\n    P.toProperty.RespectsIso := by\n  apply MorphismProperty.RespectsIso.mk\n  Â· rintro X Y Z e f âŸ¨a, hâŸ©; exact âŸ¨a, hâ‚ e f hâŸ©\n  Â· rintro X Y Z e f âŸ¨a, hâŸ©; exact âŸ¨isAffine_of_isIso e.inv, hâ‚‚ e f hâŸ©\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.respectsIso_of","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : P.RespectsIso\nâŠ¢ (AlgebraicGeometry.AffineTargetMorphismProperty.of P).toProperty.RespectsIso","decl":"instance respectsIso_of\n    (P : MorphismProperty Scheme) [P.RespectsIso] :\n    (of P).toProperty.RespectsIso := by\n  apply respectsIso_mk\n  Â· intro _ _ _ _ _ _; apply MorphismProperty.RespectsIso.precomp\n  Â· intro _ _ _ _ _ _; apply MorphismProperty.RespectsIso.postcomp\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.respectsIso","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nself : P.IsLocal\nâŠ¢ P.toProperty.RespectsIso","decl":"/-- We say that `P : AffineTargetMorphismProperty` is a local property if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ Y.basicOpen r` for any\n  global section `r`.\n3. If `P` holds for `f âˆ£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,\n  then `P` holds for `f`.\n-/\nclass IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  /-- `P` as a morphism property respects isomorphisms -/\n  respectsIso : P.toProperty.RespectsIso\n  /-- `P` is stable under restriction to basic open set of global sections. -/\n  to_basicOpen :\n    âˆ€ {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) (r : Î“(Y, âŠ¤)), P f â†’ P (f âˆ£_ Y.basicOpen r)\n  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\n    sections -/\n  of_basicOpenCover :\n    âˆ€ {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) (s : Finset Î“(Y, âŠ¤))\n      (_ : Ideal.span (s : Set Î“(Y, âŠ¤)) = âŠ¤), (âˆ€ r : s, P (f âˆ£_ Y.basicOpen r.1)) â†’ P f\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.to_basicOpen","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nself : P.IsLocal\nX Y : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\nr : â†‘(Y.presheaf.obj { unop := Top.top })\naâœ : P f\nâŠ¢ P (AlgebraicGeometry.morphismRestrict f (Y.basicOpen r))","decl":"/-- We say that `P : AffineTargetMorphismProperty` is a local property if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ Y.basicOpen r` for any\n  global section `r`.\n3. If `P` holds for `f âˆ£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,\n  then `P` holds for `f`.\n-/\nclass IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  /-- `P` as a morphism property respects isomorphisms -/\n  respectsIso : P.toProperty.RespectsIso\n  /-- `P` is stable under restriction to basic open set of global sections. -/\n  to_basicOpen :\n    âˆ€ {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) (r : Î“(Y, âŠ¤)), P f â†’ P (f âˆ£_ Y.basicOpen r)\n  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\n    sections -/\n  of_basicOpenCover :\n    âˆ€ {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) (s : Finset Î“(Y, âŠ¤))\n      (_ : Ideal.span (s : Set Î“(Y, âŠ¤)) = âŠ¤), (âˆ€ r : s, P (f âˆ£_ Y.basicOpen r.1)) â†’ P f\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal.of_basicOpenCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\nself : P.IsLocal\nX Y : AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsAffine Y\nf : Quiver.Hom X Y\ns : Finset â†‘(Y.presheaf.obj { unop := Top.top })\nxâœ : Eq (Ideal.span â†‘s) Top.top\naâœ : âˆ€ (r : Subtype fun x => Membership.mem s x), P (AlgebraicGeometry.morphismRestrict f (Y.basicOpen â†‘r))\nâŠ¢ P f","decl":"/-- We say that `P : AffineTargetMorphismProperty` is a local property if\n1. `P` respects isomorphisms.\n2. If `P` holds for `f : X âŸ¶ Y`, then `P` holds for `f âˆ£_ Y.basicOpen r` for any\n  global section `r`.\n3. If `P` holds for `f âˆ£_ Y.basicOpen r` for all `r` in a spanning set of the global sections,\n  then `P` holds for `f`.\n-/\nclass IsLocal (P : AffineTargetMorphismProperty) : Prop where\n  /-- `P` as a morphism property respects isomorphisms -/\n  respectsIso : P.toProperty.RespectsIso\n  /-- `P` is stable under restriction to basic open set of global sections. -/\n  to_basicOpen :\n    âˆ€ {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) (r : Î“(Y, âŠ¤)), P f â†’ P (f âˆ£_ Y.basicOpen r)\n  /-- `P` for `f` if `P` holds for `f` restricted to basic sets of a spanning set of the global\n    sections -/\n  of_basicOpenCover :\n    âˆ€ {X Y : Scheme} [IsAffine Y] (f : X âŸ¶ Y) (s : Finset Î“(Y, âŠ¤))\n      (_ : Ideal.span (s : Set Î“(Y, âŠ¤)) = âŠ¤), (âˆ€ r : s, P (f âˆ£_ Y.basicOpen r.1)) â†’ P f\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.instIsLocalOfOfIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtTarget P\nâŠ¢ (AlgebraicGeometry.AffineTargetMorphismProperty.of P).IsLocal","decl":"open AffineTargetMorphismProperty in\ninstance (P : MorphismProperty Scheme) [IsLocalAtTarget P] : (of P).IsLocal where\n  respectsIso := inferInstance\n  to_basicOpen _ _ H := IsLocalAtTarget.restrict H _\n  of_basicOpenCover {_ Y} _ _ _ hs := IsLocalAtTarget.of_iSup_eq_top _\n    (((isAffineOpen_top Y).basicOpen_union_eq_self_iff _).mpr hs)\n\n"}
{"name":"AlgebraicGeometry.AffineTargetMorphismProperty.IsStableUnderBaseChange.mk","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : P.toProperty.RespectsIso\nH : âˆ€ â¦ƒX Y S : AlgebraicGeometry.Schemeâ¦„ [inst : AlgebraicGeometry.IsAffine S] [inst_1 : AlgebraicGeometry.IsAffine X] (f : Quiver.Hom X S) (g : Quiver.Hom Y S), P g â†’ P (CategoryTheory.Limits.pullback.fst f g)\nâŠ¢ P.IsStableUnderBaseChange","decl":"lemma IsStableUnderBaseChange.mk (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso]\n    (H : âˆ€ â¦ƒX Y S : Schemeâ¦„ [IsAffine S] [IsAffine X] (f : X âŸ¶ S) (g : Y âŸ¶ S),\n      P g â†’ P (pullback.fst f g)) : P.IsStableUnderBaseChange := by\n  intros Z X Y S _ _ f g f' g' h hg\n  rw [â† P.cancel_left_of_respectsIso h.isoPullback.inv, h.isoPullback_inv_fst]\n  exact H f g hg\n\n"}
{"name":"AlgebraicGeometry.of_targetAffineLocally_of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ² : P.IsLocal\nX Y UX UY : AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsAffine UY\nf : Quiver.Hom X Y\niY : Quiver.Hom UY Y\ninstâœ : AlgebraicGeometry.IsOpenImmersion iY\niX : Quiver.Hom UX X\nf' : Quiver.Hom UX UY\nh : CategoryTheory.IsPullback iX f' f iY\nhf : AlgebraicGeometry.targetAffineLocally P f\nâŠ¢ P f'","decl":"theorem of_targetAffineLocally_of_isPullback\n    {P : AffineTargetMorphismProperty} [P.IsLocal]\n    {X Y UX UY : Scheme.{u}} [IsAffine UY] {f : X âŸ¶ Y} {iY : UY âŸ¶ Y} [IsOpenImmersion iY]\n    {iX : UX âŸ¶ X} {f' : UX âŸ¶ UY} (h : IsPullback iX f' f iY) (hf : targetAffineLocally P f) :\n    P f' := by\n  rw [â† P.cancel_left_of_respectsIso h.isoPullback.inv, h.isoPullback_inv_snd]\n  exact (P.arrow_mk_iso_iff\n    (morphismRestrictOpensRange f _)).mp (hf âŸ¨_, isAffineOpen_opensRange iYâŸ©)\n\n"}
{"name":"AlgebraicGeometry.instRespectsIsoSchemeTargetAffineLocallyOfToProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : P.toProperty.RespectsIso\nâŠ¢ (AlgebraicGeometry.targetAffineLocally P).RespectsIso","decl":"instance (P : AffineTargetMorphismProperty) [P.toProperty.RespectsIso] :\n    (targetAffineLocally P).RespectsIso := by\n  apply MorphismProperty.RespectsIso.mk\n  Â· introv H U\n    rw [morphismRestrict_comp, P.cancel_left_of_respectsIso]\n    exact H U\n  Â· introv H\n    rintro âŸ¨U, hU : IsAffineOpen UâŸ©; dsimp\n    haveI : IsAffine _ := hU.preimage_of_isIso e.hom\n    rw [morphismRestrict_comp, P.cancel_right_of_respectsIso]\n    exact H âŸ¨(Opens.map e.hom.base).obj U, hU.preimage_of_isIso e.homâŸ©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.eq_targetAffineLocally'","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam AlgebraicGeometry.AffineTargetMorphismProperty\nself : AlgebraicGeometry.HasAffineProperty P Q\nâŠ¢ Eq P (AlgebraicGeometry.targetAffineLocally Q)","decl":"/--\n`HasAffineProperty P Q` is a type class asserting that `P` is local at the target, and over affine\nschemes, it is equivalent to `Q : AffineTargetMorphismProperty`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local at the target\n2. `P f` if and only if `âˆ€ U, Q (f âˆ£_ U)` ranging over all affine opens of `U`.\nSee `HasAffineProperty.iff`.\n-/\nclass HasAffineProperty (P : MorphismProperty Scheme)\n    (Q : outParam AffineTargetMorphismProperty) : Prop where\n  isLocal_affineProperty : Q.IsLocal\n  eq_targetAffineLocally' : P = targetAffineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.isLocal_affineProperty","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : outParam AlgebraicGeometry.AffineTargetMorphismProperty\nself : AlgebraicGeometry.HasAffineProperty P Q\nâŠ¢ AlgebraicGeometry.AffineTargetMorphismProperty.IsLocal Q","decl":"/--\n`HasAffineProperty P Q` is a type class asserting that `P` is local at the target, and over affine\nschemes, it is equivalent to `Q : AffineTargetMorphismProperty`.\nTo make the proofs easier, we state it instead as\n1. `Q` is local at the target\n2. `P f` if and only if `âˆ€ U, Q (f âˆ£_ U)` ranging over all affine opens of `U`.\nSee `HasAffineProperty.iff`.\n-/\nclass HasAffineProperty (P : MorphismProperty Scheme)\n    (Q : outParam AffineTargetMorphismProperty) : Prop where\n  isLocal_affineProperty : Q.IsLocal\n  eq_targetAffineLocally' : P = targetAffineLocally Q\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.instTargetAffineLocallyOfIsLocal","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"Q : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : Q.IsLocal\nâŠ¢ AlgebraicGeometry.HasAffineProperty (AlgebraicGeometry.targetAffineLocally Q) Q","decl":"instance (Q : AffineTargetMorphismProperty) [Q.IsLocal] :\n    HasAffineProperty (targetAffineLocally Q) Q :=\n  âŸ¨inferInstance, rflâŸ©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.eq_targetAffineLocally","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nâŠ¢ Eq P (AlgebraicGeometry.targetAffineLocally Q)","decl":"lemma eq_targetAffineLocally : P = targetAffineLocally Q := eq_targetAffineLocally'\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_isLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\ninstâœ : AlgebraicGeometry.IsLocalAtTarget P\nâŠ¢ AlgebraicGeometry.HasAffineProperty P (AlgebraicGeometry.AffineTargetMorphismProperty.of P)","decl":"/-- Every property local at the target can be associated with an affine target property.\nThis is not an instance as the associated property can often take on simpler forms. -/\nlemma of_isLocalAtTarget (P) [IsLocalAtTarget P] :\n    HasAffineProperty P (AffineTargetMorphismProperty.of P) where\n  isLocal_affineProperty := inferInstance\n  eq_targetAffineLocally' := by\n    ext X Y f\n    constructor\n    Â· intro hf âŸ¨U, hUâŸ©\n      exact IsLocalAtTarget.restrict hf _\n    Â· intro hf\n      exact IsLocalAtTarget.of_openCover (P := P) Y.affineCover\n        fun i â†¦ of_targetAffineLocally_of_isPullback (.of_hasPullback _ _) hf\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.copy","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P P' : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ Q' : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\ne : Eq P P'\ne' : Eq Q Q'\nâŠ¢ AlgebraicGeometry.HasAffineProperty P' Q'","decl":"lemma copy {P P'} {Q Q'} [HasAffineProperty P Q]\n    (e : P = P') (e' : Q = Q') : HasAffineProperty P' Q' where\n  isLocal_affineProperty := e' â–¸ isLocal_affineProperty P\n  eq_targetAffineLocally' := e' â–¸ e.symm â–¸ eq_targetAffineLocally P\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_isPullback","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ² : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nUX UY : AlgebraicGeometry.Scheme\ninstâœÂ¹ : AlgebraicGeometry.IsAffine UY\niY : Quiver.Hom UY Y\ninstâœ : AlgebraicGeometry.IsOpenImmersion iY\niX : Quiver.Hom UX X\nf' : Quiver.Hom UX UY\nh : CategoryTheory.IsPullback iX f' f iY\nhf : P f\nâŠ¢ Q f'","decl":"theorem of_isPullback {UX UY : Scheme.{u}} [IsAffine UY] {iY : UY âŸ¶ Y} [IsOpenImmersion iY]\n    {iX : UX âŸ¶ X} {f' : UX âŸ¶ UY} (h : IsPullback iX f' f iY) (hf : P f) :\n    Q f' :=\n  letI := isLocal_affineProperty P\n  of_targetAffineLocally_of_isPullback h (eq_targetAffineLocally (P := P) â–¸ hf)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.restrict","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nhf : P f\nU : â†‘Y.affineOpens\nâŠ¢ Q (AlgebraicGeometry.morphismRestrict f â†‘U)","decl":"theorem restrict (hf : P f) (U : Y.affineOpens) :\n    Q (f âˆ£_ U) :=\n  of_isPullback (isPullback_morphismRestrict f U).flip hf\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.instRespectsIsoScheme","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nâŠ¢ P.RespectsIso","decl":"instance (priority := 900) : P.RespectsIso := by\n  letI := isLocal_affineProperty P\n  rw [eq_targetAffineLocally P]\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nÎ¹ : Sort u_1\nU : Î¹ â†’ â†‘Y.affineOpens\nhU : Eq (iSup fun i => â†‘(U i)) Top.top\nhU' : âˆ€ (i : Î¹), Q (AlgebraicGeometry.morphismRestrict f â†‘(U i))\nâŠ¢ P f","decl":"theorem of_iSup_eq_top\n    {Î¹} (U : Î¹ â†’ Y.affineOpens) (hU : â¨† i, (U i : Y.Opens) = âŠ¤)\n    (hU' : âˆ€ i, Q (f âˆ£_ U i)) :\n    P f := by\n  letI := isLocal_affineProperty P\n  rw [eq_targetAffineLocally P]\n  classical\n  intro V\n  induction V using of_affine_open_cover U hU  with\n  | basicOpen U r h =>\n    haveI : IsAffine _ := U.2\n    have := AffineTargetMorphismProperty.IsLocal.to_basicOpen (f âˆ£_ U.1) (U.1.topIso.inv r) h\n    exact (Q.arrow_mk_iso_iff\n      (morphismRestrictRestrictBasicOpen f _ r)).mp this\n  | openCover U s hs H =>\n    apply AffineTargetMorphismProperty.IsLocal.of_basicOpenCover _\n      (s.image (Scheme.Opens.topIso _).inv) (by simp [â† Ideal.map_span, hs, Ideal.map_top])\n    intro âŸ¨r, hrâŸ©\n    obtain âŸ¨r, hr', rflâŸ© := Finset.mem_image.mp hr\n    exact (Q.arrow_mk_iso_iff\n      (morphismRestrictRestrictBasicOpen f _ r).symm).mp (H âŸ¨r, hr'âŸ©)\n  | hU i => exact hU' i\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff_of_iSup_eq_top","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nÎ¹ : Sort u_1\nU : Î¹ â†’ â†‘Y.affineOpens\nhU : Eq (iSup fun i => â†‘(U i)) Top.top\nâŠ¢ Iff (P f) (âˆ€ (i : Î¹), Q (AlgebraicGeometry.morphismRestrict f â†‘(U i)))","decl":"theorem iff_of_iSup_eq_top\n    {Î¹} (U : Î¹ â†’ Y.affineOpens) (hU : â¨† i, (U i : Y.Opens) = âŠ¤) :\n    P f â†” âˆ€ i, Q (f âˆ£_ U i) :=\n  âŸ¨fun H _ â†¦ restrict H _, fun H â†¦ HasAffineProperty.of_iSup_eq_top U hU HâŸ©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ninstâœ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\nhğ’° : âˆ€ (i : ğ’°.1), Q (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i)\nâŠ¢ P f","decl":"theorem of_openCover\n    (ğ’° : Y.OpenCover) [âˆ€ i, IsAffine (ğ’°.obj i)] (hğ’° : âˆ€ i, Q (ğ’°.pullbackHom f i)) :\n    P f :=\n  letI := isLocal_affineProperty P\n  of_iSup_eq_top\n    (fun i â†¦ âŸ¨_, isAffineOpen_opensRange (ğ’°.map i)âŸ©) ğ’°.iSup_opensRange\n    (fun i â†¦ (Q.arrow_mk_iso_iff (morphismRestrictOpensRange f _)).mpr (hğ’° i))\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff_of_openCover","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nğ’° : Y.OpenCover\ninstâœ : âˆ€ (i : ğ’°.J), AlgebraicGeometry.IsAffine (ğ’°.obj i)\nâŠ¢ Iff (P f) (âˆ€ (i : ğ’°.1), Q (AlgebraicGeometry.Scheme.Cover.pullbackHom ğ’° f i))","decl":"theorem iff_of_openCover (ğ’° : Y.OpenCover) [âˆ€ i, IsAffine (ğ’°.obj i)] :\n    P f â†” âˆ€ i, Q (ğ’°.pullbackHom f i) := by\n  letI := isLocal_affineProperty P\n  rw [iff_of_iSup_eq_top (P := P)\n    (fun i â†¦ âŸ¨_, isAffineOpen_opensRange _âŸ©) ğ’°.iSup_opensRange]\n  exact forall_congr' fun i â†¦ Q.arrow_mk_iso_iff\n    (morphismRestrictOpensRange f _)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff_of_isAffine","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœÂ¹ : AlgebraicGeometry.HasAffineProperty P Q\nX Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninstâœ : AlgebraicGeometry.IsAffine Y\nâŠ¢ Iff (P f) (Q f)","decl":"theorem iff_of_isAffine [IsAffine Y] : P f â†” Q f := by\n  letI := isLocal_affineProperty P\n  haveI : âˆ€ i, IsAffine (Scheme.Cover.obj\n      (Scheme.coverOfIsIso (P := @IsOpenImmersion) (ğŸ™ Y)) i) := fun i => by\n    dsimp; infer_instance\n  rw [iff_of_openCover (P := P) (Scheme.coverOfIsIso.{0} (ğŸ™ Y))]\n  trans Q (pullback.snd f (ğŸ™ _))\n  Â· exact âŸ¨fun H => H PUnit.unit, fun H _ => HâŸ©\n  rw [â† Category.comp_id (pullback.snd _ _), â† pullback.condition,\n    Q.cancel_left_of_respectsIso]\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.instIsLocalAtTarget","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nâŠ¢ AlgebraicGeometry.IsLocalAtTarget P","decl":"instance (priority := 900) : IsLocalAtTarget P := by\n  letI := isLocal_affineProperty P\n  apply IsLocalAtTarget.mk'\n  Â· rw [eq_targetAffineLocally P]\n    intro X Y f U H V\n    rw [Q.arrow_mk_iso_iff (morphismRestrictRestrict f _ _)]\n    exact H âŸ¨_, V.2.image_of_isOpenImmersion (Y.ofRestrict _)âŸ©\n  Â· rintro X Y f Î¹ U hU H\n    let ğ’° := Y.openCoverOfISupEqTop U hU\n    apply of_openCover ğ’°.affineRefinement.openCover\n    rintro âŸ¨i, jâŸ©\n    have : P (ğ’°.pullbackHom f i) := by\n      refine (P.arrow_mk_iso_iff\n        (morphismRestrictEq _ ?_ â‰ªâ‰« morphismRestrictOpensRange f (ğ’°.map i))).mp (H i)\n      exact (Scheme.Opens.opensRange_Î¹ _).symm\n    rw [â† Q.cancel_left_of_respectsIso (ğ’°.pullbackCoverAffineRefinementObjIso f _).inv,\n      ğ’°.pullbackCoverAffineRefinementObjIso_inv_pullbackHom]\n    exact of_isPullback (.of_hasPullback _ _) this\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.iff","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\nâŠ¢ Iff (AlgebraicGeometry.HasAffineProperty P Q) (And (AlgebraicGeometry.IsLocalAtTarget P) (Eq Q (AlgebraicGeometry.AffineTargetMorphismProperty.of P)))","decl":"open AffineTargetMorphismProperty in\nprotected theorem iff {P : MorphismProperty Scheme} {Q : AffineTargetMorphismProperty} :\n    HasAffineProperty P Q â†” IsLocalAtTarget P âˆ§ Q = of P :=\n  âŸ¨fun _ â†¦ âŸ¨inferInstance, ext fun _ _ _ â†¦ iff_of_isAffine.symmâŸ©,\n    fun âŸ¨_, eâŸ© â†¦ e â–¸ of_isLocalAtTarget PâŸ©\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.isStableUnderBaseChange","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nhP' : Q.IsStableUnderBaseChange\nâŠ¢ P.IsStableUnderBaseChange","decl":"theorem isStableUnderBaseChange (hP' : Q.IsStableUnderBaseChange) :\n    P.IsStableUnderBaseChange :=\n  MorphismProperty.IsStableUnderBaseChange.mk'\n    (fun X Y S f g _ H => by\n      rw [IsLocalAtTarget.iff_of_openCover (P := P) (S.affineCover.pullbackCover f)]\n      intro i\n      let e : pullback (pullback.fst f g) ((S.affineCover.pullbackCover f).map i) â‰…\n          _ := by\n        refine pullbackSymmetry _ _ â‰ªâ‰« pullbackRightPullbackFstIso f g _ â‰ªâ‰« ?_ â‰ªâ‰«\n          (pullbackRightPullbackFstIso (S.affineCover.map i) g\n            (pullback.snd f (S.affineCover.map i))).symm\n        exact asIso\n          (pullback.map _ _ _ _ (ğŸ™ _) (ğŸ™ _) (ğŸ™ _) (by simpa using pullback.condition) (by simp))\n      have : e.hom â‰« pullback.fst _ _ =\n          (S.affineCover.pullbackCover f).pullbackHom (pullback.fst _ _) i := by\n        simp [e, Scheme.Cover.pullbackHom]\n      rw [â† this, P.cancel_left_of_respectsIso]\n      apply HasAffineProperty.pullback_fst_of_right hP'\n      letI := isLocal_affineProperty P\n      rw [â† pullbackSymmetry_hom_comp_snd, Q.cancel_left_of_respectsIso]\n      apply of_isPullback (.of_hasPullback _ _) H)\n\n"}
{"name":"AlgebraicGeometry.HasAffineProperty.isLocalAtSource","module":"Mathlib.AlgebraicGeometry.Morphisms.Basic","initialProofState":"P : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\nQ : AlgebraicGeometry.AffineTargetMorphismProperty\ninstâœ : AlgebraicGeometry.HasAffineProperty P Q\nH : âˆ€ {X Y : AlgebraicGeometry.Scheme} (f : Quiver.Hom X Y) [inst : AlgebraicGeometry.IsAffine Y] (ğ’° : X.OpenCover), Iff (Q f) (âˆ€ (i : ğ’°.J), Q (CategoryTheory.CategoryStruct.comp (ğ’°.map i) f))\nâŠ¢ AlgebraicGeometry.IsLocalAtSource P","decl":"lemma isLocalAtSource\n    (H : âˆ€ {X Y : Scheme.{u}} (f : X âŸ¶ Y) [IsAffine Y] (ğ’° : Scheme.OpenCover.{u} X),\n        Q f â†” âˆ€ i, Q (ğ’°.map i â‰« f)) : IsLocalAtSource P where\n  iff_of_openCover' {X Y} f ğ’° := by\n    simp_rw [IsLocalAtTarget.iff_of_iSup_eq_top _ (iSup_affineOpens_eq_top Y)]\n    rw [forall_comm]\n    refine forall_congr' fun U â†¦ ?_\n    simp_rw [HasAffineProperty.iff_of_isAffine, morphismRestrict_comp]\n    exact @H _ _ (f âˆ£_ U.1) U.2 (ğ’°.restrict (f â»Â¹áµ U.1))\n\n"}
