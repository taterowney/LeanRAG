{"name":"CategoryTheory.Projective.factors","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nP : C\nself : CategoryTheory.Projective P\nE X : C\nf : Quiver.Hom P X\ne : Quiver.Hom E X\ninst✝ : CategoryTheory.Epi e\n⊢ Exists fun f' => Eq (CategoryTheory.CategoryStruct.comp f' e) f","decl":"/--\nAn object `P` is called *projective* if every morphism out of `P` factors through every epimorphism.\n-/\nclass Projective (P : C) : Prop where\n  factors : ∀ {E X : C} (f : P ⟶ X) (e : E ⟶ X) [Epi e], ∃ f', f' ≫ e = f\n\n"}
{"name":"CategoryTheory.Limits.IsZero.projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsZero X\n⊢ CategoryTheory.Projective X","decl":"lemma Limits.IsZero.projective {X : C} (h : IsZero X) : Projective X where\n  factors _ _ _ := ⟨h.to_ _, h.eq_of_src _ _⟩\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nX : C\ninst✝ : SizeOf C\np : C\nprojective : CategoryTheory.Projective p\nf : Quiver.Hom p X\nepi : CategoryTheory.Epi f\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.ProjectivePresentation.mk p f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf p)) (SizeOf.sizeOf projective)) (SizeOf.sizeOf f)) (SizeOf.sizeOf epi))","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ⟶ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ⟶ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.epi","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nself : CategoryTheory.ProjectivePresentation X\n⊢ CategoryTheory.Epi self.f","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ⟶ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ⟶ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX : C\nself : CategoryTheory.ProjectivePresentation X\n⊢ CategoryTheory.Projective self.p","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ⟶ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ⟶ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX p✝ : C\nprojective✝ : CategoryTheory.Projective p✝\nf✝ : Quiver.Hom p✝ X\nepi✝ : CategoryTheory.Epi f✝\np : C\nprojective : CategoryTheory.Projective p\nf : Quiver.Hom p X\nepi : CategoryTheory.Epi f\nx✝ : Eq (CategoryTheory.ProjectivePresentation.mk p✝ f✝) (CategoryTheory.ProjectivePresentation.mk p f)\n⊢ And (Eq p✝ p) (HEq f✝ f)","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ⟶ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ⟶ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nX p✝ : C\nprojective✝ : CategoryTheory.Projective p✝\nf✝ : Quiver.Hom p✝ X\nepi✝ : CategoryTheory.Epi f✝\np : C\nprojective : CategoryTheory.Projective p\nf : Quiver.Hom p X\nepi : CategoryTheory.Epi f\n⊢ Eq (Eq (CategoryTheory.ProjectivePresentation.mk p✝ f✝) (CategoryTheory.ProjectivePresentation.mk p f)) (And (Eq p✝ p) (HEq f✝ f))","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ⟶ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ⟶ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.EnoughProjectives.presentation","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.EnoughProjectives C\nX : C\n⊢ Nonempty (CategoryTheory.ProjectivePresentation X)","decl":"/-- A category \"has enough projectives\" if for every object `X` there is a projective object `P` and\n    an epimorphism `P ↠ X`. -/\nclass EnoughProjectives : Prop where\n  presentation : ∀ X : C, Nonempty (ProjectivePresentation X)\n\n"}
{"name":"CategoryTheory.Projective.factorThru_comp_assoc","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP X E : C\ninst✝¹ : CategoryTheory.Projective P\nf : Quiver.Hom P X\ne : Quiver.Hom E X\ninst✝ : CategoryTheory.Epi e\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Projective.factorThru f e) (CategoryTheory.CategoryStruct.comp e h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem factorThru_comp {P X E : C} [Projective P] (f : P ⟶ X) (e : E ⟶ X) [Epi e] :\n    factorThru f e ≫ e = f :=\n  (Projective.factors f e).choose_spec\n\n"}
{"name":"CategoryTheory.Projective.factorThru_comp","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nP X E : C\ninst✝¹ : CategoryTheory.Projective P\nf : Quiver.Hom P X\ne : Quiver.Hom E X\ninst✝ : CategoryTheory.Epi e\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Projective.factorThru f e) e) f","decl":"@[reassoc (attr := simp)]\ntheorem factorThru_comp {P X E : C} [Projective P] (f : P ⟶ X) (e : E ⟶ X) [Epi e] :\n    factorThru f e ≫ e = f :=\n  (Projective.factors f e).choose_spec\n\n"}
{"name":"CategoryTheory.Projective.zero_projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroObject C\n⊢ CategoryTheory.Projective 0","decl":"instance zero_projective [HasZeroObject C] : Projective (0 : C) :=\n  (isZero_zero C).projective\n\n"}
{"name":"CategoryTheory.Projective.of_iso","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : C\ni : CategoryTheory.Iso P Q\nx✝ : CategoryTheory.Projective P\n⊢ CategoryTheory.Projective Q","decl":"theorem of_iso {P Q : C} (i : P ≅ Q) (_ : Projective P) : Projective Q where\n  factors f e _ :=\n    let ⟨f', hf'⟩ := Projective.factors (i.hom ≫ f) e\n    ⟨i.inv ≫ f', by simp [hf']⟩\n\n"}
{"name":"CategoryTheory.Projective.iso_iff","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP Q : C\ni : CategoryTheory.Iso P Q\n⊢ Iff (CategoryTheory.Projective P) (CategoryTheory.Projective Q)","decl":"theorem iso_iff {P Q : C} (i : P ≅ Q) : Projective P ↔ Projective Q :=\n  ⟨of_iso i, of_iso i.symm⟩\n\n"}
{"name":"CategoryTheory.Projective.inst","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"X : Type u\n⊢ CategoryTheory.Projective X","decl":"/-- The axiom of choice says that every type is a projective object in `Type`. -/\ninstance (X : Type u) : Projective X where\n  factors f e _ :=\n    have he : Function.Surjective e := surjective_of_epi e\n    ⟨fun x => (he (f x)).choose, funext fun x ↦ (he (f x)).choose_spec⟩\n\n"}
{"name":"CategoryTheory.Projective.Type.enoughProjectives","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"⊢ CategoryTheory.EnoughProjectives (Type u)","decl":"instance Type.enoughProjectives : EnoughProjectives (Type u) where\n  presentation X := ⟨⟨X, 𝟙 X⟩⟩\n\n"}
{"name":"CategoryTheory.Projective.instCoprod","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝² : CategoryTheory.Limits.HasBinaryCoproduct P Q\ninst✝¹ : CategoryTheory.Projective P\ninst✝ : CategoryTheory.Projective Q\n⊢ CategoryTheory.Projective (CategoryTheory.Limits.coprod P Q)","decl":"instance {P Q : C} [HasBinaryCoproduct P Q] [Projective P] [Projective Q] : Projective (P ⨿ Q) where\n  factors f e epi := ⟨coprod.desc (factorThru (coprod.inl ≫ f) e) (factorThru (coprod.inr ≫ f) e),\n    by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Projective.instSigmaObj","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nβ : Type v\ng : β → C\ninst✝¹ : CategoryTheory.Limits.HasCoproduct g\ninst✝ : ∀ (b : β), CategoryTheory.Projective (g b)\n⊢ CategoryTheory.Projective (CategoryTheory.Limits.sigmaObj g)","decl":"instance {β : Type v} (g : β → C) [HasCoproduct g] [∀ b, Projective (g b)] : Projective (∐ g) where\n  factors f e epi := ⟨Sigma.desc fun b => factorThru (Sigma.ι g b ≫ f) e, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Projective.instBiprod","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝² : CategoryTheory.Limits.HasBinaryBiproduct P Q\ninst✝¹ : CategoryTheory.Projective P\ninst✝ : CategoryTheory.Projective Q\n⊢ CategoryTheory.Projective (CategoryTheory.Limits.biprod P Q)","decl":"instance {P Q : C} [HasZeroMorphisms C] [HasBinaryBiproduct P Q] [Projective P] [Projective Q] :\n    Projective (P ⊞ Q) where\n  factors f e epi := ⟨biprod.desc (factorThru (biprod.inl ≫ f) e) (factorThru (biprod.inr ≫ f) e),\n    by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Projective.instBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nβ : Type v\ng : β → C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝¹ : CategoryTheory.Limits.HasBiproduct g\ninst✝ : ∀ (b : β), CategoryTheory.Projective (g b)\n⊢ CategoryTheory.Projective (CategoryTheory.Limits.biproduct g)","decl":"instance {β : Type v} (g : β → C) [HasZeroMorphisms C] [HasBiproduct g] [∀ b, Projective (g b)] :\n    Projective (⨁ g) where\n  factors f e epi := ⟨biproduct.desc fun b => factorThru (biproduct.ι g b ≫ f) e, by aesop_cat⟩\n\n"}
{"name":"CategoryTheory.Projective.projective_iff_preservesEpimorphisms_coyoneda_obj","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nP : C\n⊢ Iff (CategoryTheory.Projective P) (CategoryTheory.coyoneda.obj { unop := P }).PreservesEpimorphisms","decl":"theorem projective_iff_preservesEpimorphisms_coyoneda_obj (P : C) :\n    Projective P ↔ (coyoneda.obj (op P)).PreservesEpimorphisms :=\n  ⟨fun hP =>\n    ⟨fun f _ =>\n      (epi_iff_surjective _).2 fun g =>\n        have : Projective (unop (op P)) := hP\n        ⟨factorThru g f, factorThru_comp _ _⟩⟩,\n    fun _ =>\n    ⟨fun f e _ =>\n      (epi_iff_surjective _).1 (inferInstance : Epi ((coyoneda.obj (op P)).map e)) f⟩⟩\n\n"}
{"name":"CategoryTheory.Projective.projective_over","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnoughProjectives C\nX : C\n⊢ CategoryTheory.Projective (CategoryTheory.Projective.over X)","decl":"instance projective_over (X : C) : Projective (over X) :=\n  (EnoughProjectives.presentation X).some.projective\n\n"}
{"name":"CategoryTheory.Projective.π_epi","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.EnoughProjectives C\nX : C\n⊢ CategoryTheory.Epi (CategoryTheory.Projective.π X)","decl":"instance π_epi (X : C) : Epi (π X) :=\n  (EnoughProjectives.presentation X).some.epi\n\n"}
{"name":"CategoryTheory.Projective.instSyzygies","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.EnoughProjectives C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Limits.HasKernel f\n⊢ CategoryTheory.Projective (CategoryTheory.Projective.syzygies f)","decl":"instance : Projective (syzygies f) := inferInstanceAs (Projective (over _))\n\n"}
{"name":"CategoryTheory.Adjunction.map_projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝ : G.PreservesEpimorphisms\nP : C\nhP : CategoryTheory.Projective P\n⊢ CategoryTheory.Projective (F.obj P)","decl":"theorem map_projective (adj : F ⊣ G) [G.PreservesEpimorphisms] (P : C) (hP : Projective P) :\n    Projective (F.obj P) where\n  factors f g _ := by\n    rcases hP.factors (adj.unit.app P ≫ G.map f) (G.map g) with ⟨f', hf'⟩\n    use F.map f' ≫ adj.counit.app _\n    rw [Category.assoc, ← Adjunction.counit_naturality, ← Category.assoc, ← F.map_comp, hf']\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.projective_of_map_projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nP : C\nhP : CategoryTheory.Projective (F.obj P)\n⊢ CategoryTheory.Projective P","decl":"theorem projective_of_map_projective (adj : F ⊣ G) [F.Full] [F.Faithful] (P : C)\n    (hP : Projective (F.obj P)) : Projective P where\n  factors f g _ := by\n    haveI := Adjunction.leftAdjoint_preservesColimits.{0, 0} adj\n    rcases (@hP).1 (F.map f) (F.map g) with ⟨f', hf'⟩\n    use adj.unit.app _ ≫ G.map f' ≫ (inv <| adj.unit.app _)\n    exact F.map_injective (by simpa)\n\n"}
{"name":"CategoryTheory.Equivalence.map_projective_iff","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Equivalence C D\nP : C\n⊢ Iff (CategoryTheory.Projective (F.functor.obj P)) (CategoryTheory.Projective P)","decl":"theorem map_projective_iff (P : C) : Projective (F.functor.obj P) ↔ Projective P :=\n  ⟨F.toAdjunction.projective_of_map_projective P, F.toAdjunction.map_projective P⟩\n\n"}
{"name":"CategoryTheory.Equivalence.enoughProjectives_iff","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Equivalence C D\n⊢ Iff (CategoryTheory.EnoughProjectives C) (CategoryTheory.EnoughProjectives D)","decl":"theorem enoughProjectives_iff (F : C ≌ D) : EnoughProjectives C ↔ EnoughProjectives D := by\n  constructor\n  all_goals intro H; constructor; intro X; constructor\n  · exact F.symm.projectivePresentationOfMapProjectivePresentation _\n      (Nonempty.some (H.presentation (F.inverse.obj X)))\n  · exact F.projectivePresentationOfMapProjectivePresentation X\n      (Nonempty.some (H.presentation (F.functor.obj X)))\n\n"}
