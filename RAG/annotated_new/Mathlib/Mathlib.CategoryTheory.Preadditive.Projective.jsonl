{"name":"CategoryTheory.Projective.factors","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nP : C\nself : CategoryTheory.Projective P\nE X : C\nf : Quiver.Hom P X\ne : Quiver.Hom E X\ninst‚úù : CategoryTheory.Epi e\n‚ä¢ Exists fun f' => Eq (CategoryTheory.CategoryStruct.comp f' e) f","decl":"/--\nAn object `P` is called *projective* if every morphism out of `P` factors through every epimorphism.\n-/\nclass Projective (P : C) : Prop where\n  factors : ‚àÄ {E X : C} (f : P ‚ü∂ X) (e : E ‚ü∂ X) [Epi e], ‚àÉ f', f' ‚â´ e = f\n\n"}
{"name":"CategoryTheory.Limits.IsZero.projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nh : CategoryTheory.Limits.IsZero X\n‚ä¢ CategoryTheory.Projective X","decl":"lemma Limits.IsZero.projective {X : C} (h : IsZero X) : Projective X where\n  factors _ _ _ := ‚ü®h.to_ _, h.eq_of_src _ _‚ü©\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nX : C\ninst‚úù : SizeOf C\np : C\nprojective : CategoryTheory.Projective p\nf : Quiver.Hom p X\nepi : CategoryTheory.Epi f\n‚ä¢ Eq (SizeOf.sizeOf (CategoryTheory.ProjectivePresentation.mk p f)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf p)) (SizeOf.sizeOf projective)) (SizeOf.sizeOf f)) (SizeOf.sizeOf epi))","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ‚ü∂ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ‚ü∂ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.epi","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nself : CategoryTheory.ProjectivePresentation X\n‚ä¢ CategoryTheory.Epi self.f","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ‚ü∂ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ‚ü∂ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX : C\nself : CategoryTheory.ProjectivePresentation X\n‚ä¢ CategoryTheory.Projective self.p","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ‚ü∂ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ‚ü∂ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.mk.inj","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX p‚úù : C\nprojective‚úù : CategoryTheory.Projective p‚úù\nf‚úù : Quiver.Hom p‚úù X\nepi‚úù : CategoryTheory.Epi f‚úù\np : C\nprojective : CategoryTheory.Projective p\nf : Quiver.Hom p X\nepi : CategoryTheory.Epi f\nx‚úù : Eq (CategoryTheory.ProjectivePresentation.mk p‚úù f‚úù) (CategoryTheory.ProjectivePresentation.mk p f)\n‚ä¢ And (Eq p‚úù p) (HEq f‚úù f)","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ‚ü∂ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ‚ü∂ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.ProjectivePresentation.mk.injEq","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX p‚úù : C\nprojective‚úù : CategoryTheory.Projective p‚úù\nf‚úù : Quiver.Hom p‚úù X\nepi‚úù : CategoryTheory.Epi f‚úù\np : C\nprojective : CategoryTheory.Projective p\nf : Quiver.Hom p X\nepi : CategoryTheory.Epi f\n‚ä¢ Eq (Eq (CategoryTheory.ProjectivePresentation.mk p‚úù f‚úù) (CategoryTheory.ProjectivePresentation.mk p f)) (And (Eq p‚úù p) (HEq f‚úù f))","decl":"/-- A projective presentation of an object `X` consists of an epimorphism `f : P ‚ü∂ X`\nfrom some projective object `P`.\n-/\nstructure ProjectivePresentation (X : C) where\n  p : C\n  [projective : Projective p]\n  f : p ‚ü∂ X\n  [epi : Epi f]\n\n"}
{"name":"CategoryTheory.EnoughProjectives.presentation","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.EnoughProjectives C\nX : C\n‚ä¢ Nonempty (CategoryTheory.ProjectivePresentation X)","decl":"/-- A category \"has enough projectives\" if for every object `X` there is a projective object `P` and\n    an epimorphism `P ‚Ü† X`. -/\nclass EnoughProjectives : Prop where\n  presentation : ‚àÄ X : C, Nonempty (ProjectivePresentation X)\n\n"}
{"name":"CategoryTheory.Projective.factorThru_comp_assoc","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP X E : C\ninst‚úù¬π : CategoryTheory.Projective P\nf : Quiver.Hom P X\ne : Quiver.Hom E X\ninst‚úù : CategoryTheory.Epi e\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Projective.factorThru f e) (CategoryTheory.CategoryStruct.comp e h)) (CategoryTheory.CategoryStruct.comp f h)","decl":"@[reassoc (attr := simp)]\ntheorem factorThru_comp {P X E : C} [Projective P] (f : P ‚ü∂ X) (e : E ‚ü∂ X) [Epi e] :\n    factorThru f e ‚â´ e = f :=\n  (Projective.factors f e).choose_spec\n\n"}
{"name":"CategoryTheory.Projective.factorThru_comp","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nP X E : C\ninst‚úù¬π : CategoryTheory.Projective P\nf : Quiver.Hom P X\ne : Quiver.Hom E X\ninst‚úù : CategoryTheory.Epi e\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Projective.factorThru f e) e) f","decl":"@[reassoc (attr := simp)]\ntheorem factorThru_comp {P X E : C} [Projective P] (f : P ‚ü∂ X) (e : E ‚ü∂ X) [Epi e] :\n    factorThru f e ‚â´ e = f :=\n  (Projective.factors f e).choose_spec\n\n"}
{"name":"CategoryTheory.Projective.zero_projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.Limits.HasZeroObject C\n‚ä¢ CategoryTheory.Projective 0","decl":"instance zero_projective [HasZeroObject C] : Projective (0 : C) :=\n  (isZero_zero C).projective\n\n"}
{"name":"CategoryTheory.Projective.of_iso","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : C\ni : CategoryTheory.Iso P Q\nx‚úù : CategoryTheory.Projective P\n‚ä¢ CategoryTheory.Projective Q","decl":"theorem of_iso {P Q : C} (i : P ‚âÖ Q) (_ : Projective P) : Projective Q where\n  factors f e _ :=\n    let ‚ü®f', hf'‚ü© := Projective.factors (i.hom ‚â´ f) e\n    ‚ü®i.inv ‚â´ f', by simp [hf']‚ü©\n\n"}
{"name":"CategoryTheory.Projective.iso_iff","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP Q : C\ni : CategoryTheory.Iso P Q\n‚ä¢ Iff (CategoryTheory.Projective P) (CategoryTheory.Projective Q)","decl":"theorem iso_iff {P Q : C} (i : P ‚âÖ Q) : Projective P ‚Üî Projective Q :=\n  ‚ü®of_iso i, of_iso i.symm‚ü©\n\n"}
{"name":"CategoryTheory.Projective.inst","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"X : Type u\n‚ä¢ CategoryTheory.Projective X","decl":"/-- The axiom of choice says that every type is a projective object in `Type`. -/\ninstance (X : Type u) : Projective X where\n  factors f e _ :=\n    have he : Function.Surjective e := surjective_of_epi e\n    ‚ü®fun x => (he (f x)).choose, funext fun x ‚Ü¶ (he (f x)).choose_spec‚ü©\n\n"}
{"name":"CategoryTheory.Projective.Type.enoughProjectives","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"‚ä¢ CategoryTheory.EnoughProjectives (Type u)","decl":"instance Type.enoughProjectives : EnoughProjectives (Type u) where\n  presentation X := ‚ü®‚ü®X, ùüô X‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Projective.instCoprod","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryCoproduct P Q\ninst‚úù¬π : CategoryTheory.Projective P\ninst‚úù : CategoryTheory.Projective Q\n‚ä¢ CategoryTheory.Projective (CategoryTheory.Limits.coprod P Q)","decl":"instance {P Q : C} [HasBinaryCoproduct P Q] [Projective P] [Projective Q] : Projective (P ‚®ø Q) where\n  factors f e epi := ‚ü®coprod.desc (factorThru (coprod.inl ‚â´ f) e) (factorThru (coprod.inr ‚â´ f) e),\n    by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Projective.instSigmaObj","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nŒ≤ : Type v\ng : Œ≤ ‚Üí C\ninst‚úù¬π : CategoryTheory.Limits.HasCoproduct g\ninst‚úù : ‚àÄ (b : Œ≤), CategoryTheory.Projective (g b)\n‚ä¢ CategoryTheory.Projective (CategoryTheory.Limits.sigmaObj g)","decl":"instance {Œ≤ : Type v} (g : Œ≤ ‚Üí C) [HasCoproduct g] [‚àÄ b, Projective (g b)] : Projective (‚àê g) where\n  factors f e epi := ‚ü®Sigma.desc fun b => factorThru (Sigma.Œπ g b ‚â´ f) e, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Projective.instBiprod","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nP Q : C\ninst‚úù¬≥ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬≤ : CategoryTheory.Limits.HasBinaryBiproduct P Q\ninst‚úù¬π : CategoryTheory.Projective P\ninst‚úù : CategoryTheory.Projective Q\n‚ä¢ CategoryTheory.Projective (CategoryTheory.Limits.biprod P Q)","decl":"instance {P Q : C} [HasZeroMorphisms C] [HasBinaryBiproduct P Q] [Projective P] [Projective Q] :\n    Projective (P ‚äû Q) where\n  factors f e epi := ‚ü®biprod.desc (factorThru (biprod.inl ‚â´ f) e) (factorThru (biprod.inr ‚â´ f) e),\n    by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Projective.instBiproduct","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nŒ≤ : Type v\ng : Œ≤ ‚Üí C\ninst‚úù¬≤ : CategoryTheory.Limits.HasZeroMorphisms C\ninst‚úù¬π : CategoryTheory.Limits.HasBiproduct g\ninst‚úù : ‚àÄ (b : Œ≤), CategoryTheory.Projective (g b)\n‚ä¢ CategoryTheory.Projective (CategoryTheory.Limits.biproduct g)","decl":"instance {Œ≤ : Type v} (g : Œ≤ ‚Üí C) [HasZeroMorphisms C] [HasBiproduct g] [‚àÄ b, Projective (g b)] :\n    Projective (‚®Å g) where\n  factors f e epi := ‚ü®biproduct.desc fun b => factorThru (biproduct.Œπ g b ‚â´ f) e, by aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Projective.projective_iff_preservesEpimorphisms_coyoneda_obj","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nP : C\n‚ä¢ Iff (CategoryTheory.Projective P) (CategoryTheory.coyoneda.obj { unop := P }).PreservesEpimorphisms","decl":"theorem projective_iff_preservesEpimorphisms_coyoneda_obj (P : C) :\n    Projective P ‚Üî (coyoneda.obj (op P)).PreservesEpimorphisms :=\n  ‚ü®fun hP =>\n    ‚ü®fun f _ =>\n      (epi_iff_surjective _).2 fun g =>\n        have : Projective (unop (op P)) := hP\n        ‚ü®factorThru g f, factorThru_comp _ _‚ü©‚ü©,\n    fun _ =>\n    ‚ü®fun f e _ =>\n      (epi_iff_surjective _).1 (inferInstance : Epi ((coyoneda.obj (op P)).map e)) f‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Projective.projective_over","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.EnoughProjectives C\nX : C\n‚ä¢ CategoryTheory.Projective (CategoryTheory.Projective.over X)","decl":"instance projective_over (X : C) : Projective (over X) :=\n  (EnoughProjectives.presentation X).some.projective\n\n"}
{"name":"CategoryTheory.Projective.œÄ_epi","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\ninst‚úù : CategoryTheory.EnoughProjectives C\nX : C\n‚ä¢ CategoryTheory.Epi (CategoryTheory.Projective.œÄ X)","decl":"instance œÄ_epi (X : C) : Epi (œÄ X) :=\n  (EnoughProjectives.presentation X).some.epi\n\n"}
{"name":"CategoryTheory.Projective.instSyzygies","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\ninst‚úù¬≤ : CategoryTheory.EnoughProjectives C\ninst‚úù¬π : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\ninst‚úù : CategoryTheory.Limits.HasKernel f\n‚ä¢ CategoryTheory.Projective (CategoryTheory.Projective.syzygies f)","decl":"instance : Projective (syzygies f) := inferInstanceAs (Projective (over _))\n\n"}
{"name":"CategoryTheory.Adjunction.map_projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬π : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù : G.PreservesEpimorphisms\nP : C\nhP : CategoryTheory.Projective P\n‚ä¢ CategoryTheory.Projective (F.obj P)","decl":"theorem map_projective (adj : F ‚ä£ G) [G.PreservesEpimorphisms] (P : C) (hP : Projective P) :\n    Projective (F.obj P) where\n  factors f g _ := by\n    rcases hP.factors (adj.unit.app P ‚â´ G.map f) (G.map g) with ‚ü®f', hf'‚ü©\n    use F.map f' ‚â´ adj.counit.app _\n    rw [Category.assoc, ‚Üê Adjunction.counit_naturality, ‚Üê Category.assoc, ‚Üê F.map_comp, hf']\n    simp\n\n"}
{"name":"CategoryTheory.Adjunction.projective_of_map_projective","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù¬≤ : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nadj : CategoryTheory.Adjunction F G\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nP : C\nhP : CategoryTheory.Projective (F.obj P)\n‚ä¢ CategoryTheory.Projective P","decl":"theorem projective_of_map_projective (adj : F ‚ä£ G) [F.Full] [F.Faithful] (P : C)\n    (hP : Projective (F.obj P)) : Projective P where\n  factors f g _ := by\n    haveI := Adjunction.leftAdjoint_preservesColimits.{0, 0} adj\n    rcases (@hP).1 (F.map f) (F.map g) with ‚ü®f', hf'‚ü©\n    use adj.unit.app _ ‚â´ G.map f' ‚â´ (inv <| adj.unit.app _)\n    exact F.map_injective (by simpa)\n\n"}
{"name":"CategoryTheory.Equivalence.map_projective_iff","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Equivalence C D\nP : C\n‚ä¢ Iff (CategoryTheory.Projective (F.functor.obj P)) (CategoryTheory.Projective P)","decl":"theorem map_projective_iff (P : C) : Projective (F.functor.obj P) ‚Üî Projective P :=\n  ‚ü®F.toAdjunction.projective_of_map_projective P, F.toAdjunction.map_projective P‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.enoughProjectives_iff","module":"Mathlib.CategoryTheory.Preadditive.Projective","initialProofState":"C : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst‚úù : CategoryTheory.Category.{v', u'} D\nF : CategoryTheory.Equivalence C D\n‚ä¢ Iff (CategoryTheory.EnoughProjectives C) (CategoryTheory.EnoughProjectives D)","decl":"theorem enoughProjectives_iff (F : C ‚âå D) : EnoughProjectives C ‚Üî EnoughProjectives D := by\n  constructor\n  all_goals intro H; constructor; intro X; constructor\n  ¬∑ exact F.symm.projectivePresentationOfMapProjectivePresentation _\n      (Nonempty.some (H.presentation (F.inverse.obj X)))\n  ¬∑ exact F.projectivePresentationOfMapProjectivePresentation X\n      (Nonempty.some (H.presentation (F.functor.obj X)))\n\n"}
