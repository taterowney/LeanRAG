{"name":"regularSpace_iff","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ Iff (RegularSpace X) (‚àÄ {s : Set X} {a : X}, IsClosed s ‚Üí Not (Membership.mem s a) ‚Üí Disjoint (nhdsSet s) (nhds a))","decl":"/-- A topological space is called a *regular space* if for any closed set `s` and `a ‚àâ s`, there\nexist disjoint open sets `U ‚äá s` and `V ‚àã a`. We formulate this condition in terms of `Disjoint`ness\nof filters `ùìùÀ¢ s` and `ùìù a`. -/\n@[mk_iff]\nclass RegularSpace (X : Type u) [TopologicalSpace X] : Prop where\n  /-- If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\n  neighborhoods. -/\n  regular : ‚àÄ {s : Set X} {a}, IsClosed s ‚Üí a ‚àâ s ‚Üí Disjoint (ùìùÀ¢ s) (ùìù a)\n\n"}
{"name":"RegularSpace.regular","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : RegularSpace X\ns : Set X\na : X\na‚úù¬π : IsClosed s\na‚úù : Not (Membership.mem s a)\n‚ä¢ Disjoint (nhdsSet s) (nhds a)","decl":"/-- A topological space is called a *regular space* if for any closed set `s` and `a ‚àâ s`, there\nexist disjoint open sets `U ‚äá s` and `V ‚àã a`. We formulate this condition in terms of `Disjoint`ness\nof filters `ùìùÀ¢ s` and `ùìù a`. -/\n@[mk_iff]\nclass RegularSpace (X : Type u) [TopologicalSpace X] : Prop where\n  /-- If `a` is a point that does not belong to a closed set `s`, then `a` and `s` admit disjoint\n  neighborhoods. -/\n  regular : ‚àÄ {s : Set X} {a}, IsClosed s ‚Üí a ‚àâ s ‚Üí Disjoint (ùìùÀ¢ s) (ùìù a)\n\n"}
{"name":"regularSpace_TFAE","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\n‚ä¢ (List.cons (RegularSpace X) (List.cons (‚àÄ (s : Set X) (x : X), Not (Membership.mem (closure s) x) ‚Üí Disjoint (nhdsSet s) (nhds x)) (List.cons (‚àÄ (x : X) (s : Set X), Iff (Disjoint (nhdsSet s) (nhds x)) (Not (Membership.mem (closure s) x))) (List.cons (‚àÄ (x : X) (s : Set X), Membership.mem (nhds x) s ‚Üí Exists fun t => And (Membership.mem (nhds x) t) (And (IsClosed t) (HasSubset.Subset t s))) (List.cons (‚àÄ (x : X), LE.le ((nhds x).lift' closure) (nhds x)) (List.cons (‚àÄ (x : X), Eq ((nhds x).lift' closure) (nhds x)) List.nil)))))).TFAE","decl":"theorem regularSpace_TFAE (X : Type u) [TopologicalSpace X] :\n    List.TFAE [RegularSpace X,\n      ‚àÄ (s : Set X) x, x ‚àâ closure s ‚Üí Disjoint (ùìùÀ¢ s) (ùìù x),\n      ‚àÄ (x : X) (s : Set X), Disjoint (ùìùÀ¢ s) (ùìù x) ‚Üî x ‚àâ closure s,\n      ‚àÄ (x : X) (s : Set X), s ‚àà ùìù x ‚Üí ‚àÉ t ‚àà ùìù x, IsClosed t ‚àß t ‚äÜ s,\n      ‚àÄ x : X, (ùìù x).lift' closure ‚â§ ùìù x,\n      ‚àÄ x : X , (ùìù x).lift' closure = ùìù x] := by\n  tfae_have 1 ‚Üî 5 := by\n    rw [regularSpace_iff, (@compl_surjective (Set X) _).forall, forall_swap]\n    simp only [isClosed_compl_iff, mem_compl_iff, Classical.not_not, @and_comm (_ ‚àà _),\n      (nhds_basis_opens _).lift'_closure.le_basis_iff (nhds_basis_opens _), and_imp,\n      (nhds_basis_opens _).disjoint_iff_right, exists_prop, ‚Üê subset_interior_iff_mem_nhdsSet,\n      interior_compl, compl_subset_compl]\n  tfae_have 5 ‚Üí 6 := fun h a => (h a).antisymm (ùìù _).le_lift'_closure\n  tfae_have 6 ‚Üí 4\n  | H, a, s, hs => by\n    rw [‚Üê H] at hs\n    rcases (ùìù a).basis_sets.lift'_closure.mem_iff.mp hs with ‚ü®U, hU, hUs‚ü©\n    exact ‚ü®closure U, mem_of_superset hU subset_closure, isClosed_closure, hUs‚ü©\n  tfae_have 4 ‚Üí 2\n  | H, s, a, ha => by\n    have ha' : s·∂ú ‚àà ùìù a := by rwa [‚Üê mem_interior_iff_mem_nhds, interior_compl]\n    rcases H _ _ ha' with ‚ü®U, hU, hUc, hUs‚ü©\n    refine disjoint_of_disjoint_of_mem disjoint_compl_left ?_ hU\n    rwa [‚Üê subset_interior_iff_mem_nhdsSet, hUc.isOpen_compl.interior_eq, subset_compl_comm]\n  tfae_have 2 ‚Üí 3 := by\n    refine fun H a s => ‚ü®fun hd has => mem_closure_iff_nhds_ne_bot.mp has ?_, H s a‚ü©\n    exact (hd.symm.mono_right <| @principal_le_nhdsSet _ _ s).eq_bot\n  tfae_have 3 ‚Üí 1 := fun H => ‚ü®fun hs ha => (H _ _).mpr <| hs.closure_eq.symm ‚ñ∏ ha‚ü©\n  tfae_finish\n\n"}
{"name":"RegularSpace.of_lift'_closure_le","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : ‚àÄ (x : X), LE.le ((nhds x).lift' closure) (nhds x)\n‚ä¢ RegularSpace X","decl":"theorem RegularSpace.of_lift'_closure_le (h : ‚àÄ x : X, (ùìù x).lift' closure ‚â§ ùìù x) :\n    RegularSpace X :=\n  Iff.mpr ((regularSpace_TFAE X).out 0 4) h\n\n"}
{"name":"RegularSpace.of_lift'_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : ‚àÄ (x : X), Eq ((nhds x).lift' closure) (nhds x)\n‚ä¢ RegularSpace X","decl":"theorem RegularSpace.of_lift'_closure (h : ‚àÄ x : X, (ùìù x).lift' closure = ùìù x) : RegularSpace X :=\n  Iff.mpr ((regularSpace_TFAE X).out 0 5) h\n\n"}
{"name":"RegularSpace.of_hasBasis","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : X ‚Üí Sort u_3\np : (a : X) ‚Üí Œπ a ‚Üí Prop\ns : (a : X) ‚Üí Œπ a ‚Üí Set X\nh‚ÇÅ : ‚àÄ (a : X), (nhds a).HasBasis (p a) (s a)\nh‚ÇÇ : ‚àÄ (a : X) (i : Œπ a), p a i ‚Üí IsClosed (s a i)\n‚ä¢ RegularSpace X","decl":"theorem RegularSpace.of_hasBasis {Œπ : X ‚Üí Sort*} {p : ‚àÄ a, Œπ a ‚Üí Prop} {s : ‚àÄ a, Œπ a ‚Üí Set X}\n    (h‚ÇÅ : ‚àÄ a, (ùìù a).HasBasis (p a) (s a)) (h‚ÇÇ : ‚àÄ a i, p a i ‚Üí IsClosed (s a i)) :\n    RegularSpace X :=\n  .of_lift'_closure fun a => (h‚ÇÅ a).lift'_closure_eq_self (h‚ÇÇ a)\n\n"}
{"name":"RegularSpace.of_exists_mem_nhds_isClosed_subset","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nh : ‚àÄ (x : X) (s : Set X), Membership.mem (nhds x) s ‚Üí Exists fun t => And (Membership.mem (nhds x) t) (And (IsClosed t) (HasSubset.Subset t s))\n‚ä¢ RegularSpace X","decl":"theorem RegularSpace.of_exists_mem_nhds_isClosed_subset\n    (h : ‚àÄ (x : X), ‚àÄ s ‚àà ùìù x, ‚àÉ t ‚àà ùìù x, IsClosed t ‚àß t ‚äÜ s) : RegularSpace X :=\n  Iff.mpr ((regularSpace_TFAE X).out 0 3) h\n\n"}
{"name":"instRegularSpaceOfWeaklyLocallyCompactSpaceOfR1Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : WeaklyLocallyCompactSpace X\ninst‚úù : R1Space X\n‚ä¢ RegularSpace X","decl":"/-- A weakly locally compact R‚ÇÅ space is regular. -/\ninstance (priority := 100) [WeaklyLocallyCompactSpace X] [R1Space X] : RegularSpace X :=\n  .of_hasBasis isCompact_isClosed_basis_nhds fun _ _ ‚ü®_, _, h‚ü© ‚Ü¶ h\n\n"}
{"name":"disjoint_nhdsSet_nhds","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\ns : Set X\n‚ä¢ Iff (Disjoint (nhdsSet s) (nhds x)) (Not (Membership.mem (closure s) x))","decl":"theorem disjoint_nhdsSet_nhds : Disjoint (ùìùÀ¢ s) (ùìù x) ‚Üî x ‚àâ closure s := by\n  have h := (regularSpace_TFAE X).out 0 2\n  exact h.mp ‚Äπ_‚Ä∫ _ _\n\n"}
{"name":"disjoint_nhds_nhdsSet","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\ns : Set X\n‚ä¢ Iff (Disjoint (nhds x) (nhdsSet s)) (Not (Membership.mem (closure s) x))","decl":"theorem disjoint_nhds_nhdsSet : Disjoint (ùìù x) (ùìùÀ¢ s) ‚Üî x ‚àâ closure s :=\n  disjoint_comm.trans disjoint_nhdsSet_nhds\n\n"}
{"name":"instR1Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ R1Space X","decl":"/-- A regular space is R‚ÇÅ. -/\ninstance (priority := 100) : R1Space X where\n  specializes_or_disjoint_nhds _ _ := or_iff_not_imp_left.2 fun h ‚Ü¶ by\n    rwa [‚Üê nhdsSet_singleton, disjoint_nhdsSet_nhds, ‚Üê specializes_iff_mem_closure]\n\n"}
{"name":"exists_mem_nhds_isClosed_subset","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\ns : Set X\nh : Membership.mem (nhds x) s\n‚ä¢ Exists fun t => And (Membership.mem (nhds x) t) (And (IsClosed t) (HasSubset.Subset t s))","decl":"theorem exists_mem_nhds_isClosed_subset {x : X} {s : Set X} (h : s ‚àà ùìù x) :\n    ‚àÉ t ‚àà ùìù x, IsClosed t ‚àß t ‚äÜ s := by\n  have h' := (regularSpace_TFAE X).out 0 3\n  exact h'.mp ‚Äπ_‚Ä∫ _ _ h\n\n"}
{"name":"closed_nhds_basis","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem (nhds x) s) (IsClosed s)) id","decl":"theorem closed_nhds_basis (x : X) : (ùìù x).HasBasis (fun s : Set X => s ‚àà ùìù x ‚àß IsClosed s) id :=\n  hasBasis_self.2 fun _ => exists_mem_nhds_isClosed_subset\n\n"}
{"name":"lift'_nhds_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\n‚ä¢ Eq ((nhds x).lift' closure) (nhds x)","decl":"theorem lift'_nhds_closure (x : X) : (ùìù x).lift' closure = ùìù x :=\n  (closed_nhds_basis x).lift'_closure_eq_self fun _ => And.right\n\n"}
{"name":"Filter.HasBasis.nhds_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nŒπ : Sort u_3\nx : X\np : Œπ ‚Üí Prop\ns : Œπ ‚Üí Set X\nh : (nhds x).HasBasis p s\n‚ä¢ (nhds x).HasBasis p fun i => closure (s i)","decl":"theorem Filter.HasBasis.nhds_closure {Œπ : Sort*} {x : X} {p : Œπ ‚Üí Prop} {s : Œπ ‚Üí Set X}\n    (h : (ùìù x).HasBasis p s) : (ùìù x).HasBasis p fun i => closure (s i) :=\n  lift'_nhds_closure x ‚ñ∏ h.lift'_closure\n\n"}
{"name":"hasBasis_nhds_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => Membership.mem (nhds x) s) closure","decl":"theorem hasBasis_nhds_closure (x : X) : (ùìù x).HasBasis (fun s => s ‚àà ùìù x) closure :=\n  (ùìù x).basis_sets.nhds_closure\n\n"}
{"name":"hasBasis_opens_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem s x) (IsOpen s)) closure","decl":"theorem hasBasis_opens_closure (x : X) : (ùìù x).HasBasis (fun s => x ‚àà s ‚àß IsOpen s) closure :=\n  (nhds_basis_opens x).nhds_closure\n\n"}
{"name":"IsCompact.exists_isOpen_closure_subset","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nK U : Set X\nhK : IsCompact K\nhU : Membership.mem (nhdsSet K) U\n‚ä¢ Exists fun V => And (IsOpen V) (And (HasSubset.Subset K V) (HasSubset.Subset (closure V) U))","decl":"theorem IsCompact.exists_isOpen_closure_subset {K U : Set X} (hK : IsCompact K) (hU : U ‚àà ùìùÀ¢ K) :\n    ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß closure V ‚äÜ U := by\n  have hd : Disjoint (ùìùÀ¢ K) (ùìùÀ¢ U·∂ú) := by\n    simpa [hK.disjoint_nhdsSet_left, disjoint_nhds_nhdsSet,\n      ‚Üê subset_interior_iff_mem_nhdsSet] using hU\n  rcases ((hasBasis_nhdsSet _).disjoint_iff (hasBasis_nhdsSet _)).1 hd\n    with ‚ü®V, ‚ü®hVo, hKV‚ü©, W, ‚ü®hW, hUW‚ü©, hVW‚ü©\n  refine ‚ü®V, hVo, hKV, Subset.trans ?_ (compl_subset_comm.1 hUW)‚ü©\n  exact closure_minimal hVW.subset_compl_right hW.isClosed_compl\n\n"}
{"name":"IsCompact.lift'_closure_nhdsSet","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nK : Set X\nhK : IsCompact K\n‚ä¢ Eq ((nhdsSet K).lift' closure) (nhdsSet K)","decl":"theorem IsCompact.lift'_closure_nhdsSet {K : Set X} (hK : IsCompact K) :\n    (ùìùÀ¢ K).lift' closure = ùìùÀ¢ K := by\n  refine le_antisymm (fun U hU ‚Ü¶ ?_) (le_lift'_closure _)\n  rcases hK.exists_isOpen_closure_subset hU with ‚ü®V, hVo, hKV, hVU‚ü©\n  exact mem_of_superset (mem_lift' <| hVo.mem_nhdsSet.2 hKV) hVU\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.nhds_basis_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nB : Set (Set X)\nhB : TopologicalSpace.IsTopologicalBasis B\nx : X\n‚ä¢ (nhds x).HasBasis (fun s => And (Membership.mem s x) (Membership.mem B s)) closure","decl":"theorem TopologicalSpace.IsTopologicalBasis.nhds_basis_closure {B : Set (Set X)}\n    (hB : IsTopologicalBasis B) (x : X) :\n    (ùìù x).HasBasis (fun s : Set X => x ‚àà s ‚àß s ‚àà B) closure := by\n  simpa only [and_comm] using hB.nhds_hasBasis.nhds_closure\n\n"}
{"name":"TopologicalSpace.IsTopologicalBasis.exists_closure_subset","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nB : Set (Set X)\nhB : TopologicalSpace.IsTopologicalBasis B\nx : X\ns : Set X\nh : Membership.mem (nhds x) s\n‚ä¢ Exists fun t => And (Membership.mem B t) (And (Membership.mem t x) (HasSubset.Subset (closure t) s))","decl":"theorem TopologicalSpace.IsTopologicalBasis.exists_closure_subset {B : Set (Set X)}\n    (hB : IsTopologicalBasis B) {x : X} {s : Set X} (h : s ‚àà ùìù x) :\n    ‚àÉ t ‚àà B, x ‚àà t ‚àß closure t ‚äÜ s := by\n  simpa only [exists_prop, and_assoc] using hB.nhds_hasBasis.nhds_closure.mem_iff.mp h\n\n"}
{"name":"Topology.IsInducing.regularSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Topology.IsInducing f\n‚ä¢ RegularSpace Y","decl":"protected theorem Topology.IsInducing.regularSpace [TopologicalSpace Y] {f : Y ‚Üí X}\n    (hf : IsInducing f) : RegularSpace Y :=\n  .of_hasBasis\n    (fun b => by rw [hf.nhds_eq_comap b]; exact (closed_nhds_basis _).comap _)\n    fun b s hs => by exact hs.2.preimage hf.continuous\n\n"}
{"name":"Inducing.regularSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : TopologicalSpace Y\nf : Y ‚Üí X\nhf : Topology.IsInducing f\n‚ä¢ RegularSpace Y","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.regularSpace := IsInducing.regularSpace\n\n"}
{"name":"regularSpace_induced","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\nf : Y ‚Üí X\n‚ä¢ RegularSpace Y","decl":"theorem regularSpace_induced (f : Y ‚Üí X) : @RegularSpace Y (induced f ‚Äπ_‚Ä∫) :=\n  letI := induced f ‚Äπ_‚Ä∫\n  (IsInducing.induced f).regularSpace\n\n"}
{"name":"regularSpace_sInf","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_3\nT : Set (TopologicalSpace X)\nh : ‚àÄ (t : TopologicalSpace X), Membership.mem T t ‚Üí RegularSpace X\n‚ä¢ RegularSpace X","decl":"theorem regularSpace_sInf {X} {T : Set (TopologicalSpace X)} (h : ‚àÄ t ‚àà T, @RegularSpace X t) :\n    @RegularSpace X (sInf T) := by\n  let _ := sInf T\n  have : ‚àÄ a, (ùìù a).HasBasis\n      (fun If : Œ£ I : Set T, I ‚Üí Set X =>\n        If.1.Finite ‚àß ‚àÄ i : If.1, If.2 i ‚àà @nhds X i a ‚àß @IsClosed X i (If.2 i))\n      fun If => ‚ãÇ i : If.1, If.snd i := fun a ‚Ü¶ by\n    rw [nhds_sInf, ‚Üê iInf_subtype'']\n    exact hasBasis_iInf fun t : T => @closed_nhds_basis X t (h t t.2) a\n  refine .of_hasBasis this fun a If hIf => isClosed_iInter fun i => ?_\n  exact (hIf.2 i).2.mono (sInf_le (i : T).2)\n\n"}
{"name":"regularSpace_iInf","module":"Mathlib.Topology.Separation.Regular","initialProofState":"Œπ : Sort u_3\nX : Type u_4\nt : Œπ ‚Üí TopologicalSpace X\nh : ‚àÄ (i : Œπ), RegularSpace X\n‚ä¢ RegularSpace X","decl":"theorem regularSpace_iInf {Œπ X} {t : Œπ ‚Üí TopologicalSpace X} (h : ‚àÄ i, @RegularSpace X (t i)) :\n    @RegularSpace X (iInf t) :=\n  regularSpace_sInf <| forall_mem_range.mpr h\n\n"}
{"name":"RegularSpace.inf","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_3\nt‚ÇÅ t‚ÇÇ : TopologicalSpace X\nh‚ÇÅ : RegularSpace X\nh‚ÇÇ : RegularSpace X\n‚ä¢ RegularSpace X","decl":"theorem RegularSpace.inf {X} {t‚ÇÅ t‚ÇÇ : TopologicalSpace X} (h‚ÇÅ : @RegularSpace X t‚ÇÅ)\n    (h‚ÇÇ : @RegularSpace X t‚ÇÇ) : @RegularSpace X (t‚ÇÅ ‚äì t‚ÇÇ) := by\n  rw [inf_eq_iInf]\n  exact regularSpace_iInf (Bool.forall_bool.2 ‚ü®h‚ÇÇ, h‚ÇÅ‚ü©)\n\n"}
{"name":"instRegularSpaceSubtype","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\np : X ‚Üí Prop\n‚ä¢ RegularSpace (Subtype p)","decl":"instance {p : X ‚Üí Prop} : RegularSpace (Subtype p) :=\n  IsEmbedding.subtypeVal.isInducing.regularSpace\n\n"}
{"name":"instRegularSpaceProd","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : RegularSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : RegularSpace Y\n‚ä¢ RegularSpace (Prod X Y)","decl":"instance [TopologicalSpace Y] [RegularSpace Y] : RegularSpace (X √ó Y) :=\n  (regularSpace_induced (@Prod.fst X Y)).inf (regularSpace_induced (@Prod.snd X Y))\n\n"}
{"name":"instRegularSpaceForall","module":"Mathlib.Topology.Separation.Regular","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), RegularSpace (X i)\n‚ä¢ RegularSpace ((i : Œπ) ‚Üí X i)","decl":"instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, RegularSpace (X i)] :\n    RegularSpace (‚àÄ i, X i) :=\n  regularSpace_iInf fun _ => regularSpace_induced _\n\n"}
{"name":"SeparatedNhds.of_isCompact_isClosed","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\ns t : Set X\nhs : IsCompact s\nht : IsClosed t\nhst : Disjoint s t\n‚ä¢ SeparatedNhds s t","decl":"/-- In a regular space, if a compact set and a closed set are disjoint, then they have disjoint\nneighborhoods. -/\nlemma SeparatedNhds.of_isCompact_isClosed {s t : Set X}\n    (hs : IsCompact s) (ht : IsClosed t) (hst : Disjoint s t) : SeparatedNhds s t := by\n  simpa only [separatedNhds_iff_disjoint, hs.disjoint_nhdsSet_left, disjoint_nhds_nhdsSet,\n    ht.closure_eq, disjoint_left] using hst\n\n"}
{"name":"IsClosed.HasSeparatingCover","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ns t : Set X\ninst‚úù¬π : LindelofSpace X\ninst‚úù : RegularSpace X\ns_cl : IsClosed s\nt_cl : IsClosed t\nst_dis : Disjoint s t\n‚ä¢ HasSeparatingCover s t","decl":"/-- This technique to witness `HasSeparatingCover` in regular Lindel√∂f topological spaces\nwill be used to prove regular Lindel√∂f spaces are normal. -/\nlemma IsClosed.HasSeparatingCover {s t : Set X} [LindelofSpace X] [RegularSpace X]\n    (s_cl : IsClosed s) (t_cl : IsClosed t) (st_dis : Disjoint s t) : HasSeparatingCover s t := by\n  -- `IsLindelof.indexed_countable_subcover` requires the space be Nonempty\n  rcases isEmpty_or_nonempty X with empty_X | nonempty_X\n  ¬∑ rw [subset_eq_empty (t := s) (fun ‚¶É_‚¶Ñ _ ‚Ü¶ trivial) (univ_eq_empty_iff.mpr empty_X)]\n    exact hasSeparatingCovers_iff_separatedNhds.mpr (SeparatedNhds.empty_left t) |>.1\n  -- This is almost `HasSeparatingCover`, but is not countable. We define for all `a : X` for use\n  -- with `IsLindelof.indexed_countable_subcover` momentarily.\n  have (a : X) : ‚àÉ n : Set X, IsOpen n ‚àß Disjoint (closure n) t ‚àß (a ‚àà s ‚Üí a ‚àà n) := by\n    wlog ains : a ‚àà s\n    ¬∑ exact ‚ü®‚àÖ, isOpen_empty, SeparatedNhds.empty_left t |>.disjoint_closure_left, fun a ‚Ü¶ ains a‚ü©\n    obtain ‚ü®n, nna, ncl, nsubkc‚ü© := ((regularSpace_TFAE X).out 0 3 :).mp ‚ÄπRegularSpace X‚Ä∫ a t·∂ú <|\n      t_cl.compl_mem_nhds (disjoint_left.mp st_dis ains)\n    exact\n      ‚ü®interior n,\n       isOpen_interior,\n       disjoint_left.mpr fun ‚¶É_‚¶Ñ ain ‚Ü¶\n         nsubkc <| (IsClosed.closure_subset_iff ncl).mpr interior_subset ain,\n       fun _ ‚Ü¶ mem_interior_iff_mem_nhds.mpr nna‚ü©\n  -- By Lindel√∂f, we may obtain a countable subcover witnessing `HasSeparatingCover`\n  choose u u_open u_dis u_nhd using this\n  obtain ‚ü®f, f_cov‚ü© := s_cl.isLindelof.indexed_countable_subcover\n    u u_open (fun a ainh ‚Ü¶ mem_iUnion.mpr ‚ü®a, u_nhd a ainh‚ü©)\n  exact ‚ü®u ‚àò f, f_cov, fun n ‚Ü¶ ‚ü®u_open (f n), u_dis (f n)‚ü©‚ü©\n\n\n"}
{"name":"exists_compact_closed_between","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : LocallyCompactSpace X\ninst‚úù : RegularSpace X\nK U : Set X\nhK : IsCompact K\nhU : IsOpen U\nh_KU : HasSubset.Subset K U\n‚ä¢ Exists fun L => And (IsCompact L) (And (IsClosed L) (And (HasSubset.Subset K (interior L)) (HasSubset.Subset L U)))","decl":"/-- In a (possibly non-Hausdorff) locally compact regular space, for every containment `K ‚äÜ U` of\n  a compact set `K` in an open set `U`, there is a compact closed neighborhood `L`\n  such that `K ‚äÜ L ‚äÜ U`: equivalently, there is a compact closed set `L` such\n  that `K ‚äÜ interior L` and `L ‚äÜ U`. -/\ntheorem exists_compact_closed_between [LocallyCompactSpace X] [RegularSpace X]\n    {K U : Set X} (hK : IsCompact K) (hU : IsOpen U) (h_KU : K ‚äÜ U) :\n    ‚àÉ L, IsCompact L ‚àß IsClosed L ‚àß K ‚äÜ interior L ‚àß L ‚äÜ U :=\n  let ‚ü®L, L_comp, KL, LU‚ü© := exists_compact_between hK hU h_KU\n  ‚ü®closure L, L_comp.closure, isClosed_closure, KL.trans <| interior_mono subset_closure,\n    L_comp.closure_subset_of_isOpen hU LU‚ü©\n\n"}
{"name":"exists_open_between_and_isCompact_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : LocallyCompactSpace X\ninst‚úù : RegularSpace X\nK U : Set X\nhK : IsCompact K\nhU : IsOpen U\nhKU : HasSubset.Subset K U\n‚ä¢ Exists fun V => And (IsOpen V) (And (HasSubset.Subset K V) (And (HasSubset.Subset (closure V) U) (IsCompact (closure V))))","decl":"/-- In a locally compact regular space, given a compact set `K` inside an open set `U`, we can find\nan open set `V` between these sets with compact closure: `K ‚äÜ V` and the closure of `V` is\ninside `U`. -/\ntheorem exists_open_between_and_isCompact_closure [LocallyCompactSpace X] [RegularSpace X]\n    {K U : Set X} (hK : IsCompact K) (hU : IsOpen U) (hKU : K ‚äÜ U) :\n    ‚àÉ V, IsOpen V ‚àß K ‚äÜ V ‚àß closure V ‚äÜ U ‚àß IsCompact (closure V) := by\n  rcases exists_compact_closed_between hK hU hKU with ‚ü®L, L_compact, L_closed, KL, LU‚ü©\n  have A : closure (interior L) ‚äÜ L := by\n    apply (closure_mono interior_subset).trans (le_of_eq L_closed.closure_eq)\n  refine ‚ü®interior L, isOpen_interior, KL, A.trans LU, ?_‚ü©\n  exact L_compact.closure_of_subset interior_subset\n\n"}
{"name":"T25Space.t2_5","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T25Space X\nx y : X\na‚úù : Ne x y\n‚ä¢ Disjoint ((nhds x).lift' closure) ((nhds y).lift' closure)","decl":"/-- A T‚ÇÇ.‚ÇÖ space, also known as a Urysohn space, is a topological space\n  where for every pair `x ‚â† y`, there are two open sets, with the intersection of closures\n  empty, one containing `x` and the other `y` . -/\nclass T25Space (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Given two distinct points in a T‚ÇÇ.‚ÇÖ space, their filters of closed neighborhoods are\n  disjoint. -/\n  t2_5 : ‚àÄ ‚¶Éx y : X‚¶Ñ, x ‚â† y ‚Üí Disjoint ((ùìù x).lift' closure) ((ùìù y).lift' closure)\n\n"}
{"name":"disjoint_lift'_closure_nhds","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T25Space X\nx y : X\n‚ä¢ Iff (Disjoint ((nhds x).lift' closure) ((nhds y).lift' closure)) (Ne x y)","decl":"@[simp]\ntheorem disjoint_lift'_closure_nhds [T25Space X] {x y : X} :\n    Disjoint ((ùìù x).lift' closure) ((ùìù y).lift' closure) ‚Üî x ‚â† y :=\n  ‚ü®fun h hxy => by simp [hxy, nhds_neBot.ne] at h, fun h => T25Space.t2_5 h‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"T25Space.t2Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T25Space X\n‚ä¢ T2Space X","decl":"instance (priority := 100) T25Space.t2Space [T25Space X] : T2Space X :=\n  t2Space_iff_disjoint_nhds.2 fun _ _ hne =>\n    (disjoint_lift'_closure_nhds.2 hne).mono (le_lift'_closure _) (le_lift'_closure _)\n\n"}
{"name":"exists_nhds_disjoint_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T25Space X\nx y : X\nh : Ne x y\n‚ä¢ Exists fun s => And (Membership.mem (nhds x) s) (Exists fun t => And (Membership.mem (nhds y) t) (Disjoint (closure s) (closure t)))","decl":"theorem exists_nhds_disjoint_closure [T25Space X] {x y : X} (h : x ‚â† y) :\n    ‚àÉ s ‚àà ùìù x, ‚àÉ t ‚àà ùìù y, Disjoint (closure s) (closure t) :=\n  ((ùìù x).basis_sets.lift'_closure.disjoint_iff (ùìù y).basis_sets.lift'_closure).1 <|\n    disjoint_lift'_closure_nhds.2 h\n\n"}
{"name":"exists_open_nhds_disjoint_closure","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T25Space X\nx y : X\nh : Ne x y\n‚ä¢ Exists fun u => And (Membership.mem u x) (And (IsOpen u) (Exists fun v => And (Membership.mem v y) (And (IsOpen v) (Disjoint (closure u) (closure v)))))","decl":"theorem exists_open_nhds_disjoint_closure [T25Space X] {x y : X} (h : x ‚â† y) :\n    ‚àÉ u : Set X,\n      x ‚àà u ‚àß IsOpen u ‚àß ‚àÉ v : Set X, y ‚àà v ‚àß IsOpen v ‚àß Disjoint (closure u) (closure v) := by\n  simpa only [exists_prop, and_assoc] using\n    ((nhds_basis_opens x).lift'_closure.disjoint_iff (nhds_basis_opens y).lift'_closure).1\n      (disjoint_lift'_closure_nhds.2 h)\n\n"}
{"name":"T25Space.of_injective_continuous","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T25Space Y\nf : X ‚Üí Y\nhinj : Function.Injective f\nhcont : Continuous f\n‚ä¢ T25Space X","decl":"theorem T25Space.of_injective_continuous [TopologicalSpace Y] [T25Space Y] {f : X ‚Üí Y}\n    (hinj : Injective f) (hcont : Continuous f) : T25Space X where\n  t2_5 x y hne := (tendsto_lift'_closure_nhds hcont x).disjoint (t2_5 <| hinj.ne hne)\n    (tendsto_lift'_closure_nhds hcont y)\n\n"}
{"name":"Topology.IsEmbedding.t25Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T25Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T25Space X","decl":"theorem Topology.IsEmbedding.t25Space [TopologicalSpace Y] [T25Space Y] {f : X ‚Üí Y}\n    (hf : IsEmbedding f) : T25Space X :=\n  .of_injective_continuous hf.injective hf.continuous\n\n"}
{"name":"Embedding.t25Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T25Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T25Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t25Space := IsEmbedding.t25Space\n\n"}
{"name":"Subtype.instT25Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T25Space X\np : X ‚Üí Prop\n‚ä¢ T25Space (Subtype fun x => p x)","decl":"instance Subtype.instT25Space [T25Space X] {p : X ‚Üí Prop} : T25Space {x // p x} :=\n  IsEmbedding.subtypeVal.t25Space\n\n"}
{"name":"T3Space.toRegularSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T3Space X\n‚ä¢ RegularSpace X","decl":"/-- A T‚ÇÉ space is a T‚ÇÄ space which is a regular space. Any T‚ÇÉ space is a T‚ÇÅ space, a T‚ÇÇ space, and\na T‚ÇÇ.‚ÇÖ space. -/\nclass T3Space (X : Type u) [TopologicalSpace X] extends T0Space X, RegularSpace X : Prop\n\n"}
{"name":"T3Space.toT0Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T3Space X\n‚ä¢ T0Space X","decl":"/-- A T‚ÇÉ space is a T‚ÇÄ space which is a regular space. Any T‚ÇÉ space is a T‚ÇÅ space, a T‚ÇÇ space, and\na T‚ÇÇ.‚ÇÖ space. -/\nclass T3Space (X : Type u) [TopologicalSpace X] extends T0Space X, RegularSpace X : Prop\n\n"}
{"name":"instT3Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T0Space X\ninst‚úù : RegularSpace X\n‚ä¢ T3Space X","decl":"instance (priority := 90) instT3Space [T0Space X] [RegularSpace X] : T3Space X := ‚ü®‚ü©\n\n"}
{"name":"RegularSpace.t3Space_iff_t0Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\n‚ä¢ Iff (T3Space X) (T0Space X)","decl":"theorem RegularSpace.t3Space_iff_t0Space [RegularSpace X] : T3Space X ‚Üî T0Space X := by\n  constructor <;> intro <;> infer_instance\n\n-- see Note [lower instance priority]\n"}
{"name":"T3Space.t25Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T3Space X\n‚ä¢ T25Space X","decl":"instance (priority := 100) T3Space.t25Space [T3Space X] : T25Space X := by\n  refine ‚ü®fun x y hne => ?_‚ü©\n  rw [lift'_nhds_closure, lift'_nhds_closure]\n  have : x ‚àâ closure {y} ‚à® y ‚àâ closure {x} :=\n    (t0Space_iff_or_not_mem_closure X).mp inferInstance hne\n  simp only [‚Üê disjoint_nhds_nhdsSet, nhdsSet_singleton] at this\n  exact this.elim id fun h => h.symm\n\n"}
{"name":"Topology.IsEmbedding.t3Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T3Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T3Space X","decl":"protected theorem Topology.IsEmbedding.t3Space [TopologicalSpace Y] [T3Space Y] {f : X ‚Üí Y}\n    (hf : IsEmbedding f) : T3Space X :=\n  { toT0Space := hf.t0Space\n    toRegularSpace := hf.isInducing.regularSpace }\n\n"}
{"name":"Embedding.t3Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T3Space Y\nf : X ‚Üí Y\nhf : Topology.IsEmbedding f\n‚ä¢ T3Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t3Space := IsEmbedding.t3Space\n\n"}
{"name":"Subtype.t3Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T3Space X\np : X ‚Üí Prop\n‚ä¢ T3Space (Subtype p)","decl":"instance Subtype.t3Space [T3Space X] {p : X ‚Üí Prop} : T3Space (Subtype p) :=\n  IsEmbedding.subtypeVal.t3Space\n\n"}
{"name":"ULift.instT3Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T3Space X\n‚ä¢ T3Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT3Space [T3Space X] : T3Space (ULift X) :=\n  IsEmbedding.uliftDown.t3Space\n\n"}
{"name":"instT3SpaceProd","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : T3Space X\ninst‚úù : T3Space Y\n‚ä¢ T3Space (Prod X Y)","decl":"instance [TopologicalSpace Y] [T3Space X] [T3Space Y] : T3Space (X √ó Y) := ‚ü®‚ü©\n\n"}
{"name":"instT3SpaceForall","module":"Mathlib.Topology.Separation.Regular","initialProofState":"Œπ : Type u_3\nX : Œπ ‚Üí Type u_4\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : ‚àÄ (i : Œπ), T3Space (X i)\n‚ä¢ T3Space ((i : Œπ) ‚Üí X i)","decl":"instance {Œπ : Type*} {X : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, T3Space (X i)] :\n    T3Space (‚àÄ i, X i) := ‚ü®‚ü©\n\n"}
{"name":"disjoint_nested_nhds","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T3Space X\nx y : X\nh : Ne x y\n‚ä¢ Exists fun U‚ÇÅ => And (Membership.mem (nhds x) U‚ÇÅ) (Exists fun V‚ÇÅ => And (Membership.mem (nhds x) V‚ÇÅ) (Exists fun U‚ÇÇ => And (Membership.mem (nhds y) U‚ÇÇ) (Exists fun V‚ÇÇ => And (Membership.mem (nhds y) V‚ÇÇ) (And (IsClosed V‚ÇÅ) (And (IsClosed V‚ÇÇ) (And (IsOpen U‚ÇÅ) (And (IsOpen U‚ÇÇ) (And (HasSubset.Subset V‚ÇÅ U‚ÇÅ) (And (HasSubset.Subset V‚ÇÇ U‚ÇÇ) (Disjoint U‚ÇÅ U‚ÇÇ))))))))))","decl":"/-- Given two points `x ‚â† y`, we can find neighbourhoods `x ‚àà V‚ÇÅ ‚äÜ U‚ÇÅ` and `y ‚àà V‚ÇÇ ‚äÜ U‚ÇÇ`,\nwith the `V‚Çñ` closed and the `U‚Çñ` open, such that the `U‚Çñ` are disjoint. -/\ntheorem disjoint_nested_nhds [T3Space X] {x y : X} (h : x ‚â† y) :\n    ‚àÉ U‚ÇÅ ‚àà ùìù x, ‚àÉ V‚ÇÅ ‚àà ùìù x, ‚àÉ U‚ÇÇ ‚àà ùìù y, ‚àÉ V‚ÇÇ ‚àà ùìù y,\n      IsClosed V‚ÇÅ ‚àß IsClosed V‚ÇÇ ‚àß IsOpen U‚ÇÅ ‚àß IsOpen U‚ÇÇ ‚àß V‚ÇÅ ‚äÜ U‚ÇÅ ‚àß V‚ÇÇ ‚äÜ U‚ÇÇ ‚àß Disjoint U‚ÇÅ U‚ÇÇ := by\n  rcases t2_separation h with ‚ü®U‚ÇÅ, U‚ÇÇ, U‚ÇÅ_op, U‚ÇÇ_op, x_in, y_in, H‚ü©\n  rcases exists_mem_nhds_isClosed_subset (U‚ÇÅ_op.mem_nhds x_in) with ‚ü®V‚ÇÅ, V‚ÇÅ_in, V‚ÇÅ_closed, h‚ÇÅ‚ü©\n  rcases exists_mem_nhds_isClosed_subset (U‚ÇÇ_op.mem_nhds y_in) with ‚ü®V‚ÇÇ, V‚ÇÇ_in, V‚ÇÇ_closed, h‚ÇÇ‚ü©\n  exact ‚ü®U‚ÇÅ, mem_of_superset V‚ÇÅ_in h‚ÇÅ, V‚ÇÅ, V‚ÇÅ_in, U‚ÇÇ, mem_of_superset V‚ÇÇ_in h‚ÇÇ, V‚ÇÇ, V‚ÇÇ_in,\n    V‚ÇÅ_closed, V‚ÇÇ_closed, U‚ÇÅ_op, U‚ÇÇ_op, h‚ÇÅ, h‚ÇÇ, H‚ü©\n\n"}
{"name":"instT3SpaceSeparationQuotientOfRegularSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : RegularSpace X\n‚ä¢ T3Space (SeparationQuotient X)","decl":"/-- The `SeparationQuotient` of a regular space is a T‚ÇÉ space. -/\ninstance [RegularSpace X] : T3Space (SeparationQuotient X) where\n  regular {s a} hs ha := by\n    rcases surjective_mk a with ‚ü®a, rfl‚ü©\n    rw [‚Üê disjoint_comap_iff surjective_mk, comap_mk_nhds_mk, comap_mk_nhdsSet]\n    exact RegularSpace.regular (hs.preimage continuous_mk) ha\n\n"}
{"name":"NormalSpace.normal","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : NormalSpace X\ns t : Set X\na‚úù¬≤ : IsClosed s\na‚úù¬π : IsClosed t\na‚úù : Disjoint s t\n‚ä¢ SeparatedNhds s t","decl":"/-- A topological space is said to be a *normal space* if any two disjoint closed sets\nhave disjoint open neighborhoods. -/\nclass NormalSpace (X : Type u) [TopologicalSpace X] : Prop where\n  /-- Two disjoint sets in a normal space admit disjoint neighbourhoods. -/\n  normal : ‚àÄ s t : Set X, IsClosed s ‚Üí IsClosed t ‚Üí Disjoint s t ‚Üí SeparatedNhds s t\n\n"}
{"name":"normal_separation","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : NormalSpace X\ns t : Set X\nH1 : IsClosed s\nH2 : IsClosed t\nH3 : Disjoint s t\n‚ä¢ SeparatedNhds s t","decl":"theorem normal_separation [NormalSpace X] {s t : Set X} (H1 : IsClosed s) (H2 : IsClosed t)\n    (H3 : Disjoint s t) : SeparatedNhds s t :=\n  NormalSpace.normal s t H1 H2 H3\n\n"}
{"name":"disjoint_nhdsSet_nhdsSet","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsClosed t\nhd : Disjoint s t\n‚ä¢ Disjoint (nhdsSet s) (nhdsSet t)","decl":"theorem disjoint_nhdsSet_nhdsSet [NormalSpace X] {s t : Set X} (hs : IsClosed s) (ht : IsClosed t)\n    (hd : Disjoint s t) : Disjoint (ùìùÀ¢ s) (ùìùÀ¢ t) :=\n  (normal_separation hs ht hd).disjoint_nhdsSet\n\n"}
{"name":"normal_exists_closure_subset","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : NormalSpace X\ns t : Set X\nhs : IsClosed s\nht : IsOpen t\nhst : HasSubset.Subset s t\n‚ä¢ Exists fun u => And (IsOpen u) (And (HasSubset.Subset s u) (HasSubset.Subset (closure u) t))","decl":"theorem normal_exists_closure_subset [NormalSpace X] {s t : Set X} (hs : IsClosed s) (ht : IsOpen t)\n    (hst : s ‚äÜ t) : ‚àÉ u, IsOpen u ‚àß s ‚äÜ u ‚àß closure u ‚äÜ t := by\n  have : Disjoint s t·∂ú := Set.disjoint_left.mpr fun x hxs hxt => hxt (hst hxs)\n  rcases normal_separation hs (isClosed_compl_iff.2 ht) this with\n    ‚ü®s', t', hs', ht', hss', htt', hs't'‚ü©\n  refine ‚ü®s', hs', hss', Subset.trans (closure_minimal ?_ (isClosed_compl_iff.2 ht'))\n    (compl_subset_comm.1 htt')‚ü©\n  exact fun x hxs hxt => hs't'.le_bot ‚ü®hxs, hxt‚ü©\n\n"}
{"name":"Topology.IsClosedEmbedding.normalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ NormalSpace X","decl":"/-- If the codomain of a closed embedding is a normal space, then so is the domain. -/\nprotected theorem Topology.IsClosedEmbedding.normalSpace [TopologicalSpace Y] [NormalSpace Y]\n    {f : X ‚Üí Y} (hf : IsClosedEmbedding f) : NormalSpace X where\n  normal s t hs ht hst := by\n    have H : SeparatedNhds (f '' s) (f '' t) :=\n      NormalSpace.normal (f '' s) (f '' t) (hf.isClosedMap s hs) (hf.isClosedMap t ht)\n        (disjoint_image_of_injective hf.injective hst)\n    exact (H.preimage hf.continuous).mono (subset_preimage_image _ _) (subset_preimage_image _ _)\n\n"}
{"name":"ClosedEmbedding.normalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ NormalSpace X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.normalSpace := IsClosedEmbedding.normalSpace\n\n"}
{"name":"NormalSpace.of_compactSpace_r1Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : CompactSpace X\ninst‚úù : R1Space X\n‚ä¢ NormalSpace X","decl":"instance (priority := 100) NormalSpace.of_compactSpace_r1Space [CompactSpace X] [R1Space X] :\n    NormalSpace X where\n  normal _s _t hs ht := .of_isCompact_isCompact_isClosed hs.isCompact ht.isCompact ht\n\n"}
{"name":"NormalSpace.of_regularSpace_lindelofSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : LindelofSpace X\n‚ä¢ NormalSpace X","decl":"set_option pp.universes true in\n/-- A regular topological space with a Lindel√∂f topology is a normal space. A consequence of e.g.\nCorollaries 20.8 and 20.10 of [Willard's *General Topology*][zbMATH02107988] (without the\nassumption of Hausdorff). -/\ninstance (priority := 100) NormalSpace.of_regularSpace_lindelofSpace\n    [RegularSpace X] [LindelofSpace X] : NormalSpace X where\n  normal _ _ hcl kcl hkdis :=\n    hasSeparatingCovers_iff_separatedNhds.mp\n    ‚ü®hcl.HasSeparatingCover kcl hkdis, kcl.HasSeparatingCover hcl (Disjoint.symm hkdis)‚ü©\n\n"}
{"name":"NormalSpace.of_regularSpace_secondCountableTopology","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : RegularSpace X\ninst‚úù : SecondCountableTopology X\n‚ä¢ NormalSpace X","decl":"instance (priority := 100) NormalSpace.of_regularSpace_secondCountableTopology\n    [RegularSpace X] [SecondCountableTopology X] : NormalSpace X :=\n  of_regularSpace_lindelofSpace\n\n"}
{"name":"T4Space.toT1Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T4Space X\n‚ä¢ T1Space X","decl":"/-- A T‚ÇÑ space is a normal T‚ÇÅ space. -/\nclass T4Space (X : Type u) [TopologicalSpace X] extends T1Space X, NormalSpace X : Prop\n\n"}
{"name":"T4Space.toNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T4Space X\n‚ä¢ NormalSpace X","decl":"/-- A T‚ÇÑ space is a normal T‚ÇÅ space. -/\nclass T4Space (X : Type u) [TopologicalSpace X] extends T1Space X, NormalSpace X : Prop\n\n"}
{"name":"instT4SpaceOfT1SpaceOfNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T1Space X\ninst‚úù : NormalSpace X\n‚ä¢ T4Space X","decl":"instance (priority := 100) [T1Space X] [NormalSpace X] : T4Space X := ‚ü®‚ü©\n\n-- see Note [lower instance priority]\n"}
{"name":"T4Space.t3Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T4Space X\n‚ä¢ T3Space X","decl":"instance (priority := 100) T4Space.t3Space [T4Space X] : T3Space X where\n  regular hs hxs := by simpa only [nhdsSet_singleton] using (normal_separation hs isClosed_singleton\n    (disjoint_singleton_right.mpr hxs)).disjoint_nhdsSet\n\n"}
{"name":"Topology.IsClosedEmbedding.t4Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T4Space Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ T4Space X","decl":"/-- If the codomain of a closed embedding is a T‚ÇÑ space, then so is the domain. -/\nprotected theorem Topology.IsClosedEmbedding.t4Space [TopologicalSpace Y] [T4Space Y] {f : X ‚Üí Y}\n    (hf : IsClosedEmbedding f) : T4Space X where\n  toT1Space := hf.isEmbedding.t1Space\n  toNormalSpace := hf.normalSpace\n\n"}
{"name":"ClosedEmbedding.t4Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T4Space Y\nf : X ‚Üí Y\nhf : Topology.IsClosedEmbedding f\n‚ä¢ T4Space X","decl":"@[deprecated (since := \"2024-10-20\")]\nalias ClosedEmbedding.t4Space := IsClosedEmbedding.t4Space\n\n"}
{"name":"ULift.instT4Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T4Space X\n‚ä¢ T4Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT4Space [T4Space X] : T4Space (ULift X) := IsClosedEmbedding.uliftDown.t4Space\n\n"}
{"name":"SeparationQuotient.instNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : NormalSpace X\n‚ä¢ NormalSpace (SeparationQuotient X)","decl":"/-- The `SeparationQuotient` of a normal space is a normal space. -/\ninstance [NormalSpace X] : NormalSpace (SeparationQuotient X) where\n  normal s t hs ht hd := separatedNhds_iff_disjoint.2 <| by\n    rw [‚Üê disjoint_comap_iff surjective_mk, comap_mk_nhdsSet, comap_mk_nhdsSet]\n    exact disjoint_nhdsSet_nhdsSet (hs.preimage continuous_mk) (ht.preimage continuous_mk)\n      (hd.preimage mk)\n\n"}
{"name":"CompletelyNormalSpace.completely_normal","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : CompletelyNormalSpace X\ns t : Set X\na‚úù¬π : Disjoint (closure s) t\na‚úù : Disjoint s (closure t)\n‚ä¢ Disjoint (nhdsSet s) (nhdsSet t)","decl":"/-- A topological space `X` is a *completely normal space* provided that for any two sets `s`, `t`\nsuch that if both `closure s` is disjoint with `t`, and `s` is disjoint with `closure t`,\nthen there exist disjoint neighbourhoods of `s` and `t`. -/\nclass CompletelyNormalSpace (X : Type u) [TopologicalSpace X] : Prop where\n  /-- If `closure s` is disjoint with `t`, and `s` is disjoint with `closure t`, then `s` and `t`\n  admit disjoint neighbourhoods. -/\n  completely_normal :\n    ‚àÄ ‚¶És t : Set X‚¶Ñ, Disjoint (closure s) t ‚Üí Disjoint s (closure t) ‚Üí Disjoint (ùìùÀ¢ s) (ùìùÀ¢ t)\n\n"}
{"name":"CompletelyNormalSpace.toNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompletelyNormalSpace X\n‚ä¢ NormalSpace X","decl":"/-- A completely normal space is a normal space. -/\ninstance (priority := 100) CompletelyNormalSpace.toNormalSpace\n    [CompletelyNormalSpace X] : NormalSpace X where\n  normal s t hs ht hd := separatedNhds_iff_disjoint.2 <|\n    completely_normal (by rwa [hs.closure_eq]) (by rwa [ht.closure_eq])\n\n"}
{"name":"Topology.IsEmbedding.completelyNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : CompletelyNormalSpace Y\ne : X ‚Üí Y\nhe : Topology.IsEmbedding e\n‚ä¢ CompletelyNormalSpace X","decl":"theorem Topology.IsEmbedding.completelyNormalSpace [TopologicalSpace Y] [CompletelyNormalSpace Y]\n    {e : X ‚Üí Y} (he : IsEmbedding e) : CompletelyNormalSpace X := by\n  refine ‚ü®fun s t hd‚ÇÅ hd‚ÇÇ => ?_‚ü©\n  simp only [he.isInducing.nhdsSet_eq_comap]\n  refine disjoint_comap (completely_normal ?_ ?_)\n  ¬∑ rwa [‚Üê subset_compl_iff_disjoint_left, image_subset_iff, preimage_compl,\n      ‚Üê he.closure_eq_preimage_closure_image, subset_compl_iff_disjoint_left]\n  ¬∑ rwa [‚Üê subset_compl_iff_disjoint_right, image_subset_iff, preimage_compl,\n      ‚Üê he.closure_eq_preimage_closure_image, subset_compl_iff_disjoint_right]\n\n"}
{"name":"Embedding.completelyNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : CompletelyNormalSpace Y\ne : X ‚Üí Y\nhe : Topology.IsEmbedding e\n‚ä¢ CompletelyNormalSpace X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.completelyNormalSpace := IsEmbedding.completelyNormalSpace\n\n"}
{"name":"instCompletelyNormalSpaceSubtype","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompletelyNormalSpace X\np : X ‚Üí Prop\n‚ä¢ CompletelyNormalSpace (Subtype fun x => p x)","decl":"/-- A subspace of a completely normal space is a completely normal space. -/\ninstance [CompletelyNormalSpace X] {p : X ‚Üí Prop} : CompletelyNormalSpace { x // p x } :=\n  IsEmbedding.subtypeVal.completelyNormalSpace\n\n"}
{"name":"ULift.instCompletelyNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : CompletelyNormalSpace X\n‚ä¢ CompletelyNormalSpace (ULift.{u_3, u_1} X)","decl":"instance ULift.instCompletelyNormalSpace [CompletelyNormalSpace X] :\n    CompletelyNormalSpace (ULift X) :=\n  IsEmbedding.uliftDown.completelyNormalSpace\n\n"}
{"name":"T5Space.toT1Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T5Space X\n‚ä¢ T1Space X","decl":"/-- A T‚ÇÖ space is a completely normal T‚ÇÅ space. -/\nclass T5Space (X : Type u) [TopologicalSpace X] extends T1Space X, CompletelyNormalSpace X : Prop\n\n"}
{"name":"T5Space.toCompletelyNormalSpace","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u\ninst‚úù : TopologicalSpace X\nself : T5Space X\n‚ä¢ CompletelyNormalSpace X","decl":"/-- A T‚ÇÖ space is a completely normal T‚ÇÅ space. -/\nclass T5Space (X : Type u) [TopologicalSpace X] extends T1Space X, CompletelyNormalSpace X : Prop\n\n"}
{"name":"Topology.IsEmbedding.t5Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T5Space Y\ne : X ‚Üí Y\nhe : Topology.IsEmbedding e\n‚ä¢ T5Space X","decl":"theorem Topology.IsEmbedding.t5Space [TopologicalSpace Y] [T5Space Y] {e : X ‚Üí Y}\n    (he : IsEmbedding e) : T5Space X where\n  __ := he.t1Space\n  completely_normal := by\n    have := he.completelyNormalSpace\n    exact completely_normal\n\n"}
{"name":"Embedding.t5Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T5Space Y\ne : X ‚Üí Y\nhe : Topology.IsEmbedding e\n‚ä¢ T5Space X","decl":"@[deprecated (since := \"2024-10-26\")]\nalias Embedding.t5Space := IsEmbedding.t5Space\n\n-- see Note [lower instance priority]\n"}
{"name":"T5Space.toT4Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T5Space X\n‚ä¢ T4Space X","decl":"/-- A `T‚ÇÖ` space is a `T‚ÇÑ` space. -/\ninstance (priority := 100) T5Space.toT4Space [T5Space X] : T4Space X where\n  -- follows from type-class inference\n\n"}
{"name":"instT5SpaceSubtype","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T5Space X\np : X ‚Üí Prop\n‚ä¢ T5Space (Subtype fun x => p x)","decl":"/-- A subspace of a T‚ÇÖ space is a T‚ÇÖ space. -/\ninstance [T5Space X] {p : X ‚Üí Prop} : T5Space { x // p x } :=\n  IsEmbedding.subtypeVal.t5Space\n\n"}
{"name":"ULift.instT5Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : T5Space X\n‚ä¢ T5Space (ULift.{u_3, u_1} X)","decl":"instance ULift.instT5Space [T5Space X] : T5Space (ULift X) :=\n  IsEmbedding.uliftDown.t5Space\n\n"}
{"name":"instT5SpaceSeparationQuotientOfCompletelyNormalSpaceOfR0Space","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : CompletelyNormalSpace X\ninst‚úù : R0Space X\n‚ä¢ T5Space (SeparationQuotient X)","decl":"/-- The `SeparationQuotient` of a completely normal R‚ÇÄ space is a T‚ÇÖ space. -/\ninstance [CompletelyNormalSpace X] [R0Space X] : T5Space (SeparationQuotient X) where\n  t1 := by\n    rwa [((t1Space_TFAE (SeparationQuotient X)).out 1 0 :), SeparationQuotient.t1Space_iff]\n  completely_normal s t hd‚ÇÅ hd‚ÇÇ := by\n    rw [‚Üê disjoint_comap_iff surjective_mk, comap_mk_nhdsSet, comap_mk_nhdsSet]\n    apply completely_normal <;> rw [‚Üê preimage_mk_closure]\n    exacts [hd‚ÇÅ.preimage mk, hd‚ÇÇ.preimage mk]\n\n"}
{"name":"connectedComponent_eq_iInter_isClopen","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T2Space X\ninst‚úù : CompactSpace X\nx : X\n‚ä¢ Eq (connectedComponent x) (Set.iInter fun s => ‚Üës)","decl":"/-- In a compact T‚ÇÇ space, the connected component of a point equals the intersection of all\nits clopen neighbourhoods. -/\ntheorem connectedComponent_eq_iInter_isClopen [T2Space X] [CompactSpace X] (x : X) :\n    connectedComponent x = ‚ãÇ s : { s : Set X // IsClopen s ‚àß x ‚àà s }, s := by\n  apply Subset.antisymm connectedComponent_subset_iInter_isClopen\n  -- Reduce to showing that the clopen intersection is connected.\n  refine IsPreconnected.subset_connectedComponent ?_ (mem_iInter.2 fun s => s.2.2)\n  -- We do this by showing that any disjoint cover by two closed sets implies\n  -- that one of these closed sets must contain our whole thing.\n  -- To reduce to the case where the cover is disjoint on all of `X` we need that `s` is closed\n  have hs : @IsClosed X _ (‚ãÇ s : { s : Set X // IsClopen s ‚àß x ‚àà s }, s) :=\n    isClosed_iInter fun s => s.2.1.1\n  rw [isPreconnected_iff_subset_of_fully_disjoint_closed hs]\n  intro a b ha hb hab ab_disj\n  -- Since our space is normal, we get two larger disjoint open sets containing the disjoint\n  -- closed sets. If we can show that our intersection is a subset of any of these we can then\n  -- \"descend\" this to show that it is a subset of either a or b.\n  rcases normal_separation ha hb ab_disj with ‚ü®u, v, hu, hv, hau, hbv, huv‚ü©\n  obtain ‚ü®s, H‚ü© : ‚àÉ s : Set X, IsClopen s ‚àß x ‚àà s ‚àß s ‚äÜ u ‚à™ v := by\n    /- Now we find a clopen set `s` around `x`, contained in `u ‚à™ v`. We utilize the fact that\n    `X \\ u ‚à™ v` will be compact, so there must be some finite intersection of clopen neighbourhoods\n    of `X` disjoint to it, but a finite intersection of clopen sets is clopen,\n    so we let this be our `s`. -/\n    have H1 := (hu.union hv).isClosed_compl.isCompact.inter_iInter_nonempty\n      (fun s : { s : Set X // IsClopen s ‚àß x ‚àà s } => s) fun s => s.2.1.1\n    rw [‚Üê not_disjoint_iff_nonempty_inter, imp_not_comm, not_forall] at H1\n    cases' H1 (disjoint_compl_left_iff_subset.2 <| hab.trans <| union_subset_union hau hbv)\n      with si H2\n    refine ‚ü®‚ãÇ U ‚àà si, Subtype.val U, ?_, ?_, ?_‚ü©\n    ¬∑ exact isClopen_biInter_finset fun s _ => s.2.1\n    ¬∑ exact mem_iInter‚ÇÇ.2 fun s _ => s.2.2\n    ¬∑ rwa [‚Üê disjoint_compl_left_iff_subset, disjoint_iff_inter_eq_empty,\n        ‚Üê not_nonempty_iff_eq_empty]\n  -- So, we get a disjoint decomposition `s = s ‚à© u ‚à™ s ‚à© v` of clopen sets. The intersection of all\n  -- clopen neighbourhoods will then lie in whichever of u or v x lies in and hence will be a subset\n  -- of either a or b.\n  ¬∑ have H1 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hu hv huv\n    rw [union_comm] at H\n    have H2 := isClopen_inter_of_disjoint_cover_clopen H.1 H.2.2 hv hu huv.symm\n    by_cases hxu : x ‚àà u <;> [left; right]\n    -- The x ‚àà u case.\n    ¬∑ suffices ‚ãÇ s : { s : Set X // IsClopen s ‚àß x ‚àà s }, ‚Üës ‚äÜ u\n        from Disjoint.left_le_of_le_sup_right hab (huv.mono this hbv)\n      ¬∑ apply Subset.trans _ s.inter_subset_right\n        exact iInter_subset (fun s : { s : Set X // IsClopen s ‚àß x ‚àà s } => s.1)\n          ‚ü®s ‚à© u, H1, mem_inter H.2.1 hxu‚ü©\n    -- If x ‚àâ u, we get x ‚àà v since x ‚àà u ‚à™ v. The rest is then like the x ‚àà u case.\n    ¬∑ have h1 : x ‚àà v :=\n        (hab.trans (union_subset_union hau hbv) (mem_iInter.2 fun i => i.2.2)).resolve_left hxu\n      suffices ‚ãÇ s : { s : Set X // IsClopen s ‚àß x ‚àà s }, ‚Üës ‚äÜ v\n        from (huv.symm.mono this hau).left_le_of_le_sup_left hab\n      ¬∑ refine Subset.trans ?_ s.inter_subset_right\n        exact iInter_subset (fun s : { s : Set X // IsClopen s ‚àß x ‚àà s } => s.1)\n          ‚ü®s ‚à© v, H2, mem_inter H.2.1 h1‚ü©\n\n"}
{"name":"ConnectedComponents.t2","module":"Mathlib.Topology.Separation.Regular","initialProofState":"X : Type u_1\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : T2Space X\ninst‚úù : CompactSpace X\n‚ä¢ T2Space (ConnectedComponents X)","decl":"/-- `ConnectedComponents X` is Hausdorff when `X` is Hausdorff and compact -/\n@[stacks 0900 \"The Stacks entry proves profiniteness.\"]\ninstance ConnectedComponents.t2 [T2Space X] [CompactSpace X] : T2Space (ConnectedComponents X) := by\n  -- Fix 2 distinct connected components, with points a and b\n  refine ‚ü®ConnectedComponents.surjective_coe.forall‚ÇÇ.2 fun a b ne => ?_‚ü©\n  rw [ConnectedComponents.coe_ne_coe] at ne\n  have h := connectedComponent_disjoint ne\n  -- write ‚Üëb as the intersection of all clopen subsets containing it\n  rw [connectedComponent_eq_iInter_isClopen b, disjoint_iff_inter_eq_empty] at h\n  -- Now we show that this can be reduced to some clopen containing `‚Üëb` being disjoint to `‚Üëa`\n  obtain ‚ü®U, V, hU, ha, hb, rfl‚ü© : ‚àÉ (U : Set X) (V : Set (ConnectedComponents X)),\n      IsClopen U ‚àß connectedComponent a ‚à© U = ‚àÖ ‚àß connectedComponent b ‚äÜ U ‚àß (‚Üë) ‚Åª¬π' V = U := by\n    have h :=\n      (isClosed_connectedComponent (Œ± := X)).isCompact.elim_finite_subfamily_closed\n        _ (fun s : { s : Set X // IsClopen s ‚àß b ‚àà s } => s.2.1.1) h\n    cases' h with fin_a ha\n    -- This clopen and its complement will separate the connected components of `a` and `b`\n    set U : Set X := ‚ãÇ (i : { s // IsClopen s ‚àß b ‚àà s }) (_ : i ‚àà fin_a), i\n    have hU : IsClopen U := isClopen_biInter_finset fun i _ => i.2.1\n    exact ‚ü®U, (‚Üë) '' U, hU, ha, subset_iInter‚ÇÇ fun s _ => s.2.1.connectedComponent_subset s.2.2,\n      (connectedComponents_preimage_image U).symm ‚ñ∏ hU.biUnion_connectedComponent_eq‚ü©\n  rw [ConnectedComponents.isQuotientMap_coe.isClopen_preimage] at hU\n  refine ‚ü®V·∂ú, V, hU.compl.isOpen, hU.isOpen, ?_, hb mem_connectedComponent, disjoint_compl_left‚ü©\n  exact fun h => flip Set.Nonempty.ne_empty ha ‚ü®a, mem_connectedComponent, h‚ü©\n"}
