{"name":"CategoryTheory.bifunctorComp₁₂Obj_obj_map","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nX₁ : C₁\nX₂ : C₂\nx✝¹ x✝ : C₃\nφ : Quiver.Hom x✝¹ x✝\n⊢ Eq (((CategoryTheory.bifunctorComp₁₂Obj F₁₂ G X₁).obj X₂).map φ) ((G.obj ((F₁₂.obj X₁).obj X₂)).map φ)","decl":"/-- Auxiliary definition for `bifunctorComp₁₂`. -/\n@[simps]\ndef bifunctorComp₁₂Obj (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) (G : C₁₂ ⥤ C₃ ⥤ C₄) (X₁ : C₁) :\n    C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₂ :=\n    { obj := fun X₃ => (G.obj ((F₁₂.obj X₁).obj X₂)).obj X₃\n      map := fun {_ _} φ => (G.obj ((F₁₂.obj X₁).obj X₂)).map φ }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ => (G.map ((F₁₂.obj X₁).map φ)).app X₃ }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂Obj_obj_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq (((CategoryTheory.bifunctorComp₁₂Obj F₁₂ G X₁).obj X₂).obj X₃) ((G.obj ((F₁₂.obj X₁).obj X₂)).obj X₃)","decl":"/-- Auxiliary definition for `bifunctorComp₁₂`. -/\n@[simps]\ndef bifunctorComp₁₂Obj (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) (G : C₁₂ ⥤ C₃ ⥤ C₄) (X₁ : C₁) :\n    C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₂ :=\n    { obj := fun X₃ => (G.obj ((F₁₂.obj X₁).obj X₂)).obj X₃\n      map := fun {_ _} φ => (G.obj ((F₁₂.obj X₁).obj X₂)).map φ }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ => (G.map ((F₁₂.obj X₁).map φ)).app X₃ }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂Obj_map_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nX₁ : C₁\nX₂ Y₂ : C₂\nφ : Quiver.Hom X₂ Y₂\nX₃ : C₃\n⊢ Eq (((CategoryTheory.bifunctorComp₁₂Obj F₁₂ G X₁).map φ).app X₃) ((G.map ((F₁₂.obj X₁).map φ)).app X₃)","decl":"/-- Auxiliary definition for `bifunctorComp₁₂`. -/\n@[simps]\ndef bifunctorComp₁₂Obj (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) (G : C₁₂ ⥤ C₃ ⥤ C₄) (X₁ : C₁) :\n    C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₂ :=\n    { obj := fun X₃ => (G.obj ((F₁₂.obj X₁).obj X₂)).obj X₃\n      map := fun {_ _} φ => (G.obj ((F₁₂.obj X₁).obj X₂)).map φ }\n  map {X₂ Y₂} φ :=\n    { app := fun X₃ => (G.map ((F₁₂.obj X₁).map φ)).app X₃ }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂_map_app_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nX₁ Y₁ : C₁\nφ : Quiver.Hom X₁ Y₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq ((((CategoryTheory.bifunctorComp₁₂ F₁₂ G).map φ).app X₂).app X₃) ((G.map ((F₁₂.map φ).app X₂)).app X₃)","decl":"/-- Given two bifunctors `F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂` and `G : C₁₂ ⥤ C₃ ⥤ C₄`, this is\nthe trifunctor `C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` obtained by composition. -/\n@[simps]\ndef bifunctorComp₁₂ (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) (G : C₁₂ ⥤ C₃ ⥤ C₄) :\n    C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₁ := bifunctorComp₁₂Obj F₁₂ G X₁\n  map {X₁ Y₁} φ :=\n    { app := fun X₂ =>\n        { app := fun X₃ => (G.map ((F₁₂.map φ).app X₂)).app X₃ }\n      naturality := fun {X₂ Y₂} ψ => by\n        ext X₃\n        dsimp\n        simp only [← NatTrans.comp_app, ← G.map_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nX₁ : C₁\n⊢ Eq ((CategoryTheory.bifunctorComp₁₂ F₁₂ G).obj X₁) (CategoryTheory.bifunctorComp₁₂Obj F₁₂ G X₁)","decl":"/-- Given two bifunctors `F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂` and `G : C₁₂ ⥤ C₃ ⥤ C₄`, this is\nthe trifunctor `C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` obtained by composition. -/\n@[simps]\ndef bifunctorComp₁₂ (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) (G : C₁₂ ⥤ C₃ ⥤ C₄) :\n    C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₁ := bifunctorComp₁₂Obj F₁₂ G X₁\n  map {X₁ Y₁} φ :=\n    { app := fun X₂ =>\n        { app := fun X₃ => (G.map ((F₁₂.map φ).app X₂)).app X₃ }\n      naturality := fun {X₂ Y₂} ψ => by\n        ext X₃\n        dsimp\n        simp only [← NatTrans.comp_app, ← G.map_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂FunctorObj_map_app_app_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG G' : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nφ : Quiver.Hom G G'\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq (((((CategoryTheory.bifunctorComp₁₂FunctorObj F₁₂).map φ).app X₁).app X₂).app X₃) ((φ.app ((F₁₂.obj X₁).obj X₂)).app X₃)","decl":"/-- Auxiliary definition for `bifunctorComp₁₂Functor`. -/\n@[simps]\ndef bifunctorComp₁₂FunctorObj (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) :\n    (C₁₂ ⥤ C₃ ⥤ C₄) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj G := bifunctorComp₁₂ F₁₂ G\n  map {G G'} φ :=\n    { app X₁ :=\n        { app X₂ :=\n            { app X₃ := (φ.app ((F₁₂.obj X₁).obj X₂)).app X₃ }\n          naturality := fun X₂ Y₂ f ↦ by\n            ext X₃\n            dsimp\n            simp only [← NatTrans.comp_app, NatTrans.naturality] }\n      naturality X₁ Y₁ f := by\n        ext X₂ X₃\n        dsimp\n        simp only [← NatTrans.comp_app, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂FunctorObj_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\n⊢ Eq ((CategoryTheory.bifunctorComp₁₂FunctorObj F₁₂).obj G) (CategoryTheory.bifunctorComp₁₂ F₁₂ G)","decl":"/-- Auxiliary definition for `bifunctorComp₁₂Functor`. -/\n@[simps]\ndef bifunctorComp₁₂FunctorObj (F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂) :\n    (C₁₂ ⥤ C₃ ⥤ C₄) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj G := bifunctorComp₁₂ F₁₂ G\n  map {G G'} φ :=\n    { app X₁ :=\n        { app X₂ :=\n            { app X₃ := (φ.app ((F₁₂.obj X₁).obj X₂)).app X₃ }\n          naturality := fun X₂ Y₂ f ↦ by\n            ext X₃\n            dsimp\n            simp only [← NatTrans.comp_app, NatTrans.naturality] }\n      naturality X₁ Y₁ f := by\n        ext X₂ X₃\n        dsimp\n        simp only [← NatTrans.comp_app, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂FunctorMap_app_app_app_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ F₁₂' : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nφ : Quiver.Hom F₁₂ F₁₂'\nG : CategoryTheory.Functor C₁₂ (CategoryTheory.Functor C₃ C₄)\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq (((((CategoryTheory.bifunctorComp₁₂FunctorMap φ).app G).app X₁).app X₂).app X₃) ((G.map ((φ.app X₁).app X₂)).app X₃)","decl":"/-- Auxiliary definition for `bifunctorComp₁₂Functor`. -/\n@[simps]\ndef bifunctorComp₁₂FunctorMap {F₁₂ F₁₂' : C₁ ⥤ C₂ ⥤ C₁₂} (φ : F₁₂ ⟶ F₁₂') :\n    bifunctorComp₁₂FunctorObj (C₃ := C₃) (C₄ := C₄) F₁₂ ⟶ bifunctorComp₁₂FunctorObj F₁₂' where\n  app G :=\n    { app X₁ :=\n        { app X₂ := { app X₃ := (G.map ((φ.app X₁).app X₂)).app X₃ }\n          naturality := fun X₂ Y₂ f ↦ by\n            ext X₃\n            dsimp\n            simp only [← NatTrans.comp_app, NatTrans.naturality, ← G.map_comp] }\n      naturality X₁ Y₁ f := by\n        ext X₂ X₃\n        dsimp\n        simp only [← NatTrans.comp_app, NatTrans.naturality, ← G.map_comp] }\n  naturality G G' f := by\n    ext X₁ X₂ X₃\n    dsimp\n    simp only [← NatTrans.comp_app, NatTrans.naturality]\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂Functor_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nF₁₂ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\n⊢ Eq (CategoryTheory.bifunctorComp₁₂Functor.obj F₁₂) (CategoryTheory.bifunctorComp₁₂FunctorObj F₁₂)","decl":"/-- The functor `(C₁ ⥤ C₂ ⥤ C₁₂) ⥤ (C₁₂ ⥤ C₃ ⥤ C₄) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` which\nsends `F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂` and `G : C₁₂ ⥤ C₃ ⥤ C₄` to the functor\n`bifunctorComp₁₂ F₁₂ G : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`. -/\n@[simps]\ndef bifunctorComp₁₂Functor : (C₁ ⥤ C₂ ⥤ C₁₂) ⥤ (C₁₂ ⥤ C₃ ⥤ C₄) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj := bifunctorComp₁₂FunctorObj\n  map := bifunctorComp₁₂FunctorMap\n\n"}
{"name":"CategoryTheory.bifunctorComp₁₂Functor_map","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₁₂ : Type u_5\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_5} C₁₂\nX✝ Y✝ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂ C₁₂)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.bifunctorComp₁₂Functor.map φ) (CategoryTheory.bifunctorComp₁₂FunctorMap φ)","decl":"/-- The functor `(C₁ ⥤ C₂ ⥤ C₁₂) ⥤ (C₁₂ ⥤ C₃ ⥤ C₄) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` which\nsends `F₁₂ : C₁ ⥤ C₂ ⥤ C₁₂` and `G : C₁₂ ⥤ C₃ ⥤ C₄` to the functor\n`bifunctorComp₁₂ F₁₂ G : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`. -/\n@[simps]\ndef bifunctorComp₁₂Functor : (C₁ ⥤ C₂ ⥤ C₁₂) ⥤ (C₁₂ ⥤ C₃ ⥤ C₄) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj := bifunctorComp₁₂FunctorObj\n  map := bifunctorComp₁₂FunctorMap\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃Obj_obj_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq (((CategoryTheory.bifunctorComp₂₃Obj F G₂₃ X₁).obj X₂).obj X₃) ((F.obj X₁).obj ((G₂₃.obj X₂).obj X₃))","decl":"/-- Auxiliary definition for `bifunctorComp₂₃`. -/\n@[simps]\ndef bifunctorComp₂₃Obj (F : C₁ ⥤ C₂₃ ⥤ C₄) (G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃) (X₁ : C₁) :\n    C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₂ :=\n    { obj X₃ := (F.obj X₁).obj ((G₂₃.obj X₂).obj X₃)\n      map φ := (F.obj X₁).map ((G₂₃.obj X₂).map φ) }\n  map {X₂ Y₂} φ :=\n    { app X₃ := (F.obj X₁).map ((G₂₃.map φ).app X₃)\n      naturality X₃ Y₃ φ := by\n        dsimp\n        simp only [← Functor.map_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃Obj_map_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nX₁ : C₁\nX₂ Y₂ : C₂\nφ : Quiver.Hom X₂ Y₂\nX₃ : C₃\n⊢ Eq (((CategoryTheory.bifunctorComp₂₃Obj F G₂₃ X₁).map φ).app X₃) ((F.obj X₁).map ((G₂₃.map φ).app X₃))","decl":"/-- Auxiliary definition for `bifunctorComp₂₃`. -/\n@[simps]\ndef bifunctorComp₂₃Obj (F : C₁ ⥤ C₂₃ ⥤ C₄) (G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃) (X₁ : C₁) :\n    C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₂ :=\n    { obj X₃ := (F.obj X₁).obj ((G₂₃.obj X₂).obj X₃)\n      map φ := (F.obj X₁).map ((G₂₃.obj X₂).map φ) }\n  map {X₂ Y₂} φ :=\n    { app X₃ := (F.obj X₁).map ((G₂₃.map φ).app X₃)\n      naturality X₃ Y₃ φ := by\n        dsimp\n        simp only [← Functor.map_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃Obj_obj_map","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nX₁ : C₁\nX₂ : C₂\nX✝ Y✝ : C₃\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.bifunctorComp₂₃Obj F G₂₃ X₁).obj X₂).map φ) ((F.obj X₁).map ((G₂₃.obj X₂).map φ))","decl":"/-- Auxiliary definition for `bifunctorComp₂₃`. -/\n@[simps]\ndef bifunctorComp₂₃Obj (F : C₁ ⥤ C₂₃ ⥤ C₄) (G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃) (X₁ : C₁) :\n    C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₂ :=\n    { obj X₃ := (F.obj X₁).obj ((G₂₃.obj X₂).obj X₃)\n      map φ := (F.obj X₁).map ((G₂₃.obj X₂).map φ) }\n  map {X₂ Y₂} φ :=\n    { app X₃ := (F.obj X₁).map ((G₂₃.map φ).app X₃)\n      naturality X₃ Y₃ φ := by\n        dsimp\n        simp only [← Functor.map_comp, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nX₁ : C₁\n⊢ Eq ((CategoryTheory.bifunctorComp₂₃ F G₂₃).obj X₁) (CategoryTheory.bifunctorComp₂₃Obj F G₂₃ X₁)","decl":"/-- Given two bifunctors `F : C₁ ⥤ C₂₃ ⥤ C₄` and `G₂₃ : C₂ ⥤ C₃ ⥤ C₄`, this is\nthe trifunctor `C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` obtained by composition. -/\n@[simps]\ndef bifunctorComp₂₃ (F : C₁ ⥤ C₂₃ ⥤ C₄) (G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃) :\n    C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₁ := bifunctorComp₂₃Obj F G₂₃ X₁\n  map {X₁ Y₁} φ :=\n    { app := fun X₂ =>\n        { app := fun X₃ => (F.map φ).app ((G₂₃.obj X₂).obj X₃) } }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃_map_app_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nX₁ Y₁ : C₁\nφ : Quiver.Hom X₁ Y₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq ((((CategoryTheory.bifunctorComp₂₃ F G₂₃).map φ).app X₂).app X₃) ((F.map φ).app ((G₂₃.obj X₂).obj X₃))","decl":"/-- Given two bifunctors `F : C₁ ⥤ C₂₃ ⥤ C₄` and `G₂₃ : C₂ ⥤ C₃ ⥤ C₄`, this is\nthe trifunctor `C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` obtained by composition. -/\n@[simps]\ndef bifunctorComp₂₃ (F : C₁ ⥤ C₂₃ ⥤ C₄) (G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃) :\n    C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj X₁ := bifunctorComp₂₃Obj F G₂₃ X₁\n  map {X₁ Y₁} φ :=\n    { app := fun X₂ =>\n        { app := fun X₃ => (F.map φ).app ((G₂₃.obj X₂).obj X₃) } }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃FunctorObj_map_app_app_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ G₂₃' : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nφ : Quiver.Hom G₂₃ G₂₃'\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq (((((CategoryTheory.bifunctorComp₂₃FunctorObj F).map φ).app X₁).app X₂).app X₃) ((F.obj X₁).map ((φ.app X₂).app X₃))","decl":"/-- Auxiliary definition for `bifunctorComp₂₃Functor`. -/\n@[simps]\ndef bifunctorComp₂₃FunctorObj (F : C₁ ⥤ C₂₃ ⥤ C₄) :\n    (C₂ ⥤ C₃ ⥤ C₂₃) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj G₂₃ := bifunctorComp₂₃ F G₂₃\n  map {G₂₃ G₂₃'} φ :=\n    { app X₁ :=\n        { app X₂ :=\n            { app X₃ := (F.obj X₁).map ((φ.app X₂).app X₃)\n              naturality X₃ Y₃ f := by\n                dsimp\n                simp only [← Functor.map_comp, NatTrans.naturality] }\n          naturality X₂ Y₂ f := by\n            ext X₃\n            dsimp\n            simp only [← NatTrans.comp_app, ← Functor.map_comp, NatTrans.naturality] } }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃FunctorObj_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\n⊢ Eq ((CategoryTheory.bifunctorComp₂₃FunctorObj F).obj G₂₃) (CategoryTheory.bifunctorComp₂₃ F G₂₃)","decl":"/-- Auxiliary definition for `bifunctorComp₂₃Functor`. -/\n@[simps]\ndef bifunctorComp₂₃FunctorObj (F : C₁ ⥤ C₂₃ ⥤ C₄) :\n    (C₂ ⥤ C₃ ⥤ C₂₃) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj G₂₃ := bifunctorComp₂₃ F G₂₃\n  map {G₂₃ G₂₃'} φ :=\n    { app X₁ :=\n        { app X₂ :=\n            { app X₃ := (F.obj X₁).map ((φ.app X₂).app X₃)\n              naturality X₃ Y₃ f := by\n                dsimp\n                simp only [← Functor.map_comp, NatTrans.naturality] }\n          naturality X₂ Y₂ f := by\n            ext X₃\n            dsimp\n            simp only [← NatTrans.comp_app, ← Functor.map_comp, NatTrans.naturality] } }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃FunctorMap_app_app_app_app","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF F' : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nφ : Quiver.Hom F F'\nG₂₃ : CategoryTheory.Functor C₂ (CategoryTheory.Functor C₃ C₂₃)\nX₁ : C₁\nX₂ : C₂\nX₃ : C₃\n⊢ Eq (((((CategoryTheory.bifunctorComp₂₃FunctorMap φ).app G₂₃).app X₁).app X₂).app X₃) ((φ.app X₁).app ((G₂₃.obj X₂).obj X₃))","decl":"/-- Auxiliary definition for `bifunctorComp₂₃Functor`. -/\n@[simps]\ndef bifunctorComp₂₃FunctorMap {F F' : C₁ ⥤ C₂₃ ⥤ C₄} (φ : F ⟶ F') :\n    bifunctorComp₂₃FunctorObj F (C₂ := C₂) (C₃ := C₃) ⟶ bifunctorComp₂₃FunctorObj F' where\n  app G₂₃ :=\n    { app X₁ := { app X₂ := { app X₃ := (φ.app X₁).app ((G₂₃.obj X₂).obj X₃) } }\n      naturality X₁ Y₁ f := by\n        ext X₂ X₃\n        dsimp\n        simp only [← NatTrans.comp_app, NatTrans.naturality] }\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃Functor_map","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nX✝ Y✝ : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\nφ : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.bifunctorComp₂₃Functor.map φ) (CategoryTheory.bifunctorComp₂₃FunctorMap φ)","decl":"/-- The functor `(C₁ ⥤ C₂₃ ⥤ C₄) ⥤ (C₂ ⥤ C₃ ⥤ C₂₃) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` which\nsends `F : C₁ ⥤ C₂₃ ⥤ C₄` and `G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃` to the\nfunctor `bifunctorComp₂₃ F G₂₃ : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`. -/\n@[simps]\ndef bifunctorComp₂₃Functor :\n    (C₁ ⥤ C₂₃ ⥤ C₄) ⥤ (C₂ ⥤ C₃ ⥤ C₂₃) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj := bifunctorComp₂₃FunctorObj\n  map := bifunctorComp₂₃FunctorMap\n\n"}
{"name":"CategoryTheory.bifunctorComp₂₃Functor_obj","module":"Mathlib.CategoryTheory.Functor.Trifunctor","initialProofState":"C₁ : Type u_1\nC₂ : Type u_2\nC₃ : Type u_3\nC₄ : Type u_4\nC₂₃ : Type u_6\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C₁\ninst✝³ : CategoryTheory.Category.{u_8, u_2} C₂\ninst✝² : CategoryTheory.Category.{u_9, u_3} C₃\ninst✝¹ : CategoryTheory.Category.{u_10, u_4} C₄\ninst✝ : CategoryTheory.Category.{u_11, u_6} C₂₃\nF : CategoryTheory.Functor C₁ (CategoryTheory.Functor C₂₃ C₄)\n⊢ Eq (CategoryTheory.bifunctorComp₂₃Functor.obj F) (CategoryTheory.bifunctorComp₂₃FunctorObj F)","decl":"/-- The functor `(C₁ ⥤ C₂₃ ⥤ C₄) ⥤ (C₂ ⥤ C₃ ⥤ C₂₃) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄` which\nsends `F : C₁ ⥤ C₂₃ ⥤ C₄` and `G₂₃ : C₂ ⥤ C₃ ⥤ C₂₃` to the\nfunctor `bifunctorComp₂₃ F G₂₃ : C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄`. -/\n@[simps]\ndef bifunctorComp₂₃Functor :\n    (C₁ ⥤ C₂₃ ⥤ C₄) ⥤ (C₂ ⥤ C₃ ⥤ C₂₃) ⥤ C₁ ⥤ C₂ ⥤ C₃ ⥤ C₄ where\n  obj := bifunctorComp₂₃FunctorObj\n  map := bifunctorComp₂₃FunctorMap\n\n"}
