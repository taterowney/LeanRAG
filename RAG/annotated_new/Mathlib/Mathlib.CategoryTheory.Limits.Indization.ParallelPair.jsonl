{"name":"CategoryTheory.IndParallelPairPresentation.hI","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nself : CategoryTheory.IndParallelPairPresentation f g\n⊢ CategoryTheory.IsFiltered self.I","decl":"/-- Structure containing data exhibiting two parallel natural transformations `f` and `g` between\npresheaves `A` and `B` as induced by a natural transformation in a functor category exhibiting\n`A` and `B` as ind-objects. -/\nstructure IndParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (f g : A ⟶ B) where\n  /-- The indexing category. -/\n  I : Type v₁\n  /-- Category instance on the indexing category. -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram presenting `A`. -/\n  F₁ : I ⥤ C\n  /-- The diagram presenting `B`. -/\n  F₂ : I ⥤ C\n  /-- The cocone on `F₁` with apex `A`. -/\n  ι₁ : F₁ ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- The cocone on `F₁` with apex `A` is a colimit cocone. -/\n  isColimit₁ : IsColimit (Cocone.mk A ι₁)\n  /-- The cocone on `F₂` with apex `B`. -/\n  ι₂ : F₂ ⋙ yoneda ⟶ (Functor.const I).obj B\n  /-- The cocone on `F₂` with apex `B` is a colimit cocone. -/\n  isColimit₂ : IsColimit (Cocone.mk B ι₂)\n  /-- The natural transformation presenting `f`. -/\n  φ : F₁ ⟶ F₂\n  /-- The natural transformation presenting `g`. -/\n  ψ : F₁ ⟶ F₂\n  /-- `f` is in fact presented by `φ`. -/\n  hf : f = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight φ yoneda)\n  /-- `g` is in fact presented by `ψ`. -/\n  hg : g = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight ψ yoneda)\n\n"}
{"name":"CategoryTheory.IndParallelPairPresentation.hf","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nself : CategoryTheory.IndParallelPairPresentation f g\n⊢ Eq f (self.isColimit₁.map { pt := B, ι := self.ι₂ } (CategoryTheory.whiskerRight self.φ CategoryTheory.yoneda))","decl":"/-- Structure containing data exhibiting two parallel natural transformations `f` and `g` between\npresheaves `A` and `B` as induced by a natural transformation in a functor category exhibiting\n`A` and `B` as ind-objects. -/\nstructure IndParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (f g : A ⟶ B) where\n  /-- The indexing category. -/\n  I : Type v₁\n  /-- Category instance on the indexing category. -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram presenting `A`. -/\n  F₁ : I ⥤ C\n  /-- The diagram presenting `B`. -/\n  F₂ : I ⥤ C\n  /-- The cocone on `F₁` with apex `A`. -/\n  ι₁ : F₁ ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- The cocone on `F₁` with apex `A` is a colimit cocone. -/\n  isColimit₁ : IsColimit (Cocone.mk A ι₁)\n  /-- The cocone on `F₂` with apex `B`. -/\n  ι₂ : F₂ ⋙ yoneda ⟶ (Functor.const I).obj B\n  /-- The cocone on `F₂` with apex `B` is a colimit cocone. -/\n  isColimit₂ : IsColimit (Cocone.mk B ι₂)\n  /-- The natural transformation presenting `f`. -/\n  φ : F₁ ⟶ F₂\n  /-- The natural transformation presenting `g`. -/\n  ψ : F₁ ⟶ F₂\n  /-- `f` is in fact presented by `φ`. -/\n  hf : f = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight φ yoneda)\n  /-- `g` is in fact presented by `ψ`. -/\n  hg : g = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight ψ yoneda)\n\n"}
{"name":"CategoryTheory.IndParallelPairPresentation.hg","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nself : CategoryTheory.IndParallelPairPresentation f g\n⊢ Eq g (self.isColimit₁.map { pt := B, ι := self.ι₂ } (CategoryTheory.whiskerRight self.ψ CategoryTheory.yoneda))","decl":"/-- Structure containing data exhibiting two parallel natural transformations `f` and `g` between\npresheaves `A` and `B` as induced by a natural transformation in a functor category exhibiting\n`A` and `B` as ind-objects. -/\nstructure IndParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (f g : A ⟶ B) where\n  /-- The indexing category. -/\n  I : Type v₁\n  /-- Category instance on the indexing category. -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram presenting `A`. -/\n  F₁ : I ⥤ C\n  /-- The diagram presenting `B`. -/\n  F₂ : I ⥤ C\n  /-- The cocone on `F₁` with apex `A`. -/\n  ι₁ : F₁ ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- The cocone on `F₁` with apex `A` is a colimit cocone. -/\n  isColimit₁ : IsColimit (Cocone.mk A ι₁)\n  /-- The cocone on `F₂` with apex `B`. -/\n  ι₂ : F₂ ⋙ yoneda ⟶ (Functor.const I).obj B\n  /-- The cocone on `F₂` with apex `B` is a colimit cocone. -/\n  isColimit₂ : IsColimit (Cocone.mk B ι₂)\n  /-- The natural transformation presenting `f`. -/\n  φ : F₁ ⟶ F₂\n  /-- The natural transformation presenting `g`. -/\n  ψ : F₁ ⟶ F₂\n  /-- `f` is in fact presented by `φ`. -/\n  hf : f = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight φ yoneda)\n  /-- `g` is in fact presented by `ψ`. -/\n  hg : g = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight ψ yoneda)\n\n"}
{"name":"CategoryTheory.IndParallelPairPresentation.mk.inj","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nI✝ : Type v₁\nℐ✝ : CategoryTheory.SmallCategory I✝\nhI✝ : CategoryTheory.IsFiltered I✝\nF₁✝ F₂✝ : CategoryTheory.Functor I✝ C\nι₁✝ : Quiver.Hom (F₁✝.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I✝).obj A)\nisColimit₁✝ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι₁✝ }\nι₂✝ : Quiver.Hom (F₂✝.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I✝).obj B)\nisColimit₂✝ : CategoryTheory.Limits.IsColimit { pt := B, ι := ι₂✝ }\nφ✝ ψ✝ : Quiver.Hom F₁✝ F₂✝\nhf✝ : Eq f (isColimit₁✝.map { pt := B, ι := ι₂✝ } (CategoryTheory.whiskerRight φ✝ CategoryTheory.yoneda))\nhg✝ : Eq g (isColimit₁✝.map { pt := B, ι := ι₂✝ } (CategoryTheory.whiskerRight ψ✝ CategoryTheory.yoneda))\nI : Type v₁\nℐ : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF₁ F₂ : CategoryTheory.Functor I C\nι₁ : Quiver.Hom (F₁.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit₁ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι₁ }\nι₂ : Quiver.Hom (F₂.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj B)\nisColimit₂ : CategoryTheory.Limits.IsColimit { pt := B, ι := ι₂ }\nφ ψ : Quiver.Hom F₁ F₂\nhf : Eq f (isColimit₁.map { pt := B, ι := ι₂ } (CategoryTheory.whiskerRight φ CategoryTheory.yoneda))\nhg : Eq g (isColimit₁.map { pt := B, ι := ι₂ } (CategoryTheory.whiskerRight ψ CategoryTheory.yoneda))\nx✝ : Eq (CategoryTheory.IndParallelPairPresentation.mk I✝ F₁✝ F₂✝ ι₁✝ isColimit₁✝ ι₂✝ isColimit₂✝ φ✝ ψ✝ hf✝ hg✝) (CategoryTheory.IndParallelPairPresentation.mk I F₁ F₂ ι₁ isColimit₁ ι₂ isColimit₂ φ ψ hf hg)\n⊢ And (Eq I✝ I) (And (HEq ℐ✝ ℐ) (And (HEq F₁✝ F₁) (And (HEq F₂✝ F₂) (And (HEq ι₁✝ ι₁) (And (HEq isColimit₁✝ isColimit₁) (And (HEq ι₂✝ ι₂) (And (HEq isColimit₂✝ isColimit₂) (And (HEq φ✝ φ) (HEq ψ✝ ψ)))))))))","decl":"/-- Structure containing data exhibiting two parallel natural transformations `f` and `g` between\npresheaves `A` and `B` as induced by a natural transformation in a functor category exhibiting\n`A` and `B` as ind-objects. -/\nstructure IndParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (f g : A ⟶ B) where\n  /-- The indexing category. -/\n  I : Type v₁\n  /-- Category instance on the indexing category. -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram presenting `A`. -/\n  F₁ : I ⥤ C\n  /-- The diagram presenting `B`. -/\n  F₂ : I ⥤ C\n  /-- The cocone on `F₁` with apex `A`. -/\n  ι₁ : F₁ ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- The cocone on `F₁` with apex `A` is a colimit cocone. -/\n  isColimit₁ : IsColimit (Cocone.mk A ι₁)\n  /-- The cocone on `F₂` with apex `B`. -/\n  ι₂ : F₂ ⋙ yoneda ⟶ (Functor.const I).obj B\n  /-- The cocone on `F₂` with apex `B` is a colimit cocone. -/\n  isColimit₂ : IsColimit (Cocone.mk B ι₂)\n  /-- The natural transformation presenting `f`. -/\n  φ : F₁ ⟶ F₂\n  /-- The natural transformation presenting `g`. -/\n  ψ : F₁ ⟶ F₂\n  /-- `f` is in fact presented by `φ`. -/\n  hf : f = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight φ yoneda)\n  /-- `g` is in fact presented by `ψ`. -/\n  hg : g = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight ψ yoneda)\n\n"}
{"name":"CategoryTheory.IndParallelPairPresentation.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\ninst✝ : SizeOf C\nI : Type v₁\nℐ : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF₁ F₂ : CategoryTheory.Functor I C\nι₁ : Quiver.Hom (F₁.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit₁ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι₁ }\nι₂ : Quiver.Hom (F₂.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj B)\nisColimit₂ : CategoryTheory.Limits.IsColimit { pt := B, ι := ι₂ }\nφ ψ : Quiver.Hom F₁ F₂\nhf : Eq f (isColimit₁.map { pt := B, ι := ι₂ } (CategoryTheory.whiskerRight φ CategoryTheory.yoneda))\nhg : Eq g (isColimit₁.map { pt := B, ι := ι₂ } (CategoryTheory.whiskerRight ψ CategoryTheory.yoneda))\n⊢ Eq (SizeOf.sizeOf (CategoryTheory.IndParallelPairPresentation.mk I F₁ F₂ ι₁ isColimit₁ ι₂ isColimit₂ φ ψ hf hg)) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf ℐ)) (SizeOf.sizeOf hI)) (SizeOf.sizeOf F₁)) (SizeOf.sizeOf F₂)) (SizeOf.sizeOf ι₁)) (SizeOf.sizeOf isColimit₁)) (SizeOf.sizeOf ι₂)) (SizeOf.sizeOf isColimit₂)) (SizeOf.sizeOf φ)) (SizeOf.sizeOf ψ)) (SizeOf.sizeOf hf)) (SizeOf.sizeOf hg))","decl":"/-- Structure containing data exhibiting two parallel natural transformations `f` and `g` between\npresheaves `A` and `B` as induced by a natural transformation in a functor category exhibiting\n`A` and `B` as ind-objects. -/\nstructure IndParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (f g : A ⟶ B) where\n  /-- The indexing category. -/\n  I : Type v₁\n  /-- Category instance on the indexing category. -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram presenting `A`. -/\n  F₁ : I ⥤ C\n  /-- The diagram presenting `B`. -/\n  F₂ : I ⥤ C\n  /-- The cocone on `F₁` with apex `A`. -/\n  ι₁ : F₁ ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- The cocone on `F₁` with apex `A` is a colimit cocone. -/\n  isColimit₁ : IsColimit (Cocone.mk A ι₁)\n  /-- The cocone on `F₂` with apex `B`. -/\n  ι₂ : F₂ ⋙ yoneda ⟶ (Functor.const I).obj B\n  /-- The cocone on `F₂` with apex `B` is a colimit cocone. -/\n  isColimit₂ : IsColimit (Cocone.mk B ι₂)\n  /-- The natural transformation presenting `f`. -/\n  φ : F₁ ⟶ F₂\n  /-- The natural transformation presenting `g`. -/\n  ψ : F₁ ⟶ F₂\n  /-- `f` is in fact presented by `φ`. -/\n  hf : f = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight φ yoneda)\n  /-- `g` is in fact presented by `ψ`. -/\n  hg : g = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight ψ yoneda)\n\n"}
{"name":"CategoryTheory.IndParallelPairPresentation.mk.injEq","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nI✝ : Type v₁\nℐ✝ : CategoryTheory.SmallCategory I✝\nhI✝ : CategoryTheory.IsFiltered I✝\nF₁✝ F₂✝ : CategoryTheory.Functor I✝ C\nι₁✝ : Quiver.Hom (F₁✝.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I✝).obj A)\nisColimit₁✝ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι₁✝ }\nι₂✝ : Quiver.Hom (F₂✝.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I✝).obj B)\nisColimit₂✝ : CategoryTheory.Limits.IsColimit { pt := B, ι := ι₂✝ }\nφ✝ ψ✝ : Quiver.Hom F₁✝ F₂✝\nhf✝ : Eq f (isColimit₁✝.map { pt := B, ι := ι₂✝ } (CategoryTheory.whiskerRight φ✝ CategoryTheory.yoneda))\nhg✝ : Eq g (isColimit₁✝.map { pt := B, ι := ι₂✝ } (CategoryTheory.whiskerRight ψ✝ CategoryTheory.yoneda))\nI : Type v₁\nℐ : CategoryTheory.SmallCategory I\nhI : CategoryTheory.IsFiltered I\nF₁ F₂ : CategoryTheory.Functor I C\nι₁ : Quiver.Hom (F₁.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj A)\nisColimit₁ : CategoryTheory.Limits.IsColimit { pt := A, ι := ι₁ }\nι₂ : Quiver.Hom (F₂.comp CategoryTheory.yoneda) ((CategoryTheory.Functor.const I).obj B)\nisColimit₂ : CategoryTheory.Limits.IsColimit { pt := B, ι := ι₂ }\nφ ψ : Quiver.Hom F₁ F₂\nhf : Eq f (isColimit₁.map { pt := B, ι := ι₂ } (CategoryTheory.whiskerRight φ CategoryTheory.yoneda))\nhg : Eq g (isColimit₁.map { pt := B, ι := ι₂ } (CategoryTheory.whiskerRight ψ CategoryTheory.yoneda))\n⊢ Eq (Eq (CategoryTheory.IndParallelPairPresentation.mk I✝ F₁✝ F₂✝ ι₁✝ isColimit₁✝ ι₂✝ isColimit₂✝ φ✝ ψ✝ hf✝ hg✝) (CategoryTheory.IndParallelPairPresentation.mk I F₁ F₂ ι₁ isColimit₁ ι₂ isColimit₂ φ ψ hf hg)) (And (Eq I✝ I) (And (HEq ℐ✝ ℐ) (And (HEq F₁✝ F₁) (And (HEq F₂✝ F₂) (And (HEq ι₁✝ ι₁) (And (HEq isColimit₁✝ isColimit₁) (And (HEq ι₂✝ ι₂) (And (HEq isColimit₂✝ isColimit₂) (And (HEq φ✝ φ) (HEq ψ✝ ψ))))))))))","decl":"/-- Structure containing data exhibiting two parallel natural transformations `f` and `g` between\npresheaves `A` and `B` as induced by a natural transformation in a functor category exhibiting\n`A` and `B` as ind-objects. -/\nstructure IndParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (f g : A ⟶ B) where\n  /-- The indexing category. -/\n  I : Type v₁\n  /-- Category instance on the indexing category. -/\n  [ℐ : SmallCategory I]\n  [hI : IsFiltered I]\n  /-- The diagram presenting `A`. -/\n  F₁ : I ⥤ C\n  /-- The diagram presenting `B`. -/\n  F₂ : I ⥤ C\n  /-- The cocone on `F₁` with apex `A`. -/\n  ι₁ : F₁ ⋙ yoneda ⟶ (Functor.const I).obj A\n  /-- The cocone on `F₁` with apex `A` is a colimit cocone. -/\n  isColimit₁ : IsColimit (Cocone.mk A ι₁)\n  /-- The cocone on `F₂` with apex `B`. -/\n  ι₂ : F₂ ⋙ yoneda ⟶ (Functor.const I).obj B\n  /-- The cocone on `F₂` with apex `B` is a colimit cocone. -/\n  isColimit₂ : IsColimit (Cocone.mk B ι₂)\n  /-- The natural transformation presenting `f`. -/\n  φ : F₁ ⟶ F₂\n  /-- The natural transformation presenting `g`. -/\n  ψ : F₁ ⟶ F₂\n  /-- `f` is in fact presented by `φ`. -/\n  hf : f = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight φ yoneda)\n  /-- `g` is in fact presented by `ψ`. -/\n  hg : g = IsColimit.map isColimit₁ (Cocone.mk B ι₂) (whiskerRight ψ yoneda)\n\n"}
{"name":"CategoryTheory.instIsFilteredI","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nP : CategoryTheory.IndParallelPairPresentation f g\n⊢ CategoryTheory.IsFiltered P.I","decl":"instance {A B : Cᵒᵖ ⥤ Type v₁} {f g : A ⟶ B} (P : IndParallelPairPresentation f g) :\n    IsFiltered P.I := P.hI\n\n"}
{"name":"CategoryTheory.NonemptyParallelPairPresentationAux.hf","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nP₁ : CategoryTheory.Limits.IndObjectPresentation A\nP₂ : CategoryTheory.Limits.IndObjectPresentation B\n⊢ Eq f ((CategoryTheory.NonemptyParallelPairPresentationAux.isColimit₁ f g P₁ P₂).map { pt := B, ι := CategoryTheory.NonemptyParallelPairPresentationAux.ι₂ f g P₁ P₂ } (CategoryTheory.whiskerRight (CategoryTheory.NonemptyParallelPairPresentationAux.ϕ f g P₁ P₂) CategoryTheory.yoneda))","decl":"theorem hf : f = IsColimit.map (isColimit₁ f g P₁ P₂)\n    (Cocone.mk B (ι₂ f g P₁ P₂)) (whiskerRight (ϕ f g P₁ P₂) yoneda) := by\n  refine (isColimit₁ f g P₁ P₂).hom_ext (fun i => ?_)\n  rw [IsColimit.ι_map]\n  simpa using i.hom.1.w.symm\n\n"}
{"name":"CategoryTheory.NonemptyParallelPairPresentationAux.hg","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nf g : Quiver.Hom A B\nP₁ : CategoryTheory.Limits.IndObjectPresentation A\nP₂ : CategoryTheory.Limits.IndObjectPresentation B\n⊢ Eq g ((CategoryTheory.NonemptyParallelPairPresentationAux.isColimit₁ f g P₁ P₂).map { pt := B, ι := CategoryTheory.NonemptyParallelPairPresentationAux.ι₂ f g P₁ P₂ } (CategoryTheory.whiskerRight (CategoryTheory.NonemptyParallelPairPresentationAux.ψ f g P₁ P₂) CategoryTheory.yoneda))","decl":"theorem hg : g = IsColimit.map (isColimit₁ f g P₁ P₂)\n    (Cocone.mk B (ι₂ f g P₁ P₂)) (whiskerRight (ψ f g P₁ P₂) yoneda) := by\n  refine (isColimit₁ f g P₁ P₂).hom_ext (fun i => ?_)\n  rw [IsColimit.ι_map]\n  simpa using i.hom.2.w.symm\n\n"}
{"name":"CategoryTheory.nonempty_indParallelPairPresentation","module":"Mathlib.CategoryTheory.Limits.Indization.ParallelPair","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA B : CategoryTheory.Functor (Opposite C) (Type v₁)\nhA : CategoryTheory.Limits.IsIndObject A\nhB : CategoryTheory.Limits.IsIndObject B\nf g : Quiver.Hom A B\n⊢ Nonempty (CategoryTheory.IndParallelPairPresentation f g)","decl":"theorem nonempty_indParallelPairPresentation {A B : Cᵒᵖ ⥤ Type v₁} (hA : IsIndObject A)\n    (hB : IsIndObject B) (f g : A ⟶ B) : Nonempty (IndParallelPairPresentation f g) :=\n  ⟨NonemptyParallelPairPresentationAux.presentation f g hA.presentation hB.presentation⟩\n\n"}
