{"name":"invOf_neg","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝³ : Monoid α\ninst✝² : HasDistribNeg α\na : α\ninst✝¹ : Invertible a\ninst✝ : Invertible (Neg.neg a)\n⊢ Eq (Invertible.invOf (Neg.neg a)) (Neg.neg (Invertible.invOf a))","decl":"@[simp]\ntheorem invOf_neg [Monoid α] [HasDistribNeg α] (a : α) [Invertible a] [Invertible (-a)] :\n    ⅟ (-a) = -⅟ a :=\n  invOf_eq_right_inv (by simp)\n\n"}
{"name":"one_sub_invOf_two","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝¹ : Ring α\ninst✝ : Invertible 2\n⊢ Eq (HSub.hSub 1 (Invertible.invOf 2)) (Invertible.invOf 2)","decl":"@[simp]\ntheorem one_sub_invOf_two [Ring α] [Invertible (2 : α)] : 1 - (⅟ 2 : α) = ⅟ 2 :=\n  (isUnit_of_invertible (2 : α)).mul_right_inj.1 <| by\n    rw [mul_sub, mul_invOf_self, mul_one, ← one_add_one_eq_two, add_sub_cancel_right]\n\n"}
{"name":"invOf_two_add_invOf_two","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝¹ : NonAssocSemiring α\ninst✝ : Invertible 2\n⊢ Eq (HAdd.hAdd (Invertible.invOf 2) (Invertible.invOf 2)) 1","decl":"@[simp]\ntheorem invOf_two_add_invOf_two [NonAssocSemiring α] [Invertible (2 : α)] :\n    (⅟ 2 : α) + (⅟ 2 : α) = 1 := by rw [← two_mul, mul_invOf_self]\n\n"}
{"name":"pos_of_invertible_cast","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝² : Semiring α\ninst✝¹ : Nontrivial α\nn : Nat\ninst✝ : Invertible ↑n\n⊢ LT.lt 0 n","decl":"theorem pos_of_invertible_cast [Semiring α] [Nontrivial α] (n : ℕ) [Invertible (n : α)] : 0 < n :=\n  Nat.zero_lt_of_ne_zero fun h => Invertible.ne_zero (n : α) (h ▸ Nat.cast_zero)\n\n"}
{"name":"invOf_add_invOf","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝² : Semiring α\na b : α\ninst✝¹ : Invertible a\ninst✝ : Invertible b\n⊢ Eq (HAdd.hAdd (Invertible.invOf a) (Invertible.invOf b)) (HMul.hMul (HMul.hMul (Invertible.invOf a) (HAdd.hAdd a b)) (Invertible.invOf b))","decl":"theorem invOf_add_invOf [Semiring α] (a b : α) [Invertible a] [Invertible b] :\n    ⅟a + ⅟b = ⅟a * (a + b) * ⅟b := by\n  rw [mul_add, invOf_mul_self, add_mul, one_mul, mul_assoc, mul_invOf_self, mul_one, add_comm]\n\n"}
{"name":"invOf_sub_invOf","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝² : Ring α\na b : α\ninst✝¹ : Invertible a\ninst✝ : Invertible b\n⊢ Eq (HSub.hSub (Invertible.invOf a) (Invertible.invOf b)) (HMul.hMul (HMul.hMul (Invertible.invOf a) (HSub.hSub b a)) (Invertible.invOf b))","decl":"/-- A version of `inv_sub_inv'` for `invOf`. -/\ntheorem invOf_sub_invOf [Ring α] (a b : α) [Invertible a] [Invertible b] :\n    ⅟a - ⅟b = ⅟a * (b - a) * ⅟b := by\n  rw [mul_sub, invOf_mul_self, sub_mul, one_mul, mul_assoc, mul_invOf_self, mul_one]\n\n"}
{"name":"Ring.inverse_add_inverse","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝ : Semiring α\na b : α\nh : Iff (IsUnit a) (IsUnit b)\n⊢ Eq (HAdd.hAdd (Ring.inverse a) (Ring.inverse b)) (HMul.hMul (HMul.hMul (Ring.inverse a) (HAdd.hAdd a b)) (Ring.inverse b))","decl":"/-- A version of `inv_add_inv'` for `Ring.inverse`. -/\ntheorem Ring.inverse_add_inverse [Semiring α] {a b : α} (h : IsUnit a ↔ IsUnit b) :\n    Ring.inverse a + Ring.inverse b = Ring.inverse a * (a + b) * Ring.inverse b := by\n  by_cases ha : IsUnit a\n  · have hb := h.mp ha\n    obtain ⟨ia⟩ := ha.nonempty_invertible\n    obtain ⟨ib⟩ := hb.nonempty_invertible\n    simp_rw [inverse_invertible, invOf_add_invOf]\n  · have hb := h.not.mp ha\n    simp [inverse_non_unit, ha, hb]\n\n"}
{"name":"Ring.inverse_sub_inverse","module":"Mathlib.Algebra.Ring.Invertible","initialProofState":"α : Type u\ninst✝ : Ring α\na b : α\nh : Iff (IsUnit a) (IsUnit b)\n⊢ Eq (HSub.hSub (Ring.inverse a) (Ring.inverse b)) (HMul.hMul (HMul.hMul (Ring.inverse a) (HSub.hSub b a)) (Ring.inverse b))","decl":"/-- A version of `inv_sub_inv'` for `Ring.inverse`. -/\ntheorem Ring.inverse_sub_inverse [Ring α] {a b : α} (h : IsUnit a ↔ IsUnit b) :\n    Ring.inverse a - Ring.inverse b = Ring.inverse a * (b - a) * Ring.inverse b := by\n  by_cases ha : IsUnit a\n  · have hb := h.mp ha\n    obtain ⟨ia⟩ := ha.nonempty_invertible\n    obtain ⟨ib⟩ := hb.nonempty_invertible\n    simp_rw [inverse_invertible, invOf_sub_invOf]\n  · have hb := h.not.mp ha\n    simp [inverse_non_unit, ha, hb]\n"}
