{"name":"CategoryTheory.DifferentialObject.objEqToHom_refl","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\ni : β\n⊢ Eq (X.objEqToHom ⋯) (CategoryTheory.CategoryStruct.id (X.obj i))","decl":"@[simp]\ntheorem objEqToHom_refl (i : β) : X.objEqToHom (refl i) = 𝟙 _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.DifferentialObject.objEqToHom_d","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nx y : β\nh : Eq x y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.objEqToHom h) (X.d y)) (CategoryTheory.CategoryStruct.comp (X.d x) (X.objEqToHom ⋯))","decl":"@[reassoc (attr := simp)]\ntheorem objEqToHom_d {x y : β} (h : x = y) :\n    X.objEqToHom h ≫ X.d y = X.d x ≫ X.objEqToHom (by cases h; rfl) := by cases h; dsimp; simp\n\n"}
{"name":"CategoryTheory.DifferentialObject.objEqToHom_d_assoc","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nx y : β\nh✝ : Eq x y\nZ : V\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CategoryTheory.GradedObjectWithShift b V) 1).obj X.obj y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.objEqToHom h✝) (CategoryTheory.CategoryStruct.comp (X.d y) h)) (CategoryTheory.CategoryStruct.comp (X.d x) (CategoryTheory.CategoryStruct.comp (X.objEqToHom ⋯) h))","decl":"@[reassoc (attr := simp)]\ntheorem objEqToHom_d {x y : β} (h : x = y) :\n    X.objEqToHom h ≫ X.d y = X.d x ≫ X.objEqToHom (by cases h; rfl) := by cases h; dsimp; simp\n\n"}
{"name":"CategoryTheory.DifferentialObject.d_squared_apply","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nx : β\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.d x) (X.d ((fun b_1 => HAdd.hAdd b_1 (HSMul.hSMul { as := 1 }.as b)) x))) 0","decl":"@[reassoc (attr := simp)]\ntheorem d_squared_apply {x : β} : X.d x ≫ X.d _ = 0 := congr_fun X.d_squared _\n\n"}
{"name":"CategoryTheory.DifferentialObject.d_squared_apply_assoc","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nx : β\nZ : V\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (CategoryTheory.GradedObjectWithShift b V) 1).obj X.obj (HAdd.hAdd x (HSMul.hSMul 1 b))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.d x) (CategoryTheory.CategoryStruct.comp (X.d (HAdd.hAdd x (HSMul.hSMul 1 b))) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem d_squared_apply {x : β} : X.d x ≫ X.d _ = 0 := congr_fun X.d_squared _\n\n"}
{"name":"CategoryTheory.DifferentialObject.eqToHom_f'_assoc","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX Y : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nf : Quiver.Hom X Y\nx y : β\nh✝ : Eq x y\nZ : V\nh : Quiver.Hom (Y.obj y) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.objEqToHom h✝) (CategoryTheory.CategoryStruct.comp (f.f y) h)) (CategoryTheory.CategoryStruct.comp (f.f x) (CategoryTheory.CategoryStruct.comp (Y.objEqToHom h✝) h))","decl":"@[reassoc (attr := simp)]\ntheorem eqToHom_f' {X Y : DifferentialObject ℤ (GradedObjectWithShift b V)} (f : X ⟶ Y) {x y : β}\n    (h : x = y) : X.objEqToHom h ≫ f.f y = f.f x ≫ Y.objEqToHom h := by cases h; simp\n\n"}
{"name":"CategoryTheory.DifferentialObject.eqToHom_f'","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX Y : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nf : Quiver.Hom X Y\nx y : β\nh : Eq x y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.objEqToHom h) (f.f y)) (CategoryTheory.CategoryStruct.comp (f.f x) (Y.objEqToHom h))","decl":"@[reassoc (attr := simp)]\ntheorem eqToHom_f' {X Y : DifferentialObject ℤ (GradedObjectWithShift b V)} (f : X ⟶ Y) {x y : β}\n    (h : x = y) : X.objEqToHom h ≫ f.f y = f.f x ≫ Y.objEqToHom h := by cases h; simp\n\n"}
{"name":"HomologicalComplex.d_eqToHom_assoc","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V (ComplexShape.up' b)\nx y z : β\nh✝ : Eq y z\nZ : V\nh : Quiver.Hom (X.X z) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.d x y) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) h)) (CategoryTheory.CategoryStruct.comp (X.d x z) h)","decl":"@[reassoc]\ntheorem d_eqToHom (X : HomologicalComplex V (ComplexShape.up' b)) {x y z : β} (h : y = z) :\n    X.d x y ≫ eqToHom (congr_arg X.X h) = X.d x z := by cases h; simp\n\n"}
{"name":"HomologicalComplex.d_eqToHom","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V (ComplexShape.up' b)\nx y z : β\nh : Eq y z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.d x y) (CategoryTheory.eqToHom ⋯)) (X.d x z)","decl":"@[reassoc]\ntheorem d_eqToHom (X : HomologicalComplex V (ComplexShape.up' b)) {x y z : β} (h : y = z) :\n    X.d x y ≫ eqToHom (congr_arg X.X h) = X.d x z := by cases h; simp\n\n"}
{"name":"HomologicalComplex.dgoToHomologicalComplex_obj_X","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\ni : β\n⊢ Eq (((HomologicalComplex.dgoToHomologicalComplex b V).obj X).X i) (X.obj i)","decl":"open Classical in\n/-- The functor from differential graded objects to homological complexes.\n-/\n@[simps]\ndef dgoToHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ⥤\n      HomologicalComplex V (ComplexShape.up' b) where\n  obj X :=\n    { X := fun i => X.obj i\n      d := fun i j =>\n        if h : i + b = j then X.d i ≫ X.objEqToHom (show i + (1 : ℤ) • b = j by simp [h]) else 0\n      shape := fun i j w => by dsimp at w; convert dif_neg w\n      d_comp_d' := fun i j k hij hjk => by\n        dsimp at hij hjk; substs hij hjk\n        simp }\n  map {X Y} f :=\n    { f := f.f\n      comm' := fun i j h => by\n        dsimp at h ⊢\n        subst h\n        simp only [dite_true, Category.assoc, eqToHom_f']\n        -- Porting note: this `rw` used to be part of the `simp`.\n        have : f.f i ≫ Y.d i = X.d i ≫ f.f _ := (congr_fun f.comm i).symm\n        rw [reassoc_of% this] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n"}
{"name":"HomologicalComplex.dgoToHomologicalComplex_obj_d","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\ni j : β\n⊢ Eq (((HomologicalComplex.dgoToHomologicalComplex b V).obj X).d i j) (dite (Eq (HAdd.hAdd i b) j) (fun h => CategoryTheory.CategoryStruct.comp (X.d i) (X.objEqToHom ⋯)) fun h => 0)","decl":"open Classical in\n/-- The functor from differential graded objects to homological complexes.\n-/\n@[simps]\ndef dgoToHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ⥤\n      HomologicalComplex V (ComplexShape.up' b) where\n  obj X :=\n    { X := fun i => X.obj i\n      d := fun i j =>\n        if h : i + b = j then X.d i ≫ X.objEqToHom (show i + (1 : ℤ) • b = j by simp [h]) else 0\n      shape := fun i j w => by dsimp at w; convert dif_neg w\n      d_comp_d' := fun i j k hij hjk => by\n        dsimp at hij hjk; substs hij hjk\n        simp }\n  map {X Y} f :=\n    { f := f.f\n      comm' := fun i j h => by\n        dsimp at h ⊢\n        subst h\n        simp only [dite_true, Category.assoc, eqToHom_f']\n        -- Porting note: this `rw` used to be part of the `simp`.\n        have : f.f i ≫ Y.d i = X.d i ≫ f.f _ := (congr_fun f.comm i).symm\n        rw [reassoc_of% this] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n"}
{"name":"HomologicalComplex.dgoToHomologicalComplex_map_f","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX Y : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\nf : Quiver.Hom X Y\ni : β\n⊢ Eq (((HomologicalComplex.dgoToHomologicalComplex b V).map f).f i) (f.f i)","decl":"open Classical in\n/-- The functor from differential graded objects to homological complexes.\n-/\n@[simps]\ndef dgoToHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ⥤\n      HomologicalComplex V (ComplexShape.up' b) where\n  obj X :=\n    { X := fun i => X.obj i\n      d := fun i j =>\n        if h : i + b = j then X.d i ≫ X.objEqToHom (show i + (1 : ℤ) • b = j by simp [h]) else 0\n      shape := fun i j w => by dsimp at w; convert dif_neg w\n      d_comp_d' := fun i j k hij hjk => by\n        dsimp at hij hjk; substs hij hjk\n        simp }\n  map {X Y} f :=\n    { f := f.f\n      comm' := fun i j h => by\n        dsimp at h ⊢\n        subst h\n        simp only [dite_true, Category.assoc, eqToHom_f']\n        -- Porting note: this `rw` used to be part of the `simp`.\n        have : f.f i ≫ Y.d i = X.d i ≫ f.f _ := (congr_fun f.comm i).symm\n        rw [reassoc_of% this] }\n  map_id _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n  map_comp _ _ := rfl -- the `aesop_cat` autoparam solves this but it's slow\n\n"}
{"name":"HomologicalComplex.homologicalComplexToDGO_obj_obj","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V (ComplexShape.up' b)\ni : β\n⊢ Eq (((HomologicalComplex.homologicalComplexToDGO b V).obj X).obj i) (X.X i)","decl":"/-- The functor from homological complexes to differential graded objects.\n-/\n@[simps]\ndef homologicalComplexToDGO :\n    HomologicalComplex V (ComplexShape.up' b) ⥤\n      DifferentialObject ℤ (GradedObjectWithShift b V) where\n  obj X :=\n    { obj := fun i => X.X i\n      d := fun i => X.d i _ }\n  map {X Y} f := { f := f.f }\n\n"}
{"name":"HomologicalComplex.homologicalComplexToDGO_map_f","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX Y : HomologicalComplex V (ComplexShape.up' b)\nf : Quiver.Hom X Y\ni : β\n⊢ Eq (((HomologicalComplex.homologicalComplexToDGO b V).map f).f i) (f.f i)","decl":"/-- The functor from homological complexes to differential graded objects.\n-/\n@[simps]\ndef homologicalComplexToDGO :\n    HomologicalComplex V (ComplexShape.up' b) ⥤\n      DifferentialObject ℤ (GradedObjectWithShift b V) where\n  obj X :=\n    { obj := fun i => X.X i\n      d := fun i => X.d i _ }\n  map {X Y} f := { f := f.f }\n\n"}
{"name":"HomologicalComplex.homologicalComplexToDGO_obj_d","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V (ComplexShape.up' b)\ni : β\n⊢ Eq (((HomologicalComplex.homologicalComplexToDGO b V).obj X).d i) (X.d i ((fun b_1 => HAdd.hAdd b_1 (HSMul.hSMul { as := 1 }.as b)) i))","decl":"/-- The functor from homological complexes to differential graded objects.\n-/\n@[simps]\ndef homologicalComplexToDGO :\n    HomologicalComplex V (ComplexShape.up' b) ⥤\n      DifferentialObject ℤ (GradedObjectWithShift b V) where\n  obj X :=\n    { obj := fun i => X.X i\n      d := fun i => X.d i _ }\n  map {X Y} f := { f := f.f }\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplexUnitIso_inv_app_f","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\ni : β\n⊢ Eq (((HomologicalComplex.dgoEquivHomologicalComplexUnitIso b V).inv.app X).f i) (CategoryTheory.CategoryStruct.id (X.obj i))","decl":"/-- The unit isomorphism for `dgoEquivHomologicalComplex`.\n-/\n@[simps!]\ndef dgoEquivHomologicalComplexUnitIso :\n    𝟭 (DifferentialObject ℤ (GradedObjectWithShift b V)) ≅\n      dgoToHomologicalComplex b V ⋙ homologicalComplexToDGO b V :=\n  NatIso.ofComponents (fun X =>\n    { hom := { f := fun i => 𝟙 (X.obj i) }\n      inv := { f := fun i => 𝟙 (X.obj i) } })\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplexUnitIso_hom_app_f","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : CategoryTheory.DifferentialObject Int (CategoryTheory.GradedObjectWithShift b V)\ni : β\n⊢ Eq (((HomologicalComplex.dgoEquivHomologicalComplexUnitIso b V).hom.app X).f i) (CategoryTheory.CategoryStruct.id (X.obj i))","decl":"/-- The unit isomorphism for `dgoEquivHomologicalComplex`.\n-/\n@[simps!]\ndef dgoEquivHomologicalComplexUnitIso :\n    𝟭 (DifferentialObject ℤ (GradedObjectWithShift b V)) ≅\n      dgoToHomologicalComplex b V ⋙ homologicalComplexToDGO b V :=\n  NatIso.ofComponents (fun X =>\n    { hom := { f := fun i => 𝟙 (X.obj i) }\n      inv := { f := fun i => 𝟙 (X.obj i) } })\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplexCounitIso_hom_app_f","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V (ComplexShape.up' b)\ni : β\n⊢ Eq (((HomologicalComplex.dgoEquivHomologicalComplexCounitIso b V).hom.app X).f i) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- The counit isomorphism for `dgoEquivHomologicalComplex`.\n-/\n@[simps!]\ndef dgoEquivHomologicalComplexCounitIso :\n    homologicalComplexToDGO b V ⋙ dgoToHomologicalComplex b V ≅\n      𝟭 (HomologicalComplex V (ComplexShape.up' b)) :=\n  NatIso.ofComponents (fun X =>\n    { hom := { f := fun i => 𝟙 (X.X i) }\n      inv := { f := fun i => 𝟙 (X.X i) } })\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplexCounitIso_inv_app_f","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\nX : HomologicalComplex V (ComplexShape.up' b)\ni : β\n⊢ Eq (((HomologicalComplex.dgoEquivHomologicalComplexCounitIso b V).inv.app X).f i) (CategoryTheory.CategoryStruct.id (X.X i))","decl":"/-- The counit isomorphism for `dgoEquivHomologicalComplex`.\n-/\n@[simps!]\ndef dgoEquivHomologicalComplexCounitIso :\n    homologicalComplexToDGO b V ⋙ dgoToHomologicalComplex b V ≅\n      𝟭 (HomologicalComplex V (ComplexShape.up' b)) :=\n  NatIso.ofComponents (fun X =>\n    { hom := { f := fun i => 𝟙 (X.X i) }\n      inv := { f := fun i => 𝟙 (X.X i) } })\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplex_unitIso","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.dgoEquivHomologicalComplex b V).unitIso (HomologicalComplex.dgoEquivHomologicalComplexUnitIso b V)","decl":"/-- The category of differential graded objects in `V` is equivalent\nto the category of homological complexes in `V`.\n-/\n@[simps]\ndef dgoEquivHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ≌\n      HomologicalComplex V (ComplexShape.up' b) where\n  functor := dgoToHomologicalComplex b V\n  inverse := homologicalComplexToDGO b V\n  unitIso := dgoEquivHomologicalComplexUnitIso b V\n  counitIso := dgoEquivHomologicalComplexCounitIso b V\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplex_counitIso","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.dgoEquivHomologicalComplex b V).counitIso (HomologicalComplex.dgoEquivHomologicalComplexCounitIso b V)","decl":"/-- The category of differential graded objects in `V` is equivalent\nto the category of homological complexes in `V`.\n-/\n@[simps]\ndef dgoEquivHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ≌\n      HomologicalComplex V (ComplexShape.up' b) where\n  functor := dgoToHomologicalComplex b V\n  inverse := homologicalComplexToDGO b V\n  unitIso := dgoEquivHomologicalComplexUnitIso b V\n  counitIso := dgoEquivHomologicalComplexCounitIso b V\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplex_inverse","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.dgoEquivHomologicalComplex b V).inverse (HomologicalComplex.homologicalComplexToDGO b V)","decl":"/-- The category of differential graded objects in `V` is equivalent\nto the category of homological complexes in `V`.\n-/\n@[simps]\ndef dgoEquivHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ≌\n      HomologicalComplex V (ComplexShape.up' b) where\n  functor := dgoToHomologicalComplex b V\n  inverse := homologicalComplexToDGO b V\n  unitIso := dgoEquivHomologicalComplexUnitIso b V\n  counitIso := dgoEquivHomologicalComplexCounitIso b V\n\n"}
{"name":"HomologicalComplex.dgoEquivHomologicalComplex_functor","module":"Mathlib.Algebra.Homology.DifferentialObject","initialProofState":"β : Type u_1\ninst✝² : AddCommGroup β\nb : β\nV : Type u_2\ninst✝¹ : CategoryTheory.Category.{u_3, u_2} V\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms V\n⊢ Eq (HomologicalComplex.dgoEquivHomologicalComplex b V).functor (HomologicalComplex.dgoToHomologicalComplex b V)","decl":"/-- The category of differential graded objects in `V` is equivalent\nto the category of homological complexes in `V`.\n-/\n@[simps]\ndef dgoEquivHomologicalComplex :\n    DifferentialObject ℤ (GradedObjectWithShift b V) ≌\n      HomologicalComplex V (ComplexShape.up' b) where\n  functor := dgoToHomologicalComplex b V\n  inverse := homologicalComplexToDGO b V\n  unitIso := dgoEquivHomologicalComplexUnitIso b V\n  counitIso := dgoEquivHomologicalComplexCounitIso b V\n\n"}
