{"name":"MeasureTheory.ae_const_le_iff_forall_lt_measure_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_2\ninstâœÂ³ : LinearOrder Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : OrderTopology Î²\ninstâœ : FirstCountableTopology Î²\nf : Î± â†’ Î²\nc : Î²\nâŠ¢ Iff (Filter.Eventually (fun x => LE.le c (f x)) (MeasureTheory.ae Î¼)) (âˆ€ (b : Î²), LT.lt b c â†’ Eq (Î¼ (setOf fun x => LE.le (f x) b)) 0)","decl":"theorem ae_const_le_iff_forall_lt_measure_zero {Î²} [LinearOrder Î²] [TopologicalSpace Î²]\n    [OrderTopology Î²] [FirstCountableTopology Î²] (f : Î± â†’ Î²) (c : Î²) :\n    (âˆ€áµ x âˆ‚Î¼, c â‰¤ f x) â†” âˆ€ b < c, Î¼ {x | f x â‰¤ b} = 0 := by\n  rw [ae_iff]\n  push_neg\n  constructor\n  Â· intro h b hb\n    exact measure_mono_null (fun y hy => (lt_of_le_of_lt hy hb : _)) h\n  intro hc\n  by_cases h : âˆ€ b, c â‰¤ b\n  Â· have : {a : Î± | f a < c} = âˆ… := by\n      apply Set.eq_empty_iff_forall_not_mem.2 fun x hx => ?_\n      exact (lt_irrefl _ (lt_of_lt_of_le hx (h (f x)))).elim\n    simp [this]\n  by_cases H : Â¬IsLUB (Set.Iio c) c\n  Â· have : c âˆˆ upperBounds (Set.Iio c) := fun y hy => le_of_lt hy\n    obtain âŸ¨b, b_up, bcâŸ© : âˆƒ b : Î², b âˆˆ upperBounds (Set.Iio c) âˆ§ b < c := by\n      simpa [IsLUB, IsLeast, this, lowerBounds] using H\n    exact measure_mono_null (fun x hx => b_up hx) (hc b bc)\n  push_neg at H h\n  obtain âŸ¨u, _, u_lt, u_lim, -âŸ© :\n    âˆƒ u : â„• â†’ Î²,\n      StrictMono u âˆ§ (âˆ€ n : â„•, u n < c) âˆ§ Tendsto u atTop (ğ“ c) âˆ§ âˆ€ n : â„•, u n âˆˆ Set.Iio c :=\n    H.exists_seq_strictMono_tendsto_of_not_mem (lt_irrefl c) h\n  have h_Union : {x | f x < c} = â‹ƒ n : â„•, {x | f x â‰¤ u n} := by\n    ext1 x\n    simp_rw [Set.mem_iUnion, Set.mem_setOf_eq]\n    constructor <;> intro h\n    Â· obtain âŸ¨n, hnâŸ© := ((tendsto_order.1 u_lim).1 _ h).exists; exact âŸ¨n, hn.leâŸ©\n    Â· obtain âŸ¨n, hnâŸ© := h; exact hn.trans_lt (u_lt _)\n  rw [h_Union, measure_iUnion_null_iff]\n  intro n\n  exact hc _ (u_lt n)\n\n"}
{"name":"MeasureTheory.ae_le_const_iff_forall_gt_measure_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ² : Type u_2\ninstâœÂ³ : LinearOrder Î²\ninstâœÂ² : TopologicalSpace Î²\ninstâœÂ¹ : OrderTopology Î²\ninstâœ : FirstCountableTopology Î²\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Î²\nc : Î²\nâŠ¢ Iff (Filter.Eventually (fun x => LE.le (f x) c) (MeasureTheory.ae Î¼)) (âˆ€ (b : Î²), LT.lt c b â†’ Eq (Î¼ (setOf fun x => LE.le b (f x))) 0)","decl":"lemma ae_le_const_iff_forall_gt_measure_zero {Î²} [LinearOrder Î²] [TopologicalSpace Î²]\n    [OrderTopology Î²] [FirstCountableTopology Î²] {Î¼ : Measure Î±} (f : Î± â†’ Î²) (c : Î²) :\n    (âˆ€áµ x âˆ‚Î¼, f x â‰¤ c) â†” âˆ€ b, c < b â†’ Î¼ {x | b â‰¤ f x} = 0 :=\n  ae_const_le_iff_forall_lt_measure_zero (Î² := Î²áµ’áµˆ) _ _\n\n"}
{"name":"MeasureTheory.ae_le_of_forall_setLIntegral_le_of_sigmaFiniteâ‚€","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf g : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE f g","decl":"theorem ae_le_of_forall_setLIntegral_le_of_sigmaFiniteâ‚€ [SigmaFinite Î¼]\n    {f g : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ«â» x in s, f x âˆ‚Î¼ â‰¤ âˆ«â» x in s, g x âˆ‚Î¼) :\n    f â‰¤áµ[Î¼] g := by\n  have A : âˆ€ (Îµ N : â„â‰¥0) (p : â„•), 0 < Îµ â†’\n      Î¼ ({x | g x + Îµ â‰¤ f x âˆ§ g x â‰¤ N} âˆ© spanningSets Î¼ p) = 0 := by\n    intro Îµ N p Îµpos\n    let s := {x | g x + Îµ â‰¤ f x âˆ§ g x â‰¤ N} âˆ© spanningSets Î¼ p\n    have s_lt_top : Î¼ s < âˆ :=\n      (measure_mono (Set.inter_subset_right)).trans_lt (measure_spanningSets_lt_top Î¼ p)\n    have A : (âˆ«â» x in s, g x âˆ‚Î¼) + Îµ * Î¼ s â‰¤ (âˆ«â» x in s, g x âˆ‚Î¼) + 0 :=\n      calc\n        (âˆ«â» x in s, g x âˆ‚Î¼) + Îµ * Î¼ s = (âˆ«â» x in s, g x âˆ‚Î¼) + âˆ«â» _ in s, Îµ âˆ‚Î¼ := by\n          simp only [lintegral_const, Set.univ_inter, MeasurableSet.univ, Measure.restrict_apply]\n        _ = âˆ«â» x in s, g x + Îµ âˆ‚Î¼ := (lintegral_add_right _ measurable_const).symm\n        _ â‰¤ âˆ«â» x in s, f x âˆ‚Î¼ :=\n          setLIntegral_mono_ae hf.restrict <| ae_of_all _ fun x hx => hx.1.1\n        _ â‰¤ (âˆ«â» x in s, g x âˆ‚Î¼) + 0 := by\n          rw [add_zero, â† Measure.restrict_toMeasurable s_lt_top.ne]\n          refine h _ (measurableSet_toMeasurable ..) ?_\n          rwa [measure_toMeasurable]\n    have B : (âˆ«â» x in s, g x âˆ‚Î¼) â‰  âˆ :=\n      (setLIntegral_lt_top_of_le_nnreal s_lt_top.ne âŸ¨N, fun _ h â†¦ h.1.2âŸ©).ne\n    have : (Îµ : â„â‰¥0âˆ) * Î¼ s â‰¤ 0 := ENNReal.le_of_add_le_add_left B A\n    simpa only [ENNReal.coe_eq_zero, nonpos_iff_eq_zero, mul_eq_zero, Îµpos.ne', false_or]\n  obtain âŸ¨u, _, u_pos, u_limâŸ© :\n    âˆƒ u : â„• â†’ â„â‰¥0, StrictAnti u âˆ§ (âˆ€ n, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„â‰¥0)\n  let s := fun n : â„• => {x | g x + u n â‰¤ f x âˆ§ g x â‰¤ (n : â„â‰¥0)} âˆ© spanningSets Î¼ n\n  have Î¼s : âˆ€ n, Î¼ (s n) = 0 := fun n => A _ _ _ (u_pos n)\n  have B : {x | f x â‰¤ g x}á¶œ âŠ† â‹ƒ n, s n := by\n    intro x hx\n    simp only [Set.mem_compl_iff, Set.mem_setOf, not_le] at hx\n    have L1 : âˆ€á¶  n in atTop, g x + u n â‰¤ f x := by\n      have : Tendsto (fun n => g x + u n) atTop (ğ“ (g x + (0 : â„â‰¥0))) :=\n        tendsto_const_nhds.add (ENNReal.tendsto_coe.2 u_lim)\n      simp only [ENNReal.coe_zero, add_zero] at this\n      exact this.eventually_le_const hx\n    have L2 : âˆ€á¶  n : â„• in (atTop : Filter â„•), g x â‰¤ (n : â„â‰¥0) :=\n      have : Tendsto (fun n : â„• => ((n : â„â‰¥0) : â„â‰¥0âˆ)) atTop (ğ“ âˆ) := by\n        simp only [ENNReal.coe_natCast]\n        exact ENNReal.tendsto_nat_nhds_top\n      this.eventually_const_le (hx.trans_le le_top)\n    apply Set.mem_iUnion.2\n    exact ((L1.and L2).and (eventually_mem_spanningSets Î¼ x)).exists\n  refine le_antisymm ?_ bot_le\n  calc\n    Î¼ {x : Î± | (fun x : Î± => f x â‰¤ g x) x}á¶œ â‰¤ Î¼ (â‹ƒ n, s n) := measure_mono B\n    _ â‰¤ âˆ‘' n, Î¼ (s n) := measure_iUnion_le _\n    _ = 0 := by simp only [Î¼s, tsum_zero]\n\n"}
{"name":"MeasureTheory.ae_le_of_forall_setLIntegral_le_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf g : Î± â†’ ENNReal\nhf : Measurable f\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyLE f g","decl":"theorem ae_le_of_forall_setLIntegral_le_of_sigmaFinite [SigmaFinite Î¼] {f g : Î± â†’ â„â‰¥0âˆ}\n    (hf : Measurable f)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ (âˆ«â» x in s, f x âˆ‚Î¼) â‰¤ âˆ«â» x in s, g x âˆ‚Î¼) : f â‰¤áµ[Î¼] g :=\n  ae_le_of_forall_setLIntegral_le_of_sigmaFiniteâ‚€ hf.aemeasurable h\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setLIntegral_eq_of_sigmaFiniteâ‚€","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf g : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setLIntegral_eq_of_sigmaFiniteâ‚€ [SigmaFinite Î¼]\n    {f g : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (hg : AEMeasurable g Î¼)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ«â» x in s, f x âˆ‚Î¼ = âˆ«â» x in s, g x âˆ‚Î¼) : f =áµ[Î¼] g := by\n  have A : f â‰¤áµ[Î¼] g :=\n    ae_le_of_forall_setLIntegral_le_of_sigmaFiniteâ‚€ hf fun s hs h's => le_of_eq (h s hs h's)\n  have B : g â‰¤áµ[Î¼] f :=\n    ae_le_of_forall_setLIntegral_le_of_sigmaFiniteâ‚€ hg fun s hs h's => ge_of_eq (h s hs h's)\n  filter_upwards [A, B] with x using le_antisymm\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf g : Î± â†’ ENNReal\nhf : Measurable f\nhg : Measurable g\nh : âˆ€ (s : Set Î±), MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite [SigmaFinite Î¼] {f g : Î± â†’ â„â‰¥0âˆ}\n    (hf : Measurable f) (hg : Measurable g)\n    (h : âˆ€ s, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ«â» x in s, f x âˆ‚Î¼ = âˆ«â» x in s, g x âˆ‚Î¼) : f =áµ[Î¼] g :=\n  ae_eq_of_forall_setLIntegral_eq_of_sigmaFiniteâ‚€ hf.aemeasurable hg.aemeasurable h\n\n"}
{"name":"MeasureTheory.AEMeasurable.ae_eq_of_forall_setLIntegral_eq","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm0 : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nhgi : Ne (MeasureTheory.lintegral Î¼ fun x => g x) Top.top\nhfg : âˆ€ â¦ƒs : Set Î±â¦„, MeasurableSet s â†’ LT.lt (Î¼ s) Top.top â†’ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => f x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => g x)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq f g","decl":"theorem AEMeasurable.ae_eq_of_forall_setLIntegral_eq {f g : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)\n    (hg : AEMeasurable g Î¼) (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) (hgi : âˆ«â» x, g x âˆ‚Î¼ â‰  âˆ)\n    (hfg : âˆ€ â¦ƒsâ¦„, MeasurableSet s â†’ Î¼ s < âˆ â†’ âˆ«â» x in s, f x âˆ‚Î¼ = âˆ«â» x in s, g x âˆ‚Î¼) :\n    f =áµ[Î¼] g := by\n  have hf' : AEFinStronglyMeasurable f Î¼ :=\n    ENNReal.aefinStronglyMeasurable_of_aemeasurable hfi hf\n  have hg' : AEFinStronglyMeasurable g Î¼ :=\n    ENNReal.aefinStronglyMeasurable_of_aemeasurable hgi hg\n  let s := hf'.sigmaFiniteSet\n  let t := hg'.sigmaFiniteSet\n  suffices f =áµ[Î¼.restrict (s âˆª t)] g by\n    refine ae_of_ae_restrict_of_ae_restrict_compl _ this ?_\n    simp only [Set.compl_union]\n    have h1 : f =áµ[Î¼.restrict sá¶œ] 0 := hf'.ae_eq_zero_compl\n    have h2 : g =áµ[Î¼.restrict tá¶œ] 0 := hg'.ae_eq_zero_compl\n    rw [ae_restrict_iff' (hf'.measurableSet.compl.inter hg'.measurableSet.compl)]\n    rw [EventuallyEq, ae_restrict_iff' hf'.measurableSet.compl] at h1\n    rw [EventuallyEq, ae_restrict_iff' hg'.measurableSet.compl] at h2\n    filter_upwards [h1, h2] with x h1 h2 hx\n    rw [h1 (Set.inter_subset_left hx), h2 (Set.inter_subset_right hx)]\n  have := hf'.sigmaFinite_restrict\n  have := hg'.sigmaFinite_restrict\n  refine ae_eq_of_forall_setLIntegral_eq_of_sigmaFiniteâ‚€ hf.restrict hg.restrict\n    fun u hu huÎ¼ â†¦ ?_\n  rw [Measure.restrict_restrict hu]\n  rw [Measure.restrict_apply hu] at huÎ¼\n  exact hfg (hu.inter (hf'.measurableSet.union hg'.measurableSet)) huÎ¼\n\n"}
{"name":"MeasureTheory.withDensity_eq_iff_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SigmaFinite Î¼\nf g : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nâŠ¢ Iff (Eq (Î¼.withDensity f) (Î¼.withDensity g)) ((MeasureTheory.ae Î¼).EventuallyEq f g)","decl":"theorem withDensity_eq_iff_of_sigmaFinite [SigmaFinite Î¼] {f g : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)\n    (hg : AEMeasurable g Î¼) : Î¼.withDensity f = Î¼.withDensity g â†” f =áµ[Î¼] g :=\n  âŸ¨fun hfg â†¦ by\n    refine ae_eq_of_forall_setLIntegral_eq_of_sigmaFiniteâ‚€ hf hg fun s hs _ â†¦ ?_\n    rw [â† withDensity_apply f hs, â† withDensity_apply g hs, â† hfg], withDensity_congr_aeâŸ©\n\n"}
{"name":"MeasureTheory.withDensity_eq_iff","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhg : AEMeasurable g Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ Iff (Eq (Î¼.withDensity f) (Î¼.withDensity g)) ((MeasureTheory.ae Î¼).EventuallyEq f g)","decl":"theorem withDensity_eq_iff {f g : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼)\n    (hg : AEMeasurable g Î¼) (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) :\n    Î¼.withDensity f = Î¼.withDensity g â†” f =áµ[Î¼] g :=\n  âŸ¨fun hfg â†¦ by\n    refine AEMeasurable.ae_eq_of_forall_setLIntegral_eq hf hg hfi ?_ fun s hs _ â†¦ ?_\n    Â· rwa [â† setLIntegral_univ, â† withDensity_apply g MeasurableSet.univ, â† hfg,\n        withDensity_apply f MeasurableSet.univ, setLIntegral_univ]\n    Â· rw [â† withDensity_apply f hs, â† withDensity_apply g hs, â† hfg], withDensity_congr_aeâŸ©\n\n"}
