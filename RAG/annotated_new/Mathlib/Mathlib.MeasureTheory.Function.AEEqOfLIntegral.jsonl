{"name":"MeasureTheory.ae_const_le_iff_forall_lt_measure_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_2\ninst✝³ : LinearOrder β\ninst✝² : TopologicalSpace β\ninst✝¹ : OrderTopology β\ninst✝ : FirstCountableTopology β\nf : α → β\nc : β\n⊢ Iff (Filter.Eventually (fun x => LE.le c (f x)) (MeasureTheory.ae μ)) (∀ (b : β), LT.lt b c → Eq (μ (setOf fun x => LE.le (f x) b)) 0)","decl":"theorem ae_const_le_iff_forall_lt_measure_zero {β} [LinearOrder β] [TopologicalSpace β]\n    [OrderTopology β] [FirstCountableTopology β] (f : α → β) (c : β) :\n    (∀ᵐ x ∂μ, c ≤ f x) ↔ ∀ b < c, μ {x | f x ≤ b} = 0 := by\n  rw [ae_iff]\n  push_neg\n  constructor\n  · intro h b hb\n    exact measure_mono_null (fun y hy => (lt_of_le_of_lt hy hb : _)) h\n  intro hc\n  by_cases h : ∀ b, c ≤ b\n  · have : {a : α | f a < c} = ∅ := by\n      apply Set.eq_empty_iff_forall_not_mem.2 fun x hx => ?_\n      exact (lt_irrefl _ (lt_of_lt_of_le hx (h (f x)))).elim\n    simp [this]\n  by_cases H : ¬IsLUB (Set.Iio c) c\n  · have : c ∈ upperBounds (Set.Iio c) := fun y hy => le_of_lt hy\n    obtain ⟨b, b_up, bc⟩ : ∃ b : β, b ∈ upperBounds (Set.Iio c) ∧ b < c := by\n      simpa [IsLUB, IsLeast, this, lowerBounds] using H\n    exact measure_mono_null (fun x hx => b_up hx) (hc b bc)\n  push_neg at H h\n  obtain ⟨u, _, u_lt, u_lim, -⟩ :\n    ∃ u : ℕ → β,\n      StrictMono u ∧ (∀ n : ℕ, u n < c) ∧ Tendsto u atTop (𝓝 c) ∧ ∀ n : ℕ, u n ∈ Set.Iio c :=\n    H.exists_seq_strictMono_tendsto_of_not_mem (lt_irrefl c) h\n  have h_Union : {x | f x < c} = ⋃ n : ℕ, {x | f x ≤ u n} := by\n    ext1 x\n    simp_rw [Set.mem_iUnion, Set.mem_setOf_eq]\n    constructor <;> intro h\n    · obtain ⟨n, hn⟩ := ((tendsto_order.1 u_lim).1 _ h).exists; exact ⟨n, hn.le⟩\n    · obtain ⟨n, hn⟩ := h; exact hn.trans_lt (u_lt _)\n  rw [h_Union, measure_iUnion_null_iff]\n  intro n\n  exact hc _ (u_lt n)\n\n"}
{"name":"MeasureTheory.ae_le_const_iff_forall_gt_measure_zero","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nβ : Type u_2\ninst✝³ : LinearOrder β\ninst✝² : TopologicalSpace β\ninst✝¹ : OrderTopology β\ninst✝ : FirstCountableTopology β\nμ : MeasureTheory.Measure α\nf : α → β\nc : β\n⊢ Iff (Filter.Eventually (fun x => LE.le (f x) c) (MeasureTheory.ae μ)) (∀ (b : β), LT.lt c b → Eq (μ (setOf fun x => LE.le b (f x))) 0)","decl":"lemma ae_le_const_iff_forall_gt_measure_zero {β} [LinearOrder β] [TopologicalSpace β]\n    [OrderTopology β] [FirstCountableTopology β] {μ : Measure α} (f : α → β) (c : β) :\n    (∀ᵐ x ∂μ, f x ≤ c) ↔ ∀ b, c < b → μ {x | b ≤ f x} = 0 :=\n  ae_const_le_iff_forall_lt_measure_zero (β := βᵒᵈ) _ _\n\n"}
{"name":"MeasureTheory.ae_le_of_forall_setLIntegral_le_of_sigmaFinite₀","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf g : α → ENNReal\nhf : AEMeasurable f μ\nh : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)\n⊢ (MeasureTheory.ae μ).EventuallyLE f g","decl":"theorem ae_le_of_forall_setLIntegral_le_of_sigmaFinite₀ [SigmaFinite μ]\n    {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (h : ∀ s, MeasurableSet s → μ s < ∞ → ∫⁻ x in s, f x ∂μ ≤ ∫⁻ x in s, g x ∂μ) :\n    f ≤ᵐ[μ] g := by\n  have A : ∀ (ε N : ℝ≥0) (p : ℕ), 0 < ε →\n      μ ({x | g x + ε ≤ f x ∧ g x ≤ N} ∩ spanningSets μ p) = 0 := by\n    intro ε N p εpos\n    let s := {x | g x + ε ≤ f x ∧ g x ≤ N} ∩ spanningSets μ p\n    have s_lt_top : μ s < ∞ :=\n      (measure_mono (Set.inter_subset_right)).trans_lt (measure_spanningSets_lt_top μ p)\n    have A : (∫⁻ x in s, g x ∂μ) + ε * μ s ≤ (∫⁻ x in s, g x ∂μ) + 0 :=\n      calc\n        (∫⁻ x in s, g x ∂μ) + ε * μ s = (∫⁻ x in s, g x ∂μ) + ∫⁻ _ in s, ε ∂μ := by\n          simp only [lintegral_const, Set.univ_inter, MeasurableSet.univ, Measure.restrict_apply]\n        _ = ∫⁻ x in s, g x + ε ∂μ := (lintegral_add_right _ measurable_const).symm\n        _ ≤ ∫⁻ x in s, f x ∂μ :=\n          setLIntegral_mono_ae hf.restrict <| ae_of_all _ fun x hx => hx.1.1\n        _ ≤ (∫⁻ x in s, g x ∂μ) + 0 := by\n          rw [add_zero, ← Measure.restrict_toMeasurable s_lt_top.ne]\n          refine h _ (measurableSet_toMeasurable ..) ?_\n          rwa [measure_toMeasurable]\n    have B : (∫⁻ x in s, g x ∂μ) ≠ ∞ :=\n      (setLIntegral_lt_top_of_le_nnreal s_lt_top.ne ⟨N, fun _ h ↦ h.1.2⟩).ne\n    have : (ε : ℝ≥0∞) * μ s ≤ 0 := ENNReal.le_of_add_le_add_left B A\n    simpa only [ENNReal.coe_eq_zero, nonpos_iff_eq_zero, mul_eq_zero, εpos.ne', false_or]\n  obtain ⟨u, _, u_pos, u_lim⟩ :\n    ∃ u : ℕ → ℝ≥0, StrictAnti u ∧ (∀ n, 0 < u n) ∧ Tendsto u atTop (𝓝 0) :=\n    exists_seq_strictAnti_tendsto (0 : ℝ≥0)\n  let s := fun n : ℕ => {x | g x + u n ≤ f x ∧ g x ≤ (n : ℝ≥0)} ∩ spanningSets μ n\n  have μs : ∀ n, μ (s n) = 0 := fun n => A _ _ _ (u_pos n)\n  have B : {x | f x ≤ g x}ᶜ ⊆ ⋃ n, s n := by\n    intro x hx\n    simp only [Set.mem_compl_iff, Set.mem_setOf, not_le] at hx\n    have L1 : ∀ᶠ n in atTop, g x + u n ≤ f x := by\n      have : Tendsto (fun n => g x + u n) atTop (𝓝 (g x + (0 : ℝ≥0))) :=\n        tendsto_const_nhds.add (ENNReal.tendsto_coe.2 u_lim)\n      simp only [ENNReal.coe_zero, add_zero] at this\n      exact this.eventually_le_const hx\n    have L2 : ∀ᶠ n : ℕ in (atTop : Filter ℕ), g x ≤ (n : ℝ≥0) :=\n      have : Tendsto (fun n : ℕ => ((n : ℝ≥0) : ℝ≥0∞)) atTop (𝓝 ∞) := by\n        simp only [ENNReal.coe_natCast]\n        exact ENNReal.tendsto_nat_nhds_top\n      this.eventually_const_le (hx.trans_le le_top)\n    apply Set.mem_iUnion.2\n    exact ((L1.and L2).and (eventually_mem_spanningSets μ x)).exists\n  refine le_antisymm ?_ bot_le\n  calc\n    μ {x : α | (fun x : α => f x ≤ g x) x}ᶜ ≤ μ (⋃ n, s n) := measure_mono B\n    _ ≤ ∑' n, μ (s n) := measure_iUnion_le _\n    _ = 0 := by simp only [μs, tsum_zero]\n\n"}
{"name":"MeasureTheory.ae_le_of_forall_setLIntegral_le_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf g : α → ENNReal\nhf : Measurable f\nh : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)\n⊢ (MeasureTheory.ae μ).EventuallyLE f g","decl":"theorem ae_le_of_forall_setLIntegral_le_of_sigmaFinite [SigmaFinite μ] {f g : α → ℝ≥0∞}\n    (hf : Measurable f)\n    (h : ∀ s, MeasurableSet s → μ s < ∞ → (∫⁻ x in s, f x ∂μ) ≤ ∫⁻ x in s, g x ∂μ) : f ≤ᵐ[μ] g :=\n  ae_le_of_forall_setLIntegral_le_of_sigmaFinite₀ hf.aemeasurable h\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite₀","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\nh : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)\n⊢ (MeasureTheory.ae μ).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite₀ [SigmaFinite μ]\n    {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hg : AEMeasurable g μ)\n    (h : ∀ s, MeasurableSet s → μ s < ∞ → ∫⁻ x in s, f x ∂μ = ∫⁻ x in s, g x ∂μ) : f =ᵐ[μ] g := by\n  have A : f ≤ᵐ[μ] g :=\n    ae_le_of_forall_setLIntegral_le_of_sigmaFinite₀ hf fun s hs h's => le_of_eq (h s hs h's)\n  have B : g ≤ᵐ[μ] f :=\n    ae_le_of_forall_setLIntegral_le_of_sigmaFinite₀ hg fun s hs h's => ge_of_eq (h s hs h's)\n  filter_upwards [A, B] with x using le_antisymm\n\n"}
{"name":"MeasureTheory.ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf g : α → ENNReal\nhf : Measurable f\nhg : Measurable g\nh : ∀ (s : Set α), MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)\n⊢ (MeasureTheory.ae μ).EventuallyEq f g","decl":"theorem ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite [SigmaFinite μ] {f g : α → ℝ≥0∞}\n    (hf : Measurable f) (hg : Measurable g)\n    (h : ∀ s, MeasurableSet s → μ s < ∞ → ∫⁻ x in s, f x ∂μ = ∫⁻ x in s, g x ∂μ) : f =ᵐ[μ] g :=\n  ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite₀ hf.aemeasurable hg.aemeasurable h\n\n"}
{"name":"MeasureTheory.AEMeasurable.ae_eq_of_forall_setLIntegral_eq","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm0 : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\nhgi : Ne (MeasureTheory.lintegral μ fun x => g x) Top.top\nhfg : ∀ ⦃s : Set α⦄, MeasurableSet s → LT.lt (μ s) Top.top → Eq (MeasureTheory.lintegral (μ.restrict s) fun x => f x) (MeasureTheory.lintegral (μ.restrict s) fun x => g x)\n⊢ (MeasureTheory.ae μ).EventuallyEq f g","decl":"theorem AEMeasurable.ae_eq_of_forall_setLIntegral_eq {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) (hfi : ∫⁻ x, f x ∂μ ≠ ∞) (hgi : ∫⁻ x, g x ∂μ ≠ ∞)\n    (hfg : ∀ ⦃s⦄, MeasurableSet s → μ s < ∞ → ∫⁻ x in s, f x ∂μ = ∫⁻ x in s, g x ∂μ) :\n    f =ᵐ[μ] g := by\n  have hf' : AEFinStronglyMeasurable f μ :=\n    ENNReal.aefinStronglyMeasurable_of_aemeasurable hfi hf\n  have hg' : AEFinStronglyMeasurable g μ :=\n    ENNReal.aefinStronglyMeasurable_of_aemeasurable hgi hg\n  let s := hf'.sigmaFiniteSet\n  let t := hg'.sigmaFiniteSet\n  suffices f =ᵐ[μ.restrict (s ∪ t)] g by\n    refine ae_of_ae_restrict_of_ae_restrict_compl _ this ?_\n    simp only [Set.compl_union]\n    have h1 : f =ᵐ[μ.restrict sᶜ] 0 := hf'.ae_eq_zero_compl\n    have h2 : g =ᵐ[μ.restrict tᶜ] 0 := hg'.ae_eq_zero_compl\n    rw [ae_restrict_iff' (hf'.measurableSet.compl.inter hg'.measurableSet.compl)]\n    rw [EventuallyEq, ae_restrict_iff' hf'.measurableSet.compl] at h1\n    rw [EventuallyEq, ae_restrict_iff' hg'.measurableSet.compl] at h2\n    filter_upwards [h1, h2] with x h1 h2 hx\n    rw [h1 (Set.inter_subset_left hx), h2 (Set.inter_subset_right hx)]\n  have := hf'.sigmaFinite_restrict\n  have := hg'.sigmaFinite_restrict\n  refine ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite₀ hf.restrict hg.restrict\n    fun u hu huμ ↦ ?_\n  rw [Measure.restrict_restrict hu]\n  rw [Measure.restrict_apply hu] at huμ\n  exact hfg (hu.inter (hf'.measurableSet.union hg'.measurableSet)) huμ\n\n"}
{"name":"MeasureTheory.withDensity_eq_iff_of_sigmaFinite","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SigmaFinite μ\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\n⊢ Iff (Eq (μ.withDensity f) (μ.withDensity g)) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"theorem withDensity_eq_iff_of_sigmaFinite [SigmaFinite μ] {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) : μ.withDensity f = μ.withDensity g ↔ f =ᵐ[μ] g :=\n  ⟨fun hfg ↦ by\n    refine ae_eq_of_forall_setLIntegral_eq_of_sigmaFinite₀ hf hg fun s hs _ ↦ ?_\n    rw [← withDensity_apply f hs, ← withDensity_apply g hs, ← hfg], withDensity_congr_ae⟩\n\n"}
{"name":"MeasureTheory.withDensity_eq_iff","module":"Mathlib.MeasureTheory.Function.AEEqOfLIntegral","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → ENNReal\nhf : AEMeasurable f μ\nhg : AEMeasurable g μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ Iff (Eq (μ.withDensity f) (μ.withDensity g)) ((MeasureTheory.ae μ).EventuallyEq f g)","decl":"theorem withDensity_eq_iff {f g : α → ℝ≥0∞} (hf : AEMeasurable f μ)\n    (hg : AEMeasurable g μ) (hfi : ∫⁻ x, f x ∂μ ≠ ∞) :\n    μ.withDensity f = μ.withDensity g ↔ f =ᵐ[μ] g :=\n  ⟨fun hfg ↦ by\n    refine AEMeasurable.ae_eq_of_forall_setLIntegral_eq hf hg hfi ?_ fun s hs _ ↦ ?_\n    · rwa [← setLIntegral_univ, ← withDensity_apply g MeasurableSet.univ, ← hfg,\n        withDensity_apply f MeasurableSet.univ, setLIntegral_univ]\n    · rw [← withDensity_apply f hs, ← withDensity_apply g hs, ← hfg], withDensity_congr_ae⟩\n\n"}
