{"name":"isConjRoot_def","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y : A\n⊢ Iff (IsConjRoot R x y) (Eq (minpoly R x) (minpoly R y))","decl":"/--\nThe definition of conjugate roots.\n-/\ntheorem isConjRoot_def {x y : A} : IsConjRoot R x y ↔ minpoly R x = minpoly R y := Iff.rfl\n\n"}
{"name":"IsConjRoot.refl","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\n⊢ IsConjRoot R x x","decl":"/--\nEvery element is a conjugate root of itself.\n-/\n@[refl] theorem refl {x : A} : IsConjRoot R x x := rfl\n\n"}
{"name":"IsConjRoot.symm","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y : A\nh : IsConjRoot R x y\n⊢ IsConjRoot R y x","decl":"/--\nIf `y` is a conjugate root of `x`, then `x` is also a conjugate root of `y`.\n-/\n@[symm] theorem symm {x y : A} (h : IsConjRoot R x y) : IsConjRoot R y x := Eq.symm h\n\n"}
{"name":"IsConjRoot.trans","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y z : A\nh₁ : IsConjRoot R x y\nh₂ : IsConjRoot R y z\n⊢ IsConjRoot R x z","decl":"/--\nIf `y` is a conjugate root of `x` and `z` is a conjugate root of `y`, then `z` is a conjugate\nroot of `x`.\n-/\n@[trans] theorem trans {x y z: A} (h₁ : IsConjRoot R x y) (h₂ : IsConjRoot R y z) :\n    IsConjRoot R x z := Eq.trans h₁ h₂\n\n"}
{"name":"IsConjRoot.aeval_eq_zero","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y : A\nh : IsConjRoot R x y\n⊢ Eq ((Polynomial.aeval y) (minpoly R x)) 0","decl":"/--\nLet `p` be the minimal polynomial of `x`. If `y` is a conjugate root of `x`, then `p y = 0`.\n-/\ntheorem aeval_eq_zero {x y : A} (h : IsConjRoot R x y) : aeval y (minpoly R x) = 0 :=\n  h ▸ minpoly.aeval R y\n\n"}
{"name":"IsConjRoot.add_algebraMap","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Field K\ninst✝ : Algebra K S\nx y : S\nr : K\nh : IsConjRoot K x y\n⊢ IsConjRoot K (HAdd.hAdd x ((algebraMap K S) r)) (HAdd.hAdd y ((algebraMap K S) r))","decl":"/--\nLet `r` be an element of the base ring. If `y` is a conjugate root of `x`, then `y + r` is a\nconjugate root of `x + r`.\n-/\ntheorem add_algebraMap {x y : S} (r : K) (h : IsConjRoot K x y) :\n    IsConjRoot K (x + algebraMap K S r) (y + algebraMap K S r) := by\n  rw [isConjRoot_def, minpoly.add_algebraMap x r, minpoly.add_algebraMap y r, h]\n\n"}
{"name":"IsConjRoot.sub_algebraMap","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Field K\ninst✝ : Algebra K S\nx y : S\nr : K\nh : IsConjRoot K x y\n⊢ IsConjRoot K (HSub.hSub x ((algebraMap K S) r)) (HSub.hSub y ((algebraMap K S) r))","decl":"/--\nLet `r` be an element of the base ring. If `y` is a conjugate root of `x`, then `y - r` is a\nconjugate root of `x - r`.\n-/\ntheorem sub_algebraMap {x y : S} (r : K) (h : IsConjRoot K x y) :\n    IsConjRoot K (x - algebraMap K S r) (y - algebraMap K S r) := by\n  simpa only [sub_eq_add_neg, map_neg] using add_algebraMap (-r) h\n\n"}
{"name":"IsConjRoot.neg","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝² : CommRing S\ninst✝¹ : Field K\ninst✝ : Algebra K S\nx y : S\nh : IsConjRoot K x y\n⊢ IsConjRoot K (Neg.neg x) (Neg.neg y)","decl":"/--\nIf `y` is a conjugate root of `x`, then `-y` is a conjugate root of `-x`.\n-/\ntheorem neg {x y : S} (h : IsConjRoot K x y) :\n    IsConjRoot K (-x) (-y) := by\n  rw [isConjRoot_def, minpoly.neg x, minpoly.neg y, h]\n\n"}
{"name":"isConjRoot_algHom_iff_of_injective","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\nB : Type u_6\ninst✝⁴ : CommRing R\ninst✝³ : Ring A\ninst✝² : Ring B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nx y : A\nf : AlgHom R A B\nhf : Function.Injective ⇑f\n⊢ Iff (IsConjRoot R (f x) (f y)) (IsConjRoot R x y)","decl":"/--\nA variant of `isConjRoot_algHom_iff`, only assuming `Function.Injective f`,\ninstead of `DivisionRing A`.\nIf `y` is a conjugate root of `x` and `f` is an injective `R`-algebra homomorphism, then `f y` is\na conjugate root of `f x`.\n-/\ntheorem isConjRoot_algHom_iff_of_injective {x y : A} {f : A →ₐ[R] B}\n    (hf : Function.Injective f) : IsConjRoot R (f x) (f y) ↔ IsConjRoot R x y := by\n  rw [isConjRoot_def, isConjRoot_def, algHom_eq f hf, algHom_eq f hf]\n\n"}
{"name":"isConjRoot_algHom_iff","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nB : Type u_6\ninst✝⁵ : CommRing R\ninst✝⁴ : Ring B\ninst✝³ : Algebra R B\nA : Type u_7\ninst✝² : DivisionRing A\ninst✝¹ : Algebra R A\ninst✝ : Nontrivial B\nx y : A\nf : AlgHom R A B\n⊢ Iff (IsConjRoot R (f x) (f y)) (IsConjRoot R x y)","decl":"/--\nIf `y` is a conjugate root of `x` in some division ring and `f` is a `R`-algebra homomorphism, then\n`f y` is a conjugate root of `f x`.\n-/\ntheorem isConjRoot_algHom_iff {A} [DivisionRing A] [Algebra R A]\n    [Nontrivial B] {x y : A} (f : A →ₐ[R] B) : IsConjRoot R (f x) (f y) ↔ IsConjRoot R x y :=\n  isConjRoot_algHom_iff_of_injective f.injective\n\n"}
{"name":"isConjRoot_of_aeval_eq_zero","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nA : Type u_5\ninst✝³ : Ring A\ninst✝² : Field K\ninst✝¹ : Algebra K A\ninst✝ : IsDomain A\nx y : A\nhx : IsIntegral K x\nh : Eq ((Polynomial.aeval y) (minpoly K x)) 0\n⊢ IsConjRoot K x y","decl":"/--\nLet `p` be the minimal polynomial of an integral element `x`. If `p y` = 0, then `y` is a\nconjugate root of `x`.\n-/\ntheorem isConjRoot_of_aeval_eq_zero [IsDomain A] {x y : A} (hx : IsIntegral K x)\n    (h : aeval y (minpoly K x) = 0) : IsConjRoot K x y :=\n  minpoly.eq_of_irreducible_of_monic (minpoly.irreducible hx) h (minpoly.monic hx)\n\n"}
{"name":"isConjRoot_iff_aeval_eq_zero","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nA : Type u_5\ninst✝³ : Ring A\ninst✝² : Field K\ninst✝¹ : Algebra K A\ninst✝ : IsDomain A\nx y : A\nh : IsIntegral K x\n⊢ Iff (IsConjRoot K x y) (Eq ((Polynomial.aeval y) (minpoly K x)) 0)","decl":"/--\nLet `p` be the minimal polynomial of an integral element `x`. Then `y` is a conjugate root of `x`\nif and only if `p y = 0`.\n-/\ntheorem isConjRoot_iff_aeval_eq_zero [IsDomain A] {x y : A}\n    (h : IsIntegral K x) : IsConjRoot K x y ↔ aeval y (minpoly K x) = 0 :=\n  ⟨IsConjRoot.aeval_eq_zero, isConjRoot_of_aeval_eq_zero h⟩\n\n"}
{"name":"isConjRoot_of_algEquiv","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\ns : AlgEquiv R A A\n⊢ IsConjRoot R x (s x)","decl":"/--\nLet `s` be an `R`-algebra isomorphism. Then `s x` is a conjugate root of `x`.\n-/\n@[simp]\ntheorem isConjRoot_of_algEquiv (x : A) (s : A ≃ₐ[R] A) : IsConjRoot R x (s x) :=\n  Eq.symm (minpoly.algEquiv_eq s x)\n\n"}
{"name":"isConjRoot_of_algEquiv'","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\ns : AlgEquiv R A A\n⊢ IsConjRoot R (s x) x","decl":"/--\nA variant of `isConjRoot_of_algEquiv`.\nLet `s` be an `R`-algebra isomorphism. Then `x` is a conjugate root of `s x`.\n-/\n@[simp]\ntheorem isConjRoot_of_algEquiv' (x : A) (s : A ≃ₐ[R] A) : IsConjRoot R (s x) x :=\n  (minpoly.algEquiv_eq s x)\n\n"}
{"name":"isConjRoot_of_algEquiv₂","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx : A\ns₁ s₂ : AlgEquiv R A A\n⊢ IsConjRoot R (s₁ x) (s₂ x)","decl":"/--\nLet `s₁` and `s₂` be two `R`-algebra isomorphisms. Then `s₂ x` is a conjugate root of `s₁ x`.\n-/\n@[simp]\ntheorem isConjRoot_of_algEquiv₂ (x : A) (s₁ s₂ : A ≃ₐ[R] A) : IsConjRoot R (s₁ x) (s₂ x) :=\n  isConjRoot_def.mpr <| (minpoly.algEquiv_eq s₂ x) ▸ (minpoly.algEquiv_eq s₁ x)\n\n"}
{"name":"IsConjRoot.exists_algEquiv","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Normal K L\nx y : L\nh : IsConjRoot K x y\n⊢ Exists fun σ => Eq (σ y) x","decl":"/--\nLet `L / K` be a normal field extension. For any two elements `x` and `y` in `L`, if `y` is a\nconjugate root of `x`, then there exists a `K`-automorphism `σ : L ≃ₐ[K] L` such\nthat `σ y = x`.\n-/\ntheorem IsConjRoot.exists_algEquiv [Normal K L] {x y: L} (h : IsConjRoot K x y) :\n    ∃ σ : L ≃ₐ[K] L, σ y = x := by\n  obtain ⟨σ, hσ⟩ :=\n    exists_algHom_of_splits_of_aeval (normal_iff.mp inferInstance) (h ▸ minpoly.aeval K x)\n  exact ⟨AlgEquiv.ofBijective σ (σ.normal_bijective _ _ _), hσ⟩\n\n"}
{"name":"isConjRoot_iff_exists_algEquiv","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Normal K L\nx y : L\n⊢ Iff (IsConjRoot K x y) (Exists fun σ => Eq (σ y) x)","decl":"/--\nLet `L / K` be a normal field extension. For any two elements `x` and `y` in `L`, `y` is a\nconjugate root of `x` if and only if there exists a `K`-automorphism `σ : L ≃ₐ[K] L` such\nthat `σ y = x`.\n-/\ntheorem isConjRoot_iff_exists_algEquiv [Normal K L] {x y : L} :\n    IsConjRoot K x y ↔ ∃ σ : L ≃ₐ[K] L, σ y = x :=\n  ⟨exists_algEquiv, fun ⟨_, h⟩ => h ▸ (isConjRoot_of_algEquiv _ _).symm⟩\n\n"}
{"name":"isConjRoot_iff_orbitRel","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Normal K L\nx y : L\n⊢ Iff (IsConjRoot K x y) ((MulAction.orbitRel (AlgEquiv K L L) L) x y)","decl":"/--\nLet `L / K` be a normal field extension. For any two elements `x` and `y` in `L`, `y` is a\nconjugate root of `x` if and only if `x` and `y` falls in the same orbit of the action of Galois\ngroup.\n-/\ntheorem isConjRoot_iff_orbitRel [Normal K L] {x y : L} :\n    IsConjRoot K x y ↔ MulAction.orbitRel (L ≃ₐ[K] L) L x y:=\n  (isConjRoot_iff_exists_algEquiv)\n\n"}
{"name":"IsConjRoot.of_isScalarTower","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nL : Type u_3\nS : Type u_4\ninst✝⁷ : CommRing S\ninst✝⁶ : Field K\ninst✝⁵ : Field L\ninst✝⁴ : Algebra K S\ninst✝³ : Algebra K L\ninst✝² : Algebra L S\ninst✝¹ : IsDomain S\ninst✝ : IsScalarTower K L S\nx y : S\nhx : IsIntegral K x\nh : IsConjRoot L x y\n⊢ IsConjRoot K x y","decl":"/--\nLet `S / L / K` be a tower of extensions. For any two elements `y` and `x` in `S`, if `y` is a\nconjugate root of `x` over `L`, then `y` is also a conjugate root of `x` over\n`K`.\n-/\ntheorem IsConjRoot.of_isScalarTower [IsScalarTower K L S] {x y : S} (hx : IsIntegral K x)\n    (h : IsConjRoot L x y) : IsConjRoot K x y :=\n  isConjRoot_of_aeval_eq_zero hx <| minpoly.aeval_of_isScalarTower K x y (aeval_eq_zero h)\n\n"}
{"name":"isConjRoot_iff_mem_minpoly_aroots","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nx y : S\nh : IsIntegral K x\n⊢ Iff (IsConjRoot K x y) (Membership.mem ((minpoly K x).aroots S) y)","decl":"/--\n`y` is a conjugate root of `x` over `K` if and only if `y` is a root of the minimal polynomial of\n`x`. This is variant of `isConjRoot_iff_aeval_eq_zero`.\n-/\ntheorem isConjRoot_iff_mem_minpoly_aroots {x y : S} (h : IsIntegral K x) :\n    IsConjRoot K x y ↔ y ∈ (minpoly K x).aroots S := by\n  rw [Polynomial.mem_aroots, isConjRoot_iff_aeval_eq_zero h]\n  simp only [iff_and_self]\n  exact fun _ => minpoly.ne_zero h\n\n"}
{"name":"isConjRoot_iff_mem_minpoly_rootSet","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nx y : S\nh : IsIntegral K x\n⊢ Iff (IsConjRoot K x y) (Membership.mem ((minpoly K x).rootSet S) y)","decl":"/--\n`y` is a conjugate root of `x` over `K` if and only if `y` is a root of the minimal polynomial of\n`x`. This is variant of `isConjRoot_iff_aeval_eq_zero`.\n-/\ntheorem isConjRoot_iff_mem_minpoly_rootSet {x y : S}\n    (h : IsIntegral K x) : IsConjRoot K x y ↔ y ∈ (minpoly K x).rootSet S :=\n  (isConjRoot_iff_mem_minpoly_aroots h).trans (by simp [rootSet])\n\n"}
{"name":"IsConjRoot.isIntegral","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nA : Type u_5\ninst✝² : CommRing R\ninst✝¹ : Ring A\ninst✝ : Algebra R A\nx y : A\nhx : IsIntegral R x\nh : IsConjRoot R x y\n⊢ IsIntegral R y","decl":"/--\nIf `y` is a conjugate root of an integral element `x` over `R`, then `y` is also integral\nover `R`.\n-/\ntheorem isIntegral {x y : A} (hx : IsIntegral R x) (h : IsConjRoot R x y) :\n    IsIntegral R y :=\n  ⟨minpoly R x, minpoly.monic hx, h ▸ minpoly.aeval R y⟩\n\n"}
{"name":"IsConjRoot.eq_algebraMap_of_injective","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R S\nr : R\nx : S\nh : IsConjRoot R ((algebraMap R S) r) x\nhf : Function.Injective ⇑(algebraMap R S)\n⊢ Eq x ((algebraMap R S) r)","decl":"/--\nA variant of `IsConjRoot.eq_of_isConjRoot_algebraMap`, only assuming `Nontrivial R`,\n`NoZeroSMulDivisors R A` and `Function.Injective (algebraMap R A)` instead of `Field R`. If `x` is a\nconjugate root of some element `algebraMap R S r` in the image of the base ring, then\n`x = algebraMap R S r`.\n-/\ntheorem eq_algebraMap_of_injective [Nontrivial R] [NoZeroSMulDivisors R S] {r : R} {x : S}\n    (h : IsConjRoot R (algebraMap R S r) x) (hf : Function.Injective (algebraMap R S)) :\n    x = algebraMap R S r := by\n  rw [IsConjRoot, minpoly.eq_X_sub_C_of_algebraMap_inj _ hf] at h\n  have : x ∈ (X - C r).aroots S := by\n    rw [mem_aroots]\n    simp [X_sub_C_ne_zero, h ▸ minpoly.aeval R x]\n  simpa [aroots_X_sub_C] using this\n\n"}
{"name":"IsConjRoot.eq_algebraMap","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nr : K\nx : S\nh : IsConjRoot K ((algebraMap K S) r) x\n⊢ Eq x ((algebraMap K S) r)","decl":"/--\nIf `x` is a conjugate root of some element `algebraMap R S r` in the image of the base ring, then\n`x = algebraMap R S r`.\n-/\ntheorem eq_algebraMap {r : K} {x : S} (h : IsConjRoot K (algebraMap K S r) x) :\n    x = algebraMap K S r :=\n  eq_algebraMap_of_injective h (algebraMap K S).injective\n\n"}
{"name":"IsConjRoot.eq_zero_of_injective","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R S\nx : S\nh : IsConjRoot R 0 x\nhf : Function.Injective ⇑(algebraMap R S)\n⊢ Eq x 0","decl":"/--\nA variant of `IsConjRoot.eq_zero`, only assuming `Nontrivial R`,\n`NoZeroSMulDivisors R A` and `Function.Injective (algebraMap R A)` instead of `Field R`. If `x` is a\nconjugate root of `0`, then `x = 0`.\n-/\ntheorem eq_zero_of_injective [Nontrivial R] [NoZeroSMulDivisors R S] {x : S} (h : IsConjRoot R 0 x)\n    (hf : Function.Injective (algebraMap R S)) : x = 0 :=\n  (algebraMap R S).map_zero ▸ (eq_algebraMap_of_injective ((algebraMap R S).map_zero ▸ h) hf)\n\n"}
{"name":"IsConjRoot.eq_zero","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nx : S\nh : IsConjRoot K 0 x\n⊢ Eq x 0","decl":"/--\nIf `x` is a conjugate root of `0`, then `x = 0`.\n-/\ntheorem eq_zero {x : S} (h : IsConjRoot K 0 x) : x = 0 :=\n  eq_zero_of_injective h (algebraMap K S).injective\n\n"}
{"name":"isConjRoot_iff_eq_algebraMap_of_injective","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R S\nr : R\nx : S\nhf : Function.Injective ⇑(algebraMap R S)\n⊢ Iff (IsConjRoot R ((algebraMap R S) r) x) (Eq x ((algebraMap R S) r))","decl":"/--\nA variant of `IsConjRoot.eq_of_isConjRoot_algebraMap`, only assuming `Nontrivial R`,\n`NoZeroSMulDivisors R A` and `Function.Injective (algebraMap R A)` instead of `Field R`. If `x` is a\nconjugate root of some element `algebraMap R S r` in the image of the base ring, then\n`x = algebraMap R S r`.\n-/\ntheorem isConjRoot_iff_eq_algebraMap_of_injective [Nontrivial R] [NoZeroSMulDivisors R S] {r : R}\n    {x : S} (hf : Function.Injective (algebraMap R S)) :\n    IsConjRoot R (algebraMap R S r) x ↔ x = algebraMap R S r :=\n    ⟨fun h => eq_algebraMap_of_injective h hf, fun h => h.symm ▸ rfl⟩\n\n"}
{"name":"isConjRoot_iff_eq_algebraMap","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nr : K\nx : S\n⊢ Iff (IsConjRoot K ((algebraMap K S) r) x) (Eq x ((algebraMap K S) r))","decl":"/--\nAn element `x` is a conjugate root of some element `algebraMap R S r` in the image of the base ring\nif and only if `x = algebraMap R S r`.\n-/\n@[simp]\ntheorem isConjRoot_iff_eq_algebraMap {r : K} {x : S} :\n    IsConjRoot K (algebraMap K S r) x ↔ x = algebraMap K S r :=\n  isConjRoot_iff_eq_algebraMap_of_injective (algebraMap K S).injective\n\n"}
{"name":"isConjRoot_iff_eq_algebraMap'","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nr : K\nx : S\n⊢ Iff (IsConjRoot K x ((algebraMap K S) r)) (Eq x ((algebraMap K S) r))","decl":"/--\nA variant of `isConjRoot_iff_eq_algebraMap`.\nan element `algebraMap R S r` in the image of the base ring is a conjugate root of an element `x`\nif and only if `x = algebraMap R S r`.\n-/\n@[simp]\ntheorem isConjRoot_iff_eq_algebraMap' {r : K} {x : S} :\n    IsConjRoot K x (algebraMap K S r) ↔ x = algebraMap K S r :=\n  eq_comm.trans <| isConjRoot_iff_eq_algebraMap_of_injective (algebraMap K S).injective\n\n"}
{"name":"isConjRoot_zero_iff_eq_zero_of_injective","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : Nontrivial R\nx : S\ninst✝ : NoZeroSMulDivisors R S\nhf : Function.Injective ⇑(algebraMap R S)\n⊢ Iff (IsConjRoot R 0 x) (Eq x 0)","decl":"/--\nA variant of `IsConjRoot.iff_eq_zero`, only assuming `Nontrivial R`,\n`NoZeroSMulDivisors R A` and `Function.Injective (algebraMap R A)` instead of `Field R`. `x` is a\nconjugate root of `0` if and only if `x = 0`.\n-/\ntheorem isConjRoot_zero_iff_eq_zero_of_injective [Nontrivial R] {x : S} [NoZeroSMulDivisors R S]\n    (hf : Function.Injective (algebraMap R S)) : IsConjRoot R 0 x ↔ x = 0 :=\n  ⟨fun h => eq_zero_of_injective h hf, fun h => h.symm ▸ rfl⟩\n\n"}
{"name":"isConjRoot_zero_iff_eq_zero","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nx : S\n⊢ Iff (IsConjRoot K 0 x) (Eq x 0)","decl":"/--\n`x` is a conjugate root of `0` if and only if `x = 0`.\n-/\n@[simp]\ntheorem isConjRoot_zero_iff_eq_zero {x : S} : IsConjRoot K 0 x ↔ x = 0 :=\n  isConjRoot_zero_iff_eq_zero_of_injective (algebraMap K S).injective\n\n"}
{"name":"isConjRoot_zero_iff_eq_zero'","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nx : S\n⊢ Iff (IsConjRoot K x 0) (Eq x 0)","decl":"/--\nA variant of `IsConjRoot.iff_eq_zero`. `0` is a conjugate root of `x` if and only if `x = 0`.\n-/\n@[simp]\ntheorem isConjRoot_zero_iff_eq_zero' {x : S} : IsConjRoot K x 0 ↔ x = 0 :=\n  eq_comm.trans <| isConjRoot_zero_iff_eq_zero_of_injective (algebraMap K S).injective\n\n"}
{"name":"IsConjRoot.ne_zero_of_injective","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"R : Type u_1\nS : Type u_4\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsDomain S\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroSMulDivisors R S\nx y : S\nhx : Ne x 0\nh : IsConjRoot R x y\nhf : Function.Injective ⇑(algebraMap R S)\n⊢ Ne y 0","decl":"/--\nA variant of `IsConjRoot.ne_zero`, only assuming `Nontrivial R`,\n`NoZeroSMulDivisors R A` and `Function.Injective (algebraMap R A)` instead of `Field R`. If `y` is\na conjugate root of a nonzero element `x`, then `y` is not zero.\n-/\ntheorem ne_zero_of_injective [Nontrivial R] [NoZeroSMulDivisors R S] {x y : S} (hx : x ≠ 0)\n    (h : IsConjRoot R x y) (hf : Function.Injective (algebraMap R S)) : y ≠ 0 :=\n  fun g => hx (eq_zero_of_injective (g ▸ h.symm) hf)\n\n"}
{"name":"IsConjRoot.ne_zero","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nS : Type u_4\ninst✝³ : CommRing S\ninst✝² : Field K\ninst✝¹ : Algebra K S\ninst✝ : IsDomain S\nx y : S\nhx : Ne x 0\nh : IsConjRoot K x y\n⊢ Ne y 0","decl":"/--\nIf `y` is a conjugate root of a nonzero element `x`, then `y` is not zero.\n-/\ntheorem ne_zero {x y : S} (hx : x ≠ 0) (h : IsConjRoot K x y) : y ≠ 0 :=\n  ne_zero_of_injective hx h (algebraMap K S).injective\n\n"}
{"name":"not_mem_iff_exists_ne_and_isConjRoot","module":"Mathlib.FieldTheory.Minpoly.IsConjRoot","initialProofState":"K : Type u_2\nL : Type u_3\ninst✝² : Field K\ninst✝¹ : Field L\ninst✝ : Algebra K L\nx : L\nh : IsSeparable K x\nsp : Polynomial.Splits (algebraMap K L) (minpoly K x)\n⊢ Iff (Not (Membership.mem Bot.bot x)) (Exists fun y => And (Ne x y) (IsConjRoot K x y))","decl":"/--\nLet `L / K` be a field extension. If `x` is a separable element over `K` and the minimal polynomial\nof `x` splits in `L`, then `x` is not in `K` if and only if there exists a conjugate\nroot of `x` over `K` in `L` which is not equal to `x` itself.\n-/\ntheorem not_mem_iff_exists_ne_and_isConjRoot {x : L} (h : IsSeparable K x)\n    (sp : (minpoly K x).Splits (algebraMap K L)) :\n    x ∉ (⊥ : Subalgebra K L) ↔ ∃ y : L, x ≠ y ∧ IsConjRoot K x y := by\n  calc\n    _ ↔ 2 ≤ (minpoly K x).natDegree := (minpoly.two_le_natDegree_iff h.isIntegral).symm\n    _ ↔ 2 ≤ Fintype.card ((minpoly K x).rootSet L) :=\n      (Polynomial.card_rootSet_eq_natDegree h sp) ▸ Iff.rfl\n    _ ↔ Nontrivial ((minpoly K x).rootSet L) := Fintype.one_lt_card_iff_nontrivial\n    _ ↔ ∃ y : ((minpoly K x).rootSet L), ↑y ≠ x :=\n      (nontrivial_iff_exists_ne ⟨x, mem_rootSet.mpr ⟨minpoly.ne_zero h.isIntegral,\n          minpoly.aeval K x⟩⟩).trans ⟨fun ⟨y, hy⟩ => ⟨y, Subtype.coe_ne_coe.mpr hy⟩,\n          fun ⟨y, hy⟩ => ⟨y, Subtype.coe_ne_coe.mp hy⟩⟩\n    _ ↔ _ :=\n      ⟨fun ⟨⟨y, hy⟩, hne⟩ => ⟨y, ⟨hne.symm,\n          (isConjRoot_iff_mem_minpoly_rootSet h.isIntegral).mpr hy⟩⟩,\n          fun ⟨y, hne, hy⟩ => ⟨⟨y,\n          (isConjRoot_iff_mem_minpoly_rootSet h.isIntegral).mp hy⟩, hne.symm⟩⟩\n"}
