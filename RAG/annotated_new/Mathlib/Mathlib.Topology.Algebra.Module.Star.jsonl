{"name":"starL_symm_apply","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : CommSemiring R\ninst✝⁶ : StarRing R\ninst✝⁵ : AddCommMonoid A\ninst✝⁴ : StarAddMonoid A\ninst✝³ : Module R A\ninst✝² : StarModule R A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousStar A\na✝ : A\n⊢ Eq ((starL R).symm a✝) (starAddEquiv.symm a✝)","decl":"/-- If `A` is a topological module over a commutative `R` with compatible actions,\nthen `star` is a continuous semilinear equivalence. -/\n@[simps!]\ndef starL (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] [TopologicalSpace A] [ContinuousStar A] :\n    A ≃L⋆[R] A where\n  toLinearEquiv := starLinearEquiv R\n  continuous_toFun := continuous_star\n  continuous_invFun := continuous_star\n\n-- TODO: this could be replaced with something like `(starL R).restrict_scalarsₛₗ h` if we\n-- implemented the idea in\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Star-semilinear.20maps.20are.20semilinear.20when.20star.20is.20trivial/near/359557835\n"}
{"name":"starL_apply","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁷ : CommSemiring R\ninst✝⁶ : StarRing R\ninst✝⁵ : AddCommMonoid A\ninst✝⁴ : StarAddMonoid A\ninst✝³ : Module R A\ninst✝² : StarModule R A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousStar A\na✝ : A\n⊢ Eq ((starL R) a✝) (Star.star a✝)","decl":"/-- If `A` is a topological module over a commutative `R` with compatible actions,\nthen `star` is a continuous semilinear equivalence. -/\n@[simps!]\ndef starL (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] [TopologicalSpace A] [ContinuousStar A] :\n    A ≃L⋆[R] A where\n  toLinearEquiv := starLinearEquiv R\n  continuous_toFun := continuous_star\n  continuous_invFun := continuous_star\n\n-- TODO: this could be replaced with something like `(starL R).restrict_scalarsₛₗ h` if we\n-- implemented the idea in\n-- https://leanprover.zulipchat.com/#narrow/stream/217875-Is-there-code-for-X.3F/topic/Star-semilinear.20maps.20are.20semilinear.20when.20star.20is.20trivial/near/359557835\n"}
{"name":"starL'_apply","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁸ : CommSemiring R\ninst✝⁷ : StarRing R\ninst✝⁶ : TrivialStar R\ninst✝⁵ : AddCommMonoid A\ninst✝⁴ : StarAddMonoid A\ninst✝³ : Module R A\ninst✝² : StarModule R A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousStar A\na✝ : A\n⊢ Eq ((starL' R) a✝) (Star.star a✝)","decl":"/-- If `A` is a topological module over a commutative `R` with trivial star and compatible actions,\nthen `star` is a continuous linear equivalence. -/\n@[simps!]\ndef starL' (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [TrivialStar R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] [TopologicalSpace A] [ContinuousStar A] :\n    A ≃L[R] A :=\n  (starL R : A ≃L⋆[R] A).trans\n    ({ AddEquiv.refl A with\n        map_smul' := fun r a => by simp [starRingEnd_apply]\n        continuous_toFun := continuous_id\n        continuous_invFun := continuous_id } :\n      A ≃L⋆[R] A)\n\n"}
{"name":"starL'_symm_apply","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁸ : CommSemiring R\ninst✝⁷ : StarRing R\ninst✝⁶ : TrivialStar R\ninst✝⁵ : AddCommMonoid A\ninst✝⁴ : StarAddMonoid A\ninst✝³ : Module R A\ninst✝² : StarModule R A\ninst✝¹ : TopologicalSpace A\ninst✝ : ContinuousStar A\na✝ : A\n⊢ Eq ((starL' R).symm a✝) ((starL R).symm ({ toFun := id, map_add' := ⋯, map_smul' := ⋯, invFun := id, left_inv := ⋯, right_inv := ⋯ }.symm a✝))","decl":"/-- If `A` is a topological module over a commutative `R` with trivial star and compatible actions,\nthen `star` is a continuous linear equivalence. -/\n@[simps!]\ndef starL' (R : Type*) {A : Type*} [CommSemiring R] [StarRing R] [TrivialStar R] [AddCommMonoid A]\n    [StarAddMonoid A] [Module R A] [StarModule R A] [TopologicalSpace A] [ContinuousStar A] :\n    A ≃L[R] A :=\n  (starL R : A ≃L⋆[R] A).trans\n    ({ AddEquiv.refl A with\n        map_smul' := fun r a => by simp [starRingEnd_apply]\n        continuous_toFun := continuous_id\n        continuous_invFun := continuous_id } :\n      A ≃L⋆[R] A)\n\n"}
{"name":"continuous_selfAdjointPart","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : ContinuousAdd A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\n⊢ Continuous ⇑(selfAdjointPart R)","decl":"theorem continuous_selfAdjointPart [ContinuousAdd A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    Continuous (selfAdjointPart R (A := A)) :=\n  ((continuous_const_smul _).comp <| continuous_id.add continuous_star).subtype_mk _\n\n"}
{"name":"continuous_skewAdjointPart","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : ContinuousSub A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\n⊢ Continuous ⇑(skewAdjointPart R)","decl":"theorem continuous_skewAdjointPart [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    Continuous (skewAdjointPart R (A := A)) :=\n  ((continuous_const_smul _).comp <| continuous_id.sub continuous_star).subtype_mk _\n\n"}
{"name":"continuous_decomposeProdAdjoint","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalAddGroup A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\n⊢ Continuous ⇑(StarModule.decomposeProdAdjoint R A)","decl":"theorem continuous_decomposeProdAdjoint [TopologicalAddGroup A] [ContinuousStar A]\n    [ContinuousConstSMul R A] : Continuous (StarModule.decomposeProdAdjoint R A) :=\n  (continuous_selfAdjointPart R A).prod_mk (continuous_skewAdjointPart R A)\n\n"}
{"name":"continuous_decomposeProdAdjoint_symm","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁹ : Semiring R\ninst✝⁸ : StarMul R\ninst✝⁷ : TrivialStar R\ninst✝⁶ : AddCommGroup A\ninst✝⁵ : Module R A\ninst✝⁴ : StarAddMonoid A\ninst✝³ : StarModule R A\ninst✝² : Invertible 2\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalAddGroup A\n⊢ Continuous ⇑(StarModule.decomposeProdAdjoint R A).symm","decl":"theorem continuous_decomposeProdAdjoint_symm [TopologicalAddGroup A] :\n    Continuous (StarModule.decomposeProdAdjoint R A).symm :=\n  (continuous_subtype_val.comp continuous_fst).add (continuous_subtype_val.comp continuous_snd)\n\n"}
{"name":"selfAdjointPartL_apply_coe","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : ContinuousAdd A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\nx : A\n⊢ Eq (↑((selfAdjointPartL R A) x)) (HAdd.hAdd (HSMul.hSMul (Invertible.invOf 2) x) (HSMul.hSMul (Invertible.invOf 2) (Star.star x)))","decl":"/-- The self-adjoint part of an element of a star module, as a continuous linear map. -/\n@[simps! -isSimp]\ndef selfAdjointPartL [ContinuousAdd A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    A →L[R] selfAdjoint A where\n  toLinearMap := selfAdjointPart R\n  cont := continuous_selfAdjointPart _ _\n\n"}
{"name":"skewAdjointPartL_apply_coe","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : ContinuousSub A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\nx : A\n⊢ Eq (↑((skewAdjointPartL R A) x)) (HSMul.hSMul (Invertible.invOf 2) (HSub.hSub x (Star.star x)))","decl":"/-- The skew-adjoint part of an element of a star module, as a continuous linear map. -/\n@[simps!]\ndef skewAdjointPartL [ContinuousSub A] [ContinuousStar A] [ContinuousConstSMul R A] :\n    A →L[R] skewAdjoint A where\n  toLinearMap := skewAdjointPart R\n  cont := continuous_skewAdjointPart _ _\n\n"}
{"name":"StarModule.decomposeProdAdjointL_apply","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalAddGroup A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\ni : A\n⊢ Eq ((StarModule.decomposeProdAdjointL R A) i) { fst := (selfAdjointPart R) i, snd := (skewAdjointPart R) i }","decl":"/-- The decomposition of elements of a star module into their self- and skew-adjoint parts,\nas a continuous linear equivalence. -/\n@[simps!]\ndef StarModule.decomposeProdAdjointL [TopologicalAddGroup A] [ContinuousStar A]\n    [ContinuousConstSMul R A] : A ≃L[R] selfAdjoint A × skewAdjoint A where\n  toLinearEquiv := StarModule.decomposeProdAdjoint R A\n  continuous_toFun := continuous_decomposeProdAdjoint _ _\n  continuous_invFun := continuous_decomposeProdAdjoint_symm _ _\n"}
{"name":"StarModule.decomposeProdAdjointL_symm_apply","module":"Mathlib.Topology.Algebra.Module.Star","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝¹¹ : Semiring R\ninst✝¹⁰ : StarMul R\ninst✝⁹ : TrivialStar R\ninst✝⁸ : AddCommGroup A\ninst✝⁷ : Module R A\ninst✝⁶ : StarAddMonoid A\ninst✝⁵ : StarModule R A\ninst✝⁴ : Invertible 2\ninst✝³ : TopologicalSpace A\ninst✝² : TopologicalAddGroup A\ninst✝¹ : ContinuousStar A\ninst✝ : ContinuousConstSMul R A\na : Prod (Subtype fun x => Membership.mem (selfAdjoint A) x) (Subtype fun x => Membership.mem (skewAdjoint A) x)\n⊢ Eq ((StarModule.decomposeProdAdjointL R A).symm a) (HAdd.hAdd ((selfAdjoint.submodule R A).subtype a.1) ((skewAdjoint.submodule R A).subtype a.2))","decl":"/-- The decomposition of elements of a star module into their self- and skew-adjoint parts,\nas a continuous linear equivalence. -/\n@[simps!]\ndef StarModule.decomposeProdAdjointL [TopologicalAddGroup A] [ContinuousStar A]\n    [ContinuousConstSMul R A] : A ≃L[R] selfAdjoint A × skewAdjoint A where\n  toLinearEquiv := StarModule.decomposeProdAdjoint R A\n  continuous_toFun := continuous_decomposeProdAdjoint _ _\n  continuous_invFun := continuous_decomposeProdAdjoint_symm _ _\n"}
