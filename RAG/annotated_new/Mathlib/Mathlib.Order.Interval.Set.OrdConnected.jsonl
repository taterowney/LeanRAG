{"name":"Set.OrdConnected.out","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nh : s.OrdConnected\nx : α\nx✝¹ : Membership.mem s x\ny : α\nx✝ : Membership.mem s y\n⊢ HasSubset.Subset (Set.Icc x y) s","decl":"theorem OrdConnected.out (h : OrdConnected s) : ∀ ⦃x⦄ (_ : x ∈ s) ⦃y⦄ (_ : y ∈ s), Icc x y ⊆ s :=\n  h.1\n\n"}
{"name":"Set.ordConnected_def","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff s.OrdConnected (∀ ⦃x : α⦄, Membership.mem s x → ∀ ⦃y : α⦄, Membership.mem s y → HasSubset.Subset (Set.Icc x y) s)","decl":"theorem ordConnected_def : OrdConnected s ↔ ∀ ⦃x⦄ (_ : x ∈ s) ⦃y⦄ (_ : y ∈ s), Icc x y ⊆ s :=\n  ⟨fun h => h.1, fun h => ⟨h⟩⟩\n\n"}
{"name":"Set.ordConnected_iff","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff s.OrdConnected (∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LE.le x y → HasSubset.Subset (Set.Icc x y) s)","decl":"/-- It suffices to prove `[[x, y]] ⊆ s` for `x y ∈ s`, `x ≤ y`. -/\ntheorem ordConnected_iff : OrdConnected s ↔ ∀ x ∈ s, ∀ y ∈ s, x ≤ y → Icc x y ⊆ s :=\n  ordConnected_def.trans\n    ⟨fun hs _ hx _ hy _ => hs hx hy, fun H x hx y hy _ hz => H x hx y hy (le_trans hz.1 hz.2) hz⟩\n\n"}
{"name":"Set.ordConnected_of_Ioo","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_3\ninst✝ : PartialOrder α\ns : Set α\nhs : ∀ (x : α), Membership.mem s x → ∀ (y : α), Membership.mem s y → LT.lt x y → HasSubset.Subset (Set.Ioo x y) s\n⊢ s.OrdConnected","decl":"theorem ordConnected_of_Ioo {α : Type*} [PartialOrder α] {s : Set α}\n    (hs : ∀ x ∈ s, ∀ y ∈ s, x < y → Ioo x y ⊆ s) : OrdConnected s := by\n  rw [ordConnected_iff]\n  intro x hx y hy hxy\n  rcases eq_or_lt_of_le hxy with (rfl | hxy'); · simpa\n  rw [← Ioc_insert_left hxy, ← Ioo_insert_right hxy']\n  exact insert_subset_iff.2 ⟨hx, insert_subset_iff.2 ⟨hy, hs x hx y hy hxy'⟩⟩\n\n"}
{"name":"Set.OrdConnected.preimage_mono","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nf : β → α\nhs : s.OrdConnected\nhf : Monotone f\n⊢ (Set.preimage f s).OrdConnected","decl":"theorem OrdConnected.preimage_mono {f : β → α} (hs : OrdConnected s) (hf : Monotone f) :\n    OrdConnected (f ⁻¹' s) :=\n  ⟨fun _ hx _ hy _ hz => hs.out hx hy ⟨hf hz.1, hf hz.2⟩⟩\n\n"}
{"name":"Set.OrdConnected.preimage_anti","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nf : β → α\nhs : s.OrdConnected\nhf : Antitone f\n⊢ (Set.preimage f s).OrdConnected","decl":"theorem OrdConnected.preimage_anti {f : β → α} (hs : OrdConnected s) (hf : Antitone f) :\n    OrdConnected (f ⁻¹' s) :=\n  ⟨fun _ hx _ hy _ hz => hs.out hy hx ⟨hf hz.2, hf hz.1⟩⟩\n\n"}
{"name":"Set.Icc_subset","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : s.OrdConnected\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ HasSubset.Subset (Set.Icc x y) s","decl":"protected theorem Icc_subset (s : Set α) [hs : OrdConnected s] {x y} (hx : x ∈ s) (hy : y ∈ s) :\n    Icc x y ⊆ s :=\n  hs.out hx hy\n\n"}
{"name":"OrderEmbedding.image_Icc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : (Set.range ⇑e).OrdConnected\nx y : α\n⊢ Eq (Set.image (⇑e) (Set.Icc x y)) (Set.Icc (e x) (e y))","decl":"theorem image_Icc (e : α ↪o β) (he : OrdConnected (range e)) (x y : α) :\n    e '' Icc x y = Icc (e x) (e y) := by\n  rw [← e.preimage_Icc, image_preimage_eq_inter_range, inter_eq_left.2 (he.out ⟨_, rfl⟩ ⟨_, rfl⟩)]\n\n"}
{"name":"OrderEmbedding.image_Ico","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : (Set.range ⇑e).OrdConnected\nx y : α\n⊢ Eq (Set.image (⇑e) (Set.Ico x y)) (Set.Ico (e x) (e y))","decl":"theorem image_Ico (e : α ↪o β) (he : OrdConnected (range e)) (x y : α) :\n    e '' Ico x y = Ico (e x) (e y) := by\n  rw [← e.preimage_Ico, image_preimage_eq_inter_range,\n    inter_eq_left.2 <| Ico_subset_Icc_self.trans <| he.out ⟨_, rfl⟩ ⟨_, rfl⟩]\n\n"}
{"name":"OrderEmbedding.image_Ioc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : (Set.range ⇑e).OrdConnected\nx y : α\n⊢ Eq (Set.image (⇑e) (Set.Ioc x y)) (Set.Ioc (e x) (e y))","decl":"theorem image_Ioc (e : α ↪o β) (he : OrdConnected (range e)) (x y : α) :\n    e '' Ioc x y = Ioc (e x) (e y) := by\n  rw [← e.preimage_Ioc, image_preimage_eq_inter_range,\n    inter_eq_left.2 <| Ioc_subset_Icc_self.trans <| he.out ⟨_, rfl⟩ ⟨_, rfl⟩]\n\n"}
{"name":"OrderEmbedding.image_Ioo","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderEmbedding α β\nhe : (Set.range ⇑e).OrdConnected\nx y : α\n⊢ Eq (Set.image (⇑e) (Set.Ioo x y)) (Set.Ioo (e x) (e y))","decl":"theorem image_Ioo (e : α ↪o β) (he : OrdConnected (range e)) (x y : α) :\n    e '' Ioo x y = Ioo (e x) (e y) := by\n  rw [← e.preimage_Ioo, image_preimage_eq_inter_range,\n    inter_eq_left.2 <| Ioo_subset_Icc_self.trans <| he.out ⟨_, rfl⟩ ⟨_, rfl⟩]\n\n"}
{"name":"Set.image_subtype_val_Icc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : s.OrdConnected\nx y : ↑s\n⊢ Eq (Set.image Subtype.val (Set.Icc x y)) (Set.Icc ↑x ↑y)","decl":"@[simp]\nlemma image_subtype_val_Icc {s : Set α} [OrdConnected s] (x y : s) :\n    Subtype.val '' Icc x y = Icc x.1 y :=\n  (OrderEmbedding.subtype (· ∈ s)).image_Icc (by simpa) x y\n\n"}
{"name":"Set.image_subtype_val_Ico","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : s.OrdConnected\nx y : ↑s\n⊢ Eq (Set.image Subtype.val (Set.Ico x y)) (Set.Ico ↑x ↑y)","decl":"@[simp]\nlemma image_subtype_val_Ico {s : Set α} [OrdConnected s] (x y : s) :\n    Subtype.val '' Ico x y = Ico x.1 y :=\n  (OrderEmbedding.subtype (· ∈ s)).image_Ico (by simpa) x y\n\n"}
{"name":"Set.image_subtype_val_Ioc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : s.OrdConnected\nx y : ↑s\n⊢ Eq (Set.image Subtype.val (Set.Ioc x y)) (Set.Ioc ↑x ↑y)","decl":"@[simp]\nlemma image_subtype_val_Ioc {s : Set α} [OrdConnected s] (x y : s) :\n    Subtype.val '' Ioc x y = Ioc x.1 y :=\n  (OrderEmbedding.subtype (· ∈ s)).image_Ioc (by simpa) x y\n\n"}
{"name":"Set.image_subtype_val_Ioo","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : s.OrdConnected\nx y : ↑s\n⊢ Eq (Set.image Subtype.val (Set.Ioo x y)) (Set.Ioo ↑x ↑y)","decl":"@[simp]\nlemma image_subtype_val_Ioo {s : Set α} [OrdConnected s] (x y : s) :\n    Subtype.val '' Ioo x y = Ioo x.1 y :=\n  (OrderEmbedding.subtype (· ∈ s)).image_Ioo (by simpa) x y\n\n"}
{"name":"Set.OrdConnected.inter","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns t : Set α\nhs : s.OrdConnected\nht : t.OrdConnected\n⊢ (Inter.inter s t).OrdConnected","decl":"theorem OrdConnected.inter {s t : Set α} (hs : OrdConnected s) (ht : OrdConnected t) :\n    OrdConnected (s ∩ t) :=\n  ⟨fun _ hx _ hy => subset_inter (hs.out hx.1 hy.1) (ht.out hx.2 hy.2)⟩\n\n"}
{"name":"Set.OrdConnected.inter'","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ns t : Set α\ninst✝¹ : s.OrdConnected\ninst✝ : t.OrdConnected\n⊢ (Inter.inter s t).OrdConnected","decl":"instance OrdConnected.inter' {s t : Set α} [OrdConnected s] [OrdConnected t] :\n    OrdConnected (s ∩ t) :=\n  OrdConnected.inter ‹_› ‹_›\n\n"}
{"name":"Set.OrdConnected.dual","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\nhs : s.OrdConnected\n⊢ (Set.preimage (⇑OrderDual.ofDual) s).OrdConnected","decl":"theorem OrdConnected.dual {s : Set α} (hs : OrdConnected s) :\n    OrdConnected (OrderDual.ofDual ⁻¹' s) :=\n  ⟨fun _ hx _ hy _ hz => hs.out hy hx ⟨hz.2, hz.1⟩⟩\n\n"}
{"name":"Set.ordConnected_dual","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Set.preimage (⇑OrderDual.ofDual) s).OrdConnected s.OrdConnected","decl":"theorem ordConnected_dual {s : Set α} : OrdConnected (OrderDual.ofDual ⁻¹' s) ↔ OrdConnected s :=\n  ⟨fun h => by simpa only [ordConnected_def] using h.dual, fun h => h.dual⟩\n\n"}
{"name":"Set.ordConnected_sInter","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nS : Set (Set α)\nhS : ∀ (s : Set α), Membership.mem S s → s.OrdConnected\n⊢ S.sInter.OrdConnected","decl":"theorem ordConnected_sInter {S : Set (Set α)} (hS : ∀ s ∈ S, OrdConnected s) :\n    OrdConnected (⋂₀ S) :=\n  ⟨fun _x hx _y hy _z hz s hs => (hS s hs).out (hx s hs) (hy s hs) hz⟩\n\n"}
{"name":"Set.ordConnected_iInter","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nι : Sort u_3\ns : ι → Set α\nhs : ∀ (i : ι), (s i).OrdConnected\n⊢ (Set.iInter fun i => s i).OrdConnected","decl":"theorem ordConnected_iInter {ι : Sort*} {s : ι → Set α} (hs : ∀ i, OrdConnected (s i)) :\n    OrdConnected (⋂ i, s i) :=\n  ordConnected_sInter <| forall_mem_range.2 hs\n\n"}
{"name":"Set.ordConnected_iInter'","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nι : Sort u_3\ns : ι → Set α\ninst✝ : ∀ (i : ι), (s i).OrdConnected\n⊢ (Set.iInter fun i => s i).OrdConnected","decl":"instance ordConnected_iInter' {ι : Sort*} {s : ι → Set α} [∀ i, OrdConnected (s i)] :\n    OrdConnected (⋂ i, s i) :=\n  ordConnected_iInter ‹_›\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:107:6: warning: expanding binder group (i hi) -/\n"}
{"name":"Set.ordConnected_biInter","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nι : Sort u_3\np : ι → Prop\ns : (i : ι) → p i → Set α\nhs : ∀ (i : ι) (hi : p i), (s i hi).OrdConnected\n⊢ (Set.iInter fun i => Set.iInter fun hi => s i hi).OrdConnected","decl":"theorem ordConnected_biInter {ι : Sort*} {p : ι → Prop} {s : ∀ i, p i → Set α}\n    (hs : ∀ i hi, OrdConnected (s i hi)) : OrdConnected (⋂ (i) (hi), s i hi) :=\n  ordConnected_iInter fun i => ordConnected_iInter <| hs i\n\n"}
{"name":"Set.ordConnected_pi","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"ι : Type u_3\nα : ι → Type u_4\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\nh : ∀ (i : ι), Membership.mem s i → (t i).OrdConnected\n⊢ (s.pi t).OrdConnected","decl":"theorem ordConnected_pi {ι : Type*} {α : ι → Type*} [∀ i, Preorder (α i)] {s : Set ι}\n    {t : ∀ i, Set (α i)} (h : ∀ i ∈ s, OrdConnected (t i)) : OrdConnected (s.pi t) :=\n  ⟨fun _ hx _ hy _ hz i hi => (h i hi).out (hx i hi) (hy i hi) ⟨hz.1 i, hz.2 i⟩⟩\n\n"}
{"name":"Set.ordConnected_pi'","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"ι : Type u_3\nα : ι → Type u_4\ninst✝ : (i : ι) → Preorder (α i)\ns : Set ι\nt : (i : ι) → Set (α i)\nh : ∀ (i : ι), (t i).OrdConnected\n⊢ (s.pi t).OrdConnected","decl":"instance ordConnected_pi' {ι : Type*} {α : ι → Type*} [∀ i, Preorder (α i)] {s : Set ι}\n    {t : ∀ i, Set (α i)} [h : ∀ i, OrdConnected (t i)] : OrdConnected (s.pi t) :=\n  ordConnected_pi fun i _ => h i\n\n"}
{"name":"Set.ordConnected_Ici","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ (Set.Ici a).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Ici {a : α} : OrdConnected (Ici a) :=\n  ⟨fun _ hx _ _ _ hz => le_trans hx hz.1⟩\n\n"}
{"name":"Set.ordConnected_Iic","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ (Set.Iic a).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Iic {a : α} : OrdConnected (Iic a) :=\n  ⟨fun _ _ _ hy _ hz => le_trans hz.2 hy⟩\n\n"}
{"name":"Set.ordConnected_Ioi","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ (Set.Ioi a).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Ioi {a : α} : OrdConnected (Ioi a) :=\n  ⟨fun _ hx _ _ _ hz => lt_of_lt_of_le hx hz.1⟩\n\n"}
{"name":"Set.ordConnected_Iio","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ (Set.Iio a).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Iio {a : α} : OrdConnected (Iio a) :=\n  ⟨fun _ _ _ hy _ hz => lt_of_le_of_lt hz.2 hy⟩\n\n"}
{"name":"Set.ordConnected_Icc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ (Set.Icc a b).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Icc {a b : α} : OrdConnected (Icc a b) :=\n  ordConnected_Ici.inter ordConnected_Iic\n\n"}
{"name":"Set.ordConnected_Ico","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ (Set.Ico a b).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Ico {a b : α} : OrdConnected (Ico a b) :=\n  ordConnected_Ici.inter ordConnected_Iio\n\n"}
{"name":"Set.ordConnected_Ioc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ (Set.Ioc a b).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Ioc {a b : α} : OrdConnected (Ioc a b) :=\n  ordConnected_Ioi.inter ordConnected_Iic\n\n"}
{"name":"Set.ordConnected_Ioo","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ (Set.Ioo a b).OrdConnected","decl":"@[instance]\ntheorem ordConnected_Ioo {a b : α} : OrdConnected (Ioo a b) :=\n  ordConnected_Ioi.inter ordConnected_Iio\n\n"}
{"name":"Set.ordConnected_singleton","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_3\ninst✝ : PartialOrder α\na : α\n⊢ (Singleton.singleton a).OrdConnected","decl":"@[instance]\ntheorem ordConnected_singleton {α : Type*} [PartialOrder α] {a : α} :\n    OrdConnected ({a} : Set α) := by\n  rw [← Icc_self]\n  exact ordConnected_Icc\n\n"}
{"name":"Set.ordConnected_empty","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ EmptyCollection.emptyCollection.OrdConnected","decl":"@[instance]\ntheorem ordConnected_empty : OrdConnected (∅ : Set α) :=\n  ⟨fun _ => False.elim⟩\n\n"}
{"name":"Set.ordConnected_univ","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Set.univ.OrdConnected","decl":"@[instance]\ntheorem ordConnected_univ : OrdConnected (univ : Set α) :=\n  ⟨fun _ _ _ _ => subset_univ _⟩\n\n"}
{"name":"Set.instDenselyOrdered","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : DenselyOrdered α\ns : Set α\nhs : s.OrdConnected\n⊢ DenselyOrdered ↑s","decl":"/-- In a dense order `α`, the subtype from an `OrdConnected` set is also densely ordered. -/\ninstance instDenselyOrdered [DenselyOrdered α] {s : Set α} [hs : OrdConnected s] :\n    DenselyOrdered s :=\n  ⟨fun a b (h : (a : α) < b) =>\n    let ⟨x, H⟩ := exists_between h\n    ⟨⟨x, (hs.out a.2 b.2) (Ioo_subset_Icc_self H)⟩, H⟩⟩\n\n"}
{"name":"Set.ordConnected_preimage","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\nF : Type u_3\ninst✝¹ : FunLike F α β\ninst✝ : OrderHomClass F α β\nf : F\ns : Set β\nhs : s.OrdConnected\n⊢ (Set.preimage (⇑f) s).OrdConnected","decl":"@[instance]\ntheorem ordConnected_preimage {F : Type*} [FunLike F α β] [OrderHomClass F α β] (f : F)\n    {s : Set β} [hs : OrdConnected s] : OrdConnected (f ⁻¹' s) :=\n  ⟨fun _ hx _ hy _ hz => hs.out hx hy ⟨OrderHomClass.mono _ hz.1, OrderHomClass.mono _ hz.2⟩⟩\n\n"}
{"name":"Set.ordConnected_image","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\nE : Type u_3\ninst✝¹ : EquivLike E α β\ninst✝ : OrderIsoClass E α β\ne : E\ns : Set α\nhs : s.OrdConnected\n⊢ (Set.image (⇑e) s).OrdConnected","decl":"@[instance]\ntheorem ordConnected_image {E : Type*} [EquivLike E α β] [OrderIsoClass E α β] (e : E) {s : Set α}\n    [hs : OrdConnected s] : OrdConnected (e '' s) := by\n  erw [(e : α ≃o β).image_eq_preimage]\n  apply ordConnected_preimage (e : α ≃o β).symm\n\n-- Porting note: split up `simp_rw [← image_univ, OrdConnected_image e]`, would not work otherwise\n"}
{"name":"Set.ordConnected_range","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Preorder α\ninst✝² : Preorder β\nE : Type u_3\ninst✝¹ : EquivLike E α β\ninst✝ : OrderIsoClass E α β\ne : E\n⊢ (Set.range ⇑e).OrdConnected","decl":"@[instance]\ntheorem ordConnected_range {E : Type*} [EquivLike E α β] [OrderIsoClass E α β] (e : E) :\n    OrdConnected (range e) := by\n  simp_rw [← image_univ]\n  exact ordConnected_image (e : α ≃o β)\n\n"}
{"name":"Set.dual_ordConnected_iff","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : Preorder α\ns : Set α\n⊢ Iff (Set.preimage (⇑OrderDual.ofDual) s).OrdConnected s.OrdConnected","decl":"@[simp]\ntheorem dual_ordConnected_iff {s : Set α} : OrdConnected (ofDual ⁻¹' s) ↔ OrdConnected s := by\n  simp_rw [ordConnected_def, toDual.surjective.forall, dual_Icc, Subtype.forall']\n  exact forall_swap\n\n"}
{"name":"Set.dual_ordConnected","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : s.OrdConnected\n⊢ (Set.preimage (⇑OrderDual.ofDual) s).OrdConnected","decl":"@[instance]\ntheorem dual_ordConnected {s : Set α} [OrdConnected s] : OrdConnected (ofDual ⁻¹' s) :=\n  dual_ordConnected_iff.2 ‹_›\n\n"}
{"name":"IsAntichain.ordConnected","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\nhs : IsAntichain (fun x1 x2 => LE.le x1 x2) s\n⊢ s.OrdConnected","decl":"protected theorem _root_.IsAntichain.ordConnected (hs : IsAntichain (· ≤ ·) s) : s.OrdConnected :=\n  ⟨fun x hx y hy z hz => by\n    obtain rfl := hs.eq hx hy (hz.1.trans hz.2)\n    rw [Icc_self, mem_singleton_iff] at hz\n    rwa [hz]⟩\n\n"}
{"name":"Set.ordConnected_inter_Icc_of_subset","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\nx y : α\nh : HasSubset.Subset (Set.Ioo x y) s\n⊢ (Inter.inter s (Set.Icc x y)).OrdConnected","decl":"lemma ordConnected_inter_Icc_of_subset (h : Ioo x y ⊆ s) : OrdConnected (s ∩ Icc x y) :=\n  ordConnected_of_Ioo fun _u ⟨_, hu, _⟩ _v ⟨_, _, hv⟩ _ ↦\n    Ioo_subset_Ioo hu hv |>.trans <| subset_inter h Ioo_subset_Icc_self\n\n"}
{"name":"Set.ordConnected_inter_Icc_iff","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Iff (Inter.inter s (Set.Icc x y)).OrdConnected (HasSubset.Subset (Set.Ioo x y) s)","decl":"lemma ordConnected_inter_Icc_iff (hx : x ∈ s) (hy : y ∈ s) :\n    OrdConnected (s ∩ Icc x y) ↔ Ioo x y ⊆ s := by\n  refine ⟨fun h ↦ Ioo_subset_Icc_self.trans fun z hz ↦ ?_, ordConnected_inter_Icc_of_subset⟩\n  have hxy : x ≤ y := hz.1.trans hz.2\n  exact h.out ⟨hx, left_mem_Icc.2 hxy⟩ ⟨hy, right_mem_Icc.2 hxy⟩ hz |>.1\n\n"}
{"name":"Set.not_ordConnected_inter_Icc_iff","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Iff (Not (Inter.inter s (Set.Icc x y)).OrdConnected) (Exists fun z => And (Not (Membership.mem s z)) (Membership.mem (Set.Ioo x y) z))","decl":"lemma not_ordConnected_inter_Icc_iff (hx : x ∈ s) (hy : y ∈ s) :\n    ¬ OrdConnected (s ∩ Icc x y) ↔ ∃ z ∉ s, z ∈ Ioo x y := by\n  simp_rw [ordConnected_inter_Icc_iff hx hy, subset_def, not_forall, exists_prop, and_comm]\n\n"}
{"name":"Set.ordConnected_uIcc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ (Set.uIcc a b).OrdConnected","decl":"@[instance]\ntheorem ordConnected_uIcc {a b : α} : OrdConnected [[a, b]] :=\n  ordConnected_Icc\n\n"}
{"name":"Set.ordConnected_uIoc","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ (Set.uIoc a b).OrdConnected","decl":"@[instance]\ntheorem ordConnected_uIoc {a b : α} : OrdConnected (Ι a b) :=\n  ordConnected_Ioc\n\n"}
{"name":"Set.OrdConnected.uIcc_subset","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nhs : s.OrdConnected\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\n⊢ HasSubset.Subset (Set.uIcc x y) s","decl":"theorem OrdConnected.uIcc_subset (hs : OrdConnected s) ⦃x⦄ (hx : x ∈ s) ⦃y⦄ (hy : y ∈ s) :\n    [[x, y]] ⊆ s :=\n  hs.out (min_rec' (· ∈ s) hx hy) (max_rec' (· ∈ s) hx hy)\n\n"}
{"name":"Set.OrdConnected.uIoc_subset","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nhs : s.OrdConnected\nx : α\nhx : Membership.mem s x\ny : α\nhy : Membership.mem s y\n⊢ HasSubset.Subset (Set.uIoc x y) s","decl":"theorem OrdConnected.uIoc_subset (hs : OrdConnected s) ⦃x⦄ (hx : x ∈ s) ⦃y⦄ (hy : y ∈ s) :\n    Ι x y ⊆ s :=\n  Ioc_subset_Icc_self.trans <| hs.uIcc_subset hx hy\n\n"}
{"name":"Set.ordConnected_iff_uIcc_subset","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\n⊢ Iff s.OrdConnected (∀ ⦃x : α⦄, Membership.mem s x → ∀ ⦃y : α⦄, Membership.mem s y → HasSubset.Subset (Set.uIcc x y) s)","decl":"theorem ordConnected_iff_uIcc_subset :\n    OrdConnected s ↔ ∀ ⦃x⦄ (_ : x ∈ s) ⦃y⦄ (_ : y ∈ s), [[x, y]] ⊆ s :=\n  ⟨fun h => h.uIcc_subset, fun H => ⟨fun _ hx _ hy => Icc_subset_uIcc.trans <| H hx hy⟩⟩\n\n"}
{"name":"Set.ordConnected_of_uIcc_subset_left","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\nh : ∀ (y : α), Membership.mem s y → HasSubset.Subset (Set.uIcc x y) s\n⊢ s.OrdConnected","decl":"theorem ordConnected_of_uIcc_subset_left (h : ∀ y ∈ s, [[x, y]] ⊆ s) : OrdConnected s :=\n  ordConnected_iff_uIcc_subset.2 fun y hy z hz =>\n    calc\n      [[y, z]] ⊆ [[y, x]] ∪ [[x, z]] := uIcc_subset_uIcc_union_uIcc\n      _ = [[x, y]] ∪ [[x, z]] := by rw [uIcc_comm]\n      _ ⊆ s := union_subset (h y hy) (h z hz)\n\n"}
{"name":"Set.ordConnected_iff_uIcc_subset_left","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\nhx : Membership.mem s x\n⊢ Iff s.OrdConnected (∀ ⦃y : α⦄, Membership.mem s y → HasSubset.Subset (Set.uIcc x y) s)","decl":"theorem ordConnected_iff_uIcc_subset_left (hx : x ∈ s) :\n    OrdConnected s ↔ ∀ ⦃y⦄, y ∈ s → [[x, y]] ⊆ s :=\n  ⟨fun hs => hs.uIcc_subset hx, ordConnected_of_uIcc_subset_left⟩\n\n"}
{"name":"Set.ordConnected_iff_uIcc_subset_right","module":"Mathlib.Order.Interval.Set.OrdConnected","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\ns : Set α\nx : α\nhx : Membership.mem s x\n⊢ Iff s.OrdConnected (∀ ⦃y : α⦄, Membership.mem s y → HasSubset.Subset (Set.uIcc y x) s)","decl":"theorem ordConnected_iff_uIcc_subset_right (hx : x ∈ s) :\n    OrdConnected s ↔ ∀ ⦃y⦄, y ∈ s → [[y, x]] ⊆ s := by\n  simp_rw [ordConnected_iff_uIcc_subset_left hx, uIcc_comm]\n\n"}
