{"name":"ContMDiffWithinAt.mfderivWithin","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹âµ : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœÂ¹â´ : NormedAddCommGroup E\ninstâœÂ¹Â³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ¹Â² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹Â¹ : TopologicalSpace M\ninstâœÂ¹â° : ChartedSpace H M\nE' : Type u_5\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœâ· : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœâ¶ : TopologicalSpace M'\ninstâœâµ : ChartedSpace H' M'\nF : Type u_8\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nG : Type u_9\ninstâœÂ² : TopologicalSpace G\nJ : ModelWithCorners ğ•œ F G\nN : Type u_10\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ChartedSpace G N\nJs : IsManifold J n N\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nxâ‚€ : N\nf : N â†’ M â†’ M'\ng : N â†’ M\nt : Set N\nu : Set M\nhf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (SProd.sprod t u) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContMDiffWithinAt J I m g t xâ‚€\nhxâ‚€ : Membership.mem t xâ‚€\nhu : Set.MapsTo g t u\nhmn : LE.le (HAdd.hAdd m 1) n\nh'u : UniqueMDiffOn I u\nâŠ¢ ContMDiffWithinAt J (modelWithCornersSelf ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) E E')) m (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderivWithin I I' (f x) u (g x)) xâ‚€) t xâ‚€","decl":"/-- The function that sends `x` to the `y`-derivative of `f (x, y)` at `g (x)` is `C^m` at `xâ‚€`,\nwhere the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^n` at `(xâ‚€, g(xâ‚€))` for `n â‰¥ m + 1` and `g` is `C^m` at `xâ‚€`.\nWe have to insert a coordinate change from `xâ‚€` to `x` to make the derivative sensible.\nVersion within a set.\n-/\nprotected theorem ContMDiffWithinAt.mfderivWithin {xâ‚€ : N} {f : N â†’ M â†’ M'} {g : N â†’ M}\n    {t : Set N} {u : Set M}\n    (hf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (t Ã—Ë¢ u) (xâ‚€, g xâ‚€))\n    (hg : ContMDiffWithinAt J I m g t xâ‚€) (hxâ‚€ : xâ‚€ âˆˆ t)\n    (hu : MapsTo g t u) (hmn : m + 1 â‰¤ n) (h'u : UniqueMDiffOn I u) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffWithinAt J ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n      (inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderivWithin I I' (f x) u (g x)) xâ‚€) t xâ‚€ := by\n  have : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n  have : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n  have : IsManifold J 1 N := .of_le (le_trans le_add_self hmn)\n  have : IsManifold J m N := .of_le (le_trans le_self_add hmn)\n  -- first localize the result to a smaller set, to make sure everything happens in chart domains\n  let t' := t âˆ© g â»Â¹' ((extChartAt I (g xâ‚€)).source)\n  have ht't : t' âŠ† t := inter_subset_left\n  suffices ContMDiffWithinAt J ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n      (inTangentCoordinates I I' g (fun x â†¦ f x (g x))\n        (fun x â†¦ mfderivWithin I I' (f x) u (g x)) xâ‚€) t' xâ‚€ by\n    apply ContMDiffWithinAt.mono_of_mem_nhdsWithin this\n    apply inter_mem self_mem_nhdsWithin\n    exact hg.continuousWithinAt.preimage_mem_nhdsWithin (extChartAt_source_mem_nhds (g xâ‚€))\n  -- register a few basic facts that maps send suitable neighborhoods to suitable neighborhoods,\n  -- by continuity\n  have hxâ‚€gxâ‚€ : (xâ‚€, g xâ‚€) âˆˆ t Ã—Ë¢ u := by simp [hxâ‚€, hu hxâ‚€]\n  have h4f : ContinuousWithinAt (fun x => f x (g x)) t xâ‚€ := by\n    change ContinuousWithinAt ((Function.uncurry f) âˆ˜ (fun x â†¦ (x, g x))) t xâ‚€\n    refine ContinuousWithinAt.comp hf.continuousWithinAt ?_ (fun y hy â†¦ by simp [hy, hu hy])\n    exact (continuousWithinAt_id.prod hg.continuousWithinAt)\n  have h4f := h4f.preimage_mem_nhdsWithin (extChartAt_source_mem_nhds (I := I') (f xâ‚€ (g xâ‚€)))\n  have h3f := (contMDiffWithinAt_iff_contMDiffWithinAt_nhdsWithin (by simp)).mp\n    (hf.of_le <| (self_le_add_left 1 m).trans hmn)\n  simp only [Nat.cast_one, hxâ‚€gxâ‚€, insert_eq_of_mem] at h3f\n  have h2f : âˆ€á¶  xâ‚‚ in ğ“[t] xâ‚€, ContMDiffWithinAt I I' 1 (f xâ‚‚) u (g xâ‚‚) := by\n    have : MapsTo (fun x â†¦ (x, g x)) t (t Ã—Ë¢ u) := fun y hy â†¦ by simp [hy, hu hy]\n    filter_upwards [((continuousWithinAt_id.prod hg.continuousWithinAt)\n      |>.tendsto_nhdsWithin this).eventually h3f, self_mem_nhdsWithin] with x hx h'x\n    apply hx.comp (g x) (contMDiffWithinAt_const.prod_mk contMDiffWithinAt_id)\n    exact fun y hy â†¦ by simp [h'x, hy]\n  have h2g : g â»Â¹' (extChartAt I (g xâ‚€)).source âˆˆ ğ“[t] xâ‚€ :=\n    hg.continuousWithinAt.preimage_mem_nhdsWithin (extChartAt_source_mem_nhds (g xâ‚€))\n  -- key point: the derivative of `f` composed with extended charts, at the point `g x` read in the\n  -- chart, is `C^n` in the vector space sense. This follows from `ContDiffWithinAt.fderivWithin`,\n  -- which is the vector space analogue of the result we are proving.\n  have : ContDiffWithinAt ğ•œ m (fun x â†¦ fderivWithin ğ•œ\n        (extChartAt I' (f xâ‚€ (g xâ‚€)) âˆ˜ f ((extChartAt J xâ‚€).symm x) âˆ˜ (extChartAt I (g xâ‚€)).symm)\n        ((extChartAt I (g xâ‚€)).target âˆ© (extChartAt I (g xâ‚€)).symm â»Â¹' u)\n        (extChartAt I (g xâ‚€) (g ((extChartAt J xâ‚€).symm x))))\n      ((extChartAt J xâ‚€).symm â»Â¹' t' âˆ© range J) (extChartAt J xâ‚€ xâ‚€) := by\n    have hf' := hf.mono (prod_mono_left ht't)\n    have hg' := hg.mono (show t' âŠ† t from inter_subset_left)\n    rw [contMDiffWithinAt_iff] at hf' hg'\n    simp_rw [Function.comp_def, uncurry, extChartAt_prod, PartialEquiv.prod_coe_symm,\n      ModelWithCorners.range_prod] at hf' âŠ¢\n    apply ContDiffWithinAt.fderivWithin _ _ _ (show (m : WithTop â„•âˆ) + 1 â‰¤ n from mod_cast hmn )\n    Â· simp [hxâ‚€, t']\n    Â· apply inter_subset_left.trans\n      rw [preimage_subset_iff]\n      intro a ha\n      refine âŸ¨PartialEquiv.map_source _ (inter_subset_right ha :), ?_âŸ©\n      rw [mem_preimage, PartialEquiv.left_inv (extChartAt I (g xâ‚€))]\n      Â· exact hu (inter_subset_left ha)\n      Â· exact (inter_subset_right ha :)\n    Â· have : ((fun p â†¦ ((extChartAt J xâ‚€).symm p.1, (extChartAt I (g xâ‚€)).symm p.2)) â»Â¹' t' Ã—Ë¢ u\n            âˆ© range J Ã—Ë¢ (extChartAt I (g xâ‚€)).target)\n          âŠ† ((fun p â†¦ ((extChartAt J xâ‚€).symm p.1, (extChartAt I (g xâ‚€)).symm p.2)) â»Â¹' t' Ã—Ë¢ u\n            âˆ© range J Ã—Ë¢ range I) := by\n        apply inter_subset_inter_right\n        exact Set.prod_mono_right (extChartAt_target_subset_range (g xâ‚€))\n      convert hf'.2.mono this\n      Â· ext y; simp; tauto\n      Â· simp\n    Â· exact hg'.2\n    Â· exact UniqueMDiffOn.uniqueDiffOn_target_inter h'u (g xâ‚€)\n  -- reformulate the previous point as `C^n` in the manifold sense (but still for a map between\n  -- vector spaces)\n  have :\n    ContMDiffWithinAt J ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n      (fun x =>\n        fderivWithin ğ•œ (extChartAt I' (f xâ‚€ (g xâ‚€)) âˆ˜ f x âˆ˜ (extChartAt I (g xâ‚€)).symm)\n        ((extChartAt I (g xâ‚€)).target âˆ© (extChartAt I (g xâ‚€)).symm â»Â¹' u)\n          (extChartAt I (g xâ‚€) (g x))) t' xâ‚€ := by\n    simp_rw [contMDiffWithinAt_iff_source_of_mem_source (mem_chart_source G xâ‚€),\n      contMDiffWithinAt_iff_contDiffWithinAt, Function.comp_def] at this âŠ¢\n    exact this\n  -- finally, argue that the map we control in the previous point coincides locally with the map we\n  -- want to prove the regularity of, so regularity of the latter follows from regularity of the\n  -- former.\n  apply this.congr_of_eventuallyEq_of_mem _ (by simp [t', hxâ‚€])\n  apply nhdsWithin_mono _ ht't\n  filter_upwards [h2f, h4f, h2g, self_mem_nhdsWithin] with x hx h'x h2 hxt\n  have h1 : g x âˆˆ u := hu hxt\n  have h3 : UniqueMDiffWithinAt ğ“˜(ğ•œ, E)\n      ((extChartAt I (g xâ‚€)).target âˆ© (extChartAt I (g xâ‚€)).symm â»Â¹' u)\n      ((extChartAt I (g xâ‚€)) (g x)) := by\n    apply UniqueDiffWithinAt.uniqueMDiffWithinAt\n    apply UniqueMDiffOn.uniqueDiffOn_target_inter h'u\n    refine âŸ¨PartialEquiv.map_source _ h2, ?_âŸ©\n    rwa [mem_preimage, PartialEquiv.left_inv _ h2]\n  have A : mfderivWithin ğ“˜(ğ•œ, E) I ((extChartAt I (g xâ‚€)).symm)\n        (range I) ((extChartAt I (g xâ‚€)) (g x))\n      = mfderivWithin ğ“˜(ğ•œ, E) I ((extChartAt I (g xâ‚€)).symm)\n        ((extChartAt I (g xâ‚€)).target âˆ© (extChartAt I (g xâ‚€)).symm â»Â¹' u)\n        ((extChartAt I (g xâ‚€)) (g x)) := by\n    apply (MDifferentiableWithinAt.mfderivWithin_mono _ h3 _).symm\n    Â· apply mdifferentiableWithinAt_extChartAt_symm\n      exact PartialEquiv.map_source (extChartAt I (g xâ‚€)) h2\n    Â· exact inter_subset_left.trans (extChartAt_target_subset_range (g xâ‚€))\n  rw [inTangentCoordinates_eq_mfderiv_comp, A,\n    â† mfderivWithin_comp_of_eq, â† mfderiv_comp_mfderivWithin_of_eq]\n  Â· exact mfderivWithin_eq_fderivWithin\n  Â· exact mdifferentiableAt_extChartAt (by simpa using h'x)\n  Â· apply MDifferentiableWithinAt.comp (I' := I) (u := u) _ _ _ inter_subset_right\n    Â· convert hx.mdifferentiableWithinAt le_rfl\n      exact PartialEquiv.left_inv (extChartAt I (g xâ‚€)) h2\n    Â· apply (mdifferentiableWithinAt_extChartAt_symm _).mono\n      Â· exact inter_subset_left.trans (extChartAt_target_subset_range (g xâ‚€))\n      Â· exact PartialEquiv.map_source (extChartAt I (g xâ‚€)) h2\n  Â· exact h3\n  Â· simp only [Function.comp_def, PartialEquiv.left_inv (extChartAt I (g xâ‚€)) h2]\n  Â· exact hx.mdifferentiableWithinAt le_rfl\n  Â· apply (mdifferentiableWithinAt_extChartAt_symm _).mono\n    Â· exact inter_subset_left.trans (extChartAt_target_subset_range (g xâ‚€))\n    Â· exact PartialEquiv.map_source (extChartAt I (g xâ‚€)) h2\n  Â· exact inter_subset_right\n  Â· exact h3\n  Â· exact PartialEquiv.left_inv (extChartAt I (g xâ‚€)) h2\n  Â· simpa using h2\n  Â· simpa using h'x\n\n"}
{"name":"ContMDiffWithinAt.mfderivWithin_const","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nxâ‚€ : M\nf : M â†’ M'\nhf : ContMDiffWithinAt I I' n f s xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nhx : Membership.mem s xâ‚€\nhs : UniqueMDiffOn I s\nâŠ¢ ContMDiffWithinAt I (modelWithCornersSelf ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) E E')) m (inTangentCoordinates I I' id f (mfderivWithin I I' f s) xâ‚€) s xâ‚€","decl":"/-- The derivative `D_yf(y)` is `C^m` at `xâ‚€`, where the derivative is taken as a continuous\nlinear map. We have to assume that `f` is `C^n` at `xâ‚€` for some `n â‰¥ m + 1`.\nWe have to insert a coordinate change from `xâ‚€` to `x` to make the derivative sensible.\nThis is a special case of `ContMDiffWithinAt.mfderivWithin` where `f` does not contain any\nparameters and `g = id`.\n-/\ntheorem ContMDiffWithinAt.mfderivWithin_const {xâ‚€ : M} {f : M â†’ M'}\n    (hf : ContMDiffWithinAt I I' n f s xâ‚€)\n    (hmn : m + 1 â‰¤ n) (hx : xâ‚€ âˆˆ s) (hs : UniqueMDiffOn I s) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffWithinAt I ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n      (inTangentCoordinates I I' id f (mfderivWithin I I' f s) xâ‚€) s xâ‚€ := by\n  have : ContMDiffWithinAt (I.prod I) I' n (fun x : M Ã— M => f x.2) (s Ã—Ë¢ s) (xâ‚€, xâ‚€) :=\n    ContMDiffWithinAt.comp (xâ‚€, xâ‚€) hf contMDiffWithinAt_snd mapsTo_snd_prod\n  exact this.mfderivWithin contMDiffWithinAt_id hx (mapsTo_id _) hmn hs\n\n"}
{"name":"ContMDiffWithinAt.mfderivWithin_apply","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ²â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœÂ¹â¹ : NormedAddCommGroup E\ninstâœÂ¹â¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ¹â· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹â¶ : TopologicalSpace M\ninstâœÂ¹âµ : ChartedSpace H M\nE' : Type u_5\ninstâœÂ¹â´ : NormedAddCommGroup E'\ninstâœÂ¹Â³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ¹Â² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹Â¹ : TopologicalSpace M'\ninstâœÂ¹â° : ChartedSpace H' M'\nF : Type u_8\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nG : Type u_9\ninstâœâ· : TopologicalSpace G\nJ : ModelWithCorners ğ•œ F G\nN : Type u_10\ninstâœâ¶ : TopologicalSpace N\ninstâœâµ : ChartedSpace G N\nJs : IsManifold J n N\nF' : Type u_11\ninstâœâ´ : NormedAddCommGroup F'\ninstâœÂ³ : NormedSpace ğ•œ F'\nG' : Type u_12\ninstâœÂ² : TopologicalSpace G'\nJ' : ModelWithCorners ğ•œ F' G'\nN' : Type u_13\ninstâœÂ¹ : TopologicalSpace N'\ninstâœ : ChartedSpace G' N'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nxâ‚€ : N'\nf : N â†’ M â†’ M'\ng : N â†’ M\ngâ‚ : N' â†’ N\ngâ‚‚ : N' â†’ E\nt : Set N\nu : Set M\nv : Set N'\nhf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (SProd.sprod t u) { fst := gâ‚ xâ‚€, snd := g (gâ‚ xâ‚€) }\nhg : ContMDiffWithinAt J I m g t (gâ‚ xâ‚€)\nhgâ‚ : ContMDiffWithinAt J' J m gâ‚ v xâ‚€\nhgâ‚‚ : ContMDiffWithinAt J' (modelWithCornersSelf ğ•œ E) m gâ‚‚ v xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nh'gâ‚ : Set.MapsTo gâ‚ v t\nhgâ‚xâ‚€ : Membership.mem t (gâ‚ xâ‚€)\nh'g : Set.MapsTo g t u\nhu : UniqueMDiffOn I u\nâŠ¢ ContMDiffWithinAt J' (modelWithCornersSelf ğ•œ E') m (fun x => (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderivWithin I I' (f x) u (g x)) (gâ‚ xâ‚€) (gâ‚ x)) (gâ‚‚ x)) v xâ‚€","decl":"/-- The function that sends `x` to the `y`-derivative of `f(x,y)` at `g(x)` applied to `gâ‚‚(x)` is\n`C^n` at `xâ‚€`, where the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^(n+1)` at `(xâ‚€, g(xâ‚€))` and `g` is `C^n` at `xâ‚€`.\nWe have to insert a coordinate change from `xâ‚€` to `gâ‚(x)` to make the derivative sensible.\n\nThis is similar to `ContMDiffWithinAt.mfderivWithin`, but where the continuous linear map is\napplied to a (variable) vector.\n-/\ntheorem ContMDiffWithinAt.mfderivWithin_apply {xâ‚€ : N'}\n    {f : N â†’ M â†’ M'} {g : N â†’ M} {gâ‚ : N' â†’ N} {gâ‚‚ : N' â†’ E} {t : Set N} {u : Set M} {v : Set N'}\n    (hf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (t Ã—Ë¢ u) (gâ‚ xâ‚€, g (gâ‚ xâ‚€)))\n    (hg : ContMDiffWithinAt J I m g t (gâ‚ xâ‚€)) (hgâ‚ : ContMDiffWithinAt J' J m gâ‚ v xâ‚€)\n    (hgâ‚‚ : ContMDiffWithinAt J' ğ“˜(ğ•œ, E) m gâ‚‚ v xâ‚€) (hmn : m + 1 â‰¤ n) (h'gâ‚ : MapsTo gâ‚ v t)\n    (hgâ‚xâ‚€ : gâ‚ xâ‚€ âˆˆ t) (h'g : MapsTo g t u) (hu : UniqueMDiffOn I u) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffWithinAt J' ğ“˜(ğ•œ, E') m\n      (fun x => (inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderivWithin I I' (f x) u (g x)) (gâ‚ xâ‚€) (gâ‚ x)) (gâ‚‚ x)) v xâ‚€ :=\n  ((hf.mfderivWithin hg hgâ‚xâ‚€ h'g hmn hu).comp_of_eq hgâ‚ h'gâ‚ rfl).clm_apply hgâ‚‚\n\n"}
{"name":"ContMDiffAt.mfderiv","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹âµ : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœÂ¹â´ : NormedAddCommGroup E\ninstâœÂ¹Â³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ¹Â² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹Â¹ : TopologicalSpace M\ninstâœÂ¹â° : ChartedSpace H M\nE' : Type u_5\ninstâœâ¹ : NormedAddCommGroup E'\ninstâœâ¸ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœâ· : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœâ¶ : TopologicalSpace M'\ninstâœâµ : ChartedSpace H' M'\nF : Type u_8\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace ğ•œ F\nG : Type u_9\ninstâœÂ² : TopologicalSpace G\nJ : ModelWithCorners ğ•œ F G\nN : Type u_10\ninstâœÂ¹ : TopologicalSpace N\ninstâœ : ChartedSpace G N\nJs : IsManifold J n N\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nxâ‚€ : N\nf : N â†’ M â†’ M'\ng : N â†’ M\nhf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContMDiffAt J I m g xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContMDiffAt J (modelWithCornersSelf ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) E E')) m (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) xâ‚€) xâ‚€","decl":"/-- The function that sends `x` to the `y`-derivative of `f (x, y)` at `g (x)` is `C^m` at `xâ‚€`,\nwhere the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^n` at `(xâ‚€, g(xâ‚€))` for `n â‰¥ m + 1` and `g` is `C^m` at `xâ‚€`.\nWe have to insert a coordinate change from `xâ‚€` to `x` to make the derivative sensible.\nThis result is used to show that maps into the 1-jet bundle and cotangent bundle are `C^n`.\n`ContMDiffAt.mfderiv_const` is a special case of this.\n-/\nprotected theorem ContMDiffAt.mfderiv {xâ‚€ : N} (f : N â†’ M â†’ M') (g : N â†’ M)\n    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (xâ‚€, g xâ‚€)) (hg : ContMDiffAt J I m g xâ‚€)\n    (hmn : m + 1 â‰¤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffAt J ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n      (inTangentCoordinates I I' g (fun x â†¦ f x (g x)) (fun x â†¦ mfderiv I I' (f x) (g x)) xâ‚€)\n      xâ‚€ := by\n  rw [â† contMDiffWithinAt_univ] at hf hg âŠ¢\n  rw [â† univ_prod_univ] at hf\n  simp_rw [â† mfderivWithin_univ]\n  exact ContMDiffWithinAt.mfderivWithin hf hg (mem_univ _) (mapsTo_univ _ _) hmn\n    uniqueMDiffOn_univ\n\n"}
{"name":"ContMDiffAt.mfderiv_const","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nxâ‚€ : M\nf : M â†’ M'\nhf : ContMDiffAt I I' n f xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContMDiffAt I (modelWithCornersSelf ğ•œ (ContinuousLinearMap (RingHom.id ğ•œ) E E')) m (inTangentCoordinates I I' id f (mfderiv I I' f) xâ‚€) xâ‚€","decl":"/-- The derivative `D_yf(y)` is `C^m` at `xâ‚€`, where the derivative is taken as a continuous\nlinear map. We have to assume that `f` is `C^n` at `xâ‚€` for some `n â‰¥ m + 1`.\nWe have to insert a coordinate change from `xâ‚€` to `x` to make the derivative sensible.\nThis is a special case of `ContMDiffAt.mfderiv` where `f` does not contain any parameters and\n`g = id`.\n-/\ntheorem ContMDiffAt.mfderiv_const {xâ‚€ : M} {f : M â†’ M'} (hf : ContMDiffAt I I' n f xâ‚€)\n    (hmn : m + 1 â‰¤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffAt I ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m (inTangentCoordinates I I' id f (mfderiv I I' f) xâ‚€) xâ‚€ :=\n  haveI : ContMDiffAt (I.prod I) I' n (fun x : M Ã— M => f x.2) (xâ‚€, xâ‚€) :=\n    ContMDiffAt.comp (xâ‚€, xâ‚€) hf contMDiffAt_snd\n  this.mfderiv (fun _ => f) id contMDiffAt_id hmn\n\n"}
{"name":"ContMDiffAt.mfderiv_apply","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ²â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœÂ¹â¹ : NormedAddCommGroup E\ninstâœÂ¹â¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ¹â· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹â¶ : TopologicalSpace M\ninstâœÂ¹âµ : ChartedSpace H M\nE' : Type u_5\ninstâœÂ¹â´ : NormedAddCommGroup E'\ninstâœÂ¹Â³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ¹Â² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹Â¹ : TopologicalSpace M'\ninstâœÂ¹â° : ChartedSpace H' M'\nF : Type u_8\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nG : Type u_9\ninstâœâ· : TopologicalSpace G\nJ : ModelWithCorners ğ•œ F G\nN : Type u_10\ninstâœâ¶ : TopologicalSpace N\ninstâœâµ : ChartedSpace G N\nJs : IsManifold J n N\nF' : Type u_11\ninstâœâ´ : NormedAddCommGroup F'\ninstâœÂ³ : NormedSpace ğ•œ F'\nG' : Type u_12\ninstâœÂ² : TopologicalSpace G'\nJ' : ModelWithCorners ğ•œ F' G'\nN' : Type u_13\ninstâœÂ¹ : TopologicalSpace N'\ninstâœ : ChartedSpace G' N'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nxâ‚€ : N'\nf : N â†’ M â†’ M'\ng : N â†’ M\ngâ‚ : N' â†’ N\ngâ‚‚ : N' â†’ E\nhf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) { fst := gâ‚ xâ‚€, snd := g (gâ‚ xâ‚€) }\nhg : ContMDiffAt J I m g (gâ‚ xâ‚€)\nhgâ‚ : ContMDiffAt J' J m gâ‚ xâ‚€\nhgâ‚‚ : ContMDiffAt J' (modelWithCornersSelf ğ•œ E) m gâ‚‚ xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContMDiffAt J' (modelWithCornersSelf ğ•œ E') m (fun x => (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) (gâ‚ xâ‚€) (gâ‚ x)) (gâ‚‚ x)) xâ‚€","decl":"/-- The function that sends `x` to the `y`-derivative of `f(x,y)` at `g(x)` applied to `gâ‚‚(x)` is\n`C^n` at `xâ‚€`, where the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^(n+1)` at `(xâ‚€, g(xâ‚€))` and `g` is `C^n` at `xâ‚€`.\nWe have to insert a coordinate change from `xâ‚€` to `gâ‚(x)` to make the derivative sensible.\n\nThis is similar to `ContMDiffAt.mfderiv`, but where the continuous linear map is applied to a\n(variable) vector.\n-/\ntheorem ContMDiffAt.mfderiv_apply {xâ‚€ : N'} (f : N â†’ M â†’ M') (g : N â†’ M) (gâ‚ : N' â†’ N) (gâ‚‚ : N' â†’ E)\n    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (gâ‚ xâ‚€, g (gâ‚ xâ‚€)))\n    (hg : ContMDiffAt J I m g (gâ‚ xâ‚€)) (hgâ‚ : ContMDiffAt J' J m gâ‚ xâ‚€)\n    (hgâ‚‚ : ContMDiffAt J' ğ“˜(ğ•œ, E) m gâ‚‚ xâ‚€) (hmn : m + 1 â‰¤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffAt J' ğ“˜(ğ•œ, E') m\n      (fun x => inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderiv I I' (f x) (g x)) (gâ‚ xâ‚€) (gâ‚ x) (gâ‚‚ x)) xâ‚€ :=\n  ((hf.mfderiv f g hg hmn).comp_of_eq hgâ‚ rfl).clm_apply hgâ‚‚\n\n"}
{"name":"ContMDiffOn.contMDiffOn_tangentMapWithin","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le (HAdd.hAdd m 1) n\nhs : UniqueMDiffOn I s\nâŠ¢ ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative\nis `C^m` when `m+1 â‰¤ n`. -/\ntheorem ContMDiffOn.contMDiffOn_tangentMapWithin\n    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 â‰¤ n)\n    (hs : UniqueMDiffOn I s) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)\n      (Ï€ E (TangentSpace I) â»Â¹' s) := by\n  have : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n  have : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n  intro xâ‚€ hxâ‚€\n  let s' : Set (TangentBundle I M) := (Ï€ E (TangentSpace I) â»Â¹' s)\n  let bâ‚ : TangentBundle I M â†’ M := fun p â†¦ p.1\n  let v : Î  (y : TangentBundle I M), TangentSpace I (bâ‚ y) := fun y â†¦ y.2\n  have hv : ContMDiffWithinAt I.tangent I.tangent m (fun y â†¦ (v y : TangentBundle I M)) s' xâ‚€ :=\n    contMDiffWithinAt_id\n  let bâ‚‚ : TangentBundle I M â†’ M' := f âˆ˜ bâ‚\n  have hbâ‚‚ : ContMDiffWithinAt I.tangent I' m bâ‚‚ s' xâ‚€ :=\n    ((hf (bâ‚ xâ‚€) hxâ‚€).of_le (le_self_add.trans hmn)).comp _\n      (contMDiffWithinAt_proj (TangentSpace I)) (fun x h â†¦ h)\n  let Ï• : Î  (y : TangentBundle I M), TangentSpace I (bâ‚ y) â†’L[ğ•œ] TangentSpace I' (bâ‚‚ y) :=\n    fun y â†¦ mfderivWithin I I' f s (bâ‚ y)\n  have hÏ• : ContMDiffWithinAt I.tangent ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n      (fun y â†¦ ContinuousLinearMap.inCoordinates E (TangentSpace I (M := M)) E'\n        (TangentSpace I' (M := M')) (bâ‚ xâ‚€) (bâ‚ y) (bâ‚‚ xâ‚€) (bâ‚‚ y) (Ï• y))\n      s' xâ‚€ := by\n    have A : ContMDiffWithinAt I ğ“˜(ğ•œ, E â†’L[ğ•œ] E') m\n        (fun y â†¦ ContinuousLinearMap.inCoordinates E (TangentSpace I (M := M)) E'\n          (TangentSpace I' (M := M')) (bâ‚ xâ‚€) y (bâ‚‚ xâ‚€) (f y) (mfderivWithin I I' f s y))\n        s (bâ‚ xâ‚€) :=\n      ContMDiffWithinAt.mfderivWithin_const (hf _ hxâ‚€) hmn hxâ‚€ hs\n    exact A.comp _ (contMDiffWithinAt_proj (TangentSpace I)) (fun x h â†¦ h)\n  exact ContMDiffWithinAt.clm_apply_of_inCoordinates hÏ• hv hbâ‚‚\n\n"}
{"name":"ContMDiffOn.contMDiffOn_tangentMapWithin_aux","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le (HAdd.hAdd m 1) n\nhs : UniqueMDiffOn I s\nâŠ¢ ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"@[deprecated (since := \"2024-10-07\")]\nalias ContMDiffOn.contMDiffOn_tangentMapWithin_aux := ContMDiffOn.contMDiffOn_tangentMapWithin\n\n"}
{"name":"ContMDiffOn.continuousOn_tangentMapWithin_aux","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le (HAdd.hAdd m 1) n\nhs : UniqueMDiffOn I s\nâŠ¢ ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"@[deprecated (since := \"2024-10-07\")]\nalias ContMDiffOn.continuousOn_tangentMapWithin_aux := ContMDiffOn.contMDiffOn_tangentMapWithin\n\n"}
{"name":"ContMDiffOn.continuousOn_tangentMapWithin","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le 1 n\nhs : UniqueMDiffOn I s\nâŠ¢ ContinuousOn (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"/-- If a function is `C^n` on a domain with unique derivatives, with `1 â‰¤ n`, then its bundled\nderivative is continuous there. -/\ntheorem ContMDiffOn.continuousOn_tangentMapWithin (hf : ContMDiffOn I I' n f s) (hmn : 1 â‰¤ n)\n    (hs : UniqueMDiffOn I s) :\n    haveI : IsManifold I 1 M := .of_le hmn\n    haveI : IsManifold I' 1 M' := .of_le hmn\n    ContinuousOn (tangentMapWithin I I' f s) (Ï€ E (TangentSpace I) â»Â¹' s) := by\n  have : IsManifold I 1 M := .of_le hmn\n  have : IsManifold I' 1 M' := .of_le hmn\n  have :\n    ContMDiffOn I.tangent I'.tangent 0 (tangentMapWithin I I' f s) (Ï€ E (TangentSpace I) â»Â¹' s) :=\n    hf.contMDiffOn_tangentMapWithin hmn hs\n  exact this.continuousOn\n\n"}
{"name":"ContMDiff.contMDiff_tangentMap","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiff I I' n f\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContMDiff I.tangent I'.tangent m (tangentMap I I' f)","decl":"/-- If a function is `C^n`, then its bundled derivative is `C^m` when `m+1 â‰¤ n`. -/\ntheorem ContMDiff.contMDiff_tangentMap (hf : ContMDiff I I' n f) (hmn : m + 1 â‰¤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiff I.tangent I'.tangent m (tangentMap I I' f) := by\n  haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n  haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n  rw [â† contMDiffOn_univ] at hf âŠ¢\n  convert hf.contMDiffOn_tangentMapWithin hmn uniqueMDiffOn_univ\n  rw [tangentMapWithin_univ]\n\n"}
{"name":"ContMDiff.continuous_tangentMap","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiff I I' n f\nhmn : LE.le 1 n\nâŠ¢ Continuous (tangentMap I I' f)","decl":"/-- If a function is `C^n`, with `1 â‰¤ n`, then its bundled derivative is continuous. -/\ntheorem ContMDiff.continuous_tangentMap (hf : ContMDiff I I' n f) (hmn : 1 â‰¤ n) :\n    haveI : IsManifold I 1 M := .of_le hmn\n    haveI : IsManifold I' 1 M' := .of_le hmn\n    Continuous (tangentMap I I' f) := by\n  haveI : IsManifold I 1 M := .of_le hmn\n  haveI : IsManifold I' 1 M' := .of_le hmn\n  rw [â† contMDiffOn_univ] at hf\n  rw [continuous_iff_continuousOn_univ]\n  convert hf.continuousOn_tangentMapWithin hmn uniqueMDiffOn_univ\n  rw [tangentMapWithin_univ]\n\n"}
{"name":"Smooth.tangentMap","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nm n : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : M â†’ M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiff I I' n f\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContMDiff I.tangent I'.tangent m (tangentMap I I' f)","decl":"@[deprecated (since := \"2024-11-21\")] alias Smooth.tangentMap := ContMDiff.contMDiff_tangentMap\n\n"}
{"name":"TangentBundle.tangentMap_tangentBundle_pure","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœÂ² : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœÂ¹ : TopologicalSpace M\ninstâœ : ChartedSpace H M\nIs : IsManifold I 1 M\np : TangentBundle I M\nâŠ¢ Eq (tangentMap I I.tangent (Bundle.zeroSection E (TangentSpace I)) p) { proj := { proj := p.proj, snd := 0 }, snd := { fst := p.snd, snd := 0 } }","decl":"/-- The derivative of the zero section of the tangent bundle maps `âŸ¨x, vâŸ©` to `âŸ¨âŸ¨x, 0âŸ©, âŸ¨v, 0âŸ©âŸ©`.\n\nNote that, as currently framed, this is a statement in coordinates, thus reliant on the choice\nof the coordinate system we use on the tangent bundle.\n\nHowever, the result itself is coordinate-dependent only to the extent that the coordinates\ndetermine a splitting of the tangent bundle.  Moreover, there is a canonical splitting at each\npoint of the zero section (since there is a canonical horizontal space there, the tangent space\nto the zero section, in addition to the canonical vertical space which is the kernel of the\nderivative of the projection), and this canonical splitting is also the one that comes from the\ncoordinates on the tangent bundle in our definitions. So this statement is not as crazy as it\nmay seem.\n\nTODO define splittings of vector bundles; state this result invariantly. -/\ntheorem tangentMap_tangentBundle_pure [Is : IsManifold I 1 M]\n    (p : TangentBundle I M) :\n    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = âŸ¨âŸ¨p.proj, 0âŸ©, âŸ¨p.2, 0âŸ©âŸ© := by\n  rcases p with âŸ¨x, vâŸ©\n  have N : I.symm â»Â¹' (chartAt H x).target âˆˆ ğ“ (I ((chartAt H x) x)) := by\n    apply IsOpen.mem_nhds\n    Â· apply (PartialHomeomorph.open_target _).preimage I.continuous_invFun\n    Â· simp only [mfld_simps]\n  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=\n    haveI : ContMDiff I (I.prod ğ“˜(ğ•œ, E)) âŠ¤ (zeroSection E (TangentSpace I : M â†’ Type _)) :=\n      Bundle.contMDiff_zeroSection ğ•œ (TangentSpace I : M â†’ Type _)\n    this.mdifferentiableAt le_top\n  have B : fderivWithin ğ•œ (fun x' : E â†¦ (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v\n      = (v, 0) := by\n    rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]\n    Â· simp\n    Â· exact differentiableAt_id'\n    Â· exact differentiableAt_const _\n    Â· exact ModelWithCorners.uniqueDiffWithinAt_image I\n    Â· exact differentiableAt_id'.prod (differentiableAt_const _)\n  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,\n    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,\n    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]\n  rw [â† fderivWithin_inter N] at B\n  rw [â† fderivWithin_inter N, â† B]\n  congr 1\n  refine fderivWithin_congr (fun y hy => ?_) ?_\n  Â· simp only [mfld_simps] at hy\n    simp only [hy, Prod.mk.inj_iff, mfld_simps]\n  Â· simp only [Prod.mk.inj_iff, mfld_simps]\n\n"}
{"name":"ContMDiffMap.mdifferentiable'","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : ContMDiffMap I I' M M' n\nhn : LE.le 1 n\nâŠ¢ MDifferentiable I I' â‡‘f","decl":"protected theorem mdifferentiable' (f : C^nâŸ®I, M; I', M'âŸ¯) (hn : 1 â‰¤ n) : MDifferentiable I I' f :=\n  f.contMDiff.mdifferentiable hn\n\n"}
{"name":"ContMDiffMap.mdifferentiable","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : ContMDiffMap I I' M M' â†‘Top.top\nâŠ¢ MDifferentiable I I' â‡‘f","decl":"protected theorem mdifferentiable (f : C^âˆâŸ®I, M; I', M'âŸ¯) : MDifferentiable I I' f :=\n  f.contMDiff.mdifferentiable (mod_cast le_top)\n\n"}
{"name":"ContMDiffMap.mdifferentiableAt","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nH : Type u_3\ninstâœâ· : TopologicalSpace H\nI : ModelWithCorners ğ•œ E H\nM : Type u_4\ninstâœâ¶ : TopologicalSpace M\ninstâœâµ : ChartedSpace H M\nE' : Type u_5\ninstâœâ´ : NormedAddCommGroup E'\ninstâœÂ³ : NormedSpace ğ•œ E'\nH' : Type u_6\ninstâœÂ² : TopologicalSpace H'\nI' : ModelWithCorners ğ•œ E' H'\nM' : Type u_7\ninstâœÂ¹ : TopologicalSpace M'\ninstâœ : ChartedSpace H' M'\nf : ContMDiffMap I I' M M' â†‘Top.top\nx : M\nâŠ¢ MDifferentiableAt I I' (â‡‘f) x","decl":"protected theorem mdifferentiableAt (f : C^âˆâŸ®I, M; I', M'âŸ¯) {x} : MDifferentiableAt I I' f x :=\n  f.mdifferentiable x\n\n"}
