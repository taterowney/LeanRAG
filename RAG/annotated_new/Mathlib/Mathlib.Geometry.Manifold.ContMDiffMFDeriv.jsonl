{"name":"ContMDiffWithinAt.mfderivWithin","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁵ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝¹⁴ : NormedAddCommGroup E\ninst✝¹³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹¹ : TopologicalSpace M\ninst✝¹⁰ : ChartedSpace H M\nE' : Type u_5\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝⁷ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝⁶ : TopologicalSpace M'\ninst✝⁵ : ChartedSpace H' M'\nF : Type u_8\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nG : Type u_9\ninst✝² : TopologicalSpace G\nJ : ModelWithCorners 𝕜 F G\nN : Type u_10\ninst✝¹ : TopologicalSpace N\ninst✝ : ChartedSpace G N\nJs : IsManifold J n N\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nx₀ : N\nf : N → M → M'\ng : N → M\nt : Set N\nu : Set M\nhf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (SProd.sprod t u) { fst := x₀, snd := g x₀ }\nhg : ContMDiffWithinAt J I m g t x₀\nhx₀ : Membership.mem t x₀\nhu : Set.MapsTo g t u\nhmn : LE.le (HAdd.hAdd m 1) n\nh'u : UniqueMDiffOn I u\n⊢ ContMDiffWithinAt J (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) E E')) m (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderivWithin I I' (f x) u (g x)) x₀) t x₀","decl":"/-- The function that sends `x` to the `y`-derivative of `f (x, y)` at `g (x)` is `C^m` at `x₀`,\nwhere the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^n` at `(x₀, g(x₀))` for `n ≥ m + 1` and `g` is `C^m` at `x₀`.\nWe have to insert a coordinate change from `x₀` to `x` to make the derivative sensible.\nVersion within a set.\n-/\nprotected theorem ContMDiffWithinAt.mfderivWithin {x₀ : N} {f : N → M → M'} {g : N → M}\n    {t : Set N} {u : Set M}\n    (hf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (t ×ˢ u) (x₀, g x₀))\n    (hg : ContMDiffWithinAt J I m g t x₀) (hx₀ : x₀ ∈ t)\n    (hu : MapsTo g t u) (hmn : m + 1 ≤ n) (h'u : UniqueMDiffOn I u) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffWithinAt J 𝓘(𝕜, E →L[𝕜] E') m\n      (inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderivWithin I I' (f x) u (g x)) x₀) t x₀ := by\n  have : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n  have : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n  have : IsManifold J 1 N := .of_le (le_trans le_add_self hmn)\n  have : IsManifold J m N := .of_le (le_trans le_self_add hmn)\n  -- first localize the result to a smaller set, to make sure everything happens in chart domains\n  let t' := t ∩ g ⁻¹' ((extChartAt I (g x₀)).source)\n  have ht't : t' ⊆ t := inter_subset_left\n  suffices ContMDiffWithinAt J 𝓘(𝕜, E →L[𝕜] E') m\n      (inTangentCoordinates I I' g (fun x ↦ f x (g x))\n        (fun x ↦ mfderivWithin I I' (f x) u (g x)) x₀) t' x₀ by\n    apply ContMDiffWithinAt.mono_of_mem_nhdsWithin this\n    apply inter_mem self_mem_nhdsWithin\n    exact hg.continuousWithinAt.preimage_mem_nhdsWithin (extChartAt_source_mem_nhds (g x₀))\n  -- register a few basic facts that maps send suitable neighborhoods to suitable neighborhoods,\n  -- by continuity\n  have hx₀gx₀ : (x₀, g x₀) ∈ t ×ˢ u := by simp [hx₀, hu hx₀]\n  have h4f : ContinuousWithinAt (fun x => f x (g x)) t x₀ := by\n    change ContinuousWithinAt ((Function.uncurry f) ∘ (fun x ↦ (x, g x))) t x₀\n    refine ContinuousWithinAt.comp hf.continuousWithinAt ?_ (fun y hy ↦ by simp [hy, hu hy])\n    exact (continuousWithinAt_id.prod hg.continuousWithinAt)\n  have h4f := h4f.preimage_mem_nhdsWithin (extChartAt_source_mem_nhds (I := I') (f x₀ (g x₀)))\n  have h3f := (contMDiffWithinAt_iff_contMDiffWithinAt_nhdsWithin (by simp)).mp\n    (hf.of_le <| (self_le_add_left 1 m).trans hmn)\n  simp only [Nat.cast_one, hx₀gx₀, insert_eq_of_mem] at h3f\n  have h2f : ∀ᶠ x₂ in 𝓝[t] x₀, ContMDiffWithinAt I I' 1 (f x₂) u (g x₂) := by\n    have : MapsTo (fun x ↦ (x, g x)) t (t ×ˢ u) := fun y hy ↦ by simp [hy, hu hy]\n    filter_upwards [((continuousWithinAt_id.prod hg.continuousWithinAt)\n      |>.tendsto_nhdsWithin this).eventually h3f, self_mem_nhdsWithin] with x hx h'x\n    apply hx.comp (g x) (contMDiffWithinAt_const.prod_mk contMDiffWithinAt_id)\n    exact fun y hy ↦ by simp [h'x, hy]\n  have h2g : g ⁻¹' (extChartAt I (g x₀)).source ∈ 𝓝[t] x₀ :=\n    hg.continuousWithinAt.preimage_mem_nhdsWithin (extChartAt_source_mem_nhds (g x₀))\n  -- key point: the derivative of `f` composed with extended charts, at the point `g x` read in the\n  -- chart, is `C^n` in the vector space sense. This follows from `ContDiffWithinAt.fderivWithin`,\n  -- which is the vector space analogue of the result we are proving.\n  have : ContDiffWithinAt 𝕜 m (fun x ↦ fderivWithin 𝕜\n        (extChartAt I' (f x₀ (g x₀)) ∘ f ((extChartAt J x₀).symm x) ∘ (extChartAt I (g x₀)).symm)\n        ((extChartAt I (g x₀)).target ∩ (extChartAt I (g x₀)).symm ⁻¹' u)\n        (extChartAt I (g x₀) (g ((extChartAt J x₀).symm x))))\n      ((extChartAt J x₀).symm ⁻¹' t' ∩ range J) (extChartAt J x₀ x₀) := by\n    have hf' := hf.mono (prod_mono_left ht't)\n    have hg' := hg.mono (show t' ⊆ t from inter_subset_left)\n    rw [contMDiffWithinAt_iff] at hf' hg'\n    simp_rw [Function.comp_def, uncurry, extChartAt_prod, PartialEquiv.prod_coe_symm,\n      ModelWithCorners.range_prod] at hf' ⊢\n    apply ContDiffWithinAt.fderivWithin _ _ _ (show (m : WithTop ℕ∞) + 1 ≤ n from mod_cast hmn )\n    · simp [hx₀, t']\n    · apply inter_subset_left.trans\n      rw [preimage_subset_iff]\n      intro a ha\n      refine ⟨PartialEquiv.map_source _ (inter_subset_right ha :), ?_⟩\n      rw [mem_preimage, PartialEquiv.left_inv (extChartAt I (g x₀))]\n      · exact hu (inter_subset_left ha)\n      · exact (inter_subset_right ha :)\n    · have : ((fun p ↦ ((extChartAt J x₀).symm p.1, (extChartAt I (g x₀)).symm p.2)) ⁻¹' t' ×ˢ u\n            ∩ range J ×ˢ (extChartAt I (g x₀)).target)\n          ⊆ ((fun p ↦ ((extChartAt J x₀).symm p.1, (extChartAt I (g x₀)).symm p.2)) ⁻¹' t' ×ˢ u\n            ∩ range J ×ˢ range I) := by\n        apply inter_subset_inter_right\n        exact Set.prod_mono_right (extChartAt_target_subset_range (g x₀))\n      convert hf'.2.mono this\n      · ext y; simp; tauto\n      · simp\n    · exact hg'.2\n    · exact UniqueMDiffOn.uniqueDiffOn_target_inter h'u (g x₀)\n  -- reformulate the previous point as `C^n` in the manifold sense (but still for a map between\n  -- vector spaces)\n  have :\n    ContMDiffWithinAt J 𝓘(𝕜, E →L[𝕜] E') m\n      (fun x =>\n        fderivWithin 𝕜 (extChartAt I' (f x₀ (g x₀)) ∘ f x ∘ (extChartAt I (g x₀)).symm)\n        ((extChartAt I (g x₀)).target ∩ (extChartAt I (g x₀)).symm ⁻¹' u)\n          (extChartAt I (g x₀) (g x))) t' x₀ := by\n    simp_rw [contMDiffWithinAt_iff_source_of_mem_source (mem_chart_source G x₀),\n      contMDiffWithinAt_iff_contDiffWithinAt, Function.comp_def] at this ⊢\n    exact this\n  -- finally, argue that the map we control in the previous point coincides locally with the map we\n  -- want to prove the regularity of, so regularity of the latter follows from regularity of the\n  -- former.\n  apply this.congr_of_eventuallyEq_of_mem _ (by simp [t', hx₀])\n  apply nhdsWithin_mono _ ht't\n  filter_upwards [h2f, h4f, h2g, self_mem_nhdsWithin] with x hx h'x h2 hxt\n  have h1 : g x ∈ u := hu hxt\n  have h3 : UniqueMDiffWithinAt 𝓘(𝕜, E)\n      ((extChartAt I (g x₀)).target ∩ (extChartAt I (g x₀)).symm ⁻¹' u)\n      ((extChartAt I (g x₀)) (g x)) := by\n    apply UniqueDiffWithinAt.uniqueMDiffWithinAt\n    apply UniqueMDiffOn.uniqueDiffOn_target_inter h'u\n    refine ⟨PartialEquiv.map_source _ h2, ?_⟩\n    rwa [mem_preimage, PartialEquiv.left_inv _ h2]\n  have A : mfderivWithin 𝓘(𝕜, E) I ((extChartAt I (g x₀)).symm)\n        (range I) ((extChartAt I (g x₀)) (g x))\n      = mfderivWithin 𝓘(𝕜, E) I ((extChartAt I (g x₀)).symm)\n        ((extChartAt I (g x₀)).target ∩ (extChartAt I (g x₀)).symm ⁻¹' u)\n        ((extChartAt I (g x₀)) (g x)) := by\n    apply (MDifferentiableWithinAt.mfderivWithin_mono _ h3 _).symm\n    · apply mdifferentiableWithinAt_extChartAt_symm\n      exact PartialEquiv.map_source (extChartAt I (g x₀)) h2\n    · exact inter_subset_left.trans (extChartAt_target_subset_range (g x₀))\n  rw [inTangentCoordinates_eq_mfderiv_comp, A,\n    ← mfderivWithin_comp_of_eq, ← mfderiv_comp_mfderivWithin_of_eq]\n  · exact mfderivWithin_eq_fderivWithin\n  · exact mdifferentiableAt_extChartAt (by simpa using h'x)\n  · apply MDifferentiableWithinAt.comp (I' := I) (u := u) _ _ _ inter_subset_right\n    · convert hx.mdifferentiableWithinAt le_rfl\n      exact PartialEquiv.left_inv (extChartAt I (g x₀)) h2\n    · apply (mdifferentiableWithinAt_extChartAt_symm _).mono\n      · exact inter_subset_left.trans (extChartAt_target_subset_range (g x₀))\n      · exact PartialEquiv.map_source (extChartAt I (g x₀)) h2\n  · exact h3\n  · simp only [Function.comp_def, PartialEquiv.left_inv (extChartAt I (g x₀)) h2]\n  · exact hx.mdifferentiableWithinAt le_rfl\n  · apply (mdifferentiableWithinAt_extChartAt_symm _).mono\n    · exact inter_subset_left.trans (extChartAt_target_subset_range (g x₀))\n    · exact PartialEquiv.map_source (extChartAt I (g x₀)) h2\n  · exact inter_subset_right\n  · exact h3\n  · exact PartialEquiv.left_inv (extChartAt I (g x₀)) h2\n  · simpa using h2\n  · simpa using h'x\n\n"}
{"name":"ContMDiffWithinAt.mfderivWithin_const","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nx₀ : M\nf : M → M'\nhf : ContMDiffWithinAt I I' n f s x₀\nhmn : LE.le (HAdd.hAdd m 1) n\nhx : Membership.mem s x₀\nhs : UniqueMDiffOn I s\n⊢ ContMDiffWithinAt I (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) E E')) m (inTangentCoordinates I I' id f (mfderivWithin I I' f s) x₀) s x₀","decl":"/-- The derivative `D_yf(y)` is `C^m` at `x₀`, where the derivative is taken as a continuous\nlinear map. We have to assume that `f` is `C^n` at `x₀` for some `n ≥ m + 1`.\nWe have to insert a coordinate change from `x₀` to `x` to make the derivative sensible.\nThis is a special case of `ContMDiffWithinAt.mfderivWithin` where `f` does not contain any\nparameters and `g = id`.\n-/\ntheorem ContMDiffWithinAt.mfderivWithin_const {x₀ : M} {f : M → M'}\n    (hf : ContMDiffWithinAt I I' n f s x₀)\n    (hmn : m + 1 ≤ n) (hx : x₀ ∈ s) (hs : UniqueMDiffOn I s) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffWithinAt I 𝓘(𝕜, E →L[𝕜] E') m\n      (inTangentCoordinates I I' id f (mfderivWithin I I' f s) x₀) s x₀ := by\n  have : ContMDiffWithinAt (I.prod I) I' n (fun x : M × M => f x.2) (s ×ˢ s) (x₀, x₀) :=\n    ContMDiffWithinAt.comp (x₀, x₀) hf contMDiffWithinAt_snd mapsTo_snd_prod\n  exact this.mfderivWithin contMDiffWithinAt_id hx (mapsTo_id _) hmn hs\n\n"}
{"name":"ContMDiffWithinAt.mfderivWithin_apply","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝²⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝¹⁹ : NormedAddCommGroup E\ninst✝¹⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹⁶ : TopologicalSpace M\ninst✝¹⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝¹⁴ : NormedAddCommGroup E'\ninst✝¹³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝¹² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹¹ : TopologicalSpace M'\ninst✝¹⁰ : ChartedSpace H' M'\nF : Type u_8\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nG : Type u_9\ninst✝⁷ : TopologicalSpace G\nJ : ModelWithCorners 𝕜 F G\nN : Type u_10\ninst✝⁶ : TopologicalSpace N\ninst✝⁵ : ChartedSpace G N\nJs : IsManifold J n N\nF' : Type u_11\ninst✝⁴ : NormedAddCommGroup F'\ninst✝³ : NormedSpace 𝕜 F'\nG' : Type u_12\ninst✝² : TopologicalSpace G'\nJ' : ModelWithCorners 𝕜 F' G'\nN' : Type u_13\ninst✝¹ : TopologicalSpace N'\ninst✝ : ChartedSpace G' N'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nx₀ : N'\nf : N → M → M'\ng : N → M\ng₁ : N' → N\ng₂ : N' → E\nt : Set N\nu : Set M\nv : Set N'\nhf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (SProd.sprod t u) { fst := g₁ x₀, snd := g (g₁ x₀) }\nhg : ContMDiffWithinAt J I m g t (g₁ x₀)\nhg₁ : ContMDiffWithinAt J' J m g₁ v x₀\nhg₂ : ContMDiffWithinAt J' (modelWithCornersSelf 𝕜 E) m g₂ v x₀\nhmn : LE.le (HAdd.hAdd m 1) n\nh'g₁ : Set.MapsTo g₁ v t\nhg₁x₀ : Membership.mem t (g₁ x₀)\nh'g : Set.MapsTo g t u\nhu : UniqueMDiffOn I u\n⊢ ContMDiffWithinAt J' (modelWithCornersSelf 𝕜 E') m (fun x => (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderivWithin I I' (f x) u (g x)) (g₁ x₀) (g₁ x)) (g₂ x)) v x₀","decl":"/-- The function that sends `x` to the `y`-derivative of `f(x,y)` at `g(x)` applied to `g₂(x)` is\n`C^n` at `x₀`, where the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^(n+1)` at `(x₀, g(x₀))` and `g` is `C^n` at `x₀`.\nWe have to insert a coordinate change from `x₀` to `g₁(x)` to make the derivative sensible.\n\nThis is similar to `ContMDiffWithinAt.mfderivWithin`, but where the continuous linear map is\napplied to a (variable) vector.\n-/\ntheorem ContMDiffWithinAt.mfderivWithin_apply {x₀ : N'}\n    {f : N → M → M'} {g : N → M} {g₁ : N' → N} {g₂ : N' → E} {t : Set N} {u : Set M} {v : Set N'}\n    (hf : ContMDiffWithinAt (J.prod I) I' n (Function.uncurry f) (t ×ˢ u) (g₁ x₀, g (g₁ x₀)))\n    (hg : ContMDiffWithinAt J I m g t (g₁ x₀)) (hg₁ : ContMDiffWithinAt J' J m g₁ v x₀)\n    (hg₂ : ContMDiffWithinAt J' 𝓘(𝕜, E) m g₂ v x₀) (hmn : m + 1 ≤ n) (h'g₁ : MapsTo g₁ v t)\n    (hg₁x₀ : g₁ x₀ ∈ t) (h'g : MapsTo g t u) (hu : UniqueMDiffOn I u) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffWithinAt J' 𝓘(𝕜, E') m\n      (fun x => (inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderivWithin I I' (f x) u (g x)) (g₁ x₀) (g₁ x)) (g₂ x)) v x₀ :=\n  ((hf.mfderivWithin hg hg₁x₀ h'g hmn hu).comp_of_eq hg₁ h'g₁ rfl).clm_apply hg₂\n\n"}
{"name":"ContMDiffAt.mfderiv","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁵ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝¹⁴ : NormedAddCommGroup E\ninst✝¹³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹¹ : TopologicalSpace M\ninst✝¹⁰ : ChartedSpace H M\nE' : Type u_5\ninst✝⁹ : NormedAddCommGroup E'\ninst✝⁸ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝⁷ : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝⁶ : TopologicalSpace M'\ninst✝⁵ : ChartedSpace H' M'\nF : Type u_8\ninst✝⁴ : NormedAddCommGroup F\ninst✝³ : NormedSpace 𝕜 F\nG : Type u_9\ninst✝² : TopologicalSpace G\nJ : ModelWithCorners 𝕜 F G\nN : Type u_10\ninst✝¹ : TopologicalSpace N\ninst✝ : ChartedSpace G N\nJs : IsManifold J n N\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nx₀ : N\nf : N → M → M'\ng : N → M\nhf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) { fst := x₀, snd := g x₀ }\nhg : ContMDiffAt J I m g x₀\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContMDiffAt J (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) E E')) m (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) x₀) x₀","decl":"/-- The function that sends `x` to the `y`-derivative of `f (x, y)` at `g (x)` is `C^m` at `x₀`,\nwhere the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^n` at `(x₀, g(x₀))` for `n ≥ m + 1` and `g` is `C^m` at `x₀`.\nWe have to insert a coordinate change from `x₀` to `x` to make the derivative sensible.\nThis result is used to show that maps into the 1-jet bundle and cotangent bundle are `C^n`.\n`ContMDiffAt.mfderiv_const` is a special case of this.\n-/\nprotected theorem ContMDiffAt.mfderiv {x₀ : N} (f : N → M → M') (g : N → M)\n    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (x₀, g x₀)) (hg : ContMDiffAt J I m g x₀)\n    (hmn : m + 1 ≤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffAt J 𝓘(𝕜, E →L[𝕜] E') m\n      (inTangentCoordinates I I' g (fun x ↦ f x (g x)) (fun x ↦ mfderiv I I' (f x) (g x)) x₀)\n      x₀ := by\n  rw [← contMDiffWithinAt_univ] at hf hg ⊢\n  rw [← univ_prod_univ] at hf\n  simp_rw [← mfderivWithin_univ]\n  exact ContMDiffWithinAt.mfderivWithin hf hg (mem_univ _) (mapsTo_univ _ _) hmn\n    uniqueMDiffOn_univ\n\n"}
{"name":"ContMDiffAt.mfderiv_const","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nx₀ : M\nf : M → M'\nhf : ContMDiffAt I I' n f x₀\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContMDiffAt I (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) E E')) m (inTangentCoordinates I I' id f (mfderiv I I' f) x₀) x₀","decl":"/-- The derivative `D_yf(y)` is `C^m` at `x₀`, where the derivative is taken as a continuous\nlinear map. We have to assume that `f` is `C^n` at `x₀` for some `n ≥ m + 1`.\nWe have to insert a coordinate change from `x₀` to `x` to make the derivative sensible.\nThis is a special case of `ContMDiffAt.mfderiv` where `f` does not contain any parameters and\n`g = id`.\n-/\ntheorem ContMDiffAt.mfderiv_const {x₀ : M} {f : M → M'} (hf : ContMDiffAt I I' n f x₀)\n    (hmn : m + 1 ≤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffAt I 𝓘(𝕜, E →L[𝕜] E') m (inTangentCoordinates I I' id f (mfderiv I I' f) x₀) x₀ :=\n  haveI : ContMDiffAt (I.prod I) I' n (fun x : M × M => f x.2) (x₀, x₀) :=\n    ContMDiffAt.comp (x₀, x₀) hf contMDiffAt_snd\n  this.mfderiv (fun _ => f) id contMDiffAt_id hmn\n\n"}
{"name":"ContMDiffAt.mfderiv_apply","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝²⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝¹⁹ : NormedAddCommGroup E\ninst✝¹⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝¹⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹⁶ : TopologicalSpace M\ninst✝¹⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝¹⁴ : NormedAddCommGroup E'\ninst✝¹³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝¹² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹¹ : TopologicalSpace M'\ninst✝¹⁰ : ChartedSpace H' M'\nF : Type u_8\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nG : Type u_9\ninst✝⁷ : TopologicalSpace G\nJ : ModelWithCorners 𝕜 F G\nN : Type u_10\ninst✝⁶ : TopologicalSpace N\ninst✝⁵ : ChartedSpace G N\nJs : IsManifold J n N\nF' : Type u_11\ninst✝⁴ : NormedAddCommGroup F'\ninst✝³ : NormedSpace 𝕜 F'\nG' : Type u_12\ninst✝² : TopologicalSpace G'\nJ' : ModelWithCorners 𝕜 F' G'\nN' : Type u_13\ninst✝¹ : TopologicalSpace N'\ninst✝ : ChartedSpace G' N'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nx₀ : N'\nf : N → M → M'\ng : N → M\ng₁ : N' → N\ng₂ : N' → E\nhf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) { fst := g₁ x₀, snd := g (g₁ x₀) }\nhg : ContMDiffAt J I m g (g₁ x₀)\nhg₁ : ContMDiffAt J' J m g₁ x₀\nhg₂ : ContMDiffAt J' (modelWithCornersSelf 𝕜 E) m g₂ x₀\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContMDiffAt J' (modelWithCornersSelf 𝕜 E') m (fun x => (inTangentCoordinates I I' g (fun x => f x (g x)) (fun x => mfderiv I I' (f x) (g x)) (g₁ x₀) (g₁ x)) (g₂ x)) x₀","decl":"/-- The function that sends `x` to the `y`-derivative of `f(x,y)` at `g(x)` applied to `g₂(x)` is\n`C^n` at `x₀`, where the derivative is taken as a continuous linear map.\nWe have to assume that `f` is `C^(n+1)` at `(x₀, g(x₀))` and `g` is `C^n` at `x₀`.\nWe have to insert a coordinate change from `x₀` to `g₁(x)` to make the derivative sensible.\n\nThis is similar to `ContMDiffAt.mfderiv`, but where the continuous linear map is applied to a\n(variable) vector.\n-/\ntheorem ContMDiffAt.mfderiv_apply {x₀ : N'} (f : N → M → M') (g : N → M) (g₁ : N' → N) (g₂ : N' → E)\n    (hf : ContMDiffAt (J.prod I) I' n (Function.uncurry f) (g₁ x₀, g (g₁ x₀)))\n    (hg : ContMDiffAt J I m g (g₁ x₀)) (hg₁ : ContMDiffAt J' J m g₁ x₀)\n    (hg₂ : ContMDiffAt J' 𝓘(𝕜, E) m g₂ x₀) (hmn : m + 1 ≤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffAt J' 𝓘(𝕜, E') m\n      (fun x => inTangentCoordinates I I' g (fun x => f x (g x))\n        (fun x => mfderiv I I' (f x) (g x)) (g₁ x₀) (g₁ x) (g₂ x)) x₀ :=\n  ((hf.mfderiv f g hg hmn).comp_of_eq hg₁ rfl).clm_apply hg₂\n\n"}
{"name":"ContMDiffOn.contMDiffOn_tangentMapWithin","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le (HAdd.hAdd m 1) n\nhs : UniqueMDiffOn I s\n⊢ ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative\nis `C^m` when `m+1 ≤ n`. -/\ntheorem ContMDiffOn.contMDiffOn_tangentMapWithin\n    (hf : ContMDiffOn I I' n f s) (hmn : m + 1 ≤ n)\n    (hs : UniqueMDiffOn I s) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s)\n      (π E (TangentSpace I) ⁻¹' s) := by\n  have : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n  have : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n  intro x₀ hx₀\n  let s' : Set (TangentBundle I M) := (π E (TangentSpace I) ⁻¹' s)\n  let b₁ : TangentBundle I M → M := fun p ↦ p.1\n  let v : Π (y : TangentBundle I M), TangentSpace I (b₁ y) := fun y ↦ y.2\n  have hv : ContMDiffWithinAt I.tangent I.tangent m (fun y ↦ (v y : TangentBundle I M)) s' x₀ :=\n    contMDiffWithinAt_id\n  let b₂ : TangentBundle I M → M' := f ∘ b₁\n  have hb₂ : ContMDiffWithinAt I.tangent I' m b₂ s' x₀ :=\n    ((hf (b₁ x₀) hx₀).of_le (le_self_add.trans hmn)).comp _\n      (contMDiffWithinAt_proj (TangentSpace I)) (fun x h ↦ h)\n  let ϕ : Π (y : TangentBundle I M), TangentSpace I (b₁ y) →L[𝕜] TangentSpace I' (b₂ y) :=\n    fun y ↦ mfderivWithin I I' f s (b₁ y)\n  have hϕ : ContMDiffWithinAt I.tangent 𝓘(𝕜, E →L[𝕜] E') m\n      (fun y ↦ ContinuousLinearMap.inCoordinates E (TangentSpace I (M := M)) E'\n        (TangentSpace I' (M := M')) (b₁ x₀) (b₁ y) (b₂ x₀) (b₂ y) (ϕ y))\n      s' x₀ := by\n    have A : ContMDiffWithinAt I 𝓘(𝕜, E →L[𝕜] E') m\n        (fun y ↦ ContinuousLinearMap.inCoordinates E (TangentSpace I (M := M)) E'\n          (TangentSpace I' (M := M')) (b₁ x₀) y (b₂ x₀) (f y) (mfderivWithin I I' f s y))\n        s (b₁ x₀) :=\n      ContMDiffWithinAt.mfderivWithin_const (hf _ hx₀) hmn hx₀ hs\n    exact A.comp _ (contMDiffWithinAt_proj (TangentSpace I)) (fun x h ↦ h)\n  exact ContMDiffWithinAt.clm_apply_of_inCoordinates hϕ hv hb₂\n\n"}
{"name":"ContMDiffOn.contMDiffOn_tangentMapWithin_aux","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le (HAdd.hAdd m 1) n\nhs : UniqueMDiffOn I s\n⊢ ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"@[deprecated (since := \"2024-10-07\")]\nalias ContMDiffOn.contMDiffOn_tangentMapWithin_aux := ContMDiffOn.contMDiffOn_tangentMapWithin\n\n"}
{"name":"ContMDiffOn.continuousOn_tangentMapWithin_aux","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le (HAdd.hAdd m 1) n\nhs : UniqueMDiffOn I s\n⊢ ContMDiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"@[deprecated (since := \"2024-10-07\")]\nalias ContMDiffOn.continuousOn_tangentMapWithin_aux := ContMDiffOn.contMDiffOn_tangentMapWithin\n\n"}
{"name":"ContMDiffOn.continuousOn_tangentMapWithin","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\ns : Set M\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiffOn I I' n f s\nhmn : LE.le 1 n\nhs : UniqueMDiffOn I s\n⊢ ContinuousOn (tangentMapWithin I I' f s) (Set.preimage Bundle.TotalSpace.proj s)","decl":"/-- If a function is `C^n` on a domain with unique derivatives, with `1 ≤ n`, then its bundled\nderivative is continuous there. -/\ntheorem ContMDiffOn.continuousOn_tangentMapWithin (hf : ContMDiffOn I I' n f s) (hmn : 1 ≤ n)\n    (hs : UniqueMDiffOn I s) :\n    haveI : IsManifold I 1 M := .of_le hmn\n    haveI : IsManifold I' 1 M' := .of_le hmn\n    ContinuousOn (tangentMapWithin I I' f s) (π E (TangentSpace I) ⁻¹' s) := by\n  have : IsManifold I 1 M := .of_le hmn\n  have : IsManifold I' 1 M' := .of_le hmn\n  have :\n    ContMDiffOn I.tangent I'.tangent 0 (tangentMapWithin I I' f s) (π E (TangentSpace I) ⁻¹' s) :=\n    hf.contMDiffOn_tangentMapWithin hmn hs\n  exact this.continuousOn\n\n"}
{"name":"ContMDiff.contMDiff_tangentMap","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiff I I' n f\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContMDiff I.tangent I'.tangent m (tangentMap I I' f)","decl":"/-- If a function is `C^n`, then its bundled derivative is `C^m` when `m+1 ≤ n`. -/\ntheorem ContMDiff.contMDiff_tangentMap (hf : ContMDiff I I' n f) (hmn : m + 1 ≤ n) :\n    haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n    haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n    ContMDiff I.tangent I'.tangent m (tangentMap I I' f) := by\n  haveI : IsManifold I 1 M := .of_le (le_trans le_add_self hmn)\n  haveI : IsManifold I' 1 M' := .of_le (le_trans le_add_self hmn)\n  rw [← contMDiffOn_univ] at hf ⊢\n  convert hf.contMDiffOn_tangentMapWithin hmn uniqueMDiffOn_univ\n  rw [tangentMapWithin_univ]\n\n"}
{"name":"ContMDiff.continuous_tangentMap","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiff I I' n f\nhmn : LE.le 1 n\n⊢ Continuous (tangentMap I I' f)","decl":"/-- If a function is `C^n`, with `1 ≤ n`, then its bundled derivative is continuous. -/\ntheorem ContMDiff.continuous_tangentMap (hf : ContMDiff I I' n f) (hmn : 1 ≤ n) :\n    haveI : IsManifold I 1 M := .of_le hmn\n    haveI : IsManifold I' 1 M' := .of_le hmn\n    Continuous (tangentMap I I' f) := by\n  haveI : IsManifold I 1 M := .of_le hmn\n  haveI : IsManifold I' 1 M' := .of_le hmn\n  rw [← contMDiffOn_univ] at hf\n  rw [continuous_iff_continuousOn_univ]\n  convert hf.continuousOn_tangentMapWithin hmn uniqueMDiffOn_univ\n  rw [tangentMapWithin_univ]\n\n"}
{"name":"Smooth.tangentMap","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nm n : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : M → M'\nIs : IsManifold I n M\nI's : IsManifold I' n M'\nhf : ContMDiff I I' n f\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContMDiff I.tangent I'.tangent m (tangentMap I I' f)","decl":"@[deprecated (since := \"2024-11-21\")] alias Smooth.tangentMap := ContMDiff.contMDiff_tangentMap\n\n"}
{"name":"TangentBundle.tangentMap_tangentBundle_pure","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝² : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝¹ : TopologicalSpace M\ninst✝ : ChartedSpace H M\nIs : IsManifold I 1 M\np : TangentBundle I M\n⊢ Eq (tangentMap I I.tangent (Bundle.zeroSection E (TangentSpace I)) p) { proj := { proj := p.proj, snd := 0 }, snd := { fst := p.snd, snd := 0 } }","decl":"/-- The derivative of the zero section of the tangent bundle maps `⟨x, v⟩` to `⟨⟨x, 0⟩, ⟨v, 0⟩⟩`.\n\nNote that, as currently framed, this is a statement in coordinates, thus reliant on the choice\nof the coordinate system we use on the tangent bundle.\n\nHowever, the result itself is coordinate-dependent only to the extent that the coordinates\ndetermine a splitting of the tangent bundle.  Moreover, there is a canonical splitting at each\npoint of the zero section (since there is a canonical horizontal space there, the tangent space\nto the zero section, in addition to the canonical vertical space which is the kernel of the\nderivative of the projection), and this canonical splitting is also the one that comes from the\ncoordinates on the tangent bundle in our definitions. So this statement is not as crazy as it\nmay seem.\n\nTODO define splittings of vector bundles; state this result invariantly. -/\ntheorem tangentMap_tangentBundle_pure [Is : IsManifold I 1 M]\n    (p : TangentBundle I M) :\n    tangentMap I I.tangent (zeroSection E (TangentSpace I)) p = ⟨⟨p.proj, 0⟩, ⟨p.2, 0⟩⟩ := by\n  rcases p with ⟨x, v⟩\n  have N : I.symm ⁻¹' (chartAt H x).target ∈ 𝓝 (I ((chartAt H x) x)) := by\n    apply IsOpen.mem_nhds\n    · apply (PartialHomeomorph.open_target _).preimage I.continuous_invFun\n    · simp only [mfld_simps]\n  have A : MDifferentiableAt I I.tangent (fun x => @TotalSpace.mk M E (TangentSpace I) x 0) x :=\n    haveI : ContMDiff I (I.prod 𝓘(𝕜, E)) ⊤ (zeroSection E (TangentSpace I : M → Type _)) :=\n      Bundle.contMDiff_zeroSection 𝕜 (TangentSpace I : M → Type _)\n    this.mdifferentiableAt le_top\n  have B : fderivWithin 𝕜 (fun x' : E ↦ (x', (0 : E))) (Set.range I) (I ((chartAt H x) x)) v\n      = (v, 0) := by\n    rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]\n    · simp\n    · exact differentiableAt_id'\n    · exact differentiableAt_const _\n    · exact ModelWithCorners.uniqueDiffWithinAt_image I\n    · exact differentiableAt_id'.prod (differentiableAt_const _)\n  simp (config := { unfoldPartialApp := true }) only [Bundle.zeroSection, tangentMap, mfderiv, A,\n    if_pos, chartAt, FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply,\n    tangentBundleCore, Function.comp_def, ContinuousLinearMap.map_zero, mfld_simps]\n  rw [← fderivWithin_inter N] at B\n  rw [← fderivWithin_inter N, ← B]\n  congr 1\n  refine fderivWithin_congr (fun y hy => ?_) ?_\n  · simp only [mfld_simps] at hy\n    simp only [hy, Prod.mk.inj_iff, mfld_simps]\n  · simp only [Prod.mk.inj_iff, mfld_simps]\n\n"}
{"name":"ContMDiffMap.mdifferentiable'","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : ContMDiffMap I I' M M' n\nhn : LE.le 1 n\n⊢ MDifferentiable I I' ⇑f","decl":"protected theorem mdifferentiable' (f : C^n⟮I, M; I', M'⟯) (hn : 1 ≤ n) : MDifferentiable I I' f :=\n  f.contMDiff.mdifferentiable hn\n\n"}
{"name":"ContMDiffMap.mdifferentiable","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : ContMDiffMap I I' M M' ↑Top.top\n⊢ MDifferentiable I I' ⇑f","decl":"protected theorem mdifferentiable (f : C^∞⟮I, M; I', M'⟯) : MDifferentiable I I' f :=\n  f.contMDiff.mdifferentiable (mod_cast le_top)\n\n"}
{"name":"ContMDiffMap.mdifferentiableAt","module":"Mathlib.Geometry.Manifold.ContMDiffMFDeriv","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nH : Type u_3\ninst✝⁷ : TopologicalSpace H\nI : ModelWithCorners 𝕜 E H\nM : Type u_4\ninst✝⁶ : TopologicalSpace M\ninst✝⁵ : ChartedSpace H M\nE' : Type u_5\ninst✝⁴ : NormedAddCommGroup E'\ninst✝³ : NormedSpace 𝕜 E'\nH' : Type u_6\ninst✝² : TopologicalSpace H'\nI' : ModelWithCorners 𝕜 E' H'\nM' : Type u_7\ninst✝¹ : TopologicalSpace M'\ninst✝ : ChartedSpace H' M'\nf : ContMDiffMap I I' M M' ↑Top.top\nx : M\n⊢ MDifferentiableAt I I' (⇑f) x","decl":"protected theorem mdifferentiableAt (f : C^∞⟮I, M; I', M'⟯) {x} : MDifferentiableAt I I' f x :=\n  f.mdifferentiable x\n\n"}
