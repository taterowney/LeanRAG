{"name":"bernoulli'_def'","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq (bernoulli' n) (HSub.hSub 1 (Finset.univ.sum fun k => HMul.hMul (HDiv.hDiv (↑(n.choose ↑k)) (HAdd.hAdd (HSub.hSub ↑n ↑↑k) 1)) (bernoulli' ↑k)))","decl":"theorem bernoulli'_def' (n : ℕ) :\n    bernoulli' n = 1 - ∑ k : Fin n, n.choose k / (n - k + 1) * bernoulli' k :=\n  WellFounded.fix_eq _ _ _\n\n"}
{"name":"bernoulli'_def","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq (bernoulli' n) (HSub.hSub 1 ((Finset.range n).sum fun k => HMul.hMul (HDiv.hDiv (↑(n.choose k)) (HAdd.hAdd (HSub.hSub ↑n ↑k) 1)) (bernoulli' k)))","decl":"theorem bernoulli'_def (n : ℕ) :\n    bernoulli' n = 1 - ∑ k ∈ range n, n.choose k / (n - k + 1) * bernoulli' k := by\n  rw [bernoulli'_def', ← Fin.sum_univ_eq_sum_range]\n\n"}
{"name":"bernoulli'_spec","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n.succ).sum fun k => HMul.hMul (HDiv.hDiv (↑(n.choose (HSub.hSub n k))) (HAdd.hAdd (HSub.hSub ↑n ↑k) 1)) (bernoulli' k)) 1","decl":"theorem bernoulli'_spec (n : ℕ) :\n    (∑ k ∈ range n.succ, (n.choose (n - k) : ℚ) / (n - k + 1) * bernoulli' k) = 1 := by\n  rw [sum_range_succ_comm, bernoulli'_def n, tsub_self, choose_zero_right, sub_self, zero_add,\n    div_one, cast_one, one_mul, sub_add, ← sum_sub_distrib, ← sub_eq_zero, sub_sub_cancel_left,\n    neg_eq_zero]\n  exact Finset.sum_eq_zero (fun x hx => by rw [choose_symm (le_of_lt (mem_range.1 hx)), sub_self])\n\n"}
{"name":"bernoulli'_spec'","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (HDiv.hDiv (↑((HAdd.hAdd k.1 k.2).choose k.2)) (HAdd.hAdd (↑k.2) 1)) (bernoulli' k.1)) 1","decl":"theorem bernoulli'_spec' (n : ℕ) :\n    (∑ k ∈ antidiagonal n, ((k.1 + k.2).choose k.2 : ℚ) / (k.2 + 1) * bernoulli' k.1) = 1 := by\n  refine ((sum_antidiagonal_eq_sum_range_succ_mk _ n).trans ?_).trans (bernoulli'_spec n)\n  refine sum_congr rfl fun x hx => ?_\n  simp only [add_tsub_cancel_of_le, mem_range_succ_iff.mp hx, cast_sub]\n\n"}
{"name":"bernoulli'_zero","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli' 0) 1","decl":"@[simp]\ntheorem bernoulli'_zero : bernoulli' 0 = 1 := by\n  rw [bernoulli'_def]\n  norm_num\n\n"}
{"name":"bernoulli'_one","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli' 1) (1 / 2)","decl":"@[simp]\ntheorem bernoulli'_one : bernoulli' 1 = 1 / 2 := by\n  rw [bernoulli'_def]\n  norm_num\n\n"}
{"name":"bernoulli'_two","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli' 2) (1 / 6)","decl":"@[simp]\ntheorem bernoulli'_two : bernoulli' 2 = 1 / 6 := by\n  rw [bernoulli'_def]\n  norm_num [sum_range_succ, sum_range_succ, sum_range_zero]\n\n"}
{"name":"bernoulli'_three","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli' 3) 0","decl":"@[simp]\ntheorem bernoulli'_three : bernoulli' 3 = 0 := by\n  rw [bernoulli'_def]\n  norm_num [sum_range_succ, sum_range_succ, sum_range_zero]\n\n"}
{"name":"bernoulli'_four","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli' 4) (-1 / 30)","decl":"@[simp]\ntheorem bernoulli'_four : bernoulli' 4 = -1 / 30 := by\n  have : Nat.choose 4 2 = 6 := by decide -- shrug\n  rw [bernoulli'_def]\n  norm_num [sum_range_succ, sum_range_succ, sum_range_zero, this]\n\n"}
{"name":"sum_bernoulli'","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n).sum fun k => HMul.hMul (↑(n.choose k)) (bernoulli' k)) ↑n","decl":"@[simp]\ntheorem sum_bernoulli' (n : ℕ) : (∑ k ∈ range n, (n.choose k : ℚ) * bernoulli' k) = n := by\n  cases' n with n\n  · simp\n  suffices\n    ((n + 1 : ℚ) * ∑ k ∈ range n, ↑(n.choose k) / (n - k + 1) * bernoulli' k) =\n      ∑ x ∈ range n, ↑(n.succ.choose x) * bernoulli' x by\n    rw_mod_cast [sum_range_succ, bernoulli'_def, ← this, choose_succ_self_right]\n    ring\n  simp_rw [mul_sum, ← mul_assoc]\n  refine sum_congr rfl fun k hk => ?_\n  congr\n  have : ((n - k : ℕ) : ℚ) + 1 ≠ 0 := by norm_cast\n  field_simp [← cast_sub (mem_range.1 hk).le, mul_comm]\n  rw_mod_cast [tsub_add_eq_add_tsub (mem_range.1 hk).le, choose_mul_succ_eq]\n\n"}
{"name":"bernoulli'PowerSeries_mul_exp_sub_one","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\n⊢ Eq (HMul.hMul (bernoulli'PowerSeries A) (HSub.hSub (PowerSeries.exp A) 1)) (HMul.hMul PowerSeries.X (PowerSeries.exp A))","decl":"theorem bernoulli'PowerSeries_mul_exp_sub_one :\n    bernoulli'PowerSeries A * (exp A - 1) = X * exp A := by\n  ext n\n  -- constant coefficient is a special case\n  cases' n with n\n  · simp\n  rw [bernoulli'PowerSeries, coeff_mul, mul_comm X, sum_antidiagonal_succ']\n  suffices (∑ p ∈ antidiagonal n,\n      bernoulli' p.1 / p.1! * ((p.2 + 1) * p.2! : ℚ)⁻¹) = (n ! : ℚ)⁻¹ by\n    simpa [map_sum, Nat.factorial] using congr_arg (algebraMap ℚ A) this\n  apply eq_inv_of_mul_eq_one_left\n  rw [sum_mul]\n  convert bernoulli'_spec' n using 1\n  apply sum_congr rfl\n  simp_rw [mem_antidiagonal]\n  rintro ⟨i, j⟩ rfl\n  have := factorial_mul_factorial_dvd_factorial_add i j\n  field_simp [mul_comm _ (bernoulli' i), mul_assoc, add_choose]\n  norm_cast\n  simp [mul_comm (j + 1)]\n\n"}
{"name":"bernoulli'_odd_eq_zero","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\nh_odd : Odd n\nhlt : LT.lt 1 n\n⊢ Eq (bernoulli' n) 0","decl":"/-- Odd Bernoulli numbers (greater than 1) are zero. -/\ntheorem bernoulli'_odd_eq_zero {n : ℕ} (h_odd : Odd n) (hlt : 1 < n) : bernoulli' n = 0 := by\n  let B := mk fun n => bernoulli' n / (n ! : ℚ)\n  suffices (B - evalNegHom B) * (exp ℚ - 1) = X * (exp ℚ - 1) by\n    cases' mul_eq_mul_right_iff.mp this with h h <;>\n      simp only [PowerSeries.ext_iff, evalNegHom, coeff_X] at h\n    · apply eq_zero_of_neg_eq\n      specialize h n\n      split_ifs at h <;> simp_all [B, h_odd.neg_one_pow, factorial_ne_zero]\n    · simpa +decide [Nat.factorial] using h 1\n  have h : B * (exp ℚ - 1) = X * exp ℚ := by\n    simpa [bernoulli'PowerSeries] using bernoulli'PowerSeries_mul_exp_sub_one ℚ\n  rw [sub_mul, h, mul_sub X, sub_right_inj, ← neg_sub, mul_neg, neg_eq_iff_eq_neg]\n  suffices evalNegHom (B * (exp ℚ - 1)) * exp ℚ = evalNegHom (X * exp ℚ) * exp ℚ by\n    rw [map_mul, map_mul] at this -- Porting note: Why doesn't simp do this?\n    simpa [mul_assoc, sub_mul, mul_comm (evalNegHom (exp ℚ)), exp_mul_exp_neg_eq_one]\n  congr\n\n"}
{"name":"bernoulli'_eq_bernoulli","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq (bernoulli' n) (HMul.hMul (HPow.hPow (-1) n) (bernoulli n))","decl":"theorem bernoulli'_eq_bernoulli (n : ℕ) : bernoulli' n = (-1) ^ n * bernoulli n := by\n  simp [bernoulli, ← mul_assoc, ← sq, ← pow_mul, mul_comm n 2]\n\n"}
{"name":"bernoulli_zero","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli 0) 1","decl":"@[simp]\ntheorem bernoulli_zero : bernoulli 0 = 1 := by simp [bernoulli]\n\n"}
{"name":"bernoulli_one","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"⊢ Eq (bernoulli 1) (-1 / 2)","decl":"@[simp]\ntheorem bernoulli_one : bernoulli 1 = -1 / 2 := by norm_num [bernoulli]\n\n"}
{"name":"bernoulli_eq_bernoulli'_of_ne_one","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\nhn : Ne n 1\n⊢ Eq (bernoulli n) (bernoulli' n)","decl":"theorem bernoulli_eq_bernoulli'_of_ne_one {n : ℕ} (hn : n ≠ 1) : bernoulli n = bernoulli' n := by\n  by_cases h0 : n = 0; · simp [h0]\n  rw [bernoulli, neg_one_pow_eq_pow_mod_two]\n  cases' mod_two_eq_zero_or_one n with h h\n  · simp [h]\n  · simp [bernoulli'_odd_eq_zero (odd_iff.mpr h) (one_lt_iff_ne_zero_and_ne_one.mpr ⟨h0, hn⟩)]\n\n"}
{"name":"sum_bernoulli","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq ((Finset.range n).sum fun k => HMul.hMul (↑(n.choose k)) (bernoulli k)) (ite (Eq n 1) 1 0)","decl":"@[simp]\ntheorem sum_bernoulli (n : ℕ) :\n    (∑ k ∈ range n, (n.choose k : ℚ) * bernoulli k) = if n = 1 then 1 else 0 := by\n  cases' n with n\n  · simp\n  cases' n with n\n  · rw [sum_range_one]\n    simp\n  suffices (∑ i ∈ range n, ↑((n + 2).choose (i + 2)) * bernoulli (i + 2)) = n / 2 by\n    simp only [this, sum_range_succ', cast_succ, bernoulli_one, bernoulli_zero, choose_one_right,\n      mul_one, choose_zero_right, cast_zero, if_false, zero_add, succ_succ_ne_one]\n    ring\n  have f := sum_bernoulli' n.succ.succ\n  simp_rw [sum_range_succ', cast_succ, ← eq_sub_iff_add_eq] at f\n  -- Porting note: was `convert f`\n  refine Eq.trans ?_ (Eq.trans f ?_)\n  · congr\n    funext x\n    rw [bernoulli_eq_bernoulli'_of_ne_one (succ_ne_zero x ∘ succ.inj)]\n  · simp only [one_div, mul_one, bernoulli'_zero, cast_one, choose_zero_right, add_sub_cancel_right,\n      zero_add, choose_one_right, cast_succ, cast_add, cast_one, bernoulli'_one, one_div]\n    ring\n\n"}
{"name":"bernoulli_spec'","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n : Nat\n⊢ Eq ((Finset.HasAntidiagonal.antidiagonal n).sum fun k => HMul.hMul (HDiv.hDiv (↑((HAdd.hAdd k.1 k.2).choose k.2)) (HAdd.hAdd (↑k.2) 1)) (bernoulli k.1)) (ite (Eq n 0) 1 0)","decl":"theorem bernoulli_spec' (n : ℕ) :\n    (∑ k ∈ antidiagonal n, ((k.1 + k.2).choose k.2 : ℚ) / (k.2 + 1) * bernoulli k.1) =\n      if n = 0 then 1 else 0 := by\n  cases' n with n\n  · simp\n  rw [if_neg (succ_ne_zero _)]\n  -- algebra facts\n  have h₁ : (1, n) ∈ antidiagonal n.succ := by simp [mem_antidiagonal, add_comm]\n  have h₂ : (n : ℚ) + 1 ≠ 0 := by norm_cast\n  have h₃ : (1 + n).choose n = n + 1 := by simp [add_comm]\n  -- key equation: the corresponding fact for `bernoulli'`\n  have H := bernoulli'_spec' n.succ\n  -- massage it to match the structure of the goal, then convert piece by piece\n  rw [sum_eq_add_sum_diff_singleton h₁] at H ⊢\n  apply add_eq_of_eq_sub'\n  convert eq_sub_of_add_eq' H using 1\n  · refine sum_congr rfl fun p h => ?_\n    obtain ⟨h', h''⟩ : p ∈ _ ∧ p ≠ _ := by rwa [mem_sdiff, mem_singleton] at h\n    simp [bernoulli_eq_bernoulli'_of_ne_one ((not_congr (antidiagonal_congr h' h₁)).mp h'')]\n  · field_simp [h₃]\n    norm_num\n\n"}
{"name":"bernoulliPowerSeries_mul_exp_sub_one","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"A : Type u_1\ninst✝¹ : CommRing A\ninst✝ : Algebra Rat A\n⊢ Eq (HMul.hMul (bernoulliPowerSeries A) (HSub.hSub (PowerSeries.exp A) 1)) PowerSeries.X","decl":"theorem bernoulliPowerSeries_mul_exp_sub_one : bernoulliPowerSeries A * (exp A - 1) = X := by\n  ext n\n  -- constant coefficient is a special case\n  cases' n with n\n  · simp\n  simp only [bernoulliPowerSeries, coeff_mul, coeff_X, sum_antidiagonal_succ', one_div, coeff_mk,\n    coeff_one, coeff_exp, LinearMap.map_sub, factorial, if_pos, cast_succ, cast_one, cast_mul,\n    sub_zero, RingHom.map_one, add_eq_zero, if_false, _root_.inv_one, zero_add, one_ne_zero,\n    mul_zero, and_false, sub_self, ← RingHom.map_mul, ← map_sum]\n  cases' n with n\n  · simp\n  rw [if_neg n.succ_succ_ne_one]\n  have hfact : ∀ m, (m ! : ℚ) ≠ 0 := fun m => mod_cast factorial_ne_zero m\n  have hite2 : ite (n.succ = 0) 1 0 = (0 : ℚ) := if_neg n.succ_ne_zero\n  simp only [CharP.cast_eq_zero, zero_add, inv_one, map_one, sub_self, mul_zero, add_eq]\n  rw [← map_zero (algebraMap ℚ A), ← zero_div (n.succ ! : ℚ), ← hite2, ← bernoulli_spec', sum_div]\n  refine congr_arg (algebraMap ℚ A) (sum_congr rfl fun x h => eq_div_of_mul_eq (hfact n.succ) ?_)\n  rw [mem_antidiagonal] at h\n  rw [← h, add_choose, cast_div_charZero (factorial_mul_factorial_dvd_factorial_add _ _)]\n  field_simp [hfact x.1, mul_comm _ (bernoulli x.1), mul_assoc]\n  left; left; ring\n\n"}
{"name":"sum_range_pow","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n p : Nat\n⊢ Eq ((Finset.range n).sum fun k => HPow.hPow (↑k) p) ((Finset.range (HAdd.hAdd p 1)).sum fun i => HDiv.hDiv (HMul.hMul (HMul.hMul (bernoulli i) ↑((HAdd.hAdd p 1).choose i)) (HPow.hPow (↑n) (HSub.hSub (HAdd.hAdd p 1) i))) (HAdd.hAdd (↑p) 1))","decl":"/-- **Faulhaber's theorem** relating the **sum of p-th powers** to the Bernoulli numbers:\n$$\\sum_{k=0}^{n-1} k^p = \\sum_{i=0}^p B_i\\binom{p+1}{i}\\frac{n^{p+1-i}}{p+1}.$$\nSee https://proofwiki.org/wiki/Faulhaber%27s_Formula and [orosi2018faulhaber] for\nthe proof provided here. -/\ntheorem sum_range_pow (n p : ℕ) :\n    (∑ k ∈ range n, (k : ℚ) ^ p) =\n      ∑ i ∈ range (p + 1), bernoulli i * ((p + 1).choose i) * (n : ℚ) ^ (p + 1 - i) / (p + 1) := by\n  have hne : ∀ m : ℕ, (m ! : ℚ) ≠ 0 := fun m => mod_cast factorial_ne_zero m\n  -- compute the Cauchy product of two power series\n  have h_cauchy :\n    ((mk fun p => bernoulli p / p !) * mk fun q => coeff ℚ (q + 1) (exp ℚ ^ n)) =\n      mk fun p => ∑ i ∈ range (p + 1),\n          bernoulli i * (p + 1).choose i * (n : ℚ) ^ (p + 1 - i) / (p + 1)! := by\n    ext q : 1\n    let f a b := bernoulli a / a ! * coeff ℚ (b + 1) (exp ℚ ^ n)\n    -- key step: use `PowerSeries.coeff_mul` and then rewrite sums\n    simp only [f, coeff_mul, coeff_mk, cast_mul, sum_antidiagonal_eq_sum_range_succ f]\n    apply sum_congr rfl\n    intros m h\n    simp only [f, exp_pow_eq_rescale_exp, rescale, one_div, coeff_mk, RingHom.coe_mk, coeff_exp,\n      RingHom.id_apply, cast_mul, Algebra.id.map_eq_id]\n    -- manipulate factorials and binomial coefficients\n    simp? at h says simp only [succ_eq_add_one, mem_range, f] at h\n    rw [choose_eq_factorial_div_factorial h.le, eq_comm, div_eq_iff (hne q.succ), succ_eq_add_one,\n      mul_assoc _ _ (q.succ ! : ℚ), mul_comm _ (q.succ ! : ℚ), ← mul_assoc, div_mul_eq_mul_div]\n    simp only [add_eq, add_zero, IsUnit.mul_iff, Nat.isUnit_iff, succ.injEq, cast_mul,\n      cast_succ, MonoidHom.coe_mk, OneHom.coe_mk, coeff_exp, Algebra.id.map_eq_id, one_div,\n      map_inv₀, map_natCast, coeff_mk, mul_inv_rev]\n    rw [mul_comm ((n : ℚ) ^ (q - m + 1)), ← mul_assoc _ _ ((n : ℚ) ^ (q - m + 1)), ← one_div,\n      mul_one_div, div_div, tsub_add_eq_add_tsub (le_of_lt_succ h), cast_div, cast_mul]\n    · ring\n    · exact factorial_mul_factorial_dvd_factorial h.le\n    · simp [hne, factorial_ne_zero]\n  -- same as our goal except we pull out `p!` for convenience\n  have hps :\n    (∑ k ∈ range n, (k : ℚ) ^ p) =\n      (∑ i ∈ range (p + 1),\n          bernoulli i * (p + 1).choose i * (n : ℚ) ^ (p + 1 - i) / (p + 1)!) * p ! := by\n    suffices\n      (mk fun p => ∑ k ∈ range n, (k : ℚ) ^ p * algebraMap ℚ ℚ p !⁻¹) =\n        mk fun p =>\n          ∑ i ∈ range (p + 1), bernoulli i * (p + 1).choose i * (n : ℚ) ^ (p + 1 - i) / (p + 1)! by\n      rw [← div_eq_iff (hne p), div_eq_mul_inv, sum_mul]\n      rw [PowerSeries.ext_iff] at this\n      simpa using this p\n    -- the power series `exp ℚ - 1` is non-zero, a fact we need in order to use `mul_right_inj'`\n    have hexp : exp ℚ - 1 ≠ 0 := by\n      simp only [exp, PowerSeries.ext_iff, Ne, not_forall]\n      use 1\n      simp [factorial_ne_zero]\n    have h_r : exp ℚ ^ n - 1 = X * mk fun p => coeff ℚ (p + 1) (exp ℚ ^ n) := by\n      have h_const : C ℚ (constantCoeff ℚ (exp ℚ ^ n)) = 1 := by simp\n      rw [← h_const, sub_const_eq_X_mul_shift]\n    -- key step: a chain of equalities of power series\n    -- Porting note: altered proof slightly\n    rw [← mul_right_inj' hexp, mul_comm]\n    rw [← exp_pow_sum, geom_sum_mul, h_r, ← bernoulliPowerSeries_mul_exp_sub_one,\n      bernoulliPowerSeries, mul_right_comm]\n    simp only [mul_comm, mul_eq_mul_left_iff, hexp, or_false]\n    refine Eq.trans (mul_eq_mul_right_iff.mpr ?_) (Eq.trans h_cauchy ?_)\n    · left\n      congr\n    · simp only [mul_comm, factorial, cast_succ, cast_pow]\n\n  -- massage `hps` into our goal\n  rw [hps, sum_mul]\n  refine sum_congr rfl fun x _ => ?_\n  field_simp [mul_right_comm _ ↑p !, ← mul_assoc _ _ ↑p !, factorial]\n  ring\n\n"}
{"name":"sum_Ico_pow","module":"Mathlib.NumberTheory.Bernoulli","initialProofState":"n p : Nat\n⊢ Eq ((Finset.Ico 1 (HAdd.hAdd n 1)).sum fun k => HPow.hPow (↑k) p) ((Finset.range (HAdd.hAdd p 1)).sum fun i => HDiv.hDiv (HMul.hMul (HMul.hMul (bernoulli' i) ↑((HAdd.hAdd p 1).choose i)) (HPow.hPow (↑n) (HSub.hSub (HAdd.hAdd p 1) i))) (HAdd.hAdd (↑p) 1))","decl":"/-- Alternate form of **Faulhaber's theorem**, relating the sum of p-th powers to the Bernoulli\nnumbers: $$\\sum_{k=1}^{n} k^p = \\sum_{i=0}^p (-1)^iB_i\\binom{p+1}{i}\\frac{n^{p+1-i}}{p+1}.$$\nDeduced from `sum_range_pow`. -/\ntheorem sum_Ico_pow (n p : ℕ) :\n    (∑ k ∈ Ico 1 (n + 1), (k : ℚ) ^ p) =\n      ∑ i ∈ range (p + 1), bernoulli' i * (p + 1).choose i * (n : ℚ) ^ (p + 1 - i) / (p + 1) := by\n  rw [← Nat.cast_succ]\n  -- dispose of the trivial case\n  cases' p with p\n  · simp\n  let f i := bernoulli i * p.succ.succ.choose i * (n : ℚ) ^ (p.succ.succ - i) / p.succ.succ\n  let f' i := bernoulli' i * p.succ.succ.choose i * (n : ℚ) ^ (p.succ.succ - i) / p.succ.succ\n  suffices (∑ k ∈ Ico 1 n.succ, (k : ℚ) ^ p.succ) = ∑ i ∈ range p.succ.succ, f' i by convert this\n  -- prove some algebraic facts that will make things easier for us later on\n  have hle := Nat.le_add_left 1 n\n  have hne : (p + 1 + 1 : ℚ) ≠ 0 := by norm_cast\n  have h1 : ∀ r : ℚ, r * (p + 1 + 1) * (n : ℚ) ^ p.succ / (p + 1 + 1 : ℚ) = r * (n : ℚ) ^ p.succ :=\n      fun r => by rw [mul_div_right_comm, mul_div_cancel_right₀ _ hne]\n  have h2 : f 1 + (n : ℚ) ^ p.succ = 1 / 2 * (n : ℚ) ^ p.succ := by\n    simp_rw [f, bernoulli_one, choose_one_right, succ_sub_succ_eq_sub, cast_succ, tsub_zero, h1]\n    ring\n  have :\n    (∑ i ∈ range p, bernoulli (i + 2) * (p + 2).choose (i + 2) * (n : ℚ) ^ (p - i) / ↑(p + 2)) =\n      ∑ i ∈ range p, bernoulli' (i + 2) * (p + 2).choose (i + 2) * (n : ℚ) ^ (p - i) / ↑(p + 2) :=\n    sum_congr rfl fun i _ => by rw [bernoulli_eq_bernoulli'_of_ne_one (succ_succ_ne_one i)]\n  calc\n    (-- replace sum over `Ico` with sum over `range` and simplify\n        ∑ k ∈ Ico 1 n.succ, (k : ℚ) ^ p.succ)\n    _ = ∑ k ∈ range n.succ, (k : ℚ) ^ p.succ := by simp [sum_Ico_eq_sub _ hle, succ_ne_zero]\n    -- extract the last term of the sum\n    _ = (∑ k ∈ range n, (k : ℚ) ^ p.succ) + (n : ℚ) ^ p.succ := by rw [sum_range_succ]\n    -- apply the key lemma, `sum_range_pow`\n    _ = (∑ i ∈ range p.succ.succ, f i) + (n : ℚ) ^ p.succ := by simp [f, sum_range_pow]\n    -- extract the first two terms of the sum\n    _ = (∑ i ∈ range p, f i.succ.succ) + f 1 + f 0 + (n : ℚ) ^ p.succ := by\n      simp_rw [sum_range_succ']\n    _ = (∑ i ∈ range p, f i.succ.succ) + (f 1 + (n : ℚ) ^ p.succ) + f 0 := by ring\n    _ = (∑ i ∈ range p, f i.succ.succ) + 1 / 2 * (n : ℚ) ^ p.succ + f 0 := by rw [h2]\n    -- convert from `bernoulli` to `bernoulli'`\n    _ = (∑ i ∈ range p, f' i.succ.succ) + f' 1 + f' 0 := by\n      simpa [f, f', h1, fun i => show i + 2 = i + 1 + 1 from rfl]\n    -- rejoin the first two terms of the sum\n    _ = ∑ i ∈ range p.succ.succ, f' i := by simp_rw [sum_range_succ']\n\n"}
