{"name":"DirectSum.GNonUnitalNonAssocSemiring.zero_mul","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\nb : A j\n⊢ Eq (GradedMonoid.GMul.mul 0 b) 0","decl":"/-- A graded version of `NonUnitalNonAssocSemiring`. -/\nclass GNonUnitalNonAssocSemiring [Add ι] [∀ i, AddCommMonoid (A i)] extends\n  GradedMonoid.GMul A where\n  /-- Multiplication from the right with any graded component's zero vanishes. -/\n  mul_zero : ∀ {i j} (a : A i), mul a (0 : A j) = 0\n  /-- Multiplication from the left with any graded component's zero vanishes. -/\n  zero_mul : ∀ {i j} (b : A j), mul (0 : A i) b = 0\n  /-- Multiplication from the right between graded components distributes with respect to\n  addition. -/\n  mul_add : ∀ {i j} (a : A i) (b c : A j), mul a (b + c) = mul a b + mul a c\n  /-- Multiplication from the left between graded components distributes with respect to\n  addition. -/\n  add_mul : ∀ {i j} (a b : A i) (c : A j), mul (a + b) c = mul a c + mul b c\n\n"}
{"name":"DirectSum.GNonUnitalNonAssocSemiring.mul_add","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\na : A i\nb c : A j\n⊢ Eq (GradedMonoid.GMul.mul a (HAdd.hAdd b c)) (HAdd.hAdd (GradedMonoid.GMul.mul a b) (GradedMonoid.GMul.mul a c))","decl":"/-- A graded version of `NonUnitalNonAssocSemiring`. -/\nclass GNonUnitalNonAssocSemiring [Add ι] [∀ i, AddCommMonoid (A i)] extends\n  GradedMonoid.GMul A where\n  /-- Multiplication from the right with any graded component's zero vanishes. -/\n  mul_zero : ∀ {i j} (a : A i), mul a (0 : A j) = 0\n  /-- Multiplication from the left with any graded component's zero vanishes. -/\n  zero_mul : ∀ {i j} (b : A j), mul (0 : A i) b = 0\n  /-- Multiplication from the right between graded components distributes with respect to\n  addition. -/\n  mul_add : ∀ {i j} (a : A i) (b c : A j), mul a (b + c) = mul a b + mul a c\n  /-- Multiplication from the left between graded components distributes with respect to\n  addition. -/\n  add_mul : ∀ {i j} (a b : A i) (c : A j), mul (a + b) c = mul a c + mul b c\n\n"}
{"name":"DirectSum.GNonUnitalNonAssocSemiring.mul_zero","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\na : A i\n⊢ Eq (GradedMonoid.GMul.mul a 0) 0","decl":"/-- A graded version of `NonUnitalNonAssocSemiring`. -/\nclass GNonUnitalNonAssocSemiring [Add ι] [∀ i, AddCommMonoid (A i)] extends\n  GradedMonoid.GMul A where\n  /-- Multiplication from the right with any graded component's zero vanishes. -/\n  mul_zero : ∀ {i j} (a : A i), mul a (0 : A j) = 0\n  /-- Multiplication from the left with any graded component's zero vanishes. -/\n  zero_mul : ∀ {i j} (b : A j), mul (0 : A i) b = 0\n  /-- Multiplication from the right between graded components distributes with respect to\n  addition. -/\n  mul_add : ∀ {i j} (a : A i) (b c : A j), mul a (b + c) = mul a b + mul a c\n  /-- Multiplication from the left between graded components distributes with respect to\n  addition. -/\n  add_mul : ∀ {i j} (a b : A i) (c : A j), mul (a + b) c = mul a c + mul b c\n\n"}
{"name":"DirectSum.GNonUnitalNonAssocSemiring.add_mul","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : Add ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\na b : A i\nc : A j\n⊢ Eq (GradedMonoid.GMul.mul (HAdd.hAdd a b) c) (HAdd.hAdd (GradedMonoid.GMul.mul a c) (GradedMonoid.GMul.mul b c))","decl":"/-- A graded version of `NonUnitalNonAssocSemiring`. -/\nclass GNonUnitalNonAssocSemiring [Add ι] [∀ i, AddCommMonoid (A i)] extends\n  GradedMonoid.GMul A where\n  /-- Multiplication from the right with any graded component's zero vanishes. -/\n  mul_zero : ∀ {i j} (a : A i), mul a (0 : A j) = 0\n  /-- Multiplication from the left with any graded component's zero vanishes. -/\n  zero_mul : ∀ {i j} (b : A j), mul (0 : A i) b = 0\n  /-- Multiplication from the right between graded components distributes with respect to\n  addition. -/\n  mul_add : ∀ {i j} (a : A i) (b c : A j), mul a (b + c) = mul a b + mul a c\n  /-- Multiplication from the left between graded components distributes with respect to\n  addition. -/\n  add_mul : ∀ {i j} (a b : A i) (c : A j), mul (a + b) c = mul a c + mul b c\n\n"}
{"name":"DirectSum.GSemiring.gnpow_zero'","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\na : GradedMonoid A\n⊢ Eq (GradedMonoid.mk (HSMul.hSMul 0 a.fst) (DirectSum.GSemiring.gnpow 0 a.snd)) 1","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GSemiring.natCast_succ","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\nn : Nat\n⊢ Eq (DirectSum.GSemiring.natCast (HAdd.hAdd n 1)) (HAdd.hAdd (DirectSum.GSemiring.natCast n) GradedMonoid.GOne.one)","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GSemiring.gnpow_succ'","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\nn : Nat\na : GradedMonoid A\n⊢ Eq (GradedMonoid.mk (HSMul.hSMul n.succ a.fst) (DirectSum.GSemiring.gnpow n.succ a.snd)) (HMul.hMul ⟨HSMul.hSMul n a.fst, DirectSum.GSemiring.gnpow n a.snd⟩ a)","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GSemiring.mul_assoc","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\na b c : GradedMonoid A\n⊢ Eq (HMul.hMul (HMul.hMul a b) c) (HMul.hMul a (HMul.hMul b c))","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GSemiring.one_mul","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\na : GradedMonoid A\n⊢ Eq (HMul.hMul 1 a) a","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GSemiring.natCast_zero","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\n⊢ Eq (DirectSum.GSemiring.natCast 0) 0","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GSemiring.mul_one","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GSemiring A\na : GradedMonoid A\n⊢ Eq (HMul.hMul a 1) a","decl":"/-- A graded version of `Semiring`. -/\nclass GSemiring [AddMonoid ι] [∀ i, AddCommMonoid (A i)] extends GNonUnitalNonAssocSemiring A,\n  GradedMonoid.GMonoid A where\n  /-- The canonical map from ℕ to the zeroth component of a graded semiring. -/\n  natCast : ℕ → A 0\n  /-- The canonical map from ℕ to a graded semiring respects zero. -/\n  natCast_zero : natCast 0 = 0\n  /-- The canonical map from ℕ to a graded semiring respects successors. -/\n  natCast_succ : ∀ n : ℕ, natCast (n + 1) = natCast n + GradedMonoid.GOne.one\n\n"}
{"name":"DirectSum.GCommSemiring.mul_comm","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddCommMonoid ι\ninst✝ : (i : ι) → AddCommMonoid (A i)\nself : DirectSum.GCommSemiring A\na b : GradedMonoid A\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A graded version of `CommSemiring`. -/\nclass GCommSemiring [AddCommMonoid ι] [∀ i, AddCommMonoid (A i)] extends GSemiring A,\n  GradedMonoid.GCommMonoid A\n\n"}
{"name":"DirectSum.GRing.intCast_ofNat","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommGroup (A i)\nself : DirectSum.GRing A\nn : Nat\n⊢ Eq (DirectSum.GRing.intCast ↑n) (DirectSum.GSemiring.natCast n)","decl":"/-- A graded version of `Ring`. -/\nclass GRing [AddMonoid ι] [∀ i, AddCommGroup (A i)] extends GSemiring A where\n  /-- The canonical map from ℤ to the zeroth component of a graded ring. -/\n  intCast : ℤ → A 0\n  /-- The canonical map from ℤ to a graded ring extends the canonical map from ℕ to the underlying\n  graded semiring. -/\n  intCast_ofNat : ∀ n : ℕ, intCast n = natCast n\n  /-- On negative integers, the canonical map from ℤ to a graded ring is the negative extension of\n  the canonical map from ℕ to the underlying graded semiring. -/\n  -- Porting note: -(n+1) -> Int.negSucc\n  intCast_negSucc_ofNat : ∀ n : ℕ, intCast (Int.negSucc n) = -natCast (n + 1 : ℕ)\n\n"}
{"name":"DirectSum.GRing.intCast_negSucc_ofNat","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddMonoid ι\ninst✝ : (i : ι) → AddCommGroup (A i)\nself : DirectSum.GRing A\nn : Nat\n⊢ Eq (DirectSum.GRing.intCast (Int.negSucc n)) (Neg.neg (DirectSum.GSemiring.natCast (HAdd.hAdd n 1)))","decl":"/-- A graded version of `Ring`. -/\nclass GRing [AddMonoid ι] [∀ i, AddCommGroup (A i)] extends GSemiring A where\n  /-- The canonical map from ℤ to the zeroth component of a graded ring. -/\n  intCast : ℤ → A 0\n  /-- The canonical map from ℤ to a graded ring extends the canonical map from ℕ to the underlying\n  graded semiring. -/\n  intCast_ofNat : ∀ n : ℕ, intCast n = natCast n\n  /-- On negative integers, the canonical map from ℤ to a graded ring is the negative extension of\n  the canonical map from ℕ to the underlying graded semiring. -/\n  -- Porting note: -(n+1) -> Int.negSucc\n  intCast_negSucc_ofNat : ∀ n : ℕ, intCast (Int.negSucc n) = -natCast (n + 1 : ℕ)\n\n"}
{"name":"DirectSum.GCommRing.mul_comm","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝¹ : AddCommMonoid ι\ninst✝ : (i : ι) → AddCommGroup (A i)\nself : DirectSum.GCommRing A\na b : GradedMonoid A\n⊢ Eq (HMul.hMul a b) (HMul.hMul b a)","decl":"/-- A graded version of `CommRing`. -/\nclass GCommRing [AddCommMonoid ι] [∀ i, AddCommGroup (A i)] extends GRing A, GCommSemiring A\n\n"}
{"name":"DirectSum.of_eq_of_gradedMonoid_eq","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝¹ : DecidableEq ι\nA : ι → Type u_2\ninst✝ : (i : ι) → AddCommMonoid (A i)\ni j : ι\na : A i\nb : A j\nh : Eq (GradedMonoid.mk i a) (GradedMonoid.mk j b)\n⊢ Eq ((DirectSum.of A i) a) ((DirectSum.of A j) b)","decl":"theorem of_eq_of_gradedMonoid_eq {A : ι → Type*} [∀ i : ι, AddCommMonoid (A i)] {i j : ι} {a : A i}\n    {b : A j} (h : GradedMonoid.mk i a = GradedMonoid.mk j b) :\n    DirectSum.of A i a = DirectSum.of A j b :=\n  DFinsupp.single_eq_of_sigma_eq h\n\n"}
{"name":"DirectSum.one_def","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : Zero ι\ninst✝¹ : GradedMonoid.GOne A\ninst✝ : (i : ι) → AddCommMonoid (A i)\n⊢ Eq 1 ((DirectSum.of A 0) GradedMonoid.GOne.one)","decl":"theorem one_def : 1 = DirectSum.of A 0 GradedMonoid.GOne.one := rfl\n\n"}
{"name":"DirectSum.gMulHom_apply_apply","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\nA : ι → Type u_2\ninst✝² : Add ι\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\na : A i\nb : A j\n⊢ Eq (((DirectSum.gMulHom A) a) b) (GradedMonoid.GMul.mul a b)","decl":"/-- The piecewise multiplication from the `Mul` instance, as a bundled homomorphism. -/\n@[simps]\ndef gMulHom {i j} : A i →+ A j →+ A (i + j) where\n  toFun a :=\n    { toFun := fun b => GradedMonoid.GMul.mul a b\n      map_zero' := GNonUnitalNonAssocSemiring.mul_zero _\n      map_add' := GNonUnitalNonAssocSemiring.mul_add _ }\n  map_zero' := AddMonoidHom.ext fun a => GNonUnitalNonAssocSemiring.zero_mul a\n  map_add' _ _ := AddMonoidHom.ext fun _ => GNonUnitalNonAssocSemiring.add_mul _ _ _\n\n"}
{"name":"DirectSum.mulHom_apply","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : Add ι\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : DirectSum.GNonUnitalNonAssocSemiring A\na b : DirectSum ι fun i => A i\n⊢ Eq (((DirectSum.mulHom A) a) b) (HMul.hMul a b)","decl":"theorem mulHom_apply (a b : ⨁ i, A i) : mulHom A a b = a * b := rfl\n\n"}
{"name":"DirectSum.mulHom_of_of","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : Add ι\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\na : A i\nb : A j\n⊢ Eq (((DirectSum.mulHom A) ((DirectSum.of A i) a)) ((DirectSum.of A j) b)) ((DirectSum.of A (HAdd.hAdd i j)) (GradedMonoid.GMul.mul a b))","decl":"theorem mulHom_of_of {i j} (a : A i) (b : A j) :\n    mulHom A (of A i a) (of A j b) = of A (i + j) (GradedMonoid.GMul.mul a b) := by\n  unfold mulHom\n  simp only [toAddMonoid_of, flip_apply, coe_comp, Function.comp_apply]\n  rfl\n\n"}
{"name":"DirectSum.of_mul_of","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : Add ι\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : DirectSum.GNonUnitalNonAssocSemiring A\ni j : ι\na : A i\nb : A j\n⊢ Eq (HMul.hMul ((DirectSum.of A i) a) ((DirectSum.of A j) b)) ((DirectSum.of A (HAdd.hAdd i j)) (GradedMonoid.GMul.mul a b))","decl":"theorem of_mul_of {i j} (a : A i) (b : A j) :\n    of A i a * of A j b = of _ (i + j) (GradedMonoid.GMul.mul a b) :=\n  mulHom_of_of a b\n\n"}
{"name":"DirectSum.ofPow","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\ni : ι\na : A i\nn : Nat\n⊢ Eq (HPow.hPow ((DirectSum.of A i) a) n) ((DirectSum.of A (HSMul.hSMul n i)) (GradedMonoid.GMonoid.gnpow n a))","decl":"theorem ofPow {i} (a : A i) (n : ℕ) :\n    of _ i a ^ n = of _ (n • i) (GradedMonoid.GMonoid.gnpow _ a) := by\n  induction n with\n  | zero => exact of_eq_of_gradedMonoid_eq (pow_zero <| GradedMonoid.mk _ a).symm\n  | succ n n_ih =>\n    rw [pow_succ, n_ih, of_mul_of]\n    exact of_eq_of_gradedMonoid_eq (pow_succ (GradedMonoid.mk _ a) n).symm\n\n"}
{"name":"DirectSum.ofList_dProd","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nα : Type u_3\nl : List α\nfι : α → ι\nfA : (a : α) → A (fι a)\n⊢ Eq ((DirectSum.of A (l.dProdIndex fι)) (l.dProd fι fA)) (List.map (fun a => (DirectSum.of A (fι a)) (fA a)) l).prod","decl":"theorem ofList_dProd {α} (l : List α) (fι : α → ι) (fA : ∀ a, A (fι a)) :\n    of A _ (l.dProd fι fA) = (l.map fun a => of A (fι a) (fA a)).prod := by\n  induction l with\n  | nil => simp only [List.map_nil, List.prod_nil, List.dProd_nil]; rfl\n  | cons head tail =>\n    rename_i ih\n    simp only [List.map_cons, List.prod_cons, List.dProd_cons, ← ih]\n    rw [DirectSum.of_mul_of (fA head)]\n    rfl\n\n"}
{"name":"DirectSum.list_prod_ofFn_of_eq_dProd","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nn : Nat\nfι : Fin n → ι\nfA : (a : Fin n) → A (fι a)\n⊢ Eq (List.ofFn fun a => (DirectSum.of A (fι a)) (fA a)).prod ((DirectSum.of A ((List.finRange n).dProdIndex fι)) ((List.finRange n).dProd fι fA))","decl":"theorem list_prod_ofFn_of_eq_dProd (n : ℕ) (fι : Fin n → ι) (fA : ∀ a, A (fι a)) :\n    (List.ofFn fun a => of A (fι a) (fA a)).prod = of A _ ((List.finRange n).dProd fι fA) := by\n  rw [List.ofFn_eq_map, ofList_dProd]\n\n"}
{"name":"DirectSum.mul_eq_dfinsupp_sum","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : (i : ι) → (x : A i) → Decidable (Ne x 0)\na a' : DirectSum ι fun i => A i\n⊢ Eq (HMul.hMul a a') (DFinsupp.sum a fun x ai => DFinsupp.sum a' fun x_1 aj => (DirectSum.of A (HAdd.hAdd x x_1)) (GradedMonoid.GMul.mul ai aj))","decl":"theorem mul_eq_dfinsupp_sum [∀ (i : ι) (x : A i), Decidable (x ≠ 0)] (a a' : ⨁ i, A i) :\n    a * a'\n      = a.sum fun _ ai => a'.sum fun _ aj => DirectSum.of _ _ <| GradedMonoid.GMul.mul ai aj := by\n  change mulHom _ a a' = _\n  -- Porting note: I have no idea how the proof from ml3 worked it used to be\n  -- simpa only [mul_hom, to_add_monoid, dfinsupp.lift_add_hom_apply, dfinsupp.sum_add_hom_apply,\n  -- add_monoid_hom.dfinsupp_sum_apply, flip_apply, add_monoid_hom.dfinsupp_sum_add_hom_apply],\n  rw [mulHom, toAddMonoid, DFinsupp.liftAddHom_apply]\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [DFinsupp.sumAddHom_apply]\n  rw [AddMonoidHom.dfinsupp_sum_apply]\n  apply congrArg _\n  funext x\n  simp_rw [flip_apply]\n  erw [DFinsupp.sumAddHom_apply]\n  simp only [gMulHom, AddMonoidHom.dfinsupp_sum_apply, flip_apply, coe_comp, AddMonoidHom.coe_mk,\n  ZeroHom.coe_mk, Function.comp_apply, AddMonoidHom.compHom_apply_apply]\n\n"}
{"name":"DirectSum.mul_eq_sum_support_ghas_mul","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : (i : ι) → (x : A i) → Decidable (Ne x 0)\na a' : DirectSum ι fun i => A i\n⊢ Eq (HMul.hMul a a') ((SProd.sprod (DFinsupp.support a) (DFinsupp.support a')).sum fun ij => (DirectSum.of A (HAdd.hAdd ij.1 ij.2)) (GradedMonoid.GMul.mul (a ij.1) (a' ij.2)))","decl":"/-- A heavily unfolded version of the definition of multiplication -/\ntheorem mul_eq_sum_support_ghas_mul [∀ (i : ι) (x : A i), Decidable (x ≠ 0)] (a a' : ⨁ i, A i) :\n    a * a' =\n      ∑ ij ∈ DFinsupp.support a ×ˢ DFinsupp.support a',\n        DirectSum.of _ _ (GradedMonoid.GMul.mul (a ij.fst) (a' ij.snd)) := by\n  simp only [mul_eq_dfinsupp_sum, DFinsupp.sum, Finset.sum_product]\n\n"}
{"name":"DirectSum.of_zero_one","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : Zero ι\ninst✝¹ : GradedMonoid.GOne A\ninst✝ : (i : ι) → AddCommMonoid (A i)\n⊢ Eq ((DirectSum.of A 0) 1) 1","decl":"@[simp]\ntheorem of_zero_one : of _ 0 (1 : A 0) = 1 :=\n  rfl\n\n"}
{"name":"DirectSum.of_zero_smul","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : AddZeroClass ι\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : DirectSum.GNonUnitalNonAssocSemiring A\ni : ι\na : A 0\nb : A i\n⊢ Eq ((DirectSum.of A i) (HSMul.hSMul a b)) (HMul.hMul ((DirectSum.of A 0) a) ((DirectSum.of A i) b))","decl":"@[simp]\ntheorem of_zero_smul {i} (a : A 0) (b : A i) : of _ _ (a • b) = of _ _ a * of _ _ b :=\n  (of_eq_of_gradedMonoid_eq (GradedMonoid.mk_zero_smul a b)).trans (of_mul_of _ _).symm\n\n"}
{"name":"DirectSum.of_zero_mul","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : AddZeroClass ι\ninst✝¹ : (i : ι) → AddCommMonoid (A i)\ninst✝ : DirectSum.GNonUnitalNonAssocSemiring A\na b : A 0\n⊢ Eq ((DirectSum.of A 0) (HMul.hMul a b)) (HMul.hMul ((DirectSum.of A 0) a) ((DirectSum.of A 0) b))","decl":"@[simp]\ntheorem of_zero_mul (a b : A 0) : of _ 0 (a * b) = of _ 0 a * of _ 0 b :=\n  of_zero_smul A a b\n\n"}
{"name":"DirectSum.of_zero_pow","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\na : A 0\nn : Nat\n⊢ Eq ((DirectSum.of A 0) (HPow.hPow a n)) (HPow.hPow ((DirectSum.of A 0) a) n)","decl":"@[simp]\ntheorem of_zero_pow (a : A 0) : ∀ n : ℕ, of A 0 (a ^ n) = of A 0 a ^ n\n  | 0 => by rw [pow_zero, pow_zero, DirectSum.of_zero_one]\n  -- Porting note: Lean doesn't think this terminates if we only use `of_zero_pow` alone\n  | n + 1 => by rw [pow_succ, pow_succ, of_zero_mul, of_zero_pow _ n]\n\n"}
{"name":"DirectSum.of_natCast","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : (i : ι) → AddCommMonoid (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GSemiring A\nn : Nat\n⊢ Eq ((DirectSum.of A 0) ↑n) ↑n","decl":"@[simp]\ntheorem of_natCast (n : ℕ) : of A 0 n = n :=\n  rfl\n\n"}
{"name":"DirectSum.of_zero_ofNat","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq ((DirectSum.of A 0) (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem of_zero_ofNat (n : ℕ) [n.AtLeastTwo] : of A 0 ofNat(n) = ofNat(n) :=\n  of_natCast A n\n\n"}
{"name":"DirectSum.of_intCast","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝³ : DecidableEq ι\nA : ι → Type u_2\ninst✝² : (i : ι) → AddCommGroup (A i)\ninst✝¹ : AddMonoid ι\ninst✝ : DirectSum.GRing A\nn : Int\n⊢ Eq ((DirectSum.of A 0) ↑n) ↑n","decl":"@[simp]\ntheorem of_intCast (n : ℤ) : of A 0 n = n := by\n  rfl\n\n"}
{"name":"DirectSum.ringHom_ext'","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nF G : RingHom (DirectSum ι fun i => A i) R\nh : ∀ (i : ι), Eq ((↑F).comp (DirectSum.of A i)) ((↑G).comp (DirectSum.of A i))\n⊢ Eq F G","decl":"/-- If two ring homomorphisms from `⨁ i, A i` are equal on each `of A i y`,\nthen they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem ringHom_ext' ⦃F G : (⨁ i, A i) →+* R⦄\n    (h : ∀ i, (↑F : _ →+ R).comp (of A i) = (↑G : _ →+ R).comp (of A i)) : F = G :=\n  RingHom.coe_addMonoidHom_injective <| DirectSum.addHom_ext' h\n\n"}
{"name":"DirectSum.ringHom_ext'_iff","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nF G : RingHom (DirectSum ι fun i => A i) R\n⊢ Iff (Eq F G) (∀ (i : ι), Eq ((↑F).comp (DirectSum.of A i)) ((↑G).comp (DirectSum.of A i)))","decl":"/-- If two ring homomorphisms from `⨁ i, A i` are equal on each `of A i y`,\nthen they are equal.\n\nSee note [partially-applied ext lemmas]. -/\n@[ext]\ntheorem ringHom_ext' ⦃F G : (⨁ i, A i) →+* R⦄\n    (h : ∀ i, (↑F : _ →+ R).comp (of A i) = (↑G : _ →+ R).comp (of A i)) : F = G :=\n  RingHom.coe_addMonoidHom_injective <| DirectSum.addHom_ext' h\n\n"}
{"name":"DirectSum.ringHom_ext","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nf g : RingHom (DirectSum ι fun i => A i) R\nh : ∀ (i : ι) (x : A i), Eq (f ((DirectSum.of A i) x)) (g ((DirectSum.of A i) x))\n⊢ Eq f g","decl":"/-- Two `RingHom`s out of a direct sum are equal if they agree on the generators. -/\ntheorem ringHom_ext ⦃f g : (⨁ i, A i) →+* R⦄ (h : ∀ i x, f (of A i x) = g (of A i x)) : f = g :=\n  ringHom_ext' fun i => AddMonoidHom.ext <| h i\n\n"}
{"name":"DirectSum.toSemiring_apply","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nf : (i : ι) → AddMonoidHom (A i) R\nhone : Eq ((f 0) GradedMonoid.GOne.one) 1\nhmul : ∀ {i j : ι} (ai : A i) (aj : A j), Eq ((f (HAdd.hAdd i j)) (GradedMonoid.GMul.mul ai aj)) (HMul.hMul ((f i) ai) ((f j) aj))\na : DirectSum ι fun i => A i\n⊢ Eq ((DirectSum.toSemiring f hone hmul) a) ((DirectSum.toAddMonoid f) a)","decl":"/-- A family of `AddMonoidHom`s preserving `DirectSum.One.one` and `DirectSum.Mul.mul`\ndescribes a `RingHom`s on `⨁ i, A i`. This is a stronger version of `DirectSum.toMonoid`.\n\nOf particular interest is the case when `A i` are bundled subojects, `f` is the family of\ncoercions such as `AddSubmonoid.subtype (A i)`, and the `[GSemiring A]` structure originates from\n`DirectSum.gsemiring.ofAddSubmonoids`, in which case the proofs about `GOne` and `GMul`\ncan be discharged by `rfl`. -/\n@[simps]\ndef toSemiring (f : ∀ i, A i →+ R) (hone : f _ GradedMonoid.GOne.one = 1)\n    (hmul : ∀ {i j} (ai : A i) (aj : A j), f _ (GradedMonoid.GMul.mul ai aj) = f _ ai * f _ aj) :\n    (⨁ i, A i) →+* R :=\n  { toAddMonoid f with\n    toFun := toAddMonoid f\n    map_one' := by\n      change (toAddMonoid f) (of _ 0 _) = 1\n      rw [toAddMonoid_of]\n      exact hone\n    map_mul' := by\n      rw [(toAddMonoid f).map_mul_iff]\n      refine DirectSum.addHom_ext' (fun xi ↦ AddMonoidHom.ext (fun xv ↦ ?_))\n      refine DirectSum.addHom_ext' (fun yi ↦ AddMonoidHom.ext (fun yv ↦ ?_))\n      show\n        toAddMonoid f (of A xi xv * of A yi yv) =\n          toAddMonoid f (of A xi xv) * toAddMonoid f (of A yi yv)\n      simp_rw [of_mul_of, toAddMonoid_of]\n      exact hmul _ _ }\n\n"}
{"name":"DirectSum.toSemiring_of","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nf : (i : ι) → AddMonoidHom (A i) R\nhone : Eq ((f 0) GradedMonoid.GOne.one) 1\nhmul : ∀ {i j : ι} (ai : A i) (aj : A j), Eq ((f (HAdd.hAdd i j)) (GradedMonoid.GMul.mul ai aj)) (HMul.hMul ((f i) ai) ((f j) aj))\ni : ι\nx : A i\n⊢ Eq ((DirectSum.toSemiring f hone hmul) ((DirectSum.of A i) x)) ((f i) x)","decl":"theorem toSemiring_of (f : ∀ i, A i →+ R) (hone hmul) (i : ι) (x : A i) :\n    toSemiring f hone hmul (of _ i x) = f _ x :=\n  toAddMonoid_of f i x\n\n"}
{"name":"DirectSum.toSemiring_coe_addMonoidHom","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nf : (i : ι) → AddMonoidHom (A i) R\nhone : Eq ((f 0) GradedMonoid.GOne.one) 1\nhmul : ∀ {i j : ι} (ai : A i) (aj : A j), Eq ((f (HAdd.hAdd i j)) (GradedMonoid.GMul.mul ai aj)) (HMul.hMul ((f i) ai) ((f j) aj))\n⊢ Eq (↑(DirectSum.toSemiring f hone hmul)) (DirectSum.toAddMonoid f)","decl":"@[simp]\ntheorem toSemiring_coe_addMonoidHom (f : ∀ i, A i →+ R) (hone hmul) :\n    (toSemiring f hone hmul : (⨁ i, A i) →+ R) = toAddMonoid f :=\n  rfl\n\n"}
{"name":"DirectSum.liftRingHom_apply","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nf : Subtype fun f => And (Eq (f GradedMonoid.GOne.one) 1) (∀ {i j : ι} (ai : A i) (aj : A j), Eq (f (GradedMonoid.GMul.mul ai aj)) (HMul.hMul (f ai) (f aj)))\n⊢ Eq (DirectSum.liftRingHom f) (DirectSum.toSemiring (fun x => ↑f) ⋯ ⋯)","decl":"/-- Families of `AddMonoidHom`s preserving `DirectSum.One.one` and `DirectSum.Mul.mul`\nare isomorphic to `RingHom`s on `⨁ i, A i`. This is a stronger version of `DFinsupp.liftAddHom`.\n-/\n@[simps]\ndef liftRingHom :\n    { f : ∀ {i}, A i →+ R //\n        f GradedMonoid.GOne.one = 1 ∧\n          ∀ {i j} (ai : A i) (aj : A j), f (GradedMonoid.GMul.mul ai aj) = f ai * f aj } ≃\n      ((⨁ i, A i) →+* R) where\n  toFun f := toSemiring (fun _ => f.1) f.2.1 f.2.2\n  invFun F :=\n    ⟨by intro i; exact (F : (⨁ i, A i) →+ R).comp (of _ i),\n      by\n      simp only [AddMonoidHom.comp_apply]\n      rw [← F.map_one]\n      rfl,\n      by\n      intros i j ai aj\n      simp only [AddMonoidHom.comp_apply, AddMonoidHom.coe_coe]\n      rw [← F.map_mul (of A i ai), of_mul_of ai]⟩\n  left_inv f := by\n    ext xi xv\n    exact toAddMonoid_of (fun _ => f.1) xi xv\n  right_inv F := by\n    apply RingHom.coe_addMonoidHom_injective\n    refine DirectSum.addHom_ext' (fun xi ↦ AddMonoidHom.ext (fun xv ↦ ?_))\n    simp only [RingHom.coe_addMonoidHom_mk, DirectSum.toAddMonoid_of, AddMonoidHom.mk_coe,\n      AddMonoidHom.comp_apply, toSemiring_coe_addMonoidHom]\n\n"}
{"name":"DirectSum.liftRingHom_symm_apply_coe","module":"Mathlib.Algebra.DirectSum.Ring","initialProofState":"ι : Type u_1\ninst✝⁴ : DecidableEq ι\nA : ι → Type u_2\nR : Type u_3\ninst✝³ : (i : ι) → AddCommMonoid (A i)\ninst✝² : AddMonoid ι\ninst✝¹ : DirectSum.GSemiring A\ninst✝ : Semiring R\nF : RingHom (DirectSum ι fun i => A i) R\ni : ι\n⊢ Eq (↑(DirectSum.liftRingHom.symm F)) ((↑F).comp (DirectSum.of A i))","decl":"/-- Families of `AddMonoidHom`s preserving `DirectSum.One.one` and `DirectSum.Mul.mul`\nare isomorphic to `RingHom`s on `⨁ i, A i`. This is a stronger version of `DFinsupp.liftAddHom`.\n-/\n@[simps]\ndef liftRingHom :\n    { f : ∀ {i}, A i →+ R //\n        f GradedMonoid.GOne.one = 1 ∧\n          ∀ {i j} (ai : A i) (aj : A j), f (GradedMonoid.GMul.mul ai aj) = f ai * f aj } ≃\n      ((⨁ i, A i) →+* R) where\n  toFun f := toSemiring (fun _ => f.1) f.2.1 f.2.2\n  invFun F :=\n    ⟨by intro i; exact (F : (⨁ i, A i) →+ R).comp (of _ i),\n      by\n      simp only [AddMonoidHom.comp_apply]\n      rw [← F.map_one]\n      rfl,\n      by\n      intros i j ai aj\n      simp only [AddMonoidHom.comp_apply, AddMonoidHom.coe_coe]\n      rw [← F.map_mul (of A i ai), of_mul_of ai]⟩\n  left_inv f := by\n    ext xi xv\n    exact toAddMonoid_of (fun _ => f.1) xi xv\n  right_inv F := by\n    apply RingHom.coe_addMonoidHom_injective\n    refine DirectSum.addHom_ext' (fun xi ↦ AddMonoidHom.ext (fun xv ↦ ?_))\n    simp only [RingHom.coe_addMonoidHom_mk, DirectSum.toAddMonoid_of, AddMonoidHom.mk_coe,\n      AddMonoidHom.comp_apply, toSemiring_coe_addMonoidHom]\n\n"}
