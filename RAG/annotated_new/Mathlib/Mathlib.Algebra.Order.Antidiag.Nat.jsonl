{"name":"Nat.mem_finMulAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n : Nat\nf : Fin d → Nat\n⊢ Iff (Membership.mem (d.finMulAntidiag n) f) (And (Eq (Finset.univ.prod fun i => f i) n) (Ne n 0))","decl":"@[simp]\ntheorem mem_finMulAntidiag {d n : ℕ} {f : Fin d → ℕ} :\n    f ∈ finMulAntidiag d n ↔ ∏ i, f i = n ∧ n ≠ 0 := by\n  unfold finMulAntidiag\n  split_ifs with h\n  · simp_rw [mem_map, mem_finAntidiagonal, Function.Embedding.arrowCongrRight_apply,\n      Function.comp_def, Function.Embedding.trans_apply, Equiv.coe_toEmbedding,\n      Function.Embedding.coeFn_mk, ← Additive.ofMul.symm_apply_eq, Additive.ofMul_symm_eq,\n      toMul_sum, (Equiv.piCongrRight fun _=> Additive.ofMul).surjective.exists,\n      Equiv.piCongrRight_apply, Pi.map_apply, toMul_ofMul, ← PNat.coe_inj, PNat.mk_coe,\n      PNat.coe_prod]\n    constructor\n    · rintro ⟨a, ha_mem, rfl⟩\n      exact ⟨ha_mem, h.ne.symm⟩\n    · rintro ⟨rfl, _⟩\n      refine ⟨fun i ↦ ⟨f i, ?_⟩, rfl, funext fun _ => rfl⟩\n      apply Nat.pos_of_ne_zero\n      exact Finset.prod_ne_zero_iff.mp h.ne.symm _ (mem_univ _)\n  · simp only [not_lt, nonpos_iff_eq_zero] at h\n    simp only [h, not_mem_empty, ne_eq, not_true_eq_false, and_false]\n\n"}
{"name":"Nat.finMulAntidiag_zero_right","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d : Nat\n⊢ Eq (d.finMulAntidiag 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem finMulAntidiag_zero_right (d : ℕ) :\n    finMulAntidiag d 0 = ∅ := rfl\n\n"}
{"name":"Nat.finMulAntidiag_one","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d : Nat\n⊢ Eq (d.finMulAntidiag 1) (Singleton.singleton fun x => 1)","decl":"theorem finMulAntidiag_one {d : ℕ} :\n    finMulAntidiag d 1 = {fun _ => 1} := by\n  ext f\n  simp only [mem_finMulAntidiag, and_true, mem_singleton]\n  constructor\n  · intro ⟨hf, _⟩; ext i\n    rw [← Nat.dvd_one, ← hf]\n    exact dvd_prod_of_mem f (mem_univ _)\n  · rintro rfl\n    simp only [prod_const_one, implies_true, ne_eq, one_ne_zero, not_false_eq_true,\n    and_self]\n\n"}
{"name":"Nat.finMulAntidiag_zero_left","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"n : Nat\nhn : Ne n 1\n⊢ Eq (Nat.finMulAntidiag 0 n) EmptyCollection.emptyCollection","decl":"theorem finMulAntidiag_zero_left {n : ℕ} (hn : n ≠ 1) :\n    finMulAntidiag 0 n = ∅ := by\n  ext\n  simp [hn.symm]\n\n"}
{"name":"Nat.dvd_of_mem_finMulAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"n d : Nat\nf : Fin d → Nat\nhf : Membership.mem (d.finMulAntidiag n) f\ni : Fin d\n⊢ Dvd.dvd (f i) n","decl":"theorem dvd_of_mem_finMulAntidiag {n d : ℕ} {f : Fin d → ℕ} (hf : f ∈ finMulAntidiag d n)\n    (i : Fin d) : f i ∣ n := by\n  rw [mem_finMulAntidiag] at hf\n  rw [← hf.1]\n  exact dvd_prod_of_mem f (mem_univ i)\n\n"}
{"name":"Nat.ne_zero_of_mem_finMulAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n : Nat\nf : Fin d → Nat\nhf : Membership.mem (d.finMulAntidiag n) f\ni : Fin d\n⊢ Ne (f i) 0","decl":"theorem ne_zero_of_mem_finMulAntidiag {d n : ℕ} {f : Fin d → ℕ}\n    (hf : f ∈ finMulAntidiag d n) (i : Fin d) : f i ≠ 0 :=\n  ne_zero_of_dvd_ne_zero (mem_finMulAntidiag.mp hf).2 (dvd_of_mem_finMulAntidiag hf i)\n\n"}
{"name":"Nat.prod_eq_of_mem_finMulAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n : Nat\nf : Fin d → Nat\nhf : Membership.mem (d.finMulAntidiag n) f\n⊢ Eq (Finset.univ.prod fun i => f i) n","decl":"theorem prod_eq_of_mem_finMulAntidiag {d n : ℕ} {f : Fin d → ℕ}\n    (hf : f ∈ finMulAntidiag d n) : ∏ i, f i = n :=\n  (mem_finMulAntidiag.mp hf).1\n\n"}
{"name":"Nat.finMulAntidiag_eq_piFinset_divisors_filter","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d m n : Nat\nhmn : Dvd.dvd m n\nhn : Ne n 0\n⊢ Eq (d.finMulAntidiag m) (Finset.filter (fun f => Eq (Finset.univ.prod fun i => f i) m) (Fintype.piFinset fun x => n.divisors))","decl":"theorem finMulAntidiag_eq_piFinset_divisors_filter {d m n : ℕ} (hmn : m ∣ n) (hn : n ≠ 0) :\n    finMulAntidiag d m =\n      {f ∈ Fintype.piFinset fun _ : Fin d => n.divisors | ∏ i, f i = m} := by\n  ext f\n  simp only [mem_univ, not_true, IsEmpty.forall_iff, implies_true, ne_eq, true_and,\n    Fintype.mem_piFinset, mem_divisors, Nat.isUnit_iff, mem_filter]\n  constructor\n  · intro hf\n    refine ⟨?_, prod_eq_of_mem_finMulAntidiag hf⟩\n    exact fun i => ⟨(dvd_of_mem_finMulAntidiag hf i).trans hmn, hn⟩\n  · rw [mem_finMulAntidiag]\n    exact fun ⟨_, hprod⟩ => ⟨hprod, ne_zero_of_dvd_ne_zero hn hmn⟩\n\n"}
{"name":"Nat.image_apply_finMulAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n : Nat\ni : Fin d\nhd : Ne d 1\n⊢ Eq (Finset.image (fun f => f i) (d.finMulAntidiag n)) n.divisors","decl":"lemma image_apply_finMulAntidiag {d n : ℕ} {i : Fin d} (hd : d ≠ 1) :\n    (finMulAntidiag d n).image (fun f => f i) = divisors n := by\n  ext k\n  simp only [mem_image, ne_eq, mem_divisors, Nat.isUnit_iff]\n  constructor\n  · rintro ⟨f, hf, rfl⟩\n    exact ⟨dvd_of_mem_finMulAntidiag hf _, (mem_finMulAntidiag.mp hf).2⟩\n  · simp_rw [mem_finMulAntidiag]\n    rintro ⟨⟨r, rfl⟩, hn⟩\n    have hs : Nontrivial (Fin d) := by\n      rw [Fin.nontrivial_iff_two_le]\n      obtain rfl | hd' := eq_or_ne d 0\n      · exact i.elim0\n      omega\n    obtain ⟨i', hi_ne⟩ := exists_ne i\n    use fun j => if j = i then k else if j = i' then r else 1\n    simp only [ite_true, and_true, hn]\n    rw [← Finset.mul_prod_erase (a:=i) (h:=mem_univ _),\n      ← Finset.mul_prod_erase (a:= i')]\n    · rw [if_neg hi_ne, if_pos rfl, if_pos rfl, prod_eq_one]\n      · refine ⟨by ring, hn⟩\n      intro j hj\n      simp only [mem_erase, ne_eq, mem_univ, and_true] at hj\n      rw [if_neg hj.1, if_neg hj.2]\n    exact mem_erase.mpr ⟨hi_ne, mem_univ _⟩\n\n"}
{"name":"Nat.image_piFinTwoEquiv_finMulAntidiag","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"n : Nat\n⊢ Eq (Finset.image (⇑(piFinTwoEquiv fun x => Nat)) (Nat.finMulAntidiag 2 n)) n.divisorsAntidiagonal","decl":"lemma image_piFinTwoEquiv_finMulAntidiag {n : ℕ} :\n    (finMulAntidiag 2 n).image (piFinTwoEquiv <| fun _ => ℕ) = divisorsAntidiagonal n := by\n  ext x\n  simp [(piFinTwoEquiv <| fun _ => ℕ).symm.surjective.exists]\n\n"}
{"name":"Nat.finMulAntidiag_existsUnique_prime_dvd","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n p : Nat\nhn : Squarefree n\nhp : Membership.mem n.primeFactorsList p\nf : Fin d → Nat\nhf : Membership.mem (d.finMulAntidiag n) f\n⊢ ExistsUnique fun i => Dvd.dvd p (f i)","decl":"lemma finMulAntidiag_existsUnique_prime_dvd {d n p : ℕ} (hn : Squarefree n)\n    (hp : p ∈ n.primeFactorsList) (f : Fin d → ℕ) (hf : f ∈ finMulAntidiag d n) :\n    ∃! i, p ∣ f i := by\n  rw [mem_finMulAntidiag] at hf\n  rw [mem_primeFactorsList hf.2, ← hf.1, hp.1.prime.dvd_finset_prod_iff] at hp\n  obtain ⟨i, his, hi⟩ := hp.2\n  refine ⟨i, hi, ?_⟩\n  intro j hj\n  by_contra hij\n  apply Nat.Prime.not_coprime_iff_dvd.mpr ⟨p, hp.1, hi, hj⟩\n  apply Nat.coprime_of_squarefree_mul\n  apply hn.squarefree_of_dvd\n  rw [← hf.1, ← Finset.mul_prod_erase _ _ (his),\n    ← Finset.mul_prod_erase _ _ (mem_erase.mpr ⟨hij, mem_univ _⟩), ← mul_assoc]\n  apply Nat.dvd_mul_right\n\n"}
{"name":"Nat.finMulAntidiag_exists_unique_prime_dvd","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n p : Nat\nhn : Squarefree n\nhp : Membership.mem n.primeFactorsList p\nf : Fin d → Nat\nhf : Membership.mem (d.finMulAntidiag n) f\n⊢ ExistsUnique fun i => Dvd.dvd p (f i)","decl":"@[deprecated (since := \"2024-12-17\")]\nalias finMulAntidiag_exists_unique_prime_dvd := finMulAntidiag_existsUnique_prime_dvd\n\n"}
{"name":"Nat.card_finMulAntidiag_of_squarefree","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"d n : Nat\nhn : Squarefree n\n⊢ Eq (d.finMulAntidiag n).card (HPow.hPow d (ArithmeticFunction.cardDistinctFactors n))","decl":"theorem card_finMulAntidiag_of_squarefree {d n : ℕ} (hn : Squarefree n) :\n    #(finMulAntidiag d n) = d ^ ω n := by\n  rw [← card_finMulAntidiag_pi d n hn, Finset.card_pi, Finset.prod_const,\n    ArithmeticFunction.cardDistinctFactors_apply, ← List.card_toFinset, toFinset_factors,\n    Finset.card_fin]\n\n"}
{"name":"Nat.finMulAntidiag_three","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"n : Nat\na : Fin 3 → Nat\nha : Membership.mem (Nat.finMulAntidiag 3 n) a\n⊢ Eq (HMul.hMul (HMul.hMul (a 0) (a 1)) (a 2)) n","decl":"theorem finMulAntidiag_three {n : ℕ} (a) (ha : a ∈ finMulAntidiag 3 n) : a 0 * a 1 * a 2 = n := by\n  rw [← (mem_finMulAntidiag.mp ha).1, Fin.prod_univ_three a]\n\n"}
{"name":"Nat.card_pair_lcm_eq","module":"Mathlib.Algebra.Order.Antidiag.Nat","initialProofState":"n : Nat\nhn : Squarefree n\n⊢ Eq (Finset.filter (fun p => Eq (p.1.lcm p.2) n) (SProd.sprod n.divisors n.divisors)).card (HPow.hPow 3 (ArithmeticFunction.cardDistinctFactors n))","decl":"open card_pair_lcm_eq in\ntheorem card_pair_lcm_eq {n : ℕ} (hn : Squarefree n) :\n    #{p ∈ (n.divisors ×ˢ n.divisors) | p.1.lcm p.2 = n} = 3 ^ ω n := by\n  rw [← card_finMulAntidiag_of_squarefree hn, eq_comm]\n  apply Finset.card_bij f (f_img hn) (f_inj) (f_surj hn.ne_zero)\n\n"}
