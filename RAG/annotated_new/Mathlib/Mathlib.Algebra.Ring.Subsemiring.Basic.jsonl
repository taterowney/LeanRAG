{"name":"SubsemiringClass.instCharZero","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : NonAssocSemiring R\ninst✝¹ : SetLike S R\nhSR : SubsemiringClass S R\ns : S\ninst✝ : CharZero R\n⊢ CharZero (Subtype fun x => Membership.mem s x)","decl":"instance instCharZero [CharZero R] : CharZero s :=\n  ⟨Function.Injective.of_comp (f := Subtype.val) (g := Nat.cast (R := s)) Nat.cast_injective⟩\n\n"}
{"name":"Subsemiring.toSubmonoid_strictMono","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ StrictMono Subsemiring.toSubmonoid","decl":"@[mono]\ntheorem toSubmonoid_strictMono : StrictMono (toSubmonoid : Subsemiring R → Submonoid R) :=\n  fun _ _ => id\n\n"}
{"name":"Subsemiring.toSubmonoid_mono","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Monotone Subsemiring.toSubmonoid","decl":"@[mono]\ntheorem toSubmonoid_mono : Monotone (toSubmonoid : Subsemiring R → Submonoid R) :=\n  toSubmonoid_strictMono.monotone\n\n"}
{"name":"Subsemiring.toAddSubmonoid_strictMono","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ StrictMono Subsemiring.toAddSubmonoid","decl":"@[mono]\ntheorem toAddSubmonoid_strictMono : StrictMono (toAddSubmonoid : Subsemiring R → AddSubmonoid R) :=\n  fun _ _ => id\n\n"}
{"name":"Subsemiring.toAddSubmonoid_mono","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Monotone Subsemiring.toAddSubmonoid","decl":"@[mono]\ntheorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : Subsemiring R → AddSubmonoid R) :=\n  toAddSubmonoid_strictMono.monotone\n\n"}
{"name":"Subsemiring.list_prod_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Subsemiring R\nl : List R\na✝ : ∀ (x : R), Membership.mem l x → Membership.mem s x\n⊢ Membership.mem s l.prod","decl":"/-- Product of a list of elements in a `Subsemiring` is in the `Subsemiring`. -/\nnonrec theorem list_prod_mem {R : Type*} [Semiring R] (s : Subsemiring R) {l : List R} :\n    (∀ x ∈ l, x ∈ s) → l.prod ∈ s :=\n  list_prod_mem\n\n"}
{"name":"Subsemiring.list_sum_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Subsemiring R\nl : List R\na✝ : ∀ (x : R), Membership.mem l x → Membership.mem s x\n⊢ Membership.mem s l.sum","decl":"/-- Sum of a list of elements in a `Subsemiring` is in the `Subsemiring`. -/\nprotected theorem list_sum_mem {l : List R} : (∀ x ∈ l, x ∈ s) → l.sum ∈ s :=\n  list_sum_mem\n\n"}
{"name":"Subsemiring.multiset_prod_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\ns : Subsemiring R\nm : Multiset R\na✝ : ∀ (a : R), Membership.mem m a → Membership.mem s a\n⊢ Membership.mem s m.prod","decl":"/-- Product of a multiset of elements in a `Subsemiring` of a `CommSemiring`\n    is in the `Subsemiring`. -/\nprotected theorem multiset_prod_mem {R} [CommSemiring R] (s : Subsemiring R) (m : Multiset R) :\n    (∀ a ∈ m, a ∈ s) → m.prod ∈ s :=\n  multiset_prod_mem m\n\n"}
{"name":"Subsemiring.multiset_sum_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Subsemiring R\nm : Multiset R\na✝ : ∀ (a : R), Membership.mem m a → Membership.mem s a\n⊢ Membership.mem s m.sum","decl":"/-- Sum of a multiset of elements in a `Subsemiring` of a `Semiring` is\nin the `add_subsemiring`. -/\nprotected theorem multiset_sum_mem (m : Multiset R) : (∀ a ∈ m, a ∈ s) → m.sum ∈ s :=\n  multiset_sum_mem m\n\n"}
{"name":"Subsemiring.prod_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\ns : Subsemiring R\nι : Type u_2\nt : Finset ι\nf : ι → R\nh : ∀ (c : ι), Membership.mem t c → Membership.mem s (f c)\n⊢ Membership.mem s (t.prod fun i => f i)","decl":"/-- Product of elements of a subsemiring of a `CommSemiring` indexed by a `Finset` is in the\n    subsemiring. -/\nprotected theorem prod_mem {R : Type*} [CommSemiring R] (s : Subsemiring R) {ι : Type*}\n    {t : Finset ι} {f : ι → R} (h : ∀ c ∈ t, f c ∈ s) : (∏ i ∈ t, f i) ∈ s :=\n  prod_mem h\n\n"}
{"name":"Subsemiring.sum_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Subsemiring R\nι : Type u_1\nt : Finset ι\nf : ι → R\nh : ∀ (c : ι), Membership.mem t c → Membership.mem s (f c)\n⊢ Membership.mem s (t.sum fun i => f i)","decl":"/-- Sum of elements in a `Subsemiring` of a `Semiring` indexed by a `Finset`\nis in the `add_subsemiring`. -/\nprotected theorem sum_mem (s : Subsemiring R) {ι : Type*} {t : Finset ι} {f : ι → R}\n    (h : ∀ c ∈ t, f c ∈ s) : (∑ i ∈ t, f i) ∈ s :=\n  sum_mem h\n\n"}
{"name":"Subsemiring.topEquiv_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nr : R\n⊢ Eq (↑(Subsemiring.topEquiv.symm r)) r","decl":"/-- The ring equiv between the top element of `Subsemiring R` and `R`. -/\n@[simps]\ndef topEquiv : (⊤ : Subsemiring R) ≃+* R where\n  toFun r := r\n  invFun r := ⟨r, Subsemiring.mem_top r⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' := (⊤ : Subsemiring R).coe_mul\n  map_add' := (⊤ : Subsemiring R).coe_add\n\n"}
{"name":"Subsemiring.topEquiv_apply","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nr : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (Subsemiring.topEquiv r) ↑r","decl":"/-- The ring equiv between the top element of `Subsemiring R` and `R`. -/\n@[simps]\ndef topEquiv : (⊤ : Subsemiring R) ≃+* R where\n  toFun r := r\n  invFun r := ⟨r, Subsemiring.mem_top r⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' := (⊤ : Subsemiring R).coe_mul\n  map_add' := (⊤ : Subsemiring R).coe_add\n\n"}
{"name":"Subsemiring.comap_toSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Subsemiring S\n⊢ Eq (Subsemiring.comap f s).toSubmonoid { carrier := Set.preimage ⇑f ↑s, mul_mem' := ⋯, one_mem' := ⋯ }","decl":"/-- The preimage of a subsemiring along a ring homomorphism is a subsemiring. -/\n@[simps coe toSubmonoid]\ndef comap (f : R →+* S) (s : Subsemiring S) : Subsemiring R :=\n  { s.toSubmonoid.comap (f : R →* S), s.toAddSubmonoid.comap (f : R →+ S) with carrier := f ⁻¹' s }\n\n"}
{"name":"Subsemiring.coe_comap","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Subsemiring S\n⊢ Eq (↑(Subsemiring.comap f s)) (Set.preimage ⇑f ↑s)","decl":"/-- The preimage of a subsemiring along a ring homomorphism is a subsemiring. -/\n@[simps coe toSubmonoid]\ndef comap (f : R →+* S) (s : Subsemiring S) : Subsemiring R :=\n  { s.toSubmonoid.comap (f : R →* S), s.toAddSubmonoid.comap (f : R →+ S) with carrier := f ⁻¹' s }\n\n"}
{"name":"Subsemiring.mem_comap","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring S\nf : RingHom R S\nx : R\n⊢ Iff (Membership.mem (Subsemiring.comap f s) x) (Membership.mem s (f x))","decl":"@[simp]\ntheorem mem_comap {s : Subsemiring S} {f : R →+* S} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Subsemiring.comap_comap","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\ns : Subsemiring T\ng : RingHom S T\nf : RingHom R S\n⊢ Eq (Subsemiring.comap f (Subsemiring.comap g s)) (Subsemiring.comap (g.comp f) s)","decl":"theorem comap_comap (s : Subsemiring T) (g : S →+* T) (f : R →+* S) :\n    (s.comap g).comap f = s.comap (g.comp f) :=\n  rfl\n\n"}
{"name":"Subsemiring.map_toSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Subsemiring R\n⊢ Eq (Subsemiring.map f s).toSubmonoid { carrier := Set.image ⇑f ↑s, mul_mem' := ⋯, one_mem' := ⋯ }","decl":"/-- The image of a subsemiring along a ring homomorphism is a subsemiring. -/\n@[simps coe toSubmonoid]\ndef map (f : R →+* S) (s : Subsemiring R) : Subsemiring S :=\n  { s.toSubmonoid.map (f : R →* S), s.toAddSubmonoid.map (f : R →+ S) with carrier := f '' s }\n\n"}
{"name":"Subsemiring.coe_map","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Subsemiring R\n⊢ Eq (↑(Subsemiring.map f s)) (Set.image ⇑f ↑s)","decl":"/-- The image of a subsemiring along a ring homomorphism is a subsemiring. -/\n@[simps coe toSubmonoid]\ndef map (f : R →+* S) (s : Subsemiring R) : Subsemiring S :=\n  { s.toSubmonoid.map (f : R →* S), s.toAddSubmonoid.map (f : R →+ S) with carrier := f '' s }\n\n"}
{"name":"Subsemiring.mem_map","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Subsemiring R\ny : S\n⊢ Iff (Membership.mem (Subsemiring.map f s) y) (Exists fun x => And (Membership.mem s x) (Eq (f x) y))","decl":"@[simp]\nlemma mem_map {f : R →+* S} {s : Subsemiring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y := Iff.rfl\n\n"}
{"name":"Subsemiring.map_id","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Subsemiring R\n⊢ Eq (Subsemiring.map (RingHom.id R) s) s","decl":"@[simp]\ntheorem map_id : s.map (RingHom.id R) = s :=\n  SetLike.coe_injective <| Set.image_id _\n\n"}
{"name":"Subsemiring.map_map","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\ns : Subsemiring R\ng : RingHom S T\nf : RingHom R S\n⊢ Eq (Subsemiring.map g (Subsemiring.map f s)) (Subsemiring.map (g.comp f) s)","decl":"theorem map_map (g : S →+* T) (f : R →+* S) : (s.map f).map g = s.map (g.comp f) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n\n"}
{"name":"Subsemiring.map_le_iff_le_comap","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Subsemiring R\nt : Subsemiring S\n⊢ Iff (LE.le (Subsemiring.map f s) t) (LE.le s (Subsemiring.comap f t))","decl":"theorem map_le_iff_le_comap {f : R →+* S} {s : Subsemiring R} {t : Subsemiring S} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n\n"}
{"name":"Subsemiring.gc_map_comap","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ GaloisConnection (Subsemiring.map f) (Subsemiring.comap f)","decl":"theorem gc_map_comap (f : R →+* S) : GaloisConnection (map f) (comap f) := fun _ _ =>\n  map_le_iff_le_comap\n\n"}
{"name":"Subsemiring.coe_equivMapOfInjective_apply","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring R\nf : RingHom R S\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((s.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[simp]\ntheorem coe_equivMapOfInjective_apply (f : R →+* S) (hf : Function.Injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x :=\n  rfl\n\n"}
{"name":"RingHom.rangeS_toSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Eq f.rangeS.toSubmonoid { carrier := Set.range ⇑f, mul_mem' := ⋯, one_mem' := ⋯ }","decl":"/-- The range of a ring homomorphism is a subsemiring. See Note [range copy pattern]. -/\n@[simps! coe toSubmonoid]\ndef rangeS : Subsemiring S :=\n  ((⊤ : Subsemiring R).map f).copy (Set.range f) Set.image_univ.symm\n\n"}
{"name":"RingHom.coe_rangeS","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Eq (↑f.rangeS) (Set.range ⇑f)","decl":"/-- The range of a ring homomorphism is a subsemiring. See Note [range copy pattern]. -/\n@[simps! coe toSubmonoid]\ndef rangeS : Subsemiring S :=\n  ((⊤ : Subsemiring R).map f).copy (Set.range f) Set.image_univ.symm\n\n"}
{"name":"RingHom.mem_rangeS","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ny : S\n⊢ Iff (Membership.mem f.rangeS y) (Exists fun x => Eq (f x) y)","decl":"@[simp]\ntheorem mem_rangeS {f : R →+* S} {y : S} : y ∈ f.rangeS ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"RingHom.rangeS_eq_map","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Eq f.rangeS (Subsemiring.map f Top.top)","decl":"theorem rangeS_eq_map (f : R →+* S) : f.rangeS = (⊤ : Subsemiring R).map f := by\n  ext\n  simp\n\n"}
{"name":"RingHom.mem_rangeS_self","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nx : R\n⊢ Membership.mem f.rangeS (f x)","decl":"theorem mem_rangeS_self (f : R →+* S) (x : R) : f x ∈ f.rangeS :=\n  mem_rangeS.mpr ⟨x, rfl⟩\n\n"}
{"name":"RingHom.map_rangeS","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\ng : RingHom S T\nf : RingHom R S\n⊢ Eq (Subsemiring.map g f.rangeS) (g.comp f).rangeS","decl":"theorem map_rangeS : f.rangeS.map g = (g.comp f).rangeS := by\n  simpa only [rangeS_eq_map] using (⊤ : Subsemiring R).map_map g f\n\n"}
{"name":"Subsemiring.coe_bot","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Eq (↑Bot.bot) (Set.range Nat.cast)","decl":"theorem coe_bot : ((⊥ : Subsemiring R) : Set R) = Set.range ((↑) : ℕ → R) :=\n  (Nat.castRingHom R).coe_rangeS\n\n"}
{"name":"Subsemiring.mem_bot","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nx : R\n⊢ Iff (Membership.mem Bot.bot x) (Exists fun n => Eq (↑n) x)","decl":"theorem mem_bot {x : R} : x ∈ (⊥ : Subsemiring R) ↔ ∃ n : ℕ, ↑n = x :=\n  RingHom.mem_rangeS\n\n"}
{"name":"Subsemiring.coe_sInf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nS : Set (Subsemiring R)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (Subsemiring R)) : ((sInf S : Subsemiring R) : Set R) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"Subsemiring.mem_sInf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nS : Set (Subsemiring R)\nx : R\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : Subsemiring R), Membership.mem S p → Membership.mem p x)","decl":"theorem mem_sInf {S : Set (Subsemiring R)} {x : R} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"Subsemiring.coe_iInf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nι : Sort u_1\nS : ι → Subsemiring R\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf {ι : Sort*} {S : ι → Subsemiring R} : (↑(⨅ i, S i) : Set R) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"Subsemiring.mem_iInf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nι : Sort u_1\nS : ι → Subsemiring R\nx : R\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"theorem mem_iInf {ι : Sort*} {S : ι → Subsemiring R} {x : R} : (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"Subsemiring.sInf_toSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set (Subsemiring R)\n⊢ Eq (InfSet.sInf s).toSubmonoid (iInf fun t => iInf fun h => t.toSubmonoid)","decl":"@[simp]\ntheorem sInf_toSubmonoid (s : Set (Subsemiring R)) :\n    (sInf s).toSubmonoid = ⨅ t ∈ s, Subsemiring.toSubmonoid t :=\n  mk'_toSubmonoid _ _\n\n"}
{"name":"Subsemiring.sInf_toAddSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set (Subsemiring R)\n⊢ Eq (InfSet.sInf s).toAddSubmonoid (iInf fun t => iInf fun h => t.toAddSubmonoid)","decl":"@[simp]\ntheorem sInf_toAddSubmonoid (s : Set (Subsemiring R)) :\n    (sInf s).toAddSubmonoid = ⨅ t ∈ s, Subsemiring.toAddSubmonoid t :=\n  mk'_toAddSubmonoid _ _\n\n"}
{"name":"Subsemiring.eq_top_iff'","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nA : Subsemiring R\n⊢ Iff (Eq A Top.top) (∀ (x : R), Membership.mem A x)","decl":"theorem eq_top_iff' (A : Subsemiring R) : A = ⊤ ↔ ∀ x : R, x ∈ A :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"Subsemiring.center_toSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Eq (Subsemiring.center R).toSubmonoid { carrier := (NonUnitalSubsemiring.center R).carrier, mul_mem' := ⋯, one_mem' := ⋯ }","decl":"/-- The center of a non-associative semiring `R` is the set of elements that commute and associate\nwith everything in `R` -/\n@[simps coe toSubmonoid]\ndef center : Subsemiring R :=\n  { NonUnitalSubsemiring.center R with\n    one_mem' := Set.one_mem_center }\n\n"}
{"name":"Subsemiring.coe_center","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Eq (↑(Subsemiring.center R)) (NonUnitalSubsemiring.center R).carrier","decl":"/-- The center of a non-associative semiring `R` is the set of elements that commute and associate\nwith everything in `R` -/\n@[simps coe toSubmonoid]\ndef center : Subsemiring R :=\n  { NonUnitalSubsemiring.center R with\n    one_mem' := Set.one_mem_center }\n\n"}
{"name":"Subsemiring.centerCongr_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\ns : Subtype fun x => Membership.mem (Subsemigroup.center S) x\n⊢ Eq (↑((Subsemiring.centerCongr e).symm s)) ((↑e).symm ↑s)","decl":"/-- The center of isomorphic (not necessarily associative) semirings are isomorphic. -/\n@[simps!] def centerCongr [NonAssocSemiring S] (e : R ≃+* S) : center R ≃+* center S :=\n  NonUnitalSubsemiring.centerCongr e\n\n"}
{"name":"Subsemiring.centerCongr_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\nr : Subtype fun x => Membership.mem (Subsemigroup.center R) x\n⊢ Eq (↑((Subsemiring.centerCongr e) r)) (e ↑r)","decl":"/-- The center of isomorphic (not necessarily associative) semirings are isomorphic. -/\n@[simps!] def centerCongr [NonAssocSemiring S] (e : R ≃+* S) : center R ≃+* center S :=\n  NonUnitalSubsemiring.centerCongr e\n\n"}
{"name":"Subsemiring.centerToMulOpposite_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nr : Subtype fun x => Membership.mem (Subsemigroup.center R) x\n⊢ Eq (↑(Subsemiring.centerToMulOpposite r)) (MulOpposite.op ↑r)","decl":"/-- The center of a (not necessarily associative) semiring\nis isomorphic to the center of its opposite. -/\n@[simps!] def centerToMulOpposite : center R ≃+* center Rᵐᵒᵖ :=\n  NonUnitalSubsemiring.centerToMulOpposite\n\n"}
{"name":"Subsemiring.centerToMulOpposite_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nr : Subtype fun x => Membership.mem (Subsemigroup.center (MulOpposite R)) x\n⊢ Eq (↑(Subsemiring.centerToMulOpposite.symm r)) (MulOpposite.unop ↑r)","decl":"/-- The center of a (not necessarily associative) semiring\nis isomorphic to the center of its opposite. -/\n@[simps!] def centerToMulOpposite : center R ≃+* center Rᵐᵒᵖ :=\n  NonUnitalSubsemiring.centerToMulOpposite\n\n"}
{"name":"Subsemiring.mem_center_iff","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nz : R\n⊢ Iff (Membership.mem (Subsemiring.center R) z) (∀ (g : R), Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"theorem mem_center_iff {R} [Semiring R] {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g :=\n  Subsemigroup.mem_center_iff\n\n"}
{"name":"Subsemiring.center_eq_top","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\n⊢ Eq (Subsemiring.center R) Top.top","decl":"@[simp]\ntheorem center_eq_top (R) [CommSemiring R] : center R = ⊤ :=\n  SetLike.coe_injective (Set.center_eq_univ R)\n\n"}
{"name":"Subsemiring.coe_centralizer","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\n⊢ Eq (↑(Subsemiring.centralizer s)) s.centralizer","decl":"@[simp, norm_cast]\ntheorem coe_centralizer {R} [Semiring R] (s : Set R) : (centralizer s : Set R) = s.centralizer :=\n  rfl\n\n"}
{"name":"Subsemiring.centralizer_toSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\n⊢ Eq (Subsemiring.centralizer s).toSubmonoid (Submonoid.centralizer s)","decl":"theorem centralizer_toSubmonoid {R} [Semiring R] (s : Set R) :\n    (centralizer s).toSubmonoid = Submonoid.centralizer s :=\n  rfl\n\n"}
{"name":"Subsemiring.mem_centralizer_iff","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\nz : R\n⊢ Iff (Membership.mem (Subsemiring.centralizer s) z) (∀ (g : R), Membership.mem s g → Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"theorem mem_centralizer_iff {R} [Semiring R] {s : Set R} {z : R} :\n    z ∈ centralizer s ↔ ∀ g ∈ s, g * z = z * g :=\n  Iff.rfl\n\n"}
{"name":"Subsemiring.center_le_centralizer","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\n⊢ LE.le (Subsemiring.center R) (Subsemiring.centralizer s)","decl":"theorem center_le_centralizer {R} [Semiring R] (s) : center R ≤ centralizer s :=\n  s.center_subset_centralizer\n\n"}
{"name":"Subsemiring.centralizer_le","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (Subsemiring.centralizer t) (Subsemiring.centralizer s)","decl":"theorem centralizer_le {R} [Semiring R] (s t : Set R) (h : s ⊆ t) : centralizer t ≤ centralizer s :=\n  Set.centralizer_subset h\n\n"}
{"name":"Subsemiring.centralizer_eq_top_iff_subset","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\n⊢ Iff (Eq (Subsemiring.centralizer s) Top.top) (HasSubset.Subset s ↑(Subsemiring.center R))","decl":"@[simp]\ntheorem centralizer_eq_top_iff_subset {R} [Semiring R] {s : Set R} :\n    centralizer s = ⊤ ↔ s ⊆ center R :=\n  SetLike.ext'_iff.trans Set.centralizer_eq_top_iff_subset\n\n"}
{"name":"Subsemiring.centralizer_univ","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Eq (Subsemiring.centralizer Set.univ) (Subsemiring.center R)","decl":"@[simp]\ntheorem centralizer_univ {R} [Semiring R] : centralizer Set.univ = center R :=\n  SetLike.ext' (Set.centralizer_univ R)\n\n"}
{"name":"Subsemiring.le_centralizer_centralizer","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Subsemiring R\n⊢ LE.le s (Subsemiring.centralizer ↑(Subsemiring.centralizer ↑s))","decl":"lemma le_centralizer_centralizer {R} [Semiring R] {s : Subsemiring R} :\n    s ≤ centralizer (centralizer (s : Set R)) :=\n  Set.subset_centralizer_centralizer\n\n"}
{"name":"Subsemiring.centralizer_centralizer_centralizer","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\n⊢ Eq (Subsemiring.centralizer s.centralizer.centralizer) (Subsemiring.centralizer s)","decl":"@[simp]\nlemma centralizer_centralizer_centralizer {R} [Semiring R] {s : Set R} :\n    centralizer s.centralizer.centralizer = centralizer s := by\n  apply SetLike.coe_injective\n  simp only [coe_centralizer, Set.centralizer_centralizer_centralizer]\n\n"}
{"name":"Subsemiring.mem_closure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nx : R\ns : Set R\n⊢ Iff (Membership.mem (Subsemiring.closure s) x) (∀ (S : Subsemiring R), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"theorem mem_closure {x : R} {s : Set R} : x ∈ closure s ↔ ∀ S : Subsemiring R, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"Subsemiring.subset_closure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\n⊢ HasSubset.Subset s ↑(Subsemiring.closure s)","decl":"/-- The subsemiring generated by a set includes the set. -/\n@[simp, aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_closure {s : Set R} : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"Subsemiring.not_mem_of_not_mem_closure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\nP : R\nhP : Not (Membership.mem (Subsemiring.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"Subsemiring.closure_le","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\nt : Subsemiring R\n⊢ Iff (LE.le (Subsemiring.closure s) t) (HasSubset.Subset s ↑t)","decl":"/-- A subsemiring `S` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set R} {t : Subsemiring R} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"Subsemiring.closure_mono","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (Subsemiring.closure s) (Subsemiring.closure t)","decl":"/-- Subsemiring closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[gcongr]\ntheorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n\n"}
{"name":"Subsemiring.closure_eq_of_le","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\nt : Subsemiring R\nh₁ : HasSubset.Subset s ↑t\nh₂ : LE.le t (Subsemiring.closure s)\n⊢ Eq (Subsemiring.closure s) t","decl":"theorem closure_eq_of_le {s : Set R} {t : Subsemiring R} (h₁ : s ⊆ t) (h₂ : t ≤ closure s) :\n    closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"Subsemiring.mem_map_equiv","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\nK : Subsemiring R\nx : S\n⊢ Iff (Membership.mem (Subsemiring.map (↑f) K) x) (Membership.mem K (f.symm x))","decl":"theorem mem_map_equiv {f : R ≃+* S} {K : Subsemiring R} {x : S} :\n    x ∈ K.map (f : R →+* S) ↔ f.symm x ∈ K := by\n  convert @Set.mem_image_equiv _ _ (↑K) f.toEquiv x using 1\n\n"}
{"name":"Subsemiring.map_equiv_eq_comap_symm","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\nK : Subsemiring R\n⊢ Eq (Subsemiring.map (↑f) K) (Subsemiring.comap (↑f.symm) K)","decl":"theorem map_equiv_eq_comap_symm (f : R ≃+* S) (K : Subsemiring R) :\n    K.map (f : R →+* S) = K.comap f.symm :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"Subsemiring.comap_equiv_eq_map_symm","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingEquiv R S\nK : Subsemiring S\n⊢ Eq (Subsemiring.comap (↑f) K) (Subsemiring.map (↑f.symm) K)","decl":"theorem comap_equiv_eq_map_symm (f : R ≃+* S) (K : Subsemiring S) :\n    K.comap (f : R →+* S) = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"Submonoid.subsemiringClosure_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nM : Submonoid R\n⊢ Eq ↑M.subsemiringClosure ↑(AddSubmonoid.closure ↑M)","decl":"theorem subsemiringClosure_coe :\n    (M.subsemiringClosure : Set R) = AddSubmonoid.closure (M : Set R) :=\n  rfl\n\n"}
{"name":"Submonoid.subsemiringClosure_mem","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nM : Submonoid R\nx : R\n⊢ Iff (Membership.mem M.subsemiringClosure x) (Membership.mem (AddSubmonoid.closure ↑M) x)","decl":"theorem subsemiringClosure_mem {x : R} :\n    x ∈ M.subsemiringClosure ↔ x ∈ AddSubmonoid.closure (M : Set R) :=\n  Iff.rfl\n\n"}
{"name":"Submonoid.subsemiringClosure_toAddSubmonoid","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nM : Submonoid R\n⊢ Eq M.subsemiringClosure.toAddSubmonoid (AddSubmonoid.closure ↑M)","decl":"theorem subsemiringClosure_toAddSubmonoid :\n    M.subsemiringClosure.toAddSubmonoid = AddSubmonoid.closure (M : Set R) :=\n  rfl\n\n"}
{"name":"Submonoid.subsemiringClosure_toNonUnitalSubsemiring","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nM : Submonoid R\n⊢ Eq M.subsemiringClosure.toNonUnitalSubsemiring (NonUnitalSubsemiring.closure ↑M)","decl":"@[simp] lemma subsemiringClosure_toNonUnitalSubsemiring (M : Submonoid R) :\n    M.subsemiringClosure.toNonUnitalSubsemiring = .closure M := by\n  refine Eq.symm (NonUnitalSubsemiring.closure_eq_of_le ?_ fun _ hx ↦ ?_)\n  · simp [Submonoid.subsemiringClosure_coe]\n  · simp [Submonoid.subsemiringClosure_mem] at hx\n    induction hx using AddSubmonoid.closure_induction <;> aesop\n\n"}
{"name":"Submonoid.subsemiringClosure_eq_closure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nM : Submonoid R\n⊢ Eq M.subsemiringClosure (Subsemiring.closure ↑M)","decl":"/-- The `Subsemiring` generated by a multiplicative submonoid coincides with the\n`Subsemiring.closure` of the submonoid itself . -/\ntheorem subsemiringClosure_eq_closure : M.subsemiringClosure = Subsemiring.closure (M : Set R) := by\n  ext\n  refine\n    ⟨fun hx => ?_, fun hx =>\n      (Subsemiring.mem_closure.mp hx) M.subsemiringClosure fun s sM => ?_⟩\n  <;> rintro - ⟨H1, rfl⟩\n  <;> rintro - ⟨H2, rfl⟩\n  · exact AddSubmonoid.mem_closure.mp hx H1.toAddSubmonoid H2\n  · exact H2 sM\n\n"}
{"name":"Subsemiring.closure_submonoid_closure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\n⊢ Eq (Subsemiring.closure ↑(Submonoid.closure s)) (Subsemiring.closure s)","decl":"@[simp]\ntheorem closure_submonoid_closure (s : Set R) : closure ↑(Submonoid.closure s) = closure s :=\n  le_antisymm\n    (closure_le.mpr fun _ hy =>\n      (Submonoid.mem_closure.mp hy) (closure s).toSubmonoid subset_closure)\n    (closure_mono Submonoid.subset_closure)\n\n"}
{"name":"Subsemiring.coe_closure_eq","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\n⊢ Eq ↑(Subsemiring.closure s) ↑(AddSubmonoid.closure ↑(Submonoid.closure s))","decl":"/-- The elements of the subsemiring closure of `M` are exactly the elements of the additive closure\nof a multiplicative submonoid `M`. -/\ntheorem coe_closure_eq (s : Set R) :\n    (closure s : Set R) = AddSubmonoid.closure (Submonoid.closure s : Set R) := by\n  simp [← Submonoid.subsemiringClosure_toAddSubmonoid, Submonoid.subsemiringClosure_eq_closure]\n\n"}
{"name":"Subsemiring.mem_closure_iff","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\nx : R\n⊢ Iff (Membership.mem (Subsemiring.closure s) x) (Membership.mem (AddSubmonoid.closure ↑(Submonoid.closure s)) x)","decl":"theorem mem_closure_iff {s : Set R} {x} :\n    x ∈ closure s ↔ x ∈ AddSubmonoid.closure (Submonoid.closure s : Set R) :=\n  Set.ext_iff.mp (coe_closure_eq s) x\n\n"}
{"name":"Subsemiring.closure_addSubmonoid_closure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\n⊢ Eq (Subsemiring.closure ↑(AddSubmonoid.closure s)) (Subsemiring.closure s)","decl":"@[simp]\ntheorem closure_addSubmonoid_closure {s : Set R} :\n    closure ↑(AddSubmonoid.closure s) = closure s := by\n  ext x\n  refine ⟨fun hx => ?_, fun hx => closure_mono AddSubmonoid.subset_closure hx⟩\n  rintro - ⟨H, rfl⟩\n  rintro - ⟨J, rfl⟩\n  refine (AddSubmonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.toAddSubmonoid fun y hy => ?_\n  refine (Submonoid.mem_closure.mp hy) H.toSubmonoid fun z hz => ?_\n  exact (AddSubmonoid.mem_closure.mp hz) H.toAddSubmonoid fun w hw => J hw\n\n"}
{"name":"Subsemiring.closure_induction","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\np : (x : R) → Membership.mem (Subsemiring.closure s) x → Prop\nmem : ∀ (x : R) (hx : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\none : p 1 ⋯\nadd : ∀ (x y : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nmul : ∀ (x y : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : R\nhx : Membership.mem (Subsemiring.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : (x : R) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (hx : x ∈ s), p x (subset_closure hx))\n    (zero : p 0 (zero_mem _)) (one : p 1 (one_mem _))\n    (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (add_mem hx hy))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x} (hx : x ∈ closure s)  : p x hx :=\n  let K : Subsemiring R :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩\n      add_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, add _ _ _ _ hpx hpy⟩\n      one_mem' := ⟨_, one⟩\n      zero_mem' := ⟨_, zero⟩ }\n  closure_le (t := K) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"Subsemiring.closure_induction'","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\np : (x : R) → Membership.mem (Subsemiring.closure s) x → Prop\nmem : ∀ (x : R) (hx : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\none : p 1 ⋯\nadd : ∀ (x y : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nmul : ∀ (x y : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : R\nhx : Membership.mem (Subsemiring.closure s) x\n⊢ p x hx","decl":"@[deprecated closure_induction (since := \"2024-10-10\")]\nalias closure_induction' := closure_induction\n\n"}
{"name":"Subsemiring.closure_induction₂","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set R\np : (x y : R) → Membership.mem (Subsemiring.closure s) x → Membership.mem (Subsemiring.closure s) y → Prop\nmem_mem : ∀ (x y : R) (hx : Membership.mem s x) (hy : Membership.mem s y), p x y ⋯ ⋯\nzero_left : ∀ (x : R) (hx : Membership.mem (Subsemiring.closure s) x), p 0 x ⋯ hx\nzero_right : ∀ (x : R) (hx : Membership.mem (Subsemiring.closure s) x), p x 0 hx ⋯\none_left : ∀ (x : R) (hx : Membership.mem (Subsemiring.closure s) x), p 1 x ⋯ hx\none_right : ∀ (x : R) (hx : Membership.mem (Subsemiring.closure s) x), p x 1 hx ⋯\nadd_left : ∀ (x y z : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y) (hz : Membership.mem (Subsemiring.closure s) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nadd_right : ∀ (x y z : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y) (hz : Membership.mem (Subsemiring.closure s) z), p x y hx hy → p x z hx hz → p x (HAdd.hAdd y z) hx ⋯\nmul_left : ∀ (x y z : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y) (hz : Membership.mem (Subsemiring.closure s) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (x y z : R) (hx : Membership.mem (Subsemiring.closure s) x) (hy : Membership.mem (Subsemiring.closure s) y) (hz : Membership.mem (Subsemiring.closure s) z), p x y hx hy → p x z hx hz → p x (HMul.hMul y z) hx ⋯\nx y : R\nhx : Membership.mem (Subsemiring.closure s) x\nhy : Membership.mem (Subsemiring.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[elab_as_elim]\ntheorem closure_induction₂ {s : Set R} {p : (x y : R) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem_mem : ∀ (x) (y) (hx : x ∈ s) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (zero_left : ∀ x hx, p 0 x (zero_mem _) hx) (zero_right : ∀ x hx, p x 0 hx (zero_mem _))\n    (one_left : ∀ x hx, p 1 x (one_mem _) hx) (one_right : ∀ x hx, p x 1 hx (one_mem _))\n    (add_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x + y) z (add_mem hx hy) hz)\n    (add_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y + z) hx (add_mem hy hz))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y * z) hx (mul_mem hy hz))\n    {x y : R} (hx : x ∈ closure s) (hy : y ∈ closure s) :\n    p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem_mem _ _ h hz\n    | zero => exact zero_left _ _\n    | one => exact one_left _ _\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | add _ _ _ _ h₁ h₂ => exact add_left _ _ _ _ _ _ h₁ h₂\n  | zero => exact zero_right x hx\n  | one => exact one_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ _ h₁ h₂\n  | add _ _ _ _ h₁ h₂ => exact add_right _ _ _ _ _ _ h₁ h₂\n\n"}
{"name":"Subsemiring.mem_closure_iff_exists_list","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : Set R\nx : R\n⊢ Iff (Membership.mem (Subsemiring.closure s) x) (Exists fun L => And (∀ (t : List R), Membership.mem L t → ∀ (y : R), Membership.mem t y → Membership.mem s y) (Eq (List.map List.prod L).sum x))","decl":"theorem mem_closure_iff_exists_list {R} [Semiring R] {s : Set R} {x} :\n    x ∈ closure s ↔ ∃ L : List (List R), (∀ t ∈ L, ∀ y ∈ t, y ∈ s) ∧ (L.map List.prod).sum = x := by\n  constructor\n  · intro hx\n    rw [mem_closure_iff] at hx\n    induction hx using AddSubmonoid.closure_induction with\n    | mem x hx =>\n      suffices ∃ t : List R, (∀ y ∈ t, y ∈ s) ∧ t.prod = x from\n        let ⟨t, ht1, ht2⟩ := this\n        ⟨[t], List.forall_mem_singleton.2 ht1, by\n          rw [List.map_singleton, List.sum_singleton, ht2]⟩\n      induction hx using Submonoid.closure_induction with\n      | mem x hx => exact ⟨[x], List.forall_mem_singleton.2 hx, List.prod_singleton⟩\n      | one => exact ⟨[], List.forall_mem_nil _, rfl⟩\n      | mul x y _ _ ht hu =>\n        obtain ⟨⟨t, ht1, ht2⟩, ⟨u, hu1, hu2⟩⟩ := And.intro ht hu\n        exact ⟨t ++ u, List.forall_mem_append.2 ⟨ht1, hu1⟩, by rw [List.prod_append, ht2, hu2]⟩\n    | one => exact ⟨[], List.forall_mem_nil _, rfl⟩\n    | mul x y _ _ hL hM =>\n      obtain ⟨⟨L, HL1, HL2⟩, ⟨M, HM1, HM2⟩⟩ := And.intro hL hM\n      exact ⟨L ++ M, List.forall_mem_append.2 ⟨HL1, HM1⟩, by\n        rw [List.map_append, List.sum_append, HL2, HM2]⟩\n  · rintro ⟨L, HL1, HL2⟩\n    exact HL2 ▸\n      list_sum_mem fun r hr =>\n        let ⟨t, ht1, ht2⟩ := List.mem_map.1 hr\n        ht2 ▸ list_prod_mem _ fun y hy => subset_closure <| HL1 t ht1 y hy\n\n"}
{"name":"Subsemiring.closure_eq","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Subsemiring R\n⊢ Eq (Subsemiring.closure ↑s) s","decl":"/-- Closure of a subsemiring `S` equals `S`. -/\n@[simp]\ntheorem closure_eq (s : Subsemiring R) : closure (s : Set R) = s :=\n  (Subsemiring.gi R).l_u_eq s\n\n"}
{"name":"Subsemiring.closure_empty","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Eq (Subsemiring.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem closure_empty : closure (∅ : Set R) = ⊥ :=\n  (Subsemiring.gi R).gc.l_bot\n\n"}
{"name":"Subsemiring.closure_univ","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\n⊢ Eq (Subsemiring.closure Set.univ) Top.top","decl":"@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = ⊤ :=\n  @coe_top R _ ▸ closure_eq ⊤\n\n"}
{"name":"Subsemiring.closure_union","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns t : Set R\n⊢ Eq (Subsemiring.closure (Union.union s t)) (Max.max (Subsemiring.closure s) (Subsemiring.closure t))","decl":"theorem closure_union (s t : Set R) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (Subsemiring.gi R).gc.l_sup\n\n"}
{"name":"Subsemiring.closure_iUnion","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nι : Sort u_1\ns : ι → Set R\n⊢ Eq (Subsemiring.closure (Set.iUnion fun i => s i)) (iSup fun i => Subsemiring.closure (s i))","decl":"theorem closure_iUnion {ι} (s : ι → Set R) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (Subsemiring.gi R).gc.l_iSup\n\n"}
{"name":"Subsemiring.closure_sUnion","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Set (Set R)\n⊢ Eq (Subsemiring.closure s.sUnion) (iSup fun t => iSup fun h => Subsemiring.closure t)","decl":"theorem closure_sUnion (s : Set (Set R)) : closure (⋃₀ s) = ⨆ t ∈ s, closure t :=\n  (Subsemiring.gi R).gc.l_sSup\n\n"}
{"name":"Subsemiring.map_sup","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns t : Subsemiring R\nf : RingHom R S\n⊢ Eq (Subsemiring.map f (Max.max s t)) (Max.max (Subsemiring.map f s) (Subsemiring.map f t))","decl":"theorem map_sup (s t : Subsemiring R) (f : R →+* S) : (s ⊔ t).map f = s.map f ⊔ t.map f :=\n  (gc_map_comap f).l_sup\n\n"}
{"name":"Subsemiring.map_iSup","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nι : Sort u_1\nf : RingHom R S\ns : ι → Subsemiring R\n⊢ Eq (Subsemiring.map f (iSup s)) (iSup fun i => Subsemiring.map f (s i))","decl":"theorem map_iSup {ι : Sort*} (f : R →+* S) (s : ι → Subsemiring R) :\n    (iSup s).map f = ⨆ i, (s i).map f :=\n  (gc_map_comap f).l_iSup\n\n"}
{"name":"Subsemiring.map_inf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns t : Subsemiring R\nf : RingHom R S\nhf : Function.Injective ⇑f\n⊢ Eq (Subsemiring.map f (Min.min s t)) (Min.min (Subsemiring.map f s) (Subsemiring.map f t))","decl":"theorem map_inf (s t : Subsemiring R) (f : R →+* S) (hf : Function.Injective f) :\n    (s ⊓ t).map f = s.map f ⊓ t.map f := SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"Subsemiring.map_iInf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\nι : Sort u_1\ninst✝ : Nonempty ι\nf : RingHom R S\nhf : Function.Injective ⇑f\ns : ι → Subsemiring R\n⊢ Eq (Subsemiring.map f (iInf s)) (iInf fun i => Subsemiring.map f (s i))","decl":"theorem map_iInf {ι : Sort*} [Nonempty ι] (f : R →+* S) (hf : Function.Injective f)\n    (s : ι → Subsemiring R) : (iInf s).map f = ⨅ i, (s i).map f := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"Subsemiring.comap_inf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns t : Subsemiring S\nf : RingHom R S\n⊢ Eq (Subsemiring.comap f (Min.min s t)) (Min.min (Subsemiring.comap f s) (Subsemiring.comap f t))","decl":"theorem comap_inf (s t : Subsemiring S) (f : R →+* S) : (s ⊓ t).comap f = s.comap f ⊓ t.comap f :=\n  (gc_map_comap f).u_inf\n\n"}
{"name":"Subsemiring.comap_iInf","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nι : Sort u_1\nf : RingHom R S\ns : ι → Subsemiring S\n⊢ Eq (Subsemiring.comap f (iInf s)) (iInf fun i => Subsemiring.comap f (s i))","decl":"theorem comap_iInf {ι : Sort*} (f : R →+* S) (s : ι → Subsemiring S) :\n    (iInf s).comap f = ⨅ i, (s i).comap f :=\n  (gc_map_comap f).u_iInf\n\n"}
{"name":"Subsemiring.map_bot","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Eq (Subsemiring.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : R →+* S) : (⊥ : Subsemiring R).map f = ⊥ :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"Subsemiring.comap_top","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Eq (Subsemiring.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top (f : R →+* S) : (⊤ : Subsemiring S).comap f = ⊤ :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"Subsemiring.coe_prod","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring R\nt : Subsemiring S\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[norm_cast]\ntheorem coe_prod (s : Subsemiring R) (t : Subsemiring S) :\n    (s.prod t : Set (R × S)) = (s : Set R) ×ˢ (t : Set S) :=\n  rfl\n\n"}
{"name":"Subsemiring.mem_prod","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring R\nt : Subsemiring S\np : Prod R S\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"theorem mem_prod {s : Subsemiring R} {t : Subsemiring S} {p : R × S} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"Subsemiring.prod_mono","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns₁ s₂ : Subsemiring R\nhs : LE.le s₁ s₂\nt₁ t₂ : Subsemiring S\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[gcongr, mono]\ntheorem prod_mono ⦃s₁ s₂ : Subsemiring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : Subsemiring S⦄ (ht : t₁ ≤ t₂) :\n    s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"Subsemiring.prod_mono_right","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring R\n⊢ Monotone fun t => s.prod t","decl":"theorem prod_mono_right (s : Subsemiring R) : Monotone fun t : Subsemiring S => s.prod t :=\n  prod_mono (le_refl s)\n\n"}
{"name":"Subsemiring.prod_mono_left","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nt : Subsemiring S\n⊢ Monotone fun s => s.prod t","decl":"theorem prod_mono_left (t : Subsemiring S) : Monotone fun s : Subsemiring R => s.prod t :=\n  fun _ _ hs => prod_mono hs (le_refl t)\n\n"}
{"name":"Subsemiring.prod_top","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring R\n⊢ Eq (s.prod Top.top) (Subsemiring.comap (RingHom.fst R S) s)","decl":"theorem prod_top (s : Subsemiring R) : s.prod (⊤ : Subsemiring S) = s.comap (RingHom.fst R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"Subsemiring.top_prod","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring S\n⊢ Eq (Top.top.prod s) (Subsemiring.comap (RingHom.snd R S) s)","decl":"theorem top_prod (s : Subsemiring S) : (⊤ : Subsemiring R).prod s = s.comap (RingHom.snd R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"Subsemiring.top_prod_top","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[simp]\ntheorem top_prod_top : (⊤ : Subsemiring R).prod (⊤ : Subsemiring S) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"Subsemiring.mem_iSup_of_directed","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nι : Sort u_1\nhι : Nonempty ι\nS : ι → Subsemiring R\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : R\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"theorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Subsemiring R} (hS : Directed (· ≤ ·) S)\n    {x : R} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  let U : Subsemiring R :=\n    Subsemiring.mk' (⋃ i, (S i : Set R))\n      (⨆ i, (S i).toSubmonoid) (Submonoid.coe_iSup_of_directed hS)\n      (⨆ i, (S i).toAddSubmonoid) (AddSubmonoid.coe_iSup_of_directed hS)\n  -- Porting note: gave the hypothesis an explicit name because `@this` doesn't work\n  suffices h : ⨆ i, S i ≤ U by simpa [U] using @h x\n  exact iSup_le fun i x hx ↦ Set.mem_iUnion.2 ⟨i, hx⟩\n\n"}
{"name":"Subsemiring.coe_iSup_of_directed","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nι : Sort u_1\nhι : Nonempty ι\nS : ι → Subsemiring R\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"theorem coe_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → Subsemiring R}\n    (hS : Directed (· ≤ ·) S) : ((⨆ i, S i : Subsemiring R) : Set R) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"Subsemiring.mem_sSup_of_directedOn","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nS : Set (Subsemiring R)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : R\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"theorem mem_sSup_of_directedOn {S : Set (Subsemiring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) {x : R} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, SetCoe.exists, Subtype.coe_mk,\n    exists_prop]\n\n"}
{"name":"Subsemiring.coe_sSup_of_directedOn","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nS : Set (Subsemiring R)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"theorem coe_sSup_of_directedOn {S : Set (Subsemiring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set R) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directedOn Sne hS]\n\n"}
{"name":"RingHom.codRestrict_apply","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\nσS : Type u_2\ninst✝¹ : SetLike σS S\ninst✝ : SubsemiringClass σS S\nf : RingHom R S\ns : σS\nh : ∀ (x : R), Membership.mem s (f x)\nx : R\n⊢ Eq (↑((f.codRestrict s h) x)) (f x)","decl":"@[simp]\ntheorem codRestrict_apply (f : R →+* S) (s : σS) (h : ∀ x, f x ∈ s) (x : R) :\n    (f.codRestrict s h x : S) = f x :=\n  rfl\n\n"}
{"name":"RingHom.coe_restrict_apply","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : NonAssocSemiring R\ninst✝⁴ : NonAssocSemiring S\nσR : Type u_1\nσS : Type u_2\ninst✝³ : SetLike σR R\ninst✝² : SetLike σS S\ninst✝¹ : SubsemiringClass σR R\ninst✝ : SubsemiringClass σS S\nf : RingHom R S\ns' : σR\ns : σS\nh : ∀ (x : R), Membership.mem s' x → Membership.mem s (f x)\nx : Subtype fun x => Membership.mem s' x\n⊢ Eq (↑((f.restrict s' s h) x)) (f ↑x)","decl":"@[simp]\ntheorem coe_restrict_apply (f : R →+* S) (s' : σR) (s : σS) (h : ∀ x ∈ s', f x ∈ s) (x : s') :\n    (f.restrict s' s h x : S) = f x :=\n  rfl\n\n"}
{"name":"RingHom.comp_restrict","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : NonAssocSemiring R\ninst✝⁴ : NonAssocSemiring S\nσR : Type u_1\nσS : Type u_2\ninst✝³ : SetLike σR R\ninst✝² : SetLike σS S\ninst✝¹ : SubsemiringClass σR R\ninst✝ : SubsemiringClass σS S\nf : RingHom R S\ns' : σR\ns : σS\nh : ∀ (x : R), Membership.mem s' x → Membership.mem s (f x)\n⊢ Eq ((SubsemiringClass.subtype s).comp (f.restrict s' s h)) (f.comp (SubsemiringClass.subtype s'))","decl":"@[simp]\ntheorem comp_restrict (f : R →+* S) (s' : σR) (s : σS) (h : ∀ x ∈ s', f x ∈ s) :\n    (SubsemiringClass.subtype s).comp (f.restrict s' s h) = f.comp (SubsemiringClass.subtype s') :=\n  rfl\n\n"}
{"name":"RingHom.coe_rangeSRestrict","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nx : R\n⊢ Eq (↑(f.rangeSRestrict x)) (f x)","decl":"@[simp]\ntheorem coe_rangeSRestrict (f : R →+* S) (x : R) : (f.rangeSRestrict x : S) = f x :=\n  rfl\n\n"}
{"name":"RingHom.rangeSRestrict_surjective","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Function.Surjective ⇑f.rangeSRestrict","decl":"theorem rangeSRestrict_surjective (f : R →+* S) : Function.Surjective f.rangeSRestrict :=\n  fun ⟨_, hy⟩ =>\n  let ⟨x, hx⟩ := mem_rangeS.mp hy\n  ⟨x, Subtype.ext hx⟩\n\n"}
{"name":"RingHom.rangeS_top_iff_surjective","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\n⊢ Iff (Eq f.rangeS Top.top) (Function.Surjective ⇑f)","decl":"theorem rangeS_top_iff_surjective {f : R →+* S} :\n    f.rangeS = (⊤ : Subsemiring S) ↔ Function.Surjective f :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_rangeS, coe_top]) Set.range_eq_univ\n\n"}
{"name":"RingHom.rangeS_top_of_surjective","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\n⊢ Eq f.rangeS Top.top","decl":"/-- The range of a surjective ring homomorphism is the whole of the codomain. -/\n@[simp]\ntheorem rangeS_top_of_surjective (f : R →+* S) (hf : Function.Surjective f) :\n    f.rangeS = (⊤ : Subsemiring S) :=\n  rangeS_top_iff_surjective.2 hf\n\n"}
{"name":"RingHom.eqOn_sclosure","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf g : RingHom R S\ns : Set R\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(Subsemiring.closure s)","decl":"/-- If two ring homomorphisms are equal on a set, then they are equal on its subsemiring closure. -/\ntheorem eqOn_sclosure {f g : R →+* S} {s : Set R} (h : Set.EqOn f g s) : Set.EqOn f g (closure s) :=\n  show closure s ≤ f.eqLocusS g from closure_le.2 h\n\n"}
{"name":"RingHom.eq_of_eqOn_stop","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf g : RingHom R S\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"theorem eq_of_eqOn_stop {f g : R →+* S} (h : Set.EqOn f g (⊤ : Subsemiring R)) : f = g :=\n  ext fun _ => h trivial\n\n"}
{"name":"RingHom.eq_of_eqOn_sdense","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Set R\nhs : Eq (Subsemiring.closure s) Top.top\nf g : RingHom R S\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"theorem eq_of_eqOn_sdense {s : Set R} (hs : closure s = ⊤) {f g : R →+* S} (h : s.EqOn f g) :\n    f = g :=\n  eq_of_eqOn_stop <| hs ▸ eqOn_sclosure h\n\n"}
{"name":"RingHom.sclosure_preimage_le","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Set S\n⊢ LE.le (Subsemiring.closure (Set.preimage (⇑f) s)) (Subsemiring.comap f (Subsemiring.closure s))","decl":"theorem sclosure_preimage_le (f : R →+* S) (s : Set S) : closure (f ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"RingHom.map_closureS","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\ns : Set R\n⊢ Eq (Subsemiring.map f (Subsemiring.closure s)) (Subsemiring.closure (Set.image (⇑f) s))","decl":"/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem map_closureS (f : R →+* S) (s : Set R) : (closure s).map f = closure (f '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (Subsemiring.gi S).gc (Subsemiring.gi R).gc\n    fun _ ↦ rfl\n\n"}
{"name":"Subsemiring.inclusion_injective","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\nS T : Subsemiring R\nh : LE.le S T\n⊢ Function.Injective ⇑(Subsemiring.inclusion h)","decl":"theorem inclusion_injective {S T : Subsemiring R} (h : S ≤ T) :\n    Function.Injective (inclusion h) := Set.inclusion_injective h\n\n"}
{"name":"Subsemiring.rangeS_subtype","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonAssocSemiring R\ns : Subsemiring R\n⊢ Eq s.subtype.rangeS s","decl":"@[simp]\ntheorem rangeS_subtype (s : Subsemiring R) : s.subtype.rangeS = s :=\n  SetLike.coe_injective <| (coe_rangeS _).trans Subtype.range_coe\n\n"}
{"name":"Subsemiring.range_fst","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (RingHom.fst R S).rangeS Top.top","decl":"@[simp]\ntheorem range_fst : (fst R S).rangeS = ⊤ :=\n  (fst R S).rangeS_top_of_surjective <| Prod.fst_surjective\n\n"}
{"name":"Subsemiring.range_snd","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (RingHom.snd R S).rangeS Top.top","decl":"@[simp]\ntheorem range_snd : (snd R S).rangeS = ⊤ :=\n  (snd R S).rangeS_top_of_surjective <| Prod.snd_surjective\n\n"}
{"name":"Subsemiring.prod_bot_sup_bot_prod","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ns : Subsemiring R\nt : Subsemiring S\n⊢ Eq (Max.max (s.prod Bot.bot) (Bot.bot.prod t)) (s.prod t)","decl":"@[simp]\ntheorem prod_bot_sup_bot_prod (s : Subsemiring R) (t : Subsemiring S) :\n    s.prod ⊥ ⊔ prod ⊥ t = s.prod t :=\n  le_antisymm (sup_le (prod_mono_right s bot_le) (prod_mono_left t bot_le)) fun p hp =>\n    Prod.fst_mul_snd p ▸\n      mul_mem\n        ((le_sup_left : s.prod ⊥ ≤ s.prod ⊥ ⊔ prod ⊥ t) ⟨hp.1, SetLike.mem_coe.2 <| one_mem ⊥⟩)\n        ((le_sup_right : prod ⊥ t ≤ s.prod ⊥ ⊔ prod ⊥ t) ⟨SetLike.mem_coe.2 <| one_mem ⊥, hp.2⟩)\n\n"}
{"name":"RingEquiv.ofLeftInverseS_apply","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ng : S → R\nf : RingHom R S\nh : Function.LeftInverse g ⇑f\nx : R\n⊢ Eq (↑((RingEquiv.ofLeftInverseS h) x)) (f x)","decl":"@[simp]\ntheorem ofLeftInverseS_apply {g : S → R} {f : R →+* S} (h : Function.LeftInverse g f) (x : R) :\n    ↑(ofLeftInverseS h x) = f x :=\n  rfl\n\n"}
{"name":"RingEquiv.ofLeftInverseS_symm_apply","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ng : S → R\nf : RingHom R S\nh : Function.LeftInverse g ⇑f\nx : Subtype fun x => Membership.mem f.rangeS x\n⊢ Eq ((RingEquiv.ofLeftInverseS h).symm x) (g ↑x)","decl":"@[simp]\ntheorem ofLeftInverseS_symm_apply {g : S → R} {f : R →+* S} (h : Function.LeftInverse g f)\n    (x : f.rangeS) : (ofLeftInverseS h).symm x = g x :=\n  rfl\n\n"}
{"name":"RingEquiv.subsemiringMap_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\ns : Subsemiring R\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((e.subsemiringMap s) x)) (e ↑x)","decl":"@[simp]\ntheorem subsemiringMap_apply_coe (e : R ≃+* S) (s : Subsemiring R) (x : s) :\n    ((subsemiringMap e s) x : S) = e x :=\n  rfl\n\n"}
{"name":"RingEquiv.subsemiringMap_symm_apply_coe","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\ne : RingEquiv R S\ns : Subsemiring R\nx : Subtype fun x => Membership.mem (Subsemiring.map e.toRingHom s) x\n⊢ Eq (↑((e.subsemiringMap s).symm x)) (e.symm ↑x)","decl":"@[simp]\ntheorem subsemiringMap_symm_apply_coe (e : R ≃+* S) (s : Subsemiring R) (x : s.map e.toRingHom) :\n    ((subsemiringMap e s).symm x : R) = e.symm x :=\n  rfl\n\n"}
{"name":"Subsemiring.smul_def","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\nα : Type u_2\ninst✝¹ : NonAssocSemiring R'\ninst✝ : SMul R' α\nS : Subsemiring R'\ng : Subtype fun x => Membership.mem S x\nm : α\n⊢ Eq (HSMul.hSMul g m) (HSMul.hSMul (↑g) m)","decl":"theorem smul_def [SMul R' α] {S : Subsemiring R'} (g : S) (m : α) : g • m = (g : R') • m :=\n  rfl\n\n"}
{"name":"Subsemiring.smulCommClass_left","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring R'\ninst✝² : SMul R' β\ninst✝¹ : SMul α β\ninst✝ : SMulCommClass R' α β\nS : Subsemiring R'\n⊢ SMulCommClass (Subtype fun x => Membership.mem S x) α β","decl":"instance smulCommClass_left [SMul R' β] [SMul α β] [SMulCommClass R' α β] (S : Subsemiring R') :\n    SMulCommClass S α β :=\n  S.toSubmonoid.smulCommClass_left\n\n"}
{"name":"Subsemiring.smulCommClass_right","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring R'\ninst✝² : SMul α β\ninst✝¹ : SMul R' β\ninst✝ : SMulCommClass α R' β\nS : Subsemiring R'\n⊢ SMulCommClass α (Subtype fun x => Membership.mem S x) β","decl":"instance smulCommClass_right [SMul α β] [SMul R' β] [SMulCommClass α R' β] (S : Subsemiring R') :\n    SMulCommClass α S β :=\n  S.toSubmonoid.smulCommClass_right\n\n"}
{"name":"Subsemiring.isScalarTower","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁴ : NonAssocSemiring R'\ninst✝³ : SMul α β\ninst✝² : SMul R' α\ninst✝¹ : SMul R' β\ninst✝ : IsScalarTower R' α β\nS : Subsemiring R'\n⊢ IsScalarTower (Subtype fun x => Membership.mem S x) α β","decl":"/-- Note that this provides `IsScalarTower S R R` which is needed by `smul_mul_assoc`. -/\ninstance isScalarTower [SMul α β] [SMul R' α] [SMul R' β] [IsScalarTower R' α β]\n    (S : Subsemiring R') :\n    IsScalarTower S α β :=\n  S.toSubmonoid.isScalarTower\n\n"}
{"name":"Subsemiring.faithfulSMul","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\nα : Type u_2\ninst✝² : NonAssocSemiring R'\ninst✝¹ : SMul R' α\ninst✝ : FaithfulSMul R' α\nS : Subsemiring R'\n⊢ FaithfulSMul (Subtype fun x => Membership.mem S x) α","decl":"instance faithfulSMul [SMul R' α] [FaithfulSMul R' α] (S : Subsemiring R') : FaithfulSMul S α :=\n  S.toSubmonoid.faithfulSMul\n\n"}
{"name":"Subsemiring.center.smulCommClass_left","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\ninst✝ : Semiring R'\n⊢ SMulCommClass (Subtype fun x => Membership.mem (Subsemiring.center R') x) R' R'","decl":"/-- The center of a semiring acts commutatively on that semiring. -/\ninstance center.smulCommClass_left : SMulCommClass (center R') R' R' :=\n  Submonoid.center.smulCommClass_left\n\n"}
{"name":"Subsemiring.center.smulCommClass_right","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\ninst✝ : Semiring R'\n⊢ SMulCommClass R' (Subtype fun x => Membership.mem (Subsemiring.center R') x) R'","decl":"/-- The center of a semiring acts commutatively on that semiring. -/\ninstance center.smulCommClass_right : SMulCommClass R' (center R') R' :=\n  Submonoid.center.smulCommClass_right\n\n"}
{"name":"Subsemiring.closure_le_centralizer_centralizer","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R' : Type u_1\ninst✝ : Semiring R'\ns : Set R'\n⊢ LE.le (Subsemiring.closure s) (Subsemiring.centralizer ↑(Subsemiring.centralizer s))","decl":"lemma closure_le_centralizer_centralizer (s : Set R') :\n    closure s ≤ centralizer (centralizer s) :=\n  closure_le.mpr Set.subset_centralizer_centralizer\n\n"}
{"name":"Subsemiring.map_comap_eq","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nt : Subsemiring S\n⊢ Eq (Subsemiring.map f (Subsemiring.comap f t)) (Min.min t f.rangeS)","decl":"theorem map_comap_eq (f : R →+* S) (t : Subsemiring S) : (t.comap f).map f = t ⊓ f.rangeS :=\n  SetLike.coe_injective Set.image_preimage_eq_inter_range\n\n"}
{"name":"Subsemiring.map_comap_eq_self","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nt : Subsemiring S\nh : LE.le t f.rangeS\n⊢ Eq (Subsemiring.map f (Subsemiring.comap f t)) t","decl":"theorem map_comap_eq_self\n    {f : R →+* S} {t : Subsemiring S} (h : t ≤ f.rangeS) : (t.comap f).map f = t := by\n  simpa only [inf_of_le_left h] using map_comap_eq f t\n\n"}
{"name":"Subsemiring.map_comap_eq_self_of_surjective","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nhf : Function.Surjective ⇑f\nt : Subsemiring S\n⊢ Eq (Subsemiring.map f (Subsemiring.comap f t)) t","decl":"theorem map_comap_eq_self_of_surjective\n    {f : R →+* S} (hf : Function.Surjective f) (t : Subsemiring S) : (t.comap f).map f = t :=\n  map_comap_eq_self <| by simp [hf]\n\n"}
{"name":"Subsemiring.comap_map_eq_self_of_injective","module":"Mathlib.Algebra.Ring.Subsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nf : RingHom R S\nhf : Function.Injective ⇑f\ns : Subsemiring R\n⊢ Eq (Subsemiring.comap f (Subsemiring.map f s)) s","decl":"theorem comap_map_eq_self_of_injective\n    {f : R →+* S} (hf : Function.Injective f) (s : Subsemiring R) : (s.map f).comap f = s :=\n  SetLike.coe_injective (Set.preimage_image_eq _ hf)\n\n"}
