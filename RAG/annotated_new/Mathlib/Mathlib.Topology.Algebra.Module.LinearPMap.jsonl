{"name":"LinearPMap.IsClosed.isClosable","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : f.IsClosed\n⊢ f.IsClosable","decl":"/-- A closed operator is trivially closable. -/\ntheorem IsClosed.isClosable {f : E →ₗ.[R] F} (hf : f.IsClosed) : f.IsClosable :=\n  ⟨f, hf.submodule_topologicalClosure_eq⟩\n\n"}
{"name":"LinearPMap.IsClosable.leIsClosable","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf g : LinearPMap R E F\nhf : f.IsClosable\nhfg : LE.le g f\n⊢ g.IsClosable","decl":"/-- If `g` has a closable extension `f`, then `g` itself is closable. -/\ntheorem IsClosable.leIsClosable {f g : E →ₗ.[R] F} (hf : f.IsClosable) (hfg : g ≤ f) :\n    g.IsClosable := by\n  cases' hf with f' hf\n  have : g.graph.topologicalClosure ≤ f'.graph := by\n    rw [← hf]\n    exact Submodule.topologicalClosure_mono (le_graph_of_le hfg)\n  use g.graph.topologicalClosure.toLinearPMap\n  rw [Submodule.toLinearPMap_graph_eq]\n  exact fun _ hx hx' => f'.graph_fst_eq_zero_snd (this hx) hx'\n\n"}
{"name":"LinearPMap.IsClosable.existsUnique","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : f.IsClosable\n⊢ ExistsUnique fun f' => Eq f.graph.topologicalClosure f'.graph","decl":"/-- The closure is unique. -/\ntheorem IsClosable.existsUnique {f : E →ₗ.[R] F} (hf : f.IsClosable) :\n    ∃! f' : E →ₗ.[R] F, f.graph.topologicalClosure = f'.graph := by\n  refine existsUnique_of_exists_of_unique hf fun _ _ hy₁ hy₂ => eq_of_eq_graph ?_\n  rw [← hy₁, ← hy₂]\n\n"}
{"name":"LinearPMap.closure_def","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : f.IsClosable\n⊢ Eq f.closure (Exists.choose hf)","decl":"theorem closure_def {f : E →ₗ.[R] F} (hf : f.IsClosable) : f.closure = hf.choose := by\n  simp [closure, hf]\n\n"}
{"name":"LinearPMap.closure_def'","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : Not f.IsClosable\n⊢ Eq f.closure f","decl":"theorem closure_def' {f : E →ₗ.[R] F} (hf : ¬f.IsClosable) : f.closure = f := by simp [closure, hf]\n\n"}
{"name":"LinearPMap.IsClosable.graph_closure_eq_closure_graph","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : f.IsClosable\n⊢ Eq f.graph.topologicalClosure f.closure.graph","decl":"/-- The closure (as a submodule) of the graph is equal to the graph of the closure\n  (as a `LinearPMap`). -/\ntheorem IsClosable.graph_closure_eq_closure_graph {f : E →ₗ.[R] F} (hf : f.IsClosable) :\n    f.graph.topologicalClosure = f.closure.graph := by\n  rw [closure_def hf]\n  exact hf.choose_spec\n\n"}
{"name":"LinearPMap.le_closure","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\n⊢ LE.le f f.closure","decl":"/-- A `LinearPMap` is contained in its closure. -/\ntheorem le_closure (f : E →ₗ.[R] F) : f ≤ f.closure := by\n  by_cases hf : f.IsClosable\n  · refine le_of_le_graph ?_\n    rw [← hf.graph_closure_eq_closure_graph]\n    exact (graph f).le_topologicalClosure\n  rw [closure_def' hf]\n\n"}
{"name":"LinearPMap.IsClosable.closure_mono","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf g : LinearPMap R E F\nhg : g.IsClosable\nh : LE.le f g\n⊢ LE.le f.closure g.closure","decl":"theorem IsClosable.closure_mono {f g : E →ₗ.[R] F} (hg : g.IsClosable) (h : f ≤ g) :\n    f.closure ≤ g.closure := by\n  refine le_of_le_graph ?_\n  rw [← (hg.leIsClosable h).graph_closure_eq_closure_graph]\n  rw [← hg.graph_closure_eq_closure_graph]\n  exact Submodule.topologicalClosure_mono (le_graph_of_le h)\n\n"}
{"name":"LinearPMap.IsClosable.closure_isClosed","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : f.IsClosable\n⊢ f.closure.IsClosed","decl":"/-- If `f` is closable, then the closure is closed. -/\ntheorem IsClosable.closure_isClosed {f : E →ₗ.[R] F} (hf : f.IsClosable) : f.closure.IsClosed := by\n  rw [IsClosed, ← hf.graph_closure_eq_closure_graph]\n  exact f.graph.isClosed_topologicalClosure\n\n"}
{"name":"LinearPMap.IsClosable.closureIsClosable","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : f.IsClosable\n⊢ f.closure.IsClosable","decl":"/-- If `f` is closable, then the closure is closable. -/\ntheorem IsClosable.closureIsClosable {f : E →ₗ.[R] F} (hf : f.IsClosable) : f.closure.IsClosable :=\n  hf.closure_isClosed.isClosable\n\n"}
{"name":"LinearPMap.isClosable_iff_exists_closed_extension","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\n⊢ Iff f.IsClosable (Exists fun g => And g.IsClosed (LE.le f g))","decl":"theorem isClosable_iff_exists_closed_extension {f : E →ₗ.[R] F} :\n    f.IsClosable ↔ ∃ g : E →ₗ.[R] F, g.IsClosed ∧ f ≤ g :=\n  ⟨fun h => ⟨f.closure, h.closure_isClosed, f.le_closure⟩, fun ⟨_, hg, h⟩ =>\n    hg.isClosable.leIsClosable h⟩\n\n"}
{"name":"LinearPMap.HasCore.closure_eq","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nS : Submodule R E\nself : f.HasCore S\n⊢ Eq (f.domRestrict S).closure f","decl":"/-- A submodule `S` is a core of `f` if the closure of the restriction of `f` to `S` is `f`. -/\nstructure HasCore (f : E →ₗ.[R] F) (S : Submodule R E) : Prop where\n  le_domain : S ≤ f.domain\n  closure_eq : (f.domRestrict S).closure = f\n\n"}
{"name":"LinearPMap.HasCore.le_domain","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nS : Submodule R E\nself : f.HasCore S\n⊢ LE.le S f.domain","decl":"/-- A submodule `S` is a core of `f` if the closure of the restriction of `f` to `S` is `f`. -/\nstructure HasCore (f : E →ₗ.[R] F) (S : Submodule R E) : Prop where\n  le_domain : S ≤ f.domain\n  closure_eq : (f.domRestrict S).closure = f\n\n"}
{"name":"LinearPMap.hasCore_def","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nS : Submodule R E\nh : f.HasCore S\n⊢ Eq (f.domRestrict S).closure f","decl":"theorem hasCore_def {f : E →ₗ.[R] F} {S : Submodule R E} (h : f.HasCore S) :\n    (f.domRestrict S).closure = f :=\n  h.2\n\n"}
{"name":"LinearPMap.closureHasCore","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\n⊢ f.closure.HasCore f.domain","decl":"/-- For every unbounded operator `f` the submodule `f.domain` is a core of its closure.\n\nNote that we don't require that `f` is closable, due to the definition of the closure. -/\ntheorem closureHasCore (f : E →ₗ.[R] F) : f.closure.HasCore f.domain := by\n  refine ⟨f.le_closure.1, ?_⟩\n  congr\n  ext x y hxy\n  · simp only [domRestrict_domain, Submodule.mem_inf, and_iff_left_iff_imp]\n    intro hx\n    exact f.le_closure.1 hx\n  let z : f.closure.domain := ⟨y.1, f.le_closure.1 y.2⟩\n  have hyz : (y : E) = z := by simp [z]\n  rw [f.le_closure.2 hyz]\n  exact domRestrict_apply (hxy.trans hyz)\n\n"}
{"name":"LinearPMap.closure_inverse_graph","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\nhf' : f.IsClosable\nhcf : Eq (LinearMap.ker f.closure.toFun) Bot.bot\n⊢ Eq f.closure.inverse.graph f.inverse.graph.topologicalClosure","decl":"/-- If `f` is invertible and closable as well as its closure being invertible, then\nthe graph of the inverse of the closure is given by the closure of the graph of the inverse. -/\ntheorem closure_inverse_graph (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable)\n    (hcf : LinearMap.ker f.closure.toFun = ⊥) :\n    f.closure.inverse.graph = f.inverse.graph.topologicalClosure := by\n  rw [inverse_graph hf, inverse_graph hcf, ← hf'.graph_closure_eq_closure_graph]\n  apply SetLike.ext'\n  simp only [Submodule.topologicalClosure_coe, Submodule.map_coe, LinearEquiv.prodComm_apply]\n  apply (image_closure_subset_closure_image continuous_swap).antisymm\n  have h1 := Set.image_equiv_eq_preimage_symm f.graph (LinearEquiv.prodComm R E F).toEquiv\n  have h2 := Set.image_equiv_eq_preimage_symm (_root_.closure f.graph)\n    (LinearEquiv.prodComm R E F).toEquiv\n  simp only [LinearEquiv.coe_toEquiv, LinearEquiv.prodComm_apply,\n    LinearEquiv.coe_toEquiv_symm] at h1 h2\n  rw [h1, h2]\n  apply continuous_swap.closure_preimage_subset\n\n"}
{"name":"LinearPMap.inverse_isClosable_iff","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\nhf' : f.IsClosable\n⊢ Iff f.inverse.IsClosable (Eq (LinearMap.ker f.closure.toFun) Bot.bot)","decl":"/-- Assuming that `f` is invertible and closable, then the closure is invertible if and only\nif the inverse of `f` is closable. -/\ntheorem inverse_isClosable_iff (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable) :\n    f.inverse.IsClosable ↔ LinearMap.ker f.closure.toFun = ⊥ := by\n  constructor\n  · intro ⟨f', h⟩\n    rw [LinearMap.ker_eq_bot']\n    intro ⟨x, hx⟩ hx'\n    simp only [Submodule.mk_eq_zero]\n    rw [toFun_eq_coe, eq_comm, image_iff] at hx'\n    have : (0, x) ∈ graph f' := by\n      rw [← h, inverse_graph hf]\n      rw [← hf'.graph_closure_eq_closure_graph, ← SetLike.mem_coe,\n        Submodule.topologicalClosure_coe] at hx'\n      apply image_closure_subset_closure_image continuous_swap\n      simp only [Set.mem_image, Prod.exists, Prod.swap_prod_mk, Prod.mk.injEq]\n      exact ⟨x, 0, hx', rfl, rfl⟩\n    exact graph_fst_eq_zero_snd f' this rfl\n  · intro h\n    use f.closure.inverse\n    exact (closure_inverse_graph hf hf' h).symm\n\n"}
{"name":"LinearPMap.inverse_closure","module":"Mathlib.Topology.Algebra.Module.LinearPMap","initialProofState":"R : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup E\ninst✝⁹ : AddCommGroup F\ninst✝⁸ : Module R E\ninst✝⁷ : Module R F\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : TopologicalSpace F\ninst✝⁴ : ContinuousAdd E\ninst✝³ : ContinuousAdd F\ninst✝² : TopologicalSpace R\ninst✝¹ : ContinuousSMul R E\ninst✝ : ContinuousSMul R F\nf : LinearPMap R E F\nhf : Eq (LinearMap.ker f.toFun) Bot.bot\nhf' : f.IsClosable\nhcf : Eq (LinearMap.ker f.closure.toFun) Bot.bot\n⊢ Eq f.inverse.closure f.closure.inverse","decl":"/-- If `f` is invertible and closable, then taking the closure and the inverse commute. -/\ntheorem inverse_closure (hf : LinearMap.ker f.toFun = ⊥) (hf' : f.IsClosable)\n    (hcf : LinearMap.ker f.closure.toFun = ⊥) :\n    f.inverse.closure = f.closure.inverse := by\n  apply eq_of_eq_graph\n  rw [closure_inverse_graph hf hf' hcf,\n    ((inverse_isClosable_iff hf hf').mpr hcf).graph_closure_eq_closure_graph]\n\n"}
