{"name":"SimpleGraph.symm","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nself : SimpleGraph V\n⊢ Symmetric self.Adj","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.ext_iff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nx y : SimpleGraph V\n⊢ Iff (Eq x y) (Eq x.Adj y.Adj)","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.loopless","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nself : SimpleGraph V\n⊢ Irreflexive self.Adj","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.ext","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nx y : SimpleGraph V\nAdj : Eq x.Adj y.Adj\n⊢ Eq x y","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.mk.injEq","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nAdj✝ : V → V → Prop\nsymm✝ : autoParam (Symmetric Adj✝) _auto✝\nloopless✝ : autoParam (Irreflexive Adj✝) _auto✝\nAdj : V → V → Prop\nsymm : autoParam (Symmetric Adj) _auto✝\nloopless : autoParam (Irreflexive Adj) _auto✝\n⊢ Eq (Eq { Adj := Adj✝, symm := symm✝, loopless := loopless✝ } { Adj := Adj, symm := symm, loopless := loopless }) (Eq Adj✝ Adj)","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.mk.sizeOf_spec","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ninst✝ : SizeOf V\nAdj : V → V → Prop\nsymm : autoParam (Symmetric Adj) _auto✝\nloopless : autoParam (Irreflexive Adj) _auto✝\n⊢ Eq (SizeOf.sizeOf { Adj := Adj, symm := symm, loopless := loopless }) 1","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.mk.inj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nAdj✝ : V → V → Prop\nsymm✝ : autoParam (Symmetric Adj✝) _auto✝\nloopless✝ : autoParam (Irreflexive Adj✝) _auto✝\nAdj : V → V → Prop\nsymm : autoParam (Symmetric Adj) _auto✝\nloopless : autoParam (Irreflexive Adj) _auto✝\nx✝ : Eq { Adj := Adj✝, symm := symm✝, loopless := loopless✝ } { Adj := Adj, symm := symm, loopless := loopless }\n⊢ Eq Adj✝ Adj","decl":"/-- A simple graph is an irreflexive symmetric relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\nThere is exactly one edge for every pair of adjacent vertices;\nsee `SimpleGraph.edgeSet` for the corresponding edge set.\n-/\n@[ext, aesop safe constructors (rule_sets := [SimpleGraph])]\nstructure SimpleGraph (V : Type u) where\n  /-- The adjacency relation of a simple graph. -/\n  Adj : V → V → Prop\n  symm : Symmetric Adj := by aesop_graph\n  loopless : Irreflexive Adj := by aesop_graph\n\n"}
{"name":"SimpleGraph.mk'_apply_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nx : Subtype fun adj => And (∀ (x y : V), Eq (adj x y) (adj y x)) (∀ (x : V), Not (Eq (adj x x) Bool.true))\nv w : V\n⊢ Eq ((SimpleGraph.mk' x).Adj v w) (Eq (↑x v w) Bool.true)","decl":"/-- Constructor for simple graphs using a symmetric irreflexive boolean function. -/\n@[simps]\ndef SimpleGraph.mk' {V : Type u} :\n    {adj : V → V → Bool // (∀ x y, adj x y = adj y x) ∧ (∀ x, ¬ adj x x)} ↪ SimpleGraph V where\n  toFun x := ⟨fun v w ↦ x.1 v w, fun v w ↦ by simp [x.2.1], fun v ↦ by simp [x.2.2]⟩\n  inj' := by\n    rintro ⟨adj, _⟩ ⟨adj', _⟩\n    simp only [mk.injEq, Subtype.mk.injEq]\n    intro h\n    funext v w\n    simpa [Bool.coe_iff_coe] using congr_fun₂ h v w\n\n"}
{"name":"SimpleGraph.instFinite","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ninst✝ : Finite V\n⊢ Finite (SimpleGraph V)","decl":"/-- There are finitely many simple graphs on a given finite type. -/\ninstance SimpleGraph.instFinite {V : Type u} [Finite V] : Finite (SimpleGraph V) :=\n  .of_injective SimpleGraph.Adj fun _ _ ↦ SimpleGraph.ext\n\n"}
{"name":"SimpleGraph.fromRel_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nr : V → V → Prop\nv w : V\n⊢ Iff ((SimpleGraph.fromRel r).Adj v w) (And (Ne v w) (Or (r v w) (r w v)))","decl":"@[simp]\ntheorem SimpleGraph.fromRel_adj {V : Type u} (r : V → V → Prop) (v w : V) :\n    (SimpleGraph.fromRel r).Adj v w ↔ v ≠ w ∧ (r v w ∨ r w v) :=\n  Iff.rfl\n\n"}
{"name":"completeBipartiteGraph_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u_1\nW : Type u_2\nv w : Sum V W\n⊢ Eq ((completeBipartiteGraph V W).Adj v w) (Or (And (Eq v.isLeft Bool.true) (Eq w.isRight Bool.true)) (And (Eq v.isRight Bool.true) (Eq w.isLeft Bool.true)))","decl":"/-- Two vertices are adjacent in the complete bipartite graph on two vertex types\nif and only if they are not from the same side.\nAny bipartite graph may be regarded as a subgraph of one of these. -/\n@[simps]\ndef completeBipartiteGraph (V W : Type*) : SimpleGraph (V ⊕ W) where\n  Adj v w := v.isLeft ∧ w.isRight ∨ v.isRight ∧ w.isLeft\n  symm v w := by cases v <;> cases w <;> simp\n  loopless v := by cases v <;> simp\n\n"}
{"name":"SimpleGraph.irrefl","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Not (G.Adj v v)","decl":"@[simp]\nprotected theorem irrefl {v : V} : ¬G.Adj v v :=\n  G.loopless v\n\n"}
{"name":"SimpleGraph.adj_comm","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\n⊢ Iff (G.Adj u v) (G.Adj v u)","decl":"theorem adj_comm (u v : V) : G.Adj u v ↔ G.Adj v u :=\n  ⟨fun x => G.symm x, fun x => G.symm x⟩\n\n"}
{"name":"SimpleGraph.adj_symm","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ G.Adj v u","decl":"@[symm]\ntheorem adj_symm (h : G.Adj u v) : G.Adj v u :=\n  G.symm h\n\n"}
{"name":"SimpleGraph.Adj.symm","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nu v : V\nh : G.Adj u v\n⊢ G.Adj v u","decl":"theorem Adj.symm {G : SimpleGraph V} {u v : V} (h : G.Adj u v) : G.Adj v u :=\n  G.symm h\n\n"}
{"name":"SimpleGraph.ne_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\nh : G.Adj a b\n⊢ Ne a b","decl":"theorem ne_of_adj (h : G.Adj a b) : a ≠ b := by\n  rintro rfl\n  exact G.irrefl h\n\n"}
{"name":"SimpleGraph.Adj.ne","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\nh : G.Adj a b\n⊢ Ne a b","decl":"protected theorem Adj.ne {G : SimpleGraph V} {a b : V} (h : G.Adj a b) : a ≠ b :=\n  G.ne_of_adj h\n\n"}
{"name":"SimpleGraph.Adj.ne'","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\nh : G.Adj a b\n⊢ Ne b a","decl":"protected theorem Adj.ne' {G : SimpleGraph V} {a b : V} (h : G.Adj a b) : b ≠ a :=\n  h.ne.symm\n\n"}
{"name":"SimpleGraph.ne_of_adj_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w x : V\nh : G.Adj v x\nhn : Not (G.Adj w x)\n⊢ Ne v w","decl":"theorem ne_of_adj_of_not_adj {v w x : V} (h : G.Adj v x) (hn : ¬G.Adj w x) : v ≠ w := fun h' =>\n  hn (h' ▸ h)\n\n"}
{"name":"SimpleGraph.adj_injective","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Function.Injective SimpleGraph.Adj","decl":"theorem adj_injective : Injective (Adj : SimpleGraph V → V → V → Prop) :=\n  fun _ _ => SimpleGraph.ext\n\n"}
{"name":"SimpleGraph.adj_inj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG H : SimpleGraph V\n⊢ Iff (Eq G.Adj H.Adj) (Eq G H)","decl":"@[simp]\ntheorem adj_inj {G H : SimpleGraph V} : G.Adj = H.Adj ↔ G = H :=\n  adj_injective.eq_iff\n\n"}
{"name":"SimpleGraph.adj_congr_of_sym2","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w x : V\nh : Eq (Sym2.mk { fst := u, snd := v }) (Sym2.mk { fst := w, snd := x })\n⊢ Iff (G.Adj u v) (G.Adj w x)","decl":"theorem adj_congr_of_sym2 {u v w x : V} (h : s(u, v) = s(w, x)) : G.Adj u v ↔ G.Adj w x := by\n  simp only [Sym2.eq, Sym2.rel_iff', Prod.mk.injEq, Prod.swap_prod_mk] at h\n  cases' h with hl hr\n  · rw [hl.1, hl.2]\n  · rw [hr.1, hr.2, adj_comm]\n\n"}
{"name":"SimpleGraph.isSubgraph_eq_le","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq SimpleGraph.IsSubgraph fun x1 x2 => LE.le x1 x2","decl":"@[simp]\ntheorem isSubgraph_eq_le : (IsSubgraph : SimpleGraph V → SimpleGraph V → Prop) = (· ≤ ·) :=\n  rfl\n\n"}
{"name":"SimpleGraph.sup_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nx y : SimpleGraph V\nv w : V\n⊢ Iff ((Max.max x y).Adj v w) (Or (x.Adj v w) (y.Adj v w))","decl":"@[simp]\ntheorem sup_adj (x y : SimpleGraph V) (v w : V) : (x ⊔ y).Adj v w ↔ x.Adj v w ∨ y.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.inf_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nx y : SimpleGraph V\nv w : V\n⊢ Iff ((Min.min x y).Adj v w) (And (x.Adj v w) (y.Adj v w))","decl":"@[simp]\ntheorem inf_adj (x y : SimpleGraph V) (v w : V) : (x ⊓ y).Adj v w ↔ x.Adj v w ∧ y.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.compl_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff ((HasCompl.compl G).Adj v w) (And (Ne v w) (Not (G.Adj v w)))","decl":"@[simp]\ntheorem compl_adj (G : SimpleGraph V) (v w : V) : Gᶜ.Adj v w ↔ v ≠ w ∧ ¬G.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.sdiff_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nx y : SimpleGraph V\nv w : V\n⊢ Iff ((SDiff.sdiff x y).Adj v w) (And (x.Adj v w) (Not (y.Adj v w)))","decl":"@[simp]\ntheorem sdiff_adj (x y : SimpleGraph V) (v w : V) : (x \\ y).Adj v w ↔ x.Adj v w ∧ ¬y.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.sSup_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ns : Set (SimpleGraph V)\na b : V\n⊢ Iff ((SupSet.sSup s).Adj a b) (Exists fun G => And (Membership.mem s G) (G.Adj a b))","decl":"@[simp]\ntheorem sSup_adj {s : Set (SimpleGraph V)} {a b : V} : (sSup s).Adj a b ↔ ∃ G ∈ s, Adj G a b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.sInf_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\na b : V\ns : Set (SimpleGraph V)\n⊢ Iff ((InfSet.sInf s).Adj a b) (And (∀ (G : SimpleGraph V), Membership.mem s G → G.Adj a b) (Ne a b))","decl":"@[simp]\ntheorem sInf_adj {s : Set (SimpleGraph V)} : (sInf s).Adj a b ↔ (∀ G ∈ s, Adj G a b) ∧ a ≠ b :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.iSup_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"ι : Sort u_1\nV : Type u\na b : V\nf : ι → SimpleGraph V\n⊢ Iff ((iSup fun i => f i).Adj a b) (Exists fun i => (f i).Adj a b)","decl":"@[simp]\ntheorem iSup_adj {f : ι → SimpleGraph V} : (⨆ i, f i).Adj a b ↔ ∃ i, (f i).Adj a b := by simp [iSup]\n\n"}
{"name":"SimpleGraph.iInf_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"ι : Sort u_1\nV : Type u\na b : V\nf : ι → SimpleGraph V\n⊢ Iff ((iInf fun i => f i).Adj a b) (And (∀ (i : ι), (f i).Adj a b) (Ne a b))","decl":"@[simp]\ntheorem iInf_adj {f : ι → SimpleGraph V} : (⨅ i, f i).Adj a b ↔ (∀ i, (f i).Adj a b) ∧ a ≠ b := by\n  simp [iInf]\n\n"}
{"name":"SimpleGraph.sInf_adj_of_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\na b : V\ns : Set (SimpleGraph V)\nhs : s.Nonempty\n⊢ Iff ((InfSet.sInf s).Adj a b) (∀ (G : SimpleGraph V), Membership.mem s G → G.Adj a b)","decl":"theorem sInf_adj_of_nonempty {s : Set (SimpleGraph V)} (hs : s.Nonempty) :\n    (sInf s).Adj a b ↔ ∀ G ∈ s, Adj G a b :=\n  sInf_adj.trans <|\n    and_iff_left_of_imp <| by\n      obtain ⟨G, hG⟩ := hs\n      exact fun h => (h _ hG).ne\n\n"}
{"name":"SimpleGraph.iInf_adj_of_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"ι : Sort u_1\nV : Type u\na b : V\ninst✝ : Nonempty ι\nf : ι → SimpleGraph V\n⊢ Iff ((iInf fun i => f i).Adj a b) (∀ (i : ι), (f i).Adj a b)","decl":"theorem iInf_adj_of_nonempty [Nonempty ι] {f : ι → SimpleGraph V} :\n    (⨅ i, f i).Adj a b ↔ ∀ i, (f i).Adj a b := by\n  rw [iInf, sInf_adj_of_nonempty (Set.range_nonempty _), Set.forall_mem_range]\n\n"}
{"name":"SimpleGraph.top_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nv w : V\n⊢ Iff (Top.top.Adj v w) (Ne v w)","decl":"@[simp]\ntheorem top_adj (v w : V) : (⊤ : SimpleGraph V).Adj v w ↔ v ≠ w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.bot_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nv w : V\n⊢ Iff (Bot.bot.Adj v w) False","decl":"@[simp]\ntheorem bot_adj (v w : V) : (⊥ : SimpleGraph V).Adj v w ↔ False :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.completeGraph_eq_top","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq (completeGraph V) Top.top","decl":"@[simp]\ntheorem completeGraph_eq_top (V : Type u) : completeGraph V = ⊤ :=\n  rfl\n\n"}
{"name":"SimpleGraph.emptyGraph_eq_bot","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq (emptyGraph V) Bot.bot","decl":"@[simp]\ntheorem emptyGraph_eq_bot (V : Type u) : emptyGraph V = ⊥ :=\n  rfl\n\n"}
{"name":"SimpleGraph.instInhabited_default","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq Inhabited.default Bot.bot","decl":"@[simps]\ninstance (V : Type u) : Inhabited (SimpleGraph V) :=\n  ⟨⊥⟩\n\n"}
{"name":"SimpleGraph.instNontrivial","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ninst✝ : Nontrivial V\n⊢ Nontrivial (SimpleGraph V)","decl":"instance [Nontrivial V] : Nontrivial (SimpleGraph V) :=\n  ⟨⟨⊥, ⊤, fun h ↦ not_subsingleton V ⟨by simpa only [← adj_inj, funext_iff, bot_adj,\n    top_adj, ne_eq, eq_iff_iff, false_iff, not_not] using h⟩⟩⟩\n\n"}
{"name":"SimpleGraph.mem_support","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Iff (Membership.mem G.support v) (Exists fun w => G.Adj v w)","decl":"theorem mem_support {v : V} : v ∈ G.support ↔ ∃ w, G.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.support_mono","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG G' : SimpleGraph V\nh : LE.le G G'\n⊢ HasSubset.Subset G.support G'.support","decl":"theorem support_mono {G G' : SimpleGraph V} (h : G ≤ G') : G.support ⊆ G'.support :=\n  Rel.dom_mono h\n\n"}
{"name":"SimpleGraph.mem_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (Membership.mem G.edgeSet (Sym2.mk { fst := v, snd := w })) (G.Adj v w)","decl":"@[simp]\ntheorem mem_edgeSet : s(v, w) ∈ G.edgeSet ↔ G.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.not_isDiag_of_mem_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ne : Sym2 V\na✝ : Membership.mem G.edgeSet e\n⊢ Not e.IsDiag","decl":"theorem not_isDiag_of_mem_edgeSet : e ∈ edgeSet G → ¬e.IsDiag :=\n  Sym2.ind (fun _ _ => Adj.ne) e\n\n"}
{"name":"SimpleGraph.edgeSet_inj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Iff (Eq G₁.edgeSet G₂.edgeSet) (Eq G₁ G₂)","decl":"theorem edgeSet_inj : G₁.edgeSet = G₂.edgeSet ↔ G₁ = G₂ := (edgeSetEmbedding V).eq_iff_eq\n\n"}
{"name":"SimpleGraph.edgeSet_subset_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Iff (HasSubset.Subset G₁.edgeSet G₂.edgeSet) (LE.le G₁ G₂)","decl":"@[simp]\ntheorem edgeSet_subset_edgeSet : edgeSet G₁ ⊆ edgeSet G₂ ↔ G₁ ≤ G₂ :=\n  (edgeSetEmbedding V).le_iff_le\n\n"}
{"name":"SimpleGraph.edgeSet_ssubset_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Iff (HasSSubset.SSubset G₁.edgeSet G₂.edgeSet) (LT.lt G₁ G₂)","decl":"@[simp]\ntheorem edgeSet_ssubset_edgeSet : edgeSet G₁ ⊂ edgeSet G₂ ↔ G₁ < G₂ :=\n  (edgeSetEmbedding V).lt_iff_lt\n\n"}
{"name":"SimpleGraph.edgeSet_injective","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Function.Injective SimpleGraph.edgeSet","decl":"theorem edgeSet_injective : Injective (edgeSet : SimpleGraph V → Set (Sym2 V)) :=\n  (edgeSetEmbedding V).injective\n\n"}
{"name":"SimpleGraph.edgeSet_mono","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\na✝ : LE.le G₁ G₂\n⊢ HasSubset.Subset G₁.edgeSet G₂.edgeSet","decl":"alias ⟨_, edgeSet_mono⟩ := edgeSet_subset_edgeSet\n\n"}
{"name":"SimpleGraph.edgeSet_strict_mono","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\na✝ : LT.lt G₁ G₂\n⊢ HasSSubset.SSubset G₁.edgeSet G₂.edgeSet","decl":"alias ⟨_, edgeSet_strict_mono⟩ := edgeSet_ssubset_edgeSet\n\n"}
{"name":"SimpleGraph.edgeSet_bot","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq Bot.bot.edgeSet EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem edgeSet_bot : (⊥ : SimpleGraph V).edgeSet = ∅ :=\n  Sym2.fromRel_bot\n\n"}
{"name":"SimpleGraph.edgeSet_top","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq Top.top.edgeSet (setOf fun e => Not e.IsDiag)","decl":"@[simp]\ntheorem edgeSet_top : (⊤ : SimpleGraph V).edgeSet = {e | ¬e.IsDiag} :=\n  Sym2.fromRel_ne\n\n"}
{"name":"SimpleGraph.edgeSet_subset_setOf_not_isDiag","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ HasSubset.Subset G.edgeSet (setOf fun e => Not e.IsDiag)","decl":"@[simp]\ntheorem edgeSet_subset_setOf_not_isDiag : G.edgeSet ⊆ {e | ¬e.IsDiag} :=\n  fun _ h => (Sym2.fromRel_irreflexive (sym := G.symm)).mp G.loopless h\n\n"}
{"name":"SimpleGraph.edgeSet_sup","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Eq (Max.max G₁ G₂).edgeSet (Union.union G₁.edgeSet G₂.edgeSet)","decl":"@[simp]\ntheorem edgeSet_sup : (G₁ ⊔ G₂).edgeSet = G₁.edgeSet ∪ G₂.edgeSet := by\n  ext ⟨x, y⟩\n  rfl\n\n"}
{"name":"SimpleGraph.edgeSet_inf","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Eq (Min.min G₁ G₂).edgeSet (Inter.inter G₁.edgeSet G₂.edgeSet)","decl":"@[simp]\ntheorem edgeSet_inf : (G₁ ⊓ G₂).edgeSet = G₁.edgeSet ∩ G₂.edgeSet := by\n  ext ⟨x, y⟩\n  rfl\n\n"}
{"name":"SimpleGraph.edgeSet_sdiff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Eq (SDiff.sdiff G₁ G₂).edgeSet (SDiff.sdiff G₁.edgeSet G₂.edgeSet)","decl":"@[simp]\ntheorem edgeSet_sdiff : (G₁ \\ G₂).edgeSet = G₁.edgeSet \\ G₂.edgeSet := by\n  ext ⟨x, y⟩\n  rfl\n\n"}
{"name":"SimpleGraph.disjoint_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG₁ G₂ : SimpleGraph V\n⊢ Iff (Disjoint G₁.edgeSet G₂.edgeSet) (Disjoint G₁ G₂)","decl":"@[simp] lemma disjoint_edgeSet : Disjoint G₁.edgeSet G₂.edgeSet ↔ Disjoint G₁ G₂ := by\n  rw [Set.disjoint_iff, disjoint_iff_inf_le, ← edgeSet_inf, ← edgeSet_bot, ← Set.le_iff_subset,\n    OrderEmbedding.le_iff_le]\n\n"}
{"name":"SimpleGraph.edgeSet_eq_empty","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff (Eq G.edgeSet EmptyCollection.emptyCollection) (Eq G Bot.bot)","decl":"@[simp] lemma edgeSet_eq_empty : G.edgeSet = ∅ ↔ G = ⊥ := by rw [← edgeSet_bot, edgeSet_inj]\n\n"}
{"name":"SimpleGraph.edgeSet_nonempty","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Iff G.edgeSet.Nonempty (Ne G Bot.bot)","decl":"@[simp] lemma edgeSet_nonempty : G.edgeSet.Nonempty ↔ G ≠ ⊥ := by\n  rw [Set.nonempty_iff_ne_empty, edgeSet_eq_empty.ne]\n\n"}
{"name":"SimpleGraph.edgeSet_sdiff_sdiff_isDiag","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ Eq (SDiff.sdiff G.edgeSet (SDiff.sdiff s (setOf fun e => e.IsDiag))) (SDiff.sdiff G.edgeSet s)","decl":"/-- This lemma, combined with `edgeSet_sdiff` and `edgeSet_from_edgeSet`,\nallows proving `(G \\ from_edgeSet s).edge_set = G.edgeSet \\ s` by `simp`. -/\n@[simp]\ntheorem edgeSet_sdiff_sdiff_isDiag (G : SimpleGraph V) (s : Set (Sym2 V)) :\n    G.edgeSet \\ (s \\ { e | e.IsDiag }) = G.edgeSet \\ s := by\n  ext e\n  simp only [Set.mem_diff, Set.mem_setOf_eq, not_and, not_not, and_congr_right_iff]\n  intro h\n  simp only [G.not_isDiag_of_mem_edgeSet h, imp_false]\n\n"}
{"name":"SimpleGraph.adj_iff_exists_edge","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (G.Adj v w) (And (Ne v w) (Exists fun e => And (Membership.mem G.edgeSet e) (And (Membership.mem e v) (Membership.mem e w))))","decl":"/-- Two vertices are adjacent iff there is an edge between them. The\ncondition `v ≠ w` ensures they are different endpoints of the edge,\nwhich is necessary since when `v = w` the existential\n`∃ (e ∈ G.edgeSet), v ∈ e ∧ w ∈ e` is satisfied by every edge\nincident to `v`. -/\ntheorem adj_iff_exists_edge {v w : V} : G.Adj v w ↔ v ≠ w ∧ ∃ e ∈ G.edgeSet, v ∈ e ∧ w ∈ e := by\n  refine ⟨fun _ => ⟨G.ne_of_adj ‹_›, s(v, w), by simpa⟩, ?_⟩\n  rintro ⟨hne, e, he, hv⟩\n  rw [Sym2.mem_and_mem_iff hne] at hv\n  subst e\n  rwa [mem_edgeSet] at he\n\n"}
{"name":"SimpleGraph.adj_iff_exists_edge_coe","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\n⊢ Iff (G.Adj a b) (Exists fun e => Eq (↑e) (Sym2.mk { fst := a, snd := b }))","decl":"theorem adj_iff_exists_edge_coe : G.Adj a b ↔ ∃ e : G.edgeSet, e.val = s(a, b) := by\n  simp only [mem_edgeSet, exists_prop, SetCoe.exists, exists_eq_right, Subtype.coe_mk]\n\n"}
{"name":"SimpleGraph.edge_other_ne","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ne : Sym2 V\nhe : Membership.mem G.edgeSet e\nv : V\nh : Membership.mem e v\n⊢ Ne (Sym2.Mem.other h) v","decl":"theorem edge_other_ne {e : Sym2 V} (he : e ∈ G.edgeSet) {v : V} (h : v ∈ e) :\n    Sym2.Mem.other h ≠ v := by\n  rw [← Sym2.other_spec h, Sym2.eq_swap] at he\n  exact G.ne_of_adj he\n\n"}
{"name":"SimpleGraph.fromEdgeSet_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nv w : V\ns : Set (Sym2 V)\n⊢ Iff ((SimpleGraph.fromEdgeSet s).Adj v w) (And (Membership.mem s (Sym2.mk { fst := v, snd := w })) (Ne v w))","decl":"@[simp]\ntheorem fromEdgeSet_adj : (fromEdgeSet s).Adj v w ↔ s(v, w) ∈ s ∧ v ≠ w :=\n  Iff.rfl\n\n-- Note: we need to make sure `fromEdgeSet_adj` and this lemma are confluent.\n-- In particular, both yield `s(u, v) ∈ (fromEdgeSet s).edgeSet` ==> `s(v, w) ∈ s ∧ v ≠ w`.\n"}
{"name":"SimpleGraph.edgeSet_fromEdgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ns : Set (Sym2 V)\n⊢ Eq (SimpleGraph.fromEdgeSet s).edgeSet (SDiff.sdiff s (setOf fun e => e.IsDiag))","decl":"@[simp]\ntheorem edgeSet_fromEdgeSet : (fromEdgeSet s).edgeSet = s \\ { e | e.IsDiag } := by\n  ext e\n  exact Sym2.ind (by simp) e\n\n"}
{"name":"SimpleGraph.fromEdgeSet_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq (SimpleGraph.fromEdgeSet G.edgeSet) G","decl":"@[simp]\ntheorem fromEdgeSet_edgeSet : fromEdgeSet G.edgeSet = G := by\n  ext v w\n  exact ⟨fun h => h.1, fun h => ⟨h, G.ne_of_adj h⟩⟩\n\n"}
{"name":"SimpleGraph.fromEdgeSet_empty","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq (SimpleGraph.fromEdgeSet EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem fromEdgeSet_empty : fromEdgeSet (∅ : Set (Sym2 V)) = ⊥ := by\n  ext v w\n  simp only [fromEdgeSet_adj, Set.mem_empty_iff_false, false_and, bot_adj]\n\n"}
{"name":"SimpleGraph.fromEdgeSet_univ","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\n⊢ Eq (SimpleGraph.fromEdgeSet Set.univ) Top.top","decl":"@[simp]\ntheorem fromEdgeSet_univ : fromEdgeSet (Set.univ : Set (Sym2 V)) = ⊤ := by\n  ext v w\n  simp only [fromEdgeSet_adj, Set.mem_univ, true_and, top_adj]\n\n"}
{"name":"SimpleGraph.fromEdgeSet_inter","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ns t : Set (Sym2 V)\n⊢ Eq (SimpleGraph.fromEdgeSet (Inter.inter s t)) (Min.min (SimpleGraph.fromEdgeSet s) (SimpleGraph.fromEdgeSet t))","decl":"@[simp]\ntheorem fromEdgeSet_inter (s t : Set (Sym2 V)) :\n    fromEdgeSet (s ∩ t) = fromEdgeSet s ⊓ fromEdgeSet t := by\n  ext v w\n  simp only [fromEdgeSet_adj, Set.mem_inter_iff, Ne, inf_adj]\n  tauto\n\n"}
{"name":"SimpleGraph.fromEdgeSet_union","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ns t : Set (Sym2 V)\n⊢ Eq (SimpleGraph.fromEdgeSet (Union.union s t)) (Max.max (SimpleGraph.fromEdgeSet s) (SimpleGraph.fromEdgeSet t))","decl":"@[simp]\ntheorem fromEdgeSet_union (s t : Set (Sym2 V)) :\n    fromEdgeSet (s ∪ t) = fromEdgeSet s ⊔ fromEdgeSet t := by\n  ext v w\n  simp [Set.mem_union, or_and_right]\n\n"}
{"name":"SimpleGraph.fromEdgeSet_sdiff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ns t : Set (Sym2 V)\n⊢ Eq (SimpleGraph.fromEdgeSet (SDiff.sdiff s t)) (SDiff.sdiff (SimpleGraph.fromEdgeSet s) (SimpleGraph.fromEdgeSet t))","decl":"@[simp]\ntheorem fromEdgeSet_sdiff (s t : Set (Sym2 V)) :\n    fromEdgeSet (s \\ t) = fromEdgeSet s \\ fromEdgeSet t := by\n  ext v w\n  constructor <;> simp +contextual\n\n"}
{"name":"SimpleGraph.fromEdgeSet_mono","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ns t : Set (Sym2 V)\nh : HasSubset.Subset s t\n⊢ LE.le (SimpleGraph.fromEdgeSet s) (SimpleGraph.fromEdgeSet t)","decl":"@[gcongr, mono]\ntheorem fromEdgeSet_mono {s t : Set (Sym2 V)} (h : s ⊆ t) : fromEdgeSet s ≤ fromEdgeSet t := by\n  rintro v w\n  simp +contextual only [fromEdgeSet_adj, Ne, not_false_iff,\n    and_true, and_imp]\n  exact fun vws _ => h vws\n\n"}
{"name":"SimpleGraph.disjoint_fromEdgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ Iff (Disjoint G (SimpleGraph.fromEdgeSet s)) (Disjoint G.edgeSet s)","decl":"@[simp] lemma disjoint_fromEdgeSet : Disjoint G (fromEdgeSet s) ↔ Disjoint G.edgeSet s := by\n  conv_rhs => rw [← Set.diff_union_inter s {e : Sym2 V | e.IsDiag}]\n  rw [← disjoint_edgeSet,  edgeSet_fromEdgeSet, Set.disjoint_union_right, and_iff_left]\n  exact Set.disjoint_left.2 fun e he he' ↦ not_isDiag_of_mem_edgeSet _ he he'.2\n\n"}
{"name":"SimpleGraph.fromEdgeSet_disjoint","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ Iff (Disjoint (SimpleGraph.fromEdgeSet s) G) (Disjoint s G.edgeSet)","decl":"@[simp] lemma fromEdgeSet_disjoint : Disjoint (fromEdgeSet s) G ↔ Disjoint s G.edgeSet := by\n  rw [disjoint_comm, disjoint_fromEdgeSet, disjoint_comm]\n\n"}
{"name":"SimpleGraph.incidenceSet_subset","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ HasSubset.Subset (G.incidenceSet v) G.edgeSet","decl":"theorem incidenceSet_subset (v : V) : G.incidenceSet v ⊆ G.edgeSet := fun _ h => h.1\n\n"}
{"name":"SimpleGraph.mk'_mem_incidenceSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b c : V\n⊢ Iff (Membership.mem (G.incidenceSet a) (Sym2.mk { fst := b, snd := c })) (And (G.Adj b c) (Or (Eq a b) (Eq a c)))","decl":"theorem mk'_mem_incidenceSet_iff : s(b, c) ∈ G.incidenceSet a ↔ G.Adj b c ∧ (a = b ∨ a = c) :=\n  and_congr_right' Sym2.mem_iff\n\n"}
{"name":"SimpleGraph.mk'_mem_incidenceSet_left_iff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\n⊢ Iff (Membership.mem (G.incidenceSet a) (Sym2.mk { fst := a, snd := b })) (G.Adj a b)","decl":"theorem mk'_mem_incidenceSet_left_iff : s(a, b) ∈ G.incidenceSet a ↔ G.Adj a b :=\n  and_iff_left <| Sym2.mem_mk_left _ _\n\n"}
{"name":"SimpleGraph.mk'_mem_incidenceSet_right_iff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\n⊢ Iff (Membership.mem (G.incidenceSet b) (Sym2.mk { fst := a, snd := b })) (G.Adj a b)","decl":"theorem mk'_mem_incidenceSet_right_iff : s(a, b) ∈ G.incidenceSet b ↔ G.Adj a b :=\n  and_iff_left <| Sym2.mem_mk_right _ _\n\n"}
{"name":"SimpleGraph.edge_mem_incidenceSet_iff","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na : V\ne : ↑G.edgeSet\n⊢ Iff (Membership.mem (G.incidenceSet a) ↑e) (Membership.mem (↑e) a)","decl":"theorem edge_mem_incidenceSet_iff {e : G.edgeSet} : ↑e ∈ G.incidenceSet a ↔ a ∈ (e : Sym2 V) :=\n  and_iff_right e.2\n\n"}
{"name":"SimpleGraph.incidenceSet_inter_incidenceSet_subset","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\nh : Ne a b\n⊢ HasSubset.Subset (Inter.inter (G.incidenceSet a) (G.incidenceSet b)) (Singleton.singleton (Sym2.mk { fst := a, snd := b }))","decl":"theorem incidenceSet_inter_incidenceSet_subset (h : a ≠ b) :\n    G.incidenceSet a ∩ G.incidenceSet b ⊆ {s(a, b)} := fun _e he =>\n  (Sym2.mem_and_mem_iff h).1 ⟨he.1.2, he.2.2⟩\n\n"}
{"name":"SimpleGraph.incidenceSet_inter_incidenceSet_of_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\nh : G.Adj a b\n⊢ Eq (Inter.inter (G.incidenceSet a) (G.incidenceSet b)) (Singleton.singleton (Sym2.mk { fst := a, snd := b }))","decl":"theorem incidenceSet_inter_incidenceSet_of_adj (h : G.Adj a b) :\n    G.incidenceSet a ∩ G.incidenceSet b = {s(a, b)} := by\n  refine (G.incidenceSet_inter_incidenceSet_subset <| h.ne).antisymm ?_\n  rintro _ (rfl : _ = s(a, b))\n  exact ⟨G.mk'_mem_incidenceSet_left_iff.2 h, G.mk'_mem_incidenceSet_right_iff.2 h⟩\n\n"}
{"name":"SimpleGraph.adj_of_mem_incidenceSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\ne : Sym2 V\nh : Ne a b\nha : Membership.mem (G.incidenceSet a) e\nhb : Membership.mem (G.incidenceSet b) e\n⊢ G.Adj a b","decl":"theorem adj_of_mem_incidenceSet (h : a ≠ b) (ha : e ∈ G.incidenceSet a)\n    (hb : e ∈ G.incidenceSet b) : G.Adj a b := by\n  rwa [← mk'_mem_incidenceSet_left_iff, ←\n    Set.mem_singleton_iff.1 <| G.incidenceSet_inter_incidenceSet_subset h ⟨ha, hb⟩]\n\n"}
{"name":"SimpleGraph.incidenceSet_inter_incidenceSet_of_not_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na b : V\nh : Not (G.Adj a b)\nhn : Ne a b\n⊢ Eq (Inter.inter (G.incidenceSet a) (G.incidenceSet b)) EmptyCollection.emptyCollection","decl":"theorem incidenceSet_inter_incidenceSet_of_not_adj (h : ¬G.Adj a b) (hn : a ≠ b) :\n    G.incidenceSet a ∩ G.incidenceSet b = ∅ := by\n  simp_rw [Set.eq_empty_iff_forall_not_mem, Set.mem_inter_iff, not_and]\n  intro u ha hb\n  exact h (G.adj_of_mem_incidenceSet hn ha hb)\n\n"}
{"name":"SimpleGraph.mem_neighborSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (Membership.mem (G.neighborSet v) w) (G.Adj v w)","decl":"@[simp]\ntheorem mem_neighborSet (v w : V) : w ∈ G.neighborSet v ↔ G.Adj v w :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.not_mem_neighborSet_self","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\na : V\n⊢ Not (Membership.mem (G.neighborSet a) a)","decl":"lemma not_mem_neighborSet_self : a ∉ G.neighborSet a := by simp\n\n"}
{"name":"SimpleGraph.mem_incidenceSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (Membership.mem (G.incidenceSet v) (Sym2.mk { fst := v, snd := w })) (G.Adj v w)","decl":"@[simp]\ntheorem mem_incidenceSet (v w : V) : s(v, w) ∈ G.incidenceSet v ↔ G.Adj v w := by\n  simp [incidenceSet]\n\n"}
{"name":"SimpleGraph.mem_incidence_iff_neighbor","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Iff (Membership.mem (G.incidenceSet v) (Sym2.mk { fst := v, snd := w })) (Membership.mem (G.neighborSet v) w)","decl":"theorem mem_incidence_iff_neighbor {v w : V} :\n    s(v, w) ∈ G.incidenceSet v ↔ w ∈ G.neighborSet v := by\n  simp only [mem_incidenceSet, mem_neighborSet]\n\n"}
{"name":"SimpleGraph.adj_incidenceSet_inter","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\ne : Sym2 V\nhe : Membership.mem G.edgeSet e\nh : Membership.mem e v\n⊢ Eq (Inter.inter (G.incidenceSet v) (G.incidenceSet (Sym2.Mem.other h))) (Singleton.singleton e)","decl":"theorem adj_incidenceSet_inter {v : V} {e : Sym2 V} (he : e ∈ G.edgeSet) (h : v ∈ e) :\n    G.incidenceSet v ∩ G.incidenceSet (Sym2.Mem.other h) = {e} := by\n  ext e'\n  simp only [incidenceSet, Set.mem_sep_iff, Set.mem_inter_iff, Set.mem_singleton_iff]\n  refine ⟨fun h' => ?_, ?_⟩\n  · rw [← Sym2.other_spec h]\n    exact (Sym2.mem_and_mem_iff (edge_other_ne G he h).symm).mp ⟨h'.1.2, h'.2.2⟩\n  · rintro rfl\n    exact ⟨⟨he, h⟩, he, Sym2.other_mem _⟩\n\n"}
{"name":"SimpleGraph.compl_neighborSet_disjoint","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Disjoint (G.neighborSet v) ((HasCompl.compl G).neighborSet v)","decl":"theorem compl_neighborSet_disjoint (G : SimpleGraph V) (v : V) :\n    Disjoint (G.neighborSet v) (Gᶜ.neighborSet v) := by\n  rw [Set.disjoint_iff]\n  rintro w ⟨h, h'⟩\n  rw [mem_neighborSet, compl_adj] at h'\n  exact h'.2 h\n\n"}
{"name":"SimpleGraph.neighborSet_union_compl_neighborSet_eq","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq (Union.union (G.neighborSet v) ((HasCompl.compl G).neighborSet v)) (HasCompl.compl (Singleton.singleton v))","decl":"theorem neighborSet_union_compl_neighborSet_eq (G : SimpleGraph V) (v : V) :\n    G.neighborSet v ∪ Gᶜ.neighborSet v = {v}ᶜ := by\n  ext w\n  have h := @ne_of_adj _ G\n  simp_rw [Set.mem_union, mem_neighborSet, compl_adj, Set.mem_compl_iff, Set.mem_singleton_iff]\n  tauto\n\n"}
{"name":"SimpleGraph.card_neighborSet_union_compl_neighborSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\ninst✝¹ : Fintype V\nG : SimpleGraph V\nv : V\ninst✝ : Fintype ↑(Union.union (G.neighborSet v) ((HasCompl.compl G).neighborSet v))\n⊢ Eq (Union.union (G.neighborSet v) ((HasCompl.compl G).neighborSet v)).toFinset.card (HSub.hSub (Fintype.card V) 1)","decl":"theorem card_neighborSet_union_compl_neighborSet [Fintype V] (G : SimpleGraph V) (v : V)\n    [Fintype (G.neighborSet v ∪ Gᶜ.neighborSet v : Set V)] :\n    #(G.neighborSet v ∪ Gᶜ.neighborSet v).toFinset = Fintype.card V - 1 := by\n  classical simp_rw [neighborSet_union_compl_neighborSet_eq, Set.toFinset_compl,\n      Finset.card_compl, Set.toFinset_card, Set.card_singleton]\n\n"}
{"name":"SimpleGraph.neighborSet_compl","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv : V\n⊢ Eq ((HasCompl.compl G).neighborSet v) (SDiff.sdiff (HasCompl.compl (G.neighborSet v)) (Singleton.singleton v))","decl":"theorem neighborSet_compl (G : SimpleGraph V) (v : V) :\n    Gᶜ.neighborSet v = (G.neighborSet v)ᶜ \\ {v} := by\n  ext w\n  simp [and_comm, eq_comm]\n\n"}
{"name":"SimpleGraph.commonNeighbors_eq","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Eq (G.commonNeighbors v w) (Inter.inter (G.neighborSet v) (G.neighborSet w))","decl":"theorem commonNeighbors_eq (v w : V) : G.commonNeighbors v w = G.neighborSet v ∩ G.neighborSet w :=\n  rfl\n\n"}
{"name":"SimpleGraph.mem_commonNeighbors","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nu v w : V\n⊢ Iff (Membership.mem (G.commonNeighbors v w) u) (And (G.Adj v u) (G.Adj w u))","decl":"theorem mem_commonNeighbors {u v w : V} : u ∈ G.commonNeighbors v w ↔ G.Adj v u ∧ G.Adj w u :=\n  Iff.rfl\n\n"}
{"name":"SimpleGraph.commonNeighbors_symm","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Eq (G.commonNeighbors v w) (G.commonNeighbors w v)","decl":"theorem commonNeighbors_symm (v w : V) : G.commonNeighbors v w = G.commonNeighbors w v :=\n  Set.inter_comm _ _\n\n"}
{"name":"SimpleGraph.not_mem_commonNeighbors_left","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Not (Membership.mem (G.commonNeighbors v w) v)","decl":"theorem not_mem_commonNeighbors_left (v w : V) : v ∉ G.commonNeighbors v w := fun h =>\n  ne_of_adj G h.1 rfl\n\n"}
{"name":"SimpleGraph.not_mem_commonNeighbors_right","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ Not (Membership.mem (G.commonNeighbors v w) w)","decl":"theorem not_mem_commonNeighbors_right (v w : V) : w ∉ G.commonNeighbors v w := fun h =>\n  ne_of_adj G h.2 rfl\n\n"}
{"name":"SimpleGraph.commonNeighbors_subset_neighborSet_left","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ HasSubset.Subset (G.commonNeighbors v w) (G.neighborSet v)","decl":"theorem commonNeighbors_subset_neighborSet_left (v w : V) :\n    G.commonNeighbors v w ⊆ G.neighborSet v :=\n  Set.inter_subset_left\n\n"}
{"name":"SimpleGraph.commonNeighbors_subset_neighborSet_right","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\n⊢ HasSubset.Subset (G.commonNeighbors v w) (G.neighborSet w)","decl":"theorem commonNeighbors_subset_neighborSet_right (v w : V) :\n    G.commonNeighbors v w ⊆ G.neighborSet w :=\n  Set.inter_subset_right\n\n"}
{"name":"SimpleGraph.commonNeighbors_top_eq","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nv w : V\n⊢ Eq (Top.top.commonNeighbors v w) (SDiff.sdiff Set.univ (Insert.insert v (Singleton.singleton w)))","decl":"theorem commonNeighbors_top_eq {v w : V} :\n    (⊤ : SimpleGraph V).commonNeighbors v w = Set.univ \\ {v, w} := by\n  ext u\n  simp [commonNeighbors, eq_comm, not_or]\n\n"}
{"name":"SimpleGraph.edge_other_incident_set","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nv : V\ne : Sym2 V\nh : Membership.mem (G.incidenceSet v) e\n⊢ Membership.mem (G.incidenceSet (G.otherVertexOfIncident h)) e","decl":"theorem edge_other_incident_set {v : V} {e : Sym2 V} (h : e ∈ G.incidenceSet v) :\n    e ∈ G.incidenceSet (G.otherVertexOfIncident h) := by\n  use h.1\n  simp [otherVertexOfIncident, Sym2.other_mem']\n\n"}
{"name":"SimpleGraph.incidence_other_prop","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nv : V\ne : Sym2 V\nh : Membership.mem (G.incidenceSet v) e\n⊢ Membership.mem (G.neighborSet v) (G.otherVertexOfIncident h)","decl":"theorem incidence_other_prop {v : V} {e : Sym2 V} (h : e ∈ G.incidenceSet v) :\n    G.otherVertexOfIncident h ∈ G.neighborSet v := by\n  cases' h with he hv\n  rwa [← Sym2.other_spec' hv, mem_edgeSet] at he\n\n-- Porting note: as a simp lemma this does not apply even to itself\n"}
{"name":"SimpleGraph.incidence_other_neighbor_edge","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nv w : V\nh : Membership.mem (G.neighborSet v) w\n⊢ Eq (G.otherVertexOfIncident ⋯) w","decl":"theorem incidence_other_neighbor_edge {v w : V} (h : w ∈ G.neighborSet v) :\n    G.otherVertexOfIncident (G.mem_incidence_iff_neighbor.mpr h) = w :=\n  Sym2.congr_right.mp (Sym2.other_spec' (G.mem_incidence_iff_neighbor.mpr h).right)\n\n"}
{"name":"SimpleGraph.incidenceSetEquivNeighborSet_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nv : V\ne : ↑(G.incidenceSet v)\n⊢ Eq (↑((G.incidenceSetEquivNeighborSet v) e)) (G.otherVertexOfIncident ⋯)","decl":"/-- There is an equivalence between the set of edges incident to a given\nvertex and the set of vertices adjacent to the vertex. -/\n@[simps]\ndef incidenceSetEquivNeighborSet (v : V) : G.incidenceSet v ≃ G.neighborSet v where\n  toFun e := ⟨G.otherVertexOfIncident e.2, G.incidence_other_prop e.2⟩\n  invFun w := ⟨s(v, w.1), G.mem_incidence_iff_neighbor.mpr w.2⟩\n  left_inv x := by simp [otherVertexOfIncident]\n  right_inv := fun ⟨w, hw⟩ => by\n    simp only [mem_neighborSet, Subtype.mk.injEq]\n    exact incidence_other_neighbor_edge _ hw\n\n"}
{"name":"SimpleGraph.incidenceSetEquivNeighborSet_symm_apply_coe","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ninst✝ : DecidableEq V\nv : V\nw : ↑(G.neighborSet v)\n⊢ Eq (↑((G.incidenceSetEquivNeighborSet v).symm w)) (Sym2.mk { fst := v, snd := ↑w })","decl":"/-- There is an equivalence between the set of edges incident to a given\nvertex and the set of vertices adjacent to the vertex. -/\n@[simps]\ndef incidenceSetEquivNeighborSet (v : V) : G.incidenceSet v ≃ G.neighborSet v where\n  toFun e := ⟨G.otherVertexOfIncident e.2, G.incidence_other_prop e.2⟩\n  invFun w := ⟨s(v, w.1), G.mem_incidence_iff_neighbor.mpr w.2⟩\n  left_inv x := by simp [otherVertexOfIncident]\n  right_inv := fun ⟨w, hw⟩ => by\n    simp only [mem_neighborSet, Subtype.mk.injEq]\n    exact incidence_other_neighbor_edge _ hw\n\n"}
{"name":"SimpleGraph.deleteEdges_adj","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\nv w : V\ns : Set (Sym2 V)\n⊢ Iff ((G.deleteEdges s).Adj v w) (And (G.Adj v w) (Not (Membership.mem s (Sym2.mk { fst := v, snd := w }))))","decl":"@[simp] lemma deleteEdges_adj : (G.deleteEdges s).Adj v w ↔ G.Adj v w ∧ ¬s(v, w) ∈ s :=\n  and_congr_right fun h ↦ (and_iff_left h.ne).not\n\n"}
{"name":"SimpleGraph.deleteEdges_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG G' : SimpleGraph V\n⊢ Eq (G.deleteEdges G'.edgeSet) (SDiff.sdiff G G')","decl":"@[simp] lemma deleteEdges_edgeSet (G G' : SimpleGraph V) : G.deleteEdges G'.edgeSet = G \\ G' := by\n  ext; simp\n\n"}
{"name":"SimpleGraph.deleteEdges_deleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns s' : Set (Sym2 V)\n⊢ Eq ((G.deleteEdges s).deleteEdges s') (G.deleteEdges (Union.union s s'))","decl":"@[simp]\ntheorem deleteEdges_deleteEdges (s s' : Set (Sym2 V)) :\n    (G.deleteEdges s).deleteEdges s' = G.deleteEdges (s ∪ s') := by simp [deleteEdges, sdiff_sdiff]\n\n"}
{"name":"SimpleGraph.deleteEdges_empty","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq (G.deleteEdges EmptyCollection.emptyCollection) G","decl":"@[simp] lemma deleteEdges_empty : G.deleteEdges ∅ = G := by simp [deleteEdges]\n"}
{"name":"SimpleGraph.deleteEdges_univ","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\n⊢ Eq (G.deleteEdges Set.univ) Bot.bot","decl":"@[simp] lemma deleteEdges_univ : G.deleteEdges Set.univ = ⊥ := by simp [deleteEdges]\n\n"}
{"name":"SimpleGraph.deleteEdges_le","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ LE.le (G.deleteEdges s) G","decl":"lemma deleteEdges_le (s : Set (Sym2 V)) : G.deleteEdges s ≤ G := sdiff_le\n\n"}
{"name":"SimpleGraph.deleteEdges_anti","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns₁ s₂ : Set (Sym2 V)\nh : HasSubset.Subset s₁ s₂\n⊢ LE.le (G.deleteEdges s₂) (G.deleteEdges s₁)","decl":"lemma deleteEdges_anti (h : s₁ ⊆ s₂) : G.deleteEdges s₂ ≤ G.deleteEdges s₁ :=\n  sdiff_le_sdiff_left <| fromEdgeSet_mono h\n\n"}
{"name":"SimpleGraph.deleteEdges_mono","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG H : SimpleGraph V\ns : Set (Sym2 V)\nh : LE.le G H\n⊢ LE.le (G.deleteEdges s) (H.deleteEdges s)","decl":"lemma deleteEdges_mono (h : G ≤ H) : G.deleteEdges s ≤ H.deleteEdges s := sdiff_le_sdiff_right h\n\n"}
{"name":"SimpleGraph.deleteEdges_eq_self","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ Iff (Eq (G.deleteEdges s) G) (Disjoint G.edgeSet s)","decl":"@[simp] lemma deleteEdges_eq_self : G.deleteEdges s = G ↔ Disjoint G.edgeSet s := by\n  rw [deleteEdges, sdiff_eq_left, disjoint_fromEdgeSet]\n\n"}
{"name":"SimpleGraph.deleteEdges_eq_inter_edgeSet","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ Eq (G.deleteEdges s) (G.deleteEdges (Inter.inter s G.edgeSet))","decl":"theorem deleteEdges_eq_inter_edgeSet (s : Set (Sym2 V)) :\n    G.deleteEdges s = G.deleteEdges (s ∩ G.edgeSet) := by\n  ext\n  simp +contextual [imp_false]\n\n"}
{"name":"SimpleGraph.deleteEdges_sdiff_eq_of_le","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG H : SimpleGraph V\nh : LE.le H G\n⊢ Eq (G.deleteEdges (SDiff.sdiff G.edgeSet H.edgeSet)) H","decl":"theorem deleteEdges_sdiff_eq_of_le {H : SimpleGraph V} (h : H ≤ G) :\n    G.deleteEdges (G.edgeSet \\ H.edgeSet) = H := by\n  rw [← edgeSet_sdiff, deleteEdges_edgeSet, sdiff_sdiff_eq_self h]\n\n"}
{"name":"SimpleGraph.edgeSet_deleteEdges","module":"Mathlib.Combinatorics.SimpleGraph.Basic","initialProofState":"V : Type u\nG : SimpleGraph V\ns : Set (Sym2 V)\n⊢ Eq (G.deleteEdges s).edgeSet (SDiff.sdiff G.edgeSet s)","decl":"theorem edgeSet_deleteEdges (s : Set (Sym2 V)) : (G.deleteEdges s).edgeSet = G.edgeSet \\ s := by\n  simp [deleteEdges]\n\n"}
