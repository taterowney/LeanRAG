{"name":"ModularGroup.bottom_row_coprime","module":"Mathlib.NumberTheory.Modular","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\ng : Matrix.SpecialLinearGroup (Fin 2) R\n‚ä¢ IsCoprime (‚Üëg 1 0) (‚Üëg 1 1)","decl":"/-- The two numbers `c`, `d` in the \"bottom_row\" of `g=[[*,*],[c,d]]` in `SL(2, ‚Ñ§)` are coprime. -/\ntheorem bottom_row_coprime {R : Type*} [CommRing R] (g : SL(2, R)) :\n    IsCoprime ((‚Üëg : Matrix (Fin 2) (Fin 2) R) 1 0) ((‚Üëg : Matrix (Fin 2) (Fin 2) R) 1 1) := by\n  use -(‚Üëg : Matrix (Fin 2) (Fin 2) R) 0 1, (‚Üëg : Matrix (Fin 2) (Fin 2) R) 0 0\n  rw [add_comm, neg_mul, ‚Üê sub_eq_add_neg, ‚Üê det_fin_two]\n  exact g.det_coe\n\n"}
{"name":"ModularGroup.bottom_row_surj","module":"Mathlib.NumberTheory.Modular","initialProofState":"R : Type u_1\ninst‚úù : CommRing R\n‚ä¢ Set.SurjOn (fun g => ‚Üëg 1) Set.univ (setOf fun cd => IsCoprime (cd 0) (cd 1))","decl":"/-- Every pair `![c, d]` of coprime integers is the \"bottom_row\" of some element `g=[[*,*],[c,d]]`\nof `SL(2,‚Ñ§)`. -/\ntheorem bottom_row_surj {R : Type*} [CommRing R] :\n    Set.SurjOn (fun g : SL(2, R) => (‚Üëg : Matrix (Fin 2) (Fin 2) R) 1) Set.univ\n      {cd | IsCoprime (cd 0) (cd 1)} := by\n  rintro cd ‚ü®b‚ÇÄ, a, gcd_eqn‚ü©\n  let A := of ![![a, -b‚ÇÄ], cd]\n  have det_A_1 : det A = 1 := by\n    convert gcd_eqn\n    rw [det_fin_two]\n    simp [A, (by ring : a * cd 1 + b‚ÇÄ * cd 0 = b‚ÇÄ * cd 0 + a * cd 1)]\n  refine ‚ü®‚ü®A, det_A_1‚ü©, Set.mem_univ _, ?_‚ü©\n  ext; simp [A]\n\n"}
{"name":"ModularGroup.tendsto_normSq_coprime_pair","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Filter.Tendsto (fun p => Complex.normSq (HAdd.hAdd (HMul.hMul ‚Üë(p 0) ‚Üëz) ‚Üë(p 1))) Filter.cofinite Filter.atTop","decl":"/-- The function `(c,d) ‚Üí |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite.\n-/\ntheorem tendsto_normSq_coprime_pair :\n    Filter.Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * z + p 1)) cofinite atTop := by\n  -- using this instance rather than the automatic `Function.module` makes unification issues in\n  -- `LinearEquiv.isClosedEmbedding_of_injective` less bad later in the proof.\n  letI : Module ‚Ñù (Fin 2 ‚Üí ‚Ñù) := NormedSpace.toModule\n  let œÄ‚ÇÄ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 0\n  let œÄ‚ÇÅ : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚Ñù := LinearMap.proj 1\n  let f : (Fin 2 ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] ‚ÑÇ := œÄ‚ÇÄ.smulRight (z : ‚ÑÇ) + œÄ‚ÇÅ.smulRight 1\n  have f_def : ‚áëf = fun p : Fin 2 ‚Üí ‚Ñù => (p 0 : ‚ÑÇ) * ‚Üëz + p 1 := by\n    ext1\n    dsimp only [œÄ‚ÇÄ, œÄ‚ÇÅ, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,\n      LinearMap.add_apply]\n    rw [mul_one]\n  have :\n    (fun p : Fin 2 ‚Üí ‚Ñ§ => normSq ((p 0 : ‚ÑÇ) * ‚Üëz + ‚Üë(p 1))) =\n      normSq ‚àò f ‚àò fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p := by\n    ext1\n    rw [f_def]\n    dsimp only [Function.comp_def]\n    rw [ofReal_intCast, ofReal_intCast]\n  rw [this]\n  have hf : LinearMap.ker f = ‚ä• := by\n    let g : ‚ÑÇ ‚Üí‚Çó[‚Ñù] Fin 2 ‚Üí ‚Ñù :=\n      LinearMap.pi ![imLm, imLm.comp ((z : ‚ÑÇ) ‚Ä¢ ((conjAe : ‚ÑÇ ‚Üí‚Çê[‚Ñù] ‚ÑÇ) : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚ÑÇ))]\n    suffices ((z : ‚ÑÇ).im‚Åª¬π ‚Ä¢ g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this\n    apply LinearMap.ext\n    intro c\n    have hz : (z : ‚ÑÇ).im ‚â† 0 := z.2.ne'\n    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]\n    ext i\n    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]\n    fin_cases i\n    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * (f c).im = c 0\n      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel‚ÇÄ hz,\n        mul_one]\n    ¬∑ show (z : ‚ÑÇ).im‚Åª¬π * ((z : ‚ÑÇ) * conj (f c)).im = c 1\n      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,\n        conj_ofReal, ‚Üê ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul‚ÇÄ hz]\n      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]\n  have hf' : IsClosedEmbedding f := f.isClosedEmbedding_of_injective hf\n  have h‚ÇÇ : Tendsto (fun p : Fin 2 ‚Üí ‚Ñ§ => ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p) cofinite (cocompact _) := by\n    convert Tendsto.pi_map_coprod·µ¢ fun _ => Int.tendsto_coe_cofinite\n    ¬∑ rw [coprod·µ¢_cofinite]\n    ¬∑ rw [coprod·µ¢_cocompact]\n  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h‚ÇÇ)\n\n"}
{"name":"ModularGroup.lcRow0_apply","module":"Mathlib.NumberTheory.Modular","initialProofState":"p : Fin 2 ‚Üí Int\ng : Matrix (Fin 2) (Fin 2) Real\n‚ä¢ Eq ((ModularGroup.lcRow0 p) g) (HAdd.hAdd (HMul.hMul (‚Üë(p 0)) (g 0 0)) (HMul.hMul (‚Üë(p 1)) (g 0 1)))","decl":"@[simp]\ntheorem lcRow0_apply (p : Fin 2 ‚Üí ‚Ñ§) (g : Matrix (Fin 2) (Fin 2) ‚Ñù) :\n    lcRow0 p g = p 0 * g 0 0 + p 1 * g 0 1 :=\n  rfl\n\n"}
{"name":"ModularGroup.lcRow0Extend_symm_apply","module":"Mathlib.NumberTheory.Modular","initialProofState":"cd : Fin 2 ‚Üí Int\nhcd : IsCoprime (cd 0) (cd 1)\nf : (i : Fin 2) ‚Üí (fun a => Fin 2 ‚Üí Real) i\ni a‚úù : Fin 2\n‚ä¢ Eq ((ModularGroup.lcRow0Extend hcd).symm f i a‚úù) ((Matrix.vecCons ((LinearMap.GeneralLinearGroup.generalLinearEquiv Real (Fin 2 ‚Üí Real)) (Matrix.GeneralLinearGroup.toLin (Matrix.planeConformalMatrix (‚Üë(cd 0)) (Neg.neg ‚Üë(cd 1)) ‚ãØ))) (Matrix.vecCons (LinearEquiv.refl Real (Fin 2 ‚Üí Real)) Matrix.vecEmpty) i).symm (f i) a‚úù)","decl":"/-- Linear map sending the matrix [a, b; c, d] to the matrix [ac‚ÇÄ + bd‚ÇÄ, - ad‚ÇÄ + bc‚ÇÄ; c, d], for\nsome fixed `(c‚ÇÄ, d‚ÇÄ)`. -/\n@[simps!]\ndef lcRow0Extend {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çó[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù :=\n  LinearEquiv.piCongrRight\n    ![by\n      refine\n        LinearMap.GeneralLinearGroup.generalLinearEquiv ‚Ñù (Fin 2 ‚Üí ‚Ñù)\n          (GeneralLinearGroup.toLin (planeConformalMatrix (cd 0 : ‚Ñù) (-(cd 1 : ‚Ñù)) ?_))\n      norm_cast\n      rw [neg_sq]\n      exact hcd.sq_add_sq_ne_zero, LinearEquiv.refl ‚Ñù (Fin 2 ‚Üí ‚Ñù)]\n\n"}
{"name":"ModularGroup.lcRow0Extend_apply","module":"Mathlib.NumberTheory.Modular","initialProofState":"cd : Fin 2 ‚Üí Int\nhcd : IsCoprime (cd 0) (cd 1)\nf : (i : Fin 2) ‚Üí (fun a => Fin 2 ‚Üí Real) i\ni a‚úù : Fin 2\n‚ä¢ Eq ((ModularGroup.lcRow0Extend hcd) f i a‚úù) ((Matrix.vecCons ((LinearMap.GeneralLinearGroup.generalLinearEquiv Real (Fin 2 ‚Üí Real)) (Matrix.GeneralLinearGroup.toLin (Matrix.planeConformalMatrix (‚Üë(cd 0)) (Neg.neg ‚Üë(cd 1)) ‚ãØ))) (Matrix.vecCons (LinearEquiv.refl Real (Fin 2 ‚Üí Real)) Matrix.vecEmpty) i) (f i) a‚úù)","decl":"/-- Linear map sending the matrix [a, b; c, d] to the matrix [ac‚ÇÄ + bd‚ÇÄ, - ad‚ÇÄ + bc‚ÇÄ; c, d], for\nsome fixed `(c‚ÇÄ, d‚ÇÄ)`. -/\n@[simps!]\ndef lcRow0Extend {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Matrix (Fin 2) (Fin 2) ‚Ñù ‚âÉ‚Çó[‚Ñù] Matrix (Fin 2) (Fin 2) ‚Ñù :=\n  LinearEquiv.piCongrRight\n    ![by\n      refine\n        LinearMap.GeneralLinearGroup.generalLinearEquiv ‚Ñù (Fin 2 ‚Üí ‚Ñù)\n          (GeneralLinearGroup.toLin (planeConformalMatrix (cd 0 : ‚Ñù) (-(cd 1 : ‚Ñù)) ?_))\n      norm_cast\n      rw [neg_sq]\n      exact hcd.sq_add_sq_ne_zero, LinearEquiv.refl ‚Ñù (Fin 2 ‚Üí ‚Ñù)]\n\n"}
{"name":"ModularGroup.tendsto_lcRow0","module":"Mathlib.NumberTheory.Modular","initialProofState":"cd : Fin 2 ‚Üí Int\nhcd : IsCoprime (cd 0) (cd 1)\n‚ä¢ Filter.Tendsto (fun g => (ModularGroup.lcRow0 cd) ‚Üë((Matrix.SpecialLinearGroup.map (Int.castRingHom Real)) ‚Üëg)) Filter.cofinite (Filter.cocompact Real)","decl":"/-- The map `lcRow0` is proper, that is, preimages of cocompact sets are finite in\n`[[* , *], [c, d]]`. -/\ntheorem tendsto_lcRow0 {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Tendsto (fun g : { g : SL(2, ‚Ñ§) // g 1 = cd } => lcRow0 cd ‚Üë(‚Üëg : SL(2, ‚Ñù))) cofinite\n      (cocompact ‚Ñù) := by\n  let mB : ‚Ñù ‚Üí Matrix (Fin 2) (Fin 2) ‚Ñù := fun t => of ![![t, (-(1 : ‚Ñ§) : ‚Ñù)], (‚Üë) ‚àò cd]\n  have hmB : Continuous mB := by\n    refine continuous_matrix ?_\n    simp only [mB, Fin.forall_fin_two, continuous_const, continuous_id', of_apply, cons_val_zero,\n      cons_val_one, and_self_iff]\n  refine Filter.Tendsto.of_tendsto_comp ?_ (comap_cocompact_le hmB)\n  let f‚ÇÅ : SL(2, ‚Ñ§) ‚Üí Matrix (Fin 2) (Fin 2) ‚Ñù := fun g =>\n    Matrix.map (‚Üëg : Matrix _ _ ‚Ñ§) ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù)\n  have cocompact_‚Ñù_to_cofinite_‚Ñ§_matrix :\n    Tendsto (fun m : Matrix (Fin 2) (Fin 2) ‚Ñ§ => Matrix.map m ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù)) cofinite\n      (cocompact _) := by\n    simpa only [coprod·µ¢_cofinite, coprod·µ¢_cocompact] using\n      Tendsto.pi_map_coprod·µ¢ fun _ : Fin 2 =>\n        Tendsto.pi_map_coprod·µ¢ fun _ : Fin 2 => Int.tendsto_coe_cofinite\n  have hf‚ÇÅ : Tendsto f‚ÇÅ cofinite (cocompact _) :=\n    cocompact_‚Ñù_to_cofinite_‚Ñ§_matrix.comp Subtype.coe_injective.tendsto_cofinite\n  have hf‚ÇÇ : IsClosedEmbedding (lcRow0Extend hcd) :=\n    (lcRow0Extend hcd).toContinuousLinearEquiv.toHomeomorph.isClosedEmbedding\n  convert hf‚ÇÇ.tendsto_cocompact.comp (hf‚ÇÅ.comp Subtype.coe_injective.tendsto_cofinite) using 1\n  ext ‚ü®g, rfl‚ü© i j : 3\n  fin_cases i <;> [fin_cases j; skip]\n  -- the following are proved by `simp`, but it is replaced by `simp only` to avoid timeouts.\n  ¬∑ simp only [Fin.isValue, Int.cast_one, map_apply_coe, RingHom.mapMatrix_apply,\n      Int.coe_castRingHom, lcRow0_apply, map_apply, Fin.zero_eta, id_eq, Function.comp_apply,\n      of_apply, cons_val', cons_val_zero, empty_val', cons_val_fin_one, lcRow0Extend_apply,\n      LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv, GeneralLinearGroup.coe_toLin,\n      val_planeConformalMatrix, neg_neg, mulVecLin_apply, mulVec, dotProduct, Fin.sum_univ_two,\n      cons_val_one, head_cons, mB, f‚ÇÅ]\n  ¬∑ convert congr_arg (fun n : ‚Ñ§ => (-n : ‚Ñù)) g.det_coe.symm using 1\n    simp only [Fin.zero_eta, id_eq, Function.comp_apply, lcRow0Extend_apply, cons_val_zero,\n      LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv, GeneralLinearGroup.coe_toLin,\n      mulVecLin_apply, mulVec, dotProduct, det_fin_two, f‚ÇÅ]\n    simp only [Fin.isValue, Fin.mk_one, val_planeConformalMatrix, neg_neg, of_apply, cons_val',\n      empty_val', cons_val_fin_one, cons_val_one, head_fin_const, map_apply, Fin.sum_univ_two,\n      cons_val_zero, neg_mul, head_cons, Int.cast_sub, Int.cast_mul, neg_sub]\n    ring\n  ¬∑ rfl\n\n"}
{"name":"ModularGroup.smul_eq_lcRow0_add","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\np : Fin 2 ‚Üí Int\nhp : IsCoprime (p 0) (p 1)\nhg : Eq (‚Üëg 1) p\n‚ä¢ Eq (‚Üë(HSMul.hSMul g z)) (HAdd.hAdd (HDiv.hDiv (‚Üë((ModularGroup.lcRow0 p) ‚Üë((Matrix.SpecialLinearGroup.map (Int.castRingHom Real)) g))) (HAdd.hAdd (HPow.hPow (‚Üë(p 0)) 2) (HPow.hPow (‚Üë(p 1)) 2))) (HDiv.hDiv (HSub.hSub (HMul.hMul ‚Üë(p 1) ‚Üëz) ‚Üë(p 0)) (HMul.hMul (HAdd.hAdd (HPow.hPow (‚Üë(p 0)) 2) (HPow.hPow (‚Üë(p 1)) 2)) (HAdd.hAdd (HMul.hMul ‚Üë(p 0) ‚Üëz) ‚Üë(p 1)))))","decl":"/-- This replaces `(g‚Ä¢z).re = a/c + *` in the standard theory with the following novel identity:\n  `g ‚Ä¢ z = (a c + b d) / (c^2 + d^2) + (d z - c) / ((c^2 + d^2) (c z + d))`\n  which does not need to be decomposed depending on whether `c = 0`. -/\ntheorem smul_eq_lcRow0_add {p : Fin 2 ‚Üí ‚Ñ§} (hp : IsCoprime (p 0) (p 1)) (hg : g 1 = p) :\n    ‚Üë(g ‚Ä¢ z) =\n      (lcRow0 p ‚Üë(g : SL(2, ‚Ñù)) : ‚ÑÇ) / ((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) +\n        ((p 1 : ‚ÑÇ) * z - p 0) / (((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) * (p 0 * z + p 1)) := by\n  have nonZ1 : (p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2 ‚â† 0 := mod_cast hp.sq_add_sq_ne_zero\n  have : ((‚Üë) : ‚Ñ§ ‚Üí ‚Ñù) ‚àò p ‚â† 0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)\n  have nonZ2 : (p 0 : ‚ÑÇ) * z + p 1 ‚â† 0 := by simpa using linear_ne_zero _ z this\n  field_simp [nonZ1, nonZ2, denom_ne_zero, num]\n  rw [(by simp :\n    (p 1 : ‚ÑÇ) * z - p 0 = (p 1 * z - p 0) * ‚Üë(Matrix.det (‚Üëg : Matrix (Fin 2) (Fin 2) ‚Ñ§)))]\n  rw [‚Üê hg, det_fin_two]\n  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,\n    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe_apply_complex]\n  ring\n\n"}
{"name":"ModularGroup.tendsto_abs_re_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\np : Fin 2 ‚Üí Int\nhp : IsCoprime (p 0) (p 1)\n‚ä¢ Filter.Tendsto (fun g => abs (HSMul.hSMul (‚Üëg) z).re) Filter.cofinite Filter.atTop","decl":"theorem tendsto_abs_re_smul {p : Fin 2 ‚Üí ‚Ñ§} (hp : IsCoprime (p 0) (p 1)) :\n    Tendsto\n      (fun g : { g : SL(2, ‚Ñ§) // g 1 = p } => |((g : SL(2, ‚Ñ§)) ‚Ä¢ z).re|) cofinite atTop := by\n  suffices\n    Tendsto (fun g : (fun g : SL(2, ‚Ñ§) => g 1) ‚Åª¬π' {p} => ((g : SL(2, ‚Ñ§)) ‚Ä¢ z).re) cofinite\n      (cocompact ‚Ñù)\n    by exact tendsto_norm_cocompact_atTop.comp this\n  have : ((p 0 : ‚Ñù) ^ 2 + (p 1 : ‚Ñù) ^ 2)‚Åª¬π ‚â† 0 := by\n    apply inv_ne_zero\n    exact mod_cast hp.sq_add_sq_ne_zero\n  let f := Homeomorph.mulRight‚ÇÄ _ this\n  let ff := Homeomorph.addRight\n    (((p 1 : ‚ÑÇ) * z - p 0) / (((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) * (p 0 * z + p 1))).re\n  convert (f.trans ff).isClosedEmbedding.tendsto_cocompact.comp (tendsto_lcRow0 hp) with _ _ g\n  change\n    ((g : SL(2, ‚Ñ§)) ‚Ä¢ z).re =\n      lcRow0 p ‚Üë(‚Üëg : SL(2, ‚Ñù)) / ((p 0 : ‚Ñù) ^ 2 + (p 1 : ‚Ñù) ^ 2) +\n        Complex.re (((p 1 : ‚ÑÇ) * z - p 0) / (((p 0 : ‚ÑÇ) ^ 2 + (p 1 : ‚ÑÇ) ^ 2) * (p 0 * z + p 1)))\n  exact mod_cast congr_arg Complex.re (smul_eq_lcRow0_add z hp g.2)\n\n"}
{"name":"ModularGroup.exists_max_im","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Exists fun g => ‚àÄ (g' : Matrix.SpecialLinearGroup (Fin 2) Int), LE.le (HSMul.hSMul g' z).im (HSMul.hSMul g z).im","decl":"/-- For `z : ‚Ñç`, there is a `g : SL(2,‚Ñ§)` maximizing `(g‚Ä¢z).im` -/\ntheorem exists_max_im : ‚àÉ g : SL(2, ‚Ñ§), ‚àÄ g' : SL(2, ‚Ñ§), (g' ‚Ä¢ z).im ‚â§ (g ‚Ä¢ z).im := by\n  classical\n  let s : Set (Fin 2 ‚Üí ‚Ñ§) := {cd | IsCoprime (cd 0) (cd 1)}\n  have hs : s.Nonempty := ‚ü®![1, 1], isCoprime_one_left‚ü©\n  obtain ‚ü®p, hp_coprime, hp‚ü© :=\n    Filter.Tendsto.exists_within_forall_le hs (tendsto_normSq_coprime_pair z)\n  obtain ‚ü®g, -, hg‚ü© := bottom_row_surj hp_coprime\n  refine ‚ü®g, fun g' => ?_‚ü©\n  rw [ModularGroup.im_smul_eq_div_normSq, ModularGroup.im_smul_eq_div_normSq,\n    div_le_div_iff_of_pos_left]\n  ¬∑ simpa [‚Üê hg] using hp (g' 1) (bottom_row_coprime g')\n  ¬∑ exact z.im_pos\n  ¬∑ exact normSq_denom_pos g' z\n  ¬∑ exact normSq_denom_pos g z\n\n"}
{"name":"ModularGroup.exists_row_one_eq_and_min_re","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\ncd : Fin 2 ‚Üí Int\nhcd : IsCoprime (cd 0) (cd 1)\n‚ä¢ Exists fun g => And (Eq (‚Üëg 1) cd) (‚àÄ (g' : Matrix.SpecialLinearGroup (Fin 2) Int), Eq (‚Üëg 1) (‚Üëg' 1) ‚Üí LE.le (abs (HSMul.hSMul g z).re) (abs (HSMul.hSMul g' z).re))","decl":"/-- Given `z : ‚Ñç` and a bottom row `(c,d)`, among the `g : SL(2,‚Ñ§)` with this bottom row, minimize\n  `|(g‚Ä¢z).re|`. -/\ntheorem exists_row_one_eq_and_min_re {cd : Fin 2 ‚Üí ‚Ñ§} (hcd : IsCoprime (cd 0) (cd 1)) :\n    ‚àÉ g : SL(2, ‚Ñ§), g 1 = cd ‚àß ‚àÄ g' : SL(2, ‚Ñ§), g 1 = g' 1 ‚Üí\n      |(g ‚Ä¢ z).re| ‚â§ |(g' ‚Ä¢ z).re| := by\n  haveI : Nonempty { g : SL(2, ‚Ñ§) // g 1 = cd } :=\n    let ‚ü®x, hx‚ü© := bottom_row_surj hcd\n    ‚ü®‚ü®x, hx.2‚ü©‚ü©\n  obtain ‚ü®g, hg‚ü© := Filter.Tendsto.exists_forall_le (tendsto_abs_re_smul z hcd)\n  refine ‚ü®g, g.2, ?_‚ü©\n  intro g1 hg1\n  have : g1 ‚àà (fun g : SL(2, ‚Ñ§) => g 1) ‚Åª¬π' {cd} := by\n    rw [Set.mem_preimage, Set.mem_singleton_iff]\n    exact Eq.trans hg1.symm (Set.mem_singleton_iff.mp (Set.mem_preimage.mp g.2))\n  exact hg ‚ü®g1, this‚ü©\n\n"}
{"name":"ModularGroup.coe_T_zpow_smul_eq","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\n‚ä¢ Eq (‚Üë(HSMul.hSMul (HPow.hPow ModularGroup.T n) z)) (HAdd.hAdd ‚Üëz ‚Üën)","decl":"theorem coe_T_zpow_smul_eq {n : ‚Ñ§} : (‚Üë(T ^ n ‚Ä¢ z) : ‚ÑÇ) = z + n := by\n  rw [sl_moeb, UpperHalfPlane.coe_smul]\n  simp [coe_T_zpow, denom, num, -map_zpow]\n\n"}
{"name":"ModularGroup.re_T_zpow_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\n‚ä¢ Eq (HSMul.hSMul (HPow.hPow ModularGroup.T n) z).re (HAdd.hAdd z.re ‚Üën)","decl":"theorem re_T_zpow_smul (n : ‚Ñ§) : (T ^ n ‚Ä¢ z).re = z.re + n := by\n  rw [‚Üê coe_re, coe_T_zpow_smul_eq, add_re, intCast_re, coe_re]\n\n"}
{"name":"ModularGroup.im_T_zpow_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\n‚ä¢ Eq (HSMul.hSMul (HPow.hPow ModularGroup.T n) z).im z.im","decl":"theorem im_T_zpow_smul (n : ‚Ñ§) : (T ^ n ‚Ä¢ z).im = z.im := by\n  rw [‚Üê coe_im, coe_T_zpow_smul_eq, add_im, intCast_im, add_zero, coe_im]\n\n"}
{"name":"ModularGroup.re_T_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Eq (HSMul.hSMul ModularGroup.T z).re (HAdd.hAdd z.re 1)","decl":"theorem re_T_smul : (T ‚Ä¢ z).re = z.re + 1 := by simpa using re_T_zpow_smul z 1\n\n"}
{"name":"ModularGroup.im_T_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Eq (HSMul.hSMul ModularGroup.T z).im z.im","decl":"theorem im_T_smul : (T ‚Ä¢ z).im = z.im := by simpa using im_T_zpow_smul z 1\n\n"}
{"name":"ModularGroup.re_T_inv_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Eq (HSMul.hSMul (Inv.inv ModularGroup.T) z).re (HSub.hSub z.re 1)","decl":"theorem re_T_inv_smul : (T‚Åª¬π ‚Ä¢ z).re = z.re - 1 := by simpa using re_T_zpow_smul z (-1)\n\n"}
{"name":"ModularGroup.im_T_inv_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Eq (HSMul.hSMul (Inv.inv ModularGroup.T) z).im z.im","decl":"theorem im_T_inv_smul : (T‚Åª¬π ‚Ä¢ z).im = z.im := by simpa using im_T_zpow_smul z (-1)\n\n"}
{"name":"ModularGroup.exists_eq_T_zpow_of_c_eq_zero","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nhc : Eq (‚Üëg 1 0) 0\n‚ä¢ Exists fun n => ‚àÄ (z : UpperHalfPlane), Eq (HSMul.hSMul g z) (HSMul.hSMul (HPow.hPow ModularGroup.T n) z)","decl":"theorem exists_eq_T_zpow_of_c_eq_zero (hc : g 1 0 = 0) :\n    ‚àÉ n : ‚Ñ§, ‚àÄ z : ‚Ñç, g ‚Ä¢ z = T ^ n ‚Ä¢ z := by\n  have had := g.det_coe\n  replace had : g 0 0 * g 1 1 = 1 := by rw [det_fin_two, hc] at had; omega\n  rcases Int.eq_one_or_neg_one_of_mul_eq_one' had with (‚ü®ha, hd‚ü© | ‚ü®ha, hd‚ü©)\n  ¬∑ use g 0 1\n    suffices g = T ^ g 0 1 by intro z; conv_lhs => rw [this]\n    ext i j; fin_cases i <;> fin_cases j <;>\n      simp [ha, hc, hd, coe_T_zpow, show (1 : Fin (0 + 2)) = (1 : Fin 2) from rfl]\n  ¬∑ use -(g 0 1)\n    suffices g = -T ^ (-(g 0 1)) by intro z; conv_lhs => rw [this, SL_neg_smul]\n    ext i j; fin_cases i <;> fin_cases j <;>\n      simp [ha, hc, hd, coe_T_zpow, show (1 : Fin (0 + 2)) = (1 : Fin 2) from rfl]\n\n-- If `c = 1`, then `g` factorises into a product terms involving only `T` and `S`.\n"}
{"name":"ModularGroup.g_eq_of_c_eq_one","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nhc : Eq (‚Üëg 1 0) 1\n‚ä¢ Eq g (HMul.hMul (HMul.hMul (HPow.hPow ModularGroup.T (‚Üëg 0 0)) ModularGroup.S) (HPow.hPow ModularGroup.T (‚Üëg 1 1)))","decl":"theorem g_eq_of_c_eq_one (hc : g 1 0 = 1) : g = T ^ g 0 0 * S * T ^ g 1 1 := by\n  have hg := g.det_coe.symm\n  replace hg : g 0 1 = g 0 0 * g 1 1 - 1 := by rw [det_fin_two, hc] at hg; omega\n  refine Subtype.ext ?_\n  conv_lhs => rw [(g : Matrix _ _ ‚Ñ§).eta_fin_two]\n  simp only [hg, sub_eq_add_neg, hc, coe_mul, coe_T_zpow, coe_S, mul_fin_two, mul_zero, mul_one,\n    zero_add, one_mul, add_zero, zero_mul]\n\n"}
{"name":"ModularGroup.normSq_S_smul_lt_one","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : LT.lt 1 (Complex.normSq ‚Üëz)\n‚ä¢ LT.lt (Complex.normSq ‚Üë(HSMul.hSMul ModularGroup.S z)) 1","decl":"/-- If `1 < |z|`, then `|S ‚Ä¢ z| < 1`. -/\ntheorem normSq_S_smul_lt_one (h : 1 < normSq z) : normSq ‚Üë(S ‚Ä¢ z) < 1 := by\n  simpa [coe_S, num, denom] using (inv_lt_inv‚ÇÄ z.normSq_pos zero_lt_one).mpr h\n\n"}
{"name":"ModularGroup.im_lt_im_S_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : LT.lt (Complex.normSq ‚Üëz) 1\n‚ä¢ LT.lt z.im (HSMul.hSMul ModularGroup.S z).im","decl":"/-- If `|z| < 1`, then applying `S` strictly decreases `im`. -/\ntheorem im_lt_im_S_smul (h : normSq z < 1) : z.im < (S ‚Ä¢ z).im := by\n  have : z.im < z.im / normSq (z : ‚ÑÇ) := by\n    have imz : 0 < z.im := im_pos z\n    apply (lt_div_iff‚ÇÄ z.normSq_pos).mpr\n    nlinarith\n  convert this\n  simp only [ModularGroup.im_smul_eq_div_normSq]\n  simp [denom, coe_S]\n\n"}
{"name":"ModularGroup.abs_two_mul_re_lt_one_of_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : Membership.mem ModularGroup.fdo z\n‚ä¢ LT.lt (abs (HMul.hMul 2 z.re)) 1","decl":"theorem abs_two_mul_re_lt_one_of_mem_fdo (h : z ‚àà ùíü·µí) : |2 * z.re| < 1 := by\n  rw [abs_mul, abs_two, ‚Üê lt_div_iff‚ÇÄ' (zero_lt_two' ‚Ñù)]\n  exact h.2\n\n"}
{"name":"ModularGroup.three_lt_four_mul_im_sq_of_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : Membership.mem ModularGroup.fdo z\n‚ä¢ LT.lt 3 (HMul.hMul 4 (HPow.hPow z.im 2))","decl":"theorem three_lt_four_mul_im_sq_of_mem_fdo (h : z ‚àà ùíü·µí) : 3 < 4 * z.im ^ 2 := by\n  have : 1 < z.re * z.re + z.im * z.im := by simpa [Complex.normSq_apply] using h.1\n  have := h.2\n  cases abs_cases z.re <;> nlinarith\n\n"}
{"name":"ModularGroup.three_le_four_mul_im_sq_of_mem_fd","module":"Mathlib.NumberTheory.Modular","initialProofState":"œÑ : UpperHalfPlane\nh : Membership.mem ModularGroup.fd œÑ\n‚ä¢ LE.le 3 (HMul.hMul 4 (HPow.hPow œÑ.im 2))","decl":"/-- non-strict variant of `ModularGroup.three_le_four_mul_im_sq_of_mem_fdo` -/\ntheorem three_le_four_mul_im_sq_of_mem_fd {œÑ : ‚Ñç} (h : œÑ ‚àà ùíü) : 3 ‚â§ 4 * œÑ.im ^ 2 := by\n  have : 1 ‚â§ œÑ.re * œÑ.re + œÑ.im * œÑ.im := by simpa [Complex.normSq_apply] using h.1\n  cases abs_cases œÑ.re <;> nlinarith [h.2]\n\n"}
{"name":"ModularGroup.one_lt_normSq_T_zpow_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nn : Int\n‚ä¢ LT.lt 1 (Complex.normSq ‚Üë(HSMul.hSMul (HPow.hPow ModularGroup.T n) z))","decl":"/-- If `z ‚àà ùíü·µí`, and `n : ‚Ñ§`, then `|z + n| > 1`. -/\ntheorem one_lt_normSq_T_zpow_smul (hz : z ‚àà ùíü·µí) (n : ‚Ñ§) : 1 < normSq (T ^ n ‚Ä¢ z : ‚Ñç) := by\n  have hz‚ÇÅ : 1 < z.re * z.re + z.im * z.im := hz.1\n  have hzn := Int.nneg_mul_add_sq_of_abs_le_one n (abs_two_mul_re_lt_one_of_mem_fdo hz).le\n  have : 1 < (z.re + ‚Üën) * (z.re + ‚Üën) + z.im * z.im := by linarith\n  simpa [coe_T_zpow, normSq, num, denom, -map_zpow]\n\n"}
{"name":"ModularGroup.eq_zero_of_mem_fdo_of_T_zpow_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul (HPow.hPow ModularGroup.T n) z)\n‚ä¢ Eq n 0","decl":"theorem eq_zero_of_mem_fdo_of_T_zpow_mem_fdo {n : ‚Ñ§} (hz : z ‚àà ùíü·µí) (hg : T ^ n ‚Ä¢ z ‚àà ùíü·µí) :\n    n = 0 := by\n  suffices |(n : ‚Ñù)| < 1 by\n    rwa [‚Üê Int.cast_abs, ‚Üê Int.cast_one, Int.cast_lt, Int.abs_lt_one_iff] at this\n  have h‚ÇÅ := hz.2\n  have h‚ÇÇ := hg.2\n  rw [re_T_zpow_smul] at h‚ÇÇ\n  calc\n    |(n : ‚Ñù)| ‚â§ |z.re| + |z.re + (n : ‚Ñù)| := abs_add' (n : ‚Ñù) z.re\n    _ < 1 / 2 + 1 / 2 := add_lt_add h‚ÇÅ h‚ÇÇ\n    _ = 1 := add_halves 1\n\n"}
{"name":"ModularGroup.exists_smul_mem_fd","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n‚ä¢ Exists fun g => Membership.mem ModularGroup.fd (HSMul.hSMul g z)","decl":"/-- First Fundamental Domain Lemma: Any `z : ‚Ñç` can be moved to `ùíü` by an element of\n`SL(2,‚Ñ§)` -/\ntheorem exists_smul_mem_fd (z : ‚Ñç) : ‚àÉ g : SL(2, ‚Ñ§), g ‚Ä¢ z ‚àà ùíü := by\n  -- obtain a g‚ÇÄ which maximizes im (g ‚Ä¢ z),\n  obtain ‚ü®g‚ÇÄ, hg‚ÇÄ‚ü© := exists_max_im z\n  -- then among those, minimize re\n  obtain ‚ü®g, hg, hg'‚ü© := exists_row_one_eq_and_min_re z (bottom_row_coprime g‚ÇÄ)\n  refine ‚ü®g, ?_‚ü©\n  -- `g` has same max im property as `g‚ÇÄ`\n  have hg‚ÇÄ' : ‚àÄ g' : SL(2, ‚Ñ§), (g' ‚Ä¢ z).im ‚â§ (g ‚Ä¢ z).im := by\n    have hg'' : (g ‚Ä¢ z).im = (g‚ÇÄ ‚Ä¢ z).im := by\n      rw [ModularGroup.im_smul_eq_div_normSq, ModularGroup.im_smul_eq_div_normSq,\n        denom_apply, denom_apply, hg]\n    simpa only [hg''] using hg‚ÇÄ\n  constructor\n  ¬∑ -- Claim: `1 ‚â§ ‚áënorm_sq ‚Üë(g ‚Ä¢ z)`. If not, then `S‚Ä¢g‚Ä¢z` has larger imaginary part\n    contrapose! hg‚ÇÄ'\n    refine ‚ü®S * g, ?_‚ü©\n    rw [mul_smul]\n    exact im_lt_im_S_smul hg‚ÇÄ'\n  ¬∑ show |(g ‚Ä¢ z).re| ‚â§ 1 / 2\n    -- if not, then either `T` or `T'` decrease |Re|.\n    rw [abs_le]\n    constructor\n    ¬∑ contrapose! hg'\n      refine ‚ü®T * g, (T_mul_apply_one _).symm, ?_‚ü©\n      rw [mul_smul, re_T_smul]\n      cases abs_cases ((g ‚Ä¢ z).re + 1) <;> cases abs_cases (g ‚Ä¢ z).re <;> linarith\n    ¬∑ contrapose! hg'\n      refine ‚ü®T‚Åª¬π * g, (T_inv_mul_apply_one _).symm, ?_‚ü©\n      rw [mul_smul, re_T_inv_smul]\n      cases abs_cases ((g ‚Ä¢ z).re - 1) <;> cases abs_cases (g ‚Ä¢ z).re <;> linarith\n\n"}
{"name":"ModularGroup.abs_c_le_one","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul g z)\n‚ä¢ LE.le (abs (‚Üëg 1 0)) 1","decl":"/-- An auxiliary result en route to `ModularGroup.c_eq_zero`. -/\ntheorem abs_c_le_one (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : |g 1 0| ‚â§ 1 := by\n  let c' : ‚Ñ§ := g 1 0\n  let c := (c' : ‚Ñù)\n  suffices 3 * c ^ 2 < 4 by\n    rw [‚Üê Int.cast_pow, ‚Üê Int.cast_three, ‚Üê Int.cast_four, ‚Üê Int.cast_mul, Int.cast_lt] at this\n    replace this : c' ^ 2 ‚â§ 1 ^ 2 := by omega\n    rwa [sq_le_sq, abs_one] at this\n  suffices c ‚â† 0 ‚Üí 9 * c ^ 4 < 16 by\n    rcases eq_or_ne c 0 with (hc | hc)\n    ¬∑ rw [hc]; norm_num\n    ¬∑ refine (abs_lt_of_sq_lt_sq' ?_ (by norm_num)).2\n      specialize this hc\n      linarith\n  intro hc\n  have h‚ÇÅ : 3 * 3 * c ^ 4 < 4 * (g ‚Ä¢ z).im ^ 2 * (4 * z.im ^ 2) * c ^ 4 := by\n    gcongr <;> apply three_lt_four_mul_im_sq_of_mem_fdo <;> assumption\n  have h‚ÇÇ : (c * z.im) ^ 4 / normSq (denom (‚Üëg) z) ^ 2 ‚â§ 1 :=\n    div_le_one_of_le‚ÇÄ\n      (pow_four_le_pow_two_of_pow_two_le (z.c_mul_im_sq_le_normSq_denom g))\n      (sq_nonneg _)\n  let nsq := normSq (denom g z)\n  calc\n    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g ‚Ä¢ z).im ^ 2 * 16 := by linarith\n    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by\n      rw [im_smul_eq_div_normSq, div_pow]\n      ring\n    _ ‚â§ 16 := by rw [‚Üê mul_pow]; linarith\n\n"}
{"name":"ModularGroup.c_eq_zero","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul g z)\n‚ä¢ Eq (‚Üëg 1 0) 0","decl":"/-- An auxiliary result en route to `ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo`. -/\ntheorem c_eq_zero (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : g 1 0 = 0 := by\n  have hp : ‚àÄ {g' : SL(2, ‚Ñ§)}, g' ‚Ä¢ z ‚àà ùíü·µí ‚Üí g' 1 0 ‚â† 1 := by\n    intro g' hg'\n    by_contra hc\n    let a := g' 0 0\n    let d := g' 1 1\n    have had : T ^ (-a) * g' = S * T ^ d := by\n      rw [g_eq_of_c_eq_one hc]\n      dsimp [a, d]\n      group\n    let w := T ^ (-a) ‚Ä¢ g' ‚Ä¢ z\n    have h‚ÇÅ : w = S ‚Ä¢ T ^ d ‚Ä¢ z := by simp only [w, ‚Üê mul_smul, had]\n    replace h‚ÇÅ : normSq w < 1 := h‚ÇÅ.symm ‚ñ∏ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)\n    have h‚ÇÇ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)\n    linarith\n  have hn : g 1 0 ‚â† -1 := by\n    intro hc\n    replace hc : (-g) 1 0 = 1 := by simp [‚Üê neg_eq_iff_eq_neg.mpr hc]\n    replace hg : -g ‚Ä¢ z ‚àà ùíü·µí := (SL_neg_smul g z).symm ‚ñ∏ hg\n    exact hp hg hc\n  specialize hp hg\n  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with ‚ü®‚ü© <;> tauto\n\n"}
{"name":"ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul g z)\n‚ä¢ Eq z (HSMul.hSMul g z)","decl":"/-- Second Fundamental Domain Lemma: if both `z` and `g ‚Ä¢ z` are in the open domain `ùíü·µí`,\nwhere `z : ‚Ñç` and `g : SL(2,‚Ñ§)`, then `z = g ‚Ä¢ z`. -/\ntheorem eq_smul_self_of_mem_fdo_mem_fdo (hz : z ‚àà ùíü·µí) (hg : g ‚Ä¢ z ‚àà ùíü·µí) : z = g ‚Ä¢ z := by\n  obtain ‚ü®n, hn‚ü© := exists_eq_T_zpow_of_c_eq_zero (c_eq_zero hz hg)\n  rw [hn] at hg ‚ä¢\n  simp [eq_zero_of_mem_fdo_of_T_zpow_mem_fdo hz hg, one_smul]\n\n"}
{"name":"ModularGroup.exists_one_half_le_im_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"œÑ : UpperHalfPlane\n‚ä¢ Exists fun Œ≥ => LE.le (1 / 2) (HSMul.hSMul Œ≥ œÑ).im","decl":"lemma exists_one_half_le_im_smul (œÑ : ‚Ñç) : ‚àÉ Œ≥ : SL(2, ‚Ñ§), 1 / 2 ‚â§ im (Œ≥ ‚Ä¢ œÑ) := by\n  obtain ‚ü®Œ≥, hŒ≥‚ü© := exists_smul_mem_fd œÑ\n  use Œ≥\n  nlinarith [three_le_four_mul_im_sq_of_mem_fd hŒ≥, im_pos (Œ≥ ‚Ä¢ œÑ)]\n\n"}
{"name":"ModularGroup.exists_one_half_le_im_smul_and_norm_denom_le","module":"Mathlib.NumberTheory.Modular","initialProofState":"œÑ : UpperHalfPlane\n‚ä¢ Exists fun Œ≥ => And (LE.le (1 / 2) (HSMul.hSMul Œ≥ œÑ).im) (LE.le (Norm.norm (UpperHalfPlane.denom (‚ÜëŒ≥) œÑ)) 1)","decl":"/-- For every `œÑ : ‚Ñç` there is some `Œ≥ ‚àà SL(2, ‚Ñ§)` that sends it to an element whose\nimaginary part is at least `1/2` and such that `denom Œ≥ œÑ` has norm at most 1. -/\nlemma exists_one_half_le_im_smul_and_norm_denom_le (œÑ : ‚Ñç) :\n    ‚àÉ Œ≥ : SL(2, ‚Ñ§), 1 / 2 ‚â§ im (Œ≥ ‚Ä¢ œÑ) ‚àß ‚Äñdenom Œ≥ œÑ‚Äñ ‚â§ 1 := by\n  rcases le_total (1 / 2) œÑ.im with h | h\n  ¬∑ exact ‚ü®1, (one_smul SL(2, ‚Ñ§) œÑ).symm ‚ñ∏ h, by simp only [coe_one, denom_one, norm_one, le_refl]‚ü©\n  ¬∑ refine (exists_one_half_le_im_smul œÑ).imp (fun Œ≥ hŒ≥ ‚Ü¶ ‚ü®hŒ≥, ?_‚ü©)\n    have h1 : œÑ.im ‚â§ (Œ≥ ‚Ä¢ œÑ).im := h.trans hŒ≥\n    rw [im_smul_eq_div_normSq, le_div_iff‚ÇÄ (normSq_denom_pos (‚ÜëŒ≥) œÑ), normSq_eq_norm_sq] at h1\n    simpa only [norm_eq_abs, sq_le_one_iff_abs_le_one, Complex.abs_abs] using\n      (mul_le_iff_le_one_right œÑ.2).mp h1\n\n"}
