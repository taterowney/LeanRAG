{"name":"ModularGroup.bottom_row_coprime","module":"Mathlib.NumberTheory.Modular","initialProofState":"R : Type u_1\ninst✝ : CommRing R\ng : Matrix.SpecialLinearGroup (Fin 2) R\n⊢ IsCoprime (↑g 1 0) (↑g 1 1)","decl":"/-- The two numbers `c`, `d` in the \"bottom_row\" of `g=[[*,*],[c,d]]` in `SL(2, ℤ)` are coprime. -/\ntheorem bottom_row_coprime {R : Type*} [CommRing R] (g : SL(2, R)) :\n    IsCoprime ((↑g : Matrix (Fin 2) (Fin 2) R) 1 0) ((↑g : Matrix (Fin 2) (Fin 2) R) 1 1) := by\n  use -(↑g : Matrix (Fin 2) (Fin 2) R) 0 1, (↑g : Matrix (Fin 2) (Fin 2) R) 0 0\n  rw [add_comm, neg_mul, ← sub_eq_add_neg, ← det_fin_two]\n  exact g.det_coe\n\n"}
{"name":"ModularGroup.bottom_row_surj","module":"Mathlib.NumberTheory.Modular","initialProofState":"R : Type u_1\ninst✝ : CommRing R\n⊢ Set.SurjOn (fun g => ↑g 1) Set.univ (setOf fun cd => IsCoprime (cd 0) (cd 1))","decl":"/-- Every pair `![c, d]` of coprime integers is the \"bottom_row\" of some element `g=[[*,*],[c,d]]`\nof `SL(2,ℤ)`. -/\ntheorem bottom_row_surj {R : Type*} [CommRing R] :\n    Set.SurjOn (fun g : SL(2, R) => (↑g : Matrix (Fin 2) (Fin 2) R) 1) Set.univ\n      {cd | IsCoprime (cd 0) (cd 1)} := by\n  rintro cd ⟨b₀, a, gcd_eqn⟩\n  let A := of ![![a, -b₀], cd]\n  have det_A_1 : det A = 1 := by\n    convert gcd_eqn\n    rw [det_fin_two]\n    simp [A, (by ring : a * cd 1 + b₀ * cd 0 = b₀ * cd 0 + a * cd 1)]\n  refine ⟨⟨A, det_A_1⟩, Set.mem_univ _, ?_⟩\n  ext; simp [A]\n\n"}
{"name":"ModularGroup.tendsto_normSq_coprime_pair","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Filter.Tendsto (fun p => Complex.normSq (HAdd.hAdd (HMul.hMul ↑(p 0) ↑z) ↑(p 1))) Filter.cofinite Filter.atTop","decl":"/-- The function `(c,d) → |cz+d|^2` is proper, that is, preimages of bounded-above sets are finite.\n-/\ntheorem tendsto_normSq_coprime_pair :\n    Filter.Tendsto (fun p : Fin 2 → ℤ => normSq ((p 0 : ℂ) * z + p 1)) cofinite atTop := by\n  -- using this instance rather than the automatic `Function.module` makes unification issues in\n  -- `LinearEquiv.isClosedEmbedding_of_injective` less bad later in the proof.\n  letI : Module ℝ (Fin 2 → ℝ) := NormedSpace.toModule\n  let π₀ : (Fin 2 → ℝ) →ₗ[ℝ] ℝ := LinearMap.proj 0\n  let π₁ : (Fin 2 → ℝ) →ₗ[ℝ] ℝ := LinearMap.proj 1\n  let f : (Fin 2 → ℝ) →ₗ[ℝ] ℂ := π₀.smulRight (z : ℂ) + π₁.smulRight 1\n  have f_def : ⇑f = fun p : Fin 2 → ℝ => (p 0 : ℂ) * ↑z + p 1 := by\n    ext1\n    dsimp only [π₀, π₁, f, LinearMap.coe_proj, real_smul, LinearMap.coe_smulRight,\n      LinearMap.add_apply]\n    rw [mul_one]\n  have :\n    (fun p : Fin 2 → ℤ => normSq ((p 0 : ℂ) * ↑z + ↑(p 1))) =\n      normSq ∘ f ∘ fun p : Fin 2 → ℤ => ((↑) : ℤ → ℝ) ∘ p := by\n    ext1\n    rw [f_def]\n    dsimp only [Function.comp_def]\n    rw [ofReal_intCast, ofReal_intCast]\n  rw [this]\n  have hf : LinearMap.ker f = ⊥ := by\n    let g : ℂ →ₗ[ℝ] Fin 2 → ℝ :=\n      LinearMap.pi ![imLm, imLm.comp ((z : ℂ) • ((conjAe : ℂ →ₐ[ℝ] ℂ) : ℂ →ₗ[ℝ] ℂ))]\n    suffices ((z : ℂ).im⁻¹ • g).comp f = LinearMap.id by exact LinearMap.ker_eq_bot_of_inverse this\n    apply LinearMap.ext\n    intro c\n    have hz : (z : ℂ).im ≠ 0 := z.2.ne'\n    rw [LinearMap.comp_apply, LinearMap.smul_apply, LinearMap.id_apply]\n    ext i\n    dsimp only [Pi.smul_apply, LinearMap.pi_apply, smul_eq_mul]\n    fin_cases i\n    · show (z : ℂ).im⁻¹ * (f c).im = c 0\n      rw [f_def, add_im, im_ofReal_mul, ofReal_im, add_zero, mul_left_comm, inv_mul_cancel₀ hz,\n        mul_one]\n    · show (z : ℂ).im⁻¹ * ((z : ℂ) * conj (f c)).im = c 1\n      rw [f_def, RingHom.map_add, RingHom.map_mul, mul_add, mul_left_comm, mul_conj, conj_ofReal,\n        conj_ofReal, ← ofReal_mul, add_im, ofReal_im, zero_add, inv_mul_eq_iff_eq_mul₀ hz]\n      simp only [ofReal_im, ofReal_re, mul_im, zero_add, mul_zero]\n  have hf' : IsClosedEmbedding f := f.isClosedEmbedding_of_injective hf\n  have h₂ : Tendsto (fun p : Fin 2 → ℤ => ((↑) : ℤ → ℝ) ∘ p) cofinite (cocompact _) := by\n    convert Tendsto.pi_map_coprodᵢ fun _ => Int.tendsto_coe_cofinite\n    · rw [coprodᵢ_cofinite]\n    · rw [coprodᵢ_cocompact]\n  exact tendsto_normSq_cocompact_atTop.comp (hf'.tendsto_cocompact.comp h₂)\n\n"}
{"name":"ModularGroup.lcRow0_apply","module":"Mathlib.NumberTheory.Modular","initialProofState":"p : Fin 2 → Int\ng : Matrix (Fin 2) (Fin 2) Real\n⊢ Eq ((ModularGroup.lcRow0 p) g) (HAdd.hAdd (HMul.hMul (↑(p 0)) (g 0 0)) (HMul.hMul (↑(p 1)) (g 0 1)))","decl":"@[simp]\ntheorem lcRow0_apply (p : Fin 2 → ℤ) (g : Matrix (Fin 2) (Fin 2) ℝ) :\n    lcRow0 p g = p 0 * g 0 0 + p 1 * g 0 1 :=\n  rfl\n\n"}
{"name":"ModularGroup.lcRow0Extend_symm_apply","module":"Mathlib.NumberTheory.Modular","initialProofState":"cd : Fin 2 → Int\nhcd : IsCoprime (cd 0) (cd 1)\nf : (i : Fin 2) → (fun a => Fin 2 → Real) i\ni a✝ : Fin 2\n⊢ Eq ((ModularGroup.lcRow0Extend hcd).symm f i a✝) ((Matrix.vecCons ((LinearMap.GeneralLinearGroup.generalLinearEquiv Real (Fin 2 → Real)) (Matrix.GeneralLinearGroup.toLin (Matrix.planeConformalMatrix (↑(cd 0)) (Neg.neg ↑(cd 1)) ⋯))) (Matrix.vecCons (LinearEquiv.refl Real (Fin 2 → Real)) Matrix.vecEmpty) i).symm (f i) a✝)","decl":"/-- Linear map sending the matrix [a, b; c, d] to the matrix [ac₀ + bd₀, - ad₀ + bc₀; c, d], for\nsome fixed `(c₀, d₀)`. -/\n@[simps!]\ndef lcRow0Extend {cd : Fin 2 → ℤ} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Matrix (Fin 2) (Fin 2) ℝ ≃ₗ[ℝ] Matrix (Fin 2) (Fin 2) ℝ :=\n  LinearEquiv.piCongrRight\n    ![by\n      refine\n        LinearMap.GeneralLinearGroup.generalLinearEquiv ℝ (Fin 2 → ℝ)\n          (GeneralLinearGroup.toLin (planeConformalMatrix (cd 0 : ℝ) (-(cd 1 : ℝ)) ?_))\n      norm_cast\n      rw [neg_sq]\n      exact hcd.sq_add_sq_ne_zero, LinearEquiv.refl ℝ (Fin 2 → ℝ)]\n\n"}
{"name":"ModularGroup.lcRow0Extend_apply","module":"Mathlib.NumberTheory.Modular","initialProofState":"cd : Fin 2 → Int\nhcd : IsCoprime (cd 0) (cd 1)\nf : (i : Fin 2) → (fun a => Fin 2 → Real) i\ni a✝ : Fin 2\n⊢ Eq ((ModularGroup.lcRow0Extend hcd) f i a✝) ((Matrix.vecCons ((LinearMap.GeneralLinearGroup.generalLinearEquiv Real (Fin 2 → Real)) (Matrix.GeneralLinearGroup.toLin (Matrix.planeConformalMatrix (↑(cd 0)) (Neg.neg ↑(cd 1)) ⋯))) (Matrix.vecCons (LinearEquiv.refl Real (Fin 2 → Real)) Matrix.vecEmpty) i) (f i) a✝)","decl":"/-- Linear map sending the matrix [a, b; c, d] to the matrix [ac₀ + bd₀, - ad₀ + bc₀; c, d], for\nsome fixed `(c₀, d₀)`. -/\n@[simps!]\ndef lcRow0Extend {cd : Fin 2 → ℤ} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Matrix (Fin 2) (Fin 2) ℝ ≃ₗ[ℝ] Matrix (Fin 2) (Fin 2) ℝ :=\n  LinearEquiv.piCongrRight\n    ![by\n      refine\n        LinearMap.GeneralLinearGroup.generalLinearEquiv ℝ (Fin 2 → ℝ)\n          (GeneralLinearGroup.toLin (planeConformalMatrix (cd 0 : ℝ) (-(cd 1 : ℝ)) ?_))\n      norm_cast\n      rw [neg_sq]\n      exact hcd.sq_add_sq_ne_zero, LinearEquiv.refl ℝ (Fin 2 → ℝ)]\n\n"}
{"name":"ModularGroup.tendsto_lcRow0","module":"Mathlib.NumberTheory.Modular","initialProofState":"cd : Fin 2 → Int\nhcd : IsCoprime (cd 0) (cd 1)\n⊢ Filter.Tendsto (fun g => (ModularGroup.lcRow0 cd) ↑((Matrix.SpecialLinearGroup.map (Int.castRingHom Real)) ↑g)) Filter.cofinite (Filter.cocompact Real)","decl":"/-- The map `lcRow0` is proper, that is, preimages of cocompact sets are finite in\n`[[* , *], [c, d]]`. -/\ntheorem tendsto_lcRow0 {cd : Fin 2 → ℤ} (hcd : IsCoprime (cd 0) (cd 1)) :\n    Tendsto (fun g : { g : SL(2, ℤ) // g 1 = cd } => lcRow0 cd ↑(↑g : SL(2, ℝ))) cofinite\n      (cocompact ℝ) := by\n  let mB : ℝ → Matrix (Fin 2) (Fin 2) ℝ := fun t => of ![![t, (-(1 : ℤ) : ℝ)], (↑) ∘ cd]\n  have hmB : Continuous mB := by\n    refine continuous_matrix ?_\n    simp only [mB, Fin.forall_fin_two, continuous_const, continuous_id', of_apply, cons_val_zero,\n      cons_val_one, and_self_iff]\n  refine Filter.Tendsto.of_tendsto_comp ?_ (comap_cocompact_le hmB)\n  let f₁ : SL(2, ℤ) → Matrix (Fin 2) (Fin 2) ℝ := fun g =>\n    Matrix.map (↑g : Matrix _ _ ℤ) ((↑) : ℤ → ℝ)\n  have cocompact_ℝ_to_cofinite_ℤ_matrix :\n    Tendsto (fun m : Matrix (Fin 2) (Fin 2) ℤ => Matrix.map m ((↑) : ℤ → ℝ)) cofinite\n      (cocompact _) := by\n    simpa only [coprodᵢ_cofinite, coprodᵢ_cocompact] using\n      Tendsto.pi_map_coprodᵢ fun _ : Fin 2 =>\n        Tendsto.pi_map_coprodᵢ fun _ : Fin 2 => Int.tendsto_coe_cofinite\n  have hf₁ : Tendsto f₁ cofinite (cocompact _) :=\n    cocompact_ℝ_to_cofinite_ℤ_matrix.comp Subtype.coe_injective.tendsto_cofinite\n  have hf₂ : IsClosedEmbedding (lcRow0Extend hcd) :=\n    (lcRow0Extend hcd).toContinuousLinearEquiv.toHomeomorph.isClosedEmbedding\n  convert hf₂.tendsto_cocompact.comp (hf₁.comp Subtype.coe_injective.tendsto_cofinite) using 1\n  ext ⟨g, rfl⟩ i j : 3\n  fin_cases i <;> [fin_cases j; skip]\n  -- the following are proved by `simp`, but it is replaced by `simp only` to avoid timeouts.\n  · simp only [Fin.isValue, Int.cast_one, map_apply_coe, RingHom.mapMatrix_apply,\n      Int.coe_castRingHom, lcRow0_apply, map_apply, Fin.zero_eta, id_eq, Function.comp_apply,\n      of_apply, cons_val', cons_val_zero, empty_val', cons_val_fin_one, lcRow0Extend_apply,\n      LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv, GeneralLinearGroup.coe_toLin,\n      val_planeConformalMatrix, neg_neg, mulVecLin_apply, mulVec, dotProduct, Fin.sum_univ_two,\n      cons_val_one, head_cons, mB, f₁]\n  · convert congr_arg (fun n : ℤ => (-n : ℝ)) g.det_coe.symm using 1\n    simp only [Fin.zero_eta, id_eq, Function.comp_apply, lcRow0Extend_apply, cons_val_zero,\n      LinearMap.GeneralLinearGroup.coeFn_generalLinearEquiv, GeneralLinearGroup.coe_toLin,\n      mulVecLin_apply, mulVec, dotProduct, det_fin_two, f₁]\n    simp only [Fin.isValue, Fin.mk_one, val_planeConformalMatrix, neg_neg, of_apply, cons_val',\n      empty_val', cons_val_fin_one, cons_val_one, head_fin_const, map_apply, Fin.sum_univ_two,\n      cons_val_zero, neg_mul, head_cons, Int.cast_sub, Int.cast_mul, neg_sub]\n    ring\n  · rfl\n\n"}
{"name":"ModularGroup.smul_eq_lcRow0_add","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\np : Fin 2 → Int\nhp : IsCoprime (p 0) (p 1)\nhg : Eq (↑g 1) p\n⊢ Eq (↑(HSMul.hSMul g z)) (HAdd.hAdd (HDiv.hDiv (↑((ModularGroup.lcRow0 p) ↑((Matrix.SpecialLinearGroup.map (Int.castRingHom Real)) g))) (HAdd.hAdd (HPow.hPow (↑(p 0)) 2) (HPow.hPow (↑(p 1)) 2))) (HDiv.hDiv (HSub.hSub (HMul.hMul ↑(p 1) ↑z) ↑(p 0)) (HMul.hMul (HAdd.hAdd (HPow.hPow (↑(p 0)) 2) (HPow.hPow (↑(p 1)) 2)) (HAdd.hAdd (HMul.hMul ↑(p 0) ↑z) ↑(p 1)))))","decl":"/-- This replaces `(g•z).re = a/c + *` in the standard theory with the following novel identity:\n  `g • z = (a c + b d) / (c^2 + d^2) + (d z - c) / ((c^2 + d^2) (c z + d))`\n  which does not need to be decomposed depending on whether `c = 0`. -/\ntheorem smul_eq_lcRow0_add {p : Fin 2 → ℤ} (hp : IsCoprime (p 0) (p 1)) (hg : g 1 = p) :\n    ↑(g • z) =\n      (lcRow0 p ↑(g : SL(2, ℝ)) : ℂ) / ((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) +\n        ((p 1 : ℂ) * z - p 0) / (((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) * (p 0 * z + p 1)) := by\n  have nonZ1 : (p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2 ≠ 0 := mod_cast hp.sq_add_sq_ne_zero\n  have : ((↑) : ℤ → ℝ) ∘ p ≠ 0 := fun h => hp.ne_zero (by ext i; simpa using congr_fun h i)\n  have nonZ2 : (p 0 : ℂ) * z + p 1 ≠ 0 := by simpa using linear_ne_zero _ z this\n  field_simp [nonZ1, nonZ2, denom_ne_zero, num]\n  rw [(by simp :\n    (p 1 : ℂ) * z - p 0 = (p 1 * z - p 0) * ↑(Matrix.det (↑g : Matrix (Fin 2) (Fin 2) ℤ)))]\n  rw [← hg, det_fin_two]\n  simp only [Int.coe_castRingHom, coe_matrix_coe, Int.cast_mul, ofReal_intCast, map_apply, denom,\n    Int.cast_sub, coe_GLPos_coe_GL_coe_matrix, coe_apply_complex]\n  ring\n\n"}
{"name":"ModularGroup.tendsto_abs_re_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\np : Fin 2 → Int\nhp : IsCoprime (p 0) (p 1)\n⊢ Filter.Tendsto (fun g => abs (HSMul.hSMul (↑g) z).re) Filter.cofinite Filter.atTop","decl":"theorem tendsto_abs_re_smul {p : Fin 2 → ℤ} (hp : IsCoprime (p 0) (p 1)) :\n    Tendsto\n      (fun g : { g : SL(2, ℤ) // g 1 = p } => |((g : SL(2, ℤ)) • z).re|) cofinite atTop := by\n  suffices\n    Tendsto (fun g : (fun g : SL(2, ℤ) => g 1) ⁻¹' {p} => ((g : SL(2, ℤ)) • z).re) cofinite\n      (cocompact ℝ)\n    by exact tendsto_norm_cocompact_atTop.comp this\n  have : ((p 0 : ℝ) ^ 2 + (p 1 : ℝ) ^ 2)⁻¹ ≠ 0 := by\n    apply inv_ne_zero\n    exact mod_cast hp.sq_add_sq_ne_zero\n  let f := Homeomorph.mulRight₀ _ this\n  let ff := Homeomorph.addRight\n    (((p 1 : ℂ) * z - p 0) / (((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) * (p 0 * z + p 1))).re\n  convert (f.trans ff).isClosedEmbedding.tendsto_cocompact.comp (tendsto_lcRow0 hp) with _ _ g\n  change\n    ((g : SL(2, ℤ)) • z).re =\n      lcRow0 p ↑(↑g : SL(2, ℝ)) / ((p 0 : ℝ) ^ 2 + (p 1 : ℝ) ^ 2) +\n        Complex.re (((p 1 : ℂ) * z - p 0) / (((p 0 : ℂ) ^ 2 + (p 1 : ℂ) ^ 2) * (p 0 * z + p 1)))\n  exact mod_cast congr_arg Complex.re (smul_eq_lcRow0_add z hp g.2)\n\n"}
{"name":"ModularGroup.exists_max_im","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Exists fun g => ∀ (g' : Matrix.SpecialLinearGroup (Fin 2) Int), LE.le (HSMul.hSMul g' z).im (HSMul.hSMul g z).im","decl":"/-- For `z : ℍ`, there is a `g : SL(2,ℤ)` maximizing `(g•z).im` -/\ntheorem exists_max_im : ∃ g : SL(2, ℤ), ∀ g' : SL(2, ℤ), (g' • z).im ≤ (g • z).im := by\n  classical\n  let s : Set (Fin 2 → ℤ) := {cd | IsCoprime (cd 0) (cd 1)}\n  have hs : s.Nonempty := ⟨![1, 1], isCoprime_one_left⟩\n  obtain ⟨p, hp_coprime, hp⟩ :=\n    Filter.Tendsto.exists_within_forall_le hs (tendsto_normSq_coprime_pair z)\n  obtain ⟨g, -, hg⟩ := bottom_row_surj hp_coprime\n  refine ⟨g, fun g' => ?_⟩\n  rw [ModularGroup.im_smul_eq_div_normSq, ModularGroup.im_smul_eq_div_normSq,\n    div_le_div_iff_of_pos_left]\n  · simpa [← hg] using hp (g' 1) (bottom_row_coprime g')\n  · exact z.im_pos\n  · exact normSq_denom_pos g' z\n  · exact normSq_denom_pos g z\n\n"}
{"name":"ModularGroup.exists_row_one_eq_and_min_re","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\ncd : Fin 2 → Int\nhcd : IsCoprime (cd 0) (cd 1)\n⊢ Exists fun g => And (Eq (↑g 1) cd) (∀ (g' : Matrix.SpecialLinearGroup (Fin 2) Int), Eq (↑g 1) (↑g' 1) → LE.le (abs (HSMul.hSMul g z).re) (abs (HSMul.hSMul g' z).re))","decl":"/-- Given `z : ℍ` and a bottom row `(c,d)`, among the `g : SL(2,ℤ)` with this bottom row, minimize\n  `|(g•z).re|`. -/\ntheorem exists_row_one_eq_and_min_re {cd : Fin 2 → ℤ} (hcd : IsCoprime (cd 0) (cd 1)) :\n    ∃ g : SL(2, ℤ), g 1 = cd ∧ ∀ g' : SL(2, ℤ), g 1 = g' 1 →\n      |(g • z).re| ≤ |(g' • z).re| := by\n  haveI : Nonempty { g : SL(2, ℤ) // g 1 = cd } :=\n    let ⟨x, hx⟩ := bottom_row_surj hcd\n    ⟨⟨x, hx.2⟩⟩\n  obtain ⟨g, hg⟩ := Filter.Tendsto.exists_forall_le (tendsto_abs_re_smul z hcd)\n  refine ⟨g, g.2, ?_⟩\n  intro g1 hg1\n  have : g1 ∈ (fun g : SL(2, ℤ) => g 1) ⁻¹' {cd} := by\n    rw [Set.mem_preimage, Set.mem_singleton_iff]\n    exact Eq.trans hg1.symm (Set.mem_singleton_iff.mp (Set.mem_preimage.mp g.2))\n  exact hg ⟨g1, this⟩\n\n"}
{"name":"ModularGroup.coe_T_zpow_smul_eq","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\n⊢ Eq (↑(HSMul.hSMul (HPow.hPow ModularGroup.T n) z)) (HAdd.hAdd ↑z ↑n)","decl":"theorem coe_T_zpow_smul_eq {n : ℤ} : (↑(T ^ n • z) : ℂ) = z + n := by\n  rw [sl_moeb, UpperHalfPlane.coe_smul]\n  simp [coe_T_zpow, denom, num, -map_zpow]\n\n"}
{"name":"ModularGroup.re_T_zpow_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\n⊢ Eq (HSMul.hSMul (HPow.hPow ModularGroup.T n) z).re (HAdd.hAdd z.re ↑n)","decl":"theorem re_T_zpow_smul (n : ℤ) : (T ^ n • z).re = z.re + n := by\n  rw [← coe_re, coe_T_zpow_smul_eq, add_re, intCast_re, coe_re]\n\n"}
{"name":"ModularGroup.im_T_zpow_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\n⊢ Eq (HSMul.hSMul (HPow.hPow ModularGroup.T n) z).im z.im","decl":"theorem im_T_zpow_smul (n : ℤ) : (T ^ n • z).im = z.im := by\n  rw [← coe_im, coe_T_zpow_smul_eq, add_im, intCast_im, add_zero, coe_im]\n\n"}
{"name":"ModularGroup.re_T_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HSMul.hSMul ModularGroup.T z).re (HAdd.hAdd z.re 1)","decl":"theorem re_T_smul : (T • z).re = z.re + 1 := by simpa using re_T_zpow_smul z 1\n\n"}
{"name":"ModularGroup.im_T_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HSMul.hSMul ModularGroup.T z).im z.im","decl":"theorem im_T_smul : (T • z).im = z.im := by simpa using im_T_zpow_smul z 1\n\n"}
{"name":"ModularGroup.re_T_inv_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HSMul.hSMul (Inv.inv ModularGroup.T) z).re (HSub.hSub z.re 1)","decl":"theorem re_T_inv_smul : (T⁻¹ • z).re = z.re - 1 := by simpa using re_T_zpow_smul z (-1)\n\n"}
{"name":"ModularGroup.im_T_inv_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Eq (HSMul.hSMul (Inv.inv ModularGroup.T) z).im z.im","decl":"theorem im_T_inv_smul : (T⁻¹ • z).im = z.im := by simpa using im_T_zpow_smul z (-1)\n\n"}
{"name":"ModularGroup.exists_eq_T_zpow_of_c_eq_zero","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nhc : Eq (↑g 1 0) 0\n⊢ Exists fun n => ∀ (z : UpperHalfPlane), Eq (HSMul.hSMul g z) (HSMul.hSMul (HPow.hPow ModularGroup.T n) z)","decl":"theorem exists_eq_T_zpow_of_c_eq_zero (hc : g 1 0 = 0) :\n    ∃ n : ℤ, ∀ z : ℍ, g • z = T ^ n • z := by\n  have had := g.det_coe\n  replace had : g 0 0 * g 1 1 = 1 := by rw [det_fin_two, hc] at had; omega\n  rcases Int.eq_one_or_neg_one_of_mul_eq_one' had with (⟨ha, hd⟩ | ⟨ha, hd⟩)\n  · use g 0 1\n    suffices g = T ^ g 0 1 by intro z; conv_lhs => rw [this]\n    ext i j; fin_cases i <;> fin_cases j <;>\n      simp [ha, hc, hd, coe_T_zpow, show (1 : Fin (0 + 2)) = (1 : Fin 2) from rfl]\n  · use -(g 0 1)\n    suffices g = -T ^ (-(g 0 1)) by intro z; conv_lhs => rw [this, SL_neg_smul]\n    ext i j; fin_cases i <;> fin_cases j <;>\n      simp [ha, hc, hd, coe_T_zpow, show (1 : Fin (0 + 2)) = (1 : Fin 2) from rfl]\n\n-- If `c = 1`, then `g` factorises into a product terms involving only `T` and `S`.\n"}
{"name":"ModularGroup.g_eq_of_c_eq_one","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nhc : Eq (↑g 1 0) 1\n⊢ Eq g (HMul.hMul (HMul.hMul (HPow.hPow ModularGroup.T (↑g 0 0)) ModularGroup.S) (HPow.hPow ModularGroup.T (↑g 1 1)))","decl":"theorem g_eq_of_c_eq_one (hc : g 1 0 = 1) : g = T ^ g 0 0 * S * T ^ g 1 1 := by\n  have hg := g.det_coe.symm\n  replace hg : g 0 1 = g 0 0 * g 1 1 - 1 := by rw [det_fin_two, hc] at hg; omega\n  refine Subtype.ext ?_\n  conv_lhs => rw [(g : Matrix _ _ ℤ).eta_fin_two]\n  simp only [hg, sub_eq_add_neg, hc, coe_mul, coe_T_zpow, coe_S, mul_fin_two, mul_zero, mul_one,\n    zero_add, one_mul, add_zero, zero_mul]\n\n"}
{"name":"ModularGroup.normSq_S_smul_lt_one","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : LT.lt 1 (Complex.normSq ↑z)\n⊢ LT.lt (Complex.normSq ↑(HSMul.hSMul ModularGroup.S z)) 1","decl":"/-- If `1 < |z|`, then `|S • z| < 1`. -/\ntheorem normSq_S_smul_lt_one (h : 1 < normSq z) : normSq ↑(S • z) < 1 := by\n  simpa [coe_S, num, denom] using (inv_lt_inv₀ z.normSq_pos zero_lt_one).mpr h\n\n"}
{"name":"ModularGroup.im_lt_im_S_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : LT.lt (Complex.normSq ↑z) 1\n⊢ LT.lt z.im (HSMul.hSMul ModularGroup.S z).im","decl":"/-- If `|z| < 1`, then applying `S` strictly decreases `im`. -/\ntheorem im_lt_im_S_smul (h : normSq z < 1) : z.im < (S • z).im := by\n  have : z.im < z.im / normSq (z : ℂ) := by\n    have imz : 0 < z.im := im_pos z\n    apply (lt_div_iff₀ z.normSq_pos).mpr\n    nlinarith\n  convert this\n  simp only [ModularGroup.im_smul_eq_div_normSq]\n  simp [denom, coe_S]\n\n"}
{"name":"ModularGroup.abs_two_mul_re_lt_one_of_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : Membership.mem ModularGroup.fdo z\n⊢ LT.lt (abs (HMul.hMul 2 z.re)) 1","decl":"theorem abs_two_mul_re_lt_one_of_mem_fdo (h : z ∈ 𝒟ᵒ) : |2 * z.re| < 1 := by\n  rw [abs_mul, abs_two, ← lt_div_iff₀' (zero_lt_two' ℝ)]\n  exact h.2\n\n"}
{"name":"ModularGroup.three_lt_four_mul_im_sq_of_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nh : Membership.mem ModularGroup.fdo z\n⊢ LT.lt 3 (HMul.hMul 4 (HPow.hPow z.im 2))","decl":"theorem three_lt_four_mul_im_sq_of_mem_fdo (h : z ∈ 𝒟ᵒ) : 3 < 4 * z.im ^ 2 := by\n  have : 1 < z.re * z.re + z.im * z.im := by simpa [Complex.normSq_apply] using h.1\n  have := h.2\n  cases abs_cases z.re <;> nlinarith\n\n"}
{"name":"ModularGroup.three_le_four_mul_im_sq_of_mem_fd","module":"Mathlib.NumberTheory.Modular","initialProofState":"τ : UpperHalfPlane\nh : Membership.mem ModularGroup.fd τ\n⊢ LE.le 3 (HMul.hMul 4 (HPow.hPow τ.im 2))","decl":"/-- non-strict variant of `ModularGroup.three_le_four_mul_im_sq_of_mem_fdo` -/\ntheorem three_le_four_mul_im_sq_of_mem_fd {τ : ℍ} (h : τ ∈ 𝒟) : 3 ≤ 4 * τ.im ^ 2 := by\n  have : 1 ≤ τ.re * τ.re + τ.im * τ.im := by simpa [Complex.normSq_apply] using h.1\n  cases abs_cases τ.re <;> nlinarith [h.2]\n\n"}
{"name":"ModularGroup.one_lt_normSq_T_zpow_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nn : Int\n⊢ LT.lt 1 (Complex.normSq ↑(HSMul.hSMul (HPow.hPow ModularGroup.T n) z))","decl":"/-- If `z ∈ 𝒟ᵒ`, and `n : ℤ`, then `|z + n| > 1`. -/\ntheorem one_lt_normSq_T_zpow_smul (hz : z ∈ 𝒟ᵒ) (n : ℤ) : 1 < normSq (T ^ n • z : ℍ) := by\n  have hz₁ : 1 < z.re * z.re + z.im * z.im := hz.1\n  have hzn := Int.nneg_mul_add_sq_of_abs_le_one n (abs_two_mul_re_lt_one_of_mem_fdo hz).le\n  have : 1 < (z.re + ↑n) * (z.re + ↑n) + z.im * z.im := by linarith\n  simpa [coe_T_zpow, normSq, num, denom, -map_zpow]\n\n"}
{"name":"ModularGroup.eq_zero_of_mem_fdo_of_T_zpow_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\nn : Int\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul (HPow.hPow ModularGroup.T n) z)\n⊢ Eq n 0","decl":"theorem eq_zero_of_mem_fdo_of_T_zpow_mem_fdo {n : ℤ} (hz : z ∈ 𝒟ᵒ) (hg : T ^ n • z ∈ 𝒟ᵒ) :\n    n = 0 := by\n  suffices |(n : ℝ)| < 1 by\n    rwa [← Int.cast_abs, ← Int.cast_one, Int.cast_lt, Int.abs_lt_one_iff] at this\n  have h₁ := hz.2\n  have h₂ := hg.2\n  rw [re_T_zpow_smul] at h₂\n  calc\n    |(n : ℝ)| ≤ |z.re| + |z.re + (n : ℝ)| := abs_add' (n : ℝ) z.re\n    _ < 1 / 2 + 1 / 2 := add_lt_add h₁ h₂\n    _ = 1 := add_halves 1\n\n"}
{"name":"ModularGroup.exists_smul_mem_fd","module":"Mathlib.NumberTheory.Modular","initialProofState":"z : UpperHalfPlane\n⊢ Exists fun g => Membership.mem ModularGroup.fd (HSMul.hSMul g z)","decl":"/-- First Fundamental Domain Lemma: Any `z : ℍ` can be moved to `𝒟` by an element of\n`SL(2,ℤ)` -/\ntheorem exists_smul_mem_fd (z : ℍ) : ∃ g : SL(2, ℤ), g • z ∈ 𝒟 := by\n  -- obtain a g₀ which maximizes im (g • z),\n  obtain ⟨g₀, hg₀⟩ := exists_max_im z\n  -- then among those, minimize re\n  obtain ⟨g, hg, hg'⟩ := exists_row_one_eq_and_min_re z (bottom_row_coprime g₀)\n  refine ⟨g, ?_⟩\n  -- `g` has same max im property as `g₀`\n  have hg₀' : ∀ g' : SL(2, ℤ), (g' • z).im ≤ (g • z).im := by\n    have hg'' : (g • z).im = (g₀ • z).im := by\n      rw [ModularGroup.im_smul_eq_div_normSq, ModularGroup.im_smul_eq_div_normSq,\n        denom_apply, denom_apply, hg]\n    simpa only [hg''] using hg₀\n  constructor\n  · -- Claim: `1 ≤ ⇑norm_sq ↑(g • z)`. If not, then `S•g•z` has larger imaginary part\n    contrapose! hg₀'\n    refine ⟨S * g, ?_⟩\n    rw [mul_smul]\n    exact im_lt_im_S_smul hg₀'\n  · show |(g • z).re| ≤ 1 / 2\n    -- if not, then either `T` or `T'` decrease |Re|.\n    rw [abs_le]\n    constructor\n    · contrapose! hg'\n      refine ⟨T * g, (T_mul_apply_one _).symm, ?_⟩\n      rw [mul_smul, re_T_smul]\n      cases abs_cases ((g • z).re + 1) <;> cases abs_cases (g • z).re <;> linarith\n    · contrapose! hg'\n      refine ⟨T⁻¹ * g, (T_inv_mul_apply_one _).symm, ?_⟩\n      rw [mul_smul, re_T_inv_smul]\n      cases abs_cases ((g • z).re - 1) <;> cases abs_cases (g • z).re <;> linarith\n\n"}
{"name":"ModularGroup.abs_c_le_one","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul g z)\n⊢ LE.le (abs (↑g 1 0)) 1","decl":"/-- An auxiliary result en route to `ModularGroup.c_eq_zero`. -/\ntheorem abs_c_le_one (hz : z ∈ 𝒟ᵒ) (hg : g • z ∈ 𝒟ᵒ) : |g 1 0| ≤ 1 := by\n  let c' : ℤ := g 1 0\n  let c := (c' : ℝ)\n  suffices 3 * c ^ 2 < 4 by\n    rw [← Int.cast_pow, ← Int.cast_three, ← Int.cast_four, ← Int.cast_mul, Int.cast_lt] at this\n    replace this : c' ^ 2 ≤ 1 ^ 2 := by omega\n    rwa [sq_le_sq, abs_one] at this\n  suffices c ≠ 0 → 9 * c ^ 4 < 16 by\n    rcases eq_or_ne c 0 with (hc | hc)\n    · rw [hc]; norm_num\n    · refine (abs_lt_of_sq_lt_sq' ?_ (by norm_num)).2\n      specialize this hc\n      linarith\n  intro hc\n  have h₁ : 3 * 3 * c ^ 4 < 4 * (g • z).im ^ 2 * (4 * z.im ^ 2) * c ^ 4 := by\n    gcongr <;> apply three_lt_four_mul_im_sq_of_mem_fdo <;> assumption\n  have h₂ : (c * z.im) ^ 4 / normSq (denom (↑g) z) ^ 2 ≤ 1 :=\n    div_le_one_of_le₀\n      (pow_four_le_pow_two_of_pow_two_le (z.c_mul_im_sq_le_normSq_denom g))\n      (sq_nonneg _)\n  let nsq := normSq (denom g z)\n  calc\n    9 * c ^ 4 < c ^ 4 * z.im ^ 2 * (g • z).im ^ 2 * 16 := by linarith\n    _ = c ^ 4 * z.im ^ 4 / nsq ^ 2 * 16 := by\n      rw [im_smul_eq_div_normSq, div_pow]\n      ring\n    _ ≤ 16 := by rw [← mul_pow]; linarith\n\n"}
{"name":"ModularGroup.c_eq_zero","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul g z)\n⊢ Eq (↑g 1 0) 0","decl":"/-- An auxiliary result en route to `ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo`. -/\ntheorem c_eq_zero (hz : z ∈ 𝒟ᵒ) (hg : g • z ∈ 𝒟ᵒ) : g 1 0 = 0 := by\n  have hp : ∀ {g' : SL(2, ℤ)}, g' • z ∈ 𝒟ᵒ → g' 1 0 ≠ 1 := by\n    intro g' hg'\n    by_contra hc\n    let a := g' 0 0\n    let d := g' 1 1\n    have had : T ^ (-a) * g' = S * T ^ d := by\n      rw [g_eq_of_c_eq_one hc]\n      dsimp [a, d]\n      group\n    let w := T ^ (-a) • g' • z\n    have h₁ : w = S • T ^ d • z := by simp only [w, ← mul_smul, had]\n    replace h₁ : normSq w < 1 := h₁.symm ▸ normSq_S_smul_lt_one (one_lt_normSq_T_zpow_smul hz d)\n    have h₂ : 1 < normSq w := one_lt_normSq_T_zpow_smul hg' (-a)\n    linarith\n  have hn : g 1 0 ≠ -1 := by\n    intro hc\n    replace hc : (-g) 1 0 = 1 := by simp [← neg_eq_iff_eq_neg.mpr hc]\n    replace hg : -g • z ∈ 𝒟ᵒ := (SL_neg_smul g z).symm ▸ hg\n    exact hp hg hc\n  specialize hp hg\n  rcases Int.abs_le_one_iff.mp <| abs_c_le_one hz hg with ⟨⟩ <;> tauto\n\n"}
{"name":"ModularGroup.eq_smul_self_of_mem_fdo_mem_fdo","module":"Mathlib.NumberTheory.Modular","initialProofState":"g : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\nhz : Membership.mem ModularGroup.fdo z\nhg : Membership.mem ModularGroup.fdo (HSMul.hSMul g z)\n⊢ Eq z (HSMul.hSMul g z)","decl":"/-- Second Fundamental Domain Lemma: if both `z` and `g • z` are in the open domain `𝒟ᵒ`,\nwhere `z : ℍ` and `g : SL(2,ℤ)`, then `z = g • z`. -/\ntheorem eq_smul_self_of_mem_fdo_mem_fdo (hz : z ∈ 𝒟ᵒ) (hg : g • z ∈ 𝒟ᵒ) : z = g • z := by\n  obtain ⟨n, hn⟩ := exists_eq_T_zpow_of_c_eq_zero (c_eq_zero hz hg)\n  rw [hn] at hg ⊢\n  simp [eq_zero_of_mem_fdo_of_T_zpow_mem_fdo hz hg, one_smul]\n\n"}
{"name":"ModularGroup.exists_one_half_le_im_smul","module":"Mathlib.NumberTheory.Modular","initialProofState":"τ : UpperHalfPlane\n⊢ Exists fun γ => LE.le (1 / 2) (HSMul.hSMul γ τ).im","decl":"lemma exists_one_half_le_im_smul (τ : ℍ) : ∃ γ : SL(2, ℤ), 1 / 2 ≤ im (γ • τ) := by\n  obtain ⟨γ, hγ⟩ := exists_smul_mem_fd τ\n  use γ\n  nlinarith [three_le_four_mul_im_sq_of_mem_fd hγ, im_pos (γ • τ)]\n\n"}
{"name":"ModularGroup.exists_one_half_le_im_smul_and_norm_denom_le","module":"Mathlib.NumberTheory.Modular","initialProofState":"τ : UpperHalfPlane\n⊢ Exists fun γ => And (LE.le (1 / 2) (HSMul.hSMul γ τ).im) (LE.le (Norm.norm (UpperHalfPlane.denom (↑γ) τ)) 1)","decl":"/-- For every `τ : ℍ` there is some `γ ∈ SL(2, ℤ)` that sends it to an element whose\nimaginary part is at least `1/2` and such that `denom γ τ` has norm at most 1. -/\nlemma exists_one_half_le_im_smul_and_norm_denom_le (τ : ℍ) :\n    ∃ γ : SL(2, ℤ), 1 / 2 ≤ im (γ • τ) ∧ ‖denom γ τ‖ ≤ 1 := by\n  rcases le_total (1 / 2) τ.im with h | h\n  · exact ⟨1, (one_smul SL(2, ℤ) τ).symm ▸ h, by simp only [coe_one, denom_one, norm_one, le_refl]⟩\n  · refine (exists_one_half_le_im_smul τ).imp (fun γ hγ ↦ ⟨hγ, ?_⟩)\n    have h1 : τ.im ≤ (γ • τ).im := h.trans hγ\n    rw [im_smul_eq_div_normSq, le_div_iff₀ (normSq_denom_pos (↑γ) τ), normSq_eq_norm_sq] at h1\n    simpa only [norm_eq_abs, sq_le_one_iff_abs_le_one, Complex.abs_abs] using\n      (mul_le_iff_le_one_right τ.2).mp h1\n\n"}
