{"name":"CategoryTheory.Functor.Elements.ext","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nx y : F.Elements\nh‚ÇÅ : Eq x.fst y.fst\nh‚ÇÇ : Eq (F.map (CategoryTheory.eqToHom h‚ÇÅ) x.snd) y.snd\n‚ä¢ Eq x y","decl":"lemma Functor.Elements.ext {F : C ‚•§ Type w} (x y : F.Elements) (h‚ÇÅ : x.fst = y.fst)\n    (h‚ÇÇ : F.map (eqToHom h‚ÇÅ) x.snd = y.snd) : x = y := by\n  cases x\n  cases y\n  cases h‚ÇÅ\n  simp only [eqToHom_refl, FunctorToTypes.map_id_apply] at h‚ÇÇ\n  simp [h‚ÇÇ]\n\n"}
{"name":"CategoryTheory.NatTrans.mapElements_map_coe","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nœÜ : Quiver.Hom F G\np q : F.Elements\nx‚úù : Quiver.Hom p q\n‚ä¢ Eq ‚Üë((CategoryTheory.NatTrans.mapElements œÜ).map x‚úù) ‚Üëx‚úù","decl":"/-- Natural transformations are mapped to functors between category of elements -/\n@[simps]\ndef NatTrans.mapElements {F G : C ‚•§ Type w} (œÜ : F ‚ü∂ G) : F.Elements ‚•§ G.Elements where\n  obj := fun ‚ü®X, x‚ü© ‚Ü¶ ‚ü®_, œÜ.app X x‚ü©\n  map {p q} := fun ‚ü®f, h‚ü© ‚Ü¶ ‚ü®f, by have hb := congrFun (œÜ.naturality f) p.2; aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.NatTrans.mapElements_obj","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nœÜ : Quiver.Hom F G\nx‚úù : F.Elements\n‚ä¢ Eq ((CategoryTheory.NatTrans.mapElements œÜ).obj x‚úù) (CategoryTheory.NatTrans.mapElements.match_1 (fun x => G.Elements) x‚úù fun X x => ‚ü®X, œÜ.app X x‚ü©)","decl":"/-- Natural transformations are mapped to functors between category of elements -/\n@[simps]\ndef NatTrans.mapElements {F G : C ‚•§ Type w} (œÜ : F ‚ü∂ G) : F.Elements ‚•§ G.Elements where\n  obj := fun ‚ü®X, x‚ü© ‚Ü¶ ‚ü®_, œÜ.app X x‚ü©\n  map {p q} := fun ‚ü®f, h‚ü© ‚Ü¶ ‚ü®f, by have hb := congrFun (œÜ.naturality f) p.2; aesop_cat‚ü©\n\n"}
{"name":"CategoryTheory.Functor.elementsFunctor_map","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nX‚úù Y‚úù : CategoryTheory.Functor C (Type w)\nn : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (CategoryTheory.Functor.elementsFunctor.map n) (CategoryTheory.NatTrans.mapElements n)","decl":"/-- The functor mapping functors `C ‚•§ Type w` to their category of elements -/\n@[simps]\ndef Functor.elementsFunctor : (C ‚•§ Type w) ‚•§ Cat where\n  obj F := Cat.of F.Elements\n  map n := NatTrans.mapElements n\n\n"}
{"name":"CategoryTheory.Functor.elementsFunctor_obj","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ Eq (CategoryTheory.Functor.elementsFunctor.obj F) (CategoryTheory.Cat.of F.Elements)","decl":"/-- The functor mapping functors `C ‚•§ Type w` to their category of elements -/\n@[simps]\ndef Functor.elementsFunctor : (C ‚•§ Type w) ‚•§ Cat where\n  obj F := Cat.of F.Elements\n  map n := NatTrans.mapElements n\n\n"}
{"name":"CategoryTheory.CategoryOfElements.homMk_coe","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nx y : F.Elements\nf : Quiver.Hom x.fst y.fst\nhf : Eq (F.map f x.snd) y.snd\n‚ä¢ Eq (‚Üë(CategoryTheory.CategoryOfElements.homMk x y f hf)) f","decl":"/-- Constructor for morphisms in the category of elements of a functor to types. -/\n@[simps]\ndef homMk {F : C ‚•§ Type w} (x y : F.Elements) (f : x.1 ‚ü∂ y.1) (hf : F.map f x.snd = y.snd) :\n    x ‚ü∂ y :=\n  ‚ü®f, hf‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.ext_iff","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nx y : F.Elements\nf g : Quiver.Hom x y\n‚ä¢ Iff (Eq f g) (Eq ‚Üëf ‚Üëg)","decl":"@[ext]\ntheorem ext (F : C ‚•§ Type w) {x y : F.Elements} (f g : x ‚ü∂ y) (w : f.val = g.val) : f = g :=\n  Subtype.ext_val w\n\n"}
{"name":"CategoryTheory.CategoryOfElements.ext","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nx y : F.Elements\nf g : Quiver.Hom x y\nw : Eq ‚Üëf ‚Üëg\n‚ä¢ Eq f g","decl":"@[ext]\ntheorem ext (F : C ‚•§ Type w) {x y : F.Elements} (f g : x ‚ü∂ y) (w : f.val = g.val) : f = g :=\n  Subtype.ext_val w\n\n"}
{"name":"CategoryTheory.CategoryOfElements.comp_val","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\np q r : F.Elements\nf : Quiver.Hom p q\ng : Quiver.Hom q r\n‚ä¢ Eq (‚Üë(CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp ‚Üëf ‚Üëg)","decl":"@[simp]\ntheorem comp_val {F : C ‚•§ Type w} {p q r : F.Elements} {f : p ‚ü∂ q} {g : q ‚ü∂ r} :\n    (f ‚â´ g).val = f.val ‚â´ g.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.id_val","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\np : F.Elements\n‚ä¢ Eq (‚Üë(CategoryTheory.CategoryStruct.id p)) (CategoryTheory.CategoryStruct.id p.fst)","decl":"@[simp]\ntheorem id_val {F : C ‚•§ Type w} {p : F.Elements} : (ùüô p : p ‚ü∂ p).val = ùüô p.1 :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.map_snd","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\np q : F.Elements\nf : Quiver.Hom p q\n‚ä¢ Eq (F.map (‚Üëf) p.snd) q.snd","decl":"@[simp]\ntheorem map_snd {F : C ‚•§ Type w} {p q : F.Elements} (f : p ‚ü∂ q) : (F.map f.val) p.2 = q.2 :=\n  f.property\n\n"}
{"name":"CategoryTheory.CategoryOfElements.isoMk_hom","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nx y : F.Elements\ne : CategoryTheory.Iso x.fst y.fst\nhe : Eq (F.map e.hom x.snd) y.snd\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.isoMk x y e he).hom (CategoryTheory.CategoryOfElements.homMk x y e.hom he)","decl":"/-- Constructor for isomorphisms in the category of elements of a functor to types. -/\n@[simps]\ndef isoMk {F : C ‚•§ Type w} (x y : F.Elements) (e : x.1 ‚âÖ y.1) (he : F.map e.hom x.snd = y.snd) :\n    x ‚âÖ y where\n  hom := homMk x y e.hom he\n  inv := homMk y x e.inv (by rw [‚Üê he, FunctorToTypes.map_inv_map_hom_apply])\n\n"}
{"name":"CategoryTheory.CategoryOfElements.isoMk_inv","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nx y : F.Elements\ne : CategoryTheory.Iso x.fst y.fst\nhe : Eq (F.map e.hom x.snd) y.snd\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.isoMk x y e he).inv (CategoryTheory.CategoryOfElements.homMk y x e.inv ‚ãØ)","decl":"/-- Constructor for isomorphisms in the category of elements of a functor to types. -/\n@[simps]\ndef isoMk {F : C ‚•§ Type w} (x y : F.Elements) (e : x.1 ‚âÖ y.1) (he : F.map e.hom x.snd = y.snd) :\n    x ‚âÖ y where\n  hom := homMk x y e.hom he\n  inv := homMk y x e.inv (by rw [‚Üê he, FunctorToTypes.map_inv_map_hom_apply])\n\n"}
{"name":"CategoryTheory.CategoryOfElements.œÄ_obj","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX : F.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.œÄ F).obj X) X.fst","decl":"/-- The functor out of the category of elements which forgets the element. -/\n@[simps]\ndef œÄ : F.Elements ‚•§ C where\n  obj X := X.1\n  map f := f.val\n\n"}
{"name":"CategoryTheory.CategoryOfElements.œÄ_map","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX‚úù Y‚úù : F.Elements\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.œÄ F).map f) ‚Üëf","decl":"/-- The functor out of the category of elements which forgets the element. -/\n@[simps]\ndef œÄ : F.Elements ‚•§ C where\n  obj X := X.1\n  map f := f.val\n\n"}
{"name":"CategoryTheory.CategoryOfElements.instFaithfulElementsœÄ","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ (CategoryTheory.CategoryOfElements.œÄ F).Faithful","decl":"instance : (œÄ F).Faithful where\n\n"}
{"name":"CategoryTheory.CategoryOfElements.instReflectsIsomorphismsElementsœÄ","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ (CategoryTheory.CategoryOfElements.œÄ F).ReflectsIsomorphisms","decl":"instance : (œÄ F).ReflectsIsomorphisms where\n  reflects {X Y} f h := ‚ü®‚ü®‚ü®inv ((œÄ F).map f),\n    by rw [‚Üê map_snd f, ‚Üê FunctorToTypes.map_comp_apply]; simp‚ü©, by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.map_map_coe","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C (Type w)\nŒ± : Quiver.Hom F‚ÇÅ F‚ÇÇ\nt‚ÇÅ t‚ÇÇ : F‚ÇÅ.Elements\nk : Quiver.Hom t‚ÇÅ t‚ÇÇ\n‚ä¢ Eq ‚Üë((CategoryTheory.CategoryOfElements.map Œ±).map k) ‚Üëk","decl":"/-- A natural transformation between functors induces a functor between the categories of elements.\n-/\n@[simps]\ndef map {F‚ÇÅ F‚ÇÇ : C ‚•§ Type w} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) : F‚ÇÅ.Elements ‚•§ F‚ÇÇ.Elements where\n  obj t := ‚ü®t.1, Œ±.app t.1 t.2‚ü©\n  map {t‚ÇÅ t‚ÇÇ} k := ‚ü®k.1, by simpa [map_snd] using (FunctorToTypes.naturality _ _ Œ± k.1 t‚ÇÅ.2).symm‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.map_obj_fst","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C (Type w)\nŒ± : Quiver.Hom F‚ÇÅ F‚ÇÇ\nt : F‚ÇÅ.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.map Œ±).obj t).fst t.fst","decl":"/-- A natural transformation between functors induces a functor between the categories of elements.\n-/\n@[simps]\ndef map {F‚ÇÅ F‚ÇÇ : C ‚•§ Type w} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) : F‚ÇÅ.Elements ‚•§ F‚ÇÇ.Elements where\n  obj t := ‚ü®t.1, Œ±.app t.1 t.2‚ü©\n  map {t‚ÇÅ t‚ÇÇ} k := ‚ü®k.1, by simpa [map_snd] using (FunctorToTypes.naturality _ _ Œ± k.1 t‚ÇÅ.2).symm‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.map_obj_snd","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C (Type w)\nŒ± : Quiver.Hom F‚ÇÅ F‚ÇÇ\nt : F‚ÇÅ.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.map Œ±).obj t).snd (Œ±.app t.fst t.snd)","decl":"/-- A natural transformation between functors induces a functor between the categories of elements.\n-/\n@[simps]\ndef map {F‚ÇÅ F‚ÇÇ : C ‚•§ Type w} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) : F‚ÇÅ.Elements ‚•§ F‚ÇÇ.Elements where\n  obj t := ‚ü®t.1, Œ±.app t.1 t.2‚ü©\n  map {t‚ÇÅ t‚ÇÇ} k := ‚ü®k.1, by simpa [map_snd] using (FunctorToTypes.naturality _ _ Œ± k.1 t‚ÇÅ.2).symm‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.map_œÄ","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor C (Type w)\nŒ± : Quiver.Hom F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.map Œ±).comp (CategoryTheory.CategoryOfElements.œÄ F‚ÇÇ)) (CategoryTheory.CategoryOfElements.œÄ F‚ÇÅ)","decl":"@[simp]\ntheorem map_œÄ {F‚ÇÅ F‚ÇÇ : C ‚•§ Type w} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) : map Œ± ‚ãô œÄ F‚ÇÇ = œÄ F‚ÇÅ :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.toStructuredArrow_obj","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX : F.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.toStructuredArrow F).obj X) { left := { as := PUnit.unit }, right := X.fst, hom := fun x => X.snd }","decl":"@[simp]\ntheorem toStructuredArrow_obj (X) :\n    (toStructuredArrow F).obj X =\n      { left := ‚ü®‚ü®‚ü©‚ü©\n        right := X.1\n        hom := fun _ => X.2 } :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.to_comma_map_right","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX Y : F.Elements\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.toStructuredArrow F).map f).right ‚Üëf","decl":"@[simp]\ntheorem to_comma_map_right {X Y} (f : X ‚ü∂ Y) : ((toStructuredArrow F).map f).right = f.val :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.fromStructuredArrow_obj","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX : CategoryTheory.StructuredArrow PUnit.{w + 1} F\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.fromStructuredArrow F).obj X) ‚ü®X.right, X.hom PUnit.unit‚ü©","decl":"@[simp]\ntheorem fromStructuredArrow_obj (X) : (fromStructuredArrow F).obj X = ‚ü®X.right, X.hom PUnit.unit‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.fromStructuredArrow_map","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX Y : CategoryTheory.StructuredArrow PUnit.{w + 1} F\nf : Quiver.Hom X Y\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.fromStructuredArrow F).map f) ‚ü®f.right, ‚ãØ‚ü©","decl":"@[simp]\ntheorem fromStructuredArrow_map {X Y} (f : X ‚ü∂ Y) :\n    (fromStructuredArrow F).map f = ‚ü®f.right, congr_fun f.w.symm PUnit.unit‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_counitIso","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.structuredArrowEquivalence F).counitIso (CategoryTheory.Iso.refl ((CategoryTheory.CategoryOfElements.fromStructuredArrow F).comp (CategoryTheory.CategoryOfElements.toStructuredArrow F)))","decl":"/-- The equivalence between the category of elements `F.Elements`\n    and the comma category `(*, F)`. -/\n@[simps]\ndef structuredArrowEquivalence : F.Elements ‚âå StructuredArrow PUnit F where\n  functor := toStructuredArrow F\n  inverse := fromStructuredArrow F\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_inverse","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.structuredArrowEquivalence F).inverse (CategoryTheory.CategoryOfElements.fromStructuredArrow F)","decl":"/-- The equivalence between the category of elements `F.Elements`\n    and the comma category `(*, F)`. -/\n@[simps]\ndef structuredArrowEquivalence : F.Elements ‚âå StructuredArrow PUnit F where\n  functor := toStructuredArrow F\n  inverse := fromStructuredArrow F\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_functor","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.structuredArrowEquivalence F).functor (CategoryTheory.CategoryOfElements.toStructuredArrow F)","decl":"/-- The equivalence between the category of elements `F.Elements`\n    and the comma category `(*, F)`. -/\n@[simps]\ndef structuredArrowEquivalence : F.Elements ‚âå StructuredArrow PUnit F where\n  functor := toStructuredArrow F\n  inverse := fromStructuredArrow F\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.structuredArrowEquivalence_unitIso","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.structuredArrowEquivalence F).unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id F.Elements))","decl":"/-- The equivalence between the category of elements `F.Elements`\n    and the comma category `(*, F)`. -/\n@[simps]\ndef structuredArrowEquivalence : F.Elements ‚âå StructuredArrow PUnit F where\n  functor := toStructuredArrow F\n  inverse := fromStructuredArrow F\n  unitIso := Iso.refl _\n  counitIso := Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.toCostructuredArrow_obj","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : Opposite F.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.toCostructuredArrow F).obj X) (CategoryTheory.CostructuredArrow.mk (CategoryTheory.yonedaEquiv.symm (Opposite.unop X).snd))","decl":"/-- The forward direction of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n-/\n@[simps]\ndef toCostructuredArrow (F : C·µí·µñ ‚•§ Type v) : F.Elements·µí·µñ ‚•§ CostructuredArrow yoneda F where\n  obj X := CostructuredArrow.mk (yonedaEquiv.symm (unop X).2)\n  map f :=\n    CostructuredArrow.homMk f.unop.val.unop (by\n      ext Z y\n      dsimp [yonedaEquiv]\n      simp only [FunctorToTypes.map_comp_apply, ‚Üê f.unop.2])\n\n"}
{"name":"CategoryTheory.CategoryOfElements.toCostructuredArrow_map","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX‚úù Y‚úù : Opposite F.Elements\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.toCostructuredArrow F).map f) (CategoryTheory.CostructuredArrow.homMk (‚Üëf.unop).unop ‚ãØ)","decl":"/-- The forward direction of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n-/\n@[simps]\ndef toCostructuredArrow (F : C·µí·µñ ‚•§ Type v) : F.Elements·µí·µñ ‚•§ CostructuredArrow yoneda F where\n  obj X := CostructuredArrow.mk (yonedaEquiv.symm (unop X).2)\n  map f :=\n    CostructuredArrow.homMk f.unop.val.unop (by\n      ext Z y\n      dsimp [yonedaEquiv]\n      simp only [FunctorToTypes.map_comp_apply, ‚Üê f.unop.2])\n\n"}
{"name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_map_coe","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX Y : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)\nf : Quiver.Hom X Y\n‚ä¢ Eq (‚Üë((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).map f)) f.unop.left.op","decl":"/-- The reverse direction of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n-/\n@[simps]\ndef fromCostructuredArrow (F : C·µí·µñ ‚•§ Type v) : (CostructuredArrow yoneda F)·µí·µñ ‚•§ F.Elements where\n  obj X := ‚ü®op (unop X).1, yonedaEquiv.1 (unop X).3‚ü©\n  map {X Y} f :=\n    ‚ü®f.unop.1.op, by\n      convert (congr_fun ((unop X).hom.naturality f.unop.left.op) (ùüô _)).symm\n      simp only [Equiv.toFun_as_coe, Quiver.Hom.unop_op, yonedaEquiv_apply, types_comp_apply,\n        Category.comp_id, yoneda_obj_map]\n      have : yoneda.map f.unop.left ‚â´ (unop X).hom = (unop Y).hom := by\n        convert f.unop.3\n      rw [‚Üê this]\n      simp only [yoneda_map_app, FunctorToTypes.comp]\n      rw [Category.id_comp]‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_snd","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).obj X).snd (CategoryTheory.yonedaEquiv.toFun (Opposite.unop X).hom)","decl":"/-- The reverse direction of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n-/\n@[simps]\ndef fromCostructuredArrow (F : C·µí·µñ ‚•§ Type v) : (CostructuredArrow yoneda F)·µí·µñ ‚•§ F.Elements where\n  obj X := ‚ü®op (unop X).1, yonedaEquiv.1 (unop X).3‚ü©\n  map {X Y} f :=\n    ‚ü®f.unop.1.op, by\n      convert (congr_fun ((unop X).hom.naturality f.unop.left.op) (ùüô _)).symm\n      simp only [Equiv.toFun_as_coe, Quiver.Hom.unop_op, yonedaEquiv_apply, types_comp_apply,\n        Category.comp_id, yoneda_obj_map]\n      have : yoneda.map f.unop.left ‚â´ (unop X).hom = (unop Y).hom := by\n        convert f.unop.3\n      rw [‚Üê this]\n      simp only [yoneda_map_app, FunctorToTypes.comp]\n      rw [Category.id_comp]‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_fst","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : Opposite (CategoryTheory.CostructuredArrow CategoryTheory.yoneda F)\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).obj X).fst { unop := (Opposite.unop X).left }","decl":"/-- The reverse direction of the equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)`,\ngiven by `CategoryTheory.yonedaEquiv`.\n-/\n@[simps]\ndef fromCostructuredArrow (F : C·µí·µñ ‚•§ Type v) : (CostructuredArrow yoneda F)·µí·µñ ‚•§ F.Elements where\n  obj X := ‚ü®op (unop X).1, yonedaEquiv.1 (unop X).3‚ü©\n  map {X Y} f :=\n    ‚ü®f.unop.1.op, by\n      convert (congr_fun ((unop X).hom.naturality f.unop.left.op) (ùüô _)).symm\n      simp only [Equiv.toFun_as_coe, Quiver.Hom.unop_op, yonedaEquiv_apply, types_comp_apply,\n        Category.comp_id, yoneda_obj_map]\n      have : yoneda.map f.unop.left ‚â´ (unop X).hom = (unop Y).hom := by\n        convert f.unop.3\n      rw [‚Üê this]\n      simp only [yoneda_map_app, FunctorToTypes.comp]\n      rw [Category.id_comp]‚ü©\n\n"}
{"name":"CategoryTheory.CategoryOfElements.fromCostructuredArrow_obj_mk","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : C\nf : Quiver.Hom (CategoryTheory.yoneda.obj X) F\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).obj { unop := CategoryTheory.CostructuredArrow.mk f }) ‚ü®{ unop := X }, CategoryTheory.yonedaEquiv.toFun f‚ü©","decl":"@[simp]\ntheorem fromCostructuredArrow_obj_mk (F : C·µí·µñ ‚•§ Type v) {X : C} (f : yoneda.obj X ‚ü∂ F) :\n    (fromCostructuredArrow F).obj (op (CostructuredArrow.mk f)) = ‚ü®op X, yonedaEquiv.1 f‚ü© :=\n  rfl\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_counitIso","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence F).counitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.CostructuredArrow.isoMk (CategoryTheory.Iso.refl (((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).rightOp.comp (CategoryTheory.CategoryOfElements.toCostructuredArrow F)).obj X).left) ‚ãØ) ‚ãØ)","decl":"/-- The equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)` given by yoneda lemma. -/\n@[simps]\ndef costructuredArrowYonedaEquivalence (F : C·µí·µñ ‚•§ Type v) :\n    F.Elements·µí·µñ ‚âå CostructuredArrow yoneda F where\n  functor := toCostructuredArrow F\n  inverse := (fromCostructuredArrow F).rightOp\n  unitIso :=\n    NatIso.ofComponents\n      (fun X ‚Ü¶ Iso.op (CategoryOfElements.isoMk _ _ (Iso.refl _) (by simp))) (by\n        rintro ‚ü®x‚ü© ‚ü®y‚ü© ‚ü®f : y ‚ü∂ x‚ü©\n        exact Quiver.Hom.unop_inj (by ext; simp))\n  counitIso := NatIso.ofComponents (fun X ‚Ü¶ CostructuredArrow.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_inverse","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence F).inverse (CategoryTheory.CategoryOfElements.fromCostructuredArrow F).rightOp","decl":"/-- The equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)` given by yoneda lemma. -/\n@[simps]\ndef costructuredArrowYonedaEquivalence (F : C·µí·µñ ‚•§ Type v) :\n    F.Elements·µí·µñ ‚âå CostructuredArrow yoneda F where\n  functor := toCostructuredArrow F\n  inverse := (fromCostructuredArrow F).rightOp\n  unitIso :=\n    NatIso.ofComponents\n      (fun X ‚Ü¶ Iso.op (CategoryOfElements.isoMk _ _ (Iso.refl _) (by simp))) (by\n        rintro ‚ü®x‚ü© ‚ü®y‚ü© ‚ü®f : y ‚ü∂ x‚ü©\n        exact Quiver.Hom.unop_inj (by ext; simp))\n  counitIso := NatIso.ofComponents (fun X ‚Ü¶ CostructuredArrow.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_unitIso","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence F).unitIso (CategoryTheory.NatIso.ofComponents (fun X => (CategoryTheory.CategoryOfElements.isoMk ((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).obj { unop := (CategoryTheory.CategoryOfElements.toCostructuredArrow F).obj X }) (Opposite.unop X) (CategoryTheory.Iso.refl ((CategoryTheory.CategoryOfElements.fromCostructuredArrow F).obj { unop := (CategoryTheory.CategoryOfElements.toCostructuredArrow F).obj X }).fst) ‚ãØ).op) ‚ãØ)","decl":"/-- The equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)` given by yoneda lemma. -/\n@[simps]\ndef costructuredArrowYonedaEquivalence (F : C·µí·µñ ‚•§ Type v) :\n    F.Elements·µí·µñ ‚âå CostructuredArrow yoneda F where\n  functor := toCostructuredArrow F\n  inverse := (fromCostructuredArrow F).rightOp\n  unitIso :=\n    NatIso.ofComponents\n      (fun X ‚Ü¶ Iso.op (CategoryOfElements.isoMk _ _ (Iso.refl _) (by simp))) (by\n        rintro ‚ü®x‚ü© ‚ü®y‚ü© ‚ü®f : y ‚ü∂ x‚ü©\n        exact Quiver.Hom.unop_inj (by ext; simp))\n  counitIso := NatIso.ofComponents (fun X ‚Ü¶ CostructuredArrow.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence_functor","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ Eq (CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalence F).functor (CategoryTheory.CategoryOfElements.toCostructuredArrow F)","decl":"/-- The equivalence `F.Elements·µí·µñ ‚âÖ (yoneda, F)` given by yoneda lemma. -/\n@[simps]\ndef costructuredArrowYonedaEquivalence (F : C·µí·µñ ‚•§ Type v) :\n    F.Elements·µí·µñ ‚âå CostructuredArrow yoneda F where\n  functor := toCostructuredArrow F\n  inverse := (fromCostructuredArrow F).rightOp\n  unitIso :=\n    NatIso.ofComponents\n      (fun X ‚Ü¶ Iso.op (CategoryOfElements.isoMk _ _ (Iso.refl _) (by simp))) (by\n        rintro ‚ü®x‚ü© ‚ü®y‚ü© ‚ü®f : y ‚ü∂ x‚ü©\n        exact Quiver.Hom.unop_inj (by ext; simp))\n  counitIso := NatIso.ofComponents (fun X ‚Ü¶ CostructuredArrow.isoMk (Iso.refl _))\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrow_yoneda_equivalence_naturality","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF‚ÇÅ F‚ÇÇ : CategoryTheory.Functor (Opposite C) (Type v)\nŒ± : Quiver.Hom F‚ÇÅ F‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.map Œ±).op.comp (CategoryTheory.CategoryOfElements.toCostructuredArrow F‚ÇÇ)) ((CategoryTheory.CategoryOfElements.toCostructuredArrow F‚ÇÅ).comp (CategoryTheory.CostructuredArrow.map Œ±))","decl":"/-- The equivalence `(-.Elements)·µí·µñ ‚âÖ (yoneda, -)` of is actually a natural isomorphism of functors.\n-/\ntheorem costructuredArrow_yoneda_equivalence_naturality {F‚ÇÅ F‚ÇÇ : C·µí·µñ ‚•§ Type v} (Œ± : F‚ÇÅ ‚ü∂ F‚ÇÇ) :\n    (map Œ±).op ‚ãô toCostructuredArrow F‚ÇÇ = toCostructuredArrow F‚ÇÅ ‚ãô CostructuredArrow.map Œ± := by\n  fapply Functor.ext\n  ¬∑ intro X\n    simp only [CostructuredArrow.map_mk, toCostructuredArrow_obj, Functor.op_obj,\n      Functor.comp_obj]\n    congr\n    ext _ f\n    simpa using congr_fun (Œ±.naturality f.op).symm (unop X).snd\n  ¬∑ simp\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_inv_app","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : Opposite F.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj F).inv.app X) (CategoryTheory.CategoryStruct.id (Opposite.unop (Opposite.unop X).1))","decl":"/-- The equivalence `F.elements·µí·µñ ‚âå (yoneda, F)` is compatible with the forgetful functors. -/\n@[simps!]\ndef costructuredArrowYonedaEquivalenceFunctorProj (F : C·µí·µñ ‚•§ Type v) :\n    (costructuredArrowYonedaEquivalence F).functor ‚ãô CostructuredArrow.proj _ _ ‚âÖ (œÄ F).leftOp :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj_hom_app","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : Opposite F.Elements\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceFunctorProj F).hom.app X) (CategoryTheory.CategoryStruct.id (Opposite.unop (Opposite.unop X).1))","decl":"/-- The equivalence `F.elements·µí·µñ ‚âå (yoneda, F)` is compatible with the forgetful functors. -/\n@[simps!]\ndef costructuredArrowYonedaEquivalenceFunctorProj (F : C·µí·µñ ‚•§ Type v) :\n    (costructuredArrowYonedaEquivalence F).functor ‚ãô CostructuredArrow.proj _ _ ‚âÖ (œÄ F).leftOp :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ_inv_app","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda F\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ F).inv.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The equivalence `F.elements·µí·µñ ‚âå (yoneda, F)` is compatible with the forgetful functors. -/\n@[simps!]\ndef costructuredArrowYonedaEquivalenceInverseœÄ (F : C·µí·µñ ‚•§ Type v) :\n    (costructuredArrowYonedaEquivalence F).inverse ‚ãô (œÄ F).leftOp ‚âÖ CostructuredArrow.proj _ _ :=\n  Iso.refl _\n\n"}
{"name":"CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ_hom_app","module":"Mathlib.CategoryTheory.Elements","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor (Opposite C) (Type v)\nX : CategoryTheory.CostructuredArrow CategoryTheory.yoneda F\n‚ä¢ Eq ((CategoryTheory.CategoryOfElements.costructuredArrowYonedaEquivalenceInverseœÄ F).hom.app X) (CategoryTheory.CategoryStruct.id X.left)","decl":"/-- The equivalence `F.elements·µí·µñ ‚âå (yoneda, F)` is compatible with the forgetful functors. -/\n@[simps!]\ndef costructuredArrowYonedaEquivalenceInverseœÄ (F : C·µí·µñ ‚•§ Type v) :\n    (costructuredArrowYonedaEquivalence F).inverse ‚ãô (œÄ F).leftOp ‚âÖ CostructuredArrow.proj _ _ :=\n  Iso.refl _\n\n"}
