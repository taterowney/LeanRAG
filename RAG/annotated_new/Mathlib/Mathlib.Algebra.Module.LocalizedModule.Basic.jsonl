{"name":"LocalizedModule.r.isEquiv","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ IsEquiv (Prod M (Subtype fun x => Membership.mem S x)) (LocalizedModule.r S M)","decl":"theorem r.isEquiv : IsEquiv _ (r S M) :=\n  { refl := fun ⟨m, s⟩ => ⟨1, by rw [one_smul]⟩\n    trans := fun ⟨m1, s1⟩ ⟨m2, s2⟩ ⟨m3, s3⟩ ⟨u1, hu1⟩ ⟨u2, hu2⟩ => by\n      use u1 * u2 * s2\n      -- Put everything in the same shape, sorting the terms using `simp`\n      have hu1' := congr_arg ((u2 * s3) • ·) hu1.symm\n      have hu2' := congr_arg ((u1 * s1) • ·) hu2.symm\n      simp only [← mul_smul, smul_assoc, mul_assoc, mul_comm, mul_left_comm] at hu1' hu2' ⊢\n      rw [hu2', hu1']\n    symm := fun ⟨_, _⟩ ⟨_, _⟩ ⟨u, hu⟩ => ⟨u, hu.symm⟩ }\n\n"}
{"name":"LocalizedModule.mk_eq","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm m' : M\ns s' : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (LocalizedModule.mk m s) (LocalizedModule.mk m' s')) (Exists fun u => Eq (HSMul.hSMul u (HSMul.hSMul s' m)) (HSMul.hSMul u (HSMul.hSMul s m')))","decl":"theorem mk_eq {m m' : M} {s s' : S} : mk m s = mk m' s' ↔ ∃ u : S, u • s' • m = u • s • m' :=\n  Quotient.eq'\n\n"}
{"name":"LocalizedModule.induction_on","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nβ : LocalizedModule S M → Prop\nh : ∀ (m : M) (s : Subtype fun x => Membership.mem S x), β (LocalizedModule.mk m s)\nx : LocalizedModule S M\n⊢ β x","decl":"@[elab_as_elim, induction_eliminator, cases_eliminator]\ntheorem induction_on {β : LocalizedModule S M → Prop} (h : ∀ (m : M) (s : S), β (mk m s)) :\n    ∀ x : LocalizedModule S M, β x := by\n  rintro ⟨⟨m, s⟩⟩\n  exact h m s\n\n"}
{"name":"LocalizedModule.induction_on₂","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nβ : LocalizedModule S M → LocalizedModule S M → Prop\nh : ∀ (m m' : M) (s s' : Subtype fun x => Membership.mem S x), β (LocalizedModule.mk m s) (LocalizedModule.mk m' s')\nx y : LocalizedModule S M\n⊢ β x y","decl":"@[elab_as_elim]\ntheorem induction_on₂ {β : LocalizedModule S M → LocalizedModule S M → Prop}\n    (h : ∀ (m m' : M) (s s' : S), β (mk m s) (mk m' s')) : ∀ x y, β x y := by\n  rintro ⟨⟨m, s⟩⟩ ⟨⟨m', s'⟩⟩\n  exact h m m' s s'\n\n"}
{"name":"LocalizedModule.liftOn_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_2\nf : Prod M (Subtype fun x => Membership.mem S x) → α\nwd : ∀ (p p' : Prod M (Subtype fun x => Membership.mem S x)), HasEquiv.Equiv p p' → Eq (f p) (f p')\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((LocalizedModule.mk m s).liftOn f wd) (f { fst := m, snd := s })","decl":"theorem liftOn_mk {α : Type*} {f : M × S → α} (wd : ∀ (p p' : M × S), p ≈ p' → f p = f p')\n    (m : M) (s : S) : liftOn (mk m s) f wd = f ⟨m, s⟩ := by convert Quotient.liftOn_mk f wd ⟨m, s⟩\n\n"}
{"name":"LocalizedModule.liftOn₂_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nα : Type u_2\nf : Prod M (Subtype fun x => Membership.mem S x) → Prod M (Subtype fun x => Membership.mem S x) → α\nwd : ∀ (p q p' q' : Prod M (Subtype fun x => Membership.mem S x)), HasEquiv.Equiv p p' → HasEquiv.Equiv q q' → Eq (f p q) (f p' q')\nm m' : M\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq ((LocalizedModule.mk m s).liftOn₂ (LocalizedModule.mk m' s') f wd) (f { fst := m, snd := s } { fst := m', snd := s' })","decl":"theorem liftOn₂_mk {α : Type*} (f : M × S → M × S → α)\n    (wd : ∀ (p q p' q' : M × S), p ≈ p' → q ≈ q' → f p q = f p' q') (m m' : M)\n    (s s' : S) : liftOn₂ (mk m s) (mk m' s') f wd = f ⟨m, s⟩ ⟨m', s'⟩ := by\n  convert Quotient.liftOn₂_mk f wd _ _\n\n"}
{"name":"LocalizedModule.subsingleton","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nh : Membership.mem S 0\n⊢ Subsingleton (LocalizedModule S M)","decl":"/-- If `S` contains `0` then the localization at `S` is trivial. -/\ntheorem subsingleton (h : 0 ∈ S) : Subsingleton (LocalizedModule S M) := by\n  refine ⟨fun a b ↦ ?_⟩\n  induction a,b using LocalizedModule.induction_on₂\n  exact mk_eq.mpr ⟨⟨0, h⟩, by simp only [Submonoid.mk_smul, zero_smul]⟩\n\n"}
{"name":"LocalizedModule.zero_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (LocalizedModule.mk 0 s) 0","decl":"@[simp]\ntheorem zero_mk (s : S) : mk (0 : M) s = 0 :=\n  mk_eq.mpr ⟨1, by rw [one_smul, smul_zero, smul_zero, one_smul]⟩\n\n"}
{"name":"LocalizedModule.mk_add_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm1 m2 : M\ns1 s2 : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (LocalizedModule.mk m1 s1) (LocalizedModule.mk m2 s2)) (LocalizedModule.mk (HAdd.hAdd (HSMul.hSMul s2 m1) (HSMul.hSMul s1 m2)) (HMul.hMul s1 s2))","decl":"theorem mk_add_mk {m1 m2 : M} {s1 s2 : S} :\n    mk m1 s1 + mk m2 s2 = mk (s2 • m1 + s1 • m2) (s1 * s2) :=\n  mk_eq.mpr <| ⟨1, rfl⟩\n\n"}
{"name":"LocalizedModule.mk_neg","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (LocalizedModule.mk (Neg.neg m) s) (Neg.neg (LocalizedModule.mk m s))","decl":"theorem mk_neg {M : Type*} [AddCommGroup M] [Module R M] {m : M} {s : S} : mk (-m) s = -mk m s :=\n  rfl\n\n"}
{"name":"LocalizedModule.mk_mul_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na₁ a₂ : A\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (LocalizedModule.mk a₁ s₁) (LocalizedModule.mk a₂ s₂)) (LocalizedModule.mk (HMul.hMul a₁ a₂) (HMul.hMul s₁ s₂))","decl":"theorem mk_mul_mk {A : Type*} [Semiring A] [Algebra R A] {a₁ a₂ : A} {s₁ s₂ : S} :\n    mk a₁ s₁ * mk a₂ s₂ = mk (a₁ * a₂) (s₁ * s₂) :=\n  rfl\n\n"}
{"name":"LocalizedModule.smul_def","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nT : Type u_1\ninst✝² : CommSemiring T\ninst✝¹ : Algebra R T\ninst✝ : IsLocalization S T\nx : T\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul x (LocalizedModule.mk m s)) (LocalizedModule.mk (HSMul.hSMul (IsLocalization.sec S x).1 m) (HMul.hMul (IsLocalization.sec S x).2 s))","decl":"theorem smul_def (x : T) (m : M) (s : S) :\n    x • mk m s = mk ((IsLocalization.sec S x).1 • m) ((IsLocalization.sec S x).2 * s) := rfl\n\n"}
{"name":"LocalizedModule.mk'_smul_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nT : Type u_1\ninst✝² : CommSemiring T\ninst✝¹ : Algebra R T\ninst✝ : IsLocalization S T\nr : R\nm : M\ns s' : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (IsLocalization.mk' T r s) (LocalizedModule.mk m s')) (LocalizedModule.mk (HSMul.hSMul r m) (HMul.hMul s s'))","decl":"theorem mk'_smul_mk (r : R) (m : M) (s s' : S) :\n    IsLocalization.mk' T r s • mk m s' = mk (r • m) (s * s') := by\n  rw [smul_def, mk_eq]\n  obtain ⟨c, hc⟩ := IsLocalization.eq.mp <| IsLocalization.mk'_sec T (IsLocalization.mk' T r s)\n  use c\n  simp_rw [← mul_smul, Submonoid.smul_def, Submonoid.coe_mul, ← mul_smul, ← mul_assoc,\n    mul_comm _ (s' : R), mul_assoc, hc]\n\n"}
{"name":"LocalizedModule.mk_smul_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nm : M\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (Localization.mk r s) (LocalizedModule.mk m t)) (LocalizedModule.mk (HSMul.hSMul r m) (HMul.hMul s t))","decl":"theorem mk_smul_mk (r : R) (m : M) (s t : S) :\n    Localization.mk r s • mk m t = mk (r • m) (s * t) := by\n  rw [Localization.mk_eq_mk']\n  exact mk'_smul_mk ..\n\n"}
{"name":"LocalizedModule.mk_cancel_common_left","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns' s : Subtype fun x => Membership.mem S x\nm : M\n⊢ Eq (LocalizedModule.mk (HSMul.hSMul s' m) (HMul.hMul s' s)) (LocalizedModule.mk m s)","decl":"@[simp]\ntheorem mk_cancel_common_left (s' s : S) (m : M) : mk (s' • m) (s' * s) = mk m s :=\n  mk_eq.mpr\n    ⟨1, by\n      simp only [mul_smul, one_smul]\n      rw [smul_comm]⟩\n\n"}
{"name":"LocalizedModule.mk_cancel","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Subtype fun x => Membership.mem S x\nm : M\n⊢ Eq (LocalizedModule.mk (HSMul.hSMul s m) s) (LocalizedModule.mk m 1)","decl":"@[simp]\ntheorem mk_cancel (s : S) (m : M) : mk (s • m) s = mk m 1 :=\n  mk_eq.mpr ⟨1, by simp⟩\n\n"}
{"name":"LocalizedModule.mk_cancel_common_right","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns s' : Subtype fun x => Membership.mem S x\nm : M\n⊢ Eq (LocalizedModule.mk (HSMul.hSMul s' m) (HMul.hMul s s')) (LocalizedModule.mk m s)","decl":"@[simp]\ntheorem mk_cancel_common_right (s s' : S) (m : M) : mk (s' • m) (s * s') = mk m s :=\n  mk_eq.mpr ⟨1, by simp [mul_smul]⟩\n\n"}
{"name":"LocalizedModule.smul'_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\ns : Subtype fun x => Membership.mem S x\nm : M\n⊢ Eq (HSMul.hSMul r (LocalizedModule.mk m s)) (LocalizedModule.mk (HSMul.hSMul r m) s)","decl":"theorem smul'_mk (r : R) (s : S) (m : M) : r • mk m s = mk (r • m) s := by\n  erw [mk_smul_mk r m 1 s]\n  rw [one_mul]\n\n"}
{"name":"LocalizedModule.smul_eq_iff_of_mem","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nhr : Membership.mem S r\nx y : LocalizedModule S M\n⊢ Iff (Eq (HSMul.hSMul r x) y) (Eq x (HSMul.hSMul (Localization.mk 1 ⟨r, hr⟩) y))","decl":"lemma smul_eq_iff_of_mem\n    (r : R) (hr : r ∈ S) (x y : LocalizedModule S M) :\n    r • x = y ↔ x = Localization.mk 1 ⟨r, hr⟩ • y := by\n  induction x using induction_on with\n  | h m s =>\n    induction y using induction_on with\n    | h n t =>\n      rw [smul'_mk, mk_smul_mk, one_smul, mk_eq, mk_eq]\n      simp only [Subtype.exists, Submonoid.mk_smul, exists_prop]\n      fconstructor\n      · rintro ⟨a, ha, eq1⟩\n        refine ⟨a, ha, ?_⟩\n        rw [mul_smul, ← eq1, Submonoid.mk_smul, smul_comm r t]\n      · rintro ⟨a, ha, eq1⟩\n        refine ⟨a, ha, ?_⟩\n        rw [← eq1, mul_comm, mul_smul, Submonoid.mk_smul, Submonoid.smul_def, Submonoid.mk_smul]\n\n"}
{"name":"LocalizedModule.eq_zero_of_smul_eq_zero","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nr : R\nhr : Membership.mem S r\nx : LocalizedModule S M\nhx : Eq (HSMul.hSMul r x) 0\n⊢ Eq x 0","decl":"lemma eq_zero_of_smul_eq_zero\n    (r : R) (hr : r ∈ S) (x : LocalizedModule S M) (hx : r • x = 0) : x = 0 := by\n  rw [smul_eq_iff_of_mem (hr := hr)] at hx\n  rw [hx, smul_zero]\n\n"}
{"name":"LocalizedModule.smul'_mul","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nT : Type u_1\ninst✝⁴ : CommSemiring T\ninst✝³ : Algebra R T\ninst✝² : IsLocalization S T\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : T\np₁ p₂ : LocalizedModule S A\n⊢ Eq (HMul.hMul (HSMul.hSMul x p₁) p₂) (HSMul.hSMul x (HMul.hMul p₁ p₂))","decl":"theorem smul'_mul {A : Type*} [Semiring A] [Algebra R A] (x : T) (p₁ p₂ : LocalizedModule S A) :\n    x • p₁ * p₂ = x • (p₁ * p₂) := by\n  induction p₁, p₂ using induction_on₂ with | _ a₁ s₁ a₂ s₂ => _\n  rw [mk_mul_mk, smul_def, smul_def, mk_mul_mk, mul_assoc, smul_mul_assoc]\n\n"}
{"name":"LocalizedModule.mul_smul'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nT : Type u_1\ninst✝⁴ : CommSemiring T\ninst✝³ : Algebra R T\ninst✝² : IsLocalization S T\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : T\np₁ p₂ : LocalizedModule S A\n⊢ Eq (HMul.hMul p₁ (HSMul.hSMul x p₂)) (HSMul.hSMul x (HMul.hMul p₁ p₂))","decl":"theorem mul_smul' {A : Type*} [Semiring A] [Algebra R A] (x : T) (p₁ p₂ : LocalizedModule S A) :\n    p₁ * x • p₂ = x • (p₁ * p₂) := by\n  induction p₁, p₂ using induction_on₂ with | _ a₁ s₁ a₂ s₂ => _\n  rw [smul_def, mk_mul_mk, mk_mul_mk, smul_def, mul_left_comm, mul_smul_comm]\n\n"}
{"name":"LocalizedModule.algebraMap_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nT : Type u_1\ninst✝⁴ : CommSemiring T\ninst✝³ : Algebra R T\ninst✝² : IsLocalization S T\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((algebraMap T (LocalizedModule S A)) (IsLocalization.mk' T a s)) (LocalizedModule.mk ((algebraMap R A) a) s)","decl":"theorem algebraMap_mk' {A : Type*} [Semiring A] [Algebra R A] (a : R) (s : S) :\n    algebraMap _ _ (IsLocalization.mk' T a s) = mk (algebraMap R A a) s := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  change _ • mk _ _ = _\n  rw [mk'_smul_mk, Algebra.algebraMap_eq_smul_one, mul_one]\n\n"}
{"name":"LocalizedModule.algebraMap_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nA : Type u_2\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\na : R\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((algebraMap (Localization S) (LocalizedModule S A)) (Localization.mk a s)) (LocalizedModule.mk ((algebraMap R A) a) s)","decl":"theorem algebraMap_mk {A : Type*} [Semiring A] [Algebra R A] (a : R) (s : S) :\n    algebraMap _ _ (Localization.mk a s) = mk (algebraMap R A a) s := by\n  rw [Localization.mk_eq_mk']\n  exact algebraMap_mk' ..\n\n"}
{"name":"LocalizedModule.instIsScalarTower","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nT : Type u_1\ninst✝² : CommSemiring T\ninst✝¹ : Algebra R T\ninst✝ : IsLocalization S T\n⊢ IsScalarTower R T (LocalizedModule S M)","decl":"instance : IsScalarTower R T (LocalizedModule S M) where\n  smul_assoc r x p := by\n    induction' p with m s\n    rw [← IsLocalization.mk'_sec (M := S) T x, IsLocalization.smul_mk', mk'_smul_mk, mk'_smul_mk,\n      smul'_mk, mul_smul]\n\n"}
{"name":"LocalizedModule.mkLinearMap_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nm : M\n⊢ Eq ((LocalizedModule.mkLinearMap S M) m) (LocalizedModule.mk m 1)","decl":"/-- The function `m ↦ m / 1` as an `R`-linear map.\n-/\n@[simps]\ndef mkLinearMap : M →ₗ[R] LocalizedModule S M where\n  toFun m := mk m 1\n  map_add' x y := by simp [mk_add_mk]\n  map_smul' _ _ := (smul'_mk _ _ _).symm\n\n"}
{"name":"LocalizedModule.divBy_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Subtype fun x => Membership.mem S x\np : LocalizedModule S M\n⊢ Eq ((LocalizedModule.divBy s) p) (p.liftOn (fun p => LocalizedModule.mk p.1 (HMul.hMul p.2 s)) ⋯)","decl":"/-- For any `s : S`, there is an `R`-linear map given by `a/b ↦ a/(b*s)`.\n-/\n@[simps]\ndef divBy (s : S) : LocalizedModule S M →ₗ[R] LocalizedModule S M where\n  toFun p :=\n    p.liftOn (fun p => mk p.1 (p.2 * s)) fun ⟨a, b⟩ ⟨a', b'⟩ ⟨c, eq1⟩ =>\n      mk_eq.mpr ⟨c, by rw [mul_smul, mul_smul, smul_comm _ s, smul_comm _ s, eq1, smul_comm _ s,\n        smul_comm _ s]⟩\n  map_add' x y := by\n    refine x.induction_on₂ ?_ y\n    intro m₁ m₂ t₁ t₂\n    simp_rw [mk_add_mk, LocalizedModule.liftOn_mk, mk_add_mk, mul_smul, mul_comm _ s, mul_assoc,\n      smul_comm _ s, ← smul_add, mul_left_comm s t₁ t₂, mk_cancel_common_left s]\n  map_smul' r x := by\n    refine x.induction_on (fun _ _ ↦ ?_)\n    dsimp only\n    change liftOn (mk _ _) _ _ = r • (liftOn (mk _ _) _ _)\n    simp_rw [liftOn_mk, mul_assoc, ← smul_def]\n    congr!\n\n"}
{"name":"LocalizedModule.divBy_mul_by","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Subtype fun x => Membership.mem S x\np : LocalizedModule S M\n⊢ Eq ((LocalizedModule.divBy s) (((algebraMap R (Module.End R (LocalizedModule S M))) ↑s) p)) p","decl":"theorem divBy_mul_by (s : S) (p : LocalizedModule S M) :\n    divBy s (algebraMap R (Module.End R (LocalizedModule S M)) s p) = p :=\n  p.induction_on fun m t => by\n    rw [Module.algebraMap_end_apply, divBy_apply]\n    erw [smul_def]\n    rw [LocalizedModule.liftOn_mk, mul_assoc, ← smul_def]\n    erw [smul'_mk]\n    rw [← Submonoid.smul_def, mk_cancel_common_right _ s]\n\n"}
{"name":"LocalizedModule.mul_by_divBy","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type v\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Subtype fun x => Membership.mem S x\np : LocalizedModule S M\n⊢ Eq (((algebraMap R (Module.End R (LocalizedModule S M))) ↑s) ((LocalizedModule.divBy s) p)) p","decl":"theorem mul_by_divBy (s : S) (p : LocalizedModule S M) :\n    algebraMap R (Module.End R (LocalizedModule S M)) s (divBy s p) = p :=\n  p.induction_on fun m t => by\n    rw [divBy_apply, Module.algebraMap_end_apply, LocalizedModule.liftOn_mk, smul'_mk,\n      ← Submonoid.smul_def, mk_cancel_common_right _ s]\n\n"}
{"name":"IsLocalizedModule.surj'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nself : IsLocalizedModule S f\ny : M'\n⊢ Exists fun x => Eq (HSMul.hSMul x.2 y) (f x.1)","decl":"/-- The characteristic predicate for localized module.\n`IsLocalizedModule S f` describes that `f : M ⟶ M'` is the localization map identifying `M'` as\n`LocalizedModule S M`.\n-/\n@[mk_iff] class IsLocalizedModule : Prop where\n  map_units : ∀ x : S, IsUnit (algebraMap R (Module.End R M') x)\n  surj' : ∀ y : M', ∃ x : M × S, x.2 • y = f x.1\n  exists_of_eq : ∀ {x₁ x₂}, f x₁ = f x₂ → ∃ c : S, c • x₁ = c • x₂\n\n"}
{"name":"isLocalizedModule_iff","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\n⊢ Iff (IsLocalizedModule S f) (And (∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M')) ↑x)) (And (∀ (y : M'), Exists fun x => Eq (HSMul.hSMul x.2 y) (f x.1)) (∀ {x₁ x₂ : M}, Eq (f x₁) (f x₂) → Exists fun c => Eq (HSMul.hSMul c x₁) (HSMul.hSMul c x₂))))","decl":"/-- The characteristic predicate for localized module.\n`IsLocalizedModule S f` describes that `f : M ⟶ M'` is the localization map identifying `M'` as\n`LocalizedModule S M`.\n-/\n@[mk_iff] class IsLocalizedModule : Prop where\n  map_units : ∀ x : S, IsUnit (algebraMap R (Module.End R M') x)\n  surj' : ∀ y : M', ∃ x : M × S, x.2 • y = f x.1\n  exists_of_eq : ∀ {x₁ x₂}, f x₁ = f x₂ → ∃ c : S, c • x₁ = c • x₂\n\n"}
{"name":"IsLocalizedModule.exists_of_eq","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nself : IsLocalizedModule S f\nx₁ x₂ : M\na✝ : Eq (f x₁) (f x₂)\n⊢ Exists fun c => Eq (HSMul.hSMul c x₁) (HSMul.hSMul c x₂)","decl":"/-- The characteristic predicate for localized module.\n`IsLocalizedModule S f` describes that `f : M ⟶ M'` is the localization map identifying `M'` as\n`LocalizedModule S M`.\n-/\n@[mk_iff] class IsLocalizedModule : Prop where\n  map_units : ∀ x : S, IsUnit (algebraMap R (Module.End R M') x)\n  surj' : ∀ y : M', ∃ x : M × S, x.2 • y = f x.1\n  exists_of_eq : ∀ {x₁ x₂}, f x₁ = f x₂ → ∃ c : S, c • x₁ = c • x₂\n\n"}
{"name":"IsLocalizedModule.map_units","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M M'\nself : IsLocalizedModule S f\nx : Subtype fun x => Membership.mem S x\n⊢ IsUnit ((algebraMap R (Module.End R M')) ↑x)","decl":"/-- The characteristic predicate for localized module.\n`IsLocalizedModule S f` describes that `f : M ⟶ M'` is the localization map identifying `M'` as\n`LocalizedModule S M`.\n-/\n@[mk_iff] class IsLocalizedModule : Prop where\n  map_units : ∀ x : S, IsUnit (algebraMap R (Module.End R M') x)\n  surj' : ∀ y : M', ∃ x : M × S, x.2 • y = f x.1\n  exists_of_eq : ∀ {x₁ x₂}, f x₁ = f x₂ → ∃ c : S, c • x₁ = c • x₂\n\n"}
{"name":"IsLocalizedModule.surj","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ny : M'\n⊢ Exists fun x => Eq (HSMul.hSMul x.2 y) (f x.1)","decl":"lemma IsLocalizedModule.surj [IsLocalizedModule S f] (y : M') : ∃ x : M × S, x.2 • y = f x.1 :=\n  surj' y\n\n-- Porting note: Manually added to make `S` and `f` explicit.\n"}
{"name":"IsLocalizedModule.eq_iff_exists","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nx₁ x₂ : M\n⊢ Iff (Eq (f x₁) (f x₂)) (Exists fun c => Eq (HSMul.hSMul c x₁) (HSMul.hSMul c x₂))","decl":"lemma IsLocalizedModule.eq_iff_exists [IsLocalizedModule S f] {x₁ x₂} :\n    f x₁ = f x₂ ↔ ∃ c : S, c • x₁ = c • x₂ :=\n  Iff.intro exists_of_eq fun ⟨c, h⟩ ↦ by\n    apply_fun f at h\n    simp_rw [f.map_smul_of_tower, Submonoid.smul_def, ← Module.algebraMap_end_apply R R] at h\n    exact ((Module.End_isUnit_iff _).mp <| map_units f c).1 h\n\n"}
{"name":"IsLocalizedModule.of_linearEquiv","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : AddCommMonoid M''\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ne : LinearEquiv (RingHom.id R) M' M''\nhf : IsLocalizedModule S f\n⊢ IsLocalizedModule S ((↑e).comp f)","decl":"instance IsLocalizedModule.of_linearEquiv (e : M' ≃ₗ[R] M'') [hf : IsLocalizedModule S f] :\n    IsLocalizedModule S (e ∘ₗ f : M →ₗ[R] M'') where\n  map_units s := by\n    rw [show algebraMap R (Module.End R M'') s = e ∘ₗ (algebraMap R (Module.End R M') s) ∘ₗ e.symm\n      by ext; simp, Module.End_isUnit_iff, LinearMap.coe_comp, LinearMap.coe_comp,\n      LinearEquiv.coe_coe, LinearEquiv.coe_coe, EquivLike.comp_bijective, EquivLike.bijective_comp]\n    exact (Module.End_isUnit_iff _).mp <| hf.map_units s\n  surj' x := by\n    obtain ⟨p, h⟩ := hf.surj' (e.symm x)\n    exact ⟨p, by rw [LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply, ← e.congr_arg h,\n      Submonoid.smul_def, Submonoid.smul_def, LinearEquiv.map_smul, LinearEquiv.apply_symm_apply]⟩\n  exists_of_eq h := by\n    simp_rw [LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply,\n      EmbeddingLike.apply_eq_iff_eq] at h\n    exact hf.exists_of_eq h\n\n"}
{"name":"IsLocalizedModule.of_linearEquiv_right","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : AddCommMonoid M''\ninst✝² : Module R M\ninst✝¹ : Module R M'\ninst✝ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ne : LinearEquiv (RingHom.id R) M'' M\nhf : IsLocalizedModule S f\n⊢ IsLocalizedModule S (f.comp ↑e)","decl":"instance IsLocalizedModule.of_linearEquiv_right (e : M'' ≃ₗ[R] M) [hf : IsLocalizedModule S f] :\n    IsLocalizedModule S (f ∘ₗ e : M'' →ₗ[R] M') where\n  map_units s := hf.map_units s\n  surj' x := by\n    obtain ⟨⟨p, s⟩, h⟩ := hf.surj' x\n    exact ⟨⟨e.symm p, s⟩, by simpa using h⟩\n  exists_of_eq h := by\n    simp_rw [LinearMap.coe_comp, LinearEquiv.coe_coe, Function.comp_apply] at h\n    obtain ⟨c, hc⟩ := hf.exists_of_eq h\n    exact ⟨c, by simpa only [Submonoid.smul_def, map_smul, e.symm_apply_apply]\n      using congr(e.symm $hc)⟩\n\n"}
{"name":"isLocalizedModule_id","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nR' : Type u_6\ninst✝⁴ : CommSemiring R'\ninst✝³ : Algebra R R'\ninst✝² : IsLocalization S R'\ninst✝¹ : Module R' M\ninst✝ : IsScalarTower R R' M\n⊢ IsLocalizedModule S LinearMap.id","decl":"variable (M) in\nlemma isLocalizedModule_id (R') [CommSemiring R'] [Algebra R R'] [IsLocalization S R'] [Module R' M]\n    [IsScalarTower R R' M] : IsLocalizedModule S (.id : M →ₗ[R] M) where\n  map_units s := by\n    rw [← (Algebra.lsmul R (A := R') R M).commutes]; exact (IsLocalization.map_units R' s).map _\n  surj' m := ⟨(m, 1), one_smul _ _⟩\n  exists_of_eq h := ⟨1, congr_arg _ h⟩\n\n"}
{"name":"LocalizedModule.lift'_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM'' : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M''\ninst✝¹ : Module R M\ninst✝ : Module R M''\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (LocalizedModule.lift' S g h (LocalizedModule.mk m s)) (↑(Inv.inv ⋯.unit) (g m))","decl":"theorem lift'_mk (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (m : M) (s : S) :\n    LocalizedModule.lift' S g h (LocalizedModule.mk m s) = (h s).unit⁻¹.val (g m) :=\n  rfl\n\n"}
{"name":"LocalizedModule.lift'_add","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM'' : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M''\ninst✝¹ : Module R M\ninst✝ : Module R M''\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nx y : LocalizedModule S M\n⊢ Eq (LocalizedModule.lift' S g h (HAdd.hAdd x y)) (HAdd.hAdd (LocalizedModule.lift' S g h x) (LocalizedModule.lift' S g h y))","decl":"theorem lift'_add (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (x y) :\n    LocalizedModule.lift' S g h (x + y) =\n      LocalizedModule.lift' S g h x + LocalizedModule.lift' S g h y :=\n  LocalizedModule.induction_on₂\n    (by\n      intro a a' b b'\n      rw [mk_add_mk, LocalizedModule.lift'_mk, LocalizedModule.lift'_mk, LocalizedModule.lift'_mk]\n      rw [map_add, Module.End_algebraMap_isUnit_inv_apply_eq_iff, smul_add, ← map_smul,\n        ← map_smul, ← map_smul]\n      congr 1 <;> symm\n      · rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff]\n        simp only [Submonoid.coe_mul, LinearMap.map_smul_of_tower]\n        rw [mul_smul, Submonoid.smul_def]\n      · dsimp\n        rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, mul_comm, mul_smul, ← map_smul]\n        rfl)\n    x y\n\n"}
{"name":"LocalizedModule.lift'_smul","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM'' : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M''\ninst✝¹ : Module R M\ninst✝ : Module R M''\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nr : R\nm : LocalizedModule S M\n⊢ Eq (HSMul.hSMul r (LocalizedModule.lift' S g h m)) (LocalizedModule.lift' S g h (HSMul.hSMul r m))","decl":"theorem lift'_smul (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (r : R) (m) : r • LocalizedModule.lift' S g h m = LocalizedModule.lift' S g h (r • m) :=\n  m.induction_on fun a b => by\n    rw [LocalizedModule.lift'_mk, LocalizedModule.smul'_mk, LocalizedModule.lift'_mk]\n    -- Porting note: We remove `generalize_proofs h1 h2`. This does nothing here.\n    rw [← map_smul, ← g.map_smul]\n\n"}
{"name":"LocalizedModule.lift_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM'' : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M''\ninst✝¹ : Module R M\ninst✝ : Module R M''\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((LocalizedModule.lift S g h) (LocalizedModule.mk m s)) (↑(Inv.inv ⋯.unit) (g m))","decl":"/--\nIf `g` is a linear map `M → M''` such that all scalar multiplication by `s : S` is invertible, then\n`lift g m s = s⁻¹ • g m`.\n-/\ntheorem lift_mk\n    (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit (algebraMap R (Module.End R M'') x)) (m : M) (s : S) :\n    LocalizedModule.lift S g h (LocalizedModule.mk m s) = (h s).unit⁻¹.val (g m) :=\n  rfl\n\n"}
{"name":"LocalizedModule.lift_comp","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM'' : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M''\ninst✝¹ : Module R M\ninst✝ : Module R M''\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\n⊢ Eq ((LocalizedModule.lift S g h).comp (LocalizedModule.mkLinearMap S M)) g","decl":"/--\nIf `g` is a linear map `M → M''` such that all scalar multiplication by `s : S` is invertible, then\nthere is a linear map `lift g ∘ mkLinearMap = g`.\n-/\ntheorem lift_comp (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) :\n    (lift S g h).comp (mkLinearMap S M) = g := by\n  ext x\n  simp [LocalizedModule.lift_mk]\n\n"}
{"name":"LocalizedModule.lift_unique","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM'' : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : AddCommMonoid M''\ninst✝¹ : Module R M\ninst✝ : Module R M''\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nl : LinearMap (RingHom.id R) (LocalizedModule S M) M''\nhl : Eq (l.comp (LocalizedModule.mkLinearMap S M)) g\n⊢ Eq (LocalizedModule.lift S g h) l","decl":"/--\nIf `g` is a linear map `M → M''` such that all scalar multiplication by `s : S` is invertible and\n`l` is another linear map `LocalizedModule S M ⟶ M''` such that `l ∘ mkLinearMap = g` then\n`l = lift g`\n-/\ntheorem lift_unique (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (l : LocalizedModule S M →ₗ[R] M'') (hl : l.comp (LocalizedModule.mkLinearMap S M) = g) :\n    LocalizedModule.lift S g h = l := by\n  ext x; induction' x with m s\n  rw [LocalizedModule.lift_mk]\n  rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, ← hl, LinearMap.coe_comp,\n    Function.comp_apply, LocalizedModule.mkLinearMap_apply, ← l.map_smul, LocalizedModule.smul'_mk]\n  congr 1; rw [LocalizedModule.mk_eq]\n  refine ⟨1, ?_⟩; simp only [one_smul, Submonoid.smul_def]\n\n"}
{"name":"localizedModuleIsLocalizedModule","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ IsLocalizedModule S (LocalizedModule.mkLinearMap S M)","decl":"instance localizedModuleIsLocalizedModule :\n    IsLocalizedModule S (LocalizedModule.mkLinearMap S M) where\n  map_units s :=\n    ⟨⟨algebraMap R (Module.End R (LocalizedModule S M)) s, LocalizedModule.divBy s,\n        DFunLike.ext _ _ <| LocalizedModule.mul_by_divBy s,\n        DFunLike.ext _ _ <| LocalizedModule.divBy_mul_by s⟩,\n      DFunLike.ext _ _ fun p =>\n        p.induction_on <| by\n          intros\n          rfl⟩\n  surj' p :=\n    p.induction_on fun m t => by\n      refine ⟨⟨m, t⟩, ?_⟩\n      rw [Submonoid.smul_def, LocalizedModule.smul'_mk, LocalizedModule.mkLinearMap_apply,\n        ← Submonoid.smul_def, LocalizedModule.mk_cancel t]\n  exists_of_eq eq1 := by simpa only [eq_comm, one_smul] using LocalizedModule.mk_eq.mp eq1\n\n"}
{"name":"IsLocalizedModule.of_restrictScalars","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nM : Type u_2\ninst✝¹⁰ : AddCommMonoid M\nA : Type u_5\ninst✝⁹ : CommSemiring A\ninst✝⁸ : Algebra R A\ninst✝⁷ : Module R M\nS : Submonoid R\nN : Type u_6\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\ninst✝⁴ : Module A M\ninst✝³ : Module A N\ninst✝² : IsScalarTower R A M\ninst✝¹ : IsScalarTower R A N\nf : LinearMap (RingHom.id A) M N\ninst✝ : IsLocalizedModule S (↑R f)\n⊢ IsLocalizedModule (Algebra.algebraMapSubmonoid A S) f","decl":"lemma IsLocalizedModule.of_restrictScalars (S : Submonoid R)\n    {N : Type*} [AddCommGroup N] [Module R N] [Module A M] [Module A N]\n    [IsScalarTower R A M] [IsScalarTower R A N]\n    (f : M →ₗ[A] N) [IsLocalizedModule S (f.restrictScalars R)] :\n    IsLocalizedModule (Algebra.algebraMapSubmonoid A S) f where\n  map_units x := by\n    obtain ⟨_, x, hx, rfl⟩ := x\n    have := IsLocalizedModule.map_units (f.restrictScalars R) ⟨x, hx⟩\n    simp only [← IsScalarTower.algebraMap_apply, Module.End_isUnit_iff] at this ⊢\n    exact this\n  surj' y := by\n    obtain ⟨⟨x, t⟩, e⟩ := IsLocalizedModule.surj S (f.restrictScalars R) y\n    exact ⟨⟨x, ⟨_, t, t.2, rfl⟩⟩, by simpa [Submonoid.smul_def] using e⟩\n  exists_of_eq {x₁ x₂} e := by\n    obtain ⟨c, hc⟩ := IsLocalizedModule.exists_of_eq (S := S) (f := f.restrictScalars R) e\n    refine ⟨⟨_, c, c.2, rfl⟩, by simpa [Submonoid.smul_def]⟩\n\n"}
{"name":"IsLocalizedModule.of_exists_mul_mem","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nM : Type u_2\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nN : Type u_6\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nS T : Submonoid R\nh : LE.le S T\nh' : ∀ (x : Subtype fun x => Membership.mem T x), Exists fun m => Membership.mem S (HMul.hMul m ↑x)\nf : LinearMap (RingHom.id R) M N\ninst✝ : IsLocalizedModule S f\n⊢ IsLocalizedModule T f","decl":"lemma IsLocalizedModule.of_exists_mul_mem {N : Type*} [AddCommGroup N] [Module R N]\n    (S T : Submonoid R) (h : S ≤ T) (h' : ∀ x : T, ∃ m : R, m * x ∈ S)\n    (f : M →ₗ[R] N) [IsLocalizedModule S f] :\n    IsLocalizedModule T f where\n  map_units x := by\n    obtain ⟨m, mx⟩ := h' x\n    have := IsLocalizedModule.map_units f ⟨_, mx⟩\n    rw [map_mul, (Algebra.commute_algebraMap_left _ _).isUnit_mul_iff] at this\n    exact this.2\n  surj' y := by\n    obtain ⟨⟨x, t⟩, e⟩ := IsLocalizedModule.surj S f y\n    exact ⟨⟨x, ⟨t, h t.2⟩⟩, e⟩\n  exists_of_eq {x₁ x₂} e := by\n    obtain ⟨c, hc⟩ := IsLocalizedModule.exists_of_eq (S := S) (f := f) e\n    exact ⟨⟨c, h c.2⟩, hc⟩\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule'_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.fromLocalizedModule' S f (LocalizedModule.mk m s)) (↑(Inv.inv ⋯.unit) (f m))","decl":"@[simp]\ntheorem fromLocalizedModule'_mk (m : M) (s : S) :\n    fromLocalizedModule' S f (LocalizedModule.mk m s) =\n      (IsLocalizedModule.map_units f s).unit⁻¹.val (f m) :=\n  rfl\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule'_add","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nx y : LocalizedModule S M\n⊢ Eq (IsLocalizedModule.fromLocalizedModule' S f (HAdd.hAdd x y)) (HAdd.hAdd (IsLocalizedModule.fromLocalizedModule' S f x) (IsLocalizedModule.fromLocalizedModule' S f y))","decl":"theorem fromLocalizedModule'_add (x y : LocalizedModule S M) :\n    fromLocalizedModule' S f (x + y) = fromLocalizedModule' S f x + fromLocalizedModule' S f y :=\n  LocalizedModule.induction_on₂\n    (by\n      intro a a' b b'\n      simp only [LocalizedModule.mk_add_mk, fromLocalizedModule'_mk]\n      -- Porting note: We remove `generalize_proofs h1 h2 h3`.\n      rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, smul_add, ← map_smul, ← map_smul,\n        ← map_smul, map_add]\n      congr 1\n      all_goals rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff']\n      · simp [mul_smul, Submonoid.smul_def]\n      · rw [Submonoid.coe_mul, LinearMap.map_smul_of_tower, mul_comm, mul_smul, Submonoid.smul_def])\n    x y\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule'_smul","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nr : R\nx : LocalizedModule S M\n⊢ Eq (HSMul.hSMul r (IsLocalizedModule.fromLocalizedModule' S f x)) (IsLocalizedModule.fromLocalizedModule' S f (HSMul.hSMul r x))","decl":"theorem fromLocalizedModule'_smul (r : R) (x : LocalizedModule S M) :\n    r • fromLocalizedModule' S f x = fromLocalizedModule' S f (r • x) :=\n  LocalizedModule.induction_on\n    (by\n      intro a b\n      rw [fromLocalizedModule'_mk, LocalizedModule.smul'_mk, fromLocalizedModule'_mk]\n      -- Porting note: We remove `generalize_proofs h1`.\n      rw [f.map_smul, map_smul])\n    x\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((IsLocalizedModule.fromLocalizedModule S f) (LocalizedModule.mk m s)) (↑(Inv.inv ⋯.unit) (f m))","decl":"theorem fromLocalizedModule_mk (m : M) (s : S) :\n    fromLocalizedModule S f (LocalizedModule.mk m s) =\n      (IsLocalizedModule.map_units f s).unit⁻¹.val (f m) :=\n  rfl\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule.inj","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ Function.Injective ⇑(IsLocalizedModule.fromLocalizedModule S f)","decl":"theorem fromLocalizedModule.inj : Function.Injective <| fromLocalizedModule S f := fun x y eq1 => by\n  induction' x with a b\n  induction' y with a' b'\n  simp only [fromLocalizedModule_mk] at eq1\n  -- Porting note: We remove `generalize_proofs h1 h2`.\n  rw [Module.End_algebraMap_isUnit_inv_apply_eq_iff, ← LinearMap.map_smul,\n    Module.End_algebraMap_isUnit_inv_apply_eq_iff'] at eq1\n  rw [LocalizedModule.mk_eq, ← IsLocalizedModule.eq_iff_exists S f, Submonoid.smul_def,\n    Submonoid.smul_def, f.map_smul, f.map_smul, eq1]\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule.surj","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ Function.Surjective ⇑(IsLocalizedModule.fromLocalizedModule S f)","decl":"theorem fromLocalizedModule.surj : Function.Surjective <| fromLocalizedModule S f := fun x =>\n  let ⟨⟨m, s⟩, eq1⟩ := IsLocalizedModule.surj S f x\n  ⟨LocalizedModule.mk m s, by\n    rw [fromLocalizedModule_mk, Module.End_algebraMap_isUnit_inv_apply_eq_iff, ← eq1,\n      Submonoid.smul_def]⟩\n\n"}
{"name":"IsLocalizedModule.fromLocalizedModule.bij","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ Function.Bijective ⇑(IsLocalizedModule.fromLocalizedModule S f)","decl":"theorem fromLocalizedModule.bij : Function.Bijective <| fromLocalizedModule S f :=\n  ⟨fromLocalizedModule.inj _ _, fromLocalizedModule.surj _ _⟩\n\n"}
{"name":"IsLocalizedModule.iso_symm_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\na✝ : M'\n⊢ Eq ((IsLocalizedModule.iso S f).symm a✝) ((Equiv.ofBijective ⇑(IsLocalizedModule.fromLocalizedModule S f) ⋯).symm a✝)","decl":"/--\nIf `(M', f : M ⟶ M')` satisfies universal property of localized module, then `M'` is isomorphic to\n`LocalizedModule S M` as an `R`-module.\n-/\n@[simps!]\nnoncomputable def iso : LocalizedModule S M ≃ₗ[R] M' :=\n  { fromLocalizedModule S f,\n    Equiv.ofBijective (fromLocalizedModule S f) <| fromLocalizedModule.bij _ _ with }\n\n"}
{"name":"IsLocalizedModule.iso_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\na✝ : LocalizedModule S M\n⊢ Eq ((IsLocalizedModule.iso S f) a✝) (IsLocalizedModule.fromLocalizedModule' S f a✝)","decl":"/--\nIf `(M', f : M ⟶ M')` satisfies universal property of localized module, then `M'` is isomorphic to\n`LocalizedModule S M` as an `R`-module.\n-/\n@[simps!]\nnoncomputable def iso : LocalizedModule S M ≃ₗ[R] M' :=\n  { fromLocalizedModule S f,\n    Equiv.ofBijective (fromLocalizedModule S f) <| fromLocalizedModule.bij _ _ with }\n\n"}
{"name":"IsLocalizedModule.iso_apply_mk","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq ((IsLocalizedModule.iso S f) (LocalizedModule.mk m s)) (↑(Inv.inv ⋯.unit) (f m))","decl":"theorem iso_apply_mk (m : M) (s : S) :\n    iso S f (LocalizedModule.mk m s) = (IsLocalizedModule.map_units f s).unit⁻¹.val (f m) :=\n  rfl\n\n"}
{"name":"IsLocalizedModule.iso_symm_apply_aux","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M'\n⊢ Eq ((IsLocalizedModule.iso S f).symm m) (LocalizedModule.mk ⋯.choose.1 ⋯.choose.2)","decl":"theorem iso_symm_apply_aux (m : M') :\n    (iso S f).symm m =\n      LocalizedModule.mk (IsLocalizedModule.surj S f m).choose.1\n        (IsLocalizedModule.surj S f m).choose.2 := by\n  -- Porting note: We remove `generalize_proofs _ h2`.\n  apply_fun iso S f using LinearEquiv.injective (iso S f)\n  rw [LinearEquiv.apply_symm_apply]\n  simp only [iso_apply, LinearMap.toFun_eq_coe, fromLocalizedModule_mk]\n  rw [fromLocalizedModule'_mk, Module.End_algebraMap_isUnit_inv_apply_eq_iff', ← Submonoid.smul_def,\n    (surj' _).choose_spec]\n\n"}
{"name":"IsLocalizedModule.iso_symm_apply'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M'\na : M\nb : Subtype fun x => Membership.mem S x\neq1 : Eq (HSMul.hSMul b m) (f a)\n⊢ Eq ((IsLocalizedModule.iso S f).symm m) (LocalizedModule.mk a b)","decl":"theorem iso_symm_apply' (m : M') (a : M) (b : S) (eq1 : b • m = f a) :\n    (iso S f).symm m = LocalizedModule.mk a b :=\n  (iso_symm_apply_aux S f m).trans <|\n    LocalizedModule.mk_eq.mpr <| by\n      -- Porting note: We remove `generalize_proofs h1`.\n      rw [← IsLocalizedModule.eq_iff_exists S f, Submonoid.smul_def, Submonoid.smul_def, f.map_smul,\n        f.map_smul, ← (surj' _).choose_spec, ← Submonoid.smul_def, ← Submonoid.smul_def, ← mul_smul,\n        mul_comm, mul_smul, eq1]\n\n"}
{"name":"IsLocalizedModule.iso_symm_comp","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ Eq ((↑(IsLocalizedModule.iso S f).symm).comp f) (LocalizedModule.mkLinearMap S M)","decl":"theorem iso_symm_comp : (iso S f).symm.toLinearMap.comp f = LocalizedModule.mkLinearMap S M := by\n  ext m\n  rw [LinearMap.comp_apply, LocalizedModule.mkLinearMap_apply, LinearEquiv.coe_coe, iso_symm_apply']\n  exact one_smul _ _\n\n"}
{"name":"IsLocalizedModule.lift_comp","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\n⊢ Eq ((IsLocalizedModule.lift S f g h).comp f) g","decl":"theorem lift_comp (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x)) :\n    (lift S f g h).comp f = g := by\n  dsimp only [IsLocalizedModule.lift]\n  rw [LinearMap.comp_assoc, iso_symm_comp, LocalizedModule.lift_comp S g h]\n\n"}
{"name":"IsLocalizedModule.lift_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nx : M\n⊢ Eq ((IsLocalizedModule.lift S f g h) (f x)) (g x)","decl":"@[simp]\ntheorem lift_apply (g : M →ₗ[R] M'') (h) (x) :\n    lift S f g h (f x) = g x := LinearMap.congr_fun (lift_comp S f g h) x\n\n"}
{"name":"IsLocalizedModule.lift_unique","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ng : LinearMap (RingHom.id R) M M''\nh : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nl : LinearMap (RingHom.id R) M' M''\nhl : Eq (l.comp f) g\n⊢ Eq (IsLocalizedModule.lift S f g h) l","decl":"theorem lift_unique (g : M →ₗ[R] M'') (h : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    (l : M' →ₗ[R] M'') (hl : l.comp f = g) : lift S f g h = l := by\n  dsimp only [IsLocalizedModule.lift]\n  rw [LocalizedModule.lift_unique S g h (l.comp (iso S f).toLinearMap), LinearMap.comp_assoc,\n    LinearEquiv.comp_coe, LinearEquiv.symm_trans_self, LinearEquiv.refl_toLinearMap,\n    LinearMap.comp_id]\n  rw [LinearMap.comp_assoc, ← hl]\n  congr 1\n  ext x\n  rw [LinearMap.comp_apply, LocalizedModule.mkLinearMap_apply, LinearEquiv.coe_coe, iso_apply,\n    fromLocalizedModule'_mk, Module.End_algebraMap_isUnit_inv_apply_eq_iff, OneMemClass.coe_one,\n    one_smul]\n\n"}
{"name":"IsLocalizedModule.is_universal","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ng : LinearMap (RingHom.id R) M M''\nx✝ : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\n⊢ ExistsUnique fun l => Eq (l.comp f) g","decl":"/-- Universal property from localized module:\nIf `(M', f : M ⟶ M')` is a localized module then it satisfies the following universal property:\nFor every `R`-module `M''` which every `s : S`-scalar multiplication is invertible and for every\n`R`-linear map `g : M ⟶ M''`, there is a unique `R`-linear map `l : M' ⟶ M''` such that\n`l ∘ f = g`.\n```\nM -----f----> M'\n|           /\n|g       /\n|     /   l\nv   /\nM''\n```\n-/\ntheorem is_universal :\n    ∀ (g : M →ₗ[R] M'') (_ : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x)),\n      ∃! l : M' →ₗ[R] M'', l.comp f = g :=\n  fun g h => ⟨lift S f g h, lift_comp S f g h, fun l hl => (lift_unique S f g h l hl).symm⟩\n\n"}
{"name":"IsLocalizedModule.linearMap_ext","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN : Type u_6\nN' : Type u_7\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\ninst✝² : AddCommMonoid N'\ninst✝¹ : Module R N'\nf' : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S f'\ng g' : LinearMap (RingHom.id R) M' N'\nh : Eq (g.comp f) (g'.comp f)\n⊢ Eq g g'","decl":"theorem linearMap_ext {N N'} [AddCommMonoid N] [Module R N] [AddCommMonoid N'] [Module R N']\n    (f' : N →ₗ[R] N') [IsLocalizedModule S f'] ⦃g g' : M' →ₗ[R] N'⦄\n    (h : g ∘ₗ f = g' ∘ₗ f) : g = g' :=\n  (is_universal S f _ <| map_units f').unique h rfl\n\n"}
{"name":"IsLocalizedModule.ext","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nmap_unit : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nj k : LinearMap (RingHom.id R) M' M''\nh : Eq (j.comp f) (k.comp f)\n⊢ Eq j k","decl":"theorem ext (map_unit : ∀ x : S, IsUnit ((algebraMap R (Module.End R M'')) x))\n    ⦃j k : M' →ₗ[R] M''⦄ (h : j.comp f = k.comp f) : j = k := by\n  rw [← lift_unique S f (k.comp f) map_unit j h, lift_unique]\n  rfl\n\n"}
{"name":"IsLocalizedModule.ringHom_ext","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\nM'' : Type u_4\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : AddCommMonoid M''\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : Module R M''\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nmap_unit : ∀ (x : Subtype fun x => Membership.mem S x), IsUnit ((algebraMap R (Module.End R M'')) ↑x)\nj k : LinearMap (RingHom.id R) M' M''\nh : Eq (j.comp f) (k.comp f)\n⊢ Eq j k","decl":"@[deprecated (since := \"2024-12-07\")]\nalias ringHom_ext := ext\n\n"}
{"name":"IsLocalizedModule.smul_injective","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ns : Subtype fun x => Membership.mem S x\n⊢ Function.Injective fun m => HSMul.hSMul s m","decl":"include f in\ntheorem smul_injective (s : S) : Function.Injective fun m : M' => s • m :=\n  ((Module.End_isUnit_iff _).mp (IsLocalizedModule.map_units f s)).injective\n\n"}
{"name":"IsLocalizedModule.smul_inj","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ns : Subtype fun x => Membership.mem S x\nm₁ m₂ : M'\n⊢ Iff (Eq (HSMul.hSMul s m₁) (HSMul.hSMul s m₂)) (Eq m₁ m₂)","decl":"include f in\ntheorem smul_inj (s : S) (m₁ m₂ : M') : s • m₁ = s • m₂ ↔ m₁ = m₂ :=\n  (smul_injective f s).eq_iff\n\n"}
{"name":"IsLocalizedModule.mk'_smul","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nr : R\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (HSMul.hSMul r m) s) (HSMul.hSMul r (IsLocalizedModule.mk' f m s))","decl":"theorem mk'_smul (r : R) (m : M) (s : S) : mk' f (r • m) s = r • mk' f m s := by\n  delta mk'\n  rw [← LocalizedModule.smul'_mk, LinearMap.map_smul]\n\n"}
{"name":"IsLocalizedModule.mk'_add_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm₁ m₂ : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HAdd.hAdd (IsLocalizedModule.mk' f m₁ s₁) (IsLocalizedModule.mk' f m₂ s₂)) (IsLocalizedModule.mk' f (HAdd.hAdd (HSMul.hSMul s₂ m₁) (HSMul.hSMul s₁ m₂)) (HMul.hMul s₁ s₂))","decl":"theorem mk'_add_mk' (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ + mk' f m₂ s₂ = mk' f (s₂ • m₁ + s₁ • m₂) (s₁ * s₂) := by\n  delta mk'\n  rw [← map_add, LocalizedModule.mk_add_mk]\n\n"}
{"name":"IsLocalizedModule.mk'_zero","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f 0 s) 0","decl":"@[simp]\ntheorem mk'_zero (s : S) : mk' f 0 s = 0 := by rw [← zero_smul R (0 : M), mk'_smul, zero_smul]\n\n"}
{"name":"IsLocalizedModule.mk'_one","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\n⊢ Eq (IsLocalizedModule.mk' f m 1) (f m)","decl":"@[simp]\ntheorem mk'_one (m : M) : mk' f m (1 : S) = f m := by\n  delta mk'\n  rw [fromLocalizedModule_mk, Module.End_algebraMap_isUnit_inv_apply_eq_iff, Submonoid.coe_one,\n    one_smul]\n\n"}
{"name":"IsLocalizedModule.mk'_cancel","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (HSMul.hSMul s m) s) (f m)","decl":"@[simp]\ntheorem mk'_cancel (m : M) (s : S) : mk' f (s • m) s = f m := by\n  delta mk'\n  rw [LocalizedModule.mk_cancel, ← mk'_one S f, fromLocalizedModule_mk,\n    Module.End_algebraMap_isUnit_inv_apply_eq_iff, OneMemClass.coe_one, mk'_one, one_smul]\n\n"}
{"name":"IsLocalizedModule.mk'_cancel'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul s (IsLocalizedModule.mk' f m s)) (f m)","decl":"@[simp]\ntheorem mk'_cancel' (m : M) (s : S) : s • mk' f m s = f m := by\n  rw [Submonoid.smul_def, ← mk'_smul, ← Submonoid.smul_def, mk'_cancel]\n\n"}
{"name":"IsLocalizedModule.mk'_cancel_left","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (HSMul.hSMul s₁ m) (HMul.hMul s₁ s₂)) (IsLocalizedModule.mk' f m s₂)","decl":"@[simp]\ntheorem mk'_cancel_left (m : M) (s₁ s₂ : S) : mk' f (s₁ • m) (s₁ * s₂) = mk' f m s₂ := by\n  delta mk'\n  rw [LocalizedModule.mk_cancel_common_left]\n\n"}
{"name":"IsLocalizedModule.mk'_cancel_right","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (HSMul.hSMul s₂ m) (HMul.hMul s₁ s₂)) (IsLocalizedModule.mk' f m s₁)","decl":"@[simp]\ntheorem mk'_cancel_right (m : M) (s₁ s₂ : S) : mk' f (s₂ • m) (s₁ * s₂) = mk' f m s₁ := by\n  delta mk'\n  rw [LocalizedModule.mk_cancel_common_right]\n\n"}
{"name":"IsLocalizedModule.mk'_add","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm₁ m₂ : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (HAdd.hAdd m₁ m₂) s) (HAdd.hAdd (IsLocalizedModule.mk' f m₁ s) (IsLocalizedModule.mk' f m₂ s))","decl":"theorem mk'_add (m₁ m₂ : M) (s : S) : mk' f (m₁ + m₂) s = mk' f m₁ s + mk' f m₂ s := by\n  rw [mk'_add_mk', ← smul_add, mk'_cancel_left]\n\n"}
{"name":"IsLocalizedModule.mk'_eq_mk'_iff","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm₁ m₂ : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (IsLocalizedModule.mk' f m₁ s₁) (IsLocalizedModule.mk' f m₂ s₂)) (Exists fun s => Eq (HSMul.hSMul s (HSMul.hSMul s₁ m₂)) (HSMul.hSMul s (HSMul.hSMul s₂ m₁)))","decl":"theorem mk'_eq_mk'_iff (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ = mk' f m₂ s₂ ↔ ∃ s : S, s • s₁ • m₂ = s • s₂ • m₁ := by\n  delta mk'\n  rw [(fromLocalizedModule.inj S f).eq_iff, LocalizedModule.mk_eq]\n  simp_rw [eq_comm]\n\n"}
{"name":"IsLocalizedModule.mk'_neg","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (Neg.neg m) s) (Neg.neg (IsLocalizedModule.mk' f m s))","decl":"theorem mk'_neg {M M' : Type*} [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M']\n    (f : M →ₗ[R] M') [IsLocalizedModule S f] (m : M) (s : S) : mk' f (-m) s = -mk' f m s := by\n  delta mk'\n  rw [LocalizedModule.mk_neg, map_neg]\n\n"}
{"name":"IsLocalizedModule.mk'_sub","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm₁ m₂ : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (IsLocalizedModule.mk' f (HSub.hSub m₁ m₂) s) (HSub.hSub (IsLocalizedModule.mk' f m₁ s) (IsLocalizedModule.mk' f m₂ s))","decl":"theorem mk'_sub {M M' : Type*} [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M']\n    (f : M →ₗ[R] M') [IsLocalizedModule S f] (m₁ m₂ : M) (s : S) :\n    mk' f (m₁ - m₂) s = mk' f m₁ s - mk' f m₂ s := by\n  rw [sub_eq_add_neg, sub_eq_add_neg, mk'_add, mk'_neg]\n\n"}
{"name":"IsLocalizedModule.mk'_sub_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : AddCommGroup M\ninst✝³ : AddCommGroup M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm₁ m₂ : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HSub.hSub (IsLocalizedModule.mk' f m₁ s₁) (IsLocalizedModule.mk' f m₂ s₂)) (IsLocalizedModule.mk' f (HSub.hSub (HSMul.hSMul s₂ m₁) (HSMul.hSMul s₁ m₂)) (HMul.hMul s₁ s₂))","decl":"theorem mk'_sub_mk' {M M' : Type*} [AddCommGroup M] [AddCommGroup M'] [Module R M] [Module R M']\n    (f : M →ₗ[R] M') [IsLocalizedModule S f] (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ - mk' f m₂ s₂ = mk' f (s₂ • m₁ - s₁ • m₂) (s₁ * s₂) := by\n  rw [sub_eq_add_neg, ← mk'_neg, mk'_add_mk', smul_neg, ← sub_eq_add_neg]\n\n"}
{"name":"IsLocalizedModule.mk'_mul_mk'_of_map_mul","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring M\ninst✝³ : Semiring M'\ninst✝² : Module R M\ninst✝¹ : Algebra R M'\nf : LinearMap (RingHom.id R) M M'\nhf : ∀ (m₁ m₂ : M), Eq (f (HMul.hMul m₁ m₂)) (HMul.hMul (f m₁) (f m₂))\ninst✝ : IsLocalizedModule S f\nm₁ m₂ : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (IsLocalizedModule.mk' f m₁ s₁) (IsLocalizedModule.mk' f m₂ s₂)) (IsLocalizedModule.mk' f (HMul.hMul m₁ m₂) (HMul.hMul s₁ s₂))","decl":"theorem mk'_mul_mk'_of_map_mul {M M' : Type*} [Semiring M] [Semiring M'] [Module R M]\n    [Algebra R M'] (f : M →ₗ[R] M') (hf : ∀ m₁ m₂, f (m₁ * m₂) = f m₁ * f m₂)\n    [IsLocalizedModule S f] (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f m₁ s₁ * mk' f m₂ s₂ = mk' f (m₁ * m₂) (s₁ * s₂) := by\n  symm\n  apply (Module.End_algebraMap_isUnit_inv_apply_eq_iff _ _ _ _).mpr\n  simp_rw [Submonoid.coe_mul, ← smul_eq_mul]\n  rw [smul_smul_smul_comm, ← mk'_smul, ← mk'_smul]\n  simp_rw [← Submonoid.smul_def, mk'_cancel, smul_eq_mul, hf]\n\n"}
{"name":"IsLocalizedModule.mk'_mul_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring M\ninst✝³ : Semiring M'\ninst✝² : Algebra R M\ninst✝¹ : Algebra R M'\nf : AlgHom R M M'\ninst✝ : IsLocalizedModule S f.toLinearMap\nm₁ m₂ : M\ns₁ s₂ : Subtype fun x => Membership.mem S x\n⊢ Eq (HMul.hMul (IsLocalizedModule.mk' f.toLinearMap m₁ s₁) (IsLocalizedModule.mk' f.toLinearMap m₂ s₂)) (IsLocalizedModule.mk' f.toLinearMap (HMul.hMul m₁ m₂) (HMul.hMul s₁ s₂))","decl":"theorem mk'_mul_mk' {M M' : Type*} [Semiring M] [Semiring M'] [Algebra R M] [Algebra R M']\n    (f : M →ₐ[R] M') [IsLocalizedModule S f.toLinearMap] (m₁ m₂ : M) (s₁ s₂ : S) :\n    mk' f.toLinearMap m₁ s₁ * mk' f.toLinearMap m₂ s₂ = mk' f.toLinearMap (m₁ * m₂) (s₁ * s₂) :=\n  mk'_mul_mk'_of_map_mul f.toLinearMap (map_mul f) m₁ m₂ s₁ s₂\n\n"}
{"name":"IsLocalizedModule.mk'_eq_iff","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\nm' : M'\n⊢ Iff (Eq (IsLocalizedModule.mk' f m s) m') (Eq (f m) (HSMul.hSMul s m'))","decl":"theorem mk'_eq_iff {m : M} {s : S} {m' : M'} : mk' f m s = m' ↔ f m = s • m' := by\n  rw [← smul_inj f s, Submonoid.smul_def, ← mk'_smul, ← Submonoid.smul_def, mk'_cancel]\n\n"}
{"name":"IsLocalizedModule.mk'_eq_zero","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (IsLocalizedModule.mk' f m s) 0) (Eq (f m) 0)","decl":"@[simp]\ntheorem mk'_eq_zero {m : M} (s : S) : mk' f m s = 0 ↔ f m = 0 := by rw [mk'_eq_iff, smul_zero]\n\n"}
{"name":"IsLocalizedModule.mk'_eq_zero'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\ns : Subtype fun x => Membership.mem S x\n⊢ Iff (Eq (IsLocalizedModule.mk' f m s) 0) (Exists fun s' => Eq (HSMul.hSMul s' m) 0)","decl":"theorem mk'_eq_zero' {m : M} (s : S) : mk' f m s = 0 ↔ ∃ s' : S, s' • m = 0 := by\n  simp_rw [← mk'_zero f (1 : S), mk'_eq_mk'_iff, smul_zero, one_smul, eq_comm]\n\n"}
{"name":"IsLocalizedModule.mk_eq_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Subtype fun x => Membership.mem S x\nm : M\n⊢ Eq (LocalizedModule.mk m s) (IsLocalizedModule.mk' (LocalizedModule.mkLinearMap S M) m s)","decl":"theorem mk_eq_mk' (s : S) (m : M) :\n    LocalizedModule.mk m s = mk' (LocalizedModule.mkLinearMap S M) m s := by\n  rw [eq_comm, mk'_eq_iff, Submonoid.smul_def, LocalizedModule.smul'_mk, ← Submonoid.smul_def,\n    LocalizedModule.mk_cancel, LocalizedModule.mkLinearMap_apply]\n\n"}
{"name":"IsLocalizedModule.mk'_smul_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\nA : Type u_5\ninst✝⁷ : CommSemiring A\ninst✝⁶ : Algebra R A\ninst✝⁵ : Module A M'\ninst✝⁴ : IsLocalization S A\ninst✝³ : Module R M\ninst✝² : Module R M'\ninst✝¹ : IsScalarTower R A M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nx : R\nm : M\ns t : Subtype fun x => Membership.mem S x\n⊢ Eq (HSMul.hSMul (IsLocalization.mk' A x s) (IsLocalizedModule.mk' f m t)) (IsLocalizedModule.mk' f (HSMul.hSMul x m) (HMul.hMul s t))","decl":"variable (A) in\nlemma mk'_smul_mk' (x : R) (m : M) (s t : S) :\n    IsLocalization.mk' A x s • mk' f m t = mk' f (x • m) (s * t) := by\n  apply smul_injective f (s * t)\n  conv_lhs => simp only [smul_assoc, mul_smul, smul_comm t]\n  simp only [mk'_cancel', map_smul, Submonoid.smul_def s]\n  rw [← smul_assoc, IsLocalization.smul_mk'_self, algebraMap_smul]\n\n"}
{"name":"IsLocalizedModule.eq_zero_iff","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\nm : M\n⊢ Iff (Eq (f m) 0) (Exists fun s' => Eq (HSMul.hSMul s' m) 0)","decl":"theorem eq_zero_iff {m : M} : f m = 0 ↔ ∃ s' : S, s' • m = 0 :=\n  (mk'_eq_zero (1 : S)).symm.trans (mk'_eq_zero' f _)\n\n"}
{"name":"IsLocalizedModule.mk'_surjective","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ Function.Surjective (Function.uncurry (IsLocalizedModule.mk' f))","decl":"theorem mk'_surjective : Function.Surjective (Function.uncurry <| mk' f : M × S → M') := by\n  intro x\n  obtain ⟨⟨m, s⟩, e : s • x = f m⟩ := IsLocalizedModule.surj S f x\n  exact ⟨⟨m, s⟩, mk'_eq_iff.mpr e.symm⟩\n\n"}
{"name":"IsLocalizedModule.liftOfLE_comp","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₁ : Type u_7\nM₂ : Type u_6\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\nS₁ S₂ : Submonoid R\nh : LE.le S₁ S₂\nf₁ : LinearMap (RingHom.id R) M M₁\nf₂ : LinearMap (RingHom.id R) M M₂\ninst✝¹ : IsLocalizedModule S₁ f₁\ninst✝ : IsLocalizedModule S₂ f₂\n⊢ Eq ((IsLocalizedModule.liftOfLE S₁ S₂ h f₁ f₂).comp f₁) f₂","decl":"lemma liftOfLE_comp : (liftOfLE S₁ S₂ h f₁ f₂).comp f₁ = f₂ := lift_comp ..\n\n"}
{"name":"IsLocalizedModule.liftOfLE_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₁ : Type u_7\nM₂ : Type u_6\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\nS₁ S₂ : Submonoid R\nh : LE.le S₁ S₂\nf₁ : LinearMap (RingHom.id R) M M₁\nf₂ : LinearMap (RingHom.id R) M M₂\ninst✝¹ : IsLocalizedModule S₁ f₁\ninst✝ : IsLocalizedModule S₂ f₂\nx : M\n⊢ Eq ((IsLocalizedModule.liftOfLE S₁ S₂ h f₁ f₂) (f₁ x)) (f₂ x)","decl":"@[simp] lemma liftOfLE_apply (x) : liftOfLE S₁ S₂ h f₁ f₂ (f₁ x) = f₂ x := lift_apply ..\n\n"}
{"name":"IsLocalizedModule.liftOfLE_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₁ : Type u_7\nM₂ : Type u_6\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\nS₁ S₂ : Submonoid R\nh : LE.le S₁ S₂\nf₁ : LinearMap (RingHom.id R) M M₁\nf₂ : LinearMap (RingHom.id R) M M₂\ninst✝¹ : IsLocalizedModule S₁ f₁\ninst✝ : IsLocalizedModule S₂ f₂\nm : M\ns : Subtype fun x => Membership.mem S₁ x\n⊢ Eq ((IsLocalizedModule.liftOfLE S₁ S₂ h f₁ f₂) (IsLocalizedModule.mk' f₁ m s)) (IsLocalizedModule.mk' f₂ m ⟨↑s, ⋯⟩)","decl":"/-- The image of `m/s` under `liftOfLE` is `m/s`. -/\n@[simp]\nlemma liftOfLE_mk' (m : M) (s : S₁) :\n    liftOfLE S₁ S₂ h f₁ f₂ (mk' f₁ m s) = mk' f₂ m ⟨s.1, h s.2⟩ := by\n  apply ((Module.End_isUnit_iff _).mp (map_units f₂ ⟨s, h s.2⟩)).1\n  simp only [Module.algebraMap_end_apply, ← map_smul, ← Submonoid.smul_def, mk'_cancel']\n  rw [liftOfLE, lift_apply]\n  exact (mk'_cancel' (S := S₂) f₂ m ⟨s.1, h s.2⟩).symm\n\n"}
{"name":"IsLocalizedModule.instLiftOfLE","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM : Type u_2\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\nM₁ : Type u_6\nM₂ : Type u_7\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\nS₁ S₂ : Submonoid R\nh : LE.le S₁ S₂\nf₁ : LinearMap (RingHom.id R) M M₁\nf₂ : LinearMap (RingHom.id R) M M₂\ninst✝¹ : IsLocalizedModule S₁ f₁\ninst✝ : IsLocalizedModule S₂ f₂\n⊢ IsLocalizedModule S₂ (IsLocalizedModule.liftOfLE S₁ S₂ h f₁ f₂)","decl":"instance : IsLocalizedModule S₂ (liftOfLE S₁ S₂ h f₁ f₂) where\n  map_units := map_units f₂\n  surj' y := by\n    obtain ⟨⟨y', s⟩, e⟩ := IsLocalizedModule.surj S₂ f₂ y\n    exact ⟨⟨f₁ y', s⟩, by simpa⟩\n  exists_of_eq := by\n    intros x₁ x₂ e\n    obtain ⟨x₁, s₁, rfl⟩ := mk'_surjective S₁ f₁ x₁\n    obtain ⟨x₂, s₂, rfl⟩ := mk'_surjective S₁ f₁ x₂\n    simp only [Function.uncurry, liftOfLE_mk', mk'_eq_mk'_iff, Submonoid.mk_smul,\n      Submonoid.smul_def, ← mk'_smul] at e ⊢\n    obtain ⟨c, e⟩ := e\n    exact ⟨c, 1, by simpa [← smul_comm c.1]⟩\n\n"}
{"name":"IsLocalizedModule.map_comp","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN : Type u_6\nN' : Type u_7\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid N'\ninst✝² : Module R N\ninst✝¹ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S g\nh : LinearMap (RingHom.id R) M N\n⊢ Eq (((IsLocalizedModule.map S f g) h).comp f) (g.comp h)","decl":"lemma map_comp (h : M →ₗ[R] N) : (map S f g h) ∘ₗ f = g ∘ₗ h :=\n  lift_comp S f (g ∘ₗ h) (IsLocalizedModule.map_units g)\n\n"}
{"name":"IsLocalizedModule.map_apply","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN : Type u_6\nN' : Type u_7\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid N'\ninst✝² : Module R N\ninst✝¹ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S g\nh : LinearMap (RingHom.id R) M N\nx : M\n⊢ Eq (((IsLocalizedModule.map S f g) h) (f x)) (g (h x))","decl":"@[simp]\nlemma map_apply (h : M →ₗ[R] N) (x) : map S f g h (f x) = g (h x) :=\n  lift_apply S f (g ∘ₗ h) (IsLocalizedModule.map_units g) x\n\n"}
{"name":"IsLocalizedModule.map_mk'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN : Type u_6\nN' : Type u_7\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid N'\ninst✝² : Module R N\ninst✝¹ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S g\nh : LinearMap (RingHom.id R) M N\nx : M\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (((IsLocalizedModule.map S f g) h) (IsLocalizedModule.mk' f x s)) (IsLocalizedModule.mk' g (h x) s)","decl":"@[simp]\nlemma map_mk' (h : M →ₗ[R] N) (x) (s : S) :\n    map S f g h (IsLocalizedModule.mk' f x s) = (IsLocalizedModule.mk' g (h x) s) := by\n  simp only [map, lift, LinearMap.coe_mk, AddHom.coe_mk, LinearMap.coe_comp, LinearEquiv.coe_coe,\n    Function.comp_apply]\n  rw [iso_symm_apply' S f (mk' f x s) x s (mk'_cancel' f x s), LocalizedModule.lift_mk]\n  rfl\n\n"}
{"name":"IsLocalizedModule.map_id","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁵ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M\ninst✝¹ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝ : IsLocalizedModule S f\n⊢ Eq ((IsLocalizedModule.map S f f) LinearMap.id) LinearMap.id","decl":"@[simp]\nlemma map_id : map S f f (.id ) = .id := by\n  ext x\n  obtain ⟨⟨x, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective S f x\n  simp\n\n"}
{"name":"IsLocalizedModule.map_injective","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN : Type u_6\nN' : Type u_7\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid N'\ninst✝² : Module R N\ninst✝¹ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S g\nh : LinearMap (RingHom.id R) M N\nh_inj : Function.Injective ⇑h\n⊢ Function.Injective ⇑((IsLocalizedModule.map S f g) h)","decl":"@[simp]\ntheorem map_injective (h : M →ₗ[R] N) (h_inj : Function.Injective h) :\n    Function.Injective (map S f g h) := by\n  intros x y\n  obtain ⟨⟨x, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective S f x\n  obtain ⟨⟨y, t⟩, rfl⟩ := IsLocalizedModule.mk'_surjective S f y\n  simp only [Function.uncurry_apply_pair, map_mk', mk'_eq_mk'_iff, Subtype.exists,\n    Submonoid.mk_smul, exists_prop, forall_exists_index, and_imp]\n  intros c hc e\n  exact ⟨c, hc, h_inj (by simpa)⟩\n\n"}
{"name":"IsLocalizedModule.map_surjective","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM : Type u_2\nM' : Type u_3\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : AddCommMonoid M'\ninst✝⁷ : Module R M\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN : Type u_6\nN' : Type u_7\ninst✝⁴ : AddCommMonoid N\ninst✝³ : AddCommMonoid N'\ninst✝² : Module R N\ninst✝¹ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S g\nh : LinearMap (RingHom.id R) M N\nh_surj : Function.Surjective ⇑h\n⊢ Function.Surjective ⇑((IsLocalizedModule.map S f g) h)","decl":"@[simp]\ntheorem map_surjective (h : M →ₗ[R] N) (h_surj : Function.Surjective h) :\n    Function.Surjective (map S f g h) := by\n  intros x\n  obtain ⟨⟨x, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective S g x\n  obtain ⟨x, rfl⟩ := h_surj x\n  exact ⟨mk' f x s, by simp⟩\n\n"}
{"name":"IsLocalizedModule.iso_localizedModule_eq_refl","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nS : Submonoid R\nM : Type u_2\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Eq (IsLocalizedModule.iso S (LocalizedModule.mkLinearMap S M)) (LinearEquiv.refl R (LocalizedModule S M))","decl":"/-- The linear map `(LocalizedModule S M) → (LocalizedModule S M)` from `iso` is the identity. -/\nlemma iso_localizedModule_eq_refl : iso S (mkLinearMap S M) = refl R (LocalizedModule S M) := by\n  let f := mkLinearMap S M\n  obtain ⟨e, _, univ⟩ := is_universal S f f (map_units f)\n  rw [← toLinearMap_inj, univ (iso S f) ((eq_toLinearMap_symm_comp f f).1 (iso_symm_comp S f).symm)]\n  exact Eq.symm <| univ (refl R (LocalizedModule S M)) (by simp)\n\n"}
{"name":"IsLocalizedModule.map_LocalizedModules","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Submonoid R\nM₀ : Type u_6\ninst✝³ : AddCommMonoid M₀\ninst✝² : Module R M₀\nM₁ : Type u_7\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R M₁\ng : LinearMap (RingHom.id R) M₀ M₁\nm : M₀\ns : Subtype fun x => Membership.mem S x\n⊢ Eq (((IsLocalizedModule.map S (LocalizedModule.mkLinearMap S M₀) (LocalizedModule.mkLinearMap S M₁)) g) (LocalizedModule.mk m s)) (LocalizedModule.mk (g m) s)","decl":"/-- Formula for `IsLocalizedModule.map` when each localized module is a `LocalizedModule`.-/\nlemma map_LocalizedModules (g : M₀ →ₗ[R] M₁) (m : M₀) (s : S) :\n    ((map S (mkLinearMap S M₀) (mkLinearMap S M₁)) g)\n    (LocalizedModule.mk m s) = LocalizedModule.mk (g m) s := by\n  have := (iso_apply_mk S (mkLinearMap S M₁) (g m) s).symm\n  rw [iso_localizedModule_eq_refl, refl_apply] at this\n  simpa [map, lift, iso_localizedModule_eq_refl S M₀]\n\n"}
{"name":"IsLocalizedModule.map_iso_commute","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁰ : CommSemiring R\nS : Submonoid R\nM₀ : Type u_6\nM₀' : Type u_9\ninst✝⁹ : AddCommMonoid M₀\ninst✝⁸ : AddCommMonoid M₀'\ninst✝⁷ : Module R M₀\ninst✝⁶ : Module R M₀'\nf₀ : LinearMap (RingHom.id R) M₀ M₀'\ninst✝⁵ : IsLocalizedModule S f₀\nM₁ : Type u_7\nM₁' : Type u_8\ninst✝⁴ : AddCommMonoid M₁\ninst✝³ : AddCommMonoid M₁'\ninst✝² : Module R M₁\ninst✝¹ : Module R M₁'\nf₁ : LinearMap (RingHom.id R) M₁ M₁'\ninst✝ : IsLocalizedModule S f₁\ng : LinearMap (RingHom.id R) M₀ M₁\n⊢ Eq (((IsLocalizedModule.map S f₀ f₁) g).comp ↑(IsLocalizedModule.iso S f₀)) ((↑(IsLocalizedModule.iso S f₁)).comp ((IsLocalizedModule.map S (LocalizedModule.mkLinearMap S M₀) (LocalizedModule.mkLinearMap S M₁)) g))","decl":"lemma map_iso_commute (g : M₀ →ₗ[R] M₁) : (map S f₀ f₁) g ∘ₗ (iso S f₀) =\n    (iso S f₁) ∘ₗ (map S (mkLinearMap S M₀) (mkLinearMap S M₁)) g := by\n  ext x\n  refine induction_on (fun m s ↦ ((Module.End_isUnit_iff _).1 (map_units f₁ s)).1 ?_) x\n  repeat rw [Module.algebraMap_end_apply, ← CompatibleSMul.map_smul, smul'_mk, ← mk_smul, mk_cancel]\n  simp -- Can't be combined with next simp. This uses map_apply, which would be preempted by map.\n  simp [map, lift, iso_localizedModule_eq_refl, lift_mk]\n\n"}
{"name":"IsLocalizedModule.map_comp'","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\ninst✝¹⁵ : CommSemiring R\nS : Submonoid R\nM₀ : Type u_6\nM₀' : Type u_9\ninst✝¹⁴ : AddCommMonoid M₀\ninst✝¹³ : AddCommMonoid M₀'\ninst✝¹² : Module R M₀\ninst✝¹¹ : Module R M₀'\nf₀ : LinearMap (RingHom.id R) M₀ M₀'\ninst✝¹⁰ : IsLocalizedModule S f₀\nM₁ : Type u_7\nM₁' : Type u_11\ninst✝⁹ : AddCommMonoid M₁\ninst✝⁸ : AddCommMonoid M₁'\ninst✝⁷ : Module R M₁\ninst✝⁶ : Module R M₁'\nf₁ : LinearMap (RingHom.id R) M₁ M₁'\ninst✝⁵ : IsLocalizedModule S f₁\nM₂ : Type u_8\nM₂' : Type u_10\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M₂'\ninst✝² : Module R M₂\ninst✝¹ : Module R M₂'\nf₂ : LinearMap (RingHom.id R) M₂ M₂'\ninst✝ : IsLocalizedModule S f₂\ng : LinearMap (RingHom.id R) M₀ M₁\nh : LinearMap (RingHom.id R) M₁ M₂\n⊢ Eq ((IsLocalizedModule.map S f₀ f₂) (h.comp g)) (((IsLocalizedModule.map S f₁ f₂) h).comp ((IsLocalizedModule.map S f₀ f₁) g))","decl":"/-- Localization of composition is the composition of localization -/\ntheorem map_comp' (g : M₀ →ₗ[R] M₁) (h : M₁ →ₗ[R] M₂) :\n    map S f₀ f₂ (h ∘ₗ g) = map S f₁ f₂ h ∘ₗ map S f₀ f₁ g := by\n  ext x\n  obtain ⟨⟨x, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective S f₀ x\n  simp\n\n"}
{"name":"IsLocalizedModule.mkOfAlgebra","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_6\nS : Type u_7\nS' : Type u_8\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing S'\ninst✝¹ : Algebra R S\ninst✝ : Algebra R S'\nM : Submonoid R\nf : AlgHom R S S'\nh₁ : ∀ (x : R), Membership.mem M x → IsUnit ((algebraMap R S') x)\nh₂ : ∀ (y : S'), Exists fun x => Eq (HSMul.hSMul x.2 y) (f x.1)\nh₃ : ∀ (x : S), Eq (f x) 0 → Exists fun m => Eq (HSMul.hSMul m x) 0\n⊢ IsLocalizedModule M f.toLinearMap","decl":"theorem mkOfAlgebra {R S S' : Type*} [CommRing R] [CommRing S] [CommRing S'] [Algebra R S]\n    [Algebra R S'] (M : Submonoid R) (f : S →ₐ[R] S') (h₁ : ∀ x ∈ M, IsUnit (algebraMap R S' x))\n    (h₂ : ∀ y, ∃ x : S × M, x.2 • y = f x.1) (h₃ : ∀ x, f x = 0 → ∃ m : M, m • x = 0) :\n    IsLocalizedModule M f.toLinearMap := by\n  replace h₃ := fun x =>\n    Iff.intro (h₃ x) fun ⟨⟨m, hm⟩, e⟩ =>\n      (h₁ m hm).mul_left_cancel <| by\n        rw [← Algebra.smul_def]\n        simpa [Submonoid.smul_def] using f.congr_arg e\n  constructor\n  · intro x\n    rw [Module.End_isUnit_iff]\n    constructor\n    · rintro a b (e : x • a = x • b)\n      simp_rw [Submonoid.smul_def, Algebra.smul_def] at e\n      exact (h₁ x x.2).mul_left_cancel e\n    · intro a\n      refine ⟨((h₁ x x.2).unit⁻¹ :) * a, ?_⟩\n      rw [Module.algebraMap_end_apply, Algebra.smul_def, ← mul_assoc, IsUnit.mul_val_inv, one_mul]\n  · exact h₂\n  · intros x y\n    dsimp only [AlgHom.toLinearMap_apply]\n    rw [← sub_eq_zero, ← map_sub, h₃]\n    simp_rw [smul_sub, sub_eq_zero]\n    exact id\n\n"}
{"name":"LocalizedModule.mem_ker_mkLinearMap_iff","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submonoid R\nm : M\n⊢ Iff (Membership.mem (LinearMap.ker (LocalizedModule.mkLinearMap S M)) m) (Exists fun r => And (Membership.mem S r) (Eq (HSMul.hSMul r m) 0))","decl":"lemma LocalizedModule.mem_ker_mkLinearMap_iff {S : Submonoid R} {m} :\n    m ∈ LinearMap.ker (LocalizedModule.mkLinearMap S M) ↔ ∃ r ∈ S, r • m = 0 := by\n  constructor\n  · intro H\n    obtain ⟨r, hr⟩ := (@LocalizedModule.mk_eq _ _ S M _ _ m 0 1 1).mp (by simpa using H)\n    exact ⟨r, r.2, by simpa using hr⟩\n  · rintro ⟨r, hr, e⟩\n    apply ((Module.End_isUnit_iff _).mp\n      (IsLocalizedModule.map_units (LocalizedModule.mkLinearMap S M) ⟨r, hr⟩)).injective\n    simp [← IsLocalizedModule.mk_eq_mk', LocalizedModule.smul'_mk, e]\n\n"}
{"name":"LocalizedModule.subsingleton_iff_ker_eq_top","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submonoid R\n⊢ Iff (Subsingleton (LocalizedModule S M)) (Eq (LinearMap.ker (LocalizedModule.mkLinearMap S M)) Top.top)","decl":"lemma LocalizedModule.subsingleton_iff_ker_eq_top {S : Submonoid R} :\n    Subsingleton (LocalizedModule S M) ↔\n      LinearMap.ker (LocalizedModule.mkLinearMap S M) = ⊤ := by\n  rw [← top_le_iff]\n  refine ⟨fun H m _ ↦ Subsingleton.elim _ _, fun H ↦ (subsingleton_iff_forall_eq 0).mpr fun x ↦ ?_⟩\n  obtain ⟨⟨x, s⟩, rfl⟩ := IsLocalizedModule.mk'_surjective S (LocalizedModule.mkLinearMap S M) x\n  simpa using @H x Submodule.mem_top\n\n"}
{"name":"LocalizedModule.subsingleton_iff","module":"Mathlib.Algebra.Module.LocalizedModule.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nS : Submonoid R\n⊢ Iff (Subsingleton (LocalizedModule S M)) (∀ (m : M), Exists fun r => And (Membership.mem S r) (Eq (HSMul.hSMul r m) 0))","decl":"lemma LocalizedModule.subsingleton_iff {S : Submonoid R} :\n    Subsingleton (LocalizedModule S M) ↔ ∀ m : M, ∃ r ∈ S, r • m = 0 := by\n  simp_rw [subsingleton_iff_ker_eq_top, ← top_le_iff, SetLike.le_def,\n    mem_ker_mkLinearMap_iff, Submodule.mem_top, true_implies]\n\n"}
