{"name":"PNat.mk_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq (↑⟨n, h⟩) n","decl":"@[simp]\ntheorem mk_coe (n h) : (PNat.val (⟨n, h⟩ : ℕ+) : ℕ) = n :=\n  rfl\n\n"}
{"name":"PNat.natPred_eq_pred","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : Nat\nh : LT.lt 0 n\n⊢ Eq (PNat.natPred ⟨n, h⟩) n.pred","decl":"@[simp]\ntheorem natPred_eq_pred {n : ℕ} (h : 0 < n) : natPred (⟨n, h⟩ : ℕ+) = n.pred :=\n  rfl\n\n"}
{"name":"Nat.succPNat_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n.succPNat) n.succ","decl":"@[simp]\ntheorem succPNat_coe (n : ℕ) : (succPNat n : ℕ) = succ n :=\n  rfl\n\n"}
{"name":"Nat.natPred_succPNat","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : Nat\n⊢ Eq n.succPNat.natPred n","decl":"@[simp]\ntheorem natPred_succPNat (n : ℕ) : n.succPNat.natPred = n :=\n  rfl\n\n"}
{"name":"PNat.succPNat_natPred","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : PNat\n⊢ Eq n.natPred.succPNat n","decl":"@[simp]\ntheorem _root_.PNat.succPNat_natPred (n : ℕ+) : n.natPred.succPNat = n :=\n  Subtype.eq <| succ_pred_eq_of_pos n.2\n\n"}
{"name":"Nat.toPNat'_zero","module":"Mathlib.Data.PNat.Defs","initialProofState":"⊢ Eq (Nat.toPNat' 0) 1","decl":"@[simp]\ntheorem toPNat'_zero : Nat.toPNat' 0 = 1 := rfl\n\n"}
{"name":"Nat.toPNat'_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : Nat\n⊢ Eq (↑n.toPNat') (ite (LT.lt 0 n) n 1)","decl":"@[simp]\ntheorem toPNat'_coe : ∀ n : ℕ, (toPNat' n : ℕ) = ite (0 < n) n 1\n  | 0 => rfl\n  | m + 1 => by\n    rw [if_pos (succ_pos m)]\n    rfl\n\n"}
{"name":"PNat.mk_le_mk","module":"Mathlib.Data.PNat.Defs","initialProofState":"n k : Nat\nhn : LT.lt 0 n\nhk : LT.lt 0 k\n⊢ Iff (LE.le ⟨n, hn⟩ ⟨k, hk⟩) (LE.le n k)","decl":"/-- We now define a long list of structures on ℕ+ induced by\n similar structures on ℕ. Most of these behave in a completely\n obvious way, but there are a few things to be said about\n subtraction, division and powers.\n-/\n-- Porting note: no `simp`  because simp can prove it\ntheorem mk_le_mk (n k : ℕ) (hn : 0 < n) (hk : 0 < k) : (⟨n, hn⟩ : ℕ+) ≤ ⟨k, hk⟩ ↔ n ≤ k :=\n  Iff.rfl\n\n-- Porting note: no `simp`  because simp can prove it\n"}
{"name":"PNat.mk_lt_mk","module":"Mathlib.Data.PNat.Defs","initialProofState":"n k : Nat\nhn : LT.lt 0 n\nhk : LT.lt 0 k\n⊢ Iff (LT.lt ⟨n, hn⟩ ⟨k, hk⟩) (LT.lt n k)","decl":"theorem mk_lt_mk (n k : ℕ) (hn : 0 < n) (hk : 0 < k) : (⟨n, hn⟩ : ℕ+) < ⟨k, hk⟩ ↔ n < k :=\n  Iff.rfl\n\n"}
{"name":"PNat.coe_le_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"n k : PNat\n⊢ Iff (LE.le ↑n ↑k) (LE.le n k)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe (n k : ℕ+) : (n : ℕ) ≤ k ↔ n ≤ k :=\n  Iff.rfl\n\n"}
{"name":"PNat.coe_lt_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"n k : PNat\n⊢ Iff (LT.lt ↑n ↑k) (LT.lt n k)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe (n k : ℕ+) : (n : ℕ) < k ↔ n < k :=\n  Iff.rfl\n\n"}
{"name":"PNat.pos","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : PNat\n⊢ LT.lt 0 ↑n","decl":"@[simp]\ntheorem pos (n : ℕ+) : 0 < (n : ℕ) :=\n  n.2\n\n"}
{"name":"PNat.eq","module":"Mathlib.Data.PNat.Defs","initialProofState":"m n : PNat\na✝ : Eq ↑m ↑n\n⊢ Eq m n","decl":"theorem eq {m n : ℕ+} : (m : ℕ) = n → m = n :=\n  Subtype.eq\n\n"}
{"name":"PNat.coe_injective","module":"Mathlib.Data.PNat.Defs","initialProofState":"⊢ Function.Injective PNat.val","decl":"theorem coe_injective : Function.Injective PNat.val :=\n  Subtype.coe_injective\n\n"}
{"name":"PNat.ne_zero","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : PNat\n⊢ Ne (↑n) 0","decl":"@[simp]\ntheorem ne_zero (n : ℕ+) : (n : ℕ) ≠ 0 :=\n  n.2.ne'\n\n"}
{"name":"NeZero.pnat","module":"Mathlib.Data.PNat.Defs","initialProofState":"a : PNat\n⊢ NeZero ↑a","decl":"instance _root_.NeZero.pnat {a : ℕ+} : NeZero (a : ℕ) :=\n  ⟨a.ne_zero⟩\n\n"}
{"name":"PNat.toPNat'_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : Nat\na✝ : LT.lt 0 n\n⊢ Eq (↑n.toPNat') n","decl":"theorem toPNat'_coe {n : ℕ} : 0 < n → (n.toPNat' : ℕ) = n :=\n  succ_pred_eq_of_pos\n\n"}
{"name":"PNat.coe_toPNat'","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : PNat\n⊢ Eq (↑n).toPNat' n","decl":"@[simp]\ntheorem coe_toPNat' (n : ℕ+) : (n : ℕ).toPNat' = n :=\n  eq (toPNat'_coe n.pos)\n\n"}
{"name":"PNat.one_le","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : PNat\n⊢ LE.le 1 n","decl":"@[simp]\ntheorem one_le (n : ℕ+) : (1 : ℕ+) ≤ n :=\n  n.2\n\n"}
{"name":"PNat.not_lt_one","module":"Mathlib.Data.PNat.Defs","initialProofState":"n : PNat\n⊢ Not (LT.lt n 1)","decl":"@[simp]\ntheorem not_lt_one (n : ℕ+) : ¬n < 1 :=\n  not_lt_of_le n.one_le\n\n"}
{"name":"PNat.mk_one","module":"Mathlib.Data.PNat.Defs","initialProofState":"h : LT.lt 0 1\n⊢ Eq ⟨1, h⟩ 1","decl":"@[simp]\ntheorem mk_one {h} : (⟨1, h⟩ : ℕ+) = (1 : ℕ+) :=\n  rfl\n\n"}
{"name":"PNat.one_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"⊢ Eq (↑1) 1","decl":"@[norm_cast]\ntheorem one_coe : ((1 : ℕ+) : ℕ) = 1 :=\n  rfl\n\n"}
{"name":"PNat.coe_eq_one_iff","module":"Mathlib.Data.PNat.Defs","initialProofState":"m : PNat\n⊢ Iff (Eq (↑m) 1) (Eq m 1)","decl":"@[simp, norm_cast]\ntheorem coe_eq_one_iff {m : ℕ+} : (m : ℕ) = 1 ↔ m = 1 :=\n  Subtype.coe_injective.eq_iff' one_coe\n\n"}
{"name":"PNat.mod_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"m k : PNat\n⊢ Eq (↑(m.mod k)) (ite (Eq (HMod.hMod ↑m ↑k) 0) (↑k) (HMod.hMod ↑m ↑k))","decl":"theorem mod_coe (m k : ℕ+) :\n    (mod m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) (k : ℕ) ((m : ℕ) % (k : ℕ)) := by\n  dsimp [mod, modDiv]\n  cases (m : ℕ) % (k : ℕ) with\n  | zero =>\n    rw [if_pos rfl]\n    rfl\n  | succ n =>\n    rw [if_neg n.succ_ne_zero]\n    rfl\n\n"}
{"name":"PNat.div_coe","module":"Mathlib.Data.PNat.Defs","initialProofState":"m k : PNat\n⊢ Eq (m.div k) (ite (Eq (HMod.hMod ↑m ↑k) 0) (HDiv.hDiv ↑m ↑k).pred (HDiv.hDiv ↑m ↑k))","decl":"theorem div_coe (m k : ℕ+) :\n    (div m k : ℕ) = ite ((m : ℕ) % (k : ℕ) = 0) ((m : ℕ) / (k : ℕ)).pred ((m : ℕ) / (k : ℕ)) := by\n  dsimp [div, modDiv]\n  cases (m : ℕ) % (k : ℕ) with\n  | zero =>\n    rw [if_pos rfl]\n    rfl\n  | succ n =>\n    rw [if_neg n.succ_ne_zero]\n    rfl\n\n"}
{"name":"Nat.canLiftPNat","module":"Mathlib.Data.PNat.Defs","initialProofState":"⊢ CanLift Nat PNat PNat.val fun n => LT.lt 0 n","decl":"instance Nat.canLiftPNat : CanLift ℕ ℕ+ (↑) (fun n => 0 < n) :=\n  ⟨fun n hn => ⟨Nat.toPNat' n, PNat.toPNat'_coe hn⟩⟩\n\n"}
{"name":"Int.canLiftPNat","module":"Mathlib.Data.PNat.Defs","initialProofState":"⊢ CanLift Int PNat (fun x => ↑↑x) fun x => LT.lt 0 x","decl":"instance Int.canLiftPNat : CanLift ℤ ℕ+ (↑) ((0 < ·)) :=\n  ⟨fun n hn =>\n    ⟨Nat.toPNat' (Int.natAbs n), by\n      rw [Nat.toPNat'_coe, if_pos (Int.natAbs_pos.2 hn.ne'),\n        Int.natAbs_of_nonneg hn.le]⟩⟩\n\n"}
