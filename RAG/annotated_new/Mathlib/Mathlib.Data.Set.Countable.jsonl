{"name":"Set.countable_coe_iff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\n⊢ Iff (Countable ↑s) s.Countable","decl":"@[simp]\ntheorem countable_coe_iff {s : Set α} : Countable s ↔ s.Countable := .rfl\n\n"}
{"name":"Set.to_countable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\ninst✝ : Countable ↑s\n⊢ s.Countable","decl":"/-- Prove `Set.Countable` from a `Countable` instance on the subtype. -/\ntheorem to_countable (s : Set α) [Countable s] : s.Countable := ‹_›\n\n"}
{"name":"Countable.to_set","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\na✝ : Countable ↑s\n⊢ s.Countable","decl":"/-- Restate `Set.Countable` as a `Countable` instance. -/\nalias ⟨_root_.Countable.to_set, Countable.to_subtype⟩ := countable_coe_iff\n\n"}
{"name":"Set.Countable.to_subtype","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\na✝ : s.Countable\n⊢ Countable ↑s","decl":"/-- Restate `Set.Countable` as a `Countable` instance. -/\nalias ⟨_root_.Countable.to_set, Countable.to_subtype⟩ := countable_coe_iff\n\n"}
{"name":"Set.countable_iff_exists_injective","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Countable (Exists fun f => Function.Injective f)","decl":"protected theorem countable_iff_exists_injective {s : Set α} :\n    s.Countable ↔ ∃ f : s → ℕ, Injective f :=\n  countable_iff_exists_injective s\n\n"}
{"name":"Set.countable_iff_exists_injOn","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Countable (Exists fun f => Set.InjOn f s)","decl":"/-- A set `s : Set α` is countable if and only if there exists a function `α → ℕ` injective\non `s`. -/\ntheorem countable_iff_exists_injOn {s : Set α} : s.Countable ↔ ∃ f : α → ℕ, InjOn f s :=\n  Set.countable_iff_exists_injective.trans exists_injOn_iff_injective.symm\n\n"}
{"name":"Set.countable_iff_nonempty_encodable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\n⊢ Iff s.Countable (Nonempty (Encodable ↑s))","decl":"theorem countable_iff_nonempty_encodable {s : Set α} : s.Countable ↔ Nonempty (Encodable s) :=\n  Encodable.nonempty_encodable.symm\n\n"}
{"name":"Set.Countable.nonempty_encodable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\na✝ : s.Countable\n⊢ Nonempty (Encodable ↑s)","decl":"alias ⟨Countable.nonempty_encodable, _⟩ := countable_iff_nonempty_encodable\n\n"}
{"name":"Set.subset_range_enumerate","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nh : s.Countable\ndefault : α\n⊢ HasSubset.Subset s (Set.range (Set.enumerateCountable h default))","decl":"theorem subset_range_enumerate {s : Set α} (h : s.Countable) (default : α) :\n    s ⊆ range (enumerateCountable h default) := fun x hx =>\n  ⟨@Encodable.encode s h.toEncodable ⟨x, hx⟩, by\n    letI := h.toEncodable\n    simp [enumerateCountable, Encodable.encodek]⟩\n\n"}
{"name":"Set.range_enumerateCountable_subset","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nh : s.Countable\ndefault : α\n⊢ HasSubset.Subset (Set.range (Set.enumerateCountable h default)) (Insert.insert default s)","decl":"lemma range_enumerateCountable_subset {s : Set α} (h : s.Countable) (default : α) :\n    range (enumerateCountable h default) ⊆ insert default s := by\n  refine range_subset_iff.mpr (fun n ↦ ?_)\n  rw [enumerateCountable]\n  match @decode s (Countable.toEncodable h) n with\n  | none => exact mem_insert _ _\n  | some val => simp\n\n"}
{"name":"Set.range_enumerateCountable_of_mem","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nh : s.Countable\ndefault : α\nh_mem : Membership.mem s default\n⊢ Eq (Set.range (Set.enumerateCountable h default)) s","decl":"lemma range_enumerateCountable_of_mem {s : Set α} (h : s.Countable) {default : α}\n    (h_mem : default ∈ s) :\n    range (enumerateCountable h default) = s :=\n  subset_antisymm ((range_enumerateCountable_subset h _).trans_eq (insert_eq_of_mem h_mem))\n    (subset_range_enumerate h default)\n\n"}
{"name":"Set.enumerateCountable_mem","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nh : s.Countable\ndefault : α\nh_mem : Membership.mem s default\nn : Nat\n⊢ Membership.mem s (Set.enumerateCountable h default n)","decl":"lemma enumerateCountable_mem {s : Set α} (h : s.Countable) {default : α} (h_mem : default ∈ s)\n    (n : ℕ) :\n    enumerateCountable h default n ∈ s := by\n  convert mem_range_self n\n  exact (range_enumerateCountable_of_mem h h_mem).symm\n\n"}
{"name":"Set.Countable.mono","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns₁ s₂ : Set α\nh : HasSubset.Subset s₁ s₂\nhs : s₂.Countable\n⊢ s₁.Countable","decl":"theorem Countable.mono {s₁ s₂ : Set α} (h : s₁ ⊆ s₂) (hs : s₂.Countable) : s₁.Countable :=\n  have := hs.to_subtype; (inclusion_injective h).countable\n\n"}
{"name":"Set.countable_range","module":"Mathlib.Data.Set.Countable","initialProofState":"β : Type v\nι : Sort x\ninst✝ : Countable ι\nf : ι → β\n⊢ (Set.range f).Countable","decl":"theorem countable_range [Countable ι] (f : ι → β) : (range f).Countable :=\n  surjective_onto_range.countable.to_set\n\n"}
{"name":"Set.countable_iff_exists_subset_range","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ninst✝ : Nonempty α\ns : Set α\n⊢ Iff s.Countable (Exists fun f => HasSubset.Subset s (Set.range f))","decl":"theorem countable_iff_exists_subset_range [Nonempty α] {s : Set α} :\n    s.Countable ↔ ∃ f : ℕ → α, s ⊆ range f :=\n  ⟨fun h => by\n    inhabit α\n    exact ⟨enumerateCountable h default, subset_range_enumerate _ _⟩, fun ⟨f, hsf⟩ =>\n    (countable_range f).mono hsf⟩\n\n"}
{"name":"Set.countable_iff_exists_surjective","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nhs : s.Nonempty\n⊢ Iff s.Countable (Exists fun f => Function.Surjective f)","decl":"/-- A non-empty set is countable iff there exists a surjection from the\nnatural numbers onto the subtype induced by the set.\n-/\nprotected theorem countable_iff_exists_surjective {s : Set α} (hs : s.Nonempty) :\n    s.Countable ↔ ∃ f : ℕ → s, Surjective f :=\n  @countable_iff_exists_surjective s hs.to_subtype\n\n"}
{"name":"Set.Countable.exists_surjective","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nhs : s.Nonempty\na✝ : s.Countable\n⊢ Exists fun f => Function.Surjective f","decl":"alias ⟨Countable.exists_surjective, _⟩ := Set.countable_iff_exists_surjective\n\n"}
{"name":"Set.countable_univ_iff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\n⊢ Iff Set.univ.Countable (Countable α)","decl":"theorem countable_univ_iff : (univ : Set α).Countable ↔ Countable α :=\n  countable_coe_iff.symm.trans (Equiv.Set.univ _).countable_iff\n\n"}
{"name":"Set.countable_univ","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ninst✝ : Countable α\n⊢ Set.univ.Countable","decl":"theorem countable_univ [Countable α] : (univ : Set α).Countable :=\n  to_countable univ\n\n"}
{"name":"Set.not_countable_univ_iff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\n⊢ Iff (Not Set.univ.Countable) (Uncountable α)","decl":"theorem not_countable_univ_iff : ¬ (univ : Set α).Countable ↔ Uncountable α := by\n  rw [countable_univ_iff, not_countable_iff]\n\n"}
{"name":"Set.not_countable_univ","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ninst✝ : Uncountable α\n⊢ Not Set.univ.Countable","decl":"theorem not_countable_univ [Uncountable α] : ¬ (univ : Set α).Countable :=\n  not_countable_univ_iff.2 ‹_›\n\n"}
{"name":"Set.Countable.exists_eq_range","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nhc : s.Countable\nhs : s.Nonempty\n⊢ Exists fun f => Eq s (Set.range f)","decl":"/-- If `s : Set α` is a nonempty countable set, then there exists a map\n`f : ℕ → α` such that `s = range f`. -/\ntheorem Countable.exists_eq_range {s : Set α} (hc : s.Countable) (hs : s.Nonempty) :\n    ∃ f : ℕ → α, s = range f := by\n  rcases hc.exists_surjective hs with ⟨f, hf⟩\n  refine ⟨(↑) ∘ f, ?_⟩\n  rw [hf.range_comp, Subtype.range_coe]\n\n"}
{"name":"Set.countable_empty","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\n⊢ EmptyCollection.emptyCollection.Countable","decl":"@[simp] theorem countable_empty : (∅ : Set α).Countable := to_countable _\n\n"}
{"name":"Set.countable_singleton","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\na : α\n⊢ (Singleton.singleton a).Countable","decl":"@[simp] theorem countable_singleton (a : α) : ({a} : Set α).Countable := to_countable _\n\n"}
{"name":"Set.Countable.image","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nhs : s.Countable\nf : α → β\n⊢ (Set.image f s).Countable","decl":"theorem Countable.image {s : Set α} (hs : s.Countable) (f : α → β) : (f '' s).Countable := by\n  rw [image_eq_range]\n  have := hs.to_subtype\n  apply countable_range\n\n"}
{"name":"Set.MapsTo.countable_of_injOn","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\nf : α → β\nhf : Set.MapsTo f s t\nhf' : Set.InjOn f s\nht : t.Countable\n⊢ s.Countable","decl":"theorem MapsTo.countable_of_injOn {s : Set α} {t : Set β} {f : α → β} (hf : MapsTo f s t)\n    (hf' : InjOn f s) (ht : t.Countable) : s.Countable :=\n  have := ht.to_subtype\n  have : Injective (hf.restrict f s t) := (injOn_iff_injective.1 hf').codRestrict _\n  this.countable\n\n"}
{"name":"Set.Countable.preimage_of_injOn","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set β\nhs : s.Countable\nf : α → β\nhf : Set.InjOn f (Set.preimage f s)\n⊢ (Set.preimage f s).Countable","decl":"theorem Countable.preimage_of_injOn {s : Set β} (hs : s.Countable) {f : α → β}\n    (hf : InjOn f (f ⁻¹' s)) : (f ⁻¹' s).Countable :=\n  (mapsTo_preimage f s).countable_of_injOn hf hs\n\n"}
{"name":"Set.Countable.preimage","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set β\nhs : s.Countable\nf : α → β\nhf : Function.Injective f\n⊢ (Set.preimage f s).Countable","decl":"protected theorem Countable.preimage {s : Set β} (hs : s.Countable) {f : α → β} (hf : Injective f) :\n    (f ⁻¹' s).Countable :=\n  hs.preimage_of_injOn hf.injOn\n\n"}
{"name":"Set.exists_seq_iSup_eq_top_iff_countable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ninst✝ : CompleteLattice α\np : α → Prop\nh : Exists fun x => p x\n⊢ Iff (Exists fun s => And (∀ (n : Nat), p (s n)) (Eq (iSup fun n => s n) Top.top)) (Exists fun S => And S.Countable (And (∀ (s : α), Membership.mem S s → p s) (Eq (SupSet.sSup S) Top.top)))","decl":"theorem exists_seq_iSup_eq_top_iff_countable [CompleteLattice α] {p : α → Prop} (h : ∃ x, p x) :\n    (∃ s : ℕ → α, (∀ n, p (s n)) ∧ ⨆ n, s n = ⊤) ↔\n      ∃ S : Set α, S.Countable ∧ (∀ s ∈ S, p s) ∧ sSup S = ⊤ := by\n  constructor\n  · rintro ⟨s, hps, hs⟩\n    refine ⟨range s, countable_range s, forall_mem_range.2 hps, ?_⟩\n    rwa [sSup_range]\n  · rintro ⟨S, hSc, hps, hS⟩\n    rcases eq_empty_or_nonempty S with (rfl | hne)\n    · rw [sSup_empty] at hS\n      haveI := subsingleton_of_bot_eq_top hS\n      rcases h with ⟨x, hx⟩\n      exact ⟨fun _ => x, fun _ => hx, Subsingleton.elim _ _⟩\n    · rcases (Set.countable_iff_exists_surjective hne).1 hSc with ⟨s, hs⟩\n      refine ⟨fun n => s n, fun n => hps _ (s n).coe_prop, ?_⟩\n      rwa [hs.iSup_comp, ← sSup_eq_iSup']\n\n"}
{"name":"Set.exists_seq_cover_iff_countable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\np : Set α → Prop\nh : Exists fun s => p s\n⊢ Iff (Exists fun s => And (∀ (n : Nat), p (s n)) (Eq (Set.iUnion fun n => s n) Set.univ)) (Exists fun S => And S.Countable (And (∀ (s : Set α), Membership.mem S s → p s) (Eq S.sUnion Set.univ)))","decl":"theorem exists_seq_cover_iff_countable {p : Set α → Prop} (h : ∃ s, p s) :\n    (∃ s : ℕ → Set α, (∀ n, p (s n)) ∧ ⋃ n, s n = univ) ↔\n      ∃ S : Set (Set α), S.Countable ∧ (∀ s ∈ S, p s) ∧ ⋃₀ S = univ :=\n  exists_seq_iSup_eq_top_iff_countable h\n\n"}
{"name":"Set.countable_of_injective_of_countable_image","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nf : α → β\nhf : Set.InjOn f s\nhs : (Set.image f s).Countable\n⊢ s.Countable","decl":"theorem countable_of_injective_of_countable_image {s : Set α} {f : α → β} (hf : InjOn f s)\n    (hs : (f '' s).Countable) : s.Countable :=\n  (mapsTo_image _ _).countable_of_injOn hf hs\n\n"}
{"name":"Set.countable_iUnion","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nι : Sort x\nt : ι → Set α\ninst✝ : Countable ι\nht : ∀ (i : ι), (t i).Countable\n⊢ (Set.iUnion fun i => t i).Countable","decl":"theorem countable_iUnion {t : ι → Set α} [Countable ι] (ht : ∀ i, (t i).Countable) :\n    (⋃ i, t i).Countable := by\n  have := fun i ↦ (ht i).to_subtype\n  rw [iUnion_eq_range_psigma]\n  apply countable_range\n\n"}
{"name":"Set.countable_iUnion_iff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nι : Sort x\ninst✝ : Countable ι\nt : ι → Set α\n⊢ Iff (Set.iUnion fun i => t i).Countable (∀ (i : ι), (t i).Countable)","decl":"@[simp]\ntheorem countable_iUnion_iff [Countable ι] {t : ι → Set α} :\n    (⋃ i, t i).Countable ↔ ∀ i, (t i).Countable :=\n  ⟨fun h _ => h.mono <| subset_iUnion _ _, countable_iUnion⟩\n\n"}
{"name":"Set.Countable.biUnion_iff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : (a : α) → Membership.mem s a → Set β\nhs : s.Countable\n⊢ Iff (Set.iUnion fun a => Set.iUnion fun h => t a h).Countable (∀ (a : α) (ha : Membership.mem s a), (t a ha).Countable)","decl":"theorem Countable.biUnion_iff {s : Set α} {t : ∀ a ∈ s, Set β} (hs : s.Countable) :\n    (⋃ a ∈ s, t a ‹_›).Countable ↔ ∀ a (ha : a ∈ s), (t a ha).Countable := by\n  have := hs.to_subtype\n  rw [biUnion_eq_iUnion, countable_iUnion_iff, SetCoe.forall']\n\n"}
{"name":"Set.Countable.sUnion_iff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set (Set α)\nhs : s.Countable\n⊢ Iff s.sUnion.Countable (∀ (a : Set α), Membership.mem s a → a.Countable)","decl":"theorem Countable.sUnion_iff {s : Set (Set α)} (hs : s.Countable) :\n    (⋃₀ s).Countable ↔ ∀ a ∈ s, a.Countable := by rw [sUnion_eq_biUnion, hs.biUnion_iff]\n\n"}
{"name":"Set.Countable.biUnion","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : (a : α) → Membership.mem s a → Set β\nhs : s.Countable\na✝ : ∀ (a : α) (ha : Membership.mem s a), (t a ha).Countable\n⊢ (Set.iUnion fun a => Set.iUnion fun h => t a h).Countable","decl":"alias ⟨_, Countable.biUnion⟩ := Countable.biUnion_iff\n\n"}
{"name":"Set.Countable.sUnion","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set (Set α)\nhs : s.Countable\na✝ : ∀ (a : Set α), Membership.mem s a → a.Countable\n⊢ s.sUnion.Countable","decl":"alias ⟨_, Countable.sUnion⟩ := Countable.sUnion_iff\n\n"}
{"name":"Set.countable_union","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns t : Set α\n⊢ Iff (Union.union s t).Countable (And s.Countable t.Countable)","decl":"@[simp]\ntheorem countable_union {s t : Set α} : (s ∪ t).Countable ↔ s.Countable ∧ t.Countable := by\n  simp [union_eq_iUnion, and_comm]\n\n"}
{"name":"Set.Countable.union","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns t : Set α\nhs : s.Countable\nht : t.Countable\n⊢ (Union.union s t).Countable","decl":"theorem Countable.union {s t : Set α} (hs : s.Countable) (ht : t.Countable) : (s ∪ t).Countable :=\n  countable_union.2 ⟨hs, ht⟩\n\n"}
{"name":"Set.Countable.of_diff","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns t : Set α\nh : (SDiff.sdiff s t).Countable\nht : t.Countable\n⊢ s.Countable","decl":"theorem Countable.of_diff {s t : Set α} (h : (s \\ t).Countable) (ht : t.Countable) : s.Countable :=\n  (h.union ht).mono (subset_diff_union _ _)\n\n"}
{"name":"Set.countable_insert","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\na : α\n⊢ Iff (Insert.insert a s).Countable s.Countable","decl":"@[simp]\ntheorem countable_insert {s : Set α} {a : α} : (insert a s).Countable ↔ s.Countable := by\n  simp only [insert_eq, countable_union, countable_singleton, true_and]\n\n"}
{"name":"Set.Countable.insert","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\na : α\nh : s.Countable\n⊢ (Insert.insert a s).Countable","decl":"protected theorem Countable.insert {s : Set α} (a : α) (h : s.Countable) : (insert a s).Countable :=\n  countable_insert.2 h\n\n"}
{"name":"Set.Finite.countable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nhs : s.Finite\n⊢ s.Countable","decl":"theorem Finite.countable {s : Set α} (hs : s.Finite) : s.Countable :=\n  have := hs.to_subtype; s.to_countable\n\n"}
{"name":"Set.Countable.of_subsingleton","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ninst✝ : Subsingleton α\ns : Set α\n⊢ s.Countable","decl":"@[nontriviality]\ntheorem Countable.of_subsingleton [Subsingleton α] (s : Set α) : s.Countable :=\n  (Finite.of_subsingleton s).countable\n\n"}
{"name":"Set.Subsingleton.countable","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nhs : s.Subsingleton\n⊢ s.Countable","decl":"theorem Subsingleton.countable {s : Set α} (hs : s.Subsingleton) : s.Countable :=\n  hs.finite.countable\n\n"}
{"name":"Set.countable_isTop","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ (setOf fun x => IsTop x).Countable","decl":"theorem countable_isTop (α : Type*) [PartialOrder α] : { x : α | IsTop x }.Countable :=\n  (finite_isTop α).countable\n\n"}
{"name":"Set.countable_isBot","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ (setOf fun x => IsBot x).Countable","decl":"theorem countable_isBot (α : Type*) [PartialOrder α] : { x : α | IsBot x }.Countable :=\n  (finite_isBot α).countable\n\n"}
{"name":"Set.countable_setOf_finite_subset","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Set α\nhs : s.Countable\n⊢ (setOf fun t => And t.Finite (HasSubset.Subset t s)).Countable","decl":"/-- The set of finite subsets of a countable set is countable. -/\ntheorem countable_setOf_finite_subset {s : Set α} (hs : s.Countable) :\n    { t | Set.Finite t ∧ t ⊆ s }.Countable := by\n  have := hs.to_subtype\n  refine (countable_range fun t : Finset s => Subtype.val '' (t : Set s)).mono ?_\n  rintro t ⟨ht, hts⟩\n  lift t to Set s using hts\n  lift t to Finset s using ht.of_finite_image Subtype.val_injective.injOn\n  exact mem_range_self _\n\n"}
{"name":"Set.Countable.setOf_finite","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ninst✝ : Countable α\n⊢ (setOf fun s => s.Finite).Countable","decl":"/-- The set of finite sets in a countable type is countable. -/\ntheorem Countable.setOf_finite [Countable α] : {s : Set α | s.Finite}.Countable := by\n  simpa using countable_setOf_finite_subset countable_univ\n\n"}
{"name":"Set.countable_univ_pi","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nπ : α → Type u_1\ninst✝ : Finite α\ns : (a : α) → Set (π a)\nhs : ∀ (a : α), (s a).Countable\n⊢ (Set.univ.pi s).Countable","decl":"theorem countable_univ_pi {π : α → Type*} [Finite α] {s : ∀ a, Set (π a)}\n    (hs : ∀ a, (s a).Countable) : (pi univ s).Countable :=\n  have := fun a ↦ (hs a).to_subtype; .of_equiv _ (Equiv.Set.univPi s).symm\n\n"}
{"name":"Set.countable_pi","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nπ : α → Type u_1\ninst✝ : Finite α\ns : (a : α) → Set (π a)\nhs : ∀ (a : α), (s a).Countable\n⊢ (setOf fun f => ∀ (a : α), Membership.mem (s a) (f a)).Countable","decl":"theorem countable_pi {π : α → Type*} [Finite α] {s : ∀ a, Set (π a)} (hs : ∀ a, (s a).Countable) :\n    { f : ∀ a, π a | ∀ a, f a ∈ s a }.Countable := by\n  simpa only [← mem_univ_pi] using countable_univ_pi hs\n\n"}
{"name":"Set.Countable.prod","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\ns : Set α\nt : Set β\nhs : s.Countable\nht : t.Countable\n⊢ (SProd.sprod s t).Countable","decl":"protected theorem Countable.prod {s : Set α} {t : Set β} (hs : s.Countable) (ht : t.Countable) :\n    Set.Countable (s ×ˢ t) :=\n  have := hs.to_subtype; have := ht.to_subtype; .of_equiv _ <| (Equiv.Set.prod _ _).symm\n\n"}
{"name":"Set.Countable.image2","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\nγ : Type w\ns : Set α\nt : Set β\nhs : s.Countable\nht : t.Countable\nf : α → β → γ\n⊢ (Set.image2 f s t).Countable","decl":"theorem Countable.image2 {s : Set α} {t : Set β} (hs : s.Countable) (ht : t.Countable)\n    (f : α → β → γ) : (image2 f s t).Countable := by\n  rw [← image_prod]\n  exact (hs.prod ht).image _\n\n"}
{"name":"Set.countable_setOf_nonempty_of_disjoint","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\nβ : Type v\nf : β → Set α\nhf : Pairwise (Function.onFun Disjoint f)\ns : Set α\nh'f : ∀ (t : β), HasSubset.Subset (f t) s\nhs : s.Countable\n⊢ (setOf fun t => (f t).Nonempty).Countable","decl":"/-- If a family of disjoint sets is included in a countable set, then only countably many of\nthem are nonempty. -/\ntheorem countable_setOf_nonempty_of_disjoint {f : β → Set α}\n    (hf : Pairwise (Disjoint on f)) {s : Set α} (h'f : ∀ t, f t ⊆ s) (hs : s.Countable) :\n    Set.Countable {t | (f t).Nonempty} := by\n  rw [← Set.countable_coe_iff] at hs ⊢\n  have : ∀ t : {t // (f t).Nonempty}, ∃ x : s, x.1 ∈ f t := by\n    rintro ⟨t, ⟨x, hx⟩⟩\n    exact ⟨⟨x, (h'f t hx)⟩, hx⟩\n  choose F hF using this\n  have A : Injective F := by\n    rintro ⟨t, ht⟩ ⟨t', ht'⟩ htt'\n    have A : (f t ∩ f t').Nonempty := by\n      refine ⟨F ⟨t, ht⟩, hF ⟨t, _⟩, ?_⟩\n      rw [htt']\n      exact hF ⟨t', _⟩\n    simp only [Subtype.mk.injEq]\n    by_contra H\n    exact not_disjoint_iff_nonempty_inter.2 A (hf H)\n  exact Injective.countable A\n\n"}
{"name":"Finset.countable_toSet","module":"Mathlib.Data.Set.Countable","initialProofState":"α : Type u\ns : Finset α\n⊢ (↑s).Countable","decl":"theorem Finset.countable_toSet (s : Finset α) : Set.Countable (↑s : Set α) :=\n  s.finite_toSet.countable\n"}
