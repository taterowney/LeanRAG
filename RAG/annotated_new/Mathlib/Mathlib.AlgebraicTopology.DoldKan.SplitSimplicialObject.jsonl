{"name":"SimplicialObject.Splitting.cofan_inj_œÄSummand_eq_id_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\nZ : C\nh : Quiver.Hom (s.N (Opposite.unop A.fst).len) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (CategoryTheory.CategoryStruct.comp (s.œÄSummand A) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_œÄSummand_eq_id [HasZeroMorphisms C] {Œî : SimplexCategory·µí·µñ} (A : IndexSet Œî) :\n    (s.cofan Œî).inj A ‚â´ s.œÄSummand A = ùüô _ := by\n  simp [œÄSummand]\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_œÄSummand_eq_id","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nŒî : Opposite SimplexCategory\nA : SimplicialObject.Splitting.IndexSet Œî\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (s.œÄSummand A)) (CategoryTheory.CategoryStruct.id (SimplicialObject.Splitting.summand s.N Œî A))","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_œÄSummand_eq_id [HasZeroMorphisms C] {Œî : SimplexCategory·µí·µñ} (A : IndexSet Œî) :\n    (s.cofan Œî).inj A ‚â´ s.œÄSummand A = ùüô _ := by\n  simp [œÄSummand]\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_œÄSummand_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nŒî : Opposite SimplexCategory\nA B : SimplicialObject.Splitting.IndexSet Œî\nh : Ne B A\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (s.œÄSummand B)) 0","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_œÄSummand_eq_zero [HasZeroMorphisms C] {Œî : SimplexCategory·µí·µñ} (A B : IndexSet Œî)\n    (h : B ‚â† A) : (s.cofan Œî).inj A ‚â´ s.œÄSummand B = 0 := by\n  dsimp [œÄSummand]\n  rw [Œπ_desc, dif_neg h.symm]\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_œÄSummand_eq_zero_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Limits.HasZeroMorphisms C\nŒî : Opposite SimplexCategory\nA B : SimplicialObject.Splitting.IndexSet Œî\nh‚úù : Ne B A\nZ : C\nh : Quiver.Hom (s.N (Opposite.unop B.fst).len) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan Œî).inj A) (CategoryTheory.CategoryStruct.comp (s.œÄSummand B) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem cofan_inj_œÄSummand_eq_zero [HasZeroMorphisms C] {Œî : SimplexCategory·µí·µñ} (A B : IndexSet Œî)\n    (h : B ‚â† A) : (s.cofan Œî).inj A ‚â´ s.œÄSummand B = 0 := by\n  dsimp [œÄSummand]\n  rw [Œπ_desc, dif_neg h.symm]\n\n"}
{"name":"SimplicialObject.Splitting.decomposition_id","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nŒî : Opposite SimplexCategory\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id (X.obj Œî)) (Finset.univ.sum fun A => CategoryTheory.CategoryStruct.comp (s.œÄSummand A) ((s.cofan Œî).inj A))","decl":"theorem decomposition_id (Œî : SimplexCategory·µí·µñ) :\n    ùüô (X.obj Œî) = ‚àë A : IndexSet Œî, s.œÄSummand A ‚â´ (s.cofan Œî).inj A := by\n  apply s.hom_ext'\n  intro A\n  dsimp\n  erw [comp_id, comp_sum, Finset.sum_eq_single A, cofan_inj_œÄSummand_eq_id_assoc]\n  ¬∑ intro B _ h‚ÇÇ\n    rw [s.cofan_inj_œÄSummand_eq_zero_assoc _ _ h‚ÇÇ, zero_comp]\n  ¬∑ simp\n\n"}
{"name":"SimplicialObject.Splitting.œÉ_comp_œÄSummand_id_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk (HAdd.hAdd n 1) }))) 0","decl":"@[reassoc (attr := simp)]\ntheorem œÉ_comp_œÄSummand_id_eq_zero {n : ‚Ñï} (i : Fin (n + 1)) :\n    X.œÉ i ‚â´ s.œÄSummand (IndexSet.id (op [n + 1])) = 0 := by\n  apply s.hom_ext'\n  intro A\n  dsimp only [SimplicialObject.œÉ]\n  rw [comp_zero, s.cofan_inj_epi_naturality_assoc A (SimplexCategory.œÉ i).op,\n    cofan_inj_œÄSummand_eq_zero]\n  rw [ne_comm]\n  change ¬¨(A.epiComp (SimplexCategory.œÉ i).op).EqId\n  rw [IndexSet.eqId_iff_len_eq]\n  have h := SimplexCategory.len_le_of_epi (inferInstance : Epi A.e)\n  dsimp at h ‚ä¢\n  omega\n\n"}
{"name":"SimplicialObject.Splitting.œÉ_comp_œÄSummand_id_eq_zero_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\ni : Fin (HAdd.hAdd n 1)\nZ : C\nh : Quiver.Hom (s.N (Opposite.unop (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk (HAdd.hAdd n 1) }).fst).len) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (X.œÉ i) (CategoryTheory.CategoryStruct.comp (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk (HAdd.hAdd n 1) })) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\ntheorem œÉ_comp_œÄSummand_id_eq_zero {n : ‚Ñï} (i : Fin (n + 1)) :\n    X.œÉ i ‚â´ s.œÄSummand (IndexSet.id (op [n + 1])) = 0 := by\n  apply s.hom_ext'\n  intro A\n  dsimp only [SimplicialObject.œÉ]\n  rw [comp_zero, s.cofan_inj_epi_naturality_assoc A (SimplexCategory.œÉ i).op,\n    cofan_inj_œÄSummand_eq_zero]\n  rw [ne_comm]\n  change ¬¨(A.epiComp (SimplexCategory.œÉ i).op).EqId\n  rw [IndexSet.eqId_iff_len_eq]\n  have h := SimplexCategory.len_le_of_epi (inferInstance : Epi A.e)\n  dsimp at h ‚ä¢\n  omega\n\n"}
{"name":"SimplicialObject.Splitting.cofan_inj_comp_PInfty_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\nn : Nat\nA : SimplicialObject.Splitting.IndexSet { unop := SimplexCategory.mk n }\nhA : Not A.EqId\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan { unop := SimplexCategory.mk n }).inj A) (AlgebraicTopology.DoldKan.PInfty.f n)) 0","decl":"/-- If a simplicial object `X` in an additive category is split,\nthen `PInfty` vanishes on all the summands of `X _[n]` which do\nnot correspond to the identity of `[n]`. -/\ntheorem cofan_inj_comp_PInfty_eq_zero {X : SimplicialObject C} (s : SimplicialObject.Splitting X)\n    {n : ‚Ñï} (A : SimplicialObject.Splitting.IndexSet (op [n])) (hA : ¬¨A.EqId) :\n    (s.cofan _).inj A ‚â´ PInfty.f n = 0 := by\n  rw [SimplicialObject.Splitting.IndexSet.eqId_iff_mono] at hA\n  rw [SimplicialObject.Splitting.cofan_inj_eq, assoc, degeneracy_comp_PInfty X n A.e hA, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.comp_PInfty_eq_zero_iff","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nZ : C\nn : Nat\nf : Quiver.Hom Z (X.obj { unop := SimplexCategory.mk n })\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (AlgebraicTopology.DoldKan.PInfty.f n)) 0) (Eq (CategoryTheory.CategoryStruct.comp f (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))) 0)","decl":"theorem comp_PInfty_eq_zero_iff {Z : C} {n : ‚Ñï} (f : Z ‚ü∂ X _[n]) :\n    f ‚â´ PInfty.f n = 0 ‚Üî f ‚â´ s.œÄSummand (IndexSet.id (op [n])) = 0 := by\n  constructor\n  ¬∑ intro h\n    rcases n with _|n\n    ¬∑ dsimp at h\n      rw [comp_id] at h\n      rw [h, zero_comp]\n    ¬∑ have h' := f ‚â´= PInfty_f_add_QInfty_f (n + 1)\n      dsimp at h'\n      rw [comp_id, comp_add, h, zero_add] at h'\n      rw [‚Üê h', assoc, QInfty_f, decomposition_Q, Preadditive.sum_comp, Preadditive.comp_sum,\n        Finset.sum_eq_zero]\n      intro i _\n      simp only [assoc, œÉ_comp_œÄSummand_id_eq_zero, comp_zero]\n  ¬∑ intro h\n    rw [‚Üê comp_id f, assoc, s.decomposition_id, Preadditive.sum_comp, Preadditive.comp_sum,\n      Fintype.sum_eq_zero]\n    intro A\n    by_cases hA : A.EqId\n    ¬∑ dsimp at hA\n      subst hA\n      rw [assoc, reassoc_of% h, zero_comp]\n    ¬∑ simp only [assoc, s.cofan_inj_comp_PInfty_eq_zero A hA, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.PInfty_comp_œÄSummand_id_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\nZ : C\nh : Quiver.Hom (s.N (Opposite.unop (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }).fst).len) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) (CategoryTheory.CategoryStruct.comp (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) h)) (CategoryTheory.CategoryStruct.comp (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) h)","decl":"@[reassoc (attr := simp)]\ntheorem PInfty_comp_œÄSummand_id (n : ‚Ñï) :\n    PInfty.f n ‚â´ s.œÄSummand (IndexSet.id (op [n])) = s.œÄSummand (IndexSet.id (op [n])) := by\n  conv_rhs => rw [‚Üê id_comp (s.œÄSummand _)]\n  symm\n  rw [‚Üê sub_eq_zero, ‚Üê sub_comp, ‚Üê comp_PInfty_eq_zero_iff, sub_comp, id_comp, PInfty_f_idem,\n    sub_self]\n\n"}
{"name":"SimplicialObject.Splitting.PInfty_comp_œÄSummand_id","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))) (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))","decl":"@[reassoc (attr := simp)]\ntheorem PInfty_comp_œÄSummand_id (n : ‚Ñï) :\n    PInfty.f n ‚â´ s.œÄSummand (IndexSet.id (op [n])) = s.œÄSummand (IndexSet.id (op [n])) := by\n  conv_rhs => rw [‚Üê id_comp (s.œÄSummand _)]\n  symm\n  rw [‚Üê sub_eq_zero, ‚Üê sub_comp, ‚Üê comp_PInfty_eq_zero_iff, sub_comp, id_comp, PInfty_f_idem,\n    sub_self]\n\n"}
{"name":"SimplicialObject.Splitting.œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty_assoc","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\nZ : C\nh : Quiver.Hom ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).X n) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp ((s.cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) h))) (CategoryTheory.CategoryStruct.comp (AlgebraicTopology.DoldKan.PInfty.f n) h)","decl":"@[reassoc (attr := simp)]\ntheorem œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty (n : ‚Ñï) :\n    s.œÄSummand (IndexSet.id (op [n])) ‚â´ (s.cofan _).inj (IndexSet.id (op [n])) ‚â´ PInfty.f n =\n      PInfty.f n := by\n  conv_rhs => rw [‚Üê id_comp (PInfty.f n)]\n  erw [s.decomposition_id, Preadditive.sum_comp]\n  rw [Fintype.sum_eq_single (IndexSet.id (op [n])), assoc]\n  rintro A (hA : ¬¨A.EqId)\n  rw [assoc, s.cofan_inj_comp_PInfty_eq_zero A hA, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (CategoryTheory.CategoryStruct.comp ((s.cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (AlgebraicTopology.DoldKan.PInfty.f n))) (AlgebraicTopology.DoldKan.PInfty.f n)","decl":"@[reassoc (attr := simp)]\ntheorem œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty (n : ‚Ñï) :\n    s.œÄSummand (IndexSet.id (op [n])) ‚â´ (s.cofan _).inj (IndexSet.id (op [n])) ‚â´ PInfty.f n =\n      PInfty.f n := by\n  conv_rhs => rw [‚Üê id_comp (PInfty.f n)]\n  erw [s.decomposition_id, Preadditive.sum_comp]\n  rw [Fintype.sum_eq_single (IndexSet.id (op [n])), assoc]\n  rintro A (hA : ¬¨A.EqId)\n  rw [assoc, s.cofan_inj_comp_PInfty_eq_zero A hA, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.ŒπSummand_comp_d_comp_œÄSummand_eq_zero","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nj k : Nat\nA : SimplicialObject.Splitting.IndexSet { unop := SimplexCategory.mk j }\nhA : Not A.EqId\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp ((s.cofan { unop := SimplexCategory.mk j }).inj A) (CategoryTheory.CategoryStruct.comp ((AlgebraicTopology.AlternatingFaceMapComplex.obj X).d j k) (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk k })))) 0","decl":"theorem ŒπSummand_comp_d_comp_œÄSummand_eq_zero (j k : ‚Ñï) (A : IndexSet (op [j])) (hA : ¬¨A.EqId) :\n    (s.cofan _).inj A ‚â´ K[X].d j k ‚â´ s.œÄSummand (IndexSet.id (op [k])) = 0 := by\n  rw [A.eqId_iff_mono] at hA\n  rw [‚Üê assoc, ‚Üê s.comp_PInfty_eq_zero_iff, assoc, ‚Üê PInfty.comm j k, s.cofan_inj_eq, assoc,\n    degeneracy_comp_PInfty_assoc X j A.e hA, zero_comp, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.nondegComplex_X","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\na‚úù : Nat\n‚ä¢ Eq (s.nondegComplex.X a‚úù) (s.N a‚úù)","decl":"/-- If `s` is a splitting of a simplicial object `X` in a preadditive category,\n`s.nondegComplex` is a chain complex which is given in degree `n` by\nthe nondegenerate `n`-simplices of `X`. -/\n@[simps]\nnoncomputable def nondegComplex : ChainComplex C ‚Ñï where\n  X := s.N\n  d := s.d\n  shape i j hij := by simp only [d, K[X].shape i j hij, zero_comp, comp_zero]\n  d_comp_d' i j k _ _ := by\n    simp only [d, assoc]\n    have eq : K[X].d i j ‚â´ ùüô (X.obj (op [j])) ‚â´ K[X].d j k ‚â´\n        s.œÄSummand (IndexSet.id (op [k])) = 0 := by\n      simp\n    rw [s.decomposition_id] at eq\n    classical\n    rw [Fintype.sum_eq_add_sum_compl (IndexSet.id (op [j])), add_comp, comp_add, assoc,\n      Preadditive.sum_comp, Preadditive.comp_sum, Finset.sum_eq_zero, add_zero] at eq\n    swap\n    ¬∑ intro A hA\n      simp only [Finset.mem_compl, Finset.mem_singleton] at hA\n      simp only [assoc, ŒπSummand_comp_d_comp_œÄSummand_eq_zero _ _ _ _ hA, comp_zero]\n    rw [eq, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.nondegComplex_d","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\ni j : Nat\n‚ä¢ Eq (s.nondegComplex.d i j) (s.d i j)","decl":"/-- If `s` is a splitting of a simplicial object `X` in a preadditive category,\n`s.nondegComplex` is a chain complex which is given in degree `n` by\nthe nondegenerate `n`-simplices of `X`. -/\n@[simps]\nnoncomputable def nondegComplex : ChainComplex C ‚Ñï where\n  X := s.N\n  d := s.d\n  shape i j hij := by simp only [d, K[X].shape i j hij, zero_comp, comp_zero]\n  d_comp_d' i j k _ _ := by\n    simp only [d, assoc]\n    have eq : K[X].d i j ‚â´ ùüô (X.obj (op [j])) ‚â´ K[X].d j k ‚â´\n        s.œÄSummand (IndexSet.id (op [k])) = 0 := by\n      simp\n    rw [s.decomposition_id] at eq\n    classical\n    rw [Fintype.sum_eq_add_sum_compl (IndexSet.id (op [j])), add_comp, comp_add, assoc,\n      Preadditive.sum_comp, Preadditive.comp_sum, Finset.sum_eq_zero, add_zero] at eq\n    swap\n    ¬∑ intro A hA\n      simp only [Finset.mem_compl, Finset.mem_singleton] at hA\n      simp only [assoc, ŒπSummand_comp_d_comp_œÄSummand_eq_zero _ _ _ _ hA, comp_zero]\n    rw [eq, comp_zero]\n\n"}
{"name":"SimplicialObject.Splitting.toKaroubiNondegComplexIsoN‚ÇÅ_inv_f_f","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\n‚ä¢ Eq (s.toKaroubiNondegComplexIsoN‚ÇÅ.inv.f.f n) (s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))","decl":"/-- The chain complex `s.nondegComplex` attached to a splitting of a simplicial object `X`\nbecomes isomorphic to the normalized Moore complex `N‚ÇÅ.obj X` defined as a formal direct\nfactor in the category `Karoubi (ChainComplex C ‚Ñï)`. -/\n@[simps]\nnoncomputable def toKaroubiNondegComplexIsoN‚ÇÅ :\n    (toKaroubi _).obj s.nondegComplex ‚âÖ N‚ÇÅ.obj X where\n  hom :=\n    { f :=\n        { f := fun n => (s.cofan _).inj (IndexSet.id (op [n])) ‚â´ PInfty.f n\n          comm' := fun i j _ => by\n            dsimp\n            rw [assoc, assoc, assoc, œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty,\n              HomologicalComplex.Hom.comm] }\n      comm := by\n        ext n\n        dsimp\n        rw [id_comp, assoc, PInfty_f_idem] }\n  inv :=\n    { f :=\n        { f := fun n => s.œÄSummand (IndexSet.id (op [n]))\n          comm' := fun i j _ => by\n            dsimp\n            slice_rhs 1 1 => rw [‚Üê id_comp (K[X].d i j)]\n            erw [s.decomposition_id]\n            rw [sum_comp, sum_comp, Finset.sum_eq_single (IndexSet.id (op [i])), assoc, assoc]\n            ¬∑ intro A _ hA\n              simp only [assoc, s.ŒπSummand_comp_d_comp_œÄSummand_eq_zero _ _ _ hA, comp_zero]\n            ¬∑ simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff] }\n      comm := by\n        ext n\n        dsimp\n        simp only [comp_id, PInfty_comp_œÄSummand_id] }\n  hom_inv_id := by\n    ext n\n    simp only [assoc, PInfty_comp_œÄSummand_id, Karoubi.comp_f, HomologicalComplex.comp_f,\n      cofan_inj_œÄSummand_eq_id]\n    rfl\n  inv_hom_id := by\n    ext n\n    simp only [œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty, Karoubi.comp_f,\n      HomologicalComplex.comp_f, N‚ÇÅ_obj_p, Karoubi.id_f]\n\n"}
{"name":"SimplicialObject.Splitting.toKaroubiNondegComplexIsoN‚ÇÅ_hom_f_f","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.SimplicialObject C\ns : SimplicialObject.Splitting X\ninst‚úù : CategoryTheory.Preadditive C\nn : Nat\n‚ä¢ Eq (s.toKaroubiNondegComplexIsoN‚ÇÅ.hom.f.f n) (CategoryTheory.CategoryStruct.comp ((s.cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (AlgebraicTopology.DoldKan.PInfty.f n))","decl":"/-- The chain complex `s.nondegComplex` attached to a splitting of a simplicial object `X`\nbecomes isomorphic to the normalized Moore complex `N‚ÇÅ.obj X` defined as a formal direct\nfactor in the category `Karoubi (ChainComplex C ‚Ñï)`. -/\n@[simps]\nnoncomputable def toKaroubiNondegComplexIsoN‚ÇÅ :\n    (toKaroubi _).obj s.nondegComplex ‚âÖ N‚ÇÅ.obj X where\n  hom :=\n    { f :=\n        { f := fun n => (s.cofan _).inj (IndexSet.id (op [n])) ‚â´ PInfty.f n\n          comm' := fun i j _ => by\n            dsimp\n            rw [assoc, assoc, assoc, œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty,\n              HomologicalComplex.Hom.comm] }\n      comm := by\n        ext n\n        dsimp\n        rw [id_comp, assoc, PInfty_f_idem] }\n  inv :=\n    { f :=\n        { f := fun n => s.œÄSummand (IndexSet.id (op [n]))\n          comm' := fun i j _ => by\n            dsimp\n            slice_rhs 1 1 => rw [‚Üê id_comp (K[X].d i j)]\n            erw [s.decomposition_id]\n            rw [sum_comp, sum_comp, Finset.sum_eq_single (IndexSet.id (op [i])), assoc, assoc]\n            ¬∑ intro A _ hA\n              simp only [assoc, s.ŒπSummand_comp_d_comp_œÄSummand_eq_zero _ _ _ hA, comp_zero]\n            ¬∑ simp only [Finset.mem_univ, not_true, IsEmpty.forall_iff] }\n      comm := by\n        ext n\n        dsimp\n        simp only [comp_id, PInfty_comp_œÄSummand_id] }\n  hom_inv_id := by\n    ext n\n    simp only [assoc, PInfty_comp_œÄSummand_id, Karoubi.comp_f, HomologicalComplex.comp_f,\n      cofan_inj_œÄSummand_eq_id]\n    rfl\n  inv_hom_id := by\n    ext n\n    simp only [œÄSummand_comp_cofan_inj_id_comp_PInfty_eq_PInfty, Karoubi.comp_f,\n      HomologicalComplex.comp_f, N‚ÇÅ_obj_p, Karoubi.id_f]\n\n"}
{"name":"SimplicialObject.Split.nondegComplexFunctor_obj","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nS : SimplicialObject.Split C\n‚ä¢ Eq (SimplicialObject.Split.nondegComplexFunctor.obj S) S.s.nondegComplex","decl":"/-- The functor which sends a split simplicial object in a preadditive category to\nthe chain complex which consists of nondegenerate simplices. -/\n@[simps]\nnoncomputable def nondegComplexFunctor : Split C ‚•§ ChainComplex C ‚Ñï where\n  obj S := S.s.nondegComplex\n  map {S‚ÇÅ S‚ÇÇ} Œ¶ :=\n    { f := Œ¶.f\n      comm' := fun i j _ => by\n        dsimp\n        erw [‚Üê cofan_inj_naturality_symm_assoc Œ¶ (Splitting.IndexSet.id (op [i])),\n          ((alternatingFaceMapComplex C).map Œ¶.F).comm_assoc i j]\n        simp only [assoc]\n        congr 2\n        apply S‚ÇÅ.s.hom_ext'\n        intro A\n        dsimp [alternatingFaceMapComplex]\n        rw [cofan_inj_naturality_symm_assoc Œ¶ A]\n        by_cases h : A.EqId\n        ¬∑ dsimp at h\n          subst h\n          rw [Splitting.cofan_inj_œÄSummand_eq_id]\n          dsimp\n          rw [comp_id, Splitting.cofan_inj_œÄSummand_eq_id_assoc]\n        ¬∑ rw [S‚ÇÅ.s.cofan_inj_œÄSummand_eq_zero_assoc _ _ (Ne.symm h),\n            S‚ÇÇ.s.cofan_inj_œÄSummand_eq_zero _ _ (Ne.symm h), zero_comp, comp_zero] }\n\n"}
{"name":"SimplicialObject.Split.nondegComplexFunctor_map_f","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nS‚ÇÅ S‚ÇÇ : SimplicialObject.Split C\nŒ¶ : Quiver.Hom S‚ÇÅ S‚ÇÇ\nn : Nat\n‚ä¢ Eq ((SimplicialObject.Split.nondegComplexFunctor.map Œ¶).f n) (Œ¶.f n)","decl":"/-- The functor which sends a split simplicial object in a preadditive category to\nthe chain complex which consists of nondegenerate simplices. -/\n@[simps]\nnoncomputable def nondegComplexFunctor : Split C ‚•§ ChainComplex C ‚Ñï where\n  obj S := S.s.nondegComplex\n  map {S‚ÇÅ S‚ÇÇ} Œ¶ :=\n    { f := Œ¶.f\n      comm' := fun i j _ => by\n        dsimp\n        erw [‚Üê cofan_inj_naturality_symm_assoc Œ¶ (Splitting.IndexSet.id (op [i])),\n          ((alternatingFaceMapComplex C).map Œ¶.F).comm_assoc i j]\n        simp only [assoc]\n        congr 2\n        apply S‚ÇÅ.s.hom_ext'\n        intro A\n        dsimp [alternatingFaceMapComplex]\n        rw [cofan_inj_naturality_symm_assoc Œ¶ A]\n        by_cases h : A.EqId\n        ¬∑ dsimp at h\n          subst h\n          rw [Splitting.cofan_inj_œÄSummand_eq_id]\n          dsimp\n          rw [comp_id, Splitting.cofan_inj_œÄSummand_eq_id_assoc]\n        ¬∑ rw [S‚ÇÅ.s.cofan_inj_œÄSummand_eq_zero_assoc _ _ (Ne.symm h),\n            S‚ÇÇ.s.cofan_inj_œÄSummand_eq_zero _ _ (Ne.symm h), zero_comp, comp_zero] }\n\n"}
{"name":"SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoN‚ÇÅ_hom_app_f_f","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : SimplicialObject.Split C\nn : Nat\n‚ä¢ Eq ((SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoN‚ÇÅ.hom.app X).f.f n) (CategoryTheory.CategoryStruct.comp ((X.s.cofan { unop := SimplexCategory.mk n }).inj (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n })) (AlgebraicTopology.DoldKan.PInfty.f n))","decl":"/-- The natural isomorphism (in `Karoubi (ChainComplex C ‚Ñï)`) between the chain complex\nof nondegenerate simplices of a split simplicial object and the normalized Moore complex\ndefined as a formal direct factor of the alternating face map complex. -/\n@[simps!]\nnoncomputable def toKaroubiNondegComplexFunctorIsoN‚ÇÅ :\n    nondegComplexFunctor ‚ãô toKaroubi (ChainComplex C ‚Ñï) ‚âÖ forget C ‚ãô DoldKan.N‚ÇÅ :=\n  NatIso.ofComponents (fun S => S.s.toKaroubiNondegComplexIsoN‚ÇÅ) fun Œ¶ => by\n    ext n\n    dsimp\n    simp only [Karoubi.comp_f, toKaroubi_map_f, HomologicalComplex.comp_f,\n      nondegComplexFunctor_map_f, Splitting.toKaroubiNondegComplexIsoN‚ÇÅ_hom_f_f, N‚ÇÅ_map_f,\n      AlternatingFaceMapComplex.map_f, assoc, PInfty_f_idem_assoc]\n    erw [‚Üê Split.cofan_inj_naturality_symm_assoc Œ¶ (Splitting.IndexSet.id (op [n]))]\n    rw [PInfty_f_naturality]\n\n"}
{"name":"SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoN‚ÇÅ_inv_app_f_f","module":"Mathlib.AlgebraicTopology.DoldKan.SplitSimplicialObject","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_2, u_1} C\ninst‚úù : CategoryTheory.Preadditive C\nX : SimplicialObject.Split C\nn : Nat\n‚ä¢ Eq ((SimplicialObject.Split.toKaroubiNondegComplexFunctorIsoN‚ÇÅ.inv.app X).f.f n) (X.s.œÄSummand (SimplicialObject.Splitting.IndexSet.id { unop := SimplexCategory.mk n }))","decl":"/-- The natural isomorphism (in `Karoubi (ChainComplex C ‚Ñï)`) between the chain complex\nof nondegenerate simplices of a split simplicial object and the normalized Moore complex\ndefined as a formal direct factor of the alternating face map complex. -/\n@[simps!]\nnoncomputable def toKaroubiNondegComplexFunctorIsoN‚ÇÅ :\n    nondegComplexFunctor ‚ãô toKaroubi (ChainComplex C ‚Ñï) ‚âÖ forget C ‚ãô DoldKan.N‚ÇÅ :=\n  NatIso.ofComponents (fun S => S.s.toKaroubiNondegComplexIsoN‚ÇÅ) fun Œ¶ => by\n    ext n\n    dsimp\n    simp only [Karoubi.comp_f, toKaroubi_map_f, HomologicalComplex.comp_f,\n      nondegComplexFunctor_map_f, Splitting.toKaroubiNondegComplexIsoN‚ÇÅ_hom_f_f, N‚ÇÅ_map_f,\n      AlternatingFaceMapComplex.map_f, assoc, PInfty_f_idem_assoc]\n    erw [‚Üê Split.cofan_inj_naturality_symm_assoc Œ¶ (Splitting.IndexSet.id (op [n]))]\n    rw [PInfty_f_naturality]\n\n"}
