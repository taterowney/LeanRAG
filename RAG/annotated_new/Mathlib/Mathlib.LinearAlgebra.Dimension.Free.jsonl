{"name":"lift_rank_mul_lift_rank","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"F : Type u\nK : Type v\nA : Type w\ninst✝¹⁰ : Semiring F\ninst✝⁹ : Semiring K\ninst✝⁸ : AddCommMonoid A\ninst✝⁷ : Module F K\ninst✝⁶ : Module K A\ninst✝⁵ : Module F A\ninst✝⁴ : IsScalarTower F K A\ninst✝³ : StrongRankCondition F\ninst✝² : StrongRankCondition K\ninst✝¹ : Module.Free F K\ninst✝ : Module.Free K A\n⊢ Eq (HMul.hMul (Cardinal.lift.{w, v} (Module.rank F K)) (Cardinal.lift.{v, w} (Module.rank K A))) (Cardinal.lift.{v, w} (Module.rank F A))","decl":"/-- Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$.\n\nThe universe polymorphic version of `rank_mul_rank` below. -/\ntheorem lift_rank_mul_lift_rank :\n    Cardinal.lift.{w} (Module.rank F K) * Cardinal.lift.{v} (Module.rank K A) =\n      Cardinal.lift.{v} (Module.rank F A) := by\n  let b := Module.Free.chooseBasis F K\n  let c := Module.Free.chooseBasis K A\n  rw [← (Module.rank F K).lift_id, ← b.mk_eq_rank, ← (Module.rank K A).lift_id, ← c.mk_eq_rank,\n    ← lift_umax.{w, v}, ← (b.smulTower c).mk_eq_rank, mk_prod, lift_mul, lift_lift, lift_lift,\n    lift_lift, lift_lift, lift_umax.{v, w}]\n\n"}
{"name":"rank_mul_rank","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"F : Type u\nK : Type v\ninst✝¹⁰ : Semiring F\ninst✝⁹ : Semiring K\ninst✝⁸ : Module F K\ninst✝⁷ : StrongRankCondition F\ninst✝⁶ : StrongRankCondition K\ninst✝⁵ : Module.Free F K\nA : Type v\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module K A\ninst✝² : Module F A\ninst✝¹ : IsScalarTower F K A\ninst✝ : Module.Free K A\n⊢ Eq (HMul.hMul (Module.rank F K) (Module.rank K A)) (Module.rank F A)","decl":"/-- Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$.\n\nThis is a simpler version of `lift_rank_mul_lift_rank` with `K` and `A` in the same universe. -/\n@[stacks 09G9]\ntheorem rank_mul_rank (A : Type v) [AddCommGroup A]\n    [Module K A] [Module F A] [IsScalarTower F K A] [Module.Free K A] :\n    Module.rank F K * Module.rank K A = Module.rank F A := by\n  convert lift_rank_mul_lift_rank F K A <;> rw [lift_id]\n\n"}
{"name":"Module.finrank_mul_finrank","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"F : Type u\nK : Type v\nA : Type w\ninst✝¹⁰ : Semiring F\ninst✝⁹ : Semiring K\ninst✝⁸ : AddCommMonoid A\ninst✝⁷ : Module F K\ninst✝⁶ : Module K A\ninst✝⁵ : Module F A\ninst✝⁴ : IsScalarTower F K A\ninst✝³ : StrongRankCondition F\ninst✝² : StrongRankCondition K\ninst✝¹ : Module.Free F K\ninst✝ : Module.Free K A\n⊢ Eq (HMul.hMul (Module.finrank F K) (Module.finrank K A)) (Module.finrank F A)","decl":"/-- Tower law: if `A` is a `K`-module and `K` is an extension of `F` then\n$\\operatorname{rank}_F(A) = \\operatorname{rank}_F(K) * \\operatorname{rank}_K(A)$. -/\ntheorem Module.finrank_mul_finrank : finrank F K * finrank K A = finrank F A := by\n  simp_rw [finrank]\n  rw [← toNat_lift.{w} (Module.rank F K), ← toNat_lift.{v} (Module.rank K A), ← toNat_mul,\n    lift_rank_mul_lift_rank, toNat_lift]\n\n"}
{"name":"Module.Free.rank_eq_card_chooseBasisIndex","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\n⊢ Eq (Module.rank R M) (Cardinal.mk (Module.Free.ChooseBasisIndex R M))","decl":"/-- The rank of a free module `M` over `R` is the cardinality of `ChooseBasisIndex R M`. -/\ntheorem rank_eq_card_chooseBasisIndex : Module.rank R M = #(ChooseBasisIndex R M) :=\n  (chooseBasis R M).mk_eq_rank''.symm\n\n"}
{"name":"Module.finrank_eq_card_chooseBasisIndex","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : StrongRankCondition R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\n⊢ Eq (Module.finrank R M) (Fintype.card (Module.Free.ChooseBasisIndex R M))","decl":"/-- The finrank of a free module `M` over `R` is the cardinality of `ChooseBasisIndex R M`. -/\ntheorem _root_.Module.finrank_eq_card_chooseBasisIndex [Module.Finite R M] :\n    finrank R M = Fintype.card (ChooseBasisIndex R M) := by\n  simp [finrank, rank_eq_card_chooseBasisIndex]\n\n"}
{"name":"Module.Free.rank_eq_mk_of_infinite_lt","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : StrongRankCondition R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\ninst✝ : Infinite R\nh_lt : LT.lt (Cardinal.lift.{v, u} (Cardinal.mk R)) (Cardinal.lift.{u, v} (Cardinal.mk M))\n⊢ Eq (Module.rank R M) (Cardinal.mk M)","decl":"/-- The rank of a free module `M` over an infinite scalar ring `R` is the cardinality of `M`\nwhenever `#R < #M`. -/\nlemma rank_eq_mk_of_infinite_lt [Infinite R] (h_lt : lift.{v} #R < lift.{u} #M) :\n    Module.rank R M = #M := by\n  have : Infinite M := infinite_iff.mpr <| lift_le.mp <| le_trans (by simp) h_lt.le\n  have h : lift #M = lift #(ChooseBasisIndex R M →₀ R) := lift_mk_eq'.mpr ⟨(chooseBasis R M).repr⟩\n  simp only [mk_finsupp_lift_of_infinite', lift_id', ← rank_eq_card_chooseBasisIndex, lift_max,\n    lift_lift] at h\n  refine lift_inj.mp ((max_eq_iff.mp h.symm).resolve_right <| not_and_of_not_left _ ?_).left\n  exact (lift_umax.{v, u}.symm ▸ h_lt).ne\n\n"}
{"name":"nonempty_linearEquiv_of_lift_rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁷ : Semiring R\ninst✝⁶ : StrongRankCondition R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\ninst✝ : Module.Free R M'\ncnd : Eq (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R M'))\n⊢ Nonempty (LinearEquiv (RingHom.id R) M M')","decl":"/-- Two vector spaces are isomorphic if they have the same dimension. -/\ntheorem nonempty_linearEquiv_of_lift_rank_eq\n    (cnd : Cardinal.lift.{v'} (Module.rank R M) = Cardinal.lift.{v} (Module.rank R M')) :\n    Nonempty (M ≃ₗ[R] M') := by\n  obtain ⟨⟨α, B⟩⟩ := Module.Free.exists_basis (R := R) (M := M)\n  obtain ⟨⟨β, B'⟩⟩ := Module.Free.exists_basis (R := R) (M := M')\n  have : Cardinal.lift.{v', v} #α = Cardinal.lift.{v, v'} #β := by\n    rw [B.mk_eq_rank'', cnd, B'.mk_eq_rank'']\n  exact (Cardinal.lift_mk_eq.{v, v', 0}.1 this).map (B.equiv B')\n\n"}
{"name":"nonempty_linearEquiv_of_rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁷ : Semiring R\ninst✝⁶ : StrongRankCondition R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M₁\ninst✝ : Module.Free R M₁\ncond : Eq (Module.rank R M) (Module.rank R M₁)\n⊢ Nonempty (LinearEquiv (RingHom.id R) M M₁)","decl":"/-- Two vector spaces are isomorphic if they have the same dimension. -/\ntheorem nonempty_linearEquiv_of_rank_eq (cond : Module.rank R M = Module.rank R M₁) :\n    Nonempty (M ≃ₗ[R] M₁) :=\n  nonempty_linearEquiv_of_lift_rank_eq <| congr_arg _ cond\n\n"}
{"name":"LinearEquiv.nonempty_equiv_iff_lift_rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁷ : Semiring R\ninst✝⁶ : StrongRankCondition R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\ninst✝ : Module.Free R M'\n⊢ Iff (Nonempty (LinearEquiv (RingHom.id R) M M')) (Eq (Cardinal.lift.{v', v} (Module.rank R M)) (Cardinal.lift.{v, v'} (Module.rank R M')))","decl":"/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem LinearEquiv.nonempty_equiv_iff_lift_rank_eq : Nonempty (M ≃ₗ[R] M') ↔\n    Cardinal.lift.{v'} (Module.rank R M) = Cardinal.lift.{v} (Module.rank R M') :=\n  ⟨fun ⟨h⟩ => LinearEquiv.lift_rank_eq h, fun h => nonempty_linearEquiv_of_lift_rank_eq h⟩\n\n"}
{"name":"LinearEquiv.nonempty_equiv_iff_rank_eq","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM M₁ : Type v\ninst✝⁷ : Semiring R\ninst✝⁶ : StrongRankCondition R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\ninst✝² : AddCommMonoid M₁\ninst✝¹ : Module R M₁\ninst✝ : Module.Free R M₁\n⊢ Iff (Nonempty (LinearEquiv (RingHom.id R) M M₁)) (Eq (Module.rank R M) (Module.rank R M₁))","decl":"/-- Two vector spaces are isomorphic if and only if they have the same dimension. -/\ntheorem LinearEquiv.nonempty_equiv_iff_rank_eq :\n    Nonempty (M ≃ₗ[R] M₁) ↔ Module.rank R M = Module.rank R M₁ :=\n  ⟨fun ⟨h⟩ => LinearEquiv.rank_eq h, fun h => nonempty_linearEquiv_of_rank_eq h⟩\n\n"}
{"name":"FiniteDimensional.nonempty_linearEquiv_of_finrank_eq","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁹ : Semiring R\ninst✝⁸ : StrongRankCondition R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module.Free R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\ninst✝² : Module.Free R M'\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Finite R M'\ncond : Eq (Module.finrank R M) (Module.finrank R M')\n⊢ Nonempty (LinearEquiv (RingHom.id R) M M')","decl":"/-- Two finite and free modules are isomorphic if they have the same (finite) rank. -/\ntheorem FiniteDimensional.nonempty_linearEquiv_of_finrank_eq\n    [Module.Finite R M] [Module.Finite R M'] (cond : finrank R M = finrank R M') :\n    Nonempty (M ≃ₗ[R] M') :=\n  nonempty_linearEquiv_of_lift_rank_eq <| by simp only [← finrank_eq_rank, cond, lift_natCast]\n\n"}
{"name":"FiniteDimensional.nonempty_linearEquiv_iff_finrank_eq","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\nM' : Type v'\ninst✝⁹ : Semiring R\ninst✝⁸ : StrongRankCondition R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : Module.Free R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\ninst✝² : Module.Free R M'\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Finite R M'\n⊢ Iff (Nonempty (LinearEquiv (RingHom.id R) M M')) (Eq (Module.finrank R M) (Module.finrank R M'))","decl":"/-- Two finite and free modules are isomorphic if and only if they have the same (finite) rank. -/\ntheorem FiniteDimensional.nonempty_linearEquiv_iff_finrank_eq [Module.Finite R M]\n    [Module.Finite R M'] : Nonempty (M ≃ₗ[R] M') ↔ finrank R M = finrank R M' :=\n  ⟨fun ⟨h⟩ => h.finrank_eq, fun h => nonempty_linearEquiv_of_finrank_eq h⟩\n\n"}
{"name":"Module.subsingleton_of_rank_zero","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : Eq (Module.rank R M) 0\n⊢ Subsingleton M","decl":"/-- A free module of rank zero is trivial. -/\nlemma subsingleton_of_rank_zero (h : Module.rank R M = 0) : Subsingleton M := by\n  rw [← Basis.mk_eq_rank'' (Module.Free.chooseBasis R M), Cardinal.mk_eq_zero_iff] at h\n  exact (Module.Free.repr R M).subsingleton\n\n"}
{"name":"Module.rank_lt_aleph0_iff","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\n⊢ Iff (LT.lt (Module.rank R M) Cardinal.aleph0) (Module.Finite R M)","decl":"/-- See `rank_lt_aleph0` for the inverse direction without `Module.Free R M`. -/\nlemma rank_lt_aleph0_iff : Module.rank R M < ℵ₀ ↔ Module.Finite R M := by\n  rw [Free.rank_eq_card_chooseBasisIndex, mk_lt_aleph0_iff]\n  exact ⟨fun h ↦ Finite.of_basis (Free.chooseBasis R M),\n    fun I ↦ Finite.of_fintype (Free.ChooseBasisIndex R M)⟩\n\n"}
{"name":"Module.finrank_of_not_finite","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : Not (Module.Finite R M)\n⊢ Eq (Module.finrank R M) 0","decl":"theorem finrank_of_not_finite (h : ¬Module.Finite R M) : finrank R M = 0 := by\n  rw [finrank, toNat_eq_zero, ← not_lt, Module.rank_lt_aleph0_iff]\n  exact .inr h\n\n"}
{"name":"Module.finite_of_finrank_pos","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nh : LT.lt 0 (Module.finrank R M)\n⊢ Module.Finite R M","decl":"theorem finite_of_finrank_pos (h : 0 < finrank R M) : Module.Finite R M := by\n  contrapose h\n  simp [finrank_of_not_finite h]\n\n"}
{"name":"Module.finite_of_finrank_eq_succ","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁴ : Semiring R\ninst✝³ : StrongRankCondition R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Free R M\nn : Nat\nhn : Eq (Module.finrank R M) n.succ\n⊢ Module.Finite R M","decl":"theorem finite_of_finrank_eq_succ {n : ℕ} (hn : finrank R M = n.succ) : Module.Finite R M :=\n  finite_of_finrank_pos <| by rw [hn]; exact n.succ_pos\n\n"}
{"name":"Module.finite_iff_of_rank_eq_nsmul","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁷ : Semiring R\ninst✝⁶ : StrongRankCondition R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module.Free R M\nW : Type v\ninst✝² : AddCommGroup W\ninst✝¹ : Module R W\ninst✝ : Module.Free R W\nn : Nat\nhn : Ne n 0\nhVW : Eq (Module.rank R M) (HSMul.hSMul n (Module.rank R W))\n⊢ Iff (Module.Finite R M) (Module.Finite R W)","decl":"theorem finite_iff_of_rank_eq_nsmul {W} [AddCommGroup W] [Module R W] [Module.Free R W] {n : ℕ}\n    (hn : n ≠ 0) (hVW : Module.rank R M = n • Module.rank R W) :\n    Module.Finite R M ↔ Module.Finite R W := by\n  simp only [← rank_lt_aleph0_iff, hVW, nsmul_lt_aleph0_iff_of_ne_zero hn]\n\n"}
{"name":"Module.basisUnique_repr_eq_zero_iff","module":"Mathlib.LinearAlgebra.Dimension.Free","initialProofState":"R : Type u\nM : Type v\ninst✝⁵ : Semiring R\ninst✝⁴ : StrongRankCondition R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Module.Free R M\nι : Type u_1\ninst✝ : Unique ι\nh : Eq (Module.finrank R M) 1\nv : M\ni : ι\n⊢ Iff (Eq (((Module.basisUnique ι h).repr v) i) 0) (Eq v 0)","decl":"@[simp]\ntheorem basisUnique_repr_eq_zero_iff {ι : Type*} [Unique ι]\n    {h : finrank R M = 1} {v : M} {i : ι} :\n    (basisUnique ι h).repr v i = 0 ↔ v = 0 :=\n  ⟨fun hv =>\n    (basisUnique ι h).repr.map_eq_zero_iff.mp (Finsupp.ext fun j => Subsingleton.elim i j ▸ hv),\n    fun hv => by rw [hv, LinearEquiv.map_zero, Finsupp.zero_apply]⟩\n\n"}
