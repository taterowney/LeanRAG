{"name":"CategoryTheory.Presieve.BindStruct.hf","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nself : S.BindStruct R h\n⊢ S self.f","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y)\n    {Z : C} (h : Z ⟶ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ⟶ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ⟶ X\n  hf : S f\n  hg : R hf g\n  fac : g ≫ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nY✝ : C\ng✝ : Quiver.Hom Z Y✝\nf✝ : Quiver.Hom Y✝ X\nhf✝ : S f✝\nhg✝ : R hf✝ g✝\nfac✝ : Eq (CategoryTheory.CategoryStruct.comp g✝ f✝) h\nY : C\ng : Quiver.Hom Z Y\nf : Quiver.Hom Y X\nhf : S f\nhg : R hf g\nfac : Eq (CategoryTheory.CategoryStruct.comp g f) h\n⊢ Eq (Eq { Y := Y✝, g := g✝, f := f✝, hf := hf✝, hg := hg✝, fac := fac✝ } { Y := Y, g := g, f := f, hf := hf, hg := hg, fac := fac }) (And (Eq Y✝ Y) (And (HEq g✝ g) (HEq f✝ f)))","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y)\n    {Z : C} (h : Z ⟶ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ⟶ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ⟶ X\n  hf : S f\n  hg : R hf g\n  fac : g ≫ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.fac","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nself : S.BindStruct R h\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.g self.f) h","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y)\n    {Z : C} (h : Z ⟶ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ⟶ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ⟶ X\n  hf : S f\n  hg : R hf g\n  fac : g ≫ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nY✝ : C\ng✝ : Quiver.Hom Z Y✝\nf✝ : Quiver.Hom Y✝ X\nhf✝ : S f✝\nhg✝ : R hf✝ g✝\nfac✝ : Eq (CategoryTheory.CategoryStruct.comp g✝ f✝) h\nY : C\ng : Quiver.Hom Z Y\nf : Quiver.Hom Y X\nhf : S f\nhg : R hf g\nfac : Eq (CategoryTheory.CategoryStruct.comp g f) h\nx✝ : Eq { Y := Y✝, g := g✝, f := f✝, hf := hf✝, hg := hg✝, fac := fac✝ } { Y := Y, g := g, f := f, hf := hf, hg := hg, fac := fac }\n⊢ And (Eq Y✝ Y) (And (HEq g✝ g) (HEq f✝ f))","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y)\n    {Z : C} (h : Z ⟶ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ⟶ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ⟶ X\n  hf : S f\n  hg : R hf g\n  fac : g ≫ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.hg","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nself : S.BindStruct R h\n⊢ R ⋯ self.g","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y)\n    {Z : C} (h : Z ⟶ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ⟶ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ⟶ X\n  hf : S f\n  hg : R hf g\n  fac : g ≫ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\ninst✝² : SizeOf C\ninst✝¹ : ⦃Y : C⦄ → (a : Quiver.Hom Y X) → SizeOf (S a)\ninst✝ : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → (a : S f) → ⦃Y_1 : C⦄ → (a_1 : Quiver.Hom Y_1 Y) → SizeOf (R a a_1)\nY : C\ng : Quiver.Hom Z Y\nf : Quiver.Hom Y X\nhf : S f\nhg : R hf g\nfac : Eq (CategoryTheory.CategoryStruct.comp g f) h\n⊢ Eq (SizeOf.sizeOf { Y := Y, g := g, f := f, hf := hf, hg := hg, fac := fac }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Y)) (SizeOf.sizeOf g)) (SizeOf.sizeOf f)) (SizeOf.sizeOf hf)) (SizeOf.sizeOf hg)) (SizeOf.sizeOf fac))","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y)\n    {Z : C} (h : Z ⟶ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ⟶ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ⟶ X\n  hf : S f\n  hg : R hf g\n  fac : g ≫ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.fac_assoc","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ✝ : C\nh✝ : Quiver.Hom Z✝ X\nself : S.BindStruct R h✝\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.g (CategoryTheory.CategoryStruct.comp self.f h)) (CategoryTheory.CategoryStruct.comp h✝ h)","decl":"attribute [reassoc (attr := simp)] BindStruct.fac\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.bind","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nb : S.BindStruct R h\n⊢ S.bind R h","decl":"lemma BindStruct.bind {S : Presieve X} {R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y}\n    {Z : C} {h : Z ⟶ X} (b : BindStruct S R h) : bind S R h :=\n  ⟨b.Y, b.g, b.f, b.hf, b.hg, b.fac⟩\n\n"}
{"name":"CategoryTheory.Presieve.bind_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom Y X\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Presieve Y\ng : Quiver.Hom Z Y\nh₁ : S f\nh₂ : R h₁ g\n⊢ S.bind R (CategoryTheory.CategoryStruct.comp g f)","decl":"@[simp]\ntheorem bind_comp {S : Presieve X} {R : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, S f → Presieve Y} {g : Z ⟶ Y}\n    (h₁ : S f) (h₂ : R h₁ g) : bind S R (g ≫ f) :=\n  ⟨_, _, _, h₁, h₂, rfl⟩\n\n-- Porting note: it seems the definition of `Presieve` must be unfolded in order to define\n--   this inductive type, it was thus renamed `singleton'`\n-- Note we can't make this into `HasSingleton` because of the out-param.\n"}
{"name":"CategoryTheory.Presieve.singleton.mk","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ CategoryTheory.Presieve.singleton f f","decl":"lemma singleton.mk {f : Y ⟶ X} : singleton f f := singleton'.mk\n\n"}
{"name":"CategoryTheory.Presieve.singleton_eq_iff_domain","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf g : Quiver.Hom Y X\n⊢ Iff (CategoryTheory.Presieve.singleton f g) (Eq f g)","decl":"@[simp]\ntheorem singleton_eq_iff_domain (f g : Y ⟶ X) : singleton f g ↔ f = g := by\n  constructor\n  · rintro ⟨a, rfl⟩\n    rfl\n  · rintro rfl\n    apply singleton.mk\n\n"}
{"name":"CategoryTheory.Presieve.singleton_self","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ CategoryTheory.Presieve.singleton f f","decl":"theorem singleton_self : singleton f f :=\n  singleton.mk\n\n"}
{"name":"CategoryTheory.Presieve.pullback_singleton","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.Limits.HasPullbacks C\ng : Quiver.Hom Z X\n⊢ Eq (CategoryTheory.Presieve.pullbackArrows f (CategoryTheory.Presieve.singleton g)) (CategoryTheory.Presieve.singleton (CategoryTheory.Limits.pullback.snd g f))","decl":"theorem pullback_singleton [HasPullbacks C] (g : Z ⟶ X) :\n    pullbackArrows f (singleton g) = singleton (pullback.snd g f) := by\n  funext W\n  ext h\n  constructor\n  · rintro ⟨W, _, _, _⟩\n    exact singleton.mk\n  · rintro ⟨_⟩\n    exact pullbackArrows.mk Z g singleton.mk\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_pUnit","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ Eq (CategoryTheory.Presieve.ofArrows (fun x => Y) fun x => f) (CategoryTheory.Presieve.singleton f)","decl":"theorem ofArrows_pUnit : (ofArrows _ fun _ : PUnit => f) = singleton f := by\n  funext Y\n  ext g\n  constructor\n  · rintro ⟨_⟩\n    apply singleton.mk\n  · rintro ⟨_⟩\n    exact ofArrows.mk PUnit.unit\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nι : Type u_1\nZ : ι → C\ng : (i : ι) → Quiver.Hom (Z i) X\n⊢ Eq (CategoryTheory.Presieve.ofArrows (fun i => CategoryTheory.Limits.pullback (g i) f) fun x => CategoryTheory.Limits.pullback.snd (g x) f) (CategoryTheory.Presieve.pullbackArrows f (CategoryTheory.Presieve.ofArrows Z g))","decl":"theorem ofArrows_pullback [HasPullbacks C] {ι : Type*} (Z : ι → C) (g : ∀ i : ι, Z i ⟶ X) :\n    (ofArrows (fun i => pullback (g i) f) fun _ => pullback.snd _ _) =\n      pullbackArrows f (ofArrows Z g) := by\n  funext T\n  ext h\n  constructor\n  · rintro ⟨hk⟩\n    exact pullbackArrows.mk _ _ (ofArrows.mk hk)\n  · rintro ⟨W, k, hk₁⟩\n    cases' hk₁ with i hi\n    apply ofArrows.mk\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_bind","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nι : Type u_1\nZ : ι → C\ng : (i : ι) → Quiver.Hom (Z i) X\nj : ⦃Y : C⦄ → (f : Quiver.Hom Y X) → CategoryTheory.Presieve.ofArrows Z g f → Type u_2\nW : ⦃Y : C⦄ → (f : Quiver.Hom Y X) → (H : CategoryTheory.Presieve.ofArrows Z g f) → j f H → C\nk : ⦃Y : C⦄ → (f : Quiver.Hom Y X) → (H : CategoryTheory.Presieve.ofArrows Z g f) → (i : j f H) → Quiver.Hom (W f H i) Y\n⊢ Eq ((CategoryTheory.Presieve.ofArrows Z g).bind fun x f H => CategoryTheory.Presieve.ofArrows (W f H) (k f H)) (CategoryTheory.Presieve.ofArrows (fun i => W (g i.fst) ⋯ i.snd) fun ij => CategoryTheory.CategoryStruct.comp (k (g ij.fst) ⋯ ij.snd) (g ij.fst))","decl":"theorem ofArrows_bind {ι : Type*} (Z : ι → C) (g : ∀ i : ι, Z i ⟶ X)\n    (j : ∀ ⦃Y⦄ (f : Y ⟶ X), ofArrows Z g f → Type*) (W : ∀ ⦃Y⦄ (f : Y ⟶ X) (H), j f H → C)\n    (k : ∀ ⦃Y⦄ (f : Y ⟶ X) (H i), W f H i ⟶ Y) :\n    ((ofArrows Z g).bind fun _ f H => ofArrows (W f H) (k f H)) =\n      ofArrows (fun i : Σi, j _ (ofArrows.mk i) => W (g i.1) _ i.2) fun ij =>\n        k (g ij.1) _ ij.2 ≫ g ij.1 := by\n  funext Y\n  ext f\n  constructor\n  · rintro ⟨_, _, _, ⟨i⟩, ⟨i'⟩, rfl⟩\n    exact ofArrows.mk (Sigma.mk _ _)\n  · rintro ⟨i⟩\n    exact bind_comp _ (ofArrows.mk _) (ofArrows.mk _)\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_surj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nι : Type u_1\nY : ι → C\nf : (i : ι) → Quiver.Hom (Y i) X\nZ : C\ng : Quiver.Hom Z X\nhg : CategoryTheory.Presieve.ofArrows Y f g\n⊢ Exists fun i => Exists fun h => Eq g (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ⋯) (f i))","decl":"theorem ofArrows_surj {ι : Type*} {Y : ι → C} (f : ∀ i, Y i ⟶ X) {Z : C} (g : Z ⟶ X)\n    (hg : ofArrows Y f g) : ∃ (i : ι) (h : Y i = Z),\n    g = eqToHom h.symm ≫ f i := by\n  cases' hg with i\n  exact ⟨i, rfl, by simp only [eqToHom_refl, id_comp]⟩\n\n"}
{"name":"CategoryTheory.Presieve.functorPullback_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Presieve (F.obj X)\nY : C\nf : Quiver.Hom Y X\n⊢ Iff (CategoryTheory.Presieve.functorPullback F R f) (R (F.map f))","decl":"@[simp]\ntheorem functorPullback_mem (R : Presieve (F.obj X)) {Y} (f : Y ⟶ X) :\n    R.functorPullback F f ↔ R (F.map f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Presieve.functorPullback_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Presieve X\n⊢ Eq (CategoryTheory.Presieve.functorPullback (CategoryTheory.Functor.id C) R) R","decl":"@[simp]\ntheorem functorPullback_id (R : Presieve X) : R.functorPullback (𝟭 _) = R :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presieve.hasPullbacks.has_pullbacks","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Presieve X\nself : R.hasPullbacks\nY Z : C\nf : Quiver.Hom Y X\nx✝¹ : R f\ng : Quiver.Hom Z X\nx✝ : R g\n⊢ CategoryTheory.Limits.HasPullback f g","decl":"/-- Given a presieve `R` on `X`, the predicate `R.hasPullbacks` means that for all arrows `f` and\n    `g` in `R`, the pullback of `f` and `g` exists. -/\nclass hasPullbacks (R : Presieve X) : Prop where\n  /-- For all arrows `f` and `g` in `R`, the pullback of `f` and `g` exists. -/\n  has_pullbacks : ∀ {Y Z} {f : Y ⟶ X} (_ : R f) {g : Z ⟶ X} (_ : R g), HasPullback f g\n\n"}
{"name":"CategoryTheory.Presieve.instHasPullbacksOfHasPullbacks","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Presieve X\ninst✝ : CategoryTheory.Limits.HasPullbacks C\n⊢ R.hasPullbacks","decl":"instance (R : Presieve X) [HasPullbacks C] : R.hasPullbacks := ⟨fun _ _ ↦ inferInstance⟩\n\n"}
{"name":"CategoryTheory.Presieve.instHasPullbackOfHasPullbacksOfArrows","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nα : Type v₂\nX : α → C\nB : C\nπ : (a : α) → Quiver.Hom (X a) B\ninst✝ : (CategoryTheory.Presieve.ofArrows X π).hasPullbacks\na b : α\n⊢ CategoryTheory.Limits.HasPullback (π a) (π b)","decl":"instance {α : Type v₂} {X : α → C} {B : C} (π : (a : α) → X a ⟶ B)\n    [(Presieve.ofArrows X π).hasPullbacks] (a b : α) : HasPullback (π a) (π b) :=\n  Presieve.hasPullbacks.has_pullbacks (Presieve.ofArrows.mk _) (Presieve.ofArrows.mk _)\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.cover","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\nself : CategoryTheory.Presieve.FunctorPushforwardStructure F S f\n⊢ S self.premap","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ⟶ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ⟶ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ⟶ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ≫ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.fac","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\nself : CategoryTheory.Presieve.FunctorPushforwardStructure F S f\n⊢ Eq f (CategoryTheory.CategoryStruct.comp self.lift (F.map self.premap))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ⟶ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ⟶ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ⟶ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ≫ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\npreobj✝ : C\npremap✝ : Quiver.Hom preobj✝ X\nlift✝ : Quiver.Hom Y (F.obj preobj✝)\ncover✝ : S premap✝\nfac✝ : Eq f (CategoryTheory.CategoryStruct.comp lift✝ (F.map premap✝))\npreobj : C\npremap : Quiver.Hom preobj X\nlift : Quiver.Hom Y (F.obj preobj)\ncover : S premap\nfac : Eq f (CategoryTheory.CategoryStruct.comp lift (F.map premap))\nx✝ : Eq { preobj := preobj✝, premap := premap✝, lift := lift✝, cover := cover✝, fac := fac✝ } { preobj := preobj, premap := premap, lift := lift, cover := cover, fac := fac }\n⊢ And (Eq preobj✝ preobj) (And (HEq premap✝ premap) (HEq lift✝ lift))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ⟶ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ⟶ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ⟶ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ≫ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\npreobj✝ : C\npremap✝ : Quiver.Hom preobj✝ X\nlift✝ : Quiver.Hom Y (F.obj preobj✝)\ncover✝ : S premap✝\nfac✝ : Eq f (CategoryTheory.CategoryStruct.comp lift✝ (F.map premap✝))\npreobj : C\npremap : Quiver.Hom preobj X\nlift : Quiver.Hom Y (F.obj preobj)\ncover : S premap\nfac : Eq f (CategoryTheory.CategoryStruct.comp lift (F.map premap))\n⊢ Eq (Eq { preobj := preobj✝, premap := premap✝, lift := lift✝, cover := cover✝, fac := fac✝ } { preobj := preobj, premap := premap, lift := lift, cover := cover, fac := fac }) (And (Eq preobj✝ preobj) (And (HEq premap✝ premap) (HEq lift✝ lift)))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ⟶ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ⟶ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ⟶ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ≫ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : ⦃Y : C⦄ → (a : Quiver.Hom Y X) → SizeOf (S a)\npreobj : C\npremap : Quiver.Hom preobj X\nlift : Quiver.Hom Y (F.obj preobj)\ncover : S premap\nfac : Eq f (CategoryTheory.CategoryStruct.comp lift (F.map premap))\n⊢ Eq (SizeOf.sizeOf { preobj := preobj, premap := premap, lift := lift, cover := cover, fac := fac }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf preobj)) (SizeOf.sizeOf premap)) (SizeOf.sizeOf lift)) (SizeOf.sizeOf cover)) (SizeOf.sizeOf fac))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ⟶ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ⟶ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ⟶ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ≫ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.functorPushforward_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nR : CategoryTheory.Presieve X\n⊢ Eq (CategoryTheory.Presieve.functorPushforward (F.comp G) R) (CategoryTheory.Presieve.functorPushforward G (CategoryTheory.Presieve.functorPushforward F R))","decl":"theorem functorPushforward_comp (R : Presieve X) :\n    R.functorPushforward (F ⋙ G) = (R.functorPushforward F).functorPushforward G := by\n  funext x\n  ext f\n  constructor\n  · rintro ⟨X, f₁, g₁, h₁, rfl⟩\n    exact ⟨F.obj X, F.map f₁, g₁, ⟨X, f₁, 𝟙 _, h₁, by simp⟩, rfl⟩\n  · rintro ⟨X, f₁, g₁, ⟨X', f₂, g₂, h₁, rfl⟩, rfl⟩\n    exact ⟨X', f₂, g₁ ≫ G.map g₂, h₁, by simp⟩\n\n"}
{"name":"CategoryTheory.Presieve.image_mem_functorPushforward","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX Y : C\nR : CategoryTheory.Presieve X\nf : Quiver.Hom Y X\nh : R f\n⊢ CategoryTheory.Presieve.functorPushforward F R (F.map f)","decl":"theorem image_mem_functorPushforward (R : Presieve X) {f : Y ⟶ X} (h : R f) :\n    R.functorPushforward F (F.map f) :=\n  ⟨Y, f, 𝟙 _, h, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\narrows✝ : CategoryTheory.Presieve X\ndownward_closed✝ : ∀ {Y Z : C} {f : Quiver.Hom Y X}, arrows✝ f → ∀ (g : Quiver.Hom Z Y), arrows✝ (CategoryTheory.CategoryStruct.comp g f)\narrows : CategoryTheory.Presieve X\ndownward_closed : ∀ {Y Z : C} {f : Quiver.Hom Y X}, arrows f → ∀ (g : Quiver.Hom Z Y), arrows (CategoryTheory.CategoryStruct.comp g f)\nx✝ : Eq { arrows := arrows✝, downward_closed := downward_closed✝ } { arrows := arrows, downward_closed := downward_closed }\n⊢ Eq arrows✝ arrows","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u₁} [Category.{v₁} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ∀ {Y Z f} (_ : arrows f) (g : Z ⟶ Y), arrows (g ≫ f)\n\n"}
{"name":"CategoryTheory.Sieve.downward_closed","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nself : CategoryTheory.Sieve X\nY Z : C\nf : Quiver.Hom Y X\nx✝ : self.arrows f\ng : Quiver.Hom Z Y\n⊢ self.arrows (CategoryTheory.CategoryStruct.comp g f)","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u₁} [Category.{v₁} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ∀ {Y Z f} (_ : arrows f) (g : Z ⟶ Y), arrows (g ≫ f)\n\n"}
{"name":"CategoryTheory.Sieve.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\narrows✝ : CategoryTheory.Presieve X\ndownward_closed✝ : ∀ {Y Z : C} {f : Quiver.Hom Y X}, arrows✝ f → ∀ (g : Quiver.Hom Z Y), arrows✝ (CategoryTheory.CategoryStruct.comp g f)\narrows : CategoryTheory.Presieve X\ndownward_closed : ∀ {Y Z : C} {f : Quiver.Hom Y X}, arrows f → ∀ (g : Quiver.Hom Z Y), arrows (CategoryTheory.CategoryStruct.comp g f)\n⊢ Eq (Eq { arrows := arrows✝, downward_closed := downward_closed✝ } { arrows := arrows, downward_closed := downward_closed }) (Eq arrows✝ arrows)","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u₁} [Category.{v₁} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ∀ {Y Z f} (_ : arrows f) (g : Z ⟶ Y), arrows (g ≫ f)\n\n"}
{"name":"CategoryTheory.Sieve.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX : C\ninst✝ : SizeOf C\narrows : CategoryTheory.Presieve X\ndownward_closed : ∀ {Y Z : C} {f : Quiver.Hom Y X}, arrows f → ∀ (g : Quiver.Hom Z Y), arrows (CategoryTheory.CategoryStruct.comp g f)\n⊢ Eq (SizeOf.sizeOf { arrows := arrows, downward_closed := downward_closed }) 1","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u₁} [Category.{v₁} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ∀ {Y Z f} (_ : arrows f) (g : Z ⟶ Y), arrows (g ≫ f)\n\n"}
{"name":"CategoryTheory.Sieve.arrows_ext","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR S : CategoryTheory.Sieve X\na✝ : Eq R.arrows S.arrows\n⊢ Eq R S","decl":"theorem arrows_ext : ∀ {R S : Sieve X}, R.arrows = S.arrows → R = S := by\n  rintro ⟨_, _⟩ ⟨_, _⟩ rfl\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.ext_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR S : CategoryTheory.Sieve X\n⊢ Iff (Eq R S) (∀ ⦃Y : C⦄ (f : Quiver.Hom Y X), Iff (R.arrows f) (S.arrows f))","decl":"@[ext]\nprotected theorem ext {R S : Sieve X} (h : ∀ ⦃Y⦄ (f : Y ⟶ X), R f ↔ S f) : R = S :=\n  arrows_ext <| funext fun _ => funext fun f => propext <| h f\n\n"}
{"name":"CategoryTheory.Sieve.ext","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR S : CategoryTheory.Sieve X\nh : ∀ ⦃Y : C⦄ (f : Quiver.Hom Y X), Iff (R.arrows f) (S.arrows f)\n⊢ Eq R S","decl":"@[ext]\nprotected theorem ext {R S : Sieve X} (h : ∀ ⦃Y⦄ (f : Y ⟶ X), R f ↔ S f) : R = S :=\n  arrows_ext <| funext fun _ => funext fun f => propext <| h f\n\n"}
{"name":"CategoryTheory.Sieve.sInf_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nSs : Set (CategoryTheory.Sieve X)\nY : C\nf : Quiver.Hom Y X\n⊢ Iff ((InfSet.sInf Ss).arrows f) (∀ (S : CategoryTheory.Sieve X), Membership.mem Ss S → S.arrows f)","decl":"@[simp]\ntheorem sInf_apply {Ss : Set (Sieve X)} {Y} (f : Y ⟶ X) :\n    sInf Ss f ↔ ∀ (S : Sieve X) (_ : S ∈ Ss), S f :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Sieve.sSup_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nSs : Set (CategoryTheory.Sieve X)\nY : C\nf : Quiver.Hom Y X\n⊢ Iff ((SupSet.sSup Ss).arrows f) (Exists fun S => Exists fun x => S.arrows f)","decl":"@[simp]\ntheorem sSup_apply {Ss : Set (Sieve X)} {Y} (f : Y ⟶ X) :\n    sSup Ss f ↔ ∃ (S : Sieve X) (_ : S ∈ Ss), S f := by\n  simp [sSup, Sieve.sup, setOf]\n\n"}
{"name":"CategoryTheory.Sieve.inter_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR S : CategoryTheory.Sieve X\nY : C\nf : Quiver.Hom Y X\n⊢ Iff ((Min.min R S).arrows f) (And (R.arrows f) (S.arrows f))","decl":"@[simp]\ntheorem inter_apply {R S : Sieve X} {Y} (f : Y ⟶ X) : (R ⊓ S) f ↔ R f ∧ S f :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Sieve.union_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR S : CategoryTheory.Sieve X\nY : C\nf : Quiver.Hom Y X\n⊢ Iff ((Max.max R S).arrows f) (Or (R.arrows f) (S.arrows f))","decl":"@[simp]\ntheorem union_apply {R S : Sieve X} {Y} (f : Y ⟶ X) : (R ⊔ S) f ↔ R f ∨ S f :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Sieve.top_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ Top.top.arrows f","decl":"@[simp]\ntheorem top_apply (f : Y ⟶ X) : (⊤ : Sieve X) f :=\n  trivial\n\n"}
{"name":"CategoryTheory.Sieve.generate_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Presieve X\nZ : C\nf : Quiver.Hom Z X\n⊢ Eq ((CategoryTheory.Sieve.generate R).arrows f) (Exists fun Y => Exists fun h => Exists fun g => And (R g) (Eq (CategoryTheory.CategoryStruct.comp h g) f))","decl":"/-- Generate the smallest sieve containing the given set of arrows. -/\n@[simps]\ndef generate (R : Presieve X) : Sieve X where\n  arrows Z f := ∃ (Y : _) (h : Z ⟶ Y) (g : Y ⟶ X), R g ∧ h ≫ g = f\n  downward_closed := by\n    rintro Y Z _ ⟨W, g, f, hf, rfl⟩ h\n    exact ⟨_, h ≫ g, _, hf, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.bind_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Sieve Y\n⊢ Eq (CategoryTheory.Sieve.bind S R).arrows (S.bind fun x x_1 h => (R h).arrows)","decl":"/-- Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to\nproduce a sieve on `X`.\n-/\n@[simps]\ndef bind (S : Presieve X) (R : ∀ ⦃Y⦄ ⦃f : Y ⟶ X⦄, S f → Sieve Y) : Sieve X where\n  arrows := S.bind fun _ _ h => R h\n  downward_closed := by\n    rintro Y Z f ⟨W, f, h, hh, hf, rfl⟩ g\n    exact ⟨_, g ≫ f, _, hh, by simp [hf]⟩\n\n"}
{"name":"CategoryTheory.Sieve.generate_le_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Presieve X\nS : CategoryTheory.Sieve X\n⊢ Iff (LE.le (CategoryTheory.Sieve.generate R) S) (LE.le R S.arrows)","decl":"theorem generate_le_iff (R : Presieve X) (S : Sieve X) : generate R ≤ S ↔ R ≤ S :=\n  ⟨fun H _ _ hg => H _ ⟨_, 𝟙 _, _, hg, id_comp _⟩, fun ss Y f => by\n    rintro ⟨Z, f, g, hg, rfl⟩\n    exact S.downward_closed (ss Z hg) f⟩\n\n"}
{"name":"CategoryTheory.Sieve.le_generate","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Presieve X\n⊢ LE.le R (CategoryTheory.Sieve.generate R).arrows","decl":"theorem le_generate (R : Presieve X) : R ≤ generate R :=\n  giGenerate.gc.le_u_l R\n\n"}
{"name":"CategoryTheory.Sieve.generate_sieve","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.generate S.arrows) S","decl":"@[simp]\ntheorem generate_sieve (S : Sieve X) : generate S = S :=\n  giGenerate.l_u_eq S\n\n"}
{"name":"CategoryTheory.Sieve.id_mem_iff_eq_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Iff (S.arrows (CategoryTheory.CategoryStruct.id X)) (Eq S Top.top)","decl":"/-- If the identity arrow is in a sieve, the sieve is maximal. -/\ntheorem id_mem_iff_eq_top : S (𝟙 X) ↔ S = ⊤ :=\n  ⟨fun h => top_unique fun Y f _ => by simpa using downward_closed _ h f, fun h => h.symm ▸ trivial⟩\n\n"}
{"name":"CategoryTheory.Sieve.generate_of_contains_isSplitEpi","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nR : CategoryTheory.Presieve X\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.IsSplitEpi f\nhf : R f\n⊢ Eq (CategoryTheory.Sieve.generate R) Top.top","decl":"/-- If an arrow set contains a split epi, it generates the maximal sieve. -/\ntheorem generate_of_contains_isSplitEpi {R : Presieve X} (f : Y ⟶ X) [IsSplitEpi f] (hf : R f) :\n    generate R = ⊤ := by\n  rw [← id_mem_iff_eq_top]\n  exact ⟨_, section_ f, f, hf, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.generate_of_singleton_isSplitEpi","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\ninst✝ : CategoryTheory.IsSplitEpi f\n⊢ Eq (CategoryTheory.Sieve.generate (CategoryTheory.Presieve.singleton f)) Top.top","decl":"@[simp]\ntheorem generate_of_singleton_isSplitEpi (f : Y ⟶ X) [IsSplitEpi f] :\n    generate (Presieve.singleton f) = ⊤ :=\n  generate_of_contains_isSplitEpi f (Presieve.singleton_self _)\n\n"}
{"name":"CategoryTheory.Sieve.generate_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq (CategoryTheory.Sieve.generate Top.top) Top.top","decl":"@[simp]\ntheorem generate_top : generate (⊤ : Presieve X) = ⊤ :=\n  generate_of_contains_isSplitEpi (𝟙 _) ⟨⟩\n\n"}
{"name":"CategoryTheory.Sieve.comp_mem_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\ni : Quiver.Hom X Y\nf : Quiver.Hom Y Z\ninst✝ : CategoryTheory.IsIso i\nS : CategoryTheory.Sieve Z\n⊢ Iff (S.arrows (CategoryTheory.CategoryStruct.comp i f)) (S.arrows f)","decl":"@[simp]\nlemma comp_mem_iff (i : X ⟶ Y) (f : Y ⟶ Z) [IsIso i] (S : Sieve Z) :\n    S (i ≫ f) ↔ S f := by\n  refine ⟨fun H ↦ ?_, fun H ↦ S.downward_closed H _⟩\n  convert S.downward_closed H (inv i)\n  simp\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows_mk","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nX : C\nY : I → C\nf : (i : I) → Quiver.Hom (Y i) X\ni : I\n⊢ (CategoryTheory.Sieve.ofArrows Y f).arrows (f i)","decl":"lemma ofArrows_mk (i : I) : ofArrows Y f (f i) :=\n  ⟨_, 𝟙 _, _, ⟨i⟩, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.mem_ofArrows_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nX : C\nY : I → C\nf : (i : I) → Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\n⊢ Iff ((CategoryTheory.Sieve.ofArrows Y f).arrows g) (Exists fun i => Exists fun a => Eq g (CategoryTheory.CategoryStruct.comp a (f i)))","decl":"lemma mem_ofArrows_iff {W : C} (g : W ⟶ X) :\n    ofArrows Y f g ↔ ∃ (i : I) (a : W ⟶ Y i), g = a ≫ f i := by\n  constructor\n  · rintro ⟨T, a, b, ⟨i⟩, rfl⟩\n    exact ⟨i, a, rfl⟩\n  · rintro ⟨i, a, rfl⟩\n    apply downward_closed _ (ofArrows_mk Y f i)\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows.exists","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nX : C\nY : I → C\nf : (i : I) → Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\nhg : (CategoryTheory.Sieve.ofArrows Y f).arrows g\n⊢ Exists fun i => Exists fun h => Eq g (CategoryTheory.CategoryStruct.comp h (f i))","decl":"include hg in\nlemma ofArrows.exists : ∃ (i : I) (h : W ⟶ Y i), g = h ≫ f i := by\n  obtain ⟨_, h, _, H, rfl⟩ := hg\n  cases' H with i\n  exact ⟨i, h, rfl⟩\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows.fac_assoc","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nX : C\nY : I → C\nf : (i : I) → Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\nhg : (CategoryTheory.Sieve.ofArrows Y f).arrows g\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.ofArrows.h hg) (CategoryTheory.CategoryStruct.comp (f (CategoryTheory.Sieve.ofArrows.i hg)) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\nlemma ofArrows.fac : h hg ≫ f (i hg) = g :=\n  (ofArrows.exists hg).choose_spec.choose_spec.symm\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows.fac","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nX : C\nY : I → C\nf : (i : I) → Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\nhg : (CategoryTheory.Sieve.ofArrows Y f).arrows g\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.ofArrows.h hg) (f (CategoryTheory.Sieve.ofArrows.i hg))) g","decl":"@[reassoc (attr := simp)]\nlemma ofArrows.fac : h hg ≫ f (i hg) = g :=\n  (ofArrows.exists hg).choose_spec.choose_spec.symm\n\n"}
{"name":"CategoryTheory.Sieve.mem_ofObjects_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nY : I → C\nZ X : C\ng : Quiver.Hom Z X\n⊢ Iff ((CategoryTheory.Sieve.ofObjects Y X).arrows g) (Exists fun i => Nonempty (Quiver.Hom Z (Y i)))","decl":"lemma mem_ofObjects_iff {I : Type*} (Y : I → C) {Z X : C} (g : Z ⟶ X) :\n    ofObjects Y X g ↔ ∃ (i : I), Nonempty (Z ⟶ Y i) := by rfl\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows_le_ofObjects","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nY : I → C\nX : C\nf : (i : I) → Quiver.Hom (Y i) X\n⊢ LE.le (CategoryTheory.Sieve.ofArrows Y f) (CategoryTheory.Sieve.ofObjects Y X)","decl":"lemma ofArrows_le_ofObjects\n    {I : Type*} (Y : I → C) {X : C} (f : ∀ i, Y i ⟶ X) :\n    Sieve.ofArrows Y f ≤ Sieve.ofObjects Y X := by\n  intro W g hg\n  rw [mem_ofArrows_iff] at hg\n  obtain ⟨i, a, rfl⟩ := hg\n  exact ⟨i, ⟨a⟩⟩\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows_eq_ofObjects","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nhX : CategoryTheory.Limits.IsTerminal X\nI : Type u_1\nY : I → C\nf : (i : I) → Quiver.Hom (Y i) X\n⊢ Eq (CategoryTheory.Sieve.ofArrows Y f) (CategoryTheory.Sieve.ofObjects Y X)","decl":"lemma ofArrows_eq_ofObjects {X : C} (hX : IsTerminal X)\n    {I : Type*} (Y : I → C) (f : ∀ i, Y i ⟶ X) :\n    ofArrows Y f = ofObjects Y X := by\n  refine le_antisymm (ofArrows_le_ofObjects Y f) (fun W g => ?_)\n  rw [mem_ofArrows_iff, mem_ofObjects_iff]\n  rintro ⟨i, ⟨h⟩⟩\n  exact ⟨i, h, hX.hom_ext _ _⟩\n\n"}
{"name":"CategoryTheory.Sieve.pullback_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nh : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\nx✝ : C\nsl : Quiver.Hom x✝ Y\n⊢ Eq ((CategoryTheory.Sieve.pullback h S).arrows sl) (S.arrows (CategoryTheory.CategoryStruct.comp sl h))","decl":"/-- Given a morphism `h : Y ⟶ X`, send a sieve S on X to a sieve on Y\n    as the inverse image of S with `_ ≫ h`.\n    That is, `Sieve.pullback S h := (≫ h) '⁻¹ S`. -/\n@[simps]\ndef pullback (h : Y ⟶ X) (S : Sieve X) : Sieve Y where\n  arrows _ sl := S (sl ≫ h)\n  downward_closed g := by simp [g]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.pullback (CategoryTheory.CategoryStruct.id X) S) S","decl":"@[simp]\ntheorem pullback_id : S.pullback (𝟙 _) = S := by simp [Sieve.ext_iff]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ Eq (CategoryTheory.Sieve.pullback f Top.top) Top.top","decl":"@[simp]\ntheorem pullback_top {f : Y ⟶ X} : (⊤ : Sieve X).pullback f = ⊤ :=\n  top_unique fun _ _ => id\n\n"}
{"name":"CategoryTheory.Sieve.pullback_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nS : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.pullback (CategoryTheory.CategoryStruct.comp g f) S) (CategoryTheory.Sieve.pullback g (CategoryTheory.Sieve.pullback f S))","decl":"theorem pullback_comp {f : Y ⟶ X} {g : Z ⟶ Y} (S : Sieve X) :\n    S.pullback (g ≫ f) = (S.pullback f).pullback g := by simp [Sieve.ext_iff]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_inter","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.pullback f (Min.min S R)) (Min.min (CategoryTheory.Sieve.pullback f S) (CategoryTheory.Sieve.pullback f R))","decl":"@[simp]\ntheorem pullback_inter {f : Y ⟶ X} (S R : Sieve X) :\n    (S ⊓ R).pullback f = S.pullback f ⊓ R.pullback f := by simp [Sieve.ext_iff]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_eq_top_iff_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n⊢ Iff (S.arrows f) (Eq (CategoryTheory.Sieve.pullback f S) Top.top)","decl":"theorem pullback_eq_top_iff_mem (f : Y ⟶ X) : S f ↔ S.pullback f = ⊤ := by\n  rw [← id_mem_iff_eq_top, pullback_apply, id_comp]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_eq_top_of_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\na✝ : S.arrows f\n⊢ Eq (CategoryTheory.Sieve.pullback f S) Top.top","decl":"theorem pullback_eq_top_of_mem (S : Sieve X) {f : Y ⟶ X} : S f → S.pullback f = ⊤ :=\n  (pullback_eq_top_iff_mem f).1\n\n"}
{"name":"CategoryTheory.Sieve.pullback_ofObjects_eq_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nI : Type u_1\nY : I → C\nX : C\ni : I\ng : Quiver.Hom X (Y i)\n⊢ Eq (CategoryTheory.Sieve.ofObjects Y X) Top.top","decl":"lemma pullback_ofObjects_eq_top\n    {I : Type*} (Y : I → C) {X : C} {i : I} (g : X ⟶ Y i) :\n    ofObjects Y X = ⊤ := by\n  ext Z h\n  simp only [top_apply, iff_true]\n  rw [mem_ofObjects_iff ]\n  exact ⟨i, ⟨h ≫ g⟩⟩\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Sieve Y\nx✝ : C\ngf : Quiver.Hom x✝ X\n⊢ Eq ((CategoryTheory.Sieve.pushforward f R).arrows gf) (Exists fun g => And (Eq (CategoryTheory.CategoryStruct.comp g f) gf) (R.arrows g))","decl":"/-- Push a sieve `R` on `Y` forward along an arrow `f : Y ⟶ X`: `gf : Z ⟶ X` is in the sieve if `gf`\nfactors through some `g : Z ⟶ Y` which is in `R`.\n-/\n@[simps]\ndef pushforward (f : Y ⟶ X) (R : Sieve Y) : Sieve X where\n  arrows _ gf := ∃ g, g ≫ f = gf ∧ R g\n  downward_closed := fun ⟨j, k, z⟩ h => ⟨h ≫ j, by simp [k], by simp [z]⟩\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_apply_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nR : CategoryTheory.Sieve Y\nZ : C\ng : Quiver.Hom Z Y\nhg : R.arrows g\nf : Quiver.Hom Y X\n⊢ (CategoryTheory.Sieve.pushforward f R).arrows (CategoryTheory.CategoryStruct.comp g f)","decl":"theorem pushforward_apply_comp {R : Sieve Y} {Z : C} {g : Z ⟶ Y} (hg : R g) (f : Y ⟶ X) :\n    R.pushforward f (g ≫ f) :=\n  ⟨g, rfl, hg⟩\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nR : CategoryTheory.Sieve Z\n⊢ Eq (CategoryTheory.Sieve.pushforward (CategoryTheory.CategoryStruct.comp g f) R) (CategoryTheory.Sieve.pushforward f (CategoryTheory.Sieve.pushforward g R))","decl":"theorem pushforward_comp {f : Y ⟶ X} {g : Z ⟶ Y} (R : Sieve Z) :\n    R.pushforward (g ≫ f) = (R.pushforward g).pushforward f :=\n  Sieve.ext fun W h =>\n    ⟨fun ⟨f₁, hq, hf₁⟩ => ⟨f₁ ≫ g, by simpa, f₁, rfl, hf₁⟩, fun ⟨y, hy, z, hR, hz⟩ =>\n      ⟨z, by rw [← Category.assoc, hR]; tauto⟩⟩\n\n"}
{"name":"CategoryTheory.Sieve.galoisConnection","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ GaloisConnection (CategoryTheory.Sieve.pushforward f) (CategoryTheory.Sieve.pullback f)","decl":"theorem galoisConnection (f : Y ⟶ X) : GaloisConnection (Sieve.pushforward f) (Sieve.pullback f) :=\n  fun _ _ => ⟨fun hR _ g hg => hR _ ⟨g, rfl, hg⟩, fun hS _ _ ⟨h, hg, hh⟩ => hg ▸ hS h hh⟩\n\n"}
{"name":"CategoryTheory.Sieve.pullback_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ Monotone (CategoryTheory.Sieve.pullback f)","decl":"theorem pullback_monotone (f : Y ⟶ X) : Monotone (Sieve.pullback f) :=\n  (galoisConnection f).monotone_u\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\n⊢ Monotone (CategoryTheory.Sieve.pushforward f)","decl":"theorem pushforward_monotone (f : Y ⟶ X) : Monotone (Sieve.pushforward f) :=\n  (galoisConnection f).monotone_l\n\n"}
{"name":"CategoryTheory.Sieve.le_pushforward_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Sieve Y\n⊢ LE.le R (CategoryTheory.Sieve.pullback f (CategoryTheory.Sieve.pushforward f R))","decl":"theorem le_pushforward_pullback (f : Y ⟶ X) (R : Sieve Y) : R ≤ (R.pushforward f).pullback f :=\n  (galoisConnection f).le_u_l _\n\n"}
{"name":"CategoryTheory.Sieve.pullback_pushforward_le","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Sieve X\n⊢ LE.le (CategoryTheory.Sieve.pushforward f (CategoryTheory.Sieve.pullback f R)) R","decl":"theorem pullback_pushforward_le (f : Y ⟶ X) (R : Sieve X) : (R.pullback f).pushforward f ≤ R :=\n  (galoisConnection f).l_u_le _\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_union","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve Y\n⊢ Eq (CategoryTheory.Sieve.pushforward f (Max.max S R)) (Max.max (CategoryTheory.Sieve.pushforward f S) (CategoryTheory.Sieve.pushforward f R))","decl":"theorem pushforward_union {f : Y ⟶ X} (S R : Sieve Y) :\n    (S ⊔ R).pushforward f = S.pushforward f ⊔ R.pushforward f :=\n  (galoisConnection f).l_sup\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_le_bind_of_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Sieve Y\nf : Quiver.Hom Y X\nh : S f\n⊢ LE.le (CategoryTheory.Sieve.pushforward f (R h)) (CategoryTheory.Sieve.bind S R)","decl":"theorem pushforward_le_bind_of_mem (S : Presieve X) (R : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, S f → Sieve Y)\n    (f : Y ⟶ X) (h : S f) : (R h).pushforward f ≤ bind S R := by\n  rintro Z _ ⟨g, rfl, hg⟩\n  exact ⟨_, g, f, h, hg, rfl⟩\n\n"}
{"name":"CategoryTheory.Sieve.le_pullback_bind","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : C\nS : CategoryTheory.Presieve X\nR : ⦃Y : C⦄ → ⦃f : Quiver.Hom Y X⦄ → S f → CategoryTheory.Sieve Y\nf : Quiver.Hom Y X\nh : S f\n⊢ LE.le (R h) (CategoryTheory.Sieve.pullback f (CategoryTheory.Sieve.bind S R))","decl":"theorem le_pullback_bind (S : Presieve X) (R : ∀ ⦃Y : C⦄ ⦃f : Y ⟶ X⦄, S f → Sieve Y) (f : Y ⟶ X)\n    (h : S f) : R h ≤ (bind S R).pullback f := by\n  rw [← galoisConnection f]\n  apply pushforward_le_bind_of_mem\n\n"}
{"name":"CategoryTheory.Sieve.pullbackArrows_comm","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasPullbacks C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Presieve X\n⊢ Eq (CategoryTheory.Sieve.generate (CategoryTheory.Presieve.pullbackArrows f R)) (CategoryTheory.Sieve.pullback f (CategoryTheory.Sieve.generate R))","decl":"theorem pullbackArrows_comm [HasPullbacks C] {X Y : C} (f : Y ⟶ X) (R : Presieve X) :\n    Sieve.generate (R.pullbackArrows f) = (Sieve.generate R).pullback f := by\n  ext W g\n  constructor\n  · rintro ⟨_, h, k, hk, rfl⟩\n    cases' hk with W g hg\n    rw [Sieve.pullback_apply, assoc, ← pullback.condition, ← assoc]\n    exact Sieve.downward_closed _ (by exact Sieve.le_generate R W hg) (h ≫ pullback.fst g f)\n  · rintro ⟨W, h, k, hk, comm⟩\n    exact ⟨_, _, _, Presieve.pullbackArrows.mk _ _ hk, pullback.lift_snd _ _ comm⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve (F.obj X)\n⊢ Eq (CategoryTheory.Sieve.functorPullback F R).arrows (CategoryTheory.Presieve.functorPullback F R.arrows)","decl":"/--\nIf `R` is a sieve, then the `CategoryTheory.Presieve.functorPullback` of `R` is actually a sieve.\n-/\n@[simps]\ndef functorPullback (R : Sieve (F.obj X)) : Sieve X where\n  arrows := Presieve.functorPullback F R\n  downward_closed := by\n    intro _ _ f hf g\n    unfold Presieve.functorPullback\n    rw [F.map_comp]\n    exact R.downward_closed hf (F.map g)\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_arrows","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve (F.obj X)\n⊢ Eq (CategoryTheory.Sieve.functorPullback F R).arrows (CategoryTheory.Presieve.functorPullback F R.arrows)","decl":"@[simp]\ntheorem functorPullback_arrows (R : Sieve (F.obj X)) :\n    (R.functorPullback F).arrows = R.arrows.functorPullback F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.functorPullback (CategoryTheory.Functor.id C) R) R","decl":"@[simp]\ntheorem functorPullback_id (R : Sieve X) : R.functorPullback (𝟭 _) = R := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nR : CategoryTheory.Sieve ((F.comp G).obj X)\n⊢ Eq (CategoryTheory.Sieve.functorPullback (F.comp G) R) (CategoryTheory.Sieve.functorPullback F (CategoryTheory.Sieve.functorPullback G R))","decl":"theorem functorPullback_comp (R : Sieve ((F ⋙ G).obj X)) :\n    R.functorPullback (F ⋙ G) = (R.functorPullback G).functorPullback F := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_extend_eq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Presieve X\n⊢ Eq (CategoryTheory.Presieve.functorPushforward F (CategoryTheory.Sieve.generate R).arrows) (CategoryTheory.Presieve.functorPushforward F R)","decl":"theorem functorPushforward_extend_eq {R : Presieve X} :\n    (generate R).arrows.functorPushforward F = R.functorPushforward F := by\n  funext Y\n  ext f\n  constructor\n  · rintro ⟨X', g, f', ⟨X'', g', f'', h₁, rfl⟩, rfl⟩\n    exact ⟨X'', f'', f' ≫ F.map g', h₁, by simp⟩\n  · rintro ⟨X', g, f', h₁, h₂⟩\n    exact ⟨X', g, f', le_generate R _ h₁, h₂⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.functorPushforward F R).arrows (CategoryTheory.Presieve.functorPushforward F R.arrows)","decl":"/-- The sieve generated by the image of `R` under `F`. -/\n@[simps]\ndef functorPushforward (R : Sieve X) : Sieve (F.obj X) where\n  arrows := R.arrows.functorPushforward F\n  downward_closed := by\n    intro _ _ f h g\n    obtain ⟨X, α, β, hα, rfl⟩ := h\n    exact ⟨X, α, g ≫ β, hα, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.functorPushforward (CategoryTheory.Functor.id C) R) R","decl":"@[simp]\ntheorem functorPushforward_id (R : Sieve X) : R.functorPushforward (𝟭 _) = R := by\n  ext X f\n  constructor\n  · intro hf\n    obtain ⟨X, g, h, hg, rfl⟩ := hf\n    exact R.downward_closed hg h\n  · intro hf\n    exact ⟨X, f, 𝟙 _, hf, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nE : Type u₃\ninst✝ : CategoryTheory.Category.{v₃, u₃} E\nG : CategoryTheory.Functor D E\nR : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.functorPushforward (F.comp G) R) (CategoryTheory.Sieve.functorPushforward G (CategoryTheory.Sieve.functorPushforward F R))","decl":"theorem functorPushforward_comp (R : Sieve X) :\n    R.functorPushforward (F ⋙ G) = (R.functorPushforward F).functorPushforward G := by\n  ext\n  simp [R.arrows.functorPushforward_comp F G]\n\n"}
{"name":"CategoryTheory.Sieve.functor_galoisConnection","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ GaloisConnection (CategoryTheory.Sieve.functorPushforward F) (CategoryTheory.Sieve.functorPullback F)","decl":"theorem functor_galoisConnection (X : C) :\n    GaloisConnection (Sieve.functorPushforward F : Sieve X → Sieve (F.obj X))\n      (Sieve.functorPullback F) := by\n  intro R S\n  constructor\n  · intro hle X f hf\n    apply hle\n    refine ⟨X, f, 𝟙 _, hf, ?_⟩\n    rw [id_comp]\n  · rintro hle Y f ⟨X, g, h, hg, rfl⟩\n    apply Sieve.downward_closed S\n    exact hle g hg\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Monotone (CategoryTheory.Sieve.functorPullback F)","decl":"theorem functorPullback_monotone (X : C) :\n    Monotone (Sieve.functorPullback F : Sieve (F.obj X) → Sieve X) :=\n  (functor_galoisConnection F X).monotone_u\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Monotone (CategoryTheory.Sieve.functorPushforward F)","decl":"theorem functorPushforward_monotone (X : C) :\n    Monotone (Sieve.functorPushforward F : Sieve X → Sieve (F.obj X)) :=\n  (functor_galoisConnection F X).monotone_l\n\n"}
{"name":"CategoryTheory.Sieve.le_functorPushforward_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve X\n⊢ LE.le R (CategoryTheory.Sieve.functorPullback F (CategoryTheory.Sieve.functorPushforward F R))","decl":"theorem le_functorPushforward_pullback (R : Sieve X) :\n    R ≤ (R.functorPushforward F).functorPullback F :=\n  (functor_galoisConnection F X).le_u_l _\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_pushforward_le","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve (F.obj X)\n⊢ LE.le (CategoryTheory.Sieve.functorPushforward F (CategoryTheory.Sieve.functorPullback F R)) R","decl":"theorem functorPullback_pushforward_le (R : Sieve (F.obj X)) :\n    (R.functorPullback F).functorPushforward F ≤ R :=\n  (functor_galoisConnection F X).l_u_le _\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_union","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS R : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.functorPushforward F (Max.max S R)) (Max.max (CategoryTheory.Sieve.functorPushforward F S) (CategoryTheory.Sieve.functorPushforward F R))","decl":"theorem functorPushforward_union (S R : Sieve X) :\n    (S ⊔ R).functorPushforward F = S.functorPushforward F ⊔ R.functorPushforward F :=\n  (functor_galoisConnection F X).l_sup\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_union","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS R : CategoryTheory.Sieve (F.obj X)\n⊢ Eq (CategoryTheory.Sieve.functorPullback F (Max.max S R)) (Max.max (CategoryTheory.Sieve.functorPullback F S) (CategoryTheory.Sieve.functorPullback F R))","decl":"theorem functorPullback_union (S R : Sieve (F.obj X)) :\n    (S ⊔ R).functorPullback F = S.functorPullback F ⊔ R.functorPullback F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_inter","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nS R : CategoryTheory.Sieve (F.obj X)\n⊢ Eq (CategoryTheory.Sieve.functorPullback F (Min.min S R)) (Min.min (CategoryTheory.Sieve.functorPullback F S) (CategoryTheory.Sieve.functorPullback F R))","decl":"theorem functorPullback_inter (S R : Sieve (F.obj X)) :\n    (S ⊓ R).functorPullback F = S.functorPullback F ⊓ R.functorPullback F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_bot","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (CategoryTheory.Sieve.functorPushforward F Bot.bot) Bot.bot","decl":"@[simp]\ntheorem functorPushforward_bot (F : C ⥤ D) (X : C) : (⊥ : Sieve X).functorPushforward F = ⊥ :=\n  (functor_galoisConnection F X).l_bot\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (CategoryTheory.Sieve.functorPushforward F Top.top) Top.top","decl":"@[simp]\ntheorem functorPushforward_top (F : C ⥤ D) (X : C) : (⊤ : Sieve X).functorPushforward F = ⊤ := by\n  refine (generate_sieve _).symm.trans ?_\n  apply generate_of_contains_isSplitEpi (𝟙 (F.obj X))\n  exact ⟨X, 𝟙 _, 𝟙 _, trivial, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_bot","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (CategoryTheory.Sieve.functorPullback F Bot.bot) Bot.bot","decl":"@[simp]\ntheorem functorPullback_bot (F : C ⥤ D) (X : C) : (⊥ : Sieve (F.obj X)).functorPullback F = ⊥ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\n⊢ Eq (CategoryTheory.Sieve.functorPullback F Top.top) Top.top","decl":"@[simp]\ntheorem functorPullback_top (F : C ⥤ D) (X : C) : (⊤ : Sieve (F.obj X)).functorPullback F = ⊤ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.image_mem_functorPushforward","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve X\nV : C\nf : Quiver.Hom V X\nh : R.arrows f\n⊢ (CategoryTheory.Sieve.functorPushforward F R).arrows (F.map f)","decl":"theorem image_mem_functorPushforward (R : Sieve X) {V} {f : V ⟶ X} (h : R f) :\n    R.functorPushforward F (F.map f) :=\n  ⟨V, f, 𝟙 _, h, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_functor","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX : C\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Sieve.functorPushforward e.functor S) (CategoryTheory.Sieve.functorPullback e.inverse (CategoryTheory.Sieve.pullback (e.unitInv.app X) S))","decl":"lemma functorPushforward_functor (S : Sieve X) (e : C ≌ D) :\n    S.functorPushforward e.functor = (S.pullback (e.unitInv.app X)).functorPullback e.inverse := by\n  ext Y iYX\n  constructor\n  · rintro ⟨Z, iZX, iYZ, hiZX, rfl⟩\n    simpa using S.downward_closed hiZX (e.inverse.map iYZ ≫ e.unitInv.app Z)\n  · intro H\n    exact ⟨_, e.inverse.map iYX ≫ e.unitInv.app X, e.counitInv.app Y, by simpa using H, by simp⟩\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_functor","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX : C\nY : D\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\nf : Quiver.Hom Y (e.functor.obj X)\n⊢ Iff ((CategoryTheory.Sieve.functorPushforward e.functor S).arrows f) (S.arrows (CategoryTheory.CategoryStruct.comp (e.inverse.map f) (e.unitInv.app X)))","decl":"@[simp]\nlemma mem_functorPushforward_functor {Y : D} {S : Sieve X} {e : C ≌ D} {f : Y ⟶ e.functor.obj X} :\n    S.functorPushforward e.functor f ↔ S (e.inverse.map f ≫ e.unitInv.app X) :=\n  congr($(S.functorPushforward_functor e).arrows f)\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_inverse","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nX : D\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\n⊢ Eq (CategoryTheory.Sieve.functorPushforward e.inverse S) (CategoryTheory.Sieve.functorPullback e.functor (CategoryTheory.Sieve.pullback (e.counit.app X) S))","decl":"lemma functorPushforward_inverse {X : D} (S : Sieve X) (e : C ≌ D) :\n    S.functorPushforward e.inverse = (S.pullback (e.counit.app X)).functorPullback e.functor :=\n  Sieve.functorPushforward_functor S e.symm\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_inverse","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\nY : C\nX : D\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\nf : Quiver.Hom Y (e.inverse.obj X)\n⊢ Iff ((CategoryTheory.Sieve.functorPushforward e.inverse S).arrows f) (S.arrows (CategoryTheory.CategoryStruct.comp (e.functor.map f) (e.counit.app X)))","decl":"@[simp]\nlemma mem_functorPushforward_inverse {X : D} {S : Sieve X} {e : C ≌ D} {f : Y ⟶ e.inverse.obj X} :\n    S.functorPushforward e.inverse f ↔ S (e.functor.map f ≫ e.counit.app X) :=\n  congr($(S.functorPushforward_inverse e).arrows f)\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_equivalence_eq_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nU : C\nS : CategoryTheory.Sieve U\n⊢ Eq (CategoryTheory.Sieve.functorPushforward e.inverse (CategoryTheory.Sieve.functorPushforward e.functor S)) (CategoryTheory.Sieve.pullback (e.unitInv.app U) S)","decl":"lemma functorPushforward_equivalence_eq_pullback {U : C} (S : Sieve U) :\n    Sieve.functorPushforward e.inverse (Sieve.functorPushforward e.functor S) =\n      Sieve.pullback (e.unitInv.app U) S := by ext; simp\n\n"}
{"name":"CategoryTheory.Sieve.pullback_functorPushforward_equivalence_eq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} D\ne : CategoryTheory.Equivalence C D\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.pullback (e.unit.app X) (CategoryTheory.Sieve.functorPushforward e.inverse (CategoryTheory.Sieve.functorPushforward e.functor S))) S","decl":"lemma pullback_functorPushforward_equivalence_eq {X : C} (S : Sieve X) :\n    Sieve.pullback (e.unit.app X) (Sieve.functorPushforward e.inverse\n      (Sieve.functorPushforward e.functor S)) = S := by ext; simp\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_iff_of_full","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝ : F.Full\nX Y : C\nR : CategoryTheory.Sieve X\nf : Quiver.Hom (F.obj Y) (F.obj X)\n⊢ Iff (CategoryTheory.Presieve.functorPushforward F R.arrows f) (Exists fun g => And (Eq (F.map g) f) (R.arrows g))","decl":"lemma mem_functorPushforward_iff_of_full [F.Full] {X Y : C} (R : Sieve X) (f : F.obj Y ⟶ F.obj X) :\n    (R.arrows.functorPushforward F) f ↔ ∃ (g : Y ⟶ X), F.map g = f ∧ R g := by\n  refine ⟨fun ⟨Z, g, h, hg, hcomp⟩ ↦ ?_, fun ⟨g, hcomp, hg⟩ ↦ ?_⟩\n  · obtain ⟨h', hh'⟩ := F.map_surjective h\n    use h' ≫ g\n    simp only [Functor.map_comp, hh', hcomp, true_and]\n    apply R.downward_closed hg\n  · use Y, g, 𝟙 _, hg\n    simp [hcomp]\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_iff_of_full_of_faithful","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.Full\ninst✝ : F.Faithful\nX Y : C\nR : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n⊢ Iff (CategoryTheory.Presieve.functorPushforward F R.arrows (F.map f)) (R.arrows f)","decl":"lemma mem_functorPushforward_iff_of_full_of_faithful [F.Full] [F.Faithful]\n    {X Y : C} (R : Sieve X) (f : Y ⟶ X) :\n    (R.arrows.functorPushforward F) (F.map f) ↔ R f := by\n  rw [Sieve.mem_functorPushforward_iff_of_full]\n  refine ⟨fun ⟨g, hcomp, hg⟩ ↦ ?_, fun hf ↦ ⟨f, rfl, hf⟩⟩\n  rwa [← F.map_injective hcomp]\n\n"}
{"name":"CategoryTheory.Sieve.functor_obj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nY : Opposite C\n⊢ Eq (S.functor.obj Y) (Subtype fun g => S.arrows g)","decl":"/-- A sieve induces a presheaf. -/\n@[simps]\ndef functor (S : Sieve X) : Cᵒᵖ ⥤ Type v₁ where\n  obj Y := { g : Y.unop ⟶ X // S g }\n  map f g := ⟨f.unop ≫ g.1, downward_closed _ g.2 _⟩\n\n"}
{"name":"CategoryTheory.Sieve.functor_map_coe","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\ng : Subtype fun g => S.arrows g\n⊢ Eq (↑(S.functor.map f g)) (CategoryTheory.CategoryStruct.comp f.unop ↑g)","decl":"/-- A sieve induces a presheaf. -/\n@[simps]\ndef functor (S : Sieve X) : Cᵒᵖ ⥤ Type v₁ where\n  obj Y := { g : Y.unop ⟶ X // S g }\n  map f g := ⟨f.unop ≫ g.1, downward_closed _ g.2 _⟩\n\n"}
{"name":"CategoryTheory.Sieve.natTransOfLe_app_coe","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\nx✝ : Opposite C\nf : S.functor.obj x✝\n⊢ Eq ↑((CategoryTheory.Sieve.natTransOfLe h).app x✝ f) ↑f","decl":"/-- If a sieve S is contained in a sieve T, then we have a morphism of presheaves on their induced\npresheaves.\n-/\n@[simps]\ndef natTransOfLe {S T : Sieve X} (h : S ≤ T) : S.functor ⟶ T.functor where app _ f := ⟨f.1, h _ f.2⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorInclusion_app","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\nx✝ : Opposite C\nf : S.functor.obj x✝\n⊢ Eq (S.functorInclusion.app x✝ f) ↑f","decl":"/-- The natural inclusion from the functor induced by a sieve to the yoneda embedding. -/\n@[simps]\ndef functorInclusion (S : Sieve X) : S.functor ⟶ yoneda.obj X where app _ f := f.1\n\n"}
{"name":"CategoryTheory.Sieve.natTransOfLe_comm","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.natTransOfLe h) T.functorInclusion) S.functorInclusion","decl":"theorem natTransOfLe_comm {S T : Sieve X} (h : S ≤ T) :\n    natTransOfLe h ≫ functorInclusion _ = functorInclusion _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorInclusion_is_mono","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ CategoryTheory.Mono S.functorInclusion","decl":"/-- The presheaf induced by a sieve is a subobject of the yoneda embedding. -/\ninstance functorInclusion_is_mono : Mono S.functorInclusion :=\n  ⟨fun f g h => by\n    ext Y y\n    simpa [Subtype.ext_iff_val] using congr_fun (NatTrans.congr_app h Y) y⟩\n\n-- TODO: Show that when `f` is mono, this is right inverse to `functorInclusion` up to isomorphism.\n"}
{"name":"CategoryTheory.Sieve.sieveOfSubfunctor_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nR : CategoryTheory.Functor (Opposite C) (Type v₁)\nf : Quiver.Hom R (CategoryTheory.yoneda.obj X)\nY : C\ng : Quiver.Hom Y X\n⊢ Eq ((CategoryTheory.Sieve.sieveOfSubfunctor f).arrows g) (Exists fun t => Eq (f.app { unop := Y } t) g)","decl":"/-- A natural transformation to a representable functor induces a sieve. This is the left inverse of\n`functorInclusion`, shown in `sieveOfSubfunctor_functorInclusion`.\n-/\n@[simps]\ndef sieveOfSubfunctor {R} (f : R ⟶ yoneda.obj X) : Sieve X where\n  arrows Y g := ∃ t, f.app (Opposite.op Y) t = g\n  downward_closed := by\n    rintro Y Z _ ⟨t, rfl⟩ g\n    refine ⟨R.map g.op t, ?_⟩\n    rw [FunctorToTypes.naturality _ _ f]\n    simp\n\n"}
{"name":"CategoryTheory.Sieve.sieveOfSubfunctor_functorInclusion","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\nS : CategoryTheory.Sieve X\n⊢ Eq (CategoryTheory.Sieve.sieveOfSubfunctor S.functorInclusion) S","decl":"theorem sieveOfSubfunctor_functorInclusion : sieveOfSubfunctor S.functorInclusion = S := by\n  ext\n  simp only [functorInclusion_app, sieveOfSubfunctor_apply]\n  constructor\n  · rintro ⟨⟨f, hf⟩, rfl⟩\n    exact hf\n  · intro hf\n    exact ⟨⟨_, hf⟩, rfl⟩\n\n"}
{"name":"CategoryTheory.Sieve.functorInclusion_top_isIso","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ CategoryTheory.IsIso Top.top.functorInclusion","decl":"instance functorInclusion_top_isIso : IsIso (⊤ : Sieve X).functorInclusion :=\n  ⟨⟨{ app := fun _ a => ⟨a, ⟨⟩⟩ }, rfl, rfl⟩⟩\n\n"}
