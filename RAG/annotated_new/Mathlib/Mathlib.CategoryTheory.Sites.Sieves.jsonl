{"name":"CategoryTheory.Presieve.BindStruct.hf","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nself : S.BindStruct R h\n‚ä¢ S self.f","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y)\n    {Z : C} (h : Z ‚ü∂ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ‚ü∂ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ‚ü∂ X\n  hf : S f\n  hg : R hf g\n  fac : g ‚â´ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nY‚úù : C\ng‚úù : Quiver.Hom Z Y‚úù\nf‚úù : Quiver.Hom Y‚úù X\nhf‚úù : S f‚úù\nhg‚úù : R hf‚úù g‚úù\nfac‚úù : Eq (CategoryTheory.CategoryStruct.comp g‚úù f‚úù) h\nY : C\ng : Quiver.Hom Z Y\nf : Quiver.Hom Y X\nhf : S f\nhg : R hf g\nfac : Eq (CategoryTheory.CategoryStruct.comp g f) h\n‚ä¢ Eq (Eq { Y := Y‚úù, g := g‚úù, f := f‚úù, hf := hf‚úù, hg := hg‚úù, fac := fac‚úù } { Y := Y, g := g, f := f, hf := hf, hg := hg, fac := fac }) (And (Eq Y‚úù Y) (And (HEq g‚úù g) (HEq f‚úù f)))","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y)\n    {Z : C} (h : Z ‚ü∂ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ‚ü∂ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ‚ü∂ X\n  hf : S f\n  hg : R hf g\n  fac : g ‚â´ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.fac","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nself : S.BindStruct R h\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.g self.f) h","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y)\n    {Z : C} (h : Z ‚ü∂ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ‚ü∂ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ‚ü∂ X\n  hf : S f\n  hg : R hf g\n  fac : g ‚â´ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nY‚úù : C\ng‚úù : Quiver.Hom Z Y‚úù\nf‚úù : Quiver.Hom Y‚úù X\nhf‚úù : S f‚úù\nhg‚úù : R hf‚úù g‚úù\nfac‚úù : Eq (CategoryTheory.CategoryStruct.comp g‚úù f‚úù) h\nY : C\ng : Quiver.Hom Z Y\nf : Quiver.Hom Y X\nhf : S f\nhg : R hf g\nfac : Eq (CategoryTheory.CategoryStruct.comp g f) h\nx‚úù : Eq { Y := Y‚úù, g := g‚úù, f := f‚úù, hf := hf‚úù, hg := hg‚úù, fac := fac‚úù } { Y := Y, g := g, f := f, hf := hf, hg := hg, fac := fac }\n‚ä¢ And (Eq Y‚úù Y) (And (HEq g‚úù g) (HEq f‚úù f))","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y)\n    {Z : C} (h : Z ‚ü∂ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ‚ü∂ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ‚ü∂ X\n  hf : S f\n  hg : R hf g\n  fac : g ‚â´ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.hg","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nself : S.BindStruct R h\n‚ä¢ R ‚ãØ self.g","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y)\n    {Z : C} (h : Z ‚ü∂ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ‚ü∂ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ‚ü∂ X\n  hf : S f\n  hg : R hf g\n  fac : g ‚â´ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\ninst‚úù¬≤ : SizeOf C\ninst‚úù¬π : ‚¶ÉY : C‚¶Ñ ‚Üí (a : Quiver.Hom Y X) ‚Üí SizeOf (S a)\ninst‚úù : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí (a : S f) ‚Üí ‚¶ÉY_1 : C‚¶Ñ ‚Üí (a_1 : Quiver.Hom Y_1 Y) ‚Üí SizeOf (R a a_1)\nY : C\ng : Quiver.Hom Z Y\nf : Quiver.Hom Y X\nhf : S f\nhg : R hf g\nfac : Eq (CategoryTheory.CategoryStruct.comp g f) h\n‚ä¢ Eq (SizeOf.sizeOf { Y := Y, g := g, f := f, hf := hf, hg := hg, fac := fac }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf Y)) (SizeOf.sizeOf g)) (SizeOf.sizeOf f)) (SizeOf.sizeOf hf)) (SizeOf.sizeOf hg)) (SizeOf.sizeOf fac))","decl":"/-- Structure which contains the data and properties for a morphism `h` satisfying\n`Presieve.bind S R h`. -/\nstructure BindStruct (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y)\n    {Z : C} (h : Z ‚ü∂ X) where\n  /-- the intermediate object -/\n  Y : C\n  /-- a morphism in the family of presieves `R` -/\n  g : Z ‚ü∂ Y\n  /-- a morphism in the presieve `S` -/\n  f : Y ‚ü∂ X\n  hf : S f\n  hg : R hf g\n  fac : g ‚â´ f = h\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.fac_assoc","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ‚úù : C\nh‚úù : Quiver.Hom Z‚úù X\nself : S.BindStruct R h‚úù\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.g (CategoryTheory.CategoryStruct.comp self.f h)) (CategoryTheory.CategoryStruct.comp h‚úù h)","decl":"attribute [reassoc (attr := simp)] BindStruct.fac\n\n"}
{"name":"CategoryTheory.Presieve.BindStruct.bind","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\nZ : C\nh : Quiver.Hom Z X\nb : S.BindStruct R h\n‚ä¢ S.bind R h","decl":"lemma BindStruct.bind {S : Presieve X} {R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y}\n    {Z : C} {h : Z ‚ü∂ X} (b : BindStruct S R h) : bind S R h :=\n  ‚ü®b.Y, b.g, b.f, b.hf, b.hg, b.fac‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.bind_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom Y X\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Presieve Y\ng : Quiver.Hom Z Y\nh‚ÇÅ : S f\nh‚ÇÇ : R h‚ÇÅ g\n‚ä¢ S.bind R (CategoryTheory.CategoryStruct.comp g f)","decl":"@[simp]\ntheorem bind_comp {S : Presieve X} {R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Presieve Y} {g : Z ‚ü∂ Y}\n    (h‚ÇÅ : S f) (h‚ÇÇ : R h‚ÇÅ g) : bind S R (g ‚â´ f) :=\n  ‚ü®_, _, _, h‚ÇÅ, h‚ÇÇ, rfl‚ü©\n\n-- Porting note: it seems the definition of `Presieve` must be unfolded in order to define\n--   this inductive type, it was thus renamed `singleton'`\n-- Note we can't make this into `HasSingleton` because of the out-param.\n"}
{"name":"CategoryTheory.Presieve.singleton.mk","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ CategoryTheory.Presieve.singleton f f","decl":"lemma singleton.mk {f : Y ‚ü∂ X} : singleton f f := singleton'.mk\n\n"}
{"name":"CategoryTheory.Presieve.singleton_eq_iff_domain","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf g : Quiver.Hom Y X\n‚ä¢ Iff (CategoryTheory.Presieve.singleton f g) (Eq f g)","decl":"@[simp]\ntheorem singleton_eq_iff_domain (f g : Y ‚ü∂ X) : singleton f g ‚Üî f = g := by\n  constructor\n  ¬∑ rintro ‚ü®a, rfl‚ü©\n    rfl\n  ¬∑ rintro rfl\n    apply singleton.mk\n\n"}
{"name":"CategoryTheory.Presieve.singleton_self","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ CategoryTheory.Presieve.singleton f f","decl":"theorem singleton_self : singleton f f :=\n  singleton.mk\n\n"}
{"name":"CategoryTheory.Presieve.pullback_singleton","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom Y X\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\ng : Quiver.Hom Z X\n‚ä¢ Eq (CategoryTheory.Presieve.pullbackArrows f (CategoryTheory.Presieve.singleton g)) (CategoryTheory.Presieve.singleton (CategoryTheory.Limits.pullback.snd g f))","decl":"theorem pullback_singleton [HasPullbacks C] (g : Z ‚ü∂ X) :\n    pullbackArrows f (singleton g) = singleton (pullback.snd g f) := by\n  funext W\n  ext h\n  constructor\n  ¬∑ rintro ‚ü®W, _, _, _‚ü©\n    exact singleton.mk\n  ¬∑ rintro ‚ü®_‚ü©\n    exact pullbackArrows.mk Z g singleton.mk\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_pUnit","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Presieve.ofArrows (fun x => Y) fun x => f) (CategoryTheory.Presieve.singleton f)","decl":"theorem ofArrows_pUnit : (ofArrows _ fun _ : PUnit => f) = singleton f := by\n  funext Y\n  ext g\n  constructor\n  ¬∑ rintro ‚ü®_‚ü©\n    apply singleton.mk\n  ¬∑ rintro ‚ü®_‚ü©\n    exact ofArrows.mk PUnit.unit\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nŒπ : Type u_1\nZ : Œπ ‚Üí C\ng : (i : Œπ) ‚Üí Quiver.Hom (Z i) X\n‚ä¢ Eq (CategoryTheory.Presieve.ofArrows (fun i => CategoryTheory.Limits.pullback (g i) f) fun x => CategoryTheory.Limits.pullback.snd (g x) f) (CategoryTheory.Presieve.pullbackArrows f (CategoryTheory.Presieve.ofArrows Z g))","decl":"theorem ofArrows_pullback [HasPullbacks C] {Œπ : Type*} (Z : Œπ ‚Üí C) (g : ‚àÄ i : Œπ, Z i ‚ü∂ X) :\n    (ofArrows (fun i => pullback (g i) f) fun _ => pullback.snd _ _) =\n      pullbackArrows f (ofArrows Z g) := by\n  funext T\n  ext h\n  constructor\n  ¬∑ rintro ‚ü®hk‚ü©\n    exact pullbackArrows.mk _ _ (ofArrows.mk hk)\n  ¬∑ rintro ‚ü®W, k, hk‚ÇÅ‚ü©\n    cases' hk‚ÇÅ with i hi\n    apply ofArrows.mk\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_bind","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nŒπ : Type u_1\nZ : Œπ ‚Üí C\ng : (i : Œπ) ‚Üí Quiver.Hom (Z i) X\nj : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Quiver.Hom Y X) ‚Üí CategoryTheory.Presieve.ofArrows Z g f ‚Üí Type u_2\nW : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Quiver.Hom Y X) ‚Üí (H : CategoryTheory.Presieve.ofArrows Z g f) ‚Üí j f H ‚Üí C\nk : ‚¶ÉY : C‚¶Ñ ‚Üí (f : Quiver.Hom Y X) ‚Üí (H : CategoryTheory.Presieve.ofArrows Z g f) ‚Üí (i : j f H) ‚Üí Quiver.Hom (W f H i) Y\n‚ä¢ Eq ((CategoryTheory.Presieve.ofArrows Z g).bind fun x f H => CategoryTheory.Presieve.ofArrows (W f H) (k f H)) (CategoryTheory.Presieve.ofArrows (fun i => W (g i.fst) ‚ãØ i.snd) fun ij => CategoryTheory.CategoryStruct.comp (k (g ij.fst) ‚ãØ ij.snd) (g ij.fst))","decl":"theorem ofArrows_bind {Œπ : Type*} (Z : Œπ ‚Üí C) (g : ‚àÄ i : Œπ, Z i ‚ü∂ X)\n    (j : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), ofArrows Z g f ‚Üí Type*) (W : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) (H), j f H ‚Üí C)\n    (k : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X) (H i), W f H i ‚ü∂ Y) :\n    ((ofArrows Z g).bind fun _ f H => ofArrows (W f H) (k f H)) =\n      ofArrows (fun i : Œ£i, j _ (ofArrows.mk i) => W (g i.1) _ i.2) fun ij =>\n        k (g ij.1) _ ij.2 ‚â´ g ij.1 := by\n  funext Y\n  ext f\n  constructor\n  ¬∑ rintro ‚ü®_, _, _, ‚ü®i‚ü©, ‚ü®i'‚ü©, rfl‚ü©\n    exact ofArrows.mk (Sigma.mk _ _)\n  ¬∑ rintro ‚ü®i‚ü©\n    exact bind_comp _ (ofArrows.mk _) (ofArrows.mk _)\n\n"}
{"name":"CategoryTheory.Presieve.ofArrows_surj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nŒπ : Type u_1\nY : Œπ ‚Üí C\nf : (i : Œπ) ‚Üí Quiver.Hom (Y i) X\nZ : C\ng : Quiver.Hom Z X\nhg : CategoryTheory.Presieve.ofArrows Y f g\n‚ä¢ Exists fun i => Exists fun h => Eq g (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (f i))","decl":"theorem ofArrows_surj {Œπ : Type*} {Y : Œπ ‚Üí C} (f : ‚àÄ i, Y i ‚ü∂ X) {Z : C} (g : Z ‚ü∂ X)\n    (hg : ofArrows Y f g) : ‚àÉ (i : Œπ) (h : Y i = Z),\n    g = eqToHom h.symm ‚â´ f i := by\n  cases' hg with i\n  exact ‚ü®i, rfl, by simp only [eqToHom_refl, id_comp]‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.functorPullback_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Presieve (F.obj X)\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Iff (CategoryTheory.Presieve.functorPullback F R f) (R (F.map f))","decl":"@[simp]\ntheorem functorPullback_mem (R : Presieve (F.obj X)) {Y} (f : Y ‚ü∂ X) :\n    R.functorPullback F f ‚Üî R (F.map f) :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Presieve.functorPullback_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Presieve X\n‚ä¢ Eq (CategoryTheory.Presieve.functorPullback (CategoryTheory.Functor.id C) R) R","decl":"@[simp]\ntheorem functorPullback_id (R : Presieve X) : R.functorPullback (ùü≠ _) = R :=\n  rfl\n\n"}
{"name":"CategoryTheory.Presieve.hasPullbacks.has_pullbacks","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Presieve X\nself : R.hasPullbacks\nY Z : C\nf : Quiver.Hom Y X\nx‚úù¬π : R f\ng : Quiver.Hom Z X\nx‚úù : R g\n‚ä¢ CategoryTheory.Limits.HasPullback f g","decl":"/-- Given a presieve `R` on `X`, the predicate `R.hasPullbacks` means that for all arrows `f` and\n    `g` in `R`, the pullback of `f` and `g` exists. -/\nclass hasPullbacks (R : Presieve X) : Prop where\n  /-- For all arrows `f` and `g` in `R`, the pullback of `f` and `g` exists. -/\n  has_pullbacks : ‚àÄ {Y Z} {f : Y ‚ü∂ X} (_ : R f) {g : Z ‚ü∂ X} (_ : R g), HasPullback f g\n\n"}
{"name":"CategoryTheory.Presieve.instHasPullbacksOfHasPullbacks","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Presieve X\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\n‚ä¢ R.hasPullbacks","decl":"instance (R : Presieve X) [HasPullbacks C] : R.hasPullbacks := ‚ü®fun _ _ ‚Ü¶ inferInstance‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.instHasPullbackOfHasPullbacksOfArrows","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nŒ± : Type v‚ÇÇ\nX : Œ± ‚Üí C\nB : C\nœÄ : (a : Œ±) ‚Üí Quiver.Hom (X a) B\ninst‚úù : (CategoryTheory.Presieve.ofArrows X œÄ).hasPullbacks\na b : Œ±\n‚ä¢ CategoryTheory.Limits.HasPullback (œÄ a) (œÄ b)","decl":"instance {Œ± : Type v‚ÇÇ} {X : Œ± ‚Üí C} {B : C} (œÄ : (a : Œ±) ‚Üí X a ‚ü∂ B)\n    [(Presieve.ofArrows X œÄ).hasPullbacks] (a b : Œ±) : HasPullback (œÄ a) (œÄ b) :=\n  Presieve.hasPullbacks.has_pullbacks (Presieve.ofArrows.mk _) (Presieve.ofArrows.mk _)\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.cover","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\nself : CategoryTheory.Presieve.FunctorPushforwardStructure F S f\n‚ä¢ S self.premap","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ‚ü∂ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ‚ü∂ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ‚ü∂ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ‚â´ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.fac","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\nself : CategoryTheory.Presieve.FunctorPushforwardStructure F S f\n‚ä¢ Eq f (CategoryTheory.CategoryStruct.comp self.lift (F.map self.premap))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ‚ü∂ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ‚ü∂ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ‚ü∂ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ‚â´ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\npreobj‚úù : C\npremap‚úù : Quiver.Hom preobj‚úù X\nlift‚úù : Quiver.Hom Y (F.obj preobj‚úù)\ncover‚úù : S premap‚úù\nfac‚úù : Eq f (CategoryTheory.CategoryStruct.comp lift‚úù (F.map premap‚úù))\npreobj : C\npremap : Quiver.Hom preobj X\nlift : Quiver.Hom Y (F.obj preobj)\ncover : S premap\nfac : Eq f (CategoryTheory.CategoryStruct.comp lift (F.map premap))\nx‚úù : Eq { preobj := preobj‚úù, premap := premap‚úù, lift := lift‚úù, cover := cover‚úù, fac := fac‚úù } { preobj := preobj, premap := premap, lift := lift, cover := cover, fac := fac }\n‚ä¢ And (Eq preobj‚úù preobj) (And (HEq premap‚úù premap) (HEq lift‚úù lift))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ‚ü∂ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ‚ü∂ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ‚ü∂ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ‚â´ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\npreobj‚úù : C\npremap‚úù : Quiver.Hom preobj‚úù X\nlift‚úù : Quiver.Hom Y (F.obj preobj‚úù)\ncover‚úù : S premap‚úù\nfac‚úù : Eq f (CategoryTheory.CategoryStruct.comp lift‚úù (F.map premap‚úù))\npreobj : C\npremap : Quiver.Hom preobj X\nlift : Quiver.Hom Y (F.obj preobj)\ncover : S premap\nfac : Eq f (CategoryTheory.CategoryStruct.comp lift (F.map premap))\n‚ä¢ Eq (Eq { preobj := preobj‚úù, premap := premap‚úù, lift := lift‚úù, cover := cover‚úù, fac := fac‚úù } { preobj := preobj, premap := premap, lift := lift, cover := cover, fac := fac }) (And (Eq preobj‚úù preobj) (And (HEq premap‚úù premap) (HEq lift‚úù lift)))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ‚ü∂ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ‚ü∂ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ‚ü∂ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ‚â´ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.FunctorPushforwardStructure.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS : CategoryTheory.Presieve X\nY : D\nf : Quiver.Hom Y (F.obj X)\ninst‚úù¬≤ : SizeOf C\ninst‚úù¬π : SizeOf D\ninst‚úù : ‚¶ÉY : C‚¶Ñ ‚Üí (a : Quiver.Hom Y X) ‚Üí SizeOf (S a)\npreobj : C\npremap : Quiver.Hom preobj X\nlift : Quiver.Hom Y (F.obj preobj)\ncover : S premap\nfac : Eq f (CategoryTheory.CategoryStruct.comp lift (F.map premap))\n‚ä¢ Eq (SizeOf.sizeOf { preobj := preobj, premap := premap, lift := lift, cover := cover, fac := fac }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf preobj)) (SizeOf.sizeOf premap)) (SizeOf.sizeOf lift)) (SizeOf.sizeOf cover)) (SizeOf.sizeOf fac))","decl":"/-- An auxiliary definition in order to fix the choice of the preimages between various definitions.\n-/\nstructure FunctorPushforwardStructure (S : Presieve X) {Y} (f : Y ‚ü∂ F.obj X) where\n  /-- an object in the source category -/\n  preobj : C\n  /-- a map in the source category which has to be in the presieve -/\n  premap : preobj ‚ü∂ X\n  /-- the morphism which appear in the factorisation -/\n  lift : Y ‚ü∂ F.obj preobj\n  /-- the condition that `premap` is in the presieve -/\n  cover : S premap\n  /-- the factorisation of the morphism -/\n  fac : f = lift ‚â´ F.map premap\n\n"}
{"name":"CategoryTheory.Presieve.functorPushforward_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor D E\nR : CategoryTheory.Presieve X\n‚ä¢ Eq (CategoryTheory.Presieve.functorPushforward (F.comp G) R) (CategoryTheory.Presieve.functorPushforward G (CategoryTheory.Presieve.functorPushforward F R))","decl":"theorem functorPushforward_comp (R : Presieve X) :\n    R.functorPushforward (F ‚ãô G) = (R.functorPushforward F).functorPushforward G := by\n  funext x\n  ext f\n  constructor\n  ¬∑ rintro ‚ü®X, f‚ÇÅ, g‚ÇÅ, h‚ÇÅ, rfl‚ü©\n    exact ‚ü®F.obj X, F.map f‚ÇÅ, g‚ÇÅ, ‚ü®X, f‚ÇÅ, ùüô _, h‚ÇÅ, by simp‚ü©, rfl‚ü©\n  ¬∑ rintro ‚ü®X, f‚ÇÅ, g‚ÇÅ, ‚ü®X', f‚ÇÇ, g‚ÇÇ, h‚ÇÅ, rfl‚ü©, rfl‚ü©\n    exact ‚ü®X', f‚ÇÇ, g‚ÇÅ ‚â´ G.map g‚ÇÇ, h‚ÇÅ, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Presieve.image_mem_functorPushforward","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nR : CategoryTheory.Presieve X\nf : Quiver.Hom Y X\nh : R f\n‚ä¢ CategoryTheory.Presieve.functorPushforward F R (F.map f)","decl":"theorem image_mem_functorPushforward (R : Presieve X) {f : Y ‚ü∂ X} (h : R f) :\n    R.functorPushforward F (F.map f) :=\n  ‚ü®Y, f, ùüô _, h, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.mk.inj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\narrows‚úù : CategoryTheory.Presieve X\ndownward_closed‚úù : ‚àÄ {Y Z : C} {f : Quiver.Hom Y X}, arrows‚úù f ‚Üí ‚àÄ (g : Quiver.Hom Z Y), arrows‚úù (CategoryTheory.CategoryStruct.comp g f)\narrows : CategoryTheory.Presieve X\ndownward_closed : ‚àÄ {Y Z : C} {f : Quiver.Hom Y X}, arrows f ‚Üí ‚àÄ (g : Quiver.Hom Z Y), arrows (CategoryTheory.CategoryStruct.comp g f)\nx‚úù : Eq { arrows := arrows‚úù, downward_closed := downward_closed‚úù } { arrows := arrows, downward_closed := downward_closed }\n‚ä¢ Eq arrows‚úù arrows","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ‚àÄ {Y Z f} (_ : arrows f) (g : Z ‚ü∂ Y), arrows (g ‚â´ f)\n\n"}
{"name":"CategoryTheory.Sieve.downward_closed","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nself : CategoryTheory.Sieve X\nY Z : C\nf : Quiver.Hom Y X\nx‚úù : self.arrows f\ng : Quiver.Hom Z Y\n‚ä¢ self.arrows (CategoryTheory.CategoryStruct.comp g f)","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ‚àÄ {Y Z f} (_ : arrows f) (g : Z ‚ü∂ Y), arrows (g ‚â´ f)\n\n"}
{"name":"CategoryTheory.Sieve.mk.injEq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\narrows‚úù : CategoryTheory.Presieve X\ndownward_closed‚úù : ‚àÄ {Y Z : C} {f : Quiver.Hom Y X}, arrows‚úù f ‚Üí ‚àÄ (g : Quiver.Hom Z Y), arrows‚úù (CategoryTheory.CategoryStruct.comp g f)\narrows : CategoryTheory.Presieve X\ndownward_closed : ‚àÄ {Y Z : C} {f : Quiver.Hom Y X}, arrows f ‚Üí ‚àÄ (g : Quiver.Hom Z Y), arrows (CategoryTheory.CategoryStruct.comp g f)\n‚ä¢ Eq (Eq { arrows := arrows‚úù, downward_closed := downward_closed‚úù } { arrows := arrows, downward_closed := downward_closed }) (Eq arrows‚úù arrows)","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ‚àÄ {Y Z f} (_ : arrows f) (g : Z ‚ü∂ Y), arrows (g ‚â´ f)\n\n"}
{"name":"CategoryTheory.Sieve.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\ninst‚úù : SizeOf C\narrows : CategoryTheory.Presieve X\ndownward_closed : ‚àÄ {Y Z : C} {f : Quiver.Hom Y X}, arrows f ‚Üí ‚àÄ (g : Quiver.Hom Z Y), arrows (CategoryTheory.CategoryStruct.comp g f)\n‚ä¢ Eq (SizeOf.sizeOf { arrows := arrows, downward_closed := downward_closed }) 1","decl":"/--\nFor an object `X` of a category `C`, a `Sieve X` is a set of morphisms to `X` which is closed under\nleft-composition.\n-/\nstructure Sieve {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] (X : C) where\n  /-- the underlying presieve -/\n  arrows : Presieve X\n  /-- stability by precomposition -/\n  downward_closed : ‚àÄ {Y Z f} (_ : arrows f) (g : Z ‚ü∂ Y), arrows (g ‚â´ f)\n\n"}
{"name":"CategoryTheory.Sieve.arrows_ext","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR S : CategoryTheory.Sieve X\na‚úù : Eq R.arrows S.arrows\n‚ä¢ Eq R S","decl":"theorem arrows_ext : ‚àÄ {R S : Sieve X}, R.arrows = S.arrows ‚Üí R = S := by\n  rintro ‚ü®_, _‚ü© ‚ü®_, _‚ü© rfl\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.ext_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR S : CategoryTheory.Sieve X\n‚ä¢ Iff (Eq R S) (‚àÄ ‚¶ÉY : C‚¶Ñ (f : Quiver.Hom Y X), Iff (R.arrows f) (S.arrows f))","decl":"@[ext]\nprotected theorem ext {R S : Sieve X} (h : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üî S f) : R = S :=\n  arrows_ext <| funext fun _ => funext fun f => propext <| h f\n\n"}
{"name":"CategoryTheory.Sieve.ext","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR S : CategoryTheory.Sieve X\nh : ‚àÄ ‚¶ÉY : C‚¶Ñ (f : Quiver.Hom Y X), Iff (R.arrows f) (S.arrows f)\n‚ä¢ Eq R S","decl":"@[ext]\nprotected theorem ext {R S : Sieve X} (h : ‚àÄ ‚¶ÉY‚¶Ñ (f : Y ‚ü∂ X), R f ‚Üî S f) : R = S :=\n  arrows_ext <| funext fun _ => funext fun f => propext <| h f\n\n"}
{"name":"CategoryTheory.Sieve.sInf_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nSs : Set (CategoryTheory.Sieve X)\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Iff ((InfSet.sInf Ss).arrows f) (‚àÄ (S : CategoryTheory.Sieve X), Membership.mem Ss S ‚Üí S.arrows f)","decl":"@[simp]\ntheorem sInf_apply {Ss : Set (Sieve X)} {Y} (f : Y ‚ü∂ X) :\n    sInf Ss f ‚Üî ‚àÄ (S : Sieve X) (_ : S ‚àà Ss), S f :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Sieve.sSup_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nSs : Set (CategoryTheory.Sieve X)\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Iff ((SupSet.sSup Ss).arrows f) (Exists fun S => Exists fun x => S.arrows f)","decl":"@[simp]\ntheorem sSup_apply {Ss : Set (Sieve X)} {Y} (f : Y ‚ü∂ X) :\n    sSup Ss f ‚Üî ‚àÉ (S : Sieve X) (_ : S ‚àà Ss), S f := by\n  simp [sSup, Sieve.sup, setOf]\n\n"}
{"name":"CategoryTheory.Sieve.inter_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR S : CategoryTheory.Sieve X\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Iff ((Min.min R S).arrows f) (And (R.arrows f) (S.arrows f))","decl":"@[simp]\ntheorem inter_apply {R S : Sieve X} {Y} (f : Y ‚ü∂ X) : (R ‚äì S) f ‚Üî R f ‚àß S f :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Sieve.union_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR S : CategoryTheory.Sieve X\nY : C\nf : Quiver.Hom Y X\n‚ä¢ Iff ((Max.max R S).arrows f) (Or (R.arrows f) (S.arrows f))","decl":"@[simp]\ntheorem union_apply {R S : Sieve X} {Y} (f : Y ‚ü∂ X) : (R ‚äî S) f ‚Üî R f ‚à® S f :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.Sieve.top_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ Top.top.arrows f","decl":"@[simp]\ntheorem top_apply (f : Y ‚ü∂ X) : (‚ä§ : Sieve X) f :=\n  trivial\n\n"}
{"name":"CategoryTheory.Sieve.generate_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Presieve X\nZ : C\nf : Quiver.Hom Z X\n‚ä¢ Eq ((CategoryTheory.Sieve.generate R).arrows f) (Exists fun Y => Exists fun h => Exists fun g => And (R g) (Eq (CategoryTheory.CategoryStruct.comp h g) f))","decl":"/-- Generate the smallest sieve containing the given set of arrows. -/\n@[simps]\ndef generate (R : Presieve X) : Sieve X where\n  arrows Z f := ‚àÉ (Y : _) (h : Z ‚ü∂ Y) (g : Y ‚ü∂ X), R g ‚àß h ‚â´ g = f\n  downward_closed := by\n    rintro Y Z _ ‚ü®W, g, f, hf, rfl‚ü© h\n    exact ‚ü®_, h ‚â´ g, _, hf, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.bind_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Sieve Y\n‚ä¢ Eq (CategoryTheory.Sieve.bind S R).arrows (S.bind fun x x_1 h => (R h).arrows)","decl":"/-- Given a presieve on `X`, and a sieve on each domain of an arrow in the presieve, we can bind to\nproduce a sieve on `X`.\n-/\n@[simps]\ndef bind (S : Presieve X) (R : ‚àÄ ‚¶ÉY‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Sieve Y) : Sieve X where\n  arrows := S.bind fun _ _ h => R h\n  downward_closed := by\n    rintro Y Z f ‚ü®W, f, h, hh, hf, rfl‚ü© g\n    exact ‚ü®_, g ‚â´ f, _, hh, by simp [hf]‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.generate_le_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Presieve X\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (LE.le (CategoryTheory.Sieve.generate R) S) (LE.le R S.arrows)","decl":"theorem generate_le_iff (R : Presieve X) (S : Sieve X) : generate R ‚â§ S ‚Üî R ‚â§ S :=\n  ‚ü®fun H _ _ hg => H _ ‚ü®_, ùüô _, _, hg, id_comp _‚ü©, fun ss Y f => by\n    rintro ‚ü®Z, f, g, hg, rfl‚ü©\n    exact S.downward_closed (ss Z hg) f‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.le_generate","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Presieve X\n‚ä¢ LE.le R (CategoryTheory.Sieve.generate R).arrows","decl":"theorem le_generate (R : Presieve X) : R ‚â§ generate R :=\n  giGenerate.gc.le_u_l R\n\n"}
{"name":"CategoryTheory.Sieve.generate_sieve","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.generate S.arrows) S","decl":"@[simp]\ntheorem generate_sieve (S : Sieve X) : generate S = S :=\n  giGenerate.l_u_eq S\n\n"}
{"name":"CategoryTheory.Sieve.id_mem_iff_eq_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Iff (S.arrows (CategoryTheory.CategoryStruct.id X)) (Eq S Top.top)","decl":"/-- If the identity arrow is in a sieve, the sieve is maximal. -/\ntheorem id_mem_iff_eq_top : S (ùüô X) ‚Üî S = ‚ä§ :=\n  ‚ü®fun h => top_unique fun Y f _ => by simpa using downward_closed _ h f, fun h => h.symm ‚ñ∏ trivial‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.generate_of_contains_isSplitEpi","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nR : CategoryTheory.Presieve X\nf : Quiver.Hom Y X\ninst‚úù : CategoryTheory.IsSplitEpi f\nhf : R f\n‚ä¢ Eq (CategoryTheory.Sieve.generate R) Top.top","decl":"/-- If an arrow set contains a split epi, it generates the maximal sieve. -/\ntheorem generate_of_contains_isSplitEpi {R : Presieve X} (f : Y ‚ü∂ X) [IsSplitEpi f] (hf : R f) :\n    generate R = ‚ä§ := by\n  rw [‚Üê id_mem_iff_eq_top]\n  exact ‚ü®_, section_ f, f, hf, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.generate_of_singleton_isSplitEpi","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\ninst‚úù : CategoryTheory.IsSplitEpi f\n‚ä¢ Eq (CategoryTheory.Sieve.generate (CategoryTheory.Presieve.singleton f)) Top.top","decl":"@[simp]\ntheorem generate_of_singleton_isSplitEpi (f : Y ‚ü∂ X) [IsSplitEpi f] :\n    generate (Presieve.singleton f) = ‚ä§ :=\n  generate_of_contains_isSplitEpi f (Presieve.singleton_self _)\n\n"}
{"name":"CategoryTheory.Sieve.generate_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ Eq (CategoryTheory.Sieve.generate Top.top) Top.top","decl":"@[simp]\ntheorem generate_top : generate (‚ä§ : Presieve X) = ‚ä§ :=\n  generate_of_contains_isSplitEpi (ùüô _) ‚ü®‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.comp_mem_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\ni : Quiver.Hom X Y\nf : Quiver.Hom Y Z\ninst‚úù : CategoryTheory.IsIso i\nS : CategoryTheory.Sieve Z\n‚ä¢ Iff (S.arrows (CategoryTheory.CategoryStruct.comp i f)) (S.arrows f)","decl":"@[simp]\nlemma comp_mem_iff (i : X ‚ü∂ Y) (f : Y ‚ü∂ Z) [IsIso i] (S : Sieve Z) :\n    S (i ‚â´ f) ‚Üî S f := by\n  refine ‚ü®fun H ‚Ü¶ ?_, fun H ‚Ü¶ S.downward_closed H _‚ü©\n  convert S.downward_closed H (inv i)\n  simp\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows_mk","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nX : C\nY : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\ni : I\n‚ä¢ (CategoryTheory.Sieve.ofArrows Y f).arrows (f i)","decl":"lemma ofArrows_mk (i : I) : ofArrows Y f (f i) :=\n  ‚ü®_, ùüô _, _, ‚ü®i‚ü©, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.mem_ofArrows_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nX : C\nY : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\n‚ä¢ Iff ((CategoryTheory.Sieve.ofArrows Y f).arrows g) (Exists fun i => Exists fun a => Eq g (CategoryTheory.CategoryStruct.comp a (f i)))","decl":"lemma mem_ofArrows_iff {W : C} (g : W ‚ü∂ X) :\n    ofArrows Y f g ‚Üî ‚àÉ (i : I) (a : W ‚ü∂ Y i), g = a ‚â´ f i := by\n  constructor\n  ¬∑ rintro ‚ü®T, a, b, ‚ü®i‚ü©, rfl‚ü©\n    exact ‚ü®i, a, rfl‚ü©\n  ¬∑ rintro ‚ü®i, a, rfl‚ü©\n    apply downward_closed _ (ofArrows_mk Y f i)\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows.exists","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nX : C\nY : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\nhg : (CategoryTheory.Sieve.ofArrows Y f).arrows g\n‚ä¢ Exists fun i => Exists fun h => Eq g (CategoryTheory.CategoryStruct.comp h (f i))","decl":"include hg in\nlemma ofArrows.exists : ‚àÉ (i : I) (h : W ‚ü∂ Y i), g = h ‚â´ f i := by\n  obtain ‚ü®_, h, _, H, rfl‚ü© := hg\n  cases' H with i\n  exact ‚ü®i, h, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows.fac_assoc","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nX : C\nY : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\nhg : (CategoryTheory.Sieve.ofArrows Y f).arrows g\nZ : C\nh : Quiver.Hom X Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.ofArrows.h hg) (CategoryTheory.CategoryStruct.comp (f (CategoryTheory.Sieve.ofArrows.i hg)) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\nlemma ofArrows.fac : h hg ‚â´ f (i hg) = g :=\n  (ofArrows.exists hg).choose_spec.choose_spec.symm\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows.fac","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nX : C\nY : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\nW : C\ng : Quiver.Hom W X\nhg : (CategoryTheory.Sieve.ofArrows Y f).arrows g\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.ofArrows.h hg) (f (CategoryTheory.Sieve.ofArrows.i hg))) g","decl":"@[reassoc (attr := simp)]\nlemma ofArrows.fac : h hg ‚â´ f (i hg) = g :=\n  (ofArrows.exists hg).choose_spec.choose_spec.symm\n\n"}
{"name":"CategoryTheory.Sieve.mem_ofObjects_iff","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nY : I ‚Üí C\nZ X : C\ng : Quiver.Hom Z X\n‚ä¢ Iff ((CategoryTheory.Sieve.ofObjects Y X).arrows g) (Exists fun i => Nonempty (Quiver.Hom Z (Y i)))","decl":"lemma mem_ofObjects_iff {I : Type*} (Y : I ‚Üí C) {Z X : C} (g : Z ‚ü∂ X) :\n    ofObjects Y X g ‚Üî ‚àÉ (i : I), Nonempty (Z ‚ü∂ Y i) := by rfl\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows_le_ofObjects","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nY : I ‚Üí C\nX : C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\n‚ä¢ LE.le (CategoryTheory.Sieve.ofArrows Y f) (CategoryTheory.Sieve.ofObjects Y X)","decl":"lemma ofArrows_le_ofObjects\n    {I : Type*} (Y : I ‚Üí C) {X : C} (f : ‚àÄ i, Y i ‚ü∂ X) :\n    Sieve.ofArrows Y f ‚â§ Sieve.ofObjects Y X := by\n  intro W g hg\n  rw [mem_ofArrows_iff] at hg\n  obtain ‚ü®i, a, rfl‚ü© := hg\n  exact ‚ü®i, ‚ü®a‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.ofArrows_eq_ofObjects","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nhX : CategoryTheory.Limits.IsTerminal X\nI : Type u_1\nY : I ‚Üí C\nf : (i : I) ‚Üí Quiver.Hom (Y i) X\n‚ä¢ Eq (CategoryTheory.Sieve.ofArrows Y f) (CategoryTheory.Sieve.ofObjects Y X)","decl":"lemma ofArrows_eq_ofObjects {X : C} (hX : IsTerminal X)\n    {I : Type*} (Y : I ‚Üí C) (f : ‚àÄ i, Y i ‚ü∂ X) :\n    ofArrows Y f = ofObjects Y X := by\n  refine le_antisymm (ofArrows_le_ofObjects Y f) (fun W g => ?_)\n  rw [mem_ofArrows_iff, mem_ofObjects_iff]\n  rintro ‚ü®i, ‚ü®h‚ü©‚ü©\n  exact ‚ü®i, h, hX.hom_ext _ _‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.pullback_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nh : Quiver.Hom Y X\nS : CategoryTheory.Sieve X\nx‚úù : C\nsl : Quiver.Hom x‚úù Y\n‚ä¢ Eq ((CategoryTheory.Sieve.pullback h S).arrows sl) (S.arrows (CategoryTheory.CategoryStruct.comp sl h))","decl":"/-- Given a morphism `h : Y ‚ü∂ X`, send a sieve S on X to a sieve on Y\n    as the inverse image of S with `_ ‚â´ h`.\n    That is, `Sieve.pullback S h := (‚â´ h) '‚Åª¬π S`. -/\n@[simps]\ndef pullback (h : Y ‚ü∂ X) (S : Sieve X) : Sieve Y where\n  arrows _ sl := S (sl ‚â´ h)\n  downward_closed g := by simp [g]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.pullback (CategoryTheory.CategoryStruct.id X) S) S","decl":"@[simp]\ntheorem pullback_id : S.pullback (ùüô _) = S := by simp [Sieve.ext_iff]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ Eq (CategoryTheory.Sieve.pullback f Top.top) Top.top","decl":"@[simp]\ntheorem pullback_top {f : Y ‚ü∂ X} : (‚ä§ : Sieve X).pullback f = ‚ä§ :=\n  top_unique fun _ _ => id\n\n"}
{"name":"CategoryTheory.Sieve.pullback_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nS : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.pullback (CategoryTheory.CategoryStruct.comp g f) S) (CategoryTheory.Sieve.pullback g (CategoryTheory.Sieve.pullback f S))","decl":"theorem pullback_comp {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (S : Sieve X) :\n    S.pullback (g ‚â´ f) = (S.pullback f).pullback g := by simp [Sieve.ext_iff]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_inter","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.pullback f (Min.min S R)) (Min.min (CategoryTheory.Sieve.pullback f S) (CategoryTheory.Sieve.pullback f R))","decl":"@[simp]\ntheorem pullback_inter {f : Y ‚ü∂ X} (S R : Sieve X) :\n    (S ‚äì R).pullback f = S.pullback f ‚äì R.pullback f := by simp [Sieve.ext_iff]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_eq_top_iff_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n‚ä¢ Iff (S.arrows f) (Eq (CategoryTheory.Sieve.pullback f S) Top.top)","decl":"theorem pullback_eq_top_iff_mem (f : Y ‚ü∂ X) : S f ‚Üî S.pullback f = ‚ä§ := by\n  rw [‚Üê id_mem_iff_eq_top, pullback_apply, id_comp]\n\n"}
{"name":"CategoryTheory.Sieve.pullback_eq_top_of_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nS : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\na‚úù : S.arrows f\n‚ä¢ Eq (CategoryTheory.Sieve.pullback f S) Top.top","decl":"theorem pullback_eq_top_of_mem (S : Sieve X) {f : Y ‚ü∂ X} : S f ‚Üí S.pullback f = ‚ä§ :=\n  (pullback_eq_top_iff_mem f).1\n\n"}
{"name":"CategoryTheory.Sieve.pullback_ofObjects_eq_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nI : Type u_1\nY : I ‚Üí C\nX : C\ni : I\ng : Quiver.Hom X (Y i)\n‚ä¢ Eq (CategoryTheory.Sieve.ofObjects Y X) Top.top","decl":"lemma pullback_ofObjects_eq_top\n    {I : Type*} (Y : I ‚Üí C) {X : C} {i : I} (g : X ‚ü∂ Y i) :\n    ofObjects Y X = ‚ä§ := by\n  ext Z h\n  simp only [top_apply, iff_true]\n  rw [mem_ofObjects_iff ]\n  exact ‚ü®i, ‚ü®h ‚â´ g‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Sieve Y\nx‚úù : C\ngf : Quiver.Hom x‚úù X\n‚ä¢ Eq ((CategoryTheory.Sieve.pushforward f R).arrows gf) (Exists fun g => And (Eq (CategoryTheory.CategoryStruct.comp g f) gf) (R.arrows g))","decl":"/-- Push a sieve `R` on `Y` forward along an arrow `f : Y ‚ü∂ X`: `gf : Z ‚ü∂ X` is in the sieve if `gf`\nfactors through some `g : Z ‚ü∂ Y` which is in `R`.\n-/\n@[simps]\ndef pushforward (f : Y ‚ü∂ X) (R : Sieve Y) : Sieve X where\n  arrows _ gf := ‚àÉ g, g ‚â´ f = gf ‚àß R g\n  downward_closed := fun ‚ü®j, k, z‚ü© h => ‚ü®h ‚â´ j, by simp [k], by simp [z]‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_apply_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nR : CategoryTheory.Sieve Y\nZ : C\ng : Quiver.Hom Z Y\nhg : R.arrows g\nf : Quiver.Hom Y X\n‚ä¢ (CategoryTheory.Sieve.pushforward f R).arrows (CategoryTheory.CategoryStruct.comp g f)","decl":"theorem pushforward_apply_comp {R : Sieve Y} {Z : C} {g : Z ‚ü∂ Y} (hg : R g) (f : Y ‚ü∂ X) :\n    R.pushforward f (g ‚â´ f) :=\n  ‚ü®g, rfl, hg‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y Z : C\nf : Quiver.Hom Y X\ng : Quiver.Hom Z Y\nR : CategoryTheory.Sieve Z\n‚ä¢ Eq (CategoryTheory.Sieve.pushforward (CategoryTheory.CategoryStruct.comp g f) R) (CategoryTheory.Sieve.pushforward f (CategoryTheory.Sieve.pushforward g R))","decl":"theorem pushforward_comp {f : Y ‚ü∂ X} {g : Z ‚ü∂ Y} (R : Sieve Z) :\n    R.pushforward (g ‚â´ f) = (R.pushforward g).pushforward f :=\n  Sieve.ext fun W h =>\n    ‚ü®fun ‚ü®f‚ÇÅ, hq, hf‚ÇÅ‚ü© => ‚ü®f‚ÇÅ ‚â´ g, by simpa, f‚ÇÅ, rfl, hf‚ÇÅ‚ü©, fun ‚ü®y, hy, z, hR, hz‚ü© =>\n      ‚ü®z, by rw [‚Üê Category.assoc, hR]; tauto‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.galoisConnection","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ GaloisConnection (CategoryTheory.Sieve.pushforward f) (CategoryTheory.Sieve.pullback f)","decl":"theorem galoisConnection (f : Y ‚ü∂ X) : GaloisConnection (Sieve.pushforward f) (Sieve.pullback f) :=\n  fun _ _ => ‚ü®fun hR _ g hg => hR _ ‚ü®g, rfl, hg‚ü©, fun hS _ _ ‚ü®h, hg, hh‚ü© => hg ‚ñ∏ hS h hh‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.pullback_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ Monotone (CategoryTheory.Sieve.pullback f)","decl":"theorem pullback_monotone (f : Y ‚ü∂ X) : Monotone (Sieve.pullback f) :=\n  (galoisConnection f).monotone_u\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\n‚ä¢ Monotone (CategoryTheory.Sieve.pushforward f)","decl":"theorem pushforward_monotone (f : Y ‚ü∂ X) : Monotone (Sieve.pushforward f) :=\n  (galoisConnection f).monotone_l\n\n"}
{"name":"CategoryTheory.Sieve.le_pushforward_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Sieve Y\n‚ä¢ LE.le R (CategoryTheory.Sieve.pullback f (CategoryTheory.Sieve.pushforward f R))","decl":"theorem le_pushforward_pullback (f : Y ‚ü∂ X) (R : Sieve Y) : R ‚â§ (R.pushforward f).pullback f :=\n  (galoisConnection f).le_u_l _\n\n"}
{"name":"CategoryTheory.Sieve.pullback_pushforward_le","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Sieve X\n‚ä¢ LE.le (CategoryTheory.Sieve.pushforward f (CategoryTheory.Sieve.pullback f R)) R","decl":"theorem pullback_pushforward_le (f : Y ‚ü∂ X) (R : Sieve X) : (R.pullback f).pushforward f ‚â§ R :=\n  (galoisConnection f).l_u_le _\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_union","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nf : Quiver.Hom Y X\nS R : CategoryTheory.Sieve Y\n‚ä¢ Eq (CategoryTheory.Sieve.pushforward f (Max.max S R)) (Max.max (CategoryTheory.Sieve.pushforward f S) (CategoryTheory.Sieve.pushforward f R))","decl":"theorem pushforward_union {f : Y ‚ü∂ X} (S R : Sieve Y) :\n    (S ‚äî R).pushforward f = S.pushforward f ‚äî R.pushforward f :=\n  (galoisConnection f).l_sup\n\n"}
{"name":"CategoryTheory.Sieve.pushforward_le_bind_of_mem","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Sieve Y\nf : Quiver.Hom Y X\nh : S f\n‚ä¢ LE.le (CategoryTheory.Sieve.pushforward f (R h)) (CategoryTheory.Sieve.bind S R)","decl":"theorem pushforward_le_bind_of_mem (S : Presieve X) (R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Sieve Y)\n    (f : Y ‚ü∂ X) (h : S f) : (R h).pushforward f ‚â§ bind S R := by\n  rintro Z _ ‚ü®g, rfl, hg‚ü©\n  exact ‚ü®_, g, f, h, hg, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.le_pullback_bind","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX Y : C\nS : CategoryTheory.Presieve X\nR : ‚¶ÉY : C‚¶Ñ ‚Üí ‚¶Éf : Quiver.Hom Y X‚¶Ñ ‚Üí S f ‚Üí CategoryTheory.Sieve Y\nf : Quiver.Hom Y X\nh : S f\n‚ä¢ LE.le (R h) (CategoryTheory.Sieve.pullback f (CategoryTheory.Sieve.bind S R))","decl":"theorem le_pullback_bind (S : Presieve X) (R : ‚àÄ ‚¶ÉY : C‚¶Ñ ‚¶Éf : Y ‚ü∂ X‚¶Ñ, S f ‚Üí Sieve Y) (f : Y ‚ü∂ X)\n    (h : S f) : R h ‚â§ (bind S R).pullback f := by\n  rw [‚Üê galoisConnection f]\n  apply pushforward_le_bind_of_mem\n\n"}
{"name":"CategoryTheory.Sieve.pullbackArrows_comm","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Limits.HasPullbacks C\nX Y : C\nf : Quiver.Hom Y X\nR : CategoryTheory.Presieve X\n‚ä¢ Eq (CategoryTheory.Sieve.generate (CategoryTheory.Presieve.pullbackArrows f R)) (CategoryTheory.Sieve.pullback f (CategoryTheory.Sieve.generate R))","decl":"theorem pullbackArrows_comm [HasPullbacks C] {X Y : C} (f : Y ‚ü∂ X) (R : Presieve X) :\n    Sieve.generate (R.pullbackArrows f) = (Sieve.generate R).pullback f := by\n  ext W g\n  constructor\n  ¬∑ rintro ‚ü®_, h, k, hk, rfl‚ü©\n    cases' hk with W g hg\n    rw [Sieve.pullback_apply, assoc, ‚Üê pullback.condition, ‚Üê assoc]\n    exact Sieve.downward_closed _ (by exact Sieve.le_generate R W hg) (h ‚â´ pullback.fst g f)\n  ¬∑ rintro ‚ü®W, h, k, hk, comm‚ü©\n    exact ‚ü®_, _, _, Presieve.pullbackArrows.mk _ _ hk, pullback.lift_snd _ _ comm‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve (F.obj X)\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback F R).arrows (CategoryTheory.Presieve.functorPullback F R.arrows)","decl":"/--\nIf `R` is a sieve, then the `CategoryTheory.Presieve.functorPullback` of `R` is actually a sieve.\n-/\n@[simps]\ndef functorPullback (R : Sieve (F.obj X)) : Sieve X where\n  arrows := Presieve.functorPullback F R\n  downward_closed := by\n    intro _ _ f hf g\n    unfold Presieve.functorPullback\n    rw [F.map_comp]\n    exact R.downward_closed hf (F.map g)\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_arrows","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve (F.obj X)\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback F R).arrows (CategoryTheory.Presieve.functorPullback F R.arrows)","decl":"@[simp]\ntheorem functorPullback_arrows (R : Sieve (F.obj X)) :\n    (R.functorPullback F).arrows = R.arrows.functorPullback F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback (CategoryTheory.Functor.id C) R) R","decl":"@[simp]\ntheorem functorPullback_id (R : Sieve X) : R.functorPullback (ùü≠ _) = R := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor D E\nR : CategoryTheory.Sieve ((F.comp G).obj X)\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback (F.comp G) R) (CategoryTheory.Sieve.functorPullback F (CategoryTheory.Sieve.functorPullback G R))","decl":"theorem functorPullback_comp (R : Sieve ((F ‚ãô G).obj X)) :\n    R.functorPullback (F ‚ãô G) = (R.functorPullback G).functorPullback F := by\n  ext\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_extend_eq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Presieve X\n‚ä¢ Eq (CategoryTheory.Presieve.functorPushforward F (CategoryTheory.Sieve.generate R).arrows) (CategoryTheory.Presieve.functorPushforward F R)","decl":"theorem functorPushforward_extend_eq {R : Presieve X} :\n    (generate R).arrows.functorPushforward F = R.functorPushforward F := by\n  funext Y\n  ext f\n  constructor\n  ¬∑ rintro ‚ü®X', g, f', ‚ü®X'', g', f'', h‚ÇÅ, rfl‚ü©, rfl‚ü©\n    exact ‚ü®X'', f'', f' ‚â´ F.map g', h‚ÇÅ, by simp‚ü©\n  ¬∑ rintro ‚ü®X', g, f', h‚ÇÅ, h‚ÇÇ‚ü©\n    exact ‚ü®X', g, f', le_generate R _ h‚ÇÅ, h‚ÇÇ‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward F R).arrows (CategoryTheory.Presieve.functorPushforward F R.arrows)","decl":"/-- The sieve generated by the image of `R` under `F`. -/\n@[simps]\ndef functorPushforward (R : Sieve X) : Sieve (F.obj X) where\n  arrows := R.arrows.functorPushforward F\n  downward_closed := by\n    intro _ _ f h g\n    obtain ‚ü®X, Œ±, Œ≤, hŒ±, rfl‚ü© := h\n    exact ‚ü®X, Œ±, g ‚â´ Œ≤, hŒ±, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_id","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward (CategoryTheory.Functor.id C) R) R","decl":"@[simp]\ntheorem functorPushforward_id (R : Sieve X) : R.functorPushforward (ùü≠ _) = R := by\n  ext X f\n  constructor\n  ¬∑ intro hf\n    obtain ‚ü®X, g, h, hg, rfl‚ü© := hf\n    exact R.downward_closed hg h\n  ¬∑ intro hf\n    exact ‚ü®X, f, ùüô _, hf, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_comp","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nG : CategoryTheory.Functor D E\nR : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward (F.comp G) R) (CategoryTheory.Sieve.functorPushforward G (CategoryTheory.Sieve.functorPushforward F R))","decl":"theorem functorPushforward_comp (R : Sieve X) :\n    R.functorPushforward (F ‚ãô G) = (R.functorPushforward F).functorPushforward G := by\n  ext\n  simp [R.arrows.functorPushforward_comp F G]\n\n"}
{"name":"CategoryTheory.Sieve.functor_galoisConnection","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ GaloisConnection (CategoryTheory.Sieve.functorPushforward F) (CategoryTheory.Sieve.functorPullback F)","decl":"theorem functor_galoisConnection (X : C) :\n    GaloisConnection (Sieve.functorPushforward F : Sieve X ‚Üí Sieve (F.obj X))\n      (Sieve.functorPullback F) := by\n  intro R S\n  constructor\n  ¬∑ intro hle X f hf\n    apply hle\n    refine ‚ü®X, f, ùüô _, hf, ?_‚ü©\n    rw [id_comp]\n  ¬∑ rintro hle Y f ‚ü®X, g, h, hg, rfl‚ü©\n    apply Sieve.downward_closed S\n    exact hle g hg\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Monotone (CategoryTheory.Sieve.functorPullback F)","decl":"theorem functorPullback_monotone (X : C) :\n    Monotone (Sieve.functorPullback F : Sieve (F.obj X) ‚Üí Sieve X) :=\n  (functor_galoisConnection F X).monotone_u\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_monotone","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Monotone (CategoryTheory.Sieve.functorPushforward F)","decl":"theorem functorPushforward_monotone (X : C) :\n    Monotone (Sieve.functorPushforward F : Sieve X ‚Üí Sieve (F.obj X)) :=\n  (functor_galoisConnection F X).monotone_l\n\n"}
{"name":"CategoryTheory.Sieve.le_functorPushforward_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve X\n‚ä¢ LE.le R (CategoryTheory.Sieve.functorPullback F (CategoryTheory.Sieve.functorPushforward F R))","decl":"theorem le_functorPushforward_pullback (R : Sieve X) :\n    R ‚â§ (R.functorPushforward F).functorPullback F :=\n  (functor_galoisConnection F X).le_u_l _\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_pushforward_le","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve (F.obj X)\n‚ä¢ LE.le (CategoryTheory.Sieve.functorPushforward F (CategoryTheory.Sieve.functorPullback F R)) R","decl":"theorem functorPullback_pushforward_le (R : Sieve (F.obj X)) :\n    (R.functorPullback F).functorPushforward F ‚â§ R :=\n  (functor_galoisConnection F X).l_u_le _\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_union","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS R : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward F (Max.max S R)) (Max.max (CategoryTheory.Sieve.functorPushforward F S) (CategoryTheory.Sieve.functorPushforward F R))","decl":"theorem functorPushforward_union (S R : Sieve X) :\n    (S ‚äî R).functorPushforward F = S.functorPushforward F ‚äî R.functorPushforward F :=\n  (functor_galoisConnection F X).l_sup\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_union","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS R : CategoryTheory.Sieve (F.obj X)\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback F (Max.max S R)) (Max.max (CategoryTheory.Sieve.functorPullback F S) (CategoryTheory.Sieve.functorPullback F R))","decl":"theorem functorPullback_union (S R : Sieve (F.obj X)) :\n    (S ‚äî R).functorPullback F = S.functorPullback F ‚äî R.functorPullback F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_inter","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nS R : CategoryTheory.Sieve (F.obj X)\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback F (Min.min S R)) (Min.min (CategoryTheory.Sieve.functorPullback F S) (CategoryTheory.Sieve.functorPullback F R))","decl":"theorem functorPullback_inter (S R : Sieve (F.obj X)) :\n    (S ‚äì R).functorPullback F = S.functorPullback F ‚äì R.functorPullback F :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_bot","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward F Bot.bot) Bot.bot","decl":"@[simp]\ntheorem functorPushforward_bot (F : C ‚•§ D) (X : C) : (‚ä• : Sieve X).functorPushforward F = ‚ä• :=\n  (functor_galoisConnection F X).l_bot\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward F Top.top) Top.top","decl":"@[simp]\ntheorem functorPushforward_top (F : C ‚•§ D) (X : C) : (‚ä§ : Sieve X).functorPushforward F = ‚ä§ := by\n  refine (generate_sieve _).symm.trans ?_\n  apply generate_of_contains_isSplitEpi (ùüô (F.obj X))\n  exact ‚ü®X, ùüô _, ùüô _, trivial, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_bot","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback F Bot.bot) Bot.bot","decl":"@[simp]\ntheorem functorPullback_bot (F : C ‚•§ D) (X : C) : (‚ä• : Sieve (F.obj X)).functorPullback F = ‚ä• :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorPullback_top","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\n‚ä¢ Eq (CategoryTheory.Sieve.functorPullback F Top.top) Top.top","decl":"@[simp]\ntheorem functorPullback_top (F : C ‚•§ D) (X : C) : (‚ä§ : Sieve (F.obj X)).functorPullback F = ‚ä§ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.image_mem_functorPushforward","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX : C\nR : CategoryTheory.Sieve X\nV : C\nf : Quiver.Hom V X\nh : R.arrows f\n‚ä¢ (CategoryTheory.Sieve.functorPushforward F R).arrows (F.map f)","decl":"theorem image_mem_functorPushforward (R : Sieve X) {V} {f : V ‚ü∂ X} (h : R f) :\n    R.functorPushforward F (F.map f) :=\n  ‚ü®V, f, ùüô _, h, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_functor","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward e.functor S) (CategoryTheory.Sieve.functorPullback e.inverse (CategoryTheory.Sieve.pullback (e.unitInv.app X) S))","decl":"lemma functorPushforward_functor (S : Sieve X) (e : C ‚âå D) :\n    S.functorPushforward e.functor = (S.pullback (e.unitInv.app X)).functorPullback e.inverse := by\n  ext Y iYX\n  constructor\n  ¬∑ rintro ‚ü®Z, iZX, iYZ, hiZX, rfl‚ü©\n    simpa using S.downward_closed hiZX (e.inverse.map iYZ ‚â´ e.unitInv.app Z)\n  ¬∑ intro H\n    exact ‚ü®_, e.inverse.map iYX ‚â´ e.unitInv.app X, e.counitInv.app Y, by simpa using H, by simp‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_functor","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : C\nY : D\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\nf : Quiver.Hom Y (e.functor.obj X)\n‚ä¢ Iff ((CategoryTheory.Sieve.functorPushforward e.functor S).arrows f) (S.arrows (CategoryTheory.CategoryStruct.comp (e.inverse.map f) (e.unitInv.app X)))","decl":"@[simp]\nlemma mem_functorPushforward_functor {Y : D} {S : Sieve X} {e : C ‚âå D} {f : Y ‚ü∂ e.functor.obj X} :\n    S.functorPushforward e.functor f ‚Üî S (e.inverse.map f ‚â´ e.unitInv.app X) :=\n  congr($(S.functorPushforward_functor e).arrows f)\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_inverse","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nX : D\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward e.inverse S) (CategoryTheory.Sieve.functorPullback e.functor (CategoryTheory.Sieve.pullback (e.counit.app X) S))","decl":"lemma functorPushforward_inverse {X : D} (S : Sieve X) (e : C ‚âå D) :\n    S.functorPushforward e.inverse = (S.pullback (e.counit.app X)).functorPullback e.functor :=\n  Sieve.functorPushforward_functor S e.symm\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_inverse","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nY : C\nX : D\nS : CategoryTheory.Sieve X\ne : CategoryTheory.Equivalence C D\nf : Quiver.Hom Y (e.inverse.obj X)\n‚ä¢ Iff ((CategoryTheory.Sieve.functorPushforward e.inverse S).arrows f) (S.arrows (CategoryTheory.CategoryStruct.comp (e.functor.map f) (e.counit.app X)))","decl":"@[simp]\nlemma mem_functorPushforward_inverse {X : D} {S : Sieve X} {e : C ‚âå D} {f : Y ‚ü∂ e.inverse.obj X} :\n    S.functorPushforward e.inverse f ‚Üî S (e.functor.map f ‚â´ e.counit.app X) :=\n  congr($(S.functorPushforward_inverse e).arrows f)\n\n"}
{"name":"CategoryTheory.Sieve.functorPushforward_equivalence_eq_pullback","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nU : C\nS : CategoryTheory.Sieve U\n‚ä¢ Eq (CategoryTheory.Sieve.functorPushforward e.inverse (CategoryTheory.Sieve.functorPushforward e.functor S)) (CategoryTheory.Sieve.pullback (e.unitInv.app U) S)","decl":"lemma functorPushforward_equivalence_eq_pullback {U : C} (S : Sieve U) :\n    Sieve.functorPushforward e.inverse (Sieve.functorPushforward e.functor S) =\n      Sieve.pullback (e.unitInv.app U) S := by ext; simp\n\n"}
{"name":"CategoryTheory.Sieve.pullback_functorPushforward_equivalence_eq","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.pullback (e.unit.app X) (CategoryTheory.Sieve.functorPushforward e.inverse (CategoryTheory.Sieve.functorPushforward e.functor S))) S","decl":"lemma pullback_functorPushforward_equivalence_eq {X : C} (S : Sieve X) :\n    Sieve.pullback (e.unit.app X) (Sieve.functorPushforward e.inverse\n      (Sieve.functorPushforward e.functor S)) = S := by ext; simp\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_iff_of_full","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.Full\nX Y : C\nR : CategoryTheory.Sieve X\nf : Quiver.Hom (F.obj Y) (F.obj X)\n‚ä¢ Iff (CategoryTheory.Presieve.functorPushforward F R.arrows f) (Exists fun g => And (Eq (F.map g) f) (R.arrows g))","decl":"lemma mem_functorPushforward_iff_of_full [F.Full] {X Y : C} (R : Sieve X) (f : F.obj Y ‚ü∂ F.obj X) :\n    (R.arrows.functorPushforward F) f ‚Üî ‚àÉ (g : Y ‚ü∂ X), F.map g = f ‚àß R g := by\n  refine ‚ü®fun ‚ü®Z, g, h, hg, hcomp‚ü© ‚Ü¶ ?_, fun ‚ü®g, hcomp, hg‚ü© ‚Ü¶ ?_‚ü©\n  ¬∑ obtain ‚ü®h', hh'‚ü© := F.map_surjective h\n    use h' ‚â´ g\n    simp only [Functor.map_comp, hh', hcomp, true_and]\n    apply R.downward_closed hg\n  ¬∑ use Y, g, ùüô _, hg\n    simp [hcomp]\n\n"}
{"name":"CategoryTheory.Sieve.mem_functorPushforward_iff_of_full_of_faithful","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nX Y : C\nR : CategoryTheory.Sieve X\nf : Quiver.Hom Y X\n‚ä¢ Iff (CategoryTheory.Presieve.functorPushforward F R.arrows (F.map f)) (R.arrows f)","decl":"lemma mem_functorPushforward_iff_of_full_of_faithful [F.Full] [F.Faithful]\n    {X Y : C} (R : Sieve X) (f : Y ‚ü∂ X) :\n    (R.arrows.functorPushforward F) (F.map f) ‚Üî R f := by\n  rw [Sieve.mem_functorPushforward_iff_of_full]\n  refine ‚ü®fun ‚ü®g, hcomp, hg‚ü© ‚Ü¶ ?_, fun hf ‚Ü¶ ‚ü®f, rfl, hf‚ü©‚ü©\n  rwa [‚Üê F.map_injective hcomp]\n\n"}
{"name":"CategoryTheory.Sieve.functor_obj","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\nY : Opposite C\n‚ä¢ Eq (S.functor.obj Y) (Subtype fun g => S.arrows g)","decl":"/-- A sieve induces a presheaf. -/\n@[simps]\ndef functor (S : Sieve X) : C·µí·µñ ‚•§ Type v‚ÇÅ where\n  obj Y := { g : Y.unop ‚ü∂ X // S g }\n  map f g := ‚ü®f.unop ‚â´ g.1, downward_closed _ g.2 _‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functor_map_coe","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\nX‚úù Y‚úù : Opposite C\nf : Quiver.Hom X‚úù Y‚úù\ng : Subtype fun g => S.arrows g\n‚ä¢ Eq (‚Üë(S.functor.map f g)) (CategoryTheory.CategoryStruct.comp f.unop ‚Üëg)","decl":"/-- A sieve induces a presheaf. -/\n@[simps]\ndef functor (S : Sieve X) : C·µí·µñ ‚•§ Type v‚ÇÅ where\n  obj Y := { g : Y.unop ‚ü∂ X // S g }\n  map f g := ‚ü®f.unop ‚â´ g.1, downward_closed _ g.2 _‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.natTransOfLe_app_coe","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\nx‚úù : Opposite C\nf : S.functor.obj x‚úù\n‚ä¢ Eq ‚Üë((CategoryTheory.Sieve.natTransOfLe h).app x‚úù f) ‚Üëf","decl":"/-- If a sieve S is contained in a sieve T, then we have a morphism of presheaves on their induced\npresheaves.\n-/\n@[simps]\ndef natTransOfLe {S T : Sieve X} (h : S ‚â§ T) : S.functor ‚ü∂ T.functor where app _ f := ‚ü®f.1, h _ f.2‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorInclusion_app","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\nx‚úù : Opposite C\nf : S.functor.obj x‚úù\n‚ä¢ Eq (S.functorInclusion.app x‚úù f) ‚Üëf","decl":"/-- The natural inclusion from the functor induced by a sieve to the yoneda embedding. -/\n@[simps]\ndef functorInclusion (S : Sieve X) : S.functor ‚ü∂ yoneda.obj X where app _ f := f.1\n\n"}
{"name":"CategoryTheory.Sieve.natTransOfLe_comm","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS T : CategoryTheory.Sieve X\nh : LE.le S T\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Sieve.natTransOfLe h) T.functorInclusion) S.functorInclusion","decl":"theorem natTransOfLe_comm {S T : Sieve X} (h : S ‚â§ T) :\n    natTransOfLe h ‚â´ functorInclusion _ = functorInclusion _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Sieve.functorInclusion_is_mono","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ CategoryTheory.Mono S.functorInclusion","decl":"/-- The presheaf induced by a sieve is a subobject of the yoneda embedding. -/\ninstance functorInclusion_is_mono : Mono S.functorInclusion :=\n  ‚ü®fun f g h => by\n    ext Y y\n    simpa [Subtype.ext_iff_val] using congr_fun (NatTrans.congr_app h Y) y‚ü©\n\n-- TODO: Show that when `f` is mono, this is right inverse to `functorInclusion` up to isomorphism.\n"}
{"name":"CategoryTheory.Sieve.sieveOfSubfunctor_apply","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nR : CategoryTheory.Functor (Opposite C) (Type v‚ÇÅ)\nf : Quiver.Hom R (CategoryTheory.yoneda.obj X)\nY : C\ng : Quiver.Hom Y X\n‚ä¢ Eq ((CategoryTheory.Sieve.sieveOfSubfunctor f).arrows g) (Exists fun t => Eq (f.app { unop := Y } t) g)","decl":"/-- A natural transformation to a representable functor induces a sieve. This is the left inverse of\n`functorInclusion`, shown in `sieveOfSubfunctor_functorInclusion`.\n-/\n@[simps]\ndef sieveOfSubfunctor {R} (f : R ‚ü∂ yoneda.obj X) : Sieve X where\n  arrows Y g := ‚àÉ t, f.app (Opposite.op Y) t = g\n  downward_closed := by\n    rintro Y Z _ ‚ü®t, rfl‚ü© g\n    refine ‚ü®R.map g.op t, ?_‚ü©\n    rw [FunctorToTypes.naturality _ _ f]\n    simp\n\n"}
{"name":"CategoryTheory.Sieve.sieveOfSubfunctor_functorInclusion","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\nS : CategoryTheory.Sieve X\n‚ä¢ Eq (CategoryTheory.Sieve.sieveOfSubfunctor S.functorInclusion) S","decl":"theorem sieveOfSubfunctor_functorInclusion : sieveOfSubfunctor S.functorInclusion = S := by\n  ext\n  simp only [functorInclusion_app, sieveOfSubfunctor_apply]\n  constructor\n  ¬∑ rintro ‚ü®‚ü®f, hf‚ü©, rfl‚ü©\n    exact hf\n  ¬∑ intro hf\n    exact ‚ü®‚ü®_, hf‚ü©, rfl‚ü©\n\n"}
{"name":"CategoryTheory.Sieve.functorInclusion_top_isIso","module":"Mathlib.CategoryTheory.Sites.Sieves","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nX : C\n‚ä¢ CategoryTheory.IsIso Top.top.functorInclusion","decl":"instance functorInclusion_top_isIso : IsIso (‚ä§ : Sieve X).functorInclusion :=\n  ‚ü®‚ü®{ app := fun _ a => ‚ü®a, ‚ü®‚ü©‚ü© }, rfl, rfl‚ü©‚ü©\n\n"}
