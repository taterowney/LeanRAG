{"name":"LinearPMap.IsFormalAdjoint.symm","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nS : LinearPMap 𝕜 F E\nh : T.IsFormalAdjoint S\n⊢ S.IsFormalAdjoint T","decl":"@[symm]\nprotected theorem IsFormalAdjoint.symm (h : T.IsFormalAdjoint S) :\n    S.IsFormalAdjoint T := fun y _ => by\n  rw [← inner_conj_symm, ← inner_conj_symm (y : F), h]\n\n"}
{"name":"LinearPMap.adjointDomainMkCLM_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx : Subtype fun x => Membership.mem T.domain x\n⊢ Eq ((T.adjointDomainMkCLM y) x) (Inner.inner (↑y) (↑T x))","decl":"theorem adjointDomainMkCLM_apply (y : T.adjointDomain) (x : T.domain) :\n    adjointDomainMkCLM T y x = ⟪(y : F), T x⟫ :=\n  rfl\n\n"}
{"name":"LinearPMap.adjointDomainMkCLMExtend_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁴ : RCLike 𝕜\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace 𝕜 E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nhT : Dense ↑T.domain\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx : Subtype fun x => Membership.mem T.domain x\n⊢ Eq ((LinearPMap.adjointDomainMkCLMExtend hT y) ↑x) (Inner.inner (↑y) (↑T x))","decl":"@[simp]\ntheorem adjointDomainMkCLMExtend_apply (y : T.adjointDomain) (x : T.domain) :\n    adjointDomainMkCLMExtend hT y (x : E) = ⟪(y : F), T x⟫ :=\n  ContinuousLinearMap.extend_eq _ _ _ _ _\n\n"}
{"name":"LinearPMap.adjointAux_inner","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nhT : Dense ↑T.domain\ninst✝ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx : Subtype fun x => Membership.mem T.domain x\n⊢ Eq (Inner.inner ((LinearPMap.adjointAux hT) y) ↑x) (Inner.inner (↑y) (↑T x))","decl":"theorem adjointAux_inner (y : T.adjointDomain) (x : T.domain) :\n    ⟪adjointAux hT y, x⟫ = ⟪(y : F), T x⟫ := by\n  simp only [adjointAux, LinearMap.coe_mk, InnerProductSpace.toDual_symm_apply,\n    adjointDomainMkCLMExtend_apply]\n  -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5026):\n  -- mathlib3 was finished here\n  simp only [AddHom.coe_mk, InnerProductSpace.toDual_symm_apply]\n  rw [adjointDomainMkCLMExtend_apply]\n\n"}
{"name":"LinearPMap.adjointAux_unique","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nhT : Dense ↑T.domain\ninst✝ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx₀ : E\nhx₀ : ∀ (x : Subtype fun x => Membership.mem T.domain x), Eq (Inner.inner x₀ ↑x) (Inner.inner (↑y) (↑T x))\n⊢ Eq ((LinearPMap.adjointAux hT) y) x₀","decl":"theorem adjointAux_unique (y : T.adjointDomain) {x₀ : E}\n    (hx₀ : ∀ x : T.domain, ⟪x₀, x⟫ = ⟪(y : F), T x⟫) : adjointAux hT y = x₀ :=\n  hT.eq_of_inner_left fun v => (adjointAux_inner hT _ _).trans (hx₀ v).symm\n\n"}
{"name":"LinearPMap.mem_adjoint_domain_iff","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\ninst✝ : CompleteSpace E\ny : F\n⊢ Iff (Membership.mem T.adjoint.domain y) (Continuous ⇑(((innerₛₗ 𝕜) y).comp T.toFun))","decl":"theorem mem_adjoint_domain_iff (y : F) : y ∈ T†.domain ↔ Continuous ((innerₛₗ 𝕜 y).comp T.toFun) :=\n  Iff.rfl\n\n"}
{"name":"LinearPMap.mem_adjoint_domain_of_exists","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\ninst✝ : CompleteSpace E\ny : F\nh : Exists fun w => ∀ (x : Subtype fun x => Membership.mem T.domain x), Eq (Inner.inner w ↑x) (Inner.inner y (↑T x))\n⊢ Membership.mem T.adjoint.domain y","decl":"theorem mem_adjoint_domain_of_exists (y : F) (h : ∃ w : E, ∀ x : T.domain, ⟪w, x⟫ = ⟪y, T x⟫) :\n    y ∈ T†.domain := by\n  cases' h with w hw\n  rw [T.mem_adjoint_domain_iff]\n  have : Continuous ((innerSL 𝕜 w).comp T.domain.subtypeL) := by fun_prop\n  convert this using 1\n  exact funext fun x => (hw x).symm\n\n"}
{"name":"LinearPMap.adjoint_apply_of_not_dense","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\ninst✝ : CompleteSpace E\nhT : Not (Dense ↑T.domain)\ny : Subtype fun x => Membership.mem T.adjoint.domain x\n⊢ Eq (↑T.adjoint y) 0","decl":"theorem adjoint_apply_of_not_dense (hT : ¬Dense (T.domain : Set E)) (y : T†.domain) : T† y = 0 := by\n  classical\n  change (if hT : Dense (T.domain : Set E) then adjointAux hT else 0) y = _\n  simp only [hT, not_false_iff, dif_neg, LinearMap.zero_apply]\n\n"}
{"name":"LinearPMap.adjoint_apply_of_dense","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nhT : Dense ↑T.domain\ninst✝ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjoint.domain x\n⊢ Eq (↑T.adjoint y) ((LinearPMap.adjointAux hT) y)","decl":"theorem adjoint_apply_of_dense (y : T†.domain) : T† y = adjointAux hT y := by\n  classical\n  change (if hT : Dense (T.domain : Set E) then adjointAux hT else 0) y = _\n  simp only [hT, dif_pos, LinearMap.coe_mk]\n\n"}
{"name":"LinearPMap.adjoint_apply_eq","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nhT : Dense ↑T.domain\ninst✝ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjoint.domain x\nx₀ : E\nhx₀ : ∀ (x : Subtype fun x => Membership.mem T.domain x), Eq (Inner.inner x₀ ↑x) (Inner.inner (↑y) (↑T x))\n⊢ Eq (↑T.adjoint y) x₀","decl":"include hT in\ntheorem adjoint_apply_eq (y : T†.domain) {x₀ : E} (hx₀ : ∀ x : T.domain, ⟪x₀, x⟫ = ⟪(y : F), T x⟫) :\n    T† y = x₀ :=\n  (adjoint_apply_of_dense hT y).symm ▸ adjointAux_unique hT _ hx₀\n\n"}
{"name":"LinearPMap.adjoint_isFormalAdjoint","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nhT : Dense ↑T.domain\ninst✝ : CompleteSpace E\n⊢ T.adjoint.IsFormalAdjoint T","decl":"include hT in\n/-- The fundamental property of the adjoint. -/\ntheorem adjoint_isFormalAdjoint : T†.IsFormalAdjoint T := fun x =>\n  (adjoint_apply_of_dense hT x).symm ▸ adjointAux_inner hT x\n\n"}
{"name":"LinearPMap.IsFormalAdjoint.le_adjoint","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace 𝕜 E\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace 𝕜 F\nT : LinearPMap 𝕜 E F\nS : LinearPMap 𝕜 F E\nhT : Dense ↑T.domain\ninst✝ : CompleteSpace E\nh : T.IsFormalAdjoint S\n⊢ LE.le S T.adjoint","decl":"include hT in\n/-- The adjoint is maximal in the sense that it contains every formal adjoint. -/\ntheorem IsFormalAdjoint.le_adjoint (h : T.IsFormalAdjoint S) : S ≤ T† :=\n  ⟨-- Trivially, every `x : S.domain` is in `T.adjoint.domain`\n  fun x hx =>\n    mem_adjoint_domain_of_exists _\n      ⟨S ⟨x, hx⟩, h.symm ⟨x, hx⟩⟩,-- Equality on `S.domain` follows from equality\n  -- `⟪v, S x⟫ = ⟪v, T.adjoint y⟫` for all `v : T.domain`:\n  fun _ _ hxy => (adjoint_apply_eq hT _ fun _ => by rw [h.symm, hxy]).symm⟩\n\n"}
{"name":"ContinuousLinearMap.toPMap_adjoint_eq_adjoint_toPMap_of_dense","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : InnerProductSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : InnerProductSpace 𝕜 F\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id 𝕜) E F\np : Submodule 𝕜 E\nhp : Dense ↑p\n⊢ Eq ((↑A).toPMap p).adjoint ((↑(ContinuousLinearMap.adjoint A)).toPMap Top.top)","decl":"/-- Restricting `A` to a dense submodule and taking the `LinearPMap.adjoint` is the same\nas taking the `ContinuousLinearMap.adjoint` interpreted as a `LinearPMap`. -/\ntheorem toPMap_adjoint_eq_adjoint_toPMap_of_dense (hp : Dense (p : Set E)) :\n    (A.toPMap p).adjoint = A.adjoint.toPMap ⊤ := by\n  ext x y hxy\n  · simp only [LinearMap.toPMap_domain, Submodule.mem_top, iff_true,\n      LinearPMap.mem_adjoint_domain_iff, LinearMap.coe_comp, innerₛₗ_apply_coe]\n    exact ((innerSL 𝕜 x).comp <| A.comp <| Submodule.subtypeL _).cont\n  refine LinearPMap.adjoint_apply_eq ?_ _ fun v => ?_\n  · -- Porting note: was simply `hp` as an argument above\n    simpa using hp\n  · simp only [adjoint_inner_left, hxy, LinearMap.toPMap_apply, coe_coe]\n\n"}
{"name":"LinearPMap.isSelfAdjoint_def","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : LinearPMap 𝕜 E E\n⊢ Iff (IsSelfAdjoint A) (Eq A.adjoint A)","decl":"theorem isSelfAdjoint_def : IsSelfAdjoint A ↔ A† = A := Iff.rfl\n\n"}
{"name":"IsSelfAdjoint.dense_domain","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : RCLike 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : InnerProductSpace 𝕜 E\ninst✝ : CompleteSpace E\nA : LinearPMap 𝕜 E E\nhA : IsSelfAdjoint A\n⊢ Dense ↑A.domain","decl":"/-- Every self-adjoint `LinearPMap` has dense domain.\n\nThis is not true by definition since we define the adjoint without the assumption that the\ndomain is dense, but the choice of the junk value implies that a `LinearPMap` cannot be self-adjoint\nif it does not have dense domain. -/\ntheorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) := by\n  by_contra h\n  rw [isSelfAdjoint_def] at hA\n  have h' : A.domain = ⊤ := by\n    rw [← hA, Submodule.eq_top_iff']\n    intro x\n    rw [mem_adjoint_domain_iff, ← hA]\n    refine (innerSL 𝕜 x).cont.comp ?_\n    simp only [adjoint, h]\n    exact continuous_const\n  simp [h'] at h\n\n"}
