{"name":"LinearPMap.IsFormalAdjoint.symm","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nS : LinearPMap ğ•œ F E\nh : T.IsFormalAdjoint S\nâŠ¢ S.IsFormalAdjoint T","decl":"@[symm]\nprotected theorem IsFormalAdjoint.symm (h : T.IsFormalAdjoint S) :\n    S.IsFormalAdjoint T := fun y _ => by\n  rw [â† inner_conj_symm, â† inner_conj_symm (y : F), h]\n\n"}
{"name":"LinearPMap.adjointDomainMkCLM_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx : Subtype fun x => Membership.mem T.domain x\nâŠ¢ Eq ((T.adjointDomainMkCLM y) x) (Inner.inner (â†‘y) (â†‘T x))","decl":"theorem adjointDomainMkCLM_apply (y : T.adjointDomain) (x : T.domain) :\n    adjointDomainMkCLM T y x = âŸª(y : F), T xâŸ« :=\n  rfl\n\n"}
{"name":"LinearPMap.adjointDomainMkCLMExtend_apply","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : InnerProductSpace ğ•œ E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nhT : Dense â†‘T.domain\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx : Subtype fun x => Membership.mem T.domain x\nâŠ¢ Eq ((LinearPMap.adjointDomainMkCLMExtend hT y) â†‘x) (Inner.inner (â†‘y) (â†‘T x))","decl":"@[simp]\ntheorem adjointDomainMkCLMExtend_apply (y : T.adjointDomain) (x : T.domain) :\n    adjointDomainMkCLMExtend hT y (x : E) = âŸª(y : F), T xâŸ« :=\n  ContinuousLinearMap.extend_eq _ _ _ _ _\n\n"}
{"name":"LinearPMap.adjointAux_inner","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nhT : Dense â†‘T.domain\ninstâœ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjointDomain x\nx : Subtype fun x => Membership.mem T.domain x\nâŠ¢ Eq (Inner.inner ((LinearPMap.adjointAux hT) y) â†‘x) (Inner.inner (â†‘y) (â†‘T x))","decl":"theorem adjointAux_inner (y : T.adjointDomain) (x : T.domain) :\n    âŸªadjointAux hT y, xâŸ« = âŸª(y : F), T xâŸ« := by\n  simp only [adjointAux, LinearMap.coe_mk, InnerProductSpace.toDual_symm_apply,\n    adjointDomainMkCLMExtend_apply]\n  -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5026):\n  -- mathlib3 was finished here\n  simp only [AddHom.coe_mk, InnerProductSpace.toDual_symm_apply]\n  rw [adjointDomainMkCLMExtend_apply]\n\n"}
{"name":"LinearPMap.adjointAux_unique","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nhT : Dense â†‘T.domain\ninstâœ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjointDomain x\nxâ‚€ : E\nhxâ‚€ : âˆ€ (x : Subtype fun x => Membership.mem T.domain x), Eq (Inner.inner xâ‚€ â†‘x) (Inner.inner (â†‘y) (â†‘T x))\nâŠ¢ Eq ((LinearPMap.adjointAux hT) y) xâ‚€","decl":"theorem adjointAux_unique (y : T.adjointDomain) {xâ‚€ : E}\n    (hxâ‚€ : âˆ€ x : T.domain, âŸªxâ‚€, xâŸ« = âŸª(y : F), T xâŸ«) : adjointAux hT y = xâ‚€ :=\n  hT.eq_of_inner_left fun v => (adjointAux_inner hT _ _).trans (hxâ‚€ v).symm\n\n"}
{"name":"LinearPMap.mem_adjoint_domain_iff","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\ninstâœ : CompleteSpace E\ny : F\nâŠ¢ Iff (Membership.mem T.adjoint.domain y) (Continuous â‡‘(((innerâ‚›â‚— ğ•œ) y).comp T.toFun))","decl":"theorem mem_adjoint_domain_iff (y : F) : y âˆˆ Tâ€ .domain â†” Continuous ((innerâ‚›â‚— ğ•œ y).comp T.toFun) :=\n  Iff.rfl\n\n"}
{"name":"LinearPMap.mem_adjoint_domain_of_exists","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\ninstâœ : CompleteSpace E\ny : F\nh : Exists fun w => âˆ€ (x : Subtype fun x => Membership.mem T.domain x), Eq (Inner.inner w â†‘x) (Inner.inner y (â†‘T x))\nâŠ¢ Membership.mem T.adjoint.domain y","decl":"theorem mem_adjoint_domain_of_exists (y : F) (h : âˆƒ w : E, âˆ€ x : T.domain, âŸªw, xâŸ« = âŸªy, T xâŸ«) :\n    y âˆˆ Tâ€ .domain := by\n  cases' h with w hw\n  rw [T.mem_adjoint_domain_iff]\n  have : Continuous ((innerSL ğ•œ w).comp T.domain.subtypeL) := by fun_prop\n  convert this using 1\n  exact funext fun x => (hw x).symm\n\n"}
{"name":"LinearPMap.adjoint_apply_of_not_dense","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\ninstâœ : CompleteSpace E\nhT : Not (Dense â†‘T.domain)\ny : Subtype fun x => Membership.mem T.adjoint.domain x\nâŠ¢ Eq (â†‘T.adjoint y) 0","decl":"theorem adjoint_apply_of_not_dense (hT : Â¬Dense (T.domain : Set E)) (y : Tâ€ .domain) : Tâ€  y = 0 := by\n  classical\n  change (if hT : Dense (T.domain : Set E) then adjointAux hT else 0) y = _\n  simp only [hT, not_false_iff, dif_neg, LinearMap.zero_apply]\n\n"}
{"name":"LinearPMap.adjoint_apply_of_dense","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nhT : Dense â†‘T.domain\ninstâœ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjoint.domain x\nâŠ¢ Eq (â†‘T.adjoint y) ((LinearPMap.adjointAux hT) y)","decl":"theorem adjoint_apply_of_dense (y : Tâ€ .domain) : Tâ€  y = adjointAux hT y := by\n  classical\n  change (if hT : Dense (T.domain : Set E) then adjointAux hT else 0) y = _\n  simp only [hT, dif_pos, LinearMap.coe_mk]\n\n"}
{"name":"LinearPMap.adjoint_apply_eq","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nhT : Dense â†‘T.domain\ninstâœ : CompleteSpace E\ny : Subtype fun x => Membership.mem T.adjoint.domain x\nxâ‚€ : E\nhxâ‚€ : âˆ€ (x : Subtype fun x => Membership.mem T.domain x), Eq (Inner.inner xâ‚€ â†‘x) (Inner.inner (â†‘y) (â†‘T x))\nâŠ¢ Eq (â†‘T.adjoint y) xâ‚€","decl":"include hT in\ntheorem adjoint_apply_eq (y : Tâ€ .domain) {xâ‚€ : E} (hxâ‚€ : âˆ€ x : T.domain, âŸªxâ‚€, xâŸ« = âŸª(y : F), T xâŸ«) :\n    Tâ€  y = xâ‚€ :=\n  (adjoint_apply_of_dense hT y).symm â–¸ adjointAux_unique hT _ hxâ‚€\n\n"}
{"name":"LinearPMap.adjoint_isFormalAdjoint","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nhT : Dense â†‘T.domain\ninstâœ : CompleteSpace E\nâŠ¢ T.adjoint.IsFormalAdjoint T","decl":"include hT in\n/-- The fundamental property of the adjoint. -/\ntheorem adjoint_isFormalAdjoint : Tâ€ .IsFormalAdjoint T := fun x =>\n  (adjoint_apply_of_dense hT x).symm â–¸ adjointAux_inner hT x\n\n"}
{"name":"LinearPMap.IsFormalAdjoint.le_adjoint","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : InnerProductSpace ğ•œ E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : InnerProductSpace ğ•œ F\nT : LinearPMap ğ•œ E F\nS : LinearPMap ğ•œ F E\nhT : Dense â†‘T.domain\ninstâœ : CompleteSpace E\nh : T.IsFormalAdjoint S\nâŠ¢ LE.le S T.adjoint","decl":"include hT in\n/-- The adjoint is maximal in the sense that it contains every formal adjoint. -/\ntheorem IsFormalAdjoint.le_adjoint (h : T.IsFormalAdjoint S) : S â‰¤ Tâ€  :=\n  âŸ¨-- Trivially, every `x : S.domain` is in `T.adjoint.domain`\n  fun x hx =>\n    mem_adjoint_domain_of_exists _\n      âŸ¨S âŸ¨x, hxâŸ©, h.symm âŸ¨x, hxâŸ©âŸ©,-- Equality on `S.domain` follows from equality\n  -- `âŸªv, S xâŸ« = âŸªv, T.adjoint yâŸ«` for all `v : T.domain`:\n  fun _ _ hxy => (adjoint_apply_eq hT _ fun _ => by rw [h.symm, hxy]).symmâŸ©\n\n"}
{"name":"ContinuousLinearMap.toPMap_adjoint_eq_adjoint_toPMap_of_dense","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : InnerProductSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : InnerProductSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace F\nA : ContinuousLinearMap (RingHom.id ğ•œ) E F\np : Submodule ğ•œ E\nhp : Dense â†‘p\nâŠ¢ Eq ((â†‘A).toPMap p).adjoint ((â†‘(ContinuousLinearMap.adjoint A)).toPMap Top.top)","decl":"/-- Restricting `A` to a dense submodule and taking the `LinearPMap.adjoint` is the same\nas taking the `ContinuousLinearMap.adjoint` interpreted as a `LinearPMap`. -/\ntheorem toPMap_adjoint_eq_adjoint_toPMap_of_dense (hp : Dense (p : Set E)) :\n    (A.toPMap p).adjoint = A.adjoint.toPMap âŠ¤ := by\n  ext x y hxy\n  Â· simp only [LinearMap.toPMap_domain, Submodule.mem_top, iff_true,\n      LinearPMap.mem_adjoint_domain_iff, LinearMap.coe_comp, innerâ‚›â‚—_apply_coe]\n    exact ((innerSL ğ•œ x).comp <| A.comp <| Submodule.subtypeL _).cont\n  refine LinearPMap.adjoint_apply_eq ?_ _ fun v => ?_\n  Â· -- Porting note: was simply `hp` as an argument above\n    simpa using hp\n  Â· simp only [adjoint_inner_left, hxy, LinearMap.toPMap_apply, coe_coe]\n\n"}
{"name":"LinearPMap.isSelfAdjoint_def","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : LinearPMap ğ•œ E E\nâŠ¢ Iff (IsSelfAdjoint A) (Eq A.adjoint A)","decl":"theorem isSelfAdjoint_def : IsSelfAdjoint A â†” Aâ€  = A := Iff.rfl\n\n"}
{"name":"IsSelfAdjoint.dense_domain","module":"Mathlib.Analysis.InnerProductSpace.LinearPMap","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : InnerProductSpace ğ•œ E\ninstâœ : CompleteSpace E\nA : LinearPMap ğ•œ E E\nhA : IsSelfAdjoint A\nâŠ¢ Dense â†‘A.domain","decl":"/-- Every self-adjoint `LinearPMap` has dense domain.\n\nThis is not true by definition since we define the adjoint without the assumption that the\ndomain is dense, but the choice of the junk value implies that a `LinearPMap` cannot be self-adjoint\nif it does not have dense domain. -/\ntheorem _root_.IsSelfAdjoint.dense_domain (hA : IsSelfAdjoint A) : Dense (A.domain : Set E) := by\n  by_contra h\n  rw [isSelfAdjoint_def] at hA\n  have h' : A.domain = âŠ¤ := by\n    rw [â† hA, Submodule.eq_top_iff']\n    intro x\n    rw [mem_adjoint_domain_iff, â† hA]\n    refine (innerSL ğ•œ x).cont.comp ?_\n    simp only [adjoint, h]\n    exact continuous_const\n  simp [h'] at h\n\n"}
