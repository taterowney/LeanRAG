{"name":"Digraph.mk.inj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\nAdj✝ Adj : V → V → Prop\nx✝ : Eq { Adj := Adj✝ } { Adj := Adj }\n⊢ Eq Adj✝ Adj","decl":"/--\nA digraph is a relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\n\nIn this treatment, a digraph may have self-loops.\n-/\n@[ext]\nstructure Digraph (V : Type*) where\n  /-- The adjacency relation of a digraph. -/\n  Adj : V → V → Prop\n\n"}
{"name":"Digraph.ext_iff","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\nx y : Digraph V\n⊢ Iff (Eq x y) (Eq x.Adj y.Adj)","decl":"/--\nA digraph is a relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\n\nIn this treatment, a digraph may have self-loops.\n-/\n@[ext]\nstructure Digraph (V : Type*) where\n  /-- The adjacency relation of a digraph. -/\n  Adj : V → V → Prop\n\n"}
{"name":"Digraph.mk.injEq","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\nAdj✝ Adj : V → V → Prop\n⊢ Eq (Eq { Adj := Adj✝ } { Adj := Adj }) (Eq Adj✝ Adj)","decl":"/--\nA digraph is a relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\n\nIn this treatment, a digraph may have self-loops.\n-/\n@[ext]\nstructure Digraph (V : Type*) where\n  /-- The adjacency relation of a digraph. -/\n  Adj : V → V → Prop\n\n"}
{"name":"Digraph.ext","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\nx y : Digraph V\nAdj : Eq x.Adj y.Adj\n⊢ Eq x y","decl":"/--\nA digraph is a relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\n\nIn this treatment, a digraph may have self-loops.\n-/\n@[ext]\nstructure Digraph (V : Type*) where\n  /-- The adjacency relation of a digraph. -/\n  Adj : V → V → Prop\n\n"}
{"name":"Digraph.mk.sizeOf_spec","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\ninst✝ : SizeOf V\nAdj : V → V → Prop\n⊢ Eq (SizeOf.sizeOf { Adj := Adj }) 1","decl":"/--\nA digraph is a relation `Adj` on a vertex type `V`.\nThe relation describes which pairs of vertices are adjacent.\n\nIn this treatment, a digraph may have self-loops.\n-/\n@[ext]\nstructure Digraph (V : Type*) where\n  /-- The adjacency relation of a digraph. -/\n  Adj : V → V → Prop\n\n"}
{"name":"Digraph.mk'_apply_Adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\nx : V → V → Bool\nv w : V\n⊢ Eq ((Digraph.mk' x).Adj v w) (Eq (x v w) Bool.true)","decl":"/--\nConstructor for digraphs using a boolean function.\nThis is useful for creating a digraph with a decidable `Adj` relation,\nand it's used in the construction of the `Fintype (Digraph V)` instance.\n-/\n@[simps]\ndef Digraph.mk' {V : Type*} : (V → V → Bool) ↪ Digraph V where\n  toFun x := ⟨fun v w ↦ x v w⟩\n  inj' adj adj' := by\n    simp_rw [mk.injEq]\n    intro h\n    funext v w\n    simpa only [eq_iff_iff, Bool.coe_iff_coe] using congr($h v w)\n\n"}
{"name":"Digraph.completeBipartiteGraph_Adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_1\nW : Type u_2\nv w : Sum V W\n⊢ Eq ((Digraph.completeBipartiteGraph V W).Adj v w) (Or (And (Eq v.isLeft Bool.true) (Eq w.isRight Bool.true)) (And (Eq v.isRight Bool.true) (Eq w.isLeft Bool.true)))","decl":"/--\nTwo vertices are adjacent in the complete bipartite digraph on two vertex types\nif and only if they are not from the same side.\nAny bipartite digraph may be regarded as a subgraph of one of these.\n-/\n@[simps]\ndef completeBipartiteGraph (V W : Type*) : Digraph (Sum V W) where\n  Adj v w := v.isLeft ∧ w.isRight ∨ v.isRight ∧ w.isLeft\n\n"}
{"name":"Digraph.adj_injective","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\n⊢ Function.Injective Digraph.Adj","decl":"theorem adj_injective : Injective (Adj : Digraph V → V → V → Prop) := fun _ _ ↦ Digraph.ext\n\n"}
{"name":"Digraph.adj_inj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nG H : Digraph V\n⊢ Iff (Eq G.Adj H.Adj) (Eq G H)","decl":"@[simp] theorem adj_inj {G H : Digraph V} : G.Adj = H.Adj ↔ G = H := Digraph.ext_iff.symm\n\n"}
{"name":"Digraph.isSubgraph_eq_le","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\n⊢ Eq Digraph.IsSubgraph fun x1 x2 => LE.le x1 x2","decl":"@[simp]\ntheorem isSubgraph_eq_le : (Digraph.IsSubgraph : Digraph V → Digraph V → Prop) = (· ≤ ·) := rfl\n\n"}
{"name":"Digraph.sup_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nx y : Digraph V\nv w : V\n⊢ Iff ((Max.max x y).Adj v w) (Or (x.Adj v w) (y.Adj v w))","decl":"@[simp]\ntheorem sup_adj (x y : Digraph V) (v w : V) : (x ⊔ y).Adj v w ↔ x.Adj v w ∨ y.Adj v w := Iff.rfl\n\n"}
{"name":"Digraph.inf_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nx y : Digraph V\nv w : V\n⊢ Iff ((Min.min x y).Adj v w) (And (x.Adj v w) (y.Adj v w))","decl":"@[simp]\ntheorem inf_adj (x y : Digraph V) (v w : V) : (x ⊓ y).Adj v w ↔ x.Adj v w ∧ y.Adj v w := Iff.rfl\n\n"}
{"name":"Digraph.compl_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nG : Digraph V\nv w : V\n⊢ Iff ((HasCompl.compl G).Adj v w) (Not (G.Adj v w))","decl":"@[simp] theorem compl_adj (G : Digraph V) (v w : V) : Gᶜ.Adj v w ↔ ¬G.Adj v w := Iff.rfl\n\n"}
{"name":"Digraph.sdiff_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nx y : Digraph V\nv w : V\n⊢ Iff ((SDiff.sdiff x y).Adj v w) (And (x.Adj v w) (Not (y.Adj v w)))","decl":"@[simp]\ntheorem sdiff_adj (x y : Digraph V) (v w : V) : (x \\ y).Adj v w ↔ x.Adj v w ∧ ¬y.Adj v w := Iff.rfl\n\n"}
{"name":"Digraph.sSup_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\na b : V\ns : Set (Digraph V)\n⊢ Iff ((SupSet.sSup s).Adj a b) (Exists fun G => And (Membership.mem s G) (G.Adj a b))","decl":"@[simp]\ntheorem sSup_adj {s : Set (Digraph V)} : (sSup s).Adj a b ↔ ∃ G ∈ s, Adj G a b := Iff.rfl\n\n"}
{"name":"Digraph.sInf_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\na b : V\ns : Set (Digraph V)\n⊢ Iff ((InfSet.sInf s).Adj a b) (∀ (G : Digraph V), Membership.mem s G → G.Adj a b)","decl":"@[simp]\ntheorem sInf_adj {s : Set (Digraph V)} : (sInf s).Adj a b ↔ ∀ G ∈ s, Adj G a b := Iff.rfl\n\n"}
{"name":"Digraph.iSup_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"ι : Sort u_1\nV : Type u_2\na b : V\nf : ι → Digraph V\n⊢ Iff ((iSup fun i => f i).Adj a b) (Exists fun i => (f i).Adj a b)","decl":"@[simp]\ntheorem iSup_adj {f : ι → Digraph V} : (⨆ i, f i).Adj a b ↔ ∃ i, (f i).Adj a b := by simp [iSup]\n\n"}
{"name":"Digraph.iInf_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"ι : Sort u_1\nV : Type u_2\na b : V\nf : ι → Digraph V\n⊢ Iff ((iInf fun i => f i).Adj a b) (∀ (i : ι), (f i).Adj a b)","decl":"@[simp]\ntheorem iInf_adj {f : ι → Digraph V} : (⨅ i, f i).Adj a b ↔ (∀ i, (f i).Adj a b) := by simp [iInf]\n\n"}
{"name":"Digraph.top_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nv w : V\n⊢ Top.top.Adj v w","decl":"@[simp] theorem top_adj (v w : V) : (⊤ : Digraph V).Adj v w := trivial\n\n"}
{"name":"Digraph.bot_adj","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\nv w : V\n⊢ Iff (Bot.bot.Adj v w) False","decl":"@[simp] theorem bot_adj (v w : V) : (⊥ : Digraph V).Adj v w ↔ False := Iff.rfl\n\n"}
{"name":"Digraph.completeDigraph_eq_top","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_3\n⊢ Eq (Digraph.completeDigraph V) Top.top","decl":"@[simp] theorem completeDigraph_eq_top (V : Type*) : Digraph.completeDigraph V = ⊤ := rfl\n\n"}
{"name":"Digraph.emptyDigraph_eq_bot","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_3\n⊢ Eq (Digraph.emptyDigraph V) Bot.bot","decl":"@[simp] theorem emptyDigraph_eq_bot (V : Type*) : Digraph.emptyDigraph V = ⊥ := rfl\n\n"}
{"name":"Digraph.instInhabited_default","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_3\n⊢ Eq Inhabited.default Bot.bot","decl":"@[simps] instance (V : Type*) : Inhabited (Digraph V) := ⟨⊥⟩\n\n"}
{"name":"Digraph.instNontrivialOfNonempty","module":"Mathlib.Combinatorics.Digraph.Basic","initialProofState":"V : Type u_2\ninst✝ : Nonempty V\n⊢ Nontrivial (Digraph V)","decl":"instance [Nonempty V] : Nontrivial (Digraph V) := by\n  use ⊥, ⊤\n  have v := Classical.arbitrary V\n  exact ne_of_apply_ne (·.Adj v v) (by simp)\n\n"}
