{"name":"CategoryTheory.MorphismProperty.IsCompatibleWithShift.condition","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nA : Type w\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift C A\nself : W.IsCompatibleWithShift A\na : A\n⊢ Eq (W.inverseImage (CategoryTheory.shiftFunctor C a)) W","decl":"/-- A morphism property `W` on a category `C` is compatible with the shift by a\nmonoid `A` when for all `a : A`, a morphism `f` belongs to `W`\nif and only if `f⟦a⟧'` does. -/\nclass IsCompatibleWithShift : Prop where\n  /-- the condition that for all `a : A`, the morphism property `W` is not changed when\n  we take its inverse image by the shift functor by `a` -/\n  condition : ∀ (a : A), W.inverseImage (shiftFunctor C a) = W\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsCompatibleWithShift.iff","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nA : Type w\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : W.IsCompatibleWithShift A\nX Y : C\nf : Quiver.Hom X Y\na : A\n⊢ Iff (W ((CategoryTheory.shiftFunctor C a).map f)) (W f)","decl":"lemma iff {X Y : C} (f : X ⟶ Y) (a : A) : W (f⟦a⟧') ↔ W f := by\n  conv_rhs => rw [← @IsCompatibleWithShift.condition _ _ W A _ _ _ a]\n  rfl\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsCompatibleWithShift.shiftFunctor_comp_inverts","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝³ : L.IsLocalization W\nA : Type w\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : W.IsCompatibleWithShift A\na : A\n⊢ W.IsInvertedBy ((CategoryTheory.shiftFunctor C a).comp L)","decl":"lemma shiftFunctor_comp_inverts (a : A) :\n    W.IsInvertedBy (shiftFunctor C a ⋙ L) := fun _ _ f hf =>\n  Localization.inverts L W _ (by simpa only [iff] using hf)\n\n"}
{"name":"CategoryTheory.MorphismProperty.shift","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nW : CategoryTheory.MorphismProperty C\nA : Type w\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift C A\ninst✝ : W.IsCompatibleWithShift A\nX Y : C\nf : Quiver.Hom X Y\nhf : W f\na : A\n⊢ W ((CategoryTheory.shiftFunctor C a).map f)","decl":"variable {A} in\nlemma shift {X Y : C} {f : X ⟶ Y} (hf : W f) (a : A) : W (f⟦a⟧') := by\n  simpa only [IsCompatibleWithShift.iff W f a] using hf\n\n"}
{"name":"CategoryTheory.Functor.commShiftOfLocalization.iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\na : A\nX : C\n⊢ Eq ((CategoryTheory.Functor.commShiftOfLocalization.iso L W F F' a).hom.app (L.obj X)) (CategoryTheory.CategoryStruct.comp (F'.map ((L.commShiftIso a).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F F').hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor E a).map ((CategoryTheory.Localization.Lifting.iso L W F F').inv.app X)))))","decl":"@[simp, reassoc]\nlemma iso_hom_app (a : A) (X : C) :\n    (commShiftOfLocalization.iso L W F F' a).hom.app (L.obj X) =\n      F'.map ((L.commShiftIso a).inv.app X) ≫\n      (Lifting.iso L W F F').hom.app (X⟦a⟧) ≫\n        (F.commShiftIso a).hom.app X ≫\n          (shiftFunctor E a).map ((Lifting.iso L W F F').inv.app X) := by\n  simp [commShiftOfLocalization.iso]\n\n"}
{"name":"CategoryTheory.Functor.commShiftOfLocalization.iso_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\na : A\nX : C\nZ : E\nh : Quiver.Hom ((CategoryTheory.shiftFunctor E a).obj (F'.obj (L.obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.commShiftOfLocalization.iso L W F F' a).hom.app (L.obj X)) h) (CategoryTheory.CategoryStruct.comp (F'.map ((L.commShiftIso a).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F F').hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor E a).map ((CategoryTheory.Localization.Lifting.iso L W F F').inv.app X)) h))))","decl":"@[simp, reassoc]\nlemma iso_hom_app (a : A) (X : C) :\n    (commShiftOfLocalization.iso L W F F' a).hom.app (L.obj X) =\n      F'.map ((L.commShiftIso a).inv.app X) ≫\n      (Lifting.iso L W F F').hom.app (X⟦a⟧) ≫\n        (F.commShiftIso a).hom.app X ≫\n          (shiftFunctor E a).map ((Lifting.iso L W F F').inv.app X) := by\n  simp [commShiftOfLocalization.iso]\n\n"}
{"name":"CategoryTheory.Functor.commShiftOfLocalization.iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\na : A\nX : C\n⊢ Eq ((CategoryTheory.Functor.commShiftOfLocalization.iso L W F F' a).inv.app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor E a).map ((CategoryTheory.Localization.Lifting.iso L W F F').hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F F').inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (F'.map ((L.commShiftIso a).hom.app X)))))","decl":"@[simp, reassoc]\nlemma iso_inv_app (a : A) (X : C) :\n    (commShiftOfLocalization.iso L W F F' a).inv.app (L.obj X) =\n        (shiftFunctor E a).map ((Lifting.iso L W F F').hom.app X) ≫\n        (F.commShiftIso a).inv.app X ≫\n      (Lifting.iso L W F F').inv.app (X⟦a⟧) ≫\n      F'.map ((L.commShiftIso a).hom.app X) := by\n  simp [commShiftOfLocalization.iso]\n\n"}
{"name":"CategoryTheory.Functor.commShiftOfLocalization.iso_inv_app_assoc","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\na : A\nX : C\nZ : E\nh : Quiver.Hom (F'.obj ((CategoryTheory.shiftFunctor D a).obj (L.obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Functor.commShiftOfLocalization.iso L W F F' a).inv.app (L.obj X)) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor E a).map ((CategoryTheory.Localization.Lifting.iso L W F F').hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F F').inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp (F'.map ((L.commShiftIso a).hom.app X)) h))))","decl":"@[simp, reassoc]\nlemma iso_inv_app (a : A) (X : C) :\n    (commShiftOfLocalization.iso L W F F' a).inv.app (L.obj X) =\n        (shiftFunctor E a).map ((Lifting.iso L W F F').hom.app X) ≫\n        (F.commShiftIso a).inv.app X ≫\n      (Lifting.iso L W F F').inv.app (X⟦a⟧) ≫\n      F'.map ((L.commShiftIso a).hom.app X) := by\n  simp [commShiftOfLocalization.iso]\n\n"}
{"name":"CategoryTheory.Functor.commShiftOfLocalization_iso_hom_app","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\na : A\nX : C\n⊢ Eq ((F'.commShiftIso a).hom.app (L.obj X)) (CategoryTheory.CategoryStruct.comp (F'.map ((L.commShiftIso a).inv.app X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F F').hom.app ((CategoryTheory.shiftFunctor C a).obj X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).hom.app X) ((CategoryTheory.shiftFunctor E a).map ((CategoryTheory.Localization.Lifting.iso L W F F').inv.app X)))))","decl":"lemma commShiftOfLocalization_iso_hom_app (a : A) (X : C) :\n    letI := Functor.commShiftOfLocalization L W A F F'\n    (F'.commShiftIso a).hom.app (L.obj X) =\n      F'.map ((L.commShiftIso a).inv.app X) ≫ (Lifting.iso L W F F').hom.app (X⟦a⟧) ≫\n        (F.commShiftIso a).hom.app X ≫\n          (shiftFunctor E a).map ((Lifting.iso L W F F').inv.app X) := by\n  apply commShiftOfLocalization.iso_hom_app\n\n"}
{"name":"CategoryTheory.Functor.commShiftOfLocalization_iso_inv_app","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\na : A\nX : C\n⊢ Eq ((F'.commShiftIso a).inv.app (L.obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor E a).map ((CategoryTheory.Localization.Lifting.iso L W F F').hom.app X)) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso a).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Localization.Lifting.iso L W F F').inv.app ((CategoryTheory.shiftFunctor C a).obj X)) (F'.map ((L.commShiftIso a).hom.app X)))))","decl":"lemma commShiftOfLocalization_iso_inv_app (a : A) (X : C) :\n    letI := Functor.commShiftOfLocalization L W A F F'\n    (F'.commShiftIso a).inv.app (L.obj X) =\n      (shiftFunctor E a).map ((Lifting.iso L W F F').hom.app X) ≫\n      (F.commShiftIso a).inv.app X ≫ (Lifting.iso L W F F').inv.app (X⟦a⟧) ≫\n     F'.map ((L.commShiftIso a).hom.app X) := by\n  apply commShiftOfLocalization.iso_inv_app\n\n"}
{"name":"CategoryTheory.NatTrans.commShift_iso_hom_of_localization","module":"Mathlib.CategoryTheory.Shift.Localization","initialProofState":"C : Type u₁\nD : Type u₂\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Category.{v₂, u₂} D\nE : Type u₃\ninst✝⁸ : CategoryTheory.Category.{v₃, u₃} E\nL : CategoryTheory.Functor C D\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\nA : Type w\ninst✝⁶ : AddMonoid A\ninst✝⁵ : CategoryTheory.HasShift C A\nF : CategoryTheory.Functor C E\nF' : CategoryTheory.Functor D E\ninst✝⁴ : CategoryTheory.Localization.Lifting L W F F'\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : CategoryTheory.HasShift E A\ninst✝¹ : L.CommShift A\ninst✝ : F.CommShift A\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.Localization.Lifting.iso L W F F').hom A","decl":"instance NatTrans.commShift_iso_hom_of_localization :\n    letI := Functor.commShiftOfLocalization L W A F F'\n    NatTrans.CommShift (Lifting.iso L W F F').hom A := by\n  letI := Functor.commShiftOfLocalization L W A F F'\n  constructor\n  intro a\n  ext X\n  simp only [comp_app, whiskerRight_app, whiskerLeft_app,\n    Functor.commShiftIso_comp_hom_app,\n    Functor.commShiftOfLocalization_iso_hom_app,\n    Category.assoc, ← Functor.map_comp, ← Functor.map_comp_assoc,\n    Iso.hom_inv_id_app, Functor.map_id, Iso.inv_hom_id_app,\n    Category.comp_id, Category.id_comp, Functor.comp_obj]\n\n"}
