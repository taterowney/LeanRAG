{"name":"Seminorm.mk.inj","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_12\nE : Type u_13\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\ntoAddGroupSeminorm✝ : AddGroupSeminorm E\nsmul'✝ : ∀ (a : 𝕜) (x : E), Eq (toAddGroupSeminorm✝.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm✝.toFun x))\ntoAddGroupSeminorm : AddGroupSeminorm E\nsmul' : ∀ (a : 𝕜) (x : E), Eq (toAddGroupSeminorm.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm.toFun x))\nx✝ : Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, smul' := smul'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, smul' := smul' }\n⊢ Eq toAddGroupSeminorm✝ toAddGroupSeminorm","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (𝕜 : Type*) (E : Type*) [SeminormedRing 𝕜] [AddGroup E] [SMul 𝕜 E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : ∀ (a : 𝕜) (x : E), toFun (a • x) = ‖a‖ * toFun x\n\n"}
{"name":"Seminorm.mk.injEq","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_12\nE : Type u_13\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\ntoAddGroupSeminorm✝ : AddGroupSeminorm E\nsmul'✝ : ∀ (a : 𝕜) (x : E), Eq (toAddGroupSeminorm✝.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm✝.toFun x))\ntoAddGroupSeminorm : AddGroupSeminorm E\nsmul' : ∀ (a : 𝕜) (x : E), Eq (toAddGroupSeminorm.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm.toFun x))\n⊢ Eq (Eq { toAddGroupSeminorm := toAddGroupSeminorm✝, smul' := smul'✝ } { toAddGroupSeminorm := toAddGroupSeminorm, smul' := smul' }) (Eq toAddGroupSeminorm✝ toAddGroupSeminorm)","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (𝕜 : Type*) (E : Type*) [SeminormedRing 𝕜] [AddGroup E] [SMul 𝕜 E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : ∀ (a : 𝕜) (x : E), toFun (a • x) = ‖a‖ * toFun x\n\n"}
{"name":"Seminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_12\nE : Type u_13\ninst✝⁴ : SeminormedRing 𝕜\ninst✝³ : AddGroup E\ninst✝² : SMul 𝕜 E\ninst✝¹ : SizeOf 𝕜\ninst✝ : SizeOf E\ntoAddGroupSeminorm : AddGroupSeminorm E\nsmul' : ∀ (a : 𝕜) (x : E), Eq (toAddGroupSeminorm.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm.toFun x))\n⊢ Eq (SizeOf.sizeOf { toAddGroupSeminorm := toAddGroupSeminorm, smul' := smul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupSeminorm))","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (𝕜 : Type*) (E : Type*) [SeminormedRing 𝕜] [AddGroup E] [SMul 𝕜 E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : ∀ (a : 𝕜) (x : E), toFun (a • x) = ‖a‖ * toFun x\n\n"}
{"name":"Seminorm.smul'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_12\nE : Type u_13\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\nself : Seminorm 𝕜 E\na : 𝕜\nx : E\n⊢ Eq (self.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (self.toFun x))","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (𝕜 : Type*) (E : Type*) [SeminormedRing 𝕜] [AddGroup E] [SMul 𝕜 E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : ∀ (a : 𝕜) (x : E), toFun (a • x) = ‖a‖ * toFun x\n\n"}
{"name":"SeminormClass.map_smul_eq_mul","module":"Mathlib.Analysis.Seminorm","initialProofState":"F : Type u_12\n𝕜 : outParam (Type u_13)\nE : outParam (Type u_14)\ninst✝³ : SeminormedRing 𝕜\ninst✝² : AddGroup E\ninst✝¹ : SMul 𝕜 E\ninst✝ : FunLike F E Real\nself : SeminormClass F 𝕜 E\nf : F\na : 𝕜\nx : E\n⊢ Eq (f (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (f x))","decl":"/-- `SeminormClass F 𝕜 E` states that `F` is a type of seminorms on the `𝕜`-module `E`.\n\nYou should extend this class when you extend `Seminorm`. -/\nclass SeminormClass (F : Type*) (𝕜 E : outParam Type*) [SeminormedRing 𝕜] [AddGroup E]\n  [SMul 𝕜 E] [FunLike F E ℝ] extends AddGroupSeminormClass F E ℝ : Prop where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  map_smul_eq_mul (f : F) (a : 𝕜) (x : E) : f (a • x) = ‖a‖ * f x\n\n"}
{"name":"SeminormClass.toAddGroupSeminormClass","module":"Mathlib.Analysis.Seminorm","initialProofState":"F : Type u_12\n𝕜 : outParam (Type u_13)\nE : outParam (Type u_14)\ninst✝³ : SeminormedRing 𝕜\ninst✝² : AddGroup E\ninst✝¹ : SMul 𝕜 E\ninst✝ : FunLike F E Real\nself : SeminormClass F 𝕜 E\n⊢ AddGroupSeminormClass F E Real","decl":"/-- `SeminormClass F 𝕜 E` states that `F` is a type of seminorms on the `𝕜`-module `E`.\n\nYou should extend this class when you extend `Seminorm`. -/\nclass SeminormClass (F : Type*) (𝕜 E : outParam Type*) [SeminormedRing 𝕜] [AddGroup E]\n  [SMul 𝕜 E] [FunLike F E ℝ] extends AddGroupSeminormClass F E ℝ : Prop where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  map_smul_eq_mul (f : F) (a : 𝕜) (x : E) : f (a • x) = ‖a‖ * f x\n\n"}
{"name":"Seminorm.instSeminormClass","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\n⊢ SeminormClass (Seminorm 𝕜 E) 𝕜 E","decl":"instance instSeminormClass : SeminormClass (Seminorm 𝕜 E) 𝕜 E where\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_neg_eq_map f := f.neg'\n  map_smul_eq_mul f := f.smul'\n\n"}
{"name":"Seminorm.ext","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\nh : ∀ (x : E), Eq (p x) (q x)\n⊢ Eq p q","decl":"@[ext]\ntheorem ext {p q : Seminorm 𝕜 E} (h : ∀ x, (p : E → ℝ) x = q x) : p = q :=\n  DFunLike.ext p q h\n\n"}
{"name":"Seminorm.ext_iff","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Iff (Eq p q) (∀ (x : E), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext {p q : Seminorm 𝕜 E} (h : ∀ x, (p : E → ℝ) x = q x) : p = q :=\n  DFunLike.ext p q h\n\n"}
{"name":"Seminorm.coe_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\n⊢ Eq (⇑0) 0","decl":"@[simp]\ntheorem coe_zero : ⇑(0 : Seminorm 𝕜 E) = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.zero_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\nx : E\n⊢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : E) : (0 : Seminorm 𝕜 E) x = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.instIsScalarTowerOfReal","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nR' : Type u_2\n𝕜 : Type u_3\nE : Type u_7\ninst✝¹⁰ : SeminormedRing 𝕜\ninst✝⁹ : AddGroup E\ninst✝⁸ : SMul 𝕜 E\ninst✝⁷ : SMul R Real\ninst✝⁶ : SMul R NNReal\ninst✝⁵ : IsScalarTower R NNReal Real\ninst✝⁴ : SMul R' Real\ninst✝³ : SMul R' NNReal\ninst✝² : IsScalarTower R' NNReal Real\ninst✝¹ : SMul R R'\ninst✝ : IsScalarTower R R' Real\n⊢ IsScalarTower R R' (Seminorm 𝕜 E)","decl":"instance [SMul R ℝ] [SMul R ℝ≥0] [IsScalarTower R ℝ≥0 ℝ] [SMul R' ℝ] [SMul R' ℝ≥0]\n    [IsScalarTower R' ℝ≥0 ℝ] [SMul R R'] [IsScalarTower R R' ℝ] :\n    IsScalarTower R R' (Seminorm 𝕜 E) where\n  smul_assoc r a p := ext fun x => smul_assoc r a (p x)\n\n"}
{"name":"Seminorm.coe_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\n𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : SeminormedRing 𝕜\ninst✝⁴ : AddGroup E\ninst✝³ : SMul 𝕜 E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : Seminorm 𝕜 E\n⊢ Eq (⇑(HSMul.hSMul r p)) (HSMul.hSMul r ⇑p)","decl":"theorem coe_smul [SMul R ℝ] [SMul R ℝ≥0] [IsScalarTower R ℝ≥0 ℝ] (r : R) (p : Seminorm 𝕜 E) :\n    ⇑(r • p) = r • ⇑p :=\n  rfl\n\n"}
{"name":"Seminorm.smul_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\n𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : SeminormedRing 𝕜\ninst✝⁴ : AddGroup E\ninst✝³ : SMul 𝕜 E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np : Seminorm 𝕜 E\nx : E\n⊢ Eq ((HSMul.hSMul r p) x) (HSMul.hSMul r (p x))","decl":"@[simp]\ntheorem smul_apply [SMul R ℝ] [SMul R ℝ≥0] [IsScalarTower R ℝ≥0 ℝ] (r : R) (p : Seminorm 𝕜 E)\n    (x : E) : (r • p) x = r • p x :=\n  rfl\n\n"}
{"name":"Seminorm.coe_add","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Eq (⇑(HAdd.hAdd p q)) (HAdd.hAdd ⇑p ⇑q)","decl":"theorem coe_add (p q : Seminorm 𝕜 E) : ⇑(p + q) = p + q :=\n  rfl\n\n"}
{"name":"Seminorm.add_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\nx : E\n⊢ Eq ((HAdd.hAdd p q) x) (HAdd.hAdd (p x) (q x))","decl":"@[simp]\ntheorem add_apply (p q : Seminorm 𝕜 E) (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n"}
{"name":"Seminorm.coeFnAddMonoidHom_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\na✝ : Seminorm 𝕜 E\na : E\n⊢ Eq ((Seminorm.coeFnAddMonoidHom 𝕜 E) a✝ a) (a✝ a)","decl":"/-- `coeFn` as an `AddMonoidHom`. Helper definition for showing that `Seminorm 𝕜 E` is a module. -/\n@[simps]\ndef coeFnAddMonoidHom : AddMonoidHom (Seminorm 𝕜 E) (E → ℝ) where\n  toFun := (↑)\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"Seminorm.coeFnAddMonoidHom_injective","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\n⊢ Function.Injective ⇑(Seminorm.coeFnAddMonoidHom 𝕜 E)","decl":"theorem coeFnAddMonoidHom_injective : Function.Injective (coeFnAddMonoidHom 𝕜 E) :=\n  show @Function.Injective (Seminorm 𝕜 E) (E → ℝ) (↑) from DFunLike.coe_injective\n\n"}
{"name":"Seminorm.coe_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Eq (⇑(Max.max p q)) (Max.max ⇑p ⇑q)","decl":"@[simp]\ntheorem coe_sup (p q : Seminorm 𝕜 E) : ⇑(p ⊔ q) = (p : E → ℝ) ⊔ (q : E → ℝ) :=\n  rfl\n\n"}
{"name":"Seminorm.sup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\nx : E\n⊢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"theorem sup_apply (p q : Seminorm 𝕜 E) (x : E) : (p ⊔ q) x = p x ⊔ q x :=\n  rfl\n\n"}
{"name":"Seminorm.smul_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\n𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : SeminormedRing 𝕜\ninst✝⁴ : AddGroup E\ninst✝³ : SMul 𝕜 E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np q : Seminorm 𝕜 E\n⊢ Eq (HSMul.hSMul r (Max.max p q)) (Max.max (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"theorem smul_sup [SMul R ℝ] [SMul R ℝ≥0] [IsScalarTower R ℝ≥0 ℝ] (r : R) (p q : Seminorm 𝕜 E) :\n    r • (p ⊔ q) = r • p ⊔ r • q :=\n  have real.smul_max : ∀ x y : ℝ, r • max x y = max (r • x) (r • y) := fun x y => by\n    simpa only [← smul_eq_mul, ← NNReal.smul_def, smul_one_smul ℝ≥0 r (_ : ℝ)] using\n      mul_max_of_nonneg x y (r • (1 : ℝ≥0) : ℝ≥0).coe_nonneg\n  ext fun _ => real.smul_max _ _\n\n"}
{"name":"Seminorm.coe_le_coe","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Iff (LE.le ⇑p ⇑q) (LE.le p q)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe {p q : Seminorm 𝕜 E} : (p : E → ℝ) ≤ q ↔ p ≤ q :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.coe_lt_coe","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Iff (LT.lt ⇑p ⇑q) (LT.lt p q)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe {p q : Seminorm 𝕜 E} : (p : E → ℝ) < q ↔ p < q :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.le_def","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Iff (LE.le p q) (∀ (x : E), LE.le (p x) (q x))","decl":"theorem le_def {p q : Seminorm 𝕜 E} : p ≤ q ↔ ∀ x, p x ≤ q x :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.lt_def","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\n⊢ Iff (LT.lt p q) (And (LE.le p q) (Exists fun x => LT.lt (p x) (q x)))","decl":"theorem lt_def {p q : Seminorm 𝕜 E} : p < q ↔ p ≤ q ∧ ∃ x, p x < q x :=\n  @Pi.lt_def _ _ _ p q\n\n"}
{"name":"Seminorm.coe_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\n⊢ Eq (⇑(p.comp f)) (Function.comp ⇑p ⇑f)","decl":"theorem coe_comp (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) : ⇑(p.comp f) = p ∘ f :=\n  rfl\n\n"}
{"name":"Seminorm.comp_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nx : E\n⊢ Eq ((p.comp f) x) (p (f x))","decl":"@[simp]\ntheorem comp_apply (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) (x : E) : (p.comp f) x = p (f x) :=\n  rfl\n\n"}
{"name":"Seminorm.comp_id","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\n⊢ Eq (p.comp LinearMap.id) p","decl":"@[simp]\ntheorem comp_id (p : Seminorm 𝕜 E) : p.comp LinearMap.id = p :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np : Seminorm 𝕜₂ E₂\n⊢ Eq (p.comp 0) 0","decl":"@[simp]\ntheorem comp_zero (p : Seminorm 𝕜₂ E₂) : p.comp (0 : E →ₛₗ[σ₁₂] E₂) = 0 :=\n  ext fun _ => map_zero p\n\n"}
{"name":"Seminorm.zero_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\n⊢ Eq (Seminorm.comp 0 f) 0","decl":"@[simp]\ntheorem zero_comp (f : E →ₛₗ[σ₁₂] E₂) : (0 : Seminorm 𝕜₂ E₂).comp f = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\n𝕜₃ : Type u_5\nE : Type u_7\nE₂ : Type u_8\nE₃ : Type u_9\ninst✝¹² : SeminormedRing 𝕜\ninst✝¹¹ : SeminormedRing 𝕜₂\ninst✝¹⁰ : SeminormedRing 𝕜₃\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁹ : RingHomIsometric σ₁₂\nσ₂₃ : RingHom 𝕜₂ 𝕜₃\ninst✝⁸ : RingHomIsometric σ₂₃\nσ₁₃ : RingHom 𝕜 𝕜₃\ninst✝⁷ : RingHomIsometric σ₁₃\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : AddCommGroup E₂\ninst✝⁴ : AddCommGroup E₃\ninst✝³ : Module 𝕜 E\ninst✝² : Module 𝕜₂ E₂\ninst✝¹ : Module 𝕜₃ E₃\ninst✝ : RingHomCompTriple σ₁₂ σ₂₃ σ₁₃\np : Seminorm 𝕜₃ E₃\ng : LinearMap σ₂₃ E₂ E₃\nf : LinearMap σ₁₂ E E₂\n⊢ Eq (p.comp (g.comp f)) ((p.comp g).comp f)","decl":"theorem comp_comp [RingHomCompTriple σ₁₂ σ₂₃ σ₁₃] (p : Seminorm 𝕜₃ E₃) (g : E₂ →ₛₗ[σ₂₃] E₃)\n    (f : E →ₛₗ[σ₁₂] E₂) : p.comp (g.comp f) = (p.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.add_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np q : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\n⊢ Eq ((HAdd.hAdd p q).comp f) (HAdd.hAdd (p.comp f) (q.comp f))","decl":"theorem add_comp (p q : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) :\n    (p + q).comp f = p.comp f + q.comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_add_le","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np : Seminorm 𝕜₂ E₂\nf g : LinearMap σ₁₂ E E₂\n⊢ LE.le (p.comp (HAdd.hAdd f g)) (HAdd.hAdd (p.comp f) (p.comp g))","decl":"theorem comp_add_le (p : Seminorm 𝕜₂ E₂) (f g : E →ₛₗ[σ₁₂] E₂) :\n    p.comp (f + g) ≤ p.comp f + p.comp g := fun _ => map_add_le_add p _ _\n\n"}
{"name":"Seminorm.smul_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\n𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁹ : SeminormedRing 𝕜\ninst✝⁸ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁷ : RingHomIsometric σ₁₂\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : AddCommGroup E₂\ninst✝⁴ : Module 𝕜 E\ninst✝³ : Module 𝕜₂ E₂\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nc : R\n⊢ Eq ((HSMul.hSMul c p).comp f) (HSMul.hSMul c (p.comp f))","decl":"theorem smul_comp (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) (c : R) :\n    (c • p).comp f = c • p.comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_mono","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np q : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nhp : LE.le p q\n⊢ LE.le (p.comp f) (q.comp f)","decl":"theorem comp_mono {p q : Seminorm 𝕜₂ E₂} (f : E →ₛₗ[σ₁₂] E₂) (hp : p ≤ q) : p.comp f ≤ q.comp f :=\n  fun _ => hp _\n\n"}
{"name":"Seminorm.pullback_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\np : Seminorm 𝕜₂ E₂\n⊢ Eq ((Seminorm.pullback f) p) (p.comp f)","decl":"/-- The composition as an `AddMonoidHom`. -/\n@[simps]\ndef pullback (f : E →ₛₗ[σ₁₂] E₂) : Seminorm 𝕜₂ E₂ →+ Seminorm 𝕜 E where\n  toFun := fun p => p.comp f\n  map_zero' := zero_comp f\n  map_add' := fun p q => add_comp p q f\n\n"}
{"name":"Seminorm.coe_bot","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq (⇑Bot.bot) 0","decl":"@[simp]\ntheorem coe_bot : ⇑(⊥ : Seminorm 𝕜 E) = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.bot_eq_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq Bot.bot 0","decl":"theorem bot_eq_zero : (⊥ : Seminorm 𝕜 E) = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.smul_le_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np q : Seminorm 𝕜 E\na b : NNReal\nhpq : LE.le p q\nhab : LE.le a b\n⊢ LE.le (HSMul.hSMul a p) (HSMul.hSMul b q)","decl":"theorem smul_le_smul {p q : Seminorm 𝕜 E} {a b : ℝ≥0} (hpq : p ≤ q) (hab : a ≤ b) :\n    a • p ≤ b • q := by\n  simp_rw [le_def]\n  intro x\n  exact mul_le_mul hab (hpq x) (apply_nonneg p x) (NNReal.coe_nonneg b)\n\n"}
{"name":"Seminorm.finset_sup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\n⊢ Eq ((s.sup p) x) ↑(s.sup fun i => ⟨(p i) x, ⋯⟩)","decl":"theorem finset_sup_apply (p : ι → Seminorm 𝕜 E) (s : Finset ι) (x : E) :\n    s.sup p x = ↑(s.sup fun i => ⟨p i x, apply_nonneg (p i) x⟩ : ℝ≥0) := by\n  induction' s using Finset.cons_induction_on with a s ha ih\n  · rw [Finset.sup_empty, Finset.sup_empty, coe_bot, _root_.bot_eq_zero, Pi.zero_apply]\n    norm_cast\n  · rw [Finset.sup_cons, Finset.sup_cons, coe_sup, Pi.sup_apply, NNReal.coe_max, NNReal.coe_mk, ih]\n\n"}
{"name":"Seminorm.exists_apply_eq_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nhs : s.Nonempty\nx : E\n⊢ Exists fun i => And (Membership.mem s i) (Eq ((s.sup p) x) ((p i) x))","decl":"theorem exists_apply_eq_finset_sup (p : ι → Seminorm 𝕜 E) {s : Finset ι} (hs : s.Nonempty) (x : E) :\n    ∃ i ∈ s, s.sup p x = p i x := by\n  rcases Finset.exists_mem_eq_sup s hs (fun i ↦ (⟨p i x, apply_nonneg _ _⟩ : ℝ≥0)) with ⟨i, hi, hix⟩\n  rw [finset_sup_apply]\n  exact ⟨i, hi, congr_arg _ hix⟩\n\n"}
{"name":"Seminorm.zero_or_exists_apply_eq_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\n⊢ Or (Eq ((s.sup p) x) 0) (Exists fun i => And (Membership.mem s i) (Eq ((s.sup p) x) ((p i) x)))","decl":"theorem zero_or_exists_apply_eq_finset_sup (p : ι → Seminorm 𝕜 E) (s : Finset ι) (x : E) :\n    s.sup p x = 0 ∨ ∃ i ∈ s, s.sup p x = p i x := by\n  rcases Finset.eq_empty_or_nonempty s with (rfl|hs)\n  · left; rfl\n  · right; exact exists_apply_eq_finset_sup p hs x\n\n"}
{"name":"Seminorm.finset_sup_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nC : NNReal\n⊢ Eq (s.sup (HSMul.hSMul C p)) (HSMul.hSMul C (s.sup p))","decl":"theorem finset_sup_smul (p : ι → Seminorm 𝕜 E) (s : Finset ι) (C : ℝ≥0) :\n    s.sup (C • p) = C • s.sup p := by\n  ext x\n  rw [smul_apply, finset_sup_apply, finset_sup_apply]\n  symm\n  exact congr_arg ((↑) : ℝ≥0 → ℝ) (NNReal.mul_finset_sup C s (fun i ↦ ⟨p i x, apply_nonneg _ _⟩))\n\n"}
{"name":"Seminorm.finset_sup_le_sum","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\n⊢ LE.le (s.sup p) (s.sum fun i => p i)","decl":"theorem finset_sup_le_sum (p : ι → Seminorm 𝕜 E) (s : Finset ι) : s.sup p ≤ ∑ i ∈ s, p i := by\n  classical\n  refine Finset.sup_le_iff.mpr ?_\n  intro i hi\n  rw [Finset.sum_eq_sum_diff_singleton_add hi, le_add_iff_nonneg_left]\n  exact bot_le\n\n"}
{"name":"Seminorm.finset_sup_apply_le","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\na : Real\nha : LE.le 0 a\nh : ∀ (i : ι), Membership.mem s i → LE.le ((p i) x) a\n⊢ LE.le ((s.sup p) x) a","decl":"theorem finset_sup_apply_le {p : ι → Seminorm 𝕜 E} {s : Finset ι} {x : E} {a : ℝ} (ha : 0 ≤ a)\n    (h : ∀ i, i ∈ s → p i x ≤ a) : s.sup p x ≤ a := by\n  lift a to ℝ≥0 using ha\n  rw [finset_sup_apply, NNReal.coe_le_coe]\n  exact Finset.sup_le h\n\n"}
{"name":"Seminorm.le_finset_sup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\ni : ι\nhi : Membership.mem s i\n⊢ LE.le ((p i) x) ((s.sup p) x)","decl":"theorem le_finset_sup_apply {p : ι → Seminorm 𝕜 E} {s : Finset ι} {x : E} {i : ι}\n    (hi : i ∈ s) : p i x ≤ s.sup p x :=\n  (Finset.le_sup hi : p i ≤ s.sup p) x\n\n"}
{"name":"Seminorm.finset_sup_apply_lt","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\na : Real\nha : LT.lt 0 a\nh : ∀ (i : ι), Membership.mem s i → LT.lt ((p i) x) a\n⊢ LT.lt ((s.sup p) x) a","decl":"theorem finset_sup_apply_lt {p : ι → Seminorm 𝕜 E} {s : Finset ι} {x : E} {a : ℝ} (ha : 0 < a)\n    (h : ∀ i, i ∈ s → p i x < a) : s.sup p x < a := by\n  lift a to ℝ≥0 using ha.le\n  rw [finset_sup_apply, NNReal.coe_lt_coe, Finset.sup_lt_iff]\n  · exact h\n  · exact NNReal.coe_pos.mpr ha\n\n"}
{"name":"Seminorm.norm_sub_map_le_sub","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nx y : E\n⊢ LE.le (Norm.norm (HSub.hSub (p x) (p y))) (p (HSub.hSub x y))","decl":"theorem norm_sub_map_le_sub (p : Seminorm 𝕜 E) (x y : E) : ‖p x - p y‖ ≤ p (x - y) :=\n  abs_sub_map_le_sub p x y\n\n"}
{"name":"Seminorm.comp_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedCommRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nc : 𝕜₂\n⊢ Eq (p.comp (HSMul.hSMul c f)) (HSMul.hSMul (NNNorm.nnnorm c) (p.comp f))","decl":"theorem comp_smul (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) (c : 𝕜₂) :\n    p.comp (c • f) = ‖c‖₊ • p.comp f :=\n  ext fun _ => by\n    rw [comp_apply, smul_apply, LinearMap.smul_apply, map_smul_eq_mul, NNReal.smul_def, coe_nnnorm,\n      smul_eq_mul, comp_apply]\n\n"}
{"name":"Seminorm.comp_smul_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : SeminormedCommRing 𝕜₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝⁴ : RingHomIsometric σ₁₂\ninst✝³ : AddCommGroup E\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜 E\ninst✝ : Module 𝕜₂ E₂\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nc : 𝕜₂\nx : E\n⊢ Eq ((p.comp (HSMul.hSMul c f)) x) (HMul.hMul (Norm.norm c) (p (f x)))","decl":"theorem comp_smul_apply (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) (c : 𝕜₂) (x : E) :\n    p.comp (c • f) x = ‖c‖ * p (f x) :=\n  map_smul_eq_mul p _ _\n\n"}
{"name":"Seminorm.bddBelow_range_add","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np q : Seminorm 𝕜 E\nx : E\n⊢ BddBelow (Set.range fun u => HAdd.hAdd (p u) (q (HSub.hSub x u)))","decl":"/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem bddBelow_range_add : BddBelow (range fun u => p u + q (x - u)) :=\n  ⟨0, by\n    rintro _ ⟨x, rfl⟩\n    dsimp; positivity⟩\n\n"}
{"name":"Seminorm.inf_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np q : Seminorm 𝕜 E\nx : E\n⊢ Eq ((Min.min p q) x) (iInf fun u => HAdd.hAdd (p u) (q (HSub.hSub x u)))","decl":"@[simp]\ntheorem inf_apply (p q : Seminorm 𝕜 E) (x : E) : (p ⊓ q) x = ⨅ u : E, p u + q (x - u) :=\n  rfl\n\n"}
{"name":"Seminorm.smul_inf","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\n𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : SMul R Real\ninst✝¹ : SMul R NNReal\ninst✝ : IsScalarTower R NNReal Real\nr : R\np q : Seminorm 𝕜 E\n⊢ Eq (HSMul.hSMul r (Min.min p q)) (Min.min (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"theorem smul_inf [SMul R ℝ] [SMul R ℝ≥0] [IsScalarTower R ℝ≥0 ℝ] (r : R) (p q : Seminorm 𝕜 E) :\n    r • (p ⊓ q) = r • p ⊓ r • q := by\n  ext\n  simp_rw [smul_apply, inf_apply, smul_apply, ← smul_one_smul ℝ≥0 r (_ : ℝ), NNReal.smul_def,\n    smul_eq_mul, Real.mul_iInf_of_nonneg (NNReal.coe_nonneg _), mul_add]\n\n"}
{"name":"Seminorm.coe_sSup_eq'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set (Seminorm 𝕜 E)\nhs : BddAbove (Set.image DFunLike.coe s)\n⊢ Eq (⇑(SupSet.sSup s)) (iSup fun p => ⇑↑p)","decl":"protected theorem coe_sSup_eq' {s : Set <| Seminorm 𝕜 E}\n    (hs : BddAbove ((↑) '' s : Set (E → ℝ))) : ↑(sSup s) = ⨆ p : s, ((p : Seminorm 𝕜 E) : E → ℝ) :=\n  congr_arg _ (dif_pos hs)\n\n"}
{"name":"Seminorm.bddAbove_iff","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set (Seminorm 𝕜 E)\n⊢ Iff (BddAbove s) (BddAbove (Set.image DFunLike.coe s))","decl":"protected theorem bddAbove_iff {s : Set <| Seminorm 𝕜 E} :\n    BddAbove s ↔ BddAbove ((↑) '' s : Set (E → ℝ)) :=\n  ⟨fun ⟨q, hq⟩ => ⟨q, forall_mem_image.2 fun _ hp => hq hp⟩, fun H =>\n    ⟨sSup s, fun p hp x => by\n      dsimp\n      rw [Seminorm.coe_sSup_eq' H, iSup_apply]\n      rcases H with ⟨q, hq⟩\n      exact\n        le_ciSup ⟨q x, forall_mem_range.mpr fun i : s => hq (mem_image_of_mem _ i.2) x⟩ ⟨p, hp⟩⟩⟩\n\n"}
{"name":"Seminorm.bddAbove_range_iff","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nι : Sort u_12\np : ι → Seminorm 𝕜 E\n⊢ Iff (BddAbove (Set.range p)) (∀ (x : E), BddAbove (Set.range fun i => (p i) x))","decl":"protected theorem bddAbove_range_iff {ι : Sort*} {p : ι → Seminorm 𝕜 E} :\n    BddAbove (range p) ↔ ∀ x, BddAbove (range fun i ↦ p i x) := by\n  rw [Seminorm.bddAbove_iff, ← range_comp, bddAbove_range_pi]; rfl\n\n"}
{"name":"Seminorm.coe_sSup_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set (Seminorm 𝕜 E)\nhs : BddAbove s\n⊢ Eq (⇑(SupSet.sSup s)) (iSup fun p => ⇑↑p)","decl":"protected theorem coe_sSup_eq {s : Set <| Seminorm 𝕜 E} (hs : BddAbove s) :\n    ↑(sSup s) = ⨆ p : s, ((p : Seminorm 𝕜 E) : E → ℝ) :=\n  Seminorm.coe_sSup_eq' (Seminorm.bddAbove_iff.mp hs)\n\n"}
{"name":"Seminorm.coe_iSup_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nι : Sort u_12\np : ι → Seminorm 𝕜 E\nhp : BddAbove (Set.range p)\n⊢ Eq (⇑(iSup fun i => p i)) (iSup fun i => ⇑(p i))","decl":"protected theorem coe_iSup_eq {ι : Sort*} {p : ι → Seminorm 𝕜 E} (hp : BddAbove (range p)) :\n    ↑(⨆ i, p i) = ⨆ i, ((p i : Seminorm 𝕜 E) : E → ℝ) := by\n  rw [← sSup_range, Seminorm.coe_sSup_eq hp]\n  exact iSup_range' (fun p : Seminorm 𝕜 E => (p : E → ℝ)) p\n\n"}
{"name":"Seminorm.sSup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\ns : Set (Seminorm 𝕜 E)\nhp : BddAbove s\nx : E\n⊢ Eq ((SupSet.sSup s) x) (iSup fun p => ↑p x)","decl":"protected theorem sSup_apply {s : Set (Seminorm 𝕜 E)} (hp : BddAbove s) {x : E} :\n    (sSup s) x = ⨆ p : s, (p : E → ℝ) x := by\n  rw [Seminorm.coe_sSup_eq hp, iSup_apply]\n\n"}
{"name":"Seminorm.iSup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nι : Sort u_12\np : ι → Seminorm 𝕜 E\nhp : BddAbove (Set.range p)\nx : E\n⊢ Eq ((iSup fun i => p i) x) (iSup fun i => (p i) x)","decl":"protected theorem iSup_apply {ι : Sort*} {p : ι → Seminorm 𝕜 E}\n    (hp : BddAbove (range p)) {x : E} : (⨆ i, p i) x = ⨆ i, p i x := by\n  rw [Seminorm.coe_iSup_eq hp, iSup_apply]\n\n"}
{"name":"Seminorm.sSup_empty","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\n⊢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Bot.bot","decl":"protected theorem sSup_empty : sSup (∅ : Set (Seminorm 𝕜 E)) = ⊥ := by\n  ext\n  rw [Seminorm.sSup_apply bddAbove_empty, Real.iSup_of_isEmpty]\n  rfl\n\n"}
{"name":"Seminorm.mem_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx y : E\nr : Real\n⊢ Iff (Membership.mem (p.ball x r) y) (LT.lt (p (HSub.hSub y x)) r)","decl":"@[simp]\ntheorem mem_ball : y ∈ ball p x r ↔ p (y - x) < r :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.mem_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx y : E\nr : Real\n⊢ Iff (Membership.mem (p.closedBall x r) y) (LE.le (p (HSub.hSub y x)) r)","decl":"@[simp]\ntheorem mem_closedBall : y ∈ closedBall p x r ↔ p (y - x) ≤ r :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.mem_ball_self","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\nhr : LT.lt 0 r\n⊢ Membership.mem (p.ball x r) x","decl":"theorem mem_ball_self (hr : 0 < r) : x ∈ ball p x r := by simp [hr]\n\n"}
{"name":"Seminorm.mem_closedBall_self","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\nhr : LE.le 0 r\n⊢ Membership.mem (p.closedBall x r) x","decl":"theorem mem_closedBall_self (hr : 0 ≤ r) : x ∈ closedBall p x r := by simp [hr]\n\n"}
{"name":"Seminorm.mem_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\ny : E\nr : Real\n⊢ Iff (Membership.mem (p.ball 0 r) y) (LT.lt (p y) r)","decl":"theorem mem_ball_zero : y ∈ ball p 0 r ↔ p y < r := by rw [mem_ball, sub_zero]\n\n"}
{"name":"Seminorm.mem_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\ny : E\nr : Real\n⊢ Iff (Membership.mem (p.closedBall 0 r) y) (LE.le (p y) r)","decl":"theorem mem_closedBall_zero : y ∈ closedBall p 0 r ↔ p y ≤ r := by rw [mem_closedBall, sub_zero]\n\n"}
{"name":"Seminorm.ball_zero_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Eq (p.ball 0 r) (setOf fun y => LT.lt (p y) r)","decl":"theorem ball_zero_eq : ball p 0 r = { y : E | p y < r } :=\n  Set.ext fun _ => p.mem_ball_zero\n\n"}
{"name":"Seminorm.closedBall_zero_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Eq (p.closedBall 0 r) (setOf fun y => LE.le (p y) r)","decl":"theorem closedBall_zero_eq : closedBall p 0 r = { y : E | p y ≤ r } :=\n  Set.ext fun _ => p.mem_closedBall_zero\n\n"}
{"name":"Seminorm.ball_subset_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\n⊢ HasSubset.Subset (p.ball x r) (p.closedBall x r)","decl":"theorem ball_subset_closedBall (x r) : ball p x r ⊆ closedBall p x r := fun _ h =>\n  (mem_closedBall _).mpr ((mem_ball _).mp h).le\n\n"}
{"name":"Seminorm.closedBall_eq_biInter_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\n⊢ Eq (p.closedBall x r) (Set.iInter fun ρ => Set.iInter fun h => p.ball x ρ)","decl":"theorem closedBall_eq_biInter_ball (x r) : closedBall p x r = ⋂ ρ > r, ball p x ρ := by\n  ext y; simp_rw [mem_closedBall, mem_iInter₂, mem_ball, ← forall_lt_iff_le']\n\n"}
{"name":"Seminorm.ball_zero'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nr : Real\nx : E\nhr : LT.lt 0 r\n⊢ Eq (Seminorm.ball 0 x r) Set.univ","decl":"@[simp]\ntheorem ball_zero' (x : E) (hr : 0 < r) : ball (0 : Seminorm 𝕜 E) x r = Set.univ := by\n  rw [Set.eq_univ_iff_forall, ball]\n  simp [hr]\n\n"}
{"name":"Seminorm.closedBall_zero'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nr : Real\nx : E\nhr : LT.lt 0 r\n⊢ Eq (Seminorm.closedBall 0 x r) Set.univ","decl":"@[simp]\ntheorem closedBall_zero' (x : E) (hr : 0 < r) : closedBall (0 : Seminorm 𝕜 E) x r = Set.univ :=\n  eq_univ_of_subset (ball_subset_closedBall _ _ _) (ball_zero' x hr)\n\n"}
{"name":"Seminorm.ball_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nc : NNReal\nhc : LT.lt 0 c\nr : Real\nx : E\n⊢ Eq ((HSMul.hSMul c p).ball x r) (p.ball x (HDiv.hDiv r ↑c))","decl":"theorem ball_smul (p : Seminorm 𝕜 E) {c : NNReal} (hc : 0 < c) (r : ℝ) (x : E) :\n    (c • p).ball x r = p.ball x (r / c) := by\n  ext\n  rw [mem_ball, mem_ball, smul_apply, NNReal.smul_def, smul_eq_mul, mul_comm,\n    lt_div_iff₀ (NNReal.coe_pos.mpr hc)]\n\n"}
{"name":"Seminorm.closedBall_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nc : NNReal\nhc : LT.lt 0 c\nr : Real\nx : E\n⊢ Eq ((HSMul.hSMul c p).closedBall x r) (p.closedBall x (HDiv.hDiv r ↑c))","decl":"theorem closedBall_smul (p : Seminorm 𝕜 E) {c : NNReal} (hc : 0 < c) (r : ℝ) (x : E) :\n    (c • p).closedBall x r = p.closedBall x (r / c) := by\n  ext\n  rw [mem_closedBall, mem_closedBall, smul_apply, NNReal.smul_def, smul_eq_mul, mul_comm,\n    le_div_iff₀ (NNReal.coe_pos.mpr hc)]\n\n"}
{"name":"Seminorm.ball_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\ne : E\nr : Real\n⊢ Eq ((Max.max p q).ball e r) (Inter.inter (p.ball e r) (q.ball e r))","decl":"theorem ball_sup (p : Seminorm 𝕜 E) (q : Seminorm 𝕜 E) (e : E) (r : ℝ) :\n    ball (p ⊔ q) e r = ball p e r ∩ ball q e r := by\n  simp_rw [ball, ← Set.setOf_and, coe_sup, Pi.sup_apply, sup_lt_iff]\n\n"}
{"name":"Seminorm.closedBall_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np q : Seminorm 𝕜 E\ne : E\nr : Real\n⊢ Eq ((Max.max p q).closedBall e r) (Inter.inter (p.closedBall e r) (q.closedBall e r))","decl":"theorem closedBall_sup (p : Seminorm 𝕜 E) (q : Seminorm 𝕜 E) (e : E) (r : ℝ) :\n    closedBall (p ⊔ q) e r = closedBall p e r ∩ closedBall q e r := by\n  simp_rw [closedBall, ← Set.setOf_and, coe_sup, Pi.sup_apply, sup_le_iff]\n\n"}
{"name":"Seminorm.ball_finset_sup'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nH : s.Nonempty\ne : E\nr : Real\n⊢ Eq ((s.sup' H p).ball e r) (s.inf' H fun i => (p i).ball e r)","decl":"theorem ball_finset_sup' (p : ι → Seminorm 𝕜 E) (s : Finset ι) (H : s.Nonempty) (e : E) (r : ℝ) :\n    ball (s.sup' H p) e r = s.inf' H fun i => ball (p i) e r := by\n  induction H using Finset.Nonempty.cons_induction with\n  | singleton => simp\n  | cons _ _ _ hs ih =>\n    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, ball_sup]\n    -- Porting note: `rw` can't use `inf_eq_inter` here, but `simp` can?\n    simp only [inf_eq_inter, ih]\n\n"}
{"name":"Seminorm.closedBall_finset_sup'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nH : s.Nonempty\ne : E\nr : Real\n⊢ Eq ((s.sup' H p).closedBall e r) (s.inf' H fun i => (p i).closedBall e r)","decl":"theorem closedBall_finset_sup' (p : ι → Seminorm 𝕜 E) (s : Finset ι) (H : s.Nonempty) (e : E)\n    (r : ℝ) : closedBall (s.sup' H p) e r = s.inf' H fun i => closedBall (p i) e r := by\n  induction H using Finset.Nonempty.cons_induction with\n  | singleton => simp\n  | cons _ _ _ hs ih =>\n    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, closedBall_sup]\n    -- Porting note: `rw` can't use `inf_eq_inter` here, but `simp` can?\n    simp only [inf_eq_inter, ih]\n\n"}
{"name":"Seminorm.ball_mono","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nx : E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\nh : LE.le r₁ r₂\n⊢ HasSubset.Subset (p.ball x r₁) (p.ball x r₂)","decl":"theorem ball_mono {p : Seminorm 𝕜 E} {r₁ r₂ : ℝ} (h : r₁ ≤ r₂) : p.ball x r₁ ⊆ p.ball x r₂ :=\n  fun _ (hx : _ < _) => hx.trans_le h\n\n"}
{"name":"Seminorm.closedBall_mono","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nx : E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\nh : LE.le r₁ r₂\n⊢ HasSubset.Subset (p.closedBall x r₁) (p.closedBall x r₂)","decl":"theorem closedBall_mono {p : Seminorm 𝕜 E} {r₁ r₂ : ℝ} (h : r₁ ≤ r₂) :\n    p.closedBall x r₁ ⊆ p.closedBall x r₂ := fun _ (hx : _ ≤ _) => hx.trans h\n\n"}
{"name":"Seminorm.ball_antitone","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nx : E\nr : Real\np q : Seminorm 𝕜 E\nh : LE.le q p\n⊢ HasSubset.Subset (p.ball x r) (q.ball x r)","decl":"theorem ball_antitone {p q : Seminorm 𝕜 E} (h : q ≤ p) : p.ball x r ⊆ q.ball x r := fun _ =>\n  (h _).trans_lt\n\n"}
{"name":"Seminorm.closedBall_antitone","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nx : E\nr : Real\np q : Seminorm 𝕜 E\nh : LE.le q p\n⊢ HasSubset.Subset (p.closedBall x r) (q.closedBall x r)","decl":"theorem closedBall_antitone {p q : Seminorm 𝕜 E} (h : q ≤ p) :\n    p.closedBall x r ⊆ q.closedBall x r := fun _ => (h _).trans\n\n"}
{"name":"Seminorm.ball_add_ball_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\nx₁ x₂ : E\n⊢ HasSubset.Subset (HAdd.hAdd (p.ball x₁ r₁) (p.ball x₂ r₂)) (p.ball (HAdd.hAdd x₁ x₂) (HAdd.hAdd r₁ r₂))","decl":"theorem ball_add_ball_subset (p : Seminorm 𝕜 E) (r₁ r₂ : ℝ) (x₁ x₂ : E) :\n    p.ball (x₁ : E) r₁ + p.ball (x₂ : E) r₂ ⊆ p.ball (x₁ + x₂) (r₁ + r₂) := by\n  rintro x ⟨y₁, hy₁, y₂, hy₂, rfl⟩\n  rw [mem_ball, add_sub_add_comm]\n  exact (map_add_le_add p _ _).trans_lt (add_lt_add hy₁ hy₂)\n\n"}
{"name":"Seminorm.closedBall_add_closedBall_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\nx₁ x₂ : E\n⊢ HasSubset.Subset (HAdd.hAdd (p.closedBall x₁ r₁) (p.closedBall x₂ r₂)) (p.closedBall (HAdd.hAdd x₁ x₂) (HAdd.hAdd r₁ r₂))","decl":"theorem closedBall_add_closedBall_subset (p : Seminorm 𝕜 E) (r₁ r₂ : ℝ) (x₁ x₂ : E) :\n    p.closedBall (x₁ : E) r₁ + p.closedBall (x₂ : E) r₂ ⊆ p.closedBall (x₁ + x₂) (r₁ + r₂) := by\n  rintro x ⟨y₁, hy₁, y₂, hy₂, rfl⟩\n  rw [mem_closedBall, add_sub_add_comm]\n  exact (map_add_le_add p _ _).trans (add_le_add hy₁ hy₂)\n\n"}
{"name":"Seminorm.sub_mem_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\np : Seminorm 𝕜 E\nx₁ x₂ y : E\nr : Real\n⊢ Iff (Membership.mem (p.ball y r) (HSub.hSub x₁ x₂)) (Membership.mem (p.ball (HAdd.hAdd x₂ y) r) x₁)","decl":"theorem sub_mem_ball (p : Seminorm 𝕜 E) (x₁ x₂ y : E) (r : ℝ) :\n    x₁ - x₂ ∈ p.ball y r ↔ x₁ ∈ p.ball (x₂ + y) r := by simp_rw [mem_ball, sub_sub]\n\n"}
{"name":"Seminorm.vadd_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nx y : E\nr : Real\np : Seminorm 𝕜 E\n⊢ Eq (HVAdd.hVAdd x (p.ball y r)) (p.ball (HVAdd.hVAdd x y) r)","decl":"/-- The image of a ball under addition with a singleton is another ball. -/\ntheorem vadd_ball (p : Seminorm 𝕜 E) : x +ᵥ p.ball y r = p.ball (x +ᵥ y) r :=\n  letI := AddGroupSeminorm.toSeminormedAddCommGroup p.toAddGroupSeminorm\n  Metric.vadd_ball x y r\n\n"}
{"name":"Seminorm.vadd_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : SMul 𝕜 E\nx y : E\nr : Real\np : Seminorm 𝕜 E\n⊢ Eq (HVAdd.hVAdd x (p.closedBall y r)) (p.closedBall (HVAdd.hVAdd x y) r)","decl":"/-- The image of a closed ball under addition with a singleton is another closed ball. -/\ntheorem vadd_closedBall (p : Seminorm 𝕜 E) : x +ᵥ p.closedBall y r = p.closedBall (x +ᵥ y) r :=\n  letI := AddGroupSeminorm.toSeminormedAddCommGroup p.toAddGroupSeminorm\n  Metric.vadd_closedBall x y r\n\n"}
{"name":"Seminorm.ball_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : SeminormedRing 𝕜₂\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜₂ E₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nx : E\nr : Real\n⊢ Eq ((p.comp f).ball x r) (Set.preimage (⇑f) (p.ball (f x) r))","decl":"theorem ball_comp (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) (x : E) (r : ℝ) :\n    (p.comp f).ball x r = f ⁻¹' p.ball (f x) r := by\n  ext\n  simp_rw [ball, mem_preimage, comp_apply, Set.mem_setOf_eq, map_sub]\n\n"}
{"name":"Seminorm.closedBall_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\n𝕜₂ : Type u_4\nE : Type u_7\nE₂ : Type u_8\ninst✝⁶ : SeminormedRing 𝕜\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module 𝕜 E\ninst✝³ : SeminormedRing 𝕜₂\ninst✝² : AddCommGroup E₂\ninst✝¹ : Module 𝕜₂ E₂\nσ₁₂ : RingHom 𝕜 𝕜₂\ninst✝ : RingHomIsometric σ₁₂\np : Seminorm 𝕜₂ E₂\nf : LinearMap σ₁₂ E E₂\nx : E\nr : Real\n⊢ Eq ((p.comp f).closedBall x r) (Set.preimage (⇑f) (p.closedBall (f x) r))","decl":"theorem closedBall_comp (p : Seminorm 𝕜₂ E₂) (f : E →ₛₗ[σ₁₂] E₂) (x : E) (r : ℝ) :\n    (p.comp f).closedBall x r = f ⁻¹' p.closedBall (f x) r := by\n  ext\n  simp_rw [closedBall, mem_preimage, comp_apply, Set.mem_setOf_eq, map_sub]\n\n"}
{"name":"Seminorm.preimage_metric_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Eq (Set.preimage (⇑p) (Metric.ball 0 r)) (setOf fun x => LT.lt (p x) r)","decl":"theorem preimage_metric_ball {r : ℝ} : p ⁻¹' Metric.ball 0 r = { x | p x < r } := by\n  ext x\n  simp only [mem_setOf, mem_preimage, mem_ball_zero_iff, Real.norm_of_nonneg (apply_nonneg p _)]\n\n"}
{"name":"Seminorm.preimage_metric_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Eq (Set.preimage (⇑p) (Metric.closedBall 0 r)) (setOf fun x => LE.le (p x) r)","decl":"theorem preimage_metric_closedBall {r : ℝ} : p ⁻¹' Metric.closedBall 0 r = { x | p x ≤ r } := by\n  ext x\n  simp only [mem_setOf, mem_preimage, mem_closedBall_zero_iff,\n    Real.norm_of_nonneg (apply_nonneg p _)]\n\n"}
{"name":"Seminorm.ball_zero_eq_preimage_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Eq (p.ball 0 r) (Set.preimage (⇑p) (Metric.ball 0 r))","decl":"theorem ball_zero_eq_preimage_ball {r : ℝ} : p.ball 0 r = p ⁻¹' Metric.ball 0 r := by\n  rw [ball_zero_eq, preimage_metric_ball]\n\n"}
{"name":"Seminorm.closedBall_zero_eq_preimage_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Eq (p.closedBall 0 r) (Set.preimage (⇑p) (Metric.closedBall 0 r))","decl":"theorem closedBall_zero_eq_preimage_closedBall {r : ℝ} :\n    p.closedBall 0 r = p ⁻¹' Metric.closedBall 0 r := by\n  rw [closedBall_zero_eq, preimage_metric_closedBall]\n\n"}
{"name":"Seminorm.ball_bot","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nr : Real\nx : E\nhr : LT.lt 0 r\n⊢ Eq (Bot.bot.ball x r) Set.univ","decl":"@[simp]\ntheorem ball_bot {r : ℝ} (x : E) (hr : 0 < r) : ball (⊥ : Seminorm 𝕜 E) x r = Set.univ :=\n  ball_zero' x hr\n\n"}
{"name":"Seminorm.closedBall_bot","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nr : Real\nx : E\nhr : LT.lt 0 r\n⊢ Eq (Bot.bot.closedBall x r) Set.univ","decl":"@[simp]\ntheorem closedBall_bot {r : ℝ} (x : E) (hr : 0 < r) :\n    closedBall (⊥ : Seminorm 𝕜 E) x r = Set.univ :=\n  closedBall_zero' x hr\n\n"}
{"name":"Seminorm.balanced_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Balanced 𝕜 (p.ball 0 r)","decl":"/-- Seminorm-balls at the origin are balanced. -/\ntheorem balanced_ball_zero (r : ℝ) : Balanced 𝕜 (ball p 0 r) := by\n  rintro a ha x ⟨y, hy, hx⟩\n  rw [mem_ball_zero, ← hx, map_smul_eq_mul]\n  calc\n    _ ≤ p y := mul_le_of_le_one_left (apply_nonneg p _) ha\n    _ < r := by rwa [mem_ball_zero] at hy\n\n"}
{"name":"Seminorm.balanced_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\n⊢ Balanced 𝕜 (p.closedBall 0 r)","decl":"/-- Closed seminorm-balls at the origin are balanced. -/\ntheorem balanced_closedBall_zero (r : ℝ) : Balanced 𝕜 (closedBall p 0 r) := by\n  rintro a ha x ⟨y, hy, hx⟩\n  rw [mem_closedBall_zero, ← hx, map_smul_eq_mul]\n  calc\n    _ ≤ p y := mul_le_of_le_one_left (apply_nonneg p _) ha\n    _ ≤ r := by rwa [mem_closedBall_zero] at hy\n\n"}
{"name":"Seminorm.ball_finset_sup_eq_iInter","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq ((s.sup p).ball x r) (Set.iInter fun i => Set.iInter fun h => (p i).ball x r)","decl":"theorem ball_finset_sup_eq_iInter (p : ι → Seminorm 𝕜 E) (s : Finset ι) (x : E) {r : ℝ}\n    (hr : 0 < r) : ball (s.sup p) x r = ⋂ i ∈ s, ball (p i) x r := by\n  lift r to NNReal using hr.le\n  simp_rw [ball, iInter_setOf, finset_sup_apply, NNReal.coe_lt_coe,\n    Finset.sup_lt_iff (show ⊥ < r from hr), ← NNReal.coe_lt_coe, NNReal.coe_mk]\n\n"}
{"name":"Seminorm.closedBall_finset_sup_eq_iInter","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\nr : Real\nhr : LE.le 0 r\n⊢ Eq ((s.sup p).closedBall x r) (Set.iInter fun i => Set.iInter fun h => (p i).closedBall x r)","decl":"theorem closedBall_finset_sup_eq_iInter (p : ι → Seminorm 𝕜 E) (s : Finset ι) (x : E) {r : ℝ}\n    (hr : 0 ≤ r) : closedBall (s.sup p) x r = ⋂ i ∈ s, closedBall (p i) x r := by\n  lift r to NNReal using hr\n  simp_rw [closedBall, iInter_setOf, finset_sup_apply, NNReal.coe_le_coe, Finset.sup_le_iff, ←\n    NNReal.coe_le_coe, NNReal.coe_mk]\n\n"}
{"name":"Seminorm.ball_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq ((s.sup p).ball x r) (s.inf fun i => (p i).ball x r)","decl":"theorem ball_finset_sup (p : ι → Seminorm 𝕜 E) (s : Finset ι) (x : E) {r : ℝ} (hr : 0 < r) :\n    ball (s.sup p) x r = s.inf fun i => ball (p i) x r := by\n  rw [Finset.inf_eq_iInf]\n  exact ball_finset_sup_eq_iInter _ _ _ hr\n\n"}
{"name":"Seminorm.closedBall_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nx : E\nr : Real\nhr : LE.le 0 r\n⊢ Eq ((s.sup p).closedBall x r) (s.inf fun i => (p i).closedBall x r)","decl":"theorem closedBall_finset_sup (p : ι → Seminorm 𝕜 E) (s : Finset ι) (x : E) {r : ℝ} (hr : 0 ≤ r) :\n    closedBall (s.sup p) x r = s.inf fun i => closedBall (p i) x r := by\n  rw [Finset.inf_eq_iInf]\n  exact closedBall_finset_sup_eq_iInter _ _ _ hr\n\n"}
{"name":"Seminorm.ball_eq_emptyset","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\nhr : LE.le r 0\n⊢ Eq (p.ball x r) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ball_eq_emptyset (p : Seminorm 𝕜 E) {x : E} {r : ℝ} (hr : r ≤ 0) : p.ball x r = ∅ := by\n  ext\n  rw [Seminorm.mem_ball, Set.mem_empty_iff_false, iff_false, not_lt]\n  exact hr.trans (apply_nonneg p _)\n\n"}
{"name":"Seminorm.closedBall_eq_emptyset","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\nhr : LT.lt r 0\n⊢ Eq (p.closedBall x r) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem closedBall_eq_emptyset (p : Seminorm 𝕜 E) {x : E} {r : ℝ} (hr : r < 0) :\n    p.closedBall x r = ∅ := by\n  ext\n  rw [Seminorm.mem_closedBall, Set.mem_empty_iff_false, iff_false, not_le]\n  exact hr.trans_le (apply_nonneg _ _)\n\n"}
{"name":"Seminorm.closedBall_smul_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr₁ : Real\nhr₁ : Ne r₁ 0\nr₂ : Real\n⊢ HasSubset.Subset (HSMul.hSMul (Metric.closedBall 0 r₁) (p.ball 0 r₂)) (p.ball 0 (HMul.hMul r₁ r₂))","decl":"theorem closedBall_smul_ball (p : Seminorm 𝕜 E) {r₁ : ℝ} (hr₁ : r₁ ≠ 0) (r₂ : ℝ) :\n    Metric.closedBall (0 : 𝕜) r₁ • p.ball 0 r₂ ⊆ p.ball 0 (r₁ * r₂) := by\n  simp only [smul_subset_iff, mem_ball_zero, mem_closedBall_zero_iff, map_smul_eq_mul]\n  refine fun a ha b hb ↦ mul_lt_mul' ha hb (apply_nonneg _ _) ?_\n  exact hr₁.lt_or_lt.resolve_left <| ((norm_nonneg a).trans ha).not_lt\n\n"}
{"name":"Seminorm.ball_smul_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\nhr₂ : Ne r₂ 0\n⊢ HasSubset.Subset (HSMul.hSMul (Metric.ball 0 r₁) (p.closedBall 0 r₂)) (p.ball 0 (HMul.hMul r₁ r₂))","decl":"theorem ball_smul_closedBall (p : Seminorm 𝕜 E) (r₁ : ℝ) {r₂ : ℝ} (hr₂ : r₂ ≠ 0) :\n    Metric.ball (0 : 𝕜) r₁ • p.closedBall 0 r₂ ⊆ p.ball 0 (r₁ * r₂) := by\n  simp only [smul_subset_iff, mem_ball_zero, mem_closedBall_zero, mem_ball_zero_iff,\n    map_smul_eq_mul]\n  intro a ha b hb\n  rw [mul_comm, mul_comm r₁]\n  refine mul_lt_mul' hb ha (norm_nonneg _) (hr₂.lt_or_lt.resolve_left ?_)\n  exact ((apply_nonneg p b).trans hb).not_lt\n\n"}
{"name":"Seminorm.ball_smul_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\n⊢ HasSubset.Subset (HSMul.hSMul (Metric.ball 0 r₁) (p.ball 0 r₂)) (p.ball 0 (HMul.hMul r₁ r₂))","decl":"theorem ball_smul_ball (p : Seminorm 𝕜 E) (r₁ r₂ : ℝ) :\n    Metric.ball (0 : 𝕜) r₁ • p.ball 0 r₂ ⊆ p.ball 0 (r₁ * r₂) := by\n  rcases eq_or_ne r₂ 0 with rfl | hr₂\n  · simp\n  · exact (smul_subset_smul_left (ball_subset_closedBall _ _ _)).trans\n      (ball_smul_closedBall _ _ hr₂)\n\n"}
{"name":"Seminorm.closedBall_smul_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\n⊢ HasSubset.Subset (HSMul.hSMul (Metric.closedBall 0 r₁) (p.closedBall 0 r₂)) (p.closedBall 0 (HMul.hMul r₁ r₂))","decl":"theorem closedBall_smul_closedBall (p : Seminorm 𝕜 E) (r₁ r₂ : ℝ) :\n    Metric.closedBall (0 : 𝕜) r₁ • p.closedBall 0 r₂ ⊆ p.closedBall 0 (r₁ * r₂) := by\n  simp only [smul_subset_iff, mem_closedBall_zero, mem_closedBall_zero_iff, map_smul_eq_mul]\n  intro a ha b hb\n  gcongr\n  exact (norm_nonneg _).trans ha\n\n"}
{"name":"Seminorm.neg_mem_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nx : E\n⊢ Iff (Membership.mem (p.ball 0 r) (Neg.neg x)) (Membership.mem (p.ball 0 r) x)","decl":"theorem neg_mem_ball_zero {r : ℝ} {x : E} : -x ∈ ball p 0 r ↔ x ∈ ball p 0 r := by\n  simp only [mem_ball_zero, map_neg_eq_map]\n\n"}
{"name":"Seminorm.neg_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : SeminormedRing 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nx : E\n⊢ Eq (Neg.neg (p.ball x r)) (p.ball (Neg.neg x) r)","decl":"@[simp]\ntheorem neg_ball (p : Seminorm 𝕜 E) (r : ℝ) (x : E) : -ball p x r = ball p (-x) r := by\n  ext\n  rw [Set.mem_neg, mem_ball, mem_ball, ← neg_add', sub_neg_eq_add, map_neg_eq_map]\n\n"}
{"name":"Seminorm.closedBall_iSup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nι : Sort u_12\np : ι → Seminorm 𝕜 E\nhp : BddAbove (Set.range p)\ne : E\nr : Real\nhr : LT.lt 0 r\n⊢ Eq ((iSup fun i => p i).closedBall e r) (Set.iInter fun i => (p i).closedBall e r)","decl":"theorem closedBall_iSup {ι : Sort*} {p : ι → Seminorm 𝕜 E} (hp : BddAbove (range p)) (e : E)\n    {r : ℝ} (hr : 0 < r) : closedBall (⨆ i, p i) e r = ⋂ i, closedBall (p i) e r := by\n  cases isEmpty_or_nonempty ι\n  · rw [iSup_of_empty', iInter_of_empty, Seminorm.sSup_empty]\n    exact closedBall_bot _ hr\n  · ext x\n    have := Seminorm.bddAbove_range_iff.mp hp (x - e)\n    simp only [mem_closedBall, mem_iInter, Seminorm.iSup_apply hp, ciSup_le_iff this]\n\n"}
{"name":"Seminorm.ball_norm_mul_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nk : 𝕜\nr : Real\n⊢ HasSubset.Subset (p.ball 0 (HMul.hMul (Norm.norm k) r)) (HSMul.hSMul k (p.ball 0 r))","decl":"theorem ball_norm_mul_subset {p : Seminorm 𝕜 E} {k : 𝕜} {r : ℝ} :\n    p.ball 0 (‖k‖ * r) ⊆ k • p.ball 0 r := by\n  rcases eq_or_ne k 0 with (rfl | hk)\n  · rw [norm_zero, zero_mul, ball_eq_emptyset _ le_rfl]\n    exact empty_subset _\n  · intro x\n    rw [Set.mem_smul_set, Seminorm.mem_ball_zero]\n    refine fun hx => ⟨k⁻¹ • x, ?_, ?_⟩\n    · rwa [Seminorm.mem_ball_zero, map_smul_eq_mul, norm_inv, ←\n        mul_lt_mul_left <| norm_pos_iff.mpr hk, ← mul_assoc, ← div_eq_mul_inv ‖k‖ ‖k‖,\n        div_self (ne_of_gt <| norm_pos_iff.mpr hk), one_mul]\n    rw [← smul_assoc, smul_eq_mul, ← div_eq_mul_inv, div_self hk, one_smul]\n\n"}
{"name":"Seminorm.smul_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nk : 𝕜\nr : Real\nhk : Ne k 0\n⊢ Eq (HSMul.hSMul k (p.ball 0 r)) (p.ball 0 (HMul.hMul (Norm.norm k) r))","decl":"theorem smul_ball_zero {p : Seminorm 𝕜 E} {k : 𝕜} {r : ℝ} (hk : k ≠ 0) :\n    k • p.ball 0 r = p.ball 0 (‖k‖ * r) := by\n  ext\n  rw [mem_smul_set_iff_inv_smul_mem₀ hk, p.mem_ball_zero, p.mem_ball_zero, map_smul_eq_mul,\n    norm_inv, ← div_eq_inv_mul, div_lt_iff₀ (norm_pos_iff.2 hk), mul_comm]\n\n"}
{"name":"Seminorm.smul_closedBall_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nk : 𝕜\nr : Real\n⊢ HasSubset.Subset (HSMul.hSMul k (p.closedBall 0 r)) (p.closedBall 0 (HMul.hMul (Norm.norm k) r))","decl":"theorem smul_closedBall_subset {p : Seminorm 𝕜 E} {k : 𝕜} {r : ℝ} :\n    k • p.closedBall 0 r ⊆ p.closedBall 0 (‖k‖ * r) := by\n  rintro x ⟨y, hy, h⟩\n  rw [Seminorm.mem_closedBall_zero, ← h, map_smul_eq_mul]\n  rw [Seminorm.mem_closedBall_zero] at hy\n  gcongr\n\n"}
{"name":"Seminorm.smul_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nk : 𝕜\nr : Real\nhk : LT.lt 0 (Norm.norm k)\n⊢ Eq (HSMul.hSMul k (p.closedBall 0 r)) (p.closedBall 0 (HMul.hMul (Norm.norm k) r))","decl":"theorem smul_closedBall_zero {p : Seminorm 𝕜 E} {k : 𝕜} {r : ℝ} (hk : 0 < ‖k‖) :\n    k • p.closedBall 0 r = p.closedBall 0 (‖k‖ * r) := by\n  refine subset_antisymm smul_closedBall_subset ?_\n  intro x\n  rw [Set.mem_smul_set, Seminorm.mem_closedBall_zero]\n  refine fun hx => ⟨k⁻¹ • x, ?_, ?_⟩\n  · rwa [Seminorm.mem_closedBall_zero, map_smul_eq_mul, norm_inv, ← mul_le_mul_left hk, ← mul_assoc,\n      ← div_eq_mul_inv ‖k‖ ‖k‖, div_self (ne_of_gt hk), one_mul]\n  rw [← smul_assoc, smul_eq_mul, ← div_eq_mul_inv, div_self (norm_pos_iff.mp hk), one_smul]\n\n"}
{"name":"Seminorm.ball_zero_absorbs_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr₁ r₂ : Real\nhr₁ : LT.lt 0 r₁\n⊢ Absorbs 𝕜 (p.ball 0 r₁) (p.ball 0 r₂)","decl":"theorem ball_zero_absorbs_ball_zero (p : Seminorm 𝕜 E) {r₁ r₂ : ℝ} (hr₁ : 0 < r₁) :\n    Absorbs 𝕜 (p.ball 0 r₁) (p.ball 0 r₂) := by\n  rcases exists_pos_lt_mul hr₁ r₂ with ⟨r, hr₀, hr⟩\n  refine .of_norm ⟨r, fun a ha x hx => ?_⟩\n  rw [smul_ball_zero (norm_pos_iff.1 <| hr₀.trans_le ha), p.mem_ball_zero]\n  rw [p.mem_ball_zero] at hx\n  exact hx.trans (hr.trans_le <| by gcongr)\n\n"}
{"name":"Seminorm.absorbent_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ Absorbent 𝕜 (p.ball 0 r)","decl":"/-- Seminorm-balls at the origin are absorbent. -/\nprotected theorem absorbent_ball_zero (hr : 0 < r) : Absorbent 𝕜 (ball p (0 : E) r) :=\n  absorbent_iff_forall_absorbs_singleton.2 fun _ =>\n    (p.ball_zero_absorbs_ball_zero hr).mono_right <|\n      singleton_subset_iff.2 <| p.mem_ball_zero.2 <| lt_add_one _\n\n"}
{"name":"Seminorm.absorbent_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ Absorbent 𝕜 (p.closedBall 0 r)","decl":"/-- Closed seminorm-balls at the origin are absorbent. -/\nprotected theorem absorbent_closedBall_zero (hr : 0 < r) : Absorbent 𝕜 (closedBall p (0 : E) r) :=\n  (p.absorbent_ball_zero hr).mono (p.ball_subset_closedBall _ _)\n\n"}
{"name":"Seminorm.absorbent_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nx : E\nhpr : LT.lt (p x) r\n⊢ Absorbent 𝕜 (p.ball x r)","decl":"/-- Seminorm-balls containing the origin are absorbent. -/\nprotected theorem absorbent_ball (hpr : p x < r) : Absorbent 𝕜 (ball p x r) := by\n  refine (p.absorbent_ball_zero <| sub_pos.2 hpr).mono fun y hy => ?_\n  rw [p.mem_ball_zero] at hy\n  exact p.mem_ball.2 ((map_sub_le_add p _ _).trans_lt <| add_lt_of_lt_sub_right hy)\n\n"}
{"name":"Seminorm.absorbent_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nx : E\nhpr : LT.lt (p x) r\n⊢ Absorbent 𝕜 (p.closedBall x r)","decl":"/-- Seminorm-balls containing the origin are absorbent. -/\nprotected theorem absorbent_closedBall (hpr : p x < r) : Absorbent 𝕜 (closedBall p x r) := by\n  refine (p.absorbent_closedBall_zero <| sub_pos.2 hpr).mono fun y hy => ?_\n  rw [p.mem_closedBall_zero] at hy\n  exact p.mem_closedBall.2 ((map_sub_le_add p _ _).trans <| add_le_of_le_sub_right hy)\n\n"}
{"name":"Seminorm.smul_ball_preimage","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\ny : E\nr : Real\na : 𝕜\nha : Ne a 0\n⊢ Eq (Set.preimage (fun x => HSMul.hSMul a x) (p.ball y r)) (p.ball (HSMul.hSMul (Inv.inv a) y) (HDiv.hDiv r (Norm.norm a)))","decl":"@[simp]\ntheorem smul_ball_preimage (p : Seminorm 𝕜 E) (y : E) (r : ℝ) (a : 𝕜) (ha : a ≠ 0) :\n    (a • ·) ⁻¹' p.ball y r = p.ball (a⁻¹ • y) (r / ‖a‖) :=\n  Set.ext fun _ => by\n    rw [mem_preimage, mem_ball, mem_ball, lt_div_iff₀ (norm_pos_iff.mpr ha), mul_comm, ←\n      map_smul_eq_mul p, smul_sub, smul_inv_smul₀ ha]\n\n"}
{"name":"Seminorm.convexOn","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : NormedSpace Real 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : SMul Real E\ninst✝ : IsScalarTower Real 𝕜 E\np : Seminorm 𝕜 E\n⊢ ConvexOn Real Set.univ ⇑p","decl":"/-- A seminorm is convex. Also see `convexOn_norm`. -/\nprotected theorem convexOn : ConvexOn ℝ univ p := by\n  refine ⟨convex_univ, fun x _ y _ a b ha hb _ => ?_⟩\n  calc\n    p (a • x + b • y) ≤ p (a • x) + p (b • y) := map_add_le_add p _ _\n    _ = ‖a • (1 : 𝕜)‖ * p x + ‖b • (1 : 𝕜)‖ * p y := by\n      rw [← map_smul_eq_mul p, ← map_smul_eq_mul p, smul_one_smul, smul_one_smul]\n    _ = a * p x + b * p y := by\n      rw [norm_smul, norm_smul, norm_one, mul_one, mul_one, Real.norm_of_nonneg ha,\n        Real.norm_of_nonneg hb]\n\n"}
{"name":"Seminorm.convex_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : NormedSpace Real 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : Module Real E\ninst✝ : IsScalarTower Real 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\n⊢ Convex Real (p.ball x r)","decl":"/-- Seminorm-balls are convex. -/\ntheorem convex_ball : Convex ℝ (ball p x r) := by\n  convert (p.convexOn.translate_left (-x)).convex_lt r\n  ext y\n  rw [preimage_univ, sep_univ, p.mem_ball, sub_eq_add_neg]\n  rfl\n\n"}
{"name":"Seminorm.convex_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : NormedSpace Real 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : Module Real E\ninst✝ : IsScalarTower Real 𝕜 E\np : Seminorm 𝕜 E\nx : E\nr : Real\n⊢ Convex Real (p.closedBall x r)","decl":"/-- Closed seminorm-balls are convex. -/\ntheorem convex_closedBall : Convex ℝ (closedBall p x r) := by\n  rw [closedBall_eq_biInter_ball]\n  exact convex_iInter₂ fun _ _ => convex_ball _ _ _\n\n"}
{"name":"Seminorm.coe_restrictScalars","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\n𝕜' : Type u_12\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : SeminormedRing 𝕜'\ninst✝⁵ : NormedAlgebra 𝕜 𝕜'\ninst✝⁴ : NormOneClass 𝕜'\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜' E\ninst✝¹ : SMul 𝕜 E\ninst✝ : IsScalarTower 𝕜 𝕜' E\np : Seminorm 𝕜' E\n⊢ Eq ⇑(Seminorm.restrictScalars 𝕜 p) ⇑p","decl":"@[simp]\ntheorem coe_restrictScalars (p : Seminorm 𝕜' E) : (p.restrictScalars 𝕜 : E → ℝ) = p :=\n  rfl\n\n"}
{"name":"Seminorm.restrictScalars_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\n𝕜' : Type u_12\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : SeminormedRing 𝕜'\ninst✝⁵ : NormedAlgebra 𝕜 𝕜'\ninst✝⁴ : NormOneClass 𝕜'\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜' E\ninst✝¹ : SMul 𝕜 E\ninst✝ : IsScalarTower 𝕜 𝕜' E\np : Seminorm 𝕜' E\n⊢ Eq (Seminorm.restrictScalars 𝕜 p).ball p.ball","decl":"@[simp]\ntheorem restrictScalars_ball (p : Seminorm 𝕜' E) : (p.restrictScalars 𝕜).ball = p.ball :=\n  rfl\n\n"}
{"name":"Seminorm.restrictScalars_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\n𝕜' : Type u_12\ninst✝⁷ : NormedField 𝕜\ninst✝⁶ : SeminormedRing 𝕜'\ninst✝⁵ : NormedAlgebra 𝕜 𝕜'\ninst✝⁴ : NormOneClass 𝕜'\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜' E\ninst✝¹ : SMul 𝕜 E\ninst✝ : IsScalarTower 𝕜 𝕜' E\np : Seminorm 𝕜' E\n⊢ Eq (Seminorm.restrictScalars 𝕜 p).closedBall p.closedBall","decl":"@[simp]\ntheorem restrictScalars_closedBall (p : Seminorm 𝕜' E) :\n    (p.restrictScalars 𝕜).closedBall = p.closedBall :=\n  rfl\n\n"}
{"name":"Seminorm.continuousAt_zero_of_forall'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝³ : SeminormedRing 𝕝\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕝 E\ninst✝ : TopologicalSpace E\np : Seminorm 𝕝 E\nhp : ∀ (r : Real), GT.gt r 0 → Membership.mem (nhds 0) (p.closedBall 0 r)\n⊢ ContinuousAt (⇑p) 0","decl":"/-- A seminorm is continuous at `0` if `p.closedBall 0 r ∈ 𝓝 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuousAt_zero'`. -/\ntheorem continuousAt_zero_of_forall' [TopologicalSpace E] {p : Seminorm 𝕝 E}\n    (hp : ∀ r > 0, p.closedBall 0 r ∈ (𝓝 0 : Filter E)) :\n    ContinuousAt p 0 := by\n  simp_rw [Seminorm.closedBall_zero_eq_preimage_closedBall] at hp\n  rwa [ContinuousAt, Metric.nhds_basis_closedBall.tendsto_right_iff, map_zero]\n\n"}
{"name":"Seminorm.continuousAt_zero'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousConstSMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhp : Membership.mem (nhds 0) (p.closedBall 0 r)\n⊢ ContinuousAt (⇑p) 0","decl":"theorem continuousAt_zero' [TopologicalSpace E] [ContinuousConstSMul 𝕜 E] {p : Seminorm 𝕜 E}\n    {r : ℝ} (hp : p.closedBall 0 r ∈ (𝓝 0 : Filter E)) : ContinuousAt p 0 := by\n  refine continuousAt_zero_of_forall' fun ε hε ↦ ?_\n  obtain ⟨k, hk₀, hk⟩ : ∃ k : 𝕜, 0 < ‖k‖ ∧ ‖k‖ * r < ε := by\n    rcases le_or_lt r 0 with hr | hr\n    · use 1; simpa using hr.trans_lt hε\n    · simpa [lt_div_iff₀ hr] using exists_norm_lt 𝕜 (div_pos hε hr)\n  rw [← set_smul_mem_nhds_zero_iff (norm_pos_iff.1 hk₀), smul_closedBall_zero hk₀] at hp\n  exact mem_of_superset hp <| p.closedBall_mono hk.le\n\n"}
{"name":"Seminorm.continuousAt_zero_of_forall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝³ : SeminormedRing 𝕝\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕝 E\ninst✝ : TopologicalSpace E\np : Seminorm 𝕝 E\nhp : ∀ (r : Real), GT.gt r 0 → Membership.mem (nhds 0) (p.ball 0 r)\n⊢ ContinuousAt (⇑p) 0","decl":"/-- A seminorm is continuous at `0` if `p.ball 0 r ∈ 𝓝 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuousAt_zero'`. -/\ntheorem continuousAt_zero_of_forall [TopologicalSpace E] {p : Seminorm 𝕝 E}\n    (hp : ∀ r > 0, p.ball 0 r ∈ (𝓝 0 : Filter E)) :\n    ContinuousAt p 0 :=\n  continuousAt_zero_of_forall'\n    (fun r hr ↦ Filter.mem_of_superset (hp r hr) <| p.ball_subset_closedBall _ _)\n\n"}
{"name":"Seminorm.continuousAt_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁴ : NontriviallyNormedField 𝕜\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕜 E\ninst✝¹ : TopologicalSpace E\ninst✝ : ContinuousConstSMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhp : Membership.mem (nhds 0) (p.ball 0 r)\n⊢ ContinuousAt (⇑p) 0","decl":"theorem continuousAt_zero [TopologicalSpace E] [ContinuousConstSMul 𝕜 E] {p : Seminorm 𝕜 E} {r : ℝ}\n    (hp : p.ball 0 r ∈ (𝓝 0 : Filter E)) : ContinuousAt p 0 :=\n  continuousAt_zero' (Filter.mem_of_superset hp <| p.ball_subset_closedBall _ _)\n\n"}
{"name":"Seminorm.uniformContinuous_of_continuousAt_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : UniformSpace E\ninst✝ : UniformAddGroup E\np : Seminorm 𝕝 E\nhp : ContinuousAt (⇑p) 0\n⊢ UniformContinuous ⇑p","decl":"protected theorem uniformContinuous_of_continuousAt_zero [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm 𝕝 E} (hp : ContinuousAt p 0) : UniformContinuous p := by\n  have hp : Filter.Tendsto p (𝓝 0) (𝓝 0) := map_zero p ▸ hp\n  rw [UniformContinuous, uniformity_eq_comap_nhds_zero_swapped,\n    Metric.uniformity_eq_comap_nhds_zero, Filter.tendsto_comap_iff]\n  exact\n    tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds (hp.comp Filter.tendsto_comap)\n      (fun xy => dist_nonneg) fun xy => p.norm_sub_map_le_sub _ _\n\n"}
{"name":"Seminorm.continuous_of_continuousAt_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\np : Seminorm 𝕝 E\nhp : ContinuousAt (⇑p) 0\n⊢ Continuous ⇑p","decl":"protected theorem continuous_of_continuousAt_zero [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm 𝕝 E} (hp : ContinuousAt p 0) : Continuous p := by\n  letI := TopologicalAddGroup.toUniformSpace E\n  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform\n  exact (Seminorm.uniformContinuous_of_continuousAt_zero hp).continuous\n\n"}
{"name":"Seminorm.uniformContinuous_of_forall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : UniformSpace E\ninst✝ : UniformAddGroup E\np : Seminorm 𝕝 E\nhp : ∀ (r : Real), GT.gt r 0 → Membership.mem (nhds 0) (p.ball 0 r)\n⊢ UniformContinuous ⇑p","decl":"/-- A seminorm is uniformly continuous if `p.ball 0 r ∈ 𝓝 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.uniformContinuous`. -/\nprotected theorem uniformContinuous_of_forall [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm 𝕝 E} (hp : ∀ r > 0, p.ball 0 r ∈ (𝓝 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero_of_forall hp)\n\n"}
{"name":"Seminorm.uniformContinuous","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : UniformSpace E\ninst✝¹ : UniformAddGroup E\ninst✝ : ContinuousConstSMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhp : Membership.mem (nhds 0) (p.ball 0 r)\n⊢ UniformContinuous ⇑p","decl":"protected theorem uniformContinuous [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul 𝕜 E]\n    {p : Seminorm 𝕜 E} {r : ℝ} (hp : p.ball 0 r ∈ (𝓝 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero hp)\n\n"}
{"name":"Seminorm.uniformContinuous_of_forall'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : UniformSpace E\ninst✝ : UniformAddGroup E\np : Seminorm 𝕝 E\nhp : ∀ (r : Real), GT.gt r 0 → Membership.mem (nhds 0) (p.closedBall 0 r)\n⊢ UniformContinuous ⇑p","decl":"/-- A seminorm is uniformly continuous if `p.closedBall 0 r ∈ 𝓝 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.uniformContinuous'`. -/\nprotected theorem uniformContinuous_of_forall' [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm 𝕝 E} (hp : ∀ r > 0, p.closedBall 0 r ∈ (𝓝 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero_of_forall' hp)\n\n"}
{"name":"Seminorm.uniformContinuous'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : UniformSpace E\ninst✝¹ : UniformAddGroup E\ninst✝ : ContinuousConstSMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhp : Membership.mem (nhds 0) (p.closedBall 0 r)\n⊢ UniformContinuous ⇑p","decl":"protected theorem uniformContinuous' [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul 𝕜 E]\n    {p : Seminorm 𝕜 E} {r : ℝ} (hp : p.closedBall 0 r ∈ (𝓝 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero' hp)\n\n"}
{"name":"Seminorm.continuous_of_forall","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\np : Seminorm 𝕝 E\nhp : ∀ (r : Real), GT.gt r 0 → Membership.mem (nhds 0) (p.ball 0 r)\n⊢ Continuous ⇑p","decl":"/-- A seminorm is continuous if `p.ball 0 r ∈ 𝓝 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuous`. -/\nprotected theorem continuous_of_forall [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm 𝕝 E} (hp : ∀ r > 0, p.ball 0 r ∈ (𝓝 0 : Filter E)) :\n    Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero_of_forall hp)\n\n"}
{"name":"Seminorm.continuous","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousConstSMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhp : Membership.mem (nhds 0) (p.ball 0 r)\n⊢ Continuous ⇑p","decl":"protected theorem continuous [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousConstSMul 𝕜 E]\n    {p : Seminorm 𝕜 E} {r : ℝ} (hp : p.ball 0 r ∈ (𝓝 0 : Filter E)) : Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero hp)\n\n"}
{"name":"Seminorm.continuous_of_forall'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\np : Seminorm 𝕝 E\nhp : ∀ (r : Real), GT.gt r 0 → Membership.mem (nhds 0) (p.closedBall 0 r)\n⊢ Continuous ⇑p","decl":"/-- A seminorm is continuous if `p.closedBall 0 r ∈ 𝓝 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuous'`. -/\nprotected theorem continuous_of_forall' [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm 𝕝 E} (hp : ∀ r > 0, p.closedBall 0 r ∈ (𝓝 0 : Filter E)) :\n    Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero_of_forall' hp)\n\n"}
{"name":"Seminorm.continuous'","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\ninst✝² : TopologicalSpace E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousConstSMul 𝕜 E\np : Seminorm 𝕜 E\nr : Real\nhp : Membership.mem (nhds 0) (p.closedBall 0 r)\n⊢ Continuous ⇑p","decl":"protected theorem continuous' [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousConstSMul 𝕜 E]\n    {p : Seminorm 𝕜 E} {r : ℝ} (hp : p.closedBall 0 r ∈ (𝓝 0 : Filter E)) :\n    Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero' hp)\n\n"}
{"name":"Seminorm.continuous_of_le","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝⁴ : SeminormedRing 𝕝\ninst✝³ : AddCommGroup E\ninst✝² : Module 𝕝 E\ninst✝¹ : TopologicalSpace E\ninst✝ : TopologicalAddGroup E\np q : Seminorm 𝕝 E\nhq : Continuous ⇑q\nhpq : LE.le p q\n⊢ Continuous ⇑p","decl":"theorem continuous_of_le [TopologicalSpace E] [TopologicalAddGroup E]\n    {p q : Seminorm 𝕝 E} (hq : Continuous q) (hpq : p ≤ q) : Continuous p := by\n  refine Seminorm.continuous_of_forall (fun r hr ↦ Filter.mem_of_superset\n    (IsOpen.mem_nhds ?_ <| q.mem_ball_self hr) (ball_antitone hpq))\n  rw [ball_zero_eq]\n  exact isOpen_lt hq continuous_const\n\n"}
{"name":"Seminorm.ball_mem_nhds","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕝 : Type u_6\nE : Type u_7\ninst✝³ : SeminormedRing 𝕝\ninst✝² : AddCommGroup E\ninst✝¹ : Module 𝕝 E\ninst✝ : TopologicalSpace E\np : Seminorm 𝕝 E\nhp : Continuous ⇑p\nr : Real\nhr : LT.lt 0 r\n⊢ Membership.mem (nhds 0) (p.ball 0 r)","decl":"lemma ball_mem_nhds [TopologicalSpace E] {p : Seminorm 𝕝 E} (hp : Continuous p) {r : ℝ}\n    (hr : 0 < r) : p.ball 0 r ∈ (𝓝 0 : Filter E) :=\n  have this : Tendsto p (𝓝 0) (𝓝 0) := map_zero p ▸ hp.tendsto 0\n  by simpa only [p.ball_zero_eq] using this (Iio_mem_nhds hr)\n\n"}
{"name":"Seminorm.uniformSpace_eq_of_hasBasis","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\nι : Sort u_12\ninst✝² : UniformSpace E\ninst✝¹ : UniformAddGroup E\ninst✝ : ContinuousConstSMul 𝕜 E\np' : ι → Prop\ns : ι → Set E\np : Seminorm 𝕜 E\nhb : (nhds 0).HasBasis p' s\nh₁ : Exists fun r => Membership.mem (nhds 0) (p.closedBall 0 r)\nh₂ : ∀ (i : ι), p' i → Exists fun r => And (GT.gt r 0) (HasSubset.Subset (p.ball 0 r) (s i))\n⊢ Eq inst✝² PseudoMetricSpace.toUniformSpace","decl":"lemma uniformSpace_eq_of_hasBasis\n    {ι} [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul 𝕜 E]\n    {p' : ι → Prop} {s : ι → Set E} (p : Seminorm 𝕜 E) (hb : (𝓝 0 : Filter E).HasBasis p' s)\n    (h₁ : ∃ r, p.closedBall 0 r ∈ 𝓝 0) (h₂ : ∀ i, p' i → ∃ r > 0, p.ball 0 r ⊆ s i) :\n    ‹UniformSpace E› = p.toAddGroupSeminorm.toSeminormedAddGroup.toUniformSpace := by\n  refine UniformAddGroup.ext ‹_› p.toAddGroupSeminorm.toSeminormedAddCommGroup.to_uniformAddGroup ?_\n  apply le_antisymm\n  · rw [← @comap_norm_nhds_zero E p.toAddGroupSeminorm.toSeminormedAddGroup, ← tendsto_iff_comap]\n    suffices Continuous p from this.tendsto' 0 _ (map_zero p)\n    rcases h₁ with ⟨r, hr⟩\n    exact p.continuous' hr\n  · rw [(@NormedAddCommGroup.nhds_zero_basis_norm_lt E\n      p.toAddGroupSeminorm.toSeminormedAddGroup).le_basis_iff hb]\n    simpa only [subset_def, mem_ball_zero] using h₂\n\n"}
{"name":"Seminorm.uniformity_eq_of_hasBasis","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module 𝕜 E\nι : Sort u_12\ninst✝² : UniformSpace E\ninst✝¹ : UniformAddGroup E\ninst✝ : ContinuousConstSMul 𝕜 E\np' : ι → Prop\ns : ι → Set E\np : Seminorm 𝕜 E\nhb : (nhds 0).HasBasis p' s\nh₁ : Exists fun r => Membership.mem (nhds 0) (p.closedBall 0 r)\nh₂ : ∀ (i : ι), p' i → Exists fun r => And (GT.gt r 0) (HasSubset.Subset (p.ball 0 r) (s i))\n⊢ Eq (uniformity E) (iInf fun r => iInf fun h => Filter.principal (setOf fun x => LT.lt (p (HSub.hSub x.1 x.2)) r))","decl":"lemma uniformity_eq_of_hasBasis\n    {ι} [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul 𝕜 E]\n    {p' : ι → Prop} {s : ι → Set E} (p : Seminorm 𝕜 E) (hb : (𝓝 0 : Filter E).HasBasis p' s)\n    (h₁ : ∃ r, p.closedBall 0 r ∈ 𝓝 0) (h₂ : ∀ i, p' i → ∃ r > 0, p.ball 0 r ⊆ s i) :\n    𝓤 E = ⨅ r > 0, 𝓟 {x | p (x.1 - x.2) < r} := by\n  rw [uniformSpace_eq_of_hasBasis p hb h₁ h₂]; rfl\n\n"}
{"name":"Seminorm.rescale_to_shell_zpow","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nε : Real\nεpos : LT.lt 0 ε\nx : E\nhx : Ne (p x) 0\n⊢ Exists fun n => And (Ne (HPow.hPow c n) 0) (And (LT.lt (p (HSMul.hSMul (HPow.hPow c n) x)) ε) (And (LE.le (HDiv.hDiv ε (Norm.norm c)) (p (HSMul.hSMul (HPow.hPow c n) x))) (LE.le (Inv.inv (Norm.norm (HPow.hPow c n))) (HMul.hMul (HMul.hMul (Inv.inv ε) (Norm.norm c)) (p x)))))","decl":"/-- Let `p` be a seminorm on a vector space over a `NormedField`.\nIf there is a scalar `c` with `‖c‖>1`, then any `x` such that `p x ≠ 0` can be\nmoved by scalar multiplication to any `p`-shell of width `‖c‖`. Also recap information on the\nvalue of `p` on the rescaling element that shows up in applications. -/\nlemma rescale_to_shell_zpow (p : Seminorm 𝕜 E) {c : 𝕜} (hc : 1 < ‖c‖) {ε : ℝ}\n    (εpos : 0 < ε) {x : E} (hx : p x ≠ 0) : ∃ n : ℤ, c^n ≠ 0 ∧\n    p (c^n • x) < ε ∧ (ε / ‖c‖ ≤ p (c^n • x)) ∧ (‖c^n‖⁻¹ ≤ ε⁻¹ * ‖c‖ * p x) := by\n  have xεpos : 0 < (p x)/ε := by positivity\n  rcases exists_mem_Ico_zpow xεpos hc with ⟨n, hn⟩\n  have cpos : 0 < ‖c‖ := by positivity\n  have cnpos : 0 < ‖c^(n+1)‖ := by rw [norm_zpow]; exact xεpos.trans hn.2\n  refine ⟨-(n+1), ?_, ?_, ?_, ?_⟩\n  · show c ^ (-(n + 1)) ≠ 0; exact zpow_ne_zero _ (norm_pos_iff.1 cpos)\n  · show p ((c ^ (-(n + 1))) • x) < ε\n    rw [map_smul_eq_mul, zpow_neg, norm_inv, ← div_eq_inv_mul, div_lt_iff₀ cnpos, mul_comm,\n        norm_zpow]\n    exact (div_lt_iff₀ εpos).1 (hn.2)\n  · show ε / ‖c‖ ≤ p (c ^ (-(n + 1)) • x)\n    rw [zpow_neg, div_le_iff₀ cpos, map_smul_eq_mul, norm_inv, norm_zpow, zpow_add₀ (ne_of_gt cpos),\n        zpow_one, mul_inv_rev, mul_comm, ← mul_assoc, ← mul_assoc, mul_inv_cancel₀ (ne_of_gt cpos),\n        one_mul, ← div_eq_inv_mul, le_div_iff₀ (zpow_pos cpos _), mul_comm]\n    exact (le_div_iff₀ εpos).1 hn.1\n  · show ‖(c ^ (-(n + 1)))‖⁻¹ ≤ ε⁻¹ * ‖c‖ * p x\n    have : ε⁻¹ * ‖c‖ * p x = ε⁻¹ * p x * ‖c‖ := by ring\n    rw [zpow_neg, norm_inv, inv_inv, norm_zpow, zpow_add₀ (ne_of_gt cpos), zpow_one, this,\n        ← div_eq_inv_mul]\n    exact mul_le_mul_of_nonneg_right hn.1 (norm_nonneg _)\n\n"}
{"name":"Seminorm.rescale_to_shell","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : Seminorm 𝕜 E\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nε : Real\nεpos : LT.lt 0 ε\nx : E\nhx : Ne (p x) 0\n⊢ Exists fun d => And (Ne d 0) (And (LT.lt (p (HSMul.hSMul d x)) ε) (And (LE.le (HDiv.hDiv ε (Norm.norm c)) (p (HSMul.hSMul d x))) (LE.le (Inv.inv (Norm.norm d)) (HMul.hMul (HMul.hMul (Inv.inv ε) (Norm.norm c)) (p x)))))","decl":"/-- Let `p` be a seminorm on a vector space over a `NormedField`.\nIf there is a scalar `c` with `‖c‖>1`, then any `x` such that `p x ≠ 0` can be\nmoved by scalar multiplication to any `p`-shell of width `‖c‖`. Also recap information on the\nvalue of `p` on the rescaling element that shows up in applications. -/\nlemma rescale_to_shell (p : Seminorm 𝕜 E) {c : 𝕜} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε) {x : E}\n    (hx : p x ≠ 0) :\n    ∃d : 𝕜, d ≠ 0 ∧ p (d • x) < ε ∧ (ε/‖c‖ ≤ p (d • x)) ∧ (‖d‖⁻¹ ≤ ε⁻¹ * ‖c‖ * p x) :=\nlet ⟨_, hn⟩ := p.rescale_to_shell_zpow hc εpos hx; ⟨_, hn⟩\n\n"}
{"name":"Seminorm.bound_of_shell","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np q : Seminorm 𝕜 E\nε C : Real\nε_pos : LT.lt 0 ε\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nhf : ∀ (x : E), LE.le (HDiv.hDiv ε (Norm.norm c)) (p x) → LT.lt (p x) ε → LE.le (q x) (HMul.hMul C (p x))\nx : E\nhx : Ne (p x) 0\n⊢ LE.le (q x) (HMul.hMul C (p x))","decl":"/-- Let `p` and `q` be two seminorms on a vector space over a `NontriviallyNormedField`.\nIf we have `q x ≤ C * p x` on some shell of the form `{x | ε/‖c‖ ≤ p x < ε}` (where `ε > 0`\nand `‖c‖ > 1`), then we also have `q x ≤ C * p x` for all `x` such that `p x ≠ 0`. -/\nlemma bound_of_shell\n    (p q : Seminorm 𝕜 E) {ε C : ℝ} (ε_pos : 0 < ε) {c : 𝕜} (hc : 1 < ‖c‖)\n    (hf : ∀ x, ε / ‖c‖ ≤ p x → p x < ε → q x ≤ C * p x) {x : E} (hx : p x ≠ 0) :\n    q x ≤ C * p x := by\n  rcases p.rescale_to_shell hc ε_pos hx with ⟨δ, hδ, δxle, leδx, -⟩\n  simpa only [map_smul_eq_mul, mul_left_comm C, mul_le_mul_left (norm_pos_iff.2 hδ)]\n    using hf (δ • x) leδx δxle\n\n"}
{"name":"Seminorm.bound_of_shell_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np q : Seminorm 𝕜 E\nε : Real\nC : NNReal\nε_pos : LT.lt 0 ε\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nhf : ∀ (x : E), LE.le (HDiv.hDiv ε (Norm.norm c)) (p x) → LT.lt (p x) ε → LE.le (q x) ((HSMul.hSMul C p) x)\nx : E\nhx : Ne (p x) 0\n⊢ LE.le (q x) ((HSMul.hSMul C p) x)","decl":"/-- A version of `Seminorm.bound_of_shell` expressed using pointwise scalar multiplication of\nseminorms. -/\nlemma bound_of_shell_smul\n    (p q : Seminorm 𝕜 E) {ε : ℝ} {C : ℝ≥0} (ε_pos : 0 < ε) {c : 𝕜} (hc : 1 < ‖c‖)\n    (hf : ∀ x, ε / ‖c‖ ≤ p x → p x < ε → q x ≤ (C • p) x) {x : E} (hx : p x ≠ 0) :\n    q x ≤ (C • p) x :=\n  Seminorm.bound_of_shell p q ε_pos hc hf hx\n\n"}
{"name":"Seminorm.bound_of_shell_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\nι : Type u_11\ninst✝² : NormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\np : ι → Seminorm 𝕜 E\ns : Finset ι\nq : Seminorm 𝕜 E\nε : Real\nC : NNReal\nε_pos : LT.lt 0 ε\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nhf : ∀ (x : E), (∀ (i : ι), Membership.mem s i → LT.lt ((p i) x) ε) → ∀ (j : ι), Membership.mem s j → LE.le (HDiv.hDiv ε (Norm.norm c)) ((p j) x) → LE.le (q x) ((HSMul.hSMul C (p j)) x)\nx : E\nhx : Exists fun j => And (Membership.mem s j) (Ne ((p j) x) 0)\n⊢ LE.le (q x) ((HSMul.hSMul C (s.sup p)) x)","decl":"lemma bound_of_shell_sup (p : ι → Seminorm 𝕜 E) (s : Finset ι)\n    (q : Seminorm 𝕜 E) {ε : ℝ} {C : ℝ≥0} (ε_pos : 0 < ε) {c : 𝕜} (hc : 1 < ‖c‖)\n    (hf : ∀ x, (∀ i ∈ s, p i x < ε) → ∀ j ∈ s, ε / ‖c‖ ≤ p j x → q x ≤ (C • p j) x)\n    {x : E} (hx : ∃ j, j ∈ s ∧ p j x ≠ 0) :\n    q x ≤ (C • s.sup p) x := by\n  rcases hx with ⟨j, hj, hjx⟩\n  have : (s.sup p) x ≠ 0 :=\n    ne_of_gt ((hjx.symm.lt_of_le <| apply_nonneg _ _).trans_le (le_finset_sup_apply hj))\n  refine (s.sup p).bound_of_shell_smul q ε_pos hc (fun y hle hlt ↦ ?_) this\n  rcases exists_apply_eq_finset_sup p ⟨j, hj⟩ y with ⟨i, hi, hiy⟩\n  rw [smul_apply, hiy]\n  exact hf y (fun k hk ↦ (le_finset_sup_apply hk).trans_lt hlt) i hi (hiy ▸ hle)\n\n"}
{"name":"Seminorm.bddAbove_of_absorbent","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NontriviallyNormedField 𝕜\ninst✝¹ : AddCommGroup E\ninst✝ : Module 𝕜 E\nι : Sort u_12\np : ι → Seminorm 𝕜 E\ns : Set E\nhs : Absorbent 𝕜 s\nh : ∀ (x : E), Membership.mem s x → BddAbove (Set.range fun x_1 => (p x_1) x)\n⊢ BddAbove (Set.range p)","decl":"/-- Let `p i` be a family of seminorms on `E`. Let `s` be an absorbent set in `𝕜`.\nIf all seminorms are uniformly bounded at every point of `s`,\nthen they are bounded in the space of seminorms. -/\nlemma bddAbove_of_absorbent {ι : Sort*} {p : ι → Seminorm 𝕜 E} {s : Set E} (hs : Absorbent 𝕜 s)\n    (h : ∀ x ∈ s, BddAbove (range (p · x))) : BddAbove (range p) := by\n  rw [Seminorm.bddAbove_range_iff]\n  intro x\n  obtain ⟨c, hc₀, hc⟩ : ∃ c ≠ 0, (c : 𝕜) • x ∈ s :=\n    (eventually_mem_nhdsWithin.and (hs.eventually_nhdsWithin_zero x)).exists\n  rcases h _ hc with ⟨M, hM⟩\n  refine ⟨M / ‖c‖, forall_mem_range.mpr fun i ↦ (le_div_iff₀' (norm_pos_iff.2 hc₀)).2 ?_⟩\n  exact hM ⟨i, map_smul_eq_mul ..⟩\n\n"}
{"name":"coe_normSeminorm","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (⇑(normSeminorm 𝕜 E)) Norm.norm","decl":"@[simp]\ntheorem coe_normSeminorm : ⇑(normSeminorm 𝕜 E) = norm :=\n  rfl\n\n"}
{"name":"ball_normSeminorm","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\n⊢ Eq (normSeminorm 𝕜 E).ball Metric.ball","decl":"@[simp]\ntheorem ball_normSeminorm : (normSeminorm 𝕜 E).ball = Metric.ball := by\n  ext x r y\n  simp only [Seminorm.mem_ball, Metric.mem_ball, coe_normSeminorm, dist_eq_norm]\n\n"}
{"name":"absorbent_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\nhr : LT.lt 0 r\n⊢ Absorbent 𝕜 (Metric.ball 0 r)","decl":"/-- Balls at the origin are absorbent. -/\ntheorem absorbent_ball_zero (hr : 0 < r) : Absorbent 𝕜 (Metric.ball (0 : E) r) := by\n  rw [← ball_normSeminorm 𝕜]\n  exact (normSeminorm _ _).absorbent_ball_zero hr\n\n"}
{"name":"absorbent_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\nx : E\nhx : LT.lt (Norm.norm x) r\n⊢ Absorbent 𝕜 (Metric.ball x r)","decl":"/-- Balls containing the origin are absorbent. -/\ntheorem absorbent_ball (hx : ‖x‖ < r) : Absorbent 𝕜 (Metric.ball x r) := by\n  rw [← ball_normSeminorm 𝕜]\n  exact (normSeminorm _ _).absorbent_ball hx\n\n"}
{"name":"balanced_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nr : Real\n⊢ Balanced 𝕜 (Metric.ball 0 r)","decl":"/-- Balls at the origin are balanced. -/\ntheorem balanced_ball_zero : Balanced 𝕜 (Metric.ball (0 : E) r) := by\n  rw [← ball_normSeminorm 𝕜]\n  exact (normSeminorm _ _).balanced_ball_zero r\n\n"}
{"name":"rescale_to_shell_semi_normed_zpow","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nε : Real\nεpos : LT.lt 0 ε\nx : E\nhx : Ne (Norm.norm x) 0\n⊢ Exists fun n => And (Ne (HPow.hPow c n) 0) (And (LT.lt (Norm.norm (HSMul.hSMul (HPow.hPow c n) x)) ε) (And (LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm (HSMul.hSMul (HPow.hPow c n) x))) (LE.le (Inv.inv (Norm.norm (HPow.hPow c n))) (HMul.hMul (HMul.hMul (Inv.inv ε) (Norm.norm c)) (Norm.norm x)))))","decl":"/-- If there is a scalar `c` with `‖c‖>1`, then any element with nonzero norm can be\nmoved by scalar multiplication to any shell of width `‖c‖`. Also recap information on the norm of\nthe rescaling element that shows up in applications. -/\nlemma rescale_to_shell_semi_normed_zpow {c : 𝕜} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε) {x : E}\n    (hx : ‖x‖ ≠ 0) :\n    ∃ n : ℤ, c^n ≠ 0 ∧ ‖c^n • x‖ < ε ∧ (ε / ‖c‖ ≤ ‖c^n • x‖) ∧ (‖c^n‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖) :=\n  (normSeminorm 𝕜 E).rescale_to_shell_zpow hc εpos hx\n\n"}
{"name":"rescale_to_shell_semi_normed","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nE : Type u_7\ninst✝² : NormedField 𝕜\ninst✝¹ : SeminormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nε : Real\nεpos : LT.lt 0 ε\nx : E\nhx : Ne (Norm.norm x) 0\n⊢ Exists fun d => And (Ne d 0) (And (LT.lt (Norm.norm (HSMul.hSMul d x)) ε) (And (LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm (HSMul.hSMul d x))) (LE.le (Inv.inv (Norm.norm d)) (HMul.hMul (HMul.hMul (Inv.inv ε) (Norm.norm c)) (Norm.norm x)))))","decl":"/-- If there is a scalar `c` with `‖c‖>1`, then any element with nonzero norm can be\nmoved by scalar multiplication to any shell of width `‖c‖`. Also recap information on the norm of\nthe rescaling element that shows up in applications. -/\nlemma rescale_to_shell_semi_normed {c : 𝕜} (hc : 1 < ‖c‖) {ε : ℝ} (εpos : 0 < ε)\n    {x : E} (hx : ‖x‖ ≠ 0) :\n    ∃d : 𝕜, d ≠ 0 ∧ ‖d • x‖ < ε ∧ (ε/‖c‖ ≤ ‖d • x‖) ∧ (‖d‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖) :=\n  (normSeminorm 𝕜 E).rescale_to_shell hc εpos hx\n\n"}
{"name":"rescale_to_shell_zpow","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nF : Type u_10\ninst✝² : NormedField 𝕜\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nε : Real\nεpos : LT.lt 0 ε\nx : F\nhx : Ne x 0\n⊢ Exists fun n => And (Ne (HPow.hPow c n) 0) (And (LT.lt (Norm.norm (HSMul.hSMul (HPow.hPow c n) x)) ε) (And (LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm (HSMul.hSMul (HPow.hPow c n) x))) (LE.le (Inv.inv (Norm.norm (HPow.hPow c n))) (HMul.hMul (HMul.hMul (Inv.inv ε) (Norm.norm c)) (Norm.norm x)))))","decl":"lemma rescale_to_shell_zpow [NormedAddCommGroup F] [NormedSpace 𝕜 F] {c : 𝕜} (hc : 1 < ‖c‖)\n    {ε : ℝ} (εpos : 0 < ε) {x : F} (hx : x ≠ 0) :\n    ∃ n : ℤ, c^n ≠ 0 ∧ ‖c^n • x‖ < ε ∧ (ε / ‖c‖ ≤ ‖c^n • x‖) ∧ (‖c^n‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖) :=\n  rescale_to_shell_semi_normed_zpow hc εpos (norm_ne_zero_iff.mpr hx)\n\n"}
{"name":"rescale_to_shell","module":"Mathlib.Analysis.Seminorm","initialProofState":"𝕜 : Type u_3\nF : Type u_10\ninst✝² : NormedField 𝕜\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nc : 𝕜\nhc : LT.lt 1 (Norm.norm c)\nε : Real\nεpos : LT.lt 0 ε\nx : F\nhx : Ne x 0\n⊢ Exists fun d => And (Ne d 0) (And (LT.lt (Norm.norm (HSMul.hSMul d x)) ε) (And (LE.le (HDiv.hDiv ε (Norm.norm c)) (Norm.norm (HSMul.hSMul d x))) (LE.le (Inv.inv (Norm.norm d)) (HMul.hMul (HMul.hMul (Inv.inv ε) (Norm.norm c)) (Norm.norm x)))))","decl":"/-- If there is a scalar `c` with `‖c‖>1`, then any element can be moved by scalar multiplication to\nany shell of width `‖c‖`. Also recap information on the norm of the rescaling element that shows\nup in applications. -/\nlemma rescale_to_shell [NormedAddCommGroup F] [NormedSpace 𝕜 F] {c : 𝕜} (hc : 1 < ‖c‖)\n    {ε : ℝ} (εpos : 0 < ε) {x : F} (hx : x ≠ 0) :\n    ∃d : 𝕜, d ≠ 0 ∧ ‖d • x‖ < ε ∧ (ε/‖c‖ ≤ ‖d • x‖) ∧ (‖d‖⁻¹ ≤ ε⁻¹ * ‖c‖ * ‖x‖) :=\n  rescale_to_shell_semi_normed hc εpos (norm_ne_zero_iff.mpr hx)\n\n"}
