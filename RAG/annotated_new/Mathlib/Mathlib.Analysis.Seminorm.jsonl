{"name":"Seminorm.mk.inj","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_12\nE : Type u_13\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\ntoAddGroupSeminormâœ : AddGroupSeminorm E\nsmul'âœ : âˆ€ (a : ğ•œ) (x : E), Eq (toAddGroupSeminormâœ.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminormâœ.toFun x))\ntoAddGroupSeminorm : AddGroupSeminorm E\nsmul' : âˆ€ (a : ğ•œ) (x : E), Eq (toAddGroupSeminorm.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm.toFun x))\nxâœ : Eq { toAddGroupSeminorm := toAddGroupSeminormâœ, smul' := smul'âœ } { toAddGroupSeminorm := toAddGroupSeminorm, smul' := smul' }\nâŠ¢ Eq toAddGroupSeminormâœ toAddGroupSeminorm","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (ğ•œ : Type*) (E : Type*) [SeminormedRing ğ•œ] [AddGroup E] [SMul ğ•œ E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : âˆ€ (a : ğ•œ) (x : E), toFun (a â€¢ x) = â€–aâ€– * toFun x\n\n"}
{"name":"Seminorm.mk.injEq","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_12\nE : Type u_13\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\ntoAddGroupSeminormâœ : AddGroupSeminorm E\nsmul'âœ : âˆ€ (a : ğ•œ) (x : E), Eq (toAddGroupSeminormâœ.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminormâœ.toFun x))\ntoAddGroupSeminorm : AddGroupSeminorm E\nsmul' : âˆ€ (a : ğ•œ) (x : E), Eq (toAddGroupSeminorm.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm.toFun x))\nâŠ¢ Eq (Eq { toAddGroupSeminorm := toAddGroupSeminormâœ, smul' := smul'âœ } { toAddGroupSeminorm := toAddGroupSeminorm, smul' := smul' }) (Eq toAddGroupSeminormâœ toAddGroupSeminorm)","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (ğ•œ : Type*) (E : Type*) [SeminormedRing ğ•œ] [AddGroup E] [SMul ğ•œ E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : âˆ€ (a : ğ•œ) (x : E), toFun (a â€¢ x) = â€–aâ€– * toFun x\n\n"}
{"name":"Seminorm.mk.sizeOf_spec","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_12\nE : Type u_13\ninstâœâ´ : SeminormedRing ğ•œ\ninstâœÂ³ : AddGroup E\ninstâœÂ² : SMul ğ•œ E\ninstâœÂ¹ : SizeOf ğ•œ\ninstâœ : SizeOf E\ntoAddGroupSeminorm : AddGroupSeminorm E\nsmul' : âˆ€ (a : ğ•œ) (x : E), Eq (toAddGroupSeminorm.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (toAddGroupSeminorm.toFun x))\nâŠ¢ Eq (SizeOf.sizeOf { toAddGroupSeminorm := toAddGroupSeminorm, smul' := smul' }) (HAdd.hAdd 1 (SizeOf.sizeOf toAddGroupSeminorm))","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (ğ•œ : Type*) (E : Type*) [SeminormedRing ğ•œ] [AddGroup E] [SMul ğ•œ E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : âˆ€ (a : ğ•œ) (x : E), toFun (a â€¢ x) = â€–aâ€– * toFun x\n\n"}
{"name":"Seminorm.smul'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_12\nE : Type u_13\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\nself : Seminorm ğ•œ E\na : ğ•œ\nx : E\nâŠ¢ Eq (self.toFun (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (self.toFun x))","decl":"/-- A seminorm on a module over a normed ring is a function to the reals that is positive\nsemidefinite, positive homogeneous, and subadditive. -/\nstructure Seminorm (ğ•œ : Type*) (E : Type*) [SeminormedRing ğ•œ] [AddGroup E] [SMul ğ•œ E] extends\n  AddGroupSeminorm E where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  smul' : âˆ€ (a : ğ•œ) (x : E), toFun (a â€¢ x) = â€–aâ€– * toFun x\n\n"}
{"name":"SeminormClass.map_smul_eq_mul","module":"Mathlib.Analysis.Seminorm","initialProofState":"F : Type u_12\nğ•œ : outParam (Type u_13)\nE : outParam (Type u_14)\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : AddGroup E\ninstâœÂ¹ : SMul ğ•œ E\ninstâœ : FunLike F E Real\nself : SeminormClass F ğ•œ E\nf : F\na : ğ•œ\nx : E\nâŠ¢ Eq (f (HSMul.hSMul a x)) (HMul.hMul (Norm.norm a) (f x))","decl":"/-- `SeminormClass F ğ•œ E` states that `F` is a type of seminorms on the `ğ•œ`-module `E`.\n\nYou should extend this class when you extend `Seminorm`. -/\nclass SeminormClass (F : Type*) (ğ•œ E : outParam Type*) [SeminormedRing ğ•œ] [AddGroup E]\n  [SMul ğ•œ E] [FunLike F E â„] extends AddGroupSeminormClass F E â„ : Prop where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  map_smul_eq_mul (f : F) (a : ğ•œ) (x : E) : f (a â€¢ x) = â€–aâ€– * f x\n\n"}
{"name":"SeminormClass.toAddGroupSeminormClass","module":"Mathlib.Analysis.Seminorm","initialProofState":"F : Type u_12\nğ•œ : outParam (Type u_13)\nE : outParam (Type u_14)\ninstâœÂ³ : SeminormedRing ğ•œ\ninstâœÂ² : AddGroup E\ninstâœÂ¹ : SMul ğ•œ E\ninstâœ : FunLike F E Real\nself : SeminormClass F ğ•œ E\nâŠ¢ AddGroupSeminormClass F E Real","decl":"/-- `SeminormClass F ğ•œ E` states that `F` is a type of seminorms on the `ğ•œ`-module `E`.\n\nYou should extend this class when you extend `Seminorm`. -/\nclass SeminormClass (F : Type*) (ğ•œ E : outParam Type*) [SeminormedRing ğ•œ] [AddGroup E]\n  [SMul ğ•œ E] [FunLike F E â„] extends AddGroupSeminormClass F E â„ : Prop where\n  /-- The seminorm of a scalar multiplication is the product of the absolute value of the scalar\n  and the original seminorm. -/\n  map_smul_eq_mul (f : F) (a : ğ•œ) (x : E) : f (a â€¢ x) = â€–aâ€– * f x\n\n"}
{"name":"Seminorm.instSeminormClass","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\nâŠ¢ SeminormClass (Seminorm ğ•œ E) ğ•œ E","decl":"instance instSeminormClass : SeminormClass (Seminorm ğ•œ E) ğ•œ E where\n  map_zero f := f.map_zero'\n  map_add_le_add f := f.add_le'\n  map_neg_eq_map f := f.neg'\n  map_smul_eq_mul f := f.smul'\n\n"}
{"name":"Seminorm.ext","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nh : âˆ€ (x : E), Eq (p x) (q x)\nâŠ¢ Eq p q","decl":"@[ext]\ntheorem ext {p q : Seminorm ğ•œ E} (h : âˆ€ x, (p : E â†’ â„) x = q x) : p = q :=\n  DFunLike.ext p q h\n\n"}
{"name":"Seminorm.ext_iff","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Iff (Eq p q) (âˆ€ (x : E), Eq (p x) (q x))","decl":"@[ext]\ntheorem ext {p q : Seminorm ğ•œ E} (h : âˆ€ x, (p : E â†’ â„) x = q x) : p = q :=\n  DFunLike.ext p q h\n\n"}
{"name":"Seminorm.coe_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\nâŠ¢ Eq (â‡‘0) 0","decl":"@[simp]\ntheorem coe_zero : â‡‘(0 : Seminorm ğ•œ E) = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.zero_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\nx : E\nâŠ¢ Eq (0 x) 0","decl":"@[simp]\ntheorem zero_apply (x : E) : (0 : Seminorm ğ•œ E) x = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.instIsScalarTowerOfReal","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nR' : Type u_2\nğ•œ : Type u_3\nE : Type u_7\ninstâœÂ¹â° : SeminormedRing ğ•œ\ninstâœâ¹ : AddGroup E\ninstâœâ¸ : SMul ğ•œ E\ninstâœâ· : SMul R Real\ninstâœâ¶ : SMul R NNReal\ninstâœâµ : IsScalarTower R NNReal Real\ninstâœâ´ : SMul R' Real\ninstâœÂ³ : SMul R' NNReal\ninstâœÂ² : IsScalarTower R' NNReal Real\ninstâœÂ¹ : SMul R R'\ninstâœ : IsScalarTower R R' Real\nâŠ¢ IsScalarTower R R' (Seminorm ğ•œ E)","decl":"instance [SMul R â„] [SMul R â„â‰¥0] [IsScalarTower R â„â‰¥0 â„] [SMul R' â„] [SMul R' â„â‰¥0]\n    [IsScalarTower R' â„â‰¥0 â„] [SMul R R'] [IsScalarTower R R' â„] :\n    IsScalarTower R R' (Seminorm ğ•œ E) where\n  smul_assoc r a p := ext fun x => smul_assoc r a (p x)\n\n"}
{"name":"Seminorm.coe_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : SeminormedRing ğ•œ\ninstâœâ´ : AddGroup E\ninstâœÂ³ : SMul ğ•œ E\ninstâœÂ² : SMul R Real\ninstâœÂ¹ : SMul R NNReal\ninstâœ : IsScalarTower R NNReal Real\nr : R\np : Seminorm ğ•œ E\nâŠ¢ Eq (â‡‘(HSMul.hSMul r p)) (HSMul.hSMul r â‡‘p)","decl":"theorem coe_smul [SMul R â„] [SMul R â„â‰¥0] [IsScalarTower R â„â‰¥0 â„] (r : R) (p : Seminorm ğ•œ E) :\n    â‡‘(r â€¢ p) = r â€¢ â‡‘p :=\n  rfl\n\n"}
{"name":"Seminorm.smul_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : SeminormedRing ğ•œ\ninstâœâ´ : AddGroup E\ninstâœÂ³ : SMul ğ•œ E\ninstâœÂ² : SMul R Real\ninstâœÂ¹ : SMul R NNReal\ninstâœ : IsScalarTower R NNReal Real\nr : R\np : Seminorm ğ•œ E\nx : E\nâŠ¢ Eq ((HSMul.hSMul r p) x) (HSMul.hSMul r (p x))","decl":"@[simp]\ntheorem smul_apply [SMul R â„] [SMul R â„â‰¥0] [IsScalarTower R â„â‰¥0 â„] (r : R) (p : Seminorm ğ•œ E)\n    (x : E) : (r â€¢ p) x = r â€¢ p x :=\n  rfl\n\n"}
{"name":"Seminorm.coe_add","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Eq (â‡‘(HAdd.hAdd p q)) (HAdd.hAdd â‡‘p â‡‘q)","decl":"theorem coe_add (p q : Seminorm ğ•œ E) : â‡‘(p + q) = p + q :=\n  rfl\n\n"}
{"name":"Seminorm.add_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nx : E\nâŠ¢ Eq ((HAdd.hAdd p q) x) (HAdd.hAdd (p x) (q x))","decl":"@[simp]\ntheorem add_apply (p q : Seminorm ğ•œ E) (x : E) : (p + q) x = p x + q x :=\n  rfl\n\n"}
{"name":"Seminorm.coeFnAddMonoidHom_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\naâœ : Seminorm ğ•œ E\na : E\nâŠ¢ Eq ((Seminorm.coeFnAddMonoidHom ğ•œ E) aâœ a) (aâœ a)","decl":"/-- `coeFn` as an `AddMonoidHom`. Helper definition for showing that `Seminorm ğ•œ E` is a module. -/\n@[simps]\ndef coeFnAddMonoidHom : AddMonoidHom (Seminorm ğ•œ E) (E â†’ â„) where\n  toFun := (â†‘)\n  map_zero' := coe_zero\n  map_add' := coe_add\n\n"}
{"name":"Seminorm.coeFnAddMonoidHom_injective","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\nâŠ¢ Function.Injective â‡‘(Seminorm.coeFnAddMonoidHom ğ•œ E)","decl":"theorem coeFnAddMonoidHom_injective : Function.Injective (coeFnAddMonoidHom ğ•œ E) :=\n  show @Function.Injective (Seminorm ğ•œ E) (E â†’ â„) (â†‘) from DFunLike.coe_injective\n\n"}
{"name":"Seminorm.coe_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Eq (â‡‘(Max.max p q)) (Max.max â‡‘p â‡‘q)","decl":"@[simp]\ntheorem coe_sup (p q : Seminorm ğ•œ E) : â‡‘(p âŠ” q) = (p : E â†’ â„) âŠ” (q : E â†’ â„) :=\n  rfl\n\n"}
{"name":"Seminorm.sup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nx : E\nâŠ¢ Eq ((Max.max p q) x) (Max.max (p x) (q x))","decl":"theorem sup_apply (p q : Seminorm ğ•œ E) (x : E) : (p âŠ” q) x = p x âŠ” q x :=\n  rfl\n\n"}
{"name":"Seminorm.smul_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : SeminormedRing ğ•œ\ninstâœâ´ : AddGroup E\ninstâœÂ³ : SMul ğ•œ E\ninstâœÂ² : SMul R Real\ninstâœÂ¹ : SMul R NNReal\ninstâœ : IsScalarTower R NNReal Real\nr : R\np q : Seminorm ğ•œ E\nâŠ¢ Eq (HSMul.hSMul r (Max.max p q)) (Max.max (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"theorem smul_sup [SMul R â„] [SMul R â„â‰¥0] [IsScalarTower R â„â‰¥0 â„] (r : R) (p q : Seminorm ğ•œ E) :\n    r â€¢ (p âŠ” q) = r â€¢ p âŠ” r â€¢ q :=\n  have real.smul_max : âˆ€ x y : â„, r â€¢ max x y = max (r â€¢ x) (r â€¢ y) := fun x y => by\n    simpa only [â† smul_eq_mul, â† NNReal.smul_def, smul_one_smul â„â‰¥0 r (_ : â„)] using\n      mul_max_of_nonneg x y (r â€¢ (1 : â„â‰¥0) : â„â‰¥0).coe_nonneg\n  ext fun _ => real.smul_max _ _\n\n"}
{"name":"Seminorm.coe_le_coe","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Iff (LE.le â‡‘p â‡‘q) (LE.le p q)","decl":"@[simp, norm_cast]\ntheorem coe_le_coe {p q : Seminorm ğ•œ E} : (p : E â†’ â„) â‰¤ q â†” p â‰¤ q :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.coe_lt_coe","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Iff (LT.lt â‡‘p â‡‘q) (LT.lt p q)","decl":"@[simp, norm_cast]\ntheorem coe_lt_coe {p q : Seminorm ğ•œ E} : (p : E â†’ â„) < q â†” p < q :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.le_def","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Iff (LE.le p q) (âˆ€ (x : E), LE.le (p x) (q x))","decl":"theorem le_def {p q : Seminorm ğ•œ E} : p â‰¤ q â†” âˆ€ x, p x â‰¤ q x :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.lt_def","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\nâŠ¢ Iff (LT.lt p q) (And (LE.le p q) (Exists fun x => LT.lt (p x) (q x)))","decl":"theorem lt_def {p q : Seminorm ğ•œ E} : p < q â†” p â‰¤ q âˆ§ âˆƒ x, p x < q x :=\n  @Pi.lt_def _ _ _ p q\n\n"}
{"name":"Seminorm.coe_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nâŠ¢ Eq (â‡‘(p.comp f)) (Function.comp â‡‘p â‡‘f)","decl":"theorem coe_comp (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) : â‡‘(p.comp f) = p âˆ˜ f :=\n  rfl\n\n"}
{"name":"Seminorm.comp_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nx : E\nâŠ¢ Eq ((p.comp f) x) (p (f x))","decl":"@[simp]\ntheorem comp_apply (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (x : E) : (p.comp f) x = p (f x) :=\n  rfl\n\n"}
{"name":"Seminorm.comp_id","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nâŠ¢ Eq (p.comp LinearMap.id) p","decl":"@[simp]\ntheorem comp_id (p : Seminorm ğ•œ E) : p.comp LinearMap.id = p :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nâŠ¢ Eq (p.comp 0) 0","decl":"@[simp]\ntheorem comp_zero (p : Seminorm ğ•œâ‚‚ Eâ‚‚) : p.comp (0 : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) = 0 :=\n  ext fun _ => map_zero p\n\n"}
{"name":"Seminorm.zero_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nâŠ¢ Eq (Seminorm.comp 0 f) 0","decl":"@[simp]\ntheorem zero_comp (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) : (0 : Seminorm ğ•œâ‚‚ Eâ‚‚).comp f = 0 :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nğ•œâ‚ƒ : Type u_5\nE : Type u_7\nEâ‚‚ : Type u_8\nEâ‚ƒ : Type u_9\ninstâœÂ¹Â² : SeminormedRing ğ•œ\ninstâœÂ¹Â¹ : SeminormedRing ğ•œâ‚‚\ninstâœÂ¹â° : SeminormedRing ğ•œâ‚ƒ\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ¹ : RingHomIsometric Ïƒâ‚â‚‚\nÏƒâ‚‚â‚ƒ : RingHom ğ•œâ‚‚ ğ•œâ‚ƒ\ninstâœâ¸ : RingHomIsometric Ïƒâ‚‚â‚ƒ\nÏƒâ‚â‚ƒ : RingHom ğ•œ ğ•œâ‚ƒ\ninstâœâ· : RingHomIsometric Ïƒâ‚â‚ƒ\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : AddCommGroup Eâ‚‚\ninstâœâ´ : AddCommGroup Eâ‚ƒ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : Module ğ•œâ‚‚ Eâ‚‚\ninstâœÂ¹ : Module ğ•œâ‚ƒ Eâ‚ƒ\ninstâœ : RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ\np : Seminorm ğ•œâ‚ƒ Eâ‚ƒ\ng : LinearMap Ïƒâ‚‚â‚ƒ Eâ‚‚ Eâ‚ƒ\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nâŠ¢ Eq (p.comp (g.comp f)) ((p.comp g).comp f)","decl":"theorem comp_comp [RingHomCompTriple Ïƒâ‚â‚‚ Ïƒâ‚‚â‚ƒ Ïƒâ‚â‚ƒ] (p : Seminorm ğ•œâ‚ƒ Eâ‚ƒ) (g : Eâ‚‚ â†’â‚›â‚—[Ïƒâ‚‚â‚ƒ] Eâ‚ƒ)\n    (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) : p.comp (g.comp f) = (p.comp g).comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.add_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np q : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nâŠ¢ Eq ((HAdd.hAdd p q).comp f) (HAdd.hAdd (p.comp f) (q.comp f))","decl":"theorem add_comp (p q : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) :\n    (p + q).comp f = p.comp f + q.comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_add_le","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf g : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nâŠ¢ LE.le (p.comp (HAdd.hAdd f g)) (HAdd.hAdd (p.comp f) (p.comp g))","decl":"theorem comp_add_le (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f g : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) :\n    p.comp (f + g) â‰¤ p.comp f + p.comp g := fun _ => map_add_le_add p _ _\n\n"}
{"name":"Seminorm.smul_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¹ : SeminormedRing ğ•œ\ninstâœâ¸ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ· : RingHomIsometric Ïƒâ‚â‚‚\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : AddCommGroup Eâ‚‚\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : Module ğ•œâ‚‚ Eâ‚‚\ninstâœÂ² : SMul R Real\ninstâœÂ¹ : SMul R NNReal\ninstâœ : IsScalarTower R NNReal Real\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nc : R\nâŠ¢ Eq ((HSMul.hSMul c p).comp f) (HSMul.hSMul c (p.comp f))","decl":"theorem smul_comp (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (c : R) :\n    (c â€¢ p).comp f = c â€¢ p.comp f :=\n  ext fun _ => rfl\n\n"}
{"name":"Seminorm.comp_mono","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np q : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nhp : LE.le p q\nâŠ¢ LE.le (p.comp f) (q.comp f)","decl":"theorem comp_mono {p q : Seminorm ğ•œâ‚‚ Eâ‚‚} (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (hp : p â‰¤ q) : p.comp f â‰¤ q.comp f :=\n  fun _ => hp _\n\n"}
{"name":"Seminorm.pullback_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nâŠ¢ Eq ((Seminorm.pullback f) p) (p.comp f)","decl":"/-- The composition as an `AddMonoidHom`. -/\n@[simps]\ndef pullback (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) : Seminorm ğ•œâ‚‚ Eâ‚‚ â†’+ Seminorm ğ•œ E where\n  toFun := fun p => p.comp f\n  map_zero' := zero_comp f\n  map_add' := fun p q => add_comp p q f\n\n"}
{"name":"Seminorm.coe_bot","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq (â‡‘Bot.bot) 0","decl":"@[simp]\ntheorem coe_bot : â‡‘(âŠ¥ : Seminorm ğ•œ E) = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.bot_eq_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq Bot.bot 0","decl":"theorem bot_eq_zero : (âŠ¥ : Seminorm ğ•œ E) = 0 :=\n  rfl\n\n"}
{"name":"Seminorm.smul_le_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np q : Seminorm ğ•œ E\na b : NNReal\nhpq : LE.le p q\nhab : LE.le a b\nâŠ¢ LE.le (HSMul.hSMul a p) (HSMul.hSMul b q)","decl":"theorem smul_le_smul {p q : Seminorm ğ•œ E} {a b : â„â‰¥0} (hpq : p â‰¤ q) (hab : a â‰¤ b) :\n    a â€¢ p â‰¤ b â€¢ q := by\n  simp_rw [le_def]\n  intro x\n  exact mul_le_mul hab (hpq x) (apply_nonneg p x) (NNReal.coe_nonneg b)\n\n"}
{"name":"Seminorm.finset_sup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\nâŠ¢ Eq ((s.sup p) x) â†‘(s.sup fun i => âŸ¨(p i) x, â‹¯âŸ©)","decl":"theorem finset_sup_apply (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (x : E) :\n    s.sup p x = â†‘(s.sup fun i => âŸ¨p i x, apply_nonneg (p i) xâŸ© : â„â‰¥0) := by\n  induction' s using Finset.cons_induction_on with a s ha ih\n  Â· rw [Finset.sup_empty, Finset.sup_empty, coe_bot, _root_.bot_eq_zero, Pi.zero_apply]\n    norm_cast\n  Â· rw [Finset.sup_cons, Finset.sup_cons, coe_sup, Pi.sup_apply, NNReal.coe_max, NNReal.coe_mk, ih]\n\n"}
{"name":"Seminorm.exists_apply_eq_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nhs : s.Nonempty\nx : E\nâŠ¢ Exists fun i => And (Membership.mem s i) (Eq ((s.sup p) x) ((p i) x))","decl":"theorem exists_apply_eq_finset_sup (p : Î¹ â†’ Seminorm ğ•œ E) {s : Finset Î¹} (hs : s.Nonempty) (x : E) :\n    âˆƒ i âˆˆ s, s.sup p x = p i x := by\n  rcases Finset.exists_mem_eq_sup s hs (fun i â†¦ (âŸ¨p i x, apply_nonneg _ _âŸ© : â„â‰¥0)) with âŸ¨i, hi, hixâŸ©\n  rw [finset_sup_apply]\n  exact âŸ¨i, hi, congr_arg _ hixâŸ©\n\n"}
{"name":"Seminorm.zero_or_exists_apply_eq_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\nâŠ¢ Or (Eq ((s.sup p) x) 0) (Exists fun i => And (Membership.mem s i) (Eq ((s.sup p) x) ((p i) x)))","decl":"theorem zero_or_exists_apply_eq_finset_sup (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (x : E) :\n    s.sup p x = 0 âˆ¨ âˆƒ i âˆˆ s, s.sup p x = p i x := by\n  rcases Finset.eq_empty_or_nonempty s with (rfl|hs)\n  Â· left; rfl\n  Â· right; exact exists_apply_eq_finset_sup p hs x\n\n"}
{"name":"Seminorm.finset_sup_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nC : NNReal\nâŠ¢ Eq (s.sup (HSMul.hSMul C p)) (HSMul.hSMul C (s.sup p))","decl":"theorem finset_sup_smul (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (C : â„â‰¥0) :\n    s.sup (C â€¢ p) = C â€¢ s.sup p := by\n  ext x\n  rw [smul_apply, finset_sup_apply, finset_sup_apply]\n  symm\n  exact congr_arg ((â†‘) : â„â‰¥0 â†’ â„) (NNReal.mul_finset_sup C s (fun i â†¦ âŸ¨p i x, apply_nonneg _ _âŸ©))\n\n"}
{"name":"Seminorm.finset_sup_le_sum","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nâŠ¢ LE.le (s.sup p) (s.sum fun i => p i)","decl":"theorem finset_sup_le_sum (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) : s.sup p â‰¤ âˆ‘ i âˆˆ s, p i := by\n  classical\n  refine Finset.sup_le_iff.mpr ?_\n  intro i hi\n  rw [Finset.sum_eq_sum_diff_singleton_add hi, le_add_iff_nonneg_left]\n  exact bot_le\n\n"}
{"name":"Seminorm.finset_sup_apply_le","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\na : Real\nha : LE.le 0 a\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ LE.le ((p i) x) a\nâŠ¢ LE.le ((s.sup p) x) a","decl":"theorem finset_sup_apply_le {p : Î¹ â†’ Seminorm ğ•œ E} {s : Finset Î¹} {x : E} {a : â„} (ha : 0 â‰¤ a)\n    (h : âˆ€ i, i âˆˆ s â†’ p i x â‰¤ a) : s.sup p x â‰¤ a := by\n  lift a to â„â‰¥0 using ha\n  rw [finset_sup_apply, NNReal.coe_le_coe]\n  exact Finset.sup_le h\n\n"}
{"name":"Seminorm.le_finset_sup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\ni : Î¹\nhi : Membership.mem s i\nâŠ¢ LE.le ((p i) x) ((s.sup p) x)","decl":"theorem le_finset_sup_apply {p : Î¹ â†’ Seminorm ğ•œ E} {s : Finset Î¹} {x : E} {i : Î¹}\n    (hi : i âˆˆ s) : p i x â‰¤ s.sup p x :=\n  (Finset.le_sup hi : p i â‰¤ s.sup p) x\n\n"}
{"name":"Seminorm.finset_sup_apply_lt","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\na : Real\nha : LT.lt 0 a\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ LT.lt ((p i) x) a\nâŠ¢ LT.lt ((s.sup p) x) a","decl":"theorem finset_sup_apply_lt {p : Î¹ â†’ Seminorm ğ•œ E} {s : Finset Î¹} {x : E} {a : â„} (ha : 0 < a)\n    (h : âˆ€ i, i âˆˆ s â†’ p i x < a) : s.sup p x < a := by\n  lift a to â„â‰¥0 using ha.le\n  rw [finset_sup_apply, NNReal.coe_lt_coe, Finset.sup_lt_iff]\n  Â· exact h\n  Â· exact NNReal.coe_pos.mpr ha\n\n"}
{"name":"Seminorm.norm_sub_map_le_sub","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nx y : E\nâŠ¢ LE.le (Norm.norm (HSub.hSub (p x) (p y))) (p (HSub.hSub x y))","decl":"theorem norm_sub_map_le_sub (p : Seminorm ğ•œ E) (x y : E) : â€–p x - p yâ€– â‰¤ p (x - y) :=\n  abs_sub_map_le_sub p x y\n\n"}
{"name":"Seminorm.comp_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedCommRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nc : ğ•œâ‚‚\nâŠ¢ Eq (p.comp (HSMul.hSMul c f)) (HSMul.hSMul (NNNorm.nnnorm c) (p.comp f))","decl":"theorem comp_smul (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (c : ğ•œâ‚‚) :\n    p.comp (c â€¢ f) = â€–câ€–â‚Š â€¢ p.comp f :=\n  ext fun _ => by\n    rw [comp_apply, smul_apply, LinearMap.smul_apply, map_smul_eq_mul, NNReal.smul_def, coe_nnnorm,\n      smul_eq_mul, comp_apply]\n\n"}
{"name":"Seminorm.comp_smul_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : SeminormedCommRing ğ•œâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœâ´ : RingHomIsometric Ïƒâ‚â‚‚\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œ E\ninstâœ : Module ğ•œâ‚‚ Eâ‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nc : ğ•œâ‚‚\nx : E\nâŠ¢ Eq ((p.comp (HSMul.hSMul c f)) x) (HMul.hMul (Norm.norm c) (p (f x)))","decl":"theorem comp_smul_apply (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (c : ğ•œâ‚‚) (x : E) :\n    p.comp (c â€¢ f) x = â€–câ€– * p (f x) :=\n  map_smul_eq_mul p _ _\n\n"}
{"name":"Seminorm.bddBelow_range_add","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np q : Seminorm ğ•œ E\nx : E\nâŠ¢ BddBelow (Set.range fun u => HAdd.hAdd (p u) (q (HSub.hSub x u)))","decl":"/-- Auxiliary lemma to show that the infimum of seminorms is well-defined. -/\ntheorem bddBelow_range_add : BddBelow (range fun u => p u + q (x - u)) :=\n  âŸ¨0, by\n    rintro _ âŸ¨x, rflâŸ©\n    dsimp; positivityâŸ©\n\n"}
{"name":"Seminorm.inf_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np q : Seminorm ğ•œ E\nx : E\nâŠ¢ Eq ((Min.min p q) x) (iInf fun u => HAdd.hAdd (p u) (q (HSub.hSub x u)))","decl":"@[simp]\ntheorem inf_apply (p q : Seminorm ğ•œ E) (x : E) : (p âŠ“ q) x = â¨… u : E, p u + q (x - u) :=\n  rfl\n\n"}
{"name":"Seminorm.smul_inf","module":"Mathlib.Analysis.Seminorm","initialProofState":"R : Type u_1\nğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : SMul R Real\ninstâœÂ¹ : SMul R NNReal\ninstâœ : IsScalarTower R NNReal Real\nr : R\np q : Seminorm ğ•œ E\nâŠ¢ Eq (HSMul.hSMul r (Min.min p q)) (Min.min (HSMul.hSMul r p) (HSMul.hSMul r q))","decl":"theorem smul_inf [SMul R â„] [SMul R â„â‰¥0] [IsScalarTower R â„â‰¥0 â„] (r : R) (p q : Seminorm ğ•œ E) :\n    r â€¢ (p âŠ“ q) = r â€¢ p âŠ“ r â€¢ q := by\n  ext\n  simp_rw [smul_apply, inf_apply, smul_apply, â† smul_one_smul â„â‰¥0 r (_ : â„), NNReal.smul_def,\n    smul_eq_mul, Real.mul_iInf_of_nonneg (NNReal.coe_nonneg _), mul_add]\n\n"}
{"name":"Seminorm.coe_sSup_eq'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set (Seminorm ğ•œ E)\nhs : BddAbove (Set.image DFunLike.coe s)\nâŠ¢ Eq (â‡‘(SupSet.sSup s)) (iSup fun p => â‡‘â†‘p)","decl":"protected theorem coe_sSup_eq' {s : Set <| Seminorm ğ•œ E}\n    (hs : BddAbove ((â†‘) '' s : Set (E â†’ â„))) : â†‘(sSup s) = â¨† p : s, ((p : Seminorm ğ•œ E) : E â†’ â„) :=\n  congr_arg _ (dif_pos hs)\n\n"}
{"name":"Seminorm.bddAbove_iff","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set (Seminorm ğ•œ E)\nâŠ¢ Iff (BddAbove s) (BddAbove (Set.image DFunLike.coe s))","decl":"protected theorem bddAbove_iff {s : Set <| Seminorm ğ•œ E} :\n    BddAbove s â†” BddAbove ((â†‘) '' s : Set (E â†’ â„)) :=\n  âŸ¨fun âŸ¨q, hqâŸ© => âŸ¨q, forall_mem_image.2 fun _ hp => hq hpâŸ©, fun H =>\n    âŸ¨sSup s, fun p hp x => by\n      dsimp\n      rw [Seminorm.coe_sSup_eq' H, iSup_apply]\n      rcases H with âŸ¨q, hqâŸ©\n      exact\n        le_ciSup âŸ¨q x, forall_mem_range.mpr fun i : s => hq (mem_image_of_mem _ i.2) xâŸ© âŸ¨p, hpâŸ©âŸ©âŸ©\n\n"}
{"name":"Seminorm.bddAbove_range_iff","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nÎ¹ : Sort u_12\np : Î¹ â†’ Seminorm ğ•œ E\nâŠ¢ Iff (BddAbove (Set.range p)) (âˆ€ (x : E), BddAbove (Set.range fun i => (p i) x))","decl":"protected theorem bddAbove_range_iff {Î¹ : Sort*} {p : Î¹ â†’ Seminorm ğ•œ E} :\n    BddAbove (range p) â†” âˆ€ x, BddAbove (range fun i â†¦ p i x) := by\n  rw [Seminorm.bddAbove_iff, â† range_comp, bddAbove_range_pi]; rfl\n\n"}
{"name":"Seminorm.coe_sSup_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set (Seminorm ğ•œ E)\nhs : BddAbove s\nâŠ¢ Eq (â‡‘(SupSet.sSup s)) (iSup fun p => â‡‘â†‘p)","decl":"protected theorem coe_sSup_eq {s : Set <| Seminorm ğ•œ E} (hs : BddAbove s) :\n    â†‘(sSup s) = â¨† p : s, ((p : Seminorm ğ•œ E) : E â†’ â„) :=\n  Seminorm.coe_sSup_eq' (Seminorm.bddAbove_iff.mp hs)\n\n"}
{"name":"Seminorm.coe_iSup_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nÎ¹ : Sort u_12\np : Î¹ â†’ Seminorm ğ•œ E\nhp : BddAbove (Set.range p)\nâŠ¢ Eq (â‡‘(iSup fun i => p i)) (iSup fun i => â‡‘(p i))","decl":"protected theorem coe_iSup_eq {Î¹ : Sort*} {p : Î¹ â†’ Seminorm ğ•œ E} (hp : BddAbove (range p)) :\n    â†‘(â¨† i, p i) = â¨† i, ((p i : Seminorm ğ•œ E) : E â†’ â„) := by\n  rw [â† sSup_range, Seminorm.coe_sSup_eq hp]\n  exact iSup_range' (fun p : Seminorm ğ•œ E => (p : E â†’ â„)) p\n\n"}
{"name":"Seminorm.sSup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\ns : Set (Seminorm ğ•œ E)\nhp : BddAbove s\nx : E\nâŠ¢ Eq ((SupSet.sSup s) x) (iSup fun p => â†‘p x)","decl":"protected theorem sSup_apply {s : Set (Seminorm ğ•œ E)} (hp : BddAbove s) {x : E} :\n    (sSup s) x = â¨† p : s, (p : E â†’ â„) x := by\n  rw [Seminorm.coe_sSup_eq hp, iSup_apply]\n\n"}
{"name":"Seminorm.iSup_apply","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nÎ¹ : Sort u_12\np : Î¹ â†’ Seminorm ğ•œ E\nhp : BddAbove (Set.range p)\nx : E\nâŠ¢ Eq ((iSup fun i => p i) x) (iSup fun i => (p i) x)","decl":"protected theorem iSup_apply {Î¹ : Sort*} {p : Î¹ â†’ Seminorm ğ•œ E}\n    (hp : BddAbove (range p)) {x : E} : (â¨† i, p i) x = â¨† i, p i x := by\n  rw [Seminorm.coe_iSup_eq hp, iSup_apply]\n\n"}
{"name":"Seminorm.sSup_empty","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nâŠ¢ Eq (SupSet.sSup EmptyCollection.emptyCollection) Bot.bot","decl":"protected theorem sSup_empty : sSup (âˆ… : Set (Seminorm ğ•œ E)) = âŠ¥ := by\n  ext\n  rw [Seminorm.sSup_apply bddAbove_empty, Real.iSup_of_isEmpty]\n  rfl\n\n"}
{"name":"Seminorm.mem_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nx y : E\nr : Real\nâŠ¢ Iff (Membership.mem (p.ball x r) y) (LT.lt (p (HSub.hSub y x)) r)","decl":"@[simp]\ntheorem mem_ball : y âˆˆ ball p x r â†” p (y - x) < r :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.mem_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nx y : E\nr : Real\nâŠ¢ Iff (Membership.mem (p.closedBall x r) y) (LE.le (p (HSub.hSub y x)) r)","decl":"@[simp]\ntheorem mem_closedBall : y âˆˆ closedBall p x r â†” p (y - x) â‰¤ r :=\n  Iff.rfl\n\n"}
{"name":"Seminorm.mem_ball_self","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Membership.mem (p.ball x r) x","decl":"theorem mem_ball_self (hr : 0 < r) : x âˆˆ ball p x r := by simp [hr]\n\n"}
{"name":"Seminorm.mem_closedBall_self","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Membership.mem (p.closedBall x r) x","decl":"theorem mem_closedBall_self (hr : 0 â‰¤ r) : x âˆˆ closedBall p x r := by simp [hr]\n\n"}
{"name":"Seminorm.mem_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\ny : E\nr : Real\nâŠ¢ Iff (Membership.mem (p.ball 0 r) y) (LT.lt (p y) r)","decl":"theorem mem_ball_zero : y âˆˆ ball p 0 r â†” p y < r := by rw [mem_ball, sub_zero]\n\n"}
{"name":"Seminorm.mem_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\ny : E\nr : Real\nâŠ¢ Iff (Membership.mem (p.closedBall 0 r) y) (LE.le (p y) r)","decl":"theorem mem_closedBall_zero : y âˆˆ closedBall p 0 r â†” p y â‰¤ r := by rw [mem_closedBall, sub_zero]\n\n"}
{"name":"Seminorm.ball_zero_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Eq (p.ball 0 r) (setOf fun y => LT.lt (p y) r)","decl":"theorem ball_zero_eq : ball p 0 r = { y : E | p y < r } :=\n  Set.ext fun _ => p.mem_ball_zero\n\n"}
{"name":"Seminorm.closedBall_zero_eq","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Eq (p.closedBall 0 r) (setOf fun y => LE.le (p y) r)","decl":"theorem closedBall_zero_eq : closedBall p 0 r = { y : E | p y â‰¤ r } :=\n  Set.ext fun _ => p.mem_closedBall_zero\n\n"}
{"name":"Seminorm.ball_subset_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nâŠ¢ HasSubset.Subset (p.ball x r) (p.closedBall x r)","decl":"theorem ball_subset_closedBall (x r) : ball p x r âŠ† closedBall p x r := fun _ h =>\n  (mem_closedBall _).mpr ((mem_ball _).mp h).le\n\n"}
{"name":"Seminorm.closedBall_eq_biInter_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nâŠ¢ Eq (p.closedBall x r) (Set.iInter fun Ï => Set.iInter fun h => p.ball x Ï)","decl":"theorem closedBall_eq_biInter_ball (x r) : closedBall p x r = â‹‚ Ï > r, ball p x Ï := by\n  ext y; simp_rw [mem_closedBall, mem_iInterâ‚‚, mem_ball, â† forall_lt_iff_le']\n\n"}
{"name":"Seminorm.ball_zero'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nr : Real\nx : E\nhr : LT.lt 0 r\nâŠ¢ Eq (Seminorm.ball 0 x r) Set.univ","decl":"@[simp]\ntheorem ball_zero' (x : E) (hr : 0 < r) : ball (0 : Seminorm ğ•œ E) x r = Set.univ := by\n  rw [Set.eq_univ_iff_forall, ball]\n  simp [hr]\n\n"}
{"name":"Seminorm.closedBall_zero'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nr : Real\nx : E\nhr : LT.lt 0 r\nâŠ¢ Eq (Seminorm.closedBall 0 x r) Set.univ","decl":"@[simp]\ntheorem closedBall_zero' (x : E) (hr : 0 < r) : closedBall (0 : Seminorm ğ•œ E) x r = Set.univ :=\n  eq_univ_of_subset (ball_subset_closedBall _ _ _) (ball_zero' x hr)\n\n"}
{"name":"Seminorm.ball_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nc : NNReal\nhc : LT.lt 0 c\nr : Real\nx : E\nâŠ¢ Eq ((HSMul.hSMul c p).ball x r) (p.ball x (HDiv.hDiv r â†‘c))","decl":"theorem ball_smul (p : Seminorm ğ•œ E) {c : NNReal} (hc : 0 < c) (r : â„) (x : E) :\n    (c â€¢ p).ball x r = p.ball x (r / c) := by\n  ext\n  rw [mem_ball, mem_ball, smul_apply, NNReal.smul_def, smul_eq_mul, mul_comm,\n    lt_div_iffâ‚€ (NNReal.coe_pos.mpr hc)]\n\n"}
{"name":"Seminorm.closedBall_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nc : NNReal\nhc : LT.lt 0 c\nr : Real\nx : E\nâŠ¢ Eq ((HSMul.hSMul c p).closedBall x r) (p.closedBall x (HDiv.hDiv r â†‘c))","decl":"theorem closedBall_smul (p : Seminorm ğ•œ E) {c : NNReal} (hc : 0 < c) (r : â„) (x : E) :\n    (c â€¢ p).closedBall x r = p.closedBall x (r / c) := by\n  ext\n  rw [mem_closedBall, mem_closedBall, smul_apply, NNReal.smul_def, smul_eq_mul, mul_comm,\n    le_div_iffâ‚€ (NNReal.coe_pos.mpr hc)]\n\n"}
{"name":"Seminorm.ball_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\ne : E\nr : Real\nâŠ¢ Eq ((Max.max p q).ball e r) (Inter.inter (p.ball e r) (q.ball e r))","decl":"theorem ball_sup (p : Seminorm ğ•œ E) (q : Seminorm ğ•œ E) (e : E) (r : â„) :\n    ball (p âŠ” q) e r = ball p e r âˆ© ball q e r := by\n  simp_rw [ball, â† Set.setOf_and, coe_sup, Pi.sup_apply, sup_lt_iff]\n\n"}
{"name":"Seminorm.closedBall_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np q : Seminorm ğ•œ E\ne : E\nr : Real\nâŠ¢ Eq ((Max.max p q).closedBall e r) (Inter.inter (p.closedBall e r) (q.closedBall e r))","decl":"theorem closedBall_sup (p : Seminorm ğ•œ E) (q : Seminorm ğ•œ E) (e : E) (r : â„) :\n    closedBall (p âŠ” q) e r = closedBall p e r âˆ© closedBall q e r := by\n  simp_rw [closedBall, â† Set.setOf_and, coe_sup, Pi.sup_apply, sup_le_iff]\n\n"}
{"name":"Seminorm.ball_finset_sup'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nH : s.Nonempty\ne : E\nr : Real\nâŠ¢ Eq ((s.sup' H p).ball e r) (s.inf' H fun i => (p i).ball e r)","decl":"theorem ball_finset_sup' (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (H : s.Nonempty) (e : E) (r : â„) :\n    ball (s.sup' H p) e r = s.inf' H fun i => ball (p i) e r := by\n  induction H using Finset.Nonempty.cons_induction with\n  | singleton => simp\n  | cons _ _ _ hs ih =>\n    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, ball_sup]\n    -- Porting note: `rw` can't use `inf_eq_inter` here, but `simp` can?\n    simp only [inf_eq_inter, ih]\n\n"}
{"name":"Seminorm.closedBall_finset_sup'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nH : s.Nonempty\ne : E\nr : Real\nâŠ¢ Eq ((s.sup' H p).closedBall e r) (s.inf' H fun i => (p i).closedBall e r)","decl":"theorem closedBall_finset_sup' (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (H : s.Nonempty) (e : E)\n    (r : â„) : closedBall (s.sup' H p) e r = s.inf' H fun i => closedBall (p i) e r := by\n  induction H using Finset.Nonempty.cons_induction with\n  | singleton => simp\n  | cons _ _ _ hs ih =>\n    rw [Finset.sup'_cons hs, Finset.inf'_cons hs, closedBall_sup]\n    -- Porting note: `rw` can't use `inf_eq_inter` here, but `simp` can?\n    simp only [inf_eq_inter, ih]\n\n"}
{"name":"Seminorm.ball_mono","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nx : E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nh : LE.le râ‚ râ‚‚\nâŠ¢ HasSubset.Subset (p.ball x râ‚) (p.ball x râ‚‚)","decl":"theorem ball_mono {p : Seminorm ğ•œ E} {râ‚ râ‚‚ : â„} (h : râ‚ â‰¤ râ‚‚) : p.ball x râ‚ âŠ† p.ball x râ‚‚ :=\n  fun _ (hx : _ < _) => hx.trans_le h\n\n"}
{"name":"Seminorm.closedBall_mono","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nx : E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nh : LE.le râ‚ râ‚‚\nâŠ¢ HasSubset.Subset (p.closedBall x râ‚) (p.closedBall x râ‚‚)","decl":"theorem closedBall_mono {p : Seminorm ğ•œ E} {râ‚ râ‚‚ : â„} (h : râ‚ â‰¤ râ‚‚) :\n    p.closedBall x râ‚ âŠ† p.closedBall x râ‚‚ := fun _ (hx : _ â‰¤ _) => hx.trans h\n\n"}
{"name":"Seminorm.ball_antitone","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nx : E\nr : Real\np q : Seminorm ğ•œ E\nh : LE.le q p\nâŠ¢ HasSubset.Subset (p.ball x r) (q.ball x r)","decl":"theorem ball_antitone {p q : Seminorm ğ•œ E} (h : q â‰¤ p) : p.ball x r âŠ† q.ball x r := fun _ =>\n  (h _).trans_lt\n\n"}
{"name":"Seminorm.closedBall_antitone","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nx : E\nr : Real\np q : Seminorm ğ•œ E\nh : LE.le q p\nâŠ¢ HasSubset.Subset (p.closedBall x r) (q.closedBall x r)","decl":"theorem closedBall_antitone {p q : Seminorm ğ•œ E} (h : q â‰¤ p) :\n    p.closedBall x r âŠ† q.closedBall x r := fun _ => (h _).trans\n\n"}
{"name":"Seminorm.ball_add_ball_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nxâ‚ xâ‚‚ : E\nâŠ¢ HasSubset.Subset (HAdd.hAdd (p.ball xâ‚ râ‚) (p.ball xâ‚‚ râ‚‚)) (p.ball (HAdd.hAdd xâ‚ xâ‚‚) (HAdd.hAdd râ‚ râ‚‚))","decl":"theorem ball_add_ball_subset (p : Seminorm ğ•œ E) (râ‚ râ‚‚ : â„) (xâ‚ xâ‚‚ : E) :\n    p.ball (xâ‚ : E) râ‚ + p.ball (xâ‚‚ : E) râ‚‚ âŠ† p.ball (xâ‚ + xâ‚‚) (râ‚ + râ‚‚) := by\n  rintro x âŸ¨yâ‚, hyâ‚, yâ‚‚, hyâ‚‚, rflâŸ©\n  rw [mem_ball, add_sub_add_comm]\n  exact (map_add_le_add p _ _).trans_lt (add_lt_add hyâ‚ hyâ‚‚)\n\n"}
{"name":"Seminorm.closedBall_add_closedBall_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nxâ‚ xâ‚‚ : E\nâŠ¢ HasSubset.Subset (HAdd.hAdd (p.closedBall xâ‚ râ‚) (p.closedBall xâ‚‚ râ‚‚)) (p.closedBall (HAdd.hAdd xâ‚ xâ‚‚) (HAdd.hAdd râ‚ râ‚‚))","decl":"theorem closedBall_add_closedBall_subset (p : Seminorm ğ•œ E) (râ‚ râ‚‚ : â„) (xâ‚ xâ‚‚ : E) :\n    p.closedBall (xâ‚ : E) râ‚ + p.closedBall (xâ‚‚ : E) râ‚‚ âŠ† p.closedBall (xâ‚ + xâ‚‚) (râ‚ + râ‚‚) := by\n  rintro x âŸ¨yâ‚, hyâ‚, yâ‚‚, hyâ‚‚, rflâŸ©\n  rw [mem_closedBall, add_sub_add_comm]\n  exact (map_add_le_add p _ _).trans (add_le_add hyâ‚ hyâ‚‚)\n\n"}
{"name":"Seminorm.sub_mem_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\np : Seminorm ğ•œ E\nxâ‚ xâ‚‚ y : E\nr : Real\nâŠ¢ Iff (Membership.mem (p.ball y r) (HSub.hSub xâ‚ xâ‚‚)) (Membership.mem (p.ball (HAdd.hAdd xâ‚‚ y) r) xâ‚)","decl":"theorem sub_mem_ball (p : Seminorm ğ•œ E) (xâ‚ xâ‚‚ y : E) (r : â„) :\n    xâ‚ - xâ‚‚ âˆˆ p.ball y r â†” xâ‚ âˆˆ p.ball (xâ‚‚ + y) r := by simp_rw [mem_ball, sub_sub]\n\n"}
{"name":"Seminorm.vadd_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nx y : E\nr : Real\np : Seminorm ğ•œ E\nâŠ¢ Eq (HVAdd.hVAdd x (p.ball y r)) (p.ball (HVAdd.hVAdd x y) r)","decl":"/-- The image of a ball under addition with a singleton is another ball. -/\ntheorem vadd_ball (p : Seminorm ğ•œ E) : x +áµ¥ p.ball y r = p.ball (x +áµ¥ y) r :=\n  letI := AddGroupSeminorm.toSeminormedAddCommGroup p.toAddGroupSeminorm\n  Metric.vadd_ball x y r\n\n"}
{"name":"Seminorm.vadd_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : SMul ğ•œ E\nx y : E\nr : Real\np : Seminorm ğ•œ E\nâŠ¢ Eq (HVAdd.hVAdd x (p.closedBall y r)) (p.closedBall (HVAdd.hVAdd x y) r)","decl":"/-- The image of a closed ball under addition with a singleton is another closed ball. -/\ntheorem vadd_closedBall (p : Seminorm ğ•œ E) : x +áµ¥ p.closedBall y r = p.closedBall (x +áµ¥ y) r :=\n  letI := AddGroupSeminorm.toSeminormedAddCommGroup p.toAddGroupSeminorm\n  Metric.vadd_closedBall x y r\n\n"}
{"name":"Seminorm.ball_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : SeminormedRing ğ•œâ‚‚\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Eâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nx : E\nr : Real\nâŠ¢ Eq ((p.comp f).ball x r) (Set.preimage (â‡‘f) (p.ball (f x) r))","decl":"theorem ball_comp (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (x : E) (r : â„) :\n    (p.comp f).ball x r = f â»Â¹' p.ball (f x) r := by\n  ext\n  simp_rw [ball, mem_preimage, comp_apply, Set.mem_setOf_eq, map_sub]\n\n"}
{"name":"Seminorm.closedBall_comp","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nğ•œâ‚‚ : Type u_4\nE : Type u_7\nEâ‚‚ : Type u_8\ninstâœâ¶ : SeminormedRing ğ•œ\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : SeminormedRing ğ•œâ‚‚\ninstâœÂ² : AddCommGroup Eâ‚‚\ninstâœÂ¹ : Module ğ•œâ‚‚ Eâ‚‚\nÏƒâ‚â‚‚ : RingHom ğ•œ ğ•œâ‚‚\ninstâœ : RingHomIsometric Ïƒâ‚â‚‚\np : Seminorm ğ•œâ‚‚ Eâ‚‚\nf : LinearMap Ïƒâ‚â‚‚ E Eâ‚‚\nx : E\nr : Real\nâŠ¢ Eq ((p.comp f).closedBall x r) (Set.preimage (â‡‘f) (p.closedBall (f x) r))","decl":"theorem closedBall_comp (p : Seminorm ğ•œâ‚‚ Eâ‚‚) (f : E â†’â‚›â‚—[Ïƒâ‚â‚‚] Eâ‚‚) (x : E) (r : â„) :\n    (p.comp f).closedBall x r = f â»Â¹' p.closedBall (f x) r := by\n  ext\n  simp_rw [closedBall, mem_preimage, comp_apply, Set.mem_setOf_eq, map_sub]\n\n"}
{"name":"Seminorm.preimage_metric_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Eq (Set.preimage (â‡‘p) (Metric.ball 0 r)) (setOf fun x => LT.lt (p x) r)","decl":"theorem preimage_metric_ball {r : â„} : p â»Â¹' Metric.ball 0 r = { x | p x < r } := by\n  ext x\n  simp only [mem_setOf, mem_preimage, mem_ball_zero_iff, Real.norm_of_nonneg (apply_nonneg p _)]\n\n"}
{"name":"Seminorm.preimage_metric_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Eq (Set.preimage (â‡‘p) (Metric.closedBall 0 r)) (setOf fun x => LE.le (p x) r)","decl":"theorem preimage_metric_closedBall {r : â„} : p â»Â¹' Metric.closedBall 0 r = { x | p x â‰¤ r } := by\n  ext x\n  simp only [mem_setOf, mem_preimage, mem_closedBall_zero_iff,\n    Real.norm_of_nonneg (apply_nonneg p _)]\n\n"}
{"name":"Seminorm.ball_zero_eq_preimage_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Eq (p.ball 0 r) (Set.preimage (â‡‘p) (Metric.ball 0 r))","decl":"theorem ball_zero_eq_preimage_ball {r : â„} : p.ball 0 r = p â»Â¹' Metric.ball 0 r := by\n  rw [ball_zero_eq, preimage_metric_ball]\n\n"}
{"name":"Seminorm.closedBall_zero_eq_preimage_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Eq (p.closedBall 0 r) (Set.preimage (â‡‘p) (Metric.closedBall 0 r))","decl":"theorem closedBall_zero_eq_preimage_closedBall {r : â„} :\n    p.closedBall 0 r = p â»Â¹' Metric.closedBall 0 r := by\n  rw [closedBall_zero_eq, preimage_metric_closedBall]\n\n"}
{"name":"Seminorm.ball_bot","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nr : Real\nx : E\nhr : LT.lt 0 r\nâŠ¢ Eq (Bot.bot.ball x r) Set.univ","decl":"@[simp]\ntheorem ball_bot {r : â„} (x : E) (hr : 0 < r) : ball (âŠ¥ : Seminorm ğ•œ E) x r = Set.univ :=\n  ball_zero' x hr\n\n"}
{"name":"Seminorm.closedBall_bot","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nr : Real\nx : E\nhr : LT.lt 0 r\nâŠ¢ Eq (Bot.bot.closedBall x r) Set.univ","decl":"@[simp]\ntheorem closedBall_bot {r : â„} (x : E) (hr : 0 < r) :\n    closedBall (âŠ¥ : Seminorm ğ•œ E) x r = Set.univ :=\n  closedBall_zero' x hr\n\n"}
{"name":"Seminorm.balanced_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Balanced ğ•œ (p.ball 0 r)","decl":"/-- Seminorm-balls at the origin are balanced. -/\ntheorem balanced_ball_zero (r : â„) : Balanced ğ•œ (ball p 0 r) := by\n  rintro a ha x âŸ¨y, hy, hxâŸ©\n  rw [mem_ball_zero, â† hx, map_smul_eq_mul]\n  calc\n    _ â‰¤ p y := mul_le_of_le_one_left (apply_nonneg p _) ha\n    _ < r := by rwa [mem_ball_zero] at hy\n\n"}
{"name":"Seminorm.balanced_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nâŠ¢ Balanced ğ•œ (p.closedBall 0 r)","decl":"/-- Closed seminorm-balls at the origin are balanced. -/\ntheorem balanced_closedBall_zero (r : â„) : Balanced ğ•œ (closedBall p 0 r) := by\n  rintro a ha x âŸ¨y, hy, hxâŸ©\n  rw [mem_closedBall_zero, â† hx, map_smul_eq_mul]\n  calc\n    _ â‰¤ p y := mul_le_of_le_one_left (apply_nonneg p _) ha\n    _ â‰¤ r := by rwa [mem_closedBall_zero] at hy\n\n"}
{"name":"Seminorm.ball_finset_sup_eq_iInter","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq ((s.sup p).ball x r) (Set.iInter fun i => Set.iInter fun h => (p i).ball x r)","decl":"theorem ball_finset_sup_eq_iInter (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (x : E) {r : â„}\n    (hr : 0 < r) : ball (s.sup p) x r = â‹‚ i âˆˆ s, ball (p i) x r := by\n  lift r to NNReal using hr.le\n  simp_rw [ball, iInter_setOf, finset_sup_apply, NNReal.coe_lt_coe,\n    Finset.sup_lt_iff (show âŠ¥ < r from hr), â† NNReal.coe_lt_coe, NNReal.coe_mk]\n\n"}
{"name":"Seminorm.closedBall_finset_sup_eq_iInter","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq ((s.sup p).closedBall x r) (Set.iInter fun i => Set.iInter fun h => (p i).closedBall x r)","decl":"theorem closedBall_finset_sup_eq_iInter (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (x : E) {r : â„}\n    (hr : 0 â‰¤ r) : closedBall (s.sup p) x r = â‹‚ i âˆˆ s, closedBall (p i) x r := by\n  lift r to NNReal using hr\n  simp_rw [closedBall, iInter_setOf, finset_sup_apply, NNReal.coe_le_coe, Finset.sup_le_iff, â†\n    NNReal.coe_le_coe, NNReal.coe_mk]\n\n"}
{"name":"Seminorm.ball_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq ((s.sup p).ball x r) (s.inf fun i => (p i).ball x r)","decl":"theorem ball_finset_sup (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (x : E) {r : â„} (hr : 0 < r) :\n    ball (s.sup p) x r = s.inf fun i => ball (p i) x r := by\n  rw [Finset.inf_eq_iInf]\n  exact ball_finset_sup_eq_iInter _ _ _ hr\n\n"}
{"name":"Seminorm.closedBall_finset_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nx : E\nr : Real\nhr : LE.le 0 r\nâŠ¢ Eq ((s.sup p).closedBall x r) (s.inf fun i => (p i).closedBall x r)","decl":"theorem closedBall_finset_sup (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹) (x : E) {r : â„} (hr : 0 â‰¤ r) :\n    closedBall (s.sup p) x r = s.inf fun i => closedBall (p i) x r := by\n  rw [Finset.inf_eq_iInf]\n  exact closedBall_finset_sup_eq_iInter _ _ _ hr\n\n"}
{"name":"Seminorm.ball_eq_emptyset","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nhr : LE.le r 0\nâŠ¢ Eq (p.ball x r) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem ball_eq_emptyset (p : Seminorm ğ•œ E) {x : E} {r : â„} (hr : r â‰¤ 0) : p.ball x r = âˆ… := by\n  ext\n  rw [Seminorm.mem_ball, Set.mem_empty_iff_false, iff_false, not_lt]\n  exact hr.trans (apply_nonneg p _)\n\n"}
{"name":"Seminorm.closedBall_eq_emptyset","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nhr : LT.lt r 0\nâŠ¢ Eq (p.closedBall x r) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem closedBall_eq_emptyset (p : Seminorm ğ•œ E) {x : E} {r : â„} (hr : r < 0) :\n    p.closedBall x r = âˆ… := by\n  ext\n  rw [Seminorm.mem_closedBall, Set.mem_empty_iff_false, iff_false, not_le]\n  exact hr.trans_le (apply_nonneg _ _)\n\n"}
{"name":"Seminorm.closedBall_smul_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ : Real\nhrâ‚ : Ne râ‚ 0\nrâ‚‚ : Real\nâŠ¢ HasSubset.Subset (HSMul.hSMul (Metric.closedBall 0 râ‚) (p.ball 0 râ‚‚)) (p.ball 0 (HMul.hMul râ‚ râ‚‚))","decl":"theorem closedBall_smul_ball (p : Seminorm ğ•œ E) {râ‚ : â„} (hrâ‚ : râ‚ â‰  0) (râ‚‚ : â„) :\n    Metric.closedBall (0 : ğ•œ) râ‚ â€¢ p.ball 0 râ‚‚ âŠ† p.ball 0 (râ‚ * râ‚‚) := by\n  simp only [smul_subset_iff, mem_ball_zero, mem_closedBall_zero_iff, map_smul_eq_mul]\n  refine fun a ha b hb â†¦ mul_lt_mul' ha hb (apply_nonneg _ _) ?_\n  exact hrâ‚.lt_or_lt.resolve_left <| ((norm_nonneg a).trans ha).not_lt\n\n"}
{"name":"Seminorm.ball_smul_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nhrâ‚‚ : Ne râ‚‚ 0\nâŠ¢ HasSubset.Subset (HSMul.hSMul (Metric.ball 0 râ‚) (p.closedBall 0 râ‚‚)) (p.ball 0 (HMul.hMul râ‚ râ‚‚))","decl":"theorem ball_smul_closedBall (p : Seminorm ğ•œ E) (râ‚ : â„) {râ‚‚ : â„} (hrâ‚‚ : râ‚‚ â‰  0) :\n    Metric.ball (0 : ğ•œ) râ‚ â€¢ p.closedBall 0 râ‚‚ âŠ† p.ball 0 (râ‚ * râ‚‚) := by\n  simp only [smul_subset_iff, mem_ball_zero, mem_closedBall_zero, mem_ball_zero_iff,\n    map_smul_eq_mul]\n  intro a ha b hb\n  rw [mul_comm, mul_comm râ‚]\n  refine mul_lt_mul' hb ha (norm_nonneg _) (hrâ‚‚.lt_or_lt.resolve_left ?_)\n  exact ((apply_nonneg p b).trans hb).not_lt\n\n"}
{"name":"Seminorm.ball_smul_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nâŠ¢ HasSubset.Subset (HSMul.hSMul (Metric.ball 0 râ‚) (p.ball 0 râ‚‚)) (p.ball 0 (HMul.hMul râ‚ râ‚‚))","decl":"theorem ball_smul_ball (p : Seminorm ğ•œ E) (râ‚ râ‚‚ : â„) :\n    Metric.ball (0 : ğ•œ) râ‚ â€¢ p.ball 0 râ‚‚ âŠ† p.ball 0 (râ‚ * râ‚‚) := by\n  rcases eq_or_ne râ‚‚ 0 with rfl | hrâ‚‚\n  Â· simp\n  Â· exact (smul_subset_smul_left (ball_subset_closedBall _ _ _)).trans\n      (ball_smul_closedBall _ _ hrâ‚‚)\n\n"}
{"name":"Seminorm.closedBall_smul_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nâŠ¢ HasSubset.Subset (HSMul.hSMul (Metric.closedBall 0 râ‚) (p.closedBall 0 râ‚‚)) (p.closedBall 0 (HMul.hMul râ‚ râ‚‚))","decl":"theorem closedBall_smul_closedBall (p : Seminorm ğ•œ E) (râ‚ râ‚‚ : â„) :\n    Metric.closedBall (0 : ğ•œ) râ‚ â€¢ p.closedBall 0 râ‚‚ âŠ† p.closedBall 0 (râ‚ * râ‚‚) := by\n  simp only [smul_subset_iff, mem_closedBall_zero, mem_closedBall_zero_iff, map_smul_eq_mul]\n  intro a ha b hb\n  gcongr\n  exact (norm_nonneg _).trans ha\n\n"}
{"name":"Seminorm.neg_mem_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nx : E\nâŠ¢ Iff (Membership.mem (p.ball 0 r) (Neg.neg x)) (Membership.mem (p.ball 0 r) x)","decl":"theorem neg_mem_ball_zero {r : â„} {x : E} : -x âˆˆ ball p 0 r â†” x âˆˆ ball p 0 r := by\n  simp only [mem_ball_zero, map_neg_eq_map]\n\n"}
{"name":"Seminorm.neg_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : SeminormedRing ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nx : E\nâŠ¢ Eq (Neg.neg (p.ball x r)) (p.ball (Neg.neg x) r)","decl":"@[simp]\ntheorem neg_ball (p : Seminorm ğ•œ E) (r : â„) (x : E) : -ball p x r = ball p (-x) r := by\n  ext\n  rw [Set.mem_neg, mem_ball, mem_ball, â† neg_add', sub_neg_eq_add, map_neg_eq_map]\n\n"}
{"name":"Seminorm.closedBall_iSup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nÎ¹ : Sort u_12\np : Î¹ â†’ Seminorm ğ•œ E\nhp : BddAbove (Set.range p)\ne : E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Eq ((iSup fun i => p i).closedBall e r) (Set.iInter fun i => (p i).closedBall e r)","decl":"theorem closedBall_iSup {Î¹ : Sort*} {p : Î¹ â†’ Seminorm ğ•œ E} (hp : BddAbove (range p)) (e : E)\n    {r : â„} (hr : 0 < r) : closedBall (â¨† i, p i) e r = â‹‚ i, closedBall (p i) e r := by\n  cases isEmpty_or_nonempty Î¹\n  Â· rw [iSup_of_empty', iInter_of_empty, Seminorm.sSup_empty]\n    exact closedBall_bot _ hr\n  Â· ext x\n    have := Seminorm.bddAbove_range_iff.mp hp (x - e)\n    simp only [mem_closedBall, mem_iInter, Seminorm.iSup_apply hp, ciSup_le_iff this]\n\n"}
{"name":"Seminorm.ball_norm_mul_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nk : ğ•œ\nr : Real\nâŠ¢ HasSubset.Subset (p.ball 0 (HMul.hMul (Norm.norm k) r)) (HSMul.hSMul k (p.ball 0 r))","decl":"theorem ball_norm_mul_subset {p : Seminorm ğ•œ E} {k : ğ•œ} {r : â„} :\n    p.ball 0 (â€–kâ€– * r) âŠ† k â€¢ p.ball 0 r := by\n  rcases eq_or_ne k 0 with (rfl | hk)\n  Â· rw [norm_zero, zero_mul, ball_eq_emptyset _ le_rfl]\n    exact empty_subset _\n  Â· intro x\n    rw [Set.mem_smul_set, Seminorm.mem_ball_zero]\n    refine fun hx => âŸ¨kâ»Â¹ â€¢ x, ?_, ?_âŸ©\n    Â· rwa [Seminorm.mem_ball_zero, map_smul_eq_mul, norm_inv, â†\n        mul_lt_mul_left <| norm_pos_iff.mpr hk, â† mul_assoc, â† div_eq_mul_inv â€–kâ€– â€–kâ€–,\n        div_self (ne_of_gt <| norm_pos_iff.mpr hk), one_mul]\n    rw [â† smul_assoc, smul_eq_mul, â† div_eq_mul_inv, div_self hk, one_smul]\n\n"}
{"name":"Seminorm.smul_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nk : ğ•œ\nr : Real\nhk : Ne k 0\nâŠ¢ Eq (HSMul.hSMul k (p.ball 0 r)) (p.ball 0 (HMul.hMul (Norm.norm k) r))","decl":"theorem smul_ball_zero {p : Seminorm ğ•œ E} {k : ğ•œ} {r : â„} (hk : k â‰  0) :\n    k â€¢ p.ball 0 r = p.ball 0 (â€–kâ€– * r) := by\n  ext\n  rw [mem_smul_set_iff_inv_smul_memâ‚€ hk, p.mem_ball_zero, p.mem_ball_zero, map_smul_eq_mul,\n    norm_inv, â† div_eq_inv_mul, div_lt_iffâ‚€ (norm_pos_iff.2 hk), mul_comm]\n\n"}
{"name":"Seminorm.smul_closedBall_subset","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nk : ğ•œ\nr : Real\nâŠ¢ HasSubset.Subset (HSMul.hSMul k (p.closedBall 0 r)) (p.closedBall 0 (HMul.hMul (Norm.norm k) r))","decl":"theorem smul_closedBall_subset {p : Seminorm ğ•œ E} {k : ğ•œ} {r : â„} :\n    k â€¢ p.closedBall 0 r âŠ† p.closedBall 0 (â€–kâ€– * r) := by\n  rintro x âŸ¨y, hy, hâŸ©\n  rw [Seminorm.mem_closedBall_zero, â† h, map_smul_eq_mul]\n  rw [Seminorm.mem_closedBall_zero] at hy\n  gcongr\n\n"}
{"name":"Seminorm.smul_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nk : ğ•œ\nr : Real\nhk : LT.lt 0 (Norm.norm k)\nâŠ¢ Eq (HSMul.hSMul k (p.closedBall 0 r)) (p.closedBall 0 (HMul.hMul (Norm.norm k) r))","decl":"theorem smul_closedBall_zero {p : Seminorm ğ•œ E} {k : ğ•œ} {r : â„} (hk : 0 < â€–kâ€–) :\n    k â€¢ p.closedBall 0 r = p.closedBall 0 (â€–kâ€– * r) := by\n  refine subset_antisymm smul_closedBall_subset ?_\n  intro x\n  rw [Set.mem_smul_set, Seminorm.mem_closedBall_zero]\n  refine fun hx => âŸ¨kâ»Â¹ â€¢ x, ?_, ?_âŸ©\n  Â· rwa [Seminorm.mem_closedBall_zero, map_smul_eq_mul, norm_inv, â† mul_le_mul_left hk, â† mul_assoc,\n      â† div_eq_mul_inv â€–kâ€– â€–kâ€–, div_self (ne_of_gt hk), one_mul]\n  rw [â† smul_assoc, smul_eq_mul, â† div_eq_mul_inv, div_self (norm_pos_iff.mp hk), one_smul]\n\n"}
{"name":"Seminorm.ball_zero_absorbs_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nrâ‚ râ‚‚ : Real\nhrâ‚ : LT.lt 0 râ‚\nâŠ¢ Absorbs ğ•œ (p.ball 0 râ‚) (p.ball 0 râ‚‚)","decl":"theorem ball_zero_absorbs_ball_zero (p : Seminorm ğ•œ E) {râ‚ râ‚‚ : â„} (hrâ‚ : 0 < râ‚) :\n    Absorbs ğ•œ (p.ball 0 râ‚) (p.ball 0 râ‚‚) := by\n  rcases exists_pos_lt_mul hrâ‚ râ‚‚ with âŸ¨r, hrâ‚€, hrâŸ©\n  refine .of_norm âŸ¨r, fun a ha x hx => ?_âŸ©\n  rw [smul_ball_zero (norm_pos_iff.1 <| hrâ‚€.trans_le ha), p.mem_ball_zero]\n  rw [p.mem_ball_zero] at hx\n  exact hx.trans (hr.trans_le <| by gcongr)\n\n"}
{"name":"Seminorm.absorbent_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Absorbent ğ•œ (p.ball 0 r)","decl":"/-- Seminorm-balls at the origin are absorbent. -/\nprotected theorem absorbent_ball_zero (hr : 0 < r) : Absorbent ğ•œ (ball p (0 : E) r) :=\n  absorbent_iff_forall_absorbs_singleton.2 fun _ =>\n    (p.ball_zero_absorbs_ball_zero hr).mono_right <|\n      singleton_subset_iff.2 <| p.mem_ball_zero.2 <| lt_add_one _\n\n"}
{"name":"Seminorm.absorbent_closedBall_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Absorbent ğ•œ (p.closedBall 0 r)","decl":"/-- Closed seminorm-balls at the origin are absorbent. -/\nprotected theorem absorbent_closedBall_zero (hr : 0 < r) : Absorbent ğ•œ (closedBall p (0 : E) r) :=\n  (p.absorbent_ball_zero hr).mono (p.ball_subset_closedBall _ _)\n\n"}
{"name":"Seminorm.absorbent_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nx : E\nhpr : LT.lt (p x) r\nâŠ¢ Absorbent ğ•œ (p.ball x r)","decl":"/-- Seminorm-balls containing the origin are absorbent. -/\nprotected theorem absorbent_ball (hpr : p x < r) : Absorbent ğ•œ (ball p x r) := by\n  refine (p.absorbent_ball_zero <| sub_pos.2 hpr).mono fun y hy => ?_\n  rw [p.mem_ball_zero] at hy\n  exact p.mem_ball.2 ((map_sub_le_add p _ _).trans_lt <| add_lt_of_lt_sub_right hy)\n\n"}
{"name":"Seminorm.absorbent_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nx : E\nhpr : LT.lt (p x) r\nâŠ¢ Absorbent ğ•œ (p.closedBall x r)","decl":"/-- Seminorm-balls containing the origin are absorbent. -/\nprotected theorem absorbent_closedBall (hpr : p x < r) : Absorbent ğ•œ (closedBall p x r) := by\n  refine (p.absorbent_closedBall_zero <| sub_pos.2 hpr).mono fun y hy => ?_\n  rw [p.mem_closedBall_zero] at hy\n  exact p.mem_closedBall.2 ((map_sub_le_add p _ _).trans <| add_le_of_le_sub_right hy)\n\n"}
{"name":"Seminorm.smul_ball_preimage","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\ny : E\nr : Real\na : ğ•œ\nha : Ne a 0\nâŠ¢ Eq (Set.preimage (fun x => HSMul.hSMul a x) (p.ball y r)) (p.ball (HSMul.hSMul (Inv.inv a) y) (HDiv.hDiv r (Norm.norm a)))","decl":"@[simp]\ntheorem smul_ball_preimage (p : Seminorm ğ•œ E) (y : E) (r : â„) (a : ğ•œ) (ha : a â‰  0) :\n    (a â€¢ Â·) â»Â¹' p.ball y r = p.ball (aâ»Â¹ â€¢ y) (r / â€–aâ€–) :=\n  Set.ext fun _ => by\n    rw [mem_preimage, mem_ball, mem_ball, lt_div_iffâ‚€ (norm_pos_iff.mpr ha), mul_comm, â†\n      map_smul_eq_mul p, smul_sub, smul_inv_smulâ‚€ ha]\n\n"}
{"name":"Seminorm.convexOn","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : NormedSpace Real ğ•œ\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : SMul Real E\ninstâœ : IsScalarTower Real ğ•œ E\np : Seminorm ğ•œ E\nâŠ¢ ConvexOn Real Set.univ â‡‘p","decl":"/-- A seminorm is convex. Also see `convexOn_norm`. -/\nprotected theorem convexOn : ConvexOn â„ univ p := by\n  refine âŸ¨convex_univ, fun x _ y _ a b ha hb _ => ?_âŸ©\n  calc\n    p (a â€¢ x + b â€¢ y) â‰¤ p (a â€¢ x) + p (b â€¢ y) := map_add_le_add p _ _\n    _ = â€–a â€¢ (1 : ğ•œ)â€– * p x + â€–b â€¢ (1 : ğ•œ)â€– * p y := by\n      rw [â† map_smul_eq_mul p, â† map_smul_eq_mul p, smul_one_smul, smul_one_smul]\n    _ = a * p x + b * p y := by\n      rw [norm_smul, norm_smul, norm_one, mul_one, mul_one, Real.norm_of_nonneg ha,\n        Real.norm_of_nonneg hb]\n\n"}
{"name":"Seminorm.convex_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : NormedSpace Real ğ•œ\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module Real E\ninstâœ : IsScalarTower Real ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nâŠ¢ Convex Real (p.ball x r)","decl":"/-- Seminorm-balls are convex. -/\ntheorem convex_ball : Convex â„ (ball p x r) := by\n  convert (p.convexOn.translate_left (-x)).convex_lt r\n  ext y\n  rw [preimage_univ, sep_univ, p.mem_ball, sub_eq_add_neg]\n  rfl\n\n"}
{"name":"Seminorm.convex_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : NormedSpace Real ğ•œ\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : Module Real E\ninstâœ : IsScalarTower Real ğ•œ E\np : Seminorm ğ•œ E\nx : E\nr : Real\nâŠ¢ Convex Real (p.closedBall x r)","decl":"/-- Closed seminorm-balls are convex. -/\ntheorem convex_closedBall : Convex â„ (closedBall p x r) := by\n  rw [closedBall_eq_biInter_ball]\n  exact convex_iInterâ‚‚ fun _ _ => convex_ball _ _ _\n\n"}
{"name":"Seminorm.coe_restrictScalars","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nğ•œ' : Type u_12\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : SeminormedRing ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ ğ•œ'\ninstâœâ´ : NormOneClass ğ•œ'\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ' E\ninstâœÂ¹ : SMul ğ•œ E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\np : Seminorm ğ•œ' E\nâŠ¢ Eq â‡‘(Seminorm.restrictScalars ğ•œ p) â‡‘p","decl":"@[simp]\ntheorem coe_restrictScalars (p : Seminorm ğ•œ' E) : (p.restrictScalars ğ•œ : E â†’ â„) = p :=\n  rfl\n\n"}
{"name":"Seminorm.restrictScalars_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nğ•œ' : Type u_12\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : SeminormedRing ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ ğ•œ'\ninstâœâ´ : NormOneClass ğ•œ'\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ' E\ninstâœÂ¹ : SMul ğ•œ E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\np : Seminorm ğ•œ' E\nâŠ¢ Eq (Seminorm.restrictScalars ğ•œ p).ball p.ball","decl":"@[simp]\ntheorem restrictScalars_ball (p : Seminorm ğ•œ' E) : (p.restrictScalars ğ•œ).ball = p.ball :=\n  rfl\n\n"}
{"name":"Seminorm.restrictScalars_closedBall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nğ•œ' : Type u_12\ninstâœâ· : NormedField ğ•œ\ninstâœâ¶ : SeminormedRing ğ•œ'\ninstâœâµ : NormedAlgebra ğ•œ ğ•œ'\ninstâœâ´ : NormOneClass ğ•œ'\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ' E\ninstâœÂ¹ : SMul ğ•œ E\ninstâœ : IsScalarTower ğ•œ ğ•œ' E\np : Seminorm ğ•œ' E\nâŠ¢ Eq (Seminorm.restrictScalars ğ•œ p).closedBall p.closedBall","decl":"@[simp]\ntheorem restrictScalars_closedBall (p : Seminorm ğ•œ' E) :\n    (p.restrictScalars ğ•œ).closedBall = p.closedBall :=\n  rfl\n\n"}
{"name":"Seminorm.continuousAt_zero_of_forall'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœÂ³ : SeminormedRing ğ•\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ• E\ninstâœ : TopologicalSpace E\np : Seminorm ğ• E\nhp : âˆ€ (r : Real), GT.gt r 0 â†’ Membership.mem (nhds 0) (p.closedBall 0 r)\nâŠ¢ ContinuousAt (â‡‘p) 0","decl":"/-- A seminorm is continuous at `0` if `p.closedBall 0 r âˆˆ ğ“ 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuousAt_zero'`. -/\ntheorem continuousAt_zero_of_forall' [TopologicalSpace E] {p : Seminorm ğ• E}\n    (hp : âˆ€ r > 0, p.closedBall 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    ContinuousAt p 0 := by\n  simp_rw [Seminorm.closedBall_zero_eq_preimage_closedBall] at hp\n  rwa [ContinuousAt, Metric.nhds_basis_closedBall.tendsto_right_iff, map_zero]\n\n"}
{"name":"Seminorm.continuousAt_zero'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousConstSMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhp : Membership.mem (nhds 0) (p.closedBall 0 r)\nâŠ¢ ContinuousAt (â‡‘p) 0","decl":"theorem continuousAt_zero' [TopologicalSpace E] [ContinuousConstSMul ğ•œ E] {p : Seminorm ğ•œ E}\n    {r : â„} (hp : p.closedBall 0 r âˆˆ (ğ“ 0 : Filter E)) : ContinuousAt p 0 := by\n  refine continuousAt_zero_of_forall' fun Îµ hÎµ â†¦ ?_\n  obtain âŸ¨k, hkâ‚€, hkâŸ© : âˆƒ k : ğ•œ, 0 < â€–kâ€– âˆ§ â€–kâ€– * r < Îµ := by\n    rcases le_or_lt r 0 with hr | hr\n    Â· use 1; simpa using hr.trans_lt hÎµ\n    Â· simpa [lt_div_iffâ‚€ hr] using exists_norm_lt ğ•œ (div_pos hÎµ hr)\n  rw [â† set_smul_mem_nhds_zero_iff (norm_pos_iff.1 hkâ‚€), smul_closedBall_zero hkâ‚€] at hp\n  exact mem_of_superset hp <| p.closedBall_mono hk.le\n\n"}
{"name":"Seminorm.continuousAt_zero_of_forall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœÂ³ : SeminormedRing ğ•\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ• E\ninstâœ : TopologicalSpace E\np : Seminorm ğ• E\nhp : âˆ€ (r : Real), GT.gt r 0 â†’ Membership.mem (nhds 0) (p.ball 0 r)\nâŠ¢ ContinuousAt (â‡‘p) 0","decl":"/-- A seminorm is continuous at `0` if `p.ball 0 r âˆˆ ğ“ 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuousAt_zero'`. -/\ntheorem continuousAt_zero_of_forall [TopologicalSpace E] {p : Seminorm ğ• E}\n    (hp : âˆ€ r > 0, p.ball 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    ContinuousAt p 0 :=\n  continuousAt_zero_of_forall'\n    (fun r hr â†¦ Filter.mem_of_superset (hp r hr) <| p.ball_subset_closedBall _ _)\n\n"}
{"name":"Seminorm.continuousAt_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâ´ : NontriviallyNormedField ğ•œ\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : ContinuousConstSMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhp : Membership.mem (nhds 0) (p.ball 0 r)\nâŠ¢ ContinuousAt (â‡‘p) 0","decl":"theorem continuousAt_zero [TopologicalSpace E] [ContinuousConstSMul ğ•œ E] {p : Seminorm ğ•œ E} {r : â„}\n    (hp : p.ball 0 r âˆˆ (ğ“ 0 : Filter E)) : ContinuousAt p 0 :=\n  continuousAt_zero' (Filter.mem_of_superset hp <| p.ball_subset_closedBall _ _)\n\n"}
{"name":"Seminorm.uniformContinuous_of_continuousAt_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : UniformSpace E\ninstâœ : UniformAddGroup E\np : Seminorm ğ• E\nhp : ContinuousAt (â‡‘p) 0\nâŠ¢ UniformContinuous â‡‘p","decl":"protected theorem uniformContinuous_of_continuousAt_zero [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm ğ• E} (hp : ContinuousAt p 0) : UniformContinuous p := by\n  have hp : Filter.Tendsto p (ğ“ 0) (ğ“ 0) := map_zero p â–¸ hp\n  rw [UniformContinuous, uniformity_eq_comap_nhds_zero_swapped,\n    Metric.uniformity_eq_comap_nhds_zero, Filter.tendsto_comap_iff]\n  exact\n    tendsto_of_tendsto_of_tendsto_of_le_of_le tendsto_const_nhds (hp.comp Filter.tendsto_comap)\n      (fun xy => dist_nonneg) fun xy => p.norm_sub_map_le_sub _ _\n\n"}
{"name":"Seminorm.continuous_of_continuousAt_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : Seminorm ğ• E\nhp : ContinuousAt (â‡‘p) 0\nâŠ¢ Continuous â‡‘p","decl":"protected theorem continuous_of_continuousAt_zero [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm ğ• E} (hp : ContinuousAt p 0) : Continuous p := by\n  letI := TopologicalAddGroup.toUniformSpace E\n  haveI : UniformAddGroup E := comm_topologicalAddGroup_is_uniform\n  exact (Seminorm.uniformContinuous_of_continuousAt_zero hp).continuous\n\n"}
{"name":"Seminorm.uniformContinuous_of_forall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : UniformSpace E\ninstâœ : UniformAddGroup E\np : Seminorm ğ• E\nhp : âˆ€ (r : Real), GT.gt r 0 â†’ Membership.mem (nhds 0) (p.ball 0 r)\nâŠ¢ UniformContinuous â‡‘p","decl":"/-- A seminorm is uniformly continuous if `p.ball 0 r âˆˆ ğ“ 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.uniformContinuous`. -/\nprotected theorem uniformContinuous_of_forall [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm ğ• E} (hp : âˆ€ r > 0, p.ball 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero_of_forall hp)\n\n"}
{"name":"Seminorm.uniformContinuous","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhp : Membership.mem (nhds 0) (p.ball 0 r)\nâŠ¢ UniformContinuous â‡‘p","decl":"protected theorem uniformContinuous [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul ğ•œ E]\n    {p : Seminorm ğ•œ E} {r : â„} (hp : p.ball 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero hp)\n\n"}
{"name":"Seminorm.uniformContinuous_of_forall'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : UniformSpace E\ninstâœ : UniformAddGroup E\np : Seminorm ğ• E\nhp : âˆ€ (r : Real), GT.gt r 0 â†’ Membership.mem (nhds 0) (p.closedBall 0 r)\nâŠ¢ UniformContinuous â‡‘p","decl":"/-- A seminorm is uniformly continuous if `p.closedBall 0 r âˆˆ ğ“ 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.uniformContinuous'`. -/\nprotected theorem uniformContinuous_of_forall' [UniformSpace E] [UniformAddGroup E]\n    {p : Seminorm ğ• E} (hp : âˆ€ r > 0, p.closedBall 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero_of_forall' hp)\n\n"}
{"name":"Seminorm.uniformContinuous'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhp : Membership.mem (nhds 0) (p.closedBall 0 r)\nâŠ¢ UniformContinuous â‡‘p","decl":"protected theorem uniformContinuous' [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul ğ•œ E]\n    {p : Seminorm ğ•œ E} {r : â„} (hp : p.closedBall 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    UniformContinuous p :=\n  Seminorm.uniformContinuous_of_continuousAt_zero (continuousAt_zero' hp)\n\n"}
{"name":"Seminorm.continuous_of_forall","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : Seminorm ğ• E\nhp : âˆ€ (r : Real), GT.gt r 0 â†’ Membership.mem (nhds 0) (p.ball 0 r)\nâŠ¢ Continuous â‡‘p","decl":"/-- A seminorm is continuous if `p.ball 0 r âˆˆ ğ“ 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuous`. -/\nprotected theorem continuous_of_forall [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm ğ• E} (hp : âˆ€ r > 0, p.ball 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero_of_forall hp)\n\n"}
{"name":"Seminorm.continuous","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhp : Membership.mem (nhds 0) (p.ball 0 r)\nâŠ¢ Continuous â‡‘p","decl":"protected theorem continuous [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousConstSMul ğ•œ E]\n    {p : Seminorm ğ•œ E} {r : â„} (hp : p.ball 0 r âˆˆ (ğ“ 0 : Filter E)) : Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero hp)\n\n"}
{"name":"Seminorm.continuous_of_forall'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np : Seminorm ğ• E\nhp : âˆ€ (r : Real), GT.gt r 0 â†’ Membership.mem (nhds 0) (p.closedBall 0 r)\nâŠ¢ Continuous â‡‘p","decl":"/-- A seminorm is continuous if `p.closedBall 0 r âˆˆ ğ“ 0` for *all* `r > 0`.\nOver a `NontriviallyNormedField` it is actually enough to check that this is true\nfor *some* `r`, see `Seminorm.continuous'`. -/\nprotected theorem continuous_of_forall' [TopologicalSpace E] [TopologicalAddGroup E]\n    {p : Seminorm ğ• E} (hp : âˆ€ r > 0, p.closedBall 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero_of_forall' hp)\n\n"}
{"name":"Seminorm.continuous'","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : TopologicalSpace E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\np : Seminorm ğ•œ E\nr : Real\nhp : Membership.mem (nhds 0) (p.closedBall 0 r)\nâŠ¢ Continuous â‡‘p","decl":"protected theorem continuous' [TopologicalSpace E] [TopologicalAddGroup E] [ContinuousConstSMul ğ•œ E]\n    {p : Seminorm ğ•œ E} {r : â„} (hp : p.closedBall 0 r âˆˆ (ğ“ 0 : Filter E)) :\n    Continuous p :=\n  Seminorm.continuous_of_continuousAt_zero (continuousAt_zero' hp)\n\n"}
{"name":"Seminorm.continuous_of_le","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœâ´ : SeminormedRing ğ•\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module ğ• E\ninstâœÂ¹ : TopologicalSpace E\ninstâœ : TopologicalAddGroup E\np q : Seminorm ğ• E\nhq : Continuous â‡‘q\nhpq : LE.le p q\nâŠ¢ Continuous â‡‘p","decl":"theorem continuous_of_le [TopologicalSpace E] [TopologicalAddGroup E]\n    {p q : Seminorm ğ• E} (hq : Continuous q) (hpq : p â‰¤ q) : Continuous p := by\n  refine Seminorm.continuous_of_forall (fun r hr â†¦ Filter.mem_of_superset\n    (IsOpen.mem_nhds ?_ <| q.mem_ball_self hr) (ball_antitone hpq))\n  rw [ball_zero_eq]\n  exact isOpen_lt hq continuous_const\n\n"}
{"name":"Seminorm.ball_mem_nhds","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ• : Type u_6\nE : Type u_7\ninstâœÂ³ : SeminormedRing ğ•\ninstâœÂ² : AddCommGroup E\ninstâœÂ¹ : Module ğ• E\ninstâœ : TopologicalSpace E\np : Seminorm ğ• E\nhp : Continuous â‡‘p\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Membership.mem (nhds 0) (p.ball 0 r)","decl":"lemma ball_mem_nhds [TopologicalSpace E] {p : Seminorm ğ• E} (hp : Continuous p) {r : â„}\n    (hr : 0 < r) : p.ball 0 r âˆˆ (ğ“ 0 : Filter E) :=\n  have this : Tendsto p (ğ“ 0) (ğ“ 0) := map_zero p â–¸ hp.tendsto 0\n  by simpa only [p.ball_zero_eq] using this (Iio_mem_nhds hr)\n\n"}
{"name":"Seminorm.uniformSpace_eq_of_hasBasis","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\nÎ¹ : Sort u_12\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\np' : Î¹ â†’ Prop\ns : Î¹ â†’ Set E\np : Seminorm ğ•œ E\nhb : (nhds 0).HasBasis p' s\nhâ‚ : Exists fun r => Membership.mem (nhds 0) (p.closedBall 0 r)\nhâ‚‚ : âˆ€ (i : Î¹), p' i â†’ Exists fun r => And (GT.gt r 0) (HasSubset.Subset (p.ball 0 r) (s i))\nâŠ¢ Eq instâœÂ² PseudoMetricSpace.toUniformSpace","decl":"lemma uniformSpace_eq_of_hasBasis\n    {Î¹} [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul ğ•œ E]\n    {p' : Î¹ â†’ Prop} {s : Î¹ â†’ Set E} (p : Seminorm ğ•œ E) (hb : (ğ“ 0 : Filter E).HasBasis p' s)\n    (hâ‚ : âˆƒ r, p.closedBall 0 r âˆˆ ğ“ 0) (hâ‚‚ : âˆ€ i, p' i â†’ âˆƒ r > 0, p.ball 0 r âŠ† s i) :\n    â€¹UniformSpace Eâ€º = p.toAddGroupSeminorm.toSeminormedAddGroup.toUniformSpace := by\n  refine UniformAddGroup.ext â€¹_â€º p.toAddGroupSeminorm.toSeminormedAddCommGroup.to_uniformAddGroup ?_\n  apply le_antisymm\n  Â· rw [â† @comap_norm_nhds_zero E p.toAddGroupSeminorm.toSeminormedAddGroup, â† tendsto_iff_comap]\n    suffices Continuous p from this.tendsto' 0 _ (map_zero p)\n    rcases hâ‚ with âŸ¨r, hrâŸ©\n    exact p.continuous' hr\n  Â· rw [(@NormedAddCommGroup.nhds_zero_basis_norm_lt E\n      p.toAddGroupSeminorm.toSeminormedAddGroup).le_basis_iff hb]\n    simpa only [subset_def, mem_ball_zero] using hâ‚‚\n\n"}
{"name":"Seminorm.uniformity_eq_of_hasBasis","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module ğ•œ E\nÎ¹ : Sort u_12\ninstâœÂ² : UniformSpace E\ninstâœÂ¹ : UniformAddGroup E\ninstâœ : ContinuousConstSMul ğ•œ E\np' : Î¹ â†’ Prop\ns : Î¹ â†’ Set E\np : Seminorm ğ•œ E\nhb : (nhds 0).HasBasis p' s\nhâ‚ : Exists fun r => Membership.mem (nhds 0) (p.closedBall 0 r)\nhâ‚‚ : âˆ€ (i : Î¹), p' i â†’ Exists fun r => And (GT.gt r 0) (HasSubset.Subset (p.ball 0 r) (s i))\nâŠ¢ Eq (uniformity E) (iInf fun r => iInf fun h => Filter.principal (setOf fun x => LT.lt (p (HSub.hSub x.1 x.2)) r))","decl":"lemma uniformity_eq_of_hasBasis\n    {Î¹} [UniformSpace E] [UniformAddGroup E] [ContinuousConstSMul ğ•œ E]\n    {p' : Î¹ â†’ Prop} {s : Î¹ â†’ Set E} (p : Seminorm ğ•œ E) (hb : (ğ“ 0 : Filter E).HasBasis p' s)\n    (hâ‚ : âˆƒ r, p.closedBall 0 r âˆˆ ğ“ 0) (hâ‚‚ : âˆ€ i, p' i â†’ âˆƒ r > 0, p.ball 0 r âŠ† s i) :\n    ğ“¤ E = â¨… r > 0, ğ“Ÿ {x | p (x.1 - x.2) < r} := by\n  rw [uniformSpace_eq_of_hasBasis p hb hâ‚ hâ‚‚]; rfl\n\n"}
{"name":"Seminorm.rescale_to_shell_zpow","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nx : E\nhx : Ne (p x) 0\nâŠ¢ Exists fun n => And (Ne (HPow.hPow c n) 0) (And (LT.lt (p (HSMul.hSMul (HPow.hPow c n) x)) Îµ) (And (LE.le (HDiv.hDiv Îµ (Norm.norm c)) (p (HSMul.hSMul (HPow.hPow c n) x))) (LE.le (Inv.inv (Norm.norm (HPow.hPow c n))) (HMul.hMul (HMul.hMul (Inv.inv Îµ) (Norm.norm c)) (p x)))))","decl":"/-- Let `p` be a seminorm on a vector space over a `NormedField`.\nIf there is a scalar `c` with `â€–câ€–>1`, then any `x` such that `p x â‰  0` can be\nmoved by scalar multiplication to any `p`-shell of width `â€–câ€–`. Also recap information on the\nvalue of `p` on the rescaling element that shows up in applications. -/\nlemma rescale_to_shell_zpow (p : Seminorm ğ•œ E) {c : ğ•œ} (hc : 1 < â€–câ€–) {Îµ : â„}\n    (Îµpos : 0 < Îµ) {x : E} (hx : p x â‰  0) : âˆƒ n : â„¤, c^n â‰  0 âˆ§\n    p (c^n â€¢ x) < Îµ âˆ§ (Îµ / â€–câ€– â‰¤ p (c^n â€¢ x)) âˆ§ (â€–c^nâ€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * p x) := by\n  have xÎµpos : 0 < (p x)/Îµ := by positivity\n  rcases exists_mem_Ico_zpow xÎµpos hc with âŸ¨n, hnâŸ©\n  have cpos : 0 < â€–câ€– := by positivity\n  have cnpos : 0 < â€–c^(n+1)â€– := by rw [norm_zpow]; exact xÎµpos.trans hn.2\n  refine âŸ¨-(n+1), ?_, ?_, ?_, ?_âŸ©\n  Â· show c ^ (-(n + 1)) â‰  0; exact zpow_ne_zero _ (norm_pos_iff.1 cpos)\n  Â· show p ((c ^ (-(n + 1))) â€¢ x) < Îµ\n    rw [map_smul_eq_mul, zpow_neg, norm_inv, â† div_eq_inv_mul, div_lt_iffâ‚€ cnpos, mul_comm,\n        norm_zpow]\n    exact (div_lt_iffâ‚€ Îµpos).1 (hn.2)\n  Â· show Îµ / â€–câ€– â‰¤ p (c ^ (-(n + 1)) â€¢ x)\n    rw [zpow_neg, div_le_iffâ‚€ cpos, map_smul_eq_mul, norm_inv, norm_zpow, zpow_addâ‚€ (ne_of_gt cpos),\n        zpow_one, mul_inv_rev, mul_comm, â† mul_assoc, â† mul_assoc, mul_inv_cancelâ‚€ (ne_of_gt cpos),\n        one_mul, â† div_eq_inv_mul, le_div_iffâ‚€ (zpow_pos cpos _), mul_comm]\n    exact (le_div_iffâ‚€ Îµpos).1 hn.1\n  Â· show â€–(c ^ (-(n + 1)))â€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * p x\n    have : Îµâ»Â¹ * â€–câ€– * p x = Îµâ»Â¹ * p x * â€–câ€– := by ring\n    rw [zpow_neg, norm_inv, inv_inv, norm_zpow, zpow_addâ‚€ (ne_of_gt cpos), zpow_one, this,\n        â† div_eq_inv_mul]\n    exact mul_le_mul_of_nonneg_right hn.1 (norm_nonneg _)\n\n"}
{"name":"Seminorm.rescale_to_shell","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Seminorm ğ•œ E\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nx : E\nhx : Ne (p x) 0\nâŠ¢ Exists fun d => And (Ne d 0) (And (LT.lt (p (HSMul.hSMul d x)) Îµ) (And (LE.le (HDiv.hDiv Îµ (Norm.norm c)) (p (HSMul.hSMul d x))) (LE.le (Inv.inv (Norm.norm d)) (HMul.hMul (HMul.hMul (Inv.inv Îµ) (Norm.norm c)) (p x)))))","decl":"/-- Let `p` be a seminorm on a vector space over a `NormedField`.\nIf there is a scalar `c` with `â€–câ€–>1`, then any `x` such that `p x â‰  0` can be\nmoved by scalar multiplication to any `p`-shell of width `â€–câ€–`. Also recap information on the\nvalue of `p` on the rescaling element that shows up in applications. -/\nlemma rescale_to_shell (p : Seminorm ğ•œ E) {c : ğ•œ} (hc : 1 < â€–câ€–) {Îµ : â„} (Îµpos : 0 < Îµ) {x : E}\n    (hx : p x â‰  0) :\n    âˆƒd : ğ•œ, d â‰  0 âˆ§ p (d â€¢ x) < Îµ âˆ§ (Îµ/â€–câ€– â‰¤ p (d â€¢ x)) âˆ§ (â€–dâ€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * p x) :=\nlet âŸ¨_, hnâŸ© := p.rescale_to_shell_zpow hc Îµpos hx; âŸ¨_, hnâŸ©\n\n"}
{"name":"Seminorm.bound_of_shell","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np q : Seminorm ğ•œ E\nÎµ C : Real\nÎµ_pos : LT.lt 0 Îµ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nhf : âˆ€ (x : E), LE.le (HDiv.hDiv Îµ (Norm.norm c)) (p x) â†’ LT.lt (p x) Îµ â†’ LE.le (q x) (HMul.hMul C (p x))\nx : E\nhx : Ne (p x) 0\nâŠ¢ LE.le (q x) (HMul.hMul C (p x))","decl":"/-- Let `p` and `q` be two seminorms on a vector space over a `NontriviallyNormedField`.\nIf we have `q x â‰¤ C * p x` on some shell of the form `{x | Îµ/â€–câ€– â‰¤ p x < Îµ}` (where `Îµ > 0`\nand `â€–câ€– > 1`), then we also have `q x â‰¤ C * p x` for all `x` such that `p x â‰  0`. -/\nlemma bound_of_shell\n    (p q : Seminorm ğ•œ E) {Îµ C : â„} (Îµ_pos : 0 < Îµ) {c : ğ•œ} (hc : 1 < â€–câ€–)\n    (hf : âˆ€ x, Îµ / â€–câ€– â‰¤ p x â†’ p x < Îµ â†’ q x â‰¤ C * p x) {x : E} (hx : p x â‰  0) :\n    q x â‰¤ C * p x := by\n  rcases p.rescale_to_shell hc Îµ_pos hx with âŸ¨Î´, hÎ´, Î´xle, leÎ´x, -âŸ©\n  simpa only [map_smul_eq_mul, mul_left_comm C, mul_le_mul_left (norm_pos_iff.2 hÎ´)]\n    using hf (Î´ â€¢ x) leÎ´x Î´xle\n\n"}
{"name":"Seminorm.bound_of_shell_smul","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np q : Seminorm ğ•œ E\nÎµ : Real\nC : NNReal\nÎµ_pos : LT.lt 0 Îµ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nhf : âˆ€ (x : E), LE.le (HDiv.hDiv Îµ (Norm.norm c)) (p x) â†’ LT.lt (p x) Îµ â†’ LE.le (q x) ((HSMul.hSMul C p) x)\nx : E\nhx : Ne (p x) 0\nâŠ¢ LE.le (q x) ((HSMul.hSMul C p) x)","decl":"/-- A version of `Seminorm.bound_of_shell` expressed using pointwise scalar multiplication of\nseminorms. -/\nlemma bound_of_shell_smul\n    (p q : Seminorm ğ•œ E) {Îµ : â„} {C : â„â‰¥0} (Îµ_pos : 0 < Îµ) {c : ğ•œ} (hc : 1 < â€–câ€–)\n    (hf : âˆ€ x, Îµ / â€–câ€– â‰¤ p x â†’ p x < Îµ â†’ q x â‰¤ (C â€¢ p) x) {x : E} (hx : p x â‰  0) :\n    q x â‰¤ (C â€¢ p) x :=\n  Seminorm.bound_of_shell p q Îµ_pos hc hf hx\n\n"}
{"name":"Seminorm.bound_of_shell_sup","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\nÎ¹ : Type u_11\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\np : Î¹ â†’ Seminorm ğ•œ E\ns : Finset Î¹\nq : Seminorm ğ•œ E\nÎµ : Real\nC : NNReal\nÎµ_pos : LT.lt 0 Îµ\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nhf : âˆ€ (x : E), (âˆ€ (i : Î¹), Membership.mem s i â†’ LT.lt ((p i) x) Îµ) â†’ âˆ€ (j : Î¹), Membership.mem s j â†’ LE.le (HDiv.hDiv Îµ (Norm.norm c)) ((p j) x) â†’ LE.le (q x) ((HSMul.hSMul C (p j)) x)\nx : E\nhx : Exists fun j => And (Membership.mem s j) (Ne ((p j) x) 0)\nâŠ¢ LE.le (q x) ((HSMul.hSMul C (s.sup p)) x)","decl":"lemma bound_of_shell_sup (p : Î¹ â†’ Seminorm ğ•œ E) (s : Finset Î¹)\n    (q : Seminorm ğ•œ E) {Îµ : â„} {C : â„â‰¥0} (Îµ_pos : 0 < Îµ) {c : ğ•œ} (hc : 1 < â€–câ€–)\n    (hf : âˆ€ x, (âˆ€ i âˆˆ s, p i x < Îµ) â†’ âˆ€ j âˆˆ s, Îµ / â€–câ€– â‰¤ p j x â†’ q x â‰¤ (C â€¢ p j) x)\n    {x : E} (hx : âˆƒ j, j âˆˆ s âˆ§ p j x â‰  0) :\n    q x â‰¤ (C â€¢ s.sup p) x := by\n  rcases hx with âŸ¨j, hj, hjxâŸ©\n  have : (s.sup p) x â‰  0 :=\n    ne_of_gt ((hjx.symm.lt_of_le <| apply_nonneg _ _).trans_le (le_finset_sup_apply hj))\n  refine (s.sup p).bound_of_shell_smul q Îµ_pos hc (fun y hle hlt â†¦ ?_) this\n  rcases exists_apply_eq_finset_sup p âŸ¨j, hjâŸ© y with âŸ¨i, hi, hiyâŸ©\n  rw [smul_apply, hiy]\n  exact hf y (fun k hk â†¦ (le_finset_sup_apply hk).trans_lt hlt) i hi (hiy â–¸ hle)\n\n"}
{"name":"Seminorm.bddAbove_of_absorbent","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NontriviallyNormedField ğ•œ\ninstâœÂ¹ : AddCommGroup E\ninstâœ : Module ğ•œ E\nÎ¹ : Sort u_12\np : Î¹ â†’ Seminorm ğ•œ E\ns : Set E\nhs : Absorbent ğ•œ s\nh : âˆ€ (x : E), Membership.mem s x â†’ BddAbove (Set.range fun x_1 => (p x_1) x)\nâŠ¢ BddAbove (Set.range p)","decl":"/-- Let `p i` be a family of seminorms on `E`. Let `s` be an absorbent set in `ğ•œ`.\nIf all seminorms are uniformly bounded at every point of `s`,\nthen they are bounded in the space of seminorms. -/\nlemma bddAbove_of_absorbent {Î¹ : Sort*} {p : Î¹ â†’ Seminorm ğ•œ E} {s : Set E} (hs : Absorbent ğ•œ s)\n    (h : âˆ€ x âˆˆ s, BddAbove (range (p Â· x))) : BddAbove (range p) := by\n  rw [Seminorm.bddAbove_range_iff]\n  intro x\n  obtain âŸ¨c, hcâ‚€, hcâŸ© : âˆƒ c â‰  0, (c : ğ•œ) â€¢ x âˆˆ s :=\n    (eventually_mem_nhdsWithin.and (hs.eventually_nhdsWithin_zero x)).exists\n  rcases h _ hc with âŸ¨M, hMâŸ©\n  refine âŸ¨M / â€–câ€–, forall_mem_range.mpr fun i â†¦ (le_div_iffâ‚€' (norm_pos_iff.2 hcâ‚€)).2 ?_âŸ©\n  exact hM âŸ¨i, map_smul_eq_mul ..âŸ©\n\n"}
{"name":"coe_normSeminorm","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (â‡‘(normSeminorm ğ•œ E)) Norm.norm","decl":"@[simp]\ntheorem coe_normSeminorm : â‡‘(normSeminorm ğ•œ E) = norm :=\n  rfl\n\n"}
{"name":"ball_normSeminorm","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nâŠ¢ Eq (normSeminorm ğ•œ E).ball Metric.ball","decl":"@[simp]\ntheorem ball_normSeminorm : (normSeminorm ğ•œ E).ball = Metric.ball := by\n  ext x r y\n  simp only [Seminorm.mem_ball, Metric.mem_ball, coe_normSeminorm, dist_eq_norm]\n\n"}
{"name":"absorbent_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nhr : LT.lt 0 r\nâŠ¢ Absorbent ğ•œ (Metric.ball 0 r)","decl":"/-- Balls at the origin are absorbent. -/\ntheorem absorbent_ball_zero (hr : 0 < r) : Absorbent ğ•œ (Metric.ball (0 : E) r) := by\n  rw [â† ball_normSeminorm ğ•œ]\n  exact (normSeminorm _ _).absorbent_ball_zero hr\n\n"}
{"name":"absorbent_ball","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nx : E\nhx : LT.lt (Norm.norm x) r\nâŠ¢ Absorbent ğ•œ (Metric.ball x r)","decl":"/-- Balls containing the origin are absorbent. -/\ntheorem absorbent_ball (hx : â€–xâ€– < r) : Absorbent ğ•œ (Metric.ball x r) := by\n  rw [â† ball_normSeminorm ğ•œ]\n  exact (normSeminorm _ _).absorbent_ball hx\n\n"}
{"name":"balanced_ball_zero","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nr : Real\nâŠ¢ Balanced ğ•œ (Metric.ball 0 r)","decl":"/-- Balls at the origin are balanced. -/\ntheorem balanced_ball_zero : Balanced ğ•œ (Metric.ball (0 : E) r) := by\n  rw [â† ball_normSeminorm ğ•œ]\n  exact (normSeminorm _ _).balanced_ball_zero r\n\n"}
{"name":"rescale_to_shell_semi_normed_zpow","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nx : E\nhx : Ne (Norm.norm x) 0\nâŠ¢ Exists fun n => And (Ne (HPow.hPow c n) 0) (And (LT.lt (Norm.norm (HSMul.hSMul (HPow.hPow c n) x)) Îµ) (And (LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm (HSMul.hSMul (HPow.hPow c n) x))) (LE.le (Inv.inv (Norm.norm (HPow.hPow c n))) (HMul.hMul (HMul.hMul (Inv.inv Îµ) (Norm.norm c)) (Norm.norm x)))))","decl":"/-- If there is a scalar `c` with `â€–câ€–>1`, then any element with nonzero norm can be\nmoved by scalar multiplication to any shell of width `â€–câ€–`. Also recap information on the norm of\nthe rescaling element that shows up in applications. -/\nlemma rescale_to_shell_semi_normed_zpow {c : ğ•œ} (hc : 1 < â€–câ€–) {Îµ : â„} (Îµpos : 0 < Îµ) {x : E}\n    (hx : â€–xâ€– â‰  0) :\n    âˆƒ n : â„¤, c^n â‰  0 âˆ§ â€–c^n â€¢ xâ€– < Îµ âˆ§ (Îµ / â€–câ€– â‰¤ â€–c^n â€¢ xâ€–) âˆ§ (â€–c^nâ€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * â€–xâ€–) :=\n  (normSeminorm ğ•œ E).rescale_to_shell_zpow hc Îµpos hx\n\n"}
{"name":"rescale_to_shell_semi_normed","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nE : Type u_7\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : SeminormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nx : E\nhx : Ne (Norm.norm x) 0\nâŠ¢ Exists fun d => And (Ne d 0) (And (LT.lt (Norm.norm (HSMul.hSMul d x)) Îµ) (And (LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm (HSMul.hSMul d x))) (LE.le (Inv.inv (Norm.norm d)) (HMul.hMul (HMul.hMul (Inv.inv Îµ) (Norm.norm c)) (Norm.norm x)))))","decl":"/-- If there is a scalar `c` with `â€–câ€–>1`, then any element with nonzero norm can be\nmoved by scalar multiplication to any shell of width `â€–câ€–`. Also recap information on the norm of\nthe rescaling element that shows up in applications. -/\nlemma rescale_to_shell_semi_normed {c : ğ•œ} (hc : 1 < â€–câ€–) {Îµ : â„} (Îµpos : 0 < Îµ)\n    {x : E} (hx : â€–xâ€– â‰  0) :\n    âˆƒd : ğ•œ, d â‰  0 âˆ§ â€–d â€¢ xâ€– < Îµ âˆ§ (Îµ/â€–câ€– â‰¤ â€–d â€¢ xâ€–) âˆ§ (â€–dâ€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * â€–xâ€–) :=\n  (normSeminorm ğ•œ E).rescale_to_shell hc Îµpos hx\n\n"}
{"name":"rescale_to_shell_zpow","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nF : Type u_10\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nx : F\nhx : Ne x 0\nâŠ¢ Exists fun n => And (Ne (HPow.hPow c n) 0) (And (LT.lt (Norm.norm (HSMul.hSMul (HPow.hPow c n) x)) Îµ) (And (LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm (HSMul.hSMul (HPow.hPow c n) x))) (LE.le (Inv.inv (Norm.norm (HPow.hPow c n))) (HMul.hMul (HMul.hMul (Inv.inv Îµ) (Norm.norm c)) (Norm.norm x)))))","decl":"lemma rescale_to_shell_zpow [NormedAddCommGroup F] [NormedSpace ğ•œ F] {c : ğ•œ} (hc : 1 < â€–câ€–)\n    {Îµ : â„} (Îµpos : 0 < Îµ) {x : F} (hx : x â‰  0) :\n    âˆƒ n : â„¤, c^n â‰  0 âˆ§ â€–c^n â€¢ xâ€– < Îµ âˆ§ (Îµ / â€–câ€– â‰¤ â€–c^n â€¢ xâ€–) âˆ§ (â€–c^nâ€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * â€–xâ€–) :=\n  rescale_to_shell_semi_normed_zpow hc Îµpos (norm_ne_zero_iff.mpr hx)\n\n"}
{"name":"rescale_to_shell","module":"Mathlib.Analysis.Seminorm","initialProofState":"ğ•œ : Type u_3\nF : Type u_10\ninstâœÂ² : NormedField ğ•œ\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nc : ğ•œ\nhc : LT.lt 1 (Norm.norm c)\nÎµ : Real\nÎµpos : LT.lt 0 Îµ\nx : F\nhx : Ne x 0\nâŠ¢ Exists fun d => And (Ne d 0) (And (LT.lt (Norm.norm (HSMul.hSMul d x)) Îµ) (And (LE.le (HDiv.hDiv Îµ (Norm.norm c)) (Norm.norm (HSMul.hSMul d x))) (LE.le (Inv.inv (Norm.norm d)) (HMul.hMul (HMul.hMul (Inv.inv Îµ) (Norm.norm c)) (Norm.norm x)))))","decl":"/-- If there is a scalar `c` with `â€–câ€–>1`, then any element can be moved by scalar multiplication to\nany shell of width `â€–câ€–`. Also recap information on the norm of the rescaling element that shows\nup in applications. -/\nlemma rescale_to_shell [NormedAddCommGroup F] [NormedSpace ğ•œ F] {c : ğ•œ} (hc : 1 < â€–câ€–)\n    {Îµ : â„} (Îµpos : 0 < Îµ) {x : F} (hx : x â‰  0) :\n    âˆƒd : ğ•œ, d â‰  0 âˆ§ â€–d â€¢ xâ€– < Îµ âˆ§ (Îµ/â€–câ€– â‰¤ â€–d â€¢ xâ€–) âˆ§ (â€–dâ€–â»Â¹ â‰¤ Îµâ»Â¹ * â€–câ€– * â€–xâ€–) :=\n  rescale_to_shell_semi_normed hc Îµpos (norm_ne_zero_iff.mpr hx)\n\n"}
