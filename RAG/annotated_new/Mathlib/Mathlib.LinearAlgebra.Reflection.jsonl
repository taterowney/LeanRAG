{"name":"Module.preReflection_apply","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\ny : M\n⊢ Eq ((Module.preReflection x f) y) (HSub.hSub y (HSMul.hSMul (f y) x))","decl":"lemma preReflection_apply :\n    preReflection x f y = y - (f y) • x := by\n  simp [preReflection]\n\n"}
{"name":"Module.preReflection_apply_self","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nh : Eq (f x) 2\n⊢ Eq ((Module.preReflection x f) x) (Neg.neg x)","decl":"lemma preReflection_apply_self (h : f x = 2) :\n    preReflection x f x = - x := by\n  rw [preReflection_apply, h, two_smul]; abel\n\n"}
{"name":"Module.involutive_preReflection","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nh : Eq (f x) 2\n⊢ Function.Involutive ⇑(Module.preReflection x f)","decl":"lemma involutive_preReflection (h : f x = 2) :\n    Involutive (preReflection x f) :=\n  fun y ↦ by simp [map_sub, h, smul_sub, two_smul, preReflection_apply]\n\n"}
{"name":"Module.preReflection_preReflection","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\ny : M\ng : Module.Dual R M\nh : Eq (f x) 2\n⊢ Eq (Module.preReflection ((Module.preReflection x f) y) ((Module.preReflection f ((Module.Dual.eval R M) x)) g)) (LinearMap.comp (Module.preReflection x f) (LinearMap.comp (Module.preReflection y g) (Module.preReflection x f)))","decl":"lemma preReflection_preReflection (g : Dual R M) (h : f x = 2) :\n    preReflection (preReflection x f y) (preReflection f (Dual.eval R M x) g) =\n    (preReflection x f) ∘ₗ (preReflection y g) ∘ₗ (preReflection x f) := by\n  ext m\n  simp only [h, preReflection_apply, mul_comm (g x) (f m), mul_two, mul_assoc, Dual.eval_apply,\n    LinearMap.sub_apply, LinearMap.coe_comp, LinearMap.smul_apply, smul_eq_mul, smul_sub, sub_smul,\n    smul_smul, sub_mul, comp_apply, map_sub, map_smul, add_smul]\n  abel\n\n"}
{"name":"Module.reflection_apply","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\ny : M\nh : Eq (f x) 2\n⊢ Eq ((Module.reflection h) y) (HSub.hSub y (HSMul.hSMul (f y) x))","decl":"lemma reflection_apply (h : f x = 2) :\n    reflection h y = y - (f y) • x :=\n  preReflection_apply x f y\n\n"}
{"name":"Module.reflection_apply_self","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nh : Eq (f x) 2\n⊢ Eq ((Module.reflection h) x) (Neg.neg x)","decl":"@[simp]\nlemma reflection_apply_self (h : f x = 2) :\n    reflection h x = - x :=\n  preReflection_apply_self h\n\n"}
{"name":"Module.involutive_reflection","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nh : Eq (f x) 2\n⊢ Function.Involutive ⇑(Module.reflection h)","decl":"lemma involutive_reflection (h : f x = 2) :\n    Involutive (reflection h) :=\n  involutive_preReflection h\n\n"}
{"name":"Module.reflection_inv","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nh : Eq (f x) 2\n⊢ Eq (Inv.inv (Module.reflection h)) (Module.reflection h)","decl":"@[simp]\nlemma reflection_inv (h : f x = 2) : (reflection h)⁻¹ = reflection h := rfl\n\n"}
{"name":"Module.reflection_symm","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nh : Eq (f x) 2\n⊢ Eq (Module.reflection h).symm (Module.reflection h)","decl":"@[simp]\nlemma reflection_symm (h : f x = 2) :\n    (reflection h).symm = reflection h :=\n  rfl\n\n"}
{"name":"Module.invOn_reflection_of_mapsTo","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nΦ : Set M\nh : Eq (f x) 2\n⊢ Set.InvOn (⇑(Module.reflection h)) (⇑(Module.reflection h)) Φ Φ","decl":"lemma invOn_reflection_of_mapsTo {Φ : Set M} (h : f x = 2) :\n    InvOn (reflection h) (reflection h) Φ Φ :=\n  ⟨fun x _ ↦ involutive_reflection h x, fun x _ ↦ involutive_reflection h x⟩\n\n"}
{"name":"Module.bijOn_reflection_of_mapsTo","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\nΦ : Set M\nh : Eq (f x) 2\nh' : Set.MapsTo (⇑(Module.reflection h)) Φ Φ\n⊢ Set.BijOn (⇑(Module.reflection h)) Φ Φ","decl":"lemma bijOn_reflection_of_mapsTo {Φ : Set M} (h : f x = 2) (h' : MapsTo (reflection h) Φ Φ) :\n    BijOn (reflection h) Φ Φ :=\n  (invOn_reflection_of_mapsTo h).bijOn h' h'\n\n"}
{"name":"Module.reflection_mul_reflection_pow_apply","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Nat\nz : M\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq ((HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m) z) (HAdd.hAdd (HAdd.hAdd z (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 2) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 1) 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 3) 2))))) (HSub.hSub (HSMul.hSMul (HSub.hSub (HMul.hMul (g x) (f z)) (g z)) y) (HSMul.hSMul (f z) x)))) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 1) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (↑m) 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 2) 2))))) (HSub.hSub (HSMul.hSMul (HSub.hSub (HMul.hMul (f y) (g z)) (f z)) x) (HSMul.hSMul (g z) y))))","decl":"/-- A formula for $(r_1 r_2)^m z$, where $m$ is a natural number and $z \\in M$. -/\nlemma reflection_mul_reflection_pow_apply (m : ℕ) (z : M)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    ((reflection hf * reflection hg) ^ m) z =\n      z +\n        ((S R ((m - 2) / 2)).eval t * ((S R ((m - 1) / 2)).eval t + (S R ((m - 3) / 2)).eval t)) •\n          ((g x * f z - g z) • y - f z • x) +\n        ((S R ((m - 1) / 2)).eval t * ((S R (m / 2)).eval t + (S R ((m - 2) / 2)).eval t)) •\n          ((f y * g z - f z) • x - g z • y) := by\n  induction m with\n  | zero => simp\n  | succ m ih =>\n    /- Now, let us collect two facts about the evaluations of `S r k`. These easily follow from the\n    properties of the `S` polynomials. -/\n    have S_eval_t_sub_two (k : ℤ) :\n        (S R (k - 2)).eval t = t * (S R (k - 1)).eval t - (S R k).eval t := by\n      simp [S_sub_two]\n    have S_eval_t_sq_add_S_eval_t_sq (k : ℤ) :\n        (S R k).eval t ^ 2 + (S R (k + 1)).eval t ^ 2 - t * (S R k).eval t * (S R (k + 1)).eval t\n        = 1 := by\n      simpa using congr_arg (Polynomial.eval t) (S_sq_add_S_sq R k)\n    -- Apply the inductive hypothesis.\n    rw [pow_succ', LinearEquiv.mul_apply, ih, LinearEquiv.mul_apply]\n    -- Expand out all the reflections and use `hf`, `hg`.\n    simp only [reflection_apply, map_add, map_sub, map_smul, hf, hg]\n    -- `m` can be written in the form `2 * k + e`, where `e` is `0` or `1`.\n    push_cast\n    rw [← Int.ediv_add_emod m 2]\n    set k : ℤ := m / 2\n    set e : ℤ := m % 2\n    simp_rw [add_assoc (2 * k), add_sub_assoc (2 * k), add_comm (2 * k),\n      add_mul_ediv_left _ k (by norm_num : (2 : ℤ) ≠ 0)]\n    have he : e = 0 ∨ e = 1 := by omega\n    clear_value e\n    /- Now, equate the coefficients on both sides. These linear combinations were\n    found using `polyrith`. -/\n    match_scalars\n    · rfl\n    · linear_combination (norm := skip) (-g z * f y * (S R (e - 1 + k)).eval t +\n          f z * (S R (e - 1 + k)).eval t) * S_eval_t_sub_two (e + k) +\n          (-g z * f y + f z) * S_eval_t_sq_add_S_eval_t_sq (k - 1)\n      subst ht\n      obtain rfl | rfl : e = 0 ∨ e = 1 := he <;> ring_nf\n    · linear_combination (norm := skip)\n          g z * (S R (e - 1 + k)).eval t * S_eval_t_sub_two (e + k) +\n          g z * S_eval_t_sq_add_S_eval_t_sq (k - 1)\n      subst ht\n      obtain rfl | rfl : e = 0 ∨ e = 1 := he <;> ring_nf\n\n"}
{"name":"Module.reflection_mul_reflection_pow","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Nat\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq (↑(HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m)) (HAdd.hAdd (HAdd.hAdd LinearMap.id (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 2) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 1) 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 3) 2))))) (HSub.hSub (LinearMap.smulRight (HSub.hSub (HSMul.hSMul (g x) f) g) y) (LinearMap.smulRight f x)))) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 1) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (↑m) 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub (↑m) 2) 2))))) (HSub.hSub (LinearMap.smulRight (HSub.hSub (HSMul.hSMul (f y) g) f) x) (LinearMap.smulRight g y))))","decl":"/-- A formula for $(r_1 r_2)^m$, where $m$ is a natural number. -/\nlemma reflection_mul_reflection_pow (m : ℕ)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    ((reflection hf * reflection hg) ^ m).toLinearMap =\n      LinearMap.id (R := R) (M := M) +\n        ((S R ((m - 2) / 2)).eval t * ((S R ((m - 1) / 2)).eval t + (S R ((m - 3) / 2)).eval t)) •\n          ((g x • f - g).smulRight y - f.smulRight x) +\n        ((S R ((m - 1) / 2)).eval t * ((S R (m / 2)).eval t + (S R ((m - 2) / 2)).eval t)) •\n          ((f y • g - f).smulRight x - g.smulRight y) := by\n  ext z\n  simpa using reflection_mul_reflection_pow_apply hf hg m z t ht\n\n"}
{"name":"Module.reflection_mul_reflection_zpow_apply","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Int\nz : M\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq ((HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m) z) (HAdd.hAdd (HAdd.hAdd z (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 2) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 1) 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 3) 2))))) (HSub.hSub (HSMul.hSMul (HSub.hSub (HMul.hMul (g x) (f z)) (g z)) y) (HSMul.hSMul (f z) x)))) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 1) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv m 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 2) 2))))) (HSub.hSub (HSMul.hSMul (HSub.hSub (HMul.hMul (f y) (g z)) (f z)) x) (HSMul.hSMul (g z) y))))","decl":"/-- A formula for $(r_1 r_2)^m z$, where $m$ is an integer and $z \\in M$. -/\nlemma reflection_mul_reflection_zpow_apply (m : ℤ) (z : M)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    ((reflection hf * reflection hg) ^ m) z =\n      z +\n        ((S R ((m - 2) / 2)).eval t * ((S R ((m - 1) / 2)).eval t + (S R ((m - 3) / 2)).eval t)) •\n          ((g x * f z - g z) • y - f z • x) +\n        ((S R ((m - 1) / 2)).eval t * ((S R (m / 2)).eval t + (S R ((m - 2) / 2)).eval t)) •\n          ((f y * g z - f z) • x - g z • y) := by\n  induction m using Int.negInduction with\n  | nat m => exact_mod_cast reflection_mul_reflection_pow_apply hf hg m z t ht\n  | neg _ m =>\n    have ht' : t = g x * f y - 2 := by rwa [mul_comm (g x)]\n    rw [zpow_neg, ← inv_zpow, mul_inv_rev, reflection_inv, reflection_inv, zpow_natCast,\n      reflection_mul_reflection_pow_apply hg hf m z t ht', add_right_comm z]\n    have aux (a b : ℤ) (hab : a + b = -3 := by omega) : a / 2 = -(b / 2) - 2 := by omega\n    rw [aux (-m - 3) m, aux (-m - 2) (m - 1), aux (-m - 1) (m - 2), aux (-m) (m - 3)]\n    simp only [S_neg_sub_two, Polynomial.eval_neg]\n    ring_nf\n\n"}
{"name":"Module.reflection_mul_reflection_zpow","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Int\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq (↑(HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m)) (HAdd.hAdd (HAdd.hAdd LinearMap.id (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 2) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 1) 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 3) 2))))) (HSub.hSub (LinearMap.smulRight (HSub.hSub (HSMul.hSMul (g x) f) g) y) (LinearMap.smulRight f x)))) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 1) 2))) (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv m 2))) (Polynomial.eval t (Polynomial.Chebyshev.S R (HDiv.hDiv (HSub.hSub m 2) 2))))) (HSub.hSub (LinearMap.smulRight (HSub.hSub (HSMul.hSMul (f y) g) f) x) (LinearMap.smulRight g y))))","decl":"/-- A formula for $(r_1 r_2)^m$, where $m$ is an integer. -/\nlemma reflection_mul_reflection_zpow (m : ℤ)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    ((reflection hf * reflection hg) ^ m).toLinearMap =\n      LinearMap.id (R := R) (M := M) +\n        ((S R ((m - 2) / 2)).eval t * ((S R ((m - 1) / 2)).eval t + (S R ((m - 3) / 2)).eval t)) •\n          ((g x • f - g).smulRight y - f.smulRight x) +\n        ((S R ((m - 1) / 2)).eval t * ((S R (m / 2)).eval t + (S R ((m - 2) / 2)).eval t)) •\n          ((f y • g - f).smulRight x - g.smulRight y) := by\n  ext z\n  simpa using reflection_mul_reflection_zpow_apply hf hg m z t ht\n\n"}
{"name":"Module.reflection_mul_reflection_zpow_apply_self","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Int\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq ((HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m) x) (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R m)) (Polynomial.eval t (Polynomial.Chebyshev.S R (HSub.hSub m 1)))) x) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HSub.hSub m 1))) (Neg.neg (g x))) y))","decl":"/-- A formula for $(r_1 r_2)^m x$, where $m$ is an integer. This is the special case of\n`Module.reflection_mul_reflection_zpow_apply` with $z = x$. -/\nlemma reflection_mul_reflection_zpow_apply_self (m : ℤ)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    ((reflection hf * reflection hg) ^ m) x =\n      ((S R m).eval t + (S R (m - 1)).eval t) • x + ((S R (m - 1)).eval t * -g x) • y := by\n  /- Even though this is a special case of `Module.reflection_mul_reflection_zpow_apply`, it is\n  easier to prove it from scratch. -/\n  have S_eval_t_sub_two (k : ℤ) :\n      (S R (k - 2)).eval t = (f y * g x - 2) * (S R (k - 1)).eval t - (S R k).eval t := by\n    simp [S_sub_two, ht]\n  induction m using Int.induction_on with\n  | hz => simp\n  | hp m ih =>\n    -- Apply the inductive hypothesis.\n    rw [add_comm (m : ℤ) 1, zpow_one_add, LinearEquiv.mul_apply, LinearEquiv.mul_apply, ih]\n    -- Expand out all the reflections and use `hf`, `hg`.\n    simp only [reflection_apply, map_add, map_sub, map_smul, hf, hg]\n    -- Equate coefficients of `x` and `y`.\n    match_scalars\n    · linear_combination (norm := ring_nf) -S_eval_t_sub_two (m + 1)\n    · ring_nf\n  | hn m ih =>\n    -- Apply the inductive hypothesis.\n    rw [sub_eq_add_neg (-m : ℤ) 1, add_comm (-m : ℤ) (-1), zpow_add, zpow_neg_one, mul_inv_rev,\n      reflection_inv, reflection_inv, LinearEquiv.mul_apply, LinearEquiv.mul_apply, ih]\n    -- Expand out all the reflections and use `hf`, `hg`.\n    simp only [reflection_apply, map_add, map_sub, map_smul, hf, hg]\n    -- Equate coefficients of `x` and `y`.\n    match_scalars\n    · linear_combination (norm := ring_nf) -S_eval_t_sub_two (-m)\n    · linear_combination (norm := ring_nf) g x * S_eval_t_sub_two (-m)\n\n"}
{"name":"Module.reflection_mul_reflection_pow_apply_self","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Nat\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq ((HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m) x) (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R ↑m)) (Polynomial.eval t (Polynomial.Chebyshev.S R (HSub.hSub (↑m) 1)))) x) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R (HSub.hSub (↑m) 1))) (Neg.neg (g x))) y))","decl":"/-- A formula for $(r_1 r_2)^m x$, where $m$ is a natural number. This is the special case of\n`Module.reflection_mul_reflection_pow_apply` with $z = x$. -/\nlemma reflection_mul_reflection_pow_apply_self (m : ℕ)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    ((reflection hf * reflection hg) ^ m) x =\n      ((S R m).eval t + (S R (m - 1)).eval t) • x + ((S R (m - 1)).eval t * -g x) • y :=\n  mod_cast reflection_mul_reflection_zpow_apply_self hf hg m t ht\n\n"}
{"name":"Module.reflection_mul_reflection_mul_reflection_zpow_apply_self","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Int\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq ((HMul.hMul (Module.reflection hg) (HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m)) x) (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R m)) (Polynomial.eval t (Polynomial.Chebyshev.S R (HSub.hSub m 1)))) x) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R m)) (Neg.neg (g x))) y))","decl":"/-- A formula for $r_2 (r_1 r_2)^m x$, where $m$ is an integer. -/\nlemma reflection_mul_reflection_mul_reflection_zpow_apply_self (m : ℤ)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    (reflection hg * (reflection hf * reflection hg) ^ m) x =\n      ((S R m).eval t + (S R (m - 1)).eval t) • x + ((S R m).eval t * -g x) • y := by\n  rw [LinearEquiv.mul_apply, reflection_mul_reflection_zpow_apply_self hf hg m t ht]\n  -- Expand out all the reflections and use `hf`, `hg`.\n  simp only [reflection_apply, map_add, map_sub, map_smul, hf, hg]\n  -- Equate coefficients of `x` and `y`.\n  module\n\n"}
{"name":"Module.reflection_mul_reflection_mul_reflection_pow_apply_self","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx y : M\nf g : Module.Dual R M\nhf : Eq (f x) 2\nhg : Eq (g y) 2\nm : Nat\nt : optParam R (HSub.hSub (HMul.hMul (f y) (g x)) 2)\nht : autoParam (Eq t (HSub.hSub (HMul.hMul (f y) (g x)) 2)) _auto✝\n⊢ Eq ((HMul.hMul (Module.reflection hg) (HPow.hPow (HMul.hMul (Module.reflection hf) (Module.reflection hg)) m)) x) (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd (Polynomial.eval t (Polynomial.Chebyshev.S R ↑m)) (Polynomial.eval t (Polynomial.Chebyshev.S R (HSub.hSub (↑m) 1)))) x) (HSMul.hSMul (HMul.hMul (Polynomial.eval t (Polynomial.Chebyshev.S R ↑m)) (Neg.neg (g x))) y))","decl":"/-- A formula for $r_2 (r_1 r_2)^m x$, where $m$ is a natural number. -/\nlemma reflection_mul_reflection_mul_reflection_pow_apply_self (m : ℕ)\n    (t : R := f y * g x - 2) (ht : t = f y * g x - 2 := by rfl) :\n    (reflection hg * (reflection hf * reflection hg) ^ m) x =\n      ((S R m).eval t + (S R (m - 1)).eval t) • x + ((S R m).eval t * -g x) • y :=\n  mod_cast reflection_mul_reflection_mul_reflection_zpow_apply_self hf hg m t ht\n\n"}
{"name":"Module.Dual.eq_of_preReflection_mapsTo","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nx : M\nΦ : Set M\nhΦ₁ : Φ.Finite\nhΦ₂ : Eq (Submodule.span R Φ) Top.top\nf g : Module.Dual R M\nhf₁ : Eq (f x) 2\nhf₂ : Set.MapsTo (⇑(Module.preReflection x f)) Φ Φ\nhg₁ : Eq (g x) 2\nhg₂ : Set.MapsTo (⇑(Module.preReflection x g)) Φ Φ\n⊢ Eq f g","decl":"/-- See also `Module.Dual.eq_of_preReflection_mapsTo'` for a variant of this lemma which\napplies when `Φ` does not span.\n\nThis rather technical-looking lemma exists because it is exactly what is needed to establish various\nuniqueness results for root data / systems. One might regard this lemma as lying at the boundary of\nlinear algebra and combinatorics since the finiteness assumption is the key. -/\nlemma Dual.eq_of_preReflection_mapsTo [CharZero R] [NoZeroSMulDivisors R M]\n    {x : M} {Φ : Set M} (hΦ₁ : Φ.Finite) (hΦ₂ : span R Φ = ⊤) {f g : Dual R M}\n    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)\n    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :\n    f = g := by\n  have hx : x ≠ 0 := by rintro rfl; simp at hf₁\n  let u := reflection hg₁ * reflection hf₁\n  have hu : u = LinearMap.id (R := R) (M := M) + (f - g).smulRight x := by\n    ext y\n    simp only [u, reflection_apply, hg₁, two_smul, LinearEquiv.coe_toLinearMap_mul,\n      LinearMap.id_coe, LinearEquiv.coe_coe, LinearMap.mul_apply, LinearMap.add_apply, id_eq,\n      LinearMap.coe_smulRight, LinearMap.sub_apply, map_sub, map_smul, sub_add_cancel_left,\n      smul_neg, sub_neg_eq_add, sub_smul]\n    abel\n  replace hu : ∀ (n : ℕ),\n      ↑(u ^ n) = LinearMap.id (R := R) (M := M) + (n : R) • (f - g).smulRight x := by\n    intros n\n    induction n with\n    | zero => simp\n    | succ n ih =>\n      have : ((f - g).smulRight x).comp ((n : R) • (f - g).smulRight x) = 0 := by\n        ext; simp [hf₁, hg₁]\n      rw [pow_succ', LinearEquiv.coe_toLinearMap_mul, ih, hu, add_mul, mul_add, mul_add]\n      simp_rw [LinearMap.mul_eq_comp, LinearMap.comp_id, LinearMap.id_comp, this, add_zero,\n        add_assoc, Nat.cast_succ, add_smul, one_smul]\n  suffices IsOfFinOrder u by\n    obtain ⟨n, hn₀, hn₁⟩ := isOfFinOrder_iff_pow_eq_one.mp this\n    replace hn₁ : (↑(u ^ n) : M →ₗ[R] M) = LinearMap.id := LinearEquiv.toLinearMap_inj.mpr hn₁\n    simpa [hn₁, hn₀.ne', hx, sub_eq_zero] using hu n\n  exact u.isOfFinOrder_of_finite_of_span_eq_top_of_mapsTo hΦ₁ hΦ₂ (hg₂.comp hf₂)\n\n"}
{"name":"Module.Dual.eq_of_preReflection_mapsTo'","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : CommRing R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : CharZero R\ninst✝ : NoZeroSMulDivisors R M\nx : M\nΦ : Set M\nhΦ₁ : Φ.Finite\nhx : Membership.mem (Submodule.span R Φ) x\nf g : Module.Dual R M\nhf₁ : Eq (f x) 2\nhf₂ : Set.MapsTo (⇑(Module.preReflection x f)) Φ Φ\nhg₁ : Eq (g x) 2\nhg₂ : Set.MapsTo (⇑(Module.preReflection x g)) Φ Φ\n⊢ Eq ((Submodule.span R Φ).subtype.dualMap f) ((Submodule.span R Φ).subtype.dualMap g)","decl":"/-- This rather technical-looking lemma exists because it is exactly what is needed to establish a\nuniqueness result for root data. See the doc string of `Module.Dual.eq_of_preReflection_mapsTo` for\nfurther remarks. -/\nlemma Dual.eq_of_preReflection_mapsTo' [CharZero R] [NoZeroSMulDivisors R M]\n    {x : M} {Φ : Set M} (hΦ₁ : Φ.Finite) (hx : x ∈ span R Φ) {f g : Dual R M}\n    (hf₁ : f x = 2) (hf₂ : MapsTo (preReflection x f) Φ Φ)\n    (hg₁ : g x = 2) (hg₂ : MapsTo (preReflection x g) Φ Φ) :\n    (span R Φ).subtype.dualMap f = (span R Φ).subtype.dualMap g := by\n  set Φ' : Set (span R Φ) := range (inclusion <| Submodule.subset_span (R := R) (s := Φ))\n  rw [← finite_coe_iff] at hΦ₁\n  have hΦ'₁ : Φ'.Finite := finite_range (inclusion Submodule.subset_span)\n  have hΦ'₂ : span R Φ' = ⊤ := by\n    simp only [Φ']\n    rw [range_inclusion]\n    simp\n  let x' : span R Φ := ⟨x, hx⟩\n  have this : ∀ {F : Dual R M}, MapsTo (preReflection x F) Φ Φ →\n      MapsTo (preReflection x' ((span R Φ).subtype.dualMap F)) Φ' Φ' := by\n    intro F hF ⟨y, hy⟩ hy'\n    simp only [Φ'] at hy' ⊢\n    rw [range_inclusion] at hy'\n    simp only [SetLike.coe_sort_coe, mem_setOf_eq] at hy' ⊢\n    rw [range_inclusion]\n    exact hF hy'\n  exact eq_of_preReflection_mapsTo hΦ'₁ hΦ'₂ hf₁ (this hf₂) hg₁ (this hg₂)\n\n"}
{"name":"Module.reflection_reflection_iterate","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : CommRing R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx : M\nf : Module.Dual R M\ny : M\ng : Module.Dual R M\nhfx : Eq (f x) 2\nhgy : Eq (g y) 2\nhgxfy : Eq (HMul.hMul (f y) (g x)) 4\nn : Nat\n⊢ Eq (Nat.iterate (⇑((Module.reflection hgy).trans (Module.reflection hfx))) n y) (HAdd.hAdd y (HSMul.hSMul n (HSub.hSub (HSMul.hSMul (f y) x) (HSMul.hSMul 2 y))))","decl":"/-- Composite of reflections in \"parallel\" hyperplanes is a shear (special case). -/\nlemma reflection_reflection_iterate\n    (hfx : f x = 2) (hgy : g y = 2) (hgxfy : f y * g x = 4) (n : ℕ) :\n    ((reflection hgy).trans (reflection hfx))^[n] y = y + n • (f y • x - (2 : R) • y) := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    have hz : ∀ z : M, f y • g x • z = 2 • 2 • z := by\n      intro z\n      rw [smul_smul, hgxfy, smul_smul, ← Nat.cast_smul_eq_nsmul R (2 * 2), show 2 * 2 = 4 from rfl,\n        Nat.cast_ofNat]\n    simp only [iterate_succ', comp_apply, ih, two_smul, smul_sub, smul_add, map_add,\n      LinearEquiv.trans_apply, reflection_apply_self, map_neg, reflection_apply, neg_sub, map_sub,\n      map_nsmul, map_smul, smul_neg, hz, add_smul]\n    abel\n\n"}
{"name":"Module.infinite_range_reflection_reflection_iterate_iff","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nx : M\nf : Module.Dual R M\ny : M\ng : Module.Dual R M\ninst✝ : NoZeroSMulDivisors Int M\nhfx : Eq (f x) 2\nhgy : Eq (g y) 2\nhgxfy : Eq (HMul.hMul (f y) (g x)) 4\n⊢ Iff (Set.range fun n => Nat.iterate (⇑((Module.reflection hgy).trans (Module.reflection hfx))) n y).Infinite (Ne (HSMul.hSMul (f y) x) (HSMul.hSMul 2 y))","decl":"lemma infinite_range_reflection_reflection_iterate_iff [NoZeroSMulDivisors ℤ M]\n    (hfx : f x = 2) (hgy : g y = 2) (hgxfy : f y * g x = 4) :\n    (range <| fun n ↦ ((reflection hgy).trans (reflection hfx))^[n] y).Infinite ↔\n    f y • x ≠ (2 : R) • y := by\n  simp only [reflection_reflection_iterate hfx hgy hgxfy, infinite_range_add_nsmul_iff, sub_ne_zero]\n\n"}
{"name":"Module.eq_of_mapsTo_reflection_of_mem","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nx : M\nf : Module.Dual R M\ny : M\ng : Module.Dual R M\ninst✝ : NoZeroSMulDivisors Int M\nΦ : Set M\nhΦ : Φ.Finite\nhfx : Eq (f x) 2\nhgy : Eq (g y) 2\nhgx : Eq (g x) 2\nhfy : Eq (f y) 2\nhxfΦ : Set.MapsTo (⇑(Module.preReflection x f)) Φ Φ\nhygΦ : Set.MapsTo (⇑(Module.preReflection y g)) Φ Φ\nhyΦ : Membership.mem Φ y\n⊢ Eq x y","decl":"lemma eq_of_mapsTo_reflection_of_mem [NoZeroSMulDivisors ℤ M] {Φ : Set M} (hΦ : Φ.Finite)\n    (hfx : f x = 2) (hgy : g y = 2) (hgx : g x = 2) (hfy : f y = 2)\n    (hxfΦ : MapsTo (preReflection x f) Φ Φ)\n    (hygΦ : MapsTo (preReflection y g) Φ Φ)\n    (hyΦ : y ∈ Φ) :\n    x = y := by\n  suffices h : f y • x = (2 : R) • y by\n    rw [hfy, two_smul R x, two_smul R y, ← two_zsmul, ← two_zsmul] at h\n    exact smul_right_injective _ two_ne_zero h\n  rw [← not_infinite] at hΦ\n  contrapose! hΦ\n  apply ((infinite_range_reflection_reflection_iterate_iff hfx hgy\n    (by rw [hfy, hgx]; norm_cast)).mpr hΦ).mono\n  rw [range_subset_iff]\n  intro n\n  rw [← IsFixedPt.image_iterate ((bijOn_reflection_of_mapsTo hfx hxfΦ).comp\n    (bijOn_reflection_of_mapsTo hgy hygΦ)).image_eq n]\n  exact mem_image_of_mem _ hyΦ\n\n"}
{"name":"Module.injOn_dualMap_subtype_span_range_range","module":"Mathlib.LinearAlgebra.Reflection","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nι : Type u_3\ninst✝ : NoZeroSMulDivisors Int M\nr : Function.Embedding ι M\nc : ι → Module.Dual R M\nhfin : (Set.range ⇑r).Finite\nh_two : ∀ (i : ι), Eq ((c i) (r i)) 2\nh_mapsTo : ∀ (i : ι), Set.MapsTo (⇑(Module.preReflection (r i) (c i))) (Set.range ⇑r) (Set.range ⇑r)\n⊢ Set.InjOn (⇑(Submodule.span R (Set.range ⇑r)).subtype.dualMap) (Set.range c)","decl":"lemma injOn_dualMap_subtype_span_range_range {ι : Type*} [NoZeroSMulDivisors ℤ M]\n    {r : ι ↪ M} {c : ι → Dual R M} (hfin : (range r).Finite)\n    (h_two : ∀ i, c i (r i) = 2)\n    (h_mapsTo : ∀ i, MapsTo (preReflection (r i) (c i)) (range r) (range r)) :\n    InjOn (span R (range r)).subtype.dualMap (range c) := by\n  rintro - ⟨i, rfl⟩ - ⟨j, rfl⟩ hij\n  congr\n  suffices ∀ k, c i (r k) = c j (r k) by\n    rw [← EmbeddingLike.apply_eq_iff_eq r]\n    exact eq_of_mapsTo_reflection_of_mem (f := c i) (g := c j) hfin (h_two i) (h_two j)\n      (by rw [← this, h_two]) (by rw [this, h_two]) (h_mapsTo i) (h_mapsTo j) (mem_range_self j)\n  intro k\n  simpa using LinearMap.congr_fun hij ⟨r k, Submodule.subset_span (mem_range_self k)⟩\n\n"}
