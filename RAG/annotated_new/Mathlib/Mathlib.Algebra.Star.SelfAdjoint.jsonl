{"name":"IsStarNormal.star_comm_self","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : Star R\nx : R\nself : IsStarNormal x\n⊢ Commute (Star.star x) x","decl":"/-- An element of a star monoid is normal if it commutes with its adjoint. -/\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  /-- A normal element of a star monoid commutes with its adjoint. -/\n  star_comm_self : Commute (star x) x\n\n"}
{"name":"isStarNormal_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : Star R\nx : R\n⊢ Iff (IsStarNormal x) (Commute (Star.star x) x)","decl":"/-- An element of a star monoid is normal if it commutes with its adjoint. -/\n@[mk_iff]\nclass IsStarNormal [Mul R] [Star R] (x : R) : Prop where\n  /-- A normal element of a star monoid commutes with its adjoint. -/\n  star_comm_self : Commute (star x) x\n\n"}
{"name":"star_comm_self'","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Mul R\ninst✝¹ : Star R\nx : R\ninst✝ : IsStarNormal x\n⊢ Eq (HMul.hMul (Star.star x) x) (HMul.hMul x (Star.star x))","decl":"theorem star_comm_self' [Mul R] [Star R] (x : R) [IsStarNormal x] : star x * x = x * star x :=\n  IsStarNormal.star_comm_self\n\n"}
{"name":"IsSelfAdjoint.all","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Star R\ninst✝ : TrivialStar R\nr : R\n⊢ IsSelfAdjoint r","decl":"/-- All elements are self-adjoint when `star` is trivial. -/\ntheorem all [Star R] [TrivialStar R] (r : R) : IsSelfAdjoint r :=\n  star_trivial _\n\n"}
{"name":"IsSelfAdjoint.star_eq","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝ : Star R\nx : R\nhx : IsSelfAdjoint x\n⊢ Eq (Star.star x) x","decl":"theorem star_eq [Star R] {x : R} (hx : IsSelfAdjoint x) : star x = x :=\n  hx\n\n"}
{"name":"isSelfAdjoint_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝ : Star R\nx : R\n⊢ Iff (IsSelfAdjoint x) (Eq (Star.star x) x)","decl":"theorem _root_.isSelfAdjoint_iff [Star R] {x : R} : IsSelfAdjoint x ↔ star x = x :=\n  Iff.rfl\n\n"}
{"name":"IsSelfAdjoint.star_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝ : InvolutiveStar R\nx : R\n⊢ Iff (IsSelfAdjoint (Star.star x)) (IsSelfAdjoint x)","decl":"@[simp]\ntheorem star_iff [InvolutiveStar R] {x : R} : IsSelfAdjoint (star x) ↔ IsSelfAdjoint x := by\n  simpa only [IsSelfAdjoint, star_star] using eq_comm\n\n"}
{"name":"IsSelfAdjoint.star_mul_self","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\n⊢ IsSelfAdjoint (HMul.hMul (Star.star x) x)","decl":"@[simp]\ntheorem star_mul_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (star x * x) := by\n  simp only [IsSelfAdjoint, star_mul, star_star]\n\n"}
{"name":"IsSelfAdjoint.mul_star_self","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx : R\n⊢ IsSelfAdjoint (HMul.hMul x (Star.star x))","decl":"@[simp]\ntheorem mul_star_self [Mul R] [StarMul R] (x : R) : IsSelfAdjoint (x * star x) := by\n  simpa only [star_star] using star_mul_self (star x)\n\n"}
{"name":"IsSelfAdjoint.commute_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_3\ninst✝¹ : Mul R\ninst✝ : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n⊢ Iff (Commute x y) (IsSelfAdjoint (HMul.hMul x y))","decl":"/-- Self-adjoint elements commute if and only if their product is self-adjoint. -/\nlemma commute_iff {R : Type*} [Mul R] [StarMul R] {x y : R}\n    (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : Commute x y ↔ IsSelfAdjoint (x * y) := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rw [isSelfAdjoint_iff, star_mul, hx.star_eq, hy.star_eq, h.eq]\n  · simpa only [star_mul, hx.star_eq, hy.star_eq] using h.symm\n\n"}
{"name":"IsSelfAdjoint.map","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝³ : Star R\ninst✝² : Star S\ninst✝¹ : FunLike F R S\ninst✝ : StarHomClass F R S\nx : R\nhx : IsSelfAdjoint x\nf : F\n⊢ IsSelfAdjoint (f x)","decl":"/-- Functions in a `StarHomClass` preserve self-adjoint elements. -/\n@[aesop 10% apply]\ntheorem map {F R S : Type*} [Star R] [Star S] [FunLike F R S] [StarHomClass F R S]\n    {x : R} (hx : IsSelfAdjoint x) (f : F) : IsSelfAdjoint (f x) :=\n  show star (f x) = f x from map_star f x ▸ congr_arg f hx\n\n"}
{"name":"IsSelfAdjoint.starHom_apply","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝³ : Star R\ninst✝² : Star S\ninst✝¹ : FunLike F R S\ninst✝ : StarHomClass F R S\nx : R\nhx : IsSelfAdjoint x\nf : F\n⊢ IsSelfAdjoint (f x)","decl":"@[deprecated (since := \"2024-09-07\")] alias starHom_apply := map\n\n/- note: this lemma is *not* marked as `simp` so that Lean doesn't look for a `[TrivialStar R]`\ninstance every time it sees `⊢ IsSelfAdjoint (f x)`, which will likely occur relatively often. -/\n"}
{"name":"isSelfAdjoint_map","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝⁴ : Star R\ninst✝³ : Star S\ninst✝² : FunLike F R S\ninst✝¹ : StarHomClass F R S\ninst✝ : TrivialStar R\nf : F\nx : R\n⊢ IsSelfAdjoint (f x)","decl":"theorem _root_.isSelfAdjoint_map {F R S : Type*} [Star R] [Star S] [FunLike F R S]\n    [StarHomClass F R S] [TrivialStar R] (f : F) (x : R) : IsSelfAdjoint (f x) :=\n  (IsSelfAdjoint.all x).map f\n\n"}
{"name":"isSelfAdjoint_starHom_apply","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝⁴ : Star R\ninst✝³ : Star S\ninst✝² : FunLike F R S\ninst✝¹ : StarHomClass F R S\ninst✝ : TrivialStar R\nf : F\nx : R\n⊢ IsSelfAdjoint (f x)","decl":"@[deprecated (since := \"2024-09-07\")] alias _root_.isSelfAdjoint_starHom_apply := isSelfAdjoint_map\n\n"}
{"name":"IsSelfAdjoint.zero","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\n⊢ IsSelfAdjoint 0","decl":"@[simp] protected theorem zero : IsSelfAdjoint (0 : R) := star_zero R\n\n"}
{"name":"IsSelfAdjoint.add","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddMonoid R\ninst✝ : StarAddMonoid R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n⊢ IsSelfAdjoint (HAdd.hAdd x y)","decl":"@[aesop 90% apply]\ntheorem add {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x + y) := by\n  simp only [isSelfAdjoint_iff, star_add, hx.star_eq, hy.star_eq]\n\n"}
{"name":"IsSelfAdjoint.neg","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nx : R\nhx : IsSelfAdjoint x\n⊢ IsSelfAdjoint (Neg.neg x)","decl":"@[aesop safe apply]\ntheorem neg {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint (-x) := by\n  simp only [isSelfAdjoint_iff, star_neg, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.sub","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n⊢ IsSelfAdjoint (HSub.hSub x y)","decl":"@[aesop 90% apply]\ntheorem sub {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x - y) := by\n  simp only [isSelfAdjoint_iff, star_sub, hx.star_eq, hy.star_eq]\n\n"}
{"name":"IsSelfAdjoint.add_star_self","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : StarAddMonoid R\nx : R\n⊢ IsSelfAdjoint (HAdd.hAdd x (Star.star x))","decl":"@[simp]\ntheorem add_star_self (x : R) : IsSelfAdjoint (x + star x) := by\n  simp only [isSelfAdjoint_iff, add_comm, star_add, star_star]\n\n"}
{"name":"IsSelfAdjoint.star_add_self","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddCommMonoid R\ninst✝ : StarAddMonoid R\nx : R\n⊢ IsSelfAdjoint (HAdd.hAdd (Star.star x) x)","decl":"@[simp]\ntheorem star_add_self (x : R) : IsSelfAdjoint (star x + x) := by\n  simp only [isSelfAdjoint_iff, add_comm, star_add, star_star]\n\n"}
{"name":"IsSelfAdjoint.conjugate","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semigroup R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\nz : R\n⊢ IsSelfAdjoint (HMul.hMul (HMul.hMul z x) (Star.star z))","decl":"@[aesop safe apply]\ntheorem conjugate {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (z * x * star z) := by\n  simp only [isSelfAdjoint_iff, star_mul, star_star, mul_assoc, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.conjugate'","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semigroup R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\nz : R\n⊢ IsSelfAdjoint (HMul.hMul (HMul.hMul (Star.star z) x) z)","decl":"@[aesop safe apply]\ntheorem conjugate' {x : R} (hx : IsSelfAdjoint x) (z : R) : IsSelfAdjoint (star z * x * z) := by\n  simp only [isSelfAdjoint_iff, star_mul, star_star, mul_assoc, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.conjugate_self","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semigroup R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\nz : R\nhz : IsSelfAdjoint z\n⊢ IsSelfAdjoint (HMul.hMul (HMul.hMul z x) z)","decl":"@[aesop 90% apply]\ntheorem conjugate_self {x : R} (hx : IsSelfAdjoint x) {z : R} (hz : IsSelfAdjoint z) :\n    IsSelfAdjoint (z * x * z) := by nth_rewrite 2 [← hz]; exact conjugate hx z\n\n"}
{"name":"IsSelfAdjoint.isStarNormal","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semigroup R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\n⊢ IsStarNormal x","decl":"@[aesop 10% apply]\ntheorem isStarNormal {x : R} (hx : IsSelfAdjoint x) : IsStarNormal x :=\n  ⟨by simp only [Commute, SemiconjBy, hx.star_eq]⟩\n\n"}
{"name":"IsSelfAdjoint.one","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : MulOneClass R\ninst✝ : StarMul R\n⊢ IsSelfAdjoint 1","decl":"@[simp] protected theorem one : IsSelfAdjoint (1 : R) :=\n  star_one R\n\n"}
{"name":"IsSelfAdjoint.pow","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Monoid R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\nn : Nat\n⊢ IsSelfAdjoint (HPow.hPow x n)","decl":"@[aesop safe apply]\ntheorem pow {x : R} (hx : IsSelfAdjoint x) (n : ℕ) : IsSelfAdjoint (x ^ n) := by\n  simp only [isSelfAdjoint_iff, star_pow, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.natCast","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : StarRing R\nn : Nat\n⊢ IsSelfAdjoint ↑n","decl":"@[simp]\nprotected theorem natCast (n : ℕ) : IsSelfAdjoint (n : R) :=\n  star_natCast _\n\n"}
{"name":"IsSelfAdjoint.ofNat","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Semiring R\ninst✝¹ : StarRing R\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ IsSelfAdjoint (OfNat.ofNat n)","decl":"@[simp]\nprotected theorem ofNat (n : ℕ) [n.AtLeastTwo] : IsSelfAdjoint (ofNat(n) : R) :=\n  .natCast n\n\n"}
{"name":"IsSelfAdjoint.mul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : CommSemigroup R\ninst✝ : StarMul R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n⊢ IsSelfAdjoint (HMul.hMul x y)","decl":"theorem mul {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x * y) := by\n  simp only [isSelfAdjoint_iff, star_mul', hx.star_eq, hy.star_eq]\n\n"}
{"name":"IsSelfAdjoint.conj_eq","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"α : Type u_3\ninst✝¹ : CommSemiring α\ninst✝ : StarRing α\na : α\nha : IsSelfAdjoint a\n⊢ Eq ((starRingEnd α) a) a","decl":"lemma conj_eq (ha : IsSelfAdjoint a) : conj a = a := ha.star_eq\n\n"}
{"name":"IsSelfAdjoint.intCast","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\nz : Int\n⊢ IsSelfAdjoint ↑z","decl":"@[simp]\nprotected theorem intCast (z : ℤ) : IsSelfAdjoint (z : R) :=\n  star_intCast _\n\n"}
{"name":"IsSelfAdjoint.inv","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Group R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\n⊢ IsSelfAdjoint (Inv.inv x)","decl":"@[aesop safe apply]\ntheorem inv {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint x⁻¹ := by\n  simp only [isSelfAdjoint_iff, star_inv, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.zpow","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Group R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\nn : Int\n⊢ IsSelfAdjoint (HPow.hPow x n)","decl":"@[aesop safe apply]\ntheorem zpow {x : R} (hx : IsSelfAdjoint x) (n : ℤ) : IsSelfAdjoint (x ^ n) := by\n  simp only [isSelfAdjoint_iff, star_zpow, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.inv₀","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : GroupWithZero R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\n⊢ IsSelfAdjoint (Inv.inv x)","decl":"@[aesop safe apply]\ntheorem inv₀ {x : R} (hx : IsSelfAdjoint x) : IsSelfAdjoint x⁻¹ := by\n  simp only [isSelfAdjoint_iff, star_inv₀, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.zpow₀","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : GroupWithZero R\ninst✝ : StarMul R\nx : R\nhx : IsSelfAdjoint x\nn : Int\n⊢ IsSelfAdjoint (HPow.hPow x n)","decl":"@[aesop safe apply]\ntheorem zpow₀ {x : R} (hx : IsSelfAdjoint x) (n : ℤ) : IsSelfAdjoint (x ^ n) := by\n  simp only [isSelfAdjoint_iff, star_zpow₀, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.nnratCast","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : DivisionSemiring R\ninst✝ : StarRing R\nq : NNRat\n⊢ IsSelfAdjoint ↑q","decl":"@[simp]\nprotected lemma nnratCast [DivisionSemiring R] [StarRing R] (q : ℚ≥0) :\n    IsSelfAdjoint (q : R) :=\n  star_nnratCast _\n\n"}
{"name":"IsSelfAdjoint.ratCast","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : DivisionRing R\ninst✝ : StarRing R\nx : Rat\n⊢ IsSelfAdjoint ↑x","decl":"@[simp]\nprotected theorem ratCast (x : ℚ) : IsSelfAdjoint (x : R) :=\n  star_ratCast _\n\n"}
{"name":"IsSelfAdjoint.div","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semifield R\ninst✝ : StarRing R\nx y : R\nhx : IsSelfAdjoint x\nhy : IsSelfAdjoint y\n⊢ IsSelfAdjoint (HDiv.hDiv x y)","decl":"theorem div {x y : R} (hx : IsSelfAdjoint x) (hy : IsSelfAdjoint y) : IsSelfAdjoint (x / y) := by\n  simp only [isSelfAdjoint_iff, star_div₀, hx.star_eq, hy.star_eq]\n\n"}
{"name":"IsSelfAdjoint.smul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : Star R\ninst✝³ : AddMonoid A\ninst✝² : StarAddMonoid A\ninst✝¹ : SMul R A\ninst✝ : StarModule R A\nr : R\nhr : IsSelfAdjoint r\nx : A\nhx : IsSelfAdjoint x\n⊢ IsSelfAdjoint (HSMul.hSMul r x)","decl":"@[aesop safe apply]\ntheorem smul [Star R] [AddMonoid A] [StarAddMonoid A] [SMul R A] [StarModule R A]\n    {r : R} (hr : IsSelfAdjoint r) {x : A} (hx : IsSelfAdjoint x) :\n    IsSelfAdjoint (r • x) := by\n  simp only [isSelfAdjoint_iff, star_smul, hr.star_eq, hx.star_eq]\n\n"}
{"name":"IsSelfAdjoint.smul_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : Monoid R\ninst✝⁴ : StarMul R\ninst✝³ : AddMonoid A\ninst✝² : StarAddMonoid A\ninst✝¹ : MulAction R A\ninst✝ : StarModule R A\nr : R\nhr : IsSelfAdjoint r\nhu : IsUnit r\nx : A\n⊢ Iff (IsSelfAdjoint (HSMul.hSMul r x)) (IsSelfAdjoint x)","decl":"theorem smul_iff [Monoid R] [StarMul R] [AddMonoid A] [StarAddMonoid A]\n    [MulAction R A] [StarModule R A] {r : R} (hr : IsSelfAdjoint r) (hu : IsUnit r) {x : A} :\n    IsSelfAdjoint (r • x) ↔ IsSelfAdjoint x := by\n  refine ⟨fun hrx ↦ ?_, .smul hr⟩\n  lift r to Rˣ using hu\n  rw [← inv_smul_smul r x]\n  replace hr : IsSelfAdjoint r := Units.ext hr.star_eq\n  exact hr.inv.smul hrx\n\n"}
{"name":"selfAdjoint.mem_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nx : R\n⊢ Iff (Membership.mem (selfAdjoint R) x) (Eq (Star.star x) x)","decl":"theorem mem_iff {x : R} : x ∈ selfAdjoint R ↔ star x = x := by\n  rw [← AddSubgroup.mem_carrier]\n  exact Iff.rfl\n\n"}
{"name":"selfAdjoint.star_val_eq","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddGroup R\ninst✝ : StarAddMonoid R\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ Eq (Star.star ↑x) ↑x","decl":"@[simp, norm_cast]\ntheorem star_val_eq {x : selfAdjoint R} : star (x : R) = x :=\n  x.prop\n\n"}
{"name":"selfAdjoint.isStarNormal","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalRing R\ninst✝ : StarRing R\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ IsStarNormal ↑x","decl":"instance isStarNormal [NonUnitalRing R] [StarRing R] (x : selfAdjoint R) :\n    IsStarNormal (x : R) :=\n  x.prop.isStarNormal\n\n"}
{"name":"selfAdjoint.val_one","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\n⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem val_one : ↑(1 : selfAdjoint R) = (1 : R) :=\n  rfl\n\n"}
{"name":"selfAdjoint.instNontrivialSubtypeMemAddSubgroup","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : StarRing R\ninst✝ : Nontrivial R\n⊢ Nontrivial (Subtype fun x => Membership.mem (selfAdjoint R) x)","decl":"instance [Nontrivial R] : Nontrivial (selfAdjoint R) :=\n  ⟨⟨0, 1, ne_of_apply_ne Subtype.val zero_ne_one⟩⟩\n\n"}
{"name":"selfAdjoint.val_pow","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp, norm_cast]\ntheorem val_pow (x : selfAdjoint R) (n : ℕ) : ↑(x ^ n) = (x : R) ^ n :=\n  rfl\n\n"}
{"name":"selfAdjoint.val_mul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : NonUnitalCommRing R\ninst✝ : StarRing R\nx y : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem val_mul (x y : selfAdjoint R) : ↑(x * y) = (x : R) * y :=\n  rfl\n\n"}
{"name":"selfAdjoint.val_inv","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ Eq (↑(Inv.inv x)) (Inv.inv ↑x)","decl":"@[simp, norm_cast]\ntheorem val_inv (x : selfAdjoint R) : ↑x⁻¹ = (x : R)⁻¹ :=\n  rfl\n\n"}
{"name":"selfAdjoint.val_div","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nx y : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ Eq (↑(HDiv.hDiv x y)) (HDiv.hDiv ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem val_div (x y : selfAdjoint R) : ↑(x / y) = (x / y : R) :=\n  rfl\n\n"}
{"name":"selfAdjoint.val_zpow","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\nz : Int\n⊢ Eq (↑(HPow.hPow x z)) (HPow.hPow (↑x) z)","decl":"@[simp, norm_cast]\ntheorem val_zpow (x : selfAdjoint R) (z : ℤ) : ↑(x ^ z) = (x : R) ^ z :=\n  rfl\n\n"}
{"name":"selfAdjoint.val_nnratCast","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nq : NNRat\n⊢ Eq ↑↑q ↑q","decl":"@[simp, norm_cast] lemma val_nnratCast (q : ℚ≥0) : (q : selfAdjoint R) = (q : R) := rfl\n"}
{"name":"selfAdjoint.val_ratCast","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nq : Rat\n⊢ Eq ↑↑q ↑q","decl":"@[simp, norm_cast] lemma val_ratCast (q : ℚ) : (q : selfAdjoint R) = (q : R) := rfl\n\n"}
{"name":"selfAdjoint.val_nnqsmul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nq : NNRat\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ Eq (↑(HSMul.hSMul q x)) (HSMul.hSMul q ↑x)","decl":"@[simp, norm_cast] lemma val_nnqsmul (q : ℚ≥0) (x : selfAdjoint R) : ↑(q • x) = q • (x : R) := rfl\n"}
{"name":"selfAdjoint.val_qsmul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Field R\ninst✝ : StarRing R\nq : Rat\nx : Subtype fun x => Membership.mem (selfAdjoint R) x\n⊢ Eq (↑(HSMul.hSMul q x)) (HSMul.hSMul q ↑x)","decl":"@[simp, norm_cast] lemma val_qsmul (q : ℚ) (x : selfAdjoint R) : ↑(q • x) = q • (x : R) := rfl\n\n"}
{"name":"selfAdjoint.val_smul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : Star R\ninst✝⁴ : TrivialStar R\ninst✝³ : AddGroup A\ninst✝² : StarAddMonoid A\ninst✝¹ : SMul R A\ninst✝ : StarModule R A\nr : R\nx : Subtype fun x => Membership.mem (selfAdjoint A) x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[simp, norm_cast]\ntheorem val_smul [SMul R A] [StarModule R A] (r : R) (x : selfAdjoint A) : ↑(r • x) = r • (x : A) :=\n  rfl\n\n"}
{"name":"skewAdjoint.mem_iff","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddCommGroup R\ninst✝ : StarAddMonoid R\nx : R\n⊢ Iff (Membership.mem (skewAdjoint R) x) (Eq (Star.star x) (Neg.neg x))","decl":"theorem mem_iff {x : R} : x ∈ skewAdjoint R ↔ star x = -x := by\n  rw [← AddSubgroup.mem_carrier]\n  exact Iff.rfl\n\n"}
{"name":"skewAdjoint.star_val_eq","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : AddCommGroup R\ninst✝ : StarAddMonoid R\nx : Subtype fun x => Membership.mem (skewAdjoint R) x\n⊢ Eq (Star.star ↑x) (Neg.neg ↑x)","decl":"@[simp, norm_cast]\ntheorem star_val_eq {x : skewAdjoint R} : star (x : R) = -x :=\n  x.prop\n\n"}
{"name":"skewAdjoint.conjugate","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\nx : R\nhx : Membership.mem (skewAdjoint R) x\nz : R\n⊢ Membership.mem (skewAdjoint R) (HMul.hMul (HMul.hMul z x) (Star.star z))","decl":"theorem conjugate {x : R} (hx : x ∈ skewAdjoint R) (z : R) : z * x * star z ∈ skewAdjoint R := by\n  simp only [mem_iff, star_mul, star_star, mem_iff.mp hx, neg_mul, mul_neg, mul_assoc]\n\n"}
{"name":"skewAdjoint.conjugate'","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\nx : R\nhx : Membership.mem (skewAdjoint R) x\nz : R\n⊢ Membership.mem (skewAdjoint R) (HMul.hMul (HMul.hMul (Star.star z) x) z)","decl":"theorem conjugate' {x : R} (hx : x ∈ skewAdjoint R) (z : R) : star z * x * z ∈ skewAdjoint R := by\n  simp only [mem_iff, star_mul, star_star, mem_iff.mp hx, neg_mul, mul_neg, mul_assoc]\n\n"}
{"name":"skewAdjoint.isStarNormal_of_mem","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\nx : R\nhx : Membership.mem (skewAdjoint R) x\n⊢ IsStarNormal x","decl":"theorem isStarNormal_of_mem {x : R} (hx : x ∈ skewAdjoint R) : IsStarNormal x :=\n  ⟨by\n    simp only [mem_iff] at hx\n    simp only [hx, Commute.neg_left, Commute.refl]⟩\n\n"}
{"name":"skewAdjoint.instIsStarNormalValMemAddSubgroup","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\ninst✝ : StarRing R\nx : Subtype fun x => Membership.mem (skewAdjoint R) x\n⊢ IsStarNormal ↑x","decl":"instance (x : skewAdjoint R) : IsStarNormal (x : R) :=\n  isStarNormal_of_mem (SetLike.coe_mem _)\n\n"}
{"name":"skewAdjoint.smul_mem","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁶ : Star R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : StarAddMonoid A\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R A\ninst✝ : StarModule R A\nr : R\nx : A\nh : Membership.mem (skewAdjoint A) x\n⊢ Membership.mem (skewAdjoint A) (HSMul.hSMul r x)","decl":"@[aesop safe apply (rule_sets := [SetLike])]\ntheorem smul_mem [Monoid R] [DistribMulAction R A] [StarModule R A] (r : R) {x : A}\n    (h : x ∈ skewAdjoint A) : r • x ∈ skewAdjoint A := by\n  rw [mem_iff, star_smul, star_trivial, mem_iff.mp h, smul_neg r]\n\n"}
{"name":"skewAdjoint.val_smul","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁶ : Star R\ninst✝⁵ : TrivialStar R\ninst✝⁴ : AddCommGroup A\ninst✝³ : StarAddMonoid A\ninst✝² : Monoid R\ninst✝¹ : DistribMulAction R A\ninst✝ : StarModule R A\nr : R\nx : Subtype fun x => Membership.mem (skewAdjoint A) x\n⊢ Eq (↑(HSMul.hSMul r x)) (HSMul.hSMul r ↑x)","decl":"@[simp, norm_cast]\ntheorem val_smul [Monoid R] [DistribMulAction R A] [StarModule R A] (r : R) (x : skewAdjoint A) :\n    ↑(r • x) = r • (x : A) :=\n  rfl\n\n"}
{"name":"IsSelfAdjoint.smul_mem_skewAdjoint","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid R\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule R A\nr : R\nhr : Membership.mem (skewAdjoint R) r\na : A\nha : IsSelfAdjoint a\n⊢ Membership.mem (skewAdjoint A) (HSMul.hSMul r a)","decl":"/-- Scalar multiplication of a self-adjoint element by a skew-adjoint element produces a\nskew-adjoint element. -/\ntheorem IsSelfAdjoint.smul_mem_skewAdjoint [Ring R] [AddCommGroup A] [Module R A] [StarAddMonoid R]\n    [StarAddMonoid A] [StarModule R A] {r : R} (hr : r ∈ skewAdjoint R) {a : A}\n    (ha : IsSelfAdjoint a) : r • a ∈ skewAdjoint A :=\n  (star_smul _ _).trans <| (congr_arg₂ _ hr ha).trans <| neg_smul _ _\n\n"}
{"name":"isSelfAdjoint_smul_of_mem_skewAdjoint","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup A\ninst✝³ : Module R A\ninst✝² : StarAddMonoid R\ninst✝¹ : StarAddMonoid A\ninst✝ : StarModule R A\nr : R\nhr : Membership.mem (skewAdjoint R) r\na : A\nha : Membership.mem (skewAdjoint A) a\n⊢ IsSelfAdjoint (HSMul.hSMul r a)","decl":"/-- Scalar multiplication of a skew-adjoint element by a skew-adjoint element produces a\nself-adjoint element. -/\ntheorem isSelfAdjoint_smul_of_mem_skewAdjoint [Ring R] [AddCommGroup A] [Module R A]\n    [StarAddMonoid R] [StarAddMonoid A] [StarModule R A] {r : R} (hr : r ∈ skewAdjoint R) {a : A}\n    (ha : a ∈ skewAdjoint A) : IsSelfAdjoint (r • a) :=\n  (star_smul _ _).trans <| (congr_arg₂ _ hr ha).trans <| neg_smul_neg _ _\n\n"}
{"name":"IsStarNormal.zero","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : Semiring R\ninst✝ : StarRing R\n⊢ IsStarNormal 0","decl":"protected instance IsStarNormal.zero [Semiring R] [StarRing R] : IsStarNormal (0 : R) :=\n  ⟨by simp only [Commute.refl, star_comm_self, star_zero]⟩\n\n"}
{"name":"IsStarNormal.one","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : MulOneClass R\ninst✝ : StarMul R\n⊢ IsStarNormal 1","decl":"protected instance IsStarNormal.one [MulOneClass R] [StarMul R] : IsStarNormal (1 : R) :=\n  ⟨by simp only [Commute.refl, star_comm_self, star_one]⟩\n\n"}
{"name":"IsStarNormal.star","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Mul R\ninst✝¹ : StarMul R\nx : R\ninst✝ : IsStarNormal x\n⊢ IsStarNormal (Star.star x)","decl":"protected instance IsStarNormal.star [Mul R] [StarMul R] {x : R} [IsStarNormal x] :\n    IsStarNormal (star x) :=\n  ⟨show star (star x) * star x = star x * star (star x) by rw [star_star, star_comm_self']⟩\n\n"}
{"name":"IsStarNormal.neg","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Ring R\ninst✝¹ : StarAddMonoid R\nx : R\ninst✝ : IsStarNormal x\n⊢ IsStarNormal (Neg.neg x)","decl":"protected instance IsStarNormal.neg [Ring R] [StarAddMonoid R] {x : R} [IsStarNormal x] :\n    IsStarNormal (-x) :=\n  ⟨show star (-x) * -x = -x * star (-x) by simp_rw [star_neg, neg_mul_neg, star_comm_self']⟩\n\n"}
{"name":"IsStarNormal.val_inv","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Monoid R\ninst✝¹ : StarMul R\nx : Units R\ninst✝ : IsStarNormal ↑x\n⊢ IsStarNormal ↑(Inv.inv x)","decl":"protected instance IsStarNormal.val_inv [Monoid R] [StarMul R] {x : Rˣ} [IsStarNormal (x : R)] :\n    IsStarNormal (↑x⁻¹ : R) where\n  star_comm_self := by simpa [← Units.coe_star_inv, -Commute.units_val_iff] using star_comm_self\n\n"}
{"name":"IsStarNormal.map","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"F : Type u_3\nR : Type u_4\nS : Type u_5\ninst✝⁶ : Mul R\ninst✝⁵ : Star R\ninst✝⁴ : Mul S\ninst✝³ : Star S\ninst✝² : FunLike F R S\ninst✝¹ : MulHomClass F R S\ninst✝ : StarHomClass F R S\nf : F\nr : R\nhr : IsStarNormal r\n⊢ IsStarNormal (f r)","decl":"protected instance IsStarNormal.map {F R S : Type*} [Mul R] [Star R] [Mul S] [Star S]\n    [FunLike F R S] [MulHomClass F R S] [StarHomClass F R S] (f : F) (r : R) [hr : IsStarNormal r] :\n    IsStarNormal (f r) where\n  star_comm_self := by simpa [map_star] using congr(f $(hr.star_comm_self))\n\n-- see Note [lower instance priority]\n"}
{"name":"TrivialStar.isStarNormal","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝² : Mul R\ninst✝¹ : StarMul R\ninst✝ : TrivialStar R\nx : R\n⊢ IsStarNormal x","decl":"instance (priority := 100) TrivialStar.isStarNormal [Mul R] [StarMul R] [TrivialStar R]\n    {x : R} : IsStarNormal x :=\n  ⟨by rw [star_trivial]⟩\n\n-- see Note [lower instance priority]\n"}
{"name":"CommMonoid.isStarNormal","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoid R\ninst✝ : StarMul R\nx : R\n⊢ IsStarNormal x","decl":"instance (priority := 100) CommMonoid.isStarNormal [CommMonoid R] [StarMul R] {x : R} :\n    IsStarNormal x :=\n  ⟨mul_comm _ _⟩\n\n\n"}
{"name":"Pi.isSelfAdjoint","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"ι : Type u_3\nα : ι → Type u_4\ninst✝ : (i : ι) → Star (α i)\nf : (i : ι) → α i\n⊢ Iff (IsSelfAdjoint f) (∀ (i : ι), IsSelfAdjoint (f i))","decl":"protected lemma isSelfAdjoint : IsSelfAdjoint f ↔ ∀ i, IsSelfAdjoint (f i) := funext_iff\n\n"}
{"name":"IsSelfAdjoint.apply","module":"Mathlib.Algebra.Star.SelfAdjoint","initialProofState":"ι : Type u_3\nα : ι → Type u_4\ninst✝ : (i : ι) → Star (α i)\nf : (i : ι) → α i\na✝ : IsSelfAdjoint f\ni : ι\n⊢ IsSelfAdjoint (f i)","decl":"alias ⟨_root_.IsSelfAdjoint.apply, _⟩ := Pi.isSelfAdjoint\n\n"}
