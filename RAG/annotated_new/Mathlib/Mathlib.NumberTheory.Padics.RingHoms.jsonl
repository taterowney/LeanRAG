{"name":"PadicInt.modPart_lt_p","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nr : Rat\n⊢ LT.lt (PadicInt.modPart p r) ↑p","decl":"theorem modPart_lt_p : modPart p r < p := by\n  convert Int.emod_lt _ _\n  · simp\n  · exact mod_cast hp_prime.1.ne_zero\n\n"}
{"name":"PadicInt.modPart_nonneg","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nr : Rat\n⊢ LE.le 0 (PadicInt.modPart p r)","decl":"theorem modPart_nonneg : 0 ≤ modPart p r :=\n  Int.emod_nonneg _ <| mod_cast hp_prime.1.ne_zero\n\n"}
{"name":"PadicInt.isUnit_den","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nr : Rat\nh : LE.le (Norm.norm ↑r) 1\n⊢ IsUnit ↑r.den","decl":"theorem isUnit_den (r : ℚ) (h : ‖(r : ℚ_[p])‖ ≤ 1) : IsUnit (r.den : ℤ_[p]) := by\n  rw [isUnit_iff]\n  apply le_antisymm (r.den : ℤ_[p]).2\n  rw [← not_lt, coe_natCast]\n  intro norm_denom_lt\n  have hr : ‖(r * r.den : ℚ_[p])‖ = ‖(r.num : ℚ_[p])‖ := by\n    congr\n    rw_mod_cast [@Rat.mul_den_eq_num r]\n  rw [padicNormE.mul] at hr\n  have key : ‖(r.num : ℚ_[p])‖ < 1 := by\n    calc\n      _ = _ := hr.symm\n      _ < 1 * 1 := mul_lt_mul' h norm_denom_lt (norm_nonneg _) zero_lt_one\n      _ = 1 := mul_one 1\n\n  have : ↑p ∣ r.num ∧ (p : ℤ) ∣ r.den := by\n    simp only [← norm_int_lt_one_iff_dvd, ← padic_norm_e_of_padicInt]\n    exact ⟨key, norm_denom_lt⟩\n  apply hp_prime.1.not_dvd_one\n  rwa [← r.reduced.gcd_eq_one, Nat.dvd_gcd_iff, ← Int.natCast_dvd, ← Int.natCast_dvd_natCast]\n\n"}
{"name":"PadicInt.norm_sub_modPart_aux","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nr : Rat\nh : LE.le (Norm.norm ↑r) 1\n⊢ Dvd.dvd (↑p) (HSub.hSub r.num (HMul.hMul (HMod.hMod (HMul.hMul r.num (r.den.gcdA p)) ↑p) ↑r.den))","decl":"theorem norm_sub_modPart_aux (r : ℚ) (h : ‖(r : ℚ_[p])‖ ≤ 1) :\n    ↑p ∣ r.num - r.num * r.den.gcdA p % p * ↑r.den := by\n  rw [← ZMod.intCast_zmod_eq_zero_iff_dvd]\n  simp only [Int.cast_natCast, ZMod.natCast_mod, Int.cast_mul, Int.cast_sub]\n  have := congr_arg (fun x => x % p : ℤ → ZMod p) (gcd_eq_gcd_ab r.den p)\n  simp only [Int.cast_natCast, CharP.cast_eq_zero, EuclideanDomain.mod_zero, Int.cast_add,\n    Int.cast_mul, zero_mul, add_zero] at this\n  push_cast\n  rw [mul_right_comm, mul_assoc, ← this]\n  suffices rdcp : r.den.Coprime p by\n    rw [rdcp.gcd_eq_one]\n    simp only [mul_one, cast_one, sub_self]\n  apply Coprime.symm\n  apply (coprime_or_dvd_of_prime hp_prime.1 _).resolve_right\n  rw [← Int.natCast_dvd_natCast, ← norm_int_lt_one_iff_dvd, not_lt]\n  apply ge_of_eq\n  rw [← isUnit_iff]\n  exact isUnit_den r h\n\n"}
{"name":"PadicInt.norm_sub_modPart","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nr : Rat\nh : LE.le (Norm.norm ↑r) 1\n⊢ LT.lt (Norm.norm (HSub.hSub ⟨↑r, h⟩ ↑(PadicInt.modPart p r))) 1","decl":"theorem norm_sub_modPart (h : ‖(r : ℚ_[p])‖ ≤ 1) : ‖(⟨r, h⟩ - modPart p r : ℤ_[p])‖ < 1 := by\n  let n := modPart p r\n  rw [norm_lt_one_iff_dvd, ← (isUnit_den r h).dvd_mul_right]\n  suffices ↑p ∣ r.num - n * r.den by\n    convert (Int.castRingHom ℤ_[p]).map_dvd this\n    simp only [n, sub_mul, Int.cast_natCast, eq_intCast, Int.cast_mul, sub_left_inj,\n      Int.cast_sub]\n    apply Subtype.coe_injective\n    simp only [coe_mul, Subtype.coe_mk, coe_natCast]\n    rw_mod_cast [@Rat.mul_den_eq_num r]\n    rfl\n  exact norm_sub_modPart_aux r h\n\n"}
{"name":"PadicInt.exists_mem_range_of_norm_rat_le_one","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nr : Rat\nh : LE.le (Norm.norm ↑r) 1\n⊢ Exists fun n => And (LE.le 0 n) (And (LT.lt n ↑p) (LT.lt (Norm.norm (HSub.hSub ⟨↑r, h⟩ ↑n)) 1))","decl":"theorem exists_mem_range_of_norm_rat_le_one (h : ‖(r : ℚ_[p])‖ ≤ 1) :\n    ∃ n : ℤ, 0 ≤ n ∧ n < p ∧ ‖(⟨r, h⟩ - n : ℤ_[p])‖ < 1 :=\n  ⟨modPart p r, modPart_nonneg _, modPart_lt_p _, norm_sub_modPart _ h⟩\n\n"}
{"name":"PadicInt.zmod_congr_of_sub_mem_span_aux","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nn : Nat\nx : PadicInt p\na b : Int\nha : Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) (HSub.hSub x ↑a)\nhb : Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) (HSub.hSub x ↑b)\n⊢ Eq ↑a ↑b","decl":"theorem zmod_congr_of_sub_mem_span_aux (n : ℕ) (x : ℤ_[p]) (a b : ℤ)\n    (ha : x - a ∈ (Ideal.span {(p : ℤ_[p]) ^ n}))\n    (hb : x - b ∈ (Ideal.span {(p : ℤ_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by\n  rw [Ideal.mem_span_singleton] at ha hb\n  rw [← sub_eq_zero, ← Int.cast_sub, ZMod.intCast_zmod_eq_zero_iff_dvd, Int.natCast_pow]\n  rw [← dvd_neg, neg_sub] at ha\n  have := dvd_add ha hb\n  rwa [sub_eq_add_neg, sub_eq_add_neg, add_assoc, neg_add_cancel_left, ← sub_eq_add_neg, ←\n    Int.cast_sub, pow_p_dvd_int_iff] at this\n\n"}
{"name":"PadicInt.zmod_congr_of_sub_mem_span","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nn : Nat\nx : PadicInt p\na b : Nat\nha : Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) (HSub.hSub x ↑a)\nhb : Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) (HSub.hSub x ↑b)\n⊢ Eq ↑a ↑b","decl":"theorem zmod_congr_of_sub_mem_span (n : ℕ) (x : ℤ_[p]) (a b : ℕ)\n    (ha : x - a ∈ (Ideal.span {(p : ℤ_[p]) ^ n}))\n    (hb : x - b ∈ (Ideal.span {(p : ℤ_[p]) ^ n})) : (a : ZMod (p ^ n)) = b := by\n  simpa using zmod_congr_of_sub_mem_span_aux n x a b ha hb\n\n"}
{"name":"PadicInt.zmod_congr_of_sub_mem_max_ideal","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\nm n : Nat\nhm : Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑m)\nhn : Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑n)\n⊢ Eq ↑m ↑n","decl":"theorem zmod_congr_of_sub_mem_max_ideal (x : ℤ_[p]) (m n : ℕ) (hm : x - m ∈ maximalIdeal ℤ_[p])\n    (hn : x - n ∈ maximalIdeal ℤ_[p]) : (m : ZMod p) = n := by\n  rw [maximalIdeal_eq_span_p] at hm hn\n  have := zmod_congr_of_sub_mem_span_aux 1 x m n\n  simp only [pow_one] at this\n  specialize this hm hn\n  apply_fun ZMod.castHom (show p ∣ p ^ 1 by rw [pow_one]) (ZMod p) at this\n  simp only [map_intCast] at this\n  simpa only [Int.cast_natCast] using this\n\n"}
{"name":"PadicInt.exists_mem_range","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Exists fun n => And (LT.lt n p) (Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑n))","decl":"theorem exists_mem_range : ∃ n : ℕ, n < p ∧ x - n ∈ maximalIdeal ℤ_[p] := by\n  simp only [maximalIdeal_eq_span_p, Ideal.mem_span_singleton, ← norm_lt_one_iff_dvd]\n  obtain ⟨r, hr⟩ := rat_dense p (x : ℚ_[p]) zero_lt_one\n  have H : ‖(r : ℚ_[p])‖ ≤ 1 := by\n    rw [norm_sub_rev] at hr\n    calc\n      _ = ‖(r : ℚ_[p]) - x + x‖ := by ring_nf\n      _ ≤ _ := padicNormE.nonarchimedean _ _\n      _ ≤ _ := max_le (le_of_lt hr) x.2\n\n  obtain ⟨n, hzn, hnp, hn⟩ := exists_mem_range_of_norm_rat_le_one r H\n  lift n to ℕ using hzn\n  use n\n  constructor\n  · exact mod_cast hnp\n  simp only [norm_def, coe_sub, Subtype.coe_mk, coe_natCast] at hn ⊢\n  rw [show (x - n : ℚ_[p]) = x - r + (r - n) by ring]\n  apply lt_of_le_of_lt (padicNormE.nonarchimedean _ _)\n  apply max_lt hr\n  simpa using hn\n\n"}
{"name":"PadicInt.existsUnique_mem_range","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ ExistsUnique fun n => And (LT.lt n p) (Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑n))","decl":"theorem existsUnique_mem_range : ∃! n : ℕ, n < p ∧ x - n ∈ maximalIdeal ℤ_[p] := by\n  obtain ⟨n, hn₁, hn₂⟩ := exists_mem_range x\n  use n, ⟨hn₁, hn₂⟩, fun m ⟨hm₁, hm₂⟩ ↦ ?_\n  have := (zmod_congr_of_sub_mem_max_ideal x n m hn₂ hm₂).symm\n  rwa [ZMod.natCast_eq_natCast_iff, ModEq, mod_eq_of_lt hn₁, mod_eq_of_lt hm₁] at this\n\n"}
{"name":"PadicInt.exists_unique_mem_range","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ ExistsUnique fun n => And (LT.lt n p) (Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑n))","decl":"@[deprecated (since := \"2024-12-17\")] alias exists_unique_mem_range := existsUnique_mem_range\n\n"}
{"name":"PadicInt.zmodRepr_spec","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ And (LT.lt x.zmodRepr p) (Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑x.zmodRepr))","decl":"theorem zmodRepr_spec : zmodRepr x < p ∧ x - zmodRepr x ∈ maximalIdeal ℤ_[p] :=\n  Classical.choose_spec (existsUnique_mem_range x).exists\n\n"}
{"name":"PadicInt.zmodRepr_unique","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\ny : Nat\nhy₁ : LT.lt y p\nhy₂ : Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑y)\n⊢ Eq y x.zmodRepr","decl":"theorem zmodRepr_unique (y : ℕ) (hy₁ : y < p) (hy₂ : x - y ∈ maximalIdeal ℤ_[p]) : y = zmodRepr x :=\n  have h := (Classical.choose_spec (existsUnique_mem_range x)).right\n  (h y ⟨hy₁, hy₂⟩).trans (h (zmodRepr x) (zmodRepr_spec x)).symm\n\n"}
{"name":"PadicInt.zmodRepr_lt_p","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ LT.lt x.zmodRepr p","decl":"theorem zmodRepr_lt_p : zmodRepr x < p :=\n  (zmodRepr_spec _).1\n\n"}
{"name":"PadicInt.sub_zmodRepr_mem","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x ↑x.zmodRepr)","decl":"theorem sub_zmodRepr_mem : x - zmodRepr x ∈ maximalIdeal ℤ_[p] :=\n  (zmodRepr_spec _).2\n\n"}
{"name":"PadicInt.toZMod_spec","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Membership.mem (IsLocalRing.maximalIdeal (PadicInt p)) (HSub.hSub x (PadicInt.toZMod x).cast)","decl":"/-- `z - (toZMod z : ℤ_[p])` is contained in the maximal ideal of `ℤ_[p]`, for every `z : ℤ_[p]`.\n\nThe coercion from `ZMod p` to `ℤ_[p]` is `ZMod.cast`,\nwhich coerces `ZMod p` into arbitrary rings.\nThis is unfortunate, but a consequence of the fact that we allow `ZMod p`\nto coerce to rings of arbitrary characteristic, instead of only rings of characteristic `p`.\nThis coercion is only a ring homomorphism if it coerces into a ring whose characteristic divides\n`p`. While this is not the case here we can still make use of the coercion.\n-/\ntheorem toZMod_spec : x - (ZMod.cast (toZMod x) : ℤ_[p]) ∈ maximalIdeal ℤ_[p] := by\n  convert sub_zmodRepr_mem x using 2\n  dsimp [toZMod, toZModHom]\n  rcases Nat.exists_eq_add_of_lt hp_prime.1.pos with ⟨p', rfl⟩\n  change ↑((_ : ZMod (0 + p' + 1)).val) = (_ : ℤ_[0 + p' + 1])\n  rw [Nat.cast_inj]\n  apply mod_eq_of_lt\n  simpa only [zero_add] using zmodRepr_lt_p x\n\n"}
{"name":"PadicInt.ker_toZMod","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\n⊢ Eq (RingHom.ker PadicInt.toZMod) (IsLocalRing.maximalIdeal (PadicInt p))","decl":"theorem ker_toZMod : RingHom.ker (toZMod : ℤ_[p] →+* ZMod p) = maximalIdeal ℤ_[p] := by\n  ext x\n  rw [RingHom.mem_ker]\n  constructor\n  · intro h\n    simpa only [h, ZMod.cast_zero, sub_zero] using toZMod_spec x\n  · intro h\n    rw [← sub_zero x] at h\n    dsimp [toZMod, toZModHom]\n    convert zmod_congr_of_sub_mem_max_ideal x _ 0 _ h\n    · norm_cast\n    · apply sub_zmodRepr_mem\n\n"}
{"name":"PadicInt.appr_lt","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\nn : Nat\n⊢ LT.lt (x.appr n) (HPow.hPow p n)","decl":"theorem appr_lt (x : ℤ_[p]) (n : ℕ) : x.appr n < p ^ n := by\n  induction' n with n ih generalizing x\n  · simp only [appr, zero_eq, _root_.pow_zero, zero_lt_one]\n  simp only [appr, map_natCast, ZMod.natCast_self, RingHom.map_pow, Int.natAbs, RingHom.map_mul]\n  have hp : p ^ n < p ^ (n + 1) := by apply Nat.pow_lt_pow_right hp_prime.1.one_lt n.lt_add_one\n  split_ifs with h\n  · apply lt_trans (ih _) hp\n  · calc\n      _ < p ^ n + p ^ n * (p - 1) := ?_\n      _ = p ^ (n + 1) := ?_\n\n    · apply add_lt_add_of_lt_of_le (ih _)\n      apply Nat.mul_le_mul_left\n      apply le_pred_of_lt\n      apply ZMod.val_lt\n    · rw [mul_tsub, mul_one, ← _root_.pow_succ]\n      apply add_tsub_cancel_of_le (le_of_lt hp)\n\n"}
{"name":"PadicInt.appr_mono","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\n⊢ Monotone x.appr","decl":"theorem appr_mono (x : ℤ_[p]) : Monotone x.appr := by\n  apply monotone_nat_of_le_succ\n  intro n\n  dsimp [appr]\n  split_ifs; · rfl\n  apply Nat.le_add_right\n\n"}
{"name":"PadicInt.dvd_appr_sub_appr","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx : PadicInt p\nm n : Nat\nh : LE.le m n\n⊢ Dvd.dvd (HPow.hPow p m) (HSub.hSub (x.appr n) (x.appr m))","decl":"theorem dvd_appr_sub_appr (x : ℤ_[p]) (m n : ℕ) (h : m ≤ n) : p ^ m ∣ x.appr n - x.appr m := by\n  obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le h; clear h\n  induction' k with k ih\n  · simp only [zero_eq, add_zero, le_refl, tsub_eq_zero_of_le, ne_eq, Nat.isUnit_iff, dvd_zero]\n  rw [← add_assoc]\n  dsimp [appr]\n  split_ifs with h\n  · exact ih\n  rw [add_comm, add_tsub_assoc_of_le (appr_mono _ (Nat.le_add_right m k))]\n  apply dvd_add _ ih\n  apply dvd_mul_of_dvd_left\n  apply pow_dvd_pow _ (Nat.le_add_right m k)\n\n"}
{"name":"PadicInt.appr_spec","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nn : Nat\nx : PadicInt p\n⊢ Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) (HSub.hSub x ↑(x.appr n))","decl":"theorem appr_spec (n : ℕ) : ∀ x : ℤ_[p], x - appr x n ∈ Ideal.span {(p : ℤ_[p]) ^ n} := by\n  simp only [Ideal.mem_span_singleton]\n  induction' n with n ih\n  · simp only [zero_eq, _root_.pow_zero, isUnit_one, IsUnit.dvd, forall_const]\n  intro x\n  dsimp only [appr]\n  split_ifs with h\n  · rw [h]\n    apply dvd_zero\n  push_cast\n  rw [sub_add_eq_sub_sub]\n  obtain ⟨c, hc⟩ := ih x\n  simp only [map_natCast, ZMod.natCast_self, RingHom.map_pow, RingHom.map_mul, ZMod.natCast_val]\n  have hc' : c ≠ 0 := by\n    rintro rfl\n    simp only [mul_zero] at hc\n    contradiction\n  conv_rhs =>\n    congr\n    simp only [hc]\n  rw [show (x - (appr x n : ℤ_[p])).valuation = ((p : ℤ_[p]) ^ n * c).valuation by rw [hc]]\n  rw [valuation_p_pow_mul _ _ hc', Nat.cast_add, add_sub_cancel_left, _root_.pow_succ, ← mul_sub]\n  apply mul_dvd_mul_left\n  obtain hc0 | hc0 := eq_or_ne c.valuation 0\n  · simp only [hc0, mul_one, _root_.pow_zero, Nat.cast_zero, Int.natAbs_zero]\n    rw [mul_comm, unitCoeff_spec h] at hc\n    suffices c = unitCoeff h by\n      rw [← this, ← Ideal.mem_span_singleton, ← maximalIdeal_eq_span_p]\n      apply toZMod_spec\n    lift c to ℤ_[p]ˣ using by simp [isUnit_iff, norm_eq_zpow_neg_valuation hc', hc0]\n    rw [IsDiscreteValuationRing.unit_mul_pow_congr_unit _ _ _ _ _ hc]\n    exact irreducible_p\n  · simp only [Int.natAbs_ofNat, zero_pow hc0, sub_zero, ZMod.cast_zero, mul_zero]\n    rw [unitCoeff_spec hc']\n    exact (dvd_pow_self (p : ℤ_[p]) hc0).mul_left _\n\n"}
{"name":"PadicInt.ker_toZModPow","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nn : Nat\n⊢ Eq (RingHom.ker (PadicInt.toZModPow n)) (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n)))","decl":"theorem ker_toZModPow (n : ℕ) :\n    RingHom.ker (toZModPow n : ℤ_[p] →+* ZMod (p ^ n)) = Ideal.span {(p : ℤ_[p]) ^ n} := by\n  ext x\n  rw [RingHom.mem_ker]\n  constructor\n  · intro h\n    suffices x.appr n = 0 by\n      convert appr_spec n x\n      simp only [this, sub_zero, cast_zero]\n    dsimp [toZModPow, toZModHom] at h\n    rw [ZMod.natCast_zmod_eq_zero_iff_dvd] at h\n    apply eq_zero_of_dvd_of_lt h (appr_lt _ _)\n  · intro h\n    rw [← sub_zero x] at h\n    dsimp [toZModPow, toZModHom]\n    rw [zmod_congr_of_sub_mem_span n x _ 0 _ h, cast_zero]\n    apply appr_spec\n\n-- This is not a simp lemma; simp can't match the LHS.\n"}
{"name":"PadicInt.zmod_cast_comp_toZModPow","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nm n : Nat\nh : LE.le m n\n⊢ Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p m))).comp (PadicInt.toZModPow n)) (PadicInt.toZModPow m)","decl":"theorem zmod_cast_comp_toZModPow (m n : ℕ) (h : m ≤ n) :\n    (ZMod.castHom (pow_dvd_pow p h) (ZMod (p ^ m))).comp (@toZModPow p _ n) = @toZModPow p _ m := by\n  apply ZMod.ringHom_eq_of_ker_eq\n  ext x\n  rw [RingHom.mem_ker, RingHom.mem_ker]\n  simp only [Function.comp_apply, ZMod.castHom_apply, RingHom.coe_comp]\n  simp only [toZModPow, toZModHom, RingHom.coe_mk]\n  dsimp\n  rw [ZMod.cast_natCast (pow_dvd_pow p h),\n    zmod_congr_of_sub_mem_span m (x.appr n) (x.appr n) (x.appr m)]\n  · rw [sub_self]\n    apply Ideal.zero_mem _\n  · rw [Ideal.mem_span_singleton]\n    rcases dvd_appr_sub_appr x m n h with ⟨c, hc⟩\n    use c\n    rw [← Nat.cast_sub (appr_mono _ h), hc, Nat.cast_mul, Nat.cast_pow]\n\n"}
{"name":"PadicInt.cast_toZModPow","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nm n : Nat\nh : LE.le m n\nx : PadicInt p\n⊢ Eq ((PadicInt.toZModPow n) x).cast ((PadicInt.toZModPow m) x)","decl":"@[simp]\ntheorem cast_toZModPow (m n : ℕ) (h : m ≤ n) (x : ℤ_[p]) :\n    ZMod.cast (toZModPow n x) = toZModPow m x := by\n  rw [← zmod_cast_comp_toZModPow _ _ h]\n  rfl\n\n"}
{"name":"PadicInt.denseRange_natCast","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\n⊢ DenseRange Nat.cast","decl":"theorem denseRange_natCast : DenseRange (Nat.cast : ℕ → ℤ_[p]) := by\n  intro x\n  rw [Metric.mem_closure_range_iff]\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε\n  use x.appr n\n  rw [dist_eq_norm]\n  apply lt_of_le_of_lt _ hn\n  rw [norm_le_pow_iff_mem_span_pow]\n  apply appr_spec\n\n"}
{"name":"PadicInt.denseRange_intCast","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\n⊢ DenseRange Int.cast","decl":"theorem denseRange_intCast : DenseRange (Int.cast : ℤ → ℤ_[p]) := by\n  intro x\n  refine DenseRange.induction_on denseRange_natCast x ?_ ?_\n  · exact isClosed_closure\n  · intro a\n    apply subset_closure\n    exact Set.mem_range_self _\n\n"}
{"name":"PadicInt.nthHom_zero","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\n⊢ Eq (PadicInt.nthHom f 0) 0","decl":"@[simp]\ntheorem nthHom_zero : nthHom f 0 = 0 := by\n  simp (config := { unfoldPartialApp := true }) [nthHom]\n  rfl\n\n"}
{"name":"PadicInt.pow_dvd_nthHom_sub","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr : R\ni j : Nat\nh : LE.le i j\n⊢ Dvd.dvd (HPow.hPow (↑p) i) (HSub.hSub (PadicInt.nthHom f r j) (PadicInt.nthHom f r i))","decl":"theorem pow_dvd_nthHom_sub (r : R) (i j : ℕ) (h : i ≤ j) :\n    (p : ℤ) ^ i ∣ nthHom f r j - nthHom f r i := by\n  specialize f_compat i j h\n  rw [← Int.natCast_pow, ← ZMod.intCast_zmod_eq_zero_iff_dvd, Int.cast_sub]\n  dsimp [nthHom]\n  rw [← f_compat, RingHom.comp_apply]\n  simp only [ZMod.cast_id, ZMod.castHom_apply, sub_self, ZMod.natCast_val, ZMod.intCast_cast]\n\n"}
{"name":"PadicInt.isCauSeq_nthHom","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr : R\n⊢ IsCauSeq (padicNorm p) fun n => ↑(PadicInt.nthHom f r n)","decl":"theorem isCauSeq_nthHom (r : R) : IsCauSeq (padicNorm p) fun n => nthHom f r n := by\n  intro ε hε\n  obtain ⟨k, hk⟩ : ∃ k : ℕ, (p : ℚ) ^ (-((k : ℕ) : ℤ)) < ε := exists_pow_neg_lt_rat p hε\n  use k\n  intro j hj\n  refine lt_of_le_of_lt ?_ hk\n  -- Need to do beta reduction first, as `norm_cast` doesn't.\n  -- Added to adapt to https://github.com/leanprover/lean4/pull/2734.\n  beta_reduce\n  norm_cast\n  rw [← padicNorm.dvd_iff_norm_le]\n  exact mod_cast pow_dvd_nthHom_sub f_compat r k j hj\n\n"}
{"name":"PadicInt.nthHomSeq_one","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\n⊢ HasEquiv.Equiv (PadicInt.nthHomSeq f_compat 1) 1","decl":"theorem nthHomSeq_one : nthHomSeq f_compat 1 ≈ 1 := by\n  intro ε hε\n  change _ < _ at hε\n  use 1\n  intro j hj\n  haveI : Fact (1 < p ^ j) := ⟨Nat.one_lt_pow (by omega) hp_prime.1.one_lt⟩\n  suffices (ZMod.cast (1 : ZMod (p ^ j)) : ℚ) = 1 by simp [nthHomSeq, nthHom, this, hε]\n  rw [ZMod.cast_eq_val, ZMod.val_one, Nat.cast_one]\n\n"}
{"name":"PadicInt.nthHomSeq_add","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr s : R\n⊢ HasEquiv.Equiv (PadicInt.nthHomSeq f_compat (HAdd.hAdd r s)) (HAdd.hAdd (PadicInt.nthHomSeq f_compat r) (PadicInt.nthHomSeq f_compat s))","decl":"theorem nthHomSeq_add (r s : R) :\n    nthHomSeq f_compat (r + s) ≈ nthHomSeq f_compat r + nthHomSeq f_compat s := by\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt_rat p hε\n  use n\n  intro j hj\n  dsimp [nthHomSeq]\n  apply lt_of_le_of_lt _ hn\n  rw [← Int.cast_add, ← Int.cast_sub, ← padicNorm.dvd_iff_norm_le, ←\n    ZMod.intCast_zmod_eq_zero_iff_dvd]\n  dsimp [nthHom]\n  simp only [ZMod.natCast_val, RingHom.map_add, Int.cast_sub, ZMod.intCast_cast, Int.cast_add]\n  rw [ZMod.cast_add (show p ^ n ∣ p ^ j from pow_dvd_pow _ hj)]\n  simp only [cast_add, ZMod.natCast_val, Int.cast_add, ZMod.intCast_cast, sub_self]\n\n"}
{"name":"PadicInt.nthHomSeq_mul","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr s : R\n⊢ HasEquiv.Equiv (PadicInt.nthHomSeq f_compat (HMul.hMul r s)) (HMul.hMul (PadicInt.nthHomSeq f_compat r) (PadicInt.nthHomSeq f_compat s))","decl":"theorem nthHomSeq_mul (r s : R) :\n    nthHomSeq f_compat (r * s) ≈ nthHomSeq f_compat r * nthHomSeq f_compat s := by\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt_rat p hε\n  use n\n  intro j hj\n  dsimp [nthHomSeq]\n  apply lt_of_le_of_lt _ hn\n  rw [← Int.cast_mul, ← Int.cast_sub, ← padicNorm.dvd_iff_norm_le, ←\n    ZMod.intCast_zmod_eq_zero_iff_dvd]\n  dsimp [nthHom]\n  simp only [ZMod.natCast_val, RingHom.map_mul, Int.cast_sub, ZMod.intCast_cast, Int.cast_mul]\n  rw [ZMod.cast_mul (show p ^ n ∣ p ^ j from pow_dvd_pow _ hj), sub_self]\n\n"}
{"name":"PadicInt.limNthHom_spec","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr : R\nε : Real\na✝ : LT.lt 0 ε\n⊢ Exists fun N => ∀ (n : Nat), GE.ge n N → LT.lt (Norm.norm (HSub.hSub (PadicInt.limNthHom f_compat r) ↑(PadicInt.nthHom f r n))) ε","decl":"theorem limNthHom_spec (r : R) :\n    ∀ ε : ℝ, 0 < ε → ∃ N : ℕ, ∀ n ≥ N, ‖limNthHom f_compat r - nthHom f r n‖ < ε := by\n  intro ε hε\n  obtain ⟨ε', hε'0, hε'⟩ : ∃ v : ℚ, (0 : ℝ) < v ∧ ↑v < ε := exists_rat_btwn hε\n  norm_cast at hε'0\n  obtain ⟨N, hN⟩ := padicNormE.defn (nthHomSeq f_compat r) hε'0\n  use N\n  intro n hn\n  apply _root_.lt_trans _ hε'\n  change (padicNormE _  : ℝ) < _\n  norm_cast\n  exact hN _ hn\n\n"}
{"name":"PadicInt.limNthHom_zero","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\n⊢ Eq (PadicInt.limNthHom f_compat 0) 0","decl":"theorem limNthHom_zero : limNthHom f_compat 0 = 0 := by simp [limNthHom]; rfl\n\n"}
{"name":"PadicInt.limNthHom_one","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\n⊢ Eq (PadicInt.limNthHom f_compat 1) 1","decl":"theorem limNthHom_one : limNthHom f_compat 1 = 1 :=\n  Subtype.ext <| Quot.sound <| nthHomSeq_one f_compat\n\n"}
{"name":"PadicInt.limNthHom_add","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr s : R\n⊢ Eq (PadicInt.limNthHom f_compat (HAdd.hAdd r s)) (HAdd.hAdd (PadicInt.limNthHom f_compat r) (PadicInt.limNthHom f_compat s))","decl":"theorem limNthHom_add (r s : R) :\n    limNthHom f_compat (r + s) = limNthHom f_compat r + limNthHom f_compat s :=\n  Subtype.ext <| Quot.sound <| nthHomSeq_add f_compat _ _\n\n"}
{"name":"PadicInt.limNthHom_mul","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr s : R\n⊢ Eq (PadicInt.limNthHom f_compat (HMul.hMul r s)) (HMul.hMul (PadicInt.limNthHom f_compat r) (PadicInt.limNthHom f_compat s))","decl":"theorem limNthHom_mul (r s : R) :\n    limNthHom f_compat (r * s) = limNthHom f_compat r * limNthHom f_compat s :=\n  Subtype.ext <| Quot.sound <| nthHomSeq_mul f_compat _ _\n\n-- TODO: generalize this to arbitrary complete discrete valuation rings\n"}
{"name":"PadicInt.lift_sub_val_mem_span","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nr : R\nn : Nat\n⊢ Membership.mem (Ideal.span (Singleton.singleton (HPow.hPow (↑p) n))) (HSub.hSub ((PadicInt.lift f_compat) r) ↑((f n) r).val)","decl":"theorem lift_sub_val_mem_span (r : R) (n : ℕ) :\n    lift f_compat r - (f n r).val ∈ (Ideal.span {(p : ℤ_[p]) ^ n}) := by\n  obtain ⟨k, hk⟩ :=\n    limNthHom_spec f_compat r _\n      (show (0 : ℝ) < (p : ℝ) ^ (-n : ℤ) from zpow_pos (mod_cast hp_prime.1.pos) _)\n  have := le_of_lt (hk (max n k) (le_max_right _ _))\n  rw [norm_le_pow_iff_mem_span_pow] at this\n  dsimp [lift]\n  rw [sub_eq_sub_add_sub (limNthHom f_compat r) _ ↑(nthHom f r (max n k))]\n  apply Ideal.add_mem _ _ this\n  rw [Ideal.mem_span_singleton]\n  convert\n    (Int.castRingHom ℤ_[p]).map_dvd (pow_dvd_nthHom_sub f_compat r n (max n k) (le_max_left _ _))\n  · rw [map_pow]; rfl\n  · rw [map_sub]; rfl\n\n"}
{"name":"PadicInt.lift_spec","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\nn : Nat\n⊢ Eq ((PadicInt.toZModPow n).comp (PadicInt.lift f_compat)) (f n)","decl":"/-- One part of the universal property of `ℤ_[p]` as a projective limit.\nSee also `PadicInt.lift_unique`.\n-/\ntheorem lift_spec (n : ℕ) : (toZModPow n).comp (lift f_compat) = f n := by\n  ext r\n  rw [RingHom.comp_apply, ← ZMod.natCast_zmod_val (f n r), ← map_natCast <| toZModPow n, ←\n    sub_eq_zero, ← RingHom.map_sub, ← RingHom.mem_ker, ker_toZModPow]\n  apply lift_sub_val_mem_span\n\n"}
{"name":"PadicInt.lift_unique","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"R : Type u_1\ninst✝ : NonAssocSemiring R\np : Nat\nf : (k : Nat) → RingHom R (ZMod (HPow.hPow p k))\nhp_prime : Fact (Nat.Prime p)\nf_compat : ∀ (k1 k2 : Nat) (hk : LE.le k1 k2), Eq ((ZMod.castHom ⋯ (ZMod (HPow.hPow p k1))).comp (f k2)) (f k1)\ng : RingHom R (PadicInt p)\nhg : ∀ (n : Nat), Eq ((PadicInt.toZModPow n).comp g) (f n)\n⊢ Eq (PadicInt.lift f_compat) g","decl":"/-- One part of the universal property of `ℤ_[p]` as a projective limit.\nSee also `PadicInt.lift_spec`.\n-/\ntheorem lift_unique (g : R →+* ℤ_[p]) (hg : ∀ n, (toZModPow n).comp g = f n) :\n    lift f_compat = g := by\n  ext1 r\n  apply eq_of_forall_dist_le\n  intro ε hε\n  obtain ⟨n, hn⟩ := exists_pow_neg_lt p hε\n  apply le_trans _ (le_of_lt hn)\n  rw [dist_eq_norm, norm_le_pow_iff_mem_span_pow, ← ker_toZModPow, RingHom.mem_ker,\n    RingHom.map_sub, ← RingHom.comp_apply, ← RingHom.comp_apply, lift_spec, hg, sub_self]\n\n"}
{"name":"PadicInt.lift_self","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nz : PadicInt p\n⊢ Eq ((PadicInt.lift ⋯) z) z","decl":"@[simp]\ntheorem lift_self (z : ℤ_[p]) : lift zmod_cast_comp_toZModPow z = z := by\n  show _ = RingHom.id _ z\n  rw [lift_unique zmod_cast_comp_toZModPow (RingHom.id ℤ_[p])]\n  intro; rw [RingHom.comp_id]\n\n"}
{"name":"PadicInt.ext_of_toZModPow","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nx y : PadicInt p\n⊢ Iff (∀ (n : Nat), Eq ((PadicInt.toZModPow n) x) ((PadicInt.toZModPow n) y)) (Eq x y)","decl":"theorem ext_of_toZModPow {x y : ℤ_[p]} : (∀ n, toZModPow n x = toZModPow n y) ↔ x = y := by\n  constructor\n  · intro h\n    rw [← lift_self x, ← lift_self y]\n    simp (config := { unfoldPartialApp := true }) [lift, limNthHom, nthHom, h]\n  · rintro rfl _\n    rfl\n\n"}
{"name":"PadicInt.toZModPow_eq_iff_ext","module":"Mathlib.NumberTheory.Padics.RingHoms","initialProofState":"p : Nat\nhp_prime : Fact (Nat.Prime p)\nR : Type u_1\ninst✝ : NonAssocSemiring R\ng g' : RingHom R (PadicInt p)\n⊢ Iff (∀ (n : Nat), Eq ((PadicInt.toZModPow n).comp g) ((PadicInt.toZModPow n).comp g')) (Eq g g')","decl":"theorem toZModPow_eq_iff_ext {R : Type*} [NonAssocSemiring R] {g g' : R →+* ℤ_[p]} :\n    (∀ n, (toZModPow n).comp g = (toZModPow n).comp g') ↔ g = g' := by\n  constructor\n  · intro hg\n    ext x : 1\n    apply ext_of_toZModPow.mp\n    intro n\n    show (toZModPow n).comp g x = (toZModPow n).comp g' x\n    rw [hg n]\n  · rintro rfl _\n    rfl\n\n"}
