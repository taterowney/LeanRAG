{"name":"LightCondSet.continuous_coinducingCoprod","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : LightCondSet\nS : LightProfinite\nx : X.val.obj { unop := S }\n⊢ Continuous fun a => LightCondSet.coinducingCoprod X ⟨⟨S, x⟩, a⟩","decl":"lemma continuous_coinducingCoprod {S : LightProfinite.{u}} (x : X.val.obj ⟨S⟩) :\n    Continuous fun a ↦ (X.coinducingCoprod ⟨⟨S, x⟩, a⟩) := by\n  suffices ∀ (i : (T : LightProfinite.{u}) × X.val.obj ⟨T⟩),\n      Continuous (fun (a : i.fst) ↦ X.coinducingCoprod ⟨i, a⟩) from this ⟨_, _⟩\n  rw [← continuous_sigma_iff]\n  apply continuous_coinduced_rng\n\n"}
{"name":"LightCondSet.toTopCatMap_apply","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X Y : LightCondSet\nf : Quiver.Hom X Y\na✝ : X.val.obj { unop := LightProfinite.of PUnit.{u + 1} }\n⊢ Eq ((LightCondSet.toTopCatMap f) a✝) (f.val.app { unop := LightProfinite.of PUnit.{u + 1} } a✝)","decl":"/-- The map part of the functor `LightCondSet ⥤ TopCat` -/\n@[simps]\ndef toTopCatMap : X.toTopCat ⟶ Y.toTopCat where\n  toFun := f.val.app ⟨LightProfinite.of PUnit⟩\n  continuous_toFun := by\n    rw [continuous_coinduced_dom]\n    apply continuous_sigma\n    intro ⟨S, x⟩\n    simp only [Function.comp_apply, coinducingCoprod]\n    rw [show (fun (a : S) ↦ f.val.app ⟨of PUnit⟩ (X.val.map ((of PUnit.{u+1}).const a).op x)) = _\n      from funext fun a ↦ NatTrans.naturality_apply f.val ((of PUnit.{u+1}).const a).op x]\n    exact continuous_coinducingCoprod _ _\n\n"}
{"name":"lightCondSetToTopCat_map","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X✝ Y✝ : LightCondSet\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (lightCondSetToTopCat.map f) (LightCondSet.toTopCatMap f)","decl":"/-- The functor `LightCondSet ⥤ TopCat` -/\n@[simps]\ndef _root_.lightCondSetToTopCat : LightCondSet.{u} ⥤ TopCat.{u} where\n  obj X := X.toTopCat\n  map f := toTopCatMap f\n\n"}
{"name":"lightCondSetToTopCat_obj","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : LightCondSet\n⊢ Eq (lightCondSetToTopCat.obj X) X.toTopCat","decl":"/-- The functor `LightCondSet ⥤ TopCat` -/\n@[simps]\ndef _root_.lightCondSetToTopCat : LightCondSet.{u} ⥤ TopCat.{u} where\n  obj X := X.toTopCat\n  map f := toTopCatMap f\n\n"}
{"name":"LightCondSet.topCatAdjunctionCounit_bijective","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : TopCat\n⊢ Function.Bijective ⇑(LightCondSet.topCatAdjunctionCounit X)","decl":"lemma topCatAdjunctionCounit_bijective (X : TopCat.{u}) :\n    Function.Bijective (topCatAdjunctionCounit X) :=\n  (topCatAdjunctionCounitEquiv X).bijective\n\n"}
{"name":"LightCondSet.topCatAdjunctionUnit_val_app_apply","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : LightCondSet\nS : Opposite LightProfinite\nx : X.val.obj S\ns : ↑((CompHausLike.compHausLikeToTop fun X => And (TotallyDisconnectedSpace ↑X) (SecondCountableTopology ↑X)).obj (Opposite.unop S))\n⊢ Eq ((X.topCatAdjunctionUnit.val.app S x) s) (X.val.map (CompHausLike.const (LightProfinite.of PUnit.{u + 1}) s).op x)","decl":"/-- The unit of the adjunction `lightCondSetToTopCat ⊣ topCatToLightCondSet` -/\n@[simps val_app val_app_apply]\ndef topCatAdjunctionUnit (X : LightCondSet.{u}) : X ⟶ X.toTopCat.toLightCondSet where\n  val := {\n    app := fun S x ↦ {\n      toFun := fun s ↦ X.val.map ((of PUnit.{u+1}).const s).op x\n      continuous_toFun := by\n        suffices ∀ (i : (T : LightProfinite.{u}) × X.val.obj ⟨T⟩),\n          Continuous (fun (a : i.fst) ↦ X.coinducingCoprod ⟨i, a⟩) from this ⟨_, _⟩\n        rw [← continuous_sigma_iff]\n        apply continuous_coinduced_rng }\n    naturality := fun _ _ _ ↦ by\n      ext\n      simp only [TopCat.toSheafCompHausLike_val_obj, CompHausLike.compHausLikeToTop_obj,\n        Opposite.op_unop, types_comp_apply, TopCat.toSheafCompHausLike_val_map,\n        ← FunctorToTypes.map_comp_apply]\n      rfl }\n\n"}
{"name":"LightCondSet.topCatAdjunctionUnit_val_app","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : LightCondSet\nS : Opposite LightProfinite\nx : X.val.obj S\n⊢ Eq (X.topCatAdjunctionUnit.val.app S x) { toFun := fun s => X.val.map (CompHausLike.const (LightProfinite.of PUnit.{u + 1}) s).op x, continuous_toFun := ⋯ }","decl":"/-- The unit of the adjunction `lightCondSetToTopCat ⊣ topCatToLightCondSet` -/\n@[simps val_app val_app_apply]\ndef topCatAdjunctionUnit (X : LightCondSet.{u}) : X ⟶ X.toTopCat.toLightCondSet where\n  val := {\n    app := fun S x ↦ {\n      toFun := fun s ↦ X.val.map ((of PUnit.{u+1}).const s).op x\n      continuous_toFun := by\n        suffices ∀ (i : (T : LightProfinite.{u}) × X.val.obj ⟨T⟩),\n          Continuous (fun (a : i.fst) ↦ X.coinducingCoprod ⟨i, a⟩) from this ⟨_, _⟩\n        rw [← continuous_sigma_iff]\n        apply continuous_coinduced_rng }\n    naturality := fun _ _ _ ↦ by\n      ext\n      simp only [TopCat.toSheafCompHausLike_val_obj, CompHausLike.compHausLikeToTop_obj,\n        Opposite.op_unop, types_comp_apply, TopCat.toSheafCompHausLike_val_map,\n        ← FunctorToTypes.map_comp_apply]\n      rfl }\n\n"}
{"name":"LightCondSet.instEpiTopCatAppCounitTopCatAdjunction","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : TopCat\n⊢ CategoryTheory.Epi (LightCondSet.topCatAdjunction.counit.app X)","decl":"instance (X : TopCat) : Epi (topCatAdjunction.counit.app X) := by\n  rw [TopCat.epi_iff_surjective]\n  exact (topCatAdjunctionCounit_bijective _).2\n\n"}
{"name":"LightCondSet.instFaithfulTopCatTopCatToLightCondSet","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"⊢ topCatToLightCondSet.Faithful","decl":"instance : topCatToLightCondSet.Faithful := topCatAdjunction.faithful_R_of_epi_counit_app\n\n"}
{"name":"LightCondSet.instSequentialSpaceαTopologicalSpaceToTopCat","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : LightCondSet\n⊢ SequentialSpace ↑X.toTopCat","decl":"instance (X : LightCondSet.{u}) : SequentialSpace X.toTopCat := by\n  apply SequentialSpace.coinduced\n\n"}
{"name":"LightCondSet.instSequentialSpaceαTopologicalSpaceObjTopCatLightCondSetToTopCat","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"X : LightCondSet\n⊢ SequentialSpace ↑(lightCondSetToTopCat.obj X)","decl":"instance (X : LightCondSet.{u}) : SequentialSpace (lightCondSetToTopCat.obj X) :=\n  inferInstanceAs (SequentialSpace X.toTopCat)\n\n"}
{"name":"LightCondSet.instIsIsoFunctorSequentialCounitSequentialAdjunction","module":"Mathlib.Condensed.Light.TopCatAdjunction","initialProofState":"⊢ CategoryTheory.IsIso LightCondSet.sequentialAdjunction.counit","decl":"instance : IsIso sequentialAdjunction.{0}.counit := by\n  rw [NatTrans.isIso_iff_isIso_app]\n  intro X\n  exact inferInstanceAs (IsIso (sequentialAdjunctionCounitIso X).hom)\n\n"}
