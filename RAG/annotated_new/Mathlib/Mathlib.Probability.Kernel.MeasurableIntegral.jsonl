{"name":"ProbabilityTheory.measurableSet_kernel_integrable","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nÎº : ProbabilityTheory.Kernel Î± Î²\nE : Type u_4\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : ProbabilityTheory.IsSFiniteKernel Îº\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nâŠ¢ MeasurableSet (setOf fun x => MeasureTheory.Integrable (f x) (Îº x))","decl":"theorem ProbabilityTheory.measurableSet_kernel_integrable â¦ƒf : Î± â†’ Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable (uncurry f)) :\n    MeasurableSet {x | Integrable (f x) (Îº x)} := by\n  simp_rw [Integrable, hf.of_uncurry_left.aestronglyMeasurable, true_and]\n  exact measurableSet_lt (Measurable.lintegral_kernel_prod_right hf.enorm) measurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_right","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nÎº : ProbabilityTheory.Kernel Î± Î²\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\ninstâœ : NormedSpace Real E\nf : Î± â†’ Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral (Îº x) fun y => f x y","decl":"theorem StronglyMeasurable.integral_kernel_prod_right â¦ƒf : Î± â†’ Î² â†’ Eâ¦„\n    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun x => âˆ« y, f x y âˆ‚Îº x := by\n  classical\n  by_cases hE : CompleteSpace E; swap\n  Â· simp [integral, hE, stronglyMeasurable_const]\n  borelize E\n  haveI : TopologicalSpace.SeparableSpace (range (uncurry f) âˆª {0} : Set E) :=\n    hf.separableSpace_range_union_singleton\n  let s : â„• â†’ SimpleFunc (Î± Ã— Î²) E :=\n    SimpleFunc.approxOn _ hf.measurable (range (uncurry f) âˆª {0}) 0 (by simp)\n  let s' : â„• â†’ Î± â†’ SimpleFunc Î² E := fun n x => (s n).comp (Prod.mk x) measurable_prod_mk_left\n  let f' : â„• â†’ Î± â†’ E := fun n =>\n    {x | Integrable (f x) (Îº x)}.indicator fun x => (s' n x).integral (Îº x)\n  have hf' : âˆ€ n, StronglyMeasurable (f' n) := by\n    intro n; refine StronglyMeasurable.indicator ?_ (measurableSet_kernel_integrable hf)\n    have : âˆ€ x, ((s' n x).range.filter fun x => x â‰  0) âŠ† (s n).range := by\n      intro x; refine Finset.Subset.trans (Finset.filter_subset _ _) ?_; intro y\n      simp_rw [SimpleFunc.mem_range]; rintro âŸ¨z, rflâŸ©; exact âŸ¨(x, z), rflâŸ©\n    simp only [SimpleFunc.integral_eq_sum_of_subset (this _)]\n    refine Finset.stronglyMeasurable_sum _ fun x _ => ?_\n    refine (Measurable.ennreal_toReal ?_).stronglyMeasurable.smul_const _\n    simp only [s', SimpleFunc.coe_comp, preimage_comp]\n    apply Kernel.measurable_kernel_prod_mk_left\n    exact (s n).measurableSet_fiber x\n  have h2f' : Tendsto f' atTop (ğ“ fun x : Î± => âˆ« y : Î², f x y âˆ‚Îº x) := by\n    rw [tendsto_pi_nhds]; intro x\n    by_cases hfx : Integrable (f x) (Îº x)\n    Â· have (n) : Integrable (s' n x) (Îº x) := by\n        apply (hfx.norm.add hfx.norm).mono' (s' n x).aestronglyMeasurable\n        filter_upwards with y\n        simp_rw [s', SimpleFunc.coe_comp]; exact SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n      simp only [f',  hfx, SimpleFunc.integral_eq_integral _ (this _), indicator_of_mem,\n        mem_setOf_eq]\n      refine\n        tendsto_integral_of_dominated_convergence (fun y => â€–f x yâ€– + â€–f x yâ€–)\n          (fun n => (s' n x).aestronglyMeasurable) (hfx.norm.add hfx.norm) ?_ ?_\n      Â· -- Porting note: was\n        -- exact fun n => Eventually.of_forall fun y =>\n        --   SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n        exact fun n => Eventually.of_forall fun y =>\n          SimpleFunc.norm_approxOn_zero_le hf.measurable (by simp) (x, y) n\n      Â· refine Eventually.of_forall fun y => SimpleFunc.tendsto_approxOn hf.measurable (by simp) ?_\n        apply subset_closure\n        simp [-uncurry_apply_pair]\n    Â· simp [f', hfx, integral_undef]\n  exact stronglyMeasurable_of_tendsto _ hf' h2f'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_right'","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nÎº : ProbabilityTheory.Kernel Î± Î²\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\ninstâœ : NormedSpace Real E\nf : Prod Î± Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral (Îº x) fun y => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_right' â¦ƒf : Î± Ã— Î² â†’ Eâ¦„ (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => âˆ« y, f (x, y) âˆ‚Îº x := by\n  rw [â† uncurry_curry f] at hf\n  exact hf.integral_kernel_prod_right\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_right''","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\na : Î±\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\ninstâœ : NormedSpace Real E\nf : Prod Î² Î³ â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral (Î· { fst := a, snd := x }) fun y => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_right'' {f : Î² Ã— Î³ â†’ E}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => âˆ« y, f (x, y) âˆ‚Î· (a, x) := by\n  change\n    StronglyMeasurable\n      ((fun x => âˆ« y, (fun u : (Î± Ã— Î²) Ã— Î³ => f (u.1.2, u.2)) (x, y) âˆ‚Î· x) âˆ˜ fun x => (a, x))\n  apply StronglyMeasurable.comp_measurable _ (measurable_prod_mk_left (m := mÎ±))\n  Â· have := MeasureTheory.StronglyMeasurable.integral_kernel_prod_right' (Îº := Î·)\n      (hf.comp_measurable (measurable_fst.snd.prod_mk measurable_snd))\n    simpa using this\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_left","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nÎº : ProbabilityTheory.Kernel Î± Î²\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\ninstâœ : NormedSpace Real E\nf : Î² â†’ Î± â†’ E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\nâŠ¢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral (Îº y) fun x => f x y","decl":"theorem StronglyMeasurable.integral_kernel_prod_left â¦ƒf : Î² â†’ Î± â†’ Eâ¦„\n    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun y => âˆ« x, f x y âˆ‚Îº y :=\n  (hf.comp_measurable measurable_swap).integral_kernel_prod_right'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_left'","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nÎº : ProbabilityTheory.Kernel Î± Î²\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Îº\ninstâœ : NormedSpace Real E\nf : Prod Î² Î± â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral (Îº y) fun x => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_left' â¦ƒf : Î² Ã— Î± â†’ Eâ¦„ (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun y => âˆ« x, f (x, y) âˆ‚Îº y :=\n  (hf.comp_measurable measurable_swap).integral_kernel_prod_right'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_left''","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nmÎ± : MeasurableSpace Î±\nmÎ² : MeasurableSpace Î²\nmÎ³ : MeasurableSpace Î³\nÎ· : ProbabilityTheory.Kernel (Prod Î± Î²) Î³\na : Î±\nE : Type u_4\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : ProbabilityTheory.IsSFiniteKernel Î·\ninstâœ : NormedSpace Real E\nf : Prod Î³ Î² â†’ E\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral (Î· { fst := a, snd := y }) fun x => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_left'' {f : Î³ Ã— Î² â†’ E} (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun y => âˆ« x, f (x, y) âˆ‚Î· (a, y) := by\n  change\n    StronglyMeasurable\n      ((fun y => âˆ« x, (fun u : Î³ Ã— Î± Ã— Î² => f (u.1, u.2.2)) (x, y) âˆ‚Î· y) âˆ˜ fun x => (a, x))\n  apply StronglyMeasurable.comp_measurable _ (measurable_prod_mk_left (m := mÎ±))\n  Â· have := MeasureTheory.StronglyMeasurable.integral_kernel_prod_left' (Îº := Î·)\n      (hf.comp_measurable (measurable_fst.prod_mk measurable_snd.snd))\n    simpa using this\n\n"}
