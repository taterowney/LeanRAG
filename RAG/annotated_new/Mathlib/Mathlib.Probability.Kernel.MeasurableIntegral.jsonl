{"name":"ProbabilityTheory.measurableSet_kernel_integrable","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nE : Type u_4\ninst✝¹ : NormedAddCommGroup E\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\nf : α → β → E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\n⊢ MeasurableSet (setOf fun x => MeasureTheory.Integrable (f x) (κ x))","decl":"theorem ProbabilityTheory.measurableSet_kernel_integrable ⦃f : α → β → E⦄\n    (hf : StronglyMeasurable (uncurry f)) :\n    MeasurableSet {x | Integrable (f x) (κ x)} := by\n  simp_rw [Integrable, hf.of_uncurry_left.aestronglyMeasurable, true_and]\n  exact measurableSet_lt (Measurable.lintegral_kernel_prod_right hf.enorm) measurable_const\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_right","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : NormedSpace Real E\nf : α → β → E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\n⊢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral (κ x) fun y => f x y","decl":"theorem StronglyMeasurable.integral_kernel_prod_right ⦃f : α → β → E⦄\n    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun x => ∫ y, f x y ∂κ x := by\n  classical\n  by_cases hE : CompleteSpace E; swap\n  · simp [integral, hE, stronglyMeasurable_const]\n  borelize E\n  haveI : TopologicalSpace.SeparableSpace (range (uncurry f) ∪ {0} : Set E) :=\n    hf.separableSpace_range_union_singleton\n  let s : ℕ → SimpleFunc (α × β) E :=\n    SimpleFunc.approxOn _ hf.measurable (range (uncurry f) ∪ {0}) 0 (by simp)\n  let s' : ℕ → α → SimpleFunc β E := fun n x => (s n).comp (Prod.mk x) measurable_prod_mk_left\n  let f' : ℕ → α → E := fun n =>\n    {x | Integrable (f x) (κ x)}.indicator fun x => (s' n x).integral (κ x)\n  have hf' : ∀ n, StronglyMeasurable (f' n) := by\n    intro n; refine StronglyMeasurable.indicator ?_ (measurableSet_kernel_integrable hf)\n    have : ∀ x, ((s' n x).range.filter fun x => x ≠ 0) ⊆ (s n).range := by\n      intro x; refine Finset.Subset.trans (Finset.filter_subset _ _) ?_; intro y\n      simp_rw [SimpleFunc.mem_range]; rintro ⟨z, rfl⟩; exact ⟨(x, z), rfl⟩\n    simp only [SimpleFunc.integral_eq_sum_of_subset (this _)]\n    refine Finset.stronglyMeasurable_sum _ fun x _ => ?_\n    refine (Measurable.ennreal_toReal ?_).stronglyMeasurable.smul_const _\n    simp only [s', SimpleFunc.coe_comp, preimage_comp]\n    apply Kernel.measurable_kernel_prod_mk_left\n    exact (s n).measurableSet_fiber x\n  have h2f' : Tendsto f' atTop (𝓝 fun x : α => ∫ y : β, f x y ∂κ x) := by\n    rw [tendsto_pi_nhds]; intro x\n    by_cases hfx : Integrable (f x) (κ x)\n    · have (n) : Integrable (s' n x) (κ x) := by\n        apply (hfx.norm.add hfx.norm).mono' (s' n x).aestronglyMeasurable\n        filter_upwards with y\n        simp_rw [s', SimpleFunc.coe_comp]; exact SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n      simp only [f',  hfx, SimpleFunc.integral_eq_integral _ (this _), indicator_of_mem,\n        mem_setOf_eq]\n      refine\n        tendsto_integral_of_dominated_convergence (fun y => ‖f x y‖ + ‖f x y‖)\n          (fun n => (s' n x).aestronglyMeasurable) (hfx.norm.add hfx.norm) ?_ ?_\n      · -- Porting note: was\n        -- exact fun n => Eventually.of_forall fun y =>\n        --   SimpleFunc.norm_approxOn_zero_le _ _ (x, y) n\n        exact fun n => Eventually.of_forall fun y =>\n          SimpleFunc.norm_approxOn_zero_le hf.measurable (by simp) (x, y) n\n      · refine Eventually.of_forall fun y => SimpleFunc.tendsto_approxOn hf.measurable (by simp) ?_\n        apply subset_closure\n        simp [-uncurry_apply_pair]\n    · simp [f', hfx, integral_undef]\n  exact stronglyMeasurable_of_tendsto _ hf' h2f'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_right'","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : NormedSpace Real E\nf : Prod α β → E\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral (κ x) fun y => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_right' ⦃f : α × β → E⦄ (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun x => ∫ y, f (x, y) ∂κ x := by\n  rw [← uncurry_curry f] at hf\n  exact hf.integral_kernel_prod_right\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_right''","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel (Prod α β) γ\na : α\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel η\ninst✝ : NormedSpace Real E\nf : Prod β γ → E\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun x => MeasureTheory.integral (η { fst := a, snd := x }) fun y => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_right'' {f : β × γ → E}\n    (hf : StronglyMeasurable f) : StronglyMeasurable fun x => ∫ y, f (x, y) ∂η (a, x) := by\n  change\n    StronglyMeasurable\n      ((fun x => ∫ y, (fun u : (α × β) × γ => f (u.1.2, u.2)) (x, y) ∂η x) ∘ fun x => (a, x))\n  apply StronglyMeasurable.comp_measurable _ (measurable_prod_mk_left (m := mα))\n  · have := MeasureTheory.StronglyMeasurable.integral_kernel_prod_right' (κ := η)\n      (hf.comp_measurable (measurable_fst.snd.prod_mk measurable_snd))\n    simpa using this\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_left","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : NormedSpace Real E\nf : β → α → E\nhf : MeasureTheory.StronglyMeasurable (Function.uncurry f)\n⊢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral (κ y) fun x => f x y","decl":"theorem StronglyMeasurable.integral_kernel_prod_left ⦃f : β → α → E⦄\n    (hf : StronglyMeasurable (uncurry f)) : StronglyMeasurable fun y => ∫ x, f x y ∂κ y :=\n  (hf.comp_measurable measurable_swap).integral_kernel_prod_right'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_left'","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : NormedSpace Real E\nf : Prod β α → E\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral (κ y) fun x => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_left' ⦃f : β × α → E⦄ (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun y => ∫ x, f (x, y) ∂κ y :=\n  (hf.comp_measurable measurable_swap).integral_kernel_prod_right'\n\n"}
{"name":"MeasureTheory.StronglyMeasurable.integral_kernel_prod_left''","module":"Mathlib.Probability.Kernel.MeasurableIntegral","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nη : ProbabilityTheory.Kernel (Prod α β) γ\na : α\nE : Type u_4\ninst✝² : NormedAddCommGroup E\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel η\ninst✝ : NormedSpace Real E\nf : Prod γ β → E\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.StronglyMeasurable fun y => MeasureTheory.integral (η { fst := a, snd := y }) fun x => f { fst := x, snd := y }","decl":"theorem StronglyMeasurable.integral_kernel_prod_left'' {f : γ × β → E} (hf : StronglyMeasurable f) :\n    StronglyMeasurable fun y => ∫ x, f (x, y) ∂η (a, y) := by\n  change\n    StronglyMeasurable\n      ((fun y => ∫ x, (fun u : γ × α × β => f (u.1, u.2.2)) (x, y) ∂η y) ∘ fun x => (a, x))\n  apply StronglyMeasurable.comp_measurable _ (measurable_prod_mk_left (m := mα))\n  · have := MeasureTheory.StronglyMeasurable.integral_kernel_prod_left' (κ := η)\n      (hf.comp_measurable (measurable_fst.prod_mk measurable_snd.snd))\n    simpa using this\n\n"}
