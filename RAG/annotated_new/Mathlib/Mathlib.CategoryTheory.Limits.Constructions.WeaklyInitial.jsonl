{"name":"CategoryTheory.has_weakly_initial_of_weakly_initial_set_and_hasProducts","module":"Mathlib.CategoryTheory.Limits.Constructions.WeaklyInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasProducts C\nÎ¹ : Type v\nB : Î¹ â†’ C\nhB : âˆ€ (A : C), Exists fun i => Nonempty (Quiver.Hom (B i) A)\nâŠ¢ Exists fun T => âˆ€ (X : C), Nonempty (Quiver.Hom T X)","decl":"/--\nIf `C` has (small) products and a small weakly initial set of objects, then it has a weakly initial\nobject.\n-/\ntheorem has_weakly_initial_of_weakly_initial_set_and_hasProducts [HasProducts.{v} C] {Î¹ : Type v}\n    {B : Î¹ â†’ C} (hB : âˆ€ A : C, âˆƒ i, Nonempty (B i âŸ¶ A)) : âˆƒ T : C, âˆ€ X, Nonempty (T âŸ¶ X) :=\n  âŸ¨âˆá¶œ B, fun X => âŸ¨Pi.Ï€ _ _ â‰« (hB X).choose_spec.someâŸ©âŸ©\n\n"}
{"name":"CategoryTheory.hasInitial_of_weakly_initial_and_hasWideEqualizers","module":"Mathlib.CategoryTheory.Limits.Constructions.WeaklyInitial","initialProofState":"C : Type u\ninstâœÂ¹ : CategoryTheory.Category.{v, u} C\ninstâœ : CategoryTheory.Limits.HasWideEqualizers C\nT : C\nhT : âˆ€ (X : C), Nonempty (Quiver.Hom T X)\nâŠ¢ CategoryTheory.Limits.HasInitial C","decl":"/-- If `C` has (small) wide equalizers and a weakly initial object, then it has an initial object.\n\nThe initial object is constructed as the wide equalizer of all endomorphisms on the given weakly\ninitial object.\n-/\ntheorem hasInitial_of_weakly_initial_and_hasWideEqualizers [HasWideEqualizers.{v} C] {T : C}\n    (hT : âˆ€ X, Nonempty (T âŸ¶ X)) : HasInitial C := by\n  let endos := T âŸ¶ T\n  let i := wideEqualizer.Î¹ (id : endos â†’ endos)\n  haveI : Nonempty endos := âŸ¨ğŸ™ _âŸ©\n  have : âˆ€ X : C, Unique (wideEqualizer (id : endos â†’ endos) âŸ¶ X) := by\n    intro X\n    refine âŸ¨âŸ¨i â‰« Classical.choice (hT X)âŸ©, fun a => ?_âŸ©\n    let E := equalizer a (i â‰« Classical.choice (hT _))\n    let e : E âŸ¶ wideEqualizer id := equalizer.Î¹ _ _\n    let h : T âŸ¶ E := Classical.choice (hT E)\n    have : ((i â‰« h) â‰« e) â‰« i = i â‰« ğŸ™ _ := by\n      rw [Category.assoc, Category.assoc]\n      apply wideEqualizer.condition (id : endos â†’ endos) (h â‰« e â‰« i)\n    rw [Category.comp_id, cancel_mono_id i] at this\n    haveI : IsSplitEpi e := IsSplitEpi.mk' âŸ¨i â‰« h, thisâŸ©\n    rw [â† cancel_epi e]\n    apply equalizer.condition\n  exact hasInitial_of_unique (wideEqualizer (id : endos â†’ endos))\n\n"}
