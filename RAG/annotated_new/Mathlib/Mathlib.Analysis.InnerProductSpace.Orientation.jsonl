{"name":"OrthonormalBasis.det_to_matrix_orthonormalBasis_of_same_orientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne f : OrthonormalBasis ι Real E\nh : Eq e.toBasis.orientation f.toBasis.orientation\n⊢ Eq (e.toBasis.det ⇑f) 1","decl":"/-- The change-of-basis matrix between two orthonormal bases with the same orientation has\ndeterminant 1. -/\ntheorem det_to_matrix_orthonormalBasis_of_same_orientation\n    (h : e.toBasis.orientation = f.toBasis.orientation) : e.toBasis.det f = 1 := by\n  apply (e.det_to_matrix_orthonormalBasis_real f).resolve_right\n  have : 0 < e.toBasis.det f := by\n    rw [e.toBasis.orientation_eq_iff_det_pos] at h\n    simpa using h\n  linarith\n\n"}
{"name":"OrthonormalBasis.det_to_matrix_orthonormalBasis_of_opposite_orientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne f : OrthonormalBasis ι Real E\nh : Ne e.toBasis.orientation f.toBasis.orientation\n⊢ Eq (e.toBasis.det ⇑f) (-1)","decl":"/-- The change-of-basis matrix between two orthonormal bases with the opposite orientations has\ndeterminant -1. -/\ntheorem det_to_matrix_orthonormalBasis_of_opposite_orientation\n    (h : e.toBasis.orientation ≠ f.toBasis.orientation) : e.toBasis.det f = -1 := by\n  contrapose! h\n  simp [e.toBasis.orientation_eq_iff_det_pos,\n    (e.det_to_matrix_orthonormalBasis_real f).resolve_right h]\n\n"}
{"name":"OrthonormalBasis.same_orientation_iff_det_eq_det","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne f : OrthonormalBasis ι Real E\n⊢ Iff (Eq e.toBasis.det f.toBasis.det) (Eq e.toBasis.orientation f.toBasis.orientation)","decl":"/-- Two orthonormal bases with the same orientation determine the same \"determinant\" top-dimensional\nform on `E`, and conversely. -/\ntheorem same_orientation_iff_det_eq_det :\n    e.toBasis.det = f.toBasis.det ↔ e.toBasis.orientation = f.toBasis.orientation := by\n  constructor\n  · intro h\n    dsimp [Basis.orientation]\n    congr\n  · intro h\n    rw [e.toBasis.det.eq_smul_basis_det f.toBasis]\n    simp [e.det_to_matrix_orthonormalBasis_of_same_orientation f h]\n\n"}
{"name":"OrthonormalBasis.det_eq_neg_det_of_opposite_orientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝³ : NormedAddCommGroup E\ninst✝² : InnerProductSpace Real E\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\ne f : OrthonormalBasis ι Real E\nh : Ne e.toBasis.orientation f.toBasis.orientation\n⊢ Eq e.toBasis.det (Neg.neg f.toBasis.det)","decl":"/-- Two orthonormal bases with opposite orientations determine opposite \"determinant\"\ntop-dimensional forms on `E`. -/\ntheorem det_eq_neg_det_of_opposite_orientation (h : e.toBasis.orientation ≠ f.toBasis.orientation) :\n    e.toBasis.det = -f.toBasis.det := by\n  rw [e.toBasis.det.eq_smul_basis_det f.toBasis]\n  -- Porting note: added `neg_one_smul` with explicit type\n  simp [e.det_to_matrix_orthonormalBasis_of_opposite_orientation f h,\n    neg_one_smul ℝ (M := E [⋀^ι]→ₗ[ℝ] ℝ)]\n\n"}
{"name":"OrthonormalBasis.orthonormal_adjustToOrientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nι : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ne : OrthonormalBasis ι Real E\nx : Orientation Real E ι\ninst✝ : Nonempty ι\n⊢ Orthonormal Real ⇑(e.toBasis.adjustToOrientation x)","decl":"/-- `OrthonormalBasis.adjustToOrientation`, applied to an orthonormal basis, preserves the\nproperty of orthonormality. -/\ntheorem orthonormal_adjustToOrientation : Orthonormal ℝ (e.toBasis.adjustToOrientation x) := by\n  apply e.orthonormal.orthonormal_of_forall_eq_or_eq_neg\n  simpa using e.toBasis.adjustToOrientation_apply_eq_or_eq_neg x\n\n"}
{"name":"OrthonormalBasis.toBasis_adjustToOrientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nι : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ne : OrthonormalBasis ι Real E\nx : Orientation Real E ι\ninst✝ : Nonempty ι\n⊢ Eq (e.adjustToOrientation x).toBasis (e.toBasis.adjustToOrientation x)","decl":"theorem toBasis_adjustToOrientation :\n    (e.adjustToOrientation x).toBasis = e.toBasis.adjustToOrientation x :=\n  (e.toBasis.adjustToOrientation x).toBasis_toOrthonormalBasis _\n\n"}
{"name":"OrthonormalBasis.orientation_adjustToOrientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nι : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ne : OrthonormalBasis ι Real E\nx : Orientation Real E ι\ninst✝ : Nonempty ι\n⊢ Eq (e.adjustToOrientation x).toBasis.orientation x","decl":"/-- `adjustToOrientation` gives an orthonormal basis with the required orientation. -/\n@[simp]\ntheorem orientation_adjustToOrientation : (e.adjustToOrientation x).toBasis.orientation = x := by\n  rw [e.toBasis_adjustToOrientation]\n  exact e.toBasis.orientation_adjustToOrientation x\n\n"}
{"name":"OrthonormalBasis.adjustToOrientation_apply_eq_or_eq_neg","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nι : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ne : OrthonormalBasis ι Real E\nx : Orientation Real E ι\ninst✝ : Nonempty ι\ni : ι\n⊢ Or (Eq ((e.adjustToOrientation x) i) (e i)) (Eq ((e.adjustToOrientation x) i) (Neg.neg (e i)))","decl":"/-- Every basis vector from `adjustToOrientation` is either that from the original basis or its\nnegation. -/\ntheorem adjustToOrientation_apply_eq_or_eq_neg (i : ι) :\n    e.adjustToOrientation x i = e i ∨ e.adjustToOrientation x i = -e i := by\n  simpa [← e.toBasis_adjustToOrientation] using\n    e.toBasis.adjustToOrientation_apply_eq_or_eq_neg x i\n\n"}
{"name":"OrthonormalBasis.det_adjustToOrientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nι : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ne : OrthonormalBasis ι Real E\nx : Orientation Real E ι\ninst✝ : Nonempty ι\n⊢ Or (Eq (e.adjustToOrientation x).toBasis.det e.toBasis.det) (Eq (e.adjustToOrientation x).toBasis.det (Neg.neg e.toBasis.det))","decl":"theorem det_adjustToOrientation :\n    (e.adjustToOrientation x).toBasis.det = e.toBasis.det ∨\n      (e.adjustToOrientation x).toBasis.det = -e.toBasis.det := by\n  simpa using e.toBasis.det_adjustToOrientation x\n\n"}
{"name":"OrthonormalBasis.abs_det_adjustToOrientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nι : Type u_2\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ne : OrthonormalBasis ι Real E\nx : Orientation Real E ι\ninst✝ : Nonempty ι\nv : ι → E\n⊢ Eq (abs ((e.adjustToOrientation x).toBasis.det v)) (abs (e.toBasis.det v))","decl":"theorem abs_det_adjustToOrientation (v : ι → E) :\n    |(e.adjustToOrientation x).toBasis.det v| = |e.toBasis.det v| := by\n  simp [toBasis_adjustToOrientation]\n\n"}
{"name":"Orientation.finOrthonormalBasis_orientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\nhn : LT.lt 0 n\nh : Eq (Module.finrank Real E) n\nx : Orientation Real E (Fin n)\n⊢ Eq (Orientation.finOrthonormalBasis hn h x).toBasis.orientation x","decl":"/-- `Orientation.finOrthonormalBasis` gives a basis with the required orientation. -/\n@[simp]\ntheorem finOrthonormalBasis_orientation (hn : 0 < n) (h : finrank ℝ E = n)\n    (x : Orientation ℝ E (Fin n)) : (x.finOrthonormalBasis hn h).toBasis.orientation = x := by\n  haveI := Fin.pos_iff_nonempty.1 hn\n  haveI : FiniteDimensional ℝ E := .of_finrank_pos <| h.symm ▸ hn\n  exact ((@stdOrthonormalBasis _ _ _ _ _ this).reindex <|\n    finCongr h).orientation_adjustToOrientation x\n\n"}
{"name":"Orientation.volumeForm_def","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\n⊢ Eq o.volumeForm\n    (Nat.casesAuxOn (motive := fun a => Eq n a → AlternatingMap Real E Real (Fin n)) n\n      (fun h =>\n        Eq.ndrec (motive := fun {n} => [_i : Fact (Eq (Module.finrank Real E) n)] → Orientation Real E (Fin n) → AlternatingMap Real E Real (Fin n))\n          (fun [Fact (Eq (Module.finrank Real E) 0)] o =>\n            let opos := AlternatingMap.constOfIsEmpty Real E (Fin 0) 1;\n            ⋯.by_cases (fun x => opos) fun x => Neg.neg opos)\n          ⋯ o)\n      (fun n_1 h => Eq.ndrec (motive := fun {n} => [_i : Fact (Eq (Module.finrank Real E) n)] → Orientation Real E (Fin n) → AlternatingMap Real E Real (Fin n)) (fun [Fact (Eq (Module.finrank Real E) (HAdd.hAdd n_1 1))] o => (Orientation.finOrthonormalBasis ⋯ ⋯ o).toBasis.det) ⋯ o) ⋯)","decl":"/-- The volume form on an oriented real inner product space, a nonvanishing top-dimensional\nalternating form uniquely defined by compatibility with the orientation and inner product structure.\n-/\nirreducible_def volumeForm : E [⋀^Fin n]→ₗ[ℝ] ℝ := by\n  classical\n    cases' n with n\n    · let opos : E [⋀^Fin 0]→ₗ[ℝ] ℝ := .constOfIsEmpty ℝ E (Fin 0) (1 : ℝ)\n      exact o.eq_or_eq_neg_of_isEmpty.by_cases (fun _ => opos) fun _ => -opos\n    · exact (o.finOrthonormalBasis n.succ_pos _i.out).toBasis.det\n\n"}
{"name":"Orientation.volumeForm_zero_pos","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\n_i : Fact (Eq (Module.finrank Real E) 0)\n⊢ Eq Module.Oriented.positiveOrientation.volumeForm (AlternatingMap.constLinearEquivOfIsEmpty 1)","decl":"@[simp]\ntheorem volumeForm_zero_pos [_i : Fact (finrank ℝ E = 0)] :\n    Orientation.volumeForm (positiveOrientation : Orientation ℝ E (Fin 0)) =\n      AlternatingMap.constLinearEquivOfIsEmpty 1 := by\n  simp [volumeForm, Or.by_cases, if_pos]\n\n"}
{"name":"Orientation.volumeForm_zero_neg","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\n_i : Fact (Eq (Module.finrank Real E) 0)\n⊢ Eq (Neg.neg Module.Oriented.positiveOrientation).volumeForm (Neg.neg (AlternatingMap.constLinearEquivOfIsEmpty 1))","decl":"theorem volumeForm_zero_neg [_i : Fact (finrank ℝ E = 0)] :\n    Orientation.volumeForm (-positiveOrientation : Orientation ℝ E (Fin 0)) =\n      -AlternatingMap.constLinearEquivOfIsEmpty 1 := by\n  simp_rw [volumeForm, Or.by_cases, positiveOrientation]\n  apply if_neg\n  simp only [neg_rayOfNeZero]\n  rw [ray_eq_iff, SameRay.sameRay_comm]\n  intro h\n  simpa using\n    congr_arg AlternatingMap.constLinearEquivOfIsEmpty.symm (eq_zero_of_sameRay_self_neg h)\n\n"}
{"name":"Orientation.volumeForm_robust","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nb : OrthonormalBasis (Fin n) Real E\nhb : Eq b.toBasis.orientation o\n⊢ Eq o.volumeForm b.toBasis.det","decl":"/-- The volume form on an oriented real inner product space can be evaluated as the determinant with\nrespect to any orthonormal basis of the space compatible with the orientation. -/\ntheorem volumeForm_robust (b : OrthonormalBasis (Fin n) ℝ E) (hb : b.toBasis.orientation = o) :\n    o.volumeForm = b.toBasis.det := by\n  cases n\n  · classical\n      have : o = positiveOrientation := hb.symm.trans b.toBasis.orientation_isEmpty\n      simp_rw [volumeForm, Or.by_cases, dif_pos this, Nat.rec_zero, Basis.det_isEmpty]\n  · simp_rw [volumeForm]\n    rw [same_orientation_iff_det_eq_det, hb]\n    exact o.finOrthonormalBasis_orientation _ _\n\n"}
{"name":"Orientation.volumeForm_robust_neg","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nb : OrthonormalBasis (Fin n) Real E\nhb : Ne b.toBasis.orientation o\n⊢ Eq o.volumeForm (Neg.neg b.toBasis.det)","decl":"/-- The volume form on an oriented real inner product space can be evaluated as the determinant with\nrespect to any orthonormal basis of the space compatible with the orientation. -/\ntheorem volumeForm_robust_neg (b : OrthonormalBasis (Fin n) ℝ E) (hb : b.toBasis.orientation ≠ o) :\n    o.volumeForm = -b.toBasis.det := by\n  cases' n with n\n  · classical\n      have : positiveOrientation ≠ o := by rwa [b.toBasis.orientation_isEmpty] at hb\n      simp_rw [volumeForm, Or.by_cases, dif_neg this.symm, Nat.rec_zero, Basis.det_isEmpty]\n  let e : OrthonormalBasis (Fin n.succ) ℝ E := o.finOrthonormalBasis n.succ_pos Fact.out\n  simp_rw [volumeForm]\n  apply e.det_eq_neg_det_of_opposite_orientation b\n  convert hb.symm\n  exact o.finOrthonormalBasis_orientation _ _\n\n"}
{"name":"Orientation.volumeForm_neg_orientation","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\n⊢ Eq (Neg.neg o).volumeForm (Neg.neg o.volumeForm)","decl":"@[simp]\ntheorem volumeForm_neg_orientation : (-o).volumeForm = -o.volumeForm := by\n  cases' n with n\n  · refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl\n    · simp [volumeForm_zero_neg]\n    · rw [neg_neg (positiveOrientation (R := ℝ))] -- Porting note: added\n      simp [volumeForm_zero_neg]\n  let e : OrthonormalBasis (Fin n.succ) ℝ E := o.finOrthonormalBasis n.succ_pos Fact.out\n  have h₁ : e.toBasis.orientation = o := o.finOrthonormalBasis_orientation _ _\n  have h₂ : e.toBasis.orientation ≠ -o := by\n    symm\n    rw [e.toBasis.orientation_ne_iff_eq_neg, h₁]\n  rw [o.volumeForm_robust e h₁, (-o).volumeForm_robust_neg e h₂]\n\n"}
{"name":"Orientation.volumeForm_robust'","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nb : OrthonormalBasis (Fin n) Real E\nv : Fin n → E\n⊢ Eq (abs (o.volumeForm v)) (abs (b.toBasis.det v))","decl":"theorem volumeForm_robust' (b : OrthonormalBasis (Fin n) ℝ E) (v : Fin n → E) :\n    |o.volumeForm v| = |b.toBasis.det v| := by\n  cases n\n  · refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp\n  · rw [o.volumeForm_robust (b.adjustToOrientation o) (b.orientation_adjustToOrientation o),\n      b.abs_det_adjustToOrientation]\n\n"}
{"name":"Orientation.abs_volumeForm_apply_le","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nv : Fin n → E\n⊢ LE.le (abs (o.volumeForm v)) (Finset.univ.prod fun i => Norm.norm (v i))","decl":"/-- Let `v` be an indexed family of `n` vectors in an oriented `n`-dimensional real inner\nproduct space `E`. The output of the volume form of `E` when evaluated on `v` is bounded in absolute\nvalue by the product of the norms of the vectors `v i`. -/\ntheorem abs_volumeForm_apply_le (v : Fin n → E) : |o.volumeForm v| ≤ ∏ i : Fin n, ‖v i‖ := by\n  cases' n with n\n  · refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp\n  haveI : FiniteDimensional ℝ E := .of_fact_finrank_eq_succ n\n  have : finrank ℝ E = Fintype.card (Fin n.succ) := by simpa using _i.out\n  let b : OrthonormalBasis (Fin n.succ) ℝ E := gramSchmidtOrthonormalBasis this v\n  have hb : b.toBasis.det v = ∏ i, ⟪b i, v i⟫ := gramSchmidtOrthonormalBasis_det this v\n  rw [o.volumeForm_robust' b, hb, Finset.abs_prod]\n  apply Finset.prod_le_prod\n  · intro i _\n    positivity\n  intro i _\n  convert abs_real_inner_le_norm (b i) (v i)\n  simp [b.orthonormal.1 i]\n\n"}
{"name":"Orientation.volumeForm_apply_le","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nv : Fin n → E\n⊢ LE.le (o.volumeForm v) (Finset.univ.prod fun i => Norm.norm (v i))","decl":"theorem volumeForm_apply_le (v : Fin n → E) : o.volumeForm v ≤ ∏ i : Fin n, ‖v i‖ :=\n  (le_abs_self _).trans (o.abs_volumeForm_apply_le v)\n\n"}
{"name":"Orientation.abs_volumeForm_apply_of_pairwise_orthogonal","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nv : Fin n → E\nhv : Pairwise fun i j => Eq (Inner.inner (v i) (v j)) 0\n⊢ Eq (abs (o.volumeForm v)) (Finset.univ.prod fun i => Norm.norm (v i))","decl":"/-- Let `v` be an indexed family of `n` orthogonal vectors in an oriented `n`-dimensional\nreal inner product space `E`. The output of the volume form of `E` when evaluated on `v` is, up to\nsign, the product of the norms of the vectors `v i`. -/\ntheorem abs_volumeForm_apply_of_pairwise_orthogonal {v : Fin n → E}\n    (hv : Pairwise fun i j => ⟪v i, v j⟫ = 0) : |o.volumeForm v| = ∏ i : Fin n, ‖v i‖ := by\n  cases' n with n\n  · refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp\n  haveI : FiniteDimensional ℝ E := .of_fact_finrank_eq_succ n\n  have hdim : finrank ℝ E = Fintype.card (Fin n.succ) := by simpa using _i.out\n  let b : OrthonormalBasis (Fin n.succ) ℝ E := gramSchmidtOrthonormalBasis hdim v\n  have hb : b.toBasis.det v = ∏ i, ⟪b i, v i⟫ := gramSchmidtOrthonormalBasis_det hdim v\n  rw [o.volumeForm_robust' b, hb, Finset.abs_prod]\n  by_cases h : ∃ i, v i = 0\n  · obtain ⟨i, hi⟩ := h\n    rw [Finset.prod_eq_zero (Finset.mem_univ i), Finset.prod_eq_zero (Finset.mem_univ i)] <;>\n      simp [hi]\n  push_neg at h\n  congr\n  ext i\n  have hb : b i = ‖v i‖⁻¹ • v i := gramSchmidtOrthonormalBasis_apply_of_orthogonal hdim hv (h i)\n  simp only [hb, inner_smul_left, real_inner_self_eq_norm_mul_norm, RCLike.conj_to_real]\n  rw [abs_of_nonneg]\n  · field_simp\n  · positivity\n\n"}
{"name":"Orientation.abs_volumeForm_apply_of_orthonormal","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nv : OrthonormalBasis (Fin n) Real E\n⊢ Eq (abs (o.volumeForm ⇑v)) 1","decl":"/-- The output of the volume form of an oriented real inner product space `E` when evaluated on an\northonormal basis is ±1. -/\ntheorem abs_volumeForm_apply_of_orthonormal (v : OrthonormalBasis (Fin n) ℝ E) :\n    |o.volumeForm v| = 1 := by\n  simpa [o.volumeForm_robust' v v] using congr_arg abs v.toBasis.det_self\n\n"}
{"name":"Orientation.volumeForm_map","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nF : Type u_2\ninst✝² : NormedAddCommGroup F\ninst✝¹ : InnerProductSpace Real F\ninst✝ : Fact (Eq (Module.finrank Real F) n)\nφ : LinearIsometryEquiv (RingHom.id Real) E F\nx : Fin n → F\n⊢ Eq (((Orientation.map (Fin n) φ.toLinearEquiv) o).volumeForm x) (o.volumeForm (Function.comp (⇑φ.symm) x))","decl":"theorem volumeForm_map {F : Type*} [NormedAddCommGroup F] [InnerProductSpace ℝ F]\n    [Fact (finrank ℝ F = n)] (φ : E ≃ₗᵢ[ℝ] F) (x : Fin n → F) :\n    (Orientation.map (Fin n) φ.toLinearEquiv o).volumeForm x = o.volumeForm (φ.symm ∘ x) := by\n  cases' n with n\n  · refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp\n  let e : OrthonormalBasis (Fin n.succ) ℝ E := o.finOrthonormalBasis n.succ_pos Fact.out\n  have he : e.toBasis.orientation = o :=\n    o.finOrthonormalBasis_orientation n.succ_pos Fact.out\n  have heφ : (e.map φ).toBasis.orientation = Orientation.map (Fin n.succ) φ.toLinearEquiv o := by\n    rw [← he]\n    exact e.toBasis.orientation_map φ.toLinearEquiv\n  rw [(Orientation.map (Fin n.succ) φ.toLinearEquiv o).volumeForm_robust (e.map φ) heφ]\n  rw [o.volumeForm_robust e he]\n  simp\n\n"}
{"name":"Orientation.volumeForm_comp_linearIsometryEquiv","module":"Mathlib.Analysis.InnerProductSpace.Orientation","initialProofState":"E : Type u_1\ninst✝¹ : NormedAddCommGroup E\ninst✝ : InnerProductSpace Real E\nn : Nat\n_i : Fact (Eq (Module.finrank Real E) n)\no : Orientation Real E (Fin n)\nφ : LinearIsometryEquiv (RingHom.id Real) E E\nhφ : LT.lt 0 (LinearMap.det ↑φ.toLinearEquiv)\nx : Fin n → E\n⊢ Eq (o.volumeForm (Function.comp (⇑φ) x)) (o.volumeForm x)","decl":"/-- The volume form is invariant under pullback by a positively-oriented isometric automorphism. -/\ntheorem volumeForm_comp_linearIsometryEquiv (φ : E ≃ₗᵢ[ℝ] E)\n    (hφ : 0 < LinearMap.det (φ.toLinearEquiv : E →ₗ[ℝ] E)) (x : Fin n → E) :\n    o.volumeForm (φ ∘ x) = o.volumeForm x := by\n  cases' n with n -- Porting note: need to explicitly prove `FiniteDimensional ℝ E`\n  · refine o.eq_or_eq_neg_of_isEmpty.elim ?_ ?_ <;> rintro rfl <;> simp\n  haveI : FiniteDimensional ℝ E := .of_fact_finrank_eq_succ n\n  convert o.volumeForm_map φ (φ ∘ x)\n  · symm\n    rwa [← o.map_eq_iff_det_pos φ.toLinearEquiv] at hφ\n    rw [_i.out, Fintype.card_fin]\n  · ext\n    simp\n\n"}
