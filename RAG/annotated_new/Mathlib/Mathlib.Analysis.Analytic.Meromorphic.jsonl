{"name":"AnalyticAt.meromorphicAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\nhf : AnalyticAt 𝕜 f x\n⊢ MeromorphicAt f x","decl":"@[fun_prop]\nlemma AnalyticAt.meromorphicAt {f : 𝕜 → E} {x : 𝕜} (hf : AnalyticAt 𝕜 f x) :\n    MeromorphicAt f x :=\n  ⟨0, by simpa only [pow_zero, one_smul]⟩\n\n/- Analogue of the principle of isolated zeros for an analytic function: if a function is\nmeromorphic at `z₀`, then either it is identically zero in a punctured neighborhood of `z₀`, or it\ndoes not vanish there at all. -/\n"}
{"name":"MeromorphicAt.eventually_eq_zero_or_eventually_ne_zero","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nz₀ : 𝕜\nhf : MeromorphicAt f z₀\n⊢ Or (Filter.Eventually (fun z => Eq (f z) 0) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀)))) (Filter.Eventually (fun z => Ne (f z) 0) (nhdsWithin z₀ (HasCompl.compl (Singleton.singleton z₀))))","decl":"theorem MeromorphicAt.eventually_eq_zero_or_eventually_ne_zero {f : 𝕜 → E} {z₀ : 𝕜}\n    (hf : MeromorphicAt f z₀) :\n    (∀ᶠ z in 𝓝[≠] z₀, f z = 0) ∨ (∀ᶠ z in 𝓝[≠] z₀, f z ≠ 0) := by\n  obtain ⟨n, h⟩ := hf\n  rcases h.eventually_eq_zero_or_eventually_ne_zero with h₁ | h₂\n  · left\n    filter_upwards [nhdsWithin_le_nhds h₁, self_mem_nhdsWithin] with y h₁y h₂y\n    rcases (smul_eq_zero.1 h₁y) with h₃ | h₄\n    · exact False.elim (h₂y (sub_eq_zero.1 (pow_eq_zero_iff'.1 h₃).1))\n    · assumption\n  · right\n    filter_upwards [h₂, self_mem_nhdsWithin] with y h₁y h₂y\n    exact (smul_ne_zero_iff.1 h₁y).2\n\n"}
{"name":"MeromorphicAt.id","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nx : 𝕜\n⊢ MeromorphicAt id x","decl":"lemma id (x : 𝕜) : MeromorphicAt id x := analyticAt_id.meromorphicAt\n\n"}
{"name":"MeromorphicAt.const","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ne : E\nx : 𝕜\n⊢ MeromorphicAt (fun x => e) x","decl":"@[fun_prop]\nlemma const (e : E) (x : 𝕜) : MeromorphicAt (fun _ ↦ e) x :=\n  analyticAt_const.meromorphicAt\n\n"}
{"name":"MeromorphicAt.add","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (HAdd.hAdd f g) x","decl":"@[fun_prop]\nlemma add {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f + g) x := by\n  rcases hf with ⟨m, hf⟩\n  rcases hg with ⟨n, hg⟩\n  refine ⟨max m n, ?_⟩\n  have : (fun z ↦ (z - x) ^ max m n • (f + g) z) = fun z ↦ (z - x) ^ (max m n - m) •\n      ((z - x) ^ m • f z) + (z - x) ^ (max m n - n) • ((z - x) ^ n • g z) := by\n    simp_rw [← mul_smul, ← pow_add, Nat.sub_add_cancel (Nat.le_max_left _ _),\n      Nat.sub_add_cancel (Nat.le_max_right _ _), Pi.add_apply, smul_add]\n  rw [this]\n  exact (((analyticAt_id.sub analyticAt_const).pow _).smul hf).add\n   (((analyticAt_id.sub analyticAt_const).pow _).smul hg)\n\n"}
{"name":"MeromorphicAt.add'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (fun z => HAdd.hAdd (f z) (g z)) x","decl":"@[fun_prop]\nlemma add' {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z ↦ f z + g z) x :=\n  hf.add hg\n\n"}
{"name":"MeromorphicAt.smul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → 𝕜\ng : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (HSMul.hSMul f g) x","decl":"@[fun_prop]\nlemma smul {f : 𝕜 → 𝕜} {g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f • g) x := by\n  rcases hf with ⟨m, hf⟩\n  rcases hg with ⟨n, hg⟩\n  refine ⟨m + n, ?_⟩\n  convert hf.smul' hg using 2 with z\n  rw [Pi.smul_apply', smul_eq_mul]\n  module\n\n"}
{"name":"MeromorphicAt.smul'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → 𝕜\ng : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (fun z => HSMul.hSMul (f z) (g z)) x","decl":"@[fun_prop]\nlemma smul' {f : 𝕜 → 𝕜} {g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z ↦ f z • g z) x :=\n  hf.smul hg\n\n"}
{"name":"MeromorphicAt.mul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (HMul.hMul f g) x","decl":"@[fun_prop]\nlemma mul {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f * g) x :=\n  hf.smul hg\n\n"}
{"name":"MeromorphicAt.mul'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (fun z => HMul.hMul (f z) (g z)) x","decl":"@[fun_prop]\nlemma mul' {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z ↦ f z * g z) x :=\n  hf.smul hg\n\n"}
{"name":"MeromorphicAt.neg","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\n⊢ MeromorphicAt (Neg.neg f) x","decl":"@[fun_prop]\nlemma neg {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt (-f) x := by\n  convert (MeromorphicAt.const (-1 : 𝕜) x).smul hf using 1\n  ext1 z\n  simp only [Pi.neg_apply, Pi.smul_apply', neg_smul, one_smul]\n\n"}
{"name":"MeromorphicAt.neg'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\n⊢ MeromorphicAt (fun z => Neg.neg (f z)) x","decl":"@[fun_prop]\nlemma neg' {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt (fun z ↦ -f z) x :=\n  hf.neg\n\n"}
{"name":"MeromorphicAt.neg_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\n⊢ Iff (MeromorphicAt (Neg.neg f) x) (MeromorphicAt f x)","decl":"@[simp]\nlemma neg_iff {f : 𝕜 → E} {x : 𝕜} :\n    MeromorphicAt (-f) x ↔ MeromorphicAt f x :=\n  ⟨fun h ↦ by simpa only [neg_neg] using h.neg, MeromorphicAt.neg⟩\n\n"}
{"name":"MeromorphicAt.sub","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (HSub.hSub f g) x","decl":"@[fun_prop]\nlemma sub {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f - g) x := by\n  convert hf.add hg.neg using 1\n  ext1 z\n  simp_rw [Pi.sub_apply, Pi.add_apply, Pi.neg_apply, sub_eq_add_neg]\n\n"}
{"name":"MeromorphicAt.sub'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (fun z => HSub.hSub (f z) (g z)) x","decl":"@[fun_prop]\nlemma sub' {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z ↦ f z - g z) x :=\n  hf.sub hg\n\n"}
{"name":"MeromorphicAt.congr","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhfg : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).EventuallyEq f g\n⊢ MeromorphicAt g x","decl":"/-- With our definitions, `MeromorphicAt f x` depends only on the values of `f` on a punctured\nneighbourhood of `x` (not on `f x`) -/\nlemma congr {f g : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (hfg : f =ᶠ[𝓝[≠] x] g) :\n    MeromorphicAt g x := by\n  rcases hf with ⟨m, hf⟩\n  refine ⟨m + 1, ?_⟩\n  have : AnalyticAt 𝕜 (fun z ↦ z - x) x := analyticAt_id.sub analyticAt_const\n  refine (this.smul' hf).congr ?_\n  rw [eventuallyEq_nhdsWithin_iff] at hfg\n  filter_upwards [hfg] with z hz\n  rcases eq_or_ne z x with rfl | hn\n  · simp\n  · rw [hz (Set.mem_compl_singleton_iff.mp hn), pow_succ', mul_smul]\n\n"}
{"name":"MeromorphicAt.inv","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\n⊢ MeromorphicAt (Inv.inv f) x","decl":"@[fun_prop]\nlemma inv {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt f⁻¹ x := by\n  rcases hf with ⟨m, hf⟩\n  by_cases h_eq : (fun z ↦ (z - x) ^ m • f z) =ᶠ[𝓝 x] 0\n  · -- silly case: f locally 0 near x\n    refine (MeromorphicAt.const 0 x).congr ?_\n    rw [eventuallyEq_nhdsWithin_iff]\n    filter_upwards [h_eq] with z hfz hz\n    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,\n      inv_zero]\n  · -- interesting case: use local formula for `f`\n    obtain ⟨n, g, hg_an, hg_ne, hg_eq⟩ := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq\n    have : AnalyticAt 𝕜 (fun z ↦ (z - x) ^ (m + 1)) x :=\n      (analyticAt_id.sub analyticAt_const).pow _\n    -- use `m + 1` rather than `m` to damp out any silly issues with the value at `z = x`\n    refine ⟨n + 1, (this.smul' <| hg_an.inv hg_ne).congr ?_⟩\n    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'\n    rcases eq_or_ne z x with rfl | hz_ne\n    · simp only [sub_self, pow_succ, mul_zero, zero_smul]\n    · simp_rw [smul_eq_mul] at hfg ⊢\n      have aux1 : f z ≠ 0 := by\n        have : (z - x) ^ n * g z ≠ 0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'\n        rw [← hfg, mul_ne_zero_iff] at this\n        exact this.2\n      field_simp [sub_ne_zero.mpr hz_ne]\n      rw [pow_succ', mul_assoc, hfg]\n      ring\n\n"}
{"name":"MeromorphicAt.inv'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\n⊢ MeromorphicAt (fun z => Inv.inv (f z)) x","decl":"@[fun_prop]\nlemma inv' {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) : MeromorphicAt (fun z ↦ (f z)⁻¹) x :=\n  hf.inv\n\n"}
{"name":"MeromorphicAt.inv_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\n⊢ Iff (MeromorphicAt (Inv.inv f) x) (MeromorphicAt f x)","decl":"@[simp]\nlemma inv_iff {f : 𝕜 → 𝕜} {x : 𝕜} :\n    MeromorphicAt f⁻¹ x ↔ MeromorphicAt f x :=\n  ⟨fun h ↦ by simpa only [inv_inv] using h.inv, MeromorphicAt.inv⟩\n\n"}
{"name":"MeromorphicAt.div","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (HDiv.hDiv f g) x","decl":"@[fun_prop]\nlemma div {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f / g) x :=\n  (div_eq_mul_inv f g).symm ▸ (hf.mul hg.inv)\n\n"}
{"name":"MeromorphicAt.div'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ MeromorphicAt (fun z => HDiv.hDiv (f z) (g z)) x","decl":"@[fun_prop]\nlemma div' {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z ↦ f z / g z) x :=\n  hf.div hg\n\n"}
{"name":"MeromorphicAt.pow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nn : Nat\n⊢ MeromorphicAt (HPow.hPow f n) x","decl":"@[fun_prop]\nlemma pow {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℕ) : MeromorphicAt (f ^ n) x := by\n  induction n with\n  | zero => simpa only [pow_zero] using MeromorphicAt.const 1 x\n  | succ m hm => simpa only [pow_succ] using hm.mul hf\n\n"}
{"name":"MeromorphicAt.pow'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nn : Nat\n⊢ MeromorphicAt (fun z => HPow.hPow (f z) n) x","decl":"@[fun_prop]\nlemma pow' {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℕ) :\n    MeromorphicAt (fun z ↦ (f z) ^ n) x :=\n  hf.pow n\n\n"}
{"name":"MeromorphicAt.zpow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nn : Int\n⊢ MeromorphicAt (HPow.hPow f n) x","decl":"@[fun_prop]\nlemma zpow {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : MeromorphicAt (f ^ n) x := by\n  induction n with\n  | ofNat m => simpa only [Int.ofNat_eq_coe, zpow_natCast] using hf.pow m\n  | negSucc m => simpa only [zpow_negSucc, inv_iff] using hf.pow (m + 1)\n\n"}
{"name":"MeromorphicAt.zpow'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nn : Int\n⊢ MeromorphicAt (fun z => HPow.hPow (f z) n) x","decl":"@[fun_prop]\nlemma zpow' {f : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) :\n    MeromorphicAt (fun z ↦ (f z) ^ n) x :=\n  hf.zpow n\n\n"}
{"name":"MeromorphicAt.eventually_analyticAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\nf : 𝕜 → E\nx : 𝕜\nh : MeromorphicAt f x\n⊢ Filter.Eventually (fun y => AnalyticAt 𝕜 f y) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))","decl":"theorem eventually_analyticAt [CompleteSpace E] {f : 𝕜 → E} {x : 𝕜}\n    (h : MeromorphicAt f x) : ∀ᶠ y in 𝓝[≠] x, AnalyticAt 𝕜 f y := by\n  rw [MeromorphicAt] at h\n  obtain ⟨n, h⟩ := h\n  apply AnalyticAt.eventually_analyticAt at h\n  refine (h.filter_mono ?_).mp ?_\n  · simp [nhdsWithin]\n  · rw [eventually_nhdsWithin_iff]\n    apply Filter.Eventually.of_forall\n    intro y hy hf\n    rw [Set.mem_compl_iff, Set.mem_singleton_iff] at hy\n    have := ((analyticAt_id (𝕜 := 𝕜).sub analyticAt_const).pow n).inv\n      (pow_ne_zero _ (sub_ne_zero_of_ne hy))\n    apply (this.smul hf).congr ∘ (eventually_ne_nhds hy).mono\n    intro z hz\n    simp [smul_smul, hz, sub_eq_zero]\n\n"}
{"name":"MeromorphicAt.order_eq_top_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\n⊢ Iff (Eq hf.order Top.top) (Filter.Eventually (fun z => Eq (f z) 0) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))))","decl":"lemma order_eq_top_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) :\n    hf.order = ⊤ ↔ ∀ᶠ z in 𝓝[≠] x, f z = 0 := by\n  unfold order\n  by_cases h : hf.choose_spec.order = ⊤\n  · rw [h, ENat.map_top, ← WithTop.coe_natCast,\n      top_sub, eq_self, true_iff, eventually_nhdsWithin_iff]\n    rw [AnalyticAt.order_eq_top_iff] at h\n    filter_upwards [h] with z hf hz\n    rwa [smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)] at hf\n  · obtain ⟨m, hm⟩ := ENat.ne_top_iff_exists.mp h\n    simp only [← hm, ENat.map_coe, WithTop.coe_natCast, sub_eq_top_iff, WithTop.natCast_ne_top,\n      or_self, false_iff]\n    contrapose! h\n    rw [AnalyticAt.order_eq_top_iff]\n    rw [← hf.choose_spec.frequently_eq_iff_eventually_eq analyticAt_const]\n    apply Eventually.frequently\n    filter_upwards [h] with z hfz\n    rw [hfz, smul_zero]\n\n"}
{"name":"MeromorphicAt.order_eq_int_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nn : Int\n⊢ Iff (Eq hf.order ↑n) (Exists fun g => And (AnalyticAt 𝕜 g x) (And (Ne (g x) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z x) n) (g z))) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))))))","decl":"lemma order_eq_int_iff {f : 𝕜 → E} {x : 𝕜} (hf : MeromorphicAt f x) (n : ℤ) : hf.order = n ↔\n    ∃ g : 𝕜 → E, AnalyticAt 𝕜 g x ∧ g x ≠ 0 ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z := by\n  unfold order\n  by_cases h : hf.choose_spec.order = ⊤\n  · rw [h, ENat.map_top, ← WithTop.coe_natCast, top_sub,\n      eq_false_intro WithTop.top_ne_coe, false_iff]\n    rw [AnalyticAt.order_eq_top_iff] at h\n    refine fun ⟨g, hg_an, hg_ne, hg_eq⟩ ↦ hg_ne ?_\n    apply EventuallyEq.eq_of_nhds\n    rw [EventuallyEq, ← AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]\n    apply Eventually.frequently\n    rw [eventually_nhdsWithin_iff] at hg_eq ⊢\n    filter_upwards [h, hg_eq] with z hfz hfz_eq hz\n    rwa [hfz_eq hz, ← mul_smul, smul_eq_zero_iff_right] at hfz\n    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))\n  · obtain ⟨m, h⟩ := ENat.ne_top_iff_exists.mp h\n    rw [← h, ENat.map_coe, ← WithTop.coe_natCast, ← coe_sub, WithTop.coe_inj]\n    obtain ⟨g, hg_an, hg_ne, hg_eq⟩ := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm\n    replace hg_eq : ∀ᶠ (z : 𝕜) in 𝓝[≠] x, f z = (z - x) ^ (↑m - ↑hf.choose : ℤ) • g z := by\n      rw [eventually_nhdsWithin_iff]\n      filter_upwards [hg_eq] with z hg_eq hz\n      rwa [← smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), ← mul_smul,\n        ← zpow_add₀ (sub_ne_zero.mpr hz), ← add_sub_assoc, add_sub_cancel_left, zpow_natCast,\n        zpow_natCast]\n    exact ⟨fun h ↦ ⟨g, hg_an, hg_ne, h ▸ hg_eq⟩,\n      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero ⟨g, hg_an, hg_ne, hg_eq⟩⟩\n\n"}
{"name":"AnalyticAt.meromorphicAt_order","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\nhf : AnalyticAt 𝕜 f x\n⊢ Eq ⋯.order (ENat.map Nat.cast hf.order)","decl":"/-- Compatibility of notions of `order` for analytic and meromorphic functions. -/\nlemma _root_.AnalyticAt.meromorphicAt_order {f : 𝕜 → E} {x : 𝕜} (hf : AnalyticAt 𝕜 f x) :\n    hf.meromorphicAt.order = hf.order.map (↑) := by\n  rcases eq_or_ne hf.order ⊤ with ho | ho\n  · rw [ho, ENat.map_top, order_eq_top_iff]\n    exact (hf.order_eq_top_iff.mp ho).filter_mono nhdsWithin_le_nhds\n  · obtain ⟨n, hn⟩ := ENat.ne_top_iff_exists.mp ho\n    simp_rw [← hn, ENat.map_coe, order_eq_int_iff, zpow_natCast]\n    rcases (hf.order_eq_nat_iff _).mp hn.symm with ⟨g, h1, h2, h3⟩\n    exact ⟨g, h1, h2, h3.filter_mono nhdsWithin_le_nhds⟩\n\n"}
{"name":"MeromorphicAt.order_smul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → 𝕜\ng : 𝕜 → E\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ Eq ⋯.order (HAdd.hAdd hf.order hg.order)","decl":"/-- The order is additive when multiplying scalar-valued and vector-valued meromorphic functions. -/\ntheorem order_smul {f : 𝕜 → 𝕜} {g : 𝕜 → E} {x : 𝕜}\n    (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    (hf.smul hg).order = hf.order + hg.order := by\n  -- Trivial cases: one of the functions vanishes around z₀\n  cases' h₂f : hf.order with m h₂f\n  · simp only [top_add, order_eq_top_iff] at h₂f ⊢\n    filter_upwards [h₂f] with z hz using by simp [hz]\n  cases' h₂g : hg.order with n h₂f\n  · simp only [add_top, order_eq_top_iff] at h₂g ⊢\n    filter_upwards [h₂g] with z hz using by simp [hz]\n  -- Non-trivial case: both functions do not vanish around z₀\n  rw [← WithTop.coe_add, order_eq_int_iff]\n  obtain ⟨F, h₁F, h₂F, h₃F⟩ := (hf.order_eq_int_iff _).1 h₂f\n  obtain ⟨G, h₁G, h₂G, h₃G⟩ := (hg.order_eq_int_iff _).1 h₂g\n  use F • G, h₁F.smul h₁G, by simp [h₂F, h₂G]\n  filter_upwards [self_mem_nhdsWithin, h₃F, h₃G] with a ha hfa hga\n  simp [hfa, hga, smul_comm (F a), zpow_add₀ (sub_ne_zero.mpr ha), mul_smul]\n\n"}
{"name":"MeromorphicAt.order_mul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nf g : 𝕜 → 𝕜\nx : 𝕜\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\n⊢ Eq ⋯.order (HAdd.hAdd hf.order hg.order)","decl":"/-- The order is additive when multiplying meromorphic functions. -/\ntheorem order_mul {f g : 𝕜 → 𝕜} {x : 𝕜} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    (hf.mul hg).order = hf.order + hg.order :=\n  hf.order_smul hg\n\n"}
{"name":"MeromorphicAt.iff_eventuallyEq_zpow_smul_analyticAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nx : 𝕜\n⊢ Iff (MeromorphicAt f x) (Exists fun n => Exists fun g => And (AnalyticAt 𝕜 g x) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z x) n) (g z))) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))))","decl":"lemma iff_eventuallyEq_zpow_smul_analyticAt {f : 𝕜 → E} {x : 𝕜} : MeromorphicAt f x ↔\n    ∃ (n : ℤ) (g : 𝕜 → E), AnalyticAt 𝕜 g x ∧ ∀ᶠ z in 𝓝[≠] x, f z = (z - x) ^ n • g z := by\n  refine ⟨fun ⟨n, hn⟩ ↦ ⟨-n, _, ⟨hn, eventually_nhdsWithin_iff.mpr ?_⟩⟩, ?_⟩\n  · filter_upwards with z hz\n    match_scalars\n    field_simp [sub_ne_zero.mpr hz]\n  · refine fun ⟨n, g, hg_an, hg_eq⟩ ↦ MeromorphicAt.congr ?_ (EventuallyEq.symm hg_eq)\n    exact (((MeromorphicAt.id x).sub (.const _ x)).zpow _).smul hg_an.meromorphicAt\n\n"}
{"name":"AnalyticOnNhd.meromorphicOn","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\n⊢ MeromorphicOn f U","decl":"lemma AnalyticOnNhd.meromorphicOn {f : 𝕜 → E} {U : Set 𝕜} (hf : AnalyticOnNhd 𝕜 f U) :\n    MeromorphicOn f U :=\n  fun x hx ↦ (hf x hx).meromorphicAt\n\n"}
{"name":"AnalyticOn.meromorphicOn","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : AnalyticOnNhd 𝕜 f U\n⊢ MeromorphicOn f U","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.meromorphicOn := AnalyticOnNhd.meromorphicOn\n\n"}
{"name":"MeromorphicOn.id","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\nU : Set 𝕜\n⊢ MeromorphicOn id U","decl":"lemma id {U : Set 𝕜} : MeromorphicOn id U := fun x _ ↦ .id x\n\n"}
{"name":"MeromorphicOn.const","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ne : E\nU : Set 𝕜\n⊢ MeromorphicOn (fun x => e) U","decl":"lemma const (e : E) {U : Set 𝕜} : MeromorphicOn (fun _ ↦ e) U :=\n  fun x _ ↦ .const e x\n\n"}
{"name":"MeromorphicOn.isClopen_setOf_order_eq_top","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\n⊢ IsClopen (setOf fun u => Eq ⋯.order Top.top)","decl":"/-- The set where a meromorphic function has infinite order is clopen in its domain of meromorphy.\n-/\ntheorem isClopen_setOf_order_eq_top {U : Set 𝕜} (hf : MeromorphicOn f U) :\n    IsClopen { u : U | (hf u.1 u.2).order = ⊤ } := by\n  constructor\n  · rw [← isOpen_compl_iff, isOpen_iff_forall_mem_open]\n    intro z hz\n    rcases (hf z.1 z.2).eventually_eq_zero_or_eventually_ne_zero with h | h\n    · -- Case: f is locally zero in a punctured neighborhood of z\n      rw [← (hf z.1 z.2).order_eq_top_iff] at h\n      tauto\n    · -- Case: f is locally nonzero in a punctured neighborhood of z\n      obtain ⟨t', h₁t', h₂t', h₃t'⟩ := eventually_nhds_iff.1 (eventually_nhdsWithin_iff.1 h)\n      use Subtype.val ⁻¹' t'\n      constructor\n      · intro w hw\n        simp only [Set.mem_compl_iff, Set.mem_setOf_eq]\n        by_cases h₁w : w = z\n        · rwa [h₁w]\n        · rw [MeromorphicAt.order_eq_top_iff, not_eventually]\n          apply Filter.Eventually.frequently\n          rw [eventually_nhdsWithin_iff, eventually_nhds_iff]\n          use t' \\ {z.1}, fun y h₁y h₂y ↦ h₁t' y h₁y.1 h₁y.2, h₂t'.sdiff isClosed_singleton, hw,\n            Set.mem_singleton_iff.not.2 (Subtype.coe_ne_coe.mpr h₁w)\n      · exact ⟨isOpen_induced h₂t', h₃t'⟩\n  · apply isOpen_iff_forall_mem_open.mpr\n    intro z hz\n    conv =>\n      arg 1; intro; left; right; arg 1; intro\n      rw [MeromorphicAt.order_eq_top_iff, eventually_nhdsWithin_iff, eventually_nhds_iff]\n    simp only [Set.mem_setOf_eq] at hz\n    rw [MeromorphicAt.order_eq_top_iff, eventually_nhdsWithin_iff, eventually_nhds_iff] at hz\n    obtain ⟨t', h₁t', h₂t', h₃t'⟩ := hz\n    use Subtype.val ⁻¹' t'\n    simp only [Set.mem_compl_iff, Set.mem_singleton_iff, isOpen_induced h₂t', Set.mem_preimage,\n      h₃t', and_self, and_true]\n    intro w hw\n    simp only [Set.mem_setOf_eq]\n    -- Trivial case: w = z\n    by_cases h₁w : w = z\n    · rw [h₁w]\n      tauto\n    -- Nontrivial case: w ≠ z\n    use t' \\ {z.1}, fun y h₁y _ ↦ h₁t' y (Set.mem_of_mem_diff h₁y) (Set.mem_of_mem_inter_right h₁y)\n    constructor\n    · exact h₂t'.sdiff isClosed_singleton\n    · apply (Set.mem_diff w).1\n      exact ⟨hw, Set.mem_singleton_iff.not.1 (Subtype.coe_ne_coe.2 h₁w)⟩\n\n"}
{"name":"MeromorphicOn.exists_order_ne_top_iff_forall","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\nhU : IsConnected U\n⊢ Iff (Exists fun u => Ne ⋯.order Top.top) (∀ (u : ↑U), Ne ⋯.order Top.top)","decl":"/-- On a connected set, there exists a point where a meromorphic function `f` has finite order iff\n`f` has finite order at every point. -/\ntheorem exists_order_ne_top_iff_forall {U : Set 𝕜} (hf : MeromorphicOn f U) (hU : IsConnected U) :\n    (∃ u : U, (hf u u.2).order ≠ ⊤) ↔ (∀ u : U, (hf u u.2).order ≠ ⊤) := by\n  constructor\n  · intro h₂f\n    have := isPreconnected_iff_preconnectedSpace.1 hU.isPreconnected\n    rcases isClopen_iff.1 hf.isClopen_setOf_order_eq_top with h | h\n    · intro u\n      have : u ∉ (∅ : Set U) := by exact fun a => a\n      rw [← h] at this\n      tauto\n    · obtain ⟨u, hU⟩ := h₂f\n      have : u ∈ Set.univ := by trivial\n      rw [← h] at this\n      tauto\n  · intro h₂f\n    obtain ⟨v, hv⟩ := hU.nonempty\n    use ⟨v, hv⟩, h₂f ⟨v, hv⟩\n\n"}
{"name":"MeromorphicOn.order_ne_top_of_isPreconnected","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nx y : 𝕜\nhf : MeromorphicOn f U\nhU : IsPreconnected U\nh₁x : Membership.mem U x\nhy : Membership.mem U y\nh₂x : Ne ⋯.order Top.top\n⊢ Ne ⋯.order Top.top","decl":"/-- On a preconnected set, a meromorphic function has finite order at one point if it has finite\norder at another point. -/\ntheorem order_ne_top_of_isPreconnected {U : Set 𝕜} {x y : 𝕜} (hf : MeromorphicOn f U)\n    (hU : IsPreconnected U) (h₁x : x ∈ U) (hy : y ∈ U) (h₂x : (hf x h₁x).order ≠ ⊤) :\n    (hf y hy).order ≠ ⊤ :=\n  (hf.exists_order_ne_top_iff_forall ⟨Set.nonempty_of_mem h₁x, hU⟩).1 (by use ⟨x, h₁x⟩) ⟨y, hy⟩\n\n"}
{"name":"MeromorphicOn.mono_set","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\nV : Set 𝕜\nhv : HasSubset.Subset V U\n⊢ MeromorphicOn f V","decl":"include hf in\nlemma mono_set {V : Set 𝕜} (hv : V ⊆ U) : MeromorphicOn f V := fun x hx ↦ hf x (hv hx)\n\n"}
{"name":"MeromorphicOn.add","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\nhg : MeromorphicOn g U\n⊢ MeromorphicOn (HAdd.hAdd f g) U","decl":"include hf hg in\nlemma add : MeromorphicOn (f + g) U := fun x hx ↦ (hf x hx).add (hg x hx)\n\n"}
{"name":"MeromorphicOn.sub","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\nhg : MeromorphicOn g U\n⊢ MeromorphicOn (HSub.hSub f g) U","decl":"include hf hg in\nlemma sub : MeromorphicOn (f - g) U := fun x hx ↦ (hf x hx).sub (hg x hx)\n\n"}
{"name":"MeromorphicOn.neg","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\n⊢ MeromorphicOn (Neg.neg f) U","decl":"include hf in\nlemma neg : MeromorphicOn (-f) U := fun x hx ↦ (hf x hx).neg\n\n"}
{"name":"MeromorphicOn.neg_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : 𝕜 → E\nU : Set 𝕜\n⊢ Iff (MeromorphicOn (Neg.neg f) U) (MeromorphicOn f U)","decl":"@[simp] lemma neg_iff : MeromorphicOn (-f) U ↔ MeromorphicOn f U :=\n  ⟨fun h ↦ by simpa only [neg_neg] using h.neg, neg⟩\n\n"}
{"name":"MeromorphicOn.smul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : 𝕜 → 𝕜\nf : 𝕜 → E\nU : Set 𝕜\nhs : MeromorphicOn s U\nhf : MeromorphicOn f U\n⊢ MeromorphicOn (HSMul.hSMul s f) U","decl":"include hs hf in\nlemma smul : MeromorphicOn (s • f) U := fun x hx ↦ (hs x hx).smul (hf x hx)\n\n"}
{"name":"MeromorphicOn.mul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns t : 𝕜 → 𝕜\nU : Set 𝕜\nhs : MeromorphicOn s U\nht : MeromorphicOn t U\n⊢ MeromorphicOn (HMul.hMul s t) U","decl":"include hs ht in\nlemma mul : MeromorphicOn (s * t) U := fun x hx ↦ (hs x hx).mul (ht x hx)\n\n"}
{"name":"MeromorphicOn.inv","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns : 𝕜 → 𝕜\nU : Set 𝕜\nhs : MeromorphicOn s U\n⊢ MeromorphicOn (Inv.inv s) U","decl":"include hs in\nlemma inv : MeromorphicOn s⁻¹ U := fun x hx ↦ (hs x hx).inv\n\n"}
{"name":"MeromorphicOn.inv_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns : 𝕜 → 𝕜\nU : Set 𝕜\n⊢ Iff (MeromorphicOn (Inv.inv s) U) (MeromorphicOn s U)","decl":"@[simp] lemma inv_iff : MeromorphicOn s⁻¹ U ↔ MeromorphicOn s U :=\n  ⟨fun h ↦ by simpa only [inv_inv] using h.inv, inv⟩\n\n"}
{"name":"MeromorphicOn.div","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns t : 𝕜 → 𝕜\nU : Set 𝕜\nhs : MeromorphicOn s U\nht : MeromorphicOn t U\n⊢ MeromorphicOn (HDiv.hDiv s t) U","decl":"include hs ht in\nlemma div : MeromorphicOn (s / t) U := fun x hx ↦ (hs x hx).div (ht x hx)\n\n"}
{"name":"MeromorphicOn.pow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns : 𝕜 → 𝕜\nU : Set 𝕜\nhs : MeromorphicOn s U\nn : Nat\n⊢ MeromorphicOn (HPow.hPow s n) U","decl":"include hs in\nlemma pow (n : ℕ) : MeromorphicOn (s ^ n) U := fun x hx ↦ (hs x hx).pow _\n\n"}
{"name":"MeromorphicOn.zpow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝ : NontriviallyNormedField 𝕜\ns : 𝕜 → 𝕜\nU : Set 𝕜\nhs : MeromorphicOn s U\nn : Int\n⊢ MeromorphicOn (HPow.hPow s n) U","decl":"include hs in\nlemma zpow (n : ℤ) : MeromorphicOn (s ^ n) U := fun x hx ↦ (hs x hx).zpow _\n\n"}
{"name":"MeromorphicOn.congr","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : 𝕜 → E\nU : Set 𝕜\nhf : MeromorphicOn f U\nh_eq : Set.EqOn f g U\nhu : IsOpen U\n⊢ MeromorphicOn g U","decl":"include hf in\nlemma congr (h_eq : Set.EqOn f g U) (hu : IsOpen U) : MeromorphicOn g U := by\n  refine fun x hx ↦ (hf x hx).congr (EventuallyEq.filter_mono ?_ nhdsWithin_le_nhds)\n  exact eventually_of_mem (hu.mem_nhds hx) h_eq\n\n"}
{"name":"MeromorphicOn.eventually_codiscreteWithin_analyticAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type u_2\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nU : Set 𝕜\ninst✝ : CompleteSpace E\nf : 𝕜 → E\nh : MeromorphicOn f U\n⊢ Filter.Eventually (fun y => AnalyticAt 𝕜 f y) (Filter.codiscreteWithin U)","decl":"theorem eventually_codiscreteWithin_analyticAt\n    [CompleteSpace E] (f : 𝕜 → E) (h : MeromorphicOn f U) :\n    ∀ᶠ (y : 𝕜) in codiscreteWithin U, AnalyticAt 𝕜 f y := by\n  rw [eventually_iff, mem_codiscreteWithin]\n  intro x hx\n  rw [disjoint_principal_right]\n  apply Filter.mem_of_superset ((h x hx).eventually_analyticAt)\n  intro x hx\n  simp [hx]\n\n"}
