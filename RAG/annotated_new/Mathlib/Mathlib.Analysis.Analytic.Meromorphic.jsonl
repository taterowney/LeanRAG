{"name":"AnalyticAt.meromorphicAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nhf : AnalyticAt ğ•œ f x\nâŠ¢ MeromorphicAt f x","decl":"@[fun_prop]\nlemma AnalyticAt.meromorphicAt {f : ğ•œ â†’ E} {x : ğ•œ} (hf : AnalyticAt ğ•œ f x) :\n    MeromorphicAt f x :=\n  âŸ¨0, by simpa only [pow_zero, one_smul]âŸ©\n\n/- Analogue of the principle of isolated zeros for an analytic function: if a function is\nmeromorphic at `zâ‚€`, then either it is identically zero in a punctured neighborhood of `zâ‚€`, or it\ndoes not vanish there at all. -/\n"}
{"name":"MeromorphicAt.eventually_eq_zero_or_eventually_ne_zero","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nzâ‚€ : ğ•œ\nhf : MeromorphicAt f zâ‚€\nâŠ¢ Or (Filter.Eventually (fun z => Eq (f z) 0) (nhdsWithin zâ‚€ (HasCompl.compl (Singleton.singleton zâ‚€)))) (Filter.Eventually (fun z => Ne (f z) 0) (nhdsWithin zâ‚€ (HasCompl.compl (Singleton.singleton zâ‚€))))","decl":"theorem MeromorphicAt.eventually_eq_zero_or_eventually_ne_zero {f : ğ•œ â†’ E} {zâ‚€ : ğ•œ}\n    (hf : MeromorphicAt f zâ‚€) :\n    (âˆ€á¶  z in ğ“[â‰ ] zâ‚€, f z = 0) âˆ¨ (âˆ€á¶  z in ğ“[â‰ ] zâ‚€, f z â‰  0) := by\n  obtain âŸ¨n, hâŸ© := hf\n  rcases h.eventually_eq_zero_or_eventually_ne_zero with hâ‚ | hâ‚‚\n  Â· left\n    filter_upwards [nhdsWithin_le_nhds hâ‚, self_mem_nhdsWithin] with y hâ‚y hâ‚‚y\n    rcases (smul_eq_zero.1 hâ‚y) with hâ‚ƒ | hâ‚„\n    Â· exact False.elim (hâ‚‚y (sub_eq_zero.1 (pow_eq_zero_iff'.1 hâ‚ƒ).1))\n    Â· assumption\n  Â· right\n    filter_upwards [hâ‚‚, self_mem_nhdsWithin] with y hâ‚y hâ‚‚y\n    exact (smul_ne_zero_iff.1 hâ‚y).2\n\n"}
{"name":"MeromorphicAt.id","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nx : ğ•œ\nâŠ¢ MeromorphicAt id x","decl":"lemma id (x : ğ•œ) : MeromorphicAt id x := analyticAt_id.meromorphicAt\n\n"}
{"name":"MeromorphicAt.const","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ne : E\nx : ğ•œ\nâŠ¢ MeromorphicAt (fun x => e) x","decl":"@[fun_prop]\nlemma const (e : E) (x : ğ•œ) : MeromorphicAt (fun _ â†¦ e) x :=\n  analyticAt_const.meromorphicAt\n\n"}
{"name":"MeromorphicAt.add","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (HAdd.hAdd f g) x","decl":"@[fun_prop]\nlemma add {f g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f + g) x := by\n  rcases hf with âŸ¨m, hfâŸ©\n  rcases hg with âŸ¨n, hgâŸ©\n  refine âŸ¨max m n, ?_âŸ©\n  have : (fun z â†¦ (z - x) ^ max m n â€¢ (f + g) z) = fun z â†¦ (z - x) ^ (max m n - m) â€¢\n      ((z - x) ^ m â€¢ f z) + (z - x) ^ (max m n - n) â€¢ ((z - x) ^ n â€¢ g z) := by\n    simp_rw [â† mul_smul, â† pow_add, Nat.sub_add_cancel (Nat.le_max_left _ _),\n      Nat.sub_add_cancel (Nat.le_max_right _ _), Pi.add_apply, smul_add]\n  rw [this]\n  exact (((analyticAt_id.sub analyticAt_const).pow _).smul hf).add\n   (((analyticAt_id.sub analyticAt_const).pow _).smul hg)\n\n"}
{"name":"MeromorphicAt.add'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (fun z => HAdd.hAdd (f z) (g z)) x","decl":"@[fun_prop]\nlemma add' {f g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z â†¦ f z + g z) x :=\n  hf.add hg\n\n"}
{"name":"MeromorphicAt.smul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ ğ•œ\ng : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (HSMul.hSMul f g) x","decl":"@[fun_prop]\nlemma smul {f : ğ•œ â†’ ğ•œ} {g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f â€¢ g) x := by\n  rcases hf with âŸ¨m, hfâŸ©\n  rcases hg with âŸ¨n, hgâŸ©\n  refine âŸ¨m + n, ?_âŸ©\n  convert hf.smul' hg using 2 with z\n  rw [Pi.smul_apply', smul_eq_mul]\n  module\n\n"}
{"name":"MeromorphicAt.smul'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ ğ•œ\ng : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (fun z => HSMul.hSMul (f z) (g z)) x","decl":"@[fun_prop]\nlemma smul' {f : ğ•œ â†’ ğ•œ} {g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z â†¦ f z â€¢ g z) x :=\n  hf.smul hg\n\n"}
{"name":"MeromorphicAt.mul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (HMul.hMul f g) x","decl":"@[fun_prop]\nlemma mul {f g : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f * g) x :=\n  hf.smul hg\n\n"}
{"name":"MeromorphicAt.mul'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (fun z => HMul.hMul (f z) (g z)) x","decl":"@[fun_prop]\nlemma mul' {f g : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z â†¦ f z * g z) x :=\n  hf.smul hg\n\n"}
{"name":"MeromorphicAt.neg","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nâŠ¢ MeromorphicAt (Neg.neg f) x","decl":"@[fun_prop]\nlemma neg {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) : MeromorphicAt (-f) x := by\n  convert (MeromorphicAt.const (-1 : ğ•œ) x).smul hf using 1\n  ext1 z\n  simp only [Pi.neg_apply, Pi.smul_apply', neg_smul, one_smul]\n\n"}
{"name":"MeromorphicAt.neg'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nâŠ¢ MeromorphicAt (fun z => Neg.neg (f z)) x","decl":"@[fun_prop]\nlemma neg' {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) : MeromorphicAt (fun z â†¦ -f z) x :=\n  hf.neg\n\n"}
{"name":"MeromorphicAt.neg_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nâŠ¢ Iff (MeromorphicAt (Neg.neg f) x) (MeromorphicAt f x)","decl":"@[simp]\nlemma neg_iff {f : ğ•œ â†’ E} {x : ğ•œ} :\n    MeromorphicAt (-f) x â†” MeromorphicAt f x :=\n  âŸ¨fun h â†¦ by simpa only [neg_neg] using h.neg, MeromorphicAt.negâŸ©\n\n"}
{"name":"MeromorphicAt.sub","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (HSub.hSub f g) x","decl":"@[fun_prop]\nlemma sub {f g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f - g) x := by\n  convert hf.add hg.neg using 1\n  ext1 z\n  simp_rw [Pi.sub_apply, Pi.add_apply, Pi.neg_apply, sub_eq_add_neg]\n\n"}
{"name":"MeromorphicAt.sub'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (fun z => HSub.hSub (f z) (g z)) x","decl":"@[fun_prop]\nlemma sub' {f g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z â†¦ f z - g z) x :=\n  hf.sub hg\n\n"}
{"name":"MeromorphicAt.congr","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhfg : (nhdsWithin x (HasCompl.compl (Singleton.singleton x))).EventuallyEq f g\nâŠ¢ MeromorphicAt g x","decl":"/-- With our definitions, `MeromorphicAt f x` depends only on the values of `f` on a punctured\nneighbourhood of `x` (not on `f x`) -/\nlemma congr {f g : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (hfg : f =á¶ [ğ“[â‰ ] x] g) :\n    MeromorphicAt g x := by\n  rcases hf with âŸ¨m, hfâŸ©\n  refine âŸ¨m + 1, ?_âŸ©\n  have : AnalyticAt ğ•œ (fun z â†¦ z - x) x := analyticAt_id.sub analyticAt_const\n  refine (this.smul' hf).congr ?_\n  rw [eventuallyEq_nhdsWithin_iff] at hfg\n  filter_upwards [hfg] with z hz\n  rcases eq_or_ne z x with rfl | hn\n  Â· simp\n  Â· rw [hz (Set.mem_compl_singleton_iff.mp hn), pow_succ', mul_smul]\n\n"}
{"name":"MeromorphicAt.inv","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nâŠ¢ MeromorphicAt (Inv.inv f) x","decl":"@[fun_prop]\nlemma inv {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) : MeromorphicAt fâ»Â¹ x := by\n  rcases hf with âŸ¨m, hfâŸ©\n  by_cases h_eq : (fun z â†¦ (z - x) ^ m â€¢ f z) =á¶ [ğ“ x] 0\n  Â· -- silly case: f locally 0 near x\n    refine (MeromorphicAt.const 0 x).congr ?_\n    rw [eventuallyEq_nhdsWithin_iff]\n    filter_upwards [h_eq] with z hfz hz\n    rw [Pi.inv_apply, (smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)).mp hfz,\n      inv_zero]\n  Â· -- interesting case: use local formula for `f`\n    obtain âŸ¨n, g, hg_an, hg_ne, hg_eqâŸ© := hf.exists_eventuallyEq_pow_smul_nonzero_iff.mpr h_eq\n    have : AnalyticAt ğ•œ (fun z â†¦ (z - x) ^ (m + 1)) x :=\n      (analyticAt_id.sub analyticAt_const).pow _\n    -- use `m + 1` rather than `m` to damp out any silly issues with the value at `z = x`\n    refine âŸ¨n + 1, (this.smul' <| hg_an.inv hg_ne).congr ?_âŸ©\n    filter_upwards [hg_eq, hg_an.continuousAt.eventually_ne hg_ne] with z hfg hg_ne'\n    rcases eq_or_ne z x with rfl | hz_ne\n    Â· simp only [sub_self, pow_succ, mul_zero, zero_smul]\n    Â· simp_rw [smul_eq_mul] at hfg âŠ¢\n      have aux1 : f z â‰  0 := by\n        have : (z - x) ^ n * g z â‰  0 := mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz_ne)) hg_ne'\n        rw [â† hfg, mul_ne_zero_iff] at this\n        exact this.2\n      field_simp [sub_ne_zero.mpr hz_ne]\n      rw [pow_succ', mul_assoc, hfg]\n      ring\n\n"}
{"name":"MeromorphicAt.inv'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nâŠ¢ MeromorphicAt (fun z => Inv.inv (f z)) x","decl":"@[fun_prop]\nlemma inv' {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) : MeromorphicAt (fun z â†¦ (f z)â»Â¹) x :=\n  hf.inv\n\n"}
{"name":"MeromorphicAt.inv_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nâŠ¢ Iff (MeromorphicAt (Inv.inv f) x) (MeromorphicAt f x)","decl":"@[simp]\nlemma inv_iff {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} :\n    MeromorphicAt fâ»Â¹ x â†” MeromorphicAt f x :=\n  âŸ¨fun h â†¦ by simpa only [inv_inv] using h.inv, MeromorphicAt.invâŸ©\n\n"}
{"name":"MeromorphicAt.div","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (HDiv.hDiv f g) x","decl":"@[fun_prop]\nlemma div {f g : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (f / g) x :=\n  (div_eq_mul_inv f g).symm â–¸ (hf.mul hg.inv)\n\n"}
{"name":"MeromorphicAt.div'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ MeromorphicAt (fun z => HDiv.hDiv (f z) (g z)) x","decl":"@[fun_prop]\nlemma div' {f g : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    MeromorphicAt (fun z â†¦ f z / g z) x :=\n  hf.div hg\n\n"}
{"name":"MeromorphicAt.pow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nn : Nat\nâŠ¢ MeromorphicAt (HPow.hPow f n) x","decl":"@[fun_prop]\nlemma pow {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„•) : MeromorphicAt (f ^ n) x := by\n  induction n with\n  | zero => simpa only [pow_zero] using MeromorphicAt.const 1 x\n  | succ m hm => simpa only [pow_succ] using hm.mul hf\n\n"}
{"name":"MeromorphicAt.pow'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nn : Nat\nâŠ¢ MeromorphicAt (fun z => HPow.hPow (f z) n) x","decl":"@[fun_prop]\nlemma pow' {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„•) :\n    MeromorphicAt (fun z â†¦ (f z) ^ n) x :=\n  hf.pow n\n\n"}
{"name":"MeromorphicAt.zpow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nn : Int\nâŠ¢ MeromorphicAt (HPow.hPow f n) x","decl":"@[fun_prop]\nlemma zpow {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) : MeromorphicAt (f ^ n) x := by\n  induction n with\n  | ofNat m => simpa only [Int.ofNat_eq_coe, zpow_natCast] using hf.pow m\n  | negSucc m => simpa only [zpow_negSucc, inv_iff] using hf.pow (m + 1)\n\n"}
{"name":"MeromorphicAt.zpow'","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nn : Int\nâŠ¢ MeromorphicAt (fun z => HPow.hPow (f z) n) x","decl":"@[fun_prop]\nlemma zpow' {f : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) :\n    MeromorphicAt (fun z â†¦ (f z) ^ n) x :=\n  hf.zpow n\n\n"}
{"name":"MeromorphicAt.eventually_analyticAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\nf : ğ•œ â†’ E\nx : ğ•œ\nh : MeromorphicAt f x\nâŠ¢ Filter.Eventually (fun y => AnalyticAt ğ•œ f y) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))","decl":"theorem eventually_analyticAt [CompleteSpace E] {f : ğ•œ â†’ E} {x : ğ•œ}\n    (h : MeromorphicAt f x) : âˆ€á¶  y in ğ“[â‰ ] x, AnalyticAt ğ•œ f y := by\n  rw [MeromorphicAt] at h\n  obtain âŸ¨n, hâŸ© := h\n  apply AnalyticAt.eventually_analyticAt at h\n  refine (h.filter_mono ?_).mp ?_\n  Â· simp [nhdsWithin]\n  Â· rw [eventually_nhdsWithin_iff]\n    apply Filter.Eventually.of_forall\n    intro y hy hf\n    rw [Set.mem_compl_iff, Set.mem_singleton_iff] at hy\n    have := ((analyticAt_id (ğ•œ := ğ•œ).sub analyticAt_const).pow n).inv\n      (pow_ne_zero _ (sub_ne_zero_of_ne hy))\n    apply (this.smul hf).congr âˆ˜ (eventually_ne_nhds hy).mono\n    intro z hz\n    simp [smul_smul, hz, sub_eq_zero]\n\n"}
{"name":"MeromorphicAt.order_eq_top_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nâŠ¢ Iff (Eq hf.order Top.top) (Filter.Eventually (fun z => Eq (f z) 0) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))))","decl":"lemma order_eq_top_iff {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) :\n    hf.order = âŠ¤ â†” âˆ€á¶  z in ğ“[â‰ ] x, f z = 0 := by\n  unfold order\n  by_cases h : hf.choose_spec.order = âŠ¤\n  Â· rw [h, ENat.map_top, â† WithTop.coe_natCast,\n      top_sub, eq_self, true_iff, eventually_nhdsWithin_iff]\n    rw [AnalyticAt.order_eq_top_iff] at h\n    filter_upwards [h] with z hf hz\n    rwa [smul_eq_zero_iff_right <| pow_ne_zero _ (sub_ne_zero.mpr hz)] at hf\n  Â· obtain âŸ¨m, hmâŸ© := ENat.ne_top_iff_exists.mp h\n    simp only [â† hm, ENat.map_coe, WithTop.coe_natCast, sub_eq_top_iff, WithTop.natCast_ne_top,\n      or_self, false_iff]\n    contrapose! h\n    rw [AnalyticAt.order_eq_top_iff]\n    rw [â† hf.choose_spec.frequently_eq_iff_eventually_eq analyticAt_const]\n    apply Eventually.frequently\n    filter_upwards [h] with z hfz\n    rw [hfz, smul_zero]\n\n"}
{"name":"MeromorphicAt.order_eq_int_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nn : Int\nâŠ¢ Iff (Eq hf.order â†‘n) (Exists fun g => And (AnalyticAt ğ•œ g x) (And (Ne (g x) 0) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z x) n) (g z))) (nhdsWithin x (HasCompl.compl (Singleton.singleton x))))))","decl":"lemma order_eq_int_iff {f : ğ•œ â†’ E} {x : ğ•œ} (hf : MeromorphicAt f x) (n : â„¤) : hf.order = n â†”\n    âˆƒ g : ğ•œ â†’ E, AnalyticAt ğ•œ g x âˆ§ g x â‰  0 âˆ§ âˆ€á¶  z in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z := by\n  unfold order\n  by_cases h : hf.choose_spec.order = âŠ¤\n  Â· rw [h, ENat.map_top, â† WithTop.coe_natCast, top_sub,\n      eq_false_intro WithTop.top_ne_coe, false_iff]\n    rw [AnalyticAt.order_eq_top_iff] at h\n    refine fun âŸ¨g, hg_an, hg_ne, hg_eqâŸ© â†¦ hg_ne ?_\n    apply EventuallyEq.eq_of_nhds\n    rw [EventuallyEq, â† AnalyticAt.frequently_eq_iff_eventually_eq hg_an analyticAt_const]\n    apply Eventually.frequently\n    rw [eventually_nhdsWithin_iff] at hg_eq âŠ¢\n    filter_upwards [h, hg_eq] with z hfz hfz_eq hz\n    rwa [hfz_eq hz, â† mul_smul, smul_eq_zero_iff_right] at hfz\n    exact mul_ne_zero (pow_ne_zero _ (sub_ne_zero.mpr hz)) (zpow_ne_zero _ (sub_ne_zero.mpr hz))\n  Â· obtain âŸ¨m, hâŸ© := ENat.ne_top_iff_exists.mp h\n    rw [â† h, ENat.map_coe, â† WithTop.coe_natCast, â† coe_sub, WithTop.coe_inj]\n    obtain âŸ¨g, hg_an, hg_ne, hg_eqâŸ© := (AnalyticAt.order_eq_nat_iff _ _).mp h.symm\n    replace hg_eq : âˆ€á¶  (z : ğ•œ) in ğ“[â‰ ] x, f z = (z - x) ^ (â†‘m - â†‘hf.choose : â„¤) â€¢ g z := by\n      rw [eventually_nhdsWithin_iff]\n      filter_upwards [hg_eq] with z hg_eq hz\n      rwa [â† smul_right_inj <| zpow_ne_zero _ (sub_ne_zero.mpr hz), â† mul_smul,\n        â† zpow_addâ‚€ (sub_ne_zero.mpr hz), â† add_sub_assoc, add_sub_cancel_left, zpow_natCast,\n        zpow_natCast]\n    exact âŸ¨fun h â†¦ âŸ¨g, hg_an, hg_ne, h â–¸ hg_eqâŸ©,\n      AnalyticAt.unique_eventuallyEq_zpow_smul_nonzero âŸ¨g, hg_an, hg_ne, hg_eqâŸ©âŸ©\n\n"}
{"name":"AnalyticAt.meromorphicAt_order","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nhf : AnalyticAt ğ•œ f x\nâŠ¢ Eq â‹¯.order (ENat.map Nat.cast hf.order)","decl":"/-- Compatibility of notions of `order` for analytic and meromorphic functions. -/\nlemma _root_.AnalyticAt.meromorphicAt_order {f : ğ•œ â†’ E} {x : ğ•œ} (hf : AnalyticAt ğ•œ f x) :\n    hf.meromorphicAt.order = hf.order.map (â†‘) := by\n  rcases eq_or_ne hf.order âŠ¤ with ho | ho\n  Â· rw [ho, ENat.map_top, order_eq_top_iff]\n    exact (hf.order_eq_top_iff.mp ho).filter_mono nhdsWithin_le_nhds\n  Â· obtain âŸ¨n, hnâŸ© := ENat.ne_top_iff_exists.mp ho\n    simp_rw [â† hn, ENat.map_coe, order_eq_int_iff, zpow_natCast]\n    rcases (hf.order_eq_nat_iff _).mp hn.symm with âŸ¨g, h1, h2, h3âŸ©\n    exact âŸ¨g, h1, h2, h3.filter_mono nhdsWithin_le_nhdsâŸ©\n\n"}
{"name":"MeromorphicAt.order_smul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ ğ•œ\ng : ğ•œ â†’ E\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ Eq â‹¯.order (HAdd.hAdd hf.order hg.order)","decl":"/-- The order is additive when multiplying scalar-valued and vector-valued meromorphic functions. -/\ntheorem order_smul {f : ğ•œ â†’ ğ•œ} {g : ğ•œ â†’ E} {x : ğ•œ}\n    (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    (hf.smul hg).order = hf.order + hg.order := by\n  -- Trivial cases: one of the functions vanishes around zâ‚€\n  cases' hâ‚‚f : hf.order with m hâ‚‚f\n  Â· simp only [top_add, order_eq_top_iff] at hâ‚‚f âŠ¢\n    filter_upwards [hâ‚‚f] with z hz using by simp [hz]\n  cases' hâ‚‚g : hg.order with n hâ‚‚f\n  Â· simp only [add_top, order_eq_top_iff] at hâ‚‚g âŠ¢\n    filter_upwards [hâ‚‚g] with z hz using by simp [hz]\n  -- Non-trivial case: both functions do not vanish around zâ‚€\n  rw [â† WithTop.coe_add, order_eq_int_iff]\n  obtain âŸ¨F, hâ‚F, hâ‚‚F, hâ‚ƒFâŸ© := (hf.order_eq_int_iff _).1 hâ‚‚f\n  obtain âŸ¨G, hâ‚G, hâ‚‚G, hâ‚ƒGâŸ© := (hg.order_eq_int_iff _).1 hâ‚‚g\n  use F â€¢ G, hâ‚F.smul hâ‚G, by simp [hâ‚‚F, hâ‚‚G]\n  filter_upwards [self_mem_nhdsWithin, hâ‚ƒF, hâ‚ƒG] with a ha hfa hga\n  simp [hfa, hga, smul_comm (F a), zpow_addâ‚€ (sub_ne_zero.mpr ha), mul_smul]\n\n"}
{"name":"MeromorphicAt.order_mul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nf g : ğ•œ â†’ ğ•œ\nx : ğ•œ\nhf : MeromorphicAt f x\nhg : MeromorphicAt g x\nâŠ¢ Eq â‹¯.order (HAdd.hAdd hf.order hg.order)","decl":"/-- The order is additive when multiplying meromorphic functions. -/\ntheorem order_mul {f g : ğ•œ â†’ ğ•œ} {x : ğ•œ} (hf : MeromorphicAt f x) (hg : MeromorphicAt g x) :\n    (hf.mul hg).order = hf.order + hg.order :=\n  hf.order_smul hg\n\n"}
{"name":"MeromorphicAt.iff_eventuallyEq_zpow_smul_analyticAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nx : ğ•œ\nâŠ¢ Iff (MeromorphicAt f x) (Exists fun n => Exists fun g => And (AnalyticAt ğ•œ g x) (Filter.Eventually (fun z => Eq (f z) (HSMul.hSMul (HPow.hPow (HSub.hSub z x) n) (g z))) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))))","decl":"lemma iff_eventuallyEq_zpow_smul_analyticAt {f : ğ•œ â†’ E} {x : ğ•œ} : MeromorphicAt f x â†”\n    âˆƒ (n : â„¤) (g : ğ•œ â†’ E), AnalyticAt ğ•œ g x âˆ§ âˆ€á¶  z in ğ“[â‰ ] x, f z = (z - x) ^ n â€¢ g z := by\n  refine âŸ¨fun âŸ¨n, hnâŸ© â†¦ âŸ¨-n, _, âŸ¨hn, eventually_nhdsWithin_iff.mpr ?_âŸ©âŸ©, ?_âŸ©\n  Â· filter_upwards with z hz\n    match_scalars\n    field_simp [sub_ne_zero.mpr hz]\n  Â· refine fun âŸ¨n, g, hg_an, hg_eqâŸ© â†¦ MeromorphicAt.congr ?_ (EventuallyEq.symm hg_eq)\n    exact (((MeromorphicAt.id x).sub (.const _ x)).zpow _).smul hg_an.meromorphicAt\n\n"}
{"name":"AnalyticOnNhd.meromorphicOn","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhf : AnalyticOnNhd ğ•œ f U\nâŠ¢ MeromorphicOn f U","decl":"lemma AnalyticOnNhd.meromorphicOn {f : ğ•œ â†’ E} {U : Set ğ•œ} (hf : AnalyticOnNhd ğ•œ f U) :\n    MeromorphicOn f U :=\n  fun x hx â†¦ (hf x hx).meromorphicAt\n\n"}
{"name":"AnalyticOn.meromorphicOn","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhf : AnalyticOnNhd ğ•œ f U\nâŠ¢ MeromorphicOn f U","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticOn.meromorphicOn := AnalyticOnNhd.meromorphicOn\n\n"}
{"name":"MeromorphicOn.id","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\nU : Set ğ•œ\nâŠ¢ MeromorphicOn id U","decl":"lemma id {U : Set ğ•œ} : MeromorphicOn id U := fun x _ â†¦ .id x\n\n"}
{"name":"MeromorphicOn.const","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ne : E\nU : Set ğ•œ\nâŠ¢ MeromorphicOn (fun x => e) U","decl":"lemma const (e : E) {U : Set ğ•œ} : MeromorphicOn (fun _ â†¦ e) U :=\n  fun x _ â†¦ .const e x\n\n"}
{"name":"MeromorphicOn.isClopen_setOf_order_eq_top","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nâŠ¢ IsClopen (setOf fun u => Eq â‹¯.order Top.top)","decl":"/-- The set where a meromorphic function has infinite order is clopen in its domain of meromorphy.\n-/\ntheorem isClopen_setOf_order_eq_top {U : Set ğ•œ} (hf : MeromorphicOn f U) :\n    IsClopen { u : U | (hf u.1 u.2).order = âŠ¤ } := by\n  constructor\n  Â· rw [â† isOpen_compl_iff, isOpen_iff_forall_mem_open]\n    intro z hz\n    rcases (hf z.1 z.2).eventually_eq_zero_or_eventually_ne_zero with h | h\n    Â· -- Case: f is locally zero in a punctured neighborhood of z\n      rw [â† (hf z.1 z.2).order_eq_top_iff] at h\n      tauto\n    Â· -- Case: f is locally nonzero in a punctured neighborhood of z\n      obtain âŸ¨t', hâ‚t', hâ‚‚t', hâ‚ƒt'âŸ© := eventually_nhds_iff.1 (eventually_nhdsWithin_iff.1 h)\n      use Subtype.val â»Â¹' t'\n      constructor\n      Â· intro w hw\n        simp only [Set.mem_compl_iff, Set.mem_setOf_eq]\n        by_cases hâ‚w : w = z\n        Â· rwa [hâ‚w]\n        Â· rw [MeromorphicAt.order_eq_top_iff, not_eventually]\n          apply Filter.Eventually.frequently\n          rw [eventually_nhdsWithin_iff, eventually_nhds_iff]\n          use t' \\ {z.1}, fun y hâ‚y hâ‚‚y â†¦ hâ‚t' y hâ‚y.1 hâ‚y.2, hâ‚‚t'.sdiff isClosed_singleton, hw,\n            Set.mem_singleton_iff.not.2 (Subtype.coe_ne_coe.mpr hâ‚w)\n      Â· exact âŸ¨isOpen_induced hâ‚‚t', hâ‚ƒt'âŸ©\n  Â· apply isOpen_iff_forall_mem_open.mpr\n    intro z hz\n    conv =>\n      arg 1; intro; left; right; arg 1; intro\n      rw [MeromorphicAt.order_eq_top_iff, eventually_nhdsWithin_iff, eventually_nhds_iff]\n    simp only [Set.mem_setOf_eq] at hz\n    rw [MeromorphicAt.order_eq_top_iff, eventually_nhdsWithin_iff, eventually_nhds_iff] at hz\n    obtain âŸ¨t', hâ‚t', hâ‚‚t', hâ‚ƒt'âŸ© := hz\n    use Subtype.val â»Â¹' t'\n    simp only [Set.mem_compl_iff, Set.mem_singleton_iff, isOpen_induced hâ‚‚t', Set.mem_preimage,\n      hâ‚ƒt', and_self, and_true]\n    intro w hw\n    simp only [Set.mem_setOf_eq]\n    -- Trivial case: w = z\n    by_cases hâ‚w : w = z\n    Â· rw [hâ‚w]\n      tauto\n    -- Nontrivial case: w â‰  z\n    use t' \\ {z.1}, fun y hâ‚y _ â†¦ hâ‚t' y (Set.mem_of_mem_diff hâ‚y) (Set.mem_of_mem_inter_right hâ‚y)\n    constructor\n    Â· exact hâ‚‚t'.sdiff isClosed_singleton\n    Â· apply (Set.mem_diff w).1\n      exact âŸ¨hw, Set.mem_singleton_iff.not.1 (Subtype.coe_ne_coe.2 hâ‚w)âŸ©\n\n"}
{"name":"MeromorphicOn.exists_order_ne_top_iff_forall","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nhU : IsConnected U\nâŠ¢ Iff (Exists fun u => Ne â‹¯.order Top.top) (âˆ€ (u : â†‘U), Ne â‹¯.order Top.top)","decl":"/-- On a connected set, there exists a point where a meromorphic function `f` has finite order iff\n`f` has finite order at every point. -/\ntheorem exists_order_ne_top_iff_forall {U : Set ğ•œ} (hf : MeromorphicOn f U) (hU : IsConnected U) :\n    (âˆƒ u : U, (hf u u.2).order â‰  âŠ¤) â†” (âˆ€ u : U, (hf u u.2).order â‰  âŠ¤) := by\n  constructor\n  Â· intro hâ‚‚f\n    have := isPreconnected_iff_preconnectedSpace.1 hU.isPreconnected\n    rcases isClopen_iff.1 hf.isClopen_setOf_order_eq_top with h | h\n    Â· intro u\n      have : u âˆ‰ (âˆ… : Set U) := by exact fun a => a\n      rw [â† h] at this\n      tauto\n    Â· obtain âŸ¨u, hUâŸ© := hâ‚‚f\n      have : u âˆˆ Set.univ := by trivial\n      rw [â† h] at this\n      tauto\n  Â· intro hâ‚‚f\n    obtain âŸ¨v, hvâŸ© := hU.nonempty\n    use âŸ¨v, hvâŸ©, hâ‚‚f âŸ¨v, hvâŸ©\n\n"}
{"name":"MeromorphicOn.order_ne_top_of_isPreconnected","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nx y : ğ•œ\nhf : MeromorphicOn f U\nhU : IsPreconnected U\nhâ‚x : Membership.mem U x\nhy : Membership.mem U y\nhâ‚‚x : Ne â‹¯.order Top.top\nâŠ¢ Ne â‹¯.order Top.top","decl":"/-- On a preconnected set, a meromorphic function has finite order at one point if it has finite\norder at another point. -/\ntheorem order_ne_top_of_isPreconnected {U : Set ğ•œ} {x y : ğ•œ} (hf : MeromorphicOn f U)\n    (hU : IsPreconnected U) (hâ‚x : x âˆˆ U) (hy : y âˆˆ U) (hâ‚‚x : (hf x hâ‚x).order â‰  âŠ¤) :\n    (hf y hy).order â‰  âŠ¤ :=\n  (hf.exists_order_ne_top_iff_forall âŸ¨Set.nonempty_of_mem hâ‚x, hUâŸ©).1 (by use âŸ¨x, hâ‚xâŸ©) âŸ¨y, hyâŸ©\n\n"}
{"name":"MeromorphicOn.mono_set","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nV : Set ğ•œ\nhv : HasSubset.Subset V U\nâŠ¢ MeromorphicOn f V","decl":"include hf in\nlemma mono_set {V : Set ğ•œ} (hv : V âŠ† U) : MeromorphicOn f V := fun x hx â†¦ hf x (hv hx)\n\n"}
{"name":"MeromorphicOn.add","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nhg : MeromorphicOn g U\nâŠ¢ MeromorphicOn (HAdd.hAdd f g) U","decl":"include hf hg in\nlemma add : MeromorphicOn (f + g) U := fun x hx â†¦ (hf x hx).add (hg x hx)\n\n"}
{"name":"MeromorphicOn.sub","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nhg : MeromorphicOn g U\nâŠ¢ MeromorphicOn (HSub.hSub f g) U","decl":"include hf hg in\nlemma sub : MeromorphicOn (f - g) U := fun x hx â†¦ (hf x hx).sub (hg x hx)\n\n"}
{"name":"MeromorphicOn.neg","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nâŠ¢ MeromorphicOn (Neg.neg f) U","decl":"include hf in\nlemma neg : MeromorphicOn (-f) U := fun x hx â†¦ (hf x hx).neg\n\n"}
{"name":"MeromorphicOn.neg_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : ğ•œ â†’ E\nU : Set ğ•œ\nâŠ¢ Iff (MeromorphicOn (Neg.neg f) U) (MeromorphicOn f U)","decl":"@[simp] lemma neg_iff : MeromorphicOn (-f) U â†” MeromorphicOn f U :=\n  âŸ¨fun h â†¦ by simpa only [neg_neg] using h.neg, negâŸ©\n\n"}
{"name":"MeromorphicOn.smul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : ğ•œ â†’ ğ•œ\nf : ğ•œ â†’ E\nU : Set ğ•œ\nhs : MeromorphicOn s U\nhf : MeromorphicOn f U\nâŠ¢ MeromorphicOn (HSMul.hSMul s f) U","decl":"include hs hf in\nlemma smul : MeromorphicOn (s â€¢ f) U := fun x hx â†¦ (hs x hx).smul (hf x hx)\n\n"}
{"name":"MeromorphicOn.mul","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns t : ğ•œ â†’ ğ•œ\nU : Set ğ•œ\nhs : MeromorphicOn s U\nht : MeromorphicOn t U\nâŠ¢ MeromorphicOn (HMul.hMul s t) U","decl":"include hs ht in\nlemma mul : MeromorphicOn (s * t) U := fun x hx â†¦ (hs x hx).mul (ht x hx)\n\n"}
{"name":"MeromorphicOn.inv","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns : ğ•œ â†’ ğ•œ\nU : Set ğ•œ\nhs : MeromorphicOn s U\nâŠ¢ MeromorphicOn (Inv.inv s) U","decl":"include hs in\nlemma inv : MeromorphicOn sâ»Â¹ U := fun x hx â†¦ (hs x hx).inv\n\n"}
{"name":"MeromorphicOn.inv_iff","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns : ğ•œ â†’ ğ•œ\nU : Set ğ•œ\nâŠ¢ Iff (MeromorphicOn (Inv.inv s) U) (MeromorphicOn s U)","decl":"@[simp] lemma inv_iff : MeromorphicOn sâ»Â¹ U â†” MeromorphicOn s U :=\n  âŸ¨fun h â†¦ by simpa only [inv_inv] using h.inv, invâŸ©\n\n"}
{"name":"MeromorphicOn.div","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns t : ğ•œ â†’ ğ•œ\nU : Set ğ•œ\nhs : MeromorphicOn s U\nht : MeromorphicOn t U\nâŠ¢ MeromorphicOn (HDiv.hDiv s t) U","decl":"include hs ht in\nlemma div : MeromorphicOn (s / t) U := fun x hx â†¦ (hs x hx).div (ht x hx)\n\n"}
{"name":"MeromorphicOn.pow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns : ğ•œ â†’ ğ•œ\nU : Set ğ•œ\nhs : MeromorphicOn s U\nn : Nat\nâŠ¢ MeromorphicOn (HPow.hPow s n) U","decl":"include hs in\nlemma pow (n : â„•) : MeromorphicOn (s ^ n) U := fun x hx â†¦ (hs x hx).pow _\n\n"}
{"name":"MeromorphicOn.zpow","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœ : NontriviallyNormedField ğ•œ\ns : ğ•œ â†’ ğ•œ\nU : Set ğ•œ\nhs : MeromorphicOn s U\nn : Int\nâŠ¢ MeromorphicOn (HPow.hPow s n) U","decl":"include hs in\nlemma zpow (n : â„¤) : MeromorphicOn (s ^ n) U := fun x hx â†¦ (hs x hx).zpow _\n\n"}
{"name":"MeromorphicOn.congr","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : ğ•œ â†’ E\nU : Set ğ•œ\nhf : MeromorphicOn f U\nh_eq : Set.EqOn f g U\nhu : IsOpen U\nâŠ¢ MeromorphicOn g U","decl":"include hf in\nlemma congr (h_eq : Set.EqOn f g U) (hu : IsOpen U) : MeromorphicOn g U := by\n  refine fun x hx â†¦ (hf x hx).congr (EventuallyEq.filter_mono ?_ nhdsWithin_le_nhds)\n  exact eventually_of_mem (hu.mem_nhds hx) h_eq\n\n"}
{"name":"MeromorphicOn.eventually_codiscreteWithin_analyticAt","module":"Mathlib.Analysis.Analytic.Meromorphic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type u_2\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\nU : Set ğ•œ\ninstâœ : CompleteSpace E\nf : ğ•œ â†’ E\nh : MeromorphicOn f U\nâŠ¢ Filter.Eventually (fun y => AnalyticAt ğ•œ f y) (Filter.codiscreteWithin U)","decl":"theorem eventually_codiscreteWithin_analyticAt\n    [CompleteSpace E] (f : ğ•œ â†’ E) (h : MeromorphicOn f U) :\n    âˆ€á¶  (y : ğ•œ) in codiscreteWithin U, AnalyticAt ğ•œ f y := by\n  rw [eventually_iff, mem_codiscreteWithin]\n  intro x hx\n  rw [disjoint_principal_right]\n  apply Filter.mem_of_superset ((h x hx).eventually_analyticAt)\n  intro x hx\n  simp [hx]\n\n"}
