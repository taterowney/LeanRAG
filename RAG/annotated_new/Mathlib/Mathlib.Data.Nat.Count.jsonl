{"name":"Nat.count_zero","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Nat.count p 0) 0","decl":"@[simp]\ntheorem count_zero : count p 0 = 0 := by\n  rw [count, List.range_zero, List.countP, List.countP.go]\n\n"}
{"name":"Nat.count_eq_card_filter_range","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Eq (Nat.count p n) (Finset.filter (fun x => p x) (Finset.range n)).card","decl":"theorem count_eq_card_filter_range (n : ℕ) : count p n = #{x ∈ range n | p x} := by\n  rw [count, List.countP_eq_length_filter]\n  rfl\n\n"}
{"name":"Nat.count_eq_card_fintype","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Eq (Nat.count p n) (Fintype.card (Subtype fun k => And (LT.lt k n) (p k)))","decl":"/-- `count p n` can be expressed as the cardinality of `{k // k < n ∧ p k}`. -/\ntheorem count_eq_card_fintype (n : ℕ) : count p n = Fintype.card { k : ℕ // k < n ∧ p k } := by\n  rw [count_eq_card_filter_range, ← Fintype.card_ofFinset, ← CountSet.fintype]\n  rfl\n\n"}
{"name":"Nat.count_le","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ LE.le (Nat.count p n) n","decl":"theorem count_le {n : ℕ} : count p n ≤ n := by\n  rw [count_eq_card_filter_range]\n  exact (card_filter_le _ _).trans_eq (card_range _)\n\n"}
{"name":"Nat.count_succ","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Eq (Nat.count p (HAdd.hAdd n 1)) (HAdd.hAdd (Nat.count p n) (ite (p n) 1 0))","decl":"theorem count_succ (n : ℕ) : count p (n + 1) = count p n + if p n then 1 else 0 := by\n  split_ifs with h <;> simp [count, List.range_succ, h]\n\n"}
{"name":"Nat.count_monotone","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\n⊢ Monotone (Nat.count p)","decl":"@[mono]\ntheorem count_monotone : Monotone (count p) :=\n  monotone_nat_of_le_succ fun n ↦ by by_cases h : p n <;> simp [count_succ, h]\n\n"}
{"name":"Nat.count_add","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\na b : Nat\n⊢ Eq (Nat.count p (HAdd.hAdd a b)) (HAdd.hAdd (Nat.count p a) (Nat.count (fun k => p (HAdd.hAdd a k)) b))","decl":"theorem count_add (a b : ℕ) : count p (a + b) = count p a + count (fun k ↦ p (a + k)) b := by\n  have : Disjoint {x ∈ range a | p x} {x ∈ (range b).map <| addLeftEmbedding a | p x} := by\n    apply disjoint_filter_filter\n    rw [Finset.disjoint_left]\n    simp_rw [mem_map, mem_range, addLeftEmbedding_apply]\n    rintro x hx ⟨c, _, rfl⟩\n    exact (self_le_add_right _ _).not_lt hx\n  simp_rw [count_eq_card_filter_range, range_add, filter_union, card_union_of_disjoint this,\n    filter_map, addLeftEmbedding, card_map]\n  rfl\n\n"}
{"name":"Nat.count_add'","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\na b : Nat\n⊢ Eq (Nat.count p (HAdd.hAdd a b)) (HAdd.hAdd (Nat.count (fun k => p (HAdd.hAdd k b)) a) (Nat.count p b))","decl":"theorem count_add' (a b : ℕ) : count p (a + b) = count (fun k ↦ p (k + b)) a + count p b := by\n  rw [add_comm, count_add, add_comm]\n  simp_rw [add_comm b]\n\n"}
{"name":"Nat.count_one","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\n⊢ Eq (Nat.count p 1) (ite (p 0) 1 0)","decl":"theorem count_one : count p 1 = if p 0 then 1 else 0 := by simp [count_succ]\n\n"}
{"name":"Nat.count_succ'","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Eq (Nat.count p (HAdd.hAdd n 1)) (HAdd.hAdd (Nat.count (fun k => p (HAdd.hAdd k 1)) n) (ite (p 0) 1 0))","decl":"theorem count_succ' (n : ℕ) :\n    count p (n + 1) = count (fun k ↦ p (k + 1)) n + if p 0 then 1 else 0 := by\n  rw [count_add', count_one]\n\n"}
{"name":"Nat.count_lt_count_succ_iff","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Iff (LT.lt (Nat.count p n) (Nat.count p (HAdd.hAdd n 1))) (p n)","decl":"@[simp]\ntheorem count_lt_count_succ_iff {n : ℕ} : count p n < count p (n + 1) ↔ p n := by\n  by_cases h : p n <;> simp [count_succ, h]\n\n"}
{"name":"Nat.count_succ_eq_succ_count_iff","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Iff (Eq (Nat.count p (HAdd.hAdd n 1)) (HAdd.hAdd (Nat.count p n) 1)) (p n)","decl":"theorem count_succ_eq_succ_count_iff {n : ℕ} : count p (n + 1) = count p n + 1 ↔ p n := by\n  by_cases h : p n <;> simp [h, count_succ]\n\n"}
{"name":"Nat.count_succ_eq_count_iff","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Iff (Eq (Nat.count p (HAdd.hAdd n 1)) (Nat.count p n)) (Not (p n))","decl":"theorem count_succ_eq_count_iff {n : ℕ} : count p (n + 1) = count p n ↔ ¬p n := by\n  by_cases h : p n <;> simp [h, count_succ]\n\n"}
{"name":"Nat.count_succ_eq_succ_count","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\na✝ : p n\n⊢ Eq (Nat.count p (HAdd.hAdd n 1)) (HAdd.hAdd (Nat.count p n) 1)","decl":"alias ⟨_, count_succ_eq_succ_count⟩ := count_succ_eq_succ_count_iff\n\n"}
{"name":"Nat.count_succ_eq_count","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\na✝ : Not (p n)\n⊢ Eq (Nat.count p (HAdd.hAdd n 1)) (Nat.count p n)","decl":"alias ⟨_, count_succ_eq_count⟩ := count_succ_eq_count_iff\n\n"}
{"name":"Nat.count_le_cardinal","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ LE.le (↑(Nat.count p n)) (Cardinal.mk ↑(setOf fun k => p k))","decl":"theorem count_le_cardinal (n : ℕ) : (count p n : Cardinal) ≤ Cardinal.mk { k | p k } := by\n  rw [count_eq_card_fintype, ← Cardinal.mk_fintype]\n  exact Cardinal.mk_subtype_mono fun x hx ↦ hx.2\n\n"}
{"name":"Nat.lt_of_count_lt_count","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\na b : Nat\nh : LT.lt (Nat.count p a) (Nat.count p b)\n⊢ LT.lt a b","decl":"theorem lt_of_count_lt_count {a b : ℕ} (h : count p a < count p b) : a < b :=\n  (count_monotone p).reflect_lt h\n\n"}
{"name":"Nat.count_strict_mono","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nm n : Nat\nhm : p m\nhmn : LT.lt m n\n⊢ LT.lt (Nat.count p m) (Nat.count p n)","decl":"theorem count_strict_mono {m n : ℕ} (hm : p m) (hmn : m < n) : count p m < count p n :=\n  (count_lt_count_succ_iff.2 hm).trans_le <| count_monotone _ (Nat.succ_le_iff.2 hmn)\n\n"}
{"name":"Nat.count_injective","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nm n : Nat\nhm : p m\nhn : p n\nheq : Eq (Nat.count p m) (Nat.count p n)\n⊢ Eq m n","decl":"theorem count_injective {m n : ℕ} (hm : p m) (hn : p n) (heq : count p m = count p n) : m = n := by\n  by_contra! h : m ≠ n\n  wlog hmn : m < n\n  · exact this hn hm heq.symm h.symm (h.lt_or_lt.resolve_left hmn)\n  · simpa [heq] using count_strict_mono hm hmn\n\n"}
{"name":"Nat.count_le_card","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nhp : (setOf p).Finite\nn : Nat\n⊢ LE.le (Nat.count p n) hp.toFinset.card","decl":"theorem count_le_card (hp : (setOf p).Finite) (n : ℕ) : count p n ≤ #hp.toFinset := by\n  rw [count_eq_card_filter_range]\n  exact Finset.card_mono fun x hx ↦ hp.mem_toFinset.2 (mem_filter.1 hx).2\n\n"}
{"name":"Nat.count_lt_card","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\nhp : (setOf p).Finite\nhpn : p n\n⊢ LT.lt (Nat.count p n) hp.toFinset.card","decl":"theorem count_lt_card {n : ℕ} (hp : (setOf p).Finite) (hpn : p n) : count p n < #hp.toFinset :=\n  (count_lt_count_succ_iff.2 hpn).trans_le (count_le_card hp _)\n\n"}
{"name":"Nat.count_iff_forall","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Iff (Eq (Nat.count p n) n) (∀ (n' : Nat), LT.lt n' n → p n')","decl":"theorem count_iff_forall {n : ℕ} : count p n = n ↔ ∀ n' < n, p n' := by\n  simpa [count_eq_card_filter_range, card_range, mem_range] using\n    card_filter_eq_iff (p := p) (s := range n)\n\n"}
{"name":"Nat.count_of_forall","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\na✝ : ∀ (n' : Nat), LT.lt n' n → p n'\n⊢ Eq (Nat.count p n) n","decl":"alias ⟨_, count_of_forall⟩ := count_iff_forall\n\n"}
{"name":"Nat.count_true","module":"Mathlib.Data.Nat.Count","initialProofState":"n : Nat\n⊢ Eq (Nat.count (fun x => True) n) n","decl":"@[simp] theorem count_true (n : ℕ) : count (fun _ ↦ True) n = n := count_of_forall fun _ _ ↦ trivial\n\n"}
{"name":"Nat.count_iff_forall_not","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\n⊢ Iff (Eq (Nat.count p n) 0) (∀ (m : Nat), LT.lt m n → Not (p m))","decl":"theorem count_iff_forall_not {n : ℕ} : count p n = 0 ↔ ∀ m < n, ¬p m := by\n  simpa [count_eq_card_filter_range, mem_range] using\n    card_filter_eq_zero_iff (p := p) (s := range n)\n\n"}
{"name":"Nat.count_of_forall_not","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝ : DecidablePred p\nn : Nat\na✝ : ∀ (m : Nat), LT.lt m n → Not (p m)\n⊢ Eq (Nat.count p n) 0","decl":"alias ⟨_, count_of_forall_not⟩ := count_iff_forall_not\n\n"}
{"name":"Nat.count_false","module":"Mathlib.Data.Nat.Count","initialProofState":"n : Nat\n⊢ Eq (Nat.count (fun x => False) n) 0","decl":"@[simp] theorem count_false (n : ℕ) : count (fun _ ↦ False) n = 0 :=\n  count_of_forall_not fun _ _ ↦ id\n\n"}
{"name":"Nat.count_mono_left","module":"Mathlib.Data.Nat.Count","initialProofState":"p : Nat → Prop\ninst✝¹ : DecidablePred p\nq : Nat → Prop\ninst✝ : DecidablePred q\nn : Nat\nhpq : ∀ (k : Nat), p k → q k\n⊢ LE.le (Nat.count p n) (Nat.count q n)","decl":"theorem count_mono_left {n : ℕ} (hpq : ∀ k, p k → q k) : count p n ≤ count q n := by\n  simp only [count_eq_card_filter_range]\n  exact card_le_card ((range n).monotone_filter_right hpq)\n\n"}
