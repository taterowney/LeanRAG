{"name":"MonoidAlgebra.nonUnitalAlgHom_ext","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : Semiring k\ninst✝² : Mul G\nA : Type u₃\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction k A\nφ₁ φ₂ : NonUnitalAlgHom (MonoidHom.id k) (MonoidAlgebra k G) A\nh : ∀ (x : G), Eq (φ₁ (MonoidAlgebra.single x 1)) (φ₂ (MonoidAlgebra.single x 1))\n⊢ Eq φ₁ φ₂","decl":"/-- A non_unital `k`-algebra homomorphism from `MonoidAlgebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. -/\ntheorem nonUnitalAlgHom_ext [DistribMulAction k A] {φ₁ φ₂ : MonoidAlgebra k G →ₙₐ[k] A}\n    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=\n  NonUnitalAlgHom.to_distribMulActionHom_injective <|\n    Finsupp.distribMulActionHom_ext' fun a => DistribMulActionHom.ext_ring (h a)\n\n"}
{"name":"MonoidAlgebra.nonUnitalAlgHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : Semiring k\ninst✝² : Mul G\nA : Type u₃\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction k A\nφ₁ φ₂ : NonUnitalAlgHom (MonoidHom.id k) (MonoidAlgebra k G) A\n⊢ Iff (Eq φ₁ φ₂) (Eq (φ₁.toMulHom.comp (MonoidAlgebra.ofMagma k G)) (φ₂.toMulHom.comp (MonoidAlgebra.ofMagma k G)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : MonoidAlgebra k G →ₙₐ[k] A}\n    (h : φ₁.toMulHom.comp (ofMagma k G) = φ₂.toMulHom.comp (ofMagma k G)) : φ₁ = φ₂ :=\n  nonUnitalAlgHom_ext k <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidAlgebra.nonUnitalAlgHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : Semiring k\ninst✝² : Mul G\nA : Type u₃\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction k A\nφ₁ φ₂ : NonUnitalAlgHom (MonoidHom.id k) (MonoidAlgebra k G) A\nh : Eq (φ₁.toMulHom.comp (MonoidAlgebra.ofMagma k G)) (φ₂.toMulHom.comp (MonoidAlgebra.ofMagma k G))\n⊢ Eq φ₁ φ₂","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : MonoidAlgebra k G →ₙₐ[k] A}\n    (h : φ₁.toMulHom.comp (ofMagma k G) = φ₂.toMulHom.comp (ofMagma k G)) : φ₁ = φ₂ :=\n  nonUnitalAlgHom_ext k <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidAlgebra.liftMagma_apply_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝⁵ : Semiring k\ninst✝⁴ : Mul G\nA : Type u₃\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module k A\ninst✝¹ : IsScalarTower k A A\ninst✝ : SMulCommClass k A A\nf : MulHom G A\na : MonoidAlgebra k G\n⊢ Eq (((MonoidAlgebra.liftMagma k) f) a) (Finsupp.sum a fun m t => HSMul.hSMul t (f m))","decl":"/-- The functor `G ↦ MonoidAlgebra k G`, from the category of magmas to the category of non-unital,\nnon-associative algebras over `k` is adjoint to the forgetful functor in the other direction. -/\n@[simps apply_apply symm_apply]\ndef liftMagma [Module k A] [IsScalarTower k A A] [SMulCommClass k A A] :\n    (G →ₙ* A) ≃ (MonoidAlgebra k G →ₙₐ[k] A) where\n  toFun f :=\n    { liftAddHom fun x => (smulAddHom k A).flip (f x) with\n      toFun := fun a => a.sum fun m t => t • f m\n      map_smul' := fun t' a => by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed\n        beta_reduce\n        rw [Finsupp.smul_sum, sum_smul_index']\n        · simp_rw [smul_assoc, MonoidHom.id_apply]\n        · intro m\n          exact zero_smul k (f m)\n      map_mul' := fun a₁ a₂ => by\n        let g : G → k → A := fun m t => t • f m\n        have h₁ : ∀ m, g m 0 = 0 := by\n          intro m\n          exact zero_smul k (f m)\n        have h₂ : ∀ (m) (t₁ t₂ : k), g m (t₁ + t₂) = g m t₁ + g m t₂ := by\n          intros\n          rw [← add_smul]\n        -- Porting note: `reducible` cannot be `local` so proof gets long.\n        simp_rw [Finsupp.mul_sum, Finsupp.sum_mul, smul_mul_smul_comm, ← f.map_mul, mul_def,\n          sum_comm a₂ a₁]\n        rw [sum_sum_index h₁ h₂]; congr; ext\n        rw [sum_sum_index h₁ h₂]; congr; ext\n        rw [sum_single_index (h₁ _)] }\n  invFun F := F.toMulHom.comp (ofMagma k G)\n  left_inv f := by\n    ext m\n    simp only [NonUnitalAlgHom.coe_mk, ofMagma_apply, NonUnitalAlgHom.toMulHom_eq_coe,\n      sum_single_index, Function.comp_apply, one_smul, zero_smul, MulHom.coe_comp,\n      NonUnitalAlgHom.coe_to_mulHom]\n  right_inv F := by\n    ext m\n    simp only [NonUnitalAlgHom.coe_mk, ofMagma_apply, NonUnitalAlgHom.toMulHom_eq_coe,\n      sum_single_index, Function.comp_apply, one_smul, zero_smul, MulHom.coe_comp,\n      NonUnitalAlgHom.coe_to_mulHom]\n\n"}
{"name":"MonoidAlgebra.liftMagma_symm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝⁵ : Semiring k\ninst✝⁴ : Mul G\nA : Type u₃\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module k A\ninst✝¹ : IsScalarTower k A A\ninst✝ : SMulCommClass k A A\nF : NonUnitalAlgHom (MonoidHom.id k) (MonoidAlgebra k G) A\n⊢ Eq ((MonoidAlgebra.liftMagma k).symm F) (F.toMulHom.comp (MonoidAlgebra.ofMagma k G))","decl":"/-- The functor `G ↦ MonoidAlgebra k G`, from the category of magmas to the category of non-unital,\nnon-associative algebras over `k` is adjoint to the forgetful functor in the other direction. -/\n@[simps apply_apply symm_apply]\ndef liftMagma [Module k A] [IsScalarTower k A A] [SMulCommClass k A A] :\n    (G →ₙ* A) ≃ (MonoidAlgebra k G →ₙₐ[k] A) where\n  toFun f :=\n    { liftAddHom fun x => (smulAddHom k A).flip (f x) with\n      toFun := fun a => a.sum fun m t => t • f m\n      map_smul' := fun t' a => by\n        -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed\n        beta_reduce\n        rw [Finsupp.smul_sum, sum_smul_index']\n        · simp_rw [smul_assoc, MonoidHom.id_apply]\n        · intro m\n          exact zero_smul k (f m)\n      map_mul' := fun a₁ a₂ => by\n        let g : G → k → A := fun m t => t • f m\n        have h₁ : ∀ m, g m 0 = 0 := by\n          intro m\n          exact zero_smul k (f m)\n        have h₂ : ∀ (m) (t₁ t₂ : k), g m (t₁ + t₂) = g m t₁ + g m t₂ := by\n          intros\n          rw [← add_smul]\n        -- Porting note: `reducible` cannot be `local` so proof gets long.\n        simp_rw [Finsupp.mul_sum, Finsupp.sum_mul, smul_mul_smul_comm, ← f.map_mul, mul_def,\n          sum_comm a₂ a₁]\n        rw [sum_sum_index h₁ h₂]; congr; ext\n        rw [sum_sum_index h₁ h₂]; congr; ext\n        rw [sum_single_index (h₁ _)] }\n  invFun F := F.toMulHom.comp (ofMagma k G)\n  left_inv f := by\n    ext m\n    simp only [NonUnitalAlgHom.coe_mk, ofMagma_apply, NonUnitalAlgHom.toMulHom_eq_coe,\n      sum_single_index, Function.comp_apply, one_smul, zero_smul, MulHom.coe_comp,\n      NonUnitalAlgHom.coe_to_mulHom]\n  right_inv F := by\n    ext m\n    simp only [NonUnitalAlgHom.coe_mk, ofMagma_apply, NonUnitalAlgHom.toMulHom_eq_coe,\n      sum_single_index, Function.comp_apply, one_smul, zero_smul, MulHom.coe_comp,\n      NonUnitalAlgHom.coe_to_mulHom]\n\n"}
{"name":"MonoidAlgebra.singleOneAlgHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Semiring A\ninst✝¹ : Algebra k A\ninst✝ : Monoid G\nb : A\n⊢ Eq (MonoidAlgebra.singleOneAlgHom b) (MonoidAlgebra.single 1 b)","decl":"/-- `Finsupp.single 1` as an `AlgHom` -/\n@[simps! apply]\ndef singleOneAlgHom {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G] :\n    A →ₐ[k] MonoidAlgebra A G :=\n  { singleOneRingHom with\n    commutes' := fun r => by\n      ext\n      simp\n      rfl }\n\n"}
{"name":"MonoidAlgebra.coe_algebraMap","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Semiring A\ninst✝¹ : Algebra k A\ninst✝ : Monoid G\n⊢ Eq (⇑(algebraMap k (MonoidAlgebra A G))) (Function.comp (MonoidAlgebra.single 1) ⇑(algebraMap k A))","decl":"@[simp]\ntheorem coe_algebraMap {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G] :\n    ⇑(algebraMap k (MonoidAlgebra A G)) = single 1 ∘ algebraMap k A :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.single_eq_algebraMap_mul_of","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝¹ : CommSemiring k\ninst✝ : Monoid G\na : G\nb : k\n⊢ Eq (MonoidAlgebra.single a b) (HMul.hMul ((algebraMap k (MonoidAlgebra k G)) b) ((MonoidAlgebra.of k G) a))","decl":"theorem single_eq_algebraMap_mul_of [CommSemiring k] [Monoid G] (a : G) (b : k) :\n    single a b = algebraMap k (MonoidAlgebra k G) b * of k G a := by simp\n\n"}
{"name":"MonoidAlgebra.single_algebraMap_eq_algebraMap_mul_of","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Semiring A\ninst✝¹ : Algebra k A\ninst✝ : Monoid G\na : G\nb : k\n⊢ Eq (MonoidAlgebra.single a ((algebraMap k A) b)) (HMul.hMul ((algebraMap k (MonoidAlgebra A G)) b) ((MonoidAlgebra.of A G) a))","decl":"theorem single_algebraMap_eq_algebraMap_mul_of {A : Type*} [CommSemiring k] [Semiring A]\n    [Algebra k A] [Monoid G] (a : G) (b : k) :\n    single a (algebraMap k A b) = algebraMap k (MonoidAlgebra A G) b * of A G a := by simp\n\n"}
{"name":"MonoidAlgebra.isLocalHom_singleOneAlgHom","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : Semiring A\ninst✝¹ : Algebra k A\ninst✝ : Monoid G\n⊢ IsLocalHom MonoidAlgebra.singleOneAlgHom","decl":"instance isLocalHom_singleOneAlgHom\n    {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G] :\n    IsLocalHom (singleOneAlgHom : A →ₐ[k] MonoidAlgebra A G) where\n  map_nonunit := isLocalHom_singleOneRingHom.map_nonunit\n\n"}
{"name":"MonoidAlgebra.isLocalHom_algebraMap","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\ninst✝⁴ : CommSemiring k\ninst✝³ : Semiring A\ninst✝² : Algebra k A\ninst✝¹ : Monoid G\ninst✝ : IsLocalHom (algebraMap k A)\n⊢ IsLocalHom (algebraMap k (MonoidAlgebra A G))","decl":"instance isLocalHom_algebraMap\n    {A : Type*} [CommSemiring k] [Semiring A] [Algebra k A] [Monoid G]\n    [IsLocalHom (algebraMap k A)] :\n    IsLocalHom (algebraMap k (MonoidAlgebra A G)) where\n  map_nonunit _ hx := .of_map _ _ <| isLocalHom_singleOneAlgHom (k := k).map_nonunit _ hx\n\n"}
{"name":"MonoidAlgebra.algHom_ext","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (MonoidAlgebra k G) A\nh : ∀ (x : G), Eq (φ₁ (MonoidAlgebra.single x 1)) (φ₂ (MonoidAlgebra.single x 1))\n⊢ Eq φ₁ φ₂","decl":"/-- A `k`-algebra homomorphism from `MonoidAlgebra k G` is uniquely defined by its\nvalues on the functions `single a 1`. -/\ntheorem algHom_ext ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄\n    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=\n  AlgHom.toLinearMap_injective <| Finsupp.lhom_ext' fun a => LinearMap.ext_ring (h a)\n\n-- Porting note: The priority must be `high`.\n"}
{"name":"MonoidAlgebra.algHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (MonoidAlgebra k G) A\n⊢ Iff (Eq φ₁ φ₂) (Eq ((↑φ₁).comp (MonoidAlgebra.of k G)) ((↑φ₂).comp (MonoidAlgebra.of k G)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem algHom_ext' ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄\n    (h :\n      (φ₁ : MonoidAlgebra k G →* A).comp (of k G) = (φ₂ : MonoidAlgebra k G →* A).comp (of k G)) :\n    φ₁ = φ₂ :=\n  algHom_ext <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidAlgebra.algHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (MonoidAlgebra k G) A\nh : Eq ((↑φ₁).comp (MonoidAlgebra.of k G)) ((↑φ₂).comp (MonoidAlgebra.of k G))\n⊢ Eq φ₁ φ₂","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem algHom_ext' ⦃φ₁ φ₂ : MonoidAlgebra k G →ₐ[k] A⦄\n    (h :\n      (φ₁ : MonoidAlgebra k G →* A).comp (of k G) = (φ₂ : MonoidAlgebra k G →* A).comp (of k G)) :\n    φ₁ = φ₂ :=\n  algHom_ext <| DFunLike.congr_fun h\n\n"}
{"name":"MonoidAlgebra.lift_apply'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom G A\nf : MonoidAlgebra k G\n⊢ Eq (((MonoidAlgebra.lift k G A) F) f) (Finsupp.sum f fun a b => HMul.hMul ((algebraMap k A) b) (F a))","decl":"theorem lift_apply' (F : G →* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => algebraMap k A b * F a :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.lift_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom G A\nf : MonoidAlgebra k G\n⊢ Eq (((MonoidAlgebra.lift k G A) F) f) (Finsupp.sum f fun a b => HSMul.hSMul b (F a))","decl":"theorem lift_apply (F : G →* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => b • F a := by simp only [lift_apply', Algebra.smul_def]\n\n"}
{"name":"MonoidAlgebra.lift_def","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom G A\n⊢ Eq ⇑((MonoidAlgebra.lift k G A) F) ⇑(MonoidAlgebra.liftNC ↑(algebraMap k A) ⇑F)","decl":"theorem lift_def (F : G →* A) : ⇑(lift k G A F) = liftNC ((algebraMap k A : k →+* A) : k →+ A) F :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.lift_symm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : AlgHom k (MonoidAlgebra k G) A\nx : G\n⊢ Eq (((MonoidAlgebra.lift k G A).symm F) x) (F (MonoidAlgebra.single x 1))","decl":"@[simp]\ntheorem lift_symm_apply (F : MonoidAlgebra k G →ₐ[k] A) (x : G) :\n    (lift k G A).symm F x = F (single x 1) :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.lift_single","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom G A\na : G\nb : k\n⊢ Eq (((MonoidAlgebra.lift k G A) F) (MonoidAlgebra.single a b)) (HSMul.hSMul b (F a))","decl":"@[simp]\ntheorem lift_single (F : G →* A) (a b) : lift k G A F (single a b) = b • F a := by\n  rw [lift_def, liftNC_single, Algebra.smul_def, AddMonoidHom.coe_coe]\n\n"}
{"name":"MonoidAlgebra.lift_of","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom G A\nx : G\n⊢ Eq (((MonoidAlgebra.lift k G A) F) ((MonoidAlgebra.of k G) x)) (F x)","decl":"theorem lift_of (F : G →* A) (x) : lift k G A F (of k G x) = F x := by simp\n\n"}
{"name":"MonoidAlgebra.lift_unique'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : AlgHom k (MonoidAlgebra k G) A\n⊢ Eq F ((MonoidAlgebra.lift k G A) ((↑F).comp (MonoidAlgebra.of k G)))","decl":"theorem lift_unique' (F : MonoidAlgebra k G →ₐ[k] A) :\n    F = lift k G A ((F : MonoidAlgebra k G →* A).comp (of k G)) :=\n  ((lift k G A).apply_symm_apply F).symm\n\n"}
{"name":"MonoidAlgebra.lift_unique","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : AlgHom k (MonoidAlgebra k G) A\nf : MonoidAlgebra k G\n⊢ Eq (F f) (Finsupp.sum f fun a b => HSMul.hSMul b (F (MonoidAlgebra.single a 1)))","decl":"/-- Decomposition of a `k`-algebra homomorphism from `MonoidAlgebra k G` by\nits values on `F (single a 1)`. -/\ntheorem lift_unique (F : MonoidAlgebra k G →ₐ[k] A) (f : MonoidAlgebra k G) :\n    F f = f.sum fun a b => b • F (single a 1) := by\n  conv_lhs =>\n    rw [lift_unique' F]\n    simp [lift_apply]\n\n"}
{"name":"MonoidAlgebra.mapDomainNonUnitalAlgHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u_4\nA : Type u_5\ninst✝⁶ : CommSemiring k\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra k A\nG : Type u_6\nH : Type u_7\nF : Type u_8\ninst✝³ : Mul G\ninst✝² : Mul H\ninst✝¹ : FunLike F G H\ninst✝ : MulHomClass F G H\nf : F\na✝ : Finsupp G A\n⊢ Eq ((MonoidAlgebra.mapDomainNonUnitalAlgHom k A f) a✝) ((↑(Finsupp.mapDomain.addMonoidHom ⇑f)).toFun a✝)","decl":"/-- If `f : G → H` is a homomorphism between two magmas, then\n`Finsupp.mapDomain f` is a non-unital algebra homomorphism between their magma algebras. -/\n@[simps apply]\ndef mapDomainNonUnitalAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A]\n    {G H F : Type*} [Mul G] [Mul H] [FunLike F G H] [MulHomClass F G H] (f : F) :\n    MonoidAlgebra A G →ₙₐ[k] MonoidAlgebra A H :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra A G →+ MonoidAlgebra A H) with\n    map_mul' := fun x y => mapDomain_mul f x y\n    map_smul' := fun r x => mapDomain_smul r x }\n\n"}
{"name":"MonoidAlgebra.mapDomain_algebraMap","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\ninst✝⁶ : CommSemiring k\ninst✝⁵ : Monoid G\ninst✝⁴ : Monoid H\nA : Type u₃\ninst✝³ : Semiring A\ninst✝² : Algebra k A\nF : Type u_4\ninst✝¹ : FunLike F G H\ninst✝ : MonoidHomClass F G H\nf : F\nr : k\n⊢ Eq (MonoidAlgebra.mapDomain (⇑f) ((algebraMap k (MonoidAlgebra A G)) r)) ((algebraMap k (MonoidAlgebra A H)) r)","decl":"variable (A) in\ntheorem mapDomain_algebraMap {F : Type*} [FunLike F G H] [MonoidHomClass F G H] (f : F) (r : k) :\n    mapDomain f (algebraMap k (MonoidAlgebra A G) r) = algebraMap k (MonoidAlgebra A H) r := by\n  simp only [coe_algebraMap, mapDomain_single, map_one, (· ∘ ·)]\n\n"}
{"name":"MonoidAlgebra.mapDomainAlgHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"G : Type u₂\ninst✝⁶ : Monoid G\nk : Type u_4\nA : Type u_5\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Semiring A\ninst✝³ : Algebra k A\nH : Type u_6\nF : Type u_7\ninst✝² : Monoid H\ninst✝¹ : FunLike F G H\ninst✝ : MonoidHomClass F G H\nf : F\na✝ : Finsupp G A\n⊢ Eq ((MonoidAlgebra.mapDomainAlgHom k A f) a✝) (Finsupp.mapDomain (⇑f) a✝)","decl":"/-- If `f : G → H` is a multiplicative homomorphism between two monoids, then\n`Finsupp.mapDomain f` is an algebra homomorphism between their monoid algebras. -/\n@[simps!]\ndef mapDomainAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A] {H F : Type*}\n    [Monoid H] [FunLike F G H] [MonoidHomClass F G H] (f : F) :\n    MonoidAlgebra A G →ₐ[k] MonoidAlgebra A H :=\n  { mapDomainRingHom A f with commutes' := mapDomain_algebraMap A f }\n\n"}
{"name":"MonoidAlgebra.mapDomainAlgHom_id","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"G : Type u₂\ninst✝³ : Monoid G\nk : Type u_4\nA : Type u_5\ninst✝² : CommSemiring k\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\n⊢ Eq (MonoidAlgebra.mapDomainAlgHom k A (MonoidHom.id G)) (AlgHom.id k (MonoidAlgebra A G))","decl":"@[simp]\nlemma mapDomainAlgHom_id (k A) [CommSemiring k] [Semiring A] [Algebra k A] :\n    mapDomainAlgHom k A (MonoidHom.id G) = AlgHom.id k (MonoidAlgebra A G) := by\n  ext; simp [MonoidHom.id, ← Function.id_def]\n\n"}
{"name":"MonoidAlgebra.mapDomainAlgHom_comp","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u_4\nA : Type u_5\nG₁ : Type u_6\nG₂ : Type u_7\nG₃ : Type u_8\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Semiring A\ninst✝³ : Algebra k A\ninst✝² : Monoid G₁\ninst✝¹ : Monoid G₂\ninst✝ : Monoid G₃\nf : MonoidHom G₁ G₂\ng : MonoidHom G₂ G₃\n⊢ Eq (MonoidAlgebra.mapDomainAlgHom k A (g.comp f)) ((MonoidAlgebra.mapDomainAlgHom k A g).comp (MonoidAlgebra.mapDomainAlgHom k A f))","decl":"@[simp]\nlemma mapDomainAlgHom_comp (k A) {G₁ G₂ G₃} [CommSemiring k] [Semiring A] [Algebra k A]\n    [Monoid G₁] [Monoid G₂] [Monoid G₃] (f : G₁ →* G₂) (g : G₂ →* G₃) :\n    mapDomainAlgHom k A (g.comp f) = (mapDomainAlgHom k A g).comp (mapDomainAlgHom k A f) := by\n  ext; simp [mapDomain_comp]\n\n"}
{"name":"MonoidAlgebra.domCongr_toAlgHom","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\ninst✝⁴ : CommSemiring k\ninst✝³ : Monoid G\ninst✝² : Monoid H\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : MulEquiv G H\n⊢ Eq (↑(MonoidAlgebra.domCongr k A e)) (MonoidAlgebra.mapDomainAlgHom k A e)","decl":"theorem domCongr_toAlgHom (e : G ≃* H) : (domCongr k A e).toAlgHom = mapDomainAlgHom k A e :=\n  AlgHom.ext fun _ => equivMapDomain_eq_mapDomain _ _\n\n"}
{"name":"MonoidAlgebra.domCongr_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\ninst✝⁴ : CommSemiring k\ninst✝³ : Monoid G\ninst✝² : Monoid H\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : MulEquiv G H\nf : MonoidAlgebra A G\nh : H\n⊢ Eq (((MonoidAlgebra.domCongr k A e) f) h) (f (e.symm h))","decl":"@[simp] theorem domCongr_apply (e : G ≃* H) (f : MonoidAlgebra A G) (h : H) :\n    domCongr k A e f h = f (e.symm h) :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.domCongr_support","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\ninst✝⁴ : CommSemiring k\ninst✝³ : Monoid G\ninst✝² : Monoid H\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : MulEquiv G H\nf : MonoidAlgebra A G\n⊢ Eq ((MonoidAlgebra.domCongr k A e) f).support (Finset.map (↑e).toEmbedding f.support)","decl":"@[simp] theorem domCongr_support (e : G ≃* H) (f : MonoidAlgebra A G) :\n    (domCongr k A e f).support = f.support.map e :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.domCongr_single","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\ninst✝⁴ : CommSemiring k\ninst✝³ : Monoid G\ninst✝² : Monoid H\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : MulEquiv G H\ng : G\na : A\n⊢ Eq ((MonoidAlgebra.domCongr k A e) (MonoidAlgebra.single g a)) (MonoidAlgebra.single (e g) a)","decl":"@[simp] theorem domCongr_single (e : G ≃* H) (g : G) (a : A) :\n    domCongr k A e (single g a) = single (e g) a :=\n  Finsupp.equivMapDomain_single _ _ _\n\n"}
{"name":"MonoidAlgebra.domCongr_refl","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : Monoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\n⊢ Eq (MonoidAlgebra.domCongr k A (MulEquiv.refl G)) AlgEquiv.refl","decl":"@[simp] theorem domCongr_refl : domCongr k A (MulEquiv.refl G) = AlgEquiv.refl :=\n  AlgEquiv.ext fun _ => Finsupp.ext fun _ => rfl\n\n"}
{"name":"MonoidAlgebra.domCongr_symm","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\ninst✝⁴ : CommSemiring k\ninst✝³ : Monoid G\ninst✝² : Monoid H\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : MulEquiv G H\n⊢ Eq (MonoidAlgebra.domCongr k A e).symm (MonoidAlgebra.domCongr k A e.symm)","decl":"@[simp] theorem domCongr_symm (e : G ≃* H) : (domCongr k A e).symm = domCongr k A e.symm := rfl\n\n"}
{"name":"MonoidAlgebra.GroupSMul.linearMap_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝⁵ : Monoid G\ninst✝⁴ : CommSemiring k\nV : Type u₃\ninst✝³ : AddCommMonoid V\ninst✝² : Module k V\ninst✝¹ : Module (MonoidAlgebra k G) V\ninst✝ : IsScalarTower k (MonoidAlgebra k G) V\ng : G\nv : V\n⊢ Eq ((MonoidAlgebra.GroupSMul.linearMap k V g) v) (HSMul.hSMul (MonoidAlgebra.single g 1) v)","decl":"@[simp]\ntheorem GroupSMul.linearMap_apply [Monoid G] [CommSemiring k] (V : Type u₃) [AddCommMonoid V]\n    [Module k V] [Module (MonoidAlgebra k G) V] [IsScalarTower k (MonoidAlgebra k G) V] (g : G)\n    (v : V) : (GroupSMul.linearMap k V g) v = single g (1 : k) • v :=\n  rfl\n\n"}
{"name":"MonoidAlgebra.equivariantOfLinearOfComm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝⁹ : Monoid G\ninst✝⁸ : CommSemiring k\nV : Type u₃\nW : Type u₄\ninst✝⁷ : AddCommMonoid V\ninst✝⁶ : Module k V\ninst✝⁵ : Module (MonoidAlgebra k G) V\ninst✝⁴ : IsScalarTower k (MonoidAlgebra k G) V\ninst✝³ : AddCommMonoid W\ninst✝² : Module k W\ninst✝¹ : Module (MonoidAlgebra k G) W\ninst✝ : IsScalarTower k (MonoidAlgebra k G) W\nf : LinearMap (RingHom.id k) V W\nh : ∀ (g : G) (v : V), Eq (f (HSMul.hSMul (MonoidAlgebra.single g 1) v)) (HSMul.hSMul (MonoidAlgebra.single g 1) (f v))\nv : V\n⊢ Eq ((MonoidAlgebra.equivariantOfLinearOfComm f h) v) (f v)","decl":"@[simp]\ntheorem equivariantOfLinearOfComm_apply (v : V) : (equivariantOfLinearOfComm f h) v = f v :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.nonUnitalAlgHom_ext","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : Semiring k\ninst✝² : Add G\nA : Type u₃\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction k A\nφ₁ φ₂ : NonUnitalAlgHom (MonoidHom.id k) (AddMonoidAlgebra k G) A\nh : ∀ (x : G), Eq (φ₁ (AddMonoidAlgebra.single x 1)) (φ₂ (AddMonoidAlgebra.single x 1))\n⊢ Eq φ₁ φ₂","decl":"/-- A non_unital `k`-algebra homomorphism from `k[G]` is uniquely defined by its\nvalues on the functions `single a 1`. -/\ntheorem nonUnitalAlgHom_ext [DistribMulAction k A] {φ₁ φ₂ : k[G] →ₙₐ[k] A}\n    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=\n  @MonoidAlgebra.nonUnitalAlgHom_ext k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h\n\n"}
{"name":"AddMonoidAlgebra.nonUnitalAlgHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : Semiring k\ninst✝² : Add G\nA : Type u₃\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction k A\nφ₁ φ₂ : NonUnitalAlgHom (MonoidHom.id k) (AddMonoidAlgebra k G) A\n⊢ Iff (Eq φ₁ φ₂) (Eq (φ₁.toMulHom.comp (AddMonoidAlgebra.ofMagma k G)) (φ₂.toMulHom.comp (AddMonoidAlgebra.ofMagma k G)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : k[G] →ₙₐ[k] A}\n    (h : φ₁.toMulHom.comp (ofMagma k G) = φ₂.toMulHom.comp (ofMagma k G)) : φ₁ = φ₂ :=\n  @MonoidAlgebra.nonUnitalAlgHom_ext' k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h\n\n"}
{"name":"AddMonoidAlgebra.nonUnitalAlgHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : Semiring k\ninst✝² : Add G\nA : Type u₃\ninst✝¹ : NonUnitalNonAssocSemiring A\ninst✝ : DistribMulAction k A\nφ₁ φ₂ : NonUnitalAlgHom (MonoidHom.id k) (AddMonoidAlgebra k G) A\nh : Eq (φ₁.toMulHom.comp (AddMonoidAlgebra.ofMagma k G)) (φ₂.toMulHom.comp (AddMonoidAlgebra.ofMagma k G))\n⊢ Eq φ₁ φ₂","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem nonUnitalAlgHom_ext' [DistribMulAction k A] {φ₁ φ₂ : k[G] →ₙₐ[k] A}\n    (h : φ₁.toMulHom.comp (ofMagma k G) = φ₂.toMulHom.comp (ofMagma k G)) : φ₁ = φ₂ :=\n  @MonoidAlgebra.nonUnitalAlgHom_ext' k (Multiplicative G) _ _ _ _ _ φ₁ φ₂ h\n\n"}
{"name":"AddMonoidAlgebra.liftMagma_apply_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝⁵ : Semiring k\ninst✝⁴ : Add G\nA : Type u₃\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module k A\ninst✝¹ : IsScalarTower k A A\ninst✝ : SMulCommClass k A A\nf : MulHom (Multiplicative G) A\na : AddMonoidAlgebra k G\n⊢ Eq (((AddMonoidAlgebra.liftMagma k) f) a) (Finsupp.sum a fun m t => HSMul.hSMul t (f (Multiplicative.ofAdd m)))","decl":"/-- The functor `G ↦ k[G]`, from the category of magmas to the category of\nnon-unital, non-associative algebras over `k` is adjoint to the forgetful functor in the other\ndirection. -/\n@[simps apply_apply symm_apply]\ndef liftMagma [Module k A] [IsScalarTower k A A] [SMulCommClass k A A] :\n    (Multiplicative G →ₙ* A) ≃ (k[G] →ₙₐ[k] A) :=\n  { (MonoidAlgebra.liftMagma k : (Multiplicative G →ₙ* A) ≃ (_ →ₙₐ[k] A)) with\n    toFun := fun f =>\n      { (MonoidAlgebra.liftMagma k f :) with\n        toFun := fun a => sum a fun m t => t • f (Multiplicative.ofAdd m) }\n    invFun := fun F => F.toMulHom.comp (ofMagma k G) }\n\n"}
{"name":"AddMonoidAlgebra.liftMagma_symm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝⁵ : Semiring k\ninst✝⁴ : Add G\nA : Type u₃\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module k A\ninst✝¹ : IsScalarTower k A A\ninst✝ : SMulCommClass k A A\nF : NonUnitalAlgHom (MonoidHom.id k) (AddMonoidAlgebra k G) A\n⊢ Eq ((AddMonoidAlgebra.liftMagma k).symm F) (F.toMulHom.comp (AddMonoidAlgebra.ofMagma k G))","decl":"/-- The functor `G ↦ k[G]`, from the category of magmas to the category of\nnon-unital, non-associative algebras over `k` is adjoint to the forgetful functor in the other\ndirection. -/\n@[simps apply_apply symm_apply]\ndef liftMagma [Module k A] [IsScalarTower k A A] [SMulCommClass k A A] :\n    (Multiplicative G →ₙ* A) ≃ (k[G] →ₙₐ[k] A) :=\n  { (MonoidAlgebra.liftMagma k : (Multiplicative G →ₙ* A) ≃ (_ →ₙₐ[k] A)) with\n    toFun := fun f =>\n      { (MonoidAlgebra.liftMagma k f :) with\n        toFun := fun a => sum a fun m t => t • f (Multiplicative.ofAdd m) }\n    invFun := fun F => F.toMulHom.comp (ofMagma k G) }\n\n"}
{"name":"AddMonoidAlgebra.singleZeroAlgHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Semiring k\ninst✝¹ : Algebra R k\ninst✝ : AddMonoid G\nb : k\n⊢ Eq (AddMonoidAlgebra.singleZeroAlgHom b) (AddMonoidAlgebra.single 0 b)","decl":"/-- `Finsupp.single 0` as an `AlgHom` -/\n@[simps! apply]\ndef singleZeroAlgHom [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] : k →ₐ[R] k[G] :=\n  { singleZeroRingHom with\n    commutes' := fun r => by\n      ext\n      simp\n      rfl }\n\n"}
{"name":"AddMonoidAlgebra.coe_algebraMap","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Semiring k\ninst✝¹ : Algebra R k\ninst✝ : AddMonoid G\n⊢ Eq (⇑(algebraMap R (AddMonoidAlgebra k G))) (Function.comp (AddMonoidAlgebra.single 0) ⇑(algebraMap R k))","decl":"@[simp]\ntheorem coe_algebraMap [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] :\n    (algebraMap R k[G] : R → k[G]) = single 0 ∘ algebraMap R k :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.isLocalHom_singleZeroAlgHom","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Semiring k\ninst✝¹ : Algebra R k\ninst✝ : AddMonoid G\n⊢ IsLocalHom AddMonoidAlgebra.singleZeroAlgHom","decl":"instance isLocalHom_singleZeroAlgHom [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G] :\n    IsLocalHom (singleZeroAlgHom : k →ₐ[R] k[G]) where\n  map_nonunit := isLocalHom_singleZeroRingHom.map_nonunit\n\n"}
{"name":"AddMonoidAlgebra.isLocalHom_algebraMap","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nR : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Semiring k\ninst✝² : Algebra R k\ninst✝¹ : AddMonoid G\ninst✝ : IsLocalHom (algebraMap R k)\n⊢ IsLocalHom (algebraMap R (AddMonoidAlgebra k G))","decl":"instance isLocalHom_algebraMap [CommSemiring R] [Semiring k] [Algebra R k] [AddMonoid G]\n    [IsLocalHom (algebraMap R k)] :\n    IsLocalHom (algebraMap R k[G]) where\n  map_nonunit _ hx := .of_map _ _ <| isLocalHom_singleZeroAlgHom (R := R).map_nonunit _ hx\n\n"}
{"name":"AddMonoidAlgebra.algHom_ext","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (AddMonoidAlgebra k G) A\nh : ∀ (x : G), Eq (φ₁ (AddMonoidAlgebra.single x 1)) (φ₂ (AddMonoidAlgebra.single x 1))\n⊢ Eq φ₁ φ₂","decl":"/-- A `k`-algebra homomorphism from `k[G]` is uniquely defined by its\nvalues on the functions `single a 1`. -/\ntheorem algHom_ext ⦃φ₁ φ₂ : k[G] →ₐ[k] A⦄\n    (h : ∀ x, φ₁ (single x 1) = φ₂ (single x 1)) : φ₁ = φ₂ :=\n  @MonoidAlgebra.algHom_ext k (Multiplicative G) _ _ _ _ _ _ _ h\n\n"}
{"name":"AddMonoidAlgebra.algHom_ext'_iff","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (AddMonoidAlgebra k G) A\n⊢ Iff (Eq φ₁ φ₂) (Eq ((↑φ₁).comp (AddMonoidAlgebra.of k G)) ((↑φ₂).comp (AddMonoidAlgebra.of k G)))","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem algHom_ext' ⦃φ₁ φ₂ : k[G] →ₐ[k] A⦄\n    (h : (φ₁ : k[G] →* A).comp (of k G) = (φ₂ : k[G] →* A).comp (of k G)) :\n    φ₁ = φ₂ :=\n  algHom_ext <| DFunLike.congr_fun h\n\n"}
{"name":"AddMonoidAlgebra.algHom_ext'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (AddMonoidAlgebra k G) A\nh : Eq ((↑φ₁).comp (AddMonoidAlgebra.of k G)) ((↑φ₂).comp (AddMonoidAlgebra.of k G))\n⊢ Eq φ₁ φ₂","decl":"/-- See note [partially-applied ext lemmas]. -/\n@[ext high]\ntheorem algHom_ext' ⦃φ₁ φ₂ : k[G] →ₐ[k] A⦄\n    (h : (φ₁ : k[G] →* A).comp (of k G) = (φ₂ : k[G] →* A).comp (of k G)) :\n    φ₁ = φ₂ :=\n  algHom_ext <| DFunLike.congr_fun h\n\n"}
{"name":"AddMonoidAlgebra.lift_apply'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom (Multiplicative G) A\nf : MonoidAlgebra k G\n⊢ Eq (((AddMonoidAlgebra.lift k G A) F) f) (Finsupp.sum f fun a b => HMul.hMul ((algebraMap k A) b) (F (Multiplicative.ofAdd a)))","decl":"theorem lift_apply' (F : Multiplicative G →* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => algebraMap k A b * F (Multiplicative.ofAdd a) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.lift_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom (Multiplicative G) A\nf : MonoidAlgebra k G\n⊢ Eq (((AddMonoidAlgebra.lift k G A) F) f) (Finsupp.sum f fun a b => HSMul.hSMul b (F (Multiplicative.ofAdd a)))","decl":"theorem lift_apply (F : Multiplicative G →* A) (f : MonoidAlgebra k G) :\n    lift k G A F f = f.sum fun a b => b • F (Multiplicative.ofAdd a) := by\n  simp only [lift_apply', Algebra.smul_def]\n\n"}
{"name":"AddMonoidAlgebra.lift_def","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom (Multiplicative G) A\n⊢ Eq ⇑((AddMonoidAlgebra.lift k G A) F) ⇑(AddMonoidAlgebra.liftNC ↑(algebraMap k A) ⇑F)","decl":"theorem lift_def (F : Multiplicative G →* A) :\n    ⇑(lift k G A F) = liftNC ((algebraMap k A : k →+* A) : k →+ A) F :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.lift_symm_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : AlgHom k (AddMonoidAlgebra k G) A\nx : Multiplicative G\n⊢ Eq (((AddMonoidAlgebra.lift k G A).symm F) x) (F (AddMonoidAlgebra.single (Multiplicative.toAdd x) 1))","decl":"@[simp]\ntheorem lift_symm_apply (F : k[G] →ₐ[k] A) (x : Multiplicative G) :\n    (lift k G A).symm F x = F (single x.toAdd 1) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.lift_of","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom (Multiplicative G) A\nx : Multiplicative G\n⊢ Eq (((AddMonoidAlgebra.lift k G A) F) ((AddMonoidAlgebra.of k G) x)) (F x)","decl":"theorem lift_of (F : Multiplicative G →* A) (x : Multiplicative G) :\n    lift k G A F (of k G x) = F x := MonoidAlgebra.lift_of F x\n\n"}
{"name":"AddMonoidAlgebra.lift_single","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom (Multiplicative G) A\na : G\nb : k\n⊢ Eq (((AddMonoidAlgebra.lift k G A) F) (AddMonoidAlgebra.single a b)) (HSMul.hSMul b (F (Multiplicative.ofAdd a)))","decl":"@[simp]\ntheorem lift_single (F : Multiplicative G →* A) (a b) :\n    lift k G A F (single a b) = b • F (Multiplicative.ofAdd a) :=\n  MonoidAlgebra.lift_single F (.ofAdd a) b\n\n"}
{"name":"AddMonoidAlgebra.lift_of'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : MonoidHom (Multiplicative G) A\nx : G\n⊢ Eq (((AddMonoidAlgebra.lift k G A) F) (AddMonoidAlgebra.of' k G x)) (F (Multiplicative.ofAdd x))","decl":"lemma lift_of' (F : Multiplicative G →* A) (x : G) :\n    lift k G A F (of' k G x) = F (Multiplicative.ofAdd x) :=\n  lift_of F x\n\n"}
{"name":"AddMonoidAlgebra.lift_unique'","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : AlgHom k (AddMonoidAlgebra k G) A\n⊢ Eq F ((AddMonoidAlgebra.lift k G A) ((↑F).comp (AddMonoidAlgebra.of k G)))","decl":"theorem lift_unique' (F : k[G] →ₐ[k] A) :\n    F = lift k G A ((F : k[G] →* A).comp (of k G)) :=\n  ((lift k G A).apply_symm_apply F).symm\n\n"}
{"name":"AddMonoidAlgebra.lift_unique","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nF : AlgHom k (AddMonoidAlgebra k G) A\nf : MonoidAlgebra k G\n⊢ Eq (F f) (Finsupp.sum f fun a b => HSMul.hSMul b (F (AddMonoidAlgebra.single a 1)))","decl":"/-- Decomposition of a `k`-algebra homomorphism from `MonoidAlgebra k G` by\nits values on `F (single a 1)`. -/\ntheorem lift_unique (F : k[G] →ₐ[k] A) (f : MonoidAlgebra k G) :\n    F f = f.sum fun a b => b • F (single a 1) := by\n  conv_lhs =>\n    rw [lift_unique' F]\n    simp [lift_apply]\n\n"}
{"name":"AddMonoidAlgebra.algHom_ext_iff","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\nA : Type u₃\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\nφ₁ φ₂ : AlgHom k (AddMonoidAlgebra k G) A\n⊢ Iff (∀ (x : G), Eq (φ₁ (Finsupp.single x 1)) (φ₂ (Finsupp.single x 1))) (Eq φ₁ φ₂)","decl":"theorem algHom_ext_iff {φ₁ φ₂ : k[G] →ₐ[k] A} :\n    (∀ x, φ₁ (Finsupp.single x 1) = φ₂ (Finsupp.single x 1)) ↔ φ₁ = φ₂ :=\n  ⟨fun h => algHom_ext h, by rintro rfl _; rfl⟩\n\n"}
{"name":"AddMonoidAlgebra.mapDomain_algebraMap","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\nH : Type u_4\nF : Type u_5\ninst✝⁶ : CommSemiring k\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra k A\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : FunLike F G H\ninst✝ : AddMonoidHomClass F G H\nf : F\nr : k\n⊢ Eq (AddMonoidAlgebra.mapDomain (⇑f) ((algebraMap k (AddMonoidAlgebra A G)) r)) ((algebraMap k (AddMonoidAlgebra A H)) r)","decl":"theorem mapDomain_algebraMap (A : Type*) {H F : Type*} [CommSemiring k] [Semiring A] [Algebra k A]\n    [AddMonoid G] [AddMonoid H] [FunLike F G H] [AddMonoidHomClass F G H]\n    (f : F) (r : k) :\n    mapDomain f (algebraMap k A[G] r) = algebraMap k A[H] r := by\n  simp only [Function.comp_apply, mapDomain_single, AddMonoidAlgebra.coe_algebraMap, map_zero]\n\n"}
{"name":"AddMonoidAlgebra.mapDomainNonUnitalAlgHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u_3\nA : Type u_4\ninst✝⁶ : CommSemiring k\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra k A\nG : Type u_5\nH : Type u_6\nF : Type u_7\ninst✝³ : Add G\ninst✝² : Add H\ninst✝¹ : FunLike F G H\ninst✝ : AddHomClass F G H\nf : F\na✝ : Finsupp G A\n⊢ Eq ((AddMonoidAlgebra.mapDomainNonUnitalAlgHom k A f) a✝) ((↑(Finsupp.mapDomain.addMonoidHom ⇑f)).toFun a✝)","decl":"/-- If `f : G → H` is a homomorphism between two additive magmas, then `Finsupp.mapDomain f` is a\nnon-unital algebra homomorphism between their additive magma algebras. -/\n@[simps apply]\ndef mapDomainNonUnitalAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A]\n    {G H F : Type*} [Add G] [Add H] [FunLike F G H] [AddHomClass F G H] (f : F) :\n    A[G] →ₙₐ[k] A[H] :=\n  { (Finsupp.mapDomain.addMonoidHom f : MonoidAlgebra A G →+ MonoidAlgebra A H) with\n    map_mul' := fun x y => mapDomain_mul f x y\n    map_smul' := fun r x => mapDomain_smul r x }\n\n"}
{"name":"AddMonoidAlgebra.mapDomainAlgHom_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"G : Type u₂\nk : Type u_3\nA : Type u_4\ninst✝⁶ : CommSemiring k\ninst✝⁵ : Semiring A\ninst✝⁴ : Algebra k A\ninst✝³ : AddMonoid G\nH : Type u_5\nF : Type u_6\ninst✝² : AddMonoid H\ninst✝¹ : FunLike F G H\ninst✝ : AddMonoidHomClass F G H\nf : F\na✝ : Finsupp G A\n⊢ Eq ((AddMonoidAlgebra.mapDomainAlgHom k A f) a✝) (Finsupp.mapDomain (⇑f) a✝)","decl":"/-- If `f : G → H` is an additive homomorphism between two additive monoids, then\n`Finsupp.mapDomain f` is an algebra homomorphism between their add monoid algebras. -/\n@[simps!]\ndef mapDomainAlgHom (k A : Type*) [CommSemiring k] [Semiring A] [Algebra k A] [AddMonoid G]\n    {H F : Type*} [AddMonoid H] [FunLike F G H] [AddMonoidHomClass F G H] (f : F) :\n    A[G] →ₐ[k] A[H] :=\n  { mapDomainRingHom A f with commutes' := mapDomain_algebraMap A f }\n\n"}
{"name":"AddMonoidAlgebra.mapDomainAlgHom_id","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"G : Type u₂\nk : Type u_3\nA : Type u_4\ninst✝³ : CommSemiring k\ninst✝² : Semiring A\ninst✝¹ : Algebra k A\ninst✝ : AddMonoid G\n⊢ Eq (AddMonoidAlgebra.mapDomainAlgHom k A (AddMonoidHom.id G)) (AlgHom.id k (AddMonoidAlgebra A G))","decl":"@[simp]\nlemma mapDomainAlgHom_id (k A) [CommSemiring k] [Semiring A] [Algebra k A] [AddMonoid G] :\n    mapDomainAlgHom k A (AddMonoidHom.id G) = AlgHom.id k (AddMonoidAlgebra A G) := by\n  ext; simp [AddMonoidHom.id, ← Function.id_def]\n\n"}
{"name":"AddMonoidAlgebra.mapDomainAlgHom_comp","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u_3\nA : Type u_4\nG₁ : Type u_5\nG₂ : Type u_6\nG₃ : Type u_7\ninst✝⁵ : CommSemiring k\ninst✝⁴ : Semiring A\ninst✝³ : Algebra k A\ninst✝² : AddMonoid G₁\ninst✝¹ : AddMonoid G₂\ninst✝ : AddMonoid G₃\nf : AddMonoidHom G₁ G₂\ng : AddMonoidHom G₂ G₃\n⊢ Eq (AddMonoidAlgebra.mapDomainAlgHom k A (g.comp f)) ((AddMonoidAlgebra.mapDomainAlgHom k A g).comp (AddMonoidAlgebra.mapDomainAlgHom k A f))","decl":"@[simp]\nlemma mapDomainAlgHom_comp (k A) {G₁ G₂ G₃} [CommSemiring k] [Semiring A] [Algebra k A]\n    [AddMonoid G₁] [AddMonoid G₂] [AddMonoid G₃] (f : G₁ →+ G₂) (g : G₂ →+ G₃) :\n    mapDomainAlgHom k A (g.comp f) = (mapDomainAlgHom k A g).comp (mapDomainAlgHom k A f) := by\n  ext; simp [mapDomain_comp]\n\n"}
{"name":"AddMonoidAlgebra.domCongr_toAlgHom","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\nA : Type u_3\ninst✝⁴ : CommSemiring k\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : AddEquiv G H\n⊢ Eq (↑(AddMonoidAlgebra.domCongr k A e)) (AddMonoidAlgebra.mapDomainAlgHom k A e)","decl":"theorem domCongr_toAlgHom (e : G ≃+ H) : (domCongr k A e).toAlgHom = mapDomainAlgHom k A e :=\n  AlgHom.ext fun _ => equivMapDomain_eq_mapDomain _ _\n\n"}
{"name":"AddMonoidAlgebra.domCongr_apply","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\nA : Type u_3\ninst✝⁴ : CommSemiring k\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : AddEquiv G H\nf : MonoidAlgebra A G\nh : H\n⊢ Eq (((AddMonoidAlgebra.domCongr k A e) f) h) (f (e.symm h))","decl":"@[simp] theorem domCongr_apply (e : G ≃+ H) (f : MonoidAlgebra A G) (h : H) :\n    domCongr k A e f h = f (e.symm h) :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.domCongr_support","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\nA : Type u_3\ninst✝⁴ : CommSemiring k\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : AddEquiv G H\nf : MonoidAlgebra A G\n⊢ Eq ((AddMonoidAlgebra.domCongr k A e) f).support (Finset.map (↑e).toEmbedding f.support)","decl":"@[simp] theorem domCongr_support (e : G ≃+ H) (f : MonoidAlgebra A G) :\n    (domCongr k A e f).support = f.support.map e :=\n  rfl\n\n"}
{"name":"AddMonoidAlgebra.domCongr_single","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\nA : Type u_3\ninst✝⁴ : CommSemiring k\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : AddEquiv G H\ng : G\na : A\n⊢ Eq ((AddMonoidAlgebra.domCongr k A e) (AddMonoidAlgebra.single g a)) (AddMonoidAlgebra.single (e g) a)","decl":"@[simp] theorem domCongr_single (e : G ≃+ H) (g : G) (a : A) :\n    domCongr k A e (single g a) = single (e g) a :=\n  Finsupp.equivMapDomain_single _ _ _\n\n"}
{"name":"AddMonoidAlgebra.domCongr_refl","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nA : Type u_3\ninst✝³ : CommSemiring k\ninst✝² : AddMonoid G\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\n⊢ Eq (AddMonoidAlgebra.domCongr k A (AddEquiv.refl G)) AlgEquiv.refl","decl":"@[simp] theorem domCongr_refl : domCongr k A (AddEquiv.refl G) = AlgEquiv.refl :=\n  AlgEquiv.ext fun _ => Finsupp.ext fun _ => rfl\n\n"}
{"name":"AddMonoidAlgebra.domCongr_symm","module":"Mathlib.Algebra.MonoidAlgebra.Basic","initialProofState":"k : Type u₁\nG : Type u₂\nH : Type u_1\nA : Type u_3\ninst✝⁴ : CommSemiring k\ninst✝³ : AddMonoid G\ninst✝² : AddMonoid H\ninst✝¹ : Semiring A\ninst✝ : Algebra k A\ne : AddEquiv G H\n⊢ Eq (AddMonoidAlgebra.domCongr k A e).symm (AddMonoidAlgebra.domCongr k A e.symm)","decl":"@[simp] theorem domCongr_symm (e : G ≃+ H) : (domCongr k A e).symm = domCongr k A e.symm := rfl\n\n"}
