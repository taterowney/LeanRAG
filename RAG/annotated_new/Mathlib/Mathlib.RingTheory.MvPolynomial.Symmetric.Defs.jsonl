{"name":"Finset.esymm_map_val","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nσ : Type u_2\nf : σ → R\ns : Finset σ\nn : Nat\n⊢ Eq ((Multiset.map f s.val).esymm n) ((Finset.powersetCard n s).sum fun t => t.prod f)","decl":"theorem _root_.Finset.esymm_map_val {σ} (f : σ → R) (s : Finset σ) (n : ℕ) :\n    (s.val.map f).esymm n = (s.powersetCard n).sum fun t => t.prod f := by\n  simp only [esymm, powersetCard_map, ← Finset.map_val_val_powersetCard, map_map]\n  rfl\n\n"}
{"name":"Multiset.pow_smul_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nS : Type u_2\ninst✝³ : Monoid S\ninst✝² : DistribMulAction S R\ninst✝¹ : IsScalarTower S R R\ninst✝ : SMulCommClass S R R\ns : S\nn : Nat\nm : Multiset R\n⊢ Eq (HSMul.hSMul (HPow.hPow s n) (m.esymm n)) ((Multiset.map (fun x => HSMul.hSMul s x) m).esymm n)","decl":"lemma pow_smul_esymm {S : Type*} [Monoid S] [DistribMulAction S R] [IsScalarTower S R R]\n    [SMulCommClass S R R] (s : S) (n : ℕ) (m : Multiset R) :\n    s ^ n • m.esymm n = (m.map (s • ·)).esymm n := by\n  rw [esymm, smul_sum, map_map]\n  trans ((powersetCard n m).map (fun x : Multiset R ↦ s ^ card x • x.prod)).sum\n  · refine congr_arg _ (map_congr rfl (fun x hx ↦ ?_))\n    rw [Function.comp_apply, (mem_powersetCard.1 hx).2]\n  · simp_rw [smul_prod, esymm, powersetCard_map, map_map, Function.comp_def]\n\n"}
{"name":"MvPolynomial.mem_symmetricSubalgebra","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\np : MvPolynomial σ R\n⊢ Iff (Membership.mem (MvPolynomial.symmetricSubalgebra σ R) p) p.IsSymmetric","decl":"@[simp]\ntheorem mem_symmetricSubalgebra [CommSemiring R] (p : MvPolynomial σ R) :\n    p ∈ symmetricSubalgebra σ R ↔ p.IsSymmetric :=\n  Iff.rfl\n\n"}
{"name":"MvPolynomial.IsSymmetric.C","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nr : R\n⊢ (MvPolynomial.C r).IsSymmetric","decl":"@[simp]\ntheorem C (r : R) : IsSymmetric (C r : MvPolynomial σ R) :=\n  (symmetricSubalgebra σ R).algebraMap_mem r\n\n"}
{"name":"MvPolynomial.IsSymmetric.zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ MvPolynomial.IsSymmetric 0","decl":"@[simp]\ntheorem zero : IsSymmetric (0 : MvPolynomial σ R) :=\n  (symmetricSubalgebra σ R).zero_mem\n\n"}
{"name":"MvPolynomial.IsSymmetric.one","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\n⊢ MvPolynomial.IsSymmetric 1","decl":"@[simp]\ntheorem one : IsSymmetric (1 : MvPolynomial σ R) :=\n  (symmetricSubalgebra σ R).one_mem\n\n"}
{"name":"MvPolynomial.IsSymmetric.add","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\nhφ : φ.IsSymmetric\nhψ : ψ.IsSymmetric\n⊢ (HAdd.hAdd φ ψ).IsSymmetric","decl":"theorem add (hφ : IsSymmetric φ) (hψ : IsSymmetric ψ) : IsSymmetric (φ + ψ) :=\n  (symmetricSubalgebra σ R).add_mem hφ hψ\n\n"}
{"name":"MvPolynomial.IsSymmetric.mul","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ ψ : MvPolynomial σ R\nhφ : φ.IsSymmetric\nhψ : ψ.IsSymmetric\n⊢ (HMul.hMul φ ψ).IsSymmetric","decl":"theorem mul (hφ : IsSymmetric φ) (hψ : IsSymmetric ψ) : IsSymmetric (φ * ψ) :=\n  (symmetricSubalgebra σ R).mul_mem hφ hψ\n\n"}
{"name":"MvPolynomial.IsSymmetric.smul","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nr : R\nhφ : φ.IsSymmetric\n⊢ (HSMul.hSMul r φ).IsSymmetric","decl":"theorem smul (r : R) (hφ : IsSymmetric φ) : IsSymmetric (r • φ) :=\n  (symmetricSubalgebra σ R).smul_mem hφ r\n\n"}
{"name":"MvPolynomial.IsSymmetric.map","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\nS : Type u_4\ninst✝¹ : CommSemiring R\ninst✝ : CommSemiring S\nφ : MvPolynomial σ R\nhφ : φ.IsSymmetric\nf : RingHom R S\n⊢ ((MvPolynomial.map f) φ).IsSymmetric","decl":"@[simp]\ntheorem map (hφ : IsSymmetric φ) (f : R →+* S) : IsSymmetric (map f φ) := fun e => by\n  rw [← map_rename, hφ]\n\n"}
{"name":"MvPolynomial.IsSymmetric.rename","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\nhφ : φ.IsSymmetric\ne : Equiv σ τ\n⊢ ((MvPolynomial.rename ⇑e) φ).IsSymmetric","decl":"protected theorem rename (hφ : φ.IsSymmetric) (e : σ ≃ τ) : (rename e φ).IsSymmetric := fun _ => by\n  apply rename_injective _ e.symm.injective\n  simp_rw [rename_rename, ← Equiv.coe_trans, Equiv.self_trans_symm, Equiv.coe_refl, rename_id]\n  rw [hφ]\n\n"}
{"name":"MvPolynomial.isSymmetric_rename","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\nφ : MvPolynomial σ R\ne : Equiv σ τ\n⊢ Iff ((MvPolynomial.rename ⇑e) φ).IsSymmetric φ.IsSymmetric","decl":"@[simp]\ntheorem _root_.MvPolynomial.isSymmetric_rename {e : σ ≃ τ} :\n    (MvPolynomial.rename e φ).IsSymmetric ↔ φ.IsSymmetric :=\n  ⟨fun h => by simpa using (IsSymmetric.rename (R := R) h e.symm), (IsSymmetric.rename · e)⟩\n\n"}
{"name":"MvPolynomial.IsSymmetric.neg","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommRing R\nφ : MvPolynomial σ R\nhφ : φ.IsSymmetric\n⊢ (Neg.neg φ).IsSymmetric","decl":"theorem neg (hφ : IsSymmetric φ) : IsSymmetric (-φ) :=\n  (symmetricSubalgebra σ R).neg_mem hφ\n\n"}
{"name":"MvPolynomial.IsSymmetric.sub","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nR : Type u_3\ninst✝ : CommRing R\nφ ψ : MvPolynomial σ R\nhφ : φ.IsSymmetric\nhψ : ψ.IsSymmetric\n⊢ (HSub.hSub φ ψ).IsSymmetric","decl":"theorem sub (hφ : IsSymmetric φ) (hψ : IsSymmetric ψ) : IsSymmetric (φ - ψ) :=\n  (symmetricSubalgebra σ R).sub_mem hφ hψ\n\n"}
{"name":"MvPolynomial.renameSymmetricSubalgebra_apply_coe","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\ne : Equiv σ τ\na : Subtype fun x => Membership.mem (MvPolynomial.symmetricSubalgebra σ R) x\n⊢ Eq (↑((MvPolynomial.renameSymmetricSubalgebra e) a)) ((MvPolynomial.rename ⇑e) ↑a)","decl":"/-- `MvPolynomial.rename` induces an isomorphism between the symmetric subalgebras. -/\n@[simps!]\ndef renameSymmetricSubalgebra [CommSemiring R] (e : σ ≃ τ) :\n    symmetricSubalgebra σ R ≃ₐ[R] symmetricSubalgebra τ R :=\n  AlgEquiv.ofAlgHom\n    (((rename e).comp (symmetricSubalgebra σ R).val).codRestrict _ <| fun x => x.2.rename e)\n    (((rename e.symm).comp <| Subalgebra.val _).codRestrict _ <| fun x => x.2.rename e.symm)\n    (AlgHom.ext <| fun p => Subtype.ext <| by simp)\n    (AlgHom.ext <| fun p => Subtype.ext <| by simp)\n\n"}
{"name":"MvPolynomial.renameSymmetricSubalgebra_symm_apply_coe","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_1\nτ : Type u_2\nR : Type u_3\ninst✝ : CommSemiring R\ne : Equiv σ τ\na : Subtype fun x => Membership.mem (MvPolynomial.symmetricSubalgebra τ R) x\n⊢ Eq (↑((MvPolynomial.renameSymmetricSubalgebra e).symm a)) ((MvPolynomial.rename ⇑e.symm) ↑a)","decl":"/-- `MvPolynomial.rename` induces an isomorphism between the symmetric subalgebras. -/\n@[simps!]\ndef renameSymmetricSubalgebra [CommSemiring R] (e : σ ≃ τ) :\n    symmetricSubalgebra σ R ≃ₐ[R] symmetricSubalgebra τ R :=\n  AlgEquiv.ofAlgHom\n    (((rename e).comp (symmetricSubalgebra σ R).val).codRestrict _ <| fun x => x.2.rename e)\n    (((rename e.symm).comp <| Subalgebra.val _).codRestrict _ <| fun x => x.2.rename e.symm)\n    (AlgHom.ext <| fun p => Subtype.ext <| by simp)\n    (AlgHom.ext <| fun p => Subtype.ext <| by simp)\n\n"}
{"name":"MvPolynomial.esymm_eq_multiset_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.esymm σ R) (Multiset.map MvPolynomial.X Finset.univ.val).esymm","decl":"/-- The `n`th elementary symmetric `MvPolynomial σ R` is obtained by evaluating the\n`n`th elementary symmetric at the `Multiset` of the monomials -/\ntheorem esymm_eq_multiset_esymm : esymm σ R = (univ.val.map X).esymm := by\n  exact funext fun n => (esymm_map_val X _ n).symm\n\n"}
{"name":"MvPolynomial.aeval_esymm_eq_multiset_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"S : Type u_4\nσ : Type u_5\nR : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Fintype σ\ninst✝ : Algebra R S\nn : Nat\nf : σ → S\n⊢ Eq ((MvPolynomial.aeval f) (MvPolynomial.esymm σ R n)) ((Multiset.map f Finset.univ.val).esymm n)","decl":"theorem aeval_esymm_eq_multiset_esymm [Algebra R S] (n : ℕ) (f : σ → S) :\n    aeval f (esymm σ R n) = (univ.val.map f).esymm n := by\n  simp_rw [esymm, aeval_sum, aeval_prod, aeval_X, esymm_map_val]\n\n"}
{"name":"MvPolynomial.esymm_eq_sum_subtype","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nn : Nat\n⊢ Eq (MvPolynomial.esymm σ R n) (Finset.univ.sum fun t => (↑t).prod fun i => MvPolynomial.X i)","decl":"/-- We can define `esymm σ R n` by summing over a subtype instead of over `powerset_len`. -/\ntheorem esymm_eq_sum_subtype (n : ℕ) :\n    esymm σ R n = ∑ t : {s : Finset σ // #s = n}, ∏ i ∈ (t : Finset σ), X i :=\n  sum_subtype _ (fun _ => mem_powersetCard_univ) _\n\n"}
{"name":"MvPolynomial.esymm_eq_sum_monomial","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nn : Nat\n⊢ Eq (MvPolynomial.esymm σ R n) ((Finset.powersetCard n Finset.univ).sum fun t => (MvPolynomial.monomial (t.sum fun i => Finsupp.single i 1)) 1)","decl":"/-- We can define `esymm σ R n` as a sum over explicit monomials -/\ntheorem esymm_eq_sum_monomial (n : ℕ) :\n    esymm σ R n = ∑ t ∈ powersetCard n univ, monomial (∑ i ∈ t, Finsupp.single i 1) 1 := by\n  simp_rw [monomial_sum_one]\n  rfl\n\n"}
{"name":"MvPolynomial.esymm_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.esymm σ R 0) 1","decl":"@[simp]\ntheorem esymm_zero : esymm σ R 0 = 1 := by\n  simp only [esymm, powersetCard_zero, sum_singleton, prod_empty]\n\n"}
{"name":"MvPolynomial.esymm_one","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.esymm σ R 1) (Finset.univ.sum fun i => MvPolynomial.X i)","decl":"@[simp]\ntheorem esymm_one : esymm σ R 1 = ∑ i, X i := by simp [esymm, powersetCard_one]\n\n"}
{"name":"MvPolynomial.esymmPart_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.esymmPart σ R (Nat.Partition.indiscrete 0)) 1","decl":"theorem esymmPart_zero : esymmPart σ R (.indiscrete 0) = 1 := by simp [esymmPart]\n\n"}
{"name":"MvPolynomial.esymmPart_indiscrete","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nn : Nat\n⊢ Eq (MvPolynomial.esymmPart σ R (Nat.Partition.indiscrete n)) (MvPolynomial.esymm σ R n)","decl":"@[simp]\ntheorem esymmPart_indiscrete (n : ℕ) : esymmPart σ R (.indiscrete n) = esymm σ R n := by\n  cases n <;> simp [esymmPart]\n\n"}
{"name":"MvPolynomial.map_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"S : Type u_4\nσ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Fintype σ\nn : Nat\nf : RingHom R S\n⊢ Eq ((MvPolynomial.map f) (MvPolynomial.esymm σ R n)) (MvPolynomial.esymm σ S n)","decl":"theorem map_esymm (n : ℕ) (f : R →+* S) : map f (esymm σ R n) = esymm σ S n := by\n  simp_rw [esymm, map_sum, map_prod, map_X]\n\n"}
{"name":"MvPolynomial.rename_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"τ : Type u_2\nσ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : Fintype τ\nn : Nat\ne : Equiv σ τ\n⊢ Eq ((MvPolynomial.rename ⇑e) (MvPolynomial.esymm σ R n)) (MvPolynomial.esymm τ R n)","decl":"theorem rename_esymm (n : ℕ) (e : σ ≃ τ) : rename e (esymm σ R n) = esymm τ R n :=\n  calc\n    rename e (esymm σ R n) = ∑ x ∈ powersetCard n univ, ∏ i ∈ x, X (e i) := by\n      simp_rw [esymm, map_sum, map_prod, rename_X]\n    _ = ∑ t ∈ powersetCard n (univ.map e.toEmbedding), ∏ i ∈ t, X i := by\n      simp [powersetCard_map, -map_univ_equiv]\n      -- Porting note: Why did `mapEmbedding_apply` not work?\n      dsimp [mapEmbedding, OrderEmbedding.ofMapLEIff]\n      simp\n    _ = ∑ t ∈ powersetCard n univ, ∏ i ∈ t, X i := by rw [map_univ_equiv]\n\n"}
{"name":"MvPolynomial.esymm_isSymmetric","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nn : Nat\n⊢ (MvPolynomial.esymm σ R n).IsSymmetric","decl":"theorem esymm_isSymmetric (n : ℕ) : IsSymmetric (esymm σ R n) := by\n  intro\n  rw [rename_esymm]\n\n"}
{"name":"MvPolynomial.support_esymm''","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : Fintype σ\ninst✝¹ : DecidableEq σ\ninst✝ : Nontrivial R\nn : Nat\n⊢ Eq (MvPolynomial.esymm σ R n).support ((Finset.powersetCard n Finset.univ).biUnion fun t => (Finsupp.single (t.sum fun i => Finsupp.single i 1) 1).support)","decl":"theorem support_esymm'' [DecidableEq σ] [Nontrivial R] (n : ℕ) :\n    (esymm σ R n).support =\n      (powersetCard n (univ : Finset σ)).biUnion fun t =>\n        (Finsupp.single (∑ i ∈ t, Finsupp.single i 1) (1 : R)).support := by\n  rw [esymm_eq_sum_monomial]\n  simp only [← single_eq_monomial]\n  refine Finsupp.support_sum_eq_biUnion (powersetCard n (univ : Finset σ)) ?_\n  intro s t hst\n  rw [disjoint_left, Finsupp.support_single_ne_zero _ one_ne_zero]\n  rw [Finsupp.support_single_ne_zero _ one_ne_zero]\n  simp only [one_ne_zero, mem_singleton, Finsupp.mem_support_iff]\n  rintro a h rfl\n  have := congr_arg Finsupp.support h\n  rw [Finsupp.support_sum_eq_biUnion, Finsupp.support_sum_eq_biUnion] at this\n  · have hsingle : ∀ s : Finset σ, ∀ x : σ, x ∈ s → (Finsupp.single x 1).support = {x} := by\n      intros _ x _\n      rw [Finsupp.support_single_ne_zero x one_ne_zero]\n    have hs := biUnion_congr (of_eq_true (eq_self s)) (hsingle s)\n    have ht := biUnion_congr (of_eq_true (eq_self t)) (hsingle t)\n    rw [hs, ht] at this\n    · simp only [biUnion_singleton_eq_self] at this\n      exact absurd this hst.symm\n  all_goals intro x y; simp [Finsupp.support_single_disjoint]\n\n"}
{"name":"MvPolynomial.support_esymm'","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : Fintype σ\ninst✝¹ : DecidableEq σ\ninst✝ : Nontrivial R\nn : Nat\n⊢ Eq (MvPolynomial.esymm σ R n).support ((Finset.powersetCard n Finset.univ).biUnion fun t => Singleton.singleton (t.sum fun i => Finsupp.single i 1))","decl":"theorem support_esymm' [DecidableEq σ] [Nontrivial R] (n : ℕ) : (esymm σ R n).support =\n    (powersetCard n (univ : Finset σ)).biUnion fun t => {∑ i ∈ t, Finsupp.single i 1} := by\n  rw [support_esymm'']\n  congr\n  funext\n  exact Finsupp.support_single_ne_zero _ one_ne_zero\n\n"}
{"name":"MvPolynomial.support_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : Fintype σ\ninst✝¹ : DecidableEq σ\ninst✝ : Nontrivial R\nn : Nat\n⊢ Eq (MvPolynomial.esymm σ R n).support (Finset.image (fun t => t.sum fun i => Finsupp.single i 1) (Finset.powersetCard n Finset.univ))","decl":"theorem support_esymm [DecidableEq σ] [Nontrivial R] (n : ℕ) : (esymm σ R n).support =\n    (powersetCard n (univ : Finset σ)).image fun t => ∑ i ∈ t, Finsupp.single i 1 := by\n  rw [support_esymm']\n  exact biUnion_singleton\n\n"}
{"name":"MvPolynomial.degrees_esymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : Nontrivial R\nn : Nat\nhpos : LT.lt 0 n\nhn : LE.le n (Fintype.card σ)\n⊢ Eq (MvPolynomial.esymm σ R n).degrees Finset.univ.val","decl":"theorem degrees_esymm [Nontrivial R] {n : ℕ} (hpos : 0 < n) (hn : n ≤ Fintype.card σ) :\n    (esymm σ R n).degrees = (univ : Finset σ).val := by\n  classical\n    have :\n      (Finsupp.toMultiset ∘ fun t : Finset σ => ∑ i ∈ t, Finsupp.single i 1) = val := by\n      funext\n      simp [Finsupp.toMultiset_sum_single]\n    rw [degrees_def, support_esymm, sup_image, this]\n    have : ((powersetCard n univ).sup (fun (x : Finset σ) => x)).val\n        = sup (powersetCard n univ) val := by\n      refine comp_sup_eq_sup_comp _ ?_ ?_\n      · intros\n        simp only [union_val, sup_eq_union]\n        congr\n      · rfl\n    rw [← this]\n    obtain ⟨k, rfl⟩ := Nat.exists_eq_succ_of_ne_zero hpos.ne'\n    simpa using powersetCard_sup _ _ (Nat.lt_of_succ_le hn)\n\n"}
{"name":"MvPolynomial.hsymm_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\n⊢ Eq (MvPolynomial.hsymm σ R 0) 1","decl":"@[simp]\ntheorem hsymm_zero : hsymm σ R 0 = 1 := by simp [hsymm, eq_nil_of_card_zero]\n\n"}
{"name":"MvPolynomial.hsymm_one","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\n⊢ Eq (MvPolynomial.hsymm σ R 1) (Finset.univ.sum fun i => MvPolynomial.X i)","decl":"@[simp]\ntheorem hsymm_one : hsymm σ R 1 = ∑ i, X i := by\n  symm\n  apply Fintype.sum_equiv oneEquiv\n  simp only [oneEquiv_apply, Multiset.map_singleton, Multiset.prod_singleton, implies_true]\n\n"}
{"name":"MvPolynomial.hsymmPart_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\n⊢ Eq (MvPolynomial.hsymmPart σ R (Nat.Partition.indiscrete 0)) 1","decl":"theorem hsymmPart_zero : hsymmPart σ R (.indiscrete 0) = 1 := by simp [hsymmPart]\n\n"}
{"name":"MvPolynomial.hsymmPart_indiscrete","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\nn : Nat\n⊢ Eq (MvPolynomial.hsymmPart σ R (Nat.Partition.indiscrete n)) (MvPolynomial.hsymm σ R n)","decl":"@[simp]\ntheorem hsymmPart_indiscrete (n : ℕ) : hsymmPart σ R (.indiscrete n) = hsymm σ R n := by\n  cases n <;> simp [hsymmPart]\n\n"}
{"name":"MvPolynomial.map_hsymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"S : Type u_4\nσ : Type u_5\nR : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\nn : Nat\nf : RingHom R S\n⊢ Eq ((MvPolynomial.map f) (MvPolynomial.hsymm σ R n)) (MvPolynomial.hsymm σ S n)","decl":"theorem map_hsymm (n : ℕ) (f : R →+* S) : map f (hsymm σ R n) = hsymm σ S n := by\n  simp [hsymm, ← Multiset.prod_hom']\n\n"}
{"name":"MvPolynomial.rename_hsymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"τ : Type u_2\nσ : Type u_5\nR : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : Fintype σ\ninst✝² : Fintype τ\ninst✝¹ : DecidableEq σ\ninst✝ : DecidableEq τ\nn : Nat\ne : Equiv σ τ\n⊢ Eq ((MvPolynomial.rename ⇑e) (MvPolynomial.hsymm σ R n)) (MvPolynomial.hsymm τ R n)","decl":"theorem rename_hsymm (n : ℕ) (e : σ ≃ τ) : rename e (hsymm σ R n) = hsymm τ R n := by\n  simp_rw [hsymm, map_sum, ← prod_hom', rename_X]\n  apply Fintype.sum_equiv (equivCongr e)\n  simp\n\n"}
{"name":"MvPolynomial.hsymm_isSymmetric","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\nn : Nat\n⊢ (MvPolynomial.hsymm σ R n).IsSymmetric","decl":"theorem hsymm_isSymmetric (n : ℕ) : IsSymmetric (hsymm σ R n) := rename_hsymm _ _ n\n\n"}
{"name":"MvPolynomial.psum_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.psum σ R 0) ↑(Fintype.card σ)","decl":"@[simp]\ntheorem psum_zero : psum σ R 0 = Fintype.card σ := by simp [psum]\n\n"}
{"name":"MvPolynomial.psum_one","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.psum σ R 1) (Finset.univ.sum fun i => MvPolynomial.X i)","decl":"@[simp]\ntheorem psum_one : psum σ R 1 = ∑ i, X i := by simp [psum]\n\n"}
{"name":"MvPolynomial.psumPart_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\n⊢ Eq (MvPolynomial.psumPart σ R (Nat.Partition.indiscrete 0)) 1","decl":"@[simp]\ntheorem psumPart_zero : psumPart σ R (.indiscrete 0) = 1 := by simp [psumPart]\n\n"}
{"name":"MvPolynomial.psumPart_indiscrete","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nn : Nat\nnpos : Ne n 0\n⊢ Eq (MvPolynomial.psumPart σ R (Nat.Partition.indiscrete n)) (MvPolynomial.psum σ R n)","decl":"@[simp]\ntheorem psumPart_indiscrete {n : ℕ} (npos : n ≠ 0) :\n    psumPart σ R (.indiscrete n) = psum σ R n := by simp [psumPart, npos]\n\n"}
{"name":"MvPolynomial.rename_psum","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"τ : Type u_2\nσ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : Fintype τ\nn : Nat\ne : Equiv σ τ\n⊢ Eq ((MvPolynomial.rename ⇑e) (MvPolynomial.psum σ R n)) (MvPolynomial.psum τ R n)","decl":"@[simp]\ntheorem rename_psum (n : ℕ) (e : σ ≃ τ) : rename e (psum σ R n) = psum τ R n := by\n  simp_rw [psum, map_sum, map_pow, rename_X, e.sum_comp (X · ^ n)]\n\n"}
{"name":"MvPolynomial.psum_isSymmetric","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝¹ : CommSemiring R\ninst✝ : Fintype σ\nn : Nat\n⊢ (MvPolynomial.psum σ R n).IsSymmetric","decl":"theorem psum_isSymmetric (n : ℕ) : IsSymmetric (psum σ R n) := rename_psum _ _ n\n\n"}
{"name":"MvPolynomial.msymm_zero","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\n⊢ Eq (MvPolynomial.msymm σ R (Nat.Partition.indiscrete 0)) 1","decl":"@[simp]\ntheorem msymm_zero : msymm σ R (.indiscrete 0) = 1 := by\n  rw [msymm, Fintype.sum_subsingleton _ ⟨(Sym.nil : Sym σ 0), rfl⟩]\n  simp\n\n"}
{"name":"MvPolynomial.msymm_one","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\n⊢ Eq (MvPolynomial.msymm σ R (Nat.Partition.indiscrete 1)) (Finset.univ.sum fun i => MvPolynomial.X i)","decl":"@[simp]\ntheorem msymm_one : msymm σ R (.indiscrete 1) = ∑ i, X i := by\n  have : (fun (x : Sym σ 1) ↦ x ∈ Set.univ) =\n      (fun x ↦ Nat.Partition.ofSym x = Nat.Partition.indiscrete 1) := by\n    simp_rw [Set.mem_univ, Nat.Partition.ofSym_one]\n  symm\n  rw [Fintype.sum_equiv (Equiv.trans Sym.oneEquiv (Equiv.Set.univ (Sym σ 1)).symm)\n    _ (fun s ↦ (s.1.1.map X).prod)]\n  · apply Fintype.sum_equiv (Equiv.subtypeEquivProp this)\n    intro x\n    congr\n  · intro x\n    rw [← Multiset.prod_singleton (X x), ← Multiset.map_singleton]\n    congr\n\n"}
{"name":"MvPolynomial.rename_msymm","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"τ : Type u_2\nσ : Type u_5\nR : Type u_6\ninst✝⁴ : CommSemiring R\ninst✝³ : Fintype σ\ninst✝² : Fintype τ\ninst✝¹ : DecidableEq σ\ninst✝ : DecidableEq τ\nn : Nat\nμ : n.Partition\ne : Equiv σ τ\n⊢ Eq ((MvPolynomial.rename ⇑e) (MvPolynomial.msymm σ R μ)) (MvPolynomial.msymm τ R μ)","decl":"@[simp]\ntheorem rename_msymm (μ : n.Partition) (e : σ ≃ τ) :\n    rename e (msymm σ R μ) = msymm τ R μ := by\n  rw [msymm, map_sum]\n  apply Fintype.sum_equiv (Nat.Partition.ofSymShapeEquiv μ e)\n  intro\n  rw [← Multiset.prod_hom, Multiset.map_map, Nat.Partition.ofSymShapeEquiv]\n  simp\n\n"}
{"name":"MvPolynomial.msymm_isSymmetric","module":"Mathlib.RingTheory.MvPolynomial.Symmetric.Defs","initialProofState":"σ : Type u_5\nR : Type u_6\ninst✝² : CommSemiring R\ninst✝¹ : Fintype σ\ninst✝ : DecidableEq σ\nn : Nat\nμ : n.Partition\n⊢ (MvPolynomial.msymm σ R μ).IsSymmetric","decl":"theorem msymm_isSymmetric (μ : n.Partition) : IsSymmetric (msymm σ R μ) :=\n  rename_msymm _ _ μ\n\n"}
