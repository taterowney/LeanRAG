{"name":"cfc_tsub","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝⁹ : TopologicalSpace A\ninst✝⁸ : Ring A\ninst✝⁷ : PartialOrder A\ninst✝⁶ : StarRing A\ninst✝⁵ : StarOrderedRing A\ninst✝⁴ : Algebra Real A\ninst✝³ : TopologicalRing A\ninst✝² : T2Space A\ninst✝¹ : ContinuousFunctionalCalculus Real IsSelfAdjoint\ninst✝ : NonnegSpectrumClass Real A\nf g : NNReal → NNReal\na : A\nhfg : ∀ (x : NNReal), Membership.mem (spectrum NNReal a) x → LE.le (g x) (f x)\nha : autoParam (LE.le 0 a) _auto✝\nhf : autoParam (ContinuousOn f (spectrum NNReal a)) _auto✝\nhg : autoParam (ContinuousOn g (spectrum NNReal a)) _auto✝\n⊢ Eq (cfc (fun x => HSub.hSub (f x) (g x)) a) (HSub.hSub (cfc f a) (cfc g a))","decl":"theorem cfc_tsub {A : Type*} [TopologicalSpace A] [Ring A] [PartialOrder A] [StarRing A]\n    [StarOrderedRing A] [Algebra ℝ A] [TopologicalRing A] [T2Space A]\n    [ContinuousFunctionalCalculus ℝ (IsSelfAdjoint : A → Prop)]\n    [NonnegSpectrumClass ℝ A] (f g : ℝ≥0 → ℝ≥0)\n    (a : A) (hfg : ∀ x ∈ spectrum ℝ≥0 a, g x ≤ f x) (ha : 0 ≤ a := by cfc_tac)\n    (hf : ContinuousOn f (spectrum ℝ≥0 a) := by cfc_cont_tac)\n    (hg : ContinuousOn g (spectrum ℝ≥0 a) := by cfc_cont_tac) :\n    cfc (fun x ↦ f x - g x) a = cfc f a - cfc g a := by\n  have ha' := SpectrumRestricts.nnreal_of_nonneg ha\n  have : (spectrum ℝ a).EqOn (fun x ↦ ((f x.toNNReal - g x.toNNReal : ℝ≥0) : ℝ))\n      (fun x ↦ f x.toNNReal - g x.toNNReal) :=\n    fun x hx ↦ NNReal.coe_sub <| hfg _ <| ha'.apply_mem hx\n  rw [cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_congr this]\n  refine cfc_sub _ _ a ?_ ?_\n  all_goals\n    exact continuous_subtype_val.comp_continuousOn <|\n      ContinuousOn.comp ‹_› continuous_real_toNNReal.continuousOn <| ha'.image ▸ Set.mapsTo_image ..\n\n"}
{"name":"cfcₙ_tsub","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝¹¹ : TopologicalSpace A\ninst✝¹⁰ : NonUnitalRing A\ninst✝⁹ : PartialOrder A\ninst✝⁸ : StarRing A\ninst✝⁷ : StarOrderedRing A\ninst✝⁶ : Module Real A\ninst✝⁵ : IsScalarTower Real A A\ninst✝⁴ : SMulCommClass Real A A\ninst✝³ : TopologicalRing A\ninst✝² : T2Space A\ninst✝¹ : NonUnitalContinuousFunctionalCalculus Real IsSelfAdjoint\ninst✝ : NonnegSpectrumClass Real A\nf g : NNReal → NNReal\na : A\nhfg : ∀ (x : NNReal), Membership.mem (quasispectrum NNReal a) x → LE.le (g x) (f x)\nha : autoParam (LE.le 0 a) _auto✝\nhf : autoParam (ContinuousOn f (quasispectrum NNReal a)) _auto✝\nhf0 : autoParam (Eq (f 0) 0) _auto✝\nhg : autoParam (ContinuousOn g (quasispectrum NNReal a)) _auto✝\nhg0 : autoParam (Eq (g 0) 0) _auto✝\n⊢ Eq (cfcₙ (fun x => HSub.hSub (f x) (g x)) a) (HSub.hSub (cfcₙ f a) (cfcₙ g a))","decl":"theorem cfcₙ_tsub {A : Type*} [TopologicalSpace A] [NonUnitalRing A] [PartialOrder A] [StarRing A]\n    [StarOrderedRing A] [Module ℝ A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A] [TopologicalRing A]\n    [T2Space A] [NonUnitalContinuousFunctionalCalculus ℝ (IsSelfAdjoint : A → Prop)]\n    [NonnegSpectrumClass ℝ A] (f g : ℝ≥0 → ℝ≥0)\n    (a : A) (hfg : ∀ x ∈ σₙ ℝ≥0 a, g x ≤ f x) (ha : 0 ≤ a := by cfc_tac)\n    (hf : ContinuousOn f (σₙ ℝ≥0 a) := by cfc_cont_tac) (hf0 : f 0 = 0 := by cfc_zero_tac)\n    (hg : ContinuousOn g (σₙ ℝ≥0 a) := by cfc_cont_tac) (hg0 : g 0 = 0 := by cfc_zero_tac) :\n    cfcₙ (fun x ↦ f x - g x) a = cfcₙ f a - cfcₙ g a := by\n  have ha' := QuasispectrumRestricts.nnreal_of_nonneg ha\n  have : (σₙ ℝ a).EqOn (fun x ↦ ((f x.toNNReal - g x.toNNReal : ℝ≥0) : ℝ))\n      (fun x ↦ f x.toNNReal - g x.toNNReal) :=\n    fun x hx ↦ NNReal.coe_sub <| hfg _ <| ha'.apply_mem hx\n  rw [cfcₙ_nnreal_eq_real, cfcₙ_nnreal_eq_real, cfcₙ_nnreal_eq_real, cfcₙ_congr this]\n  refine cfcₙ_sub _ _ a ?_ (by simpa) ?_\n  all_goals\n    exact continuous_subtype_val.comp_continuousOn <|\n      ContinuousOn.comp ‹_› continuous_real_toNNReal.continuousOn <| ha'.image ▸ Set.mapsTo_image ..\n\n"}
{"name":"Unitization.instStarOrderedRing","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝ : NonUnitalCStarAlgebra A\n⊢ StarOrderedRing (Unitization Complex A)","decl":"instance instStarOrderedRing : StarOrderedRing A⁺¹ :=\n    CStarAlgebra.spectralOrderedRing _\n\n"}
{"name":"Unitization.inr_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nha : autoParam (IsSelfAdjoint a) _auto✝\nhb : autoParam (IsSelfAdjoint b) _auto✝\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"lemma inr_le_iff (a b : A) (ha : IsSelfAdjoint a := by cfc_tac)\n    (hb : IsSelfAdjoint b := by cfc_tac) :\n    (a : A⁺¹) ≤ (b : A⁺¹) ↔ a ≤ b := by\n  -- TODO: prove the more general result for star monomorphisms and use it here.\n  rw [← sub_nonneg, ← sub_nonneg (a := b), StarOrderedRing.nonneg_iff_spectrum_nonneg (R := ℝ) _,\n    ← inr_sub ℂ b a, ← Unitization.quasispectrum_eq_spectrum_inr' ℝ ℂ]\n  exact StarOrderedRing.nonneg_iff_quasispectrum_nonneg _ |>.symm\n\n"}
{"name":"Unitization.inr_nonneg_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\n⊢ Iff (LE.le 0 ↑a) (LE.le 0 a)","decl":"@[simp, norm_cast]\nlemma inr_nonneg_iff {a : A} : 0 ≤ (a : A⁺¹) ↔ 0 ≤ a := by\n  by_cases ha : IsSelfAdjoint a\n  · exact inr_zero ℂ (A := A) ▸ inr_le_iff 0 a\n  · refine ⟨?_, ?_⟩\n    all_goals refine fun h ↦ (ha ?_).elim\n    · exact isSelfAdjoint_inr (R := ℂ) |>.mp <| .of_nonneg h\n    · exact .of_nonneg h\n\n"}
{"name":"Unitization.nnreal_cfcₙ_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nf : NNReal → NNReal\nhf₀ : autoParam (Eq (f 0) 0) _auto✝\n⊢ Eq (↑(cfcₙ f a)) (cfc f ↑a)","decl":"lemma nnreal_cfcₙ_eq_cfc_inr (a : A) (f : ℝ≥0 → ℝ≥0)\n    (hf₀ : f 0 = 0 := by cfc_zero_tac) : cfcₙ f a = cfc f (a : A⁺¹) :=\n  cfcₙ_eq_cfc_inr inr_nonneg_iff ..\n\n"}
{"name":"cfc_nnreal_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝⁹ : TopologicalSpace A\ninst✝⁸ : Ring A\ninst✝⁷ : StarRing A\ninst✝⁶ : PartialOrder A\ninst✝⁵ : StarOrderedRing A\ninst✝⁴ : Algebra Real A\ninst✝³ : TopologicalRing A\ninst✝² : NonnegSpectrumClass Real A\ninst✝¹ : T2Space A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\nf g : NNReal → NNReal\na : A\nha_spec : SpectrumRestricts a ⇑ContinuousMap.realToNNReal\nhf : autoParam (ContinuousOn f (spectrum NNReal a)) _auto✝\nhg : autoParam (ContinuousOn g (spectrum NNReal a)) _auto✝\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (cfc f a) (cfc g a)) (∀ (x : NNReal), Membership.mem (spectrum NNReal a) x → LE.le (f x) (g x))","decl":"/-- `cfc_le_iff` only applies to a scalar ring where `R` is an actual `Ring`, and not a `Semiring`.\nHowever, this theorem still holds for `ℝ≥0` as long as the algebra `A` itself is an `ℝ`-algebra. -/\nlemma cfc_nnreal_le_iff {A : Type*} [TopologicalSpace A] [Ring A] [StarRing A] [PartialOrder A]\n    [StarOrderedRing A] [Algebra ℝ A] [TopologicalRing A] [NonnegSpectrumClass ℝ A]\n    [T2Space A] [ContinuousFunctionalCalculus ℝ (IsSelfAdjoint : A → Prop)]\n    (f : ℝ≥0 → ℝ≥0) (g : ℝ≥0 → ℝ≥0) (a : A)\n    (ha_spec : SpectrumRestricts a ContinuousMap.realToNNReal)\n    (hf : ContinuousOn f (spectrum ℝ≥0 a) := by cfc_cont_tac)\n    (hg : ContinuousOn g (spectrum ℝ≥0 a) := by cfc_cont_tac)\n    (ha : 0 ≤ a := by cfc_tac) :\n    cfc f a ≤ cfc g a ↔ ∀ x ∈ spectrum ℝ≥0 a, f x ≤ g x := by\n  have hf' := hf.ofReal_map_toNNReal <| ha_spec.image ▸ Set.mapsTo_image ..\n  have hg' := hg.ofReal_map_toNNReal <| ha_spec.image ▸ Set.mapsTo_image ..\n  rw [cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_le_iff ..]\n  simp [NNReal.coe_le_coe, ← ha_spec.image]\n\n"}
{"name":"CFC.exists_pos_algebraMap_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝⁸ : TopologicalSpace A\ninst✝⁷ : Ring A\ninst✝⁶ : StarRing A\ninst✝⁵ : PartialOrder A\ninst✝⁴ : StarOrderedRing A\ninst✝³ : Algebra Real A\ninst✝² : NonnegSpectrumClass Real A\ninst✝¹ : Nontrivial A\ninst✝ : ContinuousFunctionalCalculus Real IsSelfAdjoint\na : A\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Iff (Exists fun r => And (GT.gt r 0) (LE.le ((algebraMap Real A) r) a)) (∀ (x : Real), Membership.mem (spectrum Real a) x → LT.lt 0 x)","decl":"open ContinuousFunctionalCalculus in\n/-- In a unital `ℝ`-algebra `A` with a continuous functional calculus, an element `a : A` is larger\nthan some `algebraMap ℝ A r` if and only if every element of the `ℝ`-spectrum is nonnegative. -/\nlemma CFC.exists_pos_algebraMap_le_iff {A : Type*} [TopologicalSpace A] [Ring A] [StarRing A]\n    [PartialOrder A] [StarOrderedRing A] [Algebra ℝ A] [NonnegSpectrumClass ℝ A] [Nontrivial A]\n    [ContinuousFunctionalCalculus ℝ (IsSelfAdjoint : A → Prop)]\n    {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    (∃ r > 0, algebraMap ℝ A r ≤ a) ↔ (∀ x ∈ spectrum ℝ a, 0 < x) := by\n  have h_cpct : IsCompact (spectrum ℝ a) := isCompact_iff_compactSpace.mpr inferInstance\n  simp_rw [algebraMap_le_iff_le_spectrum (a := a)]\n  refine ⟨?_, fun h ↦ ?_⟩\n  · rintro ⟨r, hr, hr_le⟩\n    exact (hr.trans_le <| hr_le · ·)\n  · obtain ⟨r, hr, hr_min⟩ := h_cpct.exists_isMinOn (spectrum_nonempty ℝ a ha) continuousOn_id\n    exact ⟨r, h _ hr, hr_min⟩\n\n"}
{"name":"IsSelfAdjoint.le_algebraMap_norm_self","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ LE.le a ((algebraMap Real A) (Norm.norm a))","decl":"lemma IsSelfAdjoint.le_algebraMap_norm_self {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    a ≤ algebraMap ℝ A ‖a‖ := by\n  by_cases nontriv : Nontrivial A\n  · refine le_algebraMap_of_spectrum_le fun r hr => ?_\n    calc r ≤ ‖r‖ := Real.le_norm_self r\n      _ ≤ ‖a‖ := spectrum.norm_le_norm_of_mem hr\n  · rw [not_nontrivial_iff_subsingleton] at nontriv\n    simp\n\n"}
{"name":"IsSelfAdjoint.neg_algebraMap_norm_le_self","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ LE.le (Neg.neg ((algebraMap Real A) (Norm.norm a))) a","decl":"lemma IsSelfAdjoint.neg_algebraMap_norm_le_self {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    - (algebraMap ℝ A ‖a‖) ≤ a := by\n  have : - a ≤ algebraMap ℝ A ‖a‖ := by\n    rw [← norm_neg]\n    exact IsSelfAdjoint.le_algebraMap_norm_self (neg ha)\n  exact neg_le.mp this\n\n"}
{"name":"CStarAlgebra.mul_star_le_algebraMap_norm_sq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\n⊢ LE.le (HMul.hMul a (Star.star a)) ((algebraMap Real A) (HPow.hPow (Norm.norm a) 2))","decl":"lemma CStarAlgebra.mul_star_le_algebraMap_norm_sq {a : A} :\n    a * star a ≤ algebraMap ℝ A (‖a‖ ^ 2) := by\n  have : a * star a ≤ algebraMap ℝ A ‖a * star a‖ := IsSelfAdjoint.le_algebraMap_norm_self\n  rwa [CStarRing.norm_self_mul_star, ← pow_two] at this\n\n"}
{"name":"CStarAlgebra.star_mul_le_algebraMap_norm_sq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\n⊢ LE.le (HMul.hMul (Star.star a) a) ((algebraMap Real A) (HPow.hPow (Norm.norm a) 2))","decl":"lemma CStarAlgebra.star_mul_le_algebraMap_norm_sq {a : A} :\n    star a * a ≤ algebraMap ℝ A (‖a‖ ^ 2) := by\n  have : star a * a ≤ algebraMap ℝ A ‖star a * a‖ := IsSelfAdjoint.le_algebraMap_norm_self\n  rwa [CStarRing.norm_star_mul_self, ← pow_two] at this\n\n"}
{"name":"IsSelfAdjoint.toReal_spectralRadius_eq_norm","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝ : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\n⊢ Eq (spectralRadius Real a).toReal (Norm.norm a)","decl":"lemma IsSelfAdjoint.toReal_spectralRadius_eq_norm {a : A} (ha : IsSelfAdjoint a) :\n    (spectralRadius ℝ a).toReal = ‖a‖ := by\n  simp [ha.spectrumRestricts.spectralRadius_eq, ha.spectralRadius_eq_nnnorm]\n\n"}
{"name":"CStarAlgebra.norm_or_neg_norm_mem_spectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝¹ : CStarAlgebra A\ninst✝ : Nontrivial A\na : A\nha : autoParam (IsSelfAdjoint a) _auto✝\n⊢ Or (Membership.mem (spectrum Real a) (Norm.norm a)) (Membership.mem (spectrum Real a) (Neg.neg (Norm.norm a)))","decl":"lemma norm_or_neg_norm_mem_spectrum [Nontrivial A] {a : A}\n    (ha : IsSelfAdjoint a := by cfc_tac) : ‖a‖ ∈ spectrum ℝ a ∨ -‖a‖ ∈ spectrum ℝ a := by\n  have ha' : SpectrumRestricts a Complex.reCLM := ha.spectrumRestricts\n  rw [← ha.toReal_spectralRadius_eq_norm]\n  exact Real.spectralRadius_mem_spectrum_or (ha'.image ▸ (spectrum.nonempty a).image _)\n\n"}
{"name":"CStarAlgebra.nnnorm_mem_spectrum_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝³ : CStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : Nontrivial A\na : A\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Membership.mem (spectrum NNReal a) (NNNorm.nnnorm a)","decl":"lemma nnnorm_mem_spectrum_of_nonneg [Nontrivial A] {a : A} (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖₊ ∈ spectrum ℝ≥0 a := by\n  have : IsSelfAdjoint a := .of_nonneg ha\n  convert NNReal.spectralRadius_mem_spectrum (a := a) ?_ (.nnreal_of_nonneg ha)\n  · simp [this.spectrumRestricts.spectralRadius_eq, this.spectralRadius_eq_nnnorm]\n  · exact this.spectrumRestricts.image ▸ (spectrum.nonempty a).image _\n\n"}
{"name":"CStarAlgebra.norm_mem_spectrum_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝³ : CStarAlgebra A\ninst✝² : PartialOrder A\ninst✝¹ : StarOrderedRing A\ninst✝ : Nontrivial A\na : A\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Membership.mem (spectrum Real a) (Norm.norm a)","decl":"lemma norm_mem_spectrum_of_nonneg [Nontrivial A] {a : A} (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖ ∈ spectrum ℝ a := by\n  simpa using spectrum.algebraMap_mem ℝ <| nnnorm_mem_spectrum_of_nonneg ha\n\n"}
{"name":"CStarAlgebra.norm_le_iff_le_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nr : Real\nhr : LE.le 0 r\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (Norm.norm a) r) (LE.le a ((algebraMap Real A) r))","decl":"lemma norm_le_iff_le_algebraMap (a : A) {r : ℝ} (hr : 0 ≤ r) (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖ ≤ r ↔ a ≤ algebraMap ℝ A r := by\n  rw [le_algebraMap_iff_spectrum_le]\n  obtain (h | _) := subsingleton_or_nontrivial A\n  · simp [Subsingleton.elim a 0, hr]\n  · exact ⟨fun h x hx ↦ Real.le_norm_self x |>.trans (spectrum.norm_le_norm_of_mem hx) |>.trans h,\n      fun h ↦ h ‖a‖ <| norm_mem_spectrum_of_nonneg⟩\n\n"}
{"name":"CStarAlgebra.nnnorm_le_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nr : NNReal\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (NNNorm.nnnorm a) r) (LE.le a ((algebraMap NNReal A) r))","decl":"lemma nnnorm_le_iff_of_nonneg (a : A) (r : ℝ≥0) (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖₊ ≤ r ↔ a ≤ algebraMap ℝ≥0 A r := by\n  rw [← NNReal.coe_le_coe]\n  exact norm_le_iff_le_algebraMap a r.2\n\n"}
{"name":"CStarAlgebra.norm_le_one_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (Norm.norm a) 1) (LE.le a 1)","decl":"lemma norm_le_one_iff_of_nonneg (a : A) (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖ ≤ 1 ↔ a ≤ 1 := by\n  simpa using norm_le_iff_le_algebraMap a zero_le_one\n\n"}
{"name":"CStarAlgebra.nnnorm_le_one_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (NNNorm.nnnorm a) 1) (LE.le a 1)","decl":"lemma nnnorm_le_one_iff_of_nonneg (a : A) (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖₊ ≤ 1 ↔ a ≤ 1 := by\n  rw [← NNReal.coe_le_coe]\n  exact norm_le_one_iff_of_nonneg a\n\n"}
{"name":"CStarAlgebra.norm_le_natCast_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nn : Nat\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (Norm.norm a) ↑n) (LE.le a ↑n)","decl":"lemma norm_le_natCast_iff_of_nonneg (a : A) (n : ℕ) (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖ ≤ n ↔ a ≤ n := by\n  simpa using norm_le_iff_le_algebraMap a n.cast_nonneg\n\n"}
{"name":"CStarAlgebra.nnnorm_le_natCast_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nn : Nat\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Iff (LE.le (NNNorm.nnnorm a) ↑n) (LE.le a ↑n)","decl":"lemma nnnorm_le_natCast_iff_of_nonneg (a : A) (n : ℕ) (ha : 0 ≤ a := by cfc_tac) :\n    ‖a‖₊ ≤ n ↔ a ≤ n := by\n  simpa using nnnorm_le_iff_of_nonneg a n\n\n\n"}
{"name":"CStarAlgebra.mem_Icc_algebraMap_iff_norm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx : A\nr : Real\nhr : LE.le 0 r\n⊢ Iff (Membership.mem (Set.Icc 0 ((algebraMap Real A) r)) x) (And (LE.le 0 x) (LE.le (Norm.norm x) r))","decl":"lemma mem_Icc_algebraMap_iff_norm_le {x : A} {r : ℝ} (hr : 0 ≤ r) :\n    x ∈ Icc 0 (algebraMap ℝ A r) ↔ 0 ≤ x ∧ ‖x‖ ≤ r := by\n  rw [mem_Icc, and_congr_right_iff, iff_comm]\n  exact (norm_le_iff_le_algebraMap _ hr ·)\n\n"}
{"name":"CStarAlgebra.mem_Icc_algebraMap_iff_nnnorm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx : A\nr : NNReal\n⊢ Iff (Membership.mem (Set.Icc 0 ((algebraMap NNReal A) r)) x) (And (LE.le 0 x) (LE.le (NNNorm.nnnorm x) r))","decl":"lemma mem_Icc_algebraMap_iff_nnnorm_le {x : A} {r : ℝ≥0} :\n    x ∈ Icc 0 (algebraMap ℝ≥0 A r) ↔ 0 ≤ x ∧ ‖x‖₊ ≤ r :=\n  mem_Icc_algebraMap_iff_norm_le (hr := r.2)\n\n"}
{"name":"CStarAlgebra.mem_Icc_iff_norm_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx : A\n⊢ Iff (Membership.mem (Set.Icc 0 1) x) (And (LE.le 0 x) (LE.le (Norm.norm x) 1))","decl":"lemma mem_Icc_iff_norm_le_one {x : A} :\n    x ∈ Icc 0 1 ↔ 0 ≤ x ∧ ‖x‖ ≤ 1 := by\n  simpa only [map_one] using mem_Icc_algebraMap_iff_norm_le zero_le_one (A := A)\n\n"}
{"name":"CStarAlgebra.mem_Icc_iff_nnnorm_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx : A\n⊢ Iff (Membership.mem (Set.Icc 0 1) x) (And (LE.le 0 x) (LE.le (NNNorm.nnnorm x) 1))","decl":"lemma mem_Icc_iff_nnnorm_le_one {x : A} :\n    x ∈ Icc 0 1 ↔ 0 ≤ x ∧ ‖x‖₊ ≤ 1 :=\n  mem_Icc_iff_norm_le_one\n\n"}
{"name":"CFC.conjugate_rpow_neg_one_half","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nh₀ : IsUnit a\nha : autoParam (LE.le 0 a) _auto✝\n⊢ Eq (HMul.hMul (HMul.hMul (HPow.hPow a (Neg.neg (1 / 2))) a) (HPow.hPow a (Neg.neg (1 / 2)))) 1","decl":"lemma CFC.conjugate_rpow_neg_one_half {a : A} (h₀ : IsUnit a) (ha : 0 ≤ a := by cfc_tac) :\n    a ^ (-(1 / 2) : ℝ) * a * a ^ (-(1 / 2) : ℝ) = 1 := by\n  lift a to Aˣ using h₀\n  nth_rw 2 [← rpow_one (a : A)]\n  simp only [← rpow_add (a.zero_not_mem_spectrum ℝ≥0)]\n  norm_num\n  exact rpow_zero _\n\n"}
{"name":"CStarAlgebra.isUnit_of_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nh₀ : IsUnit a\nha : autoParam (LE.le 0 a) _auto✝\nhab : LE.le a b\n⊢ IsUnit b","decl":"/-- In a unital C⋆-algebra, if `a` is nonnegative and invertible, and `a ≤ b`, then `b` is\ninvertible. -/\nlemma CStarAlgebra.isUnit_of_le {a b : A} (h₀ : IsUnit a) (ha : 0 ≤ a := by cfc_tac)\n    (hab : a ≤ b) : IsUnit b := by\n  rw [← spectrum.zero_not_mem_iff ℝ≥0] at h₀ ⊢\n  nontriviality A\n  have hb := (show 0 ≤ a from ha).trans hab\n  rw [zero_not_mem_iff, SpectrumRestricts.nnreal_lt_iff (.nnreal_of_nonneg ‹_›),\n    NNReal.coe_zero, ← CFC.exists_pos_algebraMap_le_iff (.of_nonneg ‹_›)] at h₀ ⊢\n  peel h₀ with r hr _\n  exact this.trans hab\n\n"}
{"name":"le_iff_norm_sqrt_mul_rpow","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nhbu : IsUnit b\nha : LE.le 0 a\nhb : LE.le 0 b\n⊢ Iff (LE.le a b) (LE.le (Norm.norm (HMul.hMul (CFC.sqrt a) (HPow.hPow b (Neg.neg (1 / 2))))) 1)","decl":"lemma le_iff_norm_sqrt_mul_rpow {a b : A} (hbu : IsUnit b) (ha : 0 ≤ a) (hb : 0 ≤ (b : A)) :\n    a ≤ b ↔ ‖sqrt a * (b : A) ^ (-(1 / 2) : ℝ)‖ ≤ 1 := by\n  lift b to Aˣ using hbu\n  have hbab : 0 ≤ (b : A) ^ (-(1 / 2) : ℝ) * a * (b : A) ^ (-(1 / 2) : ℝ) :=\n    conjugate_nonneg_of_nonneg ha rpow_nonneg\n  #adaptation_note /-- 2024-11-10\n  added `(R := A)` -/\n  conv_rhs =>\n    rw [← sq_le_one_iff₀ (norm_nonneg _), sq, ← CStarRing.norm_star_mul_self, star_mul,\n      IsSelfAdjoint.of_nonneg (R := A) sqrt_nonneg, IsSelfAdjoint.of_nonneg rpow_nonneg,\n      ← mul_assoc, mul_assoc _ _ (sqrt a), sqrt_mul_sqrt_self a,\n      CStarAlgebra.norm_le_one_iff_of_nonneg _ hbab]\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · calc\n      _ ≤ ↑b ^ (-(1 / 2) : ℝ) * (b : A) * ↑b ^ (-(1 / 2) : ℝ) :=\n        IsSelfAdjoint.of_nonneg rpow_nonneg |>.conjugate_le_conjugate h\n      _ = 1 := conjugate_rpow_neg_one_half b.isUnit\n  · calc\n      a = (sqrt ↑b * ↑b ^ (-(1 / 2) : ℝ)) * a * (↑b ^ (-(1 / 2) : ℝ) * sqrt ↑b) := by\n        simp only [CFC.sqrt_eq_rpow .., ← CFC.rpow_add (b.zero_not_mem_spectrum ℝ≥0)]\n        norm_num\n        simp [CFC.rpow_zero (b : A)]\n      _ = sqrt ↑b * (↑b ^ (-(1 / 2) : ℝ) * a * ↑b ^ (-(1 / 2) : ℝ)) * sqrt ↑b := by\n        simp only [mul_assoc]\n      _ ≤ b := conjugate_le_conjugate_of_nonneg h sqrt_nonneg |>.trans <| by\n        simp [CFC.sqrt_mul_sqrt_self (b : A)]\n\n"}
{"name":"le_iff_norm_sqrt_mul_sqrt_inv","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nb : Units A\nha : LE.le 0 a\nhb : LE.le 0 ↑b\n⊢ Iff (LE.le a ↑b) (LE.le (Norm.norm (HMul.hMul (CFC.sqrt a) (CFC.sqrt ↑(Inv.inv b)))) 1)","decl":"lemma le_iff_norm_sqrt_mul_sqrt_inv {a : A} {b : Aˣ} (ha : 0 ≤ a) (hb : 0 ≤ (b : A)) :\n    a ≤ b ↔ ‖sqrt a * sqrt (↑b⁻¹ : A)‖ ≤ 1 := by\n  rw [CFC.sqrt_eq_rpow (a := (↑b⁻¹ : A)), ← CFC.rpow_neg_one_eq_inv b,\n    CFC.rpow_rpow (b : A) _ _ (by simp) (by norm_num), le_iff_norm_sqrt_mul_rpow b.isUnit ha hb]\n  norm_num\n\n"}
{"name":"CStarAlgebra.inv_le_inv","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : Units A\nha : LE.le 0 ↑a\nhab : LE.le ↑a ↑b\n⊢ LE.le ↑(Inv.inv b) ↑(Inv.inv a)","decl":"/-- In a unital C⋆-algebra, if `0 ≤ a ≤ b` and `a` and `b` are units, then `b⁻¹ ≤ a⁻¹`. -/\nprotected lemma inv_le_inv {a b : Aˣ} (ha : 0 ≤ (a : A))\n    (hab : (a : A) ≤ b) : (↑b⁻¹ : A) ≤ a⁻¹ := by\n  have hb := ha.trans hab\n  have hb_inv : (0 : A) ≤ b⁻¹ := inv_nonneg_of_nonneg b hb\n  have ha_inv : (0 : A) ≤ a⁻¹ := inv_nonneg_of_nonneg a ha\n  rw [le_iff_norm_sqrt_mul_sqrt_inv ha hb, ← sq_le_one_iff₀ (norm_nonneg _), sq,\n    ← CStarRing.norm_star_mul_self] at hab\n  rw [le_iff_norm_sqrt_mul_sqrt_inv hb_inv ha_inv, inv_inv, ← sq_le_one_iff₀ (norm_nonneg _), sq,\n    ← CStarRing.norm_self_mul_star]\n  rwa [star_mul, IsSelfAdjoint.of_nonneg sqrt_nonneg,\n    IsSelfAdjoint.of_nonneg sqrt_nonneg] at hab ⊢\n\n"}
{"name":"CStarAlgebra.inv_le_inv_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : Units A\nha : LE.le 0 ↑a\nhb : LE.le 0 ↑b\n⊢ Iff (LE.le ↑(Inv.inv a) ↑(Inv.inv b)) (LE.le ↑b ↑a)","decl":"/-- In a unital C⋆-algebra, if `0 ≤ a` and `0 ≤ b` and `a` and `b` are units, then `a⁻¹ ≤ b⁻¹`\nif and only if `b ≤ a`. -/\nprotected lemma inv_le_inv_iff {a b : Aˣ} (ha : 0 ≤ (a : A)) (hb : 0 ≤ (b : A)) :\n    (↑a⁻¹ : A) ≤ b⁻¹ ↔ (b : A) ≤ a :=\n  ⟨CStarAlgebra.inv_le_inv (inv_nonneg_of_nonneg a ha), CStarAlgebra.inv_le_inv hb⟩\n\n"}
{"name":"CStarAlgebra.inv_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : Units A\nha : LE.le 0 ↑a\nhb : LE.le 0 ↑b\n⊢ Iff (LE.le ↑(Inv.inv a) ↑b) (LE.le ↑(Inv.inv b) ↑a)","decl":"lemma inv_le_iff {a b : Aˣ} (ha : 0 ≤ (a : A)) (hb : 0 ≤ (↑b : A)) :\n    (↑a⁻¹ : A) ≤ b ↔ (↑b⁻¹ : A) ≤ a := by\n  simpa using CStarAlgebra.inv_le_inv_iff ha (inv_nonneg_of_nonneg b hb)\n\n"}
{"name":"CStarAlgebra.le_inv_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : Units A\nha : LE.le 0 ↑a\nhb : LE.le 0 ↑b\n⊢ Iff (LE.le ↑a ↑(Inv.inv b)) (LE.le ↑b ↑(Inv.inv a))","decl":"lemma le_inv_iff {a b : Aˣ} (ha : 0 ≤ (a : A)) (hb : 0 ≤ (↑b : A)) :\n    a ≤ (↑b⁻¹ : A) ↔ b ≤ (↑a⁻¹ : A) := by\n  simpa using CStarAlgebra.inv_le_inv_iff (inv_nonneg_of_nonneg a ha) hb\n\n"}
{"name":"CStarAlgebra.one_le_inv_iff_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : Units A\nha : LE.le 0 ↑a\n⊢ Iff (LE.le 1 ↑(Inv.inv a)) (LE.le a 1)","decl":"lemma one_le_inv_iff_le_one {a : Aˣ} (ha : 0 ≤ (a : A)) :\n    1 ≤ (↑a⁻¹ : A) ↔ a ≤ 1 := by\n  simpa using CStarAlgebra.le_inv_iff (a := 1) (by simp) ha\n\n"}
{"name":"CStarAlgebra.inv_le_one_iff_one_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : Units A\nha : LE.le 0 ↑a\n⊢ Iff (LE.le (↑(Inv.inv a)) 1) (LE.le 1 a)","decl":"lemma inv_le_one_iff_one_le {a : Aˣ} (ha : 0 ≤ (a : A)) :\n    (↑a⁻¹ : A) ≤ 1 ↔ 1 ≤ a := by\n  simpa using CStarAlgebra.inv_le_iff ha (b := 1) (by simp)\n\n"}
{"name":"CStarAlgebra.inv_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : Units A\nha : LE.le 1 a\n⊢ LE.le (↑(Inv.inv a)) 1","decl":"lemma inv_le_one {a : Aˣ} (ha : 1 ≤ a) : (↑a⁻¹ : A) ≤ 1 :=\n  CStarAlgebra.inv_le_one_iff_one_le (zero_le_one.trans ha) |>.mpr ha\n\n"}
{"name":"CStarAlgebra.le_one_of_one_le_inv","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : Units A\nha : LE.le 1 ↑(Inv.inv a)\n⊢ LE.le (↑a) 1","decl":"lemma le_one_of_one_le_inv {a : Aˣ} (ha : 1 ≤ (↑a⁻¹ : A)) : (a : A) ≤ 1 := by\n  simpa using CStarAlgebra.inv_le_one ha\n\n"}
{"name":"CStarAlgebra.rpow_neg_one_le_rpow_neg_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nha : LE.le 0 a\nhab : LE.le a b\nhau : IsUnit a\n⊢ LE.le (HPow.hPow b (-1)) (HPow.hPow a (-1))","decl":"lemma rpow_neg_one_le_rpow_neg_one {a b : A} (ha : 0 ≤ a) (hab : a ≤ b) (hau : IsUnit a) :\n    b ^ (-1 : ℝ) ≤ a ^ (-1 : ℝ) := by\n  lift b to Aˣ using isUnit_of_le hau ha hab\n  lift a to Aˣ using hau\n  rw [rpow_neg_one_eq_inv a ha, rpow_neg_one_eq_inv b (ha.trans hab)]\n  exact CStarAlgebra.inv_le_inv ha hab\n\n"}
{"name":"CStarAlgebra.rpow_neg_one_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : LE.le 1 a\n⊢ LE.le (HPow.hPow a (-1)) 1","decl":"lemma rpow_neg_one_le_one {a : A} (ha : 1 ≤ a) : a ^ (-1 : ℝ) ≤ 1 := by\n  lift a to Aˣ using isUnit_of_le isUnit_one zero_le_one ha\n  rw [rpow_neg_one_eq_inv a (zero_le_one.trans ha)]\n  exact inv_le_one ha\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClassComplexNonUnital","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝¹ : NonUnitalCStarAlgebra A\ninst✝ : PartialOrder A\n⊢ NonnegSpectrumClass Complex A","decl":"open ComplexOrder in\ninstance instNonnegSpectrumClassComplexNonUnital : NonnegSpectrumClass ℂ A where\n  quasispectrum_nonneg_of_nonneg a ha x hx := by\n    rw [Unitization.quasispectrum_eq_spectrum_inr' ℂ ℂ a] at hx\n    exact spectrum_nonneg_of_nonneg (Unitization.inr_nonneg_iff.mpr ha) hx\n\n"}
{"name":"CStarAlgebra.norm_le_norm_of_nonneg_of_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nha : autoParam (LE.le 0 a) _auto✝\nhab : LE.le a b\n⊢ LE.le (Norm.norm a) (Norm.norm b)","decl":"lemma norm_le_norm_of_nonneg_of_le {a b : A} (ha : 0 ≤ a := by cfc_tac) (hab : a ≤ b) :\n    ‖a‖ ≤ ‖b‖ := by\n  suffices ∀ a b : A⁺¹, 0 ≤ a → a ≤ b → ‖a‖ ≤ ‖b‖ by\n    have hb := ha.trans hab\n    simpa only [ge_iff_le, Unitization.norm_inr] using\n      this a b (by simpa) (by rwa [Unitization.inr_le_iff a b])\n  intro a b ha hab\n  have hb : 0 ≤ b := ha.trans hab\n  -- these two `have`s are just for performance\n  have := IsSelfAdjoint.of_nonneg ha; have := IsSelfAdjoint.of_nonneg hb\n  have h₂ : cfc (id : ℝ → ℝ) a ≤ cfc (fun _ => ‖b‖) a := by\n    calc _ = a := by rw [cfc_id ℝ a]\n      _ ≤ cfc id b := (cfc_id ℝ b) ▸ hab\n      _ ≤ cfc (fun _ => ‖b‖) b := by\n          refine cfc_mono fun x hx => ?_\n          calc x = ‖x‖ := (Real.norm_of_nonneg (spectrum_nonneg_of_nonneg hb hx)).symm\n            _ ≤ ‖b‖ := spectrum.norm_le_norm_of_mem hx\n      _ = _ := by rw [cfc_const _ _, cfc_const _ _]\n  rw [cfc_le_iff id (fun _ => ‖b‖) a] at h₂\n  exact h₂ ‖a‖ <| norm_mem_spectrum_of_nonneg ha\n\n"}
{"name":"CStarAlgebra.nnnorm_le_nnnorm_of_nonneg_of_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nha : autoParam (LE.le 0 a) _auto✝\nhab : LE.le a b\n⊢ LE.le (NNNorm.nnnorm a) (NNNorm.nnnorm b)","decl":"theorem nnnorm_le_nnnorm_of_nonneg_of_le {a : A} {b : A} (ha : 0 ≤ a := by cfc_tac) (hab : a ≤ b) :\n    ‖a‖₊ ≤ ‖b‖₊ :=\n  norm_le_norm_of_nonneg_of_le ha hab\n\n"}
{"name":"CStarAlgebra.conjugate_le_norm_smul","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nhb : autoParam (IsSelfAdjoint b) _auto✝\n⊢ LE.le (HMul.hMul (HMul.hMul (Star.star a) b) a) (HSMul.hSMul (Norm.norm b) (HMul.hMul (Star.star a) a))","decl":"lemma conjugate_le_norm_smul {a b : A} (hb : IsSelfAdjoint b := by cfc_tac) :\n    star a * b * a ≤ ‖b‖ • (star a * a) := by\n  suffices ∀ a b : A⁺¹, IsSelfAdjoint b → star a * b * a ≤ ‖b‖ • (star a * a) by\n    rw [← Unitization.inr_le_iff _ _ (by aesop) ((IsSelfAdjoint.all _).smul (.star_mul_self a))]\n    simpa [Unitization.norm_inr] using this a b <| hb.inr ℂ\n  intro a b hb\n  calc\n    star a * b * a ≤ star a * (algebraMap ℝ A⁺¹ ‖b‖) * a :=\n      conjugate_le_conjugate hb.le_algebraMap_norm_self _\n    _ = ‖b‖ • (star a * a) := by simp [Algebra.algebraMap_eq_smul_one]\n\n"}
{"name":"CStarAlgebra.conjugate_le_norm_smul'","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na b : A\nhb : autoParam (IsSelfAdjoint b) _auto✝\n⊢ LE.le (HMul.hMul (HMul.hMul a b) (Star.star a)) (HSMul.hSMul (Norm.norm b) (HMul.hMul a (Star.star a)))","decl":"lemma conjugate_le_norm_smul' {a b : A} (hb : IsSelfAdjoint b := by cfc_tac) :\n    a * b * star a ≤ ‖b‖ • (a * star a) := by\n  have h₁ : a * b * star a = star (star a) * b * star a := by simp\n  have h₂ : a * star a = star (star a) * star a := by simp\n  simp only [h₁, h₂]\n  exact conjugate_le_norm_smul\n\n"}
{"name":"CStarAlgebra.isClosed_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\n⊢ IsClosed (setOf fun a => LE.le 0 a)","decl":"/-- The set of nonnegative elements in a C⋆-algebra is closed. -/\nlemma isClosed_nonneg : IsClosed {a : A | 0 ≤ a} := by\n  suffices IsClosed {a : A⁺¹ | 0 ≤ a} by\n    rw [Unitization.isometry_inr (𝕜 := ℂ) |>.isClosedEmbedding.isClosed_iff_image_isClosed]\n    convert this.inter <| (Unitization.isometry_inr (𝕜 := ℂ)).isClosedEmbedding.isClosed_range\n    ext a\n    simp only [Set.mem_image, Set.mem_setOf_eq, Set.mem_inter_iff, Set.mem_range, ← exists_and_left]\n    congr! 2 with x\n    exact and_congr_left fun h ↦ by simp [← h]\n  simp only [nonneg_iff_isSelfAdjoint_and_spectrumRestricts,\n    and_congr_right (SpectrumRestricts.nnreal_iff_nnnorm · le_rfl), Set.setOf_and]\n  refine isClosed_eq ?_ ?_ |>.inter <| isClosed_le ?_ ?_\n  all_goals fun_prop\n\n"}
{"name":"CStarAlgebra.instOrderClosedTopology","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\n⊢ OrderClosedTopology A","decl":"instance : OrderClosedTopology A where\n  isClosed_le' := isClosed_le_of_isClosed_nonneg isClosed_nonneg\n\n"}
{"name":"CStarAlgebra.inr_mem_Icc_iff_norm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx : A\n⊢ Iff (Membership.mem (Set.Icc 0 1) ↑x) (And (LE.le 0 x) (LE.le (Norm.norm x) 1))","decl":"lemma inr_mem_Icc_iff_norm_le {x : A} :\n    (x : A⁺¹) ∈ Icc 0 1 ↔ 0 ≤ x ∧ ‖x‖ ≤ 1 := by\n  simp only [mem_Icc, inr_nonneg_iff, and_congr_right_iff]\n  rw [← norm_inr (𝕜 := ℂ), ← inr_nonneg_iff, iff_comm]\n  exact (norm_le_one_iff_of_nonneg _ ·)\n\n"}
{"name":"CStarAlgebra.inr_mem_Icc_iff_nnnorm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\nx : A\n⊢ Iff (Membership.mem (Set.Icc 0 1) ↑x) (And (LE.le 0 x) (LE.le (NNNorm.nnnorm x) 1))","decl":"lemma inr_mem_Icc_iff_nnnorm_le {x : A} :\n    (x : A⁺¹) ∈ Icc 0 1 ↔ 0 ≤ x ∧ ‖x‖₊ ≤ 1 :=\n  inr_mem_Icc_iff_norm_le\n\n"}
{"name":"CStarAlgebra.preimage_inr_Icc_zero_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : NonUnitalCStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\n⊢ Eq (Set.preimage Unitization.inr (Set.Icc 0 1)) (Inter.inter (setOf fun x => LE.le 0 x) (Metric.closedBall 0 1))","decl":"lemma preimage_inr_Icc_zero_one :\n    ((↑) : A → A⁺¹) ⁻¹' Icc 0 1 = {x : A | 0 ≤ x} ∩ closedBall 0 1 := by\n  ext\n  simp [- mem_Icc, inr_mem_Icc_iff_norm_le]\n\n"}
{"name":"CStarAlgebra.pow_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : autoParam (LE.le 0 a) _auto✝\nn : Nat\n⊢ LE.le 0 (HPow.hPow a n)","decl":"lemma pow_nonneg {a : A} (ha : 0 ≤ a := by cfc_tac) (n : ℕ) : 0 ≤ a ^ n := by\n  rw [← cfc_pow_id (R := ℝ≥0) a]\n  exact cfc_nonneg_of_predicate\n\n"}
{"name":"CStarAlgebra.pow_monotone","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha : LE.le 1 a\n⊢ Monotone fun x => HPow.hPow a x","decl":"lemma pow_monotone {a : A} (ha : 1 ≤ a) : Monotone (a ^ · : ℕ → A) := by\n  have ha' : 0 ≤ a := zero_le_one.trans ha\n  intro n m hnm\n  simp only\n  rw [← cfc_pow_id (R := ℝ) a, ← cfc_pow_id (R := ℝ) a, cfc_le_iff ..]\n  rw [CFC.one_le_iff (R := ℝ) a] at ha\n  peel ha with x hx _\n  exact pow_le_pow_right₀ (ha x hx) hnm\n\n"}
{"name":"CStarAlgebra.pow_antitone","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst✝² : CStarAlgebra A\ninst✝¹ : PartialOrder A\ninst✝ : StarOrderedRing A\na : A\nha₀ : autoParam (LE.le 0 a) _auto✝\nha₁ : LE.le a 1\n⊢ Antitone fun x => HPow.hPow a x","decl":"lemma pow_antitone {a : A} (ha₀ : 0 ≤ a := by cfc_tac) (ha₁ : a ≤ 1) :\n    Antitone (a ^ · : ℕ → A) := by\n  intro n m hnm\n  simp only\n  rw [← cfc_pow_id (R := ℝ) a, ← cfc_pow_id (R := ℝ) a, cfc_le_iff ..]\n  rw [CFC.le_one_iff (R := ℝ) a] at ha₁\n  peel ha₁ with x hx _\n  exact pow_le_pow_of_le_one (spectrum_nonneg_of_nonneg ha₀ hx) (ha₁ x hx) hnm\n\n"}
