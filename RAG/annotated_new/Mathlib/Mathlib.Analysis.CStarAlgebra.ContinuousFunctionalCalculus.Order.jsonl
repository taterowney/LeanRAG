{"name":"cfc_tsub","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù‚Åπ : TopologicalSpace A\ninst‚úù‚Å∏ : Ring A\ninst‚úù‚Å∑ : PartialOrder A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : StarOrderedRing A\ninst‚úù‚Å¥ : Algebra Real A\ninst‚úù¬≥ : TopologicalRing A\ninst‚úù¬≤ : T2Space A\ninst‚úù¬π : ContinuousFunctionalCalculus Real IsSelfAdjoint\ninst‚úù : NonnegSpectrumClass Real A\nf g : NNReal ‚Üí NNReal\na : A\nhfg : ‚àÄ (x : NNReal), Membership.mem (spectrum NNReal a) x ‚Üí LE.le (g x) (f x)\nha : autoParam (LE.le 0 a) _auto‚úù\nhf : autoParam (ContinuousOn f (spectrum NNReal a)) _auto‚úù\nhg : autoParam (ContinuousOn g (spectrum NNReal a)) _auto‚úù\n‚ä¢ Eq (cfc (fun x => HSub.hSub (f x) (g x)) a) (HSub.hSub (cfc f a) (cfc g a))","decl":"theorem cfc_tsub {A : Type*} [TopologicalSpace A] [Ring A] [PartialOrder A] [StarRing A]\n    [StarOrderedRing A] [Algebra ‚Ñù A] [TopologicalRing A] [T2Space A]\n    [ContinuousFunctionalCalculus ‚Ñù (IsSelfAdjoint : A ‚Üí Prop)]\n    [NonnegSpectrumClass ‚Ñù A] (f g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0)\n    (a : A) (hfg : ‚àÄ x ‚àà spectrum ‚Ñù‚â•0 a, g x ‚â§ f x) (ha : 0 ‚â§ a := by cfc_tac)\n    (hf : ContinuousOn f (spectrum ‚Ñù‚â•0 a) := by cfc_cont_tac)\n    (hg : ContinuousOn g (spectrum ‚Ñù‚â•0 a) := by cfc_cont_tac) :\n    cfc (fun x ‚Ü¶ f x - g x) a = cfc f a - cfc g a := by\n  have ha' := SpectrumRestricts.nnreal_of_nonneg ha\n  have : (spectrum ‚Ñù a).EqOn (fun x ‚Ü¶ ((f x.toNNReal - g x.toNNReal : ‚Ñù‚â•0) : ‚Ñù))\n      (fun x ‚Ü¶ f x.toNNReal - g x.toNNReal) :=\n    fun x hx ‚Ü¶ NNReal.coe_sub <| hfg _ <| ha'.apply_mem hx\n  rw [cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_congr this]\n  refine cfc_sub _ _ a ?_ ?_\n  all_goals\n    exact continuous_subtype_val.comp_continuousOn <|\n      ContinuousOn.comp ‚Äπ_‚Ä∫ continuous_real_toNNReal.continuousOn <| ha'.image ‚ñ∏ Set.mapsTo_image ..\n\n"}
{"name":"cfc‚Çô_tsub","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬π¬π : TopologicalSpace A\ninst‚úù¬π‚Å∞ : NonUnitalRing A\ninst‚úù‚Åπ : PartialOrder A\ninst‚úù‚Å∏ : StarRing A\ninst‚úù‚Å∑ : StarOrderedRing A\ninst‚úù‚Å∂ : Module Real A\ninst‚úù‚Åµ : IsScalarTower Real A A\ninst‚úù‚Å¥ : SMulCommClass Real A A\ninst‚úù¬≥ : TopologicalRing A\ninst‚úù¬≤ : T2Space A\ninst‚úù¬π : NonUnitalContinuousFunctionalCalculus Real IsSelfAdjoint\ninst‚úù : NonnegSpectrumClass Real A\nf g : NNReal ‚Üí NNReal\na : A\nhfg : ‚àÄ (x : NNReal), Membership.mem (quasispectrum NNReal a) x ‚Üí LE.le (g x) (f x)\nha : autoParam (LE.le 0 a) _auto‚úù\nhf : autoParam (ContinuousOn f (quasispectrum NNReal a)) _auto‚úù\nhf0 : autoParam (Eq (f 0) 0) _auto‚úù\nhg : autoParam (ContinuousOn g (quasispectrum NNReal a)) _auto‚úù\nhg0 : autoParam (Eq (g 0) 0) _auto‚úù\n‚ä¢ Eq (cfc‚Çô (fun x => HSub.hSub (f x) (g x)) a) (HSub.hSub (cfc‚Çô f a) (cfc‚Çô g a))","decl":"theorem cfc‚Çô_tsub {A : Type*} [TopologicalSpace A] [NonUnitalRing A] [PartialOrder A] [StarRing A]\n    [StarOrderedRing A] [Module ‚Ñù A] [IsScalarTower ‚Ñù A A] [SMulCommClass ‚Ñù A A] [TopologicalRing A]\n    [T2Space A] [NonUnitalContinuousFunctionalCalculus ‚Ñù (IsSelfAdjoint : A ‚Üí Prop)]\n    [NonnegSpectrumClass ‚Ñù A] (f g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0)\n    (a : A) (hfg : ‚àÄ x ‚àà œÉ‚Çô ‚Ñù‚â•0 a, g x ‚â§ f x) (ha : 0 ‚â§ a := by cfc_tac)\n    (hf : ContinuousOn f (œÉ‚Çô ‚Ñù‚â•0 a) := by cfc_cont_tac) (hf0 : f 0 = 0 := by cfc_zero_tac)\n    (hg : ContinuousOn g (œÉ‚Çô ‚Ñù‚â•0 a) := by cfc_cont_tac) (hg0 : g 0 = 0 := by cfc_zero_tac) :\n    cfc‚Çô (fun x ‚Ü¶ f x - g x) a = cfc‚Çô f a - cfc‚Çô g a := by\n  have ha' := QuasispectrumRestricts.nnreal_of_nonneg ha\n  have : (œÉ‚Çô ‚Ñù a).EqOn (fun x ‚Ü¶ ((f x.toNNReal - g x.toNNReal : ‚Ñù‚â•0) : ‚Ñù))\n      (fun x ‚Ü¶ f x.toNNReal - g x.toNNReal) :=\n    fun x hx ‚Ü¶ NNReal.coe_sub <| hfg _ <| ha'.apply_mem hx\n  rw [cfc‚Çô_nnreal_eq_real, cfc‚Çô_nnreal_eq_real, cfc‚Çô_nnreal_eq_real, cfc‚Çô_congr this]\n  refine cfc‚Çô_sub _ _ a ?_ (by simpa) ?_\n  all_goals\n    exact continuous_subtype_val.comp_continuousOn <|\n      ContinuousOn.comp ‚Äπ_‚Ä∫ continuous_real_toNNReal.continuousOn <| ha'.image ‚ñ∏ Set.mapsTo_image ..\n\n"}
{"name":"Unitization.instStarOrderedRing","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù : NonUnitalCStarAlgebra A\n‚ä¢ StarOrderedRing (Unitization Complex A)","decl":"instance instStarOrderedRing : StarOrderedRing A‚Å∫¬π :=\n    CStarAlgebra.spectralOrderedRing _\n\n"}
{"name":"Unitization.inr_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nha : autoParam (IsSelfAdjoint a) _auto‚úù\nhb : autoParam (IsSelfAdjoint b) _auto‚úù\n‚ä¢ Iff (LE.le ‚Üëa ‚Üëb) (LE.le a b)","decl":"lemma inr_le_iff (a b : A) (ha : IsSelfAdjoint a := by cfc_tac)\n    (hb : IsSelfAdjoint b := by cfc_tac) :\n    (a : A‚Å∫¬π) ‚â§ (b : A‚Å∫¬π) ‚Üî a ‚â§ b := by\n  -- TODO: prove the more general result for star monomorphisms and use it here.\n  rw [‚Üê sub_nonneg, ‚Üê sub_nonneg (a := b), StarOrderedRing.nonneg_iff_spectrum_nonneg (R := ‚Ñù) _,\n    ‚Üê inr_sub ‚ÑÇ b a, ‚Üê Unitization.quasispectrum_eq_spectrum_inr' ‚Ñù ‚ÑÇ]\n  exact StarOrderedRing.nonneg_iff_quasispectrum_nonneg _ |>.symm\n\n"}
{"name":"Unitization.inr_nonneg_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\n‚ä¢ Iff (LE.le 0 ‚Üëa) (LE.le 0 a)","decl":"@[simp, norm_cast]\nlemma inr_nonneg_iff {a : A} : 0 ‚â§ (a : A‚Å∫¬π) ‚Üî 0 ‚â§ a := by\n  by_cases ha : IsSelfAdjoint a\n  ¬∑ exact inr_zero ‚ÑÇ (A := A) ‚ñ∏ inr_le_iff 0 a\n  ¬∑ refine ‚ü®?_, ?_‚ü©\n    all_goals refine fun h ‚Ü¶ (ha ?_).elim\n    ¬∑ exact isSelfAdjoint_inr (R := ‚ÑÇ) |>.mp <| .of_nonneg h\n    ¬∑ exact .of_nonneg h\n\n"}
{"name":"Unitization.nnreal_cfc‚Çô_eq_cfc_inr","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nf : NNReal ‚Üí NNReal\nhf‚ÇÄ : autoParam (Eq (f 0) 0) _auto‚úù\n‚ä¢ Eq (‚Üë(cfc‚Çô f a)) (cfc f ‚Üëa)","decl":"lemma nnreal_cfc‚Çô_eq_cfc_inr (a : A) (f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0)\n    (hf‚ÇÄ : f 0 = 0 := by cfc_zero_tac) : cfc‚Çô f a = cfc f (a : A‚Å∫¬π) :=\n  cfc‚Çô_eq_cfc_inr inr_nonneg_iff ..\n\n"}
{"name":"cfc_nnreal_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù‚Åπ : TopologicalSpace A\ninst‚úù‚Å∏ : Ring A\ninst‚úù‚Å∑ : StarRing A\ninst‚úù‚Å∂ : PartialOrder A\ninst‚úù‚Åµ : StarOrderedRing A\ninst‚úù‚Å¥ : Algebra Real A\ninst‚úù¬≥ : TopologicalRing A\ninst‚úù¬≤ : NonnegSpectrumClass Real A\ninst‚úù¬π : T2Space A\ninst‚úù : ContinuousFunctionalCalculus Real IsSelfAdjoint\nf g : NNReal ‚Üí NNReal\na : A\nha_spec : SpectrumRestricts a ‚áëContinuousMap.realToNNReal\nhf : autoParam (ContinuousOn f (spectrum NNReal a)) _auto‚úù\nhg : autoParam (ContinuousOn g (spectrum NNReal a)) _auto‚úù\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (cfc f a) (cfc g a)) (‚àÄ (x : NNReal), Membership.mem (spectrum NNReal a) x ‚Üí LE.le (f x) (g x))","decl":"/-- `cfc_le_iff` only applies to a scalar ring where `R` is an actual `Ring`, and not a `Semiring`.\nHowever, this theorem still holds for `‚Ñù‚â•0` as long as the algebra `A` itself is an `‚Ñù`-algebra. -/\nlemma cfc_nnreal_le_iff {A : Type*} [TopologicalSpace A] [Ring A] [StarRing A] [PartialOrder A]\n    [StarOrderedRing A] [Algebra ‚Ñù A] [TopologicalRing A] [NonnegSpectrumClass ‚Ñù A]\n    [T2Space A] [ContinuousFunctionalCalculus ‚Ñù (IsSelfAdjoint : A ‚Üí Prop)]\n    (f : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) (g : ‚Ñù‚â•0 ‚Üí ‚Ñù‚â•0) (a : A)\n    (ha_spec : SpectrumRestricts a ContinuousMap.realToNNReal)\n    (hf : ContinuousOn f (spectrum ‚Ñù‚â•0 a) := by cfc_cont_tac)\n    (hg : ContinuousOn g (spectrum ‚Ñù‚â•0 a) := by cfc_cont_tac)\n    (ha : 0 ‚â§ a := by cfc_tac) :\n    cfc f a ‚â§ cfc g a ‚Üî ‚àÄ x ‚àà spectrum ‚Ñù‚â•0 a, f x ‚â§ g x := by\n  have hf' := hf.ofReal_map_toNNReal <| ha_spec.image ‚ñ∏ Set.mapsTo_image ..\n  have hg' := hg.ofReal_map_toNNReal <| ha_spec.image ‚ñ∏ Set.mapsTo_image ..\n  rw [cfc_nnreal_eq_real, cfc_nnreal_eq_real, cfc_le_iff ..]\n  simp [NNReal.coe_le_coe, ‚Üê ha_spec.image]\n\n"}
{"name":"CFC.exists_pos_algebraMap_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù‚Å∏ : TopologicalSpace A\ninst‚úù‚Å∑ : Ring A\ninst‚úù‚Å∂ : StarRing A\ninst‚úù‚Åµ : PartialOrder A\ninst‚úù‚Å¥ : StarOrderedRing A\ninst‚úù¬≥ : Algebra Real A\ninst‚úù¬≤ : NonnegSpectrumClass Real A\ninst‚úù¬π : Nontrivial A\ninst‚úù : ContinuousFunctionalCalculus Real IsSelfAdjoint\na : A\nha : autoParam (IsSelfAdjoint a) _auto‚úù\n‚ä¢ Iff (Exists fun r => And (GT.gt r 0) (LE.le ((algebraMap Real A) r) a)) (‚àÄ (x : Real), Membership.mem (spectrum Real a) x ‚Üí LT.lt 0 x)","decl":"open ContinuousFunctionalCalculus in\n/-- In a unital `‚Ñù`-algebra `A` with a continuous functional calculus, an element `a : A` is larger\nthan some `algebraMap ‚Ñù A r` if and only if every element of the `‚Ñù`-spectrum is nonnegative. -/\nlemma CFC.exists_pos_algebraMap_le_iff {A : Type*} [TopologicalSpace A] [Ring A] [StarRing A]\n    [PartialOrder A] [StarOrderedRing A] [Algebra ‚Ñù A] [NonnegSpectrumClass ‚Ñù A] [Nontrivial A]\n    [ContinuousFunctionalCalculus ‚Ñù (IsSelfAdjoint : A ‚Üí Prop)]\n    {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    (‚àÉ r > 0, algebraMap ‚Ñù A r ‚â§ a) ‚Üî (‚àÄ x ‚àà spectrum ‚Ñù a, 0 < x) := by\n  have h_cpct : IsCompact (spectrum ‚Ñù a) := isCompact_iff_compactSpace.mpr inferInstance\n  simp_rw [algebraMap_le_iff_le_spectrum (a := a)]\n  refine ‚ü®?_, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ rintro ‚ü®r, hr, hr_le‚ü©\n    exact (hr.trans_le <| hr_le ¬∑ ¬∑)\n  ¬∑ obtain ‚ü®r, hr, hr_min‚ü© := h_cpct.exists_isMinOn (spectrum_nonempty ‚Ñù a ha) continuousOn_id\n    exact ‚ü®r, h _ hr, hr_min‚ü©\n\n"}
{"name":"IsSelfAdjoint.le_algebraMap_norm_self","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : autoParam (IsSelfAdjoint a) _auto‚úù\n‚ä¢ LE.le a ((algebraMap Real A) (Norm.norm a))","decl":"lemma IsSelfAdjoint.le_algebraMap_norm_self {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    a ‚â§ algebraMap ‚Ñù A ‚Äña‚Äñ := by\n  by_cases nontriv : Nontrivial A\n  ¬∑ refine le_algebraMap_of_spectrum_le fun r hr => ?_\n    calc r ‚â§ ‚Äñr‚Äñ := Real.le_norm_self r\n      _ ‚â§ ‚Äña‚Äñ := spectrum.norm_le_norm_of_mem hr\n  ¬∑ rw [not_nontrivial_iff_subsingleton] at nontriv\n    simp\n\n"}
{"name":"IsSelfAdjoint.neg_algebraMap_norm_le_self","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : autoParam (IsSelfAdjoint a) _auto‚úù\n‚ä¢ LE.le (Neg.neg ((algebraMap Real A) (Norm.norm a))) a","decl":"lemma IsSelfAdjoint.neg_algebraMap_norm_le_self {a : A} (ha : IsSelfAdjoint a := by cfc_tac) :\n    - (algebraMap ‚Ñù A ‚Äña‚Äñ) ‚â§ a := by\n  have : - a ‚â§ algebraMap ‚Ñù A ‚Äña‚Äñ := by\n    rw [‚Üê norm_neg]\n    exact IsSelfAdjoint.le_algebraMap_norm_self (neg ha)\n  exact neg_le.mp this\n\n"}
{"name":"CStarAlgebra.mul_star_le_algebraMap_norm_sq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\n‚ä¢ LE.le (HMul.hMul a (Star.star a)) ((algebraMap Real A) (HPow.hPow (Norm.norm a) 2))","decl":"lemma CStarAlgebra.mul_star_le_algebraMap_norm_sq {a : A} :\n    a * star a ‚â§ algebraMap ‚Ñù A (‚Äña‚Äñ ^ 2) := by\n  have : a * star a ‚â§ algebraMap ‚Ñù A ‚Äña * star a‚Äñ := IsSelfAdjoint.le_algebraMap_norm_self\n  rwa [CStarRing.norm_self_mul_star, ‚Üê pow_two] at this\n\n"}
{"name":"CStarAlgebra.star_mul_le_algebraMap_norm_sq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\n‚ä¢ LE.le (HMul.hMul (Star.star a) a) ((algebraMap Real A) (HPow.hPow (Norm.norm a) 2))","decl":"lemma CStarAlgebra.star_mul_le_algebraMap_norm_sq {a : A} :\n    star a * a ‚â§ algebraMap ‚Ñù A (‚Äña‚Äñ ^ 2) := by\n  have : star a * a ‚â§ algebraMap ‚Ñù A ‚Äñstar a * a‚Äñ := IsSelfAdjoint.le_algebraMap_norm_self\n  rwa [CStarRing.norm_star_mul_self, ‚Üê pow_two] at this\n\n"}
{"name":"IsSelfAdjoint.toReal_spectralRadius_eq_norm","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù : CStarAlgebra A\na : A\nha : IsSelfAdjoint a\n‚ä¢ Eq (spectralRadius Real a).toReal (Norm.norm a)","decl":"lemma IsSelfAdjoint.toReal_spectralRadius_eq_norm {a : A} (ha : IsSelfAdjoint a) :\n    (spectralRadius ‚Ñù a).toReal = ‚Äña‚Äñ := by\n  simp [ha.spectrumRestricts.spectralRadius_eq, ha.spectralRadius_eq_nnnorm]\n\n"}
{"name":"CStarAlgebra.norm_or_neg_norm_mem_spectrum","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬π : CStarAlgebra A\ninst‚úù : Nontrivial A\na : A\nha : autoParam (IsSelfAdjoint a) _auto‚úù\n‚ä¢ Or (Membership.mem (spectrum Real a) (Norm.norm a)) (Membership.mem (spectrum Real a) (Neg.neg (Norm.norm a)))","decl":"lemma norm_or_neg_norm_mem_spectrum [Nontrivial A] {a : A}\n    (ha : IsSelfAdjoint a := by cfc_tac) : ‚Äña‚Äñ ‚àà spectrum ‚Ñù a ‚à® -‚Äña‚Äñ ‚àà spectrum ‚Ñù a := by\n  have ha' : SpectrumRestricts a Complex.reCLM := ha.spectrumRestricts\n  rw [‚Üê ha.toReal_spectralRadius_eq_norm]\n  exact Real.spectralRadius_mem_spectrum_or (ha'.image ‚ñ∏ (spectrum.nonempty a).image _)\n\n"}
{"name":"CStarAlgebra.nnnorm_mem_spectrum_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≥ : CStarAlgebra A\ninst‚úù¬≤ : PartialOrder A\ninst‚úù¬π : StarOrderedRing A\ninst‚úù : Nontrivial A\na : A\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Membership.mem (spectrum NNReal a) (NNNorm.nnnorm a)","decl":"lemma nnnorm_mem_spectrum_of_nonneg [Nontrivial A] {a : A} (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ‚Çä ‚àà spectrum ‚Ñù‚â•0 a := by\n  have : IsSelfAdjoint a := .of_nonneg ha\n  convert NNReal.spectralRadius_mem_spectrum (a := a) ?_ (.nnreal_of_nonneg ha)\n  ¬∑ simp [this.spectrumRestricts.spectralRadius_eq, this.spectralRadius_eq_nnnorm]\n  ¬∑ exact this.spectrumRestricts.image ‚ñ∏ (spectrum.nonempty a).image _\n\n"}
{"name":"CStarAlgebra.norm_mem_spectrum_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≥ : CStarAlgebra A\ninst‚úù¬≤ : PartialOrder A\ninst‚úù¬π : StarOrderedRing A\ninst‚úù : Nontrivial A\na : A\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Membership.mem (spectrum Real a) (Norm.norm a)","decl":"lemma norm_mem_spectrum_of_nonneg [Nontrivial A] {a : A} (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ ‚àà spectrum ‚Ñù a := by\n  simpa using spectrum.algebraMap_mem ‚Ñù <| nnnorm_mem_spectrum_of_nonneg ha\n\n"}
{"name":"CStarAlgebra.norm_le_iff_le_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nr : Real\nhr : LE.le 0 r\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (Norm.norm a) r) (LE.le a ((algebraMap Real A) r))","decl":"lemma norm_le_iff_le_algebraMap (a : A) {r : ‚Ñù} (hr : 0 ‚â§ r) (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ ‚â§ r ‚Üî a ‚â§ algebraMap ‚Ñù A r := by\n  rw [le_algebraMap_iff_spectrum_le]\n  obtain (h | _) := subsingleton_or_nontrivial A\n  ¬∑ simp [Subsingleton.elim a 0, hr]\n  ¬∑ exact ‚ü®fun h x hx ‚Ü¶ Real.le_norm_self x |>.trans (spectrum.norm_le_norm_of_mem hx) |>.trans h,\n      fun h ‚Ü¶ h ‚Äña‚Äñ <| norm_mem_spectrum_of_nonneg‚ü©\n\n"}
{"name":"CStarAlgebra.nnnorm_le_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nr : NNReal\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (NNNorm.nnnorm a) r) (LE.le a ((algebraMap NNReal A) r))","decl":"lemma nnnorm_le_iff_of_nonneg (a : A) (r : ‚Ñù‚â•0) (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ‚Çä ‚â§ r ‚Üî a ‚â§ algebraMap ‚Ñù‚â•0 A r := by\n  rw [‚Üê NNReal.coe_le_coe]\n  exact norm_le_iff_le_algebraMap a r.2\n\n"}
{"name":"CStarAlgebra.norm_le_one_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (Norm.norm a) 1) (LE.le a 1)","decl":"lemma norm_le_one_iff_of_nonneg (a : A) (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ ‚â§ 1 ‚Üî a ‚â§ 1 := by\n  simpa using norm_le_iff_le_algebraMap a zero_le_one\n\n"}
{"name":"CStarAlgebra.nnnorm_le_one_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (NNNorm.nnnorm a) 1) (LE.le a 1)","decl":"lemma nnnorm_le_one_iff_of_nonneg (a : A) (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ‚Çä ‚â§ 1 ‚Üî a ‚â§ 1 := by\n  rw [‚Üê NNReal.coe_le_coe]\n  exact norm_le_one_iff_of_nonneg a\n\n"}
{"name":"CStarAlgebra.norm_le_natCast_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nn : Nat\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (Norm.norm a) ‚Üën) (LE.le a ‚Üën)","decl":"lemma norm_le_natCast_iff_of_nonneg (a : A) (n : ‚Ñï) (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ ‚â§ n ‚Üî a ‚â§ n := by\n  simpa using norm_le_iff_le_algebraMap a n.cast_nonneg\n\n"}
{"name":"CStarAlgebra.nnnorm_le_natCast_iff_of_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nn : Nat\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Iff (LE.le (NNNorm.nnnorm a) ‚Üën) (LE.le a ‚Üën)","decl":"lemma nnnorm_le_natCast_iff_of_nonneg (a : A) (n : ‚Ñï) (ha : 0 ‚â§ a := by cfc_tac) :\n    ‚Äña‚Äñ‚Çä ‚â§ n ‚Üî a ‚â§ n := by\n  simpa using nnnorm_le_iff_of_nonneg a n\n\n\n"}
{"name":"CStarAlgebra.mem_Icc_algebraMap_iff_norm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx : A\nr : Real\nhr : LE.le 0 r\n‚ä¢ Iff (Membership.mem (Set.Icc 0 ((algebraMap Real A) r)) x) (And (LE.le 0 x) (LE.le (Norm.norm x) r))","decl":"lemma mem_Icc_algebraMap_iff_norm_le {x : A} {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    x ‚àà Icc 0 (algebraMap ‚Ñù A r) ‚Üî 0 ‚â§ x ‚àß ‚Äñx‚Äñ ‚â§ r := by\n  rw [mem_Icc, and_congr_right_iff, iff_comm]\n  exact (norm_le_iff_le_algebraMap _ hr ¬∑)\n\n"}
{"name":"CStarAlgebra.mem_Icc_algebraMap_iff_nnnorm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx : A\nr : NNReal\n‚ä¢ Iff (Membership.mem (Set.Icc 0 ((algebraMap NNReal A) r)) x) (And (LE.le 0 x) (LE.le (NNNorm.nnnorm x) r))","decl":"lemma mem_Icc_algebraMap_iff_nnnorm_le {x : A} {r : ‚Ñù‚â•0} :\n    x ‚àà Icc 0 (algebraMap ‚Ñù‚â•0 A r) ‚Üî 0 ‚â§ x ‚àß ‚Äñx‚Äñ‚Çä ‚â§ r :=\n  mem_Icc_algebraMap_iff_norm_le (hr := r.2)\n\n"}
{"name":"CStarAlgebra.mem_Icc_iff_norm_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx : A\n‚ä¢ Iff (Membership.mem (Set.Icc 0 1) x) (And (LE.le 0 x) (LE.le (Norm.norm x) 1))","decl":"lemma mem_Icc_iff_norm_le_one {x : A} :\n    x ‚àà Icc 0 1 ‚Üî 0 ‚â§ x ‚àß ‚Äñx‚Äñ ‚â§ 1 := by\n  simpa only [map_one] using mem_Icc_algebraMap_iff_norm_le zero_le_one (A := A)\n\n"}
{"name":"CStarAlgebra.mem_Icc_iff_nnnorm_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx : A\n‚ä¢ Iff (Membership.mem (Set.Icc 0 1) x) (And (LE.le 0 x) (LE.le (NNNorm.nnnorm x) 1))","decl":"lemma mem_Icc_iff_nnnorm_le_one {x : A} :\n    x ‚àà Icc 0 1 ‚Üî 0 ‚â§ x ‚àß ‚Äñx‚Äñ‚Çä ‚â§ 1 :=\n  mem_Icc_iff_norm_le_one\n\n"}
{"name":"CFC.conjugate_rpow_neg_one_half","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nh‚ÇÄ : IsUnit a\nha : autoParam (LE.le 0 a) _auto‚úù\n‚ä¢ Eq (HMul.hMul (HMul.hMul (HPow.hPow a (Neg.neg (1 / 2))) a) (HPow.hPow a (Neg.neg (1 / 2)))) 1","decl":"lemma CFC.conjugate_rpow_neg_one_half {a : A} (h‚ÇÄ : IsUnit a) (ha : 0 ‚â§ a := by cfc_tac) :\n    a ^ (-(1 / 2) : ‚Ñù) * a * a ^ (-(1 / 2) : ‚Ñù) = 1 := by\n  lift a to AÀ£ using h‚ÇÄ\n  nth_rw 2 [‚Üê rpow_one (a : A)]\n  simp only [‚Üê rpow_add (a.zero_not_mem_spectrum ‚Ñù‚â•0)]\n  norm_num\n  exact rpow_zero _\n\n"}
{"name":"CStarAlgebra.isUnit_of_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nh‚ÇÄ : IsUnit a\nha : autoParam (LE.le 0 a) _auto‚úù\nhab : LE.le a b\n‚ä¢ IsUnit b","decl":"/-- In a unital C‚ãÜ-algebra, if `a` is nonnegative and invertible, and `a ‚â§ b`, then `b` is\ninvertible. -/\nlemma CStarAlgebra.isUnit_of_le {a b : A} (h‚ÇÄ : IsUnit a) (ha : 0 ‚â§ a := by cfc_tac)\n    (hab : a ‚â§ b) : IsUnit b := by\n  rw [‚Üê spectrum.zero_not_mem_iff ‚Ñù‚â•0] at h‚ÇÄ ‚ä¢\n  nontriviality A\n  have hb := (show 0 ‚â§ a from ha).trans hab\n  rw [zero_not_mem_iff, SpectrumRestricts.nnreal_lt_iff (.nnreal_of_nonneg ‚Äπ_‚Ä∫),\n    NNReal.coe_zero, ‚Üê CFC.exists_pos_algebraMap_le_iff (.of_nonneg ‚Äπ_‚Ä∫)] at h‚ÇÄ ‚ä¢\n  peel h‚ÇÄ with r hr _\n  exact this.trans hab\n\n"}
{"name":"le_iff_norm_sqrt_mul_rpow","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nhbu : IsUnit b\nha : LE.le 0 a\nhb : LE.le 0 b\n‚ä¢ Iff (LE.le a b) (LE.le (Norm.norm (HMul.hMul (CFC.sqrt a) (HPow.hPow b (Neg.neg (1 / 2))))) 1)","decl":"lemma le_iff_norm_sqrt_mul_rpow {a b : A} (hbu : IsUnit b) (ha : 0 ‚â§ a) (hb : 0 ‚â§ (b : A)) :\n    a ‚â§ b ‚Üî ‚Äñsqrt a * (b : A) ^ (-(1 / 2) : ‚Ñù)‚Äñ ‚â§ 1 := by\n  lift b to AÀ£ using hbu\n  have hbab : 0 ‚â§ (b : A) ^ (-(1 / 2) : ‚Ñù) * a * (b : A) ^ (-(1 / 2) : ‚Ñù) :=\n    conjugate_nonneg_of_nonneg ha rpow_nonneg\n  #adaptation_note /-- 2024-11-10\n  added `(R := A)` -/\n  conv_rhs =>\n    rw [‚Üê sq_le_one_iff‚ÇÄ (norm_nonneg _), sq, ‚Üê CStarRing.norm_star_mul_self, star_mul,\n      IsSelfAdjoint.of_nonneg (R := A) sqrt_nonneg, IsSelfAdjoint.of_nonneg rpow_nonneg,\n      ‚Üê mul_assoc, mul_assoc _ _ (sqrt a), sqrt_mul_sqrt_self a,\n      CStarAlgebra.norm_le_one_iff_of_nonneg _ hbab]\n  refine ‚ü®fun h ‚Ü¶ ?_, fun h ‚Ü¶ ?_‚ü©\n  ¬∑ calc\n      _ ‚â§ ‚Üëb ^ (-(1 / 2) : ‚Ñù) * (b : A) * ‚Üëb ^ (-(1 / 2) : ‚Ñù) :=\n        IsSelfAdjoint.of_nonneg rpow_nonneg |>.conjugate_le_conjugate h\n      _ = 1 := conjugate_rpow_neg_one_half b.isUnit\n  ¬∑ calc\n      a = (sqrt ‚Üëb * ‚Üëb ^ (-(1 / 2) : ‚Ñù)) * a * (‚Üëb ^ (-(1 / 2) : ‚Ñù) * sqrt ‚Üëb) := by\n        simp only [CFC.sqrt_eq_rpow .., ‚Üê CFC.rpow_add (b.zero_not_mem_spectrum ‚Ñù‚â•0)]\n        norm_num\n        simp [CFC.rpow_zero (b : A)]\n      _ = sqrt ‚Üëb * (‚Üëb ^ (-(1 / 2) : ‚Ñù) * a * ‚Üëb ^ (-(1 / 2) : ‚Ñù)) * sqrt ‚Üëb := by\n        simp only [mul_assoc]\n      _ ‚â§ b := conjugate_le_conjugate_of_nonneg h sqrt_nonneg |>.trans <| by\n        simp [CFC.sqrt_mul_sqrt_self (b : A)]\n\n"}
{"name":"le_iff_norm_sqrt_mul_sqrt_inv","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nb : Units A\nha : LE.le 0 a\nhb : LE.le 0 ‚Üëb\n‚ä¢ Iff (LE.le a ‚Üëb) (LE.le (Norm.norm (HMul.hMul (CFC.sqrt a) (CFC.sqrt ‚Üë(Inv.inv b)))) 1)","decl":"lemma le_iff_norm_sqrt_mul_sqrt_inv {a : A} {b : AÀ£} (ha : 0 ‚â§ a) (hb : 0 ‚â§ (b : A)) :\n    a ‚â§ b ‚Üî ‚Äñsqrt a * sqrt (‚Üëb‚Åª¬π : A)‚Äñ ‚â§ 1 := by\n  rw [CFC.sqrt_eq_rpow (a := (‚Üëb‚Åª¬π : A)), ‚Üê CFC.rpow_neg_one_eq_inv b,\n    CFC.rpow_rpow (b : A) _ _ (by simp) (by norm_num), le_iff_norm_sqrt_mul_rpow b.isUnit ha hb]\n  norm_num\n\n"}
{"name":"CStarAlgebra.inv_le_inv","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : Units A\nha : LE.le 0 ‚Üëa\nhab : LE.le ‚Üëa ‚Üëb\n‚ä¢ LE.le ‚Üë(Inv.inv b) ‚Üë(Inv.inv a)","decl":"/-- In a unital C‚ãÜ-algebra, if `0 ‚â§ a ‚â§ b` and `a` and `b` are units, then `b‚Åª¬π ‚â§ a‚Åª¬π`. -/\nprotected lemma inv_le_inv {a b : AÀ£} (ha : 0 ‚â§ (a : A))\n    (hab : (a : A) ‚â§ b) : (‚Üëb‚Åª¬π : A) ‚â§ a‚Åª¬π := by\n  have hb := ha.trans hab\n  have hb_inv : (0 : A) ‚â§ b‚Åª¬π := inv_nonneg_of_nonneg b hb\n  have ha_inv : (0 : A) ‚â§ a‚Åª¬π := inv_nonneg_of_nonneg a ha\n  rw [le_iff_norm_sqrt_mul_sqrt_inv ha hb, ‚Üê sq_le_one_iff‚ÇÄ (norm_nonneg _), sq,\n    ‚Üê CStarRing.norm_star_mul_self] at hab\n  rw [le_iff_norm_sqrt_mul_sqrt_inv hb_inv ha_inv, inv_inv, ‚Üê sq_le_one_iff‚ÇÄ (norm_nonneg _), sq,\n    ‚Üê CStarRing.norm_self_mul_star]\n  rwa [star_mul, IsSelfAdjoint.of_nonneg sqrt_nonneg,\n    IsSelfAdjoint.of_nonneg sqrt_nonneg] at hab ‚ä¢\n\n"}
{"name":"CStarAlgebra.inv_le_inv_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : Units A\nha : LE.le 0 ‚Üëa\nhb : LE.le 0 ‚Üëb\n‚ä¢ Iff (LE.le ‚Üë(Inv.inv a) ‚Üë(Inv.inv b)) (LE.le ‚Üëb ‚Üëa)","decl":"/-- In a unital C‚ãÜ-algebra, if `0 ‚â§ a` and `0 ‚â§ b` and `a` and `b` are units, then `a‚Åª¬π ‚â§ b‚Åª¬π`\nif and only if `b ‚â§ a`. -/\nprotected lemma inv_le_inv_iff {a b : AÀ£} (ha : 0 ‚â§ (a : A)) (hb : 0 ‚â§ (b : A)) :\n    (‚Üëa‚Åª¬π : A) ‚â§ b‚Åª¬π ‚Üî (b : A) ‚â§ a :=\n  ‚ü®CStarAlgebra.inv_le_inv (inv_nonneg_of_nonneg a ha), CStarAlgebra.inv_le_inv hb‚ü©\n\n"}
{"name":"CStarAlgebra.inv_le_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : Units A\nha : LE.le 0 ‚Üëa\nhb : LE.le 0 ‚Üëb\n‚ä¢ Iff (LE.le ‚Üë(Inv.inv a) ‚Üëb) (LE.le ‚Üë(Inv.inv b) ‚Üëa)","decl":"lemma inv_le_iff {a b : AÀ£} (ha : 0 ‚â§ (a : A)) (hb : 0 ‚â§ (‚Üëb : A)) :\n    (‚Üëa‚Åª¬π : A) ‚â§ b ‚Üî (‚Üëb‚Åª¬π : A) ‚â§ a := by\n  simpa using CStarAlgebra.inv_le_inv_iff ha (inv_nonneg_of_nonneg b hb)\n\n"}
{"name":"CStarAlgebra.le_inv_iff","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : Units A\nha : LE.le 0 ‚Üëa\nhb : LE.le 0 ‚Üëb\n‚ä¢ Iff (LE.le ‚Üëa ‚Üë(Inv.inv b)) (LE.le ‚Üëb ‚Üë(Inv.inv a))","decl":"lemma le_inv_iff {a b : AÀ£} (ha : 0 ‚â§ (a : A)) (hb : 0 ‚â§ (‚Üëb : A)) :\n    a ‚â§ (‚Üëb‚Åª¬π : A) ‚Üî b ‚â§ (‚Üëa‚Åª¬π : A) := by\n  simpa using CStarAlgebra.inv_le_inv_iff (inv_nonneg_of_nonneg a ha) hb\n\n"}
{"name":"CStarAlgebra.one_le_inv_iff_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : Units A\nha : LE.le 0 ‚Üëa\n‚ä¢ Iff (LE.le 1 ‚Üë(Inv.inv a)) (LE.le a 1)","decl":"lemma one_le_inv_iff_le_one {a : AÀ£} (ha : 0 ‚â§ (a : A)) :\n    1 ‚â§ (‚Üëa‚Åª¬π : A) ‚Üî a ‚â§ 1 := by\n  simpa using CStarAlgebra.le_inv_iff (a := 1) (by simp) ha\n\n"}
{"name":"CStarAlgebra.inv_le_one_iff_one_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : Units A\nha : LE.le 0 ‚Üëa\n‚ä¢ Iff (LE.le (‚Üë(Inv.inv a)) 1) (LE.le 1 a)","decl":"lemma inv_le_one_iff_one_le {a : AÀ£} (ha : 0 ‚â§ (a : A)) :\n    (‚Üëa‚Åª¬π : A) ‚â§ 1 ‚Üî 1 ‚â§ a := by\n  simpa using CStarAlgebra.inv_le_iff ha (b := 1) (by simp)\n\n"}
{"name":"CStarAlgebra.inv_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : Units A\nha : LE.le 1 a\n‚ä¢ LE.le (‚Üë(Inv.inv a)) 1","decl":"lemma inv_le_one {a : AÀ£} (ha : 1 ‚â§ a) : (‚Üëa‚Åª¬π : A) ‚â§ 1 :=\n  CStarAlgebra.inv_le_one_iff_one_le (zero_le_one.trans ha) |>.mpr ha\n\n"}
{"name":"CStarAlgebra.le_one_of_one_le_inv","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : Units A\nha : LE.le 1 ‚Üë(Inv.inv a)\n‚ä¢ LE.le (‚Üëa) 1","decl":"lemma le_one_of_one_le_inv {a : AÀ£} (ha : 1 ‚â§ (‚Üëa‚Åª¬π : A)) : (a : A) ‚â§ 1 := by\n  simpa using CStarAlgebra.inv_le_one ha\n\n"}
{"name":"CStarAlgebra.rpow_neg_one_le_rpow_neg_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nha : LE.le 0 a\nhab : LE.le a b\nhau : IsUnit a\n‚ä¢ LE.le (HPow.hPow b (-1)) (HPow.hPow a (-1))","decl":"lemma rpow_neg_one_le_rpow_neg_one {a b : A} (ha : 0 ‚â§ a) (hab : a ‚â§ b) (hau : IsUnit a) :\n    b ^ (-1 : ‚Ñù) ‚â§ a ^ (-1 : ‚Ñù) := by\n  lift b to AÀ£ using isUnit_of_le hau ha hab\n  lift a to AÀ£ using hau\n  rw [rpow_neg_one_eq_inv a ha, rpow_neg_one_eq_inv b (ha.trans hab)]\n  exact CStarAlgebra.inv_le_inv ha hab\n\n"}
{"name":"CStarAlgebra.rpow_neg_one_le_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : LE.le 1 a\n‚ä¢ LE.le (HPow.hPow a (-1)) 1","decl":"lemma rpow_neg_one_le_one {a : A} (ha : 1 ‚â§ a) : a ^ (-1 : ‚Ñù) ‚â§ 1 := by\n  lift a to AÀ£ using isUnit_of_le isUnit_one zero_le_one ha\n  rw [rpow_neg_one_eq_inv a (zero_le_one.trans ha)]\n  exact inv_le_one ha\n\n"}
{"name":"CStarAlgebra.instNonnegSpectrumClassComplexNonUnital","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬π : NonUnitalCStarAlgebra A\ninst‚úù : PartialOrder A\n‚ä¢ NonnegSpectrumClass Complex A","decl":"open ComplexOrder in\ninstance instNonnegSpectrumClassComplexNonUnital : NonnegSpectrumClass ‚ÑÇ A where\n  quasispectrum_nonneg_of_nonneg a ha x hx := by\n    rw [Unitization.quasispectrum_eq_spectrum_inr' ‚ÑÇ ‚ÑÇ a] at hx\n    exact spectrum_nonneg_of_nonneg (Unitization.inr_nonneg_iff.mpr ha) hx\n\n"}
{"name":"CStarAlgebra.norm_le_norm_of_nonneg_of_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nha : autoParam (LE.le 0 a) _auto‚úù\nhab : LE.le a b\n‚ä¢ LE.le (Norm.norm a) (Norm.norm b)","decl":"lemma norm_le_norm_of_nonneg_of_le {a b : A} (ha : 0 ‚â§ a := by cfc_tac) (hab : a ‚â§ b) :\n    ‚Äña‚Äñ ‚â§ ‚Äñb‚Äñ := by\n  suffices ‚àÄ a b : A‚Å∫¬π, 0 ‚â§ a ‚Üí a ‚â§ b ‚Üí ‚Äña‚Äñ ‚â§ ‚Äñb‚Äñ by\n    have hb := ha.trans hab\n    simpa only [ge_iff_le, Unitization.norm_inr] using\n      this a b (by simpa) (by rwa [Unitization.inr_le_iff a b])\n  intro a b ha hab\n  have hb : 0 ‚â§ b := ha.trans hab\n  -- these two `have`s are just for performance\n  have := IsSelfAdjoint.of_nonneg ha; have := IsSelfAdjoint.of_nonneg hb\n  have h‚ÇÇ : cfc (id : ‚Ñù ‚Üí ‚Ñù) a ‚â§ cfc (fun _ => ‚Äñb‚Äñ) a := by\n    calc _ = a := by rw [cfc_id ‚Ñù a]\n      _ ‚â§ cfc id b := (cfc_id ‚Ñù b) ‚ñ∏ hab\n      _ ‚â§ cfc (fun _ => ‚Äñb‚Äñ) b := by\n          refine cfc_mono fun x hx => ?_\n          calc x = ‚Äñx‚Äñ := (Real.norm_of_nonneg (spectrum_nonneg_of_nonneg hb hx)).symm\n            _ ‚â§ ‚Äñb‚Äñ := spectrum.norm_le_norm_of_mem hx\n      _ = _ := by rw [cfc_const _ _, cfc_const _ _]\n  rw [cfc_le_iff id (fun _ => ‚Äñb‚Äñ) a] at h‚ÇÇ\n  exact h‚ÇÇ ‚Äña‚Äñ <| norm_mem_spectrum_of_nonneg ha\n\n"}
{"name":"CStarAlgebra.nnnorm_le_nnnorm_of_nonneg_of_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nha : autoParam (LE.le 0 a) _auto‚úù\nhab : LE.le a b\n‚ä¢ LE.le (NNNorm.nnnorm a) (NNNorm.nnnorm b)","decl":"theorem nnnorm_le_nnnorm_of_nonneg_of_le {a : A} {b : A} (ha : 0 ‚â§ a := by cfc_tac) (hab : a ‚â§ b) :\n    ‚Äña‚Äñ‚Çä ‚â§ ‚Äñb‚Äñ‚Çä :=\n  norm_le_norm_of_nonneg_of_le ha hab\n\n"}
{"name":"CStarAlgebra.conjugate_le_norm_smul","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nhb : autoParam (IsSelfAdjoint b) _auto‚úù\n‚ä¢ LE.le (HMul.hMul (HMul.hMul (Star.star a) b) a) (HSMul.hSMul (Norm.norm b) (HMul.hMul (Star.star a) a))","decl":"lemma conjugate_le_norm_smul {a b : A} (hb : IsSelfAdjoint b := by cfc_tac) :\n    star a * b * a ‚â§ ‚Äñb‚Äñ ‚Ä¢ (star a * a) := by\n  suffices ‚àÄ a b : A‚Å∫¬π, IsSelfAdjoint b ‚Üí star a * b * a ‚â§ ‚Äñb‚Äñ ‚Ä¢ (star a * a) by\n    rw [‚Üê Unitization.inr_le_iff _ _ (by aesop) ((IsSelfAdjoint.all _).smul (.star_mul_self a))]\n    simpa [Unitization.norm_inr] using this a b <| hb.inr ‚ÑÇ\n  intro a b hb\n  calc\n    star a * b * a ‚â§ star a * (algebraMap ‚Ñù A‚Å∫¬π ‚Äñb‚Äñ) * a :=\n      conjugate_le_conjugate hb.le_algebraMap_norm_self _\n    _ = ‚Äñb‚Äñ ‚Ä¢ (star a * a) := by simp [Algebra.algebraMap_eq_smul_one]\n\n"}
{"name":"CStarAlgebra.conjugate_le_norm_smul'","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na b : A\nhb : autoParam (IsSelfAdjoint b) _auto‚úù\n‚ä¢ LE.le (HMul.hMul (HMul.hMul a b) (Star.star a)) (HSMul.hSMul (Norm.norm b) (HMul.hMul a (Star.star a)))","decl":"lemma conjugate_le_norm_smul' {a b : A} (hb : IsSelfAdjoint b := by cfc_tac) :\n    a * b * star a ‚â§ ‚Äñb‚Äñ ‚Ä¢ (a * star a) := by\n  have h‚ÇÅ : a * b * star a = star (star a) * b * star a := by simp\n  have h‚ÇÇ : a * star a = star (star a) * star a := by simp\n  simp only [h‚ÇÅ, h‚ÇÇ]\n  exact conjugate_le_norm_smul\n\n"}
{"name":"CStarAlgebra.isClosed_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ IsClosed (setOf fun a => LE.le 0 a)","decl":"/-- The set of nonnegative elements in a C‚ãÜ-algebra is closed. -/\nlemma isClosed_nonneg : IsClosed {a : A | 0 ‚â§ a} := by\n  suffices IsClosed {a : A‚Å∫¬π | 0 ‚â§ a} by\n    rw [Unitization.isometry_inr (ùïú := ‚ÑÇ) |>.isClosedEmbedding.isClosed_iff_image_isClosed]\n    convert this.inter <| (Unitization.isometry_inr (ùïú := ‚ÑÇ)).isClosedEmbedding.isClosed_range\n    ext a\n    simp only [Set.mem_image, Set.mem_setOf_eq, Set.mem_inter_iff, Set.mem_range, ‚Üê exists_and_left]\n    congr! 2 with x\n    exact and_congr_left fun h ‚Ü¶ by simp [‚Üê h]\n  simp only [nonneg_iff_isSelfAdjoint_and_spectrumRestricts,\n    and_congr_right (SpectrumRestricts.nnreal_iff_nnnorm ¬∑ le_rfl), Set.setOf_and]\n  refine isClosed_eq ?_ ?_ |>.inter <| isClosed_le ?_ ?_\n  all_goals fun_prop\n\n"}
{"name":"CStarAlgebra.instOrderClosedTopology","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ OrderClosedTopology A","decl":"instance : OrderClosedTopology A where\n  isClosed_le' := isClosed_le_of_isClosed_nonneg isClosed_nonneg\n\n"}
{"name":"CStarAlgebra.inr_mem_Icc_iff_norm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx : A\n‚ä¢ Iff (Membership.mem (Set.Icc 0 1) ‚Üëx) (And (LE.le 0 x) (LE.le (Norm.norm x) 1))","decl":"lemma inr_mem_Icc_iff_norm_le {x : A} :\n    (x : A‚Å∫¬π) ‚àà Icc 0 1 ‚Üî 0 ‚â§ x ‚àß ‚Äñx‚Äñ ‚â§ 1 := by\n  simp only [mem_Icc, inr_nonneg_iff, and_congr_right_iff]\n  rw [‚Üê norm_inr (ùïú := ‚ÑÇ), ‚Üê inr_nonneg_iff, iff_comm]\n  exact (norm_le_one_iff_of_nonneg _ ¬∑)\n\n"}
{"name":"CStarAlgebra.inr_mem_Icc_iff_nnnorm_le","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\nx : A\n‚ä¢ Iff (Membership.mem (Set.Icc 0 1) ‚Üëx) (And (LE.le 0 x) (LE.le (NNNorm.nnnorm x) 1))","decl":"lemma inr_mem_Icc_iff_nnnorm_le {x : A} :\n    (x : A‚Å∫¬π) ‚àà Icc 0 1 ‚Üî 0 ‚â§ x ‚àß ‚Äñx‚Äñ‚Çä ‚â§ 1 :=\n  inr_mem_Icc_iff_norm_le\n\n"}
{"name":"CStarAlgebra.preimage_inr_Icc_zero_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : NonUnitalCStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\n‚ä¢ Eq (Set.preimage Unitization.inr (Set.Icc 0 1)) (Inter.inter (setOf fun x => LE.le 0 x) (Metric.closedBall 0 1))","decl":"lemma preimage_inr_Icc_zero_one :\n    ((‚Üë) : A ‚Üí A‚Å∫¬π) ‚Åª¬π' Icc 0 1 = {x : A | 0 ‚â§ x} ‚à© closedBall 0 1 := by\n  ext\n  simp [- mem_Icc, inr_mem_Icc_iff_norm_le]\n\n"}
{"name":"CStarAlgebra.pow_nonneg","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : autoParam (LE.le 0 a) _auto‚úù\nn : Nat\n‚ä¢ LE.le 0 (HPow.hPow a n)","decl":"lemma pow_nonneg {a : A} (ha : 0 ‚â§ a := by cfc_tac) (n : ‚Ñï) : 0 ‚â§ a ^ n := by\n  rw [‚Üê cfc_pow_id (R := ‚Ñù‚â•0) a]\n  exact cfc_nonneg_of_predicate\n\n"}
{"name":"CStarAlgebra.pow_monotone","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha : LE.le 1 a\n‚ä¢ Monotone fun x => HPow.hPow a x","decl":"lemma pow_monotone {a : A} (ha : 1 ‚â§ a) : Monotone (a ^ ¬∑ : ‚Ñï ‚Üí A) := by\n  have ha' : 0 ‚â§ a := zero_le_one.trans ha\n  intro n m hnm\n  simp only\n  rw [‚Üê cfc_pow_id (R := ‚Ñù) a, ‚Üê cfc_pow_id (R := ‚Ñù) a, cfc_le_iff ..]\n  rw [CFC.one_le_iff (R := ‚Ñù) a] at ha\n  peel ha with x hx _\n  exact pow_le_pow_right‚ÇÄ (ha x hx) hnm\n\n"}
{"name":"CStarAlgebra.pow_antitone","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Order","initialProofState":"A : Type u_1\ninst‚úù¬≤ : CStarAlgebra A\ninst‚úù¬π : PartialOrder A\ninst‚úù : StarOrderedRing A\na : A\nha‚ÇÄ : autoParam (LE.le 0 a) _auto‚úù\nha‚ÇÅ : LE.le a 1\n‚ä¢ Antitone fun x => HPow.hPow a x","decl":"lemma pow_antitone {a : A} (ha‚ÇÄ : 0 ‚â§ a := by cfc_tac) (ha‚ÇÅ : a ‚â§ 1) :\n    Antitone (a ^ ¬∑ : ‚Ñï ‚Üí A) := by\n  intro n m hnm\n  simp only\n  rw [‚Üê cfc_pow_id (R := ‚Ñù) a, ‚Üê cfc_pow_id (R := ‚Ñù) a, cfc_le_iff ..]\n  rw [CFC.le_one_iff (R := ‚Ñù) a] at ha‚ÇÅ\n  peel ha‚ÇÅ with x hx _\n  exact pow_le_pow_of_le_one (spectrum_nonneg_of_nonneg ha‚ÇÄ hx) (ha‚ÇÅ x hx) hnm\n\n"}
