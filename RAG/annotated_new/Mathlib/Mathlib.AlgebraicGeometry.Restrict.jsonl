{"name":"AlgebraicGeometry.Scheme.Opens.ι_base_apply","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : Subtype fun x => Membership.mem U x\n⊢ Eq (U.ι.base x) ↑x","decl":"@[simp]\nlemma ι_base_apply (x : U) : U.ι.base x = x.val := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.instIsOpenImmersionι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ AlgebraicGeometry.IsOpenImmersion U.ι","decl":"instance : IsOpenImmersion U.ι := inferInstanceAs (IsOpenImmersion (X.ofRestrict _))\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.instCanonicallyOver_over","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (CategoryTheory.over (↑U) X inferInstance) U.ι","decl":"@[simps! over] instance : U.toScheme.CanonicallyOver X where\n  hom := U.ι\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.instIsOverι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ AlgebraicGeometry.Scheme.Hom.IsOver U.ι X","decl":"instance (U : X.Opens) : U.ι.IsOver X where\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toScheme_carrier","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq ↑↑(↑U).toPresheafedSpace ↑↑U","decl":"lemma toScheme_carrier : (U : Type u) = (U : Set X) := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toScheme_presheaf_obj","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : (↑U).Opens\n⊢ Eq ((↑U).presheaf.obj { unop := V }) (X.presheaf.obj { unop := (AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V })","decl":"lemma toScheme_presheaf_obj (V) : Γ(U, V) = Γ(X, U.ι ''ᵁ V) := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.toScheme_presheaf_map","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV W : Opposite (TopologicalSpace.Opens ↑↑(↑U).toPresheafedSpace)\ni : Quiver.Hom V W\n⊢ Eq ((↑U).presheaf.map i) (X.presheaf.map ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).map i.unop).op)","decl":"@[simp]\nlemma toScheme_presheaf_map {V W} (i : V ⟶ W) :\n    U.toScheme.presheaf.map i = X.presheaf.map (U.ι.opensFunctor.map i.unop).op := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_app","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app U.ι V) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[simp]\nlemma ι_app (V) : U.ι.app V = X.presheaf.map\n    (homOfLE (x := U.ι ''ᵁ U.ι ⁻¹ᵁ V) (Set.image_preimage_subset _ _)).op :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_appTop","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop U.ι) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[simp]\nlemma ι_appTop :\n    U.ι.appTop = X.presheaf.map (homOfLE (x := U.ι ''ᵁ ⊤) le_top).op :=\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_appLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nW : (↑U).Opens\ne : LE.le W ((TopologicalSpace.Opens.map U.ι.base).obj V)\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appLE U.ι V W e) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[simp]\nlemma ι_appLE (V W e) :\n    U.ι.appLE V W e =\n      X.presheaf.map (homOfLE (x := U.ι ''ᵁ W) (Set.image_subset_iff.mpr ‹_›)).op := by\n  simp only [Hom.appLE, ι_app, Functor.op_obj, Opens.carrier_eq_coe, toScheme_presheaf_map,\n    Quiver.Hom.unop_op, Hom.opensFunctor_map_homOfLE, Opens.coe_inclusion', ← Functor.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_appIso","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : (↑U).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appIso U.ι V) (CategoryTheory.Iso.refl (X.presheaf.obj { unop := (AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V }))","decl":"@[simp]\nlemma ι_appIso (V) : U.ι.appIso V = Iso.refl _ :=\n  X.ofRestrict_appIso _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.opensRange_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.opensRange U.ι) U","decl":"@[simp]\nlemma opensRange_ι : U.ι.opensRange = U :=\n  Opens.ext Subtype.range_val\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.range_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (Set.range ⇑U.ι.base) ↑U","decl":"@[simp]\nlemma range_ι : Set.range U.ι.base = U :=\n  Subtype.range_val\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_image_top","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj Top.top) U","decl":"lemma ι_image_top : U.ι ''ᵁ ⊤ = U :=\n  U.isOpenEmbedding_obj_top\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_image_le","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nW : (↑U).Opens\n⊢ LE.le ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj W) U","decl":"lemma ι_image_le (W : U.toScheme.Opens) : U.ι ''ᵁ W ≤ U := by\n  simp_rw [← U.ι_image_top]\n  exact U.ι.image_le_image_of_le le_top\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_preimage_self","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq ((TopologicalSpace.Opens.map U.ι.base).obj U) Top.top","decl":"@[simp]\nlemma ι_preimage_self : U.ι ⁻¹ᵁ U = ⊤ :=\n  Opens.inclusion'_map_eq_top _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_appLE_isIso","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.Scheme.Hom.appLE U.ι U Top.top ⋯)","decl":"instance ι_appLE_isIso :\n    IsIso (U.ι.appLE U ⊤ U.ι_preimage_self.ge) := by\n  simp only [ι, ofRestrict_appLE]\n  show IsIso (X.presheaf.map (eqToIso U.ι_image_top).hom.op)\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_app_self","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app U.ι U) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)","decl":"lemma ι_app_self : U.ι.app U = X.presheaf.map (eqToHom (X := U.ι ''ᵁ _) (by simp)).op := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.eq_presheaf_map_eqToHom","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV W : (↑U).Opens\ne : Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj W)\n⊢ Eq (X.presheaf.map (CategoryTheory.eqToHom e).op) ((↑U).presheaf.map (CategoryTheory.eqToHom ⋯).op)","decl":"lemma eq_presheaf_map_eqToHom {V W : Opens U} (e : U.ι ''ᵁ V = U.ι ''ᵁ W) :\n    X.presheaf.map (eqToHom e).op =\n      U.toScheme.presheaf.map (eqToHom <| U.isOpenEmbedding.functor_obj_injective e).op := rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.nonempty_iff","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Iff (Nonempty ↑↑(↑U).toPresheafedSpace) (↑U).Nonempty","decl":"@[simp]\nlemma nonempty_iff : Nonempty U.toScheme ↔ (U : Set X).Nonempty := by\n  simp only [toScheme_carrier, SetLike.coe_sort_coe, nonempty_subtype]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.topIso_hom","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq U.topIso.hom (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)","decl":"attribute [-simp] eqToHom_op in\n/-- The global sections of the restriction is isomorphic to the sections on the open set. -/\n@[simps!]\ndef topIso : Γ(U, ⊤) ≅ Γ(X, U) :=\n  X.presheaf.mapIso (eqToIso U.ι_image_top.symm).op\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.topIso_inv","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq U.topIso.inv (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)","decl":"attribute [-simp] eqToHom_op in\n/-- The global sections of the restriction is isomorphic to the sections on the open set. -/\n@[simps!]\ndef topIso : Γ(U, ⊤) ≅ Γ(X, U) :=\n  X.presheaf.mapIso (eqToIso U.ι_image_top.symm).op\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.germ_stalkIso_hom","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : (↑U).Opens\nx : Subtype fun x => Membership.mem U x\nhx : Membership.mem V x\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((↑U).presheaf.germ V x hx) (U.stalkIso x).hom) (X.presheaf.germ ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ↑x ⋯)","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkIso_hom {X : Scheme.{u}} (U : X.Opens)\n    {V : U.toScheme.Opens} (x : U) (hx : x ∈ V) :\n      U.toScheme.presheaf.germ V x hx ≫ (U.stalkIso x).hom =\n        X.presheaf.germ (U.ι ''ᵁ V) x.1 ⟨x, hx, rfl⟩ :=\n    PresheafedSpace.restrictStalkIso_hom_eq_germ _ U.isOpenEmbedding _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.germ_stalkIso_hom_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : (↑U).Opens\nx : Subtype fun x => Membership.mem U x\nhx : Membership.mem V x\nZ : CommRingCat\nh : Quiver.Hom (X.presheaf.stalk ↑x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((↑U).presheaf.germ V x hx) (CategoryTheory.CategoryStruct.comp (U.stalkIso x).hom h)) (CategoryTheory.CategoryStruct.comp (X.presheaf.germ ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ↑x ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma germ_stalkIso_hom {X : Scheme.{u}} (U : X.Opens)\n    {V : U.toScheme.Opens} (x : U) (hx : x ∈ V) :\n      U.toScheme.presheaf.germ V x hx ≫ (U.stalkIso x).hom =\n        X.presheaf.germ (U.ι ''ᵁ V) x.1 ⟨x, hx, rfl⟩ :=\n    PresheafedSpace.restrictStalkIso_hom_eq_germ _ U.isOpenEmbedding _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.germ_stalkIso_inv_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : (↑U).Opens\nx : Subtype fun x => Membership.mem U x\nhx : Membership.mem V x\nZ : CommRingCat\nh : Quiver.Hom ((↑U).presheaf.stalk x) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ↑x ⋯) (CategoryTheory.CategoryStruct.comp (U.stalkIso x).inv h)) (CategoryTheory.CategoryStruct.comp ((↑U).presheaf.germ V x hx) h)","decl":"@[reassoc]\nlemma germ_stalkIso_inv {X : Scheme.{u}} (U : X.Opens) (V : U.toScheme.Opens) (x : U)\n    (hx : x ∈ V) : X.presheaf.germ (U.ι ''ᵁ V) x ⟨x, hx, rfl⟩ ≫\n      (U.stalkIso x).inv = U.toScheme.presheaf.germ V x hx :=\n  PresheafedSpace.restrictStalkIso_inv_eq_germ X.toPresheafedSpace U.isOpenEmbedding V x hx\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.germ_stalkIso_inv","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nV : (↑U).Opens\nx : Subtype fun x => Membership.mem U x\nhx : Membership.mem V x\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.presheaf.germ ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ↑x ⋯) (U.stalkIso x).inv) ((↑U).presheaf.germ V x hx)","decl":"@[reassoc]\nlemma germ_stalkIso_inv {X : Scheme.{u}} (U : X.Opens) (V : U.toScheme.Opens) (x : U)\n    (hx : x ∈ V) : X.presheaf.germ (U.ι ''ᵁ V) x ⟨x, hx, rfl⟩ ≫\n      (U.stalkIso x).inv = U.toScheme.presheaf.germ V x hx :=\n  PresheafedSpace.restrictStalkIso_inv_eq_germ X.toPresheafedSpace U.isOpenEmbedding V x hx\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.stalkIso_inv","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nx : Subtype fun x => Membership.mem U x\n⊢ Eq (U.stalkIso x).inv (AlgebraicGeometry.Scheme.Hom.stalkMap U.ι x)","decl":"lemma stalkIso_inv {X : Scheme.{u}} (U : X.Opens) (x : U) :\n    (U.stalkIso x).inv = U.ι.stalkMap x := by\n  rw [← Category.comp_id (U.stalkIso x).inv, Iso.inv_comp_eq]\n  apply TopCat.Presheaf.stalk_hom_ext\n  intro W hxW\n  simp only [Category.comp_id, U.germ_stalkIso_hom_assoc]\n  convert (Scheme.stalkMap_germ U.ι (U.ι ''ᵁ W) x ⟨_, hxW, rfl⟩).symm\n  refine (U.toScheme.presheaf.germ_res (homOfLE ?_) _ _).symm\n  exact (Set.preimage_image_eq _ Subtype.val_injective).le\n\n"}
{"name":"AlgebraicGeometry.Scheme.openCoverOfISupEqTop_J","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"s : Type u_1\nX : AlgebraicGeometry.Scheme\nU : s → X.Opens\nhU : Eq (iSup fun i => U i) Top.top\n⊢ Eq (X.openCoverOfISupEqTop U hU).J s","decl":"/-- If `U` is a family of open sets that covers `X`, then `X.restrict U` forms an `X.open_cover`. -/\n@[simps! J obj map]\ndef Scheme.openCoverOfISupEqTop {s : Type*} (X : Scheme.{u}) (U : s → X.Opens)\n    (hU : ⨆ i, U i = ⊤) : X.OpenCover where\n  J := s\n  obj i := U i\n  map i := (U i).ι\n  f x :=\n    haveI : x ∈ ⨆ i, U i := hU.symm ▸ show x ∈ (⊤ : X.Opens) by trivial\n    (Opens.mem_iSup.mp this).choose\n  covers x := by\n    erw [Subtype.range_coe]\n    have : x ∈ ⨆ i, U i := hU.symm ▸ show x ∈ (⊤ : X.Opens) by trivial\n    exact (Opens.mem_iSup.mp this).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.openCoverOfISupEqTop_map","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"s : Type u_1\nX : AlgebraicGeometry.Scheme\nU : s → X.Opens\nhU : Eq (iSup fun i => U i) Top.top\ni : s\n⊢ Eq ((X.openCoverOfISupEqTop U hU).map i) (U i).ι","decl":"/-- If `U` is a family of open sets that covers `X`, then `X.restrict U` forms an `X.open_cover`. -/\n@[simps! J obj map]\ndef Scheme.openCoverOfISupEqTop {s : Type*} (X : Scheme.{u}) (U : s → X.Opens)\n    (hU : ⨆ i, U i = ⊤) : X.OpenCover where\n  J := s\n  obj i := U i\n  map i := (U i).ι\n  f x :=\n    haveI : x ∈ ⨆ i, U i := hU.symm ▸ show x ∈ (⊤ : X.Opens) by trivial\n    (Opens.mem_iSup.mp this).choose\n  covers x := by\n    erw [Subtype.range_coe]\n    have : x ∈ ⨆ i, U i := hU.symm ▸ show x ∈ (⊤ : X.Opens) by trivial\n    exact (Opens.mem_iSup.mp this).choose_spec\n\n"}
{"name":"AlgebraicGeometry.Scheme.openCoverOfISupEqTop_obj","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"s : Type u_1\nX : AlgebraicGeometry.Scheme\nU : s → X.Opens\nhU : Eq (iSup fun i => U i) Top.top\ni : s\n⊢ Eq ((X.openCoverOfISupEqTop U hU).obj i) ↑(U i)","decl":"/-- If `U` is a family of open sets that covers `X`, then `X.restrict U` forms an `X.open_cover`. -/\n@[simps! J obj map]\ndef Scheme.openCoverOfISupEqTop {s : Type*} (X : Scheme.{u}) (U : s → X.Opens)\n    (hU : ⨆ i, U i = ⊤) : X.OpenCover where\n  J := s\n  obj i := U i\n  map i := (U i).ι\n  f x :=\n    haveI : x ∈ ⨆ i, U i := hU.symm ▸ show x ∈ (⊤ : X.Opens) by trivial\n    (Opens.mem_iSup.mp this).choose\n  covers x := by\n    erw [Subtype.range_coe]\n    have : x ∈ ⨆ i, U i := hU.symm ▸ show x ∈ (⊤ : X.Opens) by trivial\n    exact (Opens.mem_iSup.mp this).choose_spec\n\n"}
{"name":"AlgebraicGeometry.coe_opensRestrict_symm_apply","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\na✝ : Subtype fun V => LE.le V U\n⊢ Eq (↑((AlgebraicGeometry.opensRestrict U).symm a✝)) (Set.preimage ⇑U.ι.base ↑↑((Equiv.subtypeEquivProp ⋯).symm a✝))","decl":"/-- The open sets of an open subscheme corresponds to the open sets containing in the subset. -/\n@[simps!]\ndef opensRestrict :\n    Scheme.Opens U ≃ { V : X.Opens // V ≤ U } :=\n  (IsOpenImmersion.opensEquiv (U.ι)).trans (Equiv.subtypeEquivProp (by simp))\n\n"}
{"name":"AlgebraicGeometry.coe_opensRestrict_apply_coe","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\na✝ : (↑U).Opens\n⊢ Eq (↑↑((AlgebraicGeometry.opensRestrict U) a✝)) (Set.image (fun a => ↑a) ↑a✝)","decl":"/-- The open sets of an open subscheme corresponds to the open sets containing in the subset. -/\n@[simps!]\ndef opensRestrict :\n    Scheme.Opens U ≃ { V : X.Opens // V ≤ U } :=\n  (IsOpenImmersion.opensEquiv (U.ι)).trans (Equiv.subtypeEquivProp (by simp))\n\n"}
{"name":"AlgebraicGeometry.Scheme.map_basicOpen","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nr : ↑((↑U).presheaf.obj { unop := Top.top })\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj ((↑U).basicOpen r)) (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)) r))","decl":"lemma Scheme.map_basicOpen (r : Γ(U, ⊤)) :\n    U.ι ''ᵁ U.toScheme.basicOpen r = X.basicOpen\n      (X.presheaf.map (eqToHom U.isOpenEmbedding_obj_top.symm).op r) := by\n  refine (Scheme.image_basicOpen (X.ofRestrict U.isOpenEmbedding) r).trans ?_\n  rw [← Scheme.basicOpen_res_eq _ _ (eqToHom U.isOpenEmbedding_obj_top).op]\n  rw [← CommRingCat.comp_apply, ← CategoryTheory.Functor.map_comp, ← op_comp, eqToHom_trans,\n    eqToHom_refl, op_id, CategoryTheory.Functor.map_id]\n  congr\n  exact PresheafedSpace.IsOpenImmersion.ofRestrict_invApp _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.map_basicOpen'","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nr : ↑((↑U).presheaf.obj { unop := Top.top })\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj ((↑U).basicOpen r)) (X.basicOpen ((CategoryTheory.ConcreteCategory.hom (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)) r))","decl":"@[deprecated (since := \"2024-10-23\")] alias Scheme.map_basicOpen' := Scheme.map_basicOpen\n\n"}
{"name":"AlgebraicGeometry.Scheme.Opens.ι_image_basicOpen","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nr : ↑((↑U).presheaf.obj { unop := Top.top })\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj ((↑U).basicOpen r)) (X.basicOpen r)","decl":"lemma Scheme.Opens.ι_image_basicOpen (r : Γ(U, ⊤)) :\n    U.ι ''ᵁ U.toScheme.basicOpen r = X.basicOpen r := by\n  rw [Scheme.map_basicOpen, Scheme.basicOpen_res_eq]\n\n"}
{"name":"AlgebraicGeometry.Scheme.map_basicOpen_map","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\nr : ↑(X.presheaf.obj { unop := U })\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj ((↑U).basicOpen ((CategoryTheory.ConcreteCategory.hom U.topIso.inv) r))) (X.basicOpen r)","decl":"lemma Scheme.map_basicOpen_map (r : Γ(X, U)) :\n    U.ι ''ᵁ (U.toScheme.basicOpen <| U.topIso.inv r) = X.basicOpen r := by\n  simp only [Scheme.Opens.toScheme_presheaf_obj]\n  rw [Scheme.map_basicOpen, Scheme.basicOpen_res_eq, Scheme.Opens.topIso_inv,\n    Scheme.basicOpen_res_eq X]\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE e) V.ι) U.ι","decl":"@[reassoc (attr := simp)]\nlemma Scheme.homOfLE_ι (X : Scheme.{u}) {U V : X.Opens} (e : U ≤ V) :\n    X.homOfLE e ≫ V.ι = U.ι :=\n  IsOpenImmersion.lift_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE e) (CategoryTheory.CategoryStruct.comp V.ι h)) (CategoryTheory.CategoryStruct.comp U.ι h)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.homOfLE_ι (X : Scheme.{u}) {U V : X.Opens} (e : U ≤ V) :\n    X.homOfLE e ≫ V.ι = U.ι :=\n  IsOpenImmersion.lift_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.instIsOverHomOfLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\nh : LE.le U V\n⊢ AlgebraicGeometry.Scheme.Hom.IsOver (X.homOfLE h) X","decl":"instance {U V : X.Opens} (h : U ≤ V) : (X.homOfLE h).IsOver X where\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_rfl","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.homOfLE ⋯) (CategoryTheory.CategoryStruct.id ↑U)","decl":"@[simp]\nlemma Scheme.homOfLE_rfl (X : Scheme.{u}) (U : X.Opens) : X.homOfLE (refl U) = 𝟙 _ := by\n  rw [← cancel_mono U.ι, Scheme.homOfLE_ι, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_homOfLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V W : X.Opens\ne₁ : LE.le U V\ne₂ : LE.le V W\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE e₁) (X.homOfLE e₂)) (X.homOfLE ⋯)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.homOfLE_homOfLE (X : Scheme.{u}) {U V W : X.Opens} (e₁ : U ≤ V) (e₂ : V ≤ W) :\n    X.homOfLE e₁ ≫ X.homOfLE e₂ = X.homOfLE (e₁.trans e₂) := by\n  rw [← cancel_mono W.ι, Category.assoc, Scheme.homOfLE_ι, Scheme.homOfLE_ι, Scheme.homOfLE_ι]\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_homOfLE_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V W : X.Opens\ne₁ : LE.le U V\ne₂ : LE.le V W\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (↑W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE e₁) (CategoryTheory.CategoryStruct.comp (X.homOfLE e₂) h)) (CategoryTheory.CategoryStruct.comp (X.homOfLE ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.homOfLE_homOfLE (X : Scheme.{u}) {U V W : X.Opens} (e₁ : U ≤ V) (e₂ : V ≤ W) :\n    X.homOfLE e₁ ≫ X.homOfLE e₂ = X.homOfLE (e₁.trans e₂) := by\n  rw [← cancel_mono W.ι, Category.assoc, Scheme.homOfLE_ι, Scheme.homOfLE_ι, Scheme.homOfLE_ι]\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_base","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\n⊢ Eq (X.homOfLE e).base ((TopologicalSpace.Opens.toTopCat ↑X.toPresheafedSpace).map (CategoryTheory.homOfLE e))","decl":"theorem Scheme.homOfLE_base {U V : X.Opens} (e : U ≤ V) :\n    (X.homOfLE e).base = (Opens.toTopCat _).map (homOfLE e) := by\n  ext a; refine Subtype.ext ?_ -- Porting note: `ext` did not pick up `Subtype.ext`\n  exact congr($(X.homOfLE_ι e).base a)\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_apply","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nx : Subtype fun x => Membership.mem U x\n⊢ Eq ↑((X.homOfLE e).base x) ↑x","decl":"@[simp]\ntheorem Scheme.homOfLE_apply {U V : X.Opens} (e : U ≤ V) (x : U) :\n    ((X.homOfLE e).base x).1 = x := by\n  rw [homOfLE_base]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.ι_image_homOfLE_le_ι_image","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nW : (↑V).Opens\n⊢ LE.le ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj ((TopologicalSpace.Opens.map (X.homOfLE e).base).obj W)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor V.ι).obj W)","decl":"theorem Scheme.ι_image_homOfLE_le_ι_image {U V : X.Opens} (e : U ≤ V) (W : Opens V) :\n    U.ι ''ᵁ (X.homOfLE e ⁻¹ᵁ W) ≤ V.ι ''ᵁ W := by\n  simp only [← SetLike.coe_subset_coe, IsOpenMap.coe_functor_obj, Set.image_subset_iff,\n    Scheme.homOfLE_base, Opens.map_coe, Opens.inclusion'_apply]\n  rintro _ h\n  exact ⟨_, h, rfl⟩\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_app","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nW : (↑V).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (X.homOfLE e) W) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[simp]\ntheorem Scheme.homOfLE_app {U V : X.Opens} (e : U ≤ V) (W : Opens V) :\n    (X.homOfLE e).app W =\n      X.presheaf.map (homOfLE <| X.ι_image_homOfLE_le_ι_image e W).op := by\n  have e₁ := Scheme.congr_app (X.homOfLE_ι e) (V.ι ''ᵁ W)\n  have : V.ι ⁻¹ᵁ V.ι ''ᵁ W = W := W.map_functor_eq (U := V)\n  have e₂ := (X.homOfLE e).naturality (eqToIso this).hom.op\n  have e₃ := e₂.symm.trans e₁\n  dsimp at e₃ ⊢\n  rw [← IsIso.eq_comp_inv, ← Functor.map_inv, ← Functor.map_comp] at e₃\n  rw [e₃, ← Functor.map_comp]\n  congr 1\n\n"}
{"name":"AlgebraicGeometry.Scheme.homOfLE_appTop","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (X.homOfLE e)) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"theorem Scheme.homOfLE_appTop {U V : X.Opens} (e : U ≤ V) :\n    (X.homOfLE e).appTop =\n      X.presheaf.map (homOfLE <| X.ι_image_homOfLE_le_ι_image e ⊤).op :=\n  homOfLE_app ..\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionHomOfLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\n⊢ AlgebraicGeometry.IsOpenImmersion (X.homOfLE e)","decl":"instance (X : Scheme.{u}) {U V : X.Opens} (e : U ≤ V) : IsOpenImmersion (X.homOfLE e) := by\n  delta Scheme.homOfLE\n  infer_instance\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_obj_left","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.restrictFunctor.obj U).left ↑U","decl":"variable (X) in\n/-- The functor taking open subsets of `X` to open subschemes of `X`. -/\n@[simps! obj_left obj_hom map_left]\ndef Scheme.restrictFunctor : X.Opens ⥤ Over X where\n  obj U := Over.mk U.ι\n  map {U V} i := Over.homMk (X.homOfLE i.le) (by simp)\n  map_id U := by\n    ext1\n    exact Scheme.homOfLE_rfl _ _\n  map_comp {U V W} i j := by\n    ext1\n    exact (X.homOfLE_homOfLE i.le j.le).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_map_left","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ni : Quiver.Hom U V\n⊢ Eq (X.restrictFunctor.map i).left (X.homOfLE ⋯)","decl":"variable (X) in\n/-- The functor taking open subsets of `X` to open subschemes of `X`. -/\n@[simps! obj_left obj_hom map_left]\ndef Scheme.restrictFunctor : X.Opens ⥤ Over X where\n  obj U := Over.mk U.ι\n  map {U V} i := Over.homMk (X.homOfLE i.le) (by simp)\n  map_id U := by\n    ext1\n    exact Scheme.homOfLE_rfl _ _\n  map_comp {U V W} i j := by\n    ext1\n    exact (X.homOfLE_homOfLE i.le j.le).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_obj_hom","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.restrictFunctor.obj U).hom U.ι","decl":"variable (X) in\n/-- The functor taking open subsets of `X` to open subschemes of `X`. -/\n@[simps! obj_left obj_hom map_left]\ndef Scheme.restrictFunctor : X.Opens ⥤ Over X where\n  obj U := Over.mk U.ι\n  map {U V} i := Over.homMk (X.homOfLE i.le) (by simp)\n  map_id U := by\n    ext1\n    exact Scheme.homOfLE_rfl _ _\n  map_comp {U V W} i j := by\n    ext1\n    exact (X.homOfLE_homOfLE i.le j.le).symm\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_map_ofRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE e) V.ι) U.ι","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictFunctor_map_ofRestrict := Scheme.homOfLE_ι\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_map_ofRestrict_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE e) (CategoryTheory.CategoryStruct.comp V.ι h)) (CategoryTheory.CategoryStruct.comp U.ι h)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictFunctor_map_ofRestrict_assoc := Scheme.homOfLE_ι_assoc\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_map_base","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\n⊢ Eq (X.homOfLE e).base ((TopologicalSpace.Opens.toTopCat ↑X.toPresheafedSpace).map (CategoryTheory.homOfLE e))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictFunctor_map_base := Scheme.homOfLE_base\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_map_app_aux","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nW : (↑V).Opens\n⊢ LE.le ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj ((TopologicalSpace.Opens.map (X.homOfLE e).base).obj W)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor V.ι).obj W)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictFunctor_map_app_aux := Scheme.ι_image_homOfLE_le_ι_image\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctor_map_app","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : LE.le U V\nW : (↑V).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (X.homOfLE e) W) (X.presheaf.map (CategoryTheory.homOfLE ⋯).op)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictFunctor_map_app := Scheme.homOfLE_app\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctorΓ_hom_app","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X✝ : AlgebraicGeometry.Scheme\nX : Opposite X✝.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.restrictFunctorΓ.hom.app X) (X✝.presheaf.map (CategoryTheory.eqToHom ⋯))","decl":"/-- The functor that restricts to open subschemes and then takes global section is\nisomorphic to the structure sheaf. -/\n@[simps!]\ndef Scheme.restrictFunctorΓ : X.restrictFunctor.op ⋙ (Over.forget X).op ⋙ Scheme.Γ ≅ X.presheaf :=\n  NatIso.ofComponents\n    (fun U => X.presheaf.mapIso ((eqToIso (unop U).isOpenEmbedding_obj_top).symm.op :))\n    (by\n      intro U V i\n      dsimp\n      rw [X.homOfLE_appTop, ← Functor.map_comp, ← Functor.map_comp]\n      congr 1)\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictFunctorΓ_inv_app","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X✝ : AlgebraicGeometry.Scheme\nX : Opposite X✝.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.restrictFunctorΓ.inv.app X) (X✝.presheaf.map (CategoryTheory.eqToHom ⋯))","decl":"/-- The functor that restricts to open subschemes and then takes global section is\nisomorphic to the structure sheaf. -/\n@[simps!]\ndef Scheme.restrictFunctorΓ : X.restrictFunctor.op ⋙ (Over.forget X).op ⋙ Scheme.Γ ≅ X.presheaf :=\n  NatIso.ofComponents\n    (fun U => X.presheaf.mapIso ((eqToIso (unop U).isOpenEmbedding_obj_top).symm.op :))\n    (by\n      intro U V i\n      dsimp\n      rw [X.homOfLE_appTop, ← Functor.map_comp, ← Functor.map_comp]\n      congr 1)\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isoImage_hom_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).hom ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι) (CategoryTheory.CategoryStruct.comp U.ι f)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.isoImage_hom_ι\n    {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : X.Opens) :\n    (f.isoImage U).hom ≫ (f ''ᵁ U).ι = U.ι ≫ f :=\n  IsOpenImmersion.isoOfRangeEq_hom_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isoImage_hom_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).hom (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι h)) (CategoryTheory.CategoryStruct.comp U.ι (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.isoImage_hom_ι\n    {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : X.Opens) :\n    (f.isoImage U).hom ≫ (f ''ᵁ U).ι = U.ι ≫ f :=\n  IsOpenImmersion.isoOfRangeEq_hom_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isoImage_inv_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).inv (CategoryTheory.CategoryStruct.comp U.ι (CategoryTheory.CategoryStruct.comp f h))) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι h)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.isoImage_inv_ι\n    {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : X.Opens) :\n    (f.isoImage U).inv ≫ U.ι ≫ f = (f ''ᵁ U).ι :=\n  IsOpenImmersion.isoOfRangeEq_inv_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.isoImage_inv_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).inv (CategoryTheory.CategoryStruct.comp U.ι f)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.isoImage_inv_ι\n    {X Y : Scheme.{u}} (f : X ⟶ Y) [IsOpenImmersion f] (U : X.Opens) :\n    (f.isoImage U).inv ≫ U.ι ≫ f = (f ''ᵁ U).ι :=\n  IsOpenImmersion.isoOfRangeEq_inv_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.restrictRestrict_hom_restrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).hom ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι) (CategoryTheory.CategoryStruct.comp U.ι f)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictRestrict_hom_restrict := Scheme.Hom.isoImage_hom_ι\n"}
{"name":"AlgebraicGeometry.Scheme.restrictRestrict_inv_restrict_restrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).inv (CategoryTheory.CategoryStruct.comp U.ι f)) ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictRestrict_inv_restrict_restrict := Scheme.Hom.isoImage_inv_ι\n"}
{"name":"AlgebraicGeometry.Scheme.restrictRestrict_hom_restrict_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).hom (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι h)) (CategoryTheory.CategoryStruct.comp U.ι (CategoryTheory.CategoryStruct.comp f h))","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictRestrict_hom_restrict_assoc := Scheme.Hom.isoImage_hom_ι_assoc\n"}
{"name":"AlgebraicGeometry.Scheme.restrictRestrict_inv_restrict_restrict_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\nU : X.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.isoImage f U).inv (CategoryTheory.CategoryStruct.comp U.ι (CategoryTheory.CategoryStruct.comp f h))) (CategoryTheory.CategoryStruct.comp ((AlgebraicGeometry.Scheme.Hom.opensFunctor f).obj U).ι h)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias Scheme.restrictRestrict_inv_restrict_restrict_assoc := Scheme.Hom.isoImage_inv_ι_assoc\n\n"}
{"name":"AlgebraicGeometry.Scheme.topIso_hom","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq X.topIso.hom Top.top.ι","decl":"/-- `(⊤ : X.Opens)` as a scheme is isomorphic to `X`. -/\n@[simps hom]\ndef Scheme.topIso (X : Scheme) : ↑(⊤ : X.Opens) ≅ X where\n  hom := Scheme.Opens.ι _\n  inv := ⟨X.restrictTopIso.inv⟩\n  hom_inv_id := Hom.ext' X.restrictTopIso.hom_inv_id\n  inv_hom_id := Hom.ext' X.restrictTopIso.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.toIso_inv_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Z : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.topIso.inv (CategoryTheory.CategoryStruct.comp Top.top.ι h)) h","decl":"@[reassoc (attr := simp)]\nlemma Scheme.toIso_inv_ι (X : Scheme.{u}) : X.topIso.inv ≫ Opens.ι _ = 𝟙 _ :=\n  X.topIso.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.toIso_inv_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq (CategoryTheory.CategoryStruct.comp X.topIso.inv Top.top.ι) (CategoryTheory.CategoryStruct.id X)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.toIso_inv_ι (X : Scheme.{u}) : X.topIso.inv ≫ Opens.ι _ = 𝟙 _ :=\n  X.topIso.inv_hom_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.ι_toIso_inv_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Z : AlgebraicGeometry.Scheme\nh : Quiver.Hom (↑Top.top) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp Top.top.ι (CategoryTheory.CategoryStruct.comp X.topIso.inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma Scheme.ι_toIso_inv (X : Scheme.{u}) : Opens.ι _ ≫ X.topIso.inv = 𝟙 _ :=\n  X.topIso.hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.ι_toIso_inv","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\n⊢ Eq (CategoryTheory.CategoryStruct.comp Top.top.ι X.topIso.inv) (CategoryTheory.CategoryStruct.id ↑Top.top)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.ι_toIso_inv (X : Scheme.{u}) : Opens.ι _ ≫ X.topIso.inv = 𝟙 _ :=\n  X.topIso.hom_inv_id\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoOfEq_hom_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : Eq U V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.isoOfEq e).hom V.ι) U.ι","decl":"@[reassoc (attr := simp)]\nlemma Scheme.isoOfEq_hom_ι (X : Scheme.{u}) {U V : X.Opens} (e : U = V) :\n    (X.isoOfEq e).hom ≫ V.ι = U.ι :=\n  IsOpenImmersion.isoOfRangeEq_hom_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoOfEq_hom_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : Eq U V\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.isoOfEq e).hom (CategoryTheory.CategoryStruct.comp V.ι h)) (CategoryTheory.CategoryStruct.comp U.ι h)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.isoOfEq_hom_ι (X : Scheme.{u}) {U V : X.Opens} (e : U = V) :\n    (X.isoOfEq e).hom ≫ V.ι = U.ι :=\n  IsOpenImmersion.isoOfRangeEq_hom_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoOfEq_inv_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : Eq U V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.isoOfEq e).inv U.ι) V.ι","decl":"@[reassoc (attr := simp)]\nlemma Scheme.isoOfEq_inv_ι (X : Scheme.{u}) {U V : X.Opens} (e : U = V) :\n    (X.isoOfEq e).inv ≫ U.ι = V.ι :=\n  IsOpenImmersion.isoOfRangeEq_inv_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoOfEq_inv_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\ne : Eq U V\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.isoOfEq e).inv (CategoryTheory.CategoryStruct.comp U.ι h)) (CategoryTheory.CategoryStruct.comp V.ι h)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.isoOfEq_inv_ι (X : Scheme.{u}) {U V : X.Opens} (e : U = V) :\n    (X.isoOfEq e).inv ≫ U.ι = V.ι :=\n  IsOpenImmersion.isoOfRangeEq_inv_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.isoOfEq_rfl","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (X.isoOfEq ⋯) (CategoryTheory.Iso.refl ↑U)","decl":"@[simp]\nlemma Scheme.isoOfEq_rfl (X : Scheme.{u}) (U : X.Opens) : X.isoOfEq (refl U) = Iso.refl _ := by\n  ext1\n  rw [← cancel_mono U.ι, Scheme.isoOfEq_hom_ι, Iso.refl_hom, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimageIso_hom_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : CategoryTheory.IsIso f\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.preimageIso U).hom (CategoryTheory.CategoryStruct.comp U.ι h)) (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.preimageIso_hom_ι {X Y : Scheme.{u}} (f : X.Hom Y) [IsIso (C := Scheme) f]\n    (U : Y.Opens) : (f.preimageIso U).hom ≫ U.ι = (f ⁻¹ᵁ U).ι ≫ f :=\n  IsOpenImmersion.isoOfRangeEq_hom_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimageIso_hom_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : CategoryTheory.IsIso f\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.preimageIso U).hom U.ι) (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι f)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.preimageIso_hom_ι {X Y : Scheme.{u}} (f : X.Hom Y) [IsIso (C := Scheme) f]\n    (U : Y.Opens) : (f.preimageIso U).hom ≫ U.ι = (f ⁻¹ᵁ U).ι ≫ f :=\n  IsOpenImmersion.isoOfRangeEq_hom_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimageIso_inv_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : CategoryTheory.IsIso f\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.preimageIso U).inv (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι (CategoryTheory.CategoryStruct.comp f h))) (CategoryTheory.CategoryStruct.comp U.ι h)","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.preimageIso_inv_ι {X Y : Scheme.{u}} (f : X.Hom Y) [IsIso (C := Scheme) f]\n    (U : Y.Opens) : (f.preimageIso U).inv ≫ (f ⁻¹ᵁ U).ι ≫ f = U.ι :=\n  IsOpenImmersion.isoOfRangeEq_inv_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.preimageIso_inv_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : X.Hom Y\ninst✝ : CategoryTheory.IsIso f\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (f.preimageIso U).inv (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι f)) U.ι","decl":"@[reassoc (attr := simp)]\nlemma Scheme.Hom.preimageIso_inv_ι {X Y : Scheme.{u}} (f : X.Hom Y) [IsIso (C := Scheme) f]\n    (U : Y.Opens) : (f.preimageIso U).inv ≫ (f ⁻¹ᵁ U).ι ≫ f = U.ι :=\n  IsOpenImmersion.isoOfRangeEq_inv_fac _ _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_inv_fst_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f U.ι) h)) (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι h)","decl":"@[simp, reassoc]\ntheorem pullbackRestrictIsoRestrict_inv_fst {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (pullbackRestrictIsoRestrict f U).inv ≫ pullback.fst f _ = (f ⁻¹ᵁ U).ι := by\n  delta pullbackRestrictIsoRestrict; simp\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_inv_fst","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).inv (CategoryTheory.Limits.pullback.fst f U.ι)) ((TopologicalSpace.Opens.map f.base).obj U).ι","decl":"@[simp, reassoc]\ntheorem pullbackRestrictIsoRestrict_inv_fst {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (pullbackRestrictIsoRestrict f U).inv ≫ pullback.fst f _ = (f ⁻¹ᵁ U).ι := by\n  delta pullbackRestrictIsoRestrict; simp\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_hom_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).hom ((TopologicalSpace.Opens.map f.base).obj U).ι) (CategoryTheory.Limits.pullback.fst f U.ι)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRestrictIsoRestrict_hom_ι {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (pullbackRestrictIsoRestrict f U).hom ≫ (f ⁻¹ᵁ U).ι = pullback.fst f _ := by\n  delta pullbackRestrictIsoRestrict; simp\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_hom_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).hom (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f U.ι) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRestrictIsoRestrict_hom_ι {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (pullbackRestrictIsoRestrict f U).hom ≫ (f ⁻¹ᵁ U).ι = pullback.fst f _ := by\n  delta pullbackRestrictIsoRestrict; simp\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_hom_restrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).hom ((TopologicalSpace.Opens.map f.base).obj U).ι) (CategoryTheory.Limits.pullback.fst f U.ι)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias pullbackRestrictIsoRestrict_hom_restrict := pullbackRestrictIsoRestrict_hom_ι\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_hom_restrict_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).hom (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f U.ι) h)","decl":"@[deprecated (since := \"2024-10-20\")]\nalias pullbackRestrictIsoRestrict_hom_restrict_assoc := pullbackRestrictIsoRestrict_hom_ι_assoc\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_hom_morphismRestrict_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (↑U) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).hom (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.morphismRestrict f U) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f U.ι) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRestrictIsoRestrict_hom_morphismRestrict {X Y : Scheme.{u}} (f : X ⟶ Y)\n    (U : Y.Opens) : (pullbackRestrictIsoRestrict f U).hom ≫ f ∣_ U = pullback.snd _ _ :=\n  Iso.hom_inv_id_assoc _ _\n\n"}
{"name":"AlgebraicGeometry.pullbackRestrictIsoRestrict_hom_morphismRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.pullbackRestrictIsoRestrict f U).hom (AlgebraicGeometry.morphismRestrict f U)) (CategoryTheory.Limits.pullback.snd f U.ι)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRestrictIsoRestrict_hom_morphismRestrict {X Y : Scheme.{u}} (f : X ⟶ Y)\n    (U : Y.Opens) : (pullbackRestrictIsoRestrict f U).hom ≫ f ∣_ U = pullback.snd _ _ :=\n  Iso.hom_inv_id_assoc _ _\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.morphismRestrict f U) (CategoryTheory.CategoryStruct.comp U.ι h)) (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\ntheorem morphismRestrict_ι {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (f ∣_ U) ≫ U.ι = (f ⁻¹ᵁ U).ι ≫ f := by\n  delta morphismRestrict\n  rw [Category.assoc, pullback.condition.symm, pullbackRestrictIsoRestrict_inv_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.morphismRestrict f U) U.ι) (CategoryTheory.CategoryStruct.comp ((TopologicalSpace.Opens.map f.base).obj U).ι f)","decl":"@[reassoc (attr := simp)]\ntheorem morphismRestrict_ι {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (f ∣_ U) ≫ U.ι = (f ⁻¹ᵁ U).ι ≫ f := by\n  delta morphismRestrict\n  rw [Category.assoc, pullback.condition.symm, pullbackRestrictIsoRestrict_inv_fst_assoc]\n\n"}
{"name":"AlgebraicGeometry.isPullback_morphismRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ CategoryTheory.IsPullback (AlgebraicGeometry.morphismRestrict f U) ((TopologicalSpace.Opens.map f.base).obj U).ι U.ι f","decl":"theorem isPullback_morphismRestrict {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    IsPullback (f ∣_ U) (f ⁻¹ᵁ U).ι U.ι f := by\n  delta morphismRestrict\n  rw [← Category.id_comp f]\n  refine\n    (IsPullback.of_horiz_isIso ⟨?_⟩).paste_horiz\n      (IsPullback.of_hasPullback f (Y.ofRestrict U.isOpenEmbedding)).flip\n  -- Porting note: changed `rw` to `erw`\n  erw [pullbackRestrictIsoRestrict_inv_fst]; rw [Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.isPullback_opens_inf_le","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V W : X.Opens\nhU : LE.le U W\nhV : LE.le V W\n⊢ CategoryTheory.IsPullback (X.homOfLE ⋯) (X.homOfLE ⋯) (X.homOfLE hU) (X.homOfLE hV)","decl":"lemma isPullback_opens_inf_le {X : Scheme} {U V W : X.Opens} (hU : U ≤ W) (hV : V ≤ W) :\n    IsPullback (X.homOfLE inf_le_left) (X.homOfLE inf_le_right) (X.homOfLE hU) (X.homOfLE hV) := by\n  refine (isPullback_morphismRestrict (X.homOfLE hV) (W.ι ⁻¹ᵁ U)).of_iso (V.ι.isoImage _ ≪≫\n    X.isoOfEq ?_) (W.ι.isoImage _ ≪≫ X.isoOfEq ?_) (Iso.refl _) (Iso.refl _) ?_ ?_ ?_ ?_\n  · rw [← TopologicalSpace.Opens.map_comp_obj, ← Scheme.comp_base, Scheme.homOfLE_ι]\n    exact V.functor_map_eq_inf U\n  · exact (W.functor_map_eq_inf U).trans (by simpa)\n  all_goals { simp [← cancel_mono (Scheme.Opens.ι _)] }\n\n"}
{"name":"AlgebraicGeometry.isPullback_opens_inf","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU V : X.Opens\n⊢ CategoryTheory.IsPullback (X.homOfLE ⋯) (X.homOfLE ⋯) U.ι V.ι","decl":"lemma isPullback_opens_inf {X : Scheme} (U V : X.Opens) :\n    IsPullback (X.homOfLE inf_le_left) (X.homOfLE inf_le_right) U.ι V.ι :=\n  (isPullback_morphismRestrict V.ι U).of_iso (V.ι.isoImage _ ≪≫ X.isoOfEq\n    (V.functor_map_eq_inf U)) (Iso.refl _) (Iso.refl _) (Iso.refl _) (by simp [← cancel_mono U.ι])\n    (by simp [← cancel_mono V.ι]) (by simp) (by simp)\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_id","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nU : X.Opens\n⊢ Eq (AlgebraicGeometry.morphismRestrict (CategoryTheory.CategoryStruct.id X) U) (CategoryTheory.CategoryStruct.id ↑((TopologicalSpace.Opens.map (CategoryTheory.CategoryStruct.id X).base).obj U))","decl":"@[simp]\nlemma morphismRestrict_id {X : Scheme.{u}} (U : X.Opens) : 𝟙 X ∣_ U = 𝟙 _ := by\n  rw [← cancel_mono U.ι, morphismRestrict_ι, Category.comp_id, Category.id_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_comp","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y Z : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nU : TopologicalSpace.Opens ↑↑Z.toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.morphismRestrict (CategoryTheory.CategoryStruct.comp f g) U) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.morphismRestrict f ((TopologicalSpace.Opens.map g.base).obj U)) (AlgebraicGeometry.morphismRestrict g U))","decl":"theorem morphismRestrict_comp {X Y Z : Scheme.{u}} (f : X ⟶ Y) (g : Y ⟶ Z) (U : Opens Z) :\n    (f ≫ g) ∣_ U = f ∣_ g ⁻¹ᵁ U ≫ g ∣_ U := by\n  delta morphismRestrict\n  rw [← pullbackRightPullbackFstIso_inv_snd_snd]\n  simp_rw [← Category.assoc]\n  congr 1\n  rw [← cancel_mono (pullback.fst _ _)]\n  simp_rw [Category.assoc]\n  rw [pullbackRestrictIsoRestrict_inv_fst, pullbackRightPullbackFstIso_inv_snd_fst, ←\n    pullback.condition, pullbackRestrictIsoRestrict_inv_fst_assoc,\n    pullbackRestrictIsoRestrict_inv_fst_assoc]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.instIsIsoSchemeMorphismRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.IsIso f\nU : Y.Opens\n⊢ CategoryTheory.IsIso (AlgebraicGeometry.morphismRestrict f U)","decl":"instance {X Y : Scheme.{u}} (f : X ⟶ Y) [IsIso f] (U : Y.Opens) : IsIso (f ∣_ U) := by\n  delta morphismRestrict; infer_instance\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_base_coe","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nx : ↑↑(↑((TopologicalSpace.Opens.map f.base).obj U)).toPresheafedSpace\n⊢ Eq (Coe.coe ((AlgebraicGeometry.morphismRestrict f U).base x)) (f.base ↑x)","decl":"theorem morphismRestrict_base_coe {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) (x) :\n    @Coe.coe U Y (⟨fun x => x.1⟩) ((f ∣_ U).base x) = f.base x.1 :=\n  congr_arg (fun f => (Scheme.Hom.toLRSHom f).base x)\n    (morphismRestrict_ι f U)\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_base","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (⇑(AlgebraicGeometry.morphismRestrict f U).base) (U.carrier.restrictPreimage ⇑f.base)","decl":"theorem morphismRestrict_base {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    ⇑(f ∣_ U).base = U.1.restrictPreimage f.base :=\n  funext fun x => Subtype.ext (morphismRestrict_base_coe f U x)\n\n"}
{"name":"AlgebraicGeometry.image_morphismRestrict_preimage","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : TopologicalSpace.Opens ↑↑(↑U).toPresheafedSpace\n⊢ Eq ((AlgebraicGeometry.Scheme.Hom.opensFunctor ((TopologicalSpace.Opens.map f.base).obj U).ι).obj ((TopologicalSpace.Opens.map (AlgebraicGeometry.morphismRestrict f U).base).obj V)) ((TopologicalSpace.Opens.map f.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V))","decl":"theorem image_morphismRestrict_preimage {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) (V : Opens U) :\n    (f ⁻¹ᵁ U).ι ''ᵁ ((f ∣_ U) ⁻¹ᵁ V) = f ⁻¹ᵁ (U.ι ''ᵁ V) := by\n  ext1\n  ext x\n  constructor\n  · rintro ⟨⟨x, hx⟩, hx' : (f ∣_ U).base _ ∈ V, rfl⟩\n    refine ⟨⟨_, hx⟩, ?_, rfl⟩\n    -- Porting note: this rewrite was not necessary\n    rw [SetLike.mem_coe]\n    convert hx'\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext1` is not compiling\n    refine Subtype.ext ?_\n    exact (morphismRestrict_base_coe f U ⟨x, hx⟩).symm\n  · rintro ⟨⟨x, hx⟩, hx' : _ ∈ V.1, rfl : x = _⟩\n    refine ⟨⟨_, hx⟩, (?_ : (f ∣_ U).base ⟨x, hx⟩ ∈ V.1), rfl⟩\n    convert hx'\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext1` is compiling\n    refine Subtype.ext ?_\n    exact morphismRestrict_base_coe f U ⟨x, hx⟩\n\n"}
{"name":"AlgebraicGeometry.eqToHom_eq_homOfLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"C : Type u_1\ninst✝ : Preorder C\nX Y : C\ne : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom e) (CategoryTheory.homOfLE ⋯)","decl":"lemma eqToHom_eq_homOfLE {C} [Preorder C] {X Y : C} (e : X = Y) : eqToHom e = homOfLE e.le := rfl\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_app","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : (↑U).Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (AlgebraicGeometry.morphismRestrict f U) V) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V)) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op))","decl":"open Scheme in\ntheorem morphismRestrict_app {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) (V : U.toScheme.Opens) :\n    (f ∣_ U).app V = f.app (U.ι ''ᵁ V) ≫\n        X.presheaf.map (eqToHom (image_morphismRestrict_preimage f U V)).op := by\n  have := Scheme.congr_app (morphismRestrict_ι f U) (U.ι ''ᵁ V)\n  simp only [Scheme.preimage_comp, Opens.toScheme_presheaf_obj, Hom.app_eq_appLE, comp_appLE,\n    Opens.ι_appLE, eqToHom_op, Opens.toScheme_presheaf_map, eqToHom_unop] at this\n  have e : U.ι ⁻¹ᵁ (U.ι ''ᵁ V) = V :=\n    Opens.ext (Set.preimage_image_eq _ Subtype.coe_injective)\n  have e' : (f ∣_ U) ⁻¹ᵁ V = (f ∣_ U) ⁻¹ᵁ U.ι ⁻¹ᵁ U.ι ''ᵁ V := by rw [e]\n  simp only [Opens.toScheme_presheaf_obj, Hom.app_eq_appLE, eqToHom_op, Hom.appLE_map]\n  rw [← (f ∣_ U).appLE_map' _ e', ← (f ∣_ U).map_appLE' _ e]\n  simp only [Opens.toScheme_presheaf_obj, eqToHom_eq_homOfLE, Opens.toScheme_presheaf_map,\n    Quiver.Hom.unop_op, Hom.opensFunctor_map_homOfLE]\n  rw [this, Hom.appLE_map, Hom.appLE_map, Hom.appLE_map]\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_appTop","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appTop (AlgebraicGeometry.morphismRestrict f U)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj Top.top)) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op))","decl":"theorem morphismRestrict_appTop {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    (f ∣_ U).appTop = f.app (U.ι ''ᵁ ⊤) ≫\n        X.presheaf.map (eqToHom (image_morphismRestrict_preimage f U ⊤)).op :=\n  morphismRestrict_app ..\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_app'","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : TopologicalSpace.Opens ↑↑(↑U).toPresheafedSpace\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.app (AlgebraicGeometry.morphismRestrict f U) V) (AlgebraicGeometry.Scheme.Hom.appLE f ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ((AlgebraicGeometry.Scheme.Hom.opensFunctor ((TopologicalSpace.Opens.map f.base).obj U).ι).obj ((TopologicalSpace.Opens.map (AlgebraicGeometry.morphismRestrict f U).base).obj V)) ⋯)","decl":"@[simp]\ntheorem morphismRestrict_app' {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) (V : Opens U) :\n    (f ∣_ U).app V = f.appLE _ _ (image_morphismRestrict_preimage f U V).le :=\n  morphismRestrict_app f U V\n\n"}
{"name":"AlgebraicGeometry.morphismRestrict_appLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : (↑U).Opens\nW : (↑((TopologicalSpace.Opens.map f.base).obj U)).Opens\ne : LE.le W ((TopologicalSpace.Opens.map (AlgebraicGeometry.morphismRestrict f U).base).obj V)\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appLE (AlgebraicGeometry.morphismRestrict f U) V W e) (AlgebraicGeometry.Scheme.Hom.appLE f ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj V) ((AlgebraicGeometry.Scheme.Hom.opensFunctor ((TopologicalSpace.Opens.map f.base).obj U).ι).obj W) ⋯)","decl":"@[simp]\ntheorem morphismRestrict_appLE {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) (V W e) :\n    (f ∣_ U).appLE V W e = f.appLE (U.ι ''ᵁ V) ((f ⁻¹ᵁ U).ι ''ᵁ W)\n      ((Set.image_subset _ e).trans (image_morphismRestrict_preimage f U V).le) := by\n  rw [Scheme.Hom.appLE, morphismRestrict_app', Scheme.Opens.toScheme_presheaf_map,\n    Scheme.Hom.appLE_map]\n\n"}
{"name":"AlgebraicGeometry.Γ_map_morphismRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Γ.map (AlgebraicGeometry.morphismRestrict f U).op) (CategoryTheory.CategoryStruct.comp (Y.presheaf.map (CategoryTheory.eqToHom ⋯).op) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.app f U) (X.presheaf.map (CategoryTheory.eqToHom ⋯).op)))","decl":"theorem Γ_map_morphismRestrict {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) :\n    Scheme.Γ.map (f ∣_ U).op =\n      Y.presheaf.map (eqToHom U.isOpenEmbedding_obj_top.symm).op ≫\n        f.app U ≫ X.presheaf.map (eqToHom (f ⁻¹ᵁ U).isOpenEmbedding_obj_top).op := by\n  rw [Scheme.Γ_map_op, morphismRestrict_appTop f U, f.naturality_assoc, ← X.presheaf.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.instIsOpenImmersionMorphismRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\ninst✝ : AlgebraicGeometry.IsOpenImmersion f\n⊢ AlgebraicGeometry.IsOpenImmersion (AlgebraicGeometry.morphismRestrict f U)","decl":"instance {X Y : Scheme.{u}} (f : X ⟶ Y) (U : Y.Opens) [IsOpenImmersion f] :\n    IsOpenImmersion (f ∣_ U) := by\n  delta morphismRestrict\n  exact PresheafedSpace.IsOpenImmersion.comp _ _\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_eq_morphismRestrict","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.resLE f U ((TopologicalSpace.Opens.map f.base).obj U) ⋯) (AlgebraicGeometry.morphismRestrict f U)","decl":"lemma resLE_eq_morphismRestrict : f.resLE U (f ⁻¹ᵁ U) le_rfl = f ∣_ U := by\n  simp [resLE]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_id","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\nV V' : X.Opens\ni : LE.le V V'\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.resLE (CategoryTheory.CategoryStruct.id X) V' V i) (X.homOfLE i)","decl":"lemma resLE_id (i : V ≤ V') : resLE (𝟙 X) V' V i = X.homOfLE i := by\n  simp only [resLE, morphismRestrict_id]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_comp_ι","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) U.ι) (CategoryTheory.CategoryStruct.comp V.ι f)","decl":"@[reassoc (attr := simp)]\nlemma resLE_comp_ι : f.resLE U V e ≫ U.ι = V.ι ≫ f := by\n  simp [resLE]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_comp_ι_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) (CategoryTheory.CategoryStruct.comp U.ι h)) (CategoryTheory.CategoryStruct.comp V.ι (CategoryTheory.CategoryStruct.comp f h))","decl":"@[reassoc (attr := simp)]\nlemma resLE_comp_ι : f.resLE U V e ≫ U.ι = V.ι ≫ f := by\n  simp [resLE]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_comp_resLE_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nZ✝ : AlgebraicGeometry.Scheme\ng : Quiver.Hom Y Z✝\nW : Z✝.Opens\ne' : LE.le U ((TopologicalSpace.Opens.map g.base).obj W)\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (↑W) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE g W U e') h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE (CategoryTheory.CategoryStruct.comp f g) W V ⋯) h)","decl":"@[reassoc]\nlemma resLE_comp_resLE {Z : Scheme.{u}} (g : Y ⟶ Z) {W : Z.Opens} (e') :\n    f.resLE U V e ≫ g.resLE W U e' = (f ≫ g).resLE W V\n      (e.trans ((Opens.map f.base).map (homOfLE e')).le) := by\n  simp [← cancel_mono W.ι]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_comp_resLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nZ : AlgebraicGeometry.Scheme\ng : Quiver.Hom Y Z\nW : Z.Opens\ne' : LE.le U ((TopologicalSpace.Opens.map g.base).obj W)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) (AlgebraicGeometry.Scheme.Hom.resLE g W U e')) (AlgebraicGeometry.Scheme.Hom.resLE (CategoryTheory.CategoryStruct.comp f g) W V ⋯)","decl":"@[reassoc]\nlemma resLE_comp_resLE {Z : Scheme.{u}} (g : Y ⟶ Z) {W : Z.Opens} (e') :\n    f.resLE U V e ≫ g.resLE W U e' = (f ≫ g).resLE W V\n      (e.trans ((Opens.map f.base).map (homOfLE e')).le) := by\n  simp [← cancel_mono W.ι]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_resLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : LE.le V' V\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE i) (AlgebraicGeometry.Scheme.Hom.resLE f U V e)) (AlgebraicGeometry.Scheme.Hom.resLE f U V' ⋯)","decl":"@[reassoc (attr := simp)]\nlemma map_resLE (i : V' ≤ V) :\n    X.homOfLE i ≫ f.resLE U V e = f.resLE U V' (i.trans e) := by\n  simp_rw [← resLE_id, resLE_comp_resLE, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.map_resLE_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : LE.le V' V\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (↑U) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.homOfLE i) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V' ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma map_resLE (i : V' ≤ V) :\n    X.homOfLE i ≫ f.resLE U V e = f.resLE U V' (i.trans e) := by\n  simp_rw [← resLE_id, resLE_comp_resLE, Category.id_comp]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_map","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU U' : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : LE.le U U'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) (Y.homOfLE i)) (AlgebraicGeometry.Scheme.Hom.resLE f U' V ⋯)","decl":"@[reassoc (attr := simp)]\nlemma resLE_map (i : U ≤ U') :\n    f.resLE U V e ≫ Y.homOfLE i =\n      f.resLE U' V (e.trans ((Opens.map f.base).map i.hom).le) := by\n  simp_rw [← resLE_id, resLE_comp_resLE, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_map_assoc","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU U' : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ni : LE.le U U'\nZ : AlgebraicGeometry.Scheme\nh : Quiver.Hom (↑U') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U V e) (CategoryTheory.CategoryStruct.comp (Y.homOfLE i) h)) (CategoryTheory.CategoryStruct.comp (AlgebraicGeometry.Scheme.Hom.resLE f U' V ⋯) h)","decl":"@[reassoc (attr := simp)]\nlemma resLE_map (i : U ≤ U') :\n    f.resLE U V e ≫ Y.homOfLE i =\n      f.resLE U' V (e.trans ((Opens.map f.base).map i.hom).le) := by\n  simp_rw [← resLE_id, resLE_comp_resLE, Category.comp_id]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_congr","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU U' : Y.Opens\nV V' : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\ne₁ : Eq U U'\ne₂ : Eq V V'\nP : CategoryTheory.MorphismProperty AlgebraicGeometry.Scheme\n⊢ Iff (P (AlgebraicGeometry.Scheme.Hom.resLE f U V e)) (P (AlgebraicGeometry.Scheme.Hom.resLE f U' V' ⋯))","decl":"lemma resLE_congr (e₁ : U = U') (e₂ : V = V') (P : MorphismProperty Scheme.{u}) :\n    P (f.resLE U V e) ↔ P (f.resLE U' V' (e₁ ▸ e₂ ▸ e)) := by\n  subst e₁; subst e₂; rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_preimage","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nO : (↑U).Opens\n⊢ Eq ((TopologicalSpace.Opens.map (AlgebraicGeometry.Scheme.Hom.resLE f U V e).base).obj O) ((TopologicalSpace.Opens.map V.ι.base).obj ((TopologicalSpace.Opens.map f.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj O)))","decl":"lemma resLE_preimage (f : X ⟶ Y) {U : Y.Opens} {V : X.Opens} (e : V ≤ f ⁻¹ᵁ U)\n    (O : U.toScheme.Opens) :\n    f.resLE U V e ⁻¹ᵁ O = V.ι ⁻¹ᵁ (f ⁻¹ᵁ U.ι ''ᵁ O) := by\n  rw [← preimage_comp, ← resLE_comp_ι f e, preimage_comp, preimage_image_eq]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.le_preimage_resLE_iff","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nO : (↑U).Opens\nW : (↑V).Opens\n⊢ Iff (LE.le W ((TopologicalSpace.Opens.map (AlgebraicGeometry.Scheme.Hom.resLE f U V e).base).obj O)) (LE.le ((AlgebraicGeometry.Scheme.Hom.opensFunctor V.ι).obj W) ((TopologicalSpace.Opens.map f.base).obj ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj O)))","decl":"lemma le_preimage_resLE_iff {U : Y.Opens} {V : X.Opens} (e : V ≤ f ⁻¹ᵁ U)\n    (O : U.toScheme.Opens) (W : V.toScheme.Opens) :\n    W ≤ (f.resLE U V e) ⁻¹ᵁ O ↔ V.ι ''ᵁ W ≤ f ⁻¹ᵁ U.ι ''ᵁ O := by\n  simp [resLE_preimage, ← image_le_image_iff V.ι, image_preimage_eq_opensRange_inter, V.ι_image_le]\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.resLE_appLE","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nO : (↑U).Opens\nW : (↑V).Opens\ne' : LE.le W ((TopologicalSpace.Opens.map (AlgebraicGeometry.Scheme.Hom.resLE f U V e).base).obj O)\n⊢ Eq (AlgebraicGeometry.Scheme.Hom.appLE (AlgebraicGeometry.Scheme.Hom.resLE f U V e) O W e') (AlgebraicGeometry.Scheme.Hom.appLE f ((AlgebraicGeometry.Scheme.Hom.opensFunctor U.ι).obj O) ((AlgebraicGeometry.Scheme.Hom.opensFunctor V.ι).obj W) ⋯)","decl":"lemma resLE_appLE {U : Y.Opens} {V : X.Opens} (e : V ≤ f ⁻¹ᵁ U)\n    (O : U.toScheme.Opens) (W : V.toScheme.Opens) (e' : W ≤ resLE f U V e ⁻¹ᵁ O) :\n    (f.resLE U V e).appLE O W e' =\n      f.appLE (U.ι ''ᵁ O) (V.ι ''ᵁ W) ((le_preimage_resLE_iff f e O W).mp e') := by\n  simp only [appLE, resLE, comp_coeBase, Opens.map_comp_obj, comp_app, morphismRestrict_app',\n    homOfLE_leOfHom, homOfLE_app, Category.assoc, Opens.toScheme_presheaf_map, Quiver.Hom.unop_op,\n    opensFunctor_map_homOfLE]\n  rw [← X.presheaf.map_comp, ← X.presheaf.map_comp]\n  rfl\n\n"}
{"name":"AlgebraicGeometry.Scheme.Hom.coe_resLE_base","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X Y : AlgebraicGeometry.Scheme\nf : Quiver.Hom X Y\nU : Y.Opens\nV : X.Opens\ne : LE.le V ((TopologicalSpace.Opens.map f.base).obj U)\nx : Subtype fun x => Membership.mem V x\n⊢ Eq (↑((AlgebraicGeometry.Scheme.Hom.resLE f U V e).base x)) (f.base ↑x)","decl":"@[simp]\nlemma coe_resLE_base (x : V) : ((f.resLE U V e).base x).val = f.base x := by\n  simp [resLE, morphismRestrict_base]\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.restrict_map","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nU : X.Opens\nx✝ : 𝒰.J\n⊢ Eq ((𝒰.restrict U).map x✝) (AlgebraicGeometry.morphismRestrict (𝒰.map x✝) U)","decl":"/-- The restriction of an open cover to an open subset. -/\n@[simps! J obj map]\nnoncomputable\ndef Scheme.OpenCover.restrict {X : Scheme.{u}} (𝒰 : X.OpenCover) (U : Opens X) :\n    U.toScheme.OpenCover := by\n  refine Cover.copy (𝒰.pullbackCover U.ι) 𝒰.J _ (𝒰.map · ∣_ U) (Equiv.refl _)\n    (fun i ↦ IsOpenImmersion.isoOfRangeEq (Opens.ι _) (pullback.snd _ _) ?_) ?_\n  · erw [IsOpenImmersion.range_pullback_snd_of_left U.ι (𝒰.map i)]\n    rw [Opens.opensRange_ι]\n    exact Subtype.range_val\n  · intro i\n    rw [← cancel_mono U.ι]\n    simp only [morphismRestrict_ι, Cover.pullbackCover_J, Equiv.refl_apply, Cover.pullbackCover_obj,\n      Cover.pullbackCover_map, Category.assoc, pullback.condition]\n    rw [IsOpenImmersion.isoOfRangeEq_hom_fac_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.restrict_J","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nU : X.Opens\n⊢ Eq (𝒰.restrict U).J 𝒰.J","decl":"/-- The restriction of an open cover to an open subset. -/\n@[simps! J obj map]\nnoncomputable\ndef Scheme.OpenCover.restrict {X : Scheme.{u}} (𝒰 : X.OpenCover) (U : Opens X) :\n    U.toScheme.OpenCover := by\n  refine Cover.copy (𝒰.pullbackCover U.ι) 𝒰.J _ (𝒰.map · ∣_ U) (Equiv.refl _)\n    (fun i ↦ IsOpenImmersion.isoOfRangeEq (Opens.ι _) (pullback.snd _ _) ?_) ?_\n  · erw [IsOpenImmersion.range_pullback_snd_of_left U.ι (𝒰.map i)]\n    rw [Opens.opensRange_ι]\n    exact Subtype.range_val\n  · intro i\n    rw [← cancel_mono U.ι]\n    simp only [morphismRestrict_ι, Cover.pullbackCover_J, Equiv.refl_apply, Cover.pullbackCover_obj,\n      Cover.pullbackCover_map, Category.assoc, pullback.condition]\n    rw [IsOpenImmersion.isoOfRangeEq_hom_fac_assoc]\n\n"}
{"name":"AlgebraicGeometry.Scheme.OpenCover.restrict_obj","module":"Mathlib.AlgebraicGeometry.Restrict","initialProofState":"X : AlgebraicGeometry.Scheme\n𝒰 : X.OpenCover\nU : X.Opens\nx✝ : 𝒰.J\n⊢ Eq ((𝒰.restrict U).obj x✝) ↑((TopologicalSpace.Opens.map (𝒰.map x✝).base).obj U)","decl":"/-- The restriction of an open cover to an open subset. -/\n@[simps! J obj map]\nnoncomputable\ndef Scheme.OpenCover.restrict {X : Scheme.{u}} (𝒰 : X.OpenCover) (U : Opens X) :\n    U.toScheme.OpenCover := by\n  refine Cover.copy (𝒰.pullbackCover U.ι) 𝒰.J _ (𝒰.map · ∣_ U) (Equiv.refl _)\n    (fun i ↦ IsOpenImmersion.isoOfRangeEq (Opens.ι _) (pullback.snd _ _) ?_) ?_\n  · erw [IsOpenImmersion.range_pullback_snd_of_left U.ι (𝒰.map i)]\n    rw [Opens.opensRange_ι]\n    exact Subtype.range_val\n  · intro i\n    rw [← cancel_mono U.ι]\n    simp only [morphismRestrict_ι, Cover.pullbackCover_J, Equiv.refl_apply, Cover.pullbackCover_obj,\n      Cover.pullbackCover_map, Category.assoc, pullback.condition]\n    rw [IsOpenImmersion.isoOfRangeEq_hom_fac_assoc]\n\n"}
