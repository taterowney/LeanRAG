{"name":"ZLattice.covolume_eq_measure_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : FiniteDimensional Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : Submodule Int E\ninst✝² : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝¹ : IsZLattice Real L\nμ : autoParam (MeasureTheory.Measure E) _auto✝\ninst✝ : MeasureTheory.Measure.IsAddHaarMeasure μ\nF : Set E\nh : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem L x) F μ\n⊢ Eq (ZLattice.covolume L μ) (μ F).toReal","decl":"theorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F μ) :\n    covolume L μ = (μ F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E μ := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E μ)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume μ)\n\n"}
{"name":"ZLattice.covolume_ne_zero","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : FiniteDimensional Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : Submodule Int E\ninst✝² : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝¹ : IsZLattice Real L\nμ : autoParam (MeasureTheory.Measure E) _auto✝\ninst✝ : MeasureTheory.Measure.IsAddHaarMeasure μ\n⊢ Ne (ZLattice.covolume L μ) 0","decl":"theorem covolume_ne_zero : covolume L μ ≠ 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L μ (isAddFundamentalDomain (Free.chooseBasis ℤ L) μ),\n    ENNReal.toReal_ne_zero]\n  refine ⟨measure_fundamentalDomain_ne_zero _, ne_of_lt ?_⟩\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\n"}
{"name":"ZLattice.covolume_pos","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\ninst✝⁵ : FiniteDimensional Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : Submodule Int E\ninst✝² : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝¹ : IsZLattice Real L\nμ : autoParam (MeasureTheory.Measure E) _auto✝\ninst✝ : MeasureTheory.Measure.IsAddHaarMeasure μ\n⊢ LT.lt 0 (ZLattice.covolume L μ)","decl":"theorem covolume_pos : 0 < covolume L μ :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L μ).symm\n\n"}
{"name":"ZLattice.covolume_comap","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝¹³ : NormedAddCommGroup E\ninst✝¹² : NormedSpace Real E\ninst✝¹¹ : FiniteDimensional Real E\ninst✝¹⁰ : MeasurableSpace E\ninst✝⁹ : BorelSpace E\nL : Submodule Int E\ninst✝⁸ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝⁷ : IsZLattice Real L\nμ : autoParam (MeasureTheory.Measure E) _auto✝\ninst✝⁶ : MeasureTheory.Measure.IsAddHaarMeasure μ\nF : Type u_2\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace Real F\ninst✝³ : FiniteDimensional Real F\ninst✝² : MeasurableSpace F\ninst✝¹ : BorelSpace F\nν : autoParam (MeasureTheory.Measure F) _auto✝\ninst✝ : MeasureTheory.Measure.IsAddHaarMeasure ν\ne : ContinuousLinearEquiv (RingHom.id Real) F E\nhe : MeasureTheory.MeasurePreserving (⇑e) ν μ\n⊢ Eq (ZLattice.covolume (ZLattice.comap Real L ↑e.toLinearEquiv) ν) (ZLattice.covolume L μ)","decl":"theorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace ℝ F] [FiniteDimensional ℝ F]\n    [MeasurableSpace F] [BorelSpace F] (ν : Measure F := by volume_tac) [Measure.IsAddHaarMeasure ν]\n    {e : F ≃L[ℝ] E} (he : MeasurePreserving e ν μ) :\n    covolume (ZLattice.comap ℝ L e.toLinearMap) ν = covolume L μ := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis ℤ L) μ),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis ℤ L).ofZLatticeComap ℝ L e.toLinearEquiv) ν)), ← he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, ← e.image_symm_eq_preimage,\n    ← e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\n"}
{"name":"ZLattice.covolume_eq_det_mul_measure","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Real E\ninst✝⁷ : FiniteDimensional Real E\ninst✝⁶ : MeasurableSpace E\ninst✝⁵ : BorelSpace E\nL : Submodule Int E\ninst✝⁴ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝³ : IsZLattice Real L\nμ : autoParam (MeasureTheory.Measure E) _auto✝\ninst✝² : MeasureTheory.Measure.IsAddHaarMeasure μ\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\nb₀ : Basis ι Real E\n⊢ Eq (ZLattice.covolume L μ) (HMul.hMul (abs (b₀.det (Function.comp Subtype.val ⇑b))) (μ (ZSpan.fundamentalDomain b₀)).toReal)","decl":"theorem covolume_eq_det_mul_measure {ι : Type*} [Fintype ι] [DecidableEq ι] (b : Basis ι ℤ L)\n    (b₀ : Basis ι ℝ E) :\n    covolume L μ = |b₀.det ((↑) ∘ b)| * (μ (fundamentalDomain b₀)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L μ (isAddFundamentalDomain b μ),\n    measure_fundamentalDomain _ _ b₀,\n    measure_congr (fundamentalDomain_ae_parallelepiped b₀ μ), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply ℝ L _\n\n"}
{"name":"ZLattice.covolume_eq_det","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"ι : Type u_2\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\nL : Submodule Int (ι → Real)\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice Real L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\n⊢ Eq (ZLattice.covolume L MeasureTheory.MeasureSpace.volume) (abs (Matrix.of (Function.comp Subtype.val ⇑b)).det)","decl":"theorem covolume_eq_det {ι : Type*} [Fintype ι] [DecidableEq ι] (L : Submodule ℤ (ι → ℝ))\n    [DiscreteTopology L] [IsZLattice ℝ L] (b : Basis ι ℤ L) :\n    covolume L = |(Matrix.of ((↑) ∘ b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply ℝ L _\n\n"}
{"name":"ZLattice.covolume_eq_det_inv","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"ι : Type u_2\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\nL : Submodule Int (ι → Real)\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice Real L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\n⊢ Eq (ZLattice.covolume L MeasureTheory.MeasureSpace.volume) (Inv.inv (abs ↑(LinearEquiv.det (Basis.ofZLatticeBasis Real L b).equivFun)))","decl":"theorem covolume_eq_det_inv {ι : Type*} [Fintype ι] [DecidableEq ι] (L : Submodule ℤ (ι → ℝ))\n    [DiscreteTopology L] [IsZLattice ℝ L] (b : Basis ι ℤ L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis ℝ L).equivFun : ℝ)|⁻¹ := by\n  rw [covolume_eq_det L b, ← Pi.basisFun_det_apply, show (((↑) : L → _) ∘ ⇑b) =\n    (b.ofZLatticeBasis ℝ) by ext; simp, ← Basis.det_inv, ← abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, ← Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\n"}
{"name":"ZLattice.volume_image_eq_volume_div_covolume","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"ι : Type u_2\ninst✝³ : Fintype ι\ninst✝² : DecidableEq ι\nL : Submodule Int (ι → Real)\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice Real L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ns : Set (ι → Real)\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.image (⇑(Basis.ofZLatticeBasis Real L b).equivFun) s)) (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s) (ENNReal.ofReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"theorem volume_image_eq_volume_div_covolume {ι : Type*} [Fintype ι] [DecidableEq ι]\n    (L : Submodule ℤ (ι → ℝ)) [DiscreteTopology L] [IsZLattice ℝ L] (b : Basis ι ℤ L)\n    {s : Set (ι → ℝ)} :\n    volume ((b.ofZLatticeBasis ℝ L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n"}
{"name":"ZLattice.volume_image_eq_volume_div_covolume'","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_2\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : InnerProductSpace Real E\ninst✝⁵ : FiniteDimensional Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : Submodule Int E\ninst✝² : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝¹ : IsZLattice Real L\nι : Type u_3\ninst✝ : Fintype ι\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ns : Set E\nhs : MeasureTheory.NullMeasurableSet s MeasureTheory.MeasureSpace.volume\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.image (⇑(Basis.ofZLatticeBasis Real L b).equivFun) s)) (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s) (ENNReal.ofReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace ℝ E] [FiniteDimensional ℝ E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule ℤ E) [DiscreteTopology L] [IsZLattice ℝ L] {ι : Type*} [Fintype ι]\n    (b : Basis ι ℤ L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis ℝ).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank ℝ E) ≃ ι :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis ℝ)])\n  let f := (EuclideanSpace.equiv ι ℝ).symm.trans\n    ((stdOrthonormalBasis ℝ E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis ℝ E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv ι).symm\n  rw [← hf.measure_preimage hs, ← (covolume_comap L volume volume hf),\n    ← volume_image_eq_volume_div_covolume (ZLattice.comap ℝ L f.toLinearMap)\n    (b.ofZLatticeComap ℝ L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    ← f.image_symm_eq_preimage, ← Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\n"}
{"name":"ZLattice.covolume.tendsto_card_div_pow''","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace Real E\nL : Submodule Int E\ninst✝⁵ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝⁴ : IsZLattice Real L\nι : Type u_2\ninst✝³ : Fintype ι\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ninst✝² : FiniteDimensional Real E\ninst✝¹ : MeasurableSpace E\ninst✝ : BorelSpace E\ns : Set E\nhs₁ : Bornology.IsBounded s\nhs₂ : MeasurableSet s\nhs₃ : Eq (MeasureTheory.MeasureSpace.volume (frontier (Set.image (⇑(Basis.ofZLatticeBasis Real L b).equivFun) s))) 0\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (↑(Nat.card ↑(Inter.inter s (HSMul.hSMul (Inv.inv ↑n) ↑L)))) (HPow.hPow (↑n) (Fintype.card ι))) Filter.atTop (nhds (MeasureTheory.MeasureSpace.volume (Set.image (⇑(Basis.ofZLatticeBasis Real L b).equivFun) s)).toReal)","decl":"/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional ℝ E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs₁ : IsBounded s) (hs₂ : MeasurableSet s)\n    (hs₃ : volume (frontier ((b.ofZLatticeBasis ℝ).equivFun '' s)) = 0):\n    Tendsto (fun n : ℕ ↦ (Nat.card (s ∩ (n : ℝ)⁻¹ • L : Set E) : ℝ) / n ^ card ι)\n      atTop (𝓝 (volume ((b.ofZLatticeBasis ℝ).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis ℝ).equivFun '' s) ?_ ?_ hs₃)\n  · filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis ℝ).equivFun.toEquiv.subtypeEquiv fun x ↦ ?_).symm\n    simp_rw [Set.mem_inter_iff, ← b.ofZLatticeBasis_span ℝ, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff₀\n      (mod_cast hn.ne' : (n : ℝ) ≠ 0), ← Finsupp.coe_smul, ← LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  · rw [← NormedSpace.isVonNBounded_iff ℝ] at hs₁ ⊢\n    exact Bornology.IsVonNBounded.image hs₁ ((b.ofZLatticeBasis ℝ).equivFunL : E →L[ℝ] ι → ℝ)\n  · exact (b.ofZLatticeBasis ℝ).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs₂\n\n"}
{"name":"ZLattice.covolume.tendsto_card_le_div''","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\nL : Submodule Int E\ninst✝⁶ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝⁵ : IsZLattice Real L\nι : Type u_2\ninst✝⁴ : Fintype ι\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ninst✝³ : FiniteDimensional Real E\ninst✝² : MeasurableSpace E\ninst✝¹ : BorelSpace E\ninst✝ : Nonempty ι\nX : Set E\nhX : ∀ ⦃x : E⦄ ⦃r : Real⦄, Membership.mem X x → LT.lt 0 r → Membership.mem X (HSMul.hSMul r x)\nF : E → Real\nh₁ : ∀ (x : E) ⦃r : Real⦄, LE.le 0 r → Eq (F (HSMul.hSMul r x)) (HMul.hMul (HPow.hPow r (Fintype.card ι)) (F x))\nh₂ : Bornology.IsBounded (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh₃ : MeasurableSet (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh₄ : Eq (MeasureTheory.MeasureSpace.volume (frontier (Set.image (⇑(Basis.ofZLatticeBasis Real L b).equivFun) (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))))) 0\n⊢ Filter.Tendsto (fun c => HDiv.hDiv (↑(Nat.card ↑(Inter.inter (setOf fun x => And (Membership.mem X x) (LE.le (F x) c)) ↑L))) c) Filter.atTop (nhds (MeasureTheory.MeasureSpace.volume (Set.image (⇑(Basis.ofZLatticeBasis Real L b).equivFun) (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1)))).toReal)","decl":"/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional ℝ E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty ι] {X : Set E} (hX : ∀ ⦃x⦄ ⦃r : ℝ⦄, x ∈ X → 0 < r → r • x ∈ X)\n    {F : E → ℝ} (h₁ : ∀ x ⦃r : ℝ⦄, 0 ≤ r →  F (r • x) = r ^ card ι * (F x))\n    (h₂ : IsBounded {x ∈ X | F x ≤ 1}) (h₃ : MeasurableSet {x ∈ X | F x ≤ 1})\n    (h₄ : volume (frontier ((b.ofZLatticeBasis ℝ L).equivFun '' {x | x ∈ X ∧ F x ≤ 1})) = 0) :\n    Tendsto (fun c : ℝ ↦\n      Nat.card ({x ∈ X | F x ≤ c} ∩ L : Set E) / (c : ℝ))\n        atTop (𝓝 (volume ((b.ofZLatticeBasis ℝ).equivFun '' {x ∈ X | F x ≤ 1})).toReal) := by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis ℝ).equivFun '' {x ∈ X | F x ≤ 1}) ?_ ?_ h₄ fun x y hx hy ↦ ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x ↦ x ^ (card ι : ℝ)⁻¹) atTop atTop)\n  · filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux₁ : (card ι : ℝ) ≠ 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux₂ : 0 < c ^ (card ι : ℝ)⁻¹ := Real.rpow_pos_of_pos hc _\n    have aux₃ : (c ^ (card ι : ℝ)⁻¹)⁻¹ ≠ 0 := inv_ne_zero aux₂.ne'\n    have aux₄ : c ^ (-(card ι : ℝ)⁻¹) ≠ 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain ⟨hc₁, hc₂⟩ := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, ← Real.rpow_natCast, Real.rpow_inv_rpow hc₁ aux₁, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis ℝ).equivFun.toEquiv.trans\n          (Equiv.smulRight aux₄)) fun _ ↦ ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc₁, Set.smul_mem_smul_set_iff₀ aux₃,\n      ← Set.mem_smul_set_iff_inv_smul_mem₀ aux₂.ne', ← image_smul_set,\n      tendsto_card_le_div''_aux hX h₁ aux₂, ← Real.rpow_natCast, ← Real.rpow_mul hc₁,\n      inv_mul_cancel₀ aux₁, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, ← b.ofZLatticeBasis_span ℝ, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  · rw [← NormedSpace.isVonNBounded_iff ℝ] at h₂ ⊢\n    exact Bornology.IsVonNBounded.image h₂ ((b.ofZLatticeBasis ℝ).equivFunL : E →L[ℝ] ι → ℝ)\n  · exact (b.ofZLatticeBasis ℝ).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h₃\n  · simp_rw [← image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h₁ hx,\n      tendsto_card_le_div''_aux hX h₁ (lt_of_lt_of_le hx hy)]\n    exact fun a ⟨ha₁, ha₂⟩ ↦ ⟨ha₁, le_trans ha₂ <| pow_le_pow_left₀ (le_of_lt hx) hy _⟩\n\n"}
{"name":"ZLattice.covolume.tendsto_card_div_pow","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"ι : Type u_1\ninst✝² : Fintype ι\nL : Submodule Int (ι → Real)\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice Real L\nb : Basis ι Int (Subtype fun x => Membership.mem L x)\ns : Set (ι → Real)\nhs₁ : Bornology.IsBounded s\nhs₂ : MeasurableSet s\nhs₃ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (↑(Nat.card ↑(Inter.inter s (HSMul.hSMul (Inv.inv ↑n) ↑L)))) (HPow.hPow (↑n) (Fintype.card ι))) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"theorem tendsto_card_div_pow (b : Basis ι ℤ L) {s : Set (ι → ℝ)} (hs₁ : IsBounded s)\n    (hs₂ : MeasurableSet s) (hs₃ : volume (frontier s) = 0) :\n    Tendsto (fun n : ℕ ↦ (Nat.card (s ∩ (n : ℝ)⁻¹ • L : Set (ι → ℝ)) : ℝ) / n ^ card ι)\n      atTop (𝓝 ((volume s).toReal / covolume L)) := by\n  classical\n  convert tendsto_card_div_pow'' b hs₁ hs₂ ?_\n  · rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  · rw [frontier_equivFun, volume_image_eq_volume_div_covolume, hs₃, ENNReal.zero_div]\n\n"}
{"name":"ZLattice.covolume.tendsto_card_le_div","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"ι : Type u_1\ninst✝³ : Fintype ι\nL : Submodule Int (ι → Real)\ninst✝² : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝¹ : IsZLattice Real L\nX : Set (ι → Real)\nhX : ∀ ⦃x : ι → Real⦄ ⦃r : Real⦄, Membership.mem X x → LT.lt 0 r → Membership.mem X (HSMul.hSMul r x)\nF : (ι → Real) → Real\nh₁ : ∀ (x : ι → Real) ⦃r : Real⦄, LE.le 0 r → Eq (F (HSMul.hSMul r x)) (HMul.hMul (HPow.hPow r (Fintype.card ι)) (F x))\nh₂ : Bornology.IsBounded (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh₃ : MeasurableSet (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh₄ : Eq (MeasureTheory.MeasureSpace.volume (frontier (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1)))) 0\ninst✝ : Nonempty ι\n⊢ Filter.Tendsto (fun c => HDiv.hDiv (↑(Nat.card ↑(Inter.inter (setOf fun x => And (Membership.mem X x) (LE.le (F x) c)) ↑L))) c) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"theorem tendsto_card_le_div {X : Set (ι → ℝ)} (hX : ∀ ⦃x⦄ ⦃r : ℝ⦄, x ∈ X → 0 < r → r • x ∈ X)\n    {F : (ι → ℝ) → ℝ} (h₁ : ∀ x ⦃r : ℝ⦄, 0 ≤ r →  F (r • x) = r ^ card ι * (F x))\n    (h₂ : IsBounded {x ∈ X | F x ≤ 1}) (h₃ : MeasurableSet {x ∈ X | F x ≤ 1})\n    (h₄ : volume (frontier {x | x ∈ X ∧ F x ≤ 1}) = 0) [Nonempty ι] :\n    Tendsto (fun c : ℝ ↦\n      Nat.card ({x ∈ X | F x ≤ c} ∩ L : Set (ι → ℝ)) / (c : ℝ))\n        atTop (𝓝 ((volume {x ∈ X | F x ≤ 1}).toReal / covolume L)) := by\n  classical\n  let e : Free.ChooseBasisIndex ℤ ↥L ≃ ι := by\n    refine Fintype.equivOfCardEq ?_\n    rw [← finrank_eq_card_chooseBasisIndex, ZLattice.rank ℝ, finrank_fintype_fun_eq_card]\n  let b := (Module.Free.chooseBasis ℤ L).reindex e\n  convert tendsto_card_le_div'' b hX h₁ h₂ h₃ ?_\n  · rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  · rw [frontier_equivFun, volume_image_eq_volume_div_covolume, h₄, ENNReal.zero_div]\n\n"}
{"name":"ZLattice.covolume.tendsto_card_div_pow'","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁶ : NormedAddCommGroup E\ninst✝⁵ : InnerProductSpace Real E\ninst✝⁴ : FiniteDimensional Real E\ninst✝³ : MeasurableSpace E\ninst✝² : BorelSpace E\nL : Submodule Int E\ninst✝¹ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝ : IsZLattice Real L\ns : Set E\nhs₁ : Bornology.IsBounded s\nhs₂ : MeasurableSet s\nhs₃ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\n⊢ Filter.Tendsto (fun n => HDiv.hDiv (↑(Nat.card ↑(Inter.inter s (HSMul.hSMul (Inv.inv ↑n) ↑L)))) (HPow.hPow (↑n) (Module.finrank Real E))) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the `InnerProductSpace` case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow' {s : Set E} (hs₁ : IsBounded s) (hs₂ : MeasurableSet s)\n    (hs₃ : volume (frontier s) = 0) :\n    Tendsto (fun n : ℕ ↦ (Nat.card (s ∩ (n : ℝ)⁻¹ • L : Set E) : ℝ) / n ^ finrank ℝ E)\n      atTop (𝓝 ((volume s).toReal / covolume L)) := by\n  let b := Module.Free.chooseBasis ℤ L\n  convert tendsto_card_div_pow'' b hs₁ hs₂ ?_\n  · rw [← finrank_eq_card_chooseBasisIndex, ZLattice.rank ℝ L]\n  · rw [volume_image_eq_volume_div_covolume' L b hs₂.nullMeasurableSet, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  · rw [frontier_equivFun, volume_image_eq_volume_div_covolume', hs₃, ENNReal.zero_div]\n    exact NullMeasurableSet.of_null hs₃\n\n"}
{"name":"ZLattice.covolume.tendsto_card_le_div'","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : InnerProductSpace Real E\ninst✝⁵ : FiniteDimensional Real E\ninst✝⁴ : MeasurableSpace E\ninst✝³ : BorelSpace E\nL : Submodule Int E\ninst✝² : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst✝¹ : IsZLattice Real L\ninst✝ : Nontrivial E\nX : Set E\nF : E → Real\nhX : ∀ ⦃x : E⦄ ⦃r : Real⦄, Membership.mem X x → LT.lt 0 r → Membership.mem X (HSMul.hSMul r x)\nh₁ : ∀ (x : E) ⦃r : Real⦄, LE.le 0 r → Eq (F (HSMul.hSMul r x)) (HMul.hMul (HPow.hPow r (Module.finrank Real E)) (F x))\nh₂ : Bornology.IsBounded (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh₃ : MeasurableSet (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh₄ : Eq (MeasureTheory.MeasureSpace.volume (frontier (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1)))) 0\n⊢ Filter.Tendsto (fun c => HDiv.hDiv (↑(Nat.card ↑(Inter.inter (setOf fun x => And (Membership.mem X x) (LE.le (F x) c)) ↑L))) c) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the `InnerProductSpace` case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_le_div' [Nontrivial E] {X : Set E} {F : E → ℝ}\n    (hX : ∀ ⦃x⦄ ⦃r : ℝ⦄, x ∈ X → 0 < r → r • x ∈ X)\n    (h₁ : ∀ x ⦃r : ℝ⦄, 0 ≤ r →  F (r • x) = r ^ finrank ℝ E * (F x))\n    (h₂ : IsBounded {x ∈ X | F x ≤ 1}) (h₃ : MeasurableSet {x ∈ X | F x ≤ 1})\n    (h₄ : volume (frontier {x ∈ X | F x ≤ 1}) = 0) :\n    Tendsto (fun c : ℝ ↦\n      Nat.card ({x ∈ X | F x ≤ c} ∩ L : Set E) / (c : ℝ))\n        atTop (𝓝 ((volume {x ∈ X | F x ≤ 1}).toReal / covolume L)) := by\n  let b := Module.Free.chooseBasis ℤ L\n  convert tendsto_card_le_div'' b hX ?_ h₂ h₃ ?_\n  · rw [volume_image_eq_volume_div_covolume' L b h₃.nullMeasurableSet, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  · have : Nontrivial L := nontrivial_of_finrank_pos <| (ZLattice.rank ℝ L).symm ▸ finrank_pos\n    infer_instance\n  · rwa [← finrank_eq_card_chooseBasisIndex, ZLattice.rank ℝ L]\n  · rw [frontier_equivFun, volume_image_eq_volume_div_covolume', h₄, ENNReal.zero_div]\n    exact NullMeasurableSet.of_null h₄\n\n"}
