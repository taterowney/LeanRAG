{"name":"ZLattice.covolume_eq_measure_fundamentalDomain","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : FiniteDimensional Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\nL : Submodule Int E\ninst‚úù¬≤ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬π : IsZLattice Real L\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\ninst‚úù : MeasureTheory.Measure.IsAddHaarMeasure Œº\nF : Set E\nh : MeasureTheory.IsAddFundamentalDomain (Subtype fun x => Membership.mem L x) F Œº\n‚ä¢ Eq (ZLattice.covolume L Œº) (Œº F).toReal","decl":"theorem covolume_eq_measure_fundamentalDomain {F : Set E} (h : IsAddFundamentalDomain L F Œº) :\n    covolume L Œº = (Œº F).toReal := by\n  have : MeasurableVAdd L E := (inferInstance : MeasurableVAdd L.toAddSubgroup E)\n  have : VAddInvariantMeasure L E Œº := (inferInstance : VAddInvariantMeasure L.toAddSubgroup E Œº)\n  exact congr_arg ENNReal.toReal (h.covolume_eq_volume Œº)\n\n"}
{"name":"ZLattice.covolume_ne_zero","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : FiniteDimensional Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\nL : Submodule Int E\ninst‚úù¬≤ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬π : IsZLattice Real L\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\ninst‚úù : MeasureTheory.Measure.IsAddHaarMeasure Œº\n‚ä¢ Ne (ZLattice.covolume L Œº) 0","decl":"theorem covolume_ne_zero : covolume L Œº ‚â† 0 := by\n  rw [covolume_eq_measure_fundamentalDomain L Œº (isAddFundamentalDomain (Free.chooseBasis ‚Ñ§ L) Œº),\n    ENNReal.toReal_ne_zero]\n  refine ‚ü®measure_fundamentalDomain_ne_zero _, ne_of_lt ?_‚ü©\n  exact Bornology.IsBounded.measure_lt_top (fundamentalDomain_isBounded _)\n\n"}
{"name":"ZLattice.covolume_pos","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\ninst‚úù‚Åµ : FiniteDimensional Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\nL : Submodule Int E\ninst‚úù¬≤ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬π : IsZLattice Real L\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\ninst‚úù : MeasureTheory.Measure.IsAddHaarMeasure Œº\n‚ä¢ LT.lt 0 (ZLattice.covolume L Œº)","decl":"theorem covolume_pos : 0 < covolume L Œº :=\n  lt_of_le_of_ne ENNReal.toReal_nonneg (covolume_ne_zero L Œº).symm\n\n"}
{"name":"ZLattice.covolume_comap","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù¬π¬≥ : NormedAddCommGroup E\ninst‚úù¬π¬≤ : NormedSpace Real E\ninst‚úù¬π¬π : FiniteDimensional Real E\ninst‚úù¬π‚Å∞ : MeasurableSpace E\ninst‚úù‚Åπ : BorelSpace E\nL : Submodule Int E\ninst‚úù‚Å∏ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù‚Å∑ : IsZLattice Real L\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\ninst‚úù‚Å∂ : MeasureTheory.Measure.IsAddHaarMeasure Œº\nF : Type u_2\ninst‚úù‚Åµ : NormedAddCommGroup F\ninst‚úù‚Å¥ : NormedSpace Real F\ninst‚úù¬≥ : FiniteDimensional Real F\ninst‚úù¬≤ : MeasurableSpace F\ninst‚úù¬π : BorelSpace F\nŒΩ : autoParam (MeasureTheory.Measure F) _auto‚úù\ninst‚úù : MeasureTheory.Measure.IsAddHaarMeasure ŒΩ\ne : ContinuousLinearEquiv (RingHom.id Real) F E\nhe : MeasureTheory.MeasurePreserving (‚áëe) ŒΩ Œº\n‚ä¢ Eq (ZLattice.covolume (ZLattice.comap Real L ‚Üëe.toLinearEquiv) ŒΩ) (ZLattice.covolume L Œº)","decl":"theorem covolume_comap {F : Type*} [NormedAddCommGroup F] [NormedSpace ‚Ñù F] [FiniteDimensional ‚Ñù F]\n    [MeasurableSpace F] [BorelSpace F] (ŒΩ : Measure F := by volume_tac) [Measure.IsAddHaarMeasure ŒΩ]\n    {e : F ‚âÉL[‚Ñù] E} (he : MeasurePreserving e ŒΩ Œº) :\n    covolume (ZLattice.comap ‚Ñù L e.toLinearMap) ŒΩ = covolume L Œº := by\n  rw [covolume_eq_measure_fundamentalDomain _ _ (isAddFundamentalDomain (Free.chooseBasis ‚Ñ§ L) Œº),\n    covolume_eq_measure_fundamentalDomain _ _ ((isAddFundamentalDomain\n    ((Free.chooseBasis ‚Ñ§ L).ofZLatticeComap ‚Ñù L e.toLinearEquiv) ŒΩ)), ‚Üê he.measure_preimage\n    (fundamentalDomain_measurableSet _).nullMeasurableSet, ‚Üê e.image_symm_eq_preimage,\n    ‚Üê e.symm.coe_toLinearEquiv, map_fundamentalDomain]\n  congr!\n  ext; simp\n\n"}
{"name":"ZLattice.covolume_eq_det_mul_measure","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Åπ : NormedAddCommGroup E\ninst‚úù‚Å∏ : NormedSpace Real E\ninst‚úù‚Å∑ : FiniteDimensional Real E\ninst‚úù‚Å∂ : MeasurableSpace E\ninst‚úù‚Åµ : BorelSpace E\nL : Submodule Int E\ninst‚úù‚Å¥ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬≥ : IsZLattice Real L\nŒº : autoParam (MeasureTheory.Measure E) _auto‚úù\ninst‚úù¬≤ : MeasureTheory.Measure.IsAddHaarMeasure Œº\nŒπ : Type u_2\ninst‚úù¬π : Fintype Œπ\ninst‚úù : DecidableEq Œπ\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\nb‚ÇÄ : Basis Œπ Real E\n‚ä¢ Eq (ZLattice.covolume L Œº) (HMul.hMul (abs (b‚ÇÄ.det (Function.comp Subtype.val ‚áëb))) (Œº (ZSpan.fundamentalDomain b‚ÇÄ)).toReal)","decl":"theorem covolume_eq_det_mul_measure {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ] (b : Basis Œπ ‚Ñ§ L)\n    (b‚ÇÄ : Basis Œπ ‚Ñù E) :\n    covolume L Œº = |b‚ÇÄ.det ((‚Üë) ‚àò b)| * (Œº (fundamentalDomain b‚ÇÄ)).toReal := by\n  rw [covolume_eq_measure_fundamentalDomain L Œº (isAddFundamentalDomain b Œº),\n    measure_fundamentalDomain _ _ b‚ÇÄ,\n    measure_congr (fundamentalDomain_ae_parallelepiped b‚ÇÄ Œº), ENNReal.toReal_mul,\n    ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext\n  exact b.ofZLatticeBasis_apply ‚Ñù L _\n\n"}
{"name":"ZLattice.covolume_eq_det","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"Œπ : Type u_2\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : DecidableEq Œπ\nL : Submodule Int (Œπ ‚Üí Real)\ninst‚úù¬π : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù : IsZLattice Real L\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\n‚ä¢ Eq (ZLattice.covolume L MeasureTheory.MeasureSpace.volume) (abs (Matrix.of (Function.comp Subtype.val ‚áëb)).det)","decl":"theorem covolume_eq_det {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ] (L : Submodule ‚Ñ§ (Œπ ‚Üí ‚Ñù))\n    [DiscreteTopology L] [IsZLattice ‚Ñù L] (b : Basis Œπ ‚Ñ§ L) :\n    covolume L = |(Matrix.of ((‚Üë) ‚àò b)).det| := by\n  rw [covolume_eq_measure_fundamentalDomain L volume (isAddFundamentalDomain b volume),\n    volume_fundamentalDomain, ENNReal.toReal_ofReal (by positivity)]\n  congr\n  ext1\n  exact b.ofZLatticeBasis_apply ‚Ñù L _\n\n"}
{"name":"ZLattice.covolume_eq_det_inv","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"Œπ : Type u_2\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : DecidableEq Œπ\nL : Submodule Int (Œπ ‚Üí Real)\ninst‚úù¬π : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù : IsZLattice Real L\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\n‚ä¢ Eq (ZLattice.covolume L MeasureTheory.MeasureSpace.volume) (Inv.inv (abs ‚Üë(LinearEquiv.det (Basis.ofZLatticeBasis Real L b).equivFun)))","decl":"theorem covolume_eq_det_inv {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ] (L : Submodule ‚Ñ§ (Œπ ‚Üí ‚Ñù))\n    [DiscreteTopology L] [IsZLattice ‚Ñù L] (b : Basis Œπ ‚Ñ§ L) :\n    covolume L = |(LinearEquiv.det (b.ofZLatticeBasis ‚Ñù L).equivFun : ‚Ñù)|‚Åª¬π := by\n  rw [covolume_eq_det L b, ‚Üê Pi.basisFun_det_apply, show (((‚Üë) : L ‚Üí _) ‚àò ‚áëb) =\n    (b.ofZLatticeBasis ‚Ñù) by ext; simp, ‚Üê Basis.det_inv, ‚Üê abs_inv, Units.val_inv_eq_inv_val,\n    IsUnit.unit_spec, ‚Üê Basis.det_basis, LinearEquiv.coe_det]\n  rfl\n\n"}
{"name":"ZLattice.volume_image_eq_volume_div_covolume","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"Œπ : Type u_2\ninst‚úù¬≥ : Fintype Œπ\ninst‚úù¬≤ : DecidableEq Œπ\nL : Submodule Int (Œπ ‚Üí Real)\ninst‚úù¬π : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù : IsZLattice Real L\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\ns : Set (Œπ ‚Üí Real)\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.image (‚áë(Basis.ofZLatticeBasis Real L b).equivFun) s)) (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s) (ENNReal.ofReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"theorem volume_image_eq_volume_div_covolume {Œπ : Type*} [Fintype Œπ] [DecidableEq Œπ]\n    (L : Submodule ‚Ñ§ (Œπ ‚Üí ‚Ñù)) [DiscreteTopology L] [IsZLattice ‚Ñù L] (b : Basis Œπ ‚Ñ§ L)\n    {s : Set (Œπ ‚Üí ‚Ñù)} :\n    volume ((b.ofZLatticeBasis ‚Ñù L).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  rw [LinearEquiv.image_eq_preimage, Measure.addHaar_preimage_linearEquiv, LinearEquiv.symm_symm,\n    covolume_eq_det_inv L b, ENNReal.div_eq_inv_mul, ENNReal.ofReal_inv_of_pos\n    (abs_pos.mpr (LinearEquiv.det _).ne_zero), inv_inv, LinearEquiv.coe_det]\n\n"}
{"name":"ZLattice.volume_image_eq_volume_div_covolume'","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_2\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : InnerProductSpace Real E\ninst‚úù‚Åµ : FiniteDimensional Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\nL : Submodule Int E\ninst‚úù¬≤ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬π : IsZLattice Real L\nŒπ : Type u_3\ninst‚úù : Fintype Œπ\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\ns : Set E\nhs : MeasureTheory.NullMeasurableSet s MeasureTheory.MeasureSpace.volume\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.image (‚áë(Basis.ofZLatticeBasis Real L b).equivFun) s)) (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s) (ENNReal.ofReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"/-- A more general version of `ZLattice.volume_image_eq_volume_div_covolume`;\nsee the `Naming conventions` section in the introduction. -/\ntheorem volume_image_eq_volume_div_covolume' {E : Type*} [NormedAddCommGroup E]\n    [InnerProductSpace ‚Ñù E] [FiniteDimensional ‚Ñù E] [MeasurableSpace E] [BorelSpace E]\n    (L : Submodule ‚Ñ§ E) [DiscreteTopology L] [IsZLattice ‚Ñù L] {Œπ : Type*} [Fintype Œπ]\n    (b : Basis Œπ ‚Ñ§ L) {s : Set E} (hs : NullMeasurableSet s) :\n    volume ((b.ofZLatticeBasis ‚Ñù).equivFun '' s) = volume s / ENNReal.ofReal (covolume L) := by\n  classical\n  let e : Fin (finrank ‚Ñù E) ‚âÉ Œπ :=\n    Fintype.equivOfCardEq (by rw [Fintype.card_fin, finrank_eq_card_basis (b.ofZLatticeBasis ‚Ñù)])\n  let f := (EuclideanSpace.equiv Œπ ‚Ñù).symm.trans\n    ((stdOrthonormalBasis ‚Ñù E).reindex e).repr.toContinuousLinearEquiv.symm\n  have hf : MeasurePreserving f :=\n    ((stdOrthonormalBasis ‚Ñù E).reindex e).measurePreserving_repr_symm.comp\n      (EuclideanSpace.volume_preserving_measurableEquiv Œπ).symm\n  rw [‚Üê hf.measure_preimage hs, ‚Üê (covolume_comap L volume volume hf),\n    ‚Üê volume_image_eq_volume_div_covolume (ZLattice.comap ‚Ñù L f.toLinearMap)\n    (b.ofZLatticeComap ‚Ñù L f.toLinearEquiv), Basis.ofZLatticeBasis_comap,\n    ‚Üê f.image_symm_eq_preimage, ‚Üê Set.image_comp]\n  simp only [Basis.equivFun_apply, ContinuousLinearEquiv.symm_toLinearEquiv, Basis.map_equivFun,\n    LinearEquiv.symm_symm, Function.comp_apply, LinearEquiv.trans_apply,\n    ContinuousLinearEquiv.coe_toLinearEquiv, ContinuousLinearEquiv.apply_symm_apply]\n\n"}
{"name":"ZLattice.covolume.tendsto_card_div_pow''","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : NormedSpace Real E\nL : Submodule Int E\ninst‚úù‚Åµ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù‚Å¥ : IsZLattice Real L\nŒπ : Type u_2\ninst‚úù¬≥ : Fintype Œπ\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\ninst‚úù¬≤ : FiniteDimensional Real E\ninst‚úù¬π : MeasurableSpace E\ninst‚úù : BorelSpace E\ns : Set E\nhs‚ÇÅ : Bornology.IsBounded s\nhs‚ÇÇ : MeasurableSet s\nhs‚ÇÉ : Eq (MeasureTheory.MeasureSpace.volume (frontier (Set.image (‚áë(Basis.ofZLatticeBasis Real L b).equivFun) s))) 0\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (‚Üë(Nat.card ‚Üë(Inter.inter s (HSMul.hSMul (Inv.inv ‚Üën) ‚ÜëL)))) (HPow.hPow (‚Üën) (Fintype.card Œπ))) Filter.atTop (nhds (MeasureTheory.MeasureSpace.volume (Set.image (‚áë(Basis.ofZLatticeBasis Real L b).equivFun) s)).toReal)","decl":"/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the general case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow'' [FiniteDimensional ‚Ñù E] [MeasurableSpace E] [BorelSpace E]\n    {s : Set E} (hs‚ÇÅ : IsBounded s) (hs‚ÇÇ : MeasurableSet s)\n    (hs‚ÇÉ : volume (frontier ((b.ofZLatticeBasis ‚Ñù).equivFun '' s)) = 0):\n    Tendsto (fun n : ‚Ñï ‚Ü¶ (Nat.card (s ‚à© (n : ‚Ñù)‚Åª¬π ‚Ä¢ L : Set E) : ‚Ñù) / n ^ card Œπ)\n      atTop (ùìù (volume ((b.ofZLatticeBasis ‚Ñù).equivFun '' s)).toReal) := by\n  refine Tendsto.congr' ?_\n    (tendsto_card_div_pow_atTop_volume ((b.ofZLatticeBasis ‚Ñù).equivFun '' s) ?_ ?_ hs‚ÇÉ)\n  ¬∑ filter_upwards [eventually_gt_atTop 0] with n hn\n    congr\n    refine Nat.card_congr <| ((b.ofZLatticeBasis ‚Ñù).equivFun.toEquiv.subtypeEquiv fun x ‚Ü¶ ?_).symm\n    simp_rw [Set.mem_inter_iff, ‚Üê b.ofZLatticeBasis_span ‚Ñù, LinearEquiv.coe_toEquiv,\n      Basis.equivFun_apply, Set.mem_image, DFunLike.coe_fn_eq, EmbeddingLike.apply_eq_iff_eq,\n      exists_eq_right, and_congr_right_iff, Set.mem_inv_smul_set_iff‚ÇÄ\n      (mod_cast hn.ne' : (n : ‚Ñù) ‚â† 0), ‚Üê Finsupp.coe_smul, ‚Üê LinearEquiv.map_smul, SetLike.mem_coe,\n      Basis.mem_span_iff_repr_mem, Pi.basisFun_repr, implies_true]\n  ¬∑ rw [‚Üê NormedSpace.isVonNBounded_iff ‚Ñù] at hs‚ÇÅ ‚ä¢\n    exact Bornology.IsVonNBounded.image hs‚ÇÅ ((b.ofZLatticeBasis ‚Ñù).equivFunL : E ‚ÜíL[‚Ñù] Œπ ‚Üí ‚Ñù)\n  ¬∑ exact (b.ofZLatticeBasis ‚Ñù).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr hs‚ÇÇ\n\n"}
{"name":"ZLattice.covolume.tendsto_card_le_div''","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∏ : NormedAddCommGroup E\ninst‚úù‚Å∑ : NormedSpace Real E\nL : Submodule Int E\ninst‚úù‚Å∂ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù‚Åµ : IsZLattice Real L\nŒπ : Type u_2\ninst‚úù‚Å¥ : Fintype Œπ\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\ninst‚úù¬≥ : FiniteDimensional Real E\ninst‚úù¬≤ : MeasurableSpace E\ninst‚úù¬π : BorelSpace E\ninst‚úù : Nonempty Œπ\nX : Set E\nhX : ‚àÄ ‚¶Éx : E‚¶Ñ ‚¶Ér : Real‚¶Ñ, Membership.mem X x ‚Üí LT.lt 0 r ‚Üí Membership.mem X (HSMul.hSMul r x)\nF : E ‚Üí Real\nh‚ÇÅ : ‚àÄ (x : E) ‚¶Ér : Real‚¶Ñ, LE.le 0 r ‚Üí Eq (F (HSMul.hSMul r x)) (HMul.hMul (HPow.hPow r (Fintype.card Œπ)) (F x))\nh‚ÇÇ : Bornology.IsBounded (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh‚ÇÉ : MeasurableSet (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh‚ÇÑ : Eq (MeasureTheory.MeasureSpace.volume (frontier (Set.image (‚áë(Basis.ofZLatticeBasis Real L b).equivFun) (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))))) 0\n‚ä¢ Filter.Tendsto (fun c => HDiv.hDiv (‚Üë(Nat.card ‚Üë(Inter.inter (setOf fun x => And (Membership.mem X x) (LE.le (F x) c)) ‚ÜëL))) c) Filter.atTop (nhds (MeasureTheory.MeasureSpace.volume (Set.image (‚áë(Basis.ofZLatticeBasis Real L b).equivFun) (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1)))).toReal)","decl":"/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the general case;\nsee the `Naming conventions` section in the introduction. -/\ntheorem tendsto_card_le_div'' [FiniteDimensional ‚Ñù E] [MeasurableSpace E] [BorelSpace E]\n    [Nonempty Œπ] {X : Set E} (hX : ‚àÄ ‚¶Éx‚¶Ñ ‚¶Ér : ‚Ñù‚¶Ñ, x ‚àà X ‚Üí 0 < r ‚Üí r ‚Ä¢ x ‚àà X)\n    {F : E ‚Üí ‚Ñù} (h‚ÇÅ : ‚àÄ x ‚¶Ér : ‚Ñù‚¶Ñ, 0 ‚â§ r ‚Üí  F (r ‚Ä¢ x) = r ^ card Œπ * (F x))\n    (h‚ÇÇ : IsBounded {x ‚àà X | F x ‚â§ 1}) (h‚ÇÉ : MeasurableSet {x ‚àà X | F x ‚â§ 1})\n    (h‚ÇÑ : volume (frontier ((b.ofZLatticeBasis ‚Ñù L).equivFun '' {x | x ‚àà X ‚àß F x ‚â§ 1})) = 0) :\n    Tendsto (fun c : ‚Ñù ‚Ü¶\n      Nat.card ({x ‚àà X | F x ‚â§ c} ‚à© L : Set E) / (c : ‚Ñù))\n        atTop (ùìù (volume ((b.ofZLatticeBasis ‚Ñù).equivFun '' {x ‚àà X | F x ‚â§ 1})).toReal) := by\n\n  refine Tendsto.congr' ?_ <| (tendsto_card_div_pow_atTop_volume'\n      ((b.ofZLatticeBasis ‚Ñù).equivFun '' {x ‚àà X | F x ‚â§ 1}) ?_ ?_ h‚ÇÑ fun x y hx hy ‚Ü¶ ?_).comp\n        (tendsto_rpow_atTop <| inv_pos.mpr\n          (Nat.cast_pos.mpr card_pos) : Tendsto (fun x ‚Ü¶ x ^ (card Œπ : ‚Ñù)‚Åª¬π) atTop atTop)\n  ¬∑ filter_upwards [eventually_gt_atTop 0] with c hc\n    have aux‚ÇÅ : (card Œπ : ‚Ñù) ‚â† 0 := Nat.cast_ne_zero.mpr card_ne_zero\n    have aux‚ÇÇ : 0 < c ^ (card Œπ : ‚Ñù)‚Åª¬π := Real.rpow_pos_of_pos hc _\n    have aux‚ÇÉ : (c ^ (card Œπ : ‚Ñù)‚Åª¬π)‚Åª¬π ‚â† 0 := inv_ne_zero aux‚ÇÇ.ne'\n    have aux‚ÇÑ : c ^ (-(card Œπ : ‚Ñù)‚Åª¬π) ‚â† 0 := (Real.rpow_pos_of_pos hc _).ne'\n    obtain ‚ü®hc‚ÇÅ, hc‚ÇÇ‚ü© := lt_iff_le_and_ne.mp hc\n    rw [Function.comp_apply, ‚Üê Real.rpow_natCast, Real.rpow_inv_rpow hc‚ÇÅ aux‚ÇÅ, eq_comm]\n    congr\n    refine Nat.card_congr <| Equiv.subtypeEquiv ((b.ofZLatticeBasis ‚Ñù).equivFun.toEquiv.trans\n          (Equiv.smulRight aux‚ÇÑ)) fun _ ‚Ü¶ ?_\n    rw [Set.mem_inter_iff, Set.mem_inter_iff, Equiv.trans_apply, LinearEquiv.coe_toEquiv,\n      Equiv.smulRight_apply, Real.rpow_neg hc‚ÇÅ, Set.smul_mem_smul_set_iff‚ÇÄ aux‚ÇÉ,\n      ‚Üê Set.mem_smul_set_iff_inv_smul_mem‚ÇÄ aux‚ÇÇ.ne', ‚Üê image_smul_set,\n      tendsto_card_le_div''_aux hX h‚ÇÅ aux‚ÇÇ, ‚Üê Real.rpow_natCast, ‚Üê Real.rpow_mul hc‚ÇÅ,\n      inv_mul_cancel‚ÇÄ aux‚ÇÅ, Real.rpow_one]\n    simp_rw [SetLike.mem_coe, Set.mem_image, EmbeddingLike.apply_eq_iff_eq, exists_eq_right,\n      and_congr_right_iff, ‚Üê b.ofZLatticeBasis_span ‚Ñù, Basis.mem_span_iff_repr_mem,\n      Pi.basisFun_repr, Basis.equivFun_apply, implies_true]\n  ¬∑ rw [‚Üê NormedSpace.isVonNBounded_iff ‚Ñù] at h‚ÇÇ ‚ä¢\n    exact Bornology.IsVonNBounded.image h‚ÇÇ ((b.ofZLatticeBasis ‚Ñù).equivFunL : E ‚ÜíL[‚Ñù] Œπ ‚Üí ‚Ñù)\n  ¬∑ exact (b.ofZLatticeBasis ‚Ñù).equivFunL.toHomeomorph.toMeasurableEquiv.measurableSet_image.mpr h‚ÇÉ\n  ¬∑ simp_rw [‚Üê image_smul_set]\n    apply Set.image_mono\n    rw [tendsto_card_le_div''_aux hX h‚ÇÅ hx,\n      tendsto_card_le_div''_aux hX h‚ÇÅ (lt_of_lt_of_le hx hy)]\n    exact fun a ‚ü®ha‚ÇÅ, ha‚ÇÇ‚ü© ‚Ü¶ ‚ü®ha‚ÇÅ, le_trans ha‚ÇÇ <| pow_le_pow_left‚ÇÄ (le_of_lt hx) hy _‚ü©\n\n"}
{"name":"ZLattice.covolume.tendsto_card_div_pow","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"Œπ : Type u_1\ninst‚úù¬≤ : Fintype Œπ\nL : Submodule Int (Œπ ‚Üí Real)\ninst‚úù¬π : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù : IsZLattice Real L\nb : Basis Œπ Int (Subtype fun x => Membership.mem L x)\ns : Set (Œπ ‚Üí Real)\nhs‚ÇÅ : Bornology.IsBounded s\nhs‚ÇÇ : MeasurableSet s\nhs‚ÇÉ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (‚Üë(Nat.card ‚Üë(Inter.inter s (HSMul.hSMul (Inv.inv ‚Üën) ‚ÜëL)))) (HPow.hPow (‚Üën) (Fintype.card Œπ))) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"theorem tendsto_card_div_pow (b : Basis Œπ ‚Ñ§ L) {s : Set (Œπ ‚Üí ‚Ñù)} (hs‚ÇÅ : IsBounded s)\n    (hs‚ÇÇ : MeasurableSet s) (hs‚ÇÉ : volume (frontier s) = 0) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ (Nat.card (s ‚à© (n : ‚Ñù)‚Åª¬π ‚Ä¢ L : Set (Œπ ‚Üí ‚Ñù)) : ‚Ñù) / n ^ card Œπ)\n      atTop (ùìù ((volume s).toReal / covolume L)) := by\n  classical\n  convert tendsto_card_div_pow'' b hs‚ÇÅ hs‚ÇÇ ?_\n  ¬∑ rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  ¬∑ rw [frontier_equivFun, volume_image_eq_volume_div_covolume, hs‚ÇÉ, ENNReal.zero_div]\n\n"}
{"name":"ZLattice.covolume.tendsto_card_le_div","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"Œπ : Type u_1\ninst‚úù¬≥ : Fintype Œπ\nL : Submodule Int (Œπ ‚Üí Real)\ninst‚úù¬≤ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬π : IsZLattice Real L\nX : Set (Œπ ‚Üí Real)\nhX : ‚àÄ ‚¶Éx : Œπ ‚Üí Real‚¶Ñ ‚¶Ér : Real‚¶Ñ, Membership.mem X x ‚Üí LT.lt 0 r ‚Üí Membership.mem X (HSMul.hSMul r x)\nF : (Œπ ‚Üí Real) ‚Üí Real\nh‚ÇÅ : ‚àÄ (x : Œπ ‚Üí Real) ‚¶Ér : Real‚¶Ñ, LE.le 0 r ‚Üí Eq (F (HSMul.hSMul r x)) (HMul.hMul (HPow.hPow r (Fintype.card Œπ)) (F x))\nh‚ÇÇ : Bornology.IsBounded (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh‚ÇÉ : MeasurableSet (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh‚ÇÑ : Eq (MeasureTheory.MeasureSpace.volume (frontier (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1)))) 0\ninst‚úù : Nonempty Œπ\n‚ä¢ Filter.Tendsto (fun c => HDiv.hDiv (‚Üë(Nat.card ‚Üë(Inter.inter (setOf fun x => And (Membership.mem X x) (LE.le (F x) c)) ‚ÜëL))) c) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"theorem tendsto_card_le_div {X : Set (Œπ ‚Üí ‚Ñù)} (hX : ‚àÄ ‚¶Éx‚¶Ñ ‚¶Ér : ‚Ñù‚¶Ñ, x ‚àà X ‚Üí 0 < r ‚Üí r ‚Ä¢ x ‚àà X)\n    {F : (Œπ ‚Üí ‚Ñù) ‚Üí ‚Ñù} (h‚ÇÅ : ‚àÄ x ‚¶Ér : ‚Ñù‚¶Ñ, 0 ‚â§ r ‚Üí  F (r ‚Ä¢ x) = r ^ card Œπ * (F x))\n    (h‚ÇÇ : IsBounded {x ‚àà X | F x ‚â§ 1}) (h‚ÇÉ : MeasurableSet {x ‚àà X | F x ‚â§ 1})\n    (h‚ÇÑ : volume (frontier {x | x ‚àà X ‚àß F x ‚â§ 1}) = 0) [Nonempty Œπ] :\n    Tendsto (fun c : ‚Ñù ‚Ü¶\n      Nat.card ({x ‚àà X | F x ‚â§ c} ‚à© L : Set (Œπ ‚Üí ‚Ñù)) / (c : ‚Ñù))\n        atTop (ùìù ((volume {x ‚àà X | F x ‚â§ 1}).toReal / covolume L)) := by\n  classical\n  let e : Free.ChooseBasisIndex ‚Ñ§ ‚Ü•L ‚âÉ Œπ := by\n    refine Fintype.equivOfCardEq ?_\n    rw [‚Üê finrank_eq_card_chooseBasisIndex, ZLattice.rank ‚Ñù, finrank_fintype_fun_eq_card]\n  let b := (Module.Free.chooseBasis ‚Ñ§ L).reindex e\n  convert tendsto_card_le_div'' b hX h‚ÇÅ h‚ÇÇ h‚ÇÉ ?_\n  ¬∑ rw [volume_image_eq_volume_div_covolume L b, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  ¬∑ rw [frontier_equivFun, volume_image_eq_volume_div_covolume, h‚ÇÑ, ENNReal.zero_div]\n\n"}
{"name":"ZLattice.covolume.tendsto_card_div_pow'","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∂ : NormedAddCommGroup E\ninst‚úù‚Åµ : InnerProductSpace Real E\ninst‚úù‚Å¥ : FiniteDimensional Real E\ninst‚úù¬≥ : MeasurableSpace E\ninst‚úù¬≤ : BorelSpace E\nL : Submodule Int E\ninst‚úù¬π : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù : IsZLattice Real L\ns : Set E\nhs‚ÇÅ : Bornology.IsBounded s\nhs‚ÇÇ : MeasurableSet s\nhs‚ÇÉ : Eq (MeasureTheory.MeasureSpace.volume (frontier s)) 0\n‚ä¢ Filter.Tendsto (fun n => HDiv.hDiv (‚Üë(Nat.card ‚Üë(Inter.inter s (HSMul.hSMul (Inv.inv ‚Üën) ‚ÜëL)))) (HPow.hPow (‚Üën) (Module.finrank Real E))) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume s).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"/-- A version of `ZLattice.covolume.tendsto_card_div_pow` for the `InnerProductSpace` case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_div_pow' {s : Set E} (hs‚ÇÅ : IsBounded s) (hs‚ÇÇ : MeasurableSet s)\n    (hs‚ÇÉ : volume (frontier s) = 0) :\n    Tendsto (fun n : ‚Ñï ‚Ü¶ (Nat.card (s ‚à© (n : ‚Ñù)‚Åª¬π ‚Ä¢ L : Set E) : ‚Ñù) / n ^ finrank ‚Ñù E)\n      atTop (ùìù ((volume s).toReal / covolume L)) := by\n  let b := Module.Free.chooseBasis ‚Ñ§ L\n  convert tendsto_card_div_pow'' b hs‚ÇÅ hs‚ÇÇ ?_\n  ¬∑ rw [‚Üê finrank_eq_card_chooseBasisIndex, ZLattice.rank ‚Ñù L]\n  ¬∑ rw [volume_image_eq_volume_div_covolume' L b hs‚ÇÇ.nullMeasurableSet, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  ¬∑ rw [frontier_equivFun, volume_image_eq_volume_div_covolume', hs‚ÇÉ, ENNReal.zero_div]\n    exact NullMeasurableSet.of_null hs‚ÇÉ\n\n"}
{"name":"ZLattice.covolume.tendsto_card_le_div'","module":"Mathlib.Algebra.Module.ZLattice.Covolume","initialProofState":"E : Type u_1\ninst‚úù‚Å∑ : NormedAddCommGroup E\ninst‚úù‚Å∂ : InnerProductSpace Real E\ninst‚úù‚Åµ : FiniteDimensional Real E\ninst‚úù‚Å¥ : MeasurableSpace E\ninst‚úù¬≥ : BorelSpace E\nL : Submodule Int E\ninst‚úù¬≤ : DiscreteTopology (Subtype fun x => Membership.mem L x)\ninst‚úù¬π : IsZLattice Real L\ninst‚úù : Nontrivial E\nX : Set E\nF : E ‚Üí Real\nhX : ‚àÄ ‚¶Éx : E‚¶Ñ ‚¶Ér : Real‚¶Ñ, Membership.mem X x ‚Üí LT.lt 0 r ‚Üí Membership.mem X (HSMul.hSMul r x)\nh‚ÇÅ : ‚àÄ (x : E) ‚¶Ér : Real‚¶Ñ, LE.le 0 r ‚Üí Eq (F (HSMul.hSMul r x)) (HMul.hMul (HPow.hPow r (Module.finrank Real E)) (F x))\nh‚ÇÇ : Bornology.IsBounded (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh‚ÇÉ : MeasurableSet (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))\nh‚ÇÑ : Eq (MeasureTheory.MeasureSpace.volume (frontier (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1)))) 0\n‚ä¢ Filter.Tendsto (fun c => HDiv.hDiv (‚Üë(Nat.card ‚Üë(Inter.inter (setOf fun x => And (Membership.mem X x) (LE.le (F x) c)) ‚ÜëL))) c) Filter.atTop (nhds (HDiv.hDiv (MeasureTheory.MeasureSpace.volume (setOf fun x => And (Membership.mem X x) (LE.le (F x) 1))).toReal (ZLattice.covolume L MeasureTheory.MeasureSpace.volume)))","decl":"/-- A version of `ZLattice.covolume.tendsto_card_le_div` for the `InnerProductSpace` case;\nsee the `Naming convention` section in the introduction. -/\ntheorem tendsto_card_le_div' [Nontrivial E] {X : Set E} {F : E ‚Üí ‚Ñù}\n    (hX : ‚àÄ ‚¶Éx‚¶Ñ ‚¶Ér : ‚Ñù‚¶Ñ, x ‚àà X ‚Üí 0 < r ‚Üí r ‚Ä¢ x ‚àà X)\n    (h‚ÇÅ : ‚àÄ x ‚¶Ér : ‚Ñù‚¶Ñ, 0 ‚â§ r ‚Üí  F (r ‚Ä¢ x) = r ^ finrank ‚Ñù E * (F x))\n    (h‚ÇÇ : IsBounded {x ‚àà X | F x ‚â§ 1}) (h‚ÇÉ : MeasurableSet {x ‚àà X | F x ‚â§ 1})\n    (h‚ÇÑ : volume (frontier {x ‚àà X | F x ‚â§ 1}) = 0) :\n    Tendsto (fun c : ‚Ñù ‚Ü¶\n      Nat.card ({x ‚àà X | F x ‚â§ c} ‚à© L : Set E) / (c : ‚Ñù))\n        atTop (ùìù ((volume {x ‚àà X | F x ‚â§ 1}).toReal / covolume L)) := by\n  let b := Module.Free.chooseBasis ‚Ñ§ L\n  convert tendsto_card_le_div'' b hX ?_ h‚ÇÇ h‚ÇÉ ?_\n  ¬∑ rw [volume_image_eq_volume_div_covolume' L b h‚ÇÉ.nullMeasurableSet, ENNReal.toReal_div,\n      ENNReal.toReal_ofReal (covolume_pos L volume).le]\n  ¬∑ have : Nontrivial L := nontrivial_of_finrank_pos <| (ZLattice.rank ‚Ñù L).symm ‚ñ∏ finrank_pos\n    infer_instance\n  ¬∑ rwa [‚Üê finrank_eq_card_chooseBasisIndex, ZLattice.rank ‚Ñù L]\n  ¬∑ rw [frontier_equivFun, volume_image_eq_volume_div_covolume', h‚ÇÑ, ENNReal.zero_div]\n    exact NullMeasurableSet.of_null h‚ÇÑ\n\n"}
