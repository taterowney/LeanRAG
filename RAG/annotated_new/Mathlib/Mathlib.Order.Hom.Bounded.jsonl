{"name":"TopHom.mk.sizeOf_spec","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Top α\ninst✝² : Top β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\nmap_top' : Eq (toFun Top.top) Top.top\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_top' := map_top' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_top'))","decl":"/-- The type of `⊤`-preserving functions from `α` to `β`. -/\nstructure TopHom (α β : Type*) [Top α] [Top β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n\n"}
{"name":"TopHom.map_top'","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Top α\ninst✝ : Top β\nself : TopHom α β\n⊢ Eq (self.toFun Top.top) Top.top","decl":"/-- The type of `⊤`-preserving functions from `α` to `β`. -/\nstructure TopHom (α β : Type*) [Top α] [Top β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n\n"}
{"name":"TopHom.mk.inj","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Top α\ninst✝ : Top β\ntoFun✝ : α → β\nmap_top'✝ : Eq (toFun✝ Top.top) Top.top\ntoFun : α → β\nmap_top' : Eq (toFun Top.top) Top.top\nx✝ : Eq { toFun := toFun✝, map_top' := map_top'✝ } { toFun := toFun, map_top' := map_top' }\n⊢ Eq toFun✝ toFun","decl":"/-- The type of `⊤`-preserving functions from `α` to `β`. -/\nstructure TopHom (α β : Type*) [Top α] [Top β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n\n"}
{"name":"TopHom.mk.injEq","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Top α\ninst✝ : Top β\ntoFun✝ : α → β\nmap_top'✝ : Eq (toFun✝ Top.top) Top.top\ntoFun : α → β\nmap_top' : Eq (toFun Top.top) Top.top\n⊢ Eq (Eq { toFun := toFun✝, map_top' := map_top'✝ } { toFun := toFun, map_top' := map_top' }) (Eq toFun✝ toFun)","decl":"/-- The type of `⊤`-preserving functions from `α` to `β`. -/\nstructure TopHom (α β : Type*) [Top α] [Top β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n\n"}
{"name":"BotHom.mk.injEq","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Bot α\ninst✝ : Bot β\ntoFun✝ : α → β\nmap_bot'✝ : Eq (toFun✝ Bot.bot) Bot.bot\ntoFun : α → β\nmap_bot' : Eq (toFun Bot.bot) Bot.bot\n⊢ Eq (Eq { toFun := toFun✝, map_bot' := map_bot'✝ } { toFun := toFun, map_bot' := map_bot' }) (Eq toFun✝ toFun)","decl":"/-- The type of `⊥`-preserving functions from `α` to `β`. -/\nstructure BotHom (α β : Type*) [Bot α] [Bot β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BotHom.mk.inj","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Bot α\ninst✝ : Bot β\ntoFun✝ : α → β\nmap_bot'✝ : Eq (toFun✝ Bot.bot) Bot.bot\ntoFun : α → β\nmap_bot' : Eq (toFun Bot.bot) Bot.bot\nx✝ : Eq { toFun := toFun✝, map_bot' := map_bot'✝ } { toFun := toFun, map_bot' := map_bot' }\n⊢ Eq toFun✝ toFun","decl":"/-- The type of `⊥`-preserving functions from `α` to `β`. -/\nstructure BotHom (α β : Type*) [Bot α] [Bot β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BotHom.mk.sizeOf_spec","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Bot α\ninst✝² : Bot β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\nmap_bot' : Eq (toFun Bot.bot) Bot.bot\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, map_bot' := map_bot' }) (HAdd.hAdd 1 (SizeOf.sizeOf map_bot'))","decl":"/-- The type of `⊥`-preserving functions from `α` to `β`. -/\nstructure BotHom (α β : Type*) [Bot α] [Bot β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BotHom.map_bot'","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝¹ : Bot α\ninst✝ : Bot β\nself : BotHom α β\n⊢ Eq (self.toFun Bot.bot) Bot.bot","decl":"/-- The type of `⊥`-preserving functions from `α` to `β`. -/\nstructure BotHom (α β : Type*) [Bot α] [Bot β] where\n  /-- The underlying function. The preferred spelling is `DFunLike.coe`. -/\n  toFun : α → β\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHom.map_top'","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nself : BoundedOrderHom α β\n⊢ Eq (self.toFun Top.top) Top.top","decl":"/-- The type of bounded order homomorphisms from `α` to `β`. -/\nstructure BoundedOrderHom (α β : Type*) [Preorder α] [Preorder β] [BoundedOrder α]\n  [BoundedOrder β] extends OrderHom α β where\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHom.mk.inj","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\ntoOrderHom✝ : OrderHom α β\nmap_top'✝ : Eq (toOrderHom✝.toFun Top.top) Top.top\nmap_bot'✝ : Eq (toOrderHom✝.toFun Bot.bot) Bot.bot\ntoOrderHom : OrderHom α β\nmap_top' : Eq (toOrderHom.toFun Top.top) Top.top\nmap_bot' : Eq (toOrderHom.toFun Bot.bot) Bot.bot\nx✝ : Eq { toOrderHom := toOrderHom✝, map_top' := map_top'✝, map_bot' := map_bot'✝ } { toOrderHom := toOrderHom, map_top' := map_top', map_bot' := map_bot' }\n⊢ Eq toOrderHom✝ toOrderHom","decl":"/-- The type of bounded order homomorphisms from `α` to `β`. -/\nstructure BoundedOrderHom (α β : Type*) [Preorder α] [Preorder β] [BoundedOrder α]\n  [BoundedOrder β] extends OrderHom α β where\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHom.map_bot'","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nself : BoundedOrderHom α β\n⊢ Eq (self.toFun Bot.bot) Bot.bot","decl":"/-- The type of bounded order homomorphisms from `α` to `β`. -/\nstructure BoundedOrderHom (α β : Type*) [Preorder α] [Preorder β] [BoundedOrder α]\n  [BoundedOrder β] extends OrderHom α β where\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHom.mk.sizeOf_spec","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : BoundedOrder α\ninst✝² : BoundedOrder β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoOrderHom : OrderHom α β\nmap_top' : Eq (toOrderHom.toFun Top.top) Top.top\nmap_bot' : Eq (toOrderHom.toFun Bot.bot) Bot.bot\n⊢ Eq (SizeOf.sizeOf { toOrderHom := toOrderHom, map_top' := map_top', map_bot' := map_bot' }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toOrderHom)) (SizeOf.sizeOf map_top')) (SizeOf.sizeOf map_bot'))","decl":"/-- The type of bounded order homomorphisms from `α` to `β`. -/\nstructure BoundedOrderHom (α β : Type*) [Preorder α] [Preorder β] [BoundedOrder α]\n  [BoundedOrder β] extends OrderHom α β where\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHom.mk.injEq","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\ntoOrderHom✝ : OrderHom α β\nmap_top'✝ : Eq (toOrderHom✝.toFun Top.top) Top.top\nmap_bot'✝ : Eq (toOrderHom✝.toFun Bot.bot) Bot.bot\ntoOrderHom : OrderHom α β\nmap_top' : Eq (toOrderHom.toFun Top.top) Top.top\nmap_bot' : Eq (toOrderHom.toFun Bot.bot) Bot.bot\n⊢ Eq (Eq { toOrderHom := toOrderHom✝, map_top' := map_top'✝, map_bot' := map_bot'✝ } { toOrderHom := toOrderHom, map_top' := map_top', map_bot' := map_bot' }) (Eq toOrderHom✝ toOrderHom)","decl":"/-- The type of bounded order homomorphisms from `α` to `β`. -/\nstructure BoundedOrderHom (α β : Type*) [Preorder α] [Preorder β] [BoundedOrder α]\n  [BoundedOrder β] extends OrderHom α β where\n  /-- The function preserves the top element. The preferred spelling is `map_top`. -/\n  map_top' : toFun ⊤ = ⊤\n  /-- The function preserves the bottom element. The preferred spelling is `map_bot`. -/\n  map_bot' : toFun ⊥ = ⊥\n\n"}
{"name":"TopHomClass.map_top","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : Top α\ninst✝¹ : Top β\ninst✝ : FunLike F α β\nself : TopHomClass F α β\nf : F\n⊢ Eq (f Top.top) Top.top","decl":"/-- `TopHomClass F α β` states that `F` is a type of `⊤`-preserving morphisms.\n\nYou should extend this class when you extend `TopHom`. -/\nclass TopHomClass (F : Type*) (α β : outParam Type*) [Top α] [Top β] [FunLike F α β] :\n    Prop where\n  /-- A `TopHomClass` morphism preserves the top element. -/\n  map_top (f : F) : f ⊤ = ⊤\n\n"}
{"name":"BotHomClass.map_bot","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_6\nα : outParam (Type u_7)\nβ : outParam (Type u_8)\ninst✝² : Bot α\ninst✝¹ : Bot β\ninst✝ : FunLike F α β\nself : BotHomClass F α β\nf : F\n⊢ Eq (f Bot.bot) Bot.bot","decl":"/-- `BotHomClass F α β` states that `F` is a type of `⊥`-preserving morphisms.\n\nYou should extend this class when you extend `BotHom`. -/\nclass BotHomClass (F : Type*) (α β : outParam Type*) [Bot α] [Bot β] [FunLike F α β] :\n    Prop where\n  /-- A `BotHomClass` morphism preserves the bottom element. -/\n  map_bot (f : F) : f ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHomClass.toRelHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_6\nα : Type u_7\nβ : Type u_8\ninst✝⁴ : LE α\ninst✝³ : LE β\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : FunLike F α β\nself : BoundedOrderHomClass F α β\n⊢ RelHomClass F (fun x1 x2 => LE.le x1 x2) fun x1 x2 => LE.le x1 x2","decl":"/-- `BoundedOrderHomClass F α β` states that `F` is a type of bounded order morphisms.\n\nYou should extend this class when you extend `BoundedOrderHom`. -/\nclass BoundedOrderHomClass (F α β : Type*) [LE α] [LE β]\n  [BoundedOrder α] [BoundedOrder β] [FunLike F α β]\n  extends RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop) : Prop where\n  /-- Morphisms preserve the top element. The preferred spelling is `_root_.map_top`. -/\n  map_top (f : F) : f ⊤ = ⊤\n  /-- Morphisms preserve the bottom element. The preferred spelling is `_root_.map_bot`. -/\n  map_bot (f : F) : f ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHomClass.map_bot","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_6\nα : Type u_7\nβ : Type u_8\ninst✝⁴ : LE α\ninst✝³ : LE β\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : FunLike F α β\nself : BoundedOrderHomClass F α β\nf : F\n⊢ Eq (f Bot.bot) Bot.bot","decl":"/-- `BoundedOrderHomClass F α β` states that `F` is a type of bounded order morphisms.\n\nYou should extend this class when you extend `BoundedOrderHom`. -/\nclass BoundedOrderHomClass (F α β : Type*) [LE α] [LE β]\n  [BoundedOrder α] [BoundedOrder β] [FunLike F α β]\n  extends RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop) : Prop where\n  /-- Morphisms preserve the top element. The preferred spelling is `_root_.map_top`. -/\n  map_top (f : F) : f ⊤ = ⊤\n  /-- Morphisms preserve the bottom element. The preferred spelling is `_root_.map_bot`. -/\n  map_bot (f : F) : f ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHomClass.map_top","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_6\nα : Type u_7\nβ : Type u_8\ninst✝⁴ : LE α\ninst✝³ : LE β\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : FunLike F α β\nself : BoundedOrderHomClass F α β\nf : F\n⊢ Eq (f Top.top) Top.top","decl":"/-- `BoundedOrderHomClass F α β` states that `F` is a type of bounded order morphisms.\n\nYou should extend this class when you extend `BoundedOrderHom`. -/\nclass BoundedOrderHomClass (F α β : Type*) [LE α] [LE β]\n  [BoundedOrder α] [BoundedOrder β] [FunLike F α β]\n  extends RelHomClass F ((· ≤ ·) : α → α → Prop) ((· ≤ ·) : β → β → Prop) : Prop where\n  /-- Morphisms preserve the top element. The preferred spelling is `_root_.map_top`. -/\n  map_top (f : F) : f ⊤ = ⊤\n  /-- Morphisms preserve the bottom element. The preferred spelling is `_root_.map_bot`. -/\n  map_bot (f : F) : f ⊥ = ⊥\n\n"}
{"name":"BoundedOrderHomClass.toTopHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : FunLike F α β\ninst✝⁴ : LE α\ninst✝³ : LE β\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrderHomClass F α β\n⊢ TopHomClass F α β","decl":"instance (priority := 100) BoundedOrderHomClass.toTopHomClass [LE α] [LE β]\n    [BoundedOrder α] [BoundedOrder β] [BoundedOrderHomClass F α β] : TopHomClass F α β :=\n  { ‹BoundedOrderHomClass F α β› with }\n\n-- See note [lower instance priority]\n"}
{"name":"BoundedOrderHomClass.toBotHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : FunLike F α β\ninst✝⁴ : LE α\ninst✝³ : LE β\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrderHomClass F α β\n⊢ BotHomClass F α β","decl":"instance (priority := 100) BoundedOrderHomClass.toBotHomClass [LE α] [LE β]\n    [BoundedOrder α] [BoundedOrder β] [BoundedOrderHomClass F α β] : BotHomClass F α β :=\n  { ‹BoundedOrderHomClass F α β› with }\n\n"}
{"name":"OrderIsoClass.toTopHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : EquivLike F α β\ninst✝⁴ : LE α\ninst✝³ : OrderTop α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop β\ninst✝ : OrderIsoClass F α β\n⊢ TopHomClass F α β","decl":"instance (priority := 100) OrderIsoClass.toTopHomClass [LE α] [OrderTop α]\n    [PartialOrder β] [OrderTop β] [OrderIsoClass F α β] : TopHomClass F α β :=\n  { show OrderHomClass F α β from inferInstance with\n    map_top := fun f => top_le_iff.1 <| (map_inv_le_iff f).1 le_top }\n\n-- See note [lower instance priority]\n"}
{"name":"OrderIsoClass.toBotHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : EquivLike F α β\ninst✝⁴ : LE α\ninst✝³ : OrderBot α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot β\ninst✝ : OrderIsoClass F α β\n⊢ BotHomClass F α β","decl":"instance (priority := 100) OrderIsoClass.toBotHomClass [LE α] [OrderBot α]\n    [PartialOrder β] [OrderBot β] [OrderIsoClass F α β] : BotHomClass F α β :=\n  { map_bot := fun f => le_bot_iff.1 <| (le_map_inv_iff f).1 bot_le }\n\n-- See note [lower instance priority]\n"}
{"name":"OrderIsoClass.toBoundedOrderHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : EquivLike F α β\ninst✝⁴ : LE α\ninst✝³ : BoundedOrder α\ninst✝² : PartialOrder β\ninst✝¹ : BoundedOrder β\ninst✝ : OrderIsoClass F α β\n⊢ BoundedOrderHomClass F α β","decl":"instance (priority := 100) OrderIsoClass.toBoundedOrderHomClass [LE α] [BoundedOrder α]\n    [PartialOrder β] [BoundedOrder β] [OrderIsoClass F α β] : BoundedOrderHomClass F α β :=\n  { show OrderHomClass F α β from inferInstance, OrderIsoClass.toTopHomClass,\n    OrderIsoClass.toBotHomClass with }\n\n-- Porting note: the `letI` is needed because we can't make the\n-- `OrderTop` parameters instance implicit in `OrderIsoClass.toTopHomClass`,\n-- and they apparently can't be figured out through unification.\n"}
{"name":"map_eq_top_iff","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : EquivLike F α β\ninst✝⁴ : LE α\ninst✝³ : OrderTop α\ninst✝² : PartialOrder β\ninst✝¹ : OrderTop β\ninst✝ : OrderIsoClass F α β\nf : F\na : α\n⊢ Iff (Eq (f a) Top.top) (Eq a Top.top)","decl":"@[simp]\ntheorem map_eq_top_iff [LE α] [OrderTop α] [PartialOrder β] [OrderTop β] [OrderIsoClass F α β]\n    (f : F) {a : α} : f a = ⊤ ↔ a = ⊤ := by\n  letI : TopHomClass F α β := OrderIsoClass.toTopHomClass\n  rw [← map_top f, (EquivLike.injective f).eq_iff]\n\n-- Porting note: the `letI` is needed because we can't make the\n-- `OrderBot` parameters instance implicit in `OrderIsoClass.toBotHomClass`,\n-- and they apparently can't be figured out through unification.\n"}
{"name":"map_eq_bot_iff","module":"Mathlib.Order.Hom.Bounded","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : EquivLike F α β\ninst✝⁴ : LE α\ninst✝³ : OrderBot α\ninst✝² : PartialOrder β\ninst✝¹ : OrderBot β\ninst✝ : OrderIsoClass F α β\nf : F\na : α\n⊢ Iff (Eq (f a) Bot.bot) (Eq a Bot.bot)","decl":"@[simp]\ntheorem map_eq_bot_iff [LE α] [OrderBot α] [PartialOrder β] [OrderBot β] [OrderIsoClass F α β]\n    (f : F) {a : α} : f a = ⊥ ↔ a = ⊥ := by\n  letI : BotHomClass F α β := OrderIsoClass.toBotHomClass\n  rw [← map_bot f, (EquivLike.injective f).eq_iff]\n\n"}
{"name":"TopHom.instTopHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\n⊢ TopHomClass (TopHom α β) α β","decl":"instance : TopHomClass (TopHom α β) α β where\n  map_top := TopHom.map_top'\n\n-- this must come after the coe_to_fun definition\n"}
{"name":"TopHom.ext_iff","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\nf g : TopHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : TopHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"TopHom.ext","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\nf g : TopHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : TopHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"TopHom.coe_copy","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\nf : TopHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : TopHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"TopHom.copy_eq","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\nf : TopHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : TopHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"TopHom.coe_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝ : Top α\n⊢ Eq (⇑(TopHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(TopHom.id α) = id :=\n  rfl\n\n"}
{"name":"TopHom.id_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝ : Top α\na : α\n⊢ Eq ((TopHom.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : TopHom.id α a = a :=\n  rfl\n\n"}
{"name":"TopHom.coe_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Top α\ninst✝¹ : Top β\ninst✝ : Top γ\nf : TopHom β γ\ng : TopHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : TopHom β γ) (g : TopHom α β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"TopHom.comp_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Top α\ninst✝¹ : Top β\ninst✝ : Top γ\nf : TopHom β γ\ng : TopHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : TopHom β γ) (g : TopHom α β) (a : α) : (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"TopHom.comp_assoc","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝³ : Top α\ninst✝² : Top β\ninst✝¹ : Top γ\ninst✝ : Top δ\nf : TopHom γ δ\ng : TopHom β γ\nh : TopHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : TopHom γ δ) (g : TopHom β γ) (h : TopHom α β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"TopHom.comp_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\nf : TopHom α β\n⊢ Eq (f.comp (TopHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : TopHom α β) : f.comp (TopHom.id α) = f :=\n  TopHom.ext fun _ => rfl\n\n"}
{"name":"TopHom.id_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Top α\ninst✝ : Top β\nf : TopHom α β\n⊢ Eq ((TopHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : TopHom α β) : (TopHom.id β).comp f = f :=\n  TopHom.ext fun _ => rfl\n\n"}
{"name":"TopHom.cancel_right","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Top α\ninst✝¹ : Top β\ninst✝ : Top γ\ng₁ g₂ : TopHom β γ\nf : TopHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : TopHom β γ} {f : TopHom α β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => TopHom.ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, congr_arg (fun g => comp g f)⟩\n\n"}
{"name":"TopHom.cancel_left","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Top α\ninst✝¹ : Top β\ninst✝ : Top γ\ng : TopHom β γ\nf₁ f₂ : TopHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : TopHom β γ} {f₁ f₂ : TopHom α β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => TopHom.ext fun a => hg <| by rw [← TopHom.comp_apply, h, TopHom.comp_apply],\n    congr_arg _⟩\n\n"}
{"name":"TopHom.coe_top","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Top α\ninst✝¹ : LE β\ninst✝ : OrderTop β\n⊢ Eq (⇑Top.top) Top.top","decl":"@[simp]\ntheorem coe_top : ⇑(⊤ : TopHom α β) = ⊤ :=\n  rfl\n\n"}
{"name":"TopHom.top_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Top α\ninst✝¹ : LE β\ninst✝ : OrderTop β\na : α\n⊢ Eq (Top.top a) Top.top","decl":"@[simp]\ntheorem top_apply (a : α) : (⊤ : TopHom α β) a = ⊤ :=\n  rfl\n\n"}
{"name":"TopHom.coe_inf","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Top α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\nf g : TopHom α β\n⊢ Eq (⇑(Min.min f g)) (Min.min ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_inf : ⇑(f ⊓ g) = ⇑f ⊓ ⇑g :=\n  rfl\n\n"}
{"name":"TopHom.inf_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Top α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderTop β\nf g : TopHom α β\na : α\n⊢ Eq ((Min.min f g) a) (Min.min (f a) (g a))","decl":"@[simp]\ntheorem inf_apply (a : α) : (f ⊓ g) a = f a ⊓ g a :=\n  rfl\n\n"}
{"name":"TopHom.coe_sup","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Top α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderTop β\nf g : TopHom α β\n⊢ Eq (⇑(Max.max f g)) (Max.max ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_sup : ⇑(f ⊔ g) = ⇑f ⊔ ⇑g :=\n  rfl\n\n"}
{"name":"TopHom.sup_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Top α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderTop β\nf g : TopHom α β\na : α\n⊢ Eq ((Max.max f g) a) (Max.max (f a) (g a))","decl":"@[simp]\ntheorem sup_apply (a : α) : (f ⊔ g) a = f a ⊔ g a :=\n  rfl\n\n"}
{"name":"BotHom.instBotHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\n⊢ BotHomClass (BotHom α β) α β","decl":"instance : BotHomClass (BotHom α β) α β where\n  map_bot := BotHom.map_bot'\n\n-- this must come after the coe_to_fun definition\n"}
{"name":"BotHom.ext_iff","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\nf g : BotHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : BotHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"BotHom.ext","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\nf g : BotHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : BotHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"BotHom.coe_copy","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\nf : BotHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : BotHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"BotHom.copy_eq","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\nf : BotHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : BotHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"BotHom.coe_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝ : Bot α\n⊢ Eq (⇑(BotHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(BotHom.id α) = id :=\n  rfl\n\n"}
{"name":"BotHom.id_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝ : Bot α\na : α\n⊢ Eq ((BotHom.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : BotHom.id α a = a :=\n  rfl\n\n"}
{"name":"BotHom.coe_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Bot α\ninst✝¹ : Bot β\ninst✝ : Bot γ\nf : BotHom β γ\ng : BotHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : BotHom β γ) (g : BotHom α β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"BotHom.comp_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Bot α\ninst✝¹ : Bot β\ninst✝ : Bot γ\nf : BotHom β γ\ng : BotHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : BotHom β γ) (g : BotHom α β) (a : α) : (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"BotHom.comp_assoc","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝³ : Bot α\ninst✝² : Bot β\ninst✝¹ : Bot γ\ninst✝ : Bot δ\nf : BotHom γ δ\ng : BotHom β γ\nh : BotHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : BotHom γ δ) (g : BotHom β γ) (h : BotHom α β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"BotHom.comp_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\nf : BotHom α β\n⊢ Eq (f.comp (BotHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : BotHom α β) : f.comp (BotHom.id α) = f :=\n  BotHom.ext fun _ => rfl\n\n"}
{"name":"BotHom.id_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Bot α\ninst✝ : Bot β\nf : BotHom α β\n⊢ Eq ((BotHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : BotHom α β) : (BotHom.id β).comp f = f :=\n  BotHom.ext fun _ => rfl\n\n"}
{"name":"BotHom.cancel_right","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Bot α\ninst✝¹ : Bot β\ninst✝ : Bot γ\ng₁ g₂ : BotHom β γ\nf : BotHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : BotHom β γ} {f : BotHom α β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => BotHom.ext <| hf.forall.2 <| DFunLike.ext_iff.1 h, congr_arg (comp · f)⟩\n\n"}
{"name":"BotHom.cancel_left","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝² : Bot α\ninst✝¹ : Bot β\ninst✝ : Bot γ\ng : BotHom β γ\nf₁ f₂ : BotHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : BotHom β γ} {f₁ f₂ : BotHom α β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h => BotHom.ext fun a => hg <| by rw [← BotHom.comp_apply, h, BotHom.comp_apply],\n    congr_arg _⟩\n\n"}
{"name":"BotHom.coe_bot","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Bot α\ninst✝¹ : LE β\ninst✝ : OrderBot β\n⊢ Eq (⇑Bot.bot) Bot.bot","decl":"@[simp]\ntheorem coe_bot : ⇑(⊥ : BotHom α β) = ⊥ :=\n  rfl\n\n"}
{"name":"BotHom.bot_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Bot α\ninst✝¹ : LE β\ninst✝ : OrderBot β\na : α\n⊢ Eq (Bot.bot a) Bot.bot","decl":"@[simp]\ntheorem bot_apply (a : α) : (⊥ : BotHom α β) a = ⊥ :=\n  rfl\n\n"}
{"name":"BotHom.coe_inf","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Bot α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderBot β\nf g : BotHom α β\n⊢ Eq (⇑(Min.min f g)) (Min.min ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_inf : ⇑(f ⊓ g) = ⇑f ⊓ ⇑g :=\n  rfl\n\n"}
{"name":"BotHom.inf_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Bot α\ninst✝¹ : SemilatticeInf β\ninst✝ : OrderBot β\nf g : BotHom α β\na : α\n⊢ Eq ((Min.min f g) a) (Min.min (f a) (g a))","decl":"@[simp]\ntheorem inf_apply (a : α) : (f ⊓ g) a = f a ⊓ g a :=\n  rfl\n\n"}
{"name":"BotHom.coe_sup","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Bot α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\nf g : BotHom α β\n⊢ Eq (⇑(Max.max f g)) (Max.max ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_sup : ⇑(f ⊔ g) = ⇑f ⊔ ⇑g :=\n  rfl\n\n"}
{"name":"BotHom.sup_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝² : Bot α\ninst✝¹ : SemilatticeSup β\ninst✝ : OrderBot β\nf g : BotHom α β\na : α\n⊢ Eq ((Max.max f g) a) (Max.max (f a) (g a))","decl":"@[simp]\ntheorem sup_apply (a : α) : (f ⊔ g) a = f a ⊔ g a :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.instBoundedOrderHomClass","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\n⊢ BoundedOrderHomClass (BoundedOrderHom α β) α β","decl":"instance : BoundedOrderHomClass (BoundedOrderHom α β) α β where\n  map_rel f := @(f.monotone')\n  map_top f := f.map_top'\n  map_bot f := f.map_bot'\n\n"}
{"name":"BoundedOrderHom.ext","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf g : BoundedOrderHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : BoundedOrderHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"BoundedOrderHom.ext_iff","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf g : BoundedOrderHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : BoundedOrderHom α β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"BoundedOrderHom.coe_copy","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : BoundedOrderHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : BoundedOrderHom α β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.copy_eq","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : BoundedOrderHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : BoundedOrderHom α β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"BoundedOrderHom.coe_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\n⊢ Eq (⇑(BoundedOrderHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(BoundedOrderHom.id α) = id :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.id_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\na : α\n⊢ Eq ((BoundedOrderHom.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : BoundedOrderHom.id α a = a :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.coe_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\nf : BoundedOrderHom β γ\ng : BoundedOrderHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) : (f.comp g : α → γ) = f ∘ g :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.comp_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\nf : BoundedOrderHom β γ\ng : BoundedOrderHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) (a : α) :\n    (f.comp g) a = f (g a) :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.coe_comp_orderHom","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\nf : BoundedOrderHom β γ\ng : BoundedOrderHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[simp]\ntheorem coe_comp_orderHom (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) :\n    (f.comp g : OrderHom α γ) = (f : OrderHom β γ).comp g :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.coe_comp_topHom","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\nf : BoundedOrderHom β γ\ng : BoundedOrderHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[simp]\ntheorem coe_comp_topHom (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) :\n    (f.comp g : TopHom α γ) = (f : TopHom β γ).comp g :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.coe_comp_botHom","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\nf : BoundedOrderHom β γ\ng : BoundedOrderHom α β\n⊢ Eq (↑(f.comp g)) ((↑f).comp ↑g)","decl":"@[simp]\ntheorem coe_comp_botHom (f : BoundedOrderHom β γ) (g : BoundedOrderHom α β) :\n    (f.comp g : BotHom α γ) = (f : BotHom β γ).comp g :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.comp_assoc","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : Preorder α\ninst✝⁶ : Preorder β\ninst✝⁵ : Preorder γ\ninst✝⁴ : Preorder δ\ninst✝³ : BoundedOrder α\ninst✝² : BoundedOrder β\ninst✝¹ : BoundedOrder γ\ninst✝ : BoundedOrder δ\nf : BoundedOrderHom γ δ\ng : BoundedOrderHom β γ\nh : BoundedOrderHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"@[simp]\ntheorem comp_assoc (f : BoundedOrderHom γ δ) (g : BoundedOrderHom β γ) (h : BoundedOrderHom α β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.comp_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : BoundedOrderHom α β\n⊢ Eq (f.comp (BoundedOrderHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : BoundedOrderHom α β) : f.comp (BoundedOrderHom.id α) = f :=\n  BoundedOrderHom.ext fun _ => rfl\n\n"}
{"name":"BoundedOrderHom.id_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : Preorder β\ninst✝¹ : BoundedOrder α\ninst✝ : BoundedOrder β\nf : BoundedOrderHom α β\n⊢ Eq ((BoundedOrderHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : BoundedOrderHom α β) : (BoundedOrderHom.id β).comp f = f :=\n  BoundedOrderHom.ext fun _ => rfl\n\n"}
{"name":"BoundedOrderHom.cancel_right","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\ng₁ g₂ : BoundedOrderHom β γ\nf : BoundedOrderHom α β\nhf : Function.Surjective ⇑f\n⊢ Iff (Eq (g₁.comp f) (g₂.comp f)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_right {g₁ g₂ : BoundedOrderHom β γ} {f : BoundedOrderHom α β} (hf : Surjective f) :\n    g₁.comp f = g₂.comp f ↔ g₁ = g₂ :=\n  ⟨fun h => BoundedOrderHom.ext <| hf.forall.2 <| DFunLike.ext_iff.1 h,\n   congr_arg (fun g => comp g f)⟩\n\n"}
{"name":"BoundedOrderHom.cancel_left","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : Preorder β\ninst✝³ : Preorder γ\ninst✝² : BoundedOrder α\ninst✝¹ : BoundedOrder β\ninst✝ : BoundedOrder γ\ng : BoundedOrderHom β γ\nf₁ f₂ : BoundedOrderHom α β\nhg : Function.Injective ⇑g\n⊢ Iff (Eq (g.comp f₁) (g.comp f₂)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_left {g : BoundedOrderHom β γ} {f₁ f₂ : BoundedOrderHom α β} (hg : Injective g) :\n    g.comp f₁ = g.comp f₂ ↔ f₁ = f₂ :=\n  ⟨fun h =>\n    BoundedOrderHom.ext fun a =>\n      hg <| by rw [← BoundedOrderHom.comp_apply, h, BoundedOrderHom.comp_apply],\n    congr_arg _⟩\n\n"}
{"name":"TopHom.dual_symm_apply_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : OrderTop α\ninst✝¹ : LE β\ninst✝ : OrderTop β\nf : BotHom (OrderDual α) (OrderDual β)\na : OrderDual α\n⊢ Eq ((TopHom.dual.symm f) a) (f a)","decl":"/-- Reinterpret a top homomorphism as a bot homomorphism between the dual lattices. -/\n@[simps]\nprotected def dual :\n    TopHom α β ≃ BotHom αᵒᵈ βᵒᵈ where\n  toFun f := ⟨f, f.map_top'⟩\n  invFun f := ⟨f, f.map_bot'⟩\n  left_inv _ := TopHom.ext fun _ => rfl\n  right_inv _ := BotHom.ext fun _ => rfl\n\n"}
{"name":"TopHom.dual_apply_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : OrderTop α\ninst✝¹ : LE β\ninst✝ : OrderTop β\nf : TopHom α β\na : α\n⊢ Eq ((TopHom.dual f) a) (f a)","decl":"/-- Reinterpret a top homomorphism as a bot homomorphism between the dual lattices. -/\n@[simps]\nprotected def dual :\n    TopHom α β ≃ BotHom αᵒᵈ βᵒᵈ where\n  toFun f := ⟨f, f.map_top'⟩\n  invFun f := ⟨f, f.map_bot'⟩\n  left_inv _ := TopHom.ext fun _ => rfl\n  right_inv _ := BotHom.ext fun _ => rfl\n\n"}
{"name":"TopHom.dual_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : LE α\ninst✝ : OrderTop α\n⊢ Eq (TopHom.dual (TopHom.id α)) (BotHom.id (OrderDual α))","decl":"@[simp]\ntheorem dual_id : TopHom.dual (TopHom.id α) = BotHom.id _ :=\n  rfl\n\n"}
{"name":"TopHom.dual_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : LE α\ninst✝⁴ : OrderTop α\ninst✝³ : LE β\ninst✝² : OrderTop β\ninst✝¹ : LE γ\ninst✝ : OrderTop γ\ng : TopHom β γ\nf : TopHom α β\n⊢ Eq (TopHom.dual (g.comp f)) ((TopHom.dual g).comp (TopHom.dual f))","decl":"@[simp]\ntheorem dual_comp (g : TopHom β γ) (f : TopHom α β) :\n    TopHom.dual (g.comp f) = g.dual.comp (TopHom.dual f) :=\n  rfl\n\n"}
{"name":"TopHom.symm_dual_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : LE α\ninst✝ : OrderTop α\n⊢ Eq (TopHom.dual.symm (BotHom.id (OrderDual α))) (TopHom.id α)","decl":"@[simp]\ntheorem symm_dual_id : TopHom.dual.symm (BotHom.id _) = TopHom.id α :=\n  rfl\n\n"}
{"name":"TopHom.symm_dual_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : LE α\ninst✝⁴ : OrderTop α\ninst✝³ : LE β\ninst✝² : OrderTop β\ninst✝¹ : LE γ\ninst✝ : OrderTop γ\ng : BotHom (OrderDual β) (OrderDual γ)\nf : BotHom (OrderDual α) (OrderDual β)\n⊢ Eq (TopHom.dual.symm (g.comp f)) ((TopHom.dual.symm g).comp (TopHom.dual.symm f))","decl":"@[simp]\ntheorem symm_dual_comp (g : BotHom βᵒᵈ γᵒᵈ) (f : BotHom αᵒᵈ βᵒᵈ) :\n    TopHom.dual.symm (g.comp f) = (TopHom.dual.symm g).comp (TopHom.dual.symm f) :=\n  rfl\n\n"}
{"name":"BotHom.dual_symm_apply_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : OrderBot α\ninst✝¹ : LE β\ninst✝ : OrderBot β\nf : TopHom (OrderDual α) (OrderDual β)\na : OrderDual α\n⊢ Eq ((BotHom.dual.symm f) a) (f a)","decl":"/-- Reinterpret a bot homomorphism as a top homomorphism between the dual lattices. -/\n@[simps]\nprotected def dual :\n    BotHom α β ≃ TopHom αᵒᵈ βᵒᵈ where\n  toFun f := ⟨f, f.map_bot'⟩\n  invFun f := ⟨f, f.map_top'⟩\n  left_inv _ := BotHom.ext fun _ => rfl\n  right_inv _ := TopHom.ext fun _ => rfl\n\n"}
{"name":"BotHom.dual_apply_apply","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : LE α\ninst✝² : OrderBot α\ninst✝¹ : LE β\ninst✝ : OrderBot β\nf : BotHom α β\na : α\n⊢ Eq ((BotHom.dual f) a) (f a)","decl":"/-- Reinterpret a bot homomorphism as a top homomorphism between the dual lattices. -/\n@[simps]\nprotected def dual :\n    BotHom α β ≃ TopHom αᵒᵈ βᵒᵈ where\n  toFun f := ⟨f, f.map_bot'⟩\n  invFun f := ⟨f, f.map_top'⟩\n  left_inv _ := BotHom.ext fun _ => rfl\n  right_inv _ := TopHom.ext fun _ => rfl\n\n"}
{"name":"BotHom.dual_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : LE α\ninst✝ : OrderBot α\n⊢ Eq (BotHom.dual (BotHom.id α)) (TopHom.id (OrderDual α))","decl":"@[simp]\ntheorem dual_id : BotHom.dual (BotHom.id α) = TopHom.id _ :=\n  rfl\n\n"}
{"name":"BotHom.dual_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : LE α\ninst✝⁴ : OrderBot α\ninst✝³ : LE β\ninst✝² : OrderBot β\ninst✝¹ : LE γ\ninst✝ : OrderBot γ\ng : BotHom β γ\nf : BotHom α β\n⊢ Eq (BotHom.dual (g.comp f)) ((BotHom.dual g).comp (BotHom.dual f))","decl":"@[simp]\ntheorem dual_comp (g : BotHom β γ) (f : BotHom α β) :\n    BotHom.dual (g.comp f) = g.dual.comp (BotHom.dual f) :=\n  rfl\n\n"}
{"name":"BotHom.symm_dual_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : LE α\ninst✝ : OrderBot α\n⊢ Eq (BotHom.dual.symm (TopHom.id (OrderDual α))) (BotHom.id α)","decl":"@[simp]\ntheorem symm_dual_id : BotHom.dual.symm (TopHom.id _) = BotHom.id α :=\n  rfl\n\n"}
{"name":"BotHom.symm_dual_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : LE α\ninst✝⁴ : OrderBot α\ninst✝³ : LE β\ninst✝² : OrderBot β\ninst✝¹ : LE γ\ninst✝ : OrderBot γ\ng : TopHom (OrderDual β) (OrderDual γ)\nf : TopHom (OrderDual α) (OrderDual β)\n⊢ Eq (BotHom.dual.symm (g.comp f)) ((BotHom.dual.symm g).comp (BotHom.dual.symm f))","decl":"@[simp]\ntheorem symm_dual_comp (g : TopHom βᵒᵈ γᵒᵈ) (f : TopHom αᵒᵈ βᵒᵈ) :\n    BotHom.dual.symm (g.comp f) = (BotHom.dual.symm g).comp (BotHom.dual.symm f) :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.dual_apply_toOrderHom","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : BoundedOrder α\ninst✝¹ : Preorder β\ninst✝ : BoundedOrder β\nf : BoundedOrderHom α β\n⊢ Eq (BoundedOrderHom.dual f).toOrderHom (OrderHom.dual f.toOrderHom)","decl":"/-- Reinterpret a bounded order homomorphism as a bounded order homomorphism between the dual\norders. -/\n@[simps]\nprotected def dual :\n    BoundedOrderHom α β ≃\n      BoundedOrderHom αᵒᵈ\n        βᵒᵈ where\n  toFun f := ⟨f.toOrderHom.dual, f.map_bot', f.map_top'⟩\n  invFun f := ⟨OrderHom.dual.symm f.toOrderHom, f.map_bot', f.map_top'⟩\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := ext fun _ => rfl\n\n"}
{"name":"BoundedOrderHom.dual_symm_apply_toOrderHom","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : Preorder α\ninst✝² : BoundedOrder α\ninst✝¹ : Preorder β\ninst✝ : BoundedOrder β\nf : BoundedOrderHom (OrderDual α) (OrderDual β)\n⊢ Eq (BoundedOrderHom.dual.symm f).toOrderHom (OrderHom.dual.symm f.toOrderHom)","decl":"/-- Reinterpret a bounded order homomorphism as a bounded order homomorphism between the dual\norders. -/\n@[simps]\nprotected def dual :\n    BoundedOrderHom α β ≃\n      BoundedOrderHom αᵒᵈ\n        βᵒᵈ where\n  toFun f := ⟨f.toOrderHom.dual, f.map_bot', f.map_top'⟩\n  invFun f := ⟨OrderHom.dual.symm f.toOrderHom, f.map_bot', f.map_top'⟩\n  left_inv _ := ext fun _ => rfl\n  right_inv _ := ext fun _ => rfl\n\n"}
{"name":"BoundedOrderHom.dual_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\n⊢ Eq (BoundedOrderHom.dual (BoundedOrderHom.id α)) (BoundedOrderHom.id (OrderDual α))","decl":"@[simp]\ntheorem dual_id : (BoundedOrderHom.id α).dual = BoundedOrderHom.id _ :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.dual_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : BoundedOrder α\ninst✝³ : Preorder β\ninst✝² : BoundedOrder β\ninst✝¹ : Preorder γ\ninst✝ : BoundedOrder γ\ng : BoundedOrderHom β γ\nf : BoundedOrderHom α β\n⊢ Eq (BoundedOrderHom.dual (g.comp f)) ((BoundedOrderHom.dual g).comp (BoundedOrderHom.dual f))","decl":"@[simp]\ntheorem dual_comp (g : BoundedOrderHom β γ) (f : BoundedOrderHom α β) :\n    (g.comp f).dual = g.dual.comp f.dual :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.symm_dual_id","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ninst✝ : BoundedOrder α\n⊢ Eq (BoundedOrderHom.dual.symm (BoundedOrderHom.id (OrderDual α))) (BoundedOrderHom.id α)","decl":"@[simp]\ntheorem symm_dual_id : BoundedOrderHom.dual.symm (BoundedOrderHom.id _) = BoundedOrderHom.id α :=\n  rfl\n\n"}
{"name":"BoundedOrderHom.symm_dual_comp","module":"Mathlib.Order.Hom.Bounded","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : Preorder α\ninst✝⁴ : BoundedOrder α\ninst✝³ : Preorder β\ninst✝² : BoundedOrder β\ninst✝¹ : Preorder γ\ninst✝ : BoundedOrder γ\ng : BoundedOrderHom (OrderDual β) (OrderDual γ)\nf : BoundedOrderHom (OrderDual α) (OrderDual β)\n⊢ Eq (BoundedOrderHom.dual.symm (g.comp f)) ((BoundedOrderHom.dual.symm g).comp (BoundedOrderHom.dual.symm f))","decl":"@[simp]\ntheorem symm_dual_comp (g : BoundedOrderHom βᵒᵈ γᵒᵈ) (f : BoundedOrderHom αᵒᵈ βᵒᵈ) :\n    BoundedOrderHom.dual.symm (g.comp f) =\n      (BoundedOrderHom.dual.symm g).comp (BoundedOrderHom.dual.symm f) :=\n  rfl\n\n"}
