{"name":"CategoryTheory.Limits.preservesLimitsOfShape_pempty_of_preservesTerminal","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) G","decl":"/-- Preserving the terminal object implies preserving all limits of the empty diagram. -/\nlemma preservesLimitsOfShape_pempty_of_preservesTerminal [PreservesLimit (Functor.empty.{0} C) G] :\n    PreservesLimitsOfShape (Discrete PEmpty.{1}) G where\n  preservesLimit := preservesLimit_of_iso_diagram G (Functor.emptyExt (Functor.empty.{0} C) _)\n\n"}
{"name":"CategoryTheory.Limits.hasTerminal_of_hasTerminal_of_preservesLimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G\n⊢ CategoryTheory.Limits.HasTerminal D","decl":"/-- If `C` has a terminal object and `G` preserves terminal objects, then `D` has a terminal object\nalso.\nNote this property is somewhat unique to (co)limits of the empty diagram: for general `J`, if `C`\nhas limits of shape `J` and `G` preserves them, then `D` does not necessarily have limits of shape\n`J`.\n-/\ntheorem hasTerminal_of_hasTerminal_of_preservesLimit [PreservesLimit (Functor.empty.{0} C) G] :\n    HasTerminal D := ⟨fun F => by\n  haveI := HasLimit.mk ⟨_, isLimitOfHasTerminalOfPreservesLimit G⟩\n  apply hasLimitOfIso F.uniqueFromEmpty.symm⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesTerminal.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasTerminal D\ni : CategoryTheory.IsIso (CategoryTheory.Limits.terminalComparison G)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G","decl":"/-- If the terminal comparison map for `G` is an isomorphism, then `G` preserves terminal objects.\n-/\nlemma PreservesTerminal.of_iso_comparison [i : IsIso (terminalComparison G)] :\n    PreservesLimit (Functor.empty.{0} C) G := by\n  apply preservesLimit_of_preserves_limit_cone terminalIsTerminal\n  apply (isLimitMapConeEmptyConeEquiv _ _).symm _\n  exact @IsLimit.ofPointIso _ _ _ _ _ _ _ (limit.isLimit (Functor.empty.{0} D)) i\n\n"}
{"name":"CategoryTheory.Limits.preservesTerminal_of_isIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasTerminal D\nf : Quiver.Hom (G.obj (CategoryTheory.Limits.terminal C)) (CategoryTheory.Limits.terminal D)\ni : CategoryTheory.IsIso f\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G","decl":"/-- If there is any isomorphism `G.obj ⊤ ⟶ ⊤`, then `G` preserves terminal objects. -/\nlemma preservesTerminal_of_isIso (f : G.obj (⊤_ C) ⟶ ⊤_ D) [i : IsIso f] :\n    PreservesLimit (Functor.empty.{0} C) G := by\n  rw [Subsingleton.elim f (terminalComparison G)] at i\n  exact PreservesTerminal.of_iso_comparison G\n\n"}
{"name":"CategoryTheory.Limits.preservesTerminal_of_iso","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasTerminal D\nf : CategoryTheory.Iso (G.obj (CategoryTheory.Limits.terminal C)) (CategoryTheory.Limits.terminal D)\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G","decl":"/-- If there is any isomorphism `G.obj ⊤ ≅ ⊤`, then `G` preserves terminal objects. -/\nlemma preservesTerminal_of_iso (f : G.obj (⊤_ C) ≅ ⊤_ D) : PreservesLimit (Functor.empty.{0} C) G :=\n  preservesTerminal_of_isIso G f.hom\n\n"}
{"name":"CategoryTheory.Limits.PreservesTerminal.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasTerminal C\ninst✝¹ : CategoryTheory.Limits.HasTerminal D\ninst✝ : CategoryTheory.Limits.PreservesLimit (CategoryTheory.Functor.empty C) G\n⊢ Eq (CategoryTheory.Limits.PreservesTerminal.iso G).hom (CategoryTheory.Limits.terminalComparison G)","decl":"@[simp]\ntheorem PreservesTerminal.iso_hom : (PreservesTerminal.iso G).hom = terminalComparison G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoTerminalComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasTerminal D\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.terminalComparison G)","decl":"instance : IsIso (terminalComparison G) := by\n  rw [← PreservesTerminal.iso_hom]\n  infer_instance\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_pempty_of_preservesInitial","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete PEmpty.{1}) G","decl":"/-- Preserving the initial object implies preserving all colimits of the empty diagram. -/\nlemma preservesColimitsOfShape_pempty_of_preservesInitial\n    [PreservesColimit (Functor.empty.{0} C) G] :\n    PreservesColimitsOfShape (Discrete PEmpty.{1}) G where\n  preservesColimit :=\n    preservesColimit_of_iso_diagram G (Functor.emptyExt (Functor.empty.{0} C) _)\n\n"}
{"name":"CategoryTheory.Limits.hasInitial_of_hasInitial_of_preservesColimit","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G\n⊢ CategoryTheory.Limits.HasInitial D","decl":"/-- If `C` has an initial object and `G` preserves initial objects, then `D` has an initial object\nalso.\nNote this property is somewhat unique to colimits of the empty diagram: for general `J`, if `C`\nhas colimits of shape `J` and `G` preserves them, then `D` does not necessarily have colimits of\nshape `J`.\n-/\ntheorem hasInitial_of_hasInitial_of_preservesColimit [PreservesColimit (Functor.empty.{0} C) G] :\n    HasInitial D :=\n  ⟨fun F => by\n    haveI := HasColimit.mk ⟨_, isColimitOfHasInitialOfPreservesColimit G⟩\n    apply hasColimitOfIso F.uniqueFromEmpty⟩\n\n"}
{"name":"CategoryTheory.Limits.PreservesInitial.of_iso_comparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasInitial D\ni : CategoryTheory.IsIso (CategoryTheory.Limits.initialComparison G)\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G","decl":"/-- If the initial comparison map for `G` is an isomorphism, then `G` preserves initial objects.\n-/\nlemma PreservesInitial.of_iso_comparison [i : IsIso (initialComparison G)] :\n    PreservesColimit (Functor.empty.{0} C) G := by\n  apply preservesColimit_of_preserves_colimit_cocone initialIsInitial\n  apply (isColimitMapCoconeEmptyCoconeEquiv _ _).symm _\n  exact @IsColimit.ofPointIso _ _ _ _ _ _ _ (colimit.isColimit (Functor.empty.{0} D)) i\n\n"}
{"name":"CategoryTheory.Limits.preservesInitial_of_isIso","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasInitial D\nf : Quiver.Hom (CategoryTheory.Limits.initial D) (G.obj (CategoryTheory.Limits.initial C))\ni : CategoryTheory.IsIso f\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G","decl":"/-- If there is any isomorphism `⊥ ⟶ G.obj ⊥`, then `G` preserves initial objects. -/\nlemma preservesInitial_of_isIso (f : ⊥_ D ⟶ G.obj (⊥_ C)) [i : IsIso f] :\n    PreservesColimit (Functor.empty.{0} C) G := by\n  rw [Subsingleton.elim f (initialComparison G)] at i\n  exact PreservesInitial.of_iso_comparison G\n\n"}
{"name":"CategoryTheory.Limits.preservesInitial_of_iso","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasInitial D\nf : CategoryTheory.Iso (CategoryTheory.Limits.initial D) (G.obj (CategoryTheory.Limits.initial C))\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G","decl":"/-- If there is any isomorphism `⊥ ≅ G.obj ⊥`, then `G` preserves initial objects. -/\nlemma preservesInitial_of_iso (f : ⊥_ D ≅ G.obj (⊥_ C)) :\n    PreservesColimit (Functor.empty.{0} C) G :=\n  preservesInitial_of_isIso G f.hom\n\n"}
{"name":"CategoryTheory.Limits.PreservesInitial.iso_hom","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasInitial C\ninst✝¹ : CategoryTheory.Limits.HasInitial D\ninst✝ : CategoryTheory.Limits.PreservesColimit (CategoryTheory.Functor.empty C) G\n⊢ Eq (CategoryTheory.Limits.PreservesInitial.iso G).inv (CategoryTheory.Limits.initialComparison G)","decl":"@[simp]\ntheorem PreservesInitial.iso_hom : (PreservesInitial.iso G).inv = initialComparison G :=\n  rfl\n\n"}
{"name":"CategoryTheory.Limits.instIsIsoInitialComparison","module":"Mathlib.CategoryTheory.Limits.Preserves.Shapes.Terminal","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nG : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasInitial C\ninst✝ : CategoryTheory.Limits.HasInitial D\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.initialComparison G)","decl":"instance : IsIso (initialComparison G) := by\n  rw [← PreservesInitial.iso_hom]\n  infer_instance\n\n"}
