{"name":"Finset.sum_insertNone","module":"Mathlib.Algebra.BigOperators.Option","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nf : Option α → M\ns : Finset α\n⊢ Eq ((Finset.insertNone s).sum fun x => f x) (HAdd.hAdd (f Option.none) (s.sum fun x => f (Option.some x)))","decl":"@[to_additive (attr := simp)]\ntheorem prod_insertNone (f : Option α → M) (s : Finset α) :\n    ∏ x ∈ insertNone s, f x = f none * ∏ x ∈ s, f (some x) := by simp [insertNone]\n\n"}
{"name":"Finset.prod_insertNone","module":"Mathlib.Algebra.BigOperators.Option","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : CommMonoid M\nf : Option α → M\ns : Finset α\n⊢ Eq ((Finset.insertNone s).prod fun x => f x) (HMul.hMul (f Option.none) (s.prod fun x => f (Option.some x)))","decl":"@[to_additive (attr := simp)]\ntheorem prod_insertNone (f : Option α → M) (s : Finset α) :\n    ∏ x ∈ insertNone s, f x = f none * ∏ x ∈ s, f (some x) := by simp [insertNone]\n\n"}
{"name":"Finset.add_sum_eq_sum_insertNone","module":"Mathlib.Algebra.BigOperators.Option","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nf : α → M\nx : M\ns : Finset α\n⊢ Eq (HAdd.hAdd x (s.sum fun i => f i)) ((Finset.insertNone s).sum fun i => i.elim x f)","decl":"@[to_additive]\ntheorem mul_prod_eq_prod_insertNone (f : α → M) (x : M) (s : Finset α) :\n    x * ∏ i ∈ s, f i = ∏ i ∈ insertNone s, i.elim x f :=\n  (prod_insertNone (fun i => i.elim x f) _).symm\n\n"}
{"name":"Finset.mul_prod_eq_prod_insertNone","module":"Mathlib.Algebra.BigOperators.Option","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : CommMonoid M\nf : α → M\nx : M\ns : Finset α\n⊢ Eq (HMul.hMul x (s.prod fun i => f i)) ((Finset.insertNone s).prod fun i => i.elim x f)","decl":"@[to_additive]\ntheorem mul_prod_eq_prod_insertNone (f : α → M) (x : M) (s : Finset α) :\n    x * ∏ i ∈ s, f i = ∏ i ∈ insertNone s, i.elim x f :=\n  (prod_insertNone (fun i => i.elim x f) _).symm\n\n"}
{"name":"Finset.sum_eraseNone","module":"Mathlib.Algebra.BigOperators.Option","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : AddCommMonoid M\nf : α → M\ns : Finset (Option α)\n⊢ Eq ((Finset.eraseNone s).sum fun x => f x) (s.sum fun x => Option.elim' 0 f x)","decl":"@[to_additive]\ntheorem prod_eraseNone (f : α → M) (s : Finset (Option α)) :\n    ∏ x ∈ eraseNone s, f x = ∏ x ∈ s, Option.elim' 1 f x := by\n  classical calc\n      ∏ x ∈ eraseNone s, f x = ∏ x ∈ (eraseNone s).map Embedding.some, Option.elim' 1 f x :=\n        (prod_map (eraseNone s) Embedding.some <| Option.elim' 1 f).symm\n      _ = ∏ x ∈ s.erase none, Option.elim' 1 f x := by rw [map_some_eraseNone]\n      _ = ∏ x ∈ s, Option.elim' 1 f x := prod_erase _ rfl\n\n"}
{"name":"Finset.prod_eraseNone","module":"Mathlib.Algebra.BigOperators.Option","initialProofState":"α : Type u_1\nM : Type u_2\ninst✝ : CommMonoid M\nf : α → M\ns : Finset (Option α)\n⊢ Eq ((Finset.eraseNone s).prod fun x => f x) (s.prod fun x => Option.elim' 1 f x)","decl":"@[to_additive]\ntheorem prod_eraseNone (f : α → M) (s : Finset (Option α)) :\n    ∏ x ∈ eraseNone s, f x = ∏ x ∈ s, Option.elim' 1 f x := by\n  classical calc\n      ∏ x ∈ eraseNone s, f x = ∏ x ∈ (eraseNone s).map Embedding.some, Option.elim' 1 f x :=\n        (prod_map (eraseNone s) Embedding.some <| Option.elim' 1 f).symm\n      _ = ∏ x ∈ s.erase none, Option.elim' 1 f x := by rw [map_some_eraseNone]\n      _ = ∏ x ∈ s, Option.elim' 1 f x := prod_erase _ rfl\n\n"}
