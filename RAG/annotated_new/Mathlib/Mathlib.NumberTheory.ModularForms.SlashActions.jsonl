{"name":"SlashAction.slash_mul","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"β : Type u_1\nG : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : Group G\ninst✝¹ : AddMonoid α\ninst✝ : SMul γ α\nself : SlashAction β G α γ\nk : β\ng h : G\na : α\n⊢ Eq (SlashAction.map γ k (HMul.hMul g h) a) (SlashAction.map γ k h (SlashAction.map γ k g a))","decl":"/-- A general version of the slash action of the space of modular forms. -/\nclass SlashAction (β G α γ : Type*) [Group G] [AddMonoid α] [SMul γ α] where\n  map : β → G → α → α\n  zero_slash : ∀ (k : β) (g : G), map k g 0 = 0\n  slash_one : ∀ (k : β) (a : α), map k 1 a = a\n  slash_mul : ∀ (k : β) (g h : G) (a : α), map k (g * h) a = map k h (map k g a)\n  smul_slash : ∀ (k : β) (g : G) (a : α) (z : γ), map k g (z • a) = z • map k g a\n  add_slash : ∀ (k : β) (g : G) (a b : α), map k g (a + b) = map k g a + map k g b\n\n"}
{"name":"SlashAction.zero_slash","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"β : Type u_1\nG : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : Group G\ninst✝¹ : AddMonoid α\ninst✝ : SMul γ α\nself : SlashAction β G α γ\nk : β\ng : G\n⊢ Eq (SlashAction.map γ k g 0) 0","decl":"/-- A general version of the slash action of the space of modular forms. -/\nclass SlashAction (β G α γ : Type*) [Group G] [AddMonoid α] [SMul γ α] where\n  map : β → G → α → α\n  zero_slash : ∀ (k : β) (g : G), map k g 0 = 0\n  slash_one : ∀ (k : β) (a : α), map k 1 a = a\n  slash_mul : ∀ (k : β) (g h : G) (a : α), map k (g * h) a = map k h (map k g a)\n  smul_slash : ∀ (k : β) (g : G) (a : α) (z : γ), map k g (z • a) = z • map k g a\n  add_slash : ∀ (k : β) (g : G) (a b : α), map k g (a + b) = map k g a + map k g b\n\n"}
{"name":"SlashAction.smul_slash","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"β : Type u_1\nG : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : Group G\ninst✝¹ : AddMonoid α\ninst✝ : SMul γ α\nself : SlashAction β G α γ\nk : β\ng : G\na : α\nz : γ\n⊢ Eq (SlashAction.map γ k g (HSMul.hSMul z a)) (HSMul.hSMul z (SlashAction.map γ k g a))","decl":"/-- A general version of the slash action of the space of modular forms. -/\nclass SlashAction (β G α γ : Type*) [Group G] [AddMonoid α] [SMul γ α] where\n  map : β → G → α → α\n  zero_slash : ∀ (k : β) (g : G), map k g 0 = 0\n  slash_one : ∀ (k : β) (a : α), map k 1 a = a\n  slash_mul : ∀ (k : β) (g h : G) (a : α), map k (g * h) a = map k h (map k g a)\n  smul_slash : ∀ (k : β) (g : G) (a : α) (z : γ), map k g (z • a) = z • map k g a\n  add_slash : ∀ (k : β) (g : G) (a b : α), map k g (a + b) = map k g a + map k g b\n\n"}
{"name":"SlashAction.add_slash","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"β : Type u_1\nG : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : Group G\ninst✝¹ : AddMonoid α\ninst✝ : SMul γ α\nself : SlashAction β G α γ\nk : β\ng : G\na b : α\n⊢ Eq (SlashAction.map γ k g (HAdd.hAdd a b)) (HAdd.hAdd (SlashAction.map γ k g a) (SlashAction.map γ k g b))","decl":"/-- A general version of the slash action of the space of modular forms. -/\nclass SlashAction (β G α γ : Type*) [Group G] [AddMonoid α] [SMul γ α] where\n  map : β → G → α → α\n  zero_slash : ∀ (k : β) (g : G), map k g 0 = 0\n  slash_one : ∀ (k : β) (a : α), map k 1 a = a\n  slash_mul : ∀ (k : β) (g h : G) (a : α), map k (g * h) a = map k h (map k g a)\n  smul_slash : ∀ (k : β) (g : G) (a : α) (z : γ), map k g (z • a) = z • map k g a\n  add_slash : ∀ (k : β) (g : G) (a b : α), map k g (a + b) = map k g a + map k g b\n\n"}
{"name":"SlashAction.slash_one","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"β : Type u_1\nG : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝² : Group G\ninst✝¹ : AddMonoid α\ninst✝ : SMul γ α\nself : SlashAction β G α γ\nk : β\na : α\n⊢ Eq (SlashAction.map γ k 1 a) a","decl":"/-- A general version of the slash action of the space of modular forms. -/\nclass SlashAction (β G α γ : Type*) [Group G] [AddMonoid α] [SMul γ α] where\n  map : β → G → α → α\n  zero_slash : ∀ (k : β) (g : G), map k g 0 = 0\n  slash_one : ∀ (k : β) (a : α), map k 1 a = a\n  slash_mul : ∀ (k : β) (g h : G) (a : α), map k (g * h) a = map k h (map k g a)\n  smul_slash : ∀ (k : β) (g : G) (a : α) (z : γ), map k g (z • a) = z • map k g a\n  add_slash : ∀ (k : β) (g : G) (a b : α), map k g (a + b) = map k g a + map k g b\n\n"}
{"name":"SlashAction.neg_slash","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"β : Type u_1\nG : Type u_2\nα : Type u_3\nγ : Type u_4\ninst✝³ : Group G\ninst✝² : AddGroup α\ninst✝¹ : SMul γ α\ninst✝ : SlashAction β G α γ\nk : β\ng : G\na : α\n⊢ Eq (SlashAction.map γ k g (Neg.neg a)) (Neg.neg (SlashAction.map γ k g a))","decl":"@[simp]\ntheorem SlashAction.neg_slash {β G α γ : Type*} [Group G] [AddGroup α] [SMul γ α]\n    [SlashAction β G α γ] (k : β) (g : G) (a : α) : (-a) ∣[k;γ] g = -a ∣[k;γ] g :=\n  eq_neg_of_add_eq_zero_left <| by\n    rw [← SlashAction.add_slash, neg_add_cancel, SlashAction.zero_slash]\n\n"}
{"name":"SlashAction.smul_slash_of_tower","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"R : Type u_1\nβ : Type u_2\nG : Type u_3\nα : Type u_4\nγ : Type u_5\ninst✝⁷ : Group G\ninst✝⁶ : AddGroup α\ninst✝⁵ : Monoid γ\ninst✝⁴ : MulAction γ α\ninst✝³ : SMul R γ\ninst✝² : SMul R α\ninst✝¹ : IsScalarTower R γ α\ninst✝ : SlashAction β G α γ\nk : β\ng : G\na : α\nr : R\n⊢ Eq (SlashAction.map γ k g (HSMul.hSMul r a)) (HSMul.hSMul r (SlashAction.map γ k g a))","decl":"@[simp]\ntheorem SlashAction.smul_slash_of_tower {R β G α : Type*} (γ : Type*) [Group G] [AddGroup α]\n    [Monoid γ] [MulAction γ α] [SMul R γ] [SMul R α] [IsScalarTower R γ α] [SlashAction β G α γ]\n    (k : β) (g : G) (a : α) (r : R) : (r • a) ∣[k;γ] g = r • a ∣[k;γ] g := by\n  rw [← smul_one_smul γ r a, SlashAction.smul_slash, smul_one_smul]\n\n"}
{"name":"ModularForm.slash_def","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"k : Int\nf : UpperHalfPlane → Complex\nA : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\n⊢ Eq (SlashAction.map Complex k A f) (ModularForm.slash k A f)","decl":"theorem slash_def (A : GL(2, ℝ)⁺) : f ∣[k] A = slash k A f :=\n  rfl\n\n"}
{"name":"ModularForm.SL_slash","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"k : Int\nf : UpperHalfPlane → Complex\nγ : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Eq (SlashAction.map Complex k γ f) (SlashAction.map Complex k (↑γ) f)","decl":"@[simp]\ntheorem SL_slash (γ : SL(2, ℤ)) : f ∣[k] γ = f ∣[k] (γ : GL(2, ℝ)⁺) :=\n  rfl\n\n"}
{"name":"ModularForm.is_invariant_const","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"A : Matrix.SpecialLinearGroup (Fin 2) Int\nx : Complex\n⊢ Eq (SlashAction.map Complex 0 A (Function.const UpperHalfPlane x)) (Function.const UpperHalfPlane x)","decl":"theorem is_invariant_const (A : SL(2, ℤ)) (x : ℂ) :\n    Function.const ℍ x ∣[(0 : ℤ)] A = Function.const ℍ x := by\n  funext\n  simp only [SL_slash, slash_def, slash, Function.const_apply, det_coe, ofReal_one, zero_sub,\n    zpow_neg, zpow_one, inv_one, mul_one, neg_zero, zpow_zero]\n\n"}
{"name":"ModularForm.is_invariant_one","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"A : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Eq (SlashAction.map Complex 0 A 1) 1","decl":"/-- The constant function 1 is invariant under any element of `SL(2, ℤ)`. -/\ntheorem is_invariant_one (A : SL(2, ℤ)) : (1 : ℍ → ℂ) ∣[(0 : ℤ)] A = (1 : ℍ → ℂ) :=\n  is_invariant_const _ _\n\n"}
{"name":"ModularForm.is_invariant_one'","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"A : Matrix.SpecialLinearGroup (Fin 2) Int\n⊢ Eq (SlashAction.map Complex 0 (↑A) 1) 1","decl":"/-- Variant of `is_invariant_one` with the left hand side in simp normal form. -/\n@[simp]\ntheorem is_invariant_one' (A : SL(2, ℤ)) : (1 : ℍ → ℂ) ∣[(0 : ℤ)] (A : GL(2, ℝ)⁺) = 1 := by\n  simpa using is_invariant_one A\n\n"}
{"name":"ModularForm.slash_action_eq'_iff","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"k : Int\nf : UpperHalfPlane → Complex\nγ : Matrix.SpecialLinearGroup (Fin 2) Int\nz : UpperHalfPlane\n⊢ Iff (Eq (SlashAction.map Complex k γ f z) (f z)) (Eq (f (HSMul.hSMul γ z)) (HMul.hMul (HPow.hPow (HAdd.hAdd (HMul.hMul ↑(↑γ 1 0) ↑z) ↑(↑γ 1 1)) k) (f z)))","decl":"/-- A function `f : ℍ → ℂ` is slash-invariant, of weight `k ∈ ℤ` and level `Γ`,\n  if for every matrix `γ ∈ Γ` we have `f(γ • z)= (c*z+d)^k f(z)` where `γ= ![![a, b], ![c, d]]`,\n  and it acts on `ℍ` via Möbius transformations. -/\ntheorem slash_action_eq'_iff (k : ℤ) (f : ℍ → ℂ) (γ : SL(2, ℤ)) (z : ℍ) :\n    (f ∣[k] γ) z = f z ↔ f (γ • z) = ((γ 1 0 : ℂ) * z + (γ 1 1 : ℂ)) ^ k * f z := by\n  simp only [SL_slash, slash_def, ModularForm.slash]\n  convert inv_mul_eq_iff_eq_mul₀ (G₀ := ℂ) _ using 2\n  · rw [mul_comm]\n    simp only [denom, zpow_neg, det_coe, ofReal_one, one_zpow, mul_one,\n      sl_moeb]\n    rfl\n  · convert zpow_ne_zero k (denom_ne_zero γ z)\n\n"}
{"name":"ModularForm.mul_slash","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"k1 k2 : Int\nA : Subtype fun x => Membership.mem (Matrix.GLPos (Fin 2) Real) x\nf g : UpperHalfPlane → Complex\n⊢ Eq (SlashAction.map Complex (HAdd.hAdd k1 k2) A (HMul.hMul f g)) (HMul.hMul (HSMul.hSMul (↑↑A).det (SlashAction.map Complex k1 A f)) (SlashAction.map Complex k2 A g))","decl":"theorem mul_slash (k1 k2 : ℤ) (A : GL(2, ℝ)⁺) (f g : ℍ → ℂ) :\n    (f * g) ∣[k1 + k2] A = ((↑ₘA).det : ℝ) • f ∣[k1] A * g ∣[k2] A := by\n  ext1 x\n  simp only [slash_def, slash, Matrix.GeneralLinearGroup.val_det_apply,\n    Pi.mul_apply, Pi.smul_apply, Algebra.smul_mul_assoc, real_smul]\n  set d : ℂ := ↑(↑ₘ[ℝ] A).det\n  have h1 : d ^ (k1 + k2 - 1) = d * d ^ (k1 - 1) * d ^ (k2 - 1) := by\n    have : d ≠ 0 := by\n      dsimp only [d]\n      exact_mod_cast Matrix.GLPos.det_ne_zero A\n    rw [← zpow_one_add₀ this, ← zpow_add₀ this]\n    congr; ring\n  have h22 : denom A x ^ (-(k1 + k2)) = denom A x ^ (-k1) * denom A x ^ (-k2) := by\n    rw [Int.neg_add, zpow_add₀]\n    exact UpperHalfPlane.denom_ne_zero A x\n  rw [h1, h22]\n  ring\n\n"}
{"name":"ModularForm.mul_slash_SL2","module":"Mathlib.NumberTheory.ModularForms.SlashActions","initialProofState":"k1 k2 : Int\nA : Matrix.SpecialLinearGroup (Fin 2) Int\nf g : UpperHalfPlane → Complex\n⊢ Eq (SlashAction.map Complex (HAdd.hAdd k1 k2) A (HMul.hMul f g)) (HMul.hMul (SlashAction.map Complex k1 A f) (SlashAction.map Complex k2 A g))","decl":"theorem mul_slash_SL2 (k1 k2 : ℤ) (A : SL(2, ℤ)) (f g : ℍ → ℂ) :\n    (f * g) ∣[k1 + k2] A = f ∣[k1] A * g ∣[k2] A :=\n  calc\n    (f * g) ∣[k1 + k2] (A : GL(2, ℝ)⁺) =\n        ((↑ₘA).det : ℝ) • f ∣[k1] A * g ∣[k2] A := by\n      apply mul_slash\n    _ = (1 : ℝ) • f ∣[k1] A * g ∣[k2] A := by rw [det_coe]\n    _ = f ∣[k1] A * g ∣[k2] A := by rw [one_smul]\n\n"}
