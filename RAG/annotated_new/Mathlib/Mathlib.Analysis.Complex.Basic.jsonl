{"name":"Complex.norm_eq_abs","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Norm.norm z) (Complex.abs z)","decl":"@[simp]\ntheorem norm_eq_abs (z : ‚ÑÇ) : ‚Äñz‚Äñ = abs z :=\n  rfl\n\n"}
{"name":"Complex.norm_I","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (Norm.norm Complex.I) 1","decl":"lemma norm_I : ‚ÄñI‚Äñ = 1 := abs_I\n\n"}
{"name":"Complex.norm_exp_ofReal_mul_I","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"t : Real\n‚ä¢ Eq (Norm.norm (Complex.exp (HMul.hMul (‚Üët) Complex.I))) 1","decl":"theorem norm_exp_ofReal_mul_I (t : ‚Ñù) : ‚Äñexp (t * I)‚Äñ = 1 := by\n  simp only [norm_eq_abs, abs_exp_ofReal_mul_I]\n\n"}
{"name":"Complex.nnnorm_I","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (NNNorm.nnnorm Complex.I) 1","decl":"@[simp] lemma nnnorm_I : ‚ÄñI‚Äñ‚Çä = 1 := by simp [nnnorm]\n\n"}
{"name":"Complex.dist_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\n‚ä¢ Eq (Dist.dist z w) (Complex.abs (HSub.hSub z w))","decl":"theorem dist_eq (z w : ‚ÑÇ) : dist z w = abs (z - w) :=\n  rfl\n\n"}
{"name":"Complex.dist_eq_re_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\n‚ä¢ Eq (Dist.dist z w) (HAdd.hAdd (HPow.hPow (HSub.hSub z.re w.re) 2) (HPow.hPow (HSub.hSub z.im w.im) 2)).sqrt","decl":"theorem dist_eq_re_im (z w : ‚ÑÇ) : dist z w = ‚àö((z.re - w.re) ^ 2 + (z.im - w.im) ^ 2) := by\n  rw [sq, sq]\n  rfl\n\n"}
{"name":"Complex.dist_mk","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : Real\n‚ä¢ Eq (Dist.dist { re := x‚ÇÅ, im := y‚ÇÅ } { re := x‚ÇÇ, im := y‚ÇÇ }) (HAdd.hAdd (HPow.hPow (HSub.hSub x‚ÇÅ x‚ÇÇ) 2) (HPow.hPow (HSub.hSub y‚ÇÅ y‚ÇÇ) 2)).sqrt","decl":"@[simp]\ntheorem dist_mk (x‚ÇÅ y‚ÇÅ x‚ÇÇ y‚ÇÇ : ‚Ñù) :\n    dist (mk x‚ÇÅ y‚ÇÅ) (mk x‚ÇÇ y‚ÇÇ) = ‚àö((x‚ÇÅ - x‚ÇÇ) ^ 2 + (y‚ÇÅ - y‚ÇÇ) ^ 2) :=\n  dist_eq_re_im _ _\n\n"}
{"name":"Complex.dist_of_re_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\nh : Eq z.re w.re\n‚ä¢ Eq (Dist.dist z w) (Dist.dist z.im w.im)","decl":"theorem dist_of_re_eq {z w : ‚ÑÇ} (h : z.re = w.re) : dist z w = dist z.im w.im := by\n  rw [dist_eq_re_im, h, sub_self, zero_pow two_ne_zero, zero_add, Real.sqrt_sq_eq_abs, Real.dist_eq]\n\n"}
{"name":"Complex.nndist_of_re_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\nh : Eq z.re w.re\n‚ä¢ Eq (NNDist.nndist z w) (NNDist.nndist z.im w.im)","decl":"theorem nndist_of_re_eq {z w : ‚ÑÇ} (h : z.re = w.re) : nndist z w = nndist z.im w.im :=\n  NNReal.eq <| dist_of_re_eq h\n\n"}
{"name":"Complex.edist_of_re_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\nh : Eq z.re w.re\n‚ä¢ Eq (EDist.edist z w) (EDist.edist z.im w.im)","decl":"theorem edist_of_re_eq {z w : ‚ÑÇ} (h : z.re = w.re) : edist z w = edist z.im w.im := by\n  rw [edist_nndist, edist_nndist, nndist_of_re_eq h]\n\n"}
{"name":"Complex.dist_of_im_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\nh : Eq z.im w.im\n‚ä¢ Eq (Dist.dist z w) (Dist.dist z.re w.re)","decl":"theorem dist_of_im_eq {z w : ‚ÑÇ} (h : z.im = w.im) : dist z w = dist z.re w.re := by\n  rw [dist_eq_re_im, h, sub_self, zero_pow two_ne_zero, add_zero, Real.sqrt_sq_eq_abs, Real.dist_eq]\n\n"}
{"name":"Complex.nndist_of_im_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\nh : Eq z.im w.im\n‚ä¢ Eq (NNDist.nndist z w) (NNDist.nndist z.re w.re)","decl":"theorem nndist_of_im_eq {z w : ‚ÑÇ} (h : z.im = w.im) : nndist z w = nndist z.re w.re :=\n  NNReal.eq <| dist_of_im_eq h\n\n"}
{"name":"Complex.edist_of_im_eq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\nh : Eq z.im w.im\n‚ä¢ Eq (EDist.edist z w) (EDist.edist z.re w.re)","decl":"theorem edist_of_im_eq {z w : ‚ÑÇ} (h : z.im = w.im) : edist z w = edist z.re w.re := by\n  rw [edist_nndist, edist_nndist, nndist_of_im_eq h]\n\n"}
{"name":"Complex.dist_conj_self","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Dist.dist ((starRingEnd Complex) z) z) (HMul.hMul 2 (abs z.im))","decl":"theorem dist_conj_self (z : ‚ÑÇ) : dist (conj z) z = 2 * |z.im| := by\n  rw [dist_of_re_eq (conj_re z), conj_im, dist_comm, Real.dist_eq, sub_neg_eq_add, ‚Üê two_mul,\n    _root_.abs_mul, abs_of_pos (zero_lt_two' ‚Ñù)]\n\n"}
{"name":"Complex.nndist_conj_self","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (NNDist.nndist ((starRingEnd Complex) z) z) (HMul.hMul 2 (Real.nnabs z.im))","decl":"theorem nndist_conj_self (z : ‚ÑÇ) : nndist (conj z) z = 2 * Real.nnabs z.im :=\n  NNReal.eq <| by rw [‚Üê dist_nndist, NNReal.coe_mul, NNReal.coe_two, Real.coe_nnabs, dist_conj_self]\n\n"}
{"name":"Complex.dist_self_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Dist.dist z ((starRingEnd Complex) z)) (HMul.hMul 2 (abs z.im))","decl":"theorem dist_self_conj (z : ‚ÑÇ) : dist z (conj z) = 2 * |z.im| := by rw [dist_comm, dist_conj_self]\n\n"}
{"name":"Complex.nndist_self_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (NNDist.nndist z ((starRingEnd Complex) z)) (HMul.hMul 2 (Real.nnabs z.im))","decl":"theorem nndist_self_conj (z : ‚ÑÇ) : nndist z (conj z) = 2 * Real.nnabs z.im := by\n  rw [nndist_comm, nndist_conj_self]\n\n"}
{"name":"Complex.comap_abs_nhds_zero","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (Filter.comap (‚áëComplex.abs) (nhds 0)) (nhds 0)","decl":"@[simp 1100]\ntheorem comap_abs_nhds_zero : comap abs (ùìù 0) = ùìù 0 :=\n  comap_norm_nhds_zero\n\n"}
{"name":"Complex.norm_real","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"r : Real\n‚ä¢ Eq (Norm.norm ‚Üër) (Norm.norm r)","decl":"@[simp 1100, norm_cast] lemma norm_real (r : ‚Ñù) : ‚Äñ(r : ‚ÑÇ)‚Äñ = ‚Äñr‚Äñ := abs_ofReal _\n"}
{"name":"Complex.nnnorm_real","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"r : Real\n‚ä¢ Eq (NNNorm.nnnorm ‚Üër) (NNNorm.nnnorm r)","decl":"@[simp, norm_cast] lemma nnnorm_real (r : ‚Ñù) : ‚Äñ(r : ‚ÑÇ)‚Äñ‚Çä = ‚Äñr‚Äñ‚Çä := by ext; exact norm_real _\n\n"}
{"name":"Complex.norm_natCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Norm.norm ‚Üën) ‚Üën","decl":"@[simp 1100, norm_cast] lemma norm_natCast (n : ‚Ñï) : ‚Äñ(n : ‚ÑÇ)‚Äñ = n := abs_natCast _\n"}
{"name":"Complex.norm_intCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Int\n‚ä¢ Eq (Norm.norm ‚Üën) (abs ‚Üën)","decl":"@[simp 1100, norm_cast] lemma norm_intCast (n : ‚Ñ§) : ‚Äñ(n : ‚ÑÇ)‚Äñ = |(n : ‚Ñù)| := abs_intCast n\n"}
{"name":"Complex.norm_ratCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"q : Rat\n‚ä¢ Eq (Norm.norm ‚Üëq) (abs ‚Üëq)","decl":"@[simp 1100, norm_cast] lemma norm_ratCast (q : ‚Ñö) : ‚Äñ(q : ‚ÑÇ)‚Äñ = |(q : ‚Ñù)| := norm_real _\n\n"}
{"name":"Complex.nnnorm_natCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (NNNorm.nnnorm ‚Üën) ‚Üën","decl":"@[simp 1100, norm_cast] lemma nnnorm_natCast (n : ‚Ñï) : ‚Äñ(n : ‚ÑÇ)‚Äñ‚Çä = n := Subtype.ext <| by simp\n"}
{"name":"Complex.nnnorm_intCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Int\n‚ä¢ Eq (NNNorm.nnnorm ‚Üën) (NNNorm.nnnorm n)","decl":"@[simp 1100, norm_cast] lemma nnnorm_intCast (n : ‚Ñ§) : ‚Äñ(n : ‚ÑÇ)‚Äñ‚Çä = ‚Äñn‚Äñ‚Çä := by\n  ext; exact norm_intCast n\n"}
{"name":"Complex.nnnorm_ratCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"q : Rat\n‚ä¢ Eq (NNNorm.nnnorm ‚Üëq) (NNNorm.nnnorm ‚Üëq)","decl":"@[simp 1100, norm_cast] lemma nnnorm_ratCast (q : ‚Ñö) : ‚Äñ(q : ‚ÑÇ)‚Äñ‚Çä = ‚Äñ(q : ‚Ñù)‚Äñ‚Çä := nnnorm_real q\n\n"}
{"name":"Complex.norm_ofNat","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (Norm.norm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp 1100] lemma norm_ofNat (n : ‚Ñï) [n.AtLeastTwo] :\n    ‚Äñ(ofNat(n) : ‚ÑÇ)‚Äñ = OfNat.ofNat n := norm_natCast n\n\n"}
{"name":"Complex.nnnorm_ofNat","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Eq (NNNorm.nnnorm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp 1100] lemma nnnorm_ofNat (n : ‚Ñï) [n.AtLeastTwo] :\n    ‚Äñ(ofNat(n) : ‚ÑÇ)‚Äñ‚Çä = OfNat.ofNat n := nnnorm_natCast n\n\n"}
{"name":"Complex.norm_nat","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (Norm.norm ‚Üën) ‚Üën","decl":"@[deprecated (since := \"2024-08-25\")] alias norm_nat := norm_natCast\n"}
{"name":"Complex.norm_int","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Int\n‚ä¢ Eq (Norm.norm ‚Üën) (abs ‚Üën)","decl":"@[deprecated (since := \"2024-08-25\")] alias norm_int := norm_intCast\n"}
{"name":"Complex.norm_rat","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"q : Rat\n‚ä¢ Eq (Norm.norm ‚Üëq) (abs ‚Üëq)","decl":"@[deprecated (since := \"2024-08-25\")] alias norm_rat := norm_ratCast\n"}
{"name":"Complex.nnnorm_nat","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\n‚ä¢ Eq (NNNorm.nnnorm ‚Üën) ‚Üën","decl":"@[deprecated (since := \"2024-08-25\")] alias nnnorm_nat := nnnorm_natCast\n"}
{"name":"Complex.nnnorm_int","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Int\n‚ä¢ Eq (NNNorm.nnnorm ‚Üën) (NNNorm.nnnorm n)","decl":"@[deprecated (since := \"2024-08-25\")] alias nnnorm_int := nnnorm_intCast\n\n"}
{"name":"Complex.norm_nnratCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"q : NNRat\n‚ä¢ Eq (Norm.norm ‚Üëq) ‚Üëq","decl":"@[simp 1100, norm_cast]\nlemma norm_nnratCast (q : ‚Ñö‚â•0) : ‚Äñ(q : ‚ÑÇ)‚Äñ = q := abs_of_nonneg q.cast_nonneg\n\n"}
{"name":"Complex.nnnorm_nnratCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"q : NNRat\n‚ä¢ Eq (NNNorm.nnnorm ‚Üëq) ‚Üëq","decl":"@[simp 1100, norm_cast]\nlemma nnnorm_nnratCast (q : ‚Ñö‚â•0) : ‚Äñ(q : ‚ÑÇ)‚Äñ‚Çä = q := by simp [nnnorm, -norm_eq_abs]\n\n"}
{"name":"Complex.norm_int_of_nonneg","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Int\nhn : LE.le 0 n\n‚ä¢ Eq (Norm.norm ‚Üën) ‚Üën","decl":"theorem norm_int_of_nonneg {n : ‚Ñ§} (hn : 0 ‚â§ n) : ‚Äñ(n : ‚ÑÇ)‚Äñ = n := by\n  rw [norm_intCast, ‚Üê Int.cast_abs, _root_.abs_of_nonneg hn]\n\n"}
{"name":"Complex.normSq_eq_norm_sq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Complex.normSq z) (HPow.hPow (Norm.norm z) 2)","decl":"lemma normSq_eq_norm_sq (z : ‚ÑÇ) : normSq z = ‚Äñz‚Äñ ^ 2 := by\n  rw [normSq_eq_abs, norm_eq_abs]\n\n"}
{"name":"Complex.continuous_abs","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Continuous ‚áëComplex.abs","decl":"@[continuity, fun_prop]\ntheorem continuous_abs : Continuous abs :=\n  continuous_norm\n\n"}
{"name":"Complex.continuous_normSq","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Continuous ‚áëComplex.normSq","decl":"@[continuity, fun_prop]\ntheorem continuous_normSq : Continuous normSq := by\n  simpa [‚Üê normSq_eq_abs] using continuous_abs.pow 2\n\n\n"}
{"name":"Complex.nnnorm_eq_one_of_pow_eq_one","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ∂ : Complex\nn : Nat\nh : Eq (HPow.hPow Œ∂ n) 1\nhn : Ne n 0\n‚ä¢ Eq (NNNorm.nnnorm Œ∂) 1","decl":"theorem nnnorm_eq_one_of_pow_eq_one {Œ∂ : ‚ÑÇ} {n : ‚Ñï} (h : Œ∂ ^ n = 1) (hn : n ‚â† 0) : ‚ÄñŒ∂‚Äñ‚Çä = 1 :=\n  (pow_left_inj‚ÇÄ zero_le' zero_le' hn).1 <| by rw [‚Üê nnnorm_pow, h, nnnorm_one, one_pow]\n\n"}
{"name":"Complex.norm_eq_one_of_pow_eq_one","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ∂ : Complex\nn : Nat\nh : Eq (HPow.hPow Œ∂ n) 1\nhn : Ne n 0\n‚ä¢ Eq (Norm.norm Œ∂) 1","decl":"theorem norm_eq_one_of_pow_eq_one {Œ∂ : ‚ÑÇ} {n : ‚Ñï} (h : Œ∂ ^ n = 1) (hn : n ‚â† 0) : ‚ÄñŒ∂‚Äñ = 1 :=\n  congr_arg Subtype.val (nnnorm_eq_one_of_pow_eq_one h hn)\n\n"}
{"name":"Complex.le_of_eq_sum_of_eq_sum_norm","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œπ : Type u_2\na b : Real\nf : Œπ ‚Üí Complex\ns : Finset Œπ\nha‚ÇÄ : LE.le 0 a\nha : Eq (‚Üëa) (s.sum fun i => f i)\nhb : Eq (‚Üëb) (s.sum fun i => ‚Üë(Norm.norm (f i)))\n‚ä¢ LE.le a b","decl":"lemma le_of_eq_sum_of_eq_sum_norm {Œπ : Type*} {a b : ‚Ñù} (f : Œπ ‚Üí ‚ÑÇ) (s : Finset Œπ) (ha‚ÇÄ : 0 ‚â§ a)\n    (ha : a = ‚àë i ‚àà s, f i) (hb : b = ‚àë i ‚àà s, (‚Äñf i‚Äñ : ‚ÑÇ)) : a ‚â§ b := by\n  norm_cast at hb; rw [‚Üê Complex.abs_of_nonneg ha‚ÇÄ, ha, hb]; exact norm_sum_le s f\n\n"}
{"name":"Complex.equivRealProd_apply_le","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ LE.le (Norm.norm (Complex.equivRealProd z)) (Complex.abs z)","decl":"theorem equivRealProd_apply_le (z : ‚ÑÇ) : ‚ÄñequivRealProd z‚Äñ ‚â§ abs z := by\n  simp [Prod.norm_def, abs_re_le_abs, abs_im_le_abs]\n\n"}
{"name":"Complex.equivRealProd_apply_le'","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ LE.le (Norm.norm (Complex.equivRealProd z)) (HMul.hMul 1 (Complex.abs z))","decl":"theorem equivRealProd_apply_le' (z : ‚ÑÇ) : ‚ÄñequivRealProd z‚Äñ ‚â§ 1 * abs z := by\n  simpa using equivRealProd_apply_le z\n\n"}
{"name":"Complex.lipschitz_equivRealProd","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ LipschitzWith 1 ‚áëComplex.equivRealProd","decl":"theorem lipschitz_equivRealProd : LipschitzWith 1 equivRealProd := by\n  simpa using AddMonoidHomClass.lipschitz_of_bound equivRealProdLm 1 equivRealProd_apply_le'\n\n"}
{"name":"Complex.antilipschitz_equivRealProd","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ AntilipschitzWith (NNReal.sqrt 2) ‚áëComplex.equivRealProd","decl":"theorem antilipschitz_equivRealProd : AntilipschitzWith (NNReal.sqrt 2) equivRealProd :=\n  AddMonoidHomClass.antilipschitz_of_bound equivRealProdLm fun z ‚Ü¶ by\n    simpa only [Real.coe_sqrt, NNReal.coe_ofNat] using abs_le_sqrt_two_mul_max z\n\n"}
{"name":"Complex.isUniformEmbedding_equivRealProd","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ IsUniformEmbedding ‚áëComplex.equivRealProd","decl":"theorem isUniformEmbedding_equivRealProd : IsUniformEmbedding equivRealProd :=\n  antilipschitz_equivRealProd.isUniformEmbedding lipschitz_equivRealProd.uniformContinuous\n\n"}
{"name":"Complex.uniformEmbedding_equivRealProd","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ IsUniformEmbedding ‚áëComplex.equivRealProd","decl":"@[deprecated (since := \"2024-10-01\")]\nalias uniformEmbedding_equivRealProd := isUniformEmbedding_equivRealProd\n\n"}
{"name":"Complex.instCompleteSpace","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ CompleteSpace Complex","decl":"instance : CompleteSpace ‚ÑÇ :=\n  (completeSpace_congr isUniformEmbedding_equivRealProd).mpr inferInstance\n\n"}
{"name":"Complex.instT2Space","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ T2Space Complex","decl":"instance instT2Space : T2Space ‚ÑÇ := TopologicalSpace.t2Space_of_metrizableSpace\n\n"}
{"name":"Complex.equivRealProdCLM_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"a‚úù : Complex\n‚ä¢ Eq (Complex.equivRealProdCLM a‚úù) { fst := a‚úù.re, snd := a‚úù.im }","decl":"/-- The natural `ContinuousLinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdCLM : ‚ÑÇ ‚âÉL[‚Ñù] ‚Ñù √ó ‚Ñù :=\n  equivRealProdLm.toContinuousLinearEquivOfBounds 1 (‚àö2) equivRealProd_apply_le' fun p =>\n    abs_le_sqrt_two_mul_max (equivRealProd.symm p)\n\n"}
{"name":"Complex.equivRealProdCLM_symm_apply_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"a‚úù : Prod Real Real\n‚ä¢ Eq (Complex.equivRealProdCLM.symm a‚úù).im a‚úù.2","decl":"/-- The natural `ContinuousLinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdCLM : ‚ÑÇ ‚âÉL[‚Ñù] ‚Ñù √ó ‚Ñù :=\n  equivRealProdLm.toContinuousLinearEquivOfBounds 1 (‚àö2) equivRealProd_apply_le' fun p =>\n    abs_le_sqrt_two_mul_max (equivRealProd.symm p)\n\n"}
{"name":"Complex.equivRealProdCLM_symm_apply_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"a‚úù : Prod Real Real\n‚ä¢ Eq (Complex.equivRealProdCLM.symm a‚úù).re a‚úù.1","decl":"/-- The natural `ContinuousLinearEquiv` from `‚ÑÇ` to `‚Ñù √ó ‚Ñù`. -/\n@[simps! (config := { simpRhs := true }) apply symm_apply_re symm_apply_im]\ndef equivRealProdCLM : ‚ÑÇ ‚âÉL[‚Ñù] ‚Ñù √ó ‚Ñù :=\n  equivRealProdLm.toContinuousLinearEquivOfBounds 1 (‚àö2) equivRealProd_apply_le' fun p =>\n    abs_le_sqrt_two_mul_max (equivRealProd.symm p)\n\n"}
{"name":"Complex.equivRealProdCLM_symm_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"p : Prod Real Real\n‚ä¢ Eq (Complex.equivRealProdCLM.symm p) (HAdd.hAdd (‚Üëp.1) (HMul.hMul (‚Üëp.2) Complex.I))","decl":"theorem equivRealProdCLM_symm_apply (p : ‚Ñù √ó ‚Ñù) :\n    Complex.equivRealProdCLM.symm p = p.1 + p.2 * Complex.I := Complex.equivRealProd_symm_apply p\n\n"}
{"name":"Complex.instProperSpace","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ ProperSpace Complex","decl":"instance : ProperSpace ‚ÑÇ :=\n  (id lipschitz_equivRealProd : LipschitzWith 1 equivRealProdCLM.toHomeomorph).properSpace\n\n"}
{"name":"Complex.tendsto_abs_cocompact_atTop","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Filter.Tendsto (‚áëComplex.abs) (Filter.cocompact Complex) Filter.atTop","decl":"/-- The `abs` function on `‚ÑÇ` is proper. -/\ntheorem tendsto_abs_cocompact_atTop : Tendsto abs (cocompact ‚ÑÇ) atTop :=\n  tendsto_norm_cocompact_atTop\n\n"}
{"name":"Complex.tendsto_normSq_cocompact_atTop","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Filter.Tendsto (‚áëComplex.normSq) (Filter.cocompact Complex) Filter.atTop","decl":"/-- The `normSq` function on `‚ÑÇ` is proper. -/\ntheorem tendsto_normSq_cocompact_atTop : Tendsto normSq (cocompact ‚ÑÇ) atTop := by\n  simpa [mul_self_abs]\n    using tendsto_abs_cocompact_atTop.atTop_mul_atTop tendsto_abs_cocompact_atTop\n\n"}
{"name":"Complex.continuous_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Continuous Complex.re","decl":"@[continuity, fun_prop]\ntheorem continuous_re : Continuous re :=\n  reCLM.continuous\n\n"}
{"name":"Complex.uniformlyContinuous_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ UniformContinuous Complex.re","decl":"lemma uniformlyContinuous_re : UniformContinuous re :=\n  reCLM.uniformContinuous\n\n"}
{"name":"Complex.uniformlyContinous_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ UniformContinuous Complex.re","decl":"@[deprecated (since := \"2024-11-04\")] alias uniformlyContinous_re := uniformlyContinuous_re\n\n"}
{"name":"Complex.reCLM_coe","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (‚ÜëComplex.reCLM) Complex.reLm","decl":"@[simp]\ntheorem reCLM_coe : (reCLM : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù) = reLm :=\n  rfl\n\n"}
{"name":"Complex.reCLM_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Complex.reCLM z) z.re","decl":"@[simp]\ntheorem reCLM_apply (z : ‚ÑÇ) : (reCLM : ‚ÑÇ ‚Üí ‚Ñù) z = z.re :=\n  rfl\n\n"}
{"name":"Complex.continuous_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Continuous Complex.im","decl":"@[continuity, fun_prop]\ntheorem continuous_im : Continuous im :=\n  imCLM.continuous\n\n"}
{"name":"Complex.uniformlyContinuous_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ UniformContinuous Complex.im","decl":"lemma uniformlyContinuous_im : UniformContinuous im :=\n  imCLM.uniformContinuous\n\n"}
{"name":"Complex.uniformlyContinous_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ UniformContinuous Complex.im","decl":"@[deprecated (since := \"2024-11-04\")] alias uniformlyContinous_im := uniformlyContinuous_im\n\n"}
{"name":"Complex.imCLM_coe","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (‚ÜëComplex.imCLM) Complex.imLm","decl":"@[simp]\ntheorem imCLM_coe : (imCLM : ‚ÑÇ ‚Üí‚Çó[‚Ñù] ‚Ñù) = imLm :=\n  rfl\n\n"}
{"name":"Complex.imCLM_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Complex.imCLM z) z.im","decl":"@[simp]\ntheorem imCLM_apply (z : ‚ÑÇ) : (imCLM : ‚ÑÇ ‚Üí ‚Ñù) z = z.im :=\n  rfl\n\n"}
{"name":"Complex.restrictScalars_one_smulRight'","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"E : Type u_1\ninst‚úù¬π : SeminormedAddCommGroup E\ninst‚úù : NormedSpace Complex E\nx : E\n‚ä¢ Eq (ContinuousLinearMap.restrictScalars Real (ContinuousLinearMap.smulRight 1 x)) (HAdd.hAdd (Complex.reCLM.smulRight x) (HSMul.hSMul Complex.I (Complex.imCLM.smulRight x)))","decl":"theorem restrictScalars_one_smulRight' (x : E) :\n    ContinuousLinearMap.restrictScalars ‚Ñù ((1 : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).smulRight x : ‚ÑÇ ‚ÜíL[‚ÑÇ] E) =\n      reCLM.smulRight x + I ‚Ä¢ imCLM.smulRight x := by\n  ext ‚ü®a, b‚ü©\n  simp [map_add, mk_eq_add_mul_I, mul_smul, smul_comm I b x]\n\n"}
{"name":"Complex.restrictScalars_one_smulRight","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Complex\n‚ä¢ Eq (ContinuousLinearMap.restrictScalars Real (ContinuousLinearMap.smulRight 1 x)) (HSMul.hSMul x 1)","decl":"theorem restrictScalars_one_smulRight (x : ‚ÑÇ) :\n    ContinuousLinearMap.restrictScalars ‚Ñù ((1 : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ).smulRight x : ‚ÑÇ ‚ÜíL[‚ÑÇ] ‚ÑÇ) =\n    x ‚Ä¢ (1 : ‚ÑÇ ‚ÜíL[‚Ñù] ‚ÑÇ) := by\n  ext1 z\n  dsimp\n  apply mul_comm\n\n"}
{"name":"Complex.conjLIE_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Complex.conjLIE z) ((starRingEnd Complex) z)","decl":"@[simp]\ntheorem conjLIE_apply (z : ‚ÑÇ) : conjLIE z = conj z :=\n  rfl\n\n"}
{"name":"Complex.conjLIE_symm","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq Complex.conjLIE.symm Complex.conjLIE","decl":"@[simp]\ntheorem conjLIE_symm : conjLIE.symm = conjLIE :=\n  rfl\n\n"}
{"name":"Complex.isometry_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Isometry ‚áë(starRingEnd Complex)","decl":"theorem isometry_conj : Isometry (conj : ‚ÑÇ ‚Üí ‚ÑÇ) :=\n  conjLIE.isometry\n\n"}
{"name":"Complex.dist_conj_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\n‚ä¢ Eq (Dist.dist ((starRingEnd Complex) z) ((starRingEnd Complex) w)) (Dist.dist z w)","decl":"@[simp]\ntheorem dist_conj_conj (z w : ‚ÑÇ) : dist (conj z) (conj w) = dist z w :=\n  isometry_conj.dist_eq z w\n\n"}
{"name":"Complex.nndist_conj_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\n‚ä¢ Eq (NNDist.nndist ((starRingEnd Complex) z) ((starRingEnd Complex) w)) (NNDist.nndist z w)","decl":"@[simp]\ntheorem nndist_conj_conj (z w : ‚ÑÇ) : nndist (conj z) (conj w) = nndist z w :=\n  isometry_conj.nndist_eq z w\n\n"}
{"name":"Complex.dist_conj_comm","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\n‚ä¢ Eq (Dist.dist ((starRingEnd Complex) z) w) (Dist.dist z ((starRingEnd Complex) w))","decl":"theorem dist_conj_comm (z w : ‚ÑÇ) : dist (conj z) w = dist z (conj w) := by\n  rw [‚Üê dist_conj_conj, conj_conj]\n\n"}
{"name":"Complex.nndist_conj_comm","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z w : Complex\n‚ä¢ Eq (NNDist.nndist ((starRingEnd Complex) z) w) (NNDist.nndist z ((starRingEnd Complex) w))","decl":"theorem nndist_conj_comm (z w : ‚ÑÇ) : nndist (conj z) w = nndist z (conj w) :=\n  Subtype.ext <| dist_conj_comm _ _\n\n"}
{"name":"Complex.instContinuousStar","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ ContinuousStar Complex","decl":"instance : ContinuousStar ‚ÑÇ :=\n  ‚ü®conjLIE.continuous‚ü©\n\n"}
{"name":"Complex.continuous_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Continuous ‚áë(starRingEnd Complex)","decl":"@[continuity]\ntheorem continuous_conj : Continuous (conj : ‚ÑÇ ‚Üí ‚ÑÇ) :=\n  continuous_star\n\n"}
{"name":"Complex.ringHom_eq_id_or_conj_of_continuous","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"f : RingHom Complex Complex\nhf : Continuous ‚áëf\n‚ä¢ Or (Eq f (RingHom.id Complex)) (Eq f (starRingEnd Complex))","decl":"/-- The only continuous ring homomorphisms from `‚ÑÇ` to `‚ÑÇ` are the identity and the complex\nconjugation. -/\ntheorem ringHom_eq_id_or_conj_of_continuous {f : ‚ÑÇ ‚Üí+* ‚ÑÇ} (hf : Continuous f) :\n    f = RingHom.id ‚ÑÇ ‚à® f = conj := by\n  simpa only [DFunLike.ext_iff] using real_algHom_eq_id_or_conj (AlgHom.mk' f (map_real_smul f hf))\n\n"}
{"name":"Complex.conjCLE_coe","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq Complex.conjCLE.toLinearEquiv Complex.conjAe.toLinearEquiv","decl":"@[simp]\ntheorem conjCLE_coe : conjCLE.toLinearEquiv = conjAe.toLinearEquiv :=\n  rfl\n\n"}
{"name":"Complex.conjCLE_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (Complex.conjCLE z) ((starRingEnd Complex) z)","decl":"@[simp]\ntheorem conjCLE_apply (z : ‚ÑÇ) : conjCLE z = conj z :=\n  rfl\n\n"}
{"name":"Complex.isometry_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Isometry Complex.ofReal","decl":"theorem isometry_ofReal : Isometry ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) :=\n  ofRealLI.isometry\n\n"}
{"name":"Complex.continuous_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Continuous Complex.ofReal","decl":"@[continuity, fun_prop]\ntheorem continuous_ofReal : Continuous ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) :=\n  ofRealLI.continuous\n\n"}
{"name":"Complex.isUniformEmbedding_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ IsUniformEmbedding Complex.ofReal","decl":"theorem isUniformEmbedding_ofReal : IsUniformEmbedding ((‚Üë) : ‚Ñù ‚Üí ‚ÑÇ) :=\n  ofRealLI.isometry.isUniformEmbedding\n\n"}
{"name":"Filter.tendsto_ofReal_iff","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\nf : Œ± ‚Üí Real\nx : Real\n‚ä¢ Iff (Filter.Tendsto (fun x => ‚Üë(f x)) l (nhds ‚Üëx)) (Filter.Tendsto f l (nhds x))","decl":"theorem _root_.Filter.tendsto_ofReal_iff {Œ± : Type*} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} {x : ‚Ñù} :\n    Tendsto (fun x ‚Ü¶ (f x : ‚ÑÇ)) l (ùìù (x : ‚ÑÇ)) ‚Üî Tendsto f l (ùìù x) :=\n  isUniformEmbedding_ofReal.isClosedEmbedding.tendsto_nhds_iff.symm\n\n"}
{"name":"Filter.Tendsto.ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_2\nl : Filter Œ±\nf : Œ± ‚Üí Real\nx : Real\nhf : Filter.Tendsto f l (nhds x)\n‚ä¢ Filter.Tendsto (fun x => ‚Üë(f x)) l (nhds ‚Üëx)","decl":"lemma _root_.Filter.Tendsto.ofReal {Œ± : Type*} {l : Filter Œ±} {f : Œ± ‚Üí ‚Ñù} {x : ‚Ñù}\n    (hf : Tendsto f l (ùìù x)) : Tendsto (fun x ‚Ü¶ (f x : ‚ÑÇ)) l (ùìù (x : ‚ÑÇ)) :=\n  tendsto_ofReal_iff.mpr hf\n\n"}
{"name":"Complex.ringHom_eq_ofReal_of_continuous","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"f : RingHom Real Complex\nh : Continuous ‚áëf\n‚ä¢ Eq f Complex.ofRealHom","decl":"/-- The only continuous ring homomorphism from `‚Ñù` to `‚ÑÇ` is the identity. -/\ntheorem ringHom_eq_ofReal_of_continuous {f : ‚Ñù ‚Üí+* ‚ÑÇ} (h : Continuous f) : f = ofRealHom := by\n  convert congr_arg AlgHom.toRingHom <| Subsingleton.elim (AlgHom.mk' f <| map_real_smul f h)\n    (Algebra.ofId ‚Ñù ‚ÑÇ)\n\n"}
{"name":"Complex.ofRealCLM_coe","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (‚ÜëComplex.ofRealCLM) Complex.ofRealAm.toLinearMap","decl":"@[simp]\ntheorem ofRealCLM_coe : (ofRealCLM : ‚Ñù ‚Üí‚Çó[‚Ñù] ‚ÑÇ) = ofRealAm.toLinearMap :=\n  rfl\n\n"}
{"name":"Complex.ofRealCLM_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Real\n‚ä¢ Eq (Complex.ofRealCLM x) ‚Üëx","decl":"@[simp]\ntheorem ofRealCLM_apply (x : ‚Ñù) : ofRealCLM x = x :=\n  rfl\n\n"}
{"name":"RCLike.re_eq_complex_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (‚áëRCLike.re) Complex.re","decl":"theorem _root_.RCLike.re_eq_complex_re : ‚áë(RCLike.re : ‚ÑÇ ‚Üí+ ‚Ñù) = Complex.re :=\n  rfl\n\n"}
{"name":"RCLike.im_eq_complex_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (‚áëRCLike.im) Complex.im","decl":"theorem _root_.RCLike.im_eq_complex_im : ‚áë(RCLike.im : ‚ÑÇ ‚Üí+ ‚Ñù) = Complex.im :=\n  rfl\n\n-- TODO: Replace `mul_conj` and `conj_mul` once `norm` has replaced `abs`\n"}
{"name":"Complex.mul_conj'","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (HMul.hMul z ((starRingEnd Complex) z)) (HPow.hPow (‚Üë(Norm.norm z)) 2)","decl":"lemma mul_conj' (z : ‚ÑÇ) : z * conj z = ‚Äñz‚Äñ ^ 2 := RCLike.mul_conj z\n"}
{"name":"Complex.conj_mul'","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Eq (HMul.hMul ((starRingEnd Complex) z) z) (HPow.hPow (‚Üë(Norm.norm z)) 2)","decl":"lemma conj_mul' (z : ‚ÑÇ) : conj z * z = ‚Äñz‚Äñ ^ 2 := RCLike.conj_mul z\n\n"}
{"name":"Complex.inv_eq_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\nhz : Eq (Norm.norm z) 1\n‚ä¢ Eq (Inv.inv z) ((starRingEnd Complex) z)","decl":"lemma inv_eq_conj (hz : ‚Äñz‚Äñ = 1) : z‚Åª¬π = conj z := RCLike.inv_eq_conj hz\n\n"}
{"name":"Complex.exists_norm_eq_mul_self","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Exists fun c => And (Eq (Norm.norm c) 1) (Eq (‚Üë(Norm.norm z)) (HMul.hMul c z))","decl":"lemma exists_norm_eq_mul_self (z : ‚ÑÇ) : ‚àÉ c, ‚Äñc‚Äñ = 1 ‚àß ‚Äñz‚Äñ = c * z :=\n  RCLike.exists_norm_eq_mul_self _\n\n"}
{"name":"Complex.exists_norm_mul_eq_self","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Exists fun c => And (Eq (Norm.norm c) 1) (Eq (HMul.hMul c ‚Üë(Norm.norm z)) z)","decl":"lemma exists_norm_mul_eq_self (z : ‚ÑÇ) : ‚àÉ c, ‚Äñc‚Äñ = 1 ‚àß c * ‚Äñz‚Äñ = z :=\n  RCLike.exists_norm_mul_eq_self _\n\n"}
{"name":"RCLike.complexRingEquiv_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"ùïú : Type u_2\ninst‚úù : RCLike ùïú\nh : Eq (RCLike.im RCLike.I) 1\nx : ùïú\n‚ä¢ Eq ((RCLike.complexRingEquiv h) x) (HAdd.hAdd (‚Üë(RCLike.re x)) (HMul.hMul (‚Üë(RCLike.im x)) Complex.I))","decl":"/-- The natural isomorphism between `ùïú` satisfying `RCLike ùïú` and `‚ÑÇ` when\n`RCLike.im RCLike.I = 1`. -/\n@[simps]\ndef _root_.RCLike.complexRingEquiv {ùïú : Type*} [RCLike ùïú]\n    (h : RCLike.im (RCLike.I : ùïú) = 1) : ùïú ‚âÉ+* ‚ÑÇ where\n  toFun x := RCLike.re x + RCLike.im x * I\n  invFun x := re x + im x * RCLike.I\n  left_inv x := by simp\n  right_inv x := by simp [h]\n  map_add' x y := by simp only [map_add, ofReal_add]; ring\n  map_mul' x y := by\n    simp only [RCLike.mul_re, ofReal_sub, ofReal_mul, RCLike.mul_im, ofReal_add]\n    ring_nf\n    rw [I_sq]\n    ring\n\n"}
{"name":"RCLike.complexRingEquiv_symm_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"ùïú : Type u_2\ninst‚úù : RCLike ùïú\nh : Eq (RCLike.im RCLike.I) 1\nx : Complex\n‚ä¢ Eq ((RCLike.complexRingEquiv h).symm x) (HAdd.hAdd (‚Üëx.re) (HMul.hMul (‚Üëx.im) RCLike.I))","decl":"/-- The natural isomorphism between `ùïú` satisfying `RCLike ùïú` and `‚ÑÇ` when\n`RCLike.im RCLike.I = 1`. -/\n@[simps]\ndef _root_.RCLike.complexRingEquiv {ùïú : Type*} [RCLike ùïú]\n    (h : RCLike.im (RCLike.I : ùïú) = 1) : ùïú ‚âÉ+* ‚ÑÇ where\n  toFun x := RCLike.re x + RCLike.im x * I\n  invFun x := re x + im x * RCLike.I\n  left_inv x := by simp\n  right_inv x := by simp [h]\n  map_add' x y := by simp only [map_add, ofReal_add]; ring\n  map_mul' x y := by\n    simp only [RCLike.mul_re, ofReal_sub, ofReal_mul, RCLike.mul_im, ofReal_add]\n    ring_nf\n    rw [I_sq]\n    ring\n\n"}
{"name":"RCLike.complexLinearIsometryEquiv_symm_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"ùïú : Type u_2\ninst‚úù : RCLike ùïú\nh : Eq (RCLike.im RCLike.I) 1\na‚úù : Complex\n‚ä¢ Eq ((RCLike.complexLinearIsometryEquiv h).symm a‚úù) ((RCLike.complexRingEquiv h).invFun a‚úù)","decl":"/-- The natural `‚Ñù`-linear isometry equivalence between `ùïú` satisfying `RCLike ùïú` and `‚ÑÇ` when\n`RCLike.im RCLike.I = 1`. -/\n@[simps]\ndef _root_.RCLike.complexLinearIsometryEquiv {ùïú : Type*} [RCLike ùïú]\n    (h : RCLike.im (RCLike.I : ùïú) = 1) : ùïú ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ where\n  map_smul' _ _ := by simp [RCLike.smul_re, RCLike.smul_im, ofReal_mul]; ring\n  norm_map' _ := by\n    rw [‚Üê sq_eq_sq‚ÇÄ (by positivity) (by positivity), ‚Üê normSq_eq_norm_sq, ‚Üê RCLike.normSq_eq_def',\n      RCLike.normSq_apply]\n    simp [normSq_add]\n  __ := RCLike.complexRingEquiv h\n\n"}
{"name":"RCLike.complexLinearIsometryEquiv_apply","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"ùïú : Type u_2\ninst‚úù : RCLike ùïú\nh : Eq (RCLike.im RCLike.I) 1\na‚úù : ùïú\n‚ä¢ Eq ((RCLike.complexLinearIsometryEquiv h) a‚úù) ((RCLike.complexRingEquiv h).toFun a‚úù)","decl":"/-- The natural `‚Ñù`-linear isometry equivalence between `ùïú` satisfying `RCLike ùïú` and `‚ÑÇ` when\n`RCLike.im RCLike.I = 1`. -/\n@[simps]\ndef _root_.RCLike.complexLinearIsometryEquiv {ùïú : Type*} [RCLike ùïú]\n    (h : RCLike.im (RCLike.I : ùïú) = 1) : ùïú ‚âÉ‚Çó·µ¢[‚Ñù] ‚ÑÇ where\n  map_smul' _ _ := by simp [RCLike.smul_re, RCLike.smul_im, ofReal_mul]; ring\n  norm_map' _ := by\n    rw [‚Üê sq_eq_sq‚ÇÄ (by positivity) (by positivity), ‚Üê normSq_eq_norm_sq, ‚Üê RCLike.normSq_eq_def',\n      RCLike.normSq_apply]\n    simp [normSq_add]\n  __ := RCLike.complexRingEquiv h\n\n"}
{"name":"Complex.isometry_intCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Isometry Int.cast","decl":"theorem isometry_intCast : Isometry ((‚Üë) : ‚Ñ§ ‚Üí ‚ÑÇ) :=\n  Isometry.of_dist_eq <| by simp_rw [‚Üê Complex.ofReal_intCast,\n    Complex.isometry_ofReal.dist_eq, Int.dist_cast_real, implies_true]\n\n"}
{"name":"Complex.closedEmbedding_intCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Topology.IsClosedEmbedding Int.cast","decl":"theorem closedEmbedding_intCast : IsClosedEmbedding ((‚Üë) : ‚Ñ§ ‚Üí ‚ÑÇ) :=\n  isometry_intCast.isClosedEmbedding\n\n"}
{"name":"Complex.isClosed_range_intCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ IsClosed (Set.range Int.cast)","decl":"lemma isClosed_range_intCast : IsClosed (Set.range ((‚Üë) : ‚Ñ§ ‚Üí ‚ÑÇ)) :=\n  Complex.closedEmbedding_intCast.isClosed_range\n\n"}
{"name":"Complex.isOpen_compl_range_intCast","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ IsOpen (HasCompl.compl (Set.range Int.cast))","decl":"lemma isOpen_compl_range_intCast : IsOpen (Set.range ((‚Üë) : ‚Ñ§ ‚Üí ‚ÑÇ))·∂ú :=\n  Complex.isClosed_range_intCast.isOpen_compl\n\n"}
{"name":"Complex.eq_coe_norm_of_nonneg","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\nhz : LE.le 0 z\n‚ä¢ Eq z ‚Üë(Norm.norm z)","decl":"theorem eq_coe_norm_of_nonneg {z : ‚ÑÇ} (hz : 0 ‚â§ z) : z = ‚Üë‚Äñz‚Äñ := by\n  lift z to ‚Ñù using hz.2.symm\n  rw [norm_eq_abs, abs_ofReal, _root_.abs_of_nonneg (id hz.1 : 0 ‚â§ z)]\n\n"}
{"name":"Complex.orderClosedTopology","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ OrderClosedTopology Complex","decl":"/-- We show that the partial order and the topology on `‚ÑÇ` are compatible.\nWe turn this into an instance scoped to `ComplexOrder`. -/\nlemma orderClosedTopology : OrderClosedTopology ‚ÑÇ where\n  isClosed_le' := by\n    simp_rw [le_def, Set.setOf_and]\n    refine IsClosed.inter (isClosed_le ?_ ?_) (isClosed_eq ?_ ?_) <;> continuity\n\n"}
{"name":"RCLike.re_to_complex","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Complex\n‚ä¢ Eq (RCLike.re x) x.re","decl":"@[simp]\ntheorem re_to_complex {x : ‚ÑÇ} : reC x = x.re :=\n  rfl\n\n"}
{"name":"RCLike.im_to_complex","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Complex\n‚ä¢ Eq (RCLike.im x) x.im","decl":"@[simp]\ntheorem im_to_complex {x : ‚ÑÇ} : imC x = x.im :=\n  rfl\n\n"}
{"name":"RCLike.I_to_complex","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq RCLike.I Complex.I","decl":"@[simp]\ntheorem I_to_complex : IC = Complex.I :=\n  rfl\n\n"}
{"name":"RCLike.normSq_to_complex","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Complex\n‚ä¢ Eq (RCLike.normSq x) (Complex.normSq x)","decl":"@[simp]\ntheorem normSq_to_complex {x : ‚ÑÇ} : norm_sqC x = Complex.normSq x :=\n  rfl\n\n"}
{"name":"RCLike.hasSum_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nx : ùïú\n‚ä¢ Iff (HasSum (fun x => (starRingEnd ùïú) (f x)) x) (HasSum f ((starRingEnd ùïú) x))","decl":"@[simp]\ntheorem hasSum_conj {f : Œ± ‚Üí ùïú} {x : ùïú} : HasSum (fun x => conj (f x)) x ‚Üî HasSum f (conj x) :=\n  conjCLE.hasSum\n\n"}
{"name":"RCLike.hasSum_conj'","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nx : ùïú\n‚ä¢ Iff (HasSum (fun x => (starRingEnd ùïú) (f x)) ((starRingEnd ùïú) x)) (HasSum f x)","decl":"theorem hasSum_conj' {f : Œ± ‚Üí ùïú} {x : ùïú} : HasSum (fun x => conj (f x)) (conj x) ‚Üî HasSum f x :=\n  conjCLE.hasSum'\n\n"}
{"name":"RCLike.summable_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\n‚ä¢ Iff (Summable fun x => (starRingEnd ùïú) (f x)) (Summable f)","decl":"@[simp]\ntheorem summable_conj {f : Œ± ‚Üí ùïú} : (Summable fun x => conj (f x)) ‚Üî Summable f :=\n  summable_star_iff\n\n"}
{"name":"RCLike.conj_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\n‚ä¢ Eq ((starRingEnd ùïú) (tsum fun a => f a)) (tsum fun a => (starRingEnd ùïú) (f a))","decl":"theorem conj_tsum (f : Œ± ‚Üí ùïú) : conj (‚àë' a, f a) = ‚àë' a, conj (f a) :=\n  tsum_star\n\n"}
{"name":"RCLike.hasSum_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí Real\nx : Real\n‚ä¢ Iff (HasSum (fun x => ‚Üë(f x)) ‚Üëx) (HasSum f x)","decl":"@[simp, norm_cast]\ntheorem hasSum_ofReal {f : Œ± ‚Üí ‚Ñù} {x : ‚Ñù} : HasSum (fun x => (f x : ùïú)) x ‚Üî HasSum f x :=\n  ‚ü®fun h => by simpa only [RCLike.reCLM_apply, RCLike.ofReal_re] using reCLM.hasSum h,\n    ofRealCLM.hasSum‚ü©\n\n"}
{"name":"RCLike.summable_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Summable fun x => ‚Üë(f x)) (Summable f)","decl":"@[simp, norm_cast]\ntheorem summable_ofReal {f : Œ± ‚Üí ‚Ñù} : (Summable fun x => (f x : ùïú)) ‚Üî Summable f :=\n  ‚ü®fun h => by simpa only [RCLike.reCLM_apply, RCLike.ofReal_re] using reCLM.summable h,\n    ofRealCLM.summable‚ü©\n\n"}
{"name":"RCLike.ofReal_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí Real\n‚ä¢ Eq (‚Üë(tsum fun a => f a)) (tsum fun a => ‚Üë(f a))","decl":"@[norm_cast]\ntheorem ofReal_tsum (f : Œ± ‚Üí ‚Ñù) : (‚Üë(‚àë' a, f a) : ùïú) = ‚àë' a, (f a : ùïú) := by\n  by_cases h : Summable f\n  ¬∑ exact ContinuousLinearMap.map_tsum ofRealCLM h\n  ¬∑ rw [tsum_eq_zero_of_not_summable h,\n      tsum_eq_zero_of_not_summable ((summable_ofReal _).not.mpr h), ofReal_zero]\n\n"}
{"name":"RCLike.hasSum_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nx : ùïú\nh : HasSum f x\n‚ä¢ HasSum (fun x => RCLike.re (f x)) (RCLike.re x)","decl":"theorem hasSum_re {f : Œ± ‚Üí ùïú} {x : ùïú} (h : HasSum f x) : HasSum (fun x => re (f x)) (re x) :=\n  reCLM.hasSum h\n\n"}
{"name":"RCLike.hasSum_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nx : ùïú\nh : HasSum f x\n‚ä¢ HasSum (fun x => RCLike.im (f x)) (RCLike.im x)","decl":"theorem hasSum_im {f : Œ± ‚Üí ùïú} {x : ùïú} (h : HasSum f x) : HasSum (fun x => im (f x)) (im x) :=\n  imCLM.hasSum h\n\n"}
{"name":"RCLike.re_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nh : Summable f\n‚ä¢ Eq (RCLike.re (tsum fun a => f a)) (tsum fun a => RCLike.re (f a))","decl":"theorem re_tsum {f : Œ± ‚Üí ùïú} (h : Summable f) : re (‚àë' a, f a) = ‚àë' a, re (f a) :=\n  reCLM.map_tsum h\n\n"}
{"name":"RCLike.im_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nh : Summable f\n‚ä¢ Eq (RCLike.im (tsum fun a => f a)) (tsum fun a => RCLike.im (f a))","decl":"theorem im_tsum {f : Œ± ‚Üí ùïú} (h : Summable f) : im (‚àë' a, f a) = ‚àë' a, im (f a) :=\n  imCLM.map_tsum h\n\n"}
{"name":"RCLike.hasSum_iff","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nùïú : Type u_2\ninst‚úù : RCLike ùïú\nf : Œ± ‚Üí ùïú\nc : ùïú\n‚ä¢ Iff (HasSum f c) (And (HasSum (fun x => RCLike.re (f x)) (RCLike.re c)) (HasSum (fun x => RCLike.im (f x)) (RCLike.im c)))","decl":"theorem hasSum_iff (f : Œ± ‚Üí ùïú) (c : ùïú) :\n    HasSum f c ‚Üî HasSum (fun x => re (f x)) (re c) ‚àß HasSum (fun x => im (f x)) (im c) := by\n  refine ‚ü®fun h => ‚ü®hasSum_re _ h, hasSum_im _ h‚ü©, ?_‚ü©\n  rintro ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©\n  simpa only [re_add_im] using\n    ((hasSum_ofReal ùïú).mpr h‚ÇÅ).add (((hasSum_ofReal ùïú).mpr h‚ÇÇ).mul_right I)\n\n"}
{"name":"Complex.hasProd_abs","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nx : Complex\nhfx : HasProd f x\n‚ä¢ HasProd (fun i => Complex.abs (f i)) (Complex.abs x)","decl":"theorem hasProd_abs {x : ‚ÑÇ} (hfx : HasProd f x) : HasProd (fun i ‚Ü¶ (f i).abs) x.abs :=\n  hfx.norm\n\n"}
{"name":"Complex.multipliable_abs","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nhf : Multipliable f\n‚ä¢ Multipliable fun i => Complex.abs (f i)","decl":"theorem multipliable_abs (hf : Multipliable f) : Multipliable (fun i ‚Ü¶ (f i).abs) :=\n  hf.norm\n\n"}
{"name":"Complex.abs_tprod","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nh : Multipliable f\n‚ä¢ Eq (Complex.abs (tprod fun i => f i)) (tprod fun i => Complex.abs (f i))","decl":"theorem abs_tprod (h : Multipliable f) : (‚àè' i, f i).abs = ‚àè' i, (f i).abs :=\n  norm_tprod h\n\n"}
{"name":"Complex.hasSum_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nx : Complex\n‚ä¢ Iff (HasSum (fun x => (starRingEnd Complex) (f x)) x) (HasSum f ((starRingEnd Complex) x))","decl":"theorem hasSum_conj {f : Œ± ‚Üí ‚ÑÇ} {x : ‚ÑÇ} : HasSum (fun x => conj (f x)) x ‚Üî HasSum f (conj x) :=\n  RCLike.hasSum_conj _\n\n"}
{"name":"Complex.hasSum_conj'","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nx : Complex\n‚ä¢ Iff (HasSum (fun x => (starRingEnd Complex) (f x)) ((starRingEnd Complex) x)) (HasSum f x)","decl":"theorem hasSum_conj' {f : Œ± ‚Üí ‚ÑÇ} {x : ‚ÑÇ} : HasSum (fun x => conj (f x)) (conj x) ‚Üî HasSum f x :=\n  RCLike.hasSum_conj' _\n\n-- Porting note: @[simp] unneeded due to `RCLike.summable_conj`\n"}
{"name":"Complex.summable_conj","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\n‚ä¢ Iff (Summable fun x => (starRingEnd Complex) (f x)) (Summable f)","decl":"theorem summable_conj {f : Œ± ‚Üí ‚ÑÇ} : (Summable fun x => conj (f x)) ‚Üî Summable f :=\n  RCLike.summable_conj _\n\n"}
{"name":"Complex.conj_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\n‚ä¢ Eq ((starRingEnd Complex) (tsum fun a => f a)) (tsum fun a => (starRingEnd Complex) (f a))","decl":"theorem conj_tsum (f : Œ± ‚Üí ‚ÑÇ) : conj (‚àë' a, f a) = ‚àë' a, conj (f a) :=\n  RCLike.conj_tsum _\n\n"}
{"name":"Complex.hasSum_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\nx : Real\n‚ä¢ Iff (HasSum (fun x => ‚Üë(f x)) ‚Üëx) (HasSum f x)","decl":"@[simp, norm_cast]\ntheorem hasSum_ofReal {f : Œ± ‚Üí ‚Ñù} {x : ‚Ñù} : HasSum (fun x => (f x : ‚ÑÇ)) x ‚Üî HasSum f x :=\n  RCLike.hasSum_ofReal _\n\n"}
{"name":"Complex.summable_ofReal","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Summable fun x => ‚Üë(f x)) (Summable f)","decl":"@[simp, norm_cast]\ntheorem summable_ofReal {f : Œ± ‚Üí ‚Ñù} : (Summable fun x => (f x : ‚ÑÇ)) ‚Üî Summable f :=\n  RCLike.summable_ofReal _\n\n"}
{"name":"Complex.ofReal_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Real\n‚ä¢ Eq (‚Üë(tsum fun a => f a)) (tsum fun a => ‚Üë(f a))","decl":"@[norm_cast]\ntheorem ofReal_tsum (f : Œ± ‚Üí ‚Ñù) : (‚Üë(‚àë' a, f a) : ‚ÑÇ) = ‚àë' a, ‚Üë(f a) :=\n  RCLike.ofReal_tsum _ _\n\n"}
{"name":"Complex.hasSum_re","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nx : Complex\nh : HasSum f x\n‚ä¢ HasSum (fun x => (f x).re) x.re","decl":"theorem hasSum_re {f : Œ± ‚Üí ‚ÑÇ} {x : ‚ÑÇ} (h : HasSum f x) : HasSum (fun x => (f x).re) x.re :=\n  RCLike.hasSum_re ‚ÑÇ h\n\n"}
{"name":"Complex.hasSum_im","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nx : Complex\nh : HasSum f x\n‚ä¢ HasSum (fun x => (f x).im) x.im","decl":"theorem hasSum_im {f : Œ± ‚Üí ‚ÑÇ} {x : ‚ÑÇ} (h : HasSum f x) : HasSum (fun x => (f x).im) x.im :=\n  RCLike.hasSum_im ‚ÑÇ h\n\n"}
{"name":"Complex.re_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nh : Summable f\n‚ä¢ Eq (tsum fun a => f a).re (tsum fun a => (f a).re)","decl":"theorem re_tsum {f : Œ± ‚Üí ‚ÑÇ} (h : Summable f) : (‚àë' a, f a).re = ‚àë' a, (f a).re :=\n  RCLike.re_tsum _ h\n\n"}
{"name":"Complex.im_tsum","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nh : Summable f\n‚ä¢ Eq (tsum fun a => f a).im (tsum fun a => (f a).im)","decl":"theorem im_tsum {f : Œ± ‚Üí ‚ÑÇ} (h : Summable f) : (‚àë' a, f a).im = ‚àë' a, (f a).im :=\n  RCLike.im_tsum _ h\n\n"}
{"name":"Complex.hasSum_iff","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"Œ± : Type u_1\nf : Œ± ‚Üí Complex\nc : Complex\n‚ä¢ Iff (HasSum f c) (And (HasSum (fun x => (f x).re) c.re) (HasSum (fun x => (f x).im) c.im))","decl":"theorem hasSum_iff (f : Œ± ‚Üí ‚ÑÇ) (c : ‚ÑÇ) :\n    HasSum f c ‚Üî HasSum (fun x => (f x).re) c.re ‚àß HasSum (fun x => (f x).im) c.im :=\n  RCLike.hasSum_iff _ _\n\n"}
{"name":"Complex.mem_slitPlane_iff","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Iff (Membership.mem Complex.slitPlane z) (Or (LT.lt 0 z.re) (Ne z.im 0))","decl":"lemma mem_slitPlane_iff {z : ‚ÑÇ} : z ‚àà slitPlane ‚Üî 0 < z.re ‚à® z.im ‚â† 0 := Set.mem_setOf\n\n"}
{"name":"Complex.slitPlane_eq_union","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq Complex.slitPlane (Union.union (setOf fun z => LT.lt 0 z.re) (setOf fun z => Ne z.im 0))","decl":"lemma slitPlane_eq_union : slitPlane = {z | 0 < z.re} ‚à™ {z | z.im ‚â† 0} := Set.setOf_or.symm\n\n"}
{"name":"Complex.isOpen_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ IsOpen Complex.slitPlane","decl":"lemma isOpen_slitPlane : IsOpen slitPlane :=\n  (isOpen_lt continuous_const continuous_re).union (isOpen_ne_fun continuous_im continuous_const)\n\n"}
{"name":"Complex.ofReal_mem_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Real\n‚ä¢ Iff (Membership.mem Complex.slitPlane ‚Üëx) (LT.lt 0 x)","decl":"@[simp]\nlemma ofReal_mem_slitPlane {x : ‚Ñù} : ‚Üëx ‚àà slitPlane ‚Üî 0 < x := by simp [mem_slitPlane_iff]\n\n"}
{"name":"Complex.neg_ofReal_mem_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"x : Real\n‚ä¢ Iff (Membership.mem Complex.slitPlane (Neg.neg ‚Üëx)) (LT.lt x 0)","decl":"@[simp]\nlemma neg_ofReal_mem_slitPlane {x : ‚Ñù} : -‚Üëx ‚àà slitPlane ‚Üî x < 0 := by\n  simpa using ofReal_mem_slitPlane (x := -x)\n\n"}
{"name":"Complex.one_mem_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Membership.mem Complex.slitPlane 1","decl":"@[simp] lemma one_mem_slitPlane : 1 ‚àà slitPlane := ofReal_mem_slitPlane.2 one_pos\n\n"}
{"name":"Complex.zero_not_mem_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Not (Membership.mem Complex.slitPlane 0)","decl":"@[simp]\nlemma zero_not_mem_slitPlane : 0 ‚àâ slitPlane := mt ofReal_mem_slitPlane.1 (lt_irrefl _)\n\n"}
{"name":"Complex.natCast_mem_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\n‚ä¢ Iff (Membership.mem Complex.slitPlane ‚Üën) (Ne n 0)","decl":"@[simp]\nlemma natCast_mem_slitPlane {n : ‚Ñï} : ‚Üën ‚àà slitPlane ‚Üî n ‚â† 0 := by\n  simpa [pos_iff_ne_zero] using @ofReal_mem_slitPlane n\n\n"}
{"name":"Complex.ofNat_mem_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"n : Nat\ninst‚úù : n.AtLeastTwo\n‚ä¢ Membership.mem Complex.slitPlane (OfNat.ofNat n)","decl":"@[simp]\nlemma ofNat_mem_slitPlane (n : ‚Ñï) [n.AtLeastTwo] : ofNat(n) ‚àà slitPlane :=\n  natCast_mem_slitPlane.2 (NeZero.ne n)\n\n"}
{"name":"Complex.mem_slitPlane_iff_not_le_zero","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\n‚ä¢ Iff (Membership.mem Complex.slitPlane z) (Not (LE.le z 0))","decl":"lemma mem_slitPlane_iff_not_le_zero {z : ‚ÑÇ} : z ‚àà slitPlane ‚Üî ¬¨z ‚â§ 0 :=\n  mem_slitPlane_iff.trans not_le_zero_iff.symm\n\n"}
{"name":"Complex.compl_Iic_zero","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ Eq (HasCompl.compl (Set.Iic 0)) Complex.slitPlane","decl":"protected lemma compl_Iic_zero : (Set.Iic 0)·∂ú = slitPlane := Set.ext fun _ ‚Ü¶\n  mem_slitPlane_iff_not_le_zero.symm\n\n"}
{"name":"Complex.slitPlane_ne_zero","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\nhz : Membership.mem Complex.slitPlane z\n‚ä¢ Ne z 0","decl":"lemma slitPlane_ne_zero {z : ‚ÑÇ} (hz : z ‚àà slitPlane) : z ‚â† 0 :=\n  ne_of_mem_of_not_mem hz zero_not_mem_slitPlane\n\n"}
{"name":"Complex.ball_one_subset_slitPlane","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"‚ä¢ HasSubset.Subset (Metric.ball 1 1) Complex.slitPlane","decl":"/-- The slit plane includes the open unit ball of radius `1` around `1`. -/\nlemma ball_one_subset_slitPlane : Metric.ball 1 1 ‚äÜ slitPlane := fun z hz ‚Ü¶ .inl <|\n  have : -1 < z.re - 1 := neg_lt_of_abs_lt <| (abs_re_le_abs _).trans_lt hz\n  by linarith\n\n"}
{"name":"Complex.mem_slitPlane_of_norm_lt_one","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"z : Complex\nhz : LT.lt (Norm.norm z) 1\n‚ä¢ Membership.mem Complex.slitPlane (HAdd.hAdd 1 z)","decl":"/-- The slit plane includes the open unit ball of radius `1` around `1`. -/\nlemma mem_slitPlane_of_norm_lt_one {z : ‚ÑÇ} (hz : ‚Äñz‚Äñ < 1) : 1 + z ‚àà slitPlane :=\n  ball_one_subset_slitPlane <| by simpa\n\n"}
{"name":"IsCompact.reProdIm","module":"Mathlib.Analysis.Complex.Basic","initialProofState":"s t : Set Real\nhs : IsCompact s\nht : IsCompact t\n‚ä¢ IsCompact (Complex.reProdIm s t)","decl":"lemma _root_.IsCompact.reProdIm {s t : Set ‚Ñù} (hs : IsCompact s) (ht : IsCompact t) :\n    IsCompact (s √ó‚ÑÇ t) :=\n  equivRealProdCLM.toHomeomorph.isCompact_preimage.2 (hs.prod ht)\n\n"}
