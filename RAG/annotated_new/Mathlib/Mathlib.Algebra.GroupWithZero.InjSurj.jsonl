{"name":"Function.Injective.noZeroDivisors","module":"Mathlib.Algebra.GroupWithZero.InjSurj","initialProofState":"M₀ : Type u_1\nM₀' : Type u_3\ninst✝⁴ : Mul M₀\ninst✝³ : Zero M₀\ninst✝² : Mul M₀'\ninst✝¹ : Zero M₀'\nf : M₀ → M₀'\nhf : Function.Injective f\nzero : Eq (f 0) 0\nmul : ∀ (x y : M₀), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ninst✝ : NoZeroDivisors M₀'\n⊢ NoZeroDivisors M₀","decl":"/-- Pull back a `NoZeroDivisors` instance along an injective function. -/\nprotected theorem Function.Injective.noZeroDivisors [NoZeroDivisors M₀'] : NoZeroDivisors M₀ where\n  eq_zero_or_eq_zero_of_mul_eq_zero {a b} H :=\n    have : f a * f b = 0 := by rw [← mul, H, zero]\n    (eq_zero_or_eq_zero_of_mul_eq_zero this).imp\n      (fun H ↦ hf <| by rwa [zero]) fun H ↦ hf <| by rwa [zero]\n\n"}
{"name":"Function.Injective.isLeftCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.InjSurj","initialProofState":"M₀ : Type u_1\nM₀' : Type u_3\ninst✝⁴ : Mul M₀\ninst✝³ : Zero M₀\ninst✝² : Mul M₀'\ninst✝¹ : Zero M₀'\nf : M₀ → M₀'\nhf : Function.Injective f\nzero : Eq (f 0) 0\nmul : ∀ (x y : M₀), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ninst✝ : IsLeftCancelMulZero M₀'\n⊢ IsLeftCancelMulZero M₀","decl":"protected theorem Function.Injective.isLeftCancelMulZero\n    [IsLeftCancelMulZero M₀'] : IsLeftCancelMulZero M₀ where\n  mul_left_cancel_of_ne_zero Hne He := by\n    have := congr_arg f He\n    rw [mul, mul] at this\n    exact hf (mul_left_cancel₀ (fun Hfa => Hne <| hf <| by rw [Hfa, zero]) this)\n\n"}
{"name":"Function.Injective.isRightCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.InjSurj","initialProofState":"M₀ : Type u_1\nM₀' : Type u_3\ninst✝⁴ : Mul M₀\ninst✝³ : Zero M₀\ninst✝² : Mul M₀'\ninst✝¹ : Zero M₀'\nf : M₀ → M₀'\nhf : Function.Injective f\nzero : Eq (f 0) 0\nmul : ∀ (x y : M₀), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ninst✝ : IsRightCancelMulZero M₀'\n⊢ IsRightCancelMulZero M₀","decl":"protected theorem Function.Injective.isRightCancelMulZero\n    [IsRightCancelMulZero M₀'] : IsRightCancelMulZero M₀ where\n  mul_right_cancel_of_ne_zero Hne He := by\n    have := congr_arg f He\n    rw [mul, mul] at this\n    exact hf (mul_right_cancel₀ (fun Hfa => Hne <| hf <| by rw [Hfa, zero]) this)\n\n"}
{"name":"Function.Injective.isCancelMulZero","module":"Mathlib.Algebra.GroupWithZero.InjSurj","initialProofState":"M₀ : Type u_1\nM₀' : Type u_3\ninst✝⁴ : Mul M₀\ninst✝³ : Zero M₀\ninst✝² : Mul M₀'\ninst✝¹ : Zero M₀'\nf : M₀ → M₀'\nhf : Function.Injective f\nzero : Eq (f 0) 0\nmul : ∀ (x y : M₀), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))\ninst✝ : IsCancelMulZero M₀'\n⊢ IsCancelMulZero M₀","decl":"protected theorem Function.Injective.isCancelMulZero\n    [IsCancelMulZero M₀'] : IsCancelMulZero M₀ where\n  __ := hf.isLeftCancelMulZero f zero mul\n  __ := hf.isRightCancelMulZero f zero mul\n\n"}
