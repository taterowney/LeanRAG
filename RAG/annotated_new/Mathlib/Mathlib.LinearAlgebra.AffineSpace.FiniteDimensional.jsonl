{"name":"finiteDimensional_vectorSpan_of_finite","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : s.Finite\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)","decl":"/-- The `vectorSpan` of a finite set is finite-dimensional. -/\ntheorem finiteDimensional_vectorSpan_of_finite {s : Set P} (h : Set.Finite s) :\n    FiniteDimensional k (vectorSpan k s) :=\n  .span_of_finite k <| h.vsub h\n\n"}
{"name":"finiteDimensional_vectorSpan_range","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Finite ι\np : ι → P\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)","decl":"/-- The `vectorSpan` of a family indexed by a `Fintype` is\nfinite-dimensional. -/\ninstance finiteDimensional_vectorSpan_range [Finite ι] (p : ι → P) :\n    FiniteDimensional k (vectorSpan k (Set.range p)) :=\n  finiteDimensional_vectorSpan_of_finite k (Set.finite_range _)\n\n"}
{"name":"finiteDimensional_vectorSpan_image_of_finite","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Finite ι\np : ι → P\ns : Set ι\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k (Set.image p s)) x)","decl":"/-- The `vectorSpan` of a subset of a family indexed by a `Fintype`\nis finite-dimensional. -/\ninstance finiteDimensional_vectorSpan_image_of_finite [Finite ι] (p : ι → P) (s : Set ι) :\n    FiniteDimensional k (vectorSpan k (p '' s)) :=\n  finiteDimensional_vectorSpan_of_finite k (Set.toFinite _)\n\n"}
{"name":"finiteDimensional_direction_affineSpan_of_finite","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : s.Finite\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (affineSpan k s).direction x)","decl":"/-- The direction of the affine span of a finite set is\nfinite-dimensional. -/\ntheorem finiteDimensional_direction_affineSpan_of_finite {s : Set P} (h : Set.Finite s) :\n    FiniteDimensional k (affineSpan k s).direction :=\n  (direction_affineSpan k s).symm ▸ finiteDimensional_vectorSpan_of_finite k h\n\n"}
{"name":"finiteDimensional_direction_affineSpan_range","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Finite ι\np : ι → P\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (affineSpan k (Set.range p)).direction x)","decl":"/-- The direction of the affine span of a family indexed by a\n`Fintype` is finite-dimensional. -/\ninstance finiteDimensional_direction_affineSpan_range [Finite ι] (p : ι → P) :\n    FiniteDimensional k (affineSpan k (Set.range p)).direction :=\n  finiteDimensional_direction_affineSpan_of_finite k (Set.finite_range _)\n\n"}
{"name":"finiteDimensional_direction_affineSpan_image_of_finite","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Finite ι\np : ι → P\ns : Set ι\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (affineSpan k (Set.image p s)).direction x)","decl":"/-- The direction of the affine span of a subset of a family indexed\nby a `Fintype` is finite-dimensional. -/\ninstance finiteDimensional_direction_affineSpan_image_of_finite [Finite ι] (p : ι → P) (s : Set ι) :\n    FiniteDimensional k (affineSpan k (p '' s)).direction :=\n  finiteDimensional_direction_affineSpan_of_finite k (Set.toFinite _)\n\n"}
{"name":"finite_of_fin_dim_affineIndependent","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : FiniteDimensional k V\np : ι → P\nhi : AffineIndependent k p\n⊢ Finite ι","decl":"/-- An affine-independent family of points in a finite-dimensional affine space is finite. -/\ntheorem finite_of_fin_dim_affineIndependent [FiniteDimensional k V] {p : ι → P}\n    (hi : AffineIndependent k p) : Finite ι := by\n  nontriviality ι; inhabit ι\n  rw [affineIndependent_iff_linearIndependent_vsub k p default] at hi\n  letI : IsNoetherian k V := IsNoetherian.iff_fg.2 inferInstance\n  exact\n    (Set.finite_singleton default).finite_of_compl (Set.finite_coe_iff.1 hi.finite_of_isNoetherian)\n\n"}
{"name":"finite_set_of_fin_dim_affineIndependent","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : FiniteDimensional k V\ns : Set ι\nf : ↑s → P\nhi : AffineIndependent k f\n⊢ s.Finite","decl":"/-- An affine-independent subset of a finite-dimensional affine space is finite. -/\ntheorem finite_set_of_fin_dim_affineIndependent [FiniteDimensional k V] {s : Set ι} {f : s → P}\n    (hi : AffineIndependent k f) : s.Finite :=\n  @Set.toFinite _ s (finite_of_fin_dim_affineIndependent k hi)\n\n"}
{"name":"AffineIndependent.finrank_vectorSpan_image_finset","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : DecidableEq P\np : ι → P\nhi : AffineIndependent k p\ns : Finset ι\nn : Nat\nhc : Eq s.card (HAdd.hAdd n 1)\n⊢ Eq (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k ↑(Finset.image p s)) x)) n","decl":"/-- The `vectorSpan` of a finite subset of an affinely independent\nfamily has dimension one less than its cardinality. -/\ntheorem AffineIndependent.finrank_vectorSpan_image_finset [DecidableEq P]\n    {p : ι → P} (hi : AffineIndependent k p) {s : Finset ι} {n : ℕ} (hc : #s = n + 1) :\n    finrank k (vectorSpan k (s.image p : Set P)) = n := by\n  classical\n  have hi' := hi.range.mono (Set.image_subset_range p ↑s)\n  have hc' : #(s.image p) = n + 1 := by rwa [s.card_image_of_injective hi.injective]\n  have hn : (s.image p).Nonempty := by simp [hc', ← Finset.card_pos]\n  rcases hn with ⟨p₁, hp₁⟩\n  have hp₁' : p₁ ∈ p '' s := by simpa using hp₁\n  rw [affineIndependent_set_iff_linearIndependent_vsub k hp₁', ← Finset.coe_singleton,\n    ← Finset.coe_image, ← Finset.coe_sdiff, Finset.sdiff_singleton_eq_erase, ← Finset.coe_image]\n    at hi'\n  have hc : #(((s.image p).erase p₁).image (· -ᵥ p₁)) = n := by\n    rw [Finset.card_image_of_injective _ (vsub_left_injective _), Finset.card_erase_of_mem hp₁]\n    exact Nat.pred_eq_of_eq_succ hc'\n  rwa [vectorSpan_eq_span_vsub_finset_right_ne k hp₁, finrank_span_finset_eq_card, hc]\n\n"}
{"name":"AffineIndependent.finrank_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nhi : AffineIndependent k p\nn : Nat\nhc : Eq (Fintype.card ι) (HAdd.hAdd n 1)\n⊢ Eq (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) n","decl":"/-- The `vectorSpan` of a finite affinely independent family has\ndimension one less than its cardinality. -/\ntheorem AffineIndependent.finrank_vectorSpan [Fintype ι] {p : ι → P} (hi : AffineIndependent k p)\n    {n : ℕ} (hc : Fintype.card ι = n + 1) : finrank k (vectorSpan k (Set.range p)) = n := by\n  classical\n  rw [← Finset.card_univ] at hc\n  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]\n  exact hi.finrank_vectorSpan_image_finset hc\n\n"}
{"name":"AffineIndependent.finrank_vectorSpan_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\np : ι → P\nhi : AffineIndependent k p\n⊢ Eq (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) 1) (Fintype.card ι)","decl":"/-- The `vectorSpan` of a finite affinely independent family has dimension one less than its\ncardinality. -/\nlemma AffineIndependent.finrank_vectorSpan_add_one [Fintype ι] [Nonempty ι] {p : ι → P}\n    (hi : AffineIndependent k p) : finrank k (vectorSpan k (Set.range p)) + 1 = Fintype.card ι := by\n  rw [hi.finrank_vectorSpan (tsub_add_cancel_of_le _).symm, tsub_add_cancel_of_le] <;>\n    exact Fintype.card_pos\n\n"}
{"name":"AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : FiniteDimensional k V\ninst✝ : Fintype ι\np : ι → P\nhi : AffineIndependent k p\nhc : Eq (Fintype.card ι) (HAdd.hAdd (Module.finrank k V) 1)\n⊢ Eq (vectorSpan k (Set.range p)) Top.top","decl":"/-- The `vectorSpan` of a finite affinely independent family whose\ncardinality is one more than that of the finite-dimensional space is\n`⊤`. -/\ntheorem AffineIndependent.vectorSpan_eq_top_of_card_eq_finrank_add_one [FiniteDimensional k V]\n    [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) (hc : Fintype.card ι = finrank k V + 1) :\n    vectorSpan k (Set.range p) = ⊤ :=\n  Submodule.eq_top_of_finrank_eq <| hi.finrank_vectorSpan hc\n\n"}
{"name":"finrank_vectorSpan_image_finset_le","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : DecidableEq P\np : ι → P\ns : Finset ι\nn : Nat\nhc : Eq s.card (HAdd.hAdd n 1)\n⊢ LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k ↑(Finset.image p s)) x)) n","decl":"/-- The `vectorSpan` of `n + 1` points in an indexed family has\ndimension at most `n`. -/\ntheorem finrank_vectorSpan_image_finset_le [DecidableEq P] (p : ι → P) (s : Finset ι) {n : ℕ}\n    (hc : #s = n + 1) : finrank k (vectorSpan k (s.image p : Set P)) ≤ n := by\n  classical\n  have hn : (s.image p).Nonempty := by\n    rw [Finset.image_nonempty, ← Finset.card_pos, hc]\n    apply Nat.succ_pos\n  rcases hn with ⟨p₁, hp₁⟩\n  rw [vectorSpan_eq_span_vsub_finset_right_ne k hp₁]\n  refine le_trans (finrank_span_finset_le_card (((s.image p).erase p₁).image fun p => p -ᵥ p₁)) ?_\n  rw [Finset.card_image_of_injective _ (vsub_left_injective p₁), Finset.card_erase_of_mem hp₁,\n    tsub_le_iff_right, ← hc]\n  apply Finset.card_image_le\n\n"}
{"name":"finrank_vectorSpan_range_le","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nn : Nat\nhc : Eq (Fintype.card ι) (HAdd.hAdd n 1)\n⊢ LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) n","decl":"/-- The `vectorSpan` of an indexed family of `n + 1` points has\ndimension at most `n`. -/\ntheorem finrank_vectorSpan_range_le [Fintype ι] (p : ι → P) {n : ℕ} (hc : Fintype.card ι = n + 1) :\n    finrank k (vectorSpan k (Set.range p)) ≤ n := by\n  classical\n  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image]\n  rw [← Finset.card_univ] at hc\n  exact finrank_vectorSpan_image_finset_le _ _ _ hc\n\n"}
{"name":"finrank_vectorSpan_range_add_one_le","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : Fintype ι\ninst✝ : Nonempty ι\np : ι → P\n⊢ LE.le (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) 1) (Fintype.card ι)","decl":"/-- The `vectorSpan` of an indexed family of `n + 1` points has dimension at most `n`. -/\nlemma finrank_vectorSpan_range_add_one_le [Fintype ι] [Nonempty ι] (p : ι → P) :\n    finrank k (vectorSpan k (Set.range p)) + 1 ≤ Fintype.card ι :=\n  (le_tsub_iff_right <| Nat.succ_le_iff.2 Fintype.card_pos).1 <| finrank_vectorSpan_range_le _ _\n    (tsub_add_cancel_of_le <| Nat.succ_le_iff.2 Fintype.card_pos).symm\n\n"}
{"name":"affineIndependent_iff_finrank_vectorSpan_eq","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nn : Nat\nhc : Eq (Fintype.card ι) (HAdd.hAdd n 1)\n⊢ Iff (AffineIndependent k p) (Eq (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) n)","decl":"/-- `n + 1` points are affinely independent if and only if their\n`vectorSpan` has dimension `n`. -/\ntheorem affineIndependent_iff_finrank_vectorSpan_eq [Fintype ι] (p : ι → P) {n : ℕ}\n    (hc : Fintype.card ι = n + 1) :\n    AffineIndependent k p ↔ finrank k (vectorSpan k (Set.range p)) = n := by\n  classical\n  have hn : Nonempty ι := by simp [← Fintype.card_pos_iff, hc]\n  cases' hn with i₁\n  rw [affineIndependent_iff_linearIndependent_vsub _ _ i₁,\n    linearIndependent_iff_card_eq_finrank_span, eq_comm,\n    vectorSpan_range_eq_span_range_vsub_right_ne k p i₁, Set.finrank]\n  rw [← Finset.card_univ] at hc\n  rw [Fintype.subtype_card]\n  simp [Finset.filter_ne', Finset.card_erase_of_mem, hc]\n\n"}
{"name":"affineIndependent_iff_le_finrank_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nn : Nat\nhc : Eq (Fintype.card ι) (HAdd.hAdd n 1)\n⊢ Iff (AffineIndependent k p) (LE.le n (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)))","decl":"/-- `n + 1` points are affinely independent if and only if their\n`vectorSpan` has dimension at least `n`. -/\ntheorem affineIndependent_iff_le_finrank_vectorSpan [Fintype ι] (p : ι → P) {n : ℕ}\n    (hc : Fintype.card ι = n + 1) :\n    AffineIndependent k p ↔ n ≤ finrank k (vectorSpan k (Set.range p)) := by\n  rw [affineIndependent_iff_finrank_vectorSpan_eq k p hc]\n  constructor\n  · rintro rfl\n    rfl\n  · exact fun hle => le_antisymm (finrank_vectorSpan_range_le k p hc) hle\n\n"}
{"name":"affineIndependent_iff_not_finrank_vectorSpan_le","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nn : Nat\nhc : Eq (Fintype.card ι) (HAdd.hAdd n 2)\n⊢ Iff (AffineIndependent k p) (Not (LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) n))","decl":"/-- `n + 2` points are affinely independent if and only if their\n`vectorSpan` does not have dimension at most `n`. -/\ntheorem affineIndependent_iff_not_finrank_vectorSpan_le [Fintype ι] (p : ι → P) {n : ℕ}\n    (hc : Fintype.card ι = n + 2) :\n    AffineIndependent k p ↔ ¬finrank k (vectorSpan k (Set.range p)) ≤ n := by\n  rw [affineIndependent_iff_le_finrank_vectorSpan k p hc, ← Nat.lt_iff_add_one_le, lt_iff_not_ge]\n\n"}
{"name":"finrank_vectorSpan_le_iff_not_affineIndependent","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nn : Nat\nhc : Eq (Fintype.card ι) (HAdd.hAdd n 2)\n⊢ Iff (LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) n) (Not (AffineIndependent k p))","decl":"/-- `n + 2` points have a `vectorSpan` with dimension at most `n` if\nand only if they are not affinely independent. -/\ntheorem finrank_vectorSpan_le_iff_not_affineIndependent [Fintype ι] (p : ι → P) {n : ℕ}\n    (hc : Fintype.card ι = n + 2) :\n    finrank k (vectorSpan k (Set.range p)) ≤ n ↔ ¬AffineIndependent k p :=\n  (not_iff_comm.1 (affineIndependent_iff_not_finrank_vectorSpan_le k p hc).symm).symm\n\n"}
{"name":"AffineIndependent.card_le_finrank_succ","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ninst✝ : Fintype ι\np : ι → P\nhp : AffineIndependent k p\n⊢ LE.le (Fintype.card ι) (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Set.range p)) x)) 1)","decl":"lemma AffineIndependent.card_le_finrank_succ [Fintype ι] {p : ι → P} (hp : AffineIndependent k p) :\n    Fintype.card ι ≤ Module.finrank k (vectorSpan k (Set.range p)) + 1 := by\n  cases isEmpty_or_nonempty ι\n  · simp [Fintype.card_eq_zero]\n  rw [← tsub_le_iff_right]\n  exact (affineIndependent_iff_le_finrank_vectorSpan _ _\n    (tsub_add_cancel_of_le <| Nat.one_le_iff_ne_zero.2 Fintype.card_ne_zero).symm).1 hp\n\n"}
{"name":"AffineIndependent.card_le_card_of_subset_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : DivisionRing k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns t : Finset V\nhs : AffineIndependent k Subtype.val\nhst : HasSubset.Subset ↑s ↑(affineSpan k ↑t)\n⊢ LE.le s.card t.card","decl":"open Finset in\n/-- If an affine independent finset is contained in the affine span of another finset, then its\ncardinality is at most the cardinality of that finset. -/\nlemma AffineIndependent.card_le_card_of_subset_affineSpan {s t : Finset V}\n    (hs : AffineIndependent k ((↑) : s → V)) (hst : (s : Set V) ⊆ affineSpan k (t : Set V)) :\n    #s ≤ #t := by\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  · simp\n  obtain rfl | ht' := t.eq_empty_or_nonempty\n  · simpa [Set.subset_empty_iff] using hst\n  have := hs'.to_subtype\n  have := ht'.to_set.to_subtype\n  have direction_le := AffineSubspace.direction_le (affineSpan_mono k hst)\n  rw [AffineSubspace.affineSpan_coe, direction_affineSpan, direction_affineSpan,\n    ← @Subtype.range_coe _ (s : Set V), ← @Subtype.range_coe _ (t : Set V)] at direction_le\n  have finrank_le := add_le_add_right (Submodule.finrank_mono direction_le) 1\n  -- We use `erw` to elide the difference between `↥s` and `↥(s : Set V)}`\n  erw [hs.finrank_vectorSpan_add_one] at finrank_le\n  simpa using finrank_le.trans <| finrank_vectorSpan_range_add_one_le _ _\n\n"}
{"name":"AffineIndependent.card_lt_card_of_affineSpan_lt_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝² : DivisionRing k\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ns t : Finset V\nhs : AffineIndependent k Subtype.val\nhst : LT.lt (affineSpan k ↑s) (affineSpan k ↑t)\n⊢ LT.lt s.card t.card","decl":"open Finset in\n/-- If the affine span of an affine independent finset is strictly contained in the affine span of\nanother finset, then its cardinality is strictly less than the cardinality of that finset. -/\nlemma AffineIndependent.card_lt_card_of_affineSpan_lt_affineSpan {s t : Finset V}\n    (hs : AffineIndependent k ((↑) : s → V))\n    (hst : affineSpan k (s : Set V) < affineSpan k (t : Set V)) : #s < #t := by\n  obtain rfl | hs' := s.eq_empty_or_nonempty\n  · simpa [card_pos] using hst\n  obtain rfl | ht' := t.eq_empty_or_nonempty\n  · simp [Set.subset_empty_iff] at hst\n  have := hs'.to_subtype\n  have := ht'.to_set.to_subtype\n  have dir_lt := AffineSubspace.direction_lt_of_nonempty (k := k) hst <| hs'.to_set.affineSpan k\n  rw [direction_affineSpan, direction_affineSpan,\n    ← @Subtype.range_coe _ (s : Set V), ← @Subtype.range_coe _ (t : Set V)] at dir_lt\n  have finrank_lt := add_lt_add_right (Submodule.finrank_lt_finrank_of_lt dir_lt) 1\n  -- We use `erw` to elide the difference between `↥s` and `↥(s : Set V)}`\n  erw [hs.finrank_vectorSpan_add_one] at finrank_lt\n  simpa using finrank_lt.trans_le <| finrank_vectorSpan_range_add_one_le _ _\n\n"}
{"name":"AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : DecidableEq P\np : ι → P\nhi : AffineIndependent k p\ns : Finset ι\nsm : Submodule k V\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem sm x)\nhle : LE.le (vectorSpan k ↑(Finset.image p s)) sm\nhc : Eq s.card (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem sm x)) 1)\n⊢ Eq (vectorSpan k ↑(Finset.image p s)) sm","decl":"/-- If the `vectorSpan` of a finite subset of an affinely independent\nfamily lies in a submodule with dimension one less than its\ncardinality, it equals that submodule. -/\ntheorem AffineIndependent.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one\n    [DecidableEq P] {p : ι → P}\n    (hi : AffineIndependent k p) {s : Finset ι} {sm : Submodule k V} [FiniteDimensional k sm]\n    (hle : vectorSpan k (s.image p : Set P) ≤ sm) (hc : #s = finrank k sm + 1) :\n    vectorSpan k (s.image p : Set P) = sm :=\n  Submodule.eq_of_le_of_finrank_eq hle <| hi.finrank_vectorSpan_image_finset hc\n\n"}
{"name":"AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : Fintype ι\np : ι → P\nhi : AffineIndependent k p\nsm : Submodule k V\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem sm x)\nhle : LE.le (vectorSpan k (Set.range p)) sm\nhc : Eq (Fintype.card ι) (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem sm x)) 1)\n⊢ Eq (vectorSpan k (Set.range p)) sm","decl":"/-- If the `vectorSpan` of a finite affinely independent\nfamily lies in a submodule with dimension one less than its\ncardinality, it equals that submodule. -/\ntheorem AffineIndependent.vectorSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype ι] {p : ι → P}\n    (hi : AffineIndependent k p) {sm : Submodule k V} [FiniteDimensional k sm]\n    (hle : vectorSpan k (Set.range p) ≤ sm) (hc : Fintype.card ι = finrank k sm + 1) :\n    vectorSpan k (Set.range p) = sm :=\n  Submodule.eq_of_le_of_finrank_eq hle <| hi.finrank_vectorSpan hc\n\n"}
{"name":"AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : DecidableEq P\np : ι → P\nhi : AffineIndependent k p\ns : Finset ι\nsp : AffineSubspace k P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem sp.direction x)\nhle : LE.le (affineSpan k ↑(Finset.image p s)) sp\nhc : Eq s.card (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem sp.direction x)) 1)\n⊢ Eq (affineSpan k ↑(Finset.image p s)) sp","decl":"/-- If the `affineSpan` of a finite subset of an affinely independent\nfamily lies in an affine subspace whose direction has dimension one\nless than its cardinality, it equals that subspace. -/\ntheorem AffineIndependent.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one\n    [DecidableEq P] {p : ι → P}\n    (hi : AffineIndependent k p) {s : Finset ι} {sp : AffineSubspace k P}\n    [FiniteDimensional k sp.direction] (hle : affineSpan k (s.image p : Set P) ≤ sp)\n    (hc : #s = finrank k sp.direction + 1) : affineSpan k (s.image p : Set P) = sp := by\n  have hn : s.Nonempty := by\n    rw [← Finset.card_pos, hc]\n    apply Nat.succ_pos\n  refine eq_of_direction_eq_of_nonempty_of_le ?_ ((hn.image p).to_set.affineSpan k) hle\n  have hd := direction_le hle\n  rw [direction_affineSpan] at hd ⊢\n  exact hi.vectorSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one hd hc\n\n"}
{"name":"AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : Fintype ι\np : ι → P\nhi : AffineIndependent k p\nsp : AffineSubspace k P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem sp.direction x)\nhle : LE.le (affineSpan k (Set.range p)) sp\nhc : Eq (Fintype.card ι) (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem sp.direction x)) 1)\n⊢ Eq (affineSpan k (Set.range p)) sp","decl":"/-- If the `affineSpan` of a finite affinely independent family lies\nin an affine subspace whose direction has dimension one less than its\ncardinality, it equals that subspace. -/\ntheorem AffineIndependent.affineSpan_eq_of_le_of_card_eq_finrank_add_one [Fintype ι] {p : ι → P}\n    (hi : AffineIndependent k p) {sp : AffineSubspace k P} [FiniteDimensional k sp.direction]\n    (hle : affineSpan k (Set.range p) ≤ sp) (hc : Fintype.card ι = finrank k sp.direction + 1) :\n    affineSpan k (Set.range p) = sp := by\n  classical\n  rw [← Finset.card_univ] at hc\n  rw [← Set.image_univ, ← Finset.coe_univ, ← Finset.coe_image] at hle ⊢\n  exact hi.affineSpan_image_finset_eq_of_le_of_card_eq_finrank_add_one hle hc\n\n"}
{"name":"AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\nι : Type u_4\ninst✝⁵ : DivisionRing k\ninst✝⁴ : AddCommGroup V\ninst✝³ : Module k V\ninst✝² : AddTorsor V P\ninst✝¹ : FiniteDimensional k V\ninst✝ : Fintype ι\np : ι → P\nhi : AffineIndependent k p\n⊢ Iff (Eq (affineSpan k (Set.range p)) Top.top) (Eq (Fintype.card ι) (HAdd.hAdd (Module.finrank k V) 1))","decl":"/-- The `affineSpan` of a finite affinely independent family is `⊤` iff the\nfamily's cardinality is one more than that of the finite-dimensional space. -/\ntheorem AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one [FiniteDimensional k V]\n    [Fintype ι] {p : ι → P} (hi : AffineIndependent k p) :\n    affineSpan k (Set.range p) = ⊤ ↔ Fintype.card ι = finrank k V + 1 := by\n  constructor\n  · intro h_tot\n    let n := Fintype.card ι - 1\n    have hn : Fintype.card ι = n + 1 :=\n      (Nat.succ_pred_eq_of_pos (card_pos_of_affineSpan_eq_top k V P h_tot)).symm\n    rw [hn, ← finrank_top, ← (vectorSpan_eq_top_of_affineSpan_eq_top k V P) h_tot,\n      ← hi.finrank_vectorSpan hn]\n  · intro hc\n    rw [← finrank_top, ← direction_top k V P] at hc\n    exact hi.affineSpan_eq_of_le_of_card_eq_finrank_add_one le_top hc\n\n"}
{"name":"Affine.Simplex.span_eq_top","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : FiniteDimensional k V\nn : Nat\nT : Affine.Simplex k V n\nhrank : Eq (Module.finrank k V) n\n⊢ Eq (affineSpan k (Set.range T.points)) Top.top","decl":"theorem Affine.Simplex.span_eq_top [FiniteDimensional k V] {n : ℕ} (T : Affine.Simplex k V n)\n    (hrank : finrank k V = n) : affineSpan k (Set.range T.points) = ⊤ := by\n  rw [AffineIndependent.affineSpan_eq_top_iff_card_eq_finrank_add_one T.independent,\n    Fintype.card_fin, hrank]\n\n"}
{"name":"finiteDimensional_vectorSpan_insert","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem s.direction x)\np : P\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k (Insert.insert p ↑s)) x)","decl":"/-- The `vectorSpan` of adding a point to a finite-dimensional subspace is finite-dimensional. -/\ninstance finiteDimensional_vectorSpan_insert (s : AffineSubspace k P)\n    [FiniteDimensional k s.direction] (p : P) :\n    FiniteDimensional k (vectorSpan k (insert p (s : Set P))) := by\n  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]\n  rcases (s : Set P).eq_empty_or_nonempty with (hs | ⟨p₀, hp₀⟩)\n  · rw [coe_eq_bot_iff] at hs\n    rw [hs, bot_coe, span_empty, bot_coe, direction_affineSpan]\n    convert finiteDimensional_bot k V <;> simp\n  · rw [affineSpan_coe, direction_affineSpan_insert hp₀]\n    infer_instance\n\n"}
{"name":"finiteDimensional_direction_affineSpan_insert","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : AffineSubspace k P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem s.direction x)\np : P\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (affineSpan k (Insert.insert p ↑s)).direction x)","decl":"/-- The direction of the affine span of adding a point to a finite-dimensional subspace is\nfinite-dimensional. -/\ninstance finiteDimensional_direction_affineSpan_insert (s : AffineSubspace k P)\n    [FiniteDimensional k s.direction] (p : P) :\n    FiniteDimensional k (affineSpan k (insert p (s : Set P))).direction :=\n  (direction_affineSpan k (insert p (s : Set P))).symm ▸ finiteDimensional_vectorSpan_insert s p\n\n"}
{"name":"finiteDimensional_vectorSpan_insert_set","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : Set P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)\np : P\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k (Insert.insert p s)) x)","decl":"/-- The `vectorSpan` of adding a point to a set with a finite-dimensional `vectorSpan` is\nfinite-dimensional. -/\ninstance finiteDimensional_vectorSpan_insert_set (s : Set P) [FiniteDimensional k (vectorSpan k s)]\n    (p : P) : FiniteDimensional k (vectorSpan k (insert p s)) := by\n  haveI : FiniteDimensional k (affineSpan k s).direction :=\n    (direction_affineSpan k s).symm ▸ inferInstance\n  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan, direction_affineSpan]\n  exact finiteDimensional_vectorSpan_insert (affineSpan k s) p\n\n"}
{"name":"collinear_iff_rank_le_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (Collinear k s) (LE.le (Module.rank k (Subtype fun x => Membership.mem (vectorSpan k s) x)) 1)","decl":"/-- The definition of `Collinear`. -/\ntheorem collinear_iff_rank_le_one (s : Set P) :\n    Collinear k s ↔ Module.rank k (vectorSpan k s) ≤ 1 := Iff.rfl\n\n"}
{"name":"collinear_iff_finrank_le_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : Set P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)\n⊢ Iff (Collinear k s) (LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k s) x)) 1)","decl":"/-- A set of points, whose `vectorSpan` is finite-dimensional, is\ncollinear if and only if their `vectorSpan` has dimension at most\n`1`. -/\ntheorem collinear_iff_finrank_le_one {s : Set P} [FiniteDimensional k (vectorSpan k s)] :\n    Collinear k s ↔ finrank k (vectorSpan k s) ≤ 1 := by\n  have h := collinear_iff_rank_le_one k s\n  rw [← finrank_eq_rank] at h\n  exact mod_cast h\n\n"}
{"name":"Collinear.finrank_le_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : Set P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)\na✝ : Collinear k s\n⊢ LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k s) x)) 1","decl":"alias ⟨Collinear.finrank_le_one, _⟩ := collinear_iff_finrank_le_one\n\n"}
{"name":"Collinear.subset","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : Set P\nhs : HasSubset.Subset s₁ s₂\nh : Collinear k s₂\n⊢ Collinear k s₁","decl":"/-- A subset of a collinear set is collinear. -/\ntheorem Collinear.subset {s₁ s₂ : Set P} (hs : s₁ ⊆ s₂) (h : Collinear k s₂) : Collinear k s₁ :=\n  (Submodule.rank_mono (vectorSpan_mono k hs)).trans h\n\n"}
{"name":"Collinear.finiteDimensional_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)","decl":"/-- The `vectorSpan` of collinear points is finite-dimensional. -/\ntheorem Collinear.finiteDimensional_vectorSpan {s : Set P} (h : Collinear k s) :\n    FiniteDimensional k (vectorSpan k s) :=\n  IsNoetherian.iff_fg.1\n    (IsNoetherian.iff_rank_lt_aleph0.2 (lt_of_le_of_lt h Cardinal.one_lt_aleph0))\n\n"}
{"name":"Collinear.finiteDimensional_direction_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (affineSpan k s).direction x)","decl":"/-- The direction of the affine span of collinear points is finite-dimensional. -/\ntheorem Collinear.finiteDimensional_direction_affineSpan {s : Set P} (h : Collinear k s) :\n    FiniteDimensional k (affineSpan k s).direction :=\n  (direction_affineSpan k s).symm ▸ h.finiteDimensional_vectorSpan\n\n"}
{"name":"collinear_empty","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\n⊢ Collinear k EmptyCollection.emptyCollection","decl":"/-- The empty set is collinear. -/\ntheorem collinear_empty : Collinear k (∅ : Set P) := by\n  rw [collinear_iff_rank_le_one, vectorSpan_empty]\n  simp\n\n"}
{"name":"collinear_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\n⊢ Collinear k (Singleton.singleton p)","decl":"/-- A single point is collinear. -/\ntheorem collinear_singleton (p : P) : Collinear k ({p} : Set P) := by\n  rw [collinear_iff_rank_le_one, vectorSpan_singleton]\n  simp\n\n"}
{"name":"collinear_iff_of_mem","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np₀ : P\nh : Membership.mem s p₀\n⊢ Iff (Collinear k s) (Exists fun v => ∀ (p : P), Membership.mem s p → Exists fun r => Eq p (HVAdd.hVAdd (HSMul.hSMul r v) p₀))","decl":"/-- Given a point `p₀` in a set of points, that set is collinear if and\nonly if the points can all be expressed as multiples of the same\nvector, added to `p₀`. -/\ntheorem collinear_iff_of_mem {s : Set P} {p₀ : P} (h : p₀ ∈ s) :\n    Collinear k s ↔ ∃ v : V, ∀ p ∈ s, ∃ r : k, p = r • v +ᵥ p₀ := by\n  simp_rw [collinear_iff_rank_le_one, rank_submodule_le_one_iff', Submodule.le_span_singleton_iff]\n  constructor\n  · rintro ⟨v₀, hv⟩\n    use v₀\n    intro p hp\n    obtain ⟨r, hr⟩ := hv (p -ᵥ p₀) (vsub_mem_vectorSpan k hp h)\n    use r\n    rw [eq_vadd_iff_vsub_eq]\n    exact hr.symm\n  · rintro ⟨v, hp₀v⟩\n    use v\n    intro w hw\n    have hs : vectorSpan k s ≤ k ∙ v := by\n      rw [vectorSpan_eq_span_vsub_set_right k h, Submodule.span_le, Set.subset_def]\n      intro x hx\n      rw [SetLike.mem_coe, Submodule.mem_span_singleton]\n      rw [Set.mem_image] at hx\n      rcases hx with ⟨p, hp, rfl⟩\n      rcases hp₀v p hp with ⟨r, rfl⟩\n      use r\n      simp\n    have hw' := SetLike.le_def.1 hs hw\n    rwa [Submodule.mem_span_singleton] at hw'\n\n"}
{"name":"collinear_iff_exists_forall_eq_smul_vadd","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\n⊢ Iff (Collinear k s) (Exists fun p₀ => Exists fun v => ∀ (p : P), Membership.mem s p → Exists fun r => Eq p (HVAdd.hVAdd (HSMul.hSMul r v) p₀))","decl":"/-- A set of points is collinear if and only if they can all be\nexpressed as multiples of the same vector, added to the same base\npoint. -/\ntheorem collinear_iff_exists_forall_eq_smul_vadd (s : Set P) :\n    Collinear k s ↔ ∃ (p₀ : P) (v : V), ∀ p ∈ s, ∃ r : k, p = r • v +ᵥ p₀ := by\n  rcases Set.eq_empty_or_nonempty s with (rfl | ⟨⟨p₁, hp₁⟩⟩)\n  · simp [collinear_empty]\n  · rw [collinear_iff_of_mem hp₁]\n    constructor\n    · exact fun h => ⟨p₁, h⟩\n    · rintro ⟨p, v, hv⟩\n      use v\n      intro p₂ hp₂\n      rcases hv p₂ hp₂ with ⟨r, rfl⟩\n      rcases hv p₁ hp₁ with ⟨r₁, rfl⟩\n      use r - r₁\n      simp [vadd_vadd, ← add_smul]\n\n"}
{"name":"collinear_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Collinear k (Insert.insert p₁ (Singleton.singleton p₂))","decl":"/-- Two points are collinear. -/\ntheorem collinear_pair (p₁ p₂ : P) : Collinear k ({p₁, p₂} : Set P) := by\n  rw [collinear_iff_exists_forall_eq_smul_vadd]\n  use p₁, p₂ -ᵥ p₁\n  intro p hp\n  rw [Set.mem_insert_iff, Set.mem_singleton_iff] at hp\n  cases' hp with hp hp\n  · use 0\n    simp [hp]\n  · use 1\n    simp [hp]\n\n"}
{"name":"affineIndependent_iff_not_collinear","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : Fin 3 → P\n⊢ Iff (AffineIndependent k p) (Not (Collinear k (Set.range p)))","decl":"/-- Three points are affinely independent if and only if they are not\ncollinear. -/\ntheorem affineIndependent_iff_not_collinear {p : Fin 3 → P} :\n    AffineIndependent k p ↔ ¬Collinear k (Set.range p) := by\n  rw [collinear_iff_finrank_le_one,\n    affineIndependent_iff_not_finrank_vectorSpan_le k p (Fintype.card_fin 3)]\n\n"}
{"name":"collinear_iff_not_affineIndependent","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : Fin 3 → P\n⊢ Iff (Collinear k (Set.range p)) (Not (AffineIndependent k p))","decl":"/-- Three points are collinear if and only if they are not affinely\nindependent. -/\ntheorem collinear_iff_not_affineIndependent {p : Fin 3 → P} :\n    Collinear k (Set.range p) ↔ ¬AffineIndependent k p := by\n  rw [collinear_iff_finrank_le_one,\n    finrank_vectorSpan_le_iff_not_affineIndependent k p (Fintype.card_fin 3)]\n\n"}
{"name":"affineIndependent_iff_not_collinear_set","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (AffineIndependent k (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))) (Not (Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))))","decl":"/-- Three points are affinely independent if and only if they are not collinear. -/\ntheorem affineIndependent_iff_not_collinear_set {p₁ p₂ p₃ : P} :\n    AffineIndependent k ![p₁, p₂, p₃] ↔ ¬Collinear k ({p₁, p₂, p₃} : Set P) := by\n  rw [affineIndependent_iff_not_collinear]\n  simp_rw [Matrix.range_cons, Matrix.range_empty, Set.singleton_union, insert_emptyc_eq]\n\n"}
{"name":"collinear_iff_not_affineIndependent_set","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))) (Not (AffineIndependent k (Matrix.vecCons p₁ (Matrix.vecCons p₂ (Matrix.vecCons p₃ Matrix.vecEmpty)))))","decl":"/-- Three points are collinear if and only if they are not affinely independent. -/\ntheorem collinear_iff_not_affineIndependent_set {p₁ p₂ p₃ : P} :\n    Collinear k ({p₁, p₂, p₃} : Set P) ↔ ¬AffineIndependent k ![p₁, p₂, p₃] :=\n  affineIndependent_iff_not_collinear_set.not_left.symm\n\n"}
{"name":"affineIndependent_iff_not_collinear_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : Fin 3 → P\ni₁ i₂ i₃ : Fin 3\nh₁₂ : Ne i₁ i₂\nh₁₃ : Ne i₁ i₃\nh₂₃ : Ne i₂ i₃\n⊢ Iff (AffineIndependent k p) (Not (Collinear k (Insert.insert (p i₁) (Insert.insert (p i₂) (Singleton.singleton (p i₃))))))","decl":"/-- Three points are affinely independent if and only if they are not collinear. -/\ntheorem affineIndependent_iff_not_collinear_of_ne {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂)\n    (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) :\n    AffineIndependent k p ↔ ¬Collinear k ({p i₁, p i₂, p i₃} : Set P) := by\n  have hu : (Finset.univ : Finset (Fin 3)) = {i₁, i₂, i₃} := by\n    -- Porting note: Originally `by decide!`\n    revert i₁ i₂ i₃; decide\n  rw [affineIndependent_iff_not_collinear, ← Set.image_univ, ← Finset.coe_univ, hu,\n    Finset.coe_insert, Finset.coe_insert, Finset.coe_singleton, Set.image_insert_eq, Set.image_pair]\n\n"}
{"name":"collinear_iff_not_affineIndependent_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : Fin 3 → P\ni₁ i₂ i₃ : Fin 3\nh₁₂ : Ne i₁ i₂\nh₁₃ : Ne i₁ i₃\nh₂₃ : Ne i₂ i₃\n⊢ Iff (Collinear k (Insert.insert (p i₁) (Insert.insert (p i₂) (Singleton.singleton (p i₃))))) (Not (AffineIndependent k p))","decl":"/-- Three points are collinear if and only if they are not affinely independent. -/\ntheorem collinear_iff_not_affineIndependent_of_ne {p : Fin 3 → P} {i₁ i₂ i₃ : Fin 3} (h₁₂ : i₁ ≠ i₂)\n    (h₁₃ : i₁ ≠ i₃) (h₂₃ : i₂ ≠ i₃) :\n    Collinear k ({p i₁, p i₂, p i₃} : Set P) ↔ ¬AffineIndependent k p :=\n  (affineIndependent_iff_not_collinear_of_ne h₁₂ h₁₃ h₂₃).not_left.symm\n\n"}
{"name":"ne₁₂_of_not_collinear","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ Ne p₁ p₂","decl":"/-- If three points are not collinear, the first and second are different. -/\ntheorem ne₁₂_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) :\n    p₁ ≠ p₂ := by\n  rintro rfl\n  simp [collinear_pair] at h\n\n"}
{"name":"ne₁₃_of_not_collinear","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ Ne p₁ p₃","decl":"/-- If three points are not collinear, the first and third are different. -/\ntheorem ne₁₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) :\n    p₁ ≠ p₃ := by\n  rintro rfl\n  simp [collinear_pair] at h\n\n"}
{"name":"ne₂₃_of_not_collinear","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ Ne p₂ p₃","decl":"/-- If three points are not collinear, the second and third are different. -/\ntheorem ne₂₃_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear k ({p₁, p₂, p₃} : Set P)) :\n    p₂ ≠ p₃ := by\n  rintro rfl\n  simp [collinear_pair] at h\n\n"}
{"name":"Collinear.mem_affineSpan_of_mem_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\np₁ p₂ p₃ : P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\nhp₃ : Membership.mem s p₃\nhp₁p₂ : Ne p₁ p₂\n⊢ Membership.mem (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) p₃","decl":"/-- A point in a collinear set of points lies in the affine span of any two distinct points of\nthat set. -/\ntheorem Collinear.mem_affineSpan_of_mem_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ p₃ : P}\n    (hp₁ : p₁ ∈ s) (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) (hp₁p₂ : p₁ ≠ p₂) : p₃ ∈ line[k, p₁, p₂] := by\n  rw [collinear_iff_of_mem hp₁] at h\n  rcases h with ⟨v, h⟩\n  rcases h p₂ hp₂ with ⟨r₂, rfl⟩\n  rcases h p₃ hp₃ with ⟨r₃, rfl⟩\n  rw [vadd_left_mem_affineSpan_pair]\n  refine ⟨r₃ / r₂, ?_⟩\n  have h₂ : r₂ ≠ 0 := by\n    rintro rfl\n    simp at hp₁p₂\n  simp [smul_smul, h₂]\n\n"}
{"name":"Collinear.affineSpan_eq_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\np₁ p₂ : P\nhp₁ : Membership.mem s p₁\nhp₂ : Membership.mem s p₂\nhp₁p₂ : Ne p₁ p₂\n⊢ Eq (affineSpan k (Insert.insert p₁ (Singleton.singleton p₂))) (affineSpan k s)","decl":"/-- The affine span of any two distinct points of a collinear set of points equals the affine\nspan of the whole set. -/\ntheorem Collinear.affineSpan_eq_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ : P} (hp₁ : p₁ ∈ s)\n    (hp₂ : p₂ ∈ s) (hp₁p₂ : p₁ ≠ p₂) : line[k, p₁, p₂] = affineSpan k s :=\n  le_antisymm (affineSpan_mono _ (Set.insert_subset_iff.2 ⟨hp₁, Set.singleton_subset_iff.2 hp₂⟩))\n    (affineSpan_le.2 fun _ hp => h.mem_affineSpan_of_mem_of_ne hp₁ hp₂ hp hp₁p₂)\n\n"}
{"name":"Collinear.collinear_insert_iff_of_ne","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\np₁ p₂ p₃ : P\nhp₂ : Membership.mem s p₂\nhp₃ : Membership.mem s p₃\nhp₂p₃ : Ne p₂ p₃\n⊢ Iff (Collinear k (Insert.insert p₁ s)) (Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))","decl":"/-- Given a collinear set of points, and two distinct points `p₂` and `p₃` in it, a point `p₁` is\ncollinear with the set if and only if it is collinear with `p₂` and `p₃`. -/\ntheorem Collinear.collinear_insert_iff_of_ne {s : Set P} (h : Collinear k s) {p₁ p₂ p₃ : P}\n    (hp₂ : p₂ ∈ s) (hp₃ : p₃ ∈ s) (hp₂p₃ : p₂ ≠ p₃) :\n    Collinear k (insert p₁ s) ↔ Collinear k ({p₁, p₂, p₃} : Set P) := by\n  have hv : vectorSpan k (insert p₁ s) = vectorSpan k ({p₁, p₂, p₃} : Set P) := by\n    -- Porting note: Original proof used `conv_lhs` and `conv_rhs`, but these tactics timed out.\n    rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]\n    symm\n    rw [← direction_affineSpan, ← affineSpan_insert_affineSpan, h.affineSpan_eq_of_ne hp₂ hp₃ hp₂p₃]\n  rw [Collinear, Collinear, hv]\n\n"}
{"name":"collinear_insert_iff_of_mem_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nh : Membership.mem (affineSpan k s) p\n⊢ Iff (Collinear k (Insert.insert p s)) (Collinear k s)","decl":"/-- Adding a point in the affine span of a set does not change whether that set is collinear. -/\ntheorem collinear_insert_iff_of_mem_affineSpan {s : Set P} {p : P} (h : p ∈ affineSpan k s) :\n    Collinear k (insert p s) ↔ Collinear k s := by\n  rw [Collinear, Collinear, vectorSpan_insert_eq_vectorSpan h]\n\n"}
{"name":"collinear_insert_of_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\nh : Membership.mem (affineSpan k (Insert.insert p₂ (Singleton.singleton p₃))) p₁\n⊢ Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- If a point lies in the affine span of two points, those three points are collinear. -/\ntheorem collinear_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ : P} (h : p₁ ∈ line[k, p₂, p₃]) :\n    Collinear k ({p₁, p₂, p₃} : Set P) := by\n  rw [collinear_insert_iff_of_mem_affineSpan h]\n  exact collinear_pair _ _ _\n\n"}
{"name":"collinear_insert_insert_of_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ p₄ : P\nh₁ : Membership.mem (affineSpan k (Insert.insert p₃ (Singleton.singleton p₄))) p₁\nh₂ : Membership.mem (affineSpan k (Insert.insert p₃ (Singleton.singleton p₄))) p₂\n⊢ Collinear k (Insert.insert p₁ (Insert.insert p₂ (Insert.insert p₃ (Singleton.singleton p₄))))","decl":"/-- If two points lie in the affine span of two points, those four points are collinear. -/\ntheorem collinear_insert_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ : P} (h₁ : p₁ ∈ line[k, p₃, p₄])\n    (h₂ : p₂ ∈ line[k, p₃, p₄]) : Collinear k ({p₁, p₂, p₃, p₄} : Set P) := by\n  rw [collinear_insert_iff_of_mem_affineSpan\n      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k (Set.subset_insert _ _)) _ h₁),\n    collinear_insert_iff_of_mem_affineSpan h₂]\n  exact collinear_pair _ _ _\n\n"}
{"name":"collinear_insert_insert_insert_of_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ p₄ p₅ : P\nh₁ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₁\nh₂ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₂\nh₃ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₃\n⊢ Collinear k (Insert.insert p₁ (Insert.insert p₂ (Insert.insert p₃ (Insert.insert p₄ (Singleton.singleton p₅)))))","decl":"/-- If three points lie in the affine span of two points, those five points are collinear. -/\ntheorem collinear_insert_insert_insert_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P}\n    (h₁ : p₁ ∈ line[k, p₄, p₅]) (h₂ : p₂ ∈ line[k, p₄, p₅]) (h₃ : p₃ ∈ line[k, p₄, p₅]) :\n    Collinear k ({p₁, p₂, p₃, p₄, p₅} : Set P) := by\n  rw [collinear_insert_iff_of_mem_affineSpan\n      ((AffineSubspace.le_def' _ _).1\n        (affineSpan_mono k ((Set.subset_insert _ _).trans (Set.subset_insert _ _))) _ h₁),\n    collinear_insert_iff_of_mem_affineSpan\n      ((AffineSubspace.le_def' _ _).1 (affineSpan_mono k (Set.subset_insert _ _)) _ h₂),\n    collinear_insert_iff_of_mem_affineSpan h₃]\n  exact collinear_pair _ _ _\n\n"}
{"name":"collinear_insert_insert_insert_left_of_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ p₄ p₅ : P\nh₁ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₁\nh₂ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₂\nh₃ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₃\n⊢ Collinear k (Insert.insert p₁ (Insert.insert p₂ (Insert.insert p₃ (Singleton.singleton p₄))))","decl":"/-- If three points lie in the affine span of two points, the first four points are collinear. -/\ntheorem collinear_insert_insert_insert_left_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P}\n    (h₁ : p₁ ∈ line[k, p₄, p₅]) (h₂ : p₂ ∈ line[k, p₄, p₅]) (h₃ : p₃ ∈ line[k, p₄, p₅]) :\n    Collinear k ({p₁, p₂, p₃, p₄} : Set P) := by\n  refine (collinear_insert_insert_insert_of_mem_affineSpan_pair h₁ h₂ h₃).subset ?_\n  repeat apply Set.insert_subset_insert\n  simp\n\n"}
{"name":"collinear_triple_of_mem_affineSpan_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ p₄ p₅ : P\nh₁ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₁\nh₂ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₂\nh₃ : Membership.mem (affineSpan k (Insert.insert p₄ (Singleton.singleton p₅))) p₃\n⊢ Collinear k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- If three points lie in the affine span of two points, the first three points are collinear. -/\ntheorem collinear_triple_of_mem_affineSpan_pair {p₁ p₂ p₃ p₄ p₅ : P} (h₁ : p₁ ∈ line[k, p₄, p₅])\n    (h₂ : p₂ ∈ line[k, p₄, p₅]) (h₃ : p₃ ∈ line[k, p₄, p₅]) :\n    Collinear k ({p₁, p₂, p₃} : Set P) := by\n  refine (collinear_insert_insert_insert_left_of_mem_affineSpan_pair h₁ h₂ h₃).subset ?_\n  simp [Set.insert_subset_insert]\n\n"}
{"name":"Coplanar.finiteDimensional_vectorSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Coplanar k s\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)","decl":"/-- The `vectorSpan` of coplanar points is finite-dimensional. -/\ntheorem Coplanar.finiteDimensional_vectorSpan {s : Set P} (h : Coplanar k s) :\n    FiniteDimensional k (vectorSpan k s) := by\n  refine IsNoetherian.iff_fg.1 (IsNoetherian.iff_rank_lt_aleph0.2 (lt_of_le_of_lt h ?_))\n  exact Cardinal.lt_aleph0.2 ⟨2, rfl⟩\n\n"}
{"name":"Coplanar.finiteDimensional_direction_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Coplanar k s\n⊢ FiniteDimensional k (Subtype fun x => Membership.mem (affineSpan k s).direction x)","decl":"/-- The direction of the affine span of coplanar points is finite-dimensional. -/\ntheorem Coplanar.finiteDimensional_direction_affineSpan {s : Set P} (h : Coplanar k s) :\n    FiniteDimensional k (affineSpan k s).direction :=\n  (direction_affineSpan k s).symm ▸ h.finiteDimensional_vectorSpan\n\n"}
{"name":"coplanar_iff_finrank_le_two","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : Set P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)\n⊢ Iff (Coplanar k s) (LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k s) x)) 2)","decl":"/-- A set of points, whose `vectorSpan` is finite-dimensional, is coplanar if and only if their\n`vectorSpan` has dimension at most `2`. -/\ntheorem coplanar_iff_finrank_le_two {s : Set P} [FiniteDimensional k (vectorSpan k s)] :\n    Coplanar k s ↔ finrank k (vectorSpan k s) ≤ 2 := by\n  have h : Coplanar k s ↔ Module.rank k (vectorSpan k s) ≤ 2 := Iff.rfl\n  rw [← finrank_eq_rank] at h\n  exact mod_cast h\n\n"}
{"name":"Coplanar.finrank_le_two","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝⁴ : DivisionRing k\ninst✝³ : AddCommGroup V\ninst✝² : Module k V\ninst✝¹ : AddTorsor V P\ns : Set P\ninst✝ : FiniteDimensional k (Subtype fun x => Membership.mem (vectorSpan k s) x)\na✝ : Coplanar k s\n⊢ LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k s) x)) 2","decl":"alias ⟨Coplanar.finrank_le_two, _⟩ := coplanar_iff_finrank_le_two\n\n"}
{"name":"Coplanar.subset","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns₁ s₂ : Set P\nhs : HasSubset.Subset s₁ s₂\nh : Coplanar k s₂\n⊢ Coplanar k s₁","decl":"/-- A subset of a coplanar set is coplanar. -/\ntheorem Coplanar.subset {s₁ s₂ : Set P} (hs : s₁ ⊆ s₂) (h : Coplanar k s₂) : Coplanar k s₁ :=\n  (Submodule.rank_mono (vectorSpan_mono k hs)).trans h\n\n"}
{"name":"Collinear.coplanar","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\n⊢ Coplanar k s","decl":"/-- Collinear points are coplanar. -/\ntheorem Collinear.coplanar {s : Set P} (h : Collinear k s) : Coplanar k s :=\n  le_trans h one_le_two\n\n"}
{"name":"coplanar_empty","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\n⊢ Coplanar k EmptyCollection.emptyCollection","decl":"/-- The empty set is coplanar. -/\ntheorem coplanar_empty : Coplanar k (∅ : Set P) :=\n  (collinear_empty k P).coplanar\n\n"}
{"name":"coplanar_singleton","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np : P\n⊢ Coplanar k (Singleton.singleton p)","decl":"/-- A single point is coplanar. -/\ntheorem coplanar_singleton (p : P) : Coplanar k ({p} : Set P) :=\n  (collinear_singleton k p).coplanar\n\n"}
{"name":"coplanar_pair","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ : P\n⊢ Coplanar k (Insert.insert p₁ (Singleton.singleton p₂))","decl":"/-- Two points are coplanar. -/\ntheorem coplanar_pair (p₁ p₂ : P) : Coplanar k ({p₁, p₂} : Set P) :=\n  (collinear_pair k p₁ p₂).coplanar\n\n"}
{"name":"coplanar_insert_iff_of_mem_affineSpan","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\nh : Membership.mem (affineSpan k s) p\n⊢ Iff (Coplanar k (Insert.insert p s)) (Coplanar k s)","decl":"/-- Adding a point in the affine span of a set does not change whether that set is coplanar. -/\ntheorem coplanar_insert_iff_of_mem_affineSpan {s : Set P} {p : P} (h : p ∈ affineSpan k s) :\n    Coplanar k (insert p s) ↔ Coplanar k s := by\n  rw [Coplanar, Coplanar, vectorSpan_insert_eq_vectorSpan h]\n\n"}
{"name":"finrank_vectorSpan_insert_le","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : AffineSubspace k P\np : P\n⊢ LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Insert.insert p ↑s)) x)) (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem s.direction x)) 1)","decl":"/-- Adding a point to a finite-dimensional subspace increases the dimension by at most one. -/\ntheorem finrank_vectorSpan_insert_le (s : AffineSubspace k P) (p : P) :\n    finrank k (vectorSpan k (insert p (s : Set P))) ≤ finrank k s.direction + 1 := by\n  by_cases hf : FiniteDimensional k s.direction; swap\n  · have hf' : ¬FiniteDimensional k (vectorSpan k (insert p (s : Set P))) := by\n      intro h\n      have h' : s.direction ≤ vectorSpan k (insert p (s : Set P)) := by\n        conv_lhs => rw [← affineSpan_coe s, direction_affineSpan]\n        exact vectorSpan_mono k (Set.subset_insert _ _)\n      exact hf (Submodule.finiteDimensional_of_le h')\n    rw [finrank_of_infinite_dimensional hf, finrank_of_infinite_dimensional hf', zero_add]\n    exact zero_le_one\n  have : FiniteDimensional k s.direction := hf\n  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan]\n  rcases (s : Set P).eq_empty_or_nonempty with (hs | ⟨p₀, hp₀⟩)\n  · rw [coe_eq_bot_iff] at hs\n    rw [hs, bot_coe, span_empty, bot_coe, direction_affineSpan, direction_bot, finrank_bot,\n      zero_add]\n    convert zero_le_one' ℕ\n    rw [← finrank_bot k V]\n    convert rfl <;> simp\n  · rw [affineSpan_coe, direction_affineSpan_insert hp₀, add_comm]\n    refine (Submodule.finrank_add_le_finrank_add_finrank _ _).trans (add_le_add_right ?_ _)\n    refine finrank_le_one ⟨p -ᵥ p₀, Submodule.mem_span_singleton_self _⟩ fun v => ?_\n    have h := v.property\n    rw [Submodule.mem_span_singleton] at h\n    rcases h with ⟨c, hc⟩\n    refine ⟨c, ?_⟩\n    ext\n    exact hc\n\n"}
{"name":"finrank_vectorSpan_insert_le_set","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\np : P\n⊢ LE.le (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k (Insert.insert p s)) x)) (HAdd.hAdd (Module.finrank k (Subtype fun x => Membership.mem (vectorSpan k s) x)) 1)","decl":"/-- Adding a point to a set with a finite-dimensional span increases the dimension by at most\none. -/\ntheorem finrank_vectorSpan_insert_le_set (s : Set P) (p : P) :\n    finrank k (vectorSpan k (insert p s)) ≤ finrank k (vectorSpan k s) + 1 := by\n  rw [← direction_affineSpan, ← affineSpan_insert_affineSpan, direction_affineSpan]\n  refine (finrank_vectorSpan_insert_le _ _).trans (add_le_add_right ?_ _)\n  rw [direction_affineSpan]\n\n"}
{"name":"Collinear.coplanar_insert","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Collinear k s\np : P\n⊢ Coplanar k (Insert.insert p s)","decl":"/-- Adding a point to a collinear set produces a coplanar set. -/\ntheorem Collinear.coplanar_insert {s : Set P} (h : Collinear k s) (p : P) :\n    Coplanar k (insert p s) := by\n  have : FiniteDimensional k { x // x ∈ vectorSpan k s } := h.finiteDimensional_vectorSpan\n  rw [coplanar_iff_finrank_le_two]\n  exact (finrank_vectorSpan_insert_le_set k s p).trans (add_le_add_right h.finrank_le_one _)\n\n"}
{"name":"coplanar_of_finrank_eq_two","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Eq (Module.finrank k V) 2\n⊢ Coplanar k s","decl":"/-- A set of points in a two-dimensional space is coplanar. -/\ntheorem coplanar_of_finrank_eq_two (s : Set P) (h : finrank k V = 2) : Coplanar k s := by\n  have : FiniteDimensional k V := .of_finrank_eq_succ h\n  rw [coplanar_iff_finrank_le_two, ← h]\n  exact Submodule.finrank_le _\n\n"}
{"name":"coplanar_of_fact_finrank_eq_two","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\ns : Set P\nh : Fact (Eq (Module.finrank k V) 2)\n⊢ Coplanar k s","decl":"/-- A set of points in a two-dimensional space is coplanar. -/\ntheorem coplanar_of_fact_finrank_eq_two (s : Set P) [h : Fact (finrank k V = 2)] : Coplanar k s :=\n  coplanar_of_finrank_eq_two s h.out\n\n"}
{"name":"coplanar_triple","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"k : Type u_1\nV : Type u_2\nP : Type u_3\ninst✝³ : DivisionRing k\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\ninst✝ : AddTorsor V P\np₁ p₂ p₃ : P\n⊢ Coplanar k (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- Three points are coplanar. -/\ntheorem coplanar_triple (p₁ p₂ p₃ : P) : Coplanar k ({p₁, p₂, p₃} : Set P) :=\n  (collinear_pair k p₂ p₃).coplanar_insert p₁\n\n"}
{"name":"AffineBasis.finiteDimensional","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : DivisionRing k\ninst✝¹ : Module k V\ninst✝ : Finite ι\nb : AffineBasis ι k P\n⊢ FiniteDimensional k V","decl":"protected theorem finiteDimensional [Finite ι] (b : AffineBasis ι k P) : FiniteDimensional k V :=\n  let ⟨i⟩ := b.nonempty\n  FiniteDimensional.of_fintype_basis (b.basisOf i)\n\n"}
{"name":"AffineBasis.finite","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : DivisionRing k\ninst✝¹ : Module k V\ninst✝ : FiniteDimensional k V\nb : AffineBasis ι k P\n⊢ Finite ι","decl":"protected theorem finite [FiniteDimensional k V] (b : AffineBasis ι k P) : Finite ι :=\n  finite_of_fin_dim_affineIndependent k b.ind\n\n"}
{"name":"AffineBasis.finite_set","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : DivisionRing k\ninst✝¹ : Module k V\ninst✝ : FiniteDimensional k V\ns : Set ι\nb : AffineBasis (↑s) k P\n⊢ s.Finite","decl":"protected theorem finite_set [FiniteDimensional k V] {s : Set ι} (b : AffineBasis s k P) :\n    s.Finite :=\n  finite_set_of_fin_dim_affineIndependent k b.ind\n\n"}
{"name":"AffineBasis.card_eq_finrank_add_one","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : DivisionRing k\ninst✝¹ : Module k V\ninst✝ : Fintype ι\nb : AffineBasis ι k P\n⊢ Eq (Fintype.card ι) (HAdd.hAdd (Module.finrank k V) 1)","decl":"theorem card_eq_finrank_add_one [Fintype ι] (b : AffineBasis ι k P) :\n    Fintype.card ι = Module.finrank k V + 1 :=\n  have : FiniteDimensional k V := b.finiteDimensional\n  b.ind.affineSpan_eq_top_iff_card_eq_finrank_add_one.mp b.tot\n\n"}
{"name":"AffineBasis.exists_affineBasis_of_finiteDimensional","module":"Mathlib.LinearAlgebra.AffineSpace.FiniteDimensional","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : AddTorsor V P\ninst✝³ : DivisionRing k\ninst✝² : Module k V\ninst✝¹ : Fintype ι\ninst✝ : FiniteDimensional k V\nh : Eq (Fintype.card ι) (HAdd.hAdd (Module.finrank k V) 1)\n⊢ Nonempty (AffineBasis ι k P)","decl":"theorem exists_affineBasis_of_finiteDimensional [Fintype ι] [FiniteDimensional k V]\n    (h : Fintype.card ι = Module.finrank k V + 1) : Nonempty (AffineBasis ι k P) := by\n  obtain ⟨s, b, hb⟩ := AffineBasis.exists_affineBasis k V P\n  lift s to Finset P using b.finite_set\n  refine ⟨b.reindex <| Fintype.equivOfCardEq ?_⟩\n  rw [h, ← b.card_eq_finrank_add_one]\n\n"}
