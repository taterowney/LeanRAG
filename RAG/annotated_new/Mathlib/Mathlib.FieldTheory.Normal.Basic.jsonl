{"name":"Normal.exists_isSplittingField","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝³ : Field F\ninst✝² : Field K\ninst✝¹ : Algebra F K\nh : Normal F K\ninst✝ : FiniteDimensional F K\n⊢ Exists fun p => Polynomial.IsSplittingField F K p","decl":"theorem Normal.exists_isSplittingField [h : Normal F K] [FiniteDimensional F K] :\n    ∃ p : F[X], IsSplittingField F K p := by\n  classical\n  let s := Basis.ofVectorSpace F K\n  refine\n    ⟨∏ x, minpoly F (s x), splits_prod _ fun x _ => h.splits (s x),\n      Subalgebra.toSubmodule.injective ?_⟩\n  rw [Algebra.top_toSubmodule, eq_top_iff, ← s.span_eq, Submodule.span_le, Set.range_subset_iff]\n  refine fun x =>\n    Algebra.subset_adjoin\n      (Multiset.mem_toFinset.mpr <|\n        (mem_roots <|\n              mt (Polynomial.map_eq_zero <| algebraMap F K).1 <|\n                Finset.prod_ne_zero_iff.2 fun x _ => ?_).2 ?_)\n  · exact minpoly.ne_zero (h.isIntegral (s x))\n  rw [IsRoot.def, eval_map, ← aeval_def, map_prod]\n  exact Finset.prod_eq_zero (Finset.mem_univ _) (minpoly.aeval _ _)\n\n"}
{"name":"Normal.of_isSplittingField","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_3\ninst✝¹ : Field E\ninst✝ : Algebra F E\np : Polynomial F\nhFEp : Polynomial.IsSplittingField F E p\n⊢ Normal F E","decl":"@[stacks 09HU \"Normal part\"]\ntheorem Normal.of_isSplittingField (p : F[X]) [hFEp : IsSplittingField F E p] : Normal F E := by\n  rcases eq_or_ne p 0 with (rfl | hp)\n  · have := hFEp.adjoin_rootSet\n    rw [rootSet_zero, Algebra.adjoin_empty] at this\n    exact Normal.of_algEquiv\n      (AlgEquiv.ofBijective (Algebra.ofId F E) (Algebra.bijective_algebraMap_iff.2 this.symm))\n  refine normal_iff.mpr fun x ↦ ?_\n  haveI : FiniteDimensional F E := IsSplittingField.finiteDimensional E p\n  have hx := IsIntegral.of_finite F x\n  let L := (p * minpoly F x).SplittingField\n  have hL := splits_of_splits_mul' _ ?_ (SplittingField.splits (p * minpoly F x))\n  · let j : E →ₐ[F] L := IsSplittingField.lift E p hL.1\n    refine ⟨hx, splits_of_comp _ (j : E →+* L) (j.comp_algebraMap ▸ hL.2) fun a ha ↦ ?_⟩\n    rw [j.comp_algebraMap] at ha\n    letI : Algebra F⟮x⟯ L := ((algHomAdjoinIntegralEquiv F hx).symm ⟨a, ha⟩).toRingHom.toAlgebra\n    let j' : E →ₐ[F⟮x⟯] L := IsSplittingField.lift E (p.map (algebraMap F F⟮x⟯)) ?_\n    · change a ∈ j.range\n      rw [← IsSplittingField.adjoin_rootSet_eq_range E p j,\n            IsSplittingField.adjoin_rootSet_eq_range E p (j'.restrictScalars F)]\n      exact ⟨x, (j'.commutes _).trans (algHomAdjoinIntegralEquiv_symm_apply_gen F hx _)⟩\n    · rw [splits_map_iff, ← IsScalarTower.algebraMap_eq]; exact hL.1\n  · rw [Polynomial.map_ne_zero_iff (algebraMap F L).injective, mul_ne_zero_iff]\n    exact ⟨hp, minpoly.ne_zero hx⟩\n\n"}
{"name":"Polynomial.SplittingField.instNormal","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝ : Field F\np : Polynomial F\n⊢ Normal F p.SplittingField","decl":"instance Polynomial.SplittingField.instNormal (p : F[X]) : Normal F p.SplittingField :=\n  Normal.of_isSplittingField p\n\n"}
{"name":"IntermediateField.normal_iSup","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\nι : Type u_3\nt : ι → IntermediateField F K\nh : ∀ (i : ι), Normal F (Subtype fun x => Membership.mem (t i) x)\n⊢ Normal F (Subtype fun x => Membership.mem (iSup fun i => t i) x)","decl":"/-- A compositum of normal extensions is normal. -/\ninstance normal_iSup {ι : Type*} (t : ι → IntermediateField F K) [h : ∀ i, Normal F (t i)] :\n    Normal F (⨆ i, t i : IntermediateField F K) := by\n  refine { toIsAlgebraic := isAlgebraic_iSup fun i => (h i).1, splits' := fun x => ?_ }\n  obtain ⟨s, hx⟩ := exists_finset_of_mem_supr'' (fun i => (h i).1) x.2\n  let E : IntermediateField F K := ⨆ i ∈ s, adjoin F ((minpoly F (i.2 :)).rootSet K)\n  have hF : Normal F E := by\n    haveI : IsSplittingField F E (∏ i ∈ s, minpoly F i.snd) := by\n      refine isSplittingField_iSup ?_ fun i _ => adjoin_rootSet_isSplittingField ?_\n      · exact Finset.prod_ne_zero_iff.mpr fun i _ => minpoly.ne_zero ((h i.1).isIntegral i.2)\n      · exact Polynomial.splits_comp_of_splits _ (algebraMap (t i.1) K) ((h i.1).splits i.2)\n    apply Normal.of_isSplittingField (∏ i ∈ s, minpoly F i.2)\n  have hE : E ≤ ⨆ i, t i := by\n    refine iSup_le fun i => iSup_le fun _ => le_iSup_of_le i.1 ?_\n    rw [adjoin_le_iff, ← image_rootSet ((h i.1).splits i.2) (t i.1).val]\n    exact fun _ ⟨a, _, h⟩ => h ▸ a.2\n  have := hF.splits ⟨x, hx⟩\n  rw [minpoly_eq, Subtype.coe_mk, ← minpoly_eq] at this\n  exact Polynomial.splits_comp_of_splits _ (inclusion hE).toRingHom this\n\n"}
{"name":"IntermediateField.splits_of_mem_adjoin","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Algebra F K\nL : Type u_3\ninst✝¹ : Field L\ninst✝ : Algebra F L\nS : Set K\nsplits : ∀ (x : K), Membership.mem S x → And (IsIntegral F x) (Polynomial.Splits (algebraMap F L) (minpoly F x))\nx : K\nhx : Membership.mem (IntermediateField.adjoin F S) x\n⊢ Polynomial.Splits (algebraMap F L) (minpoly F x)","decl":"/-- If a set of algebraic elements in a field extension `K/F` have minimal polynomials that\n  split in another extension `L/F`, then all minimal polynomials in the intermediate field\n  generated by the set also split in `L/F`. -/\n@[stacks 0BR3 \"first part\"]\ntheorem splits_of_mem_adjoin {L} [Field L] [Algebra F L] {S : Set K}\n    (splits : ∀ x ∈ S, IsIntegral F x ∧ (minpoly F x).Splits (algebraMap F L)) {x : K}\n    (hx : x ∈ adjoin F S) : (minpoly F x).Splits (algebraMap F L) := by\n  let E : IntermediateField F L := ⨆ x : S, adjoin F ((minpoly F x.val).rootSet L)\n  have normal : Normal F E := normal_iSup (h := fun x ↦\n    Normal.of_isSplittingField (hFEp := adjoin_rootSet_isSplittingField (splits x x.2).2))\n  have : ∀ x ∈ S, (minpoly F x).Splits (algebraMap F E) := fun x hx ↦ splits_of_splits\n    (splits x hx).2 fun y hy ↦ (le_iSup _ ⟨x, hx⟩ : _ ≤ E) (subset_adjoin F _ <| by exact hy)\n  obtain ⟨φ⟩ := nonempty_algHom_adjoin_of_splits fun x hx ↦ ⟨(splits x hx).1, this x hx⟩\n  convert splits_comp_of_splits _ E.val.toRingHom (normal.splits <| φ ⟨x, hx⟩)\n  rw [minpoly.algHom_eq _ φ.injective, ← minpoly.algHom_eq _ (adjoin F S).val.injective, val_mk]\n\n"}
{"name":"IntermediateField.normal_sup","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Algebra F K\nE E' : IntermediateField F K\ninst✝¹ : Normal F (Subtype fun x => Membership.mem E x)\ninst✝ : Normal F (Subtype fun x => Membership.mem E' x)\n⊢ Normal F (Subtype fun x => Membership.mem (Max.max E E') x)","decl":"instance normal_sup\n    (E E' : IntermediateField F K) [Normal F E] [Normal F E'] :\n    Normal F (E ⊔ E' : IntermediateField F K) :=\n  iSup_bool_eq (f := Bool.rec E' E) ▸ normal_iSup (h := by rintro (_|_) <;> infer_instance)\n\n"}
{"name":"IntermediateField.normal_iInf","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝² : Field F\ninst✝¹ : Field K\ninst✝ : Algebra F K\nι : Type u_3\nhι : Nonempty ι\nt : ι → IntermediateField F K\nh : ∀ (i : ι), Normal F (Subtype fun x => Membership.mem (t i) x)\n⊢ Normal F (Subtype fun x => Membership.mem (iInf fun i => t i) x)","decl":"/-- An intersection of normal extensions is normal. -/\n@[stacks 09HP]\ninstance normal_iInf {ι : Type*} [hι : Nonempty ι]\n    (t : ι → IntermediateField F K) [h : ∀ i, Normal F (t i)] :\n    Normal F (⨅ i, t i : IntermediateField F K) := by\n  refine { toIsAlgebraic := ?_, splits' := fun x => ?_ }\n  · let f := inclusion (iInf_le t hι.some)\n    exact Algebra.IsAlgebraic.of_injective f f.injective\n  · have hx : ∀ i, Splits (algebraMap F (t i)) (minpoly F x) := by\n      intro i\n      rw [← minpoly.algHom_eq (inclusion (iInf_le t i)) (inclusion (iInf_le t i)).injective]\n      exact (h i).splits' (inclusion (iInf_le t i) x)\n    simp only [splits_iff_mem (splits_of_isScalarTower K (hx hι.some))] at hx ⊢\n    rintro y hy - ⟨-, ⟨i, rfl⟩, rfl⟩\n    exact hx i y hy\n\n"}
{"name":"IntermediateField.normal_inf","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝⁴ : Field F\ninst✝³ : Field K\ninst✝² : Algebra F K\nE E' : IntermediateField F K\ninst✝¹ : Normal F (Subtype fun x => Membership.mem E x)\ninst✝ : Normal F (Subtype fun x => Membership.mem E' x)\n⊢ Normal F (Subtype fun x => Membership.mem (Min.min E E') x)","decl":"@[stacks 09HP]\ninstance normal_inf\n    (E E' : IntermediateField F K) [Normal F E] [Normal F E'] :\n    Normal F (E ⊓ E' : IntermediateField F K) :=\n  iInf_bool_eq (f := Bool.rec E' E) ▸ normal_iInf (h := by rintro (_|_) <;> infer_instance)\n\n"}
{"name":"AlgHom.fieldRange_of_normal","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\nK : Type u_2\ninst✝³ : Field F\ninst✝² : Field K\ninst✝¹ : Algebra F K\nE : IntermediateField F K\ninst✝ : Normal F (Subtype fun x => Membership.mem E x)\nf : AlgHom F (Subtype fun x => Membership.mem E x) K\n⊢ Eq f.fieldRange E","decl":"theorem AlgHom.fieldRange_of_normal {E : IntermediateField F K} [Normal F E]\n    (f : E →ₐ[F] K) : f.fieldRange = E := by\n  let g := f.restrictNormal' E\n  rw [← show E.val.comp ↑g = f from DFunLike.ext_iff.mpr (f.restrictNormal_commutes E),\n    ← AlgHom.map_fieldRange, AlgEquiv.fieldRange_eq_top g, ← AlgHom.fieldRange_eq_map,\n    IntermediateField.fieldRange_val]\n\n"}
{"name":"AlgHom.liftNormal_commutes","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝¹¹ : Field F\nK₁ : Type u_3\nK₂ : Type u_4\ninst✝¹⁰ : Field K₁\ninst✝⁹ : Field K₂\ninst✝⁸ : Algebra F K₁\ninst✝⁷ : Algebra F K₂\nϕ : AlgHom F K₁ K₂\nE : Type u_6\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra K₁ E\ninst✝³ : Algebra K₂ E\ninst✝² : IsScalarTower F K₁ E\ninst✝¹ : IsScalarTower F K₂ E\ninst✝ : Normal F E\nx : K₁\n⊢ Eq ((ϕ.liftNormal E) ((algebraMap K₁ E) x)) ((algebraMap K₂ E) (ϕ x))","decl":"@[simp]\ntheorem AlgHom.liftNormal_commutes [Normal F E] (x : K₁) :\n    ϕ.liftNormal E (algebraMap K₁ E x) = algebraMap K₂ E (ϕ x) :=\n  -- Porting note: This seems to have been some sort of typeclass override trickery using `by apply`\n  -- Now we explicitly specify which typeclass to override, using `(_)` instead of `_`\n  @AlgHom.commutes K₁ E E _ _ _ _ (_) _ _\n\n"}
{"name":"AlgHom.restrict_liftNormal","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝⁸ : Field F\nK₁ : Type u_3\ninst✝⁷ : Field K₁\ninst✝⁶ : Algebra F K₁\nE : Type u_6\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : Algebra K₁ E\ninst✝² : IsScalarTower F K₁ E\nϕ : AlgHom F K₁ K₁\ninst✝¹ : Normal F K₁\ninst✝ : Normal F E\n⊢ Eq ((ϕ.liftNormal E).restrictNormal K₁) ϕ","decl":"@[simp]\ntheorem AlgHom.restrict_liftNormal (ϕ : K₁ →ₐ[F] K₁) [Normal F K₁] [Normal F E] :\n    (ϕ.liftNormal E).restrictNormal K₁ = ϕ :=\n  AlgHom.ext fun x =>\n    (algebraMap K₁ E).injective\n      (Eq.trans (AlgHom.restrictNormal_commutes _ K₁ x) (ϕ.liftNormal_commutes E x))\n\n"}
{"name":"AlgEquiv.liftNormal_commutes","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝¹¹ : Field F\nK₁ : Type u_3\nK₂ : Type u_4\ninst✝¹⁰ : Field K₁\ninst✝⁹ : Field K₂\ninst✝⁸ : Algebra F K₁\ninst✝⁷ : Algebra F K₂\nχ : AlgEquiv F K₁ K₂\nE : Type u_6\ninst✝⁶ : Field E\ninst✝⁵ : Algebra F E\ninst✝⁴ : Algebra K₁ E\ninst✝³ : Algebra K₂ E\ninst✝² : IsScalarTower F K₁ E\ninst✝¹ : IsScalarTower F K₂ E\ninst✝ : Normal F E\nx : K₁\n⊢ Eq ((χ.liftNormal E) ((algebraMap K₁ E) x)) ((algebraMap K₂ E) (χ x))","decl":"@[simp]\ntheorem AlgEquiv.liftNormal_commutes [Normal F E] (x : K₁) :\n    χ.liftNormal E (algebraMap K₁ E x) = algebraMap K₂ E (χ x) :=\n  χ.toAlgHom.liftNormal_commutes E x\n\n"}
{"name":"AlgEquiv.restrict_liftNormal","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝⁸ : Field F\nK₁ : Type u_3\ninst✝⁷ : Field K₁\ninst✝⁶ : Algebra F K₁\nE : Type u_6\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : Algebra K₁ E\ninst✝² : IsScalarTower F K₁ E\nχ : AlgEquiv F K₁ K₁\ninst✝¹ : Normal F K₁\ninst✝ : Normal F E\n⊢ Eq ((χ.liftNormal E).restrictNormal K₁) χ","decl":"@[simp]\ntheorem AlgEquiv.restrict_liftNormal (χ : K₁ ≃ₐ[F] K₁) [Normal F K₁] [Normal F E] :\n    (χ.liftNormal E).restrictNormal K₁ = χ :=\n  AlgEquiv.ext fun x =>\n    (algebraMap K₁ E).injective\n      (Eq.trans (AlgEquiv.restrictNormal_commutes _ K₁ x) (χ.liftNormal_commutes E x))\n\n"}
{"name":"AlgEquiv.restrictNormalHom_surjective","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝⁸ : Field F\nK₁ : Type u_3\ninst✝⁷ : Field K₁\ninst✝⁶ : Algebra F K₁\nE : Type u_6\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\ninst✝³ : Algebra K₁ E\ninst✝² : IsScalarTower F K₁ E\ninst✝¹ : Normal F K₁\ninst✝ : Normal F E\n⊢ Function.Surjective ⇑(AlgEquiv.restrictNormalHom K₁)","decl":"/-- The group homomorphism given by restricting an algebra isomorphism to a normal subfield\nis surjective. -/\ntheorem AlgEquiv.restrictNormalHom_surjective [Normal F K₁] [Normal F E] :\n    Function.Surjective (AlgEquiv.restrictNormalHom K₁ : (E ≃ₐ[F] E) → K₁ ≃ₐ[F] K₁) := fun χ =>\n  ⟨χ.liftNormal E, χ.restrict_liftNormal E⟩\n\n"}
{"name":"Normal.minpoly_eq_iff_mem_orbit","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\nE : Type u_6\ninst✝¹ : Field E\ninst✝ : Algebra F E\nh : Normal F E\nx y : E\n⊢ Iff (Eq (minpoly F x) (minpoly F y)) (Membership.mem (MulAction.orbit (AlgEquiv F E E) y) x)","decl":"open IntermediateField in\ntheorem Normal.minpoly_eq_iff_mem_orbit [h : Normal F E] {x y : E} :\n    minpoly F x = minpoly F y ↔ x ∈ MulAction.orbit (E ≃ₐ[F] E) y := by\n  refine ⟨fun he ↦ ?_, fun ⟨f, he⟩ ↦ he ▸ minpoly.algEquiv_eq f y⟩\n  obtain ⟨φ, hφ⟩ := exists_algHom_of_splits_of_aeval (normal_iff.mp h) (he ▸ minpoly.aeval F x)\n  exact ⟨AlgEquiv.ofBijective φ (φ.normal_bijective F E E), hφ⟩\n\n"}
{"name":"isSolvable_of_isScalarTower","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"F : Type u_1\ninst✝⁷ : Field F\nK₁ : Type u_3\ninst✝⁶ : Field K₁\ninst✝⁵ : Algebra F K₁\nE : Type u_6\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\ninst✝² : Algebra K₁ E\ninst✝¹ : IsScalarTower F K₁ E\ninst✝ : Normal F K₁\nh1 : IsSolvable (AlgEquiv F K₁ K₁)\nh2 : IsSolvable (AlgEquiv K₁ E E)\n⊢ IsSolvable (AlgEquiv F E E)","decl":"theorem isSolvable_of_isScalarTower [Normal F K₁] [h1 : IsSolvable (K₁ ≃ₐ[F] K₁)]\n    [h2 : IsSolvable (E ≃ₐ[K₁] E)] : IsSolvable (E ≃ₐ[F] E) := by\n  let f : (E ≃ₐ[K₁] E) →* E ≃ₐ[F] E :=\n    { toFun := fun ϕ =>\n        AlgEquiv.ofAlgHom (ϕ.toAlgHom.restrictScalars F) (ϕ.symm.toAlgHom.restrictScalars F)\n          (AlgHom.ext fun x => ϕ.apply_symm_apply x) (AlgHom.ext fun x => ϕ.symm_apply_apply x)\n      map_one' := AlgEquiv.ext fun _ => rfl\n      map_mul' := fun _ _ => AlgEquiv.ext fun _ => rfl }\n  refine\n    solvable_of_ker_le_range f (AlgEquiv.restrictNormalHom K₁) fun ϕ hϕ =>\n      ⟨{ ϕ with commutes' := fun x => ?_ }, AlgEquiv.ext fun _ => rfl⟩\n  exact Eq.trans (ϕ.restrictNormal_commutes K₁ x).symm (congr_arg _ (AlgEquiv.ext_iff.mp hϕ x))\n\n"}
{"name":"minpoly.exists_algEquiv_of_root","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"K : Type u_6\nL : Type u_7\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Normal K L\nx y : L\nhy : IsAlgebraic K y\nh_ev : Eq ((Polynomial.aeval x) (minpoly K y)) 0\n⊢ Exists fun σ => Eq (σ x) y","decl":"/-- If `x : L` is a root of `minpoly K y`, then we can find `(σ : L ≃ₐ[K] L)` with `σ x = y`.\n  That is, `x` and `y` are Galois conjugates. -/\ntheorem exists_algEquiv_of_root [Normal K L] {x y : L} (hy : IsAlgebraic K y)\n    (h_ev : (Polynomial.aeval x) (minpoly K y) = 0) : ∃ σ : L ≃ₐ[K] L, σ x = y := by\n  have hx : IsAlgebraic K x := ⟨minpoly K y, ne_zero hy.isIntegral, h_ev⟩\n  set f : K⟮x⟯ ≃ₐ[K] K⟮y⟯ := algEquiv hx (eq_of_root hy h_ev)\n  have hxy : (liftNormal f L) ((algebraMap (↥K⟮x⟯) L) (AdjoinSimple.gen K x)) = y := by\n    rw [liftNormal_commutes f L, algEquiv_apply, AdjoinSimple.algebraMap_gen K y]\n  exact ⟨(liftNormal f L), hxy⟩\n\n"}
{"name":"minpoly.exists_algEquiv_of_root'","module":"Mathlib.FieldTheory.Normal.Basic","initialProofState":"K : Type u_6\nL : Type u_7\ninst✝³ : Field K\ninst✝² : Field L\ninst✝¹ : Algebra K L\ninst✝ : Normal K L\nx y : L\nhy : IsAlgebraic K y\nh_ev : Eq ((Polynomial.aeval x) (minpoly K y)) 0\n⊢ Exists fun σ => Eq (σ y) x","decl":"/-- If `x : L` is a root of `minpoly K y`, then we can find `(σ : L ≃ₐ[K] L)` with `σ y = x`.\n  That is, `x` and `y` are Galois conjugates. -/\ntheorem exists_algEquiv_of_root' [Normal K L]{x y : L} (hy : IsAlgebraic K y)\n    (h_ev : (Polynomial.aeval x) (minpoly K y) = 0) : ∃ σ : L ≃ₐ[K] L, σ y = x := by\n  obtain ⟨σ, hσ⟩ := exists_algEquiv_of_root hy h_ev\n  use σ.symm\n  rw [← hσ, symm_apply_apply]\n\n"}
