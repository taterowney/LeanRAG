{"name":"CategoryTheory.Monad.Algebra.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA‚úù : C\na‚úù : Quiver.Hom (T.obj A‚úù) A‚úù\nunit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app A‚úù) a‚úù) (CategoryTheory.CategoryStruct.id A‚úù)) _auto‚úù\nassoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app A‚úù) a‚úù) (CategoryTheory.CategoryStruct.comp (T.map a‚úù) a‚úù)) _auto‚úù\nA : C\na : Quiver.Hom (T.obj A) A\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app A) a) (CategoryTheory.CategoryStruct.id A)) _auto‚úù\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app A) a) (CategoryTheory.CategoryStruct.comp (T.map a) a)) _auto‚úù\nx‚úù : Eq { A := A‚úù, a := a‚úù, unit := unit‚úù, assoc := assoc‚úù } { A := A, a := a, unit := unit, assoc := assoc }\n‚ä¢ And (Eq A‚úù A) (HEq a‚úù a)","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ‚•§ C).obj A ‚ü∂ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.Œ∑.app A ‚â´ a = ùüô A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.Œº.app A ‚â´ a = (T : C ‚•§ C).map a ‚â´ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\ninst‚úù : SizeOf C\nA : C\na : Quiver.Hom (T.obj A) A\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app A) a) (CategoryTheory.CategoryStruct.id A)) _auto‚úù\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app A) a) (CategoryTheory.CategoryStruct.comp (T.map a) a)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { A := A, a := a, unit := unit, assoc := assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf A)) (SizeOf.sizeOf a)) (SizeOf.sizeOf unit)) (SizeOf.sizeOf assoc))","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ‚•§ C).obj A ‚ü∂ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.Œ∑.app A ‚â´ a = ùüô A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.Œº.app A ‚â´ a = (T : C ‚•§ C).map a ‚â´ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA‚úù : C\na‚úù : Quiver.Hom (T.obj A‚úù) A‚úù\nunit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app A‚úù) a‚úù) (CategoryTheory.CategoryStruct.id A‚úù)) _auto‚úù\nassoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app A‚úù) a‚úù) (CategoryTheory.CategoryStruct.comp (T.map a‚úù) a‚úù)) _auto‚úù\nA : C\na : Quiver.Hom (T.obj A) A\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app A) a) (CategoryTheory.CategoryStruct.id A)) _auto‚úù\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app A) a) (CategoryTheory.CategoryStruct.comp (T.map a) a)) _auto‚úù\n‚ä¢ Eq (Eq { A := A‚úù, a := a‚úù, unit := unit‚úù, assoc := assoc‚úù } { A := A, a := a, unit := unit, assoc := assoc }) (And (Eq A‚úù A) (HEq a‚úù a))","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ‚•§ C).obj A ‚ü∂ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.Œ∑.app A ‚â´ a = ùüô A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.Œº.app A ‚â´ a = (T : C ‚•§ C).map a ‚â´ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nself : T.Algebra\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app self.A) self.a) (CategoryTheory.CategoryStruct.comp (T.map self.a) self.a)","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ‚•§ C).obj A ‚ü∂ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.Œ∑.app A ‚â´ a = ùüô A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.Œº.app A ‚â´ a = (T : C ‚•§ C).map a ‚â´ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.unit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nself : T.Algebra\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app self.A) self.a) (CategoryTheory.CategoryStruct.id self.A)","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ‚•§ C).obj A ‚ü∂ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.Œ∑.app A ‚â´ a = ùüô A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.Œº.app A ‚â´ a = (T : C ‚•§ C).map a ‚â´ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.unit_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nself : T.Algebra\nZ : C\nh : Quiver.Hom self.A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T.Œ∑.app self.A) (CategoryTheory.CategoryStruct.comp self.a h)) h","decl":"attribute [reassoc] Algebra.unit Algebra.assoc\n\n"}
{"name":"CategoryTheory.Monad.Algebra.assoc_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nself : T.Algebra\nZ : C\nh : Quiver.Hom self.A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T.Œº.app self.A) (CategoryTheory.CategoryStruct.comp self.a h)) (CategoryTheory.CategoryStruct.comp (T.map self.a) (CategoryTheory.CategoryStruct.comp self.a h))","decl":"attribute [reassoc] Algebra.unit Algebra.assoc\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nf‚úù : Quiver.Hom A.A B.A\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f‚úù) B.a) (CategoryTheory.CategoryStruct.comp A.a f‚úù)) _auto‚úù\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f) B.a) (CategoryTheory.CategoryStruct.comp A.a f)) _auto‚úù\nx‚úù : Eq { f := f‚úù, h := h‚úù } { f := f, h := h }\n‚ä¢ Eq f‚úù f","decl":"/-- A morphism of Eilenberg‚ÄìMoore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ‚•§ C).map f ‚â´ B.a = A.a ‚â´ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of Eilenberg‚ÄìMoore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ‚•§ C).map f ‚â´ B.a = A.a ‚â´ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nf‚úù : Quiver.Hom A.A B.A\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f‚úù) B.a) (CategoryTheory.CategoryStruct.comp A.a f‚úù)) _auto‚úù\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f) B.a) (CategoryTheory.CategoryStruct.comp A.a f)) _auto‚úù\n‚ä¢ Eq (Eq { f := f‚úù, h := h‚úù } { f := f, h := h }) (Eq f‚úù f)","decl":"/-- A morphism of Eilenberg‚ÄìMoore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ‚•§ C).map f ‚â´ B.a = A.a ‚â´ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.h","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nself : A.Hom B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T.map self.f) B.a) (CategoryTheory.CategoryStruct.comp A.a self.f)","decl":"/-- A morphism of Eilenberg‚ÄìMoore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ‚•§ C).map f ‚â´ B.a = A.a ‚â´ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nx y : A.Hom B\nf : Eq x.f y.f\n‚ä¢ Eq x y","decl":"/-- A morphism of Eilenberg‚ÄìMoore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ‚•§ C).map f ‚â´ B.a = A.a ‚â´ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\ninst‚úù : SizeOf C\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f) B.a) (CategoryTheory.CategoryStruct.comp A.a f)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { f := f, h := h }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf h))","decl":"/-- A morphism of Eilenberg‚ÄìMoore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ‚•§ C).map f ‚â´ B.a = A.a ‚â´ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.h_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nself : A.Hom B\nZ : C\nh : Quiver.Hom B.A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (T.map self.f) (CategoryTheory.CategoryStruct.comp B.a h)) (CategoryTheory.CategoryStruct.comp A.a (CategoryTheory.CategoryStruct.comp self.f h))","decl":"attribute [reassoc (attr := simp)] Hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext'","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf g : Quiver.Hom X Y\nh : Eq f.f g.f\n‚ä¢ Eq f g","decl":"@[ext]\nlemma Hom.ext' (X Y : Algebra T) (f g : X ‚ü∂ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.f g.f)","decl":"@[ext]\nlemma Hom.ext' (X Y : Algebra T) (f g : X ‚ü∂ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.comp_eq_comp","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA A' A'' : T.Algebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n‚ä¢ Eq (CategoryTheory.Monad.Algebra.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\ntheorem comp_eq_comp {A A' A'' : Algebra T} (f : A ‚ü∂ A') (g : A' ‚ü∂ A'') :\n    Algebra.Hom.comp f g = f ‚â´ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.id_eq_id","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA : T.Algebra\n‚ä¢ Eq (CategoryTheory.Monad.Algebra.Hom.id A) (CategoryTheory.CategoryStruct.id A)","decl":"@[simp]\ntheorem id_eq_id (A : Algebra T) : Algebra.Hom.id A = ùüô A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.id_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA : T.Algebra\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id A).f (CategoryTheory.CategoryStruct.id A.A)","decl":"@[simp]\ntheorem id_f (A : Algebra T) : (ùüô A : A ‚ü∂ A).f = ùüô A.A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.comp_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA A' A'' : T.Algebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {A A' A'' : Algebra T} (f : A ‚ü∂ A') (g : A' ‚ü∂ A'') : (f ‚â´ g).f = f.f ‚â´ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.isoMk_inv_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map h.hom) B.a) (CategoryTheory.CategoryStruct.comp A.a h.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Monad.Algebra.isoMk h w).inv.f h.inv","decl":"/--\nTo construct an isomorphism of algebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Algebra T} (h : A.A ‚âÖ B.A)\n    (w : (T : C ‚•§ C).map h.hom ‚â´ B.a = A.a ‚â´ h.hom := by aesop_cat) : A ‚âÖ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, ‚Üê w, ‚Üê Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.Monad.Algebra.isoMk_hom_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map h.hom) B.a) (CategoryTheory.CategoryStruct.comp A.a h.hom)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Monad.Algebra.isoMk h w).hom.f h.hom","decl":"/--\nTo construct an isomorphism of algebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Algebra T} (h : A.A ‚âÖ B.A)\n    (w : (T : C ‚•§ C).map h.hom ‚â´ B.a = A.a ‚â´ h.hom := by aesop_cat) : A ‚âÖ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, ‚Üê w, ‚Üê Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.Monad.forget_map","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX‚úù Y‚úù : T.Algebra\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (T.forget.map f) f.f","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the algebraic structure. -/\n@[simps]\ndef forget : Algebra T ‚•§ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Monad.forget_obj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA : T.Algebra\n‚ä¢ Eq (T.forget.obj A) A.A","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the algebraic structure. -/\n@[simps]\ndef forget : Algebra T ‚•§ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Monad.free_obj_a","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq (T.free.obj X).a (T.Œº.app X)","decl":"/-- The free functor from the Eilenberg-Moore category, constructing an algebra for any object. -/\n@[simps]\ndef free : C ‚•§ Algebra T where\n  obj X :=\n    { A := T.obj X\n      a := T.Œº.app X\n      assoc := (T.assoc _).symm }\n  map f :=\n    { f := T.map f\n      h := T.Œº.naturality _ }\n\n"}
{"name":"CategoryTheory.Monad.free_obj_A","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX : C\n‚ä¢ Eq (T.free.obj X).A (T.obj X)","decl":"/-- The free functor from the Eilenberg-Moore category, constructing an algebra for any object. -/\n@[simps]\ndef free : C ‚•§ Algebra T where\n  obj X :=\n    { A := T.obj X\n      a := T.Œº.app X\n      assoc := (T.assoc _).symm }\n  map f :=\n    { f := T.map f\n      h := T.Œº.naturality _ }\n\n"}
{"name":"CategoryTheory.Monad.free_map_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (T.free.map f).f (T.map f)","decl":"/-- The free functor from the Eilenberg-Moore category, constructing an algebra for any object. -/\n@[simps]\ndef free : C ‚•§ Algebra T where\n  obj X :=\n    { A := T.obj X\n      a := T.Œº.app X\n      assoc := (T.assoc _).symm }\n  map f :=\n    { f := T.map f\n      h := T.Œº.naturality _ }\n\n"}
{"name":"CategoryTheory.Monad.adj_counit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ Eq T.adj.counit { app := fun Y => { f := Y.a, h := ‚ãØ }, naturality := ‚ãØ }","decl":"/-- The adjunction between the free and forgetful constructions for Eilenberg-Moore algebras for\n  a monad. cf Lemma 5.2.8 of [Riehl][riehl2017]. -/\n@[simps! unit counit]\ndef adj : T.free ‚ä£ T.forget :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => T.Œ∑.app X ‚â´ f.f\n          invFun := fun f =>\n            { f := T.map f ‚â´ Y.a\n              h := by\n                dsimp\n                simp [‚Üê Y.assoc, ‚Üê T.Œº.naturality_assoc] }\n          left_inv := fun f => by\n            ext\n            dsimp\n            simp\n          right_inv := fun f => by\n            dsimp only [forget_obj]\n            rw [‚Üê T.Œ∑.naturality_assoc, Y.unit]\n            apply Category.comp_id } }\n\n"}
{"name":"CategoryTheory.Monad.adj_unit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ Eq T.adj.unit { app := fun X => T.Œ∑.app X, naturality := ‚ãØ }","decl":"/-- The adjunction between the free and forgetful constructions for Eilenberg-Moore algebras for\n  a monad. cf Lemma 5.2.8 of [Riehl][riehl2017]. -/\n@[simps! unit counit]\ndef adj : T.free ‚ä£ T.forget :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => T.Œ∑.app X ‚â´ f.f\n          invFun := fun f =>\n            { f := T.map f ‚â´ Y.a\n              h := by\n                dsimp\n                simp [‚Üê Y.assoc, ‚Üê T.Œº.naturality_assoc] }\n          left_inv := fun f => by\n            ext\n            dsimp\n            simp\n          right_inv := fun f => by\n            dsimp only [forget_obj]\n            rw [‚Üê T.Œ∑.naturality_assoc, Y.unit]\n            apply Category.comp_id } }\n\n"}
{"name":"CategoryTheory.Monad.algebra_iso_of_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso f.f\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Given an algebra morphism whose carrier part is an isomorphism, we get an algebra isomorphism.\n-/\ntheorem algebra_iso_of_iso {A B : Algebra T} (f : A ‚ü∂ B) [IsIso f.f] : IsIso f :=\n  ‚ü®‚ü®{   f := inv f.f\n        h := by\n          rw [IsIso.eq_comp_inv f.f, Category.assoc, ‚Üê f.h]\n          simp },\n      by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Monad.forget_reflects_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ T.forget.ReflectsIsomorphisms","decl":"instance forget_reflects_iso : T.forget.ReflectsIsomorphisms where\n  -- Porting note: Is this the right approach to introduce instances?\n  reflects {_ _} f := fun [IsIso f.f] => algebra_iso_of_iso T f\n\n"}
{"name":"CategoryTheory.Monad.forget_faithful","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ T.forget.Faithful","decl":"instance forget_faithful : T.forget.Faithful where\n\n"}
{"name":"CategoryTheory.Monad.algebra_epi_of_epi","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi f.f\n‚ä¢ CategoryTheory.Epi f","decl":"/-- Given an algebra morphism whose carrier part is an epimorphism, we get an algebra epimorphism.\n-/\ntheorem algebra_epi_of_epi {X Y : Algebra T} (f : X ‚ü∂ Y) [h : Epi f.f] : Epi f :=\n  (forget T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.Monad.algebra_mono_of_mono","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono f.f\n‚ä¢ CategoryTheory.Mono f","decl":"/-- Given an algebra morphism whose carrier part is a monomorphism, we get an algebra monomorphism.\n-/\ntheorem algebra_mono_of_mono {X Y : Algebra T} (f : X ‚ü∂ Y) [h : Mono f.f] : Mono f :=\n  (forget T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Monad.instIsRightAdjointAlgebraForget","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT : CategoryTheory.Monad C\n‚ä¢ T.forget.IsRightAdjoint","decl":"instance : T.forget.IsRightAdjoint  :=\n  ‚ü®T.free, ‚ü®T.adj‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHom_obj_A","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : Quiver.Hom T‚ÇÇ T‚ÇÅ\nA : T‚ÇÅ.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).obj A).A A.A","decl":"/--\nGiven a monad morphism from `T‚ÇÇ` to `T‚ÇÅ`, we get a functor from the algebras of `T‚ÇÅ` to algebras of\n`T‚ÇÇ`.\n-/\n@[simps]\ndef algebraFunctorOfMonadHom {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÇ ‚ü∂ T‚ÇÅ) : Algebra T‚ÇÅ ‚•§ Algebra T‚ÇÇ where\n  obj A :=\n    { A := A.A\n      a := h.app A.A ‚â´ A.a\n      unit := by\n        dsimp\n        simp [A.unit]\n      assoc := by\n        dsimp\n        simp [A.assoc] }\n  map f := { f := f.f }\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHom_map_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : Quiver.Hom T‚ÇÇ T‚ÇÅ\nX‚úù Y‚úù : T‚ÇÅ.Algebra\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).map f).f f.f","decl":"/--\nGiven a monad morphism from `T‚ÇÇ` to `T‚ÇÅ`, we get a functor from the algebras of `T‚ÇÅ` to algebras of\n`T‚ÇÇ`.\n-/\n@[simps]\ndef algebraFunctorOfMonadHom {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÇ ‚ü∂ T‚ÇÅ) : Algebra T‚ÇÅ ‚•§ Algebra T‚ÇÇ where\n  obj A :=\n    { A := A.A\n      a := h.app A.A ‚â´ A.a\n      unit := by\n        dsimp\n        simp [A.unit]\n      assoc := by\n        dsimp\n        simp [A.assoc] }\n  map f := { f := f.f }\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHom_obj_a","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : Quiver.Hom T‚ÇÇ T‚ÇÅ\nA : T‚ÇÅ.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).obj A).a (CategoryTheory.CategoryStruct.comp (h.app A.A) A.a)","decl":"/--\nGiven a monad morphism from `T‚ÇÇ` to `T‚ÇÅ`, we get a functor from the algebras of `T‚ÇÅ` to algebras of\n`T‚ÇÇ`.\n-/\n@[simps]\ndef algebraFunctorOfMonadHom {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÇ ‚ü∂ T‚ÇÅ) : Algebra T‚ÇÅ ‚•§ Algebra T‚ÇÇ where\n  obj A :=\n    { A := A.A\n      a := h.app A.A ‚â´ A.a\n      unit := by\n        dsimp\n        simp [A.unit]\n      assoc := by\n        dsimp\n        simp [A.assoc] }\n  map f := { f := f.f }\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomId_hom_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ : CategoryTheory.Monad C\nX : T‚ÇÅ.Algebra\n‚ä¢ Eq (CategoryTheory.Monad.algebraFunctorOfMonadHomId.hom.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.id T‚ÇÅ)).obj X).A).hom","decl":"/--\nThe identity monad morphism induces the identity functor from the category of algebras to itself.\n-/\n-- Porting note: `semireducible -> default`\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomId {T‚ÇÅ : Monad C} : algebraFunctorOfMonadHom (ùüô T‚ÇÅ) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomId_inv_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ : CategoryTheory.Monad C\nX : T‚ÇÅ.Algebra\n‚ä¢ Eq (CategoryTheory.Monad.algebraFunctorOfMonadHomId.inv.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.id T‚ÇÅ)).obj X).A).inv","decl":"/--\nThe identity monad morphism induces the identity functor from the category of algebras to itself.\n-/\n-- Porting note: `semireducible -> default`\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomId {T‚ÇÅ : Monad C} : algebraFunctorOfMonadHom (ùüô T‚ÇÅ) ‚âÖ ùü≠ _ :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomComp_hom_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ T‚ÇÉ : CategoryTheory.Monad C\nf : Quiver.Hom T‚ÇÅ T‚ÇÇ\ng : Quiver.Hom T‚ÇÇ T‚ÇÉ\nX : T‚ÇÉ.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomComp f g).hom.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.comp f g)).obj X).A).hom","decl":"/-- A composition of monad morphisms gives the composition of corresponding functors.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomComp {T‚ÇÅ T‚ÇÇ T‚ÇÉ : Monad C} (f : T‚ÇÅ ‚ü∂ T‚ÇÇ) (g : T‚ÇÇ ‚ü∂ T‚ÇÉ) :\n    algebraFunctorOfMonadHom (f ‚â´ g) ‚âÖ algebraFunctorOfMonadHom g ‚ãô algebraFunctorOfMonadHom f :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomComp_inv_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ T‚ÇÉ : CategoryTheory.Monad C\nf : Quiver.Hom T‚ÇÅ T‚ÇÇ\ng : Quiver.Hom T‚ÇÇ T‚ÇÉ\nX : T‚ÇÉ.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomComp f g).inv.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.comp f g)).obj X).A).inv","decl":"/-- A composition of monad morphisms gives the composition of corresponding functors.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomComp {T‚ÇÅ T‚ÇÇ T‚ÇÉ : Monad C} (f : T‚ÇÅ ‚ü∂ T‚ÇÇ) (g : T‚ÇÇ ‚ü∂ T‚ÇÉ) :\n    algebraFunctorOfMonadHom (f ‚â´ g) ‚âÖ algebraFunctorOfMonadHom g ‚ãô algebraFunctorOfMonadHom f :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomEq_inv_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nf g : Quiver.Hom T‚ÇÅ T‚ÇÇ\nh : Eq f g\nX : T‚ÇÇ.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq h).inv.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom f).obj X).A).inv","decl":"/-- If `f` and `g` are two equal morphisms of monads, then the functors of algebras induced by them\nare isomorphic.\nWe define it like this as opposed to using `eqToIso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomEq {T‚ÇÅ T‚ÇÇ : Monad C} {f g : T‚ÇÅ ‚ü∂ T‚ÇÇ} (h : f = g) :\n    algebraFunctorOfMonadHom f ‚âÖ algebraFunctorOfMonadHom g :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomEq_hom_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nf g : Quiver.Hom T‚ÇÅ T‚ÇÇ\nh : Eq f g\nX : T‚ÇÇ.Algebra\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq h).hom.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom f).obj X).A).hom","decl":"/-- If `f` and `g` are two equal morphisms of monads, then the functors of algebras induced by them\nare isomorphic.\nWe define it like this as opposed to using `eqToIso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomEq {T‚ÇÅ T‚ÇÇ : Monad C} {f g : T‚ÇÅ ‚ü∂ T‚ÇÇ} (h : f = g) :\n    algebraFunctorOfMonadHom f ‚âÖ algebraFunctorOfMonadHom g :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_unitIso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).unitIso (CategoryTheory.Monad.algebraFunctorOfMonadHomId.symm.trans ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq ‚ãØ).trans (CategoryTheory.Monad.algebraFunctorOfMonadHomComp h.hom h.inv)))","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ‚ãô forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÅ ‚âÖ T‚ÇÇ) : Algebra T‚ÇÅ ‚âå Algebra T‚ÇÇ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_counitIso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).counitIso ((CategoryTheory.Monad.algebraFunctorOfMonadHomComp h.inv h.hom).symm.trans ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq ‚ãØ).trans CategoryTheory.Monad.algebraFunctorOfMonadHomId))","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ‚ãô forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÅ ‚âÖ T‚ÇÇ) : Algebra T‚ÇÅ ‚âå Algebra T‚ÇÇ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_inverse","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).inverse (CategoryTheory.Monad.algebraFunctorOfMonadHom h.hom)","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ‚ãô forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÅ ‚âÖ T‚ÇÇ) : Algebra T‚ÇÅ ‚âå Algebra T‚ÇÇ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_functor","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).functor (CategoryTheory.Monad.algebraFunctorOfMonadHom h.inv)","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ‚ãô forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÅ ‚âÖ T‚ÇÇ) : Algebra T‚ÇÅ ‚âå Algebra T‚ÇÇ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ‚â™‚â´\n      algebraFunctorOfMonadHomEq (by simp) ‚â™‚â´ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebra_equiv_of_iso_monads_comp_forget","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nT‚ÇÅ T‚ÇÇ : CategoryTheory.Monad C\nh : Quiver.Hom T‚ÇÅ T‚ÇÇ\n‚ä¢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).comp T‚ÇÅ.forget) T‚ÇÇ.forget","decl":"@[simp]\ntheorem algebra_equiv_of_iso_monads_comp_forget {T‚ÇÅ T‚ÇÇ : Monad C} (h : T‚ÇÅ ‚ü∂ T‚ÇÇ) :\n    algebraFunctorOfMonadHom h ‚ãô forget _ = forget _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA‚úù : C\na‚úù : Quiver.Hom A‚úù (G.obj A‚úù)\ncounit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp a‚úù (G.Œµ.app A‚úù)) (CategoryTheory.CategoryStruct.id A‚úù)) _auto‚úù\ncoassoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp a‚úù (G.Œ¥.app A‚úù)) (CategoryTheory.CategoryStruct.comp a‚úù (G.map a‚úù))) _auto‚úù\nA : C\na : Quiver.Hom A (G.obj A)\ncounit : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.Œµ.app A)) (CategoryTheory.CategoryStruct.id A)) _auto‚úù\ncoassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.Œ¥.app A)) (CategoryTheory.CategoryStruct.comp a (G.map a))) _auto‚úù\n‚ä¢ Eq (Eq { A := A‚úù, a := a‚úù, counit := counit‚úù, coassoc := coassoc‚úù } { A := A, a := a, counit := counit, coassoc := coassoc }) (And (Eq A‚úù A) (HEq a‚úù a))","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ‚ü∂ (G : C ‚•§ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ‚â´ G.Œµ.app A = ùüô A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ‚â´ G.Œ¥.app A = a ‚â´ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA‚úù : C\na‚úù : Quiver.Hom A‚úù (G.obj A‚úù)\ncounit‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp a‚úù (G.Œµ.app A‚úù)) (CategoryTheory.CategoryStruct.id A‚úù)) _auto‚úù\ncoassoc‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp a‚úù (G.Œ¥.app A‚úù)) (CategoryTheory.CategoryStruct.comp a‚úù (G.map a‚úù))) _auto‚úù\nA : C\na : Quiver.Hom A (G.obj A)\ncounit : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.Œµ.app A)) (CategoryTheory.CategoryStruct.id A)) _auto‚úù\ncoassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.Œ¥.app A)) (CategoryTheory.CategoryStruct.comp a (G.map a))) _auto‚úù\nx‚úù : Eq { A := A‚úù, a := a‚úù, counit := counit‚úù, coassoc := coassoc‚úù } { A := A, a := a, counit := counit, coassoc := coassoc }\n‚ä¢ And (Eq A‚úù A) (HEq a‚úù a)","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ‚ü∂ (G : C ‚•§ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ‚â´ G.Œµ.app A = ùüô A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ‚â´ G.Œ¥.app A = a ‚â´ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.coassoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.a (G.Œ¥.app self.A)) (CategoryTheory.CategoryStruct.comp self.a (G.map self.a))","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ‚ü∂ (G : C ‚•§ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ‚â´ G.Œµ.app A = ùüô A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ‚â´ G.Œ¥.app A = a ‚â´ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\ninst‚úù : SizeOf C\nA : C\na : Quiver.Hom A (G.obj A)\ncounit : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.Œµ.app A)) (CategoryTheory.CategoryStruct.id A)) _auto‚úù\ncoassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.Œ¥.app A)) (CategoryTheory.CategoryStruct.comp a (G.map a))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { A := A, a := a, counit := counit, coassoc := coassoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf A)) (SizeOf.sizeOf a)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf coassoc))","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ‚ü∂ (G : C ‚•§ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ‚â´ G.Œµ.app A = ùüô A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ‚â´ G.Œ¥.app A = a ‚â´ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.counit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.a (G.Œµ.app self.A)) (CategoryTheory.CategoryStruct.id self.A)","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u‚ÇÅ v‚ÇÅ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ‚ü∂ (G : C ‚•§ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ‚â´ G.Œµ.app A = ùüô A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ‚â´ G.Œ¥.app A = a ‚â´ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.coassoc_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\nZ : C\nh : Quiver.Hom (G.obj (G.obj self.A)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.a (CategoryTheory.CategoryStruct.comp (G.Œ¥.app self.A) h)) (CategoryTheory.CategoryStruct.comp self.a (CategoryTheory.CategoryStruct.comp (G.map self.a) h))","decl":"attribute [reassoc] Coalgebra.counit Coalgebra.coassoc\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.counit_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\nZ : C\nh : Quiver.Hom self.A Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp self.a (CategoryTheory.CategoryStruct.comp (G.Œµ.app self.A) h)) h","decl":"attribute [reassoc] Coalgebra.counit Coalgebra.coassoc\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\ninst‚úù : SizeOf C\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f)) (CategoryTheory.CategoryStruct.comp f B.a)) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { f := f, h := h }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf h))","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ‚â´ (G : C ‚•§ C).map f = f ‚â´ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nx y : A.Hom B\nf : Eq x.f y.f\n‚ä¢ Eq x y","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ‚â´ (G : C ‚•§ C).map f = f ‚â´ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.h","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nself : A.Hom B\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.a (G.map self.f)) (CategoryTheory.CategoryStruct.comp self.f B.a)","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ‚â´ (G : C ‚•§ C).map f = f ‚â´ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nf‚úù : Quiver.Hom A.A B.A\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f‚úù)) (CategoryTheory.CategoryStruct.comp f‚úù B.a)) _auto‚úù\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f)) (CategoryTheory.CategoryStruct.comp f B.a)) _auto‚úù\n‚ä¢ Eq (Eq { f := f‚úù, h := h‚úù } { f := f, h := h }) (Eq f‚úù f)","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ‚â´ (G : C ‚•§ C).map f = f ‚â´ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nf‚úù : Quiver.Hom A.A B.A\nh‚úù : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f‚úù)) (CategoryTheory.CategoryStruct.comp f‚úù B.a)) _auto‚úù\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f)) (CategoryTheory.CategoryStruct.comp f B.a)) _auto‚úù\nx‚úù : Eq { f := f‚úù, h := h‚úù } { f := f, h := h }\n‚ä¢ Eq f‚úù f","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ‚â´ (G : C ‚•§ C).map f = f ‚â´ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nx y : A.Hom B\n‚ä¢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ‚ü∂ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ‚â´ (G : C ‚•§ C).map f = f ‚â´ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.h_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nself : A.Hom B\nZ : C\nh : Quiver.Hom (G.obj B.A) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp A.a (CategoryTheory.CategoryStruct.comp (G.map self.f) h)) (CategoryTheory.CategoryStruct.comp self.f (CategoryTheory.CategoryStruct.comp B.a h))","decl":"attribute [reassoc (attr := simp)] Hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf g : Quiver.Hom X Y\n‚ä¢ Iff (Eq f g) (Eq f.f g.f)","decl":"@[ext]\nlemma Hom.ext' (X Y : Coalgebra G) (f g : X ‚ü∂ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext'","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf g : Quiver.Hom X Y\nh : Eq f.f g.f\n‚ä¢ Eq f g","decl":"@[ext]\nlemma Hom.ext' (X Y : Coalgebra G) (f g : X ‚ü∂ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.comp_eq_comp","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA A' A'' : G.Coalgebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n‚ä¢ Eq (CategoryTheory.Comonad.Coalgebra.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\ntheorem comp_eq_comp {A A' A'' : Coalgebra G} (f : A ‚ü∂ A') (g : A' ‚ü∂ A'') :\n    Coalgebra.Hom.comp f g = f ‚â´ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.id_eq_id","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA : G.Coalgebra\n‚ä¢ Eq (CategoryTheory.Comonad.Coalgebra.Hom.id A) (CategoryTheory.CategoryStruct.id A)","decl":"@[simp]\ntheorem id_eq_id (A : Coalgebra G) : Coalgebra.Hom.id A = ùüô A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.id_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA : G.Coalgebra\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id A).f (CategoryTheory.CategoryStruct.id A.A)","decl":"@[simp]\ntheorem id_f (A : Coalgebra G) : (ùüô A : A ‚ü∂ A).f = ùüô A.A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.comp_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA A' A'' : G.Coalgebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {A A' A'' : Coalgebra G} (f : A ‚ü∂ A') (g : A' ‚ü∂ A'') : (f ‚â´ g).f = f.f ‚â´ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.isoMk_inv_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map h.hom)) (CategoryTheory.CategoryStruct.comp h.hom B.a)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Comonad.Coalgebra.isoMk h w).inv.f h.inv","decl":"/--\nTo construct an isomorphism of coalgebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Coalgebra G} (h : A.A ‚âÖ B.A)\n    (w : A.a ‚â´ (G : C ‚•§ C).map h.hom = h.hom ‚â´ B.a := by aesop_cat) : A ‚âÖ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, ‚Üê reassoc_of% w, ‚Üê Functor.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.isoMk_hom_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map h.hom)) (CategoryTheory.CategoryStruct.comp h.hom B.a)) _auto‚úù\n‚ä¢ Eq (CategoryTheory.Comonad.Coalgebra.isoMk h w).hom.f h.hom","decl":"/--\nTo construct an isomorphism of coalgebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Coalgebra G} (h : A.A ‚âÖ B.A)\n    (w : A.a ‚â´ (G : C ‚•§ C).map h.hom = h.hom ‚â´ B.a := by aesop_cat) : A ‚âÖ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, ‚Üê reassoc_of% w, ‚Üê Functor.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.forget_obj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA : G.Coalgebra\n‚ä¢ Eq (G.forget.obj A) A.A","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the coalgebraic\nstructure. -/\n@[simps]\ndef forget : Coalgebra G ‚•§ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Comonad.forget_map","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX‚úù Y‚úù : G.Coalgebra\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (G.forget.map f) f.f","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the coalgebraic\nstructure. -/\n@[simps]\ndef forget : Coalgebra G ‚•§ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Comonad.cofree_obj_A","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq (G.cofree.obj X).A (G.obj X)","decl":"/-- The cofree functor from the Eilenberg-Moore category, constructing a coalgebra for any\nobject. -/\n@[simps]\ndef cofree : C ‚•§ Coalgebra G where\n  obj X :=\n    { A := G.obj X\n      a := G.Œ¥.app X\n      coassoc := (G.coassoc _).symm }\n  map f :=\n    { f := G.map f\n      h := (G.Œ¥.naturality _).symm }\n\n-- The other two `simps` projection lemmas can be derived from these two, so `simp_nf` complains if\n-- those are added too\n"}
{"name":"CategoryTheory.Comonad.cofree_map_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX‚úù Y‚úù : C\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (G.cofree.map f).f (G.map f)","decl":"/-- The cofree functor from the Eilenberg-Moore category, constructing a coalgebra for any\nobject. -/\n@[simps]\ndef cofree : C ‚•§ Coalgebra G where\n  obj X :=\n    { A := G.obj X\n      a := G.Œ¥.app X\n      coassoc := (G.coassoc _).symm }\n  map f :=\n    { f := G.map f\n      h := (G.Œ¥.naturality _).symm }\n\n-- The other two `simps` projection lemmas can be derived from these two, so `simp_nf` complains if\n-- those are added too\n"}
{"name":"CategoryTheory.Comonad.cofree_obj_a","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX : C\n‚ä¢ Eq (G.cofree.obj X).a (G.Œ¥.app X)","decl":"/-- The cofree functor from the Eilenberg-Moore category, constructing a coalgebra for any\nobject. -/\n@[simps]\ndef cofree : C ‚•§ Coalgebra G where\n  obj X :=\n    { A := G.obj X\n      a := G.Œ¥.app X\n      coassoc := (G.coassoc _).symm }\n  map f :=\n    { f := G.map f\n      h := (G.Œ¥.naturality _).symm }\n\n-- The other two `simps` projection lemmas can be derived from these two, so `simp_nf` complains if\n-- those are added too\n"}
{"name":"CategoryTheory.Comonad.adj_counit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ Eq G.adj.counit { app := fun Y => G.Œµ.app Y, naturality := ‚ãØ }","decl":"/-- The adjunction between the cofree and forgetful constructions for Eilenberg-Moore coalgebras\nfor a comonad.\n-/\n@[simps! unit counit]\ndef adj : G.forget ‚ä£ G.cofree :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f =>\n            { f := X.a ‚â´ G.map f\n              h := by\n                dsimp\n                simp [‚Üê Coalgebra.coassoc_assoc] }\n          invFun := fun g => g.f ‚â´ G.Œµ.app Y\n          left_inv := fun f => by\n            dsimp\n            rw [Category.assoc, G.Œµ.naturality, Functor.id_map, X.counit_assoc]\n          right_inv := fun g => by\n            ext1; dsimp\n            rw [Functor.map_comp, g.h_assoc, cofree_obj_a, Comonad.right_counit]\n            apply comp_id } }\n\n"}
{"name":"CategoryTheory.Comonad.adj_unit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ Eq G.adj.unit { app := fun X => { f := X.a, h := ‚ãØ }, naturality := ‚ãØ }","decl":"/-- The adjunction between the cofree and forgetful constructions for Eilenberg-Moore coalgebras\nfor a comonad.\n-/\n@[simps! unit counit]\ndef adj : G.forget ‚ä£ G.cofree :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f =>\n            { f := X.a ‚â´ G.map f\n              h := by\n                dsimp\n                simp [‚Üê Coalgebra.coassoc_assoc] }\n          invFun := fun g => g.f ‚â´ G.Œµ.app Y\n          left_inv := fun f => by\n            dsimp\n            rw [Category.assoc, G.Œµ.naturality, Functor.id_map, X.counit_assoc]\n          right_inv := fun g => by\n            ext1; dsimp\n            rw [Functor.map_comp, g.h_assoc, cofree_obj_a, Comonad.right_counit]\n            apply comp_id } }\n\n"}
{"name":"CategoryTheory.Comonad.coalgebra_iso_of_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nf : Quiver.Hom A B\ninst‚úù : CategoryTheory.IsIso f.f\n‚ä¢ CategoryTheory.IsIso f","decl":"/-- Given a coalgebra morphism whose carrier part is an isomorphism, we get a coalgebra isomorphism.\n-/\ntheorem coalgebra_iso_of_iso {A B : Coalgebra G} (f : A ‚ü∂ B) [IsIso f.f] : IsIso f :=\n  ‚ü®‚ü®{   f := inv f.f\n        h := by\n          rw [IsIso.eq_inv_comp f.f, ‚Üê f.h_assoc]\n          simp },\n      by aesop_cat‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Comonad.forget_reflects_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ G.forget.ReflectsIsomorphisms","decl":"instance forget_reflects_iso : G.forget.ReflectsIsomorphisms where\n  -- Porting note: Is this the right approach to introduce instances?\n  reflects {_ _} f := fun [IsIso f.f] => coalgebra_iso_of_iso G f\n\n"}
{"name":"CategoryTheory.Comonad.forget_faithful","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ G.forget.Faithful","decl":"instance forget_faithful : (forget G).Faithful where\n\n"}
{"name":"CategoryTheory.Comonad.algebra_epi_of_epi","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi f.f\n‚ä¢ CategoryTheory.Epi f","decl":"/-- Given a coalgebra morphism whose carrier part is an epimorphism, we get an algebra epimorphism.\n-/\ntheorem algebra_epi_of_epi {X Y : Coalgebra G} (f : X ‚ü∂ Y) [h : Epi f.f] : Epi f :=\n  (forget G).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.Comonad.algebra_mono_of_mono","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono f.f\n‚ä¢ CategoryTheory.Mono f","decl":"/-- Given a coalgebra morphism whose carrier part is a monomorphism, we get an algebra monomorphism.\n-/\ntheorem algebra_mono_of_mono {X Y : Coalgebra G} (f : X ‚ü∂ Y) [h : Mono f.f] : Mono f :=\n  (forget G).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Comonad.instIsLeftAdjointCoalgebraForget","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nG : CategoryTheory.Comonad C\n‚ä¢ G.forget.IsLeftAdjoint","decl":"instance : G.forget.IsLeftAdjoint  :=\n  ‚ü®_, ‚ü®G.adj‚ü©‚ü©\n\n"}
