{"name":"CategoryTheory.Monad.Algebra.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA✝ : C\na✝ : Quiver.Hom (T.obj A✝) A✝\nunit✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.η.app A✝) a✝) (CategoryTheory.CategoryStruct.id A✝)) _auto✝\nassoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.μ.app A✝) a✝) (CategoryTheory.CategoryStruct.comp (T.map a✝) a✝)) _auto✝\nA : C\na : Quiver.Hom (T.obj A) A\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.η.app A) a) (CategoryTheory.CategoryStruct.id A)) _auto✝\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.μ.app A) a) (CategoryTheory.CategoryStruct.comp (T.map a) a)) _auto✝\nx✝ : Eq { A := A✝, a := a✝, unit := unit✝, assoc := assoc✝ } { A := A, a := a, unit := unit, assoc := assoc }\n⊢ And (Eq A✝ A) (HEq a✝ a)","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ⥤ C).obj A ⟶ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.η.app A ≫ a = 𝟙 A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.μ.app A ≫ a = (T : C ⥤ C).map a ≫ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\ninst✝ : SizeOf C\nA : C\na : Quiver.Hom (T.obj A) A\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.η.app A) a) (CategoryTheory.CategoryStruct.id A)) _auto✝\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.μ.app A) a) (CategoryTheory.CategoryStruct.comp (T.map a) a)) _auto✝\n⊢ Eq (SizeOf.sizeOf { A := A, a := a, unit := unit, assoc := assoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf A)) (SizeOf.sizeOf a)) (SizeOf.sizeOf unit)) (SizeOf.sizeOf assoc))","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ⥤ C).obj A ⟶ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.η.app A ≫ a = 𝟙 A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.μ.app A ≫ a = (T : C ⥤ C).map a ≫ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA✝ : C\na✝ : Quiver.Hom (T.obj A✝) A✝\nunit✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.η.app A✝) a✝) (CategoryTheory.CategoryStruct.id A✝)) _auto✝\nassoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.μ.app A✝) a✝) (CategoryTheory.CategoryStruct.comp (T.map a✝) a✝)) _auto✝\nA : C\na : Quiver.Hom (T.obj A) A\nunit : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.η.app A) a) (CategoryTheory.CategoryStruct.id A)) _auto✝\nassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.μ.app A) a) (CategoryTheory.CategoryStruct.comp (T.map a) a)) _auto✝\n⊢ Eq (Eq { A := A✝, a := a✝, unit := unit✝, assoc := assoc✝ } { A := A, a := a, unit := unit, assoc := assoc }) (And (Eq A✝ A) (HEq a✝ a))","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ⥤ C).obj A ⟶ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.η.app A ≫ a = 𝟙 A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.μ.app A ≫ a = (T : C ⥤ C).map a ≫ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nself : T.Algebra\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.μ.app self.A) self.a) (CategoryTheory.CategoryStruct.comp (T.map self.a) self.a)","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ⥤ C).obj A ⟶ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.η.app A ≫ a = 𝟙 A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.μ.app A ≫ a = (T : C ⥤ C).map a ≫ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.unit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nself : T.Algebra\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.η.app self.A) self.a) (CategoryTheory.CategoryStruct.id self.A)","decl":"/-- An Eilenberg-Moore algebra for a monad `T`.\n    cf Definition 5.2.3 in [Riehl][riehl2017]. -/\nstructure Algebra (T : Monad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to an algebra. -/\n  A : C\n  /-- The structure morphism associated to an algebra. -/\n  a : (T : C ⥤ C).obj A ⟶ A\n  /-- The unit axiom associated to an algebra. -/\n  unit : T.η.app A ≫ a = 𝟙 A := by aesop_cat\n  /-- The associativity axiom associated to an algebra. -/\n  assoc : T.μ.app A ≫ a = (T : C ⥤ C).map a ≫ a := by aesop_cat\n\n"}
{"name":"CategoryTheory.Monad.Algebra.unit_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nself : T.Algebra\nZ : C\nh : Quiver.Hom self.A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.η.app self.A) (CategoryTheory.CategoryStruct.comp self.a h)) h","decl":"attribute [reassoc] Algebra.unit Algebra.assoc\n\n"}
{"name":"CategoryTheory.Monad.Algebra.assoc_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nself : T.Algebra\nZ : C\nh : Quiver.Hom self.A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.μ.app self.A) (CategoryTheory.CategoryStruct.comp self.a h)) (CategoryTheory.CategoryStruct.comp (T.map self.a) (CategoryTheory.CategoryStruct.comp self.a h))","decl":"attribute [reassoc] Algebra.unit Algebra.assoc\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nf✝ : Quiver.Hom A.A B.A\nh✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f✝) B.a) (CategoryTheory.CategoryStruct.comp A.a f✝)) _auto✝\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f) B.a) (CategoryTheory.CategoryStruct.comp A.a f)) _auto✝\nx✝ : Eq { f := f✝, h := h✝ } { f := f, h := h }\n⊢ Eq f✝ f","decl":"/-- A morphism of Eilenberg–Moore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ⥤ C).map f ≫ B.a = A.a ≫ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nx y : A.Hom B\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of Eilenberg–Moore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ⥤ C).map f ≫ B.a = A.a ≫ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nf✝ : Quiver.Hom A.A B.A\nh✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f✝) B.a) (CategoryTheory.CategoryStruct.comp A.a f✝)) _auto✝\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f) B.a) (CategoryTheory.CategoryStruct.comp A.a f)) _auto✝\n⊢ Eq (Eq { f := f✝, h := h✝ } { f := f, h := h }) (Eq f✝ f)","decl":"/-- A morphism of Eilenberg–Moore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ⥤ C).map f ≫ B.a = A.a ≫ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.h","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nself : A.Hom B\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.map self.f) B.a) (CategoryTheory.CategoryStruct.comp A.a self.f)","decl":"/-- A morphism of Eilenberg–Moore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ⥤ C).map f ≫ B.a = A.a ≫ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nx y : A.Hom B\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- A morphism of Eilenberg–Moore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ⥤ C).map f ≫ B.a = A.a ≫ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\ninst✝ : SizeOf C\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map f) B.a) (CategoryTheory.CategoryStruct.comp A.a f)) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, h := h }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf h))","decl":"/-- A morphism of Eilenberg–Moore algebras for the monad `T`. -/\n@[ext]\nstructure Hom (A B : Algebra T) where\n  /-- The underlying morphism associated to a morphism of algebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of algebras. -/\n  h : (T : C ⥤ C).map f ≫ B.a = A.a ≫ f := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.h_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nself : A.Hom B\nZ : C\nh : Quiver.Hom B.A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (T.map self.f) (CategoryTheory.CategoryStruct.comp B.a h)) (CategoryTheory.CategoryStruct.comp A.a (CategoryTheory.CategoryStruct.comp self.f h))","decl":"attribute [reassoc (attr := simp)] Hom.h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext'","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf g : Quiver.Hom X Y\nh : Eq f.f g.f\n⊢ Eq f g","decl":"@[ext]\nlemma Hom.ext' (X Y : Algebra T) (f g : X ⟶ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.Hom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.f g.f)","decl":"@[ext]\nlemma Hom.ext' (X Y : Algebra T) (f g : X ⟶ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Monad.Algebra.comp_eq_comp","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA A' A'' : T.Algebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n⊢ Eq (CategoryTheory.Monad.Algebra.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\ntheorem comp_eq_comp {A A' A'' : Algebra T} (f : A ⟶ A') (g : A' ⟶ A'') :\n    Algebra.Hom.comp f g = f ≫ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.id_eq_id","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA : T.Algebra\n⊢ Eq (CategoryTheory.Monad.Algebra.Hom.id A) (CategoryTheory.CategoryStruct.id A)","decl":"@[simp]\ntheorem id_eq_id (A : Algebra T) : Algebra.Hom.id A = 𝟙 A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.id_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA : T.Algebra\n⊢ Eq (CategoryTheory.CategoryStruct.id A).f (CategoryTheory.CategoryStruct.id A.A)","decl":"@[simp]\ntheorem id_f (A : Algebra T) : (𝟙 A : A ⟶ A).f = 𝟙 A.A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.comp_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA A' A'' : T.Algebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {A A' A'' : Algebra T} (f : A ⟶ A') (g : A' ⟶ A'') : (f ≫ g).f = f.f ≫ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Monad.Algebra.isoMk_inv_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map h.hom) B.a) (CategoryTheory.CategoryStruct.comp A.a h.hom)) _auto✝\n⊢ Eq (CategoryTheory.Monad.Algebra.isoMk h w).inv.f h.inv","decl":"/--\nTo construct an isomorphism of algebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Algebra T} (h : A.A ≅ B.A)\n    (w : (T : C ⥤ C).map h.hom ≫ B.a = A.a ≫ h.hom := by aesop_cat) : A ≅ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, ← w, ← Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.Monad.Algebra.isoMk_hom_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (T.map h.hom) B.a) (CategoryTheory.CategoryStruct.comp A.a h.hom)) _auto✝\n⊢ Eq (CategoryTheory.Monad.Algebra.isoMk h w).hom.f h.hom","decl":"/--\nTo construct an isomorphism of algebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Algebra T} (h : A.A ≅ B.A)\n    (w : (T : C ⥤ C).map h.hom ≫ B.a = A.a ≫ h.hom := by aesop_cat) : A ≅ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_comp_inv, Category.assoc, ← w, ← Functor.map_comp_assoc]\n        simp }\n\n"}
{"name":"CategoryTheory.Monad.forget_map","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX✝ Y✝ : T.Algebra\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (T.forget.map f) f.f","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the algebraic structure. -/\n@[simps]\ndef forget : Algebra T ⥤ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Monad.forget_obj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA : T.Algebra\n⊢ Eq (T.forget.obj A) A.A","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the algebraic structure. -/\n@[simps]\ndef forget : Algebra T ⥤ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Monad.free_obj_a","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : C\n⊢ Eq (T.free.obj X).a (T.μ.app X)","decl":"/-- The free functor from the Eilenberg-Moore category, constructing an algebra for any object. -/\n@[simps]\ndef free : C ⥤ Algebra T where\n  obj X :=\n    { A := T.obj X\n      a := T.μ.app X\n      assoc := (T.assoc _).symm }\n  map f :=\n    { f := T.map f\n      h := T.μ.naturality _ }\n\n"}
{"name":"CategoryTheory.Monad.free_obj_A","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX : C\n⊢ Eq (T.free.obj X).A (T.obj X)","decl":"/-- The free functor from the Eilenberg-Moore category, constructing an algebra for any object. -/\n@[simps]\ndef free : C ⥤ Algebra T where\n  obj X :=\n    { A := T.obj X\n      a := T.μ.app X\n      assoc := (T.assoc _).symm }\n  map f :=\n    { f := T.map f\n      h := T.μ.naturality _ }\n\n"}
{"name":"CategoryTheory.Monad.free_map_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (T.free.map f).f (T.map f)","decl":"/-- The free functor from the Eilenberg-Moore category, constructing an algebra for any object. -/\n@[simps]\ndef free : C ⥤ Algebra T where\n  obj X :=\n    { A := T.obj X\n      a := T.μ.app X\n      assoc := (T.assoc _).symm }\n  map f :=\n    { f := T.map f\n      h := T.μ.naturality _ }\n\n"}
{"name":"CategoryTheory.Monad.adj_counit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ Eq T.adj.counit { app := fun Y => { f := Y.a, h := ⋯ }, naturality := ⋯ }","decl":"/-- The adjunction between the free and forgetful constructions for Eilenberg-Moore algebras for\n  a monad. cf Lemma 5.2.8 of [Riehl][riehl2017]. -/\n@[simps! unit counit]\ndef adj : T.free ⊣ T.forget :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => T.η.app X ≫ f.f\n          invFun := fun f =>\n            { f := T.map f ≫ Y.a\n              h := by\n                dsimp\n                simp [← Y.assoc, ← T.μ.naturality_assoc] }\n          left_inv := fun f => by\n            ext\n            dsimp\n            simp\n          right_inv := fun f => by\n            dsimp only [forget_obj]\n            rw [← T.η.naturality_assoc, Y.unit]\n            apply Category.comp_id } }\n\n"}
{"name":"CategoryTheory.Monad.adj_unit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ Eq T.adj.unit { app := fun X => T.η.app X, naturality := ⋯ }","decl":"/-- The adjunction between the free and forgetful constructions for Eilenberg-Moore algebras for\n  a monad. cf Lemma 5.2.8 of [Riehl][riehl2017]. -/\n@[simps! unit counit]\ndef adj : T.free ⊣ T.forget :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f => T.η.app X ≫ f.f\n          invFun := fun f =>\n            { f := T.map f ≫ Y.a\n              h := by\n                dsimp\n                simp [← Y.assoc, ← T.μ.naturality_assoc] }\n          left_inv := fun f => by\n            ext\n            dsimp\n            simp\n          right_inv := fun f => by\n            dsimp only [forget_obj]\n            rw [← T.η.naturality_assoc, Y.unit]\n            apply Category.comp_id } }\n\n"}
{"name":"CategoryTheory.Monad.algebra_iso_of_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nA B : T.Algebra\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso f.f\n⊢ CategoryTheory.IsIso f","decl":"/-- Given an algebra morphism whose carrier part is an isomorphism, we get an algebra isomorphism.\n-/\ntheorem algebra_iso_of_iso {A B : Algebra T} (f : A ⟶ B) [IsIso f.f] : IsIso f :=\n  ⟨⟨{   f := inv f.f\n        h := by\n          rw [IsIso.eq_comp_inv f.f, Category.assoc, ← f.h]\n          simp },\n      by aesop_cat⟩⟩\n\n"}
{"name":"CategoryTheory.Monad.forget_reflects_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ T.forget.ReflectsIsomorphisms","decl":"instance forget_reflects_iso : T.forget.ReflectsIsomorphisms where\n  -- Porting note: Is this the right approach to introduce instances?\n  reflects {_ _} f := fun [IsIso f.f] => algebra_iso_of_iso T f\n\n"}
{"name":"CategoryTheory.Monad.forget_faithful","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ T.forget.Faithful","decl":"instance forget_faithful : T.forget.Faithful where\n\n"}
{"name":"CategoryTheory.Monad.algebra_epi_of_epi","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi f.f\n⊢ CategoryTheory.Epi f","decl":"/-- Given an algebra morphism whose carrier part is an epimorphism, we get an algebra epimorphism.\n-/\ntheorem algebra_epi_of_epi {X Y : Algebra T} (f : X ⟶ Y) [h : Epi f.f] : Epi f :=\n  (forget T).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.Monad.algebra_mono_of_mono","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\nX Y : T.Algebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono f.f\n⊢ CategoryTheory.Mono f","decl":"/-- Given an algebra morphism whose carrier part is a monomorphism, we get an algebra monomorphism.\n-/\ntheorem algebra_mono_of_mono {X Y : Algebra T} (f : X ⟶ Y) [h : Mono f.f] : Mono f :=\n  (forget T).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Monad.instIsRightAdjointAlgebraForget","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : CategoryTheory.Monad C\n⊢ T.forget.IsRightAdjoint","decl":"instance : T.forget.IsRightAdjoint  :=\n  ⟨T.free, ⟨T.adj⟩⟩\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHom_obj_A","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : Quiver.Hom T₂ T₁\nA : T₁.Algebra\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).obj A).A A.A","decl":"/--\nGiven a monad morphism from `T₂` to `T₁`, we get a functor from the algebras of `T₁` to algebras of\n`T₂`.\n-/\n@[simps]\ndef algebraFunctorOfMonadHom {T₁ T₂ : Monad C} (h : T₂ ⟶ T₁) : Algebra T₁ ⥤ Algebra T₂ where\n  obj A :=\n    { A := A.A\n      a := h.app A.A ≫ A.a\n      unit := by\n        dsimp\n        simp [A.unit]\n      assoc := by\n        dsimp\n        simp [A.assoc] }\n  map f := { f := f.f }\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHom_map_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : Quiver.Hom T₂ T₁\nX✝ Y✝ : T₁.Algebra\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).map f).f f.f","decl":"/--\nGiven a monad morphism from `T₂` to `T₁`, we get a functor from the algebras of `T₁` to algebras of\n`T₂`.\n-/\n@[simps]\ndef algebraFunctorOfMonadHom {T₁ T₂ : Monad C} (h : T₂ ⟶ T₁) : Algebra T₁ ⥤ Algebra T₂ where\n  obj A :=\n    { A := A.A\n      a := h.app A.A ≫ A.a\n      unit := by\n        dsimp\n        simp [A.unit]\n      assoc := by\n        dsimp\n        simp [A.assoc] }\n  map f := { f := f.f }\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHom_obj_a","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : Quiver.Hom T₂ T₁\nA : T₁.Algebra\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).obj A).a (CategoryTheory.CategoryStruct.comp (h.app A.A) A.a)","decl":"/--\nGiven a monad morphism from `T₂` to `T₁`, we get a functor from the algebras of `T₁` to algebras of\n`T₂`.\n-/\n@[simps]\ndef algebraFunctorOfMonadHom {T₁ T₂ : Monad C} (h : T₂ ⟶ T₁) : Algebra T₁ ⥤ Algebra T₂ where\n  obj A :=\n    { A := A.A\n      a := h.app A.A ≫ A.a\n      unit := by\n        dsimp\n        simp [A.unit]\n      assoc := by\n        dsimp\n        simp [A.assoc] }\n  map f := { f := f.f }\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomId_hom_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ : CategoryTheory.Monad C\nX : T₁.Algebra\n⊢ Eq (CategoryTheory.Monad.algebraFunctorOfMonadHomId.hom.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.id T₁)).obj X).A).hom","decl":"/--\nThe identity monad morphism induces the identity functor from the category of algebras to itself.\n-/\n-- Porting note: `semireducible -> default`\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomId {T₁ : Monad C} : algebraFunctorOfMonadHom (𝟙 T₁) ≅ 𝟭 _ :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomId_inv_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ : CategoryTheory.Monad C\nX : T₁.Algebra\n⊢ Eq (CategoryTheory.Monad.algebraFunctorOfMonadHomId.inv.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.id T₁)).obj X).A).inv","decl":"/--\nThe identity monad morphism induces the identity functor from the category of algebras to itself.\n-/\n-- Porting note: `semireducible -> default`\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomId {T₁ : Monad C} : algebraFunctorOfMonadHom (𝟙 T₁) ≅ 𝟭 _ :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomComp_hom_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ T₃ : CategoryTheory.Monad C\nf : Quiver.Hom T₁ T₂\ng : Quiver.Hom T₂ T₃\nX : T₃.Algebra\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomComp f g).hom.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.comp f g)).obj X).A).hom","decl":"/-- A composition of monad morphisms gives the composition of corresponding functors.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomComp {T₁ T₂ T₃ : Monad C} (f : T₁ ⟶ T₂) (g : T₂ ⟶ T₃) :\n    algebraFunctorOfMonadHom (f ≫ g) ≅ algebraFunctorOfMonadHom g ⋙ algebraFunctorOfMonadHom f :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomComp_inv_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ T₃ : CategoryTheory.Monad C\nf : Quiver.Hom T₁ T₂\ng : Quiver.Hom T₂ T₃\nX : T₃.Algebra\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomComp f g).inv.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom (CategoryTheory.CategoryStruct.comp f g)).obj X).A).inv","decl":"/-- A composition of monad morphisms gives the composition of corresponding functors.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomComp {T₁ T₂ T₃ : Monad C} (f : T₁ ⟶ T₂) (g : T₂ ⟶ T₃) :\n    algebraFunctorOfMonadHom (f ≫ g) ≅ algebraFunctorOfMonadHom g ⋙ algebraFunctorOfMonadHom f :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomEq_inv_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nf g : Quiver.Hom T₁ T₂\nh : Eq f g\nX : T₂.Algebra\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq h).inv.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom f).obj X).A).inv","decl":"/-- If `f` and `g` are two equal morphisms of monads, then the functors of algebras induced by them\nare isomorphic.\nWe define it like this as opposed to using `eqToIso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomEq {T₁ T₂ : Monad C} {f g : T₁ ⟶ T₂} (h : f = g) :\n    algebraFunctorOfMonadHom f ≅ algebraFunctorOfMonadHom g :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraFunctorOfMonadHomEq_hom_app_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nf g : Quiver.Hom T₁ T₂\nh : Eq f g\nX : T₂.Algebra\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq h).hom.app X).f (CategoryTheory.Iso.refl ((CategoryTheory.Monad.algebraFunctorOfMonadHom f).obj X).A).hom","decl":"/-- If `f` and `g` are two equal morphisms of monads, then the functors of algebras induced by them\nare isomorphic.\nWe define it like this as opposed to using `eqToIso` so that the components are nicer to prove\nlemmas about.\n-/\n@[simps (config := { rhsMd := .default })]\ndef algebraFunctorOfMonadHomEq {T₁ T₂ : Monad C} {f g : T₁ ⟶ T₂} (h : f = g) :\n    algebraFunctorOfMonadHom f ≅ algebraFunctorOfMonadHom g :=\n  NatIso.ofComponents fun X => Algebra.isoMk (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_unitIso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T₁ T₂\n⊢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).unitIso (CategoryTheory.Monad.algebraFunctorOfMonadHomId.symm.trans ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq ⋯).trans (CategoryTheory.Monad.algebraFunctorOfMonadHomComp h.hom h.inv)))","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ⋙ forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T₁ T₂ : Monad C} (h : T₁ ≅ T₂) : Algebra T₁ ≌ Algebra T₂ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_counitIso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T₁ T₂\n⊢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).counitIso ((CategoryTheory.Monad.algebraFunctorOfMonadHomComp h.inv h.hom).symm.trans ((CategoryTheory.Monad.algebraFunctorOfMonadHomEq ⋯).trans CategoryTheory.Monad.algebraFunctorOfMonadHomId))","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ⋙ forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T₁ T₂ : Monad C} (h : T₁ ≅ T₂) : Algebra T₁ ≌ Algebra T₂ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_inverse","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T₁ T₂\n⊢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).inverse (CategoryTheory.Monad.algebraFunctorOfMonadHom h.hom)","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ⋙ forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T₁ T₂ : Monad C} (h : T₁ ≅ T₂) : Algebra T₁ ≌ Algebra T₂ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebraEquivOfIsoMonads_functor","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : CategoryTheory.Iso T₁ T₂\n⊢ Eq (CategoryTheory.Monad.algebraEquivOfIsoMonads h).functor (CategoryTheory.Monad.algebraFunctorOfMonadHom h.inv)","decl":"/-- Isomorphic monads give equivalent categories of algebras. Furthermore, they are equivalent as\ncategories over `C`, that is, we have `algebraEquivOfIsoMonads h ⋙ forget = forget`.\n-/\n@[simps]\ndef algebraEquivOfIsoMonads {T₁ T₂ : Monad C} (h : T₁ ≅ T₂) : Algebra T₁ ≌ Algebra T₂ where\n  functor := algebraFunctorOfMonadHom h.inv\n  inverse := algebraFunctorOfMonadHom h.hom\n  unitIso :=\n    algebraFunctorOfMonadHomId.symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomComp _ _\n  counitIso :=\n    (algebraFunctorOfMonadHomComp _ _).symm ≪≫\n      algebraFunctorOfMonadHomEq (by simp) ≪≫ algebraFunctorOfMonadHomId\n\n"}
{"name":"CategoryTheory.Monad.algebra_equiv_of_iso_monads_comp_forget","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT₁ T₂ : CategoryTheory.Monad C\nh : Quiver.Hom T₁ T₂\n⊢ Eq ((CategoryTheory.Monad.algebraFunctorOfMonadHom h).comp T₁.forget) T₂.forget","decl":"@[simp]\ntheorem algebra_equiv_of_iso_monads_comp_forget {T₁ T₂ : Monad C} (h : T₁ ⟶ T₂) :\n    algebraFunctorOfMonadHom h ⋙ forget _ = forget _ :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA✝ : C\na✝ : Quiver.Hom A✝ (G.obj A✝)\ncounit✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp a✝ (G.ε.app A✝)) (CategoryTheory.CategoryStruct.id A✝)) _auto✝\ncoassoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp a✝ (G.δ.app A✝)) (CategoryTheory.CategoryStruct.comp a✝ (G.map a✝))) _auto✝\nA : C\na : Quiver.Hom A (G.obj A)\ncounit : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.ε.app A)) (CategoryTheory.CategoryStruct.id A)) _auto✝\ncoassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.δ.app A)) (CategoryTheory.CategoryStruct.comp a (G.map a))) _auto✝\n⊢ Eq (Eq { A := A✝, a := a✝, counit := counit✝, coassoc := coassoc✝ } { A := A, a := a, counit := counit, coassoc := coassoc }) (And (Eq A✝ A) (HEq a✝ a))","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ⟶ (G : C ⥤ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ≫ G.ε.app A = 𝟙 A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ≫ G.δ.app A = a ≫ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA✝ : C\na✝ : Quiver.Hom A✝ (G.obj A✝)\ncounit✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp a✝ (G.ε.app A✝)) (CategoryTheory.CategoryStruct.id A✝)) _auto✝\ncoassoc✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp a✝ (G.δ.app A✝)) (CategoryTheory.CategoryStruct.comp a✝ (G.map a✝))) _auto✝\nA : C\na : Quiver.Hom A (G.obj A)\ncounit : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.ε.app A)) (CategoryTheory.CategoryStruct.id A)) _auto✝\ncoassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.δ.app A)) (CategoryTheory.CategoryStruct.comp a (G.map a))) _auto✝\nx✝ : Eq { A := A✝, a := a✝, counit := counit✝, coassoc := coassoc✝ } { A := A, a := a, counit := counit, coassoc := coassoc }\n⊢ And (Eq A✝ A) (HEq a✝ a)","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ⟶ (G : C ⥤ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ≫ G.ε.app A = 𝟙 A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ≫ G.δ.app A = a ≫ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.coassoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.a (G.δ.app self.A)) (CategoryTheory.CategoryStruct.comp self.a (G.map self.a))","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ⟶ (G : C ⥤ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ≫ G.ε.app A = 𝟙 A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ≫ G.δ.app A = a ≫ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\ninst✝ : SizeOf C\nA : C\na : Quiver.Hom A (G.obj A)\ncounit : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.ε.app A)) (CategoryTheory.CategoryStruct.id A)) _auto✝\ncoassoc : autoParam (Eq (CategoryTheory.CategoryStruct.comp a (G.δ.app A)) (CategoryTheory.CategoryStruct.comp a (G.map a))) _auto✝\n⊢ Eq (SizeOf.sizeOf { A := A, a := a, counit := counit, coassoc := coassoc }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf A)) (SizeOf.sizeOf a)) (SizeOf.sizeOf counit)) (SizeOf.sizeOf coassoc))","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ⟶ (G : C ⥤ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ≫ G.ε.app A = 𝟙 A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ≫ G.δ.app A = a ≫ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.counit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.a (G.ε.app self.A)) (CategoryTheory.CategoryStruct.id self.A)","decl":"/-- An Eilenberg-Moore coalgebra for a comonad `T`. -/\nstructure Coalgebra (G : Comonad C) : Type max u₁ v₁ where\n  /-- The underlying object associated to a coalgebra. -/\n  A : C\n  /-- The structure morphism associated to a coalgebra. -/\n  a : A ⟶ (G : C ⥤ C).obj A\n  /-- The counit axiom associated to a coalgebra. -/\n  counit : a ≫ G.ε.app A = 𝟙 A := by aesop_cat\n  /-- The coassociativity axiom associated to a coalgebra. -/\n  coassoc : a ≫ G.δ.app A = a ≫ G.map a := by aesop_cat\n\n\n-- Porting note: no need to restate axioms in lean4.\n\n--restate_axiom coalgebra.counit'\n\n--restate_axiom coalgebra.coassoc'\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.coassoc_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\nZ : C\nh : Quiver.Hom (G.obj (G.obj self.A)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.a (CategoryTheory.CategoryStruct.comp (G.δ.app self.A) h)) (CategoryTheory.CategoryStruct.comp self.a (CategoryTheory.CategoryStruct.comp (G.map self.a) h))","decl":"attribute [reassoc] Coalgebra.counit Coalgebra.coassoc\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.counit_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nself : G.Coalgebra\nZ : C\nh : Quiver.Hom self.A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.a (CategoryTheory.CategoryStruct.comp (G.ε.app self.A) h)) h","decl":"attribute [reassoc] Coalgebra.counit Coalgebra.coassoc\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\ninst✝ : SizeOf C\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f)) (CategoryTheory.CategoryStruct.comp f B.a)) _auto✝\n⊢ Eq (SizeOf.sizeOf { f := f, h := h }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf f)) (SizeOf.sizeOf h))","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ≫ (G : C ⥤ C).map f = f ≫ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nx y : A.Hom B\nf : Eq x.f y.f\n⊢ Eq x y","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ≫ (G : C ⥤ C).map f = f ≫ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.h","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nself : A.Hom B\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.a (G.map self.f)) (CategoryTheory.CategoryStruct.comp self.f B.a)","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ≫ (G : C ⥤ C).map f = f ≫ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nf✝ : Quiver.Hom A.A B.A\nh✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f✝)) (CategoryTheory.CategoryStruct.comp f✝ B.a)) _auto✝\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f)) (CategoryTheory.CategoryStruct.comp f B.a)) _auto✝\n⊢ Eq (Eq { f := f✝, h := h✝ } { f := f, h := h }) (Eq f✝ f)","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ≫ (G : C ⥤ C).map f = f ≫ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.mk.inj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nf✝ : Quiver.Hom A.A B.A\nh✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f✝)) (CategoryTheory.CategoryStruct.comp f✝ B.a)) _auto✝\nf : Quiver.Hom A.A B.A\nh : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map f)) (CategoryTheory.CategoryStruct.comp f B.a)) _auto✝\nx✝ : Eq { f := f✝, h := h✝ } { f := f, h := h }\n⊢ Eq f✝ f","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ≫ (G : C ⥤ C).map f = f ≫ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nx y : A.Hom B\n⊢ Iff (Eq x y) (Eq x.f y.f)","decl":"/-- A morphism of Eilenberg-Moore coalgebras for the comonad `G`. -/\n@[ext]\nstructure Hom (A B : Coalgebra G) where\n  /-- The underlying morphism associated to a morphism of coalgebras. -/\n  f : A.A ⟶ B.A\n  /-- Compatibility with the structure morphism, for a morphism of coalgebras. -/\n  h : A.a ≫ (G : C ⥤ C).map f = f ≫ B.a := by aesop_cat\n\n-- Porting note: no need to restate axioms in lean4.\n--restate_axiom hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.h_assoc","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nself : A.Hom B\nZ : C\nh : Quiver.Hom (G.obj B.A) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp A.a (CategoryTheory.CategoryStruct.comp (G.map self.f) h)) (CategoryTheory.CategoryStruct.comp self.f (CategoryTheory.CategoryStruct.comp B.a h))","decl":"attribute [reassoc (attr := simp)] Hom.h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext'_iff","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf g : Quiver.Hom X Y\n⊢ Iff (Eq f g) (Eq f.f g.f)","decl":"@[ext]\nlemma Hom.ext' (X Y : Coalgebra G) (f g : X ⟶ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.Hom.ext'","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf g : Quiver.Hom X Y\nh : Eq f.f g.f\n⊢ Eq f g","decl":"@[ext]\nlemma Hom.ext' (X Y : Coalgebra G) (f g : X ⟶ Y) (h : f.f = g.f) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.comp_eq_comp","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA A' A'' : G.Coalgebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n⊢ Eq (CategoryTheory.Comonad.Coalgebra.Hom.comp f g) (CategoryTheory.CategoryStruct.comp f g)","decl":"@[simp]\ntheorem comp_eq_comp {A A' A'' : Coalgebra G} (f : A ⟶ A') (g : A' ⟶ A'') :\n    Coalgebra.Hom.comp f g = f ≫ g :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.id_eq_id","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA : G.Coalgebra\n⊢ Eq (CategoryTheory.Comonad.Coalgebra.Hom.id A) (CategoryTheory.CategoryStruct.id A)","decl":"@[simp]\ntheorem id_eq_id (A : Coalgebra G) : Coalgebra.Hom.id A = 𝟙 A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.id_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA : G.Coalgebra\n⊢ Eq (CategoryTheory.CategoryStruct.id A).f (CategoryTheory.CategoryStruct.id A.A)","decl":"@[simp]\ntheorem id_f (A : Coalgebra G) : (𝟙 A : A ⟶ A).f = 𝟙 A.A :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.comp_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA A' A'' : G.Coalgebra\nf : Quiver.Hom A A'\ng : Quiver.Hom A' A''\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).f (CategoryTheory.CategoryStruct.comp f.f g.f)","decl":"@[simp]\ntheorem comp_f {A A' A'' : Coalgebra G} (f : A ⟶ A') (g : A' ⟶ A'') : (f ≫ g).f = f.f ≫ g.f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.isoMk_inv_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map h.hom)) (CategoryTheory.CategoryStruct.comp h.hom B.a)) _auto✝\n⊢ Eq (CategoryTheory.Comonad.Coalgebra.isoMk h w).inv.f h.inv","decl":"/--\nTo construct an isomorphism of coalgebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Coalgebra G} (h : A.A ≅ B.A)\n    (w : A.a ≫ (G : C ⥤ C).map h.hom = h.hom ≫ B.a := by aesop_cat) : A ≅ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, ← reassoc_of% w, ← Functor.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.Coalgebra.isoMk_hom_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nh : CategoryTheory.Iso A.A B.A\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp A.a (G.map h.hom)) (CategoryTheory.CategoryStruct.comp h.hom B.a)) _auto✝\n⊢ Eq (CategoryTheory.Comonad.Coalgebra.isoMk h w).hom.f h.hom","decl":"/--\nTo construct an isomorphism of coalgebras, it suffices to give an isomorphism of the carriers which\ncommutes with the structure morphisms.\n-/\n@[simps]\ndef isoMk {A B : Coalgebra G} (h : A.A ≅ B.A)\n    (w : A.a ≫ (G : C ⥤ C).map h.hom = h.hom ≫ B.a := by aesop_cat) : A ≅ B where\n  hom := { f := h.hom }\n  inv :=\n    { f := h.inv\n      h := by\n        rw [h.eq_inv_comp, ← reassoc_of% w, ← Functor.map_comp]\n        simp }\n\n"}
{"name":"CategoryTheory.Comonad.forget_obj","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA : G.Coalgebra\n⊢ Eq (G.forget.obj A) A.A","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the coalgebraic\nstructure. -/\n@[simps]\ndef forget : Coalgebra G ⥤ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Comonad.forget_map","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX✝ Y✝ : G.Coalgebra\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (G.forget.map f) f.f","decl":"/-- The forgetful functor from the Eilenberg-Moore category, forgetting the coalgebraic\nstructure. -/\n@[simps]\ndef forget : Coalgebra G ⥤ C where\n  obj A := A.A\n  map f := f.f\n\n"}
{"name":"CategoryTheory.Comonad.cofree_obj_A","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX : C\n⊢ Eq (G.cofree.obj X).A (G.obj X)","decl":"/-- The cofree functor from the Eilenberg-Moore category, constructing a coalgebra for any\nobject. -/\n@[simps]\ndef cofree : C ⥤ Coalgebra G where\n  obj X :=\n    { A := G.obj X\n      a := G.δ.app X\n      coassoc := (G.coassoc _).symm }\n  map f :=\n    { f := G.map f\n      h := (G.δ.naturality _).symm }\n\n-- The other two `simps` projection lemmas can be derived from these two, so `simp_nf` complains if\n-- those are added too\n"}
{"name":"CategoryTheory.Comonad.cofree_map_f","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (G.cofree.map f).f (G.map f)","decl":"/-- The cofree functor from the Eilenberg-Moore category, constructing a coalgebra for any\nobject. -/\n@[simps]\ndef cofree : C ⥤ Coalgebra G where\n  obj X :=\n    { A := G.obj X\n      a := G.δ.app X\n      coassoc := (G.coassoc _).symm }\n  map f :=\n    { f := G.map f\n      h := (G.δ.naturality _).symm }\n\n-- The other two `simps` projection lemmas can be derived from these two, so `simp_nf` complains if\n-- those are added too\n"}
{"name":"CategoryTheory.Comonad.cofree_obj_a","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX : C\n⊢ Eq (G.cofree.obj X).a (G.δ.app X)","decl":"/-- The cofree functor from the Eilenberg-Moore category, constructing a coalgebra for any\nobject. -/\n@[simps]\ndef cofree : C ⥤ Coalgebra G where\n  obj X :=\n    { A := G.obj X\n      a := G.δ.app X\n      coassoc := (G.coassoc _).symm }\n  map f :=\n    { f := G.map f\n      h := (G.δ.naturality _).symm }\n\n-- The other two `simps` projection lemmas can be derived from these two, so `simp_nf` complains if\n-- those are added too\n"}
{"name":"CategoryTheory.Comonad.adj_counit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\n⊢ Eq G.adj.counit { app := fun Y => G.ε.app Y, naturality := ⋯ }","decl":"/-- The adjunction between the cofree and forgetful constructions for Eilenberg-Moore coalgebras\nfor a comonad.\n-/\n@[simps! unit counit]\ndef adj : G.forget ⊣ G.cofree :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f =>\n            { f := X.a ≫ G.map f\n              h := by\n                dsimp\n                simp [← Coalgebra.coassoc_assoc] }\n          invFun := fun g => g.f ≫ G.ε.app Y\n          left_inv := fun f => by\n            dsimp\n            rw [Category.assoc, G.ε.naturality, Functor.id_map, X.counit_assoc]\n          right_inv := fun g => by\n            ext1; dsimp\n            rw [Functor.map_comp, g.h_assoc, cofree_obj_a, Comonad.right_counit]\n            apply comp_id } }\n\n"}
{"name":"CategoryTheory.Comonad.adj_unit","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\n⊢ Eq G.adj.unit { app := fun X => { f := X.a, h := ⋯ }, naturality := ⋯ }","decl":"/-- The adjunction between the cofree and forgetful constructions for Eilenberg-Moore coalgebras\nfor a comonad.\n-/\n@[simps! unit counit]\ndef adj : G.forget ⊣ G.cofree :=\n  Adjunction.mkOfHomEquiv\n    { homEquiv := fun X Y =>\n        { toFun := fun f =>\n            { f := X.a ≫ G.map f\n              h := by\n                dsimp\n                simp [← Coalgebra.coassoc_assoc] }\n          invFun := fun g => g.f ≫ G.ε.app Y\n          left_inv := fun f => by\n            dsimp\n            rw [Category.assoc, G.ε.naturality, Functor.id_map, X.counit_assoc]\n          right_inv := fun g => by\n            ext1; dsimp\n            rw [Functor.map_comp, g.h_assoc, cofree_obj_a, Comonad.right_counit]\n            apply comp_id } }\n\n"}
{"name":"CategoryTheory.Comonad.coalgebra_iso_of_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nA B : G.Coalgebra\nf : Quiver.Hom A B\ninst✝ : CategoryTheory.IsIso f.f\n⊢ CategoryTheory.IsIso f","decl":"/-- Given a coalgebra morphism whose carrier part is an isomorphism, we get a coalgebra isomorphism.\n-/\ntheorem coalgebra_iso_of_iso {A B : Coalgebra G} (f : A ⟶ B) [IsIso f.f] : IsIso f :=\n  ⟨⟨{   f := inv f.f\n        h := by\n          rw [IsIso.eq_inv_comp f.f, ← f.h_assoc]\n          simp },\n      by aesop_cat⟩⟩\n\n"}
{"name":"CategoryTheory.Comonad.forget_reflects_iso","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\n⊢ G.forget.ReflectsIsomorphisms","decl":"instance forget_reflects_iso : G.forget.ReflectsIsomorphisms where\n  -- Porting note: Is this the right approach to introduce instances?\n  reflects {_ _} f := fun [IsIso f.f] => coalgebra_iso_of_iso G f\n\n"}
{"name":"CategoryTheory.Comonad.forget_faithful","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\n⊢ G.forget.Faithful","decl":"instance forget_faithful : (forget G).Faithful where\n\n"}
{"name":"CategoryTheory.Comonad.algebra_epi_of_epi","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Epi f.f\n⊢ CategoryTheory.Epi f","decl":"/-- Given a coalgebra morphism whose carrier part is an epimorphism, we get an algebra epimorphism.\n-/\ntheorem algebra_epi_of_epi {X Y : Coalgebra G} (f : X ⟶ Y) [h : Epi f.f] : Epi f :=\n  (forget G).epi_of_epi_map h\n\n"}
{"name":"CategoryTheory.Comonad.algebra_mono_of_mono","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\nX Y : G.Coalgebra\nf : Quiver.Hom X Y\nh : CategoryTheory.Mono f.f\n⊢ CategoryTheory.Mono f","decl":"/-- Given a coalgebra morphism whose carrier part is a monomorphism, we get an algebra monomorphism.\n-/\ntheorem algebra_mono_of_mono {X Y : Coalgebra G} (f : X ⟶ Y) [h : Mono f.f] : Mono f :=\n  (forget G).mono_of_mono_map h\n\n"}
{"name":"CategoryTheory.Comonad.instIsLeftAdjointCoalgebraForget","module":"Mathlib.CategoryTheory.Monad.Algebra","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nG : CategoryTheory.Comonad C\n⊢ G.forget.IsLeftAdjoint","decl":"instance : G.forget.IsLeftAdjoint  :=\n  ⟨_, ⟨G.adj⟩⟩\n\n"}
