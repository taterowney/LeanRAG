{"name":"MonoidAlgebra.mem_ideal_span_of_image","module":"Mathlib.Algebra.MonoidAlgebra.Ideal","initialProofState":"k : Type u_1\nG : Type u_3\ninst✝¹ : Monoid G\ninst✝ : Semiring k\ns : Set G\nx : MonoidAlgebra k G\n⊢ Iff (Membership.mem (Ideal.span (Set.image (⇑(MonoidAlgebra.of k G)) s)) x) (∀ (m : G), Membership.mem x.support m → Exists fun m' => And (Membership.mem s m') (Exists fun d => Eq m (HMul.hMul d m')))","decl":"/-- If `x` belongs to the ideal generated by generators in `s`, then every element of the support of\n`x` factors through an element of `s`.\n\nWe could spell `∃ d, m = d * m` as `MulOpposite.op m' ∣ MulOpposite.op m` but this would be worse.\n-/\ntheorem MonoidAlgebra.mem_ideal_span_of_image [Monoid G] [Semiring k] {s : Set G}\n    {x : MonoidAlgebra k G} :\n    x ∈ Ideal.span (MonoidAlgebra.of k G '' s) ↔ ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d * m' := by\n  let RHS : Ideal (MonoidAlgebra k G) :=\n    { carrier := { p | ∀ m : G, m ∈ p.support → ∃ m' ∈ s, ∃ d, m = d * m' }\n      add_mem' := fun {x y} hx hy m hm => by\n        classical exact (Finset.mem_union.1 <| Finsupp.support_add hm).elim (hx m) (hy m)\n      zero_mem' := fun m hm => by cases hm\n      smul_mem' := fun x y hy m hm => by\n        classical\n        rw [smul_eq_mul, mul_def] at hm\n        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)\n        obtain ⟨xm, -, hm⟩ := hm\n        replace hm := Finset.mem_biUnion.mp (Finsupp.support_sum hm)\n        obtain ⟨ym, hym, hm⟩ := hm\n        obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)\n        refine (hy _ hym).imp fun sm p => And.imp_right ?_ p\n        rintro ⟨d, rfl⟩\n        exact ⟨xm * d, (mul_assoc _ _ _).symm⟩ }\n  change _ ↔ x ∈ RHS\n  constructor\n  · revert x\n    rw [← SetLike.le_def] -- Porting note: refine needs this even though it's defeq?\n    refine Ideal.span_le.2 ?_\n    rintro _ ⟨i, hi, rfl⟩ m hm\n    refine ⟨_, hi, 1, ?_⟩\n    obtain rfl := Finset.mem_singleton.mp (Finsupp.support_single_subset hm)\n    exact (one_mul _).symm\n  · intro hx\n    rw [← Finsupp.sum_single x]\n    refine Ideal.sum_mem _ fun i hi => ?_  -- Porting note: changed `apply` to `refine`\n    obtain ⟨d, hd, d2, rfl⟩ := hx _ hi\n    convert Ideal.mul_mem_left _ (id <| Finsupp.single d2 <| x (d2 * d) : MonoidAlgebra k G) _\n    pick_goal 3\n    · exact Ideal.subset_span ⟨_, hd, rfl⟩\n    rw [id, MonoidAlgebra.of_apply, MonoidAlgebra.single_mul_single, mul_one]\n\n"}
{"name":"AddMonoidAlgebra.mem_ideal_span_of'_image","module":"Mathlib.Algebra.MonoidAlgebra.Ideal","initialProofState":"k : Type u_1\nA : Type u_2\ninst✝¹ : AddMonoid A\ninst✝ : Semiring k\ns : Set A\nx : AddMonoidAlgebra k A\n⊢ Iff (Membership.mem (Ideal.span (Set.image (AddMonoidAlgebra.of' k A) s)) x) (∀ (m : A), Membership.mem x.support m → Exists fun m' => And (Membership.mem s m') (Exists fun d => Eq m (HAdd.hAdd d m')))","decl":"/-- If `x` belongs to the ideal generated by generators in `s`, then every element of the support of\n`x` factors additively through an element of `s`.\n-/\ntheorem AddMonoidAlgebra.mem_ideal_span_of'_image [AddMonoid A] [Semiring k] {s : Set A}\n    {x : AddMonoidAlgebra k A} :\n    x ∈ Ideal.span (AddMonoidAlgebra.of' k A '' s) ↔ ∀ m ∈ x.support, ∃ m' ∈ s, ∃ d, m = d + m' :=\n  @MonoidAlgebra.mem_ideal_span_of_image k (Multiplicative A) _ _ _ _\n"}
