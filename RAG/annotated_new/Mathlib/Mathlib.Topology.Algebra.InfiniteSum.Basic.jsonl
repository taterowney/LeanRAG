{"name":"hasSum_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\n⊢ HasSum (fun x => 0) 0","decl":"/-- Constant one function has product `1` -/\n@[to_additive \"Constant zero function has sum `0`\"]\ntheorem hasProd_one : HasProd (fun _ ↦ 1 : β → α) 1 := by simp [HasProd, tendsto_const_nhds]\n\n"}
{"name":"hasProd_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\n⊢ HasProd (fun x => 1) 1","decl":"/-- Constant one function has product `1` -/\n@[to_additive \"Constant zero function has sum `0`\"]\ntheorem hasProd_one : HasProd (fun _ ↦ 1 : β → α) 1 := by simp [HasProd, tendsto_const_nhds]\n\n"}
{"name":"hasProd_empty","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : IsEmpty β\n⊢ HasProd f 1","decl":"@[to_additive]\ntheorem hasProd_empty [IsEmpty β] : HasProd f 1 := by\n  convert @hasProd_one α β _ _\n\n"}
{"name":"hasSum_empty","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : IsEmpty β\n⊢ HasSum f 0","decl":"@[to_additive]\ntheorem hasProd_empty [IsEmpty β] : HasProd f 1 := by\n  convert @hasProd_one α β _ _\n\n"}
{"name":"summable_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\n⊢ Summable fun x => 0","decl":"@[to_additive]\ntheorem multipliable_one : Multipliable (fun _ ↦ 1 : β → α) :=\n  hasProd_one.multipliable\n\n"}
{"name":"multipliable_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\n⊢ Multipliable fun x => 1","decl":"@[to_additive]\ntheorem multipliable_one : Multipliable (fun _ ↦ 1 : β → α) :=\n  hasProd_one.multipliable\n\n"}
{"name":"summable_empty","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : IsEmpty β\n⊢ Summable f","decl":"@[to_additive]\ntheorem multipliable_empty [IsEmpty β] : Multipliable f :=\n  hasProd_empty.multipliable\n\n"}
{"name":"multipliable_empty","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : IsEmpty β\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem multipliable_empty [IsEmpty β] : Multipliable f :=\n  hasProd_empty.multipliable\n\n"}
{"name":"summable_congr","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\nhfg : ∀ (b : β), Eq (f b) (g b)\n⊢ Iff (Summable f) (Summable g)","decl":"/-- See `multipliable_congr_cofinite` for a version allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"See `summable_congr_cofinite` for a version allowing the functions to\ndisagree on a finite set.\"]\ntheorem multipliable_congr (hfg : ∀ b, f b = g b) : Multipliable f ↔ Multipliable g :=\n  iff_of_eq (congr_arg Multipliable <| funext hfg)\n\n"}
{"name":"multipliable_congr","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\nhfg : ∀ (b : β), Eq (f b) (g b)\n⊢ Iff (Multipliable f) (Multipliable g)","decl":"/-- See `multipliable_congr_cofinite` for a version allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"See `summable_congr_cofinite` for a version allowing the functions to\ndisagree on a finite set.\"]\ntheorem multipliable_congr (hfg : ∀ b, f b = g b) : Multipliable f ↔ Multipliable g :=\n  iff_of_eq (congr_arg Multipliable <| funext hfg)\n\n"}
{"name":"Multipliable.congr","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\nhf : Multipliable f\nhfg : ∀ (b : β), Eq (f b) (g b)\n⊢ Multipliable g","decl":"/-- See `Multipliable.congr_cofinite` for a version allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"See `Summable.congr_cofinite` for a version allowing the functions to\ndisagree on a finite set.\"]\ntheorem Multipliable.congr (hf : Multipliable f) (hfg : ∀ b, f b = g b) : Multipliable g :=\n  (multipliable_congr hfg).mp hf\n\n"}
{"name":"Summable.congr","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\nhf : Summable f\nhfg : ∀ (b : β), Eq (f b) (g b)\n⊢ Summable g","decl":"/-- See `Multipliable.congr_cofinite` for a version allowing the functions to\ndisagree on a finite set. -/\n@[to_additive \"See `Summable.congr_cofinite` for a version allowing the functions to\ndisagree on a finite set.\"]\ntheorem Multipliable.congr (hf : Multipliable f) (hfg : ∀ b, f b = g b) : Multipliable g :=\n  (multipliable_congr hfg).mp hf\n\n"}
{"name":"HasProd.congr_fun","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\na : α\nhf : HasProd f a\nh : ∀ (x : β), Eq (g x) (f x)\n⊢ HasProd g a","decl":"@[to_additive]\nlemma HasProd.congr_fun (hf : HasProd f a) (h : ∀ x : β, g x = f x) : HasProd g a :=\n  (funext h : g = f) ▸ hf\n\n"}
{"name":"HasSum.congr_fun","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\na : α\nhf : HasSum f a\nh : ∀ (x : β), Eq (g x) (f x)\n⊢ HasSum g a","decl":"@[to_additive]\nlemma HasProd.congr_fun (hf : HasProd f a) (h : ∀ x : β, g x = f x) : HasProd g a :=\n  (funext h : g = f) ▸ hf\n\n"}
{"name":"HasProd.hasProd_of_prod_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\nh_eq : ∀ (u : Finset γ), Exists fun v => ∀ (v' : Finset β), HasSubset.Subset v v' → Exists fun u' => And (HasSubset.Subset u u') (Eq (u'.prod fun x => g x) (v'.prod fun b => f b))\nhf : HasProd g a\n⊢ HasProd f a","decl":"@[to_additive]\ntheorem HasProd.hasProd_of_prod_eq {g : γ → α}\n    (h_eq : ∀ u : Finset γ, ∃ v : Finset β, ∀ v', v ⊆ v' →\n      ∃ u', u ⊆ u' ∧ ∏ x ∈ u', g x = ∏ b ∈ v', f b)\n    (hf : HasProd g a) : HasProd f a :=\n  le_trans (map_atTop_finset_prod_le_of_prod_eq h_eq) hf\n\n"}
{"name":"HasSum.hasSum_of_sum_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\nh_eq : ∀ (u : Finset γ), Exists fun v => ∀ (v' : Finset β), HasSubset.Subset v v' → Exists fun u' => And (HasSubset.Subset u u') (Eq (u'.sum fun x => g x) (v'.sum fun b => f b))\nhf : HasSum g a\n⊢ HasSum f a","decl":"@[to_additive]\ntheorem HasProd.hasProd_of_prod_eq {g : γ → α}\n    (h_eq : ∀ u : Finset γ, ∃ v : Finset β, ∀ v', v ⊆ v' →\n      ∃ u', u ⊆ u' ∧ ∏ x ∈ u', g x = ∏ b ∈ v', f b)\n    (hf : HasProd g a) : HasProd f a :=\n  le_trans (map_atTop_finset_prod_le_of_prod_eq h_eq) hf\n\n"}
{"name":"hasProd_iff_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\nh₁ : ∀ (u : Finset γ), Exists fun v => ∀ (v' : Finset β), HasSubset.Subset v v' → Exists fun u' => And (HasSubset.Subset u u') (Eq (u'.prod fun x => g x) (v'.prod fun b => f b))\nh₂ : ∀ (v : Finset β), Exists fun u => ∀ (u' : Finset γ), HasSubset.Subset u u' → Exists fun v' => And (HasSubset.Subset v v') (Eq (v'.prod fun b => f b) (u'.prod fun x => g x))\n⊢ Iff (HasProd f a) (HasProd g a)","decl":"@[to_additive]\ntheorem hasProd_iff_hasProd {g : γ → α}\n    (h₁ : ∀ u : Finset γ, ∃ v : Finset β, ∀ v', v ⊆ v' →\n      ∃ u', u ⊆ u' ∧ ∏ x ∈ u', g x = ∏ b ∈ v', f b)\n    (h₂ : ∀ v : Finset β, ∃ u : Finset γ, ∀ u', u ⊆ u' →\n      ∃ v', v ⊆ v' ∧ ∏ b ∈ v', f b = ∏ x ∈ u', g x) :\n    HasProd f a ↔ HasProd g a :=\n  ⟨HasProd.hasProd_of_prod_eq h₂, HasProd.hasProd_of_prod_eq h₁⟩\n\n"}
{"name":"hasSum_iff_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\nh₁ : ∀ (u : Finset γ), Exists fun v => ∀ (v' : Finset β), HasSubset.Subset v v' → Exists fun u' => And (HasSubset.Subset u u') (Eq (u'.sum fun x => g x) (v'.sum fun b => f b))\nh₂ : ∀ (v : Finset β), Exists fun u => ∀ (u' : Finset γ), HasSubset.Subset u u' → Exists fun v' => And (HasSubset.Subset v v') (Eq (v'.sum fun b => f b) (u'.sum fun x => g x))\n⊢ Iff (HasSum f a) (HasSum g a)","decl":"@[to_additive]\ntheorem hasProd_iff_hasProd {g : γ → α}\n    (h₁ : ∀ u : Finset γ, ∃ v : Finset β, ∀ v', v ⊆ v' →\n      ∃ u', u ⊆ u' ∧ ∏ x ∈ u', g x = ∏ b ∈ v', f b)\n    (h₂ : ∀ v : Finset β, ∃ u : Finset γ, ∀ u', u ⊆ u' →\n      ∃ v', v ⊆ v' ∧ ∏ b ∈ v', f b = ∏ x ∈ u', g x) :\n    HasProd f a ↔ HasProd g a :=\n  ⟨HasProd.hasProd_of_prod_eq h₂, HasProd.hasProd_of_prod_eq h₁⟩\n\n"}
{"name":"Function.Injective.summable_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → β\nhg : Function.Injective g\nhf : ∀ (x : β), Not (Membership.mem (Set.range g) x) → Eq (f x) 0\n⊢ Iff (Summable (Function.comp f g)) (Summable f)","decl":"@[to_additive]\ntheorem Function.Injective.multipliable_iff {g : γ → β} (hg : Injective g)\n    (hf : ∀ x ∉ Set.range g, f x = 1) : Multipliable (f ∘ g) ↔ Multipliable f :=\n  exists_congr fun _ ↦ hg.hasProd_iff hf\n\n"}
{"name":"Function.Injective.multipliable_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → β\nhg : Function.Injective g\nhf : ∀ (x : β), Not (Membership.mem (Set.range g) x) → Eq (f x) 1\n⊢ Iff (Multipliable (Function.comp f g)) (Multipliable f)","decl":"@[to_additive]\ntheorem Function.Injective.multipliable_iff {g : γ → β} (hg : Injective g)\n    (hf : ∀ x ∉ Set.range g, f x = 1) : Multipliable (f ∘ g) ↔ Multipliable f :=\n  exists_congr fun _ ↦ hg.hasProd_iff hf\n\n"}
{"name":"hasSum_extend_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : β → γ\nhg : Function.Injective g\n⊢ Iff (HasSum (Function.extend g f 0) a) (HasSum f a)","decl":"@[to_additive (attr := simp)] theorem hasProd_extend_one {g : β → γ} (hg : Injective g) :\n    HasProd (extend g f 1) a ↔ HasProd f a := by\n  rw [← hg.hasProd_iff, extend_comp hg]\n  exact extend_apply' _ _\n\n"}
{"name":"hasProd_extend_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : β → γ\nhg : Function.Injective g\n⊢ Iff (HasProd (Function.extend g f 1) a) (HasProd f a)","decl":"@[to_additive (attr := simp)] theorem hasProd_extend_one {g : β → γ} (hg : Injective g) :\n    HasProd (extend g f 1) a ↔ HasProd f a := by\n  rw [← hg.hasProd_iff, extend_comp hg]\n  exact extend_apply' _ _\n\n"}
{"name":"multipliable_extend_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : β → γ\nhg : Function.Injective g\n⊢ Iff (Multipliable (Function.extend g f 1)) (Multipliable f)","decl":"@[to_additive (attr := simp)] theorem multipliable_extend_one {g : β → γ} (hg : Injective g) :\n    Multipliable (extend g f 1) ↔ Multipliable f :=\n  exists_congr fun _ ↦ hasProd_extend_one hg\n\n"}
{"name":"summable_extend_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : β → γ\nhg : Function.Injective g\n⊢ Iff (Summable (Function.extend g f 0)) (Summable f)","decl":"@[to_additive (attr := simp)] theorem multipliable_extend_one {g : β → γ} (hg : Injective g) :\n    Multipliable (extend g f 1) ↔ Multipliable f :=\n  exists_congr fun _ ↦ hasProd_extend_one hg\n\n"}
{"name":"hasProd_subtype_iff_mulIndicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ns : Set β\n⊢ Iff (HasProd (Function.comp f Subtype.val) a) (HasProd (s.mulIndicator f) a)","decl":"@[to_additive]\ntheorem hasProd_subtype_iff_mulIndicator {s : Set β} :\n    HasProd (f ∘ (↑) : s → α) a ↔ HasProd (s.mulIndicator f) a := by\n  rw [← Set.mulIndicator_range_comp, Subtype.range_coe,\n    hasProd_subtype_iff_of_mulSupport_subset Set.mulSupport_mulIndicator_subset]\n\n"}
{"name":"hasSum_subtype_iff_indicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ns : Set β\n⊢ Iff (HasSum (Function.comp f Subtype.val) a) (HasSum (s.indicator f) a)","decl":"@[to_additive]\ntheorem hasProd_subtype_iff_mulIndicator {s : Set β} :\n    HasProd (f ∘ (↑) : s → α) a ↔ HasProd (s.mulIndicator f) a := by\n  rw [← Set.mulIndicator_range_comp, Subtype.range_coe,\n    hasProd_subtype_iff_of_mulSupport_subset Set.mulSupport_mulIndicator_subset]\n\n"}
{"name":"summable_subtype_iff_indicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Set β\n⊢ Iff (Summable (Function.comp f Subtype.val)) (Summable (s.indicator f))","decl":"@[to_additive]\ntheorem multipliable_subtype_iff_mulIndicator {s : Set β} :\n    Multipliable (f ∘ (↑) : s → α) ↔ Multipliable (s.mulIndicator f) :=\n  exists_congr fun _ ↦ hasProd_subtype_iff_mulIndicator\n\n"}
{"name":"multipliable_subtype_iff_mulIndicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Set β\n⊢ Iff (Multipliable (Function.comp f Subtype.val)) (Multipliable (s.mulIndicator f))","decl":"@[to_additive]\ntheorem multipliable_subtype_iff_mulIndicator {s : Set β} :\n    Multipliable (f ∘ (↑) : s → α) ↔ Multipliable (s.mulIndicator f) :=\n  exists_congr fun _ ↦ hasProd_subtype_iff_mulIndicator\n\n"}
{"name":"hasProd_subtype_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\n⊢ Iff (HasProd (Function.comp f Subtype.val) a) (HasProd f a)","decl":"@[to_additive (attr := simp)]\ntheorem hasProd_subtype_mulSupport : HasProd (f ∘ (↑) : mulSupport f → α) a ↔ HasProd f a :=\n  hasProd_subtype_iff_of_mulSupport_subset <| Set.Subset.refl _\n\n"}
{"name":"hasSum_subtype_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\n⊢ Iff (HasSum (Function.comp f Subtype.val) a) (HasSum f a)","decl":"@[to_additive (attr := simp)]\ntheorem hasProd_subtype_mulSupport : HasProd (f ∘ (↑) : mulSupport f → α) a ↔ HasProd f a :=\n  hasProd_subtype_iff_of_mulSupport_subset <| Set.Subset.refl _\n\n"}
{"name":"Finset.multipliable","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ Multipliable (Function.comp f Subtype.val)","decl":"@[to_additive]\nprotected theorem Finset.multipliable (s : Finset β) (f : β → α) :\n    Multipliable (f ∘ (↑) : (↑s : Set β) → α) :=\n  (s.hasProd f).multipliable\n\n"}
{"name":"Finset.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ Summable (Function.comp f Subtype.val)","decl":"@[to_additive]\nprotected theorem Finset.multipliable (s : Finset β) (f : β → α) :\n    Multipliable (f ∘ (↑) : (↑s : Set β) → α) :=\n  (s.hasProd f).multipliable\n\n"}
{"name":"Set.Finite.multipliable","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Set β\nhs : s.Finite\nf : β → α\n⊢ Multipliable (Function.comp f Subtype.val)","decl":"@[to_additive]\nprotected theorem Set.Finite.multipliable {s : Set β} (hs : s.Finite) (f : β → α) :\n    Multipliable (f ∘ (↑) : s → α) := by\n  have := hs.toFinset.multipliable f\n  rwa [hs.coe_toFinset] at this\n\n"}
{"name":"Set.Finite.summable","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Set β\nhs : s.Finite\nf : β → α\n⊢ Summable (Function.comp f Subtype.val)","decl":"@[to_additive]\nprotected theorem Set.Finite.multipliable {s : Set β} (hs : s.Finite) (f : β → α) :\n    Multipliable (f ∘ (↑) : s → α) := by\n  have := hs.toFinset.multipliable f\n  rwa [hs.coe_toFinset] at this\n\n"}
{"name":"summable_of_finite_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nh : (Function.support f).Finite\n⊢ Summable f","decl":"@[to_additive]\ntheorem multipliable_of_finite_mulSupport (h : (mulSupport f).Finite) : Multipliable f := by\n  apply multipliable_of_ne_finset_one (s := h.toFinset); simp\n\n"}
{"name":"multipliable_of_finite_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nh : (Function.mulSupport f).Finite\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem multipliable_of_finite_mulSupport (h : (mulSupport f).Finite) : Multipliable f := by\n  apply multipliable_of_ne_finset_one (s := h.toFinset); simp\n\n"}
{"name":"Multipliable.of_finite","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Finite β\nf : β → α\n⊢ Multipliable f","decl":"@[to_additive]\nlemma Multipliable.of_finite [Finite β] {f : β → α} : Multipliable f :=\n  multipliable_of_finite_mulSupport <| Set.finite_univ.subset (Set.subset_univ _)\n\n"}
{"name":"Summable.of_finite","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Finite β\nf : β → α\n⊢ Summable f","decl":"@[to_additive]\nlemma Multipliable.of_finite [Finite β] {f : β → α} : Multipliable f :=\n  multipliable_of_finite_mulSupport <| Set.finite_univ.subset (Set.subset_univ _)\n\n"}
{"name":"hasProd_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nb : β\nhf : ∀ (b' : β), Ne b' b → Eq (f b') 1\n⊢ HasProd f (f b)","decl":"@[to_additive]\ntheorem hasProd_single {f : β → α} (b : β) (hf : ∀ (b') (_ : b' ≠ b), f b' = 1) : HasProd f (f b) :=\n  suffices HasProd f (∏ b' ∈ {b}, f b') by simpa using this\n  hasProd_prod_of_ne_finset_one <| by simpa [hf]\n\n"}
{"name":"hasSum_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nb : β\nhf : ∀ (b' : β), Ne b' b → Eq (f b') 0\n⊢ HasSum f (f b)","decl":"@[to_additive]\ntheorem hasProd_single {f : β → α} (b : β) (hf : ∀ (b') (_ : b' ≠ b), f b' = 1) : HasProd f (f b) :=\n  suffices HasProd f (∏ b' ∈ {b}, f b') by simpa using this\n  hasProd_prod_of_ne_finset_one <| by simpa [hf]\n\n"}
{"name":"hasProd_unique","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Unique β\nf : β → α\n⊢ HasProd f (f Inhabited.default)","decl":"@[to_additive (attr := simp)] lemma hasProd_unique [Unique β] (f : β → α) : HasProd f (f default) :=\n  hasProd_single default (fun _ hb ↦ False.elim <| hb <| Unique.uniq ..)\n\n"}
{"name":"hasSum_unique","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Unique β\nf : β → α\n⊢ HasSum f (f Inhabited.default)","decl":"@[to_additive (attr := simp)] lemma hasProd_unique [Unique β] (f : β → α) : HasProd f (f default) :=\n  hasProd_single default (fun _ hb ↦ False.elim <| hb <| Unique.uniq ..)\n\n"}
{"name":"hasProd_singleton","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nm : β\nf : β → α\n⊢ HasProd ((Singleton.singleton m).restrict f) (f m)","decl":"@[to_additive (attr := simp)]\nlemma hasProd_singleton (m : β) (f : β → α) : HasProd (({m} : Set β).restrict f) (f m) :=\n  hasProd_unique (Set.restrict {m} f)\n\n"}
{"name":"hasSum_singleton","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nm : β\nf : β → α\n⊢ HasSum ((Singleton.singleton m).restrict f) (f m)","decl":"@[to_additive (attr := simp)]\nlemma hasProd_singleton (m : β) (f : β → α) : HasProd (({m} : Set β).restrict f) (f m) :=\n  hasProd_unique (Set.restrict {m} f)\n\n"}
{"name":"hasProd_ite_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nb : β\ninst✝ : DecidablePred fun x => Eq x b\na : α\n⊢ HasProd (fun b' => ite (Eq b' b) a 1) a","decl":"@[to_additive]\ntheorem hasProd_ite_eq (b : β) [DecidablePred (· = b)] (a : α) :\n    HasProd (fun b' ↦ if b' = b then a else 1) a := by\n  convert @hasProd_single _ _ _ _ (fun b' ↦ if b' = b then a else 1) b (fun b' hb' ↦ if_neg hb')\n  exact (if_pos rfl).symm\n\n"}
{"name":"hasSum_ite_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nb : β\ninst✝ : DecidablePred fun x => Eq x b\na : α\n⊢ HasSum (fun b' => ite (Eq b' b) a 0) a","decl":"@[to_additive]\ntheorem hasProd_ite_eq (b : β) [DecidablePred (· = b)] (a : α) :\n    HasProd (fun b' ↦ if b' = b then a else 1) a := by\n  convert @hasProd_single _ _ _ _ (fun b' ↦ if b' = b then a else 1) b (fun b' hb' ↦ if_neg hb')\n  exact (if_pos rfl).symm\n\n"}
{"name":"Equiv.hasSum_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ne : Equiv γ β\n⊢ Iff (HasSum (Function.comp f ⇑e) a) (HasSum f a)","decl":"@[to_additive]\ntheorem Equiv.hasProd_iff (e : γ ≃ β) : HasProd (f ∘ e) a ↔ HasProd f a :=\n  e.injective.hasProd_iff <| by simp\n\n"}
{"name":"Equiv.hasProd_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ne : Equiv γ β\n⊢ Iff (HasProd (Function.comp f ⇑e) a) (HasProd f a)","decl":"@[to_additive]\ntheorem Equiv.hasProd_iff (e : γ ≃ β) : HasProd (f ∘ e) a ↔ HasProd f a :=\n  e.injective.hasProd_iff <| by simp\n\n"}
{"name":"Function.Injective.hasProd_range_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → β\nhg : Function.Injective g\n⊢ Iff (HasProd (fun x => f ↑x) a) (HasProd (Function.comp f g) a)","decl":"@[to_additive]\ntheorem Function.Injective.hasProd_range_iff {g : γ → β} (hg : Injective g) :\n    HasProd (fun x : Set.range g ↦ f x) a ↔ HasProd (f ∘ g) a :=\n  (Equiv.ofInjective g hg).hasProd_iff.symm\n\n"}
{"name":"Function.Injective.hasSum_range_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → β\nhg : Function.Injective g\n⊢ Iff (HasSum (fun x => f ↑x) a) (HasSum (Function.comp f g) a)","decl":"@[to_additive]\ntheorem Function.Injective.hasProd_range_iff {g : γ → β} (hg : Injective g) :\n    HasProd (fun x : Set.range g ↦ f x) a ↔ HasProd (f ∘ g) a :=\n  (Equiv.ofInjective g hg).hasProd_iff.symm\n\n"}
{"name":"Equiv.summable_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ne : Equiv γ β\n⊢ Iff (Summable (Function.comp f ⇑e)) (Summable f)","decl":"@[to_additive]\ntheorem Equiv.multipliable_iff (e : γ ≃ β) : Multipliable (f ∘ e) ↔ Multipliable f :=\n  exists_congr fun _ ↦ e.hasProd_iff\n\n"}
{"name":"Equiv.multipliable_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ne : Equiv γ β\n⊢ Iff (Multipliable (Function.comp f ⇑e)) (Multipliable f)","decl":"@[to_additive]\ntheorem Equiv.multipliable_iff (e : γ ≃ β) : Multipliable (f ∘ e) ↔ Multipliable f :=\n  exists_congr fun _ ↦ e.hasProd_iff\n\n"}
{"name":"Equiv.hasSum_iff_of_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\ne : Equiv ↑(Function.support f) ↑(Function.support g)\nhe : ∀ (x : ↑(Function.support f)), Eq (g ↑(e x)) (f ↑x)\n⊢ Iff (HasSum f a) (HasSum g a)","decl":"@[to_additive]\ntheorem Equiv.hasProd_iff_of_mulSupport {g : γ → α} (e : mulSupport f ≃ mulSupport g)\n    (he : ∀ x : mulSupport f, g (e x) = f x) : HasProd f a ↔ HasProd g a := by\n  have : (g ∘ (↑)) ∘ e = f ∘ (↑) := funext he\n  rw [← hasProd_subtype_mulSupport, ← this, e.hasProd_iff, hasProd_subtype_mulSupport]\n\n"}
{"name":"Equiv.hasProd_iff_of_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\ne : Equiv ↑(Function.mulSupport f) ↑(Function.mulSupport g)\nhe : ∀ (x : ↑(Function.mulSupport f)), Eq (g ↑(e x)) (f ↑x)\n⊢ Iff (HasProd f a) (HasProd g a)","decl":"@[to_additive]\ntheorem Equiv.hasProd_iff_of_mulSupport {g : γ → α} (e : mulSupport f ≃ mulSupport g)\n    (he : ∀ x : mulSupport f, g (e x) = f x) : HasProd f a ↔ HasProd g a := by\n  have : (g ∘ (↑)) ∘ e = f ∘ (↑) := funext he\n  rw [← hasProd_subtype_mulSupport, ← this, e.hasProd_iff, hasProd_subtype_mulSupport]\n\n"}
{"name":"hasSum_iff_hasSum_of_ne_zero_bij","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\ni : ↑(Function.support g) → β\nhi : Function.Injective i\nhf : HasSubset.Subset (Function.support f) (Set.range i)\nhfg : ∀ (x : ↑(Function.support g)), Eq (f (i x)) (g ↑x)\n⊢ Iff (HasSum f a) (HasSum g a)","decl":"@[to_additive]\ntheorem hasProd_iff_hasProd_of_ne_one_bij {g : γ → α} (i : mulSupport g → β)\n    (hi : Injective i) (hf : mulSupport f ⊆ Set.range i)\n    (hfg : ∀ x, f (i x) = g x) : HasProd f a ↔ HasProd g a :=\n  Iff.symm <|\n    Equiv.hasProd_iff_of_mulSupport\n      (Equiv.ofBijective (fun x ↦ ⟨i x, fun hx ↦ x.coe_prop <| hfg x ▸ hx⟩)\n        ⟨fun _ _ h ↦ hi <| Subtype.ext_iff.1 h, fun y ↦\n          (hf y.coe_prop).imp fun _ hx ↦ Subtype.ext hx⟩)\n      hfg\n\n"}
{"name":"hasProd_iff_hasProd_of_ne_one_bij","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\na : α\ng : γ → α\ni : ↑(Function.mulSupport g) → β\nhi : Function.Injective i\nhf : HasSubset.Subset (Function.mulSupport f) (Set.range i)\nhfg : ∀ (x : ↑(Function.mulSupport g)), Eq (f (i x)) (g ↑x)\n⊢ Iff (HasProd f a) (HasProd g a)","decl":"@[to_additive]\ntheorem hasProd_iff_hasProd_of_ne_one_bij {g : γ → α} (i : mulSupport g → β)\n    (hi : Injective i) (hf : mulSupport f ⊆ Set.range i)\n    (hfg : ∀ x, f (i x) = g x) : HasProd f a ↔ HasProd g a :=\n  Iff.symm <|\n    Equiv.hasProd_iff_of_mulSupport\n      (Equiv.ofBijective (fun x ↦ ⟨i x, fun hx ↦ x.coe_prop <| hfg x ▸ hx⟩)\n        ⟨fun _ _ h ↦ hi <| Subtype.ext_iff.1 h, fun y ↦\n          (hf y.coe_prop).imp fun _ hx ↦ Subtype.ext hx⟩)\n      hfg\n\n"}
{"name":"Equiv.multipliable_iff_of_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → α\ne : Equiv ↑(Function.mulSupport f) ↑(Function.mulSupport g)\nhe : ∀ (x : ↑(Function.mulSupport f)), Eq (g ↑(e x)) (f ↑x)\n⊢ Iff (Multipliable f) (Multipliable g)","decl":"@[to_additive]\ntheorem Equiv.multipliable_iff_of_mulSupport {g : γ → α} (e : mulSupport f ≃ mulSupport g)\n    (he : ∀ x : mulSupport f, g (e x) = f x) : Multipliable f ↔ Multipliable g :=\n  exists_congr fun _ ↦ e.hasProd_iff_of_mulSupport he\n\n"}
{"name":"Equiv.summable_iff_of_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → α\ne : Equiv ↑(Function.support f) ↑(Function.support g)\nhe : ∀ (x : ↑(Function.support f)), Eq (g ↑(e x)) (f ↑x)\n⊢ Iff (Summable f) (Summable g)","decl":"@[to_additive]\ntheorem Equiv.multipliable_iff_of_mulSupport {g : γ → α} (e : mulSupport f ≃ mulSupport g)\n    (he : ∀ x : mulSupport f, g (e x) = f x) : Multipliable f ↔ Multipliable g :=\n  exists_congr fun _ ↦ e.hasProd_iff_of_mulSupport he\n\n"}
{"name":"HasSum.map","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : TopologicalSpace α\nf : β → α\na : α\ninst✝³ : AddCommMonoid γ\ninst✝² : TopologicalSpace γ\nhf : HasSum f a\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : AddMonoidHomClass G α γ\ng : G\nhg : Continuous ⇑g\n⊢ HasSum (Function.comp (⇑g) f) (g a)","decl":"@[to_additive]\nprotected theorem HasProd.map [CommMonoid γ] [TopologicalSpace γ] (hf : HasProd f a) {G}\n    [FunLike G α γ] [MonoidHomClass G α γ] (g : G) (hg : Continuous g) :\n    HasProd (g ∘ f) (g a) := by\n  have : (g ∘ fun s : Finset β ↦ ∏ b ∈ s, f b) = fun s : Finset β ↦ ∏ b ∈ s, (g ∘ f) b :=\n    funext <| map_prod g _\n  unfold HasProd\n  rw [← this]\n  exact (hg.tendsto a).comp hf\n\n"}
{"name":"HasProd.map","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : CommMonoid α\ninst✝⁴ : TopologicalSpace α\nf : β → α\na : α\ninst✝³ : CommMonoid γ\ninst✝² : TopologicalSpace γ\nhf : HasProd f a\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Continuous ⇑g\n⊢ HasProd (Function.comp (⇑g) f) (g a)","decl":"@[to_additive]\nprotected theorem HasProd.map [CommMonoid γ] [TopologicalSpace γ] (hf : HasProd f a) {G}\n    [FunLike G α γ] [MonoidHomClass G α γ] (g : G) (hg : Continuous g) :\n    HasProd (g ∘ f) (g a) := by\n  have : (g ∘ fun s : Finset β ↦ ∏ b ∈ s, f b) = fun s : Finset β ↦ ∏ b ∈ s, (g ∘ f) b :=\n    funext <| map_prod g _\n  unfold HasProd\n  rw [← this]\n  exact (hg.tendsto a).comp hf\n\n"}
{"name":"Topology.IsInducing.hasProd_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : CommMonoid α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CommMonoid γ\ninst✝² : TopologicalSpace γ\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Topology.IsInducing ⇑g\nf : β → α\na : α\n⊢ Iff (HasProd (Function.comp (⇑g) f) (g a)) (HasProd f a)","decl":"@[to_additive]\nprotected theorem Topology.IsInducing.hasProd_iff [CommMonoid γ] [TopologicalSpace γ] {G}\n    [FunLike G α γ] [MonoidHomClass G α γ] {g : G} (hg : IsInducing g) (f : β → α) (a : α) :\n    HasProd (g ∘ f) (g a) ↔ HasProd f a := by\n  simp_rw [HasProd, comp_apply, ← map_prod]\n  exact hg.tendsto_nhds_iff.symm\n\n"}
{"name":"Topology.IsInducing.hasSum_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddCommMonoid γ\ninst✝² : TopologicalSpace γ\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : AddMonoidHomClass G α γ\ng : G\nhg : Topology.IsInducing ⇑g\nf : β → α\na : α\n⊢ Iff (HasSum (Function.comp (⇑g) f) (g a)) (HasSum f a)","decl":"@[to_additive]\nprotected theorem Topology.IsInducing.hasProd_iff [CommMonoid γ] [TopologicalSpace γ] {G}\n    [FunLike G α γ] [MonoidHomClass G α γ] {g : G} (hg : IsInducing g) (f : β → α) (a : α) :\n    HasProd (g ∘ f) (g a) ↔ HasProd f a := by\n  simp_rw [HasProd, comp_apply, ← map_prod]\n  exact hg.tendsto_nhds_iff.symm\n\n"}
{"name":"Inducing.hasProd_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : CommMonoid α\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CommMonoid γ\ninst✝² : TopologicalSpace γ\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Topology.IsInducing ⇑g\nf : β → α\na : α\n⊢ Iff (HasProd (Function.comp (⇑g) f) (g a)) (HasProd f a)","decl":"@[deprecated (since := \"2024-10-28\")] alias Inducing.hasProd_iff := IsInducing.hasProd_iff\n\n"}
{"name":"Multipliable.map","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : CommMonoid α\ninst✝⁴ : TopologicalSpace α\nf : β → α\ninst✝³ : CommMonoid γ\ninst✝² : TopologicalSpace γ\nhf : Multipliable f\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Continuous ⇑g\n⊢ Multipliable (Function.comp (⇑g) f)","decl":"@[to_additive]\nprotected theorem Multipliable.map [CommMonoid γ] [TopologicalSpace γ] (hf : Multipliable f) {G}\n    [FunLike G α γ] [MonoidHomClass G α γ] (g : G) (hg : Continuous g) : Multipliable (g ∘ f) :=\n  (hf.hasProd.map g hg).multipliable\n\n"}
{"name":"Summable.map","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : TopologicalSpace α\nf : β → α\ninst✝³ : AddCommMonoid γ\ninst✝² : TopologicalSpace γ\nhf : Summable f\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : AddMonoidHomClass G α γ\ng : G\nhg : Continuous ⇑g\n⊢ Summable (Function.comp (⇑g) f)","decl":"@[to_additive]\nprotected theorem Multipliable.map [CommMonoid γ] [TopologicalSpace γ] (hf : Multipliable f) {G}\n    [FunLike G α γ] [MonoidHomClass G α γ] (g : G) (hg : Continuous g) : Multipliable (g ∘ f) :=\n  (hf.hasProd.map g hg).multipliable\n\n"}
{"name":"Summable.map_iff_of_leftInverse","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁷ : AddCommMonoid α\ninst✝⁶ : TopologicalSpace α\nf : β → α\ninst✝⁵ : AddCommMonoid γ\ninst✝⁴ : TopologicalSpace γ\nG : Type u_4\nG' : Type u_5\ninst✝³ : FunLike G α γ\ninst✝² : AddMonoidHomClass G α γ\ninst✝¹ : FunLike G' γ α\ninst✝ : AddMonoidHomClass G' γ α\ng : G\ng' : G'\nhg : Continuous ⇑g\nhg' : Continuous ⇑g'\nhinv : Function.LeftInverse ⇑g' ⇑g\n⊢ Iff (Summable (Function.comp (⇑g) f)) (Summable f)","decl":"@[to_additive]\nprotected theorem Multipliable.map_iff_of_leftInverse [CommMonoid γ] [TopologicalSpace γ] {G G'}\n    [FunLike G α γ] [MonoidHomClass G α γ] [FunLike G' γ α] [MonoidHomClass G' γ α]\n    (g : G) (g' : G') (hg : Continuous g) (hg' : Continuous g') (hinv : Function.LeftInverse g' g) :\n    Multipliable (g ∘ f) ↔ Multipliable f :=\n  ⟨fun h ↦ by\n    have := h.map _ hg'\n    rwa [← Function.comp_assoc, hinv.id] at this, fun h ↦ h.map _ hg⟩\n\n"}
{"name":"Multipliable.map_iff_of_leftInverse","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁷ : CommMonoid α\ninst✝⁶ : TopologicalSpace α\nf : β → α\ninst✝⁵ : CommMonoid γ\ninst✝⁴ : TopologicalSpace γ\nG : Type u_4\nG' : Type u_5\ninst✝³ : FunLike G α γ\ninst✝² : MonoidHomClass G α γ\ninst✝¹ : FunLike G' γ α\ninst✝ : MonoidHomClass G' γ α\ng : G\ng' : G'\nhg : Continuous ⇑g\nhg' : Continuous ⇑g'\nhinv : Function.LeftInverse ⇑g' ⇑g\n⊢ Iff (Multipliable (Function.comp (⇑g) f)) (Multipliable f)","decl":"@[to_additive]\nprotected theorem Multipliable.map_iff_of_leftInverse [CommMonoid γ] [TopologicalSpace γ] {G G'}\n    [FunLike G α γ] [MonoidHomClass G α γ] [FunLike G' γ α] [MonoidHomClass G' γ α]\n    (g : G) (g' : G') (hg : Continuous g) (hg' : Continuous g') (hinv : Function.LeftInverse g' g) :\n    Multipliable (g ∘ f) ↔ Multipliable f :=\n  ⟨fun h ↦ by\n    have := h.map _ hg'\n    rwa [← Function.comp_assoc, hinv.id] at this, fun h ↦ h.map _ hg⟩\n\n"}
{"name":"Multipliable.map_tprod","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁶ : CommMonoid α\ninst✝⁵ : TopologicalSpace α\nf : β → α\ninst✝⁴ : CommMonoid γ\ninst✝³ : TopologicalSpace γ\ninst✝² : T2Space γ\nhf : Multipliable f\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Continuous ⇑g\n⊢ Eq (g (tprod fun i => f i)) (tprod fun i => g (f i))","decl":"@[to_additive]\ntheorem Multipliable.map_tprod [CommMonoid γ] [TopologicalSpace γ] [T2Space γ] (hf : Multipliable f)\n    {G} [FunLike G α γ] [MonoidHomClass G α γ] (g : G) (hg : Continuous g) :\n    g (∏' i, f i) = ∏' i, g (f i) := (HasProd.tprod_eq (HasProd.map hf.hasProd g hg)).symm\n\n"}
{"name":"Summable.map_tsum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : TopologicalSpace α\nf : β → α\ninst✝⁴ : AddCommMonoid γ\ninst✝³ : TopologicalSpace γ\ninst✝² : T2Space γ\nhf : Summable f\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : AddMonoidHomClass G α γ\ng : G\nhg : Continuous ⇑g\n⊢ Eq (g (tsum fun i => f i)) (tsum fun i => g (f i))","decl":"@[to_additive]\ntheorem Multipliable.map_tprod [CommMonoid γ] [TopologicalSpace γ] [T2Space γ] (hf : Multipliable f)\n    {G} [FunLike G α γ] [MonoidHomClass G α γ] (g : G) (hg : Continuous g) :\n    g (∏' i, f i) = ∏' i, g (f i) := (HasProd.tprod_eq (HasProd.map hf.hasProd g hg)).symm\n\n"}
{"name":"Topology.IsInducing.multipliable_iff_tprod_comp_mem_range","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁶ : CommMonoid α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : CommMonoid γ\ninst✝³ : TopologicalSpace γ\ninst✝² : T2Space γ\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Topology.IsInducing ⇑g\nf : β → α\n⊢ Iff (Multipliable f) (And (Multipliable (Function.comp (⇑g) f)) (Membership.mem (Set.range ⇑g) (tprod fun i => g (f i))))","decl":"@[to_additive]\nlemma Topology.IsInducing.multipliable_iff_tprod_comp_mem_range [CommMonoid γ] [TopologicalSpace γ]\n    [T2Space γ] {G} [FunLike G α γ] [MonoidHomClass G α γ] {g : G} (hg : IsInducing g) (f : β → α) :\n    Multipliable f ↔ Multipliable (g ∘ f) ∧ ∏' i, g (f i) ∈ Set.range g := by\n  constructor\n  · intro hf\n    constructor\n    · exact hf.map g hg.continuous\n    · use ∏' i, f i\n      exact hf.map_tprod g hg.continuous\n  · rintro ⟨hgf, a, ha⟩\n    use a\n    have := hgf.hasProd\n    simp_rw [comp_apply, ← ha] at this\n    exact (hg.hasProd_iff f a).mp this\n\n"}
{"name":"Topology.IsInducing.summable_iff_tsum_comp_mem_range","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁶ : AddCommMonoid α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : AddCommMonoid γ\ninst✝³ : TopologicalSpace γ\ninst✝² : T2Space γ\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : AddMonoidHomClass G α γ\ng : G\nhg : Topology.IsInducing ⇑g\nf : β → α\n⊢ Iff (Summable f) (And (Summable (Function.comp (⇑g) f)) (Membership.mem (Set.range ⇑g) (tsum fun i => g (f i))))","decl":"@[to_additive]\nlemma Topology.IsInducing.multipliable_iff_tprod_comp_mem_range [CommMonoid γ] [TopologicalSpace γ]\n    [T2Space γ] {G} [FunLike G α γ] [MonoidHomClass G α γ] {g : G} (hg : IsInducing g) (f : β → α) :\n    Multipliable f ↔ Multipliable (g ∘ f) ∧ ∏' i, g (f i) ∈ Set.range g := by\n  constructor\n  · intro hf\n    constructor\n    · exact hf.map g hg.continuous\n    · use ∏' i, f i\n      exact hf.map_tprod g hg.continuous\n  · rintro ⟨hgf, a, ha⟩\n    use a\n    have := hgf.hasProd\n    simp_rw [comp_apply, ← ha] at this\n    exact (hg.hasProd_iff f a).mp this\n\n"}
{"name":"Inducing.multipliable_iff_tprod_comp_mem_range","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁶ : CommMonoid α\ninst✝⁵ : TopologicalSpace α\ninst✝⁴ : CommMonoid γ\ninst✝³ : TopologicalSpace γ\ninst✝² : T2Space γ\nG : Type u_4\ninst✝¹ : FunLike G α γ\ninst✝ : MonoidHomClass G α γ\ng : G\nhg : Topology.IsInducing ⇑g\nf : β → α\n⊢ Iff (Multipliable f) (And (Multipliable (Function.comp (⇑g) f)) (Membership.mem (Set.range ⇑g) (tprod fun i => g (f i))))","decl":"@[deprecated (since := \"2024-10-28\")]\nalias Inducing.multipliable_iff_tprod_comp_mem_range :=\n  IsInducing.multipliable_iff_tprod_comp_mem_range\n\n"}
{"name":"Multipliable.map_iff_of_equiv","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : CommMonoid α\ninst✝⁴ : TopologicalSpace α\nf : β → α\ninst✝³ : CommMonoid γ\ninst✝² : TopologicalSpace γ\nG : Type u_4\ninst✝¹ : EquivLike G α γ\ninst✝ : MulEquivClass G α γ\ng : G\nhg : Continuous ⇑g\nhg' : Continuous (EquivLike.inv g)\n⊢ Iff (Multipliable (Function.comp (⇑g) f)) (Multipliable f)","decl":"/-- \"A special case of `Multipliable.map_iff_of_leftInverse` for convenience\" -/\n@[to_additive \"A special case of `Summable.map_iff_of_leftInverse` for convenience\"]\nprotected theorem Multipliable.map_iff_of_equiv [CommMonoid γ] [TopologicalSpace γ] {G}\n    [EquivLike G α γ] [MulEquivClass G α γ] (g : G) (hg : Continuous g)\n    (hg' : Continuous (EquivLike.inv g : γ → α)) : Multipliable (g ∘ f) ↔ Multipliable f :=\n  Multipliable.map_iff_of_leftInverse g (g : α ≃* γ).symm hg hg' (EquivLike.left_inv g)\n\n"}
{"name":"Summable.map_iff_of_equiv","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁵ : AddCommMonoid α\ninst✝⁴ : TopologicalSpace α\nf : β → α\ninst✝³ : AddCommMonoid γ\ninst✝² : TopologicalSpace γ\nG : Type u_4\ninst✝¹ : EquivLike G α γ\ninst✝ : AddEquivClass G α γ\ng : G\nhg : Continuous ⇑g\nhg' : Continuous (EquivLike.inv g)\n⊢ Iff (Summable (Function.comp (⇑g) f)) (Summable f)","decl":"/-- \"A special case of `Multipliable.map_iff_of_leftInverse` for convenience\" -/\n@[to_additive \"A special case of `Summable.map_iff_of_leftInverse` for convenience\"]\nprotected theorem Multipliable.map_iff_of_equiv [CommMonoid γ] [TopologicalSpace γ] {G}\n    [EquivLike G α γ] [MulEquivClass G α γ] (g : G) (hg : Continuous g)\n    (hg' : Continuous (EquivLike.inv g : γ → α)) : Multipliable (g ∘ f) ↔ Multipliable f :=\n  Multipliable.map_iff_of_leftInverse g (g : α ≃* γ).symm hg hg' (EquivLike.left_inv g)\n\n"}
{"name":"Function.Surjective.summable_iff_of_hasSum_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\nα' : Type u_4\ninst✝¹ : AddCommMonoid α'\ninst✝ : TopologicalSpace α'\ne : α' → α\nhes : Function.Surjective e\nf : β → α\ng : γ → α'\nhe : ∀ {a : α'}, Iff (HasSum f (e a)) (HasSum g a)\n⊢ Iff (Summable f) (Summable g)","decl":"@[to_additive]\ntheorem Function.Surjective.multipliable_iff_of_hasProd_iff {α' : Type*} [CommMonoid α']\n    [TopologicalSpace α'] {e : α' → α} (hes : Function.Surjective e) {f : β → α} {g : γ → α'}\n    (he : ∀ {a}, HasProd f (e a) ↔ HasProd g a) : Multipliable f ↔ Multipliable g :=\n  hes.exists.trans <| exists_congr <| @he\n\n"}
{"name":"Function.Surjective.multipliable_iff_of_hasProd_iff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\nα' : Type u_4\ninst✝¹ : CommMonoid α'\ninst✝ : TopologicalSpace α'\ne : α' → α\nhes : Function.Surjective e\nf : β → α\ng : γ → α'\nhe : ∀ {a : α'}, Iff (HasProd f (e a)) (HasProd g a)\n⊢ Iff (Multipliable f) (Multipliable g)","decl":"@[to_additive]\ntheorem Function.Surjective.multipliable_iff_of_hasProd_iff {α' : Type*} [CommMonoid α']\n    [TopologicalSpace α'] {e : α' → α} (hes : Function.Surjective e) {f : β → α} {g : γ → α'}\n    (he : ∀ {a}, HasProd f (e a) ↔ HasProd g a) : Multipliable f ↔ Multipliable g :=\n  hes.exists.trans <| exists_congr <| @he\n\n"}
{"name":"HasSum.add","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf g : β → α\na b : α\ninst✝ : ContinuousAdd α\nhf : HasSum f a\nhg : HasSum g b\n⊢ HasSum (fun b => HAdd.hAdd (f b) (g b)) (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem HasProd.mul (hf : HasProd f a) (hg : HasProd g b) :\n    HasProd (fun b ↦ f b * g b) (a * b) := by\n  dsimp only [HasProd] at hf hg ⊢\n  simp_rw [prod_mul_distrib]\n  exact hf.mul hg\n\n"}
{"name":"HasProd.mul","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf g : β → α\na b : α\ninst✝ : ContinuousMul α\nhf : HasProd f a\nhg : HasProd g b\n⊢ HasProd (fun b => HMul.hMul (f b) (g b)) (HMul.hMul a b)","decl":"@[to_additive]\ntheorem HasProd.mul (hf : HasProd f a) (hg : HasProd g b) :\n    HasProd (fun b ↦ f b * g b) (a * b) := by\n  dsimp only [HasProd] at hf hg ⊢\n  simp_rw [prod_mul_distrib]\n  exact hf.mul hg\n\n"}
{"name":"Summable.add","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf g : β → α\ninst✝ : ContinuousAdd α\nhf : Summable f\nhg : Summable g\n⊢ Summable fun b => HAdd.hAdd (f b) (g b)","decl":"@[to_additive]\ntheorem Multipliable.mul (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable fun b ↦ f b * g b :=\n  (hf.hasProd.mul hg.hasProd).multipliable\n\n"}
{"name":"Multipliable.mul","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf g : β → α\ninst✝ : ContinuousMul α\nhf : Multipliable f\nhg : Multipliable g\n⊢ Multipliable fun b => HMul.hMul (f b) (g b)","decl":"@[to_additive]\ntheorem Multipliable.mul (hf : Multipliable f) (hg : Multipliable g) :\n    Multipliable fun b ↦ f b * g b :=\n  (hf.hasProd.mul hg.hasProd).multipliable\n\n"}
{"name":"hasSum_sum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousAdd α\nf : γ → β → α\na : γ → α\ns : Finset γ\na✝ : ∀ (i : γ), Membership.mem s i → HasSum (f i) (a i)\n⊢ HasSum (fun b => s.sum fun i => f i b) (s.sum fun i => a i)","decl":"@[to_additive]\ntheorem hasProd_prod {f : γ → β → α} {a : γ → α} {s : Finset γ} :\n    (∀ i ∈ s, HasProd (f i) (a i)) → HasProd (fun b ↦ ∏ i ∈ s, f i b) (∏ i ∈ s, a i) := by\n  classical\n  exact Finset.induction_on s (by simp only [hasProd_one, prod_empty, forall_true_iff]) <| by\n    simp +contextual only [mem_insert, forall_eq_or_imp, not_false_iff,\n      prod_insert, and_imp]\n    exact fun x s _ IH hx h ↦ hx.mul (IH h)\n\n"}
{"name":"hasProd_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousMul α\nf : γ → β → α\na : γ → α\ns : Finset γ\na✝ : ∀ (i : γ), Membership.mem s i → HasProd (f i) (a i)\n⊢ HasProd (fun b => s.prod fun i => f i b) (s.prod fun i => a i)","decl":"@[to_additive]\ntheorem hasProd_prod {f : γ → β → α} {a : γ → α} {s : Finset γ} :\n    (∀ i ∈ s, HasProd (f i) (a i)) → HasProd (fun b ↦ ∏ i ∈ s, f i b) (∏ i ∈ s, a i) := by\n  classical\n  exact Finset.induction_on s (by simp only [hasProd_one, prod_empty, forall_true_iff]) <| by\n    simp +contextual only [mem_insert, forall_eq_or_imp, not_false_iff,\n      prod_insert, and_imp]\n    exact fun x s _ IH hx h ↦ hx.mul (IH h)\n\n"}
{"name":"multipliable_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousMul α\nf : γ → β → α\ns : Finset γ\nhf : ∀ (i : γ), Membership.mem s i → Multipliable (f i)\n⊢ Multipliable fun b => s.prod fun i => f i b","decl":"@[to_additive]\ntheorem multipliable_prod {f : γ → β → α} {s : Finset γ} (hf : ∀ i ∈ s, Multipliable (f i)) :\n    Multipliable fun b ↦ ∏ i ∈ s, f i b :=\n  (hasProd_prod fun i hi ↦ (hf i hi).hasProd).multipliable\n\n"}
{"name":"summable_sum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : ContinuousAdd α\nf : γ → β → α\ns : Finset γ\nhf : ∀ (i : γ), Membership.mem s i → Summable (f i)\n⊢ Summable fun b => s.sum fun i => f i b","decl":"@[to_additive]\ntheorem multipliable_prod {f : γ → β → α} {s : Finset γ} (hf : ∀ i ∈ s, Multipliable (f i)) :\n    Multipliable fun b ↦ ∏ i ∈ s, f i b :=\n  (hasProd_prod fun i hi ↦ (hf i hi).hasProd).multipliable\n\n"}
{"name":"HasProd.mul_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousMul α\ns t : Set β\nhs : Disjoint s t\nha : HasProd (Function.comp f Subtype.val) a\nhb : HasProd (Function.comp f Subtype.val) b\n⊢ HasProd (Function.comp f Subtype.val) (HMul.hMul a b)","decl":"@[to_additive]\ntheorem HasProd.mul_disjoint {s t : Set β} (hs : Disjoint s t) (ha : HasProd (f ∘ (↑) : s → α) a)\n    (hb : HasProd (f ∘ (↑) : t → α) b) : HasProd (f ∘ (↑) : (s ∪ t : Set β) → α) (a * b) := by\n  rw [hasProd_subtype_iff_mulIndicator] at *\n  rw [Set.mulIndicator_union_of_disjoint hs]\n  exact ha.mul hb\n\n"}
{"name":"HasSum.add_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousAdd α\ns t : Set β\nhs : Disjoint s t\nha : HasSum (Function.comp f Subtype.val) a\nhb : HasSum (Function.comp f Subtype.val) b\n⊢ HasSum (Function.comp f Subtype.val) (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem HasProd.mul_disjoint {s t : Set β} (hs : Disjoint s t) (ha : HasProd (f ∘ (↑) : s → α) a)\n    (hb : HasProd (f ∘ (↑) : t → α) b) : HasProd (f ∘ (↑) : (s ∪ t : Set β) → α) (a * b) := by\n  rw [hasProd_subtype_iff_mulIndicator] at *\n  rw [Set.mulIndicator_union_of_disjoint hs]\n  exact ha.mul hb\n\n"}
{"name":"hasSum_sum_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : ContinuousAdd α\nι : Type u_4\ns : Finset ι\nt : ι → Set β\na : ι → α\nhs : (↑s).Pairwise (Function.onFun Disjoint t)\nhf : ∀ (i : ι), Membership.mem s i → HasSum (Function.comp f Subtype.val) (a i)\n⊢ HasSum (Function.comp f Subtype.val) (s.sum fun i => a i)","decl":"@[to_additive]\ntheorem hasProd_prod_disjoint {ι} (s : Finset ι) {t : ι → Set β} {a : ι → α}\n    (hs : (s : Set ι).Pairwise (Disjoint on t)) (hf : ∀ i ∈ s, HasProd (f ∘ (↑) : t i → α) (a i)) :\n    HasProd (f ∘ (↑) : (⋃ i ∈ s, t i) → α) (∏ i ∈ s, a i) := by\n  simp_rw [hasProd_subtype_iff_mulIndicator] at *\n  rw [Finset.mulIndicator_biUnion _ _ hs]\n  exact hasProd_prod hf\n\n"}
{"name":"hasProd_prod_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : ContinuousMul α\nι : Type u_4\ns : Finset ι\nt : ι → Set β\na : ι → α\nhs : (↑s).Pairwise (Function.onFun Disjoint t)\nhf : ∀ (i : ι), Membership.mem s i → HasProd (Function.comp f Subtype.val) (a i)\n⊢ HasProd (Function.comp f Subtype.val) (s.prod fun i => a i)","decl":"@[to_additive]\ntheorem hasProd_prod_disjoint {ι} (s : Finset ι) {t : ι → Set β} {a : ι → α}\n    (hs : (s : Set ι).Pairwise (Disjoint on t)) (hf : ∀ i ∈ s, HasProd (f ∘ (↑) : t i → α) (a i)) :\n    HasProd (f ∘ (↑) : (⋃ i ∈ s, t i) → α) (∏ i ∈ s, a i) := by\n  simp_rw [hasProd_subtype_iff_mulIndicator] at *\n  rw [Finset.mulIndicator_biUnion _ _ hs]\n  exact hasProd_prod hf\n\n"}
{"name":"HasProd.mul_isCompl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousMul α\ns t : Set β\nhs : IsCompl s t\nha : HasProd (Function.comp f Subtype.val) a\nhb : HasProd (Function.comp f Subtype.val) b\n⊢ HasProd f (HMul.hMul a b)","decl":"@[to_additive]\ntheorem HasProd.mul_isCompl {s t : Set β} (hs : IsCompl s t) (ha : HasProd (f ∘ (↑) : s → α) a)\n    (hb : HasProd (f ∘ (↑) : t → α) b) : HasProd f (a * b) := by\n  simpa [← hs.compl_eq] using\n    (hasProd_subtype_iff_mulIndicator.1 ha).mul (hasProd_subtype_iff_mulIndicator.1 hb)\n\n"}
{"name":"HasSum.add_isCompl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousAdd α\ns t : Set β\nhs : IsCompl s t\nha : HasSum (Function.comp f Subtype.val) a\nhb : HasSum (Function.comp f Subtype.val) b\n⊢ HasSum f (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem HasProd.mul_isCompl {s t : Set β} (hs : IsCompl s t) (ha : HasProd (f ∘ (↑) : s → α) a)\n    (hb : HasProd (f ∘ (↑) : t → α) b) : HasProd f (a * b) := by\n  simpa [← hs.compl_eq] using\n    (hasProd_subtype_iff_mulIndicator.1 ha).mul (hasProd_subtype_iff_mulIndicator.1 hb)\n\n"}
{"name":"HasProd.mul_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousMul α\ns : Set β\nha : HasProd (Function.comp f Subtype.val) a\nhb : HasProd (Function.comp f Subtype.val) b\n⊢ HasProd f (HMul.hMul a b)","decl":"@[to_additive]\ntheorem HasProd.mul_compl {s : Set β} (ha : HasProd (f ∘ (↑) : s → α) a)\n    (hb : HasProd (f ∘ (↑) : (sᶜ : Set β) → α) b) : HasProd f (a * b) :=\n  ha.mul_isCompl isCompl_compl hb\n\n"}
{"name":"HasSum.add_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousAdd α\ns : Set β\nha : HasSum (Function.comp f Subtype.val) a\nhb : HasSum (Function.comp f Subtype.val) b\n⊢ HasSum f (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem HasProd.mul_compl {s : Set β} (ha : HasProd (f ∘ (↑) : s → α) a)\n    (hb : HasProd (f ∘ (↑) : (sᶜ : Set β) → α) b) : HasProd f (a * b) :=\n  ha.mul_isCompl isCompl_compl hb\n\n"}
{"name":"Summable.add_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : ContinuousAdd α\ns : Set β\nhs : Summable (Function.comp f Subtype.val)\nhsc : Summable (Function.comp f Subtype.val)\n⊢ Summable f","decl":"@[to_additive]\ntheorem Multipliable.mul_compl {s : Set β} (hs : Multipliable (f ∘ (↑) : s → α))\n    (hsc : Multipliable (f ∘ (↑) : (sᶜ : Set β) → α)) : Multipliable f :=\n  (hs.hasProd.mul_compl hsc.hasProd).multipliable\n\n"}
{"name":"Multipliable.mul_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : ContinuousMul α\ns : Set β\nhs : Multipliable (Function.comp f Subtype.val)\nhsc : Multipliable (Function.comp f Subtype.val)\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem Multipliable.mul_compl {s : Set β} (hs : Multipliable (f ∘ (↑) : s → α))\n    (hsc : Multipliable (f ∘ (↑) : (sᶜ : Set β) → α)) : Multipliable f :=\n  (hs.hasProd.mul_compl hsc.hasProd).multipliable\n\n"}
{"name":"HasSum.compl_add","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousAdd α\ns : Set β\nha : HasSum (Function.comp f Subtype.val) a\nhb : HasSum (Function.comp f Subtype.val) b\n⊢ HasSum f (HAdd.hAdd a b)","decl":"@[to_additive]\ntheorem HasProd.compl_mul {s : Set β} (ha : HasProd (f ∘ (↑) : (sᶜ : Set β) → α) a)\n    (hb : HasProd (f ∘ (↑) : s → α) b) : HasProd f (a * b) :=\n  ha.mul_isCompl isCompl_compl.symm hb\n\n"}
{"name":"HasProd.compl_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\na b : α\ninst✝ : ContinuousMul α\ns : Set β\nha : HasProd (Function.comp f Subtype.val) a\nhb : HasProd (Function.comp f Subtype.val) b\n⊢ HasProd f (HMul.hMul a b)","decl":"@[to_additive]\ntheorem HasProd.compl_mul {s : Set β} (ha : HasProd (f ∘ (↑) : (sᶜ : Set β) → α) a)\n    (hb : HasProd (f ∘ (↑) : s → α) b) : HasProd f (a * b) :=\n  ha.mul_isCompl isCompl_compl.symm hb\n\n"}
{"name":"Multipliable.compl_add","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : ContinuousMul α\ns : Set β\nhs : Multipliable (Function.comp f Subtype.val)\nhsc : Multipliable (Function.comp f Subtype.val)\n⊢ Multipliable f","decl":"@[to_additive]\ntheorem Multipliable.compl_add {s : Set β} (hs : Multipliable (f ∘ (↑) : (sᶜ : Set β) → α))\n    (hsc : Multipliable (f ∘ (↑) : s → α)) : Multipliable f :=\n  (hs.hasProd.compl_mul hsc.hasProd).multipliable\n\n"}
{"name":"Summable.compl_add","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : ContinuousAdd α\ns : Set β\nhs : Summable (Function.comp f Subtype.val)\nhsc : Summable (Function.comp f Subtype.val)\n⊢ Summable f","decl":"@[to_additive]\ntheorem Multipliable.compl_add {s : Set β} (hs : Multipliable (f ∘ (↑) : (sᶜ : Set β) → α))\n    (hsc : Multipliable (f ∘ (↑) : s → α)) : Multipliable f :=\n  (hs.hasProd.compl_mul hsc.hasProd).multipliable\n\n"}
{"name":"HasProd.update'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CommMonoid α\ninst✝² : T2Space α\ninst✝¹ : ContinuousMul α\ninst✝ : DecidableEq β\nf : β → α\na a' : α\nhf : HasProd f a\nb : β\nx : α\nhf' : HasProd (Function.update f b x) a'\n⊢ Eq (HMul.hMul a x) (HMul.hMul a' (f b))","decl":"/-- Version of `HasProd.update` for `CommMonoid` rather than `CommGroup`.\nRather than showing that `f.update` has a specific product in terms of `HasProd`,\nit gives a relationship between the products of `f` and `f.update` given that both exist. -/\n@[to_additive \"Version of `HasSum.update` for `AddCommMonoid` rather than `AddCommGroup`.\nRather than showing that `f.update` has a specific sum in terms of `HasSum`,\nit gives a relationship between the sums of `f` and `f.update` given that both exist.\"]\ntheorem HasProd.update' {α β : Type*} [TopologicalSpace α] [CommMonoid α] [T2Space α]\n    [ContinuousMul α] [DecidableEq β] {f : β → α} {a a' : α} (hf : HasProd f a) (b : β) (x : α)\n    (hf' : HasProd (update f b x) a') : a * x = a' * f b := by\n  have : ∀ b', f b' * ite (b' = b) x 1 = update f b x b' * ite (b' = b) (f b) 1 := by\n    intro b'\n    split_ifs with hb'\n    · simpa only [Function.update_apply, hb', eq_self_iff_true] using mul_comm (f b) x\n    · simp only [Function.update_apply, hb', if_false]\n  have h := hf.mul (hasProd_ite_eq b x)\n  simp_rw [this] at h\n  exact HasProd.unique h (hf'.mul (hasProd_ite_eq b (f b)))\n\n"}
{"name":"HasSum.update'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddCommMonoid α\ninst✝² : T2Space α\ninst✝¹ : ContinuousAdd α\ninst✝ : DecidableEq β\nf : β → α\na a' : α\nhf : HasSum f a\nb : β\nx : α\nhf' : HasSum (Function.update f b x) a'\n⊢ Eq (HAdd.hAdd a x) (HAdd.hAdd a' (f b))","decl":"/-- Version of `HasProd.update` for `CommMonoid` rather than `CommGroup`.\nRather than showing that `f.update` has a specific product in terms of `HasProd`,\nit gives a relationship between the products of `f` and `f.update` given that both exist. -/\n@[to_additive \"Version of `HasSum.update` for `AddCommMonoid` rather than `AddCommGroup`.\nRather than showing that `f.update` has a specific sum in terms of `HasSum`,\nit gives a relationship between the sums of `f` and `f.update` given that both exist.\"]\ntheorem HasProd.update' {α β : Type*} [TopologicalSpace α] [CommMonoid α] [T2Space α]\n    [ContinuousMul α] [DecidableEq β] {f : β → α} {a a' : α} (hf : HasProd f a) (b : β) (x : α)\n    (hf' : HasProd (update f b x) a') : a * x = a' * f b := by\n  have : ∀ b', f b' * ite (b' = b) x 1 = update f b x b' * ite (b' = b) (f b) 1 := by\n    intro b'\n    split_ifs with hb'\n    · simpa only [Function.update_apply, hb', eq_self_iff_true] using mul_comm (f b) x\n    · simp only [Function.update_apply, hb', if_false]\n  have h := hf.mul (hasProd_ite_eq b x)\n  simp_rw [this] at h\n  exact HasProd.unique h (hf'.mul (hasProd_ite_eq b (f b)))\n\n"}
{"name":"eq_add_of_hasSum_ite","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝⁴ : TopologicalSpace α\ninst✝³ : AddCommMonoid α\ninst✝² : T2Space α\ninst✝¹ : ContinuousAdd α\ninst✝ : DecidableEq β\nf : β → α\na : α\nhf : HasSum f a\nb : β\na' : α\nhf' : HasSum (fun n => ite (Eq n b) 0 (f n)) a'\n⊢ Eq a (HAdd.hAdd a' (f b))","decl":"/-- Version of `hasProd_ite_div_hasProd` for `CommMonoid` rather than `CommGroup`.\nRather than showing that the `ite` expression has a specific product in terms of `HasProd`, it gives\na relationship between the products of `f` and `ite (n = b) 0 (f n)` given that both exist. -/\n@[to_additive \"Version of `hasSum_ite_sub_hasSum` for `AddCommMonoid` rather than `AddCommGroup`.\nRather than showing that the `ite` expression has a specific sum in terms of `HasSum`,\nit gives a relationship between the sums of `f` and `ite (n = b) 0 (f n)` given that both exist.\"]\ntheorem eq_mul_of_hasProd_ite {α β : Type*} [TopologicalSpace α] [CommMonoid α] [T2Space α]\n    [ContinuousMul α] [DecidableEq β] {f : β → α} {a : α} (hf : HasProd f a) (b : β) (a' : α)\n    (hf' : HasProd (fun n ↦ ite (n = b) 1 (f n)) a') : a = a' * f b := by\n  refine (mul_one a).symm.trans (hf.update' b 1 ?_)\n  convert hf'\n  apply update_apply\n\n"}
{"name":"eq_mul_of_hasProd_ite","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝⁴ : TopologicalSpace α\ninst✝³ : CommMonoid α\ninst✝² : T2Space α\ninst✝¹ : ContinuousMul α\ninst✝ : DecidableEq β\nf : β → α\na : α\nhf : HasProd f a\nb : β\na' : α\nhf' : HasProd (fun n => ite (Eq n b) 1 (f n)) a'\n⊢ Eq a (HMul.hMul a' (f b))","decl":"/-- Version of `hasProd_ite_div_hasProd` for `CommMonoid` rather than `CommGroup`.\nRather than showing that the `ite` expression has a specific product in terms of `HasProd`, it gives\na relationship between the products of `f` and `ite (n = b) 0 (f n)` given that both exist. -/\n@[to_additive \"Version of `hasSum_ite_sub_hasSum` for `AddCommMonoid` rather than `AddCommGroup`.\nRather than showing that the `ite` expression has a specific sum in terms of `HasSum`,\nit gives a relationship between the sums of `f` and `ite (n = b) 0 (f n)` given that both exist.\"]\ntheorem eq_mul_of_hasProd_ite {α β : Type*} [TopologicalSpace α] [CommMonoid α] [T2Space α]\n    [ContinuousMul α] [DecidableEq β] {f : β → α} {a : α} (hf : HasProd f a) (b : β) (a' : α)\n    (hf' : HasProd (fun n ↦ ite (n = b) 1 (f n)) a') : a = a' * f b := by\n  refine (mul_one a).symm.trans (hf.update' b 1 ?_)\n  convert hf'\n  apply update_apply\n\n"}
{"name":"tsum_congr_set_coe","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns t : Set β\nh : Eq s t\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f ↑x)","decl":"@[to_additive]\ntheorem tprod_congr_set_coe (f : β → α) {s t : Set β} (h : s = t) :\n    ∏' x : s, f x = ∏' x : t, f x := by rw [h]\n\n"}
{"name":"tprod_congr_set_coe","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns t : Set β\nh : Eq s t\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f ↑x)","decl":"@[to_additive]\ntheorem tprod_congr_set_coe (f : β → α) {s t : Set β} (h : s = t) :\n    ∏' x : s, f x = ∏' x : t, f x := by rw [h]\n\n"}
{"name":"tsum_congr_subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nP Q : β → Prop\nh : ∀ (x : β), Iff (P x) (Q x)\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f ↑x)","decl":"@[to_additive]\ntheorem tprod_congr_subtype (f : β → α) {P Q : β → Prop} (h : ∀ x, P x ↔ Q x) :\n    ∏' x : {x // P x}, f x = ∏' x : {x // Q x}, f x :=\n  tprod_congr_set_coe f <| Set.ext h\n\n"}
{"name":"tprod_congr_subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nP Q : β → Prop\nh : ∀ (x : β), Iff (P x) (Q x)\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f ↑x)","decl":"@[to_additive]\ntheorem tprod_congr_subtype (f : β → α) {P Q : β → Prop} (h : ∀ x, P x ↔ Q x) :\n    ∏' x : {x // P x}, f x = ∏' x : {x // Q x}, f x :=\n  tprod_congr_set_coe f <| Set.ext h\n\n"}
{"name":"tprod_eq_finprod","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nhf : (Function.mulSupport f).Finite\n⊢ Eq (tprod fun b => f b) (finprod fun b => f b)","decl":"@[to_additive]\ntheorem tprod_eq_finprod (hf : (mulSupport f).Finite) :\n    ∏' b, f b = ∏ᶠ b, f b := by simp [tprod_def, multipliable_of_finite_mulSupport hf, hf]\n\n"}
{"name":"tsum_eq_finsum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nhf : (Function.support f).Finite\n⊢ Eq (tsum fun b => f b) (finsum fun b => f b)","decl":"@[to_additive]\ntheorem tprod_eq_finprod (hf : (mulSupport f).Finite) :\n    ∏' b, f b = ∏ᶠ b, f b := by simp [tprod_def, multipliable_of_finite_mulSupport hf, hf]\n\n"}
{"name":"tprod_eq_prod'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : HasSubset.Subset (Function.mulSupport f) ↑s\n⊢ Eq (tprod fun b => f b) (s.prod fun b => f b)","decl":"@[to_additive]\ntheorem tprod_eq_prod' {s : Finset β} (hf : mulSupport f ⊆ s) :\n    ∏' b, f b = ∏ b ∈ s, f b := by\n  rw [tprod_eq_finprod (s.finite_toSet.subset hf), finprod_eq_prod_of_mulSupport_subset _ hf]\n\n"}
{"name":"tsum_eq_sum'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : HasSubset.Subset (Function.support f) ↑s\n⊢ Eq (tsum fun b => f b) (s.sum fun b => f b)","decl":"@[to_additive]\ntheorem tprod_eq_prod' {s : Finset β} (hf : mulSupport f ⊆ s) :\n    ∏' b, f b = ∏ b ∈ s, f b := by\n  rw [tprod_eq_finprod (s.finite_toSet.subset hf), finprod_eq_prod_of_mulSupport_subset _ hf]\n\n"}
{"name":"tsum_eq_sum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : ∀ (b : β), Not (Membership.mem s b) → Eq (f b) 0\n⊢ Eq (tsum fun b => f b) (s.sum fun b => f b)","decl":"@[to_additive]\ntheorem tprod_eq_prod {s : Finset β} (hf : ∀ b ∉ s, f b = 1) :\n    ∏' b, f b = ∏ b ∈ s, f b :=\n  tprod_eq_prod' <| mulSupport_subset_iff'.2 hf\n\n"}
{"name":"tprod_eq_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\nhf : ∀ (b : β), Not (Membership.mem s b) → Eq (f b) 1\n⊢ Eq (tprod fun b => f b) (s.prod fun b => f b)","decl":"@[to_additive]\ntheorem tprod_eq_prod {s : Finset β} (hf : ∀ b ∉ s, f b = 1) :\n    ∏' b, f b = ∏ b ∈ s, f b :=\n  tprod_eq_prod' <| mulSupport_subset_iff'.2 hf\n\n"}
{"name":"tsum_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\n⊢ Eq (tsum fun x => 0) 0","decl":"@[to_additive (attr := simp)]\ntheorem tprod_one : ∏' _ : β, (1 : α) = 1 := by rw [tprod_eq_finprod] <;> simp\n\n"}
{"name":"tprod_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\n⊢ Eq (tprod fun x => 1) 1","decl":"@[to_additive (attr := simp)]\ntheorem tprod_one : ∏' _ : β, (1 : α) = 1 := by rw [tprod_eq_finprod] <;> simp\n\n"}
{"name":"tprod_empty","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : IsEmpty β\n⊢ Eq (tprod fun b => f b) 1","decl":"@[to_additive (attr := simp)]\ntheorem tprod_empty [IsEmpty β] : ∏' b, f b = 1 := by\n  rw [tprod_eq_prod (s := (∅ : Finset β))] <;> simp\n\n"}
{"name":"tsum_empty","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nf : β → α\ninst✝ : IsEmpty β\n⊢ Eq (tsum fun b => f b) 0","decl":"@[to_additive (attr := simp)]\ntheorem tprod_empty [IsEmpty β] : ∏' b, f b = 1 := by\n  rw [tprod_eq_prod (s := (∅ : Finset β))] <;> simp\n\n"}
{"name":"tsum_congr","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\nhfg : ∀ (b : β), Eq (f b) (g b)\n⊢ Eq (tsum fun b => f b) (tsum fun b => g b)","decl":"@[to_additive]\ntheorem tprod_congr {f g : β → α}\n    (hfg : ∀ b, f b = g b) : ∏' b, f b = ∏' b, g b :=\n  congr_arg tprod (funext hfg)\n\n"}
{"name":"tprod_congr","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf g : β → α\nhfg : ∀ (b : β), Eq (f b) (g b)\n⊢ Eq (tprod fun b => f b) (tprod fun b => g b)","decl":"@[to_additive]\ntheorem tprod_congr {f g : β → α}\n    (hfg : ∀ b, f b = g b) : ∏' b, f b = ∏' b, g b :=\n  congr_arg tprod (funext hfg)\n\n"}
{"name":"tsum_fintype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Fintype β\nf : β → α\n⊢ Eq (tsum fun b => f b) (Finset.univ.sum fun b => f b)","decl":"@[to_additive]\ntheorem tprod_fintype [Fintype β] (f : β → α) : ∏' b, f b = ∏ b, f b := by\n  apply tprod_eq_prod; simp\n\n"}
{"name":"tprod_fintype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : Fintype β\nf : β → α\n⊢ Eq (tprod fun b => f b) (Finset.univ.prod fun b => f b)","decl":"@[to_additive]\ntheorem tprod_fintype [Fintype β] (f : β → α) : ∏' b, f b = ∏ b, f b := by\n  apply tprod_eq_prod; simp\n\n"}
{"name":"sum_eq_tsum_indicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\n⊢ Eq (s.sum fun x => f x) (tsum fun x => (↑s).indicator f x)","decl":"@[to_additive]\ntheorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :\n    ∏ x ∈ s, f x = ∏' x, Set.mulIndicator (↑s) f x := by\n  rw [tprod_eq_prod' (Set.mulSupport_mulIndicator_subset),\n      Finset.prod_mulIndicator_subset _ Finset.Subset.rfl]\n\n"}
{"name":"prod_eq_tprod_mulIndicator","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Finset β\n⊢ Eq (s.prod fun x => f x) (tprod fun x => (↑s).mulIndicator f x)","decl":"@[to_additive]\ntheorem prod_eq_tprod_mulIndicator (f : β → α) (s : Finset β) :\n    ∏ x ∈ s, f x = ∏' x, Set.mulIndicator (↑s) f x := by\n  rw [tprod_eq_prod' (Set.mulSupport_mulIndicator_subset),\n      Finset.prod_mulIndicator_subset _ Finset.Subset.rfl]\n\n"}
{"name":"tsum_bool","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : Bool → α\n⊢ Eq (tsum fun i => f i) (HAdd.hAdd (f Bool.false) (f Bool.true))","decl":"@[to_additive]\ntheorem tprod_bool (f : Bool → α) : ∏' i : Bool, f i = f false * f true := by\n  rw [tprod_fintype, Fintype.prod_bool, mul_comm]\n\n"}
{"name":"tprod_bool","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : Bool → α\n⊢ Eq (tprod fun i => f i) (HMul.hMul (f Bool.false) (f Bool.true))","decl":"@[to_additive]\ntheorem tprod_bool (f : Bool → α) : ∏' i : Bool, f i = f false * f true := by\n  rw [tprod_fintype, Fintype.prod_bool, mul_comm]\n\n"}
{"name":"tprod_eq_mulSingle","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nb : β\nhf : ∀ (b' : β), Ne b' b → Eq (f b') 1\n⊢ Eq (tprod fun b => f b) (f b)","decl":"@[to_additive]\ntheorem tprod_eq_mulSingle {f : β → α} (b : β) (hf : ∀ b' ≠ b, f b' = 1) :\n    ∏' b, f b = f b := by\n  rw [tprod_eq_prod (s := {b}), prod_singleton]\n  exact fun b' hb' ↦ hf b' (by simpa using hb')\n\n"}
{"name":"tsum_eq_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\nb : β\nhf : ∀ (b' : β), Ne b' b → Eq (f b') 0\n⊢ Eq (tsum fun b => f b) (f b)","decl":"@[to_additive]\ntheorem tprod_eq_mulSingle {f : β → α} (b : β) (hf : ∀ b' ≠ b, f b' = 1) :\n    ∏' b, f b = f b := by\n  rw [tprod_eq_prod (s := {b}), prod_singleton]\n  exact fun b' hb' ↦ hf b' (by simpa using hb')\n\n"}
{"name":"tsum_tsum_eq_single","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → γ → α\nb : β\nc : γ\nhfb : ∀ (b' : β), Ne b' b → Eq (f b' c) 0\nhfc : ∀ (b' : β) (c' : γ), Ne c' c → Eq (f b' c') 0\n⊢ Eq (tsum fun b' => tsum fun c' => f b' c') (f b c)","decl":"@[to_additive]\ntheorem tprod_tprod_eq_mulSingle (f : β → γ → α) (b : β) (c : γ) (hfb : ∀ b' ≠ b, f b' c = 1)\n    (hfc : ∀ b', ∀ c' ≠ c, f b' c' = 1) : ∏' (b') (c'), f b' c' = f b c :=\n  calc\n    ∏' (b') (c'), f b' c' = ∏' b', f b' c := tprod_congr fun b' ↦ tprod_eq_mulSingle _ (hfc b')\n    _ = f b c := tprod_eq_mulSingle _ hfb\n\n"}
{"name":"tprod_tprod_eq_mulSingle","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → γ → α\nb : β\nc : γ\nhfb : ∀ (b' : β), Ne b' b → Eq (f b' c) 1\nhfc : ∀ (b' : β) (c' : γ), Ne c' c → Eq (f b' c') 1\n⊢ Eq (tprod fun b' => tprod fun c' => f b' c') (f b c)","decl":"@[to_additive]\ntheorem tprod_tprod_eq_mulSingle (f : β → γ → α) (b : β) (c : γ) (hfb : ∀ b' ≠ b, f b' c = 1)\n    (hfc : ∀ b', ∀ c' ≠ c, f b' c' = 1) : ∏' (b') (c'), f b' c' = f b c :=\n  calc\n    ∏' (b') (c'), f b' c' = ∏' b', f b' c := tprod_congr fun b' ↦ tprod_eq_mulSingle _ (hfc b')\n    _ = f b c := tprod_eq_mulSingle _ hfb\n\n"}
{"name":"tprod_ite_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nb : β\ninst✝ : DecidablePred fun x => Eq x b\na : α\n⊢ Eq (tprod fun b' => ite (Eq b' b) a 1) a","decl":"@[to_additive (attr := simp)]\ntheorem tprod_ite_eq (b : β) [DecidablePred (· = b)] (a : α) :\n    ∏' b', (if b' = b then a else 1) = a := by\n  rw [tprod_eq_mulSingle b]\n  · simp\n  · intro b' hb'; simp [hb']\n\n"}
{"name":"tsum_ite_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nb : β\ninst✝ : DecidablePred fun x => Eq x b\na : α\n⊢ Eq (tsum fun b' => ite (Eq b' b) a 0) a","decl":"@[to_additive (attr := simp)]\ntheorem tprod_ite_eq (b : β) [DecidablePred (· = b)] (a : α) :\n    ∏' b', (if b' = b then a else 1) = a := by\n  rw [tprod_eq_mulSingle b]\n  · simp\n  · intro b' hb'; simp [hb']\n\n"}
{"name":"Finset.tprod_subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ Eq (tprod fun x => f ↑x) (s.prod fun x => f x)","decl":"@[to_additive (attr := simp)]\ntheorem Finset.tprod_subtype (s : Finset β) (f : β → α) :\n    ∏' x : { x // x ∈ s }, f x = ∏ x ∈ s, f x := by\n  rw [← prod_attach]; exact tprod_fintype _\n\n"}
{"name":"Finset.tsum_subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ Eq (tsum fun x => f ↑x) (s.sum fun x => f x)","decl":"@[to_additive (attr := simp)]\ntheorem Finset.tprod_subtype (s : Finset β) (f : β → α) :\n    ∏' x : { x // x ∈ s }, f x = ∏ x ∈ s, f x := by\n  rw [← prod_attach]; exact tprod_fintype _\n\n"}
{"name":"Finset.tsum_subtype'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ Eq (tsum fun x => f ↑x) (s.sum fun x => f x)","decl":"@[to_additive]\ntheorem Finset.tprod_subtype' (s : Finset β) (f : β → α) :\n    ∏' x : (s : Set β), f x = ∏ x ∈ s, f x := by simp\n\n"}
{"name":"Finset.tprod_subtype'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Finset β\nf : β → α\n⊢ Eq (tprod fun x => f ↑x) (s.prod fun x => f x)","decl":"@[to_additive]\ntheorem Finset.tprod_subtype' (s : Finset β) (f : β → α) :\n    ∏' x : (s : Set β), f x = ∏ x ∈ s, f x := by simp\n\n"}
{"name":"tsum_singleton","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nb : β\nf : β → α\n⊢ Eq (tsum fun x => f ↑x) (f b)","decl":"@[to_additive (attr := simp)]\ntheorem tprod_singleton (b : β) (f : β → α) : ∏' x : ({b} : Set β), f x = f b := by\n  rw [← coe_singleton, Finset.tprod_subtype', prod_singleton]\n\n"}
{"name":"tprod_singleton","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nb : β\nf : β → α\n⊢ Eq (tprod fun x => f ↑x) (f b)","decl":"@[to_additive (attr := simp)]\ntheorem tprod_singleton (b : β) (f : β → α) : ∏' x : ({b} : Set β), f x = f b := by\n  rw [← coe_singleton, Finset.tprod_subtype', prod_singleton]\n\n"}
{"name":"Function.Injective.tsum_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ng : γ → β\nhg : Function.Injective g\nf : β → α\nhf : HasSubset.Subset (Function.support f) (Set.range g)\n⊢ Eq (tsum fun c => f (g c)) (tsum fun b => f b)","decl":"open scoped Classical in\n@[to_additive]\ntheorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}\n    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b := by\n  have : mulSupport f = g '' mulSupport (f ∘ g) := by\n    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]\n  rw [← Function.comp_def]\n  by_cases hf_fin : (mulSupport f).Finite\n  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn\n    lift g to γ ↪ β using hg\n    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,\n      comp_apply, ← Finset.prod_map]\n    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl\n    simp [this]\n  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by\n      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin\n    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,\n      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]\n\n"}
{"name":"Function.Injective.tprod_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ng : γ → β\nhg : Function.Injective g\nf : β → α\nhf : HasSubset.Subset (Function.mulSupport f) (Set.range g)\n⊢ Eq (tprod fun c => f (g c)) (tprod fun b => f b)","decl":"open scoped Classical in\n@[to_additive]\ntheorem Function.Injective.tprod_eq {g : γ → β} (hg : Injective g) {f : β → α}\n    (hf : mulSupport f ⊆ Set.range g) : ∏' c, f (g c) = ∏' b, f b := by\n  have : mulSupport f = g '' mulSupport (f ∘ g) := by\n    rw [mulSupport_comp_eq_preimage, Set.image_preimage_eq_iff.2 hf]\n  rw [← Function.comp_def]\n  by_cases hf_fin : (mulSupport f).Finite\n  · have hfg_fin : (mulSupport (f ∘ g)).Finite := hf_fin.preimage hg.injOn\n    lift g to γ ↪ β using hg\n    simp_rw [tprod_eq_prod' hf_fin.coe_toFinset.ge, tprod_eq_prod' hfg_fin.coe_toFinset.ge,\n      comp_apply, ← Finset.prod_map]\n    refine Finset.prod_congr (Finset.coe_injective ?_) fun _ _ ↦ rfl\n    simp [this]\n  · have hf_fin' : ¬ Set.Finite (mulSupport (f ∘ g)) := by\n      rwa [this, Set.finite_image_iff hg.injOn] at hf_fin\n    simp_rw [tprod_def, if_neg hf_fin, if_neg hf_fin', Multipliable,\n      funext fun a => propext <| hg.hasProd_iff (mulSupport_subset_iff'.1 hf) (a := a)]\n\n"}
{"name":"Equiv.tsum_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ne : Equiv γ β\nf : β → α\n⊢ Eq (tsum fun c => f (e c)) (tsum fun b => f b)","decl":"@[to_additive]\ntheorem Equiv.tprod_eq (e : γ ≃ β) (f : β → α) : ∏' c, f (e c) = ∏' b, f b :=\n  e.injective.tprod_eq <| by simp\n\n"}
{"name":"Equiv.tprod_eq","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ne : Equiv γ β\nf : β → α\n⊢ Eq (tprod fun c => f (e c)) (tprod fun b => f b)","decl":"@[to_additive]\ntheorem Equiv.tprod_eq (e : γ ≃ β) (f : β → α) : ∏' c, f (e c) = ∏' b, f b :=\n  e.injective.tprod_eq <| by simp\n\n"}
{"name":"tsum_subtype_eq_of_support_subset","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Set β\nhs : HasSubset.Subset (Function.support f) s\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_eq_of_mulSupport_subset {f : β → α} {s : Set β} (hs : mulSupport f ⊆ s) :\n    ∏' x : s, f x = ∏' x, f x :=\n  Subtype.val_injective.tprod_eq <| by simpa\n\n"}
{"name":"tprod_subtype_eq_of_mulSupport_subset","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Set β\nhs : HasSubset.Subset (Function.mulSupport f) s\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_eq_of_mulSupport_subset {f : β → α} {s : Set β} (hs : mulSupport f ⊆ s) :\n    ∏' x : s, f x = ∏' x, f x :=\n  Subtype.val_injective.tprod_eq <| by simpa\n\n"}
{"name":"tsum_subtype_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_mulSupport (f : β → α) : ∏' x : mulSupport f, f x = ∏' x, f x :=\n  tprod_subtype_eq_of_mulSupport_subset Set.Subset.rfl\n\n"}
{"name":"tprod_subtype_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem tprod_subtype_mulSupport (f : β → α) : ∏' x : mulSupport f, f x = ∏' x, f x :=\n  tprod_subtype_eq_of_mulSupport_subset Set.Subset.rfl\n\n"}
{"name":"tprod_subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ns : Set β\nf : β → α\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => s.mulIndicator f x)","decl":"@[to_additive]\ntheorem tprod_subtype (s : Set β) (f : β → α) : ∏' x : s, f x = ∏' x, s.mulIndicator f x := by\n  rw [← tprod_subtype_eq_of_mulSupport_subset Set.mulSupport_mulIndicator_subset, tprod_congr]\n  simp\n\n"}
{"name":"tsum_subtype","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ns : Set β\nf : β → α\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => s.indicator f x)","decl":"@[to_additive]\ntheorem tprod_subtype (s : Set β) (f : β → α) : ∏' x : s, f x = ∏' x, s.mulIndicator f x := by\n  rw [← tprod_subtype_eq_of_mulSupport_subset Set.mulSupport_mulIndicator_subset, tprod_congr]\n  simp\n\n"}
{"name":"tsum_univ","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f x)","decl":"@[to_additive (attr := simp)]\ntheorem tprod_univ (f : β → α) : ∏' x : (Set.univ : Set β), f x = ∏' x, f x :=\n  tprod_subtype_eq_of_mulSupport_subset <| Set.subset_univ _\n\n"}
{"name":"tprod_univ","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f x)","decl":"@[to_additive (attr := simp)]\ntheorem tprod_univ (f : β → α) : ∏' x : (Set.univ : Set β), f x = ∏' x, f x :=\n  tprod_subtype_eq_of_mulSupport_subset <| Set.subset_univ _\n\n"}
{"name":"tprod_image","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ng : γ → β\nf : β → α\ns : Set γ\nhg : Set.InjOn g s\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f (g ↑x))","decl":"@[to_additive]\ntheorem tprod_image {g : γ → β} (f : β → α) {s : Set γ} (hg : Set.InjOn g s) :\n    ∏' x : g '' s, f x = ∏' x : s, f (g x) :=\n  ((Equiv.Set.imageOfInjOn _ _ hg).tprod_eq fun x ↦ f x).symm\n\n"}
{"name":"tsum_image","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ng : γ → β\nf : β → α\ns : Set γ\nhg : Set.InjOn g s\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f (g ↑x))","decl":"@[to_additive]\ntheorem tprod_image {g : γ → β} (f : β → α) {s : Set γ} (hg : Set.InjOn g s) :\n    ∏' x : g '' s, f x = ∏' x : s, f (g x) :=\n  ((Equiv.Set.imageOfInjOn _ _ hg).tprod_eq fun x ↦ f x).symm\n\n"}
{"name":"tsum_range","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\ng : γ → β\nf : β → α\nhg : Function.Injective g\n⊢ Eq (tsum fun x => f ↑x) (tsum fun x => f (g x))","decl":"@[to_additive]\ntheorem tprod_range {g : γ → β} (f : β → α) (hg : Injective g) :\n    ∏' x : Set.range g, f x = ∏' x, f (g x) := by\n  rw [← Set.image_univ, tprod_image f hg.injOn]\n  simp_rw [← comp_apply (g := g), tprod_univ (f ∘ g)]\n\n"}
{"name":"tprod_range","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\ng : γ → β\nf : β → α\nhg : Function.Injective g\n⊢ Eq (tprod fun x => f ↑x) (tprod fun x => f (g x))","decl":"@[to_additive]\ntheorem tprod_range {g : γ → β} (f : β → α) (hg : Injective g) :\n    ∏' x : Set.range g, f x = ∏' x, f (g x) := by\n  rw [← Set.image_univ, tprod_image f hg.injOn]\n  simp_rw [← comp_apply (g := g), tprod_univ (f ∘ g)]\n\n"}
{"name":"tprod_setElem_eq_tprod_setElem_diff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns t : Set β\nhf₀ : ∀ (b : β), Membership.mem t b → Eq (f b) 1\n⊢ Eq (tprod fun a => f ↑a) (tprod fun a => f ↑a)","decl":"/-- If `f b = 1` for all `b ∈ t`, then the product of `f a` with `a ∈ s` is the same as the\nproduct of `f a` with `a ∈ s ∖ t`. -/\n@[to_additive \"If `f b = 0` for all `b ∈ t`, then the sum of `f a` with `a ∈ s` is the same as the\nsum of `f a` with `a ∈ s ∖ t`.\"]\nlemma tprod_setElem_eq_tprod_setElem_diff {f : β → α} (s t : Set β)\n    (hf₀ : ∀ b ∈ t, f b = 1) :\n    ∏' a : s, f a = ∏' a : (s \\ t : Set β), f a :=\n  .symm <| (Set.inclusion_injective (t := s) Set.diff_subset).tprod_eq (f := f ∘ (↑)) <|\n    mulSupport_subset_iff'.2 fun b hb ↦ hf₀ b <| by simpa using hb\n\n"}
{"name":"tsum_setElem_eq_tsum_setElem_diff","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns t : Set β\nhf₀ : ∀ (b : β), Membership.mem t b → Eq (f b) 0\n⊢ Eq (tsum fun a => f ↑a) (tsum fun a => f ↑a)","decl":"/-- If `f b = 1` for all `b ∈ t`, then the product of `f a` with `a ∈ s` is the same as the\nproduct of `f a` with `a ∈ s ∖ t`. -/\n@[to_additive \"If `f b = 0` for all `b ∈ t`, then the sum of `f a` with `a ∈ s` is the same as the\nsum of `f a` with `a ∈ s ∖ t`.\"]\nlemma tprod_setElem_eq_tprod_setElem_diff {f : β → α} (s t : Set β)\n    (hf₀ : ∀ b ∈ t, f b = 1) :\n    ∏' a : s, f a = ∏' a : (s \\ t : Set β), f a :=\n  .symm <| (Set.inclusion_injective (t := s) Set.diff_subset).tprod_eq (f := f ∘ (↑)) <|\n    mulSupport_subset_iff'.2 fun b hb ↦ hf₀ b <| by simpa using hb\n\n"}
{"name":"tprod_eq_tprod_diff_singleton","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Set β\nb : β\nhf₀ : Eq (f b) 1\n⊢ Eq (tprod fun a => f ↑a) (tprod fun a => f ↑a)","decl":"/-- If `f b = 1`, then the product of `f a` with `a ∈ s` is the same as the product of `f a` for\n`a ∈ s ∖ {b}`. -/\n@[to_additive \"If `f b = 0`, then the sum of `f a` with `a ∈ s` is the same as the sum of `f a`\nfor `a ∈ s ∖ {b}`.\"]\nlemma tprod_eq_tprod_diff_singleton {f : β → α} (s : Set β) {b : β} (hf₀ : f b = 1) :\n    ∏' a : s, f a = ∏' a : (s \\ {b} : Set β), f a :=\n  tprod_setElem_eq_tprod_setElem_diff s {b} fun _ ha ↦ ha ▸ hf₀\n\n"}
{"name":"tsum_eq_tsum_diff_singleton","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ns : Set β\nb : β\nhf₀ : Eq (f b) 0\n⊢ Eq (tsum fun a => f ↑a) (tsum fun a => f ↑a)","decl":"/-- If `f b = 1`, then the product of `f a` with `a ∈ s` is the same as the product of `f a` for\n`a ∈ s ∖ {b}`. -/\n@[to_additive \"If `f b = 0`, then the sum of `f a` with `a ∈ s` is the same as the sum of `f a`\nfor `a ∈ s ∖ {b}`.\"]\nlemma tprod_eq_tprod_diff_singleton {f : β → α} (s : Set β) {b : β} (hf₀ : f b = 1) :\n    ∏' a : s, f a = ∏' a : (s \\ {b} : Set β), f a :=\n  tprod_setElem_eq_tprod_setElem_diff s {b} fun _ ha ↦ ha ▸ hf₀\n\n"}
{"name":"tsum_eq_tsum_of_ne_zero_bij","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → α\ni : ↑(Function.support g) → β\nhi : Function.Injective i\nhf : HasSubset.Subset (Function.support f) (Set.range i)\nhfg : ∀ (x : ↑(Function.support g)), Eq (f (i x)) (g ↑x)\n⊢ Eq (tsum fun x => f x) (tsum fun y => g y)","decl":"@[to_additive]\ntheorem tprod_eq_tprod_of_ne_one_bij {g : γ → α} (i : mulSupport g → β) (hi : Injective i)\n    (hf : mulSupport f ⊆ Set.range i) (hfg : ∀ x, f (i x) = g x) : ∏' x, f x = ∏' y, g y := by\n  rw [← tprod_subtype_mulSupport g, ← hi.tprod_eq hf]\n  simp only [hfg]\n\n"}
{"name":"tprod_eq_tprod_of_ne_one_bij","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → α\ni : ↑(Function.mulSupport g) → β\nhi : Function.Injective i\nhf : HasSubset.Subset (Function.mulSupport f) (Set.range i)\nhfg : ∀ (x : ↑(Function.mulSupport g)), Eq (f (i x)) (g ↑x)\n⊢ Eq (tprod fun x => f x) (tprod fun y => g y)","decl":"@[to_additive]\ntheorem tprod_eq_tprod_of_ne_one_bij {g : γ → α} (i : mulSupport g → β) (hi : Injective i)\n    (hf : mulSupport f ⊆ Set.range i) (hfg : ∀ x, f (i x) = g x) : ∏' x, f x = ∏' y, g y := by\n  rw [← tprod_subtype_mulSupport g, ← hi.tprod_eq hf]\n  simp only [hfg]\n\n"}
{"name":"Equiv.tprod_eq_tprod_of_mulSupport","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → α\ne : Equiv ↑(Function.mulSupport f) ↑(Function.mulSupport g)\nhe : ∀ (x : ↑(Function.mulSupport f)), Eq (g ↑(e x)) (f ↑x)\n⊢ Eq (tprod fun x => f x) (tprod fun y => g y)","decl":"@[to_additive]\ntheorem Equiv.tprod_eq_tprod_of_mulSupport {f : β → α} {g : γ → α}\n    (e : mulSupport f ≃ mulSupport g) (he : ∀ x, g (e x) = f x) :\n    ∏' x, f x = ∏' y, g y :=\n  .symm <| tprod_eq_tprod_of_ne_one_bij _ (Subtype.val_injective.comp e.injective) (by simp) he\n\n"}
{"name":"Equiv.tsum_eq_tsum_of_support","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nf : β → α\ng : γ → α\ne : Equiv ↑(Function.support f) ↑(Function.support g)\nhe : ∀ (x : ↑(Function.support f)), Eq (g ↑(e x)) (f ↑x)\n⊢ Eq (tsum fun x => f x) (tsum fun y => g y)","decl":"@[to_additive]\ntheorem Equiv.tprod_eq_tprod_of_mulSupport {f : β → α} {g : γ → α}\n    (e : mulSupport f ≃ mulSupport g) (he : ∀ x, g (e x) = f x) :\n    ∏' x, f x = ∏' y, g y :=\n  .symm <| tprod_eq_tprod_of_ne_one_bij _ (Subtype.val_injective.comp e.injective) (by simp) he\n\n"}
{"name":"tprod_dite_right","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nP : Prop\ninst✝ : Decidable P\nx : β → Not P → α\n⊢ Eq (tprod fun b => dite P (fun h => 1) fun h => x b h) (dite P (fun h => 1) fun h => tprod fun b => x b h)","decl":"@[to_additive]\ntheorem tprod_dite_right (P : Prop) [Decidable P] (x : β → ¬P → α) :\n    ∏' b : β, (if h : P then (1 : α) else x b h) = if h : P then (1 : α) else ∏' b : β, x b h := by\n  by_cases hP : P <;> simp [hP]\n\n"}
{"name":"tsum_dite_right","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nP : Prop\ninst✝ : Decidable P\nx : β → Not P → α\n⊢ Eq (tsum fun b => dite P (fun h => 0) fun h => x b h) (dite P (fun h => 0) fun h => tsum fun b => x b h)","decl":"@[to_additive]\ntheorem tprod_dite_right (P : Prop) [Decidable P] (x : β → ¬P → α) :\n    ∏' b : β, (if h : P then (1 : α) else x b h) = if h : P then (1 : α) else ∏' b : β, x b h := by\n  by_cases hP : P <;> simp [hP]\n\n"}
{"name":"tsum_dite_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\nP : Prop\ninst✝ : Decidable P\nx : β → P → α\n⊢ Eq (tsum fun b => dite P (fun h => x b h) fun h => 0) (dite P (fun h => tsum fun b => x b h) fun h => 0)","decl":"@[to_additive]\ntheorem tprod_dite_left (P : Prop) [Decidable P] (x : β → P → α) :\n    ∏' b : β, (if h : P then x b h else 1) = if h : P then ∏' b : β, x b h else 1 := by\n  by_cases hP : P <;> simp [hP]\n\n"}
{"name":"tprod_dite_left","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\nP : Prop\ninst✝ : Decidable P\nx : β → P → α\n⊢ Eq (tprod fun b => dite P (fun h => x b h) fun h => 1) (dite P (fun h => tprod fun b => x b h) fun h => 1)","decl":"@[to_additive]\ntheorem tprod_dite_left (P : Prop) [Decidable P] (x : β → P → α) :\n    ∏' b : β, (if h : P then x b h else 1) = if h : P then ∏' b : β, x b h else 1 := by\n  by_cases hP : P <;> simp [hP]\n\n"}
{"name":"tprod_extend_one","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : CommMonoid α\ninst✝ : TopologicalSpace α\nγ : Type u_4\ng : γ → β\nhg : Function.Injective g\nf : γ → α\n⊢ Eq (tprod fun y => Function.extend g f 1 y) (tprod fun x => f x)","decl":"@[to_additive (attr := simp)]\nlemma tprod_extend_one {γ : Type*} {g : γ → β} (hg : Injective g) (f : γ → α) :\n    ∏' y, extend g f 1 y = ∏' x, f x := by\n  have : mulSupport (extend g f 1) ⊆ Set.range g := mulSupport_subset_iff'.2 <| extend_apply' _ _\n  simp_rw [← hg.tprod_eq this, hg.extend_apply]\n\n"}
{"name":"tsum_extend_zero","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : AddCommMonoid α\ninst✝ : TopologicalSpace α\nγ : Type u_4\ng : γ → β\nhg : Function.Injective g\nf : γ → α\n⊢ Eq (tsum fun y => Function.extend g f 0 y) (tsum fun x => f x)","decl":"@[to_additive (attr := simp)]\nlemma tprod_extend_one {γ : Type*} {g : γ → β} (hg : Injective g) (f : γ → α) :\n    ∏' y, extend g f 1 y = ∏' x, f x := by\n  have : mulSupport (extend g f 1) ⊆ Set.range g := mulSupport_subset_iff'.2 <| extend_apply' _ _\n  simp_rw [← hg.tprod_eq this, hg.extend_apply]\n\n"}
{"name":"Function.Surjective.tsum_eq_tsum_of_hasSum_iff_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : AddCommMonoid α\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\nα' : Type u_4\ninst✝¹ : AddCommMonoid α'\ninst✝ : TopologicalSpace α'\ne : α' → α\nhes : Function.Surjective e\nh1 : Eq (e 0) 0\nf : β → α\ng : γ → α'\nh : ∀ {a : α'}, Iff (HasSum f (e a)) (HasSum g a)\n⊢ Eq (tsum fun b => f b) (e (tsum fun c => g c))","decl":"@[to_additive]\ntheorem Function.Surjective.tprod_eq_tprod_of_hasProd_iff_hasProd {α' : Type*} [CommMonoid α']\n    [TopologicalSpace α'] {e : α' → α} (hes : Function.Surjective e) (h1 : e 1 = 1) {f : β → α}\n    {g : γ → α'} (h : ∀ {a}, HasProd f (e a) ↔ HasProd g a) : ∏' b, f b = e (∏' c, g c) :=\n  by_cases (fun x ↦ (h.mpr x.hasProd).tprod_eq) fun hg : ¬Multipliable g ↦ by\n    have hf : ¬Multipliable f := mt (hes.multipliable_iff_of_hasProd_iff @h).1 hg\n    simp [tprod_def, hf, hg, h1]\n\n"}
{"name":"Function.Surjective.tprod_eq_tprod_of_hasProd_iff_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝⁴ : CommMonoid α\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\nα' : Type u_4\ninst✝¹ : CommMonoid α'\ninst✝ : TopologicalSpace α'\ne : α' → α\nhes : Function.Surjective e\nh1 : Eq (e 1) 1\nf : β → α\ng : γ → α'\nh : ∀ {a : α'}, Iff (HasProd f (e a)) (HasProd g a)\n⊢ Eq (tprod fun b => f b) (e (tprod fun c => g c))","decl":"@[to_additive]\ntheorem Function.Surjective.tprod_eq_tprod_of_hasProd_iff_hasProd {α' : Type*} [CommMonoid α']\n    [TopologicalSpace α'] {e : α' → α} (hes : Function.Surjective e) (h1 : e 1 = 1) {f : β → α}\n    {g : γ → α'} (h : ∀ {a}, HasProd f (e a) ↔ HasProd g a) : ∏' b, f b = e (∏' c, g c) :=\n  by_cases (fun x ↦ (h.mpr x.hasProd).tprod_eq) fun hg : ¬Multipliable g ↦ by\n    have hf : ¬Multipliable f := mt (hes.multipliable_iff_of_hasProd_iff @h).1 hg\n    simp [tprod_def, hf, hg, h1]\n\n"}
{"name":"tprod_eq_tprod_of_hasProd_iff_hasProd","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : CommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : T2Space α\nf : β → α\ng : γ → α\nh : ∀ {a : α}, Iff (HasProd f a) (HasProd g a)\n⊢ Eq (tprod fun b => f b) (tprod fun c => g c)","decl":"@[to_additive]\ntheorem tprod_eq_tprod_of_hasProd_iff_hasProd {f : β → α} {g : γ → α}\n    (h : ∀ {a}, HasProd f a ↔ HasProd g a) : ∏' b, f b = ∏' c, g c :=\n  surjective_id.tprod_eq_tprod_of_hasProd_iff_hasProd rfl @h\n\n"}
{"name":"tsum_eq_tsum_of_hasSum_iff_hasSum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝² : AddCommMonoid α\ninst✝¹ : TopologicalSpace α\ninst✝ : T2Space α\nf : β → α\ng : γ → α\nh : ∀ {a : α}, Iff (HasSum f a) (HasSum g a)\n⊢ Eq (tsum fun b => f b) (tsum fun c => g c)","decl":"@[to_additive]\ntheorem tprod_eq_tprod_of_hasProd_iff_hasProd {f : β → α} {g : γ → α}\n    (h : ∀ {a}, HasProd f a ↔ HasProd g a) : ∏' b, f b = ∏' c, g c :=\n  surjective_id.tprod_eq_tprod_of_hasProd_iff_hasProd rfl @h\n\n"}
{"name":"tprod_mul","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\nf g : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousMul α\nhf : Multipliable f\nhg : Multipliable g\n⊢ Eq (tprod fun b => HMul.hMul (f b) (g b)) (HMul.hMul (tprod fun b => f b) (tprod fun b => g b))","decl":"@[to_additive]\ntheorem tprod_mul (hf : Multipliable f) (hg : Multipliable g) :\n    ∏' b, (f b * g b) = (∏' b, f b) * ∏' b, g b :=\n  (hf.hasProd.mul hg.hasProd).tprod_eq\n\n"}
{"name":"tsum_add","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\nf g : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousAdd α\nhf : Summable f\nhg : Summable g\n⊢ Eq (tsum fun b => HAdd.hAdd (f b) (g b)) (HAdd.hAdd (tsum fun b => f b) (tsum fun b => g b))","decl":"@[to_additive]\ntheorem tprod_mul (hf : Multipliable f) (hg : Multipliable g) :\n    ∏' b, (f b * g b) = (∏' b, f b) * ∏' b, g b :=\n  (hf.hasProd.mul hg.hasProd).tprod_eq\n\n"}
{"name":"tsum_sum","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : T2Space α\ninst✝ : ContinuousAdd α\nf : γ → β → α\ns : Finset γ\nhf : ∀ (i : γ), Membership.mem s i → Summable (f i)\n⊢ Eq (tsum fun b => s.sum fun i => f i b) (s.sum fun i => tsum fun b => f i b)","decl":"@[to_additive tsum_sum]\ntheorem tprod_of_prod {f : γ → β → α} {s : Finset γ} (hf : ∀ i ∈ s, Multipliable (f i)) :\n    ∏' b, ∏ i ∈ s, f i b = ∏ i ∈ s, ∏' b, f i b :=\n  (hasProd_prod fun i hi ↦ (hf i hi).hasProd).tprod_eq\n\n"}
{"name":"tprod_of_prod","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\ninst✝¹ : T2Space α\ninst✝ : ContinuousMul α\nf : γ → β → α\ns : Finset γ\nhf : ∀ (i : γ), Membership.mem s i → Multipliable (f i)\n⊢ Eq (tprod fun b => s.prod fun i => f i b) (s.prod fun i => tprod fun b => f i b)","decl":"@[to_additive tsum_sum]\ntheorem tprod_of_prod {f : γ → β → α} {s : Finset γ} (hf : ∀ i ∈ s, Multipliable (f i)) :\n    ∏' b, ∏ i ∈ s, f i b = ∏ i ∈ s, ∏' b, f i b :=\n  (hasProd_prod fun i hi ↦ (hf i hi).hasProd).tprod_eq\n\n"}
{"name":"tprod_eq_mul_tprod_ite'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : CommMonoid α\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\ninst✝¹ : ContinuousMul α\ninst✝ : DecidableEq β\nf : β → α\nb : β\nhf : Multipliable (Function.update f b 1)\n⊢ Eq (tprod fun x => f x) (HMul.hMul (f b) (tprod fun x => ite (Eq x b) 1 (f x)))","decl":"/-- Version of `tprod_eq_mul_tprod_ite` for `CommMonoid` rather than `CommGroup`.\nRequires a different convergence assumption involving `Function.update`. -/\n@[to_additive \"Version of `tsum_eq_add_tsum_ite` for `AddCommMonoid` rather than `AddCommGroup`.\nRequires a different convergence assumption involving `Function.update`.\"]\ntheorem tprod_eq_mul_tprod_ite' [DecidableEq β] {f : β → α} (b : β)\n    (hf : Multipliable (update f b 1)) :\n    ∏' x, f x = f b * ∏' x, ite (x = b) 1 (f x) :=\n  calc\n    ∏' x, f x = ∏' x, (ite (x = b) (f x) 1 * update f b 1 x) :=\n      tprod_congr fun n ↦ by split_ifs with h <;> simp [update_apply, h]\n    _ = (∏' x, ite (x = b) (f x) 1) * ∏' x, update f b 1 x :=\n      tprod_mul ⟨ite (b = b) (f b) 1, hasProd_single b fun _ hb ↦ if_neg hb⟩ hf\n    _ = ite (b = b) (f b) 1 * ∏' x, update f b 1 x := by\n      congr\n      exact tprod_eq_mulSingle b fun b' hb' ↦ if_neg hb'\n    _ = f b * ∏' x, ite (x = b) 1 (f x) := by\n      simp only [update, eq_self_iff_true, if_true, eq_rec_constant, dite_eq_ite]\n\n"}
{"name":"tsum_eq_add_tsum_ite'","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝⁴ : AddCommMonoid α\ninst✝³ : TopologicalSpace α\ninst✝² : T2Space α\ninst✝¹ : ContinuousAdd α\ninst✝ : DecidableEq β\nf : β → α\nb : β\nhf : Summable (Function.update f b 0)\n⊢ Eq (tsum fun x => f x) (HAdd.hAdd (f b) (tsum fun x => ite (Eq x b) 0 (f x)))","decl":"/-- Version of `tprod_eq_mul_tprod_ite` for `CommMonoid` rather than `CommGroup`.\nRequires a different convergence assumption involving `Function.update`. -/\n@[to_additive \"Version of `tsum_eq_add_tsum_ite` for `AddCommMonoid` rather than `AddCommGroup`.\nRequires a different convergence assumption involving `Function.update`.\"]\ntheorem tprod_eq_mul_tprod_ite' [DecidableEq β] {f : β → α} (b : β)\n    (hf : Multipliable (update f b 1)) :\n    ∏' x, f x = f b * ∏' x, ite (x = b) 1 (f x) :=\n  calc\n    ∏' x, f x = ∏' x, (ite (x = b) (f x) 1 * update f b 1 x) :=\n      tprod_congr fun n ↦ by split_ifs with h <;> simp [update_apply, h]\n    _ = (∏' x, ite (x = b) (f x) 1) * ∏' x, update f b 1 x :=\n      tprod_mul ⟨ite (b = b) (f b) 1, hasProd_single b fun _ hb ↦ if_neg hb⟩ hf\n    _ = ite (b = b) (f b) 1 * ∏' x, update f b 1 x := by\n      congr\n      exact tprod_eq_mulSingle b fun b' hb' ↦ if_neg hb'\n    _ = f b * ∏' x, ite (x = b) 1 (f x) := by\n      simp only [update, eq_self_iff_true, if_true, eq_rec_constant, dite_eq_ite]\n\n"}
{"name":"tprod_mul_tprod_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousMul α\ns : Set β\nhs : Multipliable (Function.comp f Subtype.val)\nhsc : Multipliable (Function.comp f Subtype.val)\n⊢ Eq (HMul.hMul (tprod fun x => f ↑x) (tprod fun x => f ↑x)) (tprod fun x => f x)","decl":"@[to_additive]\ntheorem tprod_mul_tprod_compl {s : Set β} (hs : Multipliable (f ∘ (↑) : s → α))\n    (hsc : Multipliable (f ∘ (↑) : ↑sᶜ → α)) : (∏' x : s, f x) * ∏' x : ↑sᶜ, f x = ∏' x, f x :=\n  (hs.hasProd.mul_compl hsc.hasProd).tprod_eq.symm\n\n"}
{"name":"tsum_add_tsum_compl","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousAdd α\ns : Set β\nhs : Summable (Function.comp f Subtype.val)\nhsc : Summable (Function.comp f Subtype.val)\n⊢ Eq (HAdd.hAdd (tsum fun x => f ↑x) (tsum fun x => f ↑x)) (tsum fun x => f x)","decl":"@[to_additive]\ntheorem tprod_mul_tprod_compl {s : Set β} (hs : Multipliable (f ∘ (↑) : s → α))\n    (hsc : Multipliable (f ∘ (↑) : ↑sᶜ → α)) : (∏' x : s, f x) * ∏' x : ↑sᶜ, f x = ∏' x, f x :=\n  (hs.hasProd.mul_compl hsc.hasProd).tprod_eq.symm\n\n"}
{"name":"tsum_union_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousAdd α\ns t : Set β\nhd : Disjoint s t\nhs : Summable (Function.comp f Subtype.val)\nht : Summable (Function.comp f Subtype.val)\n⊢ Eq (tsum fun x => f ↑x) (HAdd.hAdd (tsum fun x => f ↑x) (tsum fun x => f ↑x))","decl":"@[to_additive]\ntheorem tprod_union_disjoint {s t : Set β} (hd : Disjoint s t) (hs : Multipliable (f ∘ (↑) : s → α))\n    (ht : Multipliable (f ∘ (↑) : t → α)) :\n    ∏' x : ↑(s ∪ t), f x = (∏' x : s, f x) * ∏' x : t, f x :=\n  (hs.hasProd.mul_disjoint hd ht.hasProd).tprod_eq\n\n"}
{"name":"tprod_union_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousMul α\ns t : Set β\nhd : Disjoint s t\nhs : Multipliable (Function.comp f Subtype.val)\nht : Multipliable (Function.comp f Subtype.val)\n⊢ Eq (tprod fun x => f ↑x) (HMul.hMul (tprod fun x => f ↑x) (tprod fun x => f ↑x))","decl":"@[to_additive]\ntheorem tprod_union_disjoint {s t : Set β} (hd : Disjoint s t) (hs : Multipliable (f ∘ (↑) : s → α))\n    (ht : Multipliable (f ∘ (↑) : t → α)) :\n    ∏' x : ↑(s ∪ t), f x = (∏' x : s, f x) * ∏' x : t, f x :=\n  (hs.hasProd.mul_disjoint hd ht.hasProd).tprod_eq\n\n"}
{"name":"tprod_finset_bUnion_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : CommMonoid α\ninst✝² : TopologicalSpace α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousMul α\nι : Type u_4\ns : Finset ι\nt : ι → Set β\nhd : (↑s).Pairwise (Function.onFun Disjoint t)\nhf : ∀ (i : ι), Membership.mem s i → Multipliable (Function.comp f Subtype.val)\n⊢ Eq (tprod fun x => f ↑x) (s.prod fun i => tprod fun x => f ↑x)","decl":"@[to_additive]\ntheorem tprod_finset_bUnion_disjoint {ι} {s : Finset ι} {t : ι → Set β}\n    (hd : (s : Set ι).Pairwise (Disjoint on t)) (hf : ∀ i ∈ s, Multipliable (f ∘ (↑) : t i → α)) :\n    ∏' x : ⋃ i ∈ s, t i, f x = ∏ i ∈ s, ∏' x : t i, f x :=\n  (hasProd_prod_disjoint _ hd fun i hi ↦ (hf i hi).hasProd).tprod_eq\n\n"}
{"name":"tsum_finset_bUnion_disjoint","module":"Mathlib.Topology.Algebra.InfiniteSum.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : AddCommMonoid α\ninst✝² : TopologicalSpace α\nf : β → α\ninst✝¹ : T2Space α\ninst✝ : ContinuousAdd α\nι : Type u_4\ns : Finset ι\nt : ι → Set β\nhd : (↑s).Pairwise (Function.onFun Disjoint t)\nhf : ∀ (i : ι), Membership.mem s i → Summable (Function.comp f Subtype.val)\n⊢ Eq (tsum fun x => f ↑x) (s.sum fun i => tsum fun x => f ↑x)","decl":"@[to_additive]\ntheorem tprod_finset_bUnion_disjoint {ι} {s : Finset ι} {t : ι → Set β}\n    (hd : (s : Set ι).Pairwise (Disjoint on t)) (hf : ∀ i ∈ s, Multipliable (f ∘ (↑) : t i → α)) :\n    ∏' x : ⋃ i ∈ s, t i, f x = ∏ i ∈ s, ∏' x : t i, f x :=\n  (hasProd_prod_disjoint _ hd fun i hi ↦ (hf i hi).hasProd).tprod_eq\n\n"}
