{"name":"TensorProduct.directSum_lof_tmul_lof","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁰ : CommSemiring R\nS : Type u_1\ninst✝⁹ : Semiring S\ninst✝⁸ : Algebra R S\nι₁ : Type v₁\nι₂ : Type v₂\ninst✝⁷ : DecidableEq ι₁\ninst✝⁶ : DecidableEq ι₂\nM₁ : ι₁ → Type w₁\nM₂ : ι₂ → Type w₂\ninst✝⁵ : (i₁ : ι₁) → AddCommMonoid (M₁ i₁)\ninst✝⁴ : (i₂ : ι₂) → AddCommMonoid (M₂ i₂)\ninst✝³ : (i₁ : ι₁) → Module R (M₁ i₁)\ninst✝² : (i₂ : ι₂) → Module R (M₂ i₂)\ninst✝¹ : (i₁ : ι₁) → Module S (M₁ i₁)\ninst✝ : ∀ (i₁ : ι₁), IsScalarTower R S (M₁ i₁)\ni₁ : ι₁\nm₁ : M₁ i₁\ni₂ : ι₂\nm₂ : M₂ i₂\n⊢ Eq ((TensorProduct.directSum R S M₁ M₂) (TensorProduct.tmul R ((DirectSum.lof S ι₁ M₁ i₁) m₁) ((DirectSum.lof R ι₂ M₂ i₂) m₂))) ((DirectSum.lof S (Prod ι₁ ι₂) (fun i => TensorProduct R (M₁ i.1) (M₂ i.2)) { fst := i₁, snd := i₂ }) (TensorProduct.tmul R m₁ m₂))","decl":"@[simp]\ntheorem directSum_lof_tmul_lof (i₁ : ι₁) (m₁ : M₁ i₁) (i₂ : ι₂) (m₂ : M₂ i₂) :\n    TensorProduct.directSum R S M₁ M₂ (DirectSum.lof S ι₁ M₁ i₁ m₁ ⊗ₜ DirectSum.lof R ι₂ M₂ i₂ m₂) =\n      DirectSum.lof S (ι₁ × ι₂) (fun i => M₁ i.1 ⊗[R] M₂ i.2) (i₁, i₂) (m₁ ⊗ₜ m₂) := by\n  simp [TensorProduct.directSum]\n\n"}
{"name":"TensorProduct.directSum_symm_lof_tmul","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝¹⁰ : CommSemiring R\nS : Type u_1\ninst✝⁹ : Semiring S\ninst✝⁸ : Algebra R S\nι₁ : Type v₁\nι₂ : Type v₂\ninst✝⁷ : DecidableEq ι₁\ninst✝⁶ : DecidableEq ι₂\nM₁ : ι₁ → Type w₁\nM₂ : ι₂ → Type w₂\ninst✝⁵ : (i₁ : ι₁) → AddCommMonoid (M₁ i₁)\ninst✝⁴ : (i₂ : ι₂) → AddCommMonoid (M₂ i₂)\ninst✝³ : (i₁ : ι₁) → Module R (M₁ i₁)\ninst✝² : (i₂ : ι₂) → Module R (M₂ i₂)\ninst✝¹ : (i₁ : ι₁) → Module S (M₁ i₁)\ninst✝ : ∀ (i₁ : ι₁), IsScalarTower R S (M₁ i₁)\ni₁ : ι₁\nm₁ : M₁ i₁\ni₂ : ι₂\nm₂ : M₂ i₂\n⊢ Eq ((TensorProduct.directSum R S M₁ M₂).symm ((DirectSum.lof S (Prod ι₁ ι₂) (fun i => TensorProduct R (M₁ i.1) (M₂ i.2)) { fst := i₁, snd := i₂ }) (TensorProduct.tmul R m₁ m₂))) (TensorProduct.tmul R ((DirectSum.lof S ι₁ M₁ i₁) m₁) ((DirectSum.lof R ι₂ M₂ i₂) m₂))","decl":"@[simp]\ntheorem directSum_symm_lof_tmul (i₁ : ι₁) (m₁ : M₁ i₁) (i₂ : ι₂) (m₂ : M₂ i₂) :\n    (TensorProduct.directSum R S M₁ M₂).symm\n      (DirectSum.lof S (ι₁ × ι₂) (fun i => M₁ i.1 ⊗[R] M₂ i.2) (i₁, i₂) (m₁ ⊗ₜ m₂)) =\n      (DirectSum.lof S ι₁ M₁ i₁ m₁ ⊗ₜ DirectSum.lof R ι₂ M₂ i₂ m₂) := by\n  rw [LinearEquiv.symm_apply_eq, directSum_lof_tmul_lof]\n\n"}
{"name":"TensorProduct.directSumLeft_tmul_lof","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nι₁ : Type v₁\ninst✝⁴ : DecidableEq ι₁\nM₁ : ι₁ → Type w₁\nM₂' : Type w₂'\ninst✝³ : (i₁ : ι₁) → AddCommMonoid (M₁ i₁)\ninst✝² : AddCommMonoid M₂'\ninst✝¹ : (i₁ : ι₁) → Module R (M₁ i₁)\ninst✝ : Module R M₂'\ni : ι₁\nx : M₁ i\ny : M₂'\n⊢ Eq ((TensorProduct.directSumLeft R M₁ M₂') (TensorProduct.tmul R ((DirectSum.lof R ι₁ M₁ i) x) y)) ((DirectSum.lof R ι₁ (fun i => TensorProduct R (M₁ i) M₂') i) (TensorProduct.tmul R x y))","decl":"@[simp]\ntheorem directSumLeft_tmul_lof (i : ι₁) (x : M₁ i) (y : M₂') :\n    directSumLeft R M₁ M₂' (DirectSum.lof R _ _ i x ⊗ₜ[R] y) =\n    DirectSum.lof R _ _ i (x ⊗ₜ[R] y) := by\n  dsimp only [directSumLeft, LinearEquiv.ofLinear_apply, lift.tmul]\n  rw [DirectSum.toModule_lof R i]\n  rfl\n\n"}
{"name":"TensorProduct.directSumLeft_symm_lof_tmul","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nι₁ : Type v₁\ninst✝⁴ : DecidableEq ι₁\nM₁ : ι₁ → Type w₁\nM₂' : Type w₂'\ninst✝³ : (i₁ : ι₁) → AddCommMonoid (M₁ i₁)\ninst✝² : AddCommMonoid M₂'\ninst✝¹ : (i₁ : ι₁) → Module R (M₁ i₁)\ninst✝ : Module R M₂'\ni : ι₁\nx : M₁ i\ny : M₂'\n⊢ Eq ((TensorProduct.directSumLeft R M₁ M₂').symm ((DirectSum.lof R ι₁ (fun i => TensorProduct R (M₁ i) M₂') i) (TensorProduct.tmul R x y))) (TensorProduct.tmul R ((DirectSum.lof R ι₁ M₁ i) x) y)","decl":"@[simp]\ntheorem directSumLeft_symm_lof_tmul (i : ι₁) (x : M₁ i) (y : M₂') :\n    (directSumLeft R M₁ M₂').symm (DirectSum.lof R _ _ i (x ⊗ₜ[R] y)) =\n      DirectSum.lof R _ _ i x ⊗ₜ[R] y := by\n  rw [LinearEquiv.symm_apply_eq, directSumLeft_tmul_lof]\n\n"}
{"name":"TensorProduct.directSumRight_tmul_lof","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nι₂ : Type v₂\ninst✝⁴ : DecidableEq ι₂\nM₁' : Type w₁'\nM₂ : ι₂ → Type w₂\ninst✝³ : AddCommMonoid M₁'\ninst✝² : (i₂ : ι₂) → AddCommMonoid (M₂ i₂)\ninst✝¹ : Module R M₁'\ninst✝ : (i₂ : ι₂) → Module R (M₂ i₂)\nx : M₁'\ni : ι₂\ny : M₂ i\n⊢ Eq ((TensorProduct.directSumRight R M₁' M₂) (TensorProduct.tmul R x ((DirectSum.lof R ι₂ M₂ i) y))) ((DirectSum.lof R ι₂ (fun i => TensorProduct R M₁' (M₂ i)) i) (TensorProduct.tmul R x y))","decl":"@[simp]\ntheorem directSumRight_tmul_lof (x : M₁') (i : ι₂) (y : M₂ i) :\n    directSumRight R M₁' M₂ (x ⊗ₜ[R] DirectSum.lof R _ _ i y) =\n    DirectSum.lof R _ _ i (x ⊗ₜ[R] y) := by\n  dsimp only [directSumRight, LinearEquiv.trans_apply, TensorProduct.comm_tmul]\n  rw [directSumLeft_tmul_lof]\n  exact DFinsupp.mapRange_single (hf := fun _ => rfl)\n\n"}
{"name":"TensorProduct.directSumRight_symm_lof_tmul","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝⁵ : CommSemiring R\nι₂ : Type v₂\ninst✝⁴ : DecidableEq ι₂\nM₁' : Type w₁'\nM₂ : ι₂ → Type w₂\ninst✝³ : AddCommMonoid M₁'\ninst✝² : (i₂ : ι₂) → AddCommMonoid (M₂ i₂)\ninst✝¹ : Module R M₁'\ninst✝ : (i₂ : ι₂) → Module R (M₂ i₂)\nx : M₁'\ni : ι₂\ny : M₂ i\n⊢ Eq ((TensorProduct.directSumRight R M₁' M₂).symm ((DirectSum.lof R ι₂ (fun i => TensorProduct R M₁' (M₂ i)) i) (TensorProduct.tmul R x y))) (TensorProduct.tmul R x ((DirectSum.lof R ι₂ M₂ i) y))","decl":"@[simp]\ntheorem directSumRight_symm_lof_tmul (x : M₁') (i : ι₂) (y : M₂ i) :\n    (directSumRight R M₁' M₂).symm (DirectSum.lof R _ _ i (x ⊗ₜ[R] y)) =\n      x ⊗ₜ[R] DirectSum.lof R _ _ i y := by\n  rw [LinearEquiv.symm_apply_eq, directSumRight_tmul_lof]\n\n"}
{"name":"TensorProduct.directSumRight_comp_rTensor","module":"Mathlib.LinearAlgebra.DirectSum.TensorProduct","initialProofState":"R : Type u\ninst✝⁷ : CommSemiring R\nι₁ : Type v₁\ninst✝⁶ : DecidableEq ι₁\nM₁ : ι₁ → Type w₁\nM₁' : Type w₁'\nM₂' : Type w₂'\ninst✝⁵ : (i₁ : ι₁) → AddCommMonoid (M₁ i₁)\ninst✝⁴ : AddCommMonoid M₁'\ninst✝³ : AddCommMonoid M₂'\ninst✝² : (i₁ : ι₁) → Module R (M₁ i₁)\ninst✝¹ : Module R M₁'\ninst✝ : Module R M₂'\nf : LinearMap (RingHom.id R) M₁' M₂'\n⊢ Eq ((↑(TensorProduct.directSumRight R M₂' M₁)).comp (LinearMap.rTensor (DirectSum ι₁ fun i => M₁ i) f)) ((DirectSum.lmap fun x => LinearMap.rTensor (M₁ x) f).comp ↑(TensorProduct.directSumRight R M₁' M₁))","decl":"lemma directSumRight_comp_rTensor (f : M₁' →ₗ[R] M₂'):\n    (directSumRight R M₂' M₁).toLinearMap ∘ₗ f.rTensor _ =\n      (lmap fun _ ↦ f.rTensor _) ∘ₗ directSumRight R M₁' M₁ := by\n  ext; simp\n\n"}
