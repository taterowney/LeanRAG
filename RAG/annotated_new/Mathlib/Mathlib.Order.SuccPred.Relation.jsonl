{"name":"reflTransGen_of_succ_of_le","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ico n m) i → r i (Order.succ i)\nhnm : LE.le n m\n⊢ Relation.ReflTransGen r n m","decl":"/-- For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_succ_of_le (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico n m, r i (succ i))\n    (hnm : n ≤ m) : ReflTransGen r n m := by\n  revert h; refine Succ.rec ?_ ?_ hnm\n  · intro _\n    exact ReflTransGen.refl\n  · intro m hnm ih h\n    have : ReflTransGen r n m := ih fun i hi => h i ⟨hi.1, hi.2.trans_le <| le_succ m⟩\n    rcases (le_succ m).eq_or_lt with hm | hm\n    · rwa [← hm]\n    exact this.tail (h m ⟨hnm, hm⟩)\n\n"}
{"name":"reflTransGen_of_succ_of_ge","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ico m n) i → r (Order.succ i) i\nhmn : LE.le m n\n⊢ Relation.ReflTransGen r n m","decl":"/-- For `m ≤ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `succ i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_succ_of_ge (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico m n, r (succ i) i)\n    (hmn : m ≤ n) : ReflTransGen r n m := by\n  rw [← reflTransGen_swap]\n  exact reflTransGen_of_succ_of_le (swap r) h hmn\n\n"}
{"name":"transGen_of_succ_of_lt","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ico n m) i → r i (Order.succ i)\nhnm : LT.lt n m\n⊢ Relation.TransGen r n m","decl":"/-- For `n < m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_lt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico n m, r i (succ i))\n    (hnm : n < m) : TransGen r n m :=\n  (reflTransGen_iff_eq_or_transGen.mp <| reflTransGen_of_succ_of_le r h hnm.le).resolve_left\n    hnm.ne'\n\n"}
{"name":"transGen_of_succ_of_gt","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ico m n) i → r (Order.succ i) i\nhmn : LT.lt m n\n⊢ Relation.TransGen r n m","decl":"/-- For `m < n`, `(n, m)` is in the transitive closure of a relation `~` if `succ i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_gt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ico m n, r (succ i) i)\n    (hmn : m < n) : TransGen r n m :=\n  (reflTransGen_iff_eq_or_transGen.mp <| reflTransGen_of_succ_of_ge r h hmn.le).resolve_left\n    hmn.ne\n\n"}
{"name":"reflTransGen_of_succ","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nh1 : ∀ (i : α), Membership.mem (Set.Ico n m) i → r i (Order.succ i)\nh2 : ∀ (i : α), Membership.mem (Set.Ico m n) i → r (Order.succ i) i\n⊢ Relation.ReflTransGen r n m","decl":"/-- `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ succ i` and `succ i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_succ (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ico n m, r i (succ i))\n    (h2 : ∀ i ∈ Ico m n, r (succ i) i) : ReflTransGen r n m :=\n  (le_total n m).elim (reflTransGen_of_succ_of_le r h1) <| reflTransGen_of_succ_of_ge r h2\n\n"}
{"name":"transGen_of_succ_of_ne","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nh1 : ∀ (i : α), Membership.mem (Set.Ico n m) i → r i (Order.succ i)\nh2 : ∀ (i : α), Membership.mem (Set.Ico m n) i → r (Order.succ i) i\nhnm : Ne n m\n⊢ Relation.TransGen r n m","decl":"/-- For `n ≠ m`,`(n, m)` is in the transitive closure of a relation `~` if `i ~ succ i` and\n  `succ i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_ne (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ico n m, r i (succ i))\n    (h2 : ∀ i ∈ Ico m n, r (succ i) i) (hnm : n ≠ m) : TransGen r n m :=\n  (reflTransGen_iff_eq_or_transGen.mp (reflTransGen_of_succ r h1 h2)).resolve_left hnm.symm\n\n"}
{"name":"transGen_of_succ_of_reflexive","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : SuccOrder α\ninst✝ : IsSuccArchimedean α\nr : α → α → Prop\nn m : α\nhr : Reflexive r\nh1 : ∀ (i : α), Membership.mem (Set.Ico n m) i → r i (Order.succ i)\nh2 : ∀ (i : α), Membership.mem (Set.Ico m n) i → r (Order.succ i) i\n⊢ Relation.TransGen r n m","decl":"/-- `(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ succ i` and\n  `succ i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_succ_of_reflexive (r : α → α → Prop) {n m : α} (hr : Reflexive r)\n    (h1 : ∀ i ∈ Ico n m, r i (succ i)) (h2 : ∀ i ∈ Ico m n, r (succ i) i) : TransGen r n m := by\n  rcases eq_or_ne m n with (rfl | hmn); · exact TransGen.single (hr m)\n  exact transGen_of_succ_of_ne r h1 h2 hmn.symm\n\n"}
{"name":"reflTransGen_of_pred_of_ge","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ioc m n) i → r i (Order.pred i)\nhnm : LE.le m n\n⊢ Relation.ReflTransGen r n m","decl":"/-- For `m ≤ n`, `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_pred_of_ge (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc m n, r i (pred i))\n    (hnm : m ≤ n) : ReflTransGen r n m :=\n  reflTransGen_of_succ_of_le (α := αᵒᵈ) r (fun x hx => h x ⟨hx.2, hx.1⟩) hnm\n\n"}
{"name":"reflTransGen_of_pred_of_le","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ioc n m) i → r (Order.pred i) i\nhmn : LE.le n m\n⊢ Relation.ReflTransGen r n m","decl":"/-- For `n ≤ m`, `(n, m)` is in the reflexive-transitive closure of `~` if `pred i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_pred_of_le (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc n m, r (pred i) i)\n    (hmn : n ≤ m) : ReflTransGen r n m :=\n  reflTransGen_of_succ_of_ge (α := αᵒᵈ) r (fun x hx => h x ⟨hx.2, hx.1⟩) hmn\n\n"}
{"name":"transGen_of_pred_of_gt","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ioc m n) i → r i (Order.pred i)\nhnm : LT.lt m n\n⊢ Relation.TransGen r n m","decl":"/-- For `m < n`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `i ~ pred i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_gt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc m n, r i (pred i))\n    (hnm : m < n) : TransGen r n m :=\n  transGen_of_succ_of_lt (α := αᵒᵈ) r (fun x hx => h x ⟨hx.2, hx.1⟩) hnm\n\n"}
{"name":"transGen_of_pred_of_lt","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nh : ∀ (i : α), Membership.mem (Set.Ioc n m) i → r (Order.pred i) i\nhmn : LT.lt n m\n⊢ Relation.TransGen r n m","decl":"/-- For `n < m`, `(n, m)` is in the transitive closure of a relation `~` for `n ≠ m` if `pred i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_lt (r : α → α → Prop) {n m : α} (h : ∀ i ∈ Ioc n m, r (pred i) i)\n    (hmn : n < m) : TransGen r n m :=\n  transGen_of_succ_of_gt (α := αᵒᵈ) r (fun x hx => h x ⟨hx.2, hx.1⟩) hmn\n\n"}
{"name":"reflTransGen_of_pred","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nh1 : ∀ (i : α), Membership.mem (Set.Ioc m n) i → r i (Order.pred i)\nh2 : ∀ (i : α), Membership.mem (Set.Ioc n m) i → r (Order.pred i) i\n⊢ Relation.ReflTransGen r n m","decl":"/-- `(n, m)` is in the reflexive-transitive closure of `~` if `i ~ pred i` and `pred i ~ i`\n  for all `i` between `n` and `m`. -/\ntheorem reflTransGen_of_pred (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ioc m n, r i (pred i))\n    (h2 : ∀ i ∈ Ioc n m, r (pred i) i) : ReflTransGen r n m :=\n  reflTransGen_of_succ (α := αᵒᵈ) r (fun x hx => h1 x ⟨hx.2, hx.1⟩) fun x hx =>\n    h2 x ⟨hx.2, hx.1⟩\n\n"}
{"name":"transGen_of_pred_of_ne","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nh1 : ∀ (i : α), Membership.mem (Set.Ioc m n) i → r i (Order.pred i)\nh2 : ∀ (i : α), Membership.mem (Set.Ioc n m) i → r (Order.pred i) i\nhnm : Ne n m\n⊢ Relation.TransGen r n m","decl":"/-- For `n ≠ m`, `(n, m)` is in the transitive closure of a relation `~` if `i ~ pred i` and\n  `pred i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_ne (r : α → α → Prop) {n m : α} (h1 : ∀ i ∈ Ioc m n, r i (pred i))\n    (h2 : ∀ i ∈ Ioc n m, r (pred i) i) (hnm : n ≠ m) : TransGen r n m :=\n  transGen_of_succ_of_ne (α := αᵒᵈ) r (fun x hx => h1 x ⟨hx.2, hx.1⟩)\n    (fun x hx => h2 x ⟨hx.2, hx.1⟩) hnm\n\n"}
{"name":"transGen_of_pred_of_reflexive","module":"Mathlib.Order.SuccPred.Relation","initialProofState":"α : Type u_1\ninst✝² : LinearOrder α\ninst✝¹ : PredOrder α\ninst✝ : IsPredArchimedean α\nr : α → α → Prop\nn m : α\nhr : Reflexive r\nh1 : ∀ (i : α), Membership.mem (Set.Ioc m n) i → r i (Order.pred i)\nh2 : ∀ (i : α), Membership.mem (Set.Ioc n m) i → r (Order.pred i) i\n⊢ Relation.TransGen r n m","decl":"/-- `(n, m)` is in the transitive closure of a reflexive relation `~` if `i ~ pred i` and\n  `pred i ~ i` for all `i` between `n` and `m`. -/\ntheorem transGen_of_pred_of_reflexive (r : α → α → Prop) {n m : α} (hr : Reflexive r)\n    (h1 : ∀ i ∈ Ioc m n, r i (pred i)) (h2 : ∀ i ∈ Ioc n m, r (pred i) i) : TransGen r n m :=\n  transGen_of_succ_of_reflexive (α := αᵒᵈ) r hr (fun x hx => h1 x ⟨hx.2, hx.1⟩) fun x hx =>\n    h2 x ⟨hx.2, hx.1⟩\n\n"}
