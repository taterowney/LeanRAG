{"name":"CategoryTheory.colimitYonedaHomEquiv_œÄ_apply","module":"Mathlib.CategoryTheory.Limits.Indization.LocallySmall","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nI : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} I\ninst‚úù¬≤ : CategoryTheory.Limits.HasColimitsOfShape I (Type v)\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type v)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u v))\nF : CategoryTheory.Functor I C\nG : CategoryTheory.Functor (Opposite C) (Type v)\nŒ∑ : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp CategoryTheory.yoneda)) G\ni : Opposite I\n‚ä¢ Eq (CategoryTheory.Limits.limit.œÄ (F.op.comp G) i ((CategoryTheory.colimitYonedaHomEquiv F G) Œ∑)) (Œ∑.app { unop := F.obj (Opposite.unop i) } ((CategoryTheory.Limits.colimit.Œπ (F.comp CategoryTheory.yoneda) (Opposite.unop i)).app { unop := F.obj (Opposite.unop i) } (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := F.obj (Opposite.unop i) }))))","decl":"@[simp]\ntheorem colimitYonedaHomEquiv_œÄ_apply (Œ∑ : colimit (F ‚ãô yoneda) ‚ü∂ G) (i : I·µí·µñ) :\n    limit.œÄ (F.op ‚ãô G) i (colimitYonedaHomEquiv F G Œ∑) =\n      Œ∑.app (op (F.obj i.unop)) ((colimit.Œπ (F ‚ãô yoneda) i.unop).app _ (ùüô _)) := by\n  simp only [Functor.comp_obj, Functor.op_obj, colimitYonedaHomEquiv, uliftFunctor_obj,\n    Iso.instTransIso_trans, Iso.trans_assoc, Iso.toEquiv_comp, Equiv.symm_trans_apply,\n    Equiv.symm_symm, Equiv.trans_apply, Iso.toEquiv_fun, Iso.symm_hom, Equiv.ulift_apply]\n  have (a) := congrArg ULift.down\n    (congrFun (preservesLimitIso_inv_œÄ uliftFunctor.{u, v} (F.op ‚ãô G) i) a)\n  dsimp at this\n  rw [this, ‚Üê types_comp_apply (HasLimit.isoOfNatIso _).hom (limit.œÄ _ _),\n    HasLimit.isoOfNatIso_hom_œÄ]\n  simp\n\n"}
{"name":"CategoryTheory.instSmallHomFunctorOppositeTypeColimitCompYoneda","module":"Mathlib.CategoryTheory.Limits.Indization.LocallySmall","initialProofState":"C : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} C\nI : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} I\ninst‚úù¬≤ : CategoryTheory.Limits.HasColimitsOfShape I (Type v)\ninst‚úù¬π : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type v)\ninst‚úù : CategoryTheory.Limits.HasLimitsOfShape (Opposite I) (Type (max u v))\nF : CategoryTheory.Functor I C\nG : CategoryTheory.Functor (Opposite C) (Type v)\n‚ä¢ Small.{v, max u v} (Quiver.Hom (CategoryTheory.Limits.colimit (F.comp CategoryTheory.yoneda)) G)","decl":"instance : Small.{v} (colimit (F ‚ãô yoneda) ‚ü∂ G) where\n  equiv_small := ‚ü®_, ‚ü®colimitYonedaHomEquiv F G‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.instLocallySmallFullSubcategoryFunctorOppositeTypeIsIndObject","module":"Mathlib.CategoryTheory.Limits.Indization.LocallySmall","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\n‚ä¢ CategoryTheory.LocallySmall.{v, max u v, max u (v + 1)} (CategoryTheory.FullSubcategory CategoryTheory.Limits.IsIndObject)","decl":"instance : LocallySmall.{v} (FullSubcategory (IsIndObject (C := C))) where\n  hom_small X Y := by\n    obtain ‚ü®‚ü®P‚ü©‚ü© := X.2\n    obtain ‚ü®‚ü®Q‚ü©‚ü© := Y.2\n    let e‚ÇÅ := IsColimit.coconePointUniqueUpToIso (P.isColimit) (colimit.isColimit _)\n    let e‚ÇÇ := IsColimit.coconePointUniqueUpToIso (Q.isColimit) (colimit.isColimit _)\n    let e‚ÇÉ := Iso.homCongr e‚ÇÅ e‚ÇÇ\n    dsimp only [colimit.cocone_x] at e‚ÇÉ\n    exact small_map e‚ÇÉ\n\n"}
