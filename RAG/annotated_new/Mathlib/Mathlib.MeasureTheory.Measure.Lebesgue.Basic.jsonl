{"name":"Real.volume_eq_stieltjes_id","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"⊢ Eq MeasureTheory.MeasureSpace.volume StieltjesFunction.id.measure","decl":"/-- The volume on the real line (as a particular case of the volume on a finite-dimensional\ninner product space) coincides with the Stieltjes measure coming from the identity function. -/\ntheorem volume_eq_stieltjes_id : (volume : Measure ℝ) = StieltjesFunction.id.measure := by\n  haveI : IsAddLeftInvariant StieltjesFunction.id.measure :=\n    ⟨fun a =>\n      Eq.symm <|\n        Real.measure_ext_Ioo_rat fun p q => by\n          simp only [Measure.map_apply (measurable_const_add a) measurableSet_Ioo,\n            sub_sub_sub_cancel_right, StieltjesFunction.measure_Ioo, StieltjesFunction.id_leftLim,\n            StieltjesFunction.id_apply, id, preimage_const_add_Ioo]⟩\n  have A : StieltjesFunction.id.measure (stdOrthonormalBasis ℝ ℝ).toBasis.parallelepiped = 1 := by\n    change StieltjesFunction.id.measure (parallelepiped (stdOrthonormalBasis ℝ ℝ)) = 1\n    rcases parallelepiped_orthonormalBasis_one_dim (stdOrthonormalBasis ℝ ℝ) with (H | H) <;>\n      simp only [H, StieltjesFunction.measure_Icc, StieltjesFunction.id_apply, id, tsub_zero,\n        StieltjesFunction.id_leftLim, sub_neg_eq_add, zero_add, ENNReal.ofReal_one]\n  conv_rhs =>\n    rw [addHaarMeasure_unique StieltjesFunction.id.measure\n        (stdOrthonormalBasis ℝ ℝ).toBasis.parallelepiped, A]\n  simp only [volume, Basis.addHaar, one_smul]\n\n"}
{"name":"Real.volume_val","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"s : Set Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume s) (StieltjesFunction.id.measure s)","decl":"theorem volume_val (s) : volume s = StieltjesFunction.id.measure s := by\n  simp [volume_eq_stieltjes_id]\n\n"}
{"name":"Real.volume_Ico","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ico a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Ico {a b : ℝ} : volume (Ico a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_Icc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Icc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Icc {a b : ℝ} : volume (Icc a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ioo a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Ioo {a b : ℝ} : volume (Ioo a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_Ioc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ioc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Ioc {a b : ℝ} : volume (Ioc a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_singleton","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Singleton.singleton a)) 0","decl":"theorem volume_singleton {a : ℝ} : volume ({a} : Set ℝ) = 0 := by simp [volume_val]\n\n"}
{"name":"Real.volume_univ","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"⊢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) Top.top","decl":"theorem volume_univ : volume (univ : Set ℝ) = ∞ :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r =>\n    calc\n      (r : ℝ≥0∞) = volume (Icc (0 : ℝ) r) := by simp\n      _ ≤ volume univ := measure_mono (subset_univ _)\n\n"}
{"name":"Real.volume_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a r : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball a r)) (ENNReal.ofReal (HMul.hMul 2 r))","decl":"@[simp]\ntheorem volume_ball (a r : ℝ) : volume (Metric.ball a r) = ofReal (2 * r) := by\n  rw [ball_eq_Ioo, volume_Ioo, ← sub_add, add_sub_cancel_left, two_mul]\n\n"}
{"name":"Real.volume_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a r : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall a r)) (ENNReal.ofReal (HMul.hMul 2 r))","decl":"@[simp]\ntheorem volume_closedBall (a r : ℝ) : volume (Metric.closedBall a r) = ofReal (2 * r) := by\n  rw [closedBall_eq_Icc, volume_Icc, ← sub_add, add_sub_cancel_left, two_mul]\n\n"}
{"name":"Real.volume_emetric_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nr : ENNReal\n⊢ Eq (MeasureTheory.MeasureSpace.volume (EMetric.ball a r)) (HMul.hMul 2 r)","decl":"@[simp]\ntheorem volume_emetric_ball (a : ℝ) (r : ℝ≥0∞) : volume (EMetric.ball a r) = 2 * r := by\n  rcases eq_or_ne r ∞ with (rfl | hr)\n  · rw [Metric.emetric_ball_top, volume_univ, two_mul, _root_.top_add]\n  · lift r to ℝ≥0 using hr\n    rw [Metric.emetric_ball_nnreal, volume_ball, two_mul, ← NNReal.coe_add,\n      ENNReal.ofReal_coe_nnreal, ENNReal.coe_add, two_mul]\n\n"}
{"name":"Real.volume_emetric_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nr : ENNReal\n⊢ Eq (MeasureTheory.MeasureSpace.volume (EMetric.closedBall a r)) (HMul.hMul 2 r)","decl":"@[simp]\ntheorem volume_emetric_closedBall (a : ℝ) (r : ℝ≥0∞) : volume (EMetric.closedBall a r) = 2 * r := by\n  rcases eq_or_ne r ∞ with (rfl | hr)\n  · rw [EMetric.closedBall_top, volume_univ, two_mul, _root_.top_add]\n  · lift r to ℝ≥0 using hr\n    rw [Metric.emetric_closedBall_nnreal, volume_closedBall, two_mul, ← NNReal.coe_add,\n      ENNReal.ofReal_coe_nnreal, ENNReal.coe_add, two_mul]\n\n"}
{"name":"Real.noAtoms_volume","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"⊢ MeasureTheory.NoAtoms MeasureTheory.MeasureSpace.volume","decl":"instance noAtoms_volume : NoAtoms (volume : Measure ℝ) :=\n  ⟨fun _ => volume_singleton⟩\n\n"}
{"name":"Real.volume_interval","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.uIcc a b)) (ENNReal.ofReal (abs (HSub.hSub b a)))","decl":"@[simp]\ntheorem volume_interval {a b : ℝ} : volume (uIcc a b) = ofReal |b - a| := by\n  rw [← Icc_min_max, volume_Icc, max_sub_min_eq_abs]\n\n"}
{"name":"Real.volume_Ioi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ioi a)) Top.top","decl":"@[simp]\ntheorem volume_Ioi {a : ℝ} : volume (Ioi a) = ∞ :=\n  top_unique <|\n    le_of_tendsto' ENNReal.tendsto_nat_nhds_top fun n =>\n      calc\n        (n : ℝ≥0∞) = volume (Ioo a (a + n)) := by simp\n        _ ≤ volume (Ioi a) := measure_mono Ioo_subset_Ioi_self\n\n"}
{"name":"Real.volume_Ici","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ici a)) Top.top","decl":"@[simp]\ntheorem volume_Ici {a : ℝ} : volume (Ici a) = ∞ := by rw [← measure_congr Ioi_ae_eq_Ici]; simp\n\n"}
{"name":"Real.volume_Iio","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Iio a)) Top.top","decl":"@[simp]\ntheorem volume_Iio {a : ℝ} : volume (Iio a) = ∞ :=\n  top_unique <|\n    le_of_tendsto' ENNReal.tendsto_nat_nhds_top fun n =>\n      calc\n        (n : ℝ≥0∞) = volume (Ioo (a - n) a) := by simp\n        _ ≤ volume (Iio a) := measure_mono Ioo_subset_Iio_self\n\n"}
{"name":"Real.volume_Iic","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Iic a)) Top.top","decl":"@[simp]\ntheorem volume_Iic {a : ℝ} : volume (Iic a) = ∞ := by rw [← measure_congr Iio_ae_eq_Iic]; simp\n\n"}
{"name":"Real.locallyFinite_volume","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"⊢ MeasureTheory.IsLocallyFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance locallyFinite_volume : IsLocallyFiniteMeasure (volume : Measure ℝ) :=\n  ⟨fun x =>\n    ⟨Ioo (x - 1) (x + 1),\n      IsOpen.mem_nhds isOpen_Ioo ⟨sub_lt_self _ zero_lt_one, lt_add_of_pos_right _ zero_lt_one⟩, by\n      simp only [Real.volume_Ioo, ENNReal.ofReal_lt_top]⟩⟩\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc x y))","decl":"instance isFiniteMeasure_restrict_Icc (x y : ℝ) : IsFiniteMeasure (volume.restrict (Icc x y)) :=\n  ⟨by simp⟩\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Ico","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Ico x y))","decl":"instance isFiniteMeasure_restrict_Ico (x y : ℝ) : IsFiniteMeasure (volume.restrict (Ico x y)) :=\n  ⟨by simp⟩\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Ioc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc x y))","decl":"instance isFiniteMeasure_restrict_Ioc (x y : ℝ) : IsFiniteMeasure (volume.restrict (Ioc x y)) :=\n  ⟨by simp⟩\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n⊢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioo x y))","decl":"instance isFiniteMeasure_restrict_Ioo (x y : ℝ) : IsFiniteMeasure (volume.restrict (Ioo x y)) :=\n  ⟨by simp⟩\n\n"}
{"name":"Real.volume_le_diam","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"s : Set Real\n⊢ LE.le (MeasureTheory.MeasureSpace.volume s) (EMetric.diam s)","decl":"theorem volume_le_diam (s : Set ℝ) : volume s ≤ EMetric.diam s := by\n  by_cases hs : Bornology.IsBounded s\n  · rw [Real.ediam_eq hs, ← volume_Icc]\n    exact volume.mono hs.subset_Icc_sInf_sSup\n  · rw [Metric.ediam_of_unbounded hs]; exact le_top\n\n"}
{"name":"Filter.Eventually.volume_pos_of_nhds_real","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"p : Real → Prop\na : Real\nh : Filter.Eventually (fun x => p x) (nhds a)\n⊢ LT.lt 0 (MeasureTheory.MeasureSpace.volume (setOf fun x => p x))","decl":"theorem _root_.Filter.Eventually.volume_pos_of_nhds_real {p : ℝ → Prop} {a : ℝ}\n    (h : ∀ᶠ x in 𝓝 a, p x) : (0 : ℝ≥0∞) < volume { x | p x } := by\n  rcases h.exists_Ioo_subset with ⟨l, u, hx, hs⟩\n  refine lt_of_lt_of_le ?_ (measure_mono hs)\n  simpa [-mem_Ioo] using hx.1.trans hx.2\n\n"}
{"name":"Real.volume_Icc_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Icc a b)) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_Icc_pi {a b : ι → ℝ} : volume (Icc a b) = ∏ i, ENNReal.ofReal (b i - a i) := by\n  rw [← pi_univ_Icc, volume_pi_pi]\n  simp only [Real.volume_Icc]\n\n"}
{"name":"Real.volume_Icc_pi_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\nh : LE.le a b\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.Icc a b)).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_Icc_pi_toReal {a b : ι → ℝ} (h : a ≤ b) :\n    (volume (Icc a b)).toReal = ∏ i, (b i - a i) := by\n  simp only [volume_Icc_pi, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioo (a i) (b i))) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_pi_Ioo {a b : ι → ℝ} :\n    volume (pi univ fun i => Ioo (a i) (b i)) = ∏ i, ENNReal.ofReal (b i - a i) :=\n  (measure_congr Measure.univ_pi_Ioo_ae_eq_Icc).trans volume_Icc_pi\n\n"}
{"name":"Real.volume_pi_Ioo_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\nh : LE.le a b\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioo (a i) (b i))).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_pi_Ioo_toReal {a b : ι → ℝ} (h : a ≤ b) :\n    (volume (pi univ fun i => Ioo (a i) (b i))).toReal = ∏ i, (b i - a i) := by\n  simp only [volume_pi_Ioo, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_Ioc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioc (a i) (b i))) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_pi_Ioc {a b : ι → ℝ} :\n    volume (pi univ fun i => Ioc (a i) (b i)) = ∏ i, ENNReal.ofReal (b i - a i) :=\n  (measure_congr Measure.univ_pi_Ioc_ae_eq_Icc).trans volume_Icc_pi\n\n"}
{"name":"Real.volume_pi_Ioc_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\nh : LE.le a b\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioc (a i) (b i))).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_pi_Ioc_toReal {a b : ι → ℝ} (h : a ≤ b) :\n    (volume (pi univ fun i => Ioc (a i) (b i))).toReal = ∏ i, (b i - a i) := by\n  simp only [volume_pi_Ioc, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_Ico","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ico (a i) (b i))) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_pi_Ico {a b : ι → ℝ} :\n    volume (pi univ fun i => Ico (a i) (b i)) = ∏ i, ENNReal.ofReal (b i - a i) :=\n  (measure_congr Measure.univ_pi_Ico_ae_eq_Icc).trans volume_Icc_pi\n\n"}
{"name":"Real.volume_pi_Ico_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na b : ι → Real\nh : LE.le a b\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ico (a i) (b i))).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_pi_Ico_toReal {a b : ι → ℝ} (h : a ≤ b) :\n    (volume (pi univ fun i => Ico (a i) (b i))).toReal = ∏ i, (b i - a i) := by\n  simp only [volume_pi_Ico, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na : ι → Real\nr : Real\nhr : LT.lt 0 r\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball a r)) (ENNReal.ofReal (HPow.hPow (HMul.hMul 2 r) (Fintype.card ι)))","decl":"@[simp]\nnonrec theorem volume_pi_ball (a : ι → ℝ) {r : ℝ} (hr : 0 < r) :\n    volume (Metric.ball a r) = ENNReal.ofReal ((2 * r) ^ Fintype.card ι) := by\n  simp only [MeasureTheory.volume_pi_ball a hr, volume_ball, Finset.prod_const]\n  exact (ENNReal.ofReal_pow (mul_nonneg zero_le_two hr.le) _).symm\n\n"}
{"name":"Real.volume_pi_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\na : ι → Real\nr : Real\nhr : LE.le 0 r\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall a r)) (ENNReal.ofReal (HPow.hPow (HMul.hMul 2 r) (Fintype.card ι)))","decl":"@[simp]\nnonrec theorem volume_pi_closedBall (a : ι → ℝ) {r : ℝ} (hr : 0 ≤ r) :\n    volume (Metric.closedBall a r) = ENNReal.ofReal ((2 * r) ^ Fintype.card ι) := by\n  simp only [MeasureTheory.volume_pi_closedBall a hr, volume_closedBall, Finset.prod_const]\n  exact (ENNReal.ofReal_pow (mul_nonneg zero_le_two hr) _).symm\n\n"}
{"name":"Real.volume_pi_le_prod_diam","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\ns : Set (ι → Real)\n⊢ LE.le (MeasureTheory.MeasureSpace.volume s) (Finset.univ.prod fun i => EMetric.diam (Set.image (Function.eval i) s))","decl":"theorem volume_pi_le_prod_diam (s : Set (ι → ℝ)) :\n    volume s ≤ ∏ i : ι, EMetric.diam (Function.eval i '' s) :=\n  calc\n    volume s ≤ volume (pi univ fun i => closure (Function.eval i '' s)) :=\n      volume.mono <|\n        Subset.trans (subset_pi_eval_image univ s) <| pi_mono fun _ _ => subset_closure\n    _ = ∏ i, volume (closure <| Function.eval i '' s) := volume_pi_pi _\n    _ ≤ ∏ i : ι, EMetric.diam (Function.eval i '' s) :=\n      Finset.prod_le_prod' fun _ _ => (volume_le_diam _).trans_eq (EMetric.diam_closure _)\n\n"}
{"name":"Real.volume_pi_le_diam_pow","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\ns : Set (ι → Real)\n⊢ LE.le (MeasureTheory.MeasureSpace.volume s) (HPow.hPow (EMetric.diam s) (Fintype.card ι))","decl":"theorem volume_pi_le_diam_pow (s : Set (ι → ℝ)) : volume s ≤ EMetric.diam s ^ Fintype.card ι :=\n  calc\n    volume s ≤ ∏ i : ι, EMetric.diam (Function.eval i '' s) := volume_pi_le_prod_diam s\n    _ ≤ ∏ _i : ι, (1 : ℝ≥0) * EMetric.diam s :=\n      (Finset.prod_le_prod' fun i _ => (LipschitzWith.eval i).ediam_image_le s)\n    _ = EMetric.diam s ^ Fintype.card ι := by\n      simp only [ENNReal.coe_one, one_mul, Finset.prod_const, Fintype.card]\n\n"}
{"name":"Real.smul_map_volume_mul_left","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n⊢ Eq (HSMul.hSMul (ENNReal.ofReal (abs a)) (MeasureTheory.Measure.map (fun x => HMul.hMul a x) MeasureTheory.MeasureSpace.volume)) MeasureTheory.MeasureSpace.volume","decl":"theorem smul_map_volume_mul_left {a : ℝ} (h : a ≠ 0) :\n    ENNReal.ofReal |a| • Measure.map (a * ·) volume = volume := by\n  refine (Real.measure_ext_Ioo_rat fun p q => ?_).symm\n  cases' lt_or_gt_of_ne h with h h\n  · simp only [Real.volume_Ioo, Measure.smul_apply, ← ENNReal.ofReal_mul (le_of_lt <| neg_pos.2 h),\n      Measure.map_apply (measurable_const_mul a) measurableSet_Ioo, neg_sub_neg, neg_mul,\n      preimage_const_mul_Ioo_of_neg _ _ h, abs_of_neg h, mul_sub, smul_eq_mul,\n      mul_div_cancel₀ _ (ne_of_lt h)]\n  · simp only [Real.volume_Ioo, Measure.smul_apply, ← ENNReal.ofReal_mul (le_of_lt h),\n      Measure.map_apply (measurable_const_mul a) measurableSet_Ioo, preimage_const_mul_Ioo _ _ h,\n      abs_of_pos h, mul_sub, mul_div_cancel₀ _ (ne_of_gt h), smul_eq_mul]\n\n"}
{"name":"Real.map_volume_mul_left","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n⊢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul a x) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv a))) MeasureTheory.MeasureSpace.volume)","decl":"theorem map_volume_mul_left {a : ℝ} (h : a ≠ 0) :\n    Measure.map (a * ·) volume = ENNReal.ofReal |a⁻¹| • volume := by\n  conv_rhs =>\n    rw [← Real.smul_map_volume_mul_left h, smul_smul, ← ENNReal.ofReal_mul (abs_nonneg _), ←\n      abs_mul, inv_mul_cancel₀ h, abs_one, ENNReal.ofReal_one, one_smul]\n\n"}
{"name":"Real.volume_preimage_mul_left","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\ns : Set Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.preimage (fun x => HMul.hMul a x) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv a))) (MeasureTheory.MeasureSpace.volume s))","decl":"@[simp]\ntheorem volume_preimage_mul_left {a : ℝ} (h : a ≠ 0) (s : Set ℝ) :\n    volume ((a * ·) ⁻¹' s) = ENNReal.ofReal (abs a⁻¹) * volume s :=\n  calc\n    volume ((a * ·) ⁻¹' s) = Measure.map (a * ·) volume s :=\n      ((Homeomorph.mulLeft₀ a h).toMeasurableEquiv.map_apply s).symm\n    _ = ENNReal.ofReal (abs a⁻¹) * volume s := by rw [map_volume_mul_left h]; rfl\n\n"}
{"name":"Real.smul_map_volume_mul_right","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n⊢ Eq (HSMul.hSMul (ENNReal.ofReal (abs a)) (MeasureTheory.Measure.map (fun x => HMul.hMul x a) MeasureTheory.MeasureSpace.volume)) MeasureTheory.MeasureSpace.volume","decl":"theorem smul_map_volume_mul_right {a : ℝ} (h : a ≠ 0) :\n    ENNReal.ofReal |a| • Measure.map (· * a) volume = volume := by\n  simpa only [mul_comm] using Real.smul_map_volume_mul_left h\n\n"}
{"name":"Real.map_volume_mul_right","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n⊢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul x a) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv a))) MeasureTheory.MeasureSpace.volume)","decl":"theorem map_volume_mul_right {a : ℝ} (h : a ≠ 0) :\n    Measure.map (· * a) volume = ENNReal.ofReal |a⁻¹| • volume := by\n  simpa only [mul_comm] using Real.map_volume_mul_left h\n\n"}
{"name":"Real.volume_preimage_mul_right","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\ns : Set Real\n⊢ Eq (MeasureTheory.MeasureSpace.volume (Set.preimage (fun x => HMul.hMul x a) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv a))) (MeasureTheory.MeasureSpace.volume s))","decl":"@[simp]\ntheorem volume_preimage_mul_right {a : ℝ} (h : a ≠ 0) (s : Set ℝ) :\n    volume ((· * a) ⁻¹' s) = ENNReal.ofReal (abs a⁻¹) * volume s :=\n  calc\n    volume ((· * a) ⁻¹' s) = Measure.map (· * a) volume s :=\n      ((Homeomorph.mulRight₀ a h).toMeasurableEquiv.map_apply s).symm\n    _ = ENNReal.ofReal (abs a⁻¹) * volume s := by rw [map_volume_mul_right h]; rfl\n\n"}
{"name":"Real.smul_map_diagonal_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nD : ι → Real\nh : Ne (Matrix.diagonal D).det 0\n⊢ Eq (HSMul.hSMul (ENNReal.ofReal (abs (Matrix.diagonal D).det)) (MeasureTheory.Measure.map (⇑(Matrix.toLin' (Matrix.diagonal D))) MeasureTheory.MeasureSpace.volume)) MeasureTheory.MeasureSpace.volume","decl":"/-- A diagonal matrix rescales Lebesgue according to its determinant. This is a special case of\n`Real.map_matrix_volume_pi_eq_smul_volume_pi`, that one should use instead (and whose proof\nuses this particular case). -/\ntheorem smul_map_diagonal_volume_pi [DecidableEq ι] {D : ι → ℝ} (h : det (diagonal D) ≠ 0) :\n    ENNReal.ofReal (abs (det (diagonal D))) • Measure.map (toLin' (diagonal D)) volume =\n      volume := by\n  refine (Measure.pi_eq fun s hs => ?_).symm\n  simp only [det_diagonal, Measure.coe_smul, Algebra.id.smul_eq_mul, Pi.smul_apply]\n  rw [Measure.map_apply _ (MeasurableSet.univ_pi hs)]\n  swap; · exact Continuous.measurable (LinearMap.continuous_on_pi _)\n  have :\n    (Matrix.toLin' (diagonal D) ⁻¹' Set.pi Set.univ fun i : ι => s i) =\n      Set.pi Set.univ fun i : ι => (D i * ·) ⁻¹' s i := by\n    ext f\n    simp only [LinearMap.coe_proj, Algebra.id.smul_eq_mul, LinearMap.smul_apply, mem_univ_pi,\n      mem_preimage, LinearMap.pi_apply, diagonal_toLin']\n  have B : ∀ i, ofReal (abs (D i)) * volume ((D i * ·) ⁻¹' s i) = volume (s i) := by\n    intro i\n    have A : D i ≠ 0 := by\n      simp only [det_diagonal, Ne] at h\n      exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)\n    rw [volume_preimage_mul_left A, ← mul_assoc, ← ENNReal.ofReal_mul (abs_nonneg _), ← abs_mul,\n      mul_inv_cancel₀ A, abs_one, ENNReal.ofReal_one, one_mul]\n  rw [this, volume_pi_pi, Finset.abs_prod,\n    ENNReal.ofReal_prod_of_nonneg fun i _ => abs_nonneg (D i), ← Finset.prod_mul_distrib]\n  simp only [B]\n\n"}
{"name":"Real.volume_preserving_transvectionStruct","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nt : Matrix.TransvectionStruct ι Real\n⊢ MeasureTheory.MeasurePreserving (⇑(Matrix.toLin' t.toMatrix)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"/-- A transvection preserves Lebesgue measure. -/\ntheorem volume_preserving_transvectionStruct [DecidableEq ι] (t : TransvectionStruct ι ℝ) :\n    MeasurePreserving (toLin' t.toMatrix) := by\n  /- We use `lmarginal` to conveniently use Fubini's theorem.\n    Along the coordinate where there is a shearing, it acts like a\n    translation, and therefore preserves Lebesgue. -/\n  have ht : Measurable (toLin' t.toMatrix) :=\n    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable\n  refine ⟨ht, ?_⟩\n  refine (pi_eq fun s hs ↦ ?_).symm\n  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ ↦ hs i\n  simp_rw [← pi_pi, ← lintegral_indicator_one h2s]\n  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]\n  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)\n    (measurable_one.indicator h2s) ?_\n  simp_rw [lmarginal_singleton]\n  ext x\n  cases t with | mk t_i t_j t_hij t_c =>\n  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, ← Function.update_add,\n    lintegral_add_right_eq_self fun xᵢ ↦ indicator (univ.pi s) 1 (Function.update x t_i xᵢ)]\n\n"}
{"name":"Real.map_matrix_volume_pi_eq_smul_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nM : Matrix ι ι Real\nhM : Ne M.det 0\n⊢ Eq (MeasureTheory.Measure.map (⇑(Matrix.toLin' M)) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv M.det))) MeasureTheory.MeasureSpace.volume)","decl":"/-- Any invertible matrix rescales Lebesgue measure through the absolute value of its\ndeterminant. -/\ntheorem map_matrix_volume_pi_eq_smul_volume_pi [DecidableEq ι] {M : Matrix ι ι ℝ} (hM : det M ≠ 0) :\n    Measure.map (toLin' M) volume = ENNReal.ofReal (abs (det M)⁻¹) • volume := by\n  -- This follows from the cases we have already proved, of diagonal matrices and transvections,\n  -- as these matrices generate all invertible matrices.\n  apply diagonal_transvection_induction_of_det_ne_zero _ M hM\n  · intro D hD\n    conv_rhs => rw [← smul_map_diagonal_volume_pi hD]\n    rw [smul_smul, ← ENNReal.ofReal_mul (abs_nonneg _), ← abs_mul, inv_mul_cancel₀ hD, abs_one,\n      ENNReal.ofReal_one, one_smul]\n  · intro t\n    simp_rw [Matrix.TransvectionStruct.det, _root_.inv_one, abs_one, ENNReal.ofReal_one, one_smul,\n      (volume_preserving_transvectionStruct _).map_eq]\n  · intro A B _ _ IHA IHB\n    rw [toLin'_mul, det_mul, LinearMap.coe_comp, ← Measure.map_map, IHB, Measure.map_smul, IHA,\n      smul_smul, ← ENNReal.ofReal_mul (abs_nonneg _), ← abs_mul, mul_comm, mul_inv]\n    · apply Continuous.measurable\n      apply LinearMap.continuous_on_pi\n    · apply Continuous.measurable\n      apply LinearMap.continuous_on_pi\n\n"}
{"name":"Real.map_linearMap_volume_pi_eq_smul_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"ι : Type u_1\ninst✝ : Fintype ι\nf : LinearMap (RingHom.id Real) (ι → Real) (ι → Real)\nhf : Ne (LinearMap.det f) 0\n⊢ Eq (MeasureTheory.Measure.map (⇑f) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) MeasureTheory.MeasureSpace.volume)","decl":"/-- Any invertible linear map rescales Lebesgue measure through the absolute value of its\ndeterminant. -/\ntheorem map_linearMap_volume_pi_eq_smul_volume_pi {f : (ι → ℝ) →ₗ[ℝ] ι → ℝ}\n    (hf : LinearMap.det f ≠ 0) : Measure.map f volume =\n      ENNReal.ofReal (abs (LinearMap.det f)⁻¹) • volume := by\n  classical\n    -- this is deduced from the matrix case\n    let M := LinearMap.toMatrix' f\n    have A : LinearMap.det f = det M := by simp only [M, LinearMap.det_toMatrix']\n    have B : f = toLin' M := by simp only [M, toLin'_toMatrix']\n    rw [A, B]\n    apply map_matrix_volume_pi_eq_smul_volume_pi\n    rwa [A] at hf\n\n"}
{"name":"regionBetween_subset","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\nf g : α → Real\ns : Set α\n⊢ HasSubset.Subset (regionBetween f g s) (SProd.sprod s Set.univ)","decl":"theorem regionBetween_subset (f g : α → ℝ) (s : Set α) : regionBetween f g s ⊆ s ×ˢ univ := by\n  simpa only [prod_univ, regionBetween, Set.preimage, setOf_subset_setOf] using fun a => And.left\n\n"}
{"name":"measurableSet_regionBetween","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf g : α → Real\ns : Set α\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n⊢ MeasurableSet (regionBetween f g s)","decl":"/-- The region between two measurable functions on a measurable set is measurable. -/\ntheorem measurableSet_regionBetween (hf : Measurable f) (hg : Measurable g) (hs : MeasurableSet s) :\n    MeasurableSet (regionBetween f g s) := by\n  dsimp only [regionBetween, Ioo, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_lt (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_lt measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_region_between_oc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf g : α → Real\ns : Set α\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n⊢ MeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ioc (f p.1) (g p.1)) p.2))","decl":"/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graph of the upper function. -/\ntheorem measurableSet_region_between_oc (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    MeasurableSet { p : α × ℝ | p.fst ∈ s ∧ p.snd ∈ Ioc (f p.fst) (g p.fst) } := by\n  dsimp only [regionBetween, Ioc, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_lt (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_le measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_region_between_co","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf g : α → Real\ns : Set α\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n⊢ MeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ico (f p.1) (g p.1)) p.2))","decl":"/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graph of the lower function. -/\ntheorem measurableSet_region_between_co (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    MeasurableSet { p : α × ℝ | p.fst ∈ s ∧ p.snd ∈ Ico (f p.fst) (g p.fst) } := by\n  dsimp only [regionBetween, Ico, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_le (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_lt measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_region_between_cc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf g : α → Real\ns : Set α\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n⊢ MeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Icc (f p.1) (g p.1)) p.2))","decl":"/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graphs of both functions. -/\ntheorem measurableSet_region_between_cc (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    MeasurableSet { p : α × ℝ | p.fst ∈ s ∧ p.snd ∈ Icc (f p.fst) (g p.fst) } := by\n  dsimp only [regionBetween, Icc, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_le (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_le measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_graph","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\nhf : Measurable f\n⊢ MeasurableSet (setOf fun p => Eq p.2 (f p.1))","decl":"/-- The graph of a measurable function is a measurable set. -/\ntheorem measurableSet_graph (hf : Measurable f) :\n    MeasurableSet { p : α × ℝ | p.snd = f p.fst } := by\n  simpa using measurableSet_region_between_cc hf hf MeasurableSet.univ\n\n"}
{"name":"volume_regionBetween_eq_lintegral'","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\ns : Set α\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n⊢ Eq ((μ.prod MeasureTheory.MeasureSpace.volume) (regionBetween f g s)) (MeasureTheory.lintegral (μ.restrict s) fun y => ENNReal.ofReal (HSub.hSub g f y))","decl":"theorem volume_regionBetween_eq_lintegral' (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    μ.prod volume (regionBetween f g s) = ∫⁻ y in s, ENNReal.ofReal ((g - f) y) ∂μ := by\n  classical\n    rw [Measure.prod_apply]\n    · have h :\n        (fun x => volume { a | x ∈ s ∧ a ∈ Ioo (f x) (g x) }) =\n          s.indicator fun x => ENNReal.ofReal (g x - f x) := by\n        funext x\n        rw [indicator_apply]\n        split_ifs with h\n        · have hx : { a | x ∈ s ∧ a ∈ Ioo (f x) (g x) } = Ioo (f x) (g x) := by simp [h, Ioo]\n          simp only [hx, Real.volume_Ioo, sub_zero]\n        · have hx : { a | x ∈ s ∧ a ∈ Ioo (f x) (g x) } = ∅ := by simp [h]\n          simp only [hx, measure_empty]\n      dsimp only [regionBetween, preimage_setOf_eq]\n      rw [h, lintegral_indicator] <;> simp only [hs, Pi.sub_apply]\n    · exact measurableSet_regionBetween hf hg hs\n\n"}
{"name":"volume_regionBetween_eq_lintegral","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\ns : Set α\ninst✝ : MeasureTheory.SFinite μ\nhf : AEMeasurable f (μ.restrict s)\nhg : AEMeasurable g (μ.restrict s)\nhs : MeasurableSet s\n⊢ Eq ((μ.prod MeasureTheory.MeasureSpace.volume) (regionBetween f g s)) (MeasureTheory.lintegral (μ.restrict s) fun y => ENNReal.ofReal (HSub.hSub g f y))","decl":"/-- The volume of the region between two almost everywhere measurable functions on a measurable set\n    can be represented as a Lebesgue integral. -/\ntheorem volume_regionBetween_eq_lintegral [SFinite μ] (hf : AEMeasurable f (μ.restrict s))\n    (hg : AEMeasurable g (μ.restrict s)) (hs : MeasurableSet s) :\n    μ.prod volume (regionBetween f g s) = ∫⁻ y in s, ENNReal.ofReal ((g - f) y) ∂μ := by\n  have h₁ :\n    (fun y => ENNReal.ofReal ((g - f) y)) =ᵐ[μ.restrict s] fun y =>\n      ENNReal.ofReal ((AEMeasurable.mk g hg - AEMeasurable.mk f hf) y) :=\n    (hg.ae_eq_mk.sub hf.ae_eq_mk).fun_comp ENNReal.ofReal\n  have h₂ :\n    (μ.restrict s).prod volume (regionBetween f g s) =\n      (μ.restrict s).prod volume\n        (regionBetween (AEMeasurable.mk f hf) (AEMeasurable.mk g hg) s) := by\n    apply measure_congr\n    apply EventuallyEq.rfl.inter\n    exact\n      ((quasiMeasurePreserving_fst.ae_eq_comp hf.ae_eq_mk).comp₂ _ EventuallyEq.rfl).inter\n        (EventuallyEq.rfl.comp₂ _ <| quasiMeasurePreserving_fst.ae_eq_comp hg.ae_eq_mk)\n  rw [lintegral_congr_ae h₁, ←\n    volume_regionBetween_eq_lintegral' hf.measurable_mk hg.measurable_mk hs]\n  convert h₂ using 1\n  · rw [Measure.restrict_prod_eq_prod_univ]\n    exact (Measure.restrict_eq_self _ (regionBetween_subset f g s)).symm\n  · rw [Measure.restrict_prod_eq_prod_univ]\n    exact\n      (Measure.restrict_eq_self _\n          (regionBetween_subset (AEMeasurable.mk f hf) (AEMeasurable.mk g hg) s)).symm\n\n"}
{"name":"nullMeasurableSet_regionBetween","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nf_mble : AEMeasurable f μ\ng_mble : AEMeasurable g μ\ns : Set α\ns_mble : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ioo (f p.1) (g p.1)) p.2)) (μ.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable. -/\nlemma nullMeasurableSet_regionBetween (μ : Measure α)\n    {f g : α → ℝ} (f_mble : AEMeasurable f μ) (g_mble : AEMeasurable g μ)\n    {s : Set α} (s_mble : NullMeasurableSet s μ) :\n    NullMeasurableSet {p : α × ℝ | p.1 ∈ s ∧ p.snd ∈ Ioo (f p.fst) (g p.fst)} (μ.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  · exact nullMeasurableSet_lt (AEMeasurable.fst f_mble) measurable_snd.aemeasurable\n  · exact nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst g_mble)\n\n"}
{"name":"nullMeasurableSet_region_between_oc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nf_mble : AEMeasurable f μ\ng_mble : AEMeasurable g μ\ns : Set α\ns_mble : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ioc (f p.1) (g p.1)) p.2)) (μ.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable;\na version for the region together with the graph of the upper function. -/\nlemma nullMeasurableSet_region_between_oc (μ : Measure α)\n    {f g : α → ℝ} (f_mble : AEMeasurable f μ) (g_mble : AEMeasurable g μ)\n    {s : Set α} (s_mble : NullMeasurableSet s μ) :\n    NullMeasurableSet {p : α × ℝ | p.1 ∈ s ∧ p.snd ∈ Ioc (f p.fst) (g p.fst)} (μ.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  · exact nullMeasurableSet_lt (AEMeasurable.fst f_mble) measurable_snd.aemeasurable\n  · change NullMeasurableSet {p : α × ℝ | p.snd ≤ g p.fst} (μ.prod volume)\n    rw [show {p : α × ℝ | p.snd ≤ g p.fst} = {p : α × ℝ | g p.fst < p.snd}ᶜ by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt (AEMeasurable.fst g_mble) measurable_snd.aemeasurable).compl\n\n"}
{"name":"nullMeasurableSet_region_between_co","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nf_mble : AEMeasurable f μ\ng_mble : AEMeasurable g μ\ns : Set α\ns_mble : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ico (f p.1) (g p.1)) p.2)) (μ.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable;\na version for the region together with the graph of the lower function. -/\nlemma nullMeasurableSet_region_between_co (μ : Measure α)\n    {f g : α → ℝ} (f_mble : AEMeasurable f μ) (g_mble : AEMeasurable g μ)\n    {s : Set α} (s_mble : NullMeasurableSet s μ) :\n    NullMeasurableSet {p : α × ℝ | p.1 ∈ s ∧ p.snd ∈ Ico (f p.fst) (g p.fst)} (μ.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  · change NullMeasurableSet {p : α × ℝ | f p.fst ≤ p.snd} (μ.prod volume)\n    rw [show {p : α × ℝ | f p.fst ≤ p.snd} = {p : α × ℝ | p.snd < f p.fst}ᶜ by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst f_mble)).compl\n  · exact nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst g_mble)\n\n"}
{"name":"nullMeasurableSet_region_between_cc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nf_mble : AEMeasurable f μ\ng_mble : AEMeasurable g μ\ns : Set α\ns_mble : MeasureTheory.NullMeasurableSet s μ\n⊢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Icc (f p.1) (g p.1)) p.2)) (μ.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable;\na version for the region together with the graphs of both functions. -/\nlemma nullMeasurableSet_region_between_cc (μ : Measure α)\n    {f g : α → ℝ} (f_mble : AEMeasurable f μ) (g_mble : AEMeasurable g μ)\n    {s : Set α} (s_mble : NullMeasurableSet s μ) :\n    NullMeasurableSet {p : α × ℝ | p.1 ∈ s ∧ p.snd ∈ Icc (f p.fst) (g p.fst)} (μ.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  · change NullMeasurableSet {p : α × ℝ | f p.fst ≤ p.snd} (μ.prod volume)\n    rw [show {p : α × ℝ | f p.fst ≤ p.snd} = {p : α × ℝ | p.snd < f p.fst}ᶜ by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst f_mble)).compl\n  · change NullMeasurableSet {p : α × ℝ | p.snd ≤ g p.fst} (μ.prod volume)\n    rw [show {p : α × ℝ | p.snd ≤ g p.fst} = {p : α × ℝ | g p.fst < p.snd}ᶜ by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt (AEMeasurable.fst g_mble) measurable_snd.aemeasurable).compl\n\n"}
{"name":"ae_restrict_of_ae_restrict_inter_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"μ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.NoAtoms μ\ns : Set Real\np : Real → Prop\nh : ∀ (a b : Real), Membership.mem s a → Membership.mem s b → LT.lt a b → Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict (Inter.inter s (Set.Ioo a b))))\n⊢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (μ.restrict s))","decl":"/-- Consider a real set `s`. If a property is true almost everywhere in `s ∩ (a, b)` for\nall `a, b ∈ s`, then it is true almost everywhere in `s`. Formulated with `μ.restrict`.\nSee also `ae_of_mem_of_ae_of_mem_inter_Ioo`. -/\ntheorem ae_restrict_of_ae_restrict_inter_Ioo {μ : Measure ℝ} [NoAtoms μ] {s : Set ℝ} {p : ℝ → Prop}\n    (h : ∀ a b, a ∈ s → b ∈ s → a < b → ∀ᵐ x ∂μ.restrict (s ∩ Ioo a b), p x) :\n    ∀ᵐ x ∂μ.restrict s, p x := by\n  /- By second-countability, we cover `s` by countably many intervals `(a, b)` (except maybe for\n    two endpoints, which don't matter since `μ` does not have any atom). -/\n  let T : s × s → Set ℝ := fun p => Ioo p.1 p.2\n  let u := ⋃ i : ↥s × ↥s, T i\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo'\n  obtain ⟨A, A_count, hA⟩ :\n    ∃ A : Set (↥s × ↥s), A.Countable ∧ ⋃ i ∈ A, T i = ⋃ i : ↥s × ↥s, T i :=\n    isOpen_iUnion_countable _ fun p => isOpen_Ioo\n  have : s ⊆ s \\ u ∪ ⋃ p ∈ A, s ∩ T p := by\n    intro x hx\n    by_cases h'x : x ∈ ⋃ i : ↥s × ↥s, T i\n    · rw [← hA] at h'x\n      obtain ⟨p, pA, xp⟩ : ∃ p : ↥s × ↥s, p ∈ A ∧ x ∈ T p := by\n        simpa only [mem_iUnion, exists_prop, SetCoe.exists, exists_and_right] using h'x\n      right\n      exact mem_biUnion pA ⟨hx, xp⟩\n    · exact Or.inl ⟨hx, h'x⟩\n  apply ae_restrict_of_ae_restrict_of_subset this\n  rw [ae_restrict_union_iff, ae_restrict_biUnion_iff _ A_count]\n  constructor\n  · have : μ.restrict (s \\ u) = 0 := by simp only [restrict_eq_zero, hfinite.measure_zero]\n    simp only [this, ae_zero, eventually_bot]\n  · rintro ⟨⟨a, as⟩, ⟨b, bs⟩⟩ -\n    dsimp [T]\n    rcases le_or_lt b a with (hba | hab)\n    · simp only [Ioo_eq_empty_of_le hba, inter_empty, restrict_empty, ae_zero, eventually_bot]\n    · exact h a b as bs hab\n\n"}
{"name":"ae_of_mem_of_ae_of_mem_inter_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"μ : MeasureTheory.Measure Real\ninst✝ : MeasureTheory.NoAtoms μ\ns : Set Real\np : Real → Prop\nh : ∀ (a b : Real), Membership.mem s a → Membership.mem s b → LT.lt a b → Filter.Eventually (fun x => Membership.mem (Inter.inter s (Set.Ioo a b)) x → p x) (MeasureTheory.ae μ)\n⊢ Filter.Eventually (fun x => Membership.mem s x → p x) (MeasureTheory.ae μ)","decl":"/-- Consider a real set `s`. If a property is true almost everywhere in `s ∩ (a, b)` for\nall `a, b ∈ s`, then it is true almost everywhere in `s`. Formulated with bare membership.\nSee also `ae_restrict_of_ae_restrict_inter_Ioo`. -/\ntheorem ae_of_mem_of_ae_of_mem_inter_Ioo {μ : Measure ℝ} [NoAtoms μ] {s : Set ℝ} {p : ℝ → Prop}\n    (h : ∀ a b, a ∈ s → b ∈ s → a < b → ∀ᵐ x ∂μ, x ∈ s ∩ Ioo a b → p x) :\n    ∀ᵐ x ∂μ, x ∈ s → p x := by\n  /- By second-countability, we cover `s` by countably many intervals `(a, b)` (except maybe for\n    two endpoints, which don't matter since `μ` does not have any atom). -/\n  let T : s × s → Set ℝ := fun p => Ioo p.1 p.2\n  let u := ⋃ i : ↥s × ↥s, T i\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo'\n  obtain ⟨A, A_count, hA⟩ :\n    ∃ A : Set (↥s × ↥s), A.Countable ∧ ⋃ i ∈ A, T i = ⋃ i : ↥s × ↥s, T i :=\n    isOpen_iUnion_countable _ fun p => isOpen_Ioo\n  have M : ∀ᵐ x ∂μ, x ∉ s \\ u := hfinite.countable.ae_not_mem _\n  have M' : ∀ᵐ x ∂μ, ∀ (i : ↥s × ↥s), i ∈ A → x ∈ s ∩ T i → p x := by\n    rw [ae_ball_iff A_count]\n    rintro ⟨⟨a, as⟩, ⟨b, bs⟩⟩ -\n    change ∀ᵐ x : ℝ ∂μ, x ∈ s ∩ Ioo a b → p x\n    rcases le_or_lt b a with (hba | hab)\n    · simp only [Ioo_eq_empty_of_le hba, inter_empty, IsEmpty.forall_iff, eventually_true,\n        mem_empty_iff_false]\n    · exact h a b as bs hab\n  filter_upwards [M, M'] with x hx h'x\n  intro xs\n  by_cases Hx : x ∈ ⋃ i : ↥s × ↥s, T i\n  · rw [← hA] at Hx\n    obtain ⟨p, pA, xp⟩ : ∃ p : ↥s × ↥s, p ∈ A ∧ x ∈ T p := by\n      simpa only [mem_iUnion, exists_prop, SetCoe.exists, exists_and_right] using Hx\n    apply h'x p pA ⟨xs, xp⟩\n  · exact False.elim (hx ⟨xs, Hx⟩)\n"}
