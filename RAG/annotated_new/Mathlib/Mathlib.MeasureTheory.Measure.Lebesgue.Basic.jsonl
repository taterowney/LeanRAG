{"name":"Real.volume_eq_stieltjes_id","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"‚ä¢ Eq MeasureTheory.MeasureSpace.volume StieltjesFunction.id.measure","decl":"/-- The volume on the real line (as a particular case of the volume on a finite-dimensional\ninner product space) coincides with the Stieltjes measure coming from the identity function. -/\ntheorem volume_eq_stieltjes_id : (volume : Measure ‚Ñù) = StieltjesFunction.id.measure := by\n  haveI : IsAddLeftInvariant StieltjesFunction.id.measure :=\n    ‚ü®fun a =>\n      Eq.symm <|\n        Real.measure_ext_Ioo_rat fun p q => by\n          simp only [Measure.map_apply (measurable_const_add a) measurableSet_Ioo,\n            sub_sub_sub_cancel_right, StieltjesFunction.measure_Ioo, StieltjesFunction.id_leftLim,\n            StieltjesFunction.id_apply, id, preimage_const_add_Ioo]‚ü©\n  have A : StieltjesFunction.id.measure (stdOrthonormalBasis ‚Ñù ‚Ñù).toBasis.parallelepiped = 1 := by\n    change StieltjesFunction.id.measure (parallelepiped (stdOrthonormalBasis ‚Ñù ‚Ñù)) = 1\n    rcases parallelepiped_orthonormalBasis_one_dim (stdOrthonormalBasis ‚Ñù ‚Ñù) with (H | H) <;>\n      simp only [H, StieltjesFunction.measure_Icc, StieltjesFunction.id_apply, id, tsub_zero,\n        StieltjesFunction.id_leftLim, sub_neg_eq_add, zero_add, ENNReal.ofReal_one]\n  conv_rhs =>\n    rw [addHaarMeasure_unique StieltjesFunction.id.measure\n        (stdOrthonormalBasis ‚Ñù ‚Ñù).toBasis.parallelepiped, A]\n  simp only [volume, Basis.addHaar, one_smul]\n\n"}
{"name":"Real.volume_val","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"s : Set Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume s) (StieltjesFunction.id.measure s)","decl":"theorem volume_val (s) : volume s = StieltjesFunction.id.measure s := by\n  simp [volume_eq_stieltjes_id]\n\n"}
{"name":"Real.volume_Ico","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ico a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Ico {a b : ‚Ñù} : volume (Ico a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_Icc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Icc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Icc {a b : ‚Ñù} : volume (Icc a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ioo a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Ioo {a b : ‚Ñù} : volume (Ioo a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_Ioc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ioc a b)) (ENNReal.ofReal (HSub.hSub b a))","decl":"@[simp]\ntheorem volume_Ioc {a b : ‚Ñù} : volume (Ioc a b) = ofReal (b - a) := by simp [volume_val]\n\n"}
{"name":"Real.volume_singleton","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Singleton.singleton a)) 0","decl":"theorem volume_singleton {a : ‚Ñù} : volume ({a} : Set ‚Ñù) = 0 := by simp [volume_val]\n\n"}
{"name":"Real.volume_univ","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"‚ä¢ Eq (MeasureTheory.MeasureSpace.volume Set.univ) Top.top","decl":"theorem volume_univ : volume (univ : Set ‚Ñù) = ‚àû :=\n  ENNReal.eq_top_of_forall_nnreal_le fun r =>\n    calc\n      (r : ‚Ñù‚â•0‚àû) = volume (Icc (0 : ‚Ñù) r) := by simp\n      _ ‚â§ volume univ := measure_mono (subset_univ _)\n\n"}
{"name":"Real.volume_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a r : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball a r)) (ENNReal.ofReal (HMul.hMul 2 r))","decl":"@[simp]\ntheorem volume_ball (a r : ‚Ñù) : volume (Metric.ball a r) = ofReal (2 * r) := by\n  rw [ball_eq_Ioo, volume_Ioo, ‚Üê sub_add, add_sub_cancel_left, two_mul]\n\n"}
{"name":"Real.volume_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a r : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall a r)) (ENNReal.ofReal (HMul.hMul 2 r))","decl":"@[simp]\ntheorem volume_closedBall (a r : ‚Ñù) : volume (Metric.closedBall a r) = ofReal (2 * r) := by\n  rw [closedBall_eq_Icc, volume_Icc, ‚Üê sub_add, add_sub_cancel_left, two_mul]\n\n"}
{"name":"Real.volume_emetric_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nr : ENNReal\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (EMetric.ball a r)) (HMul.hMul 2 r)","decl":"@[simp]\ntheorem volume_emetric_ball (a : ‚Ñù) (r : ‚Ñù‚â•0‚àû) : volume (EMetric.ball a r) = 2 * r := by\n  rcases eq_or_ne r ‚àû with (rfl | hr)\n  ¬∑ rw [Metric.emetric_ball_top, volume_univ, two_mul, _root_.top_add]\n  ¬∑ lift r to ‚Ñù‚â•0 using hr\n    rw [Metric.emetric_ball_nnreal, volume_ball, two_mul, ‚Üê NNReal.coe_add,\n      ENNReal.ofReal_coe_nnreal, ENNReal.coe_add, two_mul]\n\n"}
{"name":"Real.volume_emetric_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nr : ENNReal\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (EMetric.closedBall a r)) (HMul.hMul 2 r)","decl":"@[simp]\ntheorem volume_emetric_closedBall (a : ‚Ñù) (r : ‚Ñù‚â•0‚àû) : volume (EMetric.closedBall a r) = 2 * r := by\n  rcases eq_or_ne r ‚àû with (rfl | hr)\n  ¬∑ rw [EMetric.closedBall_top, volume_univ, two_mul, _root_.top_add]\n  ¬∑ lift r to ‚Ñù‚â•0 using hr\n    rw [Metric.emetric_closedBall_nnreal, volume_closedBall, two_mul, ‚Üê NNReal.coe_add,\n      ENNReal.ofReal_coe_nnreal, ENNReal.coe_add, two_mul]\n\n"}
{"name":"Real.noAtoms_volume","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"‚ä¢ MeasureTheory.NoAtoms MeasureTheory.MeasureSpace.volume","decl":"instance noAtoms_volume : NoAtoms (volume : Measure ‚Ñù) :=\n  ‚ü®fun _ => volume_singleton‚ü©\n\n"}
{"name":"Real.volume_interval","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a b : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.uIcc a b)) (ENNReal.ofReal (abs (HSub.hSub b a)))","decl":"@[simp]\ntheorem volume_interval {a b : ‚Ñù} : volume (uIcc a b) = ofReal |b - a| := by\n  rw [‚Üê Icc_min_max, volume_Icc, max_sub_min_eq_abs]\n\n"}
{"name":"Real.volume_Ioi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ioi a)) Top.top","decl":"@[simp]\ntheorem volume_Ioi {a : ‚Ñù} : volume (Ioi a) = ‚àû :=\n  top_unique <|\n    le_of_tendsto' ENNReal.tendsto_nat_nhds_top fun n =>\n      calc\n        (n : ‚Ñù‚â•0‚àû) = volume (Ioo a (a + n)) := by simp\n        _ ‚â§ volume (Ioi a) := measure_mono Ioo_subset_Ioi_self\n\n"}
{"name":"Real.volume_Ici","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Ici a)) Top.top","decl":"@[simp]\ntheorem volume_Ici {a : ‚Ñù} : volume (Ici a) = ‚àû := by rw [‚Üê measure_congr Ioi_ae_eq_Ici]; simp\n\n"}
{"name":"Real.volume_Iio","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Iio a)) Top.top","decl":"@[simp]\ntheorem volume_Iio {a : ‚Ñù} : volume (Iio a) = ‚àû :=\n  top_unique <|\n    le_of_tendsto' ENNReal.tendsto_nat_nhds_top fun n =>\n      calc\n        (n : ‚Ñù‚â•0‚àû) = volume (Ioo (a - n) a) := by simp\n        _ ‚â§ volume (Iio a) := measure_mono Ioo_subset_Iio_self\n\n"}
{"name":"Real.volume_Iic","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Iic a)) Top.top","decl":"@[simp]\ntheorem volume_Iic {a : ‚Ñù} : volume (Iic a) = ‚àû := by rw [‚Üê measure_congr Iio_ae_eq_Iic]; simp\n\n"}
{"name":"Real.locallyFinite_volume","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"‚ä¢ MeasureTheory.IsLocallyFiniteMeasure MeasureTheory.MeasureSpace.volume","decl":"instance locallyFinite_volume : IsLocallyFiniteMeasure (volume : Measure ‚Ñù) :=\n  ‚ü®fun x =>\n    ‚ü®Ioo (x - 1) (x + 1),\n      IsOpen.mem_nhds isOpen_Ioo ‚ü®sub_lt_self _ zero_lt_one, lt_add_of_pos_right _ zero_lt_one‚ü©, by\n      simp only [Real.volume_Ioo, ENNReal.ofReal_lt_top]‚ü©‚ü©\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Icc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Icc x y))","decl":"instance isFiniteMeasure_restrict_Icc (x y : ‚Ñù) : IsFiniteMeasure (volume.restrict (Icc x y)) :=\n  ‚ü®by simp‚ü©\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Ico","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Ico x y))","decl":"instance isFiniteMeasure_restrict_Ico (x y : ‚Ñù) : IsFiniteMeasure (volume.restrict (Ico x y)) :=\n  ‚ü®by simp‚ü©\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Ioc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc x y))","decl":"instance isFiniteMeasure_restrict_Ioc (x y : ‚Ñù) : IsFiniteMeasure (volume.restrict (Ioc x y)) :=\n  ‚ü®by simp‚ü©\n\n"}
{"name":"Real.isFiniteMeasure_restrict_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"x y : Real\n‚ä¢ MeasureTheory.IsFiniteMeasure (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioo x y))","decl":"instance isFiniteMeasure_restrict_Ioo (x y : ‚Ñù) : IsFiniteMeasure (volume.restrict (Ioo x y)) :=\n  ‚ü®by simp‚ü©\n\n"}
{"name":"Real.volume_le_diam","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"s : Set Real\n‚ä¢ LE.le (MeasureTheory.MeasureSpace.volume s) (EMetric.diam s)","decl":"theorem volume_le_diam (s : Set ‚Ñù) : volume s ‚â§ EMetric.diam s := by\n  by_cases hs : Bornology.IsBounded s\n  ¬∑ rw [Real.ediam_eq hs, ‚Üê volume_Icc]\n    exact volume.mono hs.subset_Icc_sInf_sSup\n  ¬∑ rw [Metric.ediam_of_unbounded hs]; exact le_top\n\n"}
{"name":"Filter.Eventually.volume_pos_of_nhds_real","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"p : Real ‚Üí Prop\na : Real\nh : Filter.Eventually (fun x => p x) (nhds a)\n‚ä¢ LT.lt 0 (MeasureTheory.MeasureSpace.volume (setOf fun x => p x))","decl":"theorem _root_.Filter.Eventually.volume_pos_of_nhds_real {p : ‚Ñù ‚Üí Prop} {a : ‚Ñù}\n    (h : ‚àÄ·∂† x in ùìù a, p x) : (0 : ‚Ñù‚â•0‚àû) < volume { x | p x } := by\n  rcases h.exists_Ioo_subset with ‚ü®l, u, hx, hs‚ü©\n  refine lt_of_lt_of_le ?_ (measure_mono hs)\n  simpa [-mem_Ioo] using hx.1.trans hx.2\n\n"}
{"name":"Real.volume_Icc_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Icc a b)) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_Icc_pi {a b : Œπ ‚Üí ‚Ñù} : volume (Icc a b) = ‚àè i, ENNReal.ofReal (b i - a i) := by\n  rw [‚Üê pi_univ_Icc, volume_pi_pi]\n  simp only [Real.volume_Icc]\n\n"}
{"name":"Real.volume_Icc_pi_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\nh : LE.le a b\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.Icc a b)).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_Icc_pi_toReal {a b : Œπ ‚Üí ‚Ñù} (h : a ‚â§ b) :\n    (volume (Icc a b)).toReal = ‚àè i, (b i - a i) := by\n  simp only [volume_Icc_pi, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioo (a i) (b i))) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_pi_Ioo {a b : Œπ ‚Üí ‚Ñù} :\n    volume (pi univ fun i => Ioo (a i) (b i)) = ‚àè i, ENNReal.ofReal (b i - a i) :=\n  (measure_congr Measure.univ_pi_Ioo_ae_eq_Icc).trans volume_Icc_pi\n\n"}
{"name":"Real.volume_pi_Ioo_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\nh : LE.le a b\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioo (a i) (b i))).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_pi_Ioo_toReal {a b : Œπ ‚Üí ‚Ñù} (h : a ‚â§ b) :\n    (volume (pi univ fun i => Ioo (a i) (b i))).toReal = ‚àè i, (b i - a i) := by\n  simp only [volume_pi_Ioo, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_Ioc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioc (a i) (b i))) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_pi_Ioc {a b : Œπ ‚Üí ‚Ñù} :\n    volume (pi univ fun i => Ioc (a i) (b i)) = ‚àè i, ENNReal.ofReal (b i - a i) :=\n  (measure_congr Measure.univ_pi_Ioc_ae_eq_Icc).trans volume_Icc_pi\n\n"}
{"name":"Real.volume_pi_Ioc_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\nh : LE.le a b\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ioc (a i) (b i))).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_pi_Ioc_toReal {a b : Œπ ‚Üí ‚Ñù} (h : a ‚â§ b) :\n    (volume (pi univ fun i => Ioc (a i) (b i))).toReal = ‚àè i, (b i - a i) := by\n  simp only [volume_pi_Ioc, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_Ico","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ico (a i) (b i))) (Finset.univ.prod fun i => ENNReal.ofReal (HSub.hSub (b i) (a i)))","decl":"theorem volume_pi_Ico {a b : Œπ ‚Üí ‚Ñù} :\n    volume (pi univ fun i => Ico (a i) (b i)) = ‚àè i, ENNReal.ofReal (b i - a i) :=\n  (measure_congr Measure.univ_pi_Ico_ae_eq_Icc).trans volume_Icc_pi\n\n"}
{"name":"Real.volume_pi_Ico_toReal","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na b : Œπ ‚Üí Real\nh : LE.le a b\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.univ.pi fun i => Set.Ico (a i) (b i))).toReal (Finset.univ.prod fun i => HSub.hSub (b i) (a i))","decl":"@[simp]\ntheorem volume_pi_Ico_toReal {a b : Œπ ‚Üí ‚Ñù} (h : a ‚â§ b) :\n    (volume (pi univ fun i => Ico (a i) (b i))).toReal = ‚àè i, (b i - a i) := by\n  simp only [volume_pi_Ico, ENNReal.toReal_prod, ENNReal.toReal_ofReal (sub_nonneg.2 (h _))]\n\n"}
{"name":"Real.volume_pi_ball","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na : Œπ ‚Üí Real\nr : Real\nhr : LT.lt 0 r\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Metric.ball a r)) (ENNReal.ofReal (HPow.hPow (HMul.hMul 2 r) (Fintype.card Œπ)))","decl":"@[simp]\nnonrec theorem volume_pi_ball (a : Œπ ‚Üí ‚Ñù) {r : ‚Ñù} (hr : 0 < r) :\n    volume (Metric.ball a r) = ENNReal.ofReal ((2 * r) ^ Fintype.card Œπ) := by\n  simp only [MeasureTheory.volume_pi_ball a hr, volume_ball, Finset.prod_const]\n  exact (ENNReal.ofReal_pow (mul_nonneg zero_le_two hr.le) _).symm\n\n"}
{"name":"Real.volume_pi_closedBall","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\na : Œπ ‚Üí Real\nr : Real\nhr : LE.le 0 r\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Metric.closedBall a r)) (ENNReal.ofReal (HPow.hPow (HMul.hMul 2 r) (Fintype.card Œπ)))","decl":"@[simp]\nnonrec theorem volume_pi_closedBall (a : Œπ ‚Üí ‚Ñù) {r : ‚Ñù} (hr : 0 ‚â§ r) :\n    volume (Metric.closedBall a r) = ENNReal.ofReal ((2 * r) ^ Fintype.card Œπ) := by\n  simp only [MeasureTheory.volume_pi_closedBall a hr, volume_closedBall, Finset.prod_const]\n  exact (ENNReal.ofReal_pow (mul_nonneg zero_le_two hr) _).symm\n\n"}
{"name":"Real.volume_pi_le_prod_diam","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\ns : Set (Œπ ‚Üí Real)\n‚ä¢ LE.le (MeasureTheory.MeasureSpace.volume s) (Finset.univ.prod fun i => EMetric.diam (Set.image (Function.eval i) s))","decl":"theorem volume_pi_le_prod_diam (s : Set (Œπ ‚Üí ‚Ñù)) :\n    volume s ‚â§ ‚àè i : Œπ, EMetric.diam (Function.eval i '' s) :=\n  calc\n    volume s ‚â§ volume (pi univ fun i => closure (Function.eval i '' s)) :=\n      volume.mono <|\n        Subset.trans (subset_pi_eval_image univ s) <| pi_mono fun _ _ => subset_closure\n    _ = ‚àè i, volume (closure <| Function.eval i '' s) := volume_pi_pi _\n    _ ‚â§ ‚àè i : Œπ, EMetric.diam (Function.eval i '' s) :=\n      Finset.prod_le_prod' fun _ _ => (volume_le_diam _).trans_eq (EMetric.diam_closure _)\n\n"}
{"name":"Real.volume_pi_le_diam_pow","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\ns : Set (Œπ ‚Üí Real)\n‚ä¢ LE.le (MeasureTheory.MeasureSpace.volume s) (HPow.hPow (EMetric.diam s) (Fintype.card Œπ))","decl":"theorem volume_pi_le_diam_pow (s : Set (Œπ ‚Üí ‚Ñù)) : volume s ‚â§ EMetric.diam s ^ Fintype.card Œπ :=\n  calc\n    volume s ‚â§ ‚àè i : Œπ, EMetric.diam (Function.eval i '' s) := volume_pi_le_prod_diam s\n    _ ‚â§ ‚àè _i : Œπ, (1 : ‚Ñù‚â•0) * EMetric.diam s :=\n      (Finset.prod_le_prod' fun i _ => (LipschitzWith.eval i).ediam_image_le s)\n    _ = EMetric.diam s ^ Fintype.card Œπ := by\n      simp only [ENNReal.coe_one, one_mul, Finset.prod_const, Fintype.card]\n\n"}
{"name":"Real.smul_map_volume_mul_left","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n‚ä¢ Eq (HSMul.hSMul (ENNReal.ofReal (abs a)) (MeasureTheory.Measure.map (fun x => HMul.hMul a x) MeasureTheory.MeasureSpace.volume)) MeasureTheory.MeasureSpace.volume","decl":"theorem smul_map_volume_mul_left {a : ‚Ñù} (h : a ‚â† 0) :\n    ENNReal.ofReal |a| ‚Ä¢ Measure.map (a * ¬∑) volume = volume := by\n  refine (Real.measure_ext_Ioo_rat fun p q => ?_).symm\n  cases' lt_or_gt_of_ne h with h h\n  ¬∑ simp only [Real.volume_Ioo, Measure.smul_apply, ‚Üê ENNReal.ofReal_mul (le_of_lt <| neg_pos.2 h),\n      Measure.map_apply (measurable_const_mul a) measurableSet_Ioo, neg_sub_neg, neg_mul,\n      preimage_const_mul_Ioo_of_neg _ _ h, abs_of_neg h, mul_sub, smul_eq_mul,\n      mul_div_cancel‚ÇÄ _ (ne_of_lt h)]\n  ¬∑ simp only [Real.volume_Ioo, Measure.smul_apply, ‚Üê ENNReal.ofReal_mul (le_of_lt h),\n      Measure.map_apply (measurable_const_mul a) measurableSet_Ioo, preimage_const_mul_Ioo _ _ h,\n      abs_of_pos h, mul_sub, mul_div_cancel‚ÇÄ _ (ne_of_gt h), smul_eq_mul]\n\n"}
{"name":"Real.map_volume_mul_left","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n‚ä¢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul a x) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv a))) MeasureTheory.MeasureSpace.volume)","decl":"theorem map_volume_mul_left {a : ‚Ñù} (h : a ‚â† 0) :\n    Measure.map (a * ¬∑) volume = ENNReal.ofReal |a‚Åª¬π| ‚Ä¢ volume := by\n  conv_rhs =>\n    rw [‚Üê Real.smul_map_volume_mul_left h, smul_smul, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê\n      abs_mul, inv_mul_cancel‚ÇÄ h, abs_one, ENNReal.ofReal_one, one_smul]\n\n"}
{"name":"Real.volume_preimage_mul_left","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\ns : Set Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.preimage (fun x => HMul.hMul a x) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv a))) (MeasureTheory.MeasureSpace.volume s))","decl":"@[simp]\ntheorem volume_preimage_mul_left {a : ‚Ñù} (h : a ‚â† 0) (s : Set ‚Ñù) :\n    volume ((a * ¬∑) ‚Åª¬π' s) = ENNReal.ofReal (abs a‚Åª¬π) * volume s :=\n  calc\n    volume ((a * ¬∑) ‚Åª¬π' s) = Measure.map (a * ¬∑) volume s :=\n      ((Homeomorph.mulLeft‚ÇÄ a h).toMeasurableEquiv.map_apply s).symm\n    _ = ENNReal.ofReal (abs a‚Åª¬π) * volume s := by rw [map_volume_mul_left h]; rfl\n\n"}
{"name":"Real.smul_map_volume_mul_right","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n‚ä¢ Eq (HSMul.hSMul (ENNReal.ofReal (abs a)) (MeasureTheory.Measure.map (fun x => HMul.hMul x a) MeasureTheory.MeasureSpace.volume)) MeasureTheory.MeasureSpace.volume","decl":"theorem smul_map_volume_mul_right {a : ‚Ñù} (h : a ‚â† 0) :\n    ENNReal.ofReal |a| ‚Ä¢ Measure.map (¬∑ * a) volume = volume := by\n  simpa only [mul_comm] using Real.smul_map_volume_mul_left h\n\n"}
{"name":"Real.map_volume_mul_right","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\n‚ä¢ Eq (MeasureTheory.Measure.map (fun x => HMul.hMul x a) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv a))) MeasureTheory.MeasureSpace.volume)","decl":"theorem map_volume_mul_right {a : ‚Ñù} (h : a ‚â† 0) :\n    Measure.map (¬∑ * a) volume = ENNReal.ofReal |a‚Åª¬π| ‚Ä¢ volume := by\n  simpa only [mul_comm] using Real.map_volume_mul_left h\n\n"}
{"name":"Real.volume_preimage_mul_right","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"a : Real\nh : Ne a 0\ns : Set Real\n‚ä¢ Eq (MeasureTheory.MeasureSpace.volume (Set.preimage (fun x => HMul.hMul x a) s)) (HMul.hMul (ENNReal.ofReal (abs (Inv.inv a))) (MeasureTheory.MeasureSpace.volume s))","decl":"@[simp]\ntheorem volume_preimage_mul_right {a : ‚Ñù} (h : a ‚â† 0) (s : Set ‚Ñù) :\n    volume ((¬∑ * a) ‚Åª¬π' s) = ENNReal.ofReal (abs a‚Åª¬π) * volume s :=\n  calc\n    volume ((¬∑ * a) ‚Åª¬π' s) = Measure.map (¬∑ * a) volume s :=\n      ((Homeomorph.mulRight‚ÇÄ a h).toMeasurableEquiv.map_apply s).symm\n    _ = ENNReal.ofReal (abs a‚Åª¬π) * volume s := by rw [map_volume_mul_right h]; rfl\n\n"}
{"name":"Real.smul_map_diagonal_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù¬π : Fintype Œπ\ninst‚úù : DecidableEq Œπ\nD : Œπ ‚Üí Real\nh : Ne (Matrix.diagonal D).det 0\n‚ä¢ Eq (HSMul.hSMul (ENNReal.ofReal (abs (Matrix.diagonal D).det)) (MeasureTheory.Measure.map (‚áë(Matrix.toLin' (Matrix.diagonal D))) MeasureTheory.MeasureSpace.volume)) MeasureTheory.MeasureSpace.volume","decl":"/-- A diagonal matrix rescales Lebesgue according to its determinant. This is a special case of\n`Real.map_matrix_volume_pi_eq_smul_volume_pi`, that one should use instead (and whose proof\nuses this particular case). -/\ntheorem smul_map_diagonal_volume_pi [DecidableEq Œπ] {D : Œπ ‚Üí ‚Ñù} (h : det (diagonal D) ‚â† 0) :\n    ENNReal.ofReal (abs (det (diagonal D))) ‚Ä¢ Measure.map (toLin' (diagonal D)) volume =\n      volume := by\n  refine (Measure.pi_eq fun s hs => ?_).symm\n  simp only [det_diagonal, Measure.coe_smul, Algebra.id.smul_eq_mul, Pi.smul_apply]\n  rw [Measure.map_apply _ (MeasurableSet.univ_pi hs)]\n  swap; ¬∑ exact Continuous.measurable (LinearMap.continuous_on_pi _)\n  have :\n    (Matrix.toLin' (diagonal D) ‚Åª¬π' Set.pi Set.univ fun i : Œπ => s i) =\n      Set.pi Set.univ fun i : Œπ => (D i * ¬∑) ‚Åª¬π' s i := by\n    ext f\n    simp only [LinearMap.coe_proj, Algebra.id.smul_eq_mul, LinearMap.smul_apply, mem_univ_pi,\n      mem_preimage, LinearMap.pi_apply, diagonal_toLin']\n  have B : ‚àÄ i, ofReal (abs (D i)) * volume ((D i * ¬∑) ‚Åª¬π' s i) = volume (s i) := by\n    intro i\n    have A : D i ‚â† 0 := by\n      simp only [det_diagonal, Ne] at h\n      exact Finset.prod_ne_zero_iff.1 h i (Finset.mem_univ i)\n    rw [volume_preimage_mul_left A, ‚Üê mul_assoc, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul,\n      mul_inv_cancel‚ÇÄ A, abs_one, ENNReal.ofReal_one, one_mul]\n  rw [this, volume_pi_pi, Finset.abs_prod,\n    ENNReal.ofReal_prod_of_nonneg fun i _ => abs_nonneg (D i), ‚Üê Finset.prod_mul_distrib]\n  simp only [B]\n\n"}
{"name":"Real.volume_preserving_transvectionStruct","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù¬π : Fintype Œπ\ninst‚úù : DecidableEq Œπ\nt : Matrix.TransvectionStruct Œπ Real\n‚ä¢ MeasureTheory.MeasurePreserving (‚áë(Matrix.toLin' t.toMatrix)) MeasureTheory.MeasureSpace.volume MeasureTheory.MeasureSpace.volume","decl":"/-- A transvection preserves Lebesgue measure. -/\ntheorem volume_preserving_transvectionStruct [DecidableEq Œπ] (t : TransvectionStruct Œπ ‚Ñù) :\n    MeasurePreserving (toLin' t.toMatrix) := by\n  /- We use `lmarginal` to conveniently use Fubini's theorem.\n    Along the coordinate where there is a shearing, it acts like a\n    translation, and therefore preserves Lebesgue. -/\n  have ht : Measurable (toLin' t.toMatrix) :=\n    (toLin' t.toMatrix).continuous_of_finiteDimensional.measurable\n  refine ‚ü®ht, ?_‚ü©\n  refine (pi_eq fun s hs ‚Ü¶ ?_).symm\n  have h2s : MeasurableSet (univ.pi s) := .pi countable_univ fun i _ ‚Ü¶ hs i\n  simp_rw [‚Üê pi_pi, ‚Üê lintegral_indicator_one h2s]\n  rw [lintegral_map (measurable_one.indicator h2s) ht, volume_pi]\n  refine lintegral_eq_of_lmarginal_eq {t.i} ((measurable_one.indicator h2s).comp ht)\n    (measurable_one.indicator h2s) ?_\n  simp_rw [lmarginal_singleton]\n  ext x\n  cases t with | mk t_i t_j t_hij t_c =>\n  simp [transvection, mulVec_stdBasisMatrix, t_hij.symm, ‚Üê Function.update_add,\n    lintegral_add_right_eq_self fun x·µ¢ ‚Ü¶ indicator (univ.pi s) 1 (Function.update x t_i x·µ¢)]\n\n"}
{"name":"Real.map_matrix_volume_pi_eq_smul_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù¬π : Fintype Œπ\ninst‚úù : DecidableEq Œπ\nM : Matrix Œπ Œπ Real\nhM : Ne M.det 0\n‚ä¢ Eq (MeasureTheory.Measure.map (‚áë(Matrix.toLin' M)) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv M.det))) MeasureTheory.MeasureSpace.volume)","decl":"/-- Any invertible matrix rescales Lebesgue measure through the absolute value of its\ndeterminant. -/\ntheorem map_matrix_volume_pi_eq_smul_volume_pi [DecidableEq Œπ] {M : Matrix Œπ Œπ ‚Ñù} (hM : det M ‚â† 0) :\n    Measure.map (toLin' M) volume = ENNReal.ofReal (abs (det M)‚Åª¬π) ‚Ä¢ volume := by\n  -- This follows from the cases we have already proved, of diagonal matrices and transvections,\n  -- as these matrices generate all invertible matrices.\n  apply diagonal_transvection_induction_of_det_ne_zero _ M hM\n  ¬∑ intro D hD\n    conv_rhs => rw [‚Üê smul_map_diagonal_volume_pi hD]\n    rw [smul_smul, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul, inv_mul_cancel‚ÇÄ hD, abs_one,\n      ENNReal.ofReal_one, one_smul]\n  ¬∑ intro t\n    simp_rw [Matrix.TransvectionStruct.det, _root_.inv_one, abs_one, ENNReal.ofReal_one, one_smul,\n      (volume_preserving_transvectionStruct _).map_eq]\n  ¬∑ intro A B _ _ IHA IHB\n    rw [toLin'_mul, det_mul, LinearMap.coe_comp, ‚Üê Measure.map_map, IHB, Measure.map_smul, IHA,\n      smul_smul, ‚Üê ENNReal.ofReal_mul (abs_nonneg _), ‚Üê abs_mul, mul_comm, mul_inv]\n    ¬∑ apply Continuous.measurable\n      apply LinearMap.continuous_on_pi\n    ¬∑ apply Continuous.measurable\n      apply LinearMap.continuous_on_pi\n\n"}
{"name":"Real.map_linearMap_volume_pi_eq_smul_volume_pi","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œπ : Type u_1\ninst‚úù : Fintype Œπ\nf : LinearMap (RingHom.id Real) (Œπ ‚Üí Real) (Œπ ‚Üí Real)\nhf : Ne (LinearMap.det f) 0\n‚ä¢ Eq (MeasureTheory.Measure.map (‚áëf) MeasureTheory.MeasureSpace.volume) (HSMul.hSMul (ENNReal.ofReal (abs (Inv.inv (LinearMap.det f)))) MeasureTheory.MeasureSpace.volume)","decl":"/-- Any invertible linear map rescales Lebesgue measure through the absolute value of its\ndeterminant. -/\ntheorem map_linearMap_volume_pi_eq_smul_volume_pi {f : (Œπ ‚Üí ‚Ñù) ‚Üí‚Çó[‚Ñù] Œπ ‚Üí ‚Ñù}\n    (hf : LinearMap.det f ‚â† 0) : Measure.map f volume =\n      ENNReal.ofReal (abs (LinearMap.det f)‚Åª¬π) ‚Ä¢ volume := by\n  classical\n    -- this is deduced from the matrix case\n    let M := LinearMap.toMatrix' f\n    have A : LinearMap.det f = det M := by simp only [M, LinearMap.det_toMatrix']\n    have B : f = toLin' M := by simp only [M, toLin'_toMatrix']\n    rw [A, B]\n    apply map_matrix_volume_pi_eq_smul_volume_pi\n    rwa [A] at hf\n\n"}
{"name":"regionBetween_subset","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\nf g : Œ± ‚Üí Real\ns : Set Œ±\n‚ä¢ HasSubset.Subset (regionBetween f g s) (SProd.sprod s Set.univ)","decl":"theorem regionBetween_subset (f g : Œ± ‚Üí ‚Ñù) (s : Set Œ±) : regionBetween f g s ‚äÜ s √óÀ¢ univ := by\n  simpa only [prod_univ, regionBetween, Set.preimage, setOf_subset_setOf] using fun a => And.left\n\n"}
{"name":"measurableSet_regionBetween","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n‚ä¢ MeasurableSet (regionBetween f g s)","decl":"/-- The region between two measurable functions on a measurable set is measurable. -/\ntheorem measurableSet_regionBetween (hf : Measurable f) (hg : Measurable g) (hs : MeasurableSet s) :\n    MeasurableSet (regionBetween f g s) := by\n  dsimp only [regionBetween, Ioo, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_lt (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_lt measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_region_between_oc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n‚ä¢ MeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ioc (f p.1) (g p.1)) p.2))","decl":"/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graph of the upper function. -/\ntheorem measurableSet_region_between_oc (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    MeasurableSet { p : Œ± √ó ‚Ñù | p.fst ‚àà s ‚àß p.snd ‚àà Ioc (f p.fst) (g p.fst) } := by\n  dsimp only [regionBetween, Ioc, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_lt (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_le measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_region_between_co","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n‚ä¢ MeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ico (f p.1) (g p.1)) p.2))","decl":"/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graph of the lower function. -/\ntheorem measurableSet_region_between_co (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    MeasurableSet { p : Œ± √ó ‚Ñù | p.fst ‚àà s ‚àß p.snd ‚àà Ico (f p.fst) (g p.fst) } := by\n  dsimp only [regionBetween, Ico, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_le (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_lt measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_region_between_cc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n‚ä¢ MeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Icc (f p.1) (g p.1)) p.2))","decl":"/-- The region between two measurable functions on a measurable set is measurable;\na version for the region together with the graphs of both functions. -/\ntheorem measurableSet_region_between_cc (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    MeasurableSet { p : Œ± √ó ‚Ñù | p.fst ‚àà s ‚àß p.snd ‚àà Icc (f p.fst) (g p.fst) } := by\n  dsimp only [regionBetween, Icc, mem_setOf_eq, setOf_and]\n  refine\n    MeasurableSet.inter ?_\n      ((measurableSet_le (hf.comp measurable_fst) measurable_snd).inter\n        (measurableSet_le measurable_snd (hg.comp measurable_fst)))\n  exact measurable_fst hs\n\n"}
{"name":"measurableSet_graph","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nf : Œ± ‚Üí Real\nhf : Measurable f\n‚ä¢ MeasurableSet (setOf fun p => Eq p.2 (f p.1))","decl":"/-- The graph of a measurable function is a measurable set. -/\ntheorem measurableSet_graph (hf : Measurable f) :\n    MeasurableSet { p : Œ± √ó ‚Ñù | p.snd = f p.fst } := by\n  simpa using measurableSet_region_between_cc hf hf MeasurableSet.univ\n\n"}
{"name":"volume_regionBetween_eq_lintegral'","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\nhf : Measurable f\nhg : Measurable g\nhs : MeasurableSet s\n‚ä¢ Eq ((Œº.prod MeasureTheory.MeasureSpace.volume) (regionBetween f g s)) (MeasureTheory.lintegral (Œº.restrict s) fun y => ENNReal.ofReal (HSub.hSub g f y))","decl":"theorem volume_regionBetween_eq_lintegral' (hf : Measurable f) (hg : Measurable g)\n    (hs : MeasurableSet s) :\n    Œº.prod volume (regionBetween f g s) = ‚à´‚Åª y in s, ENNReal.ofReal ((g - f) y) ‚àÇŒº := by\n  classical\n    rw [Measure.prod_apply]\n    ¬∑ have h :\n        (fun x => volume { a | x ‚àà s ‚àß a ‚àà Ioo (f x) (g x) }) =\n          s.indicator fun x => ENNReal.ofReal (g x - f x) := by\n        funext x\n        rw [indicator_apply]\n        split_ifs with h\n        ¬∑ have hx : { a | x ‚àà s ‚àß a ‚àà Ioo (f x) (g x) } = Ioo (f x) (g x) := by simp [h, Ioo]\n          simp only [hx, Real.volume_Ioo, sub_zero]\n        ¬∑ have hx : { a | x ‚àà s ‚àß a ‚àà Ioo (f x) (g x) } = ‚àÖ := by simp [h]\n          simp only [hx, measure_empty]\n      dsimp only [regionBetween, preimage_setOf_eq]\n      rw [h, lintegral_indicator] <;> simp only [hs, Pi.sub_apply]\n    ¬∑ exact measurableSet_regionBetween hf hg hs\n\n"}
{"name":"volume_regionBetween_eq_lintegral","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù¬π : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\ns : Set Œ±\ninst‚úù : MeasureTheory.SFinite Œº\nhf : AEMeasurable f (Œº.restrict s)\nhg : AEMeasurable g (Œº.restrict s)\nhs : MeasurableSet s\n‚ä¢ Eq ((Œº.prod MeasureTheory.MeasureSpace.volume) (regionBetween f g s)) (MeasureTheory.lintegral (Œº.restrict s) fun y => ENNReal.ofReal (HSub.hSub g f y))","decl":"/-- The volume of the region between two almost everywhere measurable functions on a measurable set\n    can be represented as a Lebesgue integral. -/\ntheorem volume_regionBetween_eq_lintegral [SFinite Œº] (hf : AEMeasurable f (Œº.restrict s))\n    (hg : AEMeasurable g (Œº.restrict s)) (hs : MeasurableSet s) :\n    Œº.prod volume (regionBetween f g s) = ‚à´‚Åª y in s, ENNReal.ofReal ((g - f) y) ‚àÇŒº := by\n  have h‚ÇÅ :\n    (fun y => ENNReal.ofReal ((g - f) y)) =·µê[Œº.restrict s] fun y =>\n      ENNReal.ofReal ((AEMeasurable.mk g hg - AEMeasurable.mk f hf) y) :=\n    (hg.ae_eq_mk.sub hf.ae_eq_mk).fun_comp ENNReal.ofReal\n  have h‚ÇÇ :\n    (Œº.restrict s).prod volume (regionBetween f g s) =\n      (Œº.restrict s).prod volume\n        (regionBetween (AEMeasurable.mk f hf) (AEMeasurable.mk g hg) s) := by\n    apply measure_congr\n    apply EventuallyEq.rfl.inter\n    exact\n      ((quasiMeasurePreserving_fst.ae_eq_comp hf.ae_eq_mk).comp‚ÇÇ _ EventuallyEq.rfl).inter\n        (EventuallyEq.rfl.comp‚ÇÇ _ <| quasiMeasurePreserving_fst.ae_eq_comp hg.ae_eq_mk)\n  rw [lintegral_congr_ae h‚ÇÅ, ‚Üê\n    volume_regionBetween_eq_lintegral' hf.measurable_mk hg.measurable_mk hs]\n  convert h‚ÇÇ using 1\n  ¬∑ rw [Measure.restrict_prod_eq_prod_univ]\n    exact (Measure.restrict_eq_self _ (regionBetween_subset f g s)).symm\n  ¬∑ rw [Measure.restrict_prod_eq_prod_univ]\n    exact\n      (Measure.restrict_eq_self _\n          (regionBetween_subset (AEMeasurable.mk f hf) (AEMeasurable.mk g hg) s)).symm\n\n"}
{"name":"nullMeasurableSet_regionBetween","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nf_mble : AEMeasurable f Œº\ng_mble : AEMeasurable g Œº\ns : Set Œ±\ns_mble : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ioo (f p.1) (g p.1)) p.2)) (Œº.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable. -/\nlemma nullMeasurableSet_regionBetween (Œº : Measure Œ±)\n    {f g : Œ± ‚Üí ‚Ñù} (f_mble : AEMeasurable f Œº) (g_mble : AEMeasurable g Œº)\n    {s : Set Œ±} (s_mble : NullMeasurableSet s Œº) :\n    NullMeasurableSet {p : Œ± √ó ‚Ñù | p.1 ‚àà s ‚àß p.snd ‚àà Ioo (f p.fst) (g p.fst)} (Œº.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  ¬∑ exact nullMeasurableSet_lt (AEMeasurable.fst f_mble) measurable_snd.aemeasurable\n  ¬∑ exact nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst g_mble)\n\n"}
{"name":"nullMeasurableSet_region_between_oc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nf_mble : AEMeasurable f Œº\ng_mble : AEMeasurable g Œº\ns : Set Œ±\ns_mble : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ioc (f p.1) (g p.1)) p.2)) (Œº.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable;\na version for the region together with the graph of the upper function. -/\nlemma nullMeasurableSet_region_between_oc (Œº : Measure Œ±)\n    {f g : Œ± ‚Üí ‚Ñù} (f_mble : AEMeasurable f Œº) (g_mble : AEMeasurable g Œº)\n    {s : Set Œ±} (s_mble : NullMeasurableSet s Œº) :\n    NullMeasurableSet {p : Œ± √ó ‚Ñù | p.1 ‚àà s ‚àß p.snd ‚àà Ioc (f p.fst) (g p.fst)} (Œº.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  ¬∑ exact nullMeasurableSet_lt (AEMeasurable.fst f_mble) measurable_snd.aemeasurable\n  ¬∑ change NullMeasurableSet {p : Œ± √ó ‚Ñù | p.snd ‚â§ g p.fst} (Œº.prod volume)\n    rw [show {p : Œ± √ó ‚Ñù | p.snd ‚â§ g p.fst} = {p : Œ± √ó ‚Ñù | g p.fst < p.snd}·∂ú by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt (AEMeasurable.fst g_mble) measurable_snd.aemeasurable).compl\n\n"}
{"name":"nullMeasurableSet_region_between_co","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nf_mble : AEMeasurable f Œº\ng_mble : AEMeasurable g Œº\ns : Set Œ±\ns_mble : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Ico (f p.1) (g p.1)) p.2)) (Œº.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable;\na version for the region together with the graph of the lower function. -/\nlemma nullMeasurableSet_region_between_co (Œº : Measure Œ±)\n    {f g : Œ± ‚Üí ‚Ñù} (f_mble : AEMeasurable f Œº) (g_mble : AEMeasurable g Œº)\n    {s : Set Œ±} (s_mble : NullMeasurableSet s Œº) :\n    NullMeasurableSet {p : Œ± √ó ‚Ñù | p.1 ‚àà s ‚àß p.snd ‚àà Ico (f p.fst) (g p.fst)} (Œº.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  ¬∑ change NullMeasurableSet {p : Œ± √ó ‚Ñù | f p.fst ‚â§ p.snd} (Œº.prod volume)\n    rw [show {p : Œ± √ó ‚Ñù | f p.fst ‚â§ p.snd} = {p : Œ± √ó ‚Ñù | p.snd < f p.fst}·∂ú by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst f_mble)).compl\n  ¬∑ exact nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst g_mble)\n\n"}
{"name":"nullMeasurableSet_region_between_cc","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œ± : Type u_1\ninst‚úù : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\nf g : Œ± ‚Üí Real\nf_mble : AEMeasurable f Œº\ng_mble : AEMeasurable g Œº\ns : Set Œ±\ns_mble : MeasureTheory.NullMeasurableSet s Œº\n‚ä¢ MeasureTheory.NullMeasurableSet (setOf fun p => And (Membership.mem s p.1) (Membership.mem (Set.Icc (f p.1) (g p.1)) p.2)) (Œº.prod MeasureTheory.MeasureSpace.volume)","decl":"/-- The region between two a.e.-measurable functions on a null-measurable set is null-measurable;\na version for the region together with the graphs of both functions. -/\nlemma nullMeasurableSet_region_between_cc (Œº : Measure Œ±)\n    {f g : Œ± ‚Üí ‚Ñù} (f_mble : AEMeasurable f Œº) (g_mble : AEMeasurable g Œº)\n    {s : Set Œ±} (s_mble : NullMeasurableSet s Œº) :\n    NullMeasurableSet {p : Œ± √ó ‚Ñù | p.1 ‚àà s ‚àß p.snd ‚àà Icc (f p.fst) (g p.fst)} (Œº.prod volume) := by\n  refine NullMeasurableSet.inter\n          (s_mble.preimage quasiMeasurePreserving_fst) (NullMeasurableSet.inter ?_ ?_)\n  ¬∑ change NullMeasurableSet {p : Œ± √ó ‚Ñù | f p.fst ‚â§ p.snd} (Œº.prod volume)\n    rw [show {p : Œ± √ó ‚Ñù | f p.fst ‚â§ p.snd} = {p : Œ± √ó ‚Ñù | p.snd < f p.fst}·∂ú by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt measurable_snd.aemeasurable (AEMeasurable.fst f_mble)).compl\n  ¬∑ change NullMeasurableSet {p : Œ± √ó ‚Ñù | p.snd ‚â§ g p.fst} (Œº.prod volume)\n    rw [show {p : Œ± √ó ‚Ñù | p.snd ‚â§ g p.fst} = {p : Œ± √ó ‚Ñù | g p.fst < p.snd}·∂ú by\n          ext p\n          simp only [mem_setOf_eq, mem_compl_iff, not_lt]]\n    exact (nullMeasurableSet_lt (AEMeasurable.fst g_mble) measurable_snd.aemeasurable).compl\n\n"}
{"name":"ae_restrict_of_ae_restrict_inter_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.NoAtoms Œº\ns : Set Real\np : Real ‚Üí Prop\nh : ‚àÄ (a b : Real), Membership.mem s a ‚Üí Membership.mem s b ‚Üí LT.lt a b ‚Üí Filter.Eventually (fun x => p x) (MeasureTheory.ae (Œº.restrict (Inter.inter s (Set.Ioo a b))))\n‚ä¢ Filter.Eventually (fun x => p x) (MeasureTheory.ae (Œº.restrict s))","decl":"/-- Consider a real set `s`. If a property is true almost everywhere in `s ‚à© (a, b)` for\nall `a, b ‚àà s`, then it is true almost everywhere in `s`. Formulated with `Œº.restrict`.\nSee also `ae_of_mem_of_ae_of_mem_inter_Ioo`. -/\ntheorem ae_restrict_of_ae_restrict_inter_Ioo {Œº : Measure ‚Ñù} [NoAtoms Œº] {s : Set ‚Ñù} {p : ‚Ñù ‚Üí Prop}\n    (h : ‚àÄ a b, a ‚àà s ‚Üí b ‚àà s ‚Üí a < b ‚Üí ‚àÄ·µê x ‚àÇŒº.restrict (s ‚à© Ioo a b), p x) :\n    ‚àÄ·µê x ‚àÇŒº.restrict s, p x := by\n  /- By second-countability, we cover `s` by countably many intervals `(a, b)` (except maybe for\n    two endpoints, which don't matter since `Œº` does not have any atom). -/\n  let T : s √ó s ‚Üí Set ‚Ñù := fun p => Ioo p.1 p.2\n  let u := ‚ãÉ i : ‚Ü•s √ó ‚Ü•s, T i\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo'\n  obtain ‚ü®A, A_count, hA‚ü© :\n    ‚àÉ A : Set (‚Ü•s √ó ‚Ü•s), A.Countable ‚àß ‚ãÉ i ‚àà A, T i = ‚ãÉ i : ‚Ü•s √ó ‚Ü•s, T i :=\n    isOpen_iUnion_countable _ fun p => isOpen_Ioo\n  have : s ‚äÜ s \\ u ‚à™ ‚ãÉ p ‚àà A, s ‚à© T p := by\n    intro x hx\n    by_cases h'x : x ‚àà ‚ãÉ i : ‚Ü•s √ó ‚Ü•s, T i\n    ¬∑ rw [‚Üê hA] at h'x\n      obtain ‚ü®p, pA, xp‚ü© : ‚àÉ p : ‚Ü•s √ó ‚Ü•s, p ‚àà A ‚àß x ‚àà T p := by\n        simpa only [mem_iUnion, exists_prop, SetCoe.exists, exists_and_right] using h'x\n      right\n      exact mem_biUnion pA ‚ü®hx, xp‚ü©\n    ¬∑ exact Or.inl ‚ü®hx, h'x‚ü©\n  apply ae_restrict_of_ae_restrict_of_subset this\n  rw [ae_restrict_union_iff, ae_restrict_biUnion_iff _ A_count]\n  constructor\n  ¬∑ have : Œº.restrict (s \\ u) = 0 := by simp only [restrict_eq_zero, hfinite.measure_zero]\n    simp only [this, ae_zero, eventually_bot]\n  ¬∑ rintro ‚ü®‚ü®a, as‚ü©, ‚ü®b, bs‚ü©‚ü© -\n    dsimp [T]\n    rcases le_or_lt b a with (hba | hab)\n    ¬∑ simp only [Ioo_eq_empty_of_le hba, inter_empty, restrict_empty, ae_zero, eventually_bot]\n    ¬∑ exact h a b as bs hab\n\n"}
{"name":"ae_of_mem_of_ae_of_mem_inter_Ioo","module":"Mathlib.MeasureTheory.Measure.Lebesgue.Basic","initialProofState":"Œº : MeasureTheory.Measure Real\ninst‚úù : MeasureTheory.NoAtoms Œº\ns : Set Real\np : Real ‚Üí Prop\nh : ‚àÄ (a b : Real), Membership.mem s a ‚Üí Membership.mem s b ‚Üí LT.lt a b ‚Üí Filter.Eventually (fun x => Membership.mem (Inter.inter s (Set.Ioo a b)) x ‚Üí p x) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Eventually (fun x => Membership.mem s x ‚Üí p x) (MeasureTheory.ae Œº)","decl":"/-- Consider a real set `s`. If a property is true almost everywhere in `s ‚à© (a, b)` for\nall `a, b ‚àà s`, then it is true almost everywhere in `s`. Formulated with bare membership.\nSee also `ae_restrict_of_ae_restrict_inter_Ioo`. -/\ntheorem ae_of_mem_of_ae_of_mem_inter_Ioo {Œº : Measure ‚Ñù} [NoAtoms Œº] {s : Set ‚Ñù} {p : ‚Ñù ‚Üí Prop}\n    (h : ‚àÄ a b, a ‚àà s ‚Üí b ‚àà s ‚Üí a < b ‚Üí ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚à© Ioo a b ‚Üí p x) :\n    ‚àÄ·µê x ‚àÇŒº, x ‚àà s ‚Üí p x := by\n  /- By second-countability, we cover `s` by countably many intervals `(a, b)` (except maybe for\n    two endpoints, which don't matter since `Œº` does not have any atom). -/\n  let T : s √ó s ‚Üí Set ‚Ñù := fun p => Ioo p.1 p.2\n  let u := ‚ãÉ i : ‚Ü•s √ó ‚Ü•s, T i\n  have hfinite : (s \\ u).Finite := s.finite_diff_iUnion_Ioo'\n  obtain ‚ü®A, A_count, hA‚ü© :\n    ‚àÉ A : Set (‚Ü•s √ó ‚Ü•s), A.Countable ‚àß ‚ãÉ i ‚àà A, T i = ‚ãÉ i : ‚Ü•s √ó ‚Ü•s, T i :=\n    isOpen_iUnion_countable _ fun p => isOpen_Ioo\n  have M : ‚àÄ·µê x ‚àÇŒº, x ‚àâ s \\ u := hfinite.countable.ae_not_mem _\n  have M' : ‚àÄ·µê x ‚àÇŒº, ‚àÄ (i : ‚Ü•s √ó ‚Ü•s), i ‚àà A ‚Üí x ‚àà s ‚à© T i ‚Üí p x := by\n    rw [ae_ball_iff A_count]\n    rintro ‚ü®‚ü®a, as‚ü©, ‚ü®b, bs‚ü©‚ü© -\n    change ‚àÄ·µê x : ‚Ñù ‚àÇŒº, x ‚àà s ‚à© Ioo a b ‚Üí p x\n    rcases le_or_lt b a with (hba | hab)\n    ¬∑ simp only [Ioo_eq_empty_of_le hba, inter_empty, IsEmpty.forall_iff, eventually_true,\n        mem_empty_iff_false]\n    ¬∑ exact h a b as bs hab\n  filter_upwards [M, M'] with x hx h'x\n  intro xs\n  by_cases Hx : x ‚àà ‚ãÉ i : ‚Ü•s √ó ‚Ü•s, T i\n  ¬∑ rw [‚Üê hA] at Hx\n    obtain ‚ü®p, pA, xp‚ü© : ‚àÉ p : ‚Ü•s √ó ‚Ü•s, p ‚àà A ‚àß x ‚àà T p := by\n      simpa only [mem_iUnion, exists_prop, SetCoe.exists, exists_and_right] using Hx\n    apply h'x p pA ‚ü®xs, xp‚ü©\n  ¬∑ exact False.elim (hx ‚ü®xs, Hx‚ü©)\n"}
