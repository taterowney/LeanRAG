{"name":"NonUnitalRingHom.coe_fst","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\n⊢ Eq (⇑(NonUnitalRingHom.fst R S)) Prod.fst","decl":"@[simp]\ntheorem coe_fst : ⇑(fst R S) = Prod.fst :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_snd","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\n⊢ Eq (⇑(NonUnitalRingHom.snd R S)) Prod.snd","decl":"@[simp]\ntheorem coe_snd : ⇑(snd R S) = Prod.snd :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.prod_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonUnitalNonAssocSemiring R\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring T\nf : NonUnitalRingHom R S\ng : NonUnitalRingHom R T\nx : R\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"@[simp]\ntheorem prod_apply (x) : f.prod g x = (f x, g x) :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.fst_comp_prod","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonUnitalNonAssocSemiring R\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring T\nf : NonUnitalRingHom R S\ng : NonUnitalRingHom R T\n⊢ Eq ((NonUnitalRingHom.fst S T).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_comp_prod : (fst S T).comp (f.prod g) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalRingHom.snd_comp_prod","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonUnitalNonAssocSemiring R\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring T\nf : NonUnitalRingHom R S\ng : NonUnitalRingHom R T\n⊢ Eq ((NonUnitalRingHom.snd S T).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_comp_prod : (snd S T).comp (f.prod g) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"NonUnitalRingHom.prod_unique","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonUnitalNonAssocSemiring R\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring T\nf : NonUnitalRingHom R (Prod S T)\n⊢ Eq (((NonUnitalRingHom.fst S T).comp f).prod ((NonUnitalRingHom.snd S T).comp f)) f","decl":"theorem prod_unique (f : R →ₙ+* S × T) : ((fst S T).comp f).prod ((snd S T).comp f) = f :=\n  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply]\n\n"}
{"name":"NonUnitalRingHom.prodMap_def","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\ninst✝¹ : NonUnitalNonAssocSemiring R'\ninst✝ : NonUnitalNonAssocSemiring S'\nf : NonUnitalRingHom R R'\ng : NonUnitalRingHom S S'\n⊢ Eq (f.prodMap g) ((f.comp (NonUnitalRingHom.fst R S)).prod (g.comp (NonUnitalRingHom.snd R S)))","decl":"theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_prodMap","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\ninst✝¹ : NonUnitalNonAssocSemiring R'\ninst✝ : NonUnitalNonAssocSemiring S'\nf : NonUnitalRingHom R R'\ng : NonUnitalRingHom S S'\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.prod_comp_prodMap","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\nT : Type u_5\ninst✝⁴ : NonUnitalNonAssocSemiring R\ninst✝³ : NonUnitalNonAssocSemiring S\ninst✝² : NonUnitalNonAssocSemiring R'\ninst✝¹ : NonUnitalNonAssocSemiring S'\ninst✝ : NonUnitalNonAssocSemiring T\nf : NonUnitalRingHom T R\ng : NonUnitalRingHom T S\nf' : NonUnitalRingHom R R'\ng' : NonUnitalRingHom S S'\n⊢ Eq ((f'.prodMap g').comp (f.prod g)) ((f'.comp f).prod (g'.comp g))","decl":"theorem prod_comp_prodMap (f : T →ₙ+* R) (g : T →ₙ+* S) (f' : R →ₙ+* R') (g' : S →ₙ+* S') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :=\n  rfl\n\n"}
{"name":"RingHom.instRingHomSurjectiveProdFst","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_6\nS : Type u_7\ninst✝¹ : Semiring R\ninst✝ : Semiring S\n⊢ RingHomSurjective (RingHom.fst R S)","decl":"instance (R S) [Semiring R] [Semiring S] : RingHomSurjective (fst R S) := ⟨(⟨⟨·, 0⟩, rfl⟩)⟩\n"}
{"name":"RingHom.instRingHomSurjectiveProdSnd","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_6\nS : Type u_7\ninst✝¹ : Semiring R\ninst✝ : Semiring S\n⊢ RingHomSurjective (RingHom.snd R S)","decl":"instance (R S) [Semiring R] [Semiring S] : RingHomSurjective (snd R S) := ⟨(⟨⟨0, ·⟩, rfl⟩)⟩\n\n"}
{"name":"RingHom.coe_fst","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (⇑(RingHom.fst R S)) Prod.fst","decl":"@[simp]\ntheorem coe_fst : ⇑(fst R S) = Prod.fst :=\n  rfl\n\n"}
{"name":"RingHom.coe_snd","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (⇑(RingHom.snd R S)) Prod.snd","decl":"@[simp]\ntheorem coe_snd : ⇑(snd R S) = Prod.snd :=\n  rfl\n\n"}
{"name":"RingHom.prod_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\nf : RingHom R S\ng : RingHom R T\nx : R\n⊢ Eq ((f.prod g) x) { fst := f x, snd := g x }","decl":"@[simp]\ntheorem prod_apply (x) : f.prod g x = (f x, g x) :=\n  rfl\n\n"}
{"name":"RingHom.fst_comp_prod","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\nf : RingHom R S\ng : RingHom R T\n⊢ Eq ((RingHom.fst S T).comp (f.prod g)) f","decl":"@[simp]\ntheorem fst_comp_prod : (fst S T).comp (f.prod g) = f :=\n  ext fun _ => rfl\n\n"}
{"name":"RingHom.snd_comp_prod","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\nf : RingHom R S\ng : RingHom R T\n⊢ Eq ((RingHom.snd S T).comp (f.prod g)) g","decl":"@[simp]\ntheorem snd_comp_prod : (snd S T).comp (f.prod g) = g :=\n  ext fun _ => rfl\n\n"}
{"name":"RingHom.prod_unique","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\nT : Type u_5\ninst✝² : NonAssocSemiring R\ninst✝¹ : NonAssocSemiring S\ninst✝ : NonAssocSemiring T\nf : RingHom R (Prod S T)\n⊢ Eq (((RingHom.fst S T).comp f).prod ((RingHom.snd S T).comp f)) f","decl":"theorem prod_unique (f : R →+* S × T) : ((fst S T).comp f).prod ((snd S T).comp f) = f :=\n  ext fun x => by simp only [prod_apply, coe_fst, coe_snd, comp_apply]\n\n"}
{"name":"RingHom.prodMap_def","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\nf : RingHom R R'\ng : RingHom S S'\n⊢ Eq (f.prodMap g) ((f.comp (RingHom.fst R S)).prod (g.comp (RingHom.snd R S)))","decl":"theorem prodMap_def : prodMap f g = (f.comp (fst R S)).prod (g.comp (snd R S)) :=\n  rfl\n\n"}
{"name":"RingHom.coe_prodMap","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\nf : RingHom R R'\ng : RingHom S S'\n⊢ Eq (⇑(f.prodMap g)) (Prod.map ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_prodMap : ⇑(prodMap f g) = Prod.map f g :=\n  rfl\n\n"}
{"name":"RingHom.prod_comp_prodMap","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\nT : Type u_5\ninst✝⁴ : NonAssocSemiring R\ninst✝³ : NonAssocSemiring S\ninst✝² : NonAssocSemiring R'\ninst✝¹ : NonAssocSemiring S'\ninst✝ : NonAssocSemiring T\nf : RingHom T R\ng : RingHom T S\nf' : RingHom R R'\ng' : RingHom S S'\n⊢ Eq ((f'.prodMap g').comp (f.prod g)) ((f'.comp f).prod (g'.comp g))","decl":"theorem prod_comp_prodMap (f : T →+* R) (g : T →+* S) (f' : R →+* R') (g' : S →+* S') :\n    (f'.prodMap g').comp (f.prod g) = (f'.comp f).prod (g'.comp g) :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_prodComm","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (⇑RingEquiv.prodComm) Prod.swap","decl":"@[simp]\ntheorem coe_prodComm : ⇑(prodComm : R × S ≃+* S × R) = Prod.swap :=\n  rfl\n\n"}
{"name":"RingEquiv.coe_prodComm_symm","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq (⇑RingEquiv.prodComm.symm) Prod.swap","decl":"@[simp]\ntheorem coe_prodComm_symm : ⇑(prodComm : R × S ≃+* S × R).symm = Prod.swap :=\n  rfl\n\n"}
{"name":"RingEquiv.fst_comp_coe_prodComm","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq ((RingHom.fst S R).comp ↑RingEquiv.prodComm) (RingHom.snd R S)","decl":"@[simp]\ntheorem fst_comp_coe_prodComm :\n    (RingHom.fst S R).comp ↑(prodComm : R × S ≃+* S × R) = RingHom.snd R S :=\n  RingHom.ext fun _ => rfl\n\n"}
{"name":"RingEquiv.snd_comp_coe_prodComm","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\n⊢ Eq ((RingHom.snd S R).comp ↑RingEquiv.prodComm) (RingHom.fst R S)","decl":"@[simp]\ntheorem snd_comp_coe_prodComm :\n    (RingHom.snd S R).comp ↑(prodComm : R × S ≃+* S × R) = RingHom.fst R S :=\n  RingHom.ext fun _ => rfl\n\n"}
{"name":"RingEquiv.prodProdProdComm_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\nrrss : Prod (Prod R R') (Prod S S')\n⊢ Eq ((RingEquiv.prodProdProdComm R R' S S') rrss) { fst := { fst := rrss.1.1, snd := rrss.2.1 }, snd := { fst := rrss.1.2, snd := rrss.2.2 } }","decl":"/-- Four-way commutativity of `Prod`. The name matches `mul_mul_mul_comm`. -/\n@[simps apply]\ndef prodProdProdComm : (R × R') × S × S' ≃+* (R × S) × R' × S' :=\n  { AddEquiv.prodProdProdComm R R' S S', MulEquiv.prodProdProdComm R R' S S' with\n    toFun := fun rrss => ((rrss.1.1, rrss.2.1), (rrss.1.2, rrss.2.2))\n    invFun := fun rsrs => ((rsrs.1.1, rsrs.2.1), (rsrs.1.2, rsrs.2.2)) }\n\n"}
{"name":"RingEquiv.prodProdProdComm_symm","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\n⊢ Eq (RingEquiv.prodProdProdComm R R' S S').symm (RingEquiv.prodProdProdComm R S R' S')","decl":"@[simp]\ntheorem prodProdProdComm_symm : (prodProdProdComm R R' S S').symm = prodProdProdComm R S R' S' :=\n  rfl\n\n"}
{"name":"RingEquiv.prodProdProdComm_toAddEquiv","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\n⊢ Eq (↑(RingEquiv.prodProdProdComm R R' S S')) (AddEquiv.prodProdProdComm R R' S S')","decl":"@[simp]\ntheorem prodProdProdComm_toAddEquiv :\n    (prodProdProdComm R R' S S' : _ ≃+ _) = AddEquiv.prodProdProdComm R R' S S' :=\n  rfl\n\n"}
{"name":"RingEquiv.prodProdProdComm_toMulEquiv","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\n⊢ Eq (↑(RingEquiv.prodProdProdComm R R' S S')) (MulEquiv.prodProdProdComm R R' S S')","decl":"@[simp]\ntheorem prodProdProdComm_toMulEquiv :\n    (prodProdProdComm R R' S S' : _ ≃* _) = MulEquiv.prodProdProdComm R R' S S' :=\n  rfl\n\n"}
{"name":"RingEquiv.prodProdProdComm_toEquiv","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nR' : Type u_2\nS : Type u_3\nS' : Type u_4\ninst✝³ : NonAssocSemiring R\ninst✝² : NonAssocSemiring S\ninst✝¹ : NonAssocSemiring R'\ninst✝ : NonAssocSemiring S'\n⊢ Eq (↑(RingEquiv.prodProdProdComm R R' S S')) (Equiv.prodProdProdComm R R' S S')","decl":"@[simp]\ntheorem prodProdProdComm_toEquiv :\n    (prodProdProdComm R R' S S' : _ ≃ _) = Equiv.prodProdProdComm R R' S S' :=\n  rfl\n\n"}
{"name":"RingEquiv.prodZeroRing_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nx : R\n⊢ Eq ((RingEquiv.prodZeroRing R S) x) { fst := x, snd := 0 }","decl":"/-- A ring `R` is isomorphic to `R × S` when `S` is the zero ring -/\n@[simps]\ndef prodZeroRing : R ≃+* R × S where\n  toFun x := (x, 0)\n  invFun := Prod.fst\n  map_add' := by simp\n  map_mul' := by simp\n  left_inv _ := rfl\n  right_inv x := by cases x; simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"RingEquiv.prodZeroRing_symm_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nself : Prod R S\n⊢ Eq ((RingEquiv.prodZeroRing R S).symm self) self.1","decl":"/-- A ring `R` is isomorphic to `R × S` when `S` is the zero ring -/\n@[simps]\ndef prodZeroRing : R ≃+* R × S where\n  toFun x := (x, 0)\n  invFun := Prod.fst\n  map_add' := by simp\n  map_mul' := by simp\n  left_inv _ := rfl\n  right_inv x := by cases x; simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"RingEquiv.zeroRingProd_symm_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nself : Prod S R\n⊢ Eq ((RingEquiv.zeroRingProd R S).symm self) self.2","decl":"/-- A ring `R` is isomorphic to `S × R` when `S` is the zero ring -/\n@[simps]\ndef zeroRingProd : R ≃+* S × R where\n  toFun x := (0, x)\n  invFun := Prod.snd\n  map_add' := by simp\n  map_mul' := by simp\n  left_inv _ := rfl\n  right_inv x := by cases x; simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"RingEquiv.zeroRingProd_apply","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_1\nS : Type u_3\ninst✝¹ : NonAssocSemiring R\ninst✝ : NonAssocSemiring S\nx : R\n⊢ Eq ((RingEquiv.zeroRingProd R S) x) { fst := 0, snd := x }","decl":"/-- A ring `R` is isomorphic to `S × R` when `S` is the zero ring -/\n@[simps]\ndef zeroRingProd : R ≃+* S × R where\n  toFun x := (0, x)\n  invFun := Prod.snd\n  map_add' := by simp\n  map_mul' := by simp\n  left_inv _ := rfl\n  right_inv x := by cases x; simp [eq_iff_true_of_subsingleton]\n\n"}
{"name":"false_of_nontrivial_of_product_domain","module":"Mathlib.Algebra.Ring.Prod","initialProofState":"R : Type u_6\nS : Type u_7\ninst✝⁴ : Ring R\ninst✝³ : Ring S\ninst✝² : IsDomain (Prod R S)\ninst✝¹ : Nontrivial R\ninst✝ : Nontrivial S\n⊢ False","decl":"/-- The product of two nontrivial rings is not a domain -/\ntheorem false_of_nontrivial_of_product_domain (R S : Type*) [Ring R] [Ring S] [IsDomain (R × S)]\n    [Nontrivial R] [Nontrivial S] : False := by\n  have :=\n    NoZeroDivisors.eq_zero_or_eq_zero_of_mul_eq_zero (show ((0 : R), (1 : S)) * (1, 0) = 0 by simp)\n  rw [Prod.mk_eq_zero, Prod.mk_eq_zero] at this\n  rcases this with (⟨_, h⟩ | ⟨h, _⟩)\n  · exact zero_ne_one h.symm\n  · exact zero_ne_one h.symm\n"}
