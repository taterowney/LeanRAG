{"name":"SSet.horn.const_coe","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni k : Fin (HAdd.hAdd n 3)\nm : Opposite SimplexCategory\n⊢ Eq (↑(SSet.horn.const n i k m)) (SSet.stdSimplex.const (HAdd.hAdd n 2) k m)","decl":"/-- The (degenerate) subsimplex of `Λ[n+2, i]` concentrated in vertex `k`. -/\n@[simps]\ndef const (n : ℕ) (i k : Fin (n+3)) (m : SimplexCategoryᵒᵖ) : Λ[n+2, i].obj m := by\n  refine ⟨stdSimplex.const _ k _, ?_⟩\n  suffices ¬ Finset.univ ⊆ {i, k} by\n    simpa [← Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or, Fin.forall_fin_one,\n      subset_iff, mem_univ, @eq_comm _ _ k]\n  intro h\n  have := (card_le_card h).trans card_le_two\n  rw [card_fin] at this\n  omega\n\n"}
{"name":"SSet.horn.edge_coe","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni a b : Fin (HAdd.hAdd n 1)\nhab : LE.le a b\nH : LE.le (Insert.insert i (Insert.insert a (Singleton.singleton b))).card n\n⊢ Eq (↑(SSet.horn.edge n i a b hab H)) (SSet.stdSimplex.edge n a b hab)","decl":"/-- The edge of `Λ[n, i]` with endpoints `a` and `b`.\n\nThis edge only exists if `{i, a, b}` has cardinality less than `n`. -/\n@[simps]\ndef edge (n : ℕ) (i a b : Fin (n+1)) (hab : a ≤ b) (H : #{i, a, b} ≤ n) : Λ[n, i] _[1] := by\n  refine ⟨stdSimplex.edge n a b hab, ?range⟩\n  case range =>\n    suffices ∃ x, ¬i = x ∧ ¬a = x ∧ ¬b = x by\n      simpa only [unop_op, len_mk, Nat.reduceAdd, asOrderHom, yoneda_obj_obj, Set.union_singleton,\n        ne_eq, ← Set.univ_subset_iff, Set.subset_def, Set.mem_univ, Set.mem_insert_iff,\n        @eq_comm _ _ i, Set.mem_range, forall_const, not_forall, not_or, not_exists,\n        Fin.forall_fin_two, Fin.isValue]\n    contrapose! H\n    replace H : univ ⊆ {i, a, b} :=\n      fun x _ ↦ by simpa [or_iff_not_imp_left, eq_comm] using H x\n    replace H := card_le_card H\n    rwa [card_fin] at H\n\n"}
{"name":"SSet.horn.edge₃_coe_down","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni a b : Fin (HAdd.hAdd n 1)\nhab : LE.le a b\nH : LE.le 3 n\n⊢ Eq (↑(SSet.horn.edge₃ n i a b hab H)).down (SimplexCategory.Hom.mk { toFun := Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty), monotone' := ⋯ })","decl":"/-- Alternative constructor for the edge of `Λ[n, i]` with endpoints `a` and `b`,\nassuming `3 ≤ n`. -/\n@[simps!]\ndef edge₃ (n : ℕ) (i a b : Fin (n+1)) (hab : a ≤ b) (H : 3 ≤ n) :\n    Λ[n, i] _[1] :=\n  horn.edge n i a b hab <| Finset.card_le_three.trans H\n\n"}
{"name":"SSet.horn.primitiveEdge_coe_down","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 1)\nh₀ : LT.lt 0 i\nhₙ : LT.lt i (Fin.last n)\nj : Fin n\n⊢ Eq (↑(SSet.horn.primitiveEdge h₀ hₙ j)).down (SimplexCategory.Hom.mk { toFun := Matrix.vecCons j.castSucc (Matrix.vecCons j.succ Matrix.vecEmpty), monotone' := ⋯ })","decl":"/-- The edge of `Λ[n, i]` with endpoints `j` and `j+1`.\n\nThis constructor assumes `0 < i < n`,\nwhich is the type of horn that occurs in the horn-filling condition of quasicategories. -/\n@[simps!]\ndef primitiveEdge {n : ℕ} {i : Fin (n+1)}\n    (h₀ : 0 < i) (hₙ : i < Fin.last n) (j : Fin n) :\n    Λ[n, i] _[1] := by\n  refine horn.edge n i j.castSucc j.succ ?_ ?_\n  · simp only [← Fin.val_fin_le, Fin.coe_castSucc, Fin.val_succ, le_add_iff_nonneg_right, zero_le]\n  simp only [← Fin.val_fin_lt, Fin.val_zero, Fin.val_last] at h₀ hₙ\n  obtain rfl|hn : n = 2 ∨ 2 < n := by\n    rw [eq_comm, or_comm, ← le_iff_lt_or_eq]; omega\n  · revert i j; decide\n  · exact Finset.card_le_three.trans hn\n\n"}
{"name":"SSet.horn.primitiveTriangle_coe","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 4)\nh₀ : LT.lt 0 i\nhₙ : LT.lt i (Fin.last (HAdd.hAdd n 3))\nk : Nat\nh : LT.lt k (HAdd.hAdd n 2)\n⊢ Eq (↑(SSet.horn.primitiveTriangle i h₀ hₙ k h)) (SSet.stdSimplex.triangle ⟨k, ⋯⟩ ⟨HAdd.hAdd k 1, ⋯⟩ ⟨HAdd.hAdd k 2, ⋯⟩ ⋯ ⋯)","decl":"/-- The triangle in the standard simplex with vertices `k`, `k+1`, and `k+2`.\n\nThis constructor assumes `0 < i < n`,\nwhich is the type of horn that occurs in the horn-filling condition of quasicategories. -/\n@[simps]\ndef primitiveTriangle {n : ℕ} (i : Fin (n+4))\n    (h₀ : 0 < i) (hₙ : i < Fin.last (n+3))\n    (k : ℕ) (h : k < n+2) : Λ[n+3, i] _[2] := by\n  refine ⟨stdSimplex.triangle\n    (n := n+3) ⟨k, by omega⟩ ⟨k+1, by omega⟩ ⟨k+2, by omega⟩ ?_ ?_, ?_⟩\n  · simp only [Fin.mk_le_mk, le_add_iff_nonneg_right, zero_le]\n  · simp only [Fin.mk_le_mk, add_le_add_iff_left, one_le_two]\n  simp only [unop_op, SimplexCategory.len_mk, asOrderHom, SimplexCategory.Hom.toOrderHom_mk,\n    OrderHom.const_coe_coe, Set.union_singleton, ne_eq, ← Set.univ_subset_iff, Set.subset_def,\n    Set.mem_univ, Set.mem_insert_iff, Set.mem_range, Function.const_apply, exists_const,\n    forall_true_left, not_forall, not_or, unop_op, not_exists,\n    stdSimplex.triangle, OrderHom.coe_mk, @eq_comm _ _ i,\n    stdSimplex.objMk, stdSimplex.objEquiv, Equiv.ulift]\n  dsimp\n  by_cases hk0 : k = 0\n  · subst hk0\n    use Fin.last (n+3)\n    simp only [hₙ.ne, not_false_eq_true, Fin.zero_eta, zero_add, true_and]\n    intro j\n    fin_cases j <;> simp [Fin.ext_iff]\n  · use 0\n    simp only [h₀.ne', not_false_eq_true, true_and]\n    intro j\n    fin_cases j <;> simp [Fin.ext_iff, hk0]\n\n"}
{"name":"SSet.horn.face_coe","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni j : Fin (HAdd.hAdd n 2)\nh : Ne j i\n⊢ Eq (↑(SSet.horn.face i j h)) ((SSet.stdSimplex.objEquiv (SimplexCategory.mk (HAdd.hAdd n 1)) { unop := SimplexCategory.mk n }).symm (SimplexCategory.δ j))","decl":"/-- The `j`th subface of the `i`-th horn. -/\n@[simps]\ndef face {n : ℕ} (i j : Fin (n+2)) (h : j ≠ i) : Λ[n+1, i] _[n] :=\n  ⟨(stdSimplex.objEquiv _ _).symm (SimplexCategory.δ j), by\n    simpa [← Set.univ_subset_iff, Set.subset_def, asOrderHom, SimplexCategory.δ, not_or,\n      stdSimplex.objEquiv, asOrderHom, Equiv.ulift]⟩\n\n"}
{"name":"SSet.horn.hom_ext","module":"Mathlib.AlgebraicTopology.SimplicialSet.Horn","initialProofState":"n : Nat\ni : Fin (HAdd.hAdd n 2)\nS : SSet\nσ₁ σ₂ : Quiver.Hom (SSet.horn (HAdd.hAdd n 1) i) S\nh : ∀ (j : Fin (HAdd.hAdd n 2)) (h : Ne j i), Eq (σ₁.app { unop := SimplexCategory.mk n } (SSet.horn.face i j h)) (σ₂.app { unop := SimplexCategory.mk n } (SSet.horn.face i j h))\n⊢ Eq σ₁ σ₂","decl":"/-- Two morphisms from a horn are equal if they are equal on all suitable faces. -/\nprotected\nlemma hom_ext {n : ℕ} {i : Fin (n+2)} {S : SSet} (σ₁ σ₂ : Λ[n+1, i] ⟶ S)\n    (h : ∀ (j) (h : j ≠ i), σ₁.app _ (face i j h) = σ₂.app _ (face i j h)) :\n    σ₁ = σ₂ := by\n  apply NatTrans.ext; apply funext; apply Opposite.rec; apply SimplexCategory.rec\n  intro m; ext f\n  obtain ⟨f', hf⟩ := (stdSimplex.objEquiv _ _).symm.surjective f.1\n  obtain ⟨j, hji, hfj⟩ : ∃ j, ¬j = i ∧ ∀ k, f'.toOrderHom k ≠ j := by\n    obtain ⟨f, hf'⟩ := f\n    subst hf\n    simpa [← Set.univ_subset_iff, Set.subset_def, asOrderHom, not_or] using hf'\n  have H : f = (Λ[n+1, i].map (factor_δ f' j).op) (face i j hji) := by\n    apply Subtype.ext\n    apply (stdSimplex.objEquiv _ _).injective\n    rw [← hf]\n    exact (factor_δ_spec f' j hfj).symm\n  have H₁ := congrFun (σ₁.naturality (factor_δ f' j).op) (face i j hji)\n  have H₂ := congrFun (σ₂.naturality (factor_δ f' j).op) (face i j hji)\n  dsimp at H₁ H₂\n  rw [H, H₁, H₂, h _ hji]\n\n"}
