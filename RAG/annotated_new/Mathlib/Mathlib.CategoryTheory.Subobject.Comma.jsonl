{"name":"CategoryTheory.StructuredArrow.projectSubobject_mk","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\ninst✝² : CategoryTheory.Limits.HasFiniteLimits C\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteLimits T\nA P : CategoryTheory.StructuredArrow S T\nf : Quiver.Hom P A\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.StructuredArrow.projectSubobject (CategoryTheory.Subobject.mk f)) (CategoryTheory.Subobject.mk f.right)","decl":"@[simp]\ntheorem projectSubobject_mk [HasFiniteLimits C] [PreservesFiniteLimits T]\n    {A P : StructuredArrow S T}\n    (f : P ⟶ A) [Mono f] : projectSubobject (Subobject.mk f) = Subobject.mk f.right :=\n  rfl\n\n"}
{"name":"CategoryTheory.StructuredArrow.projectSubobject_factors","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits T\nA : CategoryTheory.StructuredArrow S T\nP : CategoryTheory.Subobject A\n⊢ Exists fun q => Eq (CategoryTheory.CategoryStruct.comp q (T.map (CategoryTheory.StructuredArrow.projectSubobject P).arrow)) A.hom","decl":"theorem projectSubobject_factors [HasFiniteLimits C] [PreservesFiniteLimits T]\n    {A : StructuredArrow S T} :\n    ∀ P : Subobject A, ∃ q, q ≫ T.map (projectSubobject P).arrow = A.hom :=\n  Subobject.ind _ fun P f hf =>\n    ⟨P.hom ≫ T.map (Subobject.underlyingIso _).inv, by\n      dsimp\n      simp [← T.map_comp]⟩\n\n"}
{"name":"CategoryTheory.StructuredArrow.lift_projectSubobject","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits T\nA : CategoryTheory.StructuredArrow S T\nP : CategoryTheory.Subobject A\nq : Quiver.Hom ((CategoryTheory.Functor.fromPUnit S).obj A.left) (T.obj (CategoryTheory.Subobject.underlying.obj (CategoryTheory.StructuredArrow.projectSubobject P)))\nhq : Eq (CategoryTheory.CategoryStruct.comp q (T.map (CategoryTheory.StructuredArrow.projectSubobject P).arrow)) A.hom\n⊢ Eq (CategoryTheory.StructuredArrow.liftSubobject (CategoryTheory.StructuredArrow.projectSubobject P) hq) P","decl":"/-- Projecting and then lifting a subobject recovers the original subobject, because there is at\n    most one morphism making the projected subobject into a structured arrow. -/\ntheorem lift_projectSubobject [HasFiniteLimits C] [PreservesFiniteLimits T]\n    {A : StructuredArrow S T} :\n    ∀ (P : Subobject A) {q} (hq : q ≫ T.map (projectSubobject P).arrow = A.hom),\n      liftSubobject (projectSubobject P) hq = P :=\n  Subobject.ind _\n    (by\n      intro P f hf q hq\n      fapply Subobject.mk_eq_mk_of_comm\n      · fapply isoMk\n        · exact Subobject.underlyingIso _\n        · exact (cancel_mono (T.map f.right)).1 (by dsimp; simpa [← T.map_comp] using hq)\n      · exact ext _ _ (by dsimp; simp))\n\n"}
{"name":"CategoryTheory.StructuredArrow.wellPowered_structuredArrow","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nS : D\nT : CategoryTheory.Functor C D\ninst✝³ : CategoryTheory.LocallySmall.{w, v₁, u₁} C\ninst✝² : CategoryTheory.WellPowered.{w, v₁, u₁} C\ninst✝¹ : CategoryTheory.Limits.HasFiniteLimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteLimits T\n⊢ CategoryTheory.WellPowered.{w, v₁, max u₁ v₂} (CategoryTheory.StructuredArrow S T)","decl":"/-- If `C` is well-powered and complete and `T` preserves limits, then `StructuredArrow S T` is\n    well-powered. -/\ninstance wellPowered_structuredArrow [LocallySmall.{w} C]\n    [WellPowered.{w} C] [HasFiniteLimits C] [PreservesFiniteLimits T] :\n    WellPowered.{w} (StructuredArrow S T) where\n  subobject_small X := small_map (subobjectEquiv X).toEquiv\n\n"}
{"name":"CategoryTheory.CostructuredArrow.projectQuotient_mk","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝⁴ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\ninst✝² : CategoryTheory.Limits.HasFiniteColimits C\ninst✝¹ : CategoryTheory.Limits.PreservesFiniteColimits S\nA : CategoryTheory.CostructuredArrow S T\nP : Opposite (CategoryTheory.CostructuredArrow S T)\nf : Quiver.Hom P { unop := A }\ninst✝ : CategoryTheory.Mono f\n⊢ Eq (CategoryTheory.CostructuredArrow.projectQuotient (CategoryTheory.Subobject.mk f)) (CategoryTheory.Subobject.mk f.unop.left.op)","decl":"@[simp]\ntheorem projectQuotient_mk [HasFiniteColimits C] [PreservesFiniteColimits S]\n    {A : CostructuredArrow S T}\n    {P : (CostructuredArrow S T)ᵒᵖ} (f : P ⟶ op A) [Mono f] :\n    projectQuotient (Subobject.mk f) = Subobject.mk f.unop.left.op :=\n  rfl\n\n"}
{"name":"CategoryTheory.CostructuredArrow.projectQuotient_factors","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits S\nA : CategoryTheory.CostructuredArrow S T\nP : CategoryTheory.Subobject { unop := A }\n⊢ Exists fun q => Eq (CategoryTheory.CategoryStruct.comp (S.map (CategoryTheory.CostructuredArrow.projectQuotient P).arrow.unop) q) A.hom","decl":"theorem projectQuotient_factors [HasFiniteColimits C] [PreservesFiniteColimits S]\n    {A : CostructuredArrow S T} :\n    ∀ P : Subobject (op A), ∃ q, S.map (projectQuotient P).arrow.unop ≫ q = A.hom :=\n  Subobject.ind _ fun P f hf =>\n    ⟨S.map (Subobject.underlyingIso _).unop.inv ≫ P.unop.hom, by\n      dsimp\n      rw [← Category.assoc, ← S.map_comp, ← unop_comp]\n      simp⟩\n\n"}
{"name":"CategoryTheory.CostructuredArrow.unop_left_comp_underlyingIso_hom_unop","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\nA : CategoryTheory.CostructuredArrow S T\nP : Opposite (CategoryTheory.CostructuredArrow S T)\nf : Quiver.Hom P { unop := A }\ninst✝ : CategoryTheory.Mono f.unop.left.op\n⊢ Eq (CategoryTheory.CategoryStruct.comp f.unop.left (CategoryTheory.Subobject.underlyingIso f.unop.left.op).hom.unop) (CategoryTheory.Subobject.mk f.unop.left.op).arrow.unop","decl":"/-- Technical lemma for `lift_projectQuotient`. -/\n@[simp]\ntheorem unop_left_comp_underlyingIso_hom_unop {A : CostructuredArrow S T}\n    {P : (CostructuredArrow S T)ᵒᵖ} (f : P ⟶ op A) [Mono f.unop.left.op] :\n    f.unop.left ≫ (Subobject.underlyingIso f.unop.left.op).hom.unop =\n      (Subobject.mk f.unop.left.op).arrow.unop := by\n  conv_lhs =>\n    congr\n    rw [← Quiver.Hom.unop_op f.unop.left]\n  rw [← unop_comp, Subobject.underlyingIso_hom_comp_eq_mk]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.lift_projectQuotient","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits S\nA : CategoryTheory.CostructuredArrow S T\nP : CategoryTheory.Subobject { unop := A }\nq : Quiver.Hom (S.obj (Opposite.unop (CategoryTheory.Subobject.underlying.obj (CategoryTheory.CostructuredArrow.projectQuotient P)))) ((CategoryTheory.Functor.fromPUnit T).obj A.right)\nhq : Eq (CategoryTheory.CategoryStruct.comp (S.map (CategoryTheory.CostructuredArrow.projectQuotient P).arrow.unop) q) A.hom\n⊢ Eq (CategoryTheory.CostructuredArrow.liftQuotient (CategoryTheory.CostructuredArrow.projectQuotient P) hq) P","decl":"/-- Projecting and then lifting a quotient recovers the original quotient, because there is at most\n    one morphism making the projected quotient into a costructured arrow. -/\ntheorem lift_projectQuotient [HasFiniteColimits C] [PreservesFiniteColimits S]\n    {A : CostructuredArrow S T} :\n    ∀ (P : Subobject (op A)) {q} (hq : S.map (projectQuotient P).arrow.unop ≫ q = A.hom),\n      liftQuotient (projectQuotient P) hq = P :=\n  Subobject.ind _\n    (by\n      intro P f hf q hq\n      fapply Subobject.mk_eq_mk_of_comm\n      · refine (Iso.op (isoMk ?_ ?_) : _ ≅ op (unop P))\n        · exact (Subobject.underlyingIso f.unop.left.op).unop\n        · refine (cancel_epi (S.map f.unop.left)).1 ?_\n          simpa [← Category.assoc, ← S.map_comp] using hq\n      · exact Quiver.Hom.unop_inj (by simp))\n\n"}
{"name":"CategoryTheory.CostructuredArrow.unop_left_comp_ofMkLEMk_unop","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝³ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝² : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\nA : CategoryTheory.CostructuredArrow S T\nP Q : Opposite (CategoryTheory.CostructuredArrow S T)\nf : Quiver.Hom P { unop := A }\ng : Quiver.Hom Q { unop := A }\ninst✝¹ : CategoryTheory.Mono f.unop.left.op\ninst✝ : CategoryTheory.Mono g.unop.left.op\nh : LE.le (CategoryTheory.Subobject.mk f.unop.left.op) (CategoryTheory.Subobject.mk g.unop.left.op)\n⊢ Eq (CategoryTheory.CategoryStruct.comp g.unop.left (CategoryTheory.Subobject.ofMkLEMk f.unop.left.op g.unop.left.op h).unop) f.unop.left","decl":"/-- Technical lemma for `quotientEquiv`. -/\ntheorem unop_left_comp_ofMkLEMk_unop {A : CostructuredArrow S T} {P Q : (CostructuredArrow S T)ᵒᵖ}\n    {f : P ⟶ op A} {g : Q ⟶ op A} [Mono f.unop.left.op] [Mono g.unop.left.op]\n    (h : Subobject.mk f.unop.left.op ≤ Subobject.mk g.unop.left.op) :\n    g.unop.left ≫ (Subobject.ofMkLEMk f.unop.left.op g.unop.left.op h).unop = f.unop.left := by\n  conv_lhs =>\n    congr\n    rw [← Quiver.Hom.unop_op g.unop.left]\n  rw [← unop_comp]\n  simp only [Subobject.ofMkLEMk_comp, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.CostructuredArrow.well_copowered_costructuredArrow","module":"Mathlib.CategoryTheory.Subobject.Comma","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\nS : CategoryTheory.Functor C D\nT : D\ninst✝³ : CategoryTheory.LocallySmall.{w, v₁, u₁} C\ninst✝² : CategoryTheory.WellPowered.{w, v₁, u₁} (Opposite C)\ninst✝¹ : CategoryTheory.Limits.HasFiniteColimits C\ninst✝ : CategoryTheory.Limits.PreservesFiniteColimits S\n⊢ CategoryTheory.WellPowered.{w, v₁, max u₁ v₂} (Opposite (CategoryTheory.CostructuredArrow S T))","decl":"/-- If `C` is well-copowered and cocomplete and `S` preserves colimits, then\n    `CostructuredArrow S T` is well-copowered. -/\ninstance well_copowered_costructuredArrow [LocallySmall.{w} C] [WellPowered.{w} Cᵒᵖ]\n    [HasFiniteColimits C] [PreservesFiniteColimits S] :\n    WellPowered.{w} (CostructuredArrow S T)ᵒᵖ where\n  subobject_small X := small_map (quotientEquiv (unop X)).toEquiv\n\n"}
