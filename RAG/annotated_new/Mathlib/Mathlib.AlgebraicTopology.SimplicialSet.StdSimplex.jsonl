{"name":"SSet.stdSimplex.map_id","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : SimplexCategory\nâŠ¢ Eq (SSet.stdSimplex.map (SimplexCategory.Hom.mk OrderHom.id)) (CategoryTheory.CategoryStruct.id (SSet.stdSimplex.obj n))","decl":"@[simp]\nlemma map_id (n : SimplexCategory) :\n    (SSet.stdSimplex.map (SimplexCategory.Hom.mk OrderHom.id : n âŸ¶ n)) = ðŸ™ _ :=\n  CategoryTheory.Functor.map_id _ _\n\n"}
{"name":"SSet.stdSimplex.map_apply","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"mâ‚ mâ‚‚ : Opposite SimplexCategory\nf : Quiver.Hom mâ‚ mâ‚‚\nn : SimplexCategory\nx : (SSet.stdSimplex.obj n).obj mâ‚\nâŠ¢ Eq ((SSet.stdSimplex.obj n).map f x) ((SSet.stdSimplex.objEquiv n mâ‚‚).symm (CategoryTheory.CategoryStruct.comp f.unop ((SSet.stdSimplex.objEquiv n mâ‚) x)))","decl":"lemma map_apply {mâ‚ mâ‚‚ : SimplexCategoryáµ’áµ–} (f : mâ‚ âŸ¶ mâ‚‚) {n : SimplexCategory}\n    (x : (stdSimplex.{u}.obj n).obj mâ‚) :\n    (stdSimplex.{u}.obj n).map f x = (objEquiv _ _).symm (f.unop â‰« (objEquiv _ _) x) := by\n  rfl\n\n"}
{"name":"SSet.stdSimplex.id_eq_objEquiv_symm","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\nâŠ¢ Eq (SSet.stdSimplex.id n) ((SSet.stdSimplex.objEquiv (Opposite.unop { unop := n }) { unop := n }).symm (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := n })))","decl":"lemma id_eq_objEquiv_symm (n : â„•) : id n = (objEquiv _ _).symm (ðŸ™ _) := rfl\n\n"}
{"name":"SSet.stdSimplex.objEquiv_id","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\nâŠ¢ Eq ((SSet.stdSimplex.objEquiv (SimplexCategory.mk n) { unop := SimplexCategory.mk n }) (SSet.stdSimplex.id n)) (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := SimplexCategory.mk n }))","decl":"lemma objEquiv_id (n : â„•) : objEquiv _ _ (id n) = ðŸ™ _ := rfl\n\n"}
{"name":"SSet.stdSimplex.const_down_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\nk : Fin (HAdd.hAdd n 1)\nm : Opposite SimplexCategory\nâŠ¢ Eq (SimplexCategory.Hom.toOrderHom (SSet.stdSimplex.const n k m).down) ((OrderHom.const (Fin (HAdd.hAdd (Opposite.unop m).len 1))) k)","decl":"@[simp]\nlemma const_down_toOrderHom (n : â„•) (k : Fin (n+1)) (m : SimplexCategoryáµ’áµ–) :\n    (const n k m).down.toOrderHom = OrderHom.const _ k :=\n  rfl\n\n"}
{"name":"SSet.stdSimplex.coe_edge_down_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nhab : LE.le a b\nâŠ¢ Eq (â‡‘(SimplexCategory.Hom.toOrderHom (SSet.stdSimplex.edge n a b hab).down)) (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty))","decl":"lemma coe_edge_down_toOrderHom (n : â„•) (a b : Fin (n+1)) (hab : a â‰¤ b) :\n    â†‘(edge n a b hab).down.toOrderHom = ![a, b] :=\n  rfl\n\n"}
{"name":"SSet.stdSimplex.coe_triangle_down_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\na b c : Fin (HAdd.hAdd n 1)\nhab : LE.le a b\nhbc : LE.le b c\nâŠ¢ Eq (â‡‘(SimplexCategory.Hom.toOrderHom (SSet.stdSimplex.triangle a b c hab hbc).down)) (Matrix.vecCons a (Matrix.vecCons b (Matrix.vecCons c Matrix.vecEmpty)))","decl":"lemma coe_triangle_down_toOrderHom {n : â„•} (a b c : Fin (n+1)) (hab : a â‰¤ b) (hbc : b â‰¤ c) :\n    â†‘(triangle a b c hab hbc).down.toOrderHom = ![a, b, c] :=\n  rfl\n\n"}
{"name":"SSet.Augmented.stdSimplex_obj_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Î” : SimplexCategory\nxâœ : Opposite SimplexCategory\naâœ : ((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Î”)).obj xâœ\nâŠ¢ Eq ((SSet.Augmented.stdSimplex.obj Î”).hom.app xâœ aâœ) (CategoryTheory.Limits.terminal.from (((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Î”)).obj xâœ) aâœ)","decl":"/-- The functor which sends `[n]` to the simplicial set `Î”[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory â¥¤ SSet.Augmented.{u} where\n  obj Î” :=\n    { left := SSet.stdSimplex.obj Î”\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map Î¸ :=\n    { left := SSet.stdSimplex.map Î¸\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_map_right","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Xâœ Yâœ : SimplexCategory\nÎ¸ : Quiver.Hom Xâœ Yâœ\naâœ : ((fun Î” => { left := SSet.stdSimplex.obj Î”, right := CategoryTheory.Limits.terminal (Type u), hom := { app := fun x => CategoryTheory.Limits.terminal.from (((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Î”)).obj x), naturality := â‹¯ } }) Xâœ).right\nâŠ¢ Eq ((SSet.Augmented.stdSimplex.map Î¸).right aâœ) (CategoryTheory.Limits.terminal.from ((fun Î” => { left := SSet.stdSimplex.obj Î”, right := CategoryTheory.Limits.terminal (Type u), hom := { app := fun x => CategoryTheory.Limits.terminal.from (((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Î”)).obj x), naturality := â‹¯ } }) Xâœ).right aâœ)","decl":"/-- The functor which sends `[n]` to the simplicial set `Î”[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory â¥¤ SSet.Augmented.{u} where\n  obj Î” :=\n    { left := SSet.stdSimplex.obj Î”\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map Î¸ :=\n    { left := SSet.stdSimplex.map Î¸\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_obj_right","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Î” : SimplexCategory\nâŠ¢ Eq (SSet.Augmented.stdSimplex.obj Î”).right (CategoryTheory.Limits.terminal (Type u))","decl":"/-- The functor which sends `[n]` to the simplicial set `Î”[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory â¥¤ SSet.Augmented.{u} where\n  obj Î” :=\n    { left := SSet.stdSimplex.obj Î”\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map Î¸ :=\n    { left := SSet.stdSimplex.map Î¸\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_obj_left","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Î” : SimplexCategory\nâŠ¢ Eq (SSet.Augmented.stdSimplex.obj Î”).left (SSet.stdSimplex.obj Î”)","decl":"/-- The functor which sends `[n]` to the simplicial set `Î”[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory â¥¤ SSet.Augmented.{u} where\n  obj Î” :=\n    { left := SSet.stdSimplex.obj Î”\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map Î¸ :=\n    { left := SSet.stdSimplex.map Î¸\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_map_left","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Xâœ Yâœ : SimplexCategory\nÎ¸ : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (SSet.Augmented.stdSimplex.map Î¸).left (SSet.stdSimplex.map Î¸)","decl":"/-- The functor which sends `[n]` to the simplicial set `Î”[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory â¥¤ SSet.Augmented.{u} where\n  obj Î” :=\n    { left := SSet.stdSimplex.obj Î”\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map Î¸ :=\n    { left := SSet.stdSimplex.map Î¸\n      right := terminal.from _ }\n\n"}
