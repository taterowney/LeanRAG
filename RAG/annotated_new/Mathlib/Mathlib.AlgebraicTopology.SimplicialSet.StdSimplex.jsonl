{"name":"SSet.stdSimplex.map_id","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : SimplexCategory\n⊢ Eq (SSet.stdSimplex.map (SimplexCategory.Hom.mk OrderHom.id)) (CategoryTheory.CategoryStruct.id (SSet.stdSimplex.obj n))","decl":"@[simp]\nlemma map_id (n : SimplexCategory) :\n    (SSet.stdSimplex.map (SimplexCategory.Hom.mk OrderHom.id : n ⟶ n)) = 𝟙 _ :=\n  CategoryTheory.Functor.map_id _ _\n\n"}
{"name":"SSet.stdSimplex.map_apply","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"m₁ m₂ : Opposite SimplexCategory\nf : Quiver.Hom m₁ m₂\nn : SimplexCategory\nx : (SSet.stdSimplex.obj n).obj m₁\n⊢ Eq ((SSet.stdSimplex.obj n).map f x) ((SSet.stdSimplex.objEquiv n m₂).symm (CategoryTheory.CategoryStruct.comp f.unop ((SSet.stdSimplex.objEquiv n m₁) x)))","decl":"lemma map_apply {m₁ m₂ : SimplexCategoryᵒᵖ} (f : m₁ ⟶ m₂) {n : SimplexCategory}\n    (x : (stdSimplex.{u}.obj n).obj m₁) :\n    (stdSimplex.{u}.obj n).map f x = (objEquiv _ _).symm (f.unop ≫ (objEquiv _ _) x) := by\n  rfl\n\n"}
{"name":"SSet.stdSimplex.id_eq_objEquiv_symm","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\n⊢ Eq (SSet.stdSimplex.id n) ((SSet.stdSimplex.objEquiv (Opposite.unop { unop := n }) { unop := n }).symm (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := n })))","decl":"lemma id_eq_objEquiv_symm (n : ℕ) : id n = (objEquiv _ _).symm (𝟙 _) := rfl\n\n"}
{"name":"SSet.stdSimplex.objEquiv_id","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\n⊢ Eq ((SSet.stdSimplex.objEquiv (SimplexCategory.mk n) { unop := SimplexCategory.mk n }) (SSet.stdSimplex.id n)) (CategoryTheory.CategoryStruct.id (Opposite.unop { unop := SimplexCategory.mk n }))","decl":"lemma objEquiv_id (n : ℕ) : objEquiv _ _ (id n) = 𝟙 _ := rfl\n\n"}
{"name":"SSet.stdSimplex.const_down_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\nk : Fin (HAdd.hAdd n 1)\nm : Opposite SimplexCategory\n⊢ Eq (SimplexCategory.Hom.toOrderHom (SSet.stdSimplex.const n k m).down) ((OrderHom.const (Fin (HAdd.hAdd (Opposite.unop m).len 1))) k)","decl":"@[simp]\nlemma const_down_toOrderHom (n : ℕ) (k : Fin (n+1)) (m : SimplexCategoryᵒᵖ) :\n    (const n k m).down.toOrderHom = OrderHom.const _ k :=\n  rfl\n\n"}
{"name":"SSet.stdSimplex.coe_edge_down_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\na b : Fin (HAdd.hAdd n 1)\nhab : LE.le a b\n⊢ Eq (⇑(SimplexCategory.Hom.toOrderHom (SSet.stdSimplex.edge n a b hab).down)) (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty))","decl":"lemma coe_edge_down_toOrderHom (n : ℕ) (a b : Fin (n+1)) (hab : a ≤ b) :\n    ↑(edge n a b hab).down.toOrderHom = ![a, b] :=\n  rfl\n\n"}
{"name":"SSet.stdSimplex.coe_triangle_down_toOrderHom","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"n : Nat\na b c : Fin (HAdd.hAdd n 1)\nhab : LE.le a b\nhbc : LE.le b c\n⊢ Eq (⇑(SimplexCategory.Hom.toOrderHom (SSet.stdSimplex.triangle a b c hab hbc).down)) (Matrix.vecCons a (Matrix.vecCons b (Matrix.vecCons c Matrix.vecEmpty)))","decl":"lemma coe_triangle_down_toOrderHom {n : ℕ} (a b c : Fin (n+1)) (hab : a ≤ b) (hbc : b ≤ c) :\n    ↑(triangle a b c hab hbc).down.toOrderHom = ![a, b, c] :=\n  rfl\n\n"}
{"name":"SSet.Augmented.stdSimplex_obj_hom_app","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Δ : SimplexCategory\nx✝ : Opposite SimplexCategory\na✝ : ((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Δ)).obj x✝\n⊢ Eq ((SSet.Augmented.stdSimplex.obj Δ).hom.app x✝ a✝) (CategoryTheory.Limits.terminal.from (((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Δ)).obj x✝) a✝)","decl":"/-- The functor which sends `[n]` to the simplicial set `Δ[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory ⥤ SSet.Augmented.{u} where\n  obj Δ :=\n    { left := SSet.stdSimplex.obj Δ\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map θ :=\n    { left := SSet.stdSimplex.map θ\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_map_right","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"X✝ Y✝ : SimplexCategory\nθ : Quiver.Hom X✝ Y✝\na✝ : ((fun Δ => { left := SSet.stdSimplex.obj Δ, right := CategoryTheory.Limits.terminal (Type u), hom := { app := fun x => CategoryTheory.Limits.terminal.from (((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Δ)).obj x), naturality := ⋯ } }) X✝).right\n⊢ Eq ((SSet.Augmented.stdSimplex.map θ).right a✝) (CategoryTheory.Limits.terminal.from ((fun Δ => { left := SSet.stdSimplex.obj Δ, right := CategoryTheory.Limits.terminal (Type u), hom := { app := fun x => CategoryTheory.Limits.terminal.from (((CategoryTheory.Functor.id (CategoryTheory.SimplicialObject (Type u))).obj (SSet.stdSimplex.obj Δ)).obj x), naturality := ⋯ } }) X✝).right a✝)","decl":"/-- The functor which sends `[n]` to the simplicial set `Δ[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory ⥤ SSet.Augmented.{u} where\n  obj Δ :=\n    { left := SSet.stdSimplex.obj Δ\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map θ :=\n    { left := SSet.stdSimplex.map θ\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_obj_right","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Δ : SimplexCategory\n⊢ Eq (SSet.Augmented.stdSimplex.obj Δ).right (CategoryTheory.Limits.terminal (Type u))","decl":"/-- The functor which sends `[n]` to the simplicial set `Δ[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory ⥤ SSet.Augmented.{u} where\n  obj Δ :=\n    { left := SSet.stdSimplex.obj Δ\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map θ :=\n    { left := SSet.stdSimplex.map θ\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_obj_left","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"Δ : SimplexCategory\n⊢ Eq (SSet.Augmented.stdSimplex.obj Δ).left (SSet.stdSimplex.obj Δ)","decl":"/-- The functor which sends `[n]` to the simplicial set `Δ[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory ⥤ SSet.Augmented.{u} where\n  obj Δ :=\n    { left := SSet.stdSimplex.obj Δ\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map θ :=\n    { left := SSet.stdSimplex.map θ\n      right := terminal.from _ }\n\n"}
{"name":"SSet.Augmented.stdSimplex_map_left","module":"Mathlib.AlgebraicTopology.SimplicialSet.StdSimplex","initialProofState":"X✝ Y✝ : SimplexCategory\nθ : Quiver.Hom X✝ Y✝\n⊢ Eq (SSet.Augmented.stdSimplex.map θ).left (SSet.stdSimplex.map θ)","decl":"/-- The functor which sends `[n]` to the simplicial set `Δ[n]` equipped by\nthe obvious augmentation towards the terminal object of the category of sets. -/\n@[simps]\nnoncomputable def stdSimplex : SimplexCategory ⥤ SSet.Augmented.{u} where\n  obj Δ :=\n    { left := SSet.stdSimplex.obj Δ\n      right := terminal _\n      hom := { app := fun _ => terminal.from _ } }\n  map θ :=\n    { left := SSet.stdSimplex.map θ\n      right := terminal.from _ }\n\n"}
