{"name":"CategoryTheory.ShortComplex.HomologyData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : SizeOf C\nleft : S.LeftHomologyData\nright : S.RightHomologyData\niso : CategoryTheory.Iso left.H right.H\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp left.π (CategoryTheory.CategoryStruct.comp iso.hom right.ι)) (CategoryTheory.CategoryStruct.comp left.i right.p)) _auto✝\n⊢ Eq (SizeOf.sizeOf { left := left, right := right, iso := iso, comm := comm }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right)) (SizeOf.sizeOf iso)) (SizeOf.sizeOf comm))","decl":"/-- A homology data for a short complex consists of two compatible left and\nright homology data -/\nstructure HomologyData where\n  /-- a left homology data -/\n  left : S.LeftHomologyData\n  /-- a right homology data -/\n  right : S.RightHomologyData\n  /-- the compatibility isomorphism relating the two dual notions of\n    `LeftHomologyData` and `RightHomologyData`  -/\n  iso : left.H ≅ right.H\n  /-- the pentagon relation expressing the compatibility of the left\n  and right homology data -/\n  comm : left.π ≫ iso.hom ≫ right.ι = left.i ≫ right.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nleft✝ : S.LeftHomologyData\nright✝ : S.RightHomologyData\niso✝ : CategoryTheory.Iso left✝.H right✝.H\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp left✝.π (CategoryTheory.CategoryStruct.comp iso✝.hom right✝.ι)) (CategoryTheory.CategoryStruct.comp left✝.i right✝.p)) _auto✝\nleft : S.LeftHomologyData\nright : S.RightHomologyData\niso : CategoryTheory.Iso left.H right.H\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp left.π (CategoryTheory.CategoryStruct.comp iso.hom right.ι)) (CategoryTheory.CategoryStruct.comp left.i right.p)) _auto✝\n⊢ Eq (Eq { left := left✝, right := right✝, iso := iso✝, comm := comm✝ } { left := left, right := right, iso := iso, comm := comm }) (And (Eq left✝ left) (And (Eq right✝ right) (HEq iso✝ iso)))","decl":"/-- A homology data for a short complex consists of two compatible left and\nright homology data -/\nstructure HomologyData where\n  /-- a left homology data -/\n  left : S.LeftHomologyData\n  /-- a right homology data -/\n  right : S.RightHomologyData\n  /-- the compatibility isomorphism relating the two dual notions of\n    `LeftHomologyData` and `RightHomologyData`  -/\n  iso : left.H ≅ right.H\n  /-- the pentagon relation expressing the compatibility of the left\n  and right homology data -/\n  comm : left.π ≫ iso.hom ≫ right.ι = left.i ≫ right.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.comm","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.HomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.left.π (CategoryTheory.CategoryStruct.comp self.iso.hom self.right.ι)) (CategoryTheory.CategoryStruct.comp self.left.i self.right.p)","decl":"/-- A homology data for a short complex consists of two compatible left and\nright homology data -/\nstructure HomologyData where\n  /-- a left homology data -/\n  left : S.LeftHomologyData\n  /-- a right homology data -/\n  right : S.RightHomologyData\n  /-- the compatibility isomorphism relating the two dual notions of\n    `LeftHomologyData` and `RightHomologyData`  -/\n  iso : left.H ≅ right.H\n  /-- the pentagon relation expressing the compatibility of the left\n  and right homology data -/\n  comm : left.π ≫ iso.hom ≫ right.ι = left.i ≫ right.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nleft✝ : S.LeftHomologyData\nright✝ : S.RightHomologyData\niso✝ : CategoryTheory.Iso left✝.H right✝.H\ncomm✝ : autoParam (Eq (CategoryTheory.CategoryStruct.comp left✝.π (CategoryTheory.CategoryStruct.comp iso✝.hom right✝.ι)) (CategoryTheory.CategoryStruct.comp left✝.i right✝.p)) _auto✝\nleft : S.LeftHomologyData\nright : S.RightHomologyData\niso : CategoryTheory.Iso left.H right.H\ncomm : autoParam (Eq (CategoryTheory.CategoryStruct.comp left.π (CategoryTheory.CategoryStruct.comp iso.hom right.ι)) (CategoryTheory.CategoryStruct.comp left.i right.p)) _auto✝\nx✝ : Eq { left := left✝, right := right✝, iso := iso✝, comm := comm✝ } { left := left, right := right, iso := iso, comm := comm }\n⊢ And (Eq left✝ left) (And (Eq right✝ right) (HEq iso✝ iso))","decl":"/-- A homology data for a short complex consists of two compatible left and\nright homology data -/\nstructure HomologyData where\n  /-- a left homology data -/\n  left : S.LeftHomologyData\n  /-- a right homology data -/\n  right : S.RightHomologyData\n  /-- the compatibility isomorphism relating the two dual notions of\n    `LeftHomologyData` and `RightHomologyData`  -/\n  iso : left.H ≅ right.H\n  /-- the pentagon relation expressing the compatibility of the left\n  and right homology data -/\n  comm : left.π ≫ iso.hom ≫ right.ι = left.i ≫ right.p := by aesop_cat\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.comm_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.HomologyData\nZ : C\nh : Quiver.Hom self.right.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp self.left.π (CategoryTheory.CategoryStruct.comp self.iso.hom (CategoryTheory.CategoryStruct.comp self.right.ι h))) (CategoryTheory.CategoryStruct.comp self.left.i (CategoryTheory.CategoryStruct.comp self.right.p h))","decl":"attribute [reassoc (attr := simp)] HomologyData.comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\ninst✝ : SizeOf C\nleft : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁.left h₂.left\nright : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁.right h₂.right\n⊢ Eq (SizeOf.sizeOf { left := left, right := right }) (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf left)) (SizeOf.sizeOf right))","decl":"/-- A homology map data for a morphism `φ : S₁ ⟶ S₂` where both `S₁` and `S₂` are\nequipped with homology data consists of left and right homology map data. -/\nstructure HomologyMapData where\n  /-- a left homology map data -/\n  left : LeftHomologyMapData φ h₁.left h₂.left\n  /-- a right homology map data -/\n  right : RightHomologyMapData φ h₁.right h₂.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.mk.injEq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nleft✝ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁.left h₂.left\nright✝ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁.right h₂.right\nleft : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁.left h₂.left\nright : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁.right h₂.right\n⊢ Eq (Eq { left := left✝, right := right✝ } { left := left, right := right }) (And (Eq left✝ left) (Eq right✝ right))","decl":"/-- A homology map data for a morphism `φ : S₁ ⟶ S₂` where both `S₁` and `S₂` are\nequipped with homology data consists of left and right homology map data. -/\nstructure HomologyMapData where\n  /-- a left homology map data -/\n  left : LeftHomologyMapData φ h₁.left h₂.left\n  /-- a right homology map data -/\n  right : RightHomologyMapData φ h₁.right h₂.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.mk.inj","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nleft✝ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁.left h₂.left\nright✝ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁.right h₂.right\nleft : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁.left h₂.left\nright : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁.right h₂.right\nx✝ : Eq { left := left✝, right := right✝ } { left := left, right := right }\n⊢ And (Eq left✝ left) (Eq right✝ right)","decl":"/-- A homology map data for a morphism `φ : S₁ ⟶ S₂` where both `S₁` and `S₂` are\nequipped with homology data consists of left and right homology map data. -/\nstructure HomologyMapData where\n  /-- a left homology map data -/\n  left : LeftHomologyMapData φ h₁.left h₂.left\n  /-- a right homology map data -/\n  right : RightHomologyMapData φ h₁.right h₂.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.comm_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nh✝ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nZ : C\nh : Quiver.Hom h₂.right.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.left.φH (CategoryTheory.CategoryStruct.comp h₂.iso.hom h)) (CategoryTheory.CategoryStruct.comp h₁.iso.hom (CategoryTheory.CategoryStruct.comp h✝.right.φH h))","decl":"@[reassoc]\nlemma comm (h : HomologyMapData φ h₁ h₂) :\n    h.left.φH ≫ h₂.iso.hom = h₁.iso.hom ≫ h.right.φH := by\n  simp only [← cancel_epi h₁.left.π, ← cancel_mono h₂.right.ι, assoc,\n    LeftHomologyMapData.commπ_assoc, HomologyData.comm, LeftHomologyMapData.commi_assoc,\n    RightHomologyMapData.commι, HomologyData.comm_assoc, RightHomologyMapData.commp]\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.comm","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nh : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.left.φH h₂.iso.hom) (CategoryTheory.CategoryStruct.comp h₁.iso.hom h.right.φH)","decl":"@[reassoc]\nlemma comm (h : HomologyMapData φ h₁ h₂) :\n    h.left.φH ≫ h₂.iso.hom = h₁.iso.hom ≫ h.right.φH := by\n  simp only [← cancel_epi h₁.left.π, ← cancel_mono h₂.right.ι, assoc,\n    LeftHomologyMapData.commπ_assoc, HomologyData.comm, LeftHomologyMapData.commi_assoc,\n    RightHomologyMapData.commι, HomologyData.comm_assoc, RightHomologyMapData.commp]\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.instSubsingleton","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Subsingleton (CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂)","decl":"instance : Subsingleton (HomologyMapData φ h₁ h₂) := ⟨by\n  rintro ⟨left₁, right₁⟩ ⟨left₂, right₂⟩\n  simp only [mk.injEq, eq_iff_true_of_subsingleton, and_self]⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.congr_left_φH","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ₁ γ₂ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\neq : Eq γ₁ γ₂\n⊢ Eq γ₁.left.φH γ₂.left.φH","decl":"lemma congr_left_φH {γ₁ γ₂ : HomologyMapData φ h₁ h₂} (eq : γ₁ = γ₂) :\n    γ₁.left.φH = γ₂.left.φH := by rw [eq]\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork S hf c hc).left (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc)","decl":"/-- When the first map `S.f` is zero, this is the homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsLimitKernelFork S hf c hc\n  right := RightHomologyData.ofIsLimitKernelFork S hf c hc\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork S hf c hc).iso (CategoryTheory.Iso.refl (CategoryTheory.ShortComplex.LeftHomologyData.ofIsLimitKernelFork S hf c hc).H)","decl":"/-- When the first map `S.f` is zero, this is the homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsLimitKernelFork S hf c hc\n  right := RightHomologyData.ofIsLimitKernelFork S hf c hc\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsLimitKernelFork S hf c hc).right (CategoryTheory.ShortComplex.RightHomologyData.ofIsLimitKernelFork S hf c hc)","decl":"/-- When the first map `S.f` is zero, this is the homology data on `S` given\nby any limit kernel fork of `S.g` -/\n@[simps]\ndef ofIsLimitKernelFork (hf : S.f = 0) (c : KernelFork S.g) (hc : IsLimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsLimitKernelFork S hf c hc\n  right := RightHomologyData.ofIsLimitKernelFork S hf c hc\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofHasKernel_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofHasKernel S hf).right (CategoryTheory.ShortComplex.RightHomologyData.ofHasKernel S hf)","decl":"/-- When the first map `S.f` is zero, this is the homology data on `S` given\nby the chosen `kernel S.g` -/\n@[simps]\nnoncomputable def ofHasKernel (hf : S.f = 0) [HasKernel S.g] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasKernel S hf\n  right := RightHomologyData.ofHasKernel S hf\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofHasKernel_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofHasKernel S hf).iso (CategoryTheory.Iso.refl (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernel S hf).H)","decl":"/-- When the first map `S.f` is zero, this is the homology data on `S` given\nby the chosen `kernel S.g` -/\n@[simps]\nnoncomputable def ofHasKernel (hf : S.f = 0) [HasKernel S.g] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasKernel S hf\n  right := RightHomologyData.ofHasKernel S hf\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofHasKernel_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : CategoryTheory.Limits.HasKernel S.g\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofHasKernel S hf).left (CategoryTheory.ShortComplex.LeftHomologyData.ofHasKernel S hf)","decl":"/-- When the first map `S.f` is zero, this is the homology data on `S` given\nby the chosen `kernel S.g` -/\n@[simps]\nnoncomputable def ofHasKernel (hf : S.f = 0) [HasKernel S.g] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasKernel S hf\n  right := RightHomologyData.ofHasKernel S hf\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork S hg c hc).right (CategoryTheory.ShortComplex.RightHomologyData.ofIsColimitCokernelCofork S hg c hc)","decl":"/-- When the second map `S.g` is zero, this is the homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsColimitCokernelCofork S hg c hc\n  right := RightHomologyData.ofIsColimitCokernelCofork S hg c hc\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork S hg c hc).iso (CategoryTheory.Iso.refl (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc).H)","decl":"/-- When the second map `S.g` is zero, this is the homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsColimitCokernelCofork S hg c hc\n  right := RightHomologyData.ofIsColimitCokernelCofork S hg c hc\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\nc : CategoryTheory.Limits.CokernelCofork S.f\nhc : CategoryTheory.Limits.IsColimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsColimitCokernelCofork S hg c hc).left (CategoryTheory.ShortComplex.LeftHomologyData.ofIsColimitCokernelCofork S hg c hc)","decl":"/-- When the second map `S.g` is zero, this is the homology data on `S` given\nby any colimit cokernel cofork of `S.f` -/\n@[simps]\ndef ofIsColimitCokernelCofork (hg : S.g = 0) (c : CokernelCofork S.f) (hc : IsColimit c) :\n    S.HomologyData where\n  left := LeftHomologyData.ofIsColimitCokernelCofork S hg c hc\n  right := RightHomologyData.ofIsColimitCokernelCofork S hg c hc\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofHasCokernel_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofHasCokernel S hg).iso (CategoryTheory.Iso.refl (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg).H)","decl":"/-- When the second map `S.g` is zero, this is the homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps]\nnoncomputable def ofHasCokernel (hg : S.g = 0) [HasCokernel S.f] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasCokernel S hg\n  right := RightHomologyData.ofHasCokernel S hg\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofHasCokernel_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofHasCokernel S hg).left (CategoryTheory.ShortComplex.LeftHomologyData.ofHasCokernel S hg)","decl":"/-- When the second map `S.g` is zero, this is the homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps]\nnoncomputable def ofHasCokernel (hg : S.g = 0) [HasCokernel S.f] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasCokernel S hg\n  right := RightHomologyData.ofHasCokernel S hg\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofHasCokernel_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : CategoryTheory.Limits.HasCokernel S.f\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofHasCokernel S hg).right (CategoryTheory.ShortComplex.RightHomologyData.ofHasCokernel S hg)","decl":"/-- When the second map `S.g` is zero, this is the homology data on `S` given by\nthe chosen `cokernel S.f` -/\n@[simps]\nnoncomputable def ofHasCokernel (hg : S.g = 0) [HasCokernel S.f] :\n    S.HomologyData where\n  left := LeftHomologyData.ofHasCokernel S hg\n  right := RightHomologyData.ofHasCokernel S hg\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofZeros_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofZeros S hf hg).right (CategoryTheory.ShortComplex.RightHomologyData.ofZeros S hf hg)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a homology data on S -/\n@[simps]\nnoncomputable def ofZeros (hf : S.f = 0) (hg : S.g = 0) :\n    S.HomologyData where\n  left := LeftHomologyData.ofZeros S hf hg\n  right := RightHomologyData.ofZeros S hf hg\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofZeros_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofZeros S hf hg).iso (CategoryTheory.Iso.refl (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg).H)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a homology data on S -/\n@[simps]\nnoncomputable def ofZeros (hf : S.f = 0) (hg : S.g = 0) :\n    S.HomologyData where\n  left := LeftHomologyData.ofZeros S hf hg\n  right := RightHomologyData.ofZeros S hf hg\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofZeros_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofZeros S hf hg).left (CategoryTheory.ShortComplex.LeftHomologyData.ofZeros S hf hg)","decl":"/-- When both `S.f` and `S.g` are zero, the middle object `S.X₂` gives a homology data on S -/\n@[simps]\nnoncomputable def ofZeros (hf : S.f = 0) (hg : S.g = 0) :\n    S.HomologyData where\n  left := LeftHomologyData.ofZeros S hf hg\n  right := RightHomologyData.ofZeros S hf hg\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono φ h).left (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono φ h.left)","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a homology data for `S₁` induces a homology data for `S₂`.\nThe inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : HomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HomologyData S₂ where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono φ h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono φ h.right\n  iso := h.iso\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono φ h).right (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono φ h.right)","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a homology data for `S₁` induces a homology data for `S₂`.\nThe inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : HomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HomologyData S₂ where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono φ h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono φ h.right\n  iso := h.iso\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₁.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono φ h).iso h.iso","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a homology data for `S₁` induces a homology data for `S₂`.\nThe inverse construction is `ofEpiOfIsIsoOfMono'`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono (φ : S₁ ⟶ S₂) (h : HomologyData S₁)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HomologyData S₂ where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono φ h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono φ h.right\n  iso := h.iso\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono'_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono' φ h).iso h.iso","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a homology data for `S₂` induces a homology data for `S₁`.\nThe inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : HomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HomologyData S₁ where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono' φ h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono' φ h.right\n  iso := h.iso\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono'_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono' φ h).right (CategoryTheory.ShortComplex.RightHomologyData.ofEpiOfIsIsoOfMono' φ h.right)","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a homology data for `S₂` induces a homology data for `S₁`.\nThe inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : HomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HomologyData S₁ where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono' φ h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono' φ h.right\n  iso := h.iso\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono'_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh : S₂.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofEpiOfIsIsoOfMono' φ h).left (CategoryTheory.ShortComplex.LeftHomologyData.ofEpiOfIsIsoOfMono' φ h.left)","decl":"/-- If `φ : S₁ ⟶ S₂` is a morphism of short complexes such that `φ.τ₁` is epi, `φ.τ₂` is an iso\nand `φ.τ₃` is mono, then a homology data for `S₂` induces a homology data for `S₁`.\nThe inverse construction is `ofEpiOfIsIsoOfMono`. -/\n@[simps]\nnoncomputable def ofEpiOfIsIsoOfMono' (φ : S₁ ⟶ S₂) (h : HomologyData S₂)\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HomologyData S₁ where\n  left := LeftHomologyData.ofEpiOfIsIsoOfMono' φ h.left\n  right := RightHomologyData.ofEpiOfIsIsoOfMono' φ h.right\n  iso := h.iso\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_left_K","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).left.K h.left.K","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_left_i","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).left.i (CategoryTheory.CategoryStruct.comp h.left.i e.hom.τ₂)","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_left_π","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).left.π h.left.π","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_right_H","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).right.H h.right.H","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_right_Q","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).right.Q h.right.Q","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_right_p","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).right.p (CategoryTheory.CategoryStruct.comp (CategoryTheory.inv e.hom.τ₂) h.right.p)","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_right_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).right.ι h.right.ι","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_left_H","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).left.H h.left.H","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIso_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh : S₁.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIso e h).iso h.iso","decl":"/-- If `e : S₁ ≅ S₂` is an isomorphism of short complexes and `h₁ : HomologyData S₁`,\nthis is the homology data for `S₂` deduced from the isomorphism. -/\n@[simps!]\nnoncomputable def ofIso (e : S₁ ≅ S₂) (h : HomologyData S₁) :=\n  h.ofEpiOfIsIsoOfMono e.hom\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.op_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq h.op.left h.right.op","decl":"/-- A homology data for a short complex `S` induces a homology data for `S.op`. -/\n@[simps]\ndef op (h : S.HomologyData) : S.op.HomologyData where\n  left := h.right.op\n  right := h.left.op\n  iso := h.iso.op\n  comm := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.op_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq h.op.right h.left.op","decl":"/-- A homology data for a short complex `S` induces a homology data for `S.op`. -/\n@[simps]\ndef op (h : S.HomologyData) : S.op.HomologyData where\n  left := h.right.op\n  right := h.left.op\n  iso := h.iso.op\n  comm := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.op_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq h.op.iso h.iso.op","decl":"/-- A homology data for a short complex `S` induces a homology data for `S.op`. -/\n@[simps]\ndef op (h : S.HomologyData) : S.op.HomologyData where\n  left := h.right.op\n  right := h.left.op\n  iso := h.iso.op\n  comm := Quiver.Hom.unop_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.unop_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.HomologyData\n⊢ Eq h.unop.left h.right.unop","decl":"/-- A homology data for a short complex `S` in the opposite category\ninduces a homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.HomologyData) : S.unop.HomologyData where\n  left := h.right.unop\n  right := h.left.unop\n  iso := h.iso.unop\n  comm := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.unop_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.HomologyData\n⊢ Eq h.unop.right h.left.unop","decl":"/-- A homology data for a short complex `S` in the opposite category\ninduces a homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.HomologyData) : S.unop.HomologyData where\n  left := h.right.unop\n  right := h.left.unop\n  iso := h.iso.unop\n  comm := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.unop_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\nh : S.HomologyData\n⊢ Eq h.unop.iso h.iso.unop","decl":"/-- A homology data for a short complex `S` in the opposite category\ninduces a homology data for `S.unop`. -/\n@[simps]\ndef unop {S : ShortComplex Cᵒᵖ} (h : S.HomologyData) : S.unop.HomologyData where\n  left := h.right.unop\n  right := h.left.unop\n  iso := h.iso.unop\n  comm := Quiver.Hom.op_inj (by simp)\n\n"}
{"name":"CategoryTheory.ShortComplex.HasHomology.condition","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nself : S.HasHomology\n⊢ Nonempty S.HomologyData","decl":"/-- A short complex `S` has homology when there exists a `S.HomologyData` -/\nclass HasHomology : Prop where\n  /-- the condition that there exists a homology data -/\n  condition : Nonempty S.HomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.HasHomology.mk'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ S.HasHomology","decl":"lemma HasHomology.mk' (h : S.HomologyData) : HasHomology S :=\n  ⟨Nonempty.intro h⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.instHasHomologyOppositeOp","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ S.op.HasHomology","decl":"instance [HasHomology S] : HasHomology S.op :=\n  HasHomology.mk' S.homologyData.op\n\n"}
{"name":"CategoryTheory.ShortComplex.instHasHomologyUnopOfOpposite","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex (Opposite C)\ninst✝ : S.HasHomology\n⊢ S.unop.HasHomology","decl":"instance (S : ShortComplex Cᵒᵖ) [HasHomology S] : HasHomology S.unop :=\n  HasHomology.mk' S.homologyData.unop\n\n"}
{"name":"CategoryTheory.ShortComplex.hasLeftHomology_of_hasHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ S.HasLeftHomology","decl":"instance hasLeftHomology_of_hasHomology [S.HasHomology] : S.HasLeftHomology :=\n  HasLeftHomology.mk' S.homologyData.left\n\n"}
{"name":"CategoryTheory.ShortComplex.hasRightHomology_of_hasHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ S.HasRightHomology","decl":"instance hasRightHomology_of_hasHomology [S.HasHomology] : S.HasRightHomology :=\n  HasRightHomology.mk' S.homologyData.right\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_hasCokernel","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y : C\nf : Quiver.Hom X Y\nZ : C\ninst✝ : CategoryTheory.Limits.HasCokernel f\n⊢ (CategoryTheory.ShortComplex.mk f 0 ⋯).HasHomology","decl":"instance hasHomology_of_hasCokernel {X Y : C} (f : X ⟶ Y) (Z : C) [HasCokernel f] :\n    (ShortComplex.mk f (0 : Y ⟶ Z) comp_zero).HasHomology :=\n  HasHomology.mk' (HomologyData.ofHasCokernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_hasKernel","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nY Z : C\ng : Quiver.Hom Y Z\nX : C\ninst✝ : CategoryTheory.Limits.HasKernel g\n⊢ (CategoryTheory.ShortComplex.mk 0 g ⋯).HasHomology","decl":"instance hasHomology_of_hasKernel {Y Z : C} (g : Y ⟶ Z) (X : C) [HasKernel g] :\n    (ShortComplex.mk (0 : X ⟶ Y) g zero_comp).HasHomology :=\n  HasHomology.mk' (HomologyData.ofHasKernel _ rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_zeros","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nX Y Z : C\n⊢ (CategoryTheory.ShortComplex.mk 0 0 ⋯).HasHomology","decl":"instance hasHomology_of_zeros (X Y Z : C) :\n    (ShortComplex.mk (0 : X ⟶ Y) (0 : Y ⟶ Z) zero_comp).HasHomology :=\n  HasHomology.mk' (HomologyData.ofZeros _ rfl rfl)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : S₁.HasHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ S₂.HasHomology","decl":"lemma hasHomology_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂) [HasHomology S₁]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HasHomology S₂ :=\n  HasHomology.mk' (HomologyData.ofEpiOfIsIsoOfMono φ S₁.homologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_epi_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : S₂.HasHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ S₁.HasHomology","decl":"lemma hasHomology_of_epi_of_isIso_of_mono' (φ : S₁ ⟶ S₂) [HasHomology S₂]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] : HasHomology S₁ :=\n  HasHomology.mk' (HomologyData.ofEpiOfIsIsoOfMono' φ S₂.homologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝ : S₁.HasHomology\n⊢ S₂.HasHomology","decl":"lemma hasHomology_of_iso (e : S₁ ≅ S₂) [HasHomology S₁] : HasHomology S₂ :=\n  HasHomology.mk' (HomologyData.ofIso e S₁.homologyData)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.id_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.id h).left (CategoryTheory.ShortComplex.LeftHomologyMapData.id h.left)","decl":"/-- The homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.HomologyData) : HomologyMapData (𝟙 S) h h where\n  left := LeftHomologyMapData.id h.left\n  right := RightHomologyMapData.id h.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.id_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.id h).right (CategoryTheory.ShortComplex.RightHomologyMapData.id h.right)","decl":"/-- The homology map data associated to the identity morphism of a short complex. -/\n@[simps]\ndef id (h : S.HomologyData) : HomologyMapData (𝟙 S) h h where\n  left := LeftHomologyMapData.id h.left\n  right := RightHomologyMapData.id h.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.zero_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.zero h₁ h₂).left (CategoryTheory.ShortComplex.LeftHomologyMapData.zero h₁.left h₂.left)","decl":"/-- The homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) :\n    HomologyMapData 0 h₁ h₂ where\n  left := LeftHomologyMapData.zero h₁.left h₂.left\n  right := RightHomologyMapData.zero h₁.right h₂.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.zero_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.zero h₁ h₂).right (CategoryTheory.ShortComplex.RightHomologyMapData.zero h₁.right h₂.right)","decl":"/-- The homology map data associated to the zero morphism between two short complexes. -/\n@[simps]\ndef zero (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) :\n    HomologyMapData 0 h₁ h₂ where\n  left := LeftHomologyMapData.zero h₁.left h₂.left\n  right := RightHomologyMapData.zero h₁.right h₂.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.comp_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nφ' : Quiver.Hom S₂ S₃\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nh₃ : S₃.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nψ' : CategoryTheory.ShortComplex.HomologyMapData φ' h₂ h₃\n⊢ Eq (ψ.comp ψ').left (ψ.left.comp ψ'.left)","decl":"/-- The composition of homology map data. -/\n@[simps]\ndef comp {φ : S₁ ⟶ S₂} {φ' : S₂ ⟶ S₃} {h₁ : S₁.HomologyData}\n    {h₂ : S₂.HomologyData} {h₃ : S₃.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) (ψ' : HomologyMapData φ' h₂ h₃) :\n    HomologyMapData (φ ≫ φ') h₁ h₃ where\n  left := ψ.left.comp ψ'.left\n  right := ψ.right.comp ψ'.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.comp_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nφ' : Quiver.Hom S₂ S₃\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nh₃ : S₃.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\nψ' : CategoryTheory.ShortComplex.HomologyMapData φ' h₂ h₃\n⊢ Eq (ψ.comp ψ').right (ψ.right.comp ψ'.right)","decl":"/-- The composition of homology map data. -/\n@[simps]\ndef comp {φ : S₁ ⟶ S₂} {φ' : S₂ ⟶ S₃} {h₁ : S₁.HomologyData}\n    {h₂ : S₂.HomologyData} {h₃ : S₃.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) (ψ' : HomologyMapData φ' h₂ h₃) :\n    HomologyMapData (φ ≫ φ') h₁ h₃ where\n  left := ψ.left.comp ψ'.left\n  right := ψ.right.comp ψ'.right\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.op_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq ψ.op.left ψ.right.op","decl":"/-- A homology map data for a morphism of short complexes induces\na homology map data in the opposite category. -/\n@[simps]\ndef op {φ : S₁ ⟶ S₂} {h₁ : S₁.HomologyData} {h₂ : S₂.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) :\n    HomologyMapData (opMap φ) h₂.op h₁.op where\n  left := ψ.right.op\n  right := ψ.left.op\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.op_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq ψ.op.right ψ.left.op","decl":"/-- A homology map data for a morphism of short complexes induces\na homology map data in the opposite category. -/\n@[simps]\ndef op {φ : S₁ ⟶ S₂} {h₁ : S₁.HomologyData} {h₂ : S₂.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) :\n    HomologyMapData (opMap φ) h₂.op h₁.op where\n  left := ψ.right.op\n  right := ψ.left.op\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.unop_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq ψ.unop.left ψ.right.unop","decl":"/-- A homology map data for a morphism of short complexes in the opposite category\ninduces a homology map data in the original category. -/\n@[simps]\ndef unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.HomologyData} {h₂ : S₂.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) :\n    HomologyMapData (unopMap φ) h₂.unop h₁.unop where\n  left := ψ.right.unop\n  right := ψ.left.unop\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.unop_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex (Opposite C)\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nψ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq ψ.unop.right ψ.left.unop","decl":"/-- A homology map data for a morphism of short complexes in the opposite category\ninduces a homology map data in the original category. -/\n@[simps]\ndef unop {S₁ S₂ : ShortComplex Cᵒᵖ} {φ : S₁ ⟶ S₂}\n    {h₁ : S₁.HomologyData} {h₂ : S₂.HomologyData}\n    (ψ : HomologyMapData φ h₁ h₂) :\n    HomologyMapData (unopMap φ) h₂.unop h₁.unop where\n  left := ψ.right.unop\n  right := ψ.left.unop\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.ofZeros_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂).right (CategoryTheory.ShortComplex.RightHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂)","decl":"/-- When `S₁.f`, `S₁.g`, `S₂.f` and `S₂.g` are all zero, the action on homology of a\nmorphism `φ : S₁ ⟶ S₂` is given by the action `φ.τ₂` on the middle objects. -/\n@[simps]\ndef ofZeros (φ : S₁ ⟶ S₂) (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    HomologyMapData φ (HomologyData.ofZeros S₁ hf₁ hg₁) (HomologyData.ofZeros S₂ hf₂ hg₂) where\n  left := LeftHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂\n  right := RightHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.ofZeros_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nhg₁ : Eq S₁.g 0\nhf₂ : Eq S₂.f 0\nhg₂ : Eq S₂.g 0\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂).left (CategoryTheory.ShortComplex.LeftHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂)","decl":"/-- When `S₁.f`, `S₁.g`, `S₂.f` and `S₂.g` are all zero, the action on homology of a\nmorphism `φ : S₁ ⟶ S₂` is given by the action `φ.τ₂` on the middle objects. -/\n@[simps]\ndef ofZeros (φ : S₁ ⟶ S₂) (hf₁ : S₁.f = 0) (hg₁ : S₁.g = 0) (hf₂ : S₂.f = 0) (hg₂ : S₂.g = 0) :\n    HomologyMapData φ (HomologyData.ofZeros S₁ hf₁ hg₁) (HomologyData.ofZeros S₂ hf₂ hg₂) where\n  left := LeftHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂\n  right := RightHomologyMapData.ofZeros φ hf₁ hg₁ hf₂ hg₂\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.ofIsColimitCokernelCofork_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nc₁ : CategoryTheory.Limits.CokernelCofork S₁.f\nhc₁ : CategoryTheory.Limits.IsColimit c₁\nhg₂ : Eq S₂.g 0\nc₂ : CategoryTheory.Limits.CokernelCofork S₂.f\nhc₂ : CategoryTheory.Limits.IsColimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.Limits.Cofork.π c₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π c₁) f)\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm).right (CategoryTheory.ShortComplex.RightHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm)","decl":"/-- When `S₁.g` and `S₂.g` are zero and we have chosen colimit cokernel coforks `c₁` and `c₂`\nfor `S₁.f` and `S₂.f` respectively, the action on homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`φ.τ₂ ≫ c₂.π = c₁.π ≫ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (c₁ : CokernelCofork S₁.f) (hc₁ : IsColimit c₁)\n    (hg₂ : S₂.g = 0) (c₂ : CokernelCofork S₂.f) (hc₂ : IsColimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : φ.τ₂ ≫ c₂.π = c₁.π ≫ f) :\n    HomologyMapData φ (HomologyData.ofIsColimitCokernelCofork S₁ hg₁ c₁ hc₁)\n      (HomologyData.ofIsColimitCokernelCofork S₂ hg₂ c₂ hc₂) where\n  left := LeftHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm\n  right := RightHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.ofIsColimitCokernelCofork_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhg₁ : Eq S₁.g 0\nc₁ : CategoryTheory.Limits.CokernelCofork S₁.f\nhc₁ : CategoryTheory.Limits.IsColimit c₁\nhg₂ : Eq S₂.g 0\nc₂ : CategoryTheory.Limits.CokernelCofork S₂.f\nhc₂ : CategoryTheory.Limits.IsColimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.Limits.Cofork.π c₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Cofork.π c₁) f)\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm).left (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm)","decl":"/-- When `S₁.g` and `S₂.g` are zero and we have chosen colimit cokernel coforks `c₁` and `c₂`\nfor `S₁.f` and `S₂.f` respectively, the action on homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`φ.τ₂ ≫ c₂.π = c₁.π ≫ f`. -/\n@[simps]\ndef ofIsColimitCokernelCofork (φ : S₁ ⟶ S₂)\n    (hg₁ : S₁.g = 0) (c₁ : CokernelCofork S₁.f) (hc₁ : IsColimit c₁)\n    (hg₂ : S₂.g = 0) (c₂ : CokernelCofork S₂.f) (hc₂ : IsColimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : φ.τ₂ ≫ c₂.π = c₁.π ≫ f) :\n    HomologyMapData φ (HomologyData.ofIsColimitCokernelCofork S₁ hg₁ c₁ hc₁)\n      (HomologyData.ofIsColimitCokernelCofork S₂ hg₂ c₂ hc₂) where\n  left := LeftHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm\n  right := RightHomologyMapData.ofIsColimitCokernelCofork φ hg₁ c₁ hc₁ hg₂ c₂ hc₂ f comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.ofIsLimitKernelFork_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nc₁ : CategoryTheory.Limits.KernelFork S₁.g\nhc₁ : CategoryTheory.Limits.IsLimit c₁\nhf₂ : Eq S₂.f 0\nc₂ : CategoryTheory.Limits.KernelFork S₂.g\nhc₂ : CategoryTheory.Limits.IsLimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c₁) φ.τ₂) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.ι c₂))\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm).left (CategoryTheory.ShortComplex.LeftHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm)","decl":"/-- When `S₁.f` and `S₂.f` are zero and we have chosen limit kernel forks `c₁` and `c₂`\nfor `S₁.g` and `S₂.g` respectively, the action on homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι`. -/\n@[simps]\ndef ofIsLimitKernelFork (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (c₁ : KernelFork S₁.g) (hc₁ : IsLimit c₁)\n    (hf₂ : S₂.f = 0) (c₂ : KernelFork S₂.g) (hc₂ : IsLimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι) :\n    HomologyMapData φ (HomologyData.ofIsLimitKernelFork S₁ hf₁ c₁ hc₁)\n      (HomologyData.ofIsLimitKernelFork S₂ hf₂ c₂ hc₂) where\n  left := LeftHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm\n  right := RightHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.ofIsLimitKernelFork_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nhf₁ : Eq S₁.f 0\nc₁ : CategoryTheory.Limits.KernelFork S₁.g\nhc₁ : CategoryTheory.Limits.IsLimit c₁\nhf₂ : Eq S₂.f 0\nc₂ : CategoryTheory.Limits.KernelFork S₂.g\nhc₂ : CategoryTheory.Limits.IsLimit c₂\nf : Quiver.Hom c₁.pt c₂.pt\ncomm : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Fork.ι c₁) φ.τ₂) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Limits.Fork.ι c₂))\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm).right (CategoryTheory.ShortComplex.RightHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm)","decl":"/-- When `S₁.f` and `S₂.f` are zero and we have chosen limit kernel forks `c₁` and `c₂`\nfor `S₁.g` and `S₂.g` respectively, the action on homology of a morphism `φ : S₁ ⟶ S₂` of\nshort complexes is given by the unique morphism `f : c₁.pt ⟶ c₂.pt` such that\n`c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι`. -/\n@[simps]\ndef ofIsLimitKernelFork (φ : S₁ ⟶ S₂)\n    (hf₁ : S₁.f = 0) (c₁ : KernelFork S₁.g) (hc₁ : IsLimit c₁)\n    (hf₂ : S₂.f = 0) (c₂ : KernelFork S₂.g) (hc₂ : IsLimit c₂) (f : c₁.pt ⟶ c₂.pt)\n    (comm : c₁.ι ≫ φ.τ₂ = f ≫ c₂.ι) :\n    HomologyMapData φ (HomologyData.ofIsLimitKernelFork S₁ hf₁ c₁ hc₁)\n      (HomologyData.ofIsLimitKernelFork S₂ hf₂ c₂ hc₂) where\n  left := LeftHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm\n  right := RightHomologyMapData.ofIsLimitKernelFork φ hf₁ c₁ hc₁ hf₂ c₂ hc₂ f comm\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.compatibilityOfZerosOfIsLimitKernelFork hf hg c hc).left (CategoryTheory.ShortComplex.LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the homology map\ndata (for the identity of `S`) which relates the homology data\n`HomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    HomologyMapData (𝟙 S)\n      (HomologyData.ofIsLimitKernelFork S hf c hc)\n      (HomologyData.ofZeros S hf hg) where\n  left := LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc\n  right := RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.compatibilityOfZerosOfIsLimitKernelFork_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\nhg : Eq S.g 0\nc : CategoryTheory.Limits.KernelFork S.g\nhc : CategoryTheory.Limits.IsLimit c\n⊢ Eq (CategoryTheory.ShortComplex.HomologyMapData.compatibilityOfZerosOfIsLimitKernelFork hf hg c hc).right (CategoryTheory.ShortComplex.RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc)","decl":"/-- When both maps `S.f` and `S.g` of a short complex `S` are zero, this is the homology map\ndata (for the identity of `S`) which relates the homology data\n`HomologyData.ofIsLimitKernelFork` and `ofZeros` . -/\n@[simps]\ndef compatibilityOfZerosOfIsLimitKernelFork (hf : S.f = 0) (hg : S.g = 0)\n    (c : KernelFork S.g) (hc : IsLimit c) :\n    HomologyMapData (𝟙 S)\n      (HomologyData.ofIsLimitKernelFork S hf c hc)\n      (HomologyData.ofZeros S hf hg) where\n  left := LeftHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc\n  right := RightHomologyMapData.compatibilityOfZerosOfIsLimitKernelFork S hf hg c hc\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.homologyIso_leftHomologyData","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq S.leftHomologyData.homologyIso S.leftHomologyIso.symm","decl":"@[simp]\nlemma LeftHomologyData.homologyIso_leftHomologyData [S.HasHomology] :\n    S.leftHomologyData.homologyIso = S.leftHomologyIso.symm := by\n  ext\n  dsimp [homologyIso, leftHomologyIso, ShortComplex.leftHomologyIso]\n  rw [← leftHomologyMap'_comp, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_rightHomologyData","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq S.rightHomologyData.homologyIso S.rightHomologyIso.symm","decl":"@[simp]\nlemma RightHomologyData.homologyIso_rightHomologyData [S.HasHomology] :\n    S.rightHomologyData.homologyIso = S.rightHomologyIso.symm := by\n  ext\n  dsimp [homologyIso, rightHomologyIso]\n  erw [rightHomologyMap'_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.homologyMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂) γ.left.φH","decl":"lemma homologyMap'_eq : homologyMap' φ h₁ h₂ = γ.left.φH :=\n  LeftHomologyMapData.congr_φH (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.cyclesMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.cyclesMap' φ h₁.left h₂.left) γ.left.φK","decl":"lemma cyclesMap'_eq : cyclesMap' φ h₁.left h₂.left = γ.left.φK :=\n  LeftHomologyMapData.congr_φK (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyMapData.opcyclesMap'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nγ : CategoryTheory.ShortComplex.HomologyMapData φ h₁ h₂\n⊢ Eq (CategoryTheory.ShortComplex.opcyclesMap' φ h₁.right h₂.right) γ.right.φQ","decl":"lemma opcyclesMap'_eq : opcyclesMap' φ h₁.right h₂.right = γ.right.φQ :=\n  RightHomologyMapData.congr_φQ (Subsingleton.elim _ _)\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.homologyMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom (CategoryTheory.CategoryStruct.comp γ.φH h₂.homologyIso.inv))","decl":"lemma homologyMap_eq :\n    homologyMap φ = h₁.homologyIso.hom ≫ γ.φH ≫ h₂.homologyIso.inv := by\n  dsimp [homologyMap, LeftHomologyData.homologyIso, leftHomologyIso,\n    LeftHomologyData.leftHomologyIso, homologyMap']\n  simp only [← γ.leftHomologyMap'_eq, ← leftHomologyMap'_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyMapData.homologyMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nγ : CategoryTheory.ShortComplex.LeftHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h₂.homologyIso.hom) (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom γ.φH)","decl":"lemma homologyMap_comm :\n    homologyMap φ ≫ h₂.homologyIso.hom = h₁.homologyIso.hom ≫ γ.φH := by\n  simp only [γ.homologyMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.homologyMap_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom (CategoryTheory.CategoryStruct.comp γ.φH h₂.homologyIso.inv))","decl":"lemma homologyMap_eq :\n    homologyMap φ = h₁.homologyIso.hom ≫ γ.φH ≫ h₂.homologyIso.inv := by\n  dsimp [homologyMap, homologyMap', RightHomologyData.homologyIso,\n    rightHomologyIso, RightHomologyData.rightHomologyIso]\n  have γ' : HomologyMapData φ S₁.homologyData S₂.homologyData := default\n  simp only [← γ.rightHomologyMap'_eq, assoc, ← rightHomologyMap'_comp_assoc,\n    id_comp, comp_id, γ'.left.leftHomologyMap'_eq, γ'.right.rightHomologyMap'_eq, ← γ'.comm_assoc,\n    Iso.hom_inv_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyMapData.homologyMap_comm","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nγ : CategoryTheory.ShortComplex.RightHomologyMapData φ h₁ h₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h₂.homologyIso.hom) (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom γ.φH)","decl":"lemma homologyMap_comm :\n    homologyMap φ ≫ h₂.homologyIso.hom = h₁.homologyIso.hom ≫ γ.φH := by\n  simp only [γ.homologyMap_eq, assoc, Iso.inv_hom_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_id","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' (CategoryTheory.CategoryStruct.id S) h h) (CategoryTheory.CategoryStruct.id h.left.H)","decl":"@[simp]\nlemma homologyMap'_id (h : S.HomologyData) :\n    homologyMap' (𝟙 S) h h = 𝟙 _ :=\n  (HomologyMapData.id h).homologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_id","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.CategoryStruct.id S)) (CategoryTheory.CategoryStruct.id S.homology)","decl":"@[simp]\nlemma homologyMap_id [HasHomology S] :\n    homologyMap (𝟙 S) = 𝟙 _ :=\n  homologyMap'_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' 0 h₁ h₂) 0","decl":"@[simp]\nlemma homologyMap'_zero (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) :\n    homologyMap' 0 h₁ h₂ = 0 :=\n  (HomologyMapData.zero h₁ h₂).homologyMap'_eq\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_zero","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap 0) 0","decl":"@[simp]\nlemma homologyMap_zero [S₁.HasHomology] [S₂.HasHomology] :\n    homologyMap (0 : S₁ ⟶ S₂) = 0 :=\n  homologyMap'_zero _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_comp","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\nh₃ : S₃.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' (CategoryTheory.CategoryStruct.comp φ₁ φ₂) h₁ h₃) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap' φ₁ h₁ h₂) (CategoryTheory.ShortComplex.homologyMap' φ₂ h₂ h₃))","decl":"lemma homologyMap'_comp (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃)\n    (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) (h₃ : S₃.HomologyData) :\n    homologyMap' (φ₁ ≫ φ₂) h₁ h₃ = homologyMap' φ₁ h₁ h₂ ≫\n      homologyMap' φ₂ h₂ h₃ :=\n  leftHomologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ S₃ : CategoryTheory.ShortComplex C\ninst✝² : S₁.HasHomology\ninst✝¹ : S₂.HasHomology\ninst✝ : S₃.HasHomology\nφ₁ : Quiver.Hom S₁ S₂\nφ₂ : Quiver.Hom S₂ S₃\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.CategoryStruct.comp φ₁ φ₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ₁) (CategoryTheory.ShortComplex.homologyMap φ₂))","decl":"@[simp]\nlemma homologyMap_comp [HasHomology S₁] [HasHomology S₂] [HasHomology S₃]\n    (φ₁ : S₁ ⟶ S₂) (φ₂ : S₂ ⟶ S₃) :\n    homologyMap (φ₁ ≫ φ₂) = homologyMap φ₁ ≫ homologyMap φ₂ :=\n  homologyMap'_comp _ _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMapIso'_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMapIso' e h₁ h₂).inv (CategoryTheory.ShortComplex.homologyMap' e.inv h₂ h₁)","decl":"/-- Given an isomorphism `S₁ ≅ S₂` of short complexes and homology data `h₁` and `h₂`\nfor `S₁` and `S₂` respectively, this is the induced homology isomorphism `h₁.left.H ≅ h₁.left.H`. -/\n@[simps]\ndef homologyMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.HomologyData)\n    (h₂ : S₂.HomologyData) : h₁.left.H ≅ h₂.left.H where\n  hom := homologyMap' e.hom h₁ h₂\n  inv := homologyMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← homologyMap'_comp, e.hom_inv_id, homologyMap'_id]\n  inv_hom_id := by rw [← homologyMap'_comp, e.inv_hom_id, homologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMapIso'_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMapIso' e h₁ h₂).hom (CategoryTheory.ShortComplex.homologyMap' e.hom h₁ h₂)","decl":"/-- Given an isomorphism `S₁ ≅ S₂` of short complexes and homology data `h₁` and `h₂`\nfor `S₁` and `S₂` respectively, this is the induced homology isomorphism `h₁.left.H ≅ h₁.left.H`. -/\n@[simps]\ndef homologyMapIso' (e : S₁ ≅ S₂) (h₁ : S₁.HomologyData)\n    (h₂ : S₂.HomologyData) : h₁.left.H ≅ h₂.left.H where\n  hom := homologyMap' e.hom h₁ h₂\n  inv := homologyMap' e.inv h₂ h₁\n  hom_inv_id := by rw [← homologyMap'_comp, e.hom_inv_id, homologyMap'_id]\n  inv_hom_id := by rw [← homologyMap'_comp, e.inv_hom_id, homologyMap'_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap'_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝ : CategoryTheory.IsIso φ\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂)","decl":"instance isIso_homologyMap'_of_isIso (φ : S₁ ⟶ S₂) [IsIso φ]\n    (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) :\n    IsIso (homologyMap' φ h₁ h₂) :=\n  (inferInstance : IsIso (homologyMapIso' (asIso φ) h₁ h₂).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMapIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMapIso e).hom (CategoryTheory.ShortComplex.homologyMap e.hom)","decl":"/-- The homology isomorphism `S₁.homology ⟶ S₂.homology` induced by an isomorphism\n`S₁ ≅ S₂` of short complexes. -/\n@[simps]\nnoncomputable def homologyMapIso (e : S₁ ≅ S₂) [S₁.HasHomology]\n    [S₂.HasHomology] : S₁.homology ≅ S₂.homology where\n  hom := homologyMap e.hom\n  inv := homologyMap e.inv\n  hom_inv_id := by rw [← homologyMap_comp, e.hom_inv_id, homologyMap_id]\n  inv_hom_id := by rw [← homologyMap_comp, e.inv_hom_id, homologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMapIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ne : CategoryTheory.Iso S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMapIso e).inv (CategoryTheory.ShortComplex.homologyMap e.inv)","decl":"/-- The homology isomorphism `S₁.homology ⟶ S₂.homology` induced by an isomorphism\n`S₁ ≅ S₂` of short complexes. -/\n@[simps]\nnoncomputable def homologyMapIso (e : S₁ ≅ S₂) [S₁.HasHomology]\n    [S₂.HasHomology] : S₁.homology ≅ S₂.homology where\n  hom := homologyMap e.hom\n  inv := homologyMap e.inv\n  hom_inv_id := by rw [← homologyMap_comp, e.hom_inv_id, homologyMap_id]\n  inv_hom_id := by rw [← homologyMap_comp, e.inv_hom_id, homologyMap_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap_of_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : CategoryTheory.IsIso φ\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap φ)","decl":"instance isIso_homologyMap_of_iso (φ : S₁ ⟶ S₂) [IsIso φ] [S₁.HasHomology]\n    [S₂.HasHomology] :\n    IsIso (homologyMap φ) :=\n  (inferInstance : IsIso (homologyMapIso (asIso φ)).hom)\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_eq_liftH","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (h₂.liftH (h₁.descH (CategoryTheory.CategoryStruct.comp h₁.i h₂.p) ⋯) ⋯)","decl":"lemma leftRightHomologyComparison'_eq_liftH :\n    leftRightHomologyComparison' h₁ h₂ =\n      h₂.liftH (h₁.descH (h₁.i ≫ h₂.p) (by simp))\n        (by rw [← cancel_epi h₁.π, LeftHomologyData.π_descH_assoc, assoc,\n          RightHomologyData.p_g', LeftHomologyData.wi, comp_zero]) := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.π_leftRightHomologyComparison'_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\nZ : C\nh : Quiver.Hom h₂.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.ι h))) (CategoryTheory.CategoryStruct.comp h₁.i (CategoryTheory.CategoryStruct.comp h₂.p h))","decl":"@[reassoc (attr := simp)]\nlemma π_leftRightHomologyComparison'_ι :\n    h₁.π ≫ leftRightHomologyComparison' h₁ h₂ ≫ h₂.ι = h₁.i ≫ h₂.p := by\n  simp only [leftRightHomologyComparison'_eq_liftH,\n    RightHomologyData.liftH_ι, LeftHomologyData.π_descH]\n\n"}
{"name":"CategoryTheory.ShortComplex.π_leftRightHomologyComparison'_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) h₂.ι)) (CategoryTheory.CategoryStruct.comp h₁.i h₂.p)","decl":"@[reassoc (attr := simp)]\nlemma π_leftRightHomologyComparison'_ι :\n    h₁.π ≫ leftRightHomologyComparison' h₁ h₂ ≫ h₂.ι = h₁.i ≫ h₂.p := by\n  simp only [leftRightHomologyComparison'_eq_liftH,\n    RightHomologyData.liftH_ι, LeftHomologyData.π_descH]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_eq_descH","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (h₁.descH (h₂.liftH (CategoryTheory.CategoryStruct.comp h₁.i h₂.p) ⋯) ⋯)","decl":"lemma leftRightHomologyComparison'_eq_descH :\n    leftRightHomologyComparison' h₁ h₂ =\n      h₁.descH (h₂.liftH (h₁.i ≫ h₂.p) (by simp))\n        (by rw [← cancel_mono h₂.ι, assoc, RightHomologyData.liftH_ι,\n          LeftHomologyData.f'_i_assoc, RightHomologyData.wp, zero_comp]) := by\n  simp only [← cancel_mono h₂.ι, ← cancel_epi h₁.π, π_leftRightHomologyComparison'_ι,\n    LeftHomologyData.π_descH_assoc, RightHomologyData.liftH_ι]\n\n"}
{"name":"CategoryTheory.ShortComplex.π_leftRightHomologyComparison_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : S.HasRightHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ (CategoryTheory.CategoryStruct.comp S.leftRightHomologyComparison (CategoryTheory.CategoryStruct.comp S.rightHomologyι h))) (CategoryTheory.CategoryStruct.comp S.iCycles (CategoryTheory.CategoryStruct.comp S.pOpcycles h))","decl":"@[reassoc (attr := simp)]\nlemma π_leftRightHomologyComparison_ι [S.HasLeftHomology] [S.HasRightHomology] :\n    S.leftHomologyπ ≫ S.leftRightHomologyComparison ≫ S.rightHomologyι =\n      S.iCycles ≫ S.pOpcycles :=\n  π_leftRightHomologyComparison'_ι _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.π_leftRightHomologyComparison_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : S.HasRightHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftHomologyπ (CategoryTheory.CategoryStruct.comp S.leftRightHomologyComparison S.rightHomologyι)) (CategoryTheory.CategoryStruct.comp S.iCycles S.pOpcycles)","decl":"@[reassoc (attr := simp)]\nlemma π_leftRightHomologyComparison_ι [S.HasLeftHomology] [S.HasRightHomology] :\n    S.leftHomologyπ ≫ S.leftRightHomologyComparison ≫ S.rightHomologyι =\n      S.iCycles ≫ S.pOpcycles :=\n  π_leftRightHomologyComparison'_ι _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₁.RightHomologyData\nh₁' : S₂.LeftHomologyData\nh₂' : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₁') (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁' h₂')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (CategoryTheory.ShortComplex.rightHomologyMap' φ h₂ h₂'))","decl":"@[reassoc]\nlemma leftRightHomologyComparison'_naturality (φ : S₁ ⟶ S₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₁.RightHomologyData) (h₁' : S₂.LeftHomologyData) (h₂' : S₂.RightHomologyData) :\n    leftHomologyMap' φ h₁ h₁' ≫ leftRightHomologyComparison' h₁' h₂' =\n      leftRightHomologyComparison' h₁ h₂ ≫ rightHomologyMap' φ h₂ h₂' := by\n  simp only [← cancel_epi h₁.π, ← cancel_mono h₂'.ι, assoc,\n    leftHomologyπ_naturality'_assoc, rightHomologyι_naturality',\n    π_leftRightHomologyComparison'_ι, π_leftRightHomologyComparison'_ι_assoc,\n    cyclesMap'_i_assoc, p_opcyclesMap']\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₁.RightHomologyData\nh₁' : S₂.LeftHomologyData\nh₂' : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom h₂'.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₁') (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁' h₂') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ h₂ h₂') h))","decl":"@[reassoc]\nlemma leftRightHomologyComparison'_naturality (φ : S₁ ⟶ S₂) (h₁ : S₁.LeftHomologyData)\n    (h₂ : S₁.RightHomologyData) (h₁' : S₂.LeftHomologyData) (h₂' : S₂.RightHomologyData) :\n    leftHomologyMap' φ h₁ h₁' ≫ leftRightHomologyComparison' h₁' h₂' =\n      leftRightHomologyComparison' h₁ h₂ ≫ rightHomologyMap' φ h₂ h₂' := by\n  simp only [← cancel_epi h₁.π, ← cancel_mono h₂'.ι, assoc,\n    leftHomologyπ_naturality'_assoc, rightHomologyι_naturality',\n    π_leftRightHomologyComparison'_ι, π_leftRightHomologyComparison'_ι_assoc,\n    cyclesMap'_i_assoc, p_opcyclesMap']\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_compatibility","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ h₁' : S.LeftHomologyData\nh₂ h₂' : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.id S) h₁ h₁') (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁' h₂') (CategoryTheory.ShortComplex.rightHomologyMap' (CategoryTheory.CategoryStruct.id S) h₂' h₂)))","decl":"lemma leftRightHomologyComparison'_compatibility (h₁ h₁' : S.LeftHomologyData)\n    (h₂ h₂' : S.RightHomologyData) :\n    leftRightHomologyComparison' h₁ h₂ = leftHomologyMap' (𝟙 S) h₁ h₁' ≫\n      leftRightHomologyComparison' h₁' h₂' ≫ rightHomologyMap' (𝟙 S) _ _ := by\n  rw [leftRightHomologyComparison'_naturality_assoc (𝟙 S) h₁ h₂ h₁' h₂',\n    ← rightHomologyMap'_comp, comp_id, rightHomologyMap'_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : S.HasRightHomology\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ Eq S.leftRightHomologyComparison (CategoryTheory.CategoryStruct.comp h₁.leftHomologyIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) h₂.rightHomologyIso.inv))","decl":"lemma leftRightHomologyComparison_eq [S.HasLeftHomology] [S.HasRightHomology]\n    (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData) :\n    S.leftRightHomologyComparison = h₁.leftHomologyIso.hom ≫\n      leftRightHomologyComparison' h₁ h₂ ≫ h₂.rightHomologyIso.inv :=\n  leftRightHomologyComparison'_compatibility _ _ _ _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.leftRightHomologyComparison'_eq","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftRightHomologyComparison' h.left h.right) h.iso.hom","decl":"@[simp]\nlemma HomologyData.leftRightHomologyComparison'_eq (h : S.HomologyData) :\n    leftRightHomologyComparison' h.left h.right = h.iso.hom := by\n  simp only [← cancel_epi h.left.π, ← cancel_mono h.right.ι, assoc,\n    π_leftRightHomologyComparison'_ι, comm]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftRightHomologyComparison'_of_homologyData","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h.left h.right)","decl":"instance isIso_leftRightHomologyComparison'_of_homologyData (h : S.HomologyData) :\n  IsIso (leftRightHomologyComparison' h.left h.right) := by\n    rw [h.leftRightHomologyComparison'_eq]\n    infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftRightHomologyComparison'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂)","decl":"instance isIso_leftRightHomologyComparison' [S.HasHomology]\n    (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData) :\n    IsIso (leftRightHomologyComparison' h₁ h₂) := by\n  rw [leftRightHomologyComparison'_compatibility h₁ S.homologyData.left h₂\n    S.homologyData.right]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_leftRightHomologyComparison","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ CategoryTheory.IsIso S.leftRightHomologyComparison","decl":"instance isIso_leftRightHomologyComparison [S.HasHomology] :\n    IsIso S.leftRightHomologyComparison := by\n  dsimp only [leftRightHomologyComparison]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison'_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\ninst✝ : CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂)\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison' h₁ h₂).iso (CategoryTheory.asIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂))","decl":"/-- This is the homology data for a short complex `S` that is obtained\nfrom a left homology data `h₁` and a right homology data `h₂` when the comparison\nmorphism `leftRightHomologyComparison' h₁ h₂ : h₁.H ⟶ h₂.H` is an isomorphism. -/\n@[simps]\nnoncomputable def ofIsIsoLeftRightHomologyComparison'\n    (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData)\n    [IsIso (leftRightHomologyComparison' h₁ h₂)] :\n    S.HomologyData where\n  left := h₁\n  right := h₂\n  iso := asIso (leftRightHomologyComparison' h₁ h₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison'_left","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\ninst✝ : CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂)\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison' h₁ h₂).left h₁","decl":"/-- This is the homology data for a short complex `S` that is obtained\nfrom a left homology data `h₁` and a right homology data `h₂` when the comparison\nmorphism `leftRightHomologyComparison' h₁ h₂ : h₁.H ⟶ h₂.H` is an isomorphism. -/\n@[simps]\nnoncomputable def ofIsIsoLeftRightHomologyComparison'\n    (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData)\n    [IsIso (leftRightHomologyComparison' h₁ h₂)] :\n    S.HomologyData where\n  left := h₁\n  right := h₂\n  iso := asIso (leftRightHomologyComparison' h₁ h₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison'_right","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\ninst✝ : CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂)\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.ofIsIsoLeftRightHomologyComparison' h₁ h₂).right h₂","decl":"/-- This is the homology data for a short complex `S` that is obtained\nfrom a left homology data `h₁` and a right homology data `h₂` when the comparison\nmorphism `leftRightHomologyComparison' h₁ h₂ : h₁.H ⟶ h₂.H` is an isomorphism. -/\n@[simps]\nnoncomputable def ofIsIsoLeftRightHomologyComparison'\n    (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData)\n    [IsIso (leftRightHomologyComparison' h₁ h₂)] :\n    S.HomologyData where\n  left := h₁\n  right := h₂\n  iso := asIso (leftRightHomologyComparison' h₁ h₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\n⊢ Eq (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' (CategoryTheory.CategoryStruct.id S) h₁ h.left) (CategoryTheory.CategoryStruct.comp h.iso.hom (CategoryTheory.ShortComplex.rightHomologyMap' (CategoryTheory.CategoryStruct.id S) h.right h₂)))","decl":"lemma leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'\n    (h : S.HomologyData) (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData) :\n    leftRightHomologyComparison' h₁ h₂ =\n      leftHomologyMap' (𝟙 S) h₁ h.left ≫ h.iso.hom ≫ rightHomologyMap' (𝟙 S) h.right h₂ := by\n  simpa only [h.leftRightHomologyComparison'_eq] using\n    leftRightHomologyComparison'_compatibility h₁ h.left h₂ h.right\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_fac_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom h₂.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) h) (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.CategoryStruct.comp h₂.homologyIso.hom h))","decl":"@[reassoc]\nlemma leftRightHomologyComparison'_fac (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData)\n    [S.HasHomology] :\n    leftRightHomologyComparison' h₁ h₂ = h₁.homologyIso.inv ≫ h₂.homologyIso.hom := by\n  rw [leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'\n    S.homologyData h₁ h₂]\n  dsimp only [LeftHomologyData.homologyIso, LeftHomologyData.leftHomologyIso,\n    Iso.symm, Iso.trans, Iso.refl, leftHomologyMapIso', leftHomologyIso,\n    RightHomologyData.homologyIso, RightHomologyData.rightHomologyIso,\n    rightHomologyMapIso', rightHomologyIso]\n  simp only [assoc, ← leftHomologyMap'_comp_assoc, id_comp, ← rightHomologyMap'_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison'_fac","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂) (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv h₂.homologyIso.hom)","decl":"@[reassoc]\nlemma leftRightHomologyComparison'_fac (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData)\n    [S.HasHomology] :\n    leftRightHomologyComparison' h₁ h₂ = h₁.homologyIso.inv ≫ h₂.homologyIso.hom := by\n  rw [leftRightHomologyComparison'_eq_leftHomologpMap'_comp_iso_hom_comp_rightHomologyMap'\n    S.homologyData h₁ h₂]\n  dsimp only [LeftHomologyData.homologyIso, LeftHomologyData.leftHomologyIso,\n    Iso.symm, Iso.trans, Iso.refl, leftHomologyMapIso', leftHomologyIso,\n    RightHomologyData.homologyIso, RightHomologyData.rightHomologyIso,\n    rightHomologyMapIso', rightHomologyIso]\n  simp only [assoc, ← leftHomologyMap'_comp_assoc, id_comp, ← rightHomologyMap'_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison_fac","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq S.leftRightHomologyComparison (CategoryTheory.CategoryStruct.comp S.leftHomologyIso.hom S.rightHomologyIso.inv)","decl":"@[reassoc]\nlemma leftRightHomologyComparison_fac [S.HasHomology] :\n    S.leftRightHomologyComparison = S.leftHomologyIso.hom ≫ S.rightHomologyIso.inv := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv,\n    RightHomologyData.homologyIso_rightHomologyData, Iso.symm_hom] using\n      leftRightHomologyComparison'_fac S.leftHomologyData S.rightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.leftRightHomologyComparison_fac_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.rightHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.leftRightHomologyComparison h) (CategoryTheory.CategoryStruct.comp S.leftHomologyIso.hom (CategoryTheory.CategoryStruct.comp S.rightHomologyIso.inv h))","decl":"@[reassoc]\nlemma leftRightHomologyComparison_fac [S.HasHomology] :\n    S.leftRightHomologyComparison = S.leftHomologyIso.hom ≫ S.rightHomologyIso.inv := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv,\n    RightHomologyData.homologyIso_rightHomologyData, Iso.symm_hom] using\n      leftRightHomologyComparison'_fac S.leftHomologyData S.rightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.right_homologyIso_eq_left_homologyIso_trans_iso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh : S.HomologyData\ninst✝ : S.HasHomology\n⊢ Eq h.right.homologyIso (h.left.homologyIso.trans h.iso)","decl":"lemma HomologyData.right_homologyIso_eq_left_homologyIso_trans_iso\n    (h : S.HomologyData) [S.HasHomology] :\n    h.right.homologyIso = h.left.homologyIso ≪≫ h.iso := by\n  suffices h.iso = h.left.homologyIso.symm ≪≫ h.right.homologyIso by\n    rw [this, Iso.self_symm_id_assoc]\n  ext\n  dsimp\n  rw [← leftRightHomologyComparison'_fac, leftRightHomologyComparison'_eq]\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_isIso_leftRightHomologyComparison'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nh₁ : S.LeftHomologyData\nh₂ : S.RightHomologyData\ninst✝ : CategoryTheory.IsIso (CategoryTheory.ShortComplex.leftRightHomologyComparison' h₁ h₂)\n⊢ S.HasHomology","decl":"lemma hasHomology_of_isIso_leftRightHomologyComparison'\n    (h₁ : S.LeftHomologyData) (h₂ : S.RightHomologyData)\n    [IsIso (leftRightHomologyComparison' h₁ h₂)] :\n    S.HasHomology :=\n  HasHomology.mk' (HomologyData.ofIsIsoLeftRightHomologyComparison' h₁ h₂)\n\n"}
{"name":"CategoryTheory.ShortComplex.hasHomology_of_isIsoLeftRightHomologyComparison","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝¹ : S.HasLeftHomology\ninst✝ : S.HasRightHomology\nh : CategoryTheory.IsIso S.leftRightHomologyComparison\n⊢ S.HasHomology","decl":"lemma hasHomology_of_isIsoLeftRightHomologyComparison [S.HasLeftHomology]\n    [S.HasRightHomology] [h : IsIso S.leftRightHomologyComparison] :\n    S.HasHomology := by\n  haveI : IsIso (leftRightHomologyComparison' S.leftHomologyData S.rightHomologyData) := h\n  exact hasHomology_of_isIso_leftRightHomologyComparison' S.leftHomologyData S.rightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nZ : C\nh : Quiver.Hom h₂.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp h₂.homologyIso.hom h))","decl":"@[reassoc]\nlemma LeftHomologyData.leftHomologyIso_hom_naturality\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    h₁.homologyIso.hom ≫ leftHomologyMap' φ h₁ h₂ =\n      homologyMap φ ≫ h₂.homologyIso.hom := by\n  dsimp [homologyIso, ShortComplex.leftHomologyIso, homologyMap, homologyMap', leftHomologyIso]\n  simp only [← leftHomologyMap'_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h₂.homologyIso.hom)","decl":"@[reassoc]\nlemma LeftHomologyData.leftHomologyIso_hom_naturality\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    h₁.homologyIso.hom ≫ leftHomologyMap' φ h₁ h₂ =\n      homologyMap φ ≫ h₂.homologyIso.hom := by\n  dsimp [homologyIso, ShortComplex.leftHomologyIso, homologyMap, homologyMap', leftHomologyIso]\n  simp only [← leftHomologyMap'_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\nZ : C\nh : Quiver.Hom S₂.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.homologyIso.inv h))","decl":"@[reassoc]\nlemma LeftHomologyData.leftHomologyIso_inv_naturality\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    h₁.homologyIso.inv ≫ homologyMap φ =\n      leftHomologyMap' φ h₁ h₂ ≫ h₂.homologyIso.inv := by\n  dsimp [homologyIso, ShortComplex.leftHomologyIso, homologyMap, homologyMap', leftHomologyIso]\n  simp only [← leftHomologyMap'_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap' φ h₁ h₂) h₂.homologyIso.inv)","decl":"@[reassoc]\nlemma LeftHomologyData.leftHomologyIso_inv_naturality\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.LeftHomologyData) :\n    h₁.homologyIso.inv ≫ homologyMap φ =\n      leftHomologyMap' φ h₁ h₂ ≫ h₂.homologyIso.inv := by\n  dsimp [homologyIso, ShortComplex.leftHomologyIso, homologyMap, homologyMap', leftHomologyIso]\n  simp only [← leftHomologyMap'_comp, id_comp, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.leftHomologyIso.hom (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ) S₂.leftHomologyIso.hom)","decl":"@[reassoc]\nlemma leftHomologyIso_hom_naturality :\n    S₁.leftHomologyIso.hom ≫ homologyMap φ =\n      leftHomologyMap φ ≫ S₂.leftHomologyIso.hom := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv] using\n    LeftHomologyData.leftHomologyIso_inv_naturality φ S₁.leftHomologyData S₂.leftHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.leftHomologyIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.leftHomologyIso.hom h))","decl":"@[reassoc]\nlemma leftHomologyIso_hom_naturality :\n    S₁.leftHomologyIso.hom ≫ homologyMap φ =\n      leftHomologyMap φ ≫ S₂.leftHomologyIso.hom := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv] using\n    LeftHomologyData.leftHomologyIso_inv_naturality φ S₁.leftHomologyData S₂.leftHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.leftHomologyIso.inv (CategoryTheory.ShortComplex.leftHomologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) S₂.leftHomologyIso.inv)","decl":"@[reassoc]\nlemma leftHomologyIso_inv_naturality :\n    S₁.leftHomologyIso.inv ≫ leftHomologyMap φ =\n      homologyMap φ ≫ S₂.leftHomologyIso.inv := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv] using\n    LeftHomologyData.leftHomologyIso_hom_naturality φ S₁.leftHomologyData S₂.leftHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.leftHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.leftHomologyIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.leftHomologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.leftHomologyIso.inv h))","decl":"@[reassoc]\nlemma leftHomologyIso_inv_naturality :\n    S₁.leftHomologyIso.inv ≫ leftHomologyMap φ =\n      homologyMap φ ≫ S₂.leftHomologyIso.inv := by\n  simpa only [LeftHomologyData.homologyIso_leftHomologyData, Iso.symm_inv] using\n    LeftHomologyData.leftHomologyIso_hom_naturality φ S₁.leftHomologyData S₂.leftHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom h₂.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp h₂.homologyIso.hom h))","decl":"@[reassoc]\nlemma RightHomologyData.rightHomologyIso_hom_naturality\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    h₁.homologyIso.hom ≫ rightHomologyMap' φ h₁ h₂ =\n      homologyMap φ ≫ h₂.homologyIso.hom := by\n  rw [← cancel_epi h₁.homologyIso.inv, Iso.inv_hom_id_assoc,\n    ← cancel_epi (leftRightHomologyComparison' S₁.leftHomologyData h₁),\n    ← leftRightHomologyComparison'_naturality φ S₁.leftHomologyData h₁ S₂.leftHomologyData h₂,\n    ← cancel_epi (S₁.leftHomologyData.homologyIso.hom),\n    LeftHomologyData.leftHomologyIso_hom_naturality_assoc,\n    leftRightHomologyComparison'_fac, leftRightHomologyComparison'_fac, assoc,\n    Iso.hom_inv_id_assoc, Iso.hom_inv_id_assoc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.hom (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h₂.homologyIso.hom)","decl":"@[reassoc]\nlemma RightHomologyData.rightHomologyIso_hom_naturality\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n    h₁.homologyIso.hom ≫ rightHomologyMap' φ h₁ h₂ =\n      homologyMap φ ≫ h₂.homologyIso.hom := by\n  rw [← cancel_epi h₁.homologyIso.inv, Iso.inv_hom_id_assoc,\n    ← cancel_epi (leftRightHomologyComparison' S₁.leftHomologyData h₁),\n    ← leftRightHomologyComparison'_naturality φ S₁.leftHomologyData h₁ S₂.leftHomologyData h₂,\n    ← cancel_epi (S₁.leftHomologyData.homologyIso.hom),\n    LeftHomologyData.leftHomologyIso_hom_naturality_assoc,\n    leftRightHomologyComparison'_fac, leftRightHomologyComparison'_fac, assoc,\n    Iso.hom_inv_id_assoc, Iso.hom_inv_id_assoc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom S₂.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) (CategoryTheory.CategoryStruct.comp h₂.homologyIso.inv h))","decl":"@[reassoc]\nlemma RightHomologyData.rightHomologyIso_inv_naturality\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n      h₁.homologyIso.inv ≫ homologyMap φ =\n        rightHomologyMap' φ h₁ h₂ ≫ h₂.homologyIso.inv := by\n  simp only [← cancel_mono h₂.homologyIso.hom, assoc, Iso.inv_hom_id_assoc, comp_id,\n    ← RightHomologyData.rightHomologyIso_hom_naturality φ h₁ h₂, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.RightHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap' φ h₁ h₂) h₂.homologyIso.inv)","decl":"@[reassoc]\nlemma RightHomologyData.rightHomologyIso_inv_naturality\n    (h₁ : S₁.RightHomologyData) (h₂ : S₂.RightHomologyData) :\n      h₁.homologyIso.inv ≫ homologyMap φ =\n        rightHomologyMap' φ h₁ h₂ ≫ h₂.homologyIso.inv := by\n  simp only [← cancel_mono h₂.homologyIso.hom, assoc, Iso.inv_hom_id_assoc, comp_id,\n    ← RightHomologyData.rightHomologyIso_hom_naturality φ h₁ h₂, Iso.inv_hom_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.rightHomologyIso.hom (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ) S₂.rightHomologyIso.hom)","decl":"@[reassoc]\nlemma rightHomologyIso_hom_naturality :\n    S₁.rightHomologyIso.hom ≫ homologyMap φ =\n      rightHomologyMap φ ≫ S₂.rightHomologyIso.hom := by\n  simpa only [RightHomologyData.homologyIso_rightHomologyData, Iso.symm_inv] using\n    RightHomologyData.rightHomologyIso_inv_naturality φ S₁.rightHomologyData S₂.rightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.rightHomologyIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.rightHomologyIso.hom h))","decl":"@[reassoc]\nlemma rightHomologyIso_hom_naturality :\n    S₁.rightHomologyIso.hom ≫ homologyMap φ =\n      rightHomologyMap φ ≫ S₂.rightHomologyIso.hom := by\n  simpa only [RightHomologyData.homologyIso_rightHomologyData, Iso.symm_inv] using\n    RightHomologyData.rightHomologyIso_inv_naturality φ S₁.rightHomologyData S₂.rightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.rightHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.rightHomologyIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.rightHomologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.rightHomologyIso.inv h))","decl":"@[reassoc]\nlemma rightHomologyIso_inv_naturality :\n    S₁.rightHomologyIso.inv ≫ rightHomologyMap φ =\n      homologyMap φ ≫ S₂.rightHomologyIso.inv := by\n  simpa only [RightHomologyData.homologyIso_rightHomologyData, Iso.symm_inv] using\n    RightHomologyData.rightHomologyIso_hom_naturality φ S₁.rightHomologyData S₂.rightHomologyData\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.rightHomologyIso.inv (CategoryTheory.ShortComplex.rightHomologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) S₂.rightHomologyIso.inv)","decl":"@[reassoc]\nlemma rightHomologyIso_inv_naturality :\n    S₁.rightHomologyIso.inv ≫ rightHomologyMap φ =\n      homologyMap φ ≫ S₂.rightHomologyIso.inv := by\n  simpa only [RightHomologyData.homologyIso_rightHomologyData, Iso.symm_inv] using\n    RightHomologyData.rightHomologyIso_hom_naturality φ S₁.rightHomologyData S₂.rightHomologyData\n\n"}
{"name":"CategoryTheory.CategoryWithHomology.hasHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nself : CategoryTheory.CategoryWithHomology C\nS : CategoryTheory.ShortComplex C\n⊢ S.HasHomology","decl":"/-- We shall say that a category `C` is a category with homology when all short complexes\nhave homology. -/\nclass _root_.CategoryTheory.CategoryWithHomology : Prop where\n  hasHomology : ∀ (S : ShortComplex C), S.HasHomology\n\n"}
{"name":"CategoryTheory.ShortComplex.instCategoryWithHomologyOpposite","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.CategoryWithHomology C\n⊢ CategoryTheory.CategoryWithHomology (Opposite C)","decl":"instance [CategoryWithHomology C] : CategoryWithHomology Cᵒᵖ :=\n  ⟨fun S => HasHomology.mk' S.unop.homologyData.op⟩\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyFunctor_map","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.CategoryWithHomology C\nX✝ Y✝ : CategoryTheory.ShortComplex C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.ShortComplex.homologyFunctor C).map f) (CategoryTheory.ShortComplex.homologyMap f)","decl":"/-- The homology functor `ShortComplex C ⥤ C` for a category `C` with homology. -/\n@[simps]\nnoncomputable def homologyFunctor [CategoryWithHomology C] :\n    ShortComplex C ⥤ C where\n  obj S := S.homology\n  map f := homologyMap f\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyFunctor_obj","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\ninst✝ : CategoryTheory.CategoryWithHomology C\nS : CategoryTheory.ShortComplex C\n⊢ Eq ((CategoryTheory.ShortComplex.homologyFunctor C).obj S) S.homology","decl":"/-- The homology functor `ShortComplex C ⥤ C` for a category `C` with homology. -/\n@[simps]\nnoncomputable def homologyFunctor [CategoryWithHomology C] :\n    ShortComplex C ⥤ C where\n  obj S := S.homology\n  map f := homologyMap f\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap'_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂)","decl":"instance isIso_homologyMap'_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂)\n    (h₁ : S₁.HomologyData) (h₂ : S₂.HomologyData) [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso (homologyMap' φ h₁ h₂) := by\n  dsimp only [homologyMap']\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap_of_epi_of_isIso_of_mono'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nh₁ : CategoryTheory.Epi φ.τ₁\nh₂ : CategoryTheory.IsIso φ.τ₂\nh₃ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap φ)","decl":"lemma isIso_homologyMap_of_epi_of_isIso_of_mono' (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology]\n    (h₁ : Epi φ.τ₁) (h₂ : IsIso φ.τ₂) (h₃ : Mono φ.τ₃) :\n    IsIso (homologyMap φ) := by\n  dsimp only [homologyMap]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝⁴ : S₁.HasHomology\ninst✝³ : S₂.HasHomology\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap φ)","decl":"instance isIso_homologyMap_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso (homologyMap φ) :=\n  isIso_homologyMap_of_epi_of_isIso_of_mono' φ inferInstance inferInstance inferInstance\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyFunctor_map_of_epi_of_isIso_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝³ : CategoryTheory.CategoryWithHomology C\ninst✝² : CategoryTheory.Epi φ.τ₁\ninst✝¹ : CategoryTheory.IsIso φ.τ₂\ninst✝ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso ((CategoryTheory.ShortComplex.homologyFunctor C).map φ)","decl":"instance isIso_homologyFunctor_map_of_epi_of_isIso_of_mono (φ : S₁ ⟶ S₂) [CategoryWithHomology C]\n    [Epi φ.τ₁] [IsIso φ.τ₂] [Mono φ.τ₃] :\n    IsIso ((homologyFunctor C).map φ) :=\n  (inferInstance : IsIso (homologyMap φ))\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap_of_isIso","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : S₁.HasHomology\ninst✝¹ : S₂.HasHomology\ninst✝ : CategoryTheory.IsIso φ\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap φ)","decl":"instance isIso_homologyMap_of_isIso (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology] [IsIso φ] :\n    IsIso (homologyMap φ) := by\n  dsimp only [homologyMap, homologyMap']\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyπ_comp_leftHomologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (CategoryTheory.CategoryStruct.comp S.leftHomologyIso.inv h)) (CategoryTheory.CategoryStruct.comp S.leftHomologyπ h)","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_comp_leftHomologyIso_inv :\n    S.homologyπ ≫ S.leftHomologyIso.inv = S.leftHomologyπ := by\n  dsimp only [homologyπ]\n  simp only [assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyπ_comp_leftHomologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ S.leftHomologyIso.inv) S.leftHomologyπ","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_comp_leftHomologyIso_inv :\n    S.homologyπ ≫ S.leftHomologyIso.inv = S.leftHomologyπ := by\n  dsimp only [homologyπ]\n  simp only [assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyIso_hom_comp_homologyι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyIso.hom (CategoryTheory.CategoryStruct.comp S.homologyι h)) (CategoryTheory.CategoryStruct.comp S.rightHomologyι h)","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyIso_hom_comp_homologyι :\n    S.rightHomologyIso.hom ≫ S.homologyι = S.rightHomologyι := by\n  dsimp only [homologyι]\n  simp only [Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.rightHomologyIso_hom_comp_homologyι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.rightHomologyIso.hom S.homologyι) S.rightHomologyι","decl":"@[reassoc (attr := simp)]\nlemma rightHomologyIso_hom_comp_homologyι :\n    S.rightHomologyIso.hom ≫ S.homologyι = S.rightHomologyι := by\n  dsimp only [homologyι]\n  simp only [Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_comp_homologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles S.homologyπ) 0","decl":"@[reassoc (attr := simp)]\nlemma toCycles_comp_homologyπ :\n    S.toCycles ≫ S.homologyπ = 0 := by\n  dsimp only [homologyπ]\n  simp only [toCycles_comp_leftHomologyπ_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.toCycles_comp_homologyπ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.toCycles (CategoryTheory.CategoryStruct.comp S.homologyπ h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma toCycles_comp_homologyπ :\n    S.toCycles ≫ S.homologyπ = 0 := by\n  dsimp only [homologyπ]\n  simp only [toCycles_comp_leftHomologyπ_assoc, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_comp_fromOpcycles","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyι S.fromOpcycles) 0","decl":"@[reassoc (attr := simp)]\nlemma homologyι_comp_fromOpcycles :\n    S.homologyι ≫ S.fromOpcycles = 0 := by\n  dsimp only [homologyι]\n  simp only [assoc, rightHomologyι_comp_fromOpcycles, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_comp_fromOpcycles_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.X₃ Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyι (CategoryTheory.CategoryStruct.comp S.fromOpcycles h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc (attr := simp)]\nlemma homologyι_comp_fromOpcycles :\n    S.homologyι ≫ S.fromOpcycles = 0 := by\n  dsimp only [homologyι]\n  simp only [assoc, rightHomologyι_comp_fromOpcycles, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.instEpiHomologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ CategoryTheory.Epi S.homologyπ","decl":"instance : Epi S.homologyπ :=\n  Limits.epi_of_isColimit_cofork (S.homologyIsCokernel)\n\n"}
{"name":"CategoryTheory.ShortComplex.instMonoHomologyι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ CategoryTheory.Mono S.homologyι","decl":"instance : Mono S.homologyι :=\n  Limits.mono_of_isLimit_fork (S.homologyIsKernel)\n\n"}
{"name":"CategoryTheory.ShortComplex.π_descHomology_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom S.cycles A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.toCycles k) 0\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (CategoryTheory.CategoryStruct.comp (S.descHomology k hk) h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma π_descHomology (k : S.cycles ⟶ A) (hk : S.toCycles ≫ k = 0) :\n    S.homologyπ ≫ S.descHomology k hk = k :=\n  Cofork.IsColimit.π_desc S.homologyIsCokernel\n\n"}
{"name":"CategoryTheory.ShortComplex.π_descHomology","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom S.cycles A\nhk : Eq (CategoryTheory.CategoryStruct.comp S.toCycles k) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (S.descHomology k hk)) k","decl":"@[reassoc (attr := simp)]\nlemma π_descHomology (k : S.cycles ⟶ A) (hk : S.toCycles ≫ k = 0) :\n    S.homologyπ ≫ S.descHomology k hk = k :=\n  Cofork.IsColimit.π_desc S.homologyIsCokernel\n\n"}
{"name":"CategoryTheory.ShortComplex.liftHomology_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom A S.opcycles\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.fromOpcycles) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftHomology k hk) S.homologyι) k","decl":"@[reassoc (attr := simp)]\nlemma liftHomology_ι (k : A ⟶ S.opcycles) (hk : k ≫ S.fromOpcycles = 0) :\n    S.liftHomology k hk ≫ S.homologyι = k :=\n  Fork.IsLimit.lift_ι S.homologyIsKernel\n\n"}
{"name":"CategoryTheory.ShortComplex.liftHomology_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom A S.opcycles\nhk : Eq (CategoryTheory.CategoryStruct.comp k S.fromOpcycles) 0\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftHomology k hk) (CategoryTheory.CategoryStruct.comp S.homologyι h)) (CategoryTheory.CategoryStruct.comp k h)","decl":"@[reassoc (attr := simp)]\nlemma liftHomology_ι (k : A ⟶ S.opcycles) (hk : k ≫ S.fromOpcycles = 0) :\n    S.liftHomology k hk ≫ S.homologyι = k :=\n  Fork.IsLimit.lift_ι S.homologyIsKernel\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyπ_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.homologyπ (CategoryTheory.ShortComplex.homologyMap φ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) S₂.homologyπ)","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_naturality (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology] :\n    S₁.homologyπ ≫ homologyMap φ = cyclesMap φ ≫ S₂.homologyπ := by\n  simp only [← cancel_mono S₂.leftHomologyIso.inv, assoc, ← leftHomologyIso_inv_naturality φ,\n    homologyπ_comp_leftHomologyIso_inv]\n  simp only [homologyπ, assoc, Iso.hom_inv_id_assoc, leftHomologyπ_naturality]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyπ_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nZ : C\nh : Quiver.Hom S₂.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.homologyπ (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.cyclesMap φ) (CategoryTheory.CategoryStruct.comp S₂.homologyπ h))","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_naturality (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology] :\n    S₁.homologyπ ≫ homologyMap φ = cyclesMap φ ≫ S₂.homologyπ := by\n  simp only [← cancel_mono S₂.leftHomologyIso.inv, assoc, ← leftHomologyIso_inv_naturality φ,\n    homologyπ_comp_leftHomologyIso_inv]\n  simp only [homologyπ, assoc, Iso.hom_inv_id_assoc, leftHomologyπ_naturality]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) S₂.homologyι) (CategoryTheory.CategoryStruct.comp S₁.homologyι (CategoryTheory.ShortComplex.opcyclesMap φ))","decl":"@[reassoc (attr := simp)]\nlemma homologyι_naturality (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology] :\n    homologyMap φ ≫ S₂.homologyι = S₁.homologyι ≫ S₁.opcyclesMap φ  := by\n  simp only [← cancel_epi S₁.rightHomologyIso.hom, rightHomologyIso_hom_naturality_assoc φ,\n    rightHomologyIso_hom_comp_homologyι, rightHomologyι_naturality]\n  simp only [homologyι, assoc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nZ : C\nh : Quiver.Hom S₂.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.homologyι h)) (CategoryTheory.CategoryStruct.comp S₁.homologyι (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.opcyclesMap φ) h))","decl":"@[reassoc (attr := simp)]\nlemma homologyι_naturality (φ : S₁ ⟶ S₂) [S₁.HasHomology] [S₂.HasHomology] :\n    homologyMap φ ≫ S₂.homologyι = S₁.homologyι ≫ S₁.opcyclesMap φ  := by\n  simp only [← cancel_epi S₁.rightHomologyIso.hom, rightHomologyIso_hom_naturality_assoc φ,\n    rightHomologyIso_hom_comp_homologyι, rightHomologyι_naturality]\n  simp only [homologyι, assoc, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.homology_π_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (CategoryTheory.CategoryStruct.comp S.homologyι h)) (CategoryTheory.CategoryStruct.comp S.iCycles (CategoryTheory.CategoryStruct.comp S.pOpcycles h))","decl":"@[reassoc (attr := simp)]\nlemma homology_π_ι :\n    S.homologyπ ≫ S.homologyι = S.iCycles ≫ S.pOpcycles := by\n  dsimp only [homologyπ, homologyι]\n  simpa only [assoc, S.leftRightHomologyComparison_fac] using S.π_leftRightHomologyComparison_ι\n\n"}
{"name":"CategoryTheory.ShortComplex.homology_π_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ S.homologyι) (CategoryTheory.CategoryStruct.comp S.iCycles S.pOpcycles)","decl":"@[reassoc (attr := simp)]\nlemma homology_π_ι :\n    S.homologyπ ≫ S.homologyι = S.iCycles ≫ S.pOpcycles := by\n  dsimp only [homologyπ, homologyι]\n  simpa only [assoc, S.leftRightHomologyComparison_fac] using S.π_leftRightHomologyComparison_ι\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.homologyπ_comp_homologyIso_hom_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.LeftHomologyData\nZ : C\nh : Quiver.Hom h✝.H Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (CategoryTheory.CategoryStruct.comp h✝.homologyIso.hom h)) (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.hom (CategoryTheory.CategoryStruct.comp h✝.π h))","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.homologyπ_comp_homologyIso_hom (h : S.LeftHomologyData) :\n    S.homologyπ ≫ h.homologyIso.hom = h.cyclesIso.hom ≫ h.π := by\n  dsimp only [homologyπ, homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id_assoc,\n    leftHomologyπ_comp_leftHomologyIso_hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.homologyπ_comp_homologyIso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ h.homologyIso.hom) (CategoryTheory.CategoryStruct.comp h.cyclesIso.hom h.π)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.homologyπ_comp_homologyIso_hom (h : S.LeftHomologyData) :\n    S.homologyπ ≫ h.homologyIso.hom = h.cyclesIso.hom ≫ h.π := by\n  dsimp only [homologyπ, homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id_assoc,\n    leftHomologyπ_comp_leftHomologyIso_hom]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.π_comp_homologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.π (CategoryTheory.CategoryStruct.comp h✝.homologyIso.inv h)) (CategoryTheory.CategoryStruct.comp h✝.cyclesIso.inv (CategoryTheory.CategoryStruct.comp S.homologyπ h))","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.π_comp_homologyIso_inv (h : S.LeftHomologyData) :\n    h.π ≫ h.homologyIso.inv = h.cyclesIso.inv ≫ S.homologyπ := by\n  dsimp only [homologyπ, homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, π_comp_leftHomologyIso_inv_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.π_comp_homologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.π h.homologyIso.inv) (CategoryTheory.CategoryStruct.comp h.cyclesIso.inv S.homologyπ)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.π_comp_homologyIso_inv (h : S.LeftHomologyData) :\n    h.π ≫ h.homologyIso.inv = h.cyclesIso.inv ≫ S.homologyπ := by\n  dsimp only [homologyπ, homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, π_comp_leftHomologyIso_inv_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_inv_comp_homologyι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.RightHomologyData\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.homologyIso.inv (CategoryTheory.CategoryStruct.comp S.homologyι h)) (CategoryTheory.CategoryStruct.comp h✝.ι (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.inv h))","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_inv_comp_homologyι (h : S.RightHomologyData) :\n    h.homologyIso.inv ≫ S.homologyι = h.ι ≫ h.opcyclesIso.inv := by\n  dsimp only [homologyι, homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, assoc, Iso.hom_inv_id_assoc,\n    rightHomologyIso_inv_comp_rightHomologyι]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_inv_comp_homologyι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.homologyIso.inv S.homologyι) (CategoryTheory.CategoryStruct.comp h.ι h.opcyclesIso.inv)","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_inv_comp_homologyι (h : S.RightHomologyData) :\n    h.homologyIso.inv ≫ S.homologyι = h.ι ≫ h.opcyclesIso.inv := by\n  dsimp only [homologyι, homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, assoc, Iso.hom_inv_id_assoc,\n    rightHomologyIso_inv_comp_rightHomologyι]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_hom_comp_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.homologyIso.hom h.ι) (CategoryTheory.CategoryStruct.comp S.homologyι h.opcyclesIso.hom)","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_hom_comp_ι (h : S.RightHomologyData) :\n    h.homologyIso.hom ≫ h.ι = S.homologyι ≫ h.opcyclesIso.hom := by\n  dsimp only [homologyι, homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, rightHomologyIso_hom_comp_ι]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_hom_comp_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.RightHomologyData\nZ : C\nh : Quiver.Hom h✝.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.homologyIso.hom (CategoryTheory.CategoryStruct.comp h✝.ι h)) (CategoryTheory.CategoryStruct.comp S.homologyι (CategoryTheory.CategoryStruct.comp h✝.opcyclesIso.hom h))","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_hom_comp_ι (h : S.RightHomologyData) :\n    h.homologyIso.hom ≫ h.ι = S.homologyι ≫ h.opcyclesIso.hom := by\n  dsimp only [homologyι, homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, rightHomologyIso_hom_comp_ι]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.homologyIso_hom_comp_leftHomologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.homologyIso.hom h.leftHomologyIso.inv) S.leftHomologyIso.inv","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.homologyIso_hom_comp_leftHomologyIso_inv (h : S.LeftHomologyData) :\n    h.homologyIso.hom ≫ h.leftHomologyIso.inv = S.leftHomologyIso.inv := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.homologyIso_hom_comp_leftHomologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.leftHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.homologyIso.hom (CategoryTheory.CategoryStruct.comp h✝.leftHomologyIso.inv h)) (CategoryTheory.CategoryStruct.comp S.leftHomologyIso.inv h)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.homologyIso_hom_comp_leftHomologyIso_inv (h : S.LeftHomologyData) :\n    h.homologyIso.hom ≫ h.leftHomologyIso.inv = S.leftHomologyIso.inv := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_hom_comp_homologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.LeftHomologyData\nZ : C\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.leftHomologyIso.hom (CategoryTheory.CategoryStruct.comp h✝.homologyIso.inv h)) (CategoryTheory.CategoryStruct.comp S.leftHomologyIso.hom h)","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.leftHomologyIso_hom_comp_homologyIso_inv (h : S.LeftHomologyData) :\n    h.leftHomologyIso.hom ≫ h.homologyIso.inv = S.leftHomologyIso.hom := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.leftHomologyIso_hom_comp_homologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.LeftHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.leftHomologyIso.hom h.homologyIso.inv) S.leftHomologyIso.hom","decl":"@[reassoc (attr := simp)]\nlemma LeftHomologyData.leftHomologyIso_hom_comp_homologyIso_inv (h : S.LeftHomologyData) :\n    h.leftHomologyIso.hom ≫ h.homologyIso.inv = S.leftHomologyIso.hom := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_hom_comp_rightHomologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.RightHomologyData\nZ : C\nh : Quiver.Hom S.rightHomology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.homologyIso.hom (CategoryTheory.CategoryStruct.comp h✝.rightHomologyIso.inv h)) (CategoryTheory.CategoryStruct.comp S.rightHomologyIso.inv h)","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_hom_comp_rightHomologyIso_inv (h : S.RightHomologyData) :\n    h.homologyIso.hom ≫ h.rightHomologyIso.inv = S.rightHomologyIso.inv := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.homologyIso_hom_comp_rightHomologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.homologyIso.hom h.rightHomologyIso.inv) S.rightHomologyIso.inv","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.homologyIso_hom_comp_rightHomologyIso_inv (h : S.RightHomologyData) :\n    h.homologyIso.hom ≫ h.rightHomologyIso.inv = S.rightHomologyIso.inv := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_hom, Iso.symm_hom, assoc, Iso.hom_inv_id, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_comp_homologyIso_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh✝ : S.RightHomologyData\nZ : C\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h✝.rightHomologyIso.hom (CategoryTheory.CategoryStruct.comp h✝.homologyIso.inv h)) (CategoryTheory.CategoryStruct.comp S.rightHomologyIso.hom h)","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.rightHomologyIso_hom_comp_homologyIso_inv (h : S.RightHomologyData) :\n    h.rightHomologyIso.hom ≫ h.homologyIso.inv = S.rightHomologyIso.hom := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.rightHomologyIso_hom_comp_homologyIso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\nh : S.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h.rightHomologyIso.hom h.homologyIso.inv) S.rightHomologyIso.hom","decl":"@[reassoc (attr := simp)]\nlemma RightHomologyData.rightHomologyIso_hom_comp_homologyIso_inv (h : S.RightHomologyData) :\n    h.rightHomologyIso.hom ≫ h.homologyIso.inv = S.rightHomologyIso.hom := by\n  dsimp only [homologyIso]\n  simp only [Iso.trans_inv, Iso.symm_inv, Iso.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.comp_homologyMap_comp","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.RightHomologyData\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp h₂.homologyIso.hom h₂.ι)))) (CategoryTheory.CategoryStruct.comp h₁.i (CategoryTheory.CategoryStruct.comp φ.τ₂ h₂.p))","decl":"@[reassoc]\nlemma comp_homologyMap_comp [S₁.HasHomology] [S₂.HasHomology] (φ : S₁ ⟶ S₂)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.RightHomologyData) :\n    h₁.π ≫ h₁.homologyIso.inv ≫ homologyMap φ ≫ h₂.homologyIso.hom ≫ h₂.ι =\n      h₁.i ≫ φ.τ₂ ≫ h₂.p := by\n  dsimp only [LeftHomologyData.homologyIso, RightHomologyData.homologyIso,\n    Iso.symm, Iso.trans, Iso.refl, leftHomologyIso, rightHomologyIso,\n    leftHomologyMapIso', rightHomologyMapIso',\n    LeftHomologyData.cyclesIso, RightHomologyData.opcyclesIso,\n    LeftHomologyData.leftHomologyIso, RightHomologyData.rightHomologyIso,\n    homologyMap, homologyMap']\n  simp only [assoc, rightHomologyι_naturality', rightHomologyι_naturality'_assoc,\n    leftHomologyπ_naturality'_assoc, HomologyData.comm_assoc, p_opcyclesMap'_assoc,\n    id_τ₂, p_opcyclesMap', id_comp, cyclesMap'_i_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.comp_homologyMap_comp_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.LeftHomologyData\nh₂ : S₂.RightHomologyData\nZ : C\nh : Quiver.Hom h₂.Q Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp h₁.π (CategoryTheory.CategoryStruct.comp h₁.homologyIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp h₂.homologyIso.hom (CategoryTheory.CategoryStruct.comp h₂.ι h))))) (CategoryTheory.CategoryStruct.comp h₁.i (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.CategoryStruct.comp h₂.p h)))","decl":"@[reassoc]\nlemma comp_homologyMap_comp [S₁.HasHomology] [S₂.HasHomology] (φ : S₁ ⟶ S₂)\n    (h₁ : S₁.LeftHomologyData) (h₂ : S₂.RightHomologyData) :\n    h₁.π ≫ h₁.homologyIso.inv ≫ homologyMap φ ≫ h₂.homologyIso.hom ≫ h₂.ι =\n      h₁.i ≫ φ.τ₂ ≫ h₂.p := by\n  dsimp only [LeftHomologyData.homologyIso, RightHomologyData.homologyIso,\n    Iso.symm, Iso.trans, Iso.refl, leftHomologyIso, rightHomologyIso,\n    leftHomologyMapIso', rightHomologyMapIso',\n    LeftHomologyData.cyclesIso, RightHomologyData.opcyclesIso,\n    LeftHomologyData.leftHomologyIso, RightHomologyData.rightHomologyIso,\n    homologyMap, homologyMap']\n  simp only [assoc, rightHomologyι_naturality', rightHomologyι_naturality'_assoc,\n    leftHomologyπ_naturality'_assoc, HomologyData.comm_assoc, p_opcyclesMap'_assoc,\n    id_τ₂, p_opcyclesMap', id_comp, cyclesMap'_i_assoc]\n\n"}
{"name":"CategoryTheory.ShortComplex.π_homologyMap_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.homologyπ (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) S₂.homologyι)) (CategoryTheory.CategoryStruct.comp S₁.iCycles (CategoryTheory.CategoryStruct.comp φ.τ₂ S₂.pOpcycles))","decl":"@[reassoc]\nlemma π_homologyMap_ι [S₁.HasHomology] [S₂.HasHomology] (φ : S₁ ⟶ S₂) :\n    S₁.homologyπ ≫ homologyMap φ ≫ S₂.homologyι = S₁.iCycles ≫ φ.τ₂ ≫ S₂.pOpcycles := by\n  simp only [homologyι_naturality, homology_π_ι_assoc, p_opcyclesMap]\n\n"}
{"name":"CategoryTheory.ShortComplex.π_homologyMap_ι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nφ : Quiver.Hom S₁ S₂\nZ : C\nh : Quiver.Hom S₂.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S₁.homologyπ (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ) (CategoryTheory.CategoryStruct.comp S₂.homologyι h))) (CategoryTheory.CategoryStruct.comp S₁.iCycles (CategoryTheory.CategoryStruct.comp φ.τ₂ (CategoryTheory.CategoryStruct.comp S₂.pOpcycles h)))","decl":"@[reassoc]\nlemma π_homologyMap_ι [S₁.HasHomology] [S₂.HasHomology] (φ : S₁ ⟶ S₂) :\n    S₁.homologyπ ≫ homologyMap φ ≫ S₂.homologyι = S₁.iCycles ≫ φ.τ₂ ≫ S₂.pOpcycles := by\n  simp only [homologyι_naturality, homology_π_ι_assoc, p_opcyclesMap]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap'_op","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\nh₁ : S₁.HomologyData\nh₂ : S₂.HomologyData\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap' φ h₁ h₂).op (CategoryTheory.CategoryStruct.comp h₂.iso.inv.op (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap' (CategoryTheory.ShortComplex.opMap φ) h₂.op h₁.op) h₁.iso.hom.op))","decl":"lemma homologyMap'_op : (homologyMap' φ h₁ h₂).op =\n    h₂.iso.inv.op ≫ homologyMap' (opMap φ) h₂.op h₁.op ≫ h₁.iso.hom.op :=\n  Quiver.Hom.unop_inj (by\n    dsimp\n    have γ : HomologyMapData φ h₁ h₂ := default\n    simp only [γ.homologyMap'_eq, γ.op.homologyMap'_eq, HomologyData.op_left,\n      HomologyMapData.op_left, RightHomologyMapData.op_φH, Quiver.Hom.unop_op, assoc,\n      ← γ.comm_assoc, Iso.hom_inv_id, comp_id])\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyMap_op","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.homologyMap φ).op (CategoryTheory.CategoryStruct.comp S₂.homologyOpIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.ShortComplex.opMap φ)) S₁.homologyOpIso.hom))","decl":"lemma homologyMap_op [HasHomology S₁] [HasHomology S₂] :\n    (homologyMap φ).op =\n      (S₂.homologyOpIso).inv ≫ homologyMap (opMap φ) ≫ (S₁.homologyOpIso).hom := by\n  dsimp only [homologyMap, homologyOpIso]\n  rw [homologyMap'_op]\n  dsimp only [Iso.symm, Iso.trans, Iso.op, Iso.refl, rightHomologyIso, leftHomologyIso,\n    leftHomologyOpIso, leftHomologyMapIso', rightHomologyMapIso',\n    LeftHomologyData.leftHomologyIso, homologyMap']\n  simp only [assoc, rightHomologyMap'_op, op_comp, ← leftHomologyMap'_comp_assoc, id_comp,\n    opMap_id, comp_id, HomologyData.op_left]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyOpIso_hom_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nZ : Opposite C\nh : Quiver.Hom { unop := S₁.homology } Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.ShortComplex.opMap φ)) (CategoryTheory.CategoryStruct.comp S₁.homologyOpIso.hom h)) (CategoryTheory.CategoryStruct.comp S₂.homologyOpIso.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ).op h))","decl":"@[reassoc]\nlemma homologyOpIso_hom_naturality [S₁.HasHomology] [S₂.HasHomology] :\n    homologyMap (opMap φ) ≫ (S₁.homologyOpIso).hom =\n      S₂.homologyOpIso.hom ≫ (homologyMap φ).op := by\n  simp [homologyMap_op]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyOpIso_hom_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.ShortComplex.opMap φ)) S₁.homologyOpIso.hom) (CategoryTheory.CategoryStruct.comp S₂.homologyOpIso.hom (CategoryTheory.ShortComplex.homologyMap φ).op)","decl":"@[reassoc]\nlemma homologyOpIso_hom_naturality [S₁.HasHomology] [S₂.HasHomology] :\n    homologyMap (opMap φ) ≫ (S₁.homologyOpIso).hom =\n      S₂.homologyOpIso.hom ≫ (homologyMap φ).op := by\n  simp [homologyMap_op]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyOpIso_inv_naturality_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nZ : Opposite C\nh : Quiver.Hom S₁.op.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ).op (CategoryTheory.CategoryStruct.comp S₁.homologyOpIso.inv h)) (CategoryTheory.CategoryStruct.comp S₂.homologyOpIso.inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.ShortComplex.opMap φ)) h))","decl":"@[reassoc]\nlemma homologyOpIso_inv_naturality [S₁.HasHomology] [S₂.HasHomology] :\n    (homologyMap φ).op ≫ (S₁.homologyOpIso).inv =\n      S₂.homologyOpIso.inv ≫ homologyMap (opMap φ) := by\n  simp [homologyMap_op]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyOpIso_inv_naturality","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.ShortComplex.homologyMap φ).op S₁.homologyOpIso.inv) (CategoryTheory.CategoryStruct.comp S₂.homologyOpIso.inv (CategoryTheory.ShortComplex.homologyMap (CategoryTheory.ShortComplex.opMap φ)))","decl":"@[reassoc]\nlemma homologyOpIso_inv_naturality [S₁.HasHomology] [S₂.HasHomology] :\n    (homologyMap φ).op ≫ (S₁.homologyOpIso).inv =\n      S₂.homologyOpIso.inv ≫ homologyMap (opMap φ) := by\n  simp [homologyMap_op]\n\n"}
{"name":"CategoryTheory.ShortComplex.liftCycles_homologyπ_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom A S.X₂\nx : Quiver.Hom A S.X₁\nhx : Eq k (CategoryTheory.CategoryStruct.comp x S.f)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.liftCycles k ⋯) S.homologyπ) 0","decl":"lemma liftCycles_homologyπ_eq_zero_of_boundary [S.HasHomology]\n    (k : A ⟶ S.X₂) (x : A ⟶ S.X₁) (hx : k = x ≫ S.f) :\n    S.liftCycles k (by rw [hx, assoc, S.zero, comp_zero]) ≫ S.homologyπ = 0 := by\n  dsimp only [homologyπ]\n  rw [S.liftCycles_leftHomologyπ_eq_zero_of_boundary_assoc k x hx, zero_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_descOpcycles_eq_zero_of_boundary_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom S.X₂ A\nx : Quiver.Hom S.X₃ A\nhx : Eq k (CategoryTheory.CategoryStruct.comp S.g x)\nZ : C\nh : Quiver.Hom A Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyι (CategoryTheory.CategoryStruct.comp (S.descOpcycles k ⋯) h)) (CategoryTheory.CategoryStruct.comp 0 h)","decl":"@[reassoc]\nlemma homologyι_descOpcycles_eq_zero_of_boundary [S.HasHomology]\n    (k : S.X₂ ⟶ A) (x : S.X₃ ⟶ A) (hx : k = S.g ≫ x) :\n    S.homologyι ≫ S.descOpcycles k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by\n  dsimp only [homologyι]\n  rw [assoc, S.rightHomologyι_descOpcycles_π_eq_zero_of_boundary k x hx, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_descOpcycles_eq_zero_of_boundary","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nA : C\ninst✝ : S.HasHomology\nk : Quiver.Hom S.X₂ A\nx : Quiver.Hom S.X₃ A\nhx : Eq k (CategoryTheory.CategoryStruct.comp S.g x)\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyι (S.descOpcycles k ⋯)) 0","decl":"@[reassoc]\nlemma homologyι_descOpcycles_eq_zero_of_boundary [S.HasHomology]\n    (k : S.X₂ ⟶ A) (x : S.X₃ ⟶ A) (hx : k = S.g ≫ x) :\n    S.homologyι ≫ S.descOpcycles k (by rw [hx, S.zero_assoc, zero_comp]) = 0 := by\n  dsimp only [homologyι]\n  rw [assoc, S.rightHomologyι_descOpcycles_π_eq_zero_of_boundary k x hx, comp_zero]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap_of_isIso_cyclesMap_of_epi","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nh₁ : CategoryTheory.IsIso (CategoryTheory.ShortComplex.cyclesMap φ)\nh₂ : CategoryTheory.Epi φ.τ₁\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap φ)","decl":"lemma isIso_homologyMap_of_isIso_cyclesMap_of_epi {φ : S₁ ⟶ S₂}\n    [S₁.HasHomology] [S₂.HasHomology] (h₁ : IsIso (cyclesMap φ)) (h₂ : Epi φ.τ₁) :\n    IsIso (homologyMap φ) := by\n  have h : S₂.toCycles ≫ inv (cyclesMap φ) ≫ S₁.homologyπ = 0 := by\n    simp only [← cancel_epi φ.τ₁, ← toCycles_naturality_assoc,\n      IsIso.hom_inv_id_assoc, toCycles_comp_homologyπ, comp_zero]\n  have ⟨z, hz⟩ := CokernelCofork.IsColimit.desc' S₂.homologyIsCokernel _ h\n  dsimp at hz\n  refine ⟨⟨z, ?_, ?_⟩⟩\n  · rw [← cancel_epi S₁.homologyπ, homologyπ_naturality_assoc, hz,\n      IsIso.hom_inv_id_assoc, comp_id]\n  · rw [← cancel_epi S₂.homologyπ, reassoc_of% hz, homologyπ_naturality,\n      IsIso.inv_hom_id_assoc, comp_id]\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyMap_of_isIso_opcyclesMap_of_mono","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nh₁ : CategoryTheory.IsIso (CategoryTheory.ShortComplex.opcyclesMap φ)\nh₂ : CategoryTheory.Mono φ.τ₃\n⊢ CategoryTheory.IsIso (CategoryTheory.ShortComplex.homologyMap φ)","decl":"lemma isIso_homologyMap_of_isIso_opcyclesMap_of_mono {φ : S₁ ⟶ S₂}\n    [S₁.HasHomology] [S₂.HasHomology] (h₁ : IsIso (opcyclesMap φ)) (h₂ : Mono φ.τ₃) :\n    IsIso (homologyMap φ) := by\n  have h : (S₂.homologyι ≫ inv (opcyclesMap φ)) ≫ S₁.fromOpcycles = 0 := by\n    simp only [← cancel_mono φ.τ₃, zero_comp, assoc, ← fromOpcycles_naturality,\n      IsIso.inv_hom_id_assoc, homologyι_comp_fromOpcycles]\n  have ⟨z, hz⟩ := KernelFork.IsLimit.lift' S₁.homologyIsKernel _ h\n  dsimp at hz\n  refine ⟨⟨z, ?_, ?_⟩⟩\n  · rw [← cancel_mono S₁.homologyι, id_comp, assoc, hz, homologyι_naturality_assoc,\n      IsIso.hom_inv_id, comp_id]\n  · rw [← cancel_mono S₂.homologyι, assoc, homologyι_naturality, reassoc_of% hz,\n      IsIso.inv_hom_id, comp_id, id_comp]\n\n"}
{"name":"CategoryTheory.ShortComplex.isZero_homology_of_isZero_X₂","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhS : CategoryTheory.Limits.IsZero S.X₂\ninst✝ : S.HasHomology\n⊢ CategoryTheory.Limits.IsZero S.homology","decl":"lemma isZero_homology_of_isZero_X₂ (hS : IsZero S.X₂) [S.HasHomology] :\n    IsZero S.homology :=\n  IsZero.of_iso hS (HomologyData.ofZeros S (hS.eq_of_tgt _ _)\n    (hS.eq_of_src _ _)).left.homologyIso\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : S.HasHomology\n⊢ CategoryTheory.IsIso S.homologyπ","decl":"lemma isIso_homologyπ (hf : S.f = 0) [S.HasHomology] :\n    IsIso S.homologyπ := by\n  have := S.isIso_leftHomologyπ hf\n  dsimp only [homologyπ]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.isIso_homologyι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : S.HasHomology\n⊢ CategoryTheory.IsIso S.homologyι","decl":"lemma isIso_homologyι (hg : S.g = 0) [S.HasHomology] :\n    IsIso S.homologyι := by\n  have := S.isIso_rightHomologyι hg\n  dsimp only [homologyι]\n  infer_instance\n\n"}
{"name":"CategoryTheory.ShortComplex.asIsoHomologyπ_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : S.HasHomology\n⊢ Eq (S.asIsoHomologyπ hf).hom S.homologyπ","decl":"/-- The canonical isomorphism `S.cycles ≅ S.homology` when `S.f = 0`. -/\n@[simps! hom]\nnoncomputable def asIsoHomologyπ (hf : S.f = 0) [S.HasHomology] :\n    S.cycles ≅ S.homology := by\n  have := S.isIso_homologyπ hf\n  exact asIso S.homologyπ\n\n"}
{"name":"CategoryTheory.ShortComplex.asIsoHomologyπ_inv_comp_homologyπ_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.asIsoHomologyπ hf).inv (CategoryTheory.CategoryStruct.comp S.homologyπ h)) h","decl":"@[reassoc (attr := simp)]\nlemma asIsoHomologyπ_inv_comp_homologyπ (hf : S.f = 0) [S.HasHomology] :\n    (S.asIsoHomologyπ hf).inv ≫ S.homologyπ = 𝟙 _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.asIsoHomologyπ_inv_comp_homologyπ","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.asIsoHomologyπ hf).inv S.homologyπ) (CategoryTheory.CategoryStruct.id S.homology)","decl":"@[reassoc (attr := simp)]\nlemma asIsoHomologyπ_inv_comp_homologyπ (hf : S.f = 0) [S.HasHomology] :\n    (S.asIsoHomologyπ hf).inv ≫ S.homologyπ = 𝟙 _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyπ_comp_asIsoHomologyπ_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (S.asIsoHomologyπ hf).inv) (CategoryTheory.CategoryStruct.id S.cycles)","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_comp_asIsoHomologyπ_inv (hf : S.f = 0) [S.HasHomology] :\n    S.homologyπ ≫ (S.asIsoHomologyπ hf).inv = 𝟙 _ := (S.asIsoHomologyπ hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyπ_comp_asIsoHomologyπ_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhf : Eq S.f 0\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.cycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyπ (CategoryTheory.CategoryStruct.comp (S.asIsoHomologyπ hf).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma homologyπ_comp_asIsoHomologyπ_inv (hf : S.f = 0) [S.HasHomology] :\n    S.homologyπ ≫ (S.asIsoHomologyπ hf).inv = 𝟙 _ := (S.asIsoHomologyπ hf).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.asIsoHomologyι_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : S.HasHomology\n⊢ Eq (S.asIsoHomologyι hg).hom S.homologyι","decl":"/-- The canonical isomorphism `S.homology ≅ S.opcycles` when `S.g = 0`. -/\n@[simps! hom]\nnoncomputable def asIsoHomologyι (hg : S.g = 0) [S.HasHomology] :\n    S.homology ≅ S.opcycles := by\n  have := S.isIso_homologyι hg\n  exact asIso S.homologyι\n\n"}
{"name":"CategoryTheory.ShortComplex.asIsoHomologyι_inv_comp_homologyι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.asIsoHomologyι hg).inv S.homologyι) (CategoryTheory.CategoryStruct.id S.opcycles)","decl":"@[reassoc (attr := simp)]\nlemma asIsoHomologyι_inv_comp_homologyι (hg : S.g = 0) [S.HasHomology] :\n    (S.asIsoHomologyι hg).inv ≫ S.homologyι = 𝟙 _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.asIsoHomologyι_inv_comp_homologyι_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.opcycles Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (S.asIsoHomologyι hg).inv (CategoryTheory.CategoryStruct.comp S.homologyι h)) h","decl":"@[reassoc (attr := simp)]\nlemma asIsoHomologyι_inv_comp_homologyι (hg : S.g = 0) [S.HasHomology] :\n    (S.asIsoHomologyι hg).inv ≫ S.homologyι = 𝟙 _ := Iso.inv_hom_id _\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_comp_asIsoHomologyι_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyι (S.asIsoHomologyι hg).inv) (CategoryTheory.CategoryStruct.id S.homology)","decl":"@[reassoc (attr := simp)]\nlemma homologyι_comp_asIsoHomologyι_inv (hg : S.g = 0) [S.HasHomology] :\n    S.homologyι ≫ (S.asIsoHomologyι hg).inv  = 𝟙 _ := (S.asIsoHomologyι hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.homologyι_comp_asIsoHomologyι_inv_assoc","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\nhg : Eq S.g 0\ninst✝ : S.HasHomology\nZ : C\nh : Quiver.Hom S.homology Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp S.homologyι (CategoryTheory.CategoryStruct.comp (S.asIsoHomologyι hg).inv h)) h","decl":"@[reassoc (attr := simp)]\nlemma homologyι_comp_asIsoHomologyι_inv (hg : S.g = 0) [S.HasHomology] :\n    S.homologyι ≫ (S.asIsoHomologyι hg).inv  = 𝟙 _ := (S.asIsoHomologyι hg).hom_inv_id\n\n"}
{"name":"CategoryTheory.ShortComplex.mono_homologyMap_of_mono_opcyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nh : CategoryTheory.Mono (CategoryTheory.ShortComplex.opcyclesMap φ)\n⊢ CategoryTheory.Mono (CategoryTheory.ShortComplex.homologyMap φ)","decl":"lemma mono_homologyMap_of_mono_opcyclesMap'\n    [S₁.HasHomology] [S₂.HasHomology] (h : Mono (opcyclesMap φ)) :\n    Mono (homologyMap φ) := by\n  have : Mono (homologyMap φ ≫ S₂.homologyι) := by\n    rw [homologyι_naturality φ]\n    apply mono_comp\n  exact mono_of_mono (homologyMap φ) S₂.homologyι\n\n"}
{"name":"CategoryTheory.ShortComplex.mono_homologyMap_of_mono_opcyclesMap","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : S₁.HasHomology\ninst✝¹ : S₂.HasHomology\ninst✝ : CategoryTheory.Mono (CategoryTheory.ShortComplex.opcyclesMap φ)\n⊢ CategoryTheory.Mono (CategoryTheory.ShortComplex.homologyMap φ)","decl":"instance mono_homologyMap_of_mono_opcyclesMap\n    [S₁.HasHomology] [S₂.HasHomology] [Mono (opcyclesMap φ)] :\n    Mono (homologyMap φ) :=\n  mono_homologyMap_of_mono_opcyclesMap' φ inferInstance\n\n"}
{"name":"CategoryTheory.ShortComplex.epi_homologyMap_of_epi_cyclesMap'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝¹ : S₁.HasHomology\ninst✝ : S₂.HasHomology\nh : CategoryTheory.Epi (CategoryTheory.ShortComplex.cyclesMap φ)\n⊢ CategoryTheory.Epi (CategoryTheory.ShortComplex.homologyMap φ)","decl":"lemma epi_homologyMap_of_epi_cyclesMap'\n    [S₁.HasHomology] [S₂.HasHomology] (h : Epi (cyclesMap φ)) :\n    Epi (homologyMap φ) := by\n  have : Epi (S₁.homologyπ ≫ homologyMap φ) := by\n    rw [homologyπ_naturality φ]\n    apply epi_comp\n  exact epi_of_epi S₁.homologyπ (homologyMap φ)\n\n"}
{"name":"CategoryTheory.ShortComplex.epi_homologyMap_of_epi_cyclesMap","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Limits.HasZeroMorphisms C\nS₁ S₂ : CategoryTheory.ShortComplex C\nφ : Quiver.Hom S₁ S₂\ninst✝² : S₁.HasHomology\ninst✝¹ : S₂.HasHomology\ninst✝ : CategoryTheory.Epi (CategoryTheory.ShortComplex.cyclesMap φ)\n⊢ CategoryTheory.Epi (CategoryTheory.ShortComplex.homologyMap φ)","decl":"instance epi_homologyMap_of_epi_cyclesMap\n    [S₁.HasHomology] [S₂.HasHomology] [Epi (cyclesMap φ)] :\n    Epi (homologyMap φ) :=\n  epi_homologyMap_of_epi_cyclesMap' φ inferInstance\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.canonical_K","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.canonical S).K S.cycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nleft homology data for `S` whose `K` and `H` fields are\nrespectively `S.cycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def LeftHomologyData.canonical [S.HasHomology] : S.LeftHomologyData where\n  K := S.cycles\n  H := S.homology\n  i := S.iCycles\n  π := S.homologyπ\n  wi := by simp\n  hi := S.cyclesIsKernel\n  wπ := S.toCycles_comp_homologyπ\n  hπ := S.homologyIsCokernel\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.canonical_H","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.canonical S).H S.homology","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nleft homology data for `S` whose `K` and `H` fields are\nrespectively `S.cycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def LeftHomologyData.canonical [S.HasHomology] : S.LeftHomologyData where\n  K := S.cycles\n  H := S.homology\n  i := S.iCycles\n  π := S.homologyπ\n  wi := by simp\n  hi := S.cyclesIsKernel\n  wπ := S.toCycles_comp_homologyπ\n  hπ := S.homologyIsCokernel\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.canonical_π","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.canonical S).π S.homologyπ","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nleft homology data for `S` whose `K` and `H` fields are\nrespectively `S.cycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def LeftHomologyData.canonical [S.HasHomology] : S.LeftHomologyData where\n  K := S.cycles\n  H := S.homology\n  i := S.iCycles\n  π := S.homologyπ\n  wi := by simp\n  hi := S.cyclesIsKernel\n  wπ := S.toCycles_comp_homologyπ\n  hπ := S.homologyIsCokernel\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.canonical_i","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.canonical S).i S.iCycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nleft homology data for `S` whose `K` and `H` fields are\nrespectively `S.cycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def LeftHomologyData.canonical [S.HasHomology] : S.LeftHomologyData where\n  K := S.cycles\n  H := S.homology\n  i := S.iCycles\n  π := S.homologyπ\n  wi := by simp\n  hi := S.cyclesIsKernel\n  wπ := S.toCycles_comp_homologyπ\n  hπ := S.homologyIsCokernel\n\n"}
{"name":"CategoryTheory.ShortComplex.LeftHomologyData.canonical_f'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.LeftHomologyData.canonical S).f' S.toCycles","decl":"/-- Computation of the `f'` field of `LeftHomologyData.canonical`. -/\n@[simp]\nlemma LeftHomologyData.canonical_f' [S.HasHomology] :\n    (LeftHomologyData.canonical S).f' = S.toCycles := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.canonical_H","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.canonical S).H S.homology","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nright homology data for `S` whose `Q` and `H` fields are\nrespectively `S.opcycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def RightHomologyData.canonical [S.HasHomology] : S.RightHomologyData where\n  Q := S.opcycles\n  H := S.homology\n  p := S.pOpcycles\n  ι := S.homologyι\n  wp := by simp\n  hp := S.opcyclesIsCokernel\n  wι := S.homologyι_comp_fromOpcycles\n  hι := S.homologyIsKernel\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.canonical_p","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.canonical S).p S.pOpcycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nright homology data for `S` whose `Q` and `H` fields are\nrespectively `S.opcycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def RightHomologyData.canonical [S.HasHomology] : S.RightHomologyData where\n  Q := S.opcycles\n  H := S.homology\n  p := S.pOpcycles\n  ι := S.homologyι\n  wp := by simp\n  hp := S.opcyclesIsCokernel\n  wι := S.homologyι_comp_fromOpcycles\n  hι := S.homologyIsKernel\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.canonical_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.canonical S).ι S.homologyι","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nright homology data for `S` whose `Q` and `H` fields are\nrespectively `S.opcycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def RightHomologyData.canonical [S.HasHomology] : S.RightHomologyData where\n  Q := S.opcycles\n  H := S.homology\n  p := S.pOpcycles\n  ι := S.homologyι\n  wp := by simp\n  hp := S.opcyclesIsCokernel\n  wι := S.homologyι_comp_fromOpcycles\n  hι := S.homologyIsKernel\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.canonical_Q","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.canonical S).Q S.opcycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nright homology data for `S` whose `Q` and `H` fields are\nrespectively `S.opcycles` and `S.homology`. -/\n@[simps!]\nnoncomputable def RightHomologyData.canonical [S.HasHomology] : S.RightHomologyData where\n  Q := S.opcycles\n  H := S.homology\n  p := S.pOpcycles\n  ι := S.homologyι\n  wp := by simp\n  hp := S.opcyclesIsCokernel\n  wι := S.homologyι_comp_fromOpcycles\n  hι := S.homologyIsKernel\n\n"}
{"name":"CategoryTheory.ShortComplex.RightHomologyData.canonical_g'","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.RightHomologyData.canonical S).g' S.fromOpcycles","decl":"/-- Computation of the `g'` field of `RightHomologyData.canonical`. -/\n@[simp]\nlemma RightHomologyData.canonical_g' [S.HasHomology] :\n    (RightHomologyData.canonical S).g' = S.fromOpcycles := rfl\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_iso_hom","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).iso.hom (CategoryTheory.CategoryStruct.id S.homology)","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_right_p","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).right.p S.pOpcycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_right_ι","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).right.ι S.homologyι","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_left_i","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).left.i S.iCycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_right_H","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).right.H S.homology","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_left_H","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).left.H S.homology","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_right_Q","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).right.Q S.opcycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_left_K","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).left.K S.cycles","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_left_π","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).left.π S.homologyπ","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
{"name":"CategoryTheory.ShortComplex.HomologyData.canonical_iso_inv","module":"Mathlib.Algebra.Homology.ShortComplex.Homology","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms C\nS : CategoryTheory.ShortComplex C\ninst✝ : S.HasHomology\n⊢ Eq (CategoryTheory.ShortComplex.HomologyData.canonical S).iso.inv (CategoryTheory.CategoryStruct.id S.homology)","decl":"/-- Given a short complex `S` such that `S.HasHomology`, this is the canonical\nhomology data for `S` whose `left.K`, `left/right.H` and `right.Q` fields are\nrespectively `S.cycles`, `S.homology` and `S.opcycles`. -/\n@[simps!]\nnoncomputable def HomologyData.canonical [S.HasHomology] : S.HomologyData where\n  left := LeftHomologyData.canonical S\n  right := RightHomologyData.canonical S\n  iso := Iso.refl _\n\n"}
