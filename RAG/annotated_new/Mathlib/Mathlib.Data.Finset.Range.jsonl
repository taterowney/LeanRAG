{"name":"Finset.range_val","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Eq (Finset.range n).val (Multiset.range n)","decl":"@[simp]\ntheorem range_val (n : ℕ) : (range n).1 = Multiset.range n :=\n  rfl\n\n"}
{"name":"Finset.mem_range","module":"Mathlib.Data.Finset.Range","initialProofState":"n m : Nat\n⊢ Iff (Membership.mem (Finset.range n) m) (LT.lt m n)","decl":"@[simp]\ntheorem mem_range : m ∈ range n ↔ m < n :=\n  Multiset.mem_range\n\n"}
{"name":"Finset.coe_range","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Eq (↑(Finset.range n)) (Set.Iio n)","decl":"@[simp, norm_cast]\ntheorem coe_range (n : ℕ) : (range n : Set ℕ) = Set.Iio n :=\n  Set.ext fun _ => mem_range\n\n"}
{"name":"Finset.range_zero","module":"Mathlib.Data.Finset.Range","initialProofState":"⊢ Eq (Finset.range 0) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem range_zero : range 0 = ∅ :=\n  rfl\n\n"}
{"name":"Finset.range_one","module":"Mathlib.Data.Finset.Range","initialProofState":"⊢ Eq (Finset.range 1) (Singleton.singleton 0)","decl":"@[simp]\ntheorem range_one : range 1 = {0} :=\n  rfl\n\n"}
{"name":"Finset.range_succ","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Eq (Finset.range n.succ) (Insert.insert n (Finset.range n))","decl":"theorem range_succ : range (succ n) = insert n (range n) :=\n  eq_of_veq <| (Multiset.range_succ n).trans <| (ndinsert_of_not_mem not_mem_range_self).symm\n\n"}
{"name":"Finset.range_add_one","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Eq (Finset.range (HAdd.hAdd n 1)) (Insert.insert n (Finset.range n))","decl":"theorem range_add_one : range (n + 1) = insert n (range n) :=\n  range_succ\n\n"}
{"name":"Finset.not_mem_range_self","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Not (Membership.mem (Finset.range n) n)","decl":"theorem not_mem_range_self : n ∉ range n :=\n  Multiset.not_mem_range_self\n\n"}
{"name":"Finset.self_mem_range_succ","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Membership.mem (Finset.range (HAdd.hAdd n 1)) n","decl":"theorem self_mem_range_succ (n : ℕ) : n ∈ range (n + 1) :=\n  Multiset.self_mem_range_succ n\n\n"}
{"name":"Finset.range_subset","module":"Mathlib.Data.Finset.Range","initialProofState":"n m : Nat\n⊢ Iff (HasSubset.Subset (Finset.range n) (Finset.range m)) (LE.le n m)","decl":"@[simp]\ntheorem range_subset {n m} : range n ⊆ range m ↔ n ≤ m :=\n  Multiset.range_subset\n\n"}
{"name":"Finset.range_mono","module":"Mathlib.Data.Finset.Range","initialProofState":"⊢ Monotone Finset.range","decl":"theorem range_mono : Monotone range := fun _ _ => range_subset.2\n\n"}
{"name":"GCongr.finset_range_subset_of_le","module":"Mathlib.Data.Finset.Range","initialProofState":"n m : Nat\na✝ : LE.le n m\n⊢ HasSubset.Subset (Finset.range n) (Finset.range m)","decl":"@[gcongr] alias ⟨_, _root_.GCongr.finset_range_subset_of_le⟩ := range_subset\n\n"}
{"name":"Finset.mem_range_succ_iff","module":"Mathlib.Data.Finset.Range","initialProofState":"a b : Nat\n⊢ Iff (Membership.mem (Finset.range b.succ) a) (LE.le a b)","decl":"theorem mem_range_succ_iff {a b : ℕ} : a ∈ Finset.range b.succ ↔ a ≤ b :=\n  Finset.mem_range.trans Nat.lt_succ_iff\n\n"}
{"name":"Finset.mem_range_le","module":"Mathlib.Data.Finset.Range","initialProofState":"n x : Nat\nhx : Membership.mem (Finset.range n) x\n⊢ LE.le x n","decl":"theorem mem_range_le {n x : ℕ} (hx : x ∈ range n) : x ≤ n :=\n  (mem_range.1 hx).le\n\n"}
{"name":"Finset.mem_range_sub_ne_zero","module":"Mathlib.Data.Finset.Range","initialProofState":"n x : Nat\nhx : Membership.mem (Finset.range n) x\n⊢ Ne (HSub.hSub n x) 0","decl":"theorem mem_range_sub_ne_zero {n x : ℕ} (hx : x ∈ range n) : n - x ≠ 0 :=\n  _root_.ne_of_gt <| Nat.sub_pos_of_lt <| mem_range.1 hx\n\n"}
{"name":"Finset.nonempty_range_iff","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Iff (Finset.range n).Nonempty (Ne n 0)","decl":"@[simp]\ntheorem nonempty_range_iff : (range n).Nonempty ↔ n ≠ 0 :=\n  ⟨fun ⟨k, hk⟩ => (k.zero_le.trans_lt <| mem_range.1 hk).ne',\n   fun h => ⟨0, mem_range.2 <| Nat.pos_iff_ne_zero.2 h⟩⟩\n\n"}
{"name":"Finset.Aesop.range_nonempty","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\na✝ : Ne n 0\n⊢ (Finset.range n).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\nprotected alias ⟨_, Aesop.range_nonempty⟩ := nonempty_range_iff\n\n"}
{"name":"Finset.range_eq_empty_iff","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ Iff (Eq (Finset.range n) EmptyCollection.emptyCollection) (Eq n 0)","decl":"@[simp]\ntheorem range_eq_empty_iff : range n = ∅ ↔ n = 0 := by\n  rw [← not_nonempty_iff_eq_empty, nonempty_range_iff, not_not]\n\n"}
{"name":"Finset.nonempty_range_succ","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\n⊢ (Finset.range (HAdd.hAdd n 1)).Nonempty","decl":"@[aesop safe apply (rule_sets := [finsetNonempty])]\ntheorem nonempty_range_succ : (range <| n + 1).Nonempty :=\n  nonempty_range_iff.2 n.succ_ne_zero\n\n"}
{"name":"Finset.range_nontrivial","module":"Mathlib.Data.Finset.Range","initialProofState":"n : Nat\nhn : LT.lt 1 n\n⊢ (Finset.range n).Nontrivial","decl":"lemma range_nontrivial {n : ℕ} (hn : 1 < n) : (Finset.range n).Nontrivial := by\n  rw [Finset.Nontrivial, Finset.coe_range]\n  exact ⟨0, Nat.zero_lt_one.trans hn, 1, hn, Nat.zero_ne_one⟩\n\n"}
{"name":"Finset.exists_nat_subset_range","module":"Mathlib.Data.Finset.Range","initialProofState":"s : Finset Nat\n⊢ Exists fun n => HasSubset.Subset s (Finset.range n)","decl":"theorem exists_nat_subset_range (s : Finset ℕ) : ∃ n : ℕ, s ⊆ range n :=\n  s.induction_on (by simp)\n    fun a _ _ ⟨n, hn⟩ => ⟨max (a + 1) n, insert_subset (by simp) (hn.trans (by simp))⟩\n\n"}
{"name":"coe_notMemRangeEquiv","module":"Mathlib.Data.Finset.Range","initialProofState":"k : Nat\n⊢ Eq ⇑(notMemRangeEquiv k) fun i => HSub.hSub (↑i) k","decl":"@[simp]\ntheorem coe_notMemRangeEquiv (k : ℕ) :\n    (notMemRangeEquiv k : { n // n ∉ range k } → ℕ) = fun (i : { n // n ∉ range k }) => i - k :=\n  rfl\n\n"}
{"name":"coe_notMemRangeEquiv_symm","module":"Mathlib.Data.Finset.Range","initialProofState":"k : Nat\n⊢ Eq ⇑(notMemRangeEquiv k).symm fun j => ⟨HAdd.hAdd j k, ⋯⟩","decl":"@[simp]\ntheorem coe_notMemRangeEquiv_symm (k : ℕ) :\n    ((notMemRangeEquiv k).symm : ℕ → { n // n ∉ range k }) = fun j => ⟨j + k, by simp⟩ :=\n  rfl\n"}
