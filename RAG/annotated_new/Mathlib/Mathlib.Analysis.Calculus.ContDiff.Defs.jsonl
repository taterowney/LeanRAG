{"name":"HasFTaylorSeriesUpToOn.analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\np : E → FormalMultilinearSeries 𝕜 E F\nhf : HasFTaylorSeriesUpToOn Top.top f p s\nh : AnalyticOn 𝕜 (fun x => p x 0) s\n⊢ AnalyticOn 𝕜 f s","decl":"lemma HasFTaylorSeriesUpToOn.analyticOn\n    (hf : HasFTaylorSeriesUpToOn ω f p s) (h : AnalyticOn 𝕜 (fun x ↦ p x 0) s) :\n    AnalyticOn 𝕜 f s := by\n  have : AnalyticOn 𝕜 (fun x ↦ (continuousMultilinearCurryFin0 𝕜 E F) (p x 0)) s :=\n    (LinearIsometryEquiv.analyticOnNhd _ _ ).comp_analyticOn\n      h (Set.mapsTo_univ _ _)\n  exact this.congr (fun y hy ↦ (hf.zero_eq _ hy).symm)\n\n"}
{"name":"ContDiffWithinAt.analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nh : ContDiffWithinAt 𝕜 Top.top f s x\n⊢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (AnalyticOn 𝕜 f u)","decl":"lemma ContDiffWithinAt.analyticOn (h : ContDiffWithinAt 𝕜 ω f s x) :\n    ∃ u ∈ 𝓝[insert x s] x, AnalyticOn 𝕜 f u := by\n  obtain ⟨u, hu, p, hp, h'p⟩ := h\n  exact ⟨u, hu, hp.analyticOn (h'p 0)⟩\n\n"}
{"name":"ContDiffWithinAt.analyticWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nh : ContDiffWithinAt 𝕜 Top.top f s x\n⊢ AnalyticWithinAt 𝕜 f s x","decl":"lemma ContDiffWithinAt.analyticWithinAt (h : ContDiffWithinAt 𝕜 ω f s x) :\n    AnalyticWithinAt 𝕜 f s x := by\n  obtain ⟨u, hu, hf⟩ := h.analyticOn\n  have xu : x ∈ u := mem_of_mem_nhdsWithin (by simp) hu\n  exact (hf x xu).mono_of_mem_nhdsWithin (nhdsWithin_mono _ (subset_insert _ _) hu)\n\n"}
{"name":"contDiffWithinAt_omega_iff_analyticWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\ninst✝ : CompleteSpace F\n⊢ Iff (ContDiffWithinAt 𝕜 Top.top f s x) (AnalyticWithinAt 𝕜 f s x)","decl":"theorem contDiffWithinAt_omega_iff_analyticWithinAt [CompleteSpace F] :\n    ContDiffWithinAt 𝕜 ω f s x ↔ AnalyticWithinAt 𝕜 f s x := by\n  refine ⟨fun h ↦ h.analyticWithinAt, fun h ↦ ?_⟩\n  obtain ⟨u, hu, p, hp, h'p⟩ := h.exists_hasFTaylorSeriesUpToOn ω\n  exact ⟨u, hu, p, hp.of_le le_top, fun i ↦ h'p i⟩\n\n"}
{"name":"contDiffWithinAt_nat","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : Nat\n⊢ Iff (ContDiffWithinAt 𝕜 (↑n) f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (Exists fun p => HasFTaylorSeriesUpToOn (↑n) f p u))","decl":"theorem contDiffWithinAt_nat {n : ℕ} :\n    ContDiffWithinAt 𝕜 n f s x ↔ ∃ u ∈ 𝓝[insert x s] x,\n      ∃ p : E → FormalMultilinearSeries 𝕜 E F, HasFTaylorSeriesUpToOn n f p u :=\n  ⟨fun H => H n le_rfl, fun ⟨u, hu, p, hp⟩ _m hm => ⟨u, hu, p, hp.of_le (mod_cast hm)⟩⟩\n\n"}
{"name":"contDiffWithinAt_iff_of_ne_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Iff (ContDiffWithinAt 𝕜 n f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (Exists fun p => And (HasFTaylorSeriesUpToOn n f p u) (Eq n Top.top → ∀ (i : Nat), AnalyticOn 𝕜 (fun x => p x i) u)))","decl":"/-- When `n` is either a natural number or `ω`, one can characterize the property of being `C^n`\nas the existence of a neighborhood on which there is a Taylor series up to order `n`,\nrequiring in addition that its terms are analytic in the `ω` case. -/\nlemma contDiffWithinAt_iff_of_ne_infty (hn : n ≠ ∞) :\n    ContDiffWithinAt 𝕜 n f s x ↔ ∃ u ∈ 𝓝[insert x s] x,\n      ∃ p : E → FormalMultilinearSeries 𝕜 E F, HasFTaylorSeriesUpToOn n f p u ∧\n        (n = ω → ∀ i, AnalyticOn 𝕜 (fun x ↦ p x i) u) := by\n  match n with\n  | ω => simp [ContDiffWithinAt]\n  | ∞ => simp at hn\n  | (n : ℕ) => simp [contDiffWithinAt_nat]\n\n"}
{"name":"ContDiffWithinAt.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nm n : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nhmn : LE.le m n\n⊢ ContDiffWithinAt 𝕜 m f s x","decl":"theorem ContDiffWithinAt.of_le (h : ContDiffWithinAt 𝕜 n f s x) (hmn : m ≤ n) :\n    ContDiffWithinAt 𝕜 m f s x := by\n  match n with\n  | ω => match m with\n    | ω => exact h\n    | (m : ℕ∞) =>\n      intro k _\n      obtain ⟨u, hu, p, hp, -⟩ := h\n      exact ⟨u, hu, p, hp.of_le le_top⟩\n  | (n : ℕ∞) => match m with\n    | ω => simp at hmn\n    | (m : ℕ∞) => exact fun k hk ↦ h k (le_trans hk (mod_cast hmn))\n\n"}
{"name":"AnalyticWithinAt.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ninst✝ : CompleteSpace F\nh : AnalyticWithinAt 𝕜 f s x\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"/-- In a complete space, a function which is analytic within a set at a point is also `C^ω` there.\nNote that the same statement for `AnalyticOn` does not require completeness, see\n`AnalyticOn.contDiffOn`. -/\ntheorem AnalyticWithinAt.contDiffWithinAt [CompleteSpace F] (h : AnalyticWithinAt 𝕜 f s x) :\n    ContDiffWithinAt 𝕜 n f s x :=\n  (contDiffWithinAt_omega_iff_analyticWithinAt.2 h).of_le le_top\n\n"}
{"name":"contDiffWithinAt_iff_forall_nat_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : ENat\n⊢ Iff (ContDiffWithinAt 𝕜 (↑n) f s x) (∀ (m : Nat), LE.le (↑m) n → ContDiffWithinAt 𝕜 (↑m) f s x)","decl":"theorem contDiffWithinAt_iff_forall_nat_le {n : ℕ∞} :\n    ContDiffWithinAt 𝕜 n f s x ↔ ∀ m : ℕ, ↑m ≤ n → ContDiffWithinAt 𝕜 m f s x :=\n  ⟨fun H _ hm => H.of_le (mod_cast hm), fun H m hm => H m hm _ le_rfl⟩\n\n"}
{"name":"contDiffWithinAt_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\n⊢ Iff (ContDiffWithinAt 𝕜 (↑Top.top) f s x) (∀ (n : Nat), ContDiffWithinAt 𝕜 (↑n) f s x)","decl":"theorem contDiffWithinAt_infty :\n    ContDiffWithinAt 𝕜 ∞ f s x ↔ ∀ n : ℕ, ContDiffWithinAt 𝕜 n f s x :=\n  contDiffWithinAt_iff_forall_nat_le.trans <| by simp only [forall_prop_of_true, le_top]\n\n"}
{"name":"contDiffWithinAt_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\n⊢ Iff (ContDiffWithinAt 𝕜 (↑Top.top) f s x) (∀ (n : Nat), ContDiffWithinAt 𝕜 (↑n) f s x)","decl":"@[deprecated (since := \"2024-11-25\")] alias contDiffWithinAt_top := contDiffWithinAt_infty\n\n"}
{"name":"ContDiffWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\n⊢ ContinuousWithinAt f s x","decl":"theorem ContDiffWithinAt.continuousWithinAt (h : ContDiffWithinAt 𝕜 n f s x) :\n    ContinuousWithinAt f s x := by\n  have := h.of_le (zero_le _)\n  simp only [ContDiffWithinAt, nonpos_iff_eq_zero, Nat.cast_eq_zero,\n    mem_pure, forall_eq, CharP.cast_eq_zero] at this\n  rcases this with ⟨u, hu, p, H⟩\n  rw [mem_nhdsWithin_insert] at hu\n  exact (H.continuousOn.continuousWithinAt hu.1).mono_of_mem_nhdsWithin hu.2\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"theorem ContDiffWithinAt.congr_of_eventuallyEq (h : ContDiffWithinAt 𝕜 n f s x)\n    (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) : ContDiffWithinAt 𝕜 n f₁ s x := by\n  match n with\n  | ω =>\n    obtain ⟨u, hu, p, H, H'⟩ := h\n    exact ⟨{x ∈ u | f₁ x = f x}, Filter.inter_mem hu (mem_nhdsWithin_insert.2 ⟨hx, h₁⟩), p,\n      (H.mono (sep_subset _ _)).congr fun _ ↦ And.right,\n      fun i ↦ (H' i).mono (sep_subset _ _)⟩\n  | (n : ℕ∞) =>\n    intro m hm\n    let ⟨u, hu, p, H⟩ := h m hm\n    exact ⟨{ x ∈ u | f₁ x = f x }, Filter.inter_mem hu (mem_nhdsWithin_insert.2 ⟨hx, h₁⟩), p,\n      (H.mono (sep_subset _ _)).congr fun _ ↦ And.right⟩\n\n"}
{"name":"Filter.EventuallyEq.congr_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem Filter.EventuallyEq.congr_contDiffWithinAt (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : f₁ x = f x) :\n    ContDiffWithinAt 𝕜 n f₁ s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  ⟨fun H ↦ H.congr_of_eventuallyEq h₁.symm hx.symm, fun H ↦ H.congr_of_eventuallyEq h₁ hx⟩\n\n"}
{"name":"Filter.EventuallyEq.contDiffWithinAt_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Eq (f₁ x) (f x)\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias Filter.EventuallyEq.contDiffWithinAt_iff := Filter.EventuallyEq.congr_contDiffWithinAt\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventuallyEq_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : (nhdsWithin x (Insert.insert x s)).EventuallyEq f₁ f\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"theorem ContDiffWithinAt.congr_of_eventuallyEq_insert (h : ContDiffWithinAt 𝕜 n f s x)\n    (h₁ : f₁ =ᶠ[𝓝[insert x s] x] f) : ContDiffWithinAt 𝕜 n f₁ s x :=\n  h.congr_of_eventuallyEq (nhdsWithin_mono x (subset_insert x s) h₁)\n    (mem_of_mem_nhdsWithin (mem_insert x s) h₁ :)\n\n"}
{"name":"Filter.EventuallyEq.congr_contDiffWithinAt_of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : (nhdsWithin x (Insert.insert x s)).EventuallyEq f₁ f\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem Filter.EventuallyEq.congr_contDiffWithinAt_of_insert (h₁ : f₁ =ᶠ[𝓝[insert x s] x] f) :\n    ContDiffWithinAt 𝕜 n f₁ s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  ⟨fun H ↦ H.congr_of_eventuallyEq_insert h₁.symm, fun H ↦ H.congr_of_eventuallyEq_insert h₁⟩\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventuallyEq_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Membership.mem s x\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"theorem ContDiffWithinAt.congr_of_eventuallyEq_of_mem (h : ContDiffWithinAt 𝕜 n f s x)\n    (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : x ∈ s) : ContDiffWithinAt 𝕜 n f₁ s x :=\n  h.congr_of_eventuallyEq h₁ <| h₁.self_of_nhdsWithin hx\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventually_eq'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Membership.mem s x\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.congr_of_eventually_eq' := ContDiffWithinAt.congr_of_eventuallyEq_of_mem\n\n"}
{"name":"Filter.EventuallyEq.congr_contDiffWithinAt_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : (nhdsWithin x s).EventuallyEq f₁ f\nhx : Membership.mem s x\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem Filter.EventuallyEq.congr_contDiffWithinAt_of_mem (h₁ : f₁ =ᶠ[𝓝[s] x] f) (hx : x ∈ s):\n    ContDiffWithinAt 𝕜 n f₁ s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  ⟨fun H ↦ H.congr_of_eventuallyEq_of_mem h₁.symm hx, fun H ↦ H.congr_of_eventuallyEq_of_mem h₁ hx⟩\n\n"}
{"name":"ContDiffWithinAt.congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : ∀ (y : E), Membership.mem s y → Eq (f₁ y) (f y)\nhx : Eq (f₁ x) (f x)\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"theorem ContDiffWithinAt.congr (h : ContDiffWithinAt 𝕜 n f s x) (h₁ : ∀ y ∈ s, f₁ y = f y)\n    (hx : f₁ x = f x) : ContDiffWithinAt 𝕜 n f₁ s x :=\n  h.congr_of_eventuallyEq (Filter.eventuallyEq_of_mem self_mem_nhdsWithin h₁) hx\n\n"}
{"name":"contDiffWithinAt_congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : ∀ (y : E), Membership.mem s y → Eq (f₁ y) (f y)\nhx : Eq (f₁ x) (f x)\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_congr (h₁ : ∀ y ∈ s, f₁ y = f y) (hx : f₁ x = f x) :\n    ContDiffWithinAt 𝕜 n f₁ s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  ⟨fun h' ↦ h'.congr (fun x hx ↦ (h₁ x hx).symm) hx.symm, fun h' ↦  h'.congr h₁ hx⟩\n\n"}
{"name":"ContDiffWithinAt.congr_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : ∀ (y : E), Membership.mem s y → Eq (f₁ y) (f y)\nhx : Membership.mem s x\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"theorem ContDiffWithinAt.congr_of_mem (h : ContDiffWithinAt 𝕜 n f s x) (h₁ : ∀ y ∈ s, f₁ y = f y)\n    (hx : x ∈ s) : ContDiffWithinAt 𝕜 n f₁ s x :=\n  h.congr h₁ (h₁ _ hx)\n\n"}
{"name":"ContDiffWithinAt.congr'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : ∀ (y : E), Membership.mem s y → Eq (f₁ y) (f y)\nhx : Membership.mem s x\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.congr' := ContDiffWithinAt.congr_of_mem\n\n"}
{"name":"contDiffWithinAt_congr_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : ∀ (y : E), Membership.mem s y → Eq (f₁ y) (f y)\nhx : Membership.mem s x\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_congr_of_mem (h₁ : ∀ y ∈ s, f₁ y = f y) (hx : x ∈ s) :\n    ContDiffWithinAt 𝕜 n f₁ s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  contDiffWithinAt_congr h₁ (h₁ x hx)\n\n"}
{"name":"ContDiffWithinAt.congr_of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh₁ : ∀ (y : E), Membership.mem (Insert.insert x s) y → Eq (f₁ y) (f y)\n⊢ ContDiffWithinAt 𝕜 n f₁ s x","decl":"theorem ContDiffWithinAt.congr_of_insert (h : ContDiffWithinAt 𝕜 n f s x)\n    (h₁ : ∀ y ∈ insert x s, f₁ y = f y) : ContDiffWithinAt 𝕜 n f₁ s x :=\n  h.congr (fun y hy ↦ h₁ y (mem_insert_of_mem _ hy)) (h₁ x (mem_insert _ _))\n\n"}
{"name":"contDiffWithinAt_congr_of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh₁ : ∀ (y : E), Membership.mem (Insert.insert x s) y → Eq (f₁ y) (f y)\n⊢ Iff (ContDiffWithinAt 𝕜 n f₁ s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_congr_of_insert (h₁ : ∀ y ∈ insert x s, f₁ y = f y) :\n    ContDiffWithinAt 𝕜 n f₁ s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  contDiffWithinAt_congr (fun y hy ↦ h₁ y (mem_insert_of_mem _ hy)) (h₁ x (mem_insert _ _))\n\n"}
{"name":"ContDiffWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\n⊢ ContDiffWithinAt 𝕜 n f t x","decl":"theorem ContDiffWithinAt.mono_of_mem_nhdsWithin (h : ContDiffWithinAt 𝕜 n f s x) {t : Set E}\n    (hst : s ∈ 𝓝[t] x) : ContDiffWithinAt 𝕜 n f t x := by\n  match n with\n  | ω =>\n    obtain ⟨u, hu, p, H, H'⟩ := h\n    exact ⟨u, nhdsWithin_le_of_mem (insert_mem_nhdsWithin_insert hst) hu, p, H, H'⟩\n  | (n : ℕ∞) =>\n    intro m hm\n    rcases h m hm with ⟨u, hu, p, H⟩\n    exact ⟨u, nhdsWithin_le_of_mem (insert_mem_nhdsWithin_insert hst) hu, p, H⟩\n\n"}
{"name":"ContDiffWithinAt.mono_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\n⊢ ContDiffWithinAt 𝕜 n f t x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiffWithinAt.mono_of_mem := ContDiffWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"ContDiffWithinAt.mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nt : Set E\nhst : HasSubset.Subset t s\n⊢ ContDiffWithinAt 𝕜 n f t x","decl":"theorem ContDiffWithinAt.mono (h : ContDiffWithinAt 𝕜 n f s x) {t : Set E} (hst : t ⊆ s) :\n    ContDiffWithinAt 𝕜 n f t x :=\n  h.mono_of_mem_nhdsWithin <| Filter.mem_of_superset self_mem_nhdsWithin hst\n\n"}
{"name":"ContDiffWithinAt.congr_mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns s₁ : Set E\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nh' : Set.EqOn f₁ f s₁\nh₁ : HasSubset.Subset s₁ s\nhx : Eq (f₁ x) (f x)\n⊢ ContDiffWithinAt 𝕜 n f₁ s₁ x","decl":"theorem ContDiffWithinAt.congr_mono\n    (h : ContDiffWithinAt 𝕜 n f s x) (h' : EqOn f₁ f s₁) (h₁ : s₁ ⊆ s) (hx : f₁ x = f x) :\n    ContDiffWithinAt 𝕜 n f₁ s₁ x :=\n  (h.mono h₁).congr h' hx\n\n"}
{"name":"ContDiffWithinAt.congr_set","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nt : Set E\nhst : (nhds x).EventuallyEq s t\n⊢ ContDiffWithinAt 𝕜 n f t x","decl":"theorem ContDiffWithinAt.congr_set (h : ContDiffWithinAt 𝕜 n f s x) {t : Set E}\n    (hst : s =ᶠ[𝓝 x] t) : ContDiffWithinAt 𝕜 n f t x := by\n  rw [← nhdsWithin_eq_iff_eventuallyEq] at hst\n  apply h.mono_of_mem_nhdsWithin <| hst ▸ self_mem_nhdsWithin\n\n"}
{"name":"ContDiffWithinAt.congr_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nt : Set E\nhst : (nhds x).EventuallyEq s t\n⊢ ContDiffWithinAt 𝕜 n f t x","decl":"@[deprecated (since := \"2024-10-23\")]\nalias ContDiffWithinAt.congr_nhds := ContDiffWithinAt.congr_set\n\n"}
{"name":"contDiffWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nt : Set E\nhst : (nhds x).EventuallyEq s t\n⊢ Iff (ContDiffWithinAt 𝕜 n f s x) (ContDiffWithinAt 𝕜 n f t x)","decl":"theorem contDiffWithinAt_congr_set {t : Set E} (hst : s =ᶠ[𝓝 x] t) :\n    ContDiffWithinAt 𝕜 n f s x ↔ ContDiffWithinAt 𝕜 n f t x :=\n  ⟨fun h => h.congr_set hst, fun h => h.congr_set hst.symm⟩\n\n"}
{"name":"contDiffWithinAt_congr_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nt : Set E\nhst : (nhds x).EventuallyEq s t\n⊢ Iff (ContDiffWithinAt 𝕜 n f s x) (ContDiffWithinAt 𝕜 n f t x)","decl":"@[deprecated (since := \"2024-10-23\")]\nalias contDiffWithinAt_congr_nhds := contDiffWithinAt_congr_set\n\n"}
{"name":"contDiffWithinAt_inter'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : Membership.mem (nhdsWithin x s) t\n⊢ Iff (ContDiffWithinAt 𝕜 n f (Inter.inter s t) x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_inter' (h : t ∈ 𝓝[s] x) :\n    ContDiffWithinAt 𝕜 n f (s ∩ t) x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  contDiffWithinAt_congr_set (mem_nhdsWithin_iff_eventuallyEq.1 h).symm\n\n"}
{"name":"contDiffWithinAt_inter","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : Membership.mem (nhds x) t\n⊢ Iff (ContDiffWithinAt 𝕜 n f (Inter.inter s t) x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_inter (h : t ∈ 𝓝 x) :\n    ContDiffWithinAt 𝕜 n f (s ∩ t) x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  contDiffWithinAt_inter' (mem_nhdsWithin_of_mem_nhds h)\n\n"}
{"name":"contDiffWithinAt_insert_self","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\n⊢ Iff (ContDiffWithinAt 𝕜 n f (Insert.insert x s) x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_insert_self :\n    ContDiffWithinAt 𝕜 n f (insert x s) x ↔ ContDiffWithinAt 𝕜 n f s x := by\n  match n with\n  | ω => simp [ContDiffWithinAt]\n  | (n : ℕ∞) => simp_rw [ContDiffWithinAt, insert_idem]\n\n"}
{"name":"contDiffWithinAt_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ny : E\n⊢ Iff (ContDiffWithinAt 𝕜 n f (Insert.insert y s) x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_insert {y : E} :\n    ContDiffWithinAt 𝕜 n f (insert y s) x ↔ ContDiffWithinAt 𝕜 n f s x := by\n  rcases eq_or_ne x y with (rfl | hx)\n  · exact contDiffWithinAt_insert_self\n  refine ⟨fun h ↦ h.mono (subset_insert _ _), fun h ↦ ?_⟩\n  apply h.mono_of_mem_nhdsWithin\n  simp [nhdsWithin_insert_of_ne hx, self_mem_nhdsWithin]\n\n"}
{"name":"ContDiffWithinAt.insert'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ny : E\na✝ : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n f (Insert.insert y s) x","decl":"alias ⟨ContDiffWithinAt.of_insert, ContDiffWithinAt.insert'⟩ := contDiffWithinAt_insert\n\n"}
{"name":"ContDiffWithinAt.of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ny : E\na✝ : ContDiffWithinAt 𝕜 n f (Insert.insert y s) x\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"alias ⟨ContDiffWithinAt.of_insert, ContDiffWithinAt.insert'⟩ := contDiffWithinAt_insert\n\n"}
{"name":"ContDiffWithinAt.insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n f (Insert.insert x s) x","decl":"protected theorem ContDiffWithinAt.insert (h : ContDiffWithinAt 𝕜 n f s x) :\n    ContDiffWithinAt 𝕜 n f (insert x s) x :=\n  h.insert'\n\n"}
{"name":"contDiffWithinAt_diff_singleton","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ny : E\n⊢ Iff (ContDiffWithinAt 𝕜 n f (SDiff.sdiff s (Singleton.singleton y)) x) (ContDiffWithinAt 𝕜 n f s x)","decl":"theorem contDiffWithinAt_diff_singleton {y : E} :\n    ContDiffWithinAt 𝕜 n f (s \\ {y}) x ↔ ContDiffWithinAt 𝕜 n f s x := by\n  rw [← contDiffWithinAt_insert, insert_diff_singleton, contDiffWithinAt_insert]\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nhn : LE.le 1 n\n⊢ DifferentiableWithinAt 𝕜 f (Insert.insert x s) x","decl":"/-- If a function is `C^n` within a set at a point, with `n ≥ 1`, then it is differentiable\nwithin this set at this point. -/\ntheorem ContDiffWithinAt.differentiableWithinAt' (h : ContDiffWithinAt 𝕜 n f s x) (hn : 1 ≤ n) :\n    DifferentiableWithinAt 𝕜 f (insert x s) x := by\n  rcases contDiffWithinAt_nat.1 (h.of_le hn) with ⟨u, hu, p, H⟩\n  rcases mem_nhdsWithin.1 hu with ⟨t, t_open, xt, tu⟩\n  rw [inter_comm] at tu\n  exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 <|\n    ((H.mono tu).differentiableOn le_rfl) x ⟨mem_insert x s, xt⟩\n\n"}
{"name":"ContDiffWithinAt.differentiable_within_at'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nhn : LE.le 1 n\n⊢ DifferentiableWithinAt 𝕜 f (Insert.insert x s) x","decl":"@[deprecated (since := \"2024-10-10\")]\nalias ContDiffWithinAt.differentiable_within_at' := ContDiffWithinAt.differentiableWithinAt'\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nhn : LE.le 1 n\n⊢ DifferentiableWithinAt 𝕜 f s x","decl":"theorem ContDiffWithinAt.differentiableWithinAt (h : ContDiffWithinAt 𝕜 n f s x) (hn : 1 ≤ n) :\n    DifferentiableWithinAt 𝕜 f s x :=\n  (h.differentiableWithinAt' hn).mono (subset_insert x s)\n\n"}
{"name":"contDiffWithinAt_succ_iff_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Iff (ContDiffWithinAt 𝕜 (HAdd.hAdd n 1) f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (Eq n Top.top → AnalyticOn 𝕜 f u) (Exists fun f' => And (∀ (x : E), Membership.mem u x → HasFDerivWithinAt f (f' x) u x) (ContDiffWithinAt 𝕜 n f' u x))))","decl":"/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`\n(and moreover the function is analytic when `n = ω`). -/\ntheorem contDiffWithinAt_succ_iff_hasFDerivWithinAt (hn : n ≠ ∞) :\n    ContDiffWithinAt 𝕜 (n + 1) f s x ↔ ∃ u ∈ 𝓝[insert x s] x, (n = ω → AnalyticOn 𝕜 f u) ∧\n      ∃ f' : E → E →L[𝕜] F,\n      (∀ x ∈ u, HasFDerivWithinAt f (f' x) u x) ∧ ContDiffWithinAt 𝕜 n f' u x := by\n  have h'n : n + 1 ≠ ∞ := by simpa using hn\n  constructor\n  · intro h\n    rcases (contDiffWithinAt_iff_of_ne_infty h'n).1 h with ⟨u, hu, p, Hp, H'p⟩\n    refine ⟨u, hu, ?_, fun y => (continuousMultilinearCurryFin1 𝕜 E F) (p y 1),\n        fun y hy => Hp.hasFDerivWithinAt le_add_self hy, ?_⟩\n    · rintro rfl\n      exact Hp.analyticOn (H'p rfl 0)\n    apply (contDiffWithinAt_iff_of_ne_infty hn).2\n    refine ⟨u, ?_, fun y : E => (p y).shift, ?_⟩\n    · -- Porting note: without the explicit argument Lean is not sure of the type.\n      convert @self_mem_nhdsWithin _ _ x u\n      have : x ∈ insert x s := by simp\n      exact insert_eq_of_mem (mem_of_mem_nhdsWithin this hu)\n    · rw [hasFTaylorSeriesUpToOn_succ_iff_right] at Hp\n      refine ⟨Hp.2.2, ?_⟩\n      rintro rfl i\n      change AnalyticOn 𝕜\n        (fun x ↦ (continuousMultilinearCurryRightEquiv' 𝕜 i E F) (p x (i + 1))) u\n      apply (LinearIsometryEquiv.analyticOnNhd _ _).comp_analyticOn\n        ?_ (Set.mapsTo_univ _ _)\n      exact H'p rfl _\n  · rintro ⟨u, hu, hf, f', f'_eq_deriv, Hf'⟩\n    rw [contDiffWithinAt_iff_of_ne_infty h'n]\n    rcases (contDiffWithinAt_iff_of_ne_infty hn).1 Hf' with ⟨v, hv, p', Hp', p'_an⟩\n    refine ⟨v ∩ u, ?_, fun x => (p' x).unshift (f x), ?_, ?_⟩\n    · apply Filter.inter_mem _ hu\n      apply nhdsWithin_le_of_mem hu\n      exact nhdsWithin_mono _ (subset_insert x u) hv\n    · rw [hasFTaylorSeriesUpToOn_succ_iff_right]\n      refine ⟨fun y _ => rfl, fun y hy => ?_, ?_⟩\n      · change\n          HasFDerivWithinAt (fun z => (continuousMultilinearCurryFin0 𝕜 E F).symm (f z))\n            (FormalMultilinearSeries.unshift (p' y) (f y) 1).curryLeft (v ∩ u) y\n        -- Porting note: needed `erw` here.\n        -- https://github.com/leanprover-community/mathlib4/issues/5164\n        erw [LinearIsometryEquiv.comp_hasFDerivWithinAt_iff']\n        convert (f'_eq_deriv y hy.2).mono inter_subset_right\n        rw [← Hp'.zero_eq y hy.1]\n        ext z\n        change ((p' y 0) (init (@cons 0 (fun _ => E) z 0))) (@cons 0 (fun _ => E) z 0 (last 0)) =\n          ((p' y 0) 0) z\n        congr\n        norm_num [eq_iff_true_of_subsingleton]\n      · convert (Hp'.mono inter_subset_left).congr fun x hx => Hp'.zero_eq x hx.1 using 1\n        · ext x y\n          change p' x 0 (init (@snoc 0 (fun _ : Fin 1 => E) 0 y)) y = p' x 0 0 y\n          rw [init_snoc]\n        · ext x k v y\n          change p' x k (init (@snoc k (fun _ : Fin k.succ => E) v y))\n            (@snoc k (fun _ : Fin k.succ => E) v y (last k)) = p' x k v y\n          rw [snoc_last, init_snoc]\n    · intro h i\n      simp only [WithTop.add_eq_top, WithTop.one_ne_top, or_false] at h\n      match i with\n      | 0 =>\n        simp only [FormalMultilinearSeries.unshift]\n        apply AnalyticOnNhd.comp_analyticOn _ ((hf h).mono inter_subset_right)\n          (Set.mapsTo_univ _ _)\n        exact LinearIsometryEquiv.analyticOnNhd _ _\n      | i + 1 =>\n        simp only [FormalMultilinearSeries.unshift, Nat.succ_eq_add_one]\n        apply AnalyticOnNhd.comp_analyticOn _ ((p'_an h i).mono inter_subset_left)\n          (Set.mapsTo_univ _ _)\n        exact LinearIsometryEquiv.analyticOnNhd _ _\n\n"}
{"name":"contDiffWithinAt_succ_iff_hasFDerivWithinAt'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Iff (ContDiffWithinAt 𝕜 (HAdd.hAdd n 1) f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (HasSubset.Subset u (Insert.insert x s)) (And (Eq n Top.top → AnalyticOn 𝕜 f u) (Exists fun f' => And (∀ (x : E), Membership.mem u x → HasFDerivWithinAt f (f' x) s x) (ContDiffWithinAt 𝕜 n f' s x)))))","decl":"/-- A version of `contDiffWithinAt_succ_iff_hasFDerivWithinAt` where all derivatives\n  are taken within the same set. -/\ntheorem contDiffWithinAt_succ_iff_hasFDerivWithinAt' (hn : n ≠ ∞) :\n    ContDiffWithinAt 𝕜 (n + 1) f s x ↔\n      ∃ u ∈ 𝓝[insert x s] x, u ⊆ insert x s ∧ (n = ω → AnalyticOn 𝕜 f u) ∧\n      ∃ f' : E → E →L[𝕜] F,\n        (∀ x ∈ u, HasFDerivWithinAt f (f' x) s x) ∧ ContDiffWithinAt 𝕜 n f' s x := by\n  refine ⟨fun hf => ?_, ?_⟩\n  · obtain ⟨u, hu, f_an, f', huf', hf'⟩ := (contDiffWithinAt_succ_iff_hasFDerivWithinAt hn).mp hf\n    obtain ⟨w, hw, hxw, hwu⟩ := mem_nhdsWithin.mp hu\n    rw [inter_comm] at hwu\n    refine ⟨insert x s ∩ w, inter_mem_nhdsWithin _ (hw.mem_nhds hxw), inter_subset_left, ?_, f',\n      fun y hy => ?_, ?_⟩\n    · intro h\n      apply (f_an h).mono hwu\n    · refine ((huf' y <| hwu hy).mono hwu).mono_of_mem_nhdsWithin ?_\n      refine mem_of_superset ?_ (inter_subset_inter_left _ (subset_insert _ _))\n      exact inter_mem_nhdsWithin _ (hw.mem_nhds hy.2)\n    · exact hf'.mono_of_mem_nhdsWithin (nhdsWithin_mono _ (subset_insert _ _) hu)\n  · rw [← contDiffWithinAt_insert, contDiffWithinAt_succ_iff_hasFDerivWithinAt hn,\n      insert_eq_of_mem (mem_insert _ _)]\n    rintro ⟨u, hu, hus, f_an, f', huf', hf'⟩\n    exact ⟨u, hu, f_an, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono hus⟩\n\n\n"}
{"name":"HasFTaylorSeriesUpToOn.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : ENat\nf' : E → FormalMultilinearSeries 𝕜 E F\nhf : HasFTaylorSeriesUpToOn (↑n) f f' s\n⊢ ContDiffOn 𝕜 (↑n) f s","decl":"theorem HasFTaylorSeriesUpToOn.contDiffOn {n : ℕ∞} {f' : E → FormalMultilinearSeries 𝕜 E F}\n    (hf : HasFTaylorSeriesUpToOn n f f' s) : ContDiffOn 𝕜 n f s := by\n  intro x hx m hm\n  use s\n  simp only [Set.insert_eq_of_mem hx, self_mem_nhdsWithin, true_and]\n  exact ⟨f', hf.of_le (mod_cast hm)⟩\n\n"}
{"name":"ContDiffOn.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhx : Membership.mem s x\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"theorem ContDiffOn.contDiffWithinAt (h : ContDiffOn 𝕜 n f s) (hx : x ∈ s) :\n    ContDiffWithinAt 𝕜 n f s x :=\n  h x hx\n\n"}
{"name":"ContDiffOn.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nm n : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhmn : LE.le m n\n⊢ ContDiffOn 𝕜 m f s","decl":"theorem ContDiffOn.of_le (h : ContDiffOn 𝕜 n f s) (hmn : m ≤ n) : ContDiffOn 𝕜 m f s := fun x hx =>\n  (h x hx).of_le hmn\n\n"}
{"name":"ContDiffWithinAt.contDiffOn'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nm n : WithTop ENat\nhm : LE.le m n\nh' : Eq m ↑Top.top → Eq n Top.top\nh : ContDiffWithinAt 𝕜 n f s x\n⊢ Exists fun u => And (IsOpen u) (And (Membership.mem u x) (ContDiffOn 𝕜 m f (Inter.inter (Insert.insert x s) u)))","decl":"theorem ContDiffWithinAt.contDiffOn' (hm : m ≤ n) (h' : m = ∞ → n = ω)\n    (h : ContDiffWithinAt 𝕜 n f s x) :\n    ∃ u, IsOpen u ∧ x ∈ u ∧ ContDiffOn 𝕜 m f (insert x s ∩ u) := by\n  rcases eq_or_ne n ω with rfl | hn\n  · obtain ⟨t, ht, p, hp, h'p⟩ := h\n    rcases mem_nhdsWithin.1 ht with ⟨u, huo, hxu, hut⟩\n    rw [inter_comm] at hut\n    refine ⟨u, huo, hxu, ?_⟩\n    suffices ContDiffOn 𝕜 ω f (insert x s ∩ u) from this.of_le le_top\n    intro y hy\n    refine ⟨insert x s ∩ u, ?_, p, hp.mono hut,  fun i ↦ (h'p i).mono hut⟩\n    simp only [insert_eq_of_mem, hy, self_mem_nhdsWithin]\n  · match m with\n    | ω => simp [hn] at hm\n    | ∞ => exact (hn (h' rfl)).elim\n    | (m : ℕ) =>\n      rcases contDiffWithinAt_nat.1 (h.of_le hm) with ⟨t, ht, p, hp⟩\n      rcases mem_nhdsWithin.1 ht with ⟨u, huo, hxu, hut⟩\n      rw [inter_comm] at hut\n      exact ⟨u, huo, hxu, (hp.mono hut).contDiffOn⟩\n\n"}
{"name":"ContDiffWithinAt.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nm n : WithTop ENat\nhm : LE.le m n\nh' : Eq m ↑Top.top → Eq n Top.top\nh : ContDiffWithinAt 𝕜 n f s x\n⊢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (HasSubset.Subset u (Insert.insert x s)) (ContDiffOn 𝕜 m f u))","decl":"theorem ContDiffWithinAt.contDiffOn (hm : m ≤ n) (h' : m = ∞ → n = ω)\n    (h : ContDiffWithinAt 𝕜 n f s x) :\n    ∃ u ∈ 𝓝[insert x s] x, u ⊆ insert x s ∧ ContDiffOn 𝕜 m f u := by\n  obtain ⟨_u, uo, xu, h⟩ := h.contDiffOn' hm h'\n  exact ⟨_, inter_mem_nhdsWithin _ (uo.mem_nhds xu), inter_subset_left, h⟩\n\n"}
{"name":"ContDiffOn.analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nh : ContDiffOn 𝕜 Top.top f s\n⊢ AnalyticOn 𝕜 f s","decl":"theorem ContDiffOn.analyticOn (h : ContDiffOn 𝕜 ω f s) : AnalyticOn 𝕜 f s :=\n  fun x hx ↦ (h x hx).analyticWithinAt\n\n"}
{"name":"contDiffWithinAt_iff_contDiffOn_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Iff (ContDiffWithinAt 𝕜 n f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (ContDiffOn 𝕜 n f u))","decl":"/-- A function is `C^n` within a set at a point, for `n : ℕ`, if and only if it is `C^n` on\na neighborhood of this point. -/\ntheorem contDiffWithinAt_iff_contDiffOn_nhds (hn : n ≠ ∞) :\n    ContDiffWithinAt 𝕜 n f s x ↔ ∃ u ∈ 𝓝[insert x s] x, ContDiffOn 𝕜 n f u := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · rcases h.contDiffOn le_rfl (by simp [hn]) with ⟨u, hu, h'u⟩\n    exact ⟨u, hu, h'u.2⟩\n  · rcases h with ⟨u, u_mem, hu⟩\n    have : x ∈ u := mem_of_mem_nhdsWithin (mem_insert x s) u_mem\n    exact (hu x this).mono_of_mem_nhdsWithin (nhdsWithin_mono _ (subset_insert x s) u_mem)\n\n"}
{"name":"ContDiffWithinAt.eventually","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nhn : Ne n ↑Top.top\n⊢ Filter.Eventually (fun y => ContDiffWithinAt 𝕜 n f s y) (nhdsWithin x (Insert.insert x s))","decl":"protected theorem ContDiffWithinAt.eventually (h : ContDiffWithinAt 𝕜 n f s x) (hn : n ≠ ∞) :\n    ∀ᶠ y in 𝓝[insert x s] x, ContDiffWithinAt 𝕜 n f s y := by\n  rcases h.contDiffOn le_rfl (by simp [hn]) with ⟨u, hu, _, hd⟩\n  have : ∀ᶠ y : E in 𝓝[insert x s] x, u ∈ 𝓝[insert x s] y ∧ y ∈ u :=\n    (eventually_eventually_nhdsWithin.2 hu).and hu\n  refine this.mono fun y hy => (hd y hy.2).mono_of_mem_nhdsWithin ?_\n  exact nhdsWithin_mono y (subset_insert _ _) hy.1\n\n"}
{"name":"ContDiffOn.of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 (HAdd.hAdd n 1) f s\n⊢ ContDiffOn 𝕜 n f s","decl":"theorem ContDiffOn.of_succ (h : ContDiffOn 𝕜 (n + 1) f s) : ContDiffOn 𝕜 n f s :=\n  h.of_le le_self_add\n\n"}
{"name":"ContDiffOn.one_of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 (HAdd.hAdd n 1) f s\n⊢ ContDiffOn 𝕜 1 f s","decl":"theorem ContDiffOn.one_of_succ (h : ContDiffOn 𝕜 (n + 1) f s) : ContDiffOn 𝕜 1 f s :=\n  h.of_le le_add_self\n\n"}
{"name":"contDiffOn_iff_forall_nat_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : ENat\n⊢ Iff (ContDiffOn 𝕜 (↑n) f s) (∀ (m : Nat), LE.le (↑m) n → ContDiffOn 𝕜 (↑m) f s)","decl":"theorem contDiffOn_iff_forall_nat_le {n : ℕ∞} :\n    ContDiffOn 𝕜 n f s ↔ ∀ m : ℕ, ↑m ≤ n → ContDiffOn 𝕜 m f s :=\n  ⟨fun H _ hm => H.of_le (mod_cast hm), fun H x hx m hm => H m hm x hx m le_rfl⟩\n\n"}
{"name":"contDiffOn_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (∀ (n : Nat), ContDiffOn 𝕜 (↑n) f s)","decl":"theorem contDiffOn_infty : ContDiffOn 𝕜 ∞ f s ↔ ∀ n : ℕ, ContDiffOn 𝕜 n f s :=\n  contDiffOn_iff_forall_nat_le.trans <| by simp only [le_top, forall_prop_of_true]\n\n"}
{"name":"contDiffOn_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (∀ (n : Nat), ContDiffOn 𝕜 (↑n) f s)","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiffOn_top := contDiffOn_infty\n"}
{"name":"contDiffOn_infty_iff_contDiffOn_omega","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (∀ (n : Nat), ContDiffOn 𝕜 (↑n) f s)","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_infty_iff_contDiffOn_omega := contDiffOn_infty\n\n"}
{"name":"contDiffOn_all_iff_nat","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\n⊢ Iff (∀ (n : ENat), ContDiffOn 𝕜 (↑n) f s) (∀ (n : Nat), ContDiffOn 𝕜 (↑n) f s)","decl":"theorem contDiffOn_all_iff_nat :\n    (∀ (n : ℕ∞), ContDiffOn 𝕜 n f s) ↔ ∀ n : ℕ, ContDiffOn 𝕜 n f s := by\n  refine ⟨fun H n => H n, ?_⟩\n  rintro H (_ | n)\n  exacts [contDiffOn_infty.2 H, H n]\n\n"}
{"name":"ContDiffOn.continuousOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\n⊢ ContinuousOn f s","decl":"theorem ContDiffOn.continuousOn (h : ContDiffOn 𝕜 n f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuousWithinAt\n\n"}
{"name":"ContDiffOn.congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nh₁ : ∀ (x : E), Membership.mem s x → Eq (f₁ x) (f x)\n⊢ ContDiffOn 𝕜 n f₁ s","decl":"theorem ContDiffOn.congr (h : ContDiffOn 𝕜 n f s) (h₁ : ∀ x ∈ s, f₁ x = f x) :\n    ContDiffOn 𝕜 n f₁ s := fun x hx => (h x hx).congr h₁ (h₁ x hx)\n\n"}
{"name":"contDiffOn_congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf f₁ : E → F\nn : WithTop ENat\nh₁ : ∀ (x : E), Membership.mem s x → Eq (f₁ x) (f x)\n⊢ Iff (ContDiffOn 𝕜 n f₁ s) (ContDiffOn 𝕜 n f s)","decl":"theorem contDiffOn_congr (h₁ : ∀ x ∈ s, f₁ x = f x) : ContDiffOn 𝕜 n f₁ s ↔ ContDiffOn 𝕜 n f s :=\n  ⟨fun H => H.congr fun x hx => (h₁ x hx).symm, fun H => H.congr h₁⟩\n\n"}
{"name":"ContDiffOn.mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nt : Set E\nhst : HasSubset.Subset t s\n⊢ ContDiffOn 𝕜 n f t","decl":"theorem ContDiffOn.mono (h : ContDiffOn 𝕜 n f s) {t : Set E} (hst : t ⊆ s) : ContDiffOn 𝕜 n f t :=\n  fun x hx => (h x (hst hx)).mono hst\n\n"}
{"name":"ContDiffOn.congr_mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns s₁ : Set E\nf f₁ : E → F\nn : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\nh₁ : ∀ (x : E), Membership.mem s₁ x → Eq (f₁ x) (f x)\nhs : HasSubset.Subset s₁ s\n⊢ ContDiffOn 𝕜 n f₁ s₁","decl":"theorem ContDiffOn.congr_mono (hf : ContDiffOn 𝕜 n f s) (h₁ : ∀ x ∈ s₁, f₁ x = f x) (hs : s₁ ⊆ s) :\n    ContDiffOn 𝕜 n f₁ s₁ :=\n  (hf.mono hs).congr h₁\n\n"}
{"name":"ContDiffOn.differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhn : LE.le 1 n\n⊢ DifferentiableOn 𝕜 f s","decl":"/-- If a function is `C^n` on a set with `n ≥ 1`, then it is differentiable there. -/\ntheorem ContDiffOn.differentiableOn (h : ContDiffOn 𝕜 n f s) (hn : 1 ≤ n) :\n    DifferentiableOn 𝕜 f s := fun x hx => (h x hx).differentiableWithinAt hn\n\n"}
{"name":"contDiffOn_of_locally_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ∀ (x : E), Membership.mem s x → Exists fun u => And (IsOpen u) (And (Membership.mem u x) (ContDiffOn 𝕜 n f (Inter.inter s u)))\n⊢ ContDiffOn 𝕜 n f s","decl":"/-- If a function is `C^n` around each point in a set, then it is `C^n` on the set. -/\ntheorem contDiffOn_of_locally_contDiffOn\n    (h : ∀ x ∈ s, ∃ u, IsOpen u ∧ x ∈ u ∧ ContDiffOn 𝕜 n f (s ∩ u)) : ContDiffOn 𝕜 n f s := by\n  intro x xs\n  rcases h x xs with ⟨u, u_open, xu, hu⟩\n  apply (contDiffWithinAt_inter _).1 (hu x ⟨xs, xu⟩)\n  exact IsOpen.mem_nhds u_open xu\n\n"}
{"name":"contDiffOn_succ_iff_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f s) (∀ (x : E), Membership.mem s x → Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (Eq n Top.top → AnalyticOn 𝕜 f u) (Exists fun f' => And (∀ (x : E), Membership.mem u x → HasFDerivWithinAt f (f' x) u x) (ContDiffOn 𝕜 n f' u))))","decl":"/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem contDiffOn_succ_iff_hasFDerivWithinAt (hn : n ≠ ∞) :\n    ContDiffOn 𝕜 (n + 1) f s ↔\n      ∀ x ∈ s, ∃ u ∈ 𝓝[insert x s] x, (n = ω → AnalyticOn 𝕜 f u) ∧ ∃ f' : E → E →L[𝕜] F,\n        (∀ x ∈ u, HasFDerivWithinAt f (f' x) u x) ∧ ContDiffOn 𝕜 n f' u := by\n  constructor\n  · intro h x hx\n    rcases (contDiffWithinAt_succ_iff_hasFDerivWithinAt hn).1 (h x hx) with\n      ⟨u, hu, f_an, f', hf', Hf'⟩\n    rcases Hf'.contDiffOn le_rfl (by simp [hn]) with ⟨v, vu, v'u, hv⟩\n    rw [insert_eq_of_mem hx] at hu ⊢\n    have xu : x ∈ u := mem_of_mem_nhdsWithin hx hu\n    rw [insert_eq_of_mem xu] at vu v'u\n    exact ⟨v, nhdsWithin_le_of_mem hu vu, fun h ↦ (f_an h).mono v'u, f',\n      fun y hy ↦ (hf' y (v'u hy)).mono v'u, hv⟩\n  · intro h x hx\n    rw [contDiffWithinAt_succ_iff_hasFDerivWithinAt hn]\n    rcases h x hx with ⟨u, u_nhbd, f_an, f', hu, hf'⟩\n    have : x ∈ u := mem_of_mem_nhdsWithin (mem_insert _ _) u_nhbd\n    exact ⟨u, u_nhbd, f_an, f', hu, hf' x this⟩\n\n\n"}
{"name":"contDiffOn_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\n⊢ Iff (ContDiffOn 𝕜 0 f s) (ContinuousOn f s)","decl":"@[simp]\ntheorem contDiffOn_zero : ContDiffOn 𝕜 0 f s ↔ ContinuousOn f s := by\n  refine ⟨fun H => H.continuousOn, fun H => fun x hx m hm ↦ ?_⟩\n  have : (m : WithTop ℕ∞) = 0 := le_antisymm (mod_cast hm) bot_le\n  rw [this]\n  refine ⟨insert x s, self_mem_nhdsWithin, ftaylorSeriesWithin 𝕜 f s, ?_⟩\n  rw [hasFTaylorSeriesUpToOn_zero_iff]\n  exact ⟨by rwa [insert_eq_of_mem hx], fun x _ => by simp [ftaylorSeriesWithin]⟩\n\n"}
{"name":"contDiffWithinAt_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nhx : Membership.mem s x\n⊢ Iff (ContDiffWithinAt 𝕜 0 f s x) (Exists fun u => And (Membership.mem (nhdsWithin x s) u) (ContinuousOn f (Inter.inter s u)))","decl":"theorem contDiffWithinAt_zero (hx : x ∈ s) :\n    ContDiffWithinAt 𝕜 0 f s x ↔ ∃ u ∈ 𝓝[s] x, ContinuousOn f (s ∩ u) := by\n  constructor\n  · intro h\n    obtain ⟨u, H, p, hp⟩ := h 0 le_rfl\n    refine ⟨u, ?_, ?_⟩\n    · simpa [hx] using H\n    · simp only [Nat.cast_zero, hasFTaylorSeriesUpToOn_zero_iff] at hp\n      exact hp.1.mono inter_subset_right\n  · rintro ⟨u, H, hu⟩\n    rw [← contDiffWithinAt_inter' H]\n    have h' : x ∈ s ∩ u := ⟨hx, mem_of_mem_nhdsWithin hx H⟩\n    exact (contDiffOn_zero.mpr hu).contDiffWithinAt h'\n\n"}
{"name":"ContDiffOn.ftaylorSeriesWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhs : UniqueDiffOn 𝕜 s\n⊢ HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin 𝕜 f s) s","decl":"/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylorSeriesWithin 𝕜 f s` as a Taylor series up to order `n` in `s`. -/\nprotected theorem ContDiffOn.ftaylorSeriesWithin\n    (h : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s) :\n    HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin 𝕜 f s) s := by\n  constructor\n  · intro x _\n    simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.curry0_apply,\n      iteratedFDerivWithin_zero_apply]\n  · intro m hm x hx\n    have : (m + 1 : ℕ) ≤ n := ENat.add_one_natCast_le_withTop_of_lt hm\n    rcases (h x hx).of_le this _ le_rfl with ⟨u, hu, p, Hp⟩\n    rw [insert_eq_of_mem hx] at hu\n    rcases mem_nhdsWithin.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [inter_comm] at ho\n    have : p x m.succ = ftaylorSeriesWithin 𝕜 f s x m.succ := by\n      change p x m.succ = iteratedFDerivWithin 𝕜 m.succ f s x\n      rw [← iteratedFDerivWithin_inter_open o_open xo]\n      exact (Hp.mono ho).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl (hs.inter o_open) ⟨hx, xo⟩\n    rw [← this, ← hasFDerivWithinAt_inter (IsOpen.mem_nhds o_open xo)]\n    have A : ∀ y ∈ s ∩ o, p y m = ftaylorSeriesWithin 𝕜 f s y m := by\n      rintro y ⟨hy, yo⟩\n      change p y m = iteratedFDerivWithin 𝕜 m f s y\n      rw [← iteratedFDerivWithin_inter_open o_open yo]\n      exact\n        (Hp.mono ho).eq_iteratedFDerivWithin_of_uniqueDiffOn (mod_cast Nat.le_succ m)\n          (hs.inter o_open) ⟨hy, yo⟩\n    exact\n      ((Hp.mono ho).fderivWithin m (mod_cast lt_add_one m) x ⟨hx, xo⟩).congr\n        (fun y hy => (A y hy).symm) (A x ⟨hx, xo⟩).symm\n  · intro m hm\n    apply continuousOn_of_locally_continuousOn\n    intro x hx\n    rcases (h x hx).of_le hm _ le_rfl with ⟨u, hu, p, Hp⟩\n    rcases mem_nhdsWithin.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [insert_eq_of_mem hx] at ho\n    rw [inter_comm] at ho\n    refine ⟨o, o_open, xo, ?_⟩\n    have A : ∀ y ∈ s ∩ o, p y m = ftaylorSeriesWithin 𝕜 f s y m := by\n      rintro y ⟨hy, yo⟩\n      change p y m = iteratedFDerivWithin 𝕜 m f s y\n      rw [← iteratedFDerivWithin_inter_open o_open yo]\n      exact (Hp.mono ho).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl (hs.inter o_open) ⟨hy, yo⟩\n    exact ((Hp.mono ho).cont m le_rfl).congr fun y hy => (A y hy).symm\n\n"}
{"name":"iteratedFDerivWithin_subset","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns t : Set E\nf : E → F\nx : E\nn : Nat\nst : HasSubset.Subset s t\nhs : UniqueDiffOn 𝕜 s\nht : UniqueDiffOn 𝕜 t\nh : ContDiffOn 𝕜 (↑n) f t\nhx : Membership.mem s x\n⊢ Eq (iteratedFDerivWithin 𝕜 n f s x) (iteratedFDerivWithin 𝕜 n f t x)","decl":"theorem iteratedFDerivWithin_subset {n : ℕ} (st : s ⊆ t) (hs : UniqueDiffOn 𝕜 s)\n    (ht : UniqueDiffOn 𝕜 t) (h : ContDiffOn 𝕜 n f t) (hx : x ∈ s) :\n    iteratedFDerivWithin 𝕜 n f s x = iteratedFDerivWithin 𝕜 n f t x :=\n  (((h.ftaylorSeriesWithin ht).mono st).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl hs hx).symm\n\n"}
{"name":"ContDiffWithinAt.eventually_hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : E → F\ns : Set E\na : E\nh : ContDiffWithinAt 𝕜 n f s a\nhs : UniqueDiffOn 𝕜 s\nha : Membership.mem s a\nm : Nat\nhm : LE.le (↑m) n\n⊢ Filter.Eventually (fun t => HasFTaylorSeriesUpToOn (↑m) f (ftaylorSeriesWithin 𝕜 f s) t) (nhdsWithin a s).smallSets","decl":"theorem ContDiffWithinAt.eventually_hasFTaylorSeriesUpToOn {f : E → F} {s : Set E} {a : E}\n    (h : ContDiffWithinAt 𝕜 n f s a) (hs : UniqueDiffOn 𝕜 s) (ha : a ∈ s) {m : ℕ} (hm : m ≤ n) :\n    ∀ᶠ t in (𝓝[s] a).smallSets, HasFTaylorSeriesUpToOn m f (ftaylorSeriesWithin 𝕜 f s) t := by\n  rcases h.contDiffOn' hm (by simp) with ⟨U, hUo, haU, hfU⟩\n  have : ∀ᶠ t in (𝓝[s] a).smallSets, t ⊆ s ∩ U := by\n    rw [eventually_smallSets_subset]\n    exact inter_mem_nhdsWithin _ <| hUo.mem_nhds haU\n  refine this.mono fun t ht ↦ .mono ?_ ht\n  rw [insert_eq_of_mem ha] at hfU\n  refine (hfU.ftaylorSeriesWithin (hs.inter hUo)).congr_series fun k hk x hx ↦ ?_\n  exact iteratedFDerivWithin_inter_open hUo hx.2\n\n"}
{"name":"AnalyticOn.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : AnalyticOn 𝕜 f s\nhs : UniqueDiffOn 𝕜 s\n⊢ ContDiffOn 𝕜 n f s","decl":"/-- On a set with unique differentiability, an analytic function is automatically `C^ω`, as its\nsuccessive derivatives are also analytic. This does not require completeness of the space. See\nalso `AnalyticOn.contDiffOn_of_completeSpace`.-/\ntheorem AnalyticOn.contDiffOn (h : AnalyticOn 𝕜 f s) (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 n f s := by\n  suffices ContDiffOn 𝕜 ω f s from this.of_le le_top\n  rcases h.exists_hasFTaylorSeriesUpToOn hs with ⟨p, hp⟩\n  intro x hx\n  refine ⟨s, ?_, p, hp⟩\n  rw [insert_eq_of_mem hx]\n  exact self_mem_nhdsWithin\n\n"}
{"name":"AnalyticWithinOn.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : AnalyticOn 𝕜 f s\nhs : UniqueDiffOn 𝕜 s\n⊢ ContDiffOn 𝕜 n f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.contDiffOn := AnalyticOn.contDiffOn\n\n"}
{"name":"AnalyticOnNhd.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : AnalyticOnNhd 𝕜 f s\nhs : UniqueDiffOn 𝕜 s\n⊢ ContDiffOn 𝕜 n f s","decl":"/-- On a set with unique differentiability, an analytic function is automatically `C^ω`, as its\nsuccessive derivatives are also analytic. This does not require completeness of the space. See\nalso `AnalyticOnNhd.contDiffOn_of_completeSpace`. -/\ntheorem AnalyticOnNhd.contDiffOn (h : AnalyticOnNhd 𝕜 f s) (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 n f s := h.analyticOn.contDiffOn hs\n\n"}
{"name":"AnalyticOn.contDiffOn_of_completeSpace","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\ninst✝ : CompleteSpace F\nh : AnalyticOn 𝕜 f s\n⊢ ContDiffOn 𝕜 n f s","decl":"/-- An analytic function is automatically `C^ω` in a complete space -/\ntheorem AnalyticOn.contDiffOn_of_completeSpace [CompleteSpace F] (h : AnalyticOn 𝕜 f s) :\n    ContDiffOn 𝕜 n f s :=\n  fun x hx ↦ (h x hx).contDiffWithinAt\n\n"}
{"name":"AnalyticOnNhd.contDiffOn_of_completeSpace","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\ninst✝ : CompleteSpace F\nh : AnalyticOnNhd 𝕜 f s\n⊢ ContDiffOn 𝕜 n f s","decl":"/-- An analytic function is automatically `C^ω` in a complete space -/\ntheorem AnalyticOnNhd.contDiffOn_of_completeSpace [CompleteSpace F] (h : AnalyticOnNhd 𝕜 f s) :\n    ContDiffOn 𝕜 n f s :=\n  h.analyticOn.contDiffOn_of_completeSpace\n\n"}
{"name":"contDiffOn_of_continuousOn_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : ENat\nHcont : ∀ (m : Nat), LE.le (↑m) n → ContinuousOn (fun x => iteratedFDerivWithin 𝕜 m f s x) s\nHdiff : ∀ (m : Nat), LT.lt (↑m) n → DifferentiableOn 𝕜 (fun x => iteratedFDerivWithin 𝕜 m f s x) s\n⊢ ContDiffOn 𝕜 (↑n) f s","decl":"theorem contDiffOn_of_continuousOn_differentiableOn {n : ℕ∞}\n    (Hcont : ∀ m : ℕ, m ≤ n → ContinuousOn (fun x => iteratedFDerivWithin 𝕜 m f s x) s)\n    (Hdiff : ∀ m : ℕ, m < n →\n      DifferentiableOn 𝕜 (fun x => iteratedFDerivWithin 𝕜 m f s x) s) :\n    ContDiffOn 𝕜 n f s := by\n  intro x hx m hm\n  rw [insert_eq_of_mem hx]\n  refine ⟨s, self_mem_nhdsWithin, ftaylorSeriesWithin 𝕜 f s, ?_⟩\n  constructor\n  · intro y _\n    simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.curry0_apply,\n      iteratedFDerivWithin_zero_apply]\n  · intro k hk y hy\n    convert (Hdiff k (lt_of_lt_of_le (mod_cast hk) (mod_cast hm)) y hy).hasFDerivWithinAt\n  · intro k hk\n    exact Hcont k (le_trans (mod_cast hk) (mod_cast hm))\n\n"}
{"name":"contDiffOn_of_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : ENat\nh : ∀ (m : Nat), LE.le (↑m) n → DifferentiableOn 𝕜 (iteratedFDerivWithin 𝕜 m f s) s\n⊢ ContDiffOn 𝕜 (↑n) f s","decl":"theorem contDiffOn_of_differentiableOn {n : ℕ∞}\n    (h : ∀ m : ℕ, m ≤ n → DifferentiableOn 𝕜 (iteratedFDerivWithin 𝕜 m f s) s) :\n    ContDiffOn 𝕜 n f s :=\n  contDiffOn_of_continuousOn_differentiableOn (fun m hm => (h m hm).continuousOn) fun m hm =>\n    h m (le_of_lt hm)\n\n"}
{"name":"contDiffOn_of_analyticOn_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ∀ (m : Nat), AnalyticOn 𝕜 (iteratedFDerivWithin 𝕜 m f s) s\n⊢ ContDiffOn 𝕜 n f s","decl":"theorem contDiffOn_of_analyticOn_iteratedFDerivWithin\n    (h : ∀ m, AnalyticOn 𝕜 (iteratedFDerivWithin 𝕜 m f s) s) :\n    ContDiffOn 𝕜 n f s := by\n  suffices ContDiffOn 𝕜 ω f s from this.of_le le_top\n  intro x hx\n  refine ⟨insert x s, self_mem_nhdsWithin, ftaylorSeriesWithin 𝕜 f s, ?_, ?_⟩\n  · rw [insert_eq_of_mem hx]\n    constructor\n    · intro y _\n      simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.curry0_apply,\n        iteratedFDerivWithin_zero_apply]\n    · intro k _ y hy\n      exact ((h k).differentiableOn y hy).hasFDerivWithinAt\n    · intro k _\n      exact (h k).continuousOn\n  · intro i\n    rw [insert_eq_of_mem hx]\n    exact h i\n\n"}
{"name":"contDiffOn_omega_iff_analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 Top.top f s) (AnalyticOn 𝕜 f s)","decl":"theorem contDiffOn_omega_iff_analyticOn (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 ω f s ↔ AnalyticOn 𝕜 f s :=\n  ⟨fun h m ↦ h.analyticOn m, fun h ↦ h.contDiffOn hs⟩\n\n"}
{"name":"ContDiffOn.continuousOn_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nm : Nat\nh : ContDiffOn 𝕜 n f s\nhmn : LE.le (↑m) n\nhs : UniqueDiffOn 𝕜 s\n⊢ ContinuousOn (iteratedFDerivWithin 𝕜 m f s) s","decl":"theorem ContDiffOn.continuousOn_iteratedFDerivWithin {m : ℕ} (h : ContDiffOn 𝕜 n f s)\n    (hmn : m ≤ n) (hs : UniqueDiffOn 𝕜 s) : ContinuousOn (iteratedFDerivWithin 𝕜 m f s) s :=\n  ((h.of_le hmn).ftaylorSeriesWithin hs).cont m le_rfl\n\n"}
{"name":"ContDiffOn.differentiableOn_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nm : Nat\nh : ContDiffOn 𝕜 n f s\nhmn : LT.lt (↑m) n\nhs : UniqueDiffOn 𝕜 s\n⊢ DifferentiableOn 𝕜 (iteratedFDerivWithin 𝕜 m f s) s","decl":"theorem ContDiffOn.differentiableOn_iteratedFDerivWithin {m : ℕ} (h : ContDiffOn 𝕜 n f s)\n    (hmn : m < n) (hs : UniqueDiffOn 𝕜 s) :\n    DifferentiableOn 𝕜 (iteratedFDerivWithin 𝕜 m f s) s := by\n  intro x hx\n  have : (m + 1 : ℕ) ≤ n := ENat.add_one_natCast_le_withTop_of_lt hmn\n  apply (((h.of_le this).ftaylorSeriesWithin hs).fderivWithin m ?_ x hx).differentiableWithinAt\n  exact_mod_cast lt_add_one m\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nm : Nat\nh : ContDiffWithinAt 𝕜 n f s x\nhmn : LT.lt (↑m) n\nhs : UniqueDiffOn 𝕜 (Insert.insert x s)\n⊢ DifferentiableWithinAt 𝕜 (iteratedFDerivWithin 𝕜 m f s) s x","decl":"theorem ContDiffWithinAt.differentiableWithinAt_iteratedFDerivWithin {m : ℕ}\n    (h : ContDiffWithinAt 𝕜 n f s x) (hmn : m < n) (hs : UniqueDiffOn 𝕜 (insert x s)) :\n    DifferentiableWithinAt 𝕜 (iteratedFDerivWithin 𝕜 m f s) s x := by\n  have : (m + 1 : WithTop ℕ∞) ≠ ∞ := Ne.symm (ne_of_beq_false rfl)\n  rcases h.contDiffOn' (ENat.add_one_natCast_le_withTop_of_lt hmn) (by simp [this])\n    with ⟨u, uo, xu, hu⟩\n  set t := insert x s ∩ u\n  have A : t =ᶠ[𝓝[≠] x] s := by\n    simp only [set_eventuallyEq_iff_inf_principal, ← nhdsWithin_inter']\n    rw [← inter_assoc, nhdsWithin_inter_of_mem', ← diff_eq_compl_inter, insert_diff_of_mem,\n      diff_eq_compl_inter]\n    exacts [rfl, mem_nhdsWithin_of_mem_nhds (uo.mem_nhds xu)]\n  have B : iteratedFDerivWithin 𝕜 m f s =ᶠ[𝓝 x] iteratedFDerivWithin 𝕜 m f t :=\n    iteratedFDerivWithin_eventually_congr_set' _ A.symm _\n  have C : DifferentiableWithinAt 𝕜 (iteratedFDerivWithin 𝕜 m f t) t x :=\n    hu.differentiableOn_iteratedFDerivWithin (Nat.cast_lt.2 m.lt_succ_self) (hs.inter uo) x\n      ⟨mem_insert _ _, xu⟩\n  rw [differentiableWithinAt_congr_set' _ A] at C\n  exact C.congr_of_eventuallyEq (B.filter_mono inf_le_left) B.self_of_nhds\n\n"}
{"name":"contDiffOn_iff_continuousOn_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : ENat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (↑n) f s) (And (∀ (m : Nat), LE.le (↑m) n → ContinuousOn (fun x => iteratedFDerivWithin 𝕜 m f s x) s) (∀ (m : Nat), LT.lt (↑m) n → DifferentiableOn 𝕜 (fun x => iteratedFDerivWithin 𝕜 m f s x) s))","decl":"theorem contDiffOn_iff_continuousOn_differentiableOn {n : ℕ∞} (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 n f s ↔\n      (∀ m : ℕ, m ≤ n → ContinuousOn (fun x => iteratedFDerivWithin 𝕜 m f s x) s) ∧\n        ∀ m : ℕ, m < n → DifferentiableOn 𝕜 (fun x => iteratedFDerivWithin 𝕜 m f s x) s :=\n  ⟨fun h => ⟨fun _m hm => h.continuousOn_iteratedFDerivWithin (mod_cast hm) hs,\n      fun _m hm => h.differentiableOn_iteratedFDerivWithin (mod_cast hm) hs⟩,\n    fun h => contDiffOn_of_continuousOn_differentiableOn h.1 h.2⟩\n\n"}
{"name":"contDiffOn_nat_iff_continuousOn_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : Nat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (↑n) f s) (And (∀ (m : Nat), LE.le m n → ContinuousOn (fun x => iteratedFDerivWithin 𝕜 m f s x) s) (∀ (m : Nat), LT.lt m n → DifferentiableOn 𝕜 (fun x => iteratedFDerivWithin 𝕜 m f s x) s))","decl":"theorem contDiffOn_nat_iff_continuousOn_differentiableOn {n : ℕ} (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 n f s ↔\n      (∀ m : ℕ, m ≤ n → ContinuousOn (fun x => iteratedFDerivWithin 𝕜 m f s x) s) ∧\n        ∀ m : ℕ, m < n → DifferentiableOn 𝕜 (fun x => iteratedFDerivWithin 𝕜 m f s x) s := by\n  rw [show n = ((n : ℕ∞) : WithTop ℕ∞) from rfl, contDiffOn_iff_continuousOn_differentiableOn hs]\n  simp\n\n"}
{"name":"contDiffOn_succ_of_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhf : DifferentiableOn 𝕜 f s\nh' : Eq n Top.top → AnalyticOn 𝕜 f s\nh : ContDiffOn 𝕜 n (fun y => fderivWithin 𝕜 f s y) s\n⊢ ContDiffOn 𝕜 (HAdd.hAdd n 1) f s","decl":"theorem contDiffOn_succ_of_fderivWithin (hf : DifferentiableOn 𝕜 f s)\n    (h' : n = ω → AnalyticOn 𝕜 f s)\n    (h : ContDiffOn 𝕜 n (fun y => fderivWithin 𝕜 f s y) s) : ContDiffOn 𝕜 (n + 1) f s := by\n  rcases eq_or_ne n ∞ with rfl | hn\n  · rw [ENat.coe_top_add_one, contDiffOn_infty]\n    intro m x hx\n    apply ContDiffWithinAt.of_le _ (show (m : WithTop ℕ∞) ≤ m + 1 from le_self_add)\n    rw [contDiffWithinAt_succ_iff_hasFDerivWithinAt (by simp),\n      insert_eq_of_mem hx]\n    exact ⟨s, self_mem_nhdsWithin, (by simp), fderivWithin 𝕜 f s,\n      fun y hy => (hf y hy).hasFDerivWithinAt, (h x hx).of_le (mod_cast le_top)⟩\n  · intro x hx\n    rw [contDiffWithinAt_succ_iff_hasFDerivWithinAt hn,\n      insert_eq_of_mem hx]\n    exact ⟨s, self_mem_nhdsWithin, h', fderivWithin 𝕜 f s,\n      fun y hy => (hf y hy).hasFDerivWithinAt, h x hx⟩\n\n"}
{"name":"contDiffOn_of_analyticOn_of_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhf : AnalyticOn 𝕜 f s\nh : ContDiffOn 𝕜 Top.top (fun y => fderivWithin 𝕜 f s y) s\n⊢ ContDiffOn 𝕜 n f s","decl":"theorem contDiffOn_of_analyticOn_of_fderivWithin (hf : AnalyticOn 𝕜 f s)\n    (h : ContDiffOn 𝕜 ω (fun y ↦ fderivWithin 𝕜 f s y) s) : ContDiffOn 𝕜 n f s := by\n  suffices ContDiffOn 𝕜 (ω + 1) f s from this.of_le le_top\n  exact contDiffOn_succ_of_fderivWithin hf.differentiableOn (fun _ ↦ hf) h\n\n"}
{"name":"contDiffOn_succ_iff_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f s) (And (DifferentiableOn 𝕜 f s) (And (Eq n Top.top → AnalyticOn 𝕜 f s) (ContDiffOn 𝕜 n (fderivWithin 𝕜 f s) s)))","decl":"/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (expressed with `fderivWithin`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_fderivWithin (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 (n + 1) f s ↔\n      DifferentiableOn 𝕜 f s ∧ (n = ω → AnalyticOn 𝕜 f s) ∧\n      ContDiffOn 𝕜 n (fderivWithin 𝕜 f s) s := by\n  refine ⟨fun H => ?_, fun h => contDiffOn_succ_of_fderivWithin h.1 h.2.1 h.2.2⟩\n  refine ⟨H.differentiableOn le_add_self, ?_, fun x hx => ?_⟩\n  · rintro rfl\n    exact H.analyticOn\n  have A (m : ℕ) (hm : m ≤ n) : ContDiffWithinAt 𝕜 m (fun y => fderivWithin 𝕜 f s y) s x := by\n    rcases (contDiffWithinAt_succ_iff_hasFDerivWithinAt (n := m) (ne_of_beq_false rfl)).1\n      (H.of_le (add_le_add_right hm 1) x hx) with ⟨u, hu, -, f', hff', hf'⟩\n    rcases mem_nhdsWithin.1 hu with ⟨o, o_open, xo, ho⟩\n    rw [inter_comm, insert_eq_of_mem hx] at ho\n    have := hf'.mono ho\n    rw [contDiffWithinAt_inter' (mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds o_open xo))] at this\n    apply this.congr_of_eventuallyEq_of_mem _ hx\n    have : o ∩ s ∈ 𝓝[s] x := mem_nhdsWithin.2 ⟨o, o_open, xo, Subset.refl _⟩\n    rw [inter_comm] at this\n    refine Filter.eventuallyEq_of_mem this fun y hy => ?_\n    have A : fderivWithin 𝕜 f (s ∩ o) y = f' y :=\n      ((hff' y (ho hy)).mono ho).fderivWithin (hs.inter o_open y hy)\n    rwa [fderivWithin_inter (o_open.mem_nhds hy.2)] at A\n  match n with\n  | ω => exact (H.analyticOn.fderivWithin hs).contDiffOn hs (n := ω) x hx\n  | ∞ => exact contDiffWithinAt_infty.2 (fun m ↦ A m (mod_cast le_top))\n  | (n : ℕ) => exact A n le_rfl\n\n"}
{"name":"contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f s) (And (Eq n Top.top → AnalyticOn 𝕜 f s) (Exists fun f' => And (ContDiffOn 𝕜 n f' s) (∀ (x : E), Membership.mem s x → HasFDerivWithinAt f (f' x) s x)))","decl":"theorem contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 (n + 1) f s ↔ (n = ω → AnalyticOn 𝕜 f s) ∧\n      ∃ f' : E → E →L[𝕜] F, ContDiffOn 𝕜 n f' s ∧ ∀ x, x ∈ s → HasFDerivWithinAt f (f' x) s x := by\n  rw [contDiffOn_succ_iff_fderivWithin hs]\n  refine ⟨fun h => ⟨h.2.1, fderivWithin 𝕜 f s, h.2.2,\n    fun x hx => (h.1 x hx).hasFDerivWithinAt⟩, fun ⟨f_an, h⟩ => ?_⟩\n  rcases h with ⟨f', h1, h2⟩\n  refine ⟨fun x hx => (h2 x hx).differentiableWithinAt, f_an, fun x hx => ?_⟩\n  exact (h1 x hx).congr_of_mem (fun y hy => (h2 y hy).fderivWithin (hs y hy)) hx\n\n"}
{"name":"contDiffOn_succ_iff_hasFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f s) (And (Eq n Top.top → AnalyticOn 𝕜 f s) (Exists fun f' => And (ContDiffOn 𝕜 n f' s) (∀ (x : E), Membership.mem s x → HasFDerivWithinAt f (f' x) s x)))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_succ_iff_hasFDerivWithin := contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn\n\n"}
{"name":"contDiffOn_infty_iff_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (And (DifferentiableOn 𝕜 f s) (ContDiffOn 𝕜 (↑Top.top) (fderivWithin 𝕜 f s) s))","decl":"theorem contDiffOn_infty_iff_fderivWithin (hs : UniqueDiffOn 𝕜 s) :\n    ContDiffOn 𝕜 ∞ f s ↔ DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ∞ (fderivWithin 𝕜 f s) s := by\n  rw [show ∞ = ∞ + 1 from rfl, contDiffOn_succ_iff_fderivWithin hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nhs : UniqueDiffOn 𝕜 s\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (And (DifferentiableOn 𝕜 f s) (ContDiffOn 𝕜 (↑Top.top) (fderivWithin 𝕜 f s) s))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_fderivWithin := contDiffOn_infty_iff_fderivWithin\n\n"}
{"name":"contDiffOn_succ_iff_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhs : IsOpen s\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f s) (And (DifferentiableOn 𝕜 f s) (And (Eq n Top.top → AnalyticOn 𝕜 f s) (ContDiffOn 𝕜 n (fderiv 𝕜 f) s)))","decl":"/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_fderiv_of_isOpen (hs : IsOpen s) :\n    ContDiffOn 𝕜 (n + 1) f s ↔\n      DifferentiableOn 𝕜 f s ∧ (n = ω → AnalyticOn 𝕜 f s) ∧\n      ContDiffOn 𝕜 n (fderiv 𝕜 f) s := by\n  rw [contDiffOn_succ_iff_fderivWithin hs.uniqueDiffOn]\n  exact Iff.rfl.and (Iff.rfl.and (contDiffOn_congr fun x hx ↦ fderivWithin_of_isOpen hs hx))\n\n"}
{"name":"contDiffOn_infty_iff_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nhs : IsOpen s\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (And (DifferentiableOn 𝕜 f s) (ContDiffOn 𝕜 (↑Top.top) (fderiv 𝕜 f) s))","decl":"theorem contDiffOn_infty_iff_fderiv_of_isOpen (hs : IsOpen s) :\n    ContDiffOn 𝕜 ∞ f s ↔ DifferentiableOn 𝕜 f s ∧ ContDiffOn 𝕜 ∞ (fderiv 𝕜 f) s := by\n  rw [show ∞ = ∞ + 1 from rfl, contDiffOn_succ_iff_fderiv_of_isOpen hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nhs : IsOpen s\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f s) (And (DifferentiableOn 𝕜 f s) (ContDiffOn 𝕜 (↑Top.top) (fderiv 𝕜 f) s))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_fderiv_of_isOpen := contDiffOn_infty_iff_fderiv_of_isOpen\n\n"}
{"name":"ContDiffOn.fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nm n : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffOn 𝕜 m (fderivWithin 𝕜 f s) s","decl":"protected theorem ContDiffOn.fderivWithin (hf : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s)\n    (hmn : m + 1 ≤ n) : ContDiffOn 𝕜 m (fderivWithin 𝕜 f s) s :=\n  ((contDiffOn_succ_iff_fderivWithin hs).1 (hf.of_le hmn)).2.2\n\n"}
{"name":"ContDiffOn.fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nm n : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\nhs : IsOpen s\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffOn 𝕜 m (fderiv 𝕜 f) s","decl":"theorem ContDiffOn.fderiv_of_isOpen (hf : ContDiffOn 𝕜 n f s) (hs : IsOpen s) (hmn : m + 1 ≤ n) :\n    ContDiffOn 𝕜 m (fderiv 𝕜 f) s :=\n  (hf.fderivWithin hs.uniqueDiffOn hmn).congr fun _ hx => (fderivWithin_of_isOpen hs hx).symm\n\n"}
{"name":"ContDiffOn.continuousOn_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhs : UniqueDiffOn 𝕜 s\nhn : LE.le 1 n\n⊢ ContinuousOn (fderivWithin 𝕜 f s) s","decl":"theorem ContDiffOn.continuousOn_fderivWithin (h : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s)\n    (hn : 1 ≤ n) : ContinuousOn (fderivWithin 𝕜 f s) s :=\n  ((contDiffOn_succ_iff_fderivWithin hs).1\n    (h.of_le (show 0 + (1 : WithTop ℕ∞) ≤ n from hn))).2.2.continuousOn\n\n"}
{"name":"ContDiffOn.continuousOn_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhs : IsOpen s\nhn : LE.le 1 n\n⊢ ContinuousOn (fderiv 𝕜 f) s","decl":"theorem ContDiffOn.continuousOn_fderiv_of_isOpen (h : ContDiffOn 𝕜 n f s) (hs : IsOpen s)\n    (hn : 1 ≤ n) : ContinuousOn (fderiv 𝕜 f) s :=\n  ((contDiffOn_succ_iff_fderiv_of_isOpen hs).1\n    (h.of_le (show 0 + (1 : WithTop ℕ∞) ≤ n from hn))).2.2.continuousOn\n\n"}
{"name":"contDiffWithinAt_univ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\n⊢ Iff (ContDiffWithinAt 𝕜 n f Set.univ x) (ContDiffAt 𝕜 n f x)","decl":"theorem contDiffWithinAt_univ : ContDiffWithinAt 𝕜 n f univ x ↔ ContDiffAt 𝕜 n f x :=\n  Iff.rfl\n\n"}
{"name":"contDiffAt_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (ContDiffAt 𝕜 (↑Top.top) f x) (∀ (n : Nat), ContDiffAt 𝕜 (↑n) f x)","decl":"theorem contDiffAt_infty : ContDiffAt 𝕜 ∞ f x ↔ ∀ n : ℕ, ContDiffAt 𝕜 n f x := by\n  simp [← contDiffWithinAt_univ, contDiffWithinAt_infty]\n\n"}
{"name":"contDiffAt_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (ContDiffAt 𝕜 (↑Top.top) f x) (∀ (n : Nat), ContDiffAt 𝕜 (↑n) f x)","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiffAt_top := contDiffAt_infty\n\n"}
{"name":"ContDiffAt.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffAt 𝕜 n f x\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"theorem ContDiffAt.contDiffWithinAt (h : ContDiffAt 𝕜 n f x) : ContDiffWithinAt 𝕜 n f s x :=\n  h.mono (subset_univ _)\n\n"}
{"name":"ContDiffWithinAt.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt 𝕜 n f s x\nhx : Membership.mem (nhds x) s\n⊢ ContDiffAt 𝕜 n f x","decl":"theorem ContDiffWithinAt.contDiffAt (h : ContDiffWithinAt 𝕜 n f s x) (hx : s ∈ 𝓝 x) :\n    ContDiffAt 𝕜 n f x := by rwa [ContDiffAt, ← contDiffWithinAt_inter hx, univ_inter]\n\n"}
{"name":"contDiffWithinAt_iff_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : Membership.mem (nhds x) s\n⊢ Iff (ContDiffWithinAt 𝕜 n f s x) (ContDiffAt 𝕜 n f x)","decl":"theorem contDiffWithinAt_iff_contDiffAt (h : s ∈ 𝓝 x) :\n    ContDiffWithinAt 𝕜 n f s x ↔ ContDiffAt 𝕜 n f x := by\n  rw [← univ_inter s, contDiffWithinAt_inter h, contDiffWithinAt_univ]\n\n"}
{"name":"IsOpen.contDiffOn_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhs : IsOpen s\n⊢ Iff (ContDiffOn 𝕜 n f s) (∀ ⦃a : E⦄, Membership.mem s a → ContDiffAt 𝕜 n f a)","decl":"theorem IsOpen.contDiffOn_iff (hs : IsOpen s) :\n    ContDiffOn 𝕜 n f s ↔ ∀ ⦃a⦄, a ∈ s → ContDiffAt 𝕜 n f a :=\n  forall₂_congr fun _ => contDiffWithinAt_iff_contDiffAt ∘ hs.mem_nhds\n\n"}
{"name":"ContDiffOn.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffOn 𝕜 n f s\nhx : Membership.mem (nhds x) s\n⊢ ContDiffAt 𝕜 n f x","decl":"theorem ContDiffOn.contDiffAt (h : ContDiffOn 𝕜 n f s) (hx : s ∈ 𝓝 x) :\n    ContDiffAt 𝕜 n f x :=\n  (h _ (mem_of_mem_nhds hx)).contDiffAt hx\n\n"}
{"name":"ContDiffAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf f₁ : E → F\nx : E\nn : WithTop ENat\nh : ContDiffAt 𝕜 n f x\nhg : (nhds x).EventuallyEq f₁ f\n⊢ ContDiffAt 𝕜 n f₁ x","decl":"theorem ContDiffAt.congr_of_eventuallyEq (h : ContDiffAt 𝕜 n f x) (hg : f₁ =ᶠ[𝓝 x] f) :\n    ContDiffAt 𝕜 n f₁ x :=\n  h.congr_of_eventuallyEq_of_mem (by rwa [nhdsWithin_univ]) (mem_univ x)\n\n"}
{"name":"ContDiffAt.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nm n : WithTop ENat\nh : ContDiffAt 𝕜 n f x\nhmn : LE.le m n\n⊢ ContDiffAt 𝕜 m f x","decl":"theorem ContDiffAt.of_le (h : ContDiffAt 𝕜 n f x) (hmn : m ≤ n) : ContDiffAt 𝕜 m f x :=\n  ContDiffWithinAt.of_le h hmn\n\n"}
{"name":"ContDiffAt.continuousAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffAt 𝕜 n f x\n⊢ ContinuousAt f x","decl":"theorem ContDiffAt.continuousAt (h : ContDiffAt 𝕜 n f x) : ContinuousAt f x := by\n  simpa [continuousWithinAt_univ] using h.continuousWithinAt\n\n"}
{"name":"ContDiffAt.analyticAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nh : ContDiffAt 𝕜 Top.top f x\n⊢ AnalyticAt 𝕜 f x","decl":"theorem ContDiffAt.analyticAt (h : ContDiffAt 𝕜 ω f x) : AnalyticAt 𝕜 f x := by\n  rw [← contDiffWithinAt_univ] at h\n  rw [← analyticWithinAt_univ]\n  exact h.analyticWithinAt\n\n"}
{"name":"AnalyticAt.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\ninst✝ : CompleteSpace F\nh : AnalyticAt 𝕜 f x\n⊢ ContDiffAt 𝕜 n f x","decl":"/-- In a complete space, a function which is analytic at a point is also `C^ω` there.\nNote that the same statement for `AnalyticOn` does not require completeness, see\n`AnalyticOn.contDiffOn`. -/\ntheorem AnalyticAt.contDiffAt [CompleteSpace F] (h : AnalyticAt 𝕜 f x) :\n    ContDiffAt 𝕜 n f x := by\n  rw [← contDiffWithinAt_univ]\n  rw [← analyticWithinAt_univ] at h\n  exact h.contDiffWithinAt\n\n"}
{"name":"contDiffWithinAt_compl_self","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\n⊢ Iff (ContDiffWithinAt 𝕜 n f (HasCompl.compl (Singleton.singleton x)) x) (ContDiffAt 𝕜 n f x)","decl":"@[simp]\ntheorem contDiffWithinAt_compl_self :\n    ContDiffWithinAt 𝕜 n f {x}ᶜ x ↔ ContDiffAt 𝕜 n f x := by\n  rw [compl_eq_univ_diff, contDiffWithinAt_diff_singleton, contDiffWithinAt_univ]\n\n"}
{"name":"ContDiffAt.differentiableAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffAt 𝕜 n f x\nhn : LE.le 1 n\n⊢ DifferentiableAt 𝕜 f x","decl":"/-- If a function is `C^n` with `n ≥ 1` at a point, then it is differentiable there. -/\ntheorem ContDiffAt.differentiableAt (h : ContDiffAt 𝕜 n f x) (hn : 1 ≤ n) :\n    DifferentiableAt 𝕜 f x := by\n  simpa [hn, differentiableWithinAt_univ] using h.differentiableWithinAt\n\n"}
{"name":"ContDiffAt.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nm n : WithTop ENat\nh : ContDiffAt 𝕜 n f x\nhm : LE.le m n\nh' : Eq m ↑Top.top → Eq n Top.top\n⊢ Exists fun u => And (Membership.mem (nhds x) u) (ContDiffOn 𝕜 m f u)","decl":"nonrec lemma ContDiffAt.contDiffOn (h : ContDiffAt 𝕜 n f x) (hm : m ≤ n) (h' : m = ∞ → n = ω):\n    ∃ u ∈ 𝓝 x, ContDiffOn 𝕜 m f u := by\n  simpa [nhdsWithin_univ] using h.contDiffOn hm h'\n\n"}
{"name":"contDiffAt_succ_iff_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : Nat\n⊢ Iff (ContDiffAt 𝕜 (HAdd.hAdd (↑n) 1) f x) (Exists fun f' => And (Exists fun u => And (Membership.mem (nhds x) u) (∀ (x : E), Membership.mem u x → HasFDerivAt f (f' x) x)) (ContDiffAt 𝕜 (↑n) f' x))","decl":"/-- A function is `C^(n + 1)` at a point iff locally, it has a derivative which is `C^n`. -/\ntheorem contDiffAt_succ_iff_hasFDerivAt {n : ℕ} :\n    ContDiffAt 𝕜 (n + 1) f x ↔ ∃ f' : E → E →L[𝕜] F,\n      (∃ u ∈ 𝓝 x, ∀ x ∈ u, HasFDerivAt f (f' x) x) ∧ ContDiffAt 𝕜 n f' x := by\n  rw [← contDiffWithinAt_univ, contDiffWithinAt_succ_iff_hasFDerivWithinAt (by simp)]\n  simp only [nhdsWithin_univ, exists_prop, mem_univ, insert_eq_of_mem]\n  constructor\n  · rintro ⟨u, H, -, f', h_fderiv, h_cont_diff⟩\n    rcases mem_nhds_iff.mp H with ⟨t, htu, ht, hxt⟩\n    refine ⟨f', ⟨t, ?_⟩, h_cont_diff.contDiffAt H⟩\n    refine ⟨mem_nhds_iff.mpr ⟨t, Subset.rfl, ht, hxt⟩, ?_⟩\n    intro y hyt\n    refine (h_fderiv y (htu hyt)).hasFDerivAt ?_\n    exact mem_nhds_iff.mpr ⟨t, htu, ht, hyt⟩\n  · rintro ⟨f', ⟨u, H, h_fderiv⟩, h_cont_diff⟩\n    refine ⟨u, H, by simp, f', fun x hxu ↦ ?_, h_cont_diff.contDiffWithinAt⟩\n    exact (h_fderiv x hxu).hasFDerivWithinAt\n\n"}
{"name":"ContDiffAt.eventually","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiffAt 𝕜 n f x\nh' : Ne n ↑Top.top\n⊢ Filter.Eventually (fun y => ContDiffAt 𝕜 n f y) (nhds x)","decl":"protected theorem ContDiffAt.eventually (h : ContDiffAt 𝕜 n f x) (h' : n ≠ ∞) :\n    ∀ᶠ y in 𝓝 x, ContDiffAt 𝕜 n f y := by\n  simpa [nhdsWithin_univ] using ContDiffWithinAt.eventually h h'\n\n"}
{"name":"iteratedFDerivWithin_eq_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : Nat\nhs : UniqueDiffOn 𝕜 s\nh : ContDiffAt 𝕜 (↑n) f x\nhx : Membership.mem s x\n⊢ Eq (iteratedFDerivWithin 𝕜 n f s x) (iteratedFDeriv 𝕜 n f x)","decl":"theorem iteratedFDerivWithin_eq_iteratedFDeriv {n : ℕ}\n    (hs : UniqueDiffOn 𝕜 s) (h : ContDiffAt 𝕜 n f x) (hx : x ∈ s) :\n    iteratedFDerivWithin 𝕜 n f s x = iteratedFDeriv 𝕜 n f x := by\n  rw [← iteratedFDerivWithin_univ]\n  rcases h.contDiffOn' le_rfl (by simp) with ⟨u, u_open, xu, hu⟩\n  rw [← iteratedFDerivWithin_inter_open u_open xu,\n    ← iteratedFDerivWithin_inter_open u_open xu (s := univ)]\n  apply iteratedFDerivWithin_subset\n  · exact inter_subset_inter_left _ (subset_univ _)\n  · exact hs.inter u_open\n  · apply uniqueDiffOn_univ.inter u_open\n  · simpa using hu\n  · exact ⟨hx, xu⟩\n\n"}
{"name":"HasFTaylorSeriesUpTo.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : ENat\nf' : E → FormalMultilinearSeries 𝕜 E F\nhf : HasFTaylorSeriesUpTo (↑n) f f'\n⊢ ContDiff 𝕜 (↑n) f","decl":"/-- If `f` has a Taylor series up to `n`, then it is `C^n`. -/\ntheorem HasFTaylorSeriesUpTo.contDiff {n : ℕ∞} {f' : E → FormalMultilinearSeries 𝕜 E F}\n    (hf : HasFTaylorSeriesUpTo n f f') : ContDiff 𝕜 n f :=\n  ⟨f', hf⟩\n\n"}
{"name":"contDiffOn_univ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\n⊢ Iff (ContDiffOn 𝕜 n f Set.univ) (ContDiff 𝕜 n f)","decl":"theorem contDiffOn_univ : ContDiffOn 𝕜 n f univ ↔ ContDiff 𝕜 n f := by\n  match n with\n  | ω =>\n    constructor\n    · intro H\n      use ftaylorSeriesWithin 𝕜 f univ\n      rw [← hasFTaylorSeriesUpToOn_univ_iff]\n      refine ⟨H.ftaylorSeriesWithin uniqueDiffOn_univ, fun i ↦ ?_⟩\n      rw [← analyticOn_univ]\n      exact H.analyticOn.iteratedFDerivWithin uniqueDiffOn_univ _\n    · rintro ⟨p, hp, h'p⟩ x _\n      exact ⟨univ, Filter.univ_sets _, p, (hp.hasFTaylorSeriesUpToOn univ).of_le le_top,\n        fun i ↦ (h'p i).analyticOn⟩\n  | (n : ℕ∞) =>\n    constructor\n    · intro H\n      use ftaylorSeriesWithin 𝕜 f univ\n      rw [← hasFTaylorSeriesUpToOn_univ_iff]\n      exact H.ftaylorSeriesWithin uniqueDiffOn_univ\n    · rintro ⟨p, hp⟩ x _ m hm\n      exact ⟨univ, Filter.univ_sets _, p,\n        (hp.hasFTaylorSeriesUpToOn univ).of_le (mod_cast hm)⟩\n\n"}
{"name":"contDiff_iff_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\n⊢ Iff (ContDiff 𝕜 n f) (∀ (x : E), ContDiffAt 𝕜 n f x)","decl":"theorem contDiff_iff_contDiffAt : ContDiff 𝕜 n f ↔ ∀ x, ContDiffAt 𝕜 n f x := by\n  simp [← contDiffOn_univ, ContDiffOn, ContDiffAt]\n\n"}
{"name":"ContDiff.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiff 𝕜 n f\n⊢ ContDiffAt 𝕜 n f x","decl":"theorem ContDiff.contDiffAt (h : ContDiff 𝕜 n f) : ContDiffAt 𝕜 n f x :=\n  contDiff_iff_contDiffAt.1 h x\n\n"}
{"name":"ContDiff.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\nh : ContDiff 𝕜 n f\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"theorem ContDiff.contDiffWithinAt (h : ContDiff 𝕜 n f) : ContDiffWithinAt 𝕜 n f s x :=\n  h.contDiffAt.contDiffWithinAt\n\n"}
{"name":"contDiff_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f) (∀ (n : Nat), ContDiff 𝕜 (↑n) f)","decl":"theorem contDiff_infty : ContDiff 𝕜 ∞ f ↔ ∀ n : ℕ, ContDiff 𝕜 n f := by\n  simp [contDiffOn_univ.symm, contDiffOn_infty]\n\n"}
{"name":"contDiff_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f) (∀ (n : Nat), ContDiff 𝕜 (↑n) f)","decl":"@[deprecated (since := \"2024-11-25\")] alias contDiff_top := contDiff_infty\n\n"}
{"name":"contDiff_infty_iff_contDiff_omega","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f) (∀ (n : Nat), ContDiff 𝕜 (↑n) f)","decl":"@[deprecated (since := \"2024-11-25\")] alias contDiff_infty_iff_contDiff_omega := contDiff_infty\n\n"}
{"name":"contDiff_all_iff_nat","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (∀ (n : ENat), ContDiff 𝕜 (↑n) f) (∀ (n : Nat), ContDiff 𝕜 (↑n) f)","decl":"theorem contDiff_all_iff_nat : (∀ n : ℕ∞, ContDiff 𝕜 n f) ↔ ∀ n : ℕ, ContDiff 𝕜 n f := by\n  simp only [← contDiffOn_univ, contDiffOn_all_iff_nat]\n\n"}
{"name":"ContDiff.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 n f\n⊢ ContDiffOn 𝕜 n f s","decl":"theorem ContDiff.contDiffOn (h : ContDiff 𝕜 n f) : ContDiffOn 𝕜 n f s :=\n  (contDiffOn_univ.2 h).mono (subset_univ _)\n\n"}
{"name":"contDiff_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 0 f) (Continuous f)","decl":"@[simp]\ntheorem contDiff_zero : ContDiff 𝕜 0 f ↔ Continuous f := by\n  rw [← contDiffOn_univ, continuous_iff_continuousOn_univ]\n  exact contDiffOn_zero\n\n"}
{"name":"contDiffAt_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (ContDiffAt 𝕜 0 f x) (Exists fun u => And (Membership.mem (nhds x) u) (ContinuousOn f u))","decl":"theorem contDiffAt_zero : ContDiffAt 𝕜 0 f x ↔ ∃ u ∈ 𝓝 x, ContinuousOn f u := by\n  rw [← contDiffWithinAt_univ]; simp [contDiffWithinAt_zero, nhdsWithin_univ]\n\n"}
{"name":"contDiffAt_one_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\n⊢ Iff (ContDiffAt 𝕜 1 f x) (Exists fun f' => Exists fun u => And (Membership.mem (nhds x) u) (And (ContinuousOn f' u) (∀ (x : E), Membership.mem u x → HasFDerivAt f (f' x) x)))","decl":"theorem contDiffAt_one_iff :\n    ContDiffAt 𝕜 1 f x ↔\n      ∃ f' : E → E →L[𝕜] F, ∃ u ∈ 𝓝 x, ContinuousOn f' u ∧ ∀ x ∈ u, HasFDerivAt f (f' x) x := by\n  rw [show (1 : WithTop ℕ∞) = (0 : ℕ) + 1 from rfl]\n  simp_rw [contDiffAt_succ_iff_hasFDerivAt, show ((0 : ℕ) : WithTop ℕ∞) = 0 from rfl,\n    contDiffAt_zero, exists_mem_and_iff antitone_bforall antitone_continuousOn, and_comm]\n\n"}
{"name":"ContDiff.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nm n : WithTop ENat\nh : ContDiff 𝕜 n f\nhmn : LE.le m n\n⊢ ContDiff 𝕜 m f","decl":"theorem ContDiff.of_le (h : ContDiff 𝕜 n f) (hmn : m ≤ n) : ContDiff 𝕜 m f :=\n  contDiffOn_univ.1 <| (contDiffOn_univ.2 h).of_le hmn\n\n"}
{"name":"ContDiff.of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 (HAdd.hAdd n 1) f\n⊢ ContDiff 𝕜 n f","decl":"theorem ContDiff.of_succ (h : ContDiff 𝕜 (n + 1) f) : ContDiff 𝕜 n f :=\n  h.of_le le_self_add\n\n"}
{"name":"ContDiff.one_of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 (HAdd.hAdd n 1) f\n⊢ ContDiff 𝕜 1 f","decl":"theorem ContDiff.one_of_succ (h : ContDiff 𝕜 (n + 1) f) : ContDiff 𝕜 1 f := by\n  apply h.of_le le_add_self\n\n"}
{"name":"ContDiff.continuous","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 n f\n⊢ Continuous f","decl":"theorem ContDiff.continuous (h : ContDiff 𝕜 n f) : Continuous f :=\n  contDiff_zero.1 (h.of_le bot_le)\n\n"}
{"name":"ContDiff.differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 n f\nhn : LE.le 1 n\n⊢ Differentiable 𝕜 f","decl":"/-- If a function is `C^n` with `n ≥ 1`, then it is differentiable. -/\ntheorem ContDiff.differentiable (h : ContDiff 𝕜 n f) (hn : 1 ≤ n) : Differentiable 𝕜 f :=\n  differentiableOn_univ.1 <| (contDiffOn_univ.2 h).differentiableOn hn\n\n"}
{"name":"contDiff_iff_forall_nat_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : ENat\n⊢ Iff (ContDiff 𝕜 (↑n) f) (∀ (m : Nat), LE.le (↑m) n → ContDiff 𝕜 (↑m) f)","decl":"theorem contDiff_iff_forall_nat_le {n : ℕ∞} :\n    ContDiff 𝕜 n f ↔ ∀ m : ℕ, ↑m ≤ n → ContDiff 𝕜 m f := by\n  simp_rw [← contDiffOn_univ]; exact contDiffOn_iff_forall_nat_le\n\n"}
{"name":"contDiff_succ_iff_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : Nat\n⊢ Iff (ContDiff 𝕜 (HAdd.hAdd (↑n) 1) f) (Exists fun f' => And (ContDiff 𝕜 (↑n) f') (∀ (x : E), HasFDerivAt f (f' x) x))","decl":"/-- A function is `C^(n+1)` iff it has a `C^n` derivative. -/\ntheorem contDiff_succ_iff_hasFDerivAt {n : ℕ} :\n    ContDiff 𝕜 (n + 1) f ↔\n      ∃ f' : E → E →L[𝕜] F, ContDiff 𝕜 n f' ∧ ∀ x, HasFDerivAt f (f' x) x := by\n  simp only [← contDiffOn_univ, ← hasFDerivWithinAt_univ, Set.mem_univ, forall_true_left,\n    contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn uniqueDiffOn_univ,\n    WithTop.natCast_ne_top, analyticOn_univ, false_implies, true_and]\n\n"}
{"name":"contDiff_one_iff_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 1 f) (Exists fun f' => And (Continuous f') (∀ (x : E), HasFDerivAt f (f' x) x))","decl":"theorem contDiff_one_iff_hasFDerivAt : ContDiff 𝕜 1 f ↔\n    ∃ f' : E → E →L[𝕜] F, Continuous f' ∧ ∀ x, HasFDerivAt f (f' x) x := by\n  convert contDiff_succ_iff_hasFDerivAt using 4; simp\n\n"}
{"name":"AnalyticOn.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nhf : AnalyticOn 𝕜 f Set.univ\n⊢ ContDiff 𝕜 n f","decl":"theorem AnalyticOn.contDiff (hf : AnalyticOn 𝕜 f univ) : ContDiff 𝕜 n f := by\n  rw [← contDiffOn_univ]\n  exact hf.contDiffOn (n := n) uniqueDiffOn_univ\n\n"}
{"name":"AnalyticOnNhd.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nhf : AnalyticOnNhd 𝕜 f Set.univ\n⊢ ContDiff 𝕜 n f","decl":"theorem AnalyticOnNhd.contDiff (hf : AnalyticOnNhd 𝕜 f univ) : ContDiff 𝕜 n f :=\n  hf.analyticOn.contDiff\n\n"}
{"name":"ContDiff.analyticOnNhd","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nh : ContDiff 𝕜 Top.top f\n⊢ AnalyticOnNhd 𝕜 f s","decl":"theorem ContDiff.analyticOnNhd (h : ContDiff 𝕜 ω f) : AnalyticOnNhd 𝕜 f s := by\n  rw [← contDiffOn_univ] at h\n  have := h.analyticOn\n  rw [analyticOn_univ] at this\n  exact this.mono (subset_univ _)\n\n"}
{"name":"contDiff_omega_iff_analyticOnNhd","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 Top.top f) (AnalyticOnNhd 𝕜 f Set.univ)","decl":"theorem contDiff_omega_iff_analyticOnNhd :\n    ContDiff 𝕜 ω f ↔ AnalyticOnNhd 𝕜 f univ :=\n  ⟨fun h ↦ h.analyticOnNhd, fun h ↦ h.contDiff⟩\n\n"}
{"name":"ContDiff.ftaylorSeries","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nhf : ContDiff 𝕜 n f\n⊢ HasFTaylorSeriesUpTo n f (ftaylorSeries 𝕜 f)","decl":"/-- When a function is `C^n`, it admits `ftaylorSeries 𝕜 f` as a Taylor series up\nto order `n` in `s`. -/\ntheorem ContDiff.ftaylorSeries (hf : ContDiff 𝕜 n f) :\n    HasFTaylorSeriesUpTo n f (ftaylorSeries 𝕜 f) := by\n  simp only [← contDiffOn_univ, ← hasFTaylorSeriesUpToOn_univ_iff, ← ftaylorSeriesWithin_univ]\n    at hf ⊢\n  exact ContDiffOn.ftaylorSeriesWithin hf uniqueDiffOn_univ\n\n"}
{"name":"contDiff_iff_ftaylorSeries","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : ENat\n⊢ Iff (ContDiff 𝕜 (↑n) f) (HasFTaylorSeriesUpTo (↑n) f (ftaylorSeries 𝕜 f))","decl":"/-- For `n : ℕ∞`, a function is `C^n` iff it admits `ftaylorSeries 𝕜 f`\nas a Taylor series up to order `n`. -/\ntheorem contDiff_iff_ftaylorSeries {n : ℕ∞} :\n    ContDiff 𝕜 n f ↔ HasFTaylorSeriesUpTo n f (ftaylorSeries 𝕜 f) := by\n  constructor\n  · rw [← contDiffOn_univ, ← hasFTaylorSeriesUpToOn_univ_iff, ← ftaylorSeriesWithin_univ]\n    exact fun h ↦ ContDiffOn.ftaylorSeriesWithin h uniqueDiffOn_univ\n  · exact fun h ↦ ⟨ftaylorSeries 𝕜 f, h⟩\n\n"}
{"name":"contDiff_iff_continuous_differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : ENat\n⊢ Iff (ContDiff 𝕜 (↑n) f) (And (∀ (m : Nat), LE.le (↑m) n → Continuous fun x => iteratedFDeriv 𝕜 m f x) (∀ (m : Nat), LT.lt (↑m) n → Differentiable 𝕜 fun x => iteratedFDeriv 𝕜 m f x))","decl":"theorem contDiff_iff_continuous_differentiable {n : ℕ∞} :\n    ContDiff 𝕜 n f ↔\n      (∀ m : ℕ, m ≤ n → Continuous fun x => iteratedFDeriv 𝕜 m f x) ∧\n        ∀ m : ℕ, m < n → Differentiable 𝕜 fun x => iteratedFDeriv 𝕜 m f x := by\n  simp [contDiffOn_univ.symm, continuous_iff_continuousOn_univ, differentiableOn_univ.symm,\n    iteratedFDerivWithin_univ, contDiffOn_iff_continuousOn_differentiableOn uniqueDiffOn_univ]\n\n"}
{"name":"contDiff_nat_iff_continuous_differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : Nat\n⊢ Iff (ContDiff 𝕜 (↑n) f) (And (∀ (m : Nat), LE.le m n → Continuous fun x => iteratedFDeriv 𝕜 m f x) (∀ (m : Nat), LT.lt m n → Differentiable 𝕜 fun x => iteratedFDeriv 𝕜 m f x))","decl":"theorem contDiff_nat_iff_continuous_differentiable {n : ℕ} :\n    ContDiff 𝕜 n f ↔\n      (∀ m : ℕ, m ≤ n → Continuous fun x => iteratedFDeriv 𝕜 m f x) ∧\n        ∀ m : ℕ, m < n → Differentiable 𝕜 fun x => iteratedFDeriv 𝕜 m f x := by\n  rw [show n = ((n : ℕ∞) : WithTop ℕ∞) from rfl, contDiff_iff_continuous_differentiable]\n  simp\n\n"}
{"name":"ContDiff.continuous_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nm : Nat\nhm : LE.le (↑m) n\nhf : ContDiff 𝕜 n f\n⊢ Continuous fun x => iteratedFDeriv 𝕜 m f x","decl":"/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m ≤ n`. -/\ntheorem ContDiff.continuous_iteratedFDeriv {m : ℕ} (hm : m ≤ n) (hf : ContDiff 𝕜 n f) :\n    Continuous fun x => iteratedFDeriv 𝕜 m f x :=\n  (contDiff_iff_continuous_differentiable.mp (hf.of_le hm)).1 m le_rfl\n\n"}
{"name":"ContDiff.differentiable_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nm : Nat\nhm : LT.lt (↑m) n\nhf : ContDiff 𝕜 n f\n⊢ Differentiable 𝕜 fun x => iteratedFDeriv 𝕜 m f x","decl":"/-- If `f` is `C^n` then its `m`-times iterated derivative is differentiable for `m < n`. -/\ntheorem ContDiff.differentiable_iteratedFDeriv {m : ℕ} (hm : m < n) (hf : ContDiff 𝕜 n f) :\n    Differentiable 𝕜 fun x => iteratedFDeriv 𝕜 m f x :=\n  (contDiff_iff_continuous_differentiable.mp\n    (hf.of_le (ENat.add_one_natCast_le_withTop_of_lt hm))).2 m (mod_cast lt_add_one m)\n\n"}
{"name":"contDiff_of_differentiable_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : ENat\nh : ∀ (m : Nat), LE.le (↑m) n → Differentiable 𝕜 (iteratedFDeriv 𝕜 m f)\n⊢ ContDiff 𝕜 (↑n) f","decl":"theorem contDiff_of_differentiable_iteratedFDeriv {n : ℕ∞}\n    (h : ∀ m : ℕ, m ≤ n → Differentiable 𝕜 (iteratedFDeriv 𝕜 m f)) : ContDiff 𝕜 n f :=\n  contDiff_iff_continuous_differentiable.2\n    ⟨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)⟩\n\n"}
{"name":"contDiff_succ_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\n⊢ Iff (ContDiff 𝕜 (HAdd.hAdd n 1) f) (And (Differentiable 𝕜 f) (And (Eq n Top.top → AnalyticOnNhd 𝕜 f Set.univ) (ContDiff 𝕜 n (fderiv 𝕜 f))))","decl":"/-- A function is `C^(n + 1)` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^n`. -/\ntheorem contDiff_succ_iff_fderiv :\n    ContDiff 𝕜 (n + 1) f ↔ Differentiable 𝕜 f ∧ (n = ω → AnalyticOnNhd 𝕜 f univ) ∧\n      ContDiff 𝕜 n (fderiv 𝕜 f) := by\n  simp only [← contDiffOn_univ, ← differentiableOn_univ, ← fderivWithin_univ,\n    contDiffOn_succ_iff_fderivWithin uniqueDiffOn_univ, analyticOn_univ]\n\n"}
{"name":"contDiff_one_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 1 f) (And (Differentiable 𝕜 f) (Continuous (fderiv 𝕜 f)))","decl":"theorem contDiff_one_iff_fderiv :\n    ContDiff 𝕜 1 f ↔ Differentiable 𝕜 f ∧ Continuous (fderiv 𝕜 f) := by\n  rw [show (1 : WithTop ℕ∞) = 0 + 1 from rfl, contDiff_succ_iff_fderiv]\n  simp\n\n"}
{"name":"contDiff_infty_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f) (And (Differentiable 𝕜 f) (ContDiff 𝕜 (↑Top.top) (fderiv 𝕜 f)))","decl":"theorem contDiff_infty_iff_fderiv :\n    ContDiff 𝕜 ∞ f ↔ Differentiable 𝕜 f ∧ ContDiff 𝕜 ∞ (fderiv 𝕜 f) := by\n  rw [show ∞ = ∞ + 1 from rfl, contDiff_succ_iff_fderiv]\n  simp\n\n"}
{"name":"contDiff_top_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f) (And (Differentiable 𝕜 f) (ContDiff 𝕜 (↑Top.top) (fderiv 𝕜 f)))","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiff_top_iff_fderiv := contDiff_infty_iff_fderiv\n\n"}
{"name":"ContDiff.continuous_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 n f\nhn : LE.le 1 n\n⊢ Continuous (fderiv 𝕜 f)","decl":"theorem ContDiff.continuous_fderiv (h : ContDiff 𝕜 n f) (hn : 1 ≤ n) :\n    Continuous (fderiv 𝕜 f) :=\n  (contDiff_one_iff_fderiv.1 (h.of_le hn)).2\n\n"}
{"name":"ContDiff.continuous_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"𝕜 : Type u\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nh : ContDiff 𝕜 n f\nhn : LE.le 1 n\n⊢ Continuous fun p => (fderiv 𝕜 f p.1) p.2","decl":"/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem ContDiff.continuous_fderiv_apply (h : ContDiff 𝕜 n f) (hn : 1 ≤ n) :\n    Continuous fun p : E × E => (fderiv 𝕜 f p.1 : E → F) p.2 :=\n  have A : Continuous fun q : (E →L[𝕜] F) × E => q.1 q.2 := isBoundedBilinearMap_apply.continuous\n  have B : Continuous fun p : E × E => (fderiv 𝕜 f p.1, p.2) :=\n    ((h.continuous_fderiv hn).comp continuous_fst).prod_mk continuous_snd\n  A.comp B\n"}
