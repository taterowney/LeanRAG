{"name":"HasFTaylorSeriesUpToOn.analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhf : HasFTaylorSeriesUpToOn Top.top f p s\nh : AnalyticOn ğ•œ (fun x => p x 0) s\nâŠ¢ AnalyticOn ğ•œ f s","decl":"lemma HasFTaylorSeriesUpToOn.analyticOn\n    (hf : HasFTaylorSeriesUpToOn Ï‰ f p s) (h : AnalyticOn ğ•œ (fun x â†¦ p x 0) s) :\n    AnalyticOn ğ•œ f s := by\n  have : AnalyticOn ğ•œ (fun x â†¦ (continuousMultilinearCurryFin0 ğ•œ E F) (p x 0)) s :=\n    (LinearIsometryEquiv.analyticOnNhd _ _ ).comp_analyticOn\n      h (Set.mapsTo_univ _ _)\n  exact this.congr (fun y hy â†¦ (hf.zero_eq _ hy).symm)\n\n"}
{"name":"ContDiffWithinAt.analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nh : ContDiffWithinAt ğ•œ Top.top f s x\nâŠ¢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (AnalyticOn ğ•œ f u)","decl":"lemma ContDiffWithinAt.analyticOn (h : ContDiffWithinAt ğ•œ Ï‰ f s x) :\n    âˆƒ u âˆˆ ğ“[insert x s] x, AnalyticOn ğ•œ f u := by\n  obtain âŸ¨u, hu, p, hp, h'pâŸ© := h\n  exact âŸ¨u, hu, hp.analyticOn (h'p 0)âŸ©\n\n"}
{"name":"ContDiffWithinAt.analyticWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nh : ContDiffWithinAt ğ•œ Top.top f s x\nâŠ¢ AnalyticWithinAt ğ•œ f s x","decl":"lemma ContDiffWithinAt.analyticWithinAt (h : ContDiffWithinAt ğ•œ Ï‰ f s x) :\n    AnalyticWithinAt ğ•œ f s x := by\n  obtain âŸ¨u, hu, hfâŸ© := h.analyticOn\n  have xu : x âˆˆ u := mem_of_mem_nhdsWithin (by simp) hu\n  exact (hf x xu).mono_of_mem_nhdsWithin (nhdsWithin_mono _ (subset_insert _ _) hu)\n\n"}
{"name":"contDiffWithinAt_omega_iff_analyticWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\ninstâœ : CompleteSpace F\nâŠ¢ Iff (ContDiffWithinAt ğ•œ Top.top f s x) (AnalyticWithinAt ğ•œ f s x)","decl":"theorem contDiffWithinAt_omega_iff_analyticWithinAt [CompleteSpace F] :\n    ContDiffWithinAt ğ•œ Ï‰ f s x â†” AnalyticWithinAt ğ•œ f s x := by\n  refine âŸ¨fun h â†¦ h.analyticWithinAt, fun h â†¦ ?_âŸ©\n  obtain âŸ¨u, hu, p, hp, h'pâŸ© := h.exists_hasFTaylorSeriesUpToOn Ï‰\n  exact âŸ¨u, hu, p, hp.of_le le_top, fun i â†¦ h'p iâŸ©\n\n"}
{"name":"contDiffWithinAt_nat","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nâŠ¢ Iff (ContDiffWithinAt ğ•œ (â†‘n) f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (Exists fun p => HasFTaylorSeriesUpToOn (â†‘n) f p u))","decl":"theorem contDiffWithinAt_nat {n : â„•} :\n    ContDiffWithinAt ğ•œ n f s x â†” âˆƒ u âˆˆ ğ“[insert x s] x,\n      âˆƒ p : E â†’ FormalMultilinearSeries ğ•œ E F, HasFTaylorSeriesUpToOn n f p u :=\n  âŸ¨fun H => H n le_rfl, fun âŸ¨u, hu, p, hpâŸ© _m hm => âŸ¨u, hu, p, hp.of_le (mod_cast hm)âŸ©âŸ©\n\n"}
{"name":"contDiffWithinAt_iff_of_ne_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (Exists fun p => And (HasFTaylorSeriesUpToOn n f p u) (Eq n Top.top â†’ âˆ€ (i : Nat), AnalyticOn ğ•œ (fun x => p x i) u)))","decl":"/-- When `n` is either a natural number or `Ï‰`, one can characterize the property of being `C^n`\nas the existence of a neighborhood on which there is a Taylor series up to order `n`,\nrequiring in addition that its terms are analytic in the `Ï‰` case. -/\nlemma contDiffWithinAt_iff_of_ne_infty (hn : n â‰  âˆ) :\n    ContDiffWithinAt ğ•œ n f s x â†” âˆƒ u âˆˆ ğ“[insert x s] x,\n      âˆƒ p : E â†’ FormalMultilinearSeries ğ•œ E F, HasFTaylorSeriesUpToOn n f p u âˆ§\n        (n = Ï‰ â†’ âˆ€ i, AnalyticOn ğ•œ (fun x â†¦ p x i) u) := by\n  match n with\n  | Ï‰ => simp [ContDiffWithinAt]\n  | âˆ => simp at hn\n  | (n : â„•) => simp [contDiffWithinAt_nat]\n\n"}
{"name":"ContDiffWithinAt.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nm n : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhmn : LE.le m n\nâŠ¢ ContDiffWithinAt ğ•œ m f s x","decl":"theorem ContDiffWithinAt.of_le (h : ContDiffWithinAt ğ•œ n f s x) (hmn : m â‰¤ n) :\n    ContDiffWithinAt ğ•œ m f s x := by\n  match n with\n  | Ï‰ => match m with\n    | Ï‰ => exact h\n    | (m : â„•âˆ) =>\n      intro k _\n      obtain âŸ¨u, hu, p, hp, -âŸ© := h\n      exact âŸ¨u, hu, p, hp.of_le le_topâŸ©\n  | (n : â„•âˆ) => match m with\n    | Ï‰ => simp at hmn\n    | (m : â„•âˆ) => exact fun k hk â†¦ h k (le_trans hk (mod_cast hmn))\n\n"}
{"name":"AnalyticWithinAt.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ninstâœ : CompleteSpace F\nh : AnalyticWithinAt ğ•œ f s x\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"/-- In a complete space, a function which is analytic within a set at a point is also `C^Ï‰` there.\nNote that the same statement for `AnalyticOn` does not require completeness, see\n`AnalyticOn.contDiffOn`. -/\ntheorem AnalyticWithinAt.contDiffWithinAt [CompleteSpace F] (h : AnalyticWithinAt ğ•œ f s x) :\n    ContDiffWithinAt ğ•œ n f s x :=\n  (contDiffWithinAt_omega_iff_analyticWithinAt.2 h).of_le le_top\n\n"}
{"name":"contDiffWithinAt_iff_forall_nat_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : ENat\nâŠ¢ Iff (ContDiffWithinAt ğ•œ (â†‘n) f s x) (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContDiffWithinAt ğ•œ (â†‘m) f s x)","decl":"theorem contDiffWithinAt_iff_forall_nat_le {n : â„•âˆ} :\n    ContDiffWithinAt ğ•œ n f s x â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ ContDiffWithinAt ğ•œ m f s x :=\n  âŸ¨fun H _ hm => H.of_le (mod_cast hm), fun H m hm => H m hm _ le_rflâŸ©\n\n"}
{"name":"contDiffWithinAt_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nâŠ¢ Iff (ContDiffWithinAt ğ•œ (â†‘Top.top) f s x) (âˆ€ (n : Nat), ContDiffWithinAt ğ•œ (â†‘n) f s x)","decl":"theorem contDiffWithinAt_infty :\n    ContDiffWithinAt ğ•œ âˆ f s x â†” âˆ€ n : â„•, ContDiffWithinAt ğ•œ n f s x :=\n  contDiffWithinAt_iff_forall_nat_le.trans <| by simp only [forall_prop_of_true, le_top]\n\n"}
{"name":"contDiffWithinAt_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nâŠ¢ Iff (ContDiffWithinAt ğ•œ (â†‘Top.top) f s x) (âˆ€ (n : Nat), ContDiffWithinAt ğ•œ (â†‘n) f s x)","decl":"@[deprecated (since := \"2024-11-25\")] alias contDiffWithinAt_top := contDiffWithinAt_infty\n\n"}
{"name":"ContDiffWithinAt.continuousWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContinuousWithinAt f s x","decl":"theorem ContDiffWithinAt.continuousWithinAt (h : ContDiffWithinAt ğ•œ n f s x) :\n    ContinuousWithinAt f s x := by\n  have := h.of_le (zero_le _)\n  simp only [ContDiffWithinAt, nonpos_iff_eq_zero, Nat.cast_eq_zero,\n    mem_pure, forall_eq, CharP.cast_eq_zero] at this\n  rcases this with âŸ¨u, hu, p, HâŸ©\n  rw [mem_nhdsWithin_insert] at hu\n  exact (H.continuousOn.continuousWithinAt hu.1).mono_of_mem_nhdsWithin hu.2\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"theorem ContDiffWithinAt.congr_of_eventuallyEq (h : ContDiffWithinAt ğ•œ n f s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) : ContDiffWithinAt ğ•œ n fâ‚ s x := by\n  match n with\n  | Ï‰ =>\n    obtain âŸ¨u, hu, p, H, H'âŸ© := h\n    exact âŸ¨{x âˆˆ u | fâ‚ x = f x}, Filter.inter_mem hu (mem_nhdsWithin_insert.2 âŸ¨hx, hâ‚âŸ©), p,\n      (H.mono (sep_subset _ _)).congr fun _ â†¦ And.right,\n      fun i â†¦ (H' i).mono (sep_subset _ _)âŸ©\n  | (n : â„•âˆ) =>\n    intro m hm\n    let âŸ¨u, hu, p, HâŸ© := h m hm\n    exact âŸ¨{ x âˆˆ u | fâ‚ x = f x }, Filter.inter_mem hu (mem_nhdsWithin_insert.2 âŸ¨hx, hâ‚âŸ©), p,\n      (H.mono (sep_subset _ _)).congr fun _ â†¦ And.rightâŸ©\n\n"}
{"name":"Filter.EventuallyEq.congr_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem Filter.EventuallyEq.congr_contDiffWithinAt (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : fâ‚ x = f x) :\n    ContDiffWithinAt ğ•œ n fâ‚ s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  âŸ¨fun H â†¦ H.congr_of_eventuallyEq hâ‚.symm hx.symm, fun H â†¦ H.congr_of_eventuallyEq hâ‚ hxâŸ©\n\n"}
{"name":"Filter.EventuallyEq.contDiffWithinAt_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"@[deprecated (since := \"2024-10-18\")]\nalias Filter.EventuallyEq.contDiffWithinAt_iff := Filter.EventuallyEq.congr_contDiffWithinAt\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventuallyEq_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : (nhdsWithin x (Insert.insert x s)).EventuallyEq fâ‚ f\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"theorem ContDiffWithinAt.congr_of_eventuallyEq_insert (h : ContDiffWithinAt ğ•œ n f s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[insert x s] x] f) : ContDiffWithinAt ğ•œ n fâ‚ s x :=\n  h.congr_of_eventuallyEq (nhdsWithin_mono x (subset_insert x s) hâ‚)\n    (mem_of_mem_nhdsWithin (mem_insert x s) hâ‚ :)\n\n"}
{"name":"Filter.EventuallyEq.congr_contDiffWithinAt_of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : (nhdsWithin x (Insert.insert x s)).EventuallyEq fâ‚ f\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem Filter.EventuallyEq.congr_contDiffWithinAt_of_insert (hâ‚ : fâ‚ =á¶ [ğ“[insert x s] x] f) :\n    ContDiffWithinAt ğ•œ n fâ‚ s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  âŸ¨fun H â†¦ H.congr_of_eventuallyEq_insert hâ‚.symm, fun H â†¦ H.congr_of_eventuallyEq_insert hâ‚âŸ©\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventuallyEq_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Membership.mem s x\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"theorem ContDiffWithinAt.congr_of_eventuallyEq_of_mem (h : ContDiffWithinAt ğ•œ n f s x)\n    (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s) : ContDiffWithinAt ğ•œ n fâ‚ s x :=\n  h.congr_of_eventuallyEq hâ‚ <| hâ‚.self_of_nhdsWithin hx\n\n"}
{"name":"ContDiffWithinAt.congr_of_eventually_eq'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Membership.mem s x\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.congr_of_eventually_eq' := ContDiffWithinAt.congr_of_eventuallyEq_of_mem\n\n"}
{"name":"Filter.EventuallyEq.congr_contDiffWithinAt_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : (nhdsWithin x s).EventuallyEq fâ‚ f\nhx : Membership.mem s x\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem Filter.EventuallyEq.congr_contDiffWithinAt_of_mem (hâ‚ : fâ‚ =á¶ [ğ“[s] x] f) (hx : x âˆˆ s):\n    ContDiffWithinAt ğ•œ n fâ‚ s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  âŸ¨fun H â†¦ H.congr_of_eventuallyEq_of_mem hâ‚.symm hx, fun H â†¦ H.congr_of_eventuallyEq_of_mem hâ‚ hxâŸ©\n\n"}
{"name":"ContDiffWithinAt.congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : âˆ€ (y : E), Membership.mem s y â†’ Eq (fâ‚ y) (f y)\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"theorem ContDiffWithinAt.congr (h : ContDiffWithinAt ğ•œ n f s x) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y)\n    (hx : fâ‚ x = f x) : ContDiffWithinAt ğ•œ n fâ‚ s x :=\n  h.congr_of_eventuallyEq (Filter.eventuallyEq_of_mem self_mem_nhdsWithin hâ‚) hx\n\n"}
{"name":"contDiffWithinAt_congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : âˆ€ (y : E), Membership.mem s y â†’ Eq (fâ‚ y) (f y)\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_congr (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : fâ‚ x = f x) :\n    ContDiffWithinAt ğ•œ n fâ‚ s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  âŸ¨fun h' â†¦ h'.congr (fun x hx â†¦ (hâ‚ x hx).symm) hx.symm, fun h' â†¦  h'.congr hâ‚ hxâŸ©\n\n"}
{"name":"ContDiffWithinAt.congr_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : âˆ€ (y : E), Membership.mem s y â†’ Eq (fâ‚ y) (f y)\nhx : Membership.mem s x\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"theorem ContDiffWithinAt.congr_of_mem (h : ContDiffWithinAt ğ•œ n f s x) (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y)\n    (hx : x âˆˆ s) : ContDiffWithinAt ğ•œ n fâ‚ s x :=\n  h.congr hâ‚ (hâ‚ _ hx)\n\n"}
{"name":"ContDiffWithinAt.congr'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : âˆ€ (y : E), Membership.mem s y â†’ Eq (fâ‚ y) (f y)\nhx : Membership.mem s x\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.congr' := ContDiffWithinAt.congr_of_mem\n\n"}
{"name":"contDiffWithinAt_congr_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : âˆ€ (y : E), Membership.mem s y â†’ Eq (fâ‚ y) (f y)\nhx : Membership.mem s x\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_congr_of_mem (hâ‚ : âˆ€ y âˆˆ s, fâ‚ y = f y) (hx : x âˆˆ s) :\n    ContDiffWithinAt ğ•œ n fâ‚ s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  contDiffWithinAt_congr hâ‚ (hâ‚ x hx)\n\n"}
{"name":"ContDiffWithinAt.congr_of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhâ‚ : âˆ€ (y : E), Membership.mem (Insert.insert x s) y â†’ Eq (fâ‚ y) (f y)\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ s x","decl":"theorem ContDiffWithinAt.congr_of_insert (h : ContDiffWithinAt ğ•œ n f s x)\n    (hâ‚ : âˆ€ y âˆˆ insert x s, fâ‚ y = f y) : ContDiffWithinAt ğ•œ n fâ‚ s x :=\n  h.congr (fun y hy â†¦ hâ‚ y (mem_insert_of_mem _ hy)) (hâ‚ x (mem_insert _ _))\n\n"}
{"name":"contDiffWithinAt_congr_of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nhâ‚ : âˆ€ (y : E), Membership.mem (Insert.insert x s) y â†’ Eq (fâ‚ y) (f y)\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n fâ‚ s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_congr_of_insert (hâ‚ : âˆ€ y âˆˆ insert x s, fâ‚ y = f y) :\n    ContDiffWithinAt ğ•œ n fâ‚ s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  contDiffWithinAt_congr (fun y hy â†¦ hâ‚ y (mem_insert_of_mem _ hy)) (hâ‚ x (mem_insert _ _))\n\n"}
{"name":"ContDiffWithinAt.mono_of_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ ContDiffWithinAt ğ•œ n f t x","decl":"theorem ContDiffWithinAt.mono_of_mem_nhdsWithin (h : ContDiffWithinAt ğ•œ n f s x) {t : Set E}\n    (hst : s âˆˆ ğ“[t] x) : ContDiffWithinAt ğ•œ n f t x := by\n  match n with\n  | Ï‰ =>\n    obtain âŸ¨u, hu, p, H, H'âŸ© := h\n    exact âŸ¨u, nhdsWithin_le_of_mem (insert_mem_nhdsWithin_insert hst) hu, p, H, H'âŸ©\n  | (n : â„•âˆ) =>\n    intro m hm\n    rcases h m hm with âŸ¨u, hu, p, HâŸ©\n    exact âŸ¨u, nhdsWithin_le_of_mem (insert_mem_nhdsWithin_insert hst) hu, p, HâŸ©\n\n"}
{"name":"ContDiffWithinAt.mono_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nt : Set E\nhst : Membership.mem (nhdsWithin x t) s\nâŠ¢ ContDiffWithinAt ğ•œ n f t x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiffWithinAt.mono_of_mem := ContDiffWithinAt.mono_of_mem_nhdsWithin\n\n"}
{"name":"ContDiffWithinAt.mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nt : Set E\nhst : HasSubset.Subset t s\nâŠ¢ ContDiffWithinAt ğ•œ n f t x","decl":"theorem ContDiffWithinAt.mono (h : ContDiffWithinAt ğ•œ n f s x) {t : Set E} (hst : t âŠ† s) :\n    ContDiffWithinAt ğ•œ n f t x :=\n  h.mono_of_mem_nhdsWithin <| Filter.mem_of_superset self_mem_nhdsWithin hst\n\n"}
{"name":"ContDiffWithinAt.congr_mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns sâ‚ : Set E\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nh' : Set.EqOn fâ‚ f sâ‚\nhâ‚ : HasSubset.Subset sâ‚ s\nhx : Eq (fâ‚ x) (f x)\nâŠ¢ ContDiffWithinAt ğ•œ n fâ‚ sâ‚ x","decl":"theorem ContDiffWithinAt.congr_mono\n    (h : ContDiffWithinAt ğ•œ n f s x) (h' : EqOn fâ‚ f sâ‚) (hâ‚ : sâ‚ âŠ† s) (hx : fâ‚ x = f x) :\n    ContDiffWithinAt ğ•œ n fâ‚ sâ‚ x :=\n  (h.mono hâ‚).congr h' hx\n\n"}
{"name":"ContDiffWithinAt.congr_set","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nt : Set E\nhst : (nhds x).EventuallyEq s t\nâŠ¢ ContDiffWithinAt ğ•œ n f t x","decl":"theorem ContDiffWithinAt.congr_set (h : ContDiffWithinAt ğ•œ n f s x) {t : Set E}\n    (hst : s =á¶ [ğ“ x] t) : ContDiffWithinAt ğ•œ n f t x := by\n  rw [â† nhdsWithin_eq_iff_eventuallyEq] at hst\n  apply h.mono_of_mem_nhdsWithin <| hst â–¸ self_mem_nhdsWithin\n\n"}
{"name":"ContDiffWithinAt.congr_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nt : Set E\nhst : (nhds x).EventuallyEq s t\nâŠ¢ ContDiffWithinAt ğ•œ n f t x","decl":"@[deprecated (since := \"2024-10-23\")]\nalias ContDiffWithinAt.congr_nhds := ContDiffWithinAt.congr_set\n\n"}
{"name":"contDiffWithinAt_congr_set","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nt : Set E\nhst : (nhds x).EventuallyEq s t\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f s x) (ContDiffWithinAt ğ•œ n f t x)","decl":"theorem contDiffWithinAt_congr_set {t : Set E} (hst : s =á¶ [ğ“ x] t) :\n    ContDiffWithinAt ğ•œ n f s x â†” ContDiffWithinAt ğ•œ n f t x :=\n  âŸ¨fun h => h.congr_set hst, fun h => h.congr_set hst.symmâŸ©\n\n"}
{"name":"contDiffWithinAt_congr_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nt : Set E\nhst : (nhds x).EventuallyEq s t\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f s x) (ContDiffWithinAt ğ•œ n f t x)","decl":"@[deprecated (since := \"2024-10-23\")]\nalias contDiffWithinAt_congr_nhds := contDiffWithinAt_congr_set\n\n"}
{"name":"contDiffWithinAt_inter'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : Membership.mem (nhdsWithin x s) t\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f (Inter.inter s t) x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_inter' (h : t âˆˆ ğ“[s] x) :\n    ContDiffWithinAt ğ•œ n f (s âˆ© t) x â†” ContDiffWithinAt ğ•œ n f s x :=\n  contDiffWithinAt_congr_set (mem_nhdsWithin_iff_eventuallyEq.1 h).symm\n\n"}
{"name":"contDiffWithinAt_inter","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : Membership.mem (nhds x) t\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f (Inter.inter s t) x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_inter (h : t âˆˆ ğ“ x) :\n    ContDiffWithinAt ğ•œ n f (s âˆ© t) x â†” ContDiffWithinAt ğ•œ n f s x :=\n  contDiffWithinAt_inter' (mem_nhdsWithin_of_mem_nhds h)\n\n"}
{"name":"contDiffWithinAt_insert_self","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f (Insert.insert x s) x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_insert_self :\n    ContDiffWithinAt ğ•œ n f (insert x s) x â†” ContDiffWithinAt ğ•œ n f s x := by\n  match n with\n  | Ï‰ => simp [ContDiffWithinAt]\n  | (n : â„•âˆ) => simp_rw [ContDiffWithinAt, insert_idem]\n\n"}
{"name":"contDiffWithinAt_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ny : E\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f (Insert.insert y s) x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_insert {y : E} :\n    ContDiffWithinAt ğ•œ n f (insert y s) x â†” ContDiffWithinAt ğ•œ n f s x := by\n  rcases eq_or_ne x y with (rfl | hx)\n  Â· exact contDiffWithinAt_insert_self\n  refine âŸ¨fun h â†¦ h.mono (subset_insert _ _), fun h â†¦ ?_âŸ©\n  apply h.mono_of_mem_nhdsWithin\n  simp [nhdsWithin_insert_of_ne hx, self_mem_nhdsWithin]\n\n"}
{"name":"ContDiffWithinAt.insert'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ny : E\naâœ : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n f (Insert.insert y s) x","decl":"alias âŸ¨ContDiffWithinAt.of_insert, ContDiffWithinAt.insert'âŸ© := contDiffWithinAt_insert\n\n"}
{"name":"ContDiffWithinAt.of_insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ny : E\naâœ : ContDiffWithinAt ğ•œ n f (Insert.insert y s) x\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"alias âŸ¨ContDiffWithinAt.of_insert, ContDiffWithinAt.insert'âŸ© := contDiffWithinAt_insert\n\n"}
{"name":"ContDiffWithinAt.insert","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n f (Insert.insert x s) x","decl":"protected theorem ContDiffWithinAt.insert (h : ContDiffWithinAt ğ•œ n f s x) :\n    ContDiffWithinAt ğ•œ n f (insert x s) x :=\n  h.insert'\n\n"}
{"name":"contDiffWithinAt_diff_singleton","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ny : E\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f (SDiff.sdiff s (Singleton.singleton y)) x) (ContDiffWithinAt ğ•œ n f s x)","decl":"theorem contDiffWithinAt_diff_singleton {y : E} :\n    ContDiffWithinAt ğ•œ n f (s \\ {y}) x â†” ContDiffWithinAt ğ•œ n f s x := by\n  rw [â† contDiffWithinAt_insert, insert_diff_singleton, contDiffWithinAt_insert]\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhn : LE.le 1 n\nâŠ¢ DifferentiableWithinAt ğ•œ f (Insert.insert x s) x","decl":"/-- If a function is `C^n` within a set at a point, with `n â‰¥ 1`, then it is differentiable\nwithin this set at this point. -/\ntheorem ContDiffWithinAt.differentiableWithinAt' (h : ContDiffWithinAt ğ•œ n f s x) (hn : 1 â‰¤ n) :\n    DifferentiableWithinAt ğ•œ f (insert x s) x := by\n  rcases contDiffWithinAt_nat.1 (h.of_le hn) with âŸ¨u, hu, p, HâŸ©\n  rcases mem_nhdsWithin.1 hu with âŸ¨t, t_open, xt, tuâŸ©\n  rw [inter_comm] at tu\n  exact (differentiableWithinAt_inter (IsOpen.mem_nhds t_open xt)).1 <|\n    ((H.mono tu).differentiableOn le_rfl) x âŸ¨mem_insert x s, xtâŸ©\n\n"}
{"name":"ContDiffWithinAt.differentiable_within_at'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhn : LE.le 1 n\nâŠ¢ DifferentiableWithinAt ğ•œ f (Insert.insert x s) x","decl":"@[deprecated (since := \"2024-10-10\")]\nalias ContDiffWithinAt.differentiable_within_at' := ContDiffWithinAt.differentiableWithinAt'\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhn : LE.le 1 n\nâŠ¢ DifferentiableWithinAt ğ•œ f s x","decl":"theorem ContDiffWithinAt.differentiableWithinAt (h : ContDiffWithinAt ğ•œ n f s x) (hn : 1 â‰¤ n) :\n    DifferentiableWithinAt ğ•œ f s x :=\n  (h.differentiableWithinAt' hn).mono (subset_insert x s)\n\n"}
{"name":"contDiffWithinAt_succ_iff_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Iff (ContDiffWithinAt ğ•œ (HAdd.hAdd n 1) f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f u) (Exists fun f' => And (âˆ€ (x : E), Membership.mem u x â†’ HasFDerivWithinAt f (f' x) u x) (ContDiffWithinAt ğ•œ n f' u x))))","decl":"/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`\n(and moreover the function is analytic when `n = Ï‰`). -/\ntheorem contDiffWithinAt_succ_iff_hasFDerivWithinAt (hn : n â‰  âˆ) :\n    ContDiffWithinAt ğ•œ (n + 1) f s x â†” âˆƒ u âˆˆ ğ“[insert x s] x, (n = Ï‰ â†’ AnalyticOn ğ•œ f u) âˆ§\n      âˆƒ f' : E â†’ E â†’L[ğ•œ] F,\n      (âˆ€ x âˆˆ u, HasFDerivWithinAt f (f' x) u x) âˆ§ ContDiffWithinAt ğ•œ n f' u x := by\n  have h'n : n + 1 â‰  âˆ := by simpa using hn\n  constructor\n  Â· intro h\n    rcases (contDiffWithinAt_iff_of_ne_infty h'n).1 h with âŸ¨u, hu, p, Hp, H'pâŸ©\n    refine âŸ¨u, hu, ?_, fun y => (continuousMultilinearCurryFin1 ğ•œ E F) (p y 1),\n        fun y hy => Hp.hasFDerivWithinAt le_add_self hy, ?_âŸ©\n    Â· rintro rfl\n      exact Hp.analyticOn (H'p rfl 0)\n    apply (contDiffWithinAt_iff_of_ne_infty hn).2\n    refine âŸ¨u, ?_, fun y : E => (p y).shift, ?_âŸ©\n    Â· -- Porting note: without the explicit argument Lean is not sure of the type.\n      convert @self_mem_nhdsWithin _ _ x u\n      have : x âˆˆ insert x s := by simp\n      exact insert_eq_of_mem (mem_of_mem_nhdsWithin this hu)\n    Â· rw [hasFTaylorSeriesUpToOn_succ_iff_right] at Hp\n      refine âŸ¨Hp.2.2, ?_âŸ©\n      rintro rfl i\n      change AnalyticOn ğ•œ\n        (fun x â†¦ (continuousMultilinearCurryRightEquiv' ğ•œ i E F) (p x (i + 1))) u\n      apply (LinearIsometryEquiv.analyticOnNhd _ _).comp_analyticOn\n        ?_ (Set.mapsTo_univ _ _)\n      exact H'p rfl _\n  Â· rintro âŸ¨u, hu, hf, f', f'_eq_deriv, Hf'âŸ©\n    rw [contDiffWithinAt_iff_of_ne_infty h'n]\n    rcases (contDiffWithinAt_iff_of_ne_infty hn).1 Hf' with âŸ¨v, hv, p', Hp', p'_anâŸ©\n    refine âŸ¨v âˆ© u, ?_, fun x => (p' x).unshift (f x), ?_, ?_âŸ©\n    Â· apply Filter.inter_mem _ hu\n      apply nhdsWithin_le_of_mem hu\n      exact nhdsWithin_mono _ (subset_insert x u) hv\n    Â· rw [hasFTaylorSeriesUpToOn_succ_iff_right]\n      refine âŸ¨fun y _ => rfl, fun y hy => ?_, ?_âŸ©\n      Â· change\n          HasFDerivWithinAt (fun z => (continuousMultilinearCurryFin0 ğ•œ E F).symm (f z))\n            (FormalMultilinearSeries.unshift (p' y) (f y) 1).curryLeft (v âˆ© u) y\n        -- Porting note: needed `erw` here.\n        -- https://github.com/leanprover-community/mathlib4/issues/5164\n        erw [LinearIsometryEquiv.comp_hasFDerivWithinAt_iff']\n        convert (f'_eq_deriv y hy.2).mono inter_subset_right\n        rw [â† Hp'.zero_eq y hy.1]\n        ext z\n        change ((p' y 0) (init (@cons 0 (fun _ => E) z 0))) (@cons 0 (fun _ => E) z 0 (last 0)) =\n          ((p' y 0) 0) z\n        congr\n        norm_num [eq_iff_true_of_subsingleton]\n      Â· convert (Hp'.mono inter_subset_left).congr fun x hx => Hp'.zero_eq x hx.1 using 1\n        Â· ext x y\n          change p' x 0 (init (@snoc 0 (fun _ : Fin 1 => E) 0 y)) y = p' x 0 0 y\n          rw [init_snoc]\n        Â· ext x k v y\n          change p' x k (init (@snoc k (fun _ : Fin k.succ => E) v y))\n            (@snoc k (fun _ : Fin k.succ => E) v y (last k)) = p' x k v y\n          rw [snoc_last, init_snoc]\n    Â· intro h i\n      simp only [WithTop.add_eq_top, WithTop.one_ne_top, or_false] at h\n      match i with\n      | 0 =>\n        simp only [FormalMultilinearSeries.unshift]\n        apply AnalyticOnNhd.comp_analyticOn _ ((hf h).mono inter_subset_right)\n          (Set.mapsTo_univ _ _)\n        exact LinearIsometryEquiv.analyticOnNhd _ _\n      | i + 1 =>\n        simp only [FormalMultilinearSeries.unshift, Nat.succ_eq_add_one]\n        apply AnalyticOnNhd.comp_analyticOn _ ((p'_an h i).mono inter_subset_left)\n          (Set.mapsTo_univ _ _)\n        exact LinearIsometryEquiv.analyticOnNhd _ _\n\n"}
{"name":"contDiffWithinAt_succ_iff_hasFDerivWithinAt'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Iff (ContDiffWithinAt ğ•œ (HAdd.hAdd n 1) f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (HasSubset.Subset u (Insert.insert x s)) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f u) (Exists fun f' => And (âˆ€ (x : E), Membership.mem u x â†’ HasFDerivWithinAt f (f' x) s x) (ContDiffWithinAt ğ•œ n f' s x)))))","decl":"/-- A version of `contDiffWithinAt_succ_iff_hasFDerivWithinAt` where all derivatives\n  are taken within the same set. -/\ntheorem contDiffWithinAt_succ_iff_hasFDerivWithinAt' (hn : n â‰  âˆ) :\n    ContDiffWithinAt ğ•œ (n + 1) f s x â†”\n      âˆƒ u âˆˆ ğ“[insert x s] x, u âŠ† insert x s âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ f u) âˆ§\n      âˆƒ f' : E â†’ E â†’L[ğ•œ] F,\n        (âˆ€ x âˆˆ u, HasFDerivWithinAt f (f' x) s x) âˆ§ ContDiffWithinAt ğ•œ n f' s x := by\n  refine âŸ¨fun hf => ?_, ?_âŸ©\n  Â· obtain âŸ¨u, hu, f_an, f', huf', hf'âŸ© := (contDiffWithinAt_succ_iff_hasFDerivWithinAt hn).mp hf\n    obtain âŸ¨w, hw, hxw, hwuâŸ© := mem_nhdsWithin.mp hu\n    rw [inter_comm] at hwu\n    refine âŸ¨insert x s âˆ© w, inter_mem_nhdsWithin _ (hw.mem_nhds hxw), inter_subset_left, ?_, f',\n      fun y hy => ?_, ?_âŸ©\n    Â· intro h\n      apply (f_an h).mono hwu\n    Â· refine ((huf' y <| hwu hy).mono hwu).mono_of_mem_nhdsWithin ?_\n      refine mem_of_superset ?_ (inter_subset_inter_left _ (subset_insert _ _))\n      exact inter_mem_nhdsWithin _ (hw.mem_nhds hy.2)\n    Â· exact hf'.mono_of_mem_nhdsWithin (nhdsWithin_mono _ (subset_insert _ _) hu)\n  Â· rw [â† contDiffWithinAt_insert, contDiffWithinAt_succ_iff_hasFDerivWithinAt hn,\n      insert_eq_of_mem (mem_insert _ _)]\n    rintro âŸ¨u, hu, hus, f_an, f', huf', hf'âŸ©\n    exact âŸ¨u, hu, f_an, f', fun y hy => (huf' y hy).insert'.mono hus, hf'.insert.mono husâŸ©\n\n\n"}
{"name":"HasFTaylorSeriesUpToOn.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : ENat\nf' : E â†’ FormalMultilinearSeries ğ•œ E F\nhf : HasFTaylorSeriesUpToOn (â†‘n) f f' s\nâŠ¢ ContDiffOn ğ•œ (â†‘n) f s","decl":"theorem HasFTaylorSeriesUpToOn.contDiffOn {n : â„•âˆ} {f' : E â†’ FormalMultilinearSeries ğ•œ E F}\n    (hf : HasFTaylorSeriesUpToOn n f f' s) : ContDiffOn ğ•œ n f s := by\n  intro x hx m hm\n  use s\n  simp only [Set.insert_eq_of_mem hx, self_mem_nhdsWithin, true_and]\n  exact âŸ¨f', hf.of_le (mod_cast hm)âŸ©\n\n"}
{"name":"ContDiffOn.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhx : Membership.mem s x\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"theorem ContDiffOn.contDiffWithinAt (h : ContDiffOn ğ•œ n f s) (hx : x âˆˆ s) :\n    ContDiffWithinAt ğ•œ n f s x :=\n  h x hx\n\n"}
{"name":"ContDiffOn.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nm n : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhmn : LE.le m n\nâŠ¢ ContDiffOn ğ•œ m f s","decl":"theorem ContDiffOn.of_le (h : ContDiffOn ğ•œ n f s) (hmn : m â‰¤ n) : ContDiffOn ğ•œ m f s := fun x hx =>\n  (h x hx).of_le hmn\n\n"}
{"name":"ContDiffWithinAt.contDiffOn'","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nm n : WithTop ENat\nhm : LE.le m n\nh' : Eq m â†‘Top.top â†’ Eq n Top.top\nh : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ Exists fun u => And (IsOpen u) (And (Membership.mem u x) (ContDiffOn ğ•œ m f (Inter.inter (Insert.insert x s) u)))","decl":"theorem ContDiffWithinAt.contDiffOn' (hm : m â‰¤ n) (h' : m = âˆ â†’ n = Ï‰)\n    (h : ContDiffWithinAt ğ•œ n f s x) :\n    âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ ContDiffOn ğ•œ m f (insert x s âˆ© u) := by\n  rcases eq_or_ne n Ï‰ with rfl | hn\n  Â· obtain âŸ¨t, ht, p, hp, h'pâŸ© := h\n    rcases mem_nhdsWithin.1 ht with âŸ¨u, huo, hxu, hutâŸ©\n    rw [inter_comm] at hut\n    refine âŸ¨u, huo, hxu, ?_âŸ©\n    suffices ContDiffOn ğ•œ Ï‰ f (insert x s âˆ© u) from this.of_le le_top\n    intro y hy\n    refine âŸ¨insert x s âˆ© u, ?_, p, hp.mono hut,  fun i â†¦ (h'p i).mono hutâŸ©\n    simp only [insert_eq_of_mem, hy, self_mem_nhdsWithin]\n  Â· match m with\n    | Ï‰ => simp [hn] at hm\n    | âˆ => exact (hn (h' rfl)).elim\n    | (m : â„•) =>\n      rcases contDiffWithinAt_nat.1 (h.of_le hm) with âŸ¨t, ht, p, hpâŸ©\n      rcases mem_nhdsWithin.1 ht with âŸ¨u, huo, hxu, hutâŸ©\n      rw [inter_comm] at hut\n      exact âŸ¨u, huo, hxu, (hp.mono hut).contDiffOnâŸ©\n\n"}
{"name":"ContDiffWithinAt.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nm n : WithTop ENat\nhm : LE.le m n\nh' : Eq m â†‘Top.top â†’ Eq n Top.top\nh : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (HasSubset.Subset u (Insert.insert x s)) (ContDiffOn ğ•œ m f u))","decl":"theorem ContDiffWithinAt.contDiffOn (hm : m â‰¤ n) (h' : m = âˆ â†’ n = Ï‰)\n    (h : ContDiffWithinAt ğ•œ n f s x) :\n    âˆƒ u âˆˆ ğ“[insert x s] x, u âŠ† insert x s âˆ§ ContDiffOn ğ•œ m f u := by\n  obtain âŸ¨_u, uo, xu, hâŸ© := h.contDiffOn' hm h'\n  exact âŸ¨_, inter_mem_nhdsWithin _ (uo.mem_nhds xu), inter_subset_left, hâŸ©\n\n"}
{"name":"ContDiffOn.analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nh : ContDiffOn ğ•œ Top.top f s\nâŠ¢ AnalyticOn ğ•œ f s","decl":"theorem ContDiffOn.analyticOn (h : ContDiffOn ğ•œ Ï‰ f s) : AnalyticOn ğ•œ f s :=\n  fun x hx â†¦ (h x hx).analyticWithinAt\n\n"}
{"name":"contDiffWithinAt_iff_contDiffOn_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f s x) (Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (ContDiffOn ğ•œ n f u))","decl":"/-- A function is `C^n` within a set at a point, for `n : â„•`, if and only if it is `C^n` on\na neighborhood of this point. -/\ntheorem contDiffWithinAt_iff_contDiffOn_nhds (hn : n â‰  âˆ) :\n    ContDiffWithinAt ğ•œ n f s x â†” âˆƒ u âˆˆ ğ“[insert x s] x, ContDiffOn ğ•œ n f u := by\n  refine âŸ¨fun h â†¦ ?_, fun h â†¦ ?_âŸ©\n  Â· rcases h.contDiffOn le_rfl (by simp [hn]) with âŸ¨u, hu, h'uâŸ©\n    exact âŸ¨u, hu, h'u.2âŸ©\n  Â· rcases h with âŸ¨u, u_mem, huâŸ©\n    have : x âˆˆ u := mem_of_mem_nhdsWithin (mem_insert x s) u_mem\n    exact (hu x this).mono_of_mem_nhdsWithin (nhdsWithin_mono _ (subset_insert x s) u_mem)\n\n"}
{"name":"ContDiffWithinAt.eventually","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhn : Ne n â†‘Top.top\nâŠ¢ Filter.Eventually (fun y => ContDiffWithinAt ğ•œ n f s y) (nhdsWithin x (Insert.insert x s))","decl":"protected theorem ContDiffWithinAt.eventually (h : ContDiffWithinAt ğ•œ n f s x) (hn : n â‰  âˆ) :\n    âˆ€á¶  y in ğ“[insert x s] x, ContDiffWithinAt ğ•œ n f s y := by\n  rcases h.contDiffOn le_rfl (by simp [hn]) with âŸ¨u, hu, _, hdâŸ©\n  have : âˆ€á¶  y : E in ğ“[insert x s] x, u âˆˆ ğ“[insert x s] y âˆ§ y âˆˆ u :=\n    (eventually_eventually_nhdsWithin.2 hu).and hu\n  refine this.mono fun y hy => (hd y hy.2).mono_of_mem_nhdsWithin ?_\n  exact nhdsWithin_mono y (subset_insert _ _) hy.1\n\n"}
{"name":"ContDiffOn.of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ (HAdd.hAdd n 1) f s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"theorem ContDiffOn.of_succ (h : ContDiffOn ğ•œ (n + 1) f s) : ContDiffOn ğ•œ n f s :=\n  h.of_le le_self_add\n\n"}
{"name":"ContDiffOn.one_of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ (HAdd.hAdd n 1) f s\nâŠ¢ ContDiffOn ğ•œ 1 f s","decl":"theorem ContDiffOn.one_of_succ (h : ContDiffOn ğ•œ (n + 1) f s) : ContDiffOn ğ•œ 1 f s :=\n  h.of_le le_add_self\n\n"}
{"name":"contDiffOn_iff_forall_nat_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : ENat\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘n) f s) (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContDiffOn ğ•œ (â†‘m) f s)","decl":"theorem contDiffOn_iff_forall_nat_le {n : â„•âˆ} :\n    ContDiffOn ğ•œ n f s â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ ContDiffOn ğ•œ m f s :=\n  âŸ¨fun H _ hm => H.of_le (mod_cast hm), fun H x hx m hm => H m hm x hx m le_rflâŸ©\n\n"}
{"name":"contDiffOn_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (âˆ€ (n : Nat), ContDiffOn ğ•œ (â†‘n) f s)","decl":"theorem contDiffOn_infty : ContDiffOn ğ•œ âˆ f s â†” âˆ€ n : â„•, ContDiffOn ğ•œ n f s :=\n  contDiffOn_iff_forall_nat_le.trans <| by simp only [le_top, forall_prop_of_true]\n\n"}
{"name":"contDiffOn_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (âˆ€ (n : Nat), ContDiffOn ğ•œ (â†‘n) f s)","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiffOn_top := contDiffOn_infty\n"}
{"name":"contDiffOn_infty_iff_contDiffOn_omega","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (âˆ€ (n : Nat), ContDiffOn ğ•œ (â†‘n) f s)","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_infty_iff_contDiffOn_omega := contDiffOn_infty\n\n"}
{"name":"contDiffOn_all_iff_nat","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Iff (âˆ€ (n : ENat), ContDiffOn ğ•œ (â†‘n) f s) (âˆ€ (n : Nat), ContDiffOn ğ•œ (â†‘n) f s)","decl":"theorem contDiffOn_all_iff_nat :\n    (âˆ€ (n : â„•âˆ), ContDiffOn ğ•œ n f s) â†” âˆ€ n : â„•, ContDiffOn ğ•œ n f s := by\n  refine âŸ¨fun H n => H n, ?_âŸ©\n  rintro H (_ | n)\n  exacts [contDiffOn_infty.2 H, H n]\n\n"}
{"name":"ContDiffOn.continuousOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nâŠ¢ ContinuousOn f s","decl":"theorem ContDiffOn.continuousOn (h : ContDiffOn ğ•œ n f s) : ContinuousOn f s := fun x hx =>\n  (h x hx).continuousWithinAt\n\n"}
{"name":"ContDiffOn.congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhâ‚ : âˆ€ (x : E), Membership.mem s x â†’ Eq (fâ‚ x) (f x)\nâŠ¢ ContDiffOn ğ•œ n fâ‚ s","decl":"theorem ContDiffOn.congr (h : ContDiffOn ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) :\n    ContDiffOn ğ•œ n fâ‚ s := fun x hx => (h x hx).congr hâ‚ (hâ‚ x hx)\n\n"}
{"name":"contDiffOn_congr","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf fâ‚ : E â†’ F\nn : WithTop ENat\nhâ‚ : âˆ€ (x : E), Membership.mem s x â†’ Eq (fâ‚ x) (f x)\nâŠ¢ Iff (ContDiffOn ğ•œ n fâ‚ s) (ContDiffOn ğ•œ n f s)","decl":"theorem contDiffOn_congr (hâ‚ : âˆ€ x âˆˆ s, fâ‚ x = f x) : ContDiffOn ğ•œ n fâ‚ s â†” ContDiffOn ğ•œ n f s :=\n  âŸ¨fun H => H.congr fun x hx => (hâ‚ x hx).symm, fun H => H.congr hâ‚âŸ©\n\n"}
{"name":"ContDiffOn.mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nt : Set E\nhst : HasSubset.Subset t s\nâŠ¢ ContDiffOn ğ•œ n f t","decl":"theorem ContDiffOn.mono (h : ContDiffOn ğ•œ n f s) {t : Set E} (hst : t âŠ† s) : ContDiffOn ğ•œ n f t :=\n  fun x hx => (h x (hst hx)).mono hst\n\n"}
{"name":"ContDiffOn.congr_mono","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns sâ‚ : Set E\nf fâ‚ : E â†’ F\nn : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\nhâ‚ : âˆ€ (x : E), Membership.mem sâ‚ x â†’ Eq (fâ‚ x) (f x)\nhs : HasSubset.Subset sâ‚ s\nâŠ¢ ContDiffOn ğ•œ n fâ‚ sâ‚","decl":"theorem ContDiffOn.congr_mono (hf : ContDiffOn ğ•œ n f s) (hâ‚ : âˆ€ x âˆˆ sâ‚, fâ‚ x = f x) (hs : sâ‚ âŠ† s) :\n    ContDiffOn ğ•œ n fâ‚ sâ‚ :=\n  (hf.mono hs).congr hâ‚\n\n"}
{"name":"ContDiffOn.differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhn : LE.le 1 n\nâŠ¢ DifferentiableOn ğ•œ f s","decl":"/-- If a function is `C^n` on a set with `n â‰¥ 1`, then it is differentiable there. -/\ntheorem ContDiffOn.differentiableOn (h : ContDiffOn ğ•œ n f s) (hn : 1 â‰¤ n) :\n    DifferentiableOn ğ•œ f s := fun x hx => (h x hx).differentiableWithinAt hn\n\n"}
{"name":"contDiffOn_of_locally_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : âˆ€ (x : E), Membership.mem s x â†’ Exists fun u => And (IsOpen u) (And (Membership.mem u x) (ContDiffOn ğ•œ n f (Inter.inter s u)))\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"/-- If a function is `C^n` around each point in a set, then it is `C^n` on the set. -/\ntheorem contDiffOn_of_locally_contDiffOn\n    (h : âˆ€ x âˆˆ s, âˆƒ u, IsOpen u âˆ§ x âˆˆ u âˆ§ ContDiffOn ğ•œ n f (s âˆ© u)) : ContDiffOn ğ•œ n f s := by\n  intro x xs\n  rcases h x xs with âŸ¨u, u_open, xu, huâŸ©\n  apply (contDiffWithinAt_inter _).1 (hu x âŸ¨xs, xuâŸ©)\n  exact IsOpen.mem_nhds u_open xu\n\n"}
{"name":"contDiffOn_succ_iff_hasFDerivWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) f s) (âˆ€ (x : E), Membership.mem s x â†’ Exists fun u => And (Membership.mem (nhdsWithin x (Insert.insert x s)) u) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f u) (Exists fun f' => And (âˆ€ (x : E), Membership.mem u x â†’ HasFDerivWithinAt f (f' x) u x) (ContDiffOn ğ•œ n f' u))))","decl":"/-- A function is `C^(n + 1)` on a domain iff locally, it has a derivative which is `C^n`. -/\ntheorem contDiffOn_succ_iff_hasFDerivWithinAt (hn : n â‰  âˆ) :\n    ContDiffOn ğ•œ (n + 1) f s â†”\n      âˆ€ x âˆˆ s, âˆƒ u âˆˆ ğ“[insert x s] x, (n = Ï‰ â†’ AnalyticOn ğ•œ f u) âˆ§ âˆƒ f' : E â†’ E â†’L[ğ•œ] F,\n        (âˆ€ x âˆˆ u, HasFDerivWithinAt f (f' x) u x) âˆ§ ContDiffOn ğ•œ n f' u := by\n  constructor\n  Â· intro h x hx\n    rcases (contDiffWithinAt_succ_iff_hasFDerivWithinAt hn).1 (h x hx) with\n      âŸ¨u, hu, f_an, f', hf', Hf'âŸ©\n    rcases Hf'.contDiffOn le_rfl (by simp [hn]) with âŸ¨v, vu, v'u, hvâŸ©\n    rw [insert_eq_of_mem hx] at hu âŠ¢\n    have xu : x âˆˆ u := mem_of_mem_nhdsWithin hx hu\n    rw [insert_eq_of_mem xu] at vu v'u\n    exact âŸ¨v, nhdsWithin_le_of_mem hu vu, fun h â†¦ (f_an h).mono v'u, f',\n      fun y hy â†¦ (hf' y (v'u hy)).mono v'u, hvâŸ©\n  Â· intro h x hx\n    rw [contDiffWithinAt_succ_iff_hasFDerivWithinAt hn]\n    rcases h x hx with âŸ¨u, u_nhbd, f_an, f', hu, hf'âŸ©\n    have : x âˆˆ u := mem_of_mem_nhdsWithin (mem_insert _ _) u_nhbd\n    exact âŸ¨u, u_nhbd, f_an, f', hu, hf' x thisâŸ©\n\n\n"}
{"name":"contDiffOn_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nâŠ¢ Iff (ContDiffOn ğ•œ 0 f s) (ContinuousOn f s)","decl":"@[simp]\ntheorem contDiffOn_zero : ContDiffOn ğ•œ 0 f s â†” ContinuousOn f s := by\n  refine âŸ¨fun H => H.continuousOn, fun H => fun x hx m hm â†¦ ?_âŸ©\n  have : (m : WithTop â„•âˆ) = 0 := le_antisymm (mod_cast hm) bot_le\n  rw [this]\n  refine âŸ¨insert x s, self_mem_nhdsWithin, ftaylorSeriesWithin ğ•œ f s, ?_âŸ©\n  rw [hasFTaylorSeriesUpToOn_zero_iff]\n  exact âŸ¨by rwa [insert_eq_of_mem hx], fun x _ => by simp [ftaylorSeriesWithin]âŸ©\n\n"}
{"name":"contDiffWithinAt_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nhx : Membership.mem s x\nâŠ¢ Iff (ContDiffWithinAt ğ•œ 0 f s x) (Exists fun u => And (Membership.mem (nhdsWithin x s) u) (ContinuousOn f (Inter.inter s u)))","decl":"theorem contDiffWithinAt_zero (hx : x âˆˆ s) :\n    ContDiffWithinAt ğ•œ 0 f s x â†” âˆƒ u âˆˆ ğ“[s] x, ContinuousOn f (s âˆ© u) := by\n  constructor\n  Â· intro h\n    obtain âŸ¨u, H, p, hpâŸ© := h 0 le_rfl\n    refine âŸ¨u, ?_, ?_âŸ©\n    Â· simpa [hx] using H\n    Â· simp only [Nat.cast_zero, hasFTaylorSeriesUpToOn_zero_iff] at hp\n      exact hp.1.mono inter_subset_right\n  Â· rintro âŸ¨u, H, huâŸ©\n    rw [â† contDiffWithinAt_inter' H]\n    have h' : x âˆˆ s âˆ© u := âŸ¨hx, mem_of_mem_nhdsWithin hx HâŸ©\n    exact (contDiffOn_zero.mpr hu).contDiffWithinAt h'\n\n"}
{"name":"ContDiffOn.ftaylorSeriesWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin ğ•œ f s) s","decl":"/-- When a function is `C^n` in a set `s` of unique differentiability, it admits\n`ftaylorSeriesWithin ğ•œ f s` as a Taylor series up to order `n` in `s`. -/\nprotected theorem ContDiffOn.ftaylorSeriesWithin\n    (h : ContDiffOn ğ•œ n f s) (hs : UniqueDiffOn ğ•œ s) :\n    HasFTaylorSeriesUpToOn n f (ftaylorSeriesWithin ğ•œ f s) s := by\n  constructor\n  Â· intro x _\n    simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.curry0_apply,\n      iteratedFDerivWithin_zero_apply]\n  Â· intro m hm x hx\n    have : (m + 1 : â„•) â‰¤ n := ENat.add_one_natCast_le_withTop_of_lt hm\n    rcases (h x hx).of_le this _ le_rfl with âŸ¨u, hu, p, HpâŸ©\n    rw [insert_eq_of_mem hx] at hu\n    rcases mem_nhdsWithin.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [inter_comm] at ho\n    have : p x m.succ = ftaylorSeriesWithin ğ•œ f s x m.succ := by\n      change p x m.succ = iteratedFDerivWithin ğ•œ m.succ f s x\n      rw [â† iteratedFDerivWithin_inter_open o_open xo]\n      exact (Hp.mono ho).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl (hs.inter o_open) âŸ¨hx, xoâŸ©\n    rw [â† this, â† hasFDerivWithinAt_inter (IsOpen.mem_nhds o_open xo)]\n    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylorSeriesWithin ğ•œ f s y m := by\n      rintro y âŸ¨hy, yoâŸ©\n      change p y m = iteratedFDerivWithin ğ•œ m f s y\n      rw [â† iteratedFDerivWithin_inter_open o_open yo]\n      exact\n        (Hp.mono ho).eq_iteratedFDerivWithin_of_uniqueDiffOn (mod_cast Nat.le_succ m)\n          (hs.inter o_open) âŸ¨hy, yoâŸ©\n    exact\n      ((Hp.mono ho).fderivWithin m (mod_cast lt_add_one m) x âŸ¨hx, xoâŸ©).congr\n        (fun y hy => (A y hy).symm) (A x âŸ¨hx, xoâŸ©).symm\n  Â· intro m hm\n    apply continuousOn_of_locally_continuousOn\n    intro x hx\n    rcases (h x hx).of_le hm _ le_rfl with âŸ¨u, hu, p, HpâŸ©\n    rcases mem_nhdsWithin.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [insert_eq_of_mem hx] at ho\n    rw [inter_comm] at ho\n    refine âŸ¨o, o_open, xo, ?_âŸ©\n    have A : âˆ€ y âˆˆ s âˆ© o, p y m = ftaylorSeriesWithin ğ•œ f s y m := by\n      rintro y âŸ¨hy, yoâŸ©\n      change p y m = iteratedFDerivWithin ğ•œ m f s y\n      rw [â† iteratedFDerivWithin_inter_open o_open yo]\n      exact (Hp.mono ho).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl (hs.inter o_open) âŸ¨hy, yoâŸ©\n    exact ((Hp.mono ho).cont m le_rfl).congr fun y hy => (A y hy).symm\n\n"}
{"name":"iteratedFDerivWithin_subset","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns t : Set E\nf : E â†’ F\nx : E\nn : Nat\nst : HasSubset.Subset s t\nhs : UniqueDiffOn ğ•œ s\nht : UniqueDiffOn ğ•œ t\nh : ContDiffOn ğ•œ (â†‘n) f t\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f s x) (iteratedFDerivWithin ğ•œ n f t x)","decl":"theorem iteratedFDerivWithin_subset {n : â„•} (st : s âŠ† t) (hs : UniqueDiffOn ğ•œ s)\n    (ht : UniqueDiffOn ğ•œ t) (h : ContDiffOn ğ•œ n f t) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ n f s x = iteratedFDerivWithin ğ•œ n f t x :=\n  (((h.ftaylorSeriesWithin ht).mono st).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl hs hx).symm\n\n"}
{"name":"ContDiffWithinAt.eventually_hasFTaylorSeriesUpToOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\ns : Set E\na : E\nh : ContDiffWithinAt ğ•œ n f s a\nhs : UniqueDiffOn ğ•œ s\nha : Membership.mem s a\nm : Nat\nhm : LE.le (â†‘m) n\nâŠ¢ Filter.Eventually (fun t => HasFTaylorSeriesUpToOn (â†‘m) f (ftaylorSeriesWithin ğ•œ f s) t) (nhdsWithin a s).smallSets","decl":"theorem ContDiffWithinAt.eventually_hasFTaylorSeriesUpToOn {f : E â†’ F} {s : Set E} {a : E}\n    (h : ContDiffWithinAt ğ•œ n f s a) (hs : UniqueDiffOn ğ•œ s) (ha : a âˆˆ s) {m : â„•} (hm : m â‰¤ n) :\n    âˆ€á¶  t in (ğ“[s] a).smallSets, HasFTaylorSeriesUpToOn m f (ftaylorSeriesWithin ğ•œ f s) t := by\n  rcases h.contDiffOn' hm (by simp) with âŸ¨U, hUo, haU, hfUâŸ©\n  have : âˆ€á¶  t in (ğ“[s] a).smallSets, t âŠ† s âˆ© U := by\n    rw [eventually_smallSets_subset]\n    exact inter_mem_nhdsWithin _ <| hUo.mem_nhds haU\n  refine this.mono fun t ht â†¦ .mono ?_ ht\n  rw [insert_eq_of_mem ha] at hfU\n  refine (hfU.ftaylorSeriesWithin (hs.inter hUo)).congr_series fun k hk x hx â†¦ ?_\n  exact iteratedFDerivWithin_inter_open hUo hx.2\n\n"}
{"name":"AnalyticOn.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : AnalyticOn ğ•œ f s\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"/-- On a set with unique differentiability, an analytic function is automatically `C^Ï‰`, as its\nsuccessive derivatives are also analytic. This does not require completeness of the space. See\nalso `AnalyticOn.contDiffOn_of_completeSpace`.-/\ntheorem AnalyticOn.contDiffOn (h : AnalyticOn ğ•œ f s) (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ n f s := by\n  suffices ContDiffOn ğ•œ Ï‰ f s from this.of_le le_top\n  rcases h.exists_hasFTaylorSeriesUpToOn hs with âŸ¨p, hpâŸ©\n  intro x hx\n  refine âŸ¨s, ?_, p, hpâŸ©\n  rw [insert_eq_of_mem hx]\n  exact self_mem_nhdsWithin\n\n"}
{"name":"AnalyticWithinOn.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : AnalyticOn ğ•œ f s\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"@[deprecated (since := \"2024-09-26\")]\nalias AnalyticWithinOn.contDiffOn := AnalyticOn.contDiffOn\n\n"}
{"name":"AnalyticOnNhd.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : AnalyticOnNhd ğ•œ f s\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"/-- On a set with unique differentiability, an analytic function is automatically `C^Ï‰`, as its\nsuccessive derivatives are also analytic. This does not require completeness of the space. See\nalso `AnalyticOnNhd.contDiffOn_of_completeSpace`. -/\ntheorem AnalyticOnNhd.contDiffOn (h : AnalyticOnNhd ğ•œ f s) (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ n f s := h.analyticOn.contDiffOn hs\n\n"}
{"name":"AnalyticOn.contDiffOn_of_completeSpace","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\ninstâœ : CompleteSpace F\nh : AnalyticOn ğ•œ f s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"/-- An analytic function is automatically `C^Ï‰` in a complete space -/\ntheorem AnalyticOn.contDiffOn_of_completeSpace [CompleteSpace F] (h : AnalyticOn ğ•œ f s) :\n    ContDiffOn ğ•œ n f s :=\n  fun x hx â†¦ (h x hx).contDiffWithinAt\n\n"}
{"name":"AnalyticOnNhd.contDiffOn_of_completeSpace","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\ninstâœ : CompleteSpace F\nh : AnalyticOnNhd ğ•œ f s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"/-- An analytic function is automatically `C^Ï‰` in a complete space -/\ntheorem AnalyticOnNhd.contDiffOn_of_completeSpace [CompleteSpace F] (h : AnalyticOnNhd ğ•œ f s) :\n    ContDiffOn ğ•œ n f s :=\n  h.analyticOn.contDiffOn_of_completeSpace\n\n"}
{"name":"contDiffOn_of_continuousOn_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : ENat\nHcont : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContinuousOn (fun x => iteratedFDerivWithin ğ•œ m f s x) s\nHdiff : âˆ€ (m : Nat), LT.lt (â†‘m) n â†’ DifferentiableOn ğ•œ (fun x => iteratedFDerivWithin ğ•œ m f s x) s\nâŠ¢ ContDiffOn ğ•œ (â†‘n) f s","decl":"theorem contDiffOn_of_continuousOn_differentiableOn {n : â„•âˆ}\n    (Hcont : âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (fun x => iteratedFDerivWithin ğ•œ m f s x) s)\n    (Hdiff : âˆ€ m : â„•, m < n â†’\n      DifferentiableOn ğ•œ (fun x => iteratedFDerivWithin ğ•œ m f s x) s) :\n    ContDiffOn ğ•œ n f s := by\n  intro x hx m hm\n  rw [insert_eq_of_mem hx]\n  refine âŸ¨s, self_mem_nhdsWithin, ftaylorSeriesWithin ğ•œ f s, ?_âŸ©\n  constructor\n  Â· intro y _\n    simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.curry0_apply,\n      iteratedFDerivWithin_zero_apply]\n  Â· intro k hk y hy\n    convert (Hdiff k (lt_of_lt_of_le (mod_cast hk) (mod_cast hm)) y hy).hasFDerivWithinAt\n  Â· intro k hk\n    exact Hcont k (le_trans (mod_cast hk) (mod_cast hm))\n\n"}
{"name":"contDiffOn_of_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : ENat\nh : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ DifferentiableOn ğ•œ (iteratedFDerivWithin ğ•œ m f s) s\nâŠ¢ ContDiffOn ğ•œ (â†‘n) f s","decl":"theorem contDiffOn_of_differentiableOn {n : â„•âˆ}\n    (h : âˆ€ m : â„•, m â‰¤ n â†’ DifferentiableOn ğ•œ (iteratedFDerivWithin ğ•œ m f s) s) :\n    ContDiffOn ğ•œ n f s :=\n  contDiffOn_of_continuousOn_differentiableOn (fun m hm => (h m hm).continuousOn) fun m hm =>\n    h m (le_of_lt hm)\n\n"}
{"name":"contDiffOn_of_analyticOn_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : âˆ€ (m : Nat), AnalyticOn ğ•œ (iteratedFDerivWithin ğ•œ m f s) s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"theorem contDiffOn_of_analyticOn_iteratedFDerivWithin\n    (h : âˆ€ m, AnalyticOn ğ•œ (iteratedFDerivWithin ğ•œ m f s) s) :\n    ContDiffOn ğ•œ n f s := by\n  suffices ContDiffOn ğ•œ Ï‰ f s from this.of_le le_top\n  intro x hx\n  refine âŸ¨insert x s, self_mem_nhdsWithin, ftaylorSeriesWithin ğ•œ f s, ?_, ?_âŸ©\n  Â· rw [insert_eq_of_mem hx]\n    constructor\n    Â· intro y _\n      simp only [ftaylorSeriesWithin, ContinuousMultilinearMap.curry0_apply,\n        iteratedFDerivWithin_zero_apply]\n    Â· intro k _ y hy\n      exact ((h k).differentiableOn y hy).hasFDerivWithinAt\n    Â· intro k _\n      exact (h k).continuousOn\n  Â· intro i\n    rw [insert_eq_of_mem hx]\n    exact h i\n\n"}
{"name":"contDiffOn_omega_iff_analyticOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ Top.top f s) (AnalyticOn ğ•œ f s)","decl":"theorem contDiffOn_omega_iff_analyticOn (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ Ï‰ f s â†” AnalyticOn ğ•œ f s :=\n  âŸ¨fun h m â†¦ h.analyticOn m, fun h â†¦ h.contDiffOn hsâŸ©\n\n"}
{"name":"ContDiffOn.continuousOn_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nm : Nat\nh : ContDiffOn ğ•œ n f s\nhmn : LE.le (â†‘m) n\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ ContinuousOn (iteratedFDerivWithin ğ•œ m f s) s","decl":"theorem ContDiffOn.continuousOn_iteratedFDerivWithin {m : â„•} (h : ContDiffOn ğ•œ n f s)\n    (hmn : m â‰¤ n) (hs : UniqueDiffOn ğ•œ s) : ContinuousOn (iteratedFDerivWithin ğ•œ m f s) s :=\n  ((h.of_le hmn).ftaylorSeriesWithin hs).cont m le_rfl\n\n"}
{"name":"ContDiffOn.differentiableOn_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nm : Nat\nh : ContDiffOn ğ•œ n f s\nhmn : LT.lt (â†‘m) n\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ DifferentiableOn ğ•œ (iteratedFDerivWithin ğ•œ m f s) s","decl":"theorem ContDiffOn.differentiableOn_iteratedFDerivWithin {m : â„•} (h : ContDiffOn ğ•œ n f s)\n    (hmn : m < n) (hs : UniqueDiffOn ğ•œ s) :\n    DifferentiableOn ğ•œ (iteratedFDerivWithin ğ•œ m f s) s := by\n  intro x hx\n  have : (m + 1 : â„•) â‰¤ n := ENat.add_one_natCast_le_withTop_of_lt hmn\n  apply (((h.of_le this).ftaylorSeriesWithin hs).fderivWithin m ?_ x hx).differentiableWithinAt\n  exact_mod_cast lt_add_one m\n\n"}
{"name":"ContDiffWithinAt.differentiableWithinAt_iteratedFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nm : Nat\nh : ContDiffWithinAt ğ•œ n f s x\nhmn : LT.lt (â†‘m) n\nhs : UniqueDiffOn ğ•œ (Insert.insert x s)\nâŠ¢ DifferentiableWithinAt ğ•œ (iteratedFDerivWithin ğ•œ m f s) s x","decl":"theorem ContDiffWithinAt.differentiableWithinAt_iteratedFDerivWithin {m : â„•}\n    (h : ContDiffWithinAt ğ•œ n f s x) (hmn : m < n) (hs : UniqueDiffOn ğ•œ (insert x s)) :\n    DifferentiableWithinAt ğ•œ (iteratedFDerivWithin ğ•œ m f s) s x := by\n  have : (m + 1 : WithTop â„•âˆ) â‰  âˆ := Ne.symm (ne_of_beq_false rfl)\n  rcases h.contDiffOn' (ENat.add_one_natCast_le_withTop_of_lt hmn) (by simp [this])\n    with âŸ¨u, uo, xu, huâŸ©\n  set t := insert x s âˆ© u\n  have A : t =á¶ [ğ“[â‰ ] x] s := by\n    simp only [set_eventuallyEq_iff_inf_principal, â† nhdsWithin_inter']\n    rw [â† inter_assoc, nhdsWithin_inter_of_mem', â† diff_eq_compl_inter, insert_diff_of_mem,\n      diff_eq_compl_inter]\n    exacts [rfl, mem_nhdsWithin_of_mem_nhds (uo.mem_nhds xu)]\n  have B : iteratedFDerivWithin ğ•œ m f s =á¶ [ğ“ x] iteratedFDerivWithin ğ•œ m f t :=\n    iteratedFDerivWithin_eventually_congr_set' _ A.symm _\n  have C : DifferentiableWithinAt ğ•œ (iteratedFDerivWithin ğ•œ m f t) t x :=\n    hu.differentiableOn_iteratedFDerivWithin (Nat.cast_lt.2 m.lt_succ_self) (hs.inter uo) x\n      âŸ¨mem_insert _ _, xuâŸ©\n  rw [differentiableWithinAt_congr_set' _ A] at C\n  exact C.congr_of_eventuallyEq (B.filter_mono inf_le_left) B.self_of_nhds\n\n"}
{"name":"contDiffOn_iff_continuousOn_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : ENat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘n) f s) (And (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContinuousOn (fun x => iteratedFDerivWithin ğ•œ m f s x) s) (âˆ€ (m : Nat), LT.lt (â†‘m) n â†’ DifferentiableOn ğ•œ (fun x => iteratedFDerivWithin ğ•œ m f s x) s))","decl":"theorem contDiffOn_iff_continuousOn_differentiableOn {n : â„•âˆ} (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ n f s â†”\n      (âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (fun x => iteratedFDerivWithin ğ•œ m f s x) s) âˆ§\n        âˆ€ m : â„•, m < n â†’ DifferentiableOn ğ•œ (fun x => iteratedFDerivWithin ğ•œ m f s x) s :=\n  âŸ¨fun h => âŸ¨fun _m hm => h.continuousOn_iteratedFDerivWithin (mod_cast hm) hs,\n      fun _m hm => h.differentiableOn_iteratedFDerivWithin (mod_cast hm) hsâŸ©,\n    fun h => contDiffOn_of_continuousOn_differentiableOn h.1 h.2âŸ©\n\n"}
{"name":"contDiffOn_nat_iff_continuousOn_differentiableOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : Nat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘n) f s) (And (âˆ€ (m : Nat), LE.le m n â†’ ContinuousOn (fun x => iteratedFDerivWithin ğ•œ m f s x) s) (âˆ€ (m : Nat), LT.lt m n â†’ DifferentiableOn ğ•œ (fun x => iteratedFDerivWithin ğ•œ m f s x) s))","decl":"theorem contDiffOn_nat_iff_continuousOn_differentiableOn {n : â„•} (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ n f s â†”\n      (âˆ€ m : â„•, m â‰¤ n â†’ ContinuousOn (fun x => iteratedFDerivWithin ğ•œ m f s x) s) âˆ§\n        âˆ€ m : â„•, m < n â†’ DifferentiableOn ğ•œ (fun x => iteratedFDerivWithin ğ•œ m f s x) s := by\n  rw [show n = ((n : â„•âˆ) : WithTop â„•âˆ) from rfl, contDiffOn_iff_continuousOn_differentiableOn hs]\n  simp\n\n"}
{"name":"contDiffOn_succ_of_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhf : DifferentiableOn ğ•œ f s\nh' : Eq n Top.top â†’ AnalyticOn ğ•œ f s\nh : ContDiffOn ğ•œ n (fun y => fderivWithin ğ•œ f s y) s\nâŠ¢ ContDiffOn ğ•œ (HAdd.hAdd n 1) f s","decl":"theorem contDiffOn_succ_of_fderivWithin (hf : DifferentiableOn ğ•œ f s)\n    (h' : n = Ï‰ â†’ AnalyticOn ğ•œ f s)\n    (h : ContDiffOn ğ•œ n (fun y => fderivWithin ğ•œ f s y) s) : ContDiffOn ğ•œ (n + 1) f s := by\n  rcases eq_or_ne n âˆ with rfl | hn\n  Â· rw [ENat.coe_top_add_one, contDiffOn_infty]\n    intro m x hx\n    apply ContDiffWithinAt.of_le _ (show (m : WithTop â„•âˆ) â‰¤ m + 1 from le_self_add)\n    rw [contDiffWithinAt_succ_iff_hasFDerivWithinAt (by simp),\n      insert_eq_of_mem hx]\n    exact âŸ¨s, self_mem_nhdsWithin, (by simp), fderivWithin ğ•œ f s,\n      fun y hy => (hf y hy).hasFDerivWithinAt, (h x hx).of_le (mod_cast le_top)âŸ©\n  Â· intro x hx\n    rw [contDiffWithinAt_succ_iff_hasFDerivWithinAt hn,\n      insert_eq_of_mem hx]\n    exact âŸ¨s, self_mem_nhdsWithin, h', fderivWithin ğ•œ f s,\n      fun y hy => (hf y hy).hasFDerivWithinAt, h x hxâŸ©\n\n"}
{"name":"contDiffOn_of_analyticOn_of_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhf : AnalyticOn ğ•œ f s\nh : ContDiffOn ğ•œ Top.top (fun y => fderivWithin ğ•œ f s y) s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"theorem contDiffOn_of_analyticOn_of_fderivWithin (hf : AnalyticOn ğ•œ f s)\n    (h : ContDiffOn ğ•œ Ï‰ (fun y â†¦ fderivWithin ğ•œ f s y) s) : ContDiffOn ğ•œ n f s := by\n  suffices ContDiffOn ğ•œ (Ï‰ + 1) f s from this.of_le le_top\n  exact contDiffOn_succ_of_fderivWithin hf.differentiableOn (fun _ â†¦ hf) h\n\n"}
{"name":"contDiffOn_succ_iff_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) f s) (And (DifferentiableOn ğ•œ f s) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f s) (ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s)))","decl":"/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (expressed with `fderivWithin`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_fderivWithin (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ (n + 1) f s â†”\n      DifferentiableOn ğ•œ f s âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ f s) âˆ§\n      ContDiffOn ğ•œ n (fderivWithin ğ•œ f s) s := by\n  refine âŸ¨fun H => ?_, fun h => contDiffOn_succ_of_fderivWithin h.1 h.2.1 h.2.2âŸ©\n  refine âŸ¨H.differentiableOn le_add_self, ?_, fun x hx => ?_âŸ©\n  Â· rintro rfl\n    exact H.analyticOn\n  have A (m : â„•) (hm : m â‰¤ n) : ContDiffWithinAt ğ•œ m (fun y => fderivWithin ğ•œ f s y) s x := by\n    rcases (contDiffWithinAt_succ_iff_hasFDerivWithinAt (n := m) (ne_of_beq_false rfl)).1\n      (H.of_le (add_le_add_right hm 1) x hx) with âŸ¨u, hu, -, f', hff', hf'âŸ©\n    rcases mem_nhdsWithin.1 hu with âŸ¨o, o_open, xo, hoâŸ©\n    rw [inter_comm, insert_eq_of_mem hx] at ho\n    have := hf'.mono ho\n    rw [contDiffWithinAt_inter' (mem_nhdsWithin_of_mem_nhds (IsOpen.mem_nhds o_open xo))] at this\n    apply this.congr_of_eventuallyEq_of_mem _ hx\n    have : o âˆ© s âˆˆ ğ“[s] x := mem_nhdsWithin.2 âŸ¨o, o_open, xo, Subset.refl _âŸ©\n    rw [inter_comm] at this\n    refine Filter.eventuallyEq_of_mem this fun y hy => ?_\n    have A : fderivWithin ğ•œ f (s âˆ© o) y = f' y :=\n      ((hff' y (ho hy)).mono ho).fderivWithin (hs.inter o_open y hy)\n    rwa [fderivWithin_inter (o_open.mem_nhds hy.2)] at A\n  match n with\n  | Ï‰ => exact (H.analyticOn.fderivWithin hs).contDiffOn hs (n := Ï‰) x hx\n  | âˆ => exact contDiffWithinAt_infty.2 (fun m â†¦ A m (mod_cast le_top))\n  | (n : â„•) => exact A n le_rfl\n\n"}
{"name":"contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) f s) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f s) (Exists fun f' => And (ContDiffOn ğ•œ n f' s) (âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x)))","decl":"theorem contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ (n + 1) f s â†” (n = Ï‰ â†’ AnalyticOn ğ•œ f s) âˆ§\n      âˆƒ f' : E â†’ E â†’L[ğ•œ] F, ContDiffOn ğ•œ n f' s âˆ§ âˆ€ x, x âˆˆ s â†’ HasFDerivWithinAt f (f' x) s x := by\n  rw [contDiffOn_succ_iff_fderivWithin hs]\n  refine âŸ¨fun h => âŸ¨h.2.1, fderivWithin ğ•œ f s, h.2.2,\n    fun x hx => (h.1 x hx).hasFDerivWithinAtâŸ©, fun âŸ¨f_an, hâŸ© => ?_âŸ©\n  rcases h with âŸ¨f', h1, h2âŸ©\n  refine âŸ¨fun x hx => (h2 x hx).differentiableWithinAt, f_an, fun x hx => ?_âŸ©\n  exact (h1 x hx).congr_of_mem (fun y hy => (h2 y hy).fderivWithin (hs y hy)) hx\n\n"}
{"name":"contDiffOn_succ_iff_hasFDerivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) f s) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f s) (Exists fun f' => And (ContDiffOn ğ•œ n f' s) (âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x)))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_succ_iff_hasFDerivWithin := contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn\n\n"}
{"name":"contDiffOn_infty_iff_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (And (DifferentiableOn ğ•œ f s) (ContDiffOn ğ•œ (â†‘Top.top) (fderivWithin ğ•œ f s) s))","decl":"theorem contDiffOn_infty_iff_fderivWithin (hs : UniqueDiffOn ğ•œ s) :\n    ContDiffOn ğ•œ âˆ f s â†” DifferentiableOn ğ•œ f s âˆ§ ContDiffOn ğ•œ âˆ (fderivWithin ğ•œ f s) s := by\n  rw [show âˆ = âˆ + 1 from rfl, contDiffOn_succ_iff_fderivWithin hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (And (DifferentiableOn ğ•œ f s) (ContDiffOn ğ•œ (â†‘Top.top) (fderivWithin ğ•œ f s) s))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_fderivWithin := contDiffOn_infty_iff_fderivWithin\n\n"}
{"name":"contDiffOn_succ_iff_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhs : IsOpen s\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) f s) (And (DifferentiableOn ğ•œ f s) (And (Eq n Top.top â†’ AnalyticOn ğ•œ f s) (ContDiffOn ğ•œ n (fderiv ğ•œ f) s)))","decl":"/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (expressed with `fderiv`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_fderiv_of_isOpen (hs : IsOpen s) :\n    ContDiffOn ğ•œ (n + 1) f s â†”\n      DifferentiableOn ğ•œ f s âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ f s) âˆ§\n      ContDiffOn ğ•œ n (fderiv ğ•œ f) s := by\n  rw [contDiffOn_succ_iff_fderivWithin hs.uniqueDiffOn]\n  exact Iff.rfl.and (Iff.rfl.and (contDiffOn_congr fun x hx â†¦ fderivWithin_of_isOpen hs hx))\n\n"}
{"name":"contDiffOn_infty_iff_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nhs : IsOpen s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (And (DifferentiableOn ğ•œ f s) (ContDiffOn ğ•œ (â†‘Top.top) (fderiv ğ•œ f) s))","decl":"theorem contDiffOn_infty_iff_fderiv_of_isOpen (hs : IsOpen s) :\n    ContDiffOn ğ•œ âˆ f s â†” DifferentiableOn ğ•œ f s âˆ§ ContDiffOn ğ•œ âˆ (fderiv ğ•œ f) s := by\n  rw [show âˆ = âˆ + 1 from rfl, contDiffOn_succ_iff_fderiv_of_isOpen hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nhs : IsOpen s\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) f s) (And (DifferentiableOn ğ•œ f s) (ContDiffOn ğ•œ (â†‘Top.top) (fderiv ğ•œ f) s))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_fderiv_of_isOpen := contDiffOn_infty_iff_fderiv_of_isOpen\n\n"}
{"name":"ContDiffOn.fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nm n : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffOn ğ•œ m (fderivWithin ğ•œ f s) s","decl":"protected theorem ContDiffOn.fderivWithin (hf : ContDiffOn ğ•œ n f s) (hs : UniqueDiffOn ğ•œ s)\n    (hmn : m + 1 â‰¤ n) : ContDiffOn ğ•œ m (fderivWithin ğ•œ f s) s :=\n  ((contDiffOn_succ_iff_fderivWithin hs).1 (hf.of_le hmn)).2.2\n\n"}
{"name":"ContDiffOn.fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nm n : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\nhs : IsOpen s\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffOn ğ•œ m (fderiv ğ•œ f) s","decl":"theorem ContDiffOn.fderiv_of_isOpen (hf : ContDiffOn ğ•œ n f s) (hs : IsOpen s) (hmn : m + 1 â‰¤ n) :\n    ContDiffOn ğ•œ m (fderiv ğ•œ f) s :=\n  (hf.fderivWithin hs.uniqueDiffOn hmn).congr fun _ hx => (fderivWithin_of_isOpen hs hx).symm\n\n"}
{"name":"ContDiffOn.continuousOn_fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhs : UniqueDiffOn ğ•œ s\nhn : LE.le 1 n\nâŠ¢ ContinuousOn (fderivWithin ğ•œ f s) s","decl":"theorem ContDiffOn.continuousOn_fderivWithin (h : ContDiffOn ğ•œ n f s) (hs : UniqueDiffOn ğ•œ s)\n    (hn : 1 â‰¤ n) : ContinuousOn (fderivWithin ğ•œ f s) s :=\n  ((contDiffOn_succ_iff_fderivWithin hs).1\n    (h.of_le (show 0 + (1 : WithTop â„•âˆ) â‰¤ n from hn))).2.2.continuousOn\n\n"}
{"name":"ContDiffOn.continuousOn_fderiv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhs : IsOpen s\nhn : LE.le 1 n\nâŠ¢ ContinuousOn (fderiv ğ•œ f) s","decl":"theorem ContDiffOn.continuousOn_fderiv_of_isOpen (h : ContDiffOn ğ•œ n f s) (hs : IsOpen s)\n    (hn : 1 â‰¤ n) : ContinuousOn (fderiv ğ•œ f) s :=\n  ((contDiffOn_succ_iff_fderiv_of_isOpen hs).1\n    (h.of_le (show 0 + (1 : WithTop â„•âˆ) â‰¤ n from hn))).2.2.continuousOn\n\n"}
{"name":"contDiffWithinAt_univ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f Set.univ x) (ContDiffAt ğ•œ n f x)","decl":"theorem contDiffWithinAt_univ : ContDiffWithinAt ğ•œ n f univ x â†” ContDiffAt ğ•œ n f x :=\n  Iff.rfl\n\n"}
{"name":"contDiffAt_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (ContDiffAt ğ•œ (â†‘Top.top) f x) (âˆ€ (n : Nat), ContDiffAt ğ•œ (â†‘n) f x)","decl":"theorem contDiffAt_infty : ContDiffAt ğ•œ âˆ f x â†” âˆ€ n : â„•, ContDiffAt ğ•œ n f x := by\n  simp [â† contDiffWithinAt_univ, contDiffWithinAt_infty]\n\n"}
{"name":"contDiffAt_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (ContDiffAt ğ•œ (â†‘Top.top) f x) (âˆ€ (n : Nat), ContDiffAt ğ•œ (â†‘n) f x)","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiffAt_top := contDiffAt_infty\n\n"}
{"name":"ContDiffAt.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"theorem ContDiffAt.contDiffWithinAt (h : ContDiffAt ğ•œ n f x) : ContDiffWithinAt ğ•œ n f s x :=\n  h.mono (subset_univ _)\n\n"}
{"name":"ContDiffWithinAt.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffWithinAt ğ•œ n f s x\nhx : Membership.mem (nhds x) s\nâŠ¢ ContDiffAt ğ•œ n f x","decl":"theorem ContDiffWithinAt.contDiffAt (h : ContDiffWithinAt ğ•œ n f s x) (hx : s âˆˆ ğ“ x) :\n    ContDiffAt ğ•œ n f x := by rwa [ContDiffAt, â† contDiffWithinAt_inter hx, univ_inter]\n\n"}
{"name":"contDiffWithinAt_iff_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : Membership.mem (nhds x) s\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f s x) (ContDiffAt ğ•œ n f x)","decl":"theorem contDiffWithinAt_iff_contDiffAt (h : s âˆˆ ğ“ x) :\n    ContDiffWithinAt ğ•œ n f s x â†” ContDiffAt ğ•œ n f x := by\n  rw [â† univ_inter s, contDiffWithinAt_inter h, contDiffWithinAt_univ]\n\n"}
{"name":"IsOpen.contDiffOn_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhs : IsOpen s\nâŠ¢ Iff (ContDiffOn ğ•œ n f s) (âˆ€ â¦ƒa : Eâ¦„, Membership.mem s a â†’ ContDiffAt ğ•œ n f a)","decl":"theorem IsOpen.contDiffOn_iff (hs : IsOpen s) :\n    ContDiffOn ğ•œ n f s â†” âˆ€ â¦ƒaâ¦„, a âˆˆ s â†’ ContDiffAt ğ•œ n f a :=\n  forallâ‚‚_congr fun _ => contDiffWithinAt_iff_contDiffAt âˆ˜ hs.mem_nhds\n\n"}
{"name":"ContDiffOn.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffOn ğ•œ n f s\nhx : Membership.mem (nhds x) s\nâŠ¢ ContDiffAt ğ•œ n f x","decl":"theorem ContDiffOn.contDiffAt (h : ContDiffOn ğ•œ n f s) (hx : s âˆˆ ğ“ x) :\n    ContDiffAt ğ•œ n f x :=\n  (h _ (mem_of_mem_nhds hx)).contDiffAt hx\n\n"}
{"name":"ContDiffAt.congr_of_eventuallyEq","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf fâ‚ : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nhg : (nhds x).EventuallyEq fâ‚ f\nâŠ¢ ContDiffAt ğ•œ n fâ‚ x","decl":"theorem ContDiffAt.congr_of_eventuallyEq (h : ContDiffAt ğ•œ n f x) (hg : fâ‚ =á¶ [ğ“ x] f) :\n    ContDiffAt ğ•œ n fâ‚ x :=\n  h.congr_of_eventuallyEq_of_mem (by rwa [nhdsWithin_univ]) (mem_univ x)\n\n"}
{"name":"ContDiffAt.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nm n : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nhmn : LE.le m n\nâŠ¢ ContDiffAt ğ•œ m f x","decl":"theorem ContDiffAt.of_le (h : ContDiffAt ğ•œ n f x) (hmn : m â‰¤ n) : ContDiffAt ğ•œ m f x :=\n  ContDiffWithinAt.of_le h hmn\n\n"}
{"name":"ContDiffAt.continuousAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nâŠ¢ ContinuousAt f x","decl":"theorem ContDiffAt.continuousAt (h : ContDiffAt ğ•œ n f x) : ContinuousAt f x := by\n  simpa [continuousWithinAt_univ] using h.continuousWithinAt\n\n"}
{"name":"ContDiffAt.analyticAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nh : ContDiffAt ğ•œ Top.top f x\nâŠ¢ AnalyticAt ğ•œ f x","decl":"theorem ContDiffAt.analyticAt (h : ContDiffAt ğ•œ Ï‰ f x) : AnalyticAt ğ•œ f x := by\n  rw [â† contDiffWithinAt_univ] at h\n  rw [â† analyticWithinAt_univ]\n  exact h.analyticWithinAt\n\n"}
{"name":"AnalyticAt.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\ninstâœ : CompleteSpace F\nh : AnalyticAt ğ•œ f x\nâŠ¢ ContDiffAt ğ•œ n f x","decl":"/-- In a complete space, a function which is analytic at a point is also `C^Ï‰` there.\nNote that the same statement for `AnalyticOn` does not require completeness, see\n`AnalyticOn.contDiffOn`. -/\ntheorem AnalyticAt.contDiffAt [CompleteSpace F] (h : AnalyticAt ğ•œ f x) :\n    ContDiffAt ğ•œ n f x := by\n  rw [â† contDiffWithinAt_univ]\n  rw [â† analyticWithinAt_univ] at h\n  exact h.contDiffWithinAt\n\n"}
{"name":"contDiffWithinAt_compl_self","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n f (HasCompl.compl (Singleton.singleton x)) x) (ContDiffAt ğ•œ n f x)","decl":"@[simp]\ntheorem contDiffWithinAt_compl_self :\n    ContDiffWithinAt ğ•œ n f {x}á¶œ x â†” ContDiffAt ğ•œ n f x := by\n  rw [compl_eq_univ_diff, contDiffWithinAt_diff_singleton, contDiffWithinAt_univ]\n\n"}
{"name":"ContDiffAt.differentiableAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nhn : LE.le 1 n\nâŠ¢ DifferentiableAt ğ•œ f x","decl":"/-- If a function is `C^n` with `n â‰¥ 1` at a point, then it is differentiable there. -/\ntheorem ContDiffAt.differentiableAt (h : ContDiffAt ğ•œ n f x) (hn : 1 â‰¤ n) :\n    DifferentiableAt ğ•œ f x := by\n  simpa [hn, differentiableWithinAt_univ] using h.differentiableWithinAt\n\n"}
{"name":"ContDiffAt.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nm n : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nhm : LE.le m n\nh' : Eq m â†‘Top.top â†’ Eq n Top.top\nâŠ¢ Exists fun u => And (Membership.mem (nhds x) u) (ContDiffOn ğ•œ m f u)","decl":"nonrec lemma ContDiffAt.contDiffOn (h : ContDiffAt ğ•œ n f x) (hm : m â‰¤ n) (h' : m = âˆ â†’ n = Ï‰):\n    âˆƒ u âˆˆ ğ“ x, ContDiffOn ğ•œ m f u := by\n  simpa [nhdsWithin_univ] using h.contDiffOn hm h'\n\n"}
{"name":"contDiffAt_succ_iff_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : Nat\nâŠ¢ Iff (ContDiffAt ğ•œ (HAdd.hAdd (â†‘n) 1) f x) (Exists fun f' => And (Exists fun u => And (Membership.mem (nhds x) u) (âˆ€ (x : E), Membership.mem u x â†’ HasFDerivAt f (f' x) x)) (ContDiffAt ğ•œ (â†‘n) f' x))","decl":"/-- A function is `C^(n + 1)` at a point iff locally, it has a derivative which is `C^n`. -/\ntheorem contDiffAt_succ_iff_hasFDerivAt {n : â„•} :\n    ContDiffAt ğ•œ (n + 1) f x â†” âˆƒ f' : E â†’ E â†’L[ğ•œ] F,\n      (âˆƒ u âˆˆ ğ“ x, âˆ€ x âˆˆ u, HasFDerivAt f (f' x) x) âˆ§ ContDiffAt ğ•œ n f' x := by\n  rw [â† contDiffWithinAt_univ, contDiffWithinAt_succ_iff_hasFDerivWithinAt (by simp)]\n  simp only [nhdsWithin_univ, exists_prop, mem_univ, insert_eq_of_mem]\n  constructor\n  Â· rintro âŸ¨u, H, -, f', h_fderiv, h_cont_diffâŸ©\n    rcases mem_nhds_iff.mp H with âŸ¨t, htu, ht, hxtâŸ©\n    refine âŸ¨f', âŸ¨t, ?_âŸ©, h_cont_diff.contDiffAt HâŸ©\n    refine âŸ¨mem_nhds_iff.mpr âŸ¨t, Subset.rfl, ht, hxtâŸ©, ?_âŸ©\n    intro y hyt\n    refine (h_fderiv y (htu hyt)).hasFDerivAt ?_\n    exact mem_nhds_iff.mpr âŸ¨t, htu, ht, hytâŸ©\n  Â· rintro âŸ¨f', âŸ¨u, H, h_fderivâŸ©, h_cont_diffâŸ©\n    refine âŸ¨u, H, by simp, f', fun x hxu â†¦ ?_, h_cont_diff.contDiffWithinAtâŸ©\n    exact (h_fderiv x hxu).hasFDerivWithinAt\n\n"}
{"name":"ContDiffAt.eventually","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiffAt ğ•œ n f x\nh' : Ne n â†‘Top.top\nâŠ¢ Filter.Eventually (fun y => ContDiffAt ğ•œ n f y) (nhds x)","decl":"protected theorem ContDiffAt.eventually (h : ContDiffAt ğ•œ n f x) (h' : n â‰  âˆ) :\n    âˆ€á¶  y in ğ“ x, ContDiffAt ğ•œ n f y := by\n  simpa [nhdsWithin_univ] using ContDiffWithinAt.eventually h h'\n\n"}
{"name":"iteratedFDerivWithin_eq_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : Nat\nhs : UniqueDiffOn ğ•œ s\nh : ContDiffAt ğ•œ (â†‘n) f x\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n f s x) (iteratedFDeriv ğ•œ n f x)","decl":"theorem iteratedFDerivWithin_eq_iteratedFDeriv {n : â„•}\n    (hs : UniqueDiffOn ğ•œ s) (h : ContDiffAt ğ•œ n f x) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ n f s x = iteratedFDeriv ğ•œ n f x := by\n  rw [â† iteratedFDerivWithin_univ]\n  rcases h.contDiffOn' le_rfl (by simp) with âŸ¨u, u_open, xu, huâŸ©\n  rw [â† iteratedFDerivWithin_inter_open u_open xu,\n    â† iteratedFDerivWithin_inter_open u_open xu (s := univ)]\n  apply iteratedFDerivWithin_subset\n  Â· exact inter_subset_inter_left _ (subset_univ _)\n  Â· exact hs.inter u_open\n  Â· apply uniqueDiffOn_univ.inter u_open\n  Â· simpa using hu\n  Â· exact âŸ¨hx, xuâŸ©\n\n"}
{"name":"HasFTaylorSeriesUpTo.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : ENat\nf' : E â†’ FormalMultilinearSeries ğ•œ E F\nhf : HasFTaylorSeriesUpTo (â†‘n) f f'\nâŠ¢ ContDiff ğ•œ (â†‘n) f","decl":"/-- If `f` has a Taylor series up to `n`, then it is `C^n`. -/\ntheorem HasFTaylorSeriesUpTo.contDiff {n : â„•âˆ} {f' : E â†’ FormalMultilinearSeries ğ•œ E F}\n    (hf : HasFTaylorSeriesUpTo n f f') : ContDiff ğ•œ n f :=\n  âŸ¨f', hfâŸ©\n\n"}
{"name":"contDiffOn_univ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nâŠ¢ Iff (ContDiffOn ğ•œ n f Set.univ) (ContDiff ğ•œ n f)","decl":"theorem contDiffOn_univ : ContDiffOn ğ•œ n f univ â†” ContDiff ğ•œ n f := by\n  match n with\n  | Ï‰ =>\n    constructor\n    Â· intro H\n      use ftaylorSeriesWithin ğ•œ f univ\n      rw [â† hasFTaylorSeriesUpToOn_univ_iff]\n      refine âŸ¨H.ftaylorSeriesWithin uniqueDiffOn_univ, fun i â†¦ ?_âŸ©\n      rw [â† analyticOn_univ]\n      exact H.analyticOn.iteratedFDerivWithin uniqueDiffOn_univ _\n    Â· rintro âŸ¨p, hp, h'pâŸ© x _\n      exact âŸ¨univ, Filter.univ_sets _, p, (hp.hasFTaylorSeriesUpToOn univ).of_le le_top,\n        fun i â†¦ (h'p i).analyticOnâŸ©\n  | (n : â„•âˆ) =>\n    constructor\n    Â· intro H\n      use ftaylorSeriesWithin ğ•œ f univ\n      rw [â† hasFTaylorSeriesUpToOn_univ_iff]\n      exact H.ftaylorSeriesWithin uniqueDiffOn_univ\n    Â· rintro âŸ¨p, hpâŸ© x _ m hm\n      exact âŸ¨univ, Filter.univ_sets _, p,\n        (hp.hasFTaylorSeriesUpToOn univ).of_le (mod_cast hm)âŸ©\n\n"}
{"name":"contDiff_iff_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nâŠ¢ Iff (ContDiff ğ•œ n f) (âˆ€ (x : E), ContDiffAt ğ•œ n f x)","decl":"theorem contDiff_iff_contDiffAt : ContDiff ğ•œ n f â†” âˆ€ x, ContDiffAt ğ•œ n f x := by\n  simp [â† contDiffOn_univ, ContDiffOn, ContDiffAt]\n\n"}
{"name":"ContDiff.contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nâŠ¢ ContDiffAt ğ•œ n f x","decl":"theorem ContDiff.contDiffAt (h : ContDiff ğ•œ n f) : ContDiffAt ğ•œ n f x :=\n  contDiff_iff_contDiffAt.1 h x\n\n"}
{"name":"ContDiff.contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"theorem ContDiff.contDiffWithinAt (h : ContDiff ğ•œ n f) : ContDiffWithinAt ğ•œ n f s x :=\n  h.contDiffAt.contDiffWithinAt\n\n"}
{"name":"contDiff_infty","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) f) (âˆ€ (n : Nat), ContDiff ğ•œ (â†‘n) f)","decl":"theorem contDiff_infty : ContDiff ğ•œ âˆ f â†” âˆ€ n : â„•, ContDiff ğ•œ n f := by\n  simp [contDiffOn_univ.symm, contDiffOn_infty]\n\n"}
{"name":"contDiff_top","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) f) (âˆ€ (n : Nat), ContDiff ğ•œ (â†‘n) f)","decl":"@[deprecated (since := \"2024-11-25\")] alias contDiff_top := contDiff_infty\n\n"}
{"name":"contDiff_infty_iff_contDiff_omega","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) f) (âˆ€ (n : Nat), ContDiff ğ•œ (â†‘n) f)","decl":"@[deprecated (since := \"2024-11-25\")] alias contDiff_infty_iff_contDiff_omega := contDiff_infty\n\n"}
{"name":"contDiff_all_iff_nat","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (âˆ€ (n : ENat), ContDiff ğ•œ (â†‘n) f) (âˆ€ (n : Nat), ContDiff ğ•œ (â†‘n) f)","decl":"theorem contDiff_all_iff_nat : (âˆ€ n : â„•âˆ, ContDiff ğ•œ n f) â†” âˆ€ n : â„•, ContDiff ğ•œ n f := by\n  simp only [â† contDiffOn_univ, contDiffOn_all_iff_nat]\n\n"}
{"name":"ContDiff.contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"theorem ContDiff.contDiffOn (h : ContDiff ğ•œ n f) : ContDiffOn ğ•œ n f s :=\n  (contDiffOn_univ.2 h).mono (subset_univ _)\n\n"}
{"name":"contDiff_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ 0 f) (Continuous f)","decl":"@[simp]\ntheorem contDiff_zero : ContDiff ğ•œ 0 f â†” Continuous f := by\n  rw [â† contDiffOn_univ, continuous_iff_continuousOn_univ]\n  exact contDiffOn_zero\n\n"}
{"name":"contDiffAt_zero","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (ContDiffAt ğ•œ 0 f x) (Exists fun u => And (Membership.mem (nhds x) u) (ContinuousOn f u))","decl":"theorem contDiffAt_zero : ContDiffAt ğ•œ 0 f x â†” âˆƒ u âˆˆ ğ“ x, ContinuousOn f u := by\n  rw [â† contDiffWithinAt_univ]; simp [contDiffWithinAt_zero, nhdsWithin_univ]\n\n"}
{"name":"contDiffAt_one_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nâŠ¢ Iff (ContDiffAt ğ•œ 1 f x) (Exists fun f' => Exists fun u => And (Membership.mem (nhds x) u) (And (ContinuousOn f' u) (âˆ€ (x : E), Membership.mem u x â†’ HasFDerivAt f (f' x) x)))","decl":"theorem contDiffAt_one_iff :\n    ContDiffAt ğ•œ 1 f x â†”\n      âˆƒ f' : E â†’ E â†’L[ğ•œ] F, âˆƒ u âˆˆ ğ“ x, ContinuousOn f' u âˆ§ âˆ€ x âˆˆ u, HasFDerivAt f (f' x) x := by\n  rw [show (1 : WithTop â„•âˆ) = (0 : â„•) + 1 from rfl]\n  simp_rw [contDiffAt_succ_iff_hasFDerivAt, show ((0 : â„•) : WithTop â„•âˆ) = 0 from rfl,\n    contDiffAt_zero, exists_mem_and_iff antitone_bforall antitone_continuousOn, and_comm]\n\n"}
{"name":"ContDiff.of_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nm n : WithTop ENat\nh : ContDiff ğ•œ n f\nhmn : LE.le m n\nâŠ¢ ContDiff ğ•œ m f","decl":"theorem ContDiff.of_le (h : ContDiff ğ•œ n f) (hmn : m â‰¤ n) : ContDiff ğ•œ m f :=\n  contDiffOn_univ.1 <| (contDiffOn_univ.2 h).of_le hmn\n\n"}
{"name":"ContDiff.of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ (HAdd.hAdd n 1) f\nâŠ¢ ContDiff ğ•œ n f","decl":"theorem ContDiff.of_succ (h : ContDiff ğ•œ (n + 1) f) : ContDiff ğ•œ n f :=\n  h.of_le le_self_add\n\n"}
{"name":"ContDiff.one_of_succ","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ (HAdd.hAdd n 1) f\nâŠ¢ ContDiff ğ•œ 1 f","decl":"theorem ContDiff.one_of_succ (h : ContDiff ğ•œ (n + 1) f) : ContDiff ğ•œ 1 f := by\n  apply h.of_le le_add_self\n\n"}
{"name":"ContDiff.continuous","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nâŠ¢ Continuous f","decl":"theorem ContDiff.continuous (h : ContDiff ğ•œ n f) : Continuous f :=\n  contDiff_zero.1 (h.of_le bot_le)\n\n"}
{"name":"ContDiff.differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nhn : LE.le 1 n\nâŠ¢ Differentiable ğ•œ f","decl":"/-- If a function is `C^n` with `n â‰¥ 1`, then it is differentiable. -/\ntheorem ContDiff.differentiable (h : ContDiff ğ•œ n f) (hn : 1 â‰¤ n) : Differentiable ğ•œ f :=\n  differentiableOn_univ.1 <| (contDiffOn_univ.2 h).differentiableOn hn\n\n"}
{"name":"contDiff_iff_forall_nat_le","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : ENat\nâŠ¢ Iff (ContDiff ğ•œ (â†‘n) f) (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ ContDiff ğ•œ (â†‘m) f)","decl":"theorem contDiff_iff_forall_nat_le {n : â„•âˆ} :\n    ContDiff ğ•œ n f â†” âˆ€ m : â„•, â†‘m â‰¤ n â†’ ContDiff ğ•œ m f := by\n  simp_rw [â† contDiffOn_univ]; exact contDiffOn_iff_forall_nat_le\n\n"}
{"name":"contDiff_succ_iff_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ Iff (ContDiff ğ•œ (HAdd.hAdd (â†‘n) 1) f) (Exists fun f' => And (ContDiff ğ•œ (â†‘n) f') (âˆ€ (x : E), HasFDerivAt f (f' x) x))","decl":"/-- A function is `C^(n+1)` iff it has a `C^n` derivative. -/\ntheorem contDiff_succ_iff_hasFDerivAt {n : â„•} :\n    ContDiff ğ•œ (n + 1) f â†”\n      âˆƒ f' : E â†’ E â†’L[ğ•œ] F, ContDiff ğ•œ n f' âˆ§ âˆ€ x, HasFDerivAt f (f' x) x := by\n  simp only [â† contDiffOn_univ, â† hasFDerivWithinAt_univ, Set.mem_univ, forall_true_left,\n    contDiffOn_succ_iff_hasFDerivWithinAt_of_uniqueDiffOn uniqueDiffOn_univ,\n    WithTop.natCast_ne_top, analyticOn_univ, false_implies, true_and]\n\n"}
{"name":"contDiff_one_iff_hasFDerivAt","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ 1 f) (Exists fun f' => And (Continuous f') (âˆ€ (x : E), HasFDerivAt f (f' x) x))","decl":"theorem contDiff_one_iff_hasFDerivAt : ContDiff ğ•œ 1 f â†”\n    âˆƒ f' : E â†’ E â†’L[ğ•œ] F, Continuous f' âˆ§ âˆ€ x, HasFDerivAt f (f' x) x := by\n  convert contDiff_succ_iff_hasFDerivAt using 4; simp\n\n"}
{"name":"AnalyticOn.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nhf : AnalyticOn ğ•œ f Set.univ\nâŠ¢ ContDiff ğ•œ n f","decl":"theorem AnalyticOn.contDiff (hf : AnalyticOn ğ•œ f univ) : ContDiff ğ•œ n f := by\n  rw [â† contDiffOn_univ]\n  exact hf.contDiffOn (n := n) uniqueDiffOn_univ\n\n"}
{"name":"AnalyticOnNhd.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nhf : AnalyticOnNhd ğ•œ f Set.univ\nâŠ¢ ContDiff ğ•œ n f","decl":"theorem AnalyticOnNhd.contDiff (hf : AnalyticOnNhd ğ•œ f univ) : ContDiff ğ•œ n f :=\n  hf.analyticOn.contDiff\n\n"}
{"name":"ContDiff.analyticOnNhd","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nh : ContDiff ğ•œ Top.top f\nâŠ¢ AnalyticOnNhd ğ•œ f s","decl":"theorem ContDiff.analyticOnNhd (h : ContDiff ğ•œ Ï‰ f) : AnalyticOnNhd ğ•œ f s := by\n  rw [â† contDiffOn_univ] at h\n  have := h.analyticOn\n  rw [analyticOn_univ] at this\n  exact this.mono (subset_univ _)\n\n"}
{"name":"contDiff_omega_iff_analyticOnNhd","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ Top.top f) (AnalyticOnNhd ğ•œ f Set.univ)","decl":"theorem contDiff_omega_iff_analyticOnNhd :\n    ContDiff ğ•œ Ï‰ f â†” AnalyticOnNhd ğ•œ f univ :=\n  âŸ¨fun h â†¦ h.analyticOnNhd, fun h â†¦ h.contDiffâŸ©\n\n"}
{"name":"ContDiff.ftaylorSeries","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nhf : ContDiff ğ•œ n f\nâŠ¢ HasFTaylorSeriesUpTo n f (ftaylorSeries ğ•œ f)","decl":"/-- When a function is `C^n`, it admits `ftaylorSeries ğ•œ f` as a Taylor series up\nto order `n` in `s`. -/\ntheorem ContDiff.ftaylorSeries (hf : ContDiff ğ•œ n f) :\n    HasFTaylorSeriesUpTo n f (ftaylorSeries ğ•œ f) := by\n  simp only [â† contDiffOn_univ, â† hasFTaylorSeriesUpToOn_univ_iff, â† ftaylorSeriesWithin_univ]\n    at hf âŠ¢\n  exact ContDiffOn.ftaylorSeriesWithin hf uniqueDiffOn_univ\n\n"}
{"name":"contDiff_iff_ftaylorSeries","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : ENat\nâŠ¢ Iff (ContDiff ğ•œ (â†‘n) f) (HasFTaylorSeriesUpTo (â†‘n) f (ftaylorSeries ğ•œ f))","decl":"/-- For `n : â„•âˆ`, a function is `C^n` iff it admits `ftaylorSeries ğ•œ f`\nas a Taylor series up to order `n`. -/\ntheorem contDiff_iff_ftaylorSeries {n : â„•âˆ} :\n    ContDiff ğ•œ n f â†” HasFTaylorSeriesUpTo n f (ftaylorSeries ğ•œ f) := by\n  constructor\n  Â· rw [â† contDiffOn_univ, â† hasFTaylorSeriesUpToOn_univ_iff, â† ftaylorSeriesWithin_univ]\n    exact fun h â†¦ ContDiffOn.ftaylorSeriesWithin h uniqueDiffOn_univ\n  Â· exact fun h â†¦ âŸ¨ftaylorSeries ğ•œ f, hâŸ©\n\n"}
{"name":"contDiff_iff_continuous_differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : ENat\nâŠ¢ Iff (ContDiff ğ•œ (â†‘n) f) (And (âˆ€ (m : Nat), LE.le (â†‘m) n â†’ Continuous fun x => iteratedFDeriv ğ•œ m f x) (âˆ€ (m : Nat), LT.lt (â†‘m) n â†’ Differentiable ğ•œ fun x => iteratedFDeriv ğ•œ m f x))","decl":"theorem contDiff_iff_continuous_differentiable {n : â„•âˆ} :\n    ContDiff ğ•œ n f â†”\n      (âˆ€ m : â„•, m â‰¤ n â†’ Continuous fun x => iteratedFDeriv ğ•œ m f x) âˆ§\n        âˆ€ m : â„•, m < n â†’ Differentiable ğ•œ fun x => iteratedFDeriv ğ•œ m f x := by\n  simp [contDiffOn_univ.symm, continuous_iff_continuousOn_univ, differentiableOn_univ.symm,\n    iteratedFDerivWithin_univ, contDiffOn_iff_continuousOn_differentiableOn uniqueDiffOn_univ]\n\n"}
{"name":"contDiff_nat_iff_continuous_differentiable","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : Nat\nâŠ¢ Iff (ContDiff ğ•œ (â†‘n) f) (And (âˆ€ (m : Nat), LE.le m n â†’ Continuous fun x => iteratedFDeriv ğ•œ m f x) (âˆ€ (m : Nat), LT.lt m n â†’ Differentiable ğ•œ fun x => iteratedFDeriv ğ•œ m f x))","decl":"theorem contDiff_nat_iff_continuous_differentiable {n : â„•} :\n    ContDiff ğ•œ n f â†”\n      (âˆ€ m : â„•, m â‰¤ n â†’ Continuous fun x => iteratedFDeriv ğ•œ m f x) âˆ§\n        âˆ€ m : â„•, m < n â†’ Differentiable ğ•œ fun x => iteratedFDeriv ğ•œ m f x := by\n  rw [show n = ((n : â„•âˆ) : WithTop â„•âˆ) from rfl, contDiff_iff_continuous_differentiable]\n  simp\n\n"}
{"name":"ContDiff.continuous_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nm : Nat\nhm : LE.le (â†‘m) n\nhf : ContDiff ğ•œ n f\nâŠ¢ Continuous fun x => iteratedFDeriv ğ•œ m f x","decl":"/-- If `f` is `C^n` then its `m`-times iterated derivative is continuous for `m â‰¤ n`. -/\ntheorem ContDiff.continuous_iteratedFDeriv {m : â„•} (hm : m â‰¤ n) (hf : ContDiff ğ•œ n f) :\n    Continuous fun x => iteratedFDeriv ğ•œ m f x :=\n  (contDiff_iff_continuous_differentiable.mp (hf.of_le hm)).1 m le_rfl\n\n"}
{"name":"ContDiff.differentiable_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nm : Nat\nhm : LT.lt (â†‘m) n\nhf : ContDiff ğ•œ n f\nâŠ¢ Differentiable ğ•œ fun x => iteratedFDeriv ğ•œ m f x","decl":"/-- If `f` is `C^n` then its `m`-times iterated derivative is differentiable for `m < n`. -/\ntheorem ContDiff.differentiable_iteratedFDeriv {m : â„•} (hm : m < n) (hf : ContDiff ğ•œ n f) :\n    Differentiable ğ•œ fun x => iteratedFDeriv ğ•œ m f x :=\n  (contDiff_iff_continuous_differentiable.mp\n    (hf.of_le (ENat.add_one_natCast_le_withTop_of_lt hm))).2 m (mod_cast lt_add_one m)\n\n"}
{"name":"contDiff_of_differentiable_iteratedFDeriv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : ENat\nh : âˆ€ (m : Nat), LE.le (â†‘m) n â†’ Differentiable ğ•œ (iteratedFDeriv ğ•œ m f)\nâŠ¢ ContDiff ğ•œ (â†‘n) f","decl":"theorem contDiff_of_differentiable_iteratedFDeriv {n : â„•âˆ}\n    (h : âˆ€ m : â„•, m â‰¤ n â†’ Differentiable ğ•œ (iteratedFDeriv ğ•œ m f)) : ContDiff ğ•œ n f :=\n  contDiff_iff_continuous_differentiable.2\n    âŸ¨fun m hm => (h m hm).continuous, fun m hm => h m (le_of_lt hm)âŸ©\n\n"}
{"name":"contDiff_succ_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nâŠ¢ Iff (ContDiff ğ•œ (HAdd.hAdd n 1) f) (And (Differentiable ğ•œ f) (And (Eq n Top.top â†’ AnalyticOnNhd ğ•œ f Set.univ) (ContDiff ğ•œ n (fderiv ğ•œ f))))","decl":"/-- A function is `C^(n + 1)` if and only if it is differentiable,\nand its derivative (formulated in terms of `fderiv`) is `C^n`. -/\ntheorem contDiff_succ_iff_fderiv :\n    ContDiff ğ•œ (n + 1) f â†” Differentiable ğ•œ f âˆ§ (n = Ï‰ â†’ AnalyticOnNhd ğ•œ f univ) âˆ§\n      ContDiff ğ•œ n (fderiv ğ•œ f) := by\n  simp only [â† contDiffOn_univ, â† differentiableOn_univ, â† fderivWithin_univ,\n    contDiffOn_succ_iff_fderivWithin uniqueDiffOn_univ, analyticOn_univ]\n\n"}
{"name":"contDiff_one_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ 1 f) (And (Differentiable ğ•œ f) (Continuous (fderiv ğ•œ f)))","decl":"theorem contDiff_one_iff_fderiv :\n    ContDiff ğ•œ 1 f â†” Differentiable ğ•œ f âˆ§ Continuous (fderiv ğ•œ f) := by\n  rw [show (1 : WithTop â„•âˆ) = 0 + 1 from rfl, contDiff_succ_iff_fderiv]\n  simp\n\n"}
{"name":"contDiff_infty_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) f) (And (Differentiable ğ•œ f) (ContDiff ğ•œ (â†‘Top.top) (fderiv ğ•œ f)))","decl":"theorem contDiff_infty_iff_fderiv :\n    ContDiff ğ•œ âˆ f â†” Differentiable ğ•œ f âˆ§ ContDiff ğ•œ âˆ (fderiv ğ•œ f) := by\n  rw [show âˆ = âˆ + 1 from rfl, contDiff_succ_iff_fderiv]\n  simp\n\n"}
{"name":"contDiff_top_iff_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) f) (And (Differentiable ğ•œ f) (ContDiff ğ•œ (â†‘Top.top) (fderiv ğ•œ f)))","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiff_top_iff_fderiv := contDiff_infty_iff_fderiv\n\n"}
{"name":"ContDiff.continuous_fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nhn : LE.le 1 n\nâŠ¢ Continuous (fderiv ğ•œ f)","decl":"theorem ContDiff.continuous_fderiv (h : ContDiff ğ•œ n f) (hn : 1 â‰¤ n) :\n    Continuous (fderiv ğ•œ f) :=\n  (contDiff_one_iff_fderiv.1 (h.of_le hn)).2\n\n"}
{"name":"ContDiff.continuous_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Defs","initialProofState":"ğ•œ : Type u\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nh : ContDiff ğ•œ n f\nhn : LE.le 1 n\nâŠ¢ Continuous fun p => (fderiv ğ•œ f p.1) p.2","decl":"/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem ContDiff.continuous_fderiv_apply (h : ContDiff ğ•œ n f) (hn : 1 â‰¤ n) :\n    Continuous fun p : E Ã— E => (fderiv ğ•œ f p.1 : E â†’ F) p.2 :=\n  have A : Continuous fun q : (E â†’L[ğ•œ] F) Ã— E => q.1 q.2 := isBoundedBilinearMap_apply.continuous\n  have B : Continuous fun p : E Ã— E => (fderiv ğ•œ f p.1, p.2) :=\n    ((h.continuous_fderiv hn).comp continuous_fst).prod_mk continuous_snd\n  A.comp B\n"}
