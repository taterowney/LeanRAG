{"name":"ContDiffWithinAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\ns : Set E\na : E\nn : ENat\nhc : ContDiffWithinAt Real (‚Üën) c s a\nhR : ContDiffWithinAt Real (‚Üën) R s a\nhx : ContDiffWithinAt Real (‚Üën) x s a\nhne : Ne (x a) (c a)\n‚ä¢ ContDiffWithinAt Real (‚Üën) (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s a","decl":"protected theorem ContDiffWithinAt.inversion (hc : ContDiffWithinAt ‚Ñù n c s a)\n    (hR : ContDiffWithinAt ‚Ñù n R s a) (hx : ContDiffWithinAt ‚Ñù n x s a) (hne : x a ‚â† c a) :\n    ContDiffWithinAt ‚Ñù n (fun a ‚Ü¶ inversion (c a) (R a) (x a)) s a :=\n  (((hR.div (hx.dist ‚Ñù hc hne) (dist_ne_zero.2 hne)).pow _).smul (hx.sub hc)).add hc\n\n"}
{"name":"ContDiffOn.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\ns : Set E\nn : ENat\nhc : ContDiffOn Real (‚Üën) c s\nhR : ContDiffOn Real (‚Üën) R s\nhx : ContDiffOn Real (‚Üën) x s\nhne : ‚àÄ (a : E), Membership.mem s a ‚Üí Ne (x a) (c a)\n‚ä¢ ContDiffOn Real (‚Üën) (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s","decl":"protected theorem ContDiffOn.inversion (hc : ContDiffOn ‚Ñù n c s) (hR : ContDiffOn ‚Ñù n R s)\n    (hx : ContDiffOn ‚Ñù n x s) (hne : ‚àÄ a ‚àà s, x a ‚â† c a) :\n    ContDiffOn ‚Ñù n (fun a ‚Ü¶ inversion (c a) (R a) (x a)) s := fun a ha ‚Ü¶\n  (hc a ha).inversion (hR a ha) (hx a ha) (hne a ha)\n\n"}
{"name":"ContDiffAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\na : E\nn : ENat\nhc : ContDiffAt Real (‚Üën) c a\nhR : ContDiffAt Real (‚Üën) R a\nhx : ContDiffAt Real (‚Üën) x a\nhne : Ne (x a) (c a)\n‚ä¢ ContDiffAt Real (‚Üën) (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) a","decl":"protected nonrec theorem ContDiffAt.inversion (hc : ContDiffAt ‚Ñù n c a) (hR : ContDiffAt ‚Ñù n R a)\n    (hx : ContDiffAt ‚Ñù n x a) (hne : x a ‚â† c a) :\n    ContDiffAt ‚Ñù n (fun a ‚Ü¶ inversion (c a) (R a) (x a)) a :=\n  hc.inversion hR hx hne\n\n"}
{"name":"ContDiff.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\nn : ENat\nhc : ContDiff Real (‚Üën) c\nhR : ContDiff Real (‚Üën) R\nhx : ContDiff Real (‚Üën) x\nhne : ‚àÄ (a : E), Ne (x a) (c a)\n‚ä¢ ContDiff Real ‚Üën fun a => EuclideanGeometry.inversion (c a) (R a) (x a)","decl":"protected nonrec theorem ContDiff.inversion (hc : ContDiff ‚Ñù n c) (hR : ContDiff ‚Ñù n R)\n    (hx : ContDiff ‚Ñù n x) (hne : ‚àÄ a, x a ‚â† c a) :\n    ContDiff ‚Ñù n (fun a ‚Ü¶ inversion (c a) (R a) (x a)) :=\n  contDiff_iff_contDiffAt.2 fun a ‚Ü¶ hc.contDiffAt.inversion hR.contDiffAt hx.contDiffAt (hne a)\n\n"}
{"name":"DifferentiableWithinAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\ns : Set E\na : E\nhc : DifferentiableWithinAt Real c s a\nhR : DifferentiableWithinAt Real R s a\nhx : DifferentiableWithinAt Real x s a\nhne : Ne (x a) (c a)\n‚ä¢ DifferentiableWithinAt Real (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s a","decl":"protected theorem DifferentiableWithinAt.inversion (hc : DifferentiableWithinAt ‚Ñù c s a)\n    (hR : DifferentiableWithinAt ‚Ñù R s a) (hx : DifferentiableWithinAt ‚Ñù x s a) (hne : x a ‚â† c a) :\n    DifferentiableWithinAt ‚Ñù (fun a ‚Ü¶ inversion (c a) (R a) (x a)) s a :=\n  -- TODO: Use `.div` https://github.com/leanprover-community/mathlib4/issues/5870\n  (((hR.mul <| (hx.dist ‚Ñù hc hne).inv (dist_ne_zero.2 hne)).pow _).smul (hx.sub hc)).add hc\n\n"}
{"name":"DifferentiableOn.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\ns : Set E\nhc : DifferentiableOn Real c s\nhR : DifferentiableOn Real R s\nhx : DifferentiableOn Real x s\nhne : ‚àÄ (a : E), Membership.mem s a ‚Üí Ne (x a) (c a)\n‚ä¢ DifferentiableOn Real (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) s","decl":"protected theorem DifferentiableOn.inversion (hc : DifferentiableOn ‚Ñù c s)\n    (hR : DifferentiableOn ‚Ñù R s) (hx : DifferentiableOn ‚Ñù x s) (hne : ‚àÄ a ‚àà s, x a ‚â† c a) :\n    DifferentiableOn ‚Ñù (fun a ‚Ü¶ inversion (c a) (R a) (x a)) s := fun a ha ‚Ü¶\n  (hc a ha).inversion (hR a ha) (hx a ha) (hne a ha)\n\n"}
{"name":"DifferentiableAt.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\na : E\nhc : DifferentiableAt Real c a\nhR : DifferentiableAt Real R a\nhx : DifferentiableAt Real x a\nhne : Ne (x a) (c a)\n‚ä¢ DifferentiableAt Real (fun a => EuclideanGeometry.inversion (c a) (R a) (x a)) a","decl":"protected theorem DifferentiableAt.inversion (hc : DifferentiableAt ‚Ñù c a)\n    (hR : DifferentiableAt ‚Ñù R a) (hx : DifferentiableAt ‚Ñù x a) (hne : x a ‚â† c a) :\n    DifferentiableAt ‚Ñù (fun a ‚Ü¶ inversion (c a) (R a) (x a)) a := by\n  rw [‚Üê differentiableWithinAt_univ] at *\n  exact hc.inversion hR hx hne\n\n"}
{"name":"Differentiable.inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"E : Type u_1\nF : Type u_2\ninst‚úù¬≥ : NormedAddCommGroup E\ninst‚úù¬≤ : NormedSpace Real E\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : E ‚Üí F\nR : E ‚Üí Real\nhc : Differentiable Real c\nhR : Differentiable Real R\nhx : Differentiable Real x\nhne : ‚àÄ (a : E), Ne (x a) (c a)\n‚ä¢ Differentiable Real fun a => EuclideanGeometry.inversion (c a) (R a) (x a)","decl":"protected theorem Differentiable.inversion (hc : Differentiable ‚Ñù c)\n    (hR : Differentiable ‚Ñù R) (hx : Differentiable ‚Ñù x) (hne : ‚àÄ a, x a ‚â† c a) :\n    Differentiable ‚Ñù (fun a ‚Ü¶ inversion (c a) (R a) (x a)) := fun a ‚Ü¶\n  (hc a).inversion (hR a) (hx a) (hne a)\n\n"}
{"name":"EuclideanGeometry.hasFDerivAt_inversion","module":"Mathlib.Geometry.Euclidean.Inversion.Calculus","initialProofState":"F : Type u_2\ninst‚úù¬π : NormedAddCommGroup F\ninst‚úù : InnerProductSpace Real F\nc x : F\nR : Real\nhx : Ne x c\n‚ä¢ HasFDerivAt (EuclideanGeometry.inversion c R) (HSMul.hSMul (HPow.hPow (HDiv.hDiv R (Dist.dist x c)) 2) ‚Üë{ toLinearEquiv := (reflection (Submodule.span Real (Singleton.singleton (HSub.hSub x c))).orthogonal).toLinearEquiv, continuous_toFun := ‚ãØ, continuous_invFun := ‚ãØ }) x","decl":"/-- Formula for the Fr√©chet derivative of `EuclideanGeometry.inversion c R`. -/\ntheorem hasFDerivAt_inversion (hx : x ‚â† c) :\n    HasFDerivAt (inversion c R)\n      ((R / dist x c) ^ 2 ‚Ä¢ (reflection (‚Ñù ‚àô (x - c))·óÆ : F ‚ÜíL[‚Ñù] F)) x := by\n  rcases add_left_surjective c x with ‚ü®x, rfl‚ü©\n  have : HasFDerivAt (inversion c R) (?_ : F ‚ÜíL[‚Ñù] F) (c + x) := by\n    simp +unfoldPartialApp only [inversion]\n    simp_rw [dist_eq_norm, div_pow, div_eq_mul_inv]\n    have A := (hasFDerivAt_id (ùïú := ‚Ñù) (c + x)).sub_const c\n    have B := ((hasDerivAt_inv <| by simpa using hx).comp_hasFDerivAt _ A.norm_sq).const_mul\n      (R ^ 2)\n    exact (B.smul A).add_const c\n  refine this.congr_fderiv (LinearMap.ext_on_codisjoint\n    (Submodule.isCompl_orthogonal_of_completeSpace (K := ‚Ñù ‚àô x)).codisjoint\n    (LinearMap.eqOn_span' ?_) fun y hy ‚Ü¶ ?_)\n  ¬∑ have : ((‚Äñx‚Äñ ^ 2) ^ 2)‚Åª¬π * (‚Äñx‚Äñ ^ 2) = (‚Äñx‚Äñ ^ 2)‚Åª¬π := by\n      rw [‚Üê div_eq_inv_mul, sq (‚Äñx‚Äñ ^ 2), div_self_mul_self']\n    simp [reflection_orthogonalComplement_singleton_eq_neg, real_inner_self_eq_norm_sq,\n      two_mul, this, div_eq_mul_inv, mul_add, add_smul, mul_pow]\n  ¬∑ simp [Submodule.mem_orthogonal_singleton_iff_inner_right.1 hy,\n      reflection_mem_subspace_eq_self hy, div_eq_mul_inv, mul_pow]\n\n"}
