{"name":"Finset.exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nhb : LT.lt (HSMul.hSMul t.card b) (s.sum fun x => w x)\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt b ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x))","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is greater than `n • b`, and they are sorted into\n`n` pigeonholes, then for some pigeonhole, the total weight of the pigeons in this pigeonhole is\ngreater than `b`. -/\ntheorem exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum (hf : ∀ a ∈ s, f a ∈ t)\n    (hb : #t • b < ∑ x ∈ s, w x) : ∃ y ∈ t, b < ∑ x ∈ s with f x = y, w x :=\n  exists_lt_of_sum_lt <| by simpa only [sum_fiberwise_of_maps_to hf, sum_const]\n\n"}
{"name":"Finset.exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nhb : LT.lt (s.sum fun x => w x) (HSMul.hSMul t.card b)\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x) b)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is less than `n • b`, and they are sorted into `n`\npigeonholes, then for some pigeonhole, the total weight of the pigeons in this pigeonhole is less\nthan `b`. -/\ntheorem exists_sum_fiber_lt_of_maps_to_of_sum_lt_nsmul (hf : ∀ a ∈ s, f a ∈ t)\n    (hb : ∑ x ∈ s, w x < #t • b) : ∃ y ∈ t, ∑ x ∈ s with f x = y, w x < b :=\n  exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum (M := Mᵒᵈ) hf hb\n\n"}
{"name":"Finset.exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nht : ∀ (y : β), Not (Membership.mem t y) → LE.le ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x) 0\nhb : LT.lt (HSMul.hSMul t.card b) (s.sum fun x => w x)\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt b ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x))","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is greater than `n • b`, they are sorted into some\npigeonholes, and for all but `n` pigeonholes the total weight of the pigeons there is nonpositive,\nthen for at least one of these `n` pigeonholes, the total weight of the pigeons in this pigeonhole\nis greater than `b`. -/\ntheorem exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum\n    (ht : ∀ y ∉ t, ∑ x ∈ s with f x = y, w x ≤ 0)\n    (hb : #t • b < ∑ x ∈ s, w x) : ∃ y ∈ t, b < ∑ x ∈ s with f x = y, w x :=\n  exists_lt_of_sum_lt <|\n    calc\n      ∑ _y ∈ t, b < ∑ x ∈ s, w x := by simpa\n      _ ≤ ∑ y ∈ t, ∑ x ∈ s with f x = y, w x := sum_le_sum_fiberwise_of_sum_fiber_nonpos ht\n\n"}
{"name":"Finset.exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nht : ∀ (y : β), Not (Membership.mem t y) → LE.le 0 ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x)\nhb : LT.lt (s.sum fun x => w x) (HSMul.hSMul t.card b)\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x) b)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, strict inequality version:\nif the total weight of a finite set of pigeons is less than `n • b`, they are sorted into some\npigeonholes, and for all but `n` pigeonholes the total weight of the pigeons there is nonnegative,\nthen for at least one of these `n` pigeonholes, the total weight of the pigeons in this pigeonhole\nis less than `b`. -/\ntheorem exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul\n    (ht : ∀ y ∉ t, (0 : M) ≤ ∑ x ∈ s with f x = y, w x) (hb : ∑ x ∈ s, w x < #t • b) :\n    ∃ y ∈ t, ∑ x ∈ s with f x = y, w x < b :=\n  exists_lt_sum_fiber_of_sum_fiber_nonpos_of_nsmul_lt_sum (M := Mᵒᵈ) ht hb\n\n"}
{"name":"Finset.exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nht : t.Nonempty\nhb : LE.le (HSMul.hSMul t.card b) (s.sum fun x => w x)\n⊢ Exists fun y => And (Membership.mem t y) (LE.le b ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x))","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is greater than or equal to `n • b`, and\nthey are sorted into `n > 0` pigeonholes, then for some pigeonhole, the total weight of the pigeons\nin this pigeonhole is greater than or equal to `b`. -/\ntheorem exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum (hf : ∀ a ∈ s, f a ∈ t) (ht : t.Nonempty)\n    (hb : #t • b ≤ ∑ x ∈ s, w x) : ∃ y ∈ t, b ≤ ∑ x ∈ s with f x = y, w x :=\n  exists_le_of_sum_le ht <| by simpa only [sum_fiberwise_of_maps_to hf, sum_const]\n\n"}
{"name":"Finset.exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nht : t.Nonempty\nhb : LE.le (s.sum fun x => w x) (HSMul.hSMul t.card b)\n⊢ Exists fun y => And (Membership.mem t y) (LE.le ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x) b)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is less than or equal to `n • b`, and they\nare sorted into `n > 0` pigeonholes, then for some pigeonhole, the total weight of the pigeons in\nthis pigeonhole is less than or equal to `b`. -/\ntheorem exists_sum_fiber_le_of_maps_to_of_sum_le_nsmul (hf : ∀ a ∈ s, f a ∈ t) (ht : t.Nonempty)\n    (hb : ∑ x ∈ s, w x ≤ #t • b) : ∃ y ∈ t, ∑ x ∈ s with f x = y, w x ≤ b :=\n  exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum (M := Mᵒᵈ) hf ht hb\n\n"}
{"name":"Finset.exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhf : ∀ (y : β), Not (Membership.mem t y) → LE.le ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x) 0\nht : t.Nonempty\nhb : LE.le (HSMul.hSMul t.card b) (s.sum fun x => w x)\n⊢ Exists fun y => And (Membership.mem t y) (LE.le b ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x))","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is greater than or equal to `n • b`, they\nare sorted into some pigeonholes, and for all but `n > 0` pigeonholes the total weight of the\npigeons there is nonpositive, then for at least one of these `n` pigeonholes, the total weight of\nthe pigeons in this pigeonhole is greater than or equal to `b`. -/\ntheorem exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum\n    (hf : ∀ y ∉ t, ∑ x ∈ s with f x = y, w x ≤ 0) (ht : t.Nonempty)\n    (hb : #t • b ≤ ∑ x ∈ s, w x) : ∃ y ∈ t, b ≤ ∑ x ∈ s with f x = y, w x :=\n  exists_le_of_sum_le ht <|\n    calc\n      ∑ _y ∈ t, b ≤ ∑ x ∈ s, w x := by simpa\n      _ ≤ ∑ y ∈ t, ∑ x ∈ s with f x = y, w x :=\n        sum_le_sum_fiberwise_of_sum_fiber_nonpos hf\n\n"}
{"name":"Finset.exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhf : ∀ (y : β), Not (Membership.mem t y) → LE.le 0 ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x)\nht : t.Nonempty\nhb : LE.le (s.sum fun x => w x) (HSMul.hSMul t.card b)\n⊢ Exists fun y => And (Membership.mem t y) (LE.le ((Finset.filter (fun x => Eq (f x) y) s).sum fun x => w x) b)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by weight, non-strict inequality\nversion: if the total weight of a finite set of pigeons is less than or equal to `n • b`, they are\nsorted into some pigeonholes, and for all but `n > 0` pigeonholes the total weight of the pigeons\nthere is nonnegative, then for at least one of these `n` pigeonholes, the total weight of the\npigeons in this pigeonhole is less than or equal to `b`. -/\ntheorem exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul\n    (hf : ∀ y ∉ t, (0 : M) ≤ ∑ x ∈ s with f x = y, w x) (ht : t.Nonempty)\n    (hb : ∑ x ∈ s, w x ≤ #t • b) : ∃ y ∈ t, ∑ x ∈ s with f x = y, w x ≤ b :=\n  exists_le_sum_fiber_of_sum_fiber_nonpos_of_nsmul_le_sum (M := Mᵒᵈ) hf ht hb\n\n"}
{"name":"Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nb : M\ninst✝ : LinearOrderedCommSemiring M\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nht : LT.lt (HSMul.hSMul t.card b) ↑s.card\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt b ↑(Finset.filter (fun x => Eq (f x) y) s).card)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat least as many pigeons as the ceiling of the average number of pigeons across all pigeonholes. -/\ntheorem exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to (hf : ∀ a ∈ s, f a ∈ t)\n    (ht : #t • b < #s) : ∃ y ∈ t, b < #{x ∈ s | f x = y} := by\n  simp_rw [cast_card] at ht ⊢\n  exact exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum hf ht\n\n"}
{"name":"Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nn : Nat\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nhn : LT.lt (HMul.hMul t.card n) s.card\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt n (Finset.filter (fun x => Eq (f x) y) s).card)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat least as many pigeons as the ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function between finite sets `s` and `t` and a natural number `n` such that\n`#t * n < #s`, there exists `y ∈ t` such that its preimage in `s` has more than `n`\nelements. -/\ntheorem exists_lt_card_fiber_of_mul_lt_card_of_maps_to (hf : ∀ a ∈ s, f a ∈ t)\n    (hn : #t * n < #s) : ∃ y ∈ t, n < #{x ∈ s | f x = y} :=\n  exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to hf hn\n\n"}
{"name":"Finset.exists_card_fiber_lt_of_card_lt_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nb : M\ninst✝ : LinearOrderedCommSemiring M\nht : LT.lt (↑s.card) (HSMul.hSMul t.card b)\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt (↑(Finset.filter (fun x => Eq (f x) y) s).card) b)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat most as many pigeons as the floor of the average number of pigeons across all pigeonholes. -/\ntheorem exists_card_fiber_lt_of_card_lt_nsmul (ht : #s < #t • b) :\n    ∃ y ∈ t, #{x ∈ s | f x = y} < b := by\n  simp_rw [cast_card] at ht ⊢\n  exact\n    exists_sum_fiber_lt_of_sum_fiber_nonneg_of_sum_lt_nsmul\n      (fun _ _ => sum_nonneg fun _ _ => zero_le_one) ht\n\n"}
{"name":"Finset.exists_card_fiber_lt_of_card_lt_mul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nn : Nat\nhn : LT.lt s.card (HMul.hMul t.card n)\n⊢ Exists fun y => And (Membership.mem t y) (LT.lt (Finset.filter (fun x => Eq (f x) y) s).card n)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: there is a pigeonhole with\nat most as many pigeons as the floor of the average number of pigeons across all pigeonholes.  (\"The\nminimum is at most the mean\" specialized to integers.)\n\nMore formally, given a function `f`, a finite sets `s` in its domain, a finite set `t` in its\ncodomain, and a natural number `n` such that `#s < #t * n`, there exists `y ∈ t` such that\nits preimage in `s` has less than `n` elements. -/\ntheorem exists_card_fiber_lt_of_card_lt_mul (hn : #s < #t * n) : ∃ y ∈ t, #{x ∈ s | f x = y} < n :=\n  exists_card_fiber_lt_of_card_lt_nsmul hn\n\n"}
{"name":"Finset.exists_le_card_fiber_of_nsmul_le_card_of_maps_to","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nb : M\ninst✝ : LinearOrderedCommSemiring M\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nht : t.Nonempty\nhb : LE.le (HSMul.hSMul t.card b) ↑s.card\n⊢ Exists fun y => And (Membership.mem t y) (LE.le b ↑(Finset.filter (fun x => Eq (f x) y) s).card)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: given a function between\nfinite sets `s` and `t` and a number `b` such that `#t • b ≤ #s`, there exists `y ∈ t` such\nthat its preimage in `s` has at least `b` elements.\nSee also `Finset.exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to` for a stronger statement. -/\ntheorem exists_le_card_fiber_of_nsmul_le_card_of_maps_to (hf : ∀ a ∈ s, f a ∈ t) (ht : t.Nonempty)\n    (hb : #t • b ≤ #s) : ∃ y ∈ t, b ≤ #{x ∈ s | f x = y} := by\n  simp_rw [cast_card] at hb ⊢\n  exact exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum hf ht hb\n\n"}
{"name":"Finset.exists_le_card_fiber_of_mul_le_card_of_maps_to","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nn : Nat\nhf : ∀ (a : α), Membership.mem s a → Membership.mem t (f a)\nht : t.Nonempty\nhn : LE.le (HMul.hMul t.card n) s.card\n⊢ Exists fun y => And (Membership.mem t y) (LE.le n (Finset.filter (fun x => Eq (f x) y) s).card)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: given a function between\nfinite sets `s` and `t` and a natural number `b` such that `#t * n ≤ #s`, there exists\n`y ∈ t` such that its preimage in `s` has at least `n` elements. See also\n`Finset.exists_lt_card_fiber_of_mul_lt_card_of_maps_to` for a stronger statement. -/\ntheorem exists_le_card_fiber_of_mul_le_card_of_maps_to (hf : ∀ a ∈ s, f a ∈ t) (ht : t.Nonempty)\n    (hn : #t * n ≤ #s) : ∃ y ∈ t, n ≤ #{x ∈ s | f x = y} :=\n  exists_le_card_fiber_of_nsmul_le_card_of_maps_to hf ht hn\n\n"}
{"name":"Finset.exists_card_fiber_le_of_card_le_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝¹ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nb : M\ninst✝ : LinearOrderedCommSemiring M\nht : t.Nonempty\nhb : LE.le (↑s.card) (HSMul.hSMul t.card b)\n⊢ Exists fun y => And (Membership.mem t y) (LE.le (↑(Finset.filter (fun x => Eq (f x) y) s).card) b)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: given a function `f`, a\nfinite sets `s` and `t`, and a number `b` such that `#s ≤ #t • b`, there exists `y ∈ t` such\nthat its preimage in `s` has no more than `b` elements.\nSee also `Finset.exists_card_fiber_lt_of_card_lt_nsmul` for a stronger statement. -/\ntheorem exists_card_fiber_le_of_card_le_nsmul (ht : t.Nonempty) (hb : #s ≤ #t • b) :\n    ∃ y ∈ t, #{x ∈ s | f x = y} ≤ b := by\n  simp_rw [cast_card] at hb ⊢\n  refine\n    exists_sum_fiber_le_of_sum_fiber_nonneg_of_sum_le_nsmul\n      (fun _ _ => sum_nonneg fun _ _ => zero_le_one) ht hb\n\n"}
{"name":"Finset.exists_card_fiber_le_of_card_le_mul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝ : DecidableEq β\ns : Finset α\nt : Finset β\nf : α → β\nn : Nat\nht : t.Nonempty\nhn : LE.le s.card (HMul.hMul t.card n)\n⊢ Exists fun y => And (Membership.mem t y) (LE.le (Finset.filter (fun x => Eq (f x) y) s).card n)","decl":"/-- The pigeonhole principle for finitely many pigeons counted by heads: given a function `f`, a\nfinite sets `s` in its domain, a finite set `t` in its codomain, and a natural number `n` such that\n`#s ≤ #t * n`, there exists `y ∈ t` such that its preimage in `s` has no more than `n`\nelements. See also `Finset.exists_card_fiber_lt_of_card_lt_mul` for a stronger statement. -/\ntheorem exists_card_fiber_le_of_card_le_mul (ht : t.Nonempty) (hn : #s ≤ #t * n) :\n    ∃ y ∈ t, #{x ∈ s | f x = y} ≤ n :=\n  exists_card_fiber_le_of_card_le_nsmul ht hn\n\n"}
{"name":"Fintype.exists_lt_sum_fiber_of_nsmul_lt_sum","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝³ : DecidableEq β\ninst✝² : Fintype α\ninst✝¹ : Fintype β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhb : LT.lt (HSMul.hSMul (Fintype.card β) b) (Finset.univ.sum fun x => w x)\n⊢ Exists fun y => LT.lt b ((Finset.filter (fun x => Eq (f x) y) Finset.univ).sum fun x => w x)","decl":"/-- The pigeonhole principle for finitely many pigeons of different weights, strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it greater than `b` provided that\nthe total number of pigeonholes times `b` is less than the total weight of all pigeons. -/\ntheorem exists_lt_sum_fiber_of_nsmul_lt_sum (hb : card β • b < ∑ x, w x) :\n    ∃ y, b < ∑ x with f x = y, w x :=\n  let ⟨y, _, hy⟩ := exists_lt_sum_fiber_of_maps_to_of_nsmul_lt_sum (fun _ _ => mem_univ _) hb\n  ⟨y, hy⟩\n\n"}
{"name":"Fintype.exists_le_sum_fiber_of_nsmul_le_sum","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝⁴ : DecidableEq β\ninst✝³ : Fintype α\ninst✝² : Fintype β\nf : α → β\nw : α → M\nb : M\ninst✝¹ : LinearOrderedCancelAddCommMonoid M\ninst✝ : Nonempty β\nhb : LE.le (HSMul.hSMul (Fintype.card β) b) (Finset.univ.sum fun x => w x)\n⊢ Exists fun y => LE.le b ((Finset.filter (fun x => Eq (f x) y) Finset.univ).sum fun x => w x)","decl":"/-- The pigeonhole principle for finitely many pigeons of different weights, non-strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it greater than or equal to `b`\nprovided that the total number of pigeonholes times `b` is less than or equal to the total weight of\nall pigeons. -/\ntheorem exists_le_sum_fiber_of_nsmul_le_sum [Nonempty β] (hb : card β • b ≤ ∑ x, w x) :\n    ∃ y, b ≤ ∑ x with f x = y, w x :=\n  let ⟨y, _, hy⟩ :=\n    exists_le_sum_fiber_of_maps_to_of_nsmul_le_sum (fun _ _ => mem_univ _) univ_nonempty hb\n  ⟨y, hy⟩\n\n"}
{"name":"Fintype.exists_sum_fiber_lt_of_sum_lt_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝³ : DecidableEq β\ninst✝² : Fintype α\ninst✝¹ : Fintype β\nf : α → β\nw : α → M\nb : M\ninst✝ : LinearOrderedCancelAddCommMonoid M\nhb : LT.lt (Finset.univ.sum fun x => w x) (HSMul.hSMul (Fintype.card β) b)\n⊢ Exists fun y => LT.lt ((Finset.filter (fun x => Eq (f x) y) Finset.univ).sum fun x => w x) b","decl":"/-- The pigeonhole principle for finitely many pigeons of different weights, strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it less than `b` provided that\nthe total number of pigeonholes times `b` is greater than the total weight of all pigeons. -/\ntheorem exists_sum_fiber_lt_of_sum_lt_nsmul (hb : ∑ x, w x < card β • b) :\n    ∃ y, ∑ x with f x = y, w x < b :=\n  exists_lt_sum_fiber_of_nsmul_lt_sum (M := Mᵒᵈ) _ hb\n\n"}
{"name":"Fintype.exists_sum_fiber_le_of_sum_le_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝⁴ : DecidableEq β\ninst✝³ : Fintype α\ninst✝² : Fintype β\nf : α → β\nw : α → M\nb : M\ninst✝¹ : LinearOrderedCancelAddCommMonoid M\ninst✝ : Nonempty β\nhb : LE.le (Finset.univ.sum fun x => w x) (HSMul.hSMul (Fintype.card β) b)\n⊢ Exists fun y => LE.le ((Finset.filter (fun x => Eq (f x) y) Finset.univ).sum fun x => w x) b","decl":"/-- The pigeonhole principle for finitely many pigeons of different weights, non-strict inequality\nversion: there is a pigeonhole with the total weight of pigeons in it less than or equal to `b`\nprovided that the total number of pigeonholes times `b` is greater than or equal to the total weight\nof all pigeons. -/\ntheorem exists_sum_fiber_le_of_sum_le_nsmul [Nonempty β] (hb : ∑ x, w x ≤ card β • b) :\n    ∃ y, ∑ x with f x = y, w x ≤ b :=\n  exists_le_sum_fiber_of_nsmul_le_sum (M := Mᵒᵈ) _ hb\n\n"}
{"name":"Fintype.exists_lt_card_fiber_of_nsmul_lt_card","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝³ : DecidableEq β\ninst✝² : Fintype α\ninst✝¹ : Fintype β\nf : α → β\nb : M\ninst✝ : LinearOrderedCommSemiring M\nhb : LT.lt (HSMul.hSMul (Fintype.card β) b) ↑(Fintype.card α)\n⊢ Exists fun y => LT.lt b ↑(Finset.filter (fun x => Eq (f x) y) Finset.univ).card","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes. There is a pigeonhole\nwith at least as many pigeons as the ceiling of the average number of pigeons across all\npigeonholes. -/\ntheorem exists_lt_card_fiber_of_nsmul_lt_card (hb : card β • b < card α) :\n    ∃ y : β, b < #{x | f x = y} :=\n  let ⟨y, _, h⟩ := exists_lt_card_fiber_of_nsmul_lt_card_of_maps_to (fun _ _ => mem_univ _) hb\n  ⟨y, h⟩\n\n"}
{"name":"Fintype.exists_lt_card_fiber_of_mul_lt_card","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝² : DecidableEq β\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nn : Nat\nhn : LT.lt (HMul.hMul (Fintype.card β) n) (Fintype.card α)\n⊢ Exists fun y => LT.lt n (Finset.filter (fun x => Eq (f x) y) Finset.univ).card","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at least as many pigeons as\nthe ceiling of the average number of pigeons across all pigeonholes.\n(\"The maximum is at least the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `α` and `β` and a number `n` such that\n`card β * n < card α`, there exists an element `y : β` such that its preimage has more than `n`\nelements. -/\ntheorem exists_lt_card_fiber_of_mul_lt_card (hn : card β * n < card α) :\n    ∃ y : β, n < #{x | f x = y} :=\n  exists_lt_card_fiber_of_nsmul_lt_card _ hn\n\n"}
{"name":"Fintype.exists_card_fiber_lt_of_card_lt_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝³ : DecidableEq β\ninst✝² : Fintype α\ninst✝¹ : Fintype β\nf : α → β\nb : M\ninst✝ : LinearOrderedCommSemiring M\nhb : LT.lt (↑(Fintype.card α)) (HSMul.hSMul (Fintype.card β) b)\n⊢ Exists fun y => LT.lt (↑(Finset.filter (fun x => Eq (f x) y) Finset.univ).card) b","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes. There is a pigeonhole\nwith at most as many pigeons as the floor of the average number of pigeons across all pigeonholes.\n-/\ntheorem exists_card_fiber_lt_of_card_lt_nsmul (hb : ↑(card α) < card β • b) :\n    ∃ y : β, #{x | f x = y} < b :=\n  let ⟨y, _, h⟩ := Finset.exists_card_fiber_lt_of_card_lt_nsmul (f := f) hb\n  ⟨y, h⟩\n\n"}
{"name":"Fintype.exists_card_fiber_lt_of_card_lt_mul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝² : DecidableEq β\ninst✝¹ : Fintype α\ninst✝ : Fintype β\nf : α → β\nn : Nat\nhn : LT.lt (Fintype.card α) (HMul.hMul (Fintype.card β) n)\n⊢ Exists fun y => LT.lt (Finset.filter (fun x => Eq (f x) y) Finset.univ).card n","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes.\nThere is a pigeonhole with at most as many pigeons as\nthe floor of the average number of pigeons across all pigeonholes.\n(\"The minimum is at most the mean\" specialized to integers.)\n\nMore formally, given a function `f` between finite types `α` and `β` and a number `n` such that\n`card α < card β * n`, there exists an element `y : β` such that its preimage has less than `n`\nelements. -/\ntheorem exists_card_fiber_lt_of_card_lt_mul (hn : card α < card β * n) :\n    ∃ y : β, #{x | f x = y} < n :=\n  exists_card_fiber_lt_of_card_lt_nsmul _ hn\n\n"}
{"name":"Fintype.exists_le_card_fiber_of_nsmul_le_card","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝⁴ : DecidableEq β\ninst✝³ : Fintype α\ninst✝² : Fintype β\nf : α → β\nb : M\ninst✝¹ : LinearOrderedCommSemiring M\ninst✝ : Nonempty β\nhb : LE.le (HSMul.hSMul (Fintype.card β) b) ↑(Fintype.card α)\n⊢ Exists fun y => LE.le b ↑(Finset.filter (fun x => Eq (f x) y) Finset.univ).card","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `α` and `β` and a number `b` such that `card β • b ≤ card α`, there exists an\nelement `y : β` such that its preimage has at least `b` elements.\nSee also `Fintype.exists_lt_card_fiber_of_nsmul_lt_card` for a stronger statement. -/\ntheorem exists_le_card_fiber_of_nsmul_le_card [Nonempty β] (hb : card β • b ≤ card α) :\n    ∃ y : β, b ≤ #{x | f x = y} :=\n  let ⟨y, _, h⟩ :=\n    exists_le_card_fiber_of_nsmul_le_card_of_maps_to (fun _ _ => mem_univ _) univ_nonempty hb\n  ⟨y, h⟩\n\n"}
{"name":"Fintype.exists_le_card_fiber_of_mul_le_card","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : DecidableEq β\ninst✝² : Fintype α\ninst✝¹ : Fintype β\nf : α → β\nn : Nat\ninst✝ : Nonempty β\nhn : LE.le (HMul.hMul (Fintype.card β) n) (Fintype.card α)\n⊢ Exists fun y => LE.le n (Finset.filter (fun x => Eq (f x) y) Finset.univ).card","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `α` and `β` and a number `n` such that `card β * n ≤ card α`, there exists an\nelement `y : β` such that its preimage has at least `n` elements. See also\n`Fintype.exists_lt_card_fiber_of_mul_lt_card` for a stronger statement. -/\ntheorem exists_le_card_fiber_of_mul_le_card [Nonempty β] (hn : card β * n ≤ card α) :\n    ∃ y : β, n ≤ #{x | f x = y} :=\n  exists_le_card_fiber_of_nsmul_le_card _ hn\n\n"}
{"name":"Fintype.exists_card_fiber_le_of_card_le_nsmul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\nM : Type w\ninst✝⁴ : DecidableEq β\ninst✝³ : Fintype α\ninst✝² : Fintype β\nf : α → β\nb : M\ninst✝¹ : LinearOrderedCommSemiring M\ninst✝ : Nonempty β\nhb : LE.le (↑(Fintype.card α)) (HSMul.hSMul (Fintype.card β) b)\n⊢ Exists fun y => LE.le (↑(Finset.filter (fun x => Eq (f x) y) Finset.univ).card) b","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `α` and `β` and a number `b` such that `card α ≤ card β • b`, there exists an\nelement `y : β` such that its preimage has at most `b` elements.\nSee also `Fintype.exists_card_fiber_lt_of_card_lt_nsmul` for a stronger statement. -/\ntheorem exists_card_fiber_le_of_card_le_nsmul [Nonempty β] (hb : ↑(card α) ≤ card β • b) :\n    ∃ y : β, #{x | f x = y} ≤ b :=\n  let ⟨y, _, h⟩ := Finset.exists_card_fiber_le_of_card_le_nsmul univ_nonempty hb\n  ⟨y, h⟩\n\n"}
{"name":"Fintype.exists_card_fiber_le_of_card_le_mul","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"α : Type u\nβ : Type v\ninst✝³ : DecidableEq β\ninst✝² : Fintype α\ninst✝¹ : Fintype β\nf : α → β\nn : Nat\ninst✝ : Nonempty β\nhn : LE.le (Fintype.card α) (HMul.hMul (Fintype.card β) n)\n⊢ Exists fun y => LE.le (Finset.filter (fun x => Eq (f x) y) Finset.univ).card n","decl":"/-- The strong pigeonhole principle for finitely many pigeons and pigeonholes.  Given a function `f`\nbetween finite types `α` and `β` and a number `n` such that `card α ≤ card β * n`, there exists an\nelement `y : β` such that its preimage has at most `n` elements. See also\n`Fintype.exists_card_fiber_lt_of_card_lt_mul` for a stronger statement. -/\ntheorem exists_card_fiber_le_of_card_le_mul [Nonempty β] (hn : card α ≤ card β * n) :\n    ∃ y : β, #{x | f x = y} ≤ n :=\n  exists_card_fiber_le_of_card_le_nsmul _ hn\n\n"}
{"name":"Nat.exists_lt_modEq_of_infinite","module":"Mathlib.Combinatorics.Pigeonhole","initialProofState":"s : Set Nat\nhs : s.Infinite\nk : Nat\nhk : LT.lt 0 k\n⊢ Exists fun m => And (Membership.mem s m) (Exists fun n => And (Membership.mem s n) (And (LT.lt m n) (k.ModEq m n)))","decl":"/-- If `s` is an infinite set of natural numbers and `k > 0`, then `s` contains two elements `m < n`\nthat are equal mod `k`. -/\ntheorem exists_lt_modEq_of_infinite {s : Set ℕ} (hs : s.Infinite) {k : ℕ} (hk : 0 < k) :\n    ∃ m ∈ s, ∃ n ∈ s, m < n ∧ m ≡ n [MOD k] :=\n  (hs.exists_lt_map_eq_of_mapsTo fun n _ => show n % k ∈ Iio k from Nat.mod_lt n hk) <|\n    finite_lt_nat k\n\n"}
