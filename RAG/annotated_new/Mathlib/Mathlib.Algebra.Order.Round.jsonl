{"name":"round_zero","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (round 0) 0","decl":"@[simp]\ntheorem round_zero : round (0 : α) = 0 := by simp [round]\n\n"}
{"name":"round_one","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\n⊢ Eq (round 1) 1","decl":"@[simp]\ntheorem round_one : round (1 : α) = 1 := by simp [round]\n\n"}
{"name":"round_natCast","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Nat\n⊢ Eq (round ↑n) ↑n","decl":"@[simp]\ntheorem round_natCast (n : ℕ) : round (n : α) = n := by simp [round]\n\n"}
{"name":"round_ofNat","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (round (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp]\ntheorem round_ofNat (n : ℕ) [n.AtLeastTwo] : round (ofNat(n) : α) = ofNat(n) :=\n  round_natCast n\n\n"}
{"name":"round_intCast","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nn : Int\n⊢ Eq (round ↑n) n","decl":"@[simp]\ntheorem round_intCast (n : ℤ) : round (n : α) = n := by simp [round]\n\n"}
{"name":"round_add_int","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\ny : Int\n⊢ Eq (round (HAdd.hAdd x ↑y)) (HAdd.hAdd (round x) y)","decl":"@[simp]\ntheorem round_add_int (x : α) (y : ℤ) : round (x + y) = round x + y := by\n  rw [round, round, Int.fract_add_int, Int.floor_add_int, Int.ceil_add_int, ← apply_ite₂, ite_self]\n\n"}
{"name":"round_add_one","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (round (HAdd.hAdd a 1)) (HAdd.hAdd (round a) 1)","decl":"@[simp]\ntheorem round_add_one (a : α) : round (a + 1) = round a + 1 := by\n  -- Porting note: broken `convert round_add_int a 1`\n  rw [← round_add_int a 1, cast_one]\n\n"}
{"name":"round_sub_int","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\ny : Int\n⊢ Eq (round (HSub.hSub x ↑y)) (HSub.hSub (round x) y)","decl":"@[simp]\ntheorem round_sub_int (x : α) (y : ℤ) : round (x - y) = round x - y := by\n  rw [sub_eq_add_neg]\n  norm_cast\n  rw [round_add_int, sub_eq_add_neg]\n\n"}
{"name":"round_sub_one","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\na : α\n⊢ Eq (round (HSub.hSub a 1)) (HSub.hSub (round a) 1)","decl":"@[simp]\ntheorem round_sub_one (a : α) : round (a - 1) = round a - 1 := by\n  -- Porting note: broken `convert round_sub_int a 1`\n  rw [← round_sub_int a 1, cast_one]\n\n"}
{"name":"round_add_nat","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\ny : Nat\n⊢ Eq (round (HAdd.hAdd x ↑y)) (HAdd.hAdd (round x) ↑y)","decl":"@[simp]\ntheorem round_add_nat (x : α) (y : ℕ) : round (x + y) = round x + y :=\n  mod_cast round_add_int x y\n\n"}
{"name":"round_add_ofNat","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nx : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (round (HAdd.hAdd x (OfNat.ofNat n))) (HAdd.hAdd (round x) (OfNat.ofNat n))","decl":"@[simp]\ntheorem round_add_ofNat (x : α) (n : ℕ) [n.AtLeastTwo] :\n    round (x + ofNat(n)) = round x + ofNat(n) :=\n  round_add_nat x n\n\n"}
{"name":"round_sub_nat","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\ny : Nat\n⊢ Eq (round (HSub.hSub x ↑y)) (HSub.hSub (round x) ↑y)","decl":"@[simp]\ntheorem round_sub_nat (x : α) (y : ℕ) : round (x - y) = round x - y :=\n  mod_cast round_sub_int x y\n\n"}
{"name":"round_sub_ofNat","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nx : α\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (round (HSub.hSub x (OfNat.ofNat n))) (HSub.hSub (round x) (OfNat.ofNat n))","decl":"@[simp]\ntheorem round_sub_ofNat (x : α) (n : ℕ) [n.AtLeastTwo] :\n    round (x - ofNat(n)) = round x - ofNat(n) :=\n  round_sub_nat x n\n\n"}
{"name":"round_int_add","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\ny : Int\n⊢ Eq (round (HAdd.hAdd (↑y) x)) (HAdd.hAdd y (round x))","decl":"@[simp]\ntheorem round_int_add (x : α) (y : ℤ) : round ((y : α) + x) = y + round x := by\n  rw [add_comm, round_add_int, add_comm]\n\n"}
{"name":"round_nat_add","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\ny : Nat\n⊢ Eq (round (HAdd.hAdd (↑y) x)) (HAdd.hAdd (↑y) (round x))","decl":"@[simp]\ntheorem round_nat_add (x : α) (y : ℕ) : round ((y : α) + x) = y + round x := by\n  rw [add_comm, round_add_nat, add_comm]\n\n"}
{"name":"round_ofNat_add","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝² : LinearOrderedRing α\ninst✝¹ : FloorRing α\nn : Nat\ninst✝ : n.AtLeastTwo\nx : α\n⊢ Eq (round (HAdd.hAdd (OfNat.ofNat n) x)) (HAdd.hAdd (OfNat.ofNat n) (round x))","decl":"@[simp]\ntheorem round_ofNat_add (n : ℕ) [n.AtLeastTwo] (x : α) :\n    round (ofNat(n) + x) = ofNat(n) + round x :=\n  round_nat_add x n\n\n"}
{"name":"abs_sub_round_eq_min","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\n⊢ Eq (abs (HSub.hSub x ↑(round x))) (Min.min (Int.fract x) (HSub.hSub 1 (Int.fract x)))","decl":"theorem abs_sub_round_eq_min (x : α) : |x - round x| = min (fract x) (1 - fract x) := by\n  simp_rw [round, min_def_lt, two_mul, ← lt_tsub_iff_left]\n  cases' lt_or_ge (fract x) (1 - fract x) with hx hx\n  · rw [if_pos hx, if_pos hx, self_sub_floor, abs_fract]\n  · have : 0 < fract x := by\n      replace hx : 0 < fract x + fract x := lt_of_lt_of_le zero_lt_one (tsub_le_iff_left.mp hx)\n      simpa only [← two_mul, mul_pos_iff_of_pos_left, zero_lt_two] using hx\n    rw [if_neg (not_lt.mpr hx), if_neg (not_lt.mpr hx), abs_sub_comm, ceil_sub_self_eq this.ne.symm,\n      abs_one_sub_fract]\n\n"}
{"name":"round_le","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedRing α\ninst✝ : FloorRing α\nx : α\nz : Int\n⊢ LE.le (abs (HSub.hSub x ↑(round x))) (abs (HSub.hSub x ↑z))","decl":"theorem round_le (x : α) (z : ℤ) : |x - round x| ≤ |x - z| := by\n  rw [abs_sub_round_eq_min, min_le_iff]\n  rcases le_or_lt (z : α) x with (hx | hx) <;> [left; right]\n  · conv_rhs => rw [abs_eq_self.mpr (sub_nonneg.mpr hx), ← fract_add_floor x, add_sub_assoc]\n    simpa only [le_add_iff_nonneg_right, sub_nonneg, cast_le] using le_floor.mpr hx\n  · rw [abs_eq_neg_self.mpr (sub_neg.mpr hx).le]\n    conv_rhs => rw [← fract_add_floor x]\n    rw [add_sub_assoc, add_comm, neg_add, neg_sub, le_add_neg_iff_add_le, sub_add_cancel,\n      le_sub_comm]\n    norm_cast\n    exact floor_le_sub_one_iff.mpr hx\n\n"}
{"name":"round_eq","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : α\n⊢ Eq (round x) (Int.floor (HAdd.hAdd x (1 / 2)))","decl":"theorem round_eq (x : α) : round x = ⌊x + 1 / 2⌋ := by\n  simp_rw [round, (by simp only [lt_div_iff₀', two_pos] : 2 * fract x < 1 ↔ fract x < 1 / 2)]\n  cases' lt_or_le (fract x) (1 / 2) with hx hx\n  · conv_rhs => rw [← fract_add_floor x, add_assoc, add_left_comm, floor_int_add]\n    rw [if_pos hx, self_eq_add_right, floor_eq_iff, cast_zero, zero_add]\n    constructor\n    · linarith [fract_nonneg x]\n    · linarith\n  · have : ⌊fract x + 1 / 2⌋ = 1 := by\n      rw [floor_eq_iff]\n      constructor\n      · norm_num\n        linarith\n      · norm_num\n        linarith [fract_lt_one x]\n    rw [if_neg (not_lt.mpr hx), ← fract_add_floor x, add_assoc, add_left_comm, floor_int_add,\n      ceil_add_int, add_comm _ ⌊x⌋, add_right_inj, ceil_eq_iff, this, cast_one, sub_self]\n    constructor\n    · linarith\n    · linarith [fract_lt_one x]\n\n"}
{"name":"round_two_inv","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\n⊢ Eq (round (Inv.inv 2)) 1","decl":"@[simp]\ntheorem round_two_inv : round (2⁻¹ : α) = 1 := by\n  simp only [round_eq, ← one_div, add_halves, floor_one]\n\n"}
{"name":"round_neg_two_inv","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\n⊢ Eq (round (Neg.neg (Inv.inv 2))) 0","decl":"@[simp]\ntheorem round_neg_two_inv : round (-2⁻¹ : α) = 0 := by\n  simp only [round_eq, ← one_div, neg_add_cancel, floor_zero]\n\n"}
{"name":"round_eq_zero_iff","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : α\n⊢ Iff (Eq (round x) 0) (Membership.mem (Set.Ico (Neg.neg (1 / 2)) (1 / 2)) x)","decl":"@[simp]\ntheorem round_eq_zero_iff {x : α} : round x = 0 ↔ x ∈ Ico (-(1 / 2)) ((1 : α) / 2) := by\n  rw [round_eq, floor_eq_zero_iff, add_mem_Ico_iff_left]\n  norm_num\n\n"}
{"name":"abs_sub_round","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : α\n⊢ LE.le (abs (HSub.hSub x ↑(round x))) (1 / 2)","decl":"theorem abs_sub_round (x : α) : |x - round x| ≤ 1 / 2 := by\n  rw [round_eq, abs_sub_le_iff]\n  have := floor_le (x + 1 / 2)\n  have := lt_floor_add_one (x + 1 / 2)\n  constructor <;> linarith\n\n"}
{"name":"abs_sub_round_div_natCast_eq","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nm n : Nat\n⊢ Eq (abs (HSub.hSub (HDiv.hDiv ↑m ↑n) ↑(round (HDiv.hDiv ↑m ↑n)))) (HDiv.hDiv ↑(Min.min (HMod.hMod m n) (HSub.hSub n (HMod.hMod m n))) ↑n)","decl":"theorem abs_sub_round_div_natCast_eq {m n : ℕ} :\n    |(m : α) / n - round ((m : α) / n)| = ↑(min (m % n) (n - m % n)) / n := by\n  rcases n.eq_zero_or_pos with (rfl | hn)\n  · simp\n  have hn' : 0 < (n : α) := by\n    norm_cast\n  rw [abs_sub_round_eq_min, Nat.cast_min, ← min_div_div_right hn'.le,\n    fract_div_natCast_eq_div_natCast_mod, Nat.cast_sub (m.mod_lt hn).le, sub_div, div_self hn'.ne']\n\n"}
{"name":"sub_half_lt_round","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : α\n⊢ LT.lt (HSub.hSub x (1 / 2)) ↑(round x)","decl":"@[bound]\ntheorem sub_half_lt_round (x : α) : x - 1 / 2 < round x := by\n  rw [round_eq x, show x - 1 / 2 = x + 1 / 2 - 1 by linarith]\n  exact Int.sub_one_lt_floor (x + 1 / 2)\n\n"}
{"name":"round_le_add_half","module":"Mathlib.Algebra.Order.Round","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrderedField α\ninst✝ : FloorRing α\nx : α\n⊢ LE.le (↑(round x)) (HAdd.hAdd x (1 / 2))","decl":"@[bound]\ntheorem round_le_add_half (x : α) : round x ≤ x + 1 / 2 := by\n  rw [round_eq x]\n  exact Int.floor_le (x + 1 / 2)\n\n"}
{"name":"Int.map_round","module":"Mathlib.Algebra.Order.Round","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝⁵ : LinearOrderedField α\ninst✝⁴ : LinearOrderedField β\ninst✝³ : FloorRing α\ninst✝² : FloorRing β\ninst✝¹ : FunLike F α β\ninst✝ : RingHomClass F α β\nf : F\nhf : StrictMono ⇑f\na : α\n⊢ Eq (round (f a)) (round a)","decl":"theorem map_round (f : F) (hf : StrictMono f) (a : α) : round (f a) = round a := by\n  have H : f 2 = 2 := map_natCast f 2\n  simp_rw [round_eq, ← map_floor _ hf, map_add, one_div, map_inv₀, H]\n  -- Porting note: was\n  -- simp_rw [round_eq, ← map_floor _ hf, map_add, one_div, map_inv₀, map_bit0, map_one]\n  -- Would have thought that `map_natCast` would replace `map_bit0, map_one` but seems not\n\n"}
