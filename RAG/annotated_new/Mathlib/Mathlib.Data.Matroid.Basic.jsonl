{"name":"Matroid.maximality","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nself : Matroid α\nX : Set α\na✝ : HasSubset.Subset X self.E\n⊢ Matroid.ExistsMaximalSubsetProperty self.Indep X","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.base_exchange","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nself : Matroid α\n⊢ Matroid.ExchangeProperty self.Base","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nself : Matroid α\nB : Set α\na✝ : self.Base B\n⊢ HasSubset.Subset B self.E","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.indep_iff'","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nself : Matroid α\nI : Set α\n⊢ Iff (self.Indep I) (Exists fun B => And (self.Base B) (HasSubset.Subset I B))","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.mk.injEq","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nE✝ : Set α\nBase✝ Indep✝ : Set α → Prop\nindep_iff'✝ : ∀ ⦃I : Set α⦄, Iff (Indep✝ I) (Exists fun B => And (Base✝ B) (HasSubset.Subset I B))\nexists_base✝ : Exists fun B => Base✝ B\nbase_exchange✝ : Matroid.ExchangeProperty Base✝\nmaximality✝ : ∀ (X : Set α), HasSubset.Subset X E✝ → Matroid.ExistsMaximalSubsetProperty Indep✝ X\nsubset_ground✝ : ∀ (B : Set α), Base✝ B → HasSubset.Subset B E✝\nE : Set α\nBase Indep : Set α → Prop\nindep_iff' : ∀ ⦃I : Set α⦄, Iff (Indep I) (Exists fun B => And (Base B) (HasSubset.Subset I B))\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nmaximality : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty Indep X\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (Eq { E := E✝, Base := Base✝, Indep := Indep✝, indep_iff' := indep_iff'✝, exists_base := exists_base✝, base_exchange := base_exchange✝, maximality := maximality✝, subset_ground := subset_ground✝ } { E := E, Base := Base, Indep := Indep, indep_iff' := indep_iff', exists_base := exists_base, base_exchange := base_exchange, maximality := maximality, subset_ground := subset_ground }) (And (Eq E✝ E) (And (Eq Base✝ Base) (Eq Indep✝ Indep)))","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.mk.inj","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nE✝ : Set α\nBase✝ Indep✝ : Set α → Prop\nindep_iff'✝ : ∀ ⦃I : Set α⦄, Iff (Indep✝ I) (Exists fun B => And (Base✝ B) (HasSubset.Subset I B))\nexists_base✝ : Exists fun B => Base✝ B\nbase_exchange✝ : Matroid.ExchangeProperty Base✝\nmaximality✝ : ∀ (X : Set α), HasSubset.Subset X E✝ → Matroid.ExistsMaximalSubsetProperty Indep✝ X\nsubset_ground✝ : ∀ (B : Set α), Base✝ B → HasSubset.Subset B E✝\nE : Set α\nBase Indep : Set α → Prop\nindep_iff' : ∀ ⦃I : Set α⦄, Iff (Indep I) (Exists fun B => And (Base B) (HasSubset.Subset I B))\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nmaximality : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty Indep X\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\nx✝ : Eq { E := E✝, Base := Base✝, Indep := Indep✝, indep_iff' := indep_iff'✝, exists_base := exists_base✝, base_exchange := base_exchange✝, maximality := maximality✝, subset_ground := subset_ground✝ } { E := E, Base := Base, Indep := Indep, indep_iff' := indep_iff', exists_base := exists_base, base_exchange := base_exchange, maximality := maximality, subset_ground := subset_ground }\n⊢ And (Eq E✝ E) (And (Eq Base✝ Base) (Eq Indep✝ Indep))","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.mk.sizeOf_spec","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\ninst✝ : SizeOf α\nE : Set α\nBase Indep : Set α → Prop\nindep_iff' : ∀ ⦃I : Set α⦄, Iff (Indep I) (Exists fun B => And (Base B) (HasSubset.Subset I B))\nexists_base : Exists fun B => Base B\nbase_exchange : Matroid.ExchangeProperty Base\nmaximality : ∀ (X : Set α), HasSubset.Subset X E → Matroid.ExistsMaximalSubsetProperty Indep X\nsubset_ground : ∀ (B : Set α), Base B → HasSubset.Subset B E\n⊢ Eq (SizeOf.sizeOf { E := E, Base := Base, Indep := Indep, indep_iff' := indep_iff', exists_base := exists_base, base_exchange := base_exchange, maximality := maximality, subset_ground := subset_ground }) (HAdd.hAdd 1 (SizeOf.sizeOf exists_base))","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.exists_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nself : Matroid α\n⊢ Exists fun B => self.Base B","decl":"/-- A `Matroid α` is a ground set `E` of type `Set α`, and a nonempty collection of its subsets\n  satisfying the exchange property and the maximal subset property. Each such set is called a\n  `Base` of `M`. An `Indep`endent set is just a set contained in a base, but we include this\n  predicate as a structure field for better definitional properties.\n\n  In most cases, using this definition directly is not the best way to construct a matroid,\n  since it requires specifying both the bases and independent sets. If the bases are known,\n  use `Matroid.ofBase` or a variant. If just the independent sets are known,\n  define an `IndepMatroid`, and then use `IndepMatroid.matroid`.\n  -/\nstructure Matroid (α : Type _) where\n  /-- `M` has a ground set `E`. -/\n  (E : Set α)\n  /-- `M` has a predicate `Base` defining its bases. -/\n  (Base : Set α → Prop)\n  /-- `M` has a predicate `Indep` defining its independent sets. -/\n  (Indep : Set α → Prop)\n  /-- The `Indep`endent sets are those contained in `Base`s. -/\n  (indep_iff' : ∀ ⦃I⦄, Indep I ↔ ∃ B, Base B ∧ I ⊆ B)\n  /-- There is at least one `Base`. -/\n  (exists_base : ∃ B, Base B)\n  /-- For any bases `B`, `B'` and `e ∈ B \\ B'`, there is some `f ∈ B' \\ B` for which `B-e+f`\n    is a base. -/\n  (base_exchange : Matroid.ExchangeProperty Base)\n  /-- Every independent subset `I` of a set `X` for is contained in a maximal independent\n    subset of `X`. -/\n  (maximality : ∀ X, X ⊆ E → Matroid.ExistsMaximalSubsetProperty Indep X)\n  /-- Every base is contained in the ground set. -/\n  (subset_ground : ∀ B, Base B → B ⊆ E)\n\n"}
{"name":"Matroid.ext","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nx y : Matroid α\nE : Eq x.E y.E\nBase : Eq x.Base y.Base\nIndep : Eq x.Indep y.Indep\n⊢ Eq x y","decl":"attribute [local ext] Matroid\n\n"}
{"name":"Matroid.ext_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nx y : Matroid α\n⊢ Iff (Eq x y) (And (Eq x.E y.E) (And (Eq x.Base y.Base) (Eq x.Indep y.Indep)))","decl":"attribute [local ext] Matroid\n\n"}
{"name":"Matroid.instNonemptySubtypeSetBase","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Nonempty (Subtype fun B => M.Base B)","decl":"instance (M : Matroid α) : Nonempty {B // M.Base B} :=\n  nonempty_subtype.2 M.exists_base\n\n"}
{"name":"Matroid.finite_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.Finite M.E.Finite","decl":"/-- Typeclass for a matroid having finite ground set. Just a wrapper for `M.E.Finite`-/\n@[mk_iff] protected class Finite (M : Matroid α) : Prop where\n  /-- The ground set is finite -/\n  (ground_finite : M.E.Finite)\n\n"}
{"name":"Matroid.Finite.ground_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nself : M.Finite\n⊢ M.E.Finite","decl":"/-- Typeclass for a matroid having finite ground set. Just a wrapper for `M.E.Finite`-/\n@[mk_iff] protected class Finite (M : Matroid α) : Prop where\n  /-- The ground set is finite -/\n  (ground_finite : M.E.Finite)\n\n"}
{"name":"Matroid.Nonempty.ground_nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nself : M.Nonempty\n⊢ M.E.Nonempty","decl":"/-- Typeclass for a matroid having nonempty ground set. Just a wrapper for `M.E.Nonempty`-/\nprotected class Nonempty (M : Matroid α) : Prop where\n  /-- The ground set is nonempty -/\n  (ground_nonempty : M.E.Nonempty)\n\n"}
{"name":"Matroid.ground_nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Nonempty\n⊢ M.E.Nonempty","decl":"theorem ground_nonempty (M : Matroid α) [M.Nonempty] : M.E.Nonempty :=\n  Nonempty.ground_nonempty\n\n"}
{"name":"Matroid.ground_nonempty_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.E.Nonempty M.Nonempty","decl":"theorem ground_nonempty_iff (M : Matroid α) : M.E.Nonempty ↔ M.Nonempty :=\n  ⟨fun h ↦ ⟨h⟩, fun ⟨h⟩ ↦ h⟩\n\n"}
{"name":"Matroid.nonempty_type","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nh : M.Nonempty\n⊢ Nonempty α","decl":"lemma nonempty_type (M : Matroid α) [h : M.Nonempty] : Nonempty α :=\n  ⟨M.ground_nonempty.some⟩\n\n"}
{"name":"Matroid.ground_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finite\n⊢ M.E.Finite","decl":"theorem ground_finite (M : Matroid α) [M.Finite] : M.E.Finite :=\n  Finite.ground_finite\n\n"}
{"name":"Matroid.set_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finite\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ X.Finite","decl":"theorem set_finite (M : Matroid α) [M.Finite] (X : Set α) (hX : X ⊆ M.E := by aesop) : X.Finite :=\n  M.ground_finite.subset hX\n\n"}
{"name":"Matroid.finite_of_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\ninst✝ : Finite α\nM : Matroid α\n⊢ M.Finite","decl":"instance finite_of_finite [Finite α] {M : Matroid α} : M.Finite :=\n  ⟨Set.toFinite _⟩\n\n"}
{"name":"Matroid.FiniteRk.exists_finite_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nself : M.FiniteRk\n⊢ Exists fun B => And (M.Base B) B.Finite","decl":"/-- A `FiniteRk` matroid is one whose bases are finite -/\n@[mk_iff] class FiniteRk (M : Matroid α) : Prop where\n  /-- There is a finite base -/\n  exists_finite_base : ∃ B, M.Base B ∧ B.Finite\n\n"}
{"name":"Matroid.finiteRk_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.FiniteRk (Exists fun B => And (M.Base B) B.Finite)","decl":"/-- A `FiniteRk` matroid is one whose bases are finite -/\n@[mk_iff] class FiniteRk (M : Matroid α) : Prop where\n  /-- There is a finite base -/\n  exists_finite_base : ∃ B, M.Base B ∧ B.Finite\n\n"}
{"name":"Matroid.finiteRk_of_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finite\n⊢ M.FiniteRk","decl":"instance finiteRk_of_finite (M : Matroid α) [M.Finite] : FiniteRk M :=\n  ⟨M.exists_base.imp (fun B hB ↦ ⟨hB, M.set_finite B (M.subset_ground _ hB)⟩)⟩\n\n"}
{"name":"Matroid.InfiniteRk.exists_infinite_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nself : M.InfiniteRk\n⊢ Exists fun B => And (M.Base B) B.Infinite","decl":"/-- An `InfiniteRk` matroid is one whose bases are infinite. -/\n@[mk_iff] class InfiniteRk (M : Matroid α) : Prop where\n  /-- There is an infinite base -/\n  exists_infinite_base : ∃ B, M.Base B ∧ B.Infinite\n\n"}
{"name":"Matroid.infiniteRk_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.InfiniteRk (Exists fun B => And (M.Base B) B.Infinite)","decl":"/-- An `InfiniteRk` matroid is one whose bases are infinite. -/\n@[mk_iff] class InfiniteRk (M : Matroid α) : Prop where\n  /-- There is an infinite base -/\n  exists_infinite_base : ∃ B, M.Base B ∧ B.Infinite\n\n"}
{"name":"Matroid.RkPos.empty_not_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nself : M.RkPos\n⊢ Not (M.Base EmptyCollection.emptyCollection)","decl":"/-- A `RkPos` matroid is one whose bases are nonempty. -/\n@[mk_iff] class RkPos (M : Matroid α) : Prop where\n  /-- The empty set isn't a base -/\n  empty_not_base : ¬M.Base ∅\n\n"}
{"name":"Matroid.rkPos_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.RkPos (Not (M.Base EmptyCollection.emptyCollection))","decl":"/-- A `RkPos` matroid is one whose bases are nonempty. -/\n@[mk_iff] class RkPos (M : Matroid α) : Prop where\n  /-- The empty set isn't a base -/\n  empty_not_base : ¬M.Base ∅\n\n"}
{"name":"Matroid.rkPos_nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.RkPos\n⊢ M.Nonempty","decl":"instance rkPos_nonempty {M : Matroid α} [M.RkPos] : M.Nonempty := by\n  obtain ⟨B, hB⟩ := M.exists_base\n  obtain rfl | ⟨e, heB⟩ := B.eq_empty_or_nonempty\n  · exact False.elim <| RkPos.empty_not_base hB\n  exact ⟨e, M.subset_ground B hB heB ⟩\n\n"}
{"name":"Matroid.rkPos_iff_empty_not_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.RkPos (Not (M.Base EmptyCollection.emptyCollection))","decl":"@[deprecated (since := \"2025-01-20\")] alias rkPos_iff_empty_not_base := rkPos_iff\n\n"}
{"name":"Matroid.ExchangeProperty.antichain","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nBase : Set α → Prop\nB B' : Set α\nexch : Matroid.ExchangeProperty Base\nhB : Base B\nhB' : Base B'\nh : HasSubset.Subset B B'\n⊢ Eq B B'","decl":"/-- A family of sets with the exchange property is an antichain. -/\ntheorem antichain (exch : ExchangeProperty Base) (hB : Base B) (hB' : Base B') (h : B ⊆ B') :\n    B = B' :=\n  h.antisymm (fun x hx ↦ by_contra\n    (fun hxB ↦ let ⟨_, hy, _⟩ := exch B' B hB' hB x ⟨hx, hxB⟩; hy.2 <| h hy.1))\n\n"}
{"name":"Matroid.ExchangeProperty.encard_diff_le_aux","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nBase : Set α → Prop\nB₁ B₂ : Set α\nexch : Matroid.ExchangeProperty Base\nhB₁ : Base B₁\nhB₂ : Base B₂\n⊢ LE.le (SDiff.sdiff B₁ B₂).encard (SDiff.sdiff B₂ B₁).encard","decl":"theorem encard_diff_le_aux {B₁ B₂ : Set α}\n    (exch : ExchangeProperty Base) (hB₁ : Base B₁) (hB₂ : Base B₂) :\n    (B₁ \\ B₂).encard ≤ (B₂ \\ B₁).encard := by\n  obtain (he | hinf | ⟨e, he, hcard⟩) :=\n    (B₂ \\ B₁).eq_empty_or_encard_eq_top_or_encard_diff_singleton_lt\n  · rw [exch.antichain hB₂ hB₁ (diff_eq_empty.mp he)]\n  · exact le_top.trans_eq hinf.symm\n\n  obtain ⟨f, hf, hB'⟩ := exch B₂ B₁ hB₂ hB₁ e he\n\n  have : encard (insert f (B₂ \\ {e}) \\ B₁) < encard (B₂ \\ B₁) := by\n    rw [insert_diff_of_mem _ hf.1, diff_diff_comm]; exact hcard\n\n  have hencard := encard_diff_le_aux exch hB₁ hB'\n  rw [insert_diff_of_mem _ hf.1, diff_diff_comm, ← union_singleton, ← diff_diff, diff_diff_right,\n    inter_singleton_eq_empty.mpr he.2, union_empty] at hencard\n\n  rw [← encard_diff_singleton_add_one he, ← encard_diff_singleton_add_one hf]\n  exact add_le_add_right hencard 1\ntermination_by (B₂ \\ B₁).encard\n\n"}
{"name":"Matroid.ExchangeProperty.encard_diff_eq","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nBase : Set α → Prop\nB₁ B₂ : Set α\nexch : Matroid.ExchangeProperty Base\nhB₁ : Base B₁\nhB₂ : Base B₂\n⊢ Eq (SDiff.sdiff B₁ B₂).encard (SDiff.sdiff B₂ B₁).encard","decl":"/-- For any two sets `B₁`, `B₂` in a family with the exchange property, the differences `B₁ \\ B₂`\nand `B₂ \\ B₁` have the same `ℕ∞`-cardinality. -/\ntheorem encard_diff_eq (exch : ExchangeProperty Base) (hB₁ : Base B₁) (hB₂ : Base B₂) :\n    (B₁ \\ B₂).encard = (B₂ \\ B₁).encard :=\n  (encard_diff_le_aux exch hB₁ hB₂).antisymm (encard_diff_le_aux exch hB₂ hB₁)\n\n"}
{"name":"Matroid.ExchangeProperty.encard_base_eq","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nBase : Set α → Prop\nB₁ B₂ : Set α\nexch : Matroid.ExchangeProperty Base\nhB₁ : Base B₁\nhB₂ : Base B₂\n⊢ Eq B₁.encard B₂.encard","decl":"/-- Any two sets `B₁`, `B₂` in a family with the exchange property have the same\n`ℕ∞`-cardinality. -/\ntheorem encard_base_eq (exch : ExchangeProperty Base) (hB₁ : Base B₁) (hB₂ : Base B₂) :\n    B₁.encard = B₂.encard := by\n  rw [← encard_diff_add_encard_inter B₁ B₂, exch.encard_diff_eq hB₁ hB₂, inter_comm,\n    encard_diff_add_encard_inter]\n\n"}
{"name":"Matroid.Base.subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Base B\n⊢ HasSubset.Subset B M.E","decl":"@[aesop unsafe 10% (rule_sets := [Matroid])]\ntheorem Base.subset_ground (hB : M.Base B) : B ⊆ M.E :=\n  M.subset_ground B hB\n\n"}
{"name":"Matroid.Base.exchange","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\ne : α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\nhx : Membership.mem (SDiff.sdiff B₁ B₂) e\n⊢ Exists fun y => And (Membership.mem (SDiff.sdiff B₂ B₁) y) (M.Base (Insert.insert y (SDiff.sdiff B₁ (Singleton.singleton e))))","decl":"theorem Base.exchange {e : α} (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) (hx : e ∈ B₁ \\ B₂) :\n    ∃ y ∈ B₂ \\ B₁, M.Base (insert y (B₁ \\ {e}))  :=\n  M.base_exchange B₁ B₂ hB₁ hB₂ _ hx\n\n"}
{"name":"Matroid.Base.exchange_mem","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\ne : α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\nhxB₁ : Membership.mem B₁ e\nhxB₂ : Not (Membership.mem B₂ e)\n⊢ Exists fun y => And (And (Membership.mem B₂ y) (Not (Membership.mem B₁ y))) (M.Base (Insert.insert y (SDiff.sdiff B₁ (Singleton.singleton e))))","decl":"theorem Base.exchange_mem {e : α}\n    (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) (hxB₁ : e ∈ B₁) (hxB₂ : e ∉ B₂) :\n    ∃ y, (y ∈ B₂ ∧ y ∉ B₁) ∧ M.Base (insert y (B₁ \\ {e})) := by\n  simpa using hB₁.exchange hB₂ ⟨hxB₁, hxB₂⟩\n\n"}
{"name":"Matroid.Base.eq_of_subset_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\nhB₁B₂ : HasSubset.Subset B₁ B₂\n⊢ Eq B₁ B₂","decl":"theorem Base.eq_of_subset_base (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) (hB₁B₂ : B₁ ⊆ B₂) :\n    B₁ = B₂ :=\n  M.base_exchange.antichain hB₁ hB₂ hB₁B₂\n\n"}
{"name":"Matroid.Base.not_base_of_ssubset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB X : Set α\nhB : M.Base B\nhX : HasSSubset.SSubset X B\n⊢ Not (M.Base X)","decl":"theorem Base.not_base_of_ssubset {X : Set α} (hB : M.Base B) (hX : X ⊂ B) : ¬ M.Base X :=\n  fun h ↦ hX.ne (h.eq_of_subset_base hB hX.subset)\n\n"}
{"name":"Matroid.Base.insert_not_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ne : α\nhB : M.Base B\nheB : Not (Membership.mem B e)\n⊢ Not (M.Base (Insert.insert e B))","decl":"theorem Base.insert_not_base {e : α} (hB : M.Base B) (heB : e ∉ B) : ¬ M.Base (insert e B) :=\n  fun h ↦ h.not_base_of_ssubset (ssubset_insert heB) hB\n\n"}
{"name":"Matroid.Base.encard_diff_comm","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\n⊢ Eq (SDiff.sdiff B₁ B₂).encard (SDiff.sdiff B₂ B₁).encard","decl":"theorem Base.encard_diff_comm (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) :\n    (B₁ \\ B₂).encard = (B₂ \\ B₁).encard :=\n  M.base_exchange.encard_diff_eq hB₁ hB₂\n\n"}
{"name":"Matroid.Base.ncard_diff_comm","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\n⊢ Eq (SDiff.sdiff B₁ B₂).ncard (SDiff.sdiff B₂ B₁).ncard","decl":"theorem Base.ncard_diff_comm (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) :\n    (B₁ \\ B₂).ncard = (B₂ \\ B₁).ncard := by\n  rw [ncard_def, hB₁.encard_diff_comm hB₂, ← ncard_def]\n\n"}
{"name":"Matroid.Base.card_eq_card_of_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\n⊢ Eq B₁.encard B₂.encard","decl":"theorem Base.card_eq_card_of_base (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) :\n    B₁.encard = B₂.encard := by\n  rw [M.base_exchange.encard_base_eq hB₁ hB₂]\n\n"}
{"name":"Matroid.Base.ncard_eq_ncard_of_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\n⊢ Eq B₁.ncard B₂.ncard","decl":"theorem Base.ncard_eq_ncard_of_base (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) : B₁.ncard = B₂.ncard := by\n  rw [ncard_def B₁, hB₁.card_eq_card_of_base hB₂, ← ncard_def]\n\n"}
{"name":"Matroid.Base.finite_of_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB B' : Set α\nhB : M.Base B\nh : B.Finite\nhB' : M.Base B'\n⊢ B'.Finite","decl":"theorem Base.finite_of_finite {B' : Set α}\n    (hB : M.Base B) (h : B.Finite) (hB' : M.Base B') : B'.Finite :=\n  (finite_iff_finite_of_encard_eq_encard (hB.card_eq_card_of_base hB')).mp h\n\n"}
{"name":"Matroid.Base.infinite_of_infinite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB B₁ : Set α\nhB : M.Base B\nh : B.Infinite\nhB₁ : M.Base B₁\n⊢ B₁.Infinite","decl":"theorem Base.infinite_of_infinite (hB : M.Base B) (h : B.Infinite) (hB₁ : M.Base B₁) :\n    B₁.Infinite :=\n  by_contra (fun hB_inf ↦ (hB₁.finite_of_finite (not_infinite.mp hB_inf) hB).not_infinite h)\n\n"}
{"name":"Matroid.Base.finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ninst✝ : M.FiniteRk\nhB : M.Base B\n⊢ B.Finite","decl":"theorem Base.finite [FiniteRk M] (hB : M.Base B) : B.Finite :=\n  let ⟨_,hB₀⟩ := ‹FiniteRk M›.exists_finite_base\n  hB₀.1.finite_of_finite hB₀.2 hB\n\n"}
{"name":"Matroid.Base.infinite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ninst✝ : M.InfiniteRk\nhB : M.Base B\n⊢ B.Infinite","decl":"theorem Base.infinite [InfiniteRk M] (hB : M.Base B) : B.Infinite :=\n  let ⟨_,hB₀⟩ := ‹InfiniteRk M›.exists_infinite_base\n  hB₀.1.infinite_of_infinite hB₀.2 hB\n\n"}
{"name":"Matroid.empty_not_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nh : M.RkPos\n⊢ Not (M.Base EmptyCollection.emptyCollection)","decl":"theorem empty_not_base [h : RkPos M] : ¬M.Base ∅ :=\n  h.empty_not_base\n\n"}
{"name":"Matroid.Base.nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ninst✝ : M.RkPos\nhB : M.Base B\n⊢ B.Nonempty","decl":"theorem Base.nonempty [RkPos M] (hB : M.Base B) : B.Nonempty := by\n  rw [nonempty_iff_ne_empty]; rintro rfl; exact M.empty_not_base hB\n\n"}
{"name":"Matroid.Base.rkPos_of_nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Base B\nh : B.Nonempty\n⊢ M.RkPos","decl":"theorem Base.rkPos_of_nonempty (hB : M.Base B) (h : B.Nonempty) : M.RkPos := by\n  rw [rkPos_iff]\n  intro he\n  obtain rfl := he.eq_of_subset_base hB (empty_subset B)\n  simp at h\n\n"}
{"name":"Matroid.Base.finiteRk_of_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Base B\nhfin : B.Finite\n⊢ M.FiniteRk","decl":"theorem Base.finiteRk_of_finite (hB : M.Base B) (hfin : B.Finite) : FiniteRk M :=\n  ⟨⟨B, hB, hfin⟩⟩\n\n"}
{"name":"Matroid.Base.infiniteRk_of_infinite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Base B\nh : B.Infinite\n⊢ M.InfiniteRk","decl":"theorem Base.infiniteRk_of_infinite (hB : M.Base B) (h : B.Infinite) : InfiniteRk M :=\n  ⟨⟨B, hB, h⟩⟩\n\n"}
{"name":"Matroid.not_finiteRk","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.InfiniteRk\n⊢ Not M.FiniteRk","decl":"theorem not_finiteRk (M : Matroid α) [InfiniteRk M] : ¬ FiniteRk M := by\n  intro h; obtain ⟨B,hB⟩ := M.exists_base; exact hB.infinite hB.finite\n\n"}
{"name":"Matroid.not_infiniteRk","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.FiniteRk\n⊢ Not M.InfiniteRk","decl":"theorem not_infiniteRk (M : Matroid α) [FiniteRk M] : ¬ InfiniteRk M := by\n  intro h; obtain ⟨B,hB⟩ := M.exists_base; exact hB.infinite hB.finite\n\n"}
{"name":"Matroid.finite_or_infiniteRk","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Or M.FiniteRk M.InfiniteRk","decl":"theorem finite_or_infiniteRk (M : Matroid α) : FiniteRk M ∨ InfiniteRk M :=\n  let ⟨B, hB⟩ := M.exists_base\n  B.finite_or_infinite.elim\n  (Or.inl ∘ hB.finiteRk_of_finite) (Or.inr ∘ hB.infiniteRk_of_infinite)\n\n"}
{"name":"Matroid.Base.diff_finite_comm","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\n⊢ Iff (SDiff.sdiff B₁ B₂).Finite (SDiff.sdiff B₂ B₁).Finite","decl":"theorem Base.diff_finite_comm (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) :\n    (B₁ \\ B₂).Finite ↔ (B₂ \\ B₁).Finite :=\n  finite_iff_finite_of_encard_eq_encard (hB₁.encard_diff_comm hB₂)\n\n"}
{"name":"Matroid.Base.diff_infinite_comm","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB₁ B₂ : Set α\nhB₁ : M.Base B₁\nhB₂ : M.Base B₂\n⊢ Iff (SDiff.sdiff B₁ B₂).Infinite (SDiff.sdiff B₂ B₁).Infinite","decl":"theorem Base.diff_infinite_comm (hB₁ : M.Base B₁) (hB₂ : M.Base B₂) :\n    (B₁ \\ B₂).Infinite ↔ (B₂ \\ B₁).Infinite :=\n  infinite_iff_infinite_of_encard_eq_encard (hB₁.encard_diff_comm hB₂)\n\n"}
{"name":"Matroid.ext_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nh : ∀ ⦃B : Set α⦄, HasSubset.Subset B M₁.E → Iff (M₁.Base B) (M₂.Base B)\n⊢ Eq M₁ M₂","decl":"theorem ext_base {M₁ M₂ : Matroid α} (hE : M₁.E = M₂.E)\n    (h : ∀ ⦃B⦄, B ⊆ M₁.E → (M₁.Base B ↔ M₂.Base B)) : M₁ = M₂ := by\n  have h' : ∀ B, M₁.Base B ↔ M₂.Base B :=\n    fun B ↦ ⟨fun hB ↦ (h hB.subset_ground).1 hB,\n      fun hB ↦ (h <| hB.subset_ground.trans_eq hE.symm).2 hB⟩\n  ext <;> simp [hE, M₁.indep_iff', M₂.indep_iff', h']\n\n"}
{"name":"Matroid.eq_of_base_iff_base_forall","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nh : ∀ ⦃B : Set α⦄, HasSubset.Subset B M₁.E → Iff (M₁.Base B) (M₂.Base B)\n⊢ Eq M₁ M₂","decl":"@[deprecated (since := \"2024-12-25\")] alias eq_of_base_iff_base_forall := ext_base\n\n"}
{"name":"Matroid.ext_iff_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂) (And (Eq M₁.E M₂.E) (∀ ⦃B : Set α⦄, HasSubset.Subset B M₁.E → Iff (M₁.Base B) (M₂.Base B)))","decl":"theorem ext_iff_base {M₁ M₂ : Matroid α} :\n    M₁ = M₂ ↔ M₁.E = M₂.E ∧ ∀ ⦃B⦄, B ⊆ M₁.E → (M₁.Base B ↔ M₂.Base B) :=\n  ⟨fun h ↦ by simp [h], fun ⟨hE, h⟩ ↦ ext_base hE h⟩\n\n"}
{"name":"Matroid.base_compl_iff_maximal_disjoint_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : autoParam (HasSubset.Subset B M.E) _auto✝\n⊢ Iff (M.Base (SDiff.sdiff M.E B)) (Maximal (fun I => And (HasSubset.Subset I M.E) (Exists fun B => And (M.Base B) (Disjoint I B))) B)","decl":"theorem base_compl_iff_maximal_disjoint_base (hB : B ⊆ M.E := by aesop_mat) :\n    M.Base (M.E \\ B) ↔ Maximal (fun I ↦ I ⊆ M.E ∧ ∃ B, M.Base B ∧ Disjoint I B) B := by\n  simp_rw [maximal_iff, and_iff_right hB, and_imp, forall_exists_index]\n  refine ⟨fun h ↦ ⟨⟨_, h, disjoint_sdiff_right⟩,\n    fun I hI B' ⟨hB', hIB'⟩ hBI ↦ hBI.antisymm ?_⟩, fun ⟨⟨B', hB', hBB'⟩,h⟩ ↦ ?_⟩\n  · rw [hB'.eq_of_subset_base h, ← subset_compl_iff_disjoint_right, diff_eq, compl_inter,\n      compl_compl] at hIB'\n    · exact fun e he ↦ (hIB' he).elim (fun h' ↦ (h' (hI he)).elim) id\n    rw [subset_diff, and_iff_right hB'.subset_ground, disjoint_comm]\n    exact disjoint_of_subset_left hBI hIB'\n  rw [h diff_subset B' ⟨hB', disjoint_sdiff_left⟩]\n  · simpa [hB'.subset_ground]\n  simp [subset_diff, hB, hBB']\n\n"}
{"name":"Matroid.indep_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (M.Indep I) (Exists fun B => And (M.Base B) (HasSubset.Subset I B))","decl":"theorem indep_iff : M.Indep I ↔ ∃ B, M.Base B ∧ I ⊆ B :=\n  M.indep_iff' (I := I)\n\n"}
{"name":"Matroid.setOf_indep_eq","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (setOf fun I => M.Indep I) ↑(lowerClosure (setOf fun B => M.Base B))","decl":"theorem setOf_indep_eq (M : Matroid α) : {I | M.Indep I} = lowerClosure ({B | M.Base B}) := by\n  simp_rw [indep_iff]\n  rfl\n\n"}
{"name":"Matroid.Indep.exists_base_superset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ Exists fun B => And (M.Base B) (HasSubset.Subset I B)","decl":"theorem Indep.exists_base_superset (hI : M.Indep I) : ∃ B, M.Base B ∧ I ⊆ B :=\n  indep_iff.1 hI\n\n"}
{"name":"Matroid.dep_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nD : Set α\n⊢ Iff (M.Dep D) (And (Not (M.Indep D)) (HasSubset.Subset D M.E))","decl":"theorem dep_iff : M.Dep D ↔ ¬M.Indep D ∧ D ⊆ M.E := Iff.rfl\n\n"}
{"name":"Matroid.setOf_dep_eq","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Eq (setOf fun D => M.Dep D) (Inter.inter (HasCompl.compl (setOf fun I => M.Indep I)) (Set.Iic M.E))","decl":"theorem setOf_dep_eq (M : Matroid α) : {D | M.Dep D} = {I | M.Indep I}ᶜ ∩ Iic M.E := rfl\n\n"}
{"name":"Matroid.Indep.subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ HasSubset.Subset I M.E","decl":"@[aesop unsafe 30% (rule_sets := [Matroid])]\ntheorem Indep.subset_ground (hI : M.Indep I) : I ⊆ M.E := by\n  obtain ⟨B, hB, hIB⟩ := hI.exists_base_superset\n  exact hIB.trans hB.subset_ground\n\n"}
{"name":"Matroid.Dep.subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nD : Set α\nhD : M.Dep D\n⊢ HasSubset.Subset D M.E","decl":"@[aesop unsafe 20% (rule_sets := [Matroid])]\ntheorem Dep.subset_ground (hD : M.Dep D) : D ⊆ M.E :=\n  hD.2\n\n"}
{"name":"Matroid.indep_or_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Or (M.Indep X) (M.Dep X)","decl":"theorem indep_or_dep (hX : X ⊆ M.E := by aesop_mat) : M.Indep X ∨ M.Dep X := by\n  rw [Dep, and_iff_left hX]\n  apply em\n\n"}
{"name":"Matroid.Indep.not_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ Not (M.Dep I)","decl":"theorem Indep.not_dep (hI : M.Indep I) : ¬ M.Dep I :=\n  fun h ↦ h.1 hI\n\n"}
{"name":"Matroid.Dep.not_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nD : Set α\nhD : M.Dep D\n⊢ Not (M.Indep D)","decl":"theorem Dep.not_indep (hD : M.Dep D) : ¬ M.Indep D :=\n  hD.1\n\n"}
{"name":"Matroid.dep_of_not_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nD : Set α\nhD : Not (M.Indep D)\nhDE : autoParam (HasSubset.Subset D M.E) _auto✝\n⊢ M.Dep D","decl":"theorem dep_of_not_indep (hD : ¬ M.Indep D) (hDE : D ⊆ M.E := by aesop_mat) : M.Dep D :=\n  ⟨hD, hDE⟩\n\n"}
{"name":"Matroid.indep_of_not_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : Not (M.Dep I)\nhIE : autoParam (HasSubset.Subset I M.E) _auto✝\n⊢ M.Indep I","decl":"theorem indep_of_not_dep (hI : ¬ M.Dep I) (hIE : I ⊆ M.E := by aesop_mat) : M.Indep I :=\n  by_contra (fun h ↦ hI ⟨h, hIE⟩)\n\n"}
{"name":"Matroid.not_dep_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (Not (M.Dep X)) (M.Indep X)","decl":"@[simp] theorem not_dep_iff (hX : X ⊆ M.E := by aesop_mat) : ¬ M.Dep X ↔ M.Indep X := by\n  rw [Dep, and_iff_left hX, not_not]\n\n"}
{"name":"Matroid.not_indep_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (Not (M.Indep X)) (M.Dep X)","decl":"@[simp] theorem not_indep_iff (hX : X ⊆ M.E := by aesop_mat) : ¬ M.Indep X ↔ M.Dep X := by\n  rw [Dep, and_iff_left hX]\n\n"}
{"name":"Matroid.indep_iff_not_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (M.Indep I) (And (Not (M.Dep I)) (HasSubset.Subset I M.E))","decl":"theorem indep_iff_not_dep : M.Indep I ↔ ¬M.Dep I ∧ I ⊆ M.E := by\n  rw [dep_iff, not_and, not_imp_not]\n  exact ⟨fun h ↦ ⟨fun _ ↦ h, h.subset_ground⟩, fun h ↦ h.1 h.2⟩\n\n"}
{"name":"Matroid.Indep.subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J : Set α\nhJ : M.Indep J\nhIJ : HasSubset.Subset I J\n⊢ M.Indep I","decl":"theorem Indep.subset (hJ : M.Indep J) (hIJ : I ⊆ J) : M.Indep I := by\n  obtain ⟨B, hB, hJB⟩ := hJ.exists_base_superset\n  exact indep_iff.2 ⟨B, hB, hIJ.trans hJB⟩\n\n"}
{"name":"Matroid.Dep.superset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nD X : Set α\nhD : M.Dep D\nhDX : HasSubset.Subset D X\nhXE : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Dep X","decl":"theorem Dep.superset (hD : M.Dep D) (hDX : D ⊆ X) (hXE : X ⊆ M.E := by aesop_mat) : M.Dep X :=\n  dep_of_not_indep (fun hI ↦ (hI.subset hDX).not_dep hD)\n\n"}
{"name":"Matroid.Base.indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Base B\n⊢ M.Indep B","decl":"theorem Base.indep (hB : M.Base B) : M.Indep B :=\n  indep_iff.2 ⟨B, hB, subset_rfl⟩\n\n"}
{"name":"Matroid.empty_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ M.Indep EmptyCollection.emptyCollection","decl":"@[simp] theorem empty_indep (M : Matroid α) : M.Indep ∅ :=\n  Exists.elim M.exists_base (fun _ hB ↦ hB.indep.subset (empty_subset _))\n\n"}
{"name":"Matroid.Dep.nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nD : Set α\nhD : M.Dep D\n⊢ D.Nonempty","decl":"theorem Dep.nonempty (hD : M.Dep D) : D.Nonempty := by\n  rw [nonempty_iff_ne_empty]; rintro rfl; exact hD.not_indep M.empty_indep\n\n"}
{"name":"Matroid.Indep.finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ninst✝ : M.FiniteRk\nhI : M.Indep I\n⊢ I.Finite","decl":"theorem Indep.finite [FiniteRk M] (hI : M.Indep I) : I.Finite :=\n  let ⟨_, hB, hIB⟩ := hI.exists_base_superset\n  hB.finite.subset hIB\n\n"}
{"name":"Matroid.Indep.rkPos_of_nonempty","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\nhne : I.Nonempty\n⊢ M.RkPos","decl":"theorem Indep.rkPos_of_nonempty (hI : M.Indep I) (hne : I.Nonempty) : M.RkPos := by\n  obtain ⟨B, hB, hIB⟩ := hI.exists_base_superset\n  exact hB.rkPos_of_nonempty (hne.mono hIB)\n\n"}
{"name":"Matroid.Indep.inter_right","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\nX : Set α\n⊢ M.Indep (Inter.inter I X)","decl":"theorem Indep.inter_right (hI : M.Indep I) (X : Set α) : M.Indep (I ∩ X) :=\n  hI.subset inter_subset_left\n\n"}
{"name":"Matroid.Indep.inter_left","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\nX : Set α\n⊢ M.Indep (Inter.inter X I)","decl":"theorem Indep.inter_left (hI : M.Indep I) (X : Set α) : M.Indep (X ∩ I) :=\n  hI.subset inter_subset_right\n\n"}
{"name":"Matroid.Indep.diff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\nX : Set α\n⊢ M.Indep (SDiff.sdiff I X)","decl":"theorem Indep.diff (hI : M.Indep I) (X : Set α) : M.Indep (I \\ X) :=\n  hI.subset diff_subset\n\n"}
{"name":"Matroid.Base.eq_of_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB I : Set α\nhB : M.Base B\nhI : M.Indep I\nhBI : HasSubset.Subset B I\n⊢ Eq B I","decl":"theorem Base.eq_of_subset_indep (hB : M.Base B) (hI : M.Indep I) (hBI : B ⊆ I) : B = I :=\n  let ⟨B', hB', hB'I⟩ := hI.exists_base_superset\n  hBI.antisymm (by rwa [hB.eq_of_subset_base hB' (hBI.trans hB'I)])\n\n"}
{"name":"Matroid.base_iff_maximal_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\n⊢ Iff (M.Base B) (Maximal M.Indep B)","decl":"theorem base_iff_maximal_indep : M.Base B ↔ Maximal M.Indep B := by\n  rw [maximal_subset_iff]\n  refine ⟨fun h ↦ ⟨h.indep, fun _ ↦ h.eq_of_subset_indep⟩, fun ⟨h, h'⟩ ↦ ?_⟩\n  obtain ⟨B', hB', hBB'⟩ := h.exists_base_superset\n  rwa [h' hB'.indep hBB']\n\n"}
{"name":"Matroid.Indep.base_of_maximal","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\nh : ∀ ⦃J : Set α⦄, M.Indep J → HasSubset.Subset I J → Eq I J\n⊢ M.Base I","decl":"theorem Indep.base_of_maximal (hI : M.Indep I) (h : ∀ ⦃J⦄, M.Indep J → I ⊆ J → I = J) :\n    M.Base I := by\n  rwa [base_iff_maximal_indep, maximal_subset_iff, and_iff_right hI]\n\n"}
{"name":"Matroid.Base.dep_of_ssubset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB X : Set α\nhB : M.Base B\nh : HasSSubset.SSubset B X\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Dep X","decl":"theorem Base.dep_of_ssubset (hB : M.Base B) (h : B ⊂ X) (hX : X ⊆ M.E := by aesop_mat) : M.Dep X :=\n  ⟨fun hX ↦ h.ne (hB.eq_of_subset_indep hX h.subset), hX⟩\n\n"}
{"name":"Matroid.Base.dep_of_insert","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ne : α\nhB : M.Base B\nheB : Not (Membership.mem B e)\nhe : autoParam (Membership.mem M.E e) _auto✝\n⊢ M.Dep (Insert.insert e B)","decl":"theorem Base.dep_of_insert (hB : M.Base B) (heB : e ∉ B) (he : e ∈ M.E := by aesop_mat) :\n    M.Dep (insert e B) := hB.dep_of_ssubset (ssubset_insert heB) (insert_subset he hB.subset_ground)\n\n"}
{"name":"Matroid.Base.mem_of_insert_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ne : α\nhB : M.Base B\nheB : M.Indep (Insert.insert e B)\n⊢ Membership.mem B e","decl":"theorem Base.mem_of_insert_indep (hB : M.Base B) (heB : M.Indep (insert e B)) : e ∈ B :=\n  by_contra fun he ↦ (hB.dep_of_insert he (heB.subset_ground (mem_insert _ _))).not_indep heB\n\n"}
{"name":"Matroid.Base.eq_exchange_of_diff_eq_singleton","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB B' : Set α\ne : α\nhB : M.Base B\nhB' : M.Base B'\nh : Eq (SDiff.sdiff B B') (Singleton.singleton e)\n⊢ Exists fun f => And (Membership.mem (SDiff.sdiff B' B) f) (Eq B' (SDiff.sdiff (Insert.insert f B) (Singleton.singleton e)))","decl":"/-- If the difference of two Bases is a singleton, then they differ by an insertion/removal -/\ntheorem Base.eq_exchange_of_diff_eq_singleton (hB : M.Base B) (hB' : M.Base B') (h : B \\ B' = {e}) :\n    ∃ f ∈ B' \\ B, B' = (insert f B) \\ {e} := by\n  obtain ⟨f, hf, hb⟩ := hB.exchange hB' (h.symm.subset (mem_singleton e))\n  have hne : f ≠ e := by rintro rfl; exact hf.2 (h.symm.subset (mem_singleton f)).1\n  rw [insert_diff_singleton_comm hne] at hb\n  refine ⟨f, hf, (hb.eq_of_subset_base hB' ?_).symm⟩\n  rw [diff_subset_iff, insert_subset_iff, union_comm, ← diff_subset_iff, h, and_iff_left rfl.subset]\n  exact Or.inl hf.1\n\n"}
{"name":"Matroid.Base.exchange_base_of_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ne f : α\nhB : M.Base B\nhf : Not (Membership.mem B f)\nhI : M.Indep (Insert.insert f (SDiff.sdiff B (Singleton.singleton e)))\n⊢ M.Base (Insert.insert f (SDiff.sdiff B (Singleton.singleton e)))","decl":"theorem Base.exchange_base_of_indep (hB : M.Base B) (hf : f ∉ B)\n    (hI : M.Indep (insert f (B \\ {e}))) : M.Base (insert f (B \\ {e})) := by\n  obtain ⟨B', hB', hIB'⟩ := hI.exists_base_superset\n  have hcard := hB'.encard_diff_comm hB\n  rw [insert_subset_iff, ← diff_eq_empty, diff_diff_comm, diff_eq_empty, subset_singleton_iff_eq]\n    at hIB'\n  obtain ⟨hfB, (h | h)⟩ := hIB'\n  · rw [h, encard_empty, encard_eq_zero, eq_empty_iff_forall_not_mem] at hcard\n    exact (hcard f ⟨hfB, hf⟩).elim\n  rw [h, encard_singleton, encard_eq_one] at hcard\n  obtain ⟨x, hx⟩ := hcard\n  obtain (rfl : f = x) := hx.subset ⟨hfB, hf⟩\n  simp_rw [← h, ← singleton_union, ← hx, sdiff_sdiff_right_self, inf_eq_inter, inter_comm B,\n    diff_union_inter]\n  exact hB'\n\n"}
{"name":"Matroid.Base.exchange_base_of_indep'","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ne f : α\nhB : M.Base B\nhe : Membership.mem B e\nhf : Not (Membership.mem B f)\nhI : M.Indep (SDiff.sdiff (Insert.insert f B) (Singleton.singleton e))\n⊢ M.Base (SDiff.sdiff (Insert.insert f B) (Singleton.singleton e))","decl":"theorem Base.exchange_base_of_indep' (hB : M.Base B) (he : e ∈ B) (hf : f ∉ B)\n    (hI : M.Indep (insert f B \\ {e})) : M.Base (insert f B \\ {e}) := by\n  have hfe : f ≠ e := by rintro rfl; exact hf he\n  rw [← insert_diff_singleton_comm hfe] at *\n  exact hB.exchange_base_of_indep hf hI\n\n"}
{"name":"Matroid.insert_base_of_insert_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne f : α\nhe : Not (Membership.mem I e)\nhf : Not (Membership.mem I f)\nheI : M.Base (Insert.insert e I)\nhfI : M.Indep (Insert.insert f I)\n⊢ M.Base (Insert.insert f I)","decl":"lemma insert_base_of_insert_indep {M : Matroid α} {I : Set α} {e f : α}\n    (he : e ∉ I) (hf : f ∉ I) (heI : M.Base (insert e I)) (hfI : M.Indep (insert f I)) :\n    M.Base (insert f I) := by\n  obtain rfl | hef := eq_or_ne e f\n  · assumption\n  simpa [diff_singleton_eq_self he, hfI]\n    using heI.exchange_base_of_indep (e := e) (f := f) (by simp [hef.symm, hf])\n\n"}
{"name":"Matroid.Base.insert_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\ne : α\nhB : M.Base B\nh : Membership.mem (SDiff.sdiff M.E B) e\n⊢ M.Dep (Insert.insert e B)","decl":"theorem Base.insert_dep (hB : M.Base B) (h : e ∈ M.E \\ B) : M.Dep (insert e B) := by\n  rw [← not_indep_iff (insert_subset h.1 hB.subset_ground)]\n  exact h.2 ∘ (fun hi ↦ insert_eq_self.mp (hB.eq_of_subset_indep hi (subset_insert e B)).symm)\n\n"}
{"name":"Matroid.Indep.exists_insert_of_not_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB I : Set α\nhI : M.Indep I\nhI' : Not (M.Base I)\nhB : M.Base B\n⊢ Exists fun e => And (Membership.mem (SDiff.sdiff B I) e) (M.Indep (Insert.insert e I))","decl":"theorem Indep.exists_insert_of_not_base (hI : M.Indep I) (hI' : ¬M.Base I) (hB : M.Base B) :\n    ∃ e ∈ B \\ I, M.Indep (insert e I) := by\n  obtain ⟨B', hB', hIB'⟩ := hI.exists_base_superset\n  obtain ⟨x, hxB', hx⟩ := exists_of_ssubset (hIB'.ssubset_of_ne (by (rintro rfl; exact hI' hB')))\n  by_cases hxB : x ∈ B\n  · exact ⟨x, ⟨hxB, hx⟩, hB'.indep.subset (insert_subset hxB' hIB')⟩\n  obtain ⟨e,he, hBase⟩ := hB'.exchange hB ⟨hxB',hxB⟩\n  exact ⟨e, ⟨he.1, not_mem_subset hIB' he.2⟩,\n    indep_iff.2 ⟨_, hBase, insert_subset_insert (subset_diff_singleton hIB' hx)⟩⟩\n\n"}
{"name":"Matroid.Indep.exists_insert_of_not_maximal","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI B : Set α\nhI : M.Indep I\nhInotmax : Not (Maximal M.Indep I)\nhB : Maximal M.Indep B\n⊢ Exists fun x => And (Membership.mem (SDiff.sdiff B I) x) (M.Indep (Insert.insert x I))","decl":"/-- This is the same as `Indep.exists_insert_of_not_base`, but phrased so that\n  it is defeq to the augmentation axiom for independent sets. -/\ntheorem Indep.exists_insert_of_not_maximal (M : Matroid α) ⦃I B : Set α⦄ (hI : M.Indep I)\n    (hInotmax : ¬ Maximal M.Indep I) (hB : Maximal M.Indep B) :\n    ∃ x ∈ B \\ I, M.Indep (insert x I) := by\n  simp only [maximal_subset_iff, hI, not_and, not_forall, exists_prop, true_imp_iff] at hB hInotmax\n  refine hI.exists_insert_of_not_base (fun hIb ↦ ?_) ?_\n  · obtain ⟨I', hII', hI', hne⟩ := hInotmax\n    exact hne <| hIb.eq_of_subset_indep hII' hI'\n  exact hB.1.base_of_maximal fun J hJ hBJ ↦ hB.2 hJ hBJ\n\n"}
{"name":"Matroid.Indep.base_of_forall_insert","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Indep B\nhBmax : ∀ (e : α), Membership.mem (SDiff.sdiff M.E B) e → Not (M.Indep (Insert.insert e B))\n⊢ M.Base B","decl":"theorem Indep.base_of_forall_insert (hB : M.Indep B)\n    (hBmax : ∀ e ∈ M.E \\ B, ¬ M.Indep (insert e B)) : M.Base B := by\n  refine by_contra fun hnb ↦ ?_\n  obtain ⟨B', hB'⟩ := M.exists_base\n  obtain ⟨e, he, h⟩ := hB.exists_insert_of_not_base hnb hB'\n  exact hBmax e ⟨hB'.subset_ground he.1, he.2⟩ h\n\n"}
{"name":"Matroid.ground_indep_iff_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff (M.Indep M.E) (M.Base M.E)","decl":"theorem ground_indep_iff_base : M.Indep M.E ↔ M.Base M.E :=\n  ⟨fun h ↦ h.base_of_maximal (fun _ hJ hEJ ↦ hEJ.antisymm hJ.subset_ground), Base.indep⟩\n\n"}
{"name":"Matroid.Base.exists_insert_of_ssubset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB B' I : Set α\nhB : M.Base B\nhIB : HasSSubset.SSubset I B\nhB' : M.Base B'\n⊢ Exists fun e => And (Membership.mem (SDiff.sdiff B' I) e) (M.Indep (Insert.insert e I))","decl":"theorem Base.exists_insert_of_ssubset (hB : M.Base B) (hIB : I ⊂ B) (hB' : M.Base B') :\n    ∃ e ∈ B' \\ I, M.Indep (insert e I) :=\n  (hB.indep.subset hIB.subset).exists_insert_of_not_base\n    (fun hI ↦ hIB.ne (hI.eq_of_subset_base hB hIB.subset)) hB'\n\n"}
{"name":"Matroid.ext_indep_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂) (And (Eq M₁.E M₂.E) (∀ ⦃I : Set α⦄, HasSubset.Subset I M₁.E → Iff (M₁.Indep I) (M₂.Indep I)))","decl":"@[ext] theorem ext_indep {M₁ M₂ : Matroid α} (hE : M₁.E = M₂.E)\n    (h : ∀ ⦃I⦄, I ⊆ M₁.E → (M₁.Indep I ↔ M₂.Indep I)) : M₁ = M₂ :=\n  have h' : M₁.Indep = M₂.Indep := by\n    ext I\n    by_cases hI : I ⊆ M₁.E\n    · rwa [h]\n    exact iff_of_false (fun hi ↦ hI hi.subset_ground)\n      (fun hi ↦ hI (hi.subset_ground.trans_eq hE.symm))\n  ext_base hE (fun B _ ↦ by simp_rw [base_iff_maximal_indep, h'])\n\n"}
{"name":"Matroid.ext_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nh : ∀ ⦃I : Set α⦄, HasSubset.Subset I M₁.E → Iff (M₁.Indep I) (M₂.Indep I)\n⊢ Eq M₁ M₂","decl":"@[ext] theorem ext_indep {M₁ M₂ : Matroid α} (hE : M₁.E = M₂.E)\n    (h : ∀ ⦃I⦄, I ⊆ M₁.E → (M₁.Indep I ↔ M₂.Indep I)) : M₁ = M₂ :=\n  have h' : M₁.Indep = M₂.Indep := by\n    ext I\n    by_cases hI : I ⊆ M₁.E\n    · rwa [h]\n    exact iff_of_false (fun hi ↦ hI hi.subset_ground)\n      (fun hi ↦ hI (hi.subset_ground.trans_eq hE.symm))\n  ext_base hE (fun B _ ↦ by simp_rw [base_iff_maximal_indep, h'])\n\n"}
{"name":"Matroid.eq_of_indep_iff_indep_forall","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nh : ∀ ⦃I : Set α⦄, HasSubset.Subset I M₁.E → Iff (M₁.Indep I) (M₂.Indep I)\n⊢ Eq M₁ M₂","decl":"@[deprecated (since := \"2024-12-25\")] alias eq_of_indep_iff_indep_forall := ext_indep\n\n"}
{"name":"Matroid.ext_iff_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂) (And (Eq M₁.E M₂.E) (∀ ⦃I : Set α⦄, HasSubset.Subset I M₁.E → Iff (M₁.Indep I) (M₂.Indep I)))","decl":"theorem ext_iff_indep {M₁ M₂ : Matroid α} :\n    M₁ = M₂ ↔ (M₁.E = M₂.E) ∧ ∀ ⦃I⦄, I ⊆ M₁.E → (M₁.Indep I ↔ M₂.Indep I) :=\n⟨fun h ↦ by (subst h; simp), fun h ↦ ext_indep h.1 h.2⟩\n\n"}
{"name":"Matroid.eq_iff_indep_iff_indep_forall","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\n⊢ Iff (Eq M₁ M₂) (And (Eq M₁.E M₂.E) (∀ ⦃I : Set α⦄, HasSubset.Subset I M₁.E → Iff (M₁.Indep I) (M₂.Indep I)))","decl":"@[deprecated (since := \"2024-12-25\")] alias eq_iff_indep_iff_indep_forall := ext_iff_indep\n\n"}
{"name":"Matroid.ext_base_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM₁ M₂ : Matroid α\nhE : Eq M₁.E M₂.E\nhM₁ : ∀ ⦃B : Set α⦄, M₁.Base B → M₂.Indep B\nhM₂ : ∀ ⦃B : Set α⦄, M₂.Base B → M₁.Indep B\n⊢ Eq M₁ M₂","decl":"/-- If every base of `M₁` is independent in `M₂` and vice versa, then `M₁ = M₂`. -/\nlemma ext_base_indep {M₁ M₂ : Matroid α} (hE : M₁.E = M₂.E) (hM₁ : ∀ ⦃B⦄, M₁.Base B → M₂.Indep B)\n    (hM₂ : ∀ ⦃B⦄, M₂.Base B → M₁.Indep B) : M₁ = M₂ := by\n  refine ext_indep hE fun I hIE ↦ ⟨fun hI ↦ ?_, fun hI ↦ ?_⟩\n  · obtain ⟨B, hB, hIB⟩ := hI.exists_base_superset\n    exact (hM₁ hB).subset hIB\n  obtain ⟨B, hB, hIB⟩ := hI.exists_base_superset\n  exact (hM₂ hB).subset hIB\n\n"}
{"name":"Matroid.finitary_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\n⊢ Iff M.Finitary (∀ (I : Set α), (∀ (J : Set α), HasSubset.Subset J I → J.Finite → M.Indep J) → M.Indep I)","decl":"/-- A `Finitary` matroid is one where a set is independent if and only if it all\n  its finite subsets are independent, or equivalently a matroid whose circuits are finite. -/\n@[mk_iff] class Finitary (M : Matroid α) : Prop where\n  /-- `I` is independent if all its finite subsets are independent. -/\n  indep_of_forall_finite : ∀ I, (∀ J, J ⊆ I → J.Finite → M.Indep J) → M.Indep I\n\n"}
{"name":"Matroid.Finitary.indep_of_forall_finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nself : M.Finitary\nI : Set α\na✝ : ∀ (J : Set α), HasSubset.Subset J I → J.Finite → M.Indep J\n⊢ M.Indep I","decl":"/-- A `Finitary` matroid is one where a set is independent if and only if it all\n  its finite subsets are independent, or equivalently a matroid whose circuits are finite. -/\n@[mk_iff] class Finitary (M : Matroid α) : Prop where\n  /-- `I` is independent if all its finite subsets are independent. -/\n  indep_of_forall_finite : ∀ I, (∀ J, J ⊆ I → J.Finite → M.Indep J) → M.Indep I\n\n"}
{"name":"Matroid.indep_of_forall_finite_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.Finitary\nI : Set α\nh : ∀ (J : Set α), HasSubset.Subset J I → J.Finite → M.Indep J\n⊢ M.Indep I","decl":"theorem indep_of_forall_finite_subset_indep {M : Matroid α} [Finitary M] (I : Set α)\n    (h : ∀ J, J ⊆ I → J.Finite → M.Indep J) : M.Indep I :=\n  Finitary.indep_of_forall_finite I h\n\n"}
{"name":"Matroid.indep_iff_forall_finite_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nI : Set α\nM : Matroid α\ninst✝ : M.Finitary\n⊢ Iff (M.Indep I) (∀ (J : Set α), HasSubset.Subset J I → J.Finite → M.Indep J)","decl":"theorem indep_iff_forall_finite_subset_indep {M : Matroid α} [Finitary M] :\n    M.Indep I ↔ ∀ J, J ⊆ I → J.Finite → M.Indep J :=\n  ⟨fun h _ hJI _ ↦ h.subset hJI, Finitary.indep_of_forall_finite I⟩\n\n"}
{"name":"Matroid.finitary_of_finiteRk","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\ninst✝ : M.FiniteRk\n⊢ M.Finitary","decl":"instance finitary_of_finiteRk {M : Matroid α} [FiniteRk M] : Finitary M :=\n⟨ by\n  refine fun I hI ↦ I.finite_or_infinite.elim (hI _ Subset.rfl) (fun h ↦ False.elim ?_)\n  obtain ⟨B, hB⟩ := M.exists_base\n  obtain ⟨I₀, hI₀I, hI₀fin, hI₀card⟩ := h.exists_subset_ncard_eq (B.ncard + 1)\n  obtain ⟨B', hB', hI₀B'⟩ := (hI _ hI₀I hI₀fin).exists_base_superset\n  have hle := ncard_le_ncard hI₀B' hB'.finite\n  rw [hI₀card, hB'.ncard_eq_ncard_of_base hB, Nat.add_one_le_iff] at hle\n  exact hle.ne rfl ⟩\n\n"}
{"name":"Matroid.existsMaximalSubsetProperty_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\na✝ : HasSubset.Subset X M.E\n⊢ Matroid.ExistsMaximalSubsetProperty M.Indep X","decl":"/-- Matroids obey the maximality axiom -/\ntheorem existsMaximalSubsetProperty_indep (M : Matroid α) :\n    ∀ X, X ⊆ M.E → ExistsMaximalSubsetProperty M.Indep X :=\n  M.maximality\n\n"}
{"name":"Matroid.copy_E","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nBase Indep : Set α → Prop\nhE : Eq E M.E\nhB : ∀ (B : Set α), Iff (Base B) (M.Base B)\nhI : ∀ (I : Set α), Iff (Indep I) (M.Indep I)\n⊢ Eq (M.copy E Base Indep hE hB hI).E E","decl":"/-- create a copy of `M : Matroid α` with independence and base predicates and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps] def copy (M : Matroid α) (E : Set α) (Base Indep : Set α → Prop)\n    (hE : E = M.E) (hB : ∀ B, Base B ↔ M.Base B) (hI : ∀ I, Indep I ↔ M.Indep I) : Matroid α where\n  E := E\n  Base := Base\n  Indep := Indep\n  indep_iff' _ := by simp_rw [hI, hB, M.indep_iff]\n  exists_base := by\n    simp_rw [hB]\n    exact M.exists_base\n  base_exchange := by\n    simp_rw [show Base = M.Base from funext (by simp [hB])]\n    exact M.base_exchange\n  maximality := by\n    simp_rw [hE, show Indep = M.Indep from funext (by simp [hI])]\n    exact M.maximality\n  subset_ground := by\n    simp_rw [hE, hB]\n    exact M.subset_ground\n\n"}
{"name":"Matroid.copy_Indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nBase Indep : Set α → Prop\nhE : Eq E M.E\nhB : ∀ (B : Set α), Iff (Base B) (M.Base B)\nhI : ∀ (I : Set α), Iff (Indep I) (M.Indep I)\na✝ : Set α\n⊢ Eq ((M.copy E Base Indep hE hB hI).Indep a✝) (Indep a✝)","decl":"/-- create a copy of `M : Matroid α` with independence and base predicates and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps] def copy (M : Matroid α) (E : Set α) (Base Indep : Set α → Prop)\n    (hE : E = M.E) (hB : ∀ B, Base B ↔ M.Base B) (hI : ∀ I, Indep I ↔ M.Indep I) : Matroid α where\n  E := E\n  Base := Base\n  Indep := Indep\n  indep_iff' _ := by simp_rw [hI, hB, M.indep_iff]\n  exists_base := by\n    simp_rw [hB]\n    exact M.exists_base\n  base_exchange := by\n    simp_rw [show Base = M.Base from funext (by simp [hB])]\n    exact M.base_exchange\n  maximality := by\n    simp_rw [hE, show Indep = M.Indep from funext (by simp [hI])]\n    exact M.maximality\n  subset_ground := by\n    simp_rw [hE, hB]\n    exact M.subset_ground\n\n"}
{"name":"Matroid.copy_Base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nBase Indep : Set α → Prop\nhE : Eq E M.E\nhB : ∀ (B : Set α), Iff (Base B) (M.Base B)\nhI : ∀ (I : Set α), Iff (Indep I) (M.Indep I)\na✝ : Set α\n⊢ Eq ((M.copy E Base Indep hE hB hI).Base a✝) (Base a✝)","decl":"/-- create a copy of `M : Matroid α` with independence and base predicates and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps] def copy (M : Matroid α) (E : Set α) (Base Indep : Set α → Prop)\n    (hE : E = M.E) (hB : ∀ B, Base B ↔ M.Base B) (hI : ∀ I, Indep I ↔ M.Indep I) : Matroid α where\n  E := E\n  Base := Base\n  Indep := Indep\n  indep_iff' _ := by simp_rw [hI, hB, M.indep_iff]\n  exists_base := by\n    simp_rw [hB]\n    exact M.exists_base\n  base_exchange := by\n    simp_rw [show Base = M.Base from funext (by simp [hB])]\n    exact M.base_exchange\n  maximality := by\n    simp_rw [hE, show Indep = M.Indep from funext (by simp [hI])]\n    exact M.maximality\n  subset_ground := by\n    simp_rw [hE, hB]\n    exact M.subset_ground\n\n"}
{"name":"Matroid.copyIndep_Base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nIndep : Set α → Prop\nhE : Eq E M.E\nh : ∀ (I : Set α), Iff (Indep I) (M.Indep I)\na✝ : Set α\n⊢ Eq ((M.copyIndep E Indep hE h).Base a✝) (M.Base a✝)","decl":"/-- create a copy of `M : Matroid α` with an independence predicate and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps!] def copyIndep (M : Matroid α) (E : Set α) (Indep : Set α → Prop)\n    (hE : E = M.E) (h : ∀ I, Indep I ↔ M.Indep I) : Matroid α :=\n  M.copy E M.Base Indep hE (fun _ ↦ Iff.rfl) h\n\n"}
{"name":"Matroid.copyIndep_Indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nIndep : Set α → Prop\nhE : Eq E M.E\nh : ∀ (I : Set α), Iff (Indep I) (M.Indep I)\na✝ : Set α\n⊢ Eq ((M.copyIndep E Indep hE h).Indep a✝) (Indep a✝)","decl":"/-- create a copy of `M : Matroid α` with an independence predicate and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps!] def copyIndep (M : Matroid α) (E : Set α) (Indep : Set α → Prop)\n    (hE : E = M.E) (h : ∀ I, Indep I ↔ M.Indep I) : Matroid α :=\n  M.copy E M.Base Indep hE (fun _ ↦ Iff.rfl) h\n\n"}
{"name":"Matroid.copyIndep_E","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nIndep : Set α → Prop\nhE : Eq E M.E\nh : ∀ (I : Set α), Iff (Indep I) (M.Indep I)\n⊢ Eq (M.copyIndep E Indep hE h).E E","decl":"/-- create a copy of `M : Matroid α` with an independence predicate and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps!] def copyIndep (M : Matroid α) (E : Set α) (Indep : Set α → Prop)\n    (hE : E = M.E) (h : ∀ I, Indep I ↔ M.Indep I) : Matroid α :=\n  M.copy E M.Base Indep hE (fun _ ↦ Iff.rfl) h\n\n"}
{"name":"Matroid.copyBase_Indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nBase : Set α → Prop\nhE : Eq E M.E\nh : ∀ (B : Set α), Iff (Base B) (M.Base B)\na✝ : Set α\n⊢ Eq ((M.copyBase E Base hE h).Indep a✝) (M.Indep a✝)","decl":"/-- create a copy of `M : Matroid α` with a base predicate and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps!] def copyBase (M : Matroid α) (E : Set α) (Base : Set α → Prop)\n    (hE : E = M.E) (h : ∀ B, Base B ↔ M.Base B) : Matroid α :=\n  M.copy E Base M.Indep hE h (fun _ ↦ Iff.rfl)\n\n"}
{"name":"Matroid.copyBase_E","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nBase : Set α → Prop\nhE : Eq E M.E\nh : ∀ (B : Set α), Iff (Base B) (M.Base B)\n⊢ Eq (M.copyBase E Base hE h).E E","decl":"/-- create a copy of `M : Matroid α` with a base predicate and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps!] def copyBase (M : Matroid α) (E : Set α) (Base : Set α → Prop)\n    (hE : E = M.E) (h : ∀ B, Base B ↔ M.Base B) : Matroid α :=\n  M.copy E Base M.Indep hE h (fun _ ↦ Iff.rfl)\n\n"}
{"name":"Matroid.copyBase_Base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nE : Set α\nBase : Set α → Prop\nhE : Eq E M.E\nh : ∀ (B : Set α), Iff (Base B) (M.Base B)\na✝ : Set α\n⊢ Eq ((M.copyBase E Base hE h).Base a✝) (Base a✝)","decl":"/-- create a copy of `M : Matroid α` with a base predicate and ground set defeq\nto supplied arguments that are provably equal to those of `M`. -/\n@[simps!] def copyBase (M : Matroid α) (E : Set α) (Base : Set α → Prop)\n    (hE : E = M.E) (h : ∀ B, Base B ↔ M.Base B) : Matroid α :=\n  M.copy E Base M.Indep hE h (fun _ ↦ Iff.rfl)\n\n"}
{"name":"Matroid.Basis'.indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis' I X\n⊢ M.Indep I","decl":"theorem Basis'.indep (hI : M.Basis' I X) : M.Indep I :=\n  hI.1.1\n\n"}
{"name":"Matroid.Basis.indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ M.Indep I","decl":"theorem Basis.indep (hI : M.Basis I X) : M.Indep I :=\n  hI.1.1.1\n\n"}
{"name":"Matroid.Basis.subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ HasSubset.Subset I X","decl":"theorem Basis.subset (hI : M.Basis I X) : I ⊆ X :=\n  hI.1.1.2\n\n"}
{"name":"Matroid.Basis.basis'","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ M.Basis' I X","decl":"theorem Basis.basis' (hI : M.Basis I X) : M.Basis' I X :=\n  hI.1\n\n"}
{"name":"Matroid.Basis'.basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis' I X\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Basis I X","decl":"theorem Basis'.basis (hI : M.Basis' I X) (hX : X ⊆ M.E := by aesop_mat) : M.Basis I X :=\n  ⟨hI, hX⟩\n\n"}
{"name":"Matroid.Basis'.subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis' I X\n⊢ HasSubset.Subset I X","decl":"theorem Basis'.subset (hI : M.Basis' I X) : I ⊆ X :=\n  hI.1.2\n\n\n"}
{"name":"Matroid.Basis.subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ HasSubset.Subset X M.E","decl":"@[aesop unsafe 15% (rule_sets := [Matroid])]\ntheorem Basis.subset_ground (hI : M.Basis I X) : X ⊆ M.E :=\n  hI.2\n\n"}
{"name":"Matroid.Basis.basis_inter_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ M.Basis I (Inter.inter X M.E)","decl":"theorem Basis.basis_inter_ground (hI : M.Basis I X) : M.Basis I (X ∩ M.E) := by\n  convert hI\n  rw [inter_eq_self_of_subset_left hI.subset_ground]\n\n"}
{"name":"Matroid.Basis.left_subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ HasSubset.Subset I M.E","decl":"@[aesop unsafe 15% (rule_sets := [Matroid])]\ntheorem Basis.left_subset_ground (hI : M.Basis I X) : I ⊆ M.E :=\n  hI.indep.subset_ground\n\n"}
{"name":"Matroid.Basis.eq_of_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X : Set α\nhI : M.Basis I X\nhJ : M.Indep J\nhIJ : HasSubset.Subset I J\nhJX : HasSubset.Subset J X\n⊢ Eq I J","decl":"theorem Basis.eq_of_subset_indep (hI : M.Basis I X) (hJ : M.Indep J) (hIJ : I ⊆ J) (hJX : J ⊆ X) :\n    I = J :=\n  hIJ.antisymm (hI.1.2 ⟨hJ, hJX⟩ hIJ)\n\n"}
{"name":"Matroid.Basis.Finite","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\ninst✝ : M.FiniteRk\n⊢ I.Finite","decl":"theorem Basis.Finite (hI : M.Basis I X) [FiniteRk M] : I.Finite := hI.indep.finite\n\n"}
{"name":"Matroid.basis_iff'","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\n⊢ Iff (M.Basis I X) (And (And (M.Indep I) (And (HasSubset.Subset I X) (∀ ⦃J : Set α⦄, M.Indep J → HasSubset.Subset I J → HasSubset.Subset J X → Eq I J))) (HasSubset.Subset X M.E))","decl":"theorem basis_iff' :\n    M.Basis I X ↔ (M.Indep I ∧ I ⊆ X ∧ ∀ ⦃J⦄, M.Indep J → I ⊆ J → J ⊆ X → I = J) ∧ X ⊆ M.E := by\n  rw [Basis, maximal_subset_iff]\n  tauto\n\n"}
{"name":"Matroid.basis_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Basis I X) (And (M.Indep I) (And (HasSubset.Subset I X) (∀ (J : Set α), M.Indep J → HasSubset.Subset I J → HasSubset.Subset J X → Eq I J)))","decl":"theorem basis_iff (hX : X ⊆ M.E := by aesop_mat) :\n    M.Basis I X ↔ (M.Indep I ∧ I ⊆ X ∧ ∀ J, M.Indep J → I ⊆ J → J ⊆ X → I = J) := by\n  rw [basis_iff', and_iff_left hX]\n\n"}
{"name":"Matroid.basis'_iff_basis_inter_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\n⊢ Iff (M.Basis' I X) (M.Basis I (Inter.inter X M.E))","decl":"theorem basis'_iff_basis_inter_ground : M.Basis' I X ↔ M.Basis I (X ∩ M.E) := by\n  rw [Basis', Basis, and_iff_left inter_subset_right, maximal_iff_maximal_of_imp_of_forall]\n  · exact fun I hI ↦ ⟨hI.1, hI.2.trans inter_subset_left⟩\n  exact fun I hI ↦ ⟨I, rfl.le, hI.1, subset_inter hI.2 hI.1.subset_ground⟩\n\n"}
{"name":"Matroid.basis'_iff_basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Basis' I X) (M.Basis I X)","decl":"theorem basis'_iff_basis (hX : X ⊆ M.E := by aesop_mat) : M.Basis' I X ↔ M.Basis I X := by\n  rw [basis'_iff_basis_inter_ground, inter_eq_self_of_subset_left hX]\n\n"}
{"name":"Matroid.basis_iff_basis'_subset_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\n⊢ Iff (M.Basis I X) (And (M.Basis' I X) (HasSubset.Subset X M.E))","decl":"theorem basis_iff_basis'_subset_ground : M.Basis I X ↔ M.Basis' I X ∧ X ⊆ M.E :=\n  ⟨fun h ↦ ⟨h.basis', h.subset_ground⟩, fun h ↦ (basis'_iff_basis h.2).mp h.1⟩\n\n"}
{"name":"Matroid.Basis'.basis_inter_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhIX : M.Basis' I X\n⊢ M.Basis I (Inter.inter X M.E)","decl":"theorem Basis'.basis_inter_ground (hIX : M.Basis' I X) : M.Basis I (X ∩ M.E) :=\n  basis'_iff_basis_inter_ground.mp hIX\n\n"}
{"name":"Matroid.Basis'.eq_of_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X : Set α\nhI : M.Basis' I X\nhJ : M.Indep J\nhIJ : HasSubset.Subset I J\nhJX : HasSubset.Subset J X\n⊢ Eq I J","decl":"theorem Basis'.eq_of_subset_indep (hI : M.Basis' I X) (hJ : M.Indep J) (hIJ : I ⊆ J)\n    (hJX : J ⊆ X) : I = J :=\n  hIJ.antisymm (hI.2 ⟨hJ, hJX⟩ hIJ)\n\n"}
{"name":"Matroid.Basis'.insert_not_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\ne : α\nhI : M.Basis' I X\nhe : Membership.mem (SDiff.sdiff X I) e\n⊢ Not (M.Indep (Insert.insert e I))","decl":"theorem Basis'.insert_not_indep (hI : M.Basis' I X) (he : e ∈ X \\ I) : ¬ M.Indep (insert e I) :=\n  fun hi ↦ he.2 <| insert_eq_self.1 <| Eq.symm <|\n    hI.eq_of_subset_indep hi (subset_insert _ _) (insert_subset he.1 hI.subset)\n\n"}
{"name":"Matroid.basis_iff_maximal","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Iff (M.Basis I X) (Maximal (fun I => And (M.Indep I) (HasSubset.Subset I X)) I)","decl":"theorem basis_iff_maximal (hX : X ⊆ M.E := by aesop_mat) :\n    M.Basis I X ↔ Maximal (fun I ↦ M.Indep I ∧ I ⊆ X) I := by\n  rw [Basis, and_iff_left hX]\n\n"}
{"name":"Matroid.Indep.basis_of_maximal_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\nhmax : ∀ ⦃J : Set α⦄, M.Indep J → HasSubset.Subset I J → HasSubset.Subset J X → HasSubset.Subset J I\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ M.Basis I X","decl":"theorem Indep.basis_of_maximal_subset (hI : M.Indep I) (hIX : I ⊆ X)\n    (hmax : ∀ ⦃J⦄, M.Indep J → I ⊆ J → J ⊆ X → J ⊆ I) (hX : X ⊆ M.E := by aesop_mat) :\n    M.Basis I X := by\n  rw [basis_iff (by aesop_mat : X ⊆ M.E), and_iff_right hI, and_iff_right hIX]\n  exact fun J hJ hIJ hJX ↦ hIJ.antisymm (hmax hJ hIJ hJX)\n\n"}
{"name":"Matroid.Basis.basis_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y : Set α\nhI : M.Basis I X\nhIY : HasSubset.Subset I Y\nhYX : HasSubset.Subset Y X\n⊢ M.Basis I Y","decl":"theorem Basis.basis_subset (hI : M.Basis I X) (hIY : I ⊆ Y) (hYX : Y ⊆ X) : M.Basis I Y := by\n  rw [basis_iff (hYX.trans hI.subset_ground), and_iff_right hI.indep, and_iff_right hIY]\n  exact fun J hJ hIJ hJY ↦ hI.eq_of_subset_indep hJ hIJ (hJY.trans hYX)\n\n"}
{"name":"Matroid.basis_self_iff_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\n⊢ Iff (M.Basis I I) (M.Indep I)","decl":"@[simp] theorem basis_self_iff_indep : M.Basis I I ↔ M.Indep I := by\n  rw [basis_iff', and_iff_right rfl.subset, and_assoc, and_iff_left_iff_imp]\n  exact fun hi ↦ ⟨fun _ _ ↦ subset_antisymm, hi.subset_ground⟩\n\n"}
{"name":"Matroid.Indep.basis_self","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nh : M.Indep I\n⊢ M.Basis I I","decl":"theorem Indep.basis_self (h : M.Indep I) : M.Basis I I :=\n  basis_self_iff_indep.mpr h\n\n"}
{"name":"Matroid.basis_empty_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nI : Set α\nM : Matroid α\n⊢ Iff (M.Basis I EmptyCollection.emptyCollection) (Eq I EmptyCollection.emptyCollection)","decl":"@[simp] theorem basis_empty_iff (M : Matroid α) : M.Basis I ∅ ↔ I = ∅ :=\n  ⟨fun h ↦ subset_empty_iff.mp h.subset, fun h ↦ by (rw [h]; exact M.empty_indep.basis_self)⟩\n\n"}
{"name":"Matroid.Basis.dep_of_ssubset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y : Set α\nhI : M.Basis I X\nhIY : HasSSubset.SSubset I Y\nhYX : HasSubset.Subset Y X\n⊢ M.Dep Y","decl":"theorem Basis.dep_of_ssubset (hI : M.Basis I X) (hIY : I ⊂ Y) (hYX : Y ⊆ X) : M.Dep Y := by\n  have : X ⊆ M.E := hI.subset_ground\n  rw [← not_indep_iff]\n  exact fun hY ↦ hIY.ne (hI.eq_of_subset_indep hY hIY.subset hYX)\n\n"}
{"name":"Matroid.Basis.insert_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\ne : α\nhI : M.Basis I X\nhe : Membership.mem (SDiff.sdiff X I) e\n⊢ M.Dep (Insert.insert e I)","decl":"theorem Basis.insert_dep (hI : M.Basis I X) (he : e ∈ X \\ I) : M.Dep (insert e I) :=\n  hI.dep_of_ssubset (ssubset_insert he.2) (insert_subset he.1 hI.subset)\n\n"}
{"name":"Matroid.Basis.mem_of_insert_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\ne : α\nhI : M.Basis I X\nhe : Membership.mem X e\nhIe : M.Indep (Insert.insert e I)\n⊢ Membership.mem I e","decl":"theorem Basis.mem_of_insert_indep (hI : M.Basis I X) (he : e ∈ X) (hIe : M.Indep (insert e I)) :\n    e ∈ I :=\n  by_contra (fun heI ↦ (hI.insert_dep ⟨he, heI⟩).not_indep hIe)\n\n"}
{"name":"Matroid.Basis'.mem_of_insert_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\ne : α\nhI : M.Basis' I X\nhe : Membership.mem X e\nhIe : M.Indep (Insert.insert e I)\n⊢ Membership.mem I e","decl":"theorem Basis'.mem_of_insert_indep (hI : M.Basis' I X) (he : e ∈ X) (hIe : M.Indep (insert e I)) :\n    e ∈ I :=\n  hI.basis_inter_ground.mem_of_insert_indep ⟨he, hIe.subset_ground (mem_insert _ _)⟩ hIe\n\n"}
{"name":"Matroid.Basis.not_basis_of_ssubset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X : Set α\nhI : M.Basis I X\nhJI : HasSSubset.SSubset J I\n⊢ Not (M.Basis J X)","decl":"theorem Basis.not_basis_of_ssubset (hI : M.Basis I X) (hJI : J ⊂ I) : ¬ M.Basis J X :=\n  fun h ↦ hJI.ne (h.eq_of_subset_indep hI.indep hJI.subset hI.subset)\n\n"}
{"name":"Matroid.Indep.subset_basis_of_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Exists fun J => And (M.Basis J X) (HasSubset.Subset I J)","decl":"theorem Indep.subset_basis_of_subset (hI : M.Indep I) (hIX : I ⊆ X) (hX : X ⊆ M.E := by aesop_mat) :\n    ∃ J, M.Basis J X ∧ I ⊆ J := by\n  obtain ⟨J, hJ, hJmax⟩ := M.maximality X hX I hI hIX\n  exact ⟨J, ⟨hJmax, hX⟩, hJ⟩\n\n"}
{"name":"Matroid.Indep.subset_basis'_of_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\n⊢ Exists fun J => And (M.Basis' J X) (HasSubset.Subset I J)","decl":"theorem Indep.subset_basis'_of_subset (hI : M.Indep I) (hIX : I ⊆ X) :\n    ∃ J, M.Basis' J X ∧ I ⊆ J := by\n  simp_rw [basis'_iff_basis_inter_ground]\n  exact hI.subset_basis_of_subset (subset_inter hIX hI.subset_ground)\n\n"}
{"name":"Matroid.exists_basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\n⊢ Exists fun I => M.Basis I X","decl":"theorem exists_basis (M : Matroid α) (X : Set α) (hX : X ⊆ M.E := by aesop_mat) :\n    ∃ I, M.Basis I X :=\n  let ⟨_, hI, _⟩ := M.empty_indep.subset_basis_of_subset (empty_subset X)\n  ⟨_,hI⟩\n\n"}
{"name":"Matroid.exists_basis'","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX : Set α\n⊢ Exists fun I => M.Basis' I X","decl":"theorem exists_basis' (M : Matroid α) (X : Set α) : ∃ I, M.Basis' I X :=\n  let ⟨_, hI, _⟩ := M.empty_indep.subset_basis'_of_subset (empty_subset X)\n  ⟨_,hI⟩\n\n"}
{"name":"Matroid.exists_basis_subset_basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nX Y : Set α\nM : Matroid α\nhXY : HasSubset.Subset X Y\nhY : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ Exists fun I => Exists fun J => And (M.Basis I X) (And (M.Basis J Y) (HasSubset.Subset I J))","decl":"theorem exists_basis_subset_basis (M : Matroid α) (hXY : X ⊆ Y) (hY : Y ⊆ M.E := by aesop_mat) :\n    ∃ I J, M.Basis I X ∧ M.Basis J Y ∧ I ⊆ J := by\n  obtain ⟨I, hI⟩ := M.exists_basis X (hXY.trans hY)\n  obtain ⟨J, hJ, hIJ⟩ := hI.indep.subset_basis_of_subset (hI.subset.trans hXY)\n  exact ⟨_, _, hI, hJ, hIJ⟩\n\n"}
{"name":"Matroid.Basis.exists_basis_inter_eq_of_superset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y : Set α\nhI : M.Basis I X\nhXY : HasSubset.Subset X Y\nhY : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ Exists fun J => And (M.Basis J Y) (Eq (Inter.inter J X) I)","decl":"theorem Basis.exists_basis_inter_eq_of_superset (hI : M.Basis I X) (hXY : X ⊆ Y)\n    (hY : Y ⊆ M.E := by aesop_mat) : ∃ J, M.Basis J Y ∧ J ∩ X = I := by\n  obtain ⟨J, hJ, hIJ⟩ := hI.indep.subset_basis_of_subset (hI.subset.trans hXY)\n  refine ⟨J, hJ, subset_antisymm ?_ (subset_inter hIJ hI.subset)⟩\n  exact fun e he ↦ hI.mem_of_insert_indep he.2 (hJ.indep.subset (insert_subset he.1 hIJ))\n\n"}
{"name":"Matroid.exists_basis_union_inter_basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX Y : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\nhY : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ Exists fun I => And (M.Basis I (Union.union X Y)) (M.Basis (Inter.inter I Y) Y)","decl":"theorem exists_basis_union_inter_basis (M : Matroid α) (X Y : Set α) (hX : X ⊆ M.E := by aesop_mat)\n    (hY : Y ⊆ M.E := by aesop_mat) : ∃ I, M.Basis I (X ∪ Y) ∧ M.Basis (I ∩ Y) Y :=\n  let ⟨J, hJ⟩ := M.exists_basis Y\n  (hJ.exists_basis_inter_eq_of_superset subset_union_right).imp\n  (fun I hI ↦ ⟨hI.1, by rwa [hI.2]⟩)\n\n"}
{"name":"Matroid.Indep.eq_of_basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J : Set α\nhI : M.Indep I\nhJ : M.Basis J I\n⊢ Eq J I","decl":"theorem Indep.eq_of_basis (hI : M.Indep I) (hJ : M.Basis J I) : J = I :=\n  hJ.eq_of_subset_indep hI hJ.subset rfl.subset\n\n"}
{"name":"Matroid.Basis.exists_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Basis I X\n⊢ Exists fun B => And (M.Base B) (Eq I (Inter.inter B X))","decl":"theorem Basis.exists_base (hI : M.Basis I X) : ∃ B, M.Base B ∧ I = B ∩ X :=\n  let ⟨B,hB, hIB⟩ := hI.indep.exists_base_superset\n  ⟨B, hB, subset_antisymm (subset_inter hIB hI.subset)\n    (by rw [hI.eq_of_subset_indep (hB.indep.inter_right X) (subset_inter hIB hI.subset)\n    inter_subset_right])⟩\n\n"}
{"name":"Matroid.basis_ground_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\n⊢ Iff (M.Basis B M.E) (M.Base B)","decl":"@[simp] theorem basis_ground_iff : M.Basis B M.E ↔ M.Base B := by\n  rw [Basis, and_iff_left rfl.subset, base_iff_maximal_indep,\n    maximal_and_iff_right_of_imp (fun _ h ↦ h.subset_ground),\n    and_iff_left_of_imp (fun h ↦ h.1.subset_ground)]\n\n"}
{"name":"Matroid.Base.basis_ground","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB : Set α\nhB : M.Base B\n⊢ M.Basis B M.E","decl":"theorem Base.basis_ground (hB : M.Base B) : M.Basis B M.E :=\n  basis_ground_iff.mpr hB\n\n"}
{"name":"Matroid.Indep.basis_iff_forall_insert_dep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\n⊢ Iff (M.Basis I X) (∀ (e : α), Membership.mem (SDiff.sdiff X I) e → M.Dep (Insert.insert e I))","decl":"theorem Indep.basis_iff_forall_insert_dep (hI : M.Indep I) (hIX : I ⊆ X) :\n    M.Basis I X ↔ ∀ e ∈ X \\ I, M.Dep (insert e I) := by\n  rw [Basis, maximal_iff_forall_insert (fun I J hI hIJ ↦ ⟨hI.1.subset hIJ, hIJ.trans hI.2⟩)]\n  simp only [hI, hIX, and_self, insert_subset_iff, and_true, not_and, true_and, mem_diff, and_imp,\n    Dep, hI.subset_ground]\n  exact ⟨fun h e heX heI ↦ ⟨fun hi ↦ h.1 e heI hi heX, h.2 heX⟩,\n    fun h ↦ ⟨fun e heI hi heX ↦ (h e heX heI).1 hi,\n      fun e heX ↦ (em (e ∈ I)).elim (fun h ↦ hI.subset_ground h) fun heI ↦ (h _ heX heI).2 ⟩⟩\n\n"}
{"name":"Matroid.Indep.basis_of_forall_insert","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\nhI : M.Indep I\nhIX : HasSubset.Subset I X\nhe : ∀ (e : α), Membership.mem (SDiff.sdiff X I) e → M.Dep (Insert.insert e I)\n⊢ M.Basis I X","decl":"theorem Indep.basis_of_forall_insert (hI : M.Indep I) (hIX : I ⊆ X)\n    (he : ∀ e ∈ X \\ I, M.Dep (insert e I)) : M.Basis I X :=\n  (hI.basis_iff_forall_insert_dep hIX).mpr he\n\n"}
{"name":"Matroid.Indep.basis_insert_iff","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\ne : α\nhI : M.Indep I\n⊢ Iff (M.Basis I (Insert.insert e I)) (Or (M.Dep (Insert.insert e I)) (Membership.mem I e))","decl":"theorem Indep.basis_insert_iff (hI : M.Indep I) :\n    M.Basis I (insert e I) ↔ M.Dep (insert e I) ∨ e ∈ I := by\n  simp_rw [hI.basis_iff_forall_insert_dep (subset_insert _ _), dep_iff, insert_subset_iff,\n    and_iff_left hI.subset_ground, mem_diff, mem_insert_iff, or_and_right, and_not_self,\n    or_false, and_imp, forall_eq]\n  tauto\n\n"}
{"name":"Matroid.Basis.iUnion_basis_iUnion","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nι : Type u_2\nX I : ι → Set α\nhI : ∀ (i : ι), M.Basis (I i) (X i)\nh_ind : M.Indep (Set.iUnion fun i => I i)\n⊢ M.Basis (Set.iUnion fun i => I i) (Set.iUnion fun i => X i)","decl":"theorem Basis.iUnion_basis_iUnion {ι : Type _} (X I : ι → Set α) (hI : ∀ i, M.Basis (I i) (X i))\n    (h_ind : M.Indep (⋃ i, I i)) : M.Basis (⋃ i, I i) (⋃ i, X i) := by\n  refine h_ind.basis_of_forall_insert\n    (iUnion_subset (fun i ↦ (hI i).subset.trans (subset_iUnion _ _))) ?_\n  rintro e ⟨⟨_, ⟨⟨i, hi, rfl⟩, (hes : e ∈ X i)⟩⟩, he'⟩\n  rw [mem_iUnion, not_exists] at he'\n  refine ((hI i).insert_dep ⟨hes, he' _⟩).superset (insert_subset_insert (subset_iUnion _ _)) ?_\n  rw [insert_subset_iff, iUnion_subset_iff, and_iff_left (fun i ↦ (hI i).indep.subset_ground)]\n  exact (hI i).subset_ground hes\n\n"}
{"name":"Matroid.Basis.basis_iUnion","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nι : Type u_2\ninst✝ : Nonempty ι\nX : ι → Set α\nhI : ∀ (i : ι), M.Basis I (X i)\n⊢ M.Basis I (Set.iUnion fun i => X i)","decl":"theorem Basis.basis_iUnion {ι : Type _} [Nonempty ι] (X : ι → Set α)\n    (hI : ∀ i, M.Basis I (X i)) : M.Basis I (⋃ i, X i) := by\n  convert Basis.iUnion_basis_iUnion X (fun _ ↦ I) (fun i ↦ hI i) _ <;> rw [iUnion_const]\n  exact (hI (Classical.arbitrary ι)).indep\n\n"}
{"name":"Matroid.Basis.basis_sUnion","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nXs : Set (Set α)\nhne : Xs.Nonempty\nh : ∀ (X : Set α), Membership.mem Xs X → M.Basis I X\n⊢ M.Basis I Xs.sUnion","decl":"theorem Basis.basis_sUnion {Xs : Set (Set α)} (hne : Xs.Nonempty) (h : ∀ X ∈ Xs, M.Basis I X) :\n    M.Basis I (⋃₀ Xs) := by\n  rw [sUnion_eq_iUnion]\n  have := Iff.mpr nonempty_coe_sort hne\n  exact Basis.basis_iUnion _ fun X ↦ (h X X.prop)\n\n"}
{"name":"Matroid.Indep.basis_setOf_insert_basis","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI : Set α\nhI : M.Indep I\n⊢ M.Basis I (setOf fun x => M.Basis I (Insert.insert x I))","decl":"theorem Indep.basis_setOf_insert_basis (hI : M.Indep I) :\n    M.Basis I {x | M.Basis I (insert x I)} := by\n  refine hI.basis_of_forall_insert (fun e he ↦ (?_ : M.Basis _ _))\n    (fun e he ↦ ⟨fun hu ↦ he.2 ?_, he.1.subset_ground⟩)\n  · rw [insert_eq_of_mem he]; exact hI.basis_self\n  simpa using (hu.eq_of_basis he.1).symm\n\n"}
{"name":"Matroid.Basis.union_basis_union","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X Y : Set α\nhIX : M.Basis I X\nhJY : M.Basis J Y\nh : M.Indep (Union.union I J)\n⊢ M.Basis (Union.union I J) (Union.union X Y)","decl":"theorem Basis.union_basis_union (hIX : M.Basis I X) (hJY : M.Basis J Y) (h : M.Indep (I ∪ J)) :\n    M.Basis (I ∪ J) (X ∪ Y) := by\n  rw [union_eq_iUnion, union_eq_iUnion]\n  refine Basis.iUnion_basis_iUnion _ _ ?_ ?_\n  · simp only [Bool.forall_bool, cond_false, cond_true]; exact ⟨hJY, hIX⟩\n  rwa [← union_eq_iUnion]\n\n"}
{"name":"Matroid.Basis.basis_union","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X Y : Set α\nhIX : M.Basis I X\nhIY : M.Basis I Y\n⊢ M.Basis I (Union.union X Y)","decl":"theorem Basis.basis_union (hIX : M.Basis I X) (hIY : M.Basis I Y) : M.Basis I (X ∪ Y) := by\n    convert hIX.union_basis_union hIY _ <;> rw [union_self]; exact hIX.indep\n\n"}
{"name":"Matroid.Basis.basis_union_of_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X : Set α\nhI : M.Basis I X\nhJ : M.Indep J\nhIJ : HasSubset.Subset I J\n⊢ M.Basis J (Union.union J X)","decl":"theorem Basis.basis_union_of_subset (hI : M.Basis I X) (hJ : M.Indep J) (hIJ : I ⊆ J) :\n    M.Basis J (J ∪ X) := by\n  convert hJ.basis_self.union_basis_union hI _ <;>\n  rw [union_eq_self_of_subset_right hIJ]\n  assumption\n\n"}
{"name":"Matroid.Basis.insert_basis_insert","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI X : Set α\ne : α\nhI : M.Basis I X\nh : M.Indep (Insert.insert e I)\n⊢ M.Basis (Insert.insert e I) (Insert.insert e X)","decl":"theorem Basis.insert_basis_insert (hI : M.Basis I X) (h : M.Indep (insert e I)) :\n    M.Basis (insert e I) (insert e X) := by\n  simp_rw [← union_singleton] at *\n  exact hI.union_basis_union (h.subset subset_union_right).basis_self h\n\n"}
{"name":"Matroid.Base.base_of_basis_superset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB I X : Set α\nhB : M.Base B\nhBX : HasSubset.Subset B X\nhIX : M.Basis I X\n⊢ M.Base I","decl":"theorem Base.base_of_basis_superset (hB : M.Base B) (hBX : B ⊆ X) (hIX : M.Basis I X) :\n    M.Base I := by\n  by_contra h\n  obtain ⟨e,heBI,he⟩ := hIX.indep.exists_insert_of_not_base h hB\n  exact heBI.2 (hIX.mem_of_insert_indep (hBX heBI.1) he)\n\n"}
{"name":"Matroid.Indep.exists_base_subset_union_base","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB I : Set α\nhI : M.Indep I\nhB : M.Base B\n⊢ Exists fun B' => And (M.Base B') (And (HasSubset.Subset I B') (HasSubset.Subset B' (Union.union I B)))","decl":"theorem Indep.exists_base_subset_union_base (hI : M.Indep I) (hB : M.Base B) :\n    ∃ B', M.Base B' ∧ I ⊆ B' ∧ B' ⊆ I ∪ B := by\n  obtain ⟨B', hB', hIB'⟩ := hI.subset_basis_of_subset <| subset_union_left (t := B)\n  exact ⟨B', hB.base_of_basis_superset subset_union_right hB', hIB', hB'.subset⟩\n\n"}
{"name":"Matroid.Basis.inter_eq_of_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X : Set α\nhIX : M.Basis I X\nhIJ : HasSubset.Subset I J\nhJ : M.Indep J\n⊢ Eq (Inter.inter J X) I","decl":"theorem Basis.inter_eq_of_subset_indep (hIX : M.Basis I X) (hIJ : I ⊆ J) (hJ : M.Indep J) :\n    J ∩ X = I :=\n(subset_inter hIJ hIX.subset).antisymm'\n  (fun _ he ↦ hIX.mem_of_insert_indep he.2 (hJ.subset (insert_subset he.1 hIJ)))\n\n"}
{"name":"Matroid.Basis'.inter_eq_of_subset_indep","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nI J X : Set α\nhI : M.Basis' I X\nhIJ : HasSubset.Subset I J\nhJ : M.Indep J\n⊢ Eq (Inter.inter J X) I","decl":"theorem Basis'.inter_eq_of_subset_indep (hI : M.Basis' I X) (hIJ : I ⊆ J) (hJ : M.Indep J) :\n    J ∩ X = I := by\n  rw [← hI.basis_inter_ground.inter_eq_of_subset_indep hIJ hJ, inter_comm X, ← inter_assoc,\n    inter_eq_self_of_subset_left hJ.subset_ground]\n\n"}
{"name":"Matroid.Base.basis_of_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nB X : Set α\nhX : autoParam (HasSubset.Subset X M.E) _auto✝\nhB : M.Base B\nhBX : HasSubset.Subset B X\n⊢ M.Basis B X","decl":"theorem Base.basis_of_subset (hX : X ⊆ M.E := by aesop_mat) (hB : M.Base B) (hBX : B ⊆ X) :\n    M.Basis B X := by\n  rw [basis_iff, and_iff_right hB.indep, and_iff_right hBX]\n  exact fun J hJ hBJ _ ↦ hB.eq_of_subset_indep hJ hBJ\n\n"}
{"name":"Matroid.exists_basis_disjoint_basis_of_subset","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nM : Matroid α\nX Y : Set α\nhXY : HasSubset.Subset X Y\nhY : autoParam (HasSubset.Subset Y M.E) _auto✝\n⊢ Exists fun I => Exists fun J => And (M.Basis I X) (And (M.Basis (Union.union I J) Y) (Disjoint X J))","decl":"theorem exists_basis_disjoint_basis_of_subset (M : Matroid α) {X Y : Set α} (hXY : X ⊆ Y)\n    (hY : Y ⊆ M.E := by aesop_mat) : ∃ I J, M.Basis I X ∧ M.Basis (I ∪ J) Y ∧ Disjoint X J := by\n  obtain ⟨I, I', hI, hI', hII'⟩ := M.exists_basis_subset_basis hXY\n  refine ⟨I, I' \\ I, hI, by rwa [union_diff_self, union_eq_self_of_subset_left hII'], ?_⟩\n  rw [disjoint_iff_forall_ne]\n  rintro e heX _ ⟨heI', heI⟩ rfl\n  exact heI <| hI.mem_of_insert_indep heX (hI'.indep.subset (insert_subset heI' hII'))\n\n"}
{"name":"Matroid.finite_setOf_matroid","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\n⊢ (setOf fun M => HasSubset.Subset M.E E).Finite","decl":"/-- For finite `E`, finitely many matroids have ground set contained in `E`. -/\ntheorem finite_setOf_matroid {E : Set α} (hE : E.Finite) : {M : Matroid α | M.E ⊆ E}.Finite := by\n  set f : Matroid α → Set α × (Set (Set α)) := fun M ↦ ⟨M.E, {B | M.Base B}⟩\n  have hf : f.Injective := by\n    refine fun M M' hMM' ↦ ?_\n    rw [Prod.mk.injEq, and_comm, Set.ext_iff, and_comm] at hMM'\n    exact ext_base hMM'.1 (fun B _ ↦ hMM'.2 B)\n  rw [← Set.finite_image_iff hf.injOn]\n  refine (hE.finite_subsets.prod hE.finite_subsets.finite_subsets).subset ?_\n  rintro _ ⟨M, hE : M.E ⊆ E, rfl⟩\n  simp only [Set.mem_prod, Set.mem_setOf_eq, Set.setOf_subset_setOf]\n  exact ⟨hE, fun B hB ↦ hB.subset_ground.trans hE⟩\n\n"}
{"name":"Matroid.finite_setOf_matroid'","module":"Mathlib.Data.Matroid.Basic","initialProofState":"α : Type u_1\nE : Set α\nhE : E.Finite\n⊢ (setOf fun M => Eq M.E E).Finite","decl":"/-- For finite `E`, finitely many matroids have ground set `E`. -/\ntheorem finite_setOf_matroid' {E : Set α} (hE : E.Finite) : {M : Matroid α | M.E = E}.Finite :=\n  (finite_setOf_matroid hE).subset (fun M ↦ by rintro rfl; exact rfl.subset)\n\n"}
