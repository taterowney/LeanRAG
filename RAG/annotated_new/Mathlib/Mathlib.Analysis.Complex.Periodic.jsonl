{"name":"Function.Periodic.abs_qParam","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nz : Complex\n‚ä¢ Eq (Complex.abs (Function.Periodic.qParam h z)) (Real.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (-2) Real.pi) z.im) h))","decl":"theorem abs_qParam (z : ‚ÑÇ) : abs (ùï¢ h z) = Real.exp (-2 * œÄ * im z / h) := by\n  simp only [qParam, abs_exp, div_ofReal_re, mul_re, re_ofNat, ofReal_re, im_ofNat, ofReal_im,\n    mul_zero, sub_zero, I_re, mul_im, zero_mul, add_zero, I_im, mul_one, sub_self, zero_sub,\n    neg_mul]\n\n"}
{"name":"Function.Periodic.im_invQParam","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nq : Complex\n‚ä¢ Eq (Function.Periodic.invQParam h q).im (HMul.hMul (HDiv.hDiv (Neg.neg h) (HMul.hMul 2 Real.pi)) (Real.log (Complex.abs q)))","decl":"theorem im_invQParam (q : ‚ÑÇ) : im (invQParam h q) = -h / (2 * œÄ) * Real.log (abs q) := by\n  simp only [invQParam, ‚Üê div_div, div_I, neg_mul, neg_im, mul_im, mul_re, div_ofReal_re,\n    div_ofNat_re, ofReal_re, I_re, mul_zero, div_ofReal_im, div_ofNat_im, ofReal_im, zero_div, I_im,\n    mul_one, sub_self, zero_mul, add_zero, log_re, zero_add, neg_div]\n\n"}
{"name":"Function.Periodic.qParam_right_inv","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nhh : Ne h 0\nq : Complex\nhq : Ne q 0\n‚ä¢ Eq (Function.Periodic.qParam h (Function.Periodic.invQParam h q)) q","decl":"theorem qParam_right_inv (hh : h ‚â† 0) {q : ‚ÑÇ} (hq : q ‚â† 0) : ùï¢ h (invQParam h q) = q := by\n  simp only [qParam, invQParam, ‚Üê mul_assoc, mul_div_cancel‚ÇÄ _ two_pi_I_ne_zero,\n    mul_div_cancel_left‚ÇÄ _ (ofReal_ne_zero.mpr hh), exp_log hq]\n\n"}
{"name":"Function.Periodic.qParam_left_inv_mod_period","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nhh : Ne h 0\nz : Complex\n‚ä¢ Exists fun m => Eq (Function.Periodic.invQParam h (Function.Periodic.qParam h z)) (HAdd.hAdd z (HMul.hMul ‚Üëm ‚Üëh))","decl":"theorem qParam_left_inv_mod_period (hh : h ‚â† 0) (z : ‚ÑÇ) :\n    ‚àÉ m : ‚Ñ§, invQParam h (ùï¢ h z) = z + m * h := by\n  dsimp only [qParam, invQParam]\n  obtain ‚ü®m, hm‚ü© := log_exp_exists (2 * ‚ÜëœÄ * I * z / ‚Üëh)\n  refine ‚ü®m, by rw [hm, mul_div_assoc, mul_comm (m : ‚ÑÇ), ‚Üê mul_add, ‚Üê mul_assoc,\n    div_mul_cancel‚ÇÄ _ two_pi_I_ne_zero, mul_add, mul_div_cancel‚ÇÄ _ (mod_cast hh), mul_comm]‚ü©\n\n"}
{"name":"Function.Periodic.abs_qParam_lt_iff","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nhh : LT.lt 0 h\nA : Real\nz : Complex\n‚ä¢ Iff (LT.lt (Complex.abs (Function.Periodic.qParam h z)) (Real.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (-2) Real.pi) A) h))) (LT.lt A z.im)","decl":"theorem abs_qParam_lt_iff (hh : 0 < h) (A : ‚Ñù) (z : ‚ÑÇ) :\n    abs (qParam h z) < Real.exp (-2 * œÄ * A / h) ‚Üî A < im z := by\n  rw [abs_qParam, Real.exp_lt_exp, div_lt_div_iff_of_pos_right hh, mul_lt_mul_left_of_neg]\n  simpa using Real.pi_pos\n\n"}
{"name":"Function.Periodic.qParam_tendsto","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nhh : LT.lt 0 h\n‚ä¢ Filter.Tendsto (Function.Periodic.qParam h) (Filter.comap Complex.im Filter.atTop) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"theorem qParam_tendsto (hh : 0 < h) : Tendsto (qParam h) I‚àû (ùìù[‚â†] 0) := by\n  refine tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ ?_\n    (.of_forall fun q ‚Ü¶ exp_ne_zero _)\n  rw [tendsto_zero_iff_norm_tendsto_zero]\n  simp only [norm_eq_abs, abs_qParam]\n  apply (tendsto_comap'_iff (m := fun y ‚Ü¶ Real.exp (-2 * œÄ * y / h)) (range_im ‚ñ∏ univ_mem)).mpr\n  refine Real.tendsto_exp_atBot.comp (.atBot_div_const hh (tendsto_id.const_mul_atTop_of_neg ?_))\n  simpa using Real.pi_pos\n\n"}
{"name":"Function.Periodic.invQParam_tendsto","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nhh : LT.lt 0 h\n‚ä¢ Filter.Tendsto (Function.Periodic.invQParam h) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (Filter.comap Complex.im Filter.atTop)","decl":"theorem invQParam_tendsto (hh : 0 < h) : Tendsto (invQParam h) (ùìù[‚â†] 0) I‚àû := by\n  simp only [tendsto_comap_iff, comp_def, im_invQParam]\n  apply Tendsto.const_mul_atBot_of_neg (div_neg_of_neg_of_pos (neg_lt_zero.mpr hh) (by positivity))\n  exact Real.tendsto_log_nhdsWithin_zero_right.comp tendsto_norm_nhdsNE_zero\n\n"}
{"name":"Function.Periodic.cuspFunction_eq_of_nonzero","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nq : Complex\nhq : Ne q 0\n‚ä¢ Eq (Function.Periodic.cuspFunction h f q) (f (Function.Periodic.invQParam h q))","decl":"theorem cuspFunction_eq_of_nonzero {q : ‚ÑÇ} (hq : q ‚â† 0) :\n    cuspFunction h f q = f (invQParam h q) :=\n  update_of_ne hq ..\n\n"}
{"name":"Function.Periodic.cuspFunction_zero_eq_limUnder_nhds_ne","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\n‚ä¢ Eq (Function.Periodic.cuspFunction h f 0) (limUnder (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))) (Function.Periodic.cuspFunction h f))","decl":"theorem cuspFunction_zero_eq_limUnder_nhds_ne :\n    cuspFunction h f 0 = limUnder (ùìù[‚â†] 0) (cuspFunction h f) := by\n  conv_lhs => simp only [cuspFunction, update_self]\n  refine congr_arg lim (Filter.map_congr <| eventuallyEq_nhdsWithin_of_eqOn fun r hr ‚Ü¶ ?_)\n  rw [cuspFunction, update_of_ne hr]\n\n"}
{"name":"Function.Periodic.eq_cuspFunction","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : Ne h 0\nhf : Function.Periodic f ‚Üëh\nz : Complex\n‚ä¢ Eq (Function.Periodic.cuspFunction h f (Function.Periodic.qParam h z)) (f z)","decl":"theorem eq_cuspFunction (hh : h ‚â† 0) (hf : Periodic f h) (z : ‚ÑÇ) :\n    (cuspFunction h f) (ùï¢ h z) = f z := by\n  have : (cuspFunction h f) (ùï¢ h z) = f (invQParam h (ùï¢ h z)) := by\n    rw [cuspFunction, update_of_ne, comp_apply]\n    exact exp_ne_zero _\n  obtain ‚ü®m, hm‚ü© := qParam_left_inv_mod_period hh z\n  simpa only [this, hm] using hf.int_mul m z\n\n"}
{"name":"Function.Periodic.differentiableAt_cuspFunction","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : Ne h 0\nhf : Function.Periodic f ‚Üëh\nz : Complex\nhol_z : DifferentiableAt Complex f z\n‚ä¢ DifferentiableAt Complex (Function.Periodic.cuspFunction h f) (Function.Periodic.qParam h z)","decl":"/--\nKey technical lemma: the function `cuspFunction h f` is differentiable at the images of\ndifferentiability points of `f` (even if `invQParam` is not differentiable there).\n-/\ntheorem differentiableAt_cuspFunction (hh : h ‚â† 0) (hf : Periodic f h)\n    {z : ‚ÑÇ} (hol_z : DifferentiableAt ‚ÑÇ f z) :\n    DifferentiableAt ‚ÑÇ (cuspFunction h f) (ùï¢ h z) := by\n  let q := ùï¢ h z\n  have qdiff : HasStrictDerivAt (ùï¢ h) (q * (2 * œÄ * I / h)) z := by\n    simpa only [id_eq, mul_one] using (((hasStrictDerivAt_id z).const_mul _).div_const _).cexp\n  -- Now show that the q-map has a differentiable local inverse at z, say L : ‚ÑÇ ‚Üí ‚ÑÇ with L q = z.\n  have diff_ne : q * (2 * œÄ * I / h) ‚â† 0 :=\n    mul_ne_zero (exp_ne_zero _) (div_ne_zero two_pi_I_ne_zero <| mod_cast hh)\n  let L := (qdiff.localInverse (ùï¢ h) _ z) diff_ne\n  have diff_L : DifferentiableAt ‚ÑÇ L q := (qdiff.to_localInverse diff_ne).differentiableAt\n  have hL : ùï¢ h ‚àò L =·∂†[ùìù q] (id : ‚ÑÇ ‚Üí ‚ÑÇ) :=\n    (qdiff.hasStrictFDerivAt_equiv diff_ne).eventually_right_inverse\n  -- Thus, if F = cuspFunction h f, we have F q' = f (L q') for q' near q.\n  -- Since L is differentiable at q, and f is diff'ble at L q [ = z], we conclude\n  -- that F is differentiable at q.\n  have hF := hL.fun_comp (cuspFunction h f)\n  have : cuspFunction h f ‚àò ùï¢ h ‚àò L = f ‚àò L := funext fun z ‚Ü¶ eq_cuspFunction hh hf (L z)\n  rw [this] at hF\n  rw [‚Üê EventuallyEq.eq_of_nhds (qdiff.hasStrictFDerivAt_equiv diff_ne).eventually_left_inverse]\n    at hol_z\n  exact (hol_z.comp q diff_L).congr_of_eventuallyEq hF.symm\n\n"}
{"name":"Function.Periodic.eventually_differentiableAt_cuspFunction_nhds_ne_zero","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : LT.lt 0 h\nhf : Function.Periodic f ‚Üëh\nh_hol : Filter.Eventually (fun z => DifferentiableAt Complex f z) (Filter.comap Complex.im Filter.atTop)\n‚ä¢ Filter.Eventually (fun q => DifferentiableAt Complex (Function.Periodic.cuspFunction h f) q) (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0)))","decl":"theorem eventually_differentiableAt_cuspFunction_nhds_ne_zero (hh : 0 < h) (hf : Periodic f h)\n    (h_hol : ‚àÄ·∂† z in I‚àû, DifferentiableAt ‚ÑÇ f z) :\n    ‚àÄ·∂† q in ùìù[‚â†] 0, DifferentiableAt ‚ÑÇ (cuspFunction h f) q := by\n  refine ((invQParam_tendsto hh).eventually h_hol).mp ?_\n  refine eventually_nhdsWithin_of_forall (fun q hq h_diff ‚Ü¶ ?_)\n  rw [‚Üê qParam_right_inv hh.ne' hq]\n  exact differentiableAt_cuspFunction hh.ne' hf h_diff\n\n"}
{"name":"Function.Periodic.boundedAtFilter_cuspFunction","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : LT.lt 0 h\nh_bd : (Filter.comap Complex.im Filter.atTop).BoundedAtFilter f\n‚ä¢ (nhdsWithin 0 (HasCompl.compl (Singleton.singleton 0))).BoundedAtFilter (Function.Periodic.cuspFunction h f)","decl":"theorem boundedAtFilter_cuspFunction (hh : 0 < h) (h_bd : BoundedAtFilter I‚àû f) :\n    BoundedAtFilter (ùìù[‚â†] 0) (cuspFunction h f) := by\n  refine (h_bd.comp_tendsto <| invQParam_tendsto hh).congr' ?_ (by rfl)\n  refine eventually_nhdsWithin_of_forall fun q hq ‚Ü¶ ?_\n  rw [cuspFunction_eq_of_nonzero _ _ hq, comp_def]\n\n"}
{"name":"Function.Periodic.cuspFunction_zero_of_zero_at_inf","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : LT.lt 0 h\nh_zer : (Filter.comap Complex.im Filter.atTop).ZeroAtFilter f\n‚ä¢ Eq (Function.Periodic.cuspFunction h f 0) 0","decl":"theorem cuspFunction_zero_of_zero_at_inf (hh : 0 < h) (h_zer : ZeroAtFilter I‚àû f) :\n    cuspFunction h f 0 = 0 := by\n  simpa only [cuspFunction, update_self] using (h_zer.comp (invQParam_tendsto hh)).limUnder_eq\n\n"}
{"name":"Function.Periodic.differentiableAt_cuspFunction_zero","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : LT.lt 0 h\nhf : Function.Periodic f ‚Üëh\nh_hol : Filter.Eventually (fun z => DifferentiableAt Complex f z) (Filter.comap Complex.im Filter.atTop)\nh_bd : (Filter.comap Complex.im Filter.atTop).BoundedAtFilter f\n‚ä¢ DifferentiableAt Complex (Function.Periodic.cuspFunction h f) 0","decl":"theorem differentiableAt_cuspFunction_zero (hh : 0 < h) (hf : Periodic f h)\n    (h_hol : ‚àÄ·∂† z in I‚àû, DifferentiableAt ‚ÑÇ f z) (h_bd : BoundedAtFilter I‚àû f) :\n    DifferentiableAt ‚ÑÇ (cuspFunction h f) 0 := by\n  obtain ‚ü®c, t‚ü© := (boundedAtFilter_cuspFunction hh h_bd).bound\n  replace t := (eventually_differentiableAt_cuspFunction_nhds_ne_zero hh hf h_hol).and t\n  simp only [norm_one, Pi.one_apply, mul_one] at t\n  obtain ‚ü®S, hS1, hS2, hS3‚ü© := eventually_nhds_iff.mp (eventually_nhdsWithin_iff.mp t)\n  have h_diff : DifferentiableOn ‚ÑÇ (cuspFunction h f) (S \\ {0}) :=\n    fun x hx ‚Ü¶ (hS1 x hx.1 hx.2).1.differentiableWithinAt\n  have hF_bd : BddAbove (norm ‚àò cuspFunction h f '' (S \\ {0})) := by\n    use c\n    simp only [mem_upperBounds, Set.mem_image, Set.mem_diff, forall_exists_index, and_imp]\n    intro y q hq hq2 hy\n    simpa only [‚Üê hy, norm_one, mul_one] using (hS1 q hq hq2).2\n  have := differentiableOn_update_limUnder_of_bddAbove (IsOpen.mem_nhds hS2 hS3) h_diff hF_bd\n  rw [‚Üê cuspFunction_zero_eq_limUnder_nhds_ne, update_eq_self] at this\n  exact this.differentiableAt (IsOpen.mem_nhds hS2 hS3)\n\n"}
{"name":"Function.Periodic.tendsto_at_I_inf","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : LT.lt 0 h\nhf : Function.Periodic f ‚Üëh\nh_hol : Filter.Eventually (fun z => DifferentiableAt Complex f z) (Filter.comap Complex.im Filter.atTop)\nh_bd : (Filter.comap Complex.im Filter.atTop).BoundedAtFilter f\n‚ä¢ Filter.Tendsto f (Filter.comap Complex.im Filter.atTop) (nhds (Function.Periodic.cuspFunction h f 0))","decl":"/--\nIf `f` is periodic, and holomorphic and bounded near `I‚àû`, then it tends to a limit at `I‚àû`,\nand this limit is the value of its cusp function at 0.\n-/\ntheorem tendsto_at_I_inf (hh : 0 < h) (hf : Periodic f h)\n    (h_hol : ‚àÄ·∂† z in I‚àû, DifferentiableAt ‚ÑÇ f z) (h_bd : BoundedAtFilter I‚àû f) :\n    Tendsto f I‚àû (ùìù <| cuspFunction h f 0) := by\n  suffices Tendsto (cuspFunction h f) (ùìù[‚â†] 0) (ùìù <| cuspFunction h f 0) by\n    simpa only [Function.comp_def, eq_cuspFunction hh.ne' hf] using this.comp (qParam_tendsto hh)\n  exact tendsto_nhdsWithin_of_tendsto_nhds\n    (differentiableAt_cuspFunction_zero hh hf h_hol h_bd).continuousAt.tendsto\n\n"}
{"name":"Function.Periodic.exp_decay_of_zero_at_inf","module":"Mathlib.Analysis.Complex.Periodic","initialProofState":"h : Real\nf : Complex ‚Üí Complex\nhh : LT.lt 0 h\nhf : Function.Periodic f ‚Üëh\nh_hol : Filter.Eventually (fun z => DifferentiableAt Complex f z) (Filter.comap Complex.im Filter.atTop)\nh_zer : (Filter.comap Complex.im Filter.atTop).ZeroAtFilter f\n‚ä¢ Asymptotics.IsBigO (Filter.comap Complex.im Filter.atTop) f fun z => Real.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (-2) Real.pi) z.im) h)","decl":"/--\nIf `f` is periodic, holomorphic near `I‚àû`, and tends to zero at `I‚àû`, then in fact it tends to zero\nexponentially fast.\n-/\ntheorem exp_decay_of_zero_at_inf (hh : 0 < h) (hf : Periodic f h)\n    (h_hol : ‚àÄ·∂† z in I‚àû, DifferentiableAt ‚ÑÇ f z) (h_zer : ZeroAtFilter I‚àû f) :\n    f =O[I‚àû] fun z ‚Ü¶ Real.exp (-2 * œÄ * im z / h) := by\n  suffices cuspFunction h f =O[_] id by\n    simpa only [comp_def, eq_cuspFunction hh.ne' hf, id_eq, norm_eq_abs, abs_qParam]\n      using (this.comp_tendsto (qParam_tendsto hh)).norm_right\n  simpa only [cuspFunction_zero_of_zero_at_inf hh h_zer, sub_zero] using\n    (differentiableAt_cuspFunction_zero hh hf h_hol h_zer.boundedAtFilter).isBigO_sub.mono\n      nhdsWithin_le_nhds\n\n"}
