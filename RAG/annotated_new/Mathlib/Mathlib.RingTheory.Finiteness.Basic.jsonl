{"name":"Submodule.fg_bot","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Bot.bot.FG","decl":"theorem fg_bot : (⊥ : Submodule R M).FG :=\n  ⟨∅, by rw [Finset.coe_empty, span_empty]⟩\n\n"}
{"name":"Submodule.fg_span","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Set M\nhs : s.Finite\n⊢ (Submodule.span R s).FG","decl":"theorem fg_span {s : Set M} (hs : s.Finite) : FG (span R s) :=\n  ⟨hs.toFinset, by rw [hs.coe_toFinset]⟩\n\n"}
{"name":"Submodule.fg_span_singleton","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ (Submodule.span R (Singleton.singleton x)).FG","decl":"theorem fg_span_singleton (x : M) : FG (R ∙ x) :=\n  fg_span (finite_singleton x)\n\n"}
{"name":"Submodule.FG.sup","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN₁ N₂ : Submodule R M\nhN₁ : N₁.FG\nhN₂ : N₂.FG\n⊢ (Max.max N₁ N₂).FG","decl":"theorem FG.sup {N₁ N₂ : Submodule R M} (hN₁ : N₁.FG) (hN₂ : N₂.FG) : (N₁ ⊔ N₂).FG :=\n  let ⟨t₁, ht₁⟩ := fg_def.1 hN₁\n  let ⟨t₂, ht₂⟩ := fg_def.1 hN₂\n  fg_def.2 ⟨t₁ ∪ t₂, ht₁.1.union ht₂.1, by rw [span_union, ht₁.2, ht₂.2]⟩\n\n"}
{"name":"Submodule.fg_finset_sup","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_3\ns : Finset ι\nN : ι → Submodule R M\nh : ∀ (i : ι), Membership.mem s i → (N i).FG\n⊢ (s.sup N).FG","decl":"theorem fg_finset_sup {ι : Type*} (s : Finset ι) (N : ι → Submodule R M) (h : ∀ i ∈ s, (N i).FG) :\n    (s.sup N).FG :=\n  Finset.sup_induction fg_bot (fun _ ha _ hb => ha.sup hb) h\n\n"}
{"name":"Submodule.fg_biSup","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nι : Type u_3\ns : Finset ι\nN : ι → Submodule R M\nh : ∀ (i : ι), Membership.mem s i → (N i).FG\n⊢ (iSup fun i => iSup fun h => N i).FG","decl":"theorem fg_biSup {ι : Type*} (s : Finset ι) (N : ι → Submodule R M) (h : ∀ i ∈ s, (N i).FG) :\n    (⨆ i ∈ s, N i).FG := by simpa only [Finset.sup_eq_iSup] using fg_finset_sup s N h\n\n"}
{"name":"Submodule.fg_iSup","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nι : Sort u_3\ninst✝ : Finite ι\nN : ι → Submodule R M\nh : ∀ (i : ι), (N i).FG\n⊢ (iSup N).FG","decl":"theorem fg_iSup {ι : Sort*} [Finite ι] (N : ι → Submodule R M) (h : ∀ i, (N i).FG) :\n    (iSup N).FG := by\n  cases nonempty_fintype (PLift ι)\n  simpa [iSup_plift_down] using fg_biSup Finset.univ (N ∘ PLift.down) fun i _ => h i.down\n\n"}
{"name":"Submodule.fg_pi","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nι : Type u_4\nM : ι → Type u_5\ninst✝² : Finite ι\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\np : (i : ι) → Submodule R (M i)\nhsb : ∀ (i : ι), (p i).FG\n⊢ (Submodule.pi Set.univ p).FG","decl":"theorem fg_pi {ι : Type*} {M : ι → Type*} [Finite ι] [∀ i, AddCommMonoid (M i)]\n    [∀ i, Module R (M i)] {p : ∀ i, Submodule R (M i)} (hsb : ∀ i, (p i).FG) :\n    (Submodule.pi Set.univ p).FG := by\n  classical\n    simp_rw [fg_def] at hsb ⊢\n    choose t htf hts using hsb\n    refine\n      ⟨⋃ i, (LinearMap.single R _ i) '' t i, Set.finite_iUnion fun i => (htf i).image _, ?_⟩\n    -- Note: https://github.com/leanprover-community/mathlib4/pull/8386 changed `span_image` into `span_image _`\n    simp_rw [span_iUnion, span_image _, hts, Submodule.iSup_map_single]\n\n"}
{"name":"Submodule.FG.map","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nP : Type u_3\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\nN : Submodule R M\nhs : N.FG\n⊢ (Submodule.map f N).FG","decl":"theorem FG.map {N : Submodule R M} (hs : N.FG) : (N.map f).FG :=\n  let ⟨t, ht⟩ := fg_def.1 hs\n  fg_def.2 ⟨f '' t, ht.1.image _, by rw [span_image, ht.2]⟩\n\n"}
{"name":"Submodule.fg_of_fg_map_injective","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nP : Type u_3\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\nhf : Function.Injective ⇑f\nN : Submodule R M\nhfn : (Submodule.map f N).FG\n⊢ N.FG","decl":"theorem fg_of_fg_map_injective (f : M →ₗ[R] P) (hf : Function.Injective f) {N : Submodule R M}\n    (hfn : (N.map f).FG) : N.FG :=\n  let ⟨t, ht⟩ := hfn\n  ⟨t.preimage f fun _ _ _ _ h => hf h,\n    Submodule.map_injective_of_injective hf <| by\n      rw [map_span, Finset.coe_preimage, Set.image_preimage_eq_inter_range,\n        Set.inter_eq_self_of_subset_left, ht]\n      rw [← LinearMap.range_coe, ← span_le, ht, ← map_top]\n      exact map_mono le_top⟩\n\n"}
{"name":"Submodule.fg_of_fg_map","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_4\nM : Type u_5\nP : Type u_6\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup P\ninst✝ : Module R P\nf : LinearMap (RingHom.id R) M P\nhf : Eq (LinearMap.ker f) Bot.bot\nN : Submodule R M\nhfn : (Submodule.map f N).FG\n⊢ N.FG","decl":"theorem fg_of_fg_map {R M P : Type*} [Ring R] [AddCommGroup M] [Module R M] [AddCommGroup P]\n    [Module R P] (f : M →ₗ[R] P)\n    (hf : LinearMap.ker f = ⊥) {N : Submodule R M}\n    (hfn : (N.map f).FG) : N.FG :=\n  fg_of_fg_map_injective f (LinearMap.ker_eq_bot.1 hf) hfn\n\n"}
{"name":"Submodule.fg_top","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff Top.top.FG N.FG","decl":"theorem fg_top (N : Submodule R M) : (⊤ : Submodule R N).FG ↔ N.FG :=\n  ⟨fun h => N.range_subtype ▸ map_top N.subtype ▸ h.map _, fun h =>\n    fg_of_fg_map_injective N.subtype Subtype.val_injective <| by rwa [map_top, range_subtype]⟩\n\n"}
{"name":"Submodule.fg_of_linearEquiv","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nP : Type u_3\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\ne : LinearEquiv (RingHom.id R) M P\nh : Top.top.FG\n⊢ Top.top.FG","decl":"theorem fg_of_linearEquiv (e : M ≃ₗ[R] P) (h : (⊤ : Submodule R P).FG) : (⊤ : Submodule R M).FG :=\n  e.symm.range ▸ map_top (e.symm : P →ₗ[R] M) ▸ h.map _\n\n"}
{"name":"Submodule.fg_induction","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_4\nM : Type u_5\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nP : Submodule R M → Prop\nh₁ : ∀ (x : M), P (Submodule.span R (Singleton.singleton x))\nh₂ : ∀ (M₁ M₂ : Submodule R M), P M₁ → P M₂ → P (Max.max M₁ M₂)\nN : Submodule R M\nhN : N.FG\n⊢ P N","decl":"theorem fg_induction (R M : Type*) [Semiring R] [AddCommMonoid M] [Module R M]\n    (P : Submodule R M → Prop) (h₁ : ∀ x, P (Submodule.span R {x}))\n    (h₂ : ∀ M₁ M₂, P M₁ → P M₂ → P (M₁ ⊔ M₂)) (N : Submodule R M) (hN : N.FG) : P N := by\n  classical\n    obtain ⟨s, rfl⟩ := hN\n    induction s using Finset.induction with\n    | empty =>\n      rw [Finset.coe_empty, Submodule.span_empty, ← Submodule.span_zero_singleton]\n      exact h₁ _\n    | insert _ ih =>\n      rw [Finset.coe_insert, Submodule.span_insert]\n      exact h₂ _ _ (h₁ _) ih\n\n"}
{"name":"Submodule.fg_restrictScalars","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_4\nS : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : Algebra R S\ninst✝³ : AddCommGroup M\ninst✝² : Module S M\ninst✝¹ : Module R M\ninst✝ : IsScalarTower R S M\nN : Submodule S M\nhfin : N.FG\nh : Function.Surjective ⇑(algebraMap R S)\n⊢ (Submodule.restrictScalars R N).FG","decl":"theorem fg_restrictScalars {R S M : Type*} [CommSemiring R] [Semiring S] [Algebra R S]\n    [AddCommGroup M] [Module S M] [Module R M] [IsScalarTower R S M] (N : Submodule S M)\n    (hfin : N.FG) (h : Function.Surjective (algebraMap R S)) :\n    (Submodule.restrictScalars R N).FG := by\n  obtain ⟨X, rfl⟩ := hfin\n  use X\n  exact (Submodule.restrictScalars_span R S h (X : Set M)).symm\n\n"}
{"name":"Submodule.FG.of_restrictScalars","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_4\nA : Type u_5\nM : Type u_6\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Algebra R A\ninst✝² : Module R M\ninst✝¹ : Module A M\ninst✝ : IsScalarTower R A M\nS : Submodule A M\nhS : (Submodule.restrictScalars R S).FG\n⊢ S.FG","decl":"lemma FG.of_restrictScalars (R) {A M} [CommSemiring R] [Semiring A] [AddCommMonoid M]\n    [Algebra R A] [Module R M] [Module A M] [IsScalarTower R A M] (S : Submodule A M)\n    (hS : (S.restrictScalars R).FG) : S.FG := by\n  obtain ⟨s, e⟩ := hS\n  refine ⟨s, Submodule.restrictScalars_injective R _ _ (le_antisymm ?_ ?_)⟩\n  · show Submodule.span A s ≤ S\n    have := Submodule.span_le.mp e.le\n    rwa [Submodule.span_le]\n  · rw [← e]\n    exact Submodule.span_le_restrictScalars _ _ _\n\n"}
{"name":"Submodule.FG.stabilizes_of_iSup_eq","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nM' : Submodule R M\nhM' : M'.FG\nN : OrderHom Nat (Submodule R M)\nH : Eq (iSup ⇑N) M'\n⊢ Exists fun n => Eq M' (N n)","decl":"theorem FG.stabilizes_of_iSup_eq {M' : Submodule R M} (hM' : M'.FG) (N : ℕ →o Submodule R M)\n    (H : iSup N = M') : ∃ n, M' = N n := by\n  obtain ⟨S, hS⟩ := hM'\n  have : ∀ s : S, ∃ n, (s : M) ∈ N n := fun s =>\n    (Submodule.mem_iSup_of_chain N s).mp\n      (by\n        rw [H, ← hS]\n        exact Submodule.subset_span s.2)\n  choose f hf using this\n  use S.attach.sup f\n  apply le_antisymm\n  · conv_lhs => rw [← hS]\n    rw [Submodule.span_le]\n    intro s hs\n    exact N.2 (Finset.le_sup <| S.mem_attach ⟨s, hs⟩) (hf _)\n  · rw [← H]\n    exact le_iSup _ _\n\n"}
{"name":"Submodule.fg_iff_compact","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Submodule R M\n⊢ Iff s.FG (CompleteLattice.IsCompactElement s)","decl":"/-- Finitely generated submodules are precisely compact elements in the submodule lattice. -/\ntheorem fg_iff_compact (s : Submodule R M) : s.FG ↔ CompleteLattice.IsCompactElement s := by\n  classical\n    -- Introduce shorthand for span of an element\n    let sp : M → Submodule R M := fun a => span R {a}\n    -- Trivial rewrite lemma; a small hack since simp (only) & rw can't accomplish this smoothly.\n    have supr_rw : ∀ t : Finset M, ⨆ x ∈ t, sp x = ⨆ x ∈ (↑t : Set M), sp x := fun t => by rfl\n    constructor\n    · rintro ⟨t, rfl⟩\n      rw [span_eq_iSup_of_singleton_spans, ← supr_rw, ← Finset.sup_eq_iSup t sp]\n      apply CompleteLattice.isCompactElement_finsetSup\n      exact fun n _ => singleton_span_isCompactElement n\n    · intro h\n      -- s is the Sup of the spans of its elements.\n      have sSup' : s = sSup (sp '' ↑s) := by\n        rw [sSup_eq_iSup, iSup_image, ← span_eq_iSup_of_singleton_spans, eq_comm, span_eq]\n      -- by h, s is then below (and equal to) the sup of the spans of finitely many elements.\n      obtain ⟨u, ⟨huspan, husup⟩⟩ := h (sp '' ↑s) (le_of_eq sSup')\n      have ssup : s = u.sup id := by\n        suffices u.sup id ≤ s from le_antisymm husup this\n        rw [sSup', Finset.sup_id_eq_sSup]\n        exact sSup_le_sSup huspan\n      obtain ⟨t, -, rfl⟩ := Finset.subset_set_image_iff.mp huspan\n      rw [Finset.sup_image, Function.id_comp, Finset.sup_eq_iSup, supr_rw, ←\n        span_eq_iSup_of_singleton_spans, eq_comm] at ssup\n      exact ⟨t, ssup⟩\n\n"}
{"name":"Module.Finite.of_finite","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite M\n⊢ Module.Finite R M","decl":"instance (priority := 100) of_finite [Finite M] : Module.Finite R M := by\n  cases nonempty_fintype M\n  exact ⟨⟨Finset.univ, by rw [Finset.coe_univ]; exact Submodule.span_univ⟩⟩\n\n"}
{"name":"Module.Finite.of_surjective","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\nhM : Module.Finite R M\nf : LinearMap (RingHom.id R) M N\nhf : Function.Surjective ⇑f\n⊢ Module.Finite R N","decl":"theorem of_surjective [hM : Module.Finite R M] (f : M →ₗ[R] N) (hf : Surjective f) :\n    Module.Finite R N :=\n  ⟨by\n    rw [← LinearMap.range_eq_top.2 hf, ← Submodule.map_top]\n    exact hM.1.map f⟩\n\n"}
{"name":"Module.Finite.quotient","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_6\nA : Type u_7\nM : Type u_8\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Ring A\ninst✝⁴ : Module A M\ninst✝³ : Module R M\ninst✝² : SMul R A\ninst✝¹ : IsScalarTower R A M\ninst✝ : Module.Finite R M\nN : Submodule A M\n⊢ Module.Finite R (HasQuotient.Quotient M N)","decl":"instance quotient (R) {A M} [Semiring R] [AddCommGroup M] [Ring A] [Module A M] [Module R M]\n    [SMul R A] [IsScalarTower R A M] [Module.Finite R M]\n    (N : Submodule A M) : Module.Finite R (M ⧸ N) :=\n  Module.Finite.of_surjective (N.mkQ.restrictScalars R) N.mkQ_surjective\n\n"}
{"name":"Module.Finite.range","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid N\ninst✝³ : Module R N\nF : Type u_6\ninst✝² : FunLike F M N\ninst✝¹ : SemilinearMapClass F (RingHom.id R) M N\ninst✝ : Module.Finite R M\nf : F\n⊢ Module.Finite R (Subtype fun x => Membership.mem (LinearMap.range f) x)","decl":"/-- The range of a linear map from a finite module is finite. -/\ninstance range {F : Type*} [FunLike F M N] [SemilinearMapClass F (RingHom.id R) M N]\n    [Module.Finite R M] (f : F) : Module.Finite R (LinearMap.range f) :=\n  of_surjective (SemilinearMapClass.semilinearMap f).rangeRestrict\n    fun ⟨_, y, hy⟩ => ⟨y, Subtype.ext hy⟩\n\n"}
{"name":"Module.Finite.map","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\np : Submodule R M\ninst✝ : Module.Finite R (Subtype fun x => Membership.mem p x)\nf : LinearMap (RingHom.id R) M N\n⊢ Module.Finite R (Subtype fun x => Membership.mem (Submodule.map f p) x)","decl":"/-- Pushforwards of finite submodules are finite. -/\ninstance map (p : Submodule R M) [Module.Finite R p] (f : M →ₗ[R] N) : Module.Finite R (p.map f) :=\n  of_surjective (f.restrict fun _ => Submodule.mem_map_of_mem) fun ⟨_, _, hy, hy'⟩ =>\n    ⟨⟨_, hy⟩, Subtype.ext hy'⟩\n\n"}
{"name":"Module.Finite.pi","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\ninst✝³ : Semiring R\nι : Type u_6\nM : ι → Type u_7\ninst✝² : Finite ι\ninst✝¹ : (i : ι) → AddCommMonoid (M i)\ninst✝ : (i : ι) → Module R (M i)\nh : ∀ (i : ι), Module.Finite R (M i)\n⊢ Module.Finite R ((i : ι) → M i)","decl":"instance pi {ι : Type*} {M : ι → Type*} [_root_.Finite ι] [∀ i, AddCommMonoid (M i)]\n    [∀ i, Module R (M i)] [h : ∀ i, Module.Finite R (M i)] : Module.Finite R (∀ i, M i) :=\n  ⟨by\n    rw [← Submodule.pi_top]\n    exact Submodule.fg_pi fun i => (h i).1⟩\n\n"}
{"name":"Module.Finite.self","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\ninst✝ : Semiring R\n⊢ Module.Finite R R","decl":"instance self : Module.Finite R R :=\n  ⟨⟨{1}, by simpa only [Finset.coe_singleton] using Ideal.span_singleton_one⟩⟩\n\n"}
{"name":"Module.Finite.of_restrictScalars_finite","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_6\nA : Type u_7\nM : Type u_8\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring A\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Module A M\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R A M\nhM : Module.Finite R M\n⊢ Module.Finite A M","decl":"theorem of_restrictScalars_finite (R A M : Type*) [CommSemiring R] [Semiring A] [AddCommMonoid M]\n    [Module R M] [Module A M] [Algebra R A] [IsScalarTower R A M] [hM : Module.Finite R M] :\n    Module.Finite A M := by\n  rw [finite_def, Submodule.fg_def] at hM ⊢\n  obtain ⟨S, hSfin, hSgen⟩ := hM\n  refine ⟨S, hSfin, eq_top_iff.2 ?_⟩\n  have := Submodule.span_le_restrictScalars R A S\n  rw [hSgen] at this\n  exact this\n\n"}
{"name":"Module.Finite.equiv","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid N\ninst✝¹ : Module R N\ninst✝ : Module.Finite R M\ne : LinearEquiv (RingHom.id R) M N\n⊢ Module.Finite R N","decl":"theorem equiv [Module.Finite R M] (e : M ≃ₗ[R] N) : Module.Finite R N :=\n  of_surjective (e : M →ₗ[R] N) e.surjective\n\n"}
{"name":"Module.Finite.equiv_iff","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\nN : Type u_5\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\n⊢ Iff (Module.Finite R M) (Module.Finite R N)","decl":"theorem equiv_iff (e : M ≃ₗ[R] N) : Module.Finite R M ↔ Module.Finite R N :=\n  ⟨fun _ ↦ equiv e, fun _ ↦ equiv e.symm⟩\n\n"}
{"name":"Module.Finite.ulift","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ Module.Finite R (ULift.{u_6, u_4} M)","decl":"instance ulift [Module.Finite R M] : Module.Finite R (ULift M) := equiv ULift.moduleEquiv.symm\n\n"}
{"name":"Module.Finite.iff_fg","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nN : Submodule R M\n⊢ Iff (Module.Finite R (Subtype fun x => Membership.mem N x)) N.FG","decl":"theorem iff_fg {N : Submodule R M} : Module.Finite R N ↔ N.FG := Module.finite_def.trans N.fg_top\n\n"}
{"name":"Module.Finite.bot","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Module.Finite R (Subtype fun x => Membership.mem Bot.bot x)","decl":"instance bot : Module.Finite R (⊥ : Submodule R M) := iff_fg.mpr fg_bot\n\n"}
{"name":"Module.Finite.top","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Module.Finite R M\n⊢ Module.Finite R (Subtype fun x => Membership.mem Top.top x)","decl":"instance top [Module.Finite R M] : Module.Finite R (⊤ : Submodule R M) := iff_fg.mpr fg_top\n\n"}
{"name":"Module.Finite.span_of_finite","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nA : Set M\nhA : A.Finite\n⊢ Module.Finite R (Subtype fun x => Membership.mem (Submodule.span R A) x)","decl":"/-- The submodule generated by a finite set is `R`-finite. -/\ntheorem span_of_finite {A : Set M} (hA : Set.Finite A) :\n    Module.Finite R (Submodule.span R A) :=\n  ⟨(Submodule.fg_top _).mpr ⟨hA.toFinset, hA.coe_toFinset.symm ▸ rfl⟩⟩\n\n"}
{"name":"Module.Finite.span_singleton","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nx : M\n⊢ Module.Finite R (Subtype fun x_1 => Membership.mem (Submodule.span R (Singleton.singleton x)) x_1)","decl":"/-- The submodule generated by a single element is `R`-finite. -/\ninstance span_singleton (x : M) : Module.Finite R (R ∙ x) :=\n  Module.Finite.span_of_finite R <| Set.finite_singleton _\n\n"}
{"name":"Module.Finite.span_finset","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nM : Type u_4\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ns : Finset M\n⊢ Module.Finite R (Subtype fun x => Membership.mem (Submodule.span R ↑s) x)","decl":"/-- The submodule generated by a finset is `R`-finite. -/\ninstance span_finset (s : Finset M) : Module.Finite R (span R (s : Set M)) :=\n  ⟨(Submodule.fg_top _).mpr ⟨s, rfl⟩⟩\n\n"}
{"name":"Module.Finite.trans","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_6\nA : Type u_7\nM : Type u_8\ninst✝⁸ : Semiring R\ninst✝⁷ : Semiring A\ninst✝⁶ : Module R A\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : Module A M\ninst✝² : IsScalarTower R A M\ninst✝¹ : Module.Finite R A\ninst✝ : Module.Finite A M\n⊢ Module.Finite R M","decl":"theorem trans {R : Type*} (A M : Type*) [Semiring R] [Semiring A] [Module R A]\n    [AddCommMonoid M] [Module R M] [Module A M] [IsScalarTower R A M] :\n    ∀ [Module.Finite R A] [Module.Finite A M], Module.Finite R M\n  | ⟨⟨s, hs⟩⟩, ⟨⟨t, ht⟩⟩ =>\n    ⟨Submodule.fg_def.2\n        ⟨Set.image2 (· • ·) (↑s : Set A) (↑t : Set M),\n          Set.Finite.image2 _ s.finite_toSet t.finite_toSet, by\n          erw [Set.image2_smul, Submodule.span_smul_of_span_eq_top hs (↑t : Set M), ht,\n            Submodule.restrictScalars_top]⟩⟩\n\n"}
{"name":"Module.Finite.of_equiv_equiv","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"A₁ : Type u_6\nB₁ : Type u_7\nA₂ : Type u_8\nB₂ : Type u_9\ninst✝⁶ : CommRing A₁\ninst✝⁵ : CommRing B₁\ninst✝⁴ : CommRing A₂\ninst✝³ : CommRing B₂\ninst✝² : Algebra A₁ B₁\ninst✝¹ : Algebra A₂ B₂\ne₁ : RingEquiv A₁ A₂\ne₂ : RingEquiv B₁ B₂\nhe : Eq ((algebraMap A₂ B₂).comp ↑e₁) ((↑e₂).comp (algebraMap A₁ B₁))\ninst✝ : Module.Finite A₁ B₁\n⊢ Module.Finite A₂ B₂","decl":"lemma of_equiv_equiv {A₁ B₁ A₂ B₂ : Type*} [CommRing A₁] [CommRing B₁]\n    [CommRing A₂] [CommRing B₂] [Algebra A₁ B₁] [Algebra A₂ B₂] (e₁ : A₁ ≃+* A₂) (e₂ : B₁ ≃+* B₂)\n    (he : RingHom.comp (algebraMap A₂ B₂) ↑e₁ = RingHom.comp ↑e₂ (algebraMap A₁ B₁))\n    [Module.Finite A₁ B₁] : Module.Finite A₂ B₂ := by\n  letI := e₁.toRingHom.toAlgebra\n  letI := ((algebraMap A₁ B₁).comp e₁.symm.toRingHom).toAlgebra\n  haveI : IsScalarTower A₁ A₂ B₁ := IsScalarTower.of_algebraMap_eq\n    (fun x ↦ by simp [RingHom.algebraMap_toAlgebra])\n  let e : B₁ ≃ₐ[A₂] B₂ :=\n    { e₂ with\n      commutes' := fun r ↦ by\n        simpa [RingHom.algebraMap_toAlgebra] using DFunLike.congr_fun he.symm (e₁.symm r) }\n  haveI := Module.Finite.of_restrictScalars_finite A₁ A₂ B₁\n  exact Module.Finite.equiv e.toLinearEquiv\n\n"}
{"name":"Submodule.finite_sup","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nV : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup V\ninst✝ : Module R V\nS₁ S₂ : Submodule R V\nh₁ : Module.Finite R (Subtype fun x => Membership.mem S₁ x)\nh₂ : Module.Finite R (Subtype fun x => Membership.mem S₂ x)\n⊢ Module.Finite R (Subtype fun x => Membership.mem (Max.max S₁ S₂) x)","decl":"/-- The sup of two fg submodules is finite. Also see `Submodule.FG.sup`. -/\ninstance finite_sup (S₁ S₂ : Submodule R V) [h₁ : Module.Finite R S₁]\n    [h₂ : Module.Finite R S₂] : Module.Finite R (S₁ ⊔ S₂ : Submodule R V) := by\n  rw [finite_def] at *\n  exact (fg_top _).2 (((fg_top S₁).1 h₁).sup ((fg_top S₂).1 h₂))\n\n"}
{"name":"Submodule.finite_finset_sup","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_2\nV : Type u_3\ninst✝³ : Ring R\ninst✝² : AddCommGroup V\ninst✝¹ : Module R V\nι : Type u_1\ns : Finset ι\nS : ι → Submodule R V\ninst✝ : ∀ (i : ι), Module.Finite R (Subtype fun x => Membership.mem (S i) x)\n⊢ Module.Finite R (Subtype fun x => Membership.mem (s.sup S) x)","decl":"/-- The submodule generated by a finite supremum of finite dimensional submodules is\nfinite-dimensional.\n\nNote that strictly this only needs `∀ i ∈ s, FiniteDimensional K (S i)`, but that doesn't\nwork well with typeclass search. -/\ninstance finite_finset_sup {ι : Type*} (s : Finset ι) (S : ι → Submodule R V)\n    [∀ i, Module.Finite R (S i)] : Module.Finite R (s.sup S : Submodule R V) := by\n  refine\n    @Finset.sup_induction _ _ _ _ s S (fun i => Module.Finite R ↑i) (Module.Finite.bot R V)\n      ?_ fun i _ => by infer_instance\n  intro S₁ hS₁ S₂ hS₂\n  exact Submodule.finite_sup S₁ S₂\n\n"}
{"name":"RingHom.Finite.id","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"A : Type u_1\ninst✝ : CommRing A\n⊢ (RingHom.id A).Finite","decl":"theorem id : Finite (RingHom.id A) :=\n  Module.Finite.self A\n\n"}
{"name":"RingHom.Finite.of_surjective","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"A : Type u_1\nB : Type u_2\ninst✝¹ : CommRing A\ninst✝ : CommRing B\nf : RingHom A B\nhf : Function.Surjective ⇑f\n⊢ f.Finite","decl":"theorem of_surjective (f : A →+* B) (hf : Surjective f) : f.Finite :=\n  letI := f.toAlgebra\n  Module.Finite.of_surjective (Algebra.linearMap A B) hf\n\n"}
{"name":"RingHom.Finite.comp","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\ng : RingHom B C\nf : RingHom A B\nhg : g.Finite\nhf : f.Finite\n⊢ (g.comp f).Finite","decl":"theorem comp {g : B →+* C} {f : A →+* B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite := by\n  algebraize [f, g, g.comp f]\n  exact Module.Finite.trans B C\n\n"}
{"name":"RingHom.Finite.of_comp_finite","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"A : Type u_1\nB : Type u_2\nC : Type u_3\ninst✝² : CommRing A\ninst✝¹ : CommRing B\ninst✝ : CommRing C\nf : RingHom A B\ng : RingHom B C\nh : (g.comp f).Finite\n⊢ g.Finite","decl":"theorem of_comp_finite {f : A →+* B} {g : B →+* C} (h : (g.comp f).Finite) : g.Finite := by\n  algebraize [f, g, g.comp f]\n  exact Module.Finite.of_restrictScalars_finite A B C\n\n"}
{"name":"AlgHom.Finite.id","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommRing R\ninst✝¹ : CommRing A\ninst✝ : Algebra R A\n⊢ (AlgHom.id R A).Finite","decl":"theorem id : Finite (AlgHom.id R A) :=\n  RingHom.Finite.id A\n\n"}
{"name":"AlgHom.Finite.comp","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\ng : AlgHom R B C\nf : AlgHom R A B\nhg : g.Finite\nhf : f.Finite\n⊢ (g.comp f).Finite","decl":"theorem comp {g : B →ₐ[R] C} {f : A →ₐ[R] B} (hg : g.Finite) (hf : f.Finite) : (g.comp f).Finite :=\n  RingHom.Finite.comp hg hf\n\n"}
{"name":"AlgHom.Finite.of_surjective","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : CommRing B\ninst✝¹ : Algebra R A\ninst✝ : Algebra R B\nf : AlgHom R A B\nhf : Function.Surjective ⇑f\n⊢ f.Finite","decl":"theorem of_surjective (f : A →ₐ[R] B) (hf : Surjective f) : f.Finite :=\n  RingHom.Finite.of_surjective f.toRingHom hf\n\n"}
{"name":"AlgHom.Finite.of_comp_finite","module":"Mathlib.RingTheory.Finiteness.Basic","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\nC : Type u_4\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing A\ninst✝⁴ : CommRing B\ninst✝³ : CommRing C\ninst✝² : Algebra R A\ninst✝¹ : Algebra R B\ninst✝ : Algebra R C\nf : AlgHom R A B\ng : AlgHom R B C\nh : (g.comp f).Finite\n⊢ g.Finite","decl":"theorem of_comp_finite {f : A →ₐ[R] B} {g : B →ₐ[R] C} (h : (g.comp f).Finite) : g.Finite :=\n  RingHom.Finite.of_comp_finite h\n\n"}
