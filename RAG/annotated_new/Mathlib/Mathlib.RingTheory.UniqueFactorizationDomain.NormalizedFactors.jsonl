{"name":"UniqueFactorizationMonoid.factors_eq_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"M : Type u_2\ninst✝² : CancelCommMonoidWithZero M\ninst✝¹ : UniqueFactorizationMonoid M\ninst✝ : Subsingleton (Units M)\nx : M\n⊢ Eq (UniqueFactorizationMonoid.factors x) (UniqueFactorizationMonoid.normalizedFactors x)","decl":"/-- An arbitrary choice of factors of `x : M` is exactly the (unique) normalized set of factors,\nif `M` has a trivial group of units. -/\n@[simp]\ntheorem factors_eq_normalizedFactors {M : Type*} [CancelCommMonoidWithZero M]\n    [UniqueFactorizationMonoid M] [Subsingleton Mˣ] (x : M) : factors x = normalizedFactors x := by\n  unfold normalizedFactors\n  convert (Multiset.map_id (factors x)).symm\n  ext p\n  exact normalize_eq p\n\n"}
{"name":"UniqueFactorizationMonoid.prod_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na : α\nane0 : Ne a 0\n⊢ Associated (UniqueFactorizationMonoid.normalizedFactors a).prod a","decl":"theorem prod_normalizedFactors {a : α} (ane0 : a ≠ 0) :\n    Associated (normalizedFactors a).prod a := by\n  rw [normalizedFactors, factors, dif_neg ane0]\n  refine Associated.trans ?_ (Classical.choose_spec (exists_prime_factors a ane0)).2\n  rw [← Associates.mk_eq_mk_iff_associated, ← Associates.prod_mk, ← Associates.prod_mk,\n    Multiset.map_map]\n  congr 2\n  ext\n  rw [Function.comp_apply, Associates.mk_normalize]\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_prod","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na : α\nane0 : Ne a 0\n⊢ Associated (UniqueFactorizationMonoid.normalizedFactors a).prod a","decl":"@[deprecated (since := \"2024-12-04\")]\nalias normalizedFactors_prod := prod_normalizedFactors\n\n"}
{"name":"UniqueFactorizationMonoid.prod_normalizedFactors_eq","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na : α\nane0 : Ne a 0\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors a).prod (normalize a)","decl":"theorem prod_normalizedFactors_eq {a : α} (ane0 : a ≠ 0) :\n    (normalizedFactors a).prod = normalize a := by\n  trans normalize (normalizedFactors a).prod\n  · rw [normalizedFactors, ← map_multiset_prod, normalize_idem]\n  · exact normalize_eq_normalize_iff.mpr (dvd_dvd_iff_associated.mpr (prod_normalizedFactors ane0))\n\n"}
{"name":"UniqueFactorizationMonoid.prime_of_normalized_factor","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na x : α\na✝ : Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) x\n⊢ Prime x","decl":"theorem prime_of_normalized_factor {a : α} : ∀ x : α, x ∈ normalizedFactors a → Prime x := by\n  rw [normalizedFactors, factors]\n  split_ifs with ane0; · simp\n  intro x hx; rcases Multiset.mem_map.1 hx with ⟨y, ⟨hy, rfl⟩⟩\n  rw [(normalize_associated _).prime_iff]\n  exact (Classical.choose_spec (UniqueFactorizationMonoid.exists_prime_factors a ane0)).1 y hy\n\n"}
{"name":"UniqueFactorizationMonoid.irreducible_of_normalized_factor","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na x : α\na✝ : Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) x\n⊢ Irreducible x","decl":"theorem irreducible_of_normalized_factor {a : α} :\n    ∀ x : α, x ∈ normalizedFactors a → Irreducible x := fun x h =>\n  (prime_of_normalized_factor x h).irreducible\n\n"}
{"name":"UniqueFactorizationMonoid.normalize_normalized_factor","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na x : α\na✝ : Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) x\n⊢ Eq (normalize x) x","decl":"theorem normalize_normalized_factor {a : α} :\n    ∀ x : α, x ∈ normalizedFactors a → normalize x = x := by\n  rw [normalizedFactors, factors]\n  split_ifs with h; · simp\n  intro x hx\n  obtain ⟨y, _, rfl⟩ := Multiset.mem_map.1 hx\n  apply normalize_idem\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_irreducible","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na : α\nha : Irreducible a\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors a) (Singleton.singleton (normalize a))","decl":"theorem normalizedFactors_irreducible {a : α} (ha : Irreducible a) :\n    normalizedFactors a = {normalize a} := by\n  obtain ⟨p, a_assoc, hp⟩ :=\n    prime_factors_irreducible ha ⟨prime_of_normalized_factor, prod_normalizedFactors ha.ne_zero⟩\n  have p_mem : p ∈ normalizedFactors a := by\n    rw [hp]\n    exact Multiset.mem_singleton_self _\n  convert hp\n  rwa [← normalize_normalized_factor p p_mem, normalize_eq_normalize_iff, dvd_dvd_iff_associated]\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_eq_of_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na p : α\na✝² : Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) p\nq : α\na✝¹ : Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) q\na✝ : Dvd.dvd p q\n⊢ Eq p q","decl":"theorem normalizedFactors_eq_of_dvd (a : α) :\n    ∀ᵉ (p ∈ normalizedFactors a) (q ∈ normalizedFactors a), p ∣ q → p = q := by\n  intro p hp q hq hdvd\n  convert normalize_eq_normalize hdvd\n          ((prime_of_normalized_factor _ hp).irreducible.dvd_symm\n            (prime_of_normalized_factor _ hq).irreducible hdvd) <;>\n    apply (normalize_normalized_factor _ ‹_›).symm\n\n"}
{"name":"UniqueFactorizationMonoid.exists_mem_normalizedFactors_of_dvd","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nha0 : Ne a 0\nhp : Irreducible p\na✝ : Dvd.dvd p a\n⊢ Exists fun q => And (Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) q) (Associated p q)","decl":"theorem exists_mem_normalizedFactors_of_dvd {a p : α} (ha0 : a ≠ 0) (hp : Irreducible p) :\n    p ∣ a → ∃ q ∈ normalizedFactors a, p ~ᵤ q := fun ⟨b, hb⟩ =>\n  have hb0 : b ≠ 0 := fun hb0 => by simp_all\n  have : Multiset.Rel Associated (p ::ₘ normalizedFactors b) (normalizedFactors a) :=\n    factors_unique\n      (fun _ hx =>\n        (Multiset.mem_cons.1 hx).elim (fun h => h.symm ▸ hp) (irreducible_of_normalized_factor _))\n      irreducible_of_normalized_factor\n      (Associated.symm <|\n        calc\n          Multiset.prod (normalizedFactors a) ~ᵤ a := prod_normalizedFactors ha0\n          _ = p * b := hb\n          _ ~ᵤ Multiset.prod (p ::ₘ normalizedFactors b) := by\n            rw [Multiset.prod_cons]\n            exact (prod_normalizedFactors hb0).symm.mul_left _\n          )\n  Multiset.exists_mem_of_rel_of_mem this (by simp)\n\n"}
{"name":"UniqueFactorizationMonoid.exists_mem_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx : α\nhx : Ne x 0\nh : Not (IsUnit x)\n⊢ Exists fun p => Membership.mem (UniqueFactorizationMonoid.normalizedFactors x) p","decl":"theorem exists_mem_normalizedFactors {x : α} (hx : x ≠ 0) (h : ¬IsUnit x) :\n    ∃ p, p ∈ normalizedFactors x := by\n  obtain ⟨p', hp', hp'x⟩ := WfDvdMonoid.exists_irreducible_factor h hx\n  obtain ⟨p, hp, _⟩ := exists_mem_normalizedFactors_of_dvd hx hp' hp'x\n  exact ⟨p, hp⟩\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_zero","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors 0) 0","decl":"@[simp]\ntheorem normalizedFactors_zero : normalizedFactors (0 : α) = 0 := by\n  simp [normalizedFactors, factors]\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_one","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors 1) 0","decl":"@[simp]\ntheorem normalizedFactors_one : normalizedFactors (1 : α) = 0 := by\n  cases' subsingleton_or_nontrivial α with h h\n  · dsimp [normalizedFactors, factors]\n    simp [Subsingleton.elim (1 : α) 0]\n  · rw [← Multiset.rel_zero_right]\n    apply factors_unique irreducible_of_normalized_factor\n    · intro x hx\n      exfalso\n      apply Multiset.not_mem_zero x hx\n    · apply prod_normalizedFactors one_ne_zero\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_mul","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx y : α\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors (HMul.hMul x y)) (HAdd.hAdd (UniqueFactorizationMonoid.normalizedFactors x) (UniqueFactorizationMonoid.normalizedFactors y))","decl":"@[simp]\ntheorem normalizedFactors_mul {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    normalizedFactors (x * y) = normalizedFactors x + normalizedFactors y := by\n  have h : (normalize : α → α) = Associates.out ∘ Associates.mk := by\n    ext\n    rw [Function.comp_apply, Associates.out_mk]\n  rw [← Multiset.map_id' (normalizedFactors (x * y)), ← Multiset.map_id' (normalizedFactors x), ←\n    Multiset.map_id' (normalizedFactors y), ← Multiset.map_congr rfl normalize_normalized_factor, ←\n    Multiset.map_congr rfl normalize_normalized_factor, ←\n    Multiset.map_congr rfl normalize_normalized_factor, ← Multiset.map_add, h, ←\n    Multiset.map_map Associates.out, eq_comm, ← Multiset.map_map Associates.out]\n  refine congr rfl ?_\n  apply Multiset.map_mk_eq_map_mk_of_rel\n  apply factors_unique\n  · intro x hx\n    rcases Multiset.mem_add.1 hx with (hx | hx) <;> exact irreducible_of_normalized_factor x hx\n  · exact irreducible_of_normalized_factor\n  · rw [Multiset.prod_add]\n    exact\n      ((prod_normalizedFactors hx).mul_mul (prod_normalizedFactors hy)).trans\n        (prod_normalizedFactors (mul_ne_zero hx hy)).symm\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx : α\nn : Nat\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors (HPow.hPow x n)) (HSMul.hSMul n (UniqueFactorizationMonoid.normalizedFactors x))","decl":"@[simp]\ntheorem normalizedFactors_pow {x : α} (n : ℕ) :\n    normalizedFactors (x ^ n) = n • normalizedFactors x := by\n  induction' n with n ih\n  · simp\n  by_cases h0 : x = 0\n  · simp [h0, zero_pow n.succ_ne_zero, smul_zero]\n  rw [pow_succ', succ_nsmul', normalizedFactors_mul h0 (pow_ne_zero _ h0), ih]\n\n"}
{"name":"Irreducible.normalizedFactors_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\np : α\nhp : Irreducible p\nk : Nat\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors (HPow.hPow p k)) (Multiset.replicate k (normalize p))","decl":"theorem _root_.Irreducible.normalizedFactors_pow {p : α} (hp : Irreducible p) (k : ℕ) :\n    normalizedFactors (p ^ k) = Multiset.replicate k (normalize p) := by\n  rw [UniqueFactorizationMonoid.normalizedFactors_pow, normalizedFactors_irreducible hp,\n    Multiset.nsmul_singleton]\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_prod_eq","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\ns : Multiset α\nhs : ∀ (a : α), Membership.mem s a → Irreducible a\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors s.prod) (Multiset.map (⇑normalize) s)","decl":"theorem normalizedFactors_prod_eq (s : Multiset α) (hs : ∀ a ∈ s, Irreducible a) :\n    normalizedFactors s.prod = s.map normalize := by\n  induction' s using Multiset.induction with a s ih\n  · rw [Multiset.prod_zero, normalizedFactors_one, Multiset.map_zero]\n  · have ia := hs a (Multiset.mem_cons_self a _)\n    have ib := fun b h => hs b (Multiset.mem_cons_of_mem h)\n    obtain rfl | ⟨b, hb⟩ := s.empty_or_exists_mem\n    · rw [Multiset.cons_zero, Multiset.prod_singleton, Multiset.map_singleton,\n        normalizedFactors_irreducible ia]\n    haveI := nontrivial_of_ne b 0 (ib b hb).ne_zero\n    rw [Multiset.prod_cons, Multiset.map_cons,\n      normalizedFactors_mul ia.ne_zero (Multiset.prod_ne_zero fun h => (ib 0 h).ne_zero rfl),\n      normalizedFactors_irreducible ia, ih ib, Multiset.singleton_add]\n\n"}
{"name":"UniqueFactorizationMonoid.dvd_iff_normalizedFactors_le_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx y : α\nhx : Ne x 0\nhy : Ne y 0\n⊢ Iff (Dvd.dvd x y) (LE.le (UniqueFactorizationMonoid.normalizedFactors x) (UniqueFactorizationMonoid.normalizedFactors y))","decl":"theorem dvd_iff_normalizedFactors_le_normalizedFactors {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    x ∣ y ↔ normalizedFactors x ≤ normalizedFactors y := by\n  constructor\n  · rintro ⟨c, rfl⟩\n    simp [hx, right_ne_zero_of_mul hy]\n  · rw [← (prod_normalizedFactors hx).dvd_iff_dvd_left, ←\n      (prod_normalizedFactors hy).dvd_iff_dvd_right]\n    apply Multiset.prod_dvd_prod_of_le\n\n"}
{"name":"Associated.normalizedFactors_eq","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na b : α\nh : Associated a b\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors a) (UniqueFactorizationMonoid.normalizedFactors b)","decl":"theorem _root_.Associated.normalizedFactors_eq {a b : α} (h : Associated a b) :\n    normalizedFactors a = normalizedFactors b := by\n  unfold normalizedFactors\n  have h' : ⇑(normalize (α := α)) = Associates.out ∘ Associates.mk := funext Associates.out_mk\n  rw [h', ← Multiset.map_map, ← Multiset.map_map,\n    Associates.rel_associated_iff_map_eq_map.mp (factors_rel_of_associated h)]\n\n"}
{"name":"UniqueFactorizationMonoid.associated_iff_normalizedFactors_eq_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx y : α\nhx : Ne x 0\nhy : Ne y 0\n⊢ Iff (Associated x y) (Eq (UniqueFactorizationMonoid.normalizedFactors x) (UniqueFactorizationMonoid.normalizedFactors y))","decl":"theorem associated_iff_normalizedFactors_eq_normalizedFactors {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    x ~ᵤ y ↔ normalizedFactors x = normalizedFactors y :=\n  ⟨Associated.normalizedFactors_eq, fun h =>\n    (prod_normalizedFactors hx).symm.trans (_root_.trans (by rw [h]) (prod_normalizedFactors hy))⟩\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_of_irreducible_pow","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\np : α\nhp : Irreducible p\nk : Nat\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors (HPow.hPow p k)) (Multiset.replicate k (normalize p))","decl":"theorem normalizedFactors_of_irreducible_pow {p : α} (hp : Irreducible p) (k : ℕ) :\n    normalizedFactors (p ^ k) = Multiset.replicate k (normalize p) := by\n  rw [normalizedFactors_pow, normalizedFactors_irreducible hp, Multiset.nsmul_singleton]\n\n"}
{"name":"UniqueFactorizationMonoid.zero_not_mem_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx : α\n⊢ Not (Membership.mem (UniqueFactorizationMonoid.normalizedFactors x) 0)","decl":"theorem zero_not_mem_normalizedFactors (x : α) : (0 : α) ∉ normalizedFactors x := fun h =>\n  Prime.ne_zero (prime_of_normalized_factor _ h) rfl\n\n"}
{"name":"UniqueFactorizationMonoid.dvd_of_mem_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na p : α\nH : Membership.mem (UniqueFactorizationMonoid.normalizedFactors a) p\n⊢ Dvd.dvd p a","decl":"theorem dvd_of_mem_normalizedFactors {a p : α} (H : p ∈ normalizedFactors a) : p ∣ a := by\n  by_cases hcases : a = 0\n  · rw [hcases]\n    exact dvd_zero p\n  · exact dvd_trans (Multiset.dvd_prod H) (Associated.dvd (prod_normalizedFactors hcases))\n\n"}
{"name":"UniqueFactorizationMonoid.mem_normalizedFactors_iff","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : NormalizationMonoid α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Subsingleton (Units α)\np x : α\nhx : Ne x 0\n⊢ Iff (Membership.mem (UniqueFactorizationMonoid.normalizedFactors x) p) (And (Prime p) (Dvd.dvd p x))","decl":"theorem mem_normalizedFactors_iff [Subsingleton αˣ] {p x : α} (hx : x ≠ 0) :\n    p ∈ normalizedFactors x ↔ Prime p ∧ p ∣ x := by\n  constructor\n  · intro h\n    exact ⟨prime_of_normalized_factor p h, dvd_of_mem_normalizedFactors h⟩\n  · rintro ⟨hprime, hdvd⟩\n    obtain ⟨q, hqmem, hqeq⟩ := exists_mem_normalizedFactors_of_dvd hx hprime.irreducible hdvd\n    rw [associated_iff_eq] at hqeq\n    exact hqeq ▸ hqmem\n\n"}
{"name":"UniqueFactorizationMonoid.exists_associated_prime_pow_of_unique_normalized_factor","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\np r : α\nh : ∀ {m : α}, Membership.mem (UniqueFactorizationMonoid.normalizedFactors r) m → Eq m p\nhr : Ne r 0\n⊢ Exists fun i => Associated (HPow.hPow p i) r","decl":"theorem exists_associated_prime_pow_of_unique_normalized_factor {p r : α}\n    (h : ∀ {m}, m ∈ normalizedFactors r → m = p) (hr : r ≠ 0) : ∃ i : ℕ, Associated (p ^ i) r := by\n  use (normalizedFactors r).card\n  have := UniqueFactorizationMonoid.prod_normalizedFactors hr\n  rwa [Multiset.eq_replicate_of_mem fun b => h, Multiset.prod_replicate] at this\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_prod_of_prime","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝³ : CancelCommMonoidWithZero α\ninst✝² : NormalizationMonoid α\ninst✝¹ : UniqueFactorizationMonoid α\ninst✝ : Subsingleton (Units α)\nm : Multiset α\nh : ∀ (p : α), Membership.mem m p → Prime p\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors m.prod) m","decl":"theorem normalizedFactors_prod_of_prime [Subsingleton αˣ] {m : Multiset α}\n    (h : ∀ p ∈ m, Prime p) : normalizedFactors m.prod = m := by\n  cases subsingleton_or_nontrivial α\n  · obtain rfl : m = 0 := by\n      refine Multiset.eq_zero_of_forall_not_mem fun x hx ↦ ?_\n      simpa [Subsingleton.elim x 0] using h x hx\n    simp\n  · simpa only [← Multiset.rel_eq, ← associated_eq_eq] using\n      prime_factors_unique prime_of_normalized_factor h\n        (prod_normalizedFactors (m.prod_ne_zero_of_prime h))\n\n"}
{"name":"UniqueFactorizationMonoid.mem_normalizedFactors_eq_of_associated","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\na b c : α\nha : Membership.mem (UniqueFactorizationMonoid.normalizedFactors c) a\nhb : Membership.mem (UniqueFactorizationMonoid.normalizedFactors c) b\nh : Associated a b\n⊢ Eq a b","decl":"theorem mem_normalizedFactors_eq_of_associated {a b c : α} (ha : a ∈ normalizedFactors c)\n    (hb : b ∈ normalizedFactors c) (h : Associated a b) : a = b := by\n  rw [← normalize_normalized_factor a ha, ← normalize_normalized_factor b hb,\n    normalize_eq_normalize_iff]\n  exact Associated.dvd_dvd h\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_pos","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx : α\nhx : Ne x 0\n⊢ Iff (LT.lt 0 (UniqueFactorizationMonoid.normalizedFactors x)) (Not (IsUnit x))","decl":"@[simp]\ntheorem normalizedFactors_pos (x : α) (hx : x ≠ 0) : 0 < normalizedFactors x ↔ ¬IsUnit x := by\n  constructor\n  · intro h hx\n    obtain ⟨p, hp⟩ := Multiset.exists_mem_of_ne_zero h.ne'\n    exact\n      (prime_of_normalized_factor _ hp).not_unit\n        (isUnit_of_dvd_unit (dvd_of_mem_normalizedFactors hp) hx)\n  · intro h\n    obtain ⟨p, hp⟩ := exists_mem_normalizedFactors hx h\n    exact\n      bot_lt_iff_ne_bot.mpr\n        (mt Multiset.eq_zero_iff_forall_not_mem.mp (not_forall.mpr ⟨p, not_not.mpr hp⟩))\n\n"}
{"name":"UniqueFactorizationMonoid.dvdNotUnit_iff_normalizedFactors_lt_normalizedFactors","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\nx y : α\nhx : Ne x 0\nhy : Ne y 0\n⊢ Iff (DvdNotUnit x y) (LT.lt (UniqueFactorizationMonoid.normalizedFactors x) (UniqueFactorizationMonoid.normalizedFactors y))","decl":"theorem dvdNotUnit_iff_normalizedFactors_lt_normalizedFactors {x y : α} (hx : x ≠ 0) (hy : y ≠ 0) :\n    DvdNotUnit x y ↔ normalizedFactors x < normalizedFactors y := by\n  constructor\n  · rintro ⟨_, c, hc, rfl⟩\n    simp only [hx, right_ne_zero_of_mul hy, normalizedFactors_mul, Ne, not_false_iff,\n      lt_add_iff_pos_right, normalizedFactors_pos, hc]\n  · intro h\n    exact\n      dvdNotUnit_of_dvd_of_not_dvd\n        ((dvd_iff_normalizedFactors_le_normalizedFactors hx hy).mpr h.le)\n        (mt (dvd_iff_normalizedFactors_le_normalizedFactors hy hx).mp h.not_le)\n\n"}
{"name":"UniqueFactorizationMonoid.normalizedFactors_multiset_prod","module":"Mathlib.RingTheory.UniqueFactorizationDomain.NormalizedFactors","initialProofState":"α : Type u_1\ninst✝² : CancelCommMonoidWithZero α\ninst✝¹ : NormalizationMonoid α\ninst✝ : UniqueFactorizationMonoid α\ns : Multiset α\nhs : Not (Membership.mem s 0)\n⊢ Eq (UniqueFactorizationMonoid.normalizedFactors s.prod) (Multiset.map UniqueFactorizationMonoid.normalizedFactors s).sum","decl":"theorem normalizedFactors_multiset_prod (s : Multiset α) (hs : 0 ∉ s) :\n    normalizedFactors (s.prod) = (s.map normalizedFactors).sum := by\n  cases subsingleton_or_nontrivial α\n  · obtain rfl : s = 0 := by\n      apply Multiset.eq_zero_of_forall_not_mem\n      intro _\n      convert hs\n    simp\n  induction s using Multiset.induction with\n  | empty => simp\n  | cons _ _ IH =>\n    rw [Multiset.prod_cons, Multiset.map_cons, Multiset.sum_cons, normalizedFactors_mul, IH]\n    · exact fun h ↦ hs (Multiset.mem_cons_of_mem h)\n    · exact fun h ↦ hs (h ▸ Multiset.mem_cons_self _ _)\n    · apply Multiset.prod_ne_zero\n      exact fun h ↦ hs (Multiset.mem_cons_of_mem h)\n\n"}
