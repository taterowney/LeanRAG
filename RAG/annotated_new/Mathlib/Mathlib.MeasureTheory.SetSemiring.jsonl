{"name":"MeasureTheory.IsSetSemiring.inter_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.IsSetSemiring C\ns : Set α\na✝¹ : Membership.mem C s\nt : Set α\na✝ : Membership.mem C t\n⊢ Membership.mem C (Inter.inter s t)","decl":"/-- A semi-ring of sets `C` is a family of sets containing `∅`, stable by intersection and such that\nfor all `s, t ∈ C`, `s \\ t` is equal to a disjoint union of finitely many sets in `C`. -/\nstructure IsSetSemiring (C : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ C\n  inter_mem : ∀ s ∈ C, ∀ t ∈ C, s ∩ t ∈ C\n  diff_eq_sUnion' : ∀ s ∈ C, ∀ t ∈ C,\n    ∃ I : Finset (Set α), ↑I ⊆ C ∧ PairwiseDisjoint (I : Set (Set α)) id ∧ s \\ t = ⋃₀ I\n\n"}
{"name":"MeasureTheory.IsSetSemiring.diff_eq_sUnion'","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.IsSetSemiring C\ns : Set α\na✝¹ : Membership.mem C s\nt : Set α\na✝ : Membership.mem C t\n⊢ Exists fun I => And (HasSubset.Subset (↑I) C) (And ((↑I).PairwiseDisjoint id) (Eq (SDiff.sdiff s t) (↑I).sUnion))","decl":"/-- A semi-ring of sets `C` is a family of sets containing `∅`, stable by intersection and such that\nfor all `s, t ∈ C`, `s \\ t` is equal to a disjoint union of finitely many sets in `C`. -/\nstructure IsSetSemiring (C : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ C\n  inter_mem : ∀ s ∈ C, ∀ t ∈ C, s ∩ t ∈ C\n  diff_eq_sUnion' : ∀ s ∈ C, ∀ t ∈ C,\n    ∃ I : Finset (Set α), ↑I ⊆ C ∧ PairwiseDisjoint (I : Set (Set α)) id ∧ s \\ t = ⋃₀ I\n\n"}
{"name":"MeasureTheory.IsSetSemiring.empty_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.IsSetSemiring C\n⊢ Membership.mem C EmptyCollection.emptyCollection","decl":"/-- A semi-ring of sets `C` is a family of sets containing `∅`, stable by intersection and such that\nfor all `s, t ∈ C`, `s \\ t` is equal to a disjoint union of finitely many sets in `C`. -/\nstructure IsSetSemiring (C : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ C\n  inter_mem : ∀ s ∈ C, ∀ t ∈ C, s ∩ t ∈ C\n  diff_eq_sUnion' : ∀ s ∈ C, ∀ t ∈ C,\n    ∃ I : Finset (Set α), ↑I ⊆ C ∧ PairwiseDisjoint (I : Set (Set α)) id ∧ s \\ t = ⋃₀ I\n\n"}
{"name":"MeasureTheory.IsSetSemiring.isPiSystem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetSemiring C\n⊢ IsPiSystem C","decl":"lemma isPiSystem (hC : IsSetSemiring C) : IsPiSystem C := fun s hs t ht _ ↦ hC.inter_mem s hs t ht\n\n"}
{"name":"MeasureTheory.IsSetSemiring.empty_nmem_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ Not (Membership.mem (hC.disjointOfDiff hs ht) EmptyCollection.emptyCollection)","decl":"lemma empty_nmem_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C) :\n    ∅ ∉ hC.disjointOfDiff hs ht := by\n  classical\n  simp only [disjointOfDiff, mem_sdiff, Finset.mem_singleton, eq_self_iff_true,\n    not_true, and_false, not_false_iff]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.subset_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ HasSubset.Subset (↑(hC.disjointOfDiff hs ht)) C","decl":"lemma subset_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C) :\n    ↑(hC.disjointOfDiff hs ht) ⊆ C := by\n  classical\n  simp only [disjointOfDiff, coe_sdiff, coe_singleton, diff_singleton_subset_iff]\n  exact (hC.diff_eq_sUnion' s hs t ht).choose_spec.1.trans (Set.subset_insert _ _)\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ (↑(hC.disjointOfDiff hs ht)).PairwiseDisjoint id","decl":"lemma pairwiseDisjoint_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C) :\n    PairwiseDisjoint (hC.disjointOfDiff hs ht : Set (Set α)) id := by\n  classical\n  simp only [disjointOfDiff, coe_sdiff, coe_singleton]\n  exact Set.PairwiseDisjoint.subset (hC.diff_eq_sUnion' s hs t ht).choose_spec.2.1\n      diff_subset\n\n"}
{"name":"MeasureTheory.IsSetSemiring.sUnion_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ Eq (↑(hC.disjointOfDiff hs ht)).sUnion (SDiff.sdiff s t)","decl":"lemma sUnion_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C) :\n    ⋃₀ hC.disjointOfDiff hs ht = s \\ t := by\n  classical\n  rw [(hC.diff_eq_sUnion' s hs t ht).choose_spec.2.2]\n  simp only [disjointOfDiff, coe_sdiff, coe_singleton, diff_singleton_subset_iff]\n  rw [sUnion_diff_singleton_empty]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.nmem_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ Not (Membership.mem (hC.disjointOfDiff hs ht) t)","decl":"lemma nmem_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C) :\n    t ∉ hC.disjointOfDiff hs ht := by\n  intro hs_mem\n  suffices t ⊆ s \\ t by\n    have h := @disjoint_sdiff_self_right _ t s _\n    specialize h le_rfl this\n    simp only [Set.bot_eq_empty, Set.le_eq_subset, subset_empty_iff] at h\n    refine hC.empty_nmem_disjointOfDiff hs ht ?_\n    rwa [← h]\n  rw [← hC.sUnion_disjointOfDiff hs ht]\n  exact subset_sUnion_of_mem hs_mem\n\n"}
{"name":"MeasureTheory.IsSetSemiring.sUnion_insert_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\nhst : HasSubset.Subset t s\n⊢ Eq (Insert.insert t ↑(hC.disjointOfDiff hs ht)).sUnion s","decl":"lemma sUnion_insert_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C)\n    (ht : t ∈ C) (hst : t ⊆ s) :\n    ⋃₀ insert t (hC.disjointOfDiff hs ht) = s := by\n  conv_rhs => rw [← union_diff_cancel hst, ← hC.sUnion_disjointOfDiff hs ht]\n  simp only [mem_coe, sUnion_insert]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjoint_sUnion_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ Disjoint t (↑(hC.disjointOfDiff hs ht)).sUnion","decl":"lemma disjoint_sUnion_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C) (ht : t ∈ C) :\n    Disjoint t (⋃₀ hC.disjointOfDiff hs ht) := by\n  rw [hC.sUnion_disjointOfDiff]\n  exact disjoint_sdiff_right\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_insert_disjointOfDiff","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ (Insert.insert t ↑(hC.disjointOfDiff hs ht)).PairwiseDisjoint id","decl":"lemma pairwiseDisjoint_insert_disjointOfDiff (hC : IsSetSemiring C) (hs : s ∈ C)\n    (ht : t ∈ C) :\n    PairwiseDisjoint (insert t (hC.disjointOfDiff hs ht) : Set (Set α)) id := by\n  have h := hC.pairwiseDisjoint_disjointOfDiff hs ht\n  refine PairwiseDisjoint.insert_of_not_mem h (hC.nmem_disjointOfDiff hs ht) fun u hu ↦ ?_\n  simp_rw [id]\n  refine Disjoint.mono_right ?_ (hC.disjoint_sUnion_disjointOfDiff hs ht)\n  simp only [Set.le_eq_subset]\n  exact subset_sUnion_of_mem hu\n\n"}
{"name":"MeasureTheory.IsSetSemiring.exists_disjoint_finset_diff_eq","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ Exists fun J => And (HasSubset.Subset (↑J) C) (And ((↑J).PairwiseDisjoint id) (Eq (SDiff.sdiff s (↑I).sUnion) (↑J).sUnion))","decl":"/-- In a semiring of sets `C`, for all set `s ∈ C` and finite set of sets `I ⊆ C`, there is a\nfinite set of sets in `C` whose union is `s \\ ⋃₀ I`.\nSee `IsSetSemiring.disjointOfDiffUnion` for a definition that gives such a set. -/\nlemma exists_disjoint_finset_diff_eq (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C) :\n    ∃ J : Finset (Set α), ↑J ⊆ C ∧ PairwiseDisjoint (J : Set (Set α)) id ∧\n      s \\ ⋃₀ I = ⋃₀ J := by\n  classical\n  induction I using Finset.induction with\n  | empty =>\n    simp only [coe_empty, sUnion_empty, diff_empty, exists_prop]\n    refine ⟨{s}, singleton_subset_set_iff.mpr hs, ?_⟩\n    simp only [coe_singleton, pairwiseDisjoint_singleton, sUnion_singleton, eq_self_iff_true,\n      and_self_iff]\n  | @insert t I' _ h => ?_\n\n  rw [coe_insert] at hI\n  have ht : t ∈ C := hI (Set.mem_insert _ _)\n  obtain ⟨J, h_ss, h_dis, h_eq⟩ := h ((Set.subset_insert _ _).trans hI)\n  let Ju : ∀ u ∈ C, Finset (Set α) := fun u hu ↦ hC.disjointOfDiff hu ht\n  have hJu_subset : ∀ (u) (hu : u ∈ C), ↑(Ju u hu) ⊆ C := by\n    intro u hu x hx\n    exact hC.subset_disjointOfDiff hu ht hx\n  have hJu_disj : ∀ (u) (hu : u ∈ C), (Ju u hu : Set (Set α)).PairwiseDisjoint id := fun u hu ↦\n    hC.pairwiseDisjoint_disjointOfDiff hu ht\n  have hJu_sUnion : ∀ (u) (hu : u ∈ C), ⋃₀ (Ju u hu : Set (Set α)) = u \\ t :=\n    fun u hu ↦ hC.sUnion_disjointOfDiff hu ht\n  have hJu_disj' : ∀ (u) (hu : u ∈ C) (v) (hv : v ∈ C) (_h_dis : Disjoint u v),\n      Disjoint (⋃₀ (Ju u hu : Set (Set α))) (⋃₀ ↑(Ju v hv)) := by\n    intro u hu v hv huv_disj\n    rw [hJu_sUnion, hJu_sUnion]\n    exact disjoint_of_subset Set.diff_subset Set.diff_subset huv_disj\n  let J' : Finset (Set α) := Finset.biUnion (Finset.univ : Finset J) fun u ↦ Ju u (h_ss u.prop)\n  have hJ'_subset : ↑J' ⊆ C := by\n    intro u\n    simp only [J' ,Subtype.coe_mk, univ_eq_attach, coe_biUnion, mem_coe, mem_attach, iUnion_true,\n      mem_iUnion, Finset.exists_coe, exists₂_imp]\n    intro v hv huvt\n    exact hJu_subset v (h_ss hv) huvt\n  refine ⟨J', hJ'_subset, ?_, ?_⟩\n  · rw [Finset.coe_biUnion]\n    refine PairwiseDisjoint.biUnion ?_ ?_\n    · simp only [univ_eq_attach, mem_coe, id, iSup_eq_iUnion]\n      simp_rw [PairwiseDisjoint, Set.Pairwise]\n      intro x _ y _ hxy\n      have hxy_disj : Disjoint (x : Set α) y := by\n        by_contra h_contra\n        refine hxy ?_\n        refine Subtype.ext ?_\n        exact h_dis.elim x.prop y.prop h_contra\n      convert hJu_disj' (x : Set α) (h_ss x.prop) y (h_ss y.prop) hxy_disj\n      · rw [sUnion_eq_biUnion]\n        congr\n      · rw [sUnion_eq_biUnion]\n        congr\n    · exact fun u _ ↦ hJu_disj _ _\n  · rw [coe_insert, sUnion_insert, Set.union_comm, ← Set.diff_diff, h_eq]\n    simp_rw [J', sUnion_eq_biUnion, Set.iUnion_diff]\n    simp only [Subtype.coe_mk, mem_coe, Finset.mem_biUnion, Finset.mem_univ, exists_true_left,\n      Finset.exists_coe, iUnion_exists, true_and]\n    rw [iUnion_comm]\n    refine iUnion_congr fun i ↦ ?_\n    by_cases hi : i ∈ J\n    · simp only [hi, iUnion_true, exists_prop]\n      rw [← hJu_sUnion i (h_ss hi), sUnion_eq_biUnion]\n      simp only [mem_coe]\n    · simp only [hi, iUnion_of_empty, iUnion_empty]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.empty_nmem_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ Not (Membership.mem (hC.disjointOfDiffUnion hs hI) EmptyCollection.emptyCollection)","decl":"lemma empty_nmem_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) :\n    ∅ ∉ hC.disjointOfDiffUnion hs hI := by\n  classical\n  simp only [disjointOfDiffUnion, mem_sdiff, Finset.mem_singleton, eq_self_iff_true,\n    not_true, and_false, not_false_iff]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjointOfDiffUnion_subset","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ HasSubset.Subset (↑(hC.disjointOfDiffUnion hs hI)) C","decl":"lemma disjointOfDiffUnion_subset (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C) :\n    ↑(hC.disjointOfDiffUnion hs hI) ⊆ C := by\n  classical\n  simp only [disjointOfDiffUnion, coe_sdiff, coe_singleton, diff_singleton_subset_iff]\n  exact (hC.exists_disjoint_finset_diff_eq hs hI).choose_spec.1.trans (Set.subset_insert _ _)\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ (↑(hC.disjointOfDiffUnion hs hI)).PairwiseDisjoint id","decl":"lemma pairwiseDisjoint_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) : PairwiseDisjoint (hC.disjointOfDiffUnion hs hI : Set (Set α)) id := by\n  classical\n  simp only [disjointOfDiffUnion, coe_sdiff, coe_singleton]\n  exact Set.PairwiseDisjoint.subset\n    (hC.exists_disjoint_finset_diff_eq hs hI).choose_spec.2.1 diff_subset\n\n"}
{"name":"MeasureTheory.IsSetSemiring.diff_sUnion_eq_sUnion_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ Eq (SDiff.sdiff s (↑I).sUnion) (↑(hC.disjointOfDiffUnion hs hI)).sUnion","decl":"lemma diff_sUnion_eq_sUnion_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) : s \\ ⋃₀ I = ⋃₀ hC.disjointOfDiffUnion hs hI := by\n  classical\n  rw [(hC.exists_disjoint_finset_diff_eq hs hI).choose_spec.2.2]\n  simp only [disjointOfDiffUnion, coe_sdiff, coe_singleton, diff_singleton_subset_iff]\n  rw [sUnion_diff_singleton_empty]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.sUnion_disjointOfDiffUnion_subset","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ HasSubset.Subset (↑(hC.disjointOfDiffUnion hs hI)).sUnion s","decl":"lemma sUnion_disjointOfDiffUnion_subset (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) : ⋃₀ (hC.disjointOfDiffUnion hs hI : Set (Set α)) ⊆ s := by\n  rw [← hC.diff_sUnion_eq_sUnion_disjointOfDiffUnion]\n  exact diff_subset\n\n"}
{"name":"MeasureTheory.IsSetSemiring.subset_of_diffUnion_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\nt : Set α\nht : Membership.mem (↑(hC.disjointOfDiffUnion hs hI)) t\n⊢ HasSubset.Subset t (SDiff.sdiff s (↑I).sUnion)","decl":"lemma subset_of_diffUnion_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C)\n    (t : Set α) (ht : t ∈ (hC.disjointOfDiffUnion hs hI : Set (Set α))) :\n    t ⊆ s \\ ⋃₀ I := by\n  revert t ht\n  rw [← sUnion_subset_iff, hC.diff_sUnion_eq_sUnion_disjointOfDiffUnion hs hI]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.subset_of_mem_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nhC : MeasureTheory.IsSetSemiring C\nI : Finset (Set α)\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\nt : Set α\nht : Membership.mem (↑(hC.disjointOfDiffUnion hs hI)) t\n⊢ HasSubset.Subset t s","decl":"lemma subset_of_mem_disjointOfDiffUnion (hC : IsSetSemiring C) {I : Finset (Set α)}\n    (hs : s ∈ C) (hI : ↑I ⊆ C) (t : Set α)\n    (ht : t ∈ (hC.disjointOfDiffUnion hs hI : Set (Set α))) :\n    t ⊆ s := by\n  apply le_trans <| hC.subset_of_diffUnion_disjointOfDiffUnion hs hI t ht\n  exact sdiff_le (a := s) (b := ⋃₀ I)\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjoint_sUnion_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ Disjoint (↑I).sUnion (↑(hC.disjointOfDiffUnion hs hI)).sUnion","decl":"lemma disjoint_sUnion_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) :\n    Disjoint (⋃₀ (I : Set (Set α))) (⋃₀ hC.disjointOfDiffUnion hs hI) := by\n  rw [← hC.diff_sUnion_eq_sUnion_disjointOfDiffUnion]; exact Set.disjoint_sdiff_right\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjoint_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\n⊢ Disjoint I (hC.disjointOfDiffUnion hs hI)","decl":"lemma disjoint_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C) (hI : ↑I ⊆ C) :\n    Disjoint I (hC.disjointOfDiffUnion hs hI) := by\n  by_contra h\n  rw [Finset.not_disjoint_iff] at h\n  obtain ⟨u, huI, hu_disjointOfDiffUnion⟩ := h\n  have h_disj : u ≤ ⊥ :=\n    hC.disjoint_sUnion_disjointOfDiffUnion hs hI (subset_sUnion_of_mem huI)\n    (subset_sUnion_of_mem hu_disjointOfDiffUnion)\n  simp only [Set.bot_eq_empty, Set.le_eq_subset, subset_empty_iff] at h_disj\n  refine hC.empty_nmem_disjointOfDiffUnion hs hI ?_\n  rwa [h_disj] at hu_disjointOfDiffUnion\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_union_disjointOfDiffUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\nh_dis : (↑I).PairwiseDisjoint id\n⊢ (Union.union ↑I ↑(hC.disjointOfDiffUnion hs hI)).PairwiseDisjoint id","decl":"lemma pairwiseDisjoint_union_disjointOfDiffUnion (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) (h_dis : PairwiseDisjoint (I : Set (Set α)) id) :\n    PairwiseDisjoint (I ∪ hC.disjointOfDiffUnion hs hI : Set (Set α)) id := by\n  rw [pairwiseDisjoint_union]\n  refine ⟨h_dis, hC.pairwiseDisjoint_disjointOfDiffUnion hs hI, fun u hu v hv _ ↦ ?_⟩\n  simp_rw [id]\n  exact disjoint_of_subset (subset_sUnion_of_mem hu) (subset_sUnion_of_mem hv)\n    (hC.disjoint_sUnion_disjointOfDiffUnion hs hI)\n\n"}
{"name":"MeasureTheory.IsSetSemiring.sUnion_union_sUnion_disjointOfDiffUnion_of_subset","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\nhI_ss : ∀ (t : Set α), Membership.mem I t → HasSubset.Subset t s\n⊢ Eq (Union.union (↑I).sUnion (↑(hC.disjointOfDiffUnion hs hI)).sUnion) s","decl":"lemma sUnion_union_sUnion_disjointOfDiffUnion_of_subset (hC : IsSetSemiring C)\n    (hs : s ∈ C) (hI : ↑I ⊆ C) (hI_ss : ∀ t ∈ I, t ⊆ s) :\n    ⋃₀ I ∪ ⋃₀ hC.disjointOfDiffUnion hs hI = s := by\n  conv_rhs => rw [← union_diff_cancel (Set.sUnion_subset hI_ss : ⋃₀ ↑I ⊆ s),\n    hC.diff_sUnion_eq_sUnion_disjointOfDiffUnion hs hI]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.sUnion_union_disjointOfDiffUnion_of_subset","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns : Set α\nI : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhs : Membership.mem C s\nhI : HasSubset.Subset (↑I) C\nhI_ss : ∀ (t : Set α), Membership.mem I t → HasSubset.Subset t s\ninst✝ : DecidableEq (Set α)\n⊢ Eq (↑(Union.union I (hC.disjointOfDiffUnion hs hI))).sUnion s","decl":"lemma sUnion_union_disjointOfDiffUnion_of_subset (hC : IsSetSemiring C) (hs : s ∈ C)\n    (hI : ↑I ⊆ C) (hI_ss : ∀ t ∈ I, t ⊆ s) [DecidableEq (Set α)] :\n    ⋃₀ ↑(I ∪ hC.disjointOfDiffUnion hs hI) = s := by\n  conv_rhs => rw [← sUnion_union_sUnion_disjointOfDiffUnion_of_subset hC hs hI hI_ss]\n  simp_rw [coe_union]\n  rw [sUnion_union]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjointOfUnion_props","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nh1 : HasSubset.Subset (↑J) C\n⊢ Exists fun K => And ((↑J).PairwiseDisjoint K) (And (∀ (i : Set α), Membership.mem J i → HasSubset.Subset (↑(K i)) C) (And ((Set.iUnion fun x => Set.iUnion fun h => ↑(K x)).PairwiseDisjoint id) (And (∀ (j : Set α), Membership.mem J j → HasSubset.Subset (↑(K j)).sUnion j) (And (∀ (j : Set α), Membership.mem J j → Not (Membership.mem (K j) EmptyCollection.emptyCollection)) (Eq (↑J).sUnion (Set.iUnion fun x => Set.iUnion fun h => ↑(K x)).sUnion)))))","decl":"theorem disjointOfUnion_props (hC : IsSetSemiring C) (h1 : ↑J ⊆ C) :\n    ∃ K : Set α → Finset (Set α),\n      PairwiseDisjoint J K\n      ∧ (∀ i ∈ J, ↑(K i) ⊆ C)\n      ∧ PairwiseDisjoint (⋃ x ∈ J, (K x : Set (Set α))) id\n      ∧ (∀ j ∈ J, ⋃₀ K j ⊆ j)\n      ∧ (∀ j ∈ J, ∅ ∉ K j)\n      ∧ ⋃₀ J = ⋃₀ (⋃ x ∈ J, (K x : Set (Set α))) := by\n  classical\n  induction J using Finset.cons_induction with\n  | empty => simp\n  | cons s J hJ hind =>\n    rw [cons_eq_insert, coe_insert, Set.insert_subset_iff] at h1\n    obtain ⟨K, hK0, ⟨hK1, hK2, hK3, hK4, hK5⟩⟩ := hind h1.2\n    let K1 : Set α → Finset (Set α) := fun (t : Set α) ↦\n      if t = s then (hC.disjointOfDiffUnion h1.1 h1.2) else K t\n    have hK1s : K1 s = hC.disjointOfDiffUnion h1.1 h1.2 := by simp [K1]\n    have hK1_of_ne t (ht : t ≠ s) : K1 t = K t := by simp [K1, ht]\n    use K1\n    simp only [cons_eq_insert, disjiUnion_eq_biUnion, Finset.biUnion_insert, coe_union, coe_biUnion,\n      mem_coe, Set.union_subset_iff, iUnion_subset_iff, Finset.mem_insert, sUnion_subset_iff,\n      forall_eq_or_imp, coe_insert, sUnion_insert, exists_and_left, exists_prop]\n    -- two simplification rules for induction hypothesis\n    have ht1' : ∀ x ∈ J, K1 x = K x := fun x hx ↦ hK1_of_ne _ (fun h_eq ↦ hJ (h_eq ▸ hx))\n    have ht2 : (⋃ x ∈ J, (K1 x : Set (Set α))) = ⋃ x ∈ J, ((K x : Set (Set α))) := by\n      apply iUnion₂_congr\n      intros x hx\n      exact_mod_cast hK1_of_ne _ (ne_of_mem_of_not_mem hx hJ)\n    simp only [hK1s]\n    refine ⟨?_, ⟨hC.disjointOfDiffUnion_subset h1.1 h1.2, ?_⟩, ?_,\n      ⟨hC.subset_of_mem_disjointOfDiffUnion h1.1 h1.2, ?_⟩, ?_, ?_⟩\n    · apply Set.Pairwise.insert\n      · intro j hj i hi hij\n        rw [Function.onFun, ht1' j hj, ht1' i hi]\n        exact hK0 hj hi hij\n      · intro i hi _\n        have h7 : Disjoint ↑(hC.disjointOfDiffUnion h1.1 h1.2) (K i : Set (Set α)) := by\n          refine disjoint_of_sSup_disjoint_of_le_of_le\n            (hC.subset_of_diffUnion_disjointOfDiffUnion h1.1 h1.2) ?_\n            (@disjoint_sdiff_left _ (⋃₀ J) s) (Or.inl\n              (hC.empty_nmem_disjointOfDiffUnion h1.1 h1.2))\n          simp only [mem_coe, Set.le_eq_subset]\n          apply sUnion_subset_iff.mp\n          exact (hK3 i hi).trans (subset_sUnion_of_mem hi)\n        have h8 : Function.onFun Disjoint K1 s i := by\n          refine Finset.disjoint_iff_inter_eq_empty.mpr ?_\n          rw [ht1' i hi, hK1s]\n          rw [Set.disjoint_iff_inter_eq_empty] at h7\n          exact_mod_cast h7\n        exact ⟨h8, Disjoint.symm h8⟩\n    · intros i hi\n      rw [ht1' i hi]\n      exact hK1 i hi\n    · simp only [iUnion_iUnion_eq_or_left]\n      refine pairwiseDisjoint_union.mpr ⟨?_, ?_, ?_⟩\n      · rw [hK1s]\n        exact hC.pairwiseDisjoint_disjointOfDiffUnion h1.1 h1.2\n      · simpa [ht2]\n      · simp only [mem_coe, mem_iUnion, exists_prop, ne_eq, id_eq, forall_exists_index, and_imp]\n        intros i hi j x hx h3 h4\n        obtain ki : i ⊆ s \\ ⋃₀ J := hC.subset_of_diffUnion_disjointOfDiffUnion h1.1 h1.2 _\n          (hK1s ▸ hi)\n        obtain hx2 : j ⊆ x := subset_trans (subset_sUnion_of_mem (ht1' x hx ▸ h3)) (hK3 x hx)\n        obtain kj : j ⊆ ⋃₀ J := hx2.trans <| subset_sUnion_of_mem hx\n        exact disjoint_of_subset ki kj disjoint_sdiff_left\n    · intros a ha\n      simp_rw [hK1_of_ne _ (ne_of_mem_of_not_mem ha hJ)]\n      change ∀ t' ∈ (K a : Set (Set α)), t' ⊆ a\n      rw [← sUnion_subset_iff]\n      exact hK3 a ha\n    · refine ⟨hC.empty_nmem_disjointOfDiffUnion h1.1 h1.2, ?_⟩\n      intros a ha\n      rw [ht1' a ha]\n      exact hK4 a ha\n    · simp only [iUnion_iUnion_eq_or_left, ht2, sUnion_union, ht2, K1]\n      simp_rw [apply_ite, hK5,\n      ← hC.diff_sUnion_eq_sUnion_disjointOfDiffUnion h1.1 h1.2, hK5]\n      simp only [↓reduceIte, diff_union_self]\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_disjointOfUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\n⊢ (↑J).PairwiseDisjoint (hC.disjointOfUnion hJ)","decl":"lemma pairwiseDisjoint_disjointOfUnion (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) :\n    PairwiseDisjoint J (hC.disjointOfUnion hJ) :=\n  (Exists.choose_spec (hC.disjointOfUnion_props hJ)).1\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjointOfUnion_subset","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nj : Set α\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\nhj : Membership.mem J j\n⊢ HasSubset.Subset (↑(hC.disjointOfUnion hJ j)) C","decl":"lemma disjointOfUnion_subset (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) (hj : j ∈ J) :\n    (disjointOfUnion hC hJ j : Set (Set α)) ⊆ C :=\n  (Exists.choose_spec (hC.disjointOfUnion_props hJ)).2.1 _ hj\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_biUnion_disjointOfUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\n⊢ (Set.iUnion fun x => Set.iUnion fun h => ↑(hC.disjointOfUnion hJ x)).PairwiseDisjoint id","decl":"lemma pairwiseDisjoint_biUnion_disjointOfUnion (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) :\n    PairwiseDisjoint (⋃ x ∈ J, (hC.disjointOfUnion hJ x : Set (Set α))) id :=\n  (Exists.choose_spec (hC.disjointOfUnion_props hJ)).2.2.1\n\n"}
{"name":"MeasureTheory.IsSetSemiring.pairwiseDisjoint_disjointOfUnion_of_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nj : Set α\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\nhj : Membership.mem J j\n⊢ (↑(hC.disjointOfUnion hJ j)).PairwiseDisjoint id","decl":"lemma pairwiseDisjoint_disjointOfUnion_of_mem (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) (hj : j ∈ J) :\n    PairwiseDisjoint (hC.disjointOfUnion hJ j : Set (Set α)) id := by\n  apply PairwiseDisjoint.subset (hC.pairwiseDisjoint_biUnion_disjointOfUnion hJ)\n  exact subset_iUnion₂_of_subset j hj fun ⦃a⦄ a ↦ a\n\n"}
{"name":"MeasureTheory.IsSetSemiring.disjointOfUnion_subset_of_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nj : Set α\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\nhj : Membership.mem J j\n⊢ HasSubset.Subset (↑(hC.disjointOfUnion hJ j)).sUnion j","decl":"lemma disjointOfUnion_subset_of_mem (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) (hj : j ∈ J) :\n    ⋃₀ hC.disjointOfUnion hJ j ⊆ j :=\n  (Exists.choose_spec (hC.disjointOfUnion_props hJ)).2.2.2.1 j hj\n\n"}
{"name":"MeasureTheory.IsSetSemiring.subset_of_mem_disjointOfUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nj : Set α\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\nhj : Membership.mem J j\nx : Set α\nhx : Membership.mem (hC.disjointOfUnion hJ j) x\n⊢ HasSubset.Subset x j","decl":"lemma subset_of_mem_disjointOfUnion (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) (hj : j ∈ J) {x : Set α}\n    (hx : x ∈ (hC.disjointOfUnion hJ) j) : x ⊆ j :=\n  sUnion_subset_iff.mp (hC.disjointOfUnion_subset_of_mem hJ hj) x hx\n\n"}
{"name":"MeasureTheory.IsSetSemiring.empty_nmem_disjointOfUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nj : Set α\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\nhj : Membership.mem J j\n⊢ Not (Membership.mem (hC.disjointOfUnion hJ j) EmptyCollection.emptyCollection)","decl":"lemma empty_nmem_disjointOfUnion (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) (hj : j ∈ J) :\n    ∅ ∉ hC.disjointOfUnion hJ j :=\n  (Exists.choose_spec (hC.disjointOfUnion_props hJ)).2.2.2.2.1 j hj\n\n"}
{"name":"MeasureTheory.IsSetSemiring.sUnion_disjointOfUnion","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nJ : Finset (Set α)\nhC : MeasureTheory.IsSetSemiring C\nhJ : HasSubset.Subset (↑J) C\n⊢ Eq (Set.iUnion fun x => Set.iUnion fun h => ↑(hC.disjointOfUnion hJ x)).sUnion (↑J).sUnion","decl":"lemma sUnion_disjointOfUnion (hC : IsSetSemiring C) (hJ : ↑J ⊆ C) :\n    ⋃₀ ⋃ x ∈ J, (hC.disjointOfUnion hJ x : Set (Set α)) = ⋃₀ J :=\n    (Exists.choose_spec (hC.disjointOfUnion_props hJ)).2.2.2.2.2.symm\n\n"}
{"name":"MeasureTheory.IsSetRing.union_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.IsSetRing C\ns t : Set α\na✝¹ : Membership.mem C s\na✝ : Membership.mem C t\n⊢ Membership.mem C (Union.union s t)","decl":"/-- A ring of sets `C` is a family of sets containing `∅`, stable by union and set difference.\nIt is then also stable by intersection (see `IsSetRing.inter_mem`). -/\nstructure IsSetRing (C : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ C\n  union_mem ⦃s t⦄ : s ∈ C → t ∈ C → s ∪ t ∈ C\n  diff_mem ⦃s t⦄ : s ∈ C → t ∈ C → s \\ t ∈ C\n\n"}
{"name":"MeasureTheory.IsSetRing.diff_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.IsSetRing C\ns t : Set α\na✝¹ : Membership.mem C s\na✝ : Membership.mem C t\n⊢ Membership.mem C (SDiff.sdiff s t)","decl":"/-- A ring of sets `C` is a family of sets containing `∅`, stable by union and set difference.\nIt is then also stable by intersection (see `IsSetRing.inter_mem`). -/\nstructure IsSetRing (C : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ C\n  union_mem ⦃s t⦄ : s ∈ C → t ∈ C → s ∪ t ∈ C\n  diff_mem ⦃s t⦄ : s ∈ C → t ∈ C → s \\ t ∈ C\n\n"}
{"name":"MeasureTheory.IsSetRing.empty_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nself : MeasureTheory.IsSetRing C\n⊢ Membership.mem C EmptyCollection.emptyCollection","decl":"/-- A ring of sets `C` is a family of sets containing `∅`, stable by union and set difference.\nIt is then also stable by intersection (see `IsSetRing.inter_mem`). -/\nstructure IsSetRing (C : Set (Set α)) : Prop where\n  empty_mem : ∅ ∈ C\n  union_mem ⦃s t⦄ : s ∈ C → t ∈ C → s ∪ t ∈ C\n  diff_mem ⦃s t⦄ : s ∈ C → t ∈ C → s \\ t ∈ C\n\n"}
{"name":"MeasureTheory.IsSetRing.inter_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\ns t : Set α\nhC : MeasureTheory.IsSetRing C\nhs : Membership.mem C s\nht : Membership.mem C t\n⊢ Membership.mem C (Inter.inter s t)","decl":"lemma inter_mem (hC : IsSetRing C) (hs : s ∈ C) (ht : t ∈ C) : s ∩ t ∈ C := by\n  rw [← diff_diff_right_self]; exact hC.diff_mem hs (hC.diff_mem hs ht)\n\n"}
{"name":"MeasureTheory.IsSetRing.isSetSemiring","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetRing C\n⊢ MeasureTheory.IsSetSemiring C","decl":"lemma isSetSemiring (hC : IsSetRing C) : IsSetSemiring C where\n  empty_mem := hC.empty_mem\n  inter_mem := fun _ hs _ ht => hC.inter_mem hs ht\n  diff_eq_sUnion' := by\n    refine fun s hs t ht => ⟨{s \\ t}, ?_, ?_, ?_⟩\n    · simp only [coe_singleton, Set.singleton_subset_iff]\n      exact hC.diff_mem hs ht\n    · simp only [coe_singleton, pairwiseDisjoint_singleton]\n    · simp only [coe_singleton, sUnion_singleton]\n\n"}
{"name":"MeasureTheory.IsSetRing.biUnion_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nι : Type u_2\nhC : MeasureTheory.IsSetRing C\ns : ι → Set α\nS : Finset ι\nhs : ∀ (n : ι), Membership.mem S n → Membership.mem C (s n)\n⊢ Membership.mem C (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"lemma biUnion_mem {ι : Type*} (hC : IsSetRing C) {s : ι → Set α}\n    (S : Finset ι) (hs : ∀ n ∈ S, s n ∈ C) :\n    ⋃ i ∈ S, s i ∈ C := by\n  classical\n  induction S using Finset.induction with\n  | empty => simp [hC.empty_mem]\n  | @insert i S _ h =>\n    simp_rw [← Finset.mem_coe, Finset.coe_insert, Set.biUnion_insert]\n    refine hC.union_mem (hs i (mem_insert_self i S)) ?_\n    exact h (fun n hnS ↦ hs n (mem_insert_of_mem hnS))\n\n"}
{"name":"MeasureTheory.IsSetRing.biInter_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nι : Type u_2\nhC : MeasureTheory.IsSetRing C\ns : ι → Set α\nS : Finset ι\nhS : S.Nonempty\nhs : ∀ (n : ι), Membership.mem S n → Membership.mem C (s n)\n⊢ Membership.mem C (Set.iInter fun i => Set.iInter fun h => s i)","decl":"lemma biInter_mem {ι : Type*} (hC : IsSetRing C) {s : ι → Set α}\n    (S : Finset ι) (hS : S.Nonempty) (hs : ∀ n ∈ S, s n ∈ C) :\n    ⋂ i ∈ S, s i ∈ C := by\n  classical\n  induction hS using Finset.Nonempty.cons_induction with\n  | singleton => simpa using hs\n  | cons i S hiS _ h =>\n    simp_rw [← Finset.mem_coe, Finset.coe_cons, Set.biInter_insert]\n    simp only [cons_eq_insert, Finset.mem_insert, forall_eq_or_imp] at hs\n    refine hC.inter_mem hs.1 ?_\n    exact h (fun n hnS ↦ hs.2 n hnS)\n\n"}
{"name":"MeasureTheory.IsSetRing.finsetSup_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetRing C\nι : Type u_2\ns : ι → Set α\nt : Finset ι\nhs : ∀ (i : ι), Membership.mem t i → Membership.mem C (s i)\n⊢ Membership.mem C (t.sup s)","decl":"lemma finsetSup_mem (hC : IsSetRing C) {ι : Type*} {s : ι → Set α} {t : Finset ι}\n    (hs : ∀ i ∈ t, s i ∈ C) :\n    t.sup s ∈ C := by\n  classical\n  induction t using Finset.induction_on with\n  | empty => exact hC.empty_mem\n  | @insert m t hm ih =>\n    simpa only [sup_insert] using\n      hC.union_mem (hs m <| mem_insert_self m t) (ih <| fun i hi ↦ hs _ <| mem_insert_of_mem hi)\n\n"}
{"name":"MeasureTheory.IsSetRing.partialSups_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nι : Type u_2\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nhC : MeasureTheory.IsSetRing C\ns : ι → Set α\nhs : ∀ (n : ι), Membership.mem C (s n)\nn : ι\n⊢ Membership.mem C ((partialSups s) n)","decl":"lemma partialSups_mem {ι : Type*} [Preorder ι] [LocallyFiniteOrderBot ι]\n    (hC : IsSetRing C) {s : ι → Set α} (hs : ∀ n, s n ∈ C) (n : ι) :\n    partialSups s n ∈ C := by\n  simpa only [partialSups_apply, sup'_eq_sup] using hC.finsetSup_mem (fun i hi ↦ hs i)\n\n"}
{"name":"MeasureTheory.IsSetRing.disjointed_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nι : Type u_2\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nhC : MeasureTheory.IsSetRing C\ns : ι → Set α\nhs : ∀ (j : ι), Membership.mem C (s j)\ni : ι\n⊢ Membership.mem C (disjointed s i)","decl":"lemma disjointed_mem {ι : Type*} [Preorder ι] [LocallyFiniteOrderBot ι]\n    (hC : IsSetRing C) {s : ι → Set α} (hs : ∀ j, s j ∈ C) (i : ι) :\n    disjointed s i ∈ C :=\n  disjointedRec (fun _ j ht ↦ hC.diff_mem ht <| hs j) (hs i)\n\n"}
{"name":"MeasureTheory.IsSetRing.iUnion_le_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetRing C\ns : Nat → Set α\nhs : ∀ (n : Nat), Membership.mem C (s n)\nn : Nat\n⊢ Membership.mem C (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"theorem iUnion_le_mem (hC : IsSetRing C) {s : ℕ → Set α} (hs : ∀ n, s n ∈ C) (n : ℕ) :\n    (⋃ i ≤ n, s i) ∈ C := by\n  induction n with\n  | zero => simp [hs 0]\n  | succ n hn => rw [biUnion_le_succ]; exact hC.union_mem hn (hs _)\n\n"}
{"name":"MeasureTheory.IsSetRing.iInter_le_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetRing C\ns : Nat → Set α\nhs : ∀ (n : Nat), Membership.mem C (s n)\nn : Nat\n⊢ Membership.mem C (Set.iInter fun i => Set.iInter fun h => s i)","decl":"theorem iInter_le_mem (hC : IsSetRing C) {s : ℕ → Set α} (hs : ∀ n, s n ∈ C) (n : ℕ) :\n    (⋂ i ≤ n, s i) ∈ C := by\n  induction n with\n  | zero => simp [hs 0]\n  | succ n hn => rw [biInter_le_succ]; exact hC.inter_mem hn (hs _)\n\n"}
{"name":"MeasureTheory.IsSetRing.accumulate_mem","module":"Mathlib.MeasureTheory.SetSemiring","initialProofState":"α : Type u_1\nC : Set (Set α)\nhC : MeasureTheory.IsSetRing C\ns : Nat → Set α\nhs : ∀ (i : Nat), Membership.mem C (s i)\nn : Nat\n⊢ Membership.mem C (Set.Accumulate s n)","decl":"theorem accumulate_mem (hC : IsSetRing C) {s : ℕ → Set α} (hs : ∀ i, s i ∈ C) (n : ℕ) :\n    Accumulate s n ∈ C := by\n  induction n with\n  | zero => simp [hs 0]\n  | succ n hn => rw [accumulate_succ]; exact hC.union_mem hn (hs _)\n\n"}
