{"name":"NNReal.rpow_eq_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\n⊢ Eq (x.rpow y) (HPow.hPow x y)","decl":"@[simp]\ntheorem rpow_eq_pow (x : ℝ≥0) (y : ℝ) : rpow x y = x ^ y :=\n  rfl\n\n"}
{"name":"NNReal.coe_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\n⊢ Eq (↑(HPow.hPow x y)) (HPow.hPow (↑x) y)","decl":"@[simp, norm_cast]\ntheorem coe_rpow (x : ℝ≥0) (y : ℝ) : ((x ^ y : ℝ≥0) : ℝ) = (x : ℝ) ^ y :=\n  rfl\n\n"}
{"name":"NNReal.rpow_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\n⊢ Eq (HPow.hPow x 0) 1","decl":"@[simp]\ntheorem rpow_zero (x : ℝ≥0) : x ^ (0 : ℝ) = 1 :=\n  NNReal.eq <| Real.rpow_zero _\n\n"}
{"name":"NNReal.rpow_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\n⊢ Iff (Eq (HPow.hPow x y) 0) (And (Eq x 0) (Ne y 0))","decl":"@[simp]\ntheorem rpow_eq_zero_iff {x : ℝ≥0} {y : ℝ} : x ^ y = 0 ↔ x = 0 ∧ y ≠ 0 := by\n  rw [← NNReal.coe_inj, coe_rpow, ← NNReal.coe_eq_zero]\n  exact Real.rpow_eq_zero_iff_of_nonneg x.2\n\n"}
{"name":"NNReal.rpow_eq_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\nhy : Ne y 0\n⊢ Iff (Eq (HPow.hPow x y) 0) (Eq x 0)","decl":"lemma rpow_eq_zero (hy : y ≠ 0) : x ^ y = 0 ↔ x = 0 := by simp [hy]\n\n"}
{"name":"NNReal.zero_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nh : Ne x 0\n⊢ Eq (HPow.hPow 0 x) 0","decl":"@[simp]\ntheorem zero_rpow {x : ℝ} (h : x ≠ 0) : (0 : ℝ≥0) ^ x = 0 :=\n  NNReal.eq <| Real.zero_rpow h\n\n"}
{"name":"NNReal.rpow_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\n⊢ Eq (HPow.hPow x 1) x","decl":"@[simp]\ntheorem rpow_one (x : ℝ≥0) : x ^ (1 : ℝ) = x :=\n  NNReal.eq <| Real.rpow_one _\n\n"}
{"name":"NNReal.rpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\n⊢ Eq (HPow.hPow x (Neg.neg y)) (Inv.inv (HPow.hPow x y))","decl":"lemma rpow_neg (x : ℝ≥0) (y : ℝ) : x ^ (-y) = (x ^ y)⁻¹ :=\n  NNReal.eq <| Real.rpow_neg x.2 _\n\n"}
{"name":"NNReal.rpow_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Nat\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\nlemma rpow_natCast (x : ℝ≥0) (n : ℕ) : x ^ (n : ℝ) = x ^ n :=\n  NNReal.eq <| by simpa only [coe_rpow, coe_pow] using Real.rpow_natCast x n\n\n"}
{"name":"NNReal.rpow_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Int\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\nlemma rpow_intCast (x : ℝ≥0) (n : ℤ) : x ^ (n : ℝ) = x ^ n := by\n  cases n <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, rpow_natCast, zpow_natCast,\n    Int.cast_negSucc, rpow_neg, zpow_negSucc]\n\n"}
{"name":"NNReal.one_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\n⊢ Eq (HPow.hPow 1 x) 1","decl":"@[simp]\ntheorem one_rpow (x : ℝ) : (1 : ℝ≥0) ^ x = 1 :=\n  NNReal.eq <| Real.one_rpow _\n\n"}
{"name":"NNReal.rpow_add","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny z : Real\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add {x : ℝ≥0} (hx : x ≠ 0) (y z : ℝ) : x ^ (y + z) = x ^ y * x ^ z :=\n  NNReal.eq <| Real.rpow_add ((NNReal.coe_pos.trans pos_iff_ne_zero).mpr hx) _ _\n\n"}
{"name":"NNReal.rpow_add'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y z : Real\nh : Ne (HAdd.hAdd y z) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add' (h : y + z ≠ 0) (x : ℝ≥0) : x ^ (y + z) = x ^ y * x ^ z :=\n  NNReal.eq <| Real.rpow_add' x.2 h\n\n"}
{"name":"NNReal.rpow_add_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny : Real\nn : Int\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_intCast (hx : x ≠ 0) (y : ℝ) (n : ℤ) : x ^ (y + n) = x ^ y * x ^ n := by\n  ext; exact Real.rpow_add_intCast (mod_cast hx) _ _\n\n"}
{"name":"NNReal.rpow_add_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_natCast (hx : x ≠ 0) (y : ℝ) (n : ℕ) : x ^ (y + n) = x ^ y * x ^ n := by\n  ext; exact Real.rpow_add_natCast (mod_cast hx) _ _\n\n"}
{"name":"NNReal.rpow_sub_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_intCast (hx : x ≠ 0) (y : ℝ) (n : ℕ) : x ^ (y - n) = x ^ y / x ^ n := by\n  ext; exact Real.rpow_sub_intCast (mod_cast hx) _ _\n\n"}
{"name":"NNReal.rpow_sub_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_natCast (hx : x ≠ 0) (y : ℝ) (n : ℕ) : x ^ (y - n) = x ^ y / x ^ n := by\n  ext; exact Real.rpow_sub_natCast (mod_cast hx) _ _\n\n"}
{"name":"NNReal.rpow_add_intCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nn : Int\nh : Ne (HAdd.hAdd y ↑n) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_intCast' {n : ℤ} (h : y + n ≠ 0) (x : ℝ≥0) : x ^ (y + n) = x ^ y * x ^ n := by\n  ext; exact Real.rpow_add_intCast' (mod_cast x.2) h\n\n"}
{"name":"NNReal.rpow_add_natCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nn : Nat\nh : Ne (HAdd.hAdd y ↑n) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HAdd.hAdd y ↑n)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_add_natCast' {n : ℕ} (h : y + n ≠ 0) (x : ℝ≥0) : x ^ (y + n) = x ^ y * x ^ n := by\n  ext; exact Real.rpow_add_natCast' (mod_cast x.2) h\n\n"}
{"name":"NNReal.rpow_sub_intCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nn : Int\nh : Ne (HSub.hSub y ↑n) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_intCast' {n : ℤ} (h : y - n ≠ 0) (x : ℝ≥0) : x ^ (y - n) = x ^ y / x ^ n := by\n  ext; exact Real.rpow_sub_intCast' (mod_cast x.2) h\n\n"}
{"name":"NNReal.rpow_sub_natCast'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nn : Nat\nh : Ne (HSub.hSub y ↑n) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HSub.hSub y ↑n)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x n))","decl":"lemma rpow_sub_natCast' {n : ℕ} (h : y - n ≠ 0) (x : ℝ≥0) : x ^ (y - n) = x ^ y / x ^ n := by\n  ext; exact Real.rpow_sub_natCast' (mod_cast x.2) h\n\n"}
{"name":"NNReal.rpow_add_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny : Real\n⊢ Eq (HPow.hPow x (HAdd.hAdd y 1)) (HMul.hMul (HPow.hPow x y) x)","decl":"lemma rpow_add_one (hx : x ≠ 0) (y : ℝ) : x ^ (y + 1) = x ^ y * x := by\n  simpa using rpow_add_natCast hx y 1\n\n"}
{"name":"NNReal.rpow_sub_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny : Real\n⊢ Eq (HPow.hPow x (HSub.hSub y 1)) (HDiv.hDiv (HPow.hPow x y) x)","decl":"lemma rpow_sub_one (hx : x ≠ 0) (y : ℝ) : x ^ (y - 1) = x ^ y / x := by\n  simpa using rpow_sub_natCast hx y 1\n\n"}
{"name":"NNReal.rpow_add_one'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : Ne (HAdd.hAdd y 1) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HAdd.hAdd y 1)) (HMul.hMul (HPow.hPow x y) x)","decl":"lemma rpow_add_one' (h : y + 1 ≠ 0) (x : ℝ≥0) : x ^ (y + 1) = x ^ y * x := by\n  rw [rpow_add' h, rpow_one]\n\n"}
{"name":"NNReal.rpow_one_add'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : Ne (HAdd.hAdd 1 y) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HAdd.hAdd 1 y)) (HMul.hMul x (HPow.hPow x y))","decl":"lemma rpow_one_add' (h : 1 + y ≠ 0) (x : ℝ≥0) : x ^ (1 + y) = x * x ^ y := by\n  rw [rpow_add' h, rpow_one]\n\n"}
{"name":"NNReal.rpow_add_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny z : Real\nhy : LE.le 0 y\nhz : LE.le 0 z\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add_of_nonneg (x : ℝ≥0) {y z : ℝ} (hy : 0 ≤ y) (hz : 0 ≤ z) :\n    x ^ (y + z) = x ^ y * x ^ z := by\n  ext; exact Real.rpow_add_of_nonneg x.2 hy hz\n\n"}
{"name":"NNReal.rpow_of_add_eq","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"w y z : Real\nx : NNReal\nhw : Ne w 0\nh : Eq (HAdd.hAdd y z) w\n⊢ Eq (HPow.hPow x w) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"/-- Variant of `NNReal.rpow_add'` that avoids having to prove `y + z = w` twice. -/\nlemma rpow_of_add_eq (x : ℝ≥0) (hw : w ≠ 0) (h : y + z = w) : x ^ w = x ^ y * x ^ z := by\n  rw [← h, rpow_add']; rwa [h]\n\n"}
{"name":"NNReal.rpow_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny z : Real\n⊢ Eq (HPow.hPow x (HMul.hMul y z)) (HPow.hPow (HPow.hPow x y) z)","decl":"theorem rpow_mul (x : ℝ≥0) (y z : ℝ) : x ^ (y * z) = (x ^ y) ^ z :=\n  NNReal.eq <| Real.rpow_mul x.2 y z\n\n"}
{"name":"NNReal.rpow_natCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Nat\nz : Real\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) z)) (HPow.hPow (HPow.hPow x n) z)","decl":"lemma rpow_natCast_mul (x : ℝ≥0) (n : ℕ) (z : ℝ) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul, rpow_natCast]\n\n"}
{"name":"NNReal.rpow_mul_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma rpow_mul_natCast (x : ℝ≥0) (y : ℝ) (n : ℕ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul, rpow_natCast]\n\n"}
{"name":"NNReal.rpow_intCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Int\nz : Real\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) z)) (HPow.hPow (HPow.hPow x n) z)","decl":"lemma rpow_intCast_mul (x : ℝ≥0) (n : ℤ) (z : ℝ) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul, rpow_intCast]\n\n"}
{"name":"NNReal.rpow_mul_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\nn : Int\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma rpow_mul_intCast (x : ℝ≥0) (y : ℝ) (n : ℤ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul, rpow_intCast]\n\n"}
{"name":"NNReal.rpow_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\n⊢ Eq (HPow.hPow x (-1)) (Inv.inv x)","decl":"theorem rpow_neg_one (x : ℝ≥0) : x ^ (-1 : ℝ) = x⁻¹ := by simp [rpow_neg]\n\n"}
{"name":"NNReal.rpow_sub","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nhx : Ne x 0\ny z : Real\n⊢ Eq (HPow.hPow x (HSub.hSub y z)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_sub {x : ℝ≥0} (hx : x ≠ 0) (y z : ℝ) : x ^ (y - z) = x ^ y / x ^ z :=\n  NNReal.eq <| Real.rpow_sub ((NNReal.coe_pos.trans pos_iff_ne_zero).mpr hx) y z\n\n"}
{"name":"NNReal.rpow_sub'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y z : Real\nh : Ne (HSub.hSub y z) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HSub.hSub y z)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_sub' (h : y - z ≠ 0) (x : ℝ≥0) : x ^ (y - z) = x ^ y / x ^ z :=\n  NNReal.eq <| Real.rpow_sub' x.2 h\n\n"}
{"name":"NNReal.rpow_sub_one'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : Ne (HSub.hSub y 1) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HSub.hSub y 1)) (HDiv.hDiv (HPow.hPow x y) x)","decl":"lemma rpow_sub_one' (h : y - 1 ≠ 0) (x : ℝ≥0) : x ^ (y - 1) = x ^ y / x := by\n  rw [rpow_sub' h, rpow_one]\n\n"}
{"name":"NNReal.rpow_one_sub'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : Ne (HSub.hSub 1 y) 0\nx : NNReal\n⊢ Eq (HPow.hPow x (HSub.hSub 1 y)) (HDiv.hDiv x (HPow.hPow x y))","decl":"lemma rpow_one_sub' (h : 1 - y ≠ 0) (x : ℝ≥0) : x ^ (1 - y) = x / x ^ y := by\n  rw [rpow_sub' h, rpow_one]\n\n"}
{"name":"NNReal.rpow_inv_rpow_self","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : Ne y 0\nx : NNReal\n⊢ Eq (HPow.hPow (HPow.hPow x y) (HDiv.hDiv 1 y)) x","decl":"theorem rpow_inv_rpow_self {y : ℝ} (hy : y ≠ 0) (x : ℝ≥0) : (x ^ y) ^ (1 / y) = x := by\n  field_simp [← rpow_mul]\n\n"}
{"name":"NNReal.rpow_self_rpow_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : Ne y 0\nx : NNReal\n⊢ Eq (HPow.hPow (HPow.hPow x (HDiv.hDiv 1 y)) y) x","decl":"theorem rpow_self_rpow_inv {y : ℝ} (hy : y ≠ 0) (x : ℝ≥0) : (x ^ (1 / y)) ^ y = x := by\n  field_simp [← rpow_mul]\n\n"}
{"name":"NNReal.inv_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\n⊢ Eq (HPow.hPow (Inv.inv x) y) (Inv.inv (HPow.hPow x y))","decl":"theorem inv_rpow (x : ℝ≥0) (y : ℝ) : x⁻¹ ^ y = (x ^ y)⁻¹ :=\n  NNReal.eq <| Real.inv_rpow x.2 y\n\n"}
{"name":"NNReal.div_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\n⊢ Eq (HPow.hPow (HDiv.hDiv x y) z) (HDiv.hDiv (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem div_rpow (x y : ℝ≥0) (z : ℝ) : (x / y) ^ z = x ^ z / y ^ z :=\n  NNReal.eq <| Real.div_rpow x.2 y.2 z\n\n"}
{"name":"NNReal.sqrt_eq_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\n⊢ Eq (NNReal.sqrt x) (HPow.hPow x (1 / 2))","decl":"theorem sqrt_eq_rpow (x : ℝ≥0) : sqrt x = x ^ (1 / (2 : ℝ)) := by\n  refine NNReal.eq ?_\n  push_cast\n  exact Real.sqrt_eq_rpow x.1\n\n"}
{"name":"NNReal.rpow_ofNat","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HPow.hPow x (OfNat.ofNat n)) (HPow.hPow x (OfNat.ofNat n))","decl":"@[simp]\nlemma rpow_ofNat (x : ℝ≥0) (n : ℕ) [n.AtLeastTwo] :\n    x ^ (ofNat(n) : ℝ) = x ^ (OfNat.ofNat n : ℕ) :=\n  rpow_natCast x n\n\n"}
{"name":"NNReal.rpow_two","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\n⊢ Eq (HPow.hPow x 2) (HPow.hPow x 2)","decl":"theorem rpow_two (x : ℝ≥0) : x ^ (2 : ℝ) = x ^ 2 := rpow_ofNat x 2\n\n"}
{"name":"NNReal.mul_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\n⊢ Eq (HPow.hPow (HMul.hMul x y) z) (HMul.hMul (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem mul_rpow {x y : ℝ≥0} {z : ℝ} : (x * y) ^ z = x ^ z * y ^ z :=\n  NNReal.eq <| Real.mul_rpow x.2 y.2\n\n"}
{"name":"NNReal.rpowMonoidHom_apply","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"r : Real\nx✝ : NNReal\n⊢ Eq ((NNReal.rpowMonoidHom r) x✝) (HPow.hPow x✝ r)","decl":"/-- `rpow` as a `MonoidHom`-/\n@[simps]\ndef rpowMonoidHom (r : ℝ) : ℝ≥0 →* ℝ≥0 where\n  toFun := (· ^ r)\n  map_one' := one_rpow _\n  map_mul' _x _y := mul_rpow\n\n"}
{"name":"NNReal.list_prod_map_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"l : List NNReal\nr : Real\n⊢ Eq (List.map (fun x => HPow.hPow x r) l).prod (HPow.hPow l.prod r)","decl":"/-- `rpow` variant of `List.prod_map_pow` for `ℝ≥0`-/\ntheorem list_prod_map_rpow (l : List ℝ≥0) (r : ℝ) :\n    (l.map (· ^ r)).prod = l.prod ^ r :=\n  l.prod_hom (rpowMonoidHom r)\n\n"}
{"name":"NNReal.list_prod_map_rpow'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\nl : List ι\nf : ι → NNReal\nr : Real\n⊢ Eq (List.map (fun x => HPow.hPow (f x) r) l).prod (HPow.hPow (List.map f l).prod r)","decl":"theorem list_prod_map_rpow' {ι} (l : List ι) (f : ι → ℝ≥0) (r : ℝ) :\n    (l.map (f · ^ r)).prod = (l.map f).prod ^ r := by\n  rw [← list_prod_map_rpow, List.map_map]; rfl\n\n"}
{"name":"NNReal.multiset_prod_map_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Multiset ι\nf : ι → NNReal\nr : Real\n⊢ Eq (Multiset.map (fun x => HPow.hPow (f x) r) s).prod (HPow.hPow (Multiset.map f s).prod r)","decl":"/-- `rpow` version of `Multiset.prod_map_pow` for `ℝ≥0`. -/\nlemma multiset_prod_map_rpow {ι} (s : Multiset ι) (f : ι → ℝ≥0) (r : ℝ) :\n    (s.map (f · ^ r)).prod = (s.map f).prod ^ r :=\n  s.prod_hom' (rpowMonoidHom r) _\n\n"}
{"name":"NNReal.finset_prod_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → NNReal\nr : Real\n⊢ Eq (s.prod fun i => HPow.hPow (f i) r) (HPow.hPow (s.prod fun i => f i) r)","decl":"/-- `rpow` version of `Finset.prod_pow` for `ℝ≥0`. -/\nlemma finset_prod_rpow {ι} (s : Finset ι) (f : ι → ℝ≥0) (r : ℝ) :\n    (∏ i ∈ s, f i ^ r) = (∏ i ∈ s, f i) ^ r :=\n  multiset_prod_map_rpow _ _ _\n\n-- note: these don't really belong here, but they're much easier to prove in terms of the above\n\n"}
{"name":"Real.list_prod_map_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"l : List Real\nhl : ∀ (x : Real), Membership.mem l x → LE.le 0 x\nr : Real\n⊢ Eq (List.map (fun x => HPow.hPow x r) l).prod (HPow.hPow l.prod r)","decl":"/-- `rpow` version of `List.prod_map_pow` for `Real`. -/\ntheorem _root_.Real.list_prod_map_rpow (l : List ℝ) (hl : ∀ x ∈ l, (0 : ℝ) ≤ x) (r : ℝ) :\n    (l.map (· ^ r)).prod = l.prod ^ r := by\n  lift l to List ℝ≥0 using hl\n  have := congr_arg ((↑) : ℝ≥0 → ℝ) (NNReal.list_prod_map_rpow l r)\n  push_cast at this\n  rw [List.map_map] at this ⊢\n  exact mod_cast this\n\n"}
{"name":"Real.list_prod_map_rpow'","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\nl : List ι\nf : ι → Real\nhl : ∀ (i : ι), Membership.mem l i → LE.le 0 (f i)\nr : Real\n⊢ Eq (List.map (fun x => HPow.hPow (f x) r) l).prod (HPow.hPow (List.map f l).prod r)","decl":"theorem _root_.Real.list_prod_map_rpow' {ι} (l : List ι) (f : ι → ℝ)\n    (hl : ∀ i ∈ l, (0 : ℝ) ≤ f i) (r : ℝ) :\n    (l.map (f · ^ r)).prod = (l.map f).prod ^ r := by\n  rw [← Real.list_prod_map_rpow (l.map f) _ r, List.map_map]\n  · rfl\n  simpa using hl\n\n"}
{"name":"Real.multiset_prod_map_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Multiset ι\nf : ι → Real\nhs : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nr : Real\n⊢ Eq (Multiset.map (fun x => HPow.hPow (f x) r) s).prod (HPow.hPow (Multiset.map f s).prod r)","decl":"/-- `rpow` version of `Multiset.prod_map_pow`. -/\ntheorem _root_.Real.multiset_prod_map_rpow {ι} (s : Multiset ι) (f : ι → ℝ)\n    (hs : ∀ i ∈ s, (0 : ℝ) ≤ f i) (r : ℝ) :\n    (s.map (f · ^ r)).prod = (s.map f).prod ^ r := by\n  induction' s using Quotient.inductionOn with l\n  simpa using Real.list_prod_map_rpow' l f hs r\n\n"}
{"name":"Real.finset_prod_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → Real\nhs : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nr : Real\n⊢ Eq (s.prod fun i => HPow.hPow (f i) r) (HPow.hPow (s.prod fun i => f i) r)","decl":"/-- `rpow` version of `Finset.prod_pow`. -/\ntheorem _root_.Real.finset_prod_rpow\n    {ι} (s : Finset ι) (f : ι → ℝ) (hs : ∀ i ∈ s, 0 ≤ f i) (r : ℝ) :\n    (∏ i ∈ s, f i ^ r) = (∏ i ∈ s, f i) ^ r :=\n  Real.multiset_prod_map_rpow s.val f hs r\n\n"}
{"name":"NNReal.rpow_le_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nh₁ : LE.le x y\nh₂ : LE.le 0 z\n⊢ LE.le (HPow.hPow x z) (HPow.hPow y z)","decl":"@[gcongr] theorem rpow_le_rpow {x y : ℝ≥0} {z : ℝ} (h₁ : x ≤ y) (h₂ : 0 ≤ z) : x ^ z ≤ y ^ z :=\n  Real.rpow_le_rpow x.2 h₁ h₂\n\n"}
{"name":"NNReal.rpow_lt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nh₁ : LT.lt x y\nh₂ : LT.lt 0 z\n⊢ LT.lt (HPow.hPow x z) (HPow.hPow y z)","decl":"@[gcongr] theorem rpow_lt_rpow {x y : ℝ≥0} {z : ℝ} (h₁ : x < y) (h₂ : 0 < z) : x ^ z < y ^ z :=\n  Real.rpow_lt_rpow x.2 h₁ h₂\n\n"}
{"name":"NNReal.rpow_lt_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LT.lt (HPow.hPow x z) (HPow.hPow y z)) (LT.lt x y)","decl":"theorem rpow_lt_rpow_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x ^ z < y ^ z ↔ x < y :=\n  Real.rpow_lt_rpow_iff x.2 y.2 hz\n\n"}
{"name":"NNReal.rpow_le_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LE.le (HPow.hPow x z) (HPow.hPow y z)) (LE.le x y)","decl":"theorem rpow_le_rpow_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x ^ z ≤ y ^ z ↔ x ≤ y :=\n  Real.rpow_le_rpow_iff x.2 y.2 hz\n\n"}
{"name":"NNReal.le_rpow_inv_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LE.le x (HPow.hPow y (Inv.inv z))) (LE.le (HPow.hPow x z) y)","decl":"theorem le_rpow_inv_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x ≤ y ^ z⁻¹ ↔ x ^ z ≤ y := by\n  rw [← rpow_le_rpow_iff hz, ← one_div, rpow_self_rpow_inv hz.ne']\n\n"}
{"name":"NNReal.rpow_inv_le_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LE.le (HPow.hPow x (Inv.inv z)) y) (LE.le x (HPow.hPow y z))","decl":"theorem rpow_inv_le_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x ^ z⁻¹ ≤ y ↔ x ≤ y ^ z := by\n  rw [← rpow_le_rpow_iff hz, ← one_div, rpow_self_rpow_inv hz.ne']\n\n"}
{"name":"NNReal.lt_rpow_inv_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LT.lt x (HPow.hPow y (Inv.inv z))) (LT.lt (HPow.hPow x z) y)","decl":"theorem lt_rpow_inv_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x < y ^ z⁻¹ ↔ x ^z < y := by\n  simp only [← not_le, rpow_inv_le_iff hz]\n\n"}
{"name":"NNReal.rpow_inv_lt_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LT.lt (HPow.hPow x (Inv.inv z)) y) (LT.lt x (HPow.hPow y z))","decl":"theorem rpow_inv_lt_iff {x y : ℝ≥0} {z : ℝ} (hz : 0 < z) : x ^ z⁻¹ < y ↔ x < y ^ z := by\n  simp only [← not_le, le_rpow_inv_iff hz]\n\n"}
{"name":"NNReal.rpow_lt_rpow_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhxy : LT.lt x y\nhz : LT.lt z 0\n⊢ LT.lt (HPow.hPow y z) (HPow.hPow x z)","decl":"lemma rpow_lt_rpow_of_neg (hx : 0 < x) (hxy : x < y) (hz : z < 0) : y ^ z < x ^ z :=\n  Real.rpow_lt_rpow_of_neg hx hxy hz\n\n"}
{"name":"NNReal.rpow_le_rpow_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhxy : LE.le x y\nhz : LE.le z 0\n⊢ LE.le (HPow.hPow y z) (HPow.hPow x z)","decl":"lemma rpow_le_rpow_of_nonpos (hx : 0 < x) (hxy : x ≤ y) (hz : z ≤ 0) : y ^ z ≤ x ^ z :=\n  Real.rpow_le_rpow_of_nonpos hx hxy hz\n\n"}
{"name":"NNReal.rpow_lt_rpow_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LT.lt (HPow.hPow x z) (HPow.hPow y z)) (LT.lt y x)","decl":"lemma rpow_lt_rpow_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ^ z < y ^ z ↔ y < x :=\n  Real.rpow_lt_rpow_iff_of_neg hx hy hz\n\n"}
{"name":"NNReal.rpow_le_rpow_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LE.le (HPow.hPow x z) (HPow.hPow y z)) (LE.le y x)","decl":"lemma rpow_le_rpow_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ^ z ≤ y ^ z ↔ y ≤ x :=\n  Real.rpow_le_rpow_iff_of_neg hx hy hz\n\n"}
{"name":"NNReal.le_rpow_inv_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\ny : NNReal\nhy : LE.le 0 y\nhz : LT.lt 0 z\nx : NNReal\n⊢ Iff (LE.le x (HPow.hPow y (Inv.inv z))) (LE.le (HPow.hPow x z) y)","decl":"lemma le_rpow_inv_iff_of_pos (hy : 0 ≤ y) (hz : 0 < z) (x : ℝ≥0) : x ≤ y ^ z⁻¹ ↔ x ^ z ≤ y :=\n  Real.le_rpow_inv_iff_of_pos x.2 hy hz\n\n"}
{"name":"NNReal.rpow_inv_le_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\ny : NNReal\nhy : LE.le 0 y\nhz : LT.lt 0 z\nx : NNReal\n⊢ Iff (LE.le (HPow.hPow x (Inv.inv z)) y) (LE.le x (HPow.hPow y z))","decl":"lemma rpow_inv_le_iff_of_pos (hy : 0 ≤ y) (hz : 0 < z) (x : ℝ≥0) : x ^ z⁻¹ ≤ y ↔ x ≤ y ^ z :=\n  Real.rpow_inv_le_iff_of_pos x.2 hy hz\n\n"}
{"name":"NNReal.lt_rpow_inv_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\ny : NNReal\nhy : LE.le 0 y\nhz : LT.lt 0 z\nx : NNReal\n⊢ Iff (LT.lt x (HPow.hPow y (Inv.inv z))) (LT.lt (HPow.hPow x z) y)","decl":"lemma lt_rpow_inv_iff_of_pos (hy : 0 ≤ y) (hz : 0 < z) (x : ℝ≥0) : x < y ^ z⁻¹ ↔ x ^ z < y :=\n  Real.lt_rpow_inv_iff_of_pos x.2 hy hz\n\n"}
{"name":"NNReal.rpow_inv_lt_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\ny : NNReal\nhy : LE.le 0 y\nhz : LT.lt 0 z\nx : NNReal\n⊢ Iff (LT.lt (HPow.hPow x (Inv.inv z)) y) (LT.lt x (HPow.hPow y z))","decl":"lemma rpow_inv_lt_iff_of_pos (hy : 0 ≤ y) (hz : 0 < z) (x : ℝ≥0) : x ^ z⁻¹ < y ↔ x < y ^ z :=\n  Real.rpow_inv_lt_iff_of_pos x.2 hy hz\n\n"}
{"name":"NNReal.le_rpow_inv_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LE.le x (HPow.hPow y (Inv.inv z))) (LE.le y (HPow.hPow x z))","decl":"lemma le_rpow_inv_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ≤ y ^ z⁻¹ ↔ y ≤ x ^ z :=\n  Real.le_rpow_inv_iff_of_neg hx hy hz\n\n"}
{"name":"NNReal.lt_rpow_inv_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LT.lt x (HPow.hPow y (Inv.inv z))) (LT.lt y (HPow.hPow x z))","decl":"lemma lt_rpow_inv_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x < y ^ z⁻¹ ↔ y < x ^ z :=\n  Real.lt_rpow_inv_iff_of_neg hx hy hz\n\n"}
{"name":"NNReal.rpow_inv_lt_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LT.lt (HPow.hPow x (Inv.inv z)) y) (LT.lt (HPow.hPow y z) x)","decl":"lemma rpow_inv_lt_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ^ z⁻¹ < y ↔ y ^ z < x :=\n  Real.rpow_inv_lt_iff_of_neg hx hy hz\n\n"}
{"name":"NNReal.rpow_inv_le_iff_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\ny : NNReal\nhx : LT.lt 0 x\nhy : LT.lt 0 y\nhz : LT.lt z 0\n⊢ Iff (LE.le (HPow.hPow x (Inv.inv z)) y) (LE.le (HPow.hPow y z) x)","decl":"lemma rpow_inv_le_iff_of_neg (hx : 0 < x) (hy : 0 < y) (hz : z < 0) : x ^ z⁻¹ ≤ y ↔ y ^ z ≤ x :=\n  Real.rpow_inv_le_iff_of_neg hx hy hz\n\n"}
{"name":"NNReal.rpow_lt_rpow_of_exponent_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny z : Real\nhx : LT.lt 1 x\nhyz : LT.lt y z\n⊢ LT.lt (HPow.hPow x y) (HPow.hPow x z)","decl":"@[gcongr] theorem rpow_lt_rpow_of_exponent_lt {x : ℝ≥0} {y z : ℝ} (hx : 1 < x) (hyz : y < z) :\n    x ^ y < x ^ z :=\n  Real.rpow_lt_rpow_of_exponent_lt hx hyz\n\n"}
{"name":"NNReal.rpow_le_rpow_of_exponent_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny z : Real\nhx : LE.le 1 x\nhyz : LE.le y z\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"@[gcongr] theorem rpow_le_rpow_of_exponent_le {x : ℝ≥0} {y z : ℝ} (hx : 1 ≤ x) (hyz : y ≤ z) :\n    x ^ y ≤ x ^ z :=\n  Real.rpow_le_rpow_of_exponent_le hx hyz\n\n"}
{"name":"NNReal.rpow_lt_rpow_of_exponent_gt","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny z : Real\nhx0 : LT.lt 0 x\nhx1 : LT.lt x 1\nhyz : LT.lt z y\n⊢ LT.lt (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_lt_rpow_of_exponent_gt {x : ℝ≥0} {y z : ℝ} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :\n    x ^ y < x ^ z :=\n  Real.rpow_lt_rpow_of_exponent_gt hx0 hx1 hyz\n\n"}
{"name":"NNReal.rpow_le_rpow_of_exponent_ge","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny z : Real\nhx0 : LT.lt 0 x\nhx1 : LE.le x 1\nhyz : LE.le z y\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_le_rpow_of_exponent_ge {x : ℝ≥0} {y z : ℝ} (hx0 : 0 < x) (hx1 : x ≤ 1) (hyz : z ≤ y) :\n    x ^ y ≤ x ^ z :=\n  Real.rpow_le_rpow_of_exponent_ge hx0 hx1 hyz\n\n"}
{"name":"NNReal.rpow_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"p : Real\nx : NNReal\nhx_pos : LT.lt 0 x\n⊢ LT.lt 0 (HPow.hPow x p)","decl":"theorem rpow_pos {p : ℝ} {x : ℝ≥0} (hx_pos : 0 < x) : 0 < x ^ p := by\n  have rpow_pos_of_nonneg : ∀ {p : ℝ}, 0 < p → 0 < x ^ p := by\n    intro p hp_pos\n    rw [← zero_rpow hp_pos.ne']\n    exact rpow_lt_rpow hx_pos hp_pos\n  rcases lt_trichotomy (0 : ℝ) p with (hp_pos | rfl | hp_neg)\n  · exact rpow_pos_of_nonneg hp_pos\n  · simp only [zero_lt_one, rpow_zero]\n  · rw [← neg_neg p, rpow_neg, inv_pos]\n    exact rpow_pos_of_nonneg (neg_pos.mpr hp_neg)\n\n"}
{"name":"NNReal.rpow_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx1 : LT.lt x 1\nhz : LT.lt 0 z\n⊢ LT.lt (HPow.hPow x z) 1","decl":"theorem rpow_lt_one {x : ℝ≥0} {z : ℝ} (hx1 : x < 1) (hz : 0 < z) : x ^ z < 1 :=\n  Real.rpow_lt_one (coe_nonneg x) hx1 hz\n\n"}
{"name":"NNReal.rpow_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx2 : LE.le x 1\nhz : LE.le 0 z\n⊢ LE.le (HPow.hPow x z) 1","decl":"theorem rpow_le_one {x : ℝ≥0} {z : ℝ} (hx2 : x ≤ 1) (hz : 0 ≤ z) : x ^ z ≤ 1 :=\n  Real.rpow_le_one x.2 hx2 hz\n\n"}
{"name":"NNReal.rpow_lt_one_of_one_lt_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx : LT.lt 1 x\nhz : LT.lt z 0\n⊢ LT.lt (HPow.hPow x z) 1","decl":"theorem rpow_lt_one_of_one_lt_of_neg {x : ℝ≥0} {z : ℝ} (hx : 1 < x) (hz : z < 0) : x ^ z < 1 :=\n  Real.rpow_lt_one_of_one_lt_of_neg hx hz\n\n"}
{"name":"NNReal.rpow_le_one_of_one_le_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx : LE.le 1 x\nhz : LE.le z 0\n⊢ LE.le (HPow.hPow x z) 1","decl":"theorem rpow_le_one_of_one_le_of_nonpos {x : ℝ≥0} {z : ℝ} (hx : 1 ≤ x) (hz : z ≤ 0) : x ^ z ≤ 1 :=\n  Real.rpow_le_one_of_one_le_of_nonpos hx hz\n\n"}
{"name":"NNReal.one_lt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx : LT.lt 1 x\nhz : LT.lt 0 z\n⊢ LT.lt 1 (HPow.hPow x z)","decl":"theorem one_lt_rpow {x : ℝ≥0} {z : ℝ} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z :=\n  Real.one_lt_rpow hx hz\n\n"}
{"name":"NNReal.one_le_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nh : LE.le 1 x\nh₁ : LE.le 0 z\n⊢ LE.le 1 (HPow.hPow x z)","decl":"theorem one_le_rpow {x : ℝ≥0} {z : ℝ} (h : 1 ≤ x) (h₁ : 0 ≤ z) : 1 ≤ x ^ z :=\n  Real.one_le_rpow h h₁\n\n"}
{"name":"NNReal.one_lt_rpow_of_pos_of_lt_one_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx1 : LT.lt 0 x\nhx2 : LT.lt x 1\nhz : LT.lt z 0\n⊢ LT.lt 1 (HPow.hPow x z)","decl":"theorem one_lt_rpow_of_pos_of_lt_one_of_neg {x : ℝ≥0} {z : ℝ} (hx1 : 0 < x) (hx2 : x < 1)\n    (hz : z < 0) : 1 < x ^ z :=\n  Real.one_lt_rpow_of_pos_of_lt_one_of_neg hx1 hx2 hz\n\n"}
{"name":"NNReal.one_le_rpow_of_pos_of_le_one_of_nonpos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx1 : LT.lt 0 x\nhx2 : LE.le x 1\nhz : LE.le z 0\n⊢ LE.le 1 (HPow.hPow x z)","decl":"theorem one_le_rpow_of_pos_of_le_one_of_nonpos {x : ℝ≥0} {z : ℝ} (hx1 : 0 < x) (hx2 : x ≤ 1)\n    (hz : z ≤ 0) : 1 ≤ x ^ z :=\n  Real.one_le_rpow_of_pos_of_le_one_of_nonpos hx1 hx2 hz\n\n"}
{"name":"NNReal.rpow_le_self_of_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nz : Real\nhx : LE.le x 1\nh_one_le : LE.le 1 z\n⊢ LE.le (HPow.hPow x z) x","decl":"theorem rpow_le_self_of_le_one {x : ℝ≥0} {z : ℝ} (hx : x ≤ 1) (h_one_le : 1 ≤ z) : x ^ z ≤ x := by\n  rcases eq_bot_or_bot_lt x with (rfl | (h : 0 < x))\n  · have : z ≠ 0 := by linarith\n    simp [this]\n  nth_rw 2 [← NNReal.rpow_one x]\n  exact NNReal.rpow_le_rpow_of_exponent_ge h hx h_one_le\n\n"}
{"name":"NNReal.rpow_left_injective","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Function.Injective fun y => HPow.hPow y x","decl":"theorem rpow_left_injective {x : ℝ} (hx : x ≠ 0) : Function.Injective fun y : ℝ≥0 => y ^ x :=\n  fun y z hyz => by simpa only [rpow_inv_rpow_self hx] using congr_arg (fun y => y ^ (1 / x)) hyz\n\n"}
{"name":"NNReal.rpow_eq_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : Ne z 0\n⊢ Iff (Eq (HPow.hPow x z) (HPow.hPow y z)) (Eq x y)","decl":"theorem rpow_eq_rpow_iff {x y : ℝ≥0} {z : ℝ} (hz : z ≠ 0) : x ^ z = y ^ z ↔ x = y :=\n  (rpow_left_injective hz).eq_iff\n\n"}
{"name":"NNReal.rpow_left_surjective","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Function.Surjective fun y => HPow.hPow y x","decl":"theorem rpow_left_surjective {x : ℝ} (hx : x ≠ 0) : Function.Surjective fun y : ℝ≥0 => y ^ x :=\n  fun y => ⟨y ^ x⁻¹, by simp_rw [← rpow_mul, inv_mul_cancel₀ hx, rpow_one]⟩\n\n"}
{"name":"NNReal.rpow_left_bijective","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Function.Bijective fun y => HPow.hPow y x","decl":"theorem rpow_left_bijective {x : ℝ} (hx : x ≠ 0) : Function.Bijective fun y : ℝ≥0 => y ^ x :=\n  ⟨rpow_left_injective hx, rpow_left_surjective hx⟩\n\n"}
{"name":"NNReal.eq_rpow_inv_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : Ne z 0\n⊢ Iff (Eq x (HPow.hPow y (Inv.inv z))) (Eq (HPow.hPow x z) y)","decl":"theorem eq_rpow_inv_iff {x y : ℝ≥0} {z : ℝ} (hz : z ≠ 0) : x = y ^ z⁻¹ ↔ x ^ z = y := by\n  rw [← rpow_eq_rpow_iff hz, ← one_div, rpow_self_rpow_inv hz]\n\n"}
{"name":"NNReal.rpow_inv_eq_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\nhz : Ne z 0\n⊢ Iff (Eq (HPow.hPow x (Inv.inv z)) y) (Eq x (HPow.hPow y z))","decl":"theorem rpow_inv_eq_iff {x y : ℝ≥0} {z : ℝ} (hz : z ≠ 0) : x ^ z⁻¹ = y ↔ x = y ^ z := by\n  rw [← rpow_eq_rpow_iff hz, ← one_div, rpow_self_rpow_inv hz]\n\n"}
{"name":"NNReal.rpow_rpow_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : Ne y 0\nx : NNReal\n⊢ Eq (HPow.hPow (HPow.hPow x y) (Inv.inv y)) x","decl":"@[simp] lemma rpow_rpow_inv {y : ℝ} (hy : y ≠ 0) (x : ℝ≥0) : (x ^ y) ^ y⁻¹ = x := by\n  rw [← rpow_mul, mul_inv_cancel₀ hy, rpow_one]\n\n"}
{"name":"NNReal.rpow_inv_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : Ne y 0\nx : NNReal\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv y)) y) x","decl":"@[simp] lemma rpow_inv_rpow {y : ℝ} (hy : y ≠ 0) (x : ℝ≥0) : (x ^ y⁻¹) ^ y = x := by\n  rw [← rpow_mul, inv_mul_cancel₀ hy, rpow_one]\n\n"}
{"name":"NNReal.pow_rpow_inv_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow (HPow.hPow x n) (Inv.inv ↑n)) x","decl":"theorem pow_rpow_inv_natCast (x : ℝ≥0) {n : ℕ} (hn : n ≠ 0) : (x ^ n) ^ (n⁻¹ : ℝ) = x := by\n  rw [← NNReal.coe_inj, coe_rpow, NNReal.coe_pow]\n  exact Real.pow_rpow_inv_natCast x.2 hn\n\n"}
{"name":"NNReal.rpow_inv_natCast_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nn : Nat\nhn : Ne n 0\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv ↑n)) n) x","decl":"theorem rpow_inv_natCast_pow (x : ℝ≥0) {n : ℕ} (hn : n ≠ 0) : (x ^ (n⁻¹ : ℝ)) ^ n = x := by\n  rw [← NNReal.coe_inj, NNReal.coe_pow, coe_rpow]\n  exact Real.rpow_inv_natCast_pow x.2 hn\n\n"}
{"name":"Real.toNNReal_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Eq (HPow.hPow x y).toNNReal (HPow.hPow x.toNNReal y)","decl":"theorem _root_.Real.toNNReal_rpow_of_nonneg {x y : ℝ} (hx : 0 ≤ x) :\n    Real.toNNReal (x ^ y) = Real.toNNReal x ^ y := by\n  nth_rw 1 [← Real.coe_toNNReal x hx]\n  rw [← NNReal.coe_rpow, Real.toNNReal_coe]\n\n"}
{"name":"NNReal.strictMono_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\nh : LT.lt 0 z\n⊢ StrictMono fun x => HPow.hPow x z","decl":"theorem strictMono_rpow_of_pos {z : ℝ} (h : 0 < z) : StrictMono fun x : ℝ≥0 => x ^ z :=\n  fun x y hxy => by simp only [NNReal.rpow_lt_rpow hxy h, coe_lt_coe]\n\n"}
{"name":"NNReal.monotone_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\nh : LE.le 0 z\n⊢ Monotone fun x => HPow.hPow x z","decl":"theorem monotone_rpow_of_nonneg {z : ℝ} (h : 0 ≤ z) : Monotone fun x : ℝ≥0 => x ^ z :=\n  h.eq_or_lt.elim (fun h0 => h0 ▸ by simp only [rpow_zero, monotone_const]) fun h0 =>\n    (strictMono_rpow_of_pos h0).monotone\n\n"}
{"name":"NNReal.orderIsoRpow_apply","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : LT.lt 0 y\nx : NNReal\n⊢ Eq ((NNReal.orderIsoRpow y hy) x) (HPow.hPow x y)","decl":"/-- Bundles `fun x : ℝ≥0 => x ^ y` into an order isomorphism when `y : ℝ` is positive,\nwhere the inverse is `fun x : ℝ≥0 => x ^ (1 / y)`. -/\n@[simps! apply]\ndef orderIsoRpow (y : ℝ) (hy : 0 < y) : ℝ≥0 ≃o ℝ≥0 :=\n  (strictMono_rpow_of_pos hy).orderIsoOfRightInverse (fun x => x ^ y) (fun x => x ^ (1 / y))\n    fun x => by\n      dsimp\n      rw [← rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]\n\n"}
{"name":"NNReal.orderIsoRpow_symm_eq","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : LT.lt 0 y\n⊢ Eq (NNReal.orderIsoRpow y hy).symm (NNReal.orderIsoRpow (HDiv.hDiv 1 y) ⋯)","decl":"theorem orderIsoRpow_symm_eq (y : ℝ) (hy : 0 < y) :\n    (orderIsoRpow y hy).symm = orderIsoRpow (1 / y) (one_div_pos.2 hy) := by\n  simp only [orderIsoRpow, one_div_one_div]; rfl\n\n"}
{"name":"Real.nnnorm_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : Real\nhx : LE.le 0 x\n⊢ Eq (NNNorm.nnnorm (HPow.hPow x y)) (HPow.hPow (NNNorm.nnnorm x) y)","decl":"theorem _root_.Real.nnnorm_rpow_of_nonneg {x y : ℝ} (hx : 0 ≤ x) : ‖x ^ y‖₊ = ‖x‖₊ ^ y := by\n  ext; exact Real.norm_rpow_of_nonneg hx\n\n"}
{"name":"ENNReal.rpow_eq_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\n⊢ Eq (x.rpow y) (HPow.hPow x y)","decl":"@[simp]\ntheorem rpow_eq_pow (x : ℝ≥0∞) (y : ℝ) : rpow x y = x ^ y :=\n  rfl\n\n"}
{"name":"ENNReal.rpow_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\n⊢ Eq (HPow.hPow x 0) 1","decl":"@[simp]\ntheorem rpow_zero {x : ℝ≥0∞} : x ^ (0 : ℝ) = 1 := by\n  cases x <;>\n    · dsimp only [(· ^ ·), Pow.pow, rpow]\n      simp [lt_irrefl]\n\n"}
{"name":"ENNReal.top_rpow_def","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\n⊢ Eq (HPow.hPow Top.top y) (ite (LT.lt 0 y) Top.top (ite (Eq y 0) 1 0))","decl":"theorem top_rpow_def (y : ℝ) : (⊤ : ℝ≥0∞) ^ y = if 0 < y then ⊤ else if y = 0 then 1 else 0 :=\n  rfl\n\n"}
{"name":"ENNReal.top_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : LT.lt 0 y\n⊢ Eq (HPow.hPow Top.top y) Top.top","decl":"@[simp]\ntheorem top_rpow_of_pos {y : ℝ} (h : 0 < y) : (⊤ : ℝ≥0∞) ^ y = ⊤ := by simp [top_rpow_def, h]\n\n"}
{"name":"ENNReal.top_rpow_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : LT.lt y 0\n⊢ Eq (HPow.hPow Top.top y) 0","decl":"@[simp]\ntheorem top_rpow_of_neg {y : ℝ} (h : y < 0) : (⊤ : ℝ≥0∞) ^ y = 0 := by\n  simp [top_rpow_def, asymm h, ne_of_lt h]\n\n"}
{"name":"ENNReal.zero_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : LT.lt 0 y\n⊢ Eq (HPow.hPow 0 y) 0","decl":"@[simp]\ntheorem zero_rpow_of_pos {y : ℝ} (h : 0 < y) : (0 : ℝ≥0∞) ^ y = 0 := by\n  rw [← ENNReal.coe_zero, ← ENNReal.some_eq_coe]\n  dsimp only [(· ^ ·), rpow, Pow.pow]\n  simp [h, asymm h, ne_of_gt h]\n\n"}
{"name":"ENNReal.zero_rpow_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nh : LT.lt y 0\n⊢ Eq (HPow.hPow 0 y) Top.top","decl":"@[simp]\ntheorem zero_rpow_of_neg {y : ℝ} (h : y < 0) : (0 : ℝ≥0∞) ^ y = ⊤ := by\n  rw [← ENNReal.coe_zero, ← ENNReal.some_eq_coe]\n  dsimp only [(· ^ ·), rpow, Pow.pow]\n  simp [h, ne_of_gt h]\n\n"}
{"name":"ENNReal.zero_rpow_def","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\n⊢ Eq (HPow.hPow 0 y) (ite (LT.lt 0 y) 0 (ite (Eq y 0) 1 Top.top))","decl":"theorem zero_rpow_def (y : ℝ) : (0 : ℝ≥0∞) ^ y = if 0 < y then 0 else if y = 0 then 1 else ⊤ := by\n  rcases lt_trichotomy (0 : ℝ) y with (H | rfl | H)\n  · simp [H, ne_of_gt, zero_rpow_of_pos, lt_irrefl]\n  · simp [lt_irrefl]\n  · simp [H, asymm H, ne_of_lt, zero_rpow_of_neg]\n\n"}
{"name":"ENNReal.zero_rpow_mul_self","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\n⊢ Eq (HMul.hMul (HPow.hPow 0 y) (HPow.hPow 0 y)) (HPow.hPow 0 y)","decl":"@[simp]\ntheorem zero_rpow_mul_self (y : ℝ) : (0 : ℝ≥0∞) ^ y * (0 : ℝ≥0∞) ^ y = (0 : ℝ≥0∞) ^ y := by\n  rw [zero_rpow_def]\n  split_ifs\n  exacts [zero_mul _, one_mul _, top_mul_top]\n\n"}
{"name":"ENNReal.coe_rpow_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\nh : Ne x 0\ny : Real\n⊢ Eq (↑(HPow.hPow x y)) (HPow.hPow (↑x) y)","decl":"@[norm_cast]\ntheorem coe_rpow_of_ne_zero {x : ℝ≥0} (h : x ≠ 0) (y : ℝ) : (↑(x ^ y) : ℝ≥0∞) = x ^ y := by\n  rw [← ENNReal.some_eq_coe]\n  dsimp only [(· ^ ·), Pow.pow, rpow]\n  simp [h]\n\n"}
{"name":"ENNReal.coe_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\nh : LE.le 0 y\n⊢ Eq (↑(HPow.hPow x y)) (HPow.hPow (↑x) y)","decl":"@[norm_cast]\ntheorem coe_rpow_of_nonneg (x : ℝ≥0) {y : ℝ} (h : 0 ≤ y) : ↑(x ^ y) = (x : ℝ≥0∞) ^ y := by\n  by_cases hx : x = 0\n  · rcases le_iff_eq_or_lt.1 h with (H | H)\n    · simp [hx, H.symm]\n    · simp [hx, zero_rpow_of_pos H, NNReal.zero_rpow (ne_of_gt H)]\n  · exact coe_rpow_of_ne_zero hx _\n\n"}
{"name":"ENNReal.coe_rpow_def","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : NNReal\ny : Real\n⊢ Eq (HPow.hPow (↑x) y) (ite (And (Eq x 0) (LT.lt y 0)) Top.top ↑(HPow.hPow x y))","decl":"theorem coe_rpow_def (x : ℝ≥0) (y : ℝ) :\n    (x : ℝ≥0∞) ^ y = if x = 0 ∧ y < 0 then ⊤ else ↑(x ^ y) :=\n  rfl\n\n"}
{"name":"ENNReal.rpow_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\n⊢ Eq (HPow.hPow x 1) x","decl":"@[simp]\ntheorem rpow_one (x : ℝ≥0∞) : x ^ (1 : ℝ) = x := by\n  cases x\n  · exact dif_pos zero_lt_one\n  · change ite _ _ _ = _\n    simp only [NNReal.rpow_one, some_eq_coe, ite_eq_right_iff, top_ne_coe, and_imp]\n    exact fun _ => zero_le_one.not_lt\n\n"}
{"name":"ENNReal.one_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\n⊢ Eq (HPow.hPow 1 x) 1","decl":"@[simp]\ntheorem one_rpow (x : ℝ) : (1 : ℝ≥0∞) ^ x = 1 := by\n  rw [← coe_one, ← coe_rpow_of_ne_zero one_ne_zero]\n  simp\n\n"}
{"name":"ENNReal.rpow_eq_zero_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\n⊢ Iff (Eq (HPow.hPow x y) 0) (Or (And (Eq x 0) (LT.lt 0 y)) (And (Eq x Top.top) (LT.lt y 0)))","decl":"@[simp]\ntheorem rpow_eq_zero_iff {x : ℝ≥0∞} {y : ℝ} : x ^ y = 0 ↔ x = 0 ∧ 0 < y ∨ x = ⊤ ∧ y < 0 := by\n  cases' x with x\n  · rcases lt_trichotomy y 0 with (H | H | H) <;>\n      simp [H, top_rpow_of_neg, top_rpow_of_pos, le_of_lt]\n  · by_cases h : x = 0\n    · rcases lt_trichotomy y 0 with (H | H | H) <;>\n        simp [h, H, zero_rpow_of_neg, zero_rpow_of_pos, le_of_lt]\n    · simp [← coe_rpow_of_ne_zero h, h]\n\n"}
{"name":"ENNReal.rpow_eq_zero_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nhy : LT.lt 0 y\n⊢ Iff (Eq (HPow.hPow x y) 0) (Eq x 0)","decl":"lemma rpow_eq_zero_iff_of_pos {x : ℝ≥0∞} {y : ℝ} (hy : 0 < y) : x ^ y = 0 ↔ x = 0 := by\n  simp [hy, hy.not_lt]\n\n"}
{"name":"ENNReal.rpow_eq_top_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\n⊢ Iff (Eq (HPow.hPow x y) Top.top) (Or (And (Eq x 0) (LT.lt y 0)) (And (Eq x Top.top) (LT.lt 0 y)))","decl":"@[simp]\ntheorem rpow_eq_top_iff {x : ℝ≥0∞} {y : ℝ} : x ^ y = ⊤ ↔ x = 0 ∧ y < 0 ∨ x = ⊤ ∧ 0 < y := by\n  cases' x with x\n  · rcases lt_trichotomy y 0 with (H | H | H) <;>\n      simp [H, top_rpow_of_neg, top_rpow_of_pos, le_of_lt]\n  · by_cases h : x = 0\n    · rcases lt_trichotomy y 0 with (H | H | H) <;>\n        simp [h, H, zero_rpow_of_neg, zero_rpow_of_pos, le_of_lt]\n    · simp [← coe_rpow_of_ne_zero h, h]\n\n"}
{"name":"ENNReal.rpow_eq_top_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nhy : LT.lt 0 y\n⊢ Iff (Eq (HPow.hPow x y) Top.top) (Eq x Top.top)","decl":"theorem rpow_eq_top_iff_of_pos {x : ℝ≥0∞} {y : ℝ} (hy : 0 < y) : x ^ y = ⊤ ↔ x = ⊤ := by\n  simp [rpow_eq_top_iff, hy, asymm hy]\n\n"}
{"name":"ENNReal.rpow_lt_top_iff_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nhy : LT.lt 0 y\n⊢ Iff (LT.lt (HPow.hPow x y) Top.top) (LT.lt x Top.top)","decl":"lemma rpow_lt_top_iff_of_pos {x : ℝ≥0∞} {y : ℝ} (hy : 0 < y) : x ^ y < ∞ ↔ x < ∞ := by\n  simp only [lt_top_iff_ne_top, Ne, rpow_eq_top_iff_of_pos hy]\n\n"}
{"name":"ENNReal.rpow_eq_top_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nhy0 : LE.le 0 y\na✝ : Eq (HPow.hPow x y) Top.top\n⊢ Eq x Top.top","decl":"theorem rpow_eq_top_of_nonneg (x : ℝ≥0∞) {y : ℝ} (hy0 : 0 ≤ y) : x ^ y = ⊤ → x = ⊤ := by\n  rw [ENNReal.rpow_eq_top_iff]\n  rintro (h|h)\n  · exfalso\n    rw [lt_iff_not_ge] at h\n    exact h.right hy0\n  · exact h.left\n\n"}
{"name":"ENNReal.rpow_ne_top_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nhy0 : LE.le 0 y\nh : Ne x Top.top\n⊢ Ne (HPow.hPow x y) Top.top","decl":"theorem rpow_ne_top_of_nonneg {x : ℝ≥0∞} {y : ℝ} (hy0 : 0 ≤ y) (h : x ≠ ⊤) : x ^ y ≠ ⊤ :=\n  mt (ENNReal.rpow_eq_top_of_nonneg x hy0) h\n\n"}
{"name":"ENNReal.rpow_lt_top_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nhy0 : LE.le 0 y\nh : Ne x Top.top\n⊢ LT.lt (HPow.hPow x y) Top.top","decl":"theorem rpow_lt_top_of_nonneg {x : ℝ≥0∞} {y : ℝ} (hy0 : 0 ≤ y) (h : x ≠ ⊤) : x ^ y < ⊤ :=\n  lt_top_iff_ne_top.mpr (ENNReal.rpow_ne_top_of_nonneg hy0 h)\n\n"}
{"name":"ENNReal.rpow_add","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhx : Ne x 0\nh'x : Ne x Top.top\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add {x : ℝ≥0∞} (y z : ℝ) (hx : x ≠ 0) (h'x : x ≠ ⊤) : x ^ (y + z) = x ^ y * x ^ z := by\n  cases' x with x\n  · exact (h'x rfl).elim\n  have : x ≠ 0 := fun h => by simp [h] at hx\n  simp [← coe_rpow_of_ne_zero this, NNReal.rpow_add this]\n\n"}
{"name":"ENNReal.rpow_add_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhy : LE.le 0 y\nhz : LE.le 0 z\n⊢ Eq (HPow.hPow x (HAdd.hAdd y z)) (HMul.hMul (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_add_of_nonneg {x : ℝ≥0∞} (y z : ℝ) (hy : 0 ≤ y) (hz : 0 ≤ z) :\n    x ^ (y + z) = x ^ y * x ^ z := by\n  induction x using recTopCoe\n  · rcases hy.eq_or_lt with rfl|hy\n    · rw [rpow_zero, one_mul, zero_add]\n    rcases hz.eq_or_lt with rfl|hz\n    · rw [rpow_zero, mul_one, add_zero]\n    simp [top_rpow_of_pos, hy, hz, add_pos hy hz]\n  simp [← coe_rpow_of_nonneg, hy, hz, add_nonneg hy hz, NNReal.rpow_add_of_nonneg _ hy hz]\n\n"}
{"name":"ENNReal.rpow_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\n⊢ Eq (HPow.hPow x (Neg.neg y)) (Inv.inv (HPow.hPow x y))","decl":"theorem rpow_neg (x : ℝ≥0∞) (y : ℝ) : x ^ (-y) = (x ^ y)⁻¹ := by\n  cases' x with x\n  · rcases lt_trichotomy y 0 with (H | H | H) <;>\n      simp [top_rpow_of_pos, top_rpow_of_neg, H, neg_pos.mpr]\n  · by_cases h : x = 0\n    · rcases lt_trichotomy y 0 with (H | H | H) <;>\n        simp [h, zero_rpow_of_pos, zero_rpow_of_neg, H, neg_pos.mpr]\n    · have A : x ^ y ≠ 0 := by simp [h]\n      simp [← coe_rpow_of_ne_zero h, ← coe_inv A, NNReal.rpow_neg]\n\n"}
{"name":"ENNReal.rpow_sub","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhx : Ne x 0\nh'x : Ne x Top.top\n⊢ Eq (HPow.hPow x (HSub.hSub y z)) (HDiv.hDiv (HPow.hPow x y) (HPow.hPow x z))","decl":"theorem rpow_sub {x : ℝ≥0∞} (y z : ℝ) (hx : x ≠ 0) (h'x : x ≠ ⊤) : x ^ (y - z) = x ^ y / x ^ z := by\n  rw [sub_eq_add_neg, rpow_add _ _ hx h'x, rpow_neg, div_eq_mul_inv]\n\n"}
{"name":"ENNReal.rpow_neg_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\n⊢ Eq (HPow.hPow x (-1)) (Inv.inv x)","decl":"theorem rpow_neg_one (x : ℝ≥0∞) : x ^ (-1 : ℝ) = x⁻¹ := by simp [rpow_neg]\n\n"}
{"name":"ENNReal.rpow_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\n⊢ Eq (HPow.hPow x (HMul.hMul y z)) (HPow.hPow (HPow.hPow x y) z)","decl":"theorem rpow_mul (x : ℝ≥0∞) (y z : ℝ) : x ^ (y * z) = (x ^ y) ^ z := by\n  cases' x with x\n  · rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>\n        rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>\n      simp [Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos,\n        mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]\n  · by_cases h : x = 0\n    · rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>\n          rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>\n        simp [h, Hy, Hz, zero_rpow_of_neg, zero_rpow_of_pos, top_rpow_of_neg, top_rpow_of_pos,\n          mul_pos_of_neg_of_neg, mul_neg_of_neg_of_pos, mul_neg_of_pos_of_neg]\n    · have : x ^ y ≠ 0 := by simp [h]\n      simp [← coe_rpow_of_ne_zero, h, this, NNReal.rpow_mul]\n\n"}
{"name":"ENNReal.rpow_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nn : Nat\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\ntheorem rpow_natCast (x : ℝ≥0∞) (n : ℕ) : x ^ (n : ℝ) = x ^ n := by\n  cases x\n  · cases n <;> simp [top_rpow_of_pos (Nat.cast_add_one_pos _), top_pow (Nat.succ_pos _)]\n  · simp [← coe_rpow_of_nonneg _ (Nat.cast_nonneg n)]\n\n"}
{"name":"ENNReal.rpow_ofNat","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (HPow.hPow x (OfNat.ofNat n)) (HPow.hPow x (OfNat.ofNat n))","decl":"@[simp]\nlemma rpow_ofNat (x : ℝ≥0∞) (n : ℕ) [n.AtLeastTwo] :\n    x ^ (ofNat(n) : ℝ) = x ^ (OfNat.ofNat n) :=\n  rpow_natCast x n\n\n"}
{"name":"ENNReal.rpow_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nn : Int\n⊢ Eq (HPow.hPow x ↑n) (HPow.hPow x n)","decl":"@[simp, norm_cast]\nlemma rpow_intCast (x : ℝ≥0∞) (n : ℤ) : x ^ (n : ℝ) = x ^ n := by\n  cases n <;> simp only [Int.ofNat_eq_coe, Int.cast_natCast, rpow_natCast, zpow_natCast,\n    Int.cast_negSucc, rpow_neg, zpow_negSucc]\n\n"}
{"name":"ENNReal.rpow_two","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\n⊢ Eq (HPow.hPow x 2) (HPow.hPow x 2)","decl":"theorem rpow_two (x : ℝ≥0∞) : x ^ (2 : ℝ) = x ^ 2 := rpow_ofNat x 2\n\n"}
{"name":"ENNReal.mul_rpow_eq_ite","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\n⊢ Eq (HPow.hPow (HMul.hMul x y) z) (ite (And (Or (And (Eq x 0) (Eq y Top.top)) (And (Eq x Top.top) (Eq y 0))) (LT.lt z 0)) Top.top (HMul.hMul (HPow.hPow x z) (HPow.hPow y z)))","decl":"theorem mul_rpow_eq_ite (x y : ℝ≥0∞) (z : ℝ) :\n    (x * y) ^ z = if (x = 0 ∧ y = ⊤ ∨ x = ⊤ ∧ y = 0) ∧ z < 0 then ⊤ else x ^ z * y ^ z := by\n  rcases eq_or_ne z 0 with (rfl | hz); · simp\n  replace hz := hz.lt_or_lt\n  wlog hxy : x ≤ y\n  · convert this y x z hz (le_of_not_le hxy) using 2 <;> simp only [mul_comm, and_comm, or_comm]\n  rcases eq_or_ne x 0 with (rfl | hx0)\n  · induction y <;> cases' hz with hz hz <;> simp [*, hz.not_lt]\n  rcases eq_or_ne y 0 with (rfl | hy0)\n  · exact (hx0 (bot_unique hxy)).elim\n  induction x\n  · cases' hz with hz hz <;> simp [hz, top_unique hxy]\n  induction y\n  · rw [ne_eq, coe_eq_zero] at hx0\n    cases' hz with hz hz <;> simp [*]\n  simp only [*, if_false]\n  norm_cast at *\n  rw [← coe_rpow_of_ne_zero (mul_ne_zero hx0 hy0), NNReal.mul_rpow]\n  norm_cast\n\n"}
{"name":"ENNReal.mul_rpow_of_ne_top","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nhx : Ne x Top.top\nhy : Ne y Top.top\nz : Real\n⊢ Eq (HPow.hPow (HMul.hMul x y) z) (HMul.hMul (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem mul_rpow_of_ne_top {x y : ℝ≥0∞} (hx : x ≠ ⊤) (hy : y ≠ ⊤) (z : ℝ) :\n    (x * y) ^ z = x ^ z * y ^ z := by simp [*, mul_rpow_eq_ite]\n\n"}
{"name":"ENNReal.coe_mul_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : NNReal\nz : Real\n⊢ Eq (HPow.hPow (HMul.hMul ↑x ↑y) z) (HMul.hMul (HPow.hPow (↑x) z) (HPow.hPow (↑y) z))","decl":"@[norm_cast]\ntheorem coe_mul_rpow (x y : ℝ≥0) (z : ℝ) : ((x : ℝ≥0∞) * y) ^ z = (x : ℝ≥0∞) ^ z * (y : ℝ≥0∞) ^ z :=\n  mul_rpow_of_ne_top coe_ne_top coe_ne_top z\n\n"}
{"name":"ENNReal.prod_coe_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → NNReal\nr : Real\n⊢ Eq (s.prod fun i => HPow.hPow (↑(f i)) r) (HPow.hPow (↑(s.prod fun i => f i)) r)","decl":"theorem prod_coe_rpow {ι} (s : Finset ι) (f : ι → ℝ≥0) (r : ℝ) :\n    ∏ i ∈ s, (f i : ℝ≥0∞) ^ r = ((∏ i ∈ s, f i : ℝ≥0) : ℝ≥0∞) ^ r := by\n  classical\n  induction s using Finset.induction with\n  | empty => simp\n  | insert hi ih => simp_rw [prod_insert hi, ih, ← coe_mul_rpow, coe_mul]\n\n"}
{"name":"ENNReal.mul_rpow_of_ne_zero","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nhx : Ne x 0\nhy : Ne y 0\nz : Real\n⊢ Eq (HPow.hPow (HMul.hMul x y) z) (HMul.hMul (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem mul_rpow_of_ne_zero {x y : ℝ≥0∞} (hx : x ≠ 0) (hy : y ≠ 0) (z : ℝ) :\n    (x * y) ^ z = x ^ z * y ^ z := by simp [*, mul_rpow_eq_ite]\n\n"}
{"name":"ENNReal.mul_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LE.le 0 z\n⊢ Eq (HPow.hPow (HMul.hMul x y) z) (HMul.hMul (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem mul_rpow_of_nonneg (x y : ℝ≥0∞) {z : ℝ} (hz : 0 ≤ z) : (x * y) ^ z = x ^ z * y ^ z := by\n  simp [hz.not_lt, mul_rpow_eq_ite]\n\n"}
{"name":"ENNReal.prod_rpow_of_ne_top","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → ENNReal\nhf : ∀ (i : ι), Membership.mem s i → Ne (f i) Top.top\nr : Real\n⊢ Eq (s.prod fun i => HPow.hPow (f i) r) (HPow.hPow (s.prod fun i => f i) r)","decl":"theorem prod_rpow_of_ne_top {ι} {s : Finset ι} {f : ι → ℝ≥0∞} (hf : ∀ i ∈ s, f i ≠ ∞) (r : ℝ) :\n    ∏ i ∈ s, f i ^ r = (∏ i ∈ s, f i) ^ r := by\n  classical\n  induction s using Finset.induction with\n  | empty => simp\n  | @insert i s hi ih =>\n    have h2f : ∀ i ∈ s, f i ≠ ∞ := fun i hi ↦ hf i <| mem_insert_of_mem hi\n    rw [prod_insert hi, prod_insert hi, ih h2f, ← mul_rpow_of_ne_top <| hf i <| mem_insert_self ..]\n    apply prod_ne_top h2f\n\n"}
{"name":"ENNReal.prod_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"ι : Type u_1\ns : Finset ι\nf : ι → ENNReal\nr : Real\nhr : LE.le 0 r\n⊢ Eq (s.prod fun i => HPow.hPow (f i) r) (HPow.hPow (s.prod fun i => f i) r)","decl":"theorem prod_rpow_of_nonneg {ι} {s : Finset ι} {f : ι → ℝ≥0∞} {r : ℝ} (hr : 0 ≤ r) :\n    ∏ i ∈ s, f i ^ r = (∏ i ∈ s, f i) ^ r := by\n  classical\n  induction s using Finset.induction with\n  | empty => simp\n  | insert hi ih => simp_rw [prod_insert hi, ih, ← mul_rpow_of_nonneg _ _ hr]\n\n"}
{"name":"ENNReal.inv_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\n⊢ Eq (HPow.hPow (Inv.inv x) y) (Inv.inv (HPow.hPow x y))","decl":"theorem inv_rpow (x : ℝ≥0∞) (y : ℝ) : x⁻¹ ^ y = (x ^ y)⁻¹ := by\n  rcases eq_or_ne y 0 with (rfl | hy); · simp only [rpow_zero, inv_one]\n  replace hy := hy.lt_or_lt\n  rcases eq_or_ne x 0 with (rfl | h0); · cases hy <;> simp [*]\n  rcases eq_or_ne x ⊤ with (rfl | h_top); · cases hy <;> simp [*]\n  apply ENNReal.eq_inv_of_mul_eq_one_left\n  rw [← mul_rpow_of_ne_zero (ENNReal.inv_ne_zero.2 h_top) h0, ENNReal.inv_mul_cancel h0 h_top,\n    one_rpow]\n\n"}
{"name":"ENNReal.div_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LE.le 0 z\n⊢ Eq (HPow.hPow (HDiv.hDiv x y) z) (HDiv.hDiv (HPow.hPow x z) (HPow.hPow y z))","decl":"theorem div_rpow_of_nonneg (x y : ℝ≥0∞) {z : ℝ} (hz : 0 ≤ z) : (x / y) ^ z = x ^ z / y ^ z := by\n  rw [div_eq_mul_inv, mul_rpow_of_nonneg _ _ hz, inv_rpow, div_eq_mul_inv]\n\n"}
{"name":"ENNReal.strictMono_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\nh : LT.lt 0 z\n⊢ StrictMono fun x => HPow.hPow x z","decl":"theorem strictMono_rpow_of_pos {z : ℝ} (h : 0 < z) : StrictMono fun x : ℝ≥0∞ => x ^ z := by\n  intro x y hxy\n  lift x to ℝ≥0 using ne_top_of_lt hxy\n  rcases eq_or_ne y ∞ with (rfl | hy)\n  · simp only [top_rpow_of_pos h, ← coe_rpow_of_nonneg _ h.le, coe_lt_top]\n  · lift y to ℝ≥0 using hy\n    simp only [← coe_rpow_of_nonneg _ h.le, NNReal.rpow_lt_rpow (coe_lt_coe.1 hxy) h, coe_lt_coe]\n\n"}
{"name":"ENNReal.monotone_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"z : Real\nh : LE.le 0 z\n⊢ Monotone fun x => HPow.hPow x z","decl":"theorem monotone_rpow_of_nonneg {z : ℝ} (h : 0 ≤ z) : Monotone fun x : ℝ≥0∞ => x ^ z :=\n  h.eq_or_lt.elim (fun h0 => h0 ▸ by simp only [rpow_zero, monotone_const]) fun h0 =>\n    (strictMono_rpow_of_pos h0).monotone\n\n"}
{"name":"ENNReal.orderIsoRpow_apply","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : LT.lt 0 y\nx : ENNReal\n⊢ Eq ((ENNReal.orderIsoRpow y hy) x) (HPow.hPow x y)","decl":"/-- Bundles `fun x : ℝ≥0∞ => x ^ y` into an order isomorphism when `y : ℝ` is positive,\nwhere the inverse is `fun x : ℝ≥0∞ => x ^ (1 / y)`. -/\n@[simps! apply]\ndef orderIsoRpow (y : ℝ) (hy : 0 < y) : ℝ≥0∞ ≃o ℝ≥0∞ :=\n  (strictMono_rpow_of_pos hy).orderIsoOfRightInverse (fun x => x ^ y) (fun x => x ^ (1 / y))\n    fun x => by\n    dsimp\n    rw [← rpow_mul, one_div_mul_cancel hy.ne.symm, rpow_one]\n\n"}
{"name":"ENNReal.orderIsoRpow_symm_apply","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : LT.lt 0 y\n⊢ Eq (ENNReal.orderIsoRpow y hy).symm (ENNReal.orderIsoRpow (HDiv.hDiv 1 y) ⋯)","decl":"theorem orderIsoRpow_symm_apply (y : ℝ) (hy : 0 < y) :\n    (orderIsoRpow y hy).symm = orderIsoRpow (1 / y) (one_div_pos.2 hy) := by\n  simp only [orderIsoRpow, one_div_one_div]\n  rfl\n\n"}
{"name":"ENNReal.rpow_le_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nh₁ : LE.le x y\nh₂ : LE.le 0 z\n⊢ LE.le (HPow.hPow x z) (HPow.hPow y z)","decl":"@[gcongr] theorem rpow_le_rpow {x y : ℝ≥0∞} {z : ℝ} (h₁ : x ≤ y) (h₂ : 0 ≤ z) : x ^ z ≤ y ^ z :=\n  monotone_rpow_of_nonneg h₂ h₁\n\n"}
{"name":"ENNReal.rpow_lt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nh₁ : LT.lt x y\nh₂ : LT.lt 0 z\n⊢ LT.lt (HPow.hPow x z) (HPow.hPow y z)","decl":"@[gcongr] theorem rpow_lt_rpow {x y : ℝ≥0∞} {z : ℝ} (h₁ : x < y) (h₂ : 0 < z) : x ^ z < y ^ z :=\n  strictMono_rpow_of_pos h₂ h₁\n\n"}
{"name":"ENNReal.rpow_le_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LE.le (HPow.hPow x z) (HPow.hPow y z)) (LE.le x y)","decl":"theorem rpow_le_rpow_iff {x y : ℝ≥0∞} {z : ℝ} (hz : 0 < z) : x ^ z ≤ y ^ z ↔ x ≤ y :=\n  (strictMono_rpow_of_pos hz).le_iff_le\n\n"}
{"name":"ENNReal.rpow_lt_rpow_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LT.lt (HPow.hPow x z) (HPow.hPow y z)) (LT.lt x y)","decl":"theorem rpow_lt_rpow_iff {x y : ℝ≥0∞} {z : ℝ} (hz : 0 < z) : x ^ z < y ^ z ↔ x < y :=\n  (strictMono_rpow_of_pos hz).lt_iff_lt\n\n"}
{"name":"ENNReal.le_rpow_inv_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LE.le x (HPow.hPow y (Inv.inv z))) (LE.le (HPow.hPow x z) y)","decl":"theorem le_rpow_inv_iff {x y : ℝ≥0∞} {z : ℝ} (hz : 0 < z) : x ≤ y ^ z⁻¹ ↔ x ^ z ≤ y := by\n  nth_rw 1 [← rpow_one x]\n  nth_rw 1 [← @mul_inv_cancel₀ _ _ z hz.ne']\n  rw [rpow_mul, @rpow_le_rpow_iff _ _ z⁻¹ (by simp [hz])]\n\n"}
{"name":"ENNReal.rpow_inv_lt_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LT.lt (HPow.hPow x (Inv.inv z)) y) (LT.lt x (HPow.hPow y z))","decl":"theorem rpow_inv_lt_iff {x y : ℝ≥0∞} {z : ℝ} (hz : 0 < z) : x ^ z⁻¹ < y ↔ x < y ^ z := by\n  simp only [← not_le, le_rpow_inv_iff hz]\n\n"}
{"name":"ENNReal.lt_rpow_inv_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LT.lt x (HPow.hPow y (Inv.inv z))) (LT.lt (HPow.hPow x z) y)","decl":"theorem lt_rpow_inv_iff {x y : ℝ≥0∞} {z : ℝ} (hz : 0 < z) : x < y ^ z⁻¹ ↔ x ^ z < y := by\n  nth_rw 1 [← rpow_one x]\n  nth_rw 1 [← @mul_inv_cancel₀ _ _ z (ne_of_lt hz).symm]\n  rw [rpow_mul, @rpow_lt_rpow_iff _ _ z⁻¹ (by simp [hz])]\n\n"}
{"name":"ENNReal.rpow_inv_le_iff","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : ENNReal\nz : Real\nhz : LT.lt 0 z\n⊢ Iff (LE.le (HPow.hPow x (Inv.inv z)) y) (LE.le x (HPow.hPow y z))","decl":"theorem rpow_inv_le_iff {x y : ℝ≥0∞} {z : ℝ} (hz : 0 < z) : x ^ z⁻¹ ≤ y ↔ x ≤ y ^ z := by\n  nth_rw 1 [← ENNReal.rpow_one y]\n  nth_rw 1 [← @mul_inv_cancel₀ _ _ z hz.ne.symm]\n  rw [ENNReal.rpow_mul, ENNReal.rpow_le_rpow_iff (inv_pos.2 hz)]\n\n"}
{"name":"ENNReal.rpow_lt_rpow_of_exponent_lt","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhx : LT.lt 1 x\nhx' : Ne x Top.top\nhyz : LT.lt y z\n⊢ LT.lt (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_lt_rpow_of_exponent_lt {x : ℝ≥0∞} {y z : ℝ} (hx : 1 < x) (hx' : x ≠ ⊤) (hyz : y < z) :\n    x ^ y < x ^ z := by\n  lift x to ℝ≥0 using hx'\n  rw [one_lt_coe_iff] at hx\n  simp [← coe_rpow_of_ne_zero (ne_of_gt (lt_trans zero_lt_one hx)),\n    NNReal.rpow_lt_rpow_of_exponent_lt hx hyz]\n\n"}
{"name":"ENNReal.rpow_le_rpow_of_exponent_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhx : LE.le 1 x\nhyz : LE.le y z\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"@[gcongr] theorem rpow_le_rpow_of_exponent_le {x : ℝ≥0∞} {y z : ℝ} (hx : 1 ≤ x) (hyz : y ≤ z) :\n    x ^ y ≤ x ^ z := by\n  cases x\n  · rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>\n    rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>\n    simp [Hy, Hz, top_rpow_of_neg, top_rpow_of_pos, le_refl] <;>\n    linarith\n  · simp only [one_le_coe_iff, some_eq_coe] at hx\n    simp [← coe_rpow_of_ne_zero (ne_of_gt (lt_of_lt_of_le zero_lt_one hx)),\n      NNReal.rpow_le_rpow_of_exponent_le hx hyz]\n\n"}
{"name":"ENNReal.rpow_lt_rpow_of_exponent_gt","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhx0 : LT.lt 0 x\nhx1 : LT.lt x 1\nhyz : LT.lt z y\n⊢ LT.lt (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_lt_rpow_of_exponent_gt {x : ℝ≥0∞} {y z : ℝ} (hx0 : 0 < x) (hx1 : x < 1) (hyz : z < y) :\n    x ^ y < x ^ z := by\n  lift x to ℝ≥0 using ne_of_lt (lt_of_lt_of_le hx1 le_top)\n  simp only [coe_lt_one_iff, coe_pos] at hx0 hx1\n  simp [← coe_rpow_of_ne_zero (ne_of_gt hx0), NNReal.rpow_lt_rpow_of_exponent_gt hx0 hx1 hyz]\n\n"}
{"name":"ENNReal.rpow_le_rpow_of_exponent_ge","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny z : Real\nhx1 : LE.le x 1\nhyz : LE.le z y\n⊢ LE.le (HPow.hPow x y) (HPow.hPow x z)","decl":"theorem rpow_le_rpow_of_exponent_ge {x : ℝ≥0∞} {y z : ℝ} (hx1 : x ≤ 1) (hyz : z ≤ y) :\n    x ^ y ≤ x ^ z := by\n  lift x to ℝ≥0 using ne_of_lt (lt_of_le_of_lt hx1 coe_lt_top)\n  by_cases h : x = 0\n  · rcases lt_trichotomy y 0 with (Hy | Hy | Hy) <;>\n    rcases lt_trichotomy z 0 with (Hz | Hz | Hz) <;>\n    simp [Hy, Hz, h, zero_rpow_of_neg, zero_rpow_of_pos, le_refl] <;>\n    linarith\n  · rw [coe_le_one_iff] at hx1\n    simp [← coe_rpow_of_ne_zero h,\n      NNReal.rpow_le_rpow_of_exponent_ge (bot_lt_iff_ne_bot.mpr h) hx1 hyz]\n\n"}
{"name":"ENNReal.rpow_le_self_of_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LE.le x 1\nh_one_le : LE.le 1 z\n⊢ LE.le (HPow.hPow x z) x","decl":"theorem rpow_le_self_of_le_one {x : ℝ≥0∞} {z : ℝ} (hx : x ≤ 1) (h_one_le : 1 ≤ z) : x ^ z ≤ x := by\n  nth_rw 2 [← ENNReal.rpow_one x]\n  exact ENNReal.rpow_le_rpow_of_exponent_ge hx h_one_le\n\n"}
{"name":"ENNReal.le_rpow_self_of_one_le","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LE.le 1 x\nh_one_le : LE.le 1 z\n⊢ LE.le x (HPow.hPow x z)","decl":"theorem le_rpow_self_of_one_le {x : ℝ≥0∞} {z : ℝ} (hx : 1 ≤ x) (h_one_le : 1 ≤ z) : x ≤ x ^ z := by\n  nth_rw 1 [← ENNReal.rpow_one x]\n  exact ENNReal.rpow_le_rpow_of_exponent_le hx h_one_le\n\n"}
{"name":"ENNReal.rpow_pos_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"p : Real\nx : ENNReal\nhx_pos : LT.lt 0 x\nhp_nonneg : LE.le 0 p\n⊢ LT.lt 0 (HPow.hPow x p)","decl":"theorem rpow_pos_of_nonneg {p : ℝ} {x : ℝ≥0∞} (hx_pos : 0 < x) (hp_nonneg : 0 ≤ p) : 0 < x ^ p := by\n  by_cases hp_zero : p = 0\n  · simp [hp_zero, zero_lt_one]\n  · rw [← Ne] at hp_zero\n    have hp_pos := lt_of_le_of_ne hp_nonneg hp_zero.symm\n    rw [← zero_rpow_of_pos hp_pos]\n    exact rpow_lt_rpow hx_pos hp_pos\n\n"}
{"name":"ENNReal.rpow_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"p : Real\nx : ENNReal\nhx_pos : LT.lt 0 x\nhx_ne_top : Ne x Top.top\n⊢ LT.lt 0 (HPow.hPow x p)","decl":"theorem rpow_pos {p : ℝ} {x : ℝ≥0∞} (hx_pos : 0 < x) (hx_ne_top : x ≠ ⊤) : 0 < x ^ p := by\n  cases' lt_or_le 0 p with hp_pos hp_nonpos\n  · exact rpow_pos_of_nonneg hx_pos (le_of_lt hp_pos)\n  · rw [← neg_neg p, rpow_neg, ENNReal.inv_pos]\n    exact rpow_ne_top_of_nonneg (Right.nonneg_neg_iff.mpr hp_nonpos) hx_ne_top\n\n"}
{"name":"ENNReal.rpow_lt_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LT.lt x 1\nhz : LT.lt 0 z\n⊢ LT.lt (HPow.hPow x z) 1","decl":"theorem rpow_lt_one {x : ℝ≥0∞} {z : ℝ} (hx : x < 1) (hz : 0 < z) : x ^ z < 1 := by\n  lift x to ℝ≥0 using ne_of_lt (lt_of_lt_of_le hx le_top)\n  simp only [coe_lt_one_iff] at hx\n  simp [← coe_rpow_of_nonneg _ (le_of_lt hz), NNReal.rpow_lt_one hx hz]\n\n"}
{"name":"ENNReal.rpow_le_one","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LE.le x 1\nhz : LE.le 0 z\n⊢ LE.le (HPow.hPow x z) 1","decl":"theorem rpow_le_one {x : ℝ≥0∞} {z : ℝ} (hx : x ≤ 1) (hz : 0 ≤ z) : x ^ z ≤ 1 := by\n  lift x to ℝ≥0 using ne_of_lt (lt_of_le_of_lt hx coe_lt_top)\n  simp only [coe_le_one_iff] at hx\n  simp [← coe_rpow_of_nonneg _ hz, NNReal.rpow_le_one hx hz]\n\n"}
{"name":"ENNReal.rpow_lt_one_of_one_lt_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LT.lt 1 x\nhz : LT.lt z 0\n⊢ LT.lt (HPow.hPow x z) 1","decl":"theorem rpow_lt_one_of_one_lt_of_neg {x : ℝ≥0∞} {z : ℝ} (hx : 1 < x) (hz : z < 0) : x ^ z < 1 := by\n  cases x\n  · simp [top_rpow_of_neg hz, zero_lt_one]\n  · simp only [some_eq_coe, one_lt_coe_iff] at hx\n    simp [← coe_rpow_of_ne_zero (ne_of_gt (lt_trans zero_lt_one hx)),\n      NNReal.rpow_lt_one_of_one_lt_of_neg hx hz]\n\n"}
{"name":"ENNReal.rpow_le_one_of_one_le_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LE.le 1 x\nhz : LT.lt z 0\n⊢ LE.le (HPow.hPow x z) 1","decl":"theorem rpow_le_one_of_one_le_of_neg {x : ℝ≥0∞} {z : ℝ} (hx : 1 ≤ x) (hz : z < 0) : x ^ z ≤ 1 := by\n  cases x\n  · simp [top_rpow_of_neg hz, zero_lt_one]\n  · simp only [one_le_coe_iff, some_eq_coe] at hx\n    simp [← coe_rpow_of_ne_zero (ne_of_gt (lt_of_lt_of_le zero_lt_one hx)),\n      NNReal.rpow_le_one_of_one_le_of_nonpos hx (le_of_lt hz)]\n\n"}
{"name":"ENNReal.one_lt_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LT.lt 1 x\nhz : LT.lt 0 z\n⊢ LT.lt 1 (HPow.hPow x z)","decl":"theorem one_lt_rpow {x : ℝ≥0∞} {z : ℝ} (hx : 1 < x) (hz : 0 < z) : 1 < x ^ z := by\n  cases x\n  · simp [top_rpow_of_pos hz]\n  · simp only [some_eq_coe, one_lt_coe_iff] at hx\n    simp [← coe_rpow_of_nonneg _ (le_of_lt hz), NNReal.one_lt_rpow hx hz]\n\n"}
{"name":"ENNReal.one_le_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx : LE.le 1 x\nhz : LT.lt 0 z\n⊢ LE.le 1 (HPow.hPow x z)","decl":"theorem one_le_rpow {x : ℝ≥0∞} {z : ℝ} (hx : 1 ≤ x) (hz : 0 < z) : 1 ≤ x ^ z := by\n  cases x\n  · simp [top_rpow_of_pos hz]\n  · simp only [one_le_coe_iff, some_eq_coe] at hx\n    simp [← coe_rpow_of_nonneg _ (le_of_lt hz), NNReal.one_le_rpow hx (le_of_lt hz)]\n\n"}
{"name":"ENNReal.one_lt_rpow_of_pos_of_lt_one_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx1 : LT.lt 0 x\nhx2 : LT.lt x 1\nhz : LT.lt z 0\n⊢ LT.lt 1 (HPow.hPow x z)","decl":"theorem one_lt_rpow_of_pos_of_lt_one_of_neg {x : ℝ≥0∞} {z : ℝ} (hx1 : 0 < x) (hx2 : x < 1)\n    (hz : z < 0) : 1 < x ^ z := by\n  lift x to ℝ≥0 using ne_of_lt (lt_of_lt_of_le hx2 le_top)\n  simp only [coe_lt_one_iff, coe_pos] at hx1 hx2 ⊢\n  simp [← coe_rpow_of_ne_zero (ne_of_gt hx1), NNReal.one_lt_rpow_of_pos_of_lt_one_of_neg hx1 hx2 hz]\n\n"}
{"name":"ENNReal.one_le_rpow_of_pos_of_le_one_of_neg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\nhx1 : LT.lt 0 x\nhx2 : LE.le x 1\nhz : LT.lt z 0\n⊢ LE.le 1 (HPow.hPow x z)","decl":"theorem one_le_rpow_of_pos_of_le_one_of_neg {x : ℝ≥0∞} {z : ℝ} (hx1 : 0 < x) (hx2 : x ≤ 1)\n    (hz : z < 0) : 1 ≤ x ^ z := by\n  lift x to ℝ≥0 using ne_of_lt (lt_of_le_of_lt hx2 coe_lt_top)\n  simp only [coe_le_one_iff, coe_pos] at hx1 hx2 ⊢\n  simp [← coe_rpow_of_ne_zero (ne_of_gt hx1),\n    NNReal.one_le_rpow_of_pos_of_le_one_of_nonpos hx1 hx2 (le_of_lt hz)]\n\n"}
{"name":"ENNReal.toNNReal_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\n⊢ Eq (HPow.hPow x z).toNNReal (HPow.hPow x.toNNReal z)","decl":"@[simp] lemma toNNReal_rpow (x : ℝ≥0∞) (z : ℝ) : (x ^ z).toNNReal = x.toNNReal ^ z := by\n  rcases lt_trichotomy z 0 with (H | H | H)\n  · cases' x with x\n    · simp [H, ne_of_lt]\n    by_cases hx : x = 0\n    · simp [hx, H, ne_of_lt]\n    · simp [← coe_rpow_of_ne_zero hx]\n  · simp [H]\n  · cases x\n    · simp [H, ne_of_gt]\n    simp [← coe_rpow_of_nonneg _ (le_of_lt H)]\n\n"}
{"name":"ENNReal.toReal_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nz : Real\n⊢ Eq (HPow.hPow x.toReal z) (HPow.hPow x z).toReal","decl":"theorem toReal_rpow (x : ℝ≥0∞) (z : ℝ) : x.toReal ^ z = (x ^ z).toReal := by\n  rw [ENNReal.toReal, ENNReal.toReal, ← NNReal.coe_rpow, ENNReal.toNNReal_rpow]\n\n"}
{"name":"ENNReal.ofReal_rpow_of_pos","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x p : Real\nhx_pos : LT.lt 0 x\n⊢ Eq (HPow.hPow (ENNReal.ofReal x) p) (ENNReal.ofReal (HPow.hPow x p))","decl":"theorem ofReal_rpow_of_pos {x p : ℝ} (hx_pos : 0 < x) :\n    ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p) := by\n  simp_rw [ENNReal.ofReal]\n  rw [← coe_rpow_of_ne_zero, coe_inj, Real.toNNReal_rpow_of_nonneg hx_pos.le]\n  simp [hx_pos]\n\n"}
{"name":"ENNReal.ofReal_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x p : Real\nhx_nonneg : LE.le 0 x\nhp_nonneg : LE.le 0 p\n⊢ Eq (HPow.hPow (ENNReal.ofReal x) p) (ENNReal.ofReal (HPow.hPow x p))","decl":"theorem ofReal_rpow_of_nonneg {x p : ℝ} (hx_nonneg : 0 ≤ x) (hp_nonneg : 0 ≤ p) :\n    ENNReal.ofReal x ^ p = ENNReal.ofReal (x ^ p) := by\n  by_cases hp0 : p = 0\n  · simp [hp0]\n  by_cases hx0 : x = 0\n  · rw [← Ne] at hp0\n    have hp_pos : 0 < p := lt_of_le_of_ne hp_nonneg hp0.symm\n    simp [hx0, hp_pos, hp_pos.ne.symm]\n  rw [← Ne] at hx0\n  exact ofReal_rpow_of_pos (hx_nonneg.lt_of_ne hx0.symm)\n\n"}
{"name":"ENNReal.rpow_rpow_inv","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : Ne y 0\nx : ENNReal\n⊢ Eq (HPow.hPow (HPow.hPow x y) (Inv.inv y)) x","decl":"@[simp] lemma rpow_rpow_inv {y : ℝ} (hy : y ≠ 0) (x : ℝ≥0∞) : (x ^ y) ^ y⁻¹ = x := by\n  rw [← rpow_mul, mul_inv_cancel₀ hy, rpow_one]\n\n"}
{"name":"ENNReal.rpow_inv_rpow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"y : Real\nhy : Ne y 0\nx : ENNReal\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv y)) y) x","decl":"@[simp] lemma rpow_inv_rpow {y : ℝ} (hy : y ≠ 0) (x : ℝ≥0∞) : (x ^ y⁻¹) ^ y = x := by\n  rw [← rpow_mul, inv_mul_cancel₀ hy, rpow_one]\n\n"}
{"name":"ENNReal.pow_rpow_inv_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"n : Nat\nhn : Ne n 0\nx : ENNReal\n⊢ Eq (HPow.hPow (HPow.hPow x n) (Inv.inv ↑n)) x","decl":"lemma pow_rpow_inv_natCast {n : ℕ} (hn : n ≠ 0) (x : ℝ≥0∞) : (x ^ n) ^ (n⁻¹ : ℝ) = x := by\n  rw [← rpow_natCast, ← rpow_mul, mul_inv_cancel₀ (by positivity), rpow_one]\n\n"}
{"name":"ENNReal.rpow_inv_natCast_pow","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"n : Nat\nhn : Ne n 0\nx : ENNReal\n⊢ Eq (HPow.hPow (HPow.hPow x (Inv.inv ↑n)) n) x","decl":"lemma rpow_inv_natCast_pow {n : ℕ} (hn : n ≠ 0) (x : ℝ≥0∞) : (x ^ (n⁻¹ : ℝ)) ^ n = x := by\n  rw [← rpow_natCast, ← rpow_mul, inv_mul_cancel₀ (by positivity), rpow_one]\n\n"}
{"name":"ENNReal.rpow_natCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nn : Nat\nz : Real\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) z)) (HPow.hPow (HPow.hPow x n) z)","decl":"lemma rpow_natCast_mul (x : ℝ≥0∞) (n : ℕ) (z : ℝ) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul, rpow_natCast]\n\n"}
{"name":"ENNReal.rpow_mul_natCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nn : Nat\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma rpow_mul_natCast (x : ℝ≥0∞) (y : ℝ) (n : ℕ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul, rpow_natCast]\n\n"}
{"name":"ENNReal.rpow_intCast_mul","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\nn : Int\nz : Real\n⊢ Eq (HPow.hPow x (HMul.hMul (↑n) z)) (HPow.hPow (HPow.hPow x n) z)","decl":"lemma rpow_intCast_mul (x : ℝ≥0∞) (n : ℤ) (z : ℝ) : x ^ (n * z) = (x ^ n) ^ z := by\n  rw [rpow_mul, rpow_intCast]\n\n"}
{"name":"ENNReal.rpow_mul_intCast","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : ENNReal\ny : Real\nn : Int\n⊢ Eq (HPow.hPow x (HMul.hMul y ↑n)) (HPow.hPow (HPow.hPow x y) n)","decl":"lemma rpow_mul_intCast (x : ℝ≥0∞) (y : ℝ) (n : ℤ) : x ^ (y * n) = (x ^ y) ^ n := by\n  rw [rpow_mul, rpow_intCast]\n\n"}
{"name":"ENNReal.rpow_left_injective","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Function.Injective fun y => HPow.hPow y x","decl":"lemma rpow_left_injective {x : ℝ} (hx : x ≠ 0) : Injective fun y : ℝ≥0∞ ↦ y ^ x :=\n  HasLeftInverse.injective ⟨fun y ↦ y ^ x⁻¹, rpow_rpow_inv hx⟩\n\n"}
{"name":"ENNReal.rpow_left_surjective","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Function.Surjective fun y => HPow.hPow y x","decl":"theorem rpow_left_surjective {x : ℝ} (hx : x ≠ 0) : Function.Surjective fun y : ℝ≥0∞ => y ^ x :=\n  HasRightInverse.surjective ⟨fun y ↦ y ^ x⁻¹, rpow_inv_rpow hx⟩\n\n"}
{"name":"ENNReal.rpow_left_bijective","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x : Real\nhx : Ne x 0\n⊢ Function.Bijective fun y => HPow.hPow y x","decl":"theorem rpow_left_bijective {x : ℝ} (hx : x ≠ 0) : Function.Bijective fun y : ℝ≥0∞ => y ^ x :=\n  ⟨rpow_left_injective hx, rpow_left_surjective hx⟩\n\n"}
{"name":"Real.enorm_rpow_of_nonneg","module":"Mathlib.Analysis.SpecialFunctions.Pow.NNReal","initialProofState":"x y : Real\nhx : LE.le 0 x\nhy : LE.le 0 y\n⊢ Eq (ENorm.enorm (HPow.hPow x y)) (HPow.hPow (ENorm.enorm x) y)","decl":"lemma _root_.Real.enorm_rpow_of_nonneg {x y : ℝ} (hx : 0 ≤ x) (hy : 0 ≤ y) :\n    ‖x ^ y‖ₑ = ‖x‖ₑ ^ y := by simp [enorm, nnnorm_rpow_of_nonneg hx, coe_rpow_of_nonneg _ hy]\n\n"}
