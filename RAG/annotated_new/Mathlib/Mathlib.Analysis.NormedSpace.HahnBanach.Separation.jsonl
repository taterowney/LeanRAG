{"name":"separate_convex_open_set","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁴ : TopologicalSpace E\ninst✝³ : AddCommGroup E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : Module Real E\ninst✝ : ContinuousSMul Real E\ns : Set E\nhs₀ : Membership.mem s 0\nhs₁ : Convex Real s\nhs₂ : IsOpen s\nx₀ : E\nhx₀ : Not (Membership.mem s x₀)\n⊢ Exists fun f => And (Eq (f x₀) 1) (∀ (x : E), Membership.mem s x → LT.lt (f x) 1)","decl":"/-- Given a set `s` which is a convex neighbourhood of `0` and a point `x₀` outside of it, there is\na continuous linear functional `f` separating `x₀` and `s`, in the sense that it sends `x₀` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]\n    [Module ℝ E] [ContinuousSMul ℝ E] {s : Set E} (hs₀ : (0 : E) ∈ s) (hs₁ : Convex ℝ s)\n    (hs₂ : IsOpen s) {x₀ : E} (hx₀ : x₀ ∉ s) : ∃ f : E →L[ℝ] ℝ, f x₀ = 1 ∧ ∀ x ∈ s, f x < 1 := by\n  let f : E →ₗ.[ℝ] ℝ := LinearPMap.mkSpanSingleton x₀ 1 (ne_of_mem_of_not_mem hs₀ hx₀).symm\n  have := exists_extension_of_le_sublinear f (gauge s) (fun c hc => gauge_smul_of_nonneg hc.le)\n    (gauge_add_le hs₁ <| absorbent_nhds_zero <| hs₂.mem_nhds hs₀) ?_\n  · obtain ⟨φ, hφ₁, hφ₂⟩ := this\n    have hφ₃ : φ x₀ = 1 := by\n      rw [← f.domain.coe_mk x₀ (Submodule.mem_span_singleton_self _), hφ₁,\n        LinearPMap.mkSpanSingleton'_apply_self]\n    have hφ₄ : ∀ x ∈ s, φ x < 1 := fun x hx =>\n      (hφ₂ x).trans_lt (gauge_lt_one_of_mem_of_isOpen hs₂ hx)\n    refine ⟨⟨φ, ?_⟩, hφ₃, hφ₄⟩\n    refine\n      φ.continuous_of_nonzero_on_open _ (hs₂.vadd (-x₀)) (Nonempty.vadd_set ⟨0, hs₀⟩)\n        (vadd_set_subset_iff.mpr fun x hx => ?_)\n    change φ (-x₀ + x) ≠ 0\n    rw [map_add, map_neg]\n    specialize hφ₄ x hx\n    linarith\n  rintro ⟨x, hx⟩\n  obtain ⟨y, rfl⟩ := Submodule.mem_span_singleton.1 hx\n  rw [LinearPMap.mkSpanSingleton'_apply]\n  simp only [mul_one, Algebra.id.smul_eq_mul, Submodule.coe_mk]\n  obtain h | h := le_or_lt y 0\n  · exact h.trans (gauge_nonneg _)\n  · rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h]\n    exact\n      one_le_gauge_of_not_mem (hs₁.starConvex hs₀)\n        (absorbent_nhds_zero <| hs₂.mem_nhds hs₀).absorbs hx₀\n\n"}
{"name":"geometric_hahn_banach_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁴ : TopologicalSpace E\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns t : Set E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhs₁ : Convex Real s\nhs₂ : IsOpen s\nht : Convex Real t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => And (∀ (a : E), Membership.mem s a → LT.lt (f a) u) (∀ (b : E), Membership.mem t b → LE.le u (f b))","decl":"/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is open,\nthere is a continuous linear functional which separates them. -/\ntheorem geometric_hahn_banach_open (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (ht : Convex ℝ t)\n    (disj : Disjoint s t) : ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ a ∈ s, f a < u) ∧ ∀ b ∈ t, u ≤ f b := by\n  obtain rfl | ⟨a₀, ha₀⟩ := s.eq_empty_or_nonempty\n  · exact ⟨0, 0, by simp, fun b _hb => le_rfl⟩\n  obtain rfl | ⟨b₀, hb₀⟩ := t.eq_empty_or_nonempty\n  · exact ⟨0, 1, fun a _ha => zero_lt_one, by simp⟩\n  let x₀ := b₀ - a₀\n  let C := x₀ +ᵥ (s - t)\n  have : (0 : E) ∈ C :=\n    ⟨a₀ - b₀, sub_mem_sub ha₀ hb₀, by simp_rw [x₀, vadd_eq_add, sub_add_sub_cancel', sub_self]⟩\n  have : Convex ℝ C := (hs₁.sub ht).vadd _\n  have : x₀ ∉ C := by\n    intro hx₀\n    rw [← add_zero x₀] at hx₀\n    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hx₀)\n  obtain ⟨f, hf₁, hf₂⟩ := separate_convex_open_set ‹0 ∈ C› ‹_› (hs₂.sub_right.vadd _) ‹x₀ ∉ C›\n  have : f b₀ = f a₀ + 1 := by simp [x₀, ← hf₁]\n  have forall_le : ∀ a ∈ s, ∀ b ∈ t, f a ≤ f b := by\n    intro a ha b hb\n    have := hf₂ (x₀ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)\n    simp only [f.map_add, f.map_sub, hf₁] at this\n    linarith\n  refine ⟨f, sInf (f '' t), image_subset_iff.1 (?_ : f '' s ⊆ Iio (sInf (f '' t))), fun b hb => ?_⟩\n  · rw [← interior_Iic]\n    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero ?_ _ hs₂)\n    · exact le_csInf (Nonempty.image _ ⟨_, hb₀⟩) (forall_mem_image.2 <| forall_le _ ha)\n    · rintro rfl\n      simp at hf₁\n  · exact csInf_le ⟨f a₀, forall_mem_image.2 <| forall_le _ ha₀⟩ (mem_image_of_mem _ hb)\n\n"}
{"name":"geometric_hahn_banach_open_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁴ : TopologicalSpace E\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns : Set E\nx : E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhs₁ : Convex Real s\nhs₂ : IsOpen s\ndisj : Not (Membership.mem s x)\n⊢ Exists fun f => ∀ (a : E), Membership.mem s a → LT.lt (f a) (f x)","decl":"theorem geometric_hahn_banach_open_point (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (disj : x ∉ s) :\n    ∃ f : E →L[ℝ] ℝ, ∀ a ∈ s, f a < f x :=\n  let ⟨f, _s, hs, hx⟩ :=\n    geometric_hahn_banach_open hs₁ hs₂ (convex_singleton x) (disjoint_singleton_right.2 disj)\n  ⟨f, fun a ha => lt_of_lt_of_le (hs a ha) (hx x (mem_singleton _))⟩\n\n"}
{"name":"geometric_hahn_banach_point_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁴ : TopologicalSpace E\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\nt : Set E\nx : E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nht₁ : Convex Real t\nht₂ : IsOpen t\ndisj : Not (Membership.mem t x)\n⊢ Exists fun f => ∀ (b : E), Membership.mem t b → LT.lt (f x) (f b)","decl":"theorem geometric_hahn_banach_point_open (ht₁ : Convex ℝ t) (ht₂ : IsOpen t) (disj : x ∉ t) :\n    ∃ f : E →L[ℝ] ℝ, ∀ b ∈ t, f x < f b :=\n  let ⟨f, hf⟩ := geometric_hahn_banach_open_point ht₁ ht₂ disj\n  ⟨-f, by simpa⟩\n\n"}
{"name":"geometric_hahn_banach_open_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁴ : TopologicalSpace E\ninst✝³ : AddCommGroup E\ninst✝² : Module Real E\ns t : Set E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul Real E\nhs₁ : Convex Real s\nhs₂ : IsOpen s\nht₁ : Convex Real t\nht₃ : IsOpen t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => And (∀ (a : E), Membership.mem s a → LT.lt (f a) u) (∀ (b : E), Membership.mem t b → LT.lt u (f b))","decl":"theorem geometric_hahn_banach_open_open (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (ht₁ : Convex ℝ t)\n    (ht₃ : IsOpen t) (disj : Disjoint s t) :\n    ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ a ∈ s, f a < u) ∧ ∀ b ∈ t, u < f b := by\n  obtain rfl | ⟨a₀, ha₀⟩ := s.eq_empty_or_nonempty\n  · exact ⟨0, -1, by simp, fun b _hb => by norm_num⟩\n  obtain rfl | ⟨b₀, hb₀⟩ := t.eq_empty_or_nonempty\n  · exact ⟨0, 1, fun a _ha => by norm_num, by simp⟩\n  obtain ⟨f, s, hf₁, hf₂⟩ := geometric_hahn_banach_open hs₁ hs₂ ht₁ disj\n  have hf : IsOpenMap f := by\n    refine f.isOpenMap_of_ne_zero ?_\n    rintro rfl\n    simp_rw [ContinuousLinearMap.zero_apply] at hf₁ hf₂\n    exact (hf₁ _ ha₀).not_le (hf₂ _ hb₀)\n  refine ⟨f, s, hf₁, image_subset_iff.1 (?_ : f '' t ⊆ Ioi s)⟩\n  rw [← interior_Ici]\n  refine interior_maximal (image_subset_iff.2 hf₂) (f.isOpenMap_of_ne_zero ?_ _ ht₃)\n  rintro rfl\n  simp_rw [ContinuousLinearMap.zero_apply] at hf₁ hf₂\n  exact (hf₁ _ ha₀).not_le (hf₂ _ hb₀)\n\n"}
{"name":"geometric_hahn_banach_compact_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns t : Set E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsCompact s\nht₁ : Convex Real t\nht₂ : IsClosed t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => Exists fun v => And (∀ (a : E), Membership.mem s a → LT.lt (f a) u) (And (LT.lt u v) (∀ (b : E), Membership.mem t b → LT.lt v (f b)))","decl":"/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is\ncompact and `t` is closed, there is a continuous linear functional which strongly separates them. -/\ntheorem geometric_hahn_banach_compact_closed (hs₁ : Convex ℝ s) (hs₂ : IsCompact s)\n    (ht₁ : Convex ℝ t) (ht₂ : IsClosed t) (disj : Disjoint s t) :\n    ∃ (f : E →L[ℝ] ℝ) (u v : ℝ), (∀ a ∈ s, f a < u) ∧ u < v ∧ ∀ b ∈ t, v < f b := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  · exact ⟨0, -2, -1, by simp, by norm_num, fun b _hb => by norm_num⟩\n  obtain rfl | _ht := t.eq_empty_or_nonempty\n  · exact ⟨0, 1, 2, fun a _ha => by norm_num, by norm_num, by simp⟩\n  obtain ⟨U, V, hU, hV, hU₁, hV₁, sU, tV, disj'⟩ := disj.exists_open_convexes hs₁ hs₂ ht₁ ht₂\n  obtain ⟨f, u, hf₁, hf₂⟩ := geometric_hahn_banach_open_open hU₁ hU hV₁ hV disj'\n  obtain ⟨x, hx₁, hx₂⟩ := hs₂.exists_isMaxOn hs f.continuous.continuousOn\n  have : f x < u := hf₁ x (sU hx₁)\n  exact\n    ⟨f, (f x + u) / 2, u,\n      fun a ha => by have := hx₂ ha; dsimp at this; linarith,\n      by linarith,\n      fun b hb => hf₂ b (tV hb)⟩\n\n"}
{"name":"geometric_hahn_banach_closed_compact","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns t : Set E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\nht₁ : Convex Real t\nht₂ : IsCompact t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => Exists fun v => And (∀ (a : E), Membership.mem s a → LT.lt (f a) u) (And (LT.lt u v) (∀ (b : E), Membership.mem t b → LT.lt v (f b)))","decl":"/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is\nclosed, and `t` is compact, there is a continuous linear functional which strongly separates them.\n-/\ntheorem geometric_hahn_banach_closed_compact (hs₁ : Convex ℝ s) (hs₂ : IsClosed s)\n    (ht₁ : Convex ℝ t) (ht₂ : IsCompact t) (disj : Disjoint s t) :\n    ∃ (f : E →L[ℝ] ℝ) (u v : ℝ), (∀ a ∈ s, f a < u) ∧ u < v ∧ ∀ b ∈ t, v < f b :=\n  let ⟨f, s, t, hs, st, ht⟩ := geometric_hahn_banach_compact_closed ht₁ ht₂ hs₁ hs₂ disj.symm\n  ⟨-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hs⟩\n\n"}
{"name":"geometric_hahn_banach_point_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\nt : Set E\nx : E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\nht₁ : Convex Real t\nht₂ : IsClosed t\ndisj : Not (Membership.mem t x)\n⊢ Exists fun f => Exists fun u => And (LT.lt (f x) u) (∀ (b : E), Membership.mem t b → LT.lt u (f b))","decl":"theorem geometric_hahn_banach_point_closed (ht₁ : Convex ℝ t) (ht₂ : IsClosed t) (disj : x ∉ t) :\n    ∃ (f : E →L[ℝ] ℝ) (u : ℝ), f x < u ∧ ∀ b ∈ t, u < f b :=\n  let ⟨f, _u, v, ha, hst, hb⟩ :=\n    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton ht₁ ht₂\n      (disjoint_singleton_left.2 disj)\n  ⟨f, v, hst.trans' <| ha x <| mem_singleton _, hb⟩\n\n"}
{"name":"geometric_hahn_banach_closed_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\nx : E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\ndisj : Not (Membership.mem s x)\n⊢ Exists fun f => Exists fun u => And (∀ (a : E), Membership.mem s a → LT.lt (f a) u) (LT.lt u (f x))","decl":"theorem geometric_hahn_banach_closed_point (hs₁ : Convex ℝ s) (hs₂ : IsClosed s) (disj : x ∉ s) :\n    ∃ (f : E →L[ℝ] ℝ) (u : ℝ), (∀ a ∈ s, f a < u) ∧ u < f x :=\n  let ⟨f, s, _t, ha, hst, hb⟩ :=\n    geometric_hahn_banach_closed_compact hs₁ hs₂ (convex_singleton x) isCompact_singleton\n      (disjoint_singleton_right.2 disj)\n  ⟨f, s, ha, hst.trans <| hb x <| mem_singleton _⟩\n\n"}
{"name":"geometric_hahn_banach_point_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Real E\nx y : E\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousSMul Real E\ninst✝¹ : LocallyConvexSpace Real E\ninst✝ : T1Space E\nhxy : Ne x y\n⊢ Exists fun f => LT.lt (f x) (f y)","decl":"/-- See also `NormedSpace.eq_iff_forall_dual_eq`. -/\ntheorem geometric_hahn_banach_point_point [T1Space E] (hxy : x ≠ y) :\n    ∃ f : E →L[ℝ] ℝ, f x < f y := by\n  obtain ⟨f, s, t, hs, st, ht⟩ :=\n    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton\n      (convex_singleton y) isClosed_singleton (disjoint_singleton.2 hxy)\n  exact ⟨f, by linarith [hs x rfl, ht y rfl]⟩\n\n"}
{"name":"iInter_halfSpaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\n⊢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (l x) (l y))) s","decl":"/-- A closed convex set is the intersection of the half-spaces containing it. -/\ntheorem iInter_halfSpaces_eq (hs₁ : Convex ℝ s) (hs₂ : IsClosed s) :\n    ⋂ l : E →L[ℝ] ℝ, { x | ∃ y ∈ s, l x ≤ l y } = s := by\n  rw [Set.iInter_setOf]\n  refine Set.Subset.antisymm (fun x hx => ?_) fun x hx l => ⟨x, hx, le_rfl⟩\n  by_contra h\n  obtain ⟨l, s, hlA, hl⟩ := geometric_hahn_banach_closed_point hs₁ hs₂ h\n  obtain ⟨y, hy, hxy⟩ := hx l\n  exact ((hxy.trans_lt (hlA y hy)).trans hl).not_le le_rfl\n"}
{"name":"iInter_halfspaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninst✝⁵ : TopologicalSpace E\ninst✝⁴ : AddCommGroup E\ninst✝³ : Module Real E\ns : Set E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul Real E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\n⊢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (l x) (l y))) s","decl":"@[deprecated (since := \"2024-11-12\")] alias iInter_halfspaces_eq := iInter_halfSpaces_eq\n\n"}
{"name":"RCLike.re_extendTo𝕜'ₗ","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁶ : TopologicalSpace E\ninst✝⁵ : AddCommGroup E\ninst✝⁴ : Module Real E\ninst✝³ : RCLike 𝕜\ninst✝² : Module 𝕜 E\ninst✝¹ : IsScalarTower Real 𝕜 E\ninst✝ : ContinuousConstSMul 𝕜 E\ng : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\n⊢ Eq (RCLike.re ((RCLike.extendTo𝕜'ₗ g) x)) (g x)","decl":"@[simp]\nlemma re_extendTo𝕜'ₗ [ContinuousConstSMul 𝕜 E] (g : E →L[ℝ] ℝ) (x : E) : re ((extendTo𝕜'ₗ g) x : 𝕜)\n    = g x := by\n  have h g (x : E) : extendTo𝕜'ₗ g x = ((g x : 𝕜) - (I : 𝕜) * (g ((I : 𝕜) • x) : 𝕜)) := rfl\n  simp only [h , map_sub, ofReal_re, mul_re, I_re, zero_mul, ofReal_im, mul_zero,\n    sub_self, sub_zero]\n\n"}
{"name":"RCLike.separate_convex_open_set","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : TopologicalSpace E\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\ns : Set E\nhs₀ : Membership.mem s 0\nhs₁ : Convex Real s\nhs₂ : IsOpen s\nx₀ : E\nhx₀ : Not (Membership.mem s x₀)\n⊢ Exists fun f => And (Eq (RCLike.re (f x₀)) 1) (∀ (x : E), Membership.mem s x → LT.lt (RCLike.re (f x)) 1)","decl":"theorem separate_convex_open_set {s : Set E}\n    (hs₀ : (0 : E) ∈ s) (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) {x₀ : E} (hx₀ : x₀ ∉ s) :\n    ∃ f : E →L[𝕜] 𝕜, re (f x₀) = 1 ∧ ∀ x ∈ s, re (f x) < 1 := by\n  have := IsScalarTower.continuousSMul (M := ℝ) (α := E) 𝕜\n  obtain ⟨g, hg⟩ := _root_.separate_convex_open_set hs₀ hs₁ hs₂ hx₀\n  use extendTo𝕜'ₗ g\n  simp only [re_extendTo𝕜'ₗ]\n  exact hg\n\n"}
{"name":"RCLike.geometric_hahn_banach_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : TopologicalSpace E\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ns t : Set E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\nhs₁ : Convex Real s\nhs₂ : IsOpen s\nht : Convex Real t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => And (∀ (a : E), Membership.mem s a → LT.lt (RCLike.re (f a)) u) (∀ (b : E), Membership.mem t b → LE.le u (RCLike.re (f b)))","decl":"theorem geometric_hahn_banach_open (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (ht : Convex ℝ t)\n    (disj : Disjoint s t) : ∃ (f : E →L[𝕜] 𝕜) (u : ℝ), (∀ a ∈ s, re (f a) < u) ∧\n    ∀ b ∈ t, u ≤ re (f b) := by\n  have := IsScalarTower.continuousSMul (M := ℝ) (α := E) 𝕜\n  obtain ⟨f, u, h⟩ := _root_.geometric_hahn_banach_open hs₁ hs₂ ht disj\n  use extendTo𝕜'ₗ f\n  simp only [re_extendTo𝕜'ₗ]\n  exact Exists.intro u h\n\n"}
{"name":"RCLike.geometric_hahn_banach_open_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : TopologicalSpace E\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ns : Set E\nx : E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\nhs₁ : Convex Real s\nhs₂ : IsOpen s\ndisj : Not (Membership.mem s x)\n⊢ Exists fun f => ∀ (a : E), Membership.mem s a → LT.lt (RCLike.re (f a)) (RCLike.re (f x))","decl":"theorem geometric_hahn_banach_open_point (hs₁ : Convex ℝ s) (hs₂ : IsOpen s) (disj : x ∉ s) :\n    ∃ f : E →L[𝕜] 𝕜, ∀ a ∈ s, re (f a) < re (f x) := by\n  have := IsScalarTower.continuousSMul (M := ℝ) (α := E) 𝕜\n  obtain ⟨f, h⟩ := _root_.geometric_hahn_banach_open_point hs₁ hs₂ disj\n  use extendTo𝕜'ₗ f\n  simp only [re_extendTo𝕜'ₗ]\n  exact fun a a_1 ↦ h a a_1\n\n"}
{"name":"RCLike.geometric_hahn_banach_point_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : TopologicalSpace E\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\nt : Set E\nx : E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\nht₁ : Convex Real t\nht₂ : IsOpen t\ndisj : Not (Membership.mem t x)\n⊢ Exists fun f => ∀ (b : E), Membership.mem t b → LT.lt (RCLike.re (f x)) (RCLike.re (f b))","decl":"theorem geometric_hahn_banach_point_open (ht₁ : Convex ℝ t) (ht₂ : IsOpen t) (disj : x ∉ t) :\n    ∃ f : E →L[𝕜] 𝕜, ∀ b ∈ t, re (f x) < re (f b) :=\n  let ⟨f, hf⟩ := geometric_hahn_banach_open_point ht₁ ht₂ disj\n  ⟨-f, by simpa⟩\n\n"}
{"name":"RCLike.geometric_hahn_banach_open_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁷ : TopologicalSpace E\ninst✝⁶ : AddCommGroup E\ninst✝⁵ : Module Real E\ns t : Set E\ninst✝⁴ : RCLike 𝕜\ninst✝³ : Module 𝕜 E\ninst✝² : IsScalarTower Real 𝕜 E\ninst✝¹ : TopologicalAddGroup E\ninst✝ : ContinuousSMul 𝕜 E\nhs₁ : Convex Real s\nhs₂ : IsOpen s\nht₁ : Convex Real t\nht₃ : IsOpen t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => And (∀ (a : E), Membership.mem s a → LT.lt (RCLike.re (f a)) u) (∀ (b : E), Membership.mem t b → LT.lt u (RCLike.re (f b)))","decl":"theorem geometric_hahn_banach_open_open (hs₁ : Convex ℝ s) (hs₂ : IsOpen s)\n    (ht₁ : Convex ℝ t) (ht₃ : IsOpen t) (disj : Disjoint s t) :\n    ∃ (f : E →L[𝕜] 𝕜) (u : ℝ), (∀ a ∈ s, re (f a) < u) ∧ ∀ b ∈ t, u < re (f b) := by\n  have := IsScalarTower.continuousSMul (M := ℝ) (α := E) 𝕜\n  obtain ⟨f, u, h⟩ := _root_.geometric_hahn_banach_open_open hs₁ hs₂ ht₁ ht₃ disj\n  use extendTo𝕜'ₗ f\n  simp only [re_extendTo𝕜'ₗ]\n  exact Exists.intro u h\n\n"}
{"name":"RCLike.geometric_hahn_banach_compact_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\ns t : Set E\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : IsScalarTower Real 𝕜 E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsCompact s\nht₁ : Convex Real t\nht₂ : IsClosed t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => Exists fun v => And (∀ (a : E), Membership.mem s a → LT.lt (RCLike.re (f a)) u) (And (LT.lt u v) (∀ (b : E), Membership.mem t b → LT.lt v (RCLike.re (f b))))","decl":"theorem geometric_hahn_banach_compact_closed (hs₁ : Convex ℝ s) (hs₂ : IsCompact s)\n    (ht₁ : Convex ℝ t) (ht₂ : IsClosed t) (disj : Disjoint s t) :\n    ∃ (f : E →L[𝕜] 𝕜) (u v : ℝ), (∀ a ∈ s, re (f a) < u) ∧ u < v ∧ ∀ b ∈ t, v < re (f b) := by\n  have := IsScalarTower.continuousSMul (M := ℝ) (α := E) 𝕜\n  obtain ⟨g, u, v, h1⟩ := _root_.geometric_hahn_banach_compact_closed hs₁ hs₂ ht₁ ht₂ disj\n  use extendTo𝕜'ₗ g\n  simp only [re_extendTo𝕜'ₗ, exists_and_left]\n  exact ⟨u, h1.1, v, h1.2⟩\n\n"}
{"name":"RCLike.geometric_hahn_banach_closed_compact","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\ns t : Set E\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : IsScalarTower Real 𝕜 E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\nht₁ : Convex Real t\nht₂ : IsCompact t\ndisj : Disjoint s t\n⊢ Exists fun f => Exists fun u => Exists fun v => And (∀ (a : E), Membership.mem s a → LT.lt (RCLike.re (f a)) u) (And (LT.lt u v) (∀ (b : E), Membership.mem t b → LT.lt v (RCLike.re (f b))))","decl":"theorem geometric_hahn_banach_closed_compact (hs₁ : Convex ℝ s) (hs₂ : IsClosed s)\n    (ht₁ : Convex ℝ t) (ht₂ : IsCompact t) (disj : Disjoint s t) :\n    ∃ (f : E →L[𝕜] 𝕜) (u v : ℝ), (∀ a ∈ s, re (f a) < u) ∧ u < v ∧ ∀ b ∈ t, v < re (f b) :=\n  let ⟨f, s, t, hs, st, ht⟩ := geometric_hahn_banach_compact_closed ht₁ ht₂ hs₁ hs₂ disj.symm\n  ⟨-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hs⟩\n\n"}
{"name":"RCLike.geometric_hahn_banach_point_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\nt : Set E\nx : E\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : IsScalarTower Real 𝕜 E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : LocallyConvexSpace Real E\nht₁ : Convex Real t\nht₂ : IsClosed t\ndisj : Not (Membership.mem t x)\n⊢ Exists fun f => Exists fun u => And (LT.lt (RCLike.re (f x)) u) (∀ (b : E), Membership.mem t b → LT.lt u (RCLike.re (f b)))","decl":"theorem geometric_hahn_banach_point_closed (ht₁ : Convex ℝ t) (ht₂ : IsClosed t)\n    (disj : x ∉ t) : ∃ (f : E →L[𝕜] 𝕜) (u : ℝ), re (f x) < u ∧ ∀ b ∈ t, u < re (f b) :=\n  let ⟨f, _u, v, ha, hst, hb⟩ :=\n    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton ht₁ ht₂\n      (disjoint_singleton_left.2 disj)\n  ⟨f, v, hst.trans' <| ha x <| mem_singleton _, hb⟩\n\n"}
{"name":"RCLike.geometric_hahn_banach_closed_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\ns : Set E\nx : E\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : IsScalarTower Real 𝕜 E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\ndisj : Not (Membership.mem s x)\n⊢ Exists fun f => Exists fun u => And (∀ (a : E), Membership.mem s a → LT.lt (RCLike.re (f a)) u) (LT.lt u (RCLike.re (f x)))","decl":"theorem geometric_hahn_banach_closed_point (hs₁ : Convex ℝ s) (hs₂ : IsClosed s)\n    (disj : x ∉ s) : ∃ (f : E →L[𝕜] 𝕜) (u : ℝ), (∀ a ∈ s, re (f a) < u) ∧ u < re (f x) :=\n  let ⟨f, s, _t, ha, hst, hb⟩ :=\n    geometric_hahn_banach_closed_compact hs₁ hs₂ (convex_singleton x) isCompact_singleton\n      (disjoint_singleton_right.2 disj)\n  ⟨f, s, ha, hst.trans <| hb x <| mem_singleton _⟩\n\n"}
{"name":"RCLike.geometric_hahn_banach_point_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁹ : TopologicalSpace E\ninst✝⁸ : AddCommGroup E\ninst✝⁷ : Module Real E\nx y : E\ninst✝⁶ : RCLike 𝕜\ninst✝⁵ : Module 𝕜 E\ninst✝⁴ : IsScalarTower Real 𝕜 E\ninst✝³ : TopologicalAddGroup E\ninst✝² : ContinuousSMul 𝕜 E\ninst✝¹ : LocallyConvexSpace Real E\ninst✝ : T1Space E\nhxy : Ne x y\n⊢ Exists fun f => LT.lt (RCLike.re (f x)) (RCLike.re (f y))","decl":"theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x ≠ y) :\n    ∃ f : E →L[𝕜] 𝕜, re (f x) < re (f y) := by\n  obtain ⟨f, s, t, hs, st, ht⟩ :=\n    geometric_hahn_banach_compact_closed (𝕜 := 𝕜) (convex_singleton x) isCompact_singleton\n      (convex_singleton y) isClosed_singleton (disjoint_singleton.2 hxy)\n  exact ⟨f, by linarith [hs x rfl, ht y rfl]⟩\n\n"}
{"name":"RCLike.iInter_halfSpaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\ns : Set E\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : IsScalarTower Real 𝕜 E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\n⊢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (RCLike.re (l x)) (RCLike.re (l y)))) s","decl":"theorem iInter_halfSpaces_eq (hs₁ : Convex ℝ s) (hs₂ : IsClosed s) :\n    ⋂ l : E →L[𝕜] 𝕜, { x | ∃ y ∈ s, re (l x) ≤ re (l y) } = s := by\n  rw [Set.iInter_setOf]\n  refine Set.Subset.antisymm (fun x hx => ?_) fun x hx l => ⟨x, hx, le_rfl⟩\n  by_contra h\n  obtain ⟨l, s, hlA, hl⟩ := geometric_hahn_banach_closed_point (𝕜 := 𝕜) hs₁ hs₂ h\n  obtain ⟨y, hy, hxy⟩ := hx l\n  exact ((hxy.trans_lt (hlA y hy)).trans hl).false\n"}
{"name":"RCLike.iInter_halfspaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁸ : TopologicalSpace E\ninst✝⁷ : AddCommGroup E\ninst✝⁶ : Module Real E\ns : Set E\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : Module 𝕜 E\ninst✝³ : IsScalarTower Real 𝕜 E\ninst✝² : TopologicalAddGroup E\ninst✝¹ : ContinuousSMul 𝕜 E\ninst✝ : LocallyConvexSpace Real E\nhs₁ : Convex Real s\nhs₂ : IsClosed s\n⊢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (RCLike.re (l x)) (RCLike.re (l y)))) s","decl":"@[deprecated (since := \"2024-11-12\")] alias iInter_halfspaces_eq := iInter_halfSpaces_eq\n\n"}
