{"name":"separate_convex_open_set","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : Module Real E\ninstâœ : ContinuousSMul Real E\ns : Set E\nhsâ‚€ : Membership.mem s 0\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\nxâ‚€ : E\nhxâ‚€ : Not (Membership.mem s xâ‚€)\nâŠ¢ Exists fun f => And (Eq (f xâ‚€) 1) (âˆ€ (x : E), Membership.mem s x â†’ LT.lt (f x) 1)","decl":"/-- Given a set `s` which is a convex neighbourhood of `0` and a point `xâ‚€` outside of it, there is\na continuous linear functional `f` separating `xâ‚€` and `s`, in the sense that it sends `xâ‚€` to 1 and\nall of `s` to values strictly below `1`. -/\ntheorem separate_convex_open_set [TopologicalSpace E] [AddCommGroup E] [TopologicalAddGroup E]\n    [Module â„ E] [ContinuousSMul â„ E] {s : Set E} (hsâ‚€ : (0 : E) âˆˆ s) (hsâ‚ : Convex â„ s)\n    (hsâ‚‚ : IsOpen s) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ s) : âˆƒ f : E â†’L[â„] â„, f xâ‚€ = 1 âˆ§ âˆ€ x âˆˆ s, f x < 1 := by\n  let f : E â†’â‚—.[â„] â„ := LinearPMap.mkSpanSingleton xâ‚€ 1 (ne_of_mem_of_not_mem hsâ‚€ hxâ‚€).symm\n  have := exists_extension_of_le_sublinear f (gauge s) (fun c hc => gauge_smul_of_nonneg hc.le)\n    (gauge_add_le hsâ‚ <| absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€) ?_\n  Â· obtain âŸ¨Ï†, hÏ†â‚, hÏ†â‚‚âŸ© := this\n    have hÏ†â‚ƒ : Ï† xâ‚€ = 1 := by\n      rw [â† f.domain.coe_mk xâ‚€ (Submodule.mem_span_singleton_self _), hÏ†â‚,\n        LinearPMap.mkSpanSingleton'_apply_self]\n    have hÏ†â‚„ : âˆ€ x âˆˆ s, Ï† x < 1 := fun x hx =>\n      (hÏ†â‚‚ x).trans_lt (gauge_lt_one_of_mem_of_isOpen hsâ‚‚ hx)\n    refine âŸ¨âŸ¨Ï†, ?_âŸ©, hÏ†â‚ƒ, hÏ†â‚„âŸ©\n    refine\n      Ï†.continuous_of_nonzero_on_open _ (hsâ‚‚.vadd (-xâ‚€)) (Nonempty.vadd_set âŸ¨0, hsâ‚€âŸ©)\n        (vadd_set_subset_iff.mpr fun x hx => ?_)\n    change Ï† (-xâ‚€ + x) â‰  0\n    rw [map_add, map_neg]\n    specialize hÏ†â‚„ x hx\n    linarith\n  rintro âŸ¨x, hxâŸ©\n  obtain âŸ¨y, rflâŸ© := Submodule.mem_span_singleton.1 hx\n  rw [LinearPMap.mkSpanSingleton'_apply]\n  simp only [mul_one, Algebra.id.smul_eq_mul, Submodule.coe_mk]\n  obtain h | h := le_or_lt y 0\n  Â· exact h.trans (gauge_nonneg _)\n  Â· rw [gauge_smul_of_nonneg h.le, smul_eq_mul, le_mul_iff_one_le_right h]\n    exact\n      one_le_gauge_of_not_mem (hsâ‚.starConvex hsâ‚€)\n        (absorbent_nhds_zero <| hsâ‚‚.mem_nhds hsâ‚€).absorbs hxâ‚€\n\n"}
{"name":"geometric_hahn_banach_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns t : Set E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\nht : Convex Real t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (f a) u) (âˆ€ (b : E), Membership.mem t b â†’ LE.le u (f b))","decl":"/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is open,\nthere is a continuous linear functional which separates them. -/\ntheorem geometric_hahn_banach_open (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s) (ht : Convex â„ t)\n    (disj : Disjoint s t) : âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ âˆ€ b âˆˆ t, u â‰¤ f b := by\n  obtain rfl | âŸ¨aâ‚€, haâ‚€âŸ© := s.eq_empty_or_nonempty\n  Â· exact âŸ¨0, 0, by simp, fun b _hb => le_rflâŸ©\n  obtain rfl | âŸ¨bâ‚€, hbâ‚€âŸ© := t.eq_empty_or_nonempty\n  Â· exact âŸ¨0, 1, fun a _ha => zero_lt_one, by simpâŸ©\n  let xâ‚€ := bâ‚€ - aâ‚€\n  let C := xâ‚€ +áµ¥ (s - t)\n  have : (0 : E) âˆˆ C :=\n    âŸ¨aâ‚€ - bâ‚€, sub_mem_sub haâ‚€ hbâ‚€, by simp_rw [xâ‚€, vadd_eq_add, sub_add_sub_cancel', sub_self]âŸ©\n  have : Convex â„ C := (hsâ‚.sub ht).vadd _\n  have : xâ‚€ âˆ‰ C := by\n    intro hxâ‚€\n    rw [â† add_zero xâ‚€] at hxâ‚€\n    exact disj.zero_not_mem_sub_set (vadd_mem_vadd_set_iff.1 hxâ‚€)\n  obtain âŸ¨f, hfâ‚, hfâ‚‚âŸ© := separate_convex_open_set â€¹0 âˆˆ Câ€º â€¹_â€º (hsâ‚‚.sub_right.vadd _) â€¹xâ‚€ âˆ‰ Câ€º\n  have : f bâ‚€ = f aâ‚€ + 1 := by simp [xâ‚€, â† hfâ‚]\n  have forall_le : âˆ€ a âˆˆ s, âˆ€ b âˆˆ t, f a â‰¤ f b := by\n    intro a ha b hb\n    have := hfâ‚‚ (xâ‚€ + (a - b)) (vadd_mem_vadd_set <| sub_mem_sub ha hb)\n    simp only [f.map_add, f.map_sub, hfâ‚] at this\n    linarith\n  refine âŸ¨f, sInf (f '' t), image_subset_iff.1 (?_ : f '' s âŠ† Iio (sInf (f '' t))), fun b hb => ?_âŸ©\n  Â· rw [â† interior_Iic]\n    refine interior_maximal (image_subset_iff.2 fun a ha => ?_) (f.isOpenMap_of_ne_zero ?_ _ hsâ‚‚)\n    Â· exact le_csInf (Nonempty.image _ âŸ¨_, hbâ‚€âŸ©) (forall_mem_image.2 <| forall_le _ ha)\n    Â· rintro rfl\n      simp at hfâ‚\n  Â· exact csInf_le âŸ¨f aâ‚€, forall_mem_image.2 <| forall_le _ haâ‚€âŸ© (mem_image_of_mem _ hb)\n\n"}
{"name":"geometric_hahn_banach_open_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns : Set E\nx : E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\ndisj : Not (Membership.mem s x)\nâŠ¢ Exists fun f => âˆ€ (a : E), Membership.mem s a â†’ LT.lt (f a) (f x)","decl":"theorem geometric_hahn_banach_open_point (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s) (disj : x âˆ‰ s) :\n    âˆƒ f : E â†’L[â„] â„, âˆ€ a âˆˆ s, f a < f x :=\n  let âŸ¨f, _s, hs, hxâŸ© :=\n    geometric_hahn_banach_open hsâ‚ hsâ‚‚ (convex_singleton x) (disjoint_singleton_right.2 disj)\n  âŸ¨f, fun a ha => lt_of_lt_of_le (hs a ha) (hx x (mem_singleton _))âŸ©\n\n"}
{"name":"geometric_hahn_banach_point_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\nt : Set E\nx : E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsOpen t\ndisj : Not (Membership.mem t x)\nâŠ¢ Exists fun f => âˆ€ (b : E), Membership.mem t b â†’ LT.lt (f x) (f b)","decl":"theorem geometric_hahn_banach_point_open (htâ‚ : Convex â„ t) (htâ‚‚ : IsOpen t) (disj : x âˆ‰ t) :\n    âˆƒ f : E â†’L[â„] â„, âˆ€ b âˆˆ t, f x < f b :=\n  let âŸ¨f, hfâŸ© := geometric_hahn_banach_open_point htâ‚ htâ‚‚ disj\n  âŸ¨-f, by simpaâŸ©\n\n"}
{"name":"geometric_hahn_banach_open_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâ´ : TopologicalSpace E\ninstâœÂ³ : AddCommGroup E\ninstâœÂ² : Module Real E\ns t : Set E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\nhtâ‚ : Convex Real t\nhtâ‚ƒ : IsOpen t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (f a) u) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt u (f b))","decl":"theorem geometric_hahn_banach_open_open (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s) (htâ‚ : Convex â„ t)\n    (htâ‚ƒ : IsOpen t) (disj : Disjoint s t) :\n    âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ âˆ€ b âˆˆ t, u < f b := by\n  obtain rfl | âŸ¨aâ‚€, haâ‚€âŸ© := s.eq_empty_or_nonempty\n  Â· exact âŸ¨0, -1, by simp, fun b _hb => by norm_numâŸ©\n  obtain rfl | âŸ¨bâ‚€, hbâ‚€âŸ© := t.eq_empty_or_nonempty\n  Â· exact âŸ¨0, 1, fun a _ha => by norm_num, by simpâŸ©\n  obtain âŸ¨f, s, hfâ‚, hfâ‚‚âŸ© := geometric_hahn_banach_open hsâ‚ hsâ‚‚ htâ‚ disj\n  have hf : IsOpenMap f := by\n    refine f.isOpenMap_of_ne_zero ?_\n    rintro rfl\n    simp_rw [ContinuousLinearMap.zero_apply] at hfâ‚ hfâ‚‚\n    exact (hfâ‚ _ haâ‚€).not_le (hfâ‚‚ _ hbâ‚€)\n  refine âŸ¨f, s, hfâ‚, image_subset_iff.1 (?_ : f '' t âŠ† Ioi s)âŸ©\n  rw [â† interior_Ici]\n  refine interior_maximal (image_subset_iff.2 hfâ‚‚) (f.isOpenMap_of_ne_zero ?_ _ htâ‚ƒ)\n  rintro rfl\n  simp_rw [ContinuousLinearMap.zero_apply] at hfâ‚ hfâ‚‚\n  exact (hfâ‚ _ haâ‚€).not_le (hfâ‚‚ _ hbâ‚€)\n\n"}
{"name":"geometric_hahn_banach_compact_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns t : Set E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul Real E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsCompact s\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsClosed t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => Exists fun v => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (f a) u) (And (LT.lt u v) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt v (f b)))","decl":"/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is\ncompact and `t` is closed, there is a continuous linear functional which strongly separates them. -/\ntheorem geometric_hahn_banach_compact_closed (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsCompact s)\n    (htâ‚ : Convex â„ t) (htâ‚‚ : IsClosed t) (disj : Disjoint s t) :\n    âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ u < v âˆ§ âˆ€ b âˆˆ t, v < f b := by\n  obtain rfl | hs := s.eq_empty_or_nonempty\n  Â· exact âŸ¨0, -2, -1, by simp, by norm_num, fun b _hb => by norm_numâŸ©\n  obtain rfl | _ht := t.eq_empty_or_nonempty\n  Â· exact âŸ¨0, 1, 2, fun a _ha => by norm_num, by norm_num, by simpâŸ©\n  obtain âŸ¨U, V, hU, hV, hUâ‚, hVâ‚, sU, tV, disj'âŸ© := disj.exists_open_convexes hsâ‚ hsâ‚‚ htâ‚ htâ‚‚\n  obtain âŸ¨f, u, hfâ‚, hfâ‚‚âŸ© := geometric_hahn_banach_open_open hUâ‚ hU hVâ‚ hV disj'\n  obtain âŸ¨x, hxâ‚, hxâ‚‚âŸ© := hsâ‚‚.exists_isMaxOn hs f.continuous.continuousOn\n  have : f x < u := hfâ‚ x (sU hxâ‚)\n  exact\n    âŸ¨f, (f x + u) / 2, u,\n      fun a ha => by have := hxâ‚‚ ha; dsimp at this; linarith,\n      by linarith,\n      fun b hb => hfâ‚‚ b (tV hb)âŸ©\n\n"}
{"name":"geometric_hahn_banach_closed_compact","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns t : Set E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul Real E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsCompact t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => Exists fun v => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (f a) u) (And (LT.lt u v) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt v (f b)))","decl":"/-- A version of the **Hahn-Banach theorem**: given disjoint convex sets `s`, `t` where `s` is\nclosed, and `t` is compact, there is a continuous linear functional which strongly separates them.\n-/\ntheorem geometric_hahn_banach_closed_compact (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsClosed s)\n    (htâ‚ : Convex â„ t) (htâ‚‚ : IsCompact t) (disj : Disjoint s t) :\n    âˆƒ (f : E â†’L[â„] â„) (u v : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ u < v âˆ§ âˆ€ b âˆˆ t, v < f b :=\n  let âŸ¨f, s, t, hs, st, htâŸ© := geometric_hahn_banach_compact_closed htâ‚ htâ‚‚ hsâ‚ hsâ‚‚ disj.symm\n  âŸ¨-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hsâŸ©\n\n"}
{"name":"geometric_hahn_banach_point_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\nt : Set E\nx : E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul Real E\ninstâœ : LocallyConvexSpace Real E\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsClosed t\ndisj : Not (Membership.mem t x)\nâŠ¢ Exists fun f => Exists fun u => And (LT.lt (f x) u) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt u (f b))","decl":"theorem geometric_hahn_banach_point_closed (htâ‚ : Convex â„ t) (htâ‚‚ : IsClosed t) (disj : x âˆ‰ t) :\n    âˆƒ (f : E â†’L[â„] â„) (u : â„), f x < u âˆ§ âˆ€ b âˆˆ t, u < f b :=\n  let âŸ¨f, _u, v, ha, hst, hbâŸ© :=\n    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton htâ‚ htâ‚‚\n      (disjoint_singleton_left.2 disj)\n  âŸ¨f, v, hst.trans' <| ha x <| mem_singleton _, hbâŸ©\n\n"}
{"name":"geometric_hahn_banach_closed_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\nx : E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul Real E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\ndisj : Not (Membership.mem s x)\nâŠ¢ Exists fun f => Exists fun u => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (f a) u) (LT.lt u (f x))","decl":"theorem geometric_hahn_banach_closed_point (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsClosed s) (disj : x âˆ‰ s) :\n    âˆƒ (f : E â†’L[â„] â„) (u : â„), (âˆ€ a âˆˆ s, f a < u) âˆ§ u < f x :=\n  let âŸ¨f, s, _t, ha, hst, hbâŸ© :=\n    geometric_hahn_banach_closed_compact hsâ‚ hsâ‚‚ (convex_singleton x) isCompact_singleton\n      (disjoint_singleton_right.2 disj)\n  âŸ¨f, s, ha, hst.trans <| hb x <| mem_singleton _âŸ©\n\n"}
{"name":"geometric_hahn_banach_point_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module Real E\nx y : E\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousSMul Real E\ninstâœÂ¹ : LocallyConvexSpace Real E\ninstâœ : T1Space E\nhxy : Ne x y\nâŠ¢ Exists fun f => LT.lt (f x) (f y)","decl":"/-- See also `NormedSpace.eq_iff_forall_dual_eq`. -/\ntheorem geometric_hahn_banach_point_point [T1Space E] (hxy : x â‰  y) :\n    âˆƒ f : E â†’L[â„] â„, f x < f y := by\n  obtain âŸ¨f, s, t, hs, st, htâŸ© :=\n    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton\n      (convex_singleton y) isClosed_singleton (disjoint_singleton.2 hxy)\n  exact âŸ¨f, by linarith [hs x rfl, ht y rfl]âŸ©\n\n"}
{"name":"iInter_halfSpaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul Real E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\nâŠ¢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (l x) (l y))) s","decl":"/-- A closed convex set is the intersection of the half-spaces containing it. -/\ntheorem iInter_halfSpaces_eq (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsClosed s) :\n    â‹‚ l : E â†’L[â„] â„, { x | âˆƒ y âˆˆ s, l x â‰¤ l y } = s := by\n  rw [Set.iInter_setOf]\n  refine Set.Subset.antisymm (fun x hx => ?_) fun x hx l => âŸ¨x, hx, le_rflâŸ©\n  by_contra h\n  obtain âŸ¨l, s, hlA, hlâŸ© := geometric_hahn_banach_closed_point hsâ‚ hsâ‚‚ h\n  obtain âŸ¨y, hy, hxyâŸ© := hx l\n  exact ((hxy.trans_lt (hlA y hy)).trans hl).not_le le_rfl\n"}
{"name":"iInter_halfspaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"E : Type u_2\ninstâœâµ : TopologicalSpace E\ninstâœâ´ : AddCommGroup E\ninstâœÂ³ : Module Real E\ns : Set E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul Real E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\nâŠ¢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (l x) (l y))) s","decl":"@[deprecated (since := \"2024-11-12\")] alias iInter_halfspaces_eq := iInter_halfSpaces_eq\n\n"}
{"name":"RCLike.re_extendToğ•œ'â‚—","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¶ : TopologicalSpace E\ninstâœâµ : AddCommGroup E\ninstâœâ´ : Module Real E\ninstâœÂ³ : RCLike ğ•œ\ninstâœÂ² : Module ğ•œ E\ninstâœÂ¹ : IsScalarTower Real ğ•œ E\ninstâœ : ContinuousConstSMul ğ•œ E\ng : ContinuousLinearMap (RingHom.id Real) E Real\nx : E\nâŠ¢ Eq (RCLike.re ((RCLike.extendToğ•œ'â‚— g) x)) (g x)","decl":"@[simp]\nlemma re_extendToğ•œ'â‚— [ContinuousConstSMul ğ•œ E] (g : E â†’L[â„] â„) (x : E) : re ((extendToğ•œ'â‚— g) x : ğ•œ)\n    = g x := by\n  have h g (x : E) : extendToğ•œ'â‚— g x = ((g x : ğ•œ) - (I : ğ•œ) * (g ((I : ğ•œ) â€¢ x) : ğ•œ)) := rfl\n  simp only [h , map_sub, ofReal_re, mul_re, I_re, zero_mul, ofReal_im, mul_zero,\n    sub_self, sub_zero]\n\n"}
{"name":"RCLike.separate_convex_open_set","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\ns : Set E\nhsâ‚€ : Membership.mem s 0\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\nxâ‚€ : E\nhxâ‚€ : Not (Membership.mem s xâ‚€)\nâŠ¢ Exists fun f => And (Eq (RCLike.re (f xâ‚€)) 1) (âˆ€ (x : E), Membership.mem s x â†’ LT.lt (RCLike.re (f x)) 1)","decl":"theorem separate_convex_open_set {s : Set E}\n    (hsâ‚€ : (0 : E) âˆˆ s) (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s) {xâ‚€ : E} (hxâ‚€ : xâ‚€ âˆ‰ s) :\n    âˆƒ f : E â†’L[ğ•œ] ğ•œ, re (f xâ‚€) = 1 âˆ§ âˆ€ x âˆˆ s, re (f x) < 1 := by\n  have := IsScalarTower.continuousSMul (M := â„) (Î± := E) ğ•œ\n  obtain âŸ¨g, hgâŸ© := _root_.separate_convex_open_set hsâ‚€ hsâ‚ hsâ‚‚ hxâ‚€\n  use extendToğ•œ'â‚— g\n  simp only [re_extendToğ•œ'â‚—]\n  exact hg\n\n"}
{"name":"RCLike.geometric_hahn_banach_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\ns t : Set E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\nht : Convex Real t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (RCLike.re (f a)) u) (âˆ€ (b : E), Membership.mem t b â†’ LE.le u (RCLike.re (f b)))","decl":"theorem geometric_hahn_banach_open (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s) (ht : Convex â„ t)\n    (disj : Disjoint s t) : âˆƒ (f : E â†’L[ğ•œ] ğ•œ) (u : â„), (âˆ€ a âˆˆ s, re (f a) < u) âˆ§\n    âˆ€ b âˆˆ t, u â‰¤ re (f b) := by\n  have := IsScalarTower.continuousSMul (M := â„) (Î± := E) ğ•œ\n  obtain âŸ¨f, u, hâŸ© := _root_.geometric_hahn_banach_open hsâ‚ hsâ‚‚ ht disj\n  use extendToğ•œ'â‚— f\n  simp only [re_extendToğ•œ'â‚—]\n  exact Exists.intro u h\n\n"}
{"name":"RCLike.geometric_hahn_banach_open_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\ns : Set E\nx : E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\ndisj : Not (Membership.mem s x)\nâŠ¢ Exists fun f => âˆ€ (a : E), Membership.mem s a â†’ LT.lt (RCLike.re (f a)) (RCLike.re (f x))","decl":"theorem geometric_hahn_banach_open_point (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s) (disj : x âˆ‰ s) :\n    âˆƒ f : E â†’L[ğ•œ] ğ•œ, âˆ€ a âˆˆ s, re (f a) < re (f x) := by\n  have := IsScalarTower.continuousSMul (M := â„) (Î± := E) ğ•œ\n  obtain âŸ¨f, hâŸ© := _root_.geometric_hahn_banach_open_point hsâ‚ hsâ‚‚ disj\n  use extendToğ•œ'â‚— f\n  simp only [re_extendToğ•œ'â‚—]\n  exact fun a a_1 â†¦ h a a_1\n\n"}
{"name":"RCLike.geometric_hahn_banach_point_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\nt : Set E\nx : E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsOpen t\ndisj : Not (Membership.mem t x)\nâŠ¢ Exists fun f => âˆ€ (b : E), Membership.mem t b â†’ LT.lt (RCLike.re (f x)) (RCLike.re (f b))","decl":"theorem geometric_hahn_banach_point_open (htâ‚ : Convex â„ t) (htâ‚‚ : IsOpen t) (disj : x âˆ‰ t) :\n    âˆƒ f : E â†’L[ğ•œ] ğ•œ, âˆ€ b âˆˆ t, re (f x) < re (f b) :=\n  let âŸ¨f, hfâŸ© := geometric_hahn_banach_open_point htâ‚ htâ‚‚ disj\n  âŸ¨-f, by simpaâŸ©\n\n"}
{"name":"RCLike.geometric_hahn_banach_open_open","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ· : TopologicalSpace E\ninstâœâ¶ : AddCommGroup E\ninstâœâµ : Module Real E\ns t : Set E\ninstâœâ´ : RCLike ğ•œ\ninstâœÂ³ : Module ğ•œ E\ninstâœÂ² : IsScalarTower Real ğ•œ E\ninstâœÂ¹ : TopologicalAddGroup E\ninstâœ : ContinuousSMul ğ•œ E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsOpen s\nhtâ‚ : Convex Real t\nhtâ‚ƒ : IsOpen t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (RCLike.re (f a)) u) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt u (RCLike.re (f b)))","decl":"theorem geometric_hahn_banach_open_open (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsOpen s)\n    (htâ‚ : Convex â„ t) (htâ‚ƒ : IsOpen t) (disj : Disjoint s t) :\n    âˆƒ (f : E â†’L[ğ•œ] ğ•œ) (u : â„), (âˆ€ a âˆˆ s, re (f a) < u) âˆ§ âˆ€ b âˆˆ t, u < re (f b) := by\n  have := IsScalarTower.continuousSMul (M := â„) (Î± := E) ğ•œ\n  obtain âŸ¨f, u, hâŸ© := _root_.geometric_hahn_banach_open_open hsâ‚ hsâ‚‚ htâ‚ htâ‚ƒ disj\n  use extendToğ•œ'â‚— f\n  simp only [re_extendToğ•œ'â‚—]\n  exact Exists.intro u h\n\n"}
{"name":"RCLike.geometric_hahn_banach_compact_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module Real E\ns t : Set E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : IsScalarTower Real ğ•œ E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsCompact s\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsClosed t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => Exists fun v => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (RCLike.re (f a)) u) (And (LT.lt u v) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt v (RCLike.re (f b))))","decl":"theorem geometric_hahn_banach_compact_closed (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsCompact s)\n    (htâ‚ : Convex â„ t) (htâ‚‚ : IsClosed t) (disj : Disjoint s t) :\n    âˆƒ (f : E â†’L[ğ•œ] ğ•œ) (u v : â„), (âˆ€ a âˆˆ s, re (f a) < u) âˆ§ u < v âˆ§ âˆ€ b âˆˆ t, v < re (f b) := by\n  have := IsScalarTower.continuousSMul (M := â„) (Î± := E) ğ•œ\n  obtain âŸ¨g, u, v, h1âŸ© := _root_.geometric_hahn_banach_compact_closed hsâ‚ hsâ‚‚ htâ‚ htâ‚‚ disj\n  use extendToğ•œ'â‚— g\n  simp only [re_extendToğ•œ'â‚—, exists_and_left]\n  exact âŸ¨u, h1.1, v, h1.2âŸ©\n\n"}
{"name":"RCLike.geometric_hahn_banach_closed_compact","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module Real E\ns t : Set E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : IsScalarTower Real ğ•œ E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsCompact t\ndisj : Disjoint s t\nâŠ¢ Exists fun f => Exists fun u => Exists fun v => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (RCLike.re (f a)) u) (And (LT.lt u v) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt v (RCLike.re (f b))))","decl":"theorem geometric_hahn_banach_closed_compact (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsClosed s)\n    (htâ‚ : Convex â„ t) (htâ‚‚ : IsCompact t) (disj : Disjoint s t) :\n    âˆƒ (f : E â†’L[ğ•œ] ğ•œ) (u v : â„), (âˆ€ a âˆˆ s, re (f a) < u) âˆ§ u < v âˆ§ âˆ€ b âˆˆ t, v < re (f b) :=\n  let âŸ¨f, s, t, hs, st, htâŸ© := geometric_hahn_banach_compact_closed htâ‚ htâ‚‚ hsâ‚ hsâ‚‚ disj.symm\n  âŸ¨-f, -t, -s, by simpa using ht, by simpa using st, by simpa using hsâŸ©\n\n"}
{"name":"RCLike.geometric_hahn_banach_point_closed","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module Real E\nt : Set E\nx : E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : IsScalarTower Real ğ•œ E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : LocallyConvexSpace Real E\nhtâ‚ : Convex Real t\nhtâ‚‚ : IsClosed t\ndisj : Not (Membership.mem t x)\nâŠ¢ Exists fun f => Exists fun u => And (LT.lt (RCLike.re (f x)) u) (âˆ€ (b : E), Membership.mem t b â†’ LT.lt u (RCLike.re (f b)))","decl":"theorem geometric_hahn_banach_point_closed (htâ‚ : Convex â„ t) (htâ‚‚ : IsClosed t)\n    (disj : x âˆ‰ t) : âˆƒ (f : E â†’L[ğ•œ] ğ•œ) (u : â„), re (f x) < u âˆ§ âˆ€ b âˆˆ t, u < re (f b) :=\n  let âŸ¨f, _u, v, ha, hst, hbâŸ© :=\n    geometric_hahn_banach_compact_closed (convex_singleton x) isCompact_singleton htâ‚ htâ‚‚\n      (disjoint_singleton_left.2 disj)\n  âŸ¨f, v, hst.trans' <| ha x <| mem_singleton _, hbâŸ©\n\n"}
{"name":"RCLike.geometric_hahn_banach_closed_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module Real E\ns : Set E\nx : E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : IsScalarTower Real ğ•œ E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\ndisj : Not (Membership.mem s x)\nâŠ¢ Exists fun f => Exists fun u => And (âˆ€ (a : E), Membership.mem s a â†’ LT.lt (RCLike.re (f a)) u) (LT.lt u (RCLike.re (f x)))","decl":"theorem geometric_hahn_banach_closed_point (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsClosed s)\n    (disj : x âˆ‰ s) : âˆƒ (f : E â†’L[ğ•œ] ğ•œ) (u : â„), (âˆ€ a âˆˆ s, re (f a) < u) âˆ§ u < re (f x) :=\n  let âŸ¨f, s, _t, ha, hst, hbâŸ© :=\n    geometric_hahn_banach_closed_compact hsâ‚ hsâ‚‚ (convex_singleton x) isCompact_singleton\n      (disjoint_singleton_right.2 disj)\n  âŸ¨f, s, ha, hst.trans <| hb x <| mem_singleton _âŸ©\n\n"}
{"name":"RCLike.geometric_hahn_banach_point_point","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¹ : TopologicalSpace E\ninstâœâ¸ : AddCommGroup E\ninstâœâ· : Module Real E\nx y : E\ninstâœâ¶ : RCLike ğ•œ\ninstâœâµ : Module ğ•œ E\ninstâœâ´ : IsScalarTower Real ğ•œ E\ninstâœÂ³ : TopologicalAddGroup E\ninstâœÂ² : ContinuousSMul ğ•œ E\ninstâœÂ¹ : LocallyConvexSpace Real E\ninstâœ : T1Space E\nhxy : Ne x y\nâŠ¢ Exists fun f => LT.lt (RCLike.re (f x)) (RCLike.re (f y))","decl":"theorem geometric_hahn_banach_point_point [T1Space E] (hxy : x â‰  y) :\n    âˆƒ f : E â†’L[ğ•œ] ğ•œ, re (f x) < re (f y) := by\n  obtain âŸ¨f, s, t, hs, st, htâŸ© :=\n    geometric_hahn_banach_compact_closed (ğ•œ := ğ•œ) (convex_singleton x) isCompact_singleton\n      (convex_singleton y) isClosed_singleton (disjoint_singleton.2 hxy)\n  exact âŸ¨f, by linarith [hs x rfl, ht y rfl]âŸ©\n\n"}
{"name":"RCLike.iInter_halfSpaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module Real E\ns : Set E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : IsScalarTower Real ğ•œ E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\nâŠ¢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (RCLike.re (l x)) (RCLike.re (l y)))) s","decl":"theorem iInter_halfSpaces_eq (hsâ‚ : Convex â„ s) (hsâ‚‚ : IsClosed s) :\n    â‹‚ l : E â†’L[ğ•œ] ğ•œ, { x | âˆƒ y âˆˆ s, re (l x) â‰¤ re (l y) } = s := by\n  rw [Set.iInter_setOf]\n  refine Set.Subset.antisymm (fun x hx => ?_) fun x hx l => âŸ¨x, hx, le_rflâŸ©\n  by_contra h\n  obtain âŸ¨l, s, hlA, hlâŸ© := geometric_hahn_banach_closed_point (ğ•œ := ğ•œ) hsâ‚ hsâ‚‚ h\n  obtain âŸ¨y, hy, hxyâŸ© := hx l\n  exact ((hxy.trans_lt (hlA y hy)).trans hl).false\n"}
{"name":"RCLike.iInter_halfspaces_eq","module":"Mathlib.Analysis.NormedSpace.HahnBanach.Separation","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâ¸ : TopologicalSpace E\ninstâœâ· : AddCommGroup E\ninstâœâ¶ : Module Real E\ns : Set E\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : Module ğ•œ E\ninstâœÂ³ : IsScalarTower Real ğ•œ E\ninstâœÂ² : TopologicalAddGroup E\ninstâœÂ¹ : ContinuousSMul ğ•œ E\ninstâœ : LocallyConvexSpace Real E\nhsâ‚ : Convex Real s\nhsâ‚‚ : IsClosed s\nâŠ¢ Eq (Set.iInter fun l => setOf fun x => Exists fun y => And (Membership.mem s y) (LE.le (RCLike.re (l x)) (RCLike.re (l y)))) s","decl":"@[deprecated (since := \"2024-11-12\")] alias iInter_halfspaces_eq := iInter_halfSpaces_eq\n\n"}
