{"name":"AffineBasis.toMatrix_apply","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝³ : AddCommGroup V\ninst✝² : AddTorsor V P\ninst✝¹ : Ring k\ninst✝ : Module k V\nb : AffineBasis ι k P\nι' : Type u_1\nq : ι' → P\ni : ι'\nj : ι\n⊢ Eq (b.toMatrix q i j) ((b.coord j) (q i))","decl":"@[simp]\ntheorem toMatrix_apply {ι' : Type*} (q : ι' → P) (i : ι') (j : ι) :\n    b.toMatrix q i j = b.coord j (q i) := rfl\n\n"}
{"name":"AffineBasis.toMatrix_self","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : DecidableEq ι\n⊢ Eq (b.toMatrix ⇑b) 1","decl":"@[simp]\ntheorem toMatrix_self [DecidableEq ι] : b.toMatrix b = (1 : Matrix ι ι k) := by\n  ext i j\n  rw [toMatrix_apply, coord_apply, Matrix.one_eq_pi_single, Pi.single_apply]\n\n"}
{"name":"AffineBasis.toMatrix_row_sum_one","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\nι' : Type u_1\ninst✝ : Fintype ι\nq : ι' → P\ni : ι'\n⊢ Eq (Finset.univ.sum fun j => b.toMatrix q i j) 1","decl":"theorem toMatrix_row_sum_one [Fintype ι] (q : ι' → P) (i : ι') : ∑ j, b.toMatrix q i j = 1 := by\n  simp\n\n"}
{"name":"AffineBasis.affineIndependent_of_toMatrix_right_inv","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : AddTorsor V P\ninst✝⁴ : Ring k\ninst✝³ : Module k V\nb : AffineBasis ι k P\nι' : Type u_1\ninst✝² : Fintype ι\ninst✝¹ : Finite ι'\ninst✝ : DecidableEq ι'\np : ι' → P\nA : Matrix ι ι' k\nhA : Eq (HMul.hMul (b.toMatrix p) A) 1\n⊢ AffineIndependent k p","decl":"/-- Given a family of points `p : ι' → P` and an affine basis `b`, if the matrix whose rows are the\ncoordinates of `p` with respect `b` has a right inverse, then `p` is affine independent. -/\ntheorem affineIndependent_of_toMatrix_right_inv [Fintype ι] [Finite ι'] [DecidableEq ι']\n    (p : ι' → P) {A : Matrix ι ι' k} (hA : b.toMatrix p * A = 1) : AffineIndependent k p := by\n  cases nonempty_fintype ι'\n  rw [affineIndependent_iff_eq_of_fintype_affineCombination_eq]\n  intro w₁ w₂ hw₁ hw₂ hweq\n  have hweq' : w₁ ᵥ* b.toMatrix p = w₂ ᵥ* b.toMatrix p := by\n    ext j\n    change (∑ i, w₁ i • b.coord j (p i)) = ∑ i, w₂ i • b.coord j (p i)\n    -- Porting note: Added `u` because `∘` was causing trouble\n    have u : (fun i => b.coord j (p i)) = b.coord j ∘ p := by simp only [Function.comp_def]\n    rw [← Finset.univ.affineCombination_eq_linear_combination _ _ hw₁,\n      ← Finset.univ.affineCombination_eq_linear_combination _ _ hw₂, u,\n      ← Finset.univ.map_affineCombination p w₁ hw₁, ← Finset.univ.map_affineCombination p w₂ hw₂,\n      hweq]\n  replace hweq' := congr_arg (fun w => w ᵥ* A) hweq'\n  simpa only [Matrix.vecMul_vecMul, hA, Matrix.vecMul_one] using hweq'\n\n"}
{"name":"AffineBasis.affineSpan_eq_top_of_toMatrix_left_inv","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁷ : AddCommGroup V\ninst✝⁶ : AddTorsor V P\ninst✝⁵ : Ring k\ninst✝⁴ : Module k V\nb : AffineBasis ι k P\nι' : Type u_1\ninst✝³ : Finite ι\ninst✝² : Fintype ι'\ninst✝¹ : DecidableEq ι\ninst✝ : Nontrivial k\np : ι' → P\nA : Matrix ι ι' k\nhA : Eq (HMul.hMul A (b.toMatrix p)) 1\n⊢ Eq (affineSpan k (Set.range p)) Top.top","decl":"/-- Given a family of points `p : ι' → P` and an affine basis `b`, if the matrix whose rows are the\ncoordinates of `p` with respect `b` has a left inverse, then `p` spans the entire space. -/\ntheorem affineSpan_eq_top_of_toMatrix_left_inv [Finite ι] [Fintype ι'] [DecidableEq ι]\n    [Nontrivial k] (p : ι' → P) {A : Matrix ι ι' k} (hA : A * b.toMatrix p = 1) :\n    affineSpan k (range p) = ⊤ := by\n  cases nonempty_fintype ι\n  suffices ∀ i, b i ∈ affineSpan k (range p) by\n    rw [eq_top_iff, ← b.tot, affineSpan_le]\n    rintro q ⟨i, rfl⟩\n    exact this i\n  intro i\n  have hAi : ∑ j, A i j = 1 := by\n    calc\n      ∑ j, A i j = ∑ j, A i j * ∑ l, b.toMatrix p j l := by simp\n      _ = ∑ j, ∑ l, A i j * b.toMatrix p j l := by simp_rw [Finset.mul_sum]\n      _ = ∑ l, ∑ j, A i j * b.toMatrix p j l := by rw [Finset.sum_comm]\n      _ = ∑ l, (A * b.toMatrix p) i l := rfl\n      _ = 1 := by simp [hA, Matrix.one_apply, Finset.filter_eq]\n  have hbi : b i = Finset.univ.affineCombination k p (A i) := by\n    apply b.ext_elem\n    intro j\n    rw [b.coord_apply, Finset.univ.map_affineCombination _ _ hAi,\n      Finset.univ.affineCombination_eq_linear_combination _ _ hAi]\n    change _ = (A * b.toMatrix p) i j\n    simp_rw [hA, Matrix.one_apply, @eq_comm _ i j]\n  rw [hbi]\n  exact affineCombination_mem_affineSpan hAi p\n\n"}
{"name":"AffineBasis.toMatrix_vecMul_coords","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁴ : AddCommGroup V\ninst✝³ : AddTorsor V P\ninst✝² : Ring k\ninst✝¹ : Module k V\nb : AffineBasis ι k P\ninst✝ : Fintype ι\nb₂ : AffineBasis ι k P\nx : P\n⊢ Eq (Matrix.vecMul (b₂.coords x) (b.toMatrix ⇑b₂)) (b.coords x)","decl":"/-- A change of basis formula for barycentric coordinates.\n\nSee also `AffineBasis.toMatrix_inv_vecMul_toMatrix`. -/\n@[simp]\ntheorem toMatrix_vecMul_coords (x : P) : b₂.coords x ᵥ* b.toMatrix b₂ = b.coords x := by\n  ext j\n  change _ = b.coord j x\n  conv_rhs => rw [← b₂.affineCombination_coord_eq_self x]\n  rw [Finset.map_affineCombination _ _ _ (b₂.sum_coord_apply_eq_one x)]\n  simp [Matrix.vecMul, dotProduct, toMatrix_apply, coords]\n\n"}
{"name":"AffineBasis.toMatrix_mul_toMatrix","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : AddTorsor V P\ninst✝³ : Ring k\ninst✝² : Module k V\nb : AffineBasis ι k P\ninst✝¹ : Fintype ι\nb₂ : AffineBasis ι k P\ninst✝ : DecidableEq ι\n⊢ Eq (HMul.hMul (b.toMatrix ⇑b₂) (b₂.toMatrix ⇑b)) 1","decl":"theorem toMatrix_mul_toMatrix : b.toMatrix b₂ * b₂.toMatrix b = 1 := by\n  ext l m\n  change (b.coords (b₂ l) ᵥ* b₂.toMatrix b) m = _\n  rw [toMatrix_vecMul_coords, coords_apply, ← toMatrix_apply, toMatrix_self]\n\n"}
{"name":"AffineBasis.isUnit_toMatrix","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : AddTorsor V P\ninst✝³ : Ring k\ninst✝² : Module k V\nb : AffineBasis ι k P\ninst✝¹ : Fintype ι\nb₂ : AffineBasis ι k P\ninst✝ : DecidableEq ι\n⊢ IsUnit (b.toMatrix ⇑b₂)","decl":"theorem isUnit_toMatrix : IsUnit (b.toMatrix b₂) :=\n  ⟨{  val := b.toMatrix b₂\n      inv := b₂.toMatrix b\n      val_inv := b.toMatrix_mul_toMatrix b₂\n      inv_val := b₂.toMatrix_mul_toMatrix b }, rfl⟩\n\n"}
{"name":"AffineBasis.isUnit_toMatrix_iff","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁶ : AddCommGroup V\ninst✝⁵ : AddTorsor V P\ninst✝⁴ : Ring k\ninst✝³ : Module k V\nb : AffineBasis ι k P\ninst✝² : Fintype ι\ninst✝¹ : DecidableEq ι\ninst✝ : Nontrivial k\np : ι → P\n⊢ Iff (IsUnit (b.toMatrix p)) (And (AffineIndependent k p) (Eq (affineSpan k (Set.range p)) Top.top))","decl":"theorem isUnit_toMatrix_iff [Nontrivial k] (p : ι → P) :\n    IsUnit (b.toMatrix p) ↔ AffineIndependent k p ∧ affineSpan k (range p) = ⊤ := by\n  constructor\n  · rintro ⟨⟨B, A, hA, hA'⟩, rfl : B = b.toMatrix p⟩\n    exact ⟨b.affineIndependent_of_toMatrix_right_inv p hA,\n      b.affineSpan_eq_top_of_toMatrix_left_inv p hA'⟩\n  · rintro ⟨h_tot, h_ind⟩\n    let b' : AffineBasis ι k P := ⟨p, h_tot, h_ind⟩\n    change IsUnit (b.toMatrix b')\n    exact b.isUnit_toMatrix b'\n\n"}
{"name":"AffineBasis.toMatrix_inv_vecMul_toMatrix","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : AddTorsor V P\ninst✝³ : CommRing k\ninst✝² : Module k V\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb b₂ : AffineBasis ι k P\nx : P\n⊢ Eq (Matrix.vecMul (b.coords x) (Inv.inv (b.toMatrix ⇑b₂))) (b₂.coords x)","decl":"/-- A change of basis formula for barycentric coordinates.\n\nSee also `AffineBasis.toMatrix_vecMul_coords`. -/\n@[simp]\ntheorem toMatrix_inv_vecMul_toMatrix (x : P) :\n    b.coords x ᵥ* (b.toMatrix b₂)⁻¹ = b₂.coords x := by\n  have hu := b.isUnit_toMatrix b₂\n  rw [Matrix.isUnit_iff_isUnit_det] at hu\n  rw [← b.toMatrix_vecMul_coords b₂, Matrix.vecMul_vecMul, Matrix.mul_nonsing_inv _ hu,\n    Matrix.vecMul_one]\n\n"}
{"name":"AffineBasis.det_smul_coords_eq_cramer_coords","module":"Mathlib.LinearAlgebra.AffineSpace.Matrix","initialProofState":"ι : Type u₁\nk : Type u₂\nV : Type u₃\nP : Type u₄\ninst✝⁵ : AddCommGroup V\ninst✝⁴ : AddTorsor V P\ninst✝³ : CommRing k\ninst✝² : Module k V\ninst✝¹ : DecidableEq ι\ninst✝ : Fintype ι\nb b₂ : AffineBasis ι k P\nx : P\n⊢ Eq (HSMul.hSMul (b.toMatrix ⇑b₂).det (b₂.coords x)) ((b.toMatrix ⇑b₂).transpose.cramer (b.coords x))","decl":"/-- If we fix a background affine basis `b`, then for any other basis `b₂`, we can characterise\nthe barycentric coordinates provided by `b₂` in terms of determinants relative to `b`. -/\ntheorem det_smul_coords_eq_cramer_coords (x : P) :\n    (b.toMatrix b₂).det • b₂.coords x = (b.toMatrix b₂)ᵀ.cramer (b.coords x) := by\n  have hu := b.isUnit_toMatrix b₂\n  rw [Matrix.isUnit_iff_isUnit_det] at hu\n  rw [← b.toMatrix_inv_vecMul_toMatrix, Matrix.det_smul_inv_vecMul_eq_cramer_transpose _ _ hu]\n\n"}
