{"name":"exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace Real F\ninstâœ : SecondCountableTopology F\nf : E â†’ F\ns : Set E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nr : ContinuousLinearMap (RingHom.id Real) E F â†’ NNReal\nrpos : âˆ€ (A : ContinuousLinearMap (RingHom.id Real) E F), Ne (r A) 0\nâŠ¢ Exists fun t => Exists fun A => And (âˆ€ (n : Nat), IsClosed (t n)) (And (HasSubset.Subset s (Set.iUnion fun n => t n)) (And (âˆ€ (n : Nat), ApproximatesLinearOn f (A n) (Inter.inter s (t n)) (r (A n))) (s.Nonempty â†’ âˆ€ (n : Nat), Exists fun y => And (Membership.mem s y) (Eq (A n) (f' y)))))","decl":"/-- Assume that a function `f` has a derivative at every point of a set `s`. Then one may cover `s`\nwith countably many closed sets `t n` on which `f` is well approximated by linear maps `A n`. -/\ntheorem exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]\n    (f : E â†’ F) (s : Set E) (f' : E â†’ E â†’L[â„] F) (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x)\n    (r : (E â†’L[â„] F) â†’ â„â‰¥0) (rpos : âˆ€ A, r A â‰  0) :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] F),\n      (âˆ€ n, IsClosed (t n)) âˆ§\n        (s âŠ† â‹ƒ n, t n) âˆ§\n          (âˆ€ n, ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§\n            (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) := by\n  /- Choose countably many linear maps `f' z`. For every such map, if `f` has a derivative at `x`\n    close enough to `f' z`, then `f y - f x` is well approximated by `f' z (y - x)` for `y` close\n    enough to `x`, say on a ball of radius `r` (or even `u n` for some `n`, where `u` is a fixed\n    sequence tending to `0`).\n    Let `M n z` be the points where this happens. Then this set is relatively closed inside `s`,\n    and moreover in every closed ball of radius `u n / 3` inside it the map is well approximated by\n    `f' z`. Using countably many closed balls to split `M n z` into small diameter subsets\n    `K n z p`, one obtains the desired sets `t q` after reindexing.\n    -/\n  -- exclude the trivial case where `s` is empty\n  rcases eq_empty_or_nonempty s with (rfl | hs)\n  Â· refine âŸ¨fun _ => âˆ…, fun _ => 0, ?_, ?_, ?_, ?_âŸ© <;> simp\n  -- we will use countably many linear maps. Select these from all the derivatives since the\n  -- space of linear maps is second-countable\n  obtain âŸ¨T, T_count, hTâŸ© :\n    âˆƒ T : Set s,\n      T.Countable âˆ§ â‹ƒ x âˆˆ T, ball (f' (x : E)) (r (f' x)) = â‹ƒ x : s, ball (f' x) (r (f' x)) :=\n    TopologicalSpace.isOpen_iUnion_countable _ fun x => isOpen_ball\n  -- fix a sequence `u` of positive reals tending to zero.\n  obtain âŸ¨u, _, u_pos, u_limâŸ© :\n    âˆƒ u : â„• â†’ â„, StrictAnti u âˆ§ (âˆ€ n : â„•, 0 < u n) âˆ§ Tendsto u atTop (ğ“ 0) :=\n    exists_seq_strictAnti_tendsto (0 : â„)\n  -- `M n z` is the set of points `x` such that `f y - f x` is close to `f' z (y - x)` for `y`\n  -- in the ball of radius `u n` around `x`.\n  let M : â„• â†’ T â†’ Set E := fun n z =>\n    {x | x âˆˆ s âˆ§ âˆ€ y âˆˆ s âˆ© ball x (u n), â€–f y - f x - f' z (y - x)â€– â‰¤ r (f' z) * â€–y - xâ€–}\n  -- As `f` is differentiable everywhere on `s`, the sets `M n z` cover `s` by design.\n  have s_subset : âˆ€ x âˆˆ s, âˆƒ (n : â„•) (z : T), x âˆˆ M n z := by\n    intro x xs\n    obtain âŸ¨z, zT, hzâŸ© : âˆƒ z âˆˆ T, f' x âˆˆ ball (f' (z : E)) (r (f' z)) := by\n      have : f' x âˆˆ â‹ƒ z âˆˆ T, ball (f' (z : E)) (r (f' z)) := by\n        rw [hT]\n        refine mem_iUnion.2 âŸ¨âŸ¨x, xsâŸ©, ?_âŸ©\n        simpa only [mem_ball, Subtype.coe_mk, dist_self] using (rpos (f' x)).bot_lt\n      rwa [mem_iUnionâ‚‚, bex_def] at this\n    obtain âŸ¨Îµ, Îµpos, hÎµâŸ© : âˆƒ Îµ : â„, 0 < Îµ âˆ§ â€–f' x - f' zâ€– + Îµ â‰¤ r (f' z) := by\n      refine âŸ¨r (f' z) - â€–f' x - f' zâ€–, ?_, le_of_eq (by abel)âŸ©\n      simpa only [sub_pos] using mem_ball_iff_norm.mp hz\n    obtain âŸ¨Î´, Î´pos, hÎ´âŸ© :\n      âˆƒ (Î´ : â„), 0 < Î´ âˆ§ ball x Î´ âˆ© s âŠ† {y | â€–f y - f x - (f' x) (y - x)â€– â‰¤ Îµ * â€–y - xâ€–} :=\n      Metric.mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Îµpos)\n    obtain âŸ¨n, hnâŸ© : âˆƒ n, u n < Î´ := ((tendsto_order.1 u_lim).2 _ Î´pos).exists\n    refine âŸ¨n, âŸ¨z, zTâŸ©, âŸ¨xs, ?_âŸ©âŸ©\n    intro y hy\n    calc\n      â€–f y - f x - (f' z) (y - x)â€– = â€–f y - f x - (f' x) (y - x) + (f' x - f' z) (y - x)â€– := by\n        congr 1\n        simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]\n        abel\n      _ â‰¤ â€–f y - f x - (f' x) (y - x)â€– + â€–(f' x - f' z) (y - x)â€– := norm_add_le _ _\n      _ â‰¤ Îµ * â€–y - xâ€– + â€–f' x - f' zâ€– * â€–y - xâ€– := by\n        refine add_le_add (hÎ´ ?_) (ContinuousLinearMap.le_opNorm _ _)\n        rw [inter_comm]\n        exact inter_subset_inter_right _ (ball_subset_ball hn.le) hy\n      _ â‰¤ r (f' z) * â€–y - xâ€– := by\n        rw [â† add_mul, add_comm]\n        gcongr\n  -- the sets `M n z` are relatively closed in `s`, as all the conditions defining it are clearly\n  -- closed\n  have closure_M_subset : âˆ€ n z, s âˆ© closure (M n z) âŠ† M n z := by\n    rintro n z x âŸ¨xs, hxâŸ©\n    refine âŸ¨xs, fun y hy => ?_âŸ©\n    obtain âŸ¨a, aM, a_limâŸ© : âˆƒ a : â„• â†’ E, (âˆ€ k, a k âˆˆ M n z) âˆ§ Tendsto a atTop (ğ“ x) :=\n      mem_closure_iff_seq_limit.1 hx\n    have L1 :\n      Tendsto (fun k : â„• => â€–f y - f (a k) - (f' z) (y - a k)â€–) atTop\n        (ğ“ â€–f y - f x - (f' z) (y - x)â€–) := by\n      apply Tendsto.norm\n      have L : Tendsto (fun k => f (a k)) atTop (ğ“ (f x)) := by\n        apply (hf' x xs).continuousWithinAt.tendsto.comp\n        apply tendsto_nhdsWithin_of_tendsto_nhds_of_eventually_within _ a_lim\n        exact Eventually.of_forall fun k => (aM k).1\n      apply Tendsto.sub (tendsto_const_nhds.sub L)\n      exact ((f' z).continuous.tendsto _).comp (tendsto_const_nhds.sub a_lim)\n    have L2 : Tendsto (fun k : â„• => (r (f' z) : â„) * â€–y - a kâ€–) atTop (ğ“ (r (f' z) * â€–y - xâ€–)) :=\n      (tendsto_const_nhds.sub a_lim).norm.const_mul _\n    have I : âˆ€á¶  k in atTop, â€–f y - f (a k) - (f' z) (y - a k)â€– â‰¤ r (f' z) * â€–y - a kâ€– := by\n      have L : Tendsto (fun k => dist y (a k)) atTop (ğ“ (dist y x)) :=\n        tendsto_const_nhds.dist a_lim\n      filter_upwards [(tendsto_order.1 L).2 _ hy.2]\n      intro k hk\n      exact (aM k).2 y âŸ¨hy.1, hkâŸ©\n    exact le_of_tendsto_of_tendsto L1 L2 I\n  -- choose a dense sequence `d p`\n  rcases TopologicalSpace.exists_dense_seq E with âŸ¨d, hdâŸ©\n  -- split `M n z` into subsets `K n z p` of small diameters by intersecting with the ball\n  -- `closedBall (d p) (u n / 3)`.\n  let K : â„• â†’ T â†’ â„• â†’ Set E := fun n z p => closure (M n z) âˆ© closedBall (d p) (u n / 3)\n  -- on the sets `K n z p`, the map `f` is well approximated by `f' z` by design.\n  have K_approx : âˆ€ (n) (z : T) (p), ApproximatesLinearOn f (f' z) (s âˆ© K n z p) (r (f' z)) := by\n    intro n z p x hx y hy\n    have yM : y âˆˆ M n z := closure_M_subset _ _ âŸ¨hy.1, hy.2.1âŸ©\n    refine yM.2 _ âŸ¨hx.1, ?_âŸ©\n    calc\n      dist x y â‰¤ dist x (d p) + dist y (d p) := dist_triangle_right _ _ _\n      _ â‰¤ u n / 3 + u n / 3 := add_le_add hx.2.2 hy.2.2\n      _ < u n := by linarith [u_pos n]\n  -- the sets `K n z p` are also closed, again by design.\n  have K_closed : âˆ€ (n) (z : T) (p), IsClosed (K n z p) := fun n z p =>\n    isClosed_closure.inter isClosed_ball\n  -- reindex the sets `K n z p`, to let them only depend on an integer parameter `q`.\n  obtain âŸ¨F, hFâŸ© : âˆƒ F : â„• â†’ â„• Ã— T Ã— â„•, Function.Surjective F := by\n    haveI : Encodable T := T_count.toEncodable\n    have : Nonempty T := by\n      rcases hs with âŸ¨x, xsâŸ©\n      rcases s_subset x xs with âŸ¨n, z, _âŸ©\n      exact âŸ¨zâŸ©\n    inhabit â†¥T\n    exact âŸ¨_, Encodable.surjective_decode_iget (â„• Ã— T Ã— â„•)âŸ©\n  -- these sets `t q = K n z p` will do\n  refine\n    âŸ¨fun q => K (F q).1 (F q).2.1 (F q).2.2, fun q => f' (F q).2.1, fun n => K_closed _ _ _,\n      fun x xs => ?_, fun q => K_approx _ _ _, fun _ q => âŸ¨(F q).2.1, (F q).2.1.1.2, rflâŸ©âŸ©\n  -- the only fact that needs further checking is that they cover `s`.\n  -- we already know that any point `x âˆˆ s` belongs to a set `M n z`.\n  obtain âŸ¨n, z, hnzâŸ© : âˆƒ (n : â„•) (z : T), x âˆˆ M n z := s_subset x xs\n  -- by density, it also belongs to a ball `closedBall (d p) (u n / 3)`.\n  obtain âŸ¨p, hpâŸ© : âˆƒ p : â„•, x âˆˆ closedBall (d p) (u n / 3) := by\n    have : Set.Nonempty (ball x (u n / 3)) := by simp only [nonempty_ball]; linarith [u_pos n]\n    obtain âŸ¨p, hpâŸ© : âˆƒ p : â„•, d p âˆˆ ball x (u n / 3) := hd.exists_mem_open isOpen_ball this\n    exact âŸ¨p, (mem_ball'.1 hp).leâŸ©\n  -- choose `q` for which `t q = K n z p`.\n  obtain âŸ¨q, hqâŸ© : âˆƒ q, F q = (n, z, p) := hF _\n  -- then `x` belongs to `t q`.\n  apply mem_iUnion.2 âŸ¨q, _âŸ©\n  simp (config := { zeta := false }) only [K, hq, mem_inter_iff, hp, and_true]\n  exact subset_closure hnz\n\n"}
{"name":"exists_partition_approximatesLinearOn_of_hasFDerivWithinAt","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\ninstâœ : SecondCountableTopology F\nf : E â†’ F\ns : Set E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E F\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nr : ContinuousLinearMap (RingHom.id Real) E F â†’ NNReal\nrpos : âˆ€ (A : ContinuousLinearMap (RingHom.id Real) E F), Ne (r A) 0\nâŠ¢ Exists fun t => Exists fun A => And (Pairwise (Function.onFun Disjoint t)) (And (âˆ€ (n : Nat), MeasurableSet (t n)) (And (HasSubset.Subset s (Set.iUnion fun n => t n)) (And (âˆ€ (n : Nat), ApproximatesLinearOn f (A n) (Inter.inter s (t n)) (r (A n))) (s.Nonempty â†’ âˆ€ (n : Nat), Exists fun y => And (Membership.mem s y) (Eq (A n) (f' y))))))","decl":"/-- Assume that a function `f` has a derivative at every point of a set `s`. Then one may\npartition `s` into countably many disjoint relatively measurable sets (i.e., intersections\nof `s` with measurable sets `t n`) on which `f` is well approximated by linear maps `A n`. -/\ntheorem exists_partition_approximatesLinearOn_of_hasFDerivWithinAt [SecondCountableTopology F]\n    (f : E â†’ F) (s : Set E) (f' : E â†’ E â†’L[â„] F) (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x)\n    (r : (E â†’L[â„] F) â†’ â„â‰¥0) (rpos : âˆ€ A, r A â‰  0) :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] F),\n      Pairwise (Disjoint on t) âˆ§\n        (âˆ€ n, MeasurableSet (t n)) âˆ§\n          (s âŠ† â‹ƒ n, t n) âˆ§\n            (âˆ€ n, ApproximatesLinearOn f (A n) (s âˆ© t n) (r (A n))) âˆ§\n              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) := by\n  rcases exists_closed_cover_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' r rpos with\n    âŸ¨t, A, t_closed, st, t_approx, htâŸ©\n  refine\n    âŸ¨disjointed t, A, disjoint_disjointed _,\n      MeasurableSet.disjointed fun n => (t_closed n).measurableSet, ?_, ?_, htâŸ©\n  Â· rw [iUnion_disjointed]; exact st\n  Â· intro n; exact (t_approx n).mono_set (inter_subset_inter_right _ (disjointed_subset _ _))\n\n"}
{"name":"MeasureTheory.addHaar_image_le_mul_of_det_lt","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nA : ContinuousLinearMap (RingHom.id Real) E E\nm : NNReal\nhm : LT.lt (ENNReal.ofReal (abs A.det)) â†‘m\nâŠ¢ Filter.Eventually (fun Î´ => âˆ€ (s : Set E) (f : E â†’ E), ApproximatesLinearOn f A s Î´ â†’ LE.le (Î¼ (Set.image f s)) (HMul.hMul (â†‘m) (Î¼ s))) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- Let `f` be a function which is sufficiently close (in the Lipschitz sense) to a given linear\nmap `A`. Then it expands the volume of any set by at most `m` for any `m > det A`. -/\ntheorem addHaar_image_le_mul_of_det_lt (A : E â†’L[â„] E) {m : â„â‰¥0}\n    (hm : ENNReal.ofReal |A.det| < m) :\n    âˆ€á¶  Î´ in ğ“[>] (0 : â„â‰¥0),\n      âˆ€ (s : Set E) (f : E â†’ E), ApproximatesLinearOn f A s Î´ â†’ Î¼ (f '' s) â‰¤ m * Î¼ s := by\n  apply nhdsWithin_le_nhds\n  let d := ENNReal.ofReal |A.det|\n  -- construct a small neighborhood of `A '' (closedBall 0 1)` with measure comparable to\n  -- the determinant of `A`.\n  obtain âŸ¨Îµ, hÎµ, ÎµposâŸ© :\n    âˆƒ Îµ : â„, Î¼ (closedBall 0 Îµ + A '' closedBall 0 1) < m * Î¼ (closedBall 0 1) âˆ§ 0 < Îµ := by\n    have HC : IsCompact (A '' closedBall 0 1) :=\n      (ProperSpace.isCompact_closedBall _ _).image A.continuous\n    have L0 :\n      Tendsto (fun Îµ => Î¼ (cthickening Îµ (A '' closedBall 0 1))) (ğ“[>] 0)\n        (ğ“ (Î¼ (A '' closedBall 0 1))) := by\n      apply Tendsto.mono_left _ nhdsWithin_le_nhds\n      exact tendsto_measure_cthickening_of_isCompact HC\n    have L1 :\n      Tendsto (fun Îµ => Î¼ (closedBall 0 Îµ + A '' closedBall 0 1)) (ğ“[>] 0)\n        (ğ“ (Î¼ (A '' closedBall 0 1))) := by\n      apply L0.congr' _\n      filter_upwards [self_mem_nhdsWithin] with r hr\n      rw [â† HC.add_closedBall_zero (le_of_lt hr), add_comm]\n    have L2 :\n      Tendsto (fun Îµ => Î¼ (closedBall 0 Îµ + A '' closedBall 0 1)) (ğ“[>] 0)\n        (ğ“ (d * Î¼ (closedBall 0 1))) := by\n      convert L1\n      exact (addHaar_image_continuousLinearMap _ _ _).symm\n    have I : d * Î¼ (closedBall 0 1) < m * Î¼ (closedBall 0 1) :=\n      (ENNReal.mul_lt_mul_right (measure_closedBall_pos Î¼ _ zero_lt_one).ne'\n            measure_closedBall_lt_top.ne).2\n        hm\n    have H :\n      âˆ€á¶  b : â„ in ğ“[>] 0, Î¼ (closedBall 0 b + A '' closedBall 0 1) < m * Î¼ (closedBall 0 1) :=\n      (tendsto_order.1 L2).2 _ I\n    exact (H.and self_mem_nhdsWithin).exists\n  have : Iio (âŸ¨Îµ, Îµpos.leâŸ© : â„â‰¥0) âˆˆ ğ“ (0 : â„â‰¥0) := by apply Iio_mem_nhds; exact Îµpos\n  filter_upwards [this]\n  -- fix a function `f` which is close enough to `A`.\n  intro Î´ hÎ´ s f hf\n  simp only [mem_Iio, â† NNReal.coe_lt_coe, NNReal.coe_mk] at hÎ´\n  -- This function expands the volume of any ball by at most `m`\n  have I : âˆ€ x r, x âˆˆ s â†’ 0 â‰¤ r â†’ Î¼ (f '' (s âˆ© closedBall x r)) â‰¤ m * Î¼ (closedBall x r) := by\n    intro x r xs r0\n    have K : f '' (s âˆ© closedBall x r) âŠ† A '' closedBall 0 r + closedBall (f x) (Îµ * r) := by\n      rintro y âŸ¨z, âŸ¨zs, zrâŸ©, rflâŸ©\n      rw [mem_closedBall_iff_norm] at zr\n      apply Set.mem_add.2 âŸ¨A (z - x), _, f z - f x - A (z - x) + f x, _, _âŸ©\n      Â· apply mem_image_of_mem\n        simpa only [dist_eq_norm, mem_closedBall, mem_closedBall_zero_iff, sub_zero] using zr\n      Â· rw [mem_closedBall_iff_norm, add_sub_cancel_right]\n        calc\n          â€–f z - f x - A (z - x)â€– â‰¤ Î´ * â€–z - xâ€– := hf _ zs _ xs\n          _ â‰¤ Îµ * r := by gcongr\n      Â· simp only [map_sub, Pi.sub_apply]\n        abel\n    have :\n      A '' closedBall 0 r + closedBall (f x) (Îµ * r) =\n        {f x} + r â€¢ (A '' closedBall 0 1 + closedBall 0 Îµ) := by\n      rw [smul_add, â† add_assoc, add_comm {f x}, add_assoc, smul_closedBall _ _ Îµpos.le, smul_zero,\n        singleton_add_closedBall_zero, â† image_smul_set â„ E E A,\n        _root_.smul_closedBall _ _ zero_le_one, smul_zero, Real.norm_eq_abs, abs_of_nonneg r0,\n        mul_one, mul_comm]\n    rw [this] at K\n    calc\n      Î¼ (f '' (s âˆ© closedBall x r)) â‰¤ Î¼ ({f x} + r â€¢ (A '' closedBall 0 1 + closedBall 0 Îµ)) :=\n        measure_mono K\n      _ = ENNReal.ofReal (r ^ finrank â„ E) * Î¼ (A '' closedBall 0 1 + closedBall 0 Îµ) := by\n        simp only [abs_of_nonneg r0, addHaar_smul, image_add_left, abs_pow, singleton_add,\n          measure_preimage_add]\n      _ â‰¤ ENNReal.ofReal (r ^ finrank â„ E) * (m * Î¼ (closedBall 0 1)) := by\n        rw [add_comm]; gcongr\n      _ = m * Î¼ (closedBall x r) := by simp only [addHaar_closedBall' Î¼ _ r0]; ring\n  -- covering `s` by closed balls with total measure very close to `Î¼ s`, one deduces that the\n  -- measure of `f '' s` is at most `m * (Î¼ s + a)` for any positive `a`.\n  have J : âˆ€á¶  a in ğ“[>] (0 : â„â‰¥0âˆ), Î¼ (f '' s) â‰¤ m * (Î¼ s + a) := by\n    filter_upwards [self_mem_nhdsWithin] with a ha\n    rw [mem_Ioi] at ha\n    obtain âŸ¨t, r, t_count, ts, rpos, st, Î¼tâŸ© :\n      âˆƒ (t : Set E) (r : E â†’ â„),\n        t.Countable âˆ§\n          t âŠ† s âˆ§\n            (âˆ€ x : E, x âˆˆ t â†’ 0 < r x) âˆ§\n              (s âŠ† â‹ƒ x âˆˆ t, closedBall x (r x)) âˆ§\n                (âˆ‘' x : â†¥t, Î¼ (closedBall (â†‘x) (r â†‘x))) â‰¤ Î¼ s + a :=\n      Besicovitch.exists_closedBall_covering_tsum_measure_le Î¼ ha.ne' (fun _ => Ioi 0) s\n        fun x _ Î´ Î´pos => âŸ¨Î´ / 2, by simp [half_pos Î´pos, Î´pos]âŸ©\n    haveI : Encodable t := t_count.toEncodable\n    calc\n      Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ x : t, f '' (s âˆ© closedBall x (r x))) := by\n        rw [biUnion_eq_iUnion] at st\n        apply measure_mono\n        rw [â† image_iUnion, â† inter_iUnion]\n        exact image_subset _ (subset_inter (Subset.refl _) st)\n      _ â‰¤ âˆ‘' x : t, Î¼ (f '' (s âˆ© closedBall x (r x))) := measure_iUnion_le _\n      _ â‰¤ âˆ‘' x : t, m * Î¼ (closedBall x (r x)) :=\n        (ENNReal.tsum_le_tsum fun x => I x (r x) (ts x.2) (rpos x x.2).le)\n      _ â‰¤ m * (Î¼ s + a) := by rw [ENNReal.tsum_mul_left]; gcongr\n  -- taking the limit in `a`, one obtains the conclusion\n  have L : Tendsto (fun a => (m : â„â‰¥0âˆ) * (Î¼ s + a)) (ğ“[>] 0) (ğ“ (m * (Î¼ s + 0))) := by\n    apply Tendsto.mono_left _ nhdsWithin_le_nhds\n    apply ENNReal.Tendsto.const_mul (tendsto_const_nhds.add tendsto_id)\n    simp only [ENNReal.coe_ne_top, Ne, or_true, not_false_iff]\n  rw [add_zero] at L\n  exact ge_of_tendsto L J\n\n"}
{"name":"MeasureTheory.mul_le_addHaar_image_of_lt_det","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nA : ContinuousLinearMap (RingHom.id Real) E E\nm : NNReal\nhm : LT.lt (â†‘m) (ENNReal.ofReal (abs A.det))\nâŠ¢ Filter.Eventually (fun Î´ => âˆ€ (s : Set E) (f : E â†’ E), ApproximatesLinearOn f A s Î´ â†’ LE.le (HMul.hMul (â†‘m) (Î¼ s)) (Î¼ (Set.image f s))) (nhdsWithin 0 (Set.Ioi 0))","decl":"/-- Let `f` be a function which is sufficiently close (in the Lipschitz sense) to a given linear\nmap `A`. Then it expands the volume of any set by at least `m` for any `m < det A`. -/\ntheorem mul_le_addHaar_image_of_lt_det (A : E â†’L[â„] E) {m : â„â‰¥0}\n    (hm : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det|) :\n    âˆ€á¶  Î´ in ğ“[>] (0 : â„â‰¥0),\n      âˆ€ (s : Set E) (f : E â†’ E), ApproximatesLinearOn f A s Î´ â†’ (m : â„â‰¥0âˆ) * Î¼ s â‰¤ Î¼ (f '' s) := by\n  apply nhdsWithin_le_nhds\n  -- The assumption `hm` implies that `A` is invertible. If `f` is close enough to `A`, it is also\n  -- invertible. One can then pass to the inverses, and deduce the estimate from\n  -- `addHaar_image_le_mul_of_det_lt` applied to `fâ»Â¹` and `Aâ»Â¹`.\n  -- exclude first the trivial case where `m = 0`.\n  rcases eq_or_lt_of_le (zero_le m) with (rfl | mpos)\n  Â· filter_upwards\n    simp only [forall_const, zero_mul, imp_true_iff, zero_le, ENNReal.coe_zero]\n  have hA : A.det â‰  0 := by\n    intro h; simp only [h, ENNReal.not_lt_zero, ENNReal.ofReal_zero, abs_zero] at hm\n  -- let `B` be the continuous linear equiv version of `A`.\n  let B := A.toContinuousLinearEquivOfDetNeZero hA\n  -- the determinant of `B.symm` is bounded by `mâ»Â¹`\n  have I : ENNReal.ofReal |(B.symm : E â†’L[â„] E).det| < (mâ»Â¹ : â„â‰¥0) := by\n    simp only [ENNReal.ofReal, abs_inv, Real.toNNReal_inv, ContinuousLinearEquiv.det_coe_symm,\n      ContinuousLinearMap.coe_toContinuousLinearEquivOfDetNeZero, ENNReal.coe_lt_coe] at hm âŠ¢\n    exact NNReal.inv_lt_inv mpos.ne' hm\n  -- therefore, we may apply `addHaar_image_le_mul_of_det_lt` to `B.symm` and `mâ»Â¹`.\n  obtain âŸ¨Î´â‚€, Î´â‚€pos, hÎ´â‚€âŸ© :\n    âˆƒ Î´ : â„â‰¥0,\n      0 < Î´ âˆ§\n        âˆ€ (t : Set E) (g : E â†’ E),\n          ApproximatesLinearOn g (B.symm : E â†’L[â„] E) t Î´ â†’ Î¼ (g '' t) â‰¤ â†‘mâ»Â¹ * Î¼ t := by\n    have :\n      âˆ€á¶  Î´ : â„â‰¥0 in ğ“[>] 0,\n        âˆ€ (t : Set E) (g : E â†’ E),\n          ApproximatesLinearOn g (B.symm : E â†’L[â„] E) t Î´ â†’ Î¼ (g '' t) â‰¤ â†‘mâ»Â¹ * Î¼ t :=\n      addHaar_image_le_mul_of_det_lt Î¼ B.symm I\n    rcases (this.and self_mem_nhdsWithin).exists with âŸ¨Î´â‚€, h, h'âŸ©\n    exact âŸ¨Î´â‚€, h', hâŸ©\n  -- record smallness conditions for `Î´` that will be needed to apply `hÎ´â‚€` below.\n  have L1 : âˆ€á¶  Î´ in ğ“ (0 : â„â‰¥0), Subsingleton E âˆ¨ Î´ < â€–(B.symm : E â†’L[â„] E)â€–â‚Šâ»Â¹ := by\n    by_cases h : Subsingleton E\n    Â· simp only [h, true_or, eventually_const]\n    simp only [h, false_or]\n    apply Iio_mem_nhds\n    simpa only [h, false_or, inv_pos] using B.subsingleton_or_nnnorm_symm_pos\n  have L2 :\n    âˆ€á¶  Î´ in ğ“ (0 : â„â‰¥0), â€–(B.symm : E â†’L[â„] E)â€–â‚Š * (â€–(B.symm : E â†’L[â„] E)â€–â‚Šâ»Â¹ - Î´)â»Â¹ * Î´ < Î´â‚€ := by\n    have :\n      Tendsto (fun Î´ => â€–(B.symm : E â†’L[â„] E)â€–â‚Š * (â€–(B.symm : E â†’L[â„] E)â€–â‚Šâ»Â¹ - Î´)â»Â¹ * Î´) (ğ“ 0)\n        (ğ“ (â€–(B.symm : E â†’L[â„] E)â€–â‚Š * (â€–(B.symm : E â†’L[â„] E)â€–â‚Šâ»Â¹ - 0)â»Â¹ * 0)) := by\n      rcases eq_or_ne â€–(B.symm : E â†’L[â„] E)â€–â‚Š 0 with (H | H)\n      Â· simpa only [H, zero_mul] using tendsto_const_nhds\n      refine Tendsto.mul (tendsto_const_nhds.mul ?_) tendsto_id\n      refine (Tendsto.sub tendsto_const_nhds tendsto_id).invâ‚€ ?_\n      simpa only [tsub_zero, inv_eq_zero, Ne] using H\n    simp only [mul_zero] at this\n    exact (tendsto_order.1 this).2 Î´â‚€ Î´â‚€pos\n  -- let `Î´` be small enough, and `f` approximated by `B` up to `Î´`.\n  filter_upwards [L1, L2]\n  intro Î´ h1Î´ h2Î´ s f hf\n  have hf' : ApproximatesLinearOn f (B : E â†’L[â„] E) s Î´ := by convert hf\n  let F := hf'.toPartialEquiv h1Î´\n  -- the condition to be checked can be reformulated in terms of the inverse maps\n  suffices H : Î¼ (F.symm '' F.target) â‰¤ (mâ»Â¹ : â„â‰¥0) * Î¼ F.target by\n    change (m : â„â‰¥0âˆ) * Î¼ F.source â‰¤ Î¼ F.target\n    rwa [â† F.symm_image_target_eq_source, mul_comm, â† ENNReal.le_div_iff_mul_le, div_eq_mul_inv,\n      mul_comm, â† ENNReal.coe_inv mpos.ne']\n    Â· apply Or.inl\n      simpa only [ENNReal.coe_eq_zero, Ne] using mpos.ne'\n    Â· simp only [ENNReal.coe_ne_top, true_or, Ne, not_false_iff]\n  -- as `fâ»Â¹` is well approximated by `Bâ»Â¹`, the conclusion follows from `hÎ´â‚€`\n  -- and our choice of `Î´`.\n  exact hÎ´â‚€ _ _ ((hf'.to_inv h1Î´).mono_num h2Î´.le)\n\n"}
{"name":"ApproximatesLinearOn.norm_fderiv_sub_le","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nA : ContinuousLinearMap (RingHom.id Real) E E\nÎ´ : NNReal\nhf : ApproximatesLinearOn f A s Î´\nhs : MeasurableSet s\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ Filter.Eventually (fun x => LE.le (NNNorm.nnnorm (HSub.hSub (f' x) A)) Î´) (MeasureTheory.ae (Î¼.restrict s))","decl":"/-- If a differentiable function `f` is approximated by a linear map `A` on a set `s`, up to `Î´`,\nthen at almost every `x` in `s` one has `â€–f' x - Aâ€– â‰¤ Î´`. -/\ntheorem _root_.ApproximatesLinearOn.norm_fderiv_sub_le {A : E â†’L[â„] E} {Î´ : â„â‰¥0}\n    (hf : ApproximatesLinearOn f A s Î´) (hs : MeasurableSet s) (f' : E â†’ E â†’L[â„] E)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) : âˆ€áµ x âˆ‚Î¼.restrict s, â€–f' x - Aâ€–â‚Š â‰¤ Î´ := by\n  /- The conclusion will hold at the Lebesgue density points of `s` (which have full measure).\n    At such a point `x`, for any `z` and any `Îµ > 0` one has for small `r`\n    that `{x} + r â€¢ closedBall z Îµ` intersects `s`. At a point `y` in the intersection,\n    `f y - f x` is close both to `f' x (r z)` (by differentiability) and to `A (r z)`\n    (by linear approximation), so these two quantities are close, i.e., `(f' x - A) z` is small. -/\n  filter_upwards [Besicovitch.ae_tendsto_measure_inter_div Î¼ s, ae_restrict_mem hs]\n  -- start from a Lebesgue density point `x`, belonging to `s`.\n  intro x hx xs\n  -- consider an arbitrary vector `z`.\n  apply ContinuousLinearMap.opNorm_le_bound _ Î´.2 fun z => ?_\n  -- to show that `â€–(f' x - A) zâ€– â‰¤ Î´ â€–zâ€–`, it suffices to do it up to some error that vanishes\n  -- asymptotically in terms of `Îµ > 0`.\n  suffices H : âˆ€ Îµ, 0 < Îµ â†’ â€–(f' x - A) zâ€– â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ by\n    have :\n      Tendsto (fun Îµ : â„ => ((Î´ : â„) + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ) (ğ“[>] 0)\n        (ğ“ ((Î´ + 0) * (â€–zâ€– + 0) + â€–f' x - Aâ€– * 0)) :=\n      Tendsto.mono_left (Continuous.tendsto (by fun_prop) 0) nhdsWithin_le_nhds\n    simp only [add_zero, mul_zero] at this\n    apply le_of_tendsto_of_tendsto tendsto_const_nhds this\n    filter_upwards [self_mem_nhdsWithin]\n    exact H\n  -- fix a positive `Îµ`.\n  intro Îµ Îµpos\n  -- for small enough `r`, the rescaled ball `r â€¢ closedBall z Îµ` intersects `s`, as `x` is a\n  -- density point\n  have Bâ‚ : âˆ€á¶  r in ğ“[>] (0 : â„), (s âˆ© ({x} + r â€¢ closedBall z Îµ)).Nonempty :=\n    eventually_nonempty_inter_smul_of_density_one Î¼ s x hx _ measurableSet_closedBall\n      (measure_closedBall_pos Î¼ z Îµpos).ne'\n  obtain âŸ¨Ï, Ïpos, hÏâŸ© :\n    âˆƒ Ï > 0, ball x Ï âˆ© s âŠ† {y : E | â€–f y - f x - (f' x) (y - x)â€– â‰¤ Îµ * â€–y - xâ€–} :=\n    mem_nhdsWithin_iff.1 ((hf' x xs).isLittleO.def Îµpos)\n  -- for small enough `r`, the rescaled ball `r â€¢ closedBall z Îµ` is included in the set where\n  -- `f y - f x` is well approximated by `f' x (y - x)`.\n  have Bâ‚‚ : âˆ€á¶  r in ğ“[>] (0 : â„), {x} + r â€¢ closedBall z Îµ âŠ† ball x Ï := by\n    apply nhdsWithin_le_nhds\n    exact eventually_singleton_add_smul_subset isBounded_closedBall (ball_mem_nhds x Ïpos)\n  -- fix a small positive `r` satisfying the above properties, as well as a corresponding `y`.\n  obtain âŸ¨r, âŸ¨y, âŸ¨ys, hyâŸ©âŸ©, rÏ, rposâŸ© :\n    âˆƒ r : â„,\n      (s âˆ© ({x} + r â€¢ closedBall z Îµ)).Nonempty âˆ§ {x} + r â€¢ closedBall z Îµ âŠ† ball x Ï âˆ§ 0 < r :=\n    (Bâ‚.and (Bâ‚‚.and self_mem_nhdsWithin)).exists\n  -- write `y = x + r a` with `a âˆˆ closedBall z Îµ`.\n  obtain âŸ¨a, az, yaâŸ© : âˆƒ a, a âˆˆ closedBall z Îµ âˆ§ y = x + r â€¢ a := by\n    simp only [mem_smul_set, image_add_left, mem_preimage, singleton_add] at hy\n    rcases hy with âŸ¨a, az, haâŸ©\n    exact âŸ¨a, az, by simp only [ha, add_neg_cancel_left]âŸ©\n  have norm_a : â€–aâ€– â‰¤ â€–zâ€– + Îµ :=\n    calc\n      â€–aâ€– = â€–z + (a - z)â€– := by simp only [_root_.add_sub_cancel]\n      _ â‰¤ â€–zâ€– + â€–a - zâ€– := norm_add_le _ _\n      _ â‰¤ â€–zâ€– + Îµ := add_le_add_left (mem_closedBall_iff_norm.1 az) _\n  -- use the approximation properties to control `(f' x - A) a`, and then `(f' x - A) z` as `z` is\n  -- close to `a`.\n  have I : r * â€–(f' x - A) aâ€– â‰¤ r * (Î´ + Îµ) * (â€–zâ€– + Îµ) :=\n    calc\n      r * â€–(f' x - A) aâ€– = â€–(f' x - A) (r â€¢ a)â€– := by\n        simp only [ContinuousLinearMap.map_smul, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]\n      _ = â€–f y - f x - A (y - x) - (f y - f x - (f' x) (y - x))â€– := by\n        congr 1\n        simp only [ya, add_sub_cancel_left, sub_sub_sub_cancel_left, ContinuousLinearMap.coe_sub',\n          eq_self_iff_true, sub_left_inj, Pi.sub_apply, ContinuousLinearMap.map_smul, smul_sub]\n      _ â‰¤ â€–f y - f x - A (y - x)â€– + â€–f y - f x - (f' x) (y - x)â€– := norm_sub_le _ _\n      _ â‰¤ Î´ * â€–y - xâ€– + Îµ * â€–y - xâ€– := (add_le_add (hf _ ys _ xs) (hÏ âŸ¨rÏ hy, ysâŸ©))\n      _ = r * (Î´ + Îµ) * â€–aâ€– := by\n        simp only [ya, add_sub_cancel_left, norm_smul, Real.norm_eq_abs, abs_of_nonneg rpos.le]\n        ring\n      _ â‰¤ r * (Î´ + Îµ) * (â€–zâ€– + Îµ) := by gcongr\n  calc\n    â€–(f' x - A) zâ€– = â€–(f' x - A) a + (f' x - A) (z - a)â€– := by\n      congr 1\n      simp only [ContinuousLinearMap.coe_sub', map_sub, Pi.sub_apply]\n      abel\n    _ â‰¤ â€–(f' x - A) aâ€– + â€–(f' x - A) (z - a)â€– := norm_add_le _ _\n    _ â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * â€–z - aâ€– := by\n      apply add_le_add\n      Â· rw [mul_assoc] at I; exact (mul_le_mul_left rpos).1 I\n      Â· apply ContinuousLinearMap.le_opNorm\n    _ â‰¤ (Î´ + Îµ) * (â€–zâ€– + Îµ) + â€–f' x - Aâ€– * Îµ := by\n      rw [mem_closedBall_iff_norm'] at az\n      gcongr\n\n"}
{"name":"MeasureTheory.addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhf : DifferentiableOn Real f s\nhs : Eq (Î¼ s) 0\nâŠ¢ Eq (Î¼ (Set.image f s)) 0","decl":"/-- A differentiable function maps sets of measure zero to sets of measure zero. -/\ntheorem addHaar_image_eq_zero_of_differentiableOn_of_addHaar_eq_zero (hf : DifferentiableOn â„ f s)\n    (hs : Î¼ s = 0) : Î¼ (f '' s) = 0 := by\n  refine le_antisymm ?_ (zero_le _)\n  have :\n      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§\n        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’\n          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + 1 : â„â‰¥0) * Î¼ t := by\n    intro A\n    let m : â„â‰¥0 := Real.toNNReal |A.det| + 1\n    have I : ENNReal.ofReal |A.det| < m := by\n      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, zero_lt_one, ENNReal.coe_lt_coe]\n    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©\n    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©\n  choose Î´ hÎ´ using this\n  obtain âŸ¨t, A, _, _, t_cover, ht, -âŸ© :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),\n      Pairwise (Disjoint on t) âˆ§\n        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§\n          (s âŠ† â‹ƒ n : â„•, t n) âˆ§\n            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§\n              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = fderivWithin â„ f s y) :=\n    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s (fderivWithin â„ f s)\n      (fun x xs => (hf x xs).hasFDerivWithinAt) Î´ fun A => (hÎ´ A).1.ne'\n  calc\n    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by\n      apply measure_mono\n      rw [â† image_iUnion, â† inter_iUnion]\n      exact image_subset f (subset_inter Subset.rfl t_cover)\n    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _\n    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + 1 : â„â‰¥0) * Î¼ (s âˆ© t n) := by\n      apply ENNReal.tsum_le_tsum fun n => ?_\n      apply (hÎ´ (A n)).2\n      exact ht n\n    _ â‰¤ âˆ‘' n, ((Real.toNNReal |(A n).det| + 1 : â„â‰¥0) : â„â‰¥0âˆ) * 0 := by\n      refine ENNReal.tsum_le_tsum fun n => mul_le_mul_left' ?_ _\n      exact le_trans (measure_mono inter_subset_left) (le_of_eq hs)\n    _ = 0 := by simp only [tsum_zero, mul_zero]\n\n"}
{"name":"MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nR : Real\nhs : HasSubset.Subset s (Metric.closedBall 0 R)\nÎµ : NNReal\nÎµpos : LT.lt 0 Îµ\nh'f' : âˆ€ (x : E), Membership.mem s x â†’ Eq (f' x).det 0\nâŠ¢ LE.le (Î¼ (Set.image f s)) (HMul.hMul (â†‘Îµ) (Î¼ (Metric.closedBall 0 R)))","decl":"/-- A version of **Sard's lemma** in fixed dimension: given a differentiable function from `E`\nto `E` and a set where the differential is not invertible, then the image of this set has\nzero measure. Here, we give an auxiliary statement towards this result. -/\ntheorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (R : â„) (hs : s âŠ† closedBall 0 R) (Îµ : â„â‰¥0)\n    (Îµpos : 0 < Îµ) (h'f' : âˆ€ x âˆˆ s, (f' x).det = 0) : Î¼ (f '' s) â‰¤ Îµ * Î¼ (closedBall 0 R) := by\n  rcases eq_empty_or_nonempty s with (rfl | h's); Â· simp only [measure_empty, zero_le, image_empty]\n  have :\n      âˆ€ A : E â†’L[â„] E, âˆƒ Î´ : â„â‰¥0, 0 < Î´ âˆ§\n        âˆ€ (t : Set E), ApproximatesLinearOn f A t Î´ â†’\n          Î¼ (f '' t) â‰¤ (Real.toNNReal |A.det| + Îµ : â„â‰¥0) * Î¼ t := by\n    intro A\n    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ\n    have I : ENNReal.ofReal |A.det| < m := by\n      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]\n    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, h'âŸ©\n    exact âŸ¨Î´, h', fun t ht => h t f htâŸ©\n  choose Î´ hÎ´ using this\n  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, Af'âŸ© :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),\n      Pairwise (Disjoint on t) âˆ§\n        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§\n          (s âŠ† â‹ƒ n : â„•, t n) âˆ§\n            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§\n              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=\n    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'\n  calc\n    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by\n      rw [â† image_iUnion, â† inter_iUnion]\n      gcongr\n      exact subset_inter Subset.rfl t_cover\n    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _\n    _ â‰¤ âˆ‘' n, (Real.toNNReal |(A n).det| + Îµ : â„â‰¥0) * Î¼ (s âˆ© t n) := by\n      gcongr\n      exact (hÎ´ (A _)).2 _ (ht _)\n    _ = âˆ‘' n, Îµ * Î¼ (s âˆ© t n) := by\n      congr with n\n      rcases Af' h's n with âŸ¨y, ys, hyâŸ©\n      simp only [hy, h'f' y ys, Real.toNNReal_zero, abs_zero, zero_add]\n    _ â‰¤ Îµ * âˆ‘' n, Î¼ (closedBall 0 R âˆ© t n) := by\n      rw [ENNReal.tsum_mul_left]\n      gcongr\n    _ = Îµ * Î¼ (â‹ƒ n, closedBall 0 R âˆ© t n) := by\n      rw [measure_iUnion]\n      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right\n      Â· intro n\n        exact measurableSet_closedBall.inter (t_meas n)\n    _ â‰¤ Îµ * Î¼ (closedBall 0 R) := by\n      rw [â† inter_iUnion]\n      exact mul_le_mul_left' (measure_mono inter_subset_left) _\n\n"}
{"name":"MeasureTheory.addHaar_image_eq_zero_of_det_fderivWithin_eq_zero","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nh'f' : âˆ€ (x : E), Membership.mem s x â†’ Eq (f' x).det 0\nâŠ¢ Eq (Î¼ (Set.image f s)) 0","decl":"/-- A version of Sard lemma in fixed dimension: given a differentiable function from `E` to `E` and\na set where the differential is not invertible, then the image of this set has zero measure. -/\ntheorem addHaar_image_eq_zero_of_det_fderivWithin_eq_zero\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (h'f' : âˆ€ x âˆˆ s, (f' x).det = 0) :\n    Î¼ (f '' s) = 0 := by\n  suffices H : âˆ€ R, Î¼ (f '' (s âˆ© closedBall 0 R)) = 0 by\n    apply le_antisymm _ (zero_le _)\n    rw [â† iUnion_inter_closedBall_nat s 0]\n    calc\n      Î¼ (f '' â‹ƒ n : â„•, s âˆ© closedBall 0 n) â‰¤ âˆ‘' n : â„•, Î¼ (f '' (s âˆ© closedBall 0 n)) := by\n        rw [image_iUnion]; exact measure_iUnion_le _\n      _ â‰¤ 0 := by simp only [H, tsum_zero, nonpos_iff_eq_zero]\n  intro R\n  have A : âˆ€ (Îµ : â„â‰¥0), 0 < Îµ â†’ Î¼ (f '' (s âˆ© closedBall 0 R)) â‰¤ Îµ * Î¼ (closedBall 0 R) :=\n    fun Îµ Îµpos =>\n    addHaar_image_eq_zero_of_det_fderivWithin_eq_zero_aux Î¼\n      (fun x hx => (hf' x hx.1).mono inter_subset_left) R inter_subset_right Îµ Îµpos\n      fun x hx => h'f' x hx.1\n  have B : Tendsto (fun Îµ : â„â‰¥0 => (Îµ : â„â‰¥0âˆ) * Î¼ (closedBall 0 R)) (ğ“[>] 0) (ğ“ 0) := by\n    have :\n      Tendsto (fun Îµ : â„â‰¥0 => (Îµ : â„â‰¥0âˆ) * Î¼ (closedBall 0 R)) (ğ“ 0)\n        (ğ“ (((0 : â„â‰¥0) : â„â‰¥0âˆ) * Î¼ (closedBall 0 R))) :=\n      ENNReal.Tendsto.mul_const (ENNReal.tendsto_coe.2 tendsto_id)\n        (Or.inr measure_closedBall_lt_top.ne)\n    simp only [zero_mul, ENNReal.coe_zero] at this\n    exact Tendsto.mono_left this nhdsWithin_le_nhds\n  apply le_antisymm _ (zero_le _)\n  apply ge_of_tendsto B\n  filter_upwards [self_mem_nhdsWithin]\n  exact A\n\n"}
{"name":"MeasureTheory.aemeasurable_fderivWithin","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ AEMeasurable f' (Î¼.restrict s)","decl":"/-- The derivative of a function on a measurable set is almost everywhere measurable on this set\nwith respect to Lebesgue measure. Note that, in general, it is not genuinely measurable there,\nas `f'` is not unique (but only on a set of measure `0`, as the argument shows). -/\ntheorem aemeasurable_fderivWithin (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) : AEMeasurable f' (Î¼.restrict s) := by\n  /- It suffices to show that `f'` can be uniformly approximated by a measurable function.\n    Fix `Îµ > 0`. Thanks to `exists_partition_approximatesLinearOn_of_hasFDerivWithinAt`, one\n    can find a countable measurable partition of `s` into sets `s âˆ© t n` on which `f` is well\n    approximated by linear maps `A n`. On almost all of `s âˆ© t n`, it follows from\n    `ApproximatesLinearOn.norm_fderiv_sub_le` that `f'` is uniformly approximated by `A n`, which\n    gives the conclusion. -/\n  -- fix a precision `Îµ`\n  refine aemeasurable_of_unif_approx fun Îµ Îµpos => ?_\n  let Î´ : â„â‰¥0 := âŸ¨Îµ, le_of_lt ÎµposâŸ©\n  have Î´pos : 0 < Î´ := Îµpos\n  -- partition `s` into sets `s âˆ© t n` on which `f` is approximated by linear maps `A n`.\n  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, _âŸ© :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),\n      Pairwise (Disjoint on t) âˆ§\n        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§\n          (s âŠ† â‹ƒ n : â„•, t n) âˆ§\n            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) Î´) âˆ§\n              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=\n    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' (fun _ => Î´) fun _ =>\n      Î´pos.ne'\n  -- define a measurable function `g` which coincides with `A n` on `t n`.\n  obtain âŸ¨g, g_meas, hgâŸ© :\n      âˆƒ g : E â†’ E â†’L[â„] E, Measurable g âˆ§ âˆ€ (n : â„•) (x : E), x âˆˆ t n â†’ g x = A n :=\n    exists_measurable_piecewise t t_meas (fun n _ => A n) (fun n => measurable_const) <|\n      t_disj.mono fun i j h => by simp only [h.inter_eq, eqOn_empty]\n  refine âŸ¨g, g_meas.aemeasurable, ?_âŸ©\n  -- reduce to checking that `f'` and `g` are close on almost all of `s âˆ© t n`, for all `n`.\n  suffices H : âˆ€áµ x : E âˆ‚sum fun n â†¦ Î¼.restrict (s âˆ© t n), dist (g x) (f' x) â‰¤ Îµ by\n    have : Î¼.restrict s â‰¤ sum fun n => Î¼.restrict (s âˆ© t n) := by\n      have : s = â‹ƒ n, s âˆ© t n := by\n        rw [â† inter_iUnion]\n        exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left\n      conv_lhs => rw [this]\n      exact restrict_iUnion_le\n    exact ae_mono this H\n  -- fix such an `n`.\n  refine ae_sum_iff.2 fun n => ?_\n  -- on almost all `s âˆ© t n`, `f' x` is close to `A n` thanks to\n  -- `ApproximatesLinearOn.norm_fderiv_sub_le`.\n  have Eâ‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), â€–f' x - A nâ€–â‚Š â‰¤ Î´ :=\n    (ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>\n      (hf' x hx.1).mono inter_subset_left\n  -- moreover, `g x` is equal to `A n` there.\n  have Eâ‚‚ : âˆ€áµ x : E âˆ‚Î¼.restrict (s âˆ© t n), g x = A n := by\n    suffices H : âˆ€áµ x : E âˆ‚Î¼.restrict (t n), g x = A n from\n      ae_mono (restrict_mono inter_subset_right le_rfl) H\n    filter_upwards [ae_restrict_mem (t_meas n)]\n    exact hg n\n  -- putting these two properties together gives the conclusion.\n  filter_upwards [Eâ‚, Eâ‚‚] with x hx1 hx2\n  rw [â† nndist_eq_nnnorm] at hx1\n  rw [hx2, dist_comm]\n  exact hx1\n\n"}
{"name":"MeasureTheory.aemeasurable_ofReal_abs_det_fderivWithin","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ AEMeasurable (fun x => ENNReal.ofReal (abs (f' x).det)) (Î¼.restrict s)","decl":"theorem aemeasurable_ofReal_abs_det_fderivWithin (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) :\n    AEMeasurable (fun x => ENNReal.ofReal |(f' x).det|) (Î¼.restrict s) := by\n  apply ENNReal.measurable_ofReal.comp_aemeasurable\n  refine continuous_abs.measurable.comp_aemeasurable ?_\n  refine ContinuousLinearMap.continuous_det.measurable.comp_aemeasurable ?_\n  exact aemeasurable_fderivWithin Î¼ hs hf'\n\n"}
{"name":"MeasureTheory.aemeasurable_toNNReal_abs_det_fderivWithin","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ AEMeasurable (fun x => (abs (f' x).det).toNNReal) (Î¼.restrict s)","decl":"theorem aemeasurable_toNNReal_abs_det_fderivWithin (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) :\n    AEMeasurable (fun x => |(f' x).det|.toNNReal) (Î¼.restrict s) := by\n  apply measurable_real_toNNReal.comp_aemeasurable\n  refine continuous_abs.measurable.comp_aemeasurable ?_\n  refine ContinuousLinearMap.continuous_det.measurable.comp_aemeasurable ?_\n  exact aemeasurable_fderivWithin Î¼ hs hf'\n\n"}
{"name":"MeasureTheory.measurable_image_of_fderivWithin","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nâŠ¢ MeasurableSet (Set.image f s)","decl":"/-- If a function is differentiable and injective on a measurable set,\nthen the image is measurable. -/\ntheorem measurable_image_of_fderivWithin (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) : MeasurableSet (f '' s) :=\n  haveI : DifferentiableOn â„ f s := fun x hx => (hf' x hx).differentiableWithinAt\n  hs.image_of_continuousOn_injOn (DifferentiableOn.continuousOn this) hf\n\n"}
{"name":"MeasureTheory.measurableEmbedding_of_fderivWithin","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ¹ : MeasurableSpace E\ninstâœ : BorelSpace E\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nâŠ¢ MeasurableEmbedding (s.restrict f)","decl":"/-- If a function is differentiable and injective on a measurable set `s`, then its restriction\nto `s` is a measurable embedding. -/\ntheorem measurableEmbedding_of_fderivWithin (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    MeasurableEmbedding (s.restrict f) :=\n  haveI : DifferentiableOn â„ f s := fun x hx => (hf' x hx).differentiableWithinAt\n  this.continuousOn.measurableEmbedding hs hf\n\n"}
{"name":"MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv_aux1","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nÎµ : NNReal\nÎµpos : LT.lt 0 Îµ\nâŠ¢ LE.le (Î¼ (Set.image f s)) (HAdd.hAdd (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det)) (HMul.hMul (HMul.hMul 2 â†‘Îµ) (Î¼ s)))","decl":"theorem addHaar_image_le_lintegral_abs_det_fderiv_aux1 (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :\n    Î¼ (f '' s) â‰¤ (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by\n  /- To bound `Î¼ (f '' s)`, we cover `s` by sets where `f` is well-approximated by linear maps\n    `A n` (and where `f'` is almost everywhere close to `A n`), and then use that `f` expands the\n    measure of such a set by at most `(A n).det + Îµ`. -/\n  have :\n    âˆ€ A : E â†’L[â„] E,\n      âˆƒ Î´ : â„â‰¥0,\n        0 < Î´ âˆ§\n          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§\n            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’\n              Î¼ (g '' t) â‰¤ (ENNReal.ofReal |A.det| + Îµ) * Î¼ t := by\n    intro A\n    let m : â„â‰¥0 := Real.toNNReal |A.det| + Îµ\n    have I : ENNReal.ofReal |A.det| < m := by\n      simp only [m, ENNReal.ofReal, lt_add_iff_pos_right, Îµpos, ENNReal.coe_lt_coe]\n    rcases ((addHaar_image_le_mul_of_det_lt Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©\n    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ := by\n      refine continuousAt_iff.1 ?_ Îµ Îµpos\n      exact ContinuousLinearMap.continuous_det.continuousAt\n    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©\n    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©\n    Â· intro B hB\n      rw [â† Real.dist_eq]\n      apply (hÎ´' B _).le\n      rw [dist_eq_norm]\n      calc\n        â€–B - Aâ€– â‰¤ (min Î´ Î´'' : â„â‰¥0) := hB\n        _ â‰¤ Î´'' := by simp only [le_refl, NNReal.coe_min, min_le_iff, or_true]\n        _ < Î´' := half_lt_self Î´'pos\n    Â· intro t g htg\n      exact h t g (htg.mono_num (min_le_left _ _))\n  choose Î´ hÎ´ using this\n  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),\n      Pairwise (Disjoint on t) âˆ§\n        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§\n          (s âŠ† â‹ƒ n : â„•, t n) âˆ§\n            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§\n              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=\n    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'\n  calc\n    Î¼ (f '' s) â‰¤ Î¼ (â‹ƒ n, f '' (s âˆ© t n)) := by\n      apply measure_mono\n      rw [â† image_iUnion, â† inter_iUnion]\n      exact image_subset f (subset_inter Subset.rfl t_cover)\n    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© t n)) := measure_iUnion_le _\n    _ â‰¤ âˆ‘' n, (ENNReal.ofReal |(A n).det| + Îµ) * Î¼ (s âˆ© t n) := by\n      apply ENNReal.tsum_le_tsum fun n => ?_\n      apply (hÎ´ (A n)).2.2\n      exact ht n\n    _ = âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by\n      simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter]\n    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by\n      apply ENNReal.tsum_le_tsum fun n => ?_\n      apply lintegral_mono_ae\n      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>\n          (hf' x hx.1).mono inter_subset_left]\n      intro x hx\n      have I : |(A n).det| â‰¤ |(f' x).det| + Îµ :=\n        calc\n          |(A n).det| = |(f' x).det - ((f' x).det - (A n).det)| := by congr 1; abel\n          _ â‰¤ |(f' x).det| + |(f' x).det - (A n).det| := abs_sub _ _\n          _ â‰¤ |(f' x).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)\n      calc\n        ENNReal.ofReal |(A n).det| + Îµ â‰¤ ENNReal.ofReal (|(f' x).det| + Îµ) + Îµ := by gcongr\n        _ = ENNReal.ofReal |(f' x).det| + 2 * Îµ := by\n          simp only [ENNReal.ofReal_add, abs_nonneg, two_mul, add_assoc, NNReal.zero_le_coe,\n            ENNReal.ofReal_coe_nnreal]\n    _ = âˆ«â» x in â‹ƒ n, s âˆ© t n, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by\n      have M : âˆ€ n : â„•, MeasurableSet (s âˆ© t n) := fun n => hs.inter (t_meas n)\n      rw [lintegral_iUnion M]\n      exact pairwise_disjoint_mono t_disj fun n => inter_subset_right\n    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| + 2 * Îµ âˆ‚Î¼ := by\n      rw [â† inter_iUnion, inter_eq_self_of_subset_left t_cover]\n    _ = (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s := by\n      simp only [lintegral_add_right' _ aemeasurable_const, setLIntegral_const]\n\n"}
{"name":"MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv_aux2","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nh's : Ne (Î¼ s) Top.top\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ LE.le (Î¼ (Set.image f s)) (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det))","decl":"theorem addHaar_image_le_lintegral_abs_det_fderiv_aux2 (hs : MeasurableSet s) (h's : Î¼ s â‰  âˆ)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) :\n    Î¼ (f '' s) â‰¤ âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by\n  -- We just need to let the error tend to `0` in the previous lemma.\n  have :\n    Tendsto (fun Îµ : â„â‰¥0 => (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * Îµ * Î¼ s) (ğ“[>] 0)\n      (ğ“ ((âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) + 2 * (0 : â„â‰¥0) * Î¼ s)) := by\n    apply Tendsto.mono_left _ nhdsWithin_le_nhds\n    refine tendsto_const_nhds.add ?_\n    refine ENNReal.Tendsto.mul_const ?_ (Or.inr h's)\n    exact ENNReal.Tendsto.const_mul (ENNReal.tendsto_coe.2 tendsto_id) (Or.inr ENNReal.coe_ne_top)\n  simp only [add_zero, zero_mul, mul_zero, ENNReal.coe_zero] at this\n  apply ge_of_tendsto this\n  filter_upwards [self_mem_nhdsWithin]\n  intro Îµ Îµpos\n  rw [mem_Ioi] at Îµpos\n  exact addHaar_image_le_lintegral_abs_det_fderiv_aux1 Î¼ hs hf' Îµpos\n\n"}
{"name":"MeasureTheory.addHaar_image_le_lintegral_abs_det_fderiv","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ LE.le (Î¼ (Set.image f s)) (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det))","decl":"theorem addHaar_image_le_lintegral_abs_det_fderiv (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) :\n    Î¼ (f '' s) â‰¤ âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by\n  /- We already know the result for finite-measure sets. We cover `s` by finite-measure sets using\n    `spanningSets Î¼`, and apply the previous result to each of these parts. -/\n  let u n := disjointed (spanningSets Î¼) n\n  have u_meas : âˆ€ n, MeasurableSet (u n) := by\n    intro n\n    apply MeasurableSet.disjointed fun i => ?_\n    exact measurableSet_spanningSets Î¼ i\n  have A : s = â‹ƒ n, s âˆ© u n := by\n    rw [â† inter_iUnion, iUnion_disjointed, iUnion_spanningSets, inter_univ]\n  calc\n    Î¼ (f '' s) â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© u n)) := by\n      conv_lhs => rw [A, image_iUnion]\n      exact measure_iUnion_le _\n    _ â‰¤ âˆ‘' n, âˆ«â» x in s âˆ© u n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by\n      apply ENNReal.tsum_le_tsum fun n => ?_\n      apply\n        addHaar_image_le_lintegral_abs_det_fderiv_aux2 Î¼ (hs.inter (u_meas n)) _ fun x hx =>\n          (hf' x hx.1).mono inter_subset_left\n      have : Î¼ (u n) < âˆ :=\n        lt_of_le_of_lt (measure_mono (disjointed_subset _ _)) (measure_spanningSets_lt_top Î¼ n)\n      exact ne_of_lt (lt_of_le_of_lt (measure_mono inter_subset_right) this)\n    _ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by\n      conv_rhs => rw [A]\n      rw [lintegral_iUnion]\n      Â· intro n; exact hs.inter (u_meas n)\n      Â· exact pairwise_disjoint_mono (disjoint_disjointed _) fun n => inter_subset_right\n\n"}
{"name":"MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux1","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nÎµ : NNReal\nÎµpos : LT.lt 0 Îµ\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det)) (HAdd.hAdd (Î¼ (Set.image f s)) (HMul.hMul (HMul.hMul 2 â†‘Îµ) (Î¼ s)))","decl":"theorem lintegral_abs_det_fderiv_le_addHaar_image_aux1 (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) {Îµ : â„â‰¥0} (Îµpos : 0 < Îµ) :\n    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) â‰¤ Î¼ (f '' s) + 2 * Îµ * Î¼ s := by\n  /- To bound `âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼`, we cover `s` by sets where `f` is\n    well-approximated by linear maps `A n` (and where `f'` is almost everywhere close to `A n`),\n    and then use that `f` expands the measure of such a set by at least `(A n).det - Îµ`. -/\n  have :\n    âˆ€ A : E â†’L[â„] E,\n      âˆƒ Î´ : â„â‰¥0,\n        0 < Î´ âˆ§\n          (âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ Î´ â†’ |B.det - A.det| â‰¤ Îµ) âˆ§\n            âˆ€ (t : Set E) (g : E â†’ E), ApproximatesLinearOn g A t Î´ â†’\n              ENNReal.ofReal |A.det| * Î¼ t â‰¤ Î¼ (g '' t) + Îµ * Î¼ t := by\n    intro A\n    obtain âŸ¨Î´', Î´'pos, hÎ´'âŸ© : âˆƒ (Î´' : â„), 0 < Î´' âˆ§ âˆ€ B, dist B A < Î´' â†’ dist B.det A.det < â†‘Îµ := by\n      refine continuousAt_iff.1 ?_ Îµ Îµpos\n      exact ContinuousLinearMap.continuous_det.continuousAt\n    let Î´'' : â„â‰¥0 := âŸ¨Î´' / 2, (half_pos Î´'pos).leâŸ©\n    have I'' : âˆ€ B : E â†’L[â„] E, â€–B - Aâ€– â‰¤ â†‘Î´'' â†’ |B.det - A.det| â‰¤ â†‘Îµ := by\n      intro B hB\n      rw [â† Real.dist_eq]\n      apply (hÎ´' B _).le\n      rw [dist_eq_norm]\n      exact hB.trans_lt (half_lt_self Î´'pos)\n    rcases eq_or_ne A.det 0 with (hA | hA)\n    Â· refine âŸ¨Î´'', half_pos Î´'pos, I'', ?_âŸ©\n      simp only [hA, forall_const, zero_mul, ENNReal.ofReal_zero, imp_true_iff,\n        zero_le, abs_zero]\n    let m : â„â‰¥0 := Real.toNNReal |A.det| - Îµ\n    have I : (m : â„â‰¥0âˆ) < ENNReal.ofReal |A.det| := by\n      simp only [m, ENNReal.ofReal, ENNReal.coe_sub]\n      apply ENNReal.sub_lt_self ENNReal.coe_ne_top\n      Â· simpa only [abs_nonpos_iff, Real.toNNReal_eq_zero, ENNReal.coe_eq_zero, Ne] using hA\n      Â· simp only [Îµpos.ne', ENNReal.coe_eq_zero, Ne, not_false_iff]\n    rcases ((mul_le_addHaar_image_of_lt_det Î¼ A I).and self_mem_nhdsWithin).exists with âŸ¨Î´, h, Î´posâŸ©\n    refine âŸ¨min Î´ Î´'', lt_min Î´pos (half_pos Î´'pos), ?_, ?_âŸ©\n    Â· intro B hB\n      apply I'' _ (hB.trans _)\n      simp only [le_refl, NNReal.coe_min, min_le_iff, or_true]\n    Â· intro t g htg\n      rcases eq_or_ne (Î¼ t) âˆ with (ht | ht)\n      Â· simp only [ht, Îµpos.ne', ENNReal.mul_top, ENNReal.coe_eq_zero, le_top, Ne,\n          not_false_iff, _root_.add_top]\n      have := h t g (htg.mono_num (min_le_left _ _))\n      rwa [ENNReal.coe_sub, ENNReal.sub_mul, tsub_le_iff_right] at this\n      simp only [ht, imp_true_iff, Ne, not_false_iff]\n  choose Î´ hÎ´ using this\n  obtain âŸ¨t, A, t_disj, t_meas, t_cover, ht, -âŸ© :\n    âˆƒ (t : â„• â†’ Set E) (A : â„• â†’ E â†’L[â„] E),\n      Pairwise (Disjoint on t) âˆ§\n        (âˆ€ n : â„•, MeasurableSet (t n)) âˆ§\n          (s âŠ† â‹ƒ n : â„•, t n) âˆ§\n            (âˆ€ n : â„•, ApproximatesLinearOn f (A n) (s âˆ© t n) (Î´ (A n))) âˆ§\n              (s.Nonempty â†’ âˆ€ n, âˆƒ y âˆˆ s, A n = f' y) :=\n    exists_partition_approximatesLinearOn_of_hasFDerivWithinAt f s f' hf' Î´ fun A => (hÎ´ A).1.ne'\n  have s_eq : s = â‹ƒ n, s âˆ© t n := by\n    rw [â† inter_iUnion]\n    exact Subset.antisymm (subset_inter Subset.rfl t_cover) inter_subset_left\n  calc\n    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =\n        âˆ‘' n, âˆ«â» x in s âˆ© t n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by\n      conv_lhs => rw [s_eq]\n      rw [lintegral_iUnion]\n      Â· exact fun n => hs.inter (t_meas n)\n      Â· exact pairwise_disjoint_mono t_disj fun n => inter_subset_right\n    _ â‰¤ âˆ‘' n, âˆ«â» _ in s âˆ© t n, ENNReal.ofReal |(A n).det| + Îµ âˆ‚Î¼ := by\n      apply ENNReal.tsum_le_tsum fun n => ?_\n      apply lintegral_mono_ae\n      filter_upwards [(ht n).norm_fderiv_sub_le Î¼ (hs.inter (t_meas n)) f' fun x hx =>\n          (hf' x hx.1).mono inter_subset_left]\n      intro x hx\n      have I : |(f' x).det| â‰¤ |(A n).det| + Îµ :=\n        calc\n          |(f' x).det| = |(A n).det + ((f' x).det - (A n).det)| := by congr 1; abel\n          _ â‰¤ |(A n).det| + |(f' x).det - (A n).det| := abs_add _ _\n          _ â‰¤ |(A n).det| + Îµ := add_le_add le_rfl ((hÎ´ (A n)).2.1 _ hx)\n      calc\n        ENNReal.ofReal |(f' x).det| â‰¤ ENNReal.ofReal (|(A n).det| + Îµ) :=\n          ENNReal.ofReal_le_ofReal I\n        _ = ENNReal.ofReal |(A n).det| + Îµ := by\n          simp only [ENNReal.ofReal_add, abs_nonneg, NNReal.zero_le_coe, ENNReal.ofReal_coe_nnreal]\n    _ = âˆ‘' n, (ENNReal.ofReal |(A n).det| * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by\n      simp only [setLIntegral_const, lintegral_add_right _ measurable_const]\n    _ â‰¤ âˆ‘' n, (Î¼ (f '' (s âˆ© t n)) + Îµ * Î¼ (s âˆ© t n) + Îµ * Î¼ (s âˆ© t n)) := by\n      gcongr\n      exact (hÎ´ (A _)).2.2 _ _ (ht _)\n    _ = Î¼ (f '' s) + 2 * Îµ * Î¼ s := by\n      conv_rhs => rw [s_eq]\n      rw [image_iUnion, measure_iUnion]; rotate_left\n      Â· intro i j hij\n        apply Disjoint.image _ hf inter_subset_left inter_subset_left\n        exact Disjoint.mono inter_subset_right inter_subset_right (t_disj hij)\n      Â· intro i\n        exact\n          measurable_image_of_fderivWithin (hs.inter (t_meas i))\n            (fun x hx => (hf' x hx.1).mono inter_subset_left)\n            (hf.mono inter_subset_left)\n      rw [measure_iUnion]; rotate_left\n      Â· exact pairwise_disjoint_mono t_disj fun i => inter_subset_right\n      Â· exact fun i => hs.inter (t_meas i)\n      rw [â† ENNReal.tsum_mul_left, â† ENNReal.tsum_add]\n      congr 1\n      ext1 i\n      rw [mul_assoc, two_mul, add_assoc]\n\n"}
{"name":"MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image_aux2","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nh's : Ne (Î¼ s) Top.top\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det)) (Î¼ (Set.image f s))","decl":"theorem lintegral_abs_det_fderiv_le_addHaar_image_aux2 (hs : MeasurableSet s) (h's : Î¼ s â‰  âˆ)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) â‰¤ Î¼ (f '' s) := by\n  -- We just need to let the error tend to `0` in the previous lemma.\n  have :\n    Tendsto (fun Îµ : â„â‰¥0 => Î¼ (f '' s) + 2 * Îµ * Î¼ s) (ğ“[>] 0)\n      (ğ“ (Î¼ (f '' s) + 2 * (0 : â„â‰¥0) * Î¼ s)) := by\n    apply Tendsto.mono_left _ nhdsWithin_le_nhds\n    refine tendsto_const_nhds.add ?_\n    refine ENNReal.Tendsto.mul_const ?_ (Or.inr h's)\n    exact ENNReal.Tendsto.const_mul (ENNReal.tendsto_coe.2 tendsto_id) (Or.inr ENNReal.coe_ne_top)\n  simp only [add_zero, zero_mul, mul_zero, ENNReal.coe_zero] at this\n  apply ge_of_tendsto this\n  filter_upwards [self_mem_nhdsWithin]\n  intro Îµ Îµpos\n  rw [mem_Ioi] at Îµpos\n  exact lintegral_abs_det_fderiv_le_addHaar_image_aux1 Î¼ hs hf' hf Îµpos\n\n"}
{"name":"MeasureTheory.lintegral_abs_det_fderiv_le_addHaar_image","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nâŠ¢ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det)) (Î¼ (Set.image f s))","decl":"theorem lintegral_abs_det_fderiv_le_addHaar_image (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) â‰¤ Î¼ (f '' s) := by\n  /- We already know the result for finite-measure sets. We cover `s` by finite-measure sets using\n    `spanningSets Î¼`, and apply the previous result to each of these parts. -/\n  let u n := disjointed (spanningSets Î¼) n\n  have u_meas : âˆ€ n, MeasurableSet (u n) := by\n    intro n\n    apply MeasurableSet.disjointed fun i => ?_\n    exact measurableSet_spanningSets Î¼ i\n  have A : s = â‹ƒ n, s âˆ© u n := by\n    rw [â† inter_iUnion, iUnion_disjointed, iUnion_spanningSets, inter_univ]\n  calc\n    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) =\n        âˆ‘' n, âˆ«â» x in s âˆ© u n, ENNReal.ofReal |(f' x).det| âˆ‚Î¼ := by\n      conv_lhs => rw [A]\n      rw [lintegral_iUnion]\n      Â· intro n; exact hs.inter (u_meas n)\n      Â· exact pairwise_disjoint_mono (disjoint_disjointed _) fun n => inter_subset_right\n    _ â‰¤ âˆ‘' n, Î¼ (f '' (s âˆ© u n)) := by\n      apply ENNReal.tsum_le_tsum fun n => ?_\n      apply\n        lintegral_abs_det_fderiv_le_addHaar_image_aux2 Î¼ (hs.inter (u_meas n)) _\n          (fun x hx => (hf' x hx.1).mono inter_subset_left) (hf.mono inter_subset_left)\n      have : Î¼ (u n) < âˆ :=\n        lt_of_le_of_lt (measure_mono (disjointed_subset _ _)) (measure_spanningSets_lt_top Î¼ n)\n      exact ne_of_lt (lt_of_le_of_lt (measure_mono inter_subset_right) this)\n    _ = Î¼ (f '' s) := by\n      conv_rhs => rw [A, image_iUnion]\n      rw [measure_iUnion]\n      Â· intro i j hij\n        apply Disjoint.image _ hf inter_subset_left inter_subset_left\n        exact\n          Disjoint.mono inter_subset_right inter_subset_right\n            (disjoint_disjointed _ hij)\n      Â· intro i\n        exact\n          measurable_image_of_fderivWithin (hs.inter (u_meas i))\n            (fun x hx => (hf' x hx.1).mono inter_subset_left)\n            (hf.mono inter_subset_left)\n\n"}
{"name":"MeasureTheory.lintegral_abs_det_fderiv_eq_addHaar_image","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENNReal.ofReal (abs (f' x).det)) (Î¼ (Set.image f s))","decl":"/-- Change of variable formula for differentiable functions, set version: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the measure of `f '' s` is given by the\nintegral of `|(f' x).det|` on `s`.\nNote that the measurability of `f '' s` is given by `measurable_image_of_fderivWithin`. -/\ntheorem lintegral_abs_det_fderiv_eq_addHaar_image (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    (âˆ«â» x in s, ENNReal.ofReal |(f' x).det| âˆ‚Î¼) = Î¼ (f '' s) :=\n  le_antisymm (lintegral_abs_det_fderiv_le_addHaar_image Î¼ hs hf' hf)\n    (addHaar_image_le_lintegral_abs_det_fderiv Î¼ hs hf')\n\n"}
{"name":"MeasureTheory.map_withDensity_abs_det_fderiv_eq_addHaar","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nh'f : Measurable f\nâŠ¢ Eq (MeasureTheory.Measure.map f ((Î¼.restrict s).withDensity fun x => ENNReal.ofReal (abs (f' x).det))) (Î¼.restrict (Set.image f s))","decl":"/-- Change of variable formula for differentiable functions, set version: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the pushforward of the measure with\ndensity `|(f' x).det|` on `s` is the Lebesgue measure on the image set. This version requires\nthat `f` is measurable, as otherwise `Measure.map f` is zero per our definitions.\nFor a version without measurability assumption but dealing with the restricted\nfunction `s.restrict f`, see `restrict_map_withDensity_abs_det_fderiv_eq_addHaar`.\n-/\ntheorem map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (h'f : Measurable f) :\n    Measure.map f ((Î¼.restrict s).withDensity fun x => ENNReal.ofReal |(f' x).det|) =\n      Î¼.restrict (f '' s) := by\n  apply Measure.ext fun t ht => ?_\n  rw [map_apply h'f ht, withDensity_apply _ (h'f ht), Measure.restrict_apply ht,\n    restrict_restrict (h'f ht),\n    lintegral_abs_det_fderiv_eq_addHaar_image Î¼ ((h'f ht).inter hs)\n      (fun x hx => (hf' x hx.2).mono inter_subset_right) (hf.mono inter_subset_right),\n    image_preimage_inter]\n\n"}
{"name":"MeasureTheory.restrict_map_withDensity_abs_det_fderiv_eq_addHaar","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\nâŠ¢ Eq (MeasureTheory.Measure.map (s.restrict f) (MeasureTheory.Measure.comap Subtype.val (Î¼.withDensity fun x => ENNReal.ofReal (abs (f' x).det)))) (Î¼.restrict (Set.image f s))","decl":"/-- Change of variable formula for differentiable functions, set version: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the pushforward of the measure with\ndensity `|(f' x).det|` on `s` is the Lebesgue measure on the image set. This version is expressed\nin terms of the restricted function `s.restrict f`.\nFor a version for the original function, but with a measurability assumption,\nsee `map_withDensity_abs_det_fderiv_eq_addHaar`.\n-/\ntheorem restrict_map_withDensity_abs_det_fderiv_eq_addHaar (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) :\n    Measure.map (s.restrict f) (comap (â†‘) (Î¼.withDensity fun x => ENNReal.ofReal |(f' x).det|)) =\n      Î¼.restrict (f '' s) := by\n  obtain âŸ¨u, u_meas, ufâŸ© : âˆƒ u, Measurable u âˆ§ EqOn u f s := by\n    classical\n    refine âŸ¨piecewise s f 0, ?_, piecewise_eqOn _ _ _âŸ©\n    refine ContinuousOn.measurable_piecewise ?_ continuous_zero.continuousOn hs\n    have : DifferentiableOn â„ f s := fun x hx => (hf' x hx).differentiableWithinAt\n    exact this.continuousOn\n  have u' : âˆ€ x âˆˆ s, HasFDerivWithinAt u (f' x) s x := fun x hx =>\n    (hf' x hx).congr (fun y hy => uf hy) (uf hx)\n  set F : s â†’ E := u âˆ˜ (â†‘) with hF\n  have A :\n    Measure.map F (comap (â†‘) (Î¼.withDensity fun x => ENNReal.ofReal |(f' x).det|)) =\n      Î¼.restrict (u '' s) := by\n    rw [hF, â† Measure.map_map u_meas measurable_subtype_coe, map_comap_subtype_coe hs,\n      restrict_withDensity hs]\n    exact map_withDensity_abs_det_fderiv_eq_addHaar Î¼ hs u' (hf.congr uf.symm) u_meas\n  rw [uf.image_eq] at A\n  have : F = s.restrict f := by\n    ext x\n    exact uf x.2\n  rwa [this] at A\n\n"}
{"name":"MeasureTheory.lintegral_image_eq_lintegral_abs_det_fderiv_mul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\ng : E â†’ ENNReal\nâŠ¢ Eq (MeasureTheory.lintegral (Î¼.restrict (Set.image f s)) fun x => g x) (MeasureTheory.lintegral (Î¼.restrict s) fun x => HMul.hMul (ENNReal.ofReal (abs (f' x).det)) (g (f x)))","decl":"theorem lintegral_image_eq_lintegral_abs_det_fderiv_mul (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (g : E â†’ â„â‰¥0âˆ) :\n    âˆ«â» x in f '' s, g x âˆ‚Î¼ = âˆ«â» x in s, ENNReal.ofReal |(f' x).det| * g (f x) âˆ‚Î¼ := by\n  rw [â† restrict_map_withDensity_abs_det_fderiv_eq_addHaar Î¼ hs hf' hf,\n    (measurableEmbedding_of_fderivWithin hs hf' hf).lintegral_map]\n  simp only [Set.restrict_apply, â† Function.comp_apply (f := g)]\n  rw [â† (MeasurableEmbedding.subtype_coe hs).lintegral_map, map_comap_subtype_coe hs,\n    setLIntegral_withDensity_eq_setLIntegral_mul_non_measurableâ‚€ _ _ _ hs]\n  Â· simp only [Pi.mul_apply]\n  Â· simp only [eventually_true, ENNReal.ofReal_lt_top]\n  Â· exact aemeasurable_ofReal_abs_det_fderivWithin Î¼ hs hf'\n\n"}
{"name":"MeasureTheory.integrableOn_image_iff_integrableOn_abs_det_fderiv_smul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\ng : E â†’ F\nâŠ¢ Iff (MeasureTheory.IntegrableOn g (Set.image f s) Î¼) (MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (abs (f' x).det) (g (f x))) s Î¼)","decl":"/-- Integrability in the change of variable formula for differentiable functions: if a\nfunction `f` is injective and differentiable on a measurable set `s`, then a function\n`g : E â†’ F` is integrable on `f '' s` if and only if `|(f' x).det| â€¢ g âˆ˜ f` is\nintegrable on `s`. -/\ntheorem integrableOn_image_iff_integrableOn_abs_det_fderiv_smul (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (g : E â†’ F) :\n    IntegrableOn g (f '' s) Î¼ â†” IntegrableOn (fun x => |(f' x).det| â€¢ g (f x)) s Î¼ := by\n  rw [IntegrableOn, â† restrict_map_withDensity_abs_det_fderiv_eq_addHaar Î¼ hs hf' hf,\n    (measurableEmbedding_of_fderivWithin hs hf' hf).integrable_map_iff]\n  simp only [Set.restrict_eq, â† Function.comp_assoc, ENNReal.ofReal]\n  rw [â† (MeasurableEmbedding.subtype_coe hs).integrable_map_iff, map_comap_subtype_coe hs,\n    restrict_withDensity hs, integrable_withDensity_iff_integrable_coe_smulâ‚€]\n  Â· simp_rw [IntegrableOn, Real.coe_toNNReal _ (abs_nonneg _), Function.comp_apply]\n  Â· exact aemeasurable_toNNReal_abs_det_fderivWithin Î¼ hs hf'\n\n"}
{"name":"MeasureTheory.integral_image_eq_integral_abs_det_fderiv_smul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\ng : E â†’ F\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict (Set.image f s)) fun x => g x) (MeasureTheory.integral (Î¼.restrict s) fun x => HSMul.hSMul (abs (f' x).det) (g (f x)))","decl":"/-- Change of variable formula for differentiable functions: if a function `f` is\ninjective and differentiable on a measurable set `s`, then the Bochner integral of a function\n`g : E â†’ F` on `f '' s` coincides with the integral of `|(f' x).det| â€¢ g âˆ˜ f` on `s`. -/\ntheorem integral_image_eq_integral_abs_det_fderiv_smul (hs : MeasurableSet s)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) (hf : InjOn f s) (g : E â†’ F) :\n    âˆ« x in f '' s, g x âˆ‚Î¼ = âˆ« x in s, |(f' x).det| â€¢ g (f x) âˆ‚Î¼ := by\n  rw [â† restrict_map_withDensity_abs_det_fderiv_eq_addHaar Î¼ hs hf' hf,\n    (measurableEmbedding_of_fderivWithin hs hf' hf).integral_map]\n  simp only [Set.restrict_apply, â† Function.comp_apply (f := g), ENNReal.ofReal]\n  rw [â† (MeasurableEmbedding.subtype_coe hs).integral_map, map_comap_subtype_coe hs,\n    setIntegral_withDensity_eq_setIntegral_smulâ‚€\n      (aemeasurable_toNNReal_abs_det_fderivWithin Î¼ hs hf') _ hs]\n  congr with x\n  rw [NNReal.smul_def, Real.coe_toNNReal _ (abs_nonneg (f' x).det)]\n\n-- Porting note: move this to `Topology.Algebra.Module.Basic` when port is over\n"}
{"name":"MeasureTheory.det_one_smulRight","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"ğ•œ : Type u_3\ninstâœÂ² : CommRing ğ•œ\ninstâœÂ¹ : TopologicalSpace ğ•œ\ninstâœ : ContinuousMul ğ•œ\nv : ğ•œ\nâŠ¢ Eq (ContinuousLinearMap.smulRight 1 v).det v","decl":"theorem det_one_smulRight {ğ•œ : Type*} [CommRing ğ•œ] [TopologicalSpace ğ•œ] [ContinuousMul ğ•œ] (v : ğ•œ) :\n    ((1 : ğ•œ â†’L[ğ•œ] ğ•œ).smulRight v).det = v := by\n  nontriviality ğ•œ\n  have : (1 : ğ•œ â†’L[ğ•œ] ğ•œ).smulRight v = v â€¢ (1 : ğ•œ â†’L[ğ•œ] ğ•œ) := by\n    ext1\n    simp only [ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.one_apply,\n      Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.coe_smul', Pi.smul_apply, mul_one]\n  rw [this, ContinuousLinearMap.det, ContinuousLinearMap.coe_smul,\n    ContinuousLinearMap.one_def, ContinuousLinearMap.coe_id, LinearMap.det_smul,\n    Module.finrank_self, LinearMap.det_id, pow_one, mul_one]\n\n"}
{"name":"MeasureTheory.integrableOn_image_iff_integrableOn_abs_deriv_smul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ns : Set Real\nf f' : Real â†’ Real\nhs : MeasurableSet s\nhf' : âˆ€ (x : Real), Membership.mem s x â†’ HasDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\ng : Real â†’ F\nâŠ¢ Iff (MeasureTheory.IntegrableOn g (Set.image f s) MeasureTheory.MeasureSpace.volume) (MeasureTheory.IntegrableOn (fun x => HSMul.hSMul (abs (f' x)) (g (f x))) s MeasureTheory.MeasureSpace.volume)","decl":"/-- Integrability in the change of variable formula for differentiable functions (one-variable\nversion): if a function `f` is injective and differentiable on a measurable set `s âŠ† â„`, then a\nfunction `g : â„ â†’ F` is integrable on `f '' s` if and only if `|(f' x)| â€¢ g âˆ˜ f` is integrable on\n`s`. -/\ntheorem integrableOn_image_iff_integrableOn_abs_deriv_smul {s : Set â„} {f : â„ â†’ â„} {f' : â„ â†’ â„}\n    (hs : MeasurableSet s) (hf' : âˆ€ x âˆˆ s, HasDerivWithinAt f (f' x) s x) (hf : InjOn f s)\n    (g : â„ â†’ F) : IntegrableOn g (f '' s) â†” IntegrableOn (fun x => |f' x| â€¢ g (f x)) s := by\n  simpa only [det_one_smulRight] using\n    integrableOn_image_iff_integrableOn_abs_det_fderiv_smul volume hs\n      (fun x hx => (hf' x hx).hasFDerivWithinAt) hf g\n\n"}
{"name":"MeasureTheory.integral_image_eq_integral_abs_deriv_smul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"F : Type u_2\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\ns : Set Real\nf f' : Real â†’ Real\nhs : MeasurableSet s\nhf' : âˆ€ (x : Real), Membership.mem s x â†’ HasDerivWithinAt f (f' x) s x\nhf : Set.InjOn f s\ng : Real â†’ F\nâŠ¢ Eq (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.image f s)) fun x => g x) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HSMul.hSMul (abs (f' x)) (g (f x)))","decl":"/-- Change of variable formula for differentiable functions (one-variable version): if a function\n`f` is injective and differentiable on a measurable set `s âŠ† â„`, then the Bochner integral of a\nfunction `g : â„ â†’ F` on `f '' s` coincides with the integral of `|(f' x)| â€¢ g âˆ˜ f` on `s`. -/\ntheorem integral_image_eq_integral_abs_deriv_smul {s : Set â„} {f : â„ â†’ â„} {f' : â„ â†’ â„}\n    (hs : MeasurableSet s) (hf' : âˆ€ x âˆˆ s, HasDerivWithinAt f (f' x) s x)\n    (hf : InjOn f s) (g : â„ â†’ F) : âˆ« x in f '' s, g x = âˆ« x in s, |f' x| â€¢ g (f x) := by\n  simpa only [det_one_smulRight] using\n    integral_image_eq_integral_abs_det_fderiv_smul volume hs\n      (fun x hx => (hf' x hx).hasFDerivWithinAt) hf g\n\n"}
{"name":"MeasureTheory.integral_target_eq_integral_abs_det_fderiv_smul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\nF : Type u_2\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace Real E\ninstâœâµ : FiniteDimensional Real E\ninstâœâ´ : NormedAddCommGroup F\ninstâœÂ³ : NormedSpace Real F\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nf : PartialHomeomorph E E\nhf' : âˆ€ (x : E), Membership.mem f.source x â†’ HasFDerivAt (â†‘f) (f' x) x\ng : E â†’ F\nâŠ¢ Eq (MeasureTheory.integral (Î¼.restrict f.target) fun x => g x) (MeasureTheory.integral (Î¼.restrict f.source) fun x => HSMul.hSMul (abs (f' x).det) (g (â†‘f x)))","decl":"theorem integral_target_eq_integral_abs_det_fderiv_smul {f : PartialHomeomorph E E}\n    (hf' : âˆ€ x âˆˆ f.source, HasFDerivAt f (f' x) x) (g : E â†’ F) :\n    âˆ« x in f.target, g x âˆ‚Î¼ = âˆ« x in f.source, |(f' x).det| â€¢ g (f x) âˆ‚Î¼ := by\n  have : f '' f.source = f.target := PartialEquiv.image_source_eq_target f.toPartialEquiv\n  rw [â† this]\n  apply integral_image_eq_integral_abs_det_fderiv_smul Î¼ f.open_source.measurableSet _ f.injOn\n  intro x hx\n  exact (hf' x hx).hasFDerivWithinAt\n\n"}
{"name":"MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_det_fderiv_mul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf : E â†’ E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nhf : MeasurableEmbedding f\ng : E â†’ Real\nhg : Filter.Eventually (fun x => Membership.mem (Set.image f s) x â†’ LE.le 0 (g x)) (MeasureTheory.ae Î¼)\nhg_int : MeasureTheory.IntegrableOn g (Set.image f s) Î¼\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt f (f' x) s x\nâŠ¢ Eq ((MeasureTheory.Measure.comap f (Î¼.withDensity fun x => ENNReal.ofReal (g x))) s) (ENNReal.ofReal (MeasureTheory.integral (Î¼.restrict s) fun x => HMul.hMul (abs (f' x).det) (g (f x))))","decl":"lemma _root_.MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_det_fderiv_mul\n    (hs : MeasurableSet s) (hf : MeasurableEmbedding f)\n    {g : E â†’ â„} (hg : âˆ€áµ x âˆ‚Î¼, x âˆˆ f '' s â†’ 0 â‰¤ g x) (hg_int : IntegrableOn g (f '' s) Î¼)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) :\n    (Î¼.withDensity (fun x â†¦ ENNReal.ofReal (g x))).comap f s\n      = ENNReal.ofReal (âˆ« x in s, |(f' x).det| * g (f x) âˆ‚Î¼) := by\n  rw [Measure.comap_apply f hf.injective (fun t ht â†¦ hf.measurableSet_image' ht) _ hs,\n    withDensity_apply _ (hf.measurableSet_image' hs),\n    â† ofReal_integral_eq_lintegral_ofReal hg_int\n      ((ae_restrict_iff' (hf.measurableSet_image' hs)).mpr hg),\n    integral_image_eq_integral_abs_det_fderiv_smul Î¼ hs hf' hf.injective.injOn]\n  simp_rw [smul_eq_mul]\n\n"}
{"name":"MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"E : Type u_1\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : FiniteDimensional Real E\ns : Set E\nf' : E â†’ ContinuousLinearMap (RingHom.id Real) E E\ninstâœÂ² : MeasurableSpace E\ninstâœÂ¹ : BorelSpace E\nÎ¼ : MeasureTheory.Measure E\ninstâœ : Î¼.IsAddHaarMeasure\nhs : MeasurableSet s\nf : MeasurableEquiv E E\ng : E â†’ Real\nhg : Filter.Eventually (fun x => Membership.mem (Set.image (â‡‘f) s) x â†’ LE.le 0 (g x)) (MeasureTheory.ae Î¼)\nhg_int : MeasureTheory.IntegrableOn g (Set.image (â‡‘f) s) Î¼\nhf' : âˆ€ (x : E), Membership.mem s x â†’ HasFDerivWithinAt (â‡‘f) (f' x) s x\nâŠ¢ Eq ((MeasureTheory.Measure.map (â‡‘f.symm) (Î¼.withDensity fun x => ENNReal.ofReal (g x))) s) (ENNReal.ofReal (MeasureTheory.integral (Î¼.restrict s) fun x => HMul.hMul (abs (f' x).det) (g (f x))))","decl":"lemma _root_.MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul\n    (hs : MeasurableSet s) (f : E â‰ƒáµ E)\n    {g : E â†’ â„} (hg : âˆ€áµ x âˆ‚Î¼, x âˆˆ f '' s â†’ 0 â‰¤ g x) (hg_int : IntegrableOn g (f '' s) Î¼)\n    (hf' : âˆ€ x âˆˆ s, HasFDerivWithinAt f (f' x) s x) :\n    (Î¼.withDensity (fun x â†¦ ENNReal.ofReal (g x))).map f.symm s\n      = ENNReal.ofReal (âˆ« x in s, |(f' x).det| * g (f x) âˆ‚Î¼) := by\n  rw [MeasurableEquiv.map_symm,\n    MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_det_fderiv_mul Î¼ hs\n      f.measurableEmbedding hg hg_int hf']\n\n"}
{"name":"MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"f : Real â†’ Real\nhf : MeasurableEmbedding f\ns : Set Real\nhs : MeasurableSet s\ng : Real â†’ Real\nhg : Filter.Eventually (fun x => Membership.mem (Set.image f s) x â†’ LE.le 0 (g x)) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)\nhg_int : MeasureTheory.IntegrableOn g (Set.image f s) MeasureTheory.MeasureSpace.volume\nf' : Real â†’ Real\nhf' : âˆ€ (x : Real), Membership.mem s x â†’ HasDerivWithinAt f (f' x) s x\nâŠ¢ Eq ((MeasureTheory.Measure.comap f (MeasureTheory.MeasureSpace.volume.withDensity fun x => ENNReal.ofReal (g x))) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HMul.hMul (abs (f' x)) (g (f x))))","decl":"lemma _root_.MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul\n    {f : â„ â†’ â„} (hf : MeasurableEmbedding f) {s : Set â„} (hs : MeasurableSet s)\n    {g : â„ â†’ â„} (hg : âˆ€áµ x, x âˆˆ f '' s â†’ 0 â‰¤ g x) (hg_int : IntegrableOn g (f '' s))\n    {f' : â„ â†’ â„} (hf' : âˆ€ x âˆˆ s, HasDerivWithinAt f (f' x) s x) :\n    (volume.withDensity (fun x â†¦ ENNReal.ofReal (g x))).comap f s\n      = ENNReal.ofReal (âˆ« x in s, |f' x| * g (f x)) := by\n  rw [hf.withDensity_ofReal_comap_apply_eq_integral_abs_det_fderiv_mul volume hs\n    hg hg_int hf']\n  simp only [det_one_smulRight]\n\n"}
{"name":"MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"f : MeasurableEquiv Real Real\ns : Set Real\nhs : MeasurableSet s\ng : Real â†’ Real\nhg : Filter.Eventually (fun x => Membership.mem (Set.image (â‡‘f) s) x â†’ LE.le 0 (g x)) (MeasureTheory.ae MeasureTheory.MeasureSpace.volume)\nhg_int : MeasureTheory.IntegrableOn g (Set.image (â‡‘f) s) MeasureTheory.MeasureSpace.volume\nf' : Real â†’ Real\nhf' : âˆ€ (x : Real), Membership.mem s x â†’ HasDerivWithinAt (â‡‘f) (f' x) s x\nâŠ¢ Eq ((MeasureTheory.Measure.map (â‡‘f.symm) (MeasureTheory.MeasureSpace.volume.withDensity fun x => ENNReal.ofReal (g x))) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HMul.hMul (abs (f' x)) (g (f x))))","decl":"lemma _root_.MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul\n    (f : â„ â‰ƒáµ â„) {s : Set â„} (hs : MeasurableSet s)\n    {g : â„ â†’ â„} (hg : âˆ€áµ x, x âˆˆ f '' s â†’ 0 â‰¤ g x) (hg_int : IntegrableOn g (f '' s))\n    {f' : â„ â†’ â„} (hf' : âˆ€ x âˆˆ s, HasDerivWithinAt f (f' x) s x) :\n    (volume.withDensity (fun x â†¦ ENNReal.ofReal (g x))).map f.symm s\n      = ENNReal.ofReal (âˆ« x in s, |f' x| * g (f x)) := by\n  rw [MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul volume hs\n      f hg hg_int hf']\n  simp only [det_one_smulRight]\n\n"}
{"name":"MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul'","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"f : Real â†’ Real\nhf : MeasurableEmbedding f\ns : Set Real\nhs : MeasurableSet s\nf' : Real â†’ Real\nhf' : âˆ€ (x : Real), HasDerivAt f (f' x) x\ng : Real â†’ Real\nhg : (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyLE 0 g\nhg_int : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((MeasureTheory.Measure.comap f (MeasureTheory.MeasureSpace.volume.withDensity fun x => ENNReal.ofReal (g x))) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HMul.hMul (abs (f' x)) (g (f x))))","decl":"lemma _root_.MeasurableEmbedding.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul'\n    {f : â„ â†’ â„} (hf : MeasurableEmbedding f) {s : Set â„} (hs : MeasurableSet s)\n    {f' : â„ â†’ â„} (hf' : âˆ€ x, HasDerivAt f (f' x) x)\n    {g : â„ â†’ â„} (hg : 0 â‰¤áµ[volume] g) (hg_int : Integrable g) :\n    (volume.withDensity (fun x â†¦ ENNReal.ofReal (g x))).comap f s\n      = ENNReal.ofReal (âˆ« x in s, |f' x| * g (f x)) :=\n  hf.withDensity_ofReal_comap_apply_eq_integral_abs_deriv_mul hs\n    (by filter_upwards [hg] with x hx using fun _ â†¦ hx) hg_int.integrableOn\n    (fun x _ => (hf' x).hasDerivWithinAt)\n\n"}
{"name":"MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul'","module":"Mathlib.MeasureTheory.Function.Jacobian","initialProofState":"f : MeasurableEquiv Real Real\ns : Set Real\nhs : MeasurableSet s\nf' : Real â†’ Real\nhf' : âˆ€ (x : Real), HasDerivAt (â‡‘f) (f' x) x\ng : Real â†’ Real\nhg : (MeasureTheory.ae MeasureTheory.MeasureSpace.volume).EventuallyLE 0 g\nhg_int : MeasureTheory.Integrable g MeasureTheory.MeasureSpace.volume\nâŠ¢ Eq ((MeasureTheory.Measure.map (â‡‘f.symm) (MeasureTheory.MeasureSpace.volume.withDensity fun x => ENNReal.ofReal (g x))) s) (ENNReal.ofReal (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict s) fun x => HMul.hMul (abs (f' x)) (g (f x))))","decl":"lemma _root_.MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_deriv_mul'\n    (f : â„ â‰ƒáµ â„) {s : Set â„} (hs : MeasurableSet s)\n    {f' : â„ â†’ â„} (hf' : âˆ€ x, HasDerivAt f (f' x) x)\n    {g : â„ â†’ â„} (hg : 0 â‰¤áµ[volume] g) (hg_int : Integrable g) :\n    (volume.withDensity (fun x â†¦ ENNReal.ofReal (g x))).map f.symm s\n      = ENNReal.ofReal (âˆ« x in s, |f' x| * g (f x)) := by\n  rw [MeasurableEquiv.withDensity_ofReal_map_symm_apply_eq_integral_abs_det_fderiv_mul volume hs\n      f (by filter_upwards [hg] with x hx using fun _ â†¦ hx) hg_int.integrableOn\n      (fun x _ => (hf' x).hasDerivWithinAt)]\n  simp only [det_one_smulRight]\n\n"}
