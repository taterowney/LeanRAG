{"name":"ProbabilityTheory.Kernel.mk.inj","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ntoFun✝ : α → MeasureTheory.Measure β\nmeasurable'✝ : Measurable toFun✝\ntoFun : α → MeasureTheory.Measure β\nmeasurable' : Measurable toFun\nx✝ : Eq { toFun := toFun✝, measurable' := measurable'✝ } { toFun := toFun, measurable' := measurable' }\n⊢ Eq toFun✝ toFun","decl":"/-- A kernel from a measurable space `α` to another measurable space `β` is a measurable function\n`κ : α → Measure β`. The measurable space structure on `MeasureTheory.Measure β` is given by\n`MeasureTheory.Measure.instMeasurableSpace`. A map `κ : α → MeasureTheory.Measure β` is measurable\niff `∀ s : Set β, MeasurableSet s → Measurable (fun a ↦ κ a s)`. -/\nstructure Kernel (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] where\n  /-- The underlying function of a kernel.\n\n  Do not use this function directly. Instead use the coercion coming from the `DFunLike`\n  instance. -/\n  toFun : α → Measure β\n  /-- A kernel is a measurable map.\n\n  Do not use this lemma directly. Use `Kernel.measurable` instead. -/\n  measurable' : Measurable toFun\n\n"}
{"name":"ProbabilityTheory.Kernel.mk.injEq","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\ntoFun✝ : α → MeasureTheory.Measure β\nmeasurable'✝ : Measurable toFun✝\ntoFun : α → MeasureTheory.Measure β\nmeasurable' : Measurable toFun\n⊢ Eq (Eq { toFun := toFun✝, measurable' := measurable'✝ } { toFun := toFun, measurable' := measurable' }) (Eq toFun✝ toFun)","decl":"/-- A kernel from a measurable space `α` to another measurable space `β` is a measurable function\n`κ : α → Measure β`. The measurable space structure on `MeasureTheory.Measure β` is given by\n`MeasureTheory.Measure.instMeasurableSpace`. A map `κ : α → MeasureTheory.Measure β` is measurable\niff `∀ s : Set β, MeasurableSet s → Measurable (fun a ↦ κ a s)`. -/\nstructure Kernel (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] where\n  /-- The underlying function of a kernel.\n\n  Do not use this function directly. Instead use the coercion coming from the `DFunLike`\n  instance. -/\n  toFun : α → Measure β\n  /-- A kernel is a measurable map.\n\n  Do not use this lemma directly. Use `Kernel.measurable` instead. -/\n  measurable' : Measurable toFun\n\n"}
{"name":"ProbabilityTheory.Kernel.mk.sizeOf_spec","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : MeasurableSpace α\ninst✝² : MeasurableSpace β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → MeasureTheory.Measure β\nmeasurable' : Measurable toFun\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, measurable' := measurable' }) 1","decl":"/-- A kernel from a measurable space `α` to another measurable space `β` is a measurable function\n`κ : α → Measure β`. The measurable space structure on `MeasureTheory.Measure β` is given by\n`MeasureTheory.Measure.instMeasurableSpace`. A map `κ : α → MeasureTheory.Measure β` is measurable\niff `∀ s : Set β, MeasurableSet s → Measurable (fun a ↦ κ a s)`. -/\nstructure Kernel (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] where\n  /-- The underlying function of a kernel.\n\n  Do not use this function directly. Instead use the coercion coming from the `DFunLike`\n  instance. -/\n  toFun : α → Measure β\n  /-- A kernel is a measurable map.\n\n  Do not use this lemma directly. Use `Kernel.measurable` instead. -/\n  measurable' : Measurable toFun\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable'","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\nself : ProbabilityTheory.Kernel α β\n⊢ Measurable self.toFun","decl":"/-- A kernel from a measurable space `α` to another measurable space `β` is a measurable function\n`κ : α → Measure β`. The measurable space structure on `MeasureTheory.Measure β` is given by\n`MeasureTheory.Measure.instMeasurableSpace`. A map `κ : α → MeasureTheory.Measure β` is measurable\niff `∀ s : Set β, MeasurableSet s → Measurable (fun a ↦ κ a s)`. -/\nstructure Kernel (α β : Type*) [MeasurableSpace α] [MeasurableSpace β] where\n  /-- The underlying function of a kernel.\n\n  Do not use this function directly. Instead use the coercion coming from the `DFunLike`\n  instance. -/\n  toFun : α → Measure β\n  /-- A kernel is a measurable map.\n\n  Do not use this lemma directly. Use `Kernel.measurable` instead. -/\n  measurable' : Measurable toFun\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\n⊢ Measurable ⇑κ","decl":"lemma measurable (κ : Kernel α β) : Measurable κ := κ.measurable'\n"}
{"name":"ProbabilityTheory.Kernel.coe_mk","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → MeasureTheory.Measure β\nhf : Measurable f\n⊢ Eq (⇑{ toFun := f, measurable' := hf }) f","decl":"@[simp, norm_cast] lemma coe_mk (f : α → Measure β) (hf) : mk f hf = f := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.coe_zero","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\n⊢ Eq (⇑0) 0","decl":"@[simp, norm_cast] lemma coe_zero : ⇑(0 : Kernel α β) = 0 := rfl\n"}
{"name":"ProbabilityTheory.Kernel.coe_add","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\n⊢ Eq (⇑(HAdd.hAdd κ η)) (HAdd.hAdd ⇑κ ⇑η)","decl":"@[simp, norm_cast] lemma coe_add (κ η : Kernel α β) : ⇑(κ + η) = κ + η := rfl\n"}
{"name":"ProbabilityTheory.Kernel.coe_nsmul","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nn : Nat\nκ : ProbabilityTheory.Kernel α β\n⊢ Eq (⇑(HSMul.hSMul n κ)) (HSMul.hSMul n ⇑κ)","decl":"@[simp, norm_cast] lemma coe_nsmul (n : ℕ) (κ : Kernel α β) : ⇑(n • κ) = n • κ := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.zero_apply","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\na : α\n⊢ Eq (0 a) 0","decl":"@[simp] lemma zero_apply (a : α) : (0 : Kernel α β) a = 0 := rfl\n"}
{"name":"ProbabilityTheory.Kernel.add_apply","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\na : α\n⊢ Eq ((HAdd.hAdd κ η) a) (HAdd.hAdd (κ a) (η a))","decl":"@[simp] lemma add_apply (κ η : Kernel α β) (a : α) : (κ + η) a = κ a + η a := rfl\n"}
{"name":"ProbabilityTheory.Kernel.nsmul_apply","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nn : Nat\nκ : ProbabilityTheory.Kernel α β\na : α\n⊢ Eq ((HSMul.hSMul n κ) a) (HSMul.hSMul n (κ a))","decl":"@[simp] lemma nsmul_apply (n : ℕ) (κ : Kernel α β) (a : α) : (n • κ) a = n • κ a := rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.instCovariantAddLE","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_4\nβ : Type u_5\ninst✝¹ : MeasurableSpace α\ninst✝ : MeasurableSpace β\n⊢ CovariantClass (ProbabilityTheory.Kernel α β) (ProbabilityTheory.Kernel α β) (fun x1 x2 => HAdd.hAdd x1 x2) fun x1 x2 => LE.le x1 x2","decl":"instance instCovariantAddLE {α β : Type*} [MeasurableSpace α] [MeasurableSpace β] :\n    CovariantClass (Kernel α β) (Kernel α β) (· + ·) (· ≤ ·) :=\n  ⟨fun _ _ _ hμ a ↦ add_le_add_left (hμ a) _⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.coe_finset_sum","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nI : Finset ι\nκ : ι → ProbabilityTheory.Kernel α β\n⊢ Eq (⇑(I.sum fun i => κ i)) (I.sum fun i => ⇑(κ i))","decl":"@[simp]\ntheorem coe_finset_sum (I : Finset ι) (κ : ι → Kernel α β) : ⇑(∑ i ∈ I, κ i) = ∑ i ∈ I, ⇑(κ i) :=\n  map_sum (coeAddHom α β) _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.finset_sum_apply","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nI : Finset ι\nκ : ι → ProbabilityTheory.Kernel α β\na : α\n⊢ Eq ((I.sum fun i => κ i) a) (I.sum fun i => (κ i) a)","decl":"theorem finset_sum_apply (I : Finset ι) (κ : ι → Kernel α β) (a : α) :\n    (∑ i ∈ I, κ i) a = ∑ i ∈ I, κ i a := by rw [coe_finset_sum, Finset.sum_apply]\n\n"}
{"name":"ProbabilityTheory.Kernel.finset_sum_apply'","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nI : Finset ι\nκ : ι → ProbabilityTheory.Kernel α β\na : α\ns : Set β\n⊢ Eq (((I.sum fun i => κ i) a) s) (I.sum fun i => ((κ i) a) s)","decl":"theorem finset_sum_apply' (I : Finset ι) (κ : ι → Kernel α β) (a : α) (s : Set β) :\n    (∑ i ∈ I, κ i) a s = ∑ i ∈ I, κ i a s := by rw [finset_sum_apply, Measure.finset_sum_apply]\n\n"}
{"name":"ProbabilityTheory.IsMarkovKernel.isProbabilityMeasure","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nself : ProbabilityTheory.IsMarkovKernel κ\na : α\n⊢ MeasureTheory.IsProbabilityMeasure (κ a)","decl":"/-- A kernel is a Markov kernel if every measure in its image is a probability measure. -/\nclass IsMarkovKernel (κ : Kernel α β) : Prop where\n  isProbabilityMeasure : ∀ a, IsProbabilityMeasure (κ a)\n\n"}
{"name":"ProbabilityTheory.IsZeroOrMarkovKernel.eq_zero_or_isMarkovKernel'","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nself : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ Or (Eq κ 0) (ProbabilityTheory.IsMarkovKernel κ)","decl":"/-- A class for kernels which are zero or a Markov kernel. -/\nclass IsZeroOrMarkovKernel (κ : Kernel α β) : Prop where\n  eq_zero_or_isMarkovKernel' : κ = 0 ∨ IsMarkovKernel κ\n\n"}
{"name":"ProbabilityTheory.IsFiniteKernel.exists_univ_le","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nself : ProbabilityTheory.IsFiniteKernel κ\n⊢ Exists fun C => And (LT.lt C Top.top) (∀ (a : α), LE.le ((κ a) Set.univ) C)","decl":"/-- A kernel is finite if every measure in its image is finite, with a uniform bound. -/\nclass IsFiniteKernel (κ : Kernel α β) : Prop where\n  exists_univ_le : ∃ C : ℝ≥0∞, C < ∞ ∧ ∀ a, κ a Set.univ ≤ C\n\n"}
{"name":"ProbabilityTheory.eq_zero_or_isMarkovKernel","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ Or (Eq κ 0) (ProbabilityTheory.IsMarkovKernel κ)","decl":"theorem eq_zero_or_isMarkovKernel\n    (κ : Kernel α β) [h : IsZeroOrMarkovKernel κ] :\n    κ = 0 ∨ IsMarkovKernel κ :=\n  h.eq_zero_or_isMarkovKernel'\n\n"}
{"name":"ProbabilityTheory.IsFiniteKernel.bound_lt_top","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsFiniteKernel κ\n⊢ LT.lt (ProbabilityTheory.IsFiniteKernel.bound κ) Top.top","decl":"theorem IsFiniteKernel.bound_lt_top (κ : Kernel α β) [h : IsFiniteKernel κ] :\n    IsFiniteKernel.bound κ < ∞ :=\n  h.exists_univ_le.choose_spec.1\n\n"}
{"name":"ProbabilityTheory.IsFiniteKernel.bound_ne_top","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\n⊢ Ne (ProbabilityTheory.IsFiniteKernel.bound κ) Top.top","decl":"theorem IsFiniteKernel.bound_ne_top (κ : Kernel α β) [IsFiniteKernel κ] :\n    IsFiniteKernel.bound κ ≠ ∞ :=\n  (IsFiniteKernel.bound_lt_top κ).ne\n\n"}
{"name":"ProbabilityTheory.Kernel.measure_le_bound","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsFiniteKernel κ\na : α\ns : Set β\n⊢ LE.le ((κ a) s) (ProbabilityTheory.IsFiniteKernel.bound κ)","decl":"theorem Kernel.measure_le_bound (κ : Kernel α β) [h : IsFiniteKernel κ] (a : α) (s : Set β) :\n    κ a s ≤ IsFiniteKernel.bound κ :=\n  (measure_mono (Set.subset_univ s)).trans (h.exists_univ_le.choose_spec.2 a)\n\n"}
{"name":"ProbabilityTheory.isFiniteKernel_zero","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_4\nβ : Type u_5\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace β\n⊢ ProbabilityTheory.IsFiniteKernel 0","decl":"instance isFiniteKernel_zero (α β : Type*) {_ : MeasurableSpace α} {_ : MeasurableSpace β} :\n    IsFiniteKernel (0 : Kernel α β) :=\n  ⟨⟨0, ENNReal.coe_lt_top, fun _ => by\n      simp only [Kernel.zero_apply, Measure.coe_zero, Pi.zero_apply, le_zero_iff]⟩⟩\n\n"}
{"name":"ProbabilityTheory.IsFiniteKernel.add","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsFiniteKernel κ\ninst✝ : ProbabilityTheory.IsFiniteKernel η\n⊢ ProbabilityTheory.IsFiniteKernel (HAdd.hAdd κ η)","decl":"instance IsFiniteKernel.add (κ η : Kernel α β) [IsFiniteKernel κ] [IsFiniteKernel η] :\n    IsFiniteKernel (κ + η) := by\n  refine ⟨⟨IsFiniteKernel.bound κ + IsFiniteKernel.bound η,\n    ENNReal.add_lt_top.mpr ⟨IsFiniteKernel.bound_lt_top κ, IsFiniteKernel.bound_lt_top η⟩,\n    fun a => ?_⟩⟩\n  exact add_le_add (Kernel.measure_le_bound _ _ _) (Kernel.measure_le_bound _ _ _)\n\n"}
{"name":"ProbabilityTheory.isFiniteKernel_of_le","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ ν : ProbabilityTheory.Kernel α β\nhν : ProbabilityTheory.IsFiniteKernel ν\nhκν : LE.le κ ν\n⊢ ProbabilityTheory.IsFiniteKernel κ","decl":"lemma isFiniteKernel_of_le {κ ν : Kernel α β} [hν : IsFiniteKernel ν] (hκν : κ ≤ ν) :\n    IsFiniteKernel κ := by\n  refine ⟨hν.bound, hν.bound_lt_top, fun a ↦ (hκν _ _).trans (Kernel.measure_le_bound ν a Set.univ)⟩\n\n"}
{"name":"ProbabilityTheory.IsMarkovKernel.is_probability_measure'","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsMarkovKernel κ\na : α\n⊢ MeasureTheory.IsProbabilityMeasure (κ a)","decl":"instance IsMarkovKernel.is_probability_measure' [IsMarkovKernel κ] (a : α) :\n    IsProbabilityMeasure (κ a) :=\n  IsMarkovKernel.isProbabilityMeasure a\n\n"}
{"name":"ProbabilityTheory.instIsZeroOrMarkovKernelOfNatKernel","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel 0","decl":"instance : IsZeroOrMarkovKernel (0 : Kernel α β) := ⟨Or.inl rfl⟩\n\n"}
{"name":"ProbabilityTheory.IsMarkovKernel.IsZeroOrMarkovKernel","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsMarkovKernel κ\n⊢ ProbabilityTheory.IsZeroOrMarkovKernel κ","decl":"instance (priority := 100) IsMarkovKernel.IsZeroOrMarkovKernel [h : IsMarkovKernel κ] :\n    IsZeroOrMarkovKernel κ := ⟨Or.inr h⟩\n\n"}
{"name":"ProbabilityTheory.IsZeroOrMarkovKernel.isZeroOrProbabilityMeasure","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsZeroOrMarkovKernel κ\na : α\n⊢ MeasureTheory.IsZeroOrProbabilityMeasure (κ a)","decl":"instance (priority := 100) IsZeroOrMarkovKernel.isZeroOrProbabilityMeasure\n    [IsZeroOrMarkovKernel κ] (a : α) : IsZeroOrProbabilityMeasure (κ a) := by\n  rcases eq_zero_or_isMarkovKernel κ with rfl | h'\n  · simp only [Kernel.zero_apply]\n    infer_instance\n  · infer_instance\n\n"}
{"name":"ProbabilityTheory.IsFiniteKernel.isFiniteMeasure","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsFiniteKernel κ\na : α\n⊢ MeasureTheory.IsFiniteMeasure (κ a)","decl":"instance IsFiniteKernel.isFiniteMeasure [IsFiniteKernel κ] (a : α) : IsFiniteMeasure (κ a) :=\n  ⟨(Kernel.measure_le_bound κ a Set.univ).trans_lt (IsFiniteKernel.bound_lt_top κ)⟩\n\n"}
{"name":"ProbabilityTheory.IsZeroOrMarkovKernel.isFiniteKernel","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsZeroOrMarkovKernel κ\n⊢ ProbabilityTheory.IsFiniteKernel κ","decl":"instance (priority := 100) IsZeroOrMarkovKernel.isFiniteKernel [h : IsZeroOrMarkovKernel κ] :\n    IsFiniteKernel κ := by\n  rcases eq_zero_or_isMarkovKernel κ with rfl | _h'\n  · infer_instance\n  · exact ⟨⟨1, ENNReal.one_lt_top, fun _ => prob_le_one⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.ext","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\nh : ∀ (a : α), Eq (κ a) (η a)\n⊢ Eq κ η","decl":"@[ext]\ntheorem ext (h : ∀ a, κ a = η a) : κ = η := DFunLike.ext _ _ h\n\n"}
{"name":"ProbabilityTheory.Kernel.ext_iff","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\n⊢ Iff (Eq κ η) (∀ (a : α), Eq (κ a) (η a))","decl":"@[ext]\ntheorem ext (h : ∀ a, κ a = η a) : κ = η := DFunLike.ext _ _ h\n\n"}
{"name":"ProbabilityTheory.Kernel.ext_iff'","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\n⊢ Iff (Eq κ η) (∀ (a : α) (s : Set β), MeasurableSet s → Eq ((κ a) s) ((η a) s))","decl":"theorem ext_iff' : κ = η ↔ ∀ a s, MeasurableSet s → κ a s = η a s := by\n  simp_rw [Kernel.ext_iff, Measure.ext_iff]\n\n"}
{"name":"ProbabilityTheory.Kernel.ext_fun","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\nh : ∀ (a : α) (f : β → ENNReal), Measurable f → Eq (MeasureTheory.lintegral (κ a) fun b => f b) (MeasureTheory.lintegral (η a) fun b => f b)\n⊢ Eq κ η","decl":"theorem ext_fun (h : ∀ a f, Measurable f → ∫⁻ b, f b ∂κ a = ∫⁻ b, f b ∂η a) :\n    κ = η := by\n  ext a s hs\n  specialize h a (s.indicator fun _ => 1) (Measurable.indicator measurable_const hs)\n  simp_rw [lintegral_indicator_const hs, one_mul] at h\n  rw [h]\n\n"}
{"name":"ProbabilityTheory.Kernel.ext_fun_iff","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\n⊢ Iff (Eq κ η) (∀ (a : α) (f : β → ENNReal), Measurable f → Eq (MeasureTheory.lintegral (κ a) fun b => f b) (MeasureTheory.lintegral (η a) fun b => f b))","decl":"theorem ext_fun_iff : κ = η ↔ ∀ a f, Measurable f → ∫⁻ b, f b ∂κ a = ∫⁻ b, f b ∂η a :=\n  ⟨fun h a f _ => by rw [h], ext_fun⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.measurable_coe","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ns : Set β\nhs : MeasurableSet s\n⊢ Measurable fun a => (κ a) s","decl":"protected theorem measurable_coe (κ : Kernel α β) {s : Set β} (hs : MeasurableSet s) :\n    Measurable fun a => κ a s :=\n  (Measure.measurable_coe hs).comp κ.measurable\n\n"}
{"name":"ProbabilityTheory.Kernel.apply_congr_of_mem_measurableAtom","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ny' y : α\nhy' : Membership.mem (measurableAtom y) y'\n⊢ Eq (κ y') (κ y)","decl":"lemma apply_congr_of_mem_measurableAtom (κ : Kernel α β) {y' y : α} (hy' : y' ∈ measurableAtom y) :\n    κ y' = κ y := by\n  ext s hs\n  exact mem_of_mem_measurableAtom hy' (κ.measurable_coe hs (measurableSet_singleton (κ y s))) rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_apply","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nκ : ι → ProbabilityTheory.Kernel α β\na : α\n⊢ Eq ((ProbabilityTheory.Kernel.sum κ) a) (MeasureTheory.Measure.sum fun n => (κ n) a)","decl":"theorem sum_apply [Countable ι] (κ : ι → Kernel α β) (a : α) :\n    Kernel.sum κ a = Measure.sum fun n => κ n a :=\n  rfl\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_apply'","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nκ : ι → ProbabilityTheory.Kernel α β\na : α\ns : Set β\nhs : MeasurableSet s\n⊢ Eq (((ProbabilityTheory.Kernel.sum κ) a) s) (tsum fun n => ((κ n) a) s)","decl":"theorem sum_apply' [Countable ι] (κ : ι → Kernel α β) (a : α) {s : Set β} (hs : MeasurableSet s) :\n    Kernel.sum κ a s = ∑' n, κ n a s := by rw [sum_apply κ a, Measure.sum_apply _ hs]\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_zero","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\n⊢ Eq (ProbabilityTheory.Kernel.sum fun x => 0) 0","decl":"@[simp]\ntheorem sum_zero [Countable ι] : (Kernel.sum fun _ : ι => (0 : Kernel α β)) = 0 := by\n  ext a s hs\n  rw [sum_apply' _ a hs]\n  simp only [zero_apply, Measure.coe_zero, Pi.zero_apply, tsum_zero]\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_comm","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nκ : ι → ι → ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.sum fun n => ProbabilityTheory.Kernel.sum (κ n)) (ProbabilityTheory.Kernel.sum fun m => ProbabilityTheory.Kernel.sum fun n => κ n m)","decl":"theorem sum_comm [Countable ι] (κ : ι → ι → Kernel α β) :\n    (Kernel.sum fun n => Kernel.sum (κ n)) = Kernel.sum fun m => Kernel.sum fun n => κ n m := by\n  ext a s; simp_rw [sum_apply]; rw [Measure.sum_comm]\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_fintype","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Fintype ι\nκ : ι → ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.sum κ) (Finset.univ.sum fun i => κ i)","decl":"@[simp]\ntheorem sum_fintype [Fintype ι] (κ : ι → Kernel α β) : Kernel.sum κ = ∑ i, κ i := by\n  ext a s hs\n  simp only [sum_apply' κ a hs, finset_sum_apply' _ κ a s, tsum_fintype]\n\n"}
{"name":"ProbabilityTheory.Kernel.sum_add","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nκ η : ι → ProbabilityTheory.Kernel α β\n⊢ Eq (ProbabilityTheory.Kernel.sum fun n => HAdd.hAdd (κ n) (η n)) (HAdd.hAdd (ProbabilityTheory.Kernel.sum κ) (ProbabilityTheory.Kernel.sum η))","decl":"theorem sum_add [Countable ι] (κ η : ι → Kernel α β) :\n    (Kernel.sum fun n => κ n + η n) = Kernel.sum κ + Kernel.sum η := by\n  ext a s hs\n  simp only [coe_add, Pi.add_apply, sum_apply, Measure.sum_apply _ hs, Pi.add_apply,\n    Measure.coe_add, tsum_add ENNReal.summable ENNReal.summable]\n\n"}
{"name":"ProbabilityTheory.IsSFiniteKernel.tsum_finite","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nself : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Exists fun κs => And (∀ (n : Nat), ProbabilityTheory.IsFiniteKernel (κs n)) (Eq κ (ProbabilityTheory.Kernel.sum κs))","decl":"/-- A kernel is s-finite if it can be written as the sum of countably many finite kernels. -/\nclass _root_.ProbabilityTheory.IsSFiniteKernel (κ : Kernel α β) : Prop where\n  tsum_finite : ∃ κs : ℕ → Kernel α β, (∀ n, IsFiniteKernel (κs n)) ∧ κ = Kernel.sum κs\n\n"}
{"name":"ProbabilityTheory.Kernel.IsFiniteKernel.isSFiniteKernel","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsFiniteKernel κ\n⊢ ProbabilityTheory.IsSFiniteKernel κ","decl":"instance (priority := 100) IsFiniteKernel.isSFiniteKernel [h : IsFiniteKernel κ] :\n    IsSFiniteKernel κ :=\n  ⟨⟨fun n => if n = 0 then κ else 0, fun n => by\n      simp only; split_ifs\n      · exact h\n      · infer_instance, by\n      ext a s hs\n      rw [Kernel.sum_apply' _ _ hs]\n      have : (fun i => ((ite (i = 0) κ 0) a) s) = fun i => ite (i = 0) (κ a s) 0 := by\n        ext1 i; split_ifs <;> rfl\n      rw [this, tsum_ite_eq]⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.kernel_sum_seq","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsSFiniteKernel κ\n⊢ Eq (ProbabilityTheory.Kernel.sum κ.seq) κ","decl":"theorem kernel_sum_seq (κ : Kernel α β) [h : IsSFiniteKernel κ] : Kernel.sum (seq κ) = κ :=\n  h.tsum_finite.choose_spec.2.symm\n\n"}
{"name":"ProbabilityTheory.Kernel.measure_sum_seq","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsSFiniteKernel κ\na : α\n⊢ Eq (MeasureTheory.Measure.sum fun n => (κ.seq n) a) (κ a)","decl":"theorem measure_sum_seq (κ : Kernel α β) [h : IsSFiniteKernel κ] (a : α) :\n    (Measure.sum fun n => seq κ n a) = κ a := by rw [← Kernel.sum_apply, kernel_sum_seq κ]\n\n"}
{"name":"ProbabilityTheory.Kernel.isFiniteKernel_seq","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\nh : ProbabilityTheory.IsSFiniteKernel κ\nn : Nat\n⊢ ProbabilityTheory.IsFiniteKernel (κ.seq n)","decl":"instance isFiniteKernel_seq (κ : Kernel α β) [h : IsSFiniteKernel κ] (n : ℕ) :\n    IsFiniteKernel (Kernel.seq κ n) :=\n  h.tsum_finite.choose_spec.1 n\n\n"}
{"name":"ProbabilityTheory.IsSFiniteKernel.sFinite","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ : ProbabilityTheory.Kernel α β\ninst✝ : ProbabilityTheory.IsSFiniteKernel κ\na : α\n⊢ MeasureTheory.SFinite (κ a)","decl":"instance _root_.ProbabilityTheory.IsSFiniteKernel.sFinite [IsSFiniteKernel κ] (a : α) :\n    SFinite (κ a) :=\n  ⟨⟨fun n ↦ seq κ n a, inferInstance, (measure_sum_seq κ a).symm⟩⟩\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.add","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκ η : ProbabilityTheory.Kernel α β\ninst✝¹ : ProbabilityTheory.IsSFiniteKernel κ\ninst✝ : ProbabilityTheory.IsSFiniteKernel η\n⊢ ProbabilityTheory.IsSFiniteKernel (HAdd.hAdd κ η)","decl":"instance IsSFiniteKernel.add (κ η : Kernel α β) [IsSFiniteKernel κ] [IsSFiniteKernel η] :\n    IsSFiniteKernel (κ + η) := by\n  refine ⟨⟨fun n => seq κ n + seq η n, fun n => inferInstance, ?_⟩⟩\n  rw [sum_add, kernel_sum_seq κ, kernel_sum_seq η]\n\n"}
{"name":"ProbabilityTheory.Kernel.IsSFiniteKernel.finset_sum","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nκs : ι → ProbabilityTheory.Kernel α β\nI : Finset ι\nh : ∀ (i : ι), Membership.mem I i → ProbabilityTheory.IsSFiniteKernel (κs i)\n⊢ ProbabilityTheory.IsSFiniteKernel (I.sum fun i => κs i)","decl":"theorem IsSFiniteKernel.finset_sum {κs : ι → Kernel α β} (I : Finset ι)\n    (h : ∀ i ∈ I, IsSFiniteKernel (κs i)) : IsSFiniteKernel (∑ i ∈ I, κs i) := by\n  classical\n  induction' I using Finset.induction with i I hi_nmem_I h_ind h\n  · rw [Finset.sum_empty]; infer_instance\n  · rw [Finset.sum_insert hi_nmem_I]\n    haveI : IsSFiniteKernel (κs i) := h i (Finset.mem_insert_self _ _)\n    have : IsSFiniteKernel (∑ x ∈ I, κs x) :=\n      h_ind fun i hiI => h i (Finset.mem_insert_of_mem hiI)\n    exact IsSFiniteKernel.add _ _\n\n"}
{"name":"ProbabilityTheory.Kernel.isSFiniteKernel_sum_of_denumerable","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Denumerable ι\nκs : ι → ProbabilityTheory.Kernel α β\nhκs : ∀ (n : ι), ProbabilityTheory.IsSFiniteKernel (κs n)\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.sum κs)","decl":"theorem isSFiniteKernel_sum_of_denumerable [Denumerable ι] {κs : ι → Kernel α β}\n    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (Kernel.sum κs) := by\n  let e : ℕ ≃ ι × ℕ := (Denumerable.eqv (ι × ℕ)).symm\n  refine ⟨⟨fun n => seq (κs (e n).1) (e n).2, inferInstance, ?_⟩⟩\n  have hκ_eq : Kernel.sum κs = Kernel.sum fun n => Kernel.sum (seq (κs n)) := by\n    simp_rw [kernel_sum_seq]\n  ext a s hs\n  rw [hκ_eq]\n  simp_rw [Kernel.sum_apply' _ _ hs]\n  change (∑' i, ∑' m, seq (κs i) m a s) = ∑' n, (fun im : ι × ℕ => seq (κs im.fst) im.snd a s) (e n)\n  rw [e.tsum_eq (fun im : ι × ℕ => seq (κs im.fst) im.snd a s),\n    tsum_prod' ENNReal.summable fun _ => ENNReal.summable]\n\n"}
{"name":"ProbabilityTheory.Kernel.isSFiniteKernel_sum","module":"Mathlib.Probability.Kernel.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\nι : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\ninst✝ : Countable ι\nκs : ι → ProbabilityTheory.Kernel α β\nhκs : ∀ (n : ι), ProbabilityTheory.IsSFiniteKernel (κs n)\n⊢ ProbabilityTheory.IsSFiniteKernel (ProbabilityTheory.Kernel.sum κs)","decl":"theorem isSFiniteKernel_sum [Countable ι] {κs : ι → Kernel α β}\n    (hκs : ∀ n, IsSFiniteKernel (κs n)) : IsSFiniteKernel (Kernel.sum κs) := by\n  cases fintypeOrInfinite ι\n  · rw [sum_fintype]\n    exact IsSFiniteKernel.finset_sum Finset.univ fun i _ => hκs i\n  cases nonempty_denumerable ι\n  exact isSFiniteKernel_sum_of_denumerable hκs\n\n"}
