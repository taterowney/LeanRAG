{"name":"Set.left_mem_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Ioo a b) a) False","decl":"theorem left_mem_Ioo : a ∈ Ioo a b ↔ False := by simp [lt_irrefl]\n\n"}
{"name":"Set.left_mem_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Ico a b) a) (LT.lt a b)","decl":"theorem left_mem_Ico : a ∈ Ico a b ↔ a < b := by simp [le_refl]\n\n"}
{"name":"Set.left_mem_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Icc a b) a) (LE.le a b)","decl":"theorem left_mem_Icc : a ∈ Icc a b ↔ a ≤ b := by simp [le_refl]\n\n"}
{"name":"Set.left_mem_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Ioc a b) a) False","decl":"theorem left_mem_Ioc : a ∈ Ioc a b ↔ False := by simp [lt_irrefl]\n\n"}
{"name":"Set.left_mem_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Membership.mem (Set.Ici a) a","decl":"theorem left_mem_Ici : a ∈ Ici a := by simp\n\n"}
{"name":"Set.right_mem_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Ioo a b) b) False","decl":"theorem right_mem_Ioo : b ∈ Ioo a b ↔ False := by simp [lt_irrefl]\n\n"}
{"name":"Set.right_mem_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Ico a b) b) False","decl":"theorem right_mem_Ico : b ∈ Ico a b ↔ False := by simp [lt_irrefl]\n\n"}
{"name":"Set.right_mem_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Icc a b) b) (LE.le a b)","decl":"theorem right_mem_Icc : b ∈ Icc a b ↔ a ≤ b := by simp [le_refl]\n\n"}
{"name":"Set.right_mem_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Membership.mem (Set.Ioc a b) b) (LT.lt a b)","decl":"theorem right_mem_Ioc : b ∈ Ioc a b ↔ a < b := by simp [le_refl]\n\n"}
{"name":"Set.right_mem_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Membership.mem (Set.Iic a) a","decl":"theorem right_mem_Iic : a ∈ Iic a := by simp\n\n"}
{"name":"Set.dual_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Ici (OrderDual.toDual a)) (Set.preimage (⇑OrderDual.ofDual) (Set.Iic a))","decl":"@[simp]\ntheorem dual_Ici : Ici (toDual a) = ofDual ⁻¹' Iic a :=\n  rfl\n\n"}
{"name":"Set.dual_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Iic (OrderDual.toDual a)) (Set.preimage (⇑OrderDual.ofDual) (Set.Ici a))","decl":"@[simp]\ntheorem dual_Iic : Iic (toDual a) = ofDual ⁻¹' Ici a :=\n  rfl\n\n"}
{"name":"Set.dual_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Ioi (OrderDual.toDual a)) (Set.preimage (⇑OrderDual.ofDual) (Set.Iio a))","decl":"@[simp]\ntheorem dual_Ioi : Ioi (toDual a) = ofDual ⁻¹' Iio a :=\n  rfl\n\n"}
{"name":"Set.dual_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Iio (OrderDual.toDual a)) (Set.preimage (⇑OrderDual.ofDual) (Set.Ioi a))","decl":"@[simp]\ntheorem dual_Iio : Iio (toDual a) = ofDual ⁻¹' Ioi a :=\n  rfl\n\n"}
{"name":"Set.dual_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Set.Icc (OrderDual.toDual a) (OrderDual.toDual b)) (Set.preimage (⇑OrderDual.ofDual) (Set.Icc b a))","decl":"@[simp]\ntheorem dual_Icc : Icc (toDual a) (toDual b) = ofDual ⁻¹' Icc b a :=\n  Set.ext fun _ => and_comm\n\n"}
{"name":"Set.dual_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Set.Ioc (OrderDual.toDual a) (OrderDual.toDual b)) (Set.preimage (⇑OrderDual.ofDual) (Set.Ico b a))","decl":"@[simp]\ntheorem dual_Ioc : Ioc (toDual a) (toDual b) = ofDual ⁻¹' Ico b a :=\n  Set.ext fun _ => and_comm\n\n"}
{"name":"Set.dual_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Set.Ico (OrderDual.toDual a) (OrderDual.toDual b)) (Set.preimage (⇑OrderDual.ofDual) (Set.Ioc b a))","decl":"@[simp]\ntheorem dual_Ico : Ico (toDual a) (toDual b) = ofDual ⁻¹' Ioc b a :=\n  Set.ext fun _ => and_comm\n\n"}
{"name":"Set.dual_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Set.Ioo (OrderDual.toDual a) (OrderDual.toDual b)) (Set.preimage (⇑OrderDual.ofDual) (Set.Ioo b a))","decl":"@[simp]\ntheorem dual_Ioo : Ioo (toDual a) (toDual b) = ofDual ⁻¹' Ioo b a :=\n  Set.ext fun _ => and_comm\n\n"}
{"name":"Set.nonempty_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Set.Icc a b).Nonempty (LE.le a b)","decl":"@[simp]\ntheorem nonempty_Icc : (Icc a b).Nonempty ↔ a ≤ b :=\n  ⟨fun ⟨_, hx⟩ => hx.1.trans hx.2, fun h => ⟨a, left_mem_Icc.2 h⟩⟩\n\n"}
{"name":"Set.nonempty_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Set.Ico a b).Nonempty (LT.lt a b)","decl":"@[simp]\ntheorem nonempty_Ico : (Ico a b).Nonempty ↔ a < b :=\n  ⟨fun ⟨_, hx⟩ => hx.1.trans_lt hx.2, fun h => ⟨a, left_mem_Ico.2 h⟩⟩\n\n"}
{"name":"Set.nonempty_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Set.Ioc a b).Nonempty (LT.lt a b)","decl":"@[simp]\ntheorem nonempty_Ioc : (Ioc a b).Nonempty ↔ a < b :=\n  ⟨fun ⟨_, hx⟩ => hx.1.trans_le hx.2, fun h => ⟨b, right_mem_Ioc.2 h⟩⟩\n\n"}
{"name":"Set.nonempty_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ (Set.Ici a).Nonempty","decl":"@[simp]\ntheorem nonempty_Ici : (Ici a).Nonempty :=\n  ⟨a, left_mem_Ici⟩\n\n"}
{"name":"Set.nonempty_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ (Set.Iic a).Nonempty","decl":"@[simp]\ntheorem nonempty_Iic : (Iic a).Nonempty :=\n  ⟨a, right_mem_Iic⟩\n\n"}
{"name":"Set.nonempty_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na b : α\ninst✝ : DenselyOrdered α\n⊢ Iff (Set.Ioo a b).Nonempty (LT.lt a b)","decl":"@[simp]\ntheorem nonempty_Ioo [DenselyOrdered α] : (Ioo a b).Nonempty ↔ a < b :=\n  ⟨fun ⟨_, ha, hb⟩ => ha.trans hb, exists_between⟩\n\n"}
{"name":"Set.nonempty_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMaxOrder α\n⊢ (Set.Ioi a).Nonempty","decl":"@[simp]\ntheorem nonempty_Ioi [NoMaxOrder α] : (Ioi a).Nonempty :=\n  exists_gt a\n\n"}
{"name":"Set.nonempty_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMinOrder α\n⊢ (Set.Iio a).Nonempty","decl":"@[simp]\ntheorem nonempty_Iio [NoMinOrder α] : (Iio a).Nonempty :=\n  exists_lt a\n\n"}
{"name":"Set.nonempty_Icc_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ Nonempty ↑(Set.Icc a b)","decl":"theorem nonempty_Icc_subtype (h : a ≤ b) : Nonempty (Icc a b) :=\n  Nonempty.to_subtype (nonempty_Icc.mpr h)\n\n"}
{"name":"Set.nonempty_Ico_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Nonempty ↑(Set.Ico a b)","decl":"theorem nonempty_Ico_subtype (h : a < b) : Nonempty (Ico a b) :=\n  Nonempty.to_subtype (nonempty_Ico.mpr h)\n\n"}
{"name":"Set.nonempty_Ioc_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt a b\n⊢ Nonempty ↑(Set.Ioc a b)","decl":"theorem nonempty_Ioc_subtype (h : a < b) : Nonempty (Ioc a b) :=\n  Nonempty.to_subtype (nonempty_Ioc.mpr h)\n\n"}
{"name":"Set.nonempty_Ici_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Nonempty ↑(Set.Ici a)","decl":"/-- An interval `Ici a` is nonempty. -/\ninstance nonempty_Ici_subtype : Nonempty (Ici a) :=\n  Nonempty.to_subtype nonempty_Ici\n\n"}
{"name":"Set.nonempty_Iic_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Nonempty ↑(Set.Iic a)","decl":"/-- An interval `Iic a` is nonempty. -/\ninstance nonempty_Iic_subtype : Nonempty (Iic a) :=\n  Nonempty.to_subtype nonempty_Iic\n\n"}
{"name":"Set.nonempty_Ioo_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na b : α\ninst✝ : DenselyOrdered α\nh : LT.lt a b\n⊢ Nonempty ↑(Set.Ioo a b)","decl":"theorem nonempty_Ioo_subtype [DenselyOrdered α] (h : a < b) : Nonempty (Ioo a b) :=\n  Nonempty.to_subtype (nonempty_Ioo.mpr h)\n\n"}
{"name":"Set.nonempty_Ioi_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMaxOrder α\n⊢ Nonempty ↑(Set.Ioi a)","decl":"/-- In an order without maximal elements, the intervals `Ioi` are nonempty. -/\ninstance nonempty_Ioi_subtype [NoMaxOrder α] : Nonempty (Ioi a) :=\n  Nonempty.to_subtype nonempty_Ioi\n\n"}
{"name":"Set.nonempty_Iio_subtype","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMinOrder α\n⊢ Nonempty ↑(Set.Iio a)","decl":"/-- In an order without minimal elements, the intervals `Iio` are nonempty. -/\ninstance nonempty_Iio_subtype [NoMinOrder α] : Nonempty (Iio a) :=\n  Nonempty.to_subtype nonempty_Iio\n\n"}
{"name":"Set.instNoMinOrderElemIio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMinOrder α\n⊢ NoMinOrder ↑(Set.Iio a)","decl":"instance [NoMinOrder α] : NoMinOrder (Iio a) :=\n  ⟨fun a =>\n    let ⟨b, hb⟩ := exists_lt (a : α)\n    ⟨⟨b, lt_trans hb a.2⟩, hb⟩⟩\n\n"}
{"name":"Set.instNoMinOrderElemIic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMinOrder α\n⊢ NoMinOrder ↑(Set.Iic a)","decl":"instance [NoMinOrder α] : NoMinOrder (Iic a) :=\n  ⟨fun a =>\n    let ⟨b, hb⟩ := exists_lt (a : α)\n    ⟨⟨b, hb.le.trans a.2⟩, hb⟩⟩\n\n"}
{"name":"Set.instNoMaxOrderElemIoi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMaxOrder α\n⊢ NoMaxOrder ↑(Set.Ioi a)","decl":"instance [NoMaxOrder α] : NoMaxOrder (Ioi a) :=\n  OrderDual.noMaxOrder (α := Iio (toDual a))\n\n"}
{"name":"Set.instNoMaxOrderElemIci","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : NoMaxOrder α\n⊢ NoMaxOrder ↑(Set.Ici a)","decl":"instance [NoMaxOrder α] : NoMaxOrder (Ici a) :=\n  OrderDual.noMaxOrder (α := Iic (toDual a))\n\n"}
{"name":"Set.Icc_eq_empty","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Not (LE.le a b)\n⊢ Eq (Set.Icc a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Icc_eq_empty (h : ¬a ≤ b) : Icc a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun _ ⟨ha, hb⟩ => h (ha.trans hb)\n\n"}
{"name":"Set.Ico_eq_empty","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Not (LT.lt a b)\n⊢ Eq (Set.Ico a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ico_eq_empty (h : ¬a < b) : Ico a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun _ ⟨ha, hb⟩ => h (ha.trans_lt hb)\n\n"}
{"name":"Set.Ioc_eq_empty","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Not (LT.lt a b)\n⊢ Eq (Set.Ioc a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioc_eq_empty (h : ¬a < b) : Ioc a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun _ ⟨ha, hb⟩ => h (ha.trans_le hb)\n\n"}
{"name":"Set.Ioo_eq_empty","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : Not (LT.lt a b)\n⊢ Eq (Set.Ioo a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioo_eq_empty (h : ¬a < b) : Ioo a b = ∅ :=\n  eq_empty_iff_forall_not_mem.2 fun _ ⟨ha, hb⟩ => h (ha.trans hb)\n\n"}
{"name":"Set.Icc_eq_empty_of_lt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LT.lt b a\n⊢ Eq (Set.Icc a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Icc_eq_empty_of_lt (h : b < a) : Icc a b = ∅ :=\n  Icc_eq_empty h.not_le\n\n"}
{"name":"Set.Ico_eq_empty_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le b a\n⊢ Eq (Set.Ico a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ico_eq_empty_of_le (h : b ≤ a) : Ico a b = ∅ :=\n  Ico_eq_empty h.not_lt\n\n"}
{"name":"Set.Ioc_eq_empty_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le b a\n⊢ Eq (Set.Ioc a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioc_eq_empty_of_le (h : b ≤ a) : Ioc a b = ∅ :=\n  Ioc_eq_empty h.not_lt\n\n"}
{"name":"Set.Ioo_eq_empty_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le b a\n⊢ Eq (Set.Ioo a b) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioo_eq_empty_of_le (h : b ≤ a) : Ioo a b = ∅ :=\n  Ioo_eq_empty h.not_lt\n\n"}
{"name":"Set.Ico_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Ico a a) EmptyCollection.emptyCollection","decl":"theorem Ico_self (a : α) : Ico a a = ∅ :=\n  Ico_eq_empty <| lt_irrefl _\n\n"}
{"name":"Set.Ioc_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Ioc a a) EmptyCollection.emptyCollection","decl":"theorem Ioc_self (a : α) : Ioc a a = ∅ :=\n  Ioc_eq_empty <| lt_irrefl _\n\n"}
{"name":"Set.Ioo_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Eq (Set.Ioo a a) EmptyCollection.emptyCollection","decl":"theorem Ioo_self (a : α) : Ioo a a = ∅ :=\n  Ioo_eq_empty <| lt_irrefl _\n\n"}
{"name":"Set.Ici_subset_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (HasSubset.Subset (Set.Ici a) (Set.Ici b)) (LE.le b a)","decl":"theorem Ici_subset_Ici : Ici a ⊆ Ici b ↔ b ≤ a :=\n  ⟨fun h => h <| left_mem_Ici, fun h _ hx => h.trans hx⟩\n\n"}
{"name":"GCongr.Ici_subset_Ici_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\na✝ : LE.le b a\n⊢ HasSubset.Subset (Set.Ici a) (Set.Ici b)","decl":"@[gcongr] alias ⟨_, _root_.GCongr.Ici_subset_Ici_of_le⟩ := Ici_subset_Ici\n\n"}
{"name":"Set.Iic_subset_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (HasSubset.Subset (Set.Iic a) (Set.Iic b)) (LE.le a b)","decl":"theorem Iic_subset_Iic : Iic a ⊆ Iic b ↔ a ≤ b :=\n  @Ici_subset_Ici αᵒᵈ _ _ _\n\n"}
{"name":"GCongr.Iic_subset_Iic_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\na✝ : LE.le a b\n⊢ HasSubset.Subset (Set.Iic a) (Set.Iic b)","decl":"@[gcongr] alias ⟨_, _root_.GCongr.Iic_subset_Iic_of_le⟩ := Iic_subset_Iic\n\n"}
{"name":"Set.Ici_subset_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (HasSubset.Subset (Set.Ici a) (Set.Ioi b)) (LT.lt b a)","decl":"theorem Ici_subset_Ioi : Ici a ⊆ Ioi b ↔ b < a :=\n  ⟨fun h => h left_mem_Ici, fun h _ hx => h.trans_le hx⟩\n\n"}
{"name":"Set.Iic_subset_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (HasSubset.Subset (Set.Iic a) (Set.Iio b)) (LT.lt a b)","decl":"theorem Iic_subset_Iio : Iic a ⊆ Iio b ↔ a < b :=\n  ⟨fun h => h right_mem_Iic, fun h _ hx => lt_of_le_of_lt hx h⟩\n\n"}
{"name":"Set.Ioo_subset_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Ioo a₁ b₁) (Set.Ioo a₂ b₂)","decl":"@[gcongr]\ntheorem Ioo_subset_Ioo (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Ioo a₁ b₁ ⊆ Ioo a₂ b₂ := fun _ ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans_lt hx₁, hx₂.trans_le h₂⟩\n\n"}
{"name":"Set.Ioo_subset_Ioo_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b : α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Set.Ioo a₂ b) (Set.Ioo a₁ b)","decl":"@[gcongr]\ntheorem Ioo_subset_Ioo_left (h : a₁ ≤ a₂) : Ioo a₂ b ⊆ Ioo a₁ b :=\n  Ioo_subset_Ioo h le_rfl\n\n"}
{"name":"Set.Ioo_subset_Ioo_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b₁ b₂ : α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Ioo a b₁) (Set.Ioo a b₂)","decl":"@[gcongr]\ntheorem Ioo_subset_Ioo_right (h : b₁ ≤ b₂) : Ioo a b₁ ⊆ Ioo a b₂ :=\n  Ioo_subset_Ioo le_rfl h\n\n"}
{"name":"Set.Ico_subset_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Ico a₁ b₁) (Set.Ico a₂ b₂)","decl":"@[gcongr]\ntheorem Ico_subset_Ico (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Ico a₁ b₁ ⊆ Ico a₂ b₂ := fun _ ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans hx₁, hx₂.trans_le h₂⟩\n\n"}
{"name":"Set.Ico_subset_Ico_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b : α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Set.Ico a₂ b) (Set.Ico a₁ b)","decl":"@[gcongr]\ntheorem Ico_subset_Ico_left (h : a₁ ≤ a₂) : Ico a₂ b ⊆ Ico a₁ b :=\n  Ico_subset_Ico h le_rfl\n\n"}
{"name":"Set.Ico_subset_Ico_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b₁ b₂ : α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Ico a b₁) (Set.Ico a b₂)","decl":"@[gcongr]\ntheorem Ico_subset_Ico_right (h : b₁ ≤ b₂) : Ico a b₁ ⊆ Ico a b₂ :=\n  Ico_subset_Ico le_rfl h\n\n"}
{"name":"Set.Icc_subset_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Icc a₁ b₁) (Set.Icc a₂ b₂)","decl":"@[gcongr]\ntheorem Icc_subset_Icc (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Icc a₁ b₁ ⊆ Icc a₂ b₂ := fun _ ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans hx₁, le_trans hx₂ h₂⟩\n\n"}
{"name":"Set.Icc_subset_Icc_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b : α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Set.Icc a₂ b) (Set.Icc a₁ b)","decl":"@[gcongr]\ntheorem Icc_subset_Icc_left (h : a₁ ≤ a₂) : Icc a₂ b ⊆ Icc a₁ b :=\n  Icc_subset_Icc h le_rfl\n\n"}
{"name":"Set.Icc_subset_Icc_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b₁ b₂ : α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Icc a b₁) (Set.Icc a b₂)","decl":"@[gcongr]\ntheorem Icc_subset_Icc_right (h : b₁ ≤ b₂) : Icc a b₁ ⊆ Icc a b₂ :=\n  Icc_subset_Icc le_rfl h\n\n"}
{"name":"Set.Icc_subset_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nha : LT.lt a₂ a₁\nhb : LT.lt b₁ b₂\n⊢ HasSubset.Subset (Set.Icc a₁ b₁) (Set.Ioo a₂ b₂)","decl":"theorem Icc_subset_Ioo (ha : a₂ < a₁) (hb : b₁ < b₂) : Icc a₁ b₁ ⊆ Ioo a₂ b₂ := fun _ hx =>\n  ⟨ha.trans_le hx.1, hx.2.trans_lt hb⟩\n\n"}
{"name":"Set.Icc_subset_Ici_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Icc a b) (Set.Ici a)","decl":"theorem Icc_subset_Ici_self : Icc a b ⊆ Ici a := fun _ => And.left\n\n"}
{"name":"Set.Icc_subset_Iic_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Icc a b) (Set.Iic b)","decl":"theorem Icc_subset_Iic_self : Icc a b ⊆ Iic b := fun _ => And.right\n\n"}
{"name":"Set.Ioc_subset_Iic_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.Iic b)","decl":"theorem Ioc_subset_Iic_self : Ioc a b ⊆ Iic b := fun _ => And.right\n\n"}
{"name":"Set.Ioc_subset_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₂ a₁\nh₂ : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Ioc a₁ b₁) (Set.Ioc a₂ b₂)","decl":"@[gcongr]\ntheorem Ioc_subset_Ioc (h₁ : a₂ ≤ a₁) (h₂ : b₁ ≤ b₂) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ := fun _ ⟨hx₁, hx₂⟩ =>\n  ⟨h₁.trans_lt hx₁, hx₂.trans h₂⟩\n\n"}
{"name":"Set.Ioc_subset_Ioc_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b : α\nh : LE.le a₁ a₂\n⊢ HasSubset.Subset (Set.Ioc a₂ b) (Set.Ioc a₁ b)","decl":"@[gcongr]\ntheorem Ioc_subset_Ioc_left (h : a₁ ≤ a₂) : Ioc a₂ b ⊆ Ioc a₁ b :=\n  Ioc_subset_Ioc h le_rfl\n\n"}
{"name":"Set.Ioc_subset_Ioc_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b₁ b₂ : α\nh : LE.le b₁ b₂\n⊢ HasSubset.Subset (Set.Ioc a b₁) (Set.Ioc a b₂)","decl":"@[gcongr]\ntheorem Ioc_subset_Ioc_right (h : b₁ ≤ b₂) : Ioc a b₁ ⊆ Ioc a b₂ :=\n  Ioc_subset_Ioc le_rfl h\n\n"}
{"name":"Set.Ico_subset_Ioo_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b : α\nh₁ : LT.lt a₁ a₂\n⊢ HasSubset.Subset (Set.Ico a₂ b) (Set.Ioo a₁ b)","decl":"theorem Ico_subset_Ioo_left (h₁ : a₁ < a₂) : Ico a₂ b ⊆ Ioo a₁ b := fun _ =>\n  And.imp_left h₁.trans_le\n\n"}
{"name":"Set.Ioc_subset_Ioo_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b₁ b₂ : α\nh : LT.lt b₁ b₂\n⊢ HasSubset.Subset (Set.Ioc a b₁) (Set.Ioo a b₂)","decl":"theorem Ioc_subset_Ioo_right (h : b₁ < b₂) : Ioc a b₁ ⊆ Ioo a b₂ := fun _ =>\n  And.imp_right fun h' => h'.trans_lt h\n\n"}
{"name":"Set.Icc_subset_Ico_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b₁ b₂ : α\nh₁ : LT.lt b₁ b₂\n⊢ HasSubset.Subset (Set.Icc a b₁) (Set.Ico a b₂)","decl":"theorem Icc_subset_Ico_right (h₁ : b₁ < b₂) : Icc a b₁ ⊆ Ico a b₂ := fun _ =>\n  And.imp_right fun h₂ => h₂.trans_lt h₁\n\n"}
{"name":"Set.Ioo_subset_Ico_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo a b) (Set.Ico a b)","decl":"theorem Ioo_subset_Ico_self : Ioo a b ⊆ Ico a b := fun _ => And.imp_left le_of_lt\n\n"}
{"name":"Set.Ioo_subset_Ioc_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo a b) (Set.Ioc a b)","decl":"theorem Ioo_subset_Ioc_self : Ioo a b ⊆ Ioc a b := fun _ => And.imp_right le_of_lt\n\n"}
{"name":"Set.Ico_subset_Icc_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ico a b) (Set.Icc a b)","decl":"theorem Ico_subset_Icc_self : Ico a b ⊆ Icc a b := fun _ => And.imp_right le_of_lt\n\n"}
{"name":"Set.Ioc_subset_Icc_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.Icc a b)","decl":"theorem Ioc_subset_Icc_self : Ioc a b ⊆ Icc a b := fun _ => And.imp_left le_of_lt\n\n"}
{"name":"Set.Ioo_subset_Icc_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo a b) (Set.Icc a b)","decl":"theorem Ioo_subset_Icc_self : Ioo a b ⊆ Icc a b :=\n  Subset.trans Ioo_subset_Ico_self Ico_subset_Icc_self\n\n"}
{"name":"Set.Ico_subset_Iio_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ico a b) (Set.Iio b)","decl":"theorem Ico_subset_Iio_self : Ico a b ⊆ Iio b := fun _ => And.right\n\n"}
{"name":"Set.Ioo_subset_Iio_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo a b) (Set.Iio b)","decl":"theorem Ioo_subset_Iio_self : Ioo a b ⊆ Iio b := fun _ => And.right\n\n"}
{"name":"Set.Ioc_subset_Ioi_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioc a b) (Set.Ioi a)","decl":"theorem Ioc_subset_Ioi_self : Ioc a b ⊆ Ioi a := fun _ => And.left\n\n"}
{"name":"Set.Ioo_subset_Ioi_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ioo a b) (Set.Ioi a)","decl":"theorem Ioo_subset_Ioi_self : Ioo a b ⊆ Ioi a := fun _ => And.left\n\n"}
{"name":"Set.Ioi_subset_Ici_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ HasSubset.Subset (Set.Ioi a) (Set.Ici a)","decl":"theorem Ioi_subset_Ici_self : Ioi a ⊆ Ici a := fun _ hx => le_of_lt hx\n\n"}
{"name":"Set.Iio_subset_Iic_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ HasSubset.Subset (Set.Iio a) (Set.Iic a)","decl":"theorem Iio_subset_Iic_self : Iio a ⊆ Iic a := fun _ hx => le_of_lt hx\n\n"}
{"name":"Set.Ico_subset_Ici_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ HasSubset.Subset (Set.Ico a b) (Set.Ici a)","decl":"theorem Ico_subset_Ici_self : Ico a b ⊆ Ici a := fun _ => And.left\n\n"}
{"name":"Set.Ioi_ssubset_Ici_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ HasSSubset.SSubset (Set.Ioi a) (Set.Ici a)","decl":"theorem Ioi_ssubset_Ici_self : Ioi a ⊂ Ici a :=\n  ⟨Ioi_subset_Ici_self, fun h => lt_irrefl a (h le_rfl)⟩\n\n"}
{"name":"Set.Iio_ssubset_Iic_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ HasSSubset.SSubset (Set.Iio a) (Set.Iic a)","decl":"theorem Iio_ssubset_Iic_self : Iio a ⊂ Iic a :=\n  @Ioi_ssubset_Ici_self αᵒᵈ _ _\n\n"}
{"name":"Set.Icc_subset_Icc_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Icc a₂ b₂)) (And (LE.le a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Icc_subset_Icc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Icc a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ _ ⟨hx, hx'⟩ =>\n    ⟨h.trans hx, hx'.trans h'⟩⟩\n\n"}
{"name":"Set.Icc_subset_Ioo_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Ioo a₂ b₂)) (And (LT.lt a₂ a₁) (LT.lt b₁ b₂))","decl":"theorem Icc_subset_Ioo_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioo a₂ b₂ ↔ a₂ < a₁ ∧ b₁ < b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ _ ⟨hx, hx'⟩ =>\n    ⟨h.trans_le hx, hx'.trans_lt h'⟩⟩\n\n"}
{"name":"Set.Icc_subset_Ico_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Ico a₂ b₂)) (And (LE.le a₂ a₁) (LT.lt b₁ b₂))","decl":"theorem Icc_subset_Ico_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ < b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ _ ⟨hx, hx'⟩ =>\n    ⟨h.trans hx, hx'.trans_lt h'⟩⟩\n\n"}
{"name":"Set.Icc_subset_Ioc_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Ioc a₂ b₂)) (And (LT.lt a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Icc_subset_Ioc_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ a₂ < a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h => ⟨(h ⟨le_rfl, h₁⟩).1, (h ⟨h₁, le_rfl⟩).2⟩, fun ⟨h, h'⟩ _ ⟨hx, hx'⟩ =>\n    ⟨h.trans_le hx, hx'.trans h'⟩⟩\n\n"}
{"name":"Set.Icc_subset_Iio_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ b₁ b₂ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Iio b₂)) (LT.lt b₁ b₂)","decl":"theorem Icc_subset_Iio_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Iio b₂ ↔ b₁ < b₂ :=\n  ⟨fun h => h ⟨h₁, le_rfl⟩, fun h _ ⟨_, hx'⟩ => hx'.trans_lt h⟩\n\n"}
{"name":"Set.Icc_subset_Ioi_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Ioi a₂)) (LT.lt a₂ a₁)","decl":"theorem Icc_subset_Ioi_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ioi a₂ ↔ a₂ < a₁ :=\n  ⟨fun h => h ⟨le_rfl, h₁⟩, fun h _ ⟨hx, _⟩ => h.trans_le hx⟩\n\n"}
{"name":"Set.Icc_subset_Iic_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ b₁ b₂ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Iic b₂)) (LE.le b₁ b₂)","decl":"theorem Icc_subset_Iic_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Iic b₂ ↔ b₁ ≤ b₂ :=\n  ⟨fun h => h ⟨h₁, le_rfl⟩, fun h _ ⟨_, hx'⟩ => hx'.trans h⟩\n\n"}
{"name":"Set.Icc_subset_Ici_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ : α\nh₁ : LE.le a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Icc a₁ b₁) (Set.Ici a₂)) (LE.le a₂ a₁)","decl":"theorem Icc_subset_Ici_iff (h₁ : a₁ ≤ b₁) : Icc a₁ b₁ ⊆ Ici a₂ ↔ a₂ ≤ a₁ :=\n  ⟨fun h => h ⟨le_rfl, h₁⟩, fun h _ ⟨hx, _⟩ => h.trans hx⟩\n\n"}
{"name":"Set.Icc_ssubset_Icc_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nhI : LE.le a₂ b₂\nha : LT.lt a₂ a₁\nhb : LE.le b₁ b₂\n⊢ HasSSubset.SSubset (Set.Icc a₁ b₁) (Set.Icc a₂ b₂)","decl":"theorem Icc_ssubset_Icc_left (hI : a₂ ≤ b₂) (ha : a₂ < a₁) (hb : b₁ ≤ b₂) : Icc a₁ b₁ ⊂ Icc a₂ b₂ :=\n  (ssubset_iff_of_subset (Icc_subset_Icc (le_of_lt ha) hb)).mpr\n    ⟨a₂, left_mem_Icc.mpr hI, not_and.mpr fun f _ => lt_irrefl a₂ (ha.trans_le f)⟩\n\n"}
{"name":"Set.Icc_ssubset_Icc_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na₁ a₂ b₁ b₂ : α\nhI : LE.le a₂ b₂\nha : LE.le a₂ a₁\nhb : LT.lt b₁ b₂\n⊢ HasSSubset.SSubset (Set.Icc a₁ b₁) (Set.Icc a₂ b₂)","decl":"theorem Icc_ssubset_Icc_right (hI : a₂ ≤ b₂) (ha : a₂ ≤ a₁) (hb : b₁ < b₂) :\n    Icc a₁ b₁ ⊂ Icc a₂ b₂ :=\n  (ssubset_iff_of_subset (Icc_subset_Icc ha (le_of_lt hb))).mpr\n    ⟨b₂, right_mem_Icc.mpr hI, fun f => lt_irrefl b₁ (hb.trans_le f.2)⟩\n\n"}
{"name":"Set.Ioi_subset_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ HasSubset.Subset (Set.Ioi b) (Set.Ioi a)","decl":"/-- If `a ≤ b`, then `(b, +∞) ⊆ (a, +∞)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Ioi_subset_Ioi_iff`. -/\n@[gcongr]\ntheorem Ioi_subset_Ioi (h : a ≤ b) : Ioi b ⊆ Ioi a := fun _ hx => h.trans_lt hx\n\n"}
{"name":"Set.Ioi_subset_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ HasSubset.Subset (Set.Ioi b) (Set.Ici a)","decl":"/-- If `a ≤ b`, then `(b, +∞) ⊆ [a, +∞)`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Ioi_subset_Ici_iff`. -/\ntheorem Ioi_subset_Ici (h : a ≤ b) : Ioi b ⊆ Ici a :=\n  Subset.trans (Ioi_subset_Ioi h) Ioi_subset_Ici_self\n\n"}
{"name":"Set.Iio_subset_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ HasSubset.Subset (Set.Iio a) (Set.Iio b)","decl":"/-- If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b)`. In preorders, this is just an implication. If you need\nthe equivalence in linear orders, use `Iio_subset_Iio_iff`. -/\n@[gcongr]\ntheorem Iio_subset_Iio (h : a ≤ b) : Iio a ⊆ Iio b := fun _ hx => lt_of_lt_of_le hx h\n\n"}
{"name":"Set.Iio_subset_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\nh : LE.le a b\n⊢ HasSubset.Subset (Set.Iio a) (Set.Iic b)","decl":"/-- If `a ≤ b`, then `(-∞, a) ⊆ (-∞, b]`. In preorders, this is just an implication. If you need\nthe equivalence in dense linear orders, use `Iio_subset_Iic_iff`. -/\ntheorem Iio_subset_Iic (h : a ≤ b) : Iio a ⊆ Iic b :=\n  Subset.trans (Iio_subset_Iio h) Iio_subset_Iic_self\n\n"}
{"name":"Set.Ici_inter_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Ici a) (Set.Iic b)) (Set.Icc a b)","decl":"theorem Ici_inter_Iic : Ici a ∩ Iic b = Icc a b :=\n  rfl\n\n"}
{"name":"Set.Ici_inter_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Ici a) (Set.Iio b)) (Set.Ico a b)","decl":"theorem Ici_inter_Iio : Ici a ∩ Iio b = Ico a b :=\n  rfl\n\n"}
{"name":"Set.Ioi_inter_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Ioi a) (Set.Iic b)) (Set.Ioc a b)","decl":"theorem Ioi_inter_Iic : Ioi a ∩ Iic b = Ioc a b :=\n  rfl\n\n"}
{"name":"Set.Ioi_inter_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Ioi a) (Set.Iio b)) (Set.Ioo a b)","decl":"theorem Ioi_inter_Iio : Ioi a ∩ Iio b = Ioo a b :=\n  rfl\n\n"}
{"name":"Set.Iic_inter_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Iic a) (Set.Ici b)) (Set.Icc b a)","decl":"theorem Iic_inter_Ici : Iic a ∩ Ici b = Icc b a :=\n  inter_comm _ _\n\n"}
{"name":"Set.Iio_inter_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Iio a) (Set.Ici b)) (Set.Ico b a)","decl":"theorem Iio_inter_Ici : Iio a ∩ Ici b = Ico b a :=\n  inter_comm _ _\n\n"}
{"name":"Set.Iic_inter_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Iic a) (Set.Ioi b)) (Set.Ioc b a)","decl":"theorem Iic_inter_Ioi : Iic a ∩ Ioi b = Ioc b a :=\n  inter_comm _ _\n\n"}
{"name":"Set.Iio_inter_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Eq (Inter.inter (Set.Iio a) (Set.Ioi b)) (Set.Ioo b a)","decl":"theorem Iio_inter_Ioi : Iio a ∩ Ioi b = Ioo b a :=\n  inter_comm _ _\n\n"}
{"name":"Set.mem_Icc_of_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\nh : Membership.mem (Set.Ioo a b) x\n⊢ Membership.mem (Set.Icc a b) x","decl":"theorem mem_Icc_of_Ioo (h : x ∈ Ioo a b) : x ∈ Icc a b :=\n  Ioo_subset_Icc_self h\n\n"}
{"name":"Set.mem_Ico_of_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\nh : Membership.mem (Set.Ioo a b) x\n⊢ Membership.mem (Set.Ico a b) x","decl":"theorem mem_Ico_of_Ioo (h : x ∈ Ioo a b) : x ∈ Ico a b :=\n  Ioo_subset_Ico_self h\n\n"}
{"name":"Set.mem_Ioc_of_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\nh : Membership.mem (Set.Ioo a b) x\n⊢ Membership.mem (Set.Ioc a b) x","decl":"theorem mem_Ioc_of_Ioo (h : x ∈ Ioo a b) : x ∈ Ioc a b :=\n  Ioo_subset_Ioc_self h\n\n"}
{"name":"Set.mem_Icc_of_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\nh : Membership.mem (Set.Ico a b) x\n⊢ Membership.mem (Set.Icc a b) x","decl":"theorem mem_Icc_of_Ico (h : x ∈ Ico a b) : x ∈ Icc a b :=\n  Ico_subset_Icc_self h\n\n"}
{"name":"Set.mem_Icc_of_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b x : α\nh : Membership.mem (Set.Ioc a b) x\n⊢ Membership.mem (Set.Icc a b) x","decl":"theorem mem_Icc_of_Ioc (h : x ∈ Ioc a b) : x ∈ Icc a b :=\n  Ioc_subset_Icc_self h\n\n"}
{"name":"Set.mem_Ici_of_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na x : α\nh : Membership.mem (Set.Ioi a) x\n⊢ Membership.mem (Set.Ici a) x","decl":"theorem mem_Ici_of_Ioi (h : x ∈ Ioi a) : x ∈ Ici a :=\n  Ioi_subset_Ici_self h\n\n"}
{"name":"Set.mem_Iic_of_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na x : α\nh : Membership.mem (Set.Iio a) x\n⊢ Membership.mem (Set.Iic a) x","decl":"theorem mem_Iic_of_Iio (h : x ∈ Iio a) : x ∈ Iic a :=\n  Iio_subset_Iic_self h\n\n"}
{"name":"Set.Icc_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Icc a b) EmptyCollection.emptyCollection) (Not (LE.le a b))","decl":"theorem Icc_eq_empty_iff : Icc a b = ∅ ↔ ¬a ≤ b := by\n  rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Icc]\n\n"}
{"name":"Set.Ico_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ico a b) EmptyCollection.emptyCollection) (Not (LT.lt a b))","decl":"theorem Ico_eq_empty_iff : Ico a b = ∅ ↔ ¬a < b := by\n  rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ico]\n\n"}
{"name":"Set.Ioc_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioc a b) EmptyCollection.emptyCollection) (Not (LT.lt a b))","decl":"theorem Ioc_eq_empty_iff : Ioc a b = ∅ ↔ ¬a < b := by\n  rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioc]\n\n"}
{"name":"Set.Ioo_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na b : α\ninst✝ : DenselyOrdered α\n⊢ Iff (Eq (Set.Ioo a b) EmptyCollection.emptyCollection) (Not (LT.lt a b))","decl":"theorem Ioo_eq_empty_iff [DenselyOrdered α] : Ioo a b = ∅ ↔ ¬a < b := by\n  rw [← not_nonempty_iff_eq_empty, not_iff_not, nonempty_Ioo]\n\n"}
{"name":"IsTop.Iic_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nh : IsTop a\n⊢ Eq (Set.Iic a) Set.univ","decl":"theorem _root_.IsTop.Iic_eq (h : IsTop a) : Iic a = univ :=\n  eq_univ_of_forall h\n\n"}
{"name":"IsBot.Ici_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nh : IsBot a\n⊢ Eq (Set.Ici a) Set.univ","decl":"theorem _root_.IsBot.Ici_eq (h : IsBot a) : Ici a = univ :=\n  eq_univ_of_forall h\n\n"}
{"name":"Set.Ioi_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (Eq (Set.Ioi a) EmptyCollection.emptyCollection) (IsMax a)","decl":"theorem Ioi_eq_empty_iff : Ioi a = ∅ ↔ IsMax a := by\n  simp only [isMax_iff_forall_not_lt, eq_empty_iff_forall_not_mem, mem_Ioi]\n\n"}
{"name":"Set.Iio_eq_empty_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Iff (Eq (Set.Iio a) EmptyCollection.emptyCollection) (IsMin a)","decl":"theorem Iio_eq_empty_iff : Iio a = ∅ ↔ IsMin a := Ioi_eq_empty_iff (α := αᵒᵈ)\n\n"}
{"name":"IsMax.Ioi_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\na✝ : IsMax a\n⊢ Eq (Set.Ioi a) EmptyCollection.emptyCollection","decl":"alias ⟨_, _root_.IsMax.Ioi_eq⟩ := Ioi_eq_empty_iff\n"}
{"name":"IsMin.Iio_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\na✝ : IsMin a\n⊢ Eq (Set.Iio a) EmptyCollection.emptyCollection","decl":"alias ⟨_, _root_.IsMin.Iio_eq⟩ := Iio_eq_empty_iff\n\n"}
{"name":"Set.Iic_inter_Ioc_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nh : LE.le a c\n⊢ Eq (Inter.inter (Set.Iic a) (Set.Ioc b c)) (Set.Ioc b a)","decl":"theorem Iic_inter_Ioc_of_le (h : a ≤ c) : Iic a ∩ Ioc b c = Ioc b a :=\n  ext fun _ => ⟨fun H => ⟨H.2.1, H.1⟩, fun H => ⟨H.2, H.1, H.2.trans h⟩⟩\n\n"}
{"name":"Set.not_mem_Icc_of_lt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nha : LT.lt c a\n⊢ Not (Membership.mem (Set.Icc a b) c)","decl":"theorem not_mem_Icc_of_lt (ha : c < a) : c ∉ Icc a b := fun h => ha.not_le h.1\n\n"}
{"name":"Set.not_mem_Icc_of_gt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhb : LT.lt b c\n⊢ Not (Membership.mem (Set.Icc a b) c)","decl":"theorem not_mem_Icc_of_gt (hb : b < c) : c ∉ Icc a b := fun h => hb.not_le h.2\n\n"}
{"name":"Set.not_mem_Ico_of_lt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nha : LT.lt c a\n⊢ Not (Membership.mem (Set.Ico a b) c)","decl":"theorem not_mem_Ico_of_lt (ha : c < a) : c ∉ Ico a b := fun h => ha.not_le h.1\n\n"}
{"name":"Set.not_mem_Ioc_of_gt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhb : LT.lt b c\n⊢ Not (Membership.mem (Set.Ioc a b) c)","decl":"theorem not_mem_Ioc_of_gt (hb : b < c) : c ∉ Ioc a b := fun h => hb.not_le h.2\n\n"}
{"name":"Set.not_mem_Ioi_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ Not (Membership.mem (Set.Ioi a) a)","decl":"theorem not_mem_Ioi_self : a ∉ Ioi a := lt_irrefl _\n\n"}
{"name":"Set.not_mem_Iio_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nb : α\n⊢ Not (Membership.mem (Set.Iio b) b)","decl":"theorem not_mem_Iio_self : b ∉ Iio b := lt_irrefl _\n\n"}
{"name":"Set.not_mem_Ioc_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nha : LE.le c a\n⊢ Not (Membership.mem (Set.Ioc a b) c)","decl":"theorem not_mem_Ioc_of_le (ha : c ≤ a) : c ∉ Ioc a b := fun h => lt_irrefl _ <| h.1.trans_le ha\n\n"}
{"name":"Set.not_mem_Ico_of_ge","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhb : LE.le b c\n⊢ Not (Membership.mem (Set.Ico a b) c)","decl":"theorem not_mem_Ico_of_ge (hb : b ≤ c) : c ∉ Ico a b := fun h => lt_irrefl _ <| h.2.trans_le hb\n\n"}
{"name":"Set.not_mem_Ioo_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nha : LE.le c a\n⊢ Not (Membership.mem (Set.Ioo a b) c)","decl":"theorem not_mem_Ioo_of_le (ha : c ≤ a) : c ∉ Ioo a b := fun h => lt_irrefl _ <| h.1.trans_le ha\n\n"}
{"name":"Set.not_mem_Ioo_of_ge","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b c : α\nhb : LE.le b c\n⊢ Not (Membership.mem (Set.Ioo a b) c)","decl":"theorem not_mem_Ioo_of_ge (hb : b ≤ c) : c ∉ Ioo a b := fun h => lt_irrefl _ <| h.2.trans_le hb\n\n"}
{"name":"Set.Icc_eq_Ioc_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Icc a b) (Set.Ioc a b)) (Not (LE.le a b))","decl":"@[simp] theorem Icc_eq_Ioc_same_iff : Icc a b = Ioc a b ↔ ¬a ≤ b where\n  mp h := by simpa using Set.ext_iff.mp h a\n  mpr h := by rw [Icc_eq_empty h, Ioc_eq_empty (mt le_of_lt h)]\n\n"}
{"name":"Set.Icc_eq_Ico_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Icc a b) (Set.Ico a b)) (Not (LE.le a b))","decl":"@[simp] theorem Icc_eq_Ico_same_iff : Icc a b = Ico a b ↔ ¬a ≤ b where\n  mp h := by simpa using Set.ext_iff.mp h b\n  mpr h := by rw [Icc_eq_empty h, Ico_eq_empty (mt le_of_lt h)]\n\n"}
{"name":"Set.Icc_eq_Ioo_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Icc a b) (Set.Ioo a b)) (Not (LE.le a b))","decl":"@[simp] theorem Icc_eq_Ioo_same_iff : Icc a b = Ioo a b ↔ ¬a ≤ b where\n  mp h := by simpa using Set.ext_iff.mp h b\n  mpr h := by rw [Icc_eq_empty h, Ioo_eq_empty (mt le_of_lt h)]\n\n"}
{"name":"Set.Ioc_eq_Ico_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioc a b) (Set.Ico a b)) (Not (LT.lt a b))","decl":"@[simp] theorem Ioc_eq_Ico_same_iff : Ioc a b = Ico a b ↔ ¬a < b where\n  mp h := by simpa using Set.ext_iff.mp h a\n  mpr h := by rw [Ioc_eq_empty h, Ico_eq_empty h]\n\n"}
{"name":"Set.Ioo_eq_Ioc_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioo a b) (Set.Ioc a b)) (Not (LT.lt a b))","decl":"@[simp] theorem Ioo_eq_Ioc_same_iff : Ioo a b = Ioc a b ↔ ¬a < b where\n  mp h := by simpa using Set.ext_iff.mp h b\n  mpr h := by rw [Ioo_eq_empty h, Ioc_eq_empty h]\n\n"}
{"name":"Set.Ioo_eq_Ico_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioo a b) (Set.Ico a b)) (Not (LT.lt a b))","decl":"@[simp] theorem Ioo_eq_Ico_same_iff : Ioo a b = Ico a b ↔ ¬a < b where\n  mp h := by simpa using Set.ext_iff.mp h a\n  mpr h := by rw [Ioo_eq_empty h, Ico_eq_empty h]\n\n-- Mirrored versions of the above for `simp`.\n\n"}
{"name":"Set.Ioc_eq_Icc_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioc a b) (Set.Icc a b)) (Not (LE.le a b))","decl":"@[simp] theorem Ioc_eq_Icc_same_iff : Ioc a b = Icc a b ↔ ¬a ≤ b :=\n  eq_comm.trans Icc_eq_Ioc_same_iff\n\n"}
{"name":"Set.Ico_eq_Icc_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ico a b) (Set.Icc a b)) (Not (LE.le a b))","decl":"@[simp] theorem Ico_eq_Icc_same_iff : Ico a b = Icc a b ↔ ¬a ≤ b :=\n  eq_comm.trans Icc_eq_Ico_same_iff\n\n"}
{"name":"Set.Ioo_eq_Icc_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioo a b) (Set.Icc a b)) (Not (LE.le a b))","decl":"@[simp] theorem Ioo_eq_Icc_same_iff : Ioo a b = Icc a b ↔ ¬a ≤ b :=\n  eq_comm.trans Icc_eq_Ioo_same_iff\n\n"}
{"name":"Set.Ico_eq_Ioc_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ico a b) (Set.Ioc a b)) (Not (LT.lt a b))","decl":"@[simp] theorem Ico_eq_Ioc_same_iff : Ico a b = Ioc a b ↔ ¬a < b :=\n  eq_comm.trans Ioc_eq_Ico_same_iff\n\n"}
{"name":"Set.Ioc_eq_Ioo_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ioc a b) (Set.Ioo a b)) (Not (LT.lt a b))","decl":"@[simp] theorem Ioc_eq_Ioo_same_iff : Ioc a b = Ioo a b ↔ ¬a < b :=\n  eq_comm.trans Ioo_eq_Ioc_same_iff\n\n"}
{"name":"Set.Ico_eq_Ioo_same_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (Eq (Set.Ico a b) (Set.Ioo a b)) (Not (LT.lt a b))","decl":"@[simp] theorem Ico_eq_Ioo_same_iff : Ico a b = Ioo a b ↔ ¬a < b :=\n  eq_comm.trans Ioo_eq_Ico_same_iff\n\n"}
{"name":"Set.Icc_self","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (Set.Icc a a) (Singleton.singleton a)","decl":"@[simp]\ntheorem Icc_self (a : α) : Icc a a = {a} :=\n  Set.ext <| by simp [Icc, le_antisymm_iff, and_comm]\n\n"}
{"name":"Set.Icc_eq_singleton_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b c : α\n⊢ Iff (Eq (Set.Icc a b) (Singleton.singleton c)) (And (Eq a c) (Eq b c))","decl":"@[simp]\ntheorem Icc_eq_singleton_iff : Icc a b = {c} ↔ a = c ∧ b = c := by\n  refine ⟨fun h => ?_, ?_⟩\n  · have hab : a ≤ b := nonempty_Icc.1 (h.symm.subst <| singleton_nonempty c)\n    exact\n      ⟨eq_of_mem_singleton <| h ▸ left_mem_Icc.2 hab,\n        eq_of_mem_singleton <| h ▸ right_mem_Icc.2 hab⟩\n  · rintro ⟨rfl, rfl⟩\n    exact Icc_self _\n\n"}
{"name":"Set.subsingleton_Icc_of_ge","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nhba : LE.le b a\n⊢ (Set.Icc a b).Subsingleton","decl":"lemma subsingleton_Icc_of_ge (hba : b ≤ a) : Set.Subsingleton (Icc a b) :=\n  fun _x ⟨hax, hxb⟩ _y ⟨hay, hyb⟩ ↦ le_antisymm\n    (le_implies_le_of_le_of_le hxb hay hba) (le_implies_le_of_le_of_le hyb hax hba)\n\n"}
{"name":"Set.subsingleton_Icc_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_3\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Set.Icc a b).Subsingleton (LE.le b a)","decl":"@[simp] lemma subsingleton_Icc_iff {α : Type*} [LinearOrder α] {a b : α} :\n    Set.Subsingleton (Icc a b) ↔ b ≤ a := by\n  refine ⟨fun h ↦ ?_, subsingleton_Icc_of_ge⟩\n  contrapose! h\n  simp only [gt_iff_lt, not_subsingleton_iff]\n  exact ⟨a, ⟨le_refl _, h.le⟩, b, ⟨h.le, le_refl _⟩, h.ne⟩\n\n"}
{"name":"Set.Icc_diff_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Icc a b) (Singleton.singleton a)) (Set.Ioc a b)","decl":"@[simp]\ntheorem Icc_diff_left : Icc a b \\ {a} = Ioc a b :=\n  ext fun x => by simp [lt_iff_le_and_ne, eq_comm, and_right_comm]\n\n"}
{"name":"Set.Icc_diff_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Icc a b) (Singleton.singleton b)) (Set.Ico a b)","decl":"@[simp]\ntheorem Icc_diff_right : Icc a b \\ {b} = Ico a b :=\n  ext fun x => by simp [lt_iff_le_and_ne, and_assoc]\n\n"}
{"name":"Set.Ico_diff_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Ico a b) (Singleton.singleton a)) (Set.Ioo a b)","decl":"@[simp]\ntheorem Ico_diff_left : Ico a b \\ {a} = Ioo a b :=\n  ext fun x => by simp [and_right_comm, ← lt_iff_le_and_ne, eq_comm]\n\n"}
{"name":"Set.Ioc_diff_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Ioc a b) (Singleton.singleton b)) (Set.Ioo a b)","decl":"@[simp]\ntheorem Ioc_diff_right : Ioc a b \\ {b} = Ioo a b :=\n  ext fun x => by simp [and_assoc, ← lt_iff_le_and_ne]\n\n"}
{"name":"Set.Icc_diff_both","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Icc a b) (Insert.insert a (Singleton.singleton b))) (Set.Ioo a b)","decl":"@[simp]\ntheorem Icc_diff_both : Icc a b \\ {a, b} = Ioo a b := by\n  rw [insert_eq, ← diff_diff, Icc_diff_left, Ioc_diff_right]\n\n"}
{"name":"Set.Ici_diff_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (SDiff.sdiff (Set.Ici a) (Singleton.singleton a)) (Set.Ioi a)","decl":"@[simp]\ntheorem Ici_diff_left : Ici a \\ {a} = Ioi a :=\n  ext fun x => by simp [lt_iff_le_and_ne, eq_comm]\n\n"}
{"name":"Set.Iic_diff_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (SDiff.sdiff (Set.Iic a) (Singleton.singleton a)) (Set.Iio a)","decl":"@[simp]\ntheorem Iic_diff_right : Iic a \\ {a} = Iio a :=\n  ext fun x => by simp [lt_iff_le_and_ne]\n\n"}
{"name":"Set.Ico_diff_Ioo_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (SDiff.sdiff (Set.Ico a b) (Set.Ioo a b)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Ico_diff_Ioo_same (h : a < b) : Ico a b \\ Ioo a b = {a} := by\n  rw [← Ico_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Ico.2 h)]\n\n"}
{"name":"Set.Ioc_diff_Ioo_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (SDiff.sdiff (Set.Ioc a b) (Set.Ioo a b)) (Singleton.singleton b)","decl":"@[simp]\ntheorem Ioc_diff_Ioo_same (h : a < b) : Ioc a b \\ Ioo a b = {b} := by\n  rw [← Ioc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Ioc.2 h)]\n\n"}
{"name":"Set.Icc_diff_Ico_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Eq (SDiff.sdiff (Set.Icc a b) (Set.Ico a b)) (Singleton.singleton b)","decl":"@[simp]\ntheorem Icc_diff_Ico_same (h : a ≤ b) : Icc a b \\ Ico a b = {b} := by\n  rw [← Icc_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 <| right_mem_Icc.2 h)]\n\n"}
{"name":"Set.Icc_diff_Ioc_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Eq (SDiff.sdiff (Set.Icc a b) (Set.Ioc a b)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Icc_diff_Ioc_same (h : a ≤ b) : Icc a b \\ Ioc a b = {a} := by\n  rw [← Icc_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 <| left_mem_Icc.2 h)]\n\n"}
{"name":"Set.Icc_diff_Ioo_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Eq (SDiff.sdiff (Set.Icc a b) (Set.Ioo a b)) (Insert.insert a (Singleton.singleton b))","decl":"@[simp]\ntheorem Icc_diff_Ioo_same (h : a ≤ b) : Icc a b \\ Ioo a b = {a, b} := by\n  rw [← Icc_diff_both, diff_diff_cancel_left]\n  simp [insert_subset_iff, h]\n\n"}
{"name":"Set.Ici_diff_Ioi_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (SDiff.sdiff (Set.Ici a) (Set.Ioi a)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Ici_diff_Ioi_same : Ici a \\ Ioi a = {a} := by\n  rw [← Ici_diff_left, diff_diff_cancel_left (singleton_subset_iff.2 left_mem_Ici)]\n\n"}
{"name":"Set.Iic_diff_Iio_same","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (SDiff.sdiff (Set.Iic a) (Set.Iio a)) (Singleton.singleton a)","decl":"@[simp]\ntheorem Iic_diff_Iio_same : Iic a \\ Iio a = {a} := by\n  rw [← Iic_diff_right, diff_diff_cancel_left (singleton_subset_iff.2 right_mem_Iic)]\n\n"}
{"name":"Set.Ioi_union_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (Union.union (Set.Ioi a) (Singleton.singleton a)) (Set.Ici a)","decl":"theorem Ioi_union_left : Ioi a ∪ {a} = Ici a :=\n  ext fun x => by simp [eq_comm, le_iff_eq_or_lt]\n\n"}
{"name":"Set.Iio_union_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (Union.union (Set.Iio a) (Singleton.singleton a)) (Set.Iic a)","decl":"theorem Iio_union_right : Iio a ∪ {a} = Iic a :=\n  ext fun _ => le_iff_lt_or_eq.symm\n\n"}
{"name":"Set.Ioo_union_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nhab : LT.lt a b\n⊢ Eq (Union.union (Set.Ioo a b) (Singleton.singleton a)) (Set.Ico a b)","decl":"theorem Ioo_union_left (hab : a < b) : Ioo a b ∪ {a} = Ico a b := by\n  rw [← Ico_diff_left, diff_union_self,\n    union_eq_self_of_subset_right (singleton_subset_iff.2 <| left_mem_Ico.2 hab)]\n\n"}
{"name":"Set.Ioo_union_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nhab : LT.lt a b\n⊢ Eq (Union.union (Set.Ioo a b) (Singleton.singleton b)) (Set.Ioc a b)","decl":"theorem Ioo_union_right (hab : a < b) : Ioo a b ∪ {b} = Ioc a b := by\n  simpa only [dual_Ioo, dual_Ico] using Ioo_union_left hab.dual\n\n"}
{"name":"Set.Ioo_union_both","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Ioo a b) (Insert.insert a (Singleton.singleton b))) (Set.Icc a b)","decl":"theorem Ioo_union_both (h : a ≤ b) : Ioo a b ∪ {a, b} = Icc a b := by\n  have : (Icc a b \\ {a, b}) ∪ {a, b} = Icc a b := diff_union_of_subset fun\n    | x, .inl rfl => left_mem_Icc.mpr h\n    | x, .inr rfl => right_mem_Icc.mpr h\n  rw [← this, Icc_diff_both]\n\n"}
{"name":"Set.Ioc_union_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\n⊢ Eq (Union.union (Set.Ioc a b) (Singleton.singleton a)) (Set.Icc a b)","decl":"theorem Ioc_union_left (hab : a ≤ b) : Ioc a b ∪ {a} = Icc a b := by\n  rw [← Icc_diff_left, diff_union_self,\n    union_eq_self_of_subset_right (singleton_subset_iff.2 <| left_mem_Icc.2 hab)]\n\n"}
{"name":"Set.Ico_union_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nhab : LE.le a b\n⊢ Eq (Union.union (Set.Ico a b) (Singleton.singleton b)) (Set.Icc a b)","decl":"theorem Ico_union_right (hab : a ≤ b) : Ico a b ∪ {b} = Icc a b := by\n  simpa only [dual_Ioc, dual_Icc] using Ioc_union_left hab.dual\n\n"}
{"name":"Set.Ico_insert_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Insert.insert b (Set.Ico a b)) (Set.Icc a b)","decl":"@[simp]\ntheorem Ico_insert_right (h : a ≤ b) : insert b (Ico a b) = Icc a b := by\n  rw [insert_eq, union_comm, Ico_union_right h]\n\n"}
{"name":"Set.Ioc_insert_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Insert.insert a (Set.Ioc a b)) (Set.Icc a b)","decl":"@[simp]\ntheorem Ioc_insert_left (h : a ≤ b) : insert a (Ioc a b) = Icc a b := by\n  rw [insert_eq, union_comm, Ioc_union_left h]\n\n"}
{"name":"Set.Ioo_insert_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Insert.insert a (Set.Ioo a b)) (Set.Ico a b)","decl":"@[simp]\ntheorem Ioo_insert_left (h : a < b) : insert a (Ioo a b) = Ico a b := by\n  rw [insert_eq, union_comm, Ioo_union_left h]\n\n"}
{"name":"Set.Ioo_insert_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Insert.insert b (Set.Ioo a b)) (Set.Ioc a b)","decl":"@[simp]\ntheorem Ioo_insert_right (h : a < b) : insert b (Ioo a b) = Ioc a b := by\n  rw [insert_eq, union_comm, Ioo_union_right h]\n\n"}
{"name":"Set.Iio_insert","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (Insert.insert a (Set.Iio a)) (Set.Iic a)","decl":"@[simp]\ntheorem Iio_insert : insert a (Iio a) = Iic a :=\n  ext fun _ => le_iff_eq_or_lt.symm\n\n"}
{"name":"Set.Ioi_insert","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\n⊢ Eq (Insert.insert a (Set.Ioi a)) (Set.Ici a)","decl":"@[simp]\ntheorem Ioi_insert : insert a (Ioi a) = Ici a :=\n  ext fun _ => (or_congr_left eq_comm).trans le_iff_eq_or_lt.symm\n\n"}
{"name":"Set.mem_Ici_Ioi_of_subset_of_subset","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\ns : Set α\nho : HasSubset.Subset (Set.Ioi a) s\nhc : HasSubset.Subset s (Set.Ici a)\n⊢ Membership.mem (Insert.insert (Set.Ici a) (Singleton.singleton (Set.Ioi a))) s","decl":"theorem mem_Ici_Ioi_of_subset_of_subset {s : Set α} (ho : Ioi a ⊆ s) (hc : s ⊆ Ici a) :\n    s ∈ ({Ici a, Ioi a} : Set (Set α)) :=\n  by_cases\n    (fun h : a ∈ s =>\n      Or.inl <| Subset.antisymm hc <| by rw [← Ioi_union_left, union_subset_iff]; simp [*])\n    fun h =>\n    Or.inr <| Subset.antisymm (fun _ hx => lt_of_le_of_ne (hc hx) fun heq => h <| heq.symm ▸ hx) ho\n\n"}
{"name":"Set.mem_Iic_Iio_of_subset_of_subset","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\ns : Set α\nho : HasSubset.Subset (Set.Iio a) s\nhc : HasSubset.Subset s (Set.Iic a)\n⊢ Membership.mem (Insert.insert (Set.Iic a) (Singleton.singleton (Set.Iio a))) s","decl":"theorem mem_Iic_Iio_of_subset_of_subset {s : Set α} (ho : Iio a ⊆ s) (hc : s ⊆ Iic a) :\n    s ∈ ({Iic a, Iio a} : Set (Set α)) :=\n  @mem_Ici_Ioi_of_subset_of_subset αᵒᵈ _ a s ho hc\n\n"}
{"name":"Set.mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\ns : Set α\nho : HasSubset.Subset (Set.Ioo a b) s\nhc : HasSubset.Subset s (Set.Icc a b)\n⊢ Membership.mem (Insert.insert (Set.Icc a b) (Insert.insert (Set.Ico a b) (Insert.insert (Set.Ioc a b) (Singleton.singleton (Set.Ioo a b))))) s","decl":"theorem mem_Icc_Ico_Ioc_Ioo_of_subset_of_subset {s : Set α} (ho : Ioo a b ⊆ s) (hc : s ⊆ Icc a b) :\n    s ∈ ({Icc a b, Ico a b, Ioc a b, Ioo a b} : Set (Set α)) := by\n  classical\n    by_cases ha : a ∈ s <;> by_cases hb : b ∈ s\n    · refine Or.inl (Subset.antisymm hc ?_)\n      rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha, ← Icc_diff_right,\n        diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    · refine Or.inr <| Or.inl <| Subset.antisymm ?_ ?_\n      · rw [← Icc_diff_right]\n        exact subset_diff_singleton hc hb\n      · rwa [← Ico_diff_left, diff_singleton_subset_iff, insert_eq_of_mem ha] at ho\n    · refine Or.inr <| Or.inr <| Or.inl <| Subset.antisymm ?_ ?_\n      · rw [← Icc_diff_left]\n        exact subset_diff_singleton hc ha\n      · rwa [← Ioc_diff_right, diff_singleton_subset_iff, insert_eq_of_mem hb] at ho\n    · refine Or.inr <| Or.inr <| Or.inr <| Subset.antisymm ?_ ho\n      rw [← Ico_diff_left, ← Icc_diff_right]\n      apply_rules [subset_diff_singleton]\n\n"}
{"name":"Set.eq_left_or_mem_Ioo_of_mem_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b x : α\nhmem : Membership.mem (Set.Ico a b) x\n⊢ Or (Eq x a) (Membership.mem (Set.Ioo a b) x)","decl":"theorem eq_left_or_mem_Ioo_of_mem_Ico {x : α} (hmem : x ∈ Ico a b) : x = a ∨ x ∈ Ioo a b :=\n  hmem.1.eq_or_gt.imp_right fun h => ⟨h, hmem.2⟩\n\n"}
{"name":"Set.eq_right_or_mem_Ioo_of_mem_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b x : α\nhmem : Membership.mem (Set.Ioc a b) x\n⊢ Or (Eq x b) (Membership.mem (Set.Ioo a b) x)","decl":"theorem eq_right_or_mem_Ioo_of_mem_Ioc {x : α} (hmem : x ∈ Ioc a b) : x = b ∨ x ∈ Ioo a b :=\n  hmem.2.eq_or_lt.imp_right <| And.intro hmem.1\n\n"}
{"name":"Set.eq_endpoints_or_mem_Ioo_of_mem_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b x : α\nhmem : Membership.mem (Set.Icc a b) x\n⊢ Or (Eq x a) (Or (Eq x b) (Membership.mem (Set.Ioo a b) x))","decl":"theorem eq_endpoints_or_mem_Ioo_of_mem_Icc {x : α} (hmem : x ∈ Icc a b) :\n    x = a ∨ x = b ∨ x ∈ Ioo a b :=\n  hmem.1.eq_or_gt.imp_right fun h => eq_right_or_mem_Ioo_of_mem_Ioc ⟨h, hmem.2⟩\n\n"}
{"name":"IsMax.Ici_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\nh : IsMax a\n⊢ Eq (Set.Ici a) (Singleton.singleton a)","decl":"theorem _root_.IsMax.Ici_eq (h : IsMax a) : Ici a = {a} :=\n  eq_singleton_iff_unique_mem.2 ⟨left_mem_Ici, fun _ => h.eq_of_ge⟩\n\n"}
{"name":"IsMin.Iic_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na : α\nh : IsMin a\n⊢ Eq (Set.Iic a) (Singleton.singleton a)","decl":"theorem _root_.IsMin.Iic_eq (h : IsMin a) : Iic a = {a} :=\n  h.toDual.Ici_eq\n\n"}
{"name":"Set.Ici_injective","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Function.Injective Set.Ici","decl":"theorem Ici_injective : Injective (Ici : α → Set α) := fun _ _ =>\n  eq_of_forall_ge_iff ∘ Set.ext_iff.1\n\n"}
{"name":"Set.Iic_injective","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\n⊢ Function.Injective Set.Iic","decl":"theorem Iic_injective : Injective (Iic : α → Set α) := fun _ _ =>\n  eq_of_forall_le_iff ∘ Set.ext_iff.1\n\n"}
{"name":"Set.Ici_inj","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Eq (Set.Ici a) (Set.Ici b)) (Eq a b)","decl":"theorem Ici_inj : Ici a = Ici b ↔ a = b :=\n  Ici_injective.eq_iff\n\n"}
{"name":"Set.Iic_inj","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\na b : α\n⊢ Iff (Eq (Set.Iic a) (Set.Iic b)) (Eq a b)","decl":"theorem Iic_inj : Iic a = Iic b ↔ a = b :=\n  Iic_injective.eq_iff\n\n"}
{"name":"Set.Ici_top","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderTop α\n⊢ Eq (Set.Ici Top.top) (Singleton.singleton Top.top)","decl":"@[simp]\ntheorem Ici_top [PartialOrder α] [OrderTop α] : Ici (⊤ : α) = {⊤} :=\n  isMax_top.Ici_eq\n\n"}
{"name":"Set.Ioi_top","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Eq (Set.Ioi Top.top) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Ioi_top : Ioi (⊤ : α) = ∅ :=\n  isMax_top.Ioi_eq\n\n"}
{"name":"Set.Iic_top","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\n⊢ Eq (Set.Iic Top.top) Set.univ","decl":"@[simp]\ntheorem Iic_top : Iic (⊤ : α) = univ :=\n  isTop_top.Iic_eq\n\n"}
{"name":"Set.Icc_top","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na : α\n⊢ Eq (Set.Icc a Top.top) (Set.Ici a)","decl":"@[simp]\ntheorem Icc_top : Icc a ⊤ = Ici a := by simp [← Ici_inter_Iic]\n\n"}
{"name":"Set.Ioc_top","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderTop α\na : α\n⊢ Eq (Set.Ioc a Top.top) (Set.Ioi a)","decl":"@[simp]\ntheorem Ioc_top : Ioc a ⊤ = Ioi a := by simp [← Ioi_inter_Iic]\n\n"}
{"name":"Set.Iic_bot","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : OrderBot α\n⊢ Eq (Set.Iic Bot.bot) (Singleton.singleton Bot.bot)","decl":"@[simp]\ntheorem Iic_bot [PartialOrder α] [OrderBot α] : Iic (⊥ : α) = {⊥} :=\n  isMin_bot.Iic_eq\n\n"}
{"name":"Set.Iio_bot","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Eq (Set.Iio Bot.bot) EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem Iio_bot : Iio (⊥ : α) = ∅ :=\n  isMin_bot.Iio_eq\n\n"}
{"name":"Set.Ici_bot","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\n⊢ Eq (Set.Ici Bot.bot) Set.univ","decl":"@[simp]\ntheorem Ici_bot : Ici (⊥ : α) = univ :=\n  isBot_bot.Ici_eq\n\n"}
{"name":"Set.Icc_bot","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na : α\n⊢ Eq (Set.Icc Bot.bot a) (Set.Iic a)","decl":"@[simp]\ntheorem Icc_bot : Icc ⊥ a = Iic a := by simp [← Ici_inter_Iic]\n\n"}
{"name":"Set.Ico_bot","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : OrderBot α\na : α\n⊢ Eq (Set.Ico Bot.bot a) (Set.Iio a)","decl":"@[simp]\ntheorem Ico_bot : Ico ⊥ a = Iio a := by simp [← Ici_inter_Iio]\n\n"}
{"name":"Set.Icc_bot_top","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : PartialOrder α\ninst✝ : BoundedOrder α\n⊢ Eq (Set.Icc Bot.bot Top.top) Set.univ","decl":"theorem Icc_bot_top [PartialOrder α] [BoundedOrder α] : Icc (⊥ : α) ⊤ = univ := by simp\n\n"}
{"name":"Set.not_mem_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na c : α\n⊢ Iff (Not (Membership.mem (Set.Ici a) c)) (LT.lt c a)","decl":"theorem not_mem_Ici : c ∉ Ici a ↔ c < a :=\n  not_le\n\n"}
{"name":"Set.not_mem_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c : α\n⊢ Iff (Not (Membership.mem (Set.Iic b) c)) (LT.lt b c)","decl":"theorem not_mem_Iic : c ∉ Iic b ↔ b < c :=\n  not_le\n\n"}
{"name":"Set.not_mem_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na c : α\n⊢ Iff (Not (Membership.mem (Set.Ioi a) c)) (LE.le c a)","decl":"theorem not_mem_Ioi : c ∉ Ioi a ↔ c ≤ a :=\n  not_lt\n\n"}
{"name":"Set.not_mem_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c : α\n⊢ Iff (Not (Membership.mem (Set.Iio b) c)) (LE.le b c)","decl":"theorem not_mem_Iio : c ∉ Iio b ↔ b ≤ c :=\n  not_lt\n\n"}
{"name":"Set.compl_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (HasCompl.compl (Set.Iic a)) (Set.Ioi a)","decl":"@[simp]\ntheorem compl_Iic : (Iic a)ᶜ = Ioi a :=\n  ext fun _ => not_le\n\n"}
{"name":"Set.compl_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (HasCompl.compl (Set.Ici a)) (Set.Iio a)","decl":"@[simp]\ntheorem compl_Ici : (Ici a)ᶜ = Iio a :=\n  ext fun _ => not_le\n\n"}
{"name":"Set.compl_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (HasCompl.compl (Set.Iio a)) (Set.Ici a)","decl":"@[simp]\ntheorem compl_Iio : (Iio a)ᶜ = Ici a :=\n  ext fun _ => not_lt\n\n"}
{"name":"Set.compl_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (HasCompl.compl (Set.Ioi a)) (Set.Iic a)","decl":"@[simp]\ntheorem compl_Ioi : (Ioi a)ᶜ = Iic a :=\n  ext fun _ => not_lt\n\n"}
{"name":"Set.Ici_diff_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Ici a) (Set.Ici b)) (Set.Ico a b)","decl":"@[simp]\ntheorem Ici_diff_Ici : Ici a \\ Ici b = Ico a b := by rw [diff_eq, compl_Ici, Ici_inter_Iio]\n\n"}
{"name":"Set.Ici_diff_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Ici a) (Set.Ioi b)) (Set.Icc a b)","decl":"@[simp]\ntheorem Ici_diff_Ioi : Ici a \\ Ioi b = Icc a b := by rw [diff_eq, compl_Ioi, Ici_inter_Iic]\n\n"}
{"name":"Set.Ioi_diff_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Ioi a) (Set.Ioi b)) (Set.Ioc a b)","decl":"@[simp]\ntheorem Ioi_diff_Ioi : Ioi a \\ Ioi b = Ioc a b := by rw [diff_eq, compl_Ioi, Ioi_inter_Iic]\n\n"}
{"name":"Set.Ioi_diff_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Ioi a) (Set.Ici b)) (Set.Ioo a b)","decl":"@[simp]\ntheorem Ioi_diff_Ici : Ioi a \\ Ici b = Ioo a b := by rw [diff_eq, compl_Ici, Ioi_inter_Iio]\n\n"}
{"name":"Set.Iic_diff_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Iic b) (Set.Iic a)) (Set.Ioc a b)","decl":"@[simp]\ntheorem Iic_diff_Iic : Iic b \\ Iic a = Ioc a b := by\n  rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iic]\n\n"}
{"name":"Set.Iio_diff_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Iio b) (Set.Iic a)) (Set.Ioo a b)","decl":"@[simp]\ntheorem Iio_diff_Iic : Iio b \\ Iic a = Ioo a b := by\n  rw [diff_eq, compl_Iic, inter_comm, Ioi_inter_Iio]\n\n"}
{"name":"Set.Iic_diff_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Iic b) (Set.Iio a)) (Set.Icc a b)","decl":"@[simp]\ntheorem Iic_diff_Iio : Iic b \\ Iio a = Icc a b := by\n  rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iic]\n\n"}
{"name":"Set.Iio_diff_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (SDiff.sdiff (Set.Iio b) (Set.Iio a)) (Set.Ico a b)","decl":"@[simp]\ntheorem Iio_diff_Iio : Iio b \\ Iio a = Ico a b := by\n  rw [diff_eq, compl_Iio, inter_comm, Ici_inter_Iio]\n\n"}
{"name":"Set.Ioi_injective","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Function.Injective Set.Ioi","decl":"theorem Ioi_injective : Injective (Ioi : α → Set α) := fun _ _ =>\n  eq_of_forall_gt_iff ∘ Set.ext_iff.1\n\n"}
{"name":"Set.Iio_injective","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Function.Injective Set.Iio","decl":"theorem Iio_injective : Injective (Iio : α → Set α) := fun _ _ =>\n  eq_of_forall_lt_iff ∘ Set.ext_iff.1\n\n"}
{"name":"Set.Ioi_inj","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (Set.Ioi a) (Set.Ioi b)) (Eq a b)","decl":"theorem Ioi_inj : Ioi a = Ioi b ↔ a = b :=\n  Ioi_injective.eq_iff\n\n"}
{"name":"Set.Iio_inj","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (Eq (Set.Iio a) (Set.Iio b)) (Eq a b)","decl":"theorem Iio_inj : Iio a = Iio b ↔ a = b :=\n  Iio_injective.eq_iff\n\n"}
{"name":"Set.Ico_subset_Ico_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh₁ : LT.lt a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Ico a₁ b₁) (Set.Ico a₂ b₂)) (And (LE.le a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Ico_subset_Ico_iff (h₁ : a₁ < b₁) : Ico a₁ b₁ ⊆ Ico a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h =>\n    have : a₂ ≤ a₁ ∧ a₁ < b₂ := h ⟨le_rfl, h₁⟩\n    ⟨this.1, le_of_not_lt fun h' => lt_irrefl b₂ (h ⟨this.2.le, h'⟩).2⟩,\n    fun ⟨h₁, h₂⟩ => Ico_subset_Ico h₁ h₂⟩\n\n"}
{"name":"Set.Ioc_subset_Ioc_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh₁ : LT.lt a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Ioc a₁ b₁) (Set.Ioc a₂ b₂)) (And (LE.le b₁ b₂) (LE.le a₂ a₁))","decl":"theorem Ioc_subset_Ioc_iff (h₁ : a₁ < b₁) : Ioc a₁ b₁ ⊆ Ioc a₂ b₂ ↔ b₁ ≤ b₂ ∧ a₂ ≤ a₁ := by\n  convert @Ico_subset_Ico_iff αᵒᵈ _ b₁ b₂ a₁ a₂ h₁ using 2 <;> exact (@dual_Ico α _ _ _).symm\n\n"}
{"name":"Set.Ioo_subset_Ioo_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\na₁ a₂ b₁ b₂ : α\ninst✝ : DenselyOrdered α\nh₁ : LT.lt a₁ b₁\n⊢ Iff (HasSubset.Subset (Set.Ioo a₁ b₁) (Set.Ioo a₂ b₂)) (And (LE.le a₂ a₁) (LE.le b₁ b₂))","decl":"theorem Ioo_subset_Ioo_iff [DenselyOrdered α] (h₁ : a₁ < b₁) :\n    Ioo a₁ b₁ ⊆ Ioo a₂ b₂ ↔ a₂ ≤ a₁ ∧ b₁ ≤ b₂ :=\n  ⟨fun h => by\n    rcases exists_between h₁ with ⟨x, xa, xb⟩\n    constructor <;> refine le_of_not_lt fun h' => ?_\n    · have ab := (h ⟨xa, xb⟩).1.trans xb\n      exact lt_irrefl _ (h ⟨h', ab⟩).1\n    · have ab := xa.trans (h ⟨xa, xb⟩).2\n      exact lt_irrefl _ (h ⟨ab, h'⟩).2,\n    fun ⟨h₁, h₂⟩ => Ioo_subset_Ioo h₁ h₂⟩\n\n"}
{"name":"Set.Ico_eq_Ico_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh : Or (LT.lt a₁ b₁) (LT.lt a₂ b₂)\n⊢ Iff (Eq (Set.Ico a₁ b₁) (Set.Ico a₂ b₂)) (And (Eq a₁ a₂) (Eq b₁ b₂))","decl":"theorem Ico_eq_Ico_iff (h : a₁ < b₁ ∨ a₂ < b₂) : Ico a₁ b₁ = Ico a₂ b₂ ↔ a₁ = a₂ ∧ b₁ = b₂ :=\n  ⟨fun e => by\n      simp only [Subset.antisymm_iff] at e\n      simp only [le_antisymm_iff]\n      rcases h with h | h <;>\n      simp only [gt_iff_lt, not_lt, Ico_subset_Ico_iff h] at e <;>\n      [ rcases e with ⟨⟨h₁, h₂⟩, e'⟩; rcases e with ⟨e', ⟨h₁, h₂⟩⟩ ] <;>\n      -- Porting note: restore `tauto`\n      have hab := (Ico_subset_Ico_iff <| h₁.trans_lt <| h.trans_le h₂).1 e' <;>\n      [ exact ⟨⟨hab.left, h₁⟩, ⟨h₂, hab.right⟩⟩; exact ⟨⟨h₁, hab.left⟩, ⟨hab.right, h₂⟩⟩ ],\n    fun ⟨h₁, h₂⟩ => by rw [h₁, h₂]⟩\n\n"}
{"name":"Set.Ici_eq_singleton_iff_isTop","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nx : α\n⊢ Iff (Eq (Set.Ici x) (Singleton.singleton x)) (IsTop x)","decl":"lemma Ici_eq_singleton_iff_isTop {x : α} : (Ici x = {x}) ↔ IsTop x := by\n  refine ⟨fun h y ↦ ?_, fun h ↦ by ext y; simp [(h y).ge_iff_eq]⟩\n  by_contra! H\n  have : y ∈ Ici x := H.le\n  rw [h, mem_singleton_iff] at this\n  exact lt_irrefl y (this.le.trans_lt H)\n\n"}
{"name":"Set.Ioi_subset_Ioi_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (HasSubset.Subset (Set.Ioi b) (Set.Ioi a)) (LE.le a b)","decl":"@[simp]\ntheorem Ioi_subset_Ioi_iff : Ioi b ⊆ Ioi a ↔ a ≤ b := by\n  refine ⟨fun h => ?_, fun h => Ioi_subset_Ioi h⟩\n  by_contra ba\n  exact lt_irrefl _ (h (not_le.mp ba))\n\n"}
{"name":"Set.Ioi_subset_Ici_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : DenselyOrdered α\n⊢ Iff (HasSubset.Subset (Set.Ioi b) (Set.Ici a)) (LE.le a b)","decl":"@[simp]\ntheorem Ioi_subset_Ici_iff [DenselyOrdered α] : Ioi b ⊆ Ici a ↔ a ≤ b := by\n  refine ⟨fun h => ?_, fun h => Ioi_subset_Ici h⟩\n  by_contra ba\n  obtain ⟨c, bc, ca⟩ : ∃ c, b < c ∧ c < a := exists_between (not_le.mp ba)\n  exact lt_irrefl _ (ca.trans_le (h bc))\n\n"}
{"name":"Set.Iio_subset_Iio_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Iff (HasSubset.Subset (Set.Iio a) (Set.Iio b)) (LE.le a b)","decl":"@[simp]\ntheorem Iio_subset_Iio_iff : Iio a ⊆ Iio b ↔ a ≤ b := by\n  refine ⟨fun h => ?_, fun h => Iio_subset_Iio h⟩\n  by_contra ab\n  exact lt_irrefl _ (h (not_le.mp ab))\n\n"}
{"name":"Set.Iio_subset_Iic_iff","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrder α\na b : α\ninst✝ : DenselyOrdered α\n⊢ Iff (HasSubset.Subset (Set.Iio a) (Set.Iic b)) (LE.le a b)","decl":"@[simp]\ntheorem Iio_subset_Iic_iff [DenselyOrdered α] : Iio a ⊆ Iic b ↔ a ≤ b := by\n  rw [← diff_eq_empty, Iio_diff_Iic, Ioo_eq_empty_iff, not_lt]\n\n"}
{"name":"Set.Iic_union_Ioi_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iic b) (Set.Ioi a)) Set.univ","decl":"theorem Iic_union_Ioi_of_le (h : a ≤ b) : Iic b ∪ Ioi a = univ :=\n  eq_univ_of_forall fun x => (h.lt_or_le x).symm\n\n"}
{"name":"Set.Iio_union_Ici_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iio b) (Set.Ici a)) Set.univ","decl":"theorem Iio_union_Ici_of_le (h : a ≤ b) : Iio b ∪ Ici a = univ :=\n  eq_univ_of_forall fun x => (h.le_or_lt x).symm\n\n"}
{"name":"Set.Iic_union_Ici_of_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iic b) (Set.Ici a)) Set.univ","decl":"theorem Iic_union_Ici_of_le (h : a ≤ b) : Iic b ∪ Ici a = univ :=\n  eq_univ_of_forall fun x => (h.le_or_le x).symm\n\n"}
{"name":"Set.Iio_union_Ioi_of_lt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Union.union (Set.Iio b) (Set.Ioi a)) Set.univ","decl":"theorem Iio_union_Ioi_of_lt (h : a < b) : Iio b ∪ Ioi a = univ :=\n  eq_univ_of_forall fun x => (h.lt_or_lt x).symm\n\n"}
{"name":"Set.Iic_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Union.union (Set.Iic a) (Set.Ici a)) Set.univ","decl":"@[simp]\ntheorem Iic_union_Ici : Iic a ∪ Ici a = univ :=\n  Iic_union_Ici_of_le le_rfl\n\n"}
{"name":"Set.Iio_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Union.union (Set.Iio a) (Set.Ici a)) Set.univ","decl":"@[simp]\ntheorem Iio_union_Ici : Iio a ∪ Ici a = univ :=\n  Iio_union_Ici_of_le le_rfl\n\n"}
{"name":"Set.Iic_union_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Union.union (Set.Iic a) (Set.Ioi a)) Set.univ","decl":"@[simp]\ntheorem Iic_union_Ioi : Iic a ∪ Ioi a = univ :=\n  Iic_union_Ioi_of_le le_rfl\n\n"}
{"name":"Set.Iio_union_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na : α\n⊢ Eq (Union.union (Set.Iio a) (Set.Ioi a)) (HasCompl.compl (Singleton.singleton a))","decl":"@[simp]\ntheorem Iio_union_Ioi : Iio a ∪ Ioi a = {a}ᶜ :=\n  ext fun _ => lt_or_lt_iff_ne\n\n"}
{"name":"Set.Ioo_union_Ioi'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt c b\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Ioi c)) (Set.Ioi (Min.min a c))","decl":"theorem Ioo_union_Ioi' (h₁ : c < b) : Ioo a b ∪ Ioi c = Ioi (min a c) := by\n  ext1 x\n  simp_rw [mem_union, mem_Ioo, mem_Ioi, min_lt_iff]\n  by_cases hc : c < x\n  · simp only [hc, or_true] -- Porting note: restore `tauto`\n  · have hxb : x < b := (le_of_not_gt hc).trans_lt h₁\n    simp only [hxb, and_true] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Ioo_union_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh : LT.lt c (Max.max a b)\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Ioi c)) (Set.Ioi (Min.min a c))","decl":"theorem Ioo_union_Ioi (h : c < max a b) : Ioo a b ∪ Ioi c = Ioi (min a c) := by\n  rcases le_total a b with hab | hab <;> simp [hab] at h\n  · exact Ioo_union_Ioi' h\n  · rw [min_comm]\n    simp [*, min_eq_left_of_lt]\n\n"}
{"name":"Set.Ioi_subset_Ioo_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioi a) (Union.union (Set.Ioo a b) (Set.Ici b))","decl":"theorem Ioi_subset_Ioo_union_Ici : Ioi a ⊆ Ioo a b ∪ Ici b := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨hx, hxb⟩) fun hxb => Or.inr hxb\n\n"}
{"name":"Set.Ioo_union_Ici_eq_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Ici b)) (Set.Ioi a)","decl":"@[simp]\ntheorem Ioo_union_Ici_eq_Ioi (h : a < b) : Ioo a b ∪ Ici b = Ioi a :=\n  Subset.antisymm (fun _ hx => hx.elim And.left h.trans_le) Ioi_subset_Ioo_union_Ici\n\n"}
{"name":"Set.Ici_subset_Ico_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ici a) (Union.union (Set.Ico a b) (Set.Ici b))","decl":"theorem Ici_subset_Ico_union_Ici : Ici a ⊆ Ico a b ∪ Ici b := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨hx, hxb⟩) fun hxb => Or.inr hxb\n\n"}
{"name":"Set.Ico_union_Ici_eq_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Ico a b) (Set.Ici b)) (Set.Ici a)","decl":"@[simp]\ntheorem Ico_union_Ici_eq_Ici (h : a ≤ b) : Ico a b ∪ Ici b = Ici a :=\n  Subset.antisymm (fun _ hx => hx.elim And.left h.trans) Ici_subset_Ico_union_Ici\n\n"}
{"name":"Set.Ico_union_Ici'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le c b\n⊢ Eq (Union.union (Set.Ico a b) (Set.Ici c)) (Set.Ici (Min.min a c))","decl":"theorem Ico_union_Ici' (h₁ : c ≤ b) : Ico a b ∪ Ici c = Ici (min a c) := by\n  ext1 x\n  simp_rw [mem_union, mem_Ico, mem_Ici, min_le_iff]\n  by_cases hc : c ≤ x\n  · simp only [hc, or_true] -- Porting note: restore `tauto`\n  · have hxb : x < b := (lt_of_not_ge hc).trans_le h₁\n    simp only [hxb, and_true] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Ico_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh : LE.le c (Max.max a b)\n⊢ Eq (Union.union (Set.Ico a b) (Set.Ici c)) (Set.Ici (Min.min a c))","decl":"theorem Ico_union_Ici (h : c ≤ max a b) : Ico a b ∪ Ici c = Ici (min a c) := by\n  rcases le_total a b with hab | hab <;> simp [hab] at h\n  · exact Ico_union_Ici' h\n  · simp [*]\n\n"}
{"name":"Set.Ioi_subset_Ioc_union_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioi a) (Union.union (Set.Ioc a b) (Set.Ioi b))","decl":"theorem Ioi_subset_Ioc_union_Ioi : Ioi a ⊆ Ioc a b ∪ Ioi b := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => Or.inl ⟨hx, hxb⟩) fun hxb => Or.inr hxb\n\n"}
{"name":"Set.Ioc_union_Ioi_eq_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioi b)) (Set.Ioi a)","decl":"@[simp]\ntheorem Ioc_union_Ioi_eq_Ioi (h : a ≤ b) : Ioc a b ∪ Ioi b = Ioi a :=\n  Subset.antisymm (fun _ hx => hx.elim And.left h.trans_lt) Ioi_subset_Ioc_union_Ioi\n\n"}
{"name":"Set.Ioc_union_Ioi'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le c b\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioi c)) (Set.Ioi (Min.min a c))","decl":"theorem Ioc_union_Ioi' (h₁ : c ≤ b) : Ioc a b ∪ Ioi c = Ioi (min a c) := by\n  ext1 x\n  simp_rw [mem_union, mem_Ioc, mem_Ioi, min_lt_iff]\n  by_cases hc : c < x\n  · simp only [hc, or_true] -- Porting note: restore `tauto`\n  · have hxb : x ≤ b := (le_of_not_gt hc).trans h₁\n    simp only [hxb, and_true] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Ioc_union_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh : LE.le c (Max.max a b)\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioi c)) (Set.Ioi (Min.min a c))","decl":"theorem Ioc_union_Ioi (h : c ≤ max a b) : Ioc a b ∪ Ioi c = Ioi (min a c) := by\n  rcases le_total a b with hab | hab <;> simp [hab] at h\n  · exact Ioc_union_Ioi' h\n  · simp [*]\n\n"}
{"name":"Set.Ici_subset_Icc_union_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ici a) (Union.union (Set.Icc a b) (Set.Ioi b))","decl":"theorem Ici_subset_Icc_union_Ioi : Ici a ⊆ Icc a b ∪ Ioi b := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => Or.inl ⟨hx, hxb⟩) fun hxb => Or.inr hxb\n\n"}
{"name":"Set.Icc_union_Ioi_eq_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ioi b)) (Set.Ici a)","decl":"@[simp]\ntheorem Icc_union_Ioi_eq_Ici (h : a ≤ b) : Icc a b ∪ Ioi b = Ici a :=\n  Subset.antisymm (fun _ hx => (hx.elim And.left) fun hx' => h.trans <| le_of_lt hx')\n    Ici_subset_Icc_union_Ioi\n\n"}
{"name":"Set.Ioi_subset_Ioc_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ioi a) (Union.union (Set.Ioc a b) (Set.Ici b))","decl":"theorem Ioi_subset_Ioc_union_Ici : Ioi a ⊆ Ioc a b ∪ Ici b :=\n  Subset.trans Ioi_subset_Ioo_union_Ici (union_subset_union_left _ Ioo_subset_Ioc_self)\n\n"}
{"name":"Set.Ioc_union_Ici_eq_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ici b)) (Set.Ioi a)","decl":"@[simp]\ntheorem Ioc_union_Ici_eq_Ioi (h : a < b) : Ioc a b ∪ Ici b = Ioi a :=\n  Subset.antisymm (fun _ hx => hx.elim And.left h.trans_le) Ioi_subset_Ioc_union_Ici\n\n"}
{"name":"Set.Ici_subset_Icc_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Ici a) (Union.union (Set.Icc a b) (Set.Ici b))","decl":"theorem Ici_subset_Icc_union_Ici : Ici a ⊆ Icc a b ∪ Ici b :=\n  Subset.trans Ici_subset_Ico_union_Ici (union_subset_union_left _ Ico_subset_Icc_self)\n\n"}
{"name":"Set.Icc_union_Ici_eq_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ici b)) (Set.Ici a)","decl":"@[simp]\ntheorem Icc_union_Ici_eq_Ici (h : a ≤ b) : Icc a b ∪ Ici b = Ici a :=\n  Subset.antisymm (fun _ hx => hx.elim And.left h.trans) Ici_subset_Icc_union_Ici\n\n"}
{"name":"Set.Icc_union_Ici'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le c b\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ici c)) (Set.Ici (Min.min a c))","decl":"theorem Icc_union_Ici' (h₁ : c ≤ b) : Icc a b ∪ Ici c = Ici (min a c) := by\n  ext1 x\n  simp_rw [mem_union, mem_Icc, mem_Ici, min_le_iff]\n  by_cases hc : c ≤ x\n  · simp only [hc, or_true] -- Porting note: restore `tauto`\n  · have hxb : x ≤ b := (le_of_not_ge hc).trans h₁\n    simp only [hxb, and_true] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Icc_union_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh : LE.le c (Max.max a b)\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ici c)) (Set.Ici (Min.min a c))","decl":"theorem Icc_union_Ici (h : c ≤ max a b) : Icc a b ∪ Ici c = Ici (min a c) := by\n  rcases le_or_lt a b with hab | hab <;> simp [hab] at h\n  · exact Icc_union_Ici' h\n  · rcases h with h | h\n    · simp [*]\n    · have hca : c ≤ a := h.trans hab.le\n      simp [*]\n\n"}
{"name":"Set.Iic_subset_Iio_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Iic b) (Union.union (Set.Iio a) (Set.Icc a b))","decl":"theorem Iic_subset_Iio_union_Icc : Iic b ⊆ Iio a ∪ Icc a b := fun x hx =>\n  (lt_or_le x a).elim (fun hxa => Or.inl hxa) fun hxa => Or.inr ⟨hxa, hx⟩\n\n"}
{"name":"Set.Iio_union_Icc_eq_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iio a) (Set.Icc a b)) (Set.Iic b)","decl":"@[simp]\ntheorem Iio_union_Icc_eq_Iic (h : a ≤ b) : Iio a ∪ Icc a b = Iic b :=\n  Subset.antisymm (fun _ hx => hx.elim (fun hx => (le_of_lt hx).trans h) And.right)\n    Iic_subset_Iio_union_Icc\n\n"}
{"name":"Set.Iio_subset_Iio_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Iio b) (Union.union (Set.Iio a) (Set.Ico a b))","decl":"theorem Iio_subset_Iio_union_Ico : Iio b ⊆ Iio a ∪ Ico a b := fun x hx =>\n  (lt_or_le x a).elim (fun hxa => Or.inl hxa) fun hxa => Or.inr ⟨hxa, hx⟩\n\n"}
{"name":"Set.Iio_union_Ico_eq_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iio a) (Set.Ico a b)) (Set.Iio b)","decl":"@[simp]\ntheorem Iio_union_Ico_eq_Iio (h : a ≤ b) : Iio a ∪ Ico a b = Iio b :=\n  Subset.antisymm (fun _ hx => hx.elim (fun hx' => lt_of_lt_of_le hx' h) And.right)\n    Iio_subset_Iio_union_Ico\n\n"}
{"name":"Set.Iio_union_Ico'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh₁ : LE.le c b\n⊢ Eq (Union.union (Set.Iio b) (Set.Ico c d)) (Set.Iio (Max.max b d))","decl":"theorem Iio_union_Ico' (h₁ : c ≤ b) : Iio b ∪ Ico c d = Iio (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Iio, mem_Ico, lt_max_iff]\n  by_cases hc : c ≤ x\n  · simp only [hc, true_and] -- Porting note: restore `tauto`\n  · have hxb : x < b := (lt_of_not_ge hc).trans_le h₁\n    simp only [hxb, true_or] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Iio_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh : LE.le (Min.min c d) b\n⊢ Eq (Union.union (Set.Iio b) (Set.Ico c d)) (Set.Iio (Max.max b d))","decl":"theorem Iio_union_Ico (h : min c d ≤ b) : Iio b ∪ Ico c d = Iio (max b d) := by\n  rcases le_total c d with hcd | hcd <;> simp [hcd] at h\n  · exact Iio_union_Ico' h\n  · simp [*]\n\n"}
{"name":"Set.Iic_subset_Iic_union_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Iic b) (Union.union (Set.Iic a) (Set.Ioc a b))","decl":"theorem Iic_subset_Iic_union_Ioc : Iic b ⊆ Iic a ∪ Ioc a b := fun x hx =>\n  (le_or_lt x a).elim (fun hxa => Or.inl hxa) fun hxa => Or.inr ⟨hxa, hx⟩\n\n"}
{"name":"Set.Iic_union_Ioc_eq_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iic a) (Set.Ioc a b)) (Set.Iic b)","decl":"@[simp]\ntheorem Iic_union_Ioc_eq_Iic (h : a ≤ b) : Iic a ∪ Ioc a b = Iic b :=\n  Subset.antisymm (fun _ hx => hx.elim (fun hx' => le_trans hx' h) And.right)\n    Iic_subset_Iic_union_Ioc\n\n"}
{"name":"Set.Iic_union_Ioc'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh₁ : LT.lt c b\n⊢ Eq (Union.union (Set.Iic b) (Set.Ioc c d)) (Set.Iic (Max.max b d))","decl":"theorem Iic_union_Ioc' (h₁ : c < b) : Iic b ∪ Ioc c d = Iic (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Iic, mem_Ioc, le_max_iff]\n  by_cases hc : c < x\n  · simp only [hc, true_and] -- Porting note: restore `tauto`\n  · have hxb : x ≤ b := (le_of_not_gt hc).trans h₁.le\n    simp only [hxb, true_or] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Iic_union_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh : LT.lt (Min.min c d) b\n⊢ Eq (Union.union (Set.Iic b) (Set.Ioc c d)) (Set.Iic (Max.max b d))","decl":"theorem Iic_union_Ioc (h : min c d < b) : Iic b ∪ Ioc c d = Iic (max b d) := by\n  rcases le_total c d with hcd | hcd <;> simp [hcd] at h\n  · exact Iic_union_Ioc' h\n  · rw [max_comm]\n    simp [*, max_eq_right_of_lt h]\n\n"}
{"name":"Set.Iio_subset_Iic_union_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Iio b) (Union.union (Set.Iic a) (Set.Ioo a b))","decl":"theorem Iio_subset_Iic_union_Ioo : Iio b ⊆ Iic a ∪ Ioo a b := fun x hx =>\n  (le_or_lt x a).elim (fun hxa => Or.inl hxa) fun hxa => Or.inr ⟨hxa, hx⟩\n\n"}
{"name":"Set.Iic_union_Ioo_eq_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Union.union (Set.Iic a) (Set.Ioo a b)) (Set.Iio b)","decl":"@[simp]\ntheorem Iic_union_Ioo_eq_Iio (h : a < b) : Iic a ∪ Ioo a b = Iio b :=\n  Subset.antisymm (fun _ hx => hx.elim (fun hx' => lt_of_le_of_lt hx' h) And.right)\n    Iio_subset_Iic_union_Ioo\n\n"}
{"name":"Set.Iio_union_Ioo'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh₁ : LT.lt c b\n⊢ Eq (Union.union (Set.Iio b) (Set.Ioo c d)) (Set.Iio (Max.max b d))","decl":"theorem Iio_union_Ioo' (h₁ : c < b) : Iio b ∪ Ioo c d = Iio (max b d) := by\n  ext x\n  rcases lt_or_le x b with hba | hba\n  · simp [hba, h₁]\n  · simp only [mem_Iio, mem_union, mem_Ioo, lt_max_iff]\n    refine or_congr Iff.rfl ⟨And.right, ?_⟩\n    exact fun h₂ => ⟨h₁.trans_le hba, h₂⟩\n\n"}
{"name":"Set.Iio_union_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh : LT.lt (Min.min c d) b\n⊢ Eq (Union.union (Set.Iio b) (Set.Ioo c d)) (Set.Iio (Max.max b d))","decl":"theorem Iio_union_Ioo (h : min c d < b) : Iio b ∪ Ioo c d = Iio (max b d) := by\n  rcases le_total c d with hcd | hcd <;> simp [hcd] at h\n  · exact Iio_union_Ioo' h\n  · rw [max_comm]\n    simp [*, max_eq_right_of_lt h]\n\n"}
{"name":"Set.Iic_subset_Iic_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Iic b) (Union.union (Set.Iic a) (Set.Icc a b))","decl":"theorem Iic_subset_Iic_union_Icc : Iic b ⊆ Iic a ∪ Icc a b :=\n  Subset.trans Iic_subset_Iic_union_Ioc (union_subset_union_right _ Ioc_subset_Icc_self)\n\n"}
{"name":"Set.Iic_union_Icc_eq_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LE.le a b\n⊢ Eq (Union.union (Set.Iic a) (Set.Icc a b)) (Set.Iic b)","decl":"@[simp]\ntheorem Iic_union_Icc_eq_Iic (h : a ≤ b) : Iic a ∪ Icc a b = Iic b :=\n  Subset.antisymm (fun _ hx => hx.elim (fun hx' => le_trans hx' h) And.right)\n    Iic_subset_Iic_union_Icc\n\n"}
{"name":"Set.Iic_union_Icc'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh₁ : LE.le c b\n⊢ Eq (Union.union (Set.Iic b) (Set.Icc c d)) (Set.Iic (Max.max b d))","decl":"theorem Iic_union_Icc' (h₁ : c ≤ b) : Iic b ∪ Icc c d = Iic (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Iic, mem_Icc, le_max_iff]\n  by_cases hc : c ≤ x\n  · simp only [hc, true_and] -- Porting note: restore `tauto`\n  · have hxb : x ≤ b := (le_of_not_ge hc).trans h₁\n    simp only [hxb, true_or] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Iic_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\nb c d : α\nh : LE.le (Min.min c d) b\n⊢ Eq (Union.union (Set.Iic b) (Set.Icc c d)) (Set.Iic (Max.max b d))","decl":"theorem Iic_union_Icc (h : min c d ≤ b) : Iic b ∪ Icc c d = Iic (max b d) := by\n  rcases le_or_lt c d with hcd | hcd <;> simp [hcd] at h\n  · exact Iic_union_Icc' h\n  · rcases h with h | h\n    · have hdb : d ≤ b := hcd.le.trans h\n      simp [*]\n    · simp [*]\n\n"}
{"name":"Set.Iio_subset_Iic_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ HasSubset.Subset (Set.Iio b) (Union.union (Set.Iic a) (Set.Ico a b))","decl":"theorem Iio_subset_Iic_union_Ico : Iio b ⊆ Iic a ∪ Ico a b :=\n  Subset.trans Iio_subset_Iic_union_Ioo (union_subset_union_right _ Ioo_subset_Ico_self)\n\n"}
{"name":"Set.Iic_union_Ico_eq_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\nh : LT.lt a b\n⊢ Eq (Union.union (Set.Iic a) (Set.Ico a b)) (Set.Iio b)","decl":"@[simp]\ntheorem Iic_union_Ico_eq_Iio (h : a < b) : Iic a ∪ Ico a b = Iio b :=\n  Subset.antisymm (fun _ hx => hx.elim (fun hx' => lt_of_le_of_lt hx' h) And.right)\n    Iio_subset_Iic_union_Ico\n\n"}
{"name":"Set.Ioo_subset_Ioo_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ioo a c) (Union.union (Set.Ioo a b) (Set.Ico b c))","decl":"theorem Ioo_subset_Ioo_union_Ico : Ioo a c ⊆ Ioo a b ∪ Ico b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Ioo_union_Ico_eq_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Ico b c)) (Set.Ioo a c)","decl":"@[simp]\ntheorem Ioo_union_Ico_eq_Ioo (h₁ : a < b) (h₂ : b ≤ c) : Ioo a b ∪ Ico b c = Ioo a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_le h₂⟩) fun hx => ⟨h₁.trans_le hx.1, hx.2⟩)\n    Ioo_subset_Ioo_union_Ico\n\n"}
{"name":"Set.Ico_subset_Ico_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ico a c) (Union.union (Set.Ico a b) (Set.Ico b c))","decl":"theorem Ico_subset_Ico_union_Ico : Ico a c ⊆ Ico a b ∪ Ico b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Ico_union_Ico_eq_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Ico a b) (Set.Ico b c)) (Set.Ico a c)","decl":"@[simp]\ntheorem Ico_union_Ico_eq_Ico (h₁ : a ≤ b) (h₂ : b ≤ c) : Ico a b ∪ Ico b c = Ico a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_le h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Ico_subset_Ico_union_Ico\n\n"}
{"name":"Set.Ico_union_Ico'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LE.le c b\nh₂ : LE.le a d\n⊢ Eq (Union.union (Set.Ico a b) (Set.Ico c d)) (Set.Ico (Min.min a c) (Max.max b d))","decl":"theorem Ico_union_Ico' (h₁ : c ≤ b) (h₂ : a ≤ d) : Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Ico, min_le_iff, lt_max_iff]\n  by_cases hc : c ≤ x <;> by_cases hd : x < d\n  · simp only [hc, hd, and_self, or_true] -- Porting note: restore `tauto`\n  · have hax : a ≤ x := h₂.trans (le_of_not_gt hd)\n    simp only [hax, true_and, hc, or_self] -- Porting note: restore `tauto`\n  · have hxb : x < b := (lt_of_not_ge hc).trans_le h₁\n    simp only [hxb, and_true, hc, false_and, or_false, true_or] -- Porting note: restore `tauto`\n  · simp only [hc, hd, and_self, or_false] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Ico_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LE.le (Min.min a b) (Max.max c d)\nh₂ : LE.le (Min.min c d) (Max.max a b)\n⊢ Eq (Union.union (Set.Ico a b) (Set.Ico c d)) (Set.Ico (Min.min a c) (Max.max b d))","decl":"theorem Ico_union_Ico (h₁ : min a b ≤ max c d) (h₂ : min c d ≤ max a b) :\n    Ico a b ∪ Ico c d = Ico (min a c) (max b d) := by\n  rcases le_total a b with hab | hab <;> rcases le_total c d with hcd | hcd <;> simp [*] at h₁ h₂\n  · exact Ico_union_Ico' h₂ h₁\n  all_goals simp [*]\n\n"}
{"name":"Set.Icc_subset_Ico_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Icc a c) (Union.union (Set.Ico a b) (Set.Icc b c))","decl":"theorem Icc_subset_Ico_union_Icc : Icc a c ⊆ Ico a b ∪ Icc b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Ico_union_Icc_eq_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Ico a b) (Set.Icc b c)) (Set.Icc a c)","decl":"@[simp]\ntheorem Ico_union_Icc_eq_Icc (h₁ : a ≤ b) (h₂ : b ≤ c) : Ico a b ∪ Icc b c = Icc a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.le.trans h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Icc_subset_Ico_union_Icc\n\n"}
{"name":"Set.Ioc_subset_Ioo_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ioc a c) (Union.union (Set.Ioo a b) (Set.Icc b c))","decl":"theorem Ioc_subset_Ioo_union_Icc : Ioc a c ⊆ Ioo a b ∪ Icc b c := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Ioo_union_Icc_eq_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Icc b c)) (Set.Ioc a c)","decl":"@[simp]\ntheorem Ioo_union_Icc_eq_Ioc (h₁ : a < b) (h₂ : b ≤ c) : Ioo a b ∪ Icc b c = Ioc a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.le.trans h₂⟩) fun hx => ⟨h₁.trans_le hx.1, hx.2⟩)\n    Ioc_subset_Ioo_union_Icc\n\n"}
{"name":"Set.Ioo_subset_Ioc_union_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ioo a c) (Union.union (Set.Ioc a b) (Set.Ioo b c))","decl":"theorem Ioo_subset_Ioc_union_Ioo : Ioo a c ⊆ Ioc a b ∪ Ioo b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Ioc_union_Ioo_eq_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LT.lt b c\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioo b c)) (Set.Ioo a c)","decl":"@[simp]\ntheorem Ioc_union_Ioo_eq_Ioo (h₁ : a ≤ b) (h₂ : b < c) : Ioc a b ∪ Ioo b c = Ioo a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_lt h₂⟩) fun hx => ⟨h₁.trans_lt hx.1, hx.2⟩)\n    Ioo_subset_Ioc_union_Ioo\n\n"}
{"name":"Set.Ico_subset_Icc_union_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ico a c) (Union.union (Set.Icc a b) (Set.Ioo b c))","decl":"theorem Ico_subset_Icc_union_Ioo : Ico a c ⊆ Icc a b ∪ Ioo b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Icc_union_Ioo_eq_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LT.lt b c\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ioo b c)) (Set.Ico a c)","decl":"@[simp]\ntheorem Icc_union_Ioo_eq_Ico (h₁ : a ≤ b) (h₂ : b < c) : Icc a b ∪ Ioo b c = Ico a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_lt h₂⟩) fun hx => ⟨h₁.trans hx.1.le, hx.2⟩)\n    Ico_subset_Icc_union_Ioo\n\n"}
{"name":"Set.Icc_subset_Icc_union_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Icc a c) (Union.union (Set.Icc a b) (Set.Ioc b c))","decl":"theorem Icc_subset_Icc_union_Ioc : Icc a c ⊆ Icc a b ∪ Ioc b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Icc_union_Ioc_eq_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ioc b c)) (Set.Icc a c)","decl":"@[simp]\ntheorem Icc_union_Ioc_eq_Icc (h₁ : a ≤ b) (h₂ : b ≤ c) : Icc a b ∪ Ioc b c = Icc a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans hx.1.le, hx.2⟩)\n    Icc_subset_Icc_union_Ioc\n\n"}
{"name":"Set.Ioc_subset_Ioc_union_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ioc a c) (Union.union (Set.Ioc a b) (Set.Ioc b c))","decl":"theorem Ioc_subset_Ioc_union_Ioc : Ioc a c ⊆ Ioc a b ∪ Ioc b c := fun x hx =>\n  (le_or_lt x b).elim (fun hxb => Or.inl ⟨hx.1, hxb⟩) fun hxb => Or.inr ⟨hxb, hx.2⟩\n\n"}
{"name":"Set.Ioc_union_Ioc_eq_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioc b c)) (Set.Ioc a c)","decl":"@[simp]\ntheorem Ioc_union_Ioc_eq_Ioc (h₁ : a ≤ b) (h₂ : b ≤ c) : Ioc a b ∪ Ioc b c = Ioc a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans_lt hx.1, hx.2⟩)\n    Ioc_subset_Ioc_union_Ioc\n\n"}
{"name":"Set.Ioc_union_Ioc'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LE.le c b\nh₂ : LE.le a d\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioc c d)) (Set.Ioc (Min.min a c) (Max.max b d))","decl":"theorem Ioc_union_Ioc' (h₁ : c ≤ b) (h₂ : a ≤ d) : Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Ioc, min_lt_iff, le_max_iff]\n  by_cases hc : c < x <;> by_cases hd : x ≤ d\n  · simp only [hc, hd, and_self, or_true] -- Porting note: restore `tauto`\n  · have hax : a < x := h₂.trans_lt (lt_of_not_ge hd)\n    simp only [hax, true_and, hc, or_self] -- Porting note: restore `tauto`\n  · have hxb : x ≤ b := (le_of_not_gt hc).trans h₁\n    simp only [hxb, and_true, hc, false_and, or_false, true_or] -- Porting note: restore `tauto`\n  · simp only [hc, hd, and_self, or_false] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Ioc_union_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LE.le (Min.min a b) (Max.max c d)\nh₂ : LE.le (Min.min c d) (Max.max a b)\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioc c d)) (Set.Ioc (Min.min a c) (Max.max b d))","decl":"theorem Ioc_union_Ioc (h₁ : min a b ≤ max c d) (h₂ : min c d ≤ max a b) :\n    Ioc a b ∪ Ioc c d = Ioc (min a c) (max b d) := by\n  rcases le_total a b with hab | hab <;> rcases le_total c d with hcd | hcd <;> simp [*] at h₁ h₂\n  · exact Ioc_union_Ioc' h₂ h₁\n  all_goals simp [*]\n\n"}
{"name":"Set.Ioo_subset_Ioc_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ioo a c) (Union.union (Set.Ioc a b) (Set.Ico b c))","decl":"theorem Ioo_subset_Ioc_union_Ico : Ioo a c ⊆ Ioc a b ∪ Ico b c :=\n  Subset.trans Ioo_subset_Ioc_union_Ioo (union_subset_union_right _ Ioo_subset_Ico_self)\n\n"}
{"name":"Set.Ioc_union_Ico_eq_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt a b\nh₂ : LT.lt b c\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ico b c)) (Set.Ioo a c)","decl":"@[simp]\ntheorem Ioc_union_Ico_eq_Ioo (h₁ : a < b) (h₂ : b < c) : Ioc a b ∪ Ico b c = Ioo a c :=\n  Subset.antisymm\n    (fun _ hx =>\n      hx.elim (fun hx' => ⟨hx'.1, hx'.2.trans_lt h₂⟩) fun hx' => ⟨h₁.trans_le hx'.1, hx'.2⟩)\n    Ioo_subset_Ioc_union_Ico\n\n"}
{"name":"Set.Ico_subset_Icc_union_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ico a c) (Union.union (Set.Icc a b) (Set.Ico b c))","decl":"theorem Ico_subset_Icc_union_Ico : Ico a c ⊆ Icc a b ∪ Ico b c :=\n  Subset.trans Ico_subset_Icc_union_Ioo (union_subset_union_right _ Ioo_subset_Ico_self)\n\n"}
{"name":"Set.Icc_union_Ico_eq_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LT.lt b c\n⊢ Eq (Union.union (Set.Icc a b) (Set.Ico b c)) (Set.Ico a c)","decl":"@[simp]\ntheorem Icc_union_Ico_eq_Ico (h₁ : a ≤ b) (h₂ : b < c) : Icc a b ∪ Ico b c = Ico a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans_lt h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Ico_subset_Icc_union_Ico\n\n"}
{"name":"Set.Icc_subset_Icc_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Icc a c) (Union.union (Set.Icc a b) (Set.Icc b c))","decl":"theorem Icc_subset_Icc_union_Icc : Icc a c ⊆ Icc a b ∪ Icc b c :=\n  Subset.trans Icc_subset_Icc_union_Ioc (union_subset_union_right _ Ioc_subset_Icc_self)\n\n"}
{"name":"Set.Icc_union_Icc_eq_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LE.le a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Icc a b) (Set.Icc b c)) (Set.Icc a c)","decl":"@[simp]\ntheorem Icc_union_Icc_eq_Icc (h₁ : a ≤ b) (h₂ : b ≤ c) : Icc a b ∪ Icc b c = Icc a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans hx.1, hx.2⟩)\n    Icc_subset_Icc_union_Icc\n\n"}
{"name":"Set.Icc_union_Icc'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LE.le c b\nh₂ : LE.le a d\n⊢ Eq (Union.union (Set.Icc a b) (Set.Icc c d)) (Set.Icc (Min.min a c) (Max.max b d))","decl":"theorem Icc_union_Icc' (h₁ : c ≤ b) (h₂ : a ≤ d) : Icc a b ∪ Icc c d = Icc (min a c) (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Icc, min_le_iff, le_max_iff]\n  by_cases hc : c ≤ x <;> by_cases hd : x ≤ d\n  · simp only [hc, hd, and_self, or_true] -- Porting note: restore `tauto`\n  · have hax : a ≤ x := h₂.trans (le_of_not_ge hd)\n    simp only [hax, true_and, hc, or_self] -- Porting note: restore `tauto`\n  · have hxb : x ≤ b := (le_of_not_ge hc).trans h₁\n    simp only [hxb, and_true, hc, false_and, or_false, true_or] -- Porting note: restore `tauto`\n  · simp only [hc, hd, and_self, or_false] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Icc_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LT.lt (Min.min a b) (Max.max c d)\nh₂ : LT.lt (Min.min c d) (Max.max a b)\n⊢ Eq (Union.union (Set.Icc a b) (Set.Icc c d)) (Set.Icc (Min.min a c) (Max.max b d))","decl":"/-- We cannot replace `<` by `≤` in the hypotheses.\nOtherwise for `b < a = d < c` the l.h.s. is `∅` and the r.h.s. is `{a}`.\n-/\ntheorem Icc_union_Icc (h₁ : min a b < max c d) (h₂ : min c d < max a b) :\n    Icc a b ∪ Icc c d = Icc (min a c) (max b d) := by\n  rcases le_or_lt a b with hab | hab <;> rcases le_or_lt c d with hcd | hcd <;>\n    simp only [min_eq_left, min_eq_right, max_eq_left, max_eq_right, min_eq_left_of_lt,\n      min_eq_right_of_lt, max_eq_left_of_lt, max_eq_right_of_lt, hab, hcd] at h₁ h₂\n  · exact Icc_union_Icc' h₂.le h₁.le\n  all_goals simp [*, min_eq_left_of_lt, max_eq_left_of_lt, min_eq_right_of_lt, max_eq_right_of_lt]\n\n"}
{"name":"Set.Ioc_subset_Ioc_union_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ HasSubset.Subset (Set.Ioc a c) (Union.union (Set.Ioc a b) (Set.Icc b c))","decl":"theorem Ioc_subset_Ioc_union_Icc : Ioc a c ⊆ Ioc a b ∪ Icc b c :=\n  Subset.trans Ioc_subset_Ioc_union_Ioc (union_subset_union_right _ Ioc_subset_Icc_self)\n\n"}
{"name":"Set.Ioc_union_Icc_eq_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\nh₁ : LT.lt a b\nh₂ : LE.le b c\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Icc b c)) (Set.Ioc a c)","decl":"@[simp]\ntheorem Ioc_union_Icc_eq_Ioc (h₁ : a < b) (h₂ : b ≤ c) : Ioc a b ∪ Icc b c = Ioc a c :=\n  Subset.antisymm\n    (fun _ hx => hx.elim (fun hx => ⟨hx.1, hx.2.trans h₂⟩) fun hx => ⟨h₁.trans_le hx.1, hx.2⟩)\n    Ioc_subset_Ioc_union_Icc\n\n"}
{"name":"Set.Ioo_union_Ioo'","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LT.lt c b\nh₂ : LT.lt a d\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Ioo c d)) (Set.Ioo (Min.min a c) (Max.max b d))","decl":"theorem Ioo_union_Ioo' (h₁ : c < b) (h₂ : a < d) : Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d) := by\n  ext1 x\n  simp_rw [mem_union, mem_Ioo, min_lt_iff, lt_max_iff]\n  by_cases hc : c < x <;> by_cases hd : x < d\n  · simp only [hc, hd, and_self, or_true] -- Porting note: restore `tauto`\n  · have hax : a < x := h₂.trans_le (le_of_not_lt hd)\n    simp only [hax, true_and, hc, or_self] -- Porting note: restore `tauto`\n  · have hxb : x < b := (le_of_not_lt hc).trans_lt h₁\n    simp only [hxb, and_true, hc, false_and, or_false, true_or] -- Porting note: restore `tauto`\n  · simp only [hc, hd, and_self, or_false] -- Porting note: restore `tauto`\n\n"}
{"name":"Set.Ioo_union_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c d : α\nh₁ : LT.lt (Min.min a b) (Max.max c d)\nh₂ : LT.lt (Min.min c d) (Max.max a b)\n⊢ Eq (Union.union (Set.Ioo a b) (Set.Ioo c d)) (Set.Ioo (Min.min a c) (Max.max b d))","decl":"theorem Ioo_union_Ioo (h₁ : min a b < max c d) (h₂ : min c d < max a b) :\n    Ioo a b ∪ Ioo c d = Ioo (min a c) (max b d) := by\n  rcases le_total a b with hab | hab <;> rcases le_total c d with hcd | hcd <;>\n    simp only [min_eq_left, min_eq_right, max_eq_left, max_eq_right, hab, hcd] at h₁ h₂\n  · exact Ioo_union_Ioo' h₂ h₁\n  all_goals\n    simp [*, min_eq_left_of_lt, min_eq_right_of_lt, max_eq_left_of_lt, max_eq_right_of_lt,\n      le_of_lt h₂, le_of_lt h₁]\n\n"}
{"name":"Set.Ioo_subset_Ioo_union_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na a₁ b b₁ c d : α\nh₁ : LE.le a a₁\nh₂ : LT.lt c b\nh₃ : LE.le b₁ d\n⊢ HasSubset.Subset (Set.Ioo a₁ b₁) (Union.union (Set.Ioo a b) (Set.Ioo c d))","decl":"theorem Ioo_subset_Ioo_union_Ioo (h₁ : a ≤ a₁) (h₂ : c < b) (h₃ : b₁ ≤ d) :\n    Ioo a₁ b₁ ⊆ Ioo a b ∪ Ioo c d := fun x hx =>\n  (lt_or_le x b).elim (fun hxb => Or.inl ⟨lt_of_le_of_lt h₁ hx.1, hxb⟩)\n    fun hxb => Or.inr ⟨lt_of_lt_of_le h₂ hxb, lt_of_lt_of_le hx.2 h₃⟩\n\n"}
{"name":"Set.Iic_inter_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b : α\n⊢ Eq (Inter.inter (Set.Iic a) (Set.Iic b)) (Set.Iic (Min.min a b))","decl":"@[simp]\ntheorem Iic_inter_Iic {a b : α} : Iic a ∩ Iic b = Iic (a ⊓ b) := by\n  ext x\n  simp [Iic]\n\n"}
{"name":"Set.Ioc_inter_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : SemilatticeInf α\na b c : α\n⊢ Eq (Inter.inter (Set.Ioc a b) (Set.Iic c)) (Set.Ioc a (Min.min b c))","decl":"@[simp]\ntheorem Ioc_inter_Iic (a b c : α) : Ioc a b ∩ Iic c = Ioc a (b ⊓ c) := by\n  rw [← Ioi_inter_Iic, ← Ioi_inter_Iic, inter_assoc, Iic_inter_Iic]\n\n"}
{"name":"Set.Ici_inter_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b : α\n⊢ Eq (Inter.inter (Set.Ici a) (Set.Ici b)) (Set.Ici (Max.max a b))","decl":"@[simp]\ntheorem Ici_inter_Ici {a b : α} : Ici a ∩ Ici b = Ici (a ⊔ b) := by\n  ext x\n  simp [Ici]\n\n"}
{"name":"Set.Ico_inter_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\na b c : α\n⊢ Eq (Inter.inter (Set.Ico a b) (Set.Ici c)) (Set.Ico (Max.max a c) b)","decl":"@[simp]\ntheorem Ico_inter_Ici (a b c : α) : Ico a b ∩ Ici c = Ico (a ⊔ c) b := by\n  rw [← Ici_inter_Iio, ← Ici_inter_Iio, ← Ici_inter_Ici, inter_right_comm]\n\n"}
{"name":"Set.Icc_inter_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na₁ a₂ b₁ b₂ : α\n⊢ Eq (Inter.inter (Set.Icc a₁ b₁) (Set.Icc a₂ b₂)) (Set.Icc (Max.max a₁ a₂) (Min.min b₁ b₂))","decl":"theorem Icc_inter_Icc : Icc a₁ b₁ ∩ Icc a₂ b₂ = Icc (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by\n  simp only [Ici_inter_Iic.symm, Ici_inter_Ici.symm, Iic_inter_Iic.symm]; ac_rfl\n\n"}
{"name":"Set.Icc_inter_Icc_eq_singleton","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Lattice α\na b c : α\nhab : LE.le a b\nhbc : LE.le b c\n⊢ Eq (Inter.inter (Set.Icc a b) (Set.Icc b c)) (Singleton.singleton b)","decl":"@[simp]\ntheorem Icc_inter_Icc_eq_singleton (hab : a ≤ b) (hbc : b ≤ c) : Icc a b ∩ Icc b c = {b} := by\n  rw [Icc_inter_Icc, sup_of_le_right hab, inf_of_le_left hbc, Icc_self]\n\n"}
{"name":"Set.Ioi_inter_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Inter.inter (Set.Ioi a) (Set.Ioi b)) (Set.Ioi (Max.max a b))","decl":"@[simp]\ntheorem Ioi_inter_Ioi : Ioi a ∩ Ioi b = Ioi (a ⊔ b) :=\n  ext fun _ => sup_lt_iff.symm\n\n"}
{"name":"Set.Iio_inter_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Inter.inter (Set.Iio a) (Set.Iio b)) (Set.Iio (Min.min a b))","decl":"@[simp]\ntheorem Iio_inter_Iio : Iio a ∩ Iio b = Iio (a ⊓ b) :=\n  ext fun _ => lt_inf_iff.symm\n\n"}
{"name":"Set.Ico_inter_Ico","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Eq (Inter.inter (Set.Ico a₁ b₁) (Set.Ico a₂ b₂)) (Set.Ico (Max.max a₁ a₂) (Min.min b₁ b₂))","decl":"theorem Ico_inter_Ico : Ico a₁ b₁ ∩ Ico a₂ b₂ = Ico (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by\n  simp only [Ici_inter_Iio.symm, Ici_inter_Ici.symm, Iio_inter_Iio.symm]; ac_rfl\n\n"}
{"name":"Set.Ioc_inter_Ioc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Eq (Inter.inter (Set.Ioc a₁ b₁) (Set.Ioc a₂ b₂)) (Set.Ioc (Max.max a₁ a₂) (Min.min b₁ b₂))","decl":"theorem Ioc_inter_Ioc : Ioc a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by\n  simp only [Ioi_inter_Iic.symm, Ioi_inter_Ioi.symm, Iic_inter_Iic.symm]; ac_rfl\n\n"}
{"name":"Set.Ioo_inter_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\n⊢ Eq (Inter.inter (Set.Ioo a₁ b₁) (Set.Ioo a₂ b₂)) (Set.Ioo (Max.max a₁ a₂) (Min.min b₁ b₂))","decl":"theorem Ioo_inter_Ioo : Ioo a₁ b₁ ∩ Ioo a₂ b₂ = Ioo (a₁ ⊔ a₂) (b₁ ⊓ b₂) := by\n  simp only [Ioi_inter_Iio.symm, Ioi_inter_Ioi.symm, Iio_inter_Iio.symm]; ac_rfl\n\n"}
{"name":"Set.Ioo_inter_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Inter.inter (Set.Ioo a b) (Set.Iio c)) (Set.Ioo a (Min.min b c))","decl":"theorem Ioo_inter_Iio : Ioo a b ∩ Iio c = Ioo a (min b c) := by\n  ext\n  simp_rw [mem_inter_iff, mem_Ioo, mem_Iio, lt_min_iff, and_assoc]\n\n"}
{"name":"Set.Iio_inter_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Inter.inter (Set.Iio a) (Set.Ioo b c)) (Set.Ioo b (Min.min a c))","decl":"theorem Iio_inter_Ioo : Iio a ∩ Ioo b c = Ioo b (min a c) := by\n  rw [Set.inter_comm, Set.Ioo_inter_Iio, min_comm]\n\n"}
{"name":"Set.Ioo_inter_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Inter.inter (Set.Ioo a b) (Set.Ioi c)) (Set.Ioo (Max.max a c) b)","decl":"theorem Ioo_inter_Ioi : Ioo a b ∩ Ioi c = Ioo (max a c) b := by\n  ext\n  simp_rw [mem_inter_iff, mem_Ioo, mem_Ioi, max_lt_iff, and_assoc, and_comm]\n\n"}
{"name":"Set.Ioi_inter_Ioo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Inter.inter (Set.Ioi a) (Set.Ioo b c)) (Set.Ioo (Max.max a b) c)","decl":"theorem Ioi_inter_Ioo : Set.Ioi a ∩ Set.Ioo b c = Set.Ioo (max a b) c := by\n  rw [inter_comm, Ioo_inter_Ioi, max_comm]\n\n"}
{"name":"Set.Ioc_inter_Ioo_of_left_lt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh : LT.lt b₁ b₂\n⊢ Eq (Inter.inter (Set.Ioc a₁ b₁) (Set.Ioo a₂ b₂)) (Set.Ioc (Max.max a₁ a₂) b₁)","decl":"theorem Ioc_inter_Ioo_of_left_lt (h : b₁ < b₂) : Ioc a₁ b₁ ∩ Ioo a₂ b₂ = Ioc (max a₁ a₂) b₁ :=\n  ext fun x => by\n    simp [and_assoc, @and_left_comm (x ≤ _), and_iff_left_iff_imp.2 fun h' => lt_of_le_of_lt h' h]\n\n"}
{"name":"Set.Ioc_inter_Ioo_of_right_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh : LE.le b₂ b₁\n⊢ Eq (Inter.inter (Set.Ioc a₁ b₁) (Set.Ioo a₂ b₂)) (Set.Ioo (Max.max a₁ a₂) b₂)","decl":"theorem Ioc_inter_Ioo_of_right_le (h : b₂ ≤ b₁) : Ioc a₁ b₁ ∩ Ioo a₂ b₂ = Ioo (max a₁ a₂) b₂ :=\n  ext fun x => by\n    simp [and_assoc, @and_left_comm (x ≤ _),\n      and_iff_right_iff_imp.2 fun h' => (le_of_lt h').trans h]\n\n"}
{"name":"Set.Ioo_inter_Ioc_of_left_le","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh : LE.le b₁ b₂\n⊢ Eq (Inter.inter (Set.Ioo a₁ b₁) (Set.Ioc a₂ b₂)) (Set.Ioo (Max.max a₁ a₂) b₁)","decl":"theorem Ioo_inter_Ioc_of_left_le (h : b₁ ≤ b₂) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioo (max a₁ a₂) b₁ := by\n  rw [inter_comm, Ioc_inter_Ioo_of_right_le h, max_comm]\n\n"}
{"name":"Set.Ioo_inter_Ioc_of_right_lt","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na₁ a₂ b₁ b₂ : α\nh : LT.lt b₂ b₁\n⊢ Eq (Inter.inter (Set.Ioo a₁ b₁) (Set.Ioc a₂ b₂)) (Set.Ioc (Max.max a₁ a₂) b₂)","decl":"theorem Ioo_inter_Ioc_of_right_lt (h : b₂ < b₁) : Ioo a₁ b₁ ∩ Ioc a₂ b₂ = Ioc (max a₁ a₂) b₂ := by\n  rw [inter_comm, Ioc_inter_Ioo_of_left_lt h, max_comm]\n\n"}
{"name":"Set.Ico_diff_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (SDiff.sdiff (Set.Ico a b) (Set.Iio c)) (Set.Ico (Max.max a c) b)","decl":"@[simp]\ntheorem Ico_diff_Iio : Ico a b \\ Iio c = Ico (max a c) b := by\n  rw [diff_eq, compl_Iio, Ico_inter_Ici]\n\n"}
{"name":"Set.Ioc_diff_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (SDiff.sdiff (Set.Ioc a b) (Set.Ioi c)) (Set.Ioc a (Min.min b c))","decl":"@[simp]\ntheorem Ioc_diff_Ioi : Ioc a b \\ Ioi c = Ioc a (min b c) :=\n  ext <| by simp +contextual [iff_def]\n\n"}
{"name":"Set.Ioc_inter_Ioi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Inter.inter (Set.Ioc a b) (Set.Ioi c)) (Set.Ioc (Max.max a c) b)","decl":"@[simp]\ntheorem Ioc_inter_Ioi : Ioc a b ∩ Ioi c = Ioc (a ⊔ c) b := by\n  rw [← Ioi_inter_Iic, inter_assoc, inter_comm, inter_assoc, Ioi_inter_Ioi, inter_comm,\n    Ioi_inter_Iic, sup_comm]\n\n"}
{"name":"Set.Ico_inter_Iio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Inter.inter (Set.Ico a b) (Set.Iio c)) (Set.Ico a (Min.min b c))","decl":"@[simp]\ntheorem Ico_inter_Iio : Ico a b ∩ Iio c = Ico a (min b c) :=\n  ext <| by simp +contextual [iff_def]\n\n"}
{"name":"Set.Ioc_diff_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (SDiff.sdiff (Set.Ioc a b) (Set.Iic c)) (Set.Ioc (Max.max a c) b)","decl":"@[simp]\ntheorem Ioc_diff_Iic : Ioc a b \\ Iic c = Ioc (max a c) b := by\n  rw [diff_eq, compl_Iic, Ioc_inter_Ioi]\n\n"}
{"name":"Set.Ioc_union_Ioc_right","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioc a c)) (Set.Ioc a (Max.max b c))","decl":"@[simp]\ntheorem Ioc_union_Ioc_right : Ioc a b ∪ Ioc a c = Ioc a (max b c) := by\n  rw [Ioc_union_Ioc, min_self] <;> exact (min_le_left _ _).trans (le_max_left _ _)\n\n"}
{"name":"Set.Ioc_union_Ioc_left","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Union.union (Set.Ioc a c) (Set.Ioc b c)) (Set.Ioc (Min.min a b) c)","decl":"@[simp]\ntheorem Ioc_union_Ioc_left : Ioc a c ∪ Ioc b c = Ioc (min a b) c := by\n  rw [Ioc_union_Ioc, max_self] <;> exact (min_le_right _ _).trans (le_max_right _ _)\n\n"}
{"name":"Set.Ioc_union_Ioc_symm","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b : α\n⊢ Eq (Union.union (Set.Ioc a b) (Set.Ioc b a)) (Set.Ioc (Min.min a b) (Max.max a b))","decl":"@[simp]\ntheorem Ioc_union_Ioc_symm : Ioc a b ∪ Ioc b a = Ioc (min a b) (max a b) := by\n  rw [max_comm]\n  apply Ioc_union_Ioc <;> rw [max_comm] <;> exact min_le_max\n\n"}
{"name":"Set.Ioc_union_Ioc_union_Ioc_cycle","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Eq (Union.union (Union.union (Set.Ioc a b) (Set.Ioc b c)) (Set.Ioc c a)) (Set.Ioc (Min.min a (Min.min b c)) (Max.max a (Max.max b c)))","decl":"@[simp]\ntheorem Ioc_union_Ioc_union_Ioc_cycle :\n    Ioc a b ∪ Ioc b c ∪ Ioc c a = Ioc (min a (min b c)) (max a (max b c)) := by\n  rw [Ioc_union_Ioc, Ioc_union_Ioc]\n  · ac_rfl\n  all_goals\n  solve_by_elim (config := { maxDepth := 5 }) [min_le_of_left_le, min_le_of_right_le,\n       le_max_of_le_left, le_max_of_le_right, le_refl]\n\n"}
{"name":"Set.Iic_prod_Iic","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\n⊢ Eq (SProd.sprod (Set.Iic a) (Set.Iic b)) (Set.Iic { fst := a, snd := b })","decl":"@[simp]\ntheorem Iic_prod_Iic (a : α) (b : β) : Iic a ×ˢ Iic b = Iic (a, b) :=\n  rfl\n\n"}
{"name":"Set.Ici_prod_Ici","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : α\nb : β\n⊢ Eq (SProd.sprod (Set.Ici a) (Set.Ici b)) (Set.Ici { fst := a, snd := b })","decl":"@[simp]\ntheorem Ici_prod_Ici (a : α) (b : β) : Ici a ×ˢ Ici b = Ici (a, b) :=\n  rfl\n\n"}
{"name":"Set.Ici_prod_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : Prod α β\n⊢ Eq (Set.Ici a) (SProd.sprod (Set.Ici a.fst) (Set.Ici a.snd))","decl":"theorem Ici_prod_eq (a : α × β) : Ici a = Ici a.1 ×ˢ Ici a.2 :=\n  rfl\n\n"}
{"name":"Set.Iic_prod_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na : Prod α β\n⊢ Eq (Set.Iic a) (SProd.sprod (Set.Iic a.fst) (Set.Iic a.snd))","decl":"theorem Iic_prod_eq (a : α × β) : Iic a = Iic a.1 ×ˢ Iic a.2 :=\n  rfl\n\n"}
{"name":"Set.Icc_prod_Icc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na₁ a₂ : α\nb₁ b₂ : β\n⊢ Eq (SProd.sprod (Set.Icc a₁ a₂) (Set.Icc b₁ b₂)) (Set.Icc { fst := a₁, snd := b₁ } { fst := a₂, snd := b₂ })","decl":"@[simp]\ntheorem Icc_prod_Icc (a₁ a₂ : α) (b₁ b₂ : β) : Icc a₁ a₂ ×ˢ Icc b₁ b₂ = Icc (a₁, b₁) (a₂, b₂) := by\n  ext ⟨x, y⟩\n  simp [and_assoc, and_comm, and_left_comm]\n\n"}
{"name":"Set.Icc_prod_eq","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\na b : Prod α β\n⊢ Eq (Set.Icc a b) (SProd.sprod (Set.Icc a.fst b.fst) (Set.Icc a.snd b.snd))","decl":"theorem Icc_prod_eq (a b : α × β) : Icc a b = Icc a.1 b.1 ×ˢ Icc a.2 b.2 := by simp\n\n"}
{"name":"instNoMinOrderElemIoo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ NoMinOrder ↑(Set.Ioo x y)","decl":"instance : NoMinOrder (Set.Ioo x y) :=\n  ⟨fun ⟨a, ha₁, ha₂⟩ => by\n    rcases exists_between ha₁ with ⟨b, hb₁, hb₂⟩\n    exact ⟨⟨b, hb₁, hb₂.trans ha₂⟩, hb₂⟩⟩\n\n"}
{"name":"instNoMinOrderElemIoc","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ NoMinOrder ↑(Set.Ioc x y)","decl":"instance : NoMinOrder (Set.Ioc x y) :=\n  ⟨fun ⟨a, ha₁, ha₂⟩ => by\n    rcases exists_between ha₁ with ⟨b, hb₁, hb₂⟩\n    exact ⟨⟨b, hb₁, hb₂.le.trans ha₂⟩, hb₂⟩⟩\n\n"}
{"name":"instNoMinOrderElemIoi","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ NoMinOrder ↑(Set.Ioi x)","decl":"instance : NoMinOrder (Set.Ioi x) :=\n  ⟨fun ⟨a, ha⟩ => by\n    rcases exists_between ha with ⟨b, hb₁, hb₂⟩\n    exact ⟨⟨b, hb₁⟩, hb₂⟩⟩\n\n"}
{"name":"instNoMaxOrderElemIoo","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ NoMaxOrder ↑(Set.Ioo x y)","decl":"instance : NoMaxOrder (Set.Ioo x y) :=\n  ⟨fun ⟨a, ha₁, ha₂⟩ => by\n    rcases exists_between ha₂ with ⟨b, hb₁, hb₂⟩\n    exact ⟨⟨b, ha₁.trans hb₁, hb₂⟩, hb₁⟩⟩\n\n"}
{"name":"instNoMaxOrderElemIco","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\n⊢ NoMaxOrder ↑(Set.Ico x y)","decl":"instance : NoMaxOrder (Set.Ico x y) :=\n  ⟨fun ⟨a, ha₁, ha₂⟩ => by\n    rcases exists_between ha₂ with ⟨b, hb₁, hb₂⟩\n    exact ⟨⟨b, ha₁.trans hb₁.le, hb₂⟩, hb₁⟩⟩\n\n"}
{"name":"instNoMaxOrderElemIio","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx : α\n⊢ NoMaxOrder ↑(Set.Iio x)","decl":"instance : NoMaxOrder (Set.Iio x) :=\n  ⟨fun ⟨a, ha⟩ => by\n    rcases exists_between ha with ⟨b, hb₁, hb₂⟩\n    exact ⟨⟨b, hb₂⟩, hb₁⟩⟩\n\n"}
{"name":"Set.Iic_False","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Iic False) (Singleton.singleton False)","decl":"@[simp] lemma Iic_False : Iic False = {False} := by aesop\n"}
{"name":"Set.Iic_True","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Iic True) Set.univ","decl":"@[simp] lemma Iic_True : Iic True = univ := by aesop\n"}
{"name":"Set.Ici_False","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Ici False) Set.univ","decl":"@[simp] lemma Ici_False : Ici False = univ := by aesop\n"}
{"name":"Set.Ici_True","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Ici True) (Singleton.singleton True)","decl":"@[simp] lemma Ici_True : Ici True = {True} := by aesop\n"}
{"name":"Set.Iio_False","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Iio False) EmptyCollection.emptyCollection","decl":"@[simp] lemma Iio_False : Iio False = ∅ := by aesop\n"}
{"name":"Set.Iio_True","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Iio True) (Singleton.singleton False)","decl":"@[simp] lemma Iio_True : Iio True = {False} := by aesop (add simp [Ioi, lt_iff_le_not_le])\n"}
{"name":"Set.Ioi_False","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Ioi False) (Singleton.singleton True)","decl":"@[simp] lemma Ioi_False : Ioi False = {True} := by aesop (add simp [Ioi, lt_iff_le_not_le])\n"}
{"name":"Set.Ioi_True","module":"Mathlib.Order.Interval.Set.Basic","initialProofState":"⊢ Eq (Set.Ioi True) EmptyCollection.emptyCollection","decl":"@[simp] lemma Ioi_True : Ioi True = ∅ := by aesop\n\n"}
