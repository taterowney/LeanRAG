{"name":"TruncatedWittVector.ext","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\nx y : TruncatedWittVector p n R\nh : ∀ (i : Fin n), Eq (TruncatedWittVector.coeff i x) (TruncatedWittVector.coeff i y)\n⊢ Eq x y","decl":"@[ext]\ntheorem ext {x y : TruncatedWittVector p n R} (h : ∀ i, x.coeff i = y.coeff i) : x = y :=\n  funext h\n\n"}
{"name":"TruncatedWittVector.ext_iff","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\nx y : TruncatedWittVector p n R\n⊢ Iff (Eq x y) (∀ (i : Fin n), Eq (TruncatedWittVector.coeff i x) (TruncatedWittVector.coeff i y))","decl":"@[ext]\ntheorem ext {x y : TruncatedWittVector p n R} (h : ∀ i, x.coeff i = y.coeff i) : x = y :=\n  funext h\n\n"}
{"name":"TruncatedWittVector.coeff_mk","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\nx : Fin n → R\ni : Fin n\n⊢ Eq (TruncatedWittVector.coeff i (TruncatedWittVector.mk p x)) (x i)","decl":"@[simp]\ntheorem coeff_mk (x : Fin n → R) (i : Fin n) : (mk p x).coeff i = x i :=\n  rfl\n\n"}
{"name":"TruncatedWittVector.mk_coeff","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\nx : TruncatedWittVector p n R\n⊢ Eq (TruncatedWittVector.mk p fun i => TruncatedWittVector.coeff i x) x","decl":"@[simp]\ntheorem mk_coeff (x : TruncatedWittVector p n R) : (mk p fun i => x.coeff i) = x := by\n  ext i; rw [coeff_mk]\n\n"}
{"name":"TruncatedWittVector.coeff_out","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝ : CommRing R\nx : TruncatedWittVector p n R\ni : Fin n\n⊢ Eq (x.out.coeff ↑i) (TruncatedWittVector.coeff i x)","decl":"@[simp]\ntheorem coeff_out (x : TruncatedWittVector p n R) (i : Fin n) : x.out.coeff i = x.coeff i := by\n  rw [out]; dsimp only; rw [dif_pos i.is_lt, Fin.eta]\n\n"}
{"name":"TruncatedWittVector.out_injective","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝ : CommRing R\n⊢ Function.Injective TruncatedWittVector.out","decl":"theorem out_injective : Injective (@out p n R _) := by\n  intro x y h\n  ext i\n  rw [WittVector.ext_iff] at h\n  simpa only [coeff_out] using h ↑i\n\n"}
{"name":"WittVector.coeff_truncateFun","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\nx : WittVector p R\ni : Fin n\n⊢ Eq (TruncatedWittVector.coeff i (WittVector.truncateFun n x)) (x.coeff ↑i)","decl":"@[simp]\ntheorem coeff_truncateFun (x : 𝕎 R) (i : Fin n) : (truncateFun n x).coeff i = x.coeff i := by\n  rw [truncateFun, TruncatedWittVector.coeff_mk]\n\n"}
{"name":"WittVector.out_truncateFun","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝ : CommRing R\nx : WittVector p R\n⊢ Eq (WittVector.truncateFun n x).out (WittVector.init n x)","decl":"@[simp]\ntheorem out_truncateFun (x : 𝕎 R) : (truncateFun n x).out = init n x := by\n  ext i\n  dsimp [TruncatedWittVector.out, init, select, coeff_mk]\n  split_ifs with hi; swap; · rfl\n  rw [coeff_truncateFun, Fin.val_mk]\n\n"}
{"name":"TruncatedWittVector.truncateFun_out","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝ : CommRing R\nx : TruncatedWittVector p n R\n⊢ Eq (WittVector.truncateFun n x.out) x","decl":"@[simp]\ntheorem truncateFun_out (x : TruncatedWittVector p n R) : x.out.truncateFun n = x := by\n  simp only [WittVector.truncateFun, coeff_out, mk_coeff]\n\n"}
{"name":"TruncatedWittVector.coeff_zero","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\ni : Fin n\n⊢ Eq (TruncatedWittVector.coeff i 0) 0","decl":"@[simp]\ntheorem coeff_zero (i : Fin n) : (0 : TruncatedWittVector p n R).coeff i = 0 := by\n  show coeff i (truncateFun _ 0 : TruncatedWittVector p n R) = 0\n  rw [coeff_truncateFun, WittVector.zero_coeff]\n\n"}
{"name":"WittVector.truncateFun_surjective","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝ : CommRing R\n⊢ Function.Surjective (WittVector.truncateFun n)","decl":"theorem truncateFun_surjective : Surjective (@truncateFun p n R) :=\n  Function.RightInverse.surjective TruncatedWittVector.truncateFun_out\n\n"}
{"name":"WittVector.truncateFun_zero","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (WittVector.truncateFun n 0) 0","decl":"@[simp]\ntheorem truncateFun_zero : truncateFun n (0 : 𝕎 R) = 0 := rfl\n\n"}
{"name":"WittVector.truncateFun_one","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (WittVector.truncateFun n 1) 1","decl":"@[simp]\ntheorem truncateFun_one : truncateFun n (1 : 𝕎 R) = 1 := rfl\n\n"}
{"name":"WittVector.truncateFun_add","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx y : WittVector p R\n⊢ Eq (WittVector.truncateFun n (HAdd.hAdd x y)) (HAdd.hAdd (WittVector.truncateFun n x) (WittVector.truncateFun n y))","decl":"@[simp]\ntheorem truncateFun_add (x y : 𝕎 R) :\n    truncateFun n (x + y) = truncateFun n x + truncateFun n y := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_mul","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx y : WittVector p R\n⊢ Eq (WittVector.truncateFun n (HMul.hMul x y)) (HMul.hMul (WittVector.truncateFun n x) (WittVector.truncateFun n y))","decl":"@[simp]\ntheorem truncateFun_mul (x y : 𝕎 R) :\n    truncateFun n (x * y) = truncateFun n x * truncateFun n y := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_neg","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\n⊢ Eq (WittVector.truncateFun n (Neg.neg x)) (Neg.neg (WittVector.truncateFun n x))","decl":"theorem truncateFun_neg (x : 𝕎 R) : truncateFun n (-x) = -truncateFun n x := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_sub","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx y : WittVector p R\n⊢ Eq (WittVector.truncateFun n (HSub.hSub x y)) (HSub.hSub (WittVector.truncateFun n x) (WittVector.truncateFun n y))","decl":"theorem truncateFun_sub (x y : 𝕎 R) :\n    truncateFun n (x - y) = truncateFun n x - truncateFun n y := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_nsmul","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nx : WittVector p R\n⊢ Eq (WittVector.truncateFun n (HSMul.hSMul m x)) (HSMul.hSMul m (WittVector.truncateFun n x))","decl":"theorem truncateFun_nsmul (m : ℕ) (x : 𝕎 R) : truncateFun n (m • x) = m • truncateFun n x := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_zsmul","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Int\nx : WittVector p R\n⊢ Eq (WittVector.truncateFun n (HSMul.hSMul m x)) (HSMul.hSMul m (WittVector.truncateFun n x))","decl":"theorem truncateFun_zsmul (m : ℤ) (x : 𝕎 R) : truncateFun n (m • x) = m • truncateFun n x := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_pow","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\nm : Nat\n⊢ Eq (WittVector.truncateFun n (HPow.hPow x m)) (HPow.hPow (WittVector.truncateFun n x) m)","decl":"theorem truncateFun_pow (x : 𝕎 R) (m : ℕ) : truncateFun n (x ^ m) = truncateFun n x ^ m := by\n  witt_truncateFun_tac\n\n"}
{"name":"WittVector.truncateFun_natCast","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\n⊢ Eq (WittVector.truncateFun n ↑m) ↑m","decl":"theorem truncateFun_natCast (m : ℕ) : truncateFun n (m : 𝕎 R) = m := rfl\n\n"}
{"name":"WittVector.truncateFun_intCast","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Int\n⊢ Eq (WittVector.truncateFun n ↑m) ↑m","decl":"theorem truncateFun_intCast (m : ℤ) : truncateFun n (m : 𝕎 R) = m := rfl\n\n"}
{"name":"WittVector.truncate_surjective","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\n⊢ Function.Surjective ⇑(WittVector.truncate n)","decl":"theorem truncate_surjective : Surjective (truncate n : 𝕎 R → TruncatedWittVector p n R) :=\n  truncateFun_surjective p n R\n\n"}
{"name":"WittVector.coeff_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\ni : Fin n\n⊢ Eq (TruncatedWittVector.coeff i ((WittVector.truncate n) x)) (x.coeff ↑i)","decl":"@[simp]\ntheorem coeff_truncate (x : 𝕎 R) (i : Fin n) : (truncate n x).coeff i = x.coeff i :=\n  coeff_truncateFun _ _\n\n"}
{"name":"WittVector.mem_ker_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nx : WittVector p R\n⊢ Iff (Membership.mem (RingHom.ker (WittVector.truncate n)) x) (∀ (i : Nat), LT.lt i n → Eq (x.coeff i) 0)","decl":"theorem mem_ker_truncate (x : 𝕎 R) :\n    x ∈ RingHom.ker (truncate (p := p) n) ↔ ∀ i < n, x.coeff i = 0 := by\n  simp only [RingHom.mem_ker, truncate, truncateFun, RingHom.coe_mk, TruncatedWittVector.ext_iff,\n    TruncatedWittVector.coeff_mk, coeff_zero]\n  exact Fin.forall_iff\n\n"}
{"name":"WittVector.truncate_mk'","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nf : Nat → R\n⊢ Eq ((WittVector.truncate n) { coeff := f }) (TruncatedWittVector.mk p fun k => f ↑k)","decl":"@[simp]\ntheorem truncate_mk' (f : ℕ → R) :\n    truncate n (@mk' p _ f) = TruncatedWittVector.mk _ fun k => f k := by\n  ext i\n  simp only [coeff_truncate, TruncatedWittVector.coeff_mk]\n\n"}
{"name":"TruncatedWittVector.truncate_comp_wittVector_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nhm : LE.le n m\n⊢ Eq ((TruncatedWittVector.truncate hm).comp (WittVector.truncate m)) (WittVector.truncate n)","decl":"@[simp]\ntheorem truncate_comp_wittVector_truncate {m : ℕ} (hm : n ≤ m) :\n    (truncate (p := p) (R := R) hm).comp (WittVector.truncate m) = WittVector.truncate n :=\n  RingHom.liftOfRightInverse_comp _ _ _ _\n\n"}
{"name":"TruncatedWittVector.truncate_wittVector_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nhm : LE.le n m\nx : WittVector p R\n⊢ Eq ((TruncatedWittVector.truncate hm) ((WittVector.truncate m) x)) ((WittVector.truncate n) x)","decl":"@[simp]\ntheorem truncate_wittVector_truncate {m : ℕ} (hm : n ≤ m) (x : 𝕎 R) :\n    truncate hm (WittVector.truncate m x) = WittVector.truncate n x :=\n  RingHom.liftOfRightInverse_comp_apply _ _ _ _ _\n\n"}
{"name":"TruncatedWittVector.truncate_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nn₁ n₂ n₃ : Nat\nh1 : LE.le n₁ n₂\nh2 : LE.le n₂ n₃\nx : TruncatedWittVector p n₃ R\n⊢ Eq ((TruncatedWittVector.truncate h1) ((TruncatedWittVector.truncate h2) x)) ((TruncatedWittVector.truncate ⋯) x)","decl":"@[simp]\ntheorem truncate_truncate {n₁ n₂ n₃ : ℕ} (h1 : n₁ ≤ n₂) (h2 : n₂ ≤ n₃)\n    (x : TruncatedWittVector p n₃ R) :\n    (truncate h1) (truncate h2 x) = truncate (h1.trans h2) x := by\n  obtain ⟨x, rfl⟩ := WittVector.truncate_surjective (p := p) n₃ R x\n  simp only [truncate_wittVector_truncate]\n\n"}
{"name":"TruncatedWittVector.truncate_comp","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nn₁ n₂ n₃ : Nat\nh1 : LE.le n₁ n₂\nh2 : LE.le n₂ n₃\n⊢ Eq ((TruncatedWittVector.truncate h1).comp (TruncatedWittVector.truncate h2)) (TruncatedWittVector.truncate ⋯)","decl":"@[simp]\ntheorem truncate_comp {n₁ n₂ n₃ : ℕ} (h1 : n₁ ≤ n₂) (h2 : n₂ ≤ n₃) :\n    (truncate (p := p) (R := R) h1).comp (truncate h2) = truncate (h1.trans h2) := by\n  ext1 x; simp only [truncate_truncate, Function.comp_apply, RingHom.coe_comp]\n\n"}
{"name":"TruncatedWittVector.truncate_surjective","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nhm : LE.le n m\n⊢ Function.Surjective ⇑(TruncatedWittVector.truncate hm)","decl":"theorem truncate_surjective {m : ℕ} (hm : n ≤ m) : Surjective (truncate (p := p) (R := R) hm) := by\n  intro x\n  obtain ⟨x, rfl⟩ := WittVector.truncate_surjective (p := p) _ R x\n  exact ⟨WittVector.truncate _ x, truncate_wittVector_truncate _ _⟩\n\n"}
{"name":"TruncatedWittVector.coeff_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\nm : Nat\nhm : LE.le n m\ni : Fin n\nx : TruncatedWittVector p m R\n⊢ Eq (TruncatedWittVector.coeff i ((TruncatedWittVector.truncate hm) x)) (TruncatedWittVector.coeff (Fin.castLE hm i) x)","decl":"@[simp]\ntheorem coeff_truncate {m : ℕ} (hm : n ≤ m) (i : Fin n) (x : TruncatedWittVector p m R) :\n    (truncate hm x).coeff i = x.coeff (Fin.castLE hm i) := by\n  obtain ⟨y, rfl⟩ := @WittVector.truncate_surjective p _ _ _ _ x\n  simp only [truncate_wittVector_truncate, WittVector.coeff_truncate, Fin.coe_castLE]\n\n"}
{"name":"TruncatedWittVector.card","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_2\ninst✝ : Fintype R\n⊢ Eq (Fintype.card (TruncatedWittVector p n R)) (HPow.hPow (Fintype.card R) n)","decl":"theorem card {R : Type*} [Fintype R] :\n    Fintype.card (TruncatedWittVector p n R) = Fintype.card R ^ n := by\n  simp only [TruncatedWittVector, Fintype.card_fin, Fintype.card_fun]\n\n"}
{"name":"TruncatedWittVector.iInf_ker_truncate","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝¹ : CommRing R\ninst✝ : Fact (Nat.Prime p)\n⊢ Eq (iInf fun i => RingHom.ker (WittVector.truncate i)) Bot.bot","decl":"theorem iInf_ker_truncate : ⨅ i : ℕ, RingHom.ker (WittVector.truncate (p := p) (R := R) i) = ⊥ := by\n  rw [Submodule.eq_bot_iff]\n  intro x hx\n  ext\n  simp only [WittVector.mem_ker_truncate, Ideal.mem_iInf, WittVector.zero_coeff] at hx ⊢\n  exact hx _ _ (Nat.lt_succ_self _)\n\n"}
{"name":"WittVector.truncate_liftFun","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\nf : (k : Nat) → RingHom S (TruncatedWittVector p k R)\nf_compat : ∀ (k₁ k₂ : Nat) (hk : LE.le k₁ k₂), Eq ((TruncatedWittVector.truncate hk).comp (f k₂)) (f k₁)\ns : S\n⊢ Eq ((WittVector.truncate n) (WittVector.liftFun f s)) ((f n) s)","decl":"include f_compat in\n@[simp]\ntheorem truncate_liftFun (s : S) : WittVector.truncate n (liftFun f s) = f n s := by\n  ext i\n  simp only [liftFun, TruncatedWittVector.coeff_mk, WittVector.truncate_mk']\n  rw [← f_compat (i + 1) n i.is_lt, RingHom.comp_apply, TruncatedWittVector.coeff_truncate]\n  congr 1 with _\n\n"}
{"name":"WittVector.truncate_lift","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\nf : (k : Nat) → RingHom S (TruncatedWittVector p k R)\nf_compat : ∀ (k₁ k₂ : Nat) (hk : LE.le k₁ k₂), Eq ((TruncatedWittVector.truncate hk).comp (f k₂)) (f k₁)\ns : S\n⊢ Eq ((WittVector.truncate n) ((WittVector.lift f f_compat) s)) ((f n) s)","decl":"@[simp]\ntheorem truncate_lift (s : S) : WittVector.truncate n (lift _ f_compat s) = f n s :=\n  truncate_liftFun _ f_compat s\n\n"}
{"name":"WittVector.truncate_comp_lift","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p n : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\nf : (k : Nat) → RingHom S (TruncatedWittVector p k R)\nf_compat : ∀ (k₁ k₂ : Nat) (hk : LE.le k₁ k₂), Eq ((TruncatedWittVector.truncate hk).comp (f k₂)) (f k₁)\n⊢ Eq ((WittVector.truncate n).comp (WittVector.lift f f_compat)) (f n)","decl":"@[simp]\ntheorem truncate_comp_lift : (WittVector.truncate n).comp (lift _ f_compat) = f n := by\n  ext1; rw [RingHom.comp_apply, truncate_lift]\n\n"}
{"name":"WittVector.lift_unique","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\nf : (k : Nat) → RingHom S (TruncatedWittVector p k R)\nf_compat : ∀ (k₁ k₂ : Nat) (hk : LE.le k₁ k₂), Eq ((TruncatedWittVector.truncate hk).comp (f k₂)) (f k₁)\ng : RingHom S (WittVector p R)\ng_compat : ∀ (k : Nat), Eq ((WittVector.truncate k).comp g) (f k)\n⊢ Eq (WittVector.lift f f_compat) g","decl":"/-- The uniqueness part of the universal property of `𝕎 R`. -/\ntheorem lift_unique (g : S →+* 𝕎 R) (g_compat : ∀ k, (WittVector.truncate k).comp g = f k) :\n    lift _ f_compat = g := by\n  ext1 x\n  rw [← sub_eq_zero, ← Ideal.mem_bot, ← iInf_ker_truncate, Ideal.mem_iInf]\n  intro i\n  simp only [RingHom.mem_ker, g_compat, ← RingHom.comp_apply, truncate_comp_lift, RingHom.map_sub,\n    sub_self]\n\n"}
{"name":"WittVector.liftEquiv_symm_apply_coe","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\ng : RingHom S (WittVector p R)\nk : Nat\n⊢ Eq (↑(WittVector.liftEquiv.symm g) k) ((WittVector.truncate k).comp g)","decl":"/-- The universal property of `𝕎 R` as projective limit of truncated Witt vector rings. -/\n@[simps]\ndef liftEquiv : { f : ∀ k, S →+* TruncatedWittVector p k R // ∀ (k₁ k₂) (hk : k₁ ≤ k₂),\n    (TruncatedWittVector.truncate hk).comp (f k₂) = f k₁ } ≃ (S →+* 𝕎 R) where\n  toFun f := lift f.1 f.2\n  invFun g :=\n    ⟨fun k => (truncate k).comp g, by\n      intro _ _ h\n      simp only [← RingHom.comp_assoc, truncate_comp_wittVector_truncate]⟩\n  left_inv := by rintro ⟨f, hf⟩; simp only [truncate_comp_lift]\n  right_inv _ := lift_unique _ _ fun _ => rfl\n\n"}
{"name":"WittVector.liftEquiv_apply","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\nf : Subtype fun f => ∀ (k₁ k₂ : Nat) (hk : LE.le k₁ k₂), Eq ((TruncatedWittVector.truncate hk).comp (f k₂)) (f k₁)\n⊢ Eq (WittVector.liftEquiv f) (WittVector.lift ↑f ⋯)","decl":"/-- The universal property of `𝕎 R` as projective limit of truncated Witt vector rings. -/\n@[simps]\ndef liftEquiv : { f : ∀ k, S →+* TruncatedWittVector p k R // ∀ (k₁ k₂) (hk : k₁ ≤ k₂),\n    (TruncatedWittVector.truncate hk).comp (f k₂) = f k₁ } ≃ (S →+* 𝕎 R) where\n  toFun f := lift f.1 f.2\n  invFun g :=\n    ⟨fun k => (truncate k).comp g, by\n      intro _ _ h\n      simp only [← RingHom.comp_assoc, truncate_comp_wittVector_truncate]⟩\n  left_inv := by rintro ⟨f, hf⟩; simp only [truncate_comp_lift]\n  right_inv _ := lift_unique _ _ fun _ => rfl\n\n"}
{"name":"WittVector.hom_ext","module":"Mathlib.RingTheory.WittVector.Truncated","initialProofState":"p : Nat\nR : Type u_1\ninst✝² : CommRing R\ninst✝¹ : Fact (Nat.Prime p)\nS : Type u_2\ninst✝ : Semiring S\ng₁ g₂ : RingHom S (WittVector p R)\nh : ∀ (k : Nat), Eq ((WittVector.truncate k).comp g₁) ((WittVector.truncate k).comp g₂)\n⊢ Eq g₁ g₂","decl":"theorem hom_ext (g₁ g₂ : S →+* 𝕎 R) (h : ∀ k, (truncate k).comp g₁ = (truncate k).comp g₂) :\n    g₁ = g₂ :=\n  liftEquiv.symm.injective <| Subtype.ext <| funext h\n\n"}
