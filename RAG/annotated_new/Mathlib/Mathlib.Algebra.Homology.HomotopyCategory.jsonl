{"name":"homotopy_congruence","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\n‚ä¢ CategoryTheory.Congruence (homotopic V c)","decl":"instance homotopy_congruence : Congruence (homotopic V c) where\n  equivalence :=\n    { refl := fun C => ‚ü®Homotopy.refl C‚ü©\n      symm := fun ‚ü®w‚ü© => ‚ü®w.symm‚ü©\n      trans := fun ‚ü®w‚ÇÅ‚ü© ‚ü®w‚ÇÇ‚ü© => ‚ü®w‚ÇÅ.trans w‚ÇÇ‚ü© }\n  compLeft := fun _ _ _ ‚ü®i‚ü© => ‚ü®i.compLeft _‚ü©\n  compRight := fun _ ‚ü®i‚ü© => ‚ü®i.compRight _‚ü©\n\n"}
{"name":"HomotopyCategory.instFullHomologicalComplexQuotient","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\n‚ä¢ (HomotopyCategory.quotient V c).Full","decl":"instance : (quotient V c).Full := Quotient.full_functor _\n\n"}
{"name":"HomotopyCategory.instEssSurjHomologicalComplexQuotient","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\n‚ä¢ (HomotopyCategory.quotient V c).EssSurj","decl":"instance : (quotient V c).EssSurj := Quotient.essSurj_functor _\n\n"}
{"name":"HomotopyCategory.instAdditiveHomologicalComplexQuotient","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\n‚ä¢ (HomotopyCategory.quotient V c).Additive","decl":"instance : (quotient V c).Additive where\n\n"}
{"name":"HomotopyCategory.instAdditiveHomologicalComplexQuotientHomotopicFunctor","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\n‚ä¢ (CategoryTheory.Quotient.functor (homotopic V c)).Additive","decl":"instance : Functor.Additive (Quotient.functor (homotopic V c)) where\n\n"}
{"name":"HomotopyCategory.instLinearHomologicalComplexQuotient","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"R : Type u_1\ninst‚úù¬≥ : Semiring R\nŒπ : Type u_2\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\ninst‚úù : CategoryTheory.Linear R V\n‚ä¢ CategoryTheory.Functor.Linear R (HomotopyCategory.quotient V c)","decl":"instance [Linear R V] : Functor.Linear R (HomotopyCategory.quotient V c) :=\n  Quotient.linear_functor _ _ _\n\n"}
{"name":"HomotopyCategory.instHasZeroObject","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\ninst‚úù : CategoryTheory.Limits.HasZeroObject V\n‚ä¢ CategoryTheory.Limits.HasZeroObject (HomotopyCategory V c)","decl":"instance [HasZeroObject V] : HasZeroObject (HomotopyCategory V c) :=\n  ‚ü®(quotient V c).obj 0, by\n    rw [IsZero.iff_id_eq_zero, ‚Üê (quotient V c).map_id, id_zero, Functor.map_zero]‚ü©\n\n"}
{"name":"HomotopyCategory.instFullFunctorHomologicalComplexObjWhiskeringLeftQuotient","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nD : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} D\n‚ä¢ ((CategoryTheory.whiskeringLeft (HomologicalComplex V c) (HomotopyCategory V c) D).obj (HomotopyCategory.quotient V c)).Full","decl":"instance {D : Type*} [Category D] : ((whiskeringLeft _ _ D).obj (quotient V c)).Full :=\n  Quotient.full_whiskeringLeft_functor _ _\n\n"}
{"name":"HomotopyCategory.instFaithfulFunctorHomologicalComplexObjWhiskeringLeftQuotient","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nD : Type u_3\ninst‚úù : CategoryTheory.Category.{u_4, u_3} D\n‚ä¢ ((CategoryTheory.whiskeringLeft (HomologicalComplex V c) (HomotopyCategory V c) D).obj (HomotopyCategory.quotient V c)).Faithful","decl":"instance {D : Type*} [Category D] : ((whiskeringLeft _ _ D).obj (quotient V c)).Faithful :=\n  Quotient.faithful_whiskeringLeft_functor _ _\n\n"}
{"name":"HomotopyCategory.quotient_obj_as","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\n‚ä¢ Eq ((HomotopyCategory.quotient V c).obj C).as C","decl":"theorem quotient_obj_as (C : HomologicalComplex V c) : ((quotient V c).obj C).as = C :=\n  rfl\n\n"}
{"name":"HomotopyCategory.quotient_map_out","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomotopyCategory V c\nf : Quiver.Hom C D\n‚ä¢ Eq ((HomotopyCategory.quotient V c).map (Quot.out f)) f","decl":"@[simp]\ntheorem quotient_map_out {C D : HomotopyCategory V c} (f : C ‚ü∂ D) : (quotient V c).map f.out = f :=\n  Quot.out_eq _\n\n-- Porting note: added to ease the port\n"}
{"name":"HomotopyCategory.quot_mk_eq_quotient_map","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : Quiver.Hom C D\n‚ä¢ Eq (Quot.mk (CategoryTheory.Quotient.CompClosure (homotopic V c)) f) ((HomotopyCategory.quotient V c).map f)","decl":"theorem quot_mk_eq_quotient_map {C D : HomologicalComplex V c} (f : C ‚ü∂ D) :\n    Quot.mk _ f = (quotient V c).map f := rfl\n\n"}
{"name":"HomotopyCategory.eq_of_homotopy","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : Homotopy f g\n‚ä¢ Eq ((HomotopyCategory.quotient V c).map f) ((HomotopyCategory.quotient V c).map g)","decl":"theorem eq_of_homotopy {C D : HomologicalComplex V c} (f g : C ‚ü∂ D) (h : Homotopy f g) :\n    (quotient V c).map f = (quotient V c).map g :=\n  CategoryTheory.Quotient.sound _ ‚ü®h‚ü©\n\n"}
{"name":"HomotopyCategory.quotient_map_out_comp_out","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomotopyCategory V c\nf : Quiver.Hom C D\ng : Quiver.Hom D E\n‚ä¢ Eq ((HomotopyCategory.quotient V c).map (CategoryTheory.CategoryStruct.comp (Quot.out f) (Quot.out g))) (CategoryTheory.CategoryStruct.comp f g)","decl":"theorem quotient_map_out_comp_out {C D E : HomotopyCategory V c} (f : C ‚ü∂ D) (g : D ‚ü∂ E) :\n    (quotient V c).map (Quot.out f ‚â´ Quot.out g) = f ‚â´ g := by simp\n\n"}
{"name":"HomotopyCategory.isoOfHomotopyEquiv_hom","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : HomotopyEquiv C D\n‚ä¢ Eq (HomotopyCategory.isoOfHomotopyEquiv f).hom ((HomotopyCategory.quotient V c).map f.hom)","decl":"/-- Homotopy equivalent complexes become isomorphic in the homotopy category. -/\n@[simps]\ndef isoOfHomotopyEquiv {C D : HomologicalComplex V c} (f : HomotopyEquiv C D) :\n    (quotient V c).obj C ‚âÖ (quotient V c).obj D where\n  hom := (quotient V c).map f.hom\n  inv := (quotient V c).map f.inv\n  hom_inv_id := by\n    rw [‚Üê (quotient V c).map_comp, ‚Üê (quotient V c).map_id]\n    exact eq_of_homotopy _ _ f.homotopyHomInvId\n  inv_hom_id := by\n    rw [‚Üê (quotient V c).map_comp, ‚Üê (quotient V c).map_id]\n    exact eq_of_homotopy _ _ f.homotopyInvHomId\n\n"}
{"name":"HomotopyCategory.isoOfHomotopyEquiv_inv","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : HomotopyEquiv C D\n‚ä¢ Eq (HomotopyCategory.isoOfHomotopyEquiv f).inv ((HomotopyCategory.quotient V c).map f.inv)","decl":"/-- Homotopy equivalent complexes become isomorphic in the homotopy category. -/\n@[simps]\ndef isoOfHomotopyEquiv {C D : HomologicalComplex V c} (f : HomotopyEquiv C D) :\n    (quotient V c).obj C ‚âÖ (quotient V c).obj D where\n  hom := (quotient V c).map f.hom\n  inv := (quotient V c).map f.inv\n  hom_inv_id := by\n    rw [‚Üê (quotient V c).map_comp, ‚Üê (quotient V c).map_id]\n    exact eq_of_homotopy _ _ f.homotopyHomInvId\n  inv_hom_id := by\n    rw [‚Üê (quotient V c).map_comp, ‚Üê (quotient V c).map_id]\n    exact eq_of_homotopy _ _ f.homotopyInvHomId\n\n"}
{"name":"HomotopyCategory.quotient_inverts_homotopyEquivalences","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\n‚ä¢ (HomologicalComplex.homotopyEquivalences V c).IsInvertedBy (HomotopyCategory.quotient V c)","decl":"variable (V c) in\nlemma quotient_inverts_homotopyEquivalences :\n    (HomologicalComplex.homotopyEquivalences V c).IsInvertedBy (quotient V c) := by\n  rintro K L _ ‚ü®e, rfl‚ü©\n  change IsIso (isoOfHomotopyEquiv e).hom\n  infer_instance\n\n"}
{"name":"HomotopyCategory.isZero_quotient_obj_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC : HomologicalComplex V c\n‚ä¢ Iff (CategoryTheory.Limits.IsZero ((HomotopyCategory.quotient V c).obj C)) (Nonempty (Homotopy (CategoryTheory.CategoryStruct.id C) 0))","decl":"lemma isZero_quotient_obj_iff (C : HomologicalComplex V c) :\n    IsZero ((quotient _ _).obj C) ‚Üî Nonempty (Homotopy (ùüô C) 0) := by\n  rw [IsZero.iff_id_eq_zero]\n  constructor\n  ¬∑ intro h\n    exact ‚ü®(homotopyOfEq _ _ (by simp [h]))‚ü©\n  ¬∑ rintro ‚ü®h‚ü©\n    simpa using (eq_of_homotopy _ _ h)\n\n"}
{"name":"HomotopyCategory.instAdditiveHomologyFunctor","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù¬≤ : CategoryTheory.Category.{v, u} V\ninst‚úù¬π : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\ninst‚úù : CategoryTheory.CategoryWithHomology V\ni : Œπ\n‚ä¢ (HomotopyCategory.homologyFunctor V c i).Additive","decl":"instance (i : Œπ) : (homologyFunctor V c i).Additive := by\n  have := Functor.additive_of_iso (homologyFunctorFactors V c i).symm\n  exact Functor.additive_of_full_essSurj_comp (quotient V c) _\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyCategory_obj","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nW : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_3} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nc : ComplexShape Œπ\na : CategoryTheory.Quotient (homotopic V c)\n‚ä¢ Eq ((F.mapHomotopyCategory c).obj a) ((HomotopyCategory.quotient W c).obj ((F.mapHomologicalComplex c).obj a.as))","decl":"/-- An additive functor induces a functor between homotopy categories. -/\n@[simps! obj]\ndef Functor.mapHomotopyCategory (F : V ‚•§ W) [F.Additive] (c : ComplexShape Œπ) :\n    HomotopyCategory V c ‚•§ HomotopyCategory W c :=\n  CategoryTheory.Quotient.lift _ (F.mapHomologicalComplex c ‚ãô HomotopyCategory.quotient W c)\n    (fun _ _ _ _ ‚ü®h‚ü© => HomotopyCategory.eq_of_homotopy _ _ (F.mapHomotopy h))\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyCategory_map","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nW : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_3} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nc : ComplexShape Œπ\nK L : HomologicalComplex V c\nf : Quiver.Hom K L\n‚ä¢ Eq ((F.mapHomotopyCategory c).map ((HomotopyCategory.quotient V c).map f)) ((HomotopyCategory.quotient W c).map ((F.mapHomologicalComplex c).map f))","decl":"@[simp]\nlemma Functor.mapHomotopyCategory_map (F : V ‚•§ W) [F.Additive] {c : ComplexShape Œπ}\n    {K L : HomologicalComplex V c} (f : K ‚ü∂ L) :\n    (F.mapHomotopyCategory c).map ((HomotopyCategory.quotient V c).map f) =\n      (HomotopyCategory.quotient W c).map ((F.mapHomologicalComplex c).map f) :=\n  rfl\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomotopyCategory_app","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù‚Åµ : CategoryTheory.Category.{v, u} V\ninst‚úù‚Å¥ : CategoryTheory.Preadditive V\nW : Type u_3\ninst‚úù¬≥ : CategoryTheory.Category.{u_4, u_3} W\ninst‚úù¬≤ : CategoryTheory.Preadditive W\nF G : CategoryTheory.Functor V W\ninst‚úù¬π : F.Additive\ninst‚úù : G.Additive\nŒ± : Quiver.Hom F G\nc : ComplexShape Œπ\nC : HomotopyCategory V c\n‚ä¢ Eq ((CategoryTheory.NatTrans.mapHomotopyCategory Œ± c).app C) ((HomotopyCategory.quotient W c).map ((CategoryTheory.NatTrans.mapHomologicalComplex Œ± c).app C.as))","decl":"/-- A natural transformation induces a natural transformation between\n  the induced functors on the homotopy category. -/\n@[simps]\ndef NatTrans.mapHomotopyCategory {F G : V ‚•§ W} [F.Additive] [G.Additive] (Œ± : F ‚ü∂ G)\n    (c : ComplexShape Œπ) : F.mapHomotopyCategory c ‚ü∂ G.mapHomotopyCategory c where\n  app C := (HomotopyCategory.quotient W c).map ((NatTrans.mapHomologicalComplex Œ± c).app C.as)\n  naturality := by\n    rintro ‚ü®C‚ü© ‚ü®D‚ü© ‚ü®f : C ‚ü∂ D‚ü©\n    simp only [HomotopyCategory.quot_mk_eq_quotient_map, Functor.mapHomotopyCategory_map,\n      ‚Üê Functor.map_comp, NatTrans.naturality]\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomotopyCategory_id","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nW : Type u_3\ninst‚úù¬≤ : CategoryTheory.Category.{u_4, u_3} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nc : ComplexShape Œπ\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\n‚ä¢ Eq (CategoryTheory.NatTrans.mapHomotopyCategory (CategoryTheory.CategoryStruct.id F) c) (CategoryTheory.CategoryStruct.id (F.mapHomotopyCategory c))","decl":"@[simp]\ntheorem NatTrans.mapHomotopyCategory_id (c : ComplexShape Œπ) (F : V ‚•§ W) [F.Additive] :\n    NatTrans.mapHomotopyCategory (ùüô F) c = ùüô (F.mapHomotopyCategory c) := by aesop_cat\n\n"}
{"name":"CategoryTheory.NatTrans.mapHomotopyCategory_comp","module":"Mathlib.Algebra.Homology.HomotopyCategory","initialProofState":"Œπ : Type u_2\nV : Type u\ninst‚úù‚Å∂ : CategoryTheory.Category.{v, u} V\ninst‚úù‚Åµ : CategoryTheory.Preadditive V\nW : Type u_3\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_4, u_3} W\ninst‚úù¬≥ : CategoryTheory.Preadditive W\nc : ComplexShape Œπ\nF G H : CategoryTheory.Functor V W\ninst‚úù¬≤ : F.Additive\ninst‚úù¬π : G.Additive\ninst‚úù : H.Additive\nŒ± : Quiver.Hom F G\nŒ≤ : Quiver.Hom G H\n‚ä¢ Eq (CategoryTheory.NatTrans.mapHomotopyCategory (CategoryTheory.CategoryStruct.comp Œ± Œ≤) c) (CategoryTheory.CategoryStruct.comp (CategoryTheory.NatTrans.mapHomotopyCategory Œ± c) (CategoryTheory.NatTrans.mapHomotopyCategory Œ≤ c))","decl":"@[simp]\ntheorem NatTrans.mapHomotopyCategory_comp (c : ComplexShape Œπ) {F G H : V ‚•§ W} [F.Additive]\n    [G.Additive] [H.Additive] (Œ± : F ‚ü∂ G) (Œ≤ : G ‚ü∂ H) :\n    NatTrans.mapHomotopyCategory (Œ± ‚â´ Œ≤) c =\n      NatTrans.mapHomotopyCategory Œ± c ‚â´ NatTrans.mapHomotopyCategory Œ≤ c := by aesop_cat\n\n"}
