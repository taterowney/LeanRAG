{"name":"MeasureTheory.Measure.comapₗ_apply","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nx✝¹ : MeasurableSpace α\nx✝ : MeasurableSpace β\nf : α → β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasurableSet (Set.image f s)\nμ : MeasureTheory.Measure β\nhs : MeasurableSet s\n⊢ Eq (((MeasureTheory.Measure.comapₗ f) μ) s) (μ (Set.image f s))","decl":"theorem comapₗ_apply {_ : MeasurableSpace α} {_ : MeasurableSpace β} (f : α → β)\n    (hfi : Injective f) (hf : ∀ s, MeasurableSet s → MeasurableSet (f '' s)) (μ : Measure β)\n    (hs : MeasurableSet s) : comapₗ f μ s = μ (f '' s) := by\n  rw [comapₗ, dif_pos, liftLinear_apply _ hs, OuterMeasure.comap_apply, coe_toOuterMeasure]\n  exact ⟨hfi, hf⟩\n\n"}
{"name":"MeasureTheory.Measure.comap_apply₀","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasureTheory.NullMeasurableSet (Set.image f s) μ\nhs : MeasureTheory.NullMeasurableSet s (MeasureTheory.Measure.comap f μ)\n⊢ Eq ((MeasureTheory.Measure.comap f μ) s) (μ (Set.image f s))","decl":"theorem comap_apply₀ (f : α → β) (μ : Measure β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) μ)\n    (hs : NullMeasurableSet s (comap f μ)) : comap f μ s = μ (f '' s) := by\n  rw [comap, dif_pos (And.intro hfi hf)] at hs ⊢\n  rw [toMeasure_apply₀ _ _ hs, OuterMeasure.comap_apply, coe_toOuterMeasure]\n\n"}
{"name":"MeasureTheory.Measure.le_comap_apply","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasureTheory.NullMeasurableSet (Set.image f s) μ\ns : Set α\n⊢ LE.le (μ (Set.image f s)) ((MeasureTheory.Measure.comap f μ) s)","decl":"theorem le_comap_apply (f : α → β) (μ : Measure β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) μ) (s : Set α) :\n    μ (f '' s) ≤ comap f μ s := by\n  rw [comap, dif_pos (And.intro hfi hf)]\n  exact le_toMeasure_apply _ _ _\n\n"}
{"name":"MeasureTheory.Measure.comap_apply","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasurableSet (Set.image f s)\nμ : MeasureTheory.Measure β\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.comap f μ) s) (μ (Set.image f s))","decl":"theorem comap_apply (f : α → β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → MeasurableSet (f '' s)) (μ : Measure β) (hs : MeasurableSet s) :\n    comap f μ s = μ (f '' s) :=\n  comap_apply₀ f μ hfi (fun s hs => (hf s hs).nullMeasurableSet) hs.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.Measure.comapₗ_eq_comap","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasurableSet (Set.image f s)\nμ : MeasureTheory.Measure β\nhs : MeasurableSet s\n⊢ Eq (((MeasureTheory.Measure.comapₗ f) μ) s) ((MeasureTheory.Measure.comap f μ) s)","decl":"theorem comapₗ_eq_comap (f : α → β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → MeasurableSet (f '' s)) (μ : Measure β) (hs : MeasurableSet s) :\n    comapₗ f μ s = comap f μ s :=\n  (comapₗ_apply f hfi hf μ hs).trans (comap_apply f hfi hf μ hs).symm\n\n"}
{"name":"MeasureTheory.Measure.measure_image_eq_zero_of_comap_eq_zero","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasureTheory.NullMeasurableSet (Set.image f s) μ\ns : Set α\nhs : Eq ((MeasureTheory.Measure.comap f μ) s) 0\n⊢ Eq (μ (Set.image f s)) 0","decl":"theorem measure_image_eq_zero_of_comap_eq_zero (f : α → β) (μ : Measure β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) μ) {s : Set α} (hs : comap f μ s = 0) :\n    μ (f '' s) = 0 :=\n  le_antisymm ((le_comap_apply f μ hfi hf s).trans hs.le) (zero_le _)\n\n"}
{"name":"MeasureTheory.Measure.ae_eq_image_of_ae_eq_comap","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasureTheory.NullMeasurableSet (Set.image f s) μ\ns t : Set α\nhst : (MeasureTheory.ae (MeasureTheory.Measure.comap f μ)).EventuallyEq s t\n⊢ (MeasureTheory.ae μ).EventuallyEq (Set.image f s) (Set.image f t)","decl":"theorem ae_eq_image_of_ae_eq_comap (f : α → β) (μ : Measure β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) μ)\n    {s t : Set α} (hst : s =ᵐ[comap f μ] t) : f '' s =ᵐ[μ] f '' t := by\n  rw [EventuallyEq, ae_iff] at hst ⊢\n  have h_eq_α : { a : α | ¬s a = t a } = s \\ t ∪ t \\ s := by\n    ext1 x\n    simp only [eq_iff_iff, mem_setOf_eq, mem_union, mem_diff]\n    tauto\n  have h_eq_β : { a : β | ¬(f '' s) a = (f '' t) a } = f '' s \\ f '' t ∪ f '' t \\ f '' s := by\n    ext1 x\n    simp only [eq_iff_iff, mem_setOf_eq, mem_union, mem_diff]\n    tauto\n  rw [← Set.image_diff hfi, ← Set.image_diff hfi, ← Set.image_union] at h_eq_β\n  rw [h_eq_β]\n  rw [h_eq_α] at hst\n  exact measure_image_eq_zero_of_comap_eq_zero f μ hfi hf hst\n\n"}
{"name":"MeasureTheory.Measure.NullMeasurableSet.image","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\ns : Set α\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure β\nhfi : Function.Injective f\nhf : ∀ (s : Set α), MeasurableSet s → MeasureTheory.NullMeasurableSet (Set.image f s) μ\nhs : MeasureTheory.NullMeasurableSet s (MeasureTheory.Measure.comap f μ)\n⊢ MeasureTheory.NullMeasurableSet (Set.image f s) μ","decl":"theorem NullMeasurableSet.image (f : α → β) (μ : Measure β) (hfi : Injective f)\n    (hf : ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) μ)\n    (hs : NullMeasurableSet s (μ.comap f)) : NullMeasurableSet (f '' s) μ := by\n  refine ⟨toMeasurable μ (f '' toMeasurable (μ.comap f) s), measurableSet_toMeasurable _ _, ?_⟩\n  refine EventuallyEq.trans ?_ (NullMeasurableSet.toMeasurable_ae_eq ?_).symm\n  swap\n  · exact hf _ (measurableSet_toMeasurable _ _)\n  have h : toMeasurable (comap f μ) s =ᵐ[comap f μ] s :=\n    NullMeasurableSet.toMeasurable_ae_eq hs\n  exact ae_eq_image_of_ae_eq_comap f μ hfi hf h.symm\n\n"}
{"name":"MeasureTheory.Measure.comap_preimage","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\nμ : MeasureTheory.Measure β\nhf : Function.Injective f\nhf' : Measurable f\nh : ∀ (t : Set α), MeasurableSet t → MeasureTheory.NullMeasurableSet (Set.image f t) μ\ns : Set β\nhs : MeasurableSet s\n⊢ Eq ((MeasureTheory.Measure.comap f μ) (Set.preimage f s)) (μ (Inter.inter s (Set.range f)))","decl":"theorem comap_preimage (f : α → β) (μ : Measure β) (hf : Injective f) (hf' : Measurable f)\n    (h : ∀ t, MeasurableSet t → NullMeasurableSet (f '' t) μ) {s : Set β} (hs : MeasurableSet s) :\n    μ.comap f (f ⁻¹' s) = μ (s ∩ range f) := by\n  rw [comap_apply₀ _ _ hf h (hf' hs).nullMeasurableSet, image_preimage_eq_inter_range]\n\n"}
{"name":"MeasureTheory.Measure.comap_zero","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nf : α → β\n⊢ Eq (MeasureTheory.Measure.comap f 0) 0","decl":"@[simp] lemma comap_zero (f : α → β) : (0 : Measure β).comap f = 0 := by\n  by_cases hf : Injective f ∧ ∀ s, MeasurableSet s → NullMeasurableSet (f '' s) (0 : Measure β)\n  · simp [comap, hf]\n  · simp [comap, hf]\n\n"}
{"name":"MeasureTheory.Measure.comap_id","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"β : Type u_2\nmβ : MeasurableSpace β\nμ : MeasureTheory.Measure β\n⊢ Eq (MeasureTheory.Measure.comap (fun x => x) μ) μ","decl":"@[simp]\nlemma comap_id (μ : Measure β) : comap (fun x ↦ x) μ = μ := by\n  ext s hs\n  rw [comap_apply, image_id']\n  · exact injective_id\n  all_goals simp [*]\n\n"}
{"name":"MeasureTheory.Measure.comap_comap","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nmα : MeasurableSpace α\nmβ : MeasurableSpace β\nmγ : MeasurableSpace γ\nf : α → β\ng : β → γ\nhf' : ∀ (s : Set α), MeasurableSet s → MeasurableSet (Set.image f s)\nhg : Function.Injective g\nhg' : ∀ (s : Set β), MeasurableSet s → MeasurableSet (Set.image g s)\nμ : MeasureTheory.Measure γ\n⊢ Eq (MeasureTheory.Measure.comap f (MeasureTheory.Measure.comap g μ)) (MeasureTheory.Measure.comap (Function.comp g f) μ)","decl":"lemma comap_comap (hf' : ∀ s, MeasurableSet s → MeasurableSet (f '' s)) (hg : Injective g)\n    (hg' : ∀ s, MeasurableSet s → MeasurableSet (g '' s)) (μ : Measure γ) :\n    comap f (comap g μ) = comap (g ∘ f) μ := by\n  by_cases hf : Injective f\n  · ext s hs\n    rw [comap_apply _ hf hf' _ hs, comap_apply _ hg hg' _ (hf' _ hs),\n      comap_apply _ (hg.comp hf) (fun t ht ↦ image_comp g f _ ▸ hg' _ <| hf' _ ht) _ hs, image_comp]\n  · rw [comap, dif_neg <| mt And.left hf, comap, dif_neg fun h ↦ hf h.1.of_comp]\n\n\n"}
{"name":"MeasurableEmbedding.comap_add","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nma : MeasurableSpace α\nmb : MeasurableSpace β\nf : α → β\nhf : MeasurableEmbedding f\nμ ν : MeasureTheory.Measure β\n⊢ Eq (MeasureTheory.Measure.comap f (HAdd.hAdd μ ν)) (HAdd.hAdd (MeasureTheory.Measure.comap f μ) (MeasureTheory.Measure.comap f ν))","decl":"lemma MeasurableEmbedding.comap_add {f : α → β} (hf : MeasurableEmbedding f) (μ ν : Measure β) :\n    (μ + ν).comap f = μ.comap f + ν.comap f := by\n  ext s hs\n  simp only [← comapₗ_eq_comap _ hf.injective (fun _ ↦ hf.measurableSet_image.mpr) _ hs,\n    _root_.map_add, add_apply]\n\n"}
{"name":"MeasurableEquiv.comap_symm","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nma : MeasurableSpace α\nmb : MeasurableSpace β\nμ : MeasureTheory.Measure α\ne : MeasurableEquiv α β\n⊢ Eq (MeasureTheory.Measure.comap (⇑e.symm) μ) (MeasureTheory.Measure.map (⇑e) μ)","decl":"lemma comap_symm {μ : Measure α} (e : α ≃ᵐ β) : μ.comap e.symm = μ.map e := by\n  ext s hs\n  rw [e.map_apply, Measure.comap_apply _ e.symm.injective _ _ hs, image_symm]\n  exact fun t ht ↦ e.symm.measurableSet_image.mpr ht\n\n"}
{"name":"MeasurableEquiv.map_symm","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nma : MeasurableSpace α\nmb : MeasurableSpace β\nμ : MeasureTheory.Measure α\ne : MeasurableEquiv β α\n⊢ Eq (MeasureTheory.Measure.map (⇑e.symm) μ) (MeasureTheory.Measure.comap (⇑e) μ)","decl":"lemma map_symm {μ : Measure α} (e : β ≃ᵐ α) : μ.map e.symm = μ.comap e := by\n  rw [← comap_symm, symm_symm]\n\n"}
{"name":"MeasureTheory.Measure.comap_swap","module":"Mathlib.MeasureTheory.Measure.Comap","initialProofState":"α : Type u_1\nβ : Type u_2\nma : MeasurableSpace α\nmb : MeasurableSpace β\nμ : MeasureTheory.Measure (Prod α β)\n⊢ Eq (MeasureTheory.Measure.comap Prod.swap μ) (MeasureTheory.Measure.map Prod.swap μ)","decl":"lemma MeasureTheory.Measure.comap_swap (μ : Measure (α × β)) : μ.comap .swap = μ.map .swap :=\n  (MeasurableEquiv.prodComm ..).comap_symm\n"}
