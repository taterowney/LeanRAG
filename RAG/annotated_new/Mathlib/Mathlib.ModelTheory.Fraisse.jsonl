{"name":"FirstOrder.Language.IsFraisse.FG","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nself : FirstOrder.Language.IsFraisse K\nM : CategoryTheory.Bundled L.Structure\na✝ : Membership.mem K M\n⊢ FirstOrder.Language.Structure.FG L ↑M","decl":"/-- A Fraïssé class is a nonempty, essentially countable class of structures satisfying the\nhereditary, joint embedding, and amalgamation properties. -/\nclass IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K\n\n"}
{"name":"FirstOrder.Language.IsFraisse.amalgamation","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nself : FirstOrder.Language.IsFraisse K\n⊢ FirstOrder.Language.Amalgamation K","decl":"/-- A Fraïssé class is a nonempty, essentially countable class of structures satisfying the\nhereditary, joint embedding, and amalgamation properties. -/\nclass IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K\n\n"}
{"name":"FirstOrder.Language.IsFraisse.is_nonempty","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nself : FirstOrder.Language.IsFraisse K\n⊢ K.Nonempty","decl":"/-- A Fraïssé class is a nonempty, essentially countable class of structures satisfying the\nhereditary, joint embedding, and amalgamation properties. -/\nclass IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K\n\n"}
{"name":"FirstOrder.Language.IsFraisse.hereditary","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nself : FirstOrder.Language.IsFraisse K\n⊢ FirstOrder.Language.Hereditary K","decl":"/-- A Fraïssé class is a nonempty, essentially countable class of structures satisfying the\nhereditary, joint embedding, and amalgamation properties. -/\nclass IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K\n\n"}
{"name":"FirstOrder.Language.IsFraisse.jointEmbedding","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nself : FirstOrder.Language.IsFraisse K\n⊢ FirstOrder.Language.JointEmbedding K","decl":"/-- A Fraïssé class is a nonempty, essentially countable class of structures satisfying the\nhereditary, joint embedding, and amalgamation properties. -/\nclass IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K\n\n"}
{"name":"FirstOrder.Language.IsFraisse.is_essentially_countable","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nself : FirstOrder.Language.IsFraisse K\n⊢ (Set.image Quotient.mk' K).Countable","decl":"/-- A Fraïssé class is a nonempty, essentially countable class of structures satisfying the\nhereditary, joint embedding, and amalgamation properties. -/\nclass IsFraisse : Prop where\n  is_nonempty : K.Nonempty\n  FG : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M\n  is_essentially_countable : (Quotient.mk' '' K).Countable\n  hereditary : Hereditary K\n  jointEmbedding : JointEmbedding K\n  amalgamation : Amalgamation K\n\n"}
{"name":"FirstOrder.Language.age.is_equiv_invariant","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nN P : CategoryTheory.Bundled L.Structure\nh : Nonempty (L.Equiv ↑N ↑P)\n⊢ Iff (Membership.mem (L.age M) N) (Membership.mem (L.age M) P)","decl":"theorem age.is_equiv_invariant (N P : Bundled.{w} L.Structure) (h : Nonempty (N ≃[L] P)) :\n    N ∈ L.age M ↔ P ∈ L.age M :=\n  and_congr h.some.fg_iff\n    ⟨Nonempty.map fun x => Embedding.comp x h.some.symm.toEmbedding,\n      Nonempty.map fun x => Embedding.comp x h.some.toEmbedding⟩\n\n"}
{"name":"FirstOrder.Language.Embedding.age_subset_age","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nN : Type w\ninst✝ : L.Structure N\nMN : L.Embedding M N\n⊢ HasSubset.Subset (L.age M) (L.age N)","decl":"theorem Embedding.age_subset_age (MN : M ↪[L] N) : L.age M ⊆ L.age N := fun _ =>\n  And.imp_right (Nonempty.map MN.comp)\n\n"}
{"name":"FirstOrder.Language.Equiv.age_eq_age","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\nN : Type w\ninst✝ : L.Structure N\nMN : L.Equiv M N\n⊢ Eq (L.age M) (L.age N)","decl":"theorem Equiv.age_eq_age (MN : M ≃[L] N) : L.age M = L.age N :=\n  le_antisymm MN.toEmbedding.age_subset_age MN.symm.toEmbedding.age_subset_age\n\n"}
{"name":"FirstOrder.Language.Structure.FG.mem_age_of_equiv","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM N : CategoryTheory.Bundled L.Structure\nh : FirstOrder.Language.Structure.FG L ↑M\nMN : Nonempty (L.Equiv ↑M ↑N)\n⊢ Membership.mem (L.age ↑M) N","decl":"theorem Structure.FG.mem_age_of_equiv {M N : Bundled L.Structure} (h : Structure.FG L M)\n    (MN : Nonempty (M ≃[L] N)) : N ∈ L.age M :=\n  ⟨MN.some.fg_iff.1 h, ⟨MN.some.symm.toEmbedding⟩⟩\n\n"}
{"name":"FirstOrder.Language.Hereditary.is_equiv_invariant_of_fg","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nh : FirstOrder.Language.Hereditary K\nfg : ∀ (M : CategoryTheory.Bundled L.Structure), Membership.mem K M → FirstOrder.Language.Structure.FG L ↑M\nM N : CategoryTheory.Bundled L.Structure\nhn : Nonempty (L.Equiv ↑M ↑N)\n⊢ Iff (Membership.mem K M) (Membership.mem K N)","decl":"theorem Hereditary.is_equiv_invariant_of_fg (h : Hereditary K)\n    (fg : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) (M N : Bundled.{w} L.Structure)\n    (hn : Nonempty (M ≃[L] N)) : M ∈ K ↔ N ∈ K :=\n  ⟨fun MK => h M MK ((fg M MK).mem_age_of_equiv hn),\n   fun NK => h N NK ((fg N NK).mem_age_of_equiv ⟨hn.some.symm⟩)⟩\n\n"}
{"name":"FirstOrder.Language.IsFraisse.is_equiv_invariant","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nh : FirstOrder.Language.IsFraisse K\nM N : CategoryTheory.Bundled L.Structure\nhn : Nonempty (L.Equiv ↑M ↑N)\n⊢ Iff (Membership.mem K M) (Membership.mem K N)","decl":"theorem IsFraisse.is_equiv_invariant [h : IsFraisse K] {M N : Bundled.{w} L.Structure}\n    (hn : Nonempty (M ≃[L] N)) : M ∈ K ↔ N ∈ K :=\n  h.hereditary.is_equiv_invariant_of_fg h.FG M N hn\n\n"}
{"name":"FirstOrder.Language.age.nonempty","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ (L.age M).Nonempty","decl":"theorem age.nonempty : (L.age M).Nonempty :=\n  ⟨Bundled.of (Substructure.closure L (∅ : Set M)),\n    (fg_iff_structure_fg _).1 (fg_closure Set.finite_empty), ⟨Substructure.subtype _⟩⟩\n\n"}
{"name":"FirstOrder.Language.age.hereditary","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ FirstOrder.Language.Hereditary (L.age M)","decl":"theorem age.hereditary : Hereditary (L.age M) := fun _ hN _ hP => hN.2.some.age_subset_age hP\n\n"}
{"name":"FirstOrder.Language.age.jointEmbedding","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\n⊢ FirstOrder.Language.JointEmbedding (L.age M)","decl":"theorem age.jointEmbedding : JointEmbedding (L.age M) := fun _ hN _ hP =>\n  ⟨Bundled.of (↥(hN.2.some.toHom.range ⊔ hP.2.some.toHom.range)),\n    ⟨(fg_iff_structure_fg _).1 ((hN.1.range hN.2.some.toHom).sup (hP.1.range hP.2.some.toHom)),\n      ⟨Substructure.subtype _⟩⟩,\n    ⟨Embedding.comp (inclusion le_sup_left) hN.2.some.equivRange.toEmbedding⟩,\n    ⟨Embedding.comp (inclusion le_sup_right) hP.2.some.equivRange.toEmbedding⟩⟩\n\n"}
{"name":"FirstOrder.Language.age.fg_substructure","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nS : L.Substructure M\nfg : S.FG\n⊢ Membership.mem (L.age M) { α := Subtype fun x => Membership.mem S x, str := inferInstance }","decl":"theorem age.fg_substructure {S : L.Substructure M} (fg : S.FG) : Bundled.mk S ∈ L.age M := by\n  exact ⟨(Substructure.fg_iff_structure_fg _).1 fg, ⟨subtype _⟩⟩\n\n"}
{"name":"FirstOrder.Language.age.has_representative_as_substructure","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nC : Quotient FirstOrder.Language.equivSetoid\na✝ : Membership.mem (Set.image Quotient.mk' (L.age M)) C\n⊢ Exists fun V => Eq (Quotient.mk FirstOrder.Language.equivSetoid { α := Subtype fun x => Membership.mem (↑V) x, str := inferInstance }) C","decl":"/-- Any class in the age of a structure has a representative which is a finitely generated\nsubstructure. -/\ntheorem age.has_representative_as_substructure :\n    ∀ C ∈ Quotient.mk' '' L.age M, ∃ V : {V : L.Substructure M // FG V},\n      ⟦Bundled.mk V⟧ = C := by\n  rintro _ ⟨N, ⟨N_fg, ⟨N_incl⟩⟩, N_eq⟩\n  refine N_eq.symm ▸ ⟨⟨N_incl.toHom.range, ?_⟩, Quotient.sound ⟨N_incl.equivRange.symm⟩⟩\n  exact FG.range N_fg (Embedding.toHom N_incl)\n\n"}
{"name":"FirstOrder.Language.age.countable_quotient","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nh : Countable M\n⊢ (Set.image Quotient.mk' (L.age M)).Countable","decl":"/-- The age of a countable structure is essentially countable (has countably many isomorphism\nclasses). -/\ntheorem age.countable_quotient [h : Countable M] : (Quotient.mk' '' L.age M).Countable := by\n  classical\n  refine (congr_arg _ (Set.ext <| Quotient.forall.2 fun N => ?_)).mp\n    (countable_range fun s : Finset M => ⟦⟨closure L (s : Set M), inferInstance⟩⟧)\n  constructor\n  · rintro ⟨s, hs⟩\n    use Bundled.of (closure L (s : Set M))\n    exact ⟨⟨(fg_iff_structure_fg _).1 (fg_closure s.finite_toSet), ⟨Substructure.subtype _⟩⟩, hs⟩\n  · simp only [mem_range, Quotient.eq]\n    rintro ⟨P, ⟨⟨s, hs⟩, ⟨PM⟩⟩, hP2⟩\n    have : P ≈ N := by apply Quotient.eq'.mp; rw [hP2]; rfl -- Porting note: added\n    refine ⟨s.image PM, Setoid.trans (b := P) ?_ this⟩\n    rw [← Embedding.coe_toHom, Finset.coe_image, closure_image PM.toHom, hs, ← Hom.range_eq_map]\n    exact ⟨PM.equivRange.symm⟩\n\n"}
{"name":"FirstOrder.Language.age_directLimit","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nι : Type w\ninst✝⁴ : Preorder ι\ninst✝³ : IsDirected ι fun x1 x2 => LE.le x1 x2\ninst✝² : Nonempty ι\nG : ι → Type (max w w')\ninst✝¹ : (i : ι) → L.Structure (G i)\nf : (i j : ι) → LE.le i j → L.Embedding (G i) (G j)\ninst✝ : DirectedSystem G fun i j h => ⇑(f i j h)\n⊢ Eq (L.age (FirstOrder.Language.DirectLimit G f)) (Set.iUnion fun i => L.age (G i))","decl":"/-- The age of a direct limit of structures is the union of the ages of the structures. -/\n-- @[simp] -- Porting note: cannot simplify itself\ntheorem age_directLimit {ι : Type w} [Preorder ι] [IsDirected ι (· ≤ ·)] [Nonempty ι]\n    (G : ι → Type max w w') [∀ i, L.Structure (G i)] (f : ∀ i j, i ≤ j → G i ↪[L] G j)\n    [DirectedSystem G fun i j h => f i j h] : L.age (DirectLimit G f) = ⋃ i : ι, L.age (G i) := by\n  classical\n  ext M\n  simp only [mem_iUnion]\n  constructor\n  · rintro ⟨Mfg, ⟨e⟩⟩\n    obtain ⟨s, hs⟩ := Mfg.range e.toHom\n    let out := @Quotient.out _ (DirectLimit.setoid G f)\n    obtain ⟨i, hi⟩ := Finset.exists_le (s.image (Sigma.fst ∘ out))\n    have e' := (DirectLimit.of L ι G f i).equivRange.symm.toEmbedding\n    refine ⟨i, Mfg, ⟨e'.comp ((Substructure.inclusion ?_).comp e.equivRange.toEmbedding)⟩⟩\n    rw [← hs, closure_le]\n    intro x hx\n    refine ⟨f (out x).1 i (hi (out x).1 (Finset.mem_image_of_mem _ hx)) (out x).2, ?_⟩\n    rw [Embedding.coe_toHom, DirectLimit.of_apply, @Quotient.mk_eq_iff_out _ (_),\n      DirectLimit.equiv_iff G f _ (hi (out x).1 (Finset.mem_image_of_mem _ hx)),\n      DirectedSystem.map_self]\n  · rintro ⟨i, Mfg, ⟨e⟩⟩\n    exact ⟨Mfg, ⟨Embedding.comp (DirectLimit.of L ι G f i) e⟩⟩\n\n"}
{"name":"FirstOrder.Language.exists_cg_is_age_of","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nhn : K.Nonempty\nhc : (Set.image Quotient.mk' K).Countable\nfg : ∀ (M : CategoryTheory.Bundled L.Structure), Membership.mem K M → FirstOrder.Language.Structure.FG L ↑M\nhp : FirstOrder.Language.Hereditary K\njep : FirstOrder.Language.JointEmbedding K\n⊢ Exists fun M => And (FirstOrder.Language.Structure.CG L ↑M) (Eq (L.age ↑M) K)","decl":"/-- Sufficient conditions for a class to be the age of a countably-generated structure. -/\ntheorem exists_cg_is_age_of (hn : K.Nonempty)\n    (hc : (Quotient.mk' '' K).Countable)\n    (fg : ∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) (hp : Hereditary K)\n    (jep : JointEmbedding K) : ∃ M : Bundled.{w} L.Structure, Structure.CG L M ∧ L.age M = K := by\n  obtain ⟨F, hF⟩ := hc.exists_eq_range (hn.image _)\n  simp only [Set.ext_iff, Quotient.forall, mem_image, mem_range, Quotient.eq'] at hF\n  simp_rw [Quotient.eq_mk_iff_out] at hF\n  have hF' : ∀ n : ℕ, (F n).out ∈ K := by\n    intro n\n    obtain ⟨P, hP1, hP2⟩ := (hF (F n).out).2 ⟨n, Setoid.refl _⟩\n    -- Porting note: fix hP2 because `Quotient.out (Quotient.mk' x) ≈ a` was not simplified\n    -- to `x ≈ a` in hF\n    replace hP2 := Setoid.trans (Setoid.symm (Quotient.mk_out P)) hP2\n    exact (hp.is_equiv_invariant_of_fg fg _ _ hP2).1 hP1\n  choose P hPK hP hFP using fun (N : K) (n : ℕ) => jep N N.2 (F (n + 1)).out (hF' _)\n  let G : ℕ → K := @Nat.rec (fun _ => K) ⟨(F 0).out, hF' 0⟩ fun n N => ⟨P N n, hPK N n⟩\n  -- Poting note: was\n  -- let f : ∀ i j, i ≤ j → G i ↪[L] G j := DirectedSystem.natLeRec fun n => (hP _ n).some\n  let f : ∀ (i j : ℕ), i ≤ j → (G i).val ↪[L] (G j).val := by\n    refine DirectedSystem.natLERec (G' := fun i => (G i).val) (L := L) ?_\n    dsimp only [G]\n    exact fun n => (hP _ n).some\n  have : DirectedSystem (fun n ↦ (G n).val) fun i j h ↦ ↑(f i j h) := by\n    dsimp [f, G]; infer_instance\n  refine ⟨Bundled.of (@DirectLimit L _ _ (fun n ↦ (G n).val) _ f _ _), ?_, ?_⟩\n  · exact DirectLimit.cg _ (fun n => (fg _ (G n).2).cg)\n  · refine (age_directLimit (fun n ↦ (G n).val) f).trans\n      (subset_antisymm (iUnion_subset fun n N hN => hp (G n).val (G n).2 hN) fun N KN => ?_)\n    have : Quotient.out (Quotient.mk' N) ≈ N := Quotient.eq_mk_iff_out.mp rfl\n    obtain ⟨n, ⟨e⟩⟩ := (hF N).1 ⟨N, KN, this⟩\n    refine mem_iUnion_of_mem n ⟨fg _ KN, ⟨Embedding.comp ?_ e.symm.toEmbedding⟩⟩\n    cases' n with n\n    · dsimp [G]; exact Embedding.refl _ _\n    · dsimp [G]; exact (hFP _ n).some\n\n"}
{"name":"FirstOrder.Language.exists_countable_is_age_of_iff","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\ninst✝ : Countable (Sigma fun l => L.Functions l)\n⊢ Iff (Exists fun M => And (Countable ↑M) (Eq (L.age ↑M) K)) (And K.Nonempty (And (∀ (M N : CategoryTheory.Bundled L.Structure), Nonempty (L.Equiv ↑M ↑N) → Iff (Membership.mem K M) (Membership.mem K N)) (And (Set.image Quotient.mk' K).Countable (And (∀ (M : CategoryTheory.Bundled L.Structure), Membership.mem K M → FirstOrder.Language.Structure.FG L ↑M) (And (FirstOrder.Language.Hereditary K) (FirstOrder.Language.JointEmbedding K))))))","decl":"theorem exists_countable_is_age_of_iff [Countable (Σ l, L.Functions l)] :\n    (∃ M : Bundled.{w} L.Structure, Countable M ∧ L.age M = K) ↔\n      K.Nonempty ∧ (∀ M N : Bundled.{w} L.Structure, Nonempty (M ≃[L] N) → (M ∈ K ↔ N ∈ K)) ∧\n      (Quotient.mk' '' K).Countable ∧ (∀ M : Bundled.{w} L.Structure, M ∈ K → Structure.FG L M) ∧\n      Hereditary K ∧ JointEmbedding K := by\n  constructor\n  · rintro ⟨M, h1, h2, rfl⟩\n    refine ⟨age.nonempty M, age.is_equiv_invariant L M, age.countable_quotient M, fun N hN => hN.1,\n      age.hereditary M, age.jointEmbedding M⟩\n  · rintro ⟨Kn, _, cq, hfg, hp, jep⟩\n    obtain ⟨M, hM, rfl⟩ := exists_cg_is_age_of Kn cq hfg hp jep\n    exact ⟨M, Structure.cg_iff_countable.1 hM, rfl⟩\n\n"}
{"name":"FirstOrder.Language.IsFraisseLimit.age","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : Countable (Sigma fun l => L.Functions l)\ninst✝ : Countable M\nself : FirstOrder.Language.IsFraisseLimit K M\n⊢ Eq (L.age M) K","decl":"/-- A structure `M` is a Fraïssé limit for a class `K` if it is countably generated,\nultrahomogeneous, and has age `K`. -/\nstructure IsFraisseLimit [Countable (Σ l, L.Functions l)] [Countable M] : Prop where\n  protected ultrahomogeneous : IsUltrahomogeneous L M\n  protected age : L.age M = K\n\n"}
{"name":"FirstOrder.Language.IsFraisseLimit.ultrahomogeneous","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : Countable (Sigma fun l => L.Functions l)\ninst✝ : Countable M\nself : FirstOrder.Language.IsFraisseLimit K M\n⊢ L.IsUltrahomogeneous M","decl":"/-- A structure `M` is a Fraïssé limit for a class `K` if it is countably generated,\nultrahomogeneous, and has age `K`. -/\nstructure IsFraisseLimit [Countable (Σ l, L.Functions l)] [Countable M] : Prop where\n  protected ultrahomogeneous : IsUltrahomogeneous L M\n  protected age : L.age M = K\n\n"}
{"name":"FirstOrder.Language.IsUltrahomogeneous.extend_embedding","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝² : L.Structure M\nM_homog : L.IsUltrahomogeneous M\nS : Type u_1\ninst✝¹ : L.Structure S\nS_FG : FirstOrder.Language.Structure.FG L S\nT : Type u_2\ninst✝ : L.Structure T\nh : Nonempty (L.Embedding T M)\nf : L.Embedding S M\ng : L.Embedding S T\n⊢ Exists fun f' => Eq f (f'.comp g)","decl":"/-- Any embedding from a finitely generated `S` to an ultrahomogeneous structure `M`\ncan be extended to an embedding from any structure with an embedding to `M`. -/\ntheorem IsUltrahomogeneous.extend_embedding (M_homog : L.IsUltrahomogeneous M) {S : Type*}\n    [L.Structure S] (S_FG : FG L S) {T : Type*} [L.Structure T] [h : Nonempty (T ↪[L] M)]\n    (f : S ↪[L] M) (g : S ↪[L] T) :\n    ∃ f' : T ↪[L] M, f = f'.comp g := by\n  let ⟨r⟩ := h\n  let s := r.comp g\n  let ⟨t, eq⟩ := M_homog s.toHom.range (S_FG.range s.toHom) (f.comp s.equivRange.symm.toEmbedding)\n  use t.toEmbedding.comp r\n  change _ = t.toEmbedding.comp s\n  ext x\n  have eq' := congr_fun (congr_arg DFunLike.coe eq) ⟨s x, Hom.mem_range.2 ⟨x, rfl⟩⟩\n  simp only [Embedding.comp_apply, Hom.comp_apply,\n    Equiv.coe_toHom, Embedding.coe_toHom, coeSubtype] at eq'\n  simp only [Embedding.comp_apply, ← eq', Equiv.coe_toEmbedding, EmbeddingLike.apply_eq_iff_eq]\n  apply (Embedding.equivRange (Embedding.comp r g)).injective\n  ext\n  simp only [Equiv.apply_symm_apply, Embedding.equivRange_apply, s]\n\n"}
{"name":"FirstOrder.Language.isUltrahomogeneous_iff_IsExtensionPair","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nM_CG : FirstOrder.Language.Structure.CG L M\n⊢ Iff (L.IsUltrahomogeneous M) (L.IsExtensionPair M M)","decl":"/-- A countably generated structure is ultrahomogeneous if and only if any equivalence between\nfinitely generated substructures can be extended to any element in the domain.-/\ntheorem isUltrahomogeneous_iff_IsExtensionPair (M_CG : CG L M) : L.IsUltrahomogeneous M ↔\n    L.IsExtensionPair M M := by\n  constructor\n  · intro M_homog ⟨f, f_FG⟩ m\n    let S := f.dom ⊔ closure L {m}\n    have dom_le_S : f.dom ≤ S := le_sup_left\n    let ⟨f', eq_f'⟩ := M_homog.extend_embedding (f.dom.fg_iff_structure_fg.1 f_FG)\n      ((subtype _).comp f.toEquiv.toEmbedding) (inclusion dom_le_S) (h := ⟨subtype _⟩)\n    refine ⟨⟨⟨S, f'.toHom.range, f'.equivRange⟩, f_FG.sup (fg_closure_singleton _)⟩,\n      subset_closure.trans (le_sup_right : _ ≤ S) (mem_singleton m), ⟨dom_le_S, ?_⟩⟩\n    ext\n    simp only [Embedding.comp_apply, Equiv.coe_toEmbedding, coeSubtype, eq_f',\n      Embedding.equivRange_apply, Substructure.coe_inclusion, EmbeddingLike.apply_eq_iff_eq]\n  · intro h S S_FG f\n    let ⟨g, ⟨dom_le_dom, eq⟩⟩ :=\n      equiv_between_cg M_CG M_CG ⟨⟨S, f.toHom.range, f.equivRange⟩, S_FG⟩ h h\n    use g\n    simp only [Embedding.subtype_equivRange] at eq\n    rw [← eq]\n    ext\n    rfl\n\n"}
{"name":"FirstOrder.Language.IsUltrahomogeneous.amalgamation_age","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝ : L.Structure M\nh : L.IsUltrahomogeneous M\n⊢ FirstOrder.Language.Amalgamation (L.age M)","decl":"theorem IsUltrahomogeneous.amalgamation_age (h : L.IsUltrahomogeneous M) :\n    Amalgamation (L.age M) := by\n  rintro N P Q NP NQ ⟨Nfg, ⟨-⟩⟩ ⟨Pfg, ⟨PM⟩⟩ ⟨Qfg, ⟨QM⟩⟩\n  obtain ⟨g, hg⟩ := h (PM.comp NP).toHom.range (Nfg.range _)\n    ((QM.comp NQ).comp (PM.comp NP).equivRange.symm.toEmbedding)\n  let s := (g.toHom.comp PM.toHom).range ⊔ QM.toHom.range\n  refine ⟨Bundled.of s,\n    Embedding.comp (Substructure.inclusion le_sup_left)\n      (g.toEmbedding.comp PM).equivRange.toEmbedding,\n    Embedding.comp (Substructure.inclusion le_sup_right) QM.equivRange.toEmbedding,\n    ⟨(fg_iff_structure_fg _).1 (FG.sup (Pfg.range _) (Qfg.range _)), ⟨Substructure.subtype _⟩⟩, ?_⟩\n  ext n\n  apply Subtype.ext\n  have hgn := (Embedding.ext_iff.1 hg) ((PM.comp NP).equivRange n)\n  simp only [Embedding.comp_apply, Equiv.coe_toEmbedding, Equiv.symm_apply_apply,\n    Substructure.coeSubtype, Embedding.equivRange_apply] at hgn\n  simp only [Embedding.comp_apply, Equiv.coe_toEmbedding]\n  erw [Substructure.coe_inclusion, Substructure.coe_inclusion]\n  simp only [Embedding.comp_apply, Equiv.coe_toEmbedding, Set.coe_inclusion,\n    Embedding.equivRange_apply, hgn]\n  -- This used to be `simp only [...]` before https://github.com/leanprover/lean4/pull/2644\n  erw [Embedding.comp_apply, Equiv.coe_toEmbedding,\n    Embedding.equivRange_apply]\n  simp\n\n"}
{"name":"FirstOrder.Language.IsUltrahomogeneous.age_isFraisse","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nM : Type w\ninst✝¹ : L.Structure M\ninst✝ : Countable M\nh : L.IsUltrahomogeneous M\n⊢ FirstOrder.Language.IsFraisse (L.age M)","decl":"theorem IsUltrahomogeneous.age_isFraisse [Countable M] (h : L.IsUltrahomogeneous M) :\n    IsFraisse (L.age M) :=\n  ⟨age.nonempty M, fun _ hN => hN.1, age.countable_quotient M,\n    age.hereditary M, age.jointEmbedding M, h.amalgamation_age⟩\n\n"}
{"name":"FirstOrder.Language.IsFraisseLimit.isFraisse","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nM : Type w\ninst✝² : L.Structure M\ninst✝¹ : Countable (Sigma fun l => L.Functions l)\ninst✝ : Countable M\nh : FirstOrder.Language.IsFraisseLimit K M\n⊢ FirstOrder.Language.IsFraisse K","decl":"/-- If a class has a Fraïssé limit, it must be Fraïssé. -/\ntheorem isFraisse [Countable (Σ l, L.Functions l)] [Countable M] (h : IsFraisseLimit K M) :\n    IsFraisse K :=\n  (congr rfl h.age).mp h.ultrahomogeneous.age_isFraisse\n\n"}
{"name":"FirstOrder.Language.IsFraisseLimit.isExtensionPair","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nM : Type w\ninst✝⁴ : L.Structure M\nN : Type w\ninst✝³ : L.Structure N\ninst✝² : Countable (Sigma fun l => L.Functions l)\ninst✝¹ : Countable M\ninst✝ : Countable N\nhM : FirstOrder.Language.IsFraisseLimit K M\nhN : FirstOrder.Language.IsFraisseLimit K N\n⊢ L.IsExtensionPair M N","decl":"protected theorem isExtensionPair : L.IsExtensionPair M N := by\n  intro ⟨f, f_FG⟩ m\n  let S := f.dom ⊔ closure L {m}\n  have S_FG : S.FG := f_FG.sup (Substructure.fg_closure_singleton _)\n  have S_in_age_N : ⟨S, inferInstance⟩ ∈ L.age N := by\n    rw [hN.age, ← hM.age]\n    exact ⟨(fg_iff_structure_fg S).1 S_FG, ⟨subtype _⟩⟩\n  haveI nonempty_S_N : Nonempty (S ↪[L] N) := S_in_age_N.2\n  let ⟨g, g_eq⟩ := hN.ultrahomogeneous.extend_embedding (f.dom.fg_iff_structure_fg.1 f_FG)\n    ((subtype f.cod).comp f.toEquiv.toEmbedding) (inclusion (le_sup_left : _ ≤ S))\n  refine ⟨⟨⟨S, g.toHom.range, g.equivRange⟩, S_FG⟩,\n    subset_closure.trans (le_sup_right : _ ≤ S) (mem_singleton m), ⟨le_sup_left, ?_⟩⟩\n  ext\n  simp [S, Subtype.mk_le_mk, PartialEquiv.le_def, g_eq]\n\n"}
{"name":"FirstOrder.Language.IsFraisseLimit.nonempty_equiv","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"L : FirstOrder.Language\nK : Set (CategoryTheory.Bundled L.Structure)\nM : Type w\ninst✝⁴ : L.Structure M\nN : Type w\ninst✝³ : L.Structure N\ninst✝² : Countable (Sigma fun l => L.Functions l)\ninst✝¹ : Countable M\ninst✝ : Countable N\nhM : FirstOrder.Language.IsFraisseLimit K M\nhN : FirstOrder.Language.IsFraisseLimit K N\n⊢ Nonempty (L.Equiv M N)","decl":"/-- The Fraïssé limit of a class is unique, in that any two Fraïssé limits are isomorphic. -/\ntheorem nonempty_equiv : Nonempty (M ≃[L] N) := by\n  let S : L.Substructure M := ⊥\n  have S_fg : FG L S := (fg_iff_structure_fg _).1 Substructure.fg_bot\n  obtain ⟨_, ⟨emb_S : S ↪[L] N⟩⟩ : ⟨S, inferInstance⟩ ∈ L.age N := by\n    rw [hN.age, ← hM.age]\n    exact ⟨S_fg, ⟨subtype _⟩⟩\n  let v : M ≃ₚ[L] N := {\n    dom := S\n    cod := emb_S.toHom.range\n    toEquiv := emb_S.equivRange\n  }\n  exact ⟨Exists.choose (equiv_between_cg cg_of_countable cg_of_countable\n    ⟨v, ((Substructure.fg_iff_structure_fg _).2 S_fg)⟩ (hM.isExtensionPair hN)\n      (hN.isExtensionPair hM))⟩\n\n"}
{"name":"FirstOrder.Language.empty.isFraisseLimit_of_countable_infinite","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"M : Type u_1\ninst✝² : Countable M\ninst✝¹ : Infinite M\ninst✝ : FirstOrder.Language.empty.Structure M\n⊢ FirstOrder.Language.IsFraisseLimit (setOf fun S => Finite ↑S) M","decl":"/-- Any countable infinite structure in the empty language is a Fraïssé limit of the class of finite\nstructures. -/\ntheorem isFraisseLimit_of_countable_infinite\n    (M : Type*) [Countable M] [Infinite M] [Language.empty.Structure M] :\n    IsFraisseLimit { S : Bundled Language.empty.Structure | Finite S } M where\n  age := by\n    ext S\n    simp only [age, Structure.fg_iff_finite, mem_setOf_eq, and_iff_left_iff_imp]\n    intro hS\n    simp\n  ultrahomogeneous S hS f := by\n    classical\n    have : Finite S := hS.finite\n    have : Infinite { x // x ∉ S } := ((Set.toFinite _).infinite_compl).to_subtype\n    have : Finite f.toHom.range := (((Substructure.fg_iff_structure_fg S).1 hS).range _).finite\n    have : Infinite { x // x ∉ f.toHom.range } := ((Set.toFinite _).infinite_compl ).to_subtype\n    refine ⟨StrongHomClass.toEquiv (f.equivRange.subtypeCongr nonempty_equiv_of_countable.some), ?_⟩\n    ext x\n    simp [Equiv.subtypeCongr]\n\n"}
{"name":"FirstOrder.Language.empty.isFraisse_finite","module":"Mathlib.ModelTheory.Fraisse","initialProofState":"⊢ FirstOrder.Language.IsFraisse (setOf fun S => Finite ↑S)","decl":"/-- The class of finite structures in the empty language is Fraïssé. -/\ntheorem isFraisse_finite : IsFraisse { S : Bundled.{w} Language.empty.Structure | Finite S } := by\n  have : Language.empty.Structure (ULift ℕ : Type w) := emptyStructure\n  exact (isFraisseLimit_of_countable_infinite (ULift ℕ)).isFraisse\n\n"}
