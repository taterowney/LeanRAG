{"name":"nontrivial_of_lt","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nx y : α\nh : LT.lt x y\n⊢ Nontrivial α","decl":"theorem nontrivial_of_lt [Preorder α] (x y : α) (h : x < y) : Nontrivial α :=\n  ⟨⟨x, y, ne_of_lt h⟩⟩\n\n"}
{"name":"exists_pair_lt","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_3\ninst✝¹ : Nontrivial α\ninst✝ : LinearOrder α\n⊢ Exists fun x => Exists fun y => LT.lt x y","decl":"theorem exists_pair_lt (α : Type*) [Nontrivial α] [LinearOrder α] : ∃ x y : α, x < y := by\n  rcases exists_pair_ne α with ⟨x, y, hxy⟩\n  cases lt_or_gt_of_ne hxy <;> exact ⟨_, _, ‹_›⟩\n\n"}
{"name":"nontrivial_iff_lt","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\n⊢ Iff (Nontrivial α) (Exists fun x => Exists fun y => LT.lt x y)","decl":"theorem nontrivial_iff_lt [LinearOrder α] : Nontrivial α ↔ ∃ x y : α, x < y :=\n  ⟨fun h ↦ @exists_pair_lt α h _, fun ⟨x, y, h⟩ ↦ nontrivial_of_lt x y h⟩\n\n"}
{"name":"Subtype.nontrivial_iff_exists_ne","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\np : α → Prop\nx : Subtype p\n⊢ Iff (Nontrivial (Subtype p)) (Exists fun y => Exists fun x_1 => Ne y x.val)","decl":"theorem Subtype.nontrivial_iff_exists_ne (p : α → Prop) (x : Subtype p) :\n    Nontrivial (Subtype p) ↔ ∃ (y : α) (_ : p y), y ≠ x := by\n  simp only [_root_.nontrivial_iff_exists_ne x, Subtype.exists, Ne, Subtype.ext_iff]\n\n"}
{"name":"Option.nontrivial","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\ninst✝ : Nonempty α\n⊢ Nontrivial (Option α)","decl":"instance Option.nontrivial [Nonempty α] : Nontrivial (Option α) := by\n  inhabit α\n  exact ⟨none, some default, nofun⟩\n\n"}
{"name":"Function.Injective.nontrivial","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nontrivial α\nf : α → β\nhf : Function.Injective f\n⊢ Nontrivial β","decl":"/-- Pushforward a `Nontrivial` instance along an injective function. -/\nprotected theorem Function.Injective.nontrivial [Nontrivial α] {f : α → β}\n    (hf : Function.Injective f) : Nontrivial β :=\n  let ⟨x, y, h⟩ := exists_pair_ne α\n  ⟨⟨f x, f y, hf.ne h⟩⟩\n\n"}
{"name":"Function.Injective.exists_ne","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : Nontrivial α\nf : α → β\nhf : Function.Injective f\ny : β\n⊢ Exists fun x => Ne (f x) y","decl":"/-- An injective function from a nontrivial type has an argument at\nwhich it does not take a given value. -/\nprotected theorem Function.Injective.exists_ne [Nontrivial α] {f : α → β}\n    (hf : Function.Injective f) (y : β) : ∃ x, f x ≠ y := by\n  rcases exists_pair_ne α with ⟨x₁, x₂, hx⟩\n  by_cases h : f x₂ = y\n  · exact ⟨x₁, (hf.ne_iff' h).2 hx⟩\n  · exact ⟨x₂, h⟩\n\n"}
{"name":"nontrivial_prod_right","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Nonempty α\ninst✝ : Nontrivial β\n⊢ Nontrivial (Prod α β)","decl":"instance nontrivial_prod_right [Nonempty α] [Nontrivial β] : Nontrivial (α × β) :=\n  Prod.snd_surjective.nontrivial\n\n"}
{"name":"nontrivial_prod_left","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Nontrivial α\ninst✝ : Nonempty β\n⊢ Nontrivial (Prod α β)","decl":"instance nontrivial_prod_left [Nontrivial α] [Nonempty β] : Nontrivial (α × β) :=\n  Prod.fst_surjective.nontrivial\n\n"}
{"name":"Pi.nontrivial_at","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"I : Type u_3\nf : I → Type u_4\ni' : I\ninst : ∀ (i : I), Nonempty (f i)\ninst✝ : Nontrivial (f i')\n⊢ Nontrivial ((i : I) → f i)","decl":"open Classical in\n/-- A pi type is nontrivial if it's nonempty everywhere and nontrivial somewhere. -/\ntheorem nontrivial_at (i' : I) [inst : ∀ i, Nonempty (f i)] [Nontrivial (f i')] :\n    Nontrivial (∀ i : I, f i) := by\n  letI := Classical.decEq (∀ i : I, f i)\n  exact (Function.update_injective (fun i ↦ Classical.choice (inst i)) i').nontrivial\n\n"}
{"name":"Pi.nontrivial","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"I : Type u_3\nf : I → Type u_4\ninst✝² : Inhabited I\ninst✝¹ : ∀ (i : I), Nonempty (f i)\ninst✝ : Nontrivial (f Inhabited.default)\n⊢ Nontrivial ((i : I) → f i)","decl":"/-- As a convenience, provide an instance automatically if `(f default)` is nontrivial.\n\nIf a different index has the non-trivial type, then use `haveI := nontrivial_at that_index`.\n-/\ninstance nontrivial [Inhabited I] [∀ i, Nonempty (f i)] [Nontrivial (f default)] :\n    Nontrivial (∀ i : I, f i) :=\n  nontrivial_at default\n\n"}
{"name":"Function.nontrivial","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\nβ : Type u_2\nh : Nonempty α\ninst✝ : Nontrivial β\n⊢ Nontrivial (α → β)","decl":"instance Function.nontrivial [h : Nonempty α] [Nontrivial β] : Nontrivial (α → β) :=\n  h.elim fun a ↦ Pi.nontrivial_at a\n\n"}
{"name":"Subsingleton.le","module":"Mathlib.Logic.Nontrivial.Basic","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\ninst✝ : Subsingleton α\nx y : α\n⊢ LE.le x y","decl":"@[nontriviality]\nprotected theorem Subsingleton.le [Preorder α] [Subsingleton α] (x y : α) : x ≤ y :=\n  le_of_eq (Subsingleton.elim x y)\n"}
