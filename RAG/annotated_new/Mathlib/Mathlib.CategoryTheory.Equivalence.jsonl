{"name":"CategoryTheory.Equivalence.mk'.inj","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nfunctor‚úù : CategoryTheory.Functor C D\ninverse‚úù : CategoryTheory.Functor D C\nunitIso‚úù : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor‚úù.comp inverse‚úù)\ncounitIso‚úù : CategoryTheory.Iso (inverse‚úù.comp functor‚úù) (CategoryTheory.Functor.id D)\nfunctor_unitIso_comp‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor‚úù.map (unitIso‚úù.hom.app X)) (counitIso‚úù.hom.app (functor‚úù.obj X))) (CategoryTheory.CategoryStruct.id (functor‚úù.obj X))) _auto‚úù\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunitIso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounitIso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nfunctor_unitIso_comp : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unitIso.hom.app X)) (counitIso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))) _auto‚úù\nx‚úù : Eq { functor := functor‚úù, inverse := inverse‚úù, unitIso := unitIso‚úù, counitIso := counitIso‚úù, functor_unitIso_comp := functor_unitIso_comp‚úù } { functor := functor, inverse := inverse, unitIso := unitIso, counitIso := counitIso, functor_unitIso_comp := functor_unitIso_comp }\n‚ä¢ And (Eq functor‚úù functor) (And (Eq inverse‚úù inverse) (And (HEq unitIso‚úù unitIso) (HEq counitIso‚úù counitIso)))","decl":"/-- We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `FŒ∑ ‚â´ ŒµF = 1`, or in other\n  words the composite `F ‚ü∂ FGF ‚ü∂ F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G ‚ü∂ GFG ‚ü∂ G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F ‚ü∂ F1`. -/\n@[ext, stacks 001J]\nstructure Equivalence (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D] where mk' ::\n  /-- A functor in one direction -/\n  functor : C ‚•§ D\n  /-- A functor in the other direction -/\n  inverse : D ‚•§ C\n  /-- The composition `functor ‚ãô inverse` is isomorphic to the identity -/\n  unitIso : ùü≠ C ‚âÖ functor ‚ãô inverse\n  /-- The composition `inverse ‚ãô functor` is also isomorphic to the identity -/\n  counitIso : inverse ‚ãô functor ‚âÖ ùü≠ D\n  /-- The natural isomorphisms compose to the identity. -/\n  functor_unitIso_comp :\n    ‚àÄ X : C, functor.map (unitIso.hom.app X) ‚â´ counitIso.hom.app (functor.obj X) =\n      ùüô (functor.obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.mk'.injEq","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nfunctor‚úù : CategoryTheory.Functor C D\ninverse‚úù : CategoryTheory.Functor D C\nunitIso‚úù : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor‚úù.comp inverse‚úù)\ncounitIso‚úù : CategoryTheory.Iso (inverse‚úù.comp functor‚úù) (CategoryTheory.Functor.id D)\nfunctor_unitIso_comp‚úù : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor‚úù.map (unitIso‚úù.hom.app X)) (counitIso‚úù.hom.app (functor‚úù.obj X))) (CategoryTheory.CategoryStruct.id (functor‚úù.obj X))) _auto‚úù\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunitIso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounitIso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nfunctor_unitIso_comp : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unitIso.hom.app X)) (counitIso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))) _auto‚úù\n‚ä¢ Eq (Eq { functor := functor‚úù, inverse := inverse‚úù, unitIso := unitIso‚úù, counitIso := counitIso‚úù, functor_unitIso_comp := functor_unitIso_comp‚úù } { functor := functor, inverse := inverse, unitIso := unitIso, counitIso := counitIso, functor_unitIso_comp := functor_unitIso_comp }) (And (Eq functor‚úù functor) (And (Eq inverse‚úù inverse) (And (HEq unitIso‚úù unitIso) (HEq counitIso‚úù counitIso))))","decl":"/-- We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `FŒ∑ ‚â´ ŒµF = 1`, or in other\n  words the composite `F ‚ü∂ FGF ‚ü∂ F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G ‚ü∂ GFG ‚ü∂ G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F ‚ü∂ F1`. -/\n@[ext, stacks 001J]\nstructure Equivalence (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D] where mk' ::\n  /-- A functor in one direction -/\n  functor : C ‚•§ D\n  /-- A functor in the other direction -/\n  inverse : D ‚•§ C\n  /-- The composition `functor ‚ãô inverse` is isomorphic to the identity -/\n  unitIso : ùü≠ C ‚âÖ functor ‚ãô inverse\n  /-- The composition `inverse ‚ãô functor` is also isomorphic to the identity -/\n  counitIso : inverse ‚ãô functor ‚âÖ ùü≠ D\n  /-- The natural isomorphisms compose to the identity. -/\n  functor_unitIso_comp :\n    ‚àÄ X : C, functor.map (unitIso.hom.app X) ‚â´ counitIso.hom.app (functor.obj X) =\n      ùüô (functor.obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.mk'.sizeOf_spec","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ninst‚úù¬π : SizeOf C\ninst‚úù : SizeOf D\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunitIso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounitIso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nfunctor_unitIso_comp : autoParam (‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unitIso.hom.app X)) (counitIso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { functor := functor, inverse := inverse, unitIso := unitIso, counitIso := counitIso, functor_unitIso_comp := functor_unitIso_comp }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf functor)) (SizeOf.sizeOf inverse)) (SizeOf.sizeOf unitIso)) (SizeOf.sizeOf counitIso))","decl":"/-- We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `FŒ∑ ‚â´ ŒµF = 1`, or in other\n  words the composite `F ‚ü∂ FGF ‚ü∂ F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G ‚ü∂ GFG ‚ü∂ G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F ‚ü∂ F1`. -/\n@[ext, stacks 001J]\nstructure Equivalence (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D] where mk' ::\n  /-- A functor in one direction -/\n  functor : C ‚•§ D\n  /-- A functor in the other direction -/\n  inverse : D ‚•§ C\n  /-- The composition `functor ‚ãô inverse` is isomorphic to the identity -/\n  unitIso : ùü≠ C ‚âÖ functor ‚ãô inverse\n  /-- The composition `inverse ‚ãô functor` is also isomorphic to the identity -/\n  counitIso : inverse ‚ãô functor ‚âÖ ùü≠ D\n  /-- The natural isomorphisms compose to the identity. -/\n  functor_unitIso_comp :\n    ‚àÄ X : C, functor.map (unitIso.hom.app X) ‚â´ counitIso.hom.app (functor.obj X) =\n      ùüô (functor.obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.ext","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nx y : CategoryTheory.Equivalence C D\nfunctor : Eq x.functor y.functor\ninverse : Eq x.inverse y.inverse\nunitIso : HEq x.unitIso y.unitIso\ncounitIso : HEq x.counitIso y.counitIso\n‚ä¢ Eq x y","decl":"/-- We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `FŒ∑ ‚â´ ŒµF = 1`, or in other\n  words the composite `F ‚ü∂ FGF ‚ü∂ F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G ‚ü∂ GFG ‚ü∂ G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F ‚ü∂ F1`. -/\n@[ext, stacks 001J]\nstructure Equivalence (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D] where mk' ::\n  /-- A functor in one direction -/\n  functor : C ‚•§ D\n  /-- A functor in the other direction -/\n  inverse : D ‚•§ C\n  /-- The composition `functor ‚ãô inverse` is isomorphic to the identity -/\n  unitIso : ùü≠ C ‚âÖ functor ‚ãô inverse\n  /-- The composition `inverse ‚ãô functor` is also isomorphic to the identity -/\n  counitIso : inverse ‚ãô functor ‚âÖ ùü≠ D\n  /-- The natural isomorphisms compose to the identity. -/\n  functor_unitIso_comp :\n    ‚àÄ X : C, functor.map (unitIso.hom.app X) ‚â´ counitIso.hom.app (functor.obj X) =\n      ùüô (functor.obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.functor_unitIso_comp","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nself : CategoryTheory.Equivalence C D\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (self.functor.map (self.unitIso.hom.app X)) (self.counitIso.hom.app (self.functor.obj X))) (CategoryTheory.CategoryStruct.id (self.functor.obj X))","decl":"/-- We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `FŒ∑ ‚â´ ŒµF = 1`, or in other\n  words the composite `F ‚ü∂ FGF ‚ü∂ F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G ‚ü∂ GFG ‚ü∂ G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F ‚ü∂ F1`. -/\n@[ext, stacks 001J]\nstructure Equivalence (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D] where mk' ::\n  /-- A functor in one direction -/\n  functor : C ‚•§ D\n  /-- A functor in the other direction -/\n  inverse : D ‚•§ C\n  /-- The composition `functor ‚ãô inverse` is isomorphic to the identity -/\n  unitIso : ùü≠ C ‚âÖ functor ‚ãô inverse\n  /-- The composition `inverse ‚ãô functor` is also isomorphic to the identity -/\n  counitIso : inverse ‚ãô functor ‚âÖ ùü≠ D\n  /-- The natural isomorphisms compose to the identity. -/\n  functor_unitIso_comp :\n    ‚àÄ X : C, functor.map (unitIso.hom.app X) ‚â´ counitIso.hom.app (functor.obj X) =\n      ùüô (functor.obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.ext_iff","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nx y : CategoryTheory.Equivalence C D\n‚ä¢ Iff (Eq x y) (And (Eq x.functor y.functor) (And (Eq x.inverse y.inverse) (And (HEq x.unitIso y.unitIso) (HEq x.counitIso y.counitIso))))","decl":"/-- We define an equivalence as a (half)-adjoint equivalence, a pair of functors with\n  a unit and counit which are natural isomorphisms and the triangle law `FŒ∑ ‚â´ ŒµF = 1`, or in other\n  words the composite `F ‚ü∂ FGF ‚ü∂ F` is the identity.\n\n  In `unit_inverse_comp`, we show that this is actually an adjoint equivalence, i.e., that the\n  composite `G ‚ü∂ GFG ‚ü∂ G` is also the identity.\n\n  The triangle equation is written as a family of equalities between morphisms, it is more\n  complicated if we write it as an equality of natural transformations, because then we would have\n  to insert natural transformations like `F ‚ü∂ F1`. -/\n@[ext, stacks 001J]\nstructure Equivalence (C : Type u‚ÇÅ) (D : Type u‚ÇÇ) [Category.{v‚ÇÅ} C] [Category.{v‚ÇÇ} D] where mk' ::\n  /-- A functor in one direction -/\n  functor : C ‚•§ D\n  /-- A functor in the other direction -/\n  inverse : D ‚•§ C\n  /-- The composition `functor ‚ãô inverse` is isomorphic to the identity -/\n  unitIso : ùü≠ C ‚âÖ functor ‚ãô inverse\n  /-- The composition `inverse ‚ãô functor` is also isomorphic to the identity -/\n  counitIso : inverse ‚ãô functor ‚âÖ ùü≠ D\n  /-- The natural isomorphisms compose to the identity. -/\n  functor_unitIso_comp :\n    ‚àÄ X : C, functor.map (unitIso.hom.app X) ‚â´ counitIso.hom.app (functor.obj X) =\n      ùüô (functor.obj X) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.Equivalence_mk'_unit","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunit_iso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounit_iso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nf : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unit_iso.hom.app X)) (counit_iso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))\n‚ä¢ Eq { functor := functor, inverse := inverse, unitIso := unit_iso, counitIso := counit_iso, functor_unitIso_comp := f }.unit unit_iso.hom","decl":"@[simp]\ntheorem Equivalence_mk'_unit (functor inverse unit_iso counit_iso f) :\n    (‚ü®functor, inverse, unit_iso, counit_iso, f‚ü© : C ‚âå D).unit = unit_iso.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.Equivalence_mk'_counit","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunit_iso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounit_iso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nf : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unit_iso.hom.app X)) (counit_iso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))\n‚ä¢ Eq { functor := functor, inverse := inverse, unitIso := unit_iso, counitIso := counit_iso, functor_unitIso_comp := f }.counit counit_iso.hom","decl":"@[simp]\ntheorem Equivalence_mk'_counit (functor inverse unit_iso counit_iso f) :\n    (‚ü®functor, inverse, unit_iso, counit_iso, f‚ü© : C ‚âå D).counit = counit_iso.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.Equivalence_mk'_unitInv","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunit_iso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounit_iso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nf : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unit_iso.hom.app X)) (counit_iso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))\n‚ä¢ Eq { functor := functor, inverse := inverse, unitIso := unit_iso, counitIso := counit_iso, functor_unitIso_comp := f }.unitInv unit_iso.inv","decl":"@[simp]\ntheorem Equivalence_mk'_unitInv (functor inverse unit_iso counit_iso f) :\n    (‚ü®functor, inverse, unit_iso, counit_iso, f‚ü© : C ‚âå D).unitInv = unit_iso.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.Equivalence_mk'_counitInv","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nfunctor : CategoryTheory.Functor C D\ninverse : CategoryTheory.Functor D C\nunit_iso : CategoryTheory.Iso (CategoryTheory.Functor.id C) (functor.comp inverse)\ncounit_iso : CategoryTheory.Iso (inverse.comp functor) (CategoryTheory.Functor.id D)\nf : ‚àÄ (X : C), Eq (CategoryTheory.CategoryStruct.comp (functor.map (unit_iso.hom.app X)) (counit_iso.hom.app (functor.obj X))) (CategoryTheory.CategoryStruct.id (functor.obj X))\n‚ä¢ Eq { functor := functor, inverse := inverse, unitIso := unit_iso, counitIso := counit_iso, functor_unitIso_comp := f }.counitInv counit_iso.inv","decl":"@[simp]\ntheorem Equivalence_mk'_counitInv (functor inverse unit_iso counit_iso f) :\n    (‚ü®functor, inverse, unit_iso, counit_iso, f‚ü© : C ‚âå D).counitInv = counit_iso.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.functor_unit_comp","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (e.unit.app X)) (e.counit.app (e.functor.obj X))) (CategoryTheory.CategoryStruct.id (e.functor.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem functor_unit_comp (e : C ‚âå D) (X : C) :\n    e.functor.map (e.unit.app X) ‚â´ e.counit.app (e.functor.obj X) = ùüô (e.functor.obj X) :=\n  e.functor_unitIso_comp X\n\n"}
{"name":"CategoryTheory.Equivalence.functor_unit_comp_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\nZ : D\nh : Quiver.Hom (e.functor.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (e.unit.app X)) (CategoryTheory.CategoryStruct.comp (e.counit.app (e.functor.obj X)) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem functor_unit_comp (e : C ‚âå D) (X : C) :\n    e.functor.map (e.unit.app X) ‚â´ e.counit.app (e.functor.obj X) = ùüô (e.functor.obj X) :=\n  e.functor_unitIso_comp X\n\n"}
{"name":"CategoryTheory.Equivalence.counitInv_functor_comp_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\nZ : D\nh : Quiver.Hom (e.functor.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.counitInv.app (e.functor.obj X)) (CategoryTheory.CategoryStruct.comp (e.functor.map (e.unitInv.app X)) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem counitInv_functor_comp (e : C ‚âå D) (X : C) :\n    e.counitInv.app (e.functor.obj X) ‚â´ e.functor.map (e.unitInv.app X) = ùüô (e.functor.obj X) := by\n  erw [Iso.inv_eq_inv (e.functor.mapIso (e.unitIso.app X) ‚â™‚â´ e.counitIso.app (e.functor.obj X))\n      (Iso.refl _)]\n  exact e.functor_unit_comp X\n\n"}
{"name":"CategoryTheory.Equivalence.counitInv_functor_comp","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.counitInv.app (e.functor.obj X)) (e.functor.map (e.unitInv.app X))) (CategoryTheory.CategoryStruct.id (e.functor.obj X))","decl":"@[reassoc (attr := simp)]\ntheorem counitInv_functor_comp (e : C ‚âå D) (X : C) :\n    e.counitInv.app (e.functor.obj X) ‚â´ e.functor.map (e.unitInv.app X) = ùüô (e.functor.obj X) := by\n  erw [Iso.inv_eq_inv (e.functor.mapIso (e.unitIso.app X) ‚â™‚â´ e.counitIso.app (e.functor.obj X))\n      (Iso.refl _)]\n  exact e.functor_unit_comp X\n\n"}
{"name":"CategoryTheory.Equivalence.counitInv_app_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\n‚ä¢ Eq (e.counitInv.app (e.functor.obj X)) (e.functor.map (e.unit.app X))","decl":"theorem counitInv_app_functor (e : C ‚âå D) (X : C) :\n    e.counitInv.app (e.functor.obj X) = e.functor.map (e.unit.app X) := by\n  symm\n  erw [‚Üê Iso.comp_hom_eq_id (e.counitIso.app _), functor_unit_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.counit_app_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX : C\n‚ä¢ Eq (e.counit.app (e.functor.obj X)) (e.functor.map (e.unitInv.app X))","decl":"theorem counit_app_functor (e : C ‚âå D) (X : C) :\n    e.counit.app (e.functor.obj X) = e.functor.map (e.unitInv.app X) := by\n  erw [‚Üê Iso.hom_comp_eq_id (e.functor.mapIso (e.unitIso.app X)), functor_unit_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.unit_inverse_comp","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.unit.app (e.inverse.obj Y)) (e.inverse.map (e.counit.app Y))) (CategoryTheory.CategoryStruct.id (e.inverse.obj Y))","decl":"/-- The other triangle equality. The proof follows the following proof in Globular:\n  http://globular.science/1905.001 -/\n@[reassoc (attr := simp)]\ntheorem unit_inverse_comp (e : C ‚âå D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) ‚â´ e.inverse.map (e.counit.app Y) = ùüô (e.inverse.obj Y) := by\n  rw [‚Üê id_comp (e.inverse.map _), ‚Üê map_id e.inverse, ‚Üê counitInv_functor_comp, map_comp]\n  dsimp\n  rw [‚Üê Iso.hom_inv_id_assoc (e.unitIso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]\n  slice_lhs 2 3 => erw [e.unit.naturality]\n  slice_lhs 1 2 => erw [e.unit.naturality]\n  slice_lhs 4 4 =>\n    rw [‚Üê Iso.hom_inv_id_assoc (e.inverse.mapIso (e.counitIso.app _)) (e.unitInv.app _)]\n  slice_lhs 3 4 =>\n    erw [‚Üê map_comp e.inverse, e.counit.naturality]\n    erw [(e.counitIso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 2 3 => erw [‚Üê map_comp e.inverse, e.counitIso.inv.naturality, map_comp]\n  slice_lhs 3 4 => erw [e.unitInv.naturality]\n  slice_lhs 4 5 => erw [‚Üê map_comp (e.functor ‚ãô e.inverse), (e.unitIso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 3 4 => erw [‚Üê e.unitInv.naturality]\n  slice_lhs 2 3 =>\n    erw [‚Üê map_comp e.inverse, ‚Üê e.counitIso.inv.naturality, (e.counitIso.app _).hom_inv_id,\n      map_id]\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.unit_inverse_comp_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nY : D\nZ : C\nh : Quiver.Hom (e.inverse.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.unit.app (e.inverse.obj Y)) (CategoryTheory.CategoryStruct.comp (e.inverse.map (e.counit.app Y)) h)) h","decl":"/-- The other triangle equality. The proof follows the following proof in Globular:\n  http://globular.science/1905.001 -/\n@[reassoc (attr := simp)]\ntheorem unit_inverse_comp (e : C ‚âå D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) ‚â´ e.inverse.map (e.counit.app Y) = ùüô (e.inverse.obj Y) := by\n  rw [‚Üê id_comp (e.inverse.map _), ‚Üê map_id e.inverse, ‚Üê counitInv_functor_comp, map_comp]\n  dsimp\n  rw [‚Üê Iso.hom_inv_id_assoc (e.unitIso.app _) (e.inverse.map (e.functor.map _)), app_hom, app_inv]\n  slice_lhs 2 3 => erw [e.unit.naturality]\n  slice_lhs 1 2 => erw [e.unit.naturality]\n  slice_lhs 4 4 =>\n    rw [‚Üê Iso.hom_inv_id_assoc (e.inverse.mapIso (e.counitIso.app _)) (e.unitInv.app _)]\n  slice_lhs 3 4 =>\n    erw [‚Üê map_comp e.inverse, e.counit.naturality]\n    erw [(e.counitIso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 2 3 => erw [‚Üê map_comp e.inverse, e.counitIso.inv.naturality, map_comp]\n  slice_lhs 3 4 => erw [e.unitInv.naturality]\n  slice_lhs 4 5 => erw [‚Üê map_comp (e.functor ‚ãô e.inverse), (e.unitIso.app _).hom_inv_id, map_id]\n  erw [id_comp]\n  slice_lhs 3 4 => erw [‚Üê e.unitInv.naturality]\n  slice_lhs 2 3 =>\n    erw [‚Üê map_comp e.inverse, ‚Üê e.counitIso.inv.naturality, (e.counitIso.app _).hom_inv_id,\n      map_id]\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.inverse_counitInv_comp_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nY : D\nZ : C\nh : Quiver.Hom (e.inverse.obj Y) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inverse.map (e.counitInv.app Y)) (CategoryTheory.CategoryStruct.comp (e.unitInv.app (e.inverse.obj Y)) h)) h","decl":"@[reassoc (attr := simp)]\ntheorem inverse_counitInv_comp (e : C ‚âå D) (Y : D) :\n    e.inverse.map (e.counitInv.app Y) ‚â´ e.unitInv.app (e.inverse.obj Y) = ùüô (e.inverse.obj Y) := by\n  erw [Iso.inv_eq_inv (e.unitIso.app (e.inverse.obj Y) ‚â™‚â´ e.inverse.mapIso (e.counitIso.app Y))\n      (Iso.refl _)]\n  exact e.unit_inverse_comp Y\n\n"}
{"name":"CategoryTheory.Equivalence.inverse_counitInv_comp","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nY : D\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inverse.map (e.counitInv.app Y)) (e.unitInv.app (e.inverse.obj Y))) (CategoryTheory.CategoryStruct.id (e.inverse.obj Y))","decl":"@[reassoc (attr := simp)]\ntheorem inverse_counitInv_comp (e : C ‚âå D) (Y : D) :\n    e.inverse.map (e.counitInv.app Y) ‚â´ e.unitInv.app (e.inverse.obj Y) = ùüô (e.inverse.obj Y) := by\n  erw [Iso.inv_eq_inv (e.unitIso.app (e.inverse.obj Y) ‚â™‚â´ e.inverse.mapIso (e.counitIso.app Y))\n      (Iso.refl _)]\n  exact e.unit_inverse_comp Y\n\n"}
{"name":"CategoryTheory.Equivalence.unit_app_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nY : D\n‚ä¢ Eq (e.unit.app (e.inverse.obj Y)) (e.inverse.map (e.counitInv.app Y))","decl":"theorem unit_app_inverse (e : C ‚âå D) (Y : D) :\n    e.unit.app (e.inverse.obj Y) = e.inverse.map (e.counitInv.app Y) := by\n  erw [‚Üê Iso.comp_hom_eq_id (e.inverse.mapIso (e.counitIso.app Y)), unit_inverse_comp]\n  dsimp\n\n"}
{"name":"CategoryTheory.Equivalence.unitInv_app_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nY : D\n‚ä¢ Eq (e.unitInv.app (e.inverse.obj Y)) (e.inverse.map (e.counit.app Y))","decl":"theorem unitInv_app_inverse (e : C ‚âå D) (Y : D) :\n    e.unitInv.app (e.inverse.obj Y) = e.inverse.map (e.counit.app Y) := by\n  symm\n  erw [‚Üê Iso.hom_comp_eq_id (e.unitIso.app _), unit_inverse_comp]\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.fun_inv_map_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : D\nf : Quiver.Hom X Y\nZ : D\nh : Quiver.Hom (e.functor.obj (e.inverse.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.functor.map (e.inverse.map f)) h) (CategoryTheory.CategoryStruct.comp (e.counit.app X) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (e.counitInv.app Y) h)))","decl":"@[reassoc, simp]\ntheorem fun_inv_map (e : C ‚âå D) (X Y : D) (f : X ‚ü∂ Y) :\n    e.functor.map (e.inverse.map f) = e.counit.app X ‚â´ f ‚â´ e.counitInv.app Y :=\n  (NatIso.naturality_2 e.counitIso f).symm\n\n"}
{"name":"CategoryTheory.Equivalence.fun_inv_map","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : D\nf : Quiver.Hom X Y\n‚ä¢ Eq (e.functor.map (e.inverse.map f)) (CategoryTheory.CategoryStruct.comp (e.counit.app X) (CategoryTheory.CategoryStruct.comp f (e.counitInv.app Y)))","decl":"@[reassoc, simp]\ntheorem fun_inv_map (e : C ‚âå D) (X Y : D) (f : X ‚ü∂ Y) :\n    e.functor.map (e.inverse.map f) = e.counit.app X ‚â´ f ‚â´ e.counitInv.app Y :=\n  (NatIso.naturality_2 e.counitIso f).symm\n\n"}
{"name":"CategoryTheory.Equivalence.inv_fun_map_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : C\nf : Quiver.Hom X Y\nZ : C\nh : Quiver.Hom (e.inverse.obj (e.functor.obj Y)) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (e.inverse.map (e.functor.map f)) h) (CategoryTheory.CategoryStruct.comp (e.unitInv.app X) (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (e.unit.app Y) h)))","decl":"@[reassoc, simp]\ntheorem inv_fun_map (e : C ‚âå D) (X Y : C) (f : X ‚ü∂ Y) :\n    e.inverse.map (e.functor.map f) = e.unitInv.app X ‚â´ f ‚â´ e.unit.app Y :=\n  (NatIso.naturality_1 e.unitIso f).symm\n\n"}
{"name":"CategoryTheory.Equivalence.inv_fun_map","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (e.inverse.map (e.functor.map f)) (CategoryTheory.CategoryStruct.comp (e.unitInv.app X) (CategoryTheory.CategoryStruct.comp f (e.unit.app Y)))","decl":"@[reassoc, simp]\ntheorem inv_fun_map (e : C ‚âå D) (X Y : C) (f : X ‚ü∂ Y) :\n    e.inverse.map (e.functor.map f) = e.unitInv.app X ‚â´ f ‚â´ e.unit.app Y :=\n  (NatIso.naturality_1 e.unitIso f).symm\n\n"}
{"name":"CategoryTheory.Equivalence.adjointify_Œ∑_Œµ_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nŒ∑ : CategoryTheory.Iso (CategoryTheory.Functor.id C) (F.comp G)\nŒµ : CategoryTheory.Iso (G.comp F) (CategoryTheory.Functor.id D)\nX : C\nZ : D\nh : Quiver.Hom (F.obj X) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Equivalence.adjointifyŒ∑ Œ∑ Œµ).hom.app X)) (CategoryTheory.CategoryStruct.comp (Œµ.hom.app (F.obj X)) h)) h","decl":"@[reassoc]\ntheorem adjointify_Œ∑_Œµ (X : C) :\n    F.map ((adjointifyŒ∑ Œ∑ Œµ).hom.app X) ‚â´ Œµ.hom.app (F.obj X) = ùüô (F.obj X) := by\n  dsimp [adjointifyŒ∑,Trans.trans]\n  simp only [comp_id, assoc, map_comp]\n  have := Œµ.hom.naturality (F.map (Œ∑.inv.app X)); dsimp at this; rw [this]; clear this\n  rw [‚Üê assoc _ _ (F.map _)]\n  have := Œµ.hom.naturality (Œµ.inv.app <| F.obj X); dsimp at this; rw [this]; clear this\n  have := (Œµ.app <| F.obj X).hom_inv_id; dsimp at this; rw [this]; clear this\n  rw [id_comp]; have := (F.mapIso <| Œ∑.app X).hom_inv_id; dsimp at this; rw [this]\n\n"}
{"name":"CategoryTheory.Equivalence.adjointify_Œ∑_Œµ","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nŒ∑ : CategoryTheory.Iso (CategoryTheory.Functor.id C) (F.comp G)\nŒµ : CategoryTheory.Iso (G.comp F) (CategoryTheory.Functor.id D)\nX : C\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Equivalence.adjointifyŒ∑ Œ∑ Œµ).hom.app X)) (Œµ.hom.app (F.obj X))) (CategoryTheory.CategoryStruct.id (F.obj X))","decl":"@[reassoc]\ntheorem adjointify_Œ∑_Œµ (X : C) :\n    F.map ((adjointifyŒ∑ Œ∑ Œµ).hom.app X) ‚â´ Œµ.hom.app (F.obj X) = ùüô (F.obj X) := by\n  dsimp [adjointifyŒ∑,Trans.trans]\n  simp only [comp_id, assoc, map_comp]\n  have := Œµ.hom.naturality (F.map (Œ∑.inv.app X)); dsimp at this; rw [this]; clear this\n  rw [‚Üê assoc _ _ (F.map _)]\n  have := Œµ.hom.naturality (Œµ.inv.app <| F.obj X); dsimp at this; rw [this]; clear this\n  have := (Œµ.app <| F.obj X).hom_inv_id; dsimp at this; rw [this]; clear this\n  rw [id_comp]; have := (F.mapIso <| Œ∑.app X).hom_inv_id; dsimp at this; rw [this]\n\n"}
{"name":"CategoryTheory.Equivalence.refl_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq CategoryTheory.Equivalence.refl.functor (CategoryTheory.Functor.id C)","decl":"/-- Equivalence of categories is reflexive. -/\n@[refl, simps]\ndef refl : C ‚âå C :=\n  ‚ü®ùü≠ C, ùü≠ C, Iso.refl _, Iso.refl _, fun _ => Category.id_comp _‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.refl_counitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq CategoryTheory.Equivalence.refl.counitIso (CategoryTheory.Iso.refl ((CategoryTheory.Functor.id C).comp (CategoryTheory.Functor.id C)))","decl":"/-- Equivalence of categories is reflexive. -/\n@[refl, simps]\ndef refl : C ‚âå C :=\n  ‚ü®ùü≠ C, ùü≠ C, Iso.refl _, Iso.refl _, fun _ => Category.id_comp _‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.refl_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq CategoryTheory.Equivalence.refl.inverse (CategoryTheory.Functor.id C)","decl":"/-- Equivalence of categories is reflexive. -/\n@[refl, simps]\ndef refl : C ‚âå C :=\n  ‚ü®ùü≠ C, ùü≠ C, Iso.refl _, Iso.refl _, fun _ => Category.id_comp _‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.refl_unitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ Eq CategoryTheory.Equivalence.refl.unitIso (CategoryTheory.Iso.refl (CategoryTheory.Functor.id C))","decl":"/-- Equivalence of categories is reflexive. -/\n@[refl, simps]\ndef refl : C ‚âå C :=\n  ‚ü®ùü≠ C, ùü≠ C, Iso.refl _, Iso.refl _, fun _ => Category.id_comp _‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.symm_counitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.symm.counitIso e.unitIso.symm","decl":"/-- Equivalence of categories is symmetric. -/\n@[symm, simps]\ndef symm (e : C ‚âå D) : D ‚âå C :=\n  ‚ü®e.inverse, e.functor, e.counitIso.symm, e.unitIso.symm, e.inverse_counitInv_comp‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.symm_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.symm.inverse e.functor","decl":"/-- Equivalence of categories is symmetric. -/\n@[symm, simps]\ndef symm (e : C ‚âå D) : D ‚âå C :=\n  ‚ü®e.inverse, e.functor, e.counitIso.symm, e.unitIso.symm, e.inverse_counitInv_comp‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.symm_unitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.symm.unitIso e.counitIso.symm","decl":"/-- Equivalence of categories is symmetric. -/\n@[symm, simps]\ndef symm (e : C ‚âå D) : D ‚âå C :=\n  ‚ü®e.inverse, e.functor, e.counitIso.symm, e.unitIso.symm, e.inverse_counitInv_comp‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.symm_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.symm.functor e.inverse","decl":"/-- Equivalence of categories is symmetric. -/\n@[symm, simps]\ndef symm (e : C ‚âå D) : D ‚âå C :=\n  ‚ü®e.inverse, e.functor, e.counitIso.symm, e.unitIso.symm, e.inverse_counitInv_comp‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.trans_counitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nf : CategoryTheory.Equivalence D E\n‚ä¢ Eq (e.trans f).counitIso (((f.inverse.comp e.inverse).associator e.functor f.functor).symm.trans ((CategoryTheory.isoWhiskerRight ((f.inverse.associator e.inverse e.functor).trans ((CategoryTheory.isoWhiskerLeft f.inverse e.counitIso).trans f.inverse.rightUnitor)) f.functor).trans f.counitIso))","decl":"/-- Equivalence of categories is transitive. -/\n@[trans, simps]\ndef trans (e : C ‚âå D) (f : D ‚âå E) : C ‚âå E where\n  functor := e.functor ‚ãô f.functor\n  inverse := f.inverse ‚ãô e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight (e.functor.rightUnitor.symm ‚â™‚â´\n    isoWhiskerLeft _ f.unitIso ‚â™‚â´ (Functor.associator _ _ _ ).symm) _ ‚â™‚â´ Functor.associator _ _ _\n  counitIso := (Functor.associator _ _ _ ).symm ‚â™‚â´ isoWhiskerRight ((Functor.associator _ _ _ ) ‚â™‚â´\n      isoWhiskerLeft _ e.counitIso ‚â™‚â´ f.inverse.rightUnitor) _ ‚â™‚â´ f.counitIso\n  -- We wouldn't have needed to give this proof if we'd used `Equivalence.mk`,\n  -- but we choose to avoid using that here, for the sake of good structure projection `simp`\n  -- lemmas.\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [comp_id, id_comp, map_comp, fun_inv_map, comp_obj, id_obj, counitInv,\n      functor_unit_comp_assoc, assoc]\n    slice_lhs 2 3 => rw [‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.trans_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nf : CategoryTheory.Equivalence D E\n‚ä¢ Eq (e.trans f).functor (e.functor.comp f.functor)","decl":"/-- Equivalence of categories is transitive. -/\n@[trans, simps]\ndef trans (e : C ‚âå D) (f : D ‚âå E) : C ‚âå E where\n  functor := e.functor ‚ãô f.functor\n  inverse := f.inverse ‚ãô e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight (e.functor.rightUnitor.symm ‚â™‚â´\n    isoWhiskerLeft _ f.unitIso ‚â™‚â´ (Functor.associator _ _ _ ).symm) _ ‚â™‚â´ Functor.associator _ _ _\n  counitIso := (Functor.associator _ _ _ ).symm ‚â™‚â´ isoWhiskerRight ((Functor.associator _ _ _ ) ‚â™‚â´\n      isoWhiskerLeft _ e.counitIso ‚â™‚â´ f.inverse.rightUnitor) _ ‚â™‚â´ f.counitIso\n  -- We wouldn't have needed to give this proof if we'd used `Equivalence.mk`,\n  -- but we choose to avoid using that here, for the sake of good structure projection `simp`\n  -- lemmas.\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [comp_id, id_comp, map_comp, fun_inv_map, comp_obj, id_obj, counitInv,\n      functor_unit_comp_assoc, assoc]\n    slice_lhs 2 3 => rw [‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.trans_unitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nf : CategoryTheory.Equivalence D E\n‚ä¢ Eq (e.trans f).unitIso (e.unitIso.trans ((CategoryTheory.isoWhiskerRight (e.functor.rightUnitor.symm.trans ((CategoryTheory.isoWhiskerLeft e.functor f.unitIso).trans (e.functor.associator f.functor f.inverse).symm)) e.inverse).trans ((e.functor.comp f.functor).associator f.inverse e.inverse)))","decl":"/-- Equivalence of categories is transitive. -/\n@[trans, simps]\ndef trans (e : C ‚âå D) (f : D ‚âå E) : C ‚âå E where\n  functor := e.functor ‚ãô f.functor\n  inverse := f.inverse ‚ãô e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight (e.functor.rightUnitor.symm ‚â™‚â´\n    isoWhiskerLeft _ f.unitIso ‚â™‚â´ (Functor.associator _ _ _ ).symm) _ ‚â™‚â´ Functor.associator _ _ _\n  counitIso := (Functor.associator _ _ _ ).symm ‚â™‚â´ isoWhiskerRight ((Functor.associator _ _ _ ) ‚â™‚â´\n      isoWhiskerLeft _ e.counitIso ‚â™‚â´ f.inverse.rightUnitor) _ ‚â™‚â´ f.counitIso\n  -- We wouldn't have needed to give this proof if we'd used `Equivalence.mk`,\n  -- but we choose to avoid using that here, for the sake of good structure projection `simp`\n  -- lemmas.\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [comp_id, id_comp, map_comp, fun_inv_map, comp_obj, id_obj, counitInv,\n      functor_unit_comp_assoc, assoc]\n    slice_lhs 2 3 => rw [‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.trans_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nf : CategoryTheory.Equivalence D E\n‚ä¢ Eq (e.trans f).inverse (f.inverse.comp e.inverse)","decl":"/-- Equivalence of categories is transitive. -/\n@[trans, simps]\ndef trans (e : C ‚âå D) (f : D ‚âå E) : C ‚âå E where\n  functor := e.functor ‚ãô f.functor\n  inverse := f.inverse ‚ãô e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight (e.functor.rightUnitor.symm ‚â™‚â´\n    isoWhiskerLeft _ f.unitIso ‚â™‚â´ (Functor.associator _ _ _ ).symm) _ ‚â™‚â´ Functor.associator _ _ _\n  counitIso := (Functor.associator _ _ _ ).symm ‚â™‚â´ isoWhiskerRight ((Functor.associator _ _ _ ) ‚â™‚â´\n      isoWhiskerLeft _ e.counitIso ‚â™‚â´ f.inverse.rightUnitor) _ ‚â™‚â´ f.counitIso\n  -- We wouldn't have needed to give this proof if we'd used `Equivalence.mk`,\n  -- but we choose to avoid using that here, for the sake of good structure projection `simp`\n  -- lemmas.\n  functor_unitIso_comp X := by\n    dsimp\n    simp only [comp_id, id_comp, map_comp, fun_inv_map, comp_obj, id_obj, counitInv,\n      functor_unit_comp_assoc, assoc]\n    slice_lhs 2 3 => rw [‚Üê Functor.map_comp, Iso.inv_hom_id_app]\n    simp\n\n"}
{"name":"CategoryTheory.Equivalence.funInvIdAssoc_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Functor C E\nX : C\n‚ä¢ Eq ((e.funInvIdAssoc F).hom.app X) (F.map (e.unitInv.app X))","decl":"@[simp]\ntheorem funInvIdAssoc_hom_app (e : C ‚âå D) (F : C ‚•§ E) (X : C) :\n    (funInvIdAssoc e F).hom.app X = F.map (e.unitInv.app X) := by\n  dsimp [funInvIdAssoc]\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.funInvIdAssoc_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Functor C E\nX : C\n‚ä¢ Eq ((e.funInvIdAssoc F).inv.app X) (F.map (e.unit.app X))","decl":"@[simp]\ntheorem funInvIdAssoc_inv_app (e : C ‚âå D) (F : C ‚•§ E) (X : C) :\n    (funInvIdAssoc e F).inv.app X = F.map (e.unit.app X) := by\n  dsimp [funInvIdAssoc]\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.invFunIdAssoc_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Functor D E\nX : D\n‚ä¢ Eq ((e.invFunIdAssoc F).hom.app X) (F.map (e.counit.app X))","decl":"@[simp]\ntheorem invFunIdAssoc_hom_app (e : C ‚âå D) (F : D ‚•§ E) (X : D) :\n    (invFunIdAssoc e F).hom.app X = F.map (e.counit.app X) := by\n  dsimp [invFunIdAssoc]\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.invFunIdAssoc_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\nF : CategoryTheory.Functor D E\nX : D\n‚ä¢ Eq ((e.invFunIdAssoc F).inv.app X) (F.map (e.counitInv.app X))","decl":"@[simp]\ntheorem invFunIdAssoc_inv_app (e : C ‚âå D) (F : D ‚•§ E) (X : D) :\n    (invFunIdAssoc e F).inv.app X = F.map (e.counitInv.app X) := by\n  dsimp [invFunIdAssoc]\n  simp\n\n"}
{"name":"CategoryTheory.Equivalence.congrLeft_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrLeft.inverse ((CategoryTheory.whiskeringLeft C D E).obj e.functor)","decl":"/-- If `C` is equivalent to `D`, then `C ‚•§ E` is equivalent to `D ‚•§ E`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrLeft (e : C ‚âå D) : C ‚•§ E ‚âå D ‚•§ E where\n  functor := (whiskeringLeft _ _ _).obj e.inverse\n  inverse := (whiskeringLeft _ _ _).obj e.functor\n  unitIso := (NatIso.ofComponents fun F => (e.funInvIdAssoc F).symm)\n  counitIso := (NatIso.ofComponents fun F => e.invFunIdAssoc F)\n  functor_unitIso_comp F := by\n    ext X\n    dsimp\n    simp only [funInvIdAssoc_inv_app, id_obj, comp_obj, invFunIdAssoc_hom_app,\n      Functor.comp_map, ‚Üê F.map_comp, unit_inverse_comp, map_id]\n\n"}
{"name":"CategoryTheory.Equivalence.congrLeft_counitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrLeft.counitIso (CategoryTheory.NatIso.ofComponents (fun F => e.invFunIdAssoc F) ‚ãØ)","decl":"/-- If `C` is equivalent to `D`, then `C ‚•§ E` is equivalent to `D ‚•§ E`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrLeft (e : C ‚âå D) : C ‚•§ E ‚âå D ‚•§ E where\n  functor := (whiskeringLeft _ _ _).obj e.inverse\n  inverse := (whiskeringLeft _ _ _).obj e.functor\n  unitIso := (NatIso.ofComponents fun F => (e.funInvIdAssoc F).symm)\n  counitIso := (NatIso.ofComponents fun F => e.invFunIdAssoc F)\n  functor_unitIso_comp F := by\n    ext X\n    dsimp\n    simp only [funInvIdAssoc_inv_app, id_obj, comp_obj, invFunIdAssoc_hom_app,\n      Functor.comp_map, ‚Üê F.map_comp, unit_inverse_comp, map_id]\n\n"}
{"name":"CategoryTheory.Equivalence.congrLeft_unitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrLeft.unitIso (CategoryTheory.NatIso.ofComponents (fun F => (e.funInvIdAssoc F).symm) ‚ãØ)","decl":"/-- If `C` is equivalent to `D`, then `C ‚•§ E` is equivalent to `D ‚•§ E`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrLeft (e : C ‚âå D) : C ‚•§ E ‚âå D ‚•§ E where\n  functor := (whiskeringLeft _ _ _).obj e.inverse\n  inverse := (whiskeringLeft _ _ _).obj e.functor\n  unitIso := (NatIso.ofComponents fun F => (e.funInvIdAssoc F).symm)\n  counitIso := (NatIso.ofComponents fun F => e.invFunIdAssoc F)\n  functor_unitIso_comp F := by\n    ext X\n    dsimp\n    simp only [funInvIdAssoc_inv_app, id_obj, comp_obj, invFunIdAssoc_hom_app,\n      Functor.comp_map, ‚Üê F.map_comp, unit_inverse_comp, map_id]\n\n"}
{"name":"CategoryTheory.Equivalence.congrLeft_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrLeft.functor ((CategoryTheory.whiskeringLeft D C E).obj e.inverse)","decl":"/-- If `C` is equivalent to `D`, then `C ‚•§ E` is equivalent to `D ‚•§ E`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrLeft (e : C ‚âå D) : C ‚•§ E ‚âå D ‚•§ E where\n  functor := (whiskeringLeft _ _ _).obj e.inverse\n  inverse := (whiskeringLeft _ _ _).obj e.functor\n  unitIso := (NatIso.ofComponents fun F => (e.funInvIdAssoc F).symm)\n  counitIso := (NatIso.ofComponents fun F => e.invFunIdAssoc F)\n  functor_unitIso_comp F := by\n    ext X\n    dsimp\n    simp only [funInvIdAssoc_inv_app, id_obj, comp_obj, invFunIdAssoc_hom_app,\n      Functor.comp_map, ‚Üê F.map_comp, unit_inverse_comp, map_id]\n\n"}
{"name":"CategoryTheory.Equivalence.congrRight_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrRight.functor ((CategoryTheory.whiskeringRight E C D).obj e.functor)","decl":"/-- If `C` is equivalent to `D`, then `E ‚•§ C` is equivalent to `E ‚•§ D`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrRight (e : C ‚âå D) : E ‚•§ C ‚âå E ‚•§ D where\n  functor := (whiskeringRight _ _ _).obj e.functor\n  inverse := (whiskeringRight _ _ _).obj e.inverse\n  unitIso := NatIso.ofComponents\n      fun F => F.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft F e.unitIso ‚â™‚â´ Functor.associator _ _ _\n  counitIso := NatIso.ofComponents\n      fun F => Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft F e.counitIso ‚â™‚â´ F.rightUnitor\n\n"}
{"name":"CategoryTheory.Equivalence.congrRight_unitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrRight.unitIso (CategoryTheory.NatIso.ofComponents (fun F => F.rightUnitor.symm.trans ((CategoryTheory.isoWhiskerLeft F e.unitIso).trans (F.associator e.functor e.inverse))) ‚ãØ)","decl":"/-- If `C` is equivalent to `D`, then `E ‚•§ C` is equivalent to `E ‚•§ D`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrRight (e : C ‚âå D) : E ‚•§ C ‚âå E ‚•§ D where\n  functor := (whiskeringRight _ _ _).obj e.functor\n  inverse := (whiskeringRight _ _ _).obj e.inverse\n  unitIso := NatIso.ofComponents\n      fun F => F.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft F e.unitIso ‚â™‚â´ Functor.associator _ _ _\n  counitIso := NatIso.ofComponents\n      fun F => Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft F e.counitIso ‚â™‚â´ F.rightUnitor\n\n"}
{"name":"CategoryTheory.Equivalence.congrRight_counitIso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrRight.counitIso (CategoryTheory.NatIso.ofComponents (fun F => (F.associator e.inverse e.functor).trans ((CategoryTheory.isoWhiskerLeft F e.counitIso).trans F.rightUnitor)) ‚ãØ)","decl":"/-- If `C` is equivalent to `D`, then `E ‚•§ C` is equivalent to `E ‚•§ D`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrRight (e : C ‚âå D) : E ‚•§ C ‚âå E ‚•§ D where\n  functor := (whiskeringRight _ _ _).obj e.functor\n  inverse := (whiskeringRight _ _ _).obj e.inverse\n  unitIso := NatIso.ofComponents\n      fun F => F.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft F e.unitIso ‚â™‚â´ Functor.associator _ _ _\n  counitIso := NatIso.ofComponents\n      fun F => Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft F e.counitIso ‚â™‚â´ F.rightUnitor\n\n"}
{"name":"CategoryTheory.Equivalence.congrRight_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq e.congrRight.inverse ((CategoryTheory.whiskeringRight E D C).obj e.inverse)","decl":"/-- If `C` is equivalent to `D`, then `E ‚•§ C` is equivalent to `E ‚•§ D`. -/\n@[simps! functor inverse unitIso counitIso]\ndef congrRight (e : C ‚âå D) : E ‚•§ C ‚âå E ‚•§ D where\n  functor := (whiskeringRight _ _ _).obj e.functor\n  inverse := (whiskeringRight _ _ _).obj e.inverse\n  unitIso := NatIso.ofComponents\n      fun F => F.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft F e.unitIso ‚â™‚â´ Functor.associator _ _ _\n  counitIso := NatIso.ofComponents\n      fun F => Functor.associator _ _ _ ‚â™‚â´ isoWhiskerLeft F e.counitIso ‚â™‚â´ F.rightUnitor\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_unit_right","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : C\nf f' : Quiver.Hom X Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (e.unit.app Y)) (CategoryTheory.CategoryStruct.comp f' (e.unit.app Y))) (Eq f f')","decl":"@[simp]\ntheorem cancel_unit_right {X Y : C} (f f' : X ‚ü∂ Y) :\n    f ‚â´ e.unit.app Y = f' ‚â´ e.unit.app Y ‚Üî f = f' := by simp only [cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_unitInv_right","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : C\nf f' : Quiver.Hom X (e.inverse.obj (e.functor.obj Y))\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (e.unitInv.app Y)) (CategoryTheory.CategoryStruct.comp f' (e.unitInv.app Y))) (Eq f f')","decl":"@[simp]\ntheorem cancel_unitInv_right {X Y : C} (f f' : X ‚ü∂ e.inverse.obj (e.functor.obj Y)) :\n    f ‚â´ e.unitInv.app Y = f' ‚â´ e.unitInv.app Y ‚Üî f = f' := by simp only [cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_counit_right","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : D\nf f' : Quiver.Hom X (e.functor.obj (e.inverse.obj Y))\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (e.counit.app Y)) (CategoryTheory.CategoryStruct.comp f' (e.counit.app Y))) (Eq f f')","decl":"@[simp]\ntheorem cancel_counit_right {X Y : D} (f f' : X ‚ü∂ e.functor.obj (e.inverse.obj Y)) :\n    f ‚â´ e.counit.app Y = f' ‚â´ e.counit.app Y ‚Üî f = f' := by simp only [cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_counitInv_right","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nX Y : D\nf f' : Quiver.Hom X Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (e.counitInv.app Y)) (CategoryTheory.CategoryStruct.comp f' (e.counitInv.app Y))) (Eq f f')","decl":"@[simp]\ntheorem cancel_counitInv_right {X Y : D} (f f' : X ‚ü∂ Y) :\n    f ‚â´ e.counitInv.app Y = f' ‚â´ e.counitInv.app Y ‚Üî f = f' := by simp only [cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_unit_right_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nW X X' Y : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g (e.unit.app Y))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' (e.unit.app Y)))) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g'))","decl":"@[simp]\ntheorem cancel_unit_right_assoc {W X X' Y : C} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (f' : W ‚ü∂ X') (g' : X' ‚ü∂ Y) :\n    f ‚â´ g ‚â´ e.unit.app Y = f' ‚â´ g' ‚â´ e.unit.app Y ‚Üî f ‚â´ g = f' ‚â´ g' := by\n  simp only [‚Üê Category.assoc, cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_counitInv_right_assoc","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nW X X' Y : D\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' Y\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g (e.counitInv.app Y))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' (e.counitInv.app Y)))) (Eq (CategoryTheory.CategoryStruct.comp f g) (CategoryTheory.CategoryStruct.comp f' g'))","decl":"@[simp]\ntheorem cancel_counitInv_right_assoc {W X X' Y : D} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (f' : W ‚ü∂ X')\n    (g' : X' ‚ü∂ Y) : f ‚â´ g ‚â´ e.counitInv.app Y = f' ‚â´ g' ‚â´ e.counitInv.app Y ‚Üî f ‚â´ g = f' ‚â´ g' := by\n  simp only [‚Üê Category.assoc, cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_unit_right_assoc'","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nW X X' Y Y' Z : C\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' Y'\nh' : Quiver.Hom Y' Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp h (e.unit.app Z)))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' (CategoryTheory.CategoryStruct.comp h' (e.unit.app Z))))) (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' h')))","decl":"@[simp]\ntheorem cancel_unit_right_assoc' {W X X' Y Y' Z : C} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z)\n    (f' : W ‚ü∂ X') (g' : X' ‚ü∂ Y') (h' : Y' ‚ü∂ Z) :\n    f ‚â´ g ‚â´ h ‚â´ e.unit.app Z = f' ‚â´ g' ‚â´ h' ‚â´ e.unit.app Z ‚Üî f ‚â´ g ‚â´ h = f' ‚â´ g' ‚â´ h' := by\n  simp only [‚Üê Category.assoc, cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.cancel_counitInv_right_assoc'","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nW X X' Y Y' Z : D\nf : Quiver.Hom W X\ng : Quiver.Hom X Y\nh : Quiver.Hom Y Z\nf' : Quiver.Hom W X'\ng' : Quiver.Hom X' Y'\nh' : Quiver.Hom Y' Z\n‚ä¢ Iff (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g (CategoryTheory.CategoryStruct.comp h (e.counitInv.app Z)))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' (CategoryTheory.CategoryStruct.comp h' (e.counitInv.app Z))))) (Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp g h)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp g' h')))","decl":"@[simp]\ntheorem cancel_counitInv_right_assoc' {W X X' Y Y' Z : D} (f : W ‚ü∂ X) (g : X ‚ü∂ Y) (h : Y ‚ü∂ Z)\n    (f' : W ‚ü∂ X') (g' : X' ‚ü∂ Y') (h' : Y' ‚ü∂ Z) :\n    f ‚â´ g ‚â´ h ‚â´ e.counitInv.app Z = f' ‚â´ g' ‚â´ h' ‚â´ e.counitInv.app Z ‚Üî\n    f ‚â´ g ‚â´ h = f' ‚â´ g' ‚â´ h' := by simp only [‚Üê Category.assoc, cancel_mono]\n\n"}
{"name":"CategoryTheory.Equivalence.pow_zero","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ne : CategoryTheory.Equivalence C C\n‚ä¢ Eq (HPow.hPow e 0) CategoryTheory.Equivalence.refl","decl":"@[simp]\ntheorem pow_zero (e : C ‚âå C) : e ^ (0 : ‚Ñ§) = Equivalence.refl :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.pow_one","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ne : CategoryTheory.Equivalence C C\n‚ä¢ Eq (HPow.hPow e 1) e","decl":"@[simp]\ntheorem pow_one (e : C ‚âå C) : e ^ (1 : ‚Ñ§) = e :=\n  rfl\n\n"}
{"name":"CategoryTheory.Equivalence.pow_neg_one","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\ne : CategoryTheory.Equivalence C C\n‚ä¢ Eq (HPow.hPow e (-1)) e.symm","decl":"@[simp]\ntheorem pow_neg_one (e : C ‚âå C) : e ^ (-1 : ‚Ñ§) = e.symm :=\n  rfl\n\n-- TODO as necessary, add the natural isomorphisms `(e^a).trans e^b ‚âÖ e^(a+b)`.\n-- At this point, we haven't even defined the category of equivalences.\n-- Note: the better formulation of this would involve `HasShift`.\n"}
{"name":"CategoryTheory.Equivalence.essSurj_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C E\n‚ä¢ e.functor.EssSurj","decl":"/-- The functor of an equivalence of categories is essentially surjective. -/\n@[stacks 02C3]\ninstance essSurj_functor (e : C ‚âå E) : e.functor.EssSurj :=\n  ‚ü®fun Y => ‚ü®e.inverse.obj Y, ‚ü®e.counitIso.app Y‚ü©‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.essSurj_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C E\n‚ä¢ e.inverse.EssSurj","decl":"instance essSurj_inverse (e : C ‚âå E) : e.inverse.EssSurj :=\n  e.symm.essSurj_functor\n\n"}
{"name":"CategoryTheory.Equivalence.faithful_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C E\n‚ä¢ e.functor.Faithful","decl":"/-- The functor of an equivalence of categories is faithful. -/\n@[stacks 02C3]\ninstance faithful_functor (e : C ‚âå E) : e.functor.Faithful :=\n  e.fullyFaithfulFunctor.faithful\n\n"}
{"name":"CategoryTheory.Equivalence.faithful_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C E\n‚ä¢ e.inverse.Faithful","decl":"instance faithful_inverse (e : C ‚âå E) : e.inverse.Faithful :=\n  e.fullyFaithfulInverse.faithful\n\n"}
{"name":"CategoryTheory.Equivalence.full_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C E\n‚ä¢ e.functor.Full","decl":"/-- The functor of an equivalence of categories is full. -/\n@[stacks 02C3]\ninstance full_functor (e : C ‚âå E) : e.functor.Full :=\n  e.fullyFaithfulFunctor.full\n\n"}
{"name":"CategoryTheory.Equivalence.full_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\ne : CategoryTheory.Equivalence C E\n‚ä¢ e.inverse.Full","decl":"instance full_inverse (e : C ‚âå E) : e.inverse.Full :=\n  e.fullyFaithfulInverse.full\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_unitIso_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor C D\niso : CategoryTheory.Iso e.functor G\nX : C\n‚ä¢ Eq ((e.changeFunctor iso).unitIso.inv.app X) (CategoryTheory.CategoryStruct.comp (e.inverse.map (iso.inv.app X)) (e.unitIso.inv.app X))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose functor is `G`. -/\n@[simps!]\ndef changeFunctor (e : C ‚âå D) {G : C ‚•§ D} (iso : e.functor ‚âÖ G) : C ‚âå D where\n  functor := G\n  inverse := e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight iso _\n  counitIso := isoWhiskerLeft _ iso.symm ‚â™‚â´ e.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor C D\niso : CategoryTheory.Iso e.functor G\n‚ä¢ Eq (e.changeFunctor iso).inverse e.inverse","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose functor is `G`. -/\n@[simps!]\ndef changeFunctor (e : C ‚âå D) {G : C ‚•§ D} (iso : e.functor ‚âÖ G) : C ‚âå D where\n  functor := G\n  inverse := e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight iso _\n  counitIso := isoWhiskerLeft _ iso.symm ‚â™‚â´ e.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_counitIso_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor C D\niso : CategoryTheory.Iso e.functor G\nX : D\n‚ä¢ Eq ((e.changeFunctor iso).counitIso.inv.app X) (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app X) (iso.hom.app (e.inverse.obj X)))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose functor is `G`. -/\n@[simps!]\ndef changeFunctor (e : C ‚âå D) {G : C ‚•§ D} (iso : e.functor ‚âÖ G) : C ‚âå D where\n  functor := G\n  inverse := e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight iso _\n  counitIso := isoWhiskerLeft _ iso.symm ‚â™‚â´ e.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor C D\niso : CategoryTheory.Iso e.functor G\n‚ä¢ Eq (e.changeFunctor iso).functor G","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose functor is `G`. -/\n@[simps!]\ndef changeFunctor (e : C ‚âå D) {G : C ‚•§ D} (iso : e.functor ‚âÖ G) : C ‚âå D where\n  functor := G\n  inverse := e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight iso _\n  counitIso := isoWhiskerLeft _ iso.symm ‚â™‚â´ e.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_unitIso_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor C D\niso : CategoryTheory.Iso e.functor G\nX : C\n‚ä¢ Eq ((e.changeFunctor iso).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app X) (e.inverse.map (iso.hom.app X)))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose functor is `G`. -/\n@[simps!]\ndef changeFunctor (e : C ‚âå D) {G : C ‚•§ D} (iso : e.functor ‚âÖ G) : C ‚âå D where\n  functor := G\n  inverse := e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight iso _\n  counitIso := isoWhiskerLeft _ iso.symm ‚â™‚â´ e.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_counitIso_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor C D\niso : CategoryTheory.Iso e.functor G\nX : D\n‚ä¢ Eq ((e.changeFunctor iso).counitIso.hom.app X) (CategoryTheory.CategoryStruct.comp (iso.inv.app (e.inverse.obj X)) (e.counitIso.hom.app X))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose functor is `G`. -/\n@[simps!]\ndef changeFunctor (e : C ‚âå D) {G : C ‚•§ D} (iso : e.functor ‚âÖ G) : C ‚âå D where\n  functor := G\n  inverse := e.inverse\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerRight iso _\n  counitIso := isoWhiskerLeft _ iso.symm ‚â™‚â´ e.counitIso\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_refl","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\n‚ä¢ Eq (e.changeFunctor (CategoryTheory.Iso.refl e.functor)) e","decl":"/-- Compatibility of `changeFunctor` with identity isomorphisms of functors -/\ntheorem changeFunctor_refl (e : C ‚âå D) : e.changeFunctor (Iso.refl _) = e := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.changeFunctor_trans","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG G' : CategoryTheory.Functor C D\niso‚ÇÅ : CategoryTheory.Iso e.functor G\niso‚ÇÇ : CategoryTheory.Iso G G'\n‚ä¢ Eq ((e.changeFunctor iso‚ÇÅ).changeFunctor iso‚ÇÇ) (e.changeFunctor (iso‚ÇÅ.trans iso‚ÇÇ))","decl":"/-- Compatibility of `changeFunctor` with the composition of isomorphisms of functors -/\ntheorem changeFunctor_trans (e : C ‚âå D) {G G' : C ‚•§ D} (iso‚ÇÅ : e.functor ‚âÖ G) (iso‚ÇÇ : G ‚âÖ G') :\n    (e.changeFunctor iso‚ÇÅ).changeFunctor iso‚ÇÇ = e.changeFunctor (iso‚ÇÅ ‚â™‚â´ iso‚ÇÇ) := by aesop_cat\n\n"}
{"name":"CategoryTheory.Equivalence.changeInverse_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor D C\niso : CategoryTheory.Iso e.inverse G\n‚ä¢ Eq (e.changeInverse iso).inverse G","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose inverse is `G`. -/\n@[simps!]\ndef changeInverse (e : C ‚âå D) {G : D ‚•§ C} (iso : e.inverse ‚âÖ G) : C ‚âå D where\n  functor := e.functor\n  inverse := G\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerLeft _ iso\n  counitIso := isoWhiskerRight iso.symm _ ‚â™‚â´ e.counitIso\n  functor_unitIso_comp X := by\n    dsimp\n    rw [‚Üê map_comp_assoc, assoc, iso.hom_inv_id_app, comp_id, functor_unit_comp]\n\n"}
{"name":"CategoryTheory.Equivalence.changeInverse_counitIso_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor D C\niso : CategoryTheory.Iso e.inverse G\nX : D\n‚ä¢ Eq ((e.changeInverse iso).counitIso.inv.app X) (CategoryTheory.CategoryStruct.comp (e.counitIso.inv.app X) (e.functor.map (iso.hom.app X)))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose inverse is `G`. -/\n@[simps!]\ndef changeInverse (e : C ‚âå D) {G : D ‚•§ C} (iso : e.inverse ‚âÖ G) : C ‚âå D where\n  functor := e.functor\n  inverse := G\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerLeft _ iso\n  counitIso := isoWhiskerRight iso.symm _ ‚â™‚â´ e.counitIso\n  functor_unitIso_comp X := by\n    dsimp\n    rw [‚Üê map_comp_assoc, assoc, iso.hom_inv_id_app, comp_id, functor_unit_comp]\n\n"}
{"name":"CategoryTheory.Equivalence.changeInverse_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor D C\niso : CategoryTheory.Iso e.inverse G\n‚ä¢ Eq (e.changeInverse iso).functor e.functor","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose inverse is `G`. -/\n@[simps!]\ndef changeInverse (e : C ‚âå D) {G : D ‚•§ C} (iso : e.inverse ‚âÖ G) : C ‚âå D where\n  functor := e.functor\n  inverse := G\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerLeft _ iso\n  counitIso := isoWhiskerRight iso.symm _ ‚â™‚â´ e.counitIso\n  functor_unitIso_comp X := by\n    dsimp\n    rw [‚Üê map_comp_assoc, assoc, iso.hom_inv_id_app, comp_id, functor_unit_comp]\n\n"}
{"name":"CategoryTheory.Equivalence.changeInverse_unitIso_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor D C\niso : CategoryTheory.Iso e.inverse G\nX : C\n‚ä¢ Eq ((e.changeInverse iso).unitIso.inv.app X) (CategoryTheory.CategoryStruct.comp (iso.inv.app (e.functor.obj X)) (e.unitIso.inv.app X))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose inverse is `G`. -/\n@[simps!]\ndef changeInverse (e : C ‚âå D) {G : D ‚•§ C} (iso : e.inverse ‚âÖ G) : C ‚âå D where\n  functor := e.functor\n  inverse := G\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerLeft _ iso\n  counitIso := isoWhiskerRight iso.symm _ ‚â™‚â´ e.counitIso\n  functor_unitIso_comp X := by\n    dsimp\n    rw [‚Üê map_comp_assoc, assoc, iso.hom_inv_id_app, comp_id, functor_unit_comp]\n\n"}
{"name":"CategoryTheory.Equivalence.changeInverse_counitIso_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor D C\niso : CategoryTheory.Iso e.inverse G\nX : D\n‚ä¢ Eq ((e.changeInverse iso).counitIso.hom.app X) (CategoryTheory.CategoryStruct.comp (e.functor.map (iso.inv.app X)) (e.counitIso.hom.app X))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose inverse is `G`. -/\n@[simps!]\ndef changeInverse (e : C ‚âå D) {G : D ‚•§ C} (iso : e.inverse ‚âÖ G) : C ‚âå D where\n  functor := e.functor\n  inverse := G\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerLeft _ iso\n  counitIso := isoWhiskerRight iso.symm _ ‚â™‚â´ e.counitIso\n  functor_unitIso_comp X := by\n    dsimp\n    rw [‚Üê map_comp_assoc, assoc, iso.hom_inv_id_app, comp_id, functor_unit_comp]\n\n"}
{"name":"CategoryTheory.Equivalence.changeInverse_unitIso_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\ne : CategoryTheory.Equivalence C D\nG : CategoryTheory.Functor D C\niso : CategoryTheory.Iso e.inverse G\nX : C\n‚ä¢ Eq ((e.changeInverse iso).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp (e.unitIso.hom.app X) (iso.hom.app (e.functor.obj X)))","decl":"/-- If `e : C ‚âå D` is an equivalence of categories, and `iso : e.functor ‚âÖ G` is\nan isomorphism, then there is an equivalence of categories whose inverse is `G`. -/\n@[simps!]\ndef changeInverse (e : C ‚âå D) {G : D ‚•§ C} (iso : e.inverse ‚âÖ G) : C ‚âå D where\n  functor := e.functor\n  inverse := G\n  unitIso := e.unitIso ‚â™‚â´ isoWhiskerLeft _ iso\n  counitIso := isoWhiskerRight iso.symm _ ‚â™‚â´ e.counitIso\n  functor_unitIso_comp X := by\n    dsimp\n    rw [‚Üê map_comp_assoc, assoc, iso.hom_inv_id_app, comp_id, functor_unit_comp]\n\n"}
{"name":"CategoryTheory.Functor.IsEquivalence.faithful","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.IsEquivalence\n‚ä¢ F.Faithful","decl":"/-- A functor is an equivalence of categories if it is faithful, full and\nessentially surjective. -/\nclass Functor.IsEquivalence (F : C ‚•§ D) : Prop where\n  faithful : F.Faithful := by infer_instance\n  full : F.Full := by infer_instance\n  essSurj : F.EssSurj := by infer_instance\n\n"}
{"name":"CategoryTheory.Functor.IsEquivalence.full","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.IsEquivalence\n‚ä¢ F.Full","decl":"/-- A functor is an equivalence of categories if it is faithful, full and\nessentially surjective. -/\nclass Functor.IsEquivalence (F : C ‚•§ D) : Prop where\n  faithful : F.Faithful := by infer_instance\n  full : F.Full := by infer_instance\n  essSurj : F.EssSurj := by infer_instance\n\n"}
{"name":"CategoryTheory.Functor.IsEquivalence.essSurj","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nself : F.IsEquivalence\n‚ä¢ F.EssSurj","decl":"/-- A functor is an equivalence of categories if it is faithful, full and\nessentially surjective. -/\nclass Functor.IsEquivalence (F : C ‚•§ D) : Prop where\n  faithful : F.Faithful := by infer_instance\n  full : F.Full := by infer_instance\n  essSurj : F.EssSurj := by infer_instance\n\n"}
{"name":"CategoryTheory.Equivalence.isEquivalence_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Equivalence C D\n‚ä¢ F.functor.IsEquivalence","decl":"instance Equivalence.isEquivalence_functor (F : C ‚âå D) : IsEquivalence F.functor where\n\n"}
{"name":"CategoryTheory.Equivalence.isEquivalence_inverse","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Equivalence C D\n‚ä¢ F.inverse.IsEquivalence","decl":"instance Equivalence.isEquivalence_inverse (F : C ‚âå D) : IsEquivalence F.inverse :=\n  F.symm.isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Functor.IsEquivalence.mk'","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D C\nŒ∑ : CategoryTheory.Iso (CategoryTheory.Functor.id C) (F.comp G)\nŒµ : CategoryTheory.Iso (G.comp F) (CategoryTheory.Functor.id D)\n‚ä¢ F.IsEquivalence","decl":"/-- To see that a functor is an equivalence, it suffices to provide an inverse functor `G` such that\n    `F ‚ãô G` and `G ‚ãô F` are naturally isomorphic to identity functors. -/\nprotected lemma mk' {F : C ‚•§ D} (G : D ‚•§ C) (Œ∑ : ùü≠ C ‚âÖ F ‚ãô G) (Œµ : G ‚ãô F ‚âÖ ùü≠ D) :\n    IsEquivalence F :=\n  inferInstanceAs (IsEquivalence (Equivalence.mk F G Œ∑ Œµ).functor)\n\n"}
{"name":"CategoryTheory.Functor.asEquivalence_functor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ Eq F.asEquivalence.functor F","decl":"/-- Interpret a functor that is an equivalence as an equivalence. -/\n@[simps functor, stacks 02C3]\nnoncomputable def asEquivalence (F : C ‚•§ D) [F.IsEquivalence] : C ‚âå D where\n  functor := F\n  inverse := F.inv\n  unitIso := NatIso.ofComponents\n    (fun X => (F.preimageIso <| F.objObjPreimageIso <| F.obj X).symm)\n      (fun f => F.map_injective (by simp [inv]))\n  counitIso := NatIso.ofComponents F.objObjPreimageIso (by simp [inv])\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_refl","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\n‚ä¢ (CategoryTheory.Functor.id C).IsEquivalence","decl":"instance isEquivalence_refl : IsEquivalence (ùü≠ C) :=\n  Equivalence.refl.isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_inv","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ F.inv.IsEquivalence","decl":"instance isEquivalence_inv (F : C ‚•§ D) [IsEquivalence F] : IsEquivalence F.inv :=\n  F.asEquivalence.symm.isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_trans","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.IsEquivalence\ninst‚úù : G.IsEquivalence\n‚ä¢ (F.comp G).IsEquivalence","decl":"instance isEquivalence_trans (F : C ‚•§ D) (G : D ‚•§ E) [IsEquivalence F] [IsEquivalence G] :\n    IsEquivalence (F ‚ãô G) where\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceObjWhiskeringLeft","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ ((CategoryTheory.whiskeringLeft C D E).obj F).IsEquivalence","decl":"instance (F : C ‚•§ D) [IsEquivalence F] : IsEquivalence ((whiskeringLeft C D E).obj F) :=\n  (inferInstance : IsEquivalence (Equivalence.congrLeft F.asEquivalence).inverse)\n\n"}
{"name":"CategoryTheory.Functor.instIsEquivalenceObjWhiskeringRight","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\n‚ä¢ ((CategoryTheory.whiskeringRight E C D).obj F).IsEquivalence","decl":"instance (F : C ‚•§ D) [IsEquivalence F] : IsEquivalence ((whiskeringRight E C D).obj F) :=\n  (inferInstance : IsEquivalence (Equivalence.congrRight F.asEquivalence).functor)\n\n"}
{"name":"CategoryTheory.Functor.fun_inv_map","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\nX Y : D\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.map (F.inv.map f)) (CategoryTheory.CategoryStruct.comp (F.asEquivalence.counit.app X) (CategoryTheory.CategoryStruct.comp f (F.asEquivalence.counitInv.app Y)))","decl":"@[simp]\ntheorem fun_inv_map (F : C ‚•§ D) [IsEquivalence F] (X Y : D) (f : X ‚ü∂ Y) :\n    F.map (F.inv.map f) = F.asEquivalence.counit.app X ‚â´ f ‚â´ F.asEquivalence.counitInv.app Y := by\n  erw [NatIso.naturality_2]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.inv_fun_map","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù : F.IsEquivalence\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (F.inv.map (F.map f)) (CategoryTheory.CategoryStruct.comp (F.asEquivalence.unitInv.app X) (CategoryTheory.CategoryStruct.comp f (F.asEquivalence.unit.app Y)))","decl":"@[simp]\ntheorem inv_fun_map (F : C ‚•§ D) [IsEquivalence F] (X Y : C) (f : X ‚ü∂ Y) :\n    F.inv.map (F.map f) = F.asEquivalence.unitInv.app X ‚â´ f ‚â´ F.asEquivalence.unit.app Y := by\n  erw [NatIso.naturality_1]\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_of_iso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\ninst‚úù : F.IsEquivalence\n‚ä¢ G.IsEquivalence","decl":"lemma isEquivalence_of_iso {F G : C ‚•§ D} (e : F ‚âÖ G) [F.IsEquivalence] : G.IsEquivalence :=\n  ((asEquivalence F).changeFunctor e).isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_iff_of_iso","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF G : CategoryTheory.Functor C D\ne : CategoryTheory.Iso F G\n‚ä¢ Iff F.IsEquivalence G.IsEquivalence","decl":"lemma isEquivalence_iff_of_iso {F G : C ‚•§ D} (e : F ‚âÖ G) :\n    F.IsEquivalence ‚Üî G.IsEquivalence :=\n  ‚ü®fun _ => isEquivalence_of_iso e, fun _ => isEquivalence_of_iso e.symm‚ü©\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_of_comp_right","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : G.IsEquivalence\ninst‚úù : (F.comp G).IsEquivalence\n‚ä¢ F.IsEquivalence","decl":"/-- If `G` and `F ‚ãô G` are equivalence of categories, then `F` is also an equivalence. -/\nlemma isEquivalence_of_comp_right {E : Type*} [Category E] (F : C ‚•§ D) (G : D ‚•§ E)\n    [IsEquivalence G] [IsEquivalence (F ‚ãô G)] : IsEquivalence F := by\n  rw [isEquivalence_iff_of_iso (F.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft F (G.asEquivalence.unitIso))]\n  exact ((F ‚ãô G).asEquivalence.trans G.asEquivalence.symm).isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Functor.isEquivalence_of_comp_left","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù‚Å¥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u_1\ninst‚úù¬≤ : CategoryTheory.Category.{u_2, u_1} E\nF : CategoryTheory.Functor C D\nG : CategoryTheory.Functor D E\ninst‚úù¬π : F.IsEquivalence\ninst‚úù : (F.comp G).IsEquivalence\n‚ä¢ G.IsEquivalence","decl":"/-- If `F` and `F ‚ãô G` are equivalence of categories, then `G` is also an equivalence. -/\nlemma isEquivalence_of_comp_left {E : Type*} [Category E] (F : C ‚•§ D) (G : D ‚•§ E)\n    [IsEquivalence F] [IsEquivalence (F ‚ãô G)] : IsEquivalence G := by\n  rw [isEquivalence_iff_of_iso (G.leftUnitor.symm ‚â™‚â´\n    isoWhiskerRight F.asEquivalence.counitIso.symm G)]\n  exact (F.asEquivalence.symm.trans (F ‚ãô G).asEquivalence).isEquivalence_functor\n\n"}
{"name":"CategoryTheory.Equivalence.essSurjInducedFunctor","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u_1\ne : Equiv C' D\n‚ä¢ (CategoryTheory.inducedFunctor ‚áëe).EssSurj","decl":"instance essSurjInducedFunctor {C' : Type*} (e : C' ‚âÉ D) : (inducedFunctor e).EssSurj where\n  mem_essImage Y := ‚ü®e.symm Y, by simpa using ‚ü®default‚ü©‚ü©\n\n"}
{"name":"CategoryTheory.Equivalence.inducedFunctorOfEquiv","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"D : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nC' : Type u_1\ne : Equiv C' D\n‚ä¢ (CategoryTheory.inducedFunctor ‚áëe).IsEquivalence","decl":"noncomputable instance inducedFunctorOfEquiv {C' : Type*} (e : C' ‚âÉ D) :\n    IsEquivalence (inducedFunctor e) where\n\n"}
{"name":"CategoryTheory.Equivalence.fullyFaithfulToEssImage","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\n‚ä¢ F.toEssImage.IsEquivalence","decl":"noncomputable instance fullyFaithfulToEssImage (F : C ‚•§ D) [F.Full] [F.Faithful] :\n    IsEquivalence F.toEssImage where\n\n"}
{"name":"CategoryTheory.Iso.compInverseIso_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nG : CategoryTheory.Functor C D\nH : CategoryTheory.Equivalence D E\ni : CategoryTheory.Iso F (G.comp H.functor)\nX : C\n‚ä¢ Eq (i.compInverseIso.hom.app X) (CategoryTheory.CategoryStruct.comp (H.inverse.map (i.hom.app X)) (H.unitIso.inv.app (G.obj X)))","decl":"/-- Construct an isomorphism `F ‚ãô H.inverse ‚âÖ G` from an isomorphism `F ‚âÖ G ‚ãô H.functor`. -/\n@[simps!]\ndef compInverseIso {H : D ‚âå E} (i : F ‚âÖ G ‚ãô H.functor) : F ‚ãô H.inverse ‚âÖ G :=\n  isoWhiskerRight i H.inverse ‚â™‚â´\n    associator G _ H.inverse ‚â™‚â´ isoWhiskerLeft G H.unitIso.symm ‚â™‚â´ G.rightUnitor\n\n"}
{"name":"CategoryTheory.Iso.compInverseIso_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nG : CategoryTheory.Functor C D\nH : CategoryTheory.Equivalence D E\ni : CategoryTheory.Iso F (G.comp H.functor)\nX : C\n‚ä¢ Eq (i.compInverseIso.inv.app X) (CategoryTheory.CategoryStruct.comp (H.unitIso.hom.app (G.obj X)) (H.inverse.map (i.inv.app X)))","decl":"/-- Construct an isomorphism `F ‚ãô H.inverse ‚âÖ G` from an isomorphism `F ‚âÖ G ‚ãô H.functor`. -/\n@[simps!]\ndef compInverseIso {H : D ‚âå E} (i : F ‚âÖ G ‚ãô H.functor) : F ‚ãô H.inverse ‚âÖ G :=\n  isoWhiskerRight i H.inverse ‚â™‚â´\n    associator G _ H.inverse ‚â™‚â´ isoWhiskerLeft G H.unitIso.symm ‚â™‚â´ G.rightUnitor\n\n"}
{"name":"CategoryTheory.Iso.isoCompInverse_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nG : CategoryTheory.Functor C D\nH : CategoryTheory.Equivalence D E\ni : CategoryTheory.Iso (G.comp H.functor) F\nX : C\n‚ä¢ Eq (i.isoCompInverse.inv.app X) (CategoryTheory.CategoryStruct.comp (H.inverse.map (i.inv.app X)) (H.unitIso.inv.app (G.obj X)))","decl":"/-- Construct an isomorphism `G ‚âÖ F ‚ãô H.inverse` from an isomorphism `G ‚ãô H.functor ‚âÖ F`. -/\n@[simps!]\ndef isoCompInverse {H : D ‚âå E} (i : G ‚ãô H.functor ‚âÖ F) : G ‚âÖ F ‚ãô H.inverse :=\n  G.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft G H.unitIso ‚â™‚â´ (associator _ _ _).symm ‚â™‚â´\n    isoWhiskerRight i H.inverse\n\n"}
{"name":"CategoryTheory.Iso.isoCompInverse_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nG : CategoryTheory.Functor C D\nH : CategoryTheory.Equivalence D E\ni : CategoryTheory.Iso (G.comp H.functor) F\nX : C\n‚ä¢ Eq (i.isoCompInverse.hom.app X) (CategoryTheory.CategoryStruct.comp (H.unitIso.hom.app (G.obj X)) (H.inverse.map (i.hom.app X)))","decl":"/-- Construct an isomorphism `G ‚âÖ F ‚ãô H.inverse` from an isomorphism `G ‚ãô H.functor ‚âÖ F`. -/\n@[simps!]\ndef isoCompInverse {H : D ‚âå E} (i : G ‚ãô H.functor ‚âÖ F) : G ‚âÖ F ‚ãô H.inverse :=\n  G.rightUnitor.symm ‚â™‚â´ isoWhiskerLeft G H.unitIso ‚â™‚â´ (associator _ _ _).symm ‚â™‚â´\n    isoWhiskerRight i H.inverse\n\n"}
{"name":"CategoryTheory.Iso.inverseCompIso_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D E\nG : CategoryTheory.Equivalence C D\ni : CategoryTheory.Iso F (G.functor.comp H)\nX : D\n‚ä¢ Eq (i.inverseCompIso.hom.app X) (CategoryTheory.CategoryStruct.comp (i.hom.app (G.inverse.obj X)) (H.map (G.counitIso.hom.app X)))","decl":"/-- Construct an isomorphism `G.inverse ‚ãô F ‚âÖ H` from an isomorphism `F ‚âÖ G.functor ‚ãô H`. -/\n@[simps!]\ndef inverseCompIso {G : C ‚âå D} (i : F ‚âÖ G.functor ‚ãô H) : G.inverse ‚ãô F ‚âÖ H :=\n  isoWhiskerLeft G.inverse i ‚â™‚â´ (associator _ _ _).symm ‚â™‚â´\n    isoWhiskerRight G.counitIso H ‚â™‚â´ H.leftUnitor\n\n"}
{"name":"CategoryTheory.Iso.inverseCompIso_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D E\nG : CategoryTheory.Equivalence C D\ni : CategoryTheory.Iso F (G.functor.comp H)\nX : D\n‚ä¢ Eq (i.inverseCompIso.inv.app X) (CategoryTheory.CategoryStruct.comp (H.map (G.counitIso.inv.app X)) (i.inv.app (G.inverse.obj X)))","decl":"/-- Construct an isomorphism `G.inverse ‚ãô F ‚âÖ H` from an isomorphism `F ‚âÖ G.functor ‚ãô H`. -/\n@[simps!]\ndef inverseCompIso {G : C ‚âå D} (i : F ‚âÖ G.functor ‚ãô H) : G.inverse ‚ãô F ‚âÖ H :=\n  isoWhiskerLeft G.inverse i ‚â™‚â´ (associator _ _ _).symm ‚â™‚â´\n    isoWhiskerRight G.counitIso H ‚â™‚â´ H.leftUnitor\n\n"}
{"name":"CategoryTheory.Iso.isoInverseComp_hom_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D E\nG : CategoryTheory.Equivalence C D\ni : CategoryTheory.Iso (G.functor.comp H) F\nX : D\n‚ä¢ Eq (i.isoInverseComp.hom.app X) (CategoryTheory.CategoryStruct.comp (H.map (G.counitIso.inv.app X)) (i.hom.app (G.inverse.obj X)))","decl":"/-- Construct an isomorphism `H ‚âÖ G.inverse ‚ãô F` from an isomorphism `G.functor ‚ãô H ‚âÖ F`. -/\n@[simps!]\ndef isoInverseComp {G : C ‚âå D} (i : G.functor ‚ãô H ‚âÖ F) : H ‚âÖ G.inverse ‚ãô F :=\n  H.leftUnitor.symm ‚â™‚â´ isoWhiskerRight G.counitIso.symm H ‚â™‚â´ associator _ _ _\n    ‚â™‚â´ isoWhiskerLeft G.inverse i\n\n"}
{"name":"CategoryTheory.Iso.isoInverseComp_inv_app","module":"Mathlib.CategoryTheory.Equivalence","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nE : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} E\nF : CategoryTheory.Functor C E\nH : CategoryTheory.Functor D E\nG : CategoryTheory.Equivalence C D\ni : CategoryTheory.Iso (G.functor.comp H) F\nX : D\n‚ä¢ Eq (i.isoInverseComp.inv.app X) (CategoryTheory.CategoryStruct.comp (i.inv.app (G.inverse.obj X)) (H.map (G.counitIso.hom.app X)))","decl":"/-- Construct an isomorphism `H ‚âÖ G.inverse ‚ãô F` from an isomorphism `G.functor ‚ãô H ‚âÖ F`. -/\n@[simps!]\ndef isoInverseComp {G : C ‚âå D} (i : G.functor ‚ãô H ‚âÖ F) : H ‚âÖ G.inverse ‚ãô F :=\n  H.leftUnitor.symm ‚â™‚â´ isoWhiskerRight G.counitIso.symm H ‚â™‚â´ associator _ _ _\n    ‚â™‚â´ isoWhiskerLeft G.inverse i\n\n"}
