{"name":"Finset.prod_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\nf : ι → R\ns : Finset ι\nh0 : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ LE.le 0 (s.prod fun i => f i)","decl":"lemma prod_nonneg (h0 : ∀ i ∈ s, 0 ≤ f i) : 0 ≤ ∏ i ∈ s, f i :=\n  prod_induction f (fun i ↦ 0 ≤ i) (fun _ _ ha hb ↦ mul_nonneg ha hb) zero_le_one h0\n\n"}
{"name":"Finset.prod_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\nf g : ι → R\ns : Finset ι\nh0 : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nh1 : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\n⊢ LE.le (s.prod fun i => f i) (s.prod fun i => g i)","decl":"/-- If all `f i`, `i ∈ s`, are nonnegative and each `f i` is less than or equal to `g i`, then the\nproduct of `f i` is less than or equal to the product of `g i`. See also `Finset.prod_le_prod'` for\nthe case of an ordered commutative multiplicative monoid. -/\n@[gcongr]\nlemma prod_le_prod (h0 : ∀ i ∈ s, 0 ≤ f i) (h1 : ∀ i ∈ s, f i ≤ g i) :\n    ∏ i ∈ s, f i ≤ ∏ i ∈ s, g i := by\n  induction s using Finset.cons_induction with\n  | empty => simp\n  | cons a s has ih =>\n    simp only [prod_cons, forall_mem_cons] at h0 h1 ⊢\n    have := posMulMono_iff_mulPosMono.1 ‹PosMulMono R›\n    gcongr\n    exacts [prod_nonneg h0.2, h0.1.trans h1.1, h1.1, ih h0.2 h1.2]\n\n"}
{"name":"Finset.prod_le_one","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝³ : CommMonoidWithZero R\ninst✝² : PartialOrder R\ninst✝¹ : ZeroLEOneClass R\ninst✝ : PosMulMono R\nf : ι → R\ns : Finset ι\nh0 : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nh1 : ∀ (i : ι), Membership.mem s i → LE.le (f i) 1\n⊢ LE.le (s.prod fun i => f i) 1","decl":"/-- If each `f i`, `i ∈ s` belongs to `[0, 1]`, then their product is less than or equal to one.\nSee also `Finset.prod_le_one'` for the case of an ordered commutative multiplicative monoid. -/\nlemma prod_le_one (h0 : ∀ i ∈ s, 0 ≤ f i) (h1 : ∀ i ∈ s, f i ≤ 1) : ∏ i ∈ s, f i ≤ 1 := by\n  convert ← prod_le_prod h0 h1\n  exact Finset.prod_const_one\n\n"}
{"name":"Finset.prod_pos","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : Nontrivial R\nf : ι → R\ns : Finset ι\nh0 : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\n⊢ LT.lt 0 (s.prod fun i => f i)","decl":"lemma prod_pos (h0 : ∀ i ∈ s, 0 < f i) : 0 < ∏ i ∈ s, f i :=\n  prod_induction f (fun x ↦ 0 < x) (fun _ _ ha hb ↦ mul_pos ha hb) zero_lt_one h0\n\n"}
{"name":"Finset.prod_lt_prod","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : Nontrivial R\nf g : ι → R\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\nhfg : ∀ (i : ι), Membership.mem s i → LE.le (f i) (g i)\nhlt : Exists fun i => And (Membership.mem s i) (LT.lt (f i) (g i))\n⊢ LT.lt (s.prod fun i => f i) (s.prod fun i => g i)","decl":"lemma prod_lt_prod (hf : ∀ i ∈ s, 0 < f i) (hfg : ∀ i ∈ s, f i ≤ g i)\n    (hlt : ∃ i ∈ s, f i < g i) :\n    ∏ i ∈ s, f i < ∏ i ∈ s, g i := by\n  classical\n  obtain ⟨i, hi, hilt⟩ := hlt\n  rw [← insert_erase hi, prod_insert (not_mem_erase _ _), prod_insert (not_mem_erase _ _)]\n  have := posMulStrictMono_iff_mulPosStrictMono.1 ‹PosMulStrictMono R›\n  refine mul_lt_mul_of_pos_of_nonneg' hilt ?_ ?_ ?_\n  · exact prod_le_prod (fun j hj => le_of_lt (hf j (mem_of_mem_erase hj)))\n      (fun _ hj ↦ hfg _ <| mem_of_mem_erase hj)\n  · exact prod_pos fun j hj => hf j (mem_of_mem_erase hj)\n  · exact (hf i hi).le.trans hilt.le\n\n"}
{"name":"Finset.prod_lt_prod_of_nonempty","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommMonoidWithZero R\ninst✝³ : PartialOrder R\ninst✝² : ZeroLEOneClass R\ninst✝¹ : PosMulStrictMono R\ninst✝ : Nontrivial R\nf g : ι → R\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → LT.lt 0 (f i)\nhfg : ∀ (i : ι), Membership.mem s i → LT.lt (f i) (g i)\nh_ne : s.Nonempty\n⊢ LT.lt (s.prod fun i => f i) (s.prod fun i => g i)","decl":"lemma prod_lt_prod_of_nonempty (hf : ∀ i ∈ s, 0 < f i) (hfg : ∀ i ∈ s, f i < g i)\n    (h_ne : s.Nonempty) :\n    ∏ i ∈ s, f i < ∏ i ∈ s, g i := by\n  apply prod_lt_prod hf fun i hi => le_of_lt (hfg i hi)\n  obtain ⟨i, hi⟩ := h_ne\n  exact ⟨i, hi, hfg i hi⟩\n\n"}
{"name":"Finset.sum_sq_le_sq_sum_of_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝ : OrderedSemiring R\nf : ι → R\ns : Finset ι\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\n⊢ LE.le (s.sum fun i => HPow.hPow (f i) 2) (HPow.hPow (s.sum fun i => f i) 2)","decl":"lemma sum_sq_le_sq_sum_of_nonneg (hf : ∀ i ∈ s, 0 ≤ f i) :\n    ∑ i ∈ s, f i ^ 2 ≤ (∑ i ∈ s, f i) ^ 2 := by\n  simp only [sq, sum_mul_sum]\n  refine sum_le_sum fun i hi ↦ ?_\n  rw [← mul_sum]\n  gcongr\n  · exact hf i hi\n  · exact single_le_sum hf hi\n\n"}
{"name":"Finset.prod_add_prod_le","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝ : OrderedCommSemiring R\ns : Finset ι\ni : ι\nf g h : ι → R\nhi : Membership.mem s i\nh2i : LE.le (HAdd.hAdd (g i) (h i)) (f i)\nhgf : ∀ (j : ι), Membership.mem s j → Ne j i → LE.le (g j) (f j)\nhhf : ∀ (j : ι), Membership.mem s j → Ne j i → LE.le (h j) (f j)\nhg : ∀ (i : ι), Membership.mem s i → LE.le 0 (g i)\nhh : ∀ (i : ι), Membership.mem s i → LE.le 0 (h i)\n⊢ LE.le (HAdd.hAdd (s.prod fun i => g i) (s.prod fun i => h i)) (s.prod fun i => f i)","decl":"/-- If `g, h ≤ f` and `g i + h i ≤ f i`, then the product of `f` over `s` is at least the\n  sum of the products of `g` and `h`. This is the version for `OrderedCommSemiring`. -/\nlemma prod_add_prod_le {i : ι} {f g h : ι → R} (hi : i ∈ s) (h2i : g i + h i ≤ f i)\n    (hgf : ∀ j ∈ s, j ≠ i → g j ≤ f j) (hhf : ∀ j ∈ s, j ≠ i → h j ≤ f j) (hg : ∀ i ∈ s, 0 ≤ g i)\n    (hh : ∀ i ∈ s, 0 ≤ h i) : ((∏ i ∈ s, g i) + ∏ i ∈ s, h i) ≤ ∏ i ∈ s, f i := by\n  classical\n  simp_rw [prod_eq_mul_prod_diff_singleton hi]\n  refine le_trans ?_ (mul_le_mul_of_nonneg_right h2i ?_)\n  · rw [right_distrib]\n    gcongr with j hj <;> aesop\n  · apply prod_nonneg\n    simp only [and_imp, mem_sdiff, mem_singleton]\n    exact fun j hj hji ↦ le_trans (hg j hj) (hgf j hj hji)\n\n"}
{"name":"Finset.sum_mul_self_eq_zero_iff","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : LinearOrderedSemiring R\ninst✝ : ExistsAddOfLE R\ns : Finset ι\nf : ι → R\n⊢ Iff (Eq (s.sum fun i => HMul.hMul (f i) (f i)) 0) (∀ (i : ι), Membership.mem s i → Eq (f i) 0)","decl":"theorem sum_mul_self_eq_zero_iff [LinearOrderedSemiring R] [ExistsAddOfLE R] (s : Finset ι)\n    (f : ι → R) : ∑ i ∈ s, f i * f i = 0 ↔ ∀ i ∈ s, f i = 0 := by\n  rw [sum_eq_zero_iff_of_nonneg fun _ _ ↦ mul_self_nonneg _]\n  simp\n\n"}
{"name":"Finset.abs_prod","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝ : LinearOrderedCommRing R\ns : Finset ι\nf : ι → R\n⊢ Eq (abs (s.prod fun x => f x)) (s.prod fun x => abs (f x))","decl":"lemma abs_prod [LinearOrderedCommRing R] (s : Finset ι) (f : ι → R) :\n    |∏ x ∈ s, f x| = ∏ x ∈ s, |f x| :=\n  map_prod absHom _ _\n\n"}
{"name":"Finset.PNat.coe_prod","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_4\nf : ι → PNat\ns : Finset ι\n⊢ Eq (↑(s.prod fun i => f i)) (s.prod fun i => ↑(f i))","decl":"@[simp, norm_cast]\ntheorem PNat.coe_prod {ι : Type*} (f : ι → ℕ+) (s : Finset ι) :\n    ↑(∏ i ∈ s, f i) = (∏ i ∈ s, f i : ℕ) :=\n  map_prod PNat.coeMonoidHom _ _\n\n"}
{"name":"CanonicallyOrderedAdd.prod_pos","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : PartialOrder R\ninst✝² : CanonicallyOrderedAdd R\nf : ι → R\ns : Finset ι\ninst✝¹ : NoZeroDivisors R\ninst✝ : Nontrivial R\n⊢ Iff (LT.lt 0 (s.prod fun i => f i)) (∀ (i : ι), Membership.mem s i → LT.lt 0 (f i))","decl":"/-- Note that the name is to match `CanonicallyOrderedAdd.mul_pos`. -/\n@[simp] lemma _root_.CanonicallyOrderedAdd.prod_pos [NoZeroDivisors R] [Nontrivial R] :\n    0 < ∏ i ∈ s, f i ↔ (∀ i ∈ s, (0 : R) < f i) :=\n  CanonicallyOrderedAdd.multiset_prod_pos.trans Multiset.forall_mem_map_iff\n\n"}
{"name":"Finset.prod_add_prod_le'","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : PartialOrder R\ninst✝ : CanonicallyOrderedAdd R\nf g h : ι → R\ns : Finset ι\ni : ι\nhi : Membership.mem s i\nh2i : LE.le (HAdd.hAdd (g i) (h i)) (f i)\nhgf : ∀ (j : ι), Membership.mem s j → Ne j i → LE.le (g j) (f j)\nhhf : ∀ (j : ι), Membership.mem s j → Ne j i → LE.le (h j) (f j)\n⊢ LE.le (HAdd.hAdd (s.prod fun i => g i) (s.prod fun i => h i)) (s.prod fun i => f i)","decl":"attribute [local instance] CanonicallyOrderedAdd.toOrderedCommMonoid in\n/-- If `g, h ≤ f` and `g i + h i ≤ f i`, then the product of `f` over `s` is at least the\n  sum of the products of `g` and `h`. This is the version for `CanonicallyOrderedAdd`.\n-/\nlemma prod_add_prod_le' (hi : i ∈ s) (h2i : g i + h i ≤ f i) (hgf : ∀ j ∈ s, j ≠ i → g j ≤ f j)\n    (hhf : ∀ j ∈ s, j ≠ i → h j ≤ f j) : ((∏ i ∈ s, g i) + ∏ i ∈ s, h i) ≤ ∏ i ∈ s, f i := by\n  classical\n  simp_rw [prod_eq_mul_prod_diff_singleton hi]\n  refine le_trans ?_ (mul_le_mul_right' h2i _)\n  rw [right_distrib]\n  gcongr with j hj j hj <;> simp_all\n\n"}
{"name":"Finset.sum_sq_le_sum_mul_sum_of_sq_eq_mul","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : LinearOrderedCommSemiring R\ninst✝ : ExistsAddOfLE R\ns : Finset ι\nr f g : ι → R\nhf : ∀ (i : ι), Membership.mem s i → LE.le 0 (f i)\nhg : ∀ (i : ι), Membership.mem s i → LE.le 0 (g i)\nht : ∀ (i : ι), Membership.mem s i → Eq (HPow.hPow (r i) 2) (HMul.hMul (f i) (g i))\n⊢ LE.le (HPow.hPow (s.sum fun i => r i) 2) (HMul.hMul (s.sum fun i => f i) (s.sum fun i => g i))","decl":"/-- **Cauchy-Schwarz inequality** for finsets.\n\nThis is written in terms of sequences `f`, `g`, and `r`, where `r` is a stand-in for\n`√(f i * g i)`. See `sum_mul_sq_le_sq_mul_sq` for the more usual form in terms of squared\nsequences. -/\nlemma sum_sq_le_sum_mul_sum_of_sq_eq_mul [LinearOrderedCommSemiring R] [ExistsAddOfLE R]\n    (s : Finset ι) {r f g : ι → R} (hf : ∀ i ∈ s, 0 ≤ f i) (hg : ∀ i ∈ s, 0 ≤ g i)\n    (ht : ∀ i ∈ s, r i ^ 2 = f i * g i) : (∑ i ∈ s, r i) ^ 2 ≤ (∑ i ∈ s, f i) * ∑ i ∈ s, g i := by\n  obtain h | h := (sum_nonneg hg).eq_or_gt\n  · have ht' : ∑ i ∈ s, r i = 0 := sum_eq_zero fun i hi ↦ by\n      simpa [(sum_eq_zero_iff_of_nonneg hg).1 h i hi] using ht i hi\n    rw [h, ht']\n    simp\n  · refine le_of_mul_le_mul_of_pos_left\n      (le_of_add_le_add_left (a := (∑ i ∈ s, g i) * (∑ i ∈ s, r i) ^ 2) ?_) h\n    calc\n      _ = ∑ i ∈ s, 2 * r i * (∑ j ∈ s, g j) * (∑ j ∈ s, r j) := by\n          simp_rw [mul_assoc, ← mul_sum, ← sum_mul]; ring\n      _ ≤ ∑ i ∈ s, (f i * (∑ j ∈ s, g j) ^ 2 + g i * (∑ j ∈ s, r j) ^ 2) := by\n          gcongr with i hi\n          have ht : (r i * (∑ j ∈ s, g j) * (∑ j ∈ s, r j)) ^ 2 =\n              (f i * (∑ j ∈ s, g j) ^ 2) * (g i * (∑ j ∈ s, r j) ^ 2) := by\n            conv_rhs => rw [mul_mul_mul_comm, ← ht i hi]\n            ring\n          refine le_of_eq_of_le ?_ (two_mul_le_add_of_sq_eq_mul\n            (mul_nonneg (hf i hi) (sq_nonneg _)) (mul_nonneg (hg i hi) (sq_nonneg _)) ht)\n          repeat rw [mul_assoc]\n      _ = _ := by simp_rw [sum_add_distrib, ← sum_mul]; ring\n\n"}
{"name":"Finset.sum_mul_sq_le_sq_mul_sq","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : LinearOrderedCommSemiring R\ninst✝ : ExistsAddOfLE R\ns : Finset ι\nf g : ι → R\n⊢ LE.le (HPow.hPow (s.sum fun i => HMul.hMul (f i) (g i)) 2) (HMul.hMul (s.sum fun i => HPow.hPow (f i) 2) (s.sum fun i => HPow.hPow (g i) 2))","decl":"/-- **Cauchy-Schwarz inequality** for finsets, squared version. -/\nlemma sum_mul_sq_le_sq_mul_sq [LinearOrderedCommSemiring R] [ExistsAddOfLE R] (s : Finset ι)\n    (f g : ι → R) : (∑ i ∈ s, f i * g i) ^ 2 ≤ (∑ i ∈ s, f i ^ 2) * ∑ i ∈ s, g i ^ 2 :=\n  sum_sq_le_sum_mul_sum_of_sq_eq_mul s\n    (fun _ _ ↦ sq_nonneg _) (fun _ _ ↦ sq_nonneg _) (fun _ _ ↦ mul_pow ..)\n\n"}
{"name":"Finset.sq_sum_div_le_sum_sq_div","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\ninst✝¹ : LinearOrderedSemifield R\ninst✝ : ExistsAddOfLE R\ns : Finset ι\nf g : ι → R\nhg : ∀ (i : ι), Membership.mem s i → LT.lt 0 (g i)\n⊢ LE.le (HDiv.hDiv (HPow.hPow (s.sum fun i => f i) 2) (s.sum fun i => g i)) (s.sum fun i => HDiv.hDiv (HPow.hPow (f i) 2) (g i))","decl":"/-- **Sedrakyan's lemma**, aka **Titu's lemma** or **Engel's form**.\n\nThis is a specialization of the Cauchy-Schwarz inequality with the sequences `f n / √(g n)` and\n`√(g n)`, though here it is proven without relying on square roots. -/\ntheorem sq_sum_div_le_sum_sq_div [LinearOrderedSemifield R] [ExistsAddOfLE R] (s : Finset ι)\n    (f : ι → R) {g : ι → R} (hg : ∀ i ∈ s, 0 < g i) :\n    (∑ i ∈ s, f i) ^ 2 / ∑ i ∈ s, g i ≤ ∑ i ∈ s, f i ^ 2 / g i := by\n  have hg' : ∀ i ∈ s, 0 ≤ g i := fun i hi ↦ (hg i hi).le\n  have H : ∀ i ∈ s, 0 ≤ f i ^ 2 / g i := fun i hi ↦ div_nonneg (sq_nonneg _) (hg' i hi)\n  refine div_le_of_le_mul₀ (sum_nonneg hg') (sum_nonneg H)\n    (sum_sq_le_sum_mul_sum_of_sq_eq_mul _ H hg' fun i hi ↦ ?_)\n  rw [div_mul_cancel₀]\n  exact (hg i hi).ne'\n\n"}
{"name":"AbsoluteValue.sum_le","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝¹ : Semiring R\ninst✝ : OrderedSemiring S\nabv : AbsoluteValue R S\ns : Finset ι\nf : ι → R\n⊢ LE.le (abv (s.sum fun i => f i)) (s.sum fun i => abv (f i))","decl":"lemma AbsoluteValue.sum_le [Semiring R] [OrderedSemiring S] (abv : AbsoluteValue R S)\n    (s : Finset ι) (f : ι → R) : abv (∑ i ∈ s, f i) ≤ ∑ i ∈ s, abv (f i) :=\n  Finset.le_sum_of_subadditive abv (map_zero _) abv.add_le _ _\n\n"}
{"name":"IsAbsoluteValue.abv_sum","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : Semiring R\ninst✝¹ : OrderedSemiring S\nabv : R → S\ninst✝ : IsAbsoluteValue abv\nf : ι → R\ns : Finset ι\n⊢ LE.le (abv (s.sum fun i => f i)) (s.sum fun i => abv (f i))","decl":"lemma IsAbsoluteValue.abv_sum [Semiring R] [OrderedSemiring S] (abv : R → S) [IsAbsoluteValue abv]\n    (f : ι → R) (s : Finset ι) : abv (∑ i ∈ s, f i) ≤ ∑ i ∈ s, abv (f i) :=\n  (IsAbsoluteValue.toAbsoluteValue abv).sum_le _ _\n\n"}
{"name":"AbsoluteValue.map_prod","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : Nontrivial R\ninst✝ : LinearOrderedCommRing S\nabv : AbsoluteValue R S\nf : ι → R\ns : Finset ι\n⊢ Eq (abv (s.prod fun i => f i)) (s.prod fun i => abv (f i))","decl":"nonrec lemma AbsoluteValue.map_prod [CommSemiring R] [Nontrivial R] [LinearOrderedCommRing S]\n    (abv : AbsoluteValue R S) (f : ι → R) (s : Finset ι) :\n    abv (∏ i ∈ s, f i) = ∏ i ∈ s, abv (f i) :=\n  map_prod abv f s\n\n"}
{"name":"IsAbsoluteValue.map_prod","module":"Mathlib.Algebra.Order.BigOperators.Ring.Finset","initialProofState":"ι : Type u_1\nR : Type u_2\nS : Type u_3\ninst✝³ : CommSemiring R\ninst✝² : Nontrivial R\ninst✝¹ : LinearOrderedCommRing S\nabv : R → S\ninst✝ : IsAbsoluteValue abv\nf : ι → R\ns : Finset ι\n⊢ Eq (abv (s.prod fun i => f i)) (s.prod fun i => abv (f i))","decl":"lemma IsAbsoluteValue.map_prod [CommSemiring R] [Nontrivial R] [LinearOrderedCommRing S]\n    (abv : R → S) [IsAbsoluteValue abv] (f : ι → R) (s : Finset ι) :\n    abv (∏ i ∈ s, f i) = ∏ i ∈ s, abv (f i) :=\n  (IsAbsoluteValue.toAbsoluteValue abv).map_prod _ _\n\n"}
