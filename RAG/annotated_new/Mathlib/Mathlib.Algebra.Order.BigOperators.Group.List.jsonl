{"name":"List.Forall₂.sum_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl₁ l₂ : List M\nh : List.Forall₂ (fun x1 x2 => LE.le x1 x2) l₁ l₂\n⊢ LE.le l₁.sum l₂.sum","decl":"@[to_additive sum_le_sum]\nlemma Forall₂.prod_le_prod' [Preorder M] [MulRightMono M]\n    [MulLeftMono M] {l₁ l₂ : List M} (h : Forall₂ (· ≤ ·) l₁ l₂) :\n    l₁.prod ≤ l₂.prod := by\n  induction' h with a b la lb hab ih ih'\n  · rfl\n  · simpa only [prod_cons] using mul_le_mul' hab ih'\n\n"}
{"name":"List.Forall₂.prod_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl₁ l₂ : List M\nh : List.Forall₂ (fun x1 x2 => LE.le x1 x2) l₁ l₂\n⊢ LE.le l₁.prod l₂.prod","decl":"@[to_additive sum_le_sum]\nlemma Forall₂.prod_le_prod' [Preorder M] [MulRightMono M]\n    [MulLeftMono M] {l₁ l₂ : List M} (h : Forall₂ (· ≤ ·) l₁ l₂) :\n    l₁.prod ≤ l₂.prod := by\n  induction' h with a b la lb hab ih ih'\n  · rfl\n  · simpa only [prod_cons] using mul_le_mul' hab ih'\n\n"}
{"name":"List.Sublist.prod_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl₁ l₂ : List M\nh : l₁.Sublist l₂\nh₁ : ∀ (a : M), Membership.mem l₂ a → LE.le 1 a\n⊢ LE.le l₁.prod l₂.prod","decl":"/-- If `l₁` is a sublist of `l₂` and all elements of `l₂` are greater than or equal to one, then\n`l₁.prod ≤ l₂.prod`. One can prove a stronger version assuming `∀ a ∈ l₂.diff l₁, 1 ≤ a` instead\nof `∀ a ∈ l₂, 1 ≤ a` but this lemma is not yet in `mathlib`. -/\n@[to_additive sum_le_sum \"If `l₁` is a sublist of `l₂` and all elements of `l₂` are nonnegative,\n  then `l₁.sum ≤ l₂.sum`.\n  One can prove a stronger version assuming `∀ a ∈ l₂.diff l₁, 0 ≤ a` instead of `∀ a ∈ l₂, 0 ≤ a`\n  but this lemma is not yet in `mathlib`.\"]\nlemma Sublist.prod_le_prod' [Preorder M] [MulRightMono M]\n    [MulLeftMono M] {l₁ l₂ : List M} (h : l₁ <+ l₂)\n    (h₁ : ∀ a ∈ l₂, (1 : M) ≤ a) : l₁.prod ≤ l₂.prod := by\n  induction h with\n  | slnil => rfl\n  | cons a _ ih' =>\n    simp only [prod_cons, forall_mem_cons] at h₁ ⊢\n    exact (ih' h₁.2).trans (le_mul_of_one_le_left' h₁.1)\n  | cons₂ a _ ih' =>\n    simp only [prod_cons, forall_mem_cons] at h₁ ⊢\n    exact mul_le_mul_left' (ih' h₁.2) _\n\n"}
{"name":"List.Sublist.sum_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl₁ l₂ : List M\nh : l₁.Sublist l₂\nh₁ : ∀ (a : M), Membership.mem l₂ a → LE.le 0 a\n⊢ LE.le l₁.sum l₂.sum","decl":"/-- If `l₁` is a sublist of `l₂` and all elements of `l₂` are greater than or equal to one, then\n`l₁.prod ≤ l₂.prod`. One can prove a stronger version assuming `∀ a ∈ l₂.diff l₁, 1 ≤ a` instead\nof `∀ a ∈ l₂, 1 ≤ a` but this lemma is not yet in `mathlib`. -/\n@[to_additive sum_le_sum \"If `l₁` is a sublist of `l₂` and all elements of `l₂` are nonnegative,\n  then `l₁.sum ≤ l₂.sum`.\n  One can prove a stronger version assuming `∀ a ∈ l₂.diff l₁, 0 ≤ a` instead of `∀ a ∈ l₂, 0 ≤ a`\n  but this lemma is not yet in `mathlib`.\"]\nlemma Sublist.prod_le_prod' [Preorder M] [MulRightMono M]\n    [MulLeftMono M] {l₁ l₂ : List M} (h : l₁ <+ l₂)\n    (h₁ : ∀ a ∈ l₂, (1 : M) ≤ a) : l₁.prod ≤ l₂.prod := by\n  induction h with\n  | slnil => rfl\n  | cons a _ ih' =>\n    simp only [prod_cons, forall_mem_cons] at h₁ ⊢\n    exact (ih' h₁.2).trans (le_mul_of_one_le_left' h₁.1)\n  | cons₂ a _ ih' =>\n    simp only [prod_cons, forall_mem_cons] at h₁ ⊢\n    exact mul_le_mul_left' (ih' h₁.2) _\n\n"}
{"name":"List.SublistForall₂.sum_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl₁ l₂ : List M\nh : List.SublistForall₂ (fun x1 x2 => LE.le x1 x2) l₁ l₂\nh₁ : ∀ (a : M), Membership.mem l₂ a → LE.le 0 a\n⊢ LE.le l₁.sum l₂.sum","decl":"@[to_additive sum_le_sum]\nlemma SublistForall₂.prod_le_prod' [Preorder M]\n    [MulRightMono M] [MulLeftMono M]\n    {l₁ l₂ : List M} (h : SublistForall₂ (· ≤ ·) l₁ l₂) (h₁ : ∀ a ∈ l₂, (1 : M) ≤ a) :\n    l₁.prod ≤ l₂.prod :=\n  let ⟨_, hall, hsub⟩ := sublistForall₂_iff.1 h\n  hall.prod_le_prod'.trans <| hsub.prod_le_prod' h₁\n\n"}
{"name":"List.SublistForall₂.prod_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl₁ l₂ : List M\nh : List.SublistForall₂ (fun x1 x2 => LE.le x1 x2) l₁ l₂\nh₁ : ∀ (a : M), Membership.mem l₂ a → LE.le 1 a\n⊢ LE.le l₁.prod l₂.prod","decl":"@[to_additive sum_le_sum]\nlemma SublistForall₂.prod_le_prod' [Preorder M]\n    [MulRightMono M] [MulLeftMono M]\n    {l₁ l₂ : List M} (h : SublistForall₂ (· ≤ ·) l₁ l₂) (h₁ : ∀ a ∈ l₂, (1 : M) ≤ a) :\n    l₁.prod ≤ l₂.prod :=\n  let ⟨_, hall, hsub⟩ := sublistForall₂_iff.1 h\n  hall.prod_le_prod'.trans <| hsub.prod_le_prod' h₁\n\n"}
{"name":"List.sum_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl : List ι\nf g : ι → M\nh : ∀ (i : ι), Membership.mem l i → LE.le (f i) (g i)\n⊢ LE.le (List.map f l).sum (List.map g l).sum","decl":"@[to_additive sum_le_sum]\nlemma prod_le_prod' [Preorder M] [MulRightMono M]\n    [MulLeftMono M] {l : List ι} {f g : ι → M} (h : ∀ i ∈ l, f i ≤ g i) :\n    (l.map f).prod ≤ (l.map g).prod :=\n  Forall₂.prod_le_prod' <| by simpa\n\n"}
{"name":"List.prod_le_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl : List ι\nf g : ι → M\nh : ∀ (i : ι), Membership.mem l i → LE.le (f i) (g i)\n⊢ LE.le (List.map f l).prod (List.map g l).prod","decl":"@[to_additive sum_le_sum]\nlemma prod_le_prod' [Preorder M] [MulRightMono M]\n    [MulLeftMono M] {l : List ι} {f g : ι → M} (h : ∀ i ∈ l, f i ≤ g i) :\n    (l.map f).prod ≤ (l.map g).prod :=\n  Forall₂.prod_le_prod' <| by simpa\n\n"}
{"name":"List.sum_lt_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁵ : AddMonoid M\ninst✝⁴ : Preorder M\ninst✝³ : AddLeftStrictMono M\ninst✝² : AddLeftMono M\ninst✝¹ : AddRightStrictMono M\ninst✝ : AddRightMono M\nl : List ι\nf g : ι → M\nh₁ : ∀ (i : ι), Membership.mem l i → LE.le (f i) (g i)\nh₂ : Exists fun i => And (Membership.mem l i) (LT.lt (f i) (g i))\n⊢ LT.lt (List.map f l).sum (List.map g l).sum","decl":"@[to_additive sum_lt_sum]\nlemma prod_lt_prod' [Preorder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List ι} (f g : ι → M)\n    (h₁ : ∀ i ∈ l, f i ≤ g i) (h₂ : ∃ i ∈ l, f i < g i) : (l.map f).prod < (l.map g).prod := by\n  induction' l with i l ihl\n  · rcases h₂ with ⟨_, ⟨⟩, _⟩\n  simp only [forall_mem_cons, map_cons, prod_cons] at h₁ ⊢\n  simp only [mem_cons, exists_eq_or_imp] at h₂\n  cases h₂\n  · exact mul_lt_mul_of_lt_of_le ‹_› (prod_le_prod' h₁.2)\n  · exact mul_lt_mul_of_le_of_lt h₁.1 <| ihl h₁.2 ‹_›\n\n"}
{"name":"List.prod_lt_prod'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁵ : Monoid M\ninst✝⁴ : Preorder M\ninst✝³ : MulLeftStrictMono M\ninst✝² : MulLeftMono M\ninst✝¹ : MulRightStrictMono M\ninst✝ : MulRightMono M\nl : List ι\nf g : ι → M\nh₁ : ∀ (i : ι), Membership.mem l i → LE.le (f i) (g i)\nh₂ : Exists fun i => And (Membership.mem l i) (LT.lt (f i) (g i))\n⊢ LT.lt (List.map f l).prod (List.map g l).prod","decl":"@[to_additive sum_lt_sum]\nlemma prod_lt_prod' [Preorder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List ι} (f g : ι → M)\n    (h₁ : ∀ i ∈ l, f i ≤ g i) (h₂ : ∃ i ∈ l, f i < g i) : (l.map f).prod < (l.map g).prod := by\n  induction' l with i l ihl\n  · rcases h₂ with ⟨_, ⟨⟩, _⟩\n  simp only [forall_mem_cons, map_cons, prod_cons] at h₁ ⊢\n  simp only [mem_cons, exists_eq_or_imp] at h₂\n  cases h₂\n  · exact mul_lt_mul_of_lt_of_le ‹_› (prod_le_prod' h₁.2)\n  · exact mul_lt_mul_of_le_of_lt h₁.1 <| ihl h₁.2 ‹_›\n\n"}
{"name":"List.sum_lt_sum_of_ne_nil","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁵ : AddMonoid M\ninst✝⁴ : Preorder M\ninst✝³ : AddLeftStrictMono M\ninst✝² : AddLeftMono M\ninst✝¹ : AddRightStrictMono M\ninst✝ : AddRightMono M\nl : List ι\nhl : Ne l List.nil\nf g : ι → M\nhlt : ∀ (i : ι), Membership.mem l i → LT.lt (f i) (g i)\n⊢ LT.lt (List.map f l).sum (List.map g l).sum","decl":"@[to_additive]\nlemma prod_lt_prod_of_ne_nil [Preorder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List ι} (hl : l ≠ []) (f g : ι → M)\n    (hlt : ∀ i ∈ l, f i < g i) : (l.map f).prod < (l.map g).prod :=\n  (prod_lt_prod' f g fun i hi => (hlt i hi).le) <|\n    (exists_mem_of_ne_nil l hl).imp fun i hi => ⟨hi, hlt i hi⟩\n\n"}
{"name":"List.prod_lt_prod_of_ne_nil","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁵ : Monoid M\ninst✝⁴ : Preorder M\ninst✝³ : MulLeftStrictMono M\ninst✝² : MulLeftMono M\ninst✝¹ : MulRightStrictMono M\ninst✝ : MulRightMono M\nl : List ι\nhl : Ne l List.nil\nf g : ι → M\nhlt : ∀ (i : ι), Membership.mem l i → LT.lt (f i) (g i)\n⊢ LT.lt (List.map f l).prod (List.map g l).prod","decl":"@[to_additive]\nlemma prod_lt_prod_of_ne_nil [Preorder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List ι} (hl : l ≠ []) (f g : ι → M)\n    (hlt : ∀ i ∈ l, f i < g i) : (l.map f).prod < (l.map g).prod :=\n  (prod_lt_prod' f g fun i hi => (hlt i hi).le) <|\n    (exists_mem_of_ne_nil l hl).imp fun i hi => ⟨hi, hlt i hi⟩\n\n"}
{"name":"List.prod_le_pow_card","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl : List M\nn : M\nh : ∀ (x : M), Membership.mem l x → LE.le x n\n⊢ LE.le l.prod (HPow.hPow n l.length)","decl":"@[to_additive sum_le_card_nsmul]\nlemma prod_le_pow_card [Preorder M] [MulRightMono M]\n    [MulLeftMono M] (l : List M) (n : M) (h : ∀ x ∈ l, x ≤ n) :\n    l.prod ≤ n ^ l.length := by\n      simpa only [map_id', map_const', prod_replicate] using prod_le_prod' h\n\n"}
{"name":"List.sum_le_card_nsmul","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl : List M\nn : M\nh : ∀ (x : M), Membership.mem l x → LE.le x n\n⊢ LE.le l.sum (HSMul.hSMul l.length n)","decl":"@[to_additive sum_le_card_nsmul]\nlemma prod_le_pow_card [Preorder M] [MulRightMono M]\n    [MulLeftMono M] (l : List M) (n : M) (h : ∀ x ∈ l, x ≤ n) :\n    l.prod ≤ n ^ l.length := by\n      simpa only [map_id', map_const', prod_replicate] using prod_le_prod' h\n\n"}
{"name":"List.pow_card_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl : List M\nn : M\nh : ∀ (x : M), Membership.mem l x → LE.le n x\n⊢ LE.le (HPow.hPow n l.length) l.prod","decl":"@[to_additive card_nsmul_le_sum]\nlemma pow_card_le_prod [Preorder M] [MulRightMono M]\n    [MulLeftMono M] (l : List M) (n : M) (h : ∀ x ∈ l, n ≤ x) :\n    n ^ l.length ≤ l.prod :=\n  @prod_le_pow_card Mᵒᵈ _ _ _ _ l n h\n\n"}
{"name":"List.card_nsmul_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl : List M\nn : M\nh : ∀ (x : M), Membership.mem l x → LE.le n x\n⊢ LE.le (HSMul.hSMul l.length n) l.sum","decl":"@[to_additive card_nsmul_le_sum]\nlemma pow_card_le_prod [Preorder M] [MulRightMono M]\n    [MulLeftMono M] (l : List M) (n : M) (h : ∀ x ∈ l, n ≤ x) :\n    n ^ l.length ≤ l.prod :=\n  @prod_le_pow_card Mᵒᵈ _ _ _ _ l n h\n\n"}
{"name":"List.exists_lt_of_prod_lt'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\nl : List ι\nf g : ι → M\nh : LT.lt (List.map f l).prod (List.map g l).prod\n⊢ Exists fun i => And (Membership.mem l i) (LT.lt (f i) (g i))","decl":"@[to_additive exists_lt_of_sum_lt]\nlemma exists_lt_of_prod_lt' [LinearOrder M] [MulRightMono M]\n    [MulLeftMono M] {l : List ι} (f g : ι → M)\n    (h : (l.map f).prod < (l.map g).prod) : ∃ i ∈ l, f i < g i := by\n  contrapose! h\n  exact prod_le_prod' h\n\n"}
{"name":"List.exists_lt_of_sum_lt","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\nl : List ι\nf g : ι → M\nh : LT.lt (List.map f l).sum (List.map g l).sum\n⊢ Exists fun i => And (Membership.mem l i) (LT.lt (f i) (g i))","decl":"@[to_additive exists_lt_of_sum_lt]\nlemma exists_lt_of_prod_lt' [LinearOrder M] [MulRightMono M]\n    [MulLeftMono M] {l : List ι} (f g : ι → M)\n    (h : (l.map f).prod < (l.map g).prod) : ∃ i ∈ l, f i < g i := by\n  contrapose! h\n  exact prod_le_prod' h\n\n"}
{"name":"List.exists_le_of_sum_le","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁵ : AddMonoid M\ninst✝⁴ : LinearOrder M\ninst✝³ : AddLeftStrictMono M\ninst✝² : AddLeftMono M\ninst✝¹ : AddRightStrictMono M\ninst✝ : AddRightMono M\nl : List ι\nhl : Ne l List.nil\nf g : ι → M\nh : LE.le (List.map f l).sum (List.map g l).sum\n⊢ Exists fun x => And (Membership.mem l x) (LE.le (f x) (g x))","decl":"@[to_additive exists_le_of_sum_le]\nlemma exists_le_of_prod_le' [LinearOrder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List ι} (hl : l ≠ []) (f g : ι → M)\n    (h : (l.map f).prod ≤ (l.map g).prod) : ∃ x ∈ l, f x ≤ g x := by\n  contrapose! h\n  exact prod_lt_prod_of_ne_nil hl _ _ h\n\n"}
{"name":"List.exists_le_of_prod_le'","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"ι : Type u_1\nM : Type u_3\ninst✝⁵ : Monoid M\ninst✝⁴ : LinearOrder M\ninst✝³ : MulLeftStrictMono M\ninst✝² : MulLeftMono M\ninst✝¹ : MulRightStrictMono M\ninst✝ : MulRightMono M\nl : List ι\nhl : Ne l List.nil\nf g : ι → M\nh : LE.le (List.map f l).prod (List.map g l).prod\n⊢ Exists fun x => And (Membership.mem l x) (LE.le (f x) (g x))","decl":"@[to_additive exists_le_of_sum_le]\nlemma exists_le_of_prod_le' [LinearOrder M] [MulLeftStrictMono M]\n    [MulLeftMono M] [MulRightStrictMono M]\n    [MulRightMono M] {l : List ι} (hl : l ≠ []) (f g : ι → M)\n    (h : (l.map f).prod ≤ (l.map g).prod) : ∃ x ∈ l, f x ≤ g x := by\n  contrapose! h\n  exact prod_lt_prod_of_ne_nil hl _ _ h\n\n"}
{"name":"List.one_le_prod_of_one_le","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\nl : List M\nhl₁ : ∀ (x : M), Membership.mem l x → LE.le 1 x\n⊢ LE.le 1 l.prod","decl":"@[to_additive sum_nonneg]\nlemma one_le_prod_of_one_le [Preorder M] [MulLeftMono M] {l : List M}\n    (hl₁ : ∀ x ∈ l, (1 : M) ≤ x) : 1 ≤ l.prod := by\n  -- We don't use `pow_card_le_prod` to avoid assumption\n  -- [covariant_class M M (function.swap (*)) (≤)]\n  induction' l with hd tl ih\n  · rfl\n  rw [prod_cons]\n  exact one_le_mul (hl₁ hd (mem_cons_self hd tl)) (ih fun x h => hl₁ x (mem_cons_of_mem hd h))\n\n"}
{"name":"List.sum_nonneg","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\nl : List M\nhl₁ : ∀ (x : M), Membership.mem l x → LE.le 0 x\n⊢ LE.le 0 l.sum","decl":"@[to_additive sum_nonneg]\nlemma one_le_prod_of_one_le [Preorder M] [MulLeftMono M] {l : List M}\n    (hl₁ : ∀ x ∈ l, (1 : M) ≤ x) : 1 ≤ l.prod := by\n  -- We don't use `pow_card_le_prod` to avoid assumption\n  -- [covariant_class M M (function.swap (*)) (≤)]\n  induction' l with hd tl ih\n  · rfl\n  rw [prod_cons]\n  exact one_le_mul (hl₁ hd (mem_cons_self hd tl)) (ih fun x h => hl₁ x (mem_cons_of_mem hd h))\n\n"}
{"name":"List.max_sum_le","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝³ : AddMonoid M\nl : List α\nf g : α → M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\n⊢ LE.le (Max.max (List.map f l).sum (List.map g l).sum) (List.map (fun i => Max.max (f i) (g i)) l).sum","decl":"@[to_additive]\nlemma max_prod_le (l : List α) (f g : α → M) [LinearOrder M]\n    [MulLeftMono M] [MulRightMono M] :\n    max (l.map f).prod (l.map g).prod ≤ (l.map fun i ↦ max (f i) (g i)).prod := by\n  rw [max_le_iff]\n  constructor <;> apply List.prod_le_prod' <;> intros\n  · apply le_max_left\n  · apply le_max_right\n\n"}
{"name":"List.max_prod_le","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝³ : Monoid M\nl : List α\nf g : α → M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\n⊢ LE.le (Max.max (List.map f l).prod (List.map g l).prod) (List.map (fun i => Max.max (f i) (g i)) l).prod","decl":"@[to_additive]\nlemma max_prod_le (l : List α) (f g : α → M) [LinearOrder M]\n    [MulLeftMono M] [MulRightMono M] :\n    max (l.map f).prod (l.map g).prod ≤ (l.map fun i ↦ max (f i) (g i)).prod := by\n  rw [max_le_iff]\n  constructor <;> apply List.prod_le_prod' <;> intros\n  · apply le_max_left\n  · apply le_max_right\n\n"}
{"name":"List.sum_min_le","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\nl : List α\nf g : α → M\n⊢ LE.le (List.map (fun i => Min.min (f i) (g i)) l).sum (Min.min (List.map f l).sum (List.map g l).sum)","decl":"@[to_additive]\nlemma prod_min_le [LinearOrder M] [MulLeftMono M]\n    [MulRightMono M] (l : List α) (f g : α → M) :\n    (l.map fun i ↦ min (f i) (g i)).prod ≤ min (l.map f).prod (l.map g).prod := by\n  rw [le_min_iff]\n  constructor <;> apply List.prod_le_prod' <;> intros\n  · apply min_le_left\n  · apply min_le_right\n\n"}
{"name":"List.prod_min_le","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"α : Type u_2\nM : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\nl : List α\nf g : α → M\n⊢ LE.le (List.map (fun i => Min.min (f i) (g i)) l).prod (Min.min (List.map f l).prod (List.map g l).prod)","decl":"@[to_additive]\nlemma prod_min_le [LinearOrder M] [MulLeftMono M]\n    [MulRightMono M] (l : List α) (f g : α → M) :\n    (l.map fun i ↦ min (f i) (g i)).prod ≤ min (l.map f).prod (l.map g).prod := by\n  rw [le_min_iff]\n  constructor <;> apply List.prod_le_prod' <;> intros\n  · apply min_le_left\n  · apply min_le_right\n\n"}
{"name":"List.sum_le_foldr_max","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : LinearOrder N\nf : M → N\nh0 : LE.le (f 0) 0\nhadd : ∀ (x y : M), LE.le (f (HAdd.hAdd x y)) (Max.max (f x) (f y))\nl : List M\n⊢ LE.le (f l.sum) (List.foldr Max.max 0 (List.map f l))","decl":"lemma sum_le_foldr_max [AddMonoid M] [AddMonoid N] [LinearOrder N] (f : M → N) (h0 : f 0 ≤ 0)\n    (hadd : ∀ x y, f (x + y) ≤ max (f x) (f y)) (l : List M) : f l.sum ≤ (l.map f).foldr max 0 := by\n  induction' l with hd tl IH\n  · simpa using h0\n  simp only [List.sum_cons, List.foldr_map, List.foldr] at IH ⊢\n  exact (hadd _ _).trans (max_le_max le_rfl IH)\n\n"}
{"name":"List.sum_pos","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝ : OrderedAddCommMonoid M\nl : List M\na✝¹ : ∀ (x : M), Membership.mem l x → LT.lt 0 x\na✝ : Ne l List.nil\n⊢ LT.lt 0 l.sum","decl":"@[to_additive sum_pos]\nlemma one_lt_prod_of_one_lt [OrderedCommMonoid M] :\n    ∀ l : List M, (∀ x ∈ l, (1 : M) < x) → l ≠ [] → 1 < l.prod\n  | [], _, h => (h rfl).elim\n  | [b], h, _ => by simpa using h\n  | a :: b :: l, hl₁, _ => by\n    simp only [forall_eq_or_imp, List.mem_cons] at hl₁\n    rw [List.prod_cons]\n    apply one_lt_mul_of_lt_of_le' hl₁.1\n    apply le_of_lt ((b :: l).one_lt_prod_of_one_lt _ (l.cons_ne_nil b))\n    intro x hx; cases hx\n    · exact hl₁.2.1\n    · exact hl₁.2.2 _ ‹_›\n\n"}
{"name":"List.one_lt_prod_of_one_lt","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝ : OrderedCommMonoid M\nl : List M\na✝¹ : ∀ (x : M), Membership.mem l x → LT.lt 1 x\na✝ : Ne l List.nil\n⊢ LT.lt 1 l.prod","decl":"@[to_additive sum_pos]\nlemma one_lt_prod_of_one_lt [OrderedCommMonoid M] :\n    ∀ l : List M, (∀ x ∈ l, (1 : M) < x) → l ≠ [] → 1 < l.prod\n  | [], _, h => (h rfl).elim\n  | [b], h, _ => by simpa using h\n  | a :: b :: l, hl₁, _ => by\n    simp only [forall_eq_or_imp, List.mem_cons] at hl₁\n    rw [List.prod_cons]\n    apply one_lt_mul_of_lt_of_le' hl₁.1\n    apply le_of_lt ((b :: l).one_lt_prod_of_one_lt _ (l.cons_ne_nil b))\n    intro x hx; cases hx\n    · exact hl₁.2.1\n    · exact hl₁.2.2 _ ‹_›\n\n"}
{"name":"List.single_le_sum","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝ : OrderedAddCommMonoid M\nl : List M\nhl₁ : ∀ (x : M), Membership.mem l x → LE.le 0 x\nx : M\na✝ : Membership.mem l x\n⊢ LE.le x l.sum","decl":"/-- See also `List.le_prod_of_mem`. -/\n@[to_additive \"See also `List.le_sum_of_mem`.\"]\nlemma single_le_prod [OrderedCommMonoid M] {l : List M} (hl₁ : ∀ x ∈ l, (1 : M) ≤ x) :\n    ∀ x ∈ l, x ≤ l.prod := by\n  induction l\n  · simp\n  simp_rw [prod_cons, forall_mem_cons] at hl₁ ⊢\n  constructor\n  case cons.left => exact le_mul_of_one_le_right' (one_le_prod_of_one_le hl₁.2)\n  case cons.right hd tl ih => exact fun x H => le_mul_of_one_le_of_le hl₁.1 (ih hl₁.right x H)\n\n"}
{"name":"List.single_le_prod","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝ : OrderedCommMonoid M\nl : List M\nhl₁ : ∀ (x : M), Membership.mem l x → LE.le 1 x\nx : M\na✝ : Membership.mem l x\n⊢ LE.le x l.prod","decl":"/-- See also `List.le_prod_of_mem`. -/\n@[to_additive \"See also `List.le_sum_of_mem`.\"]\nlemma single_le_prod [OrderedCommMonoid M] {l : List M} (hl₁ : ∀ x ∈ l, (1 : M) ≤ x) :\n    ∀ x ∈ l, x ≤ l.prod := by\n  induction l\n  · simp\n  simp_rw [prod_cons, forall_mem_cons] at hl₁ ⊢\n  constructor\n  case cons.left => exact le_mul_of_one_le_right' (one_le_prod_of_one_le hl₁.2)\n  case cons.right hd tl ih => exact fun x H => le_mul_of_one_le_of_le hl₁.1 (ih hl₁.right x H)\n\n"}
{"name":"List.all_one_of_le_one_le_of_prod_eq_one","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝ : OrderedCommMonoid M\nl : List M\nhl₁ : ∀ (x : M), Membership.mem l x → LE.le 1 x\nhl₂ : Eq l.prod 1\nx : M\nhx : Membership.mem l x\n⊢ Eq x 1","decl":"@[to_additive all_zero_of_le_zero_le_of_sum_eq_zero]\nlemma all_one_of_le_one_le_of_prod_eq_one [OrderedCommMonoid M] {l : List M}\n    (hl₁ : ∀ x ∈ l, (1 : M) ≤ x) (hl₂ : l.prod = 1) {x : M} (hx : x ∈ l) : x = 1 :=\n  _root_.le_antisymm (hl₂ ▸ single_le_prod hl₁ _ hx) (hl₁ x hx)\n\n"}
{"name":"List.all_zero_of_le_zero_le_of_sum_eq_zero","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝ : OrderedAddCommMonoid M\nl : List M\nhl₁ : ∀ (x : M), Membership.mem l x → LE.le 0 x\nhl₂ : Eq l.sum 0\nx : M\nhx : Membership.mem l x\n⊢ Eq x 0","decl":"@[to_additive all_zero_of_le_zero_le_of_sum_eq_zero]\nlemma all_one_of_le_one_le_of_prod_eq_one [OrderedCommMonoid M] {l : List M}\n    (hl₁ : ∀ x ∈ l, (1 : M) ≤ x) (hl₂ : l.prod = 1) {x : M} (hx : x ∈ l) : x = 1 :=\n  _root_.le_antisymm (hl₂ ▸ single_le_prod hl₁ _ hx) (hl₁ x hx)\n\n"}
{"name":"List.prod_eq_one_iff","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nl : List M\n⊢ Iff (Eq l.prod 1) (∀ (x : M), Membership.mem l x → Eq x 1)","decl":"@[to_additive] lemma prod_eq_one_iff : l.prod = 1 ↔ ∀ x ∈ l, x = (1 : M) :=\n  ⟨all_one_of_le_one_le_of_prod_eq_one fun _ _ => one_le _, fun h => by\n    rw [List.eq_replicate_iff.2 ⟨_, h⟩, prod_replicate, one_pow]\n    · exact (length l)\n    · rfl⟩\n\n"}
{"name":"List.sum_eq_zero_iff","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nl : List M\n⊢ Iff (Eq l.sum 0) (∀ (x : M), Membership.mem l x → Eq x 0)","decl":"@[to_additive] lemma prod_eq_one_iff : l.prod = 1 ↔ ∀ x ∈ l, x = (1 : M) :=\n  ⟨all_one_of_le_one_le_of_prod_eq_one fun _ _ => one_le _, fun h => by\n    rw [List.eq_replicate_iff.2 ⟨_, h⟩, prod_replicate, one_pow]\n    · exact (length l)\n    · rfl⟩\n\n"}
{"name":"List.monotone_sum_take","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nL : List M\n⊢ Monotone fun i => (List.take i L).sum","decl":"@[to_additive] lemma monotone_prod_take (L : List M) : Monotone fun i => (L.take i).prod := by\n  refine monotone_nat_of_le_succ fun n => ?_\n  cases' lt_or_le n L.length with h h\n  · rw [prod_take_succ _ _ h]\n    exact le_self_mul\n  · simp [take_of_length_le h, take_of_length_le (le_trans h (Nat.le_succ _))]\n\n"}
{"name":"List.monotone_prod_take","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nL : List M\n⊢ Monotone fun i => (List.take i L).prod","decl":"@[to_additive] lemma monotone_prod_take (L : List M) : Monotone fun i => (L.take i).prod := by\n  refine monotone_nat_of_le_succ fun n => ?_\n  cases' lt_or_le n L.length with h h\n  · rw [prod_take_succ _ _ h]\n    exact le_self_mul\n  · simp [take_of_length_le h, take_of_length_le (le_trans h (Nat.le_succ _))]\n\n"}
{"name":"List.le_sum_of_mem","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝¹ : OrderedAddCommMonoid M\ninst✝ : CanonicallyOrderedAdd M\nxs : List M\nx : M\nh₁ : Membership.mem xs x\n⊢ LE.le x xs.sum","decl":"/-- See also `List.single_le_prod`. -/\n@[to_additive \"See also `List.single_le_sum`.\"]\ntheorem le_prod_of_mem {xs : List M} {x : M} (h₁ : x ∈ xs) : x ≤ xs.prod := by\n  induction xs with\n  | nil => simp at h₁\n  | cons y ys ih =>\n    simp only [mem_cons] at h₁\n    rcases h₁ with (rfl | h₁)\n    · simp\n    · specialize ih h₁\n      simp only [List.prod_cons]\n      exact le_mul_left ih\n\n"}
{"name":"List.le_prod_of_mem","module":"Mathlib.Algebra.Order.BigOperators.Group.List","initialProofState":"M : Type u_3\ninst✝¹ : OrderedCommMonoid M\ninst✝ : CanonicallyOrderedMul M\nxs : List M\nx : M\nh₁ : Membership.mem xs x\n⊢ LE.le x xs.prod","decl":"/-- See also `List.single_le_prod`. -/\n@[to_additive \"See also `List.single_le_sum`.\"]\ntheorem le_prod_of_mem {xs : List M} {x : M} (h₁ : x ∈ xs) : x ≤ xs.prod := by\n  induction xs with\n  | nil => simp at h₁\n  | cons y ys ih =>\n    simp only [mem_cons] at h₁\n    rcases h₁ with (rfl | h₁)\n    · simp\n    · specialize ih h₁\n      simp only [List.prod_cons]\n      exact le_mul_left ih\n\n"}
