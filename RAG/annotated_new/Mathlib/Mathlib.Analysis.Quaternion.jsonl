{"name":"Quaternion.inner_self","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Quaternion Real\n⊢ Eq (Inner.inner a a) (Quaternion.normSq a)","decl":"theorem inner_self (a : ℍ) : ⟪a, a⟫ = normSq a :=\n  rfl\n\n"}
{"name":"Quaternion.inner_def","module":"Mathlib.Analysis.Quaternion","initialProofState":"a b : Quaternion Real\n⊢ Eq (Inner.inner a b) (HMul.hMul a (Star.star b)).re","decl":"theorem inner_def (a b : ℍ) : ⟪a, b⟫ = (a * star b).re :=\n  rfl\n\n"}
{"name":"Quaternion.normSq_eq_norm_mul_self","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Quaternion Real\n⊢ Eq (Quaternion.normSq a) (HMul.hMul (Norm.norm a) (Norm.norm a))","decl":"theorem normSq_eq_norm_mul_self (a : ℍ) : normSq a = ‖a‖ * ‖a‖ := by\n  rw [← inner_self, real_inner_self_eq_norm_mul_norm]\n\n"}
{"name":"Quaternion.instNormOneClassReal","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ NormOneClass (Quaternion Real)","decl":"instance : NormOneClass ℍ :=\n  ⟨by rw [norm_eq_sqrt_real_inner, inner_self, normSq.map_one, Real.sqrt_one]⟩\n\n"}
{"name":"Quaternion.norm_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Real\n⊢ Eq (Norm.norm ↑a) (Norm.norm a)","decl":"@[simp, norm_cast]\ntheorem norm_coe (a : ℝ) : ‖(a : ℍ)‖ = ‖a‖ := by\n  rw [norm_eq_sqrt_real_inner, inner_self, normSq_coe, Real.sqrt_sq_eq_abs, Real.norm_eq_abs]\n\n"}
{"name":"Quaternion.nnnorm_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Real\n⊢ Eq (NNNorm.nnnorm ↑a) (NNNorm.nnnorm a)","decl":"@[simp, norm_cast]\ntheorem nnnorm_coe (a : ℝ) : ‖(a : ℍ)‖₊ = ‖a‖₊ :=\n  Subtype.ext <| norm_coe a\n\n-- Porting note https://github.com/leanprover-community/mathlib4/issues/10959\n-- simp cannot prove this\n"}
{"name":"Quaternion.norm_star","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Quaternion Real\n⊢ Eq (Norm.norm (Star.star a)) (Norm.norm a)","decl":"@[simp, nolint simpNF]\ntheorem norm_star (a : ℍ) : ‖star a‖ = ‖a‖ := by\n  simp_rw [norm_eq_sqrt_real_inner, inner_self, normSq_star]\n\n-- Porting note https://github.com/leanprover-community/mathlib4/issues/10959\n-- simp cannot prove this\n"}
{"name":"Quaternion.nnnorm_star","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Quaternion Real\n⊢ Eq (NNNorm.nnnorm (Star.star a)) (NNNorm.nnnorm a)","decl":"@[simp, nolint simpNF]\ntheorem nnnorm_star (a : ℍ) : ‖star a‖₊ = ‖a‖₊ :=\n  Subtype.ext <| norm_star a\n\n"}
{"name":"Quaternion.instCStarRingReal","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ CStarRing (Quaternion Real)","decl":"instance : CStarRing ℍ where\n  norm_mul_self_le x :=\n    le_of_eq <| Eq.symm <| (norm_mul _ _).trans <| congr_arg (· * ‖x‖) (norm_star x)\n\n"}
{"name":"Quaternion.coeComplex_re","module":"Mathlib.Analysis.Quaternion","initialProofState":"z : Complex\n⊢ Eq (↑z).re z.re","decl":"@[simp, norm_cast]\ntheorem coeComplex_re (z : ℂ) : (z : ℍ).re = z.re :=\n  rfl\n\n"}
{"name":"Quaternion.coeComplex_imI","module":"Mathlib.Analysis.Quaternion","initialProofState":"z : Complex\n⊢ Eq (↑z).imI z.im","decl":"@[simp, norm_cast]\ntheorem coeComplex_imI (z : ℂ) : (z : ℍ).imI = z.im :=\n  rfl\n\n"}
{"name":"Quaternion.coeComplex_imJ","module":"Mathlib.Analysis.Quaternion","initialProofState":"z : Complex\n⊢ Eq (↑z).imJ 0","decl":"@[simp, norm_cast]\ntheorem coeComplex_imJ (z : ℂ) : (z : ℍ).imJ = 0 :=\n  rfl\n\n"}
{"name":"Quaternion.coeComplex_imK","module":"Mathlib.Analysis.Quaternion","initialProofState":"z : Complex\n⊢ Eq (↑z).imK 0","decl":"@[simp, norm_cast]\ntheorem coeComplex_imK (z : ℂ) : (z : ℍ).imK = 0 :=\n  rfl\n\n"}
{"name":"Quaternion.coeComplex_add","module":"Mathlib.Analysis.Quaternion","initialProofState":"z w : Complex\n⊢ Eq (↑(HAdd.hAdd z w)) (HAdd.hAdd ↑z ↑w)","decl":"@[simp, norm_cast]\ntheorem coeComplex_add (z w : ℂ) : ↑(z + w) = (z + w : ℍ) := by ext <;> simp\n\n"}
{"name":"Quaternion.coeComplex_mul","module":"Mathlib.Analysis.Quaternion","initialProofState":"z w : Complex\n⊢ Eq (↑(HMul.hMul z w)) (HMul.hMul ↑z ↑w)","decl":"@[simp, norm_cast]\ntheorem coeComplex_mul (z w : ℂ) : ↑(z * w) = (z * w : ℍ) := by ext <;> simp\n\n"}
{"name":"Quaternion.coeComplex_zero","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem coeComplex_zero : ((0 : ℂ) : ℍ) = 0 :=\n  rfl\n\n"}
{"name":"Quaternion.coeComplex_one","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem coeComplex_one : ((1 : ℂ) : ℍ) = 1 :=\n  rfl\n\n"}
{"name":"Quaternion.coe_real_complex_mul","module":"Mathlib.Analysis.Quaternion","initialProofState":"r : Real\nz : Complex\n⊢ Eq (HSMul.hSMul r ↑z) (HMul.hMul ↑r ↑z)","decl":"@[simp, norm_cast]\ntheorem coe_real_complex_mul (r : ℝ) (z : ℂ) : (r • z : ℍ) = ↑r * ↑z := by ext <;> simp\n\n"}
{"name":"Quaternion.coeComplex_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"r : Real\n⊢ Eq ↑↑r ↑r","decl":"@[simp, norm_cast]\ntheorem coeComplex_coe (r : ℝ) : ((r : ℂ) : ℍ) = r :=\n  rfl\n\n"}
{"name":"Quaternion.coe_ofComplex","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Eq (⇑Quaternion.ofComplex) Quaternion.coeComplex","decl":"@[simp]\ntheorem coe_ofComplex : ⇑ofComplex = coeComplex := rfl\n\n"}
{"name":"Quaternion.norm_piLp_equiv_symm_equivTuple","module":"Mathlib.Analysis.Quaternion","initialProofState":"x : Quaternion Real\n⊢ Eq (Norm.norm ((WithLp.equiv 2 (Fin 4 → Real)).symm ((Quaternion.equivTuple Real) x))) (Norm.norm x)","decl":"/-- The norm of the components as a euclidean vector equals the norm of the quaternion. -/\ntheorem norm_piLp_equiv_symm_equivTuple (x : ℍ) :\n    ‖(WithLp.equiv 2 (Fin 4 → _)).symm (equivTuple ℝ x)‖ = ‖x‖ := by\n  rw [norm_eq_sqrt_real_inner, norm_eq_sqrt_real_inner, inner_self, normSq_def', PiLp.inner_apply,\n    Fin.sum_univ_four]\n  simp_rw [RCLike.inner_apply, starRingEnd_apply, star_trivial, ← sq]\n  rfl\n\n"}
{"name":"Quaternion.linearIsometryEquivTuple_apply","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : Quaternion Real\n⊢ Eq (Quaternion.linearIsometryEquivTuple a) ((WithLp.equiv 2 (Fin 4 → Real)).symm (Matrix.vecCons a.re (Matrix.vecCons a.imI (Matrix.vecCons a.imJ (Matrix.vecCons a.imK Matrix.vecEmpty)))))","decl":"/-- `QuaternionAlgebra.linearEquivTuple` as a `LinearIsometryEquiv`. -/\n@[simps apply symm_apply]\nnoncomputable def linearIsometryEquivTuple : ℍ ≃ₗᵢ[ℝ] EuclideanSpace ℝ (Fin 4) :=\n  { (QuaternionAlgebra.linearEquivTuple (-1 : ℝ) (0 : ℝ) (-1 : ℝ)).trans\n      (WithLp.linearEquiv 2 ℝ (Fin 4 → ℝ)).symm with\n    toFun := fun a => !₂[a.1, a.2, a.3, a.4]\n    invFun := fun a => ⟨a 0, a 1, a 2, a 3⟩\n    norm_map' := norm_piLp_equiv_symm_equivTuple }\n\n"}
{"name":"Quaternion.linearIsometryEquivTuple_symm_apply","module":"Mathlib.Analysis.Quaternion","initialProofState":"a : EuclideanSpace Real (Fin 4)\n⊢ Eq (Quaternion.linearIsometryEquivTuple.symm a) { re := a 0, imI := a 1, imJ := a 2, imK := a 3 }","decl":"/-- `QuaternionAlgebra.linearEquivTuple` as a `LinearIsometryEquiv`. -/\n@[simps apply symm_apply]\nnoncomputable def linearIsometryEquivTuple : ℍ ≃ₗᵢ[ℝ] EuclideanSpace ℝ (Fin 4) :=\n  { (QuaternionAlgebra.linearEquivTuple (-1 : ℝ) (0 : ℝ) (-1 : ℝ)).trans\n      (WithLp.linearEquiv 2 ℝ (Fin 4 → ℝ)).symm with\n    toFun := fun a => !₂[a.1, a.2, a.3, a.4]\n    invFun := fun a => ⟨a 0, a 1, a 2, a 3⟩\n    norm_map' := norm_piLp_equiv_symm_equivTuple }\n\n"}
{"name":"Quaternion.continuous_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous Quaternion.coe","decl":"@[continuity]\ntheorem continuous_coe : Continuous (coe : ℝ → ℍ) :=\n  continuous_algebraMap ℝ ℍ\n\n"}
{"name":"Quaternion.continuous_normSq","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous ⇑Quaternion.normSq","decl":"@[continuity]\ntheorem continuous_normSq : Continuous (normSq : ℍ → ℝ) := by\n  simpa [← normSq_eq_norm_mul_self] using\n    (continuous_norm.mul continuous_norm : Continuous fun q : ℍ => ‖q‖ * ‖q‖)\n\n"}
{"name":"Quaternion.continuous_re","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous fun q => q.re","decl":"@[continuity]\ntheorem continuous_re : Continuous fun q : ℍ => q.re :=\n  (continuous_apply 0).comp linearIsometryEquivTuple.continuous\n\n"}
{"name":"Quaternion.continuous_imI","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous fun q => q.imI","decl":"@[continuity]\ntheorem continuous_imI : Continuous fun q : ℍ => q.imI :=\n  (continuous_apply 1).comp linearIsometryEquivTuple.continuous\n\n"}
{"name":"Quaternion.continuous_imJ","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous fun q => q.imJ","decl":"@[continuity]\ntheorem continuous_imJ : Continuous fun q : ℍ => q.imJ :=\n  (continuous_apply 2).comp linearIsometryEquivTuple.continuous\n\n"}
{"name":"Quaternion.continuous_imK","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous fun q => q.imK","decl":"@[continuity]\ntheorem continuous_imK : Continuous fun q : ℍ => q.imK :=\n  (continuous_apply 3).comp linearIsometryEquivTuple.continuous\n\n"}
{"name":"Quaternion.continuous_im","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ Continuous fun q => q.im","decl":"@[continuity]\ntheorem continuous_im : Continuous fun q : ℍ => q.im := by\n  simpa only [← sub_self_re] using continuous_id.sub (continuous_coe.comp continuous_re)\n\n"}
{"name":"Quaternion.instCompleteSpaceReal","module":"Mathlib.Analysis.Quaternion","initialProofState":"⊢ CompleteSpace (Quaternion Real)","decl":"instance : CompleteSpace ℍ :=\n  haveI : IsUniformEmbedding linearIsometryEquivTuple.toLinearEquiv.toEquiv.symm :=\n    linearIsometryEquivTuple.toContinuousLinearEquiv.symm.isUniformEmbedding\n  (completeSpace_congr this).1 inferInstance\n\n"}
{"name":"Quaternion.hasSum_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"α : Type u_1\nf : α → Real\nr : Real\n⊢ Iff (HasSum (fun a => ↑(f a)) ↑r) (HasSum f r)","decl":"@[simp, norm_cast]\ntheorem hasSum_coe {f : α → ℝ} {r : ℝ} : HasSum (fun a => (f a : ℍ)) (↑r : ℍ) ↔ HasSum f r :=\n  ⟨fun h => by\n    simpa only using\n    h.map (show ℍ →ₗ[ℝ] ℝ from QuaternionAlgebra.reₗ _ _ _) continuous_re,\n    fun h => by simpa only using h.map (algebraMap ℝ ℍ) (continuous_algebraMap _ _)⟩\n\n"}
{"name":"Quaternion.summable_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"α : Type u_1\nf : α → Real\n⊢ Iff (Summable fun a => ↑(f a)) (Summable f)","decl":"@[simp, norm_cast]\ntheorem summable_coe {f : α → ℝ} : (Summable fun a => (f a : ℍ)) ↔ Summable f := by\n  simpa only using\n    Summable.map_iff_of_leftInverse (algebraMap ℝ ℍ) (show ℍ →ₗ[ℝ] ℝ from\n      QuaternionAlgebra.reₗ _ _ _)\n      (continuous_algebraMap _ _) continuous_re coe_re\n\n"}
{"name":"Quaternion.tsum_coe","module":"Mathlib.Analysis.Quaternion","initialProofState":"α : Type u_1\nf : α → Real\n⊢ Eq (tsum fun a => ↑(f a)) ↑(tsum fun a => f a)","decl":"@[norm_cast]\ntheorem tsum_coe (f : α → ℝ) : (∑' a, (f a : ℍ)) = ↑(∑' a, f a) := by\n  by_cases hf : Summable f\n  · exact (hasSum_coe.mpr hf.hasSum).tsum_eq\n  · simp [tsum_eq_zero_of_not_summable hf, tsum_eq_zero_of_not_summable (summable_coe.not.mpr hf)]\n\n"}
