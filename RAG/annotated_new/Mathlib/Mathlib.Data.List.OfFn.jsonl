{"name":"List.get_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\ni : Fin (List.ofFn f).length\n⊢ Eq ((List.ofFn f).get i) (f (Fin.cast ⋯ i))","decl":"theorem get_ofFn {n} (f : Fin n → α) (i) : get (ofFn f) i = f (Fin.cast (by simp) i) := by\n  simp; congr\n\n"}
{"name":"List.get?_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\ni : Nat\n⊢ Eq ((List.ofFn f).get? i) (List.ofFnNthVal f i)","decl":"/-- The `n`th element of a list -/\ntheorem get?_ofFn {n} (f : Fin n → α) (i) : get? (ofFn f) i = ofFnNthVal f i := by\n  simp [ofFnNthVal]\n\n"}
{"name":"List.map_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nβ : Type u_1\nn : Nat\nf : Fin n → α\ng : α → β\n⊢ Eq (List.map g (List.ofFn f)) (List.ofFn (Function.comp g f))","decl":"@[simp]\ntheorem map_ofFn {β : Type*} {n : ℕ} (f : Fin n → α) (g : α → β) :\n    map g (ofFn f) = ofFn (g ∘ f) :=\n  ext_get (by simp) fun i h h' => by simp\n\n-- Porting note: we don't have Array' in mathlib4\n-- /-- Arrays converted to lists are the same as `of_fn` on the indexing function of the array. -/\n-- theorem array_eq_of_fn {n} (a : Array' n α) : a.toList = ofFn a.read :=\n--   by\n--   suffices ∀ {m h l}, DArray.revIterateAux a (fun i => cons) m h l =\n--      ofFnAux (DArray.read a) m h l\n--     from this\n--   intros; induction' m with m IH generalizing l; · rfl\n--   simp only [DArray.revIterateAux, of_fn_aux, IH]\n\n"}
{"name":"List.ofFn_congr","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm n : Nat\nh : Eq m n\nf : Fin m → α\n⊢ Eq (List.ofFn f) (List.ofFn fun i => f (Fin.cast ⋯ i))","decl":"@[congr]\ntheorem ofFn_congr {m n : ℕ} (h : m = n) (f : Fin m → α) :\n    ofFn f = ofFn fun i : Fin n => f (Fin.cast h.symm i) := by\n  subst h\n  simp_rw [Fin.cast_refl, id]\n\n"}
{"name":"List.ofFn_succ'","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n.succ → α\n⊢ Eq (List.ofFn f) ((List.ofFn fun i => f i.castSucc).concat (f (Fin.last n)))","decl":"theorem ofFn_succ' {n} (f : Fin (succ n) → α) :\n    ofFn f = (ofFn fun i => f (Fin.castSucc i)).concat (f (Fin.last _)) := by\n  induction' n with n IH\n  · rw [ofFn_zero, concat_nil, ofFn_succ, ofFn_zero]\n    rfl\n  · rw [ofFn_succ, IH, ofFn_succ, concat_cons, Fin.castSucc_zero]\n    congr\n\n"}
{"name":"List.ofFn_add","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm n : Nat\nf : Fin (HAdd.hAdd m n) → α\n⊢ Eq (List.ofFn f) (HAppend.hAppend (List.ofFn fun i => f (Fin.castAdd n i)) (List.ofFn fun j => f (Fin.natAdd m j)))","decl":"/-- Note this matches the convention of `List.ofFn_succ'`, putting the `Fin m` elements first. -/\ntheorem ofFn_add {m n} (f : Fin (m + n) → α) :\n    List.ofFn f =\n      (List.ofFn fun i => f (Fin.castAdd n i)) ++ List.ofFn fun j => f (Fin.natAdd m j) := by\n  induction' n with n IH\n  · rw [ofFn_zero, append_nil, Fin.castAdd_zero, Fin.cast_refl]\n    rfl\n  · rw [ofFn_succ', ofFn_succ', IH, append_concat]\n    rfl\n\n"}
{"name":"List.ofFn_fin_append","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm n : Nat\na : Fin m → α\nb : Fin n → α\n⊢ Eq (List.ofFn (Fin.append a b)) (HAppend.hAppend (List.ofFn a) (List.ofFn b))","decl":"@[simp]\ntheorem ofFn_fin_append {m n} (a : Fin m → α) (b : Fin n → α) :\n    List.ofFn (Fin.append a b) = List.ofFn a ++ List.ofFn b := by\n  simp_rw [ofFn_add, Fin.append_left, Fin.append_right]\n\n"}
{"name":"List.ofFn_mul","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm n : Nat\nf : Fin (HMul.hMul m n) → α\n⊢ Eq (List.ofFn f) (List.ofFn fun i => List.ofFn fun j => f ⟨HAdd.hAdd (HMul.hMul (↑i) n) ↑j, ⋯⟩).flatten","decl":"/-- This breaks a list of `m*n` items into `m` groups each containing `n` elements. -/\ntheorem ofFn_mul {m n} (f : Fin (m * n) → α) :\n    List.ofFn f = List.flatten (List.ofFn fun i : Fin m => List.ofFn fun j : Fin n => f ⟨i * n + j,\n    calc\n      ↑i * n + j < (i + 1) * n :=\n        (Nat.add_lt_add_left j.prop _).trans_eq (by rw [Nat.add_mul, Nat.one_mul])\n      _ ≤ _ := Nat.mul_le_mul_right _ i.prop⟩) := by\n  induction' m with m IH\n  · simp [ofFn_zero, Nat.zero_mul, ofFn_zero, flatten]\n  · simp_rw [ofFn_succ', succ_mul]\n    simp [flatten_concat, ofFn_add, IH]\n    rfl\n\n"}
{"name":"List.ofFn_mul'","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm n : Nat\nf : Fin (HMul.hMul m n) → α\n⊢ Eq (List.ofFn f) (List.ofFn fun i => List.ofFn fun j => f ⟨HAdd.hAdd (HMul.hMul m ↑i) ↑j, ⋯⟩).flatten","decl":"/-- This breaks a list of `m*n` items into `n` groups each containing `m` elements. -/\ntheorem ofFn_mul' {m n} (f : Fin (m * n) → α) :\n    List.ofFn f = List.flatten (List.ofFn fun i : Fin n => List.ofFn fun j : Fin m => f ⟨m * i + j,\n    calc\n      m * i + j < m * (i + 1) :=\n        (Nat.add_lt_add_left j.prop _).trans_eq (by rw [Nat.mul_add, Nat.mul_one])\n      _ ≤ _ := Nat.mul_le_mul_left _ i.prop⟩) := by simp_rw [m.mul_comm, ofFn_mul, Fin.cast_mk]\n\n"}
{"name":"List.ofFn_get","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.ofFn l.get) l","decl":"@[simp]\ntheorem ofFn_get : ∀ l : List α, (ofFn (get l)) = l\n  | [] => by rw [ofFn_zero]\n  | a :: l => by\n    rw [ofFn_succ]\n    congr\n    exact ofFn_get l\n\n"}
{"name":"List.ofFn_getElem","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.ofFn fun i => GetElem.getElem l ↑i ⋯) l","decl":"@[simp]\ntheorem ofFn_getElem : ∀ l : List α, (ofFn (fun i : Fin l.length => l[(i : Nat)])) = l\n  | [] => by rw [ofFn_zero]\n  | a :: l => by\n    rw [ofFn_succ]\n    congr\n    exact ofFn_get l\n\n"}
{"name":"List.ofFn_getElem_eq_map","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nβ : Type u_1\nl : List α\nf : α → β\n⊢ Eq (List.ofFn fun i => f (GetElem.getElem l ↑i ⋯)) (List.map f l)","decl":"@[simp]\ntheorem ofFn_getElem_eq_map {β : Type*} (l : List α) (f : α → β) :\n    ofFn (fun i : Fin l.length => f <| l[(i : Nat)]) = l.map f := by\n  rw [← Function.comp_def, ← map_ofFn, ofFn_getElem]\n\n-- not registered as a simp lemma, as otherwise it fires before `forall_mem_ofFn_iff` which\n-- is much more useful\n"}
{"name":"List.mem_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\na : α\n⊢ Iff (Membership.mem (List.ofFn f) a) (Membership.mem (Set.range f) a)","decl":"theorem mem_ofFn {n} (f : Fin n → α) (a : α) : a ∈ ofFn f ↔ a ∈ Set.range f := by\n  simp only [mem_iff_get, Set.mem_range, get_ofFn]\n  exact ⟨fun ⟨i, hi⟩ => ⟨Fin.cast (by simp) i, hi⟩, fun ⟨i, hi⟩ => ⟨Fin.cast (by simp) i, hi⟩⟩\n\n"}
{"name":"List.forall_mem_ofFn_iff","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\nP : α → Prop\n⊢ Iff (∀ (i : α), Membership.mem (List.ofFn f) i → P i) (∀ (j : Fin n), P (f j))","decl":"@[simp]\ntheorem forall_mem_ofFn_iff {n : ℕ} {f : Fin n → α} {P : α → Prop} :\n    (∀ i ∈ ofFn f, P i) ↔ ∀ j : Fin n, P (f j) := by simp only [mem_ofFn, Set.forall_mem_range]\n\n"}
{"name":"List.ofFn_const","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nc : α\n⊢ Eq (List.ofFn fun x => c) (List.replicate n c)","decl":"@[simp]\ntheorem ofFn_const : ∀ (n : ℕ) (c : α), (ofFn fun _ : Fin n => c) = replicate n c\n  | 0, c => by rw [ofFn_zero, replicate_zero]\n  | n+1, c => by rw [replicate, ← ofFn_const n]; simp\n\n"}
{"name":"List.ofFn_fin_repeat","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm : Nat\na : Fin m → α\nn : Nat\n⊢ Eq (List.ofFn (Fin.repeat n a)) (List.replicate n (List.ofFn a)).flatten","decl":"@[simp]\ntheorem ofFn_fin_repeat {m} (a : Fin m → α) (n : ℕ) :\n    List.ofFn (Fin.repeat n a) = (List.replicate n (List.ofFn a)).flatten := by\n  simp_rw [ofFn_mul, ← ofFn_const, Fin.repeat, Fin.modNat, Nat.add_comm,\n    Nat.add_mul_mod_self_right, Nat.mod_eq_of_lt (Fin.is_lt _)]\n\n"}
{"name":"List.pairwise_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nR : α → α → Prop\nn : Nat\nf : Fin n → α\n⊢ Iff (List.Pairwise R (List.ofFn f)) (∀ ⦃i j : Fin n⦄, LT.lt i j → R (f i) (f j))","decl":"@[simp]\ntheorem pairwise_ofFn {R : α → α → Prop} {n} {f : Fin n → α} :\n    (ofFn f).Pairwise R ↔ ∀ ⦃i j⦄, i < j → R (f i) (f j) := by\n  simp only [pairwise_iff_getElem, length_ofFn, List.getElem_ofFn,\n    (Fin.rightInverse_cast (length_ofFn f)).surjective.forall, Fin.forall_iff, Fin.cast_mk,\n    Fin.mk_lt_mk, forall_comm (α := (_ : Prop)) (β := ℕ)]\n\n"}
{"name":"List.getLast_ofFn_succ","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n.succ → α\n⊢ Eq ((List.ofFn f).getLast ⋯) (f (Fin.last n))","decl":"lemma getLast_ofFn_succ {n : ℕ} (f : Fin n.succ → α) :\n    (ofFn f).getLast (mt ofFn_eq_nil_iff.1 (Nat.succ_ne_zero _)) = f (Fin.last _) :=\n  getLast_ofFn f _\n\n"}
{"name":"List.last_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\nh : Ne (List.ofFn f) List.nil\nhn : optParam (LT.lt (HSub.hSub n 1) n) ⋯\n⊢ Eq ((List.ofFn f).getLast h) (f ⟨HSub.hSub n 1, hn⟩)","decl":"@[deprecated getLast_ofFn (since := \"2024-11-06\")]\ntheorem last_ofFn {n : ℕ} (f : Fin n → α) (h : ofFn f ≠ [])\n    (hn : n - 1 < n := Nat.pred_lt <| ofFn_eq_nil_iff.not.mp h) :\n    getLast (ofFn f) h = f ⟨n - 1, hn⟩ := by simp [getLast_eq_getElem]\n\n"}
{"name":"List.last_ofFn_succ","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n.succ → α\nh : optParam (Ne (List.ofFn f) List.nil) ⋯\n⊢ Eq ((List.ofFn f).getLast h) (f (Fin.last n))","decl":"@[deprecated getLast_ofFn_succ (since := \"2024-11-06\")]\ntheorem last_ofFn_succ {n : ℕ} (f : Fin n.succ → α)\n    (h : ofFn f ≠ [] := mt ofFn_eq_nil_iff.mp (Nat.succ_ne_zero _)) :\n    getLast (ofFn f) h = f (Fin.last _) :=\n  getLast_ofFn_succ _\n\n"}
{"name":"List.ofFn_cons","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\na : α\nf : Fin n → α\n⊢ Eq (List.ofFn (Fin.cons a f)) (List.cons a (List.ofFn f))","decl":"lemma ofFn_cons {n} (a : α) (f : Fin n → α) : ofFn (Fin.cons a f) = a :: ofFn f := by\n  rw [ofFn_succ]\n  rfl\n\n"}
{"name":"List.find?_ofFn_eq_some","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\np : α → Bool\nb : α\n⊢ Iff (Eq (List.find? p (List.ofFn f)) (Option.some b)) (And (Eq (p b) Bool.true) (Exists fun i => And (Eq (f i) b) (∀ (j : Fin n), LT.lt j i → Not (Eq (p (f j)) Bool.true))))","decl":"lemma find?_ofFn_eq_some {n} {f : Fin n → α} {p : α → Bool} {b : α} :\n    (ofFn f).find? p = some b ↔ p b = true ∧ ∃ i, f i = b ∧ ∀ j < i, ¬(p (f j) = true) := by\n  rw [find?_eq_some_iff_getElem]\n  exact ⟨fun ⟨hpb, i, hi, hfb, h⟩ ↦\n      ⟨hpb, ⟨⟨i, (length_ofFn f) ▸ hi⟩, by simpa using hfb, fun j hj ↦ by simpa using h j hj⟩⟩,\n    fun ⟨hpb, i, hfb, h⟩ ↦\n      ⟨hpb, ⟨i, (length_ofFn f).symm ▸ i.isLt, by simpa using hfb,\n        fun j hj ↦ by simpa using h ⟨j, by omega⟩ (by simpa using hj)⟩⟩⟩\n\n"}
{"name":"List.find?_ofFn_eq_some_of_injective","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf : Fin n → α\np : α → Bool\ni : Fin n\nh : Function.Injective f\n⊢ Iff (Eq (List.find? p (List.ofFn f)) (Option.some (f i))) (And (Eq (p (f i)) Bool.true) (∀ (j : Fin n), LT.lt j i → Not (Eq (p (f j)) Bool.true)))","decl":"lemma find?_ofFn_eq_some_of_injective {n} {f : Fin n → α} {p : α → Bool} {i : Fin n}\n    (h : Function.Injective f) :\n    (ofFn f).find? p = some (f i) ↔ p (f i) = true ∧ ∀ j < i, ¬(p (f j) = true) := by\n  simp only [find?_ofFn_eq_some, h.eq_iff, Bool.not_eq_true, exists_eq_left]\n\n"}
{"name":"List.equivSigmaTuple_symm_apply","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nf : Sigma fun n => Fin n → α\n⊢ Eq (List.equivSigmaTuple.symm f) (List.ofFn f.snd)","decl":"/-- Lists are equivalent to the sigma type of tuples of a given length. -/\n@[simps]\ndef equivSigmaTuple : List α ≃ Σn, Fin n → α where\n  toFun l := ⟨l.length, l.get⟩\n  invFun f := List.ofFn f.2\n  left_inv := List.ofFn_get\n  right_inv := fun ⟨_, f⟩ =>\n    Fin.sigma_eq_of_eq_comp_cast (length_ofFn _) <| funext fun i => get_ofFn f i\n\n"}
{"name":"List.equivSigmaTuple_apply_fst","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nl : List α\n⊢ Eq (List.equivSigmaTuple l).fst l.length","decl":"/-- Lists are equivalent to the sigma type of tuples of a given length. -/\n@[simps]\ndef equivSigmaTuple : List α ≃ Σn, Fin n → α where\n  toFun l := ⟨l.length, l.get⟩\n  invFun f := List.ofFn f.2\n  left_inv := List.ofFn_get\n  right_inv := fun ⟨_, f⟩ =>\n    Fin.sigma_eq_of_eq_comp_cast (length_ofFn _) <| funext fun i => get_ofFn f i\n\n"}
{"name":"List.equivSigmaTuple_apply_snd","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nl : List α\na✝ : Fin l.length\n⊢ Eq ((List.equivSigmaTuple l).snd a✝) (l.get a✝)","decl":"/-- Lists are equivalent to the sigma type of tuples of a given length. -/\n@[simps]\ndef equivSigmaTuple : List α ≃ Σn, Fin n → α where\n  toFun l := ⟨l.length, l.get⟩\n  invFun f := List.ofFn f.2\n  left_inv := List.ofFn_get\n  right_inv := fun ⟨_, f⟩ =>\n    Fin.sigma_eq_of_eq_comp_cast (length_ofFn _) <| funext fun i => get_ofFn f i\n\n"}
{"name":"List.ofFnRec_ofFn","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nC : List α → Sort u_1\nh : (n : Nat) → (f : Fin n → α) → C (List.ofFn f)\nn : Nat\nf : Fin n → α\n⊢ Eq (List.ofFnRec h (List.ofFn f)) (h n f)","decl":"@[simp]\ntheorem ofFnRec_ofFn {C : List α → Sort*} (h : ∀ (n) (f : Fin n → α), C (List.ofFn f)) {n : ℕ}\n    (f : Fin n → α) : @ofFnRec _ C h (List.ofFn f) = h _ f :=\n  equivSigmaTuple.rightInverse_symm.cast_eq (fun s => h s.1 s.2) ⟨n, f⟩\n\n"}
{"name":"List.exists_iff_exists_tuple","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nP : List α → Prop\n⊢ Iff (Exists fun l => P l) (Exists fun n => Exists fun f => P (List.ofFn f))","decl":"theorem exists_iff_exists_tuple {P : List α → Prop} :\n    (∃ l : List α, P l) ↔ ∃ (n : _) (f : Fin n → α), P (List.ofFn f) :=\n  equivSigmaTuple.symm.surjective.exists.trans Sigma.exists\n\n"}
{"name":"List.forall_iff_forall_tuple","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nP : List α → Prop\n⊢ Iff (∀ (l : List α), P l) (∀ (n : Nat) (f : Fin n → α), P (List.ofFn f))","decl":"theorem forall_iff_forall_tuple {P : List α → Prop} :\n    (∀ l : List α, P l) ↔ ∀ (n) (f : Fin n → α), P (List.ofFn f) :=\n  equivSigmaTuple.symm.surjective.forall.trans Sigma.forall\n\n"}
{"name":"List.ofFn_inj'","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nm n : Nat\nf : Fin m → α\ng : Fin n → α\n⊢ Iff (Eq (List.ofFn f) (List.ofFn g)) (Eq ⟨m, f⟩ ⟨n, g⟩)","decl":"/-- `Fin.sigma_eq_iff_eq_comp_cast` may be useful to work with the RHS of this expression. -/\ntheorem ofFn_inj' {m n : ℕ} {f : Fin m → α} {g : Fin n → α} :\n    ofFn f = ofFn g ↔ (⟨m, f⟩ : Σn, Fin n → α) = ⟨n, g⟩ :=\n  Iff.symm <| equivSigmaTuple.symm.injective.eq_iff.symm\n\n"}
{"name":"List.ofFn_injective","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\n⊢ Function.Injective List.ofFn","decl":"/-- Note we can only state this when the two functions are indexed by defeq `n`. -/\ntheorem ofFn_injective {n : ℕ} : Function.Injective (ofFn : (Fin n → α) → List α) := fun f g h =>\n  eq_of_heq <| by rw [ofFn_inj'] at h; cases h; rfl\n\n"}
{"name":"List.ofFn_inj","module":"Mathlib.Data.List.OfFn","initialProofState":"α : Type u\nn : Nat\nf g : Fin n → α\n⊢ Iff (Eq (List.ofFn f) (List.ofFn g)) (Eq f g)","decl":"/-- A special case of `List.ofFn_inj` for when the two functions are indexed by defeq `n`. -/\n@[simp]\ntheorem ofFn_inj {n : ℕ} {f g : Fin n → α} : ofFn f = ofFn g ↔ f = g :=\n  ofFn_injective.eq_iff\n\n"}
