{"name":"NonUnitalSubsemiring.toSubsemigroup_strictMono","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ StrictMono NonUnitalSubsemiring.toSubsemigroup","decl":"@[mono]\ntheorem toSubsemigroup_strictMono :\n    StrictMono (toSubsemigroup : NonUnitalSubsemiring R → Subsemigroup R) := fun _ _ => id\n\n"}
{"name":"NonUnitalSubsemiring.toSubsemigroup_mono","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Monotone NonUnitalSubsemiring.toSubsemigroup","decl":"@[mono]\ntheorem toSubsemigroup_mono : Monotone (toSubsemigroup : NonUnitalSubsemiring R → Subsemigroup R) :=\n  toSubsemigroup_strictMono.monotone\n\n"}
{"name":"NonUnitalSubsemiring.toAddSubmonoid_strictMono","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ StrictMono NonUnitalSubsemiring.toAddSubmonoid","decl":"@[mono]\ntheorem toAddSubmonoid_strictMono :\n    StrictMono (toAddSubmonoid : NonUnitalSubsemiring R → AddSubmonoid R) := fun _ _ => id\n\n"}
{"name":"NonUnitalSubsemiring.toAddSubmonoid_mono","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Monotone NonUnitalSubsemiring.toAddSubmonoid","decl":"@[mono]\ntheorem toAddSubmonoid_mono : Monotone (toAddSubmonoid : NonUnitalSubsemiring R → AddSubmonoid R) :=\n  toAddSubmonoid_strictMono.monotone\n\n"}
{"name":"NonUnitalSubsemiring.topEquiv_symm_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nx : R\n⊢ Eq (↑(NonUnitalSubsemiring.topEquiv.symm x)) x","decl":"/-- The ring equiv between the top element of `NonUnitalSubsemiring R` and `R`. -/\n@[simps!]\ndef topEquiv : (⊤ : NonUnitalSubsemiring R) ≃+* R :=\n  { Subsemigroup.topEquiv, AddSubmonoid.topEquiv with }\n\n"}
{"name":"NonUnitalSubsemiring.topEquiv_apply","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nx : Subtype fun x => Membership.mem Top.top x\n⊢ Eq (NonUnitalSubsemiring.topEquiv x) ↑x","decl":"/-- The ring equiv between the top element of `NonUnitalSubsemiring R` and `R`. -/\n@[simps!]\ndef topEquiv : (⊤ : NonUnitalSubsemiring R) ≃+* R :=\n  { Subsemigroup.topEquiv, AddSubmonoid.topEquiv with }\n\n"}
{"name":"NonUnitalSubsemiring.coe_comap","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ns : NonUnitalSubsemiring S\nf : F\n⊢ Eq (↑(NonUnitalSubsemiring.comap f s)) (Set.preimage ⇑f ↑s)","decl":"@[simp]\ntheorem coe_comap (s : NonUnitalSubsemiring S) (f : F) : (s.comap f : Set R) = f ⁻¹' s :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.mem_comap","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ns : NonUnitalSubsemiring S\nf : F\nx : R\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.comap f s) x) (Membership.mem s (f x))","decl":"@[simp]\ntheorem mem_comap {s : NonUnitalSubsemiring S} {f : F} {x : R} : x ∈ s.comap f ↔ f x ∈ s :=\n  Iff.rfl\n\n-- this has some nasty coercions, how to deal with it?\n"}
{"name":"NonUnitalSubsemiring.comap_comap","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝⁶ : NonUnitalNonAssocSemiring R\ninst✝⁵ : NonUnitalNonAssocSemiring S\ninst✝⁴ : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst✝³ : FunLike F R S\ninst✝² : NonUnitalRingHomClass F R S\ninst✝¹ : FunLike G S T\ninst✝ : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring T\ng : G\nf : F\n⊢ Eq (NonUnitalSubsemiring.comap f (NonUnitalSubsemiring.comap g s)) (NonUnitalSubsemiring.comap ((↑g).comp ↑f) s)","decl":"theorem comap_comap (s : NonUnitalSubsemiring T) (g : G) (f : F) :\n    ((s.comap g : NonUnitalSubsemiring S).comap f : NonUnitalSubsemiring R) =\n      s.comap ((g : S →ₙ+* T).comp (f : R →ₙ+* S)) :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.coe_map","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\ns : NonUnitalSubsemiring R\n⊢ Eq (↑(NonUnitalSubsemiring.map f s)) (Set.image ⇑f ↑s)","decl":"@[simp]\ntheorem coe_map (f : F) (s : NonUnitalSubsemiring R) : (s.map f : Set S) = f '' s :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.mem_map","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\ns : NonUnitalSubsemiring R\ny : S\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.map f s) y) (Exists fun x => And (Membership.mem s x) (Eq (f x) y))","decl":"@[simp]\ntheorem mem_map {f : F} {s : NonUnitalSubsemiring R} {y : S} : y ∈ s.map f ↔ ∃ x ∈ s, f x = y :=\n  Iff.rfl\n\n"}
{"name":"NonUnitalSubsemiring.map_id","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : NonUnitalSubsemiring R\n⊢ Eq (NonUnitalSubsemiring.map (NonUnitalRingHom.id R) s) s","decl":"@[simp]\ntheorem map_id : s.map (NonUnitalRingHom.id R) = s :=\n  SetLike.coe_injective <| Set.image_id _\n\n-- unavoidable coercions?\n"}
{"name":"NonUnitalSubsemiring.map_map","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝⁶ : NonUnitalNonAssocSemiring R\ninst✝⁵ : NonUnitalNonAssocSemiring S\ninst✝⁴ : NonUnitalNonAssocSemiring T\nF : Type u_1\nG : Type u_2\ninst✝³ : FunLike F R S\ninst✝² : NonUnitalRingHomClass F R S\ninst✝¹ : FunLike G S T\ninst✝ : NonUnitalRingHomClass G S T\ns : NonUnitalSubsemiring R\ng : G\nf : F\n⊢ Eq (NonUnitalSubsemiring.map (↑g) (NonUnitalSubsemiring.map (↑f) s)) (NonUnitalSubsemiring.map ((↑g).comp ↑f) s)","decl":"theorem map_map (g : G) (f : F) :\n    (s.map (f : R →ₙ+* S)).map (g : S →ₙ+* T) = s.map ((g : S →ₙ+* T).comp (f : R →ₙ+* S)) :=\n  SetLike.coe_injective <| Set.image_image _ _ _\n\n"}
{"name":"NonUnitalSubsemiring.map_le_iff_le_comap","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\ns : NonUnitalSubsemiring R\nt : NonUnitalSubsemiring S\n⊢ Iff (LE.le (NonUnitalSubsemiring.map f s) t) (LE.le s (NonUnitalSubsemiring.comap f t))","decl":"theorem map_le_iff_le_comap {f : F} {s : NonUnitalSubsemiring R} {t : NonUnitalSubsemiring S} :\n    s.map f ≤ t ↔ s ≤ t.comap f :=\n  Set.image_subset_iff\n\n"}
{"name":"NonUnitalSubsemiring.gc_map_comap","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ GaloisConnection (NonUnitalSubsemiring.map f) (NonUnitalSubsemiring.comap f)","decl":"theorem gc_map_comap (f : F) :\n    @GaloisConnection (NonUnitalSubsemiring R) (NonUnitalSubsemiring S) _ _ (map f) (comap f) :=\n  fun _ _ => map_le_iff_le_comap\n\n"}
{"name":"NonUnitalSubsemiring.coe_equivMapOfInjective_apply","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ns : NonUnitalSubsemiring R\nf : F\nhf : Function.Injective ⇑f\nx : Subtype fun x => Membership.mem s x\n⊢ Eq (↑((s.equivMapOfInjective f hf) x)) (f ↑x)","decl":"@[simp]\ntheorem coe_equivMapOfInjective_apply (f : F) (hf : Function.Injective f) (x : s) :\n    (equivMapOfInjective s f hf x : S) = f x :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.coe_srange","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Eq (↑(NonUnitalRingHom.srange f)) (Set.range ⇑f)","decl":"@[simp]\ntheorem coe_srange : (srange f : Set S) = Set.range f :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.mem_srange","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\ny : S\n⊢ Iff (Membership.mem (NonUnitalRingHom.srange f) y) (Exists fun x => Eq (f x) y)","decl":"@[simp]\ntheorem mem_srange {f : F} {y : S} : y ∈ srange f ↔ ∃ x, f x = y :=\n  Iff.rfl\n\n"}
{"name":"NonUnitalRingHom.srange_eq_map","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Eq (NonUnitalRingHom.srange f) (NonUnitalSubsemiring.map f Top.top)","decl":"theorem srange_eq_map : srange f = (⊤ : NonUnitalSubsemiring R).map f := by\n  ext\n  simp\n\n"}
{"name":"NonUnitalRingHom.mem_srange_self","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nx : R\n⊢ Membership.mem (NonUnitalRingHom.srange f) (f x)","decl":"theorem mem_srange_self (f : F) (x : R) : f x ∈ srange f :=\n  mem_srange.mpr ⟨x, rfl⟩\n\n"}
{"name":"NonUnitalRingHom.map_srange","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\nT : Type w\ninst✝² : NonUnitalNonAssocSemiring R\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalNonAssocSemiring T\ng : NonUnitalRingHom S T\nf : NonUnitalRingHom R S\n⊢ Eq (NonUnitalSubsemiring.map g (NonUnitalRingHom.srange f)) (NonUnitalRingHom.srange (g.comp f))","decl":"theorem map_srange (g : S →ₙ+* T) (f : R →ₙ+* S) : map g (srange f) = srange (g.comp f) := by\n  simpa only [srange_eq_map] using (⊤ : NonUnitalSubsemiring R).map_map g f\n\n"}
{"name":"NonUnitalRingHom.finite_srange","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : NonUnitalNonAssocSemiring R\ninst✝³ : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalRingHomClass F R S\ninst✝ : Finite R\nf : F\n⊢ Finite (Subtype fun x => Membership.mem (NonUnitalRingHom.srange f) x)","decl":"/-- The range of a morphism of non-unital semirings is finite if the domain is a finite. -/\ninstance finite_srange [Finite R] (f : F) : Finite (srange f : NonUnitalSubsemiring S) :=\n  (Set.finite_range f).to_subtype\n\n"}
{"name":"NonUnitalSubsemiring.coe_sInf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nS : Set (NonUnitalSubsemiring R)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp, norm_cast]\ntheorem coe_sInf (S : Set (NonUnitalSubsemiring R)) :\n    ((sInf S : NonUnitalSubsemiring R) : Set R) = ⋂ s ∈ S, ↑s :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.mem_sInf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nS : Set (NonUnitalSubsemiring R)\nx : R\n⊢ Iff (Membership.mem (InfSet.sInf S) x) (∀ (p : NonUnitalSubsemiring R), Membership.mem S p → Membership.mem p x)","decl":"theorem mem_sInf {S : Set (NonUnitalSubsemiring R)} {x : R} : x ∈ sInf S ↔ ∀ p ∈ S, x ∈ p :=\n  Set.mem_iInter₂\n\n"}
{"name":"NonUnitalSubsemiring.coe_iInf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_1\nS : ι → NonUnitalSubsemiring R\n⊢ Eq (↑(iInf fun i => S i)) (Set.iInter fun i => ↑(S i))","decl":"@[simp, norm_cast]\ntheorem coe_iInf {ι : Sort*} {S : ι → NonUnitalSubsemiring R} :\n    (↑(⨅ i, S i) : Set R) = ⋂ i, S i := by\n  simp only [iInf, coe_sInf, Set.biInter_range]\n\n"}
{"name":"NonUnitalSubsemiring.mem_iInf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_1\nS : ι → NonUnitalSubsemiring R\nx : R\n⊢ Iff (Membership.mem (iInf fun i => S i) x) (∀ (i : ι), Membership.mem (S i) x)","decl":"theorem mem_iInf {ι : Sort*} {S : ι → NonUnitalSubsemiring R} {x : R} :\n    (x ∈ ⨅ i, S i) ↔ ∀ i, x ∈ S i := by\n  simp only [iInf, mem_sInf, Set.forall_mem_range]\n\n"}
{"name":"NonUnitalSubsemiring.sInf_toSubsemigroup","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set (NonUnitalSubsemiring R)\n⊢ Eq (InfSet.sInf s).toSubsemigroup (iInf fun t => iInf fun h => t.toSubsemigroup)","decl":"@[simp]\ntheorem sInf_toSubsemigroup (s : Set (NonUnitalSubsemiring R)) :\n    (sInf s).toSubsemigroup = ⨅ t ∈ s, NonUnitalSubsemiring.toSubsemigroup t :=\n  mk'_toSubsemigroup _ _\n\n"}
{"name":"NonUnitalSubsemiring.sInf_toAddSubmonoid","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set (NonUnitalSubsemiring R)\n⊢ Eq (InfSet.sInf s).toAddSubmonoid (iInf fun t => iInf fun h => t.toAddSubmonoid)","decl":"@[simp]\ntheorem sInf_toAddSubmonoid (s : Set (NonUnitalSubsemiring R)) :\n    (sInf s).toAddSubmonoid = ⨅ t ∈ s, NonUnitalSubsemiring.toAddSubmonoid t :=\n  mk'_toAddSubmonoid _ _\n\n"}
{"name":"NonUnitalSubsemiring.eq_top_iff'","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nA : NonUnitalSubsemiring R\n⊢ Iff (Eq A Top.top) (∀ (x : R), Membership.mem A x)","decl":"theorem eq_top_iff' (A : NonUnitalSubsemiring R) : A = ⊤ ↔ ∀ x : R, x ∈ A :=\n  eq_top_iff.trans ⟨fun h m => h <| mem_top m, fun h m _ => h m⟩\n\n"}
{"name":"NonUnitalSubsemiring.coe_center","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (↑(NonUnitalSubsemiring.center R)) (Set.center R)","decl":"theorem coe_center : ↑(center R) = Set.center R :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.center_toSubsemigroup","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (NonUnitalSubsemiring.center R).toSubsemigroup (Subsemigroup.center R)","decl":"@[simp]\ntheorem center_toSubsemigroup :\n    (center R).toSubsemigroup = Subsemigroup.center R :=\n  rfl\n\n"}
{"name":"Set.mem_center_iff_addMonoidHom","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\na : R\n⊢ Iff (Membership.mem (Set.center R) a) (And (Eq (AddMonoidHom.mulLeft a) (AddMonoidHom.mulRight a)) (And (Eq (AddMonoidHom.mul.compr₂ (AddMonoidHom.mulLeft a)) (AddMonoidHom.mul.comp (AddMonoidHom.mulLeft a))) (And (Eq (AddMonoidHom.mul.comp (AddMonoidHom.mulRight a)) (AddMonoidHom.mul.compl₂ (AddMonoidHom.mulLeft a))) (Eq (AddMonoidHom.mul.compr₂ (AddMonoidHom.mulRight a)) (AddMonoidHom.mul.compl₂ (AddMonoidHom.mulRight a))))))","decl":"/-- A point-free means of proving membership in the center, for a non-associative ring.\n\nThis can be helpful when working with types that have ext lemmas for `R →+ R`. -/\nlemma _root_.Set.mem_center_iff_addMonoidHom (a : R) :\n    a ∈ Set.center R ↔\n      AddMonoidHom.mulLeft a = .mulRight a ∧\n      AddMonoidHom.compr₂ .mul (.mulLeft a) = .comp .mul (.mulLeft a) ∧\n      AddMonoidHom.comp .mul (.mulRight a) = .compl₂ .mul (.mulLeft a) ∧\n      AddMonoidHom.compr₂ .mul (.mulRight a) = .compl₂ .mul (.mulRight a) := by\n  rw [Set.mem_center_iff, isMulCentral_iff]\n  simp [DFunLike.ext_iff]\n\n"}
{"name":"NonUnitalSubsemiring.centerCongr_symm_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\ns : Subtype fun x => Membership.mem (Subsemigroup.center S) x\n⊢ Eq (↑((NonUnitalSubsemiring.centerCongr e).symm s)) ((↑e).symm ↑s)","decl":"/-- The center of isomorphic (not necessarily unital or associative) semirings are isomorphic. -/\n@[simps!] def centerCongr [NonUnitalNonAssocSemiring S] (e : R ≃+* S) : center R ≃+* center S where\n  __ := Subsemigroup.centerCongr e\n  map_add' _ _ := Subtype.ext <| by exact map_add e ..\n\n"}
{"name":"NonUnitalSubsemiring.centerCongr_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\nr : Subtype fun x => Membership.mem (Subsemigroup.center R) x\n⊢ Eq (↑((NonUnitalSubsemiring.centerCongr e) r)) (e ↑r)","decl":"/-- The center of isomorphic (not necessarily unital or associative) semirings are isomorphic. -/\n@[simps!] def centerCongr [NonUnitalNonAssocSemiring S] (e : R ≃+* S) : center R ≃+* center S where\n  __ := Subsemigroup.centerCongr e\n  map_add' _ _ := Subtype.ext <| by exact map_add e ..\n\n"}
{"name":"NonUnitalSubsemiring.centerToMulOpposite_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nr : Subtype fun x => Membership.mem (Subsemigroup.center R) x\n⊢ Eq (↑(NonUnitalSubsemiring.centerToMulOpposite r)) (MulOpposite.op ↑r)","decl":"/-- The center of a (not necessarily unital or associative) semiring\nis isomorphic to the center of its opposite. -/\n@[simps!] def centerToMulOpposite : center R ≃+* center Rᵐᵒᵖ where\n  __ := Subsemigroup.centerToMulOpposite\n  map_add' _ _ := rfl\n\n"}
{"name":"NonUnitalSubsemiring.centerToMulOpposite_symm_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nr : Subtype fun x => Membership.mem (Subsemigroup.center (MulOpposite R)) x\n⊢ Eq (↑(NonUnitalSubsemiring.centerToMulOpposite.symm r)) (MulOpposite.unop ↑r)","decl":"/-- The center of a (not necessarily unital or associative) semiring\nis isomorphic to the center of its opposite. -/\n@[simps!] def centerToMulOpposite : center R ≃+* center Rᵐᵒᵖ where\n  __ := Subsemigroup.centerToMulOpposite\n  map_add' _ _ := rfl\n\n"}
{"name":"NonUnitalSubsemiring.mem_center_iff","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\nz : R\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.center R) z) (∀ (g : R), Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"theorem mem_center_iff {R} [NonUnitalSemiring R] {z : R} : z ∈ center R ↔ ∀ g, g * z = z * g := by\n  rw [← Semigroup.mem_center_iff]\n  exact Iff.rfl\n\n"}
{"name":"NonUnitalSubsemiring.center_eq_top","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalCommSemiring R\n⊢ Eq (NonUnitalSubsemiring.center R) Top.top","decl":"@[simp]\ntheorem center_eq_top (R) [NonUnitalCommSemiring R] : center R = ⊤ :=\n  SetLike.coe_injective (Set.center_eq_univ R)\n\n"}
{"name":"NonUnitalSubsemiring.coe_centralizer","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns : Set R\n⊢ Eq (↑(NonUnitalSubsemiring.centralizer s)) s.centralizer","decl":"@[simp, norm_cast]\ntheorem coe_centralizer {R} [NonUnitalSemiring R] (s : Set R) :\n    (centralizer s : Set R) = s.centralizer :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.centralizer_toSubsemigroup","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns : Set R\n⊢ Eq (NonUnitalSubsemiring.centralizer s).toSubsemigroup (Subsemigroup.centralizer s)","decl":"theorem centralizer_toSubsemigroup {R} [NonUnitalSemiring R] (s : Set R) :\n    (centralizer s).toSubsemigroup = Subsemigroup.centralizer s :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.mem_centralizer_iff","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns : Set R\nz : R\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.centralizer s) z) (∀ (g : R), Membership.mem s g → Eq (HMul.hMul g z) (HMul.hMul z g))","decl":"theorem mem_centralizer_iff {R} [NonUnitalSemiring R] {s : Set R} {z : R} :\n    z ∈ centralizer s ↔ ∀ g ∈ s, g * z = z * g :=\n  Iff.rfl\n\n"}
{"name":"NonUnitalSubsemiring.center_le_centralizer","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns : Set R\n⊢ LE.le (NonUnitalSubsemiring.center R) (NonUnitalSubsemiring.centralizer s)","decl":"theorem center_le_centralizer {R} [NonUnitalSemiring R] (s) : center R ≤ centralizer s :=\n  s.center_subset_centralizer\n\n"}
{"name":"NonUnitalSubsemiring.centralizer_le","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (NonUnitalSubsemiring.centralizer t) (NonUnitalSubsemiring.centralizer s)","decl":"theorem centralizer_le {R} [NonUnitalSemiring R] (s t : Set R) (h : s ⊆ t) :\n    centralizer t ≤ centralizer s :=\n  Set.centralizer_subset h\n\n"}
{"name":"NonUnitalSubsemiring.centralizer_eq_top_iff_subset","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns : Set R\n⊢ Iff (Eq (NonUnitalSubsemiring.centralizer s) Top.top) (HasSubset.Subset s ↑(NonUnitalSubsemiring.center R))","decl":"@[simp]\ntheorem centralizer_eq_top_iff_subset {R} [NonUnitalSemiring R] {s : Set R} :\n    centralizer s = ⊤ ↔ s ⊆ center R :=\n  SetLike.ext'_iff.trans Set.centralizer_eq_top_iff_subset\n\n"}
{"name":"NonUnitalSubsemiring.centralizer_univ","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\n⊢ Eq (NonUnitalSubsemiring.centralizer Set.univ) (NonUnitalSubsemiring.center R)","decl":"@[simp]\ntheorem centralizer_univ {R} [NonUnitalSemiring R] : centralizer Set.univ = center R :=\n  SetLike.ext' (Set.centralizer_univ R)\n\n"}
{"name":"NonUnitalSubsemiring.mem_closure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nx : R\ns : Set R\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.closure s) x) (∀ (S : NonUnitalSubsemiring R), HasSubset.Subset s ↑S → Membership.mem S x)","decl":"theorem mem_closure {x : R} {s : Set R} :\n    x ∈ closure s ↔ ∀ S : NonUnitalSubsemiring R, s ⊆ S → x ∈ S :=\n  mem_sInf\n\n"}
{"name":"NonUnitalSubsemiring.subset_closure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\n⊢ HasSubset.Subset s ↑(NonUnitalSubsemiring.closure s)","decl":"/-- The non-unital subsemiring generated by a set includes the set. -/\n@[simp, aesop safe 20 apply (rule_sets := [SetLike])]\ntheorem subset_closure {s : Set R} : s ⊆ closure s := fun _ hx => mem_closure.2 fun _ hS => hS hx\n\n"}
{"name":"NonUnitalSubsemiring.not_mem_of_not_mem_closure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\nP : R\nhP : Not (Membership.mem (NonUnitalSubsemiring.closure s) P)\n⊢ Not (Membership.mem s P)","decl":"theorem not_mem_of_not_mem_closure {s : Set R} {P : R} (hP : P ∉ closure s) : P ∉ s := fun h =>\n  hP (subset_closure h)\n\n"}
{"name":"NonUnitalSubsemiring.closure_le","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\nt : NonUnitalSubsemiring R\n⊢ Iff (LE.le (NonUnitalSubsemiring.closure s) t) (HasSubset.Subset s ↑t)","decl":"/-- A non-unital subsemiring `S` includes `closure s` if and only if it includes `s`. -/\n@[simp]\ntheorem closure_le {s : Set R} {t : NonUnitalSubsemiring R} : closure s ≤ t ↔ s ⊆ t :=\n  ⟨Set.Subset.trans subset_closure, fun h => sInf_le h⟩\n\n"}
{"name":"NonUnitalSubsemiring.closure_mono","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns t : Set R\nh : HasSubset.Subset s t\n⊢ LE.le (NonUnitalSubsemiring.closure s) (NonUnitalSubsemiring.closure t)","decl":"/-- Subsemiring closure of a set is monotone in its argument: if `s ⊆ t`,\nthen `closure s ≤ closure t`. -/\n@[gcongr]\ntheorem closure_mono ⦃s t : Set R⦄ (h : s ⊆ t) : closure s ≤ closure t :=\n  closure_le.2 <| Set.Subset.trans h subset_closure\n\n"}
{"name":"NonUnitalSubsemiring.closure_eq_of_le","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\nt : NonUnitalSubsemiring R\nh₁ : HasSubset.Subset s ↑t\nh₂ : LE.le t (NonUnitalSubsemiring.closure s)\n⊢ Eq (NonUnitalSubsemiring.closure s) t","decl":"theorem closure_eq_of_le {s : Set R} {t : NonUnitalSubsemiring R} (h₁ : s ⊆ t)\n    (h₂ : t ≤ closure s) : closure s = t :=\n  le_antisymm (closure_le.2 h₁) h₂\n\n"}
{"name":"NonUnitalSubsemiring.closure_le_centralizer_centralizer","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u_1\ninst✝ : NonUnitalSemiring R\ns : Set R\n⊢ LE.le (NonUnitalSubsemiring.closure s) (NonUnitalSubsemiring.centralizer ↑(NonUnitalSubsemiring.centralizer s))","decl":"lemma closure_le_centralizer_centralizer {R : Type*} [NonUnitalSemiring R] (s : Set R) :\n    closure s ≤ centralizer (centralizer s) :=\n  closure_le.mpr Set.subset_centralizer_centralizer\n\n"}
{"name":"NonUnitalSubsemiring.mem_map_equiv","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\nK : NonUnitalSubsemiring R\nx : S\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.map (↑f) K) x) (Membership.mem K (f.symm x))","decl":"theorem mem_map_equiv {f : R ≃+* S} {K : NonUnitalSubsemiring R} {x : S} :\n    x ∈ K.map (f : R →ₙ+* S) ↔ f.symm x ∈ K := by\n  convert @Set.mem_image_equiv _ _ (↑K) f.toEquiv x\n\n"}
{"name":"NonUnitalSubsemiring.map_equiv_eq_comap_symm","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\nK : NonUnitalSubsemiring R\n⊢ Eq (NonUnitalSubsemiring.map (↑f) K) (NonUnitalSubsemiring.comap f.symm K)","decl":"theorem map_equiv_eq_comap_symm (f : R ≃+* S) (K : NonUnitalSubsemiring R) :\n    K.map (f : R →ₙ+* S) = K.comap f.symm :=\n  SetLike.coe_injective (f.toEquiv.image_eq_preimage K)\n\n"}
{"name":"NonUnitalSubsemiring.comap_equiv_eq_map_symm","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : RingEquiv R S\nK : NonUnitalSubsemiring S\n⊢ Eq (NonUnitalSubsemiring.comap (↑f) K) (NonUnitalSubsemiring.map f.symm K)","decl":"theorem comap_equiv_eq_map_symm (f : R ≃+* S) (K : NonUnitalSubsemiring S) :\n    K.comap (f : R →ₙ+* S) = K.map f.symm :=\n  (map_equiv_eq_comap_symm f.symm K).symm\n\n"}
{"name":"Subsemigroup.nonUnitalSubsemiringClosure_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\n⊢ Eq ↑M.nonUnitalSubsemiringClosure ↑(AddSubmonoid.closure ↑M)","decl":"theorem nonUnitalSubsemiringClosure_coe :\n    (M.nonUnitalSubsemiringClosure : Set R) = AddSubmonoid.closure (M : Set R) :=\n  rfl\n\n"}
{"name":"Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\n⊢ Eq M.nonUnitalSubsemiringClosure.toAddSubmonoid (AddSubmonoid.closure ↑M)","decl":"theorem nonUnitalSubsemiringClosure_toAddSubmonoid :\n    M.nonUnitalSubsemiringClosure.toAddSubmonoid = AddSubmonoid.closure (M : Set R) :=\n  rfl\n\n"}
{"name":"Subsemigroup.nonUnitalSubsemiringClosure_eq_closure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nM : Subsemigroup R\n⊢ Eq M.nonUnitalSubsemiringClosure (NonUnitalSubsemiring.closure ↑M)","decl":"/-- The `NonUnitalSubsemiring` generated by a multiplicative subsemigroup coincides with the\n`NonUnitalSubsemiring.closure` of the subsemigroup itself . -/\ntheorem nonUnitalSubsemiringClosure_eq_closure :\n    M.nonUnitalSubsemiringClosure = NonUnitalSubsemiring.closure (M : Set R) := by\n  ext\n  refine ⟨fun hx => ?_,\n    fun hx => (NonUnitalSubsemiring.mem_closure.mp hx) M.nonUnitalSubsemiringClosure fun s sM => ?_⟩\n  <;> rintro - ⟨H1, rfl⟩\n  <;> rintro - ⟨H2, rfl⟩\n  · exact AddSubmonoid.mem_closure.mp hx H1.toAddSubmonoid H2\n  · exact H2 sM\n\n"}
{"name":"NonUnitalSubsemiring.closure_subsemigroup_closure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\n⊢ Eq (NonUnitalSubsemiring.closure ↑(Subsemigroup.closure s)) (NonUnitalSubsemiring.closure s)","decl":"@[simp]\ntheorem closure_subsemigroup_closure (s : Set R) : closure ↑(Subsemigroup.closure s) = closure s :=\n  le_antisymm\n    (closure_le.mpr fun _ hy =>\n      (Subsemigroup.mem_closure.mp hy) (closure s).toSubsemigroup subset_closure)\n    (closure_mono Subsemigroup.subset_closure)\n\n"}
{"name":"NonUnitalSubsemiring.coe_closure_eq","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\n⊢ Eq ↑(NonUnitalSubsemiring.closure s) ↑(AddSubmonoid.closure ↑(Subsemigroup.closure s))","decl":"/-- The elements of the non-unital subsemiring closure of `M` are exactly the elements of the\nadditive closure of a multiplicative subsemigroup `M`. -/\ntheorem coe_closure_eq (s : Set R) :\n    (closure s : Set R) = AddSubmonoid.closure (Subsemigroup.closure s : Set R) := by\n  simp [← Subsemigroup.nonUnitalSubsemiringClosure_toAddSubmonoid,\n    Subsemigroup.nonUnitalSubsemiringClosure_eq_closure]\n\n"}
{"name":"NonUnitalSubsemiring.mem_closure_iff","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\nx : R\n⊢ Iff (Membership.mem (NonUnitalSubsemiring.closure s) x) (Membership.mem (AddSubmonoid.closure ↑(Subsemigroup.closure s)) x)","decl":"theorem mem_closure_iff {s : Set R} {x} :\n    x ∈ closure s ↔ x ∈ AddSubmonoid.closure (Subsemigroup.closure s : Set R) :=\n  Set.ext_iff.mp (coe_closure_eq s) x\n\n"}
{"name":"NonUnitalSubsemiring.closure_addSubmonoid_closure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\n⊢ Eq (NonUnitalSubsemiring.closure ↑(AddSubmonoid.closure s)) (NonUnitalSubsemiring.closure s)","decl":"@[simp]\ntheorem closure_addSubmonoid_closure {s : Set R} :\n    closure ↑(AddSubmonoid.closure s) = closure s := by\n  ext x\n  refine ⟨fun hx => ?_, fun hx => closure_mono AddSubmonoid.subset_closure hx⟩\n  rintro - ⟨H, rfl⟩\n  rintro - ⟨J, rfl⟩\n  refine (AddSubmonoid.mem_closure.mp (mem_closure_iff.mp hx)) H.toAddSubmonoid fun y hy => ?_\n  refine (Subsemigroup.mem_closure.mp hy) H.toSubsemigroup fun z hz => ?_\n  exact (AddSubmonoid.mem_closure.mp hz) H.toAddSubmonoid fun w hw => J hw\n\n"}
{"name":"NonUnitalSubsemiring.closure_induction","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\np : (x : R) → Membership.mem (NonUnitalSubsemiring.closure s) x → Prop\nmem : ∀ (x : R) (hx : Membership.mem s x), p x ⋯\nzero : p 0 ⋯\nadd : ∀ (x y : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x) (hy : Membership.mem (NonUnitalSubsemiring.closure s) y), p x hx → p y hy → p (HAdd.hAdd x y) ⋯\nmul : ∀ (x y : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x) (hy : Membership.mem (NonUnitalSubsemiring.closure s) y), p x hx → p y hy → p (HMul.hMul x y) ⋯\nx : R\nhx : Membership.mem (NonUnitalSubsemiring.closure s) x\n⊢ p x hx","decl":"/-- An induction principle for closure membership. If `p` holds for `0`, `1`, and all elements\nof `s`, and is preserved under addition and multiplication, then `p` holds for all elements\nof the closure of `s`. -/\n@[elab_as_elim]\ntheorem closure_induction {s : Set R} {p : (x : R) → x ∈ closure s → Prop}\n    (mem : ∀ (x) (hx : x ∈ s), p x (subset_closure hx)) (zero : p 0 (zero_mem _))\n    (add : ∀ x y hx hy, p x hx → p y hy → p (x + y) (add_mem hx hy))\n    (mul : ∀ x y hx hy, p x hx → p y hy → p (x * y) (mul_mem hx hy))\n    {x} (hx : x ∈ closure s)  : p x hx :=\n  let K : NonUnitalSubsemiring R :=\n    { carrier := { x | ∃ hx, p x hx }\n      mul_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, mul _ _ _ _ hpx hpy⟩\n      add_mem' := fun ⟨_, hpx⟩ ⟨_, hpy⟩ ↦ ⟨_, add _ _ _ _ hpx hpy⟩\n      zero_mem' := ⟨_, zero⟩ }\n  closure_le (t := K) |>.mpr (fun y hy ↦ ⟨subset_closure hy, mem y hy⟩) hx |>.elim fun _ ↦ id\n\n"}
{"name":"NonUnitalSubsemiring.closure_induction₂","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set R\np : (x y : R) → Membership.mem (NonUnitalSubsemiring.closure s) x → Membership.mem (NonUnitalSubsemiring.closure s) y → Prop\nmem_mem : ∀ (x : R) (hx : Membership.mem s x) (y : R) (hy : Membership.mem s y), p x y ⋯ ⋯\nzero_left : ∀ (x : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x), p 0 x ⋯ hx\nzero_right : ∀ (x : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x), p x 0 hx ⋯\nadd_left : ∀ (x y z : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x) (hy : Membership.mem (NonUnitalSubsemiring.closure s) y) (hz : Membership.mem (NonUnitalSubsemiring.closure s) z), p x z hx hz → p y z hy hz → p (HAdd.hAdd x y) z ⋯ hz\nadd_right : ∀ (x y z : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x) (hy : Membership.mem (NonUnitalSubsemiring.closure s) y) (hz : Membership.mem (NonUnitalSubsemiring.closure s) z), p x y hx hy → p x z hx hz → p x (HAdd.hAdd y z) hx ⋯\nmul_left : ∀ (x y z : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x) (hy : Membership.mem (NonUnitalSubsemiring.closure s) y) (hz : Membership.mem (NonUnitalSubsemiring.closure s) z), p x z hx hz → p y z hy hz → p (HMul.hMul x y) z ⋯ hz\nmul_right : ∀ (x y z : R) (hx : Membership.mem (NonUnitalSubsemiring.closure s) x) (hy : Membership.mem (NonUnitalSubsemiring.closure s) y) (hz : Membership.mem (NonUnitalSubsemiring.closure s) z), p x y hx hy → p x z hx hz → p x (HMul.hMul y z) hx ⋯\nx y : R\nhx : Membership.mem (NonUnitalSubsemiring.closure s) x\nhy : Membership.mem (NonUnitalSubsemiring.closure s) y\n⊢ p x y hx hy","decl":"/-- An induction principle for closure membership for predicates with two arguments. -/\n@[elab_as_elim]\ntheorem closure_induction₂ {s : Set R} {p : (x y : R) → x ∈ closure s → y ∈ closure s → Prop}\n    (mem_mem : ∀ (x) (hx : x ∈ s) (y) (hy : y ∈ s), p x y (subset_closure hx) (subset_closure hy))\n    (zero_left : ∀ x hx, p 0 x (zero_mem _) hx) (zero_right : ∀ x hx, p x 0 hx (zero_mem _))\n    (add_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x + y) z (add_mem hx hy) hz)\n    (add_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y + z) hx (add_mem hy hz))\n    (mul_left : ∀ x y z hx hy hz, p x z hx hz → p y z hy hz → p (x * y) z (mul_mem hx hy) hz)\n    (mul_right : ∀ x y z hx hy hz, p x y hx hy → p x z hx hz → p x (y * z) hx (mul_mem hy hz))\n    {x y : R} (hx : x ∈ closure s) (hy : y ∈ closure s) :\n    p x y hx hy := by\n  induction hy using closure_induction with\n  | mem z hz => induction hx using closure_induction with\n    | mem _ h => exact mem_mem _ h _ hz\n    | zero => exact zero_left _ _\n    | mul _ _ _ _ h₁ h₂ => exact mul_left _ _ _ _ _ _ h₁ h₂\n    | add _ _ _ _ h₁ h₂ => exact add_left _ _ _ _ _ _ h₁ h₂\n  | zero => exact zero_right x hx\n  | mul _ _ _ _ h₁ h₂ => exact mul_right _ _ _ _ _ _ h₁ h₂\n  | add _ _ _ _ h₁ h₂ => exact add_right _ _ _ _ _ _ h₁ h₂\n\n"}
{"name":"NonUnitalSubsemiring.closure_eq","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : NonUnitalSubsemiring R\n⊢ Eq (NonUnitalSubsemiring.closure ↑s) s","decl":"/-- Closure of a non-unital subsemiring `S` equals `S`. -/\n@[simp]\ntheorem closure_eq (s : NonUnitalSubsemiring R) : closure (s : Set R) = s :=\n  (NonUnitalSubsemiring.gi R).l_u_eq s\n\n"}
{"name":"NonUnitalSubsemiring.closure_empty","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (NonUnitalSubsemiring.closure EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem closure_empty : closure (∅ : Set R) = ⊥ :=\n  (NonUnitalSubsemiring.gi R).gc.l_bot\n\n"}
{"name":"NonUnitalSubsemiring.closure_univ","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (NonUnitalSubsemiring.closure Set.univ) Top.top","decl":"@[simp]\ntheorem closure_univ : closure (Set.univ : Set R) = ⊤ :=\n  @coe_top R _ ▸ closure_eq ⊤\n\n"}
{"name":"NonUnitalSubsemiring.closure_union","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns t : Set R\n⊢ Eq (NonUnitalSubsemiring.closure (Union.union s t)) (Max.max (NonUnitalSubsemiring.closure s) (NonUnitalSubsemiring.closure t))","decl":"theorem closure_union (s t : Set R) : closure (s ∪ t) = closure s ⊔ closure t :=\n  (NonUnitalSubsemiring.gi R).gc.l_sup\n\n"}
{"name":"NonUnitalSubsemiring.closure_iUnion","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_2\ns : ι → Set R\n⊢ Eq (NonUnitalSubsemiring.closure (Set.iUnion fun i => s i)) (iSup fun i => NonUnitalSubsemiring.closure (s i))","decl":"theorem closure_iUnion {ι} (s : ι → Set R) : closure (⋃ i, s i) = ⨆ i, closure (s i) :=\n  (NonUnitalSubsemiring.gi R).gc.l_iSup\n\n"}
{"name":"NonUnitalSubsemiring.closure_sUnion","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : Set (Set R)\n⊢ Eq (NonUnitalSubsemiring.closure s.sUnion) (iSup fun t => iSup fun h => NonUnitalSubsemiring.closure t)","decl":"theorem closure_sUnion (s : Set (Set R)) : closure (⋃₀ s) = ⨆ t ∈ s, closure t :=\n  (NonUnitalSubsemiring.gi R).gc.l_sSup\n\n"}
{"name":"NonUnitalSubsemiring.map_sup","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ns t : NonUnitalSubsemiring R\nf : F\n⊢ Eq (NonUnitalSubsemiring.map f (Max.max s t)) (Max.max (NonUnitalSubsemiring.map f s) (NonUnitalSubsemiring.map f t))","decl":"theorem map_sup (s t : NonUnitalSubsemiring R) (f : F) :\n    (map f (s ⊔ t) : NonUnitalSubsemiring S) = map f s ⊔ map f t :=\n  @GaloisConnection.l_sup _ _ s t _ _ _ _ (gc_map_comap f)\n\n"}
{"name":"NonUnitalSubsemiring.map_iSup","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nι : Sort u_2\nf : F\ns : ι → NonUnitalSubsemiring R\n⊢ Eq (NonUnitalSubsemiring.map f (iSup s)) (iSup fun i => NonUnitalSubsemiring.map f (s i))","decl":"theorem map_iSup {ι : Sort*} (f : F) (s : ι → NonUnitalSubsemiring R) :\n    (map f (iSup s) : NonUnitalSubsemiring S) = ⨆ i, map f (s i) :=\n  @GaloisConnection.l_iSup _ _ _ _ _ _ _ (gc_map_comap f) s\n\n"}
{"name":"NonUnitalSubsemiring.map_inf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ns t : NonUnitalSubsemiring R\nf : F\nhf : Function.Injective ⇑f\n⊢ Eq (NonUnitalSubsemiring.map f (Min.min s t)) (Min.min (NonUnitalSubsemiring.map f s) (NonUnitalSubsemiring.map f t))","decl":"theorem map_inf (s t : NonUnitalSubsemiring R) (f : F) (hf : Function.Injective f) :\n    (map f (s ⊓ t) : NonUnitalSubsemiring S) = map f s ⊓ map f t :=\n  SetLike.coe_injective (Set.image_inter hf)\n\n"}
{"name":"NonUnitalSubsemiring.map_iInf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : NonUnitalNonAssocSemiring R\ninst✝³ : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalRingHomClass F R S\nι : Sort u_2\ninst✝ : Nonempty ι\nf : F\nhf : Function.Injective ⇑f\ns : ι → NonUnitalSubsemiring R\n⊢ Eq (NonUnitalSubsemiring.map f (iInf s)) (iInf fun i => NonUnitalSubsemiring.map f (s i))","decl":"theorem map_iInf {ι : Sort*} [Nonempty ι] (f : F) (hf : Function.Injective f)\n    (s : ι → NonUnitalSubsemiring R) :\n    (map f (iInf s) : NonUnitalSubsemiring S) = ⨅ i, map f (s i) := by\n  apply SetLike.coe_injective\n  simpa using (Set.injOn_of_injective hf).image_iInter_eq (s := SetLike.coe ∘ s)\n\n"}
{"name":"NonUnitalSubsemiring.comap_inf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ns t : NonUnitalSubsemiring S\nf : F\n⊢ Eq (NonUnitalSubsemiring.comap f (Min.min s t)) (Min.min (NonUnitalSubsemiring.comap f s) (NonUnitalSubsemiring.comap f t))","decl":"theorem comap_inf (s t : NonUnitalSubsemiring S) (f : F) :\n    (comap f (s ⊓ t) : NonUnitalSubsemiring R) = comap f s ⊓ comap f t :=\n  @GaloisConnection.u_inf _ _ s t _ _ _ _ (gc_map_comap f)\n\n"}
{"name":"NonUnitalSubsemiring.comap_iInf","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nι : Sort u_2\nf : F\ns : ι → NonUnitalSubsemiring S\n⊢ Eq (NonUnitalSubsemiring.comap f (iInf s)) (iInf fun i => NonUnitalSubsemiring.comap f (s i))","decl":"theorem comap_iInf {ι : Sort*} (f : F) (s : ι → NonUnitalSubsemiring S) :\n    (comap f (iInf s) : NonUnitalSubsemiring R) = ⨅ i, comap f (s i) :=\n  @GaloisConnection.u_iInf _ _ _ _ _ _ _ (gc_map_comap f) s\n\n"}
{"name":"NonUnitalSubsemiring.map_bot","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Eq (NonUnitalSubsemiring.map f Bot.bot) Bot.bot","decl":"@[simp]\ntheorem map_bot (f : F) : map f (⊥ : NonUnitalSubsemiring R) = (⊥ : NonUnitalSubsemiring S) :=\n  (gc_map_comap f).l_bot\n\n"}
{"name":"NonUnitalSubsemiring.comap_top","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Eq (NonUnitalSubsemiring.comap f Top.top) Top.top","decl":"@[simp]\ntheorem comap_top (f : F) : comap f (⊤ : NonUnitalSubsemiring S) = (⊤ : NonUnitalSubsemiring R) :=\n  (gc_map_comap f).u_top\n\n"}
{"name":"NonUnitalSubsemiring.coe_prod","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ns : NonUnitalSubsemiring R\nt : NonUnitalSubsemiring S\n⊢ Eq (↑(s.prod t)) (SProd.sprod ↑s ↑t)","decl":"@[norm_cast]\ntheorem coe_prod (s : NonUnitalSubsemiring R) (t : NonUnitalSubsemiring S) :\n    (s.prod t : Set (R × S)) = (s : Set R) ×ˢ (t : Set S) :=\n  rfl\n\n"}
{"name":"NonUnitalSubsemiring.mem_prod","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ns : NonUnitalSubsemiring R\nt : NonUnitalSubsemiring S\np : Prod R S\n⊢ Iff (Membership.mem (s.prod t) p) (And (Membership.mem s p.1) (Membership.mem t p.2))","decl":"theorem mem_prod {s : NonUnitalSubsemiring R} {t : NonUnitalSubsemiring S} {p : R × S} :\n    p ∈ s.prod t ↔ p.1 ∈ s ∧ p.2 ∈ t :=\n  Iff.rfl\n\n"}
{"name":"NonUnitalSubsemiring.prod_mono","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ns₁ s₂ : NonUnitalSubsemiring R\nhs : LE.le s₁ s₂\nt₁ t₂ : NonUnitalSubsemiring S\nht : LE.le t₁ t₂\n⊢ LE.le (s₁.prod t₁) (s₂.prod t₂)","decl":"@[mono]\ntheorem prod_mono ⦃s₁ s₂ : NonUnitalSubsemiring R⦄ (hs : s₁ ≤ s₂) ⦃t₁ t₂ : NonUnitalSubsemiring S⦄\n    (ht : t₁ ≤ t₂) : s₁.prod t₁ ≤ s₂.prod t₂ :=\n  Set.prod_mono hs ht\n\n"}
{"name":"NonUnitalSubsemiring.prod_mono_right","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ns : NonUnitalSubsemiring R\n⊢ Monotone fun t => s.prod t","decl":"theorem prod_mono_right (s : NonUnitalSubsemiring R) :\n    Monotone fun t : NonUnitalSubsemiring S => s.prod t :=\n  prod_mono (le_refl s)\n\n"}
{"name":"NonUnitalSubsemiring.prod_mono_left","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nt : NonUnitalSubsemiring S\n⊢ Monotone fun s => s.prod t","decl":"theorem prod_mono_left (t : NonUnitalSubsemiring S) :\n    Monotone fun s : NonUnitalSubsemiring R => s.prod t := fun _ _ hs => prod_mono hs (le_refl t)\n\n"}
{"name":"NonUnitalSubsemiring.prod_top","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ns : NonUnitalSubsemiring R\n⊢ Eq (s.prod Top.top) (NonUnitalSubsemiring.comap (NonUnitalRingHom.fst R S) s)","decl":"theorem prod_top (s : NonUnitalSubsemiring R) :\n    s.prod (⊤ : NonUnitalSubsemiring S) = s.comap (NonUnitalRingHom.fst R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_fst]\n\n"}
{"name":"NonUnitalSubsemiring.top_prod","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ns : NonUnitalSubsemiring S\n⊢ Eq (Top.top.prod s) (NonUnitalSubsemiring.comap (NonUnitalRingHom.snd R S) s)","decl":"theorem top_prod (s : NonUnitalSubsemiring S) :\n    (⊤ : NonUnitalSubsemiring R).prod s = s.comap (NonUnitalRingHom.snd R S) :=\n  ext fun x => by simp [mem_prod, MonoidHom.coe_snd]\n\n"}
{"name":"NonUnitalSubsemiring.top_prod_top","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\n⊢ Eq (Top.top.prod Top.top) Top.top","decl":"@[simp]\ntheorem top_prod_top : (⊤ : NonUnitalSubsemiring R).prod (⊤ : NonUnitalSubsemiring S) = ⊤ :=\n  (top_prod _).trans <| comap_top _\n\n"}
{"name":"NonUnitalSubsemiring.mem_iSup_of_directed","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_2\nhι : Nonempty ι\nS : ι → NonUnitalSubsemiring R\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\nx : R\n⊢ Iff (Membership.mem (iSup fun i => S i) x) (Exists fun i => Membership.mem (S i) x)","decl":"theorem mem_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → NonUnitalSubsemiring R}\n    (hS : Directed (· ≤ ·) S) {x : R} : (x ∈ ⨆ i, S i) ↔ ∃ i, x ∈ S i := by\n  refine ⟨?_, fun ⟨i, hi⟩ ↦ le_iSup S i hi⟩\n  let U : NonUnitalSubsemiring R :=\n    NonUnitalSubsemiring.mk' (⋃ i, (S i : Set R))\n      (⨆ i, (S i).toSubsemigroup) (Subsemigroup.coe_iSup_of_directed hS)\n      (⨆ i, (S i).toAddSubmonoid) (AddSubmonoid.coe_iSup_of_directed hS)\n  -- Porting note `@this` doesn't work\n  suffices H : ⨆ i, S i ≤ U by simpa [U] using @H x\n  exact iSup_le fun i x hx => Set.mem_iUnion.2 ⟨i, hx⟩\n\n"}
{"name":"NonUnitalSubsemiring.coe_iSup_of_directed","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nι : Sort u_2\nhι : Nonempty ι\nS : ι → NonUnitalSubsemiring R\nhS : Directed (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(iSup fun i => S i)) (Set.iUnion fun i => ↑(S i))","decl":"theorem coe_iSup_of_directed {ι} [hι : Nonempty ι] {S : ι → NonUnitalSubsemiring R}\n    (hS : Directed (· ≤ ·) S) : ((⨆ i, S i : NonUnitalSubsemiring R) : Set R) = ⋃ i, S i :=\n  Set.ext fun x ↦ by simp [mem_iSup_of_directed hS]\n\n"}
{"name":"NonUnitalSubsemiring.mem_sSup_of_directedOn","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nS : Set (NonUnitalSubsemiring R)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\nx : R\n⊢ Iff (Membership.mem (SupSet.sSup S) x) (Exists fun s => And (Membership.mem S s) (Membership.mem s x))","decl":"theorem mem_sSup_of_directedOn {S : Set (NonUnitalSubsemiring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) {x : R} : x ∈ sSup S ↔ ∃ s ∈ S, x ∈ s := by\n  haveI : Nonempty S := Sne.to_subtype\n  simp only [sSup_eq_iSup', mem_iSup_of_directed hS.directed_val, Subtype.exists, exists_prop]\n\n"}
{"name":"NonUnitalSubsemiring.coe_sSup_of_directedOn","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\nS : Set (NonUnitalSubsemiring R)\nSne : S.Nonempty\nhS : DirectedOn (fun x1 x2 => LE.le x1 x2) S\n⊢ Eq (↑(SupSet.sSup S)) (Set.iUnion fun s => Set.iUnion fun h => ↑s)","decl":"theorem coe_sSup_of_directedOn {S : Set (NonUnitalSubsemiring R)} (Sne : S.Nonempty)\n    (hS : DirectedOn (· ≤ ·) S) : (↑(sSup S) : Set R) = ⋃ s ∈ S, ↑s :=\n  Set.ext fun x => by simp [mem_sSup_of_directedOn Sne hS]\n\n"}
{"name":"NonUnitalRingHom.eq_of_eqOn_stop","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝ : FunLike F R S\nf g : F\nh : Set.EqOn ⇑f ⇑g ↑Top.top\n⊢ Eq f g","decl":"theorem eq_of_eqOn_stop {f g : F}\n    (h : Set.EqOn (f : R → S) (g : R → S) (⊤ : NonUnitalSubsemiring R)) : f = g :=\n  DFunLike.ext _ _ fun _ => h trivial\n\n"}
{"name":"NonUnitalRingHom.coe_srangeRestrict","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nx : R\n⊢ Eq (↑((NonUnitalRingHom.srangeRestrict f) x)) (f x)","decl":"@[simp]\ntheorem coe_srangeRestrict (f : F) (x : R) : (srangeRestrict f x : S) = f x :=\n  rfl\n\n"}
{"name":"NonUnitalRingHom.srangeRestrict_surjective","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Function.Surjective ⇑(NonUnitalRingHom.srangeRestrict f)","decl":"theorem srangeRestrict_surjective (f : F) :\n    Function.Surjective (srangeRestrict f : R → (srange f : NonUnitalSubsemiring S)) :=\n  fun ⟨_, hy⟩ =>\n  let ⟨x, hx⟩ := mem_srange.mp hy\n  ⟨x, Subtype.ext hx⟩\n\n"}
{"name":"NonUnitalRingHom.srange_eq_top_iff_surjective","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Iff (Eq (NonUnitalRingHom.srange f) Top.top) (Function.Surjective ⇑f)","decl":"theorem srange_eq_top_iff_surjective {f : F} :\n    srange f = (⊤ : NonUnitalSubsemiring S) ↔ Function.Surjective (f : R → S) :=\n  SetLike.ext'_iff.trans <| Iff.trans (by rw [coe_srange, coe_top]) Set.range_eq_univ\n\n"}
{"name":"NonUnitalRingHom.srange_top_iff_surjective","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\n⊢ Iff (Eq (NonUnitalRingHom.srange f) Top.top) (Function.Surjective ⇑f)","decl":"@[deprecated (since := \"2024-11-11\")]\nalias srange_top_iff_surjective := srange_eq_top_iff_surjective\n\n"}
{"name":"NonUnitalRingHom.srange_eq_top_of_surjective","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\n⊢ Eq (NonUnitalRingHom.srange f) Top.top","decl":"/-- The range of a surjective non-unital ring homomorphism is the whole of the codomain. -/\n@[simp]\ntheorem srange_eq_top_of_surjective (f : F) (hf : Function.Surjective (f : R → S)) :\n    srange f = (⊤ : NonUnitalSubsemiring S) :=\n  srange_eq_top_iff_surjective.2 hf\n\n"}
{"name":"NonUnitalRingHom.srange_top_of_surjective","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\nhf : Function.Surjective ⇑f\n⊢ Eq (NonUnitalRingHom.srange f) Top.top","decl":"@[deprecated (since := \"2024-11-11\")] alias srange_top_of_surjective := srange_eq_top_of_surjective\n\n"}
{"name":"NonUnitalRingHom.eqOn_sclosure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf g : F\ns : Set R\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Set.EqOn ⇑f ⇑g ↑(NonUnitalSubsemiring.closure s)","decl":"/-- If two non-unital ring homomorphisms are equal on a set, then they are equal on its\nnon-unital subsemiring closure. -/\ntheorem eqOn_sclosure {f g : F} {s : Set R} (h : Set.EqOn (f : R → S) (g : R → S) s) :\n    Set.EqOn f g (closure s) :=\n  show closure s ≤ eqSlocus f g from closure_le.2 h\n\n"}
{"name":"NonUnitalRingHom.eq_of_eqOn_sdense","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\ns : Set R\nhs : Eq (NonUnitalSubsemiring.closure s) Top.top\nf g : F\nh : Set.EqOn (⇑f) (⇑g) s\n⊢ Eq f g","decl":"theorem eq_of_eqOn_sdense {s : Set R} (hs : closure s = ⊤) {f g : F}\n    (h : s.EqOn (f : R → S) (g : R → S)) : f = g :=\n  eq_of_eqOn_stop <| hs ▸ eqOn_sclosure h\n\n"}
{"name":"NonUnitalRingHom.sclosure_preimage_le","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\ns : Set S\n⊢ LE.le (NonUnitalSubsemiring.closure (Set.preimage (⇑f) s)) (NonUnitalSubsemiring.comap f (NonUnitalSubsemiring.closure s))","decl":"theorem sclosure_preimage_le (f : F) (s : Set S) :\n    closure ((f : R → S) ⁻¹' s) ≤ (closure s).comap f :=\n  closure_le.2 fun _ hx => SetLike.mem_coe.2 <| mem_comap.2 <| subset_closure hx\n\n"}
{"name":"NonUnitalRingHom.map_sclosure","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\nF : Type u_1\ninst✝² : FunLike F R S\ninst✝¹ : NonUnitalNonAssocSemiring S\ninst✝ : NonUnitalRingHomClass F R S\nf : F\ns : Set R\n⊢ Eq (NonUnitalSubsemiring.map f (NonUnitalSubsemiring.closure s)) (NonUnitalSubsemiring.closure (Set.image (⇑f) s))","decl":"/-- The image under a ring homomorphism of the subsemiring generated by a set equals\nthe subsemiring generated by the image of the set. -/\ntheorem map_sclosure (f : F) (s : Set R) : (closure s).map f = closure ((f : R → S) '' s) :=\n  Set.image_preimage.l_comm_of_u_comm (gc_map_comap f) (NonUnitalSubsemiring.gi S).gc\n    (NonUnitalSubsemiring.gi R).gc fun _ ↦ rfl\n\n"}
{"name":"NonUnitalSubsemiring.srange_subtype","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\ninst✝ : NonUnitalNonAssocSemiring R\ns : NonUnitalSubsemiring R\n⊢ Eq (NonUnitalRingHom.srange (NonUnitalSubsemiringClass.subtype s)) s","decl":"@[simp]\ntheorem srange_subtype (s : NonUnitalSubsemiring R) : NonUnitalRingHom.srange (subtype s) = s :=\n  SetLike.coe_injective <| (coe_srange _).trans Subtype.range_coe\n\n"}
{"name":"NonUnitalSubsemiring.range_fst","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\n⊢ Eq (NonUnitalRingHom.srange (NonUnitalRingHom.fst R S)) Top.top","decl":"@[simp]\ntheorem range_fst : NonUnitalRingHom.srange (fst R S) = ⊤ :=\n  NonUnitalRingHom.srange_eq_top_of_surjective (fst R S) Prod.fst_surjective\n\n"}
{"name":"NonUnitalSubsemiring.range_snd","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\n⊢ Eq (NonUnitalRingHom.srange (NonUnitalRingHom.snd R S)) Top.top","decl":"@[simp]\ntheorem range_snd : NonUnitalRingHom.srange (snd R S) = ⊤ :=\n  NonUnitalRingHom.srange_eq_top_of_surjective (snd R S) <| Prod.snd_surjective\n\n"}
{"name":"RingEquiv.sofLeftInverse'_apply","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ng : S → R\nf : F\nh : Function.LeftInverse g ⇑f\nx : R\n⊢ Eq (↑((RingEquiv.sofLeftInverse' h) x)) (f x)","decl":"@[simp]\ntheorem sofLeftInverse'_apply {g : S → R} {f : F} (h : Function.LeftInverse g f) (x : R) :\n    ↑(sofLeftInverse' h x) = f x :=\n  rfl\n\n"}
{"name":"RingEquiv.sofLeftInverse'_symm_apply","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝³ : NonUnitalNonAssocSemiring R\ninst✝² : NonUnitalNonAssocSemiring S\nF : Type u_1\ninst✝¹ : FunLike F R S\ninst✝ : NonUnitalRingHomClass F R S\ng : S → R\nf : F\nh : Function.LeftInverse g ⇑f\nx : Subtype fun x => Membership.mem (NonUnitalRingHom.srange f) x\n⊢ Eq ((RingEquiv.sofLeftInverse' h).symm x) (g ↑x)","decl":"@[simp]\ntheorem sofLeftInverse'_symm_apply {g : S → R} {f : F} (h : Function.LeftInverse g f)\n    (x : srange f) : (sofLeftInverse' h).symm x = g x :=\n  rfl\n\n"}
{"name":"RingEquiv.nonUnitalSubsemiringMap_symm_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\ns : NonUnitalSubsemiring R\ny : ↑(Set.image ⇑↑e.toAddEquiv ↑s.toAddSubmonoid)\n⊢ Eq (↑((e.nonUnitalSubsemiringMap s).symm y)) ((↑e).symm ↑y)","decl":"/-- Given an equivalence `e : R ≃+* S` of non-unital semirings and a non-unital subsemiring\n`s` of `R`, `non_unital_subsemiring_map e s` is the induced equivalence between `s` and\n`s.map e` -/\n@[simps!]\ndef nonUnitalSubsemiringMap (e : R ≃+* S) (s : NonUnitalSubsemiring R) :\n    s ≃+* NonUnitalSubsemiring.map e.toNonUnitalRingHom s :=\n  { e.toAddEquiv.addSubmonoidMap s.toAddSubmonoid,\n    e.toMulEquiv.subsemigroupMap s.toSubsemigroup with }\n\n"}
{"name":"RingEquiv.nonUnitalSubsemiringMap_apply_coe","module":"Mathlib.RingTheory.NonUnitalSubsemiring.Basic","initialProofState":"R : Type u\nS : Type v\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\ne : RingEquiv R S\ns : NonUnitalSubsemiring R\nx : ↑↑s.toAddSubmonoid\n⊢ Eq (↑((e.nonUnitalSubsemiringMap s) x)) (e ↑x)","decl":"/-- Given an equivalence `e : R ≃+* S` of non-unital semirings and a non-unital subsemiring\n`s` of `R`, `non_unital_subsemiring_map e s` is the induced equivalence between `s` and\n`s.map e` -/\n@[simps!]\ndef nonUnitalSubsemiringMap (e : R ≃+* S) (s : NonUnitalSubsemiring R) :\n    s ≃+* NonUnitalSubsemiring.map e.toNonUnitalRingHom s :=\n  { e.toAddEquiv.addSubmonoidMap s.toAddSubmonoid,\n    e.toMulEquiv.subsemigroupMap s.toSubsemigroup with }\n\n"}
