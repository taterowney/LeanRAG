{"name":"AddMonoid.not_isTorsion_iff","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\n⊢ Iff (Not (AddMonoid.IsTorsion G)) (Exists fun g => Not (IsOfFinAddOrder g))","decl":"/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\n@[to_additive (attr := simp) \"An additive monoid is not a torsion monoid if it\n  has an element of infinite order.\"]\ntheorem not_isTorsion_iff : ¬IsTorsion G ↔ ∃ g : G, ¬IsOfFinOrder g := by\n  rw [IsTorsion, not_forall]\n\n"}
{"name":"Monoid.not_isTorsion_iff","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Monoid G\n⊢ Iff (Not (Monoid.IsTorsion G)) (Exists fun g => Not (IsOfFinOrder g))","decl":"/-- A monoid is not a torsion monoid if it has an element of infinite order. -/\n@[to_additive (attr := simp) \"An additive monoid is not a torsion monoid if it\n  has an element of infinite order.\"]\ntheorem not_isTorsion_iff : ¬IsTorsion G ↔ ∃ g : G, ¬IsOfFinOrder g := by\n  rw [IsTorsion, not_forall]\n\n"}
{"name":"IsTorsion.addSubgroup","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ntG : AddMonoid.IsTorsion G\nH : AddSubgroup G\n⊢ AddMonoid.IsTorsion (Subtype fun x => Membership.mem H x)","decl":"/-- Subgroups of torsion groups are torsion groups. -/\n@[to_additive \"Subgroups of additive torsion groups are additive torsion groups.\"]\ntheorem IsTorsion.subgroup (tG : IsTorsion G) (H : Subgroup G) : IsTorsion H := fun h =>\n  Submonoid.isOfFinOrder_coe.1 <| tG h\n\n"}
{"name":"IsTorsion.subgroup","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Group G\ntG : Monoid.IsTorsion G\nH : Subgroup G\n⊢ Monoid.IsTorsion (Subtype fun x => Membership.mem H x)","decl":"/-- Subgroups of torsion groups are torsion groups. -/\n@[to_additive \"Subgroups of additive torsion groups are additive torsion groups.\"]\ntheorem IsTorsion.subgroup (tG : IsTorsion G) (H : Subgroup G) : IsTorsion H := fun h =>\n  Submonoid.isOfFinOrder_coe.1 <| tG h\n\n"}
{"name":"AddIsTorsion.of_surjective","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\nhf : Function.Surjective ⇑f\ntG : AddMonoid.IsTorsion G\n⊢ AddMonoid.IsTorsion H","decl":"/-- The image of a surjective torsion group homomorphism is torsion. -/\n@[to_additive AddIsTorsion.of_surjective\n      \"The image of a surjective additive torsion group homomorphism is torsion.\"]\ntheorem IsTorsion.of_surjective {f : G →* H} (hf : Function.Surjective f) (tG : IsTorsion G) :\n    IsTorsion H := fun h => by\n  obtain ⟨g, hg⟩ := hf h\n  rw [← hg]\n  exact f.isOfFinOrder (tG g)\n\n"}
{"name":"IsTorsion.of_surjective","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\ninst✝ : Group H\nf : MonoidHom G H\nhf : Function.Surjective ⇑f\ntG : Monoid.IsTorsion G\n⊢ Monoid.IsTorsion H","decl":"/-- The image of a surjective torsion group homomorphism is torsion. -/\n@[to_additive AddIsTorsion.of_surjective\n      \"The image of a surjective additive torsion group homomorphism is torsion.\"]\ntheorem IsTorsion.of_surjective {f : G →* H} (hf : Function.Surjective f) (tG : IsTorsion G) :\n    IsTorsion H := fun h => by\n  obtain ⟨g, hg⟩ := hf h\n  rw [← hg]\n  exact f.isOfFinOrder (tG g)\n\n"}
{"name":"IsTorsion.extension_closed","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\nN : Subgroup G\ninst✝ : Group H\nf : MonoidHom G H\nhN : Eq N f.ker\ntH : Monoid.IsTorsion H\ntN : Monoid.IsTorsion (Subtype fun x => Membership.mem N x)\n⊢ Monoid.IsTorsion G","decl":"/-- Torsion groups are closed under extensions. -/\n@[to_additive AddIsTorsion.extension_closed \"Additive torsion groups are closed under extensions.\"]\ntheorem IsTorsion.extension_closed {f : G →* H} (hN : N = f.ker) (tH : IsTorsion H)\n    (tN : IsTorsion N) : IsTorsion G := fun g => by\n  obtain ⟨ngn, ngnpos, hngn⟩ := (tH <| f g).exists_pow_eq_one\n  have hmem := MonoidHom.mem_ker.mpr ((f.map_pow g ngn).trans hngn)\n  lift g ^ ngn to N using hN.symm ▸ hmem with gn h\n  obtain ⟨nn, nnpos, hnn⟩ := (tN gn).exists_pow_eq_one\n  exact isOfFinOrder_iff_pow_eq_one.mpr <| ⟨ngn * nn, mul_pos ngnpos nnpos, by\n      rw [pow_mul, ← h, ← Subgroup.coe_pow, hnn, Subgroup.coe_one]⟩\n\n"}
{"name":"AddIsTorsion.extension_closed","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\nN : AddSubgroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\nhN : Eq N f.ker\ntH : AddMonoid.IsTorsion H\ntN : AddMonoid.IsTorsion (Subtype fun x => Membership.mem N x)\n⊢ AddMonoid.IsTorsion G","decl":"/-- Torsion groups are closed under extensions. -/\n@[to_additive AddIsTorsion.extension_closed \"Additive torsion groups are closed under extensions.\"]\ntheorem IsTorsion.extension_closed {f : G →* H} (hN : N = f.ker) (tH : IsTorsion H)\n    (tN : IsTorsion N) : IsTorsion G := fun g => by\n  obtain ⟨ngn, ngnpos, hngn⟩ := (tH <| f g).exists_pow_eq_one\n  have hmem := MonoidHom.mem_ker.mpr ((f.map_pow g ngn).trans hngn)\n  lift g ^ ngn to N using hN.symm ▸ hmem with gn h\n  obtain ⟨nn, nnpos, hnn⟩ := (tN gn).exists_pow_eq_one\n  exact isOfFinOrder_iff_pow_eq_one.mpr <| ⟨ngn * nn, mul_pos ngnpos nnpos, by\n      rw [pow_mul, ← h, ← Subgroup.coe_pow, hnn, Subgroup.coe_one]⟩\n\n"}
{"name":"IsTorsion.quotient_iff","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : Group G\nN : Subgroup G\ninst✝ : Group H\nf : MonoidHom G H\nhf : Function.Surjective ⇑f\nhN : Eq N f.ker\ntN : Monoid.IsTorsion (Subtype fun x => Membership.mem N x)\n⊢ Iff (Monoid.IsTorsion H) (Monoid.IsTorsion G)","decl":"/-- The image of a quotient is torsion iff the group is torsion. -/\n@[to_additive AddIsTorsion.quotient_iff\n      \"The image of a quotient is additively torsion iff the group is torsion.\"]\ntheorem IsTorsion.quotient_iff {f : G →* H} (hf : Function.Surjective f) (hN : N = f.ker)\n    (tN : IsTorsion N) : IsTorsion H ↔ IsTorsion G :=\n  ⟨fun tH => IsTorsion.extension_closed hN tH tN, fun tG => IsTorsion.of_surjective hf tG⟩\n\n"}
{"name":"AddIsTorsion.quotient_iff","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\nH : Type u_2\ninst✝¹ : AddGroup G\nN : AddSubgroup G\ninst✝ : AddGroup H\nf : AddMonoidHom G H\nhf : Function.Surjective ⇑f\nhN : Eq N f.ker\ntN : AddMonoid.IsTorsion (Subtype fun x => Membership.mem N x)\n⊢ Iff (AddMonoid.IsTorsion H) (AddMonoid.IsTorsion G)","decl":"/-- The image of a quotient is torsion iff the group is torsion. -/\n@[to_additive AddIsTorsion.quotient_iff\n      \"The image of a quotient is additively torsion iff the group is torsion.\"]\ntheorem IsTorsion.quotient_iff {f : G →* H} (hf : Function.Surjective f) (hN : N = f.ker)\n    (tN : IsTorsion N) : IsTorsion H ↔ IsTorsion G :=\n  ⟨fun tH => IsTorsion.extension_closed hN tH tN, fun tG => IsTorsion.of_surjective hf tG⟩\n\n"}
{"name":"ExponentExists.is_add_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nh : AddMonoid.ExponentExists G\n⊢ AddMonoid.IsTorsion G","decl":"/-- If a group exponent exists, the group is torsion. -/\n@[to_additive ExponentExists.is_add_torsion\n      \"If a group exponent exists, the group is additively torsion.\"]\ntheorem ExponentExists.isTorsion (h : ExponentExists G) : IsTorsion G := fun g => by\n  obtain ⟨n, npos, hn⟩ := h\n  exact isOfFinOrder_iff_pow_eq_one.mpr ⟨n, npos, hn g⟩\n\n"}
{"name":"ExponentExists.isTorsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Group G\nh : Monoid.ExponentExists G\n⊢ Monoid.IsTorsion G","decl":"/-- If a group exponent exists, the group is torsion. -/\n@[to_additive ExponentExists.is_add_torsion\n      \"If a group exponent exists, the group is additively torsion.\"]\ntheorem ExponentExists.isTorsion (h : ExponentExists G) : IsTorsion G := fun g => by\n  obtain ⟨n, npos, hn⟩ := h\n  exact isOfFinOrder_iff_pow_eq_one.mpr ⟨n, npos, hn g⟩\n\n"}
{"name":"IsAddTorsion.exponentExists","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ntG : AddMonoid.IsTorsion G\nbounded : (Set.range fun g => addOrderOf g).Finite\n⊢ AddMonoid.ExponentExists G","decl":"/-- The group exponent exists for any bounded torsion group. -/\n@[to_additive IsAddTorsion.exponentExists\n      \"The group exponent exists for any bounded additive torsion group.\"]\ntheorem IsTorsion.exponentExists (tG : IsTorsion G)\n    (bounded : (Set.range fun g : G => orderOf g).Finite) : ExponentExists G :=\n  exponent_ne_zero.mp <|\n    (exponent_ne_zero_iff_range_orderOf_finite fun g => (tG g).orderOf_pos).mpr bounded\n\n"}
{"name":"IsTorsion.exponentExists","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Group G\ntG : Monoid.IsTorsion G\nbounded : (Set.range fun g => orderOf g).Finite\n⊢ Monoid.ExponentExists G","decl":"/-- The group exponent exists for any bounded torsion group. -/\n@[to_additive IsAddTorsion.exponentExists\n      \"The group exponent exists for any bounded additive torsion group.\"]\ntheorem IsTorsion.exponentExists (tG : IsTorsion G)\n    (bounded : (Set.range fun g : G => orderOf g).Finite) : ExponentExists G :=\n  exponent_ne_zero.mp <|\n    (exponent_ne_zero_iff_range_orderOf_finite fun g => (tG g).orderOf_pos).mpr bounded\n\n"}
{"name":"isTorsion_of_finite","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝¹ : Group G\ninst✝ : Finite G\n⊢ Monoid.IsTorsion G","decl":"/-- Finite groups are torsion groups. -/\n@[to_additive is_add_torsion_of_finite \"Finite additive groups are additive torsion groups.\"]\ntheorem isTorsion_of_finite [Finite G] : IsTorsion G :=\n  ExponentExists.isTorsion .of_finite\n\n"}
{"name":"is_add_torsion_of_finite","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝¹ : AddGroup G\ninst✝ : Finite G\n⊢ AddMonoid.IsTorsion G","decl":"/-- Finite groups are torsion groups. -/\n@[to_additive is_add_torsion_of_finite \"Finite additive groups are additive torsion groups.\"]\ntheorem isTorsion_of_finite [Finite G] : IsTorsion G :=\n  ExponentExists.isTorsion .of_finite\n\n"}
{"name":"AddMonoid.IsTorsion.module_of_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝² : AddCommMonoid M\ninst✝¹ : Semiring R\ninst✝ : Module R M\ntR : AddMonoid.IsTorsion R\n⊢ AddMonoid.IsTorsion M","decl":"/-- A module whose scalars are additively torsion is additively torsion. -/\ntheorem IsTorsion.module_of_torsion [Semiring R] [Module R M] (tR : IsTorsion R) : IsTorsion M :=\n  fun f =>\n  isOfFinAddOrder_iff_nsmul_eq_zero.mpr <| by\n    obtain ⟨n, npos, hn⟩ := (tR 1).exists_nsmul_eq_zero\n    exact ⟨n, npos, by simp only [← Nat.cast_smul_eq_nsmul R _ f, ← nsmul_one, hn, zero_smul]⟩\n\n"}
{"name":"AddMonoid.IsTorsion.module_of_finite","module":"Mathlib.GroupTheory.Torsion","initialProofState":"R : Type u_3\nM : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : Ring R\ninst✝¹ : Finite R\ninst✝ : Module R M\n⊢ AddMonoid.IsTorsion M","decl":"/-- A module with a finite ring of scalars is additively torsion. -/\ntheorem IsTorsion.module_of_finite [Ring R] [Finite R] [Module R M] : IsTorsion M :=\n  (is_add_torsion_of_finite : IsTorsion R).module_of_torsion _ _\n\n"}
{"name":"AddCommMonoid.addTorsion.isTorsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\n⊢ AddMonoid.IsTorsion (Subtype fun x => Membership.mem (AddCommMonoid.addTorsion G) x)","decl":"/-- Torsion submonoids are torsion. -/\n@[to_additive \"Additive torsion submonoids are additively torsion.\"]\ntheorem torsion.isTorsion : IsTorsion <| torsion G := fun ⟨x, n, npos, hn⟩ =>\n  ⟨n, npos,\n    Subtype.ext <| by\n      dsimp\n      rw [mul_left_iterate]\n      change _ * 1 = 1\n      rw [_root_.mul_one, SubmonoidClass.coe_pow, Subtype.coe_mk,\n        (isPeriodicPt_mul_iff_pow_eq_one _).mp hn]⟩\n\n"}
{"name":"CommMonoid.torsion.isTorsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\n⊢ Monoid.IsTorsion (Subtype fun x => Membership.mem (CommMonoid.torsion G) x)","decl":"/-- Torsion submonoids are torsion. -/\n@[to_additive \"Additive torsion submonoids are additively torsion.\"]\ntheorem torsion.isTorsion : IsTorsion <| torsion G := fun ⟨x, n, npos, hn⟩ =>\n  ⟨n, npos,\n    Subtype.ext <| by\n      dsimp\n      rw [mul_left_iterate]\n      change _ * 1 = 1\n      rw [_root_.mul_one, SubmonoidClass.coe_pow, Subtype.coe_mk,\n        (isPeriodicPt_mul_iff_pow_eq_one _).mp hn]⟩\n\n"}
{"name":"CommMonoid.coe_primaryComponent","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑(CommMonoid.primaryComponent G p)) (setOf fun g => Exists fun n => Eq (orderOf g) (HPow.hPow p n))","decl":"/-- The `p`-primary component is the submonoid of elements with order prime-power of `p`. -/\n@[to_additive (attr := simps)\n      \"The `p`-primary component is the submonoid of elements with additive\n      order prime-power of `p`.\"]\ndef primaryComponent : Submonoid G where\n  carrier := { g | ∃ n : ℕ, orderOf g = p ^ n }\n  one_mem' := ⟨0, by rw [pow_zero, orderOf_one]⟩\n  mul_mem' hg₁ hg₂ :=\n    exists_orderOf_eq_prime_pow_iff.mpr <| by\n      obtain ⟨m, hm⟩ := exists_orderOf_eq_prime_pow_iff.mp hg₁\n      obtain ⟨n, hn⟩ := exists_orderOf_eq_prime_pow_iff.mp hg₂\n      exact\n        ⟨m + n, by\n          rw [mul_pow, pow_add, pow_mul, hm, one_pow, Monoid.one_mul, mul_comm, pow_mul, hn,\n            one_pow]⟩\n\n"}
{"name":"AddCommMonoid.coe_primaryComponent","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑(AddCommMonoid.primaryComponent G p)) (setOf fun g => Exists fun n => Eq (addOrderOf g) (HPow.hPow p n))","decl":"/-- The `p`-primary component is the submonoid of elements with order prime-power of `p`. -/\n@[to_additive (attr := simps)\n      \"The `p`-primary component is the submonoid of elements with additive\n      order prime-power of `p`.\"]\ndef primaryComponent : Submonoid G where\n  carrier := { g | ∃ n : ℕ, orderOf g = p ^ n }\n  one_mem' := ⟨0, by rw [pow_zero, orderOf_one]⟩\n  mul_mem' hg₁ hg₂ :=\n    exists_orderOf_eq_prime_pow_iff.mpr <| by\n      obtain ⟨m, hm⟩ := exists_orderOf_eq_prime_pow_iff.mp hg₁\n      obtain ⟨n, hn⟩ := exists_orderOf_eq_prime_pow_iff.mp hg₂\n      exact\n        ⟨m + n, by\n          rw [mul_pow, pow_add, pow_mul, hm, one_pow, Monoid.one_mul, mul_comm, pow_mul, hn,\n            one_pow]⟩\n\n"}
{"name":"CommMonoid.primaryComponent.exists_orderOf_eq_prime_pow","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\np : Nat\nhp : Fact (Nat.Prime p)\ng : Subtype fun x => Membership.mem (CommMonoid.primaryComponent G p) x\n⊢ Exists fun n => Eq (orderOf g) (HPow.hPow p n)","decl":"/-- Elements of the `p`-primary component have order `p^n` for some `n`. -/\n@[to_additive primaryComponent.exists_orderOf_eq_prime_nsmul\n  \"Elements of the `p`-primary component have additive order `p^n` for some `n`\"]\ntheorem primaryComponent.exists_orderOf_eq_prime_pow (g : CommMonoid.primaryComponent G p) :\n    ∃ n : ℕ, orderOf g = p ^ n := by\n      obtain ⟨_, hn⟩ := g.property\n      rw [orderOf_submonoid g] at hn\n      exact ⟨_, hn⟩\n\n"}
{"name":"AddCommMonoid.primaryComponent.exists_orderOf_eq_prime_nsmul","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\np : Nat\nhp : Fact (Nat.Prime p)\ng : Subtype fun x => Membership.mem (AddCommMonoid.primaryComponent G p) x\n⊢ Exists fun n => Eq (addOrderOf g) (HPow.hPow p n)","decl":"/-- Elements of the `p`-primary component have order `p^n` for some `n`. -/\n@[to_additive primaryComponent.exists_orderOf_eq_prime_nsmul\n  \"Elements of the `p`-primary component have additive order `p^n` for some `n`\"]\ntheorem primaryComponent.exists_orderOf_eq_prime_pow (g : CommMonoid.primaryComponent G p) :\n    ∃ n : ℕ, orderOf g = p ^ n := by\n      obtain ⟨_, hn⟩ := g.property\n      rw [orderOf_submonoid g] at hn\n      exact ⟨_, hn⟩\n\n"}
{"name":"CommMonoid.primaryComponent.disjoint","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\np : Nat\nhp : Fact (Nat.Prime p)\np' : Nat\nhp' : Fact (Nat.Prime p')\nhne : Ne p p'\n⊢ Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p')","decl":"/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\n@[to_additive \"The `p`- and `q`-primary components are disjoint for `p ≠ q`.\"]\ntheorem primaryComponent.disjoint {p' : ℕ} [hp' : Fact p'.Prime] (hne : p ≠ p') :\n    Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n  Submonoid.disjoint_def.mpr <| by\n    rintro g ⟨_ | n, hn⟩ ⟨n', hn'⟩\n    · rwa [pow_zero, orderOf_eq_one_iff] at hn\n    · exact\n        absurd (eq_of_prime_pow_eq hp.out.prime hp'.out.prime n.succ_pos (hn.symm.trans hn')) hne\n\n"}
{"name":"AddCommMonoid.primaryComponent.disjoint","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\np : Nat\nhp : Fact (Nat.Prime p)\np' : Nat\nhp' : Fact (Nat.Prime p')\nhne : Ne p p'\n⊢ Disjoint (AddCommMonoid.primaryComponent G p) (AddCommMonoid.primaryComponent G p')","decl":"/-- The `p`- and `q`-primary components are disjoint for `p ≠ q`. -/\n@[to_additive \"The `p`- and `q`-primary components are disjoint for `p ≠ q`.\"]\ntheorem primaryComponent.disjoint {p' : ℕ} [hp' : Fact p'.Prime] (hne : p ≠ p') :\n    Disjoint (CommMonoid.primaryComponent G p) (CommMonoid.primaryComponent G p') :=\n  Submonoid.disjoint_def.mpr <| by\n    rintro g ⟨_ | n, hn⟩ ⟨n', hn'⟩\n    · rwa [pow_zero, orderOf_eq_one_iff] at hn\n    · exact\n        absurd (eq_of_prime_pow_eq hp.out.prime hp'.out.prime n.succ_pos (hn.symm.trans hn')) hne\n\n"}
{"name":"AddMonoid.IsTorsion.torsion_eq_top","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\ntG : AddMonoid.IsTorsion G\n⊢ Eq (AddCommMonoid.addTorsion G) Top.top","decl":"/-- The torsion submonoid of a torsion monoid is `⊤`. -/\n@[to_additive (attr := simp) \"The additive torsion submonoid of an additive torsion monoid is `⊤`.\"]\ntheorem torsion_eq_top (tG : IsTorsion G) : torsion G = ⊤ := by ext; tauto\n\n"}
{"name":"Monoid.IsTorsion.torsion_eq_top","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\ntG : Monoid.IsTorsion G\n⊢ Eq (CommMonoid.torsion G) Top.top","decl":"/-- The torsion submonoid of a torsion monoid is `⊤`. -/\n@[to_additive (attr := simp) \"The additive torsion submonoid of an additive torsion monoid is `⊤`.\"]\ntheorem torsion_eq_top (tG : IsTorsion G) : torsion G = ⊤ := by ext; tauto\n\n"}
{"name":"AddMonoid.IsTorsion.torsionAddEquiv_apply","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\ntG : AddMonoid.IsTorsion G\na : Subtype fun x => Membership.mem (AddCommMonoid.addTorsion G) x\n⊢ Eq (tG.torsionAddEquiv a) ↑((AddEquiv.addSubmonoidCongr ⋯) a)","decl":"@[to_additive]\ntheorem torsionMulEquiv_apply (tG : IsTorsion G) (a : torsion G) :\n    tG.torsionMulEquiv a = MulEquiv.submonoidCongr tG.torsion_eq_top a :=\n  rfl\n\n"}
{"name":"Monoid.IsTorsion.torsionMulEquiv_apply","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\ntG : Monoid.IsTorsion G\na : Subtype fun x => Membership.mem (CommMonoid.torsion G) x\n⊢ Eq (tG.torsionMulEquiv a) ↑((MulEquiv.submonoidCongr ⋯) a)","decl":"@[to_additive]\ntheorem torsionMulEquiv_apply (tG : IsTorsion G) (a : torsion G) :\n    tG.torsionMulEquiv a = MulEquiv.submonoidCongr tG.torsion_eq_top a :=\n  rfl\n\n"}
{"name":"Monoid.IsTorsion.torsionMulEquiv_symm_apply_coe","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommMonoid G\ntG : Monoid.IsTorsion G\na : G\n⊢ Eq (tG.torsionMulEquiv.symm a) ⟨↑(Submonoid.topEquiv.symm a), ⋯⟩","decl":"@[to_additive]\ntheorem torsionMulEquiv_symm_apply_coe (tG : IsTorsion G) (a : G) :\n    tG.torsionMulEquiv.symm a = ⟨Submonoid.topEquiv.symm a, tG _⟩ :=\n  rfl\n\n"}
{"name":"AddMonoid.IsTorsion.torsionAddEquiv_symm_apply_coe","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommMonoid G\ntG : AddMonoid.IsTorsion G\na : G\n⊢ Eq (tG.torsionAddEquiv.symm a) ⟨↑(AddSubmonoid.topEquiv.symm a), ⋯⟩","decl":"@[to_additive]\ntheorem torsionMulEquiv_symm_apply_coe (tG : IsTorsion G) (a : G) :\n    tG.torsionMulEquiv.symm a = ⟨Submonoid.topEquiv.symm a, tG _⟩ :=\n  rfl\n\n"}
{"name":"CommGroup.torsion_eq_torsion_submonoid","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\n⊢ Eq (CommMonoid.torsion G) (CommGroup.torsion G).toSubmonoid","decl":"/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\n@[to_additive add_torsion_eq_add_torsion_submonoid\n      \"The additive torsion submonoid of an abelian group equals the torsion\n      subgroup as a submonoid.\"]\ntheorem torsion_eq_torsion_submonoid : CommMonoid.torsion G = (torsion G).toSubmonoid :=\n  rfl\n\n"}
{"name":"AddCommGroup.add_torsion_eq_add_torsion_submonoid","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\n⊢ Eq (AddCommMonoid.addTorsion G) (AddCommGroup.torsion G).toAddSubmonoid","decl":"/-- The torsion submonoid of an abelian group equals the torsion subgroup as a submonoid. -/\n@[to_additive add_torsion_eq_add_torsion_submonoid\n      \"The additive torsion submonoid of an abelian group equals the torsion\n      subgroup as a submonoid.\"]\ntheorem torsion_eq_torsion_submonoid : CommMonoid.torsion G = (torsion G).toSubmonoid :=\n  rfl\n\n"}
{"name":"AddCommGroup.mem_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\ng : G\n⊢ Iff (Membership.mem (AddCommGroup.torsion G) g) (IsOfFinAddOrder g)","decl":"@[to_additive]\ntheorem mem_torsion (g : G) : g ∈ torsion G ↔ IsOfFinOrder g := Iff.rfl\n\n"}
{"name":"CommGroup.mem_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\ng : G\n⊢ Iff (Membership.mem (CommGroup.torsion G) g) (IsOfFinOrder g)","decl":"@[to_additive]\ntheorem mem_torsion (g : G) : g ∈ torsion G ↔ IsOfFinOrder g := Iff.rfl\n\n"}
{"name":"AddCommGroup.coe_primaryComponent","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑(AddCommGroup.primaryComponent G p)) (setOf fun g => Exists fun n => Eq (addOrderOf g) (HPow.hPow p n))","decl":"/-- The `p`-primary component is the subgroup of elements with order prime-power of `p`. -/\n@[to_additive (attr := simps!)\n      \"The `p`-primary component is the subgroup of elements with additive order\n      prime-power of `p`.\"]\ndef primaryComponent : Subgroup G :=\n  { CommMonoid.primaryComponent G p with\n    inv_mem' := fun {g} ⟨n, hn⟩ => ⟨n, (orderOf_inv g).trans hn⟩ }\n\n"}
{"name":"CommGroup.coe_primaryComponent","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ Eq (↑(CommGroup.primaryComponent G p)) (setOf fun g => Exists fun n => Eq (orderOf g) (HPow.hPow p n))","decl":"/-- The `p`-primary component is the subgroup of elements with order prime-power of `p`. -/\n@[to_additive (attr := simps!)\n      \"The `p`-primary component is the subgroup of elements with additive order\n      prime-power of `p`.\"]\ndef primaryComponent : Subgroup G :=\n  { CommMonoid.primaryComponent G p with\n    inv_mem' := fun {g} ⟨n, hn⟩ => ⟨n, (orderOf_inv g).trans hn⟩ }\n\n"}
{"name":"CommGroup.primaryComponent.isPGroup","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\np : Nat\nhp : Fact (Nat.Prime p)\n⊢ IsPGroup p (Subtype fun x => Membership.mem (CommGroup.primaryComponent G p) x)","decl":"/-- The `p`-primary component is a `p` group. -/\ntheorem primaryComponent.isPGroup : IsPGroup p <| primaryComponent G p := fun g =>\n  (propext exists_orderOf_eq_prime_pow_iff.symm).mpr\n    (CommMonoid.primaryComponent.exists_orderOf_eq_prime_pow g)\n\n"}
{"name":"Monoid.not_isTorsionFree_iff","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Monoid G\n⊢ Iff (Not (Monoid.IsTorsionFree G)) (Exists fun g => And (Ne g 1) (IsOfFinOrder g))","decl":"/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\n@[to_additive (attr := simp) \"An additive monoid is not torsion free if any\n  nontrivial element has finite order.\"]\ntheorem not_isTorsionFree_iff : ¬IsTorsionFree G ↔ ∃ g : G, g ≠ 1 ∧ IsOfFinOrder g := by\n  simp_rw [IsTorsionFree, Ne, not_forall, Classical.not_not, exists_prop]\n\n"}
{"name":"AddMonoid.not_isTorsionFree_iff","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddMonoid G\n⊢ Iff (Not (AddMonoid.IsTorsionFree G)) (Exists fun g => And (Ne g 0) (IsOfFinAddOrder g))","decl":"/-- A nontrivial monoid is not torsion-free if any nontrivial element has finite order. -/\n@[to_additive (attr := simp) \"An additive monoid is not torsion free if any\n  nontrivial element has finite order.\"]\ntheorem not_isTorsionFree_iff : ¬IsTorsionFree G ↔ ∃ g : G, g ≠ 1 ∧ IsOfFinOrder g := by\n  simp_rw [IsTorsionFree, Ne, not_forall, Classical.not_not, exists_prop]\n\n"}
{"name":"AddMonoid.isTorsionFree_of_subsingleton","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝¹ : AddMonoid G\ninst✝ : Subsingleton G\n⊢ AddMonoid.IsTorsionFree G","decl":"@[to_additive (attr := simp)]\nlemma isTorsionFree_of_subsingleton [Subsingleton G] : IsTorsionFree G :=\n  fun _a ha _ => ha <| Subsingleton.elim _ _\n\n"}
{"name":"Monoid.isTorsionFree_of_subsingleton","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝¹ : Monoid G\ninst✝ : Subsingleton G\n⊢ Monoid.IsTorsionFree G","decl":"@[to_additive (attr := simp)]\nlemma isTorsionFree_of_subsingleton [Subsingleton G] : IsTorsionFree G :=\n  fun _a ha _ => ha <| Subsingleton.elim _ _\n\n"}
{"name":"Monoid.isTorsionFree_iff_torsion_eq_bot","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_3\ninst✝ : CommGroup G\n⊢ Iff (Monoid.IsTorsionFree G) (Eq (CommGroup.torsion G) Bot.bot)","decl":"@[to_additive]\nlemma isTorsionFree_iff_torsion_eq_bot {G} [CommGroup G] :\n    IsTorsionFree G ↔ CommGroup.torsion G = ⊥ := by\n  rw [IsTorsionFree, eq_bot_iff, SetLike.le_def]\n  simp [not_imp_not, CommGroup.mem_torsion]\n\n"}
{"name":"AddMonoid.isTorsionFree_iff_torsion_eq_bot","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_3\ninst✝ : AddCommGroup G\n⊢ Iff (AddMonoid.IsTorsionFree G) (Eq (AddCommGroup.torsion G) Bot.bot)","decl":"@[to_additive]\nlemma isTorsionFree_iff_torsion_eq_bot {G} [CommGroup G] :\n    IsTorsionFree G ↔ CommGroup.torsion G = ⊥ := by\n  rw [IsTorsionFree, eq_bot_iff, SetLike.le_def]\n  simp [not_imp_not, CommGroup.mem_torsion]\n\n"}
{"name":"Monoid.IsTorsion.not_torsion_free","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Group G\nhN : Nontrivial G\na✝ : Monoid.IsTorsion G\n⊢ Not (Monoid.IsTorsionFree G)","decl":"/-- A nontrivial torsion group is not torsion-free. -/\n@[to_additive \"A nontrivial additive torsion group is not torsion-free.\"]\ntheorem IsTorsion.not_torsion_free [hN : Nontrivial G] : IsTorsion G → ¬IsTorsionFree G := fun tG =>\n  not_isTorsionFree_iff.mpr <| by\n    obtain ⟨x, hx⟩ := (nontrivial_iff_exists_ne (1 : G)).mp hN\n    exact ⟨x, hx, tG x⟩\n\n"}
{"name":"AddMonoid.IsTorsion.not_torsion_free","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nhN : Nontrivial G\na✝ : AddMonoid.IsTorsion G\n⊢ Not (AddMonoid.IsTorsionFree G)","decl":"/-- A nontrivial torsion group is not torsion-free. -/\n@[to_additive \"A nontrivial additive torsion group is not torsion-free.\"]\ntheorem IsTorsion.not_torsion_free [hN : Nontrivial G] : IsTorsion G → ¬IsTorsionFree G := fun tG =>\n  not_isTorsionFree_iff.mpr <| by\n    obtain ⟨x, hx⟩ := (nontrivial_iff_exists_ne (1 : G)).mp hN\n    exact ⟨x, hx, tG x⟩\n\n"}
{"name":"AddMonoid.IsTorsionFree.not_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\nhN : Nontrivial G\na✝ : AddMonoid.IsTorsionFree G\n⊢ Not (AddMonoid.IsTorsion G)","decl":"/-- A nontrivial torsion-free group is not torsion. -/\n@[to_additive \"A nontrivial torsion-free additive group is not torsion.\"]\ntheorem IsTorsionFree.not_torsion [hN : Nontrivial G] : IsTorsionFree G → ¬IsTorsion G := fun tfG =>\n  (not_isTorsion_iff _).mpr <| by\n    obtain ⟨x, hx⟩ := (nontrivial_iff_exists_ne (1 : G)).mp hN\n    exact ⟨x, (tfG x) hx⟩\n\n"}
{"name":"Monoid.IsTorsionFree.not_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Group G\nhN : Nontrivial G\na✝ : Monoid.IsTorsionFree G\n⊢ Not (Monoid.IsTorsion G)","decl":"/-- A nontrivial torsion-free group is not torsion. -/\n@[to_additive \"A nontrivial torsion-free additive group is not torsion.\"]\ntheorem IsTorsionFree.not_torsion [hN : Nontrivial G] : IsTorsionFree G → ¬IsTorsion G := fun tfG =>\n  (not_isTorsion_iff _).mpr <| by\n    obtain ⟨x, hx⟩ := (nontrivial_iff_exists_ne (1 : G)).mp hN\n    exact ⟨x, (tfG x) hx⟩\n\n"}
{"name":"Monoid.IsTorsionFree.subgroup","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : Group G\ntG : Monoid.IsTorsionFree G\nH : Subgroup G\n⊢ Monoid.IsTorsionFree (Subtype fun x => Membership.mem H x)","decl":"/-- Subgroups of torsion-free groups are torsion-free. -/\n@[to_additive \"Subgroups of additive torsion-free groups are additively torsion-free.\"]\ntheorem IsTorsionFree.subgroup (tG : IsTorsionFree G) (H : Subgroup G) : IsTorsionFree H :=\n  fun h hne ↦ Submonoid.isOfFinOrder_coe.not.1 <| tG h <| by norm_cast\n\n"}
{"name":"AddMonoid.IsTorsionFree.addSubgroup","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\ntG : AddMonoid.IsTorsionFree G\nH : AddSubgroup G\n⊢ AddMonoid.IsTorsionFree (Subtype fun x => Membership.mem H x)","decl":"/-- Subgroups of torsion-free groups are torsion-free. -/\n@[to_additive \"Subgroups of additive torsion-free groups are additively torsion-free.\"]\ntheorem IsTorsionFree.subgroup (tG : IsTorsionFree G) (H : Subgroup G) : IsTorsionFree H :=\n  fun h hne ↦ Submonoid.isOfFinOrder_coe.not.1 <| tG h <| by norm_cast\n\n"}
{"name":"AddMonoid.IsTorsionFree.prod","module":"Mathlib.GroupTheory.Torsion","initialProofState":"η : Type u_3\nGs : η → Type u_4\ninst✝ : (i : η) → AddGroup (Gs i)\ntfGs : ∀ (i : η), AddMonoid.IsTorsionFree (Gs i)\n⊢ AddMonoid.IsTorsionFree ((i : η) → Gs i)","decl":"/-- Direct products of torsion free groups are torsion free. -/\n@[to_additive AddMonoid.IsTorsionFree.prod\n      \"Direct products of additive torsion free groups are torsion free.\"]\ntheorem IsTorsionFree.prod {η : Type*} {Gs : η → Type*} [∀ i, Group (Gs i)]\n    (tfGs : ∀ i, IsTorsionFree (Gs i)) : IsTorsionFree <| ∀ i, Gs i := fun w hne h =>\n  hne <|\n    funext fun i => Classical.not_not.mp <| mt (tfGs i (w i)) <| Classical.not_not.mpr <| h.apply i\n\n"}
{"name":"Monoid.IsTorsionFree.prod","module":"Mathlib.GroupTheory.Torsion","initialProofState":"η : Type u_3\nGs : η → Type u_4\ninst✝ : (i : η) → Group (Gs i)\ntfGs : ∀ (i : η), Monoid.IsTorsionFree (Gs i)\n⊢ Monoid.IsTorsionFree ((i : η) → Gs i)","decl":"/-- Direct products of torsion free groups are torsion free. -/\n@[to_additive AddMonoid.IsTorsionFree.prod\n      \"Direct products of additive torsion free groups are torsion free.\"]\ntheorem IsTorsionFree.prod {η : Type*} {Gs : η → Type*} [∀ i, Group (Gs i)]\n    (tfGs : ∀ i, IsTorsionFree (Gs i)) : IsTorsionFree <| ∀ i, Gs i := fun w hne h =>\n  hne <|\n    funext fun i => Classical.not_not.mp <| mt (tfGs i (w i)) <| Classical.not_not.mpr <| h.apply i\n\n"}
{"name":"AddMonoid.IsTorsionFree.quotient_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddCommGroup G\n⊢ AddMonoid.IsTorsionFree (HasQuotient.Quotient G (AddCommGroup.torsion G))","decl":"/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\n@[to_additive\n\"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"]\ntheorem IsTorsionFree.quotient_torsion : IsTorsionFree <| G ⧸ torsion G := fun g hne hfin =>\n  hne <| by\n    induction' g using QuotientGroup.induction_on with g\n    obtain ⟨m, mpos, hm⟩ := hfin.exists_pow_eq_one\n    obtain ⟨n, npos, hn⟩ := ((QuotientGroup.eq_one_iff _).mp hm).exists_pow_eq_one\n    exact\n      (QuotientGroup.eq_one_iff g).mpr\n        (isOfFinOrder_iff_pow_eq_one.mpr ⟨m * n, mul_pos mpos npos, (pow_mul g m n).symm ▸ hn⟩)\n\n"}
{"name":"Monoid.IsTorsionFree.quotient_torsion","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : CommGroup G\n⊢ Monoid.IsTorsionFree (HasQuotient.Quotient G (CommGroup.torsion G))","decl":"/-- Quotienting a group by its torsion subgroup yields a torsion free group. -/\n@[to_additive\n\"Quotienting a group by its additive torsion subgroup yields an additive torsion free group.\"]\ntheorem IsTorsionFree.quotient_torsion : IsTorsionFree <| G ⧸ torsion G := fun g hne hfin =>\n  hne <| by\n    induction' g using QuotientGroup.induction_on with g\n    obtain ⟨m, mpos, hm⟩ := hfin.exists_pow_eq_one\n    obtain ⟨n, npos, hn⟩ := ((QuotientGroup.eq_one_iff _).mp hm).exists_pow_eq_one\n    exact\n      (QuotientGroup.eq_one_iff g).mpr\n        (isOfFinOrder_iff_pow_eq_one.mpr ⟨m * n, mul_pos mpos npos, (pow_mul g m n).symm ▸ hn⟩)\n\n"}
{"name":"AddMonoid.isTorsionFree_iff_noZeroSMulDivisors_nat","module":"Mathlib.GroupTheory.Torsion","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\n⊢ Iff (AddMonoid.IsTorsionFree M) (NoZeroSMulDivisors Nat M)","decl":"lemma isTorsionFree_iff_noZeroSMulDivisors_nat {M : Type*} [AddMonoid M] :\n    IsTorsionFree M ↔ NoZeroSMulDivisors ℕ M := by\n  simp_rw [AddMonoid.IsTorsionFree, isOfFinAddOrder_iff_nsmul_eq_zero, not_exists, not_and,\n    pos_iff_ne_zero, noZeroSMulDivisors_iff, forall_swap (β := ℕ)]\n  exact forall₂_congr fun _ _ ↦ by tauto\n\n"}
{"name":"AddMonoid.isTorsionFree_iff_noZeroSMulDivisors_int","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\n⊢ Iff (AddMonoid.IsTorsionFree G) (NoZeroSMulDivisors Int G)","decl":"lemma isTorsionFree_iff_noZeroSMulDivisors_int [AddGroup G] :\n    IsTorsionFree G ↔ NoZeroSMulDivisors ℤ G := by\n  simp_rw [AddMonoid.IsTorsionFree, isOfFinAddOrder_iff_zsmul_eq_zero, not_exists, not_and,\n    noZeroSMulDivisors_iff, forall_swap (β := ℤ)]\n  exact forall₂_congr fun _ _ ↦ by tauto\n\n"}
{"name":"AddMonoid.IsTorsionFree.of_noZeroSMulDivisors","module":"Mathlib.GroupTheory.Torsion","initialProofState":"M : Type u_3\ninst✝¹ : AddMonoid M\ninst✝ : NoZeroSMulDivisors Nat M\n⊢ AddMonoid.IsTorsionFree M","decl":"lemma IsTorsionFree.of_noZeroSMulDivisors {M : Type*} [AddMonoid M] [NoZeroSMulDivisors ℕ M] :\n    IsTorsionFree M := isTorsionFree_iff_noZeroSMulDivisors_nat.2 ‹_›\n\n"}
{"name":"AddMonoid.IsTorsionFree.noZeroSMulDivisors_nat","module":"Mathlib.GroupTheory.Torsion","initialProofState":"M : Type u_3\ninst✝ : AddMonoid M\na✝ : AddMonoid.IsTorsionFree M\n⊢ NoZeroSMulDivisors Nat M","decl":"alias ⟨IsTorsionFree.noZeroSMulDivisors_nat, _⟩ := isTorsionFree_iff_noZeroSMulDivisors_nat\n"}
{"name":"AddMonoid.IsTorsionFree.noZeroSMulDivisors_int","module":"Mathlib.GroupTheory.Torsion","initialProofState":"G : Type u_1\ninst✝ : AddGroup G\na✝ : AddMonoid.IsTorsionFree G\n⊢ NoZeroSMulDivisors Int G","decl":"alias ⟨IsTorsionFree.noZeroSMulDivisors_int, _⟩ := isTorsionFree_iff_noZeroSMulDivisors_int\n\n"}
