{"name":"CochainComplex.shiftShortComplexFunctor'_inv_app_τ₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i j k i' j' k' : Int\nhi : Eq (HAdd.hAdd n i) i'\nhj : Eq (HAdd.hAdd n j) j'\nhk : Eq (HAdd.hAdd n k) k'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctor' C n i j k i' j' k' hi hj hk).inv.app X).τ₃ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).inv)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc' i j k ≅ K.sc' i' j' k'` when `n + i = i'`,\n`n + j = j'` and `n + k = k'`. -/\n@[simps!]\ndef shiftShortComplexFunctor' (n i j k i' j' k' : ℤ)\n    (hi : n + i = i') (hj : n + j = j') (hk : n + k = k') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ℤ) n) ⋙ shortComplexFunctor' C _ i j k ≅\n      shortComplexFunctor' C _ i' j' k' :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk\n      (n.negOnePow • ((shiftEval C n i i' hi).app K))\n      ((shiftEval C n j j' hj).app K) (n.negOnePow • ((shiftEval C n k k' hk).app K))\n      (by dsimp; simp) (by dsimp; simp))\n      (fun f ↦ by ext <;> dsimp <;> simp)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctor'_hom_app_τ₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i j k i' j' k' : Int\nhi : Eq (HAdd.hAdd n i) i'\nhj : Eq (HAdd.hAdd n j) j'\nhk : Eq (HAdd.hAdd n k) k'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctor' C n i j k i' j' k' hi hj hk).hom.app X).τ₁ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).hom)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc' i j k ≅ K.sc' i' j' k'` when `n + i = i'`,\n`n + j = j'` and `n + k = k'`. -/\n@[simps!]\ndef shiftShortComplexFunctor' (n i j k i' j' k' : ℤ)\n    (hi : n + i = i') (hj : n + j = j') (hk : n + k = k') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ℤ) n) ⋙ shortComplexFunctor' C _ i j k ≅\n      shortComplexFunctor' C _ i' j' k' :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk\n      (n.negOnePow • ((shiftEval C n i i' hi).app K))\n      ((shiftEval C n j j' hj).app K) (n.negOnePow • ((shiftEval C n k k' hk).app K))\n      (by dsimp; simp) (by dsimp; simp))\n      (fun f ↦ by ext <;> dsimp <;> simp)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctor'_hom_app_τ₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i j k i' j' k' : Int\nhi : Eq (HAdd.hAdd n i) i'\nhj : Eq (HAdd.hAdd n j) j'\nhk : Eq (HAdd.hAdd n k) k'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctor' C n i j k i' j' k' hi hj hk).hom.app X).τ₃ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).hom)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc' i j k ≅ K.sc' i' j' k'` when `n + i = i'`,\n`n + j = j'` and `n + k = k'`. -/\n@[simps!]\ndef shiftShortComplexFunctor' (n i j k i' j' k' : ℤ)\n    (hi : n + i = i') (hj : n + j = j') (hk : n + k = k') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ℤ) n) ⋙ shortComplexFunctor' C _ i j k ≅\n      shortComplexFunctor' C _ i' j' k' :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk\n      (n.negOnePow • ((shiftEval C n i i' hi).app K))\n      ((shiftEval C n j j' hj).app K) (n.negOnePow • ((shiftEval C n k k' hk).app K))\n      (by dsimp; simp) (by dsimp; simp))\n      (fun f ↦ by ext <;> dsimp <;> simp)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctor'_hom_app_τ₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i j k i' j' k' : Int\nhi : Eq (HAdd.hAdd n i) i'\nhj : Eq (HAdd.hAdd n j) j'\nhk : Eq (HAdd.hAdd n k) k'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctor' C n i j k i' j' k' hi hj hk).hom.app X).τ₂ (HomologicalComplex.XIsoOfEq X ⋯).hom","decl":"/-- The natural isomorphism `(K⟦n⟧).sc' i j k ≅ K.sc' i' j' k'` when `n + i = i'`,\n`n + j = j'` and `n + k = k'`. -/\n@[simps!]\ndef shiftShortComplexFunctor' (n i j k i' j' k' : ℤ)\n    (hi : n + i = i') (hj : n + j = j') (hk : n + k = k') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ℤ) n) ⋙ shortComplexFunctor' C _ i j k ≅\n      shortComplexFunctor' C _ i' j' k' :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk\n      (n.negOnePow • ((shiftEval C n i i' hi).app K))\n      ((shiftEval C n j j' hj).app K) (n.negOnePow • ((shiftEval C n k k' hk).app K))\n      (by dsimp; simp) (by dsimp; simp))\n      (fun f ↦ by ext <;> dsimp <;> simp)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctor'_inv_app_τ₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i j k i' j' k' : Int\nhi : Eq (HAdd.hAdd n i) i'\nhj : Eq (HAdd.hAdd n j) j'\nhk : Eq (HAdd.hAdd n k) k'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctor' C n i j k i' j' k' hi hj hk).inv.app X).τ₂ (HomologicalComplex.XIsoOfEq X ⋯).inv","decl":"/-- The natural isomorphism `(K⟦n⟧).sc' i j k ≅ K.sc' i' j' k'` when `n + i = i'`,\n`n + j = j'` and `n + k = k'`. -/\n@[simps!]\ndef shiftShortComplexFunctor' (n i j k i' j' k' : ℤ)\n    (hi : n + i = i') (hj : n + j = j') (hk : n + k = k') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ℤ) n) ⋙ shortComplexFunctor' C _ i j k ≅\n      shortComplexFunctor' C _ i' j' k' :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk\n      (n.negOnePow • ((shiftEval C n i i' hi).app K))\n      ((shiftEval C n j j' hj).app K) (n.negOnePow • ((shiftEval C n k k' hk).app K))\n      (by dsimp; simp) (by dsimp; simp))\n      (fun f ↦ by ext <;> dsimp <;> simp)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctor'_inv_app_τ₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i j k i' j' k' : Int\nhi : Eq (HAdd.hAdd n i) i'\nhj : Eq (HAdd.hAdd n j) j'\nhk : Eq (HAdd.hAdd n k) k'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctor' C n i j k i' j' k' hi hj hk).inv.app X).τ₁ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).inv)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc' i j k ≅ K.sc' i' j' k'` when `n + i = i'`,\n`n + j = j'` and `n + k = k'`. -/\n@[simps!]\ndef shiftShortComplexFunctor' (n i j k i' j' k' : ℤ)\n    (hi : n + i = i') (hj : n + j = j') (hk : n + k = k') :\n    (CategoryTheory.shiftFunctor (CochainComplex C ℤ) n) ⋙ shortComplexFunctor' C _ i j k ≅\n      shortComplexFunctor' C _ i' j' k' :=\n  NatIso.ofComponents (fun K => ShortComplex.isoMk\n      (n.negOnePow • ((shiftEval C n i i' hi).app K))\n      ((shiftEval C n j j' hj).app K) (n.negOnePow • ((shiftEval C n k k' hk).app K))\n      (by dsimp; simp) (by dsimp; simp))\n      (fun f ↦ by ext <;> dsimp <;> simp)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_inv_app_τ₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C n i i' hi).inv.app X).τ₃ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).inv)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc i ≅ K.sc i'` when `n + i = i'`. -/\n@[simps!]\nnoncomputable def shiftShortComplexFunctorIso (n i i' : ℤ) (hi : n + i = i') :\n    shiftFunctor C n ⋙ shortComplexFunctor C _ i ≅ shortComplexFunctor C _ i' :=\n  shiftShortComplexFunctor' C n _ i _ _ i' _\n    (by simp only [prev]; omega) hi (by simp only [next]; omega)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_hom_app_τ₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C n i i' hi).hom.app X).τ₂ (HomologicalComplex.XIsoOfEq X ⋯).hom","decl":"/-- The natural isomorphism `(K⟦n⟧).sc i ≅ K.sc i'` when `n + i = i'`. -/\n@[simps!]\nnoncomputable def shiftShortComplexFunctorIso (n i i' : ℤ) (hi : n + i = i') :\n    shiftFunctor C n ⋙ shortComplexFunctor C _ i ≅ shortComplexFunctor C _ i' :=\n  shiftShortComplexFunctor' C n _ i _ _ i' _\n    (by simp only [prev]; omega) hi (by simp only [next]; omega)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_inv_app_τ₂","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C n i i' hi).inv.app X).τ₂ (HomologicalComplex.XIsoOfEq X ⋯).inv","decl":"/-- The natural isomorphism `(K⟦n⟧).sc i ≅ K.sc i'` when `n + i = i'`. -/\n@[simps!]\nnoncomputable def shiftShortComplexFunctorIso (n i i' : ℤ) (hi : n + i = i') :\n    shiftFunctor C n ⋙ shortComplexFunctor C _ i ≅ shortComplexFunctor C _ i' :=\n  shiftShortComplexFunctor' C n _ i _ _ i' _\n    (by simp only [prev]; omega) hi (by simp only [next]; omega)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_inv_app_τ₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C n i i' hi).inv.app X).τ₁ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).inv)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc i ≅ K.sc i'` when `n + i = i'`. -/\n@[simps!]\nnoncomputable def shiftShortComplexFunctorIso (n i i' : ℤ) (hi : n + i = i') :\n    shiftFunctor C n ⋙ shortComplexFunctor C _ i ≅ shortComplexFunctor C _ i' :=\n  shiftShortComplexFunctor' C n _ i _ _ i' _\n    (by simp only [prev]; omega) hi (by simp only [next]; omega)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_hom_app_τ₁","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C n i i' hi).hom.app X).τ₁ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).hom)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc i ≅ K.sc i'` when `n + i = i'`. -/\n@[simps!]\nnoncomputable def shiftShortComplexFunctorIso (n i i' : ℤ) (hi : n + i = i') :\n    shiftFunctor C n ⋙ shortComplexFunctor C _ i ≅ shortComplexFunctor C _ i' :=\n  shiftShortComplexFunctor' C n _ i _ _ i' _\n    (by simp only [prev]; omega) hi (by simp only [next]; omega)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_hom_app_τ₃","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn i i' : Int\nhi : Eq (HAdd.hAdd n i) i'\nX : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C n i i' hi).hom.app X).τ₃ (HSMul.hSMul n.negOnePow (HomologicalComplex.XIsoOfEq X ⋯).hom)","decl":"/-- The natural isomorphism `(K⟦n⟧).sc i ≅ K.sc i'` when `n + i = i'`. -/\n@[simps!]\nnoncomputable def shiftShortComplexFunctorIso (n i i' : ℤ) (hi : n + i = i') :\n    shiftFunctor C n ⋙ shortComplexFunctor C _ i ≅ shortComplexFunctor C _ i' :=\n  shiftShortComplexFunctor' C n _ i _ _ i' _\n    (by simp only [prev]; omega) hi (by simp only [next]; omega)\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_zero_add_hom_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\na : Int\nK : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C 0 a a ⋯).hom.app K) ((HomologicalComplex.shortComplexFunctor C (ComplexShape.up Int) a).map ((CategoryTheory.shiftFunctorZero (CochainComplex C Int) Int).hom.app K))","decl":"lemma shiftShortComplexFunctorIso_zero_add_hom_app (a : ℤ) (K : CochainComplex C ℤ) :\n    (shiftShortComplexFunctorIso C 0 a a (zero_add a)).hom.app K =\n      (shortComplexFunctor C (ComplexShape.up ℤ) a).map\n        ((shiftFunctorZero (CochainComplex C ℤ) ℤ).hom.app K) := by\n  ext <;> dsimp <;> simp [one_smul, shiftFunctorZero_hom_app_f]\n\n"}
{"name":"CochainComplex.shiftShortComplexFunctorIso_add'_hom_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝¹ : CategoryTheory.Category.{u_2, u_1} C\ninst✝ : CategoryTheory.Preadditive C\nn m mn : Int\nhmn : Eq (HAdd.hAdd m n) mn\na a' a'' : Int\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nK : CochainComplex C Int\n⊢ Eq ((CochainComplex.shiftShortComplexFunctorIso C mn a a'' ⋯).hom.app K) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.shortComplexFunctor C (ComplexShape.up Int) a).map ((CategoryTheory.shiftFunctorAdd' (CochainComplex C Int) m n mn hmn).hom.app K)) (CategoryTheory.CategoryStruct.comp ((CochainComplex.shiftShortComplexFunctorIso C n a a' ha').hom.app ((CategoryTheory.shiftFunctor (CochainComplex C Int) m).obj K)) ((CochainComplex.shiftShortComplexFunctorIso C m a' a'' ha'').hom.app K)))","decl":"lemma shiftShortComplexFunctorIso_add'_hom_app\n    (n m mn : ℤ) (hmn : m + n = mn) (a a' a'' : ℤ) (ha' : n + a = a') (ha'' : m + a' = a'')\n    (K : CochainComplex C ℤ) :\n    (shiftShortComplexFunctorIso C mn a a'' (by rw [← ha'', ← ha', ← add_assoc, hmn])).hom.app K =\n      (shortComplexFunctor C (ComplexShape.up ℤ) a).map\n        ((CategoryTheory.shiftFunctorAdd' (CochainComplex C ℤ) m n mn hmn).hom.app K) ≫\n        (shiftShortComplexFunctorIso C n a a' ha').hom.app (K⟦m⟧) ≫\n        (shiftShortComplexFunctorIso C m a' a'' ha'' ).hom.app K := by\n  ext <;> dsimp <;> simp only [← hmn, Int.negOnePow_add, shiftFunctorAdd'_hom_app_f',\n    XIsoOfEq_shift, Linear.comp_units_smul, Linear.units_smul_comp,\n    XIsoOfEq_hom_comp_XIsoOfEq_hom, smul_smul]\n\n"}
{"name":"CochainComplex.ShiftSequence.shiftIso_hom_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nn a a' : Int\nha' : Eq (HAdd.hAdd n a) a'\nK : CochainComplex C Int\n⊢ Eq ((CochainComplex.ShiftSequence.shiftIso C n a a' ha').hom.app K) (CategoryTheory.ShortComplex.homologyMap ((CochainComplex.shiftShortComplexFunctorIso C n a a' ha').hom.app K))","decl":"lemma shiftIso_hom_app (n a a' : ℤ) (ha' : n + a = a') (K : CochainComplex C ℤ) :\n    (shiftIso C n a a' ha').hom.app K =\n      ShortComplex.homologyMap ((shiftShortComplexFunctorIso C n a a' ha').hom.app K) := by\n  dsimp [shiftIso]\n  erw [id_comp, id_comp, comp_id]\n\n"}
{"name":"CochainComplex.ShiftSequence.shiftIso_inv_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nn a a' : Int\nha' : Eq (HAdd.hAdd n a) a'\nK : CochainComplex C Int\n⊢ Eq ((CochainComplex.ShiftSequence.shiftIso C n a a' ha').inv.app K) (CategoryTheory.ShortComplex.homologyMap ((CochainComplex.shiftShortComplexFunctorIso C n a a' ha').inv.app K))","decl":"lemma shiftIso_inv_app (n a a' : ℤ) (ha' : n + a = a') (K : CochainComplex C ℤ) :\n    (shiftIso C n a a' ha').inv.app K =\n      ShortComplex.homologyMap ((shiftShortComplexFunctorIso C n a a' ha').inv.app K) := by\n  dsimp [shiftIso]\n  erw [id_comp, comp_id, comp_id]\n\n"}
{"name":"CochainComplex.quasiIsoAt_shift_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nn i j : Int\nh : Eq (HAdd.hAdd n i) j\n⊢ Iff (QuasiIsoAt ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) n).map φ) i) (QuasiIsoAt φ j)","decl":"lemma quasiIsoAt_shift_iff {K L : CochainComplex C ℤ} (φ : K ⟶ L) (n i j : ℤ) (h : n + i = j) :\n    QuasiIsoAt (φ⟦n⟧') i ↔ QuasiIsoAt φ j := by\n  simp only [quasiIsoAt_iff_isIso_homologyMap]\n  exact (NatIso.isIso_map_iff\n    ((homologyFunctor C (ComplexShape.up ℤ) 0).shiftIso n i j h) φ)\n\n"}
{"name":"CochainComplex.quasiIso_shift_iff","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nn : Int\n⊢ Iff (QuasiIso ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) n).map φ)) (QuasiIso φ)","decl":"lemma quasiIso_shift_iff {K L : CochainComplex C ℤ} (φ : K ⟶ L) (n : ℤ) :\n    QuasiIso (φ⟦n⟧') ↔ QuasiIso φ := by\n  simp only [quasiIso_iff, fun i ↦ quasiIsoAt_shift_iff φ n i _ rfl]\n  constructor\n  · intro h j\n    obtain ⟨i, rfl⟩ : ∃ i, j = n + i := ⟨j - n, by omega⟩\n    exact h i\n  · intro h i\n    exact h (n + i)\n\n"}
{"name":"CochainComplex.instQuasiIsoIntMapHomologicalComplexUpShiftFunctor","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝³ : CategoryTheory.Category.{u_2, u_1} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.CategoryWithHomology C\nK L : CochainComplex C Int\nφ : Quiver.Hom K L\nn : Int\ninst✝ : QuasiIso φ\n⊢ QuasiIso ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) n).map φ)","decl":"instance {K L : CochainComplex C ℤ} (φ : K ⟶ L) (n : ℤ) [QuasiIso φ] :\n    QuasiIso (φ⟦n⟧') := by\n  rw [quasiIso_shift_iff]\n  infer_instance\n\n"}
{"name":"CochainComplex.instIsCompatibleWithShiftHomologicalComplexIntUpQuasiIso","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\n⊢ (HomologicalComplex.quasiIso C (ComplexShape.up Int)).IsCompatibleWithShift Int","decl":"instance : (HomologicalComplex.quasiIso C (ComplexShape.up ℤ)).IsCompatibleWithShift ℤ where\n  condition n := by ext; apply quasiIso_shift_iff\n\n"}
{"name":"CochainComplex.homologyFunctor_shift","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nn : Int\n⊢ Eq ((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shift n) (HomologicalComplex.homologyFunctor C (ComplexShape.up Int) n)","decl":"variable (C) in\nlemma homologyFunctor_shift (n : ℤ) :\n    (homologyFunctor C (ComplexShape.up ℤ) 0).shift n =\n      homologyFunctor C (ComplexShape.up ℤ) n := rfl\n\n"}
{"name":"CochainComplex.liftCycles_shift_homologyπ_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : CochainComplex C Int\nA : C\nn i : Int\nf : Quiver.Hom A (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K).X i)\nj : Int\nhj : Eq ((ComplexShape.up Int).next i) j\nhf : Eq (CategoryTheory.CategoryStruct.comp f (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K).d i j)) 0\ni' : Int\nhi' : Eq (HAdd.hAdd n i) i'\nj' : Int\nhj' : Eq ((ComplexShape.up Int).next i') j'\nZ : C\nh : Quiver.Hom (HomologicalComplex.homology ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K) i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.liftCycles ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K) f j hj hf) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyπ ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K) i) h)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.liftCycles K (CategoryTheory.CategoryStruct.comp f (K.shiftFunctorObjXIso n i i' ⋯).hom) j' hj' ⋯) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyπ K i') (CategoryTheory.CategoryStruct.comp (((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftIso n i i' hi').inv.app K) h)))","decl":"@[reassoc]\nlemma liftCycles_shift_homologyπ\n    (K : CochainComplex C ℤ) {A : C} {n i : ℤ} (f : A ⟶ (K⟦n⟧).X i) (j : ℤ)\n    (hj : (up ℤ).next i = j) (hf : f ≫ (K⟦n⟧).d i j = 0) (i' : ℤ) (hi' : n + i = i') (j' : ℤ)\n    (hj' : (up ℤ).next i' = j') :\n    (K⟦n⟧).liftCycles f j hj hf ≫ (K⟦n⟧).homologyπ i =\n      K.liftCycles (f ≫ (K.shiftFunctorObjXIso n i i' (by omega)).hom) j' hj' (by\n        simp only [next] at hj hj'\n        obtain rfl : i' = i + n := by omega\n        obtain rfl : j' = j + n := by omega\n        dsimp at hf ⊢\n        simp only [Linear.comp_units_smul] at hf\n        apply (one_smul (M := ℤˣ) _).symm.trans _\n        rw [← Int.units_mul_self n.negOnePow, mul_smul, comp_id, hf, smul_zero]) ≫\n        K.homologyπ i' ≫\n          ((HomologicalComplex.homologyFunctor C (up ℤ) 0).shiftIso n i i' hi').inv.app K := by\n  simp only [liftCycles, homologyπ,\n    shiftFunctorObjXIso, Functor.shiftIso, Functor.ShiftSequence.shiftIso,\n    ShiftSequence.shiftIso_inv_app, ShortComplex.homologyπ_naturality,\n    ShortComplex.liftCycles_comp_cyclesMap_assoc, shiftShortComplexFunctorIso_inv_app_τ₂,\n    assoc, Iso.hom_inv_id, comp_id]\n  rfl\n\n"}
{"name":"CochainComplex.liftCycles_shift_homologyπ","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK : CochainComplex C Int\nA : C\nn i : Int\nf : Quiver.Hom A (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K).X i)\nj : Int\nhj : Eq ((ComplexShape.up Int).next i) j\nhf : Eq (CategoryTheory.CategoryStruct.comp f (((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K).d i j)) 0\ni' : Int\nhi' : Eq (HAdd.hAdd n i) i'\nj' : Int\nhj' : Eq ((ComplexShape.up Int).next i') j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.liftCycles ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K) f j hj hf) (HomologicalComplex.homologyπ ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj K) i)) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.liftCycles K (CategoryTheory.CategoryStruct.comp f (K.shiftFunctorObjXIso n i i' ⋯).hom) j' hj' ⋯) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.homologyπ K i') (((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftIso n i i' hi').inv.app K)))","decl":"@[reassoc]\nlemma liftCycles_shift_homologyπ\n    (K : CochainComplex C ℤ) {A : C} {n i : ℤ} (f : A ⟶ (K⟦n⟧).X i) (j : ℤ)\n    (hj : (up ℤ).next i = j) (hf : f ≫ (K⟦n⟧).d i j = 0) (i' : ℤ) (hi' : n + i = i') (j' : ℤ)\n    (hj' : (up ℤ).next i' = j') :\n    (K⟦n⟧).liftCycles f j hj hf ≫ (K⟦n⟧).homologyπ i =\n      K.liftCycles (f ≫ (K.shiftFunctorObjXIso n i i' (by omega)).hom) j' hj' (by\n        simp only [next] at hj hj'\n        obtain rfl : i' = i + n := by omega\n        obtain rfl : j' = j + n := by omega\n        dsimp at hf ⊢\n        simp only [Linear.comp_units_smul] at hf\n        apply (one_smul (M := ℤˣ) _).symm.trans _\n        rw [← Int.units_mul_self n.negOnePow, mul_smul, comp_id, hf, smul_zero]) ≫\n        K.homologyπ i' ≫\n          ((HomologicalComplex.homologyFunctor C (up ℤ) 0).shiftIso n i i' hi').inv.app K := by\n  simp only [liftCycles, homologyπ,\n    shiftFunctorObjXIso, Functor.shiftIso, Functor.ShiftSequence.shiftIso,\n    ShiftSequence.shiftIso_inv_app, ShortComplex.homologyπ_naturality,\n    ShortComplex.liftCycles_comp_cyclesMap_assoc, shiftShortComplexFunctorIso_inv_app_τ₂,\n    assoc, Iso.hom_inv_id, comp_id]\n  rfl\n\n"}
{"name":"HomotopyCategory.homologyShiftIso_hom_app","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nn a a' : Int\nha' : Eq (HAdd.hAdd n a) a'\nK : CochainComplex C Int\n⊢ Eq (((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).shiftIso n a a' ha').hom.app ((HomotopyCategory.quotient C (ComplexShape.up Int)).obj K)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) a).map (((HomotopyCategory.quotient C (ComplexShape.up Int)).commShiftIso n).inv.app K)) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) a).hom.app ((CategoryTheory.shiftFunctor (HomologicalComplex C (ComplexShape.up Int)) n).obj K)) (CategoryTheory.CategoryStruct.comp (((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftIso n a a' ha').hom.app K) ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) a').inv.app K))))","decl":"lemma homologyShiftIso_hom_app (n a a' : ℤ) (ha' : n + a = a') (K : CochainComplex C ℤ) :\n    ((homologyFunctor C (ComplexShape.up ℤ) 0).shiftIso n a a' ha').hom.app\n      ((quotient _ _).obj K) =\n    (homologyFunctor _ _ a).map (((quotient _ _).commShiftIso n).inv.app K) ≫\n      (homologyFunctorFactors _ _ a).hom.app (K⟦n⟧) ≫\n      ((HomologicalComplex.homologyFunctor _ _ 0).shiftIso n a a' ha').hom.app K ≫\n      (homologyFunctorFactors _ _ a').inv.app K := by\n  apply Functor.ShiftSequence.induced_shiftIso_hom_app_obj\n\n"}
{"name":"HomotopyCategory.homologyFunctor_shiftMap_assoc","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK L : CochainComplex C Int\nn : Int\nf : Quiver.Hom K ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj L)\na a' : Int\nh✝ : Eq (HAdd.hAdd n a) a'\nZ : C\nh : Quiver.Hom (((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).shift a').obj ((HomotopyCategory.quotient C (ComplexShape.up Int)).obj L)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).shiftMap (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map f) (((HomotopyCategory.quotient C (ComplexShape.up Int)).commShiftIso n).hom.app L)) a a' h✝) h) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) a).hom.app K) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftMap f a a' h✝) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) a').inv.app L) h)))","decl":"@[reassoc]\nlemma homologyFunctor_shiftMap\n    {K L : CochainComplex C ℤ} {n : ℤ} (f : K ⟶ L⟦n⟧) (a a' : ℤ) (h : n + a = a') :\n    (homologyFunctor C (ComplexShape.up ℤ) 0).shiftMap\n      ((quotient _ _).map f ≫ ((quotient _ _).commShiftIso n).hom.app _) a a' h =\n        (homologyFunctorFactors _ _ a).hom.app K ≫\n          (HomologicalComplex.homologyFunctor C (ComplexShape.up ℤ) 0).shiftMap f a a' h ≫\n            (homologyFunctorFactors _ _ a').inv.app L := by\n  apply Functor.ShiftSequence.induced_shiftMap\n\n"}
{"name":"HomotopyCategory.homologyFunctor_shiftMap","module":"Mathlib.Algebra.Homology.HomotopyCategory.ShiftSequence","initialProofState":"C : Type u_1\ninst✝² : CategoryTheory.Category.{u_2, u_1} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.CategoryWithHomology C\nK L : CochainComplex C Int\nn : Int\nf : Quiver.Hom K ((CategoryTheory.shiftFunctor (CochainComplex C Int) n).obj L)\na a' : Int\nh : Eq (HAdd.hAdd n a) a'\n⊢ Eq ((HomotopyCategory.homologyFunctor C (ComplexShape.up Int) 0).shiftMap (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.quotient C (ComplexShape.up Int)).map f) (((HomotopyCategory.quotient C (ComplexShape.up Int)).commShiftIso n).hom.app L)) a a' h) (CategoryTheory.CategoryStruct.comp ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) a).hom.app K) (CategoryTheory.CategoryStruct.comp ((HomologicalComplex.homologyFunctor C (ComplexShape.up Int) 0).shiftMap f a a' h) ((HomotopyCategory.homologyFunctorFactors C (ComplexShape.up Int) a').inv.app L)))","decl":"@[reassoc]\nlemma homologyFunctor_shiftMap\n    {K L : CochainComplex C ℤ} {n : ℤ} (f : K ⟶ L⟦n⟧) (a a' : ℤ) (h : n + a = a') :\n    (homologyFunctor C (ComplexShape.up ℤ) 0).shiftMap\n      ((quotient _ _).map f ≫ ((quotient _ _).commShiftIso n).hom.app _) a a' h =\n        (homologyFunctorFactors _ _ a).hom.app K ≫\n          (HomologicalComplex.homologyFunctor C (ComplexShape.up ℤ) 0).shiftMap f a a' h ≫\n            (homologyFunctorFactors _ _ a').inv.app L := by\n  apply Functor.ShiftSequence.induced_shiftMap\n\n"}
