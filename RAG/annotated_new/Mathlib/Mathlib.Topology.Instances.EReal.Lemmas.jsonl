{"name":"EReal.isEmbedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsEmbedding Real.toEReal","decl":"theorem isEmbedding_coe : IsEmbedding ((↑) : ℝ → EReal) :=\n  coe_strictMono.isEmbedding_of_ordConnected <| by rw [range_coe_eq_Ioo]; exact ordConnected_Ioo\n\n"}
{"name":"EReal.embedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsEmbedding Real.toEReal","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe := isEmbedding_coe\n\n"}
{"name":"EReal.isOpenEmbedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsOpenEmbedding Real.toEReal","decl":"theorem isOpenEmbedding_coe : IsOpenEmbedding ((↑) : ℝ → EReal) :=\n  ⟨isEmbedding_coe, by simp only [range_coe_eq_Ioo, isOpen_Ioo]⟩\n\n"}
{"name":"EReal.openEmbedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsOpenEmbedding Real.toEReal","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_coe := isOpenEmbedding_coe\n\n"}
{"name":"EReal.tendsto_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\nf : Filter α\nm : α → Real\na : Real\n⊢ Iff (Filter.Tendsto (fun a => ↑(m a)) f (nhds ↑a)) (Filter.Tendsto m f (nhds a))","decl":"@[norm_cast]\ntheorem tendsto_coe {α : Type*} {f : Filter α} {m : α → ℝ} {a : ℝ} :\n    Tendsto (fun a => (m a : EReal)) f (𝓝 ↑a) ↔ Tendsto m f (𝓝 a) :=\n  isEmbedding_coe.tendsto_nhds_iff.symm\n\n"}
{"name":"continuous_coe_real_ereal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Continuous Real.toEReal","decl":"theorem _root_.continuous_coe_real_ereal : Continuous ((↑) : ℝ → EReal) :=\n  isEmbedding_coe.continuous\n\n"}
{"name":"EReal.continuous_coe_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → Real\n⊢ Iff (Continuous fun a => ↑(f a)) (Continuous f)","decl":"theorem continuous_coe_iff {f : α → ℝ} : (Continuous fun a => (f a : EReal)) ↔ Continuous f :=\n  isEmbedding_coe.continuous_iff.symm\n\n"}
{"name":"EReal.nhds_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"r : Real\n⊢ Eq (nhds ↑r) (Filter.map Real.toEReal (nhds r))","decl":"theorem nhds_coe {r : ℝ} : 𝓝 (r : EReal) = (𝓝 r).map (↑) :=\n  (isOpenEmbedding_coe.map_nhds_eq r).symm\n\n"}
{"name":"EReal.nhds_coe_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"r p : Real\n⊢ Eq (nhds { fst := ↑r, snd := ↑p }) (Filter.map (fun p => { fst := ↑p.1, snd := ↑p.2 }) (nhds { fst := r, snd := p }))","decl":"theorem nhds_coe_coe {r p : ℝ} :\n    𝓝 ((r : EReal), (p : EReal)) = (𝓝 (r, p)).map fun p : ℝ × ℝ => (↑p.1, ↑p.2) :=\n  ((isOpenEmbedding_coe.prodMap isOpenEmbedding_coe).map_nhds_eq (r, p)).symm\n\n"}
{"name":"EReal.tendsto_toReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : EReal\nha : Ne a Top.top\nh'a : Ne a Bot.bot\n⊢ Filter.Tendsto EReal.toReal (nhds a) (nhds a.toReal)","decl":"theorem tendsto_toReal {a : EReal} (ha : a ≠ ⊤) (h'a : a ≠ ⊥) :\n    Tendsto EReal.toReal (𝓝 a) (𝓝 a.toReal) := by\n  lift a to ℝ using ⟨ha, h'a⟩\n  rw [nhds_coe, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"EReal.continuousOn_toReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ ContinuousOn EReal.toReal (HasCompl.compl (Insert.insert Bot.bot (Singleton.singleton Top.top)))","decl":"theorem continuousOn_toReal : ContinuousOn EReal.toReal ({⊥, ⊤}ᶜ : Set EReal) := fun _a ha =>\n  ContinuousAt.continuousWithinAt (tendsto_toReal (mt Or.inr ha) (mt Or.inl ha))\n\n"}
{"name":"EReal.isEmbedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsEmbedding ENNReal.toEReal","decl":"theorem isEmbedding_coe_ennreal : IsEmbedding ((↑) : ℝ≥0∞ → EReal) :=\n  coe_ennreal_strictMono.isEmbedding_of_ordConnected <| by\n    rw [range_coe_ennreal]; exact ordConnected_Ici\n\n"}
{"name":"EReal.embedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsEmbedding ENNReal.toEReal","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe_ennreal := isEmbedding_coe_ennreal\n\n"}
{"name":"EReal.isClosedEmbedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsClosedEmbedding ENNReal.toEReal","decl":"theorem isClosedEmbedding_coe_ennreal : IsClosedEmbedding ((↑) : ℝ≥0∞ → EReal) :=\n  ⟨isEmbedding_coe_ennreal, by rw [range_coe_ennreal]; exact isClosed_Ici⟩\n\n"}
{"name":"EReal.closedEmbedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Topology.IsClosedEmbedding ENNReal.toEReal","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_coe_ennreal := isClosedEmbedding_coe_ennreal\n\n"}
{"name":"EReal.tendsto_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\nf : Filter α\nm : α → ENNReal\na : ENNReal\n⊢ Iff (Filter.Tendsto (fun a => ↑(m a)) f (nhds ↑a)) (Filter.Tendsto m f (nhds a))","decl":"@[norm_cast]\ntheorem tendsto_coe_ennreal {α : Type*} {f : Filter α} {m : α → ℝ≥0∞} {a : ℝ≥0∞} :\n    Tendsto (fun a => (m a : EReal)) f (𝓝 ↑a) ↔ Tendsto m f (𝓝 a) :=\n  isEmbedding_coe_ennreal.tendsto_nhds_iff.symm\n\n"}
{"name":"continuous_coe_ennreal_ereal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Continuous ENNReal.toEReal","decl":"theorem _root_.continuous_coe_ennreal_ereal : Continuous ((↑) : ℝ≥0∞ → EReal) :=\n  isEmbedding_coe_ennreal.continuous\n\n"}
{"name":"EReal.continuous_coe_ennreal_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_1\ninst✝ : TopologicalSpace α\nf : α → ENNReal\n⊢ Iff (Continuous fun a => ↑(f a)) (Continuous f)","decl":"theorem continuous_coe_ennreal_iff {f : α → ℝ≥0∞} :\n    (Continuous fun a => (f a : EReal)) ↔ Continuous f :=\n  isEmbedding_coe_ennreal.continuous_iff.symm\n\n"}
{"name":"EReal.nhds_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Eq (nhds Top.top) (iInf fun a => iInf fun x => Filter.principal (Set.Ioi a))","decl":"theorem nhds_top : 𝓝 (⊤ : EReal) = ⨅ (a) (_ : a ≠ ⊤), 𝓟 (Ioi a) :=\n  nhds_top_order.trans <| by simp only [lt_top_iff_ne_top]\n\n"}
{"name":"EReal.nhds_top_basis","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ (nhds Top.top).HasBasis (fun x => True) fun x => Set.Ioi ↑x","decl":"nonrec theorem nhds_top_basis : (𝓝 (⊤ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Ioi ·) := by\n  refine nhds_top_basis.to_hasBasis (fun x hx => ?_) fun _ _ ↦ ⟨_, coe_lt_top _, Subset.rfl⟩\n  rcases exists_rat_btwn_of_lt hx with ⟨y, hxy, -⟩\n  exact ⟨_, trivial, Ioi_subset_Ioi hxy.le⟩\n\n"}
{"name":"EReal.nhds_top'","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Eq (nhds Top.top) (iInf fun a => Filter.principal (Set.Ioi ↑a))","decl":"theorem nhds_top' : 𝓝 (⊤ : EReal) = ⨅ a : ℝ, 𝓟 (Ioi ↑a) := nhds_top_basis.eq_iInf\n\n"}
{"name":"EReal.mem_nhds_top_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"s : Set EReal\n⊢ Iff (Membership.mem (nhds Top.top) s) (Exists fun y => HasSubset.Subset (Set.Ioi ↑y) s)","decl":"theorem mem_nhds_top_iff {s : Set EReal} : s ∈ 𝓝 (⊤ : EReal) ↔ ∃ y : ℝ, Ioi (y : EReal) ⊆ s :=\n  nhds_top_basis.mem_iff.trans <| by simp only [true_and]\n\n"}
{"name":"EReal.tendsto_nhds_top_iff_real","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\nm : α → EReal\nf : Filter α\n⊢ Iff (Filter.Tendsto m f (nhds Top.top)) (∀ (x : Real), Filter.Eventually (fun a => LT.lt (↑x) (m a)) f)","decl":"theorem tendsto_nhds_top_iff_real {α : Type*} {m : α → EReal} {f : Filter α} :\n    Tendsto m f (𝓝 ⊤) ↔ ∀ x : ℝ, ∀ᶠ a in f, ↑x < m a :=\n  nhds_top_basis.tendsto_right_iff.trans <| by simp only [true_implies, mem_Ioi]\n\n"}
{"name":"EReal.nhds_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Eq (nhds Bot.bot) (iInf fun a => iInf fun x => Filter.principal (Set.Iio a))","decl":"theorem nhds_bot : 𝓝 (⊥ : EReal) = ⨅ (a) (_ : a ≠ ⊥), 𝓟 (Iio a) :=\n  nhds_bot_order.trans <| by simp only [bot_lt_iff_ne_bot]\n\n"}
{"name":"EReal.nhds_bot_basis","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ (nhds Bot.bot).HasBasis (fun x => True) fun x => Set.Iio ↑x","decl":"theorem nhds_bot_basis : (𝓝 (⊥ : EReal)).HasBasis (fun _ : ℝ ↦ True) (Iio ·) := by\n  refine _root_.nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ ↦ ⟨_, bot_lt_coe _, Subset.rfl⟩\n  rcases exists_rat_btwn_of_lt hx with ⟨y, -, hxy⟩\n  exact ⟨_, trivial, Iio_subset_Iio hxy.le⟩\n\n"}
{"name":"EReal.nhds_bot'","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Eq (nhds Bot.bot) (iInf fun a => Filter.principal (Set.Iio ↑a))","decl":"theorem nhds_bot' : 𝓝 (⊥ : EReal) = ⨅ a : ℝ, 𝓟 (Iio ↑a) :=\n  nhds_bot_basis.eq_iInf\n\n"}
{"name":"EReal.mem_nhds_bot_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"s : Set EReal\n⊢ Iff (Membership.mem (nhds Bot.bot) s) (Exists fun y => HasSubset.Subset (Set.Iio ↑y) s)","decl":"theorem mem_nhds_bot_iff {s : Set EReal} : s ∈ 𝓝 (⊥ : EReal) ↔ ∃ y : ℝ, Iio (y : EReal) ⊆ s :=\n  nhds_bot_basis.mem_iff.trans <| by simp only [true_and]\n\n"}
{"name":"EReal.tendsto_nhds_bot_iff_real","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\nm : α → EReal\nf : Filter α\n⊢ Iff (Filter.Tendsto m f (nhds Bot.bot)) (∀ (x : Real), Filter.Eventually (fun a => LT.lt (m a) ↑x) f)","decl":"theorem tendsto_nhds_bot_iff_real {α : Type*} {m : α → EReal} {f : Filter α} :\n    Tendsto m f (𝓝 ⊥) ↔ ∀ x : ℝ, ∀ᶠ a in f, m a < x :=\n  nhds_bot_basis.tendsto_right_iff.trans <| by simp only [true_implies, mem_Iio]\n\n"}
{"name":"EReal.nhdsWithin_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Eq (nhdsWithin Top.top (HasCompl.compl (Singleton.singleton Top.top))) (Filter.map Real.toEReal Filter.atTop)","decl":"lemma nhdsWithin_top : 𝓝[≠] (⊤ : EReal) = (atTop).map Real.toEReal := by\n  apply (nhdsWithin_hasBasis nhds_top_basis_Ici _).ext (atTop_basis.map Real.toEReal)\n  · simp only [EReal.image_coe_Ici, true_and]\n    intro x hx\n    by_cases hx_bot : x = ⊥\n    · simp [hx_bot]\n    lift x to ℝ using ⟨hx.ne_top, hx_bot⟩\n    refine ⟨x, fun x ⟨h1, h2⟩ ↦ ?_⟩\n    simp [h1, h2.ne_top]\n  · simp only [EReal.image_coe_Ici, true_implies]\n    refine fun x ↦ ⟨x, ⟨EReal.coe_lt_top x, fun x ⟨(h1 : _ ≤ x), h2⟩ ↦ ?_⟩⟩\n    simp [h1, Ne.lt_top' fun a ↦ h2 a.symm]\n\n"}
{"name":"EReal.nhdsWithin_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Eq (nhdsWithin Bot.bot (HasCompl.compl (Singleton.singleton Bot.bot))) (Filter.map Real.toEReal Filter.atBot)","decl":"lemma nhdsWithin_bot : 𝓝[≠] (⊥ : EReal) = (atBot).map Real.toEReal := by\n  apply (nhdsWithin_hasBasis nhds_bot_basis_Iic _).ext (atBot_basis.map Real.toEReal)\n  · simp only [EReal.image_coe_Iic, Set.subset_compl_singleton_iff, Set.mem_Ioc, lt_self_iff_false,\n      bot_le, and_true, not_false_eq_true, true_and]\n    intro x hx\n    by_cases hx_top : x = ⊤\n    · simp [hx_top]\n    lift x to ℝ using ⟨hx_top, hx.ne_bot⟩\n    refine ⟨x, fun x ⟨h1, h2⟩ ↦ ?_⟩\n    simp [h2, h1.ne_bot]\n  · simp only [EReal.image_coe_Iic, true_implies]\n    refine fun x ↦ ⟨x, ⟨EReal.bot_lt_coe x, fun x ⟨(h1 : x ≤ _), h2⟩ ↦ ?_⟩⟩\n    simp [h1, Ne.bot_lt' fun a ↦ h2 a.symm]\n\n"}
{"name":"EReal.tendsto_toReal_atTop","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Filter.Tendsto EReal.toReal (nhdsWithin Top.top (HasCompl.compl (Singleton.singleton Top.top))) Filter.atTop","decl":"lemma tendsto_toReal_atTop : Tendsto EReal.toReal (𝓝[≠] ⊤) atTop := by\n  rw [nhdsWithin_top, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"EReal.tendsto_toReal_atBot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Filter.Tendsto EReal.toReal (nhdsWithin Bot.bot (HasCompl.compl (Singleton.singleton Bot.bot))) Filter.atBot","decl":"lemma tendsto_toReal_atBot : Tendsto EReal.toReal (𝓝[≠] ⊥) atBot := by\n  rw [nhdsWithin_bot, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"EReal.continuous_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ Continuous EReal.toENNReal","decl":"lemma continuous_toENNReal : Continuous EReal.toENNReal := by\n  refine continuous_iff_continuousAt.mpr fun x ↦ ?_\n  by_cases h_top : x = ⊤\n  · simp only [ContinuousAt, h_top, toENNReal_top]\n    refine ENNReal.tendsto_nhds_top fun n ↦ ?_\n    filter_upwards [eventually_gt_nhds (coe_lt_top n)] with y hy\n    exact toENNReal_coe (x := n) ▸ toENNReal_lt_toENNReal (coe_ennreal_nonneg _) hy\n  refine ContinuousOn.continuousAt ?_ (compl_singleton_mem_nhds_iff.mpr h_top)\n  refine (continuousOn_of_forall_continuousAt fun x hx ↦ ?_).congr (fun _ h ↦ toENNReal_of_ne_top h)\n  by_cases h_bot : x = ⊥\n  · refine tendsto_nhds_of_eventually_eq ?_\n    rw [h_bot, nhds_bot_basis.eventually_iff]\n    simp [toReal_bot, ENNReal.ofReal_zero, ENNReal.ofReal_eq_zero, true_and]\n    exact ⟨0, fun _ hx ↦ toReal_nonpos hx.le⟩\n  refine ENNReal.continuous_ofReal.continuousAt.comp' <| continuousOn_toReal.continuousAt\n    <| (toFinite _).isClosed.compl_mem_nhds ?_\n  simp_all only [mem_compl_iff, mem_singleton_iff, mem_insert_iff, or_self, not_false_eq_true]\n\n"}
{"name":"Continous.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nf : α → EReal\nhf : Continuous f\n⊢ Continuous fun x => (f x).toENNReal","decl":"@[fun_prop]\nlemma _root_.Continous.ereal_toENNReal {α : Type*} [TopologicalSpace α] {f : α → EReal}\n    (hf : Continuous f) :\n    Continuous fun x => (f x).toENNReal :=\n  continuous_toENNReal.comp hf\n\n"}
{"name":"ContinuousOn.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\ns : Set α\nf : α → EReal\nhf : ContinuousOn f s\n⊢ ContinuousOn (fun x => (f x).toENNReal) s","decl":"@[fun_prop]\nlemma _root_.ContinuousOn.ereal_toENNReal {α : Type*} [TopologicalSpace α] {s : Set α}\n    {f : α → EReal} (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (f x).toENNReal) s :=\n  continuous_toENNReal.comp_continuousOn hf\n\n"}
{"name":"ContinuousWithinAt.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nf : α → EReal\ns : Set α\nx : α\nhf : ContinuousWithinAt f s x\n⊢ ContinuousWithinAt (fun x => (f x).toENNReal) s x","decl":"@[fun_prop]\nlemma _root_.ContinuousWithinAt.ereal_toENNReal {α : Type*} [TopologicalSpace α] {f : α → EReal}\n    {s : Set α} {x : α} (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => (f x).toENNReal) s x :=\n  continuous_toENNReal.continuousAt.comp_continuousWithinAt hf\n\n"}
{"name":"ContinuousAt.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\ninst✝ : TopologicalSpace α\nf : α → EReal\nx : α\nhf : ContinuousAt f x\n⊢ ContinuousAt (fun x => (f x).toENNReal) x","decl":"@[fun_prop]\nlemma _root_.ContinuousAt.ereal_toENNReal {α : Type*} [TopologicalSpace α] {f : α → EReal}\n    {x : α} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x => (f x).toENNReal) x :=\n  continuous_toENNReal.continuousAt.comp hf\n\n"}
{"name":"EReal.add_iInf_le_iInf_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\nu v : α → EReal\n⊢ LE.le (HAdd.hAdd (iInf fun x => u x) (iInf fun x => v x)) (iInf fun x => HAdd.hAdd u v x)","decl":"lemma add_iInf_le_iInf_add : (⨅ x, u x) + ⨅ x, v x ≤ ⨅ x, (u + v) x :=\n  le_iInf fun i ↦ add_le_add (iInf_le u i) (iInf_le v i)\n\n"}
{"name":"EReal.iSup_add_le_add_iSup","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_2\nu v : α → EReal\n⊢ LE.le (iSup fun x => HAdd.hAdd u v x) (HAdd.hAdd (iSup fun x => u x) (iSup fun x => v x))","decl":"lemma iSup_add_le_add_iSup : ⨆ x, (u + v) x ≤ (⨆ x, u x) + ⨆ x, v x :=\n  iSup_le fun i ↦ add_le_add (le_iSup u i) (le_iSup v i)\n\n"}
{"name":"EReal.liminf_neg","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nv : α → EReal\n⊢ Eq (Filter.liminf (Neg.neg v) f) (Neg.neg (Filter.limsup v f))","decl":"lemma liminf_neg : liminf (- v) f = - limsup v f :=\n  EReal.negOrderIso.limsup_apply.symm\n\n"}
{"name":"EReal.limsup_neg","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nv : α → EReal\n⊢ Eq (Filter.limsup (Neg.neg v) f) (Neg.neg (Filter.liminf v f))","decl":"lemma limsup_neg : limsup (- v) f = - liminf v f :=\n  EReal.negOrderIso.liminf_apply.symm\n\n"}
{"name":"EReal.le_liminf_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\n⊢ LE.le (HAdd.hAdd (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HAdd.hAdd u v) f)","decl":"lemma le_liminf_add : (liminf u f) + (liminf v f) ≤ liminf (u + v) f := by\n  refine add_le_of_forall_lt fun a a_u b b_v ↦ (le_liminf_iff).2 fun c c_ab ↦ ?_\n  filter_upwards [eventually_lt_of_lt_liminf a_u, eventually_lt_of_lt_liminf b_v] with x a_x b_x\n  exact c_ab.trans (add_lt_add a_x b_x)\n\n"}
{"name":"EReal.limsup_add_le","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.limsup v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.limsup v f) Bot.bot)\n⊢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"lemma limsup_add_le (h : limsup u f ≠ ⊥ ∨ limsup v f ≠ ⊤) (h' : limsup u f ≠ ⊤ ∨ limsup v f ≠ ⊥) :\n    limsup (u + v) f ≤ (limsup u f) + (limsup v f) := by\n  refine le_add_of_forall_gt h h' fun a a_u b b_v ↦ (limsup_le_iff).2 fun c c_ab ↦ ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v] with x a_x b_x\n  exact (add_lt_add a_x b_x).trans c_ab\n\n"}
{"name":"EReal.le_limsup_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\n⊢ LE.le (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HAdd.hAdd u v) f)","decl":"lemma le_limsup_add : (limsup u f) + (liminf v f) ≤ limsup (u + v) f :=\n  add_le_of_forall_lt fun _ a_u _ b_v ↦ (le_limsup_iff).2 fun _ c_ab ↦\n    (((frequently_lt_of_lt_limsup) a_u).and_eventually ((eventually_lt_of_lt_liminf) b_v)).mono\n    fun _ ab_x ↦ c_ab.trans (add_lt_add ab_x.1 ab_x.2)\n\n"}
{"name":"EReal.liminf_add_le","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.liminf v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.liminf v f) Bot.bot)\n⊢ LE.le (Filter.liminf (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_add_le (h : limsup u f ≠ ⊥ ∨ liminf v f ≠ ⊤) (h' : limsup u f ≠ ⊤ ∨ liminf v f ≠ ⊥) :\n    liminf (u + v) f ≤ (limsup u f) + (liminf v f) :=\n  le_add_of_forall_gt h h' fun _ a_u _ b_v ↦ (liminf_le_iff).2 fun _ c_ab ↦\n    (((frequently_lt_of_liminf_lt) b_v).and_eventually ((eventually_lt_of_limsup_lt) a_u)).mono\n    fun _ ab_x ↦ (add_lt_add ab_x.2 ab_x.1).trans c_ab\n\n"}
{"name":"EReal.add_liminf_le_liminf_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\n⊢ LE.le (HAdd.hAdd (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HAdd.hAdd u v) f)","decl":"@[deprecated (since := \"2024-11-11\")] alias add_liminf_le_liminf_add := le_liminf_add\n"}
{"name":"EReal.limsup_add_le_add_limsup","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.limsup v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.limsup v f) Bot.bot)\n⊢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"@[deprecated (since := \"2024-11-11\")] alias limsup_add_le_add_limsup := limsup_add_le\n"}
{"name":"EReal.limsup_add_liminf_le_limsup_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\n⊢ LE.le (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HAdd.hAdd u v) f)","decl":"@[deprecated (since := \"2024-11-11\")] alias limsup_add_liminf_le_limsup_add := le_limsup_add\n"}
{"name":"EReal.liminf_add_le_limsup_add_liminf","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.liminf v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.liminf v f) Bot.bot)\n⊢ LE.le (Filter.liminf (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f))","decl":"@[deprecated (since := \"2024-11-11\")] alias liminf_add_le_limsup_add_liminf := liminf_add_le\n\n"}
{"name":"EReal.limsup_add_bot_of_ne_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\nh : Eq (Filter.limsup u f) Bot.bot\nh' : Ne (Filter.limsup v f) Top.top\n⊢ Eq (Filter.limsup (HAdd.hAdd u v) f) Bot.bot","decl":"lemma limsup_add_bot_of_ne_top (h : limsup u f = ⊥) (h' : limsup v f ≠ ⊤) :\n    limsup (u + v) f = ⊥ := by\n  apply le_bot_iff.1 ((limsup_add_le (.inr h') _).trans _)\n  · rw [h]; exact .inl bot_ne_top\n  · rw [h, bot_add]\n\n"}
{"name":"EReal.limsup_add_le_of_le","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\na b : EReal\nha : LT.lt (Filter.limsup u f) a\nhb : LE.le (Filter.limsup v f) b\n⊢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd a b)","decl":"lemma limsup_add_le_of_le (ha : limsup u f < a) (hb : limsup v f ≤ b) :\n    limsup (u + v) f ≤ a + b := by\n  rcases eq_top_or_lt_top b with rfl | h\n  · rw [add_top_of_ne_bot ha.ne_bot]; exact le_top\n  · exact (limsup_add_le (.inr (hb.trans_lt h).ne) (.inl ha.ne_top)).trans (add_le_add ha.le hb)\n\n"}
{"name":"EReal.liminf_add_gt_of_gt","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\na b : EReal\nha : LT.lt a (Filter.liminf u f)\nhb : LT.lt b (Filter.liminf v f)\n⊢ LT.lt (HAdd.hAdd a b) (Filter.liminf (HAdd.hAdd u v) f)","decl":"lemma liminf_add_gt_of_gt (ha : a < liminf u f) (hb : b < liminf v f) :\n    a + b < liminf (u + v) f :=\n  (add_lt_add ha hb).trans_le le_liminf_add\n\n"}
{"name":"EReal.liminf_add_top_of_ne_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"α : Type u_3\nf : Filter α\nu v : α → EReal\nh : Eq (Filter.liminf u f) Top.top\nh' : Ne (Filter.liminf v f) Bot.bot\n⊢ Eq (Filter.liminf (HAdd.hAdd u v) f) Top.top","decl":"lemma liminf_add_top_of_ne_bot (h : liminf u f = ⊤) (h' : liminf v f ≠ ⊥) :\n    liminf (u + v) f = ⊤ := by\n  apply top_le_iff.1 (le_trans _ le_liminf_add)\n  rw [h, top_add_of_ne_bot h']\n\n"}
{"name":"EReal.continuousAt_add_coe_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a b : Real\n⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := ↑a, snd := ↑b }","decl":"theorem continuousAt_add_coe_coe (a b : ℝ) :\n    ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (a, b) := by\n  simp only [ContinuousAt, nhds_coe_coe, ← coe_add, tendsto_map'_iff, Function.comp_def,\n    tendsto_coe, tendsto_add]\n\n"}
{"name":"EReal.continuousAt_add_top_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Top.top, snd := ↑a }","decl":"theorem continuousAt_add_top_coe (a : ℝ) :\n    ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (⊤, a) := by\n  simp only [ContinuousAt, tendsto_nhds_top_iff_real, top_add_coe]\n  refine fun r ↦ ((lt_mem_nhds (coe_lt_top (r - (a - 1)))).prod_nhds\n    (lt_mem_nhds <| EReal.coe_lt_coe_iff.2 <| sub_one_lt _)).mono fun _ h ↦ ?_\n  simpa only [← coe_add, _root_.sub_add_cancel] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add_coe_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := ↑a, snd := Top.top }","decl":"theorem continuousAt_add_coe_top (a : ℝ) :\n    ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (a, ⊤) := by\n  simpa only [add_comm, Function.comp_def, ContinuousAt, Prod.swap]\n    using Tendsto.comp (continuousAt_add_top_coe a) (continuous_swap.tendsto ((a : EReal), ⊤))\n\n"}
{"name":"EReal.continuousAt_add_top_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Top.top, snd := Top.top }","decl":"theorem continuousAt_add_top_top : ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (⊤, ⊤) := by\n  simp only [ContinuousAt, tendsto_nhds_top_iff_real, top_add_top]\n  refine fun r ↦ ((lt_mem_nhds (coe_lt_top 0)).prod_nhds\n    (lt_mem_nhds <| coe_lt_top r)).mono fun _ h ↦ ?_\n  simpa only [coe_zero, zero_add] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add_bot_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Bot.bot, snd := ↑a }","decl":"theorem continuousAt_add_bot_coe (a : ℝ) :\n    ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (⊥, a) := by\n  simp only [ContinuousAt, tendsto_nhds_bot_iff_real, bot_add]\n  refine fun r ↦ ((gt_mem_nhds (bot_lt_coe (r - (a + 1)))).prod_nhds\n    (gt_mem_nhds <| EReal.coe_lt_coe_iff.2 <| lt_add_one _)).mono fun _ h ↦ ?_\n  simpa only [← coe_add, _root_.sub_add_cancel] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add_coe_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := ↑a, snd := Bot.bot }","decl":"theorem continuousAt_add_coe_bot (a : ℝ) :\n    ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (a, ⊥) := by\n  simpa only [add_comm, Function.comp_def, ContinuousAt, Prod.swap]\n    using Tendsto.comp (continuousAt_add_bot_coe a) (continuous_swap.tendsto ((a : EReal), ⊥))\n\n"}
{"name":"EReal.continuousAt_add_bot_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Bot.bot, snd := Bot.bot }","decl":"theorem continuousAt_add_bot_bot : ContinuousAt (fun p : EReal × EReal => p.1 + p.2) (⊥, ⊥) := by\n  simp only [ContinuousAt, tendsto_nhds_bot_iff_real, bot_add]\n  refine fun r ↦ ((gt_mem_nhds (bot_lt_coe 0)).prod_nhds\n    (gt_mem_nhds <| bot_lt_coe r)).mono fun _ h ↦ ?_\n  simpa only [coe_zero, zero_add] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"p : Prod EReal EReal\nh : Or (Ne p.1 Top.top) (Ne p.2 Bot.bot)\nh' : Or (Ne p.1 Bot.bot) (Ne p.2 Top.top)\n⊢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) p","decl":"/-- The addition on `EReal` is continuous except where it doesn't make sense (i.e., at `(⊥, ⊤)`\nand at `(⊤, ⊥)`). -/\ntheorem continuousAt_add {p : EReal × EReal} (h : p.1 ≠ ⊤ ∨ p.2 ≠ ⊥) (h' : p.1 ≠ ⊥ ∨ p.2 ≠ ⊤) :\n    ContinuousAt (fun p : EReal × EReal => p.1 + p.2) p := by\n  rcases p with ⟨x, y⟩\n  induction x <;> induction y\n  · exact continuousAt_add_bot_bot\n  · exact continuousAt_add_bot_coe _\n  · simp at h'\n  · exact continuousAt_add_coe_bot _\n  · exact continuousAt_add_coe_coe _ _\n  · exact continuousAt_add_coe_top _\n  · simp at h\n  · exact continuousAt_add_top_coe _\n  · exact continuousAt_add_top_top\n\n"}
{"name":"EReal.continuousAt_mul","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"p : Prod EReal EReal\nh₁ : Or (Ne p.1 0) (Ne p.2 Bot.bot)\nh₂ : Or (Ne p.1 0) (Ne p.2 Top.top)\nh₃ : Or (Ne p.1 Bot.bot) (Ne p.2 0)\nh₄ : Or (Ne p.1 Top.top) (Ne p.2 0)\n⊢ ContinuousAt (fun p => HMul.hMul p.1 p.2) p","decl":"/-- The multiplication on `EReal` is continuous except at indeterminacies\n(i.e. whenever one value is zero and the other infinite). -/\ntheorem continuousAt_mul {p : EReal × EReal} (h₁ : p.1 ≠ 0 ∨ p.2 ≠ ⊥)\n    (h₂ : p.1 ≠ 0 ∨ p.2 ≠ ⊤) (h₃ : p.1 ≠ ⊥ ∨ p.2 ≠ 0) (h₄ : p.1 ≠ ⊤ ∨ p.2 ≠ 0) :\n    ContinuousAt (fun p : EReal × EReal ↦ p.1 * p.2) p := by\n  rcases p with ⟨x, y⟩\n  induction x <;> induction y\n  · exact continuousAt_mul_symm3 continuousAt_mul_top_top\n  · simp only [ne_eq, not_true_eq_false, EReal.coe_eq_zero, false_or] at h₃\n    exact continuousAt_mul_symm1 (continuousAt_mul_top_ne_zero h₃)\n  · exact EReal.neg_top ▸ continuousAt_mul_symm1 continuousAt_mul_top_top\n  · simp only [ne_eq, EReal.coe_eq_zero, not_true_eq_false, or_false] at h₁\n    exact continuousAt_mul_symm2 (continuousAt_mul_swap (continuousAt_mul_top_ne_zero h₁))\n  · exact continuousAt_mul_coe_coe _ _\n  · simp only [ne_eq, EReal.coe_eq_zero, not_true_eq_false, or_false] at h₂\n    exact continuousAt_mul_swap (continuousAt_mul_top_ne_zero h₂)\n  · exact continuousAt_mul_symm2 continuousAt_mul_top_top\n  · simp only [ne_eq, not_true_eq_false, EReal.coe_eq_zero, false_or] at h₄\n    exact continuousAt_mul_top_ne_zero h₄\n  · exact continuousAt_mul_top_top\n\n"}
{"name":"EReal.lowerSemicontinuous_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"⊢ LowerSemicontinuous fun p => HAdd.hAdd p.1 p.2","decl":"lemma lowerSemicontinuous_add : LowerSemicontinuous fun p : EReal × EReal ↦ p.1 + p.2 := by\n  intro x y\n  by_cases hx₁ : x.1 = ⊥\n  · simp [hx₁]\n  by_cases hx₂ : x.2 = ⊥\n  · simp [hx₂]\n  · exact continuousAt_add (.inr hx₂) (.inl hx₁) |>.lowerSemicontinuousAt _\n\n"}
