{"name":"EReal.isEmbedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsEmbedding Real.toEReal","decl":"theorem isEmbedding_coe : IsEmbedding ((‚Üë) : ‚Ñù ‚Üí EReal) :=\n  coe_strictMono.isEmbedding_of_ordConnected <| by rw [range_coe_eq_Ioo]; exact ordConnected_Ioo\n\n"}
{"name":"EReal.embedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsEmbedding Real.toEReal","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe := isEmbedding_coe\n\n"}
{"name":"EReal.isOpenEmbedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsOpenEmbedding Real.toEReal","decl":"theorem isOpenEmbedding_coe : IsOpenEmbedding ((‚Üë) : ‚Ñù ‚Üí EReal) :=\n  ‚ü®isEmbedding_coe, by simp only [range_coe_eq_Ioo, isOpen_Ioo]‚ü©\n\n"}
{"name":"EReal.openEmbedding_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsOpenEmbedding Real.toEReal","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding_coe := isOpenEmbedding_coe\n\n"}
{"name":"EReal.tendsto_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\nf : Filter Œ±\nm : Œ± ‚Üí Real\na : Real\n‚ä¢ Iff (Filter.Tendsto (fun a => ‚Üë(m a)) f (nhds ‚Üëa)) (Filter.Tendsto m f (nhds a))","decl":"@[norm_cast]\ntheorem tendsto_coe {Œ± : Type*} {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù} {a : ‚Ñù} :\n    Tendsto (fun a => (m a : EReal)) f (ùìù ‚Üëa) ‚Üî Tendsto m f (ùìù a) :=\n  isEmbedding_coe.tendsto_nhds_iff.symm\n\n"}
{"name":"continuous_coe_real_ereal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Continuous Real.toEReal","decl":"theorem _root_.continuous_coe_real_ereal : Continuous ((‚Üë) : ‚Ñù ‚Üí EReal) :=\n  isEmbedding_coe.continuous\n\n"}
{"name":"EReal.continuous_coe_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí Real\n‚ä¢ Iff (Continuous fun a => ‚Üë(f a)) (Continuous f)","decl":"theorem continuous_coe_iff {f : Œ± ‚Üí ‚Ñù} : (Continuous fun a => (f a : EReal)) ‚Üî Continuous f :=\n  isEmbedding_coe.continuous_iff.symm\n\n"}
{"name":"EReal.nhds_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"r : Real\n‚ä¢ Eq (nhds ‚Üër) (Filter.map Real.toEReal (nhds r))","decl":"theorem nhds_coe {r : ‚Ñù} : ùìù (r : EReal) = (ùìù r).map (‚Üë) :=\n  (isOpenEmbedding_coe.map_nhds_eq r).symm\n\n"}
{"name":"EReal.nhds_coe_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"r p : Real\n‚ä¢ Eq (nhds { fst := ‚Üër, snd := ‚Üëp }) (Filter.map (fun p => { fst := ‚Üëp.1, snd := ‚Üëp.2 }) (nhds { fst := r, snd := p }))","decl":"theorem nhds_coe_coe {r p : ‚Ñù} :\n    ùìù ((r : EReal), (p : EReal)) = (ùìù (r, p)).map fun p : ‚Ñù √ó ‚Ñù => (‚Üëp.1, ‚Üëp.2) :=\n  ((isOpenEmbedding_coe.prodMap isOpenEmbedding_coe).map_nhds_eq (r, p)).symm\n\n"}
{"name":"EReal.tendsto_toReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : EReal\nha : Ne a Top.top\nh'a : Ne a Bot.bot\n‚ä¢ Filter.Tendsto EReal.toReal (nhds a) (nhds a.toReal)","decl":"theorem tendsto_toReal {a : EReal} (ha : a ‚â† ‚ä§) (h'a : a ‚â† ‚ä•) :\n    Tendsto EReal.toReal (ùìù a) (ùìù a.toReal) := by\n  lift a to ‚Ñù using ‚ü®ha, h'a‚ü©\n  rw [nhds_coe, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"EReal.continuousOn_toReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ ContinuousOn EReal.toReal (HasCompl.compl (Insert.insert Bot.bot (Singleton.singleton Top.top)))","decl":"theorem continuousOn_toReal : ContinuousOn EReal.toReal ({‚ä•, ‚ä§}·∂ú : Set EReal) := fun _a ha =>\n  ContinuousAt.continuousWithinAt (tendsto_toReal (mt Or.inr ha) (mt Or.inl ha))\n\n"}
{"name":"EReal.isEmbedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsEmbedding ENNReal.toEReal","decl":"theorem isEmbedding_coe_ennreal : IsEmbedding ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=\n  coe_ennreal_strictMono.isEmbedding_of_ordConnected <| by\n    rw [range_coe_ennreal]; exact ordConnected_Ici\n\n"}
{"name":"EReal.embedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsEmbedding ENNReal.toEReal","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_coe_ennreal := isEmbedding_coe_ennreal\n\n"}
{"name":"EReal.isClosedEmbedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsClosedEmbedding ENNReal.toEReal","decl":"theorem isClosedEmbedding_coe_ennreal : IsClosedEmbedding ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=\n  ‚ü®isEmbedding_coe_ennreal, by rw [range_coe_ennreal]; exact isClosed_Ici‚ü©\n\n"}
{"name":"EReal.closedEmbedding_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Topology.IsClosedEmbedding ENNReal.toEReal","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding_coe_ennreal := isClosedEmbedding_coe_ennreal\n\n"}
{"name":"EReal.tendsto_coe_ennreal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\nf : Filter Œ±\nm : Œ± ‚Üí ENNReal\na : ENNReal\n‚ä¢ Iff (Filter.Tendsto (fun a => ‚Üë(m a)) f (nhds ‚Üëa)) (Filter.Tendsto m f (nhds a))","decl":"@[norm_cast]\ntheorem tendsto_coe_ennreal {Œ± : Type*} {f : Filter Œ±} {m : Œ± ‚Üí ‚Ñù‚â•0‚àû} {a : ‚Ñù‚â•0‚àû} :\n    Tendsto (fun a => (m a : EReal)) f (ùìù ‚Üëa) ‚Üî Tendsto m f (ùìù a) :=\n  isEmbedding_coe_ennreal.tendsto_nhds_iff.symm\n\n"}
{"name":"continuous_coe_ennreal_ereal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Continuous ENNReal.toEReal","decl":"theorem _root_.continuous_coe_ennreal_ereal : Continuous ((‚Üë) : ‚Ñù‚â•0‚àû ‚Üí EReal) :=\n  isEmbedding_coe_ennreal.continuous\n\n"}
{"name":"EReal.continuous_coe_ennreal_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_1\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí ENNReal\n‚ä¢ Iff (Continuous fun a => ‚Üë(f a)) (Continuous f)","decl":"theorem continuous_coe_ennreal_iff {f : Œ± ‚Üí ‚Ñù‚â•0‚àû} :\n    (Continuous fun a => (f a : EReal)) ‚Üî Continuous f :=\n  isEmbedding_coe_ennreal.continuous_iff.symm\n\n"}
{"name":"EReal.nhds_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Eq (nhds Top.top) (iInf fun a => iInf fun x => Filter.principal (Set.Ioi a))","decl":"theorem nhds_top : ùìù (‚ä§ : EReal) = ‚®Ö (a) (_ : a ‚â† ‚ä§), ùìü (Ioi a) :=\n  nhds_top_order.trans <| by simp only [lt_top_iff_ne_top]\n\n"}
{"name":"EReal.nhds_top_basis","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ (nhds Top.top).HasBasis (fun x => True) fun x => Set.Ioi ‚Üëx","decl":"nonrec theorem nhds_top_basis : (ùìù (‚ä§ : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Ioi ¬∑) := by\n  refine nhds_top_basis.to_hasBasis (fun x hx => ?_) fun _ _ ‚Ü¶ ‚ü®_, coe_lt_top _, Subset.rfl‚ü©\n  rcases exists_rat_btwn_of_lt hx with ‚ü®y, hxy, -‚ü©\n  exact ‚ü®_, trivial, Ioi_subset_Ioi hxy.le‚ü©\n\n"}
{"name":"EReal.nhds_top'","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Eq (nhds Top.top) (iInf fun a => Filter.principal (Set.Ioi ‚Üëa))","decl":"theorem nhds_top' : ùìù (‚ä§ : EReal) = ‚®Ö a : ‚Ñù, ùìü (Ioi ‚Üëa) := nhds_top_basis.eq_iInf\n\n"}
{"name":"EReal.mem_nhds_top_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"s : Set EReal\n‚ä¢ Iff (Membership.mem (nhds Top.top) s) (Exists fun y => HasSubset.Subset (Set.Ioi ‚Üëy) s)","decl":"theorem mem_nhds_top_iff {s : Set EReal} : s ‚àà ùìù (‚ä§ : EReal) ‚Üî ‚àÉ y : ‚Ñù, Ioi (y : EReal) ‚äÜ s :=\n  nhds_top_basis.mem_iff.trans <| by simp only [true_and]\n\n"}
{"name":"EReal.tendsto_nhds_top_iff_real","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\nm : Œ± ‚Üí EReal\nf : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto m f (nhds Top.top)) (‚àÄ (x : Real), Filter.Eventually (fun a => LT.lt (‚Üëx) (m a)) f)","decl":"theorem tendsto_nhds_top_iff_real {Œ± : Type*} {m : Œ± ‚Üí EReal} {f : Filter Œ±} :\n    Tendsto m f (ùìù ‚ä§) ‚Üî ‚àÄ x : ‚Ñù, ‚àÄ·∂† a in f, ‚Üëx < m a :=\n  nhds_top_basis.tendsto_right_iff.trans <| by simp only [true_implies, mem_Ioi]\n\n"}
{"name":"EReal.nhds_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Eq (nhds Bot.bot) (iInf fun a => iInf fun x => Filter.principal (Set.Iio a))","decl":"theorem nhds_bot : ùìù (‚ä• : EReal) = ‚®Ö (a) (_ : a ‚â† ‚ä•), ùìü (Iio a) :=\n  nhds_bot_order.trans <| by simp only [bot_lt_iff_ne_bot]\n\n"}
{"name":"EReal.nhds_bot_basis","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ (nhds Bot.bot).HasBasis (fun x => True) fun x => Set.Iio ‚Üëx","decl":"theorem nhds_bot_basis : (ùìù (‚ä• : EReal)).HasBasis (fun _ : ‚Ñù ‚Ü¶ True) (Iio ¬∑) := by\n  refine _root_.nhds_bot_basis.to_hasBasis (fun x hx => ?_) fun _ _ ‚Ü¶ ‚ü®_, bot_lt_coe _, Subset.rfl‚ü©\n  rcases exists_rat_btwn_of_lt hx with ‚ü®y, -, hxy‚ü©\n  exact ‚ü®_, trivial, Iio_subset_Iio hxy.le‚ü©\n\n"}
{"name":"EReal.nhds_bot'","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Eq (nhds Bot.bot) (iInf fun a => Filter.principal (Set.Iio ‚Üëa))","decl":"theorem nhds_bot' : ùìù (‚ä• : EReal) = ‚®Ö a : ‚Ñù, ùìü (Iio ‚Üëa) :=\n  nhds_bot_basis.eq_iInf\n\n"}
{"name":"EReal.mem_nhds_bot_iff","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"s : Set EReal\n‚ä¢ Iff (Membership.mem (nhds Bot.bot) s) (Exists fun y => HasSubset.Subset (Set.Iio ‚Üëy) s)","decl":"theorem mem_nhds_bot_iff {s : Set EReal} : s ‚àà ùìù (‚ä• : EReal) ‚Üî ‚àÉ y : ‚Ñù, Iio (y : EReal) ‚äÜ s :=\n  nhds_bot_basis.mem_iff.trans <| by simp only [true_and]\n\n"}
{"name":"EReal.tendsto_nhds_bot_iff_real","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\nm : Œ± ‚Üí EReal\nf : Filter Œ±\n‚ä¢ Iff (Filter.Tendsto m f (nhds Bot.bot)) (‚àÄ (x : Real), Filter.Eventually (fun a => LT.lt (m a) ‚Üëx) f)","decl":"theorem tendsto_nhds_bot_iff_real {Œ± : Type*} {m : Œ± ‚Üí EReal} {f : Filter Œ±} :\n    Tendsto m f (ùìù ‚ä•) ‚Üî ‚àÄ x : ‚Ñù, ‚àÄ·∂† a in f, m a < x :=\n  nhds_bot_basis.tendsto_right_iff.trans <| by simp only [true_implies, mem_Iio]\n\n"}
{"name":"EReal.nhdsWithin_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Eq (nhdsWithin Top.top (HasCompl.compl (Singleton.singleton Top.top))) (Filter.map Real.toEReal Filter.atTop)","decl":"lemma nhdsWithin_top : ùìù[‚â†] (‚ä§ : EReal) = (atTop).map Real.toEReal := by\n  apply (nhdsWithin_hasBasis nhds_top_basis_Ici _).ext (atTop_basis.map Real.toEReal)\n  ¬∑ simp only [EReal.image_coe_Ici, true_and]\n    intro x hx\n    by_cases hx_bot : x = ‚ä•\n    ¬∑ simp [hx_bot]\n    lift x to ‚Ñù using ‚ü®hx.ne_top, hx_bot‚ü©\n    refine ‚ü®x, fun x ‚ü®h1, h2‚ü© ‚Ü¶ ?_‚ü©\n    simp [h1, h2.ne_top]\n  ¬∑ simp only [EReal.image_coe_Ici, true_implies]\n    refine fun x ‚Ü¶ ‚ü®x, ‚ü®EReal.coe_lt_top x, fun x ‚ü®(h1 : _ ‚â§ x), h2‚ü© ‚Ü¶ ?_‚ü©‚ü©\n    simp [h1, Ne.lt_top' fun a ‚Ü¶ h2 a.symm]\n\n"}
{"name":"EReal.nhdsWithin_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Eq (nhdsWithin Bot.bot (HasCompl.compl (Singleton.singleton Bot.bot))) (Filter.map Real.toEReal Filter.atBot)","decl":"lemma nhdsWithin_bot : ùìù[‚â†] (‚ä• : EReal) = (atBot).map Real.toEReal := by\n  apply (nhdsWithin_hasBasis nhds_bot_basis_Iic _).ext (atBot_basis.map Real.toEReal)\n  ¬∑ simp only [EReal.image_coe_Iic, Set.subset_compl_singleton_iff, Set.mem_Ioc, lt_self_iff_false,\n      bot_le, and_true, not_false_eq_true, true_and]\n    intro x hx\n    by_cases hx_top : x = ‚ä§\n    ¬∑ simp [hx_top]\n    lift x to ‚Ñù using ‚ü®hx_top, hx.ne_bot‚ü©\n    refine ‚ü®x, fun x ‚ü®h1, h2‚ü© ‚Ü¶ ?_‚ü©\n    simp [h2, h1.ne_bot]\n  ¬∑ simp only [EReal.image_coe_Iic, true_implies]\n    refine fun x ‚Ü¶ ‚ü®x, ‚ü®EReal.bot_lt_coe x, fun x ‚ü®(h1 : x ‚â§ _), h2‚ü© ‚Ü¶ ?_‚ü©‚ü©\n    simp [h1, Ne.bot_lt' fun a ‚Ü¶ h2 a.symm]\n\n"}
{"name":"EReal.tendsto_toReal_atTop","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Filter.Tendsto EReal.toReal (nhdsWithin Top.top (HasCompl.compl (Singleton.singleton Top.top))) Filter.atTop","decl":"lemma tendsto_toReal_atTop : Tendsto EReal.toReal (ùìù[‚â†] ‚ä§) atTop := by\n  rw [nhdsWithin_top, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"EReal.tendsto_toReal_atBot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Filter.Tendsto EReal.toReal (nhdsWithin Bot.bot (HasCompl.compl (Singleton.singleton Bot.bot))) Filter.atBot","decl":"lemma tendsto_toReal_atBot : Tendsto EReal.toReal (ùìù[‚â†] ‚ä•) atBot := by\n  rw [nhdsWithin_bot, tendsto_map'_iff]\n  exact tendsto_id\n\n"}
{"name":"EReal.continuous_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ Continuous EReal.toENNReal","decl":"lemma continuous_toENNReal : Continuous EReal.toENNReal := by\n  refine continuous_iff_continuousAt.mpr fun x ‚Ü¶ ?_\n  by_cases h_top : x = ‚ä§\n  ¬∑ simp only [ContinuousAt, h_top, toENNReal_top]\n    refine ENNReal.tendsto_nhds_top fun n ‚Ü¶ ?_\n    filter_upwards [eventually_gt_nhds (coe_lt_top n)] with y hy\n    exact toENNReal_coe (x := n) ‚ñ∏ toENNReal_lt_toENNReal (coe_ennreal_nonneg _) hy\n  refine ContinuousOn.continuousAt ?_ (compl_singleton_mem_nhds_iff.mpr h_top)\n  refine (continuousOn_of_forall_continuousAt fun x hx ‚Ü¶ ?_).congr (fun _ h ‚Ü¶ toENNReal_of_ne_top h)\n  by_cases h_bot : x = ‚ä•\n  ¬∑ refine tendsto_nhds_of_eventually_eq ?_\n    rw [h_bot, nhds_bot_basis.eventually_iff]\n    simp [toReal_bot, ENNReal.ofReal_zero, ENNReal.ofReal_eq_zero, true_and]\n    exact ‚ü®0, fun _ hx ‚Ü¶ toReal_nonpos hx.le‚ü©\n  refine ENNReal.continuous_ofReal.continuousAt.comp' <| continuousOn_toReal.continuousAt\n    <| (toFinite _).isClosed.compl_mem_nhds ?_\n  simp_all only [mem_compl_iff, mem_singleton_iff, mem_insert_iff, or_self, not_false_eq_true]\n\n"}
{"name":"Continous.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí EReal\nhf : Continuous f\n‚ä¢ Continuous fun x => (f x).toENNReal","decl":"@[fun_prop]\nlemma _root_.Continous.ereal_toENNReal {Œ± : Type*} [TopologicalSpace Œ±] {f : Œ± ‚Üí EReal}\n    (hf : Continuous f) :\n    Continuous fun x => (f x).toENNReal :=\n  continuous_toENNReal.comp hf\n\n"}
{"name":"ContinuousOn.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\ns : Set Œ±\nf : Œ± ‚Üí EReal\nhf : ContinuousOn f s\n‚ä¢ ContinuousOn (fun x => (f x).toENNReal) s","decl":"@[fun_prop]\nlemma _root_.ContinuousOn.ereal_toENNReal {Œ± : Type*} [TopologicalSpace Œ±] {s : Set Œ±}\n    {f : Œ± ‚Üí EReal} (hf : ContinuousOn f s) :\n    ContinuousOn (fun x => (f x).toENNReal) s :=\n  continuous_toENNReal.comp_continuousOn hf\n\n"}
{"name":"ContinuousWithinAt.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí EReal\ns : Set Œ±\nx : Œ±\nhf : ContinuousWithinAt f s x\n‚ä¢ ContinuousWithinAt (fun x => (f x).toENNReal) s x","decl":"@[fun_prop]\nlemma _root_.ContinuousWithinAt.ereal_toENNReal {Œ± : Type*} [TopologicalSpace Œ±] {f : Œ± ‚Üí EReal}\n    {s : Set Œ±} {x : Œ±} (hf : ContinuousWithinAt f s x) :\n    ContinuousWithinAt (fun x => (f x).toENNReal) s x :=\n  continuous_toENNReal.continuousAt.comp_continuousWithinAt hf\n\n"}
{"name":"ContinuousAt.ereal_toENNReal","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\ninst‚úù : TopologicalSpace Œ±\nf : Œ± ‚Üí EReal\nx : Œ±\nhf : ContinuousAt f x\n‚ä¢ ContinuousAt (fun x => (f x).toENNReal) x","decl":"@[fun_prop]\nlemma _root_.ContinuousAt.ereal_toENNReal {Œ± : Type*} [TopologicalSpace Œ±] {f : Œ± ‚Üí EReal}\n    {x : Œ±} (hf : ContinuousAt f x) :\n    ContinuousAt (fun x => (f x).toENNReal) x :=\n  continuous_toENNReal.continuousAt.comp hf\n\n"}
{"name":"EReal.add_iInf_le_iInf_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\nu v : Œ± ‚Üí EReal\n‚ä¢ LE.le (HAdd.hAdd (iInf fun x => u x) (iInf fun x => v x)) (iInf fun x => HAdd.hAdd u v x)","decl":"lemma add_iInf_le_iInf_add : (‚®Ö x, u x) + ‚®Ö x, v x ‚â§ ‚®Ö x, (u + v) x :=\n  le_iInf fun i ‚Ü¶ add_le_add (iInf_le u i) (iInf_le v i)\n\n"}
{"name":"EReal.iSup_add_le_add_iSup","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_2\nu v : Œ± ‚Üí EReal\n‚ä¢ LE.le (iSup fun x => HAdd.hAdd u v x) (HAdd.hAdd (iSup fun x => u x) (iSup fun x => v x))","decl":"lemma iSup_add_le_add_iSup : ‚®Ü x, (u + v) x ‚â§ (‚®Ü x, u x) + ‚®Ü x, v x :=\n  iSup_le fun i ‚Ü¶ add_le_add (le_iSup u i) (le_iSup v i)\n\n"}
{"name":"EReal.liminf_neg","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nv : Œ± ‚Üí EReal\n‚ä¢ Eq (Filter.liminf (Neg.neg v) f) (Neg.neg (Filter.limsup v f))","decl":"lemma liminf_neg : liminf (- v) f = - limsup v f :=\n  EReal.negOrderIso.limsup_apply.symm\n\n"}
{"name":"EReal.limsup_neg","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nv : Œ± ‚Üí EReal\n‚ä¢ Eq (Filter.limsup (Neg.neg v) f) (Neg.neg (Filter.liminf v f))","decl":"lemma limsup_neg : limsup (- v) f = - liminf v f :=\n  EReal.negOrderIso.liminf_apply.symm\n\n"}
{"name":"EReal.le_liminf_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\n‚ä¢ LE.le (HAdd.hAdd (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HAdd.hAdd u v) f)","decl":"lemma le_liminf_add : (liminf u f) + (liminf v f) ‚â§ liminf (u + v) f := by\n  refine add_le_of_forall_lt fun a a_u b b_v ‚Ü¶ (le_liminf_iff).2 fun c c_ab ‚Ü¶ ?_\n  filter_upwards [eventually_lt_of_lt_liminf a_u, eventually_lt_of_lt_liminf b_v] with x a_x b_x\n  exact c_ab.trans (add_lt_add a_x b_x)\n\n"}
{"name":"EReal.limsup_add_le","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.limsup v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.limsup v f) Bot.bot)\n‚ä¢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"lemma limsup_add_le (h : limsup u f ‚â† ‚ä• ‚à® limsup v f ‚â† ‚ä§) (h' : limsup u f ‚â† ‚ä§ ‚à® limsup v f ‚â† ‚ä•) :\n    limsup (u + v) f ‚â§ (limsup u f) + (limsup v f) := by\n  refine le_add_of_forall_gt h h' fun a a_u b b_v ‚Ü¶ (limsup_le_iff).2 fun c c_ab ‚Ü¶ ?_\n  filter_upwards [eventually_lt_of_limsup_lt a_u, eventually_lt_of_limsup_lt b_v] with x a_x b_x\n  exact (add_lt_add a_x b_x).trans c_ab\n\n"}
{"name":"EReal.le_limsup_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\n‚ä¢ LE.le (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HAdd.hAdd u v) f)","decl":"lemma le_limsup_add : (limsup u f) + (liminf v f) ‚â§ limsup (u + v) f :=\n  add_le_of_forall_lt fun _ a_u _ b_v ‚Ü¶ (le_limsup_iff).2 fun _ c_ab ‚Ü¶\n    (((frequently_lt_of_lt_limsup) a_u).and_eventually ((eventually_lt_of_lt_liminf) b_v)).mono\n    fun _ ab_x ‚Ü¶ c_ab.trans (add_lt_add ab_x.1 ab_x.2)\n\n"}
{"name":"EReal.liminf_add_le","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.liminf v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.liminf v f) Bot.bot)\n‚ä¢ LE.le (Filter.liminf (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f))","decl":"lemma liminf_add_le (h : limsup u f ‚â† ‚ä• ‚à® liminf v f ‚â† ‚ä§) (h' : limsup u f ‚â† ‚ä§ ‚à® liminf v f ‚â† ‚ä•) :\n    liminf (u + v) f ‚â§ (limsup u f) + (liminf v f) :=\n  le_add_of_forall_gt h h' fun _ a_u _ b_v ‚Ü¶ (liminf_le_iff).2 fun _ c_ab ‚Ü¶\n    (((frequently_lt_of_liminf_lt) b_v).and_eventually ((eventually_lt_of_limsup_lt) a_u)).mono\n    fun _ ab_x ‚Ü¶ (add_lt_add ab_x.2 ab_x.1).trans c_ab\n\n"}
{"name":"EReal.add_liminf_le_liminf_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\n‚ä¢ LE.le (HAdd.hAdd (Filter.liminf u f) (Filter.liminf v f)) (Filter.liminf (HAdd.hAdd u v) f)","decl":"@[deprecated (since := \"2024-11-11\")] alias add_liminf_le_liminf_add := le_liminf_add\n"}
{"name":"EReal.limsup_add_le_add_limsup","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.limsup v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.limsup v f) Bot.bot)\n‚ä¢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.limsup v f))","decl":"@[deprecated (since := \"2024-11-11\")] alias limsup_add_le_add_limsup := limsup_add_le\n"}
{"name":"EReal.limsup_add_liminf_le_limsup_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\n‚ä¢ LE.le (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f)) (Filter.limsup (HAdd.hAdd u v) f)","decl":"@[deprecated (since := \"2024-11-11\")] alias limsup_add_liminf_le_limsup_add := le_limsup_add\n"}
{"name":"EReal.liminf_add_le_limsup_add_liminf","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\nh : Or (Ne (Filter.limsup u f) Bot.bot) (Ne (Filter.liminf v f) Top.top)\nh' : Or (Ne (Filter.limsup u f) Top.top) (Ne (Filter.liminf v f) Bot.bot)\n‚ä¢ LE.le (Filter.liminf (HAdd.hAdd u v) f) (HAdd.hAdd (Filter.limsup u f) (Filter.liminf v f))","decl":"@[deprecated (since := \"2024-11-11\")] alias liminf_add_le_limsup_add_liminf := liminf_add_le\n\n"}
{"name":"EReal.limsup_add_bot_of_ne_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\nh : Eq (Filter.limsup u f) Bot.bot\nh' : Ne (Filter.limsup v f) Top.top\n‚ä¢ Eq (Filter.limsup (HAdd.hAdd u v) f) Bot.bot","decl":"lemma limsup_add_bot_of_ne_top (h : limsup u f = ‚ä•) (h' : limsup v f ‚â† ‚ä§) :\n    limsup (u + v) f = ‚ä• := by\n  apply le_bot_iff.1 ((limsup_add_le (.inr h') _).trans _)\n  ¬∑ rw [h]; exact .inl bot_ne_top\n  ¬∑ rw [h, bot_add]\n\n"}
{"name":"EReal.limsup_add_le_of_le","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\na b : EReal\nha : LT.lt (Filter.limsup u f) a\nhb : LE.le (Filter.limsup v f) b\n‚ä¢ LE.le (Filter.limsup (HAdd.hAdd u v) f) (HAdd.hAdd a b)","decl":"lemma limsup_add_le_of_le (ha : limsup u f < a) (hb : limsup v f ‚â§ b) :\n    limsup (u + v) f ‚â§ a + b := by\n  rcases eq_top_or_lt_top b with rfl | h\n  ¬∑ rw [add_top_of_ne_bot ha.ne_bot]; exact le_top\n  ¬∑ exact (limsup_add_le (.inr (hb.trans_lt h).ne) (.inl ha.ne_top)).trans (add_le_add ha.le hb)\n\n"}
{"name":"EReal.liminf_add_gt_of_gt","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\na b : EReal\nha : LT.lt a (Filter.liminf u f)\nhb : LT.lt b (Filter.liminf v f)\n‚ä¢ LT.lt (HAdd.hAdd a b) (Filter.liminf (HAdd.hAdd u v) f)","decl":"lemma liminf_add_gt_of_gt (ha : a < liminf u f) (hb : b < liminf v f) :\n    a + b < liminf (u + v) f :=\n  (add_lt_add ha hb).trans_le le_liminf_add\n\n"}
{"name":"EReal.liminf_add_top_of_ne_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"Œ± : Type u_3\nf : Filter Œ±\nu v : Œ± ‚Üí EReal\nh : Eq (Filter.liminf u f) Top.top\nh' : Ne (Filter.liminf v f) Bot.bot\n‚ä¢ Eq (Filter.liminf (HAdd.hAdd u v) f) Top.top","decl":"lemma liminf_add_top_of_ne_bot (h : liminf u f = ‚ä§) (h' : liminf v f ‚â† ‚ä•) :\n    liminf (u + v) f = ‚ä§ := by\n  apply top_le_iff.1 (le_trans _ le_liminf_add)\n  rw [h, top_add_of_ne_bot h']\n\n"}
{"name":"EReal.continuousAt_add_coe_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a b : Real\n‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := ‚Üëa, snd := ‚Üëb }","decl":"theorem continuousAt_add_coe_coe (a b : ‚Ñù) :\n    ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (a, b) := by\n  simp only [ContinuousAt, nhds_coe_coe, ‚Üê coe_add, tendsto_map'_iff, Function.comp_def,\n    tendsto_coe, tendsto_add]\n\n"}
{"name":"EReal.continuousAt_add_top_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Top.top, snd := ‚Üëa }","decl":"theorem continuousAt_add_top_coe (a : ‚Ñù) :\n    ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (‚ä§, a) := by\n  simp only [ContinuousAt, tendsto_nhds_top_iff_real, top_add_coe]\n  refine fun r ‚Ü¶ ((lt_mem_nhds (coe_lt_top (r - (a - 1)))).prod_nhds\n    (lt_mem_nhds <| EReal.coe_lt_coe_iff.2 <| sub_one_lt _)).mono fun _ h ‚Ü¶ ?_\n  simpa only [‚Üê coe_add, _root_.sub_add_cancel] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add_coe_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := ‚Üëa, snd := Top.top }","decl":"theorem continuousAt_add_coe_top (a : ‚Ñù) :\n    ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (a, ‚ä§) := by\n  simpa only [add_comm, Function.comp_def, ContinuousAt, Prod.swap]\n    using Tendsto.comp (continuousAt_add_top_coe a) (continuous_swap.tendsto ((a : EReal), ‚ä§))\n\n"}
{"name":"EReal.continuousAt_add_top_top","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Top.top, snd := Top.top }","decl":"theorem continuousAt_add_top_top : ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (‚ä§, ‚ä§) := by\n  simp only [ContinuousAt, tendsto_nhds_top_iff_real, top_add_top]\n  refine fun r ‚Ü¶ ((lt_mem_nhds (coe_lt_top 0)).prod_nhds\n    (lt_mem_nhds <| coe_lt_top r)).mono fun _ h ‚Ü¶ ?_\n  simpa only [coe_zero, zero_add] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add_bot_coe","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Bot.bot, snd := ‚Üëa }","decl":"theorem continuousAt_add_bot_coe (a : ‚Ñù) :\n    ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (‚ä•, a) := by\n  simp only [ContinuousAt, tendsto_nhds_bot_iff_real, bot_add]\n  refine fun r ‚Ü¶ ((gt_mem_nhds (bot_lt_coe (r - (a + 1)))).prod_nhds\n    (gt_mem_nhds <| EReal.coe_lt_coe_iff.2 <| lt_add_one _)).mono fun _ h ‚Ü¶ ?_\n  simpa only [‚Üê coe_add, _root_.sub_add_cancel] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add_coe_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"a : Real\n‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := ‚Üëa, snd := Bot.bot }","decl":"theorem continuousAt_add_coe_bot (a : ‚Ñù) :\n    ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (a, ‚ä•) := by\n  simpa only [add_comm, Function.comp_def, ContinuousAt, Prod.swap]\n    using Tendsto.comp (continuousAt_add_bot_coe a) (continuous_swap.tendsto ((a : EReal), ‚ä•))\n\n"}
{"name":"EReal.continuousAt_add_bot_bot","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) { fst := Bot.bot, snd := Bot.bot }","decl":"theorem continuousAt_add_bot_bot : ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) (‚ä•, ‚ä•) := by\n  simp only [ContinuousAt, tendsto_nhds_bot_iff_real, bot_add]\n  refine fun r ‚Ü¶ ((gt_mem_nhds (bot_lt_coe 0)).prod_nhds\n    (gt_mem_nhds <| bot_lt_coe r)).mono fun _ h ‚Ü¶ ?_\n  simpa only [coe_zero, zero_add] using add_lt_add h.1 h.2\n\n"}
{"name":"EReal.continuousAt_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"p : Prod EReal EReal\nh : Or (Ne p.1 Top.top) (Ne p.2 Bot.bot)\nh' : Or (Ne p.1 Bot.bot) (Ne p.2 Top.top)\n‚ä¢ ContinuousAt (fun p => HAdd.hAdd p.1 p.2) p","decl":"/-- The addition on `EReal` is continuous except where it doesn't make sense (i.e., at `(‚ä•, ‚ä§)`\nand at `(‚ä§, ‚ä•)`). -/\ntheorem continuousAt_add {p : EReal √ó EReal} (h : p.1 ‚â† ‚ä§ ‚à® p.2 ‚â† ‚ä•) (h' : p.1 ‚â† ‚ä• ‚à® p.2 ‚â† ‚ä§) :\n    ContinuousAt (fun p : EReal √ó EReal => p.1 + p.2) p := by\n  rcases p with ‚ü®x, y‚ü©\n  induction x <;> induction y\n  ¬∑ exact continuousAt_add_bot_bot\n  ¬∑ exact continuousAt_add_bot_coe _\n  ¬∑ simp at h'\n  ¬∑ exact continuousAt_add_coe_bot _\n  ¬∑ exact continuousAt_add_coe_coe _ _\n  ¬∑ exact continuousAt_add_coe_top _\n  ¬∑ simp at h\n  ¬∑ exact continuousAt_add_top_coe _\n  ¬∑ exact continuousAt_add_top_top\n\n"}
{"name":"EReal.continuousAt_mul","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"p : Prod EReal EReal\nh‚ÇÅ : Or (Ne p.1 0) (Ne p.2 Bot.bot)\nh‚ÇÇ : Or (Ne p.1 0) (Ne p.2 Top.top)\nh‚ÇÉ : Or (Ne p.1 Bot.bot) (Ne p.2 0)\nh‚ÇÑ : Or (Ne p.1 Top.top) (Ne p.2 0)\n‚ä¢ ContinuousAt (fun p => HMul.hMul p.1 p.2) p","decl":"/-- The multiplication on `EReal` is continuous except at indeterminacies\n(i.e. whenever one value is zero and the other infinite). -/\ntheorem continuousAt_mul {p : EReal √ó EReal} (h‚ÇÅ : p.1 ‚â† 0 ‚à® p.2 ‚â† ‚ä•)\n    (h‚ÇÇ : p.1 ‚â† 0 ‚à® p.2 ‚â† ‚ä§) (h‚ÇÉ : p.1 ‚â† ‚ä• ‚à® p.2 ‚â† 0) (h‚ÇÑ : p.1 ‚â† ‚ä§ ‚à® p.2 ‚â† 0) :\n    ContinuousAt (fun p : EReal √ó EReal ‚Ü¶ p.1 * p.2) p := by\n  rcases p with ‚ü®x, y‚ü©\n  induction x <;> induction y\n  ¬∑ exact continuousAt_mul_symm3 continuousAt_mul_top_top\n  ¬∑ simp only [ne_eq, not_true_eq_false, EReal.coe_eq_zero, false_or] at h‚ÇÉ\n    exact continuousAt_mul_symm1 (continuousAt_mul_top_ne_zero h‚ÇÉ)\n  ¬∑ exact EReal.neg_top ‚ñ∏ continuousAt_mul_symm1 continuousAt_mul_top_top\n  ¬∑ simp only [ne_eq, EReal.coe_eq_zero, not_true_eq_false, or_false] at h‚ÇÅ\n    exact continuousAt_mul_symm2 (continuousAt_mul_swap (continuousAt_mul_top_ne_zero h‚ÇÅ))\n  ¬∑ exact continuousAt_mul_coe_coe _ _\n  ¬∑ simp only [ne_eq, EReal.coe_eq_zero, not_true_eq_false, or_false] at h‚ÇÇ\n    exact continuousAt_mul_swap (continuousAt_mul_top_ne_zero h‚ÇÇ)\n  ¬∑ exact continuousAt_mul_symm2 continuousAt_mul_top_top\n  ¬∑ simp only [ne_eq, not_true_eq_false, EReal.coe_eq_zero, false_or] at h‚ÇÑ\n    exact continuousAt_mul_top_ne_zero h‚ÇÑ\n  ¬∑ exact continuousAt_mul_top_top\n\n"}
{"name":"EReal.lowerSemicontinuous_add","module":"Mathlib.Topology.Instances.EReal.Lemmas","initialProofState":"‚ä¢ LowerSemicontinuous fun p => HAdd.hAdd p.1 p.2","decl":"lemma lowerSemicontinuous_add : LowerSemicontinuous fun p : EReal √ó EReal ‚Ü¶ p.1 + p.2 := by\n  intro x y\n  by_cases hx‚ÇÅ : x.1 = ‚ä•\n  ¬∑ simp [hx‚ÇÅ]\n  by_cases hx‚ÇÇ : x.2 = ‚ä•\n  ¬∑ simp [hx‚ÇÇ]\n  ¬∑ exact continuousAt_add (.inr hx‚ÇÇ) (.inl hx‚ÇÅ) |>.lowerSemicontinuousAt _\n\n"}
