{"name":"InnerProductSpaceable.parallelogram_identity","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"E : Type u_2\ninst‚úù : NormedAddCommGroup E\nself : InnerProductSpaceable E\nx y : E\n‚ä¢ Eq (HAdd.hAdd (HMul.hMul (Norm.norm (HAdd.hAdd x y)) (Norm.norm (HAdd.hAdd x y))) (HMul.hMul (Norm.norm (HSub.hSub x y)) (Norm.norm (HSub.hSub x y)))) (HMul.hMul 2 (HAdd.hAdd (HMul.hMul (Norm.norm x) (Norm.norm x)) (HMul.hMul (Norm.norm y) (Norm.norm y))))","decl":"/-- Predicate for the parallelogram identity to hold in a normed group. This is a scalar-less\nversion of `InnerProductSpace`. If you have an `InnerProductSpaceable` assumption, you can\nlocally upgrade that to `InnerProductSpace ùïú E` using `casesI nonempty_innerProductSpace ùïú E`.\n-/\nclass InnerProductSpaceable : Prop where\n  parallelogram_identity :\n    ‚àÄ x y : E, ‚Äñx + y‚Äñ * ‚Äñx + y‚Äñ + ‚Äñx - y‚Äñ * ‚Äñx - y‚Äñ = 2 * (‚Äñx‚Äñ * ‚Äñx‚Äñ + ‚Äñy‚Äñ * ‚Äñy‚Äñ)\n\n"}
{"name":"InnerProductSpace.toInnerProductSpaceable","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace ùïú E\n‚ä¢ InnerProductSpaceable E","decl":"theorem InnerProductSpace.toInnerProductSpaceable [InnerProductSpace ùïú E] :\n    InnerProductSpaceable E :=\n  ‚ü®parallelogram_law_with_norm ùïú‚ü©\n\n-- See note [lower instance priority]\n"}
{"name":"InnerProductSpace.toInnerProductSpaceable_ofReal","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"E : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : InnerProductSpace Real E\n‚ä¢ InnerProductSpaceable E","decl":"instance (priority := 100) InnerProductSpace.toInnerProductSpaceable_ofReal\n    [InnerProductSpace ‚Ñù E] : InnerProductSpaceable E :=\n  ‚ü®parallelogram_law_with_norm ‚Ñù‚ü©\n\n"}
{"name":"Continuous.inner_","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nf g : Real ‚Üí E\nhf : Continuous f\nhg : Continuous g\n‚ä¢ Continuous fun x => inner_ ùïú (f x) (g x)","decl":"theorem _root_.Continuous.inner_ {f g : ‚Ñù ‚Üí E} (hf : Continuous f) (hg : Continuous g) :\n    Continuous fun x => inner_ ùïú (f x) (g x) := by\n  unfold _root_.inner_\n  fun_prop\n\n"}
{"name":"InnerProductSpaceable.inner_.norm_sq","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nx : E\n‚ä¢ Eq (HPow.hPow (Norm.norm x) 2) (RCLike.re (inner_ ùïú x x))","decl":"theorem inner_.norm_sq (x : E) : ‚Äñx‚Äñ ^ 2 = re (inner_ ùïú x x) := by\n  simp only [inner_, normSq_apply, ofNat_re, ofNat_im, map_sub, map_add, map_zero, map_mul,\n    ofReal_re, ofReal_im, mul_re, inv_re, mul_im, I_re, inv_im]\n  have h‚ÇÅ : ‚Äñx - x‚Äñ = 0 := by simp\n  have h‚ÇÇ : ‚Äñx + x‚Äñ = 2 ‚Ä¢ ‚Äñx‚Äñ := by convert norm_nsmul ùïú 2 x using 2; module\n  rw [h‚ÇÅ, h‚ÇÇ]\n  ring\n\n"}
{"name":"InnerProductSpaceable.inner_.conj_symm","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≤ : RCLike ùïú\nE : Type u_2\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace ùïú E\nx y : E\n‚ä¢ Eq ((starRingEnd ùïú) (inner_ ùïú y x)) (inner_ ùïú x y)","decl":"theorem inner_.conj_symm (x y : E) : conj (inner_ ùïú y x) = inner_ ùïú x y := by\n  simp only [inner_, map_sub, map_add, map_mul, map_inv‚ÇÄ, map_ofNat, conj_ofReal, conj_I]\n  rw [add_comm y x, norm_sub_rev]\n  by_cases hI : (I : ùïú) = 0\n  ¬∑ simp only [hI, neg_zero, zero_mul]\n  have hI' := I_mul_I_of_nonzero hI\n  have I_smul (v : E) : ‚Äñ(I : ùïú) ‚Ä¢ v‚Äñ = ‚Äñv‚Äñ := by rw [norm_smul, norm_I_of_ne_zero hI, one_mul]\n  have h‚ÇÅ : ‚Äñ(I : ùïú) ‚Ä¢ y - x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x + y‚Äñ := by\n    convert I_smul ((I : ùïú) ‚Ä¢ x + y) using 2\n    linear_combination (norm := module) -hI' ‚Ä¢ x\n  have h‚ÇÇ : ‚Äñ(I : ùïú) ‚Ä¢ y + x‚Äñ = ‚Äñ(I : ùïú) ‚Ä¢ x - y‚Äñ := by\n    convert (I_smul ((I : ùïú) ‚Ä¢ y + x)).symm using 2\n    linear_combination (norm := module) -hI' ‚Ä¢ y\n  rw [h‚ÇÅ, h‚ÇÇ]\n  ring\n\n"}
{"name":"InnerProductSpaceable.add_left","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≥ : RCLike ùïú\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : InnerProductSpaceable E\nx y z : E\n‚ä¢ Eq (inner_ ùïú (HAdd.hAdd x y) z) (HAdd.hAdd (inner_ ùïú x z) (inner_ ùïú y z))","decl":"theorem add_left (x y z : E) : inner_ ùïú (x + y) z = inner_ ùïú x z + inner_ ùïú y z := by\n  have H_re := congr(- $(add_left_aux1 x y z) + $(add_left_aux2 x y z)\n    + $(add_left_aux3 y z) - $(add_left_aux4 y z))\n  have H_im := congr(- $(add_left_aux5 ùïú x y z) + $(add_left_aux6 ùïú x y z)\n      + $(add_left_aux7 ùïú y z) - $(add_left_aux8 ùïú y z))\n  have H := congr(ùìö $H_re + I * ùìö $H_im)\n  simp only [inner_, map_add, map_sub, map_neg, map_mul, map_ofNat] at H ‚ä¢\n  linear_combination H / 8\n\n"}
{"name":"InnerProductSpaceable.innerProp","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≥ : RCLike ùïú\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : InnerProductSpaceable E\nr : ùïú\n‚ä¢ InnerProductSpaceable.innerProp' E r","decl":"theorem innerProp (r : ùïú) : innerProp' E r := by\n  intro x y\n  rw [‚Üê re_add_im r, add_smul, add_left, real_prop _ x, ‚Üê smul_smul, real_prop _ _ y, I_prop,\n    map_add, map_mul, conj_ofReal, conj_ofReal, conj_I]\n  ring\n\n"}
{"name":"nonempty_innerProductSpace","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"ùïú : Type u_1\ninst‚úù¬≥ : RCLike ùïú\nE : Type u_2\ninst‚úù¬≤ : NormedAddCommGroup E\ninst‚úù¬π : NormedSpace ùïú E\ninst‚úù : InnerProductSpaceable E\n‚ä¢ Nonempty (InnerProductSpace ùïú E)","decl":"/-- **Fr√©chet‚Äìvon Neumann‚ÄìJordan Theorem**. A normed space `E` whose norm satisfies the\nparallelogram identity can be given a compatible inner product. Do\n`casesI nonempty_innerProductSpace ùïú E` to locally upgrade `InnerProductSpaceable E` to\n`InnerProductSpace ùïú E`. -/\ntheorem nonempty_innerProductSpace : Nonempty (InnerProductSpace ùïú E) :=\n  ‚ü®{  inner := inner_ ùïú\n      norm_sq_eq_inner := inner_.norm_sq\n      conj_symm := inner_.conj_symm\n      add_left := add_left\n      smul_left := fun _ _ _ => innerProp _ _ _ }‚ü©\n\n"}
{"name":"InnerProductSpaceable.to_uniformConvexSpace","module":"Mathlib.Analysis.InnerProductSpace.OfNorm","initialProofState":"E : Type u_2\ninst‚úù : NormedAddCommGroup E\n‚ä¢ UniformConvexSpace E","decl":"instance (priority := 100) InnerProductSpaceable.to_uniformConvexSpace : UniformConvexSpace E := by\n  cases nonempty_innerProductSpace ‚Ñù E; infer_instance\n"}
