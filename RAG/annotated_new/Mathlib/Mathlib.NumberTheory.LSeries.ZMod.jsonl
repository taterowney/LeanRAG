{"name":"ZMod.LSeriesSummable_of_one_lt_re","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ LSeriesSummable (fun x => Œ¶ ‚Üëx) s","decl":"/-- If `Œ¶` is a periodic function, then the L-series of `Œ¶` converges for `1 < re s`. -/\nlemma LSeriesSummable_of_one_lt_re (Œ¶ : ZMod N ‚Üí ‚ÑÇ) {s : ‚ÑÇ} (hs : 1 < re s) :\n    LSeriesSummable (Œ¶ ¬∑) s := by\n  let c := max' _ <| univ_nonempty.image (Complex.abs ‚àò Œ¶)\n  refine LSeriesSummable_of_bounded_of_one_lt_re (fun n _ ‚Ü¶ le_max' _ _ ?_) (m := c) hs\n  exact mem_image_of_mem _ (mem_univ _)\n\n"}
{"name":"ZMod.LFunction_modOne_eq","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"Œ¶ : ZMod 1 ‚Üí Complex\ns : Complex\n‚ä¢ Eq (ZMod.LFunction Œ¶ s) (HMul.hMul (Œ¶ 0) (riemannZeta s))","decl":"/-- The L-function of a function on `ZMod 1` is a scalar multiple of the Riemann zeta function. -/\nlemma LFunction_modOne_eq (Œ¶ : ZMod 1 ‚Üí ‚ÑÇ) (s : ‚ÑÇ) :\n    LFunction Œ¶ s = Œ¶ 0 * riemannZeta s := by\n  simp only [LFunction, Nat.cast_one, one_cpow, ‚Üê singleton_eq_univ (0 : ZMod 1), sum_singleton,\n    map_zero, hurwitzZeta_zero, one_mul]\n\n"}
{"name":"ZMod.LFunction_eq_LSeries","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\nhs : LT.lt 1 s.re\n‚ä¢ Eq (ZMod.LFunction Œ¶ s) (LSeries (fun x => Œ¶ ‚Üëx) s)","decl":"/-- For `1 < re s` the congruence L-function agrees with the sum of the Dirichlet series. -/\nlemma LFunction_eq_LSeries (Œ¶ : ZMod N ‚Üí ‚ÑÇ) {s : ‚ÑÇ} (hs : 1 < re s) :\n    LFunction Œ¶ s = LSeries (Œ¶ ¬∑) s := by\n  rw [LFunction, LSeries, mul_sum, Nat.sumByResidueClasses (LSeriesSummable_of_one_lt_re Œ¶ hs) N]\n  congr 1 with j\n  have : (j.val / N : ‚Ñù) ‚àà Set.Icc 0 1 := mem_Icc.mpr ‚ü®by positivity,\n    (div_le_one (Nat.cast_pos.mpr <| NeZero.pos _)).mpr <| Nat.cast_le.mpr (val_lt j).le‚ü©\n  rw [toAddCircle_apply, ‚Üê (hasSum_hurwitzZeta_of_one_lt_re this hs).tsum_eq, ‚Üê mul_assoc,\n    ‚Üê tsum_mul_left]\n  congr 1 with m\n  -- The following manipulation is slightly delicate because `(x * y) ^ s = x ^ s * y ^ s` is\n  -- false for general complex `x`, `y`, but it is true if `x` and `y` are non-negative reals, so\n  -- we have to carefully juggle coercions `‚Ñï ‚Üí ‚Ñù ‚Üí ‚ÑÇ`.\n  calc N ^ (-s) * Œ¶ j * (1 / (m + (j.val / N : ‚Ñù)) ^ s)\n  _ = Œ¶ j * (N ^ (-s) * (1 / (m + (j.val / N : ‚Ñù)) ^ s)) := by\n    rw [‚Üê mul_assoc, mul_comm _ (Œ¶ _)]\n  _ = Œ¶ j * (1 / (N : ‚Ñù) ^ s * (1 / ((j.val + N * m) / N : ‚Ñù) ^ s)) := by\n    simp only [cpow_neg, ‚Üê one_div, ofReal_div, ofReal_natCast, add_comm, add_div, ofReal_add,\n      ofReal_mul, mul_div_cancel_left‚ÇÄ (m : ‚ÑÇ) (Nat.cast_ne_zero.mpr (NeZero.ne N))]\n  _ = Œ¶ j / ((N : ‚Ñù) * ((j.val + N * m) / N : ‚Ñù)) ^ s := by -- this is the delicate step!\n    rw [one_div_mul_one_div, mul_one_div, mul_cpow_ofReal_nonneg] <;> positivity\n  _ = Œ¶ j / (N * (j.val + N * m) / N) ^ s := by\n    simp only [ofReal_natCast, ofReal_div, ofReal_add, ofReal_mul, mul_div_assoc]\n  _ = Œ¶ j / (j.val + N * m) ^ s := by\n    rw [mul_div_cancel_left‚ÇÄ _ (Nat.cast_ne_zero.mpr (NeZero.ne N))]\n  _ = Œ¶ ‚Üë(j.val + N * m) / (‚Üë(j.val + N * m)) ^ s := by\n    simp only [Nat.cast_add, Nat.cast_mul, natCast_zmod_val, natCast_self, zero_mul, add_zero]\n  _ = LSeries.term (Œ¶ ¬∑) s (j.val + N * m) := by\n    rw [LSeries.term_of_ne_zero' (ne_zero_of_one_lt_re hs)]\n\n"}
{"name":"ZMod.differentiableAt_LFunction","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\nhs : Or (Ne s 1) (Eq (Finset.univ.sum fun j => Œ¶ j) 0)\n‚ä¢ DifferentiableAt Complex (ZMod.LFunction Œ¶) s","decl":"lemma differentiableAt_LFunction (Œ¶ : ZMod N ‚Üí ‚ÑÇ) (s : ‚ÑÇ) (hs : s ‚â† 1 ‚à® ‚àë j, Œ¶ j = 0) :\n    DifferentiableAt ‚ÑÇ (LFunction Œ¶) s := by\n  refine .mul (by fun_prop) ?_\n  rcases ne_or_eq s 1 with hs' | rfl\n  ¬∑ exact .sum fun j _ ‚Ü¶ (differentiableAt_hurwitzZeta _ hs').const_mul _\n  ¬∑ have := DifferentiableAt.sum (u := univ) fun j _ ‚Ü¶\n      (differentiableAt_hurwitzZeta_sub_one_div (toAddCircle j)).const_mul (Œ¶ j)\n    simpa only [mul_sub, sum_sub_distrib, ‚Üê sum_mul, hs.neg_resolve_left rfl, zero_mul, sub_zero]\n\n"}
{"name":"ZMod.differentiable_LFunction_of_sum_zero","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Eq (Finset.univ.sum fun j => Œ¶ j) 0\n‚ä¢ Differentiable Complex (ZMod.LFunction Œ¶)","decl":"lemma differentiable_LFunction_of_sum_zero {Œ¶ : ZMod N ‚Üí ‚ÑÇ} (hŒ¶ : ‚àë j, Œ¶ j = 0) :\n    Differentiable ‚ÑÇ (LFunction Œ¶) :=\n  fun s ‚Ü¶ differentiableAt_LFunction Œ¶ s (Or.inr hŒ¶)\n\n"}
{"name":"ZMod.LFunction_residue_one","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\n‚ä¢ Filter.Tendsto (fun s => HMul.hMul (HSub.hSub s 1) (ZMod.LFunction Œ¶ s)) (nhdsWithin 1 (HasCompl.compl (Singleton.singleton 1))) (nhds (Finset.univ.sum fun j => HDiv.hDiv (Œ¶ j) ‚ÜëN))","decl":"/-- The L-function of `Œ¶` has a residue at `s = 1` equal to the average value of `Œ¶`. -/\nlemma LFunction_residue_one (Œ¶ : ZMod N ‚Üí ‚ÑÇ) :\n    Tendsto (fun s ‚Ü¶ (s - 1) * LFunction Œ¶ s) (ùìù[‚â†] 1) (ùìù (‚àë j, Œ¶ j / N)) := by\n  simp only [sum_div, LFunction, mul_sum]\n  refine tendsto_finset_sum _ fun j _ ‚Ü¶ ?_\n  rw [(by ring : Œ¶ j / N = Œ¶ j * (1 / N * 1)), one_div, ‚Üê cpow_neg_one]\n  simp only [show ‚àÄ a b c d : ‚ÑÇ, a * (b * (c * d)) = c * (b * (a * d)) by intros; ring]\n  refine tendsto_const_nhds.mul (.mul ?_ <| hurwitzZeta_residue_one _)\n  exact ((continuous_neg.const_cpow (Or.inl <| NeZero.ne _)).tendsto _).mono_left\n    nhdsWithin_le_nhds\n\n"}
{"name":"ZMod.LFunction_stdAddChar_eq_expZeta","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nj : ZMod N\ns : Complex\nhjs : Or (Ne j 0) (Ne s 1)\n‚ä¢ Eq (ZMod.LFunction (fun k => ZMod.stdAddChar (HMul.hMul j k)) s) (HurwitzZeta.expZeta (ZMod.toAddCircle j) s)","decl":"/--\nThe `LFunction` of the function `x ‚Ü¶ e (j * x)`, where `e : ZMod N ‚Üí ‚ÑÇ` is the standard additive\ncharacter, is `expZeta (j / N)`.\n\nNote this is not at all obvious from the definitions, and we prove it by analytic continuation\nfrom the convergence range.\n-/\nlemma LFunction_stdAddChar_eq_expZeta (j : ZMod N) (s : ‚ÑÇ) (hjs : j ‚â† 0 ‚à® s ‚â† 1) :\n    LFunction (fun k ‚Ü¶ ùïñ (j * k)) s = expZeta (ZMod.toAddCircle j) s := by\n  let U := if j = 0 then {z : ‚ÑÇ | z ‚â† 1} else univ -- region of analyticity of both functions\n  let V := {z : ‚ÑÇ | 1 < re z} -- convergence region\n  have hUo : IsOpen U := by\n    by_cases h : j = 0\n    ¬∑ simpa only [h, ‚ÜìreduceIte, U] using isOpen_compl_singleton\n    ¬∑ simp only [h, ‚ÜìreduceIte, isOpen_univ, U]\n  let f := LFunction (fun k ‚Ü¶ stdAddChar (j * k))\n  let g := expZeta (toAddCircle j)\n  have hU {u} : u ‚àà U ‚Üî u ‚â† 1 ‚à® j ‚â† 0 := by simp only [mem_ite_univ_right, U]; tauto\n  -- hypotheses for uniqueness of analytic continuation\n  have hf : AnalyticOnNhd ‚ÑÇ f U := by\n    refine DifferentiableOn.analyticOnNhd (fun u hu ‚Ü¶ ?_) hUo\n    refine (differentiableAt_LFunction _ _ ((hU.mp hu).imp_right fun h ‚Ü¶ ?_)).differentiableWithinAt\n    simp only [mul_comm j, AddChar.sum_mulShift _ (isPrimitive_stdAddChar _), h,\n      ‚ÜìreduceIte, CharP.cast_eq_zero, or_true]\n  have hg : AnalyticOnNhd ‚ÑÇ g U := by\n    refine DifferentiableOn.analyticOnNhd (fun u hu ‚Ü¶ ?_) hUo\n    refine (differentiableAt_expZeta _ _ ((hU.mp hu).imp_right fun h ‚Ü¶ ?_)).differentiableWithinAt\n    rwa [ne_eq, toAddCircle_eq_zero]\n  have hUc : IsPreconnected U := by\n    by_cases h : j = 0\n    ¬∑ simpa only [h, ‚ÜìreduceIte, U] using\n        (isConnected_compl_singleton_of_one_lt_rank (by simp) _).isPreconnected\n    ¬∑ simpa only [h, ‚ÜìreduceIte, U] using isPreconnected_univ\n  have hV : V ‚àà ùìù 2 := (continuous_re.isOpen_preimage _ isOpen_Ioi).mem_nhds (by simp)\n  have hUmem : 2 ‚àà U := by simp [U]\n  have hUmem' : s ‚àà U := hU.mpr hjs.symm\n  -- apply uniqueness result\n  refine hf.eqOn_of_preconnected_of_eventuallyEq hg hUc hUmem ?_ hUmem'\n  -- now remains to prove equality on `1 < re s`\n  filter_upwards [hV] with z using LFunction_stdAddChar_eq_expZeta_of_one_lt_re _\n\n"}
{"name":"ZMod.LFunction_dft","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\nhs : Or (Eq (Œ¶ 0) 0) (Ne s 1)\n‚ä¢ Eq (ZMod.LFunction (ZMod.dft Œ¶) s) (Finset.univ.sum fun j => HMul.hMul (Œ¶ j) (HurwitzZeta.expZeta (ZMod.toAddCircle (Neg.neg j)) s))","decl":"/-- Explicit formula for the L-function of `ùìï Œ¶`, where `ùìï` is the discrete Fourier transform. -/\nlemma LFunction_dft (Œ¶ : ZMod N ‚Üí ‚ÑÇ) {s : ‚ÑÇ} (hs : Œ¶ 0 = 0 ‚à® s ‚â† 1) :\n    LFunction (ùìï Œ¶) s = ‚àë j : ZMod N, Œ¶ j * expZeta (toAddCircle (-j)) s := by\n  have (j : ZMod N) : Œ¶ j * LFunction (fun k ‚Ü¶ ùïñ (-j * k)) s =\n      Œ¶ j * expZeta (toAddCircle (-j)) s := by\n    by_cases h : -j ‚â† 0 ‚à® s ‚â† 1\n    ¬∑ rw [LFunction_stdAddChar_eq_expZeta _ _ h]\n    ¬∑ simp only [neg_ne_zero, not_or, not_not] at h\n      rw [h.1, show Œ¶ 0 = 0 by tauto, zero_mul, zero_mul]\n  simp only [LFunction, ‚Üê this, mul_sum]\n  rw [dft_def, sum_comm]\n  simp only [sum_mul, mul_sum, Circle.smul_def, smul_eq_mul, stdAddChar_apply, ‚Üê mul_assoc]\n  congr 1 with j\n  congr 1 with k\n  rw [mul_assoc (Œ¶ _), mul_comm (Œ¶ _), neg_mul]\n\n"}
{"name":"ZMod.LFunction_one_sub","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\nhs : ‚àÄ (n : Nat), Ne s (Neg.neg ‚Üën)\nhs' : Or (Eq (Œ¶ 0) 0) (Ne s 1)\n‚ä¢ Eq (ZMod.LFunction Œ¶ (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HMul.hMul (HPow.hPow (‚ÜëN) (HSub.hSub s 1)) (HPow.hPow (HMul.hMul 2 ‚ÜëReal.pi) (Neg.neg s))) (Complex.Gamma s)) (HAdd.hAdd (HMul.hMul (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (‚ÜëReal.pi) Complex.I) s) 2)) (ZMod.LFunction (ZMod.dft Œ¶) s)) (HMul.hMul (Complex.exp (HDiv.hDiv (HMul.hMul (HMul.hMul (Neg.neg ‚ÜëReal.pi) Complex.I) s) 2)) (ZMod.LFunction (ZMod.dft fun x => Œ¶ (Neg.neg x)) s))))","decl":"/-- Functional equation for `ZMod` L-functions, in terms of discrete Fourier transform. -/\ntheorem LFunction_one_sub (Œ¶ : ZMod N ‚Üí ‚ÑÇ) {s : ‚ÑÇ}\n    (hs : ‚àÄ (n : ‚Ñï), s ‚â† -n) (hs' : Œ¶ 0 = 0 ‚à® s ‚â† 1) :\n    LFunction Œ¶ (1 - s) = N ^ (s - 1) * (2 * œÄ) ^ (-s) * Gamma s *\n      (cexp (œÄ * I * s / 2) * LFunction (ùìï Œ¶) s\n       + cexp (-œÄ * I * s / 2) * LFunction (ùìï fun x ‚Ü¶ Œ¶ (-x)) s) := by\n  rw [LFunction]\n  have (j : ZMod N) :  Œ¶ j * hurwitzZeta (toAddCircle j) (1 - s) = Œ¶ j *\n      ((2 * œÄ) ^ (-s) * Gamma s * (cexp (-œÄ * I * s / 2) *\n      expZeta (toAddCircle j) s + cexp (œÄ * I * s / 2) * expZeta (-toAddCircle j) s)) := by\n    rcases eq_or_ne j 0 with rfl | hj\n    ¬∑ rcases hs' with hŒ¶ | hs'\n      ¬∑ simp only [hŒ¶, zero_mul]\n      ¬∑ rw [hurwitzZeta_one_sub _ hs (Or.inr hs')]\n    ¬∑ rw [hurwitzZeta_one_sub _ hs (Or.inl <| toAddCircle_eq_zero.not.mpr hj)]\n  simp only [this, mul_assoc _ _ (Gamma s)]\n  -- get rid of Gamma terms and power of N\n  generalize (2 * œÄ) ^ (-s) * Gamma s = C\n  simp_rw [‚Üê mul_assoc, mul_comm _ C, mul_assoc, ‚Üê mul_sum, ‚Üê mul_assoc, mul_comm _ C, mul_assoc,\n    neg_sub]\n  congr 2\n  -- now gather sum terms\n  rw [LFunction_dft _ hs', LFunction_dft _ (hs'.imp_left <| by simp only [neg_zero, imp_self])]\n  conv_rhs => enter [2, 2]; rw [‚Üê (Equiv.neg _).sum_comp _ _ (by simp), Equiv.neg_apply]\n  simp_rw [neg_neg, mul_sum, ‚Üê sum_add_distrib, ‚Üê mul_assoc, mul_comm _ (Œ¶ _), mul_assoc,\n    ‚Üê mul_add, map_neg, add_comm]\n\n"}
{"name":"ZMod.LFunction_def_even","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Even Œ¶\ns : Complex\n‚ä¢ Eq (ZMod.LFunction Œ¶ s) (HMul.hMul (HPow.hPow (‚ÜëN) (Neg.neg s)) (Finset.univ.sum fun j => HMul.hMul (Œ¶ j) (HurwitzZeta.hurwitzZetaEven (ZMod.toAddCircle j) s)))","decl":"lemma LFunction_def_even (hŒ¶ : Œ¶.Even) (s : ‚ÑÇ) :\n    LFunction Œ¶ s = N ^ (-s) * ‚àë j : ZMod N, Œ¶ j * hurwitzZetaEven (toAddCircle j) s := by\n  simp only [LFunction, hurwitzZeta, mul_add (Œ¶ _), sum_add_distrib]\n  congr 1\n  simp only [add_right_eq_self, ‚Üê neg_eq_self ‚ÑÇ, ‚Üê sum_neg_distrib]\n  refine Fintype.sum_equiv (.neg _) _ _ fun i ‚Ü¶ ?_\n  simp only [Equiv.neg_apply, hŒ¶ i, map_neg, hurwitzZetaOdd_neg, mul_neg]\n\n"}
{"name":"ZMod.LFunction_def_odd","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Odd Œ¶\ns : Complex\n‚ä¢ Eq (ZMod.LFunction Œ¶ s) (HMul.hMul (HPow.hPow (‚ÜëN) (Neg.neg s)) (Finset.univ.sum fun j => HMul.hMul (Œ¶ j) (HurwitzZeta.hurwitzZetaOdd (ZMod.toAddCircle j) s)))","decl":"lemma LFunction_def_odd (hŒ¶ : Œ¶.Odd) (s : ‚ÑÇ) :\n    LFunction Œ¶ s = N ^ (-s) * ‚àë j : ZMod N, Œ¶ j * hurwitzZetaOdd (toAddCircle j) s := by\n  simp only [LFunction, hurwitzZeta, mul_add (Œ¶ _), sum_add_distrib]\n  congr 1\n  simp only [add_left_eq_self, ‚Üê neg_eq_self ‚ÑÇ, ‚Üê sum_neg_distrib]\n  refine Fintype.sum_equiv (.neg _) _ _ fun i ‚Ü¶ ?_\n  simp only [Equiv.neg_apply, hŒ¶ i, map_neg, hurwitzZetaEven_neg, neg_mul]\n\n"}
{"name":"ZMod.LFunction_apply_zero_of_even","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Even Œ¶\n‚ä¢ Eq (ZMod.LFunction Œ¶ 0) (HDiv.hDiv (Neg.neg (Œ¶ 0)) 2)","decl":"/-- Explicit formula for `LFunction Œ¶ 0` when `Œ¶` is even. -/\n@[simp] lemma LFunction_apply_zero_of_even (hŒ¶ : Œ¶.Even) :\n    LFunction Œ¶ 0 = -Œ¶ 0 / 2 := by\n  simp only [LFunction_def_even hŒ¶, neg_zero, cpow_zero, hurwitzZetaEven_apply_zero,\n    toAddCircle_eq_zero, mul_ite, mul_div, mul_neg_one, mul_zero, sum_ite_eq', Finset.mem_univ,\n    ‚ÜìreduceIte, one_mul]\n\n"}
{"name":"ZMod.LFunction_neg_two_mul_nat_add_one","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Even Œ¶\nn : Nat\n‚ä¢ Eq (ZMod.LFunction Œ¶ (Neg.neg (HMul.hMul 2 (HAdd.hAdd (‚Üën) 1)))) 0","decl":"/-- The L-function of an even function vanishes at negative even integers. -/\n@[simp] lemma LFunction_neg_two_mul_nat_add_one (hŒ¶ : Œ¶.Even) (n : ‚Ñï) :\n    LFunction Œ¶ (-(2 * (n + 1))) = 0 := by\n  simp only [LFunction_def_even hŒ¶, hurwitzZetaEven_neg_two_mul_nat_add_one, mul_zero,\n    sum_const_zero, ‚Üê neg_mul]\n\n"}
{"name":"ZMod.LFunction_neg_two_mul_nat_sub_one","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Odd Œ¶\nn : Nat\n‚ä¢ Eq (ZMod.LFunction Œ¶ (HSub.hSub (Neg.neg (HMul.hMul 2 ‚Üën)) 1)) 0","decl":"/-- The L-function of an odd function vanishes at negative odd integers. -/\n@[simp] lemma LFunction_neg_two_mul_nat_sub_one (hŒ¶ : Œ¶.Odd) (n : ‚Ñï) :\n    LFunction Œ¶ (-(2 * n) - 1) = 0 := by\n  simp only [LFunction_def_odd hŒ¶, hurwitzZetaOdd_neg_two_mul_nat_sub_one, mul_zero, ‚Üê neg_mul,\n    sum_const_zero]\n\n"}
{"name":"ZMod.completedLFunction_zero","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction 0 s) 0","decl":"@[simp] lemma completedLFunction_zero (s : ‚ÑÇ) : completedLFunction (0 : ZMod N ‚Üí ‚ÑÇ) s = 0 := by\n  simp only [completedLFunction, Pi.zero_apply, zero_mul, sum_const_zero, mul_zero, zero_add]\n\n"}
{"name":"ZMod.completedLFunction_const_mul","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\na : Complex\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction (fun j => HMul.hMul a (Œ¶ j)) s) (HMul.hMul a (ZMod.completedLFunction Œ¶ s))","decl":"lemma completedLFunction_const_mul (a : ‚ÑÇ) (Œ¶ : ZMod N ‚Üí ‚ÑÇ) (s : ‚ÑÇ) :\n    completedLFunction (fun j ‚Ü¶ a * Œ¶ j) s = a * completedLFunction Œ¶ s := by\n  simp only [completedLFunction, mul_add, mul_sum]\n  congr with i <;> ring\n\n"}
{"name":"ZMod.completedLFunction_def_even","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Even Œ¶\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction Œ¶ s) (HMul.hMul (HPow.hPow (‚ÜëN) (Neg.neg s)) (Finset.univ.sum fun j => HMul.hMul (Œ¶ j) (HurwitzZeta.completedHurwitzZetaEven (ZMod.toAddCircle j) s)))","decl":"lemma completedLFunction_def_even (hŒ¶ : Œ¶.Even) (s : ‚ÑÇ) :\n    completedLFunction Œ¶ s = N ^ (-s) * ‚àë j, Œ¶ j * completedHurwitzZetaEven (toAddCircle j) s := by\n  suffices ‚àë j, Œ¶ j * completedHurwitzZetaOdd (toAddCircle j) s = 0 by\n    rw [completedLFunction, this, mul_zero, add_zero]\n  refine (hŒ¶.mul_odd fun j ‚Ü¶ ?_).sum_eq_zero\n  rw [map_neg, completedHurwitzZetaOdd_neg]\n\n"}
{"name":"ZMod.completedLFunction_def_odd","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Odd Œ¶\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction Œ¶ s) (HMul.hMul (HPow.hPow (‚ÜëN) (Neg.neg s)) (Finset.univ.sum fun j => HMul.hMul (Œ¶ j) (HurwitzZeta.completedHurwitzZetaOdd (ZMod.toAddCircle j) s)))","decl":"lemma completedLFunction_def_odd (hŒ¶ : Œ¶.Odd) (s : ‚ÑÇ) :\n    completedLFunction Œ¶ s = N ^ (-s) * ‚àë j, Œ¶ j * completedHurwitzZetaOdd (toAddCircle j) s := by\n  suffices ‚àë j, Œ¶ j * completedHurwitzZetaEven (toAddCircle j) s = 0 by\n    rw [completedLFunction, this, mul_zero, zero_add]\n  refine (hŒ¶.mul_even fun j ‚Ü¶ ?_).sum_eq_zero\n  rw [map_neg, completedHurwitzZetaEven_neg]\n\n"}
{"name":"ZMod.completedLFunction_modOne_eq","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"Œ¶ : ZMod 1 ‚Üí Complex\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction Œ¶ s) (HMul.hMul (Œ¶ 1) (completedRiemannZeta s))","decl":"/--\nThe completed L-function of a function `ZMod 1 ‚Üí ‚ÑÇ` is a scalar multiple of the completed Riemann\nzeta function.\n-/\nlemma completedLFunction_modOne_eq (Œ¶ : ZMod 1 ‚Üí ‚ÑÇ) (s : ‚ÑÇ) :\n    completedLFunction Œ¶ s = Œ¶ 1 * completedRiemannZeta s := by\n  rw [completedLFunction_def_even (show Œ¶.Even from fun _ ‚Ü¶ congr_arg Œ¶ (Subsingleton.elim ..)),\n    Nat.cast_one, one_cpow, one_mul, ‚Üê singleton_eq_univ 0, sum_singleton, map_zero,\n    completedHurwitzZetaEven_zero, Subsingleton.elim 0 1]\n\n"}
{"name":"ZMod.differentiable_completedLFunction‚ÇÄ","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\n‚ä¢ Differentiable Complex (ZMod.completedLFunction‚ÇÄ Œ¶)","decl":"/-- The function `completedLFunction‚ÇÄ Œ¶` is differentiable. -/\nlemma differentiable_completedLFunction‚ÇÄ (Œ¶ : ZMod N ‚Üí ‚ÑÇ) :\n    Differentiable ‚ÑÇ (completedLFunction‚ÇÄ Œ¶) := by\n  refine .add ?_ ?_ <;>\n  refine .mul (by fun_prop) (.sum fun i _ ‚Ü¶ .const_mul ?_ _)\n  exacts [differentiable_completedHurwitzZetaEven‚ÇÄ _, differentiable_completedHurwitzZetaOdd _]\n\n"}
{"name":"ZMod.completedLFunction_eq","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction Œ¶ s) (HSub.hSub (HSub.hSub (ZMod.completedLFunction‚ÇÄ Œ¶ s) (HDiv.hDiv (HMul.hMul (HPow.hPow (‚ÜëN) (Neg.neg s)) (Œ¶ 0)) s)) (HDiv.hDiv (HMul.hMul (HPow.hPow (‚ÜëN) (Neg.neg s)) (Finset.univ.sum fun j => Œ¶ j)) (HSub.hSub 1 s)))","decl":"lemma completedLFunction_eq (Œ¶ : ZMod N ‚Üí ‚ÑÇ) (s : ‚ÑÇ) :\n    completedLFunction Œ¶ s =\n      completedLFunction‚ÇÄ Œ¶ s - N ^ (-s) * Œ¶ 0 / s - N ^ (-s) * (‚àë j, Œ¶ j) / (1 - s) := by\n  simp only [completedLFunction, completedHurwitzZetaEven_eq, toAddCircle_eq_zero, div_eq_mul_inv,\n    ite_mul, one_mul, zero_mul, mul_sub, mul_ite, mul_zero, sum_sub_distrib, Fintype.sum_ite_eq',\n    ‚Üê sum_mul, completedLFunction‚ÇÄ, mul_assoc]\n  abel\n\n"}
{"name":"ZMod.differentiableAt_completedLFunction","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\ns : Complex\nhs‚ÇÄ : Or (Ne s 0) (Eq (Œ¶ 0) 0)\nhs‚ÇÅ : Or (Ne s 1) (Eq (Finset.univ.sum fun j => Œ¶ j) 0)\n‚ä¢ DifferentiableAt Complex (ZMod.completedLFunction Œ¶) s","decl":"/--\nThe completed L-function of a function `ZMod N ‚Üí ‚ÑÇ` is differentiable, with the following\nexceptions: at `s = 1` if `‚àë j, Œ¶ j ‚â† 0`; and at `s = 0` if `Œ¶ 0 ‚â† 0`.\n-/\nlemma differentiableAt_completedLFunction (Œ¶ : ZMod N ‚Üí ‚ÑÇ) (s : ‚ÑÇ) (hs‚ÇÄ : s ‚â† 0 ‚à® Œ¶ 0 = 0)\n    (hs‚ÇÅ : s ‚â† 1 ‚à® ‚àë j, Œ¶ j = 0) : DifferentiableAt ‚ÑÇ (completedLFunction Œ¶) s := by\n  simp only [funext (completedLFunction_eq Œ¶), mul_div_assoc]\n  -- We know `completedLFunction‚ÇÄ` is differentiable everywhere, so it suffices to show that the\n  -- correction terms from `completedLFunction_eq` are differentiable at `s`.\n  refine ((differentiable_completedLFunction‚ÇÄ _ _).sub ?_).sub ?_\n  ¬∑ -- term with `1 / s`\n    refine .mul (by fun_prop) (hs‚ÇÄ.elim ?_ ?_)\n    ¬∑ exact fun h ‚Ü¶ (differentiableAt_const _).div differentiableAt_id h\n    ¬∑ exact fun h ‚Ü¶ by simp only [h, funext zero_div, differentiableAt_const]\n  ¬∑ -- term with `1 / (1 - s)`\n    refine .mul (by fun_prop) (hs‚ÇÅ.elim ?_ ?_)\n    ¬∑ exact fun h ‚Ü¶ .div (by fun_prop) (by fun_prop) (by rwa [sub_ne_zero, ne_comm])\n    ¬∑ exact fun h ‚Ü¶ by simp only [h, zero_div, differentiableAt_const]\n\n"}
{"name":"ZMod.differentiable_completedLFunction","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶‚ÇÇ : Eq (Œ¶ 0) 0\nhŒ¶‚ÇÉ : Eq (Finset.univ.sum fun j => Œ¶ j) 0\n‚ä¢ Differentiable Complex (ZMod.completedLFunction Œ¶)","decl":"/--\nSpecial case of `differentiableAt_completedLFunction` asserting differentiability everywhere\nunder suitable hypotheses.\n-/\nlemma differentiable_completedLFunction (hŒ¶‚ÇÇ : Œ¶ 0 = 0) (hŒ¶‚ÇÉ : ‚àë j, Œ¶ j = 0) :\n    Differentiable ‚ÑÇ (completedLFunction Œ¶) :=\n  fun s ‚Ü¶ differentiableAt_completedLFunction Œ¶ s (.inr hŒ¶‚ÇÇ) (.inr hŒ¶‚ÇÉ)\n\n"}
{"name":"ZMod.LFunction_eq_completed_div_gammaFactor_even","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Even Œ¶\ns : Complex\nhs : Or (Ne s 0) (Eq (Œ¶ 0) 0)\n‚ä¢ Eq (ZMod.LFunction Œ¶ s) (HDiv.hDiv (ZMod.completedLFunction Œ¶ s) s.Gamma‚Ñù)","decl":"/--\nRelation between the completed L-function and the usual one (even case).\nWe state it this way around so it holds at the poles of the gamma factor as well\n(except at `s = 0`, where it is genuinely false if `N > 1` and `Œ¶ 0 ‚â† 0`).\n-/\nlemma LFunction_eq_completed_div_gammaFactor_even (hŒ¶ : Œ¶.Even) (s : ‚ÑÇ) (hs : s ‚â† 0 ‚à® Œ¶ 0 = 0) :\n    LFunction Œ¶ s = completedLFunction Œ¶ s / Gamma‚Ñù s := by\n  simp only [completedLFunction_def_even hŒ¶, LFunction_def_even hŒ¶, mul_div_assoc, sum_div]\n  congr 2 with i\n  rcases ne_or_eq i 0 with hi | rfl\n  ¬∑ rw [hurwitzZetaEven_def_of_ne_or_ne (.inl (hi ‚àò toAddCircle_eq_zero.mp))]\n  ¬∑ rcases hs with hs | hŒ¶'\n    ¬∑ rw [hurwitzZetaEven_def_of_ne_or_ne (.inr hs)]\n    ¬∑ simp only [hŒ¶', map_zero, zero_mul]\n\n"}
{"name":"ZMod.LFunction_eq_completed_div_gammaFactor_odd","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Odd Œ¶\ns : Complex\n‚ä¢ Eq (ZMod.LFunction Œ¶ s) (HDiv.hDiv (ZMod.completedLFunction Œ¶ s) (HAdd.hAdd s 1).Gamma‚Ñù)","decl":"/--\nRelation between the completed L-function and the usual one (odd case).\nWe state it this way around so it holds at the poles of the gamma factor as well.\n-/\nlemma LFunction_eq_completed_div_gammaFactor_odd (hŒ¶ : Œ¶.Odd) (s : ‚ÑÇ) :\n    LFunction Œ¶ s = completedLFunction Œ¶ s / Gamma‚Ñù (s + 1) := by\n  simp only [LFunction_def_odd hŒ¶, completedLFunction_def_odd hŒ¶, hurwitzZetaOdd, mul_div_assoc,\n    sum_div]\n\n"}
{"name":"ZMod.completedLFunction_one_sub_even","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Even Œ¶\ns : Complex\nhs‚ÇÄ : Or (Ne s 0) (Eq (Finset.univ.sum fun j => Œ¶ j) 0)\nhs‚ÇÅ : Or (Ne s 1) (Eq (Œ¶ 0) 0)\n‚ä¢ Eq (ZMod.completedLFunction Œ¶ (HSub.hSub 1 s)) (HMul.hMul (HPow.hPow (‚ÜëN) (HSub.hSub s 1)) (ZMod.completedLFunction (ZMod.dft Œ¶) s))","decl":"/--\nFunctional equation for completed L-functions (even case), valid at all points of differentiability.\n-/\ntheorem completedLFunction_one_sub_even (hŒ¶ : Œ¶.Even) (s : ‚ÑÇ)\n    (hs‚ÇÄ : s ‚â† 0 ‚à® ‚àë j, Œ¶ j = 0) (hs‚ÇÅ : s ‚â† 1 ‚à® Œ¶ 0 = 0) :\n    completedLFunction Œ¶ (1 - s) = N ^ (s - 1) * completedLFunction (ùìï Œ¶) s := by\n  -- We prove this using `AnalyticOnNhd.eqOn_of_preconnected_of_eventuallyEq`, so we need to\n  -- gather up the ingredients for this big theorem.\n  -- First set up some notations:\n  let F (t) := completedLFunction Œ¶ (1 - t)\n  let G (t) := ‚ÜëN ^ (t - 1) * completedLFunction (ùìï Œ¶) t\n  -- Set on which F, G are analytic:\n  let U := {t : ‚ÑÇ | (t ‚â† 0 ‚à® ‚àë j, Œ¶ j = 0) ‚àß (t ‚â† 1 ‚à® Œ¶ 0 = 0)}\n  -- Properties of U:\n  have hsU : s ‚àà U := ‚ü®hs‚ÇÄ, hs‚ÇÅ‚ü©\n  have h2U : 2 ‚àà U := ‚ü®.inl two_ne_zero, .inl (OfNat.ofNat_ne_one _)‚ü©\n  have hUo : IsOpen U := (isOpen_compl_singleton.union isOpen_const).inter\n    (isOpen_compl_singleton.union isOpen_const)\n  have hUp : IsPreconnected U := by\n    -- need to write `U` as the complement of an obviously countable set\n    let Uc : Set ‚ÑÇ := (if ‚àë j, Œ¶ j = 0 then ‚àÖ else {0}) ‚à™ (if Œ¶ 0 = 0 then ‚àÖ else {1})\n    have : Uc.Countable := by\n      apply Countable.union <;>\n      split_ifs <;>\n      simp only [countable_singleton, countable_empty]\n    convert (this.isConnected_compl_of_one_lt_rank ?_).isPreconnected using 1\n    ¬∑ ext x\n      by_cases h : Œ¶ 0 = 0 <;>\n      by_cases h' : ‚àë j, Œ¶ j = 0 <;>\n      simp [U, Uc, h, h', and_comm]\n    ¬∑ simp only [rank_real_complex, Nat.one_lt_ofNat]\n  -- Analyticity on U:\n  have hF : AnalyticOnNhd ‚ÑÇ F U := by\n    refine DifferentiableOn.analyticOnNhd\n      (fun t ht ‚Ü¶ DifferentiableAt.differentiableWithinAt ?_) hUo\n    refine (differentiableAt_completedLFunction Œ¶ _ ?_ ?_).comp t (differentiableAt_id.const_sub 1)\n    exacts [ht.2.imp_left (sub_ne_zero.mpr ‚àò Ne.symm), ht.1.imp_left sub_eq_self.not.mpr]\n  have hG : AnalyticOnNhd ‚ÑÇ G U := by\n    refine DifferentiableOn.analyticOnNhd\n      (fun t ht ‚Ü¶ DifferentiableAt.differentiableWithinAt ?_) hUo\n    apply ((differentiableAt_id.sub_const 1).const_cpow (.inl (NeZero.ne _))).mul\n    apply differentiableAt_completedLFunction _ _ (ht.1.imp_right fun h ‚Ü¶ dft_apply_zero Œ¶ ‚ñ∏ h)\n    exact ht.2.imp_right (fun h ‚Ü¶ by simp only [‚Üê dft_apply_zero, dft_dft, neg_zero, h, smul_zero])\n  -- set where we know equality\n  have hV : {z | 1 < re z} ‚àà ùìù 2 := (continuous_re.isOpen_preimage _ isOpen_Ioi).mem_nhds (by simp)\n  have hFG : F =·∂†[ùìù 2] G := eventually_of_mem hV <| fun t ht ‚Ü¶ by\n    simpa only [F, G, pow_zero, mul_one] using completedLFunction_one_sub_of_one_lt_even hŒ¶ ht\n  -- now apply the big hammer to finish\n  exact hF.eqOn_of_preconnected_of_eventuallyEq hG hUp h2U hFG hsU\n\n"}
{"name":"ZMod.completedLFunction_one_sub_odd","module":"Mathlib.NumberTheory.LSeries.ZMod","initialProofState":"N : Nat\ninst‚úù : NeZero N\nŒ¶ : ZMod N ‚Üí Complex\nhŒ¶ : Function.Odd Œ¶\ns : Complex\n‚ä¢ Eq (ZMod.completedLFunction Œ¶ (HSub.hSub 1 s)) (HMul.hMul (HMul.hMul (HPow.hPow (‚ÜëN) (HSub.hSub s 1)) Complex.I) (ZMod.completedLFunction (ZMod.dft Œ¶) s))","decl":"/-- Functional equation for completed L-functions (odd case), valid for all `s`. -/\ntheorem completedLFunction_one_sub_odd (hŒ¶ : Œ¶.Odd) (s : ‚ÑÇ) :\n    completedLFunction Œ¶ (1 - s) = N ^ (s - 1) * I * completedLFunction (ùìï Œ¶) s := by\n  -- This is much easier than the even case since both functions are entire.\n  -- First set up some notations:\n  let F (t) := completedLFunction Œ¶ (1 - t)\n  let G (t) := ‚ÜëN ^ (t - 1) * I * completedLFunction (ùìï Œ¶) t\n  -- check F, G globally differentiable\n  have hF : Differentiable ‚ÑÇ F := (differentiable_completedLFunction hŒ¶.map_zero\n    hŒ¶.sum_eq_zero).comp (differentiable_id.const_sub 1)\n  have hG : Differentiable ‚ÑÇ G := by\n    apply (((differentiable_id.sub_const 1).const_cpow (.inl (NeZero.ne _))).mul_const _).mul\n    rw [‚Üê dft_odd_iff] at hŒ¶\n    exact differentiable_completedLFunction hŒ¶.map_zero hŒ¶.sum_eq_zero\n  -- set where we know equality\n  have : {z | 1 < re z} ‚àà ùìù 2 := (continuous_re.isOpen_preimage _ isOpen_Ioi).mem_nhds (by simp)\n  have hFG : F =·∂†[ùìù 2] G := by filter_upwards [this] with t ht\n    using completedLFunction_one_sub_of_one_lt_odd hŒ¶ ht\n  -- now apply the big hammer to finish\n  rw [‚Üê analyticOnNhd_univ_iff_differentiable] at hF hG\n  exact congr_fun (hF.eq_of_eventuallyEq hG hFG) s\n\n"}
