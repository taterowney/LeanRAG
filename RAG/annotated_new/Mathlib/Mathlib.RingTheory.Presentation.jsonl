{"name":"Algebra.Presentation.mk.inj","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ntoGenerators✝ : Algebra.Generators R S\nrels✝ : Type t\nrelation✝ : rels✝ → toGenerators✝.Ring\nspan_range_relation_eq_ker✝ : Eq (Ideal.span (Set.range relation✝)) toGenerators✝.ker\ntoGenerators : Algebra.Generators R S\nrels : Type t\nrelation : rels → toGenerators.Ring\nspan_range_relation_eq_ker : Eq (Ideal.span (Set.range relation)) toGenerators.ker\nx✝ : Eq { toGenerators := toGenerators✝, rels := rels✝, relation := relation✝, span_range_relation_eq_ker := span_range_relation_eq_ker✝ } { toGenerators := toGenerators, rels := rels, relation := relation, span_range_relation_eq_ker := span_range_relation_eq_ker }\n⊢ And (Eq toGenerators✝ toGenerators) (And (Eq rels✝ rels) (HEq relation✝ relation))","decl":"/--\nA presentation of an `R`-algebra `S` is a family of\ngenerators with\n1. `rels`: The type of relations.\n2. `relation : relations → MvPolynomial vars R`: The assignment of\neach relation to a polynomial in the generators.\n-/\n@[nolint checkUnivs]\nstructure Algebra.Presentation extends Algebra.Generators.{w} R S where\n  /-- The type of relations. -/\n  rels : Type t\n  /-- The assignment of each relation to a polynomial in the generators. -/\n  relation : rels → toGenerators.Ring\n  /-- The relations span the kernel of the canonical map. -/\n  span_range_relation_eq_ker :\n    Ideal.span (Set.range relation) = toGenerators.ker\n\n"}
{"name":"Algebra.Presentation.mk.injEq","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\ntoGenerators✝ : Algebra.Generators R S\nrels✝ : Type t\nrelation✝ : rels✝ → toGenerators✝.Ring\nspan_range_relation_eq_ker✝ : Eq (Ideal.span (Set.range relation✝)) toGenerators✝.ker\ntoGenerators : Algebra.Generators R S\nrels : Type t\nrelation : rels → toGenerators.Ring\nspan_range_relation_eq_ker : Eq (Ideal.span (Set.range relation)) toGenerators.ker\n⊢ Eq (Eq { toGenerators := toGenerators✝, rels := rels✝, relation := relation✝, span_range_relation_eq_ker := span_range_relation_eq_ker✝ } { toGenerators := toGenerators, rels := rels, relation := relation, span_range_relation_eq_ker := span_range_relation_eq_ker }) (And (Eq toGenerators✝ toGenerators) (And (Eq rels✝ rels) (HEq relation✝ relation)))","decl":"/--\nA presentation of an `R`-algebra `S` is a family of\ngenerators with\n1. `rels`: The type of relations.\n2. `relation : relations → MvPolynomial vars R`: The assignment of\neach relation to a polynomial in the generators.\n-/\n@[nolint checkUnivs]\nstructure Algebra.Presentation extends Algebra.Generators.{w} R S where\n  /-- The type of relations. -/\n  rels : Type t\n  /-- The assignment of each relation to a polynomial in the generators. -/\n  relation : rels → toGenerators.Ring\n  /-- The relations span the kernel of the canonical map. -/\n  span_range_relation_eq_ker :\n    Ideal.span (Set.range relation) = toGenerators.ker\n\n"}
{"name":"Algebra.Presentation.mk.sizeOf_spec","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : SizeOf R\ninst✝ : SizeOf S\ntoGenerators : Algebra.Generators R S\nrels : Type t\nrelation : rels → toGenerators.Ring\nspan_range_relation_eq_ker : Eq (Ideal.span (Set.range relation)) toGenerators.ker\n⊢ Eq (SizeOf.sizeOf { toGenerators := toGenerators, rels := rels, relation := relation, span_range_relation_eq_ker := span_range_relation_eq_ker }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toGenerators)) (SizeOf.sizeOf rels)) (SizeOf.sizeOf span_range_relation_eq_ker))","decl":"/--\nA presentation of an `R`-algebra `S` is a family of\ngenerators with\n1. `rels`: The type of relations.\n2. `relation : relations → MvPolynomial vars R`: The assignment of\neach relation to a polynomial in the generators.\n-/\n@[nolint checkUnivs]\nstructure Algebra.Presentation extends Algebra.Generators.{w} R S where\n  /-- The type of relations. -/\n  rels : Type t\n  /-- The assignment of each relation to a polynomial in the generators. -/\n  relation : rels → toGenerators.Ring\n  /-- The relations span the kernel of the canonical map. -/\n  span_range_relation_eq_ker :\n    Ideal.span (Set.range relation) = toGenerators.ker\n\n"}
{"name":"Algebra.Presentation.span_range_relation_eq_ker","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nself : Algebra.Presentation R S\n⊢ Eq (Ideal.span (Set.range self.relation)) self.ker","decl":"/--\nA presentation of an `R`-algebra `S` is a family of\ngenerators with\n1. `rels`: The type of relations.\n2. `relation : relations → MvPolynomial vars R`: The assignment of\neach relation to a polynomial in the generators.\n-/\n@[nolint checkUnivs]\nstructure Algebra.Presentation extends Algebra.Generators.{w} R S where\n  /-- The type of relations. -/\n  rels : Type t\n  /-- The assignment of each relation to a polynomial in the generators. -/\n  relation : rels → toGenerators.Ring\n  /-- The relations span the kernel of the canonical map. -/\n  span_range_relation_eq_ker :\n    Ideal.span (Set.range relation) = toGenerators.ker\n\n"}
{"name":"Algebra.Presentation.aeval_val_relation","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Presentation R S\ni : P.rels\n⊢ Eq ((MvPolynomial.aeval P.val) (P.relation i)) 0","decl":"@[simp]\nlemma aeval_val_relation (i) : aeval P.val (P.relation i) = 0 := by\n  rw [← RingHom.mem_ker, ← P.ker_eq_ker_aeval_val, ← P.span_range_relation_eq_ker]\n  exact Ideal.subset_span ⟨i, rfl⟩\n\n"}
{"name":"Algebra.Presentation.relation_mem_ker","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Presentation R S\ni : P.rels\n⊢ Membership.mem P.ker (P.relation i)","decl":"lemma relation_mem_ker (i : P.rels) : P.relation i ∈ P.ker := by\n  rw [← P.span_range_relation_eq_ker]\n  apply Ideal.subset_span\n  use i\n\n"}
{"name":"Algebra.Presentation.quotientEquiv_mk","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Presentation R S\np : P.Ring\n⊢ Eq (P.quotientEquiv ((Ideal.Quotient.mk P.ker) p)) ((algebraMap P.Ring S) p)","decl":"@[simp]\nlemma quotientEquiv_mk (p : P.Ring) : P.quotientEquiv p = algebraMap P.Ring S p :=\n  rfl\n\n"}
{"name":"Algebra.Presentation.quotientEquiv_symm","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Presentation R S\nx : S\n⊢ Eq (P.quotientEquiv.symm x) ((Ideal.Quotient.mk P.ker) (P.σ x))","decl":"@[simp]\nlemma quotientEquiv_symm (x : S) : P.quotientEquiv.symm x = P.σ x :=\n  rfl\n\n"}
{"name":"Algebra.Presentation.IsFinite.finite_vars","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Presentation R S\nself : P.IsFinite\n⊢ Finite P.vars","decl":"/-- A presentation is finite if there are only finitely-many\nrelations and finitely-many relations. -/\nclass IsFinite (P : Presentation.{t, w} R S) : Prop where\n  finite_vars : Finite P.vars\n  finite_rels : Finite P.rels\n\n"}
{"name":"Algebra.Presentation.IsFinite.finite_rels","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nP : Algebra.Presentation R S\nself : P.IsFinite\n⊢ Finite P.rels","decl":"/-- A presentation is finite if there are only finitely-many\nrelations and finitely-many relations. -/\nclass IsFinite (P : Presentation.{t, w} R S) : Prop where\n  finite_vars : Finite P.vars\n  finite_rels : Finite P.rels\n\n"}
{"name":"Algebra.Presentation.ideal_fg_of_isFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Algebra.Presentation R S\ninst✝ : P.IsFinite\n⊢ P.ker.FG","decl":"lemma ideal_fg_of_isFinite [P.IsFinite] : P.ker.FG := by\n  use (Set.finite_range P.relation).toFinset\n  simp [span_range_relation_eq_ker]\n\n"}
{"name":"Algebra.Presentation.instFinitePresentationQuotientOfIsFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Algebra.Presentation R S\ninst✝ : P.IsFinite\n⊢ Algebra.FinitePresentation R P.Quotient","decl":"/-- If a presentation is finite, the corresponding quotient is\nof finite presentation. -/\ninstance [P.IsFinite] : FinitePresentation R P.Quotient :=\n  FinitePresentation.quotient P.ideal_fg_of_isFinite\n\n"}
{"name":"Algebra.Presentation.finitePresentation_of_isFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nP : Algebra.Presentation R S\ninst✝ : P.IsFinite\n⊢ Algebra.FinitePresentation R S","decl":"lemma finitePresentation_of_isFinite [P.IsFinite] :\n    FinitePresentation R S :=\n  FinitePresentation.equiv (P.quotientEquiv.restrictScalars R)\n\n"}
{"name":"Algebra.Presentation.instIsFiniteOfFinitePresentation","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : Algebra.FinitePresentation R S\n⊢ (Algebra.Presentation.ofFinitePresentation R S).IsFinite","decl":"instance [FinitePresentation R S] : (ofFinitePresentation R S).IsFinite where\n  finite_vars := Finite.of_fintype (Fin _)\n  finite_rels := Finite.of_fintype (Fin _)\n\n"}
{"name":"Algebra.Presentation.ofBijectiveAlgebraMap_isFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Bijective ⇑(algebraMap R S)\n⊢ (Algebra.Presentation.ofBijectiveAlgebraMap h).IsFinite","decl":"instance ofBijectiveAlgebraMap_isFinite (h : Function.Bijective (algebraMap R S)) :\n    (ofBijectiveAlgebraMap.{t, w} h).IsFinite where\n  finite_vars := inferInstanceAs (Finite PEmpty.{w + 1})\n  finite_rels := inferInstanceAs (Finite PEmpty.{t + 1})\n\n"}
{"name":"Algebra.Presentation.ofBijectiveAlgebraMap_dimension","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nh : Function.Bijective ⇑(algebraMap R S)\n⊢ Eq (Algebra.Presentation.ofBijectiveAlgebraMap h).dimension 0","decl":"lemma ofBijectiveAlgebraMap_dimension (h : Function.Bijective (algebraMap R S)) :\n    (ofBijectiveAlgebraMap h).dimension = 0 := by\n  simp_rw [dimension, ofBijectiveAlgebraMap, Generators.ofSurjectiveAlgebraMap,\n    Generators.ofSurjective, Nat.card_eq_fintype_card, Fintype.card_ofIsEmpty]\n\n"}
{"name":"Algebra.Presentation.instIsFiniteId","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ (Algebra.Presentation.id R).IsFinite","decl":"instance : (id R).IsFinite := ofBijectiveAlgebraMap_isFinite (R := R) Function.bijective_id\n\n"}
{"name":"Algebra.Presentation.id_dimension","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\ninst✝ : CommRing R\n⊢ Eq (Algebra.Presentation.id R).dimension 0","decl":"lemma id_dimension : (Presentation.id R).dimension = 0 :=\n  ofBijectiveAlgebraMap_dimension (R := R) Function.bijective_id\n\n"}
{"name":"Algebra.Presentation.localizationAway_relation","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\nx✝ : Unit\n⊢ Eq ((Algebra.Presentation.localizationAway S r).relation x✝) (HSub.hSub (HMul.hMul (MvPolynomial.C r) (MvPolynomial.X Unit.unit)) 1)","decl":"variable (S) in\n/-- If `S` is the localization of `R` away from `r`, we can construct a natural\npresentation of `S` as `R`-algebra with a single generator `X` and the relation `r * X - 1 = 0`. -/\n@[simps relation, simps (config := .lemmasOnly) rels]\nnoncomputable def localizationAway : Presentation R S where\n  toGenerators := Generators.localizationAway r\n  rels := Unit\n  relation _ := C r * X () - 1\n  span_range_relation_eq_ker := by\n    simp only [Generators.localizationAway_vars, Set.range_const]\n    apply span_range_relation_eq_ker_localizationAway r\n\n"}
{"name":"Algebra.Presentation.localizationAway_rels","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Eq (Algebra.Presentation.localizationAway S r).rels Unit","decl":"variable (S) in\n/-- If `S` is the localization of `R` away from `r`, we can construct a natural\npresentation of `S` as `R`-algebra with a single generator `X` and the relation `r * X - 1 = 0`. -/\n@[simps relation, simps (config := .lemmasOnly) rels]\nnoncomputable def localizationAway : Presentation R S where\n  toGenerators := Generators.localizationAway r\n  rels := Unit\n  relation _ := C r * X () - 1\n  span_range_relation_eq_ker := by\n    simp only [Generators.localizationAway_vars, Set.range_const]\n    apply span_range_relation_eq_ker_localizationAway r\n\n"}
{"name":"Algebra.Presentation.localizationAway_isFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ (Algebra.Presentation.localizationAway S r).IsFinite","decl":"instance localizationAway_isFinite : (localizationAway S r).IsFinite where\n  finite_vars := inferInstanceAs <| Finite Unit\n  finite_rels := inferInstanceAs <| Finite Unit\n\n"}
{"name":"Algebra.Presentation.localizationAway_dimension_zero","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\n⊢ Eq (Algebra.Presentation.localizationAway S r).dimension 0","decl":"@[simp]\nlemma localizationAway_dimension_zero : (localizationAway S r).dimension = 0 := by\n  simp [Presentation.dimension, localizationAway, Generators.localizationAway_vars]\n\n"}
{"name":"Algebra.Presentation.baseChange_rels","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nP : Algebra.Presentation R S\n⊢ Eq (Algebra.Presentation.baseChange T P).rels P.rels","decl":"/-- If `P` is a presentation of `S` over `R` and `T` is an `R`-algebra, we\nobtain a natural presentation of `T ⊗[R] S` over `T`. -/\n@[simps relation, simps (config := .lemmasOnly) rels]\nnoncomputable\ndef baseChange : Presentation T (T ⊗[R] S) where\n  __ := Generators.baseChange P.toGenerators\n  rels := P.rels\n  relation i := MvPolynomial.map (algebraMap R T) (P.relation i)\n  span_range_relation_eq_ker := P.span_range_relation_eq_ker_baseChange T\n\n"}
{"name":"Algebra.Presentation.baseChange_relation","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nT : Type u_1\ninst✝¹ : CommRing T\ninst✝ : Algebra R T\nP : Algebra.Presentation R S\ni : P.rels\n⊢ Eq ((Algebra.Presentation.baseChange T P).relation i) ((MvPolynomial.map (algebraMap R T)) (P.relation i))","decl":"/-- If `P` is a presentation of `S` over `R` and `T` is an `R`-algebra, we\nobtain a natural presentation of `T ⊗[R] S` over `T`. -/\n@[simps relation, simps (config := .lemmasOnly) rels]\nnoncomputable\ndef baseChange : Presentation T (T ⊗[R] S) where\n  __ := Generators.baseChange P.toGenerators\n  rels := P.rels\n  relation i := MvPolynomial.map (algebraMap R T) (P.relation i)\n  span_range_relation_eq_ker := P.span_range_relation_eq_ker_baseChange T\n\n"}
{"name":"Algebra.Presentation.baseChange_isFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁵ : CommRing R\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\nT : Type u_3\ninst✝² : CommRing T\ninst✝¹ : Algebra R T\nP : Algebra.Presentation R S\ninst✝ : P.IsFinite\n⊢ (Algebra.Presentation.baseChange T P).IsFinite","decl":"instance baseChange_isFinite [P.IsFinite] : (P.baseChange T).IsFinite where\n  finite_vars := inferInstanceAs <| Finite (P.vars)\n  finite_rels := inferInstanceAs <| Finite (P.rels)\n\n"}
{"name":"Algebra.Presentation.comp_rels","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra S T\nQ : Algebra.Presentation S T\nP : Algebra.Presentation R S\ninst✝¹ : Algebra R T\ninst✝ : IsScalarTower R S T\n⊢ Eq (Q.comp P).rels (Sum Q.rels P.rels)","decl":"/-- Given presentations of `T` over `S` and of `S` over `R`,\nwe may construct a presentation of `T` over `R`. -/\n@[simps rels, simps (config := .lemmasOnly) relation]\nnoncomputable def comp : Presentation R T where\n  toGenerators := Q.toGenerators.comp P.toGenerators\n  rels := Q.rels ⊕ P.rels\n  relation := Sum.elim (Q.comp_relation_aux P)\n    (fun rp ↦ MvPolynomial.rename Sum.inr <| P.relation rp)\n  span_range_relation_eq_ker := Q.span_range_relation_eq_ker_comp P\n\n"}
{"name":"Algebra.Presentation.comp_relation","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_1\ninst✝³ : CommRing T\ninst✝² : Algebra S T\nQ : Algebra.Presentation S T\nP : Algebra.Presentation R S\ninst✝¹ : Algebra R T\ninst✝ : IsScalarTower R S T\na✝ : Sum Q.rels P.rels\n⊢ Eq ((Q.comp P).relation a✝) (Sum.elim (Algebra.Presentation.comp_relation_aux Q P) (fun rp => (MvPolynomial.rename Sum.inr) (P.relation rp)) a✝)","decl":"/-- Given presentations of `T` over `S` and of `S` over `R`,\nwe may construct a presentation of `T` over `R`. -/\n@[simps rels, simps (config := .lemmasOnly) relation]\nnoncomputable def comp : Presentation R T where\n  toGenerators := Q.toGenerators.comp P.toGenerators\n  rels := Q.rels ⊕ P.rels\n  relation := Sum.elim (Q.comp_relation_aux P)\n    (fun rp ↦ MvPolynomial.rename Sum.inr <| P.relation rp)\n  span_range_relation_eq_ker := Q.span_range_relation_eq_ker_comp P\n\n"}
{"name":"Algebra.Presentation.comp_relation_inr","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_4\ninst✝³ : CommRing T\ninst✝² : Algebra S T\nQ : Algebra.Presentation S T\nP : Algebra.Presentation R S\ninst✝¹ : Algebra R T\ninst✝ : IsScalarTower R S T\nr : P.rels\n⊢ Eq ((Q.comp P).relation (Sum.inr r)) ((MvPolynomial.rename Sum.inr) (P.relation r))","decl":"@[simp]\nlemma comp_relation_inr (r : P.rels) :\n    (Q.comp P).relation (Sum.inr r) = rename Sum.inr (P.relation r) :=\n  rfl\n\n"}
{"name":"Algebra.Presentation.comp_aeval_relation_inl","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : CommRing S\ninst✝⁴ : Algebra R S\nT : Type u_3\ninst✝³ : CommRing T\ninst✝² : Algebra S T\nQ : Algebra.Presentation S T\nP : Algebra.Presentation R S\ninst✝¹ : Algebra R T\ninst✝ : IsScalarTower R S T\nr : Q.rels\n⊢ Eq ((MvPolynomial.aeval (Sum.elim MvPolynomial.X (Function.comp (⇑MvPolynomial.C) P.val))) ((Q.comp P).relation (Sum.inl r))) (Q.relation r)","decl":"lemma comp_aeval_relation_inl (r : Q.rels) :\n    aeval (Sum.elim X (MvPolynomial.C ∘ P.val)) ((Q.comp P).relation (Sum.inl r)) =\n      Q.relation r := by\n  show (Q.aux P) _ = _\n  simp [comp_relation, comp_relation_aux_map]\n\n"}
{"name":"Algebra.Presentation.comp_isFinite","module":"Mathlib.RingTheory.Presentation","initialProofState":"R : Type u\nS : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : CommRing S\ninst✝⁶ : Algebra R S\nT : Type u_5\ninst✝⁵ : CommRing T\ninst✝⁴ : Algebra S T\nQ : Algebra.Presentation S T\nP : Algebra.Presentation R S\ninst✝³ : Algebra R T\ninst✝² : IsScalarTower R S T\ninst✝¹ : P.IsFinite\ninst✝ : Q.IsFinite\n⊢ (Q.comp P).IsFinite","decl":"instance comp_isFinite [P.IsFinite] [Q.IsFinite] : (Q.comp P).IsFinite where\n  finite_vars := inferInstanceAs <| Finite (Q.vars ⊕ P.vars)\n  finite_rels := inferInstanceAs <| Finite (Q.rels ⊕ P.rels)\n\n"}
