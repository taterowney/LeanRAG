{"name":"IsConj.refl","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ IsConj a a","decl":"@[refl]\ntheorem IsConj.refl (a : α) : IsConj a a :=\n  ⟨1, SemiconjBy.one_left a⟩\n\n"}
{"name":"IsConj.symm","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\na✝ : IsConj a b\n⊢ IsConj b a","decl":"@[symm]\ntheorem IsConj.symm {a b : α} : IsConj a b → IsConj b a\n  | ⟨c, hc⟩ => ⟨c⁻¹, hc.units_inv_symm_left⟩\n\n"}
{"name":"isConj_comm","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\ng h : α\n⊢ Iff (IsConj g h) (IsConj h g)","decl":"theorem isConj_comm {g h : α} : IsConj g h ↔ IsConj h g :=\n  ⟨IsConj.symm, IsConj.symm⟩\n\n"}
{"name":"IsConj.trans","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na b c : α\na✝¹ : IsConj a b\na✝ : IsConj b c\n⊢ IsConj a c","decl":"@[trans]\ntheorem IsConj.trans {a b c : α} : IsConj a b → IsConj b c → IsConj a c\n  | ⟨c₁, hc₁⟩, ⟨c₂, hc₂⟩ => ⟨c₂ * c₁, hc₂.mul_left hc₁⟩\n\n"}
{"name":"isConj_iff_eq","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u_1\ninst✝ : CommMonoid α\na b : α\n⊢ Iff (IsConj a b) (Eq a b)","decl":"@[simp]\ntheorem isConj_iff_eq {α : Type*} [CommMonoid α] {a b : α} : IsConj a b ↔ a = b :=\n  ⟨fun ⟨c, hc⟩ => by\n    rw [SemiconjBy, mul_comm, ← Units.mul_inv_eq_iff_eq_mul, mul_assoc, c.mul_inv, mul_one] at hc\n    exact hc, fun h => by rw [h]⟩\n\n"}
{"name":"MonoidHom.map_isConj","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nf : MonoidHom α β\na b : α\na✝ : IsConj a b\n⊢ IsConj (f a) (f b)","decl":"protected theorem MonoidHom.map_isConj (f : α →* β) {a b : α} : IsConj a b → IsConj (f a) (f b)\n  | ⟨c, hc⟩ => ⟨Units.map f c, by rw [Units.coe_map, SemiconjBy, ← f.map_mul, hc.eq, f.map_mul]⟩\n\n"}
{"name":"isConj_one_right","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : CancelMonoid α\na : α\n⊢ Iff (IsConj 1 a) (Eq a 1)","decl":"@[simp]\ntheorem isConj_one_right {a : α} : IsConj 1 a ↔ a = 1 :=\n  ⟨fun ⟨_, hc⟩ => mul_right_cancel (hc.symm.trans ((mul_one _).trans (one_mul _).symm)), fun h => by\n    rw [h]⟩\n\n"}
{"name":"isConj_one_left","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : CancelMonoid α\na : α\n⊢ Iff (IsConj a 1) (Eq a 1)","decl":"@[simp]\ntheorem isConj_one_left {a : α} : IsConj a 1 ↔ a = 1 :=\n  calc\n    IsConj a 1 ↔ IsConj 1 a := ⟨IsConj.symm, IsConj.symm⟩\n    _ ↔ a = 1 := isConj_one_right\n\n"}
{"name":"isConj_iff","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Group α\na b : α\n⊢ Iff (IsConj a b) (Exists fun c => Eq (HMul.hMul (HMul.hMul c a) (Inv.inv c)) b)","decl":"@[simp]\ntheorem isConj_iff {a b : α} : IsConj a b ↔ ∃ c : α, c * a * c⁻¹ = b :=\n  ⟨fun ⟨c, hc⟩ => ⟨c, mul_inv_eq_iff_eq_mul.2 hc⟩, fun ⟨c, hc⟩ =>\n    ⟨⟨c, c⁻¹, mul_inv_cancel c, inv_mul_cancel c⟩, mul_inv_eq_iff_eq_mul.1 hc⟩⟩\n\n-- Porting note: not in simp NF.\n-- @[simp]\n"}
{"name":"conj_inv","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Group α\na b : α\n⊢ Eq (Inv.inv (HMul.hMul (HMul.hMul b a) (Inv.inv b))) (HMul.hMul (HMul.hMul b (Inv.inv a)) (Inv.inv b))","decl":"theorem conj_inv {a b : α} : (b * a * b⁻¹)⁻¹ = b * a⁻¹ * b⁻¹ :=\n  (map_inv (MulAut.conj b) a).symm\n\n"}
{"name":"conj_mul","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Group α\na b c : α\n⊢ Eq (HMul.hMul (HMul.hMul (HMul.hMul b a) (Inv.inv b)) (HMul.hMul (HMul.hMul b c) (Inv.inv b))) (HMul.hMul (HMul.hMul b (HMul.hMul a c)) (Inv.inv b))","decl":"@[simp]\ntheorem conj_mul {a b c : α} : b * a * b⁻¹ * (b * c * b⁻¹) = b * (a * c) * b⁻¹ :=\n  (map_mul (MulAut.conj b) a c).symm\n\n"}
{"name":"conj_pow","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Group α\ni : Nat\na b : α\n⊢ Eq (HPow.hPow (HMul.hMul (HMul.hMul a b) (Inv.inv a)) i) (HMul.hMul (HMul.hMul a (HPow.hPow b i)) (Inv.inv a))","decl":"@[simp]\ntheorem conj_pow {i : ℕ} {a b : α} : (a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹ := by\n  induction' i with i hi\n  · simp\n  · simp [pow_succ, hi]\n\n"}
{"name":"conj_zpow","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Group α\ni : Int\na b : α\n⊢ Eq (HPow.hPow (HMul.hMul (HMul.hMul a b) (Inv.inv a)) i) (HMul.hMul (HMul.hMul a (HPow.hPow b i)) (Inv.inv a))","decl":"@[simp]\ntheorem conj_zpow {i : ℤ} {a b : α} : (a * b * a⁻¹) ^ i = a * b ^ i * a⁻¹ := by\n  induction i\n  · change (a * b * a⁻¹) ^ (_ : ℤ) = a * b ^ (_ : ℤ) * a⁻¹\n    simp [zpow_natCast]\n  · simp only [zpow_negSucc, conj_pow, mul_inv_rev, inv_inv]\n    rw [mul_assoc]\n-- Porting note: Added `change`, `zpow_natCast`, and `rw`.\n\n"}
{"name":"conj_injective","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Group α\nx : α\n⊢ Function.Injective fun g => HMul.hMul (HMul.hMul x g) (Inv.inv x)","decl":"theorem conj_injective {x : α} : Function.Injective fun g : α => x * g * x⁻¹ :=\n  (MulAut.conj x).injective\n\n"}
{"name":"ConjClasses.mk_eq_mk_iff_isConj","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\n⊢ Iff (Eq (ConjClasses.mk a) (ConjClasses.mk b)) (IsConj a b)","decl":"theorem mk_eq_mk_iff_isConj {a b : α} : ConjClasses.mk a = ConjClasses.mk b ↔ IsConj a b :=\n  Iff.intro Quotient.exact Quot.sound\n\n"}
{"name":"ConjClasses.quotient_mk_eq_mk","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ Eq (Quotient.mk (IsConj.setoid α) a) (ConjClasses.mk a)","decl":"theorem quotient_mk_eq_mk (a : α) : ⟦a⟧ = ConjClasses.mk a :=\n  rfl\n\n"}
{"name":"ConjClasses.quot_mk_eq_mk","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ Eq (Quot.mk (⇑(IsConj.setoid α)) a) (ConjClasses.mk a)","decl":"theorem quot_mk_eq_mk (a : α) : Quot.mk Setoid.r a = ConjClasses.mk a :=\n  rfl\n\n"}
{"name":"ConjClasses.forall_isConj","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\np : ConjClasses α → Prop\n⊢ Iff (∀ (a : ConjClasses α), p a) (∀ (a : α), p (ConjClasses.mk a))","decl":"theorem forall_isConj {p : ConjClasses α → Prop} : (∀ a, p a) ↔ ∀ a, p (ConjClasses.mk a) :=\n  Iff.intro (fun h _ => h _) fun h a => Quotient.inductionOn a h\n\n"}
{"name":"ConjClasses.mk_surjective","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\n⊢ Function.Surjective ConjClasses.mk","decl":"theorem mk_surjective : Function.Surjective (@ConjClasses.mk α _) :=\n  forall_isConj.2 fun a => ⟨a, rfl⟩\n\n"}
{"name":"ConjClasses.one_eq_mk_one","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\n⊢ Eq 1 (ConjClasses.mk 1)","decl":"theorem one_eq_mk_one : (1 : ConjClasses α) = ConjClasses.mk 1 :=\n  rfl\n\n"}
{"name":"ConjClasses.exists_rep","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : ConjClasses α\n⊢ Exists fun a0 => Eq (ConjClasses.mk a0) a","decl":"theorem exists_rep (a : ConjClasses α) : ∃ a0 : α, ConjClasses.mk a0 = a :=\n  Quot.exists_rep a\n\n"}
{"name":"ConjClasses.map_surjective","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\nβ : Type v\ninst✝¹ : Monoid α\ninst✝ : Monoid β\nf : MonoidHom α β\nhf : Function.Surjective ⇑f\n⊢ Function.Surjective (ConjClasses.map f)","decl":"theorem map_surjective {f : α →* β} (hf : Function.Surjective f) :\n    Function.Surjective (ConjClasses.map f) := by\n  intro b\n  obtain ⟨b, rfl⟩ := ConjClasses.mk_surjective b\n  obtain ⟨a, rfl⟩ := hf b\n  exact ⟨ConjClasses.mk a, rfl⟩\n\n-- Porting note: This has not been adapted to mathlib4, is it still accurate?\n"}
{"name":"ConjClasses.mk_injective","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : CommMonoid α\n⊢ Function.Injective ConjClasses.mk","decl":"theorem mk_injective : Function.Injective (@ConjClasses.mk α _) := fun _ _ =>\n  (mk_eq_mk_iff_isConj.trans isConj_iff_eq).1\n\n"}
{"name":"ConjClasses.mk_bijective","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : CommMonoid α\n⊢ Function.Bijective ConjClasses.mk","decl":"theorem mk_bijective : Function.Bijective (@ConjClasses.mk α _) :=\n  ⟨mk_injective, mk_surjective⟩\n\n"}
{"name":"mem_conjugatesOf_self","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ Membership.mem (conjugatesOf a) a","decl":"theorem mem_conjugatesOf_self {a : α} : a ∈ conjugatesOf a :=\n  IsConj.refl _\n\n"}
{"name":"IsConj.conjugatesOf_eq","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\nab : IsConj a b\n⊢ Eq (conjugatesOf a) (conjugatesOf b)","decl":"theorem IsConj.conjugatesOf_eq {a b : α} (ab : IsConj a b) : conjugatesOf a = conjugatesOf b :=\n  Set.ext fun _ => ⟨fun ag => ab.symm.trans ag, fun bg => ab.trans bg⟩\n\n"}
{"name":"isConj_iff_conjugatesOf_eq","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na b : α\n⊢ Iff (IsConj a b) (Eq (conjugatesOf a) (conjugatesOf b))","decl":"theorem isConj_iff_conjugatesOf_eq {a b : α} : IsConj a b ↔ conjugatesOf a = conjugatesOf b :=\n  ⟨IsConj.conjugatesOf_eq, fun h => by\n    have ha := @mem_conjugatesOf_self _ _ b -- Porting note: added `@`.\n    rwa [← h] at ha⟩\n\n"}
{"name":"ConjClasses.mem_carrier_mk","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\n⊢ Membership.mem (ConjClasses.mk a).carrier a","decl":"theorem mem_carrier_mk {a : α} : a ∈ carrier (ConjClasses.mk a) :=\n  IsConj.refl _\n\n"}
{"name":"ConjClasses.mem_carrier_iff_mk_eq","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : α\nb : ConjClasses α\n⊢ Iff (Membership.mem b.carrier a) (Eq (ConjClasses.mk a) b)","decl":"theorem mem_carrier_iff_mk_eq {a : α} {b : ConjClasses α} :\n    a ∈ carrier b ↔ ConjClasses.mk a = b := by\n  revert b\n  rw [forall_isConj]\n  intro b\n  rw [carrier, eq_comm, mk_eq_mk_iff_isConj, ← quotient_mk_eq_mk, Quotient.lift_mk]\n  rfl\n\n"}
{"name":"ConjClasses.carrier_eq_preimage_mk","module":"Mathlib.Algebra.Group.Conj","initialProofState":"α : Type u\ninst✝ : Monoid α\na : ConjClasses α\n⊢ Eq a.carrier (Set.preimage ConjClasses.mk (Singleton.singleton a))","decl":"theorem carrier_eq_preimage_mk {a : ConjClasses α} : a.carrier = ConjClasses.mk ⁻¹' {a} :=\n  Set.ext fun _ => mem_carrier_iff_mk_eq\n\n"}
