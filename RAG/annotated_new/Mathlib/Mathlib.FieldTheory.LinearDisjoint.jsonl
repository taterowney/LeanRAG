{"name":"IntermediateField.linearDisjoint_iff","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\n⊢ Iff (A.LinearDisjoint L) (A.LinearDisjoint (IsScalarTower.toAlgHom F L E).range)","decl":"theorem linearDisjoint_iff :\n    A.LinearDisjoint L ↔ A.toSubalgebra.LinearDisjoint (IsScalarTower.toAlgHom F L E).range :=\n  Iff.rfl\n\n"}
{"name":"IntermediateField.linearDisjoint_iff'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\n⊢ Iff (A.LinearDisjoint (Subtype fun x => Membership.mem B x)) (A.LinearDisjoint B.toSubalgebra)","decl":"/-- Two intermediate fields are linearly disjoint if and only if\nthey are linearly disjoint as subalgebras. -/\ntheorem linearDisjoint_iff' :\n    A.LinearDisjoint B ↔ A.toSubalgebra.LinearDisjoint B.toSubalgebra := by\n  rw [linearDisjoint_iff]\n  congr!\n  ext; simp\n\n"}
{"name":"IntermediateField.LinearDisjoint.symm","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\n⊢ B.LinearDisjoint (Subtype fun x => Membership.mem A x)","decl":"/-- Linear disjointness is symmetric. -/\ntheorem LinearDisjoint.symm (H : A.LinearDisjoint B) : B.LinearDisjoint A :=\n  linearDisjoint_iff'.2 (linearDisjoint_iff'.1 H).symm\n\n"}
{"name":"IntermediateField.linearDisjoint_comm","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\n⊢ Iff (A.LinearDisjoint (Subtype fun x => Membership.mem B x)) (B.LinearDisjoint (Subtype fun x => Membership.mem A x))","decl":"/-- Linear disjointness is symmetric. -/\ntheorem linearDisjoint_comm : A.LinearDisjoint B ↔ B.LinearDisjoint A :=\n  ⟨LinearDisjoint.symm, LinearDisjoint.symm⟩\n\n"}
{"name":"IntermediateField.LinearDisjoint.symm'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝¹⁰ : Field F\ninst✝⁹ : Field E\ninst✝⁸ : Algebra F E\nL : Type w\ninst✝⁷ : Field L\ninst✝⁶ : Algebra F L\ninst✝⁵ : Algebra L E\ninst✝⁴ : IsScalarTower F L E\nL' : Type u_1\ninst✝³ : Field L'\ninst✝² : Algebra F L'\ninst✝¹ : Algebra L' E\ninst✝ : IsScalarTower F L' E\nH : (IsScalarTower.toAlgHom F L E).fieldRange.LinearDisjoint L'\n⊢ (IsScalarTower.toAlgHom F L' E).fieldRange.LinearDisjoint L","decl":"/-- Linear disjointness is symmetric. -/\ntheorem LinearDisjoint.symm' (H : (IsScalarTower.toAlgHom F L E).fieldRange.LinearDisjoint L') :\n    (IsScalarTower.toAlgHom F L' E).fieldRange.LinearDisjoint L :=\n  Subalgebra.LinearDisjoint.symm H\n\n"}
{"name":"IntermediateField.linearDisjoint_comm'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝¹⁰ : Field F\ninst✝⁹ : Field E\ninst✝⁸ : Algebra F E\nL : Type w\ninst✝⁷ : Field L\ninst✝⁶ : Algebra F L\ninst✝⁵ : Algebra L E\ninst✝⁴ : IsScalarTower F L E\nL' : Type u_1\ninst✝³ : Field L'\ninst✝² : Algebra F L'\ninst✝¹ : Algebra L' E\ninst✝ : IsScalarTower F L' E\n⊢ Iff ((IsScalarTower.toAlgHom F L E).fieldRange.LinearDisjoint L') ((IsScalarTower.toAlgHom F L' E).fieldRange.LinearDisjoint L)","decl":"/-- Linear disjointness is symmetric. -/\ntheorem linearDisjoint_comm' :\n    (IsScalarTower.toAlgHom F L E).fieldRange.LinearDisjoint L' ↔\n    (IsScalarTower.toAlgHom F L' E).fieldRange.LinearDisjoint L :=\n  ⟨LinearDisjoint.symm', LinearDisjoint.symm'⟩\n\n"}
{"name":"IntermediateField.LinearDisjoint.map","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\nK : Type u_1\ninst✝¹ : Field K\ninst✝ : Algebra F K\nf : AlgHom F E K\n⊢ (IntermediateField.map f A).LinearDisjoint (Subtype fun x => Membership.mem (IntermediateField.map f B) x)","decl":"/-- Linear disjointness of intermediate fields is preserved by algebra homomorphisms. -/\ntheorem map (H : A.LinearDisjoint B) {K : Type*} [Field K] [Algebra F K]\n    (f : E →ₐ[F] K) : (A.map f).LinearDisjoint (B.map f) :=\n  linearDisjoint_iff'.2 ((linearDisjoint_iff'.1 H).map f f.injective)\n\n"}
{"name":"IntermediateField.LinearDisjoint.map'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝¹³ : Field F\ninst✝¹² : Field E\ninst✝¹¹ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝¹⁰ : Field L\ninst✝⁹ : Algebra F L\ninst✝⁸ : Algebra L E\ninst✝⁷ : IsScalarTower F L E\nH : A.LinearDisjoint L\nK : Type u_1\ninst✝⁶ : Field K\ninst✝⁵ : Algebra F K\ninst✝⁴ : Algebra L K\ninst✝³ : IsScalarTower F L K\ninst✝² : Algebra E K\ninst✝¹ : IsScalarTower F E K\ninst✝ : IsScalarTower L E K\n⊢ (IntermediateField.map (IsScalarTower.toAlgHom F E K) A).LinearDisjoint L","decl":"/-- Linear disjointness of an intermediate field with a tower of field embeddings is preserved by\nalgebra homomorphisms. -/\ntheorem map' (H : A.LinearDisjoint L) (K : Type*) [Field K] [Algebra F K] [Algebra L K]\n    [IsScalarTower F L K] [Algebra E K] [IsScalarTower F E K] [IsScalarTower L E K] :\n    (A.map (IsScalarTower.toAlgHom F E K)).LinearDisjoint L := by\n  rw [linearDisjoint_iff] at H ⊢\n  have := H.map (IsScalarTower.toAlgHom F E K) (RingHom.injective _)\n  rw [← AlgHom.range_comp] at this\n  convert this\n  ext; exact IsScalarTower.algebraMap_apply L E K _\n\n"}
{"name":"IntermediateField.LinearDisjoint.map''","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝²⁰ : Field F\ninst✝¹⁹ : Field E\ninst✝¹⁸ : Algebra F E\nL : Type w\ninst✝¹⁷ : Field L\ninst✝¹⁶ : Algebra F L\ninst✝¹⁵ : Algebra L E\ninst✝¹⁴ : IsScalarTower F L E\nL' : Type u_1\ninst✝¹³ : Field L'\ninst✝¹² : Algebra F L'\ninst✝¹¹ : Algebra L' E\ninst✝¹⁰ : IsScalarTower F L' E\nH : (IsScalarTower.toAlgHom F L E).fieldRange.LinearDisjoint L'\nK : Type u_2\ninst✝⁹ : Field K\ninst✝⁸ : Algebra F K\ninst✝⁷ : Algebra L K\ninst✝⁶ : IsScalarTower F L K\ninst✝⁵ : Algebra L' K\ninst✝⁴ : IsScalarTower F L' K\ninst✝³ : Algebra E K\ninst✝² : IsScalarTower F E K\ninst✝¹ : IsScalarTower L E K\ninst✝ : IsScalarTower L' E K\n⊢ (IsScalarTower.toAlgHom F L K).fieldRange.LinearDisjoint L'","decl":"/-- Linear disjointness is preserved by algebra homomorphism. -/\ntheorem map'' {L' : Type*} [Field L'] [Algebra F L'] [Algebra L' E] [IsScalarTower F L' E]\n    (H : (IsScalarTower.toAlgHom F L E).fieldRange.LinearDisjoint L')\n    (K : Type*) [Field K] [Algebra F K] [Algebra L K] [IsScalarTower F L K]\n    [Algebra L' K] [IsScalarTower F L' K] [Algebra E K] [IsScalarTower F E K]\n    [IsScalarTower L E K] [IsScalarTower L' E K] :\n    (IsScalarTower.toAlgHom F L K).fieldRange.LinearDisjoint L' := by\n  rw [linearDisjoint_iff] at H ⊢\n  have := H.map (IsScalarTower.toAlgHom F E K) (RingHom.injective _)\n  simp_rw [AlgHom.fieldRange_toSubalgebra, ← AlgHom.range_comp] at this\n  rw [AlgHom.fieldRange_toSubalgebra]\n  convert this <;> (ext; exact IsScalarTower.algebraMap_apply _ E K _)\n\n"}
{"name":"IntermediateField.LinearDisjoint.self_right","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA : IntermediateField F E\n⊢ A.LinearDisjoint F","decl":"variable (A) in\ntheorem self_right : A.LinearDisjoint F := Subalgebra.LinearDisjoint.bot_right _\n\n"}
{"name":"IntermediateField.LinearDisjoint.bot_right","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA : IntermediateField F E\n⊢ A.LinearDisjoint (Subtype fun x => Membership.mem Bot.bot x)","decl":"variable (A) in\ntheorem bot_right : A.LinearDisjoint (⊥ : IntermediateField F E) :=\n  linearDisjoint_iff'.2 (Subalgebra.LinearDisjoint.bot_right _)\n\n"}
{"name":"IntermediateField.LinearDisjoint.bot_left","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\n⊢ Bot.bot.LinearDisjoint L","decl":"variable (F E L) in\ntheorem bot_left : (⊥ : IntermediateField F E).LinearDisjoint L :=\n  Subalgebra.LinearDisjoint.bot_left _\n\n"}
{"name":"IntermediateField.LinearDisjoint.linearIndependent_left","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : A.LinearDisjoint L\nι : Type u_1\na : ι → Subtype fun x => Membership.mem A x\nha : LinearIndependent F a\n⊢ LinearIndependent L (Function.comp (⇑A.val) a)","decl":"/-- If `A` and `L` are linearly disjoint, then any `F`-linearly independent family on `A` remains\nlinearly independent over `L`. -/\ntheorem linearIndependent_left (H : A.LinearDisjoint L)\n    {ι : Type*} {a : ι → A} (ha : LinearIndependent F a) : LinearIndependent L (A.val ∘ a) :=\n  (Subalgebra.LinearDisjoint.linearIndependent_left_of_flat H ha).map_of_injective_injective\n    (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)) (AddMonoidHom.id E)\n    (by simp) (by simp) (fun _ _ ↦ by simp_rw [Algebra.smul_def]; rfl)\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_basis_left","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nι : Type u_1\na : Basis ι F (Subtype fun x => Membership.mem A x)\nH : LinearIndependent L (Function.comp ⇑A.val ⇑a)\n⊢ A.LinearDisjoint L","decl":"/-- If there exists an `F`-basis of `A` which remains linearly independent over `L`, then\n`A` and `L` are linearly disjoint. -/\ntheorem of_basis_left {ι : Type*} (a : Basis ι F A)\n    (H : LinearIndependent L (A.val ∘ a)) : A.LinearDisjoint L :=\n  Subalgebra.LinearDisjoint.of_basis_left _ _ a <| H.map_of_surjective_injective\n    (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)) (AddMonoidHom.id E)\n    (AlgEquiv.surjective _) (by simp) (fun _ _ ↦ by simp_rw [Algebra.smul_def]; rfl)\n\n"}
{"name":"IntermediateField.LinearDisjoint.linearIndependent_right","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\nι : Type u_1\nb : ι → Subtype fun x => Membership.mem B x\nhb : LinearIndependent F b\n⊢ LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp (⇑B.val) b)","decl":"/-- If `A` and `B` are linearly disjoint, then any `F`-linearly independent family on `B` remains\nlinearly independent over `A`. -/\ntheorem linearIndependent_right (H : A.LinearDisjoint B)\n    {ι : Type*} {b : ι → B} (hb : LinearIndependent F b) : LinearIndependent A (B.val ∘ b) :=\n  (linearDisjoint_iff'.1 H).linearIndependent_right_of_flat hb\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_basis_right","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nι : Type u_1\nb : Basis ι F (Subtype fun x => Membership.mem B x)\nH : LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp ⇑B.val ⇑b)\n⊢ A.LinearDisjoint (Subtype fun x => Membership.mem B x)","decl":"/-- If there exists an `F`-basis of `B` which remains linearly independent over `A`, then\n`A` and `B` are linearly disjoint. -/\ntheorem of_basis_right {ι : Type*} (b : Basis ι F B)\n    (H : LinearIndependent A (B.val ∘ b)) : A.LinearDisjoint B :=\n  linearDisjoint_iff'.2 (.of_basis_right _ _ b H)\n\n"}
{"name":"IntermediateField.LinearDisjoint.linearIndependent_right'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : A.LinearDisjoint L\nι : Type u_1\nb : ι → L\nhb : LinearIndependent F b\n⊢ LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp (⇑(algebraMap L E)) b)","decl":"/-- If `A` and `L` are linearly disjoint, then any `F`-linearly independent family on `L` remains\nlinearly independent over `A`. -/\ntheorem linearIndependent_right' (H : A.LinearDisjoint L) {ι : Type*} {b : ι → L}\n    (hb : LinearIndependent F b) : LinearIndependent A (algebraMap L E ∘ b) := by\n  apply Subalgebra.LinearDisjoint.linearIndependent_right_of_flat H <| hb.map' _\n    (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)).toLinearEquiv.ker\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_basis_right'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nι : Type u_1\nb : Basis ι F L\nH : LinearIndependent (Subtype fun x => Membership.mem A x) (Function.comp ⇑(algebraMap L E) ⇑b)\n⊢ A.LinearDisjoint L","decl":"/-- If there exists an `F`-basis of `L` which remains linearly independent over `A`, then\n`A` and `L` are linearly disjoint. -/\ntheorem of_basis_right' {ι : Type*} (b : Basis ι F L)\n    (H : LinearIndependent A (algebraMap L E ∘ b)) : A.LinearDisjoint L :=\n  Subalgebra.LinearDisjoint.of_basis_right _ _\n    (b.map (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)).toLinearEquiv) H\n\n"}
{"name":"IntermediateField.LinearDisjoint.linearIndependent_mul","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\nκ : Type u_1\nι : Type u_2\na : κ → Subtype fun x => Membership.mem A x\nb : ι → Subtype fun x => Membership.mem B x\nha : LinearIndependent F a\nhb : LinearIndependent F b\n⊢ LinearIndependent F fun i => HMul.hMul ↑(a i.1) ↑(b i.2)","decl":"/-- If `A` and `B` are linearly disjoint, then for any `F`-linearly independent families\n`{ u_i }`, `{ v_j }` of `A`, `B`, the products `{ u_i * v_j }`\nare linearly independent over `F`. -/\ntheorem linearIndependent_mul (H : A.LinearDisjoint B) {κ ι : Type*} {a : κ → A} {b : ι → B}\n    (ha : LinearIndependent F a) (hb : LinearIndependent F b) :\n    LinearIndependent F fun (i : κ × ι) ↦ (a i.1).1 * (b i.2).1 :=\n  (linearDisjoint_iff'.1 H).linearIndependent_mul_of_flat_left ha hb\n\n"}
{"name":"IntermediateField.LinearDisjoint.linearIndependent_mul'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : A.LinearDisjoint L\nκ : Type u_1\nι : Type u_2\na : κ → Subtype fun x => Membership.mem A x\nb : ι → L\nha : LinearIndependent F a\nhb : LinearIndependent F b\n⊢ LinearIndependent F fun i => HMul.hMul (↑(a i.1)) ((algebraMap L E) (b i.2))","decl":"/-- If `A` and `L` are linearly disjoint, then for any `F`-linearly independent families\n`{ u_i }`, `{ v_j }` of `A`, `L`, the products `{ u_i * v_j }`\nare linearly independent over `F`. -/\ntheorem linearIndependent_mul' (H : A.LinearDisjoint L) {κ ι : Type*} {a : κ → A} {b : ι → L}\n    (ha : LinearIndependent F a) (hb : LinearIndependent F b) :\n    LinearIndependent F fun (i : κ × ι) ↦ (a i.1).1 * algebraMap L E (b i.2) := by\n  apply Subalgebra.LinearDisjoint.linearIndependent_mul_of_flat_left H ha <| hb.map' _\n    (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)).toLinearEquiv.ker\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_basis_mul","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nκ : Type u_1\nι : Type u_2\na : Basis κ F (Subtype fun x => Membership.mem A x)\nb : Basis ι F (Subtype fun x => Membership.mem B x)\nH : LinearIndependent F fun i => HMul.hMul ↑(a i.1) ↑(b i.2)\n⊢ A.LinearDisjoint (Subtype fun x => Membership.mem B x)","decl":"/-- If there are `F`-bases `{ u_i }`, `{ v_j }` of `A`, `B`, such that the products\n`{ u_i * v_j }` are linearly independent over `F`, then `A` and `B` are linearly disjoint. -/\ntheorem of_basis_mul {κ ι : Type*} (a : Basis κ F A) (b : Basis ι F B)\n    (H : LinearIndependent F fun (i : κ × ι) ↦ (a i.1).1 * (b i.2).1) : A.LinearDisjoint B :=\n  linearDisjoint_iff'.2 (.of_basis_mul _ _ a b H)\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_basis_mul'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nκ : Type u_1\nι : Type u_2\na : Basis κ F (Subtype fun x => Membership.mem A x)\nb : Basis ι F L\nH : LinearIndependent F fun i => HMul.hMul (↑(a i.1)) ((algebraMap L E) (b i.2))\n⊢ A.LinearDisjoint L","decl":"/-- If there are `F`-bases `{ u_i }`, `{ v_j }` of `A`, `L`, such that the products\n`{ u_i * v_j }` are linearly independent over `F`, then `A` and `L` are linearly disjoint. -/\ntheorem of_basis_mul' {κ ι : Type*} (a : Basis κ F A) (b : Basis ι F L)\n    (H : LinearIndependent F fun (i : κ × ι) ↦ (a i.1).1 * algebraMap L E (b i.2)) :\n    A.LinearDisjoint L :=\n  Subalgebra.LinearDisjoint.of_basis_mul _ _ a\n    (b.map (AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)).toLinearEquiv) H\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_le_left","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nA' : IntermediateField F E\nH : A.LinearDisjoint L\nh : LE.le A' A\n⊢ A'.LinearDisjoint L","decl":"theorem of_le_left {A' : IntermediateField F E} (H : A.LinearDisjoint L)\n    (h : A' ≤ A) : A'.LinearDisjoint L :=\n  Subalgebra.LinearDisjoint.of_le_left_of_flat H h\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_le_right","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B B' : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\nh : LE.le B' B\n⊢ A.LinearDisjoint (Subtype fun x => Membership.mem B' x)","decl":"theorem of_le_right {B' : IntermediateField F E} (H : A.LinearDisjoint B)\n    (h : B' ≤ B) : A.LinearDisjoint B' :=\n  linearDisjoint_iff'.2 ((linearDisjoint_iff'.1 H).of_le_right_of_flat h)\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_le_right'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝¹³ : Field F\ninst✝¹² : Field E\ninst✝¹¹ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝¹⁰ : Field L\ninst✝⁹ : Algebra F L\ninst✝⁸ : Algebra L E\ninst✝⁷ : IsScalarTower F L E\nH : A.LinearDisjoint L\nL' : Type u_1\ninst✝⁶ : Field L'\ninst✝⁵ : Algebra F L'\ninst✝⁴ : Algebra L' L\ninst✝³ : IsScalarTower F L' L\ninst✝² : Algebra L' E\ninst✝¹ : IsScalarTower F L' E\ninst✝ : IsScalarTower L' L E\n⊢ A.LinearDisjoint L'","decl":"/-- Similar to `IntermediateField.LinearDisjoint.of_le_right` but this is for abstract fields. -/\ntheorem of_le_right' (H : A.LinearDisjoint L) (L' : Type*) [Field L']\n    [Algebra F L'] [Algebra L' L] [IsScalarTower F L' L]\n    [Algebra L' E] [IsScalarTower F L' E] [IsScalarTower L' L E] : A.LinearDisjoint L' := by\n  refine Subalgebra.LinearDisjoint.of_le_right_of_flat H ?_\n  convert AlgHom.range_comp_le_range (IsScalarTower.toAlgHom F L' L) (IsScalarTower.toAlgHom F L E)\n  ext; exact IsScalarTower.algebraMap_apply L' L E _\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_le","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B A' B' : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\nhA : LE.le A' A\nhB : LE.le B' B\n⊢ A'.LinearDisjoint (Subtype fun x => Membership.mem B' x)","decl":"/-- If `A` and `B` are linearly disjoint, `A'` and `B'` are contained in `A` and `B`,\nrespectively, then `A'` and `B'` are also linearly disjoint. -/\ntheorem of_le {A' B' : IntermediateField F E} (H : A.LinearDisjoint B)\n    (hA : A' ≤ A) (hB : B' ≤ B) : A'.LinearDisjoint B' :=\n  H.of_le_left hA |>.of_le_right hB\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_le'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝¹³ : Field F\ninst✝¹² : Field E\ninst✝¹¹ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝¹⁰ : Field L\ninst✝⁹ : Algebra F L\ninst✝⁸ : Algebra L E\ninst✝⁷ : IsScalarTower F L E\nA' : IntermediateField F E\nH : A.LinearDisjoint L\nhA : LE.le A' A\nL' : Type u_1\ninst✝⁶ : Field L'\ninst✝⁵ : Algebra F L'\ninst✝⁴ : Algebra L' L\ninst✝³ : IsScalarTower F L' L\ninst✝² : Algebra L' E\ninst✝¹ : IsScalarTower F L' E\ninst✝ : IsScalarTower L' L E\n⊢ A'.LinearDisjoint L'","decl":"/-- Similar to `IntermediateField.LinearDisjoint.of_le` but this is for abstract fields. -/\ntheorem of_le' {A' : IntermediateField F E} (H : A.LinearDisjoint L)\n    (hA : A' ≤ A) (L' : Type*) [Field L']\n    [Algebra F L'] [Algebra L' L] [IsScalarTower F L' L]\n    [Algebra L' E] [IsScalarTower F L' E] [IsScalarTower L' L E] : A'.LinearDisjoint L' :=\n  H.of_le_left hA |>.of_le_right' L'\n\n"}
{"name":"IntermediateField.LinearDisjoint.inf_eq_bot","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\n⊢ Eq (Min.min A B) Bot.bot","decl":"/-- If `A` and `B` are linearly disjoint over `F`, then their intersection is equal to `F`. -/\ntheorem inf_eq_bot (H : A.LinearDisjoint B) :\n    A ⊓ B = ⊥ := toSubalgebra_injective (linearDisjoint_iff'.1 H).inf_eq_bot\n\n"}
{"name":"IntermediateField.LinearDisjoint.eq_bot_of_self","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem A x)\n⊢ Eq A Bot.bot","decl":"/-- If `A` and `A` itself are linearly disjoint over `F`, then it is equal to `F`. -/\ntheorem eq_bot_of_self (H : A.LinearDisjoint A) : A = ⊥ :=\n  inf_idem A ▸ H.inf_eq_bot\n\n"}
{"name":"IntermediateField.LinearDisjoint.rank_sup","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\n⊢ Eq (Module.rank F (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.rank F (Subtype fun x => Membership.mem A x)) (Module.rank F (Subtype fun x => Membership.mem B x)))","decl":"/-- If `A` and `B` are linearly disjoint over `F`, then the\nrank of `A ⊔ B` is equal to the product of that of `A` and `B`. -/\ntheorem rank_sup (H : A.LinearDisjoint B) :\n    Module.rank F ↥(A ⊔ B) = Module.rank F A * Module.rank F B :=\n  have h := le_sup_toSubalgebra A B\n  (rank_sup_le A B).antisymm <|\n    (linearDisjoint_iff'.1 H).rank_sup_of_free.ge.trans <|\n      (Subalgebra.inclusion h).toLinearMap.rank_le_of_injective (Subalgebra.inclusion_injective h)\n\n"}
{"name":"IntermediateField.LinearDisjoint.finrank_sup","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝² : Field F\ninst✝¹ : Field E\ninst✝ : Algebra F E\nA B : IntermediateField F E\nH : A.LinearDisjoint (Subtype fun x => Membership.mem B x)\n⊢ Eq (Module.finrank F (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.finrank F (Subtype fun x => Membership.mem A x)) (Module.finrank F (Subtype fun x => Membership.mem B x)))","decl":"/-- If `A` and `B` are linearly disjoint over `F`, then the `Module.finrank` of\n`A ⊔ B` is equal to the product of that of `A` and `B`. -/\ntheorem finrank_sup (H : A.LinearDisjoint B) : finrank F ↥(A ⊔ B) = finrank F A * finrank F B := by\n  simpa only [map_mul] using congr(Cardinal.toNat $(H.rank_sup))\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_finrank_sup","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁴ : Field F\ninst✝³ : Field E\ninst✝² : Algebra F E\nA B : IntermediateField F E\ninst✝¹ : FiniteDimensional F (Subtype fun x => Membership.mem A x)\ninst✝ : FiniteDimensional F (Subtype fun x => Membership.mem B x)\nH : Eq (Module.finrank F (Subtype fun x => Membership.mem (Max.max A B) x)) (HMul.hMul (Module.finrank F (Subtype fun x => Membership.mem A x)) (Module.finrank F (Subtype fun x => Membership.mem B x)))\n⊢ A.LinearDisjoint (Subtype fun x => Membership.mem B x)","decl":"/-- If `A` and `B` are finite extensions of `F`,\nsuch that rank of `A ⊔ B` is equal to the product of the rank of `A` and `B`,\nthen `A` and `B` are linearly disjoint. -/\ntheorem of_finrank_sup [FiniteDimensional F A] [FiniteDimensional F B]\n    (H : finrank F ↥(A ⊔ B) = finrank F A * finrank F B) : A.LinearDisjoint B :=\n  linearDisjoint_iff'.2 <| .of_finrank_sup_of_free (by rwa [← sup_toSubalgebra_of_left])\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_finrank_coprime","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : (Module.finrank F (Subtype fun x => Membership.mem A x)).Coprime (Module.finrank F L)\n⊢ A.LinearDisjoint L","decl":"/-- If `A` and `L` have coprime degree over `F`, then they are linearly disjoint. -/\ntheorem of_finrank_coprime (H : (finrank F A).Coprime (finrank F L)) : A.LinearDisjoint L :=\n  letI : Field (AlgHom.range (IsScalarTower.toAlgHom F L E)) :=\n    inferInstanceAs <| Field (AlgHom.fieldRange (IsScalarTower.toAlgHom F L E))\n  letI : Field A.toSubalgebra := inferInstanceAs <| Field A\n  Subalgebra.LinearDisjoint.of_finrank_coprime_of_free <| by\n    rwa [(AlgEquiv.ofInjectiveField (IsScalarTower.toAlgHom F L E)).toLinearEquiv.finrank_eq] at H\n\n"}
{"name":"IntermediateField.LinearDisjoint.isDomain","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : A.LinearDisjoint L\n⊢ IsDomain (TensorProduct F (Subtype fun x => Membership.mem A x) L)","decl":"/-- If `A` and `L` are linearly disjoint over `F`, then `A ⊗[F] L` is a domain. -/\ntheorem isDomain (H : A.LinearDisjoint L) : IsDomain (A ⊗[F] L) :=\n  have : IsDomain (A ⊗[F] _) := Subalgebra.LinearDisjoint.isDomain H\n  (Algebra.TensorProduct.congr (AlgEquiv.refl : A ≃ₐ[F] A)\n    (AlgEquiv.ofInjective (IsScalarTower.toAlgHom F L E) (RingHom.injective _))).toMulEquiv.isDomain\n\n"}
{"name":"IntermediateField.LinearDisjoint.isDomain'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Algebra F A\ninst✝¹ : Field B\ninst✝ : Algebra F B\nfa : AlgHom F A E\nfb : AlgHom F B E\nH : fa.fieldRange.LinearDisjoint (Subtype fun x => Membership.mem fb.fieldRange x)\n⊢ IsDomain (TensorProduct F A B)","decl":"/-- If `A` and `B` are field extensions of `F`, there exists a field extension `E` of `F` that\n`A` and `B` embed into with linearly disjoint images, then `A ⊗[F] B` is a domain. -/\ntheorem isDomain' {A B : Type*} [Field A] [Algebra F A] [Field B] [Algebra F B]\n    {fa : A →ₐ[F] E} {fb : B →ₐ[F] E} (H : fa.fieldRange.LinearDisjoint fb.fieldRange) :\n    IsDomain (A ⊗[F] B) := by\n  simp_rw [linearDisjoint_iff', AlgHom.fieldRange_toSubalgebra] at H\n  exact H.isDomain_of_injective fa.injective fb.injective\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_isField","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : IsField (TensorProduct F (Subtype fun x => Membership.mem A x) L)\n⊢ A.LinearDisjoint L","decl":"/-- If `A ⊗[F] L` is a field, then `A` and `L` are linearly disjoint over `F`. -/\ntheorem of_isField (H : IsField (A ⊗[F] L)) : A.LinearDisjoint L := by\n  apply Subalgebra.LinearDisjoint.of_isField\n  -- need these otherwise the `exact` will stuck at typeclass\n  haveI : SMulCommClass F A A := SMulCommClass.of_commMonoid F A A\n  haveI : SMulCommClass F A.toSubalgebra A.toSubalgebra := ‹SMulCommClass F A A›\n  letI : Mul (A ⊗[F] L) := Algebra.TensorProduct.instMul\n  letI : Mul (A.toSubalgebra ⊗[F] (IsScalarTower.toAlgHom F L E).range) :=\n    Algebra.TensorProduct.instMul\n  exact Algebra.TensorProduct.congr (AlgEquiv.refl : A ≃ₐ[F] A)\n    (AlgEquiv.ofInjective (IsScalarTower.toAlgHom F L E) (RingHom.injective _))\n      |>.symm.toMulEquiv.isField _ H\n\n"}
{"name":"IntermediateField.LinearDisjoint.of_isField'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\ninst✝⁶ : Field F\nA : Type v\ninst✝⁵ : Field A\nB : Type w\ninst✝⁴ : Field B\ninst✝³ : Algebra F A\ninst✝² : Algebra F B\nH : IsField (TensorProduct F A B)\nK : Type u_1\ninst✝¹ : Field K\ninst✝ : Algebra F K\nfa : AlgHom F A K\nfb : AlgHom F B K\n⊢ fa.fieldRange.LinearDisjoint (Subtype fun x => Membership.mem fb.fieldRange x)","decl":"/-- If `A` and `B` are field extensions of `F`, such that `A ⊗[F] B` is a field, then for any\nfield extension of `F` that `A` and `B` embed into, their images are linearly disjoint. -/\ntheorem of_isField' {A : Type v} [Field A] {B : Type w} [Field B]\n    [Algebra F A] [Algebra F B] (H : IsField (A ⊗[F] B))\n    {K : Type*} [Field K] [Algebra F K] (fa : A →ₐ[F] K) (fb : B →ₐ[F] K) :\n    fa.fieldRange.LinearDisjoint fb.fieldRange := by\n  rw [linearDisjoint_iff']\n  apply Subalgebra.LinearDisjoint.of_isField\n  exact Algebra.TensorProduct.congr (AlgEquiv.ofInjective fa fa.injective)\n    (AlgEquiv.ofInjective fb fb.injective) |>.symm.toMulEquiv.isField _ H\n\n"}
{"name":"IntermediateField.LinearDisjoint.exists_field_of_isDomain","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\ninst✝⁵ : Field F\nA : Type v\ninst✝⁴ : Field A\nB : Type w\ninst✝³ : Field B\ninst✝² : Algebra F A\ninst✝¹ : Algebra F B\ninst✝ : IsDomain (TensorProduct F A B)\n⊢ Exists fun K => Exists fun x => Exists fun x_1 => Exists fun fa => Exists fun fb => fa.fieldRange.LinearDisjoint (Subtype fun x_2 => Membership.mem fb.fieldRange x_2)","decl":"variable (F) in\n/-- If `A` and `B` are field extensions of `F`, such that `A ⊗[F] B` is a domain, then there exists\na field extension of `F` that `A` and `B` embed into with linearly disjoint images. -/\ntheorem exists_field_of_isDomain (A : Type v) [Field A] (B : Type w) [Field B]\n    [Algebra F A] [Algebra F B] [IsDomain (A ⊗[F] B)] :\n    ∃ (K : Type (max v w)) (_ : Field K) (_ : Algebra F K) (fa : A →ₐ[F] K) (fb : B →ₐ[F] K),\n    fa.fieldRange.LinearDisjoint fb.fieldRange :=\n  have ⟨K, inst1, inst2, fa, fb, _, _, H⟩ :=\n    Subalgebra.LinearDisjoint.exists_field_of_isDomain_of_injective F A B\n      (RingHom.injective _) (RingHom.injective _)\n  ⟨K, inst1, inst2, fa, fb, linearDisjoint_iff'.2 H⟩\n\n"}
{"name":"IntermediateField.LinearDisjoint.isField_of_forall","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\ninst✝⁴ : Field F\nA : Type v\ninst✝³ : Field A\nB : Type w\ninst✝² : Field B\ninst✝¹ : Algebra F A\ninst✝ : Algebra F B\nH : ∀ (K : Type (max v w)) [inst : Field K] [inst_1 : Algebra F K] (fa : AlgHom F A K) (fb : AlgHom F B K), fa.fieldRange.LinearDisjoint (Subtype fun x => Membership.mem fb.fieldRange x)\n⊢ IsField (TensorProduct F A B)","decl":"variable (F) in\n/-- If for any field extension `K` of `F` that `A` and `B` embed into, their images are\nlinearly disjoint, then `A ⊗[F] B` is a field. (In the proof we choose `K` to be the quotient\nof `A ⊗[F] B` by a maximal ideal.) -/\ntheorem isField_of_forall (A : Type v) [Field A] (B : Type w) [Field B]\n    [Algebra F A] [Algebra F B]\n    (H : ∀ (K : Type (max v w)) [Field K] [Algebra F K],\n      ∀ (fa : A →ₐ[F] K) (fb : B →ₐ[F] K), fa.fieldRange.LinearDisjoint fb.fieldRange) :\n    IsField (A ⊗[F] B) := by\n  obtain ⟨M, hM⟩ := Ideal.exists_maximal (A ⊗[F] B)\n  apply not_imp_not.1 (Ring.ne_bot_of_isMaximal_of_not_isField hM)\n  let K : Type (max v w) := A ⊗[F] B ⧸ M\n  letI : Field K := Ideal.Quotient.field _\n  let i := IsScalarTower.toAlgHom F (A ⊗[F] B) K\n  let fa := i.comp (Algebra.TensorProduct.includeLeft : A →ₐ[F] _)\n  let fb := i.comp (Algebra.TensorProduct.includeRight : B →ₐ[F] _)\n  replace H := H K fa fb\n  simp_rw [linearDisjoint_iff', AlgHom.fieldRange_toSubalgebra,\n    Subalgebra.linearDisjoint_iff_injective] at H\n  have hi : i = (fa.range.mulMap fb.range).comp (Algebra.TensorProduct.congr\n      (AlgEquiv.ofInjective fa fa.injective) (AlgEquiv.ofInjective fb fb.injective)) := by\n    ext <;> simp [fa, fb]\n  replace H : Function.Injective i := by simpa [hi]\n  change Function.Injective (Ideal.Quotient.mk M) at H\n  rwa [RingHom.injective_iff_ker_eq_bot, Ideal.mk_ker] at H\n\n"}
{"name":"Algebra.TensorProduct.isField_of_isAlgebraic","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁵ : Field F\ninst✝⁴ : Field E\ninst✝³ : Algebra F E\nK : Type u_1\ninst✝² : Field K\ninst✝¹ : Algebra F K\ninst✝ : IsDomain (TensorProduct F E K)\nhalg : Or (Algebra.IsAlgebraic F E) (Algebra.IsAlgebraic F K)\n⊢ IsField (TensorProduct F E K)","decl":"variable (F E) in\n/-- If `E` and `K` are field extensions of `F`, one of them is algebraic, such that\n`E ⊗[F] K` is a domain, then `E ⊗[F] K` is also a field. It is a corollary of\n`Subalgebra.LinearDisjoint.exists_field_of_isDomain_of_injective` and\n`IntermediateField.sup_toSubalgebra_of_isAlgebraic`.\nSee `Algebra.TensorProduct.isAlgebraic_of_isField` for its converse (in an earlier file). -/\ntheorem _root_.Algebra.TensorProduct.isField_of_isAlgebraic\n    (K : Type*) [Field K] [Algebra F K] [IsDomain (E ⊗[F] K)]\n    (halg : Algebra.IsAlgebraic F E ∨ Algebra.IsAlgebraic F K) : IsField (E ⊗[F] K) :=\n  have ⟨L, _, _, fa, fb, hfa, hfb, H⟩ :=\n    Subalgebra.LinearDisjoint.exists_field_of_isDomain_of_injective F E K\n      (RingHom.injective _) (RingHom.injective _)\n  let f : E ⊗[F] K ≃ₐ[F] ↥(fa.fieldRange ⊔ fb.fieldRange) :=\n    Algebra.TensorProduct.congr (AlgEquiv.ofInjective fa hfa) (AlgEquiv.ofInjective fb hfb)\n    |>.trans (Subalgebra.LinearDisjoint.mulMap H)\n    |>.trans (Subalgebra.equivOfEq _ _\n      (sup_toSubalgebra_of_isAlgebraic fa.fieldRange fb.fieldRange <| by\n        rwa [(AlgEquiv.ofInjective fa hfa).isAlgebraic_iff,\n          (AlgEquiv.ofInjective fb hfb).isAlgebraic_iff] at halg).symm)\n  f.toMulEquiv.isField _ (Field.toIsField _)\n\n"}
{"name":"IntermediateField.LinearDisjoint.isField_of_isAlgebraic","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝³ : Field L\ninst✝² : Algebra F L\ninst✝¹ : Algebra L E\ninst✝ : IsScalarTower F L E\nH : A.LinearDisjoint L\nhalg : Or (Algebra.IsAlgebraic F (Subtype fun x => Membership.mem A x)) (Algebra.IsAlgebraic F L)\n⊢ IsField (TensorProduct F (Subtype fun x => Membership.mem A x) L)","decl":"/-- If `A` and `L` are linearly disjoint over `F` and one of them is algebraic,\nthen `A ⊗[F] L` is a field. -/\ntheorem isField_of_isAlgebraic (H : A.LinearDisjoint L)\n    (halg : Algebra.IsAlgebraic F A ∨ Algebra.IsAlgebraic F L) : IsField (A ⊗[F] L) :=\n  have := H.isDomain\n  Algebra.TensorProduct.isField_of_isAlgebraic F A L halg\n\n"}
{"name":"IntermediateField.LinearDisjoint.isField_of_isAlgebraic'","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝⁶ : Field F\ninst✝⁵ : Field E\ninst✝⁴ : Algebra F E\nA : Type u_1\nB : Type u_2\ninst✝³ : Field A\ninst✝² : Algebra F A\ninst✝¹ : Field B\ninst✝ : Algebra F B\nfa : AlgHom F A E\nfb : AlgHom F B E\nH : fa.fieldRange.LinearDisjoint (Subtype fun x => Membership.mem fb.fieldRange x)\nhalg : Or (Algebra.IsAlgebraic F A) (Algebra.IsAlgebraic F B)\n⊢ IsField (TensorProduct F A B)","decl":"/-- If `A` and `B` are field extensions of `F`, one of them is algebraic, such that there exists a\nfield `E` that `A` and `B` embeds into with linearly disjoint images, then `A ⊗[F] B`\nis a field. -/\ntheorem isField_of_isAlgebraic' {A B : Type*} [Field A] [Algebra F A] [Field B] [Algebra F B]\n    {fa : A →ₐ[F] E} {fb : B →ₐ[F] E} (H : fa.fieldRange.LinearDisjoint fb.fieldRange)\n    (halg : Algebra.IsAlgebraic F A ∨ Algebra.IsAlgebraic F B) : IsField (A ⊗[F] B) :=\n  have := H.isDomain'\n  Algebra.TensorProduct.isField_of_isAlgebraic F A B halg\n\n"}
{"name":"IntermediateField.LinearDisjoint.algEquiv_of_isAlgebraic","module":"Mathlib.FieldTheory.LinearDisjoint","initialProofState":"F : Type u\nE : Type v\ninst✝¹² : Field F\ninst✝¹¹ : Field E\ninst✝¹⁰ : Algebra F E\nA : IntermediateField F E\nL : Type w\ninst✝⁹ : Field L\ninst✝⁸ : Algebra F L\ninst✝⁷ : Algebra L E\ninst✝⁶ : IsScalarTower F L E\nH : A.LinearDisjoint L\nE' : Type u_1\ninst✝⁵ : Field E'\ninst✝⁴ : Algebra F E'\nB : IntermediateField F E'\nL' : Type u_2\ninst✝³ : Field L'\ninst✝² : Algebra F L'\ninst✝¹ : Algebra L' E'\ninst✝ : IsScalarTower F L' E'\nf1 : AlgEquiv F (Subtype fun x => Membership.mem A x) (Subtype fun x => Membership.mem B x)\nf2 : AlgEquiv F L L'\nhalg : Or (Algebra.IsAlgebraic F (Subtype fun x => Membership.mem A x)) (Algebra.IsAlgebraic F L)\n⊢ B.LinearDisjoint L'","decl":"/-- If `A` and `L` are linearly disjoint, one of them is algebraic, then for any `B` and `L'`\nisomorphic to `A` and `L` respectively, `B` and `L'` are also linearly disjoint. -/\ntheorem algEquiv_of_isAlgebraic (H : A.LinearDisjoint L)\n    {E' : Type*} [Field E'] [Algebra F E']\n    (B : IntermediateField F E')\n    (L' : Type*) [Field L'] [Algebra F L'] [Algebra L' E'] [IsScalarTower F L' E']\n    (f1 : A ≃ₐ[F] B) (f2 : L ≃ₐ[F] L')\n    (halg : Algebra.IsAlgebraic F A ∨ Algebra.IsAlgebraic F L) :\n    B.LinearDisjoint L' :=\n  .of_isField ((Algebra.TensorProduct.congr f1 f2).symm.toMulEquiv.isField _\n    (H.isField_of_isAlgebraic halg))\n\n"}
