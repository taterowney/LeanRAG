{"name":"Orientation.rotationAux_apply","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nx : V\n⊢ Eq ((o.rotationAux θ) x) (HAdd.hAdd (HSMul.hSMul θ.cos x) (HSMul.hSMul θ.sin (o.rightAngleRotation x)))","decl":"@[simp]\ntheorem rotationAux_apply (θ : Real.Angle) (x : V) :\n    o.rotationAux θ x = Real.Angle.cos θ • x + Real.Angle.sin θ • J x :=\n  rfl\n\n"}
{"name":"Orientation.rotation_apply","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nx : V\n⊢ Eq ((o.rotation θ) x) (HAdd.hAdd (HSMul.hSMul θ.cos x) (HSMul.hSMul θ.sin (o.rightAngleRotation x)))","decl":"theorem rotation_apply (θ : Real.Angle) (x : V) :\n    o.rotation θ x = Real.Angle.cos θ • x + Real.Angle.sin θ • J x :=\n  rfl\n\n"}
{"name":"Orientation.rotation_symm_apply","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nx : V\n⊢ Eq ((o.rotation θ).symm x) (HSub.hSub (HSMul.hSMul θ.cos x) (HSMul.hSMul θ.sin (o.rightAngleRotation x)))","decl":"theorem rotation_symm_apply (θ : Real.Angle) (x : V) :\n    (o.rotation θ).symm x = Real.Angle.cos θ • x - Real.Angle.sin θ • J x :=\n  rfl\n\n"}
{"name":"Orientation.rotation_eq_matrix_toLin","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nx : V\nhx : Ne x 0\n⊢ Eq (↑(o.rotation θ).toLinearEquiv) ((Matrix.toLin (o.basisRightAngleRotation x hx) (o.basisRightAngleRotation x hx)) (Matrix.of (Matrix.vecCons (Matrix.vecCons θ.cos (Matrix.vecCons (Neg.neg θ.sin) Matrix.vecEmpty)) (Matrix.vecCons (Matrix.vecCons θ.sin (Matrix.vecCons θ.cos Matrix.vecEmpty)) Matrix.vecEmpty))))","decl":"theorem rotation_eq_matrix_toLin (θ : Real.Angle) {x : V} (hx : x ≠ 0) :\n    (o.rotation θ).toLinearMap =\n      Matrix.toLin (o.basisRightAngleRotation x hx) (o.basisRightAngleRotation x hx)\n        !![θ.cos, -θ.sin; θ.sin, θ.cos] := by\n  apply (o.basisRightAngleRotation x hx).ext\n  intro i\n  fin_cases i\n  · rw [Matrix.toLin_self]\n    simp [rotation_apply, Fin.sum_univ_succ]\n  · rw [Matrix.toLin_self]\n    simp [rotation_apply, Fin.sum_univ_succ, add_comm]\n\n"}
{"name":"Orientation.det_rotation","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\n⊢ Eq (LinearMap.det ↑(o.rotation θ).toLinearEquiv) 1","decl":"/-- The determinant of `rotation` (as a linear map) is equal to `1`. -/\n@[simp]\ntheorem det_rotation (θ : Real.Angle) : LinearMap.det (o.rotation θ).toLinearMap = 1 := by\n  haveI : Nontrivial V := nontrivial_of_finrank_eq_succ (@Fact.out (finrank ℝ V = 2) _)\n  obtain ⟨x, hx⟩ : ∃ x, x ≠ (0 : V) := exists_ne (0 : V)\n  rw [o.rotation_eq_matrix_toLin θ hx]\n  simpa [sq] using θ.cos_sq_add_sin_sq\n\n"}
{"name":"Orientation.linearEquiv_det_rotation","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\n⊢ Eq (LinearEquiv.det (o.rotation θ).toLinearEquiv) 1","decl":"/-- The determinant of `rotation` (as a linear equiv) is equal to `1`. -/\n@[simp]\ntheorem linearEquiv_det_rotation (θ : Real.Angle) :\n    LinearEquiv.det (o.rotation θ).toLinearEquiv = 1 :=\n  Units.ext <| by\n    -- Porting note: Lean can't see through `LinearEquiv.coe_det` and needed the rewrite\n    -- in mathlib3 this was just `units.ext <| o.det_rotation θ`\n    simpa only [LinearEquiv.coe_det, Units.val_one] using o.det_rotation θ\n\n"}
{"name":"Orientation.rotation_symm","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\n⊢ Eq (o.rotation θ).symm (o.rotation (Neg.neg θ))","decl":"/-- The inverse of `rotation` is rotation by the negation of the angle. -/\n@[simp]\ntheorem rotation_symm (θ : Real.Angle) : (o.rotation θ).symm = o.rotation (-θ) := by\n  ext; simp [o.rotation_apply, o.rotation_symm_apply, sub_eq_add_neg]\n\n"}
{"name":"Orientation.rotation_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\n⊢ Eq (o.rotation 0) (LinearIsometryEquiv.refl Real V)","decl":"/-- Rotation by 0 is the identity. -/\n@[simp]\ntheorem rotation_zero : o.rotation 0 = LinearIsometryEquiv.refl ℝ V := by ext; simp [rotation]\n\n"}
{"name":"Orientation.rotation_pi","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\n⊢ Eq (o.rotation ↑Real.pi) (LinearIsometryEquiv.neg Real)","decl":"/-- Rotation by π is negation. -/\n@[simp]\ntheorem rotation_pi : o.rotation π = LinearIsometryEquiv.neg ℝ := by\n  ext x\n  simp [rotation]\n\n"}
{"name":"Orientation.rotation_pi_apply","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq ((o.rotation ↑Real.pi) x) (Neg.neg x)","decl":"/-- Rotation by π is negation. -/\ntheorem rotation_pi_apply (x : V) : o.rotation π x = -x := by simp\n\n"}
{"name":"Orientation.rotation_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\n⊢ Eq (o.rotation ↑(HDiv.hDiv Real.pi 2)) o.rightAngleRotation","decl":"/-- Rotation by π / 2 is the \"right-angle-rotation\" map `J`. -/\ntheorem rotation_pi_div_two : o.rotation (π / 2 : ℝ) = J := by\n  ext x\n  simp [rotation]\n\n"}
{"name":"Orientation.rotation_rotation","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ₁ θ₂ : Real.Angle\nx : V\n⊢ Eq ((o.rotation θ₁) ((o.rotation θ₂) x)) ((o.rotation (HAdd.hAdd θ₁ θ₂)) x)","decl":"/-- Rotating twice is equivalent to rotating by the sum of the angles. -/\n@[simp]\ntheorem rotation_rotation (θ₁ θ₂ : Real.Angle) (x : V) :\n    o.rotation θ₁ (o.rotation θ₂ x) = o.rotation (θ₁ + θ₂) x := by\n  simp only [o.rotation_apply, Real.Angle.cos_add, Real.Angle.sin_add, LinearIsometryEquiv.map_add,\n    LinearIsometryEquiv.trans_apply, map_smul, rightAngleRotation_rightAngleRotation]\n  module\n\n"}
{"name":"Orientation.rotation_trans","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ₁ θ₂ : Real.Angle\n⊢ Eq ((o.rotation θ₁).trans (o.rotation θ₂)) (o.rotation (HAdd.hAdd θ₂ θ₁))","decl":"/-- Rotating twice is equivalent to rotating by the sum of the angles. -/\n@[simp]\ntheorem rotation_trans (θ₁ θ₂ : Real.Angle) :\n    (o.rotation θ₁).trans (o.rotation θ₂) = o.rotation (θ₂ + θ₁) :=\n  LinearIsometryEquiv.ext fun _ => by rw [← rotation_rotation, LinearIsometryEquiv.trans_apply]\n\n"}
{"name":"Orientation.kahler_rotation_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nθ : Real.Angle\n⊢ Eq ((o.kahler ((o.rotation θ) x)) y) (HMul.hMul ((starRingEnd Complex) ↑θ.toCircle) ((o.kahler x) y))","decl":"/-- Rotating the first of two vectors by `θ` scales their Kahler form by `cos θ - sin θ * I`. -/\n@[simp]\ntheorem kahler_rotation_left (x y : V) (θ : Real.Angle) :\n    o.kahler (o.rotation θ x) y = conj (θ.toCircle : ℂ) * o.kahler x y := by\n  -- Porting note: this needed the `Complex.conj_ofReal` instead of `RCLike.conj_ofReal`;\n  -- I believe this is because the respective coercions are no longer defeq, and\n  -- `Real.Angle.coe_toCircle` uses the `Complex` version.\n  simp only [o.rotation_apply, map_add, map_mul, LinearMap.map_smulₛₗ, RingHom.id_apply,\n    LinearMap.add_apply, LinearMap.smul_apply, real_smul, kahler_rightAngleRotation_left,\n    Real.Angle.coe_toCircle, Complex.conj_ofReal, conj_I]\n  ring\n\n"}
{"name":"Orientation.neg_rotation","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nx : V\n⊢ Eq (Neg.neg ((o.rotation θ) x)) ((o.rotation (HAdd.hAdd (↑Real.pi) θ)) x)","decl":"/-- Negating a rotation is equivalent to rotation by π plus the angle. -/\ntheorem neg_rotation (θ : Real.Angle) (x : V) : -o.rotation θ x = o.rotation (π + θ) x := by\n  rw [← o.rotation_pi_apply, rotation_rotation]\n\n"}
{"name":"Orientation.neg_rotation_neg_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (Neg.neg ((o.rotation ↑(HDiv.hDiv (Neg.neg Real.pi) 2)) x)) ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)","decl":"/-- Negating a rotation by -π / 2 is equivalent to rotation by π / 2. -/\n@[simp]\ntheorem neg_rotation_neg_pi_div_two (x : V) :\n    -o.rotation (-π / 2 : ℝ) x = o.rotation (π / 2 : ℝ) x := by\n  rw [neg_rotation, ← Real.Angle.coe_add, neg_div, ← sub_eq_add_neg, sub_half]\n\n"}
{"name":"Orientation.neg_rotation_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (Neg.neg ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)) ((o.rotation ↑(HDiv.hDiv (Neg.neg Real.pi) 2)) x)","decl":"/-- Negating a rotation by π / 2 is equivalent to rotation by -π / 2. -/\ntheorem neg_rotation_pi_div_two (x : V) : -o.rotation (π / 2 : ℝ) x = o.rotation (-π / 2 : ℝ) x :=\n  (neg_eq_iff_eq_neg.mp <| o.neg_rotation_neg_pi_div_two _).symm\n\n"}
{"name":"Orientation.kahler_rotation_left'","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nθ : Real.Angle\n⊢ Eq ((o.kahler ((o.rotation θ) x)) y) (HMul.hMul (↑(Neg.neg θ).toCircle) ((o.kahler x) y))","decl":"/-- Rotating the first of two vectors by `θ` scales their Kahler form by `cos (-θ) + sin (-θ) * I`.\n-/\ntheorem kahler_rotation_left' (x y : V) (θ : Real.Angle) :\n    o.kahler (o.rotation θ x) y = (-θ).toCircle * o.kahler x y := by\n  simp only [Real.Angle.toCircle_neg, Circle.coe_inv_eq_conj, kahler_rotation_left]\n\n"}
{"name":"Orientation.kahler_rotation_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nθ : Real.Angle\n⊢ Eq ((o.kahler x) ((o.rotation θ) y)) (HMul.hMul (↑θ.toCircle) ((o.kahler x) y))","decl":"/-- Rotating the second of two vectors by `θ` scales their Kahler form by `cos θ + sin θ * I`. -/\n@[simp]\ntheorem kahler_rotation_right (x y : V) (θ : Real.Angle) :\n    o.kahler x (o.rotation θ y) = θ.toCircle * o.kahler x y := by\n  simp only [o.rotation_apply, map_add, LinearMap.map_smulₛₗ, RingHom.id_apply, real_smul,\n    kahler_rightAngleRotation_right, Real.Angle.coe_toCircle]\n  ring\n\n"}
{"name":"Orientation.oangle_rotation_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\nθ : Real.Angle\n⊢ Eq (o.oangle ((o.rotation θ) x) y) (HSub.hSub (o.oangle x y) θ)","decl":"/-- Rotating the first vector by `θ` subtracts `θ` from the angle between two vectors. -/\n@[simp]\ntheorem oangle_rotation_left {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) :\n    o.oangle (o.rotation θ x) y = o.oangle x y - θ := by\n  simp only [oangle, o.kahler_rotation_left']\n  rw [Complex.arg_mul_coe_angle, Real.Angle.arg_toCircle]\n  · abel\n  · exact Circle.coe_ne_zero _\n  · exact o.kahler_ne_zero hx hy\n\n"}
{"name":"Orientation.oangle_rotation_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\nθ : Real.Angle\n⊢ Eq (o.oangle x ((o.rotation θ) y)) (HAdd.hAdd (o.oangle x y) θ)","decl":"/-- Rotating the second vector by `θ` adds `θ` to the angle between two vectors. -/\n@[simp]\ntheorem oangle_rotation_right {x y : V} (hx : x ≠ 0) (hy : y ≠ 0) (θ : Real.Angle) :\n    o.oangle x (o.rotation θ y) = o.oangle x y + θ := by\n  simp only [oangle, o.kahler_rotation_right]\n  rw [Complex.arg_mul_coe_angle, Real.Angle.arg_toCircle]\n  · abel\n  · exact Circle.coe_ne_zero _\n  · exact o.kahler_ne_zero hx hy\n\n"}
{"name":"Orientation.oangle_rotation_self_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nhx : Ne x 0\nθ : Real.Angle\n⊢ Eq (o.oangle ((o.rotation θ) x) x) (Neg.neg θ)","decl":"/-- The rotation of a vector by `θ` has an angle of `-θ` from that vector. -/\n@[simp]\ntheorem oangle_rotation_self_left {x : V} (hx : x ≠ 0) (θ : Real.Angle) :\n    o.oangle (o.rotation θ x) x = -θ := by simp [hx]\n\n"}
{"name":"Orientation.oangle_rotation_self_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nhx : Ne x 0\nθ : Real.Angle\n⊢ Eq (o.oangle x ((o.rotation θ) x)) θ","decl":"/-- A vector has an angle of `θ` from the rotation of that vector by `θ`. -/\n@[simp]\ntheorem oangle_rotation_self_right {x : V} (hx : x ≠ 0) (θ : Real.Angle) :\n    o.oangle x (o.rotation θ x) = θ := by simp [hx]\n\n"}
{"name":"Orientation.oangle_rotation_oangle_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle ((o.rotation (o.oangle x y)) x) y) 0","decl":"/-- Rotating the first vector by the angle between the two vectors results in an angle of 0. -/\n@[simp]\ntheorem oangle_rotation_oangle_left (x y : V) : o.oangle (o.rotation (o.oangle x y) x) y = 0 := by\n  by_cases hx : x = 0\n  · simp [hx]\n  · by_cases hy : y = 0\n    · simp [hy]\n    · simp [hx, hy]\n\n"}
{"name":"Orientation.oangle_rotation_oangle_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Eq (o.oangle y ((o.rotation (o.oangle x y)) x)) 0","decl":"/-- Rotating the first vector by the angle between the two vectors and swapping the vectors\nresults in an angle of 0. -/\n@[simp]\ntheorem oangle_rotation_oangle_right (x y : V) : o.oangle y (o.rotation (o.oangle x y) x) = 0 := by\n  rw [oangle_rev]\n  simp\n\n"}
{"name":"Orientation.oangle_rotation","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nθ : Real.Angle\n⊢ Eq (o.oangle ((o.rotation θ) x) ((o.rotation θ) y)) (o.oangle x y)","decl":"/-- Rotating both vectors by the same angle does not change the angle between those vectors. -/\n@[simp]\ntheorem oangle_rotation (x y : V) (θ : Real.Angle) :\n    o.oangle (o.rotation θ x) (o.rotation θ y) = o.oangle x y := by\n  by_cases hx : x = 0 <;> by_cases hy : y = 0 <;> simp [hx, hy]\n\n"}
{"name":"Orientation.rotation_eq_self_iff_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nhx : Ne x 0\nθ : Real.Angle\n⊢ Iff (Eq ((o.rotation θ) x) x) (Eq θ 0)","decl":"/-- A rotation of a nonzero vector equals that vector if and only if the angle is zero. -/\n@[simp]\ntheorem rotation_eq_self_iff_angle_eq_zero {x : V} (hx : x ≠ 0) (θ : Real.Angle) :\n    o.rotation θ x = x ↔ θ = 0 := by\n  constructor\n  · intro h\n    rw [eq_comm]\n    simpa [hx, h] using o.oangle_rotation_right hx hx θ\n  · intro h\n    simp [h]\n\n"}
{"name":"Orientation.eq_rotation_self_iff_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nhx : Ne x 0\nθ : Real.Angle\n⊢ Iff (Eq x ((o.rotation θ) x)) (Eq θ 0)","decl":"/-- A nonzero vector equals a rotation of that vector if and only if the angle is zero. -/\n@[simp]\ntheorem eq_rotation_self_iff_angle_eq_zero {x : V} (hx : x ≠ 0) (θ : Real.Angle) :\n    x = o.rotation θ x ↔ θ = 0 := by rw [← o.rotation_eq_self_iff_angle_eq_zero hx, eq_comm]\n\n"}
{"name":"Orientation.rotation_eq_self_iff","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nθ : Real.Angle\n⊢ Iff (Eq ((o.rotation θ) x) x) (Or (Eq x 0) (Eq θ 0))","decl":"/-- A rotation of a vector equals that vector if and only if the vector or the angle is zero. -/\ntheorem rotation_eq_self_iff (x : V) (θ : Real.Angle) : o.rotation θ x = x ↔ x = 0 ∨ θ = 0 := by\n  by_cases h : x = 0 <;> simp [h]\n\n"}
{"name":"Orientation.eq_rotation_self_iff","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nθ : Real.Angle\n⊢ Iff (Eq x ((o.rotation θ) x)) (Or (Eq x 0) (Eq θ 0))","decl":"/-- A vector equals a rotation of that vector if and only if the vector or the angle is zero. -/\ntheorem eq_rotation_self_iff (x : V) (θ : Real.Angle) : x = o.rotation θ x ↔ x = 0 ∨ θ = 0 := by\n  rw [← rotation_eq_self_iff, eq_comm]\n\n"}
{"name":"Orientation.rotation_oangle_eq_iff_norm_eq","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq ((o.rotation (o.oangle x y)) x) y) (Eq (Norm.norm x) (Norm.norm y))","decl":"/-- Rotating a vector by the angle to another vector gives the second vector if and only if the\nnorms are equal. -/\n@[simp]\ntheorem rotation_oangle_eq_iff_norm_eq (x y : V) : o.rotation (o.oangle x y) x = y ↔ ‖x‖ = ‖y‖ := by\n  constructor\n  · intro h\n    rw [← h, LinearIsometryEquiv.norm_map]\n  · intro h\n    rw [o.eq_iff_oangle_eq_zero_of_norm_eq] <;> simp [h]\n\n"}
{"name":"Orientation.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\nθ : Real.Angle\n⊢ Iff (Eq (o.oangle x y) θ) (Eq y (HSMul.hSMul (HDiv.hDiv (Norm.norm y) (Norm.norm x)) ((o.rotation θ) x)))","decl":"/-- The angle between two nonzero vectors is `θ` if and only if the second vector is the first\nrotated by `θ` and scaled by the ratio of the norms. -/\ntheorem oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0)\n    (θ : Real.Angle) : o.oangle x y = θ ↔ y = (‖y‖ / ‖x‖) • o.rotation θ x := by\n  have hp := div_pos (norm_pos_iff.2 hy) (norm_pos_iff.2 hx)\n  constructor\n  · rintro rfl\n    rw [← LinearIsometryEquiv.map_smul, ← o.oangle_smul_left_of_pos x y hp, eq_comm,\n      rotation_oangle_eq_iff_norm_eq, norm_smul, Real.norm_of_nonneg hp.le,\n      div_mul_cancel₀ _ (norm_ne_zero_iff.2 hx)]\n  · intro hye\n    rw [hye, o.oangle_smul_right_of_pos _ _ hp, o.oangle_rotation_self_right hx]\n\n"}
{"name":"Orientation.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nhx : Ne x 0\nhy : Ne y 0\nθ : Real.Angle\n⊢ Iff (Eq (o.oangle x y) θ) (Exists fun r => And (LT.lt 0 r) (Eq y (HSMul.hSMul r ((o.rotation θ) x))))","decl":"/-- The angle between two nonzero vectors is `θ` if and only if the second vector is the first\nrotated by `θ` and scaled by a positive real. -/\ntheorem oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero {x y : V} (hx : x ≠ 0) (hy : y ≠ 0)\n    (θ : Real.Angle) : o.oangle x y = θ ↔ ∃ r : ℝ, 0 < r ∧ y = r • o.rotation θ x := by\n  constructor\n  · intro h\n    rw [o.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero hx hy] at h\n    exact ⟨‖y‖ / ‖x‖, div_pos (norm_pos_iff.2 hy) (norm_pos_iff.2 hx), h⟩\n  · rintro ⟨r, hr, rfl⟩\n    rw [o.oangle_smul_right_of_pos _ _ hr, o.oangle_rotation_self_right hx]\n\n"}
{"name":"Orientation.oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nθ : Real.Angle\n⊢ Iff (Eq (o.oangle x y) θ) (Or (And (Ne x 0) (And (Ne y 0) (Eq y (HSMul.hSMul (HDiv.hDiv (Norm.norm y) (Norm.norm x)) ((o.rotation θ) x))))) (And (Eq θ 0) (Or (Eq x 0) (Eq y 0))))","decl":"/-- The angle between two vectors is `θ` if and only if they are nonzero and the second vector\nis the first rotated by `θ` and scaled by the ratio of the norms, or `θ` and at least one of the\nvectors are zero. -/\ntheorem oangle_eq_iff_eq_norm_div_norm_smul_rotation_or_eq_zero {x y : V} (θ : Real.Angle) :\n    o.oangle x y = θ ↔\n      x ≠ 0 ∧ y ≠ 0 ∧ y = (‖y‖ / ‖x‖) • o.rotation θ x ∨ θ = 0 ∧ (x = 0 ∨ y = 0) := by\n  by_cases hx : x = 0\n  · simp [hx, eq_comm]\n  · by_cases hy : y = 0\n    · simp [hy, eq_comm]\n    · rw [o.oangle_eq_iff_eq_norm_div_norm_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]\n\n"}
{"name":"Orientation.oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\nθ : Real.Angle\n⊢ Iff (Eq (o.oangle x y) θ) (Or (And (Ne x 0) (And (Ne y 0) (Exists fun r => And (LT.lt 0 r) (Eq y (HSMul.hSMul r ((o.rotation θ) x)))))) (And (Eq θ 0) (Or (Eq x 0) (Eq y 0))))","decl":"/-- The angle between two vectors is `θ` if and only if they are nonzero and the second vector\nis the first rotated by `θ` and scaled by a positive real, or `θ` and at least one of the\nvectors are zero. -/\ntheorem oangle_eq_iff_eq_pos_smul_rotation_or_eq_zero {x y : V} (θ : Real.Angle) :\n    o.oangle x y = θ ↔\n      (x ≠ 0 ∧ y ≠ 0 ∧ ∃ r : ℝ, 0 < r ∧ y = r • o.rotation θ x) ∨ θ = 0 ∧ (x = 0 ∨ y = 0) := by\n  by_cases hx : x = 0\n  · simp [hx, eq_comm]\n  · by_cases hy : y = 0\n    · simp [hy, eq_comm]\n    · rw [o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero hx hy]\n      simp [hx, hy]\n\n"}
{"name":"Orientation.exists_linearIsometryEquiv_eq_of_det_pos","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nf : LinearIsometryEquiv (RingHom.id Real) V V\nhd : LT.lt 0 (LinearMap.det ↑f.toLinearEquiv)\n⊢ Exists fun θ => Eq f (o.rotation θ)","decl":"/-- Any linear isometric equivalence in `V` with positive determinant is `rotation`. -/\ntheorem exists_linearIsometryEquiv_eq_of_det_pos {f : V ≃ₗᵢ[ℝ] V}\n    (hd : 0 < LinearMap.det (f.toLinearEquiv : V →ₗ[ℝ] V)) :\n    ∃ θ : Real.Angle, f = o.rotation θ := by\n  haveI : Nontrivial V := nontrivial_of_finrank_eq_succ (@Fact.out (finrank ℝ V = 2) _)\n  obtain ⟨x, hx⟩ : ∃ x, x ≠ (0 : V) := exists_ne (0 : V)\n  use o.oangle x (f x)\n  apply LinearIsometryEquiv.toLinearEquiv_injective\n  apply LinearEquiv.toLinearMap_injective\n  apply (o.basisRightAngleRotation x hx).ext\n  intro i\n  symm\n  fin_cases i\n  · simp\n  have : o.oangle (J x) (f (J x)) = o.oangle x (f x) := by\n    simp only [oangle, o.linearIsometryEquiv_comp_rightAngleRotation f hd,\n      o.kahler_comp_rightAngleRotation]\n  simp [← this]\n\n"}
{"name":"Orientation.rotation_map","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\nV' : Type u_2\ninst✝⁵ : NormedAddCommGroup V\ninst✝⁴ : NormedAddCommGroup V'\ninst✝³ : InnerProductSpace Real V\ninst✝² : InnerProductSpace Real V'\ninst✝¹ : Fact (Eq (Module.finrank Real V) 2)\ninst✝ : Fact (Eq (Module.finrank Real V') 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nf : LinearIsometryEquiv (RingHom.id Real) V V'\nx : V'\n⊢ Eq ((((Orientation.map (Fin 2) f.toLinearEquiv) o).rotation θ) x) (f ((o.rotation θ) (f.symm x)))","decl":"theorem rotation_map (θ : Real.Angle) (f : V ≃ₗᵢ[ℝ] V') (x : V') :\n    (Orientation.map (Fin 2) f.toLinearEquiv o).rotation θ x = f (o.rotation θ (f.symm x)) := by\n  simp [rotation_apply, o.rightAngleRotation_map]\n\n"}
{"name":"Complex.rotation","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"θ : Real.Angle\nz : Complex\n⊢ Eq ((Complex.orientation.rotation θ) z) (HMul.hMul (↑θ.toCircle) z)","decl":"@[simp]\nprotected theorem _root_.Complex.rotation (θ : Real.Angle) (z : ℂ) :\n    Complex.orientation.rotation θ z = θ.toCircle * z := by\n  simp only [rotation_apply, Complex.rightAngleRotation, Real.Angle.coe_toCircle, real_smul]\n  ring\n\n"}
{"name":"Orientation.rotation_map_complex","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\nf : LinearIsometryEquiv (RingHom.id Real) V Complex\nhf : Eq ((Orientation.map (Fin 2) f.toLinearEquiv) o) Complex.orientation\nx : V\n⊢ Eq (f ((o.rotation θ) x)) (HMul.hMul (↑θ.toCircle) (f x))","decl":"/-- Rotation in an oriented real inner product space of dimension 2 can be evaluated in terms of a\ncomplex-number representation of the space. -/\ntheorem rotation_map_complex (θ : Real.Angle) (f : V ≃ₗᵢ[ℝ] ℂ)\n    (hf : Orientation.map (Fin 2) f.toLinearEquiv o = Complex.orientation) (x : V) :\n    f (o.rotation θ x) = θ.toCircle * f x := by\n  rw [← Complex.rotation, ← hf, o.rotation_map, LinearIsometryEquiv.symm_apply_apply]\n\n"}
{"name":"Orientation.rotation_neg_orientation_eq_neg","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nθ : Real.Angle\n⊢ Eq ((Neg.neg o).rotation θ) (o.rotation (Neg.neg θ))","decl":"/-- Negating the orientation negates the angle in `rotation`. -/\ntheorem rotation_neg_orientation_eq_neg (θ : Real.Angle) : (-o).rotation θ = o.rotation (-θ) :=\n  LinearIsometryEquiv.ext <| by simp [rotation_apply]\n\n"}
{"name":"Orientation.inner_rotation_pi_div_two_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (Inner.inner ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x) x) 0","decl":"/-- The inner product between a `π / 2` rotation of a vector and that vector is zero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_left (x : V) : ⟪o.rotation (π / 2 : ℝ) x, x⟫ = 0 := by\n  rw [rotation_pi_div_two, inner_rightAngleRotation_self]\n\n"}
{"name":"Orientation.inner_rotation_pi_div_two_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\n⊢ Eq (Inner.inner x ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)) 0","decl":"/-- The inner product between a vector and a `π / 2` rotation of that vector is zero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_right (x : V) : ⟪x, o.rotation (π / 2 : ℝ) x⟫ = 0 := by\n  rw [real_inner_comm, inner_rotation_pi_div_two_left]\n\n"}
{"name":"Orientation.inner_smul_rotation_pi_div_two_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\n⊢ Eq (Inner.inner (HSMul.hSMul r ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)) x) 0","decl":"/-- The inner product between a multiple of a `π / 2` rotation of a vector and that vector is\nzero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_left (x : V) (r : ℝ) :\n    ⟪r • o.rotation (π / 2 : ℝ) x, x⟫ = 0 := by\n  rw [inner_smul_left, inner_rotation_pi_div_two_left, mul_zero]\n\n"}
{"name":"Orientation.inner_smul_rotation_pi_div_two_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\n⊢ Eq (Inner.inner x (HSMul.hSMul r ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x))) 0","decl":"/-- The inner product between a vector and a multiple of a `π / 2` rotation of that vector is\nzero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_right (x : V) (r : ℝ) :\n    ⟪x, r • o.rotation (π / 2 : ℝ) x⟫ = 0 := by\n  rw [real_inner_comm, inner_smul_rotation_pi_div_two_left]\n\n"}
{"name":"Orientation.inner_rotation_pi_div_two_left_smul","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\n⊢ Eq (Inner.inner ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x) (HSMul.hSMul r x)) 0","decl":"/-- The inner product between a `π / 2` rotation of a vector and a multiple of that vector is\nzero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_left_smul (x : V) (r : ℝ) :\n    ⟪o.rotation (π / 2 : ℝ) x, r • x⟫ = 0 := by\n  rw [inner_smul_right, inner_rotation_pi_div_two_left, mul_zero]\n\n"}
{"name":"Orientation.inner_rotation_pi_div_two_right_smul","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr : Real\n⊢ Eq (Inner.inner (HSMul.hSMul r x) ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)) 0","decl":"/-- The inner product between a multiple of a vector and a `π / 2` rotation of that vector is\nzero. -/\n@[simp]\ntheorem inner_rotation_pi_div_two_right_smul (x : V) (r : ℝ) :\n    ⟪r • x, o.rotation (π / 2 : ℝ) x⟫ = 0 := by\n  rw [real_inner_comm, inner_rotation_pi_div_two_left_smul]\n\n"}
{"name":"Orientation.inner_smul_rotation_pi_div_two_smul_left","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr₁ r₂ : Real\n⊢ Eq (Inner.inner (HSMul.hSMul r₁ ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)) (HSMul.hSMul r₂ x)) 0","decl":"/-- The inner product between a multiple of a `π / 2` rotation of a vector and a multiple of\nthat vector is zero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_smul_left (x : V) (r₁ r₂ : ℝ) :\n    ⟪r₁ • o.rotation (π / 2 : ℝ) x, r₂ • x⟫ = 0 := by\n  rw [inner_smul_right, inner_smul_rotation_pi_div_two_left, mul_zero]\n\n"}
{"name":"Orientation.inner_smul_rotation_pi_div_two_smul_right","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx : V\nr₁ r₂ : Real\n⊢ Eq (Inner.inner (HSMul.hSMul r₂ x) (HSMul.hSMul r₁ ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x))) 0","decl":"/-- The inner product between a multiple of a vector and a multiple of a `π / 2` rotation of\nthat vector is zero. -/\n@[simp]\ntheorem inner_smul_rotation_pi_div_two_smul_right (x : V) (r₁ r₂ : ℝ) :\n    ⟪r₂ • x, r₁ • o.rotation (π / 2 : ℝ) x⟫ = 0 := by\n  rw [real_inner_comm, inner_smul_rotation_pi_div_two_smul_left]\n\n"}
{"name":"Orientation.inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Oriented.Rotation","initialProofState":"V : Type u_1\ninst✝² : NormedAddCommGroup V\ninst✝¹ : InnerProductSpace Real V\ninst✝ : Fact (Eq (Module.finrank Real V) 2)\no : Orientation Real V (Fin 2)\nx y : V\n⊢ Iff (Eq (Inner.inner x y) 0) (Or (Eq x 0) (Exists fun r => Eq (HSMul.hSMul r ((o.rotation ↑(HDiv.hDiv Real.pi 2)) x)) y))","decl":"/-- The inner product between two vectors is zero if and only if the first vector is zero or\nthe second is a multiple of a `π / 2` rotation of that vector. -/\ntheorem inner_eq_zero_iff_eq_zero_or_eq_smul_rotation_pi_div_two {x y : V} :\n    ⟪x, y⟫ = 0 ↔ x = 0 ∨ ∃ r : ℝ, r • o.rotation (π / 2 : ℝ) x = y := by\n  rw [← o.eq_zero_or_oangle_eq_iff_inner_eq_zero]\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · rcases h with (rfl | rfl | h | h)\n    · exact Or.inl rfl\n    · exact Or.inr ⟨0, zero_smul _ _⟩\n    · obtain ⟨r, _, rfl⟩ :=\n        (o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero (o.left_ne_zero_of_oangle_eq_pi_div_two h)\n          (o.right_ne_zero_of_oangle_eq_pi_div_two h) _).1 h\n      exact Or.inr ⟨r, rfl⟩\n    · obtain ⟨r, _, rfl⟩ :=\n        (o.oangle_eq_iff_eq_pos_smul_rotation_of_ne_zero\n          (o.left_ne_zero_of_oangle_eq_neg_pi_div_two h)\n          (o.right_ne_zero_of_oangle_eq_neg_pi_div_two h) _).1 h\n      refine Or.inr ⟨-r, ?_⟩\n      rw [neg_smul, ← smul_neg, o.neg_rotation_pi_div_two]\n  · rcases h with (rfl | ⟨r, rfl⟩)\n    · exact Or.inl rfl\n    · by_cases hx : x = 0; · exact Or.inl hx\n      rcases lt_trichotomy r 0 with (hr | rfl | hr)\n      · refine Or.inr (Or.inr (Or.inr ?_))\n        rw [o.oangle_smul_right_of_neg _ _ hr, o.neg_rotation_pi_div_two,\n          o.oangle_rotation_self_right hx]\n      · exact Or.inr (Or.inl (zero_smul _ _))\n      · refine Or.inr (Or.inr (Or.inl ?_))\n        rw [o.oangle_smul_right_of_pos _ _ hr, o.oangle_rotation_self_right hx]\n\n"}
