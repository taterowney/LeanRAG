{"name":"OrderRingHom.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\ntoRingHom✝ : RingHom α β\nmonotone'✝ : Monotone (↑↑toRingHom✝).toFun\ntoRingHom : RingHom α β\nmonotone' : Monotone (↑↑toRingHom).toFun\n⊢ Eq (Eq { toRingHom := toRingHom✝, monotone' := monotone'✝ } { toRingHom := toRingHom, monotone' := monotone' }) (Eq toRingHom✝ toRingHom)","decl":"/-- `OrderRingHom α β`, denoted `α →+*o β`,\nis the type of monotone semiring homomorphisms from `α` to `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingHom α β)`,\nyou should parametrize over `(F : Type*) [OrderRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingHomClass`. -/\nstructure OrderRingHom (α β : Type*) [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β]\n  [Preorder β] extends α →+* β where\n  /-- The proposition that the function preserves the order. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderRingHom.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : NonAssocSemiring α\ninst✝⁴ : Preorder α\ninst✝³ : NonAssocSemiring β\ninst✝² : Preorder β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoRingHom : RingHom α β\nmonotone' : Monotone (↑↑toRingHom).toFun\n⊢ Eq (SizeOf.sizeOf { toRingHom := toRingHom, monotone' := monotone' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingHom))","decl":"/-- `OrderRingHom α β`, denoted `α →+*o β`,\nis the type of monotone semiring homomorphisms from `α` to `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingHom α β)`,\nyou should parametrize over `(F : Type*) [OrderRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingHomClass`. -/\nstructure OrderRingHom (α β : Type*) [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β]\n  [Preorder β] extends α →+* β where\n  /-- The proposition that the function preserves the order. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderRingHom.mk.inj","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\ntoRingHom✝ : RingHom α β\nmonotone'✝ : Monotone (↑↑toRingHom✝).toFun\ntoRingHom : RingHom α β\nmonotone' : Monotone (↑↑toRingHom).toFun\nx✝ : Eq { toRingHom := toRingHom✝, monotone' := monotone'✝ } { toRingHom := toRingHom, monotone' := monotone' }\n⊢ Eq toRingHom✝ toRingHom","decl":"/-- `OrderRingHom α β`, denoted `α →+*o β`,\nis the type of monotone semiring homomorphisms from `α` to `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingHom α β)`,\nyou should parametrize over `(F : Type*) [OrderRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingHomClass`. -/\nstructure OrderRingHom (α β : Type*) [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β]\n  [Preorder β] extends α →+* β where\n  /-- The proposition that the function preserves the order. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderRingHom.monotone'","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nself : OrderRingHom α β\n⊢ Monotone (↑↑self.toRingHom).toFun","decl":"/-- `OrderRingHom α β`, denoted `α →+*o β`,\nis the type of monotone semiring homomorphisms from `α` to `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingHom α β)`,\nyou should parametrize over `(F : Type*) [OrderRingHomClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingHomClass`. -/\nstructure OrderRingHom (α β : Type*) [NonAssocSemiring α] [Preorder α] [NonAssocSemiring β]\n  [Preorder β] extends α →+* β where\n  /-- The proposition that the function preserves the order. -/\n  monotone' : Monotone toFun\n\n"}
{"name":"OrderRingIso.map_le_map_iff'","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Mul α\ninst✝⁴ : Mul β\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : LE α\ninst✝ : LE β\nself : OrderRingIso α β\na b : α\n⊢ Iff (LE.le (self.toFun a) (self.toFun b)) (LE.le a b)","decl":"/-- `OrderRingIso α β`, denoted as `α ≃+*o β`,\nis the type of order-preserving semiring isomorphisms between `α` and `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingIso α β)`,\nyou should parametrize over `(F : Type*) [OrderRingIsoClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingIsoClass`. -/\nstructure OrderRingIso (α β : Type*) [Mul α] [Mul β] [Add α] [Add β] [LE α] [LE β] extends\n  α ≃+* β where\n  /-- The proposition that the function preserves the order bijectively. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderRingIso.mk.sizeOf_spec","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁷ : Mul α\ninst✝⁶ : Mul β\ninst✝⁵ : Add α\ninst✝⁴ : Add β\ninst✝³ : LE α\ninst✝² : LE β\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoRingEquiv : RingEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toRingEquiv.toFun a) (toRingEquiv.toFun b)) (LE.le a b)\n⊢ Eq (SizeOf.sizeOf { toRingEquiv := toRingEquiv, map_le_map_iff' := map_le_map_iff' }) (HAdd.hAdd 1 (SizeOf.sizeOf toRingEquiv))","decl":"/-- `OrderRingIso α β`, denoted as `α ≃+*o β`,\nis the type of order-preserving semiring isomorphisms between `α` and `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingIso α β)`,\nyou should parametrize over `(F : Type*) [OrderRingIsoClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingIsoClass`. -/\nstructure OrderRingIso (α β : Type*) [Mul α] [Mul β] [Add α] [Add β] [LE α] [LE β] extends\n  α ≃+* β where\n  /-- The proposition that the function preserves the order bijectively. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderRingIso.mk.injEq","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Mul α\ninst✝⁴ : Mul β\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : LE α\ninst✝ : LE β\ntoRingEquiv✝ : RingEquiv α β\nmap_le_map_iff'✝ : ∀ {a b : α}, Iff (LE.le (toRingEquiv✝.toFun a) (toRingEquiv✝.toFun b)) (LE.le a b)\ntoRingEquiv : RingEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toRingEquiv.toFun a) (toRingEquiv.toFun b)) (LE.le a b)\n⊢ Eq (Eq { toRingEquiv := toRingEquiv✝, map_le_map_iff' := map_le_map_iff'✝ } { toRingEquiv := toRingEquiv, map_le_map_iff' := map_le_map_iff' }) (Eq toRingEquiv✝ toRingEquiv)","decl":"/-- `OrderRingIso α β`, denoted as `α ≃+*o β`,\nis the type of order-preserving semiring isomorphisms between `α` and `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingIso α β)`,\nyou should parametrize over `(F : Type*) [OrderRingIsoClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingIsoClass`. -/\nstructure OrderRingIso (α β : Type*) [Mul α] [Mul β] [Add α] [Add β] [LE α] [LE β] extends\n  α ≃+* β where\n  /-- The proposition that the function preserves the order bijectively. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderRingIso.mk.inj","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_6\nβ : Type u_7\ninst✝⁵ : Mul α\ninst✝⁴ : Mul β\ninst✝³ : Add α\ninst✝² : Add β\ninst✝¹ : LE α\ninst✝ : LE β\ntoRingEquiv✝ : RingEquiv α β\nmap_le_map_iff'✝ : ∀ {a b : α}, Iff (LE.le (toRingEquiv✝.toFun a) (toRingEquiv✝.toFun b)) (LE.le a b)\ntoRingEquiv : RingEquiv α β\nmap_le_map_iff' : ∀ {a b : α}, Iff (LE.le (toRingEquiv.toFun a) (toRingEquiv.toFun b)) (LE.le a b)\nx✝ : Eq { toRingEquiv := toRingEquiv✝, map_le_map_iff' := map_le_map_iff'✝ } { toRingEquiv := toRingEquiv, map_le_map_iff' := map_le_map_iff' }\n⊢ Eq toRingEquiv✝ toRingEquiv","decl":"/-- `OrderRingIso α β`, denoted as `α ≃+*o β`,\nis the type of order-preserving semiring isomorphisms between `α` and `β`.\n\nWhen possible, instead of parametrizing results over `(f : OrderRingIso α β)`,\nyou should parametrize over `(F : Type*) [OrderRingIsoClass F α β] (f : F)`.\n\nWhen you extend this structure, make sure to extend `OrderRingIsoClass`. -/\nstructure OrderRingIso (α β : Type*) [Mul α] [Mul β] [Add α] [Add β] [LE α] [LE β] extends\n  α ≃+* β where\n  /-- The proposition that the function preserves the order bijectively. -/\n  map_le_map_iff' {a b : α} : toFun a ≤ toFun b ↔ a ≤ b\n\n"}
{"name":"OrderRingHom.instOrderHomClass","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\n⊢ OrderHomClass (OrderRingHom α β) α β","decl":"instance : OrderHomClass (α →+*o β) α β where\n  map_rel f _ _ h := f.monotone' h\n\n"}
{"name":"OrderRingHom.instRingHomClass","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\n⊢ RingHomClass (OrderRingHom α β) α β","decl":"instance : RingHomClass (α →+*o β) α β where\n  map_mul f := f.map_mul'\n  map_one f := f.map_one'\n  map_add f := f.map_add'\n  map_zero f := f.map_zero'\n\n"}
{"name":"OrderRingHom.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq (↑↑f.toRingHom).toFun ⇑f","decl":"theorem toFun_eq_coe (f : α →+*o β) : f.toFun = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.ext","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf g : OrderRingHom α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α →+*o β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderRingHom.ext_iff","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf g : OrderRingHom α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : α →+*o β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderRingHom.toRingHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq f.toRingHom ↑f","decl":"@[simp]\ntheorem toRingHom_eq_coe (f : α →+*o β) : f.toRingHom = f :=\n  RingHom.ext fun _ => rfl\n\n"}
{"name":"OrderRingHom.toOrderAddMonoidHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq f.toOrderAddMonoidHom ↑f","decl":"@[simp]\ntheorem toOrderAddMonoidHom_eq_coe (f : α →+*o β) : f.toOrderAddMonoidHom = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.toOrderMonoidWithZeroHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq f.toOrderMonoidWithZeroHom ↑f","decl":"@[simp]\ntheorem toOrderMonoidWithZeroHom_eq_coe (f : α →+*o β) : f.toOrderMonoidWithZeroHom = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_coe_ringHom","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_coe_ringHom (f : α →+*o β) : ⇑(f : α →+* β) = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_coe_orderAddMonoidHom","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_coe_orderAddMonoidHom (f : α →+*o β) : ⇑(f : α →+o β) = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_coe_orderMonoidWithZeroHom","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp]\ntheorem coe_coe_orderMonoidWithZeroHom (f : α →+*o β) : ⇑(f : α →*₀o β) = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_ringHom_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\na : α\n⊢ Eq (↑f a) (f a)","decl":"@[norm_cast]\ntheorem coe_ringHom_apply (f : α →+*o β) (a : α) : (f : α →+* β) a = f a :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_orderAddMonoidHom_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\na : α\n⊢ Eq (↑f a) (f a)","decl":"@[norm_cast]\ntheorem coe_orderAddMonoidHom_apply (f : α →+*o β) (a : α) : (f : α →+o β) a = f a :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_orderMonoidWithZeroHom_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\na : α\n⊢ Eq (↑f a) (f a)","decl":"@[norm_cast]\ntheorem coe_orderMonoidWithZeroHom_apply (f : α →+*o β) (a : α) : (f : α →*₀o β) a = f a :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_copy","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (⇑(f.copy f' h)) f'","decl":"@[simp]\ntheorem coe_copy (f : α →+*o β) (f' : α → β) (h : f' = f) : ⇑(f.copy f' h) = f' :=\n  rfl\n\n"}
{"name":"OrderRingHom.copy_eq","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\nf' : α → β\nh : Eq f' ⇑f\n⊢ Eq (f.copy f' h) f","decl":"theorem copy_eq (f : α →+*o β) (f' : α → β) (h : f' = f) : f.copy f' h = f :=\n  DFunLike.ext' h\n\n"}
{"name":"OrderRingHom.coe_id","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : Preorder α\n⊢ Eq (⇑(OrderRingHom.id α)) id","decl":"@[simp, norm_cast]\ntheorem coe_id : ⇑(OrderRingHom.id α) = id :=\n  rfl\n\n"}
{"name":"OrderRingHom.id_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : Preorder α\na : α\n⊢ Eq ((OrderRingHom.id α) a) a","decl":"@[simp]\ntheorem id_apply (a : α) : OrderRingHom.id α a = a :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_ringHom_id","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : Preorder α\n⊢ Eq (↑(OrderRingHom.id α)) (RingHom.id α)","decl":"@[simp]\ntheorem coe_ringHom_id : (OrderRingHom.id α : α →+* α) = RingHom.id α :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_orderAddMonoidHom_id","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : Preorder α\n⊢ Eq (↑(OrderRingHom.id α)) (OrderAddMonoidHom.id α)","decl":"@[simp]\ntheorem coe_orderAddMonoidHom_id : (OrderRingHom.id α : α →+o α) = OrderAddMonoidHom.id α :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_orderMonoidWithZeroHom_id","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : Preorder α\n⊢ Eq (↑(OrderRingHom.id α)) (OrderMonoidWithZeroHom.id α)","decl":"@[simp]\ntheorem coe_orderMonoidWithZeroHom_id :\n    (OrderRingHom.id α : α →*₀o α) = OrderMonoidWithZeroHom.id α :=\n  rfl\n\n"}
{"name":"OrderRingHom.coe_comp","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : NonAssocSemiring α\ninst✝⁴ : Preorder α\ninst✝³ : NonAssocSemiring β\ninst✝² : Preorder β\ninst✝¹ : NonAssocSemiring γ\ninst✝ : Preorder γ\nf : OrderRingHom β γ\ng : OrderRingHom α β\n⊢ Eq (⇑(f.comp g)) (Function.comp ⇑f ⇑g)","decl":"@[simp]\ntheorem coe_comp (f : β →+*o γ) (g : α →+*o β) : ⇑(f.comp g) = f ∘ g :=\n  rfl\n\n"}
{"name":"OrderRingHom.comp_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : NonAssocSemiring α\ninst✝⁴ : Preorder α\ninst✝³ : NonAssocSemiring β\ninst✝² : Preorder β\ninst✝¹ : NonAssocSemiring γ\ninst✝ : Preorder γ\nf : OrderRingHom β γ\ng : OrderRingHom α β\na : α\n⊢ Eq ((f.comp g) a) (f (g a))","decl":"@[simp]\ntheorem comp_apply (f : β →+*o γ) (g : α →+*o β) (a : α) : f.comp g a = f (g a) :=\n  rfl\n\n"}
{"name":"OrderRingHom.comp_assoc","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nδ : Type u_5\ninst✝⁷ : NonAssocSemiring α\ninst✝⁶ : Preorder α\ninst✝⁵ : NonAssocSemiring β\ninst✝⁴ : Preorder β\ninst✝³ : NonAssocSemiring γ\ninst✝² : Preorder γ\ninst✝¹ : NonAssocSemiring δ\ninst✝ : Preorder δ\nf : OrderRingHom γ δ\ng : OrderRingHom β γ\nh : OrderRingHom α β\n⊢ Eq ((f.comp g).comp h) (f.comp (g.comp h))","decl":"theorem comp_assoc (f : γ →+*o δ) (g : β →+*o γ) (h : α →+*o β) :\n    (f.comp g).comp h = f.comp (g.comp h) :=\n  rfl\n\n"}
{"name":"OrderRingHom.comp_id","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq (f.comp (OrderRingHom.id α)) f","decl":"@[simp]\ntheorem comp_id (f : α →+*o β) : f.comp (OrderRingHom.id α) = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.id_comp","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingHom α β\n⊢ Eq ((OrderRingHom.id β).comp f) f","decl":"@[simp]\ntheorem id_comp (f : α →+*o β) : (OrderRingHom.id β).comp f = f :=\n  rfl\n\n"}
{"name":"OrderRingHom.cancel_right","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : NonAssocSemiring α\ninst✝⁴ : Preorder α\ninst✝³ : NonAssocSemiring β\ninst✝² : Preorder β\ninst✝¹ : NonAssocSemiring γ\ninst✝ : Preorder γ\nf₁ f₂ : OrderRingHom β γ\ng : OrderRingHom α β\nhg : Function.Surjective ⇑g\n⊢ Iff (Eq (f₁.comp g) (f₂.comp g)) (Eq f₁ f₂)","decl":"@[simp]\ntheorem cancel_right {f₁ f₂ : β →+*o γ} {g : α →+*o β} (hg : Surjective g) :\n    f₁.comp g = f₂.comp g ↔ f₁ = f₂ :=\n  ⟨fun h => ext <| hg.forall.2 <| DFunLike.ext_iff.1 h, fun h => by rw [h]⟩\n\n"}
{"name":"OrderRingHom.cancel_left","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁵ : NonAssocSemiring α\ninst✝⁴ : Preorder α\ninst✝³ : NonAssocSemiring β\ninst✝² : Preorder β\ninst✝¹ : NonAssocSemiring γ\ninst✝ : Preorder γ\nf : OrderRingHom β γ\ng₁ g₂ : OrderRingHom α β\nhf : Function.Injective ⇑f\n⊢ Iff (Eq (f.comp g₁) (f.comp g₂)) (Eq g₁ g₂)","decl":"@[simp]\ntheorem cancel_left {f : β →+*o γ} {g₁ g₂ : α →+*o β} (hf : Injective f) :\n    f.comp g₁ = f.comp g₂ ↔ g₁ = g₂ :=\n  ⟨fun h => ext fun a => hf <| by rw [← comp_apply, h, comp_apply], congr_arg _⟩\n\n"}
{"name":"OrderRingIso.instOrderIsoClass","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\n⊢ OrderIsoClass (OrderRingIso α β) α β","decl":"instance : OrderIsoClass (α ≃+*o β) α β where\n  map_le_map_iff f _ _ := f.map_le_map_iff'\n\n"}
{"name":"OrderRingIso.instRingEquivClass","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\n⊢ RingEquivClass (OrderRingIso α β) α β","decl":"instance : RingEquivClass (α ≃+*o β) α β where\n  map_mul f := f.map_mul'\n  map_add f := f.map_add'\n\n"}
{"name":"OrderRingIso.toFun_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf : OrderRingIso α β\n⊢ Eq f.toFun ⇑f","decl":"theorem toFun_eq_coe (f : α ≃+*o β) : f.toFun = f :=\n  rfl\n\n"}
{"name":"OrderRingIso.ext_iff","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf g : OrderRingIso α β\n⊢ Iff (Eq f g) (∀ (a : α), Eq (f a) (g a))","decl":"@[ext]\ntheorem ext {f g : α ≃+*o β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderRingIso.ext","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf g : OrderRingIso α β\nh : ∀ (a : α), Eq (f a) (g a)\n⊢ Eq f g","decl":"@[ext]\ntheorem ext {f g : α ≃+*o β} (h : ∀ a, f a = g a) : f = g :=\n  DFunLike.ext f g h\n\n"}
{"name":"OrderRingIso.coe_mk","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\ne : RingEquiv α β\nh : ∀ {a b : α}, Iff (LE.le (e.toFun a) (e.toFun b)) (LE.le a b)\n⊢ Eq ⇑{ toRingEquiv := e, map_le_map_iff' := h } ⇑e","decl":"@[simp]\ntheorem coe_mk (e : α ≃+* β) (h) : ⇑(⟨e, h⟩ : α ≃+*o β) = e :=\n  rfl\n\n"}
{"name":"OrderRingIso.mk_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\ne : OrderRingIso α β\nh : ∀ {a b : α}, Iff (LE.le ((↑e).toFun a) ((↑e).toFun b)) (LE.le a b)\n⊢ Eq { toRingEquiv := ↑e, map_le_map_iff' := h } e","decl":"@[simp]\ntheorem mk_coe (e : α ≃+*o β) (h) : (⟨e, h⟩ : α ≃+*o β) = e :=\n  ext fun _ => rfl\n\n"}
{"name":"OrderRingIso.toRingEquiv_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf : OrderRingIso α β\n⊢ Eq f.toRingEquiv ↑f","decl":"@[simp]\ntheorem toRingEquiv_eq_coe (f : α ≃+*o β) : f.toRingEquiv = f :=\n  RingEquiv.ext fun _ => rfl\n\n"}
{"name":"OrderRingIso.toOrderIso_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf : OrderRingIso α β\n⊢ Eq ↑f ↑f","decl":"@[simp]\ntheorem toOrderIso_eq_coe (f : α ≃+*o β) : f.toOrderIso = f :=\n  OrderIso.ext rfl\n\n"}
{"name":"OrderRingIso.coe_toRingEquiv","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf : OrderRingIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toRingEquiv (f : α ≃+*o β) : ⇑(f : α ≃+* β) = f :=\n  rfl\n\n-- Porting note: needed to add DFunLike.coe on the lhs, bad Equiv coercion otherwise\n"}
{"name":"OrderRingIso.coe_toOrderIso","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\nf : OrderRingIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toOrderIso (f : α ≃+*o β) : DFunLike.coe (f : α ≃o β) = f :=\n  rfl\n\n"}
{"name":"OrderRingIso.refl_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : LE α\nx : α\n⊢ Eq ((OrderRingIso.refl α) x) x","decl":"@[simp]\ntheorem refl_apply (x : α) : OrderRingIso.refl α x = x := by\n  rfl\n\n"}
{"name":"OrderRingIso.coe_ringEquiv_refl","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : LE α\n⊢ Eq (↑(OrderRingIso.refl α)) (RingEquiv.refl α)","decl":"@[simp]\ntheorem coe_ringEquiv_refl : (OrderRingIso.refl α : α ≃+* α) = RingEquiv.refl α :=\n  rfl\n\n"}
{"name":"OrderRingIso.coe_orderIso_refl","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝² : Mul α\ninst✝¹ : Add α\ninst✝ : LE α\n⊢ Eq (↑(OrderRingIso.refl α)) (OrderIso.refl α)","decl":"@[simp]\ntheorem coe_orderIso_refl : (OrderRingIso.refl α : α ≃o α) = OrderIso.refl α :=\n  rfl\n\n"}
{"name":"OrderRingIso.symm_symm","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\ne : OrderRingIso α β\n⊢ Eq e.symm.symm e","decl":"@[simp]\ntheorem symm_symm (e : α ≃+*o β) : e.symm.symm = e := rfl\n\n"}
{"name":"OrderRingIso.trans_toRingEquiv","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁸ : Mul α\ninst✝⁷ : Add α\ninst✝⁶ : LE α\ninst✝⁵ : Mul β\ninst✝⁴ : Add β\ninst✝³ : LE β\ninst✝² : Mul γ\ninst✝¹ : Add γ\ninst✝ : LE γ\nf : OrderRingIso α β\ng : OrderRingIso β γ\n⊢ Eq (f.trans g).toRingEquiv (f.trans g.toRingEquiv)","decl":"/-- This lemma used to be generated by [simps] on `trans`, but the lhs of this simplifies under\nsimp. Removed [simps] attribute and added aux version below. -/\ntheorem trans_toRingEquiv (f : α ≃+*o β) (g : β ≃+*o γ) :\n    (OrderRingIso.trans f g).toRingEquiv = RingEquiv.trans f.toRingEquiv g.toRingEquiv :=\n  rfl\n\n"}
{"name":"OrderRingIso.trans_toRingEquiv_aux","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁸ : Mul α\ninst✝⁷ : Add α\ninst✝⁶ : LE α\ninst✝⁵ : Mul β\ninst✝⁴ : Add β\ninst✝³ : LE β\ninst✝² : Mul γ\ninst✝¹ : Add γ\ninst✝ : LE γ\nf : OrderRingIso α β\ng : OrderRingIso β γ\n⊢ Eq (↑(f.trans g)) (f.trans g.toRingEquiv)","decl":"/-- `simp`-normal form of `trans_toRingEquiv`. -/\n@[simp]\ntheorem trans_toRingEquiv_aux (f : α ≃+*o β) (g : β ≃+*o γ) :\n    RingEquivClass.toRingEquiv (OrderRingIso.trans f g)\n      = RingEquiv.trans f.toRingEquiv g.toRingEquiv :=\n  rfl\n\n"}
{"name":"OrderRingIso.trans_apply","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\ninst✝⁸ : Mul α\ninst✝⁷ : Add α\ninst✝⁶ : LE α\ninst✝⁵ : Mul β\ninst✝⁴ : Add β\ninst✝³ : LE β\ninst✝² : Mul γ\ninst✝¹ : Add γ\ninst✝ : LE γ\nf : OrderRingIso α β\ng : OrderRingIso β γ\na : α\n⊢ Eq ((f.trans g) a) (g (f a))","decl":"@[simp]\ntheorem trans_apply (f : α ≃+*o β) (g : β ≃+*o γ) (a : α) : f.trans g a = g (f a) :=\n  rfl\n\n"}
{"name":"OrderRingIso.self_trans_symm","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\ne : OrderRingIso α β\n⊢ Eq (e.trans e.symm) (OrderRingIso.refl α)","decl":"@[simp]\ntheorem self_trans_symm (e : α ≃+*o β) : e.trans e.symm = OrderRingIso.refl α :=\n  ext e.left_inv\n\n"}
{"name":"OrderRingIso.symm_trans_self","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\ne : OrderRingIso α β\n⊢ Eq (e.symm.trans e) (OrderRingIso.refl β)","decl":"@[simp]\ntheorem symm_trans_self (e : α ≃+*o β) : e.symm.trans e = OrderRingIso.refl β :=\n  ext e.right_inv\n\n"}
{"name":"OrderRingIso.symm_bijective","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝⁵ : Mul α\ninst✝⁴ : Add α\ninst✝³ : LE α\ninst✝² : Mul β\ninst✝¹ : Add β\ninst✝ : LE β\n⊢ Function.Bijective OrderRingIso.symm","decl":"theorem symm_bijective : Bijective (OrderRingIso.symm : (α ≃+*o β) → β ≃+*o α) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"OrderRingIso.toOrderRingHom_eq_coe","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingIso α β\n⊢ Eq f.toOrderRingHom ↑f","decl":"@[simp]\ntheorem toOrderRingHom_eq_coe (f : α ≃+*o β) : f.toOrderRingHom = f :=\n  rfl\n\n"}
{"name":"OrderRingIso.coe_toOrderRingHom","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\nf : OrderRingIso α β\n⊢ Eq ⇑↑f ⇑f","decl":"@[simp, norm_cast]\ntheorem coe_toOrderRingHom (f : α ≃+*o β) : ⇑(f : α →+*o β) = f :=\n  rfl\n\n"}
{"name":"OrderRingIso.coe_toOrderRingHom_refl","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\ninst✝¹ : NonAssocSemiring α\ninst✝ : Preorder α\n⊢ Eq (↑(OrderRingIso.refl α)) (OrderRingHom.id α)","decl":"@[simp]\ntheorem coe_toOrderRingHom_refl : (OrderRingIso.refl α : α →+*o α) = OrderRingHom.id α :=\n  rfl\n\n"}
{"name":"OrderRingIso.toOrderRingHom_injective","module":"Mathlib.Algebra.Order.Hom.Ring","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : NonAssocSemiring α\ninst✝² : Preorder α\ninst✝¹ : NonAssocSemiring β\ninst✝ : Preorder β\n⊢ Function.Injective OrderRingIso.toOrderRingHom","decl":"theorem toOrderRingHom_injective : Injective (toOrderRingHom : α ≃+*o β → α →+*o β) :=\n  fun f g h => DFunLike.coe_injective <| by convert DFunLike.ext'_iff.1 h using 0\n\n"}
