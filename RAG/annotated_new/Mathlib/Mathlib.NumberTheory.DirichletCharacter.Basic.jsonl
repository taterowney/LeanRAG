{"name":"DirichletCharacter.toUnitHom_eq_char'","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\na : ZMod n\nha : IsUnit a\n⊢ Eq (χ a) ↑((MulChar.toUnitHom χ) ha.unit)","decl":"lemma toUnitHom_eq_char' {a : ZMod n} (ha : IsUnit a) : χ a = χ.toUnitHom ha.unit := by simp\n\n"}
{"name":"DirichletCharacter.toUnitHom_inj","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ ψ : DirichletCharacter R n\n⊢ Iff (Eq (MulChar.toUnitHom χ) (MulChar.toUnitHom ψ)) (Eq χ ψ)","decl":"lemma toUnitHom_inj (ψ : DirichletCharacter R n) : toUnitHom χ = toUnitHom ψ ↔ χ = ψ := by simp\n\n"}
{"name":"DirichletCharacter.toUnitHom_eq_iff","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ ψ : DirichletCharacter R n\n⊢ Iff (Eq (MulChar.toUnitHom χ) (MulChar.toUnitHom ψ)) (Eq χ ψ)","decl":"@[deprecated (since := \"2024-12-29\")] alias toUnitHom_eq_iff := toUnitHom_inj\n\n"}
{"name":"DirichletCharacter.eval_modulus_sub","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nx : ZMod n\n⊢ Eq (χ (HSub.hSub (↑n) x)) (χ (Neg.neg x))","decl":"lemma eval_modulus_sub (x : ZMod n) : χ (n - x) = χ (-x) := by simp\n\n"}
{"name":"DirichletCharacter.changeLevel_def","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nm : Nat\nhm : Dvd.dvd n m\n⊢ Eq ((DirichletCharacter.changeLevel hm) χ) (MulChar.ofUnitHom ((MulChar.toUnitHom χ).comp (ZMod.unitsMap hm)))","decl":"lemma changeLevel_def {m : ℕ} (hm : n ∣ m) :\n    changeLevel hm χ = MulChar.ofUnitHom (χ.toUnitHom.comp (ZMod.unitsMap hm)) := rfl\n\n"}
{"name":"DirichletCharacter.changeLevel_toUnitHom","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nm : Nat\nhm : Dvd.dvd n m\n⊢ Eq (MulChar.toUnitHom ((DirichletCharacter.changeLevel hm) χ)) ((MulChar.toUnitHom χ).comp (ZMod.unitsMap hm))","decl":"lemma changeLevel_toUnitHom {m : ℕ} (hm : n ∣ m) :\n    (changeLevel hm χ).toUnitHom = χ.toUnitHom.comp (ZMod.unitsMap hm) := by\n  simp [changeLevel]\n\n"}
{"name":"DirichletCharacter.changeLevel_injective","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\nn m : Nat\ninst✝ : NeZero m\nhm : Dvd.dvd n m\n⊢ Function.Injective ⇑(DirichletCharacter.changeLevel hm)","decl":"/-- The `changeLevel` map is injective (except in the degenerate case `m = 0`). -/\nlemma changeLevel_injective {m : ℕ} [NeZero m] (hm : n ∣ m) :\n    Function.Injective (changeLevel (R := R) hm) := by\n  intro _ _ h\n  ext1 y\n  obtain ⟨z, rfl⟩ := ZMod.unitsMap_surjective hm y\n  rw [MulChar.ext_iff] at h\n  simpa [changeLevel_def] using h z\n\n"}
{"name":"DirichletCharacter.changeLevel_eq_one_iff","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\nn m : Nat\nχ : DirichletCharacter R n\nhm : Dvd.dvd n m\ninst✝ : NeZero m\n⊢ Iff (Eq ((DirichletCharacter.changeLevel hm) χ) 1) (Eq χ 1)","decl":"@[simp]\nlemma changeLevel_eq_one_iff {m : ℕ} {χ : DirichletCharacter R n} (hm : n ∣ m) [NeZero m] :\n    changeLevel hm χ = 1 ↔ χ = 1 :=\n  map_eq_one_iff _ (changeLevel_injective hm)\n\n"}
{"name":"DirichletCharacter.changeLevel_self","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Eq ((DirichletCharacter.changeLevel ⋯) χ) χ","decl":"@[simp]\nlemma changeLevel_self : changeLevel (dvd_refl n) χ = χ := by\n  simp [changeLevel, ZMod.unitsMap]\n\n"}
{"name":"DirichletCharacter.changeLevel_self_toUnitHom","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Eq (MulChar.toUnitHom ((DirichletCharacter.changeLevel ⋯) χ)) (MulChar.toUnitHom χ)","decl":"lemma changeLevel_self_toUnitHom : (changeLevel (dvd_refl n) χ).toUnitHom = χ.toUnitHom := by\n  rw [changeLevel_self]\n\n"}
{"name":"DirichletCharacter.changeLevel_trans","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nm d : Nat\nhm : Dvd.dvd n m\nhd : Dvd.dvd m d\n⊢ Eq ((DirichletCharacter.changeLevel ⋯) χ) ((DirichletCharacter.changeLevel hd) ((DirichletCharacter.changeLevel hm) χ))","decl":"lemma changeLevel_trans {m d : ℕ} (hm : n ∣ m) (hd : m ∣ d) :\n    changeLevel (dvd_trans hm hd) χ = changeLevel hd (changeLevel hm χ) := by\n  simp [changeLevel_def, MonoidHom.comp_assoc, ZMod.unitsMap_comp]\n\n"}
{"name":"DirichletCharacter.changeLevel_eq_cast_of_dvd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nm : Nat\nhm : Dvd.dvd n m\na : Units (ZMod m)\n⊢ Eq (((DirichletCharacter.changeLevel hm) χ) ↑a) (χ (↑a).cast)","decl":"lemma changeLevel_eq_cast_of_dvd {m : ℕ} (hm : n ∣ m) (a : Units (ZMod m)) :\n    (changeLevel hm χ) a = χ (ZMod.cast (a : ZMod m)) := by\n  simp [changeLevel_def, ZMod.unitsMap_val]\n\n"}
{"name":"DirichletCharacter.changeLevel_factorsThrough","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nm : Nat\nhm : Dvd.dvd n m\n⊢ ((DirichletCharacter.changeLevel hm) χ).FactorsThrough n","decl":"lemma changeLevel_factorsThrough {m : ℕ} (hm : n ∣ m) : FactorsThrough (changeLevel hm χ) n :=\n  ⟨hm, χ, rfl⟩\n\n"}
{"name":"DirichletCharacter.FactorsThrough.dvd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nd : Nat\nh : χ.FactorsThrough d\n⊢ Dvd.dvd d n","decl":"/-- The fact that `d` divides `n` when `χ` factors through a Dirichlet character at level `d` -/\nlemma dvd {d : ℕ} (h : FactorsThrough χ d) : d ∣ n := h.1\n\n"}
{"name":"DirichletCharacter.FactorsThrough.eq_changeLevel","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nd : Nat\nh : χ.FactorsThrough d\n⊢ Eq χ ((DirichletCharacter.changeLevel ⋯) h.χ₀)","decl":"/-- The fact that `χ` factors through `χ₀` of level `d` -/\nlemma eq_changeLevel {d : ℕ} (h : FactorsThrough χ d) : χ = changeLevel h.dvd h.χ₀ :=\n  Classical.choose_spec h.2\n\n"}
{"name":"DirichletCharacter.FactorsThrough.existsUnique","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nd : Nat\ninst✝ : NeZero n\nh : χ.FactorsThrough d\n⊢ ExistsUnique fun χ' => Eq χ ((DirichletCharacter.changeLevel ⋯) χ')","decl":"/-- The character of level `d` through which `χ` factors is uniquely determined. -/\nlemma existsUnique {d : ℕ} [NeZero n] (h : FactorsThrough χ d) :\n    ∃! χ' : DirichletCharacter R d, χ = changeLevel h.dvd χ' := by\n  rcases h with ⟨hd, χ₂, rfl⟩\n  exact ⟨χ₂, rfl, fun χ₃ hχ₃ ↦ (changeLevel_injective hd hχ₃).symm⟩\n\n"}
{"name":"DirichletCharacter.FactorsThrough.same_level","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ χ.FactorsThrough n","decl":"variable (χ) in\nlemma same_level : FactorsThrough χ n := ⟨dvd_refl n, χ, (changeLevel_self χ).symm⟩\n\n"}
{"name":"DirichletCharacter.factorsThrough_iff_ker_unitsMap","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝¹ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nd : Nat\ninst✝ : NeZero n\nhd : Dvd.dvd d n\n⊢ Iff (χ.FactorsThrough d) (LE.le (ZMod.unitsMap hd).ker (MulChar.toUnitHom χ).ker)","decl":"variable {χ} in\n/-- A Dirichlet character `χ` factors through `d | n` iff its associated unit-group hom is trivial\non the kernel of `ZMod.unitsMap`. -/\nlemma factorsThrough_iff_ker_unitsMap {d : ℕ} [NeZero n] (hd : d ∣ n) :\n    FactorsThrough χ d ↔ (ZMod.unitsMap hd).ker ≤ χ.toUnitHom.ker := by\n  refine ⟨fun ⟨_, ⟨χ₀, hχ₀⟩⟩ x hx ↦ ?_, fun h ↦ ?_⟩\n  · rw [MonoidHom.mem_ker, hχ₀, changeLevel_toUnitHom, MonoidHom.comp_apply, hx, map_one]\n  · let E := MonoidHom.liftOfSurjective _ (ZMod.unitsMap_surjective hd) ⟨_, h⟩\n    have hE : E.comp (ZMod.unitsMap hd) = χ.toUnitHom := MonoidHom.liftOfRightInverse_comp ..\n    refine ⟨hd, MulChar.ofUnitHom E, equivToUnitHom.injective (?_ : toUnitHom _ = toUnitHom _)⟩\n    simp_rw [changeLevel_toUnitHom, toUnitHom_eq, ofUnitHom_eq, Equiv.apply_symm_apply, hE,\n      toUnitHom_eq]\n\n"}
{"name":"DirichletCharacter.level_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nχ : DirichletCharacter R 1\n⊢ Eq χ 1","decl":"lemma level_one (χ : DirichletCharacter R 1) : χ = 1 := by\n  ext\n  simp [units_eq_one]\n\n"}
{"name":"DirichletCharacter.level_one'","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nhn : Eq n 1\n⊢ Eq χ 1","decl":"lemma level_one' (hn : n = 1) : χ = 1 := by\n  subst hn\n  exact level_one _\n\n"}
{"name":"DirichletCharacter.instSubsingletonOfNatNat","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\n⊢ Subsingleton (DirichletCharacter R 1)","decl":"instance : Subsingleton (DirichletCharacter R 1) := by\n  refine subsingleton_iff.mpr (fun χ χ' ↦ ?_)\n  simp [level_one]\n\n"}
{"name":"DirichletCharacter.map_zero'","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nhn : Ne n 1\n⊢ Eq (χ 0) 0","decl":"/-- A Dirichlet character of modulus `≠ 1` maps `0` to `0`. -/\nlemma map_zero' (hn : n ≠ 1) : χ 0 = 0 :=\n  have := ZMod.nontrivial_iff.mpr hn; χ.map_zero\n\n"}
{"name":"DirichletCharacter.changeLevel_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn d : Nat\nh : Dvd.dvd d n\n⊢ Eq ((DirichletCharacter.changeLevel h) 1) 1","decl":"lemma changeLevel_one {d : ℕ} (h : d ∣ n) :\n    changeLevel h (1 : DirichletCharacter R d) = 1 := by\n  simp\n\n"}
{"name":"DirichletCharacter.factorsThrough_one_iff","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Iff (χ.FactorsThrough 1) (Eq χ 1)","decl":"lemma factorsThrough_one_iff : FactorsThrough χ 1 ↔ χ = 1 := by\n  refine ⟨fun ⟨_, χ₀, hχ₀⟩ ↦ ?_,\n          fun h ↦ ⟨one_dvd n, 1, by rw [h, changeLevel_one]⟩⟩\n  rwa [level_one χ₀, changeLevel_one] at hχ₀\n\n"}
{"name":"DirichletCharacter.mem_conductorSet_iff","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nx : Nat\n⊢ Iff (Membership.mem χ.conductorSet x) (χ.FactorsThrough x)","decl":"lemma mem_conductorSet_iff {x : ℕ} : x ∈ conductorSet χ ↔ FactorsThrough χ x := Iff.refl _\n\n"}
{"name":"DirichletCharacter.level_mem_conductorSet","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Membership.mem χ.conductorSet n","decl":"lemma level_mem_conductorSet : n ∈ conductorSet χ := FactorsThrough.same_level χ\n\n"}
{"name":"DirichletCharacter.mem_conductorSet_dvd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nx : Nat\nhx : Membership.mem χ.conductorSet x\n⊢ Dvd.dvd x n","decl":"lemma mem_conductorSet_dvd {x : ℕ} (hx : x ∈ conductorSet χ) : x ∣ n := hx.dvd\n\n"}
{"name":"DirichletCharacter.conductor_mem_conductorSet","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Membership.mem χ.conductorSet χ.conductor","decl":"lemma conductor_mem_conductorSet : conductor χ ∈ conductorSet χ :=\n  Nat.sInf_mem (Set.nonempty_of_mem (level_mem_conductorSet χ))\n\n"}
{"name":"DirichletCharacter.conductor_dvd_level","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Dvd.dvd χ.conductor n","decl":"lemma conductor_dvd_level : conductor χ ∣ n := (conductor_mem_conductorSet χ).dvd\n\n"}
{"name":"DirichletCharacter.factorsThrough_conductor","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ χ.FactorsThrough χ.conductor","decl":"lemma factorsThrough_conductor : FactorsThrough χ (conductor χ) := conductor_mem_conductorSet χ\n\n"}
{"name":"DirichletCharacter.conductor_ne_zero","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nhn : Ne n 0\n⊢ Ne χ.conductor 0","decl":"lemma conductor_ne_zero (hn : n ≠ 0) : conductor χ ≠ 0 :=\n  fun h ↦ hn <| Nat.eq_zero_of_zero_dvd <| h ▸ conductor_dvd_level _\n\n"}
{"name":"DirichletCharacter.conductor_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nhn : Ne n 0\n⊢ Eq (DirichletCharacter.conductor 1) 1","decl":"/-- The conductor of the trivial character is 1. -/\nlemma conductor_one (hn : n ≠ 0) : conductor (1 : DirichletCharacter R n) = 1 := by\n  suffices FactorsThrough (1 : DirichletCharacter R n) 1 by\n    have h : conductor (1 : DirichletCharacter R n) ≤ 1 :=\n      Nat.sInf_le <| (mem_conductorSet_iff _).mpr this\n    exact Nat.le_antisymm h (Nat.pos_of_ne_zero <| conductor_ne_zero _ hn)\n  exact (factorsThrough_one_iff _).mpr rfl\n\n"}
{"name":"DirichletCharacter.eq_one_iff_conductor_eq_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nhn : Ne n 0\n⊢ Iff (Eq χ 1) (Eq χ.conductor 1)","decl":"lemma eq_one_iff_conductor_eq_one (hn : n ≠ 0) : χ = 1 ↔ conductor χ = 1 := by\n  refine ⟨fun h ↦ h ▸ conductor_one hn, fun hχ ↦ ?_⟩\n  obtain ⟨h', χ₀, h⟩ := factorsThrough_conductor χ\n  exact (level_one' χ₀ hχ ▸ h).trans <| changeLevel_one h'\n\n"}
{"name":"DirichletCharacter.conductor_eq_zero_iff_level_eq_zero","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Iff (Eq χ.conductor 0) (Eq n 0)","decl":"lemma conductor_eq_zero_iff_level_eq_zero : conductor χ = 0 ↔ n = 0 := by\n  refine ⟨(conductor_ne_zero χ).mtr, ?_⟩\n  rintro rfl\n  exact Nat.sInf_eq_zero.mpr <| Or.inl <| level_mem_conductorSet χ\n\n"}
{"name":"DirichletCharacter.conductor_le_conductor_mem_conductorSet","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nd : Nat\nhd : Membership.mem χ.conductorSet d\n⊢ LE.le χ.conductor (Classical.choose ⋯).conductor","decl":"lemma conductor_le_conductor_mem_conductorSet {d : ℕ} (hd : d ∈ conductorSet χ) :\n    χ.conductor ≤ (Classical.choose hd.2).conductor := by\n  refine Nat.sInf_le <| (mem_conductorSet_iff χ).mpr <|\n    ⟨dvd_trans (conductor_dvd_level _) hd.1,\n     (factorsThrough_conductor (Classical.choose hd.2)).2.choose, ?_⟩\n  rw [changeLevel_trans _ (conductor_dvd_level _) hd.dvd,\n      ← (factorsThrough_conductor (Classical.choose hd.2)).2.choose_spec]\n  exact hd.eq_changeLevel\n\n"}
{"name":"DirichletCharacter.isPrimitive_def","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ Iff χ.IsPrimitive (Eq χ.conductor n)","decl":"lemma isPrimitive_def : IsPrimitive χ ↔ conductor χ = n := Iff.rfl\n\n"}
{"name":"DirichletCharacter.isPrimitive_one_level_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\n⊢ DirichletCharacter.IsPrimitive 1","decl":"lemma isPrimitive_one_level_one : IsPrimitive (1 : DirichletCharacter R 1) :=\n  Nat.dvd_one.mp (conductor_dvd_level _)\n\n"}
{"name":"DirichletCharacter.isPritive_one_level_zero","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\n⊢ DirichletCharacter.IsPrimitive 1","decl":"lemma isPritive_one_level_zero : IsPrimitive (1 : DirichletCharacter R 0) :=\n  conductor_eq_zero_iff_level_eq_zero.mpr rfl\n\n"}
{"name":"DirichletCharacter.conductor_one_dvd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\n⊢ Dvd.dvd (DirichletCharacter.conductor 1) n","decl":"lemma conductor_one_dvd (n : ℕ) : conductor (1 : DirichletCharacter R 1) ∣ n := by\n  rw [(isPrimitive_def _).mp isPrimitive_one_level_one]\n  apply one_dvd _\n\n"}
{"name":"DirichletCharacter.primitiveCharacter_isPrimitive","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\n⊢ χ.primitiveCharacter.IsPrimitive","decl":"lemma primitiveCharacter_isPrimitive : IsPrimitive (χ.primitiveCharacter) := by\n  by_cases h : χ.conductor = 0\n  · rw [isPrimitive_def]\n    convert conductor_eq_zero_iff_level_eq_zero.mpr h\n  · exact le_antisymm (Nat.le_of_dvd (Nat.pos_of_ne_zero h) (conductor_dvd_level _)) <|\n      conductor_le_conductor_mem_conductorSet <| conductor_mem_conductorSet χ\n\n"}
{"name":"DirichletCharacter.primitiveCharacter_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nhn : Ne n 0\n⊢ Eq (DirichletCharacter.primitiveCharacter 1) 1","decl":"lemma primitiveCharacter_one (hn : n ≠ 0) :\n    (1 : DirichletCharacter R n).primitiveCharacter = 1 := by\n  rw [eq_one_iff_conductor_eq_one <| (@conductor_one R _ _ hn) ▸ Nat.one_ne_zero,\n      (isPrimitive_def _).1 (1 : DirichletCharacter R n).primitiveCharacter_isPrimitive,\n      conductor_one hn]\n\n"}
{"name":"DirichletCharacter.mul_def","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn m : Nat\nχ : DirichletCharacter R n\nψ : DirichletCharacter R m\n⊢ Eq (χ.primitive_mul ψ) (χ.mul ψ).primitiveCharacter","decl":"lemma mul_def {n m : ℕ} {χ : DirichletCharacter R n} {ψ : DirichletCharacter R m} :\n    χ.primitive_mul ψ = primitiveCharacter (mul χ ψ) :=\n  rfl\n\n"}
{"name":"DirichletCharacter.primitive_mul_isPrimitive","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"R : Type u_1\ninst✝ : CommMonoidWithZero R\nn : Nat\nχ : DirichletCharacter R n\nm : Nat\nψ : DirichletCharacter R m\n⊢ (χ.primitive_mul ψ).IsPrimitive","decl":"lemma primitive_mul_isPrimitive {m : ℕ} (ψ : DirichletCharacter R m) :\n    IsPrimitive (primitive_mul χ ψ) :=\n  primitiveCharacter_isPrimitive _\n\n/-\n### Even and odd characters\n-/\n\n"}
{"name":"DirichletCharacter.even_or_odd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝¹ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\ninst✝ : NoZeroDivisors S\n⊢ Or ψ.Even ψ.Odd","decl":"lemma even_or_odd [NoZeroDivisors S] : ψ.Even ∨ ψ.Odd := by\n  suffices ψ (-1) ^ 2 = 1 by convert sq_eq_one_iff.mp this\n  rw [← map_pow _, neg_one_sq, map_one]\n\n"}
{"name":"DirichletCharacter.not_even_and_odd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝¹ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\ninst✝ : NeZero 2\n⊢ Not (And ψ.Even ψ.Odd)","decl":"lemma not_even_and_odd [NeZero (2 : S)] : ¬(ψ.Even ∧ ψ.Odd) := by\n  rintro ⟨(h : _ = 1), (h' : _ = -1)⟩\n  simp only [h', neg_eq_iff_add_eq_zero, one_add_one_eq_two, two_ne_zero] at h\n\n"}
{"name":"DirichletCharacter.Even.not_odd","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝¹ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\ninst✝ : NeZero 2\nhψ : ψ.Even\n⊢ Not ψ.Odd","decl":"lemma Even.not_odd [NeZero (2 : S)] (hψ : Even ψ) : ¬Odd ψ :=\n  not_and.mp ψ.not_even_and_odd hψ\n\n"}
{"name":"DirichletCharacter.Odd.not_even","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝¹ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\ninst✝ : NeZero 2\nhψ : ψ.Odd\n⊢ Not ψ.Even","decl":"lemma Odd.not_even [NeZero (2 : S)] (hψ : Odd ψ) : ¬Even ψ :=\n  not_and'.mp ψ.not_even_and_odd hψ\n\n"}
{"name":"DirichletCharacter.Odd.toUnitHom_eval_neg_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\nhψ : ψ.Odd\n⊢ Eq ((MulChar.toUnitHom ψ) (-1)) (-1)","decl":"lemma Odd.toUnitHom_eval_neg_one (hψ : ψ.Odd) : ψ.toUnitHom (-1) = -1 := by\n  rw [← Units.eq_iff, MulChar.coe_toUnitHom]\n  exact hψ\n\n"}
{"name":"DirichletCharacter.Even.toUnitHom_eval_neg_one","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\nhψ : ψ.Even\n⊢ Eq ((MulChar.toUnitHom ψ) (-1)) 1","decl":"lemma Even.toUnitHom_eval_neg_one (hψ : ψ.Even) : ψ.toUnitHom (-1) = 1 := by\n  rw [← Units.eq_iff, MulChar.coe_toUnitHom]\n  exact hψ\n\n"}
{"name":"DirichletCharacter.Odd.eval_neg","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\nx : ZMod m\nhψ : ψ.Odd\n⊢ Eq (ψ (Neg.neg x)) (Neg.neg (ψ x))","decl":"lemma Odd.eval_neg (x : ZMod m) (hψ : ψ.Odd) : ψ (- x) = - ψ x := by\n  rw [Odd] at hψ\n  rw [← neg_one_mul, map_mul]\n  simp [hψ]\n\n"}
{"name":"DirichletCharacter.Even.eval_neg","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nm : Nat\nψ : DirichletCharacter S m\nx : ZMod m\nhψ : ψ.Even\n⊢ Eq (ψ (Neg.neg x)) (ψ x)","decl":"lemma Even.eval_neg (x : ZMod m) (hψ : ψ.Even) : ψ (- x) = ψ x := by\n  rw [Even] at hψ\n  rw [← neg_one_mul, map_mul]\n  simp [hψ]\n\n"}
{"name":"DirichletCharacter.Even.to_fun","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nm : Nat\nχ : DirichletCharacter S m\nhχ : χ.Even\n⊢ Function.Even ⇑χ","decl":"/-- An even Dirichlet character is an even function. -/\nlemma Even.to_fun {χ : DirichletCharacter S m} (hχ : Even χ) : Function.Even χ :=\n  fun _ ↦ by rw [← neg_one_mul, map_mul, hχ, one_mul]\n\n"}
{"name":"DirichletCharacter.Odd.to_fun","module":"Mathlib.NumberTheory.DirichletCharacter.Basic","initialProofState":"S : Type u_2\ninst✝ : CommRing S\nm : Nat\nχ : DirichletCharacter S m\nhχ : χ.Odd\n⊢ Function.Odd ⇑χ","decl":"/-- An odd Dirichlet character is an odd function. -/\nlemma Odd.to_fun {χ : DirichletCharacter S m} (hχ : Odd χ) : Function.Odd χ :=\n  fun _ ↦ by rw [← neg_one_mul, map_mul, hχ, neg_one_mul]\n\n"}
