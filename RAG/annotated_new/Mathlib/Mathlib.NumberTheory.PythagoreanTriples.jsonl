{"name":"sq_ne_two_fin_zmod_four","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"z : ZMod 4\n⊢ Ne (HMul.hMul z z) 2","decl":"theorem sq_ne_two_fin_zmod_four (z : ZMod 4) : z * z ≠ 2 := by\n  change Fin 4 at z\n  fin_cases z <;> decide\n\n"}
{"name":"Int.sq_ne_two_mod_four","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"z : Int\n⊢ Ne (HMod.hMod (HMul.hMul z z) 4) 2","decl":"theorem Int.sq_ne_two_mod_four (z : ℤ) : z * z % 4 ≠ 2 := by\n  suffices ¬z * z % (4 : ℕ) = 2 % (4 : ℕ) by exact this\n  rw [← ZMod.intCast_eq_intCast_iff']\n  simpa using sq_ne_two_fin_zmod_four _\n\n"}
{"name":"pythagoreanTriple_comm","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\n⊢ Iff (PythagoreanTriple x y z) (PythagoreanTriple y x z)","decl":"/-- Pythagorean triples are interchangeable, i.e `x * x + y * y = y * y + x * x = z * z`.\nThis comes from additive commutativity. -/\ntheorem pythagoreanTriple_comm {x y z : ℤ} : PythagoreanTriple x y z ↔ PythagoreanTriple y x z := by\n  delta PythagoreanTriple\n  rw [add_comm]\n\n"}
{"name":"PythagoreanTriple.zero","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"⊢ PythagoreanTriple 0 0 0","decl":"/-- The zeroth Pythagorean triple is all zeros. -/\ntheorem PythagoreanTriple.zero : PythagoreanTriple 0 0 0 := by\n  simp only [PythagoreanTriple, zero_mul, zero_add]\n\n"}
{"name":"PythagoreanTriple.eq","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\n⊢ Eq (HAdd.hAdd (HMul.hMul x x) (HMul.hMul y y)) (HMul.hMul z z)","decl":"theorem eq (h : PythagoreanTriple x y z) : x * x + y * y = z * z :=\n  h\n\n"}
{"name":"PythagoreanTriple.symm","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\n⊢ PythagoreanTriple y x z","decl":"@[symm]\ntheorem symm (h : PythagoreanTriple x y z) : PythagoreanTriple y x z := by\n  rwa [pythagoreanTriple_comm]\n\n"}
{"name":"PythagoreanTriple.mul","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nk : Int\n⊢ PythagoreanTriple (HMul.hMul k x) (HMul.hMul k y) (HMul.hMul k z)","decl":"/-- A triple is still a triple if you multiply `x`, `y` and `z`\nby a constant `k`. -/\ntheorem mul (h : PythagoreanTriple x y z) (k : ℤ) : PythagoreanTriple (k * x) (k * y) (k * z) :=\n  calc\n    k * x * (k * x) + k * y * (k * y) = k ^ 2 * (x * x + y * y) := by ring\n    _ = k ^ 2 * (z * z) := by rw [h.eq]\n    _ = k * z * (k * z) := by ring\n\n"}
{"name":"PythagoreanTriple.mul_iff","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z k : Int\nhk : Ne k 0\n⊢ Iff (PythagoreanTriple (HMul.hMul k x) (HMul.hMul k y) (HMul.hMul k z)) (PythagoreanTriple x y z)","decl":"/-- `(k*x, k*y, k*z)` is a Pythagorean triple if and only if\n`(x, y, z)` is also a triple. -/\ntheorem mul_iff (k : ℤ) (hk : k ≠ 0) :\n    PythagoreanTriple (k * x) (k * y) (k * z) ↔ PythagoreanTriple x y z := by\n  refine ⟨?_, fun h => h.mul k⟩\n  simp only [PythagoreanTriple]\n  intro h\n  rw [← mul_left_inj' (mul_ne_zero hk hk)]\n  convert h using 1 <;> ring\n\n"}
{"name":"PythagoreanTriple.mul_isClassified","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nk : Int\nhc : h.IsClassified\n⊢ ⋯.IsClassified","decl":"theorem mul_isClassified (k : ℤ) (hc : h.IsClassified) : (h.mul k).IsClassified := by\n  obtain ⟨l, m, n, ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co⟩⟩ := hc\n  · use k * l, m, n\n    apply And.intro _ co\n    left\n    constructor <;> ring\n  · use k * l, m, n\n    apply And.intro _ co\n    right\n    constructor <;> ring\n\n"}
{"name":"PythagoreanTriple.even_odd_of_coprime","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\n⊢ Or (And (Eq (HMod.hMod x 2) 0) (Eq (HMod.hMod y 2) 1)) (And (Eq (HMod.hMod x 2) 1) (Eq (HMod.hMod y 2) 0))","decl":"theorem even_odd_of_coprime (hc : Int.gcd x y = 1) :\n    x % 2 = 0 ∧ y % 2 = 1 ∨ x % 2 = 1 ∧ y % 2 = 0 := by\n  cases' Int.emod_two_eq_zero_or_one x with hx hx <;>\n    cases' Int.emod_two_eq_zero_or_one y with hy hy\n  -- x even, y even\n  · exfalso\n    apply Nat.not_coprime_of_dvd_of_dvd (by decide : 1 < 2) _ _ hc\n    · apply Int.natCast_dvd.1\n      apply Int.dvd_of_emod_eq_zero hx\n    · apply Int.natCast_dvd.1\n      apply Int.dvd_of_emod_eq_zero hy\n  -- x even, y odd\n  · left\n    exact ⟨hx, hy⟩\n  -- x odd, y even\n  · right\n    exact ⟨hx, hy⟩\n  -- x odd, y odd\n  · exfalso\n    obtain ⟨x0, y0, rfl, rfl⟩ : ∃ x0 y0, x = x0 * 2 + 1 ∧ y = y0 * 2 + 1 := by\n      cases' exists_eq_mul_left_of_dvd (Int.dvd_sub_of_emod_eq hx) with x0 hx2\n      cases' exists_eq_mul_left_of_dvd (Int.dvd_sub_of_emod_eq hy) with y0 hy2\n      rw [sub_eq_iff_eq_add] at hx2 hy2\n      exact ⟨x0, y0, hx2, hy2⟩\n    apply Int.sq_ne_two_mod_four z\n    rw [show z * z = 4 * (x0 * x0 + x0 + y0 * y0 + y0) + 2 by\n        rw [← h.eq]\n        ring]\n    simp only [Int.add_emod, Int.mul_emod_right, zero_add]\n    decide\n\n"}
{"name":"PythagoreanTriple.gcd_dvd","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\n⊢ Dvd.dvd (↑(x.gcd y)) z","decl":"theorem gcd_dvd : (Int.gcd x y : ℤ) ∣ z := by\n  by_cases h0 : Int.gcd x y = 0\n  · have hx : x = 0 := by\n      apply Int.natAbs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_left h0\n    have hy : y = 0 := by\n      apply Int.natAbs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_right h0\n    have hz : z = 0 := by\n      simpa only [PythagoreanTriple, hx, hy, add_zero, zero_eq_mul, mul_zero,\n        or_self_iff] using h\n    simp only [hz, dvd_zero]\n  obtain ⟨k, x0, y0, _, h2, rfl, rfl⟩ :\n    ∃ (k : ℕ) (x0 y0 : _), 0 < k ∧ Int.gcd x0 y0 = 1 ∧ x = x0 * k ∧ y = y0 * k :=\n    Int.exists_gcd_one' (Nat.pos_of_ne_zero h0)\n  rw [Int.gcd_mul_right, h2, Int.natAbs_ofNat, one_mul]\n  rw [← Int.pow_dvd_pow_iff two_ne_zero, sq z, ← h.eq]\n  rw [(by ring : x0 * k * (x0 * k) + y0 * k * (y0 * k) = (k : ℤ) ^ 2 * (x0 * x0 + y0 * y0))]\n  exact dvd_mul_right _ _\n\n"}
{"name":"PythagoreanTriple.normalize","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\n⊢ PythagoreanTriple (HDiv.hDiv x ↑(x.gcd y)) (HDiv.hDiv y ↑(x.gcd y)) (HDiv.hDiv z ↑(x.gcd y))","decl":"theorem normalize : PythagoreanTriple (x / Int.gcd x y) (y / Int.gcd x y) (z / Int.gcd x y) := by\n  by_cases h0 : Int.gcd x y = 0\n  · have hx : x = 0 := by\n      apply Int.natAbs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_left h0\n    have hy : y = 0 := by\n      apply Int.natAbs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_right h0\n    have hz : z = 0 := by\n      simpa only [PythagoreanTriple, hx, hy, add_zero, zero_eq_mul, mul_zero,\n        or_self_iff] using h\n    simp only [hx, hy, hz]\n    exact zero\n  rcases h.gcd_dvd with ⟨z0, rfl⟩\n  obtain ⟨k, x0, y0, k0, h2, rfl, rfl⟩ :\n    ∃ (k : ℕ) (x0 y0 : _), 0 < k ∧ Int.gcd x0 y0 = 1 ∧ x = x0 * k ∧ y = y0 * k :=\n    Int.exists_gcd_one' (Nat.pos_of_ne_zero h0)\n  have hk : (k : ℤ) ≠ 0 := by\n    norm_cast\n    rwa [pos_iff_ne_zero] at k0\n  rw [Int.gcd_mul_right, h2, Int.natAbs_ofNat, one_mul] at h ⊢\n  rw [mul_comm x0, mul_comm y0, mul_iff k hk] at h\n  rwa [Int.mul_ediv_cancel _ hk, Int.mul_ediv_cancel _ hk, Int.mul_ediv_cancel_left _ hk]\n\n"}
{"name":"PythagoreanTriple.isClassified_of_isPrimitiveClassified","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhp : h.IsPrimitiveClassified\n⊢ h.IsClassified","decl":"theorem isClassified_of_isPrimitiveClassified (hp : h.IsPrimitiveClassified) : h.IsClassified := by\n  obtain ⟨m, n, H⟩ := hp\n  use 1, m, n\n  omega\n\n"}
{"name":"PythagoreanTriple.isClassified_of_normalize_isPrimitiveClassified","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : ⋯.IsPrimitiveClassified\n⊢ h.IsClassified","decl":"theorem isClassified_of_normalize_isPrimitiveClassified (hc : h.normalize.IsPrimitiveClassified) :\n    h.IsClassified := by\n  convert h.normalize.mul_isClassified (Int.gcd x y)\n        (isClassified_of_isPrimitiveClassified h.normalize hc) <;>\n    rw [Int.mul_ediv_cancel']\n  · exact Int.gcd_dvd_left\n  · exact Int.gcd_dvd_right\n  · exact h.gcd_dvd\n\n"}
{"name":"PythagoreanTriple.ne_zero_of_coprime","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\n⊢ Ne z 0","decl":"theorem ne_zero_of_coprime (hc : Int.gcd x y = 1) : z ≠ 0 := by\n  suffices 0 < z * z by\n    rintro rfl\n    norm_num at this\n  rw [← h.eq, ← sq, ← sq]\n  have hc' : Int.gcd x y ≠ 0 := by\n    rw [hc]\n    exact one_ne_zero\n  cases' Int.ne_zero_of_gcd hc' with hxz hyz\n  · apply lt_add_of_pos_of_le (sq_pos_of_ne_zero hxz) (sq_nonneg y)\n  · apply lt_add_of_le_of_pos (sq_nonneg x) (sq_pos_of_ne_zero hyz)\n\n"}
{"name":"PythagoreanTriple.isPrimitiveClassified_of_coprime_of_zero_left","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\nhx : Eq x 0\n⊢ h.IsPrimitiveClassified","decl":"theorem isPrimitiveClassified_of_coprime_of_zero_left (hc : Int.gcd x y = 1) (hx : x = 0) :\n    h.IsPrimitiveClassified := by\n  subst x\n  change Nat.gcd 0 (Int.natAbs y) = 1 at hc\n  rw [Nat.gcd_zero_left (Int.natAbs y)] at hc\n  cases' Int.natAbs_eq y with hy hy\n  · use 1, 0\n    rw [hy, hc, Int.gcd_zero_right]\n    decide\n  · use 0, 1\n    rw [hy, hc, Int.gcd_zero_left]\n    decide\n\n"}
{"name":"PythagoreanTriple.coprime_of_coprime","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\n⊢ Eq (y.gcd z) 1","decl":"theorem coprime_of_coprime (hc : Int.gcd x y = 1) : Int.gcd y z = 1 := by\n  by_contra H\n  obtain ⟨p, hp, hpy, hpz⟩ := Nat.Prime.not_coprime_iff_dvd.mp H\n  apply hp.not_dvd_one\n  rw [← hc]\n  apply Nat.dvd_gcd (Int.Prime.dvd_natAbs_of_coe_dvd_sq hp _ _) hpy\n  rw [sq, eq_sub_of_add_eq h]\n  rw [← Int.natCast_dvd] at hpy hpz\n  exact dvd_sub (hpz.mul_right _) (hpy.mul_right _)\n\n"}
{"name":"circleEquivGen_apply","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"K : Type u_1\ninst✝ : Field K\nhk : ∀ (x : K), Ne (HAdd.hAdd 1 (HPow.hPow x 2)) 0\nx : K\n⊢ Eq ↑((circleEquivGen hk) x) { fst := HDiv.hDiv (HMul.hMul 2 x) (HAdd.hAdd 1 (HPow.hPow x 2)), snd := HDiv.hDiv (HSub.hSub 1 (HPow.hPow x 2)) (HAdd.hAdd 1 (HPow.hPow x 2)) }","decl":"@[simp]\ntheorem circleEquivGen_apply (hk : ∀ x : K, 1 + x ^ 2 ≠ 0) (x : K) :\n    (circleEquivGen hk x : K × K) = ⟨2 * x / (1 + x ^ 2), (1 - x ^ 2) / (1 + x ^ 2)⟩ :=\n  rfl\n\n"}
{"name":"circleEquivGen_symm_apply","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"K : Type u_1\ninst✝ : Field K\nhk : ∀ (x : K), Ne (HAdd.hAdd 1 (HPow.hPow x 2)) 0\nv : Subtype fun p => And (Eq (HAdd.hAdd (HPow.hPow p.1 2) (HPow.hPow p.2 2)) 1) (Ne p.2 (-1))\n⊢ Eq ((circleEquivGen hk).symm v) (HDiv.hDiv (↑v).1 (HAdd.hAdd (↑v).2 1))","decl":"@[simp]\ntheorem circleEquivGen_symm_apply (hk : ∀ x : K, 1 + x ^ 2 ≠ 0)\n    (v : { p : K × K // p.1 ^ 2 + p.2 ^ 2 = 1 ∧ p.2 ≠ -1 }) :\n    (circleEquivGen hk).symm v = (v : K × K).1 / ((v : K × K).2 + 1) :=\n  rfl\n\n"}
{"name":"PythagoreanTriple.isPrimitiveClassified_aux","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\nhzpos : LT.lt 0 z\nm n : Int\nhm2n2 : LT.lt 0 (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2))\nhv2 : Eq (HDiv.hDiv ↑x ↑z) (HDiv.hDiv (HMul.hMul (HMul.hMul 2 ↑m) ↑n) (HAdd.hAdd (HPow.hPow (↑m) 2) (HPow.hPow (↑n) 2)))\nhw2 : Eq (HDiv.hDiv ↑y ↑z) (HDiv.hDiv (HSub.hSub (HPow.hPow (↑m) 2) (HPow.hPow (↑n) 2)) (HAdd.hAdd (HPow.hPow (↑m) 2) (HPow.hPow (↑n) 2)))\nH : Eq ((HSub.hSub (HPow.hPow m 2) (HPow.hPow n 2)).gcd (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2))) 1\nco : Eq (m.gcd n) 1\npp : Or (And (Eq (HMod.hMod m 2) 0) (Eq (HMod.hMod n 2) 1)) (And (Eq (HMod.hMod m 2) 1) (Eq (HMod.hMod n 2) 0))\n⊢ h.IsPrimitiveClassified","decl":"theorem isPrimitiveClassified_aux (hc : x.gcd y = 1) (hzpos : 0 < z) {m n : ℤ}\n    (hm2n2 : 0 < m ^ 2 + n ^ 2) (hv2 : (x : ℚ) / z = 2 * m * n / ((m : ℚ) ^ 2 + (n : ℚ) ^ 2))\n    (hw2 : (y : ℚ) / z = ((m : ℚ) ^ 2 - (n : ℚ) ^ 2) / ((m : ℚ) ^ 2 + (n : ℚ) ^ 2))\n    (H : Int.gcd (m ^ 2 - n ^ 2) (m ^ 2 + n ^ 2) = 1) (co : Int.gcd m n = 1)\n    (pp : m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) : h.IsPrimitiveClassified := by\n  have hz : z ≠ 0 := ne_of_gt hzpos\n  have h2 : y = m ^ 2 - n ^ 2 ∧ z = m ^ 2 + n ^ 2 := by\n    apply Rat.div_int_inj hzpos hm2n2 (h.coprime_of_coprime hc) H\n    rw [hw2]\n    norm_cast\n  use m, n\n  apply And.intro _ (And.intro co pp)\n  right\n  refine ⟨?_, h2.left⟩\n  rw [← Rat.coe_int_inj _ _, ← div_left_inj' ((mt (Rat.coe_int_inj z 0).mp) hz), hv2, h2.right]\n  norm_cast\n\n"}
{"name":"PythagoreanTriple.isPrimitiveClassified_of_coprime_of_odd_of_pos","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\nhyo : Eq (HMod.hMod y 2) 1\nhzpos : LT.lt 0 z\n⊢ h.IsPrimitiveClassified","decl":"theorem isPrimitiveClassified_of_coprime_of_odd_of_pos (hc : Int.gcd x y = 1) (hyo : y % 2 = 1)\n    (hzpos : 0 < z) : h.IsPrimitiveClassified := by\n  by_cases h0 : x = 0\n  · exact h.isPrimitiveClassified_of_coprime_of_zero_left hc h0\n  let v := (x : ℚ) / z\n  let w := (y : ℚ) / z\n  have hq : v ^ 2 + w ^ 2 = 1 := by\n    field_simp [v, w, sq]\n    norm_cast\n  have hvz : v ≠ 0 := by\n    field_simp [v]\n    exact h0\n  have hw1 : w ≠ -1 := by\n    contrapose! hvz with hw1\n    -- Porting note: `contrapose` unfolds local names, refold them\n    replace hw1 : w = -1 := hw1; show v = 0\n    rw [hw1, neg_sq, one_pow, add_left_eq_self] at hq\n    exact pow_eq_zero hq\n  have hQ : ∀ x : ℚ, 1 + x ^ 2 ≠ 0 := by\n    intro q\n    apply ne_of_gt\n    exact lt_add_of_pos_of_le zero_lt_one (sq_nonneg q)\n  have hp : (⟨v, w⟩ : ℚ × ℚ) ∈ { p : ℚ × ℚ | p.1 ^ 2 + p.2 ^ 2 = 1 ∧ p.2 ≠ -1 } := ⟨hq, hw1⟩\n  let q := (circleEquivGen hQ).symm ⟨⟨v, w⟩, hp⟩\n  have ht4 : v = 2 * q / (1 + q ^ 2) ∧ w = (1 - q ^ 2) / (1 + q ^ 2) := by\n    apply Prod.mk.inj\n    exact congr_arg Subtype.val ((circleEquivGen hQ).apply_symm_apply ⟨⟨v, w⟩, hp⟩).symm\n  let m := (q.den : ℤ)\n  let n := q.num\n  have hm0 : m ≠ 0 := by\n    -- Added to adapt to https://github.com/leanprover/lean4/pull/2734.\n    -- Without `unfold`, `norm_cast` can't see the coercion.\n    -- One might try `zeta := true` in `Tactic.NormCast.derive`,\n    -- but that seems to break many other things.\n    unfold m\n    norm_cast\n    apply Rat.den_nz q\n  have hq2 : q = n / m := (Rat.num_div_den q).symm\n  have hm2n2 : 0 < m ^ 2 + n ^ 2 := by positivity\n  have hm2n20 : (m ^ 2 + n ^ 2 : ℚ) ≠ 0 := by positivity\n  have hx1 {j k : ℚ} (h₁ : k ≠ 0) (h₂ : k ^ 2 + j ^ 2 ≠ 0) :\n      (1 - (j / k) ^ 2) / (1 + (j / k) ^ 2) = (k ^ 2 - j ^ 2) / (k ^ 2 + j ^ 2) := by\n    field_simp\n  have hw2 : w = ((m : ℚ) ^ 2 - (n : ℚ) ^ 2) / ((m : ℚ) ^ 2 + (n : ℚ) ^ 2) := by\n    calc\n      w = (1 - q ^ 2) / (1 + q ^ 2) := by apply ht4.2\n      _ = (1 - (↑n / ↑m) ^ 2) / (1 + (↑n / ↑m) ^ 2) := by rw [hq2]\n      _ = _ := by exact hx1 (Int.cast_ne_zero.mpr hm0) hm2n20\n  have hx2 {j k : ℚ} (h₁ : k ≠ 0) (h₂ : k ^ 2 + j ^ 2 ≠ 0) :\n      2 * (j / k) / (1 + (j / k) ^ 2) = 2 * k * j / (k ^ 2 + j ^ 2) :=\n    have h₃ : k * (k ^ 2 + j ^ 2) ≠ 0 := mul_ne_zero h₁ h₂\n    by field_simp; ring\n  have hv2 : v = 2 * m * n / ((m : ℚ) ^ 2 + (n : ℚ) ^ 2) := by\n    calc\n      v = 2 * q / (1 + q ^ 2) := by apply ht4.1\n      _ = 2 * (n / m) / (1 + (↑n / ↑m) ^ 2) := by rw [hq2]\n      _ = _ := by exact hx2 (Int.cast_ne_zero.mpr hm0) hm2n20\n  have hnmcp : Int.gcd n m = 1 := q.reduced\n  have hmncp : Int.gcd m n = 1 := by\n    rw [Int.gcd_comm]\n    exact hnmcp\n  cases' Int.emod_two_eq_zero_or_one m with hm2 hm2 <;>\n    cases' Int.emod_two_eq_zero_or_one n with hn2 hn2\n  · -- m even, n even\n    exfalso\n    have h1 : 2 ∣ (Int.gcd n m : ℤ) :=\n      Int.dvd_gcd (Int.dvd_of_emod_eq_zero hn2) (Int.dvd_of_emod_eq_zero hm2)\n    rw [hnmcp] at h1\n    revert h1\n    decide\n  · -- m even, n odd\n    apply h.isPrimitiveClassified_aux hc hzpos hm2n2 hv2 hw2 _ hmncp\n    · apply Or.intro_left\n      exact And.intro hm2 hn2\n    · apply coprime_sq_sub_sq_add_of_even_odd hmncp hm2 hn2\n  · -- m odd, n even\n    apply h.isPrimitiveClassified_aux hc hzpos hm2n2 hv2 hw2 _ hmncp\n    · apply Or.intro_right\n      exact And.intro hm2 hn2\n    apply coprime_sq_sub_sq_add_of_odd_even hmncp hm2 hn2\n  · -- m odd, n odd\n    exfalso\n    have h1 :\n      2 ∣ m ^ 2 + n ^ 2 ∧\n        2 ∣ m ^ 2 - n ^ 2 ∧\n          (m ^ 2 - n ^ 2) / 2 % 2 = 0 ∧ Int.gcd ((m ^ 2 - n ^ 2) / 2) ((m ^ 2 + n ^ 2) / 2) = 1 :=\n      coprime_sq_sub_sq_sum_of_odd_odd hmncp hm2 hn2\n    have h2 : y = (m ^ 2 - n ^ 2) / 2 ∧ z = (m ^ 2 + n ^ 2) / 2 := by\n      apply Rat.div_int_inj hzpos _ (h.coprime_of_coprime hc) h1.2.2.2\n      · show w = _\n        rw [← Rat.divInt_eq_div, ← Rat.divInt_mul_right (by norm_num : (2 : ℤ) ≠ 0)]\n        rw [Int.ediv_mul_cancel h1.1, Int.ediv_mul_cancel h1.2.1, hw2, Rat.divInt_eq_div]\n        norm_cast\n      · apply (mul_lt_mul_right (by norm_num : 0 < (2 : ℤ))).mp\n        rw [Int.ediv_mul_cancel h1.1, zero_mul]\n        exact hm2n2\n    norm_num [h2.1, h1.2.2.1] at hyo\n\n"}
{"name":"PythagoreanTriple.isPrimitiveClassified_of_coprime_of_pos","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\nhzpos : LT.lt 0 z\n⊢ h.IsPrimitiveClassified","decl":"theorem isPrimitiveClassified_of_coprime_of_pos (hc : Int.gcd x y = 1) (hzpos : 0 < z) :\n    h.IsPrimitiveClassified := by\n  cases' h.even_odd_of_coprime hc with h1 h2\n  · exact h.isPrimitiveClassified_of_coprime_of_odd_of_pos hc h1.right hzpos\n  rw [Int.gcd_comm] at hc\n  obtain ⟨m, n, H⟩ := h.symm.isPrimitiveClassified_of_coprime_of_odd_of_pos hc h2.left hzpos\n  use m, n; tauto\n\n"}
{"name":"PythagoreanTriple.isPrimitiveClassified_of_coprime","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nhc : Eq (x.gcd y) 1\n⊢ h.IsPrimitiveClassified","decl":"theorem isPrimitiveClassified_of_coprime (hc : Int.gcd x y = 1) : h.IsPrimitiveClassified := by\n  by_cases hz : 0 < z\n  · exact h.isPrimitiveClassified_of_coprime_of_pos hc hz\n  have h' : PythagoreanTriple x y (-z) := by simpa [PythagoreanTriple, neg_mul_neg] using h.eq\n  apply h'.isPrimitiveClassified_of_coprime_of_pos hc\n  apply lt_of_le_of_ne _ (h'.ne_zero_of_coprime hc).symm\n  exact le_neg.mp (not_lt.mp hz)\n\n"}
{"name":"PythagoreanTriple.classified","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\n⊢ h.IsClassified","decl":"theorem classified : h.IsClassified := by\n  by_cases h0 : Int.gcd x y = 0\n  · have hx : x = 0 := by\n      apply Int.natAbs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_left h0\n    have hy : y = 0 := by\n      apply Int.natAbs_eq_zero.mp\n      apply Nat.eq_zero_of_gcd_eq_zero_right h0\n    use 0, 1, 0\n    field_simp [hx, hy]\n  apply h.isClassified_of_normalize_isPrimitiveClassified\n  apply h.normalize.isPrimitiveClassified_of_coprime\n  apply Int.gcd_div_gcd_div_gcd (Nat.pos_of_ne_zero h0)\n\n"}
{"name":"PythagoreanTriple.coprime_classification","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\n⊢ Iff (And (PythagoreanTriple x y z) (Eq (x.gcd y) 1)) (Exists fun m => Exists fun n => And (Or (And (Eq x (HSub.hSub (HPow.hPow m 2) (HPow.hPow n 2))) (Eq y (HMul.hMul (HMul.hMul 2 m) n))) (And (Eq x (HMul.hMul (HMul.hMul 2 m) n)) (Eq y (HSub.hSub (HPow.hPow m 2) (HPow.hPow n 2))))) (And (Or (Eq z (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2))) (Eq z (Neg.neg (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2))))) (And (Eq (m.gcd n) 1) (Or (And (Eq (HMod.hMod m 2) 0) (Eq (HMod.hMod n 2) 1)) (And (Eq (HMod.hMod m 2) 1) (Eq (HMod.hMod n 2) 0))))))","decl":"theorem coprime_classification :\n    PythagoreanTriple x y z ∧ Int.gcd x y = 1 ↔\n      ∃ m n,\n        (x = m ^ 2 - n ^ 2 ∧ y = 2 * m * n ∨ x = 2 * m * n ∧ y = m ^ 2 - n ^ 2) ∧\n          (z = m ^ 2 + n ^ 2 ∨ z = -(m ^ 2 + n ^ 2)) ∧\n            Int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) := by\n  constructor\n  · intro h\n    obtain ⟨m, n, H⟩ := h.left.isPrimitiveClassified_of_coprime h.right\n    use m, n\n    rcases H with ⟨⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, co, pp⟩\n    · refine ⟨Or.inl ⟨rfl, rfl⟩, ?_, co, pp⟩\n      have : z ^ 2 = (m ^ 2 + n ^ 2) ^ 2 := by\n        rw [sq, ← h.left.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n    · refine ⟨Or.inr ⟨rfl, rfl⟩, ?_, co, pp⟩\n      have : z ^ 2 = (m ^ 2 + n ^ 2) ^ 2 := by\n        rw [sq, ← h.left.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n  · delta PythagoreanTriple\n    rintro ⟨m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl, co, pp⟩ <;>\n      first\n      | constructor; ring; exact coprime_sq_sub_mul co pp\n      | constructor; ring; rw [Int.gcd_comm]; exact coprime_sq_sub_mul co pp\n\n"}
{"name":"PythagoreanTriple.coprime_classification'","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\nh : PythagoreanTriple x y z\nh_coprime : Eq (x.gcd y) 1\nh_parity : Eq (HMod.hMod x 2) 1\nh_pos : LT.lt 0 z\n⊢ Exists fun m => Exists fun n => And (Eq x (HSub.hSub (HPow.hPow m 2) (HPow.hPow n 2))) (And (Eq y (HMul.hMul (HMul.hMul 2 m) n)) (And (Eq z (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2))) (And (Eq (m.gcd n) 1) (And (Or (And (Eq (HMod.hMod m 2) 0) (Eq (HMod.hMod n 2) 1)) (And (Eq (HMod.hMod m 2) 1) (Eq (HMod.hMod n 2) 0))) (LE.le 0 m)))))","decl":"/-- by assuming `x` is odd and `z` is positive we get a slightly more precise classification of\nthe Pythagorean triple `x ^ 2 + y ^ 2 = z ^ 2`-/\ntheorem coprime_classification' {x y z : ℤ} (h : PythagoreanTriple x y z)\n    (h_coprime : Int.gcd x y = 1) (h_parity : x % 2 = 1) (h_pos : 0 < z) :\n    ∃ m n,\n      x = m ^ 2 - n ^ 2 ∧\n        y = 2 * m * n ∧\n          z = m ^ 2 + n ^ 2 ∧\n            Int.gcd m n = 1 ∧ (m % 2 = 0 ∧ n % 2 = 1 ∨ m % 2 = 1 ∧ n % 2 = 0) ∧ 0 ≤ m := by\n  obtain ⟨m, n, ht1, ht2, ht3, ht4⟩ :=\n    PythagoreanTriple.coprime_classification.mp (And.intro h h_coprime)\n  rcases le_or_lt 0 m with hm | hm\n  · use m, n\n    cases' ht1 with h_odd h_even\n    · apply And.intro h_odd.1\n      apply And.intro h_odd.2\n      cases' ht2 with h_pos h_neg\n      · apply And.intro h_pos (And.intro ht3 (And.intro ht4 hm))\n      · exfalso\n        revert h_pos\n        rw [h_neg]\n        exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))\n    exfalso\n    rcases h_even with ⟨rfl, -⟩\n    rw [mul_assoc, Int.mul_emod_right] at h_parity\n    exact zero_ne_one h_parity\n  · use -m, -n\n    cases' ht1 with h_odd h_even\n    · rw [neg_sq m]\n      rw [neg_sq n]\n      apply And.intro h_odd.1\n      constructor\n      · rw [h_odd.2]\n        ring\n      cases' ht2 with h_pos h_neg\n      · apply And.intro h_pos\n        constructor\n        · delta Int.gcd\n          rw [Int.natAbs_neg, Int.natAbs_neg]\n          exact ht3\n        · rw [Int.neg_emod_two, Int.neg_emod_two]\n          apply And.intro ht4\n          omega\n      · exfalso\n        revert h_pos\n        rw [h_neg]\n        exact imp_false.mpr (not_lt.mpr (neg_nonpos.mpr (add_nonneg (sq_nonneg m) (sq_nonneg n))))\n    exfalso\n    rcases h_even with ⟨rfl, -⟩\n    rw [mul_assoc, Int.mul_emod_right] at h_parity\n    exact zero_ne_one h_parity\n\n"}
{"name":"PythagoreanTriple.classification","module":"Mathlib.NumberTheory.PythagoreanTriples","initialProofState":"x y z : Int\n⊢ Iff (PythagoreanTriple x y z) (Exists fun k => Exists fun m => Exists fun n => And (Or (And (Eq x (HMul.hMul k (HSub.hSub (HPow.hPow m 2) (HPow.hPow n 2)))) (Eq y (HMul.hMul k (HMul.hMul (HMul.hMul 2 m) n)))) (And (Eq x (HMul.hMul k (HMul.hMul (HMul.hMul 2 m) n))) (Eq y (HMul.hMul k (HSub.hSub (HPow.hPow m 2) (HPow.hPow n 2)))))) (Or (Eq z (HMul.hMul k (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2)))) (Eq z (HMul.hMul (Neg.neg k) (HAdd.hAdd (HPow.hPow m 2) (HPow.hPow n 2))))))","decl":"/-- **Formula for Pythagorean Triples** -/\ntheorem classification :\n    PythagoreanTriple x y z ↔\n      ∃ k m n,\n        (x = k * (m ^ 2 - n ^ 2) ∧ y = k * (2 * m * n) ∨\n            x = k * (2 * m * n) ∧ y = k * (m ^ 2 - n ^ 2)) ∧\n          (z = k * (m ^ 2 + n ^ 2) ∨ z = -k * (m ^ 2 + n ^ 2)) := by\n  constructor\n  · intro h\n    obtain ⟨k, m, n, H⟩ := h.classified\n    use k, m, n\n    rcases H with (⟨rfl, rfl⟩ | ⟨rfl, rfl⟩)\n    · refine ⟨Or.inl ⟨rfl, rfl⟩, ?_⟩\n      have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2 := by\n        rw [sq, ← h.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n    · refine ⟨Or.inr ⟨rfl, rfl⟩, ?_⟩\n      have : z ^ 2 = (k * (m ^ 2 + n ^ 2)) ^ 2 := by\n        rw [sq, ← h.eq]\n        ring\n      simpa using eq_or_eq_neg_of_sq_eq_sq _ _ this\n  · rintro ⟨k, m, n, ⟨rfl, rfl⟩ | ⟨rfl, rfl⟩, rfl | rfl⟩ <;> delta PythagoreanTriple <;> ring\n\n"}
