{"name":"RCLike.instContinuousMapUniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâµ : RCLike ğ•œ\ninstâœâ´ : TopologicalSpace A\ninstâœÂ³ : T2Space A\ninstâœÂ² : Ring A\ninstâœÂ¹ : StarRing A\ninstâœ : Algebra ğ•œ A\nâŠ¢ ContinuousMap.UniqueHom ğ•œ A","decl":"instance (priority := 100) RCLike.instContinuousMapUniqueHom [TopologicalSpace A]\n    [T2Space A] [Ring A] [StarRing A] [Algebra ğ•œ A] :\n    ContinuousMap.UniqueHom ğ•œ A where\n  eq_of_continuous_of_map_id s _ Ï† Ïˆ hÏ† hÏˆ h :=\n    ContinuousMap.starAlgHom_ext_map_X hÏ† hÏˆ <| by\n      convert h using 1\n      all_goals exact congr_arg _ (by ext; simp)\n\n"}
{"name":"Real.instContinuousMapUniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninstâœâ´ : TopologicalSpace A\ninstâœÂ³ : T2Space A\ninstâœÂ² : Ring A\ninstâœÂ¹ : StarRing A\ninstâœ : Algebra Real A\nâŠ¢ ContinuousMap.UniqueHom Real A","decl":"instance Real.instContinuousMapUniqueHom [TopologicalSpace A]\n    [T2Space A] [Ring A] [StarRing A] [Algebra â„ A] :\n    ContinuousMap.UniqueHom â„ A :=\n  inferInstance\n\n"}
{"name":"Complex.instContinuousMapUniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninstâœâ´ : TopologicalSpace A\ninstâœÂ³ : T2Space A\ninstâœÂ² : Ring A\ninstâœÂ¹ : StarRing A\ninstâœ : Algebra Complex A\nâŠ¢ ContinuousMap.UniqueHom Complex A","decl":"instance Complex.instContinuousMapUniqueHom [TopologicalSpace A]\n    [T2Space A] [Ring A] [StarRing A] [Algebra â„‚ A] :\n    ContinuousMap.UniqueHom â„‚ A :=\n  inferInstance\n\n"}
{"name":"ContinuousMap.continuous_toNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Continuous ContinuousMap.toNNReal","decl":"@[fun_prop]\nlemma continuous_toNNReal : Continuous (toNNReal (X := X)) := continuous_postcomp _\n\n"}
{"name":"ContinuousMap.toNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf : ContinuousMap X Real\nx : X\nâŠ¢ Eq (f.toNNReal x) (f x).toNNReal","decl":"@[simp]\nlemma toNNReal_apply (f : C(X, â„)) (x : X) : f.toNNReal x = (f x).toNNReal := rfl\n\n"}
{"name":"ContinuousMap.toNNReal_add_add_neg_add_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf g : ContinuousMap X Real\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd f g).toNNReal (Neg.neg f).toNNReal) (Neg.neg g).toNNReal) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HAdd.hAdd f g)).toNNReal f.toNNReal) g.toNNReal)","decl":"lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, â„)) :\n    (f + g).toNNReal + (-f).toNNReal + (-g).toNNReal =\n      (-(f + g)).toNNReal + f.toNNReal + g.toNNReal := by\n  ext x\n  simp [max_neg_zero, -neg_add_rev]\n  abel\n\n"}
{"name":"ContinuousMap.toNNReal_mul_add_neg_mul_add_mul_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nf g : ContinuousMap X Real\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul f g).toNNReal (HMul.hMul (Neg.neg f).toNNReal g.toNNReal)) (HMul.hMul f.toNNReal (Neg.neg g).toNNReal)) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HMul.hMul f g)).toNNReal (HMul.hMul f.toNNReal g.toNNReal)) (HMul.hMul (Neg.neg f).toNNReal (Neg.neg g).toNNReal))","decl":"lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, â„)) :\n    (f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal =\n      (-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal := by\n  ext x\n  simp [max_neg_zero, add_mul, mul_add]\n  abel\n\n"}
{"name":"ContinuousMap.toNNReal_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nr : NNReal\nâŠ¢ Eq ((algebraMap Real (ContinuousMap X Real)) â†‘r).toNNReal ((algebraMap NNReal (ContinuousMap X NNReal)) r)","decl":"@[simp]\nlemma toNNReal_algebraMap (r : â„â‰¥0) :\n    (algebraMap â„ C(X, â„) r).toNNReal = algebraMap â„â‰¥0 C(X, â„â‰¥0) r := by\n  ext; simp\n\n"}
{"name":"ContinuousMap.toNNReal_neg_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nr : NNReal\nâŠ¢ Eq (Neg.neg ((algebraMap Real (ContinuousMap X Real)) â†‘r)).toNNReal 0","decl":"@[simp]\nlemma toNNReal_neg_algebraMap (r : â„â‰¥0) : (- algebraMap â„ C(X, â„) r).toNNReal = 0 := by\n  ext; simp\n\n"}
{"name":"ContinuousMap.toNNReal_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Eq (ContinuousMap.toNNReal 1) 1","decl":"@[simp]\nlemma toNNReal_one : (1 : C(X, â„)).toNNReal = 1 := toNNReal_algebraMap 1\n\n"}
{"name":"ContinuousMap.toNNReal_neg_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœ : TopologicalSpace X\nâŠ¢ Eq (-1).toNNReal 0","decl":"@[simp]\nlemma toNNReal_neg_one : (-1 : C(X, â„)).toNNReal = 0 := toNNReal_neg_algebraMap 1\n\n"}
{"name":"StarAlgHom.realContinuousMapOfNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\nA : Type u_2\ninstâœÂ² : Ring A\ninstâœÂ¹ : StarRing A\ninstâœ : Algebra Real A\nÏ† : StarAlgHom NNReal (ContinuousMap X NNReal) A\nf : ContinuousMap X Real\nâŠ¢ Eq (Ï†.realContinuousMapOfNNReal f) (HSub.hSub (Ï† f.toNNReal) (Ï† (Neg.neg f).toNNReal))","decl":"/-- Given a star `â„â‰¥0`-algebra homomorphism `Ï†` from `C(X, â„â‰¥0)` into an `â„`-algebra `A`, this is\nthe unique extension of `Ï†` from `C(X, â„)` to `A` as a star `â„`-algebra homomorphism. -/\n@[simps]\nnoncomputable def realContinuousMapOfNNReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A) :\n    C(X, â„) â†’â‹†â‚[â„] A where\n  toFun f := Ï† f.toNNReal - Ï† (-f).toNNReal\n  map_one' := by simp\n  map_zero' := by simp\n  map_mul' f g := by\n    have := congr(Ï† $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))\n    simp only [map_add, map_mul, sub_mul, mul_sub] at this âŠ¢\n    rw [â† sub_eq_zero] at this âŠ¢\n    convert this using 1\n    abel\n  map_add' f g := by\n    have := congr(Ï† $(f.toNNReal_add_add_neg_add_neg_eq g))\n    simp only [map_add] at this âŠ¢\n    rw [â† sub_eq_zero] at this âŠ¢\n    convert this using 1\n    abel\n  commutes' r := by\n    simp only\n    obtain (hr | hr) := le_total 0 r\n    Â· lift r to â„â‰¥0 using hr\n      simpa only [ContinuousMap.toNNReal_algebraMap, ContinuousMap.toNNReal_neg_algebraMap,\n        map_zero, sub_zero] using AlgHomClass.commutes Ï† r\n    Â· rw [â† neg_neg r, â† map_neg, neg_neg (-r)]\n      rw [â† neg_nonneg] at hr\n      lift -r to â„â‰¥0 using hr with r\n      simpa only [map_neg, ContinuousMap.toNNReal_neg_algebraMap, map_zero,\n        ContinuousMap.toNNReal_algebraMap, zero_sub, neg_inj] using AlgHomClass.commutes Ï† r\n  map_star' f := by simp only [star_trivial, star_sub, â† map_star]\n\n"}
{"name":"StarAlgHom.continuous_realContinuousMapOfNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœâµ : TopologicalSpace X\nA : Type u_2\ninstâœâ´ : Ring A\ninstâœÂ³ : StarRing A\ninstâœÂ² : Algebra Real A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : TopologicalRing A\nÏ† : StarAlgHom NNReal (ContinuousMap X NNReal) A\nhÏ† : Continuous â‡‘Ï†\nâŠ¢ Continuous â‡‘Ï†.realContinuousMapOfNNReal","decl":"@[fun_prop]\nlemma continuous_realContinuousMapOfNNReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A)\n    (hÏ† : Continuous Ï†) : Continuous Ï†.realContinuousMapOfNNReal := by\n  simp [realContinuousMapOfNNReal]\n  fun_prop\n\n"}
{"name":"StarAlgHom.realContinuousMapOfNNReal_apply_comp_toReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\nA : Type u_2\ninstâœÂ² : Ring A\ninstâœÂ¹ : StarRing A\ninstâœ : Algebra Real A\nÏ† : StarAlgHom NNReal (ContinuousMap X NNReal) A\nf : ContinuousMap X NNReal\nâŠ¢ Eq (Ï†.realContinuousMapOfNNReal ({ toFun := NNReal.toReal, continuous_toFun := NNReal.continuous_coe }.comp f)) (Ï† f)","decl":"@[simp high]\nlemma realContinuousMapOfNNReal_apply_comp_toReal (Ï† : C(X, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A)\n    (f : C(X, â„â‰¥0)) :\n    Ï†.realContinuousMapOfNNReal ((ContinuousMap.mk toReal continuous_coe).comp f) = Ï† f := by\n  simp only [realContinuousMapOfNNReal_apply]\n  convert_to Ï† f - Ï† 0 = Ï† f using 2\n  on_goal -1 => rw [map_zero, sub_zero]\n  all_goals\n    congr\n    ext x\n    simp\n\n"}
{"name":"StarAlgHom.realContinuousMapOfNNReal_injective","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ³ : TopologicalSpace X\nA : Type u_2\ninstâœÂ² : Ring A\ninstâœÂ¹ : StarRing A\ninstâœ : Algebra Real A\nâŠ¢ Function.Injective StarAlgHom.realContinuousMapOfNNReal","decl":"lemma realContinuousMapOfNNReal_injective :\n    Function.Injective (realContinuousMapOfNNReal (X := X) (A := A)) := by\n  intro Ï† Ïˆ h\n  ext f\n  simpa using congr($(h) ((ContinuousMap.mk toReal continuous_coe).comp f))\n\n"}
{"name":"NNReal.instContinuousMap.UniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninstâœâ´ : Ring A\ninstâœÂ³ : StarRing A\ninstâœÂ² : Algebra Real A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : T2Space A\nâŠ¢ ContinuousMap.UniqueHom NNReal A","decl":"instance NNReal.instContinuousMap.UniqueHom [T2Space A] :\n    ContinuousMap.UniqueHom â„â‰¥0 A where\n  eq_of_continuous_of_map_id s hs Ï† Ïˆ hÏ† hÏˆ h := by\n    let s' : Set â„ := (â†‘) '' s\n    let e : s â‰ƒâ‚œ s' :=\n      { toFun := Subtype.map (â†‘) (by simp [s'])\n        invFun := Subtype.map Real.toNNReal (by simp [s'])\n        left_inv := fun _ â†¦ by ext; simp\n        right_inv := fun x â†¦ by\n          ext\n          obtain âŸ¨y, -, hyâŸ© := x.2\n          simpa using hy â–¸ NNReal.coe_nonneg y\n        continuous_toFun := continuous_coe.subtype_map (by simp [s'])\n        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }\n    have (Î¾ : C(s, â„â‰¥0) â†’â‹†â‚[â„â‰¥0] A) (hÎ¾ : Continuous Î¾) :\n        (let Î¾' := Î¾.realContinuousMapOfNNReal.comp <| ContinuousMap.compStarAlgHom' â„ â„ e\n        Continuous Î¾' âˆ§ Î¾' (.restrict s' <| .id â„) = Î¾ (.restrict s <| .id â„â‰¥0)) := by\n      intro Î¾'\n      refine âŸ¨Î¾.continuous_realContinuousMapOfNNReal hÎ¾ |>.comp <|\n        ContinuousMap.continuous_precomp _, ?_âŸ©\n      exact Î¾.realContinuousMapOfNNReal_apply_comp_toReal (.restrict s <| .id â„â‰¥0)\n    obtain âŸ¨hÏ†', hÏ†_idâŸ© := this Ï† hÏ†\n    obtain âŸ¨hÏˆ', hÏˆ_idâŸ© := this Ïˆ hÏˆ\n    have hs' : CompactSpace s' := e.compactSpace\n    have h' := ContinuousMap.UniqueHom.eq_of_continuous_of_map_id s' _ _ hÏ†' hÏˆ'\n      (hÏ†_id â–¸ hÏˆ_id â–¸ h)\n    have h'' := congr($(h').comp <| ContinuousMap.compStarAlgHom' â„ â„ (e.symm : C(s', s)))\n    have : (ContinuousMap.compStarAlgHom' â„ â„ (e : C(s, s'))).comp\n        (ContinuousMap.compStarAlgHom' â„ â„ (e.symm : C(s', s))) = StarAlgHom.id _ _ := by\n      ext1; simp\n    simp only [StarAlgHom.comp_assoc, this, StarAlgHom.comp_id] at h''\n    exact StarAlgHom.realContinuousMapOfNNReal_injective h''\n\n"}
{"name":"RCLike.uniqueNonUnitalContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"ğ•œ : Type u_1\nA : Type u_2\ninstâœâ· : RCLike ğ•œ\ninstâœâ¶ : TopologicalSpace A\ninstâœâµ : T2Space A\ninstâœâ´ : NonUnitalRing A\ninstâœÂ³ : StarRing A\ninstâœÂ² : Module ğ•œ A\ninstâœÂ¹ : IsScalarTower ğ•œ A A\ninstâœ : SMulCommClass ğ•œ A A\nâŠ¢ ContinuousMapZero.UniqueHom ğ•œ A","decl":"open NonUnitalStarAlgebra in\ninstance RCLike.uniqueNonUnitalContinuousFunctionalCalculus\n    [TopologicalSpace A] [T2Space A] [NonUnitalRing A] [StarRing A] [Module ğ•œ A]\n    [IsScalarTower ğ•œ A A] [SMulCommClass ğ•œ A A] :\n    ContinuousMapZero.UniqueHom ğ•œ A where\n  eq_of_continuous_of_map_id s hs _inst h0 Ï† Ïˆ hÏ† hÏˆ h := by\n    rw [DFunLike.ext'_iff, â† Set.eqOn_univ, â† (ContinuousMapZero.adjoin_id_dense h0).closure_eq]\n    refine Set.EqOn.closure (fun f hf â†¦ ?_) hÏ† hÏˆ\n    rw [â† NonUnitalStarAlgHom.mem_equalizer]\n    apply adjoin_le ?_ hf\n    rw [Set.singleton_subset_iff]\n    exact h\n\n"}
{"name":"ContinuousMapZero.toNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nf : ContinuousMapZero X Real\nx : X\nâŠ¢ Eq (f.toNNReal x) (f x).toNNReal","decl":"@[simp]\nlemma toNNReal_apply (f : C(X, â„)â‚€) (x : X) : f.toNNReal x = Real.toNNReal (f x) := rfl\n\n"}
{"name":"ContinuousMapZero.continuous_toNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nâŠ¢ Continuous ContinuousMapZero.toNNReal","decl":"@[fun_prop]\nlemma continuous_toNNReal : Continuous (toNNReal (X := X)) := by\n  rw [continuous_induced_rng]\n  convert_to Continuous (ContinuousMap.toNNReal âˆ˜ ((â†‘) : C(X, â„)â‚€ â†’ C(X, â„))) using 1\n  exact ContinuousMap.continuous_postcomp _ |>.comp continuous_induced_dom\n\n"}
{"name":"ContinuousMapZero.toContinuousMapHom_toNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nf : ContinuousMapZero X Real\nâŠ¢ Eq (ContinuousMapZero.toContinuousMapHom f).toNNReal (ContinuousMapZero.toContinuousMapHom f.toNNReal)","decl":"lemma toContinuousMapHom_toNNReal (f : C(X, â„)â‚€) :\n    (toContinuousMapHom (X := X) (R := â„) f).toNNReal =\n      toContinuousMapHom (X := X) (R := â„â‰¥0) f.toNNReal :=\n  rfl\n\n"}
{"name":"ContinuousMapZero.toNNReal_smul","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nr : NNReal\nf : ContinuousMapZero X Real\nâŠ¢ Eq (HSMul.hSMul r f).toNNReal (HSMul.hSMul r f.toNNReal)","decl":"@[simp]\nlemma toNNReal_smul (r : â„â‰¥0) (f : C(X, â„)â‚€) : (r â€¢ f).toNNReal = r â€¢ f.toNNReal := by\n  ext x\n  by_cases h : 0 â‰¤ f x\n  Â· simpa [max_eq_left h, NNReal.smul_def] using mul_nonneg r.coe_nonneg h\n  Â· push_neg at h\n    simpa [max_eq_right h.le, NNReal.smul_def]\n      using mul_nonpos_of_nonneg_of_nonpos r.coe_nonneg h.le\n\n"}
{"name":"ContinuousMapZero.toNNReal_neg_smul","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nr : NNReal\nf : ContinuousMapZero X Real\nâŠ¢ Eq (Neg.neg (HSMul.hSMul r f)).toNNReal (HSMul.hSMul r (Neg.neg f).toNNReal)","decl":"@[simp]\nlemma toNNReal_neg_smul (r : â„â‰¥0) (f : C(X, â„)â‚€) : (-(r â€¢ f)).toNNReal = r â€¢ (-f).toNNReal := by\n  rw [NNReal.smul_def, â† smul_neg, â† NNReal.smul_def, toNNReal_smul]\n\n"}
{"name":"ContinuousMapZero.toNNReal_mul_add_neg_mul_add_mul_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nf g : ContinuousMapZero X Real\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul f g).toNNReal (HMul.hMul (Neg.neg f).toNNReal g.toNNReal)) (HMul.hMul f.toNNReal (Neg.neg g).toNNReal)) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HMul.hMul f g)).toNNReal (HMul.hMul f.toNNReal g.toNNReal)) (HMul.hMul (Neg.neg f).toNNReal (Neg.neg g).toNNReal))","decl":"lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, â„)â‚€) :\n    ((f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal) =\n    ((-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal) := by\n  apply toContinuousMap_injective\n  simpa only [â† toContinuousMapHom_apply, map_add, map_mul, map_neg, toContinuousMapHom_toNNReal]\n    using (f : C(X, â„)).toNNReal_mul_add_neg_mul_add_mul_neg_eq g\n\n"}
{"name":"ContinuousMapZero.toNNReal_add_add_neg_add_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœÂ¹ : TopologicalSpace X\ninstâœ : Zero X\nf g : ContinuousMapZero X Real\nâŠ¢ Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd f g).toNNReal (Neg.neg f).toNNReal) (Neg.neg g).toNNReal) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HAdd.hAdd f g)).toNNReal f.toNNReal) g.toNNReal)","decl":"lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, â„)â‚€) :\n    ((f + g).toNNReal + (-f).toNNReal + (-g).toNNReal) =\n      ((-(f + g)).toNNReal + f.toNNReal + g.toNNReal) := by\n  apply toContinuousMap_injective\n  simpa only [â† toContinuousMapHom_apply, map_add, map_mul, map_neg, toContinuousMapHom_toNNReal]\n    using (f : C(X, â„)).toNNReal_add_add_neg_add_neg_eq g\n\n"}
{"name":"NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Zero X\nA : Type u_2\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : StarRing A\ninstâœ : Module Real A\nÏ† : NonUnitalStarAlgHom NNReal (ContinuousMapZero X NNReal) A\nf : ContinuousMapZero X Real\nâŠ¢ Eq (Ï†.realContinuousMapZeroOfNNReal f) (HSub.hSub (Ï† f.toNNReal) (Ï† (Neg.neg f).toNNReal))","decl":"/-- Given a non-unital star `â„â‰¥0`-algebra homomorphism `Ï†` from `C(X, â„â‰¥0)â‚€` into a non-unital\n`â„`-algebra `A`, this is the unique extension of `Ï†` from `C(X, â„)â‚€` to `A` as a non-unital\nstar `â„`-algebra homomorphism. -/\n@[simps]\nnoncomputable def realContinuousMapZeroOfNNReal (Ï† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A) :\n    C(X, â„)â‚€ â†’â‹†â‚™â‚[â„] A where\n  toFun f := Ï† f.toNNReal - Ï† (-f).toNNReal\n  map_zero' := by simp\n  map_mul' f g := by\n    have := congr(Ï† $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))\n    simp only [map_add, map_mul, sub_mul, mul_sub] at this âŠ¢\n    rw [â† sub_eq_zero] at this âŠ¢\n    rw [â† this]\n    abel\n  map_add' f g := by\n    have := congr(Ï† $(f.toNNReal_add_add_neg_add_neg_eq g))\n    simp only [map_add, map_mul, sub_mul, mul_sub] at this âŠ¢\n    rw [â† sub_eq_zero] at this âŠ¢\n    rw [â† this]\n    abel\n  map_smul' r f := by\n    simp only [MonoidHom.id_apply]\n    by_cases hr : 0 â‰¤ r\n    Â· lift r to â„â‰¥0 using hr\n      simp only [â† smul_def, toNNReal_smul, map_smul, toNNReal_neg_smul, smul_sub]\n    Â· rw [not_le, â† neg_pos] at hr\n      rw [â† neg_smul]\n      nth_rw 1 [â† neg_neg r]\n      nth_rw 3 [â† neg_neg r]\n      lift -r to â„â‰¥0 using hr.le with r\n      simp only [neg_smul, â† smul_def, toNNReal_neg_smul, map_smul, toNNReal_smul, smul_sub,\n        sub_neg_eq_add]\n      rw [sub_eq_add_neg, add_comm]\n  map_star' f := by simp only [star_trivial, star_sub, â† map_star]\n\n"}
{"name":"NonUnitalStarAlgHom.continuous_realContinuousMapZeroOfNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœâ¶ : TopologicalSpace X\ninstâœâµ : Zero X\nA : Type u_2\ninstâœâ´ : NonUnitalRing A\ninstâœÂ³ : StarRing A\ninstâœÂ² : Module Real A\ninstâœÂ¹ : TopologicalSpace A\ninstâœ : TopologicalRing A\nÏ† : NonUnitalStarAlgHom NNReal (ContinuousMapZero X NNReal) A\nhÏ† : Continuous â‡‘Ï†\nâŠ¢ Continuous â‡‘Ï†.realContinuousMapZeroOfNNReal","decl":"@[fun_prop]\nlemma continuous_realContinuousMapZeroOfNNReal (Ï† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A)\n    (hÏ† : Continuous Ï†) : Continuous Ï†.realContinuousMapZeroOfNNReal := by\n  simp [realContinuousMapZeroOfNNReal]\n  fun_prop\n\n"}
{"name":"NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_apply_comp_toReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Zero X\nA : Type u_2\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : StarRing A\ninstâœ : Module Real A\nÏ† : NonUnitalStarAlgHom NNReal (ContinuousMapZero X NNReal) A\nf : ContinuousMapZero X NNReal\nâŠ¢ Eq (Ï†.realContinuousMapZeroOfNNReal ({ toFun := NNReal.toReal, continuous_toFun := NNReal.continuous_coe, map_zero' := â‹¯ }.comp f)) (Ï† f)","decl":"@[simp high]\nlemma realContinuousMapZeroOfNNReal_apply_comp_toReal (Ï† : C(X, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A)\n    (f : C(X, â„â‰¥0)â‚€) :\n    Ï†.realContinuousMapZeroOfNNReal ((ContinuousMapZero.mk âŸ¨toReal, continuous_coeâŸ© rfl).comp f) =\n      Ï† f := by\n  simp only [realContinuousMapZeroOfNNReal_apply]\n  convert_to Ï† f - Ï† 0 = Ï† f using 2\n  on_goal -1 => rw [map_zero, sub_zero]\n  all_goals\n    congr\n    ext x\n    simp\n\n"}
{"name":"NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_injective","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninstâœâ´ : TopologicalSpace X\ninstâœÂ³ : Zero X\nA : Type u_2\ninstâœÂ² : NonUnitalRing A\ninstâœÂ¹ : StarRing A\ninstâœ : Module Real A\nâŠ¢ Function.Injective NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal","decl":"lemma realContinuousMapZeroOfNNReal_injective :\n    Function.Injective (realContinuousMapZeroOfNNReal (X := X) (A := A)) := by\n  intro Ï† Ïˆ h\n  ext f\n  simpa using congr($(h) ((ContinuousMapZero.mk âŸ¨toReal, continuous_coeâŸ© rfl).comp f))\n\n"}
{"name":"NNReal.instContinuousMapZero.UniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninstâœâ· : NonUnitalRing A\ninstâœâ¶ : StarRing A\ninstâœâµ : Module Real A\ninstâœâ´ : TopologicalSpace A\ninstâœÂ³ : TopologicalRing A\ninstâœÂ² : IsScalarTower Real A A\ninstâœÂ¹ : SMulCommClass Real A A\ninstâœ : T2Space A\nâŠ¢ ContinuousMapZero.UniqueHom NNReal A","decl":"instance NNReal.instContinuousMapZero.UniqueHom\n    [TopologicalSpace A] [TopologicalRing A] [IsScalarTower â„ A A] [SMulCommClass â„ A A]\n    [T2Space A] :\n    ContinuousMapZero.UniqueHom â„â‰¥0 A where\n  eq_of_continuous_of_map_id s hs _inst h0 Ï† Ïˆ hÏ† hÏˆ h := by\n    let s' : Set â„ := (â†‘) '' s\n    let e : s â‰ƒâ‚œ s' :=\n      { toFun := Subtype.map (â†‘) (by simp [s'])\n        invFun := Subtype.map Real.toNNReal (by simp [s'])\n        left_inv := fun _ â†¦ by ext; simp\n        right_inv := fun x â†¦ by\n          ext\n          obtain âŸ¨y, -, hyâŸ© := x.2\n          simpa using hy â–¸ NNReal.coe_nonneg y\n        continuous_toFun := continuous_coe.subtype_map (by simp [s'])\n        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }\n    let _instâ‚ : Zero s' := âŸ¨0, âŸ¨0, h0 â–¸ Subtype.property (0 : s), coe_zeroâŸ©âŸ©\n    have h0' : ((0 : s') : â„) = 0 := rfl\n    have e0 : e 0 = 0 := by ext; simp [e, h0, h0']\n    have e0' : e.symm 0 = 0 := by\n      simpa only [Homeomorph.symm_apply_apply] using congr(e.symm $(e0)).symm\n    have (Î¾ : C(s, â„â‰¥0)â‚€ â†’â‹†â‚™â‚[â„â‰¥0] A) (hÎ¾ : Continuous Î¾) :\n        (let Î¾' := Î¾.realContinuousMapZeroOfNNReal.comp <|\n          ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨e, e0âŸ©;\n          Continuous Î¾' âˆ§ Î¾' (ContinuousMapZero.id h0') = Î¾ (ContinuousMapZero.id h0)) := by\n      intro Î¾'\n      refine âŸ¨Î¾.continuous_realContinuousMapZeroOfNNReal hÎ¾ |>.comp <| ?_, ?_âŸ©\n      Â· rw [continuous_induced_rng]\n        exact ContinuousMap.continuous_precomp _ |>.comp continuous_induced_dom\n      Â· exact Î¾.realContinuousMapZeroOfNNReal_apply_comp_toReal (.id h0)\n    obtain âŸ¨hÏ†', hÏ†_idâŸ© := this Ï† hÏ†\n    obtain âŸ¨hÏˆ', hÏˆ_idâŸ© := this Ïˆ hÏˆ\n    have hs' : CompactSpace s' := e.compactSpace\n    have : ContinuousMapZero.UniqueHom â„ A := inferInstance\n    have h' := ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id\n      s' h0' _ _ hÏ†' hÏˆ' (hÏ†_id â–¸ hÏˆ_id â–¸ h)\n    have h'' := congr($(h').comp <|\n      ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨(e.symm : C(s', s)), e0'âŸ©)\n    have : (ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨(e : C(s, s')), e0âŸ©).comp\n        (ContinuousMapZero.nonUnitalStarAlgHom_precomp â„ âŸ¨(e.symm : C(s', s)), e0'âŸ©) =\n        NonUnitalStarAlgHom.id _ _ := by\n      ext; simp\n    simp only [NonUnitalStarAlgHom.comp_assoc, this, NonUnitalStarAlgHom.comp_id] at h''\n    exact NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_injective h''\n\n"}
{"name":"NonUnitalStarAlgHomClass.map_cfcâ‚™","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A â†’ Prop\nq : B â†’ Prop\ninstâœÂ²â¹ : CommSemiring R\ninstâœÂ²â¸ : Nontrivial R\ninstâœÂ²â· : StarRing R\ninstâœÂ²â¶ : MetricSpace R\ninstâœÂ²âµ : TopologicalSemiring R\ninstâœÂ²â´ : ContinuousStar R\ninstâœÂ²Â³ : CommRing S\ninstâœÂ²Â² : Algebra R S\ninstâœÂ²Â¹ : NonUnitalRing A\ninstâœÂ²â° : StarRing A\ninstâœÂ¹â¹ : TopologicalSpace A\ninstâœÂ¹â¸ : Module R A\ninstâœÂ¹â· : IsScalarTower R A A\ninstâœÂ¹â¶ : SMulCommClass R A A\ninstâœÂ¹âµ : NonUnitalRing B\ninstâœÂ¹â´ : StarRing B\ninstâœÂ¹Â³ : TopologicalSpace B\ninstâœÂ¹Â² : Module R B\ninstâœÂ¹Â¹ : IsScalarTower R B B\ninstâœÂ¹â° : SMulCommClass R B B\ninstâœâ¹ : Module S A\ninstâœâ¸ : Module S B\ninstâœâ· : IsScalarTower R S A\ninstâœâ¶ : IsScalarTower R S B\ninstâœâµ : NonUnitalContinuousFunctionalCalculus R p\ninstâœâ´ : NonUnitalContinuousFunctionalCalculus R q\ninstâœÂ³ : ContinuousMapZero.UniqueHom R B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : NonUnitalAlgHomClass F S A B\ninstâœ : StarHomClass F A B\nÏ† : F\nf : R â†’ R\na : A\nhf : autoParam (ContinuousOn f (quasispectrum R a)) _autoâœ\nhfâ‚€ : autoParam (Eq (f 0) 0) _autoâœ\nhÏ† : autoParam (Continuous â‡‘Ï†) _autoâœ\nha : autoParam (p a) _autoâœ\nhÏ†a : autoParam (q (Ï† a)) _autoâœ\nâŠ¢ Eq (Ï† (cfcâ‚™ f a)) (cfcâ‚™ f (Ï† a))","decl":"include S in\n/-- Non-unital star algebra homomorphisms commute with the non-unital continuous functional\ncalculus. -/\nlemma NonUnitalStarAlgHomClass.map_cfcâ‚™ (Ï† : F) (f : R â†’ R) (a : A)\n    (hf : ContinuousOn f (quasispectrum R a) := by cfc_cont_tac)\n    (hfâ‚€ : f 0 = 0 := by cfc_zero_tac) (hÏ† : Continuous Ï† := by fun_prop) (ha : p a := by cfc_tac)\n    (hÏ†a : q (Ï† a) := by cfc_tac) : Ï† (cfcâ‚™ f a) = cfcâ‚™ f (Ï† a) := by\n  let Ïˆ : A â†’â‹†â‚™â‚[R] B := (Ï† : A â†’â‹†â‚™â‚[S] B).restrictScalars R\n  have : Continuous Ïˆ := hÏ†\n  have h_spec := NonUnitalAlgHom.quasispectrum_apply_subset' (R := R) S Ï† a\n  have hÏˆa : q (Ïˆ a) := hÏ†a\n  let Î¹ : C(quasispectrum R (Ïˆ a), quasispectrum R a)â‚€ :=\n    âŸ¨âŸ¨Set.inclusion h_spec, continuous_id.subtype_map h_specâŸ©, rflâŸ©\n  suffices Ïˆ.comp (cfcâ‚™Hom ha) =\n      (cfcâ‚™Hom hÏˆa).comp (ContinuousMapZero.nonUnitalStarAlgHom_precomp R Î¹) by\n    have hf' : ContinuousOn f (quasispectrum R (Ïˆ a)) := hf.mono h_spec\n    rw [cfcâ‚™_apply .., cfcâ‚™_apply ..]\n    exact DFunLike.congr_fun this _\n  refine ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id _ rfl _ _\n    ?_ ?_ ?apply_id\n  case apply_id =>\n    trans cfcâ‚™Hom hÏˆa âŸ¨.restrict (quasispectrum R (Ïˆ a)) (.id R), rflâŸ©\n    Â· simp [cfcâ‚™Hom_id]\n    Â· congr\n  all_goals\n    simp [ContinuousMapZero.nonUnitalStarAlgHom_precomp]\n    fun_prop\n\n"}
{"name":"NonUnitalStarAlgHom.map_cfcâ‚™","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"R : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A â†’ Prop\nq : B â†’ Prop\ninstâœÂ²â¶ : CommSemiring R\ninstâœÂ²âµ : Nontrivial R\ninstâœÂ²â´ : StarRing R\ninstâœÂ²Â³ : MetricSpace R\ninstâœÂ²Â² : TopologicalSemiring R\ninstâœÂ²Â¹ : ContinuousStar R\ninstâœÂ²â° : CommRing S\ninstâœÂ¹â¹ : Algebra R S\ninstâœÂ¹â¸ : NonUnitalRing A\ninstâœÂ¹â· : StarRing A\ninstâœÂ¹â¶ : TopologicalSpace A\ninstâœÂ¹âµ : Module R A\ninstâœÂ¹â´ : IsScalarTower R A A\ninstâœÂ¹Â³ : SMulCommClass R A A\ninstâœÂ¹Â² : NonUnitalRing B\ninstâœÂ¹Â¹ : StarRing B\ninstâœÂ¹â° : TopologicalSpace B\ninstâœâ¹ : Module R B\ninstâœâ¸ : IsScalarTower R B B\ninstâœâ· : SMulCommClass R B B\ninstâœâ¶ : Module S A\ninstâœâµ : Module S B\ninstâœâ´ : IsScalarTower R S A\ninstâœÂ³ : IsScalarTower R S B\ninstâœÂ² : NonUnitalContinuousFunctionalCalculus R p\ninstâœÂ¹ : NonUnitalContinuousFunctionalCalculus R q\ninstâœ : ContinuousMapZero.UniqueHom R B\nÏ† : NonUnitalStarAlgHom S A B\nf : R â†’ R\na : A\nhf : autoParam (ContinuousOn f (quasispectrum R a)) _autoâœ\nhfâ‚€ : autoParam (Eq (f 0) 0) _autoâœ\nhÏ† : autoParam (Continuous â‡‘Ï†) _autoâœ\nha : autoParam (p a) _autoâœ\nhÏ†a : autoParam (q (Ï† a)) _autoâœ\nâŠ¢ Eq (Ï† (cfcâ‚™ f a)) (cfcâ‚™ f (Ï† a))","decl":"/-- Non-unital star algebra homomorphisms commute with the non-unital continuous functional\ncalculus.  This version is specialized to `A â†’â‹†â‚™â‚[S] B` to allow for dot notation. -/\nlemma NonUnitalStarAlgHom.map_cfcâ‚™ (Ï† : A â†’â‹†â‚™â‚[S] B) (f : R â†’ R) (a : A)\n    (hf : ContinuousOn f (quasispectrum R a) := by cfc_cont_tac)\n    (hfâ‚€ : f 0 = 0 := by cfc_zero_tac) (hÏ† : Continuous Ï† := by fun_prop) (ha : p a := by cfc_tac)\n    (hÏ†a : q (Ï† a) := by cfc_tac) : Ï† (cfcâ‚™ f a) = cfcâ‚™ f (Ï† a) :=\n  NonUnitalStarAlgHomClass.map_cfcâ‚™ Ï† f a\n\n"}
{"name":"StarAlgHomClass.map_cfc","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A â†’ Prop\nq : B â†’ Prop\ninstâœÂ²â´ : CommSemiring R\ninstâœÂ²Â³ : StarRing R\ninstâœÂ²Â² : MetricSpace R\ninstâœÂ²Â¹ : TopologicalSemiring R\ninstâœÂ²â° : ContinuousStar R\ninstâœÂ¹â¹ : Ring A\ninstâœÂ¹â¸ : StarRing A\ninstâœÂ¹â· : TopologicalSpace A\ninstâœÂ¹â¶ : Algebra R A\ninstâœÂ¹âµ : Ring B\ninstâœÂ¹â´ : StarRing B\ninstâœÂ¹Â³ : TopologicalSpace B\ninstâœÂ¹Â² : Algebra R B\ninstâœÂ¹Â¹ : CommSemiring S\ninstâœÂ¹â° : Algebra R S\ninstâœâ¹ : Algebra S A\ninstâœâ¸ : Algebra S B\ninstâœâ· : IsScalarTower R S A\ninstâœâ¶ : IsScalarTower R S B\ninstâœâµ : ContinuousFunctionalCalculus R p\ninstâœâ´ : ContinuousFunctionalCalculus R q\ninstâœÂ³ : ContinuousMap.UniqueHom R B\ninstâœÂ² : FunLike F A B\ninstâœÂ¹ : AlgHomClass F S A B\ninstâœ : StarHomClass F A B\nÏ† : F\nf : R â†’ R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _autoâœ\nhÏ† : autoParam (Continuous â‡‘Ï†) _autoâœ\nha : autoParam (p a) _autoâœ\nhÏ†a : autoParam (q (Ï† a)) _autoâœ\nâŠ¢ Eq (Ï† (cfc f a)) (cfc f (Ï† a))","decl":"include S in\n/-- Star algebra homomorphisms commute with the continuous functional calculus. -/\nlemma StarAlgHomClass.map_cfc (Ï† : F) (f : R â†’ R) (a : A)\n    (hf : ContinuousOn f (spectrum R a) := by cfc_cont_tac)\n    (hÏ† : Continuous Ï† := by fun_prop) (ha : p a := by cfc_tac) (hÏ†a : q (Ï† a) := by cfc_tac) :\n    Ï† (cfc f a) = cfc f (Ï† a) := by\n  let Ïˆ : A â†’â‹†â‚[R] B := (Ï† : A â†’â‹†â‚[S] B).restrictScalars R\n  have : Continuous Ïˆ := hÏ†\n  have h_spec := AlgHom.spectrum_apply_subset Ïˆ a\n  have hÏˆa : q (Ïˆ a) := hÏ†a\n  let Î¹ : C(spectrum R (Ïˆ a), spectrum R a) :=\n    âŸ¨Set.inclusion h_spec, continuous_id.subtype_map h_specâŸ©\n  suffices Ïˆ.comp (cfcHom ha) = (cfcHom hÏˆa).comp (ContinuousMap.compStarAlgHom' R R Î¹) by\n    have hf' : ContinuousOn f (spectrum R (Ïˆ a)) := hf.mono h_spec\n    rw [cfc_apply .., cfc_apply ..]\n    congrm($(this) âŸ¨_, hf.restrictâŸ©)\n  refine ContinuousMap.UniqueHom.eq_of_continuous_of_map_id _ _ _ ?_ ?_ ?apply_id\n  case apply_id =>\n    trans cfcHom hÏˆa (.restrict (spectrum R (Ïˆ a)) (.id R))\n    Â· simp [cfcHom_id]\n    Â· congr\n  all_goals\n    simp [ContinuousMap.compStarAlgHom']\n    fun_prop\n\n"}
{"name":"StarAlgHom.map_cfc","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"R : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A â†’ Prop\nq : B â†’ Prop\ninstâœÂ²Â¹ : CommSemiring R\ninstâœÂ²â° : StarRing R\ninstâœÂ¹â¹ : MetricSpace R\ninstâœÂ¹â¸ : TopologicalSemiring R\ninstâœÂ¹â· : ContinuousStar R\ninstâœÂ¹â¶ : Ring A\ninstâœÂ¹âµ : StarRing A\ninstâœÂ¹â´ : TopologicalSpace A\ninstâœÂ¹Â³ : Algebra R A\ninstâœÂ¹Â² : Ring B\ninstâœÂ¹Â¹ : StarRing B\ninstâœÂ¹â° : TopologicalSpace B\ninstâœâ¹ : Algebra R B\ninstâœâ¸ : CommSemiring S\ninstâœâ· : Algebra R S\ninstâœâ¶ : Algebra S A\ninstâœâµ : Algebra S B\ninstâœâ´ : IsScalarTower R S A\ninstâœÂ³ : IsScalarTower R S B\ninstâœÂ² : ContinuousFunctionalCalculus R p\ninstâœÂ¹ : ContinuousFunctionalCalculus R q\ninstâœ : ContinuousMap.UniqueHom R B\nÏ† : StarAlgHom S A B\nf : R â†’ R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _autoâœ\nhÏ† : autoParam (Continuous â‡‘Ï†) _autoâœ\nha : autoParam (p a) _autoâœ\nhÏ†a : autoParam (q (Ï† a)) _autoâœ\nâŠ¢ Eq (Ï† (cfc f a)) (cfc f (Ï† a))","decl":"/-- Star algebra homomorphisms commute with the continuous functional calculus.\nThis version is specialized to `A â†’â‹†â‚[S] B` to allow for dot notation. -/\nlemma StarAlgHom.map_cfc (Ï† : A â†’â‹†â‚[S] B) (f : R â†’ R) (a : A)\n    (hf : ContinuousOn f (spectrum R a) := by cfc_cont_tac) (hÏ† : Continuous Ï† := by fun_prop)\n    (ha : p a := by cfc_tac) (hÏ†a : q (Ï† a) := by cfc_tac) :\n    Ï† (cfc f a) = cfc f (Ï† a) :=\n  StarAlgHomClass.map_cfc Ï† f a\n\n"}
