{"name":"RCLike.instContinuousMapUniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁵ : RCLike 𝕜\ninst✝⁴ : TopologicalSpace A\ninst✝³ : T2Space A\ninst✝² : Ring A\ninst✝¹ : StarRing A\ninst✝ : Algebra 𝕜 A\n⊢ ContinuousMap.UniqueHom 𝕜 A","decl":"instance (priority := 100) RCLike.instContinuousMapUniqueHom [TopologicalSpace A]\n    [T2Space A] [Ring A] [StarRing A] [Algebra 𝕜 A] :\n    ContinuousMap.UniqueHom 𝕜 A where\n  eq_of_continuous_of_map_id s _ φ ψ hφ hψ h :=\n    ContinuousMap.starAlgHom_ext_map_X hφ hψ <| by\n      convert h using 1\n      all_goals exact congr_arg _ (by ext; simp)\n\n"}
{"name":"Real.instContinuousMapUniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninst✝⁴ : TopologicalSpace A\ninst✝³ : T2Space A\ninst✝² : Ring A\ninst✝¹ : StarRing A\ninst✝ : Algebra Real A\n⊢ ContinuousMap.UniqueHom Real A","decl":"instance Real.instContinuousMapUniqueHom [TopologicalSpace A]\n    [T2Space A] [Ring A] [StarRing A] [Algebra ℝ A] :\n    ContinuousMap.UniqueHom ℝ A :=\n  inferInstance\n\n"}
{"name":"Complex.instContinuousMapUniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninst✝⁴ : TopologicalSpace A\ninst✝³ : T2Space A\ninst✝² : Ring A\ninst✝¹ : StarRing A\ninst✝ : Algebra Complex A\n⊢ ContinuousMap.UniqueHom Complex A","decl":"instance Complex.instContinuousMapUniqueHom [TopologicalSpace A]\n    [T2Space A] [Ring A] [StarRing A] [Algebra ℂ A] :\n    ContinuousMap.UniqueHom ℂ A :=\n  inferInstance\n\n"}
{"name":"ContinuousMap.continuous_toNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Continuous ContinuousMap.toNNReal","decl":"@[fun_prop]\nlemma continuous_toNNReal : Continuous (toNNReal (X := X)) := continuous_postcomp _\n\n"}
{"name":"ContinuousMap.toNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf : ContinuousMap X Real\nx : X\n⊢ Eq (f.toNNReal x) (f x).toNNReal","decl":"@[simp]\nlemma toNNReal_apply (f : C(X, ℝ)) (x : X) : f.toNNReal x = (f x).toNNReal := rfl\n\n"}
{"name":"ContinuousMap.toNNReal_add_add_neg_add_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf g : ContinuousMap X Real\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd f g).toNNReal (Neg.neg f).toNNReal) (Neg.neg g).toNNReal) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HAdd.hAdd f g)).toNNReal f.toNNReal) g.toNNReal)","decl":"lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, ℝ)) :\n    (f + g).toNNReal + (-f).toNNReal + (-g).toNNReal =\n      (-(f + g)).toNNReal + f.toNNReal + g.toNNReal := by\n  ext x\n  simp [max_neg_zero, -neg_add_rev]\n  abel\n\n"}
{"name":"ContinuousMap.toNNReal_mul_add_neg_mul_add_mul_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nf g : ContinuousMap X Real\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul f g).toNNReal (HMul.hMul (Neg.neg f).toNNReal g.toNNReal)) (HMul.hMul f.toNNReal (Neg.neg g).toNNReal)) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HMul.hMul f g)).toNNReal (HMul.hMul f.toNNReal g.toNNReal)) (HMul.hMul (Neg.neg f).toNNReal (Neg.neg g).toNNReal))","decl":"lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, ℝ)) :\n    (f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal =\n      (-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal := by\n  ext x\n  simp [max_neg_zero, add_mul, mul_add]\n  abel\n\n"}
{"name":"ContinuousMap.toNNReal_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nr : NNReal\n⊢ Eq ((algebraMap Real (ContinuousMap X Real)) ↑r).toNNReal ((algebraMap NNReal (ContinuousMap X NNReal)) r)","decl":"@[simp]\nlemma toNNReal_algebraMap (r : ℝ≥0) :\n    (algebraMap ℝ C(X, ℝ) r).toNNReal = algebraMap ℝ≥0 C(X, ℝ≥0) r := by\n  ext; simp\n\n"}
{"name":"ContinuousMap.toNNReal_neg_algebraMap","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\nr : NNReal\n⊢ Eq (Neg.neg ((algebraMap Real (ContinuousMap X Real)) ↑r)).toNNReal 0","decl":"@[simp]\nlemma toNNReal_neg_algebraMap (r : ℝ≥0) : (- algebraMap ℝ C(X, ℝ) r).toNNReal = 0 := by\n  ext; simp\n\n"}
{"name":"ContinuousMap.toNNReal_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (ContinuousMap.toNNReal 1) 1","decl":"@[simp]\nlemma toNNReal_one : (1 : C(X, ℝ)).toNNReal = 1 := toNNReal_algebraMap 1\n\n"}
{"name":"ContinuousMap.toNNReal_neg_one","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝ : TopologicalSpace X\n⊢ Eq (-1).toNNReal 0","decl":"@[simp]\nlemma toNNReal_neg_one : (-1 : C(X, ℝ)).toNNReal = 0 := toNNReal_neg_algebraMap 1\n\n"}
{"name":"StarAlgHom.realContinuousMapOfNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝³ : TopologicalSpace X\nA : Type u_2\ninst✝² : Ring A\ninst✝¹ : StarRing A\ninst✝ : Algebra Real A\nφ : StarAlgHom NNReal (ContinuousMap X NNReal) A\nf : ContinuousMap X Real\n⊢ Eq (φ.realContinuousMapOfNNReal f) (HSub.hSub (φ f.toNNReal) (φ (Neg.neg f).toNNReal))","decl":"/-- Given a star `ℝ≥0`-algebra homomorphism `φ` from `C(X, ℝ≥0)` into an `ℝ`-algebra `A`, this is\nthe unique extension of `φ` from `C(X, ℝ)` to `A` as a star `ℝ`-algebra homomorphism. -/\n@[simps]\nnoncomputable def realContinuousMapOfNNReal (φ : C(X, ℝ≥0) →⋆ₐ[ℝ≥0] A) :\n    C(X, ℝ) →⋆ₐ[ℝ] A where\n  toFun f := φ f.toNNReal - φ (-f).toNNReal\n  map_one' := by simp\n  map_zero' := by simp\n  map_mul' f g := by\n    have := congr(φ $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))\n    simp only [map_add, map_mul, sub_mul, mul_sub] at this ⊢\n    rw [← sub_eq_zero] at this ⊢\n    convert this using 1\n    abel\n  map_add' f g := by\n    have := congr(φ $(f.toNNReal_add_add_neg_add_neg_eq g))\n    simp only [map_add] at this ⊢\n    rw [← sub_eq_zero] at this ⊢\n    convert this using 1\n    abel\n  commutes' r := by\n    simp only\n    obtain (hr | hr) := le_total 0 r\n    · lift r to ℝ≥0 using hr\n      simpa only [ContinuousMap.toNNReal_algebraMap, ContinuousMap.toNNReal_neg_algebraMap,\n        map_zero, sub_zero] using AlgHomClass.commutes φ r\n    · rw [← neg_neg r, ← map_neg, neg_neg (-r)]\n      rw [← neg_nonneg] at hr\n      lift -r to ℝ≥0 using hr with r\n      simpa only [map_neg, ContinuousMap.toNNReal_neg_algebraMap, map_zero,\n        ContinuousMap.toNNReal_algebraMap, zero_sub, neg_inj] using AlgHomClass.commutes φ r\n  map_star' f := by simp only [star_trivial, star_sub, ← map_star]\n\n"}
{"name":"StarAlgHom.continuous_realContinuousMapOfNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝⁵ : TopologicalSpace X\nA : Type u_2\ninst✝⁴ : Ring A\ninst✝³ : StarRing A\ninst✝² : Algebra Real A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalRing A\nφ : StarAlgHom NNReal (ContinuousMap X NNReal) A\nhφ : Continuous ⇑φ\n⊢ Continuous ⇑φ.realContinuousMapOfNNReal","decl":"@[fun_prop]\nlemma continuous_realContinuousMapOfNNReal (φ : C(X, ℝ≥0) →⋆ₐ[ℝ≥0] A)\n    (hφ : Continuous φ) : Continuous φ.realContinuousMapOfNNReal := by\n  simp [realContinuousMapOfNNReal]\n  fun_prop\n\n"}
{"name":"StarAlgHom.realContinuousMapOfNNReal_apply_comp_toReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝³ : TopologicalSpace X\nA : Type u_2\ninst✝² : Ring A\ninst✝¹ : StarRing A\ninst✝ : Algebra Real A\nφ : StarAlgHom NNReal (ContinuousMap X NNReal) A\nf : ContinuousMap X NNReal\n⊢ Eq (φ.realContinuousMapOfNNReal ({ toFun := NNReal.toReal, continuous_toFun := NNReal.continuous_coe }.comp f)) (φ f)","decl":"@[simp high]\nlemma realContinuousMapOfNNReal_apply_comp_toReal (φ : C(X, ℝ≥0) →⋆ₐ[ℝ≥0] A)\n    (f : C(X, ℝ≥0)) :\n    φ.realContinuousMapOfNNReal ((ContinuousMap.mk toReal continuous_coe).comp f) = φ f := by\n  simp only [realContinuousMapOfNNReal_apply]\n  convert_to φ f - φ 0 = φ f using 2\n  on_goal -1 => rw [map_zero, sub_zero]\n  all_goals\n    congr\n    ext x\n    simp\n\n"}
{"name":"StarAlgHom.realContinuousMapOfNNReal_injective","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝³ : TopologicalSpace X\nA : Type u_2\ninst✝² : Ring A\ninst✝¹ : StarRing A\ninst✝ : Algebra Real A\n⊢ Function.Injective StarAlgHom.realContinuousMapOfNNReal","decl":"lemma realContinuousMapOfNNReal_injective :\n    Function.Injective (realContinuousMapOfNNReal (X := X) (A := A)) := by\n  intro φ ψ h\n  ext f\n  simpa using congr($(h) ((ContinuousMap.mk toReal continuous_coe).comp f))\n\n"}
{"name":"NNReal.instContinuousMap.UniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninst✝⁴ : Ring A\ninst✝³ : StarRing A\ninst✝² : Algebra Real A\ninst✝¹ : TopologicalSpace A\ninst✝ : T2Space A\n⊢ ContinuousMap.UniqueHom NNReal A","decl":"instance NNReal.instContinuousMap.UniqueHom [T2Space A] :\n    ContinuousMap.UniqueHom ℝ≥0 A where\n  eq_of_continuous_of_map_id s hs φ ψ hφ hψ h := by\n    let s' : Set ℝ := (↑) '' s\n    let e : s ≃ₜ s' :=\n      { toFun := Subtype.map (↑) (by simp [s'])\n        invFun := Subtype.map Real.toNNReal (by simp [s'])\n        left_inv := fun _ ↦ by ext; simp\n        right_inv := fun x ↦ by\n          ext\n          obtain ⟨y, -, hy⟩ := x.2\n          simpa using hy ▸ NNReal.coe_nonneg y\n        continuous_toFun := continuous_coe.subtype_map (by simp [s'])\n        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }\n    have (ξ : C(s, ℝ≥0) →⋆ₐ[ℝ≥0] A) (hξ : Continuous ξ) :\n        (let ξ' := ξ.realContinuousMapOfNNReal.comp <| ContinuousMap.compStarAlgHom' ℝ ℝ e\n        Continuous ξ' ∧ ξ' (.restrict s' <| .id ℝ) = ξ (.restrict s <| .id ℝ≥0)) := by\n      intro ξ'\n      refine ⟨ξ.continuous_realContinuousMapOfNNReal hξ |>.comp <|\n        ContinuousMap.continuous_precomp _, ?_⟩\n      exact ξ.realContinuousMapOfNNReal_apply_comp_toReal (.restrict s <| .id ℝ≥0)\n    obtain ⟨hφ', hφ_id⟩ := this φ hφ\n    obtain ⟨hψ', hψ_id⟩ := this ψ hψ\n    have hs' : CompactSpace s' := e.compactSpace\n    have h' := ContinuousMap.UniqueHom.eq_of_continuous_of_map_id s' _ _ hφ' hψ'\n      (hφ_id ▸ hψ_id ▸ h)\n    have h'' := congr($(h').comp <| ContinuousMap.compStarAlgHom' ℝ ℝ (e.symm : C(s', s)))\n    have : (ContinuousMap.compStarAlgHom' ℝ ℝ (e : C(s, s'))).comp\n        (ContinuousMap.compStarAlgHom' ℝ ℝ (e.symm : C(s', s))) = StarAlgHom.id _ _ := by\n      ext1; simp\n    simp only [StarAlgHom.comp_assoc, this, StarAlgHom.comp_id] at h''\n    exact StarAlgHom.realContinuousMapOfNNReal_injective h''\n\n"}
{"name":"RCLike.uniqueNonUnitalContinuousFunctionalCalculus","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"𝕜 : Type u_1\nA : Type u_2\ninst✝⁷ : RCLike 𝕜\ninst✝⁶ : TopologicalSpace A\ninst✝⁵ : T2Space A\ninst✝⁴ : NonUnitalRing A\ninst✝³ : StarRing A\ninst✝² : Module 𝕜 A\ninst✝¹ : IsScalarTower 𝕜 A A\ninst✝ : SMulCommClass 𝕜 A A\n⊢ ContinuousMapZero.UniqueHom 𝕜 A","decl":"open NonUnitalStarAlgebra in\ninstance RCLike.uniqueNonUnitalContinuousFunctionalCalculus\n    [TopologicalSpace A] [T2Space A] [NonUnitalRing A] [StarRing A] [Module 𝕜 A]\n    [IsScalarTower 𝕜 A A] [SMulCommClass 𝕜 A A] :\n    ContinuousMapZero.UniqueHom 𝕜 A where\n  eq_of_continuous_of_map_id s hs _inst h0 φ ψ hφ hψ h := by\n    rw [DFunLike.ext'_iff, ← Set.eqOn_univ, ← (ContinuousMapZero.adjoin_id_dense h0).closure_eq]\n    refine Set.EqOn.closure (fun f hf ↦ ?_) hφ hψ\n    rw [← NonUnitalStarAlgHom.mem_equalizer]\n    apply adjoin_le ?_ hf\n    rw [Set.singleton_subset_iff]\n    exact h\n\n"}
{"name":"ContinuousMapZero.toNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\nf : ContinuousMapZero X Real\nx : X\n⊢ Eq (f.toNNReal x) (f x).toNNReal","decl":"@[simp]\nlemma toNNReal_apply (f : C(X, ℝ)₀) (x : X) : f.toNNReal x = Real.toNNReal (f x) := rfl\n\n"}
{"name":"ContinuousMapZero.continuous_toNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\n⊢ Continuous ContinuousMapZero.toNNReal","decl":"@[fun_prop]\nlemma continuous_toNNReal : Continuous (toNNReal (X := X)) := by\n  rw [continuous_induced_rng]\n  convert_to Continuous (ContinuousMap.toNNReal ∘ ((↑) : C(X, ℝ)₀ → C(X, ℝ))) using 1\n  exact ContinuousMap.continuous_postcomp _ |>.comp continuous_induced_dom\n\n"}
{"name":"ContinuousMapZero.toContinuousMapHom_toNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\nf : ContinuousMapZero X Real\n⊢ Eq (ContinuousMapZero.toContinuousMapHom f).toNNReal (ContinuousMapZero.toContinuousMapHom f.toNNReal)","decl":"lemma toContinuousMapHom_toNNReal (f : C(X, ℝ)₀) :\n    (toContinuousMapHom (X := X) (R := ℝ) f).toNNReal =\n      toContinuousMapHom (X := X) (R := ℝ≥0) f.toNNReal :=\n  rfl\n\n"}
{"name":"ContinuousMapZero.toNNReal_smul","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\nr : NNReal\nf : ContinuousMapZero X Real\n⊢ Eq (HSMul.hSMul r f).toNNReal (HSMul.hSMul r f.toNNReal)","decl":"@[simp]\nlemma toNNReal_smul (r : ℝ≥0) (f : C(X, ℝ)₀) : (r • f).toNNReal = r • f.toNNReal := by\n  ext x\n  by_cases h : 0 ≤ f x\n  · simpa [max_eq_left h, NNReal.smul_def] using mul_nonneg r.coe_nonneg h\n  · push_neg at h\n    simpa [max_eq_right h.le, NNReal.smul_def]\n      using mul_nonpos_of_nonneg_of_nonpos r.coe_nonneg h.le\n\n"}
{"name":"ContinuousMapZero.toNNReal_neg_smul","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\nr : NNReal\nf : ContinuousMapZero X Real\n⊢ Eq (Neg.neg (HSMul.hSMul r f)).toNNReal (HSMul.hSMul r (Neg.neg f).toNNReal)","decl":"@[simp]\nlemma toNNReal_neg_smul (r : ℝ≥0) (f : C(X, ℝ)₀) : (-(r • f)).toNNReal = r • (-f).toNNReal := by\n  rw [NNReal.smul_def, ← smul_neg, ← NNReal.smul_def, toNNReal_smul]\n\n"}
{"name":"ContinuousMapZero.toNNReal_mul_add_neg_mul_add_mul_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\nf g : ContinuousMapZero X Real\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HMul.hMul f g).toNNReal (HMul.hMul (Neg.neg f).toNNReal g.toNNReal)) (HMul.hMul f.toNNReal (Neg.neg g).toNNReal)) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HMul.hMul f g)).toNNReal (HMul.hMul f.toNNReal g.toNNReal)) (HMul.hMul (Neg.neg f).toNNReal (Neg.neg g).toNNReal))","decl":"lemma toNNReal_mul_add_neg_mul_add_mul_neg_eq (f g : C(X, ℝ)₀) :\n    ((f * g).toNNReal + (-f).toNNReal * g.toNNReal + f.toNNReal * (-g).toNNReal) =\n    ((-(f * g)).toNNReal + f.toNNReal * g.toNNReal + (-f).toNNReal * (-g).toNNReal) := by\n  apply toContinuousMap_injective\n  simpa only [← toContinuousMapHom_apply, map_add, map_mul, map_neg, toContinuousMapHom_toNNReal]\n    using (f : C(X, ℝ)).toNNReal_mul_add_neg_mul_add_mul_neg_eq g\n\n"}
{"name":"ContinuousMapZero.toNNReal_add_add_neg_add_neg_eq","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝¹ : TopologicalSpace X\ninst✝ : Zero X\nf g : ContinuousMapZero X Real\n⊢ Eq (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd f g).toNNReal (Neg.neg f).toNNReal) (Neg.neg g).toNNReal) (HAdd.hAdd (HAdd.hAdd (Neg.neg (HAdd.hAdd f g)).toNNReal f.toNNReal) g.toNNReal)","decl":"lemma toNNReal_add_add_neg_add_neg_eq (f g : C(X, ℝ)₀) :\n    ((f + g).toNNReal + (-f).toNNReal + (-g).toNNReal) =\n      ((-(f + g)).toNNReal + f.toNNReal + g.toNNReal) := by\n  apply toContinuousMap_injective\n  simpa only [← toContinuousMapHom_apply, map_add, map_mul, map_neg, toContinuousMapHom_toNNReal]\n    using (f : C(X, ℝ)).toNNReal_add_add_neg_add_neg_eq g\n\n"}
{"name":"NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_apply","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Zero X\nA : Type u_2\ninst✝² : NonUnitalRing A\ninst✝¹ : StarRing A\ninst✝ : Module Real A\nφ : NonUnitalStarAlgHom NNReal (ContinuousMapZero X NNReal) A\nf : ContinuousMapZero X Real\n⊢ Eq (φ.realContinuousMapZeroOfNNReal f) (HSub.hSub (φ f.toNNReal) (φ (Neg.neg f).toNNReal))","decl":"/-- Given a non-unital star `ℝ≥0`-algebra homomorphism `φ` from `C(X, ℝ≥0)₀` into a non-unital\n`ℝ`-algebra `A`, this is the unique extension of `φ` from `C(X, ℝ)₀` to `A` as a non-unital\nstar `ℝ`-algebra homomorphism. -/\n@[simps]\nnoncomputable def realContinuousMapZeroOfNNReal (φ : C(X, ℝ≥0)₀ →⋆ₙₐ[ℝ≥0] A) :\n    C(X, ℝ)₀ →⋆ₙₐ[ℝ] A where\n  toFun f := φ f.toNNReal - φ (-f).toNNReal\n  map_zero' := by simp\n  map_mul' f g := by\n    have := congr(φ $(f.toNNReal_mul_add_neg_mul_add_mul_neg_eq g))\n    simp only [map_add, map_mul, sub_mul, mul_sub] at this ⊢\n    rw [← sub_eq_zero] at this ⊢\n    rw [← this]\n    abel\n  map_add' f g := by\n    have := congr(φ $(f.toNNReal_add_add_neg_add_neg_eq g))\n    simp only [map_add, map_mul, sub_mul, mul_sub] at this ⊢\n    rw [← sub_eq_zero] at this ⊢\n    rw [← this]\n    abel\n  map_smul' r f := by\n    simp only [MonoidHom.id_apply]\n    by_cases hr : 0 ≤ r\n    · lift r to ℝ≥0 using hr\n      simp only [← smul_def, toNNReal_smul, map_smul, toNNReal_neg_smul, smul_sub]\n    · rw [not_le, ← neg_pos] at hr\n      rw [← neg_smul]\n      nth_rw 1 [← neg_neg r]\n      nth_rw 3 [← neg_neg r]\n      lift -r to ℝ≥0 using hr.le with r\n      simp only [neg_smul, ← smul_def, toNNReal_neg_smul, map_smul, toNNReal_smul, smul_sub,\n        sub_neg_eq_add]\n      rw [sub_eq_add_neg, add_comm]\n  map_star' f := by simp only [star_trivial, star_sub, ← map_star]\n\n"}
{"name":"NonUnitalStarAlgHom.continuous_realContinuousMapZeroOfNNReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝⁶ : TopologicalSpace X\ninst✝⁵ : Zero X\nA : Type u_2\ninst✝⁴ : NonUnitalRing A\ninst✝³ : StarRing A\ninst✝² : Module Real A\ninst✝¹ : TopologicalSpace A\ninst✝ : TopologicalRing A\nφ : NonUnitalStarAlgHom NNReal (ContinuousMapZero X NNReal) A\nhφ : Continuous ⇑φ\n⊢ Continuous ⇑φ.realContinuousMapZeroOfNNReal","decl":"@[fun_prop]\nlemma continuous_realContinuousMapZeroOfNNReal (φ : C(X, ℝ≥0)₀ →⋆ₙₐ[ℝ≥0] A)\n    (hφ : Continuous φ) : Continuous φ.realContinuousMapZeroOfNNReal := by\n  simp [realContinuousMapZeroOfNNReal]\n  fun_prop\n\n"}
{"name":"NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_apply_comp_toReal","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Zero X\nA : Type u_2\ninst✝² : NonUnitalRing A\ninst✝¹ : StarRing A\ninst✝ : Module Real A\nφ : NonUnitalStarAlgHom NNReal (ContinuousMapZero X NNReal) A\nf : ContinuousMapZero X NNReal\n⊢ Eq (φ.realContinuousMapZeroOfNNReal ({ toFun := NNReal.toReal, continuous_toFun := NNReal.continuous_coe, map_zero' := ⋯ }.comp f)) (φ f)","decl":"@[simp high]\nlemma realContinuousMapZeroOfNNReal_apply_comp_toReal (φ : C(X, ℝ≥0)₀ →⋆ₙₐ[ℝ≥0] A)\n    (f : C(X, ℝ≥0)₀) :\n    φ.realContinuousMapZeroOfNNReal ((ContinuousMapZero.mk ⟨toReal, continuous_coe⟩ rfl).comp f) =\n      φ f := by\n  simp only [realContinuousMapZeroOfNNReal_apply]\n  convert_to φ f - φ 0 = φ f using 2\n  on_goal -1 => rw [map_zero, sub_zero]\n  all_goals\n    congr\n    ext x\n    simp\n\n"}
{"name":"NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_injective","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"X : Type u_1\ninst✝⁴ : TopologicalSpace X\ninst✝³ : Zero X\nA : Type u_2\ninst✝² : NonUnitalRing A\ninst✝¹ : StarRing A\ninst✝ : Module Real A\n⊢ Function.Injective NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal","decl":"lemma realContinuousMapZeroOfNNReal_injective :\n    Function.Injective (realContinuousMapZeroOfNNReal (X := X) (A := A)) := by\n  intro φ ψ h\n  ext f\n  simpa using congr($(h) ((ContinuousMapZero.mk ⟨toReal, continuous_coe⟩ rfl).comp f))\n\n"}
{"name":"NNReal.instContinuousMapZero.UniqueHom","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"A : Type u_2\ninst✝⁷ : NonUnitalRing A\ninst✝⁶ : StarRing A\ninst✝⁵ : Module Real A\ninst✝⁴ : TopologicalSpace A\ninst✝³ : TopologicalRing A\ninst✝² : IsScalarTower Real A A\ninst✝¹ : SMulCommClass Real A A\ninst✝ : T2Space A\n⊢ ContinuousMapZero.UniqueHom NNReal A","decl":"instance NNReal.instContinuousMapZero.UniqueHom\n    [TopologicalSpace A] [TopologicalRing A] [IsScalarTower ℝ A A] [SMulCommClass ℝ A A]\n    [T2Space A] :\n    ContinuousMapZero.UniqueHom ℝ≥0 A where\n  eq_of_continuous_of_map_id s hs _inst h0 φ ψ hφ hψ h := by\n    let s' : Set ℝ := (↑) '' s\n    let e : s ≃ₜ s' :=\n      { toFun := Subtype.map (↑) (by simp [s'])\n        invFun := Subtype.map Real.toNNReal (by simp [s'])\n        left_inv := fun _ ↦ by ext; simp\n        right_inv := fun x ↦ by\n          ext\n          obtain ⟨y, -, hy⟩ := x.2\n          simpa using hy ▸ NNReal.coe_nonneg y\n        continuous_toFun := continuous_coe.subtype_map (by simp [s'])\n        continuous_invFun := continuous_real_toNNReal.subtype_map (by simp [s']) }\n    let _inst₁ : Zero s' := ⟨0, ⟨0, h0 ▸ Subtype.property (0 : s), coe_zero⟩⟩\n    have h0' : ((0 : s') : ℝ) = 0 := rfl\n    have e0 : e 0 = 0 := by ext; simp [e, h0, h0']\n    have e0' : e.symm 0 = 0 := by\n      simpa only [Homeomorph.symm_apply_apply] using congr(e.symm $(e0)).symm\n    have (ξ : C(s, ℝ≥0)₀ →⋆ₙₐ[ℝ≥0] A) (hξ : Continuous ξ) :\n        (let ξ' := ξ.realContinuousMapZeroOfNNReal.comp <|\n          ContinuousMapZero.nonUnitalStarAlgHom_precomp ℝ ⟨e, e0⟩;\n          Continuous ξ' ∧ ξ' (ContinuousMapZero.id h0') = ξ (ContinuousMapZero.id h0)) := by\n      intro ξ'\n      refine ⟨ξ.continuous_realContinuousMapZeroOfNNReal hξ |>.comp <| ?_, ?_⟩\n      · rw [continuous_induced_rng]\n        exact ContinuousMap.continuous_precomp _ |>.comp continuous_induced_dom\n      · exact ξ.realContinuousMapZeroOfNNReal_apply_comp_toReal (.id h0)\n    obtain ⟨hφ', hφ_id⟩ := this φ hφ\n    obtain ⟨hψ', hψ_id⟩ := this ψ hψ\n    have hs' : CompactSpace s' := e.compactSpace\n    have : ContinuousMapZero.UniqueHom ℝ A := inferInstance\n    have h' := ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id\n      s' h0' _ _ hφ' hψ' (hφ_id ▸ hψ_id ▸ h)\n    have h'' := congr($(h').comp <|\n      ContinuousMapZero.nonUnitalStarAlgHom_precomp ℝ ⟨(e.symm : C(s', s)), e0'⟩)\n    have : (ContinuousMapZero.nonUnitalStarAlgHom_precomp ℝ ⟨(e : C(s, s')), e0⟩).comp\n        (ContinuousMapZero.nonUnitalStarAlgHom_precomp ℝ ⟨(e.symm : C(s', s)), e0'⟩) =\n        NonUnitalStarAlgHom.id _ _ := by\n      ext; simp\n    simp only [NonUnitalStarAlgHom.comp_assoc, this, NonUnitalStarAlgHom.comp_id] at h''\n    exact NonUnitalStarAlgHom.realContinuousMapZeroOfNNReal_injective h''\n\n"}
{"name":"NonUnitalStarAlgHomClass.map_cfcₙ","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A → Prop\nq : B → Prop\ninst✝²⁹ : CommSemiring R\ninst✝²⁸ : Nontrivial R\ninst✝²⁷ : StarRing R\ninst✝²⁶ : MetricSpace R\ninst✝²⁵ : TopologicalSemiring R\ninst✝²⁴ : ContinuousStar R\ninst✝²³ : CommRing S\ninst✝²² : Algebra R S\ninst✝²¹ : NonUnitalRing A\ninst✝²⁰ : StarRing A\ninst✝¹⁹ : TopologicalSpace A\ninst✝¹⁸ : Module R A\ninst✝¹⁷ : IsScalarTower R A A\ninst✝¹⁶ : SMulCommClass R A A\ninst✝¹⁵ : NonUnitalRing B\ninst✝¹⁴ : StarRing B\ninst✝¹³ : TopologicalSpace B\ninst✝¹² : Module R B\ninst✝¹¹ : IsScalarTower R B B\ninst✝¹⁰ : SMulCommClass R B B\ninst✝⁹ : Module S A\ninst✝⁸ : Module S B\ninst✝⁷ : IsScalarTower R S A\ninst✝⁶ : IsScalarTower R S B\ninst✝⁵ : NonUnitalContinuousFunctionalCalculus R p\ninst✝⁴ : NonUnitalContinuousFunctionalCalculus R q\ninst✝³ : ContinuousMapZero.UniqueHom R B\ninst✝² : FunLike F A B\ninst✝¹ : NonUnitalAlgHomClass F S A B\ninst✝ : StarHomClass F A B\nφ : F\nf : R → R\na : A\nhf : autoParam (ContinuousOn f (quasispectrum R a)) _auto✝\nhf₀ : autoParam (Eq (f 0) 0) _auto✝\nhφ : autoParam (Continuous ⇑φ) _auto✝\nha : autoParam (p a) _auto✝\nhφa : autoParam (q (φ a)) _auto✝\n⊢ Eq (φ (cfcₙ f a)) (cfcₙ f (φ a))","decl":"include S in\n/-- Non-unital star algebra homomorphisms commute with the non-unital continuous functional\ncalculus. -/\nlemma NonUnitalStarAlgHomClass.map_cfcₙ (φ : F) (f : R → R) (a : A)\n    (hf : ContinuousOn f (quasispectrum R a) := by cfc_cont_tac)\n    (hf₀ : f 0 = 0 := by cfc_zero_tac) (hφ : Continuous φ := by fun_prop) (ha : p a := by cfc_tac)\n    (hφa : q (φ a) := by cfc_tac) : φ (cfcₙ f a) = cfcₙ f (φ a) := by\n  let ψ : A →⋆ₙₐ[R] B := (φ : A →⋆ₙₐ[S] B).restrictScalars R\n  have : Continuous ψ := hφ\n  have h_spec := NonUnitalAlgHom.quasispectrum_apply_subset' (R := R) S φ a\n  have hψa : q (ψ a) := hφa\n  let ι : C(quasispectrum R (ψ a), quasispectrum R a)₀ :=\n    ⟨⟨Set.inclusion h_spec, continuous_id.subtype_map h_spec⟩, rfl⟩\n  suffices ψ.comp (cfcₙHom ha) =\n      (cfcₙHom hψa).comp (ContinuousMapZero.nonUnitalStarAlgHom_precomp R ι) by\n    have hf' : ContinuousOn f (quasispectrum R (ψ a)) := hf.mono h_spec\n    rw [cfcₙ_apply .., cfcₙ_apply ..]\n    exact DFunLike.congr_fun this _\n  refine ContinuousMapZero.UniqueHom.eq_of_continuous_of_map_id _ rfl _ _\n    ?_ ?_ ?apply_id\n  case apply_id =>\n    trans cfcₙHom hψa ⟨.restrict (quasispectrum R (ψ a)) (.id R), rfl⟩\n    · simp [cfcₙHom_id]\n    · congr\n  all_goals\n    simp [ContinuousMapZero.nonUnitalStarAlgHom_precomp]\n    fun_prop\n\n"}
{"name":"NonUnitalStarAlgHom.map_cfcₙ","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"R : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A → Prop\nq : B → Prop\ninst✝²⁶ : CommSemiring R\ninst✝²⁵ : Nontrivial R\ninst✝²⁴ : StarRing R\ninst✝²³ : MetricSpace R\ninst✝²² : TopologicalSemiring R\ninst✝²¹ : ContinuousStar R\ninst✝²⁰ : CommRing S\ninst✝¹⁹ : Algebra R S\ninst✝¹⁸ : NonUnitalRing A\ninst✝¹⁷ : StarRing A\ninst✝¹⁶ : TopologicalSpace A\ninst✝¹⁵ : Module R A\ninst✝¹⁴ : IsScalarTower R A A\ninst✝¹³ : SMulCommClass R A A\ninst✝¹² : NonUnitalRing B\ninst✝¹¹ : StarRing B\ninst✝¹⁰ : TopologicalSpace B\ninst✝⁹ : Module R B\ninst✝⁸ : IsScalarTower R B B\ninst✝⁷ : SMulCommClass R B B\ninst✝⁶ : Module S A\ninst✝⁵ : Module S B\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : IsScalarTower R S B\ninst✝² : NonUnitalContinuousFunctionalCalculus R p\ninst✝¹ : NonUnitalContinuousFunctionalCalculus R q\ninst✝ : ContinuousMapZero.UniqueHom R B\nφ : NonUnitalStarAlgHom S A B\nf : R → R\na : A\nhf : autoParam (ContinuousOn f (quasispectrum R a)) _auto✝\nhf₀ : autoParam (Eq (f 0) 0) _auto✝\nhφ : autoParam (Continuous ⇑φ) _auto✝\nha : autoParam (p a) _auto✝\nhφa : autoParam (q (φ a)) _auto✝\n⊢ Eq (φ (cfcₙ f a)) (cfcₙ f (φ a))","decl":"/-- Non-unital star algebra homomorphisms commute with the non-unital continuous functional\ncalculus.  This version is specialized to `A →⋆ₙₐ[S] B` to allow for dot notation. -/\nlemma NonUnitalStarAlgHom.map_cfcₙ (φ : A →⋆ₙₐ[S] B) (f : R → R) (a : A)\n    (hf : ContinuousOn f (quasispectrum R a) := by cfc_cont_tac)\n    (hf₀ : f 0 = 0 := by cfc_zero_tac) (hφ : Continuous φ := by fun_prop) (ha : p a := by cfc_tac)\n    (hφa : q (φ a) := by cfc_tac) : φ (cfcₙ f a) = cfcₙ f (φ a) :=\n  NonUnitalStarAlgHomClass.map_cfcₙ φ f a\n\n"}
{"name":"StarAlgHomClass.map_cfc","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"F : Type u_1\nR : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A → Prop\nq : B → Prop\ninst✝²⁴ : CommSemiring R\ninst✝²³ : StarRing R\ninst✝²² : MetricSpace R\ninst✝²¹ : TopologicalSemiring R\ninst✝²⁰ : ContinuousStar R\ninst✝¹⁹ : Ring A\ninst✝¹⁸ : StarRing A\ninst✝¹⁷ : TopologicalSpace A\ninst✝¹⁶ : Algebra R A\ninst✝¹⁵ : Ring B\ninst✝¹⁴ : StarRing B\ninst✝¹³ : TopologicalSpace B\ninst✝¹² : Algebra R B\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\ninst✝⁹ : Algebra S A\ninst✝⁸ : Algebra S B\ninst✝⁷ : IsScalarTower R S A\ninst✝⁶ : IsScalarTower R S B\ninst✝⁵ : ContinuousFunctionalCalculus R p\ninst✝⁴ : ContinuousFunctionalCalculus R q\ninst✝³ : ContinuousMap.UniqueHom R B\ninst✝² : FunLike F A B\ninst✝¹ : AlgHomClass F S A B\ninst✝ : StarHomClass F A B\nφ : F\nf : R → R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto✝\nhφ : autoParam (Continuous ⇑φ) _auto✝\nha : autoParam (p a) _auto✝\nhφa : autoParam (q (φ a)) _auto✝\n⊢ Eq (φ (cfc f a)) (cfc f (φ a))","decl":"include S in\n/-- Star algebra homomorphisms commute with the continuous functional calculus. -/\nlemma StarAlgHomClass.map_cfc (φ : F) (f : R → R) (a : A)\n    (hf : ContinuousOn f (spectrum R a) := by cfc_cont_tac)\n    (hφ : Continuous φ := by fun_prop) (ha : p a := by cfc_tac) (hφa : q (φ a) := by cfc_tac) :\n    φ (cfc f a) = cfc f (φ a) := by\n  let ψ : A →⋆ₐ[R] B := (φ : A →⋆ₐ[S] B).restrictScalars R\n  have : Continuous ψ := hφ\n  have h_spec := AlgHom.spectrum_apply_subset ψ a\n  have hψa : q (ψ a) := hφa\n  let ι : C(spectrum R (ψ a), spectrum R a) :=\n    ⟨Set.inclusion h_spec, continuous_id.subtype_map h_spec⟩\n  suffices ψ.comp (cfcHom ha) = (cfcHom hψa).comp (ContinuousMap.compStarAlgHom' R R ι) by\n    have hf' : ContinuousOn f (spectrum R (ψ a)) := hf.mono h_spec\n    rw [cfc_apply .., cfc_apply ..]\n    congrm($(this) ⟨_, hf.restrict⟩)\n  refine ContinuousMap.UniqueHom.eq_of_continuous_of_map_id _ _ _ ?_ ?_ ?apply_id\n  case apply_id =>\n    trans cfcHom hψa (.restrict (spectrum R (ψ a)) (.id R))\n    · simp [cfcHom_id]\n    · congr\n  all_goals\n    simp [ContinuousMap.compStarAlgHom']\n    fun_prop\n\n"}
{"name":"StarAlgHom.map_cfc","module":"Mathlib.Analysis.CStarAlgebra.ContinuousFunctionalCalculus.Unique","initialProofState":"R : Type u_2\nS : Type u_3\nA : Type u_4\nB : Type u_5\np : A → Prop\nq : B → Prop\ninst✝²¹ : CommSemiring R\ninst✝²⁰ : StarRing R\ninst✝¹⁹ : MetricSpace R\ninst✝¹⁸ : TopologicalSemiring R\ninst✝¹⁷ : ContinuousStar R\ninst✝¹⁶ : Ring A\ninst✝¹⁵ : StarRing A\ninst✝¹⁴ : TopologicalSpace A\ninst✝¹³ : Algebra R A\ninst✝¹² : Ring B\ninst✝¹¹ : StarRing B\ninst✝¹⁰ : TopologicalSpace B\ninst✝⁹ : Algebra R B\ninst✝⁸ : CommSemiring S\ninst✝⁷ : Algebra R S\ninst✝⁶ : Algebra S A\ninst✝⁵ : Algebra S B\ninst✝⁴ : IsScalarTower R S A\ninst✝³ : IsScalarTower R S B\ninst✝² : ContinuousFunctionalCalculus R p\ninst✝¹ : ContinuousFunctionalCalculus R q\ninst✝ : ContinuousMap.UniqueHom R B\nφ : StarAlgHom S A B\nf : R → R\na : A\nhf : autoParam (ContinuousOn f (spectrum R a)) _auto✝\nhφ : autoParam (Continuous ⇑φ) _auto✝\nha : autoParam (p a) _auto✝\nhφa : autoParam (q (φ a)) _auto✝\n⊢ Eq (φ (cfc f a)) (cfc f (φ a))","decl":"/-- Star algebra homomorphisms commute with the continuous functional calculus.\nThis version is specialized to `A →⋆ₐ[S] B` to allow for dot notation. -/\nlemma StarAlgHom.map_cfc (φ : A →⋆ₐ[S] B) (f : R → R) (a : A)\n    (hf : ContinuousOn f (spectrum R a) := by cfc_cont_tac) (hφ : Continuous φ := by fun_prop)\n    (ha : p a := by cfc_tac) (hφa : q (φ a) := by cfc_tac) :\n    φ (cfc f a) = cfc f (φ a) :=\n  StarAlgHomClass.map_cfc φ f a\n\n"}
