{"name":"Complex.angle_eq_abs_arg","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x y : Complex\nhx : Ne x 0\nhy : Ne y 0\n⊢ Eq (InnerProductGeometry.angle x y) (abs (HDiv.hDiv x y).arg)","decl":"/-- The angle between two non-zero complex numbers is the absolute value of the argument of their\nquotient.\n\nNote that this does not hold when `x` or `y` is `0` as the LHS is `π / 2` while the RHS is `0`. -/\nlemma angle_eq_abs_arg (hx : x ≠ 0) (hy : y ≠ 0) : angle x y = |(x / y).arg| := by\n  refine Real.arccos_eq_of_eq_cos (abs_nonneg _) (abs_arg_le_pi _) ?_\n  rw [Real.cos_abs, Complex.cos_arg (div_ne_zero hx hy)]\n  have := (map_ne_zero Complex.abs).2 hx\n  have := (map_ne_zero Complex.abs).2 hy\n  simp [div_eq_mul_inv, Complex.normSq_eq_norm_sq]\n  field_simp\n  ring\n\n"}
{"name":"Complex.angle_one_left","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"y : Complex\nhy : Ne y 0\n⊢ Eq (InnerProductGeometry.angle 1 y) (abs y.arg)","decl":"lemma angle_one_left (hy : y ≠ 0) : angle 1 y = |y.arg| := by simp [angle_eq_abs_arg, hy]\n"}
{"name":"Complex.angle_one_right","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x : Complex\nhx : Ne x 0\n⊢ Eq (InnerProductGeometry.angle x 1) (abs x.arg)","decl":"lemma angle_one_right (hx : x ≠ 0) : angle x 1 = |x.arg| := by simp [angle_eq_abs_arg, hx]\n\n"}
{"name":"Complex.angle_mul_left","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"a : Complex\nha : Ne a 0\nx y : Complex\n⊢ Eq (InnerProductGeometry.angle (HMul.hMul a x) (HMul.hMul a y)) (InnerProductGeometry.angle x y)","decl":"@[simp] lemma angle_mul_left (ha : a ≠ 0) (x y : ℂ) : angle (a * x) (a * y) = angle x y := by\n  obtain rfl | hx := eq_or_ne x 0 <;> obtain rfl | hy := eq_or_ne y 0 <;>\n    simp [angle_eq_abs_arg, mul_div_mul_left, *]\n\n"}
{"name":"Complex.angle_mul_right","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"a : Complex\nha : Ne a 0\nx y : Complex\n⊢ Eq (InnerProductGeometry.angle (HMul.hMul x a) (HMul.hMul y a)) (InnerProductGeometry.angle x y)","decl":"@[simp] lemma angle_mul_right (ha : a ≠ 0) (x y : ℂ) : angle (x * a) (y * a) = angle x y := by\n  simp [mul_comm, angle_mul_left ha]\n\n"}
{"name":"Complex.angle_div_left_eq_angle_mul_right","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"a x y : Complex\n⊢ Eq (InnerProductGeometry.angle (HDiv.hDiv x a) y) (InnerProductGeometry.angle x (HMul.hMul y a))","decl":"lemma angle_div_left_eq_angle_mul_right (a x y : ℂ) : angle (x / a) y = angle x (y * a) := by\n  obtain rfl | ha := eq_or_ne a 0\n  · simp\n  · rw [← angle_mul_right ha, div_mul_cancel₀ _ ha]\n\n"}
{"name":"Complex.angle_div_right_eq_angle_mul_left","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"a x y : Complex\n⊢ Eq (InnerProductGeometry.angle x (HDiv.hDiv y a)) (InnerProductGeometry.angle (HMul.hMul x a) y)","decl":"lemma angle_div_right_eq_angle_mul_left (a x y : ℂ) : angle x (y / a) = angle (x * a) y := by\n  rw [angle_comm, angle_div_left_eq_angle_mul_right, angle_comm]\n\n"}
{"name":"Complex.angle_exp_exp","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x y : Real\n⊢ Eq (InnerProductGeometry.angle (Complex.exp (HMul.hMul (↑x) Complex.I)) (Complex.exp (HMul.hMul (↑y) Complex.I))) (abs (toIocMod Real.two_pi_pos (Neg.neg Real.pi) (HSub.hSub x y)))","decl":"lemma angle_exp_exp (x y : ℝ) :\n    angle (exp (x * I)) (exp (y * I)) = |toIocMod Real.two_pi_pos (-π) (x - y)| := by\n  simp_rw [angle_eq_abs_arg (exp_ne_zero _) (exp_ne_zero _), ← exp_sub, ← sub_mul, ← ofReal_sub,\n    arg_exp_mul_I]\n\n"}
{"name":"Complex.angle_exp_one","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x : Real\n⊢ Eq (InnerProductGeometry.angle (Complex.exp (HMul.hMul (↑x) Complex.I)) 1) (abs (toIocMod Real.two_pi_pos (Neg.neg Real.pi) x))","decl":"lemma angle_exp_one (x : ℝ) : angle (exp (x * I)) 1 = |toIocMod Real.two_pi_pos (-π) x| := by\n  simpa using angle_exp_exp x 0\n\n"}
{"name":"Complex.norm_sub_mem_Icc_angle","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x y : Complex\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\n⊢ Membership.mem (Set.Icc (HMul.hMul (HDiv.hDiv 2 Real.pi) (InnerProductGeometry.angle x y)) (InnerProductGeometry.angle x y)) (Norm.norm (HSub.hSub x y))","decl":"/-- Chord-length is a multiple of arc-length up to constants. -/\nlemma norm_sub_mem_Icc_angle (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) :\n    ‖x - y‖ ∈ Icc (2 / π * angle x y) (angle x y) := by\n  wlog h : y = 1\n  · have := @this (x / y) 1 (by simp only [norm_div, hx, hy, div_one]) norm_one rfl\n    rwa [angle_div_left_eq_angle_mul_right, div_sub_one, norm_div, hy, div_one, one_mul]\n      at this\n    rintro rfl\n    simp at hy\n  subst y\n  rw [norm_eq_abs, abs_eq_one_iff'] at hx\n  obtain ⟨θ, hθ, rfl⟩ := hx\n  rw [angle_exp_one, exp_mul_I, add_sub_right_comm, (toIocMod_eq_self _).2]\n  · norm_cast\n    rw [norm_eq_abs, abs_add_mul_I]\n    refine ⟨Real.le_sqrt_of_sq_le ?_, ?_⟩\n    · rw [mul_pow, ← _root_.abs_pow, abs_sq]\n      calc\n        _ = 2 * (1 - (1 - 2 / π ^ 2 * θ ^ 2)) := by ring\n        _ ≤ 2 * (1 - θ.cos) := by\n            gcongr; exact Real.cos_le_one_sub_mul_cos_sq <| abs_le.2 <| Ioc_subset_Icc_self hθ\n        _  = _ := by linear_combination -θ.cos_sq_add_sin_sq\n    · rw [Real.sqrt_le_left (by positivity), ← _root_.abs_pow, abs_sq]\n      calc\n        _ = 2 * (1 - θ.cos) := by linear_combination θ.cos_sq_add_sin_sq\n        _ ≤ 2 * (1 - (1 - θ ^ 2 / 2)) := by gcongr; exact Real.one_sub_sq_div_two_le_cos\n        _ = _ := by ring\n  · convert hθ\n    ring\n\n"}
{"name":"Complex.norm_sub_le_angle","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x y : Complex\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\n⊢ LE.le (Norm.norm (HSub.hSub x y)) (InnerProductGeometry.angle x y)","decl":"/-- Chord-length is always less than arc-length. -/\nlemma norm_sub_le_angle (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) : ‖x - y‖ ≤ angle x y :=\n  (norm_sub_mem_Icc_angle hx hy).2\n\n"}
{"name":"Complex.mul_angle_le_norm_sub","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x y : Complex\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\n⊢ LE.le (HMul.hMul (HDiv.hDiv 2 Real.pi) (InnerProductGeometry.angle x y)) (Norm.norm (HSub.hSub x y))","decl":"/-- Chord-length is always greater than a multiple of arc-length. -/\nlemma mul_angle_le_norm_sub (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) : 2 / π * angle x y ≤ ‖x - y‖ :=\n  (norm_sub_mem_Icc_angle hx hy).1\n\n"}
{"name":"Complex.angle_le_mul_norm_sub","module":"Mathlib.Analysis.Complex.Angle","initialProofState":"x y : Complex\nhx : Eq (Norm.norm x) 1\nhy : Eq (Norm.norm y) 1\n⊢ LE.le (InnerProductGeometry.angle x y) (HMul.hMul (HDiv.hDiv Real.pi 2) (Norm.norm (HSub.hSub x y)))","decl":"/-- Arc-length is always less than a multiple of chord-length. -/\nlemma angle_le_mul_norm_sub (hx : ‖x‖ = 1) (hy : ‖y‖ = 1) : angle x y ≤ π / 2 * ‖x - y‖ := by\n  rw [← div_le_iff₀' <| by positivity, div_eq_inv_mul, inv_div]; exact mul_angle_le_norm_sub hx hy\n\n"}
