{"name":"AddGrp.FilteredColimits.G.mk_eq","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J AddGrp\nx y : Sigma fun j => ↑(F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)\n⊢ Eq (AddGrp.FilteredColimits.G.mk F x) (AddGrp.FilteredColimits.G.mk F y)","decl":"@[to_additive]\ntheorem G.mk_eq (x y : Σ j, F.obj j)\n    (h : ∃ (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k), F.map f x.2 = F.map g y.2) :\n    G.mk.{v, u} F x = G.mk F y :=\n  Quot.eqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel (F ⋙ forget Grp) x y h)\n\n"}
{"name":"Grp.FilteredColimits.G.mk_eq","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J Grp\nx y : Sigma fun j => ↑(F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)\n⊢ Eq (Grp.FilteredColimits.G.mk F x) (Grp.FilteredColimits.G.mk F y)","decl":"@[to_additive]\ntheorem G.mk_eq (x y : Σ j, F.obj j)\n    (h : ∃ (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k), F.map f x.2 = F.map g y.2) :\n    G.mk.{v, u} F x = G.mk F y :=\n  Quot.eqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel (F ⋙ forget Grp) x y h)\n\n"}
{"name":"Grp.FilteredColimits.colimitInvAux_eq_of_rel","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J Grp\nx y : Sigma fun j => ↑(F.obj j)\nh : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget Grp)) x y\n⊢ Eq (Grp.FilteredColimits.colimitInvAux F x) (Grp.FilteredColimits.colimitInvAux F y)","decl":"@[to_additive]\ntheorem colimitInvAux_eq_of_rel (x y : Σ j, F.obj j)\n    (h : Types.FilteredColimit.Rel (F ⋙ forget Grp) x y) :\n    colimitInvAux.{v, u} F x = colimitInvAux F y := by\n  apply G.mk_eq\n  obtain ⟨k, f, g, hfg⟩ := h\n  use k, f, g\n  rw [MonoidHom.map_inv, MonoidHom.map_inv, inv_inj]\n  exact hfg\n\n"}
{"name":"AddGrp.FilteredColimits.colimitNegAux_eq_of_rel","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J AddGrp\nx y : Sigma fun j => ↑(F.obj j)\nh : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget AddGrp)) x y\n⊢ Eq (AddGrp.FilteredColimits.colimitNegAux F x) (AddGrp.FilteredColimits.colimitNegAux F y)","decl":"@[to_additive]\ntheorem colimitInvAux_eq_of_rel (x y : Σ j, F.obj j)\n    (h : Types.FilteredColimit.Rel (F ⋙ forget Grp) x y) :\n    colimitInvAux.{v, u} F x = colimitInvAux F y := by\n  apply G.mk_eq\n  obtain ⟨k, f, g, hfg⟩ := h\n  use k, f, g\n  rw [MonoidHom.map_inv, MonoidHom.map_inv, inv_inj]\n  exact hfg\n\n"}
{"name":"Grp.FilteredColimits.colimit_inv_mk_eq","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J Grp\nx : Sigma fun j => ↑(F.obj j)\n⊢ Eq (Inv.inv (Grp.FilteredColimits.G.mk F x)) (Grp.FilteredColimits.G.mk F ⟨x.fst, Inv.inv x.snd⟩)","decl":"@[to_additive (attr := simp)]\ntheorem colimit_inv_mk_eq (x : Σ j, F.obj j) : (G.mk.{v, u} F x)⁻¹ = G.mk F ⟨x.1, x.2⁻¹⟩ :=\n  rfl\n\n"}
{"name":"AddGrp.FilteredColimits.colimit_neg_mk_eq","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\ninst✝ : CategoryTheory.IsFiltered J\nF : CategoryTheory.Functor J AddGrp\nx : Sigma fun j => ↑(F.obj j)\n⊢ Eq (Neg.neg (AddGrp.FilteredColimits.G.mk F x)) (AddGrp.FilteredColimits.G.mk F ⟨x.fst, Neg.neg x.snd⟩)","decl":"@[to_additive (attr := simp)]\ntheorem colimit_inv_mk_eq (x : Σ j, F.obj j) : (G.mk.{v, u} F x)⁻¹ = G.mk F ⟨x.1, x.2⁻¹⟩ :=\n  rfl\n\n"}
{"name":"AddGrp.FilteredColimits.forget₂AddMon_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ AddGrp AddMonCat)","decl":"@[to_additive forget₂AddMon_preservesFilteredColimits]\nnoncomputable instance forget₂Mon_preservesFilteredColimits :\n    PreservesFilteredColimits.{u} (forget₂ Grp.{u} MonCat.{u}) where\n      preserves_filtered_colimits x hx1 _ :=\n      letI : Category.{u, u} x := hx1\n      ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n          (MonCat.FilteredColimits.colimitCoconeIsColimit.{u, u} _)⟩\n\n"}
{"name":"Grp.FilteredColimits.forget₂Mon_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ Grp MonCat)","decl":"@[to_additive forget₂AddMon_preservesFilteredColimits]\nnoncomputable instance forget₂Mon_preservesFilteredColimits :\n    PreservesFilteredColimits.{u} (forget₂ Grp.{u} MonCat.{u}) where\n      preserves_filtered_colimits x hx1 _ :=\n      letI : Category.{u, u} x := hx1\n      ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n          (MonCat.FilteredColimits.colimitCoconeIsColimit.{u, u} _)⟩\n\n"}
{"name":"AddGrp.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget AddGrp)","decl":"@[to_additive]\nnoncomputable instance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget Grp.{u}) :=\n  Limits.comp_preservesFilteredColimits (forget₂ Grp MonCat) (forget MonCat.{u})\n\n"}
{"name":"Grp.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget Grp)","decl":"@[to_additive]\nnoncomputable instance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget Grp.{u}) :=\n  Limits.comp_preservesFilteredColimits (forget₂ Grp MonCat) (forget MonCat.{u})\n\n"}
{"name":"AddCommGrp.FilteredColimits.forget₂AddGroup_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ AddCommGrp AddGrp)","decl":"@[to_additive]\nnoncomputable instance forget₂Group_preservesFilteredColimits :\n    PreservesFilteredColimits (forget₂ CommGrp Grp.{u}) where\n  preserves_filtered_colimits J hJ1 _ :=\n    letI : Category J := hJ1\n    { preservesColimit := fun {F} =>\n        preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n          (Grp.FilteredColimits.colimitCoconeIsColimit.{u, u}\n            (F ⋙ forget₂ CommGrp Grp.{u})) }\n\n"}
{"name":"CommGrp.FilteredColimits.forget₂Group_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ CommGrp Grp)","decl":"@[to_additive]\nnoncomputable instance forget₂Group_preservesFilteredColimits :\n    PreservesFilteredColimits (forget₂ CommGrp Grp.{u}) where\n  preserves_filtered_colimits J hJ1 _ :=\n    letI : Category J := hJ1\n    { preservesColimit := fun {F} =>\n        preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n          (Grp.FilteredColimits.colimitCoconeIsColimit.{u, u}\n            (F ⋙ forget₂ CommGrp Grp.{u})) }\n\n"}
{"name":"CommGrp.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget CommGrp)","decl":"@[to_additive]\nnoncomputable instance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget CommGrp.{u}) :=\n  Limits.comp_preservesFilteredColimits (forget₂ CommGrp Grp) (forget Grp.{u})\n\n"}
{"name":"AddCommGrp.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.Grp.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget AddCommGrp)","decl":"@[to_additive]\nnoncomputable instance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget CommGrp.{u}) :=\n  Limits.comp_preservesFilteredColimits (forget₂ CommGrp Grp) (forget Grp.{u})\n\n"}
