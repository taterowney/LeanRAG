{"name":"LinearOrderedCommMonoidWithZero.zero_le_one","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommMonoidWithZero α\n⊢ LE.le 0 1","decl":"/-- A linearly ordered commutative monoid with a zero element. -/\nclass LinearOrderedCommMonoidWithZero (α : Type*) extends LinearOrderedCommMonoid α,\n  CommMonoidWithZero α, OrderBot α where\n  /-- `0 ≤ 1` in any linearly ordered commutative monoid. -/\n  zero_le_one : (0 : α) ≤ 1\n\n"}
{"name":"LinearOrderedCommMonoidWithZero.mul_zero","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommMonoidWithZero α\na : α\n⊢ Eq (HMul.hMul a 0) 0","decl":"/-- A linearly ordered commutative monoid with a zero element. -/\nclass LinearOrderedCommMonoidWithZero (α : Type*) extends LinearOrderedCommMonoid α,\n  CommMonoidWithZero α, OrderBot α where\n  /-- `0 ≤ 1` in any linearly ordered commutative monoid. -/\n  zero_le_one : (0 : α) ≤ 1\n\n"}
{"name":"LinearOrderedCommMonoidWithZero.zero_mul","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommMonoidWithZero α\na : α\n⊢ Eq (HMul.hMul 0 a) 0","decl":"/-- A linearly ordered commutative monoid with a zero element. -/\nclass LinearOrderedCommMonoidWithZero (α : Type*) extends LinearOrderedCommMonoid α,\n  CommMonoidWithZero α, OrderBot α where\n  /-- `0 ≤ 1` in any linearly ordered commutative monoid. -/\n  zero_le_one : (0 : α) ≤ 1\n\n"}
{"name":"LinearOrderedCommGroupWithZero.mul_inv_cancel","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\na : α\na✝ : Ne a 0\n⊢ Eq (HMul.hMul a (Inv.inv a)) 1","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommGroupWithZero.inv_zero","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\n⊢ Eq (Inv.inv 0) 0","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommGroupWithZero.div_eq_mul_inv","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\na b : α\n⊢ Eq (HDiv.hDiv a b) (HMul.hMul a (Inv.inv b))","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommGroupWithZero.zpow_succ'","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\nn : Nat\na : α\n⊢ Eq (LinearOrderedCommGroupWithZero.zpow (↑n.succ) a) (HMul.hMul (LinearOrderedCommGroupWithZero.zpow (↑n) a) a)","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommGroupWithZero.zpow_zero'","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\na : α\n⊢ Eq (LinearOrderedCommGroupWithZero.zpow 0 a) 1","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommGroupWithZero.toNontrivial","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\n⊢ Nontrivial α","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommGroupWithZero.zpow_neg'","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_2\nself : LinearOrderedCommGroupWithZero α\nn : Nat\na : α\n⊢ Eq (LinearOrderedCommGroupWithZero.zpow (Int.negSucc n) a) (Inv.inv (LinearOrderedCommGroupWithZero.zpow (↑n.succ) a))","decl":"/-- A linearly ordered commutative group with a zero element. -/\nclass LinearOrderedCommGroupWithZero (α : Type*) extends LinearOrderedCommMonoidWithZero α,\n  CommGroupWithZero α\n\n"}
{"name":"LinearOrderedCommMonoidWithZero.toZeroLeOneClass","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\n⊢ ZeroLEOneClass α","decl":"instance (priority := 100) LinearOrderedCommMonoidWithZero.toZeroLeOneClass\n    [LinearOrderedCommMonoidWithZero α] : ZeroLEOneClass α :=\n  { ‹LinearOrderedCommMonoidWithZero α› with }\n\n"}
{"name":"CanonicallyOrderedAdd.toZeroLeOneClass","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝³ : AddZeroClass α\ninst✝² : LE α\ninst✝¹ : CanonicallyOrderedAdd α\ninst✝ : One α\n⊢ ZeroLEOneClass α","decl":"instance (priority := 100) CanonicallyOrderedAdd.toZeroLeOneClass\n    [AddZeroClass α] [LE α] [CanonicallyOrderedAdd α] [One α] : ZeroLEOneClass α :=\n  ⟨zero_le 1⟩\n\n"}
{"name":"zero_le'","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\na : α\n⊢ LE.le 0 a","decl":"@[simp] lemma zero_le' : 0 ≤ a := by\n  simpa only [mul_zero, mul_one] using mul_le_mul_left' (zero_le_one' α) a\n\n"}
{"name":"not_lt_zero'","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\na : α\n⊢ Not (LT.lt a 0)","decl":"@[simp]\ntheorem not_lt_zero' : ¬a < 0 :=\n  not_lt_of_le zero_le'\n\n"}
{"name":"le_zero_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\na : α\n⊢ Iff (LE.le a 0) (Eq a 0)","decl":"@[simp]\ntheorem le_zero_iff : a ≤ 0 ↔ a = 0 :=\n  ⟨fun h ↦ le_antisymm h zero_le', fun h ↦ h ▸ le_rfl⟩\n\n"}
{"name":"zero_lt_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\na : α\n⊢ Iff (LT.lt 0 a) (Ne a 0)","decl":"theorem zero_lt_iff : 0 < a ↔ a ≠ 0 :=\n  ⟨ne_of_gt, fun h ↦ lt_of_le_of_ne zero_le' h.symm⟩\n\n"}
{"name":"ne_zero_of_lt","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\na b : α\nh : LT.lt b a\n⊢ Ne a 0","decl":"theorem ne_zero_of_lt (h : b < a) : a ≠ 0 := fun h1 ↦ not_lt_zero' <| show b < 0 from h1 ▸ h\n\n"}
{"name":"bot_eq_zero''","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommMonoidWithZero α\n⊢ Eq Bot.bot 0","decl":"/-- See also `bot_eq_zero` and `bot_eq_zero'` for canonically ordered monoids. -/\nlemma bot_eq_zero'' : (⊥ : α) = 0 := eq_of_forall_ge_iff fun _ ↦ by simp\n\n"}
{"name":"pow_pos_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝¹ : LinearOrderedCommMonoidWithZero α\na : α\nn : Nat\ninst✝ : NoZeroDivisors α\nhn : Ne n 0\n⊢ Iff (LT.lt 0 (HPow.hPow a n)) (LT.lt 0 a)","decl":"lemma pow_pos_iff (hn : n ≠ 0) : 0 < a ^ n ↔ 0 < a := by simp_rw [zero_lt_iff, pow_ne_zero_iff hn]\n\n"}
{"name":"LinearOrderedCommGroupWithZero.toMulPosMono","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ MulPosMono α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toMulPosMono : MulPosMono α where\n  elim _a _b _c hbc := mul_le_mul_right' hbc _\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroupWithZero.toPosMulMono","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ PosMulMono α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toPosMulMono : PosMulMono α where\n  elim _a _b _c hbc := mul_le_mul_left' hbc _\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroupWithZero.toPosMulReflectLE","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ PosMulReflectLE α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toPosMulReflectLE :\n    PosMulReflectLE α where\n  elim a b c hbc := by simpa [a.2.ne'] using mul_le_mul_left' hbc a⁻¹\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroupWithZero.toMulPosReflectLE","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ MulPosReflectLE α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toMulPosReflectLE :\n    MulPosReflectLE α where\n  elim a b c hbc := by simpa [a.2.ne'] using mul_le_mul_right' hbc a⁻¹\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroupWithZero.toPosMulReflectLT","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ PosMulReflectLT α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toPosMulReflectLT :\n    PosMulReflectLT α where elim _a _b _c := lt_of_mul_lt_mul_left'\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroupWithZero.toPosMulStrictMono","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ PosMulStrictMono α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toPosMulStrictMono :\n    PosMulStrictMono α where\n  elim a b c hbc := by by_contra! h; exact hbc.not_le <| (mul_le_mul_left a.2).1 h\n\n-- See note [lower instance priority]\n"}
{"name":"LinearOrderedCommGroupWithZero.toMulPosStrictMono","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\n⊢ MulPosStrictMono α","decl":"instance (priority := 100) LinearOrderedCommGroupWithZero.toMulPosStrictMono :\n    MulPosStrictMono α where\n  elim a b c hbc := by by_contra! h; exact hbc.not_le <| (mul_le_mul_right a.2).1 h\n\n"}
{"name":"mul_inv_le_of_le_mul","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c : α\nhab : LE.le a (HMul.hMul b c)\n⊢ LE.le (HMul.hMul a (Inv.inv c)) b","decl":"@[deprecated mul_inv_le_of_le_mul₀ (since := \"2024-11-18\")]\ntheorem mul_inv_le_of_le_mul (hab : a ≤ b * c) : a * c⁻¹ ≤ b :=\n  mul_inv_le_of_le_mul₀ zero_le' zero_le' hab\n\n"}
{"name":"Units.zero_lt","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\nu : Units α\n⊢ LT.lt 0 ↑u","decl":"@[simp]\ntheorem Units.zero_lt (u : αˣ) : (0 : α) < u :=\n  zero_lt_iff.2 u.ne_zero\n\n"}
{"name":"mul_lt_mul_of_lt_of_le₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c d : α\nhab : LE.le a b\nhb : Ne b 0\nhcd : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"@[deprecated mul_lt_mul_of_le_of_lt_of_nonneg_of_pos (since := \"2024-11-18\")]\ntheorem mul_lt_mul_of_lt_of_le₀ (hab : a ≤ b) (hb : b ≠ 0) (hcd : c < d) : a * c < b * d :=\n  mul_lt_mul_of_le_of_lt_of_nonneg_of_pos hab hcd zero_le' (zero_lt_iff.2 hb)\n\n"}
{"name":"mul_lt_mul₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c d : α\nhab : LT.lt a b\nhcd : LT.lt c d\n⊢ LT.lt (HMul.hMul a c) (HMul.hMul b d)","decl":"@[deprecated mul_lt_mul'' (since := \"2024-11-18\")]\ntheorem mul_lt_mul₀ (hab : a < b) (hcd : c < d) : a * c < b * d :=\n  mul_lt_mul'' hab hcd zero_le' zero_le'\n\n"}
{"name":"mul_inv_lt_of_lt_mul₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c : α\nh : LT.lt a (HMul.hMul b c)\n⊢ LT.lt (HMul.hMul a (Inv.inv c)) b","decl":"theorem mul_inv_lt_of_lt_mul₀ (h : a < b * c) : a * c⁻¹ < b := by\n  contrapose! h\n  simpa only [inv_inv] using mul_inv_le_of_le_mul₀ zero_le' zero_le' h\n\n"}
{"name":"inv_mul_lt_of_lt_mul₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c : α\nh : LT.lt a (HMul.hMul b c)\n⊢ LT.lt (HMul.hMul (Inv.inv b) a) c","decl":"theorem inv_mul_lt_of_lt_mul₀ (h : a < b * c) : b⁻¹ * a < c := by\n  rw [mul_comm] at *\n  exact mul_inv_lt_of_lt_mul₀ h\n\n"}
{"name":"lt_of_mul_lt_mul_of_le₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c d : α\nh : LT.lt (HMul.hMul a b) (HMul.hMul c d)\nhc : LT.lt 0 c\nhh : LE.le c a\n⊢ LT.lt b d","decl":"theorem lt_of_mul_lt_mul_of_le₀ (h : a * b < c * d) (hc : 0 < c) (hh : c ≤ a) : b < d := by\n  have ha : a ≠ 0 := ne_of_gt (lt_of_lt_of_le hc hh)\n  rw [← inv_le_inv₀ (zero_lt_iff.2 ha) hc] at hh\n  simpa [inv_mul_cancel_left₀ ha, inv_mul_cancel_left₀ hc.ne']\n    using mul_lt_mul_of_le_of_lt_of_nonneg_of_pos hh  h zero_le' (inv_pos.2 hc)\n\n"}
{"name":"div_le_div_right₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c : α\nhc : Ne c 0\n⊢ Iff (LE.le (HDiv.hDiv a c) (HDiv.hDiv b c)) (LE.le a b)","decl":"@[deprecated div_le_div_iff_of_pos_right (since := \"2024-11-18\")]\ntheorem div_le_div_right₀ (hc : c ≠ 0) : a / c ≤ b / c ↔ a ≤ b :=\n  div_le_div_iff_of_pos_right (zero_lt_iff.2 hc)\n\n"}
{"name":"div_le_div_left₀","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na b c : α\nha : Ne a 0\nhb : Ne b 0\nhc : Ne c 0\n⊢ Iff (LE.le (HDiv.hDiv a b) (HDiv.hDiv a c)) (LE.le c b)","decl":"@[deprecated div_le_div_iff_of_pos_left (since := \"2024-11-18\")]\ntheorem div_le_div_left₀ (ha : a ≠ 0) (hb : b ≠ 0) (hc : c ≠ 0) : a / b ≤ a / c ↔ c ≤ b :=\n  div_le_div_iff_of_pos_left (zero_lt_iff.2 ha) (zero_lt_iff.2 hb) (zero_lt_iff.2 hc)\n\n"}
{"name":"OrderIso.mulLeft₀'_apply","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nha : Ne a 0\nx : α\n⊢ Eq ((OrderIso.mulLeft₀' ha) x) (HMul.hMul a x)","decl":"/-- `Equiv.mulLeft₀` as an `OrderIso` on a `LinearOrderedCommGroupWithZero.`. -/\n@[simps! (config := { simpRhs := true }) apply toEquiv,\ndeprecated OrderIso.mulLeft₀ (since := \"2024-11-18\")]\ndef OrderIso.mulLeft₀' {a : α} (ha : a ≠ 0) : α ≃o α := .mulLeft₀ a (zero_lt_iff.2 ha)\n\n"}
{"name":"OrderIso.mulLeft₀'_toEquiv","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nha : Ne a 0\n⊢ Eq (OrderIso.mulLeft₀' ha).toEquiv (Equiv.mulLeft₀ a ⋯)","decl":"/-- `Equiv.mulLeft₀` as an `OrderIso` on a `LinearOrderedCommGroupWithZero.`. -/\n@[simps! (config := { simpRhs := true }) apply toEquiv,\ndeprecated OrderIso.mulLeft₀ (since := \"2024-11-18\")]\ndef OrderIso.mulLeft₀' {a : α} (ha : a ≠ 0) : α ≃o α := .mulLeft₀ a (zero_lt_iff.2 ha)\n\n"}
{"name":"OrderIso.mulLeft₀'_symm","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nha : Ne a 0\n⊢ Eq (OrderIso.mulLeft₀' ha).symm (OrderIso.mulLeft₀' ⋯)","decl":"set_option linter.deprecated false in\n@[deprecated OrderIso.mulLeft₀_symm (since := \"2024-11-18\")]\ntheorem OrderIso.mulLeft₀'_symm {a : α} (ha : a ≠ 0) :\n    (OrderIso.mulLeft₀' ha).symm = OrderIso.mulLeft₀' (inv_ne_zero ha) := by\n  ext\n  rfl\n\n"}
{"name":"OrderIso.mulRight₀'_apply","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nha : Ne a 0\nx : α\n⊢ Eq ((OrderIso.mulRight₀' ha) x) (HMul.hMul x a)","decl":"/-- `Equiv.mulRight₀` as an `OrderIso` on a `LinearOrderedCommGroupWithZero.`. -/\n@[simps! (config := { simpRhs := true }) apply toEquiv,\ndeprecated OrderIso.mulRight₀ (since := \"2024-11-18\")]\ndef OrderIso.mulRight₀' {a : α} (ha : a ≠ 0) : α ≃o α := .mulRight₀ a (zero_lt_iff.2 ha)\n\n"}
{"name":"OrderIso.mulRight₀'_toEquiv","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nha : Ne a 0\n⊢ Eq (OrderIso.mulRight₀' ha).toEquiv (Equiv.mulRight₀ a ⋯)","decl":"/-- `Equiv.mulRight₀` as an `OrderIso` on a `LinearOrderedCommGroupWithZero.`. -/\n@[simps! (config := { simpRhs := true }) apply toEquiv,\ndeprecated OrderIso.mulRight₀ (since := \"2024-11-18\")]\ndef OrderIso.mulRight₀' {a : α} (ha : a ≠ 0) : α ≃o α := .mulRight₀ a (zero_lt_iff.2 ha)\n\n"}
{"name":"OrderIso.mulRight₀'_symm","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nha : Ne a 0\n⊢ Eq (OrderIso.mulRight₀' ha).symm (OrderIso.mulRight₀' ⋯)","decl":"set_option linter.deprecated false in\n@[deprecated OrderIso.mulRight₀_symm (since := \"2024-11-18\")]\ntheorem OrderIso.mulRight₀'_symm {a : α} (ha : a ≠ 0) :\n    (OrderIso.mulRight₀' ha).symm = OrderIso.mulRight₀' (inv_ne_zero ha) := by\n  ext\n  rfl\n\n"}
{"name":"pow_lt_pow_succ","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedCommGroupWithZero α\na : α\nn : Nat\nha : LT.lt 1 a\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow a n.succ)","decl":"@[deprecated pow_lt_pow_right₀ (since := \"2024-11-18\")]\nlemma pow_lt_pow_succ (ha : 1 < a) : a ^ n < a ^ n.succ := pow_lt_pow_right₀ ha n.lt_succ_self\n\n"}
{"name":"ofAdd_toDual_eq_zero_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommMonoidWithTop α\nx : α\n⊢ Iff (Eq (Multiplicative.ofAdd (OrderDual.toDual x)) 0) (Eq x Top.top)","decl":"@[simp]\ntheorem ofAdd_toDual_eq_zero_iff [LinearOrderedAddCommMonoidWithTop α]\n    (x : α) : Multiplicative.ofAdd (OrderDual.toDual x) = 0 ↔ x = ⊤ := Iff.rfl\n\n"}
{"name":"ofDual_toAdd_eq_top_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommMonoidWithTop α\nx : Multiplicative (OrderDual α)\n⊢ Iff (Eq (OrderDual.ofDual (Multiplicative.toAdd x)) Top.top) (Eq x 0)","decl":"@[simp]\ntheorem ofDual_toAdd_eq_top_iff [LinearOrderedAddCommMonoidWithTop α]\n    (x : Multiplicative αᵒᵈ) : OrderDual.ofDual x.toAdd = ⊤ ↔ x = 0 := Iff.rfl\n\n"}
{"name":"ofAdd_bot","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommMonoidWithTop α\n⊢ Eq (Multiplicative.ofAdd Bot.bot) 0","decl":"@[simp]\ntheorem ofAdd_bot [LinearOrderedAddCommMonoidWithTop α] :\n    Multiplicative.ofAdd ⊥ = (0 : Multiplicative αᵒᵈ) := rfl\n\n"}
{"name":"ofDual_toAdd_zero","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrderedAddCommMonoidWithTop α\n⊢ Eq (OrderDual.ofDual (Multiplicative.toAdd 0)) Top.top","decl":"@[simp]\ntheorem ofDual_toAdd_zero [LinearOrderedAddCommMonoidWithTop α] :\n    OrderDual.ofDual (0 : Multiplicative αᵒᵈ).toAdd = ⊤ := rfl\n\n"}
{"name":"WithZero.zero_le","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : WithZero α\n⊢ LE.le 0 a","decl":"lemma zero_le (a : WithZero α) : 0 ≤ a := bot_le\n\n"}
{"name":"WithZero.zero_lt_coe","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\n⊢ LT.lt 0 ↑a","decl":"lemma zero_lt_coe (a : α) : (0 : WithZero α) < a := WithBot.bot_lt_coe a\n\n"}
{"name":"WithZero.zero_eq_bot","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\n⊢ Eq 0 Bot.bot","decl":"lemma zero_eq_bot : (0 : WithZero α) = ⊥ := rfl\n\n"}
{"name":"WithZero.coe_lt_coe","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"@[simp, norm_cast] lemma coe_lt_coe : (a : WithZero α) < b ↔ a < b := WithBot.coe_lt_coe\n\n"}
{"name":"WithZero.coe_le_coe","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"@[simp, norm_cast] lemma coe_le_coe : (a : WithZero α) ≤ b ↔ a ≤ b := WithBot.coe_le_coe\n\n"}
{"name":"WithZero.one_lt_coe","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : One α\n⊢ Iff (LT.lt 1 ↑a) (LT.lt 1 a)","decl":"@[simp, norm_cast] lemma one_lt_coe [One α] : 1 < (a : WithZero α) ↔ 1 < a := coe_lt_coe\n\n"}
{"name":"WithZero.one_le_coe","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : One α\n⊢ Iff (LE.le 1 ↑a) (LE.le 1 a)","decl":"@[simp, norm_cast] lemma one_le_coe [One α] : 1 ≤ (a : WithZero α) ↔ 1 ≤ a := coe_le_coe\n\n"}
{"name":"WithZero.coe_lt_one","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : One α\n⊢ Iff (LT.lt (↑a) 1) (LT.lt a 1)","decl":"@[simp, norm_cast] lemma coe_lt_one [One α] : (a : WithZero α) < 1 ↔ a < 1 := coe_lt_coe\n\n"}
{"name":"WithZero.coe_le_one","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\na : α\ninst✝ : One α\n⊢ Iff (LE.le (↑a) 1) (LE.le a 1)","decl":"@[simp, norm_cast] lemma coe_le_one [One α] : (a : WithZero α) ≤ 1 ↔ a ≤ 1 := coe_le_coe\n\n"}
{"name":"WithZero.coe_le_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\nx : WithZero α\n⊢ Iff (LE.le (↑a) x) (Exists fun b => And (Eq x ↑b) (LE.le a b))","decl":"theorem coe_le_iff {x : WithZero α} : (a : WithZero α) ≤ x ↔ ∃ b : α, x = b ∧ a ≤ b :=\n  WithBot.coe_le_iff\n\n"}
{"name":"WithZero.unzero_le_unzero","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : WithZero α\nha : Ne a 0\nhb : Ne b 0\n⊢ Iff (LE.le (WithZero.unzero ha) (WithZero.unzero hb)) (LE.le a b)","decl":"@[simp] lemma unzero_le_unzero {a b : WithZero α} (ha hb) :\n    unzero (x := a) ha ≤ unzero (x := b) hb ↔ a ≤ b := by\n  -- TODO: Fix `lift` so that it doesn't try to clear the hypotheses I give it when it is\n  -- impossible to do so. See https://github.com/leanprover-community/mathlib4/issues/19160\n  lift a to α using id ha\n  lift b to α using id hb\n  simp\n\n"}
{"name":"WithZero.mulLeftMono","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : Mul α\ninst✝ : MulLeftMono α\n⊢ MulLeftMono (WithZero α)","decl":"instance mulLeftMono [Mul α] [MulLeftMono α] :\n    MulLeftMono (WithZero α) := by\n  refine ⟨fun a b c hbc => ?_⟩\n  induction a; · exact zero_le _\n  induction b; · exact zero_le _\n  rcases WithZero.coe_le_iff.1 hbc with ⟨c, rfl, hbc'⟩\n  rw [← coe_mul _ c, ← coe_mul, coe_le_coe]\n  exact mul_le_mul_left' hbc' _\n\n"}
{"name":"WithZero.addLeftMono","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : AddZeroClass α\ninst✝ : AddLeftMono α\nh : ∀ (a : α), LE.le 0 a\n⊢ AddLeftMono (WithZero α)","decl":"protected lemma addLeftMono [AddZeroClass α] [AddLeftMono α]\n    (h : ∀ a : α, 0 ≤ a) : AddLeftMono (WithZero α) := by\n  refine ⟨fun a b c hbc => ?_⟩\n  induction a\n  · rwa [zero_add, zero_add]\n  induction b\n  · rw [add_zero]\n    induction c\n    · rw [add_zero]\n    · rw [← coe_add, coe_le_coe]\n      exact le_add_of_nonneg_right (h _)\n  · rcases WithZero.coe_le_iff.1 hbc with ⟨c, rfl, hbc'⟩\n    rw [← coe_add, ← coe_add _ c, coe_le_coe]\n    exact add_le_add_left hbc' _\n\n"}
{"name":"WithZero.existsAddOfLE","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝² : Preorder α\ninst✝¹ : Add α\ninst✝ : ExistsAddOfLE α\n⊢ ExistsAddOfLE (WithZero α)","decl":"instance existsAddOfLE [Add α] [ExistsAddOfLE α] : ExistsAddOfLE (WithZero α) :=\n  ⟨fun {a b} => by\n    induction a\n    · exact fun _ => ⟨b, (zero_add b).symm⟩\n    induction b\n    · exact fun h => (WithBot.not_coe_le_bot _ h).elim\n    intro h\n    obtain ⟨c, rfl⟩ := exists_add_of_le (WithZero.coe_le_coe.1 h)\n    exact ⟨c, rfl⟩⟩\n\n"}
{"name":"WithZero.mulLeftReflectLT","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝² : PartialOrder α\ninst✝¹ : Mul α\ninst✝ : MulLeftReflectLT α\n⊢ MulLeftReflectLT (WithZero α)","decl":"instance mulLeftReflectLT [Mul α] [MulLeftReflectLT α] :\n    MulLeftReflectLT (WithZero α) := by\n  refine ⟨fun a b c h => ?_⟩\n  have := ((zero_le _).trans_lt h).ne'\n  induction a\n  · simp at this\n  induction c\n  · simp at this\n  induction b\n  exacts [zero_lt_coe _, coe_lt_coe.mpr (lt_of_mul_lt_mul_left' <| coe_lt_coe.mp h)]\n\n"}
{"name":"WithZero.le_max_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LE.le (↑a) (Max.max ↑b ↑c)) (LE.le a (Max.max b c))","decl":"protected lemma le_max_iff : (a : WithZero α) ≤ max (b : WithZero α) c ↔ a ≤ max b c := by\n  simp only [WithZero.coe_le_coe, le_max_iff]\n\n"}
{"name":"WithZero.min_le_iff","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝ : LinearOrder α\na b c : α\n⊢ Iff (LE.le (Min.min ↑a ↑b) ↑c) (LE.le (Min.min a b) c)","decl":"protected lemma min_le_iff : min (a : WithZero α) b ≤ c ↔ min a b ≤ c := by\n  simp only [WithZero.coe_le_coe, min_le_iff]\n\n"}
{"name":"WithZero.canonicallyOrderedAdd","module":"Mathlib.Algebra.Order.GroupWithZero.Canonical","initialProofState":"α : Type u_1\ninst✝² : AddZeroClass α\ninst✝¹ : Preorder α\ninst✝ : CanonicallyOrderedAdd α\n⊢ CanonicallyOrderedAdd (WithZero α)","decl":"/-- Adding a new zero to a canonically ordered additive monoid produces another one. -/\ninstance canonicallyOrderedAdd [AddZeroClass α] [Preorder α] [CanonicallyOrderedAdd α] :\n    CanonicallyOrderedAdd (WithZero α) :=\n  { WithZero.existsAddOfLE with\n    le_self_add := fun a b => by\n      induction a\n      · exact bot_le\n      induction b\n      · exact le_rfl\n      · exact WithZero.coe_le_coe.2 le_self_add }\n\n"}
