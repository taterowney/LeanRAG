{"name":"IsAddUnit.eq_on_neg","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nN : Type u_3\ninst✝³ : SubtractionMonoid G\ninst✝² : AddMonoid N\ninst✝¹ : FunLike F G N\ninst✝ : AddMonoidHomClass F G N\nx : G\nhx : IsAddUnit x\nf g : F\nh : Eq (f x) (g x)\n⊢ Eq (f (Neg.neg x)) (g (Neg.neg x))","decl":"/-- If two homomorphisms from a division monoid to a monoid are equal at a unit `x`, then they are\nequal at `x⁻¹`. -/\n@[to_additive\n  \"If two homomorphisms from a subtraction monoid to an additive monoid are equal at an\n  additive unit `x`, then they are equal at `-x`.\"]\ntheorem IsUnit.eq_on_inv {F G N} [DivisionMonoid G] [Monoid N] [FunLike F G N]\n    [MonoidHomClass F G N] {x : G} (hx : IsUnit x) (f g : F) (h : f x = g x) : f x⁻¹ = g x⁻¹ :=\n  left_inv_eq_right_inv (map_mul_eq_one f hx.inv_mul_cancel)\n    (h.symm ▸ map_mul_eq_one g (hx.mul_inv_cancel))\n\n"}
{"name":"IsUnit.eq_on_inv","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nN : Type u_3\ninst✝³ : DivisionMonoid G\ninst✝² : Monoid N\ninst✝¹ : FunLike F G N\ninst✝ : MonoidHomClass F G N\nx : G\nhx : IsUnit x\nf g : F\nh : Eq (f x) (g x)\n⊢ Eq (f (Inv.inv x)) (g (Inv.inv x))","decl":"/-- If two homomorphisms from a division monoid to a monoid are equal at a unit `x`, then they are\nequal at `x⁻¹`. -/\n@[to_additive\n  \"If two homomorphisms from a subtraction monoid to an additive monoid are equal at an\n  additive unit `x`, then they are equal at `-x`.\"]\ntheorem IsUnit.eq_on_inv {F G N} [DivisionMonoid G] [Monoid N] [FunLike F G N]\n    [MonoidHomClass F G N] {x : G} (hx : IsUnit x) (f g : F) (h : f x = g x) : f x⁻¹ = g x⁻¹ :=\n  left_inv_eq_right_inv (map_mul_eq_one f hx.inv_mul_cancel)\n    (h.symm ▸ map_mul_eq_one g (hx.mul_inv_cancel))\n\n"}
{"name":"eq_on_neg","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nM : Type u_3\ninst✝³ : AddGroup G\ninst✝² : AddMonoid M\ninst✝¹ : FunLike F G M\ninst✝ : AddMonoidHomClass F G M\nf g : F\nx : G\nh : Eq (f x) (g x)\n⊢ Eq (f (Neg.neg x)) (g (Neg.neg x))","decl":"/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\n@[to_additive\n    \"If two homomorphism from an additive group to an additive monoid are equal at `x`,\n    then they are equal at `-x`.\"]\ntheorem eq_on_inv {F G M} [Group G] [Monoid M] [FunLike F G M] [MonoidHomClass F G M]\n    (f g : F) {x : G} (h : f x = g x) : f x⁻¹ = g x⁻¹ :=\n  (Group.isUnit x).eq_on_inv f g h\n\n"}
{"name":"eq_on_inv","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nM : Type u_3\ninst✝³ : Group G\ninst✝² : Monoid M\ninst✝¹ : FunLike F G M\ninst✝ : MonoidHomClass F G M\nf g : F\nx : G\nh : Eq (f x) (g x)\n⊢ Eq (f (Inv.inv x)) (g (Inv.inv x))","decl":"/-- If two homomorphism from a group to a monoid are equal at `x`, then they are equal at `x⁻¹`. -/\n@[to_additive\n    \"If two homomorphism from an additive group to an additive monoid are equal at `x`,\n    then they are equal at `-x`.\"]\ntheorem eq_on_inv {F G M} [Group G] [Monoid M] [FunLike F G M] [MonoidHomClass F G M]\n    (f g : F) {x : G} (h : f x = g x) : f x⁻¹ = g x⁻¹ :=\n  (Group.isUnit x).eq_on_inv f g h\n\n"}
{"name":"Units.coe_map","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nx : Units M\n⊢ Eq (↑((Units.map f) x)) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : M →* N) (x : Mˣ) : ↑(map f x) = f x := rfl\n\n"}
{"name":"AddUnits.coe_map","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nx : AddUnits M\n⊢ Eq (↑((AddUnits.map f) x)) (f ↑x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_map (f : M →* N) (x : Mˣ) : ↑(map f x) = f x := rfl\n\n"}
{"name":"Units.coe_map_inv","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nu : Units M\n⊢ Eq (↑(Inv.inv ((Units.map f) u))) (f ↑(Inv.inv u))","decl":"@[to_additive (attr := simp)]\ntheorem coe_map_inv (f : M →* N) (u : Mˣ) : ↑(map f u)⁻¹ = f ↑u⁻¹ := rfl\n\n"}
{"name":"AddUnits.coe_map_neg","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nu : AddUnits M\n⊢ Eq (↑(Neg.neg ((AddUnits.map f) u))) (f ↑(Neg.neg u))","decl":"@[to_additive (attr := simp)]\ntheorem coe_map_inv (f : M →* N) (u : Mˣ) : ↑(map f u)⁻¹ = f ↑u⁻¹ := rfl\n\n"}
{"name":"Units.map_mk","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nval inv : M\nval_inv : Eq (HMul.hMul val inv) 1\ninv_val : Eq (HMul.hMul inv val) 1\n⊢ Eq ((Units.map f) { val := val, inv := inv, val_inv := val_inv, inv_val := inv_val }) { val := f val, inv := f inv, val_inv := ⋯, inv_val := ⋯ }","decl":"@[to_additive (attr := simp)]\nlemma map_mk (f : M →* N) (val inv : M) (val_inv inv_val) :\n    map f (mk val inv val_inv inv_val) = mk (f val) (f inv)\n      (by rw [← f.map_mul, val_inv, f.map_one]) (by rw [← f.map_mul, inv_val, f.map_one]) := rfl\n\n"}
{"name":"AddUnits.map_mk","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nval inv : M\nval_inv : Eq (HAdd.hAdd val inv) 0\ninv_val : Eq (HAdd.hAdd inv val) 0\n⊢ Eq ((AddUnits.map f) { val := val, neg := inv, val_neg := val_inv, neg_val := inv_val }) { val := f val, neg := f inv, val_neg := ⋯, neg_val := ⋯ }","decl":"@[to_additive (attr := simp)]\nlemma map_mk (f : M →* N) (val inv : M) (val_inv inv_val) :\n    map f (mk val inv val_inv inv_val) = mk (f val) (f inv)\n      (by rw [← f.map_mul, val_inv, f.map_one]) (by rw [← f.map_mul, inv_val, f.map_one]) := rfl\n\n"}
{"name":"AddUnits.map_comp","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\nP : Type w\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoid P\nf : AddMonoidHom M N\ng : AddMonoidHom N P\n⊢ Eq (AddUnits.map (g.comp f)) ((AddUnits.map g).comp (AddUnits.map f))","decl":"@[to_additive (attr := simp)]\ntheorem map_comp (f : M →* N) (g : N →* P) : map (g.comp f) = (map g).comp (map f) := rfl\n\n"}
{"name":"Units.map_comp","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\nP : Type w\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : Monoid P\nf : MonoidHom M N\ng : MonoidHom N P\n⊢ Eq (Units.map (g.comp f)) ((Units.map g).comp (Units.map f))","decl":"@[to_additive (attr := simp)]\ntheorem map_comp (f : M →* N) (g : N →* P) : map (g.comp f) = (map g).comp (map f) := rfl\n\n"}
{"name":"AddUnits.map_injective","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(AddUnits.map f)","decl":"@[to_additive]\nlemma map_injective {f : M →* N} (hf : Function.Injective f) :\n    Function.Injective (map f) := fun _ _ e => ext (hf (congr_arg val e))\n\n"}
{"name":"Units.map_injective","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nhf : Function.Injective ⇑f\n⊢ Function.Injective ⇑(Units.map f)","decl":"@[to_additive]\nlemma map_injective {f : M →* N} (hf : Function.Injective f) :\n    Function.Injective (map f) := fun _ _ e => ext (hf (congr_arg val e))\n\n"}
{"name":"Units.map_id","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\ninst✝ : Monoid M\n⊢ Eq (Units.map (MonoidHom.id M)) (MonoidHom.id (Units M))","decl":"@[to_additive (attr := simp)]\ntheorem map_id : map (MonoidHom.id M) = MonoidHom.id Mˣ := by ext; rfl\n\n"}
{"name":"AddUnits.map_id","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\ninst✝ : AddMonoid M\n⊢ Eq (AddUnits.map (AddMonoidHom.id M)) (AddMonoidHom.id (AddUnits M))","decl":"@[to_additive (attr := simp)]\ntheorem map_id : map (MonoidHom.id M) = MonoidHom.id Mˣ := by ext; rfl\n\n"}
{"name":"AddUnits.coeHom_apply","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\ninst✝ : AddMonoid M\nx : AddUnits M\n⊢ Eq ((AddUnits.coeHom M) x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem coeHom_apply (x : Mˣ) : coeHom M x = ↑x := rfl\n\n"}
{"name":"Units.coeHom_apply","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\ninst✝ : Monoid M\nx : Units M\n⊢ Eq ((Units.coeHom M) x) ↑x","decl":"@[to_additive (attr := simp)]\ntheorem coeHom_apply (x : Mˣ) : coeHom M x = ↑x := rfl\n\n"}
{"name":"Units.val_zpow_eq_zpow_val","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"α : Type u_1\ninst✝ : DivisionMonoid α\nu : Units α\nn : Int\n⊢ Eq (↑(HPow.hPow u n)) (HPow.hPow (↑u) n)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_zpow_eq_zpow_val : ∀ (u : αˣ) (n : ℤ), ((u ^ n : αˣ) : α) = (u : α) ^ n :=\n  (Units.coeHom α).map_zpow\n\n"}
{"name":"AddUnits.val_zsmul_eq_zsmul_val","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"α : Type u_1\ninst✝ : SubtractionMonoid α\nu : AddUnits α\nn : Int\n⊢ Eq (↑(HSMul.hSMul n u)) (HSMul.hSMul n ↑u)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_zpow_eq_zpow_val : ∀ (u : αˣ) (n : ℤ), ((u ^ n : αˣ) : α) = (u : α) ^ n :=\n  (Units.coeHom α).map_zpow\n\n"}
{"name":"map_units_inv","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"α : Type u_1\nM : Type u\ninst✝³ : Monoid M\ninst✝² : DivisionMonoid α\nF : Type u_2\ninst✝¹ : FunLike F M α\ninst✝ : MonoidHomClass F M α\nf : F\nu : Units M\n⊢ Eq (f ↑(Inv.inv u)) (Inv.inv (f ↑u))","decl":"@[to_additive (attr := simp)]\ntheorem _root_.map_units_inv {F : Type*} [FunLike F M α] [MonoidHomClass F M α]\n    (f : F) (u : Units M) :\n    f ↑u⁻¹ = (f u)⁻¹ := ((f : M →* α).comp (Units.coeHom M)).map_inv u\n\n"}
{"name":"map_addUnits_neg","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"α : Type u_1\nM : Type u\ninst✝³ : AddMonoid M\ninst✝² : SubtractionMonoid α\nF : Type u_2\ninst✝¹ : FunLike F M α\ninst✝ : AddMonoidHomClass F M α\nf : F\nu : AddUnits M\n⊢ Eq (f ↑(Neg.neg u)) (Neg.neg (f ↑u))","decl":"@[to_additive (attr := simp)]\ntheorem _root_.map_units_inv {F : Type*} [FunLike F M α] [MonoidHomClass F M α]\n    (f : F) (u : Units M) :\n    f ↑u⁻¹ = (f u)⁻¹ := ((f : M →* α).comp (Units.coeHom M)).map_inv u\n\n"}
{"name":"Units.coe_liftRight","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\ng : M → Units N\nh : ∀ (x : M), Eq (↑(g x)) (f x)\nx : M\n⊢ Eq (↑((Units.liftRight f g h) x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_liftRight {f : M →* N} {g : M → Nˣ} (h : ∀ x, ↑(g x) = f x) (x) :\n    (liftRight f g h x : N) = f x := h x\n\n"}
{"name":"AddUnits.coe_liftRight","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\ng : M → AddUnits N\nh : ∀ (x : M), Eq (↑(g x)) (f x)\nx : M\n⊢ Eq (↑((AddUnits.liftRight f g h) x)) (f x)","decl":"@[to_additive (attr := simp)]\ntheorem coe_liftRight {f : M →* N} {g : M → Nˣ} (h : ∀ x, ↑(g x) = f x) (x) :\n    (liftRight f g h x : N) = f x := h x\n\n"}
{"name":"Units.mul_liftRight_inv","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\ng : M → Units N\nh : ∀ (x : M), Eq (↑(g x)) (f x)\nx : M\n⊢ Eq (HMul.hMul (f x) ↑(Inv.inv ((Units.liftRight f g h) x))) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_liftRight_inv {f : M →* N} {g : M → Nˣ} (h : ∀ x, ↑(g x) = f x) (x) :\n    f x * ↑(liftRight f g h x)⁻¹ = 1 := by\n  rw [Units.mul_inv_eq_iff_eq_mul, one_mul, coe_liftRight]\n\n"}
{"name":"AddUnits.add_liftRight_neg","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\ng : M → AddUnits N\nh : ∀ (x : M), Eq (↑(g x)) (f x)\nx : M\n⊢ Eq (HAdd.hAdd (f x) ↑(Neg.neg ((AddUnits.liftRight f g h) x))) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_liftRight_inv {f : M →* N} {g : M → Nˣ} (h : ∀ x, ↑(g x) = f x) (x) :\n    f x * ↑(liftRight f g h x)⁻¹ = 1 := by\n  rw [Units.mul_inv_eq_iff_eq_mul, one_mul, coe_liftRight]\n\n"}
{"name":"Units.liftRight_inv_mul","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\ng : M → Units N\nh : ∀ (x : M), Eq (↑(g x)) (f x)\nx : M\n⊢ Eq (HMul.hMul (↑(Inv.inv ((Units.liftRight f g h) x))) (f x)) 1","decl":"@[to_additive (attr := simp)]\ntheorem liftRight_inv_mul {f : M →* N} {g : M → Nˣ} (h : ∀ x, ↑(g x) = f x) (x) :\n    ↑(liftRight f g h x)⁻¹ * f x = 1 := by\n  rw [Units.inv_mul_eq_iff_eq_mul, mul_one, coe_liftRight]\n\n"}
{"name":"AddUnits.liftRight_neg_add","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u\nN : Type v\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\ng : M → AddUnits N\nh : ∀ (x : M), Eq (↑(g x)) (f x)\nx : M\n⊢ Eq (HAdd.hAdd (↑(Neg.neg ((AddUnits.liftRight f g h) x))) (f x)) 0","decl":"@[to_additive (attr := simp)]\ntheorem liftRight_inv_mul {f : M →* N} {g : M → Nˣ} (h : ∀ x, ↑(g x) = f x) (x) :\n    ↑(liftRight f g h x)⁻¹ * f x = 1 := by\n  rw [Units.inv_mul_eq_iff_eq_mul, mul_one, coe_liftRight]\n\n"}
{"name":"AddMonoidHom.coe_toHomAddUnits","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝¹ : AddGroup G\ninst✝ : AddMonoid M\nf : AddMonoidHom G M\ng : G\n⊢ Eq (↑(f.toHomAddUnits g)) (f g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_toHomUnits {G M : Type*} [Group G] [Monoid M] (f : G →* M) (g : G) :\n    (f.toHomUnits g : M) = f g := rfl\n\n"}
{"name":"MonoidHom.coe_toHomUnits","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"G : Type u_1\nM : Type u_2\ninst✝¹ : Group G\ninst✝ : Monoid M\nf : MonoidHom G M\ng : G\n⊢ Eq (↑(f.toHomUnits g)) (f g)","decl":"@[to_additive (attr := simp)]\ntheorem coe_toHomUnits {G M : Type*} [Group G] [Monoid M] (f : G →* M) (g : G) :\n    (f.toHomUnits g : M) = f g := rfl\n\n"}
{"name":"IsAddUnit.map","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝³ : FunLike F M N\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoidHomClass F M N\nf : F\nx : M\nh : IsAddUnit x\n⊢ IsAddUnit (f x)","decl":"@[to_additive]\ntheorem map [MonoidHomClass F M N] (f : F) {x : M} (h : IsUnit x) : IsUnit (f x) := by\n  rcases h with ⟨y, rfl⟩; exact (Units.map (f : M →* N) y).isUnit\n\n"}
{"name":"IsUnit.map","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nM : Type u_3\nN : Type u_4\ninst✝³ : FunLike F M N\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : MonoidHomClass F M N\nf : F\nx : M\nh : IsUnit x\n⊢ IsUnit (f x)","decl":"@[to_additive]\ntheorem map [MonoidHomClass F M N] (f : F) {x : M} (h : IsUnit x) : IsUnit (f x) := by\n  rcases h with ⟨y, rfl⟩; exact (Units.map (f : M →* N) y).isUnit\n\n"}
{"name":"IsUnit.of_leftInverse","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : FunLike F M N\ninst✝³ : FunLike G N M\ninst✝² : Monoid M\ninst✝¹ : Monoid N\ninst✝ : MonoidHomClass G N M\nf : F\nx : M\ng : G\nhfg : Function.LeftInverse ⇑g ⇑f\nh : IsUnit (f x)\n⊢ IsUnit x","decl":"@[to_additive]\ntheorem of_leftInverse [MonoidHomClass G N M] {f : F} {x : M} (g : G)\n    (hfg : Function.LeftInverse g f) (h : IsUnit (f x)) : IsUnit x := by\n  simpa only [hfg x] using h.map g\n\n"}
{"name":"IsAddUnit.of_leftInverse","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁴ : FunLike F M N\ninst✝³ : FunLike G N M\ninst✝² : AddMonoid M\ninst✝¹ : AddMonoid N\ninst✝ : AddMonoidHomClass G N M\nf : F\nx : M\ng : G\nhfg : Function.LeftInverse ⇑g ⇑f\nh : IsAddUnit (f x)\n⊢ IsAddUnit x","decl":"@[to_additive]\ntheorem of_leftInverse [MonoidHomClass G N M] {f : F} {x : M} (g : G)\n    (hfg : Function.LeftInverse g f) (h : IsUnit (f x)) : IsUnit x := by\n  simpa only [hfg x] using h.map g\n\n"}
{"name":"isAddUnit_map_of_leftInverse","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : FunLike F M N\ninst✝⁴ : FunLike G N M\ninst✝³ : AddMonoid M\ninst✝² : AddMonoid N\ninst✝¹ : AddMonoidHomClass F M N\ninst✝ : AddMonoidHomClass G N M\nf : F\nx : M\ng : G\nhfg : Function.LeftInverse ⇑g ⇑f\n⊢ Iff (IsAddUnit (f x)) (IsAddUnit x)","decl":"/-- Prefer `IsLocalHom.of_leftInverse`, but we can't get rid of this because of `ToAdditive`. -/\n@[to_additive]\ntheorem _root_.isUnit_map_of_leftInverse [MonoidHomClass F M N] [MonoidHomClass G N M]\n    {f : F} {x : M} (g : G) (hfg : Function.LeftInverse g f) :\n    IsUnit (f x) ↔ IsUnit x := ⟨of_leftInverse g hfg, map _⟩\n\n"}
{"name":"isUnit_map_of_leftInverse","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"F : Type u_1\nG : Type u_2\nM : Type u_3\nN : Type u_4\ninst✝⁵ : FunLike F M N\ninst✝⁴ : FunLike G N M\ninst✝³ : Monoid M\ninst✝² : Monoid N\ninst✝¹ : MonoidHomClass F M N\ninst✝ : MonoidHomClass G N M\nf : F\nx : M\ng : G\nhfg : Function.LeftInverse ⇑g ⇑f\n⊢ Iff (IsUnit (f x)) (IsUnit x)","decl":"/-- Prefer `IsLocalHom.of_leftInverse`, but we can't get rid of this because of `ToAdditive`. -/\n@[to_additive]\ntheorem _root_.isUnit_map_of_leftInverse [MonoidHomClass F M N] [MonoidHomClass G N M]\n    {f : F} {x : M} (g : G) (hfg : Function.LeftInverse g f) :\n    IsUnit (f x) ↔ IsUnit x := ⟨of_leftInverse g hfg, map _⟩\n\n"}
{"name":"IsAddUnit.coe_liftRight","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nhf : ∀ (x : M), IsAddUnit (f x)\nx : M\n⊢ Eq (↑((IsAddUnit.liftRight f hf) x)) (f x)","decl":"@[to_additive]\ntheorem coe_liftRight (f : M →* N) (hf : ∀ x, IsUnit (f x)) (x) :\n    (IsUnit.liftRight f hf x : N) = f x := rfl\n\n"}
{"name":"IsUnit.coe_liftRight","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nhf : ∀ (x : M), IsUnit (f x)\nx : M\n⊢ Eq (↑((IsUnit.liftRight f hf) x)) (f x)","decl":"@[to_additive]\ntheorem coe_liftRight (f : M →* N) (hf : ∀ x, IsUnit (f x)) (x) :\n    (IsUnit.liftRight f hf x : N) = f x := rfl\n\n"}
{"name":"IsAddUnit.add_liftRight_neg","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nh : ∀ (x : M), IsAddUnit (f x)\nx : M\n⊢ Eq (HAdd.hAdd (f x) ↑(Neg.neg ((IsAddUnit.liftRight f h) x))) 0","decl":"@[to_additive (attr := simp)]\ntheorem mul_liftRight_inv (f : M →* N) (h : ∀ x, IsUnit (f x)) (x) :\n    f x * ↑(IsUnit.liftRight f h x)⁻¹ = 1 := Units.mul_liftRight_inv (by intro; rfl) x\n\n"}
{"name":"IsUnit.mul_liftRight_inv","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nh : ∀ (x : M), IsUnit (f x)\nx : M\n⊢ Eq (HMul.hMul (f x) ↑(Inv.inv ((IsUnit.liftRight f h) x))) 1","decl":"@[to_additive (attr := simp)]\ntheorem mul_liftRight_inv (f : M →* N) (h : ∀ x, IsUnit (f x)) (x) :\n    f x * ↑(IsUnit.liftRight f h x)⁻¹ = 1 := Units.mul_liftRight_inv (by intro; rfl) x\n\n"}
{"name":"IsAddUnit.liftRight_neg_add","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : AddMonoid M\ninst✝ : AddMonoid N\nf : AddMonoidHom M N\nh : ∀ (x : M), IsAddUnit (f x)\nx : M\n⊢ Eq (HAdd.hAdd (↑(Neg.neg ((IsAddUnit.liftRight f h) x))) (f x)) 0","decl":"@[to_additive (attr := simp)]\ntheorem liftRight_inv_mul (f : M →* N) (h : ∀ x, IsUnit (f x)) (x) :\n    ↑(IsUnit.liftRight f h x)⁻¹ * f x = 1 := Units.liftRight_inv_mul (by intro; rfl) x\n\n"}
{"name":"IsUnit.liftRight_inv_mul","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"M : Type u_3\nN : Type u_4\ninst✝¹ : Monoid M\ninst✝ : Monoid N\nf : MonoidHom M N\nh : ∀ (x : M), IsUnit (f x)\nx : M\n⊢ Eq (HMul.hMul (↑(Inv.inv ((IsUnit.liftRight f h) x))) (f x)) 1","decl":"@[to_additive (attr := simp)]\ntheorem liftRight_inv_mul (f : M →* N) (h : ∀ x, IsUnit (f x)) (x) :\n    ↑(IsUnit.liftRight f h x)⁻¹ * f x = 1 := Units.liftRight_inv_mul (by intro; rfl) x\n\n"}
{"name":"IsLocalHom.map_nonunit","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝² : Monoid R\ninst✝¹ : Monoid S\ninst✝ : FunLike F R S\nf : F\nself : IsLocalHom f\na : R\na✝ : IsUnit (f a)\n⊢ IsUnit a","decl":"/-- A local ring homomorphism is a map `f` between monoids such that `a` in the domain\n  is a unit if `f a` is a unit for any `a`. See `IsLocalRing.local_hom_TFAE` for other equivalent\n  definitions in the local ring case - from where this concept originates, but it is useful in\n  other contexts, so we allow this generalisation in mathlib. -/\nclass IsLocalHom (f : F) : Prop where\n  /-- A local homomorphism `f : R ⟶ S` will send nonunits of `R` to nonunits of `S`. -/\n  map_nonunit : ∀ a, IsUnit (f a) → IsUnit a\n\n"}
{"name":"IsUnit.of_map","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝³ : Monoid R\ninst✝² : Monoid S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : IsLocalHom f\na : R\nh : IsUnit (f a)\n⊢ IsUnit a","decl":"@[simp]\ntheorem IsUnit.of_map (f : F) [IsLocalHom f] (a : R) (h : IsUnit (f a)) : IsUnit a :=\n  IsLocalHom.map_nonunit a h\n\n-- TODO : remove alias, change the parenthesis of `f` and `a`\n"}
{"name":"isUnit_of_map_unit","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝³ : Monoid R\ninst✝² : Monoid S\ninst✝¹ : FunLike F R S\nf : F\ninst✝ : IsLocalHom f\na : R\nh : IsUnit (f a)\n⊢ IsUnit a","decl":"alias isUnit_of_map_unit := IsUnit.of_map\n\n"}
{"name":"isUnit_map_iff","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝⁴ : Monoid R\ninst✝³ : Monoid S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nf : F\ninst✝ : IsLocalHom f\na : R\n⊢ Iff (IsUnit (f a)) (IsUnit a)","decl":"@[simp]\ntheorem isUnit_map_iff (f : F) [IsLocalHom f] (a : R) : IsUnit (f a) ↔ IsUnit a :=\n  ⟨IsLocalHom.map_nonunit a, IsUnit.map f⟩\n\n"}
{"name":"isLocalHom_of_leftInverse","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"G : Type u_1\nR : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\ninst✝³ : FunLike F R S\ninst✝² : MonoidHomClass F R S\ninst✝¹ : FunLike G S R\ninst✝ : MonoidHomClass G S R\nf : F\ng : G\nhfg : Function.LeftInverse ⇑g ⇑f\n⊢ IsLocalHom f","decl":"theorem isLocalHom_of_leftInverse [FunLike G S R] [MonoidHomClass G S R]\n    {f : F} (g : G) (hfg : Function.LeftInverse g f) : IsLocalHom f where\n  map_nonunit a ha := by rwa [isUnit_map_of_leftInverse g hfg] at ha\n\n"}
{"name":"isLocalRingHom_of_leftInverse","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"G : Type u_1\nR : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝⁵ : Monoid R\ninst✝⁴ : Monoid S\ninst✝³ : FunLike F R S\ninst✝² : MonoidHomClass F R S\ninst✝¹ : FunLike G S R\ninst✝ : MonoidHomClass G S R\nf : F\ng : G\nhfg : Function.LeftInverse ⇑g ⇑f\n⊢ IsLocalHom f","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_of_leftInverse := isLocalHom_of_leftInverse\n\n"}
{"name":"MonoidHom.isLocalHom_comp","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nT : Type u_4\ninst✝⁴ : Monoid R\ninst✝³ : Monoid S\ninst✝² : Monoid T\ng : MonoidHom S T\nf : MonoidHom R S\ninst✝¹ : IsLocalHom g\ninst✝ : IsLocalHom f\n⊢ IsLocalHom (g.comp f)","decl":"@[instance]\ntheorem MonoidHom.isLocalHom_comp (g : S →* T) (f : R →* S) [IsLocalHom g]\n    [IsLocalHom f] : IsLocalHom (g.comp f) where\n  map_nonunit a := IsLocalHom.map_nonunit a ∘ IsLocalHom.map_nonunit (f := g) (f a)\n\n"}
{"name":"MonoidHom.isLocalRingHom_comp","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nT : Type u_4\ninst✝⁴ : Monoid R\ninst✝³ : Monoid S\ninst✝² : Monoid T\ng : MonoidHom S T\nf : MonoidHom R S\ninst✝¹ : IsLocalHom g\ninst✝ : IsLocalHom f\n⊢ IsLocalHom (g.comp f)","decl":"@[deprecated (since := \"2024-10-10\")]\nalias MonoidHom.isLocalRingHom_comp := MonoidHom.isLocalHom_comp\n\n-- see note [lower instance priority]\n"}
{"name":"isLocalHom_toMonoidHom","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝⁴ : Monoid R\ninst✝³ : Monoid S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nf : F\ninst✝ : IsLocalHom f\n⊢ IsLocalHom ↑f","decl":"@[instance 100]\ntheorem isLocalHom_toMonoidHom (f : F) [IsLocalHom f] :\n    IsLocalHom (f : R →* S) :=\n  ⟨IsLocalHom.map_nonunit (f := f)⟩\n\n"}
{"name":"isLocalRingHom_toMonoidHom","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nF : Type u_5\ninst✝⁴ : Monoid R\ninst✝³ : Monoid S\ninst✝² : FunLike F R S\ninst✝¹ : MonoidHomClass F R S\nf : F\ninst✝ : IsLocalHom f\n⊢ IsLocalHom ↑f","decl":"@[deprecated (since := \"2024-10-10\")]\nalias isLocalRingHom_toMonoidHom := isLocalHom_toMonoidHom\n\n"}
{"name":"MonoidHom.isLocalHom_of_comp","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nT : Type u_4\ninst✝³ : Monoid R\ninst✝² : Monoid S\ninst✝¹ : Monoid T\nf : MonoidHom R S\ng : MonoidHom S T\ninst✝ : IsLocalHom (g.comp f)\n⊢ IsLocalHom f","decl":"theorem MonoidHom.isLocalHom_of_comp (f : R →* S) (g : S →* T) [IsLocalHom (g.comp f)] :\n    IsLocalHom f :=\n  ⟨fun _ ha => (isUnit_map_iff (g.comp f) _).mp (ha.map g)⟩\n\n"}
{"name":"MonoidHom.isLocalRingHom_of_comp","module":"Mathlib.Algebra.Group.Units.Hom","initialProofState":"R : Type u_2\nS : Type u_3\nT : Type u_4\ninst✝³ : Monoid R\ninst✝² : Monoid S\ninst✝¹ : Monoid T\nf : MonoidHom R S\ng : MonoidHom S T\ninst✝ : IsLocalHom (g.comp f)\n⊢ IsLocalHom f","decl":"@[deprecated (since := \"2024-10-10\")]\nalias MonoidHom.isLocalRingHom_of_comp := MonoidHom.isLocalHom_of_comp\n\n"}
