{"name":"MeasureTheory.UniformIntegrable.aeStronglyMeasurable","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UniformIntegrable f p Œº\ni : Œπ\n‚ä¢ MeasureTheory.AEStronglyMeasurable (f i) Œº","decl":"protected theorem aeStronglyMeasurable {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : ‚Ñù‚â•0‚àû} (hf : UniformIntegrable f p Œº)\n    (i : Œπ) : AEStronglyMeasurable (f i) Œº :=\n  hf.1 i\n\n"}
{"name":"MeasureTheory.UniformIntegrable.unifIntegrable","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UniformIntegrable f p Œº\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"protected theorem unifIntegrable {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : ‚Ñù‚â•0‚àû} (hf : UniformIntegrable f p Œº) :\n    UnifIntegrable f p Œº :=\n  hf.2.1\n\n"}
{"name":"MeasureTheory.UniformIntegrable.mem‚Ñíp","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UniformIntegrable f p Œº\ni : Œπ\n‚ä¢ MeasureTheory.Mem‚Ñíp (f i) p Œº","decl":"protected theorem mem‚Ñíp {f : Œπ ‚Üí Œ± ‚Üí Œ≤} {p : ‚Ñù‚â•0‚àû} (hf : UniformIntegrable f p Œº) (i : Œπ) :\n    Mem‚Ñíp (f i) p Œº :=\n  ‚ü®hf.1 i,\n    let ‚ü®_, _, hC‚ü© := hf.2\n    lt_of_le_of_lt (hC i) ENNReal.coe_lt_top‚ü©\n\n"}
{"name":"MeasureTheory.UnifIntegrable.add","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf g : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UnifIntegrable f p Œº\nhg : MeasureTheory.UnifIntegrable g p Œº\nhp : LE.le 1 p\nhf_meas : ‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (f i) Œº\nhg_meas : ‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (g i) Œº\n‚ä¢ MeasureTheory.UnifIntegrable (HAdd.hAdd f g) p Œº","decl":"protected theorem add (hf : UnifIntegrable f p Œº) (hg : UnifIntegrable g p Œº) (hp : 1 ‚â§ p)\n    (hf_meas : ‚àÄ i, AEStronglyMeasurable (f i) Œº) (hg_meas : ‚àÄ i, AEStronglyMeasurable (g i) Œº) :\n    UnifIntegrable (f + g) p Œº := by\n  intro Œµ hŒµ\n  have hŒµ2 : 0 < Œµ / 2 := half_pos hŒµ\n  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ_pos, hfŒ¥‚ÇÅ‚ü© := hf hŒµ2\n  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ_pos, hgŒ¥‚ÇÇ‚ü© := hg hŒµ2\n  refine ‚ü®min Œ¥‚ÇÅ Œ¥‚ÇÇ, lt_min hŒ¥‚ÇÅ_pos hŒ¥‚ÇÇ_pos, fun i s hs hŒºs => ?_‚ü©\n  simp_rw [Pi.add_apply, Set.indicator_add']\n  refine (eLpNorm_add_le ((hf_meas i).indicator hs) ((hg_meas i).indicator hs) hp).trans ?_\n  have hŒµ_halves : ENNReal.ofReal Œµ = ENNReal.ofReal (Œµ / 2) + ENNReal.ofReal (Œµ / 2) := by\n    rw [‚Üê ENNReal.ofReal_add hŒµ2.le hŒµ2.le, add_halves]\n  rw [hŒµ_halves]\n  exact add_le_add (hfŒ¥‚ÇÅ i s hs (hŒºs.trans (ENNReal.ofReal_le_ofReal (min_le_left _ _))))\n    (hgŒ¥‚ÇÇ i s hs (hŒºs.trans (ENNReal.ofReal_le_ofReal (min_le_right _ _))))\n\n"}
{"name":"MeasureTheory.UnifIntegrable.neg","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UnifIntegrable f p Œº\n‚ä¢ MeasureTheory.UnifIntegrable (Neg.neg f) p Œº","decl":"protected theorem neg (hf : UnifIntegrable f p Œº) : UnifIntegrable (-f) p Œº := by\n  simp_rw [UnifIntegrable, Pi.neg_apply, Set.indicator_neg', eLpNorm_neg]\n  exact hf\n\n"}
{"name":"MeasureTheory.UnifIntegrable.sub","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf g : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UnifIntegrable f p Œº\nhg : MeasureTheory.UnifIntegrable g p Œº\nhp : LE.le 1 p\nhf_meas : ‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (f i) Œº\nhg_meas : ‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (g i) Œº\n‚ä¢ MeasureTheory.UnifIntegrable (HSub.hSub f g) p Œº","decl":"protected theorem sub (hf : UnifIntegrable f p Œº) (hg : UnifIntegrable g p Œº) (hp : 1 ‚â§ p)\n    (hf_meas : ‚àÄ i, AEStronglyMeasurable (f i) Œº) (hg_meas : ‚àÄ i, AEStronglyMeasurable (g i) Œº) :\n    UnifIntegrable (f - g) p Œº := by\n  rw [sub_eq_add_neg]\n  exact hf.add hg.neg hp hf_meas fun i => (hg_meas i).neg\n\n"}
{"name":"MeasureTheory.UnifIntegrable.ae_eq","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf g : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UnifIntegrable f p Œº\nhfg : ‚àÄ (n : Œπ), (MeasureTheory.ae Œº).EventuallyEq (f n) (g n)\n‚ä¢ MeasureTheory.UnifIntegrable g p Œº","decl":"protected theorem ae_eq (hf : UnifIntegrable f p Œº) (hfg : ‚àÄ n, f n =·µê[Œº] g n) :\n    UnifIntegrable g p Œº := by\n  classical\n  intro Œµ hŒµ\n  obtain ‚ü®Œ¥, hŒ¥_pos, hfŒ¥‚ü© := hf hŒµ\n  refine ‚ü®Œ¥, hŒ¥_pos, fun n s hs hŒºs => (le_of_eq <| eLpNorm_congr_ae ?_).trans (hfŒ¥ n s hs hŒºs)‚ü©\n  filter_upwards [hfg n] with x hx\n  simp_rw [Set.indicator_apply, hx]\n\n"}
{"name":"MeasureTheory.UnifIntegrable.indicator","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UnifIntegrable f p Œº\nE : Set Œ±\n‚ä¢ MeasureTheory.UnifIntegrable (fun i => E.indicator (f i)) p Œº","decl":"/-- Uniform integrability is preserved by restriction of the functions to a set. -/\nprotected theorem indicator (hf : UnifIntegrable f p Œº) (E : Set Œ±) :\n    UnifIntegrable (fun i => E.indicator (f i)) p Œº := fun Œµ hŒµ ‚Ü¶ by\n  obtain ‚ü®Œ¥, hŒ¥_pos, hŒµ‚ü© := hf hŒµ\n  refine ‚ü®Œ¥, hŒ¥_pos, fun i s hs hŒºs ‚Ü¶ ?_‚ü©\n  calc\n    eLpNorm (s.indicator (E.indicator (f i))) p Œº\n      = eLpNorm (E.indicator (s.indicator (f i))) p Œº := by\n      simp only [indicator_indicator, inter_comm]\n    _ ‚â§ eLpNorm (s.indicator (f i)) p Œº := eLpNorm_indicator_le _\n    _ ‚â§ ENNReal.ofReal Œµ := hŒµ _ _ hs hŒºs\n\n"}
{"name":"MeasureTheory.UnifIntegrable.restrict","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\np : ENNReal\nhf : MeasureTheory.UnifIntegrable f p Œº\nE : Set Œ±\n‚ä¢ MeasureTheory.UnifIntegrable f p (Œº.restrict E)","decl":"/-- Uniform integrability is preserved by restriction of the measure to a set. -/\nprotected theorem restrict (hf : UnifIntegrable f p Œº) (E : Set Œ±) :\n    UnifIntegrable f p (Œº.restrict E) := fun Œµ hŒµ ‚Ü¶ by\n  obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥Œµ‚ü© := hf hŒµ\n  refine ‚ü®Œ¥, hŒ¥_pos, fun i s hs hŒºs ‚Ü¶ ?_‚ü©\n  rw [Œº.restrict_apply hs, ‚Üê measure_toMeasurable] at hŒºs\n  calc\n    eLpNorm (indicator s (f i)) p (Œº.restrict E) = eLpNorm (f i) p (Œº.restrict (s ‚à© E)) := by\n      rw [eLpNorm_indicator_eq_eLpNorm_restrict hs, Œº.restrict_restrict hs]\n    _ ‚â§ eLpNorm (f i) p (Œº.restrict (toMeasurable Œº (s ‚à© E))) :=\n      eLpNorm_mono_measure _ <| Measure.restrict_mono (subset_toMeasurable _ _) le_rfl\n    _ = eLpNorm (indicator (toMeasurable Œº (s ‚à© E)) (f i)) p Œº :=\n      (eLpNorm_indicator_eq_eLpNorm_restrict (measurableSet_toMeasurable _ _)).symm\n    _ ‚â§ ENNReal.ofReal Œµ := hŒ¥Œµ i _ (measurableSet_toMeasurable _ _) hŒºs\n\n"}
{"name":"MeasureTheory.unifIntegrable_zero_meas","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\ninst‚úù¬π : NormedAddCommGroup Œ≤\ninst‚úù : MeasurableSpace Œ±\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\n‚ä¢ MeasureTheory.UnifIntegrable f p 0","decl":"theorem unifIntegrable_zero_meas [MeasurableSpace Œ±] {p : ‚Ñù‚â•0‚àû} {f : Œπ ‚Üí Œ± ‚Üí Œ≤} :\n    UnifIntegrable f p (0 : Measure Œ±) :=\n  fun Œµ _ => ‚ü®1, one_pos, fun i s _ _ => by simp‚ü©\n\n"}
{"name":"MeasureTheory.unifIntegrable_congr_ae","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf g : Œπ ‚Üí Œ± ‚Üí Œ≤\nhfg : ‚àÄ (n : Œπ), (MeasureTheory.ae Œº).EventuallyEq (f n) (g n)\n‚ä¢ Iff (MeasureTheory.UnifIntegrable f p Œº) (MeasureTheory.UnifIntegrable g p Œº)","decl":"theorem unifIntegrable_congr_ae {p : ‚Ñù‚â•0‚àû} {f g : Œπ ‚Üí Œ± ‚Üí Œ≤} (hfg : ‚àÄ n, f n =·µê[Œº] g n) :\n    UnifIntegrable f p Œº ‚Üî UnifIntegrable g p Œº :=\n  ‚ü®fun hf => hf.ae_eq hfg, fun hg => hg.ae_eq fun n => (hfg n).symm‚ü©\n\n"}
{"name":"MeasureTheory.tendsto_indicator_ge","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nx : Œ±\n‚ä¢ Filter.Tendsto (fun M => (setOf fun x => LE.le ‚ÜëM ‚Üë(NNNorm.nnnorm (f x))).indicator f x) Filter.atTop (nhds 0)","decl":"theorem tendsto_indicator_ge (f : Œ± ‚Üí Œ≤) (x : Œ±) :\n    Tendsto (fun M : ‚Ñï => { x | (M : ‚Ñù) ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f x) atTop (ùìù 0) := by\n  refine tendsto_atTop_of_eventually_const (i‚ÇÄ := Nat.ceil (‚Äñf x‚Äñ‚Çä : ‚Ñù) + 1) fun n hn => ?_\n  rw [Set.indicator_of_not_mem]\n  simp only [not_le, Set.mem_setOf_eq]\n  refine lt_of_le_of_lt (Nat.le_ceil _) ?_\n  refine lt_of_lt_of_le (lt_add_one _) ?_\n  norm_cast\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.integral_indicator_norm_ge_le","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.Mem‚Ñíp f 1 Œº\nhmeas : MeasureTheory.StronglyMeasurable f\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun M => LE.le (MeasureTheory.lintegral Œº fun x => ‚Üë(NNNorm.nnnorm ((setOf fun x => LE.le M ‚Üë(NNNorm.nnnorm (f x))).indicator f x))) (ENNReal.ofReal Œµ)","decl":"/-- This lemma is weaker than `MeasureTheory.Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le`\nas the latter provides `0 ‚â§ M` and does not require the measurability of `f`. -/\ntheorem Mem‚Ñíp.integral_indicator_norm_ge_le (hf : Mem‚Ñíp f 1 Œº) (hmeas : StronglyMeasurable f)\n    {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ M : ‚Ñù, (‚à´‚Åª x, ‚Äñ{ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f x‚Äñ‚Çä ‚àÇŒº) ‚â§ ENNReal.ofReal Œµ := by\n  have htendsto :\n      ‚àÄ·µê x ‚àÇŒº, Tendsto (fun M : ‚Ñï => { x | (M : ‚Ñù) ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f x) atTop (ùìù 0) :=\n    univ_mem' (id fun x => tendsto_indicator_ge f x)\n  have hmeas : ‚àÄ M : ‚Ñï, AEStronglyMeasurable ({ x | (M : ‚Ñù) ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f) Œº := by\n    intro M\n    apply hf.1.indicator\n    apply StronglyMeasurable.measurableSet_le stronglyMeasurable_const\n      hmeas.nnnorm.measurable.coe_nnreal_real.stronglyMeasurable\n  have hbound : HasFiniteIntegral (fun x => ‚Äñf x‚Äñ) Œº := by\n    rw [mem‚Ñíp_one_iff_integrable] at hf\n    exact hf.norm.2\n  have : Tendsto (fun n : ‚Ñï ‚Ü¶ ‚à´‚Åª a, ENNReal.ofReal ‚Äñ{ x | n ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f a - 0‚Äñ ‚àÇŒº)\n      atTop (ùìù 0) := by\n    refine tendsto_lintegral_norm_of_dominated_convergence hmeas hbound ?_ htendsto\n    refine fun n => univ_mem' (id fun x => ?_)\n    by_cases hx : (n : ‚Ñù) ‚â§ ‚Äñf x‚Äñ\n    ¬∑ dsimp\n      rwa [Set.indicator_of_mem]\n    ¬∑ dsimp\n      rw [Set.indicator_of_not_mem, norm_zero]\n      ¬∑ exact norm_nonneg _\n      ¬∑ assumption\n  rw [ENNReal.tendsto_atTop_zero] at this\n  obtain ‚ü®M, hM‚ü© := this (ENNReal.ofReal Œµ) (ENNReal.ofReal_pos.2 hŒµ)\n  simp only [zero_tsub, zero_le, sub_zero, zero_add, coe_nnnorm,\n    Set.mem_Icc] at hM\n  refine ‚ü®M, ?_‚ü©\n  convert hM M le_rfl\n  simp only [coe_nnnorm, ENNReal.ofReal_eq_coe_nnreal (norm_nonneg _)]\n  rfl\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le_of_meas","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.Mem‚Ñíp f 1 Œº\nhmeas : MeasureTheory.StronglyMeasurable f\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun M => And (LE.le 0 M) (LE.le (MeasureTheory.lintegral Œº fun x => ENorm.enorm ((setOf fun x => LE.le M ‚Üë(NNNorm.nnnorm (f x))).indicator f x)) (ENNReal.ofReal Œµ))","decl":"/-- This lemma is superseded by `MeasureTheory.Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le`\nwhich does not require measurability. -/\ntheorem Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le_of_meas (hf : Mem‚Ñíp f 1 Œº)\n    (hmeas : StronglyMeasurable f) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ M : ‚Ñù, 0 ‚â§ M ‚àß (‚à´‚Åª x, ‚Äñ{ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f x‚Äñ‚Çë ‚àÇŒº) ‚â§ ENNReal.ofReal Œµ :=\n  let ‚ü®M, hM‚ü© := hf.integral_indicator_norm_ge_le hmeas hŒµ\n  ‚ü®max M 0, le_max_right _ _, by simpa‚ü©\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.Mem‚Ñíp f 1 Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun M => And (LE.le 0 M) (LE.le (MeasureTheory.lintegral Œº fun x => ENorm.enorm ((setOf fun x => LE.le M ‚Üë(NNNorm.nnnorm (f x))).indicator f x)) (ENNReal.ofReal Œµ))","decl":"theorem Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le (hf : Mem‚Ñíp f 1 Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ M : ‚Ñù, 0 ‚â§ M ‚àß (‚à´‚Åª x, ‚Äñ{ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f x‚Äñ‚Çë ‚àÇŒº) ‚â§ ENNReal.ofReal Œµ := by\n  have hf_mk : Mem‚Ñíp (hf.1.mk f) 1 Œº := (mem‚Ñíp_congr_ae hf.1.ae_eq_mk).mp hf\n  obtain ‚ü®M, hM_pos, hfM‚ü© :=\n    hf_mk.integral_indicator_norm_ge_nonneg_le_of_meas hf.1.stronglyMeasurable_mk hŒµ\n  refine ‚ü®M, hM_pos, (le_of_eq ?_).trans hfM‚ü©\n  refine lintegral_congr_ae ?_\n  filter_upwards [hf.1.ae_eq_mk] with x hx\n  simp only [Set.indicator_apply, coe_nnnorm, Set.mem_setOf_eq, ENNReal.coe_inj, hx.symm]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNormEssSup_indicator_norm_ge_eq_zero","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.Mem‚Ñíp f Top.top Œº\nhmeas : MeasureTheory.StronglyMeasurable f\n‚ä¢ Exists fun M => Eq (MeasureTheory.eLpNormEssSup ((setOf fun x => LE.le M ‚Üë(NNNorm.nnnorm (f x))).indicator f) Œº) 0","decl":"theorem Mem‚Ñíp.eLpNormEssSup_indicator_norm_ge_eq_zero (hf : Mem‚Ñíp f ‚àû Œº)\n    (hmeas : StronglyMeasurable f) :\n    ‚àÉ M : ‚Ñù, eLpNormEssSup ({ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f) Œº = 0 := by\n  have hbdd : eLpNormEssSup f Œº < ‚àû := hf.eLpNorm_lt_top\n  refine ‚ü®(eLpNorm f ‚àû Œº + 1).toReal, ?_‚ü©\n  rw [eLpNormEssSup_indicator_eq_eLpNormEssSup_restrict]\n  ¬∑ have : Œº.restrict { x : Œ± | (eLpNorm f ‚ä§ Œº + 1).toReal ‚â§ ‚Äñf x‚Äñ‚Çä } = 0 := by\n      simp only [coe_nnnorm, eLpNorm_exponent_top, Measure.restrict_eq_zero]\n      have : { x : Œ± | (eLpNormEssSup f Œº + 1).toReal ‚â§ ‚Äñf x‚Äñ } ‚äÜ\n          { x : Œ± | eLpNormEssSup f Œº < ‚Äñf x‚Äñ‚Çä } := by\n        intro x hx\n        rw [Set.mem_setOf_eq, ‚Üê ENNReal.toReal_lt_toReal hbdd.ne ENNReal.coe_lt_top.ne,\n          ENNReal.coe_toReal, coe_nnnorm]\n        refine lt_of_lt_of_le ?_ hx\n        rw [ENNReal.toReal_lt_toReal hbdd.ne]\n        ¬∑ exact ENNReal.lt_add_right hbdd.ne one_ne_zero\n        ¬∑ exact (ENNReal.add_lt_top.2 ‚ü®hbdd, ENNReal.one_lt_top‚ü©).ne\n      rw [‚Üê nonpos_iff_eq_zero]\n      refine (measure_mono this).trans ?_\n      have hle := coe_nnnorm_ae_le_eLpNormEssSup f Œº\n      simp_rw [ae_iff, not_le] at hle\n      exact nonpos_iff_eq_zero.2 hle\n    rw [this, eLpNormEssSup_measure_zero]\n  exact measurableSet_le measurable_const hmeas.nnnorm.measurable.subtype_coe\n\n/- This lemma is slightly weaker than `MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_norm_ge_pos_le` as the\nlatter provides `0 < M`. -/\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_norm_ge_le","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhmeas : MeasureTheory.StronglyMeasurable f\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun M => LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le M ‚Üë(NNNorm.nnnorm (f x))).indicator f) p Œº) (ENNReal.ofReal Œµ)","decl":"theorem Mem‚Ñíp.eLpNorm_indicator_norm_ge_le (hf : Mem‚Ñíp f p Œº) (hmeas : StronglyMeasurable f) {Œµ : ‚Ñù}\n    (hŒµ : 0 < Œµ) : ‚àÉ M : ‚Ñù, eLpNorm ({ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  by_cases hp_ne_zero : p = 0\n  ¬∑ refine ‚ü®1, hp_ne_zero.symm ‚ñ∏ ?_‚ü©\n    simp [eLpNorm_exponent_zero]\n  by_cases hp_ne_top : p = ‚àû\n  ¬∑ subst hp_ne_top\n    obtain ‚ü®M, hM‚ü© := hf.eLpNormEssSup_indicator_norm_ge_eq_zero hmeas\n    refine ‚ü®M, ?_‚ü©\n    simp only [eLpNorm_exponent_top, hM, zero_le]\n  obtain ‚ü®M, hM', hM‚ü© := Mem‚Ñíp.integral_indicator_norm_ge_nonneg_le\n    (Œº := Œº) (hf.norm_rpow hp_ne_zero hp_ne_top) (Real.rpow_pos_of_pos hŒµ p.toReal)\n  refine ‚ü®M ^ (1 / p.toReal), ?_‚ü©\n  rw [eLpNorm_eq_lintegral_rpow_enorm hp_ne_zero hp_ne_top, ‚Üê ENNReal.rpow_one (ENNReal.ofReal Œµ)]\n  conv_rhs => rw [‚Üê mul_one_div_cancel (ENNReal.toReal_pos hp_ne_zero hp_ne_top).ne.symm]\n  rw [ENNReal.rpow_mul,\n    ENNReal.rpow_le_rpow_iff (one_div_pos.2 <| ENNReal.toReal_pos hp_ne_zero hp_ne_top),\n    ENNReal.ofReal_rpow_of_pos hŒµ]\n  convert hM using 3 with x\n  rw [enorm_indicator_eq_indicator_enorm, enorm_indicator_eq_indicator_enorm]\n  have hiff : M ^ (1 / p.toReal) ‚â§ ‚Äñf x‚Äñ‚Çä ‚Üî M ‚â§ ‚Äñ‚Äñf x‚Äñ ^ p.toReal‚Äñ‚Çä := by\n    rw [coe_nnnorm, coe_nnnorm, Real.norm_rpow_of_nonneg (norm_nonneg _), norm_norm,\n      ‚Üê Real.rpow_le_rpow_iff hM' (Real.rpow_nonneg (norm_nonneg _) _)\n        (one_div_pos.2 <| ENNReal.toReal_pos hp_ne_zero hp_ne_top), ‚Üê Real.rpow_mul (norm_nonneg _),\n      mul_one_div_cancel (ENNReal.toReal_pos hp_ne_zero hp_ne_top).ne.symm, Real.rpow_one]\n  by_cases hx : x ‚àà { x : Œ± | M ^ (1 / p.toReal) ‚â§ ‚Äñf x‚Äñ‚Çä }\n  ¬∑ rw [Set.indicator_of_mem hx, Set.indicator_of_mem, Real.enorm_of_nonneg (by positivity),\n      ‚Üê ENNReal.ofReal_rpow_of_nonneg (norm_nonneg _) ENNReal.toReal_nonneg, ofReal_norm]\n    rw [Set.mem_setOf_eq]\n    rwa [‚Üê hiff]\n  ¬∑ rw [Set.indicator_of_not_mem hx, Set.indicator_of_not_mem]\n    ¬∑ simp [ENNReal.toReal_pos hp_ne_zero hp_ne_top]\n    ¬∑ rw [Set.mem_setOf_eq]\n      rwa [‚Üê hiff]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_norm_ge_pos_le","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œ± ‚Üí Œ≤\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhmeas : MeasureTheory.StronglyMeasurable f\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun M => And (LT.lt 0 M) (LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le M ‚Üë(NNNorm.nnnorm (f x))).indicator f) p Œº) (ENNReal.ofReal Œµ))","decl":"/-- This lemma implies that a single function is uniformly integrable (in the probability sense). -/\ntheorem Mem‚Ñíp.eLpNorm_indicator_norm_ge_pos_le (hf : Mem‚Ñíp f p Œº) (hmeas : StronglyMeasurable f)\n    {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ M : ‚Ñù, 0 < M ‚àß eLpNorm ({ x | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  obtain ‚ü®M, hM‚ü© := hf.eLpNorm_indicator_norm_ge_le hmeas hŒµ\n  refine\n    ‚ü®max M 1, lt_of_lt_of_le zero_lt_one (le_max_right _ _), le_trans (eLpNorm_mono fun x => ?_) hM‚ü©\n  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  refine Set.indicator_le_indicator_of_subset (fun x hx => ?_) (fun x => norm_nonneg (f x)) x\n  rw [Set.mem_setOf_eq] at hx -- removing the `rw` breaks the proof!\n  exact (max_le_iff.1 hx).1\n\n"}
{"name":"MeasureTheory.eLpNorm_indicator_le_of_bound","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œ± ‚Üí Œ≤\nhp_top : Ne p Top.top\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\nM : Real\nhf : ‚àÄ (x : Œ±), LT.lt (Norm.norm (f x)) M\n‚ä¢ Exists fun Œ¥ => Exists fun x => ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (Œº s) (ENNReal.ofReal Œ¥) ‚Üí LE.le (MeasureTheory.eLpNorm (s.indicator f) p Œº) (ENNReal.ofReal Œµ)","decl":"theorem eLpNorm_indicator_le_of_bound {f : Œ± ‚Üí Œ≤} (hp_top : p ‚â† ‚àû) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) {M : ‚Ñù}\n    (hf : ‚àÄ x, ‚Äñf x‚Äñ < M) :\n    ‚àÉ (Œ¥ : ‚Ñù) (_ : 0 < Œ¥), ‚àÄ s, MeasurableSet s ‚Üí\n      Œº s ‚â§ ENNReal.ofReal Œ¥ ‚Üí eLpNorm (s.indicator f) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  by_cases hM : M ‚â§ 0\n  ¬∑ refine ‚ü®1, zero_lt_one, fun s _ _ => ?_‚ü©\n    rw [(_ : f = 0)]\n    ¬∑ simp [hŒµ.le]\n    ¬∑ ext x\n      rw [Pi.zero_apply, ‚Üê norm_le_zero_iff]\n      exact (lt_of_lt_of_le (hf x) hM).le\n  rw [not_le] at hM\n  refine ‚ü®(Œµ / M) ^ p.toReal, Real.rpow_pos_of_pos (div_pos hŒµ hM) _, fun s hs hŒº => ?_‚ü©\n  by_cases hp : p = 0\n  ¬∑ simp [hp]\n  rw [eLpNorm_indicator_eq_eLpNorm_restrict hs]\n  have haebdd : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñf x‚Äñ ‚â§ M := by\n    filter_upwards\n    exact fun x => (hf x).le\n  refine le_trans (eLpNorm_le_of_ae_bound haebdd) ?_\n  rw [Measure.restrict_apply MeasurableSet.univ, Set.univ_inter,\n    ‚Üê ENNReal.le_div_iff_mul_le (Or.inl _) (Or.inl ENNReal.ofReal_ne_top)]\n  ¬∑ rw [ENNReal.rpow_inv_le_iff (ENNReal.toReal_pos hp hp_top)]\n    refine le_trans hŒº ?_\n    rw [‚Üê ENNReal.ofReal_rpow_of_pos (div_pos hŒµ hM),\n      ENNReal.rpow_le_rpow_iff (ENNReal.toReal_pos hp hp_top), ENNReal.ofReal_div_of_pos hM]\n  ¬∑ simpa only [ENNReal.ofReal_eq_zero, not_le, Ne]\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_le'","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œ± ‚Üí Œ≤\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhmeas : MeasureTheory.StronglyMeasurable f\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun Œ¥ => Exists fun x => ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (Œº s) (ENNReal.ofReal Œ¥) ‚Üí LE.le (MeasureTheory.eLpNorm (s.indicator f) p Œº) (HMul.hMul 2 (ENNReal.ofReal Œµ))","decl":"/-- Auxiliary lemma for `MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_le`. -/\ntheorem Mem‚Ñíp.eLpNorm_indicator_le' (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû) (hf : Mem‚Ñíp f p Œº)\n    (hmeas : StronglyMeasurable f) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ (Œ¥ : ‚Ñù) (_ : 0 < Œ¥), ‚àÄ s, MeasurableSet s ‚Üí Œº s ‚â§ ENNReal.ofReal Œ¥ ‚Üí\n      eLpNorm (s.indicator f) p Œº ‚â§ 2 * ENNReal.ofReal Œµ := by\n  obtain ‚ü®M, hMpos, hM‚ü© := hf.eLpNorm_indicator_norm_ge_pos_le hmeas hŒµ\n  obtain ‚ü®Œ¥, hŒ¥pos, hŒ¥‚ü© :=\n    eLpNorm_indicator_le_of_bound (f := { x | ‚Äñf x‚Äñ < M }.indicator f) hp_top hŒµ (by\n      intro x\n      rw [norm_indicator_eq_indicator_norm, Set.indicator_apply]\n      ¬∑ split_ifs with h\n        exacts [h, hMpos])\n  refine ‚ü®Œ¥, hŒ¥pos, fun s hs hŒºs => ?_‚ü©\n  rw [(_ : f = { x : Œ± | M ‚â§ ‚Äñf x‚Äñ‚Çä }.indicator f + { x : Œ± | ‚Äñf x‚Äñ < M }.indicator f)]\n  ¬∑ rw [eLpNorm_indicator_eq_eLpNorm_restrict hs]\n    refine le_trans (eLpNorm_add_le ?_ ?_ hp_one) ?_\n    ¬∑ exact StronglyMeasurable.aestronglyMeasurable\n        (hmeas.indicator (measurableSet_le measurable_const hmeas.nnnorm.measurable.subtype_coe))\n    ¬∑ exact StronglyMeasurable.aestronglyMeasurable\n        (hmeas.indicator (measurableSet_lt hmeas.nnnorm.measurable.subtype_coe measurable_const))\n    ¬∑ rw [two_mul]\n      refine add_le_add (le_trans (eLpNorm_mono_measure _ Measure.restrict_le_self) hM) ?_\n      rw [‚Üê eLpNorm_indicator_eq_eLpNorm_restrict hs]\n      exact hŒ¥ s hs hŒºs\n  ¬∑ ext x\n    by_cases hx : M ‚â§ ‚Äñf x‚Äñ\n    ¬∑ rw [Pi.add_apply, Set.indicator_of_mem, Set.indicator_of_not_mem, add_zero] <;> simpa\n    ¬∑ rw [Pi.add_apply, Set.indicator_of_not_mem, Set.indicator_of_mem, zero_add] <;>\n        simpa using hx\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_le_of_meas","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œ± ‚Üí Œ≤\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nhmeas : MeasureTheory.StronglyMeasurable f\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun Œ¥ => Exists fun x => ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (Œº s) (ENNReal.ofReal Œ¥) ‚Üí LE.le (MeasureTheory.eLpNorm (s.indicator f) p Œº) (ENNReal.ofReal Œµ)","decl":"/-- This lemma is superseded by `MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_le` which does not require\nmeasurability on `f`. -/\ntheorem Mem‚Ñíp.eLpNorm_indicator_le_of_meas (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû) (hf : Mem‚Ñíp f p Œº)\n    (hmeas : StronglyMeasurable f) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ (Œ¥ : ‚Ñù) (_ : 0 < Œ¥), ‚àÄ s, MeasurableSet s ‚Üí Œº s ‚â§ ENNReal.ofReal Œ¥ ‚Üí\n      eLpNorm (s.indicator f) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  obtain ‚ü®Œ¥, hŒ¥pos, hŒ¥‚ü© := hf.eLpNorm_indicator_le' hp_one hp_top hmeas (half_pos hŒµ)\n  refine ‚ü®Œ¥, hŒ¥pos, fun s hs hŒºs => le_trans (hŒ¥ s hs hŒºs) ?_‚ü©\n  rw [ENNReal.ofReal_div_of_pos zero_lt_two, (by norm_num : ENNReal.ofReal 2 = 2),\n      ENNReal.mul_div_cancel] <;>\n    norm_num\n\n"}
{"name":"MeasureTheory.Mem‚Ñíp.eLpNorm_indicator_le","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œ± ‚Üí Œ≤\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nhf : MeasureTheory.Mem‚Ñíp f p Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun Œ¥ => Exists fun x => ‚àÄ (s : Set Œ±), MeasurableSet s ‚Üí LE.le (Œº s) (ENNReal.ofReal Œ¥) ‚Üí LE.le (MeasureTheory.eLpNorm (s.indicator f) p Œº) (ENNReal.ofReal Œµ)","decl":"theorem Mem‚Ñíp.eLpNorm_indicator_le (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû) (hf : Mem‚Ñíp f p Œº) {Œµ : ‚Ñù}\n    (hŒµ : 0 < Œµ) :\n    ‚àÉ (Œ¥ : ‚Ñù) (_ : 0 < Œ¥), ‚àÄ s, MeasurableSet s ‚Üí Œº s ‚â§ ENNReal.ofReal Œ¥ ‚Üí\n      eLpNorm (s.indicator f) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  have h‚Ñíp := hf\n  obtain ‚ü®‚ü®f', hf', heq‚ü©, _‚ü© := hf\n  obtain ‚ü®Œ¥, hŒ¥pos, hŒ¥‚ü© := (h‚Ñíp.ae_eq heq).eLpNorm_indicator_le_of_meas hp_one hp_top hf' hŒµ\n  refine ‚ü®Œ¥, hŒ¥pos, fun s hs hŒºs => ?_‚ü©\n  convert hŒ¥ s hs hŒºs using 1\n  rw [eLpNorm_indicator_eq_eLpNorm_restrict hs, eLpNorm_indicator_eq_eLpNorm_restrict hs]\n  exact eLpNorm_congr_ae heq.restrict\n\n"}
{"name":"MeasureTheory.unifIntegrable_const","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\ng : Œ± ‚Üí Œ≤\nhp : LE.le 1 p\nhp_ne_top : Ne p Top.top\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ MeasureTheory.UnifIntegrable (fun x => g) p Œº","decl":"/-- A constant function is uniformly integrable. -/\ntheorem unifIntegrable_const {g : Œ± ‚Üí Œ≤} (hp : 1 ‚â§ p) (hp_ne_top : p ‚â† ‚àû) (hg : Mem‚Ñíp g p Œº) :\n    UnifIntegrable (fun _ : Œπ => g) p Œº := by\n  intro Œµ hŒµ\n  obtain ‚ü®Œ¥, hŒ¥_pos, hgŒ¥‚ü© := hg.eLpNorm_indicator_le hp hp_ne_top hŒµ\n  exact ‚ü®Œ¥, hŒ¥_pos, fun _ => hgŒ¥‚ü©\n\n"}
{"name":"MeasureTheory.unifIntegrable_subsingleton","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\ninst‚úù : Subsingleton Œπ\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : ‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"/-- A single function is uniformly integrable. -/\ntheorem unifIntegrable_subsingleton [Subsingleton Œπ] (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû)\n    {f : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : ‚àÄ i, Mem‚Ñíp (f i) p Œº) : UnifIntegrable f p Œº := by\n  intro Œµ hŒµ\n  by_cases hŒπ : Nonempty Œπ\n  ¬∑ cases' hŒπ with i\n    obtain ‚ü®Œ¥, hŒ¥pos, hŒ¥‚ü© := (hf i).eLpNorm_indicator_le hp_one hp_top hŒµ\n    refine ‚ü®Œ¥, hŒ¥pos, fun j s hs hŒºs => ?_‚ü©\n    convert hŒ¥ s hs hŒºs\n  ¬∑ exact ‚ü®1, zero_lt_one, fun i => False.elim <| hŒπ <| Nonempty.intro i‚ü©\n\n"}
{"name":"MeasureTheory.unifIntegrable_fin","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nn : Nat\nf : Fin n ‚Üí Œ± ‚Üí Œ≤\nhf : ‚àÄ (i : Fin n), MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"/-- This lemma is less general than `MeasureTheory.unifIntegrable_finite` which applies to\nall sequences indexed by a finite type. -/\ntheorem unifIntegrable_fin (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû) {n : ‚Ñï} {f : Fin n ‚Üí Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ i, Mem‚Ñíp (f i) p Œº) : UnifIntegrable f p Œº := by\n  revert f\n  induction' n with n h\n  ¬∑ intro f hf\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10754): added this instance\n    have : Subsingleton (Fin Nat.zero) := subsingleton_fin_zero\n    exact unifIntegrable_subsingleton hp_one hp_top hf\n  intro f hfLp Œµ hŒµ\n  let g : Fin n ‚Üí Œ± ‚Üí Œ≤ := fun k => f k\n  have hgLp : ‚àÄ i, Mem‚Ñíp (g i) p Œº := fun i => hfLp i\n  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅpos, hŒ¥‚ÇÅ‚ü© := h hgLp hŒµ\n  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇpos, hŒ¥‚ÇÇ‚ü© := (hfLp n).eLpNorm_indicator_le hp_one hp_top hŒµ\n  refine ‚ü®min Œ¥‚ÇÅ Œ¥‚ÇÇ, lt_min hŒ¥‚ÇÅpos hŒ¥‚ÇÇpos, fun i s hs hŒºs => ?_‚ü©\n  by_cases hi : i.val < n\n  ¬∑ rw [(_ : f i = g ‚ü®i.val, hi‚ü©)]\n    ¬∑ exact hŒ¥‚ÇÅ _ s hs (le_trans hŒºs <| ENNReal.ofReal_le_ofReal <| min_le_left _ _)\n    ¬∑ simp [g]\n  ¬∑ rw [(_ : i = n)]\n    ¬∑ exact hŒ¥‚ÇÇ _ hs (le_trans hŒºs <| ENNReal.ofReal_le_ofReal <| min_le_right _ _)\n    ¬∑ have hi' := Fin.is_lt i\n      rw [Nat.lt_succ_iff] at hi'\n      rw [not_lt] at hi\n      simp [‚Üê le_antisymm hi' hi]\n\n"}
{"name":"MeasureTheory.unifIntegrable_finite","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\ninst‚úù : Finite Œπ\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : ‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"/-- A finite sequence of Lp functions is uniformly integrable. -/\ntheorem unifIntegrable_finite [Finite Œπ] (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû) {f : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ i, Mem‚Ñíp (f i) p Œº) : UnifIntegrable f p Œº := by\n  obtain ‚ü®n, hn‚ü© := Finite.exists_equiv_fin Œπ\n  intro Œµ hŒµ\n  let g : Fin n ‚Üí Œ± ‚Üí Œ≤ := f ‚àò hn.some.symm\n  have hg : ‚àÄ i, Mem‚Ñíp (g i) p Œº := fun _ => hf _\n  obtain ‚ü®Œ¥, hŒ¥pos, hŒ¥‚ü© := unifIntegrable_fin hp_one hp_top hg hŒµ\n  refine ‚ü®Œ¥, hŒ¥pos, fun i s hs hŒºs => ?_‚ü©\n  specialize hŒ¥ (hn.some i) s hs hŒºs\n  simp_rw [g, Function.comp_apply, Equiv.symm_apply_apply] at hŒ¥\n  assumption\n\n"}
{"name":"MeasureTheory.eLpNorm_sub_le_of_dist_bdd","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\ninst‚úù : NormedAddCommGroup Œ≤\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nhp' : Ne p Top.top\ns : Set Œ±\nhs : MeasurableSet s\nf g : Œ± ‚Üí Œ≤\nc : Real\nhc : LE.le 0 c\nhf : ‚àÄ (x : Œ±), Membership.mem s x ‚Üí LE.le (Dist.dist (f x) (g x)) c\n‚ä¢ LE.le (MeasureTheory.eLpNorm (s.indicator (HSub.hSub f g)) p Œº) (HMul.hMul (ENNReal.ofReal c) (HPow.hPow (Œº s) (HDiv.hDiv 1 p.toReal)))","decl":"theorem eLpNorm_sub_le_of_dist_bdd (Œº : Measure Œ±)\n    {p : ‚Ñù‚â•0‚àû} (hp' : p ‚â† ‚àû) {s : Set Œ±} (hs : MeasurableSet[m] s)\n    {f g : Œ± ‚Üí Œ≤} {c : ‚Ñù} (hc : 0 ‚â§ c) (hf : ‚àÄ x ‚àà s, dist (f x) (g x) ‚â§ c) :\n    eLpNorm (s.indicator (f - g)) p Œº ‚â§ ENNReal.ofReal c * Œº s ^ (1 / p.toReal) := by\n  by_cases hp : p = 0\n  ¬∑ simp [hp]\n  have : ‚àÄ x, ‚Äñs.indicator (f - g) x‚Äñ ‚â§ ‚Äñs.indicator (fun _ => c) x‚Äñ := by\n    intro x\n    by_cases hx : x ‚àà s\n    ¬∑ rw [Set.indicator_of_mem hx, Set.indicator_of_mem hx, Pi.sub_apply, ‚Üê dist_eq_norm,\n        Real.norm_eq_abs, abs_of_nonneg hc]\n      exact hf x hx\n    ¬∑ simp [Set.indicator_of_not_mem hx]\n  refine le_trans (eLpNorm_mono this) ?_\n  rw [eLpNorm_indicator_const hs hp hp']\n  refine mul_le_mul_right' (le_of_eq ?_) _\n  rw [‚Üê ofReal_norm_eq_enorm, Real.norm_eq_abs, abs_of_nonneg hc]\n\n"}
{"name":"MeasureTheory.tendsto_Lp_finite_of_tendsto_ae_of_meas","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\nf : Nat ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\nhf : ‚àÄ (n : Nat), MeasureTheory.StronglyMeasurable (f n)\nhg : MeasureTheory.StronglyMeasurable g\nhg' : MeasureTheory.Mem‚Ñíp g p Œº\nhui : MeasureTheory.UnifIntegrable f p Œº\nhfg : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Œº) Filter.atTop (nhds 0)","decl":"/-- A sequence of uniformly integrable functions which converges Œº-a.e. converges in Lp. -/\ntheorem tendsto_Lp_finite_of_tendsto_ae_of_meas [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)\n    {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ n, StronglyMeasurable (f n)) (hg : StronglyMeasurable g)\n    (hg' : Mem‚Ñíp g p Œº) (hui : UnifIntegrable f p Œº)\n    (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :\n    Tendsto (fun n => eLpNorm (f n - g) p Œº) atTop (ùìù 0) := by\n  rw [ENNReal.tendsto_atTop_zero]\n  intro Œµ hŒµ\n  by_cases h : Œµ < ‚àû; swap\n  ¬∑ rw [not_lt, top_le_iff] at h\n    exact ‚ü®0, fun n _ => by simp [h]‚ü©\n  by_cases hŒº : Œº = 0\n  ¬∑ exact ‚ü®0, fun n _ => by simp [hŒº]‚ü©\n  have hŒµ' : 0 < Œµ.toReal / 3 := div_pos (ENNReal.toReal_pos hŒµ.ne' h.ne) (by norm_num)\n  have hdivp : 0 ‚â§ 1 / p.toReal := by positivity\n  have hpow : 0 < measureUnivNNReal Œº ^ (1 / p.toReal) :=\n    Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _\n  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥‚ÇÅ, heLpNorm‚ÇÅ‚ü© := hui hŒµ'\n  obtain ‚ü®Œ¥‚ÇÇ, hŒ¥‚ÇÇ, heLpNorm‚ÇÇ‚ü© := hg'.eLpNorm_indicator_le hp hp' hŒµ'\n  obtain ‚ü®t, htm, ht‚ÇÅ, ht‚ÇÇ‚ü© := tendstoUniformlyOn_of_ae_tendsto' hf hg hfg (lt_min hŒ¥‚ÇÅ hŒ¥‚ÇÇ)\n  rw [Metric.tendstoUniformlyOn_iff] at ht‚ÇÇ\n  specialize ht‚ÇÇ (Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))\n    (div_pos (ENNReal.toReal_pos (gt_iff_lt.1 hŒµ).ne.symm h.ne) (mul_pos (by norm_num) hpow))\n  obtain ‚ü®N, hN‚ü© := eventually_atTop.1 ht‚ÇÇ; clear ht‚ÇÇ\n  refine ‚ü®N, fun n hn => ?_‚ü©\n  rw [‚Üê t.indicator_self_add_compl (f n - g)]\n  refine le_trans (eLpNorm_add_le (((hf n).sub hg).indicator htm).aestronglyMeasurable\n    (((hf n).sub hg).indicator htm.compl).aestronglyMeasurable hp) ?_\n  rw [sub_eq_add_neg, Set.indicator_add' t, Set.indicator_neg']\n  refine le_trans (add_le_add_right (eLpNorm_add_le ((hf n).indicator htm).aestronglyMeasurable\n    (hg.indicator htm).neg.aestronglyMeasurable hp) _) ?_\n  have hnf : eLpNorm (t.indicator (f n)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by\n    refine heLpNorm‚ÇÅ n t htm (le_trans ht‚ÇÅ ?_)\n    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÅ.le]\n    exact min_le_left _ _\n  have hng : eLpNorm (t.indicator g) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by\n    refine heLpNorm‚ÇÇ t htm (le_trans ht‚ÇÅ ?_)\n    rw [ENNReal.ofReal_le_ofReal_iff hŒ¥‚ÇÇ.le]\n    exact min_le_right _ _\n  have hlt : eLpNorm (t·∂ú.indicator (f n - g)) p Œº ‚â§ ENNReal.ofReal (Œµ.toReal / 3) := by\n    specialize hN n hn\n    have : 0 ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)) := by positivity\n    have := eLpNorm_sub_le_of_dist_bdd Œº hp' htm.compl this fun x hx =>\n      (dist_comm (g x) (f n x) ‚ñ∏ (hN x hx).le :\n        dist (f n x) (g x) ‚â§ Œµ.toReal / (3 * measureUnivNNReal Œº ^ (1 / p.toReal)))\n    refine le_trans this ?_\n    rw [div_mul_eq_div_mul_one_div, ‚Üê ENNReal.ofReal_toReal (measure_lt_top Œº t·∂ú).ne,\n      ENNReal.ofReal_rpow_of_nonneg ENNReal.toReal_nonneg hdivp, ‚Üê ENNReal.ofReal_mul, mul_assoc]\n    ¬∑ refine ENNReal.ofReal_le_ofReal (mul_le_of_le_one_right hŒµ'.le ?_)\n      rw [mul_comm, mul_one_div, div_le_one]\n      ¬∑ refine Real.rpow_le_rpow ENNReal.toReal_nonneg\n          (ENNReal.toReal_le_of_le_ofReal (measureUnivNNReal_pos hŒº).le ?_) hdivp\n        rw [ENNReal.ofReal_coe_nnreal, coe_measureUnivNNReal]\n        exact measure_mono (Set.subset_univ _)\n      ¬∑ exact Real.rpow_pos_of_pos (measureUnivNNReal_pos hŒº) _\n    ¬∑ positivity\n  have : ENNReal.ofReal (Œµ.toReal / 3) = Œµ / 3 := by\n    rw [ENNReal.ofReal_div_of_pos (show (0 : ‚Ñù) < 3 by norm_num), ENNReal.ofReal_toReal h.ne]\n    simp\n  rw [this] at hnf hng hlt\n  rw [eLpNorm_neg, ‚Üê ENNReal.add_thirds Œµ, ‚Üê sub_eq_add_neg]\n  exact add_le_add_three hnf hng hlt\n\n"}
{"name":"MeasureTheory.tendsto_Lp_finite_of_tendsto_ae","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\nf : Nat ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\nhui : MeasureTheory.UnifIntegrable f p Œº\nhfg : Filter.Eventually (fun x => Filter.Tendsto (fun n => f n x) Filter.atTop (nhds (g x))) (MeasureTheory.ae Œº)\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Œº) Filter.atTop (nhds 0)","decl":"/-- A sequence of uniformly integrable functions which converges Œº-a.e. converges in Lp. -/\ntheorem tendsto_Lp_finite_of_tendsto_ae [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)\n    {f : ‚Ñï ‚Üí Œ± ‚Üí Œ≤} {g : Œ± ‚Üí Œ≤} (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) (hg : Mem‚Ñíp g p Œº)\n    (hui : UnifIntegrable f p Œº) (hfg : ‚àÄ·µê x ‚àÇŒº, Tendsto (fun n => f n x) atTop (ùìù (g x))) :\n    Tendsto (fun n => eLpNorm (f n - g) p Œº) atTop (ùìù 0) := by\n  have : ‚àÄ n, eLpNorm (f n - g) p Œº = eLpNorm ((hf n).mk (f n) - hg.1.mk g) p Œº :=\n    fun n => eLpNorm_congr_ae ((hf n).ae_eq_mk.sub hg.1.ae_eq_mk)\n  simp_rw [this]\n  refine tendsto_Lp_finite_of_tendsto_ae_of_meas hp hp' (fun n => (hf n).stronglyMeasurable_mk)\n    hg.1.stronglyMeasurable_mk (hg.ae_eq hg.1.ae_eq_mk) (hui.ae_eq fun n => (hf n).ae_eq_mk) ?_\n  have h_ae_forall_eq : ‚àÄ·µê x ‚àÇŒº, ‚àÄ n, f n x = (hf n).mk (f n) x := by\n    rw [ae_all_iff]\n    exact fun n => (hf n).ae_eq_mk\n  filter_upwards [hfg, h_ae_forall_eq, hg.1.ae_eq_mk] with x hx_tendsto hxf_eq hxg_eq\n  rw [‚Üê hxg_eq]\n  convert hx_tendsto using 1\n  ext1 n\n  exact (hxf_eq n).symm\n\n"}
{"name":"MeasureTheory.unifIntegrable_of_tendsto_Lp_zero","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Nat ‚Üí Œ± ‚Üí Œ≤\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ‚àÄ (n : Nat), MeasureTheory.Mem‚Ñíp (f n) p Œº\nhf_tendsto : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (f n) p Œº) Filter.atTop (nhds 0)\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"theorem unifIntegrable_of_tendsto_Lp_zero (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû) (hf : ‚àÄ n, Mem‚Ñíp (f n) p Œº)\n    (hf_tendsto : Tendsto (fun n => eLpNorm (f n) p Œº) atTop (ùìù 0)) : UnifIntegrable f p Œº := by\n  intro Œµ hŒµ\n  rw [ENNReal.tendsto_atTop_zero] at hf_tendsto\n  obtain ‚ü®N, hN‚ü© := hf_tendsto (ENNReal.ofReal Œµ) (by simpa)\n  let F : Fin N ‚Üí Œ± ‚Üí Œ≤ := fun n => f n\n  have hF : ‚àÄ n, Mem‚Ñíp (F n) p Œº := fun n => hf n\n  obtain ‚ü®Œ¥‚ÇÅ, hŒ¥pos‚ÇÅ, hŒ¥‚ÇÅ‚ü© := unifIntegrable_fin hp hp' hF hŒµ\n  refine ‚ü®Œ¥‚ÇÅ, hŒ¥pos‚ÇÅ, fun n s hs hŒºs => ?_‚ü©\n  by_cases hn : n < N\n  ¬∑ exact hŒ¥‚ÇÅ ‚ü®n, hn‚ü© s hs hŒºs\n  ¬∑ exact (eLpNorm_indicator_le _).trans (hN n (not_lt.1 hn))\n\n"}
{"name":"MeasureTheory.unifIntegrable_of_tendsto_Lp","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Nat ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ‚àÄ (n : Nat), MeasureTheory.Mem‚Ñíp (f n) p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\nhfg : Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Œº) Filter.atTop (nhds 0)\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"/-- Convergence in Lp implies uniform integrability. -/\ntheorem unifIntegrable_of_tendsto_Lp (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû) (hf : ‚àÄ n, Mem‚Ñíp (f n) p Œº)\n    (hg : Mem‚Ñíp g p Œº) (hfg : Tendsto (fun n => eLpNorm (f n - g) p Œº) atTop (ùìù 0)) :\n    UnifIntegrable f p Œº := by\n  have : f = (fun _ => g) + fun n => f n - g := by ext1 n; simp\n  rw [this]\n  refine UnifIntegrable.add ?_ ?_ hp (fun _ => hg.aestronglyMeasurable)\n      fun n => (hf n).1.sub hg.aestronglyMeasurable\n  ¬∑ exact unifIntegrable_const hp hp' hg\n  ¬∑ exact unifIntegrable_of_tendsto_Lp_zero hp hp' (fun n => (hf n).sub hg) hfg\n\n"}
{"name":"MeasureTheory.tendsto_Lp_finite_of_tendstoInMeasure","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Nat ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ‚àÄ (n : Nat), MeasureTheory.AEStronglyMeasurable (f n) Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\nhui : MeasureTheory.UnifIntegrable f p Œº\nhfg : MeasureTheory.TendstoInMeasure Œº f Filter.atTop g\n‚ä¢ Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Œº) Filter.atTop (nhds 0)","decl":"/-- Forward direction of Vitali's convergence theorem: if `f` is a sequence of uniformly integrable\nfunctions that converge in measure to some function `g` in a finite measure space, then `f`\nconverge in Lp to `g`. -/\ntheorem tendsto_Lp_finite_of_tendstoInMeasure [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)\n    (hf : ‚àÄ n, AEStronglyMeasurable (f n) Œº) (hg : Mem‚Ñíp g p Œº) (hui : UnifIntegrable f p Œº)\n    (hfg : TendstoInMeasure Œº f atTop g) : Tendsto (fun n ‚Ü¶ eLpNorm (f n - g) p Œº) atTop (ùìù 0) := by\n  refine tendsto_of_subseq_tendsto fun ns hns => ?_\n  obtain ‚ü®ms, _, hms'‚ü© := TendstoInMeasure.exists_seq_tendsto_ae fun Œµ hŒµ => (hfg Œµ hŒµ).comp hns\n  exact ‚ü®ms,\n    tendsto_Lp_finite_of_tendsto_ae hp hp' (fun _ => hf _) hg (fun Œµ hŒµ =>\n      let ‚ü®Œ¥, hŒ¥, hŒ¥'‚ü© := hui hŒµ\n      ‚ü®Œ¥, hŒ¥, fun i s hs hŒºs => hŒ¥' _ s hs hŒºs‚ü©)\n      hms'‚ü©\n\n"}
{"name":"MeasureTheory.tendstoInMeasure_iff_tendsto_Lp_finite","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Nat ‚Üí Œ± ‚Üí Œ≤\ng : Œ± ‚Üí Œ≤\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ‚àÄ (n : Nat), MeasureTheory.Mem‚Ñíp (f n) p Œº\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ Iff (And (MeasureTheory.TendstoInMeasure Œº f Filter.atTop g) (MeasureTheory.UnifIntegrable f p Œº)) (Filter.Tendsto (fun n => MeasureTheory.eLpNorm (HSub.hSub (f n) g) p Œº) Filter.atTop (nhds 0))","decl":"/-- **Vitali's convergence theorem**: A sequence of functions `f` converges to `g` in Lp if and\nonly if it is uniformly integrable and converges to `g` in measure. -/\ntheorem tendstoInMeasure_iff_tendsto_Lp_finite [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)\n    (hf : ‚àÄ n, Mem‚Ñíp (f n) p Œº) (hg : Mem‚Ñíp g p Œº) :\n    TendstoInMeasure Œº f atTop g ‚àß UnifIntegrable f p Œº ‚Üî\n      Tendsto (fun n => eLpNorm (f n - g) p Œº) atTop (ùìù 0) :=\n  ‚ü®fun h => tendsto_Lp_finite_of_tendstoInMeasure hp hp' (fun n => (hf n).1) hg h.2 h.1, fun h =>\n    ‚ü®tendstoInMeasure_of_tendsto_eLpNorm (lt_of_lt_of_le zero_lt_one hp).ne.symm\n        (fun n => (hf n).aestronglyMeasurable) hg.aestronglyMeasurable h,\n      unifIntegrable_of_tendsto_Lp hp hp' hf hg h‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.unifIntegrable_of'","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nhp : LE.le 1 p\nhp' : Ne p Top.top\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : ‚àÄ (i : Œπ), MeasureTheory.StronglyMeasurable (f i)\nh : ‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun C => And (LT.lt 0 C) (‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ))\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"/-- This lemma is superseded by `unifIntegrable_of` which do not require `C` to be positive. -/\ntheorem unifIntegrable_of' (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû) {f : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ i, StronglyMeasurable (f i))\n    (h : ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ C : ‚Ñù‚â•0, 0 < C ‚àß\n      ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ) :\n    UnifIntegrable f p Œº := by\n  have hpzero := (lt_of_lt_of_le zero_lt_one hp).ne.symm\n  by_cases hŒº : Œº Set.univ = 0\n  ¬∑ rw [Measure.measure_univ_eq_zero] at hŒº\n    exact hŒº.symm ‚ñ∏ unifIntegrable_zero_meas\n  intro Œµ hŒµ\n  obtain ‚ü®C, hCpos, hC‚ü© := h (Œµ / 2) (half_pos hŒµ)\n  refine ‚ü®(Œµ / (2 * C)) ^ ENNReal.toReal p,\n    Real.rpow_pos_of_pos (div_pos hŒµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos))) _,\n    fun i s hs hŒºs => ?_‚ü©\n  by_cases hŒºs' : Œº s = 0\n  ¬∑ rw [(eLpNorm_eq_zero_iff ((hf i).indicator hs).aestronglyMeasurable hpzero).2\n        (indicator_meas_zero hŒºs')]\n    norm_num\n  calc\n    eLpNorm (Set.indicator s (f i)) p Œº ‚â§\n        eLpNorm (Set.indicator (s ‚à© { x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }) (f i)) p Œº +\n          eLpNorm (Set.indicator (s ‚à© { x | ‚Äñf i x‚Äñ‚Çä < C }) (f i)) p Œº := by\n      refine le_trans (Eq.le ?_) (eLpNorm_add_le\n        (StronglyMeasurable.aestronglyMeasurable\n          ((hf i).indicator (hs.inter (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))))\n        (StronglyMeasurable.aestronglyMeasurable\n          ((hf i).indicator (hs.inter ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const))))\n        hp)\n      congr\n      change _ = fun x => (s ‚à© { x : Œ± | C ‚â§ ‚Äñf i x‚Äñ‚Çä }).indicator (f i) x +\n        (s ‚à© { x : Œ± | ‚Äñf i x‚Äñ‚Çä < C }).indicator (f i) x\n      rw [‚Üê Set.indicator_union_of_disjoint]\n      ¬∑ rw [‚Üê Set.inter_union_distrib_left, (by ext; simp [le_or_lt] :\n            { x : Œ± | C ‚â§ ‚Äñf i x‚Äñ‚Çä } ‚à™ { x : Œ± | ‚Äñf i x‚Äñ‚Çä < C } = Set.univ),\n          Set.inter_univ]\n      ¬∑ refine (Disjoint.inf_right' _ ?_).inf_left' _\n        rw [disjoint_iff_inf_le]\n        rintro x ‚ü®hx‚ÇÅ, hx‚ÇÇ‚ü©\n        rw [Set.mem_setOf_eq] at hx‚ÇÅ hx‚ÇÇ\n        exact False.elim (hx‚ÇÇ.ne (eq_of_le_of_not_lt hx‚ÇÅ (not_lt.2 hx‚ÇÇ.le)).symm)\n    _ ‚â§ eLpNorm (Set.indicator { x | C ‚â§ ‚Äñf i x‚Äñ‚Çä } (f i)) p Œº +\n        (C : ‚Ñù‚â•0‚àû) * Œº s ^ (1 / ENNReal.toReal p) := by\n      refine add_le_add\n        (eLpNorm_mono fun x => norm_indicator_le_of_subset Set.inter_subset_right _ _) ?_\n      rw [‚Üê Set.indicator_indicator]\n      rw [eLpNorm_indicator_eq_eLpNorm_restrict hs]\n      have : ‚àÄ·µê x ‚àÇŒº.restrict s, ‚Äñ{ x : Œ± | ‚Äñf i x‚Äñ‚Çä < C }.indicator (f i) x‚Äñ ‚â§ C := by\n        filter_upwards\n        simp_rw [norm_indicator_eq_indicator_norm]\n        exact Set.indicator_le' (fun x (hx : _ < _) => hx.le) fun _ _ => NNReal.coe_nonneg _\n      refine le_trans (eLpNorm_le_of_ae_bound this) ?_\n      rw [mul_comm, Measure.restrict_apply' hs, Set.univ_inter, ENNReal.ofReal_coe_nnreal, one_div]\n    _ ‚â§ ENNReal.ofReal (Œµ / 2) + C * ENNReal.ofReal (Œµ / (2 * C)) := by\n      refine add_le_add (hC i) (mul_le_mul_left' ?_ _)\n      rwa [one_div, ENNReal.rpow_inv_le_iff (ENNReal.toReal_pos hpzero hp'),\n        ENNReal.ofReal_rpow_of_pos (div_pos hŒµ (mul_pos two_pos (NNReal.coe_pos.2 hCpos)))]\n    _ ‚â§ ENNReal.ofReal (Œµ / 2) + ENNReal.ofReal (Œµ / 2) := by\n      refine add_le_add_left ?_ _\n      rw [‚Üê ENNReal.ofReal_coe_nnreal, ‚Üê ENNReal.ofReal_mul (NNReal.coe_nonneg _), ‚Üê div_div,\n        mul_div_cancel‚ÇÄ _ (NNReal.coe_pos.2 hCpos).ne.symm]\n    _ ‚â§ ENNReal.ofReal Œµ := by\n      rw [‚Üê ENNReal.ofReal_add (half_pos hŒµ).le (half_pos hŒµ).le, add_halves]\n\n"}
{"name":"MeasureTheory.unifIntegrable_of","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nhp : LE.le 1 p\nhp' : Ne p Top.top\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : ‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (f i) Œº\nh : ‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun C => ‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ)\n‚ä¢ MeasureTheory.UnifIntegrable f p Œº","decl":"theorem unifIntegrable_of (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû) {f : Œπ ‚Üí Œ± ‚Üí Œ≤}\n    (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº)\n    (h : ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ C : ‚Ñù‚â•0,\n      ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ) :\n    UnifIntegrable f p Œº := by\n  set g : Œπ ‚Üí Œ± ‚Üí Œ≤ := fun i => (hf i).choose\n  refine\n    (unifIntegrable_of' hp hp' (fun i => (Exists.choose_spec <| hf i).1) fun Œµ hŒµ => ?_).ae_eq\n      fun i => (Exists.choose_spec <| hf i).2.symm\n  obtain ‚ü®C, hC‚ü© := h Œµ hŒµ\n  have hCg : ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñg i x‚Äñ‚Çä }.indicator (g i)) p Œº ‚â§ ENNReal.ofReal Œµ := by\n    intro i\n    refine le_trans (le_of_eq <| eLpNorm_congr_ae ?_) (hC i)\n    filter_upwards [(Exists.choose_spec <| hf i).2] with x hx\n    by_cases hfx : x ‚àà { x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }\n    ¬∑ rw [Set.indicator_of_mem hfx, Set.indicator_of_mem, hx]\n      rwa [Set.mem_setOf, hx] at hfx\n    ¬∑ rw [Set.indicator_of_not_mem hfx, Set.indicator_of_not_mem]\n      rwa [Set.mem_setOf, hx] at hfx\n  refine ‚ü®max C 1, lt_max_of_lt_right one_pos, fun i => le_trans (eLpNorm_mono fun x => ?_) (hCg i)‚ü©\n  rw [norm_indicator_eq_indicator_norm, norm_indicator_eq_indicator_norm]\n  exact Set.indicator_le_indicator_of_subset\n    (fun x hx => Set.mem_setOf_eq ‚ñ∏ le_trans (le_max_left _ _) hx) (fun _ => norm_nonneg _) _\n\n"}
{"name":"MeasureTheory.uniformIntegrable_zero_meas","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ninst‚úù : MeasurableSpace Œ±\n‚ä¢ MeasureTheory.UniformIntegrable f p 0","decl":"theorem uniformIntegrable_zero_meas [MeasurableSpace Œ±] : UniformIntegrable f p (0 : Measure Œ±) :=\n  ‚ü®fun _ => aestronglyMeasurable_zero_measure _, unifIntegrable_zero_meas, 0,\n    fun _ => eLpNorm_measure_zero.le‚ü©\n\n"}
{"name":"MeasureTheory.UniformIntegrable.ae_eq","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf g : Œπ ‚Üí Œ± ‚Üí Œ≤\nhf : MeasureTheory.UniformIntegrable f p Œº\nhfg : ‚àÄ (n : Œπ), (MeasureTheory.ae Œº).EventuallyEq (f n) (g n)\n‚ä¢ MeasureTheory.UniformIntegrable g p Œº","decl":"theorem UniformIntegrable.ae_eq {g : Œπ ‚Üí Œ± ‚Üí Œ≤} (hf : UniformIntegrable f p Œº)\n    (hfg : ‚àÄ n, f n =·µê[Œº] g n) : UniformIntegrable g p Œº := by\n  obtain ‚ü®hfm, hunif, C, hC‚ü© := hf\n  refine ‚ü®fun i => (hfm i).congr (hfg i), (unifIntegrable_congr_ae hfg).1 hunif, C, fun i => ?_‚ü©\n  rw [‚Üê eLpNorm_congr_ae (hfg i)]\n  exact hC i\n\n"}
{"name":"MeasureTheory.uniformIntegrable_congr_ae","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf g : Œπ ‚Üí Œ± ‚Üí Œ≤\nhfg : ‚àÄ (n : Œπ), (MeasureTheory.ae Œº).EventuallyEq (f n) (g n)\n‚ä¢ Iff (MeasureTheory.UniformIntegrable f p Œº) (MeasureTheory.UniformIntegrable g p Œº)","decl":"theorem uniformIntegrable_congr_ae {g : Œπ ‚Üí Œ± ‚Üí Œ≤} (hfg : ‚àÄ n, f n =·µê[Œº] g n) :\n    UniformIntegrable f p Œº ‚Üî UniformIntegrable g p Œº :=\n  ‚ü®fun h => h.ae_eq hfg, fun h => h.ae_eq fun i => (hfg i).symm‚ü©\n\n"}
{"name":"MeasureTheory.uniformIntegrable_finite","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ninst‚úù : Finite Œπ\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nhf : ‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.UniformIntegrable f p Œº","decl":"/-- A finite sequence of Lp functions is uniformly integrable in the probability sense. -/\ntheorem uniformIntegrable_finite [Finite Œπ] (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû)\n    (hf : ‚àÄ i, Mem‚Ñíp (f i) p Œº) : UniformIntegrable f p Œº := by\n  cases nonempty_fintype Œπ\n  refine ‚ü®fun n => (hf n).1, unifIntegrable_finite hp_one hp_top hf, ?_‚ü©\n  by_cases hŒπ : Nonempty Œπ\n  ¬∑ choose _ hf using hf\n    set C := (Finset.univ.image fun i : Œπ => eLpNorm (f i) p Œº).max'\n      ‚ü®eLpNorm (f hŒπ.some) p Œº, Finset.mem_image.2 ‚ü®hŒπ.some, Finset.mem_univ _, rfl‚ü©‚ü©\n    refine ‚ü®C.toNNReal, fun i => ?_‚ü©\n    rw [ENNReal.coe_toNNReal]\n    ¬∑ exact Finset.le_max' (Œ± := ‚Ñù‚â•0‚àû) _ _ (Finset.mem_image.2 ‚ü®i, Finset.mem_univ _, rfl‚ü©)\n    ¬∑ refine ne_of_lt ((Finset.max'_lt_iff _ _).2 fun y hy => ?_)\n      rw [Finset.mem_image] at hy\n      obtain ‚ü®i, -, rfl‚ü© := hy\n      exact hf i\n  ¬∑ exact ‚ü®0, fun i => False.elim <| hŒπ <| Nonempty.intro i‚ü©\n\n"}
{"name":"MeasureTheory.uniformIntegrable_subsingleton","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ninst‚úù : Subsingleton Œπ\nhp_one : LE.le 1 p\nhp_top : Ne p Top.top\nhf : ‚àÄ (i : Œπ), MeasureTheory.Mem‚Ñíp (f i) p Œº\n‚ä¢ MeasureTheory.UniformIntegrable f p Œº","decl":"/-- A single function is uniformly integrable in the probability sense. -/\ntheorem uniformIntegrable_subsingleton [Subsingleton Œπ] (hp_one : 1 ‚â§ p) (hp_top : p ‚â† ‚àû)\n    (hf : ‚àÄ i, Mem‚Ñíp (f i) p Œº) : UniformIntegrable f p Œº :=\n  uniformIntegrable_finite hp_one hp_top hf\n\n"}
{"name":"MeasureTheory.uniformIntegrable_const","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\ng : Œ± ‚Üí Œ≤\nhp : LE.le 1 p\nhp_ne_top : Ne p Top.top\nhg : MeasureTheory.Mem‚Ñíp g p Œº\n‚ä¢ MeasureTheory.UniformIntegrable (fun x => g) p Œº","decl":"/-- A constant sequence of functions is uniformly integrable in the probability sense. -/\ntheorem uniformIntegrable_const {g : Œ± ‚Üí Œ≤} (hp : 1 ‚â§ p) (hp_ne_top : p ‚â† ‚àû) (hg : Mem‚Ñíp g p Œº) :\n    UniformIntegrable (fun _ : Œπ => g) p Œº :=\n  ‚ü®fun _ => hg.1, unifIntegrable_const hp hp_ne_top hg,\n    ‚ü®(eLpNorm g p Œº).toNNReal, fun _ => le_of_eq (ENNReal.coe_toNNReal hg.2.ne).symm‚ü©‚ü©\n\n"}
{"name":"MeasureTheory.uniformIntegrable_of'","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ‚àÄ (i : Œπ), MeasureTheory.StronglyMeasurable (f i)\nh : ‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun C => ‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ)\n‚ä¢ MeasureTheory.UniformIntegrable f p Œº","decl":"/-- This lemma is superseded by `uniformIntegrable_of` which only requires\n`AEStronglyMeasurable`. -/\ntheorem uniformIntegrable_of' [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)\n    (hf : ‚àÄ i, StronglyMeasurable (f i))\n    (h : ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ C : ‚Ñù‚â•0,\n      ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ) :\n    UniformIntegrable f p Œº := by\n  refine ‚ü®fun i => (hf i).aestronglyMeasurable,\n    unifIntegrable_of hp hp' (fun i => (hf i).aestronglyMeasurable) h, ?_‚ü©\n  obtain ‚ü®C, hC‚ü© := h 1 one_pos\n  refine ‚ü®((C : ‚Ñù‚â•0‚àû) * Œº Set.univ ^ p.toReal‚Åª¬π + 1).toNNReal, fun i => ?_‚ü©\n  calc\n    eLpNorm (f i) p Œº ‚â§\n        eLpNorm ({ x : Œ± | ‚Äñf i x‚Äñ‚Çä < C }.indicator (f i)) p Œº +\n          eLpNorm ({ x : Œ± | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº := by\n      refine le_trans (eLpNorm_mono fun x => ?_) (eLpNorm_add_le\n        (StronglyMeasurable.aestronglyMeasurable\n          ((hf i).indicator ((hf i).nnnorm.measurableSet_lt stronglyMeasurable_const)))\n        (StronglyMeasurable.aestronglyMeasurable\n          ((hf i).indicator (stronglyMeasurable_const.measurableSet_le (hf i).nnnorm))) hp)\n      rw [Pi.add_apply, Set.indicator_apply]\n      split_ifs with hx\n      ¬∑ rw [Set.indicator_of_not_mem, add_zero]\n        simpa using hx\n      ¬∑ rw [Set.indicator_of_mem, zero_add]\n        simpa using hx\n    _ ‚â§ (C : ‚Ñù‚â•0‚àû) * Œº Set.univ ^ p.toReal‚Åª¬π + 1 := by\n      have : ‚àÄ·µê x ‚àÇŒº, ‚Äñ{ x : Œ± | ‚Äñf i x‚Äñ‚Çä < C }.indicator (f i) x‚Äñ‚Çä ‚â§ C := by\n        filter_upwards\n        simp_rw [nnnorm_indicator_eq_indicator_nnnorm]\n        exact Set.indicator_le fun x (hx : _ < _) => hx.le\n      refine add_le_add (le_trans (eLpNorm_le_of_ae_bound this) ?_) (ENNReal.ofReal_one ‚ñ∏ hC i)\n      simp_rw [NNReal.val_eq_coe, ENNReal.ofReal_coe_nnreal, mul_comm]\n      exact le_rfl\n    _ = ((C : ‚Ñù‚â•0‚àû) * Œº Set.univ ^ p.toReal‚Åª¬π + 1 : ‚Ñù‚â•0‚àû).toNNReal := by\n      rw [ENNReal.coe_toNNReal]\n      exact ENNReal.add_ne_top.2\n        ‚ü®ENNReal.mul_ne_top ENNReal.coe_ne_top (ENNReal.rpow_ne_top_of_nonneg\n          (inv_nonneg.2 ENNReal.toReal_nonneg) (measure_lt_top _ _).ne),\n        ENNReal.one_ne_top‚ü©\n\n"}
{"name":"MeasureTheory.uniformIntegrable_of","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\nhf : ‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (f i) Œº\nh : ‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun C => ‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ)\n‚ä¢ MeasureTheory.UniformIntegrable f p Œº","decl":"/-- A sequence of functions `(f‚Çô)` is uniformly integrable in the probability sense if for all\n`Œµ > 0`, there exists some `C` such that `‚à´ x in {|f‚Çô| ‚â• C}, f‚Çô x ‚àÇŒº ‚â§ Œµ` for all `n`. -/\ntheorem uniformIntegrable_of [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû)\n    (hf : ‚àÄ i, AEStronglyMeasurable (f i) Œº)\n    (h : ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ C : ‚Ñù‚â•0,\n      ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ) :\n    UniformIntegrable f p Œº := by\n  set g : Œπ ‚Üí Œ± ‚Üí Œ≤ := fun i => (hf i).choose\n  have hgmeas : ‚àÄ i, StronglyMeasurable (g i) := fun i => (Exists.choose_spec <| hf i).1\n  have hgeq : ‚àÄ i, g i =·µê[Œº] f i := fun i => (Exists.choose_spec <| hf i).2.symm\n  refine (uniformIntegrable_of' hp hp' hgmeas fun Œµ hŒµ => ?_).ae_eq hgeq\n  obtain ‚ü®C, hC‚ü© := h Œµ hŒµ\n  refine ‚ü®C, fun i => le_trans (le_of_eq <| eLpNorm_congr_ae ?_) (hC i)‚ü©\n  filter_upwards [(Exists.choose_spec <| hf i).2] with x hx\n  by_cases hfx : x ‚àà { x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }\n  ¬∑ rw [Set.indicator_of_mem hfx, Set.indicator_of_mem, hx]\n    rwa [Set.mem_setOf, hx] at hfx\n  ¬∑ rw [Set.indicator_of_not_mem hfx, Set.indicator_of_not_mem]\n    rwa [Set.mem_setOf, hx] at hfx\n\n"}
{"name":"MeasureTheory.UniformIntegrable.spec'","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\nhp : Ne p 0\nhp' : Ne p Top.top\nhf : ‚àÄ (i : Œπ), MeasureTheory.StronglyMeasurable (f i)\nhfu : MeasureTheory.UniformIntegrable f p Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun C => ‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ)","decl":"/-- This lemma is superseded by `UniformIntegrable.spec` which does not require measurability. -/\ntheorem UniformIntegrable.spec' (hp : p ‚â† 0) (hp' : p ‚â† ‚àû) (hf : ‚àÄ i, StronglyMeasurable (f i))\n    (hfu : UniformIntegrable f p Œº) {Œµ : ‚Ñù} (hŒµ : 0 < Œµ) :\n    ‚àÉ C : ‚Ñù‚â•0, ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  obtain ‚ü®-, hfu, M, hM‚ü© := hfu\n  obtain ‚ü®Œ¥, hŒ¥pos, hŒ¥‚ü© := hfu hŒµ\n  obtain ‚ü®C, hC‚ü© : ‚àÉ C : ‚Ñù‚â•0, ‚àÄ i, Œº { x | C ‚â§ ‚Äñf i x‚Äñ‚Çä } ‚â§ ENNReal.ofReal Œ¥ := by\n    by_contra hcon; push_neg at hcon\n    choose ‚Ñê h‚Ñê using hcon\n    lift Œ¥ to ‚Ñù‚â•0 using hŒ¥pos.le\n    have : ‚àÄ C : ‚Ñù‚â•0, C ‚Ä¢ (Œ¥ : ‚Ñù‚â•0‚àû) ^ (1 / p.toReal) ‚â§ eLpNorm (f (‚Ñê C)) p Œº := by\n      intro C\n      calc\n        C ‚Ä¢ (Œ¥ : ‚Ñù‚â•0‚àû) ^ (1 / p.toReal) ‚â§ C ‚Ä¢ Œº { x | C ‚â§ ‚Äñf (‚Ñê C) x‚Äñ‚Çä } ^ (1 / p.toReal) := by\n          rw [ENNReal.smul_def, ENNReal.smul_def, smul_eq_mul, smul_eq_mul]\n          simp_rw [ENNReal.ofReal_coe_nnreal] at h‚Ñê\n          refine mul_le_mul' le_rfl\n            (ENNReal.rpow_le_rpow (h‚Ñê C).le (one_div_nonneg.2 ENNReal.toReal_nonneg))\n        _ ‚â§ eLpNorm ({ x | C ‚â§ ‚Äñf (‚Ñê C) x‚Äñ‚Çä }.indicator (f (‚Ñê C))) p Œº := by\n          refine le_eLpNorm_of_bddBelow hp hp' _\n            (measurableSet_le measurable_const (hf _).nnnorm.measurable)\n            (Eventually.of_forall fun x hx => ?_)\n          rwa [nnnorm_indicator_eq_indicator_nnnorm, Set.indicator_of_mem hx]\n        _ ‚â§ eLpNorm (f (‚Ñê C)) p Œº := eLpNorm_indicator_le _\n    specialize this (2 * max M 1 * Œ¥‚Åª¬π ^ (1 / p.toReal))\n    rw [‚Üê ENNReal.coe_rpow_of_nonneg _ (one_div_nonneg.2 ENNReal.toReal_nonneg), ‚Üê ENNReal.coe_smul,\n      smul_eq_mul, mul_assoc, NNReal.inv_rpow,\n      inv_mul_cancel‚ÇÄ (NNReal.rpow_pos (NNReal.coe_pos.1 hŒ¥pos)).ne.symm, mul_one, ENNReal.coe_mul,\n      ‚Üê NNReal.inv_rpow] at this\n    refine (lt_of_le_of_lt (le_trans\n      (hM <| ‚Ñê <| 2 * max M 1 * Œ¥‚Åª¬π ^ (1 / p.toReal)) (le_max_left (M : ‚Ñù‚â•0‚àû) 1))\n        (lt_of_lt_of_le ?_ this)).ne rfl\n    rw [‚Üê ENNReal.coe_one, ‚Üê ENNReal.coe_max, ‚Üê ENNReal.coe_mul, ENNReal.coe_lt_coe]\n    exact lt_two_mul_self (lt_max_of_lt_right one_pos)\n  exact ‚ü®C, fun i => hŒ¥ i _ (measurableSet_le measurable_const (hf i).nnnorm.measurable) (hC i)‚ü©\n\n"}
{"name":"MeasureTheory.UniformIntegrable.spec","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\nhp : Ne p 0\nhp' : Ne p Top.top\nhfu : MeasureTheory.UniformIntegrable f p Œº\nŒµ : Real\nhŒµ : LT.lt 0 Œµ\n‚ä¢ Exists fun C => ‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ)","decl":"theorem UniformIntegrable.spec (hp : p ‚â† 0) (hp' : p ‚â† ‚àû) (hfu : UniformIntegrable f p Œº) {Œµ : ‚Ñù}\n    (hŒµ : 0 < Œµ) :\n    ‚àÉ C : ‚Ñù‚â•0, ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ := by\n  set g : Œπ ‚Üí Œ± ‚Üí Œ≤ := fun i => (hfu.1 i).choose\n  have hgmeas : ‚àÄ i, StronglyMeasurable (g i) := fun i => (Exists.choose_spec <| hfu.1 i).1\n  have hgunif : UniformIntegrable g p Œº := hfu.ae_eq fun i => (Exists.choose_spec <| hfu.1 i).2\n  obtain ‚ü®C, hC‚ü© := hgunif.spec' hp hp' hgmeas hŒµ\n  refine ‚ü®C, fun i => le_trans (le_of_eq <| eLpNorm_congr_ae ?_) (hC i)‚ü©\n  filter_upwards [(Exists.choose_spec <| hfu.1 i).2] with x hx\n  by_cases hfx : x ‚àà { x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }\n  ¬∑ rw [Set.indicator_of_mem hfx, Set.indicator_of_mem, hx]\n    rwa [Set.mem_setOf, hx] at hfx\n  ¬∑ rw [Set.indicator_of_not_mem hfx, Set.indicator_of_not_mem]\n    rwa [Set.mem_setOf, hx] at hfx\n\n"}
{"name":"MeasureTheory.uniformIntegrable_iff","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nŒ≤ : Type u_2\nŒπ : Type u_3\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\ninst‚úù¬π : NormedAddCommGroup Œ≤\np : ENNReal\nf : Œπ ‚Üí Œ± ‚Üí Œ≤\ninst‚úù : MeasureTheory.IsFiniteMeasure Œº\nhp : LE.le 1 p\nhp' : Ne p Top.top\n‚ä¢ Iff (MeasureTheory.UniformIntegrable f p Œº) (And (‚àÄ (i : Œπ), MeasureTheory.AEStronglyMeasurable (f i) Œº) (‚àÄ (Œµ : Real), LT.lt 0 Œµ ‚Üí Exists fun C => ‚àÄ (i : Œπ), LE.le (MeasureTheory.eLpNorm ((setOf fun x => LE.le C (NNNorm.nnnorm (f i x))).indicator (f i)) p Œº) (ENNReal.ofReal Œµ)))","decl":"/-- The definition of uniform integrable in mathlib is equivalent to the definition commonly\nfound in literature. -/\ntheorem uniformIntegrable_iff [IsFiniteMeasure Œº] (hp : 1 ‚â§ p) (hp' : p ‚â† ‚àû) :\n    UniformIntegrable f p Œº ‚Üî\n      (‚àÄ i, AEStronglyMeasurable (f i) Œº) ‚àß\n        ‚àÄ Œµ : ‚Ñù, 0 < Œµ ‚Üí ‚àÉ C : ‚Ñù‚â•0,\n          ‚àÄ i, eLpNorm ({ x | C ‚â§ ‚Äñf i x‚Äñ‚Çä }.indicator (f i)) p Œº ‚â§ ENNReal.ofReal Œµ :=\n  ‚ü®fun h => ‚ü®h.1, fun _ => h.spec (lt_of_lt_of_le zero_lt_one hp).ne.symm hp'‚ü©,\n    fun h => uniformIntegrable_of hp hp' h.1 h.2‚ü©\n\n"}
{"name":"MeasureTheory.uniformIntegrable_average","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nE : Type u_4\ninst‚úù¬π : NormedAddCommGroup E\ninst‚úù : NormedSpace Real E\nhp : LE.le 1 p\nf : Nat ‚Üí Œ± ‚Üí E\nhf : MeasureTheory.UniformIntegrable f p Œº\n‚ä¢ MeasureTheory.UniformIntegrable (fun n => HSMul.hSMul (Inv.inv ‚Üën) ((Finset.range n).sum fun i => f i)) p Œº","decl":"/-- The averaging of a uniformly integrable sequence is also uniformly integrable. -/\ntheorem uniformIntegrable_average\n    {E : Type*} [NormedAddCommGroup E] [NormedSpace ‚Ñù E]\n    (hp : 1 ‚â§ p) {f : ‚Ñï ‚Üí Œ± ‚Üí E} (hf : UniformIntegrable f p Œº) :\n    UniformIntegrable (fun (n : ‚Ñï) => (n : ‚Ñù)‚Åª¬π ‚Ä¢ (‚àë i ‚àà Finset.range n, f i)) p Œº := by\n  obtain ‚ü®hf‚ÇÅ, hf‚ÇÇ, hf‚ÇÉ‚ü© := hf\n  refine ‚ü®fun n => ?_, fun Œµ hŒµ => ?_, ?_‚ü©\n  ¬∑ exact (Finset.aestronglyMeasurable_sum' _ fun i _ => hf‚ÇÅ i).const_smul _\n  ¬∑ obtain ‚ü®Œ¥, hŒ¥‚ÇÅ, hŒ¥‚ÇÇ‚ü© := hf‚ÇÇ hŒµ\n    refine ‚ü®Œ¥, hŒ¥‚ÇÅ, fun n s hs hle => ?_‚ü©\n    simp_rw [Finset.smul_sum, Finset.indicator_sum]\n    refine le_trans (eLpNorm_sum_le (fun i _ => ((hf‚ÇÅ i).const_smul _).indicator hs) hp) ?_\n    have this i : s.indicator ((n : ‚Ñù) ‚Åª¬π ‚Ä¢ f i) = (‚Üën : ‚Ñù)‚Åª¬π ‚Ä¢ s.indicator (f i) :=\n      indicator_const_smul _ _ _\n    obtain rfl | hn := eq_or_ne n 0\n    ¬∑ simp\n    simp_rw [this, eLpNorm_const_smul, ‚Üê Finset.mul_sum]\n    rw [enorm_inv (by positivity), Real.enorm_natCast, ‚Üê ENNReal.div_eq_inv_mul]\n    refine ENNReal.div_le_of_le_mul' ?_\n    simpa using Finset.sum_le_card_nsmul (.range n) _ _ fun i _ => hŒ¥‚ÇÇ _ _ hs hle\n  ¬∑ obtain ‚ü®C, hC‚ü© := hf‚ÇÉ\n    simp_rw [Finset.smul_sum]\n    refine ‚ü®C, fun n => (eLpNorm_sum_le (fun i _ => (hf‚ÇÅ i).const_smul _) hp).trans ?_‚ü©\n    obtain rfl | hn := eq_or_ne n 0\n    ¬∑ simp\n    simp_rw [eLpNorm_const_smul, ‚Üê Finset.mul_sum]\n    rw [enorm_inv (by positivity), Real.enorm_natCast, ‚Üê ENNReal.div_eq_inv_mul]\n    refine ENNReal.div_le_of_le_mul' ?_\n    simpa using Finset.sum_le_card_nsmul (.range n) _ _ fun i _ => hC i\n\n"}
{"name":"MeasureTheory.uniformIntegrable_average_real","module":"Mathlib.MeasureTheory.Function.UniformIntegrable","initialProofState":"Œ± : Type u_1\nm : MeasurableSpace Œ±\nŒº : MeasureTheory.Measure Œ±\np : ENNReal\nhp : LE.le 1 p\nf : Nat ‚Üí Œ± ‚Üí Real\nhf : MeasureTheory.UniformIntegrable f p Œº\n‚ä¢ MeasureTheory.UniformIntegrable (fun n => HDiv.hDiv ((Finset.range n).sum fun i => f i) ‚Üën) p Œº","decl":"/-- The averaging of a uniformly integrable real-valued sequence is also uniformly integrable. -/\ntheorem uniformIntegrable_average_real (hp : 1 ‚â§ p) {f : ‚Ñï ‚Üí Œ± ‚Üí ‚Ñù} (hf : UniformIntegrable f p Œº) :\n    UniformIntegrable (fun n => (‚àë i ‚àà Finset.range n, f i) / (n : Œ± ‚Üí ‚Ñù)) p Œº := by\n  convert uniformIntegrable_average hp hf using 2 with n\n  ext x\n  simp [div_eq_inv_mul]\n\n"}
