{"name":"WittVector.bind‚ÇÅ_frobeniusPolyRat_wittPolynomial","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.bind‚ÇÅ (WittVector.frobeniusPolyRat p)) (wittPolynomial p Rat n)) (wittPolynomial p Rat (HAdd.hAdd n 1))","decl":"theorem bind‚ÇÅ_frobeniusPolyRat_wittPolynomial (n : ‚Ñï) :\n    bind‚ÇÅ (frobeniusPolyRat p) (wittPolynomial p ‚Ñö n) = wittPolynomial p ‚Ñö (n + 1) := by\n  delta frobeniusPolyRat\n  rw [‚Üê bind‚ÇÅ_bind‚ÇÅ, bind‚ÇÅ_xInTermsOfW_wittPolynomial, bind‚ÇÅ_X_right, Function.comp_apply]\n\n"}
{"name":"WittVector.frobeniusPolyAux_eq","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p n : Nat\n‚ä¢ Eq (WittVector.frobeniusPolyAux p n) (HSub.hSub (MvPolynomial.X (HAdd.hAdd n 1)) ((Finset.range n).sum fun i => (Finset.range (HPow.hPow p (HSub.hSub n i))).sum fun j => HMul.hMul (HMul.hMul (HPow.hPow (HPow.hPow (MvPolynomial.X i) p) (HSub.hSub (HPow.hPow p (HSub.hSub n i)) (HAdd.hAdd j 1))) (HPow.hPow (WittVector.frobeniusPolyAux p i) (HAdd.hAdd j 1))) (MvPolynomial.C ‚Üë(HMul.hMul (HDiv.hDiv ((HPow.hPow p (HSub.hSub n i)).choose (HAdd.hAdd j 1)) (HPow.hPow p (HSub.hSub (HSub.hSub n i) (multiplicity p (HAdd.hAdd j 1))))) (HPow.hPow p (HSub.hSub j (multiplicity p (HAdd.hAdd j 1))))))))","decl":"omit hp in\ntheorem frobeniusPolyAux_eq (n : ‚Ñï) :\n    frobeniusPolyAux p n =\n      X (n + 1) - ‚àë i ‚àà range n,\n          ‚àë j ‚àà range (p ^ (n - i)),\n            (X i ^ p) ^ (p ^ (n - i) - (j + 1)) * frobeniusPolyAux p i ^ (j + 1) *\n              C ‚Üë((p ^ (n - i)).choose (j + 1) / p ^ (n - i - v p (j + 1)) *\n                ‚Üëp ^ (j - v p (j + 1)) : ‚Ñï) := by\n  rw [frobeniusPolyAux, ‚Üê Fin.sum_univ_eq_sum_range]\n\n"}
{"name":"WittVector.map_frobeniusPoly.key‚ÇÅ","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn j : Nat\nhj : LT.lt j (HPow.hPow p n)\n‚ä¢ Dvd.dvd (HPow.hPow p (HSub.hSub n (multiplicity p (HAdd.hAdd j 1)))) ((HPow.hPow p n).choose (HAdd.hAdd j 1))","decl":"/-- A key divisibility fact for the proof of `WittVector.map_frobeniusPoly`. -/\ntheorem map_frobeniusPoly.key‚ÇÅ (n j : ‚Ñï) (hj : j < p ^ n) :\n    p ^ (n - v p (j + 1)) ‚à£ (p ^ n).choose (j + 1) := by\n  apply pow_dvd_of_le_emultiplicity\n  rw [hp.out.emultiplicity_choose_prime_pow hj j.succ_ne_zero]\n\n"}
{"name":"WittVector.map_frobeniusPoly.key‚ÇÇ","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn i j : Nat\nhi : LE.le i n\nhj : LT.lt j (HPow.hPow p (HSub.hSub n i))\n‚ä¢ Eq (HAdd.hAdd (HSub.hSub j (multiplicity p (HAdd.hAdd j 1))) n) (HAdd.hAdd (HAdd.hAdd i j) (HSub.hSub (HSub.hSub n i) (multiplicity p (HAdd.hAdd j 1))))","decl":"/-- A key numerical identity needed for the proof of `WittVector.map_frobeniusPoly`. -/\ntheorem map_frobeniusPoly.key‚ÇÇ {n i j : ‚Ñï} (hi : i ‚â§ n) (hj : j < p ^ (n - i)) :\n    j - v p (j + 1) + n = i + j + (n - i - v p (j + 1)) := by\n  generalize h : v p (j + 1) = m\n  rsuffices ‚ü®h‚ÇÅ, h‚ÇÇ‚ü© : m ‚â§ n - i ‚àß m ‚â§ j\n  ¬∑ rw [tsub_add_eq_add_tsub h‚ÇÇ, add_comm i j, add_tsub_assoc_of_le (h‚ÇÅ.trans (Nat.sub_le n i)),\n      add_assoc, tsub_right_comm, add_comm i,\n      tsub_add_cancel_of_le (le_tsub_of_add_le_right ((le_tsub_iff_left hi).mp h‚ÇÅ))]\n  have hle : p ^ m ‚â§ j + 1 := h ‚ñ∏ Nat.le_of_dvd j.succ_pos (pow_multiplicity_dvd _ _)\n  exact ‚ü®(Nat.pow_le_pow_iff_right hp.1.one_lt).1 (hle.trans hj),\n     Nat.le_of_lt_succ ((m.lt_pow_self hp.1.one_lt).trans_le hle)‚ü©\n\n"}
{"name":"WittVector.map_frobeniusPoly","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.map (Int.castRingHom Rat)) (WittVector.frobeniusPoly p n)) (WittVector.frobeniusPolyRat p n)","decl":"theorem map_frobeniusPoly (n : ‚Ñï) :\n    MvPolynomial.map (Int.castRingHom ‚Ñö) (frobeniusPoly p n) = frobeniusPolyRat p n := by\n  rw [frobeniusPoly, RingHom.map_add, RingHom.map_mul, RingHom.map_pow, map_C, map_X, eq_intCast,\n    Int.cast_natCast, frobeniusPolyRat]\n  refine Nat.strong_induction_on n ?_; clear n\n  intro n IH\n  rw [xInTermsOfW_eq]\n  simp only [map_sum, map_sub, map_mul, map_pow (bind‚ÇÅ _), bind‚ÇÅ_C_right]\n  have h1 : (p : ‚Ñö) ^ n * ‚Öü (p : ‚Ñö) ^ n = 1 := by rw [‚Üê mul_pow, mul_invOf_self, one_pow]\n  rw [bind‚ÇÅ_X_right, Function.comp_apply, wittPolynomial_eq_sum_C_mul_X_pow, sum_range_succ,\n    sum_range_succ, tsub_self, add_tsub_cancel_left, pow_zero, pow_one, pow_one, sub_mul, add_mul,\n    add_mul, mul_right_comm, mul_right_comm (C ((p : ‚Ñö) ^ (n + 1))), ‚Üê C_mul, ‚Üê C_mul, pow_succ',\n    mul_assoc (p : ‚Ñö) ((p : ‚Ñö) ^ n), h1, mul_one, C_1, one_mul, add_comm _ (X n ^ p), add_assoc,\n    ‚Üê add_sub, add_right_inj, frobeniusPolyAux_eq, RingHom.map_sub, map_X, mul_sub, sub_eq_add_neg,\n    add_comm _ (C (p : ‚Ñö) * X (n + 1)), ‚Üê add_sub,\n    add_right_inj, neg_eq_iff_eq_neg, neg_sub, eq_comm]\n  simp only [map_sum, mul_sum, sum_mul, ‚Üê sum_sub_distrib]\n  apply sum_congr rfl\n  intro i hi\n  rw [mem_range] at hi\n  rw [‚Üê IH i hi]\n  clear IH\n  rw [add_comm (X i ^ p), add_pow, sum_range_succ', pow_zero, tsub_zero, Nat.choose_zero_right,\n    one_mul, Nat.cast_one, mul_one, mul_add, add_mul, Nat.succ_sub (le_of_lt hi),\n    Nat.succ_eq_add_one (n - i), pow_succ', pow_mul, add_sub_cancel_right, mul_sum, sum_mul]\n  apply sum_congr rfl\n  intro j hj\n  rw [mem_range] at hj\n  rw [RingHom.map_mul, RingHom.map_mul, RingHom.map_pow, RingHom.map_pow, RingHom.map_pow,\n    RingHom.map_pow, RingHom.map_pow, map_C, map_X, mul_pow]\n  rw [mul_comm (C (p : ‚Ñö) ^ i), mul_comm _ ((X i ^ p) ^ _), mul_comm (C (p : ‚Ñö) ^ (j + 1)),\n    mul_comm (C (p : ‚Ñö))]\n  simp only [mul_assoc]\n  apply congr_arg\n  apply congr_arg\n  rw [‚Üê C_eq_coe_nat]\n  simp only [‚Üê RingHom.map_pow, ‚Üê C_mul]\n  rw [C_inj]\n  simp only [invOf_eq_inv, eq_intCast, inv_pow, Int.cast_natCast, Nat.cast_mul, Int.cast_mul]\n  rw [Rat.natCast_div _ _ (map_frobeniusPoly.key‚ÇÅ p (n - i) j hj)]\n  simp only [Nat.cast_pow, pow_add, pow_one]\n  suffices\n    (((p ^ (n - i)).choose (j + 1) : ‚Ñö) * (p : ‚Ñö) ^ (j - v p (j + 1)) * p * (p ^ n : ‚Ñö))\n      = (p : ‚Ñö) ^ j * p * ‚Üë((p ^ (n - i)).choose (j + 1) * p ^ i) *\n        (p : ‚Ñö) ^ (n - i - v p (j + 1)) by\n    have aux : ‚àÄ k : ‚Ñï, (p : ‚Ñö)^ k ‚â† 0 := by\n      intro; apply pow_ne_zero; exact mod_cast hp.1.ne_zero\n    simpa [aux, -one_div, -pow_eq_zero_iff', field_simps] using this.symm\n  rw [mul_comm _ (p : ‚Ñö), mul_assoc, mul_assoc, ‚Üê pow_add,\n    map_frobeniusPoly.key‚ÇÇ p hi.le hj, Nat.cast_mul, Nat.cast_pow]\n  ring\n\n"}
{"name":"WittVector.frobeniusPoly_zmod","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.map (Int.castRingHom (ZMod p))) (WittVector.frobeniusPoly p n)) (HPow.hPow (MvPolynomial.X n) p)","decl":"theorem frobeniusPoly_zmod (n : ‚Ñï) :\n    MvPolynomial.map (Int.castRingHom (ZMod p)) (frobeniusPoly p n) = X n ^ p := by\n  rw [frobeniusPoly, RingHom.map_add, RingHom.map_pow, RingHom.map_mul, map_X, map_C]\n  simp only [Int.cast_natCast, add_zero, eq_intCast, ZMod.natCast_self, zero_mul, C_0]\n\n"}
{"name":"WittVector.bind‚ÇÅ_frobeniusPoly_wittPolynomial","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nn : Nat\n‚ä¢ Eq ((MvPolynomial.bind‚ÇÅ (WittVector.frobeniusPoly p)) (wittPolynomial p Int n)) (wittPolynomial p Int (HAdd.hAdd n 1))","decl":"@[simp]\ntheorem bind‚ÇÅ_frobeniusPoly_wittPolynomial (n : ‚Ñï) :\n    bind‚ÇÅ (frobeniusPoly p) (wittPolynomial p ‚Ñ§ n) = wittPolynomial p ‚Ñ§ (n + 1) := by\n  apply MvPolynomial.map_injective (Int.castRingHom ‚Ñö) Int.cast_injective\n  simp only [map_bind‚ÇÅ, map_frobeniusPoly, bind‚ÇÅ_frobeniusPolyRat_wittPolynomial,\n    map_wittPolynomial]\n\n"}
{"name":"WittVector.coeff_frobeniusFun","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\ninst‚úù : CommRing R\nx : WittVector p R\nn : Nat\n‚ä¢ Eq (x.frobeniusFun.coeff n) ((MvPolynomial.aeval x.coeff) (WittVector.frobeniusPoly p n))","decl":"omit hp in\ntheorem coeff_frobeniusFun (x : ùïé R) (n : ‚Ñï) :\n    coeff (frobeniusFun x) n = MvPolynomial.aeval x.coeff (frobeniusPoly p n) := by\n  rw [frobeniusFun, coeff_mk]\n\n"}
{"name":"WittVector.frobeniusFun_isPoly","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\n‚ä¢ WittVector.IsPoly p fun R x Rcr => Rcr.frobeniusFun","decl":"/-- `frobeniusFun` is tautologically a polynomial function.\n\nSee also `frobenius_isPoly`. -/\n-- Porting note: replaced `@[is_poly]` with `instance`.\ninstance frobeniusFun_isPoly : IsPoly p fun R _ Rcr => @frobeniusFun p R _ Rcr :=\n  ‚ü®‚ü®frobeniusPoly p, by intros; funext n; apply coeff_frobeniusFun‚ü©‚ü©\n\n"}
{"name":"WittVector.ghostComponent_frobeniusFun","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nn : Nat\nx : WittVector p R\n‚ä¢ Eq ((WittVector.ghostComponent n) x.frobeniusFun) ((WittVector.ghostComponent (HAdd.hAdd n 1)) x)","decl":"@[ghost_simps]\ntheorem ghostComponent_frobeniusFun (n : ‚Ñï) (x : ùïé R) :\n    ghostComponent n (frobeniusFun x) = ghostComponent (n + 1) x := by\n  simp only [ghostComponent_apply, frobeniusFun, coeff_mk, ‚Üê bind‚ÇÅ_frobeniusPoly_wittPolynomial,\n    aeval_bind‚ÇÅ]\n\n"}
{"name":"WittVector.coeff_frobenius","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((WittVector.frobenius x).coeff n) ((MvPolynomial.aeval x.coeff) (WittVector.frobeniusPoly p n))","decl":"theorem coeff_frobenius (x : ùïé R) (n : ‚Ñï) :\n    coeff (frobenius x) n = MvPolynomial.aeval x.coeff (frobeniusPoly p n) :=\n  coeff_frobeniusFun _ _\n\n"}
{"name":"WittVector.ghostComponent_frobenius","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù : CommRing R\nn : Nat\nx : WittVector p R\n‚ä¢ Eq ((WittVector.ghostComponent n) (WittVector.frobenius x)) ((WittVector.ghostComponent (HAdd.hAdd n 1)) x)","decl":"@[ghost_simps]\ntheorem ghostComponent_frobenius (n : ‚Ñï) (x : ùïé R) :\n    ghostComponent n (frobenius x) = ghostComponent (n + 1) x :=\n  ghostComponent_frobeniusFun _ _\n\n"}
{"name":"WittVector.frobenius_isPoly","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\n‚ä¢ WittVector.IsPoly p fun R _Rcr => ‚áëWittVector.frobenius","decl":"/-- `frobenius` is tautologically a polynomial function. -/\n-- Porting note: replaced `@[is_poly]` with `instance`.\ninstance frobenius_isPoly : IsPoly p fun R _Rcr => @frobenius p R _ _Rcr :=\n  frobeniusFun_isPoly _\n\n"}
{"name":"WittVector.coeff_frobenius_charP","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù¬π : CommRing R\ninst‚úù : CharP R p\nx : WittVector p R\nn : Nat\n‚ä¢ Eq ((WittVector.frobenius x).coeff n) (HPow.hPow (x.coeff n) p)","decl":"@[simp]\ntheorem coeff_frobenius_charP (x : ùïé R) (n : ‚Ñï) : coeff (frobenius x) n = x.coeff n ^ p := by\n  rw [coeff_frobenius]\n  letI : Algebra (ZMod p) R := ZMod.algebra _ _\n  -- outline of the calculation, proofs follow below\n  calc\n    aeval (fun k => x.coeff k) (frobeniusPoly p n) =\n        aeval (fun k => x.coeff k)\n          (MvPolynomial.map (Int.castRingHom (ZMod p)) (frobeniusPoly p n)) := ?_\n    _ = aeval (fun k => x.coeff k) (X n ^ p : MvPolynomial ‚Ñï (ZMod p)) := ?_\n    _ = x.coeff n ^ p := ?_\n  ¬∑ conv_rhs => rw [aeval_eq_eval‚ÇÇHom, eval‚ÇÇHom_map_hom]\n    apply eval‚ÇÇHom_congr (RingHom.ext_int _ _) rfl rfl\n  ¬∑ rw [frobeniusPoly_zmod]\n  ¬∑ rw [map_pow, aeval_X]\n\n"}
{"name":"WittVector.frobenius_eq_map_frobenius","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù¬π : CommRing R\ninst‚úù : CharP R p\n‚ä¢ Eq WittVector.frobenius (WittVector.map (frobenius R p))","decl":"theorem frobenius_eq_map_frobenius : @frobenius p R _ _ = map (_root_.frobenius R p) := by\n  ext (x n)\n  simp only [coeff_frobenius_charP, map_coeff, frobenius_def]\n\n"}
{"name":"WittVector.frobenius_zmodp","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nhp : Fact (Nat.Prime p)\nx : WittVector p (ZMod p)\n‚ä¢ Eq (WittVector.frobenius x) x","decl":"@[simp]\ntheorem frobenius_zmodp (x : ùïé (ZMod p)) : frobenius x = x := by\n  simp only [WittVector.ext_iff, coeff_frobenius_charP, ZMod.pow_card, eq_self_iff_true,\n    forall_const]\n\n"}
{"name":"WittVector.frobeniusEquiv_symm_apply","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CharP R p\ninst‚úù : PerfectRing R p\n‚ä¢ Eq ‚áë(WittVector.frobeniusEquiv p R).symm ‚áë(WittVector.map ‚Üë(frobeniusEquiv R p).symm)","decl":"/-- `WittVector.frobenius` as an equiv. -/\n@[simps (config := .asFn)]\ndef frobeniusEquiv [PerfectRing R p] : WittVector p R ‚âÉ+* WittVector p R :=\n  { (WittVector.frobenius : WittVector p R ‚Üí+* WittVector p R) with\n    toFun := WittVector.frobenius\n    invFun := map (_root_.frobeniusEquiv R p).symm\n    left_inv := fun f => ext fun n => by\n      rw [frobenius_eq_map_frobenius]\n      exact frobeniusEquiv_symm_apply_frobenius R p _\n    right_inv := fun f => ext fun n => by\n      rw [frobenius_eq_map_frobenius]\n      exact frobenius_apply_frobeniusEquiv_symm R p _ }\n\n"}
{"name":"WittVector.frobeniusEquiv_apply","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CharP R p\ninst‚úù : PerfectRing R p\n‚ä¢ Eq ‚áë(WittVector.frobeniusEquiv p R) ‚áëWittVector.frobenius","decl":"/-- `WittVector.frobenius` as an equiv. -/\n@[simps (config := .asFn)]\ndef frobeniusEquiv [PerfectRing R p] : WittVector p R ‚âÉ+* WittVector p R :=\n  { (WittVector.frobenius : WittVector p R ‚Üí+* WittVector p R) with\n    toFun := WittVector.frobenius\n    invFun := map (_root_.frobeniusEquiv R p).symm\n    left_inv := fun f => ext fun n => by\n      rw [frobenius_eq_map_frobenius]\n      exact frobeniusEquiv_symm_apply_frobenius R p _\n    right_inv := fun f => ext fun n => by\n      rw [frobenius_eq_map_frobenius]\n      exact frobenius_apply_frobeniusEquiv_symm R p _ }\n\n"}
{"name":"WittVector.frobenius_bijective","module":"Mathlib.RingTheory.WittVector.Frobenius","initialProofState":"p : Nat\nR : Type u_1\nhp : Fact (Nat.Prime p)\ninst‚úù¬≤ : CommRing R\ninst‚úù¬π : CharP R p\ninst‚úù : PerfectRing R p\n‚ä¢ Function.Bijective ‚áëWittVector.frobenius","decl":"theorem frobenius_bijective [PerfectRing R p] :\n    Function.Bijective (@WittVector.frobenius p R _ _) :=\n  (frobeniusEquiv p R).bijective\n\n"}
