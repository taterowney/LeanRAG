{"name":"LieSubalgebra.mk.injEq","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ntoSubmodule✝ : Submodule R L\nlie_mem'✝ : ∀ {x y : L}, Membership.mem toSubmodule✝.carrier x → Membership.mem toSubmodule✝.carrier y → Membership.mem toSubmodule✝.carrier (Bracket.bracket x y)\ntoSubmodule : Submodule R L\nlie_mem' : ∀ {x y : L}, Membership.mem toSubmodule.carrier x → Membership.mem toSubmodule.carrier y → Membership.mem toSubmodule.carrier (Bracket.bracket x y)\n⊢ Eq (Eq { toSubmodule := toSubmodule✝, lie_mem' := lie_mem'✝ } { toSubmodule := toSubmodule, lie_mem' := lie_mem' }) (Eq toSubmodule✝ toSubmodule)","decl":"/-- A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie algebra. -/\nstructure LieSubalgebra extends Submodule R L where\n  /-- A Lie subalgebra is closed under Lie bracket. -/\n  lie_mem' : ∀ {x y}, x ∈ carrier → y ∈ carrier → ⁅x, y⁆ ∈ carrier\n\n"}
{"name":"LieSubalgebra.mk.sizeOf_spec","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\ninst✝¹ : SizeOf R\ninst✝ : SizeOf L\ntoSubmodule : Submodule R L\nlie_mem' : ∀ {x y : L}, Membership.mem toSubmodule.carrier x → Membership.mem toSubmodule.carrier y → Membership.mem toSubmodule.carrier (Bracket.bracket x y)\n⊢ Eq (SizeOf.sizeOf { toSubmodule := toSubmodule, lie_mem' := lie_mem' }) (HAdd.hAdd 1 (SizeOf.sizeOf toSubmodule))","decl":"/-- A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie algebra. -/\nstructure LieSubalgebra extends Submodule R L where\n  /-- A Lie subalgebra is closed under Lie bracket. -/\n  lie_mem' : ∀ {x y}, x ∈ carrier → y ∈ carrier → ⁅x, y⁆ ∈ carrier\n\n"}
{"name":"LieSubalgebra.mk.inj","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ntoSubmodule✝ : Submodule R L\nlie_mem'✝ : ∀ {x y : L}, Membership.mem toSubmodule✝.carrier x → Membership.mem toSubmodule✝.carrier y → Membership.mem toSubmodule✝.carrier (Bracket.bracket x y)\ntoSubmodule : Submodule R L\nlie_mem' : ∀ {x y : L}, Membership.mem toSubmodule.carrier x → Membership.mem toSubmodule.carrier y → Membership.mem toSubmodule.carrier (Bracket.bracket x y)\nx✝ : Eq { toSubmodule := toSubmodule✝, lie_mem' := lie_mem'✝ } { toSubmodule := toSubmodule, lie_mem' := lie_mem' }\n⊢ Eq toSubmodule✝ toSubmodule","decl":"/-- A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie algebra. -/\nstructure LieSubalgebra extends Submodule R L where\n  /-- A Lie subalgebra is closed under Lie bracket. -/\n  lie_mem' : ∀ {x y}, x ∈ carrier → y ∈ carrier → ⁅x, y⁆ ∈ carrier\n\n"}
{"name":"LieSubalgebra.lie_mem'","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nself : LieSubalgebra R L\nx y : L\na✝¹ : Membership.mem self.carrier x\na✝ : Membership.mem self.carrier y\n⊢ Membership.mem self.carrier (Bracket.bracket x y)","decl":"/-- A Lie subalgebra of a Lie algebra is submodule that is closed under the Lie bracket.\nThis is a sufficient condition for the subset itself to form a Lie algebra. -/\nstructure LieSubalgebra extends Submodule R L where\n  /-- A Lie subalgebra is closed under Lie bracket. -/\n  lie_mem' : ∀ {x y}, x ∈ carrier → y ∈ carrier → ⁅x, y⁆ ∈ carrier\n\n"}
{"name":"LieSubalgebra.instAddSubgroupClass","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ AddSubgroupClass (LieSubalgebra R L) L","decl":"instance : AddSubgroupClass (LieSubalgebra R L) L where\n  add_mem := Submodule.add_mem _\n  zero_mem L' := L'.zero_mem'\n  neg_mem {L'} x hx := show -x ∈ (L' : Submodule R L) from neg_mem hx\n\n"}
{"name":"LieSubalgebra.instIsCentralScalarSubtypeMem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nR₁ : Type u_1\ninst✝⁷ : Semiring R₁\ninst✝⁶ : SMul R₁ R\ninst✝⁵ : SMul (MulOpposite R₁) R\ninst✝⁴ : Module R₁ L\ninst✝³ : Module (MulOpposite R₁) L\ninst✝² : IsScalarTower R₁ R L\ninst✝¹ : IsScalarTower (MulOpposite R₁) R L\ninst✝ : IsCentralScalar R₁ L\nL' : LieSubalgebra R L\n⊢ IsCentralScalar R₁ (Subtype fun x => Membership.mem L' x)","decl":"instance [SMul R₁ R] [SMul R₁ᵐᵒᵖ R] [Module R₁ L] [Module R₁ᵐᵒᵖ L] [IsScalarTower R₁ R L]\n    [IsScalarTower R₁ᵐᵒᵖ R L] [IsCentralScalar R₁ L] (L' : LieSubalgebra R L) :\n    IsCentralScalar R₁ L' :=\n  L'.toSubmodule.isCentralScalar\n\n"}
{"name":"LieSubalgebra.instIsScalarTowerSubtypeMem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\nR₁ : Type u_1\ninst✝³ : Semiring R₁\ninst✝² : SMul R₁ R\ninst✝¹ : Module R₁ L\ninst✝ : IsScalarTower R₁ R L\nL' : LieSubalgebra R L\n⊢ IsScalarTower R₁ R (Subtype fun x => Membership.mem L' x)","decl":"instance [SMul R₁ R] [Module R₁ L] [IsScalarTower R₁ R L] (L' : LieSubalgebra R L) :\n    IsScalarTower R₁ R L' :=\n  L'.toSubmodule.isScalarTower\n\n"}
{"name":"LieSubalgebra.instIsNoetherianSubtypeMem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nL' : LieSubalgebra R L\ninst✝ : IsNoetherian R L\n⊢ IsNoetherian R (Subtype fun x => Membership.mem L' x)","decl":"instance (L' : LieSubalgebra R L) [IsNoetherian R L] : IsNoetherian R L' :=\n  isNoetherian_submodule' _\n\n"}
{"name":"LieSubalgebra.instIsArtinianSubtypeMem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\nL' : LieSubalgebra R L\ninst✝ : IsArtinian R L\n⊢ IsArtinian R (Subtype fun x => Membership.mem L' x)","decl":"instance (L' : LieSubalgebra R L) [IsArtinian R L] : IsArtinian R L' :=\n  isArtinian_submodule' _\n\n"}
{"name":"LieSubalgebra.zero_mem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\n⊢ Membership.mem L' 0","decl":"@[simp]\nprotected theorem zero_mem : (0 : L) ∈ L' :=\n  zero_mem L'\n\n"}
{"name":"LieSubalgebra.add_mem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx y : L\na✝¹ : Membership.mem L' x\na✝ : Membership.mem L' y\n⊢ Membership.mem L' (HAdd.hAdd x y)","decl":"protected theorem add_mem {x y : L} : x ∈ L' → y ∈ L' → (x + y : L) ∈ L' :=\n  add_mem\n\n"}
{"name":"LieSubalgebra.sub_mem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx y : L\na✝¹ : Membership.mem L' x\na✝ : Membership.mem L' y\n⊢ Membership.mem L' (HSub.hSub x y)","decl":"protected theorem sub_mem {x y : L} : x ∈ L' → y ∈ L' → (x - y : L) ∈ L' :=\n  sub_mem\n\n"}
{"name":"LieSubalgebra.smul_mem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nt : R\nx : L\nh : Membership.mem L' x\n⊢ Membership.mem L' (HSMul.hSMul t x)","decl":"theorem smul_mem (t : R) {x : L} (h : x ∈ L') : t • x ∈ L' :=\n  (L' : Submodule R L).smul_mem t h\n\n"}
{"name":"LieSubalgebra.lie_mem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx y : L\nhx : Membership.mem L' x\nhy : Membership.mem L' y\n⊢ Membership.mem L' (Bracket.bracket x y)","decl":"theorem lie_mem {x y : L} (hx : x ∈ L') (hy : y ∈ L') : (⁅x, y⁆ : L) ∈ L' :=\n  L'.lie_mem' hx hy\n\n"}
{"name":"LieSubalgebra.mem_carrier","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem L'.carrier x) (Membership.mem (↑L') x)","decl":"theorem mem_carrier {x : L} : x ∈ L'.carrier ↔ x ∈ (L' : Set L) :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.mem_mk_iff","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nS : Set L\nh₁ : ∀ {a b : L}, Membership.mem S a → Membership.mem S b → Membership.mem S (HAdd.hAdd a b)\nh₂ : S 0\nh₃ : ∀ (c : R) {x : L}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier x → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier (HSMul.hSMul c x)\nh₄ : ∀ {x y : L}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier x → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier y → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier (Bracket.bracket x y)\nx : L\n⊢ Iff (Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃, lie_mem' := h₄ } x) (Membership.mem S x)","decl":"@[simp]\ntheorem mem_mk_iff (S : Set L) (h₁ h₂ h₃ h₄) {x : L} :\n    x ∈ (⟨⟨⟨⟨S, h₁⟩, h₂⟩, h₃⟩, h₄⟩ : LieSubalgebra R L) ↔ x ∈ S :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.mem_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem L'.toSubmodule x) (Membership.mem L' x)","decl":"@[simp]\ntheorem mem_toSubmodule {x : L} : x ∈ (L' : Submodule R L) ↔ x ∈ L' :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.mem_coe_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem L'.toSubmodule x) (Membership.mem L' x)","decl":"@[deprecated (since := \"2024-12-30\")] alias mem_coe_submodule := mem_toSubmodule\n\n"}
{"name":"LieSubalgebra.mem_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem (↑L') x) (Membership.mem L' x)","decl":"theorem mem_coe {x : L} : x ∈ (L' : Set L) ↔ x ∈ L' :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.coe_bracket","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx y : Subtype fun x => Membership.mem L' x\n⊢ Eq (↑(Bracket.bracket x y)) (Bracket.bracket ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_bracket (x y : L') : (↑⁅x, y⁆ : L) = ⁅(↑x : L), ↑y⁆ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.ext_iff","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx y : Subtype fun x => Membership.mem L' x\n⊢ Iff (Eq x y) (Eq ↑x ↑y)","decl":"theorem ext_iff (x y : L') : x = y ↔ (x : L) = y :=\n  Subtype.ext_iff\n\n"}
{"name":"LieSubalgebra.coe_zero_iff_zero","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\nx : Subtype fun x => Membership.mem L' x\n⊢ Iff (Eq (↑x) 0) (Eq x 0)","decl":"theorem coe_zero_iff_zero (x : L') : (x : L) = 0 ↔ x = 0 :=\n  (ext_iff L' x 0).symm\n\n"}
{"name":"LieSubalgebra.ext","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL₁' L₂' : LieSubalgebra R L\nh : ∀ (x : L), Iff (Membership.mem L₁' x) (Membership.mem L₂' x)\n⊢ Eq L₁' L₂'","decl":"@[ext]\ntheorem ext (L₁' L₂' : LieSubalgebra R L) (h : ∀ x, x ∈ L₁' ↔ x ∈ L₂') : L₁' = L₂' :=\n  SetLike.ext h\n\n"}
{"name":"LieSubalgebra.ext_iff'","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL₁' L₂' : LieSubalgebra R L\n⊢ Iff (Eq L₁' L₂') (∀ (x : L), Iff (Membership.mem L₁' x) (Membership.mem L₂' x))","decl":"theorem ext_iff' (L₁' L₂' : LieSubalgebra R L) : L₁' = L₂' ↔ ∀ x, x ∈ L₁' ↔ x ∈ L₂' :=\n  SetLike.ext_iff\n\n"}
{"name":"LieSubalgebra.mk_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nS : Set L\nh₁ : ∀ {a b : L}, Membership.mem S a → Membership.mem S b → Membership.mem S (HAdd.hAdd a b)\nh₂ : S 0\nh₃ : ∀ (c : R) {x : L}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier x → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂ }.carrier (HSMul.hSMul c x)\nh₄ : ∀ {x y : L}, Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier x → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier y → Membership.mem { carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃ }.carrier (Bracket.bracket x y)\n⊢ Eq (↑{ carrier := S, add_mem' := h₁, zero_mem' := h₂, smul_mem' := h₃, lie_mem' := h₄ }) S","decl":"@[simp]\ntheorem mk_coe (S : Set L) (h₁ h₂ h₃ h₄) :\n    ((⟨⟨⟨⟨S, h₁⟩, h₂⟩, h₃⟩, h₄⟩ : LieSubalgebra R L) : Set L) = S :=\n  rfl\n\n"}
{"name":"LieSubalgebra.toSubmodule_mk","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\np : Submodule R L\nh : ∀ {x y : L}, Membership.mem p.carrier x → Membership.mem p.carrier y → Membership.mem p.carrier (Bracket.bracket x y)\n⊢ Eq { toSubmodule := p, lie_mem' := h }.toSubmodule p","decl":"theorem toSubmodule_mk (p : Submodule R L) (h) :\n    (({ p with lie_mem' := h } : LieSubalgebra R L) : Submodule R L) = p := by\n  cases p\n  rfl\n\n"}
{"name":"LieSubalgebra.coe_to_submodule_mk","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\np : Submodule R L\nh : ∀ {x y : L}, Membership.mem p.carrier x → Membership.mem p.carrier y → Membership.mem p.carrier (Bracket.bracket x y)\n⊢ Eq { toSubmodule := p, lie_mem' := h }.toSubmodule p","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_submodule_mk := toSubmodule_mk\n\n"}
{"name":"LieSubalgebra.coe_injective","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Function.Injective SetLike.coe","decl":"theorem coe_injective : Function.Injective ((↑) : LieSubalgebra R L → Set L) :=\n  SetLike.coe_injective\n\n"}
{"name":"LieSubalgebra.coe_set_eq","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL₁' L₂' : LieSubalgebra R L\n⊢ Iff (Eq ↑L₁' ↑L₂') (Eq L₁' L₂')","decl":"@[norm_cast]\ntheorem coe_set_eq (L₁' L₂' : LieSubalgebra R L) : (L₁' : Set L) = L₂' ↔ L₁' = L₂' :=\n  SetLike.coe_set_eq\n\n"}
{"name":"LieSubalgebra.toSubmodule_injective","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Function.Injective LieSubalgebra.toSubmodule","decl":"theorem toSubmodule_injective : Function.Injective ((↑) : LieSubalgebra R L → Submodule R L) :=\n  fun L₁' L₂' h ↦ by\n  rw [SetLike.ext'_iff] at h\n  rw [← coe_set_eq]\n  exact h\n\n"}
{"name":"LieSubalgebra.to_submodule_injective","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Function.Injective LieSubalgebra.toSubmodule","decl":"@[deprecated (since := \"2024-12-30\")] alias to_submodule_injective := toSubmodule_injective\n\n"}
{"name":"LieSubalgebra.toSubmodule_inj","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL₁' L₂' : LieSubalgebra R L\n⊢ Iff (Eq L₁'.toSubmodule L₂'.toSubmodule) (Eq L₁' L₂')","decl":"@[simp]\ntheorem toSubmodule_inj (L₁' L₂' : LieSubalgebra R L) :\n    (L₁' : Submodule R L) = (L₂' : Submodule R L) ↔ L₁' = L₂' :=\n  toSubmodule_injective.eq_iff\n\n"}
{"name":"LieSubalgebra.coe_to_submodule_inj","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL₁' L₂' : LieSubalgebra R L\n⊢ Iff (Eq L₁'.toSubmodule L₂'.toSubmodule) (Eq L₁' L₂')","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_submodule_inj := toSubmodule_inj\n\n"}
{"name":"LieSubalgebra.toSubmodule_eq_iff","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL₁' L₂' : LieSubalgebra R L\n⊢ Iff (Eq L₁'.toSubmodule L₂'.toSubmodule) (Eq L₁' L₂')","decl":"@[deprecated (since := \"2024-12-29\")] alias toSubmodule_eq_iff := toSubmodule_inj\n\n"}
{"name":"LieSubalgebra.coe_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\n⊢ Eq ↑L'.toSubmodule ↑L'","decl":"theorem coe_toSubmodule : ((L' : Submodule R L) : Set L) = L' :=\n  rfl\n\n"}
{"name":"LieSubalgebra.coe_to_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\n⊢ Eq ↑L'.toSubmodule ↑L'","decl":"@[deprecated (since := \"2024-12-30\")] alias coe_to_submodule := coe_toSubmodule\n\n"}
{"name":"LieSubalgebra.coe_bracket_of_module","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL' : LieSubalgebra R L\nM : Type w\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\nx : Subtype fun x => Membership.mem L' x\nm : M\n⊢ Eq (Bracket.bracket x m) (Bracket.bracket (↑x) m)","decl":"@[simp]\ntheorem coe_bracket_of_module (x : L') (m : M) : ⁅x, m⁆ = ⁅(x : L), m⁆ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.instIsLieTowerSubtypeMem","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL' : LieSubalgebra R L\nM : Type w\ninst✝¹ : AddCommGroup M\ninst✝ : LieRingModule L M\n⊢ IsLieTower (Subtype fun x => Membership.mem L' x) L M","decl":"instance : IsLieTower L' L M where\n  leibniz_lie x y m := leibniz_lie x.val y m\n\n"}
{"name":"LieSubalgebra.lieModule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁶ : CommRing R\ninst✝⁵ : LieRing L\ninst✝⁴ : LieAlgebra R L\nL' : LieSubalgebra R L\nM : Type w\ninst✝³ : AddCommGroup M\ninst✝² : LieRingModule L M\ninst✝¹ : Module R M\ninst✝ : LieModule R L M\n⊢ LieModule R (Subtype fun x => Membership.mem L' x) M","decl":"/-- Given a Lie algebra `L` containing a Lie subalgebra `L' ⊆ L`, together with a Lie module `M` of\n`L`, we may regard `M` as a Lie module of `L'` by restriction. -/\ninstance lieModule [LieModule R L M] : LieModule R L' M where\n  smul_lie t x m := by\n    rw [coe_bracket_of_module, Submodule.coe_smul_of_tower, smul_lie, coe_bracket_of_module]\n  lie_smul t x m := by simp only [coe_bracket_of_module, lie_smul]\n\n"}
{"name":"LieModuleHom.coe_restrictLie","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\nL' : LieSubalgebra R L\nM : Type w\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : LieRingModule L M\nN : Type w₁\ninst✝³ : AddCommGroup N\ninst✝² : LieRingModule L N\ninst✝¹ : Module R N\ninst✝ : Module R M\nf : LieModuleHom R L M N\n⊢ Eq ⇑(f.restrictLie L') ⇑f","decl":"@[simp]\ntheorem _root_.LieModuleHom.coe_restrictLie (f : M →ₗ⁅R,L⁆ N) : ⇑(f.restrictLie L') = f :=\n  rfl\n\n"}
{"name":"LieSubalgebra.coe_incl","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\n⊢ Eq (⇑L'.incl) Subtype.val","decl":"@[simp]\ntheorem coe_incl : ⇑L'.incl = ((↑) : L' → L) :=\n  rfl\n\n"}
{"name":"LieSubalgebra.coe_incl'","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nL' : LieSubalgebra R L\n⊢ Eq (⇑L'.incl') Subtype.val","decl":"@[simp]\ntheorem coe_incl' : ⇑L'.incl' = ((↑) : L' → L) :=\n  rfl\n\n"}
{"name":"LieHom.range_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\n⊢ Eq (↑f.range) (Set.range ⇑f)","decl":"@[simp]\ntheorem range_coe : (f.range : Set L₂) = Set.range f :=\n  LinearMap.range_coe (f : L →ₗ[R] L₂)\n\n"}
{"name":"LieHom.mem_range","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nx : L₂\n⊢ Iff (Membership.mem f.range x) (Exists fun y => Eq (f y) x)","decl":"@[simp]\ntheorem mem_range (x : L₂) : x ∈ f.range ↔ ∃ y : L, f y = x :=\n  LinearMap.mem_range\n\n"}
{"name":"LieHom.mem_range_self","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nx : L\n⊢ Membership.mem f.range (f x)","decl":"theorem mem_range_self (x : L) : f x ∈ f.range :=\n  LinearMap.mem_range_self (f : L →ₗ[R] L₂) x\n\n"}
{"name":"LieHom.rangeRestrict_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nx : L\n⊢ Eq (f.rangeRestrict x) ⟨f x, ⋯⟩","decl":"@[simp]\ntheorem rangeRestrict_apply (x : L) : f.rangeRestrict x = ⟨f x, f.mem_range_self x⟩ :=\n  rfl\n\n"}
{"name":"LieHom.surjective_rangeRestrict","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\n⊢ Function.Surjective ⇑f.rangeRestrict","decl":"theorem surjective_rangeRestrict : Function.Surjective f.rangeRestrict := by\n  rintro ⟨y, hy⟩\n  rw [mem_range] at hy; obtain ⟨x, rfl⟩ := hy\n  use x\n  simp only [Subtype.mk_eq_mk, rangeRestrict_apply]\n\n"}
{"name":"LieHom.equivRangeOfInjective_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nh : Function.Injective ⇑f\nx : L\n⊢ Eq ((f.equivRangeOfInjective h) x) ⟨f x, ⋯⟩","decl":"@[simp]\ntheorem equivRangeOfInjective_apply (h : Function.Injective f) (x : L) :\n    f.equivRangeOfInjective h x = ⟨f x, mem_range_self f x⟩ :=\n  rfl\n\n"}
{"name":"Submodule.exists_lieSubalgebra_coe_eq_iff","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\np : Submodule R L\n⊢ Iff (Exists fun K => Eq K.toSubmodule p) (∀ (x y : L), Membership.mem p x → Membership.mem p y → Membership.mem p (Bracket.bracket x y))","decl":"theorem Submodule.exists_lieSubalgebra_coe_eq_iff (p : Submodule R L) :\n    (∃ K : LieSubalgebra R L, ↑K = p) ↔ ∀ x y : L, x ∈ p → y ∈ p → ⁅x, y⁆ ∈ p := by\n  constructor\n  · rintro ⟨K, rfl⟩ _ _\n    exact K.lie_mem'\n  · intro h\n    use { p with lie_mem' := h _ _ }\n\n"}
{"name":"LieSubalgebra.incl_range","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\n⊢ Eq K.incl.range K","decl":"@[simp]\ntheorem incl_range : K.incl.range = K := by\n  rw [← toSubmodule_inj]\n  exact (K : Submodule R L).range_subtype\n\n"}
{"name":"LieSubalgebra.mem_map","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nK : LieSubalgebra R L\nx : L₂\n⊢ Iff (Membership.mem (LieSubalgebra.map f K) x) (Exists fun y => And (Membership.mem K y) (Eq (f y) x))","decl":"@[simp]\ntheorem mem_map (x : L₂) : x ∈ K.map f ↔ ∃ y : L, y ∈ K ∧ f y = x :=\n  Submodule.mem_map\n\n-- TODO Rename and state for homs instead of equivs.\n"}
{"name":"LieSubalgebra.mem_map_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nK : LieSubalgebra R L\ne : LieEquiv R L L₂\nx : L₂\n⊢ Iff (Membership.mem (LieSubalgebra.map e.toLieHom K) x) (Membership.mem (Submodule.map (↑e.toLinearEquiv) K.toSubmodule) x)","decl":"theorem mem_map_submodule (e : L ≃ₗ⁅R⁆ L₂) (x : L₂) :\n    x ∈ K.map (e : L →ₗ⁅R⁆ L₂) ↔ x ∈ (K : Submodule R L).map (e : L →ₗ[R] L₂) :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.le_def","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Iff (LE.le K K') (HasSubset.Subset ↑K ↑K')","decl":"theorem le_def : K ≤ K' ↔ (K : Set L) ⊆ K' :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.toSubmodule_le_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Iff (LE.le K.toSubmodule K'.toSubmodule) (LE.le K K')","decl":"@[simp]\ntheorem toSubmodule_le_toSubmodule : (K : Submodule R L) ≤ K' ↔ K ≤ K' :=\n  Iff.rfl\n\n"}
{"name":"LieSubalgebra.coe_submodule_le_coe_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Iff (LE.le K.toSubmodule K'.toSubmodule) (LE.le K K')","decl":"@[deprecated (since := \"2024-12-30\")]\nalias coe_submodule_le_coe_submodule := toSubmodule_le_toSubmodule\n\n"}
{"name":"LieSubalgebra.bot_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (↑Bot.bot) (Singleton.singleton 0)","decl":"@[simp]\ntheorem bot_coe : ((⊥ : LieSubalgebra R L) : Set L) = {0} :=\n  rfl\n\n"}
{"name":"LieSubalgebra.bot_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq Bot.bot.toSubmodule Bot.bot","decl":"@[simp]\ntheorem bot_toSubmodule : ((⊥ : LieSubalgebra R L) : Submodule R L) = ⊥ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.bot_coe_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq Bot.bot.toSubmodule Bot.bot","decl":"@[deprecated (since := \"2024-12-30\")] alias bot_coe_submodule := bot_toSubmodule\n\n"}
{"name":"LieSubalgebra.mem_bot","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : L\n⊢ Iff (Membership.mem Bot.bot x) (Eq x 0)","decl":"@[simp]\ntheorem mem_bot (x : L) : x ∈ (⊥ : LieSubalgebra R L) ↔ x = 0 :=\n  mem_singleton_iff\n\n"}
{"name":"LieSubalgebra.top_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (↑Top.top) Set.univ","decl":"@[simp]\ntheorem top_coe : ((⊤ : LieSubalgebra R L) : Set L) = univ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.top_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq Top.top.toSubmodule Top.top","decl":"@[simp]\ntheorem top_toSubmodule : ((⊤ : LieSubalgebra R L) : Submodule R L) = ⊤ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.top_coe_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq Top.top.toSubmodule Top.top","decl":"@[deprecated (since := \"2024-12-30\")] alias top_coe_submodule := top_toSubmodule\n\n"}
{"name":"LieSubalgebra.mem_top","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nx : L\n⊢ Membership.mem Top.top x","decl":"@[simp]\ntheorem mem_top (x : L) : x ∈ (⊤ : LieSubalgebra R L) :=\n  mem_univ x\n\n"}
{"name":"LieHom.range_eq_map","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\n⊢ Eq f.range (LieSubalgebra.map f Top.top)","decl":"theorem _root_.LieHom.range_eq_map : f.range = map f ⊤ := by\n  ext\n  simp\n\n"}
{"name":"LieSubalgebra.inf_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Eq (↑(Min.min K K')) (Inter.inter ↑K ↑K')","decl":"@[simp]\ntheorem inf_coe : (↑(K ⊓ K') : Set L) = (K : Set L) ∩ (K' : Set L) :=\n  rfl\n\n"}
{"name":"LieSubalgebra.sInf_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nS : Set (LieSubalgebra R L)\n⊢ Eq (InfSet.sInf S).toSubmodule (InfSet.sInf (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq s.toSubmodule x)))","decl":"@[simp]\ntheorem sInf_toSubmodule (S : Set (LieSubalgebra R L)) :\n    (↑(sInf S) : Submodule R L) = sInf {(s : Submodule R L) | s ∈ S} :=\n  rfl\n\n"}
{"name":"LieSubalgebra.sInf_coe_to_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nS : Set (LieSubalgebra R L)\n⊢ Eq (InfSet.sInf S).toSubmodule (InfSet.sInf (setOf fun x => Exists fun s => And (Membership.mem S s) (Eq s.toSubmodule x)))","decl":"@[deprecated (since := \"2024-12-30\")] alias sInf_coe_to_submodule := sInf_toSubmodule\n\n"}
{"name":"LieSubalgebra.sInf_coe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nS : Set (LieSubalgebra R L)\n⊢ Eq (↑(InfSet.sInf S)) (Set.iInter fun s => Set.iInter fun h => ↑s)","decl":"@[simp]\ntheorem sInf_coe (S : Set (LieSubalgebra R L)) : (↑(sInf S) : Set L) = ⋂ s ∈ S, (s : Set L) := by\n  rw [← coe_toSubmodule, sInf_toSubmodule, Submodule.sInf_coe]\n  ext x\n  simp\n\n"}
{"name":"LieSubalgebra.sInf_glb","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nS : Set (LieSubalgebra R L)\n⊢ IsGLB S (InfSet.sInf S)","decl":"theorem sInf_glb (S : Set (LieSubalgebra R L)) : IsGLB S (sInf S) := by\n  have h : ∀ K K' : LieSubalgebra R L, (K : Set L) ≤ K' ↔ K ≤ K' := by\n    intros\n    exact Iff.rfl\n  apply IsGLB.of_image @h\n  simp only [sInf_coe]\n  exact isGLB_biInf\n\n"}
{"name":"LieSubalgebra.instCanonicallyOrderedAdd","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ CanonicallyOrderedAdd (LieSubalgebra R L)","decl":"instance : CanonicallyOrderedAdd (LieSubalgebra R L) where\n  exists_add_of_le {_a b} h := ⟨b, (sup_eq_right.2 h).symm⟩\n  le_self_add _ _ := le_sup_left\n\n"}
{"name":"LieSubalgebra.add_eq_sup","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Eq (HAdd.hAdd K K') (Max.max K K')","decl":"@[simp]\ntheorem add_eq_sup : K + K' = K ⊔ K' :=\n  rfl\n\n"}
{"name":"LieSubalgebra.inf_toSubmodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Eq (Min.min K K').toSubmodule (Min.min K.toSubmodule K'.toSubmodule)","decl":"@[simp]\ntheorem inf_toSubmodule :\n    (↑(K ⊓ K') : Submodule R L) = (K : Submodule R L) ⊓ (K' : Submodule R L) :=\n  rfl\n\n"}
{"name":"LieSubalgebra.inf_coe_to_submodule","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\n⊢ Eq (Min.min K K').toSubmodule (Min.min K.toSubmodule K'.toSubmodule)","decl":"@[deprecated (since := \"2024-12-30\")] alias inf_coe_to_submodule := inf_toSubmodule\n\n"}
{"name":"LieSubalgebra.mem_inf","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nx : L\n⊢ Iff (Membership.mem (Min.min K K') x) (And (Membership.mem K x) (Membership.mem K' x))","decl":"@[simp]\ntheorem mem_inf (x : L) : x ∈ K ⊓ K' ↔ x ∈ K ∧ x ∈ K' := by\n  rw [← mem_toSubmodule, ← mem_toSubmodule, ← mem_toSubmodule, inf_toSubmodule,\n    Submodule.mem_inf]\n\n"}
{"name":"LieSubalgebra.eq_bot_iff","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\n⊢ Iff (Eq K Bot.bot) (∀ (x : L), Membership.mem K x → Eq x 0)","decl":"theorem eq_bot_iff : K = ⊥ ↔ ∀ x : L, x ∈ K → x = 0 := by\n  rw [_root_.eq_bot_iff]\n  exact Iff.rfl\n\n"}
{"name":"LieSubalgebra.subsingleton_of_bot","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Subsingleton (LieSubalgebra R (Subtype fun x => Membership.mem Bot.bot x))","decl":"instance subsingleton_of_bot : Subsingleton (LieSubalgebra R (⊥ : LieSubalgebra R L)) := by\n  apply subsingleton_of_bot_eq_top\n  ext ⟨x, hx⟩; change x ∈ ⊥ at hx; rw [LieSubalgebra.mem_bot] at hx; subst hx\n  simp only [mem_bot, mem_top, iff_true]\n  rfl\n\n"}
{"name":"LieSubalgebra.subsingleton_bot","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Subsingleton (Subtype fun x => Membership.mem Bot.bot x)","decl":"theorem subsingleton_bot : Subsingleton (⊥ : LieSubalgebra R L) :=\n  show Subsingleton ((⊥ : LieSubalgebra R L) : Set L) by simp\n\n"}
{"name":"LieSubalgebra.wellFoundedGT_of_noetherian","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝³ : CommRing R\ninst✝² : LieRing L\ninst✝¹ : LieAlgebra R L\ninst✝ : IsNoetherian R L\n⊢ WellFoundedGT (LieSubalgebra R L)","decl":"instance wellFoundedGT_of_noetherian [IsNoetherian R L] : WellFoundedGT (LieSubalgebra R L) :=\n  RelHomClass.isWellFounded (⟨toSubmodule, @fun _ _ h ↦ h⟩ : _ →r (· > ·))\n\n"}
{"name":"LieSubalgebra.coe_inclusion","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\nx : Subtype fun x => Membership.mem K x\n⊢ Eq ↑((LieSubalgebra.inclusion h) x) ↑x","decl":"@[simp]\ntheorem coe_inclusion (x : K) : (inclusion h x : L) = x :=\n  rfl\n\n"}
{"name":"LieSubalgebra.inclusion_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\nx : Subtype fun x => Membership.mem K x\n⊢ Eq ((LieSubalgebra.inclusion h) x) ⟨↑x, ⋯⟩","decl":"theorem inclusion_apply (x : K) : inclusion h x = ⟨x.1, h x.2⟩ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.inclusion_injective","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\n⊢ Function.Injective ⇑(LieSubalgebra.inclusion h)","decl":"theorem inclusion_injective : Function.Injective (inclusion h) := fun x y ↦ by\n  simp only [inclusion_apply, imp_self, Subtype.mk_eq_mk, SetLike.coe_eq_coe]\n\n"}
{"name":"LieSubalgebra.mem_ofLe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\nx : Subtype fun x => Membership.mem K' x\n⊢ Iff (Membership.mem (LieSubalgebra.ofLe h) x) (Membership.mem K ↑x)","decl":"@[simp]\ntheorem mem_ofLe (x : K') : x ∈ ofLe h ↔ (x : L) ∈ K := by\n  simp only [ofLe, inclusion_apply, LieHom.mem_range]\n  constructor\n  · rintro ⟨y, rfl⟩\n    exact y.property\n  · intro h\n    use ⟨(x : L), h⟩\n\n"}
{"name":"LieSubalgebra.ofLe_eq_comap_incl","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\n⊢ Eq (LieSubalgebra.ofLe h) (LieSubalgebra.comap K'.incl K)","decl":"theorem ofLe_eq_comap_incl : ofLe h = K.comap K'.incl := by\n  ext\n  rw [mem_ofLe]\n  rfl\n\n"}
{"name":"LieSubalgebra.coe_ofLe","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\n⊢ Eq (LieSubalgebra.ofLe h).toSubmodule (LinearMap.range (Submodule.inclusion h))","decl":"@[simp]\ntheorem coe_ofLe : (ofLe h : Submodule R K') = LinearMap.range (Submodule.inclusion h) :=\n  rfl\n\n"}
{"name":"LieSubalgebra.equivOfLe_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK K' : LieSubalgebra R L\nh : LE.le K K'\nx : Subtype fun x => Membership.mem K x\n⊢ Eq ((LieSubalgebra.equivOfLe h) x) ⟨(LieSubalgebra.inclusion h) x, ⋯⟩","decl":"@[simp]\ntheorem equivOfLe_apply (x : K) : equivOfLe h x = ⟨inclusion h x, (inclusion h).mem_range_self x⟩ :=\n  rfl\n\n"}
{"name":"LieSubalgebra.map_le_iff_le_comap","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\nK : LieSubalgebra R L\nK' : LieSubalgebra R L₂\n⊢ Iff (LE.le (LieSubalgebra.map f K) K') (LE.le K (LieSubalgebra.comap f K'))","decl":"theorem map_le_iff_le_comap {K : LieSubalgebra R L} {K' : LieSubalgebra R L₂} :\n    map f K ≤ K' ↔ K ≤ comap f K' :=\n  Set.image_subset_iff\n\n"}
{"name":"LieSubalgebra.gc_map_comap","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L\ninst✝² : LieAlgebra R L\nL₂ : Type w\ninst✝¹ : LieRing L₂\ninst✝ : LieAlgebra R L₂\nf : LieHom R L L₂\n⊢ GaloisConnection (LieSubalgebra.map f) (LieSubalgebra.comap f)","decl":"theorem gc_map_comap : GaloisConnection (map f) (comap f) := fun _ _ ↦ map_le_iff_le_comap\n\n"}
{"name":"LieSubalgebra.mem_lieSpan","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns : Set L\nx : L\n⊢ Iff (Membership.mem (LieSubalgebra.lieSpan R L s) x) (∀ (K : LieSubalgebra R L), HasSubset.Subset s ↑K → Membership.mem K x)","decl":"theorem mem_lieSpan {x : L} : x ∈ lieSpan R L s ↔ ∀ K : LieSubalgebra R L, s ⊆ K → x ∈ K := by\n  change x ∈ (lieSpan R L s : Set L) ↔ _\n  erw [sInf_coe]\n  exact Set.mem_iInter₂\n\n"}
{"name":"LieSubalgebra.subset_lieSpan","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns : Set L\n⊢ HasSubset.Subset s ↑(LieSubalgebra.lieSpan R L s)","decl":"theorem subset_lieSpan : s ⊆ lieSpan R L s := by\n  intro m hm\n  erw [mem_lieSpan]\n  intro K hK\n  exact hK hm\n\n"}
{"name":"LieSubalgebra.submodule_span_le_lieSpan","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns : Set L\n⊢ LE.le (Submodule.span R s) (LieSubalgebra.lieSpan R L s).toSubmodule","decl":"theorem submodule_span_le_lieSpan : Submodule.span R s ≤ lieSpan R L s := by\n  rw [Submodule.span_le]\n  apply subset_lieSpan\n\n"}
{"name":"LieSubalgebra.lieSpan_le","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns : Set L\nK : LieSubalgebra R L\n⊢ Iff (LE.le (LieSubalgebra.lieSpan R L s) K) (HasSubset.Subset s ↑K)","decl":"theorem lieSpan_le {K} : lieSpan R L s ≤ K ↔ s ⊆ K := by\n  constructor\n  · exact Set.Subset.trans subset_lieSpan\n  · intro hs m hm\n    rw [mem_lieSpan] at hm\n    exact hm _ hs\n\n"}
{"name":"LieSubalgebra.lieSpan_mono","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns t : Set L\nh : HasSubset.Subset s t\n⊢ LE.le (LieSubalgebra.lieSpan R L s) (LieSubalgebra.lieSpan R L t)","decl":"theorem lieSpan_mono {t : Set L} (h : s ⊆ t) : lieSpan R L s ≤ lieSpan R L t := by\n  rw [lieSpan_le]\n  exact Set.Subset.trans h subset_lieSpan\n\n"}
{"name":"LieSubalgebra.lieSpan_eq","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nK : LieSubalgebra R L\n⊢ Eq (LieSubalgebra.lieSpan R L ↑K) K","decl":"theorem lieSpan_eq : lieSpan R L (K : Set L) = K :=\n  le_antisymm (lieSpan_le.mpr rfl.subset) subset_lieSpan\n\n"}
{"name":"LieSubalgebra.coe_lieSpan_submodule_eq_iff","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\np : Submodule R L\n⊢ Iff (Eq (LieSubalgebra.lieSpan R L ↑p).toSubmodule p) (Exists fun K => Eq K.toSubmodule p)","decl":"theorem coe_lieSpan_submodule_eq_iff {p : Submodule R L} :\n    (lieSpan R L (p : Set L) : Submodule R L) = p ↔ ∃ K : LieSubalgebra R L, ↑K = p := by\n  rw [p.exists_lieSubalgebra_coe_eq_iff]; constructor <;> intro h\n  · intro x m hm\n    rw [← h, mem_toSubmodule]\n    exact lie_mem _ (subset_lieSpan hm)\n  · rw [← toSubmodule_mk p @h, coe_toSubmodule, toSubmodule_inj, lieSpan_eq]\n\n"}
{"name":"LieSubalgebra.span_empty","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieSubalgebra.lieSpan R L EmptyCollection.emptyCollection) Bot.bot","decl":"@[simp]\ntheorem span_empty : lieSpan R L (∅ : Set L) = ⊥ :=\n  (LieSubalgebra.gi R L).gc.l_bot\n\n"}
{"name":"LieSubalgebra.span_univ","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\n⊢ Eq (LieSubalgebra.lieSpan R L Set.univ) Top.top","decl":"@[simp]\ntheorem span_univ : lieSpan R L (Set.univ : Set L) = ⊤ :=\n  eq_top_iff.2 <| SetLike.le_def.2 <| subset_lieSpan\n\n"}
{"name":"LieSubalgebra.span_union","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns t : Set L\n⊢ Eq (LieSubalgebra.lieSpan R L (Union.union s t)) (Max.max (LieSubalgebra.lieSpan R L s) (LieSubalgebra.lieSpan R L t))","decl":"theorem span_union (s t : Set L) : lieSpan R L (s ∪ t) = lieSpan R L s ⊔ lieSpan R L t :=\n  (LieSubalgebra.gi R L).gc.l_sup\n\n"}
{"name":"LieSubalgebra.span_iUnion","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\nι : Sort u_1\ns : ι → Set L\n⊢ Eq (LieSubalgebra.lieSpan R L (Set.iUnion fun i => s i)) (iSup fun i => LieSubalgebra.lieSpan R L (s i))","decl":"theorem span_iUnion {ι} (s : ι → Set L) : lieSpan R L (⋃ i, s i) = ⨆ i, lieSpan R L (s i) :=\n  (LieSubalgebra.gi R L).gc.l_iSup\n\n"}
{"name":"LieSubalgebra.lieSpan_induction","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L\ninst✝ : LieAlgebra R L\ns : Set L\np : L → Prop\nx : L\nh : Membership.mem (LieSubalgebra.lieSpan R L s) x\nmem : ∀ (x : L), Membership.mem s x → p x\nzero : p 0\nsmul : ∀ (r : R) {x : L}, p x → p (HSMul.hSMul r x)\nadd : ∀ (x y : L), p x → p y → p (HAdd.hAdd x y)\nlie : ∀ (x y : L), p x → p y → p (Bracket.bracket x y)\n⊢ p x","decl":"/-- If a predicate `p` is true on some set `s ⊆ L`, true for `0`, stable by scalar multiplication,\nby addition and by Lie bracket, then the predicate is true on the Lie span of `s`. (Since `s` can be\nempty, and the Lie span always contains `0`, the assumption that `p 0` holds cannot be removed.) -/\n@[elab_as_elim]\ntheorem lieSpan_induction {p : L → Prop} {x : L} (h : x ∈ lieSpan R L s) (mem : ∀ x ∈ s, p x)\n    (zero : p 0) (smul : ∀ (r : R), ∀ {x : L}, p x → p (r • x))\n    (add : ∀ x y, p x → p y → p (x + y)) (lie : ∀ x y, p x → p y → p ⁅x, y⁆) : p x :=\n  let S : LieSubalgebra R L :=\n    { carrier := p\n      add_mem' := add _ _\n      zero_mem' := zero\n      smul_mem' := smul\n      lie_mem' := lie _ _ }\n  lieSpan_le.mpr (show s ≤ S from mem) h\n\n"}
{"name":"LieEquiv.ofInjective_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nf : LieHom R L₁ L₂\nh : Function.Injective ⇑f\nx : L₁\n⊢ Eq (↑((LieEquiv.ofInjective f h) x)) (f x)","decl":"@[simp]\ntheorem ofInjective_apply (f : L₁ →ₗ⁅R⁆ L₂) (h : Function.Injective f) (x : L₁) :\n    ↑(ofInjective f h x) = f x :=\n  rfl\n\n"}
{"name":"LieEquiv.ofEq_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL₁ : Type v\ninst✝² : CommRing R\ninst✝¹ : LieRing L₁\ninst✝ : LieAlgebra R L₁\nL L' : LieSubalgebra R L₁\nh : Eq ↑L ↑L'\nx : Subtype fun x => Membership.mem L x\n⊢ Eq ↑((LieEquiv.ofEq L L' h) x) ↑x","decl":"@[simp]\ntheorem ofEq_apply (L L' : LieSubalgebra R L₁) (h : (L : Set L₁) = L') (x : L) :\n    (↑(ofEq L L' h x) : L₁) = x :=\n  rfl\n\n"}
{"name":"LieEquiv.lieSubalgebraMap_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nL₁'' : LieSubalgebra R L₁\ne : LieEquiv R L₁ L₂\nx : Subtype fun x => Membership.mem L₁'' x\n⊢ Eq (↑((LieEquiv.lieSubalgebraMap L₁'' e) x)) (e ↑x)","decl":"@[simp]\ntheorem lieSubalgebraMap_apply (x : L₁'') : ↑(e.lieSubalgebraMap _ x) = e x :=\n  rfl\n\n"}
{"name":"LieEquiv.ofSubalgebras_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nL₁' : LieSubalgebra R L₁\nL₂' : LieSubalgebra R L₂\ne : LieEquiv R L₁ L₂\nh : Eq (LieSubalgebra.map e.toLieHom L₁') L₂'\nx : Subtype fun x => Membership.mem L₁' x\n⊢ Eq (↑((LieEquiv.ofSubalgebras L₁' L₂' e h) x)) (e ↑x)","decl":"@[simp]\ntheorem ofSubalgebras_apply (h : L₁'.map ↑e = L₂') (x : L₁') : ↑(e.ofSubalgebras _ _ h x) = e x :=\n  rfl\n\n"}
{"name":"LieEquiv.ofSubalgebras_symm_apply","module":"Mathlib.Algebra.Lie.Subalgebra","initialProofState":"R : Type u\nL₁ : Type v\nL₂ : Type w\ninst✝⁴ : CommRing R\ninst✝³ : LieRing L₁\ninst✝² : LieRing L₂\ninst✝¹ : LieAlgebra R L₁\ninst✝ : LieAlgebra R L₂\nL₁' : LieSubalgebra R L₁\nL₂' : LieSubalgebra R L₂\ne : LieEquiv R L₁ L₂\nh : Eq (LieSubalgebra.map e.toLieHom L₁') L₂'\nx : Subtype fun x => Membership.mem L₂' x\n⊢ Eq (↑((LieEquiv.ofSubalgebras L₁' L₂' e h).symm x)) (e.symm ↑x)","decl":"@[simp]\ntheorem ofSubalgebras_symm_apply (h : L₁'.map ↑e = L₂') (x : L₂') :\n    ↑((e.ofSubalgebras _ _ h).symm x) = e.symm x :=\n  rfl\n\n"}
