{"name":"CategoryTheory.SingleFunctors.shiftIso_zero","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nself : CategoryTheory.SingleFunctors C D A\na : A\nâŠ¢ Eq (self.shiftIso 0 a a â‹¯) (CategoryTheory.isoWhiskerLeft (self.functor a) (CategoryTheory.shiftFunctorZero D A))","decl":"/-- The type of families of functors `A â†’ C â¥¤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C â¥¤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C â¥¤ D\n  /-- the isomorphism `functor a' â‹™ shiftFunctor D n â‰… functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' â‹™ shiftFunctor D n â‰… functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰«\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ â‰ªâ‰« shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : CategoryTheory.HasShift D A\ninstâœÂ² : SizeOf C\ninstâœÂ¹ : SizeOf D\ninstâœ : SizeOf A\nfunctor : A â†’ CategoryTheory.Functor C D\nshiftIso : (n a a' : A) â†’ Eq (HAdd.hAdd n a) a' â†’ CategoryTheory.Iso ((functor a').comp (CategoryTheory.shiftFunctor D n)) (functor a)\nshiftIso_zero : âˆ€ (a : A), Eq (shiftIso 0 a a â‹¯) (CategoryTheory.isoWhiskerLeft (functor a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add : âˆ€ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso (HAdd.hAdd m n) a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso n a a' ha'))))\nâŠ¢ Eq (SizeOf.sizeOf { functor := functor, shiftIso := shiftIso, shiftIso_zero := shiftIso_zero, shiftIso_add := shiftIso_add }) 1","decl":"/-- The type of families of functors `A â†’ C â¥¤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C â¥¤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C â¥¤ D\n  /-- the isomorphism `functor a' â‹™ shiftFunctor D n â‰… functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' â‹™ shiftFunctor D n â‰… functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰«\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ â‰ªâ‰« shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nself : CategoryTheory.SingleFunctors C D A\nn m a a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nâŠ¢ Eq (self.shiftIso (HAdd.hAdd m n) a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (self.functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((self.functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (self.shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (self.shiftIso n a a' ha'))))","decl":"/-- The type of families of functors `A â†’ C â¥¤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C â¥¤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C â¥¤ D\n  /-- the isomorphism `functor a' â‹™ shiftFunctor D n â‰… functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' â‹™ shiftFunctor D n â‰… functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰«\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ â‰ªâ‰« shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.mk.inj","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nfunctorâœ : A â†’ CategoryTheory.Functor C D\nshiftIsoâœ : (n a a' : A) â†’ Eq (HAdd.hAdd n a) a' â†’ CategoryTheory.Iso ((functorâœ a').comp (CategoryTheory.shiftFunctor D n)) (functorâœ a)\nshiftIso_zeroâœ : âˆ€ (a : A), Eq (shiftIsoâœ 0 a a â‹¯) (CategoryTheory.isoWhiskerLeft (functorâœ a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_addâœ : âˆ€ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIsoâœ (HAdd.hAdd m n) a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (functorâœ a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functorâœ a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIsoâœ m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIsoâœ n a a' ha'))))\nfunctor : A â†’ CategoryTheory.Functor C D\nshiftIso : (n a a' : A) â†’ Eq (HAdd.hAdd n a) a' â†’ CategoryTheory.Iso ((functor a').comp (CategoryTheory.shiftFunctor D n)) (functor a)\nshiftIso_zero : âˆ€ (a : A), Eq (shiftIso 0 a a â‹¯) (CategoryTheory.isoWhiskerLeft (functor a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add : âˆ€ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso (HAdd.hAdd m n) a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso n a a' ha'))))\nxâœ : Eq { functor := functorâœ, shiftIso := shiftIsoâœ, shiftIso_zero := shiftIso_zeroâœ, shiftIso_add := shiftIso_addâœ } { functor := functor, shiftIso := shiftIso, shiftIso_zero := shiftIso_zero, shiftIso_add := shiftIso_add }\nâŠ¢ And (Eq functorâœ functor) (HEq shiftIsoâœ shiftIso)","decl":"/-- The type of families of functors `A â†’ C â¥¤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C â¥¤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C â¥¤ D\n  /-- the isomorphism `functor a' â‹™ shiftFunctor D n â‰… functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' â‹™ shiftFunctor D n â‰… functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰«\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ â‰ªâ‰« shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.mk.injEq","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nfunctorâœ : A â†’ CategoryTheory.Functor C D\nshiftIsoâœ : (n a a' : A) â†’ Eq (HAdd.hAdd n a) a' â†’ CategoryTheory.Iso ((functorâœ a').comp (CategoryTheory.shiftFunctor D n)) (functorâœ a)\nshiftIso_zeroâœ : âˆ€ (a : A), Eq (shiftIsoâœ 0 a a â‹¯) (CategoryTheory.isoWhiskerLeft (functorâœ a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_addâœ : âˆ€ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIsoâœ (HAdd.hAdd m n) a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (functorâœ a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functorâœ a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIsoâœ m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIsoâœ n a a' ha'))))\nfunctor : A â†’ CategoryTheory.Functor C D\nshiftIso : (n a a' : A) â†’ Eq (HAdd.hAdd n a) a' â†’ CategoryTheory.Iso ((functor a').comp (CategoryTheory.shiftFunctor D n)) (functor a)\nshiftIso_zero : âˆ€ (a : A), Eq (shiftIso 0 a a â‹¯) (CategoryTheory.isoWhiskerLeft (functor a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add : âˆ€ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso (HAdd.hAdd m n) a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso n a a' ha'))))\nâŠ¢ Eq (Eq { functor := functorâœ, shiftIso := shiftIsoâœ, shiftIso_zero := shiftIso_zeroâœ, shiftIso_add := shiftIso_addâœ } { functor := functor, shiftIso := shiftIso, shiftIso_zero := shiftIso_zero, shiftIso_add := shiftIso_add }) (And (Eq functorâœ functor) (HEq shiftIsoâœ shiftIso))","decl":"/-- The type of families of functors `A â†’ C â¥¤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C â¥¤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C â¥¤ D\n  /-- the isomorphism `functor a' â‹™ shiftFunctor D n â‰… functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' â‹™ shiftFunctor D n â‰… functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰«\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ â‰ªâ‰« shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m a a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\nâŠ¢ Eq ((F.shiftIso (HAdd.hAdd m n) a a'' â‹¯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D m n).hom.app ((F.functor a'').obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').hom.app X)) ((F.shiftIso n a a' ha').hom.app X)))","decl":"lemma shiftIso_add_hom_app (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).hom.app X =\n      (shiftFunctorAdd D m n).hom.app ((F.functor a'').obj X) â‰«\n        ((F.shiftIso m a' a'' ha'').hom.app X)âŸ¦nâŸ§' â‰«\n        (F.shiftIso n a a' ha').hom.app X := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m a a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\nâŠ¢ Eq ((F.shiftIso (HAdd.hAdd m n) a a'' â‹¯).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').inv.app X)) ((CategoryTheory.shiftFunctorAdd D m n).inv.app ((F.functor a'').obj X))))","decl":"lemma shiftIso_add_inv_app (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).inv.app X =\n      (F.shiftIso n a a' ha').inv.app X â‰«\n      ((F.shiftIso m a' a'' ha'').inv.app X)âŸ¦nâŸ§' â‰«\n      (shiftFunctorAdd D m n).inv.app ((F.functor a'').obj X) := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add'","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m mn : A\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nâŠ¢ Eq (F.shiftIso mn a a'' â‹¯) ((CategoryTheory.isoWhiskerLeft (F.functor a'') (CategoryTheory.shiftFunctorAdd' D m n mn hnm)).trans (((F.functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (F.shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (F.shiftIso n a a' ha'))))","decl":"lemma shiftIso_add' (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') :\n    F.shiftIso mn a a'' (by rw [â† hnm, â† ha'', â† ha', add_assoc]) =\n      isoWhiskerLeft _ (shiftFunctorAdd' D m n mn hnm) â‰ªâ‰« (Functor.associator _ _ _).symm â‰ªâ‰«\n        isoWhiskerRight (F.shiftIso m a' a'' ha'') _ â‰ªâ‰« F.shiftIso n a a' ha' := by\n  subst hnm\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftIso_add]\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add'_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m mn : A\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\nâŠ¢ Eq ((F.shiftIso mn a a'' â‹¯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' D m n mn hnm).hom.app ((F.functor a'').obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').hom.app X)) ((F.shiftIso n a a' ha').hom.app X)))","decl":"lemma shiftIso_add'_hom_app (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [â† hnm, â† ha'', â† ha', add_assoc])).hom.app X =\n      (shiftFunctorAdd' D m n mn hnm).hom.app ((F.functor a'').obj X) â‰«\n        ((F.shiftIso m a' a'' ha'').hom.app X)âŸ¦nâŸ§' â‰« (F.shiftIso n a a' ha').hom.app X := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add'_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m mn : A\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\nâŠ¢ Eq ((F.shiftIso mn a a'' â‹¯).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').inv.app X)) ((CategoryTheory.shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X))))","decl":"lemma shiftIso_add'_inv_app (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [â† hnm, â† ha'', â† ha', add_assoc])).inv.app X =\n        (F.shiftIso n a a' ha').inv.app X â‰«\n        ((F.shiftIso m a' a'' ha'').inv.app X)âŸ¦nâŸ§' â‰«\n      (shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X) := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\na : A\nX : C\nâŠ¢ Eq ((F.shiftIso 0 a a â‹¯).hom.app X) ((CategoryTheory.shiftFunctorZero D A).hom.app ((F.functor a).obj X))","decl":"@[simp]\nlemma shiftIso_zero_hom_app (a : A) (X : C) :\n    (F.shiftIso 0 a a (zero_add a)).hom.app X = (shiftFunctorZero D A).hom.app _ := by\n  rw [shiftIso_zero]\n  rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\na : A\nX : C\nâŠ¢ Eq ((F.shiftIso 0 a a â‹¯).inv.app X) ((CategoryTheory.shiftFunctorZero D A).inv.app ((F.functor a).toPrefunctor.1 X))","decl":"@[simp]\nlemma shiftIso_zero_inv_app (a : A) (X : C) :\n    (F.shiftIso 0 a a (zero_add a)).inv.app X = (shiftFunctorZero D A).inv.app _ := by\n  rw [shiftIso_zero]\n  rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.comm","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nself : F.Hom G\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (self.hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (self.hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a âŸ¶ G.functor a` -/\n  hom (a : A) : F.functor a âŸ¶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom â‰« hom a =\n    whiskerRight (hom a') (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.ext","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nx y : F.Hom G\nhom : Eq x.hom y.hom\nâŠ¢ Eq x y","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a âŸ¶ G.functor a` -/\n  hom (a : A) : F.functor a âŸ¶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom â‰« hom a =\n    whiskerRight (hom a') (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœâ´ : AddMonoid A\ninstâœÂ³ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ninstâœÂ² : SizeOf C\ninstâœÂ¹ : SizeOf D\ninstâœ : SizeOf A\nhom : (a : A) â†’ Quiver.Hom (F.functor a) (G.functor a)\ncomm : autoParam (âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _autoâœ\nâŠ¢ Eq (SizeOf.sizeOf { hom := hom, comm := comm }) 1","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a âŸ¶ G.functor a` -/\n  hom (a : A) : F.functor a âŸ¶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom â‰« hom a =\n    whiskerRight (hom a') (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.ext_iff","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nx y : F.Hom G\nâŠ¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a âŸ¶ G.functor a` -/\n  hom (a : A) : F.functor a âŸ¶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom â‰« hom a =\n    whiskerRight (hom a') (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.mk.inj","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nhomâœ : (a : A) â†’ Quiver.Hom (F.functor a) (G.functor a)\ncommâœ : autoParam (âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (homâœ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (homâœ a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _autoâœ\nhom : (a : A) â†’ Quiver.Hom (F.functor a) (G.functor a)\ncomm : autoParam (âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _autoâœ\nxâœ : Eq { hom := homâœ, comm := commâœ } { hom := hom, comm := comm }\nâŠ¢ Eq homâœ hom","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a âŸ¶ G.functor a` -/\n  hom (a : A) : F.functor a âŸ¶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom â‰« hom a =\n    whiskerRight (hom a') (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nhomâœ : (a : A) â†’ Quiver.Hom (F.functor a) (G.functor a)\ncommâœ : autoParam (âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (homâœ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (homâœ a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _autoâœ\nhom : (a : A) â†’ Quiver.Hom (F.functor a) (G.functor a)\ncomm : autoParam (âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _autoâœ\nâŠ¢ Eq (Eq { hom := homâœ, comm := commâœ } { hom := hom, comm := comm }) (Eq homâœ hom)","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a âŸ¶ G.functor a` -/\n  hom (a : A) : F.functor a âŸ¶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom â‰« hom a =\n    whiskerRight (hom a') (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nself : F.Hom G\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (G.functor a) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (CategoryTheory.CategoryStruct.comp (self.hom a) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (self.hom a') (CategoryTheory.shiftFunctor D n)) (CategoryTheory.CategoryStruct.comp (G.shiftIso n a a' ha').hom h))","decl":"attribute [reassoc] comm\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nxâœ : A\nâŠ¢ Eq ((CategoryTheory.SingleFunctors.Hom.id F).hom xâœ) (CategoryTheory.CategoryStruct.id (F.functor xâœ))","decl":"/-- The identity morphism in `SingleFunctors C D A`. -/\n@[simps]\ndef id : Hom F F where\n  hom _ := ğŸ™ _\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.comp_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G H : CategoryTheory.SingleFunctors C D A\nÎ± : F.Hom G\nÎ² : G.Hom H\na : A\nâŠ¢ Eq ((Î±.comp Î²).hom a) (CategoryTheory.CategoryStruct.comp (Î±.hom a) (Î².hom a))","decl":"/-- The composition of morphisms in `SingleFunctors C D A`. -/\n@[simps]\ndef comp (Î± : Hom F G) (Î² : Hom G H) : Hom F H where\n  hom a := Î±.hom a â‰« Î².hom a\n\n"}
{"name":"CategoryTheory.SingleFunctors.id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\na : A\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.id F).hom a) (CategoryTheory.CategoryStruct.id (F.functor a))","decl":"@[simp]\nlemma id_hom (a : A) : Hom.hom (ğŸ™ F) a = ğŸ™ _ := rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.comp_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G H : CategoryTheory.SingleFunctors C D A\nf : Quiver.Hom F G\ng : Quiver.Hom G H\na : A\nâŠ¢ Eq ((CategoryTheory.CategoryStruct.comp f g).hom a) (CategoryTheory.CategoryStruct.comp (f.hom a) (g.hom a))","decl":"@[simp, reassoc]\nlemma comp_hom (f : F âŸ¶ G) (g : G âŸ¶ H) (a : A) : (f â‰« g).hom a = f.hom a â‰« g.hom a := rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.comp_hom_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G H : CategoryTheory.SingleFunctors C D A\nf : Quiver.Hom F G\ng : Quiver.Hom G H\na : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (H.functor a) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp f g).hom a) h) (CategoryTheory.CategoryStruct.comp (f.hom a) (CategoryTheory.CategoryStruct.comp (g.hom a) h))","decl":"@[simp, reassoc]\nlemma comp_hom (f : F âŸ¶ G) (g : G âŸ¶ H) (a : A) : (f â‰« g).hom a = f.hom a â‰« g.hom a := rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_ext","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nf g : Quiver.Hom F G\nh : Eq f.hom g.hom\nâŠ¢ Eq f g","decl":"@[ext]\nlemma hom_ext (f g : F âŸ¶ G) (h : f.hom = g.hom) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_ext_iff","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nf g : Quiver.Hom F G\nâŠ¢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\nlemma hom_ext (f g : F âŸ¶ G) (h : f.hom = g.hom) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.SingleFunctors.isoMk_inv_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\niso : (a : A) â†’ CategoryTheory.Iso (F.functor a) (G.functor a)\ncomm : âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (iso a).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (iso a').hom (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)\na : A\nâŠ¢ Eq ((CategoryTheory.SingleFunctors.isoMk iso comm).inv.hom a) (iso a).inv","decl":"/-- Construct an isomorphism in `SingleFunctors C D A` by giving\nlevel-wise isomorphisms and checking compatibility only in the forward direction. -/\n@[simps]\ndef isoMk (iso : âˆ€ a, (F.functor a â‰… G.functor a))\n    (comm : âˆ€ (n a a' : A) (ha' : n + a = a'), (F.shiftIso n a a' ha').hom â‰« (iso a).hom =\n      whiskerRight (iso a').hom (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom) :\n    F â‰… G where\n  hom :=\n    { hom := fun a => (iso a).hom\n      comm := comm }\n  inv :=\n    { hom := fun a => (iso a).inv\n      comm := fun n a a' ha' => by\n        dsimp only\n        rw [â† cancel_mono (iso a).hom, assoc, assoc, Iso.inv_hom_id, comp_id, comm,\n          â† whiskerRight_comp_assoc, Iso.inv_hom_id, whiskerRight_id', id_comp] }\n\n"}
{"name":"CategoryTheory.SingleFunctors.isoMk_hom_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\niso : (a : A) â†’ CategoryTheory.Iso (F.functor a) (G.functor a)\ncomm : âˆ€ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (iso a).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (iso a').hom (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)\na : A\nâŠ¢ Eq ((CategoryTheory.SingleFunctors.isoMk iso comm).hom.hom a) (iso a).hom","decl":"/-- Construct an isomorphism in `SingleFunctors C D A` by giving\nlevel-wise isomorphisms and checking compatibility only in the forward direction. -/\n@[simps]\ndef isoMk (iso : âˆ€ a, (F.functor a â‰… G.functor a))\n    (comm : âˆ€ (n a a' : A) (ha' : n + a = a'), (F.shiftIso n a a' ha').hom â‰« (iso a).hom =\n      whiskerRight (iso a').hom (shiftFunctor D n) â‰« (G.shiftIso n a a' ha').hom) :\n    F â‰… G where\n  hom :=\n    { hom := fun a => (iso a).hom\n      comm := comm }\n  inv :=\n    { hom := fun a => (iso a).inv\n      comm := fun n a a' ha' => by\n        dsimp only\n        rw [â† cancel_mono (iso a).hom, assoc, assoc, Iso.inv_hom_id, comp_id, comm,\n          â† whiskerRight_comp_assoc, Iso.inv_hom_id, whiskerRight_id', id_comp] }\n\n"}
{"name":"CategoryTheory.SingleFunctors.evaluation_map","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\na : A\nxâœÂ¹ xâœ : CategoryTheory.SingleFunctors C D A\nÏ† : Quiver.Hom xâœÂ¹ xâœ\nâŠ¢ Eq ((CategoryTheory.SingleFunctors.evaluation C D a).map Ï†) (Ï†.hom a)","decl":"/-- The evaluation `SingleFunctors C D A â¥¤ C â¥¤ D` for some `a : A`. -/\n@[simps]\ndef evaluation (a : A) : SingleFunctors C D A â¥¤ C â¥¤ D where\n  obj F := F.functor a\n  map {_ _} Ï† := Ï†.hom a\n\n"}
{"name":"CategoryTheory.SingleFunctors.evaluation_obj","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\na : A\nF : CategoryTheory.SingleFunctors C D A\nâŠ¢ Eq ((CategoryTheory.SingleFunctors.evaluation C D a).obj F) (F.functor a)","decl":"/-- The evaluation `SingleFunctors C D A â¥¤ C â¥¤ D` for some `a : A`. -/\n@[simps]\ndef evaluation (a : A) : SingleFunctors C D A â¥¤ C â¥¤ D where\n  obj F := F.functor a\n  map {_ _} Ï† := Ï†.hom a\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom.hom n) (e.inv.hom n)) (CategoryTheory.CategoryStruct.id (F.functor n))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom (e : F â‰… G) (n : A) : e.hom.hom n â‰« e.inv.hom n = ğŸ™ _ := by\n  rw [â† comp_hom, e.hom_inv_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F.functor n) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.hom.hom n) (CategoryTheory.CategoryStruct.comp (e.inv.hom n) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom (e : F â‰… G) (n : A) : e.hom.hom n â‰« e.inv.hom n = ğŸ™ _ := by\n  rw [â† comp_hom, e.hom_inv_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (G.functor n) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv.hom n) (CategoryTheory.CategoryStruct.comp (e.hom.hom n) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom (e : F â‰… G) (n : A) : e.inv.hom n â‰« e.hom.hom n = ğŸ™ _ := by\n  rw [â† comp_hom, e.inv_hom_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (e.inv.hom n) (e.hom.hom n)) (CategoryTheory.CategoryStruct.id (G.functor n))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom (e : F â‰… G) (n : A) : e.inv.hom n â‰« e.hom.hom n = ğŸ™ _ := by\n  rw [â† comp_hom, e.inv_hom_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\nZ : D\nh : Quiver.Hom ((F.functor n).obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((e.hom.hom n).app X) (CategoryTheory.CategoryStruct.comp ((e.inv.hom n).app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom_app (e : F â‰… G) (n : A) (X : C) :\n    (e.hom.hom n).app X â‰« (e.inv.hom n).app X = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, hom_inv_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((e.hom.hom n).app X) ((e.inv.hom n).app X)) (CategoryTheory.CategoryStruct.id ((F.functor n).obj X))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom_app (e : F â‰… G) (n : A) (X : C) :\n    (e.hom.hom n).app X â‰« (e.inv.hom n).app X = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, hom_inv_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\nZ : D\nh : Quiver.Hom ((G.functor n).obj X) Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((e.inv.hom n).app X) (CategoryTheory.CategoryStruct.comp ((e.hom.hom n).app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom_app (e : F â‰… G) (n : A) (X : C) :\n    (e.inv.hom n).app X â‰« (e.hom.hom n).app X = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, inv_hom_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœÂ³ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ¹ : AddMonoid A\ninstâœ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp ((e.inv.hom n).app X) ((e.hom.hom n).app X)) (CategoryTheory.CategoryStruct.id ((G.functor n).obj X))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom_app (e : F â‰… G) (n : A) (X : C) :\n    (e.inv.hom n).app X â‰« (e.hom.hom n).app X = ğŸ™ _ := by\n  rw [â† NatTrans.comp_app, inv_hom_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.instIsIsoFunctorHom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninstâœâ´ : CategoryTheory.Category.{u_7, u_1} C\ninstâœÂ³ : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninstâœÂ² : AddMonoid A\ninstâœÂ¹ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nf : Quiver.Hom F G\ninstâœ : CategoryTheory.IsIso f\nn : A\nâŠ¢ CategoryTheory.IsIso (f.hom n)","decl":"instance (f : F âŸ¶ G) [IsIso f] (n : A) : IsIso (f.hom n) :=\n  (inferInstance : IsIso ((evaluation C D n).map f))\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcomp_shiftIso_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ´ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift D A\ninstâœÂ¹ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift A\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nX : C\nâŠ¢ Eq (((F.postcomp G).shiftIso n a a' ha').hom.app X) (CategoryTheory.CategoryStruct.comp ((G.commShiftIso n).inv.app ((F.functor a').obj X)) (G.map ((F.shiftIso n a a' ha').hom.app X)))","decl":"/-- Given `F : SingleFunctors C D A`, and a functor `G : D â¥¤ E` which commutes\nwith the shift by `A`, this is the \"composition\" of `F` and `G` in `SingleFunctors C E A`. -/\n@[simps! functor shiftIso_hom_app shiftIso_inv_app]\ndef postcomp (G : D â¥¤ E) [G.CommShift A] :\n    SingleFunctors C E A where\n  functor a := F.functor a â‹™ G\n  shiftIso n a a' ha' :=\n    Functor.associator _ _ _ â‰ªâ‰« isoWhiskerLeft _ (G.commShiftIso n).symm â‰ªâ‰«\n      (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight (F.shiftIso n a a' ha') G\n  shiftIso_zero a := by\n    ext X\n    dsimp\n    simp only [Functor.commShiftIso_zero, Functor.CommShift.isoZero_inv_app,\n      SingleFunctors.shiftIso_zero_hom_app,id_comp, assoc, â† G.map_comp, Iso.inv_hom_id_app,\n      Functor.map_id, Functor.id_obj, comp_id]\n  shiftIso_add n m a a' a'' ha' ha'' := by\n    ext X\n    dsimp\n    simp only [F.shiftIso_add_hom_app n m a a' a'' ha' ha'', Functor.commShiftIso_add,\n      Functor.CommShift.isoAdd_inv_app, Functor.map_comp, id_comp, assoc,\n      Functor.commShiftIso_inv_naturality_assoc]\n    simp only [â† G.map_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcomp_shiftIso_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ´ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift D A\ninstâœÂ¹ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift A\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nX : C\nâŠ¢ Eq (((F.postcomp G).shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp (G.map ((F.shiftIso n a a' ha').inv.app X)) ((G.commShiftIso n).hom.app ((F.functor a').obj X)))","decl":"/-- Given `F : SingleFunctors C D A`, and a functor `G : D â¥¤ E` which commutes\nwith the shift by `A`, this is the \"composition\" of `F` and `G` in `SingleFunctors C E A`. -/\n@[simps! functor shiftIso_hom_app shiftIso_inv_app]\ndef postcomp (G : D â¥¤ E) [G.CommShift A] :\n    SingleFunctors C E A where\n  functor a := F.functor a â‹™ G\n  shiftIso n a a' ha' :=\n    Functor.associator _ _ _ â‰ªâ‰« isoWhiskerLeft _ (G.commShiftIso n).symm â‰ªâ‰«\n      (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight (F.shiftIso n a a' ha') G\n  shiftIso_zero a := by\n    ext X\n    dsimp\n    simp only [Functor.commShiftIso_zero, Functor.CommShift.isoZero_inv_app,\n      SingleFunctors.shiftIso_zero_hom_app,id_comp, assoc, â† G.map_comp, Iso.inv_hom_id_app,\n      Functor.map_id, Functor.id_obj, comp_id]\n  shiftIso_add n m a a' a'' ha' ha'' := by\n    ext X\n    dsimp\n    simp only [F.shiftIso_add_hom_app n m a a' a'' ha' ha'', Functor.commShiftIso_add,\n      Functor.CommShift.isoAdd_inv_app, Functor.map_comp, id_comp, assoc,\n      Functor.commShiftIso_inv_naturality_assoc]\n    simp only [â† G.map_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcomp_functor","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¶ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâµ : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ´ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninstâœÂ³ : AddMonoid A\ninstâœÂ² : CategoryTheory.HasShift D A\ninstâœÂ¹ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\ninstâœ : G.CommShift A\na : A\nâŠ¢ Eq ((F.postcomp G).functor a) ((F.functor a).comp G)","decl":"/-- Given `F : SingleFunctors C D A`, and a functor `G : D â¥¤ E` which commutes\nwith the shift by `A`, this is the \"composition\" of `F` and `G` in `SingleFunctors C E A`. -/\n@[simps! functor shiftIso_hom_app shiftIso_inv_app]\ndef postcomp (G : D â¥¤ E) [G.CommShift A] :\n    SingleFunctors C E A where\n  functor a := F.functor a â‹™ G\n  shiftIso n a a' ha' :=\n    Functor.associator _ _ _ â‰ªâ‰« isoWhiskerLeft _ (G.commShiftIso n).symm â‰ªâ‰«\n      (Functor.associator _ _ _).symm â‰ªâ‰« isoWhiskerRight (F.shiftIso n a a' ha') G\n  shiftIso_zero a := by\n    ext X\n    dsimp\n    simp only [Functor.commShiftIso_zero, Functor.CommShift.isoZero_inv_app,\n      SingleFunctors.shiftIso_zero_hom_app,id_comp, assoc, â† G.map_comp, Iso.inv_hom_id_app,\n      Functor.map_id, Functor.id_obj, comp_id]\n  shiftIso_add n m a a' a'' ha' ha'' := by\n    ext X\n    dsimp\n    simp only [F.shiftIso_add_hom_app n m a a' a'' ha' ha'', Functor.commShiftIso_add,\n      Functor.CommShift.isoAdd_inv_app, Functor.map_comp, id_comp, assoc,\n      Functor.commShiftIso_inv_naturality_assoc]\n    simp only [â† G.map_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompPostcompIso_inv_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nE' : Type u_4\ninstâœâ¹ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ¸ : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ· : CategoryTheory.Category.{u_8, u_3} E\ninstâœâ¶ : CategoryTheory.Category.{u_9, u_4} E'\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift D A\ninstâœÂ³ : CategoryTheory.HasShift E A\ninstâœÂ² : CategoryTheory.HasShift E' A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E E'\ninstâœÂ¹ : G.CommShift A\ninstâœ : G'.CommShift A\na : A\nxâœ : C\nâŠ¢ Eq (((F.postcompPostcompIso G G').inv.hom a).app xâœ) (CategoryTheory.CategoryStruct.id (G'.obj (G.obj ((F.functor a).obj xâœ))))","decl":"/-- The canonical isomorphism `(F.postcomp G).postcomp G' â‰… F.postcomp (G â‹™ G')`. -/\n@[simps!]\ndef postcompPostcompIso (G : D â¥¤ E) (G' : E â¥¤ E') [G.CommShift A] [G'.CommShift A] :\n    (F.postcomp G).postcomp G' â‰… F.postcomp (G â‹™ G') :=\n  isoMk (fun _ => Functor.associator _ _ _) (fun n a a' ha' => by\n    ext X\n    simp [Functor.commShiftIso_comp_inv_app])\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompPostcompIso_hom_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nE' : Type u_4\ninstâœâ¹ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ¸ : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ· : CategoryTheory.Category.{u_8, u_3} E\ninstâœâ¶ : CategoryTheory.Category.{u_9, u_4} E'\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift D A\ninstâœÂ³ : CategoryTheory.HasShift E A\ninstâœÂ² : CategoryTheory.HasShift E' A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E E'\ninstâœÂ¹ : G.CommShift A\ninstâœ : G'.CommShift A\na : A\nxâœ : C\nâŠ¢ Eq (((F.postcompPostcompIso G G').hom.hom a).app xâœ) (CategoryTheory.CategoryStruct.id (G'.obj (G.obj ((F.functor a).obj xâœ))))","decl":"/-- The canonical isomorphism `(F.postcomp G).postcomp G' â‰… F.postcomp (G â‹™ G')`. -/\n@[simps!]\ndef postcompPostcompIso (G : D â¥¤ E) (G' : E â¥¤ E') [G.CommShift A] [G'.CommShift A] :\n    (F.postcomp G).postcomp G' â‰… F.postcomp (G â‹™ G') :=\n  isoMk (fun _ => Functor.associator _ _ _) (fun n a a' ha' => by\n    ext X\n    simp [Functor.commShiftIso_comp_inv_app])\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompIsoOfIso_inv_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¸ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ¶ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift D A\ninstâœÂ³ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG G' : CategoryTheory.Functor D E\ne : CategoryTheory.Iso G G'\ninstâœÂ² : G.CommShift A\ninstâœÂ¹ : G'.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom A\na : A\nX : C\nâŠ¢ Eq (((F.postcompIsoOfIso e).inv.hom a).app X) (e.inv.app ((F.functor a).obj X))","decl":"/-- The isomorphism `F.postcomp G â‰… F.postcomp G'` induced by an isomorphism `e : G â‰… G'`\nwhich commutes with the shift. -/\n@[simps!]\ndef postcompIsoOfIso {G G' : D â¥¤ E} (e : G â‰… G') [G.CommShift A] [G'.CommShift A]\n    [NatTrans.CommShift e.hom A] :\n    F.postcomp G â‰… F.postcomp G' :=\n  isoMk (fun a => isoWhiskerLeft (F.functor a) e) (fun n a a' ha' => by\n    ext X\n    dsimp\n    simp [NatTrans.shift_app e.hom n])\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompIsoOfIso_hom_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninstâœâ¸ : CategoryTheory.Category.{u_6, u_1} C\ninstâœâ· : CategoryTheory.Category.{u_7, u_2} D\ninstâœâ¶ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninstâœâµ : AddMonoid A\ninstâœâ´ : CategoryTheory.HasShift D A\ninstâœÂ³ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG G' : CategoryTheory.Functor D E\ne : CategoryTheory.Iso G G'\ninstâœÂ² : G.CommShift A\ninstâœÂ¹ : G'.CommShift A\ninstâœ : CategoryTheory.NatTrans.CommShift e.hom A\na : A\nX : C\nâŠ¢ Eq (((F.postcompIsoOfIso e).hom.hom a).app X) (e.hom.app ((F.functor a).obj X))","decl":"/-- The isomorphism `F.postcomp G â‰… F.postcomp G'` induced by an isomorphism `e : G â‰… G'`\nwhich commutes with the shift. -/\n@[simps!]\ndef postcompIsoOfIso {G G' : D â¥¤ E} (e : G â‰… G') [G.CommShift A] [G'.CommShift A]\n    [NatTrans.CommShift e.hom A] :\n    F.postcomp G â‰… F.postcomp G' :=\n  isoMk (fun a => isoWhiskerLeft (F.functor a) e) (fun n a a' ha' => by\n    ext X\n    dsimp\n    simp [NatTrans.shift_app e.hom n])\n\n"}
