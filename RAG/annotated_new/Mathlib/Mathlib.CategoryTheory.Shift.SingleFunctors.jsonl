{"name":"CategoryTheory.SingleFunctors.shiftIso_zero","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nself : CategoryTheory.SingleFunctors C D A\na : A\n⊢ Eq (self.shiftIso 0 a a ⋯) (CategoryTheory.isoWhiskerLeft (self.functor a) (CategoryTheory.shiftFunctorZero D A))","decl":"/-- The type of families of functors `A → C ⥤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C ⥤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C ⥤ D\n  /-- the isomorphism `functor a' ⋙ shiftFunctor D n ≅ functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' ⋙ shiftFunctor D n ≅ functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ ≪≫ shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift D A\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : SizeOf A\nfunctor : A → CategoryTheory.Functor C D\nshiftIso : (n a a' : A) → Eq (HAdd.hAdd n a) a' → CategoryTheory.Iso ((functor a').comp (CategoryTheory.shiftFunctor D n)) (functor a)\nshiftIso_zero : ∀ (a : A), Eq (shiftIso 0 a a ⋯) (CategoryTheory.isoWhiskerLeft (functor a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add : ∀ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso n a a' ha'))))\n⊢ Eq (SizeOf.sizeOf { functor := functor, shiftIso := shiftIso, shiftIso_zero := shiftIso_zero, shiftIso_add := shiftIso_add }) 1","decl":"/-- The type of families of functors `A → C ⥤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C ⥤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C ⥤ D\n  /-- the isomorphism `functor a' ⋙ shiftFunctor D n ≅ functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' ⋙ shiftFunctor D n ≅ functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ ≪≫ shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nself : CategoryTheory.SingleFunctors C D A\nn m a a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\n⊢ Eq (self.shiftIso (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (self.functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((self.functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (self.shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (self.shiftIso n a a' ha'))))","decl":"/-- The type of families of functors `A → C ⥤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C ⥤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C ⥤ D\n  /-- the isomorphism `functor a' ⋙ shiftFunctor D n ≅ functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' ⋙ shiftFunctor D n ≅ functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ ≪≫ shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.mk.inj","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nfunctor✝ : A → CategoryTheory.Functor C D\nshiftIso✝ : (n a a' : A) → Eq (HAdd.hAdd n a) a' → CategoryTheory.Iso ((functor✝ a').comp (CategoryTheory.shiftFunctor D n)) (functor✝ a)\nshiftIso_zero✝ : ∀ (a : A), Eq (shiftIso✝ 0 a a ⋯) (CategoryTheory.isoWhiskerLeft (functor✝ a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add✝ : ∀ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso✝ (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (functor✝ a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor✝ a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso✝ m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso✝ n a a' ha'))))\nfunctor : A → CategoryTheory.Functor C D\nshiftIso : (n a a' : A) → Eq (HAdd.hAdd n a) a' → CategoryTheory.Iso ((functor a').comp (CategoryTheory.shiftFunctor D n)) (functor a)\nshiftIso_zero : ∀ (a : A), Eq (shiftIso 0 a a ⋯) (CategoryTheory.isoWhiskerLeft (functor a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add : ∀ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso n a a' ha'))))\nx✝ : Eq { functor := functor✝, shiftIso := shiftIso✝, shiftIso_zero := shiftIso_zero✝, shiftIso_add := shiftIso_add✝ } { functor := functor, shiftIso := shiftIso, shiftIso_zero := shiftIso_zero, shiftIso_add := shiftIso_add }\n⊢ And (Eq functor✝ functor) (HEq shiftIso✝ shiftIso)","decl":"/-- The type of families of functors `A → C ⥤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C ⥤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C ⥤ D\n  /-- the isomorphism `functor a' ⋙ shiftFunctor D n ≅ functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' ⋙ shiftFunctor D n ≅ functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ ≪≫ shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.mk.injEq","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nfunctor✝ : A → CategoryTheory.Functor C D\nshiftIso✝ : (n a a' : A) → Eq (HAdd.hAdd n a) a' → CategoryTheory.Iso ((functor✝ a').comp (CategoryTheory.shiftFunctor D n)) (functor✝ a)\nshiftIso_zero✝ : ∀ (a : A), Eq (shiftIso✝ 0 a a ⋯) (CategoryTheory.isoWhiskerLeft (functor✝ a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add✝ : ∀ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso✝ (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (functor✝ a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor✝ a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso✝ m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso✝ n a a' ha'))))\nfunctor : A → CategoryTheory.Functor C D\nshiftIso : (n a a' : A) → Eq (HAdd.hAdd n a) a' → CategoryTheory.Iso ((functor a').comp (CategoryTheory.shiftFunctor D n)) (functor a)\nshiftIso_zero : ∀ (a : A), Eq (shiftIso 0 a a ⋯) (CategoryTheory.isoWhiskerLeft (functor a) (CategoryTheory.shiftFunctorZero D A))\nshiftIso_add : ∀ (n m a a' a'' : A) (ha' : Eq (HAdd.hAdd n a) a') (ha'' : Eq (HAdd.hAdd m a') a''), Eq (shiftIso (HAdd.hAdd m n) a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (functor a'') (CategoryTheory.shiftFunctorAdd D m n)).trans (((functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (shiftIso n a a' ha'))))\n⊢ Eq (Eq { functor := functor✝, shiftIso := shiftIso✝, shiftIso_zero := shiftIso_zero✝, shiftIso_add := shiftIso_add✝ } { functor := functor, shiftIso := shiftIso, shiftIso_zero := shiftIso_zero, shiftIso_add := shiftIso_add }) (And (Eq functor✝ functor) (HEq shiftIso✝ shiftIso))","decl":"/-- The type of families of functors `A → C ⥤ D` which are compatible with\nthe shift by `A` on the category `D`. -/\nstructure SingleFunctors where\n  /-- a family of functors `C ⥤ D` indexed by the elements of the additive monoid `A` -/\n  functor (a : A) : C ⥤ D\n  /-- the isomorphism `functor a' ⋙ shiftFunctor D n ≅ functor a` when `n + a = a'` -/\n  shiftIso (n a a' : A) (ha' : n + a = a') : functor a' ⋙ shiftFunctor D n ≅ functor a\n  /-- `shiftIso 0` is the obvious isomorphism. -/\n  shiftIso_zero (a : A) :\n    shiftIso 0 a a (zero_add a) = isoWhiskerLeft _ (shiftFunctorZero D A)\n  /-- `shiftIso (m + n)` is determined by `shiftIso m` and `shiftIso n`. -/\n  shiftIso_add (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') :\n    shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha'']) =\n      isoWhiskerLeft _ (shiftFunctorAdd D m n) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (shiftIso m a' a'' ha'') _ ≪≫ shiftIso n a a' ha'\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m a a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso (HAdd.hAdd m n) a a'' ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd D m n).hom.app ((F.functor a'').obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').hom.app X)) ((F.shiftIso n a a' ha').hom.app X)))","decl":"lemma shiftIso_add_hom_app (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).hom.app X =\n      (shiftFunctorAdd D m n).hom.app ((F.functor a'').obj X) ≫\n        ((F.shiftIso m a' a'' ha'').hom.app X)⟦n⟧' ≫\n        (F.shiftIso n a a' ha').hom.app X := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m a a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso (HAdd.hAdd m n) a a'' ⋯).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').inv.app X)) ((CategoryTheory.shiftFunctorAdd D m n).inv.app ((F.functor a'').obj X))))","decl":"lemma shiftIso_add_inv_app (n m a a' a'' : A) (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso (m + n) a a'' (by rw [add_assoc, ha', ha''])).inv.app X =\n      (F.shiftIso n a a' ha').inv.app X ≫\n      ((F.shiftIso m a' a'' ha'').inv.app X)⟦n⟧' ≫\n      (shiftFunctorAdd D m n).inv.app ((F.functor a'').obj X) := by\n  simp [F.shiftIso_add n m a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add'","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m mn : A\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\n⊢ Eq (F.shiftIso mn a a'' ⋯) ((CategoryTheory.isoWhiskerLeft (F.functor a'') (CategoryTheory.shiftFunctorAdd' D m n mn hnm)).trans (((F.functor a'').associator (CategoryTheory.shiftFunctor D m) (CategoryTheory.shiftFunctor D n)).symm.trans ((CategoryTheory.isoWhiskerRight (F.shiftIso m a' a'' ha'') (CategoryTheory.shiftFunctor D n)).trans (F.shiftIso n a a' ha'))))","decl":"lemma shiftIso_add' (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') :\n    F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc]) =\n      isoWhiskerLeft _ (shiftFunctorAdd' D m n mn hnm) ≪≫ (Functor.associator _ _ _).symm ≪≫\n        isoWhiskerRight (F.shiftIso m a' a'' ha'') _ ≪≫ F.shiftIso n a a' ha' := by\n  subst hnm\n  rw [shiftFunctorAdd'_eq_shiftFunctorAdd, shiftIso_add]\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add'_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m mn : A\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso mn a a'' ⋯).hom.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctorAdd' D m n mn hnm).hom.app ((F.functor a'').obj X)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').hom.app X)) ((F.shiftIso n a a' ha').hom.app X)))","decl":"lemma shiftIso_add'_hom_app (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc])).hom.app X =\n      (shiftFunctorAdd' D m n mn hnm).hom.app ((F.functor a'').obj X) ≫\n        ((F.shiftIso m a' a'' ha'').hom.app X)⟦n⟧' ≫ (F.shiftIso n a a' ha').hom.app X := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_add'_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nn m mn : A\nhnm : Eq (HAdd.hAdd m n) mn\na a' a'' : A\nha' : Eq (HAdd.hAdd n a) a'\nha'' : Eq (HAdd.hAdd m a') a''\nX : C\n⊢ Eq ((F.shiftIso mn a a'' ⋯).inv.app X) (CategoryTheory.CategoryStruct.comp ((F.shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.shiftIso m a' a'' ha'').inv.app X)) ((CategoryTheory.shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X))))","decl":"lemma shiftIso_add'_inv_app (n m mn : A) (hnm : m + n = mn) (a a' a'' : A)\n    (ha' : n + a = a') (ha'' : m + a' = a'') (X : C) :\n    (F.shiftIso mn a a'' (by rw [← hnm, ← ha'', ← ha', add_assoc])).inv.app X =\n        (F.shiftIso n a a' ha').inv.app X ≫\n        ((F.shiftIso m a' a'' ha'').inv.app X)⟦n⟧' ≫\n      (shiftFunctorAdd' D m n mn hnm).inv.app ((F.functor a'').obj X) := by\n  simp [F.shiftIso_add' n m mn hnm a a' a'' ha' ha'']\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_zero_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\na : A\nX : C\n⊢ Eq ((F.shiftIso 0 a a ⋯).hom.app X) ((CategoryTheory.shiftFunctorZero D A).hom.app ((F.functor a).obj X))","decl":"@[simp]\nlemma shiftIso_zero_hom_app (a : A) (X : C) :\n    (F.shiftIso 0 a a (zero_add a)).hom.app X = (shiftFunctorZero D A).hom.app _ := by\n  rw [shiftIso_zero]\n  rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.shiftIso_zero_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\na : A\nX : C\n⊢ Eq ((F.shiftIso 0 a a ⋯).inv.app X) ((CategoryTheory.shiftFunctorZero D A).inv.app ((F.functor a).toPrefunctor.1 X))","decl":"@[simp]\nlemma shiftIso_zero_inv_app (a : A) (X : C) :\n    (F.shiftIso 0 a a (zero_add a)).inv.app X = (shiftFunctorZero D A).inv.app _ := by\n  rw [shiftIso_zero]\n  rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.comm","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nself : F.Hom G\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (self.hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (self.hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a ⟶ G.functor a` -/\n  hom (a : A) : F.functor a ⟶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom ≫ hom a =\n    whiskerRight (hom a') (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.ext","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nx y : F.Hom G\nhom : Eq x.hom y.hom\n⊢ Eq x y","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a ⟶ G.functor a` -/\n  hom (a : A) : F.functor a ⟶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom ≫ hom a =\n    whiskerRight (hom a') (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.mk.sizeOf_spec","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝⁴ : AddMonoid A\ninst✝³ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ninst✝² : SizeOf C\ninst✝¹ : SizeOf D\ninst✝ : SizeOf A\nhom : (a : A) → Quiver.Hom (F.functor a) (G.functor a)\ncomm : autoParam (∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, comm := comm }) 1","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a ⟶ G.functor a` -/\n  hom (a : A) : F.functor a ⟶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom ≫ hom a =\n    whiskerRight (hom a') (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.ext_iff","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nx y : F.Hom G\n⊢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a ⟶ G.functor a` -/\n  hom (a : A) : F.functor a ⟶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom ≫ hom a =\n    whiskerRight (hom a') (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.mk.inj","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nhom✝ : (a : A) → Quiver.Hom (F.functor a) (G.functor a)\ncomm✝ : autoParam (∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom✝ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom✝ a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _auto✝\nhom : (a : A) → Quiver.Hom (F.functor a) (G.functor a)\ncomm : autoParam (∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _auto✝\nx✝ : Eq { hom := hom✝, comm := comm✝ } { hom := hom, comm := comm }\n⊢ Eq hom✝ hom","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a ⟶ G.functor a` -/\n  hom (a : A) : F.functor a ⟶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom ≫ hom a =\n    whiskerRight (hom a') (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.mk.injEq","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nhom✝ : (a : A) → Quiver.Hom (F.functor a) (G.functor a)\ncomm✝ : autoParam (∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom✝ a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom✝ a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _auto✝\nhom : (a : A) → Quiver.Hom (F.functor a) (G.functor a)\ncomm : autoParam (∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (hom a)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (hom a') (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)) _auto✝\n⊢ Eq (Eq { hom := hom✝, comm := comm✝ } { hom := hom, comm := comm }) (Eq hom✝ hom)","decl":"/-- The morphisms in the category `SingleFunctors C D A` -/\n@[ext]\nstructure Hom where\n  /-- a family of natural transformations `F.functor a ⟶ G.functor a` -/\n  hom (a : A) : F.functor a ⟶ G.functor a\n  comm (n a a' : A) (ha' : n + a = a') : (F.shiftIso n a a' ha').hom ≫ hom a =\n    whiskerRight (hom a') (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom := by aesop_cat\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.comm_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nself : F.Hom G\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (G.functor a) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (CategoryTheory.CategoryStruct.comp (self.hom a) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (self.hom a') (CategoryTheory.shiftFunctor D n)) (CategoryTheory.CategoryStruct.comp (G.shiftIso n a a' ha').hom h))","decl":"attribute [reassoc] comm\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\nx✝ : A\n⊢ Eq ((CategoryTheory.SingleFunctors.Hom.id F).hom x✝) (CategoryTheory.CategoryStruct.id (F.functor x✝))","decl":"/-- The identity morphism in `SingleFunctors C D A`. -/\n@[simps]\ndef id : Hom F F where\n  hom _ := 𝟙 _\n\n"}
{"name":"CategoryTheory.SingleFunctors.Hom.comp_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G H : CategoryTheory.SingleFunctors C D A\nα : F.Hom G\nβ : G.Hom H\na : A\n⊢ Eq ((α.comp β).hom a) (CategoryTheory.CategoryStruct.comp (α.hom a) (β.hom a))","decl":"/-- The composition of morphisms in `SingleFunctors C D A`. -/\n@[simps]\ndef comp (α : Hom F G) (β : Hom G H) : Hom F H where\n  hom a := α.hom a ≫ β.hom a\n\n"}
{"name":"CategoryTheory.SingleFunctors.id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF : CategoryTheory.SingleFunctors C D A\na : A\n⊢ Eq ((CategoryTheory.CategoryStruct.id F).hom a) (CategoryTheory.CategoryStruct.id (F.functor a))","decl":"@[simp]\nlemma id_hom (a : A) : Hom.hom (𝟙 F) a = 𝟙 _ := rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.comp_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G H : CategoryTheory.SingleFunctors C D A\nf : Quiver.Hom F G\ng : Quiver.Hom G H\na : A\n⊢ Eq ((CategoryTheory.CategoryStruct.comp f g).hom a) (CategoryTheory.CategoryStruct.comp (f.hom a) (g.hom a))","decl":"@[simp, reassoc]\nlemma comp_hom (f : F ⟶ G) (g : G ⟶ H) (a : A) : (f ≫ g).hom a = f.hom a ≫ g.hom a := rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.comp_hom_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G H : CategoryTheory.SingleFunctors C D A\nf : Quiver.Hom F G\ng : Quiver.Hom G H\na : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (H.functor a) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.CategoryStruct.comp f g).hom a) h) (CategoryTheory.CategoryStruct.comp (f.hom a) (CategoryTheory.CategoryStruct.comp (g.hom a) h))","decl":"@[simp, reassoc]\nlemma comp_hom (f : F ⟶ G) (g : G ⟶ H) (a : A) : (f ≫ g).hom a = f.hom a ≫ g.hom a := rfl\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_ext","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nf g : Quiver.Hom F G\nh : Eq f.hom g.hom\n⊢ Eq f g","decl":"@[ext]\nlemma hom_ext (f g : F ⟶ G) (h : f.hom = g.hom) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_ext_iff","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nf g : Quiver.Hom F G\n⊢ Iff (Eq f g) (Eq f.hom g.hom)","decl":"@[ext]\nlemma hom_ext (f g : F ⟶ G) (h : f.hom = g.hom) : f = g := Hom.ext h\n\n"}
{"name":"CategoryTheory.SingleFunctors.isoMk_inv_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\niso : (a : A) → CategoryTheory.Iso (F.functor a) (G.functor a)\ncomm : ∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (iso a).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (iso a').hom (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)\na : A\n⊢ Eq ((CategoryTheory.SingleFunctors.isoMk iso comm).inv.hom a) (iso a).inv","decl":"/-- Construct an isomorphism in `SingleFunctors C D A` by giving\nlevel-wise isomorphisms and checking compatibility only in the forward direction. -/\n@[simps]\ndef isoMk (iso : ∀ a, (F.functor a ≅ G.functor a))\n    (comm : ∀ (n a a' : A) (ha' : n + a = a'), (F.shiftIso n a a' ha').hom ≫ (iso a).hom =\n      whiskerRight (iso a').hom (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom) :\n    F ≅ G where\n  hom :=\n    { hom := fun a => (iso a).hom\n      comm := comm }\n  inv :=\n    { hom := fun a => (iso a).inv\n      comm := fun n a a' ha' => by\n        dsimp only\n        rw [← cancel_mono (iso a).hom, assoc, assoc, Iso.inv_hom_id, comp_id, comm,\n          ← whiskerRight_comp_assoc, Iso.inv_hom_id, whiskerRight_id', id_comp] }\n\n"}
{"name":"CategoryTheory.SingleFunctors.isoMk_hom_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\niso : (a : A) → CategoryTheory.Iso (F.functor a) (G.functor a)\ncomm : ∀ (n a a' : A) (ha' : Eq (HAdd.hAdd n a) a'), Eq (CategoryTheory.CategoryStruct.comp (F.shiftIso n a a' ha').hom (iso a).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerRight (iso a').hom (CategoryTheory.shiftFunctor D n)) (G.shiftIso n a a' ha').hom)\na : A\n⊢ Eq ((CategoryTheory.SingleFunctors.isoMk iso comm).hom.hom a) (iso a).hom","decl":"/-- Construct an isomorphism in `SingleFunctors C D A` by giving\nlevel-wise isomorphisms and checking compatibility only in the forward direction. -/\n@[simps]\ndef isoMk (iso : ∀ a, (F.functor a ≅ G.functor a))\n    (comm : ∀ (n a a' : A) (ha' : n + a = a'), (F.shiftIso n a a' ha').hom ≫ (iso a).hom =\n      whiskerRight (iso a').hom (shiftFunctor D n) ≫ (G.shiftIso n a a' ha').hom) :\n    F ≅ G where\n  hom :=\n    { hom := fun a => (iso a).hom\n      comm := comm }\n  inv :=\n    { hom := fun a => (iso a).inv\n      comm := fun n a a' ha' => by\n        dsimp only\n        rw [← cancel_mono (iso a).hom, assoc, assoc, Iso.inv_hom_id, comp_id, comm,\n          ← whiskerRight_comp_assoc, Iso.inv_hom_id, whiskerRight_id', id_comp] }\n\n"}
{"name":"CategoryTheory.SingleFunctors.evaluation_map","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\na : A\nx✝¹ x✝ : CategoryTheory.SingleFunctors C D A\nφ : Quiver.Hom x✝¹ x✝\n⊢ Eq ((CategoryTheory.SingleFunctors.evaluation C D a).map φ) (φ.hom a)","decl":"/-- The evaluation `SingleFunctors C D A ⥤ C ⥤ D` for some `a : A`. -/\n@[simps]\ndef evaluation (a : A) : SingleFunctors C D A ⥤ C ⥤ D where\n  obj F := F.functor a\n  map {_ _} φ := φ.hom a\n\n"}
{"name":"CategoryTheory.SingleFunctors.evaluation_obj","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_6, u_1} C\ninst✝² : CategoryTheory.Category.{u_7, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\na : A\nF : CategoryTheory.SingleFunctors C D A\n⊢ Eq ((CategoryTheory.SingleFunctors.evaluation C D a).obj F) (F.functor a)","decl":"/-- The evaluation `SingleFunctors C D A ⥤ C ⥤ D` for some `a : A`. -/\n@[simps]\ndef evaluation (a : A) : SingleFunctors C D A ⥤ C ⥤ D where\n  obj F := F.functor a\n  map {_ _} φ := φ.hom a\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.hom.hom n) (e.inv.hom n)) (CategoryTheory.CategoryStruct.id (F.functor n))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom (e : F ≅ G) (n : A) : e.hom.hom n ≫ e.inv.hom n = 𝟙 _ := by\n  rw [← comp_hom, e.hom_inv_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (F.functor n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.hom.hom n) (CategoryTheory.CategoryStruct.comp (e.inv.hom n) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom (e : F ≅ G) (n : A) : e.hom.hom n ≫ e.inv.hom n = 𝟙 _ := by\n  rw [← comp_hom, e.hom_inv_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nZ : CategoryTheory.Functor C D\nh : Quiver.Hom (G.functor n) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.inv.hom n) (CategoryTheory.CategoryStruct.comp (e.hom.hom n) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom (e : F ≅ G) (n : A) : e.inv.hom n ≫ e.hom.hom n = 𝟙 _ := by\n  rw [← comp_hom, e.inv_hom_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\n⊢ Eq (CategoryTheory.CategoryStruct.comp (e.inv.hom n) (e.hom.hom n)) (CategoryTheory.CategoryStruct.id (G.functor n))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom (e : F ≅ G) (n : A) : e.inv.hom n ≫ e.hom.hom n = 𝟙 _ := by\n  rw [← comp_hom, e.inv_hom_id, id_hom]\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\nZ : D\nh : Quiver.Hom ((F.functor n).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((e.hom.hom n).app X) (CategoryTheory.CategoryStruct.comp ((e.inv.hom n).app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom_app (e : F ≅ G) (n : A) (X : C) :\n    (e.hom.hom n).app X ≫ (e.inv.hom n).app X = 𝟙 _ := by\n  rw [← NatTrans.comp_app, hom_inv_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.hom_inv_id_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((e.hom.hom n).app X) ((e.inv.hom n).app X)) (CategoryTheory.CategoryStruct.id ((F.functor n).obj X))","decl":"@[reassoc (attr := simp)]\nlemma hom_inv_id_hom_app (e : F ≅ G) (n : A) (X : C) :\n    (e.hom.hom n).app X ≫ (e.inv.hom n).app X = 𝟙 _ := by\n  rw [← NatTrans.comp_app, hom_inv_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom_app_assoc","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\nZ : D\nh : Quiver.Hom ((G.functor n).obj X) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((e.inv.hom n).app X) (CategoryTheory.CategoryStruct.comp ((e.hom.hom n).app X) h)) h","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom_app (e : F ≅ G) (n : A) (X : C) :\n    (e.inv.hom n).app X ≫ (e.hom.hom n).app X = 𝟙 _ := by\n  rw [← NatTrans.comp_app, inv_hom_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.inv_hom_id_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝³ : CategoryTheory.Category.{u_7, u_1} C\ninst✝² : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝¹ : AddMonoid A\ninst✝ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\ne : CategoryTheory.Iso F G\nn : A\nX : C\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((e.inv.hom n).app X) ((e.hom.hom n).app X)) (CategoryTheory.CategoryStruct.id ((G.functor n).obj X))","decl":"@[reassoc (attr := simp)]\nlemma inv_hom_id_hom_app (e : F ≅ G) (n : A) (X : C) :\n    (e.inv.hom n).app X ≫ (e.hom.hom n).app X = 𝟙 _ := by\n  rw [← NatTrans.comp_app, inv_hom_id_hom, NatTrans.id_app]\n\n"}
{"name":"CategoryTheory.SingleFunctors.instIsIsoFunctorHom","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_7, u_1} C\ninst✝³ : CategoryTheory.Category.{u_6, u_2} D\nA : Type u_5\ninst✝² : AddMonoid A\ninst✝¹ : CategoryTheory.HasShift D A\nF G : CategoryTheory.SingleFunctors C D A\nf : Quiver.Hom F G\ninst✝ : CategoryTheory.IsIso f\nn : A\n⊢ CategoryTheory.IsIso (f.hom n)","decl":"instance (f : F ⟶ G) [IsIso f] (n : A) : IsIso (f.hom n) :=\n  (inferInstance : IsIso ((evaluation C D n).map f))\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcomp_shiftIso_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁴ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift A\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nX : C\n⊢ Eq (((F.postcomp G).shiftIso n a a' ha').hom.app X) (CategoryTheory.CategoryStruct.comp ((G.commShiftIso n).inv.app ((F.functor a').obj X)) (G.map ((F.shiftIso n a a' ha').hom.app X)))","decl":"/-- Given `F : SingleFunctors C D A`, and a functor `G : D ⥤ E` which commutes\nwith the shift by `A`, this is the \"composition\" of `F` and `G` in `SingleFunctors C E A`. -/\n@[simps! functor shiftIso_hom_app shiftIso_inv_app]\ndef postcomp (G : D ⥤ E) [G.CommShift A] :\n    SingleFunctors C E A where\n  functor a := F.functor a ⋙ G\n  shiftIso n a a' ha' :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (G.commShiftIso n).symm ≪≫\n      (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (F.shiftIso n a a' ha') G\n  shiftIso_zero a := by\n    ext X\n    dsimp\n    simp only [Functor.commShiftIso_zero, Functor.CommShift.isoZero_inv_app,\n      SingleFunctors.shiftIso_zero_hom_app,id_comp, assoc, ← G.map_comp, Iso.inv_hom_id_app,\n      Functor.map_id, Functor.id_obj, comp_id]\n  shiftIso_add n m a a' a'' ha' ha'' := by\n    ext X\n    dsimp\n    simp only [F.shiftIso_add_hom_app n m a a' a'' ha' ha'', Functor.commShiftIso_add,\n      Functor.CommShift.isoAdd_inv_app, Functor.map_comp, id_comp, assoc,\n      Functor.commShiftIso_inv_naturality_assoc]\n    simp only [← G.map_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcomp_shiftIso_inv_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁴ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift A\nn a a' : A\nha' : Eq (HAdd.hAdd n a) a'\nX : C\n⊢ Eq (((F.postcomp G).shiftIso n a a' ha').inv.app X) (CategoryTheory.CategoryStruct.comp (G.map ((F.shiftIso n a a' ha').inv.app X)) ((G.commShiftIso n).hom.app ((F.functor a').obj X)))","decl":"/-- Given `F : SingleFunctors C D A`, and a functor `G : D ⥤ E` which commutes\nwith the shift by `A`, this is the \"composition\" of `F` and `G` in `SingleFunctors C E A`. -/\n@[simps! functor shiftIso_hom_app shiftIso_inv_app]\ndef postcomp (G : D ⥤ E) [G.CommShift A] :\n    SingleFunctors C E A where\n  functor a := F.functor a ⋙ G\n  shiftIso n a a' ha' :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (G.commShiftIso n).symm ≪≫\n      (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (F.shiftIso n a a' ha') G\n  shiftIso_zero a := by\n    ext X\n    dsimp\n    simp only [Functor.commShiftIso_zero, Functor.CommShift.isoZero_inv_app,\n      SingleFunctors.shiftIso_zero_hom_app,id_comp, assoc, ← G.map_comp, Iso.inv_hom_id_app,\n      Functor.map_id, Functor.id_obj, comp_id]\n  shiftIso_add n m a a' a'' ha' ha'' := by\n    ext X\n    dsimp\n    simp only [F.shiftIso_add_hom_app n m a a' a'' ha' ha'', Functor.commShiftIso_add,\n      Functor.CommShift.isoAdd_inv_app, Functor.map_comp, id_comp, assoc,\n      Functor.commShiftIso_inv_naturality_assoc]\n    simp only [← G.map_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcomp_functor","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁶ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁴ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninst✝³ : AddMonoid A\ninst✝² : CategoryTheory.HasShift D A\ninst✝¹ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\ninst✝ : G.CommShift A\na : A\n⊢ Eq ((F.postcomp G).functor a) ((F.functor a).comp G)","decl":"/-- Given `F : SingleFunctors C D A`, and a functor `G : D ⥤ E` which commutes\nwith the shift by `A`, this is the \"composition\" of `F` and `G` in `SingleFunctors C E A`. -/\n@[simps! functor shiftIso_hom_app shiftIso_inv_app]\ndef postcomp (G : D ⥤ E) [G.CommShift A] :\n    SingleFunctors C E A where\n  functor a := F.functor a ⋙ G\n  shiftIso n a a' ha' :=\n    Functor.associator _ _ _ ≪≫ isoWhiskerLeft _ (G.commShiftIso n).symm ≪≫\n      (Functor.associator _ _ _).symm ≪≫ isoWhiskerRight (F.shiftIso n a a' ha') G\n  shiftIso_zero a := by\n    ext X\n    dsimp\n    simp only [Functor.commShiftIso_zero, Functor.CommShift.isoZero_inv_app,\n      SingleFunctors.shiftIso_zero_hom_app,id_comp, assoc, ← G.map_comp, Iso.inv_hom_id_app,\n      Functor.map_id, Functor.id_obj, comp_id]\n  shiftIso_add n m a a' a'' ha' ha'' := by\n    ext X\n    dsimp\n    simp only [F.shiftIso_add_hom_app n m a a' a'' ha' ha'', Functor.commShiftIso_add,\n      Functor.CommShift.isoAdd_inv_app, Functor.map_comp, id_comp, assoc,\n      Functor.commShiftIso_inv_naturality_assoc]\n    simp only [← G.map_comp, Iso.inv_hom_id_app_assoc]\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompPostcompIso_inv_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nE' : Type u_4\ninst✝⁹ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_8, u_3} E\ninst✝⁶ : CategoryTheory.Category.{u_9, u_4} E'\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift D A\ninst✝³ : CategoryTheory.HasShift E A\ninst✝² : CategoryTheory.HasShift E' A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E E'\ninst✝¹ : G.CommShift A\ninst✝ : G'.CommShift A\na : A\nx✝ : C\n⊢ Eq (((F.postcompPostcompIso G G').inv.hom a).app x✝) (CategoryTheory.CategoryStruct.id (G'.obj (G.obj ((F.functor a).obj x✝))))","decl":"/-- The canonical isomorphism `(F.postcomp G).postcomp G' ≅ F.postcomp (G ⋙ G')`. -/\n@[simps!]\ndef postcompPostcompIso (G : D ⥤ E) (G' : E ⥤ E') [G.CommShift A] [G'.CommShift A] :\n    (F.postcomp G).postcomp G' ≅ F.postcomp (G ⋙ G') :=\n  isoMk (fun _ => Functor.associator _ _ _) (fun n a a' ha' => by\n    ext X\n    simp [Functor.commShiftIso_comp_inv_app])\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompPostcompIso_hom_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nE' : Type u_4\ninst✝⁹ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁸ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁷ : CategoryTheory.Category.{u_8, u_3} E\ninst✝⁶ : CategoryTheory.Category.{u_9, u_4} E'\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift D A\ninst✝³ : CategoryTheory.HasShift E A\ninst✝² : CategoryTheory.HasShift E' A\nF : CategoryTheory.SingleFunctors C D A\nG : CategoryTheory.Functor D E\nG' : CategoryTheory.Functor E E'\ninst✝¹ : G.CommShift A\ninst✝ : G'.CommShift A\na : A\nx✝ : C\n⊢ Eq (((F.postcompPostcompIso G G').hom.hom a).app x✝) (CategoryTheory.CategoryStruct.id (G'.obj (G.obj ((F.functor a).obj x✝))))","decl":"/-- The canonical isomorphism `(F.postcomp G).postcomp G' ≅ F.postcomp (G ⋙ G')`. -/\n@[simps!]\ndef postcompPostcompIso (G : D ⥤ E) (G' : E ⥤ E') [G.CommShift A] [G'.CommShift A] :\n    (F.postcomp G).postcomp G' ≅ F.postcomp (G ⋙ G') :=\n  isoMk (fun _ => Functor.associator _ _ _) (fun n a a' ha' => by\n    ext X\n    simp [Functor.commShiftIso_comp_inv_app])\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompIsoOfIso_inv_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁶ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift D A\ninst✝³ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG G' : CategoryTheory.Functor D E\ne : CategoryTheory.Iso G G'\ninst✝² : G.CommShift A\ninst✝¹ : G'.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom A\na : A\nX : C\n⊢ Eq (((F.postcompIsoOfIso e).inv.hom a).app X) (e.inv.app ((F.functor a).obj X))","decl":"/-- The isomorphism `F.postcomp G ≅ F.postcomp G'` induced by an isomorphism `e : G ≅ G'`\nwhich commutes with the shift. -/\n@[simps!]\ndef postcompIsoOfIso {G G' : D ⥤ E} (e : G ≅ G') [G.CommShift A] [G'.CommShift A]\n    [NatTrans.CommShift e.hom A] :\n    F.postcomp G ≅ F.postcomp G' :=\n  isoMk (fun a => isoWhiskerLeft (F.functor a) e) (fun n a a' ha' => by\n    ext X\n    dsimp\n    simp [NatTrans.shift_app e.hom n])\n\n"}
{"name":"CategoryTheory.SingleFunctors.postcompIsoOfIso_hom_hom_app","module":"Mathlib.CategoryTheory.Shift.SingleFunctors","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁸ : CategoryTheory.Category.{u_6, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_7, u_2} D\ninst✝⁶ : CategoryTheory.Category.{u_8, u_3} E\nA : Type u_5\ninst✝⁵ : AddMonoid A\ninst✝⁴ : CategoryTheory.HasShift D A\ninst✝³ : CategoryTheory.HasShift E A\nF : CategoryTheory.SingleFunctors C D A\nG G' : CategoryTheory.Functor D E\ne : CategoryTheory.Iso G G'\ninst✝² : G.CommShift A\ninst✝¹ : G'.CommShift A\ninst✝ : CategoryTheory.NatTrans.CommShift e.hom A\na : A\nX : C\n⊢ Eq (((F.postcompIsoOfIso e).hom.hom a).app X) (e.hom.app ((F.functor a).obj X))","decl":"/-- The isomorphism `F.postcomp G ≅ F.postcomp G'` induced by an isomorphism `e : G ≅ G'`\nwhich commutes with the shift. -/\n@[simps!]\ndef postcompIsoOfIso {G G' : D ⥤ E} (e : G ≅ G') [G.CommShift A] [G'.CommShift A]\n    [NatTrans.CommShift e.hom A] :\n    F.postcomp G ≅ F.postcomp G' :=\n  isoMk (fun a => isoWhiskerLeft (F.functor a) e) (fun n a a' ha' => by\n    ext X\n    dsimp\n    simp [NatTrans.shift_app e.hom n])\n\n"}
