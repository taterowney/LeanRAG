{"name":"Algebra.adjoin_restrictScalars","module":"Mathlib.RingTheory.Adjoin.Tower","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\ninst✝⁶ : CommSemiring C\ninst✝⁵ : CommSemiring D\ninst✝⁴ : CommSemiring E\ninst✝³ : Algebra C D\ninst✝² : Algebra C E\ninst✝¹ : Algebra D E\ninst✝ : IsScalarTower C D E\nS : Set E\n⊢ Eq (Subalgebra.restrictScalars C (Algebra.adjoin D S)) (Subalgebra.restrictScalars C (Algebra.adjoin (Subtype fun x => Membership.mem (Subalgebra.map (IsScalarTower.toAlgHom C D E) Top.top) x) S))","decl":"theorem adjoin_restrictScalars (C D E : Type*) [CommSemiring C] [CommSemiring D] [CommSemiring E]\n    [Algebra C D] [Algebra C E] [Algebra D E] [IsScalarTower C D E] (S : Set E) :\n    (Algebra.adjoin D S).restrictScalars C =\n      (Algebra.adjoin ((⊤ : Subalgebra C D).map (IsScalarTower.toAlgHom C D E)) S).restrictScalars\n        C := by\n  suffices\n    Set.range (algebraMap D E) =\n      Set.range (algebraMap ((⊤ : Subalgebra C D).map (IsScalarTower.toAlgHom C D E)) E) by\n    ext x\n    change x ∈ Subsemiring.closure (_ ∪ S) ↔ x ∈ Subsemiring.closure (_ ∪ S)\n    rw [this]\n  ext x\n  constructor\n  · rintro ⟨y, hy⟩\n    exact ⟨⟨algebraMap D E y, ⟨y, ⟨Algebra.mem_top, rfl⟩⟩⟩, hy⟩\n  · rintro ⟨⟨y, ⟨z, ⟨h0, h1⟩⟩⟩, h2⟩\n    exact ⟨z, Eq.trans h1 h2⟩\n\n"}
{"name":"Algebra.adjoin_res_eq_adjoin_res","module":"Mathlib.RingTheory.Adjoin.Tower","initialProofState":"C : Type u_1\nD : Type u_2\nE : Type u_3\nF : Type u_4\ninst✝¹⁰ : CommSemiring C\ninst✝⁹ : CommSemiring D\ninst✝⁸ : CommSemiring E\ninst✝⁷ : CommSemiring F\ninst✝⁶ : Algebra C D\ninst✝⁵ : Algebra C E\ninst✝⁴ : Algebra C F\ninst✝³ : Algebra D F\ninst✝² : Algebra E F\ninst✝¹ : IsScalarTower C D F\ninst✝ : IsScalarTower C E F\nS : Set D\nT : Set E\nhS : Eq (Algebra.adjoin C S) Top.top\nhT : Eq (Algebra.adjoin C T) Top.top\n⊢ Eq (Subalgebra.restrictScalars C (Algebra.adjoin E (Set.image (⇑(algebraMap D F)) S))) (Subalgebra.restrictScalars C (Algebra.adjoin D (Set.image (⇑(algebraMap E F)) T)))","decl":"theorem adjoin_res_eq_adjoin_res (C D E F : Type*) [CommSemiring C] [CommSemiring D]\n    [CommSemiring E] [CommSemiring F] [Algebra C D] [Algebra C E] [Algebra C F] [Algebra D F]\n    [Algebra E F] [IsScalarTower C D F] [IsScalarTower C E F] {S : Set D} {T : Set E}\n    (hS : Algebra.adjoin C S = ⊤) (hT : Algebra.adjoin C T = ⊤) :\n    (Algebra.adjoin E (algebraMap D F '' S)).restrictScalars C =\n      (Algebra.adjoin D (algebraMap E F '' T)).restrictScalars C := by\n  rw [adjoin_restrictScalars C E, adjoin_restrictScalars C D, ← hS, ← hT, ← Algebra.adjoin_image,\n    ← Algebra.adjoin_image, ← AlgHom.coe_toRingHom, ← AlgHom.coe_toRingHom,\n    IsScalarTower.coe_toAlgHom, IsScalarTower.coe_toAlgHom, ← adjoin_union_eq_adjoin_adjoin, ←\n    adjoin_union_eq_adjoin_adjoin, Set.union_comm]\n\n"}
{"name":"Algebra.fg_trans'","module":"Mathlib.RingTheory.Adjoin.Tower","initialProofState":"R : Type u_1\nS : Type u_2\nA : Type u_3\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Semiring A\ninst✝³ : Algebra R S\ninst✝² : Algebra S A\ninst✝¹ : Algebra R A\ninst✝ : IsScalarTower R S A\nhRS : Top.top.FG\nhSA : Top.top.FG\n⊢ Top.top.FG","decl":"theorem Algebra.fg_trans' {R S A : Type*} [CommSemiring R] [CommSemiring S] [Semiring A]\n    [Algebra R S] [Algebra S A] [Algebra R A] [IsScalarTower R S A] (hRS : (⊤ : Subalgebra R S).FG)\n    (hSA : (⊤ : Subalgebra S A).FG) : (⊤ : Subalgebra R A).FG := by\n  classical\n  rcases hRS with ⟨s, hs⟩\n  rcases hSA with ⟨t, ht⟩\n  exact ⟨s.image (algebraMap S A) ∪ t, by\n    rw [Finset.coe_union, Finset.coe_image,\n        Algebra.adjoin_algebraMap_image_union_eq_adjoin_adjoin,\n        hs, Algebra.adjoin_top, ht, Subalgebra.restrictScalars_top,\n        Subalgebra.restrictScalars_top\n       ]\n    ⟩\n"}
{"name":"exists_subalgebra_of_fg","module":"Mathlib.RingTheory.Adjoin.Tower","initialProofState":"A : Type w\nB : Type u₁\nC : Type u_1\ninst✝⁶ : CommSemiring A\ninst✝⁵ : CommSemiring B\ninst✝⁴ : Semiring C\ninst✝³ : Algebra A B\ninst✝² : Algebra B C\ninst✝¹ : Algebra A C\ninst✝ : IsScalarTower A B C\nhAC : Top.top.FG\nhBC : Top.top.FG\n⊢ Exists fun B₀ => And B₀.FG Top.top.FG","decl":"theorem exists_subalgebra_of_fg (hAC : (⊤ : Subalgebra A C).FG) (hBC : (⊤ : Submodule B C).FG) :\n    ∃ B₀ : Subalgebra A B, B₀.FG ∧ (⊤ : Submodule B₀ C).FG := by\n  cases' hAC with x hx\n  cases' hBC with y hy\n  have := hy\n  simp_rw [eq_top_iff', mem_span_finset] at this\n  choose f hf using this\n  classical\n  let s : Finset B := Finset.image₂ f (x ∪ y * y) y\n  have hxy :\n    ∀ xi ∈ x, xi ∈ span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) :=\n    fun xi hxi =>\n    hf xi ▸\n      sum_mem fun yj hyj =>\n        smul_mem (span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C))\n          ⟨f xi yj, Algebra.subset_adjoin <| mem_image₂_of_mem (mem_union_left _ hxi) hyj⟩\n          (subset_span <| mem_insert_of_mem hyj)\n  have hyy :\n    span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) *\n        span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) ≤\n      span (Algebra.adjoin A (↑s : Set B)) (↑(insert 1 y : Finset C) : Set C) := by\n    rw [span_mul_span, span_le, coe_insert]\n    rintro _ ⟨yi, rfl | hyi, yj, rfl | hyj, rfl⟩ <;> dsimp\n    · rw [mul_one]\n      exact subset_span (Set.mem_insert _ _)\n    · rw [one_mul]\n      exact subset_span (Set.mem_insert_of_mem _ hyj)\n    · rw [mul_one]\n      exact subset_span (Set.mem_insert_of_mem _ hyi)\n    · rw [← hf (yi * yj)]\n      exact\n        SetLike.mem_coe.2\n          (sum_mem fun yk hyk =>\n            smul_mem (span (Algebra.adjoin A (↑s : Set B)) (insert 1 ↑y : Set C))\n              ⟨f (yi * yj) yk,\n                Algebra.subset_adjoin <|\n                  mem_image₂_of_mem (mem_union_right _ <| mul_mem_mul hyi hyj) hyk⟩\n              (subset_span <| Set.mem_insert_of_mem _ hyk : yk ∈ _))\n  refine ⟨Algebra.adjoin A (↑s : Set B), Subalgebra.fg_adjoin_finset _, insert 1 y, ?_⟩\n  convert restrictScalars_injective A (Algebra.adjoin A (s : Set B)) C _\n  rw [restrictScalars_top, eq_top_iff, ← Algebra.top_toSubmodule, ← hx, Algebra.adjoin_eq_span,\n    span_le]\n  refine fun r hr =>\n    Submonoid.closure_induction (fun c hc => hxy c hc) (subset_span <| mem_insert_self _ _)\n      (fun p q _ _ hp hq => hyy <| Submodule.mul_mem_mul hp hq) hr\n\n"}
{"name":"fg_of_fg_of_fg","module":"Mathlib.RingTheory.Adjoin.Tower","initialProofState":"A : Type w\nB : Type u₁\nC : Type u_1\ninst✝⁷ : CommRing A\ninst✝⁶ : CommRing B\ninst✝⁵ : CommRing C\ninst✝⁴ : Algebra A B\ninst✝³ : Algebra B C\ninst✝² : Algebra A C\ninst✝¹ : IsScalarTower A B C\ninst✝ : IsNoetherianRing A\nhAC : Top.top.FG\nhBC : Top.top.FG\nhBCi : Function.Injective ⇑(algebraMap B C)\n⊢ Top.top.FG","decl":"/-- **Artin--Tate lemma**: if A ⊆ B ⊆ C is a chain of subrings of commutative rings, and\nA is noetherian, and C is algebra-finite over A, and C is module-finite over B,\nthen B is algebra-finite over A.\n\nReferences: Atiyah--Macdonald Proposition 7.8; Altman--Kleiman 16.17. -/\n@[stacks 00IS]\ntheorem fg_of_fg_of_fg [IsNoetherianRing A] (hAC : (⊤ : Subalgebra A C).FG)\n    (hBC : (⊤ : Submodule B C).FG) (hBCi : Function.Injective (algebraMap B C)) :\n    (⊤ : Subalgebra A B).FG :=\n  let ⟨B₀, hAB₀, hB₀C⟩ := exists_subalgebra_of_fg A B C hAC hBC\n  Algebra.fg_trans' (B₀.fg_top.2 hAB₀) <|\n    Subalgebra.fg_of_submodule_fg <|\n      have : IsNoetherianRing B₀ := isNoetherianRing_of_fg hAB₀\n      have : Module.Finite B₀ C := ⟨hB₀C⟩\n      fg_of_injective (IsScalarTower.toAlgHom B₀ B C).toLinearMap hBCi\n\n"}
