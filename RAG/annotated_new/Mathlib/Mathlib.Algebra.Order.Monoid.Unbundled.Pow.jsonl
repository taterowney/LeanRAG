{"name":"Left.nsmul_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le 0 a\nn : Nat\n⊢ LE.le 0 (HSMul.hSMul n a)","decl":"@[to_additive Left.nsmul_nonneg]\ntheorem one_le_pow_of_le (ha : 1 ≤ a) : ∀ n : ℕ, 1 ≤ a ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ]\n    exact one_le_mul (one_le_pow_of_le ha k) ha\n\n"}
{"name":"Left.one_le_pow_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nha : LE.le 1 a\nn : Nat\n⊢ LE.le 1 (HPow.hPow a n)","decl":"@[to_additive Left.nsmul_nonneg]\ntheorem one_le_pow_of_le (ha : 1 ≤ a) : ∀ n : ℕ, 1 ≤ a ^ n\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ]\n    exact one_le_mul (one_le_pow_of_le ha k) ha\n\n"}
{"name":"Left.pow_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le 0 a\nn : Nat\n⊢ LE.le 0 (HSMul.hSMul n a)","decl":"@[deprecated (since := \"2024-09-21\")] alias pow_nonneg := nsmul_nonneg\n\n"}
{"name":"Left.pow_le_one_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nha : LE.le a 1\nn : Nat\n⊢ LE.le (HPow.hPow a n) 1","decl":"@[to_additive nsmul_nonpos]\ntheorem pow_le_one_of_le (ha : a ≤ 1) (n : ℕ) : a ^ n ≤ 1 := one_le_pow_of_le (M := Mᵒᵈ) ha n\n\n"}
{"name":"Left.nsmul_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le a 0\nn : Nat\n⊢ LE.le (HSMul.hSMul n a) 0","decl":"@[to_additive nsmul_nonpos]\ntheorem pow_le_one_of_le (ha : a ≤ 1) (n : ℕ) : a ^ n ≤ 1 := one_le_pow_of_le (M := Mᵒᵈ) ha n\n\n"}
{"name":"Left.pow_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le a 0\nn : Nat\n⊢ LE.le (HSMul.hSMul n a) 0","decl":"@[deprecated (since := \"2024-09-21\")] alias pow_nonpos := nsmul_nonpos\n\n"}
{"name":"Left.nsmul_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nn : Nat\nh : LT.lt a 0\nhn : Ne n 0\n⊢ LT.lt (HSMul.hSMul n a) 0","decl":"@[to_additive nsmul_neg]\ntheorem pow_lt_one_of_lt {a : M} {n : ℕ} (h : a < 1) (hn : n ≠ 0) : a ^ n < 1 := by\n  rcases Nat.exists_eq_succ_of_ne_zero hn with ⟨k, rfl⟩\n  rw [pow_succ']\n  exact mul_lt_one_of_lt_of_le h (pow_le_one_of_le h.le _)\n\n"}
{"name":"Left.pow_lt_one_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nn : Nat\nh : LT.lt a 1\nhn : Ne n 0\n⊢ LT.lt (HPow.hPow a n) 1","decl":"@[to_additive nsmul_neg]\ntheorem pow_lt_one_of_lt {a : M} {n : ℕ} (h : a < 1) (hn : n ≠ 0) : a ^ n < 1 := by\n  rcases Nat.exists_eq_succ_of_ne_zero hn with ⟨k, rfl⟩\n  rw [pow_succ']\n  exact mul_lt_one_of_lt_of_le h (pow_le_one_of_le h.le _)\n\n"}
{"name":"Left.pow_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nn : Nat\nh : LT.lt a 0\nhn : Ne n 0\n⊢ LT.lt (HSMul.hSMul n a) 0","decl":"@[deprecated (since := \"2024-09-21\")] alias pow_neg := nsmul_neg\n\n"}
{"name":"nsmul_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le 0 a\nn : Nat\n⊢ LE.le 0 (HSMul.hSMul n a)","decl":"@[to_additive nsmul_nonneg] alias one_le_pow_of_one_le' := Left.one_le_pow_of_le\n"}
{"name":"one_le_pow_of_one_le'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nha : LE.le 1 a\nn : Nat\n⊢ LE.le 1 (HPow.hPow a n)","decl":"@[to_additive nsmul_nonneg] alias one_le_pow_of_one_le' := Left.one_le_pow_of_le\n"}
{"name":"nsmul_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le a 0\nn : Nat\n⊢ LE.le (HSMul.hSMul n a) 0","decl":"@[to_additive nsmul_nonpos] alias pow_le_one' := Left.pow_le_one_of_le\n"}
{"name":"pow_le_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nha : LE.le a 1\nn : Nat\n⊢ LE.le (HPow.hPow a n) 1","decl":"@[to_additive nsmul_nonpos] alias pow_le_one' := Left.pow_le_one_of_le\n"}
{"name":"pow_lt_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nn : Nat\nh : LT.lt a 1\nhn : Ne n 0\n⊢ LT.lt (HPow.hPow a n) 1","decl":"@[to_additive nsmul_neg] alias pow_lt_one' := Left.pow_lt_one_of_lt\n\n"}
{"name":"nsmul_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nn : Nat\nh : LT.lt a 0\nhn : Ne n 0\n⊢ LT.lt (HSMul.hSMul n a) 0","decl":"@[to_additive nsmul_neg] alias pow_lt_one' := Left.pow_lt_one_of_lt\n\n"}
{"name":"pow_right_monotone","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nha : LE.le 1 a\n⊢ Monotone fun n => HPow.hPow a n","decl":"@[to_additive nsmul_left_monotone]\ntheorem pow_right_monotone (ha : 1 ≤ a) : Monotone fun n : ℕ ↦ a ^ n :=\n  monotone_nat_of_le_succ fun n ↦ by rw [pow_succ]; exact le_mul_of_one_le_right' ha\n\n"}
{"name":"nsmul_left_monotone","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LE.le 0 a\n⊢ Monotone fun n => HSMul.hSMul n a","decl":"@[to_additive nsmul_left_monotone]\ntheorem pow_right_monotone (ha : 1 ≤ a) : Monotone fun n : ℕ ↦ a ^ n :=\n  monotone_nat_of_le_succ fun n ↦ by rw [pow_succ]; exact le_mul_of_one_le_right' ha\n\n"}
{"name":"pow_le_pow_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nn m : Nat\nha : LE.le 1 a\nh : LE.le n m\n⊢ LE.le (HPow.hPow a n) (HPow.hPow a m)","decl":"@[to_additive (attr := gcongr) nsmul_le_nsmul_left]\ntheorem pow_le_pow_right' {n m : ℕ} (ha : 1 ≤ a) (h : n ≤ m) : a ^ n ≤ a ^ m :=\n  pow_right_monotone ha h\n\n"}
{"name":"nsmul_le_nsmul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nn m : Nat\nha : LE.le 0 a\nh : LE.le n m\n⊢ LE.le (HSMul.hSMul n a) (HSMul.hSMul m a)","decl":"@[to_additive (attr := gcongr) nsmul_le_nsmul_left]\ntheorem pow_le_pow_right' {n m : ℕ} (ha : 1 ≤ a) (h : n ≤ m) : a ^ n ≤ a ^ m :=\n  pow_right_monotone ha h\n\n"}
{"name":"nsmul_le_nsmul_left_of_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nn m : Nat\nha : LE.le a 0\nh : LE.le n m\n⊢ LE.le (HSMul.hSMul m a) (HSMul.hSMul n a)","decl":"@[to_additive nsmul_le_nsmul_left_of_nonpos]\ntheorem pow_le_pow_right_of_le_one' {n m : ℕ} (ha : a ≤ 1) (h : n ≤ m) : a ^ m ≤ a ^ n :=\n  pow_le_pow_right' (M := Mᵒᵈ) ha h\n\n"}
{"name":"pow_le_pow_right_of_le_one'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nn m : Nat\nha : LE.le a 1\nh : LE.le n m\n⊢ LE.le (HPow.hPow a m) (HPow.hPow a n)","decl":"@[to_additive nsmul_le_nsmul_left_of_nonpos]\ntheorem pow_le_pow_right_of_le_one' {n m : ℕ} (ha : a ≤ 1) (h : n ≤ m) : a ^ m ≤ a ^ n :=\n  pow_le_pow_right' (M := Mᵒᵈ) ha h\n\n"}
{"name":"nsmul_pos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nha : LT.lt 0 a\nk : Nat\nhk : Ne k 0\n⊢ LT.lt 0 (HSMul.hSMul k a)","decl":"@[to_additive nsmul_pos]\ntheorem one_lt_pow' (ha : 1 < a) {k : ℕ} (hk : k ≠ 0) : 1 < a ^ k :=\n  pow_lt_one' (M := Mᵒᵈ) ha hk\n\n"}
{"name":"one_lt_pow'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nha : LT.lt 1 a\nk : Nat\nhk : Ne k 0\n⊢ LT.lt 1 (HPow.hPow a k)","decl":"@[to_additive nsmul_pos]\ntheorem one_lt_pow' (ha : 1 < a) {k : ℕ} (hk : k ≠ 0) : 1 < a ^ k :=\n  pow_lt_one' (M := Mᵒᵈ) ha hk\n\n"}
{"name":"le_self_pow","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftMono M\na : M\nn : Nat\nha : LE.le 1 a\nhn : Ne n 0\n⊢ LE.le a (HPow.hPow a n)","decl":"@[to_additive]\nlemma le_self_pow (ha : 1 ≤ a) (hn : n ≠ 0) : a ≤ a ^ n := by\n  simpa using pow_le_pow_right' ha (Nat.one_le_iff_ne_zero.2 hn)\n\n"}
{"name":"le_self_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftMono M\na : M\nn : Nat\nha : LE.le 0 a\nhn : Ne n 0\n⊢ LE.le a (HSMul.hSMul n a)","decl":"@[to_additive]\nlemma le_self_pow (ha : 1 ≤ a) (hn : n ≠ 0) : a ≤ a ^ n := by\n  simpa using pow_le_pow_right' ha (Nat.one_le_iff_ne_zero.2 hn)\n\n"}
{"name":"nsmul_left_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftStrictMono M\na : M\nha : LT.lt 0 a\n⊢ StrictMono fun x => HSMul.hSMul x a","decl":"@[to_additive nsmul_left_strictMono]\ntheorem pow_right_strictMono' (ha : 1 < a) : StrictMono ((a ^ ·) : ℕ → M) :=\n  strictMono_nat_of_lt_succ fun n ↦ by rw [pow_succ]; exact lt_mul_of_one_lt_right' (a ^ n) ha\n\n"}
{"name":"pow_right_strictMono'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftStrictMono M\na : M\nha : LT.lt 1 a\n⊢ StrictMono fun x => HPow.hPow a x","decl":"@[to_additive nsmul_left_strictMono]\ntheorem pow_right_strictMono' (ha : 1 < a) : StrictMono ((a ^ ·) : ℕ → M) :=\n  strictMono_nat_of_lt_succ fun n ↦ by rw [pow_succ]; exact lt_mul_of_one_lt_right' (a ^ n) ha\n\n"}
{"name":"nsmul_lt_nsmul_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftStrictMono M\na : M\nn m : Nat\nha : LT.lt 0 a\nh : LT.lt n m\n⊢ LT.lt (HSMul.hSMul n a) (HSMul.hSMul m a)","decl":"@[to_additive (attr := gcongr) nsmul_lt_nsmul_left]\ntheorem pow_lt_pow_right' (ha : 1 < a) (h : n < m) : a ^ n < a ^ m :=\n  pow_right_strictMono' ha h\n\n"}
{"name":"pow_lt_pow_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulLeftStrictMono M\na : M\nn m : Nat\nha : LT.lt 1 a\nh : LT.lt n m\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow a m)","decl":"@[to_additive (attr := gcongr) nsmul_lt_nsmul_left]\ntheorem pow_lt_pow_right' (ha : 1 < a) (h : n < m) : a ^ n < a ^ m :=\n  pow_right_strictMono' ha h\n\n"}
{"name":"Right.one_le_pow_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulRightMono M\nx : M\nhx : LE.le 1 x\nn : Nat\n⊢ LE.le 1 (HPow.hPow x n)","decl":"@[to_additive Right.nsmul_nonneg]\ntheorem Right.one_le_pow_of_le (hx : 1 ≤ x) : ∀ {n : ℕ}, 1 ≤ x ^ n\n  | 0 => (pow_zero _).ge\n  | n + 1 => by\n    rw [pow_succ]\n    exact Right.one_le_mul (Right.one_le_pow_of_le hx) hx\n\n"}
{"name":"Right.nsmul_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddRightMono M\nx : M\nhx : LE.le 0 x\nn : Nat\n⊢ LE.le 0 (HSMul.hSMul n x)","decl":"@[to_additive Right.nsmul_nonneg]\ntheorem Right.one_le_pow_of_le (hx : 1 ≤ x) : ∀ {n : ℕ}, 1 ≤ x ^ n\n  | 0 => (pow_zero _).ge\n  | n + 1 => by\n    rw [pow_succ]\n    exact Right.one_le_mul (Right.one_le_pow_of_le hx) hx\n\n"}
{"name":"Right.pow_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddRightMono M\nx : M\nhx : LE.le 0 x\nn : Nat\n⊢ LE.le 0 (HSMul.hSMul n x)","decl":"@[deprecated (since := \"2024-09-21\")] alias Right.pow_nonneg := Right.nsmul_nonneg\n\n"}
{"name":"Right.nsmul_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddRightMono M\nx : M\nhx : LE.le x 0\nn : Nat\n⊢ LE.le (HSMul.hSMul n x) 0","decl":"@[to_additive Right.nsmul_nonpos]\ntheorem Right.pow_le_one_of_le (hx : x ≤ 1) {n : ℕ} : x ^ n ≤ 1 :=\n  Right.one_le_pow_of_le (M := Mᵒᵈ) hx\n\n"}
{"name":"Right.pow_le_one_of_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulRightMono M\nx : M\nhx : LE.le x 1\nn : Nat\n⊢ LE.le (HPow.hPow x n) 1","decl":"@[to_additive Right.nsmul_nonpos]\ntheorem Right.pow_le_one_of_le (hx : x ≤ 1) {n : ℕ} : x ^ n ≤ 1 :=\n  Right.one_le_pow_of_le (M := Mᵒᵈ) hx\n\n"}
{"name":"Right.pow_nonpos","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddRightMono M\nx : M\nhx : LE.le x 0\nn : Nat\n⊢ LE.le (HSMul.hSMul n x) 0","decl":"@[deprecated (since := \"2024-09-21\")] alias Right.pow_nonpos := Right.nsmul_nonpos\n\n"}
{"name":"Right.nsmul_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddRightMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\nh : LT.lt x 0\n⊢ LT.lt (HSMul.hSMul n x) 0","decl":"@[to_additive Right.nsmul_neg]\ntheorem Right.pow_lt_one_of_lt {n : ℕ} {x : M} (hn : 0 < n) (h : x < 1) : x ^ n < 1 := by\n  rcases Nat.exists_eq_succ_of_ne_zero hn.ne' with ⟨k, rfl⟩\n  rw [pow_succ]\n  exact mul_lt_one_of_le_of_lt (pow_le_one_of_le h.le) h\n\n"}
{"name":"Right.pow_lt_one_of_lt","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : Preorder M\ninst✝ : MulRightMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\nh : LT.lt x 1\n⊢ LT.lt (HPow.hPow x n) 1","decl":"@[to_additive Right.nsmul_neg]\ntheorem Right.pow_lt_one_of_lt {n : ℕ} {x : M} (hn : 0 < n) (h : x < 1) : x ^ n < 1 := by\n  rcases Nat.exists_eq_succ_of_ne_zero hn.ne' with ⟨k, rfl⟩\n  rw [pow_succ]\n  exact mul_lt_one_of_le_of_lt (pow_le_one_of_le h.le) h\n\n"}
{"name":"Right.pow_neg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddRightMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\nh : LT.lt x 0\n⊢ LT.lt (HSMul.hSMul n x) 0","decl":"@[deprecated (since := \"2024-09-21\")] alias Right.pow_neg := Right.nsmul_neg\n\n"}
{"name":"nsmul_le_nsmul_add_of_sq_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddRightMono M\ninst✝ : AddLeftMono M\na b : M\nhab : LE.le (HSMul.hSMul 2 a) (HAdd.hAdd b a)\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (HSMul.hSMul n a) (HAdd.hAdd (HSMul.hSMul (HSub.hSub n 1) b) a)","decl":"/-- This lemma is useful in non-cancellative monoids, like sets under pointwise operations. -/\n@[to_additive\n\"This lemma is useful in non-cancellative monoids, like sets under pointwise operations.\"]\nlemma pow_le_pow_mul_of_sq_le_mul [MulLeftMono M] {a b : M} (hab : a ^ 2 ≤ b * a) :\n    ∀ {n}, n ≠ 0 → a ^ n ≤ b ^ (n - 1) * a\n  | 1, _ => by simp\n  | n + 2, _ => by\n    calc\n      a ^ (n + 2) = a ^ (n + 1) * a := by rw [pow_succ]\n      _ ≤ b ^ n * a * a := mul_le_mul_right' (pow_le_pow_mul_of_sq_le_mul hab (by omega)) _\n      _ = b ^ n * a ^ 2 := by rw [mul_assoc, sq]\n      _ ≤ b ^ n * (b * a) := mul_le_mul_left' hab _\n      _ = b ^ (n + 1) * a := by rw [← mul_assoc, ← pow_succ]\n\n"}
{"name":"pow_le_pow_mul_of_sq_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulRightMono M\ninst✝ : MulLeftMono M\na b : M\nhab : LE.le (HPow.hPow a 2) (HMul.hMul b a)\nn : Nat\na✝ : Ne n 0\n⊢ LE.le (HPow.hPow a n) (HMul.hMul (HPow.hPow b (HSub.hSub n 1)) a)","decl":"/-- This lemma is useful in non-cancellative monoids, like sets under pointwise operations. -/\n@[to_additive\n\"This lemma is useful in non-cancellative monoids, like sets under pointwise operations.\"]\nlemma pow_le_pow_mul_of_sq_le_mul [MulLeftMono M] {a b : M} (hab : a ^ 2 ≤ b * a) :\n    ∀ {n}, n ≠ 0 → a ^ n ≤ b ^ (n - 1) * a\n  | 1, _ => by simp\n  | n + 2, _ => by\n    calc\n      a ^ (n + 2) = a ^ (n + 1) * a := by rw [pow_succ]\n      _ ≤ b ^ n * a * a := mul_le_mul_right' (pow_le_pow_mul_of_sq_le_mul hab (by omega)) _\n      _ = b ^ n * a ^ 2 := by rw [mul_assoc, sq]\n      _ ≤ b ^ n * (b * a) := mul_le_mul_left' hab _\n      _ = b ^ (n + 1) * a := by rw [← mul_assoc, ← pow_succ]\n\n"}
{"name":"StrictMono.const_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"β : Type u_1\nM : Type u_3\ninst✝⁴ : AddMonoid M\ninst✝³ : Preorder M\ninst✝² : Preorder β\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\nf : β → M\nhf : StrictMono f\nn : Nat\na✝ : Ne n 0\n⊢ StrictMono fun x => HSMul.hSMul n (f x)","decl":"@[to_additive StrictMono.const_nsmul]\ntheorem StrictMono.pow_const (hf : StrictMono f) : ∀ {n : ℕ}, n ≠ 0 → StrictMono (f · ^ n)\n  | 0, hn => (hn rfl).elim\n  | 1, _ => by simpa\n  | Nat.succ <| Nat.succ n, _ => by\n    simpa only [pow_succ] using (hf.pow_const n.succ_ne_zero).mul' hf\n\n"}
{"name":"StrictMono.pow_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"β : Type u_1\nM : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : Preorder M\ninst✝² : Preorder β\ninst✝¹ : MulLeftStrictMono M\ninst✝ : MulRightStrictMono M\nf : β → M\nhf : StrictMono f\nn : Nat\na✝ : Ne n 0\n⊢ StrictMono fun x => HPow.hPow (f x) n","decl":"@[to_additive StrictMono.const_nsmul]\ntheorem StrictMono.pow_const (hf : StrictMono f) : ∀ {n : ℕ}, n ≠ 0 → StrictMono (f · ^ n)\n  | 0, hn => (hn rfl).elim\n  | 1, _ => by simpa\n  | Nat.succ <| Nat.succ n, _ => by\n    simpa only [pow_succ] using (hf.pow_const n.succ_ne_zero).mul' hf\n\n"}
{"name":"nsmul_right_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\nn : Nat\nhn : Ne n 0\n⊢ StrictMono fun x => HSMul.hSMul n x","decl":"/-- See also `pow_left_strictMonoOn₀`. -/\n@[to_additive nsmul_right_strictMono]  -- Porting note: nolint to_additive_doc\ntheorem pow_left_strictMono (hn : n ≠ 0) : StrictMono (· ^ n : M → M) := strictMono_id.pow_const hn\n\n"}
{"name":"pow_left_strictMono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulLeftStrictMono M\ninst✝ : MulRightStrictMono M\nn : Nat\nhn : Ne n 0\n⊢ StrictMono fun x => HPow.hPow x n","decl":"/-- See also `pow_left_strictMonoOn₀`. -/\n@[to_additive nsmul_right_strictMono]  -- Porting note: nolint to_additive_doc\ntheorem pow_left_strictMono (hn : n ≠ 0) : StrictMono (· ^ n : M → M) := strictMono_id.pow_const hn\n\n"}
{"name":"nsmul_lt_nsmul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\nn : Nat\nhn : Ne n 0\na b : M\nhab : LT.lt a b\n⊢ LT.lt (HSMul.hSMul n a) (HSMul.hSMul n b)","decl":"@[to_additive (attr := mono, gcongr) nsmul_lt_nsmul_right]\nlemma pow_lt_pow_left' (hn : n ≠ 0) {a b : M} (hab : a < b) : a ^ n < b ^ n :=\n  pow_left_strictMono hn hab\n\n"}
{"name":"pow_lt_pow_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulLeftStrictMono M\ninst✝ : MulRightStrictMono M\nn : Nat\nhn : Ne n 0\na b : M\nhab : LT.lt a b\n⊢ LT.lt (HPow.hPow a n) (HPow.hPow b n)","decl":"@[to_additive (attr := mono, gcongr) nsmul_lt_nsmul_right]\nlemma pow_lt_pow_left' (hn : n ≠ 0) {a b : M} (hab : a < b) : a ^ n < b ^ n :=\n  pow_left_strictMono hn hab\n\n"}
{"name":"pow_le_pow_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b : M\nhab : LE.le a b\ni : Nat\n⊢ LE.le (HPow.hPow a i) (HPow.hPow b i)","decl":"@[to_additive (attr := mono, gcongr) nsmul_le_nsmul_right]\ntheorem pow_le_pow_left' {a b : M} (hab : a ≤ b) : ∀ i : ℕ, a ^ i ≤ b ^ i\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ]\n    exact mul_le_mul' (pow_le_pow_left' hab k) hab\n\n"}
{"name":"nsmul_le_nsmul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\na b : M\nhab : LE.le a b\ni : Nat\n⊢ LE.le (HSMul.hSMul i a) (HSMul.hSMul i b)","decl":"@[to_additive (attr := mono, gcongr) nsmul_le_nsmul_right]\ntheorem pow_le_pow_left' {a b : M} (hab : a ≤ b) : ∀ i : ℕ, a ^ i ≤ b ^ i\n  | 0 => by simp\n  | k + 1 => by\n    rw [pow_succ, pow_succ]\n    exact mul_le_mul' (pow_le_pow_left' hab k) hab\n\n"}
{"name":"Monotone.pow_const","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"β : Type u_1\nM : Type u_3\ninst✝⁴ : Monoid M\ninst✝³ : Preorder M\ninst✝² : Preorder β\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\nf : β → M\nhf : Monotone f\nn : Nat\n⊢ Monotone fun a => HPow.hPow (f a) n","decl":"@[to_additive Monotone.const_nsmul]\ntheorem Monotone.pow_const {f : β → M} (hf : Monotone f) : ∀ n : ℕ, Monotone fun a => f a ^ n\n  | 0 => by simpa using monotone_const\n  | n + 1 => by\n    simp_rw [pow_succ]\n    exact (Monotone.pow_const hf _).mul' hf\n\n"}
{"name":"Monotone.const_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"β : Type u_1\nM : Type u_3\ninst✝⁴ : AddMonoid M\ninst✝³ : Preorder M\ninst✝² : Preorder β\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\nf : β → M\nhf : Monotone f\nn : Nat\n⊢ Monotone fun a => HSMul.hSMul n (f a)","decl":"@[to_additive Monotone.const_nsmul]\ntheorem Monotone.pow_const {f : β → M} (hf : Monotone f) : ∀ n : ℕ, Monotone fun a => f a ^ n\n  | 0 => by simpa using monotone_const\n  | n + 1 => by\n    simp_rw [pow_succ]\n    exact (Monotone.pow_const hf _).mul' hf\n\n"}
{"name":"nsmul_right_mono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\nn : Nat\n⊢ Monotone fun a => HSMul.hSMul n a","decl":"@[to_additive nsmul_right_mono]\ntheorem pow_left_mono (n : ℕ) : Monotone fun a : M => a ^ n := monotone_id.pow_const _\n\n"}
{"name":"pow_left_mono","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\nn : Nat\n⊢ Monotone fun a => HPow.hPow a n","decl":"@[to_additive nsmul_right_mono]\ntheorem pow_left_mono (n : ℕ) : Monotone fun a : M => a ^ n := monotone_id.pow_const _\n\n"}
{"name":"pow_le_pow","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : Preorder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b : M\nhab : LE.le a b\nht : LE.le 1 b\nm n : Nat\nhmn : LE.le m n\n⊢ LE.le (HPow.hPow a m) (HPow.hPow b n)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_le_pow {a b : M} (hab : a ≤ b) (ht : 1 ≤ b) {m n : ℕ} (hmn : m ≤ n) : a ^ m ≤ b ^ n :=\n  (pow_le_pow_left' hab _).trans (pow_le_pow_right' ht hmn)\n\n"}
{"name":"nsmul_le_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\na b : M\nhab : LE.le a b\nht : LE.le 0 b\nm n : Nat\nhmn : LE.le m n\n⊢ LE.le (HSMul.hSMul m a) (HSMul.hSMul n b)","decl":"@[to_additive (attr := gcongr)]\nlemma pow_le_pow {a b : M} (hab : a ≤ b) (ht : 1 ≤ b) {m n : ℕ} (hmn : m ≤ n) : a ^ m ≤ b ^ n :=\n  (pow_le_pow_left' hab _).trans (pow_le_pow_right' ht hmn)\n\n"}
{"name":"le_pow_sup","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : SemilatticeSup M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b : M\nn : Nat\n⊢ LE.le (Max.max (HPow.hPow a n) (HPow.hPow b n)) (HPow.hPow (Max.max a b) n)","decl":"lemma le_pow_sup : a ^ n ⊔ b ^ n ≤ (a ⊔ b) ^ n :=\n  sup_le (pow_le_pow_left' le_sup_left _) (pow_le_pow_left' le_sup_right _)\n\n"}
{"name":"pow_inf_le","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : SemilatticeInf M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b : M\nn : Nat\n⊢ LE.le (HPow.hPow (Min.min a b) n) (Min.min (HPow.hPow a n) (HPow.hPow b n))","decl":"lemma pow_inf_le : (a ⊓ b) ^ n ≤ a ^ n ⊓ b ^ n :=\n  le_inf (pow_le_pow_left' inf_le_left _) (pow_le_pow_left' inf_le_right _)\n\n"}
{"name":"nsmul_nonneg_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le 0 (HSMul.hSMul n x)) (LE.le 0 x)","decl":"@[to_additive nsmul_nonneg_iff]\ntheorem one_le_pow_iff {x : M} {n : ℕ} (hn : n ≠ 0) : 1 ≤ x ^ n ↔ 1 ≤ x :=\n  ⟨le_imp_le_of_lt_imp_lt fun h => pow_lt_one' h hn, fun h => one_le_pow_of_one_le' h n⟩\n\n"}
{"name":"one_le_pow_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le 1 (HPow.hPow x n)) (LE.le 1 x)","decl":"@[to_additive nsmul_nonneg_iff]\ntheorem one_le_pow_iff {x : M} {n : ℕ} (hn : n ≠ 0) : 1 ≤ x ^ n ↔ 1 ≤ x :=\n  ⟨le_imp_le_of_lt_imp_lt fun h => pow_lt_one' h hn, fun h => one_le_pow_of_one_le' h n⟩\n\n"}
{"name":"pow_le_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le (HPow.hPow x n) 1) (LE.le x 1)","decl":"@[to_additive]\ntheorem pow_le_one_iff {x : M} {n : ℕ} (hn : n ≠ 0) : x ^ n ≤ 1 ↔ x ≤ 1 :=\n  one_le_pow_iff (M := Mᵒᵈ) hn\n\n"}
{"name":"nsmul_nonpos_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LE.le (HSMul.hSMul n x) 0) (LE.le x 0)","decl":"@[to_additive]\ntheorem pow_le_one_iff {x : M} {n : ℕ} (hn : n ≠ 0) : x ^ n ≤ 1 ↔ x ≤ 1 :=\n  one_le_pow_iff (M := Mᵒᵈ) hn\n\n"}
{"name":"one_lt_pow_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt 1 (HPow.hPow x n)) (LT.lt 1 x)","decl":"@[to_additive nsmul_pos_iff]\ntheorem one_lt_pow_iff {x : M} {n : ℕ} (hn : n ≠ 0) : 1 < x ^ n ↔ 1 < x :=\n  lt_iff_lt_of_le_iff_le (pow_le_one_iff hn)\n\n"}
{"name":"nsmul_pos_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt 0 (HSMul.hSMul n x)) (LT.lt 0 x)","decl":"@[to_additive nsmul_pos_iff]\ntheorem one_lt_pow_iff {x : M} {n : ℕ} (hn : n ≠ 0) : 1 < x ^ n ↔ 1 < x :=\n  lt_iff_lt_of_le_iff_le (pow_le_one_iff hn)\n\n"}
{"name":"nsmul_neg_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt (HSMul.hSMul n x) 0) (LT.lt x 0)","decl":"@[to_additive]\ntheorem pow_lt_one_iff {x : M} {n : ℕ} (hn : n ≠ 0) : x ^ n < 1 ↔ x < 1 :=\n  lt_iff_lt_of_le_iff_le (one_le_pow_iff hn)\n\n"}
{"name":"pow_lt_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (LT.lt (HPow.hPow x n) 1) (LT.lt x 1)","decl":"@[to_additive]\ntheorem pow_lt_one_iff {x : M} {n : ℕ} (hn : n ≠ 0) : x ^ n < 1 ↔ x < 1 :=\n  lt_iff_lt_of_le_iff_le (one_le_pow_iff hn)\n\n"}
{"name":"nsmul_eq_zero_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HSMul.hSMul n x) 0) (Eq x 0)","decl":"@[to_additive]\ntheorem pow_eq_one_iff {x : M} {n : ℕ} (hn : n ≠ 0) : x ^ n = 1 ↔ x = 1 := by\n  simp only [le_antisymm_iff]\n  rw [pow_le_one_iff hn, one_le_pow_iff hn]\n\n"}
{"name":"pow_eq_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftMono M\nx : M\nn : Nat\nhn : Ne n 0\n⊢ Iff (Eq (HPow.hPow x n) 1) (Eq x 1)","decl":"@[to_additive]\ntheorem pow_eq_one_iff {x : M} {n : ℕ} (hn : n ≠ 0) : x ^ n = 1 ↔ x = 1 := by\n  simp only [le_antisymm_iff]\n  rw [pow_le_one_iff hn, one_le_pow_iff hn]\n\n"}
{"name":"pow_le_pow_iff_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftStrictMono M\na : M\nm n : Nat\nha : LT.lt 1 a\n⊢ Iff (LE.le (HPow.hPow a m) (HPow.hPow a n)) (LE.le m n)","decl":"@[to_additive nsmul_le_nsmul_iff_left]\ntheorem pow_le_pow_iff_right' (ha : 1 < a) : a ^ m ≤ a ^ n ↔ m ≤ n :=\n  (pow_right_strictMono' ha).le_iff_le\n\n"}
{"name":"nsmul_le_nsmul_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftStrictMono M\na : M\nm n : Nat\nha : LT.lt 0 a\n⊢ Iff (LE.le (HSMul.hSMul m a) (HSMul.hSMul n a)) (LE.le m n)","decl":"@[to_additive nsmul_le_nsmul_iff_left]\ntheorem pow_le_pow_iff_right' (ha : 1 < a) : a ^ m ≤ a ^ n ↔ m ≤ n :=\n  (pow_right_strictMono' ha).le_iff_le\n\n"}
{"name":"nsmul_lt_nsmul_iff_left","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftStrictMono M\na : M\nm n : Nat\nha : LT.lt 0 a\n⊢ Iff (LT.lt (HSMul.hSMul m a) (HSMul.hSMul n a)) (LT.lt m n)","decl":"@[to_additive nsmul_lt_nsmul_iff_left]\ntheorem pow_lt_pow_iff_right' (ha : 1 < a) : a ^ m < a ^ n ↔ m < n :=\n  (pow_right_strictMono' ha).lt_iff_lt\n\n"}
{"name":"pow_lt_pow_iff_right'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftStrictMono M\na : M\nm n : Nat\nha : LT.lt 1 a\n⊢ Iff (LT.lt (HPow.hPow a m) (HPow.hPow a n)) (LT.lt m n)","decl":"@[to_additive nsmul_lt_nsmul_iff_left]\ntheorem pow_lt_pow_iff_right' (ha : 1 < a) : a ^ m < a ^ n ↔ m < n :=\n  (pow_right_strictMono' ha).lt_iff_lt\n\n"}
{"name":"lt_of_pow_lt_pow_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b : M\nn : Nat\na✝ : LT.lt (HPow.hPow a n) (HPow.hPow b n)\n⊢ LT.lt a b","decl":"@[to_additive lt_of_nsmul_lt_nsmul_right]\ntheorem lt_of_pow_lt_pow_left' {a b : M} (n : ℕ) : a ^ n < b ^ n → a < b :=\n  (pow_left_mono _).reflect_lt\n\n"}
{"name":"lt_of_nsmul_lt_nsmul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\na b : M\nn : Nat\na✝ : LT.lt (HSMul.hSMul n a) (HSMul.hSMul n b)\n⊢ LT.lt a b","decl":"@[to_additive lt_of_nsmul_lt_nsmul_right]\ntheorem lt_of_pow_lt_pow_left' {a b : M} (n : ℕ) : a ^ n < b ^ n → a < b :=\n  (pow_left_mono _).reflect_lt\n\n"}
{"name":"min_lt_of_add_lt_two_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\na b c : M\nh : LT.lt (HAdd.hAdd a b) (HSMul.hSMul 2 c)\n⊢ LT.lt (Min.min a b) c","decl":"@[to_additive min_lt_of_add_lt_two_nsmul]\ntheorem min_lt_of_mul_lt_sq {a b c : M} (h : a * b < c ^ 2) : min a b < c := by\n  simpa using min_lt_max_of_mul_lt_mul (h.trans_eq <| pow_two _)\n\n"}
{"name":"min_lt_of_mul_lt_sq","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b c : M\nh : LT.lt (HMul.hMul a b) (HPow.hPow c 2)\n⊢ LT.lt (Min.min a b) c","decl":"@[to_additive min_lt_of_add_lt_two_nsmul]\ntheorem min_lt_of_mul_lt_sq {a b c : M} (h : a * b < c ^ 2) : min a b < c := by\n  simpa using min_lt_max_of_mul_lt_mul (h.trans_eq <| pow_two _)\n\n"}
{"name":"lt_max_of_sq_lt_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftMono M\ninst✝ : MulRightMono M\na b c : M\nh : LT.lt (HPow.hPow a 2) (HMul.hMul b c)\n⊢ LT.lt a (Max.max b c)","decl":"@[to_additive lt_max_of_two_nsmul_lt_add]\ntheorem lt_max_of_sq_lt_mul {a b c : M} (h : a ^ 2 < b * c) : a < max b c := by\n  simpa using min_lt_max_of_mul_lt_mul ((pow_two _).symm.trans_lt h)\n\n"}
{"name":"lt_max_of_two_nsmul_lt_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftMono M\ninst✝ : AddRightMono M\na b c : M\nh : LT.lt (HSMul.hSMul 2 a) (HAdd.hAdd b c)\n⊢ LT.lt a (Max.max b c)","decl":"@[to_additive lt_max_of_two_nsmul_lt_add]\ntheorem lt_max_of_sq_lt_mul {a b c : M} (h : a ^ 2 < b * c) : a < max b c := by\n  simpa using min_lt_max_of_mul_lt_mul ((pow_two _).symm.trans_lt h)\n\n"}
{"name":"le_of_pow_le_pow_left'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftStrictMono M\ninst✝ : MulRightStrictMono M\na b : M\nn : Nat\nhn : Ne n 0\na✝ : LE.le (HPow.hPow a n) (HPow.hPow b n)\n⊢ LE.le a b","decl":"@[to_additive le_of_nsmul_le_nsmul_right]\ntheorem le_of_pow_le_pow_left' {a b : M} {n : ℕ} (hn : n ≠ 0) : a ^ n ≤ b ^ n → a ≤ b :=\n  (pow_left_strictMono hn).le_iff_le.1\n\n"}
{"name":"le_of_nsmul_le_nsmul_right","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\na b : M\nn : Nat\nhn : Ne n 0\na✝ : LE.le (HSMul.hSMul n a) (HSMul.hSMul n b)\n⊢ LE.le a b","decl":"@[to_additive le_of_nsmul_le_nsmul_right]\ntheorem le_of_pow_le_pow_left' {a b : M} {n : ℕ} (hn : n ≠ 0) : a ^ n ≤ b ^ n → a ≤ b :=\n  (pow_left_strictMono hn).le_iff_le.1\n\n"}
{"name":"min_le_of_mul_le_sq","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftStrictMono M\ninst✝ : MulRightStrictMono M\na b c : M\nh : LE.le (HMul.hMul a b) (HPow.hPow c 2)\n⊢ LE.le (Min.min a b) c","decl":"@[to_additive min_le_of_add_le_two_nsmul]\ntheorem min_le_of_mul_le_sq {a b c : M} (h : a * b ≤ c ^ 2) : min a b ≤ c := by\n  simpa using min_le_max_of_mul_le_mul (h.trans_eq <| pow_two _)\n\n"}
{"name":"min_le_of_add_le_two_nsmul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\na b c : M\nh : LE.le (HAdd.hAdd a b) (HSMul.hSMul 2 c)\n⊢ LE.le (Min.min a b) c","decl":"@[to_additive min_le_of_add_le_two_nsmul]\ntheorem min_le_of_mul_le_sq {a b c : M} (h : a * b ≤ c ^ 2) : min a b ≤ c := by\n  simpa using min_le_max_of_mul_le_mul (h.trans_eq <| pow_two _)\n\n"}
{"name":"le_max_of_two_nsmul_le_add","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : AddMonoid M\ninst✝² : LinearOrder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\na b c : M\nh : LE.le (HSMul.hSMul 2 a) (HAdd.hAdd b c)\n⊢ LE.le a (Max.max b c)","decl":"@[to_additive le_max_of_two_nsmul_le_add]\ntheorem le_max_of_sq_le_mul {a b c : M} (h : a ^ 2 ≤ b * c) : a ≤ max b c := by\n  simpa using min_le_max_of_mul_le_mul ((pow_two _).symm.trans_le h)\n\n"}
{"name":"le_max_of_sq_le_mul","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝³ : Monoid M\ninst✝² : LinearOrder M\ninst✝¹ : MulLeftStrictMono M\ninst✝ : MulRightStrictMono M\na b c : M\nh : LE.le (HPow.hPow a 2) (HMul.hMul b c)\n⊢ LE.le a (Max.max b c)","decl":"@[to_additive le_max_of_two_nsmul_le_add]\ntheorem le_max_of_sq_le_mul {a b c : M} (h : a ^ 2 ≤ b * c) : a ≤ max b c := by\n  simpa using min_le_max_of_mul_le_mul ((pow_two _).symm.trans_le h)\n\n"}
{"name":"Left.nsmul_neg_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddLeftStrictMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (HSMul.hSMul n x) 0) (LT.lt x 0)","decl":"@[to_additive Left.nsmul_neg_iff]\ntheorem Left.pow_lt_one_iff' [MulLeftStrictMono M] {n : ℕ} {x : M} (hn : 0 < n) :\n    x ^ n < 1 ↔ x < 1 :=\n  haveI := mulLeftMono_of_mulLeftStrictMono M\n  pow_lt_one_iff hn.ne'\n\n"}
{"name":"Left.pow_lt_one_iff'","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftStrictMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (HPow.hPow x n) 1) (LT.lt x 1)","decl":"@[to_additive Left.nsmul_neg_iff]\ntheorem Left.pow_lt_one_iff' [MulLeftStrictMono M] {n : ℕ} {x : M} (hn : 0 < n) :\n    x ^ n < 1 ↔ x < 1 :=\n  haveI := mulLeftMono_of_mulLeftStrictMono M\n  pow_lt_one_iff hn.ne'\n\n"}
{"name":"Left.pow_lt_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulLeftStrictMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (HPow.hPow x n) 1) (LT.lt x 1)","decl":"theorem Left.pow_lt_one_iff [MulLeftStrictMono M] {n : ℕ} {x : M} (hn : 0 < n) :\n    x ^ n < 1 ↔ x < 1 := Left.pow_lt_one_iff' hn\n\n"}
{"name":"Right.nsmul_neg_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : AddMonoid M\ninst✝¹ : LinearOrder M\ninst✝ : AddRightStrictMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (HSMul.hSMul n x) 0) (LT.lt x 0)","decl":"@[to_additive]\ntheorem Right.pow_lt_one_iff [MulRightStrictMono M] {n : ℕ} {x : M}\n    (hn : 0 < n) : x ^ n < 1 ↔ x < 1 :=\n  haveI := mulRightMono_of_mulRightStrictMono M\n  ⟨fun H => not_le.mp fun k => H.not_le <| Right.one_le_pow_of_le k, Right.pow_lt_one_of_lt hn⟩\n\n"}
{"name":"Right.pow_lt_one_iff","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"M : Type u_3\ninst✝² : Monoid M\ninst✝¹ : LinearOrder M\ninst✝ : MulRightStrictMono M\nn : Nat\nx : M\nhn : LT.lt 0 n\n⊢ Iff (LT.lt (HPow.hPow x n) 1) (LT.lt x 1)","decl":"@[to_additive]\ntheorem Right.pow_lt_one_iff [MulRightStrictMono M] {n : ℕ} {x : M}\n    (hn : 0 < n) : x ^ n < 1 ↔ x < 1 :=\n  haveI := mulRightMono_of_mulRightStrictMono M\n  ⟨fun H => not_le.mp fun k => H.not_le <| Right.one_le_pow_of_le k, Right.pow_lt_one_of_lt hn⟩\n\n"}
{"name":"one_le_zpow","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"G : Type u_2\ninst✝² : DivInvMonoid G\ninst✝¹ : Preorder G\ninst✝ : MulLeftMono G\nx : G\nH : LE.le 1 x\nn : Int\nhn : LE.le 0 n\n⊢ LE.le 1 (HPow.hPow x n)","decl":"@[to_additive zsmul_nonneg]\ntheorem one_le_zpow {x : G} (H : 1 ≤ x) {n : ℤ} (hn : 0 ≤ n) : 1 ≤ x ^ n := by\n  lift n to ℕ using hn\n  rw [zpow_natCast]\n  apply one_le_pow_of_one_le' H\n\n"}
{"name":"zsmul_nonneg","module":"Mathlib.Algebra.Order.Monoid.Unbundled.Pow","initialProofState":"G : Type u_2\ninst✝² : SubNegMonoid G\ninst✝¹ : Preorder G\ninst✝ : AddLeftMono G\nx : G\nH : LE.le 0 x\nn : Int\nhn : LE.le 0 n\n⊢ LE.le 0 (HSMul.hSMul n x)","decl":"@[to_additive zsmul_nonneg]\ntheorem one_le_zpow {x : G} (H : 1 ≤ x) {n : ℤ} (hn : 0 ≤ n) : 1 ≤ x ^ n := by\n  lift n to ℕ using hn\n  rw [zpow_natCast]\n  apply one_le_pow_of_one_le' H\n\n"}
