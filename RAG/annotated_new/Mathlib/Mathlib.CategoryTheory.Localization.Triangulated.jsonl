{"name":"CategoryTheory.MorphismProperty.IsCompatibleWithTriangulation.toIsCompatibleWithShift","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nW : CategoryTheory.MorphismProperty C\nself : W.IsCompatibleWithTriangulation\n⊢ W.IsCompatibleWithShift Int","decl":"/-- Given `W` is a class of morphisms in a pretriangulated category `C`, this is the condition\nthat `W` is compatible with the triangulation on `C`. -/\nclass IsCompatibleWithTriangulation (W : MorphismProperty C)\n    extends W.IsCompatibleWithShift ℤ : Prop where\n  compatible_with_triangulation (T₁ T₂ : Triangle C)\n    (_ : T₁ ∈ distTriang C) (_ : T₂ ∈ distTriang C)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : W a) (_ : W b)\n    (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n      ∃ (c : T₁.obj₃ ⟶ T₂.obj₃) (_ : W c),\n        (T₁.mor₂ ≫ c = b ≫ T₂.mor₂) ∧ (T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃)\n\n"}
{"name":"CategoryTheory.MorphismProperty.IsCompatibleWithTriangulation.compatible_with_triangulation","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\ninst✝⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝ : CategoryTheory.Pretriangulated C\nW : CategoryTheory.MorphismProperty C\nself : W.IsCompatibleWithTriangulation\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle C\nx✝⁴ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁\nx✝³ : Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\nx✝² : W a\nx✝¹ : W b\nx✝ : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Exists fun c => Exists fun x => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor C 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃))","decl":"/-- Given `W` is a class of morphisms in a pretriangulated category `C`, this is the condition\nthat `W` is compatible with the triangulation on `C`. -/\nclass IsCompatibleWithTriangulation (W : MorphismProperty C)\n    extends W.IsCompatibleWithShift ℤ : Prop where\n  compatible_with_triangulation (T₁ T₂ : Triangle C)\n    (_ : T₁ ∈ distTriang C) (_ : T₂ ∈ distTriang C)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (_ : W a) (_ : W b)\n    (_ : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n      ∃ (c : T₁.obj₃ ⟶ T₂.obj₃) (_ : W c),\n        (T₁.mor₂ ≫ c = b ≫ T₂.mor₂) ∧ (T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃)\n\n"}
{"name":"CategoryTheory.Functor.essImageDistTriang_mem_of_iso","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_3, u_2} D\nL : CategoryTheory.Functor C D\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.HasShift D Int\ninst✝ : L.CommShift Int\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle D\ne : CategoryTheory.Iso T₂ T₁\nh : Membership.mem L.essImageDistTriang T₁\n⊢ Membership.mem L.essImageDistTriang T₂","decl":"lemma essImageDistTriang_mem_of_iso {T₁ T₂ : Triangle D} (e : T₂ ≅ T₁)\n    (h : T₁ ∈ L.essImageDistTriang) : T₂ ∈ L.essImageDistTriang := by\n  obtain ⟨T', e', hT'⟩ := h\n  exact ⟨T', e ≪≫ e', hT'⟩\n\n"}
{"name":"CategoryTheory.Functor.contractible_mem_essImageDistTriang","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹¹ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\ninst✝¹⁰ : CategoryTheory.HasShift C Int\ninst✝⁹ : CategoryTheory.Preadditive C\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁶ : CategoryTheory.Pretriangulated C\ninst✝⁵ : CategoryTheory.HasShift D Int\ninst✝⁴ : L.CommShift Int\ninst✝³ : L.EssSurj\ninst✝² : CategoryTheory.Limits.HasZeroObject D\ninst✝¹ : CategoryTheory.Limits.HasZeroMorphisms D\ninst✝ : L.PreservesZeroMorphisms\nX : D\n⊢ Membership.mem L.essImageDistTriang (CategoryTheory.Pretriangulated.contractibleTriangle X)","decl":"lemma contractible_mem_essImageDistTriang [EssSurj L] [HasZeroObject D]\n    [HasZeroMorphisms D] [L.PreservesZeroMorphisms] (X : D) :\n    contractibleTriangle X ∈ L.essImageDistTriang := by\n  refine ⟨contractibleTriangle (L.objPreimage X), ?_, contractible_distinguished _⟩\n  exact ((contractibleTriangleFunctor D).mapIso (L.objObjPreimageIso X)).symm ≪≫\n    Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) L.mapZeroObject.symm (by simp) (by simp) (by simp)\n\n"}
{"name":"CategoryTheory.Functor.rotate_essImageDistTriang","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_2} D\nL : CategoryTheory.Functor C D\ninst✝⁹ : CategoryTheory.HasShift C Int\ninst✝⁸ : CategoryTheory.Preadditive C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.HasShift D Int\ninst✝³ : L.CommShift Int\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : L.Additive\ninst✝ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\nT : CategoryTheory.Pretriangulated.Triangle D\n⊢ Iff (Membership.mem L.essImageDistTriang T) (Membership.mem L.essImageDistTriang T.rotate)","decl":"lemma rotate_essImageDistTriang [Preadditive D] [L.Additive]\n    [∀ (n : ℤ), (shiftFunctor D n).Additive] (T : Triangle D) :\n  T ∈ L.essImageDistTriang ↔ T.rotate ∈ L.essImageDistTriang := by\n  constructor\n  · rintro ⟨T', e', hT'⟩\n    exact ⟨T'.rotate, (rotate D).mapIso e' ≪≫ L.mapTriangleRotateIso.app T',\n      rot_of_distTriang T' hT'⟩\n  · rintro ⟨T', e', hT'⟩\n    exact ⟨T'.invRotate, (triangleRotation D).unitIso.app T ≪≫ (invRotate D).mapIso e' ≪≫\n      L.mapTriangleInvRotateIso.app T', inv_rot_of_distTriang T' hT'⟩\n\n"}
{"name":"CategoryTheory.Functor.complete_distinguished_essImageDistTriang_morphism","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\ninst✝¹ : CategoryTheory.HasShift D Int\ninst✝ : L.CommShift Int\nH : ∀ (T₁' T₂' : CategoryTheory.Pretriangulated.Triangle C), Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₁' → Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T₂' → ∀ (a : Quiver.Hom (L.obj T₁'.obj₁) (L.obj T₂'.obj₁)) (b : Quiver.Hom (L.obj T₁'.obj₂) (L.obj T₂'.obj₂)), Eq (CategoryTheory.CategoryStruct.comp (L.map T₁'.mor₁) b) (CategoryTheory.CategoryStruct.comp a (L.map T₂'.mor₁)) → Exists fun φ => And (Eq φ.hom₁ a) (Eq φ.hom₂ b)\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle D\nhT₁ : Membership.mem L.essImageDistTriang T₁\nhT₂ : Membership.mem L.essImageDistTriang T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\nfac : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor D 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃))","decl":"lemma complete_distinguished_essImageDistTriang_morphism\n    (H : ∀ (T₁' T₂' : Triangle C) (_ : T₁' ∈ distTriang C) (_ : T₂' ∈ distTriang C)\n      (a : L.obj (T₁'.obj₁) ⟶ L.obj (T₂'.obj₁)) (b : L.obj (T₁'.obj₂) ⟶ L.obj (T₂'.obj₂))\n      (_ : L.map T₁'.mor₁ ≫ b = a ≫ L.map T₂'.mor₁),\n      ∃ (φ : L.mapTriangle.obj T₁' ⟶ L.mapTriangle.obj T₂'), φ.hom₁ = a ∧ φ.hom₂ = b)\n    (T₁ T₂ : Triangle D)\n    (hT₁ : T₁ ∈ Functor.essImageDistTriang L) (hT₂ : T₂ ∈ L.essImageDistTriang)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (fac : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n    ∃ c, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃ := by\n  obtain ⟨T₁', e₁, hT₁'⟩ := hT₁\n  obtain ⟨T₂', e₂, hT₂'⟩ := hT₂\n  have comm₁ := e₁.inv.comm₁\n  have comm₁' := e₂.hom.comm₁\n  have comm₂ := e₁.hom.comm₂\n  have comm₂' := e₂.hom.comm₂\n  have comm₃ := e₁.inv.comm₃\n  have comm₃' := e₂.hom.comm₃\n  dsimp at comm₁ comm₁' comm₂ comm₂' comm₃ comm₃'\n  simp only [assoc] at comm₃\n  obtain ⟨φ, hφ₁, hφ₂⟩ := H T₁' T₂' hT₁' hT₂' (e₁.inv.hom₁ ≫ a ≫ e₂.hom.hom₁)\n    (e₁.inv.hom₂ ≫ b ≫ e₂.hom.hom₂)\n    (by simp only [assoc, ← comm₁', ← reassoc_of% fac, ← reassoc_of% comm₁])\n  have h₂ := φ.comm₂\n  have h₃ := φ.comm₃\n  dsimp at h₂ h₃\n  simp only [assoc] at h₃\n  refine ⟨e₁.hom.hom₃ ≫ φ.hom₃ ≫ e₂.inv.hom₃, ?_, ?_⟩\n  · rw [reassoc_of% comm₂, reassoc_of% h₂, hφ₂, assoc, assoc,\n      Iso.hom_inv_id_triangle_hom₂_assoc, ← reassoc_of% comm₂',\n      Iso.hom_inv_id_triangle_hom₃, comp_id]\n  · rw [assoc, assoc, ← cancel_epi e₁.inv.hom₃, ← reassoc_of% comm₃,\n      Iso.inv_hom_id_triangle_hom₃_assoc, ← cancel_mono (e₂.hom.hom₁⟦(1 : ℤ)⟧'),\n      assoc, assoc, assoc, assoc, assoc, ← Functor.map_comp, ← Functor.map_comp, ← hφ₁,\n      h₃, comm₃', Iso.inv_hom_id_triangle_hom₃_assoc]\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.distinguished_cocone_triangle","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁰ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁹ : CategoryTheory.Category.{u_3, u_2} D\nL : CategoryTheory.Functor C D\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.HasShift D Int\ninst✝² : L.CommShift Int\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : L.IsLocalization W\ninst✝ : W.HasLeftCalculusOfFractions\nX Y : D\nf : Quiver.Hom X Y\n⊢ Exists fun Z => Exists fun g => Exists fun h => Membership.mem L.essImageDistTriang (CategoryTheory.Pretriangulated.Triangle.mk f g h)","decl":"include W in\nlemma distinguished_cocone_triangle {X Y : D} (f : X ⟶ Y) :\n    ∃ (Z : D) (g : Y ⟶ Z) (h : Z ⟶ X⟦(1 : ℤ)⟧),\n      Triangle.mk f g h ∈ L.essImageDistTriang := by\n  have := essSurj_mapArrow L W\n  obtain ⟨φ, ⟨e⟩⟩ : ∃ (φ : Arrow C), Nonempty (L.mapArrow.obj φ ≅ Arrow.mk f) :=\n    ⟨_, ⟨Functor.objObjPreimageIso _ _⟩⟩\n  obtain ⟨Z, g, h, H⟩ := Pretriangulated.distinguished_cocone_triangle φ.hom\n  refine ⟨L.obj Z, e.inv.right ≫ L.map g,\n    L.map h ≫ (L.commShiftIso (1 : ℤ)).hom.app _ ≫ e.hom.left⟦(1 : ℤ)⟧', _, ?_, H⟩\n  refine Triangle.isoMk _ _ (Arrow.leftFunc.mapIso e.symm) (Arrow.rightFunc.mapIso e.symm)\n    (Iso.refl _) e.inv.w.symm (by simp) ?_\n  dsimp\n  simp only [assoc, id_comp, ← Functor.map_comp, ← Arrow.comp_left, e.hom_inv_id, Arrow.id_left,\n    Functor.mapArrow_obj, Arrow.mk_left, Functor.map_id, comp_id]\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.complete_distinguished_triangle_morphism","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹¹ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁰ : CategoryTheory.Category.{u_3, u_2} D\nL : CategoryTheory.Functor C D\ninst✝⁹ : CategoryTheory.HasShift C Int\ninst✝⁸ : CategoryTheory.Preadditive C\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.HasShift D Int\ninst✝³ : L.CommShift Int\nW : CategoryTheory.MorphismProperty C\ninst✝² : L.IsLocalization W\ninst✝¹ : W.HasLeftCalculusOfFractions\ninst✝ : W.IsCompatibleWithTriangulation\nT₁ T₂ : CategoryTheory.Pretriangulated.Triangle D\nhT₁ : Membership.mem L.essImageDistTriang T₁\nhT₂ : Membership.mem L.essImageDistTriang T₂\na : Quiver.Hom T₁.obj₁ T₂.obj₁\nb : Quiver.Hom T₁.obj₂ T₂.obj₂\nfac : Eq (CategoryTheory.CategoryStruct.comp T₁.mor₁ b) (CategoryTheory.CategoryStruct.comp a T₂.mor₁)\n⊢ Exists fun c => And (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₂ c) (CategoryTheory.CategoryStruct.comp b T₂.mor₂)) (Eq (CategoryTheory.CategoryStruct.comp T₁.mor₃ ((CategoryTheory.shiftFunctor D 1).map a)) (CategoryTheory.CategoryStruct.comp c T₂.mor₃))","decl":"include W in\nlemma complete_distinguished_triangle_morphism (T₁ T₂ : Triangle D)\n    (hT₁ : T₁ ∈ L.essImageDistTriang) (hT₂ : T₂ ∈ L.essImageDistTriang)\n    (a : T₁.obj₁ ⟶ T₂.obj₁) (b : T₁.obj₂ ⟶ T₂.obj₂) (fac : T₁.mor₁ ≫ b = a ≫ T₂.mor₁) :\n    ∃ c, T₁.mor₂ ≫ c = b ≫ T₂.mor₂ ∧ T₁.mor₃ ≫ a⟦1⟧' = c ≫ T₂.mor₃ := by\n  refine L.complete_distinguished_essImageDistTriang_morphism ?_ T₁ T₂ hT₁ hT₂ a b fac\n  clear a b fac hT₁ hT₂ T₁ T₂\n  intro T₁ T₂ hT₁ hT₂ a b fac\n  obtain ⟨α, hα⟩ := exists_leftFraction L W a\n  obtain ⟨β, hβ⟩ := (MorphismProperty.RightFraction.mk α.s α.hs T₂.mor₁).exists_leftFraction\n  obtain ⟨γ, hγ⟩ := exists_leftFraction L W (b ≫ L.map β.s)\n  have := inverts L W β.s β.hs\n  have := inverts L W γ.s γ.hs\n  dsimp at hβ\n  obtain ⟨Z₂, σ, hσ, fac⟩ := (MorphismProperty.map_eq_iff_postcomp L W\n    (α.f ≫ β.f ≫ γ.s) (T₁.mor₁ ≫ γ.f)).1 (by\n      rw [← cancel_mono (L.map β.s), assoc, assoc, hγ, ← cancel_mono (L.map γ.s),\n        assoc, assoc, assoc, hα, MorphismProperty.LeftFraction.map_comp_map_s,\n        ← Functor.map_comp] at fac\n      rw [fac, ← Functor.map_comp_assoc, hβ, Functor.map_comp, Functor.map_comp,\n        Functor.map_comp, assoc, MorphismProperty.LeftFraction.map_comp_map_s_assoc])\n  simp only [assoc] at fac\n  obtain ⟨Y₃, g, h, hT₃⟩ := Pretriangulated.distinguished_cocone_triangle (β.f ≫ γ.s ≫ σ)\n  let T₃ := Triangle.mk (β.f ≫ γ.s ≫ σ) g h\n  change T₃ ∈ distTriang C at hT₃\n  have hβγσ : W (β.s ≫ γ.s ≫ σ) := W.comp_mem _ _ β.hs (W.comp_mem _ _ γ.hs hσ)\n  obtain ⟨ψ₃, hψ₃, hψ₁, hψ₂⟩ := MorphismProperty.compatible_with_triangulation\n    T₂ T₃ hT₂ hT₃ α.s (β.s ≫ γ.s ≫ σ) α.hs hβγσ (by dsimp [T₃]; rw [reassoc_of% hβ])\n  let ψ : T₂ ⟶ T₃ := Triangle.homMk _ _ α.s (β.s ≫ γ.s ≫ σ) ψ₃\n    (by dsimp [T₃]; rw [reassoc_of% hβ]) hψ₁ hψ₂\n  have : IsIso (L.mapTriangle.map ψ) := Triangle.isIso_of_isIsos _\n    (inverts L W α.s α.hs) (inverts L W _ hβγσ) (inverts L W ψ₃ hψ₃)\n  refine ⟨L.mapTriangle.map (completeDistinguishedTriangleMorphism T₁ T₃ hT₁ hT₃ α.f\n      (γ.f ≫ σ) fac.symm) ≫ inv (L.mapTriangle.map ψ), ?_, ?_⟩\n  · rw [← cancel_mono (L.mapTriangle.map ψ).hom₁, ← comp_hom₁, assoc, IsIso.inv_hom_id, comp_id]\n    dsimp [ψ]\n    rw [hα, MorphismProperty.LeftFraction.map_comp_map_s]\n  · rw [← cancel_mono (L.mapTriangle.map ψ).hom₂, ← comp_hom₂, assoc, IsIso.inv_hom_id, comp_id]\n    dsimp [ψ]\n    simp only [Functor.map_comp, reassoc_of% hγ,\n      MorphismProperty.LeftFraction.map_comp_map_s_assoc]\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.isTriangulated_functor","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁵ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_2} D\nL : CategoryTheory.Functor C D\ninst✝¹³ : CategoryTheory.HasShift C Int\ninst✝¹² : CategoryTheory.Preadditive C\ninst✝¹¹ : CategoryTheory.Limits.HasZeroObject C\ninst✝¹⁰ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁹ : CategoryTheory.Pretriangulated C\ninst✝⁸ : CategoryTheory.HasShift D Int\ninst✝⁷ : L.CommShift Int\nW : CategoryTheory.MorphismProperty C\ninst✝⁶ : L.IsLocalization W\ninst✝⁵ : W.HasLeftCalculusOfFractions\ninst✝⁴ : W.IsCompatibleWithTriangulation\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝ : L.Additive\n⊢ L.IsTriangulated","decl":"instance isTriangulated_functor :\n    letI : Pretriangulated D := pretriangulated L W; L.IsTriangulated :=\n  letI : Pretriangulated D := pretriangulated L W\n  ⟨fun T hT => ⟨T, Iso.refl _, hT⟩⟩\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.isTriangulated","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹⁵ : CategoryTheory.Category.{u_3, u_2} D\nL : CategoryTheory.Functor C D\ninst✝¹⁴ : CategoryTheory.HasShift C Int\ninst✝¹³ : CategoryTheory.Preadditive C\ninst✝¹² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝¹⁰ : CategoryTheory.Pretriangulated C\ninst✝⁹ : CategoryTheory.HasShift D Int\ninst✝⁸ : L.CommShift Int\nW : CategoryTheory.MorphismProperty C\ninst✝⁷ : L.IsLocalization W\ninst✝⁶ : W.HasLeftCalculusOfFractions\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁴ : CategoryTheory.Preadditive D\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated D\ninst✝¹ : L.IsTriangulated\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ CategoryTheory.IsTriangulated D","decl":"include W in\nlemma isTriangulated [Pretriangulated D] [L.IsTriangulated] [IsTriangulated C] :\n    IsTriangulated D := by\n  have := essSurj_mapComposableArrows L W 2\n  exact isTriangulated_of_essSurj_mapComposableArrows_two L\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.instAdditiveLocalizationShiftFunctorInt","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\ninst✝⁷ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁶ : CategoryTheory.HasShift C Int\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject C\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝² : CategoryTheory.Pretriangulated C\nW : CategoryTheory.MorphismProperty C\ninst✝¹ : W.HasLeftCalculusOfFractions\ninst✝ : W.IsCompatibleWithTriangulation\nn : Int\n⊢ (CategoryTheory.shiftFunctor W.Localization n).Additive","decl":"instance (n : ℤ) : (shiftFunctor (W.Localization) n).Additive := by\n  rw [Localization.functor_additive_iff W.Q W]\n  exact Functor.additive_of_iso (W.Q.commShiftIso n)\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.instIsTriangulatedLocalization","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\nW : CategoryTheory.MorphismProperty C\ninst✝² : W.HasLeftCalculusOfFractions\ninst✝¹ : W.IsCompatibleWithTriangulation\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ CategoryTheory.IsTriangulated W.Localization","decl":"instance [IsTriangulated C] : IsTriangulated W.Localization := isTriangulated W.Q W\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.instAdditiveLocalization'ShiftFunctorInt","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\ninst✝⁸ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁷ : CategoryTheory.HasShift C Int\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁴ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝³ : CategoryTheory.Pretriangulated C\nW : CategoryTheory.MorphismProperty C\ninst✝² : W.HasLeftCalculusOfFractions\ninst✝¹ : W.IsCompatibleWithTriangulation\ninst✝ : W.HasLocalization\nn : Int\n⊢ (CategoryTheory.shiftFunctor W.Localization' n).Additive","decl":"instance (n : ℤ) : (shiftFunctor (W.Localization') n).Additive := by\n  rw [Localization.functor_additive_iff W.Q' W]\n  exact Functor.additive_of_iso (W.Q'.commShiftIso n)\n\n"}
{"name":"CategoryTheory.Triangulated.Localization.instIsTriangulatedLocalization'","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\ninst✝⁹ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁸ : CategoryTheory.HasShift C Int\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\nW : CategoryTheory.MorphismProperty C\ninst✝³ : W.HasLeftCalculusOfFractions\ninst✝² : W.IsCompatibleWithTriangulation\ninst✝¹ : W.HasLocalization\ninst✝ : CategoryTheory.IsTriangulated C\n⊢ CategoryTheory.IsTriangulated W.Localization'","decl":"instance [IsTriangulated C] : IsTriangulated W.Localization' := isTriangulated W.Q' W\n\n"}
{"name":"CategoryTheory.Functor.distTriang_iff","module":"Mathlib.CategoryTheory.Localization.Triangulated","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝¹³ : CategoryTheory.Category.{u_3, u_2} D\nL : CategoryTheory.Functor C D\ninst✝¹² : CategoryTheory.HasShift C Int\ninst✝¹¹ : CategoryTheory.Preadditive C\ninst✝¹⁰ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁹ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁸ : CategoryTheory.Pretriangulated C\ninst✝⁷ : CategoryTheory.HasShift D Int\ninst✝⁶ : L.CommShift Int\ninst✝⁵ : CategoryTheory.Limits.HasZeroObject D\ninst✝⁴ : CategoryTheory.Preadditive D\ninst✝³ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝² : CategoryTheory.Pretriangulated D\ninst✝¹ : L.mapArrow.EssSurj\ninst✝ : L.IsTriangulated\nT : CategoryTheory.Pretriangulated.Triangle D\n⊢ Iff (Membership.mem CategoryTheory.Pretriangulated.distinguishedTriangles T) (Membership.mem L.essImageDistTriang T)","decl":"lemma distTriang_iff (T : Triangle D) :\n    (T ∈ distTriang D) ↔ T ∈ L.essImageDistTriang := by\n  constructor\n  · intro hT\n    let f := L.mapArrow.objPreimage T.mor₁\n    obtain ⟨Z, g : f.right ⟶ Z, h : Z ⟶ f.left⟦(1 : ℤ)⟧, mem⟩ :=\n      Pretriangulated.distinguished_cocone_triangle f.hom\n    exact ⟨_, (exists_iso_of_arrow_iso T _ hT (L.map_distinguished _ mem)\n      (L.mapArrow.objObjPreimageIso T.mor₁).symm).choose, mem⟩\n  · rintro ⟨T₀, e, hT₀⟩\n    exact isomorphic_distinguished _ (L.map_distinguished _ hT₀) _ e\n\n"}
