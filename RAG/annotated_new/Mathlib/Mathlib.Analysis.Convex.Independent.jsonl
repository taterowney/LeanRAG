{"name":"Subsingleton.convexIndependent","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≥ : OrderedSemiring ùïú\ninst‚úù¬≤ : AddCommGroup E\ninst‚úù¬π : Module ùïú E\ninst‚úù : Subsingleton Œπ\np : Œπ ‚Üí E\n‚ä¢ ConvexIndependent ùïú p","decl":"/-- A family with at most one point is convex independent. -/\ntheorem Subsingleton.convexIndependent [Subsingleton Œπ] (p : Œπ ‚Üí E) : ConvexIndependent ùïú p := by\n  intro s x hx\n  have : (convexHull ùïú (p '' s)).Nonempty := ‚ü®p x, hx‚ü©\n  rw [convexHull_nonempty_iff, Set.image_nonempty] at this\n  rwa [Subsingleton.mem_iff_nonempty]\n\n"}
{"name":"ConvexIndependent.injective","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\nhc : ConvexIndependent ùïú p\n‚ä¢ Function.Injective p","decl":"/-- A convex independent family is injective. -/\nprotected theorem ConvexIndependent.injective {p : Œπ ‚Üí E} (hc : ConvexIndependent ùïú p) :\n    Function.Injective p := by\n  refine fun i j hij => hc {j} i ?_\n  rw [hij, Set.image_singleton, convexHull_singleton]\n  exact Set.mem_singleton _\n\n"}
{"name":"ConvexIndependent.comp_embedding","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\nŒπ' : Type u_4\nf : Function.Embedding Œπ' Œπ\np : Œπ ‚Üí E\nhc : ConvexIndependent ùïú p\n‚ä¢ ConvexIndependent ùïú (Function.comp p ‚áëf)","decl":"/-- If a family is convex independent, so is any subfamily given by composition of an embedding into\nindex type with the original family. -/\ntheorem ConvexIndependent.comp_embedding {Œπ' : Type*} (f : Œπ' ‚Ü™ Œπ) {p : Œπ ‚Üí E}\n    (hc : ConvexIndependent ùïú p) : ConvexIndependent ùïú (p ‚àò f) := by\n  intro s x hx\n  rw [‚Üê f.injective.mem_set_image]\n  exact hc _ _ (by rwa [Set.image_image])\n\n"}
{"name":"ConvexIndependent.subtype","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\nhc : ConvexIndependent ùïú p\ns : Set Œπ\n‚ä¢ ConvexIndependent ùïú fun i => p ‚Üëi","decl":"/-- If a family is convex independent, so is any subfamily indexed by a subtype of the index type.\n-/\nprotected theorem ConvexIndependent.subtype {p : Œπ ‚Üí E} (hc : ConvexIndependent ùïú p) (s : Set Œπ) :\n    ConvexIndependent ùïú fun i : s => p i :=\n  hc.comp_embedding (Embedding.subtype _)\n\n"}
{"name":"ConvexIndependent.range","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\nhc : ConvexIndependent ùïú p\n‚ä¢ ConvexIndependent ùïú Subtype.val","decl":"/-- If an indexed family of points is convex independent, so is the corresponding set of points. -/\nprotected theorem ConvexIndependent.range {p : Œπ ‚Üí E} (hc : ConvexIndependent ùïú p) :\n    ConvexIndependent ùïú ((‚Üë) : Set.range p ‚Üí E) := by\n  let f : Set.range p ‚Üí Œπ := fun x => x.property.choose\n  have hf : ‚àÄ x, p (f x) = x := fun x => x.property.choose_spec\n  let fe : Set.range p ‚Ü™ Œπ := ‚ü®f, fun x‚ÇÅ x‚ÇÇ he => Subtype.ext (hf x‚ÇÅ ‚ñ∏ hf x‚ÇÇ ‚ñ∏ he ‚ñ∏ rfl)‚ü©\n  convert hc.comp_embedding fe\n  ext\n  rw [Embedding.coeFn_mk, comp_apply, hf]\n\n"}
{"name":"ConvexIndependent.mono","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\ns t : Set E\nhc : ConvexIndependent ùïú Subtype.val\nhs : HasSubset.Subset s t\n‚ä¢ ConvexIndependent ùïú Subtype.val","decl":"/-- A subset of a convex independent set of points is convex independent as well. -/\nprotected theorem ConvexIndependent.mono {s t : Set E} (hc : ConvexIndependent ùïú ((‚Üë) : t ‚Üí E))\n    (hs : s ‚äÜ t) : ConvexIndependent ùïú ((‚Üë) : s ‚Üí E) :=\n  hc.comp_embedding (s.embeddingOfSubset t hs)\n\n"}
{"name":"Function.Injective.convexIndependent_iff_set","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\nhi : Function.Injective p\n‚ä¢ Iff (ConvexIndependent ùïú Subtype.val) (ConvexIndependent ùïú p)","decl":"/-- The range of an injective indexed family of points is convex independent iff that family is. -/\ntheorem Function.Injective.convexIndependent_iff_set {p : Œπ ‚Üí E} (hi : Function.Injective p) :\n    ConvexIndependent ùïú ((‚Üë) : Set.range p ‚Üí E) ‚Üî ConvexIndependent ùïú p :=\n  ‚ü®fun hc =>\n    hc.comp_embedding\n      (‚ü®fun i => ‚ü®p i, Set.mem_range_self _‚ü©, fun _ _ h => hi (Subtype.mk_eq_mk.1 h)‚ü© :\n        Œπ ‚Ü™ Set.range p),\n    ConvexIndependent.range‚ü©\n\n"}
{"name":"ConvexIndependent.mem_convexHull_iff","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\nhc : ConvexIndependent ùïú p\ns : Set Œπ\ni : Œπ\n‚ä¢ Iff (Membership.mem ((convexHull ùïú) (Set.image p s)) (p i)) (Membership.mem s i)","decl":"/-- If a family is convex independent, a point in the family is in the convex hull of some of the\npoints given by a subset of the index type if and only if the point's index is in this subset. -/\n@[simp]\nprotected theorem ConvexIndependent.mem_convexHull_iff {p : Œπ ‚Üí E} (hc : ConvexIndependent ùïú p)\n    (s : Set Œπ) (i : Œπ) : p i ‚àà convexHull ùïú (p '' s) ‚Üî i ‚àà s :=\n  ‚ü®hc _ _, fun hi => subset_convexHull ùïú _ (Set.mem_image_of_mem p hi)‚ü©\n\n"}
{"name":"convexIndependent_iff_not_mem_convexHull_diff","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\n‚ä¢ Iff (ConvexIndependent ùïú p) (‚àÄ (i : Œπ) (s : Set Œπ), Not (Membership.mem ((convexHull ùïú) (Set.image p (SDiff.sdiff s (Singleton.singleton i)))) (p i)))","decl":"/-- If a family is convex independent, a point in the family is not in the convex hull of the other\npoints. See `convexIndependent_set_iff_not_mem_convexHull_diff` for the `Set` version. -/\ntheorem convexIndependent_iff_not_mem_convexHull_diff {p : Œπ ‚Üí E} :\n    ConvexIndependent ùïú p ‚Üî ‚àÄ i s, p i ‚àâ convexHull ùïú (p '' (s \\ {i})) := by\n  refine ‚ü®fun hc i s h => ?_, fun h s i hi => ?_‚ü©\n  ¬∑ rw [hc.mem_convexHull_iff] at h\n    exact h.2 (Set.mem_singleton _)\n  ¬∑ by_contra H\n    refine h i s ?_\n    rw [Set.diff_singleton_eq_self H]\n    exact hi\n\n"}
{"name":"convexIndependent_set_iff_inter_convexHull_subset","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\ns : Set E\n‚ä¢ Iff (ConvexIndependent ùïú Subtype.val) (‚àÄ (t : Set E), HasSubset.Subset t s ‚Üí HasSubset.Subset (Inter.inter s ((convexHull ùïú) t)) t)","decl":"theorem convexIndependent_set_iff_inter_convexHull_subset {s : Set E} :\n    ConvexIndependent ùïú ((‚Üë) : s ‚Üí E) ‚Üî ‚àÄ t, t ‚äÜ s ‚Üí s ‚à© convexHull ùïú t ‚äÜ t := by\n  constructor\n  ¬∑ rintro hc t h x ‚ü®hxs, hxt‚ü©\n    refine hc { x | ‚Üëx ‚àà t } ‚ü®x, hxs‚ü© ?_\n    rw [Subtype.coe_image_of_subset h]\n    exact hxt\n  ¬∑ intro hc t x h\n    rw [‚Üê Subtype.coe_injective.mem_set_image]\n    exact hc (t.image ((‚Üë) : s ‚Üí E)) (Subtype.coe_image_subset s t) ‚ü®x.prop, h‚ü©\n\n"}
{"name":"convexIndependent_set_iff_not_mem_convexHull_diff","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : OrderedSemiring ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\ns : Set E\n‚ä¢ Iff (ConvexIndependent ùïú Subtype.val) (‚àÄ (x : E), Membership.mem s x ‚Üí Not (Membership.mem ((convexHull ùïú) (SDiff.sdiff s (Singleton.singleton x))) x))","decl":"/-- If a set is convex independent, a point in the set is not in the convex hull of the other\npoints. See `convexIndependent_iff_not_mem_convexHull_diff` for the indexed family version. -/\ntheorem convexIndependent_set_iff_not_mem_convexHull_diff {s : Set E} :\n    ConvexIndependent ùïú ((‚Üë) : s ‚Üí E) ‚Üî ‚àÄ x ‚àà s, x ‚àâ convexHull ùïú (s \\ {x}) := by\n  rw [convexIndependent_set_iff_inter_convexHull_subset]\n  constructor\n  ¬∑ rintro hs x hxs hx\n    exact (hs _ Set.diff_subset ‚ü®hxs, hx‚ü©).2 (Set.mem_singleton _)\n  ¬∑ rintro hs t ht x ‚ü®hxs, hxt‚ü©\n    by_contra h\n    exact hs _ hxs (convexHull_mono (Set.subset_diff_singleton ht h) hxt)\n\n"}
{"name":"convexIndependent_iff_finset","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\nŒπ : Type u_3\ninst‚úù¬≤ : LinearOrderedField ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\np : Œπ ‚Üí E\n‚ä¢ Iff (ConvexIndependent ùïú p) (‚àÄ (s : Finset Œπ) (x : Œπ), Membership.mem ((convexHull ùïú) ‚Üë(Finset.image p s)) (p x) ‚Üí Membership.mem s x)","decl":"open scoped Classical in\n/-- To check convex independence, one only has to check finsets thanks to Carath√©odory's theorem. -/\ntheorem convexIndependent_iff_finset {p : Œπ ‚Üí E} :\n    ConvexIndependent ùïú p ‚Üî\n      ‚àÄ (s : Finset Œπ) (x : Œπ), p x ‚àà convexHull ùïú (s.image p : Set E) ‚Üí x ‚àà s := by\n  refine ‚ü®fun hc s x hx => hc s x ?_, fun h s x hx => ?_‚ü©\n  ¬∑ rwa [Finset.coe_image] at hx\n  have hp : Injective p := by\n    rintro a b hab\n    rw [‚Üê mem_singleton]\n    refine h {b} a ?_\n    rw [hab, image_singleton, coe_singleton, convexHull_singleton]\n    exact Set.mem_singleton _\n  rw [convexHull_eq_union_convexHull_finite_subsets] at hx\n  simp_rw [Set.mem_iUnion] at hx\n  obtain ‚ü®t, ht, hx‚ü© := hx\n  rw [‚Üê hp.mem_set_image]\n  refine ht ?_\n  suffices x ‚àà t.preimage p hp.injOn by rwa [mem_preimage, ‚Üê mem_coe] at this\n  refine h _ x ?_\n  rwa [t.image_preimage p hp.injOn, filter_true_of_mem]\n  exact fun y hy => s.image_subset_range p (ht <| mem_coe.2 hy)\n\n"}
{"name":"Convex.convexIndependent_extremePoints","module":"Mathlib.Analysis.Convex.Independent","initialProofState":"ùïú : Type u_1\nE : Type u_2\ninst‚úù¬≤ : LinearOrderedField ùïú\ninst‚úù¬π : AddCommGroup E\ninst‚úù : Module ùïú E\ns : Set E\nhs : Convex ùïú s\n‚ä¢ ConvexIndependent ùïú Subtype.val","decl":"theorem Convex.convexIndependent_extremePoints (hs : Convex ùïú s) :\n    ConvexIndependent ùïú ((‚Üë) : s.extremePoints ùïú ‚Üí E) :=\n  convexIndependent_set_iff_not_mem_convexHull_diff.2 fun _ hx h =>\n    (extremePoints_convexHull_subset\n          (inter_extremePoints_subset_extremePoints_of_subset\n            (convexHull_min (Set.diff_subset.trans extremePoints_subset) hs) ‚ü®h, hx‚ü©)).2\n      (Set.mem_singleton _)\n\n"}
