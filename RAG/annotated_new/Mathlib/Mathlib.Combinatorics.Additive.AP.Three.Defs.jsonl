{"name":"ThreeGPFree.mono","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns t : Set α\nh : HasSubset.Subset t s\nhs : ThreeGPFree s\n⊢ ThreeGPFree t","decl":"@[to_additive]\ntheorem ThreeGPFree.mono (h : t ⊆ s) (hs : ThreeGPFree s) : ThreeGPFree t :=\n  fun _ ha _ hb _ hc ↦ hs (h ha) (h hb) (h hc)\n\n"}
{"name":"ThreeAPFree.mono","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns t : Set α\nh : HasSubset.Subset t s\nhs : ThreeAPFree s\n⊢ ThreeAPFree t","decl":"@[to_additive]\ntheorem ThreeGPFree.mono (h : t ⊆ s) (hs : ThreeGPFree s) : ThreeGPFree t :=\n  fun _ ha _ hb _ hc ↦ hs (h ha) (h hb) (h hc)\n\n"}
{"name":"threeGPFree_empty","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : Monoid α\n⊢ ThreeGPFree EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem threeGPFree_empty : ThreeGPFree (∅ : Set α) := fun _ _ _ ha => ha.elim\n\n"}
{"name":"threeAPFree_empty","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\n⊢ ThreeAPFree EmptyCollection.emptyCollection","decl":"@[to_additive (attr := simp)]\ntheorem threeGPFree_empty : ThreeGPFree (∅ : Set α) := fun _ _ _ ha => ha.elim\n\n"}
{"name":"Set.Subsingleton.threeGPFree","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : Monoid α\ns : Set α\nhs : s.Subsingleton\n⊢ ThreeGPFree s","decl":"@[to_additive]\ntheorem Set.Subsingleton.threeGPFree (hs : s.Subsingleton) : ThreeGPFree s :=\n  fun _ ha _ hb _ _ _ ↦ hs ha hb\n\n"}
{"name":"Set.Subsingleton.threeAPFree","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\ns : Set α\nhs : s.Subsingleton\n⊢ ThreeAPFree s","decl":"@[to_additive]\ntheorem Set.Subsingleton.threeGPFree (hs : s.Subsingleton) : ThreeGPFree s :=\n  fun _ ha _ hb _ _ _ ↦ hs ha hb\n\n"}
{"name":"threeGPFree_singleton","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : Monoid α\na : α\n⊢ ThreeGPFree (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem threeGPFree_singleton (a : α) : ThreeGPFree ({a} : Set α) :=\n  subsingleton_singleton.threeGPFree\n\n"}
{"name":"threeAPFree_singleton","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddMonoid α\na : α\n⊢ ThreeAPFree (Singleton.singleton a)","decl":"@[to_additive (attr := simp)]\ntheorem threeGPFree_singleton (a : α) : ThreeGPFree ({a} : Set α) :=\n  subsingleton_singleton.threeGPFree\n\n"}
{"name":"ThreeAPFree.prod","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddMonoid α\ninst✝ : AddMonoid β\ns : Set α\nt : Set β\nhs : ThreeAPFree s\nht : ThreeAPFree t\n⊢ ThreeAPFree (SProd.sprod s t)","decl":"@[to_additive ThreeAPFree.prod]\ntheorem ThreeGPFree.prod {t : Set β} (hs : ThreeGPFree s) (ht : ThreeGPFree t) :\n    ThreeGPFree (s ×ˢ t) := fun _ ha _ hb _ hc h ↦\n  Prod.ext (hs ha.1 hb.1 hc.1 (Prod.ext_iff.1 h).1) (ht ha.2 hb.2 hc.2 (Prod.ext_iff.1 h).2)\n\n"}
{"name":"ThreeGPFree.prod","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Monoid α\ninst✝ : Monoid β\ns : Set α\nt : Set β\nhs : ThreeGPFree s\nht : ThreeGPFree t\n⊢ ThreeGPFree (SProd.sprod s t)","decl":"@[to_additive ThreeAPFree.prod]\ntheorem ThreeGPFree.prod {t : Set β} (hs : ThreeGPFree s) (ht : ThreeGPFree t) :\n    ThreeGPFree (s ×ˢ t) := fun _ ha _ hb _ hc h ↦\n  Prod.ext (hs ha.1 hb.1 hc.1 (Prod.ext_iff.1 h).1) (ht ha.2 hb.2 hc.2 (Prod.ext_iff.1 h).2)\n\n"}
{"name":"threeGPFree_pi","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"ι : Type u_4\nα : ι → Type u_5\ninst✝ : (i : ι) → Monoid (α i)\ns : (i : ι) → Set (α i)\nhs : ∀ (i : ι), ThreeGPFree (s i)\n⊢ ThreeGPFree (Set.univ.pi s)","decl":"@[to_additive]\ntheorem threeGPFree_pi {ι : Type*} {α : ι → Type*} [∀ i, Monoid (α i)] {s : ∀ i, Set (α i)}\n    (hs : ∀ i, ThreeGPFree (s i)) : ThreeGPFree ((univ : Set ι).pi s) :=\n  fun _ ha _ hb _ hc h ↦\n  funext fun i => hs i (ha i trivial) (hb i trivial) (hc i trivial) <| congr_fun h i\n\n"}
{"name":"threeAPFree_pi","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"ι : Type u_4\nα : ι → Type u_5\ninst✝ : (i : ι) → AddMonoid (α i)\ns : (i : ι) → Set (α i)\nhs : ∀ (i : ι), ThreeAPFree (s i)\n⊢ ThreeAPFree (Set.univ.pi s)","decl":"@[to_additive]\ntheorem threeGPFree_pi {ι : Type*} {α : ι → Type*} [∀ i, Monoid (α i)] {s : ∀ i, Set (α i)}\n    (hs : ∀ i, ThreeGPFree (s i)) : ThreeGPFree ((univ : Set ι).pi s) :=\n  fun _ ha _ hb _ hc h ↦\n  funext fun i => hs i (ha i trivial) (hb i trivial) (hc i trivial) <| congr_fun h i\n\n"}
{"name":"ThreeGPFree.of_image","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns A : Set α\nt : Set β\nf : α → β\nhf : IsMulFreimanHom 2 s t f\nhf' : Set.InjOn f s\nhAs : HasSubset.Subset A s\nhA : ThreeGPFree (Set.image f A)\n⊢ ThreeGPFree A","decl":"/-- Geometric progressions of length three are reflected under `2`-Freiman homomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are reflected under `2`-Freiman homomorphisms.\"]\nlemma ThreeGPFree.of_image (hf : IsMulFreimanHom 2 s t f) (hf' : s.InjOn f) (hAs : A ⊆ s)\n    (hA : ThreeGPFree (f '' A)) : ThreeGPFree A :=\n  fun _ ha _ hb _ hc habc ↦ hf' (hAs ha) (hAs hb) <| hA (mem_image_of_mem _ ha)\n    (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) <|\n    hf.mul_eq_mul (hAs ha) (hAs hc) (hAs hb) (hAs hb) habc\n\n"}
{"name":"ThreeAPFree.of_image","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns A : Set α\nt : Set β\nf : α → β\nhf : IsAddFreimanHom 2 s t f\nhf' : Set.InjOn f s\nhAs : HasSubset.Subset A s\nhA : ThreeAPFree (Set.image f A)\n⊢ ThreeAPFree A","decl":"/-- Geometric progressions of length three are reflected under `2`-Freiman homomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are reflected under `2`-Freiman homomorphisms.\"]\nlemma ThreeGPFree.of_image (hf : IsMulFreimanHom 2 s t f) (hf' : s.InjOn f) (hAs : A ⊆ s)\n    (hA : ThreeGPFree (f '' A)) : ThreeGPFree A :=\n  fun _ ha _ hb _ hc habc ↦ hf' (hAs ha) (hAs hb) <| hA (mem_image_of_mem _ ha)\n    (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) <|\n    hf.mul_eq_mul (hAs ha) (hAs hc) (hAs hb) (hAs hb) habc\n\n"}
{"name":"threeGPFree_image","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns A : Set α\nt : Set β\nf : α → β\nhf : IsMulFreimanIso 2 s t f\nhAs : HasSubset.Subset A s\n⊢ Iff (ThreeGPFree (Set.image f A)) (ThreeGPFree A)","decl":"/-- Geometric progressions of length three are unchanged under `2`-Freiman isomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are unchanged under `2`-Freiman isomorphisms.\"]\nlemma threeGPFree_image (hf : IsMulFreimanIso 2 s t f) (hAs : A ⊆ s) :\n    ThreeGPFree (f '' A) ↔ ThreeGPFree A := by\n  rw [ThreeGPFree, ThreeGPFree]\n  have := (hf.bijOn.injOn.mono hAs).bijOn_image (f := f)\n  simp +contextual only\n    [((hf.bijOn.injOn.mono hAs).bijOn_image (f := f)).forall,\n    hf.mul_eq_mul (hAs _) (hAs _) (hAs _) (hAs _), this.injOn.eq_iff]\n\n"}
{"name":"threeAPFree_image","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns A : Set α\nt : Set β\nf : α → β\nhf : IsAddFreimanIso 2 s t f\nhAs : HasSubset.Subset A s\n⊢ Iff (ThreeAPFree (Set.image f A)) (ThreeAPFree A)","decl":"/-- Geometric progressions of length three are unchanged under `2`-Freiman isomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are unchanged under `2`-Freiman isomorphisms.\"]\nlemma threeGPFree_image (hf : IsMulFreimanIso 2 s t f) (hAs : A ⊆ s) :\n    ThreeGPFree (f '' A) ↔ ThreeGPFree A := by\n  rw [ThreeGPFree, ThreeGPFree]\n  have := (hf.bijOn.injOn.mono hAs).bijOn_image (f := f)\n  simp +contextual only\n    [((hf.bijOn.injOn.mono hAs).bijOn_image (f := f)).forall,\n    hf.mul_eq_mul (hAs _) (hAs _) (hAs _) (hAs _), this.injOn.eq_iff]\n\n"}
{"name":"ThreeGPFree.image","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns A : Set α\nt : Set β\nf : α → β\nhf : IsMulFreimanIso 2 s t f\nhAs : HasSubset.Subset A s\na✝ : ThreeGPFree A\n⊢ ThreeGPFree (Set.image f A)","decl":"@[to_additive] alias ⟨_, ThreeGPFree.image⟩ := threeGPFree_image\n\n"}
{"name":"ThreeAPFree.image","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns A : Set α\nt : Set β\nf : α → β\nhf : IsAddFreimanIso 2 s t f\nhAs : HasSubset.Subset A s\na✝ : ThreeAPFree A\n⊢ ThreeAPFree (Set.image f A)","decl":"@[to_additive] alias ⟨_, ThreeGPFree.image⟩ := threeGPFree_image\n\n"}
{"name":"IsMulFreimanHom.threeGPFree","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Set α\nt : Set β\nf : α → β\nhf : IsMulFreimanHom 2 s t f\nhf' : Set.InjOn f s\nht : ThreeGPFree t\n⊢ ThreeGPFree s","decl":"/-- Geometric progressions of length three are reflected under `2`-Freiman homomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are reflected under `2`-Freiman homomorphisms.\"]\nlemma IsMulFreimanHom.threeGPFree (hf : IsMulFreimanHom 2 s t f) (hf' : s.InjOn f)\n    (ht : ThreeGPFree t) : ThreeGPFree s :=\n  (ht.mono hf.mapsTo.image_subset).of_image hf hf' subset_rfl\n\n"}
{"name":"IsAddFreimanHom.threeAPFree","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Set α\nt : Set β\nf : α → β\nhf : IsAddFreimanHom 2 s t f\nhf' : Set.InjOn f s\nht : ThreeAPFree t\n⊢ ThreeAPFree s","decl":"/-- Geometric progressions of length three are reflected under `2`-Freiman homomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are reflected under `2`-Freiman homomorphisms.\"]\nlemma IsMulFreimanHom.threeGPFree (hf : IsMulFreimanHom 2 s t f) (hf' : s.InjOn f)\n    (ht : ThreeGPFree t) : ThreeGPFree s :=\n  (ht.mono hf.mapsTo.image_subset).of_image hf hf' subset_rfl\n\n"}
{"name":"IsAddFreimanIso.threeAPFree_congr","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : AddCommMonoid α\ninst✝ : AddCommMonoid β\ns : Set α\nt : Set β\nf : α → β\nhf : IsAddFreimanIso 2 s t f\n⊢ Iff (ThreeAPFree s) (ThreeAPFree t)","decl":"/-- Geometric progressions of length three are unchanged under `2`-Freiman isomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are unchanged under `2`-Freiman isomorphisms.\"]\nlemma IsMulFreimanIso.threeGPFree_congr (hf : IsMulFreimanIso 2 s t f) :\n    ThreeGPFree s ↔ ThreeGPFree t := by\n  rw [← threeGPFree_image hf subset_rfl, hf.bijOn.image_eq]\n\n"}
{"name":"IsMulFreimanIso.threeGPFree_congr","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : CommMonoid α\ninst✝ : CommMonoid β\ns : Set α\nt : Set β\nf : α → β\nhf : IsMulFreimanIso 2 s t f\n⊢ Iff (ThreeGPFree s) (ThreeGPFree t)","decl":"/-- Geometric progressions of length three are unchanged under `2`-Freiman isomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are unchanged under `2`-Freiman isomorphisms.\"]\nlemma IsMulFreimanIso.threeGPFree_congr (hf : IsMulFreimanIso 2 s t f) :\n    ThreeGPFree s ↔ ThreeGPFree t := by\n  rw [← threeGPFree_image hf subset_rfl, hf.bijOn.image_eq]\n\n"}
{"name":"ThreeGPFree.image'","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : CommMonoid α\ninst✝² : CommMonoid β\ns : Set α\ninst✝¹ : FunLike F α β\ninst✝ : MulHomClass F α β\nf : F\nhf : Set.InjOn (⇑f) (HMul.hMul s s)\nh : ThreeGPFree s\n⊢ ThreeGPFree (Set.image (⇑f) s)","decl":"/-- Geometric progressions of length three are preserved under semigroup homomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are preserved under semigroup homomorphisms.\"]\ntheorem ThreeGPFree.image' [FunLike F α β] [MulHomClass F α β] (f : F) (hf : (s * s).InjOn f)\n    (h : ThreeGPFree s) : ThreeGPFree (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ _ ⟨c, hc, rfl⟩ habc\n  rw [h ha hb hc (hf (mul_mem_mul ha hc) (mul_mem_mul hb hb) <| by rwa [map_mul, map_mul])]\n\n"}
{"name":"ThreeAPFree.image'","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"F : Type u_1\nα : Type u_2\nβ : Type u_3\ninst✝³ : AddCommMonoid α\ninst✝² : AddCommMonoid β\ns : Set α\ninst✝¹ : FunLike F α β\ninst✝ : AddHomClass F α β\nf : F\nhf : Set.InjOn (⇑f) (HAdd.hAdd s s)\nh : ThreeAPFree s\n⊢ ThreeAPFree (Set.image (⇑f) s)","decl":"/-- Geometric progressions of length three are preserved under semigroup homomorphisms. -/\n@[to_additive\n\"Arithmetic progressions of length three are preserved under semigroup homomorphisms.\"]\ntheorem ThreeGPFree.image' [FunLike F α β] [MulHomClass F α β] (f : F) (hf : (s * s).InjOn f)\n    (h : ThreeGPFree s) : ThreeGPFree (f '' s) := by\n  rintro _ ⟨a, ha, rfl⟩ _ ⟨b, hb, rfl⟩ _ ⟨c, hc, rfl⟩ habc\n  rw [h ha hb hc (hf (mul_mem_mul ha hc) (mul_mem_mul hb hb) <| by rwa [map_mul, map_mul])]\n\n"}
{"name":"ThreeGPFree.eq_right","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoid α\ns : Set α\nhs : ThreeGPFree s\na : α\na✝³ : Membership.mem s a\nb : α\na✝² : Membership.mem s b\nc : α\na✝¹ : Membership.mem s c\na✝ : Eq (HMul.hMul a c) (HMul.hMul b b)\n⊢ Eq b c","decl":"@[to_additive] lemma ThreeGPFree.eq_right (hs : ThreeGPFree s) :\n    ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a * c = b * b → b = c := by\n  rintro a ha b hb c hc habc\n  obtain rfl := hs ha hb hc habc\n  simpa using habc.symm\n\n"}
{"name":"ThreeAPFree.eq_right","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddCancelCommMonoid α\ns : Set α\nhs : ThreeAPFree s\na : α\na✝³ : Membership.mem s a\nb : α\na✝² : Membership.mem s b\nc : α\na✝¹ : Membership.mem s c\na✝ : Eq (HAdd.hAdd a c) (HAdd.hAdd b b)\n⊢ Eq b c","decl":"@[to_additive] lemma ThreeGPFree.eq_right (hs : ThreeGPFree s) :\n    ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a * c = b * b → b = c := by\n  rintro a ha b hb c hc habc\n  obtain rfl := hs ha hb hc habc\n  simpa using habc.symm\n\n"}
{"name":"threeAPFree_insert","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddCancelCommMonoid α\ns : Set α\na : α\n⊢ Iff (ThreeAPFree (Insert.insert a s)) (And (ThreeAPFree s) (And (∀ ⦃b : α⦄, Membership.mem s b → ∀ ⦃c : α⦄, Membership.mem s c → Eq (HAdd.hAdd a c) (HAdd.hAdd b b) → Eq a b) (∀ ⦃b : α⦄, Membership.mem s b → ∀ ⦃c : α⦄, Membership.mem s c → Eq (HAdd.hAdd b c) (HAdd.hAdd a a) → Eq b a)))","decl":"@[to_additive] lemma threeGPFree_insert :\n    ThreeGPFree (insert a s) ↔ ThreeGPFree s ∧\n      (∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a * c = b * b → a = b) ∧\n        ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → b * c = a * a → b = a := by\n  refine ⟨fun hs ↦ ⟨hs.mono (subset_insert _ _),\n    fun b hb c hc ↦ hs (Or.inl rfl) (Or.inr hb) (Or.inr hc),\n    fun b hb c hc ↦ hs (Or.inr hb) (Or.inl rfl) (Or.inr hc)⟩, ?_⟩\n  rintro ⟨hs, ha, ha'⟩ b hb c hc d hd h\n  rw [mem_insert_iff] at hb hc hd\n  obtain rfl | hb := hb <;> obtain rfl | hc := hc\n  · rfl\n  all_goals obtain rfl | hd := hd\n  · exact (ha' hc hc h.symm).symm\n  · exact ha hc hd h\n  · exact mul_right_cancel h\n  · exact ha' hb hd h\n  · obtain rfl := ha hc hb ((mul_comm _ _).trans h)\n    exact ha' hb hc h\n  · exact hs hb hc hd h\n\n"}
{"name":"threeGPFree_insert","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoid α\ns : Set α\na : α\n⊢ Iff (ThreeGPFree (Insert.insert a s)) (And (ThreeGPFree s) (And (∀ ⦃b : α⦄, Membership.mem s b → ∀ ⦃c : α⦄, Membership.mem s c → Eq (HMul.hMul a c) (HMul.hMul b b) → Eq a b) (∀ ⦃b : α⦄, Membership.mem s b → ∀ ⦃c : α⦄, Membership.mem s c → Eq (HMul.hMul b c) (HMul.hMul a a) → Eq b a)))","decl":"@[to_additive] lemma threeGPFree_insert :\n    ThreeGPFree (insert a s) ↔ ThreeGPFree s ∧\n      (∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a * c = b * b → a = b) ∧\n        ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → b * c = a * a → b = a := by\n  refine ⟨fun hs ↦ ⟨hs.mono (subset_insert _ _),\n    fun b hb c hc ↦ hs (Or.inl rfl) (Or.inr hb) (Or.inr hc),\n    fun b hb c hc ↦ hs (Or.inr hb) (Or.inl rfl) (Or.inr hc)⟩, ?_⟩\n  rintro ⟨hs, ha, ha'⟩ b hb c hc d hd h\n  rw [mem_insert_iff] at hb hc hd\n  obtain rfl | hb := hb <;> obtain rfl | hc := hc\n  · rfl\n  all_goals obtain rfl | hd := hd\n  · exact (ha' hc hc h.symm).symm\n  · exact ha hc hd h\n  · exact mul_right_cancel h\n  · exact ha' hb hd h\n  · obtain rfl := ha hc hb ((mul_comm _ _).trans h)\n    exact ha' hb hc h\n  · exact hs hb hc hd h\n\n"}
{"name":"ThreeGPFree.smul_set","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoid α\ns : Set α\na : α\nhs : ThreeGPFree s\n⊢ ThreeGPFree (HSMul.hSMul a s)","decl":"@[to_additive]\ntheorem ThreeGPFree.smul_set (hs : ThreeGPFree s) : ThreeGPFree (a • s) := by\n  rintro _ ⟨b, hb, rfl⟩ _ ⟨c, hc, rfl⟩ _ ⟨d, hd, rfl⟩ h\n  exact congr_arg (a • ·) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a] using h\n\n"}
{"name":"ThreeAPFree.vadd_set","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddCancelCommMonoid α\ns : Set α\na : α\nhs : ThreeAPFree s\n⊢ ThreeAPFree (HVAdd.hVAdd a s)","decl":"@[to_additive]\ntheorem ThreeGPFree.smul_set (hs : ThreeGPFree s) : ThreeGPFree (a • s) := by\n  rintro _ ⟨b, hb, rfl⟩ _ ⟨c, hc, rfl⟩ _ ⟨d, hd, rfl⟩ h\n  exact congr_arg (a • ·) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a] using h\n\n"}
{"name":"threeGPFree_smul_set","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : CancelCommMonoid α\ns : Set α\na : α\n⊢ Iff (ThreeGPFree (HSMul.hSMul a s)) (ThreeGPFree s)","decl":"@[to_additive] lemma threeGPFree_smul_set : ThreeGPFree (a • s) ↔ ThreeGPFree s where\n  mp hs b hb c hc d hd h := mul_left_cancel\n      (hs (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) (mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, smul_eq_mul, smul_eq_mul, mul_mul_mul_comm, h])\n  mpr := ThreeGPFree.smul_set\n\n"}
{"name":"threeAPFree_vadd_set","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : AddCancelCommMonoid α\ns : Set α\na : α\n⊢ Iff (ThreeAPFree (HVAdd.hVAdd a s)) (ThreeAPFree s)","decl":"@[to_additive] lemma threeGPFree_smul_set : ThreeGPFree (a • s) ↔ ThreeGPFree s where\n  mp hs b hb c hc d hd h := mul_left_cancel\n      (hs (mem_image_of_mem _ hb) (mem_image_of_mem _ hc) (mem_image_of_mem _ hd) <| by\n        rw [mul_mul_mul_comm, smul_eq_mul, smul_eq_mul, mul_mul_mul_comm, h])\n  mpr := ThreeGPFree.smul_set\n\n"}
{"name":"threeGPFree_insert_of_lt","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : OrderedCancelCommMonoid α\ns : Set α\na : α\nhs : ∀ (i : α), Membership.mem s i → LT.lt i a\n⊢ Iff (ThreeGPFree (Insert.insert a s)) (And (ThreeGPFree s) (∀ ⦃b : α⦄, Membership.mem s b → ∀ ⦃c : α⦄, Membership.mem s c → Eq (HMul.hMul a c) (HMul.hMul b b) → Eq a b))","decl":"@[to_additive]\ntheorem threeGPFree_insert_of_lt (hs : ∀ i ∈ s, i < a) :\n    ThreeGPFree (insert a s) ↔\n      ThreeGPFree s ∧ ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a * c = b * b → a = b := by\n  refine threeGPFree_insert.trans ?_\n  rw [← and_assoc]\n  exact and_iff_left fun b hb c hc h => ((mul_lt_mul_of_lt_of_lt (hs _ hb) (hs _ hc)).ne h).elim\n\n"}
{"name":"threeAPFree_insert_of_lt","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝ : OrderedCancelAddCommMonoid α\ns : Set α\na : α\nhs : ∀ (i : α), Membership.mem s i → LT.lt i a\n⊢ Iff (ThreeAPFree (Insert.insert a s)) (And (ThreeAPFree s) (∀ ⦃b : α⦄, Membership.mem s b → ∀ ⦃c : α⦄, Membership.mem s c → Eq (HAdd.hAdd a c) (HAdd.hAdd b b) → Eq a b))","decl":"@[to_additive]\ntheorem threeGPFree_insert_of_lt (hs : ∀ i ∈ s, i < a) :\n    ThreeGPFree (insert a s) ↔\n      ThreeGPFree s ∧ ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a * c = b * b → a = b := by\n  refine threeGPFree_insert.trans ?_\n  rw [← and_assoc]\n  exact and_iff_left fun b hb c hc h => ((mul_lt_mul_of_lt_of_lt (hs _ hb) (hs _ hc)).ne h).elim\n\n"}
{"name":"ThreeGPFree.smul_set₀","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NoZeroDivisors α\ns : Set α\na : α\nhs : ThreeGPFree s\nha : Ne a 0\n⊢ ThreeGPFree (HSMul.hSMul a s)","decl":"lemma ThreeGPFree.smul_set₀ (hs : ThreeGPFree s) (ha : a ≠ 0) : ThreeGPFree (a • s) := by\n  rintro _ ⟨b, hb, rfl⟩ _ ⟨c, hc, rfl⟩ _ ⟨d, hd, rfl⟩ h\n  exact congr_arg (a • ·) <| hs hb hc hd <| by simpa [mul_mul_mul_comm _ _ a, ha] using h\n\n"}
{"name":"threeGPFree_smul_set₀","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : CancelCommMonoidWithZero α\ninst✝ : NoZeroDivisors α\ns : Set α\na : α\nha : Ne a 0\n⊢ Iff (ThreeGPFree (HSMul.hSMul a s)) (ThreeGPFree s)","decl":"theorem threeGPFree_smul_set₀ (ha : a ≠ 0) : ThreeGPFree (a • s) ↔ ThreeGPFree s :=\n  ⟨fun hs b hb c hc d hd h ↦\n    mul_left_cancel₀ ha\n      (hs (Set.mem_image_of_mem _ hb) (Set.mem_image_of_mem _ hc) (Set.mem_image_of_mem _ hd) <| by\n        rw [smul_eq_mul, smul_eq_mul, mul_mul_mul_comm, h, mul_mul_mul_comm]),\n    fun hs => hs.smul_set₀ ha⟩\n\n"}
{"name":"threeAPFree_iff_eq_right","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"s : Set Nat\n⊢ Iff (ThreeAPFree s) (∀ ⦃a : Nat⦄, Membership.mem s a → ∀ ⦃b : Nat⦄, Membership.mem s b → ∀ ⦃c : Nat⦄, Membership.mem s c → Eq (HAdd.hAdd a c) (HAdd.hAdd b b) → Eq a c)","decl":"theorem threeAPFree_iff_eq_right {s : Set ℕ} :\n    ThreeAPFree s ↔ ∀ ⦃a⦄, a ∈ s → ∀ ⦃b⦄, b ∈ s → ∀ ⦃c⦄, c ∈ s → a + c = b + b → a = c := by\n  refine forall₄_congr fun a _ha b hb => forall₃_congr fun c hc habc => ⟨?_, ?_⟩\n  · rintro rfl\n    exact (add_left_cancel habc).symm\n  · rintro rfl\n    simp_rw [← two_mul] at habc\n    exact mul_left_cancel₀ two_ne_zero habc\n\n"}
{"name":"mulRothNumber_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\n⊢ LE.le (mulRothNumber s) s.card","decl":"@[to_additive]\ntheorem mulRothNumber_le : mulRothNumber s ≤ #s := Nat.findGreatest_le #s\n\n"}
{"name":"addRothNumber_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\n⊢ LE.le (addRothNumber s) s.card","decl":"@[to_additive]\ntheorem mulRothNumber_le : mulRothNumber s ≤ #s := Nat.findGreatest_le #s\n\n"}
{"name":"mulRothNumber_spec","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\n⊢ Exists fun t => And (HasSubset.Subset t s) (And (Eq t.card (mulRothNumber s)) (ThreeGPFree ↑t))","decl":"@[to_additive]\ntheorem mulRothNumber_spec :\n    ∃ t ⊆ s, #t = mulRothNumber s ∧ ThreeGPFree (t : Set α) :=\n  Nat.findGreatest_spec (P := fun m ↦ ∃ t ⊆ s, #t = m ∧ ThreeGPFree (t : Set α))\n    (Nat.zero_le _) ⟨∅, empty_subset _, card_empty, by norm_cast; exact threeGPFree_empty⟩\n\n"}
{"name":"addRothNumber_spec","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\n⊢ Exists fun t => And (HasSubset.Subset t s) (And (Eq t.card (addRothNumber s)) (ThreeAPFree ↑t))","decl":"@[to_additive]\ntheorem mulRothNumber_spec :\n    ∃ t ⊆ s, #t = mulRothNumber s ∧ ThreeGPFree (t : Set α) :=\n  Nat.findGreatest_spec (P := fun m ↦ ∃ t ⊆ s, #t = m ∧ ThreeGPFree (t : Set α))\n    (Nat.zero_le _) ⟨∅, empty_subset _, card_empty, by norm_cast; exact threeGPFree_empty⟩\n\n"}
{"name":"ThreeAPFree.le_addRothNumber","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns t : Finset α\nhs : ThreeAPFree ↑s\nh : HasSubset.Subset s t\n⊢ LE.le s.card (addRothNumber t)","decl":"@[to_additive]\ntheorem ThreeGPFree.le_mulRothNumber (hs : ThreeGPFree (s : Set α)) (h : s ⊆ t) :\n    #s ≤ mulRothNumber t :=\n  Nat.le_findGreatest (card_le_card h) ⟨s, h, rfl, hs⟩\n\n"}
{"name":"ThreeGPFree.le_mulRothNumber","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns t : Finset α\nhs : ThreeGPFree ↑s\nh : HasSubset.Subset s t\n⊢ LE.le s.card (mulRothNumber t)","decl":"@[to_additive]\ntheorem ThreeGPFree.le_mulRothNumber (hs : ThreeGPFree (s : Set α)) (h : s ⊆ t) :\n    #s ≤ mulRothNumber t :=\n  Nat.le_findGreatest (card_le_card h) ⟨s, h, rfl, hs⟩\n\n"}
{"name":"ThreeAPFree.addRothNumber_eq","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nhs : ThreeAPFree ↑s\n⊢ Eq (addRothNumber s) s.card","decl":"@[to_additive]\ntheorem ThreeGPFree.mulRothNumber_eq (hs : ThreeGPFree (s : Set α)) :\n    mulRothNumber s = #s :=\n  (mulRothNumber_le _).antisymm <| hs.le_mulRothNumber <| Subset.refl _\n\n"}
{"name":"ThreeGPFree.mulRothNumber_eq","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nhs : ThreeGPFree ↑s\n⊢ Eq (mulRothNumber s) s.card","decl":"@[to_additive]\ntheorem ThreeGPFree.mulRothNumber_eq (hs : ThreeGPFree (s : Set α)) :\n    mulRothNumber s = #s :=\n  (mulRothNumber_le _).antisymm <| hs.le_mulRothNumber <| Subset.refl _\n\n"}
{"name":"mulRothNumber_empty","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\n⊢ Eq (mulRothNumber EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_empty : mulRothNumber (∅ : Finset α) = 0 :=\n  Nat.eq_zero_of_le_zero <| (mulRothNumber_le _).trans card_empty.le\n\n"}
{"name":"addRothNumber_empty","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\n⊢ Eq (addRothNumber EmptyCollection.emptyCollection) 0","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_empty : mulRothNumber (∅ : Finset α) = 0 :=\n  Nat.eq_zero_of_le_zero <| (mulRothNumber_le _).trans card_empty.le\n\n"}
{"name":"addRothNumber_singleton","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\na : α\n⊢ Eq (addRothNumber (Singleton.singleton a)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_singleton (a : α) : mulRothNumber ({a} : Finset α) = 1 := by\n  refine ThreeGPFree.mulRothNumber_eq ?_\n  rw [coe_singleton]\n  exact threeGPFree_singleton a\n\n"}
{"name":"mulRothNumber_singleton","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\na : α\n⊢ Eq (mulRothNumber (Singleton.singleton a)) 1","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_singleton (a : α) : mulRothNumber ({a} : Finset α) = 1 := by\n  refine ThreeGPFree.mulRothNumber_eq ?_\n  rw [coe_singleton]\n  exact threeGPFree_singleton a\n\n"}
{"name":"mulRothNumber_union_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns t : Finset α\n⊢ LE.le (mulRothNumber (Union.union s t)) (HAdd.hAdd (mulRothNumber s) (mulRothNumber t))","decl":"@[to_additive]\ntheorem mulRothNumber_union_le (s t : Finset α) :\n    mulRothNumber (s ∪ t) ≤ mulRothNumber s + mulRothNumber t :=\n  let ⟨u, hus, hcard, hu⟩ := mulRothNumber_spec (s ∪ t)\n  calc\n    mulRothNumber (s ∪ t) = #u := hcard.symm\n    _ = #(u ∩ s ∪ u ∩ t) := by rw [← inter_union_distrib_left, inter_eq_left.2 hus]\n    _ ≤ #(u ∩ s) + #(u ∩ t) := card_union_le _ _\n    _ ≤ mulRothNumber s + mulRothNumber t := _root_.add_le_add\n      ((hu.mono inter_subset_left).le_mulRothNumber inter_subset_right)\n      ((hu.mono inter_subset_left).le_mulRothNumber inter_subset_right)\n\n"}
{"name":"addRothNumber_union_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns t : Finset α\n⊢ LE.le (addRothNumber (Union.union s t)) (HAdd.hAdd (addRothNumber s) (addRothNumber t))","decl":"@[to_additive]\ntheorem mulRothNumber_union_le (s t : Finset α) :\n    mulRothNumber (s ∪ t) ≤ mulRothNumber s + mulRothNumber t :=\n  let ⟨u, hus, hcard, hu⟩ := mulRothNumber_spec (s ∪ t)\n  calc\n    mulRothNumber (s ∪ t) = #u := hcard.symm\n    _ = #(u ∩ s ∪ u ∩ t) := by rw [← inter_union_distrib_left, inter_eq_left.2 hus]\n    _ ≤ #(u ∩ s) + #(u ∩ t) := card_union_le _ _\n    _ ≤ mulRothNumber s + mulRothNumber t := _root_.add_le_add\n      ((hu.mono inter_subset_left).le_mulRothNumber inter_subset_right)\n      ((hu.mono inter_subset_left).le_mulRothNumber inter_subset_right)\n\n"}
{"name":"le_addRothNumber_product","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : AddMonoid α\ninst✝¹ : DecidableEq β\ninst✝ : AddMonoid β\ns : Finset α\nt : Finset β\n⊢ LE.le (HMul.hMul (addRothNumber s) (addRothNumber t)) (addRothNumber (SProd.sprod s t))","decl":"@[to_additive]\ntheorem le_mulRothNumber_product (s : Finset α) (t : Finset β) :\n    mulRothNumber s * mulRothNumber t ≤ mulRothNumber (s ×ˢ t) := by\n  obtain ⟨u, hus, hucard, hu⟩ := mulRothNumber_spec s\n  obtain ⟨v, hvt, hvcard, hv⟩ := mulRothNumber_spec t\n  rw [← hucard, ← hvcard, ← card_product]\n  refine ThreeGPFree.le_mulRothNumber ?_ (product_subset_product hus hvt)\n  rw [coe_product]\n  exact hu.prod hv\n\n"}
{"name":"le_mulRothNumber_product","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : Monoid α\ninst✝¹ : DecidableEq β\ninst✝ : Monoid β\ns : Finset α\nt : Finset β\n⊢ LE.le (HMul.hMul (mulRothNumber s) (mulRothNumber t)) (mulRothNumber (SProd.sprod s t))","decl":"@[to_additive]\ntheorem le_mulRothNumber_product (s : Finset α) (t : Finset β) :\n    mulRothNumber s * mulRothNumber t ≤ mulRothNumber (s ×ˢ t) := by\n  obtain ⟨u, hus, hucard, hu⟩ := mulRothNumber_spec s\n  obtain ⟨v, hvt, hvcard, hv⟩ := mulRothNumber_spec t\n  rw [← hucard, ← hvcard, ← card_product]\n  refine ThreeGPFree.le_mulRothNumber ?_ (product_subset_product hus hvt)\n  rw [coe_product]\n  exact hu.prod hv\n\n"}
{"name":"addRothNumber_lt_of_forall_not_threeAPFree","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddMonoid α\ns : Finset α\nn : Nat\nh : ∀ (t : Finset α), Membership.mem (Finset.powersetCard n s) t → Not (ThreeAPFree ↑t)\n⊢ LT.lt (addRothNumber s) n","decl":"@[to_additive]\ntheorem mulRothNumber_lt_of_forall_not_threeGPFree\n    (h : ∀ t ∈ powersetCard n s, ¬ThreeGPFree ((t : Finset α) : Set α)) :\n    mulRothNumber s < n := by\n  obtain ⟨t, hts, hcard, ht⟩ := mulRothNumber_spec s\n  rw [← hcard, ← not_le]\n  intro hn\n  obtain ⟨u, hut, rfl⟩ := exists_subset_card_eq hn\n  exact h _ (mem_powersetCard.2 ⟨hut.trans hts, rfl⟩) (ht.mono hut)\n\n"}
{"name":"mulRothNumber_lt_of_forall_not_threeGPFree","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : Monoid α\ns : Finset α\nn : Nat\nh : ∀ (t : Finset α), Membership.mem (Finset.powersetCard n s) t → Not (ThreeGPFree ↑t)\n⊢ LT.lt (mulRothNumber s) n","decl":"@[to_additive]\ntheorem mulRothNumber_lt_of_forall_not_threeGPFree\n    (h : ∀ t ∈ powersetCard n s, ¬ThreeGPFree ((t : Finset α) : Set α)) :\n    mulRothNumber s < n := by\n  obtain ⟨t, hts, hcard, ht⟩ := mulRothNumber_spec s\n  rw [← hcard, ← not_le]\n  intro hn\n  obtain ⟨u, hut, rfl⟩ := exists_subset_card_eq hn\n  exact h _ (mem_powersetCard.2 ⟨hut.trans hts, rfl⟩) (ht.mono hut)\n\n"}
{"name":"IsMulFreimanHom.mulRothNumber_mono","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq β\nA : Finset α\nB : Finset β\nf : α → β\nhf : IsMulFreimanHom 2 (↑A) (↑B) f\nhf' : Set.BijOn f ↑A ↑B\n⊢ LE.le (mulRothNumber B) (mulRothNumber A)","decl":"/-- Arithmetic progressions can be pushed forward along bijective 2-Freiman homs. -/\n@[to_additive \"Arithmetic progressions can be pushed forward along bijective 2-Freiman homs.\"]\nlemma IsMulFreimanHom.mulRothNumber_mono (hf : IsMulFreimanHom 2 A B f) (hf' : Set.BijOn f A B) :\n    mulRothNumber B ≤ mulRothNumber A := by\n  obtain ⟨s, hsB, hcard, hs⟩ := mulRothNumber_spec B\n  have hsA : invFunOn f A '' s ⊆ A :=\n    (hf'.surjOn.mapsTo_invFunOn.mono (coe_subset.2 hsB) Subset.rfl).image_subset\n  have hfsA : Set.SurjOn f A s := hf'.surjOn.mono Subset.rfl (coe_subset.2 hsB)\n  rw [← hcard, ← s.card_image_of_injOn ((invFunOn_injOn_image f _).mono hfsA)]\n  refine ThreeGPFree.le_mulRothNumber ?_ (mod_cast hsA)\n  rw [coe_image]\n\n  simpa using (hf.subset hsA hfsA.bijOn_subset.mapsTo).threeGPFree (hf'.injOn.mono hsA) hs\n\n"}
{"name":"IsAddFreimanHom.addRothNumber_mono","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq β\nA : Finset α\nB : Finset β\nf : α → β\nhf : IsAddFreimanHom 2 (↑A) (↑B) f\nhf' : Set.BijOn f ↑A ↑B\n⊢ LE.le (addRothNumber B) (addRothNumber A)","decl":"/-- Arithmetic progressions can be pushed forward along bijective 2-Freiman homs. -/\n@[to_additive \"Arithmetic progressions can be pushed forward along bijective 2-Freiman homs.\"]\nlemma IsMulFreimanHom.mulRothNumber_mono (hf : IsMulFreimanHom 2 A B f) (hf' : Set.BijOn f A B) :\n    mulRothNumber B ≤ mulRothNumber A := by\n  obtain ⟨s, hsB, hcard, hs⟩ := mulRothNumber_spec B\n  have hsA : invFunOn f A '' s ⊆ A :=\n    (hf'.surjOn.mapsTo_invFunOn.mono (coe_subset.2 hsB) Subset.rfl).image_subset\n  have hfsA : Set.SurjOn f A s := hf'.surjOn.mono Subset.rfl (coe_subset.2 hsB)\n  rw [← hcard, ← s.card_image_of_injOn ((invFunOn_injOn_image f _).mono hfsA)]\n  refine ThreeGPFree.le_mulRothNumber ?_ (mod_cast hsA)\n  rw [coe_image]\n\n  simpa using (hf.subset hsA hfsA.bijOn_subset.mapsTo).threeGPFree (hf'.injOn.mono hsA) hs\n\n"}
{"name":"IsMulFreimanIso.mulRothNumber_congr","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : CommMonoid α\ninst✝¹ : CommMonoid β\ninst✝ : DecidableEq β\nA : Finset α\nB : Finset β\nf : α → β\nhf : IsMulFreimanIso 2 (↑A) (↑B) f\n⊢ Eq (mulRothNumber A) (mulRothNumber B)","decl":"/-- Arithmetic progressions are preserved under 2-Freiman isos. -/\n@[to_additive \"Arithmetic progressions are preserved under 2-Freiman isos.\"]\nlemma IsMulFreimanIso.mulRothNumber_congr (hf : IsMulFreimanIso 2 A B f) :\n    mulRothNumber A = mulRothNumber B := by\n  refine le_antisymm ?_ (hf.isMulFreimanHom.mulRothNumber_mono hf.bijOn)\n  obtain ⟨s, hsA, hcard, hs⟩ := mulRothNumber_spec A\n  rw [← coe_subset] at hsA\n  have hfs : Set.InjOn f s := hf.bijOn.injOn.mono hsA\n  have := (hf.subset hsA hfs.bijOn_image).threeGPFree_congr.1 hs\n  rw [← coe_image] at this\n  rw [← hcard, ← Finset.card_image_of_injOn hfs]\n  refine this.le_mulRothNumber ?_\n  rw [← coe_subset, coe_image]\n  exact (hf.bijOn.mapsTo.mono hsA Subset.rfl).image_subset\n\n"}
{"name":"IsAddFreimanIso.addRothNumber_congr","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝³ : DecidableEq α\ninst✝² : AddCommMonoid α\ninst✝¹ : AddCommMonoid β\ninst✝ : DecidableEq β\nA : Finset α\nB : Finset β\nf : α → β\nhf : IsAddFreimanIso 2 (↑A) (↑B) f\n⊢ Eq (addRothNumber A) (addRothNumber B)","decl":"/-- Arithmetic progressions are preserved under 2-Freiman isos. -/\n@[to_additive \"Arithmetic progressions are preserved under 2-Freiman isos.\"]\nlemma IsMulFreimanIso.mulRothNumber_congr (hf : IsMulFreimanIso 2 A B f) :\n    mulRothNumber A = mulRothNumber B := by\n  refine le_antisymm ?_ (hf.isMulFreimanHom.mulRothNumber_mono hf.bijOn)\n  obtain ⟨s, hsA, hcard, hs⟩ := mulRothNumber_spec A\n  rw [← coe_subset] at hsA\n  have hfs : Set.InjOn f s := hf.bijOn.injOn.mono hsA\n  have := (hf.subset hsA hfs.bijOn_image).threeGPFree_congr.1 hs\n  rw [← coe_image] at this\n  rw [← hcard, ← Finset.card_image_of_injOn hfs]\n  refine this.le_mulRothNumber ?_\n  rw [← coe_subset, coe_image]\n  exact (hf.bijOn.mapsTo.mono hsA Subset.rfl).image_subset\n\n"}
{"name":"mulRothNumber_map_mul_left","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CancelCommMonoid α\ns : Finset α\na : α\n⊢ Eq (mulRothNumber (Finset.map (mulLeftEmbedding a) s)) (mulRothNumber s)","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_map_mul_left :\n    mulRothNumber (s.map <| mulLeftEmbedding a) = mulRothNumber s := by\n  refine le_antisymm ?_ ?_\n  · obtain ⟨u, hus, hcard, hu⟩ := mulRothNumber_spec (s.map <| mulLeftEmbedding a)\n    rw [subset_map_iff] at hus\n    obtain ⟨u, hus, rfl⟩ := hus\n    rw [coe_map] at hu\n    rw [← hcard, card_map]\n    exact (threeGPFree_smul_set.1 hu).le_mulRothNumber hus\n  · obtain ⟨u, hus, hcard, hu⟩ := mulRothNumber_spec s\n    have h : ThreeGPFree (u.map <| mulLeftEmbedding a : Set α) := by rw [coe_map]; exact hu.smul_set\n    convert h.le_mulRothNumber (map_subset_map.2 hus) using 1\n    rw [card_map, hcard]\n\n"}
{"name":"addRothNumber_map_add_left","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCancelCommMonoid α\ns : Finset α\na : α\n⊢ Eq (addRothNumber (Finset.map (addLeftEmbedding a) s)) (addRothNumber s)","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_map_mul_left :\n    mulRothNumber (s.map <| mulLeftEmbedding a) = mulRothNumber s := by\n  refine le_antisymm ?_ ?_\n  · obtain ⟨u, hus, hcard, hu⟩ := mulRothNumber_spec (s.map <| mulLeftEmbedding a)\n    rw [subset_map_iff] at hus\n    obtain ⟨u, hus, rfl⟩ := hus\n    rw [coe_map] at hu\n    rw [← hcard, card_map]\n    exact (threeGPFree_smul_set.1 hu).le_mulRothNumber hus\n  · obtain ⟨u, hus, hcard, hu⟩ := mulRothNumber_spec s\n    have h : ThreeGPFree (u.map <| mulLeftEmbedding a : Set α) := by rw [coe_map]; exact hu.smul_set\n    convert h.le_mulRothNumber (map_subset_map.2 hus) using 1\n    rw [card_map, hcard]\n\n"}
{"name":"mulRothNumber_map_mul_right","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : CancelCommMonoid α\ns : Finset α\na : α\n⊢ Eq (mulRothNumber (Finset.map (mulRightEmbedding a) s)) (mulRothNumber s)","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_map_mul_right :\n    mulRothNumber (s.map <| mulRightEmbedding a) = mulRothNumber s := by\n  rw [← mulLeftEmbedding_eq_mulRightEmbedding, mulRothNumber_map_mul_left s a]\n\n"}
{"name":"addRothNumber_map_add_right","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"α : Type u_2\ninst✝¹ : DecidableEq α\ninst✝ : AddCancelCommMonoid α\ns : Finset α\na : α\n⊢ Eq (addRothNumber (Finset.map (addRightEmbedding a) s)) (addRothNumber s)","decl":"@[to_additive (attr := simp)]\ntheorem mulRothNumber_map_mul_right :\n    mulRothNumber (s.map <| mulRightEmbedding a) = mulRothNumber s := by\n  rw [← mulLeftEmbedding_eq_mulRightEmbedding, mulRothNumber_map_mul_left s a]\n\n"}
{"name":"rothNumberNat_def","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"n : Nat\n⊢ Eq (rothNumberNat n) (addRothNumber (Finset.range n))","decl":"theorem rothNumberNat_def (n : ℕ) : rothNumberNat n = addRothNumber (range n) :=\n  rfl\n\n"}
{"name":"rothNumberNat_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"N : Nat\n⊢ LE.le (rothNumberNat N) N","decl":"theorem rothNumberNat_le (N : ℕ) : rothNumberNat N ≤ N :=\n  (addRothNumber_le _).trans (card_range _).le\n\n"}
{"name":"rothNumberNat_spec","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"n : Nat\n⊢ Exists fun t => And (HasSubset.Subset t (Finset.range n)) (And (Eq t.card (rothNumberNat n)) (ThreeAPFree ↑t))","decl":"theorem rothNumberNat_spec (n : ℕ) :\n    ∃ t ⊆ range n, #t = rothNumberNat n ∧ ThreeAPFree (t : Set ℕ) :=\n  addRothNumber_spec _\n\n"}
{"name":"ThreeAPFree.le_rothNumberNat","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"k n : Nat\ns : Finset Nat\nhs : ThreeAPFree ↑s\nhsn : ∀ (x : Nat), Membership.mem s x → LT.lt x n\nhsk : Eq s.card k\n⊢ LE.le k (rothNumberNat n)","decl":"/-- A verbose specialization of `threeAPFree.le_addRothNumber`, sometimes convenient in\npractice. -/\ntheorem ThreeAPFree.le_rothNumberNat (s : Finset ℕ) (hs : ThreeAPFree (s : Set ℕ))\n    (hsn : ∀ x ∈ s, x < n) (hsk : #s = k) : k ≤ rothNumberNat n :=\n  hsk.ge.trans <| hs.le_addRothNumber fun x hx => mem_range.2 <| hsn x hx\n\n"}
{"name":"rothNumberNat_add_le","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"M N : Nat\n⊢ LE.le (rothNumberNat (HAdd.hAdd M N)) (HAdd.hAdd (rothNumberNat M) (rothNumberNat N))","decl":"/-- The Roth number is a subadditive function. Note that by Fekete's lemma this shows that\nthe limit `rothNumberNat N / N` exists, but Roth's theorem gives the stronger result that this\nlimit is actually `0`. -/\ntheorem rothNumberNat_add_le (M N : ℕ) :\n    rothNumberNat (M + N) ≤ rothNumberNat M + rothNumberNat N := by\n  simp_rw [rothNumberNat_def]\n  rw [range_add_eq_union, ← addRothNumber_map_add_left (range N) M]\n  exact addRothNumber_union_le _ _\n\n"}
{"name":"rothNumberNat_zero","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"⊢ Eq (rothNumberNat 0) 0","decl":"@[simp]\ntheorem rothNumberNat_zero : rothNumberNat 0 = 0 :=\n  rfl\n\n"}
{"name":"addRothNumber_Ico","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"a b : Nat\n⊢ Eq (addRothNumber (Finset.Ico a b)) (rothNumberNat (HSub.hSub b a))","decl":"theorem addRothNumber_Ico (a b : ℕ) : addRothNumber (Ico a b) = rothNumberNat (b - a) := by\n  obtain h | h := le_total b a\n  · rw [Nat.sub_eq_zero_of_le h, Ico_eq_empty_of_le h, rothNumberNat_zero, addRothNumber_empty]\n  convert addRothNumber_map_add_left _ a\n  rw [range_eq_Ico, map_eq_image]\n  convert (image_add_left_Ico 0 (b - a) _).symm\n  exact (add_tsub_cancel_of_le h).symm\n\n"}
{"name":"Fin.addRothNumber_eq_rothNumberNat","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"k n : Nat\nhkn : LE.le (HMul.hMul 2 k) n\n⊢ Eq (addRothNumber (Finset.Iio ↑k)) (rothNumberNat k)","decl":"lemma Fin.addRothNumber_eq_rothNumberNat (hkn : 2 * k ≤ n) :\n    addRothNumber (Iio k : Finset (Fin n.succ)) = rothNumberNat k :=\n  IsAddFreimanIso.addRothNumber_congr <| mod_cast isAddFreimanIso_Iio two_ne_zero hkn\n\n"}
{"name":"Fin.addRothNumber_le_rothNumberNat","module":"Mathlib.Combinatorics.Additive.AP.Three.Defs","initialProofState":"k n : Nat\nhkn : LE.le k n\n⊢ LE.le (addRothNumber (Finset.Iio ↑k)) (rothNumberNat k)","decl":"lemma Fin.addRothNumber_le_rothNumberNat (k n : ℕ) (hkn : k ≤ n) :\n    addRothNumber (Iio k : Finset (Fin n.succ)) ≤ rothNumberNat k := by\n  suffices h : Set.BijOn (Nat.cast : ℕ → Fin n.succ) (range k) (Iio k : Finset (Fin n.succ)) by\n    exact (AddMonoidHomClass.isAddFreimanHom (Nat.castRingHom _) h.mapsTo).addRothNumber_mono h\n  refine ⟨?_, (CharP.natCast_injOn_Iio _ n.succ).mono (by simp; omega), ?_⟩\n  · simpa using fun x ↦ natCast_strictMono hkn\n  simp only [Set.SurjOn, coe_Iio, Set.subset_def, Set.mem_Iio, Set.mem_image, lt_iff_val_lt_val,\n    val_cast_of_lt, Nat.lt_succ_iff.2 hkn, coe_range]\n  exact fun x hx ↦ ⟨x, hx, by simp⟩\n\n"}
