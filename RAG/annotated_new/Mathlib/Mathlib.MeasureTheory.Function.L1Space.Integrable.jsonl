{"name":"MeasureTheory.memℒp_one_iff_integrable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\n⊢ Iff (MeasureTheory.Memℒp f 1 μ) (MeasureTheory.Integrable f μ)","decl":"theorem memℒp_one_iff_integrable {f : α → β} : Memℒp f 1 μ ↔ Integrable f μ := by\n  simp_rw [Integrable, hasFiniteIntegral_iff_enorm, Memℒp, eLpNorm_one_eq_lintegral_enorm]\n\n"}
{"name":"MeasureTheory.Integrable.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.AEStronglyMeasurable f μ","decl":"theorem Integrable.aestronglyMeasurable {f : α → β} (hf : Integrable f μ) :\n    AEStronglyMeasurable f μ :=\n  hf.1\n\n"}
{"name":"MeasureTheory.Integrable.aemeasurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ AEMeasurable f μ","decl":"theorem Integrable.aemeasurable [MeasurableSpace β] [BorelSpace β] {f : α → β}\n    (hf : Integrable f μ) : AEMeasurable f μ :=\n  hf.aestronglyMeasurable.aemeasurable\n\n"}
{"name":"MeasureTheory.Integrable.hasFiniteIntegral","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.HasFiniteIntegral f μ","decl":"theorem Integrable.hasFiniteIntegral {f : α → β} (hf : Integrable f μ) : HasFiniteIntegral f μ :=\n  hf.2\n\n"}
{"name":"MeasureTheory.Integrable.mono","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedAddCommGroup γ\nf : α → β\ng : α → γ\nhg : MeasureTheory.Integrable g μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable f μ","decl":"theorem Integrable.mono {f : α → β} {g : α → γ} (hg : Integrable g μ)\n    (hf : AEStronglyMeasurable f μ) (h : ∀ᵐ a ∂μ, ‖f a‖ ≤ ‖g a‖) : Integrable f μ :=\n  ⟨hf, hg.hasFiniteIntegral.mono h⟩\n\n"}
{"name":"MeasureTheory.Integrable.mono'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\ng : α → Real\nhg : MeasureTheory.Integrable g μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (g a)) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable f μ","decl":"theorem Integrable.mono' {f : α → β} {g : α → ℝ} (hg : Integrable g μ)\n    (hf : AEStronglyMeasurable f μ) (h : ∀ᵐ a ∂μ, ‖f a‖ ≤ g a) : Integrable f μ :=\n  ⟨hf, hg.hasFiniteIntegral.mono' h⟩\n\n"}
{"name":"MeasureTheory.Integrable.congr'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedAddCommGroup γ\nf : α → β\ng : α → γ\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable g μ","decl":"theorem Integrable.congr' {f : α → β} {g : α → γ} (hf : Integrable f μ)\n    (hg : AEStronglyMeasurable g μ) (h : ∀ᵐ a ∂μ, ‖f a‖ = ‖g a‖) : Integrable g μ :=\n  ⟨hg, hf.hasFiniteIntegral.congr' h⟩\n\n"}
{"name":"MeasureTheory.integrable_congr'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedAddCommGroup γ\nf : α → β\ng : α → γ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhg : MeasureTheory.AEStronglyMeasurable g μ\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae μ)\n⊢ Iff (MeasureTheory.Integrable f μ) (MeasureTheory.Integrable g μ)","decl":"theorem integrable_congr' {f : α → β} {g : α → γ} (hf : AEStronglyMeasurable f μ)\n    (hg : AEStronglyMeasurable g μ) (h : ∀ᵐ a ∂μ, ‖f a‖ = ‖g a‖) :\n    Integrable f μ ↔ Integrable g μ :=\n  ⟨fun h2f => h2f.congr' hg h, fun h2g => h2g.congr' hf <| EventuallyEq.symm h⟩\n\n"}
{"name":"MeasureTheory.Integrable.congr","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ MeasureTheory.Integrable g μ","decl":"theorem Integrable.congr {f g : α → β} (hf : Integrable f μ) (h : f =ᵐ[μ] g) : Integrable g μ :=\n  ⟨hf.1.congr h, hf.2.congr h⟩\n\n"}
{"name":"MeasureTheory.integrable_congr","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nh : (MeasureTheory.ae μ).EventuallyEq f g\n⊢ Iff (MeasureTheory.Integrable f μ) (MeasureTheory.Integrable g μ)","decl":"theorem integrable_congr {f g : α → β} (h : f =ᵐ[μ] g) : Integrable f μ ↔ Integrable g μ :=\n  ⟨fun hf => hf.congr h, fun hg => hg.congr h.symm⟩\n\n"}
{"name":"MeasureTheory.integrable_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nc : β\n⊢ Iff (MeasureTheory.Integrable (fun x => c) μ) (Or (Eq c 0) (MeasureTheory.IsFiniteMeasure μ))","decl":"lemma integrable_const_iff {c : β} : Integrable (fun _ : α => c) μ ↔ c = 0 ∨ IsFiniteMeasure μ := by\n  have : AEStronglyMeasurable (fun _ : α => c) μ := aestronglyMeasurable_const\n  rw [Integrable, and_iff_right this, hasFiniteIntegral_const_iff]\n\n"}
{"name":"MeasureTheory.integrable_const_iff_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nc : β\nhc : Ne c 0\n⊢ Iff (MeasureTheory.Integrable (fun x => c) μ) (MeasureTheory.IsFiniteMeasure μ)","decl":"lemma integrable_const_iff_isFiniteMeasure {c : β} (hc : c ≠ 0) :\n    Integrable (fun _ ↦ c) μ ↔ IsFiniteMeasure μ := by\n  simp [integrable_const_iff, hc, isFiniteMeasure_iff]\n\n"}
{"name":"MeasureTheory.Integrable.of_mem_Icc","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\na b : Real\nX : α → Real\nhX : AEMeasurable X μ\nh : Filter.Eventually (fun ω => Membership.mem (Set.Icc a b) (X ω)) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable X μ","decl":"theorem Integrable.of_mem_Icc [IsFiniteMeasure μ] (a b : ℝ) {X : α → ℝ} (hX : AEMeasurable X μ)\n    (h : ∀ᵐ ω ∂μ, X ω ∈ Set.Icc a b) :\n    Integrable X μ :=\n  ⟨hX.aestronglyMeasurable, .of_mem_Icc a b h⟩\n\n"}
{"name":"MeasureTheory.integrable_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nc : β\n⊢ MeasureTheory.Integrable (fun x => c) μ","decl":"@[simp, fun_prop]\ntheorem integrable_const [IsFiniteMeasure μ] (c : β) : Integrable (fun _ : α => c) μ :=\n  integrable_const_iff.2 <| .inr ‹_›\n\n"}
{"name":"MeasureTheory.Integrable.of_finite","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\ninst✝² : Finite α\ninst✝¹ : MeasurableSingletonClass α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\n⊢ MeasureTheory.Integrable f μ","decl":"@[simp]\nlemma Integrable.of_finite [Finite α] [MeasurableSingletonClass α] [IsFiniteMeasure μ] {f : α → β} :\n    Integrable f μ := ⟨.of_finite, .of_finite⟩\n\n"}
{"name":"MeasureTheory.Integrable.of_isEmpty","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : IsEmpty α\nf : α → β\n⊢ MeasureTheory.Integrable f μ","decl":"/-- This lemma is a special case of `Integrable.of_finite`. -/\n-- Eternal deprecation for discoverability, don't remove\n@[deprecated Integrable.of_finite (since := \"2024-10-05\"), nolint deprecatedNoSince]\nlemma Integrable.of_isEmpty [IsEmpty α] {f : α → β} : Integrable f μ := .of_finite\n\n"}
{"name":"MeasureTheory.Memℒp.integrable_norm_rpow","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\np : ENNReal\nhf : MeasureTheory.Memℒp f p μ\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) μ","decl":"theorem Memℒp.integrable_norm_rpow {f : α → β} {p : ℝ≥0∞} (hf : Memℒp f p μ) (hp_ne_zero : p ≠ 0)\n    (hp_ne_top : p ≠ ∞) : Integrable (fun x : α => ‖f x‖ ^ p.toReal) μ := by\n  rw [← memℒp_one_iff_integrable]\n  exact hf.norm_rpow hp_ne_zero hp_ne_top\n\n"}
{"name":"MeasureTheory.Memℒp.integrable_norm_rpow'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\np : ENNReal\nhf : MeasureTheory.Memℒp f p μ\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) μ","decl":"theorem Memℒp.integrable_norm_rpow' [IsFiniteMeasure μ] {f : α → β} {p : ℝ≥0∞} (hf : Memℒp f p μ) :\n    Integrable (fun x : α => ‖f x‖ ^ p.toReal) μ := by\n  by_cases h_zero : p = 0\n  · simp [h_zero, integrable_const]\n  by_cases h_top : p = ∞\n  · simp [h_top, integrable_const]\n  exact hf.integrable_norm_rpow h_zero h_top\n\n"}
{"name":"MeasureTheory.Memℒp.integrable_norm_pow","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\np : Nat\nhf : MeasureTheory.Memℒp f (↑p) μ\nhp : Ne p 0\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p) μ","decl":"lemma Memℒp.integrable_norm_pow {f : α → β} {p : ℕ} (hf : Memℒp f p μ) (hp : p ≠ 0) :\n    Integrable (fun x : α => ‖f x‖ ^ p) μ := by\n  simpa using hf.integrable_norm_rpow (mod_cast hp) (by simp)\n\n"}
{"name":"MeasureTheory.Memℒp.integrable_norm_pow'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\np : Nat\nhf : MeasureTheory.Memℒp f (↑p) μ\n⊢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p) μ","decl":"lemma Memℒp.integrable_norm_pow' [IsFiniteMeasure μ] {f : α → β} {p : ℕ} (hf : Memℒp f p μ) :\n    Integrable (fun x : α => ‖f x‖ ^ p) μ := by simpa using hf.integrable_norm_rpow'\n\n"}
{"name":"MeasureTheory.integrable_norm_rpow_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\np : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f μ\np_zero : Ne p 0\np_top : Ne p Top.top\n⊢ Iff (MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) μ) (MeasureTheory.Memℒp f p μ)","decl":"lemma integrable_norm_rpow_iff {f : α → β} {p : ℝ≥0∞}\n    (hf : AEStronglyMeasurable f μ) (p_zero : p ≠ 0) (p_top : p ≠ ∞) :\n    Integrable (fun x : α => ‖f x‖ ^ p.toReal) μ ↔ Memℒp f p μ := by\n  rw [← memℒp_norm_rpow_iff (q := p) hf p_zero p_top, ← memℒp_one_iff_integrable,\n    ENNReal.div_self p_zero p_top]\n\n"}
{"name":"MeasureTheory.Integrable.mono_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nh : MeasureTheory.Integrable f ν\nhμ : LE.le μ ν\n⊢ MeasureTheory.Integrable f μ","decl":"theorem Integrable.mono_measure {f : α → β} (h : Integrable f ν) (hμ : μ ≤ ν) : Integrable f μ :=\n  ⟨h.aestronglyMeasurable.mono_measure hμ, h.hasFiniteIntegral.mono_measure hμ⟩\n\n"}
{"name":"MeasureTheory.Integrable.of_measure_le_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nμ' : MeasureTheory.Measure α\nc : ENNReal\nhc : Ne c Top.top\nhμ'_le : LE.le μ' (HSMul.hSMul c μ)\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable f μ'","decl":"theorem Integrable.of_measure_le_smul {μ' : Measure α} (c : ℝ≥0∞) (hc : c ≠ ∞) (hμ'_le : μ' ≤ c • μ)\n    {f : α → β} (hf : Integrable f μ) : Integrable f μ' := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢\n  exact hf.of_measure_le_smul c hc hμ'_le\n\n"}
{"name":"MeasureTheory.Integrable.add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhμ : MeasureTheory.Integrable f μ\nhν : MeasureTheory.Integrable f ν\n⊢ MeasureTheory.Integrable f (HAdd.hAdd μ ν)","decl":"@[fun_prop]\ntheorem Integrable.add_measure {f : α → β} (hμ : Integrable f μ) (hν : Integrable f ν) :\n    Integrable f (μ + ν) := by\n  simp_rw [← memℒp_one_iff_integrable] at hμ hν ⊢\n  refine ⟨hμ.aestronglyMeasurable.add_measure hν.aestronglyMeasurable, ?_⟩\n  rw [eLpNorm_one_add_measure, ENNReal.add_lt_top]\n  exact ⟨hμ.eLpNorm_lt_top, hν.eLpNorm_lt_top⟩\n\n"}
{"name":"MeasureTheory.Integrable.left_of_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nh : MeasureTheory.Integrable f (HAdd.hAdd μ ν)\n⊢ MeasureTheory.Integrable f μ","decl":"theorem Integrable.left_of_add_measure {f : α → β} (h : Integrable f (μ + ν)) : Integrable f μ := by\n  rw [← memℒp_one_iff_integrable] at h ⊢\n  exact h.left_of_add_measure\n\n"}
{"name":"MeasureTheory.Integrable.right_of_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nh : MeasureTheory.Integrable f (HAdd.hAdd μ ν)\n⊢ MeasureTheory.Integrable f ν","decl":"theorem Integrable.right_of_add_measure {f : α → β} (h : Integrable f (μ + ν)) :\n    Integrable f ν := by\n  rw [← memℒp_one_iff_integrable] at h ⊢\n  exact h.right_of_add_measure\n\n"}
{"name":"MeasureTheory.integrable_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\n⊢ Iff (MeasureTheory.Integrable f (HAdd.hAdd μ ν)) (And (MeasureTheory.Integrable f μ) (MeasureTheory.Integrable f ν))","decl":"@[simp]\ntheorem integrable_add_measure {f : α → β} :\n    Integrable f (μ + ν) ↔ Integrable f μ ∧ Integrable f ν :=\n  ⟨fun h => ⟨h.left_of_add_measure, h.right_of_add_measure⟩, fun h => h.1.add_measure h.2⟩\n\n"}
{"name":"MeasureTheory.integrable_zero_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : NormedAddCommGroup β\nx✝ : MeasurableSpace α\nf : α → β\n⊢ MeasureTheory.Integrable f 0","decl":"@[simp]\ntheorem integrable_zero_measure {_ : MeasurableSpace α} {f : α → β} :\n    Integrable f (0 : Measure α) :=\n  ⟨aestronglyMeasurable_zero_measure f, hasFiniteIntegral_zero_measure f⟩\n\n"}
{"name":"MeasureTheory.integrable_finset_sum_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝ : NormedAddCommGroup β\nι : Type u_6\nm : MeasurableSpace α\nf : α → β\nμ : ι → MeasureTheory.Measure α\ns : Finset ι\n⊢ Iff (MeasureTheory.Integrable f (s.sum fun i => μ i)) (∀ (i : ι), Membership.mem s i → MeasureTheory.Integrable f (μ i))","decl":"theorem integrable_finset_sum_measure {ι} {m : MeasurableSpace α} {f : α → β} {μ : ι → Measure α}\n    {s : Finset ι} : Integrable f (∑ i ∈ s, μ i) ↔ ∀ i ∈ s, Integrable f (μ i) := by\n  classical\n  induction s using Finset.induction_on <;> simp [*]\n\n"}
{"name":"MeasureTheory.Integrable.smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nh : MeasureTheory.Integrable f μ\nc : ENNReal\nhc : Ne c Top.top\n⊢ MeasureTheory.Integrable f (HSMul.hSMul c μ)","decl":"theorem Integrable.smul_measure {f : α → β} (h : Integrable f μ) {c : ℝ≥0∞} (hc : c ≠ ∞) :\n    Integrable f (c • μ) := by\n  rw [← memℒp_one_iff_integrable] at h ⊢\n  exact h.smul_measure hc\n\n"}
{"name":"MeasureTheory.Integrable.smul_measure_nnreal","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nh : MeasureTheory.Integrable f μ\nc : NNReal\n⊢ MeasureTheory.Integrable f (HSMul.hSMul c μ)","decl":"@[fun_prop]\ntheorem Integrable.smul_measure_nnreal {f : α → β} (h : Integrable f μ) {c : ℝ≥0} :\n    Integrable f (c • μ) := by\n  apply h.smul_measure\n  simp\n\n"}
{"name":"MeasureTheory.integrable_smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nc : ENNReal\nh₁ : Ne c 0\nh₂ : Ne c Top.top\n⊢ Iff (MeasureTheory.Integrable f (HSMul.hSMul c μ)) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_smul_measure {f : α → β} {c : ℝ≥0∞} (h₁ : c ≠ 0) (h₂ : c ≠ ∞) :\n    Integrable f (c • μ) ↔ Integrable f μ :=\n  ⟨fun h => by\n    simpa only [smul_smul, ENNReal.inv_mul_cancel h₁ h₂, one_smul] using\n      h.smul_measure (ENNReal.inv_ne_top.2 h₁),\n    fun h => h.smul_measure h₂⟩\n\n"}
{"name":"MeasureTheory.integrable_inv_smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nc : ENNReal\nh₁ : Ne c 0\nh₂ : Ne c Top.top\n⊢ Iff (MeasureTheory.Integrable f (HSMul.hSMul (Inv.inv c) μ)) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_inv_smul_measure {f : α → β} {c : ℝ≥0∞} (h₁ : c ≠ 0) (h₂ : c ≠ ∞) :\n    Integrable f (c⁻¹ • μ) ↔ Integrable f μ :=\n  integrable_smul_measure (by simpa using h₂) (by simpa using h₁)\n\n"}
{"name":"MeasureTheory.Integrable.to_average","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nh : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable f (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)","decl":"theorem Integrable.to_average {f : α → β} (h : Integrable f μ) : Integrable f ((μ univ)⁻¹ • μ) := by\n  rcases eq_or_ne μ 0 with (rfl | hne)\n  · rwa [smul_zero]\n  · apply h.smul_measure\n    simpa\n\n"}
{"name":"MeasureTheory.integrable_average","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\n⊢ Iff (MeasureTheory.Integrable f (HSMul.hSMul (Inv.inv (μ Set.univ)) μ)) (MeasureTheory.Integrable f μ)","decl":"open scoped Classical in\ntheorem integrable_average [IsFiniteMeasure μ] {f : α → β} :\n    Integrable f ((μ univ)⁻¹ • μ) ↔ Integrable f μ :=\n  (eq_or_ne μ 0).by_cases (fun h => by simp [h]) fun h =>\n    integrable_smul_measure (ENNReal.inv_ne_zero.2 <| measure_ne_top _ _)\n      (ENNReal.inv_ne_top.2 <| mt Measure.measure_univ_eq_zero.1 h)\n\n"}
{"name":"MeasureTheory.integrable_map_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nf : α → δ\ng : δ → β\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ Iff (MeasureTheory.Integrable g (MeasureTheory.Measure.map f μ)) (MeasureTheory.Integrable (Function.comp g f) μ)","decl":"theorem integrable_map_measure {f : α → δ} {g : δ → β}\n    (hg : AEStronglyMeasurable g (Measure.map f μ)) (hf : AEMeasurable f μ) :\n    Integrable g (Measure.map f μ) ↔ Integrable (g ∘ f) μ := by\n  simp_rw [← memℒp_one_iff_integrable]\n  exact memℒp_map_measure_iff hg hf\n\n"}
{"name":"MeasureTheory.Integrable.comp_aemeasurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nf : α → δ\ng : δ → β\nhg : MeasureTheory.Integrable g (MeasureTheory.Measure.map f μ)\nhf : AEMeasurable f μ\n⊢ MeasureTheory.Integrable (Function.comp g f) μ","decl":"theorem Integrable.comp_aemeasurable {f : α → δ} {g : δ → β} (hg : Integrable g (Measure.map f μ))\n    (hf : AEMeasurable f μ) : Integrable (g ∘ f) μ :=\n  (integrable_map_measure hg.aestronglyMeasurable hf).mp hg\n\n"}
{"name":"MeasureTheory.Integrable.comp_measurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nf : α → δ\ng : δ → β\nhg : MeasureTheory.Integrable g (MeasureTheory.Measure.map f μ)\nhf : Measurable f\n⊢ MeasureTheory.Integrable (Function.comp g f) μ","decl":"theorem Integrable.comp_measurable {f : α → δ} {g : δ → β} (hg : Integrable g (Measure.map f μ))\n    (hf : Measurable f) : Integrable (g ∘ f) μ :=\n  hg.comp_aemeasurable hf.aemeasurable\n\n"}
{"name":"MeasurableEmbedding.integrable_map_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nf : α → δ\nhf : MeasurableEmbedding f\ng : δ → β\n⊢ Iff (MeasureTheory.Integrable g (MeasureTheory.Measure.map f μ)) (MeasureTheory.Integrable (Function.comp g f) μ)","decl":"theorem _root_.MeasurableEmbedding.integrable_map_iff {f : α → δ} (hf : MeasurableEmbedding f)\n    {g : δ → β} : Integrable g (Measure.map f μ) ↔ Integrable (g ∘ f) μ := by\n  simp_rw [← memℒp_one_iff_integrable]\n  exact hf.memℒp_map_measure_iff\n\n"}
{"name":"MeasureTheory.integrable_map_equiv","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nf : MeasurableEquiv α δ\ng : δ → β\n⊢ Iff (MeasureTheory.Integrable g (MeasureTheory.Measure.map (⇑f) μ)) (MeasureTheory.Integrable (Function.comp g ⇑f) μ)","decl":"theorem integrable_map_equiv (f : α ≃ᵐ δ) (g : δ → β) :\n    Integrable g (Measure.map f μ) ↔ Integrable (g ∘ f) μ := by\n  simp_rw [← memℒp_one_iff_integrable]\n  exact f.memℒp_map_measure_iff\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integrable_comp","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nν : MeasureTheory.Measure δ\ng : δ → β\nf : α → δ\nhf : MeasureTheory.MeasurePreserving f μ ν\nhg : MeasureTheory.AEStronglyMeasurable g ν\n⊢ Iff (MeasureTheory.Integrable (Function.comp g f) μ) (MeasureTheory.Integrable g ν)","decl":"theorem MeasurePreserving.integrable_comp {ν : Measure δ} {g : δ → β} {f : α → δ}\n    (hf : MeasurePreserving f μ ν) (hg : AEStronglyMeasurable g ν) :\n    Integrable (g ∘ f) μ ↔ Integrable g ν := by\n  rw [← hf.map_eq] at hg ⊢\n  exact (integrable_map_measure hg hf.measurable.aemeasurable).symm\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integrable_comp_emb","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nδ : Type u_4\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace δ\ninst✝ : NormedAddCommGroup β\nf : α → δ\nν : MeasureTheory.Measure δ\nh₁ : MeasureTheory.MeasurePreserving f μ ν\nh₂ : MeasurableEmbedding f\ng : δ → β\n⊢ Iff (MeasureTheory.Integrable (Function.comp g f) μ) (MeasureTheory.Integrable g ν)","decl":"theorem MeasurePreserving.integrable_comp_emb {f : α → δ} {ν} (h₁ : MeasurePreserving f μ ν)\n    (h₂ : MeasurableEmbedding f) {g : δ → β} : Integrable (g ∘ f) μ ↔ Integrable g ν :=\n  h₁.map_eq ▸ Iff.symm h₂.integrable_map_iff\n\n"}
{"name":"MeasureTheory.lintegral_edist_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ LT.lt (MeasureTheory.lintegral μ fun a => EDist.edist (f a) (g a)) Top.top","decl":"theorem lintegral_edist_lt_top {f g : α → β} (hf : Integrable f μ) (hg : Integrable g μ) :\n    (∫⁻ a, edist (f a) (g a) ∂μ) < ∞ :=\n  lt_of_le_of_lt (lintegral_edist_triangle hf.aestronglyMeasurable aestronglyMeasurable_zero)\n    (ENNReal.add_lt_top.2 <| by\n      simp_rw [Pi.zero_apply, ← hasFiniteIntegral_iff_edist]\n      exact ⟨hf.hasFiniteIntegral, hg.hasFiniteIntegral⟩)\n\n"}
{"name":"MeasureTheory.integrable_zero","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\n⊢ MeasureTheory.Integrable (fun x => 0) μ","decl":"@[simp]\ntheorem integrable_zero : Integrable (fun _ => (0 : β)) μ := by\n  simp [Integrable, aestronglyMeasurable_const]\n\n"}
{"name":"MeasureTheory.Integrable.add'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.HasFiniteIntegral (HAdd.hAdd f g) μ","decl":"theorem Integrable.add' {f g : α → β} (hf : Integrable f μ) (hg : Integrable g μ) :\n    HasFiniteIntegral (f + g) μ :=\n  calc\n    ∫⁻ a, ‖f a + g a‖ₑ ∂μ ≤ ∫⁻ a, ‖f a‖ₑ + ‖g a‖ₑ ∂μ := lintegral_mono fun _ ↦ enorm_add_le _ _\n    _ = _ := lintegral_enorm_add_left hf.aestronglyMeasurable _\n    _ < ∞ := add_lt_top.2 ⟨hf.hasFiniteIntegral, hg.hasFiniteIntegral⟩\n\n"}
{"name":"MeasureTheory.Integrable.add","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (HAdd.hAdd f g) μ","decl":"@[fun_prop]\ntheorem Integrable.add {f g : α → β} (hf : Integrable f μ) (hg : Integrable g μ) :\n    Integrable (f + g) μ :=\n  ⟨hf.aestronglyMeasurable.add hg.aestronglyMeasurable, hf.add' hg⟩\n\n"}
{"name":"MeasureTheory.Integrable.add''","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (fun x => HAdd.hAdd (f x) (g x)) μ","decl":"@[fun_prop]\ntheorem Integrable.add'' {f g : α → β} (hf : Integrable f μ) (hg : Integrable g μ) :\n    Integrable (fun x ↦ f x + g x) μ := hf.add hg\n\n"}
{"name":"MeasureTheory.integrable_finset_sum'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nι : Type u_6\ns : Finset ι\nf : ι → α → β\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.Integrable (f i) μ\n⊢ MeasureTheory.Integrable (s.sum fun i => f i) μ","decl":"@[fun_prop]\ntheorem integrable_finset_sum' {ι} (s : Finset ι) {f : ι → α → β}\n    (hf : ∀ i ∈ s, Integrable (f i) μ) : Integrable (∑ i ∈ s, f i) μ :=\n  Finset.sum_induction f (fun g => Integrable g μ) (fun _ _ => Integrable.add)\n    (integrable_zero _ _ _) hf\n\n"}
{"name":"MeasureTheory.integrable_finset_sum","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nι : Type u_6\ns : Finset ι\nf : ι → α → β\nhf : ∀ (i : ι), Membership.mem s i → MeasureTheory.Integrable (f i) μ\n⊢ MeasureTheory.Integrable (fun a => s.sum fun i => f i a) μ","decl":"@[fun_prop]\ntheorem integrable_finset_sum {ι} (s : Finset ι) {f : ι → α → β}\n    (hf : ∀ i ∈ s, Integrable (f i) μ) : Integrable (fun a => ∑ i ∈ s, f i a) μ := by\n  simpa only [← Finset.sum_apply] using integrable_finset_sum' s hf\n\n"}
{"name":"MeasureTheory.Integrable.neg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (Neg.neg f) μ","decl":"/-- If `f` is integrable, then so is `-f`.\nSee `Integrable.neg'` for the same statement, but formulated with `x ↦ - f x` instead of `-f`. -/\n@[fun_prop]\ntheorem Integrable.neg {f : α → β} (hf : Integrable f μ) : Integrable (-f) μ :=\n  ⟨hf.aestronglyMeasurable.neg, hf.hasFiniteIntegral.neg⟩\n\n"}
{"name":"MeasureTheory.Integrable.neg'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => Neg.neg (f x)) μ","decl":"/-- If `f` is integrable, then so is `fun x ↦ - f x`.\nSee `Integrable.neg` for the same statement, but formulated with `-f` instead of `fun x ↦ - f x`. -/\n@[fun_prop]\ntheorem Integrable.neg' {f : α → β} (hf : Integrable f μ) : Integrable (fun x ↦ - f x) μ :=\n  ⟨hf.aestronglyMeasurable.neg, hf.hasFiniteIntegral.neg⟩\n\n"}
{"name":"MeasureTheory.integrable_neg_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\n⊢ Iff (MeasureTheory.Integrable (Neg.neg f) μ) (MeasureTheory.Integrable f μ)","decl":"@[simp]\ntheorem integrable_neg_iff {f : α → β} : Integrable (-f) μ ↔ Integrable f μ :=\n  ⟨fun h => neg_neg f ▸ h.neg, Integrable.neg⟩\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_right","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ Iff (MeasureTheory.Integrable (HAdd.hAdd f g) μ) (MeasureTheory.Integrable g μ)","decl":"/-- if `f` is integrable, then `f + g` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_right'` for the same statement with `fun x ↦ f x + g x` instead\nof `f + g`. -/\n@[simp]\nlemma integrable_add_iff_integrable_right {f g : α → β} (hf : Integrable f μ) :\n    Integrable (f + g) μ ↔ Integrable g μ :=\n  ⟨fun h ↦ show g = f + g + (-f) by simp only [add_neg_cancel_comm] ▸ h.add hf.neg,\n    fun h ↦ hf.add h⟩\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_right'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd (f x) (g x)) μ) (MeasureTheory.Integrable g μ)","decl":"/-- if `f` is integrable, then `fun x ↦ f x + g x` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_right` for the same statement with `f + g` instead\nof `fun x ↦ f x + g x`. -/\n@[simp]\nlemma integrable_add_iff_integrable_right' {f g : α → β} (hf : Integrable f μ) :\n    Integrable (fun x ↦ f x + g x) μ ↔ Integrable g μ :=\n  integrable_add_iff_integrable_right hf\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_left","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ Iff (MeasureTheory.Integrable (HAdd.hAdd g f) μ) (MeasureTheory.Integrable g μ)","decl":"/-- if `f` is integrable, then `g + f` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_left'` for the same statement with `fun x ↦ g x + f x` instead\nof `g + f`. -/\n@[simp]\nlemma integrable_add_iff_integrable_left {f g : α → β} (hf : Integrable f μ) :\n    Integrable (g + f) μ ↔ Integrable g μ := by\n  rw [add_comm, integrable_add_iff_integrable_right hf]\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_left'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd (g x) (f x)) μ) (MeasureTheory.Integrable g μ)","decl":"/-- if `f` is integrable, then `fun x ↦ g x + f x` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_left'` for the same statement with `g + f` instead\nof `fun x ↦ g x + f x`. -/\n@[simp]\nlemma integrable_add_iff_integrable_left' {f g : α → β} (hf : Integrable f μ) :\n    Integrable (fun x ↦ g x + f x) μ ↔ Integrable g μ :=\n  integrable_add_iff_integrable_left hf\n\n"}
{"name":"MeasureTheory.integrable_left_of_integrable_add_of_nonneg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nh_meas : MeasureTheory.AEStronglyMeasurable f μ\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\nhg : (MeasureTheory.ae μ).EventuallyLE 0 g\nh_int : MeasureTheory.Integrable (HAdd.hAdd f g) μ\n⊢ MeasureTheory.Integrable f μ","decl":"lemma integrable_left_of_integrable_add_of_nonneg {f g : α → ℝ}\n    (h_meas : AEStronglyMeasurable f μ) (hf : 0 ≤ᵐ[μ] f) (hg : 0 ≤ᵐ[μ] g)\n    (h_int : Integrable (f + g) μ) : Integrable f μ := by\n  refine h_int.mono' h_meas ?_\n  filter_upwards [hf, hg] with a haf hag\n  exact (Real.norm_of_nonneg haf).symm ▸ le_add_of_nonneg_right hag\n\n"}
{"name":"MeasureTheory.integrable_right_of_integrable_add_of_nonneg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nh_meas : MeasureTheory.AEStronglyMeasurable f μ\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\nhg : (MeasureTheory.ae μ).EventuallyLE 0 g\nh_int : MeasureTheory.Integrable (HAdd.hAdd f g) μ\n⊢ MeasureTheory.Integrable g μ","decl":"lemma integrable_right_of_integrable_add_of_nonneg {f g : α → ℝ}\n    (h_meas : AEStronglyMeasurable f μ) (hf : 0 ≤ᵐ[μ] f) (hg : 0 ≤ᵐ[μ] g)\n    (h_int : Integrable (f + g) μ) : Integrable g μ :=\n  integrable_left_of_integrable_add_of_nonneg\n    ((AEStronglyMeasurable.add_iff_right h_meas).mp h_int.aestronglyMeasurable)\n      hg hf (add_comm f g ▸ h_int)\n\n"}
{"name":"MeasureTheory.integrable_add_iff_of_nonneg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nh_meas : MeasureTheory.AEStronglyMeasurable f μ\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\nhg : (MeasureTheory.ae μ).EventuallyLE 0 g\n⊢ Iff (MeasureTheory.Integrable (HAdd.hAdd f g) μ) (And (MeasureTheory.Integrable f μ) (MeasureTheory.Integrable g μ))","decl":"lemma integrable_add_iff_of_nonneg {f g : α → ℝ} (h_meas : AEStronglyMeasurable f μ)\n    (hf : 0 ≤ᵐ[μ] f) (hg : 0 ≤ᵐ[μ] g) :\n    Integrable (f + g) μ ↔ Integrable f μ ∧ Integrable g μ :=\n  ⟨fun h ↦ ⟨integrable_left_of_integrable_add_of_nonneg h_meas hf hg h,\n    integrable_right_of_integrable_add_of_nonneg h_meas hf hg h⟩, fun ⟨hf, hg⟩ ↦ hf.add hg⟩\n\n"}
{"name":"MeasureTheory.integrable_add_iff_of_nonpos","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g : α → Real\nh_meas : MeasureTheory.AEStronglyMeasurable f μ\nhf : (MeasureTheory.ae μ).EventuallyLE f 0\nhg : (MeasureTheory.ae μ).EventuallyLE g 0\n⊢ Iff (MeasureTheory.Integrable (HAdd.hAdd f g) μ) (And (MeasureTheory.Integrable f μ) (MeasureTheory.Integrable g μ))","decl":"lemma integrable_add_iff_of_nonpos {f g : α → ℝ} (h_meas : AEStronglyMeasurable f μ)\n    (hf : f ≤ᵐ[μ] 0) (hg : g ≤ᵐ[μ] 0) :\n    Integrable (f + g) μ ↔ Integrable f μ ∧ Integrable g μ := by\n  rw [← integrable_neg_iff, ← integrable_neg_iff (f := f), ← integrable_neg_iff (f := g), neg_add]\n  exact integrable_add_iff_of_nonneg h_meas.neg (hf.mono (fun _ ↦ neg_nonneg_of_nonpos))\n    (hg.mono (fun _ ↦ neg_nonneg_of_nonpos))\n\n"}
{"name":"MeasureTheory.integrable_add_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\nc : β\n⊢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd (f x) c) μ) (MeasureTheory.Integrable f μ)","decl":"lemma integrable_add_const_iff [IsFiniteMeasure μ] {f : α → β} {c : β} :\n    Integrable (fun x ↦ f x + c) μ ↔ Integrable f μ :=\n  integrable_add_iff_integrable_left (integrable_const _)\n\n"}
{"name":"MeasureTheory.integrable_const_add_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nf : α → β\nc : β\n⊢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd c (f x)) μ) (MeasureTheory.Integrable f μ)","decl":"lemma integrable_const_add_iff [IsFiniteMeasure μ] {f : α → β} {c : β} :\n    Integrable (fun x ↦ c + f x) μ ↔ Integrable f μ :=\n  integrable_add_iff_integrable_right (integrable_const _)\n\n"}
{"name":"MeasureTheory.Integrable.sub","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (HSub.hSub f g) μ","decl":"@[fun_prop]\ntheorem Integrable.sub {f g : α → β} (hf : Integrable f μ) (hg : Integrable g μ) :\n    Integrable (f - g) μ := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"MeasureTheory.Integrable.sub'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (fun a => HSub.hSub (f a) (g a)) μ","decl":"@[fun_prop]\ntheorem Integrable.sub' {f g : α → β} (hf : Integrable f μ) (hg : Integrable g μ) :\n    Integrable (fun a ↦ f a - g a) μ := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"MeasureTheory.Integrable.norm","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun a => Norm.norm (f a)) μ","decl":"@[fun_prop]\ntheorem Integrable.norm {f : α → β} (hf : Integrable f μ) : Integrable (fun a => ‖f a‖) μ :=\n  ⟨hf.aestronglyMeasurable.norm, hf.hasFiniteIntegral.norm⟩\n\n"}
{"name":"MeasureTheory.Integrable.inf","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_6\ninst✝ : NormedLatticeAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (Min.min f g) μ","decl":"@[fun_prop]\ntheorem Integrable.inf {β} [NormedLatticeAddCommGroup β] {f g : α → β} (hf : Integrable f μ)\n    (hg : Integrable g μ) : Integrable (f ⊓ g) μ := by\n  rw [← memℒp_one_iff_integrable] at hf hg ⊢\n  exact hf.inf hg\n\n"}
{"name":"MeasureTheory.Integrable.sup","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_6\ninst✝ : NormedLatticeAddCommGroup β\nf g : α → β\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (Max.max f g) μ","decl":"@[fun_prop]\ntheorem Integrable.sup {β} [NormedLatticeAddCommGroup β] {f g : α → β} (hf : Integrable f μ)\n    (hg : Integrable g μ) : Integrable (f ⊔ g) μ := by\n  rw [← memℒp_one_iff_integrable] at hf hg ⊢\n  exact hf.sup hg\n\n"}
{"name":"MeasureTheory.Integrable.abs","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nβ : Type u_6\ninst✝ : NormedLatticeAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun a => abs (f a)) μ","decl":"@[fun_prop]\ntheorem Integrable.abs {β} [NormedLatticeAddCommGroup β] {f : α → β} (hf : Integrable f μ) :\n    Integrable (fun a => |f a|) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢\n  exact hf.abs\n\n"}
{"name":"MeasureTheory.Integrable.bdd_mul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nF : Type u_6\ninst✝ : NormedDivisionRing F\nf g : α → F\nhint : MeasureTheory.Integrable g μ\nhm : MeasureTheory.AEStronglyMeasurable f μ\nhfbdd : Exists fun C => ∀ (x : α), LE.le (Norm.norm (f x)) C\n⊢ MeasureTheory.Integrable (fun x => HMul.hMul (f x) (g x)) μ","decl":"theorem Integrable.bdd_mul {F : Type*} [NormedDivisionRing F] {f g : α → F} (hint : Integrable g μ)\n    (hm : AEStronglyMeasurable f μ) (hfbdd : ∃ C, ∀ x, ‖f x‖ ≤ C) :\n    Integrable (fun x => f x * g x) μ := by\n  cases' isEmpty_or_nonempty α with hα hα\n  · rw [μ.eq_zero_of_isEmpty]\n    exact integrable_zero_measure\n  · refine ⟨hm.mul hint.1, ?_⟩\n    obtain ⟨C, hC⟩ := hfbdd\n    have hCnonneg : 0 ≤ C := le_trans (norm_nonneg _) (hC hα.some)\n    have : (fun x => ‖f x * g x‖₊) ≤ fun x => ⟨C, hCnonneg⟩ * ‖g x‖₊ := by\n      intro x\n      simp only [nnnorm_mul]\n      exact mul_le_mul_of_nonneg_right (hC x) (zero_le _)\n    refine lt_of_le_of_lt (lintegral_mono_nnreal this) ?_\n    simp only [ENNReal.coe_mul]\n    rw [lintegral_const_mul' _ _ ENNReal.coe_ne_top]\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top hint.2\n\n"}
{"name":"MeasureTheory.Integrable.essSup_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝² : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝¹ : NormedField 𝕜\ninst✝ : NormedSpace 𝕜 β\nf : α → β\nhf : MeasureTheory.Integrable f μ\ng : α → 𝕜\ng_aestronglyMeasurable : MeasureTheory.AEStronglyMeasurable g μ\ness_sup_g : Ne (essSup (fun x => ENorm.enorm (g x)) μ) Top.top\n⊢ MeasureTheory.Integrable (fun x => HSMul.hSMul (g x) (f x)) μ","decl":"/-- **Hölder's inequality for integrable functions**: the scalar multiplication of an integrable\nvector-valued function by a scalar function with finite essential supremum is integrable. -/\ntheorem Integrable.essSup_smul {𝕜 : Type*} [NormedField 𝕜] [NormedSpace 𝕜 β] {f : α → β}\n    (hf : Integrable f μ) {g : α → 𝕜} (g_aestronglyMeasurable : AEStronglyMeasurable g μ)\n    (ess_sup_g : essSup (‖g ·‖ₑ) μ ≠ ∞) :\n    Integrable (fun x : α => g x • f x) μ := by\n  rw [← memℒp_one_iff_integrable] at *\n  refine ⟨g_aestronglyMeasurable.smul hf.1, ?_⟩\n  have h : (1 : ℝ≥0∞) / 1 = 1 / ∞ + 1 / 1 := by norm_num\n  have hg' : eLpNorm g ∞ μ ≠ ∞ := by rwa [eLpNorm_exponent_top]\n  calc\n    eLpNorm (fun x : α => g x • f x) 1 μ ≤ _ := by\n      simpa using MeasureTheory.eLpNorm_smul_le_mul_eLpNorm hf.1 g_aestronglyMeasurable h\n    _ < ∞ := ENNReal.mul_lt_top hg'.lt_top hf.2\n\n"}
{"name":"MeasureTheory.Integrable.smul_essSup","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nf : α → 𝕜\nhf : MeasureTheory.Integrable f μ\ng : α → β\ng_aestronglyMeasurable : MeasureTheory.AEStronglyMeasurable g μ\ness_sup_g : Ne (essSup (fun x => ENorm.enorm (g x)) μ) Top.top\n⊢ MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) μ","decl":"/-- Hölder's inequality for integrable functions: the scalar multiplication of an integrable\nscalar-valued function by a vector-value function with finite essential supremum is integrable. -/\ntheorem Integrable.smul_essSup {𝕜 : Type*} [NormedRing 𝕜] [Module 𝕜 β] [BoundedSMul 𝕜 β]\n    {f : α → 𝕜} (hf : Integrable f μ) {g : α → β}\n    (g_aestronglyMeasurable : AEStronglyMeasurable g μ) (ess_sup_g : essSup (‖g ·‖ₑ) μ ≠ ∞) :\n    Integrable (fun x : α => f x • g x) μ := by\n  rw [← memℒp_one_iff_integrable] at *\n  refine ⟨hf.1.smul g_aestronglyMeasurable, ?_⟩\n  have h : (1 : ℝ≥0∞) / 1 = 1 / 1 + 1 / ∞ := by norm_num\n  have hg' : eLpNorm g ∞ μ ≠ ∞ := by rwa [eLpNorm_exponent_top]\n  calc\n    eLpNorm (fun x : α => f x • g x) 1 μ ≤ _ := by\n      simpa using MeasureTheory.eLpNorm_smul_le_mul_eLpNorm g_aestronglyMeasurable hf.1 h\n    _ < ∞ := ENNReal.mul_lt_top hf.2 hg'.lt_top\n\n"}
{"name":"MeasureTheory.integrable_norm_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.AEStronglyMeasurable f μ\n⊢ Iff (MeasureTheory.Integrable (fun a => Norm.norm (f a)) μ) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_norm_iff {f : α → β} (hf : AEStronglyMeasurable f μ) :\n    Integrable (fun a => ‖f a‖) μ ↔ Integrable f μ := by\n  simp_rw [Integrable, and_iff_right hf, and_iff_right hf.norm, hasFiniteIntegral_norm_iff]\n\n"}
{"name":"MeasureTheory.integrable_of_norm_sub_le","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf₀ f₁ : α → β\ng : α → Real\nhf₁_m : MeasureTheory.AEStronglyMeasurable f₁ μ\nhf₀_i : MeasureTheory.Integrable f₀ μ\nhg_i : MeasureTheory.Integrable g μ\nh : Filter.Eventually (fun a => LE.le (Norm.norm (HSub.hSub (f₀ a) (f₁ a))) (g a)) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable f₁ μ","decl":"theorem integrable_of_norm_sub_le {f₀ f₁ : α → β} {g : α → ℝ} (hf₁_m : AEStronglyMeasurable f₁ μ)\n    (hf₀_i : Integrable f₀ μ) (hg_i : Integrable g μ) (h : ∀ᵐ a ∂μ, ‖f₀ a - f₁ a‖ ≤ g a) :\n    Integrable f₁ μ :=\n  haveI : ∀ᵐ a ∂μ, ‖f₁ a‖ ≤ ‖f₀ a‖ + g a := by\n    apply h.mono\n    intro a ha\n    calc\n      ‖f₁ a‖ ≤ ‖f₀ a‖ + ‖f₀ a - f₁ a‖ := norm_le_insert _ _\n      _ ≤ ‖f₀ a‖ + g a := add_le_add_left ha _\n  Integrable.mono' (hf₀_i.norm.add hg_i) hf₁_m this\n\n"}
{"name":"MeasureTheory.integrable_of_le_of_le","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf g₁ g₂ : α → Real\nhf : MeasureTheory.AEStronglyMeasurable f μ\nh_le₁ : (MeasureTheory.ae μ).EventuallyLE g₁ f\nh_le₂ : (MeasureTheory.ae μ).EventuallyLE f g₂\nh_int₁ : MeasureTheory.Integrable g₁ μ\nh_int₂ : MeasureTheory.Integrable g₂ μ\n⊢ MeasureTheory.Integrable f μ","decl":"lemma integrable_of_le_of_le {f g₁ g₂ : α → ℝ} (hf : AEStronglyMeasurable f μ)\n    (h_le₁ : g₁ ≤ᵐ[μ] f) (h_le₂ : f ≤ᵐ[μ] g₂)\n    (h_int₁ : Integrable g₁ μ) (h_int₂ : Integrable g₂ μ) :\n    Integrable f μ := by\n  have : ∀ᵐ x ∂μ, ‖f x‖ ≤ max ‖g₁ x‖ ‖g₂ x‖ := by\n    filter_upwards [h_le₁, h_le₂] with x hx1 hx2\n    simp only [Real.norm_eq_abs]\n    exact abs_le_max_abs_abs hx1 hx2\n  have h_le_add : ∀ᵐ x ∂μ, ‖f x‖ ≤ ‖‖g₁ x‖ + ‖g₂ x‖‖ := by\n    filter_upwards [this] with x hx\n    refine hx.trans ?_\n    conv_rhs => rw [Real.norm_of_nonneg (by positivity)]\n    exact max_le_add_of_nonneg (norm_nonneg _) (norm_nonneg _)\n  exact Integrable.mono (h_int₁.norm.add h_int₂.norm) hf h_le_add\n\n"}
{"name":"MeasureTheory.Integrable.prod_mk","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedAddCommGroup γ\nf : α → β\ng : α → γ\nhf : MeasureTheory.Integrable f μ\nhg : MeasureTheory.Integrable g μ\n⊢ MeasureTheory.Integrable (fun x => { fst := f x, snd := g x }) μ","decl":"@[fun_prop]\ntheorem Integrable.prod_mk {f : α → β} {g : α → γ} (hf : Integrable f μ) (hg : Integrable g μ) :\n    Integrable (fun x => (f x, g x)) μ :=\n  ⟨hf.aestronglyMeasurable.prod_mk hg.aestronglyMeasurable,\n    (hf.norm.add' hg.norm).mono <|\n      Eventually.of_forall fun x =>\n        calc\n          max ‖f x‖ ‖g x‖ ≤ ‖f x‖ + ‖g x‖ := max_le_add_of_nonneg (norm_nonneg _) (norm_nonneg _)\n          _ ≤ ‖‖f x‖ + ‖g x‖‖ := le_abs_self _⟩\n\n"}
{"name":"MeasureTheory.Memℒp.integrable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\nq : ENNReal\nhq1 : LE.le 1 q\nf : α → β\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhfq : MeasureTheory.Memℒp f q μ\n⊢ MeasureTheory.Integrable f μ","decl":"theorem Memℒp.integrable {q : ℝ≥0∞} (hq1 : 1 ≤ q) {f : α → β} [IsFiniteMeasure μ]\n    (hfq : Memℒp f q μ) : Integrable f μ :=\n  memℒp_one_iff_integrable.mp (hfq.mono_exponent hq1)\n\n"}
{"name":"MeasureTheory.Integrable.measure_norm_ge_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\nε : Real\nhε : LT.lt 0 ε\n⊢ LT.lt (μ (setOf fun x => LE.le ε (Norm.norm (f x)))) Top.top","decl":"/-- A non-quantitative version of Markov inequality for integrable functions: the measure of points\nwhere `‖f x‖ ≥ ε` is finite for all positive `ε`. -/\ntheorem Integrable.measure_norm_ge_lt_top {f : α → β} (hf : Integrable f μ) {ε : ℝ} (hε : 0 < ε) :\n    μ { x | ε ≤ ‖f x‖ } < ∞ := by\n  rw [show { x | ε ≤ ‖f x‖ } = { x | .ofReal ε ≤ ‖f x‖ₑ } by\n      simp [ENNReal.ofReal, Real.toNNReal_le_iff_le_coe]]\n  refine (meas_ge_le_mul_pow_eLpNorm μ one_ne_zero ENNReal.one_ne_top hf.1 ?_).trans_lt ?_\n  · simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hε\n  apply ENNReal.mul_lt_top\n  · simpa only [ENNReal.one_toReal, ENNReal.rpow_one, ENNReal.inv_lt_top, ENNReal.ofReal_pos]\n      using hε\n  · simpa only [ENNReal.one_toReal, ENNReal.rpow_one] using\n      (memℒp_one_iff_integrable.2 hf).eLpNorm_lt_top\n\n"}
{"name":"MeasureTheory.Integrable.measure_norm_gt_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : NormedAddCommGroup β\nf : α → β\nhf : MeasureTheory.Integrable f μ\nε : Real\nhε : LT.lt 0 ε\n⊢ LT.lt (μ (setOf fun x => LT.lt ε (Norm.norm (f x)))) Top.top","decl":"/-- A non-quantitative version of Markov inequality for integrable functions: the measure of points\nwhere `‖f x‖ > ε` is finite for all positive `ε`. -/\nlemma Integrable.measure_norm_gt_lt_top {f : α → β} (hf : Integrable f μ) {ε : ℝ} (hε : 0 < ε) :\n    μ {x | ε < ‖f x‖} < ∞ :=\n  lt_of_le_of_lt (measure_mono (fun _ h ↦ (Set.mem_setOf_eq ▸ h).le)) (hf.measure_norm_ge_lt_top hε)\n\n"}
{"name":"MeasureTheory.Integrable.measure_ge_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nε : Real\nε_pos : LT.lt 0 ε\n⊢ LT.lt (μ (setOf fun a => LE.le ε (f a))) Top.top","decl":"/-- If `f` is `ℝ`-valued and integrable, then for any `c > 0` the set `{x | f x ≥ c}` has finite\nmeasure. -/\nlemma Integrable.measure_ge_lt_top {f : α → ℝ} (hf : Integrable f μ) {ε : ℝ} (ε_pos : 0 < ε) :\n    μ {a : α | ε ≤ f a} < ∞ := by\n  refine lt_of_le_of_lt (measure_mono ?_) (hf.measure_norm_ge_lt_top ε_pos)\n  intro x hx\n  simp only [Real.norm_eq_abs, Set.mem_setOf_eq] at hx ⊢\n  exact hx.trans (le_abs_self _)\n\n"}
{"name":"MeasureTheory.Integrable.measure_le_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nc : Real\nc_neg : LT.lt c 0\n⊢ LT.lt (μ (setOf fun a => LE.le (f a) c)) Top.top","decl":"/-- If `f` is `ℝ`-valued and integrable, then for any `c < 0` the set `{x | f x ≤ c}` has finite\nmeasure. -/\nlemma Integrable.measure_le_lt_top {f : α → ℝ} (hf : Integrable f μ) {c : ℝ} (c_neg : c < 0) :\n    μ {a : α | f a ≤ c} < ∞ := by\n  refine lt_of_le_of_lt (measure_mono ?_) (hf.measure_norm_ge_lt_top (show 0 < -c by linarith))\n  intro x hx\n  simp only [Real.norm_eq_abs, Set.mem_setOf_eq] at hx ⊢\n  exact (show -c ≤ - f x by linarith).trans (neg_le_abs _)\n\n"}
{"name":"MeasureTheory.Integrable.measure_gt_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nε : Real\nε_pos : LT.lt 0 ε\n⊢ LT.lt (μ (setOf fun a => LT.lt ε (f a))) Top.top","decl":"/-- If `f` is `ℝ`-valued and integrable, then for any `c > 0` the set `{x | f x > c}` has finite\nmeasure. -/\nlemma Integrable.measure_gt_lt_top {f : α → ℝ} (hf : Integrable f μ) {ε : ℝ} (ε_pos : 0 < ε) :\n    μ {a : α | ε < f a} < ∞ :=\n  lt_of_le_of_lt (measure_mono (fun _ hx ↦ (Set.mem_setOf_eq ▸ hx).le))\n    (Integrable.measure_ge_lt_top hf ε_pos)\n\n"}
{"name":"MeasureTheory.Integrable.measure_lt_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\nc : Real\nc_neg : LT.lt c 0\n⊢ LT.lt (μ (setOf fun a => LT.lt (f a) c)) Top.top","decl":"/-- If `f` is `ℝ`-valued and integrable, then for any `c < 0` the set `{x | f x < c}` has finite\nmeasure. -/\nlemma Integrable.measure_lt_lt_top {f : α → ℝ} (hf : Integrable f μ) {c : ℝ} (c_neg : c < 0) :\n    μ {a : α | f a < c} < ∞ :=\n  lt_of_le_of_lt (measure_mono (fun _ hx ↦ (Set.mem_setOf_eq ▸ hx).le))\n    (Integrable.measure_le_lt_top hf c_neg)\n\n"}
{"name":"MeasureTheory.LipschitzWith.integrable_comp_iff_of_antilipschitz","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nγ : Type u_3\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : NormedAddCommGroup γ\nK K' : NNReal\nf : α → β\ng : β → γ\nhg : LipschitzWith K g\nhg' : AntilipschitzWith K' g\ng0 : Eq (g 0) 0\n⊢ Iff (MeasureTheory.Integrable (Function.comp g f) μ) (MeasureTheory.Integrable f μ)","decl":"theorem LipschitzWith.integrable_comp_iff_of_antilipschitz {K K'} {f : α → β} {g : β → γ}\n    (hg : LipschitzWith K g) (hg' : AntilipschitzWith K' g) (g0 : g 0 = 0) :\n    Integrable (g ∘ f) μ ↔ Integrable f μ := by\n  simp [← memℒp_one_iff_integrable, hg.memℒp_comp_iff_of_antilipschitz hg' g0]\n\n"}
{"name":"MeasureTheory.Integrable.real_toNNReal","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => ↑(f x).toNNReal) μ","decl":"@[fun_prop]\ntheorem Integrable.real_toNNReal {f : α → ℝ} (hf : Integrable f μ) :\n    Integrable (fun x => ((f x).toNNReal : ℝ)) μ := by\n  refine\n    ⟨hf.aestronglyMeasurable.aemeasurable.real_toNNReal.coe_nnreal_real.aestronglyMeasurable, ?_⟩\n  rw [hasFiniteIntegral_iff_norm]\n  refine lt_of_le_of_lt ?_ ((hasFiniteIntegral_iff_norm _).1 hf.hasFiniteIntegral)\n  apply lintegral_mono\n  intro x\n  simp [ENNReal.ofReal_le_ofReal, abs_le, le_abs_self]\n\n"}
{"name":"MeasureTheory.ofReal_toReal_ae_eq","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => ENNReal.ofReal (f x).toReal) f","decl":"theorem ofReal_toReal_ae_eq {f : α → ℝ≥0∞} (hf : ∀ᵐ x ∂μ, f x < ∞) :\n    (fun x => ENNReal.ofReal (f x).toReal) =ᵐ[μ] f := by\n  filter_upwards [hf]\n  intro x hx\n  simp only [hx.ne, ofReal_toReal, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.coe_toNNReal_ae_eq","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)\n⊢ (MeasureTheory.ae μ).EventuallyEq (fun x => ↑(f x).toNNReal) f","decl":"theorem coe_toNNReal_ae_eq {f : α → ℝ≥0∞} (hf : ∀ᵐ x ∂μ, f x < ∞) :\n    (fun x => ((f x).toNNReal : ℝ≥0∞)) =ᵐ[μ] f := by\n  filter_upwards [hf]\n  intro x hx\n  simp only [hx.ne, Ne, not_false_iff, coe_toNNReal]\n\n"}
{"name":"MeasureTheory.integrable_count_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup β\ninst✝ : MeasurableSingletonClass α\nf : α → β\n⊢ Iff (MeasureTheory.Integrable f MeasureTheory.Measure.count) (Summable fun x => Norm.norm (f x))","decl":"/-- A function is integrable for the counting measure iff its norm is summable. -/\nlemma integrable_count_iff :\n    Integrable f Measure.count ↔ Summable (‖f ·‖) := by\n  -- Note: this proof would be much easier if we assumed `SecondCountableTopology G`. Without\n  -- this we have to justify the claim that `f` lands a.e. in a separable subset, which is true\n  -- (because summable functions have countable range) but slightly tedious to check.\n  rw [Integrable, hasFiniteIntegral_count_iff, and_iff_right_iff_imp]\n  intro hs\n  have hs' : (Function.support f).Countable := by\n    simpa only [Ne, Pi.zero_apply, eq_comm, Function.support, norm_eq_zero]\n      using hs.countable_support\n  letI : MeasurableSpace β := borel β\n  haveI : BorelSpace β := ⟨rfl⟩\n  refine aestronglyMeasurable_iff_aemeasurable_separable.mpr ⟨?_, ?_⟩\n  · refine (measurable_zero.measurable_of_countable_ne ?_).aemeasurable\n    simpa only [Ne, Pi.zero_apply, eq_comm, Function.support] using hs'\n  · refine ⟨f '' univ, ?_, ae_of_all _ fun a ↦ ⟨a, ⟨mem_univ _, rfl⟩⟩⟩\n    suffices f '' univ ⊆ (f '' f.support) ∪ {0} from\n      (((hs'.image f).union (countable_singleton 0)).mono this).isSeparable\n    intro g hg\n    rcases eq_or_ne g 0 with rfl | hg'\n    · exact Or.inr (mem_singleton _)\n    · obtain ⟨x, -, rfl⟩ := (mem_image ..).mp hg\n      exact Or.inl ⟨x, hg', rfl⟩\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_coe_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → NNReal\nhf : Measurable f\ng : α → E\n⊢ Iff (MeasureTheory.Integrable g (μ.withDensity fun x => ↑(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (↑(f x)) (g x)) μ)","decl":"theorem integrable_withDensity_iff_integrable_coe_smul {f : α → ℝ≥0} (hf : Measurable f)\n    {g : α → E} :\n    Integrable g (μ.withDensity fun x => f x) ↔ Integrable (fun x => (f x : ℝ) • g x) μ := by\n  by_cases H : AEStronglyMeasurable (fun x : α => (f x : ℝ) • g x) μ\n  · simp only [Integrable, aestronglyMeasurable_withDensity_iff hf, hasFiniteIntegral_iff_enorm, H,\n      true_and]\n    rw [lintegral_withDensity_eq_lintegral_mul₀' hf.coe_nnreal_ennreal.aemeasurable]\n    · simp [enorm_smul]\n    · simpa [aemeasurable_withDensity_ennreal_iff hf, enorm_smul] using H.enorm\n  · simp only [Integrable, aestronglyMeasurable_withDensity_iff hf, H, false_and]\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → NNReal\nhf : Measurable f\ng : α → E\n⊢ Iff (MeasureTheory.Integrable g (μ.withDensity fun x => ↑(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) μ)","decl":"theorem integrable_withDensity_iff_integrable_smul {f : α → ℝ≥0} (hf : Measurable f) {g : α → E} :\n    Integrable g (μ.withDensity fun x => f x) ↔ Integrable (fun x => f x • g x) μ :=\n  integrable_withDensity_iff_integrable_coe_smul hf\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_smul'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → ENNReal\nhf : Measurable f\nhflt : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)\ng : α → E\n⊢ Iff (MeasureTheory.Integrable g (μ.withDensity f)) (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x).toReal (g x)) μ)","decl":"theorem integrable_withDensity_iff_integrable_smul' {f : α → ℝ≥0∞} (hf : Measurable f)\n    (hflt : ∀ᵐ x ∂μ, f x < ∞) {g : α → E} :\n    Integrable g (μ.withDensity f) ↔ Integrable (fun x => (f x).toReal • g x) μ := by\n  rw [← withDensity_congr_ae (coe_toNNReal_ae_eq hflt),\n    integrable_withDensity_iff_integrable_smul]\n  · simp_rw [NNReal.smul_def, ENNReal.toReal]\n  · exact hf.ennreal_toNNReal\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_coe_smul₀","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → NNReal\nhf : AEMeasurable f μ\ng : α → E\n⊢ Iff (MeasureTheory.Integrable g (μ.withDensity fun x => ↑(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (↑(f x)) (g x)) μ)","decl":"theorem integrable_withDensity_iff_integrable_coe_smul₀ {f : α → ℝ≥0} (hf : AEMeasurable f μ)\n    {g : α → E} :\n    Integrable g (μ.withDensity fun x => f x) ↔ Integrable (fun x => (f x : ℝ) • g x) μ :=\n  calc\n    Integrable g (μ.withDensity fun x => f x) ↔\n        Integrable g (μ.withDensity fun x => (hf.mk f x : ℝ≥0)) := by\n      suffices (fun x => (f x : ℝ≥0∞)) =ᵐ[μ] (fun x => (hf.mk f x : ℝ≥0)) by\n        rw [withDensity_congr_ae this]\n      filter_upwards [hf.ae_eq_mk] with x hx\n      simp [hx]\n    _ ↔ Integrable (fun x => ((hf.mk f x : ℝ≥0) : ℝ) • g x) μ :=\n      integrable_withDensity_iff_integrable_coe_smul hf.measurable_mk\n    _ ↔ Integrable (fun x => (f x : ℝ) • g x) μ := by\n      apply integrable_congr\n      filter_upwards [hf.ae_eq_mk] with x hx\n      simp [hx]\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_smul₀","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → NNReal\nhf : AEMeasurable f μ\ng : α → E\n⊢ Iff (MeasureTheory.Integrable g (μ.withDensity fun x => ↑(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) μ)","decl":"theorem integrable_withDensity_iff_integrable_smul₀ {f : α → ℝ≥0} (hf : AEMeasurable f μ)\n    {g : α → E} : Integrable g (μ.withDensity fun x => f x) ↔ Integrable (fun x => f x • g x) μ :=\n  integrable_withDensity_iff_integrable_coe_smul₀ hf\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : Measurable f\nhflt : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae μ)\ng : α → Real\n⊢ Iff (MeasureTheory.Integrable g (μ.withDensity f)) (MeasureTheory.Integrable (fun x => HMul.hMul (g x) (f x).toReal) μ)","decl":"theorem integrable_withDensity_iff {f : α → ℝ≥0∞} (hf : Measurable f) (hflt : ∀ᵐ x ∂μ, f x < ∞)\n    {g : α → ℝ} : Integrable g (μ.withDensity f) ↔ Integrable (fun x => g x * (f x).toReal) μ := by\n  have : (fun x => g x * (f x).toReal) = fun x => (f x).toReal • g x := by simp [mul_comm]\n  rw [this]\n  exact integrable_withDensity_iff_integrable_smul' hf hflt\n\n"}
{"name":"MeasureTheory.memℒ1_smul_of_L1_withDensity","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → NNReal\nf_meas : Measurable f\nu : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 (μ.withDensity fun x => ↑(f x))) x\n⊢ MeasureTheory.Memℒp (fun x => HSMul.hSMul (f x) (↑↑u x)) 1 μ","decl":"theorem memℒ1_smul_of_L1_withDensity {f : α → ℝ≥0} (f_meas : Measurable f)\n    (u : Lp E 1 (μ.withDensity fun x => f x)) : Memℒp (fun x => f x • u x) 1 μ :=\n  memℒp_one_iff_integrable.2 <|\n    (integrable_withDensity_iff_integrable_smul f_meas).1 <| memℒp_one_iff_integrable.1 (Lp.memℒp u)\n\n"}
{"name":"MeasureTheory.withDensitySMulLI_apply","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace Real E\nf : α → NNReal\nf_meas : Measurable f\nu : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 (μ.withDensity fun x => ↑(f x))) x\n⊢ Eq ((MeasureTheory.withDensitySMulLI μ f_meas) u) (MeasureTheory.Memℒp.toLp (fun x => HSMul.hSMul (f x) (↑↑u x)) ⋯)","decl":"@[simp]\ntheorem withDensitySMulLI_apply {f : α → ℝ≥0} (f_meas : Measurable f)\n    (u : Lp E 1 (μ.withDensity fun x => f x)) :\n    withDensitySMulLI μ (E := E) f_meas u =\n      (memℒ1_smul_of_L1_withDensity f_meas u).toLp fun x => f x • u x :=\n  rfl\n\n"}
{"name":"MeasureTheory.mem_ℒ1_toReal_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhfm : AEMeasurable f μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ MeasureTheory.Memℒp (fun x => (f x).toReal) 1 μ","decl":"theorem mem_ℒ1_toReal_of_lintegral_ne_top {f : α → ℝ≥0∞} (hfm : AEMeasurable f μ)\n    (hfi : ∫⁻ x, f x ∂μ ≠ ∞) : Memℒp (fun x ↦ (f x).toReal) 1 μ := by\n  rw [Memℒp, eLpNorm_one_eq_lintegral_enorm]\n  exact ⟨(AEMeasurable.ennreal_toReal hfm).aestronglyMeasurable,\n    hasFiniteIntegral_toReal_of_lintegral_ne_top hfi⟩\n\n"}
{"name":"MeasureTheory.integrable_toReal_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhfm : AEMeasurable f μ\nhfi : Ne (MeasureTheory.lintegral μ fun x => f x) Top.top\n⊢ MeasureTheory.Integrable (fun x => (f x).toReal) μ","decl":"theorem integrable_toReal_of_lintegral_ne_top {f : α → ℝ≥0∞} (hfm : AEMeasurable f μ)\n    (hfi : ∫⁻ x, f x ∂μ ≠ ∞) : Integrable (fun x ↦ (f x).toReal) μ :=\n  memℒp_one_iff_integrable.1 <| mem_ℒ1_toReal_of_lintegral_ne_top hfm hfi\n\n"}
{"name":"MeasureTheory.integrable_toReal_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → ENNReal\nhf : AEMeasurable f μ\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae μ)\n⊢ Iff (MeasureTheory.Integrable (fun x => (f x).toReal) μ) (Ne (MeasureTheory.lintegral μ fun x => f x) Top.top)","decl":"lemma integrable_toReal_iff {f : α → ℝ≥0∞} (hf : AEMeasurable f μ) (hf_ne_top : ∀ᵐ x ∂μ, f x ≠ ∞) :\n    Integrable (fun x ↦ (f x).toReal) μ ↔ ∫⁻ x, f x ∂μ ≠ ∞ := by\n  rw [Integrable, hasFiniteIntegral_toReal_iff hf_ne_top]\n  simp only [hf.ennreal_toReal.aestronglyMeasurable, ne_eq, true_and]\n\n"}
{"name":"MeasureTheory.lintegral_ofReal_ne_top_iff_integrable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhfm : MeasureTheory.AEStronglyMeasurable f μ\nhf : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ Iff (Ne (MeasureTheory.lintegral μ fun a => ENNReal.ofReal (f a)) Top.top) (MeasureTheory.Integrable f μ)","decl":"lemma lintegral_ofReal_ne_top_iff_integrable {f : α → ℝ}\n    (hfm : AEStronglyMeasurable f μ) (hf : 0 ≤ᵐ[μ] f) :\n    ∫⁻ a, ENNReal.ofReal (f a) ∂μ ≠ ∞ ↔ Integrable f μ := by\n  rw [Integrable, hasFiniteIntegral_iff_ofReal hf]\n  simp [hfm]\n\n"}
{"name":"MeasureTheory.Integrable.pos_part","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun a => Max.max (f a) 0) μ","decl":"@[fun_prop]\ntheorem Integrable.pos_part {f : α → ℝ} (hf : Integrable f μ) :\n    Integrable (fun a => max (f a) 0) μ :=\n  ⟨(hf.aestronglyMeasurable.aemeasurable.max aemeasurable_const).aestronglyMeasurable,\n    hf.hasFiniteIntegral.max_zero⟩\n\n"}
{"name":"MeasureTheory.Integrable.neg_part","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun a => Max.max (Neg.neg (f a)) 0) μ","decl":"@[fun_prop]\ntheorem Integrable.neg_part {f : α → ℝ} (hf : Integrable f μ) :\n    Integrable (fun a => max (-f a) 0) μ :=\n  hf.neg.pos_part\n\n"}
{"name":"MeasureTheory.Integrable.smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedAddCommGroup 𝕜\ninst✝¹ : SMulZeroClass 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nc : 𝕜\nf : α → β\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (HSMul.hSMul c f) μ","decl":"@[fun_prop]\ntheorem Integrable.smul [NormedAddCommGroup 𝕜] [SMulZeroClass 𝕜 β] [BoundedSMul 𝕜 β] (c : 𝕜)\n    {f : α → β} (hf : Integrable f μ) : Integrable (c • f) μ :=\n  ⟨hf.aestronglyMeasurable.const_smul c, hf.hasFiniteIntegral.smul c⟩\n\n"}
{"name":"IsUnit.integrable_smul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nc : 𝕜\nhc : IsUnit c\nf : α → β\n⊢ Iff (MeasureTheory.Integrable (HSMul.hSMul c f) μ) (MeasureTheory.Integrable f μ)","decl":"theorem _root_.IsUnit.integrable_smul_iff [NormedRing 𝕜] [Module 𝕜 β] [BoundedSMul 𝕜 β] {c : 𝕜}\n    (hc : IsUnit c) (f : α → β) : Integrable (c • f) μ ↔ Integrable f μ :=\n  and_congr hc.aestronglyMeasurable_const_smul_iff (hasFiniteIntegral_smul_iff hc f)\n\n"}
{"name":"MeasureTheory.integrable_smul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedDivisionRing 𝕜\ninst✝¹ : Module 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nc : 𝕜\nhc : Ne c 0\nf : α → β\n⊢ Iff (MeasureTheory.Integrable (HSMul.hSMul c f) μ) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_smul_iff [NormedDivisionRing 𝕜] [Module 𝕜 β] [BoundedSMul 𝕜 β] {c : 𝕜}\n    (hc : c ≠ 0) (f : α → β) : Integrable (c • f) μ ↔ Integrable f μ :=\n  (IsUnit.mk0 _ hc).integrable_smul_iff f\n\n"}
{"name":"MeasureTheory.Integrable.smul_of_top_right","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nf : α → β\nφ : α → 𝕜\nhf : MeasureTheory.Integrable f μ\nhφ : MeasureTheory.Memℒp φ Top.top μ\n⊢ MeasureTheory.Integrable (HSMul.hSMul φ f) μ","decl":"theorem Integrable.smul_of_top_right {f : α → β} {φ : α → 𝕜} (hf : Integrable f μ)\n    (hφ : Memℒp φ ∞ μ) : Integrable (φ • f) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢\n  exact Memℒp.smul_of_top_right hf hφ\n\n"}
{"name":"MeasureTheory.Integrable.smul_of_top_left","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nf : α → β\nφ : α → 𝕜\nhφ : MeasureTheory.Integrable φ μ\nhf : MeasureTheory.Memℒp f Top.top μ\n⊢ MeasureTheory.Integrable (HSMul.hSMul φ f) μ","decl":"theorem Integrable.smul_of_top_left {f : α → β} {φ : α → 𝕜} (hφ : Integrable φ μ)\n    (hf : Memℒp f ∞ μ) : Integrable (φ • f) μ := by\n  rw [← memℒp_one_iff_integrable] at hφ ⊢\n  exact Memℒp.smul_of_top_left hf hφ\n\n"}
{"name":"MeasureTheory.Integrable.smul_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nβ : Type u_2\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝³ : NormedAddCommGroup β\n𝕜 : Type u_6\ninst✝² : NormedRing 𝕜\ninst✝¹ : Module 𝕜 β\ninst✝ : BoundedSMul 𝕜 β\nf : α → 𝕜\nhf : MeasureTheory.Integrable f μ\nc : β\n⊢ MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) c) μ","decl":"@[fun_prop]\ntheorem Integrable.smul_const {f : α → 𝕜} (hf : Integrable f μ) (c : β) :\n    Integrable (fun x => f x • c) μ :=\n  hf.smul_of_top_left (memℒp_top_const c)\n\n"}
{"name":"MeasureTheory.integrable_smul_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : CompleteSpace 𝕜\nE : Type u_7\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf : α → 𝕜\nc : E\nhc : Ne c 0\n⊢ Iff (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) c) μ) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_smul_const {f : α → 𝕜} {c : E} (hc : c ≠ 0) :\n    Integrable (fun x => f x • c) μ ↔ Integrable f μ := by\n  simp_rw [Integrable, aestronglyMeasurable_smul_const_iff (f := f) hc, and_congr_right_iff,\n    hasFiniteIntegral_iff_enorm, enorm_smul]\n  intro _; rw [lintegral_mul_const' _ _ enorm_ne_top, ENNReal.mul_lt_top_iff]\n  have : ∀ x : ℝ≥0∞, x = 0 → x < ∞ := by simp\n  simp [hc, or_iff_left_of_imp (this _)]\n\n"}
{"name":"MeasureTheory.Integrable.const_mul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf : α → 𝕜\nh : MeasureTheory.Integrable f μ\nc : 𝕜\n⊢ MeasureTheory.Integrable (fun x => HMul.hMul c (f x)) μ","decl":"@[fun_prop]\ntheorem Integrable.const_mul {f : α → 𝕜} (h : Integrable f μ) (c : 𝕜) :\n    Integrable (fun x => c * f x) μ :=\n  h.smul c\n\n"}
{"name":"MeasureTheory.Integrable.const_mul'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf : α → 𝕜\nh : MeasureTheory.Integrable f μ\nc : 𝕜\n⊢ MeasureTheory.Integrable (HMul.hMul (fun x => c) f) μ","decl":"theorem Integrable.const_mul' {f : α → 𝕜} (h : Integrable f μ) (c : 𝕜) :\n    Integrable ((fun _ : α => c) * f) μ :=\n  Integrable.const_mul h c\n\n"}
{"name":"MeasureTheory.Integrable.mul_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf : α → 𝕜\nh : MeasureTheory.Integrable f μ\nc : 𝕜\n⊢ MeasureTheory.Integrable (fun x => HMul.hMul (f x) c) μ","decl":"@[fun_prop]\ntheorem Integrable.mul_const {f : α → 𝕜} (h : Integrable f μ) (c : 𝕜) :\n    Integrable (fun x => f x * c) μ :=\n  h.smul (MulOpposite.op c)\n\n"}
{"name":"MeasureTheory.Integrable.mul_const'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf : α → 𝕜\nh : MeasureTheory.Integrable f μ\nc : 𝕜\n⊢ MeasureTheory.Integrable (HMul.hMul f fun x => c) μ","decl":"theorem Integrable.mul_const' {f : α → 𝕜} (h : Integrable f μ) (c : 𝕜) :\n    Integrable (f * fun _ : α => c) μ :=\n  Integrable.mul_const h c\n\n"}
{"name":"MeasureTheory.integrable_const_mul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nc : 𝕜\nhc : IsUnit c\nf : α → 𝕜\n⊢ Iff (MeasureTheory.Integrable (fun x => HMul.hMul c (f x)) μ) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_const_mul_iff {c : 𝕜} (hc : IsUnit c) (f : α → 𝕜) :\n    Integrable (fun x => c * f x) μ ↔ Integrable f μ :=\n  hc.integrable_smul_iff f\n\n"}
{"name":"MeasureTheory.integrable_mul_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nc : 𝕜\nhc : IsUnit c\nf : α → 𝕜\n⊢ Iff (MeasureTheory.Integrable (fun x => HMul.hMul (f x) c) μ) (MeasureTheory.Integrable f μ)","decl":"theorem integrable_mul_const_iff {c : 𝕜} (hc : IsUnit c) (f : α → 𝕜) :\n    Integrable (fun x => f x * c) μ ↔ Integrable f μ :=\n  hc.op.integrable_smul_iff f\n\n"}
{"name":"MeasureTheory.Integrable.bdd_mul'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf g : α → 𝕜\nc : Real\nhg : MeasureTheory.Integrable g μ\nhf : MeasureTheory.AEStronglyMeasurable f μ\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae μ)\n⊢ MeasureTheory.Integrable (fun x => HMul.hMul (f x) (g x)) μ","decl":"theorem Integrable.bdd_mul' {f g : α → 𝕜} {c : ℝ} (hg : Integrable g μ)\n    (hf : AEStronglyMeasurable f μ) (hf_bound : ∀ᵐ x ∂μ, ‖f x‖ ≤ c) :\n    Integrable (fun x => f x * g x) μ := by\n  refine Integrable.mono' (hg.norm.smul c) (hf.mul hg.1) ?_\n  filter_upwards [hf_bound] with x hx\n  rw [Pi.smul_apply, smul_eq_mul]\n  exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right hx (norm_nonneg _))\n\n"}
{"name":"MeasureTheory.Integrable.mul_of_top_right","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf φ : α → 𝕜\nhf : MeasureTheory.Integrable f μ\nhφ : MeasureTheory.Memℒp φ Top.top μ\n⊢ MeasureTheory.Integrable (HMul.hMul φ f) μ","decl":"theorem Integrable.mul_of_top_right {f : α → 𝕜} {φ : α → 𝕜} (hf : Integrable f μ)\n    (hφ : Memℒp φ ∞ μ) : Integrable (φ * f) μ :=\n  hf.smul_of_top_right hφ\n\n"}
{"name":"MeasureTheory.Integrable.mul_of_top_left","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedRing 𝕜\nf φ : α → 𝕜\nhφ : MeasureTheory.Integrable φ μ\nhf : MeasureTheory.Memℒp f Top.top μ\n⊢ MeasureTheory.Integrable (HMul.hMul φ f) μ","decl":"theorem Integrable.mul_of_top_left {f : α → 𝕜} {φ : α → 𝕜} (hφ : Integrable φ μ)\n    (hf : Memℒp f ∞ μ) : Integrable (φ * f) μ :=\n  hφ.smul_of_top_left hf\n\n"}
{"name":"MeasureTheory.Integrable.div_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : NormedDivisionRing 𝕜\nf : α → 𝕜\nh : MeasureTheory.Integrable f μ\nc : 𝕜\n⊢ MeasureTheory.Integrable (fun x => HDiv.hDiv (f x) c) μ","decl":"@[fun_prop]\ntheorem Integrable.div_const {f : α → 𝕜} (h : Integrable f μ) (c : 𝕜) :\n    Integrable (fun x => f x / c) μ := by simp_rw [div_eq_mul_inv, h.mul_const]\n\n"}
{"name":"MeasureTheory.Integrable.ofReal","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → Real\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => ↑(f x)) μ","decl":"@[fun_prop]\ntheorem Integrable.ofReal {f : α → ℝ} (hf : Integrable f μ) :\n    Integrable (fun x => (f x : 𝕜)) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢\n  exact hf.ofReal\n\n"}
{"name":"MeasureTheory.Integrable.re_im_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → 𝕜\n⊢ Iff (And (MeasureTheory.Integrable (fun x => RCLike.re (f x)) μ) (MeasureTheory.Integrable (fun x => RCLike.im (f x)) μ)) (MeasureTheory.Integrable f μ)","decl":"theorem Integrable.re_im_iff :\n    Integrable (fun x => RCLike.re (f x)) μ ∧ Integrable (fun x => RCLike.im (f x)) μ ↔\n      Integrable f μ := by\n  simp_rw [← memℒp_one_iff_integrable]\n  exact memℒp_re_im_iff\n\n"}
{"name":"MeasureTheory.Integrable.re","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → 𝕜\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => RCLike.re (f x)) μ","decl":"@[fun_prop]\ntheorem Integrable.re (hf : Integrable f μ) : Integrable (fun x => RCLike.re (f x)) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢\n  exact hf.re\n\n"}
{"name":"MeasureTheory.Integrable.im","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n𝕜 : Type u_6\ninst✝ : RCLike 𝕜\nf : α → 𝕜\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => RCLike.im (f x)) μ","decl":"@[fun_prop]\ntheorem Integrable.im (hf : Integrable f μ) : Integrable (fun x => RCLike.im (f x)) μ := by\n  rw [← memℒp_one_iff_integrable] at hf ⊢\n  exact hf.im\n\n"}
{"name":"MeasureTheory.Integrable.trim","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nH : Type u_6\ninst✝ : NormedAddCommGroup H\nm0 : MeasurableSpace α\nμ' : MeasureTheory.Measure α\nf : α → H\nhm : LE.le m m0\nhf_int : MeasureTheory.Integrable f μ'\nhf : MeasureTheory.StronglyMeasurable f\n⊢ MeasureTheory.Integrable f (μ'.trim hm)","decl":"theorem Integrable.trim (hm : m ≤ m0) (hf_int : Integrable f μ') (hf : StronglyMeasurable[m] f) :\n    Integrable f (μ'.trim hm) := by\n  refine ⟨hf.aestronglyMeasurable, ?_⟩\n  rw [HasFiniteIntegral, lintegral_trim hm _]\n  · exact hf_int.2\n  · exact @StronglyMeasurable.enorm _ m _ _ f hf\n\n"}
{"name":"MeasureTheory.integrable_of_integrable_trim","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nH : Type u_6\ninst✝ : NormedAddCommGroup H\nm0 : MeasurableSpace α\nμ' : MeasureTheory.Measure α\nf : α → H\nhm : LE.le m m0\nhf_int : MeasureTheory.Integrable f (μ'.trim hm)\n⊢ MeasureTheory.Integrable f μ'","decl":"theorem integrable_of_integrable_trim (hm : m ≤ m0) (hf_int : Integrable f (μ'.trim hm)) :\n    Integrable f μ' := by\n  obtain ⟨hf_meas_ae, hf⟩ := hf_int\n  refine ⟨aestronglyMeasurable_of_aestronglyMeasurable_trim hm hf_meas_ae, ?_⟩\n  simpa [HasFiniteIntegral, lintegral_trim_ae hm hf_meas_ae.enorm] using hf\n\n"}
{"name":"MeasureTheory.integrable_of_forall_fin_meas_le'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nE : Type u_6\nm0 : MeasurableSpace α\ninst✝¹ : NormedAddCommGroup E\nμ : MeasureTheory.Measure α\nhm : LE.le m m0\ninst✝ : MeasureTheory.SigmaFinite (μ.trim hm)\nC : ENNReal\nhC : LT.lt C Top.top\nf : α → E\nhf_meas : MeasureTheory.AEStronglyMeasurable f μ\nhf : ∀ (s : Set α), MeasurableSet s → Ne (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => ENorm.enorm (f x)) C\n⊢ MeasureTheory.Integrable f μ","decl":"theorem integrable_of_forall_fin_meas_le' {μ : Measure α} (hm : m ≤ m0) [SigmaFinite (μ.trim hm)]\n    (C : ℝ≥0∞) (hC : C < ∞) {f : α → E} (hf_meas : AEStronglyMeasurable f μ)\n    (hf : ∀ s, MeasurableSet[m] s → μ s ≠ ∞ → ∫⁻ x in s, ‖f x‖ₑ ∂μ ≤ C) : Integrable f μ :=\n  ⟨hf_meas, (lintegral_le_of_forall_fin_meas_trim_le hm C hf).trans_lt hC⟩\n\n"}
{"name":"MeasureTheory.integrable_of_forall_fin_meas_le","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝¹ : NormedAddCommGroup E\ninst✝ : MeasureTheory.SigmaFinite μ\nC : ENNReal\nhC : LT.lt C Top.top\nf : α → E\nhf_meas : MeasureTheory.AEStronglyMeasurable f μ\nhf : ∀ (s : Set α), MeasurableSet s → Ne (μ s) Top.top → LE.le (MeasureTheory.lintegral (μ.restrict s) fun x => ENorm.enorm (f x)) C\n⊢ MeasureTheory.Integrable f μ","decl":"theorem integrable_of_forall_fin_meas_le [SigmaFinite μ] (C : ℝ≥0∞) (hC : C < ∞) {f : α → E}\n    (hf_meas : AEStronglyMeasurable[m] f μ)\n    (hf : ∀ s : Set α, MeasurableSet[m] s → μ s ≠ ∞ → ∫⁻ x in s, ‖f x‖ₑ ∂μ ≤ C) :\n    Integrable f μ :=\n  have : SigmaFinite (μ.trim le_rfl) := by rwa [@trim_eq_self _ m]\n  integrable_of_forall_fin_meas_le' le_rfl C hC hf_meas hf\n\n"}
{"name":"MeasureTheory.Integrable.restrict","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝ : NormedAddCommGroup E\nf : α → E\nhf : MeasureTheory.Integrable f μ\ns : Set α\n⊢ MeasureTheory.Integrable f (μ.restrict s)","decl":"/-- One should usually use `MeasureTheory.Integrable.IntegrableOn` instead. -/\nlemma Integrable.restrict (hf : Integrable f μ) {s : Set α} : Integrable f (μ.restrict s) :=\n  hf.mono_measure Measure.restrict_le_self\n\n"}
{"name":"ContinuousLinearMap.integrable_comp","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝⁴ : NormedAddCommGroup E\n𝕜 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\nH : Type u_8\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nφ : α → H\nL : ContinuousLinearMap (RingHom.id 𝕜) H E\nφ_int : MeasureTheory.Integrable φ μ\n⊢ MeasureTheory.Integrable (fun a => L (φ a)) μ","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.integrable_comp {φ : α → H} (L : H →L[𝕜] E) (φ_int : Integrable φ μ) :\n    Integrable (fun a : α => L (φ a)) μ :=\n  ((Integrable.norm φ_int).const_mul ‖L‖).mono'\n    (L.continuous.comp_aestronglyMeasurable φ_int.aestronglyMeasurable)\n    (Eventually.of_forall fun a => L.le_opNorm (φ a))\n\n"}
{"name":"ContinuousLinearEquiv.integrable_comp_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝⁴ : NormedAddCommGroup E\n𝕜 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\nH : Type u_8\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nφ : α → H\nL : ContinuousLinearEquiv (RingHom.id 𝕜) H E\n⊢ Iff (MeasureTheory.Integrable (fun a => L (φ a)) μ) (MeasureTheory.Integrable φ μ)","decl":"@[simp]\ntheorem ContinuousLinearEquiv.integrable_comp_iff {φ : α → H} (L : H ≃L[𝕜] E) :\n    Integrable (fun a : α ↦ L (φ a)) μ ↔ Integrable φ μ :=\n  ⟨fun h ↦ by simpa using ContinuousLinearMap.integrable_comp (L.symm : E →L[𝕜] H) h,\n  fun h ↦ ContinuousLinearMap.integrable_comp (L : H →L[𝕜] E) h⟩\n\n"}
{"name":"LinearIsometryEquiv.integrable_comp_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝⁴ : NormedAddCommGroup E\n𝕜 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\nH : Type u_8\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nφ : α → H\nL : LinearIsometryEquiv (RingHom.id 𝕜) H E\n⊢ Iff (MeasureTheory.Integrable (fun a => L (φ a)) μ) (MeasureTheory.Integrable φ μ)","decl":"@[simp]\ntheorem LinearIsometryEquiv.integrable_comp_iff {φ : α → H} (L : H ≃ₗᵢ[𝕜] E) :\n    Integrable (fun a : α ↦ L (φ a)) μ ↔ Integrable φ μ :=\n  ContinuousLinearEquiv.integrable_comp_iff (L : H ≃L[𝕜] E)\n\n"}
{"name":"MeasureTheory.Integrable.apply_continuousLinearMap","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\ninst✝⁴ : NormedAddCommGroup E\n𝕜 : Type u_7\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedSpace 𝕜 E\nH : Type u_8\ninst✝¹ : NormedAddCommGroup H\ninst✝ : NormedSpace 𝕜 H\nφ : α → ContinuousLinearMap (RingHom.id 𝕜) H E\nφ_int : MeasureTheory.Integrable φ μ\nv : H\n⊢ MeasureTheory.Integrable (fun a => (φ a) v) μ","decl":"theorem MeasureTheory.Integrable.apply_continuousLinearMap {φ : α → H →L[𝕜] E}\n    (φ_int : Integrable φ μ) (v : H) : Integrable (fun a => φ a v) μ :=\n  (ContinuousLinearMap.apply 𝕜 _ v).integrable_comp φ_int\n\n"}
{"name":"MeasureTheory.Integrable.fst","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\nF : Type u_7\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : α → Prod E F\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => (f x).1) μ","decl":"@[fun_prop]\nlemma Integrable.fst {f : α → E × F} (hf : Integrable f μ) : Integrable (fun x ↦ (f x).1) μ :=\n  (ContinuousLinearMap.fst ℝ E F).integrable_comp hf\n\n"}
{"name":"MeasureTheory.Integrable.snd","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\nF : Type u_7\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : α → Prod E F\nhf : MeasureTheory.Integrable f μ\n⊢ MeasureTheory.Integrable (fun x => (f x).2) μ","decl":"@[fun_prop]\nlemma Integrable.snd {f : α → E × F} (hf : Integrable f μ) : Integrable (fun x ↦ (f x).2) μ :=\n  (ContinuousLinearMap.snd ℝ E F).integrable_comp hf\n\n"}
{"name":"MeasureTheory.integrable_prod","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\nE : Type u_6\nF : Type u_7\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace Real E\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace Real F\nf : α → Prod E F\n⊢ Iff (MeasureTheory.Integrable f μ) (And (MeasureTheory.Integrable (fun x => (f x).1) μ) (MeasureTheory.Integrable (fun x => (f x).2) μ))","decl":"lemma integrable_prod {f : α → E × F} :\n    Integrable f μ ↔ Integrable (fun x ↦ (f x).1) μ ∧ Integrable (fun x ↦ (f x).2) μ :=\n  ⟨fun h ↦ ⟨h.fst, h.snd⟩, fun h ↦ h.1.prod_mk h.2⟩\n\n"}
