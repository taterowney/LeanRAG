{"name":"MeasureTheory.memâ„’p_one_iff_integrable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Memâ„’p f 1 Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem memâ„’p_one_iff_integrable {f : Î± â†’ Î²} : Memâ„’p f 1 Î¼ â†” Integrable f Î¼ := by\n  simp_rw [Integrable, hasFiniteIntegral_iff_enorm, Memâ„’p, eLpNorm_one_eq_lintegral_enorm]\n\n"}
{"name":"MeasureTheory.Integrable.aestronglyMeasurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.AEStronglyMeasurable f Î¼","decl":"theorem Integrable.aestronglyMeasurable {f : Î± â†’ Î²} (hf : Integrable f Î¼) :\n    AEStronglyMeasurable f Î¼ :=\n  hf.1\n\n"}
{"name":"MeasureTheory.Integrable.aemeasurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ AEMeasurable f Î¼","decl":"theorem Integrable.aemeasurable [MeasurableSpace Î²] [BorelSpace Î²] {f : Î± â†’ Î²}\n    (hf : Integrable f Î¼) : AEMeasurable f Î¼ :=\n  hf.aestronglyMeasurable.aemeasurable\n\n"}
{"name":"MeasureTheory.Integrable.hasFiniteIntegral","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral f Î¼","decl":"theorem Integrable.hasFiniteIntegral {f : Î± â†’ Î²} (hf : Integrable f Î¼) : HasFiniteIntegral f Î¼ :=\n  hf.2\n\n"}
{"name":"MeasureTheory.Integrable.mono","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhg : MeasureTheory.Integrable g Î¼\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem Integrable.mono {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hg : Integrable g Î¼)\n    (hf : AEStronglyMeasurable f Î¼) (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– â‰¤ â€–g aâ€–) : Integrable f Î¼ :=\n  âŸ¨hf, hg.hasFiniteIntegral.mono hâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.mono'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\ng : Î± â†’ Real\nhg : MeasureTheory.Integrable g Î¼\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nh : Filter.Eventually (fun a => LE.le (Norm.norm (f a)) (g a)) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem Integrable.mono' {f : Î± â†’ Î²} {g : Î± â†’ â„} (hg : Integrable g Î¼)\n    (hf : AEStronglyMeasurable f Î¼) (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– â‰¤ g a) : Integrable f Î¼ :=\n  âŸ¨hf, hg.hasFiniteIntegral.mono' hâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.congr'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.Integrable g Î¼","decl":"theorem Integrable.congr' {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : Integrable f Î¼)\n    (hg : AEStronglyMeasurable g Î¼) (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– = â€–g aâ€–) : Integrable g Î¼ :=\n  âŸ¨hg, hf.hasFiniteIntegral.congr' hâŸ©\n\n"}
{"name":"MeasureTheory.integrable_congr'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhg : MeasureTheory.AEStronglyMeasurable g Î¼\nh : Filter.Eventually (fun a => Eq (Norm.norm (f a)) (Norm.norm (g a))) (MeasureTheory.ae Î¼)\nâŠ¢ Iff (MeasureTheory.Integrable f Î¼) (MeasureTheory.Integrable g Î¼)","decl":"theorem integrable_congr' {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : AEStronglyMeasurable f Î¼)\n    (hg : AEStronglyMeasurable g Î¼) (h : âˆ€áµ a âˆ‚Î¼, â€–f aâ€– = â€–g aâ€–) :\n    Integrable f Î¼ â†” Integrable g Î¼ :=\n  âŸ¨fun h2f => h2f.congr' hg h, fun h2g => h2g.congr' hf <| EventuallyEq.symm hâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.congr","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ MeasureTheory.Integrable g Î¼","decl":"theorem Integrable.congr {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (h : f =áµ[Î¼] g) : Integrable g Î¼ :=\n  âŸ¨hf.1.congr h, hf.2.congr hâŸ©\n\n"}
{"name":"MeasureTheory.integrable_congr","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nh : (MeasureTheory.ae Î¼).EventuallyEq f g\nâŠ¢ Iff (MeasureTheory.Integrable f Î¼) (MeasureTheory.Integrable g Î¼)","decl":"theorem integrable_congr {f g : Î± â†’ Î²} (h : f =áµ[Î¼] g) : Integrable f Î¼ â†” Integrable g Î¼ :=\n  âŸ¨fun hf => hf.congr h, fun hg => hg.congr h.symmâŸ©\n\n"}
{"name":"MeasureTheory.integrable_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nc : Î²\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => c) Î¼) (Or (Eq c 0) (MeasureTheory.IsFiniteMeasure Î¼))","decl":"lemma integrable_const_iff {c : Î²} : Integrable (fun _ : Î± => c) Î¼ â†” c = 0 âˆ¨ IsFiniteMeasure Î¼ := by\n  have : AEStronglyMeasurable (fun _ : Î± => c) Î¼ := aestronglyMeasurable_const\n  rw [Integrable, and_iff_right this, hasFiniteIntegral_const_iff]\n\n"}
{"name":"MeasureTheory.integrable_const_iff_isFiniteMeasure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nc : Î²\nhc : Ne c 0\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => c) Î¼) (MeasureTheory.IsFiniteMeasure Î¼)","decl":"lemma integrable_const_iff_isFiniteMeasure {c : Î²} (hc : c â‰  0) :\n    Integrable (fun _ â†¦ c) Î¼ â†” IsFiniteMeasure Î¼ := by\n  simp [integrable_const_iff, hc, isFiniteMeasure_iff]\n\n"}
{"name":"MeasureTheory.Integrable.of_mem_Icc","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\na b : Real\nX : Î± â†’ Real\nhX : AEMeasurable X Î¼\nh : Filter.Eventually (fun Ï‰ => Membership.mem (Set.Icc a b) (X Ï‰)) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.Integrable X Î¼","decl":"theorem Integrable.of_mem_Icc [IsFiniteMeasure Î¼] (a b : â„) {X : Î± â†’ â„} (hX : AEMeasurable X Î¼)\n    (h : âˆ€áµ Ï‰ âˆ‚Î¼, X Ï‰ âˆˆ Set.Icc a b) :\n    Integrable X Î¼ :=\n  âŸ¨hX.aestronglyMeasurable, .of_mem_Icc a b hâŸ©\n\n"}
{"name":"MeasureTheory.integrable_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nc : Î²\nâŠ¢ MeasureTheory.Integrable (fun x => c) Î¼","decl":"@[simp, fun_prop]\ntheorem integrable_const [IsFiniteMeasure Î¼] (c : Î²) : Integrable (fun _ : Î± => c) Î¼ :=\n  integrable_const_iff.2 <| .inr â€¹_â€º\n\n"}
{"name":"MeasureTheory.Integrable.of_finite","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\ninstâœÂ² : Finite Î±\ninstâœÂ¹ : MeasurableSingletonClass Î±\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"@[simp]\nlemma Integrable.of_finite [Finite Î±] [MeasurableSingletonClass Î±] [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} :\n    Integrable f Î¼ := âŸ¨.of_finite, .of_finiteâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.of_isEmpty","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : IsEmpty Î±\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"/-- This lemma is a special case of `Integrable.of_finite`. -/\n-- Eternal deprecation for discoverability, don't remove\n@[deprecated Integrable.of_finite (since := \"2024-10-05\"), nolint deprecatedNoSince]\nlemma Integrable.of_isEmpty [IsEmpty Î±] {f : Î± â†’ Î²} : Integrable f Î¼ := .of_finite\n\n"}
{"name":"MeasureTheory.Memâ„’p.integrable_norm_rpow","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.Memâ„’p f p Î¼\nhp_ne_zero : Ne p 0\nhp_ne_top : Ne p Top.top\nâŠ¢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) Î¼","decl":"theorem Memâ„’p.integrable_norm_rpow {f : Î± â†’ Î²} {p : â„â‰¥0âˆ} (hf : Memâ„’p f p Î¼) (hp_ne_zero : p â‰  0)\n    (hp_ne_top : p â‰  âˆ) : Integrable (fun x : Î± => â€–f xâ€– ^ p.toReal) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable]\n  exact hf.norm_rpow hp_ne_zero hp_ne_top\n\n"}
{"name":"MeasureTheory.Memâ„’p.integrable_norm_rpow'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.Memâ„’p f p Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) Î¼","decl":"theorem Memâ„’p.integrable_norm_rpow' [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} {p : â„â‰¥0âˆ} (hf : Memâ„’p f p Î¼) :\n    Integrable (fun x : Î± => â€–f xâ€– ^ p.toReal) Î¼ := by\n  by_cases h_zero : p = 0\n  Â· simp [h_zero, integrable_const]\n  by_cases h_top : p = âˆ\n  Â· simp [h_top, integrable_const]\n  exact hf.integrable_norm_rpow h_zero h_top\n\n"}
{"name":"MeasureTheory.Memâ„’p.integrable_norm_pow","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\np : Nat\nhf : MeasureTheory.Memâ„’p f (â†‘p) Î¼\nhp : Ne p 0\nâŠ¢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p) Î¼","decl":"lemma Memâ„’p.integrable_norm_pow {f : Î± â†’ Î²} {p : â„•} (hf : Memâ„’p f p Î¼) (hp : p â‰  0) :\n    Integrable (fun x : Î± => â€–f xâ€– ^ p) Î¼ := by\n  simpa using hf.integrable_norm_rpow (mod_cast hp) (by simp)\n\n"}
{"name":"MeasureTheory.Memâ„’p.integrable_norm_pow'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\np : Nat\nhf : MeasureTheory.Memâ„’p f (â†‘p) Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p) Î¼","decl":"lemma Memâ„’p.integrable_norm_pow' [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} {p : â„•} (hf : Memâ„’p f p Î¼) :\n    Integrable (fun x : Î± => â€–f xâ€– ^ p) Î¼ := by simpa using hf.integrable_norm_rpow'\n\n"}
{"name":"MeasureTheory.integrable_norm_rpow_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\np : ENNReal\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\np_zero : Ne p 0\np_top : Ne p Top.top\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HPow.hPow (Norm.norm (f x)) p.toReal) Î¼) (MeasureTheory.Memâ„’p f p Î¼)","decl":"lemma integrable_norm_rpow_iff {f : Î± â†’ Î²} {p : â„â‰¥0âˆ}\n    (hf : AEStronglyMeasurable f Î¼) (p_zero : p â‰  0) (p_top : p â‰  âˆ) :\n    Integrable (fun x : Î± => â€–f xâ€– ^ p.toReal) Î¼ â†” Memâ„’p f p Î¼ := by\n  rw [â† memâ„’p_norm_rpow_iff (q := p) hf p_zero p_top, â† memâ„’p_one_iff_integrable,\n    ENNReal.div_self p_zero p_top]\n\n"}
{"name":"MeasureTheory.Integrable.mono_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.Integrable f Î½\nhÎ¼ : LE.le Î¼ Î½\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem Integrable.mono_measure {f : Î± â†’ Î²} (h : Integrable f Î½) (hÎ¼ : Î¼ â‰¤ Î½) : Integrable f Î¼ :=\n  âŸ¨h.aestronglyMeasurable.mono_measure hÎ¼, h.hasFiniteIntegral.mono_measure hÎ¼âŸ©\n\n"}
{"name":"MeasureTheory.Integrable.of_measure_le_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nÎ¼' : MeasureTheory.Measure Î±\nc : ENNReal\nhc : Ne c Top.top\nhÎ¼'_le : LE.le Î¼' (HSMul.hSMul c Î¼)\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable f Î¼'","decl":"theorem Integrable.of_measure_le_smul {Î¼' : Measure Î±} (c : â„â‰¥0âˆ) (hc : c â‰  âˆ) (hÎ¼'_le : Î¼' â‰¤ c â€¢ Î¼)\n    {f : Î± â†’ Î²} (hf : Integrable f Î¼) : Integrable f Î¼' := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢\n  exact hf.of_measure_le_smul c hc hÎ¼'_le\n\n"}
{"name":"MeasureTheory.Integrable.add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhÎ¼ : MeasureTheory.Integrable f Î¼\nhÎ½ : MeasureTheory.Integrable f Î½\nâŠ¢ MeasureTheory.Integrable f (HAdd.hAdd Î¼ Î½)","decl":"@[fun_prop]\ntheorem Integrable.add_measure {f : Î± â†’ Î²} (hÎ¼ : Integrable f Î¼) (hÎ½ : Integrable f Î½) :\n    Integrable f (Î¼ + Î½) := by\n  simp_rw [â† memâ„’p_one_iff_integrable] at hÎ¼ hÎ½ âŠ¢\n  refine âŸ¨hÎ¼.aestronglyMeasurable.add_measure hÎ½.aestronglyMeasurable, ?_âŸ©\n  rw [eLpNorm_one_add_measure, ENNReal.add_lt_top]\n  exact âŸ¨hÎ¼.eLpNorm_lt_top, hÎ½.eLpNorm_lt_topâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.left_of_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.Integrable f (HAdd.hAdd Î¼ Î½)\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem Integrable.left_of_add_measure {f : Î± â†’ Î²} (h : Integrable f (Î¼ + Î½)) : Integrable f Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at h âŠ¢\n  exact h.left_of_add_measure\n\n"}
{"name":"MeasureTheory.Integrable.right_of_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.Integrable f (HAdd.hAdd Î¼ Î½)\nâŠ¢ MeasureTheory.Integrable f Î½","decl":"theorem Integrable.right_of_add_measure {f : Î± â†’ Î²} (h : Integrable f (Î¼ + Î½)) :\n    Integrable f Î½ := by\n  rw [â† memâ„’p_one_iff_integrable] at h âŠ¢\n  exact h.right_of_add_measure\n\n"}
{"name":"MeasureTheory.integrable_add_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ Î½ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable f (HAdd.hAdd Î¼ Î½)) (And (MeasureTheory.Integrable f Î¼) (MeasureTheory.Integrable f Î½))","decl":"@[simp]\ntheorem integrable_add_measure {f : Î± â†’ Î²} :\n    Integrable f (Î¼ + Î½) â†” Integrable f Î¼ âˆ§ Integrable f Î½ :=\n  âŸ¨fun h => âŸ¨h.left_of_add_measure, h.right_of_add_measureâŸ©, fun h => h.1.add_measure h.2âŸ©\n\n"}
{"name":"MeasureTheory.integrable_zero_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : NormedAddCommGroup Î²\nxâœ : MeasurableSpace Î±\nf : Î± â†’ Î²\nâŠ¢ MeasureTheory.Integrable f 0","decl":"@[simp]\ntheorem integrable_zero_measure {_ : MeasurableSpace Î±} {f : Î± â†’ Î²} :\n    Integrable f (0 : Measure Î±) :=\n  âŸ¨aestronglyMeasurable_zero_measure f, hasFiniteIntegral_zero_measure fâŸ©\n\n"}
{"name":"MeasureTheory.integrable_finset_sum_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\ninstâœ : NormedAddCommGroup Î²\nÎ¹ : Type u_6\nm : MeasurableSpace Î±\nf : Î± â†’ Î²\nÎ¼ : Î¹ â†’ MeasureTheory.Measure Î±\ns : Finset Î¹\nâŠ¢ Iff (MeasureTheory.Integrable f (s.sum fun i => Î¼ i)) (âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable f (Î¼ i))","decl":"theorem integrable_finset_sum_measure {Î¹} {m : MeasurableSpace Î±} {f : Î± â†’ Î²} {Î¼ : Î¹ â†’ Measure Î±}\n    {s : Finset Î¹} : Integrable f (âˆ‘ i âˆˆ s, Î¼ i) â†” âˆ€ i âˆˆ s, Integrable f (Î¼ i) := by\n  classical\n  induction s using Finset.induction_on <;> simp [*]\n\n"}
{"name":"MeasureTheory.Integrable.smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.Integrable f Î¼\nc : ENNReal\nhc : Ne c Top.top\nâŠ¢ MeasureTheory.Integrable f (HSMul.hSMul c Î¼)","decl":"theorem Integrable.smul_measure {f : Î± â†’ Î²} (h : Integrable f Î¼) {c : â„â‰¥0âˆ} (hc : c â‰  âˆ) :\n    Integrable f (c â€¢ Î¼) := by\n  rw [â† memâ„’p_one_iff_integrable] at h âŠ¢\n  exact h.smul_measure hc\n\n"}
{"name":"MeasureTheory.Integrable.smul_measure_nnreal","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.Integrable f Î¼\nc : NNReal\nâŠ¢ MeasureTheory.Integrable f (HSMul.hSMul c Î¼)","decl":"@[fun_prop]\ntheorem Integrable.smul_measure_nnreal {f : Î± â†’ Î²} (h : Integrable f Î¼) {c : â„â‰¥0} :\n    Integrable f (c â€¢ Î¼) := by\n  apply h.smul_measure\n  simp\n\n"}
{"name":"MeasureTheory.integrable_smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nc : ENNReal\nhâ‚ : Ne c 0\nhâ‚‚ : Ne c Top.top\nâŠ¢ Iff (MeasureTheory.Integrable f (HSMul.hSMul c Î¼)) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_smul_measure {f : Î± â†’ Î²} {c : â„â‰¥0âˆ} (hâ‚ : c â‰  0) (hâ‚‚ : c â‰  âˆ) :\n    Integrable f (c â€¢ Î¼) â†” Integrable f Î¼ :=\n  âŸ¨fun h => by\n    simpa only [smul_smul, ENNReal.inv_mul_cancel hâ‚ hâ‚‚, one_smul] using\n      h.smul_measure (ENNReal.inv_ne_top.2 hâ‚),\n    fun h => h.smul_measure hâ‚‚âŸ©\n\n"}
{"name":"MeasureTheory.integrable_inv_smul_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nc : ENNReal\nhâ‚ : Ne c 0\nhâ‚‚ : Ne c Top.top\nâŠ¢ Iff (MeasureTheory.Integrable f (HSMul.hSMul (Inv.inv c) Î¼)) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_inv_smul_measure {f : Î± â†’ Î²} {c : â„â‰¥0âˆ} (hâ‚ : c â‰  0) (hâ‚‚ : c â‰  âˆ) :\n    Integrable f (câ»Â¹ â€¢ Î¼) â†” Integrable f Î¼ :=\n  integrable_smul_measure (by simpa using hâ‚‚) (by simpa using hâ‚)\n\n"}
{"name":"MeasureTheory.Integrable.to_average","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nh : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable f (HSMul.hSMul (Inv.inv (Î¼ Set.univ)) Î¼)","decl":"theorem Integrable.to_average {f : Î± â†’ Î²} (h : Integrable f Î¼) : Integrable f ((Î¼ univ)â»Â¹ â€¢ Î¼) := by\n  rcases eq_or_ne Î¼ 0 with (rfl | hne)\n  Â· rwa [smul_zero]\n  Â· apply h.smul_measure\n    simpa\n\n"}
{"name":"MeasureTheory.integrable_average","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable f (HSMul.hSMul (Inv.inv (Î¼ Set.univ)) Î¼)) (MeasureTheory.Integrable f Î¼)","decl":"open scoped Classical in\ntheorem integrable_average [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} :\n    Integrable f ((Î¼ univ)â»Â¹ â€¢ Î¼) â†” Integrable f Î¼ :=\n  (eq_or_ne Î¼ 0).by_cases (fun h => by simp [h]) fun h =>\n    integrable_smul_measure (ENNReal.inv_ne_zero.2 <| measure_ne_top _ _)\n      (ENNReal.inv_ne_top.2 <| mt Measure.measure_univ_eq_zero.1 h)\n\n"}
{"name":"MeasureTheory.integrable_map_measure","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : MeasureTheory.AEStronglyMeasurable g (MeasureTheory.Measure.map f Î¼)\nhf : AEMeasurable f Î¼\nâŠ¢ Iff (MeasureTheory.Integrable g (MeasureTheory.Measure.map f Î¼)) (MeasureTheory.Integrable (Function.comp g f) Î¼)","decl":"theorem integrable_map_measure {f : Î± â†’ Î´} {g : Î´ â†’ Î²}\n    (hg : AEStronglyMeasurable g (Measure.map f Î¼)) (hf : AEMeasurable f Î¼) :\n    Integrable g (Measure.map f Î¼) â†” Integrable (g âˆ˜ f) Î¼ := by\n  simp_rw [â† memâ„’p_one_iff_integrable]\n  exact memâ„’p_map_measure_iff hg hf\n\n"}
{"name":"MeasureTheory.Integrable.comp_aemeasurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : MeasureTheory.Integrable g (MeasureTheory.Measure.map f Î¼)\nhf : AEMeasurable f Î¼\nâŠ¢ MeasureTheory.Integrable (Function.comp g f) Î¼","decl":"theorem Integrable.comp_aemeasurable {f : Î± â†’ Î´} {g : Î´ â†’ Î²} (hg : Integrable g (Measure.map f Î¼))\n    (hf : AEMeasurable f Î¼) : Integrable (g âˆ˜ f) Î¼ :=\n  (integrable_map_measure hg.aestronglyMeasurable hf).mp hg\n\n"}
{"name":"MeasureTheory.Integrable.comp_measurable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î´\ng : Î´ â†’ Î²\nhg : MeasureTheory.Integrable g (MeasureTheory.Measure.map f Î¼)\nhf : Measurable f\nâŠ¢ MeasureTheory.Integrable (Function.comp g f) Î¼","decl":"theorem Integrable.comp_measurable {f : Î± â†’ Î´} {g : Î´ â†’ Î²} (hg : Integrable g (Measure.map f Î¼))\n    (hf : Measurable f) : Integrable (g âˆ˜ f) Î¼ :=\n  hg.comp_aemeasurable hf.aemeasurable\n\n"}
{"name":"MeasurableEmbedding.integrable_map_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î´\nhf : MeasurableEmbedding f\ng : Î´ â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable g (MeasureTheory.Measure.map f Î¼)) (MeasureTheory.Integrable (Function.comp g f) Î¼)","decl":"theorem _root_.MeasurableEmbedding.integrable_map_iff {f : Î± â†’ Î´} (hf : MeasurableEmbedding f)\n    {g : Î´ â†’ Î²} : Integrable g (Measure.map f Î¼) â†” Integrable (g âˆ˜ f) Î¼ := by\n  simp_rw [â† memâ„’p_one_iff_integrable]\n  exact hf.memâ„’p_map_measure_iff\n\n"}
{"name":"MeasureTheory.integrable_map_equiv","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nf : MeasurableEquiv Î± Î´\ng : Î´ â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable g (MeasureTheory.Measure.map (â‡‘f) Î¼)) (MeasureTheory.Integrable (Function.comp g â‡‘f) Î¼)","decl":"theorem integrable_map_equiv (f : Î± â‰ƒáµ Î´) (g : Î´ â†’ Î²) :\n    Integrable g (Measure.map f Î¼) â†” Integrable (g âˆ˜ f) Î¼ := by\n  simp_rw [â† memâ„’p_one_iff_integrable]\n  exact f.memâ„’p_map_measure_iff\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integrable_comp","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nÎ½ : MeasureTheory.Measure Î´\ng : Î´ â†’ Î²\nf : Î± â†’ Î´\nhf : MeasureTheory.MeasurePreserving f Î¼ Î½\nhg : MeasureTheory.AEStronglyMeasurable g Î½\nâŠ¢ Iff (MeasureTheory.Integrable (Function.comp g f) Î¼) (MeasureTheory.Integrable g Î½)","decl":"theorem MeasurePreserving.integrable_comp {Î½ : Measure Î´} {g : Î´ â†’ Î²} {f : Î± â†’ Î´}\n    (hf : MeasurePreserving f Î¼ Î½) (hg : AEStronglyMeasurable g Î½) :\n    Integrable (g âˆ˜ f) Î¼ â†” Integrable g Î½ := by\n  rw [â† hf.map_eq] at hg âŠ¢\n  exact (integrable_map_measure hg hf.measurable.aemeasurable).symm\n\n"}
{"name":"MeasureTheory.MeasurePreserving.integrable_comp_emb","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ´ : Type u_4\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : MeasurableSpace Î´\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î´\nÎ½ : MeasureTheory.Measure Î´\nhâ‚ : MeasureTheory.MeasurePreserving f Î¼ Î½\nhâ‚‚ : MeasurableEmbedding f\ng : Î´ â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable (Function.comp g f) Î¼) (MeasureTheory.Integrable g Î½)","decl":"theorem MeasurePreserving.integrable_comp_emb {f : Î± â†’ Î´} {Î½} (hâ‚ : MeasurePreserving f Î¼ Î½)\n    (hâ‚‚ : MeasurableEmbedding f) {g : Î´ â†’ Î²} : Integrable (g âˆ˜ f) Î¼ â†” Integrable g Î½ :=\n  hâ‚.map_eq â–¸ Iff.symm hâ‚‚.integrable_map_iff\n\n"}
{"name":"MeasureTheory.lintegral_edist_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ LT.lt (MeasureTheory.lintegral Î¼ fun a => EDist.edist (f a) (g a)) Top.top","decl":"theorem lintegral_edist_lt_top {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    (âˆ«â» a, edist (f a) (g a) âˆ‚Î¼) < âˆ :=\n  lt_of_le_of_lt (lintegral_edist_triangle hf.aestronglyMeasurable aestronglyMeasurable_zero)\n    (ENNReal.add_lt_top.2 <| by\n      simp_rw [Pi.zero_apply, â† hasFiniteIntegral_iff_edist]\n      exact âŸ¨hf.hasFiniteIntegral, hg.hasFiniteIntegralâŸ©)\n\n"}
{"name":"MeasureTheory.integrable_zero","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nâŠ¢ MeasureTheory.Integrable (fun x => 0) Î¼","decl":"@[simp]\ntheorem integrable_zero : Integrable (fun _ => (0 : Î²)) Î¼ := by\n  simp [Integrable, aestronglyMeasurable_const]\n\n"}
{"name":"MeasureTheory.Integrable.add'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.HasFiniteIntegral (HAdd.hAdd f g) Î¼","decl":"theorem Integrable.add' {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    HasFiniteIntegral (f + g) Î¼ :=\n  calc\n    âˆ«â» a, â€–f a + g aâ€–â‚‘ âˆ‚Î¼ â‰¤ âˆ«â» a, â€–f aâ€–â‚‘ + â€–g aâ€–â‚‘ âˆ‚Î¼ := lintegral_mono fun _ â†¦ enorm_add_le _ _\n    _ = _ := lintegral_enorm_add_left hf.aestronglyMeasurable _\n    _ < âˆ := add_lt_top.2 âŸ¨hf.hasFiniteIntegral, hg.hasFiniteIntegralâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.add","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (HAdd.hAdd f g) Î¼","decl":"@[fun_prop]\ntheorem Integrable.add {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    Integrable (f + g) Î¼ :=\n  âŸ¨hf.aestronglyMeasurable.add hg.aestronglyMeasurable, hf.add' hgâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.add''","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => HAdd.hAdd (f x) (g x)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.add'' {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    Integrable (fun x â†¦ f x + g x) Î¼ := hf.add hg\n\n"}
{"name":"MeasureTheory.integrable_finset_sum'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nÎ¹ : Type u_6\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ Î²\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nâŠ¢ MeasureTheory.Integrable (s.sum fun i => f i) Î¼","decl":"@[fun_prop]\ntheorem integrable_finset_sum' {Î¹} (s : Finset Î¹) {f : Î¹ â†’ Î± â†’ Î²}\n    (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) : Integrable (âˆ‘ i âˆˆ s, f i) Î¼ :=\n  Finset.sum_induction f (fun g => Integrable g Î¼) (fun _ _ => Integrable.add)\n    (integrable_zero _ _ _) hf\n\n"}
{"name":"MeasureTheory.integrable_finset_sum","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nÎ¹ : Type u_6\ns : Finset Î¹\nf : Î¹ â†’ Î± â†’ Î²\nhf : âˆ€ (i : Î¹), Membership.mem s i â†’ MeasureTheory.Integrable (f i) Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => s.sum fun i => f i a) Î¼","decl":"@[fun_prop]\ntheorem integrable_finset_sum {Î¹} (s : Finset Î¹) {f : Î¹ â†’ Î± â†’ Î²}\n    (hf : âˆ€ i âˆˆ s, Integrable (f i) Î¼) : Integrable (fun a => âˆ‘ i âˆˆ s, f i a) Î¼ := by\n  simpa only [â† Finset.sum_apply] using integrable_finset_sum' s hf\n\n"}
{"name":"MeasureTheory.Integrable.neg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (Neg.neg f) Î¼","decl":"/-- If `f` is integrable, then so is `-f`.\nSee `Integrable.neg'` for the same statement, but formulated with `x â†¦ - f x` instead of `-f`. -/\n@[fun_prop]\ntheorem Integrable.neg {f : Î± â†’ Î²} (hf : Integrable f Î¼) : Integrable (-f) Î¼ :=\n  âŸ¨hf.aestronglyMeasurable.neg, hf.hasFiniteIntegral.negâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.neg'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => Neg.neg (f x)) Î¼","decl":"/-- If `f` is integrable, then so is `fun x â†¦ - f x`.\nSee `Integrable.neg` for the same statement, but formulated with `-f` instead of `fun x â†¦ - f x`. -/\n@[fun_prop]\ntheorem Integrable.neg' {f : Î± â†’ Î²} (hf : Integrable f Î¼) : Integrable (fun x â†¦ - f x) Î¼ :=\n  âŸ¨hf.aestronglyMeasurable.neg, hf.hasFiniteIntegral.negâŸ©\n\n"}
{"name":"MeasureTheory.integrable_neg_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable (Neg.neg f) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"@[simp]\ntheorem integrable_neg_iff {f : Î± â†’ Î²} : Integrable (-f) Î¼ â†” Integrable f Î¼ :=\n  âŸ¨fun h => neg_neg f â–¸ h.neg, Integrable.negâŸ©\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_right","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (MeasureTheory.Integrable (HAdd.hAdd f g) Î¼) (MeasureTheory.Integrable g Î¼)","decl":"/-- if `f` is integrable, then `f + g` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_right'` for the same statement with `fun x â†¦ f x + g x` instead\nof `f + g`. -/\n@[simp]\nlemma integrable_add_iff_integrable_right {f g : Î± â†’ Î²} (hf : Integrable f Î¼) :\n    Integrable (f + g) Î¼ â†” Integrable g Î¼ :=\n  âŸ¨fun h â†¦ show g = f + g + (-f) by simp only [add_neg_cancel_comm] â–¸ h.add hf.neg,\n    fun h â†¦ hf.add hâŸ©\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_right'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd (f x) (g x)) Î¼) (MeasureTheory.Integrable g Î¼)","decl":"/-- if `f` is integrable, then `fun x â†¦ f x + g x` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_right` for the same statement with `f + g` instead\nof `fun x â†¦ f x + g x`. -/\n@[simp]\nlemma integrable_add_iff_integrable_right' {f g : Î± â†’ Î²} (hf : Integrable f Î¼) :\n    Integrable (fun x â†¦ f x + g x) Î¼ â†” Integrable g Î¼ :=\n  integrable_add_iff_integrable_right hf\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_left","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (MeasureTheory.Integrable (HAdd.hAdd g f) Î¼) (MeasureTheory.Integrable g Î¼)","decl":"/-- if `f` is integrable, then `g + f` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_left'` for the same statement with `fun x â†¦ g x + f x` instead\nof `g + f`. -/\n@[simp]\nlemma integrable_add_iff_integrable_left {f g : Î± â†’ Î²} (hf : Integrable f Î¼) :\n    Integrable (g + f) Î¼ â†” Integrable g Î¼ := by\n  rw [add_comm, integrable_add_iff_integrable_right hf]\n\n"}
{"name":"MeasureTheory.integrable_add_iff_integrable_left'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd (g x) (f x)) Î¼) (MeasureTheory.Integrable g Î¼)","decl":"/-- if `f` is integrable, then `fun x â†¦ g x + f x` is integrable iff `g` is.\nSee `integrable_add_iff_integrable_left'` for the same statement with `g + f` instead\nof `fun x â†¦ g x + f x`. -/\n@[simp]\nlemma integrable_add_iff_integrable_left' {f g : Î± â†’ Î²} (hf : Integrable f Î¼) :\n    Integrable (fun x â†¦ g x + f x) Î¼ â†” Integrable g Î¼ :=\n  integrable_add_iff_integrable_left hf\n\n"}
{"name":"MeasureTheory.integrable_left_of_integrable_add_of_nonneg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nh_meas : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhg : (MeasureTheory.ae Î¼).EventuallyLE 0 g\nh_int : MeasureTheory.Integrable (HAdd.hAdd f g) Î¼\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"lemma integrable_left_of_integrable_add_of_nonneg {f g : Î± â†’ â„}\n    (h_meas : AEStronglyMeasurable f Î¼) (hf : 0 â‰¤áµ[Î¼] f) (hg : 0 â‰¤áµ[Î¼] g)\n    (h_int : Integrable (f + g) Î¼) : Integrable f Î¼ := by\n  refine h_int.mono' h_meas ?_\n  filter_upwards [hf, hg] with a haf hag\n  exact (Real.norm_of_nonneg haf).symm â–¸ le_add_of_nonneg_right hag\n\n"}
{"name":"MeasureTheory.integrable_right_of_integrable_add_of_nonneg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nh_meas : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhg : (MeasureTheory.ae Î¼).EventuallyLE 0 g\nh_int : MeasureTheory.Integrable (HAdd.hAdd f g) Î¼\nâŠ¢ MeasureTheory.Integrable g Î¼","decl":"lemma integrable_right_of_integrable_add_of_nonneg {f g : Î± â†’ â„}\n    (h_meas : AEStronglyMeasurable f Î¼) (hf : 0 â‰¤áµ[Î¼] f) (hg : 0 â‰¤áµ[Î¼] g)\n    (h_int : Integrable (f + g) Î¼) : Integrable g Î¼ :=\n  integrable_left_of_integrable_add_of_nonneg\n    ((AEStronglyMeasurable.add_iff_right h_meas).mp h_int.aestronglyMeasurable)\n      hg hf (add_comm f g â–¸ h_int)\n\n"}
{"name":"MeasureTheory.integrable_add_iff_of_nonneg","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nh_meas : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nhg : (MeasureTheory.ae Î¼).EventuallyLE 0 g\nâŠ¢ Iff (MeasureTheory.Integrable (HAdd.hAdd f g) Î¼) (And (MeasureTheory.Integrable f Î¼) (MeasureTheory.Integrable g Î¼))","decl":"lemma integrable_add_iff_of_nonneg {f g : Î± â†’ â„} (h_meas : AEStronglyMeasurable f Î¼)\n    (hf : 0 â‰¤áµ[Î¼] f) (hg : 0 â‰¤áµ[Î¼] g) :\n    Integrable (f + g) Î¼ â†” Integrable f Î¼ âˆ§ Integrable g Î¼ :=\n  âŸ¨fun h â†¦ âŸ¨integrable_left_of_integrable_add_of_nonneg h_meas hf hg h,\n    integrable_right_of_integrable_add_of_nonneg h_meas hf hg hâŸ©, fun âŸ¨hf, hgâŸ© â†¦ hf.add hgâŸ©\n\n"}
{"name":"MeasureTheory.integrable_add_iff_of_nonpos","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf g : Î± â†’ Real\nh_meas : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : (MeasureTheory.ae Î¼).EventuallyLE f 0\nhg : (MeasureTheory.ae Î¼).EventuallyLE g 0\nâŠ¢ Iff (MeasureTheory.Integrable (HAdd.hAdd f g) Î¼) (And (MeasureTheory.Integrable f Î¼) (MeasureTheory.Integrable g Î¼))","decl":"lemma integrable_add_iff_of_nonpos {f g : Î± â†’ â„} (h_meas : AEStronglyMeasurable f Î¼)\n    (hf : f â‰¤áµ[Î¼] 0) (hg : g â‰¤áµ[Î¼] 0) :\n    Integrable (f + g) Î¼ â†” Integrable f Î¼ âˆ§ Integrable g Î¼ := by\n  rw [â† integrable_neg_iff, â† integrable_neg_iff (f := f), â† integrable_neg_iff (f := g), neg_add]\n  exact integrable_add_iff_of_nonneg h_meas.neg (hf.mono (fun _ â†¦ neg_nonneg_of_nonpos))\n    (hg.mono (fun _ â†¦ neg_nonneg_of_nonpos))\n\n"}
{"name":"MeasureTheory.integrable_add_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\nc : Î²\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd (f x) c) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"lemma integrable_add_const_iff [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} {c : Î²} :\n    Integrable (fun x â†¦ f x + c) Î¼ â†” Integrable f Î¼ :=\n  integrable_add_iff_integrable_left (integrable_const _)\n\n"}
{"name":"MeasureTheory.integrable_const_add_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nf : Î± â†’ Î²\nc : Î²\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HAdd.hAdd c (f x)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"lemma integrable_const_add_iff [IsFiniteMeasure Î¼] {f : Î± â†’ Î²} {c : Î²} :\n    Integrable (fun x â†¦ c + f x) Î¼ â†” Integrable f Î¼ :=\n  integrable_add_iff_integrable_right (integrable_const _)\n\n"}
{"name":"MeasureTheory.Integrable.sub","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (HSub.hSub f g) Î¼","decl":"@[fun_prop]\ntheorem Integrable.sub {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    Integrable (f - g) Î¼ := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"MeasureTheory.Integrable.sub'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => HSub.hSub (f a) (g a)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.sub' {f g : Î± â†’ Î²} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    Integrable (fun a â†¦ f a - g a) Î¼ := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"MeasureTheory.Integrable.norm","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => Norm.norm (f a)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.norm {f : Î± â†’ Î²} (hf : Integrable f Î¼) : Integrable (fun a => â€–f aâ€–) Î¼ :=\n  âŸ¨hf.aestronglyMeasurable.norm, hf.hasFiniteIntegral.normâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.inf","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_6\ninstâœ : NormedLatticeAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (Min.min f g) Î¼","decl":"@[fun_prop]\ntheorem Integrable.inf {Î²} [NormedLatticeAddCommGroup Î²] {f g : Î± â†’ Î²} (hf : Integrable f Î¼)\n    (hg : Integrable g Î¼) : Integrable (f âŠ“ g) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf hg âŠ¢\n  exact hf.inf hg\n\n"}
{"name":"MeasureTheory.Integrable.sup","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_6\ninstâœ : NormedLatticeAddCommGroup Î²\nf g : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (Max.max f g) Î¼","decl":"@[fun_prop]\ntheorem Integrable.sup {Î²} [NormedLatticeAddCommGroup Î²] {f g : Î± â†’ Î²} (hf : Integrable f Î¼)\n    (hg : Integrable g Î¼) : Integrable (f âŠ” g) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf hg âŠ¢\n  exact hf.sup hg\n\n"}
{"name":"MeasureTheory.Integrable.abs","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nÎ² : Type u_6\ninstâœ : NormedLatticeAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => abs (f a)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.abs {Î²} [NormedLatticeAddCommGroup Î²] {f : Î± â†’ Î²} (hf : Integrable f Î¼) :\n    Integrable (fun a => |f a|) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢\n  exact hf.abs\n\n"}
{"name":"MeasureTheory.Integrable.bdd_mul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nF : Type u_6\ninstâœ : NormedDivisionRing F\nf g : Î± â†’ F\nhint : MeasureTheory.Integrable g Î¼\nhm : MeasureTheory.AEStronglyMeasurable f Î¼\nhfbdd : Exists fun C => âˆ€ (x : Î±), LE.le (Norm.norm (f x)) C\nâŠ¢ MeasureTheory.Integrable (fun x => HMul.hMul (f x) (g x)) Î¼","decl":"theorem Integrable.bdd_mul {F : Type*} [NormedDivisionRing F] {f g : Î± â†’ F} (hint : Integrable g Î¼)\n    (hm : AEStronglyMeasurable f Î¼) (hfbdd : âˆƒ C, âˆ€ x, â€–f xâ€– â‰¤ C) :\n    Integrable (fun x => f x * g x) Î¼ := by\n  cases' isEmpty_or_nonempty Î± with hÎ± hÎ±\n  Â· rw [Î¼.eq_zero_of_isEmpty]\n    exact integrable_zero_measure\n  Â· refine âŸ¨hm.mul hint.1, ?_âŸ©\n    obtain âŸ¨C, hCâŸ© := hfbdd\n    have hCnonneg : 0 â‰¤ C := le_trans (norm_nonneg _) (hC hÎ±.some)\n    have : (fun x => â€–f x * g xâ€–â‚Š) â‰¤ fun x => âŸ¨C, hCnonnegâŸ© * â€–g xâ€–â‚Š := by\n      intro x\n      simp only [nnnorm_mul]\n      exact mul_le_mul_of_nonneg_right (hC x) (zero_le _)\n    refine lt_of_le_of_lt (lintegral_mono_nnreal this) ?_\n    simp only [ENNReal.coe_mul]\n    rw [lintegral_const_mul' _ _ ENNReal.coe_ne_top]\n    exact ENNReal.mul_lt_top ENNReal.coe_lt_top hint.2\n\n"}
{"name":"MeasureTheory.Integrable.essSup_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ² : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ¹ : NormedField ğ•œ\ninstâœ : NormedSpace ğ•œ Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\ng : Î± â†’ ğ•œ\ng_aestronglyMeasurable : MeasureTheory.AEStronglyMeasurable g Î¼\ness_sup_g : Ne (essSup (fun x => ENorm.enorm (g x)) Î¼) Top.top\nâŠ¢ MeasureTheory.Integrable (fun x => HSMul.hSMul (g x) (f x)) Î¼","decl":"/-- **HÃ¶lder's inequality for integrable functions**: the scalar multiplication of an integrable\nvector-valued function by a scalar function with finite essential supremum is integrable. -/\ntheorem Integrable.essSup_smul {ğ•œ : Type*} [NormedField ğ•œ] [NormedSpace ğ•œ Î²] {f : Î± â†’ Î²}\n    (hf : Integrable f Î¼) {g : Î± â†’ ğ•œ} (g_aestronglyMeasurable : AEStronglyMeasurable g Î¼)\n    (ess_sup_g : essSup (â€–g Â·â€–â‚‘) Î¼ â‰  âˆ) :\n    Integrable (fun x : Î± => g x â€¢ f x) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at *\n  refine âŸ¨g_aestronglyMeasurable.smul hf.1, ?_âŸ©\n  have h : (1 : â„â‰¥0âˆ) / 1 = 1 / âˆ + 1 / 1 := by norm_num\n  have hg' : eLpNorm g âˆ Î¼ â‰  âˆ := by rwa [eLpNorm_exponent_top]\n  calc\n    eLpNorm (fun x : Î± => g x â€¢ f x) 1 Î¼ â‰¤ _ := by\n      simpa using MeasureTheory.eLpNorm_smul_le_mul_eLpNorm hf.1 g_aestronglyMeasurable h\n    _ < âˆ := ENNReal.mul_lt_top hg'.lt_top hf.2\n\n"}
{"name":"MeasureTheory.Integrable.smul_essSup","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nf : Î± â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\ng : Î± â†’ Î²\ng_aestronglyMeasurable : MeasureTheory.AEStronglyMeasurable g Î¼\ness_sup_g : Ne (essSup (fun x => ENorm.enorm (g x)) Î¼) Top.top\nâŠ¢ MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) Î¼","decl":"/-- HÃ¶lder's inequality for integrable functions: the scalar multiplication of an integrable\nscalar-valued function by a vector-value function with finite essential supremum is integrable. -/\ntheorem Integrable.smul_essSup {ğ•œ : Type*} [NormedRing ğ•œ] [Module ğ•œ Î²] [BoundedSMul ğ•œ Î²]\n    {f : Î± â†’ ğ•œ} (hf : Integrable f Î¼) {g : Î± â†’ Î²}\n    (g_aestronglyMeasurable : AEStronglyMeasurable g Î¼) (ess_sup_g : essSup (â€–g Â·â€–â‚‘) Î¼ â‰  âˆ) :\n    Integrable (fun x : Î± => f x â€¢ g x) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at *\n  refine âŸ¨hf.1.smul g_aestronglyMeasurable, ?_âŸ©\n  have h : (1 : â„â‰¥0âˆ) / 1 = 1 / 1 + 1 / âˆ := by norm_num\n  have hg' : eLpNorm g âˆ Î¼ â‰  âˆ := by rwa [eLpNorm_exponent_top]\n  calc\n    eLpNorm (fun x : Î± => f x â€¢ g x) 1 Î¼ â‰¤ _ := by\n      simpa using MeasureTheory.eLpNorm_smul_le_mul_eLpNorm g_aestronglyMeasurable hf.1 h\n    _ < âˆ := ENNReal.mul_lt_top hf.2 hg'.lt_top\n\n"}
{"name":"MeasureTheory.integrable_norm_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nâŠ¢ Iff (MeasureTheory.Integrable (fun a => Norm.norm (f a)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_norm_iff {f : Î± â†’ Î²} (hf : AEStronglyMeasurable f Î¼) :\n    Integrable (fun a => â€–f aâ€–) Î¼ â†” Integrable f Î¼ := by\n  simp_rw [Integrable, and_iff_right hf, and_iff_right hf.norm, hasFiniteIntegral_norm_iff]\n\n"}
{"name":"MeasureTheory.integrable_of_norm_sub_le","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nfâ‚€ fâ‚ : Î± â†’ Î²\ng : Î± â†’ Real\nhfâ‚_m : MeasureTheory.AEStronglyMeasurable fâ‚ Î¼\nhfâ‚€_i : MeasureTheory.Integrable fâ‚€ Î¼\nhg_i : MeasureTheory.Integrable g Î¼\nh : Filter.Eventually (fun a => LE.le (Norm.norm (HSub.hSub (fâ‚€ a) (fâ‚ a))) (g a)) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.Integrable fâ‚ Î¼","decl":"theorem integrable_of_norm_sub_le {fâ‚€ fâ‚ : Î± â†’ Î²} {g : Î± â†’ â„} (hfâ‚_m : AEStronglyMeasurable fâ‚ Î¼)\n    (hfâ‚€_i : Integrable fâ‚€ Î¼) (hg_i : Integrable g Î¼) (h : âˆ€áµ a âˆ‚Î¼, â€–fâ‚€ a - fâ‚ aâ€– â‰¤ g a) :\n    Integrable fâ‚ Î¼ :=\n  haveI : âˆ€áµ a âˆ‚Î¼, â€–fâ‚ aâ€– â‰¤ â€–fâ‚€ aâ€– + g a := by\n    apply h.mono\n    intro a ha\n    calc\n      â€–fâ‚ aâ€– â‰¤ â€–fâ‚€ aâ€– + â€–fâ‚€ a - fâ‚ aâ€– := norm_le_insert _ _\n      _ â‰¤ â€–fâ‚€ aâ€– + g a := add_le_add_left ha _\n  Integrable.mono' (hfâ‚€_i.norm.add hg_i) hfâ‚_m this\n\n"}
{"name":"MeasureTheory.integrable_of_le_of_le","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf gâ‚ gâ‚‚ : Î± â†’ Real\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nh_leâ‚ : (MeasureTheory.ae Î¼).EventuallyLE gâ‚ f\nh_leâ‚‚ : (MeasureTheory.ae Î¼).EventuallyLE f gâ‚‚\nh_intâ‚ : MeasureTheory.Integrable gâ‚ Î¼\nh_intâ‚‚ : MeasureTheory.Integrable gâ‚‚ Î¼\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"lemma integrable_of_le_of_le {f gâ‚ gâ‚‚ : Î± â†’ â„} (hf : AEStronglyMeasurable f Î¼)\n    (h_leâ‚ : gâ‚ â‰¤áµ[Î¼] f) (h_leâ‚‚ : f â‰¤áµ[Î¼] gâ‚‚)\n    (h_intâ‚ : Integrable gâ‚ Î¼) (h_intâ‚‚ : Integrable gâ‚‚ Î¼) :\n    Integrable f Î¼ := by\n  have : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ max â€–gâ‚ xâ€– â€–gâ‚‚ xâ€– := by\n    filter_upwards [h_leâ‚, h_leâ‚‚] with x hx1 hx2\n    simp only [Real.norm_eq_abs]\n    exact abs_le_max_abs_abs hx1 hx2\n  have h_le_add : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ â€–â€–gâ‚ xâ€– + â€–gâ‚‚ xâ€–â€– := by\n    filter_upwards [this] with x hx\n    refine hx.trans ?_\n    conv_rhs => rw [Real.norm_of_nonneg (by positivity)]\n    exact max_le_add_of_nonneg (norm_nonneg _) (norm_nonneg _)\n  exact Integrable.mono (h_intâ‚.norm.add h_intâ‚‚.norm) hf h_le_add\n\n"}
{"name":"MeasureTheory.Integrable.prod_mk","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nf : Î± â†’ Î²\ng : Î± â†’ Î³\nhf : MeasureTheory.Integrable f Î¼\nhg : MeasureTheory.Integrable g Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => { fst := f x, snd := g x }) Î¼","decl":"@[fun_prop]\ntheorem Integrable.prod_mk {f : Î± â†’ Î²} {g : Î± â†’ Î³} (hf : Integrable f Î¼) (hg : Integrable g Î¼) :\n    Integrable (fun x => (f x, g x)) Î¼ :=\n  âŸ¨hf.aestronglyMeasurable.prod_mk hg.aestronglyMeasurable,\n    (hf.norm.add' hg.norm).mono <|\n      Eventually.of_forall fun x =>\n        calc\n          max â€–f xâ€– â€–g xâ€– â‰¤ â€–f xâ€– + â€–g xâ€– := max_le_add_of_nonneg (norm_nonneg _) (norm_nonneg _)\n          _ â‰¤ â€–â€–f xâ€– + â€–g xâ€–â€– := le_abs_self _âŸ©\n\n"}
{"name":"MeasureTheory.Memâ„’p.integrable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\nq : ENNReal\nhq1 : LE.le 1 q\nf : Î± â†’ Î²\ninstâœ : MeasureTheory.IsFiniteMeasure Î¼\nhfq : MeasureTheory.Memâ„’p f q Î¼\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem Memâ„’p.integrable {q : â„â‰¥0âˆ} (hq1 : 1 â‰¤ q) {f : Î± â†’ Î²} [IsFiniteMeasure Î¼]\n    (hfq : Memâ„’p f q Î¼) : Integrable f Î¼ :=\n  memâ„’p_one_iff_integrable.mp (hfq.mono_exponent hq1)\n\n"}
{"name":"MeasureTheory.Integrable.measure_norm_ge_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nâŠ¢ LT.lt (Î¼ (setOf fun x => LE.le Îµ (Norm.norm (f x)))) Top.top","decl":"/-- A non-quantitative version of Markov inequality for integrable functions: the measure of points\nwhere `â€–f xâ€– â‰¥ Îµ` is finite for all positive `Îµ`. -/\ntheorem Integrable.measure_norm_ge_lt_top {f : Î± â†’ Î²} (hf : Integrable f Î¼) {Îµ : â„} (hÎµ : 0 < Îµ) :\n    Î¼ { x | Îµ â‰¤ â€–f xâ€– } < âˆ := by\n  rw [show { x | Îµ â‰¤ â€–f xâ€– } = { x | .ofReal Îµ â‰¤ â€–f xâ€–â‚‘ } by\n      simp [ENNReal.ofReal, Real.toNNReal_le_iff_le_coe]]\n  refine (meas_ge_le_mul_pow_eLpNorm Î¼ one_ne_zero ENNReal.one_ne_top hf.1 ?_).trans_lt ?_\n  Â· simpa only [Ne, ENNReal.ofReal_eq_zero, not_le] using hÎµ\n  apply ENNReal.mul_lt_top\n  Â· simpa only [ENNReal.one_toReal, ENNReal.rpow_one, ENNReal.inv_lt_top, ENNReal.ofReal_pos]\n      using hÎµ\n  Â· simpa only [ENNReal.one_toReal, ENNReal.rpow_one] using\n      (memâ„’p_one_iff_integrable.2 hf).eLpNorm_lt_top\n\n"}
{"name":"MeasureTheory.Integrable.measure_norm_gt_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : NormedAddCommGroup Î²\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nÎµ : Real\nhÎµ : LT.lt 0 Îµ\nâŠ¢ LT.lt (Î¼ (setOf fun x => LT.lt Îµ (Norm.norm (f x)))) Top.top","decl":"/-- A non-quantitative version of Markov inequality for integrable functions: the measure of points\nwhere `â€–f xâ€– > Îµ` is finite for all positive `Îµ`. -/\nlemma Integrable.measure_norm_gt_lt_top {f : Î± â†’ Î²} (hf : Integrable f Î¼) {Îµ : â„} (hÎµ : 0 < Îµ) :\n    Î¼ {x | Îµ < â€–f xâ€–} < âˆ :=\n  lt_of_le_of_lt (measure_mono (fun _ h â†¦ (Set.mem_setOf_eq â–¸ h).le)) (hf.measure_norm_ge_lt_top hÎµ)\n\n"}
{"name":"MeasureTheory.Integrable.measure_ge_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nÎµ : Real\nÎµ_pos : LT.lt 0 Îµ\nâŠ¢ LT.lt (Î¼ (setOf fun a => LE.le Îµ (f a))) Top.top","decl":"/-- If `f` is `â„`-valued and integrable, then for any `c > 0` the set `{x | f x â‰¥ c}` has finite\nmeasure. -/\nlemma Integrable.measure_ge_lt_top {f : Î± â†’ â„} (hf : Integrable f Î¼) {Îµ : â„} (Îµ_pos : 0 < Îµ) :\n    Î¼ {a : Î± | Îµ â‰¤ f a} < âˆ := by\n  refine lt_of_le_of_lt (measure_mono ?_) (hf.measure_norm_ge_lt_top Îµ_pos)\n  intro x hx\n  simp only [Real.norm_eq_abs, Set.mem_setOf_eq] at hx âŠ¢\n  exact hx.trans (le_abs_self _)\n\n"}
{"name":"MeasureTheory.Integrable.measure_le_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nc : Real\nc_neg : LT.lt c 0\nâŠ¢ LT.lt (Î¼ (setOf fun a => LE.le (f a) c)) Top.top","decl":"/-- If `f` is `â„`-valued and integrable, then for any `c < 0` the set `{x | f x â‰¤ c}` has finite\nmeasure. -/\nlemma Integrable.measure_le_lt_top {f : Î± â†’ â„} (hf : Integrable f Î¼) {c : â„} (c_neg : c < 0) :\n    Î¼ {a : Î± | f a â‰¤ c} < âˆ := by\n  refine lt_of_le_of_lt (measure_mono ?_) (hf.measure_norm_ge_lt_top (show 0 < -c by linarith))\n  intro x hx\n  simp only [Real.norm_eq_abs, Set.mem_setOf_eq] at hx âŠ¢\n  exact (show -c â‰¤ - f x by linarith).trans (neg_le_abs _)\n\n"}
{"name":"MeasureTheory.Integrable.measure_gt_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nÎµ : Real\nÎµ_pos : LT.lt 0 Îµ\nâŠ¢ LT.lt (Î¼ (setOf fun a => LT.lt Îµ (f a))) Top.top","decl":"/-- If `f` is `â„`-valued and integrable, then for any `c > 0` the set `{x | f x > c}` has finite\nmeasure. -/\nlemma Integrable.measure_gt_lt_top {f : Î± â†’ â„} (hf : Integrable f Î¼) {Îµ : â„} (Îµ_pos : 0 < Îµ) :\n    Î¼ {a : Î± | Îµ < f a} < âˆ :=\n  lt_of_le_of_lt (measure_mono (fun _ hx â†¦ (Set.mem_setOf_eq â–¸ hx).le))\n    (Integrable.measure_ge_lt_top hf Îµ_pos)\n\n"}
{"name":"MeasureTheory.Integrable.measure_lt_lt_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nc : Real\nc_neg : LT.lt c 0\nâŠ¢ LT.lt (Î¼ (setOf fun a => LT.lt (f a) c)) Top.top","decl":"/-- If `f` is `â„`-valued and integrable, then for any `c < 0` the set `{x | f x < c}` has finite\nmeasure. -/\nlemma Integrable.measure_lt_lt_top {f : Î± â†’ â„} (hf : Integrable f Î¼) {c : â„} (c_neg : c < 0) :\n    Î¼ {a : Î± | f a < c} < âˆ :=\n  lt_of_le_of_lt (measure_mono (fun _ hx â†¦ (Set.mem_setOf_eq â–¸ hx).le))\n    (Integrable.measure_le_lt_top hf c_neg)\n\n"}
{"name":"MeasureTheory.LipschitzWith.integrable_comp_iff_of_antilipschitz","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nÎ³ : Type u_3\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : NormedAddCommGroup Î³\nK K' : NNReal\nf : Î± â†’ Î²\ng : Î² â†’ Î³\nhg : LipschitzWith K g\nhg' : AntilipschitzWith K' g\ng0 : Eq (g 0) 0\nâŠ¢ Iff (MeasureTheory.Integrable (Function.comp g f) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem LipschitzWith.integrable_comp_iff_of_antilipschitz {K K'} {f : Î± â†’ Î²} {g : Î² â†’ Î³}\n    (hg : LipschitzWith K g) (hg' : AntilipschitzWith K' g) (g0 : g 0 = 0) :\n    Integrable (g âˆ˜ f) Î¼ â†” Integrable f Î¼ := by\n  simp [â† memâ„’p_one_iff_integrable, hg.memâ„’p_comp_iff_of_antilipschitz hg' g0]\n\n"}
{"name":"MeasureTheory.Integrable.real_toNNReal","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => â†‘(f x).toNNReal) Î¼","decl":"@[fun_prop]\ntheorem Integrable.real_toNNReal {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    Integrable (fun x => ((f x).toNNReal : â„)) Î¼ := by\n  refine\n    âŸ¨hf.aestronglyMeasurable.aemeasurable.real_toNNReal.coe_nnreal_real.aestronglyMeasurable, ?_âŸ©\n  rw [hasFiniteIntegral_iff_norm]\n  refine lt_of_le_of_lt ?_ ((hasFiniteIntegral_iff_norm _).1 hf.hasFiniteIntegral)\n  apply lintegral_mono\n  intro x\n  simp [ENNReal.ofReal_le_ofReal, abs_le, le_abs_self]\n\n"}
{"name":"MeasureTheory.ofReal_toReal_ae_eq","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (fun x => ENNReal.ofReal (f x).toReal) f","decl":"theorem ofReal_toReal_ae_eq {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€áµ x âˆ‚Î¼, f x < âˆ) :\n    (fun x => ENNReal.ofReal (f x).toReal) =áµ[Î¼] f := by\n  filter_upwards [hf]\n  intro x hx\n  simp only [hx.ne, ofReal_toReal, Ne, not_false_iff]\n\n"}
{"name":"MeasureTheory.coe_toNNReal_ae_eq","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)\nâŠ¢ (MeasureTheory.ae Î¼).EventuallyEq (fun x => â†‘(f x).toNNReal) f","decl":"theorem coe_toNNReal_ae_eq {f : Î± â†’ â„â‰¥0âˆ} (hf : âˆ€áµ x âˆ‚Î¼, f x < âˆ) :\n    (fun x => ((f x).toNNReal : â„â‰¥0âˆ)) =áµ[Î¼] f := by\n  filter_upwards [hf]\n  intro x hx\n  simp only [hx.ne, Ne, not_false_iff, coe_toNNReal]\n\n"}
{"name":"MeasureTheory.integrable_count_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\ninstâœÂ¹ : NormedAddCommGroup Î²\ninstâœ : MeasurableSingletonClass Î±\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable f MeasureTheory.Measure.count) (Summable fun x => Norm.norm (f x))","decl":"/-- A function is integrable for the counting measure iff its norm is summable. -/\nlemma integrable_count_iff :\n    Integrable f Measure.count â†” Summable (â€–f Â·â€–) := by\n  -- Note: this proof would be much easier if we assumed `SecondCountableTopology G`. Without\n  -- this we have to justify the claim that `f` lands a.e. in a separable subset, which is true\n  -- (because summable functions have countable range) but slightly tedious to check.\n  rw [Integrable, hasFiniteIntegral_count_iff, and_iff_right_iff_imp]\n  intro hs\n  have hs' : (Function.support f).Countable := by\n    simpa only [Ne, Pi.zero_apply, eq_comm, Function.support, norm_eq_zero]\n      using hs.countable_support\n  letI : MeasurableSpace Î² := borel Î²\n  haveI : BorelSpace Î² := âŸ¨rflâŸ©\n  refine aestronglyMeasurable_iff_aemeasurable_separable.mpr âŸ¨?_, ?_âŸ©\n  Â· refine (measurable_zero.measurable_of_countable_ne ?_).aemeasurable\n    simpa only [Ne, Pi.zero_apply, eq_comm, Function.support] using hs'\n  Â· refine âŸ¨f '' univ, ?_, ae_of_all _ fun a â†¦ âŸ¨a, âŸ¨mem_univ _, rflâŸ©âŸ©âŸ©\n    suffices f '' univ âŠ† (f '' f.support) âˆª {0} from\n      (((hs'.image f).union (countable_singleton 0)).mono this).isSeparable\n    intro g hg\n    rcases eq_or_ne g 0 with rfl | hg'\n    Â· exact Or.inr (mem_singleton _)\n    Â· obtain âŸ¨x, -, rflâŸ© := (mem_image ..).mp hg\n      exact Or.inl âŸ¨x, hg', rflâŸ©\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_coe_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ NNReal\nhf : Measurable f\ng : Î± â†’ E\nâŠ¢ Iff (MeasureTheory.Integrable g (Î¼.withDensity fun x => â†‘(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (â†‘(f x)) (g x)) Î¼)","decl":"theorem integrable_withDensity_iff_integrable_coe_smul {f : Î± â†’ â„â‰¥0} (hf : Measurable f)\n    {g : Î± â†’ E} :\n    Integrable g (Î¼.withDensity fun x => f x) â†” Integrable (fun x => (f x : â„) â€¢ g x) Î¼ := by\n  by_cases H : AEStronglyMeasurable (fun x : Î± => (f x : â„) â€¢ g x) Î¼\n  Â· simp only [Integrable, aestronglyMeasurable_withDensity_iff hf, hasFiniteIntegral_iff_enorm, H,\n      true_and]\n    rw [lintegral_withDensity_eq_lintegral_mulâ‚€' hf.coe_nnreal_ennreal.aemeasurable]\n    Â· simp [enorm_smul]\n    Â· simpa [aemeasurable_withDensity_ennreal_iff hf, enorm_smul] using H.enorm\n  Â· simp only [Integrable, aestronglyMeasurable_withDensity_iff hf, H, false_and]\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ NNReal\nhf : Measurable f\ng : Î± â†’ E\nâŠ¢ Iff (MeasureTheory.Integrable g (Î¼.withDensity fun x => â†‘(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) Î¼)","decl":"theorem integrable_withDensity_iff_integrable_smul {f : Î± â†’ â„â‰¥0} (hf : Measurable f) {g : Î± â†’ E} :\n    Integrable g (Î¼.withDensity fun x => f x) â†” Integrable (fun x => f x â€¢ g x) Î¼ :=\n  integrable_withDensity_iff_integrable_coe_smul hf\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_smul'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ ENNReal\nhf : Measurable f\nhflt : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)\ng : Î± â†’ E\nâŠ¢ Iff (MeasureTheory.Integrable g (Î¼.withDensity f)) (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x).toReal (g x)) Î¼)","decl":"theorem integrable_withDensity_iff_integrable_smul' {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f)\n    (hflt : âˆ€áµ x âˆ‚Î¼, f x < âˆ) {g : Î± â†’ E} :\n    Integrable g (Î¼.withDensity f) â†” Integrable (fun x => (f x).toReal â€¢ g x) Î¼ := by\n  rw [â† withDensity_congr_ae (coe_toNNReal_ae_eq hflt),\n    integrable_withDensity_iff_integrable_smul]\n  Â· simp_rw [NNReal.smul_def, ENNReal.toReal]\n  Â· exact hf.ennreal_toNNReal\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_coe_smulâ‚€","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ NNReal\nhf : AEMeasurable f Î¼\ng : Î± â†’ E\nâŠ¢ Iff (MeasureTheory.Integrable g (Î¼.withDensity fun x => â†‘(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (â†‘(f x)) (g x)) Î¼)","decl":"theorem integrable_withDensity_iff_integrable_coe_smulâ‚€ {f : Î± â†’ â„â‰¥0} (hf : AEMeasurable f Î¼)\n    {g : Î± â†’ E} :\n    Integrable g (Î¼.withDensity fun x => f x) â†” Integrable (fun x => (f x : â„) â€¢ g x) Î¼ :=\n  calc\n    Integrable g (Î¼.withDensity fun x => f x) â†”\n        Integrable g (Î¼.withDensity fun x => (hf.mk f x : â„â‰¥0)) := by\n      suffices (fun x => (f x : â„â‰¥0âˆ)) =áµ[Î¼] (fun x => (hf.mk f x : â„â‰¥0)) by\n        rw [withDensity_congr_ae this]\n      filter_upwards [hf.ae_eq_mk] with x hx\n      simp [hx]\n    _ â†” Integrable (fun x => ((hf.mk f x : â„â‰¥0) : â„) â€¢ g x) Î¼ :=\n      integrable_withDensity_iff_integrable_coe_smul hf.measurable_mk\n    _ â†” Integrable (fun x => (f x : â„) â€¢ g x) Î¼ := by\n      apply integrable_congr\n      filter_upwards [hf.ae_eq_mk] with x hx\n      simp [hx]\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff_integrable_smulâ‚€","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ NNReal\nhf : AEMeasurable f Î¼\ng : Î± â†’ E\nâŠ¢ Iff (MeasureTheory.Integrable g (Î¼.withDensity fun x => â†‘(f x))) (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) (g x)) Î¼)","decl":"theorem integrable_withDensity_iff_integrable_smulâ‚€ {f : Î± â†’ â„â‰¥0} (hf : AEMeasurable f Î¼)\n    {g : Î± â†’ E} : Integrable g (Î¼.withDensity fun x => f x) â†” Integrable (fun x => f x â€¢ g x) Î¼ :=\n  integrable_withDensity_iff_integrable_coe_smulâ‚€ hf\n\n"}
{"name":"MeasureTheory.integrable_withDensity_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : Measurable f\nhflt : Filter.Eventually (fun x => LT.lt (f x) Top.top) (MeasureTheory.ae Î¼)\ng : Î± â†’ Real\nâŠ¢ Iff (MeasureTheory.Integrable g (Î¼.withDensity f)) (MeasureTheory.Integrable (fun x => HMul.hMul (g x) (f x).toReal) Î¼)","decl":"theorem integrable_withDensity_iff {f : Î± â†’ â„â‰¥0âˆ} (hf : Measurable f) (hflt : âˆ€áµ x âˆ‚Î¼, f x < âˆ)\n    {g : Î± â†’ â„} : Integrable g (Î¼.withDensity f) â†” Integrable (fun x => g x * (f x).toReal) Î¼ := by\n  have : (fun x => g x * (f x).toReal) = fun x => (f x).toReal â€¢ g x := by simp [mul_comm]\n  rw [this]\n  exact integrable_withDensity_iff_integrable_smul' hf hflt\n\n"}
{"name":"MeasureTheory.memâ„’1_smul_of_L1_withDensity","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ NNReal\nf_meas : Measurable f\nu : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 (Î¼.withDensity fun x => â†‘(f x))) x\nâŠ¢ MeasureTheory.Memâ„’p (fun x => HSMul.hSMul (f x) (â†‘â†‘u x)) 1 Î¼","decl":"theorem memâ„’1_smul_of_L1_withDensity {f : Î± â†’ â„â‰¥0} (f_meas : Measurable f)\n    (u : Lp E 1 (Î¼.withDensity fun x => f x)) : Memâ„’p (fun x => f x â€¢ u x) 1 Î¼ :=\n  memâ„’p_one_iff_integrable.2 <|\n    (integrable_withDensity_iff_integrable_smul f_meas).1 <| memâ„’p_one_iff_integrable.1 (Lp.memâ„’p u)\n\n"}
{"name":"MeasureTheory.withDensitySMulLI_apply","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace Real E\nf : Î± â†’ NNReal\nf_meas : Measurable f\nu : Subtype fun x => Membership.mem (MeasureTheory.Lp E 1 (Î¼.withDensity fun x => â†‘(f x))) x\nâŠ¢ Eq ((MeasureTheory.withDensitySMulLI Î¼ f_meas) u) (MeasureTheory.Memâ„’p.toLp (fun x => HSMul.hSMul (f x) (â†‘â†‘u x)) â‹¯)","decl":"@[simp]\ntheorem withDensitySMulLI_apply {f : Î± â†’ â„â‰¥0} (f_meas : Measurable f)\n    (u : Lp E 1 (Î¼.withDensity fun x => f x)) :\n    withDensitySMulLI Î¼ (E := E) f_meas u =\n      (memâ„’1_smul_of_L1_withDensity f_meas u).toLp fun x => f x â€¢ u x :=\n  rfl\n\n"}
{"name":"MeasureTheory.mem_â„’1_toReal_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhfm : AEMeasurable f Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ MeasureTheory.Memâ„’p (fun x => (f x).toReal) 1 Î¼","decl":"theorem mem_â„’1_toReal_of_lintegral_ne_top {f : Î± â†’ â„â‰¥0âˆ} (hfm : AEMeasurable f Î¼)\n    (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) : Memâ„’p (fun x â†¦ (f x).toReal) 1 Î¼ := by\n  rw [Memâ„’p, eLpNorm_one_eq_lintegral_enorm]\n  exact âŸ¨(AEMeasurable.ennreal_toReal hfm).aestronglyMeasurable,\n    hasFiniteIntegral_toReal_of_lintegral_ne_top hfiâŸ©\n\n"}
{"name":"MeasureTheory.integrable_toReal_of_lintegral_ne_top","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhfm : AEMeasurable f Î¼\nhfi : Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top\nâŠ¢ MeasureTheory.Integrable (fun x => (f x).toReal) Î¼","decl":"theorem integrable_toReal_of_lintegral_ne_top {f : Î± â†’ â„â‰¥0âˆ} (hfm : AEMeasurable f Î¼)\n    (hfi : âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ) : Integrable (fun x â†¦ (f x).toReal) Î¼ :=\n  memâ„’p_one_iff_integrable.1 <| mem_â„’1_toReal_of_lintegral_ne_top hfm hfi\n\n"}
{"name":"MeasureTheory.integrable_toReal_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ ENNReal\nhf : AEMeasurable f Î¼\nhf_ne_top : Filter.Eventually (fun x => Ne (f x) Top.top) (MeasureTheory.ae Î¼)\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => (f x).toReal) Î¼) (Ne (MeasureTheory.lintegral Î¼ fun x => f x) Top.top)","decl":"lemma integrable_toReal_iff {f : Î± â†’ â„â‰¥0âˆ} (hf : AEMeasurable f Î¼) (hf_ne_top : âˆ€áµ x âˆ‚Î¼, f x â‰  âˆ) :\n    Integrable (fun x â†¦ (f x).toReal) Î¼ â†” âˆ«â» x, f x âˆ‚Î¼ â‰  âˆ := by\n  rw [Integrable, hasFiniteIntegral_toReal_iff hf_ne_top]\n  simp only [hf.ennreal_toReal.aestronglyMeasurable, ne_eq, true_and]\n\n"}
{"name":"MeasureTheory.lintegral_ofReal_ne_top_iff_integrable","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhfm : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Iff (Ne (MeasureTheory.lintegral Î¼ fun a => ENNReal.ofReal (f a)) Top.top) (MeasureTheory.Integrable f Î¼)","decl":"lemma lintegral_ofReal_ne_top_iff_integrable {f : Î± â†’ â„}\n    (hfm : AEStronglyMeasurable f Î¼) (hf : 0 â‰¤áµ[Î¼] f) :\n    âˆ«â» a, ENNReal.ofReal (f a) âˆ‚Î¼ â‰  âˆ â†” Integrable f Î¼ := by\n  rw [Integrable, hasFiniteIntegral_iff_ofReal hf]\n  simp [hfm]\n\n"}
{"name":"MeasureTheory.Integrable.pos_part","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => Max.max (f a) 0) Î¼","decl":"@[fun_prop]\ntheorem Integrable.pos_part {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    Integrable (fun a => max (f a) 0) Î¼ :=\n  âŸ¨(hf.aestronglyMeasurable.aemeasurable.max aemeasurable_const).aestronglyMeasurable,\n    hf.hasFiniteIntegral.max_zeroâŸ©\n\n"}
{"name":"MeasureTheory.Integrable.neg_part","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => Max.max (Neg.neg (f a)) 0) Î¼","decl":"@[fun_prop]\ntheorem Integrable.neg_part {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    Integrable (fun a => max (-f a) 0) Î¼ :=\n  hf.neg.pos_part\n\n"}
{"name":"MeasureTheory.Integrable.smul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedAddCommGroup ğ•œ\ninstâœÂ¹ : SMulZeroClass ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nf : Î± â†’ Î²\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (HSMul.hSMul c f) Î¼","decl":"@[fun_prop]\ntheorem Integrable.smul [NormedAddCommGroup ğ•œ] [SMulZeroClass ğ•œ Î²] [BoundedSMul ğ•œ Î²] (c : ğ•œ)\n    {f : Î± â†’ Î²} (hf : Integrable f Î¼) : Integrable (c â€¢ f) Î¼ :=\n  âŸ¨hf.aestronglyMeasurable.const_smul c, hf.hasFiniteIntegral.smul câŸ©\n\n"}
{"name":"IsUnit.integrable_smul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nhc : IsUnit c\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable (HSMul.hSMul c f) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem _root_.IsUnit.integrable_smul_iff [NormedRing ğ•œ] [Module ğ•œ Î²] [BoundedSMul ğ•œ Î²] {c : ğ•œ}\n    (hc : IsUnit c) (f : Î± â†’ Î²) : Integrable (c â€¢ f) Î¼ â†” Integrable f Î¼ :=\n  and_congr hc.aestronglyMeasurable_const_smul_iff (hasFiniteIntegral_smul_iff hc f)\n\n"}
{"name":"MeasureTheory.integrable_smul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedDivisionRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nc : ğ•œ\nhc : Ne c 0\nf : Î± â†’ Î²\nâŠ¢ Iff (MeasureTheory.Integrable (HSMul.hSMul c f) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_smul_iff [NormedDivisionRing ğ•œ] [Module ğ•œ Î²] [BoundedSMul ğ•œ Î²] {c : ğ•œ}\n    (hc : c â‰  0) (f : Î± â†’ Î²) : Integrable (c â€¢ f) Î¼ â†” Integrable f Î¼ :=\n  (IsUnit.mk0 _ hc).integrable_smul_iff f\n\n"}
{"name":"MeasureTheory.Integrable.smul_of_top_right","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nf : Î± â†’ Î²\nÏ† : Î± â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nhÏ† : MeasureTheory.Memâ„’p Ï† Top.top Î¼\nâŠ¢ MeasureTheory.Integrable (HSMul.hSMul Ï† f) Î¼","decl":"theorem Integrable.smul_of_top_right {f : Î± â†’ Î²} {Ï† : Î± â†’ ğ•œ} (hf : Integrable f Î¼)\n    (hÏ† : Memâ„’p Ï† âˆ Î¼) : Integrable (Ï† â€¢ f) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢\n  exact Memâ„’p.smul_of_top_right hf hÏ†\n\n"}
{"name":"MeasureTheory.Integrable.smul_of_top_left","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nf : Î± â†’ Î²\nÏ† : Î± â†’ ğ•œ\nhÏ† : MeasureTheory.Integrable Ï† Î¼\nhf : MeasureTheory.Memâ„’p f Top.top Î¼\nâŠ¢ MeasureTheory.Integrable (HSMul.hSMul Ï† f) Î¼","decl":"theorem Integrable.smul_of_top_left {f : Î± â†’ Î²} {Ï† : Î± â†’ ğ•œ} (hÏ† : Integrable Ï† Î¼)\n    (hf : Memâ„’p f âˆ Î¼) : Integrable (Ï† â€¢ f) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hÏ† âŠ¢\n  exact Memâ„’p.smul_of_top_left hf hÏ†\n\n"}
{"name":"MeasureTheory.Integrable.smul_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nÎ² : Type u_2\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœÂ³ : NormedAddCommGroup Î²\nğ•œ : Type u_6\ninstâœÂ² : NormedRing ğ•œ\ninstâœÂ¹ : Module ğ•œ Î²\ninstâœ : BoundedSMul ğ•œ Î²\nf : Î± â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nc : Î²\nâŠ¢ MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) c) Î¼","decl":"@[fun_prop]\ntheorem Integrable.smul_const {f : Î± â†’ ğ•œ} (hf : Integrable f Î¼) (c : Î²) :\n    Integrable (fun x => f x â€¢ c) Î¼ :=\n  hf.smul_of_top_left (memâ„’p_top_const c)\n\n"}
{"name":"MeasureTheory.integrable_smul_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : CompleteSpace ğ•œ\nE : Type u_7\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf : Î± â†’ ğ•œ\nc : E\nhc : Ne c 0\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HSMul.hSMul (f x) c) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_smul_const {f : Î± â†’ ğ•œ} {c : E} (hc : c â‰  0) :\n    Integrable (fun x => f x â€¢ c) Î¼ â†” Integrable f Î¼ := by\n  simp_rw [Integrable, aestronglyMeasurable_smul_const_iff (f := f) hc, and_congr_right_iff,\n    hasFiniteIntegral_iff_enorm, enorm_smul]\n  intro _; rw [lintegral_mul_const' _ _ enorm_ne_top, ENNReal.mul_lt_top_iff]\n  have : âˆ€ x : â„â‰¥0âˆ, x = 0 â†’ x < âˆ := by simp\n  simp [hc, or_iff_left_of_imp (this _)]\n\n"}
{"name":"MeasureTheory.Integrable.const_mul","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.Integrable f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.Integrable (fun x => HMul.hMul c (f x)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.const_mul {f : Î± â†’ ğ•œ} (h : Integrable f Î¼) (c : ğ•œ) :\n    Integrable (fun x => c * f x) Î¼ :=\n  h.smul c\n\n"}
{"name":"MeasureTheory.Integrable.const_mul'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.Integrable f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.Integrable (HMul.hMul (fun x => c) f) Î¼","decl":"theorem Integrable.const_mul' {f : Î± â†’ ğ•œ} (h : Integrable f Î¼) (c : ğ•œ) :\n    Integrable ((fun _ : Î± => c) * f) Î¼ :=\n  Integrable.const_mul h c\n\n"}
{"name":"MeasureTheory.Integrable.mul_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.Integrable f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.Integrable (fun x => HMul.hMul (f x) c) Î¼","decl":"@[fun_prop]\ntheorem Integrable.mul_const {f : Î± â†’ ğ•œ} (h : Integrable f Î¼) (c : ğ•œ) :\n    Integrable (fun x => f x * c) Î¼ :=\n  h.smul (MulOpposite.op c)\n\n"}
{"name":"MeasureTheory.Integrable.mul_const'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.Integrable f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.Integrable (HMul.hMul f fun x => c) Î¼","decl":"theorem Integrable.mul_const' {f : Î± â†’ ğ•œ} (h : Integrable f Î¼) (c : ğ•œ) :\n    Integrable (f * fun _ : Î± => c) Î¼ :=\n  Integrable.mul_const h c\n\n"}
{"name":"MeasureTheory.integrable_const_mul_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nc : ğ•œ\nhc : IsUnit c\nf : Î± â†’ ğ•œ\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HMul.hMul c (f x)) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_const_mul_iff {c : ğ•œ} (hc : IsUnit c) (f : Î± â†’ ğ•œ) :\n    Integrable (fun x => c * f x) Î¼ â†” Integrable f Î¼ :=\n  hc.integrable_smul_iff f\n\n"}
{"name":"MeasureTheory.integrable_mul_const_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nc : ğ•œ\nhc : IsUnit c\nf : Î± â†’ ğ•œ\nâŠ¢ Iff (MeasureTheory.Integrable (fun x => HMul.hMul (f x) c) Î¼) (MeasureTheory.Integrable f Î¼)","decl":"theorem integrable_mul_const_iff {c : ğ•œ} (hc : IsUnit c) (f : Î± â†’ ğ•œ) :\n    Integrable (fun x => f x * c) Î¼ â†” Integrable f Î¼ :=\n  hc.op.integrable_smul_iff f\n\n"}
{"name":"MeasureTheory.Integrable.bdd_mul'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf g : Î± â†’ ğ•œ\nc : Real\nhg : MeasureTheory.Integrable g Î¼\nhf : MeasureTheory.AEStronglyMeasurable f Î¼\nhf_bound : Filter.Eventually (fun x => LE.le (Norm.norm (f x)) c) (MeasureTheory.ae Î¼)\nâŠ¢ MeasureTheory.Integrable (fun x => HMul.hMul (f x) (g x)) Î¼","decl":"theorem Integrable.bdd_mul' {f g : Î± â†’ ğ•œ} {c : â„} (hg : Integrable g Î¼)\n    (hf : AEStronglyMeasurable f Î¼) (hf_bound : âˆ€áµ x âˆ‚Î¼, â€–f xâ€– â‰¤ c) :\n    Integrable (fun x => f x * g x) Î¼ := by\n  refine Integrable.mono' (hg.norm.smul c) (hf.mul hg.1) ?_\n  filter_upwards [hf_bound] with x hx\n  rw [Pi.smul_apply, smul_eq_mul]\n  exact (norm_mul_le _ _).trans (mul_le_mul_of_nonneg_right hx (norm_nonneg _))\n\n"}
{"name":"MeasureTheory.Integrable.mul_of_top_right","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf Ï† : Î± â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nhÏ† : MeasureTheory.Memâ„’p Ï† Top.top Î¼\nâŠ¢ MeasureTheory.Integrable (HMul.hMul Ï† f) Î¼","decl":"theorem Integrable.mul_of_top_right {f : Î± â†’ ğ•œ} {Ï† : Î± â†’ ğ•œ} (hf : Integrable f Î¼)\n    (hÏ† : Memâ„’p Ï† âˆ Î¼) : Integrable (Ï† * f) Î¼ :=\n  hf.smul_of_top_right hÏ†\n\n"}
{"name":"MeasureTheory.Integrable.mul_of_top_left","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedRing ğ•œ\nf Ï† : Î± â†’ ğ•œ\nhÏ† : MeasureTheory.Integrable Ï† Î¼\nhf : MeasureTheory.Memâ„’p f Top.top Î¼\nâŠ¢ MeasureTheory.Integrable (HMul.hMul Ï† f) Î¼","decl":"theorem Integrable.mul_of_top_left {f : Î± â†’ ğ•œ} {Ï† : Î± â†’ ğ•œ} (hÏ† : Integrable Ï† Î¼)\n    (hf : Memâ„’p f âˆ Î¼) : Integrable (Ï† * f) Î¼ :=\n  hÏ†.smul_of_top_left hf\n\n"}
{"name":"MeasureTheory.Integrable.div_const","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : NormedDivisionRing ğ•œ\nf : Î± â†’ ğ•œ\nh : MeasureTheory.Integrable f Î¼\nc : ğ•œ\nâŠ¢ MeasureTheory.Integrable (fun x => HDiv.hDiv (f x) c) Î¼","decl":"@[fun_prop]\ntheorem Integrable.div_const {f : Î± â†’ ğ•œ} (h : Integrable f Î¼) (c : ğ•œ) :\n    Integrable (fun x => f x / c) Î¼ := by simp_rw [div_eq_mul_inv, h.mul_const]\n\n"}
{"name":"MeasureTheory.Integrable.ofReal","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nf : Î± â†’ Real\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => â†‘(f x)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.ofReal {f : Î± â†’ â„} (hf : Integrable f Î¼) :\n    Integrable (fun x => (f x : ğ•œ)) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢\n  exact hf.ofReal\n\n"}
{"name":"MeasureTheory.Integrable.re_im_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nf : Î± â†’ ğ•œ\nâŠ¢ Iff (And (MeasureTheory.Integrable (fun x => RCLike.re (f x)) Î¼) (MeasureTheory.Integrable (fun x => RCLike.im (f x)) Î¼)) (MeasureTheory.Integrable f Î¼)","decl":"theorem Integrable.re_im_iff :\n    Integrable (fun x => RCLike.re (f x)) Î¼ âˆ§ Integrable (fun x => RCLike.im (f x)) Î¼ â†”\n      Integrable f Î¼ := by\n  simp_rw [â† memâ„’p_one_iff_integrable]\n  exact memâ„’p_re_im_iff\n\n"}
{"name":"MeasureTheory.Integrable.re","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nf : Î± â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => RCLike.re (f x)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.re (hf : Integrable f Î¼) : Integrable (fun x => RCLike.re (f x)) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢\n  exact hf.re\n\n"}
{"name":"MeasureTheory.Integrable.im","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nğ•œ : Type u_6\ninstâœ : RCLike ğ•œ\nf : Î± â†’ ğ•œ\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => RCLike.im (f x)) Î¼","decl":"@[fun_prop]\ntheorem Integrable.im (hf : Integrable f Î¼) : Integrable (fun x => RCLike.im (f x)) Î¼ := by\n  rw [â† memâ„’p_one_iff_integrable] at hf âŠ¢\n  exact hf.im\n\n"}
{"name":"MeasureTheory.Integrable.trim","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nH : Type u_6\ninstâœ : NormedAddCommGroup H\nm0 : MeasurableSpace Î±\nÎ¼' : MeasureTheory.Measure Î±\nf : Î± â†’ H\nhm : LE.le m m0\nhf_int : MeasureTheory.Integrable f Î¼'\nhf : MeasureTheory.StronglyMeasurable f\nâŠ¢ MeasureTheory.Integrable f (Î¼'.trim hm)","decl":"theorem Integrable.trim (hm : m â‰¤ m0) (hf_int : Integrable f Î¼') (hf : StronglyMeasurable[m] f) :\n    Integrable f (Î¼'.trim hm) := by\n  refine âŸ¨hf.aestronglyMeasurable, ?_âŸ©\n  rw [HasFiniteIntegral, lintegral_trim hm _]\n  Â· exact hf_int.2\n  Â· exact @StronglyMeasurable.enorm _ m _ _ f hf\n\n"}
{"name":"MeasureTheory.integrable_of_integrable_trim","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nH : Type u_6\ninstâœ : NormedAddCommGroup H\nm0 : MeasurableSpace Î±\nÎ¼' : MeasureTheory.Measure Î±\nf : Î± â†’ H\nhm : LE.le m m0\nhf_int : MeasureTheory.Integrable f (Î¼'.trim hm)\nâŠ¢ MeasureTheory.Integrable f Î¼'","decl":"theorem integrable_of_integrable_trim (hm : m â‰¤ m0) (hf_int : Integrable f (Î¼'.trim hm)) :\n    Integrable f Î¼' := by\n  obtain âŸ¨hf_meas_ae, hfâŸ© := hf_int\n  refine âŸ¨aestronglyMeasurable_of_aestronglyMeasurable_trim hm hf_meas_ae, ?_âŸ©\n  simpa [HasFiniteIntegral, lintegral_trim_ae hm hf_meas_ae.enorm] using hf\n\n"}
{"name":"MeasureTheory.integrable_of_forall_fin_meas_le'","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nE : Type u_6\nm0 : MeasurableSpace Î±\ninstâœÂ¹ : NormedAddCommGroup E\nÎ¼ : MeasureTheory.Measure Î±\nhm : LE.le m m0\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim hm)\nC : ENNReal\nhC : LT.lt C Top.top\nf : Î± â†’ E\nhf_meas : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : âˆ€ (s : Set Î±), MeasurableSet s â†’ Ne (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENorm.enorm (f x)) C\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem integrable_of_forall_fin_meas_le' {Î¼ : Measure Î±} (hm : m â‰¤ m0) [SigmaFinite (Î¼.trim hm)]\n    (C : â„â‰¥0âˆ) (hC : C < âˆ) {f : Î± â†’ E} (hf_meas : AEStronglyMeasurable f Î¼)\n    (hf : âˆ€ s, MeasurableSet[m] s â†’ Î¼ s â‰  âˆ â†’ âˆ«â» x in s, â€–f xâ€–â‚‘ âˆ‚Î¼ â‰¤ C) : Integrable f Î¼ :=\n  âŸ¨hf_meas, (lintegral_le_of_forall_fin_meas_trim_le hm C hf).trans_lt hCâŸ©\n\n"}
{"name":"MeasureTheory.integrable_of_forall_fin_meas_le","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : MeasureTheory.SigmaFinite Î¼\nC : ENNReal\nhC : LT.lt C Top.top\nf : Î± â†’ E\nhf_meas : MeasureTheory.AEStronglyMeasurable f Î¼\nhf : âˆ€ (s : Set Î±), MeasurableSet s â†’ Ne (Î¼ s) Top.top â†’ LE.le (MeasureTheory.lintegral (Î¼.restrict s) fun x => ENorm.enorm (f x)) C\nâŠ¢ MeasureTheory.Integrable f Î¼","decl":"theorem integrable_of_forall_fin_meas_le [SigmaFinite Î¼] (C : â„â‰¥0âˆ) (hC : C < âˆ) {f : Î± â†’ E}\n    (hf_meas : AEStronglyMeasurable[m] f Î¼)\n    (hf : âˆ€ s : Set Î±, MeasurableSet[m] s â†’ Î¼ s â‰  âˆ â†’ âˆ«â» x in s, â€–f xâ€–â‚‘ âˆ‚Î¼ â‰¤ C) :\n    Integrable f Î¼ :=\n  have : SigmaFinite (Î¼.trim le_rfl) := by rwa [@trim_eq_self _ m]\n  integrable_of_forall_fin_meas_le' le_rfl C hC hf_meas hf\n\n"}
{"name":"MeasureTheory.Integrable.restrict","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœ : NormedAddCommGroup E\nf : Î± â†’ E\nhf : MeasureTheory.Integrable f Î¼\ns : Set Î±\nâŠ¢ MeasureTheory.Integrable f (Î¼.restrict s)","decl":"/-- One should usually use `MeasureTheory.Integrable.IntegrableOn` instead. -/\nlemma Integrable.restrict (hf : Integrable f Î¼) {s : Set Î±} : Integrable f (Î¼.restrict s) :=\n  hf.mono_measure Measure.restrict_le_self\n\n"}
{"name":"ContinuousLinearMap.integrable_comp","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœâ´ : NormedAddCommGroup E\nğ•œ : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\nH : Type u_8\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nÏ† : Î± â†’ H\nL : ContinuousLinearMap (RingHom.id ğ•œ) H E\nÏ†_int : MeasureTheory.Integrable Ï† Î¼\nâŠ¢ MeasureTheory.Integrable (fun a => L (Ï† a)) Î¼","decl":"@[fun_prop]\ntheorem ContinuousLinearMap.integrable_comp {Ï† : Î± â†’ H} (L : H â†’L[ğ•œ] E) (Ï†_int : Integrable Ï† Î¼) :\n    Integrable (fun a : Î± => L (Ï† a)) Î¼ :=\n  ((Integrable.norm Ï†_int).const_mul â€–Lâ€–).mono'\n    (L.continuous.comp_aestronglyMeasurable Ï†_int.aestronglyMeasurable)\n    (Eventually.of_forall fun a => L.le_opNorm (Ï† a))\n\n"}
{"name":"ContinuousLinearEquiv.integrable_comp_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœâ´ : NormedAddCommGroup E\nğ•œ : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\nH : Type u_8\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nÏ† : Î± â†’ H\nL : ContinuousLinearEquiv (RingHom.id ğ•œ) H E\nâŠ¢ Iff (MeasureTheory.Integrable (fun a => L (Ï† a)) Î¼) (MeasureTheory.Integrable Ï† Î¼)","decl":"@[simp]\ntheorem ContinuousLinearEquiv.integrable_comp_iff {Ï† : Î± â†’ H} (L : H â‰ƒL[ğ•œ] E) :\n    Integrable (fun a : Î± â†¦ L (Ï† a)) Î¼ â†” Integrable Ï† Î¼ :=\n  âŸ¨fun h â†¦ by simpa using ContinuousLinearMap.integrable_comp (L.symm : E â†’L[ğ•œ] H) h,\n  fun h â†¦ ContinuousLinearMap.integrable_comp (L : H â†’L[ğ•œ] E) hâŸ©\n\n"}
{"name":"LinearIsometryEquiv.integrable_comp_iff","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœâ´ : NormedAddCommGroup E\nğ•œ : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\nH : Type u_8\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nÏ† : Î± â†’ H\nL : LinearIsometryEquiv (RingHom.id ğ•œ) H E\nâŠ¢ Iff (MeasureTheory.Integrable (fun a => L (Ï† a)) Î¼) (MeasureTheory.Integrable Ï† Î¼)","decl":"@[simp]\ntheorem LinearIsometryEquiv.integrable_comp_iff {Ï† : Î± â†’ H} (L : H â‰ƒâ‚—áµ¢[ğ•œ] E) :\n    Integrable (fun a : Î± â†¦ L (Ï† a)) Î¼ â†” Integrable Ï† Î¼ :=\n  ContinuousLinearEquiv.integrable_comp_iff (L : H â‰ƒL[ğ•œ] E)\n\n"}
{"name":"MeasureTheory.Integrable.apply_continuousLinearMap","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\ninstâœâ´ : NormedAddCommGroup E\nğ•œ : Type u_7\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedSpace ğ•œ E\nH : Type u_8\ninstâœÂ¹ : NormedAddCommGroup H\ninstâœ : NormedSpace ğ•œ H\nÏ† : Î± â†’ ContinuousLinearMap (RingHom.id ğ•œ) H E\nÏ†_int : MeasureTheory.Integrable Ï† Î¼\nv : H\nâŠ¢ MeasureTheory.Integrable (fun a => (Ï† a) v) Î¼","decl":"theorem MeasureTheory.Integrable.apply_continuousLinearMap {Ï† : Î± â†’ H â†’L[ğ•œ] E}\n    (Ï†_int : Integrable Ï† Î¼) (v : H) : Integrable (fun a => Ï† a v) Î¼ :=\n  (ContinuousLinearMap.apply ğ•œ _ v).integrable_comp Ï†_int\n\n"}
{"name":"MeasureTheory.Integrable.fst","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\nF : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Î± â†’ Prod E F\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => (f x).1) Î¼","decl":"@[fun_prop]\nlemma Integrable.fst {f : Î± â†’ E Ã— F} (hf : Integrable f Î¼) : Integrable (fun x â†¦ (f x).1) Î¼ :=\n  (ContinuousLinearMap.fst â„ E F).integrable_comp hf\n\n"}
{"name":"MeasureTheory.Integrable.snd","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\nF : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Î± â†’ Prod E F\nhf : MeasureTheory.Integrable f Î¼\nâŠ¢ MeasureTheory.Integrable (fun x => (f x).2) Î¼","decl":"@[fun_prop]\nlemma Integrable.snd {f : Î± â†’ E Ã— F} (hf : Integrable f Î¼) : Integrable (fun x â†¦ (f x).2) Î¼ :=\n  (ContinuousLinearMap.snd â„ E F).integrable_comp hf\n\n"}
{"name":"MeasureTheory.integrable_prod","module":"Mathlib.MeasureTheory.Function.L1Space.Integrable","initialProofState":"Î± : Type u_1\nm : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nE : Type u_6\nF : Type u_7\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace Real E\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace Real F\nf : Î± â†’ Prod E F\nâŠ¢ Iff (MeasureTheory.Integrable f Î¼) (And (MeasureTheory.Integrable (fun x => (f x).1) Î¼) (MeasureTheory.Integrable (fun x => (f x).2) Î¼))","decl":"lemma integrable_prod {f : Î± â†’ E Ã— F} :\n    Integrable f Î¼ â†” Integrable (fun x â†¦ (f x).1) Î¼ âˆ§ Integrable (fun x â†¦ (f x).2) Î¼ :=\n  âŸ¨fun h â†¦ âŸ¨h.fst, h.sndâŸ©, fun h â†¦ h.1.prod_mk h.2âŸ©\n\n"}
