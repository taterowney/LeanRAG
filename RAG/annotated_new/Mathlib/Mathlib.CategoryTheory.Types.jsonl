{"name":"CategoryTheory.types_hom","module":"Mathlib.CategoryTheory.Types","initialProofState":"Œ± Œ≤ : Type u\n‚ä¢ Eq (Quiver.Hom Œ± Œ≤) (Œ± ‚Üí Œ≤)","decl":"theorem types_hom {Œ± Œ≤ : Type u} : (Œ± ‚ü∂ Œ≤) = (Œ± ‚Üí Œ≤) :=\n  rfl\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/10688): this lemma was not here in Lean 3. Lean 3 `ext` would solve this goal\n-- because of its \"if all else fails, apply all `ext` lemmas\" policy,\n-- which apparently we want to move away from.\n"}
{"name":"CategoryTheory.types_ext_iff","module":"Mathlib.CategoryTheory.Types","initialProofState":"Œ± Œ≤ : Type u\nf g : Quiver.Hom Œ± Œ≤\n‚ä¢ Iff (Eq f g) (‚àÄ (a : Œ±), Eq (f a) (g a))","decl":"@[ext] theorem types_ext {Œ± Œ≤ : Type u} (f g : Œ± ‚ü∂ Œ≤) (h : ‚àÄ a : Œ±, f a = g a) : f = g := by\n  funext x\n  exact h x\n\n"}
{"name":"CategoryTheory.types_ext","module":"Mathlib.CategoryTheory.Types","initialProofState":"Œ± Œ≤ : Type u\nf g : Quiver.Hom Œ± Œ≤\nh : ‚àÄ (a : Œ±), Eq (f a) (g a)\n‚ä¢ Eq f g","decl":"@[ext] theorem types_ext {Œ± Œ≤ : Type u} (f g : Œ± ‚ü∂ Œ≤) (h : ‚àÄ a : Œ±, f a = g a) : f = g := by\n  funext x\n  exact h x\n\n"}
{"name":"CategoryTheory.types_id","module":"Mathlib.CategoryTheory.Types","initialProofState":"X : Type u\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X) id","decl":"theorem types_id (X : Type u) : ùüô X = id :=\n  rfl\n\n"}
{"name":"CategoryTheory.types_comp","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g) (Function.comp g f)","decl":"theorem types_comp {X Y Z : Type u} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) : f ‚â´ g = g ‚àò f :=\n  rfl\n\n"}
{"name":"CategoryTheory.types_id_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"X : Type u\nx : X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.id X x) x","decl":"@[simp]\ntheorem types_id_apply (X : Type u) (x : X) : (ùüô X : X ‚Üí X) x = x :=\n  rfl\n\n"}
{"name":"CategoryTheory.types_comp_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y Z : Type u\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nx : X\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f g x) (g (f x))","decl":"@[simp]\ntheorem types_comp_apply {X Y Z : Type u} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (x : X) : (f ‚â´ g) x = g (f x) :=\n  rfl\n\n"}
{"name":"CategoryTheory.hom_inv_id_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : CategoryTheory.Iso X Y\nx : X\n‚ä¢ Eq (f.inv (f.hom x)) x","decl":"@[simp]\ntheorem hom_inv_id_apply {X Y : Type u} (f : X ‚âÖ Y) (x : X) : f.inv (f.hom x) = x :=\n  congr_fun f.hom_inv_id x\n\n"}
{"name":"CategoryTheory.inv_hom_id_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : CategoryTheory.Iso X Y\ny : Y\n‚ä¢ Eq (f.hom (f.inv y)) y","decl":"@[simp]\ntheorem inv_hom_id_apply {X Y : Type u} (f : X ‚âÖ Y) (y : Y) : f.hom (f.inv y) = y :=\n  congr_fun f.inv_hom_id y\n\n-- Unfortunately without this wrapper we can't use `CategoryTheory` idioms, such as `IsIso f`.\n"}
{"name":"CategoryTheory.Functor.sections_property","module":"Mathlib.CategoryTheory.Types","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (Type w)\ns : ‚ÜëF.sections\nj j' : J\nf : Quiver.Hom j j'\n‚ä¢ Eq (F.map f (‚Üës j)) (‚Üës j')","decl":"@[simp]\nlemma sections_property {F : J ‚•§ Type w} (s : (F.sections : Type _))\n    {j j' : J} (f : j ‚ü∂ j') : F.map f (s.val j) = s.val j' :=\n  s.property f\n\n"}
{"name":"CategoryTheory.Functor.sections_ext_iff","module":"Mathlib.CategoryTheory.Types","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (Type w)\nx y : ‚ÜëF.sections\n‚ä¢ Iff (Eq x y) (‚àÄ (j : J), Eq (‚Üëx j) (‚Üëy j))","decl":"lemma sections_ext_iff {F : J ‚•§ Type w} {x y : F.sections} : x = y ‚Üî ‚àÄ j, x.val j = y.val j :=\n  Subtype.ext_iff.trans funext_iff\n\n"}
{"name":"CategoryTheory.Functor.sectionsFunctor_map_coe","module":"Mathlib.CategoryTheory.Types","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nF G : CategoryTheory.Functor J (Type w)\nœÜ : Quiver.Hom F G\nx : ‚ÜëF.sections\nj : J\n‚ä¢ Eq (‚Üë((CategoryTheory.Functor.sectionsFunctor J).map œÜ x) j) (œÜ.app j (‚Üëx j))","decl":"/-- The functor which sends a functor to types to its sections. -/\n@[simps]\ndef sectionsFunctor : (J ‚•§ Type w) ‚•§ Type max u w where\n  obj F := F.sections\n  map {F G} œÜ x := ‚ü®fun j => œÜ.app j (x.1 j), fun {j j'} f =>\n    (congr_fun (œÜ.naturality f) (x.1 j)).symm.trans (by simp [x.2 f])‚ü©\n\n"}
{"name":"CategoryTheory.Functor.sectionsFunctor_obj","module":"Mathlib.CategoryTheory.Types","initialProofState":"J : Type u\ninst‚úù : CategoryTheory.Category.{v, u} J\nF : CategoryTheory.Functor J (Type w)\n‚ä¢ Eq ((CategoryTheory.Functor.sectionsFunctor J).obj F) ‚ÜëF.sections","decl":"/-- The functor which sends a functor to types to its sections. -/\n@[simps]\ndef sectionsFunctor : (J ‚•§ Type w) ‚•§ Type max u w where\n  obj F := F.sections\n  map {F G} œÜ x := ‚ü®fun j => œÜ.app j (x.1 j), fun {j j'} f =>\n    (congr_fun (œÜ.naturality f) (x.1 j)).symm.trans (by simp [x.2 f])‚ü©\n\n"}
{"name":"CategoryTheory.FunctorToTypes.map_comp_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\na : F.obj X\n‚ä¢ Eq (F.map (CategoryTheory.CategoryStruct.comp f g) a) (F.map g (F.map f a))","decl":"@[simp]\ntheorem map_comp_apply (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z) (a : F.obj X) :\n    (F.map (f ‚â´ g)) a = (F.map g) ((F.map f) a) := by simp [types_comp]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.map_id_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX : C\na : F.obj X\n‚ä¢ Eq (F.map (CategoryTheory.CategoryStruct.id X) a) a","decl":"@[simp]\ntheorem map_id_apply (a : F.obj X) : (F.map (ùüô X)) a = a := by simp [types_id]\n\n"}
{"name":"CategoryTheory.FunctorToTypes.naturality","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nX Y : C\nœÉ : Quiver.Hom F G\nf : Quiver.Hom X Y\nx : F.obj X\n‚ä¢ Eq (œÉ.app Y (F.map f x)) (G.map f (œÉ.app X x))","decl":"theorem naturality (f : X ‚ü∂ Y) (x : F.obj X) : œÉ.app Y ((F.map f) x) = (G.map f) (œÉ.app X x) :=\n  congr_fun (œÉ.naturality f) x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.comp","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G H : CategoryTheory.Functor C (Type w)\nX : C\nœÉ : Quiver.Hom F G\nœÑ : Quiver.Hom G H\nx : F.obj X\n‚ä¢ Eq ((CategoryTheory.CategoryStruct.comp œÉ œÑ).app X x) (œÑ.app X (œÉ.app X x))","decl":"@[simp]\ntheorem comp (x : F.obj X) : (œÉ ‚â´ œÑ).app X x = œÑ.app X (œÉ.app X x) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.eqToHom_map_comp_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX Y Z : C\np : Eq X Y\nq : Eq Y Z\nx : F.obj X\n‚ä¢ Eq (F.map (CategoryTheory.eqToHom q) (F.map (CategoryTheory.eqToHom p) x)) (F.map (CategoryTheory.eqToHom ‚ãØ) x)","decl":"@[simp]\ntheorem eqToHom_map_comp_apply (p : X = Y) (q : Y = Z) (x : F.obj X) :\n    F.map (eqToHom q) (F.map (eqToHom p) x) = F.map (eqToHom <| p.trans q) x := by\n  aesop_cat\n\n"}
{"name":"CategoryTheory.FunctorToTypes.hcomp","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nœÉ : Quiver.Hom F G\nD : Type u'\nùíü : CategoryTheory.Category.{u', u'} D\nI J : CategoryTheory.Functor D C\nœÅ : Quiver.Hom I J\nW : D\nx : (I.comp F).obj W\n‚ä¢ Eq ((CategoryTheory.NatTrans.hcomp œÅ œÉ).app W x) (G.map (œÅ.app W) (œÉ.app (I.obj W) x))","decl":"@[simp]\ntheorem hcomp (x : (I ‚ãô F).obj W) : (œÅ ‚ó´ œÉ).app W x = (G.map (œÅ.app W)) (œÉ.app (I.obj W) x) :=\n  rfl\n\n"}
{"name":"CategoryTheory.FunctorToTypes.map_inv_map_hom_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX Y : C\nf : CategoryTheory.Iso X Y\nx : F.obj X\n‚ä¢ Eq (F.map f.inv (F.map f.hom x)) x","decl":"@[simp]\ntheorem map_inv_map_hom_apply (f : X ‚âÖ Y) (x : F.obj X) : F.map f.inv (F.map f.hom x) = x :=\n  congr_fun (F.mapIso f).hom_inv_id x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.map_hom_map_inv_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor C (Type w)\nX Y : C\nf : CategoryTheory.Iso X Y\ny : F.obj Y\n‚ä¢ Eq (F.map f.hom (F.map f.inv y)) y","decl":"@[simp]\ntheorem map_hom_map_inv_apply (f : X ‚âÖ Y) (y : F.obj Y) : F.map f.hom (F.map f.inv y) = y :=\n  congr_fun (F.mapIso f).inv_hom_id y\n\n"}
{"name":"CategoryTheory.FunctorToTypes.hom_inv_id_app_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nŒ± : CategoryTheory.Iso F G\nX : C\nx : F.obj X\n‚ä¢ Eq (Œ±.inv.app X (Œ±.hom.app X x)) x","decl":"@[simp]\ntheorem hom_inv_id_app_apply (Œ± : F ‚âÖ G) (X) (x) : Œ±.inv.app X (Œ±.hom.app X x) = x :=\n  congr_fun (Œ±.hom_inv_id_app X) x\n\n"}
{"name":"CategoryTheory.FunctorToTypes.inv_hom_id_app_apply","module":"Mathlib.CategoryTheory.Types","initialProofState":"C : Type u\ninst‚úù : CategoryTheory.Category.{v, u} C\nF G : CategoryTheory.Functor C (Type w)\nŒ± : CategoryTheory.Iso F G\nX : C\nx : G.obj X\n‚ä¢ Eq (Œ±.hom.app X (Œ±.inv.app X x)) x","decl":"@[simp]\ntheorem inv_hom_id_app_apply (Œ± : F ‚âÖ G) (X) (x) : Œ±.hom.app X (Œ±.inv.app X x) = x :=\n  congr_fun (Œ±.inv_hom_id_app X) x\n\n"}
{"name":"CategoryTheory.uliftFunctor_obj","module":"Mathlib.CategoryTheory.Types","initialProofState":"X : Type u\n‚ä¢ Eq (CategoryTheory.uliftFunctor.{v, u}.obj X) (ULift.{v, u} X)","decl":"@[simp]\ntheorem uliftFunctor_obj {X : Type u} : uliftFunctor.obj.{v} X = ULift.{v} X :=\n  rfl\n\n"}
{"name":"CategoryTheory.uliftFunctor_map","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\nx : ULift.{v, u} X\n‚ä¢ Eq (CategoryTheory.uliftFunctor.{v, u}.map f x) { down := f x.down }","decl":"@[simp]\ntheorem uliftFunctor_map {X Y : Type u} (f : X ‚ü∂ Y) (x : ULift.{v} X) :\n    uliftFunctor.map f x = ULift.up (f x.down) :=\n  rfl\n\n"}
{"name":"CategoryTheory.uliftFunctor_full","module":"Mathlib.CategoryTheory.Types","initialProofState":"‚ä¢ CategoryTheory.uliftFunctor.{u_1, u}.Full","decl":"instance uliftFunctor_full : Functor.Full.{u} uliftFunctor where\n  map_surjective f := ‚ü®fun x => (f (ULift.up x)).down, rfl‚ü©\n\n"}
{"name":"CategoryTheory.uliftFunctor_faithful","module":"Mathlib.CategoryTheory.Types","initialProofState":"‚ä¢ CategoryTheory.uliftFunctor.{u_2, u_1}.Faithful","decl":"instance uliftFunctor_faithful : uliftFunctor.Faithful where\n  map_injective {_X} {_Y} f g p :=\n    funext fun x =>\n      congr_arg ULift.down (congr_fun p (ULift.up x) : ULift.up (f x) = ULift.up (g x))\n\n"}
{"name":"CategoryTheory.homOfElement_eq_iff","module":"Mathlib.CategoryTheory.Types","initialProofState":"X : Type u\nx y : X\n‚ä¢ Iff (Eq (CategoryTheory.homOfElement x) (CategoryTheory.homOfElement y)) (Eq x y)","decl":"theorem homOfElement_eq_iff {X : Type u} (x y : X) : homOfElement x = homOfElement y ‚Üî x = y :=\n  ‚ü®fun H => congr_fun H PUnit.unit, by aesop‚ü©\n\n"}
{"name":"CategoryTheory.mono_iff_injective","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.Mono f) (Function.Injective f)","decl":"/-- A morphism in `Type` is a monomorphism if and only if it is injective. -/\n@[stacks 003C]\ntheorem mono_iff_injective {X Y : Type u} (f : X ‚ü∂ Y) : Mono f ‚Üî Function.Injective f := by\n  constructor\n  ¬∑ intro H x x' h\n    rw [‚Üê homOfElement_eq_iff] at h ‚ä¢\n    exact (cancel_mono f).mp h\n  ¬∑ exact fun H => ‚ü®fun g g' h => H.comp_left h‚ü©\n\n"}
{"name":"CategoryTheory.injective_of_mono","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\nhf : CategoryTheory.Mono f\n‚ä¢ Function.Injective f","decl":"theorem injective_of_mono {X Y : Type u} (f : X ‚ü∂ Y) [hf : Mono f] : Function.Injective f :=\n  (mono_iff_injective f).1 hf\n\n"}
{"name":"CategoryTheory.epi_iff_surjective","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.Epi f) (Function.Surjective f)","decl":"/-- A morphism in `Type` is an epimorphism if and only if it is surjective. -/\n@[stacks 003C]\ntheorem epi_iff_surjective {X Y : Type u} (f : X ‚ü∂ Y) : Epi f ‚Üî Function.Surjective f := by\n  constructor\n  ¬∑ rintro ‚ü®H‚ü©\n    refine Function.surjective_of_right_cancellable_Prop fun g‚ÇÅ g‚ÇÇ hg => ?_\n    rw [‚Üê Equiv.ulift.symm.injective.comp_left.eq_iff]\n    apply H\n    change ULift.up ‚àò g‚ÇÅ ‚àò f = ULift.up ‚àò g‚ÇÇ ‚àò f\n    rw [hg]\n  ¬∑ exact fun H => ‚ü®fun g g' h => H.injective_comp_right h‚ü©\n\n"}
{"name":"CategoryTheory.surjective_of_epi","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\nhf : CategoryTheory.Epi f\n‚ä¢ Function.Surjective f","decl":"theorem surjective_of_epi {X Y : Type u} (f : X ‚ü∂ Y) [hf : Epi f] : Function.Surjective f :=\n  (epi_iff_surjective f).1 hf\n\n"}
{"name":"CategoryTheory.ofTypeFunctor_obj","module":"Mathlib.CategoryTheory.Types","initialProofState":"m : Type u ‚Üí Type v\ninst‚úù¬π : Functor m\ninst‚úù : LawfulFunctor m\n‚ä¢ Eq (CategoryTheory.ofTypeFunctor m).obj m","decl":"@[simp]\ntheorem ofTypeFunctor_obj : (ofTypeFunctor m).obj = m :=\n  rfl\n\n"}
{"name":"CategoryTheory.ofTypeFunctor_map","module":"Mathlib.CategoryTheory.Types","initialProofState":"m : Type u ‚Üí Type v\ninst‚úù¬π : Functor m\ninst‚úù : LawfulFunctor m\nŒ± Œ≤ : Type u\nf : Œ± ‚Üí Œ≤\n‚ä¢ Eq ((CategoryTheory.ofTypeFunctor m).map f) (Functor.map f)","decl":"@[simp]\ntheorem ofTypeFunctor_map {Œ± Œ≤} (f : Œ± ‚Üí Œ≤) :\n    (ofTypeFunctor m).map f = (Functor.map f : m Œ± ‚Üí m Œ≤) :=\n  rfl\n\n"}
{"name":"Equiv.toIso_hom","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ne : Equiv X Y\n‚ä¢ Eq e.toIso.hom ‚áëe","decl":"@[simp]\ntheorem toIso_hom {e : X ‚âÉ Y} : e.toIso.hom = e :=\n  rfl\n\n"}
{"name":"Equiv.toIso_inv","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ne : Equiv X Y\n‚ä¢ Eq e.toIso.inv ‚áëe.symm","decl":"@[simp]\ntheorem toIso_inv {e : X ‚âÉ Y} : e.toIso.inv = e.symm :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.toEquiv_fun","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (‚áëi.toEquiv) i.hom","decl":"@[simp]\ntheorem toEquiv_fun (i : X ‚âÖ Y) : (i.toEquiv : X ‚Üí Y) = i.hom :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.toEquiv_symm_fun","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (‚áëi.toEquiv.symm) i.inv","decl":"@[simp]\ntheorem toEquiv_symm_fun (i : X ‚âÖ Y) : (i.toEquiv.symm : Y ‚Üí X) = i.inv :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.toEquiv_id","module":"Mathlib.CategoryTheory.Types","initialProofState":"X : Type u\n‚ä¢ Eq (CategoryTheory.Iso.refl X).toEquiv (Equiv.refl X)","decl":"@[simp]\ntheorem toEquiv_id (X : Type u) : (Iso.refl X).toEquiv = Equiv.refl X :=\n  rfl\n\n"}
{"name":"CategoryTheory.Iso.toEquiv_comp","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y Z : Type u\nf : CategoryTheory.Iso X Y\ng : CategoryTheory.Iso Y Z\n‚ä¢ Eq (f.trans g).toEquiv (f.toEquiv.trans g.toEquiv)","decl":"@[simp]\ntheorem toEquiv_comp {X Y Z : Type u} (f : X ‚âÖ Y) (g : Y ‚âÖ Z) :\n    (f ‚â™‚â´ g).toEquiv = f.toEquiv.trans g.toEquiv :=\n  rfl\n\n"}
{"name":"CategoryTheory.isIso_iff_bijective","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\nf : Quiver.Hom X Y\n‚ä¢ Iff (CategoryTheory.IsIso f) (Function.Bijective f)","decl":"/-- A morphism in `Type u` is an isomorphism if and only if it is bijective. -/\ntheorem isIso_iff_bijective {X Y : Type u} (f : X ‚ü∂ Y) : IsIso f ‚Üî Function.Bijective f :=\n  Iff.intro (fun _ => (asIso f : X ‚âÖ Y).toEquiv.bijective) fun b =>\n    (Equiv.ofBijective f b).toIso.isIso_hom\n\n"}
{"name":"CategoryTheory.instSplitEpiCategoryType","module":"Mathlib.CategoryTheory.Types","initialProofState":"‚ä¢ CategoryTheory.SplitEpiCategory (Type u)","decl":"instance : SplitEpiCategory (Type u) where\n  isSplitEpi_of_epi f hf :=\n    IsSplitEpi.mk' <|\n      { section_ := Function.surjInv <| (epi_iff_surjective f).1 hf\n        id := funext <| Function.rightInverse_surjInv <| (epi_iff_surjective f).1 hf }\n\n"}
{"name":"equivIsoIso_inv","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ni : CategoryTheory.Iso X Y\n‚ä¢ Eq (equivIsoIso.inv i) i.toEquiv","decl":"/-- Equivalences (between types in the same universe) are the same as (isomorphic to) isomorphisms\nof types. -/\n@[simps]\ndef equivIsoIso {X Y : Type u} : X ‚âÉ Y ‚âÖ X ‚âÖ Y where\n  hom e := e.toIso\n  inv i := i.toEquiv\n\n"}
{"name":"equivIsoIso_hom","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ne : Equiv X Y\n‚ä¢ Eq (equivIsoIso.hom e) e.toIso","decl":"/-- Equivalences (between types in the same universe) are the same as (isomorphic to) isomorphisms\nof types. -/\n@[simps]\ndef equivIsoIso {X Y : Type u} : X ‚âÉ Y ‚âÖ X ‚âÖ Y where\n  hom e := e.toIso\n  inv i := i.toEquiv\n\n"}
{"name":"equivEquivIso_hom","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ne : Equiv X Y\n‚ä¢ Eq (equivEquivIso e) e.toIso","decl":"@[simp]\ntheorem equivEquivIso_hom {X Y : Type u} (e : X ‚âÉ Y) : equivEquivIso e = e.toIso :=\n  rfl\n\n"}
{"name":"equivEquivIso_inv","module":"Mathlib.CategoryTheory.Types","initialProofState":"X Y : Type u\ne : CategoryTheory.Iso X Y\n‚ä¢ Eq (equivEquivIso.symm e) e.toEquiv","decl":"@[simp]\ntheorem equivEquivIso_inv {X Y : Type u} (e : X ‚âÖ Y) : equivEquivIso.symm e = e.toEquiv :=\n  rfl\n"}
