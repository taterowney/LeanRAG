{"name":"MeasureTheory.Measure.sub_def","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ Eq (HSub.hSub μ ν) (InfSet.sInf (setOf fun d => LE.le μ (HAdd.hAdd d ν)))","decl":"theorem sub_def : μ - ν = sInf { d | μ ≤ d + ν } := rfl\n\n"}
{"name":"MeasureTheory.Measure.sub_le_of_le_add","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν d : MeasureTheory.Measure α\nh : LE.le μ (HAdd.hAdd d ν)\n⊢ LE.le (HSub.hSub μ ν) d","decl":"theorem sub_le_of_le_add {d} (h : μ ≤ d + ν) : μ - ν ≤ d :=\n  sInf_le h\n\n"}
{"name":"MeasureTheory.Measure.sub_eq_zero_of_le","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\nh : LE.le μ ν\n⊢ Eq (HSub.hSub μ ν) 0","decl":"theorem sub_eq_zero_of_le (h : μ ≤ ν) : μ - ν = 0 :=\n  nonpos_iff_eq_zero'.1 <| sub_le_of_le_add <| by rwa [zero_add]\n\n"}
{"name":"MeasureTheory.Measure.sub_le","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\n⊢ LE.le (HSub.hSub μ ν) μ","decl":"theorem sub_le : μ - ν ≤ μ :=\n  sub_le_of_le_add <| Measure.le_add_right le_rfl\n\n"}
{"name":"MeasureTheory.Measure.sub_top","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (HSub.hSub μ Top.top) 0","decl":"@[simp]\ntheorem sub_top : μ - ⊤ = 0 :=\n  sub_eq_zero_of_le le_top\n\n"}
{"name":"MeasureTheory.Measure.zero_sub","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (HSub.hSub 0 μ) 0","decl":"@[simp]\ntheorem zero_sub : 0 - μ = 0 :=\n  sub_eq_zero_of_le μ.zero_le\n\n"}
{"name":"MeasureTheory.Measure.sub_self","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\n⊢ Eq (HSub.hSub μ μ) 0","decl":"@[simp]\ntheorem sub_self : μ - μ = 0 :=\n  sub_eq_zero_of_le le_rfl\n\n"}
{"name":"MeasureTheory.Measure.sub_apply","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\ninst✝ : MeasureTheory.IsFiniteMeasure ν\nh₁ : MeasurableSet s\nh₂ : LE.le ν μ\n⊢ Eq ((HSub.hSub μ ν) s) (HSub.hSub (μ s) (ν s))","decl":"/-- This application lemma only works in special circumstances. Given knowledge of\nwhen `μ ≤ ν` and `ν ≤ μ`, a more general application lemma can be written. -/\ntheorem sub_apply [IsFiniteMeasure ν] (h₁ : MeasurableSet s) (h₂ : ν ≤ μ) :\n    (μ - ν) s = μ s - ν s := by\n  -- We begin by defining `measure_sub`, which will be equal to `(μ - ν)`.\n  let measure_sub : Measure α := MeasureTheory.Measure.ofMeasurable\n    (fun (t : Set α) (_ : MeasurableSet t) => μ t - ν t) (by simp)\n    (fun g h_meas h_disj ↦ by\n      simp only [measure_iUnion h_disj h_meas]\n      rw [ENNReal.tsum_sub _ (h₂ <| g ·)]\n      rw [← measure_iUnion h_disj h_meas]\n      apply measure_ne_top)\n  -- Now, we demonstrate `μ - ν = measure_sub`, and apply it.\n  have h_measure_sub_add : ν + measure_sub = μ := by\n    ext1 t h_t_measurable_set\n    simp only [Pi.add_apply, coe_add]\n    rw [MeasureTheory.Measure.ofMeasurable_apply _ h_t_measurable_set, add_comm,\n      tsub_add_cancel_of_le (h₂ t)]\n  have h_measure_sub_eq : μ - ν = measure_sub := by\n    rw [MeasureTheory.Measure.sub_def]\n    apply le_antisymm\n    · apply sInf_le\n      simp [le_refl, add_comm, h_measure_sub_add]\n    apply le_sInf\n    intro d h_d\n    rw [← h_measure_sub_add, mem_setOf_eq, add_comm d] at h_d\n    apply Measure.le_of_add_le_add_left h_d\n  rw [h_measure_sub_eq]\n  apply Measure.ofMeasurable_apply _ h₁\n\n"}
{"name":"MeasureTheory.Measure.sub_add_cancel_of_le","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure ν\nh₁ : LE.le ν μ\n⊢ Eq (HAdd.hAdd (HSub.hSub μ ν) ν) μ","decl":"theorem sub_add_cancel_of_le [IsFiniteMeasure ν] (h₁ : ν ≤ μ) : μ - ν + ν = μ := by\n  ext1 s h_s_meas\n  rw [add_apply, sub_apply h_s_meas h₁, tsub_add_cancel_of_le (h₁ s)]\n\n"}
{"name":"MeasureTheory.Measure.add_sub_cancel","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure ν\n⊢ Eq (HSub.hSub (HAdd.hAdd μ ν) ν) μ","decl":"@[simp]\nprotected lemma add_sub_cancel [IsFiniteMeasure ν] : μ + ν - ν = μ := by\n  ext1 s hs\n  rw [sub_apply hs (Measure.le_add_left (le_refl _)), add_apply,\n    ENNReal.add_sub_cancel_right (measure_ne_top ν s)]\n\n"}
{"name":"MeasureTheory.Measure.restrict_sub_eq_restrict_sub_restrict","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\nh_meas_s : MeasurableSet s\n⊢ Eq ((HSub.hSub μ ν).restrict s) (HSub.hSub (μ.restrict s) (ν.restrict s))","decl":"theorem restrict_sub_eq_restrict_sub_restrict (h_meas_s : MeasurableSet s) :\n    (μ - ν).restrict s = μ.restrict s - ν.restrict s := by\n  repeat rw [sub_def]\n  have h_nonempty : { d | μ ≤ d + ν }.Nonempty := ⟨μ, Measure.le_add_right le_rfl⟩\n  rw [restrict_sInf_eq_sInf_restrict h_nonempty h_meas_s]\n  apply le_antisymm\n  · refine sInf_le_sInf_of_forall_exists_le ?_\n    intro ν' h_ν'_in\n    rw [mem_setOf_eq] at h_ν'_in\n    refine ⟨ν'.restrict s, ?_, restrict_le_self⟩\n    refine ⟨ν' + (⊤ : Measure α).restrict sᶜ, ?_, ?_⟩\n    · rw [mem_setOf_eq, add_right_comm, Measure.le_iff]\n      intro t h_meas_t\n      repeat rw [← measure_inter_add_diff t h_meas_s]\n      refine add_le_add ?_ ?_\n      · rw [add_apply, add_apply]\n        apply le_add_right _\n        rw [← restrict_eq_self μ inter_subset_right,\n          ← restrict_eq_self ν inter_subset_right]\n        apply h_ν'_in\n      · rw [add_apply, restrict_apply (h_meas_t.diff h_meas_s), diff_eq, inter_assoc, inter_self,\n          ← add_apply]\n        have h_mu_le_add_top : μ ≤ ν' + ν + ⊤ := by simp only [add_top, le_top]\n        exact Measure.le_iff'.1 h_mu_le_add_top _\n    · ext1 t h_meas_t\n      simp [restrict_apply h_meas_t, restrict_apply (h_meas_t.inter h_meas_s), inter_assoc]\n  · refine sInf_le_sInf_of_forall_exists_le ?_\n    refine forall_mem_image.2 fun t h_t_in => ⟨t.restrict s, ?_, le_rfl⟩\n    rw [Set.mem_setOf_eq, ← restrict_add]\n    exact restrict_mono Subset.rfl h_t_in\n\n"}
{"name":"MeasureTheory.Measure.sub_apply_eq_zero_of_restrict_le_restrict","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ns : Set α\nh_le : LE.le (μ.restrict s) (ν.restrict s)\nh_meas_s : MeasurableSet s\n⊢ Eq ((HSub.hSub μ ν) s) 0","decl":"theorem sub_apply_eq_zero_of_restrict_le_restrict (h_le : μ.restrict s ≤ ν.restrict s)\n    (h_meas_s : MeasurableSet s) : (μ - ν) s = 0 := by\n  rw [← restrict_apply_self, restrict_sub_eq_restrict_sub_restrict, sub_eq_zero_of_le] <;> simp [*]\n\n"}
{"name":"MeasureTheory.Measure.isFiniteMeasure_sub","module":"Mathlib.MeasureTheory.Measure.Sub","initialProofState":"α : Type u_1\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝ : MeasureTheory.IsFiniteMeasure μ\n⊢ MeasureTheory.IsFiniteMeasure (HSub.hSub μ ν)","decl":"instance isFiniteMeasure_sub [IsFiniteMeasure μ] : IsFiniteMeasure (μ - ν) :=\n  isFiniteMeasure_of_le μ sub_le\n\n"}
