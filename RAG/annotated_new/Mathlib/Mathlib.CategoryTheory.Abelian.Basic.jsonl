{"name":"CategoryTheory.Abelian.toIsNormalEpiCategory","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Abelian C\n⊢ CategoryTheory.IsNormalEpiCategory C","decl":"/-- A (preadditive) category `C` is called abelian if it has all finite products,\nall kernels and cokernels, and if every monomorphism is the kernel of some morphism\nand every epimorphism is the cokernel of some morphism.\n\n(This definition implies the existence of zero objects:\nfinite products give a terminal object, and in a preadditive category\nany terminal object is a zero object.)\n-/\nclass Abelian extends Preadditive C, IsNormalMonoCategory C, IsNormalEpiCategory C where\n  [has_finite_products : HasFiniteProducts C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n\n"}
{"name":"CategoryTheory.Abelian.toIsNormalMonoCategory","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Abelian C\n⊢ CategoryTheory.IsNormalMonoCategory C","decl":"/-- A (preadditive) category `C` is called abelian if it has all finite products,\nall kernels and cokernels, and if every monomorphism is the kernel of some morphism\nand every epimorphism is the cokernel of some morphism.\n\n(This definition implies the existence of zero objects:\nfinite products give a terminal object, and in a preadditive category\nany terminal object is a zero object.)\n-/\nclass Abelian extends Preadditive C, IsNormalMonoCategory C, IsNormalEpiCategory C where\n  [has_finite_products : HasFiniteProducts C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n\n"}
{"name":"CategoryTheory.Abelian.has_finite_products","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasFiniteProducts C","decl":"/-- A (preadditive) category `C` is called abelian if it has all finite products,\nall kernels and cokernels, and if every monomorphism is the kernel of some morphism\nand every epimorphism is the cokernel of some morphism.\n\n(This definition implies the existence of zero objects:\nfinite products give a terminal object, and in a preadditive category\nany terminal object is a zero object.)\n-/\nclass Abelian extends Preadditive C, IsNormalMonoCategory C, IsNormalEpiCategory C where\n  [has_finite_products : HasFiniteProducts C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n\n"}
{"name":"CategoryTheory.Abelian.has_cokernels","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasCokernels C","decl":"/-- A (preadditive) category `C` is called abelian if it has all finite products,\nall kernels and cokernels, and if every monomorphism is the kernel of some morphism\nand every epimorphism is the cokernel of some morphism.\n\n(This definition implies the existence of zero objects:\nfinite products give a terminal object, and in a preadditive category\nany terminal object is a zero object.)\n-/\nclass Abelian extends Preadditive C, IsNormalMonoCategory C, IsNormalEpiCategory C where\n  [has_finite_products : HasFiniteProducts C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n\n"}
{"name":"CategoryTheory.Abelian.has_kernels","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nself : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasKernels C","decl":"/-- A (preadditive) category `C` is called abelian if it has all finite products,\nall kernels and cokernels, and if every monomorphism is the kernel of some morphism\nand every epimorphism is the cokernel of some morphism.\n\n(This definition implies the existence of zero objects:\nfinite products give a terminal object, and in a preadditive category\nany terminal object is a zero object.)\n-/\nclass Abelian extends Preadditive C, IsNormalMonoCategory C, IsNormalEpiCategory C where\n  [has_finite_products : HasFiniteProducts C]\n  [has_kernels : HasKernels C]\n  [has_cokernels : HasCokernels C]\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation_m","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation f).m (CategoryTheory.Limits.kernel.ι (CategoryTheory.Limits.cokernel.π f))","decl":"/-- The factorisation of a morphism through its abelian image. -/\n@[simps]\ndef imageMonoFactorisation {X Y : C} (f : X ⟶ Y) : MonoFactorisation f where\n  I := Abelian.image f\n  m := kernel.ι _\n  m_mono := inferInstance\n  e := kernel.lift _ f (cokernel.condition _)\n  fac := kernel.lift_ι _ _ _\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation_I","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation f).I (CategoryTheory.Abelian.image f)","decl":"/-- The factorisation of a morphism through its abelian image. -/\n@[simps]\ndef imageMonoFactorisation {X Y : C} (f : X ⟶ Y) : MonoFactorisation f where\n  I := Abelian.image f\n  m := kernel.ι _\n  m_mono := inferInstance\n  e := kernel.lift _ f (cokernel.condition _)\n  fac := kernel.lift_ι _ _ _\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation_e","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation f).e (CategoryTheory.Limits.kernel.lift (CategoryTheory.Limits.cokernel.π f) f ⋯)","decl":"/-- The factorisation of a morphism through its abelian image. -/\n@[simps]\ndef imageMonoFactorisation {X Y : C} (f : X ⟶ Y) : MonoFactorisation f where\n  I := Abelian.image f\n  m := kernel.ι _\n  m_mono := inferInstance\n  e := kernel.lift _ f (cokernel.condition _)\n  fac := kernel.lift_ι _ _ _\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation_e'","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Preadditive C\ninst✝¹ : CategoryTheory.Limits.HasKernels C\ninst✝ : CategoryTheory.Limits.HasCokernels C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation f).e (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.cokernel.π (CategoryTheory.Limits.kernel.ι f)) (CategoryTheory.Abelian.coimageImageComparison f))","decl":"theorem imageMonoFactorisation_e' {X Y : C} (f : X ⟶ Y) :\n    (imageMonoFactorisation f).e = cokernel.π _ ≫ Abelian.coimageImageComparison f := by\n  dsimp\n  ext\n  simp only [Abelian.coimageImageComparison, imageMonoFactorisation_e, Category.assoc,\n    cokernel.π_desc_assoc]\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.instIsIsoEImageMonoFactorisationOfHasZeroObjectOfMonoOfCoimageImageComparison","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁶ : CategoryTheory.Category.{v, u} C\ninst✝⁵ : CategoryTheory.Preadditive C\ninst✝⁴ : CategoryTheory.Limits.HasKernels C\ninst✝³ : CategoryTheory.Limits.HasCokernels C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\ninst✝¹ : CategoryTheory.Mono f\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation f).e","decl":"instance [HasZeroObject C] {X Y : C} (f : X ⟶ Y) [Mono f]\n    [IsIso (Abelian.coimageImageComparison f)] : IsIso (imageMonoFactorisation f).e := by\n  rw [imageMonoFactorisation_e']\n  exact IsIso.comp_isIso\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.instIsIsoMImageMonoFactorisationOfHasZeroObjectOfEpi","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.imageMonoFactorisation f).m","decl":"instance [HasZeroObject C] {X Y : C} (f : X ⟶ Y) [Epi f] : IsIso (imageMonoFactorisation f).m := by\n  dsimp\n  infer_instance\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.hasImages","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Preadditive C\ninst✝² : CategoryTheory.Limits.HasKernels C\ninst✝¹ : CategoryTheory.Limits.HasCokernels C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)\n⊢ CategoryTheory.Limits.HasImages C","decl":"/-- A category in which coimage-image comparisons are all isomorphisms has images. -/\ntheorem hasImages : HasImages C :=\n  { has_image := fun {_} {_} f => { exists_image := ⟨imageFactorisation f⟩ } }\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.isNormalMonoCategory","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ CategoryTheory.IsNormalMonoCategory C","decl":"/-- A category with finite products in which coimage-image comparisons are all isomorphisms\nis a normal mono category.\n-/\nlemma isNormalMonoCategory : IsNormalMonoCategory C where\n  normalMonoOfMono f m := ⟨{\n      Z := _\n      g := cokernel.π f\n      w := by simp\n      isLimit := by\n        haveI : Limits.HasImages C := hasImages\n        haveI : HasEqualizers C := Preadditive.hasEqualizers_of_hasKernels\n        haveI : HasZeroObject C := Limits.hasZeroObject_of_hasFiniteBiproducts _\n        have aux : ∀ (s : KernelFork (cokernel.π f)), (limit.lift (parallelPair (cokernel.π f) 0) s\n          ≫ inv (imageMonoFactorisation f).e) ≫ Fork.ι (KernelFork.ofι f (by simp))\n            = Fork.ι s := ?_\n        · refine isLimitAux _ (fun A => limit.lift _ _ ≫ inv (imageMonoFactorisation f).e) aux ?_\n          intro A g hg\n          rw [KernelFork.ι_ofι] at hg\n          rw [← cancel_mono f, hg, ← aux, KernelFork.ι_ofι]\n        · intro A\n          simp only [KernelFork.ι_ofι, Category.assoc]\n          convert limit.lift_π A WalkingParallelPair.zero using 2\n          rw [IsIso.inv_comp_eq, eq_comm]\n          exact (imageMonoFactorisation f).fac }⟩\n\n"}
{"name":"CategoryTheory.Abelian.OfCoimageImageComparisonIsIso.isNormalEpiCategory","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁵ : CategoryTheory.Category.{v, u} C\ninst✝⁴ : CategoryTheory.Preadditive C\ninst✝³ : CategoryTheory.Limits.HasKernels C\ninst✝² : CategoryTheory.Limits.HasCokernels C\ninst✝¹ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)\ninst✝ : CategoryTheory.Limits.HasFiniteProducts C\n⊢ CategoryTheory.IsNormalEpiCategory C","decl":"/-- A category with finite products in which coimage-image comparisons are all isomorphisms\nis a normal epi category.\n-/\nlemma isNormalEpiCategory : IsNormalEpiCategory C where\n  normalEpiOfEpi f m := ⟨{\n      W := kernel f\n      g := kernel.ι _\n      w := kernel.condition _\n      isColimit := by\n        haveI : Limits.HasImages C := hasImages\n        haveI : HasEqualizers C := Preadditive.hasEqualizers_of_hasKernels\n        haveI : HasZeroObject C := Limits.hasZeroObject_of_hasFiniteBiproducts _\n        have aux : ∀ (s : CokernelCofork (kernel.ι f)), Cofork.π (CokernelCofork.ofπ f (by simp)) ≫\n          inv (imageMonoFactorisation f).m ≫ inv (Abelian.coimageImageComparison f) ≫\n          colimit.desc (parallelPair (kernel.ι f) 0) s = Cofork.π s := ?_\n        · refine isColimitAux _ (fun A => inv (imageMonoFactorisation f).m ≫\n                  inv (Abelian.coimageImageComparison f) ≫ colimit.desc _ _) aux ?_\n          intro A g hg\n          rw [CokernelCofork.π_ofπ] at hg\n          rw [← cancel_epi f, hg, ← aux, CokernelCofork.π_ofπ]\n        · intro A\n          simp only [CokernelCofork.π_ofπ, ← Category.assoc]\n          convert colimit.ι_desc A WalkingParallelPair.one using 2\n          rw [IsIso.comp_inv_eq, IsIso.comp_inv_eq, eq_comm, ← imageMonoFactorisation_e']\n          exact (imageMonoFactorisation f).fac }⟩\n\n"}
{"name":"CategoryTheory.Abelian.hasFiniteBiproducts","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasFiniteBiproducts C","decl":"/-- An abelian category has finite biproducts. -/\ntheorem hasFiniteBiproducts : HasFiniteBiproducts C :=\n  Limits.HasFiniteBiproducts.of_hasFiniteProducts\n\n"}
{"name":"CategoryTheory.Abelian.hasBinaryBiproducts","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasBinaryBiproducts C","decl":"instance (priority := 100) hasBinaryBiproducts : HasBinaryBiproducts C :=\n  Limits.hasBinaryBiproducts_of_finite_biproducts _\n\n"}
{"name":"CategoryTheory.Abelian.hasZeroObject","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasZeroObject C","decl":"instance (priority := 100) hasZeroObject : HasZeroObject C :=\n  hasZeroObject_of_hasInitial_object\n\n"}
{"name":"CategoryTheory.Abelian.instEpiFactorThruImage","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ CategoryTheory.Epi (CategoryTheory.Abelian.factorThruImage f)","decl":"/-- The map `p : P ⟶ image f` is an epimorphism -/\ninstance : Epi (Abelian.factorThruImage f) := by infer_instance\n\n"}
{"name":"CategoryTheory.Abelian.isIso_factorThruImage","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.factorThruImage f)","decl":"instance isIso_factorThruImage [Mono f] : IsIso (Abelian.factorThruImage f) := by infer_instance\n\n"}
{"name":"CategoryTheory.Abelian.instMonoFactorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ CategoryTheory.Mono (CategoryTheory.Abelian.factorThruCoimage f)","decl":"/-- The canonical morphism `i : coimage f ⟶ Q` is a monomorphism -/\ninstance : Mono (Abelian.factorThruCoimage f) := by infer_instance\n\n"}
{"name":"CategoryTheory.Abelian.isIso_factorThruCoimage","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.factorThruCoimage f)","decl":"instance isIso_factorThruCoimage [Epi f] : IsIso (Abelian.factorThruCoimage f) := by infer_instance\n\n"}
{"name":"CategoryTheory.Abelian.mono_of_kernel_ι_eq_zero","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\nh : Eq (CategoryTheory.Limits.kernel.ι f) 0\n⊢ CategoryTheory.Mono f","decl":"theorem mono_of_kernel_ι_eq_zero (h : kernel.ι f = 0) : Mono f :=\n  mono_of_kernel_zero h\n\n"}
{"name":"CategoryTheory.Abelian.epi_of_cokernel_π_eq_zero","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\nh : Eq (CategoryTheory.Limits.cokernel.π f) 0\n⊢ CategoryTheory.Epi f","decl":"theorem epi_of_cokernel_π_eq_zero (h : cokernel.π f = 0) : Epi f := by\n  apply NormalMonoCategory.epi_of_zero_cokernel _ (cokernel f)\n  simp_rw [← h]\n  exact IsColimit.ofIsoColimit (colimit.isColimit (parallelPair f 0)) (isoOfπ _)\n\n"}
{"name":"CategoryTheory.Abelian.image_ι_comp_eq_zero","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\nR : C\ng : Quiver.Hom Q R\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.image.ι f) g) 0","decl":"theorem image_ι_comp_eq_zero {R : C} {g : Q ⟶ R} (h : f ≫ g = 0) : Abelian.image.ι f ≫ g = 0 :=\n  zero_of_epi_comp (Abelian.factorThruImage f) <| by simp [h]\n\n"}
{"name":"CategoryTheory.Abelian.comp_coimage_π_eq_zero","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\nR : C\ng : Quiver.Hom Q R\nh : Eq (CategoryTheory.CategoryStruct.comp f g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Abelian.coimage.π g)) 0","decl":"theorem comp_coimage_π_eq_zero {R : C} {g : Q ⟶ R} (h : f ≫ g = 0) : f ≫ Abelian.coimage.π g = 0 :=\n  zero_of_comp_mono (Abelian.factorThruCoimage g) <| by simp [h]\n\n"}
{"name":"CategoryTheory.Abelian.imageStrongEpiMonoFactorisation_I","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.imageStrongEpiMonoFactorisation f).I (CategoryTheory.Abelian.image f)","decl":"/-- Factoring through the image is a strong epi-mono factorisation. -/\n@[simps]\ndef imageStrongEpiMonoFactorisation : StrongEpiMonoFactorisation f where\n  I := Abelian.image f\n  m := image.ι f\n  m_mono := by infer_instance\n  e := Abelian.factorThruImage f\n  e_strong_epi := strongEpi_of_epi _\n\n"}
{"name":"CategoryTheory.Abelian.imageStrongEpiMonoFactorisation_e","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.imageStrongEpiMonoFactorisation f).e (CategoryTheory.Abelian.factorThruImage f)","decl":"/-- Factoring through the image is a strong epi-mono factorisation. -/\n@[simps]\ndef imageStrongEpiMonoFactorisation : StrongEpiMonoFactorisation f where\n  I := Abelian.image f\n  m := image.ι f\n  m_mono := by infer_instance\n  e := Abelian.factorThruImage f\n  e_strong_epi := strongEpi_of_epi _\n\n"}
{"name":"CategoryTheory.Abelian.imageStrongEpiMonoFactorisation_m","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.imageStrongEpiMonoFactorisation f).m (CategoryTheory.Abelian.image.ι f)","decl":"/-- Factoring through the image is a strong epi-mono factorisation. -/\n@[simps]\ndef imageStrongEpiMonoFactorisation : StrongEpiMonoFactorisation f where\n  I := Abelian.image f\n  m := image.ι f\n  m_mono := by infer_instance\n  e := Abelian.factorThruImage f\n  e_strong_epi := strongEpi_of_epi _\n\n"}
{"name":"CategoryTheory.Abelian.coimageStrongEpiMonoFactorisation_I","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.coimageStrongEpiMonoFactorisation f).I (CategoryTheory.Abelian.coimage f)","decl":"/-- Factoring through the coimage is a strong epi-mono factorisation. -/\n@[simps]\ndef coimageStrongEpiMonoFactorisation : StrongEpiMonoFactorisation f where\n  I := Abelian.coimage f\n  m := Abelian.factorThruCoimage f\n  m_mono := by infer_instance\n  e := coimage.π f\n  e_strong_epi := strongEpi_of_epi _\n\n"}
{"name":"CategoryTheory.Abelian.coimageStrongEpiMonoFactorisation_e","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.coimageStrongEpiMonoFactorisation f).e (CategoryTheory.Abelian.coimage.π f)","decl":"/-- Factoring through the coimage is a strong epi-mono factorisation. -/\n@[simps]\ndef coimageStrongEpiMonoFactorisation : StrongEpiMonoFactorisation f where\n  I := Abelian.coimage f\n  m := Abelian.factorThruCoimage f\n  m_mono := by infer_instance\n  e := coimage.π f\n  e_strong_epi := strongEpi_of_epi _\n\n"}
{"name":"CategoryTheory.Abelian.coimageStrongEpiMonoFactorisation_m","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nP Q : C\nf : Quiver.Hom P Q\n⊢ Eq (CategoryTheory.Abelian.coimageStrongEpiMonoFactorisation f).m (CategoryTheory.Abelian.factorThruCoimage f)","decl":"/-- Factoring through the coimage is a strong epi-mono factorisation. -/\n@[simps]\ndef coimageStrongEpiMonoFactorisation : StrongEpiMonoFactorisation f where\n  I := Abelian.coimage f\n  m := Abelian.factorThruCoimage f\n  m_mono := by infer_instance\n  e := coimage.π f\n  e_strong_epi := strongEpi_of_epi _\n\n"}
{"name":"CategoryTheory.Abelian.instHasStrongEpiMonoFactorisations","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasStrongEpiMonoFactorisations C","decl":"/-- An abelian category has strong epi-mono factorisations. -/\ninstance (priority := 100) : HasStrongEpiMonoFactorisations C :=\n  HasStrongEpiMonoFactorisations.mk fun f => imageStrongEpiMonoFactorisation f\n\n-- In particular, this means that it has well-behaved images.\n"}
{"name":"CategoryTheory.Abelian.instIsIsoCoimageImageComparison","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ CategoryTheory.IsIso (CategoryTheory.Abelian.coimageImageComparison f)","decl":"/-- The coimage-image comparison morphism is always an isomorphism in an abelian category.\nSee `CategoryTheory.Abelian.ofCoimageImageComparisonIsIso` for the converse.\n-/\ninstance : IsIso (coimageImageComparison f) := by\n  convert\n    Iso.isIso_hom\n      (IsImage.isoExt (coimageStrongEpiMonoFactorisation f).toMonoIsImage\n        (imageStrongEpiMonoFactorisation f).toMonoIsImage)\n  ext\n  change _ = _ ≫ (imageStrongEpiMonoFactorisation f).m\n  simp [-imageStrongEpiMonoFactorisation_m]\n\n"}
{"name":"CategoryTheory.Abelian.coimageIsoImage'_hom","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.coimageIsoImage' f).hom (CategoryTheory.Limits.cokernel.desc (CategoryTheory.Limits.kernel.ι f) (CategoryTheory.Limits.factorThruImage f) ⋯)","decl":"theorem coimageIsoImage'_hom :\n    (coimageIsoImage' f).hom =\n      cokernel.desc _ (factorThruImage f) (by simp [← cancel_mono (Limits.image.ι f)]) := by\n  ext\n  simp only [← cancel_mono (Limits.image.ι f), IsImage.isoExt_hom, cokernel.π_desc,\n    Category.assoc, IsImage.lift_ι, coimageStrongEpiMonoFactorisation_m,\n    Limits.image.fac]\n\n"}
{"name":"CategoryTheory.Abelian.factorThruImage_comp_coimageIsoImage'_inv","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.factorThruImage f) (CategoryTheory.Abelian.coimageIsoImage' f).inv) (CategoryTheory.Limits.cokernel.π (CategoryTheory.Limits.kernel.ι f))","decl":"theorem factorThruImage_comp_coimageIsoImage'_inv :\n    factorThruImage f ≫ (coimageIsoImage' f).inv = cokernel.π _ := by\n  simp only [IsImage.isoExt_inv, image.isImage_lift, image.fac_lift,\n    coimageStrongEpiMonoFactorisation_e]\n\n"}
{"name":"CategoryTheory.Abelian.imageIsoImage_hom_comp_image_ι","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.imageIsoImage f).hom (CategoryTheory.Limits.image.ι f)) (CategoryTheory.Limits.kernel.ι (CategoryTheory.Limits.cokernel.π f))","decl":"theorem imageIsoImage_hom_comp_image_ι : (imageIsoImage f).hom ≫ Limits.image.ι _ = kernel.ι _ := by\n  simp only [IsImage.isoExt_hom, IsImage.lift_ι, imageStrongEpiMonoFactorisation_m]\n\n"}
{"name":"CategoryTheory.Abelian.imageIsoImage_inv","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\n⊢ Eq (CategoryTheory.Abelian.imageIsoImage f).inv (CategoryTheory.Limits.kernel.lift (CategoryTheory.Limits.cokernel.π f) (CategoryTheory.Limits.image.ι f) ⋯)","decl":"theorem imageIsoImage_inv :\n    (imageIsoImage f).inv =\n      kernel.lift _ (Limits.image.ι f) (by simp [← cancel_epi (factorThruImage f)]) := by\n  ext\n  rw [IsImage.isoExt_inv, image.isImage_lift, Limits.image.fac_lift,\n    imageStrongEpiMonoFactorisation_e, Category.assoc, kernel.lift_ι, equalizer_as_kernel,\n    kernel.lift_ι, Limits.image.fac]\n\n"}
{"name":"CategoryTheory.Abelian.comp_epiDesc","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nT : C\ng : Quiver.Hom X T\nhg : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) g) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.Abelian.epiDesc f g hg)) g","decl":"@[reassoc (attr := simp)]\ntheorem comp_epiDesc [Epi f] {T : C} (g : X ⟶ T) (hg : kernel.ι f ≫ g = 0) :\n    f ≫ epiDesc f g hg = g :=\n  (epiIsCokernelOfKernel _ (limit.isLimit _)).fac (CokernelCofork.ofπ _ hg) WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.Abelian.comp_epiDesc_assoc","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Epi f\nT : C\ng : Quiver.Hom X T\nhg : Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.kernel.ι f) g) 0\nZ : C\nh : Quiver.Hom T Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.epiDesc f g hg) h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem comp_epiDesc [Epi f] {T : C} (g : X ⟶ T) (hg : kernel.ι f ≫ g = 0) :\n    f ≫ epiDesc f g hg = g :=\n  (epiIsCokernelOfKernel _ (limit.isLimit _)).fac (CokernelCofork.ofπ _ hg) WalkingParallelPair.one\n\n"}
{"name":"CategoryTheory.Abelian.monoLift_comp_assoc","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nT : C\ng : Quiver.Hom T Y\nhg : Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.cokernel.π f)) 0\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.monoLift f g hg) (CategoryTheory.CategoryStruct.comp f h)) (CategoryTheory.CategoryStruct.comp g h)","decl":"@[reassoc (attr := simp)]\ntheorem monoLift_comp [Mono f] {T : C} (g : T ⟶ Y) (hg : g ≫ cokernel.π f = 0) :\n    monoLift f g hg ≫ f = g :=\n  (monoIsKernelOfCokernel _ (colimit.isColimit _)).fac (KernelFork.ofι _ hg)\n    WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Abelian.monoLift_comp","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Abelian C\nX Y : C\nf : Quiver.Hom X Y\ninst✝ : CategoryTheory.Mono f\nT : C\ng : Quiver.Hom T Y\nhg : Eq (CategoryTheory.CategoryStruct.comp g (CategoryTheory.Limits.cokernel.π f)) 0\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Abelian.monoLift f g hg) f) g","decl":"@[reassoc (attr := simp)]\ntheorem monoLift_comp [Mono f] {T : C} (g : T ⟶ Y) (hg : g ≫ cokernel.π f = 0) :\n    monoLift f g hg ≫ f = g :=\n  (monoIsKernelOfCokernel _ (colimit.isColimit _)).fac (KernelFork.ofι _ hg)\n    WalkingParallelPair.zero\n\n"}
{"name":"CategoryTheory.Abelian.hasEqualizers","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasEqualizers C","decl":"instance (priority := 100) hasEqualizers : HasEqualizers C :=\n  Preadditive.hasEqualizers_of_hasKernels\n\n"}
{"name":"CategoryTheory.Abelian.hasPullbacks","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasPullbacks C","decl":"/-- Any abelian category has pullbacks -/\ninstance (priority := 100) hasPullbacks : HasPullbacks C :=\n  hasPullbacks_of_hasBinaryProducts_of_hasEqualizers C\n\n"}
{"name":"CategoryTheory.Abelian.hasCoequalizers","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasCoequalizers C","decl":"instance (priority := 100) hasCoequalizers : HasCoequalizers C :=\n  Preadditive.hasCoequalizers_of_hasCokernels\n\n"}
{"name":"CategoryTheory.Abelian.hasPushouts","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasPushouts C","decl":"/-- Any abelian category has pushouts -/\ninstance (priority := 100) hasPushouts : HasPushouts C :=\n  hasPushouts_of_hasBinaryCoproducts_of_hasCoequalizers C\n\n"}
{"name":"CategoryTheory.Abelian.hasFiniteLimits","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasFiniteLimits C","decl":"instance (priority := 100) hasFiniteLimits : HasFiniteLimits C :=\n  Limits.hasFiniteLimits_of_hasEqualizers_and_finite_products\n\n"}
{"name":"CategoryTheory.Abelian.hasFiniteColimits","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Abelian C\n⊢ CategoryTheory.Limits.HasFiniteColimits C","decl":"instance (priority := 100) hasFiniteColimits : HasFiniteColimits C :=\n  Limits.hasFiniteColimits_of_hasCoequalizers_and_finite_coproducts\n\n"}
{"name":"CategoryTheory.Abelian.epi_pullback_of_epi_f","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi f\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.pullback.snd f g)","decl":"/-- In an abelian category, the pullback of an epimorphism is an epimorphism.\n    Proof from [aluffi2016, IX.2.3], cf. [borceux-vol2, 1.7.6] -/\ninstance epi_pullback_of_epi_f [Epi f] : Epi (pullback.snd f g) :=\n  -- It will suffice to consider some morphism e : Y ⟶ R such that\n    -- pullback.snd f g ≫ e = 0 and show that e = 0.\n    epi_of_cancel_zero _ fun {R} e h => by\n    -- Consider the morphism u := (0, e) : X ⊞ Y⟶ R.\n    let u := biprod.desc (0 : X ⟶ R) e\n    -- The composite pullback f g ⟶ X ⊞ Y ⟶ R is zero by assumption.\n    have hu : PullbackToBiproductIsKernel.pullbackToBiproduct f g ≫ u = 0 := by simpa [u]\n    -- pullbackToBiproduct f g is a kernel of (f, -g), so (f, -g) is a\n    -- cokernel of pullbackToBiproduct f g\n    have :=\n      epiIsCokernelOfKernel _\n        (PullbackToBiproductIsKernel.isLimitPullbackToBiproduct f g)\n    -- We use this fact to obtain a factorization of u through (f, -g) via some d : Z ⟶ R.\n    obtain ⟨d, hd⟩ := CokernelCofork.IsColimit.desc' this u hu\n    dsimp at d; dsimp [u] at hd\n    -- But then f ≫ d = 0:\n    have : f ≫ d = 0 := calc\n      f ≫ d = (biprod.inl ≫ biprod.desc f (-g)) ≫ d := by rw [biprod.inl_desc]\n      _ = biprod.inl ≫ u := by rw [Category.assoc, hd]\n      _ = 0 := biprod.inl_desc _ _\n    -- But f is an epimorphism, so d = 0...\n    have : d = 0 := (cancel_epi f).1 (by simpa)\n    -- ...or, in other words, e = 0.\n    calc\n      e = biprod.inr ≫ biprod.desc (0 : X ⟶ R) e := by rw [biprod.inr_desc]\n      _ = biprod.inr ≫ biprod.desc f (-g) ≫ d := by rw [← hd]\n      _ = biprod.inr ≫ biprod.desc f (-g) ≫ 0 := by rw [this]\n      _ = (biprod.inr ≫ biprod.desc f (-g)) ≫ 0 := by rw [← Category.assoc]\n      _ = 0 := HasZeroMorphisms.comp_zero _ _\n\n"}
{"name":"CategoryTheory.Abelian.epi_pullback_of_epi_g","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi g\n⊢ CategoryTheory.Epi (CategoryTheory.Limits.pullback.fst f g)","decl":"/-- In an abelian category, the pullback of an epimorphism is an epimorphism. -/\ninstance epi_pullback_of_epi_g [Epi g] : Epi (pullback.fst f g) :=\n  -- It will suffice to consider some morphism e : X ⟶ R such that\n  -- pullback.fst f g ≫ e = 0 and show that e = 0.\n  epi_of_cancel_zero _ fun {R} e h => by\n    -- Consider the morphism u := (e, 0) : X ⊞ Y ⟶ R.\n    let u := biprod.desc e (0 : Y ⟶ R)\n    -- The composite pullback f g ⟶ X ⊞ Y ⟶ R is zero by assumption.\n    have hu : PullbackToBiproductIsKernel.pullbackToBiproduct f g ≫ u = 0 := by simpa [u]\n    -- pullbackToBiproduct f g is a kernel of (f, -g), so (f, -g) is a\n    -- cokernel of pullbackToBiproduct f g\n    have :=\n      epiIsCokernelOfKernel _\n        (PullbackToBiproductIsKernel.isLimitPullbackToBiproduct f g)\n    -- We use this fact to obtain a factorization of u through (f, -g) via some d : Z ⟶ R.\n    obtain ⟨d, hd⟩ := CokernelCofork.IsColimit.desc' this u hu\n    dsimp at d; dsimp [u] at hd\n    -- But then (-g) ≫ d = 0:\n    have : (-g) ≫ d = 0 := calc\n      (-g) ≫ d = (biprod.inr ≫ biprod.desc f (-g)) ≫ d := by rw [biprod.inr_desc]\n      _ = biprod.inr ≫ u := by rw [Category.assoc, hd]\n      _ = 0 := biprod.inr_desc _ _\n    -- But g is an epimorphism, thus so is -g, so d = 0...\n    have : d = 0 := (cancel_epi (-g)).1 (by simpa)\n    -- ...or, in other words, e = 0.\n    calc\n      e = biprod.inl ≫ biprod.desc e (0 : Y ⟶ R) := by rw [biprod.inl_desc]\n      _ = biprod.inl ≫ biprod.desc f (-g) ≫ d := by rw [← hd]\n      _ = biprod.inl ≫ biprod.desc f (-g) ≫ 0 := by rw [this]\n      _ = (biprod.inl ≫ biprod.desc f (-g)) ≫ 0 := by rw [← Category.assoc]\n      _ = 0 := HasZeroMorphisms.comp_zero _ _\n\n"}
{"name":"CategoryTheory.Abelian.epi_snd_of_isLimit","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi f\ns : CategoryTheory.Limits.PullbackCone f g\nhs : CategoryTheory.Limits.IsLimit s\n⊢ CategoryTheory.Epi s.snd","decl":"theorem epi_snd_of_isLimit [Epi f] {s : PullbackCone f g} (hs : IsLimit s) : Epi s.snd := by\n  haveI : Epi (NatTrans.app (limit.cone (cospan f g)).π WalkingCospan.right) :=\n    Abelian.epi_pullback_of_epi_f f g\n  apply epi_of_epi_fac (IsLimit.conePointUniqueUpToIso_hom_comp (limit.isLimit _) hs _)\n\n"}
{"name":"CategoryTheory.Abelian.epi_fst_of_isLimit","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPullbacks C\nX Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ninst✝ : CategoryTheory.Epi g\ns : CategoryTheory.Limits.PullbackCone f g\nhs : CategoryTheory.Limits.IsLimit s\n⊢ CategoryTheory.Epi s.fst","decl":"theorem epi_fst_of_isLimit [Epi g] {s : PullbackCone f g} (hs : IsLimit s) : Epi s.fst := by\n  haveI : Epi (NatTrans.app (limit.cone (cospan f g)).π WalkingCospan.left) :=\n    Abelian.epi_pullback_of_epi_g f g\n  apply epi_of_epi_fac (IsLimit.conePointUniqueUpToIso_hom_comp (limit.isLimit _) hs _)\n\n"}
{"name":"CategoryTheory.Abelian.epi_fst_of_factor_thru_epi_mono_factorization","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.Limits.HasPullbacks C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng₁ : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Epi g₁\ng₂ : Quiver.Hom W Z\ninst✝ : CategoryTheory.Mono g₂\nhg : Eq (CategoryTheory.CategoryStruct.comp g₁ g₂) g\nf' : Quiver.Hom X W\nhf : Eq (CategoryTheory.CategoryStruct.comp f' g₂) f\nt : CategoryTheory.Limits.PullbackCone f g\nht : CategoryTheory.Limits.IsLimit t\n⊢ CategoryTheory.Epi t.fst","decl":"/-- Suppose `f` and `g` are two morphisms with a common codomain and suppose we have written `g` as\n    an epimorphism followed by a monomorphism. If `f` factors through the mono part of this\n    factorization, then any pullback of `g` along `f` is an epimorphism. -/\ntheorem epi_fst_of_factor_thru_epi_mono_factorization (g₁ : Y ⟶ W) [Epi g₁] (g₂ : W ⟶ Z) [Mono g₂]\n    (hg : g₁ ≫ g₂ = g) (f' : X ⟶ W) (hf : f' ≫ g₂ = f) (t : PullbackCone f g) (ht : IsLimit t) :\n    Epi t.fst := by\n  apply epi_fst_of_isLimit _ _ (PullbackCone.isLimitOfFactors f g g₂ f' g₁ hf hg t ht)\n\n"}
{"name":"CategoryTheory.Abelian.mono_pushout_of_mono_f","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Mono f\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.pushout.inr f g)","decl":"instance mono_pushout_of_mono_f [Mono f] : Mono (pushout.inr _ _ : Z ⟶ pushout f g) :=\n  mono_of_cancel_zero _ fun {R} e h => by\n    let u := biprod.lift (0 : R ⟶ Y) e\n    have hu : u ≫ BiproductToPushoutIsCokernel.biproductToPushout f g = 0 := by simpa [u]\n    have :=\n      monoIsKernelOfCokernel _\n        (BiproductToPushoutIsCokernel.isColimitBiproductToPushout f g)\n    obtain ⟨d, hd⟩ := KernelFork.IsLimit.lift' this u hu\n    dsimp at d\n    dsimp [u] at hd\n    have : d ≫ f = 0 := calc\n      d ≫ f = d ≫ biprod.lift f (-g) ≫ biprod.fst := by rw [biprod.lift_fst]\n      _ = u ≫ biprod.fst := by rw [← Category.assoc, hd]\n      _ = 0 := biprod.lift_fst _ _\n    have : d = 0 := (cancel_mono f).1 (by simpa)\n    calc\n      e = biprod.lift (0 : R ⟶ Y) e ≫ biprod.snd := by rw [biprod.lift_snd]\n      _ = (d ≫ biprod.lift f (-g)) ≫ biprod.snd := by rw [← hd]\n      _ = (0 ≫ biprod.lift f (-g)) ≫ biprod.snd := by rw [this]\n      _ = 0 ≫ biprod.lift f (-g) ≫ biprod.snd := by rw [Category.assoc]\n      _ = 0 := zero_comp\n\n"}
{"name":"CategoryTheory.Abelian.mono_pushout_of_mono_g","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Mono g\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.pushout.inl f g)","decl":"instance mono_pushout_of_mono_g [Mono g] : Mono (pushout.inl f g) :=\n  mono_of_cancel_zero _ fun {R} e h => by\n    let u := biprod.lift e (0 : R ⟶ Z)\n    have hu : u ≫ BiproductToPushoutIsCokernel.biproductToPushout f g = 0 := by simpa [u]\n    have :=\n      monoIsKernelOfCokernel _\n        (BiproductToPushoutIsCokernel.isColimitBiproductToPushout f g)\n    obtain ⟨d, hd⟩ := KernelFork.IsLimit.lift' this u hu\n    dsimp at d\n    dsimp [u] at hd\n    have : d ≫ (-g) = 0 := calc\n      d ≫ (-g) = d ≫ biprod.lift f (-g) ≫ biprod.snd := by rw [biprod.lift_snd]\n      _ = biprod.lift e (0 : R ⟶ Z) ≫ biprod.snd := by rw [← Category.assoc, hd]\n      _ = 0 := biprod.lift_snd _ _\n    have : d = 0 := (cancel_mono (-g)).1 (by simpa)\n    calc\n      e = biprod.lift e (0 : R ⟶ Z) ≫ biprod.fst := by rw [biprod.lift_fst]\n      _ = (d ≫ biprod.lift f (-g)) ≫ biprod.fst := by rw [← hd]\n      _ = (0 ≫ biprod.lift f (-g)) ≫ biprod.fst := by rw [this]\n      _ = 0 ≫ biprod.lift f (-g) ≫ biprod.fst := by rw [Category.assoc]\n      _ = 0 := zero_comp\n\n"}
{"name":"CategoryTheory.Abelian.mono_inr_of_isColimit","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Mono f\ns : CategoryTheory.Limits.PushoutCocone f g\nhs : CategoryTheory.Limits.IsColimit s\n⊢ CategoryTheory.Mono s.inr","decl":"theorem mono_inr_of_isColimit [Mono f] {s : PushoutCocone f g} (hs : IsColimit s) : Mono s.inr := by\n  haveI : Mono (NatTrans.app (colimit.cocone (span f g)).ι WalkingCospan.right) :=\n    Abelian.mono_pushout_of_mono_f f g\n  apply\n    mono_of_mono_fac (IsColimit.comp_coconePointUniqueUpToIso_hom hs (colimit.isColimit _) _)\n\n"}
{"name":"CategoryTheory.Abelian.mono_inl_of_isColimit","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\ninst✝² : CategoryTheory.Abelian C\ninst✝¹ : CategoryTheory.Limits.HasPushouts C\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ninst✝ : CategoryTheory.Mono g\ns : CategoryTheory.Limits.PushoutCocone f g\nhs : CategoryTheory.Limits.IsColimit s\n⊢ CategoryTheory.Mono s.inl","decl":"theorem mono_inl_of_isColimit [Mono g] {s : PushoutCocone f g} (hs : IsColimit s) : Mono s.inl := by\n  haveI : Mono (NatTrans.app (colimit.cocone (span f g)).ι WalkingCospan.left) :=\n    Abelian.mono_pushout_of_mono_g f g\n  apply\n    mono_of_mono_fac (IsColimit.comp_coconePointUniqueUpToIso_hom hs (colimit.isColimit _) _)\n\n"}
{"name":"CategoryTheory.Abelian.mono_inl_of_factor_thru_epi_mono_factorization","module":"Mathlib.CategoryTheory.Abelian.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\ninst✝³ : CategoryTheory.Abelian C\ninst✝² : CategoryTheory.Limits.HasPushouts C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng₁ : Quiver.Hom X W\ninst✝¹ : CategoryTheory.Epi g₁\ng₂ : Quiver.Hom W Z\ninst✝ : CategoryTheory.Mono g₂\nhg : Eq (CategoryTheory.CategoryStruct.comp g₁ g₂) g\nf' : Quiver.Hom W Y\nhf : Eq (CategoryTheory.CategoryStruct.comp g₁ f') f\nt : CategoryTheory.Limits.PushoutCocone f g\nht : CategoryTheory.Limits.IsColimit t\n⊢ CategoryTheory.Mono t.inl","decl":"/-- Suppose `f` and `g` are two morphisms with a common domain and suppose we have written `g` as\n    an epimorphism followed by a monomorphism. If `f` factors through the epi part of this\n    factorization, then any pushout of `g` along `f` is a monomorphism. -/\ntheorem mono_inl_of_factor_thru_epi_mono_factorization (f : X ⟶ Y) (g : X ⟶ Z) (g₁ : X ⟶ W) [Epi g₁]\n    (g₂ : W ⟶ Z) [Mono g₂] (hg : g₁ ≫ g₂ = g) (f' : W ⟶ Y) (hf : g₁ ≫ f' = f)\n    (t : PushoutCocone f g) (ht : IsColimit t) : Mono t.inl := by\n  apply mono_inl_of_isColimit _ _ (PushoutCocone.isColimitOfFactors _ _ _ _ _ hf hg t ht)\n\n"}
