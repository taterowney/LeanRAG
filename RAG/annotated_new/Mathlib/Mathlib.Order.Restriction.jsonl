{"name":"Preorder.restrictLe_apply","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nπ : α → Type u_2\na : α\nf : (a : α) → π a\ni : ↑(Set.Iic a)\n⊢ Eq (Preorder.restrictLe a f i) (f ↑i)","decl":"@[simp]\nlemma restrictLe_apply (a : α) (f : (a : α) → π a) (i : Iic a) : restrictLe a f i = f i := rfl\n\n"}
{"name":"Preorder.restrictLe₂_apply","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nπ : α → Type u_2\na b : α\nhab : LE.le a b\nf : (i : ↑(Set.Iic b)) → π ↑i\ni : ↑(Set.Iic a)\n⊢ Eq (Preorder.restrictLe₂ hab f i) (f ⟨↑i, ⋯⟩)","decl":"@[simp]\nlemma restrictLe₂_apply {a b : α} (hab : a ≤ b) (f : (i : Iic b) → π i) (i : Iic a) :\n    restrictLe₂ hab f i = f ⟨i.1, Iic_subset_Iic.2 hab i.2⟩ := rfl\n\n"}
{"name":"Preorder.restrictLe₂_comp_restrictLe","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nπ : α → Type u_2\na b : α\nhab : LE.le a b\n⊢ Eq (Function.comp (Preorder.restrictLe₂ hab) (Preorder.restrictLe b)) (Preorder.restrictLe a)","decl":"theorem restrictLe₂_comp_restrictLe {a b : α} (hab : a ≤ b) :\n    (restrictLe₂ (π := π) hab) ∘ (restrictLe b) = restrictLe a := rfl\n\n"}
{"name":"Preorder.restrictLe₂_comp_restrictLe₂","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝ : Preorder α\nπ : α → Type u_2\na b c : α\nhab : LE.le a b\nhbc : LE.le b c\n⊢ Eq (Function.comp (Preorder.restrictLe₂ hab) (Preorder.restrictLe₂ hbc)) (Preorder.restrictLe₂ ⋯)","decl":"theorem restrictLe₂_comp_restrictLe₂ {a b c : α} (hab : a ≤ b) (hbc : b ≤ c) :\n    (restrictLe₂ (π := π) hab) ∘ (restrictLe₂ hbc) = restrictLe₂ (hab.trans hbc) := rfl\n\n"}
{"name":"Preorder.frestrictLe_apply","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nπ : α → Type u_2\ninst✝ : LocallyFiniteOrderBot α\na : α\nf : (a : α) → π a\ni : Subtype fun x => Membership.mem (Finset.Iic a) x\n⊢ Eq (Preorder.frestrictLe a f i) (f ↑i)","decl":"@[simp]\nlemma frestrictLe_apply (a : α) (f : (a : α) → π a) (i : Iic a) : frestrictLe a f i = f i := rfl\n\n"}
{"name":"Preorder.frestrictLe₂_apply","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nπ : α → Type u_2\ninst✝ : LocallyFiniteOrderBot α\na b : α\nhab : LE.le a b\nf : (i : Subtype fun x => Membership.mem (Finset.Iic b) x) → π ↑i\ni : Subtype fun x => Membership.mem (Finset.Iic a) x\n⊢ Eq (Preorder.frestrictLe₂ hab f i) (f ⟨↑i, ⋯⟩)","decl":"@[simp]\nlemma frestrictLe₂_apply {a b : α} (hab : a ≤ b) (f : (i : Iic b) → π i) (i : Iic a) :\n    frestrictLe₂ hab f i = f ⟨i.1, Iic_subset_Iic.2 hab i.2⟩ := rfl\n\n"}
{"name":"Preorder.frestrictLe₂_comp_frestrictLe","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nπ : α → Type u_2\ninst✝ : LocallyFiniteOrderBot α\na b : α\nhab : LE.le a b\n⊢ Eq (Function.comp (Preorder.frestrictLe₂ hab) (Preorder.frestrictLe b)) (Preorder.frestrictLe a)","decl":"theorem frestrictLe₂_comp_frestrictLe {a b : α} (hab : a ≤ b) :\n    (frestrictLe₂ (π := π) hab) ∘ (frestrictLe b) = frestrictLe a := rfl\n\n"}
{"name":"Preorder.frestrictLe₂_comp_frestrictLe₂","module":"Mathlib.Order.Restriction","initialProofState":"α : Type u_1\ninst✝¹ : Preorder α\nπ : α → Type u_2\ninst✝ : LocallyFiniteOrderBot α\na b c : α\nhab : LE.le a b\nhbc : LE.le b c\n⊢ Eq (Function.comp (Preorder.frestrictLe₂ hab) (Preorder.frestrictLe₂ hbc)) (Preorder.frestrictLe₂ ⋯)","decl":"theorem frestrictLe₂_comp_frestrictLe₂ {a b c : α} (hab : a ≤ b) (hbc : b ≤ c) :\n    (frestrictLe₂ (π := π) hab) ∘ (frestrictLe₂ hbc) = frestrictLe₂ (hab.trans hbc) := rfl\n\n"}
