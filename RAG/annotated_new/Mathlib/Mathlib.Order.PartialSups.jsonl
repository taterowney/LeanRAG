{"name":"partialSups_apply","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\n⊢ Eq ((partialSups f) i) ((Finset.Iic i).sup' ⋯ f)","decl":"lemma partialSups_apply (f : ι → α) (i : ι) :\n    partialSups f i = (Iic i).sup' nonempty_Iic f :=\n  rfl\n\n"}
{"name":"partialSups_iff_forall","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\np : α → Prop\nhp : ∀ {a b : α}, Iff (p (Max.max a b)) (And (p a) (p b))\ni : ι\n⊢ Iff (p ((partialSups f) i)) (∀ (j : ι), LE.le j i → p (f j))","decl":"lemma partialSups_iff_forall {f : ι → α} (p : α → Prop)\n    (hp : ∀ {a b}, p (a ⊔ b) ↔ p a ∧ p b) {i : ι} :\n    p (partialSups f i) ↔ ∀ j ≤ i, p (f j) := by\n  classical\n  rw [partialSups_apply, comp_sup'_eq_sup'_comp (γ := Propᵒᵈ) _ p, sup'_eq_sup]\n  · show (Iic i).inf (p ∘ f) ↔ _\n    simp [Finset.inf_eq_iInf]\n  · intro x y\n    rw [hp]\n    rfl\n\n"}
{"name":"partialSups_le_iff","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\na : α\n⊢ Iff (LE.le ((partialSups f) i) a) (∀ (j : ι), LE.le j i → LE.le (f j) a)","decl":"@[simp]\nlemma partialSups_le_iff {f : ι → α} {i : ι} {a : α} :\n    partialSups f i ≤ a ↔ ∀ j ≤ i, f j ≤ a :=\n  partialSups_iff_forall (· ≤ a) sup_le_iff\n\n"}
{"name":"le_partialSups_of_le","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni j : ι\nh : LE.le i j\n⊢ LE.le (f i) ((partialSups f) j)","decl":"theorem le_partialSups_of_le (f : ι → α) {i j : ι} (h : i ≤ j) :\n    f i ≤ partialSups f j :=\n  partialSups_le_iff.1 le_rfl i h\n\n"}
{"name":"le_partialSups","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ LE.le f ⇑(partialSups f)","decl":"theorem le_partialSups (f : ι → α) :\n    f ≤ partialSups f :=\n  fun _ => le_partialSups_of_le f le_rfl\n\n"}
{"name":"partialSups_le","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\ni : ι\na : α\nw : ∀ (j : ι), LE.le j i → LE.le (f j) a\n⊢ LE.le ((partialSups f) i) a","decl":"theorem partialSups_le (f : ι → α) (i : ι) (a : α) (w : ∀ j ≤ i, f j ≤ a) :\n    partialSups f i ≤ a :=\n  partialSups_le_iff.2 w\n\n"}
{"name":"upperBounds_range_partialSups","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Eq (upperBounds (Set.range ⇑(partialSups f))) (upperBounds (Set.range f))","decl":"@[simp]\nlemma upperBounds_range_partialSups (f : ι → α) :\n    upperBounds (Set.range (partialSups f)) = upperBounds (Set.range f) := by\n  ext a\n  simp only [mem_upperBounds, Set.forall_mem_range, partialSups_le_iff]\n  exact ⟨fun h _ ↦ h _ _ le_rfl, fun h _ _ _ ↦ h _⟩\n\n"}
{"name":"bddAbove_range_partialSups","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Iff (BddAbove (Set.range ⇑(partialSups f))) (BddAbove (Set.range f))","decl":"@[simp]\ntheorem bddAbove_range_partialSups {f : ι → α} :\n    BddAbove (Set.range (partialSups f)) ↔ BddAbove (Set.range f) :=\n  .of_eq <| congr_arg Set.Nonempty <| upperBounds_range_partialSups f\n\n"}
{"name":"Monotone.partialSups_eq","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\nhf : Monotone f\n⊢ Eq (⇑(partialSups f)) f","decl":"theorem Monotone.partialSups_eq {f : ι → α} (hf : Monotone f) :\n    partialSups f = f :=\n  funext fun i ↦ le_antisymm (partialSups_le _ _ _ (@hf · i)) (le_partialSups _ _)\n\n"}
{"name":"partialSups_mono","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\n⊢ Monotone partialSups","decl":"theorem partialSups_mono :\n    Monotone (partialSups : (ι → α) → ι →o α) :=\n  fun _ _ h _ ↦ partialSups_le_iff.2 fun j hj ↦ (h j).trans (le_partialSups_of_le _ hj)\n\n"}
{"name":"partialSups_monotone","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : SemilatticeSup α\ninst✝¹ : Preorder ι\ninst✝ : LocallyFiniteOrderBot ι\nf : ι → α\n⊢ Monotone ⇑(partialSups f)","decl":"lemma partialSups_monotone (f : ι → α) :\n    Monotone (partialSups f) :=\n  fun i _ hnm ↦ partialSups_le f i _ (fun _ hm'n ↦ le_partialSups_of_le _ (hm'n.trans hnm))\n\n"}
{"name":"Pi.partialSups_apply","module":"Mathlib.Order.PartialSups","initialProofState":"ι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\nτ : Type u_3\nπ : τ → Type u_4\ninst✝ : (t : τ) → SemilatticeSup (π t)\nf : ι → (t : τ) → π t\ni : ι\nt : τ\n⊢ Eq ((partialSups f) i t) ((partialSups fun x => f x t) i)","decl":"protected lemma Pi.partialSups_apply {τ : Type*} {π : τ → Type*} [∀ t, SemilatticeSup (π t)]\n    (f : ι → (t : τ) → π t) (i : ι) (t : τ) :\n    partialSups f i t = partialSups (f · t) i := by\n  simp only [partialSups_apply, Finset.sup'_apply]\n\n"}
{"name":"partialSups_succ","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : SemilatticeSup α\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : SuccOrder ι\nf : ι → α\ni : ι\n⊢ Eq ((partialSups f) (Order.succ i)) (Max.max ((partialSups f) i) (f (Order.succ i)))","decl":"@[simp]\ntheorem partialSups_succ [LinearOrder ι] [LocallyFiniteOrderBot ι] [SuccOrder ι]\n    (f : ι → α) (i : ι) :\n    partialSups f (Order.succ i) = partialSups f i ⊔ f (Order.succ i) := by\n  suffices Iic (Order.succ i) = Iic i ∪ {Order.succ i} by simp only [partialSups_apply, this,\n    sup'_union nonempty_Iic ⟨_, mem_singleton_self _⟩ f, sup'_singleton]\n  ext\n  simp only [mem_Iic, mem_union, mem_singleton]\n  constructor\n  · exact fun h ↦ (Order.le_succ_iff_eq_or_le.mp h).symm\n  · exact fun h ↦ h.elim (le_trans · <| Order.le_succ _) le_of_eq\n\n"}
{"name":"partialSups_bot","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : SemilatticeSup α\ninst✝² : PartialOrder ι\ninst✝¹ : LocallyFiniteOrder ι\ninst✝ : OrderBot ι\nf : ι → α\n⊢ Eq ((partialSups f) Bot.bot) (f Bot.bot)","decl":"@[simp]\ntheorem partialSups_bot [PartialOrder ι] [LocallyFiniteOrder ι] [OrderBot ι]\n    (f : ι → α) : partialSups f ⊥ = f ⊥ := by\n  simp only [partialSups_apply]\n  -- should we add a lemma `Finset.Iic_bot`?\n  suffices Iic (⊥ : ι) = {⊥} by simp only [this, sup'_singleton]\n  simp only [← coe_eq_singleton, coe_Iic, Set.Iic_bot]\n\n"}
{"name":"partialSups_zero","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\nf : Nat → α\n⊢ Eq ((partialSups f) 0) (f 0)","decl":"@[simp]\ntheorem partialSups_zero (f : ℕ → α) : partialSups f 0 = f 0 :=\n  partialSups_bot f\n\n"}
{"name":"partialSups_eq_sup'_range","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\ninst✝ : SemilatticeSup α\nf : Nat → α\nn : Nat\n⊢ Eq ((partialSups f) n) ((Finset.range (HAdd.hAdd n 1)).sup' ⋯ f)","decl":"theorem partialSups_eq_sup'_range (f : ℕ → α) (n : ℕ) :\n    partialSups f n = (Finset.range (n + 1)).sup' nonempty_range_succ f :=\n  eq_of_forall_ge_iff fun _ ↦ by simp [Nat.lt_succ_iff]\n\n"}
{"name":"partialSups_eq_sup_range","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\ninst✝¹ : SemilatticeSup α\ninst✝ : OrderBot α\nf : Nat → α\nn : Nat\n⊢ Eq ((partialSups f) n) ((Finset.range (HAdd.hAdd n 1)).sup f)","decl":"theorem partialSups_eq_sup_range [OrderBot α] (f : ℕ → α) (n : ℕ) :\n    partialSups f n = (Finset.range (n + 1)).sup f :=\n  eq_of_forall_ge_iff fun _ ↦ by simp [Nat.lt_succ_iff]\n\n"}
{"name":"disjoint_partialSups_left","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : Preorder ι\ninst✝² : LocallyFiniteOrderBot ι\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\nf : ι → α\ni : ι\nx : α\n⊢ Iff (Disjoint ((partialSups f) i) x) (∀ (j : ι), LE.le j i → Disjoint (f j) x)","decl":"@[simp]\nlemma disjoint_partialSups_left {f : ι → α} {i : ι} {x : α} :\n    Disjoint (partialSups f i) x ↔ ∀ j ≤ i, Disjoint (f j) x :=\n  partialSups_iff_forall (Disjoint · x) disjoint_sup_left\n\n"}
{"name":"disjoint_partialSups_right","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : Preorder ι\ninst✝² : LocallyFiniteOrderBot ι\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\nf : ι → α\ni : ι\nx : α\n⊢ Iff (Disjoint x ((partialSups f) i)) (∀ (j : ι), LE.le j i → Disjoint x (f j))","decl":"@[simp]\nlemma disjoint_partialSups_right {f : ι → α} {i : ι} {x : α} :\n    Disjoint x (partialSups f i) ↔ ∀ j ≤ i, Disjoint x (f j) :=\n  partialSups_iff_forall (Disjoint x) disjoint_sup_right\n\n"}
{"name":"partialSups_disjoint_of_disjoint","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝³ : Preorder ι\ninst✝² : LocallyFiniteOrderBot ι\ninst✝¹ : DistribLattice α\ninst✝ : OrderBot α\nf : ι → α\nh : Pairwise (Function.onFun Disjoint f)\ni j : ι\nhij : LT.lt i j\n⊢ Disjoint ((partialSups f) i) (f j)","decl":"open scoped Function in -- required for scoped `on` notation\n/- Note this lemma requires a distributive lattice, so is not useful (or true) in situations such as\nsubmodules. -/\ntheorem partialSups_disjoint_of_disjoint (f : ι → α) (h : Pairwise (Disjoint on f))\n    {i j : ι} (hij : i < j) :\n    Disjoint (partialSups f i) (f j) :=\n  disjoint_partialSups_left.2 fun _ hk ↦ h (hk.trans_lt hij).ne\n\n"}
{"name":"partialSups_eq_ciSup_Iic","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : ConditionallyCompleteLattice α\nf : ι → α\ni : ι\n⊢ Eq ((partialSups f) i) (iSup fun i_1 => f ↑i_1)","decl":"theorem partialSups_eq_ciSup_Iic [ConditionallyCompleteLattice α] (f : ι → α) (i : ι) :\n    partialSups f i = ⨆ i : Set.Iic i, f i := by\n  simp only [partialSups_apply]\n  apply le_antisymm\n  · exact sup'_le _ _ fun j hj ↦ le_ciSup_of_le (Set.finite_range _).bddAbove\n      ⟨j, by simpa only [Set.mem_Iic, mem_Iic] using hj⟩ le_rfl\n  · exact ciSup_le fun ⟨j, hj⟩ ↦ le_sup' f (by simpa only [mem_Iic, Set.mem_Iic] using hj)\n\n"}
{"name":"ciSup_partialSups_eq","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : ConditionallyCompleteLattice α\nf : ι → α\nh : BddAbove (Set.range f)\n⊢ Eq (iSup fun i => (partialSups f) i) (iSup fun i => f i)","decl":"@[simp]\ntheorem ciSup_partialSups_eq [ConditionallyCompleteLattice α]\n    {f : ι → α} (h : BddAbove (Set.range f)) :\n    ⨆ i, partialSups f i = ⨆ i, f i := by\n  by_cases hι : Nonempty ι\n  · refine (ciSup_le fun i ↦ ?_).antisymm (ciSup_mono ?_ <| le_partialSups f)\n    · simpa only [partialSups_eq_ciSup_Iic] using ciSup_le fun i ↦ le_ciSup h _\n    · rwa [bddAbove_range_partialSups]\n  · exact congr_arg _ (funext (not_nonempty_iff.mp hι).elim)\n\n"}
{"name":"ciSup_partialSups_eq'","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : ConditionallyCompleteLinearOrder α\nf : ι → α\n⊢ Eq (iSup fun i => (partialSups f) i) (iSup fun i => f i)","decl":"/-- Version of `ciSup_partialSups_eq` without boundedness assumptions, but requiring a\n`ConditionallyCompleteLinearOrder` rather than just a `ConditionallyCompleteLattice`. -/\n@[simp]\ntheorem ciSup_partialSups_eq' [ConditionallyCompleteLinearOrder α] (f : ι → α) :\n    ⨆ i, partialSups f i = ⨆ i, f i := by\n  by_cases h : BddAbove (Set.range f)\n  · exact ciSup_partialSups_eq h\n  · rw [iSup, iSup, ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove _ h,\n      ConditionallyCompleteLinearOrder.csSup_of_not_bddAbove _\n        (bddAbove_range_partialSups.not.mpr h)]\n\n"}
{"name":"iSup_partialSups_eq","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : CompleteLattice α\nf : ι → α\n⊢ Eq (iSup fun i => (partialSups f) i) (iSup fun i => f i)","decl":"/-- Version of `ciSup_partialSups_eq` without boundedness assumptions, but requiring a\n`CompleteLattice` rather than just a `ConditionallyCompleteLattice`. -/\ntheorem iSup_partialSups_eq (f : ι → α) :\n    ⨆ i, partialSups f i = ⨆ i, f i :=\n  ciSup_partialSups_eq <| OrderTop.bddAbove _\n\n"}
{"name":"partialSups_eq_biSup","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : CompleteLattice α\nf : ι → α\ni : ι\n⊢ Eq ((partialSups f) i) (iSup fun j => iSup fun h => f j)","decl":"theorem partialSups_eq_biSup (f : ι → α) (i : ι) :\n    partialSups f i = ⨆ j ≤ i, f j := by\n  simpa only [iSup_subtype] using partialSups_eq_ciSup_Iic f i\n\n"}
{"name":"iSup_le_iSup_of_partialSups_le_partialSups","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : CompleteLattice α\nf g : ι → α\nh : LE.le (partialSups f) (partialSups g)\n⊢ LE.le (iSup fun i => f i) (iSup fun i => g i)","decl":"theorem iSup_le_iSup_of_partialSups_le_partialSups {f g : ι → α}\n    (h : partialSups f ≤ partialSups g) : ⨆ i, f i ≤ ⨆ i, g i := by\n  rw [← iSup_partialSups_eq f, ← iSup_partialSups_eq g]\n  exact iSup_mono h\n\n"}
{"name":"iSup_eq_iSup_of_partialSups_eq_partialSups","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\nι : Type u_2\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : CompleteLattice α\nf g : ι → α\nh : Eq (partialSups f) (partialSups g)\n⊢ Eq (iSup fun i => f i) (iSup fun i => g i)","decl":"theorem iSup_eq_iSup_of_partialSups_eq_partialSups {f g : ι → α}\n    (h : partialSups f = partialSups g) : ⨆ i, f i = ⨆ i, g i := by\n  simp_rw [← iSup_partialSups_eq f, ← iSup_partialSups_eq g, h]\n\n"}
{"name":"partialSups_eq_sUnion_image","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\ninst✝ : DecidableEq (Set α)\ns : Nat → Set α\nn : Nat\n⊢ Eq ((partialSups s) n) (↑(Finset.image s (Finset.range (HAdd.hAdd n 1)))).sUnion","decl":"lemma partialSups_eq_sUnion_image [DecidableEq (Set α)] (s : ℕ → Set α) (n : ℕ) :\n    partialSups s n = ⋃₀ ↑((Finset.range (n + 1)).image s) := by\n  ext; simp [partialSups_eq_biSup, Nat.lt_succ_iff]\n\n"}
{"name":"partialSups_eq_biUnion_range","module":"Mathlib.Order.PartialSups","initialProofState":"α : Type u_1\ns : Nat → Set α\nn : Nat\n⊢ Eq ((partialSups s) n) (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"lemma partialSups_eq_biUnion_range (s : ℕ → Set α) (n : ℕ) :\n    partialSups s n = ⋃ i ∈ Finset.range (n + 1), s i := by\n  ext; simp [partialSups_eq_biSup, Nat.lt_succ]\n\n"}
