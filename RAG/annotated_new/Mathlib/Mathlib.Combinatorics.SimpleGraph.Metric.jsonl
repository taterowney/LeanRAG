{"name":"SimpleGraph.edist_eq_sInf","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Eq (G.edist u v) (InfSet.sInf (Set.range fun w => ↑w.length))","decl":"theorem edist_eq_sInf : G.edist u v = sInf (Set.range fun w : G.Walk u v ↦ (w.length : ℕ∞)) := rfl\n\n"}
{"name":"SimpleGraph.Reachable.exists_walk_length_eq_edist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\n⊢ Exists fun p => Eq (↑p.length) (G.edist u v)","decl":"protected theorem Reachable.exists_walk_length_eq_edist (hr : G.Reachable u v) :\n    ∃ p : G.Walk u v, p.length = G.edist u v :=\n  csInf_mem <| Set.range_nonempty_iff_nonempty.mpr hr\n\n"}
{"name":"SimpleGraph.Connected.exists_walk_length_eq_edist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nhconn : G.Connected\nu v : V\n⊢ Exists fun p => Eq (↑p.length) (G.edist u v)","decl":"protected theorem Connected.exists_walk_length_eq_edist (hconn : G.Connected) (u v : V) :\n    ∃ p : G.Walk u v, p.length = G.edist u v :=\n  (hconn u v).exists_walk_length_eq_edist\n\n"}
{"name":"SimpleGraph.edist_le","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ LE.le (G.edist u v) ↑p.length","decl":"theorem edist_le (p : G.Walk u v) :\n    G.edist u v ≤ p.length :=\n  sInf_le ⟨p, rfl⟩\n"}
{"name":"SimpleGraph.Walk.edist_le","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ LE.le (G.edist u v) ↑p.length","decl":"protected alias Walk.edist_le := edist_le\n\n"}
{"name":"SimpleGraph.edist_eq_zero_iff","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Iff (Eq (G.edist u v) 0) (Eq u v)","decl":"@[simp]\ntheorem edist_eq_zero_iff :\n    G.edist u v = 0 ↔ u = v := by\n  apply Iff.intro <;> simp [edist, ENat.iInf_eq_zero]\n\n"}
{"name":"SimpleGraph.edist_self","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\n⊢ Eq (G.edist v v) 0","decl":"@[simp]\ntheorem edist_self : edist G v v = 0 :=\n  edist_eq_zero_iff.mpr rfl\n\n"}
{"name":"SimpleGraph.edist_pos_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhne : Ne u v\n⊢ LT.lt 0 (G.edist u v)","decl":"theorem edist_pos_of_ne (hne : u ≠ v) :\n    0 < G.edist u v :=\n  pos_iff_ne_zero.mpr <| edist_eq_zero_iff.ne.mpr hne\n\n"}
{"name":"SimpleGraph.edist_eq_top_of_not_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Not (G.Reachable u v)\n⊢ Eq (G.edist u v) Top.top","decl":"lemma edist_eq_top_of_not_reachable (h : ¬G.Reachable u v) :\n    G.edist u v = ⊤ := by\n  simp [edist, not_reachable_iff_isEmpty_walk.mp h]\n\n"}
{"name":"SimpleGraph.reachable_of_edist_ne_top","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Ne (G.edist u v) Top.top\n⊢ G.Reachable u v","decl":"theorem reachable_of_edist_ne_top (h : G.edist u v ≠ ⊤) :\n    G.Reachable u v :=\n  not_not.mp <| edist_eq_top_of_not_reachable.mt h\n\n"}
{"name":"SimpleGraph.exists_walk_of_edist_ne_top","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Ne (G.edist u v) Top.top\n⊢ Exists fun p => Eq (↑p.length) (G.edist u v)","decl":"lemma exists_walk_of_edist_ne_top (h : G.edist u v ≠ ⊤) :\n    ∃ p : G.Walk u v, p.length = G.edist u v :=\n  (reachable_of_edist_ne_top h).exists_walk_length_eq_edist\n\n"}
{"name":"SimpleGraph.edist_triangle","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v w : V\n⊢ LE.le (G.edist u w) (HAdd.hAdd (G.edist u v) (G.edist v w))","decl":"protected theorem edist_triangle : G.edist u w ≤ G.edist u v + G.edist v w := by\n  cases eq_or_ne (G.edist u v) ⊤ with\n  | inl huv => simp [huv]\n  | inr huv =>\n    cases eq_or_ne (G.edist v w) ⊤ with\n    | inl hvw => simp [hvw]\n    | inr hvw =>\n      obtain ⟨p, hp⟩ := exists_walk_of_edist_ne_top huv\n      obtain ⟨q, hq⟩ := exists_walk_of_edist_ne_top hvw\n      rw [← hp, ← hq, ← Nat.cast_add, ← Walk.length_append]\n      exact edist_le _\n\n"}
{"name":"SimpleGraph.edist_comm","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Eq (G.edist u v) (G.edist v u)","decl":"theorem edist_comm : G.edist u v = G.edist v u := by\n  rw [edist_eq_sInf, ← Set.image_univ, ← Set.image_univ_of_surjective Walk.reverse_surjective,\n    ← Set.image_comp, Set.image_univ, Function.comp_def]\n  simp_rw [Walk.length_reverse, ← edist_eq_sInf]\n\n"}
{"name":"SimpleGraph.exists_walk_of_edist_eq_coe","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nk : Nat\nh : Eq (G.edist u v) ↑k\n⊢ Exists fun p => Eq p.length k","decl":"lemma exists_walk_of_edist_eq_coe {k : ℕ} (h : G.edist u v = k) :\n    ∃ p : G.Walk u v, p.length = k :=\n  have : G.edist u v ≠ ⊤ := by rw [h]; exact ENat.coe_ne_top _\n  have ⟨p, hp⟩ := exists_walk_of_edist_ne_top this\n  ⟨p, Nat.cast_injective (hp.trans h)⟩\n\n"}
{"name":"SimpleGraph.edist_ne_top_iff_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Iff (Ne (G.edist u v) Top.top) (G.Reachable u v)","decl":"lemma edist_ne_top_iff_reachable : G.edist u v ≠ ⊤ ↔ G.Reachable u v := by\n  refine ⟨reachable_of_edist_ne_top, fun h ↦ ?_⟩\n  by_contra hx\n  simp only [edist, iInf_eq_top, ENat.coe_ne_top] at hx\n  exact h.elim hx\n\n"}
{"name":"SimpleGraph.edist_eq_one_iff_adj","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Iff (Eq (G.edist u v) 1) (G.Adj u v)","decl":"/--\nThe extended distance between vertices is equal to `1` if and only if these vertices are adjacent.\n-/\n@[simp]\ntheorem edist_eq_one_iff_adj : G.edist u v = 1 ↔ G.Adj u v := by\n  refine ⟨fun h ↦ ?_, fun h ↦ ?_⟩\n  · obtain ⟨w, hw⟩ := exists_walk_of_edist_ne_top <| by rw [h]; simp\n    exact w.adj_of_length_eq_one <| Nat.cast_eq_one.mp <| h ▸ hw\n  · exact le_antisymm (edist_le h.toWalk) (Order.one_le_iff_pos.mpr <| edist_pos_of_ne h.ne)\n\n"}
{"name":"SimpleGraph.edist_bot_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\nh : Ne u v\n⊢ Eq (Bot.bot.edist u v) Top.top","decl":"lemma edist_bot_of_ne (h : u ≠ v) : (⊥ : SimpleGraph V).edist u v = ⊤ := by\n  rwa [ne_eq, ← reachable_bot.not, ← edist_ne_top_iff_reachable.not, not_not] at h\n\n"}
{"name":"SimpleGraph.edist_bot","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\ninst✝ : DecidableEq V\n⊢ Eq (Bot.bot.edist u v) (ite (Eq u v) 0 Top.top)","decl":"lemma edist_bot [DecidableEq V] : (⊥ : SimpleGraph V).edist u v = (if u = v then 0 else ⊤) := by\n  by_cases h : u = v <;> simp [h, edist_bot_of_ne]\n\n"}
{"name":"SimpleGraph.edist_top_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\nh : Ne u v\n⊢ Eq (Top.top.edist u v) 1","decl":"lemma edist_top_of_ne (h : u ≠ v) : (⊤ : SimpleGraph V).edist u v = 1 := by\n  simp [h]\n\n"}
{"name":"SimpleGraph.edist_top","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\ninst✝ : DecidableEq V\n⊢ Eq (Top.top.edist u v) (ite (Eq u v) 0 1)","decl":"lemma edist_top [DecidableEq V] : (⊤ : SimpleGraph V).edist u v = (if u = v then 0 else 1) := by\n  by_cases h : u = v <;> simp [h]\n\n"}
{"name":"SimpleGraph.edist_anti","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nG' : SimpleGraph V\nh : LE.le G G'\n⊢ LE.le (G'.edist u v) (G.edist u v)","decl":"/-- Supergraphs have smaller or equal extended distances to their subgraphs. -/\n@[gcongr]\ntheorem edist_anti {G' : SimpleGraph V} (h : G ≤ G') :\n    G'.edist u v ≤ G.edist u v := by\n  by_cases hr : G.Reachable u v\n  · obtain ⟨_, hw⟩ := hr.exists_walk_length_eq_edist\n    rw [← hw, ← Walk.length_map (Hom.mapSpanningSubgraphs h)]\n    apply edist_le\n  · exact edist_eq_top_of_not_reachable hr ▸ le_top\n\n"}
{"name":"SimpleGraph.dist_eq_sInf","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Eq (G.dist u v) (InfSet.sInf (Set.range SimpleGraph.Walk.length))","decl":"theorem dist_eq_sInf : G.dist u v = sInf (Set.range (Walk.length : G.Walk u v → ℕ)) :=\n  ENat.iInf_toNat\n\n"}
{"name":"SimpleGraph.Reachable.exists_walk_length_eq_dist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\n⊢ Exists fun p => Eq p.length (G.dist u v)","decl":"protected theorem Reachable.exists_walk_length_eq_dist (hr : G.Reachable u v) :\n    ∃ p : G.Walk u v, p.length = G.dist u v :=\n  dist_eq_sInf ▸ Nat.sInf_mem (Set.range_nonempty_iff_nonempty.mpr hr)\n\n"}
{"name":"SimpleGraph.Connected.exists_walk_length_eq_dist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nhconn : G.Connected\nu v : V\n⊢ Exists fun p => Eq p.length (G.dist u v)","decl":"protected theorem Connected.exists_walk_length_eq_dist (hconn : G.Connected) (u v : V) :\n    ∃ p : G.Walk u v, p.length = G.dist u v :=\n  dist_eq_sInf ▸ (hconn u v).exists_walk_length_eq_dist\n\n"}
{"name":"SimpleGraph.dist_le","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\np : G.Walk u v\n⊢ LE.le (G.dist u v) p.length","decl":"theorem dist_le (p : G.Walk u v) : G.dist u v ≤ p.length :=\n  dist_eq_sInf ▸ Nat.sInf_le ⟨p, rfl⟩\n\n"}
{"name":"SimpleGraph.dist_eq_zero_iff_eq_or_not_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Iff (Eq (G.dist u v) 0) (Or (Eq u v) (Not (G.Reachable u v)))","decl":"@[simp]\ntheorem dist_eq_zero_iff_eq_or_not_reachable :\n    G.dist u v = 0 ↔ u = v ∨ ¬G.Reachable u v := by simp [dist_eq_sInf, Nat.sInf_eq_zero, Reachable]\n\n"}
{"name":"SimpleGraph.dist_self","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nv : V\n⊢ Eq (G.dist v v) 0","decl":"theorem dist_self : dist G v v = 0 := by simp\n\n"}
{"name":"SimpleGraph.Reachable.dist_eq_zero_iff","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\n⊢ Iff (Eq (G.dist u v) 0) (Eq u v)","decl":"protected theorem Reachable.dist_eq_zero_iff (hr : G.Reachable u v) :\n    G.dist u v = 0 ↔ u = v := by simp [hr]\n\n"}
{"name":"SimpleGraph.Reachable.pos_dist_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : G.Reachable u v\nhne : Ne u v\n⊢ LT.lt 0 (G.dist u v)","decl":"protected theorem Reachable.pos_dist_of_ne (h : G.Reachable u v) (hne : u ≠ v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero (by simp [h, hne])\n\n"}
{"name":"SimpleGraph.Connected.dist_eq_zero_iff","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhconn : G.Connected\n⊢ Iff (Eq (G.dist u v) 0) (Eq u v)","decl":"protected theorem Connected.dist_eq_zero_iff (hconn : G.Connected) :\n    G.dist u v = 0 ↔ u = v := by simp [hconn u v]\n\n"}
{"name":"SimpleGraph.Connected.pos_dist_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhconn : G.Connected\nhne : Ne u v\n⊢ LT.lt 0 (G.dist u v)","decl":"protected theorem Connected.pos_dist_of_ne (hconn : G.Connected) (hne : u ≠ v) :\n    0 < G.dist u v :=\n  Nat.pos_of_ne_zero fun h ↦ False.elim <| hne <| (hconn.dist_eq_zero_iff).mp h\n\n"}
{"name":"SimpleGraph.dist_eq_zero_of_not_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Not (G.Reachable u v)\n⊢ Eq (G.dist u v) 0","decl":"theorem dist_eq_zero_of_not_reachable (h : ¬G.Reachable u v) : G.dist u v = 0 := by\n  simp [h]\n\n"}
{"name":"SimpleGraph.nonempty_of_pos_dist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : LT.lt 0 (G.dist u v)\n⊢ Set.univ.Nonempty","decl":"theorem nonempty_of_pos_dist (h : 0 < G.dist u v) :\n    (Set.univ : Set (G.Walk u v)).Nonempty := by\n  rw [dist_eq_sInf] at h\n  simpa [Set.range_nonempty_iff_nonempty, Set.nonempty_iff_univ_nonempty] using\n    Nat.nonempty_of_pos_sInf h\n\n"}
{"name":"SimpleGraph.Connected.dist_triangle","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v w : V\nhconn : G.Connected\n⊢ LE.le (G.dist u w) (HAdd.hAdd (G.dist u v) (G.dist v w))","decl":"protected theorem Connected.dist_triangle (hconn : G.Connected) :\n    G.dist u w ≤ G.dist u v + G.dist v w := by\n  obtain ⟨p, hp⟩ := hconn.exists_walk_length_eq_dist u v\n  obtain ⟨q, hq⟩ := hconn.exists_walk_length_eq_dist v w\n  rw [← hp, ← hq, ← Walk.length_append]\n  apply dist_le\n\n"}
{"name":"SimpleGraph.dist_comm","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Eq (G.dist u v) (G.dist v u)","decl":"theorem dist_comm : G.dist u v = G.dist v u := by\n  rw [dist, dist, edist_comm]\n\n"}
{"name":"SimpleGraph.dist_ne_zero_iff_ne_and_reachable","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Iff (Ne (G.dist u v) 0) (And (Ne u v) (G.Reachable u v))","decl":"lemma dist_ne_zero_iff_ne_and_reachable : G.dist u v ≠ 0 ↔ u ≠ v ∧ G.Reachable u v := by\n  rw [ne_eq, dist_eq_zero_iff_eq_or_not_reachable.not]\n  push_neg; rfl\n\n"}
{"name":"SimpleGraph.Reachable.of_dist_ne_zero","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Ne (G.dist u v) 0\n⊢ G.Reachable u v","decl":"lemma Reachable.of_dist_ne_zero (h : G.dist u v ≠ 0) : G.Reachable u v :=\n  (dist_ne_zero_iff_ne_and_reachable.mp h).2\n\n"}
{"name":"SimpleGraph.exists_walk_of_dist_ne_zero","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nh : Ne (G.dist u v) 0\n⊢ Exists fun p => Eq p.length (G.dist u v)","decl":"lemma exists_walk_of_dist_ne_zero (h : G.dist u v ≠ 0) :\n    ∃ p : G.Walk u v, p.length = G.dist u v :=\n  (Reachable.of_dist_ne_zero h).exists_walk_length_eq_dist\n\n"}
{"name":"SimpleGraph.dist_eq_one_iff_adj","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\n⊢ Iff (Eq (G.dist u v) 1) (G.Adj u v)","decl":"/--\nThe distance between vertices is equal to `1` if and only if these vertices are adjacent.\n-/\n@[simp]\ntheorem dist_eq_one_iff_adj : G.dist u v = 1 ↔ G.Adj u v := by\n  rw [dist, ENat.toNat_eq_iff, ENat.coe_one, edist_eq_one_iff_adj]\n  decide\n\n"}
{"name":"SimpleGraph.Walk.isPath_of_length_eq_dist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\np : G.Walk u v\nhp : Eq p.length (G.dist u v)\n⊢ p.IsPath","decl":"theorem Walk.isPath_of_length_eq_dist (p : G.Walk u v) (hp : p.length = G.dist u v) :\n    p.IsPath := by\n  classical\n  have : p.bypass = p := by\n    apply Walk.bypass_eq_self_of_length_le\n    calc p.length\n      _ = G.dist u v := hp\n      _ ≤ p.bypass.length := dist_le p.bypass\n  rw [← this]\n  apply Walk.bypass_isPath\n\n"}
{"name":"SimpleGraph.Reachable.exists_path_of_dist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nhr : G.Reachable u v\n⊢ Exists fun p => And p.IsPath (Eq p.length (G.dist u v))","decl":"lemma Reachable.exists_path_of_dist (hr : G.Reachable u v) :\n    ∃ (p : G.Walk u v), p.IsPath ∧ p.length = G.dist u v := by\n  obtain ⟨p, h⟩ := hr.exists_walk_length_eq_dist\n  exact ⟨p, p.isPath_of_length_eq_dist h, h⟩\n\n"}
{"name":"SimpleGraph.Connected.exists_path_of_dist","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nhconn : G.Connected\nu v : V\n⊢ Exists fun p => And p.IsPath (Eq p.length (G.dist u v))","decl":"lemma Connected.exists_path_of_dist (hconn : G.Connected) (u v : V) :\n    ∃ (p : G.Walk u v), p.IsPath ∧ p.length = G.dist u v := by\n  obtain ⟨p, h⟩ := hconn.exists_walk_length_eq_dist  u v\n  exact ⟨p, p.isPath_of_length_eq_dist h, h⟩\n\n"}
{"name":"SimpleGraph.dist_bot","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\n⊢ Eq (Bot.bot.dist u v) 0","decl":"@[simp]\nlemma dist_bot : (⊥ : SimpleGraph V).dist u v = 0 := by\n  by_cases h : u = v <;> simp [h]\n\n"}
{"name":"SimpleGraph.dist_top_of_ne","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\nh : Ne u v\n⊢ Eq (Top.top.dist u v) 1","decl":"lemma dist_top_of_ne (h : u ≠ v) : (⊤ : SimpleGraph V).dist u v = 1 := by\n  simp [h]\n\n"}
{"name":"SimpleGraph.dist_top","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nu v : V\ninst✝ : DecidableEq V\n⊢ Eq (Top.top.dist u v) (ite (Eq u v) 0 1)","decl":"lemma dist_top [DecidableEq V] : (⊤ : SimpleGraph V).dist u v = (if u = v then 0 else 1) := by\n  by_cases h : u = v <;> simp [h]\n\n"}
{"name":"SimpleGraph.Reachable.dist_anti","module":"Mathlib.Combinatorics.SimpleGraph.Metric","initialProofState":"V : Type u_1\nG : SimpleGraph V\nu v : V\nG' : SimpleGraph V\nh : LE.le G G'\nhr : G.Reachable u v\n⊢ LE.le (G'.dist u v) (G.dist u v)","decl":"/-- Supergraphs have smaller or equal distances to their subgraphs. -/\n@[gcongr]\nprotected theorem Reachable.dist_anti {G' : SimpleGraph V} (h : G ≤ G') (hr : G.Reachable u v) :\n    G'.dist u v ≤ G.dist u v := by\n  obtain ⟨_, hw⟩ := hr.exists_walk_length_eq_dist\n  rw [← hw, ← Walk.length_map (Hom.mapSpanningSubgraphs h)]\n  apply dist_le\n\n"}
