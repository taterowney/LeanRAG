{"name":"Denumerable.decode_inv","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_3\nself : Denumerable α\nn : Nat\n⊢ Exists fun a => And (Membership.mem (Encodable.decode n) a) (Eq (Encodable.encode a) n)","decl":"/-- A denumerable type is (constructively) bijective with `ℕ`. Typeclass equivalent of `α ≃ ℕ`. -/\nclass Denumerable (α : Type*) extends Encodable α where\n  /-- `decode` and `encode` are inverses. -/\n  decode_inv : ∀ n, ∃ a ∈ decode n, encode a = n\n\n"}
{"name":"Denumerable.decode_isSome","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_3\ninst✝ : Denumerable α\nn : Nat\n⊢ Eq (Encodable.decode n).isSome Bool.true","decl":"theorem decode_isSome (α) [Denumerable α] (n : ℕ) : (decode (α := α) n).isSome :=\n  Option.isSome_iff_exists.2 <| (decode_inv n).imp fun _ => And.left\n\n"}
{"name":"Denumerable.decode_eq_ofNat","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_3\ninst✝ : Denumerable α\nn : Nat\n⊢ Eq (Encodable.decode n) (Option.some (Denumerable.ofNat α n))","decl":"@[simp]\ntheorem decode_eq_ofNat (α) [Denumerable α] (n : ℕ) : decode (α := α) n = some (ofNat α n) :=\n  Option.eq_some_of_isSome _\n\n"}
{"name":"Denumerable.ofNat_of_decode","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\nn : Nat\nb : α\nh : Eq (Encodable.decode n) (Option.some b)\n⊢ Eq (Denumerable.ofNat α n) b","decl":"@[simp]\ntheorem ofNat_of_decode {n b} (h : decode (α := α) n = some b) : ofNat (α := α) n = b :=\n  Option.some.inj <| (decode_eq_ofNat _ _).symm.trans h\n\n"}
{"name":"Denumerable.encode_ofNat","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\nn : Nat\n⊢ Eq (Encodable.encode (Denumerable.ofNat α n)) n","decl":"@[simp]\ntheorem encode_ofNat (n) : encode (ofNat α n) = n := by\n  obtain ⟨a, h, e⟩ := decode_inv (α := α) n\n  rwa [ofNat_of_decode h]\n\n"}
{"name":"Denumerable.ofNat_encode","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\na : α\n⊢ Eq (Denumerable.ofNat α (Encodable.encode a)) a","decl":"@[simp]\ntheorem ofNat_encode (a) : ofNat α (encode a) = a :=\n  ofNat_of_decode (encodek _)\n\n"}
{"name":"Denumerable.instInfinite","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\ninst✝ : Denumerable α\n⊢ Infinite α","decl":"instance (priority := 100) : Infinite α :=\n  Infinite.of_surjective _ (eqv α).surjective\n\n"}
{"name":"Denumerable.ofEquiv_ofNat","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_3\nβ : Type u_4\ninst✝ : Denumerable α\ne : Equiv β α\nn : Nat\n⊢ Eq (Denumerable.ofNat β n) (e.symm (Denumerable.ofNat α n))","decl":"@[simp]\ntheorem ofEquiv_ofNat (α) {β} [Denumerable α] (e : β ≃ α) (n) :\n    @ofNat β (ofEquiv _ e) n = e.symm (ofNat α n) := by\n  -- Porting note: added `letI`\n  letI := ofEquiv _ e\n  refine ofNat_of_decode ?_\n  rw [decode_ofEquiv e]\n  simp\n\n"}
{"name":"Denumerable.ofNat_nat","module":"Mathlib.Logic.Denumerable","initialProofState":"n : Nat\n⊢ Eq (Denumerable.ofNat Nat n) n","decl":"@[simp]\ntheorem ofNat_nat (n) : ofNat ℕ n = n :=\n  rfl\n\n"}
{"name":"Denumerable.sigma_ofNat_val","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\ninst✝¹ : Denumerable α\nγ : α → Type u_3\ninst✝ : (a : α) → Denumerable (γ a)\nn : Nat\n⊢ Eq (Denumerable.ofNat (Sigma γ) n) ⟨Denumerable.ofNat α (Nat.unpair n).1, Denumerable.ofNat (γ (Denumerable.ofNat α (Nat.unpair n).1)) (Nat.unpair n).2⟩","decl":"@[simp]\ntheorem sigma_ofNat_val (n : ℕ) :\n    ofNat (Sigma γ) n = ⟨ofNat α (unpair n).1, ofNat (γ _) (unpair n).2⟩ :=\n  Option.some.inj <| by rw [← decode_eq_ofNat, decode_sigma_val]; simp\n\n"}
{"name":"Denumerable.prod_ofNat_val","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Denumerable α\ninst✝ : Denumerable β\nn : Nat\n⊢ Eq (Denumerable.ofNat (Prod α β) n) { fst := Denumerable.ofNat α (Nat.unpair n).1, snd := Denumerable.ofNat β (Nat.unpair n).2 }","decl":"theorem prod_ofNat_val (n : ℕ) :\n    ofNat (α × β) n = (ofNat α (unpair n).1, ofNat β (unpair n).2) := by simp\n\n"}
{"name":"Denumerable.prod_nat_ofNat","module":"Mathlib.Logic.Denumerable","initialProofState":"⊢ Eq (Denumerable.ofNat (Prod Nat Nat)) Nat.unpair","decl":"@[simp]\ntheorem prod_nat_ofNat : ofNat (ℕ × ℕ) = unpair := by funext; simp\n\n"}
{"name":"Nat.Subtype.exists_succ","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝ : Infinite ↑s\nx : ↑s\n⊢ Exists fun n => Membership.mem s (HAdd.hAdd (HAdd.hAdd (↑x) n) 1)","decl":"theorem exists_succ (x : s) : ∃ n, (x : ℕ) + n + 1 ∈ s := by\n  by_contra h\n  have : ∀ (a : ℕ) (_ : a ∈ s), a < x + 1 := fun a ha =>\n    lt_of_not_ge fun hax => h ⟨a - (x + 1), by rwa [add_right_comm, Nat.add_sub_cancel' hax]⟩\n  classical\n  exact Fintype.false\n    ⟨(((Multiset.range (succ x)).filter (· ∈ s)).pmap\n      (fun (y : ℕ) (hy : y ∈ s) => Subtype.mk y hy) (by simp [-Multiset.range_succ])).toFinset,\n      by simpa [Subtype.ext_iff_val, Multiset.mem_filter, -Multiset.range_succ] ⟩\n\n"}
{"name":"Nat.Subtype.succ_le_of_lt","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nx y : ↑s\nh : LT.lt y x\n⊢ LE.le (Nat.Subtype.succ y) x","decl":"theorem succ_le_of_lt {x y : s} (h : y < x) : succ y ≤ x :=\n  have hx : ∃ m, (y : ℕ) + m + 1 ∈ s := exists_succ _\n  let ⟨k, hk⟩ := Nat.exists_eq_add_of_lt h\n  have : Nat.find hx ≤ k := Nat.find_min' _ (hk ▸ x.2)\n  show (y : ℕ) + Nat.find hx + 1 ≤ x by omega\n\n"}
{"name":"Nat.Subtype.le_succ_of_forall_lt_le","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nx y : ↑s\nh : ∀ (z : ↑s), LT.lt z x → LE.le z y\n⊢ LE.le x (Nat.Subtype.succ y)","decl":"theorem le_succ_of_forall_lt_le {x y : s} (h : ∀ z < x, z ≤ y) : x ≤ succ y :=\n  have hx : ∃ m, (y : ℕ) + m + 1 ∈ s := exists_succ _\n  show (x : ℕ) ≤ (y : ℕ) + Nat.find hx + 1 from\n    le_of_not_gt fun hxy =>\n      (h ⟨_, Nat.find_spec hx⟩ hxy).not_lt <|\n        (by omega : (y : ℕ) < (y : ℕ) + Nat.find hx + 1)\n\n"}
{"name":"Nat.Subtype.lt_succ_self","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nx : ↑s\n⊢ LT.lt x (Nat.Subtype.succ x)","decl":"theorem lt_succ_self (x : s) : x < succ x :=\n  calc\n    -- Porting note: replaced `x + _`, added type annotations\n    (x : ℕ) ≤ (x + Nat.find (exists_succ x) : ℕ) := le_add_right ..\n    _ < (succ x : ℕ) := Nat.lt_succ_self (x + _)\n\n"}
{"name":"Nat.Subtype.lt_succ_iff_le","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\nx y : ↑s\n⊢ Iff (LT.lt x (Nat.Subtype.succ y)) (LE.le x y)","decl":"theorem lt_succ_iff_le {x y : s} : x < succ y ↔ x ≤ y :=\n  ⟨fun h => le_of_not_gt fun h' => not_le_of_gt h (succ_le_of_lt h'), fun h =>\n    lt_of_le_of_lt h (lt_succ_self _)⟩\n\n"}
{"name":"Nat.Subtype.ofNat_surjective","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Function.Surjective (Nat.Subtype.ofNat s)","decl":"theorem ofNat_surjective : Surjective (ofNat s)\n  | ⟨x, hx⟩ => by\n    set t : List s :=\n      ((List.range x).filter fun y => y ∈ s).pmap\n        (fun (y : ℕ) (hy : y ∈ s) => ⟨y, hy⟩)\n        (by intros a ha; simpa using (List.mem_filter.mp ha).2) with ht\n    have hmt : ∀ {y : s}, y ∈ t ↔ y < ⟨x, hx⟩ := by\n      simp [List.mem_filter, Subtype.ext_iff_val, ht]\n    cases' hmax : List.maximum t with m\n    · refine ⟨0, le_antisymm bot_le (le_of_not_gt fun h => List.not_mem_nil (⊥ : s) ?_)⟩\n      rwa [← List.maximum_eq_bot.1 hmax, hmt]\n    have wf : ↑m < x := by simpa using hmt.mp (List.maximum_mem hmax)\n    rcases ofNat_surjective m with ⟨a, rfl⟩\n    refine ⟨a + 1, le_antisymm (succ_le_of_lt wf) ?_⟩\n    exact le_succ_of_forall_lt_le fun z hz => List.le_maximum_of_mem (hmt.2 hz) hmax\n  termination_by n => n.val\n\n"}
{"name":"Nat.Subtype.ofNat_range","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (Set.range (Nat.Subtype.ofNat s)) Set.univ","decl":"@[simp]\ntheorem ofNat_range : Set.range (ofNat s) = Set.univ :=\n  ofNat_surjective.range_eq\n\n"}
{"name":"Nat.Subtype.coe_comp_ofNat_range","module":"Mathlib.Logic.Denumerable","initialProofState":"s : Set Nat\ninst✝¹ : Infinite ↑s\ninst✝ : DecidablePred fun x => Membership.mem s x\n⊢ Eq (Set.range (Function.comp Subtype.val (Nat.Subtype.ofNat s))) s","decl":"@[simp]\ntheorem coe_comp_ofNat_range : Set.range ((↑) ∘ ofNat s : ℕ → ℕ) = s := by\n  rw [Set.range_comp Subtype.val, ofNat_range, Set.image_univ, Subtype.range_coe]\n\n"}
{"name":"nonempty_denumerable","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_3\ninst✝¹ : Countable α\ninst✝ : Infinite α\n⊢ Nonempty (Denumerable α)","decl":"/-- See also `nonempty_encodable`, `nonempty_fintype`. -/\ntheorem nonempty_denumerable (α : Type*) [Countable α] [Infinite α] : Nonempty (Denumerable α) :=\n  (nonempty_encodable α).map fun h => @Denumerable.ofEncodableOfInfinite _ h _\n\n"}
{"name":"nonempty_denumerable_iff","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_3\n⊢ Iff (Nonempty (Denumerable α)) (And (Countable α) (Infinite α))","decl":"theorem nonempty_denumerable_iff {α : Type*} :\n    Nonempty (Denumerable α) ↔ Countable α ∧ Infinite α :=\n  ⟨fun ⟨_⟩ ↦ ⟨inferInstance, inferInstance⟩, fun ⟨_, _⟩ ↦ nonempty_denumerable _⟩\n\n"}
{"name":"nonempty_equiv_of_countable","module":"Mathlib.Logic.Denumerable","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝³ : Countable α\ninst✝² : Infinite α\ninst✝¹ : Countable β\ninst✝ : Infinite β\n⊢ Nonempty (Equiv α β)","decl":"instance nonempty_equiv_of_countable [Countable α] [Infinite α] [Countable β] [Infinite β] :\n    Nonempty (α ≃ β) := by\n  cases nonempty_denumerable α\n  cases nonempty_denumerable β\n  exact ⟨(Denumerable.eqv _).trans (Denumerable.eqv _).symm⟩\n"}
