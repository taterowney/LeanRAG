{"name":"Set.mem_prod_list_ofFn","module":"Mathlib.Algebra.Group.Pointwise.Set.ListOfFn","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nn : Nat\na : α\ns : Fin n → Set α\n⊢ Iff (Membership.mem (List.ofFn s).prod a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).prod a)","decl":"@[to_additive]\ntheorem mem_prod_list_ofFn {a : α} {s : Fin n → Set α} :\n    a ∈ (List.ofFn s).prod ↔ ∃ f : ∀ i : Fin n, s i, (List.ofFn fun i ↦ (f i : α)).prod = a := by\n  induction' n with n ih generalizing a\n  · simp_rw [List.ofFn_zero, List.prod_nil, Fin.exists_fin_zero_pi, eq_comm, Set.mem_one]\n  · simp_rw [List.ofFn_succ, List.prod_cons, Fin.exists_fin_succ_pi, Fin.cons_zero, Fin.cons_succ,\n      mem_mul, @ih, exists_exists_eq_and, SetCoe.exists, exists_prop]\n\n"}
{"name":"Set.mem_sum_list_ofFn","module":"Mathlib.Algebra.Group.Pointwise.Set.ListOfFn","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\nn : Nat\na : α\ns : Fin n → Set α\n⊢ Iff (Membership.mem (List.ofFn s).sum a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).sum a)","decl":"@[to_additive]\ntheorem mem_prod_list_ofFn {a : α} {s : Fin n → Set α} :\n    a ∈ (List.ofFn s).prod ↔ ∃ f : ∀ i : Fin n, s i, (List.ofFn fun i ↦ (f i : α)).prod = a := by\n  induction' n with n ih generalizing a\n  · simp_rw [List.ofFn_zero, List.prod_nil, Fin.exists_fin_zero_pi, eq_comm, Set.mem_one]\n  · simp_rw [List.ofFn_succ, List.prod_cons, Fin.exists_fin_succ_pi, Fin.cons_zero, Fin.cons_succ,\n      mem_mul, @ih, exists_exists_eq_and, SetCoe.exists, exists_prop]\n\n"}
{"name":"Set.mem_list_prod","module":"Mathlib.Algebra.Group.Pointwise.Set.ListOfFn","initialProofState":"α : Type u_1\ninst✝ : Monoid α\nl : List (Set α)\na : α\n⊢ Iff (Membership.mem l.prod a) (Exists fun l' => And (Eq (List.map (fun x => ↑x.snd) l').prod a) (Eq (List.map Sigma.fst l') l))","decl":"@[to_additive]\ntheorem mem_list_prod {l : List (Set α)} {a : α} :\n    a ∈ l.prod ↔\n      ∃ l' : List (Σs : Set α, ↥s),\n        List.prod (l'.map fun x ↦ (Sigma.snd x : α)) = a ∧ l'.map Sigma.fst = l := by\n  induction' l using List.ofFnRec with n f\n  simp only [mem_prod_list_ofFn, List.exists_iff_exists_tuple, List.map_ofFn, Function.comp,\n    List.ofFn_inj', Sigma.mk.inj_iff, and_left_comm, exists_and_left, exists_eq_left, heq_eq_eq]\n  constructor\n  · rintro ⟨fi, rfl⟩\n    exact ⟨fun i ↦ ⟨_, fi i⟩, rfl, rfl⟩\n  · rintro ⟨fi, rfl, rfl⟩\n    exact ⟨fun i ↦ _, rfl⟩\n\n"}
{"name":"Set.mem_list_sum","module":"Mathlib.Algebra.Group.Pointwise.Set.ListOfFn","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\nl : List (Set α)\na : α\n⊢ Iff (Membership.mem l.sum a) (Exists fun l' => And (Eq (List.map (fun x => ↑x.snd) l').sum a) (Eq (List.map Sigma.fst l') l))","decl":"@[to_additive]\ntheorem mem_list_prod {l : List (Set α)} {a : α} :\n    a ∈ l.prod ↔\n      ∃ l' : List (Σs : Set α, ↥s),\n        List.prod (l'.map fun x ↦ (Sigma.snd x : α)) = a ∧ l'.map Sigma.fst = l := by\n  induction' l using List.ofFnRec with n f\n  simp only [mem_prod_list_ofFn, List.exists_iff_exists_tuple, List.map_ofFn, Function.comp,\n    List.ofFn_inj', Sigma.mk.inj_iff, and_left_comm, exists_and_left, exists_eq_left, heq_eq_eq]\n  constructor\n  · rintro ⟨fi, rfl⟩\n    exact ⟨fun i ↦ ⟨_, fi i⟩, rfl, rfl⟩\n  · rintro ⟨fi, rfl, rfl⟩\n    exact ⟨fun i ↦ _, rfl⟩\n\n"}
{"name":"Set.mem_nsmul","module":"Mathlib.Algebra.Group.Pointwise.Set.ListOfFn","initialProofState":"α : Type u_1\ninst✝ : AddMonoid α\ns : Set α\na : α\nn : Nat\n⊢ Iff (Membership.mem (HSMul.hSMul n s) a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).sum a)","decl":"@[to_additive]\ntheorem mem_pow {a : α} {n : ℕ} :\n    a ∈ s ^ n ↔ ∃ f : Fin n → s, (List.ofFn fun i ↦ (f i : α)).prod = a := by\n  rw [← mem_prod_list_ofFn, List.ofFn_const, List.prod_replicate]\n\n"}
{"name":"Set.mem_pow","module":"Mathlib.Algebra.Group.Pointwise.Set.ListOfFn","initialProofState":"α : Type u_1\ninst✝ : Monoid α\ns : Set α\na : α\nn : Nat\n⊢ Iff (Membership.mem (HPow.hPow s n) a) (Exists fun f => Eq (List.ofFn fun i => ↑(f i)).prod a)","decl":"@[to_additive]\ntheorem mem_pow {a : α} {n : ℕ} :\n    a ∈ s ^ n ↔ ∃ f : Fin n → s, (List.ofFn fun i ↦ (f i : α)).prod = a := by\n  rw [← mem_prod_list_ofFn, List.ofFn_const, List.prod_replicate]\n\n"}
