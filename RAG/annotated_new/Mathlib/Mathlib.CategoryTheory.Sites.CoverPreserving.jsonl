{"name":"CategoryTheory.CoverPreserving.cover_preserve","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.CoverPreserving J K G\nU : C\nS : CategoryTheory.Sieve U\nx‚úù : Membership.mem (J U) S\n‚ä¢ Membership.mem (K (G.obj U)) (CategoryTheory.Sieve.functorPushforward G S)","decl":"/-- A functor `G : (C, J) ‚•§ (D, K)` between sites is *cover-preserving*\nif for all covering sieves `R` in `C`, `R.functorPushforward G` is a covering sieve in `D`.\n-/\nstructure CoverPreserving (G : C ‚•§ D) : Prop where\n  cover_preserve : ‚àÄ {U : C} {S : Sieve U} (_ : S ‚àà J U), S.functorPushforward G ‚àà K (G.obj U)\n\n"}
{"name":"CategoryTheory.idCoverPreserving","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nJ : CategoryTheory.GrothendieckTopology C\n‚ä¢ CategoryTheory.CoverPreserving J J (CategoryTheory.Functor.id C)","decl":"/-- The identity functor on a site is cover-preserving. -/\ntheorem idCoverPreserving : CoverPreserving J J (ùü≠ _) :=\n  ‚ü®fun hS => by simpa using hS‚ü©\n\n"}
{"name":"CategoryTheory.CoverPreserving.comp","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nA : Type u‚ÇÉ\ninst‚úù : CategoryTheory.Category.{v‚ÇÉ, u‚ÇÉ} A\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nL : CategoryTheory.GrothendieckTopology A\nF : CategoryTheory.Functor C D\nhF : CategoryTheory.CoverPreserving J K F\nG : CategoryTheory.Functor D A\nhG : CategoryTheory.CoverPreserving K L G\n‚ä¢ CategoryTheory.CoverPreserving J L (F.comp G)","decl":"/-- The composition of two cover-preserving functors is cover-preserving. -/\ntheorem CoverPreserving.comp {F} (hF : CoverPreserving J K F) {G} (hG : CoverPreserving K L G) :\n    CoverPreserving J L (F ‚ãô G) :=\n  ‚ü®fun hS => by\n    rw [Sieve.functorPushforward_comp]\n    exact hG.cover_preserve (hF.cover_preserve hS)‚ü©\n\n"}
{"name":"CategoryTheory.CompatiblePreserving.compatible","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nself : CategoryTheory.CompatiblePreserving K G\n‚Ñ± : CategoryTheory.Sheaf K (Type w)\nZ : C\nT : CategoryTheory.Presieve Z\nx : CategoryTheory.Presieve.FamilyOfElements (G.op.comp ‚Ñ±.val) T\nx‚úù¬π : x.Compatible\nY‚ÇÅ Y‚ÇÇ : C\nX : D\nf‚ÇÅ : Quiver.Hom X (G.obj Y‚ÇÅ)\nf‚ÇÇ : Quiver.Hom X (G.obj Y‚ÇÇ)\ng‚ÇÅ : Quiver.Hom Y‚ÇÅ Z\ng‚ÇÇ : Quiver.Hom Y‚ÇÇ Z\nhg‚ÇÅ : T g‚ÇÅ\nhg‚ÇÇ : T g‚ÇÇ\nx‚úù : Eq (CategoryTheory.CategoryStruct.comp f‚ÇÅ (G.map g‚ÇÅ)) (CategoryTheory.CategoryStruct.comp f‚ÇÇ (G.map g‚ÇÇ))\n‚ä¢ Eq (‚Ñ±.val.map f‚ÇÅ.op (x g‚ÇÅ hg‚ÇÅ)) (‚Ñ±.val.map f‚ÇÇ.op (x g‚ÇÇ hg‚ÇÇ))","decl":"/-- A functor `G : (C, J) ‚•§ (D, K)` between sites is called compatible preserving if for each\ncompatible family of elements at `C` and valued in `G.op ‚ãô ‚Ñ±`, and each commuting diagram\n`f‚ÇÅ ‚â´ G.map g‚ÇÅ = f‚ÇÇ ‚â´ G.map g‚ÇÇ`, `x g‚ÇÅ` and `x g‚ÇÇ` coincide when restricted via `f·µ¢`.\nThis is actually stronger than merely preserving compatible families because of the definition of\n`functorPushforward` used.\n-/\nstructure CompatiblePreserving (K : GrothendieckTopology D) (G : C ‚•§ D) : Prop where\n  compatible :\n    ‚àÄ (‚Ñ± : Sheaf K (Type w)) {Z} {T : Presieve Z} {x : FamilyOfElements (G.op ‚ãô ‚Ñ±.val) T}\n      (_ : x.Compatible) {Y‚ÇÅ Y‚ÇÇ} {X} (f‚ÇÅ : X ‚ü∂ G.obj Y‚ÇÅ) (f‚ÇÇ : X ‚ü∂ G.obj Y‚ÇÇ) {g‚ÇÅ : Y‚ÇÅ ‚ü∂ Z}\n      {g‚ÇÇ : Y‚ÇÇ ‚ü∂ Z} (hg‚ÇÅ : T g‚ÇÅ) (hg‚ÇÇ : T g‚ÇÇ) (_ : f‚ÇÅ ‚â´ G.map g‚ÇÅ = f‚ÇÇ ‚â´ G.map g‚ÇÇ),\n      ‚Ñ±.val.map f‚ÇÅ.op (x g‚ÇÅ hg‚ÇÅ) = ‚Ñ±.val.map f‚ÇÇ.op (x g‚ÇÇ hg‚ÇÇ)\n\n"}
{"name":"CategoryTheory.Presieve.FamilyOfElements.Compatible.functorPushforward","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nhG : CategoryTheory.CompatiblePreserving K G\n‚Ñ± : CategoryTheory.Sheaf K (Type w)\nZ : C\nT : CategoryTheory.Presieve Z\nx : CategoryTheory.Presieve.FamilyOfElements (G.op.comp ‚Ñ±.val) T\nh : x.Compatible\n‚ä¢ (CategoryTheory.Presieve.FamilyOfElements.functorPushforward G x).Compatible","decl":"/-- `CompatiblePreserving` functors indeed preserve compatible families. -/\ntheorem Presieve.FamilyOfElements.Compatible.functorPushforward :\n    (x.functorPushforward G).Compatible := by\n  rintro Z‚ÇÅ Z‚ÇÇ W g‚ÇÅ g‚ÇÇ f‚ÇÅ' f‚ÇÇ' H‚ÇÅ H‚ÇÇ eq\n  unfold FamilyOfElements.functorPushforward\n  rcases getFunctorPushforwardStructure H‚ÇÅ with ‚ü®X‚ÇÅ, f‚ÇÅ, h‚ÇÅ, hf‚ÇÅ, rfl‚ü©\n  rcases getFunctorPushforwardStructure H‚ÇÇ with ‚ü®X‚ÇÇ, f‚ÇÇ, h‚ÇÇ, hf‚ÇÇ, rfl‚ü©\n  suffices ‚Ñ±.val.map (g‚ÇÅ ‚â´ h‚ÇÅ).op (x f‚ÇÅ hf‚ÇÅ) = ‚Ñ±.val.map (g‚ÇÇ ‚â´ h‚ÇÇ).op (x f‚ÇÇ hf‚ÇÇ) by\n    simpa using this\n  apply hG.compatible ‚Ñ± h _ _ hf‚ÇÅ hf‚ÇÇ\n  simpa using eq\n\n"}
{"name":"CategoryTheory.CompatiblePreserving.apply_map","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\nhG : CategoryTheory.CompatiblePreserving K G\n‚Ñ± : CategoryTheory.Sheaf K (Type w)\nZ : C\nT : CategoryTheory.Presieve Z\nx : CategoryTheory.Presieve.FamilyOfElements (G.op.comp ‚Ñ±.val) T\nh : x.Compatible\nY : C\nf : Quiver.Hom Y Z\nhf : T f\n‚ä¢ Eq (CategoryTheory.Presieve.FamilyOfElements.functorPushforward G x (G.map f) ‚ãØ) (x f hf)","decl":"@[simp]\ntheorem CompatiblePreserving.apply_map {Y : C} {f : Y ‚ü∂ Z} (hf : T f) :\n    x.functorPushforward G (G.map f) (image_mem_functorPushforward G T hf) = x f hf := by\n  unfold FamilyOfElements.functorPushforward\n  rcases getFunctorPushforwardStructure (image_mem_functorPushforward G T hf) with\n    ‚ü®X, g, f', hg, eq‚ü©\n  simpa using hG.compatible ‚Ñ± h f' (ùüô _) hg hf (by simp [eq])\n\n"}
{"name":"CategoryTheory.compatiblePreservingOfFlat","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} D\nK : CategoryTheory.GrothendieckTopology D\nG : CategoryTheory.Functor C D\ninst‚úù : CategoryTheory.RepresentablyFlat G\n‚ä¢ CategoryTheory.CompatiblePreserving K G","decl":"theorem compatiblePreservingOfFlat {C : Type u‚ÇÅ} [Category.{v‚ÇÅ} C] {D : Type u‚ÇÅ} [Category.{v‚ÇÅ} D]\n    (K : GrothendieckTopology D) (G : C ‚•§ D) [RepresentablyFlat G] : CompatiblePreserving K G := by\n  constructor\n  intro ‚Ñ± Z T x hx Y‚ÇÅ Y‚ÇÇ X f‚ÇÅ f‚ÇÇ g‚ÇÅ g‚ÇÇ hg‚ÇÅ hg‚ÇÇ e\n  -- First, `f‚ÇÅ` and `f‚ÇÇ` form a cone over `cospan g‚ÇÅ g‚ÇÇ ‚ãô u`.\n  let c : Cone (cospan g‚ÇÅ g‚ÇÇ ‚ãô G) :=\n    (Cones.postcompose (diagramIsoCospan (cospan g‚ÇÅ g‚ÇÇ ‚ãô G)).inv).obj (PullbackCone.mk f‚ÇÅ f‚ÇÇ e)\n  /-\n    This can then be viewed as a cospan of structured arrows, and we may obtain an arbitrary cone\n    over it since `StructuredArrow W u` is cofiltered.\n    Then, it suffices to prove that it is compatible when restricted onto `u(c'.X.right)`.\n    -/\n  let c' := IsCofiltered.cone (c.toStructuredArrow ‚ãô StructuredArrow.pre _ _ _)\n  have eq‚ÇÅ : f‚ÇÅ = (c'.pt.hom ‚â´ G.map (c'.œÄ.app left).right) ‚â´ eqToHom (by simp) := by\n    erw [‚Üê (c'.œÄ.app left).w]\n    dsimp [c]\n    simp\n  have eq‚ÇÇ : f‚ÇÇ = (c'.pt.hom ‚â´ G.map (c'.œÄ.app right).right) ‚â´ eqToHom (by simp) := by\n    erw [‚Üê (c'.œÄ.app right).w]\n    dsimp [c]\n    simp\n  conv_lhs => rw [eq‚ÇÅ]\n  conv_rhs => rw [eq‚ÇÇ]\n  simp only [c, op_comp, Functor.map_comp, types_comp_apply, eqToHom_op, eqToHom_map]\n  apply congr_arg -- Porting note: was `congr 1` which for some reason doesn't do anything here\n  -- despite goal being of the form f a = f b, with f=`‚Ñ±.val.map (Quiver.Hom.op c'.pt.hom)`\n  /-\n    Since everything now falls in the image of `u`,\n    the result follows from the compatibility of `x` in the image of `u`.\n    -/\n  injection c'.œÄ.naturality WalkingCospan.Hom.inl with _ e‚ÇÅ\n  injection c'.œÄ.naturality WalkingCospan.Hom.inr with _ e‚ÇÇ\n  exact hx (c'.œÄ.app left).right (c'.œÄ.app right).right hg‚ÇÅ hg‚ÇÇ (e‚ÇÅ.symm.trans e‚ÇÇ)\n\n"}
{"name":"CategoryTheory.compatiblePreservingOfDownwardsClosed","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≥ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nK : CategoryTheory.GrothendieckTopology D\nF : CategoryTheory.Functor C D\ninst‚úù¬π : F.Full\ninst‚úù : F.Faithful\nhF : {c : C} ‚Üí {d : D} ‚Üí Quiver.Hom d (F.obj c) ‚Üí Sigma fun c' => CategoryTheory.Iso (F.obj c') d\n‚ä¢ CategoryTheory.CompatiblePreserving K F","decl":"theorem compatiblePreservingOfDownwardsClosed (F : C ‚•§ D) [F.Full] [F.Faithful]\n    (hF : ‚àÄ {c : C} {d : D} (_ : d ‚ü∂ F.obj c), Œ£c', F.obj c' ‚âÖ d) : CompatiblePreserving K F := by\n  constructor\n  introv hx he\n  obtain ‚ü®X', e‚ü© := hF f‚ÇÅ\n  apply (‚Ñ±.1.mapIso e.op).toEquiv.injective\n  simp only [Iso.op_hom, Iso.toEquiv_fun, ‚Ñ±.1.mapIso_hom, ‚Üê FunctorToTypes.map_comp_apply]\n  simpa using\n    hx (F.preimage <| e.hom ‚â´ f‚ÇÅ) (F.preimage <| e.hom ‚â´ f‚ÇÇ) hg‚ÇÅ hg‚ÇÇ\n      (F.map_injective <| by simpa using he)\n\n"}
{"name":"CategoryTheory.Functor.isContinuous_of_coverPreserving","module":"Mathlib.CategoryTheory.Sites.CoverPreserving","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nJ : CategoryTheory.GrothendieckTopology C\nK : CategoryTheory.GrothendieckTopology D\nhF‚ÇÅ : CategoryTheory.CompatiblePreserving K F\nhF‚ÇÇ : CategoryTheory.CoverPreserving J K F\n‚ä¢ F.IsContinuous J K","decl":"/-- If `F` is cover-preserving and compatible-preserving, then `F` is a continuous functor. -/\n@[stacks 00WW \"This is basically this Stacks entry.\"]\nlemma Functor.isContinuous_of_coverPreserving (hF‚ÇÅ : CompatiblePreserving.{w} K F)\n    (hF‚ÇÇ : CoverPreserving J K F) : Functor.IsContinuous.{w} F J K where\n  op_comp_isSheaf_of_types G X S hS x hx := by\n    apply existsUnique_of_exists_of_unique\n    ¬∑ have H := (isSheaf_iff_isSheaf_of_type _ _).1 G.2 _ (hF‚ÇÇ.cover_preserve hS)\n      exact ‚ü®H.amalgamate (x.functorPushforward F) (hx.functorPushforward hF‚ÇÅ),\n        fun V f hf => (H.isAmalgamation (hx.functorPushforward hF‚ÇÅ) (F.map f) _).trans\n          (hF‚ÇÅ.apply_map _ hx hf)‚ü©\n    ¬∑ intro y‚ÇÅ y‚ÇÇ hy‚ÇÅ hy‚ÇÇ\n      apply (Presieve.isSeparated_of_isSheaf _ _ ((isSheaf_iff_isSheaf_of_type _ _).1 G.2) _\n        (hF‚ÇÇ.cover_preserve hS)).ext\n      rintro Y _ ‚ü®Z, g, h, hg, rfl‚ü©\n      dsimp\n      simp only [Functor.map_comp, types_comp_apply]\n      have H := (hy‚ÇÅ g hg).trans (hy‚ÇÇ g hg).symm\n      dsimp at H\n      rw [H]\n\n"}
