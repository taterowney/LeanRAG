{"name":"IsCoprime.symm","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nH : IsCoprime x y\n⊢ IsCoprime y x","decl":"@[symm]\ntheorem IsCoprime.symm (H : IsCoprime x y) : IsCoprime y x :=\n  let ⟨a, b, H⟩ := H\n  ⟨b, a, by rw [add_comm, H]⟩\n\n"}
{"name":"isCoprime_comm","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\n⊢ Iff (IsCoprime x y) (IsCoprime y x)","decl":"theorem isCoprime_comm : IsCoprime x y ↔ IsCoprime y x :=\n  ⟨IsCoprime.symm, IsCoprime.symm⟩\n\n"}
{"name":"isCoprime_self","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\n⊢ Iff (IsCoprime x x) (IsUnit x)","decl":"theorem isCoprime_self : IsCoprime x x ↔ IsUnit x :=\n  ⟨fun ⟨a, b, h⟩ => isUnit_of_mul_eq_one x (a + b) <| by rwa [mul_comm, add_mul], fun h =>\n    let ⟨b, hb⟩ := isUnit_iff_exists_inv'.1 h\n    ⟨b, 0, by rwa [zero_mul, add_zero]⟩⟩\n\n"}
{"name":"isCoprime_zero_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\n⊢ Iff (IsCoprime 0 x) (IsUnit x)","decl":"theorem isCoprime_zero_left : IsCoprime 0 x ↔ IsUnit x :=\n  ⟨fun ⟨a, b, H⟩ => isUnit_of_mul_eq_one x b <| by rwa [mul_zero, zero_add, mul_comm] at H, fun H =>\n    let ⟨b, hb⟩ := isUnit_iff_exists_inv'.1 H\n    ⟨1, b, by rwa [one_mul, zero_add]⟩⟩\n\n"}
{"name":"isCoprime_zero_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\n⊢ Iff (IsCoprime x 0) (IsUnit x)","decl":"theorem isCoprime_zero_right : IsCoprime x 0 ↔ IsUnit x :=\n  isCoprime_comm.trans isCoprime_zero_left\n\n"}
{"name":"not_isCoprime_zero_zero","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\n⊢ Not (IsCoprime 0 0)","decl":"theorem not_isCoprime_zero_zero [Nontrivial R] : ¬IsCoprime (0 : R) 0 :=\n  mt isCoprime_zero_right.mp not_isUnit_zero\n\n"}
{"name":"IsCoprime.intCast","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\na b : Int\nh : IsCoprime a b\n⊢ IsCoprime ↑a ↑b","decl":"lemma IsCoprime.intCast {R : Type*} [CommRing R] {a b : ℤ} (h : IsCoprime a b) :\n    IsCoprime (a : R) (b : R) := by\n  rcases h with ⟨u, v, H⟩\n  use u, v\n  rw_mod_cast [H]\n  exact Int.cast_one\n\n"}
{"name":"IsCoprime.ne_zero","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\ninst✝ : Nontrivial R\np : Fin 2 → R\nh : IsCoprime (p 0) (p 1)\n⊢ Ne p 0","decl":"/-- If a 2-vector `p` satisfies `IsCoprime (p 0) (p 1)`, then `p ≠ 0`. -/\ntheorem IsCoprime.ne_zero [Nontrivial R] {p : Fin 2 → R} (h : IsCoprime (p 0) (p 1)) : p ≠ 0 := by\n  rintro rfl\n  exact not_isCoprime_zero_zero h\n\n"}
{"name":"IsCoprime.ne_zero_or_ne_zero","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nx y : R\ninst✝ : Nontrivial R\nh : IsCoprime x y\n⊢ Or (Ne x 0) (Ne y 0)","decl":"theorem IsCoprime.ne_zero_or_ne_zero [Nontrivial R] (h : IsCoprime x y) : x ≠ 0 ∨ y ≠ 0 := by\n  apply not_or_of_imp\n  rintro rfl rfl\n  exact not_isCoprime_zero_zero h\n\n"}
{"name":"isCoprime_one_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\n⊢ IsCoprime 1 x","decl":"theorem isCoprime_one_left : IsCoprime 1 x :=\n  ⟨1, 0, by rw [one_mul, zero_mul, add_zero]⟩\n\n"}
{"name":"isCoprime_one_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx : R\n⊢ IsCoprime x 1","decl":"theorem isCoprime_one_right : IsCoprime x 1 :=\n  ⟨0, 1, by rw [one_mul, zero_mul, zero_add]⟩\n\n"}
{"name":"IsCoprime.dvd_of_dvd_mul_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : Dvd.dvd x (HMul.hMul y z)\n⊢ Dvd.dvd x y","decl":"theorem IsCoprime.dvd_of_dvd_mul_right (H1 : IsCoprime x z) (H2 : x ∣ y * z) : x ∣ y := by\n  let ⟨a, b, H⟩ := H1\n  rw [← mul_one y, ← H, mul_add, ← mul_assoc, mul_left_comm]\n  exact dvd_add (dvd_mul_left _ _) (H2.mul_left _)\n\n"}
{"name":"IsCoprime.dvd_of_dvd_mul_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : Dvd.dvd x (HMul.hMul y z)\n⊢ Dvd.dvd x z","decl":"theorem IsCoprime.dvd_of_dvd_mul_left (H1 : IsCoprime x y) (H2 : x ∣ y * z) : x ∣ z := by\n  let ⟨a, b, H⟩ := H1\n  rw [← one_mul z, ← H, add_mul, mul_right_comm, mul_assoc b]\n  exact dvd_add (dvd_mul_left _ _) (H2.mul_left _)\n\n"}
{"name":"IsCoprime.mul_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH1 : IsCoprime x z\nH2 : IsCoprime y z\n⊢ IsCoprime (HMul.hMul x y) z","decl":"theorem IsCoprime.mul_left (H1 : IsCoprime x z) (H2 : IsCoprime y z) : IsCoprime (x * y) z :=\n  let ⟨a, b, h1⟩ := H1\n  let ⟨c, d, h2⟩ := H2\n  ⟨a * c, a * x * d + b * c * y + b * d * z,\n    calc a * c * (x * y) + (a * x * d + b * c * y + b * d * z) * z\n      _ = (a * x + b * z) * (c * y + d * z) := by ring\n      _ = 1 := by rw [h1, h2, mul_one]\n      ⟩\n\n"}
{"name":"IsCoprime.mul_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH1 : IsCoprime x y\nH2 : IsCoprime x z\n⊢ IsCoprime x (HMul.hMul y z)","decl":"theorem IsCoprime.mul_right (H1 : IsCoprime x y) (H2 : IsCoprime x z) : IsCoprime x (y * z) := by\n  rw [isCoprime_comm] at H1 H2 ⊢\n  exact H1.mul_left H2\n\n"}
{"name":"IsCoprime.mul_dvd","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH : IsCoprime x y\nH1 : Dvd.dvd x z\nH2 : Dvd.dvd y z\n⊢ Dvd.dvd (HMul.hMul x y) z","decl":"theorem IsCoprime.mul_dvd (H : IsCoprime x y) (H1 : x ∣ z) (H2 : y ∣ z) : x * y ∣ z := by\n  obtain ⟨a, b, h⟩ := H\n  rw [← mul_one z, ← h, mul_add]\n  apply dvd_add\n  · rw [mul_comm z, mul_assoc]\n    exact (mul_dvd_mul_left _ H2).mul_left _\n  · rw [mul_comm b, ← mul_assoc]\n    exact (mul_dvd_mul_right H1 _).mul_right _\n\n"}
{"name":"IsCoprime.of_mul_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH : IsCoprime (HMul.hMul x y) z\n⊢ IsCoprime x z","decl":"theorem IsCoprime.of_mul_left_left (H : IsCoprime (x * y) z) : IsCoprime x z :=\n  let ⟨a, b, h⟩ := H\n  ⟨a * y, b, by rwa [mul_right_comm, mul_assoc]⟩\n\n"}
{"name":"IsCoprime.of_mul_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH : IsCoprime (HMul.hMul x y) z\n⊢ IsCoprime y z","decl":"theorem IsCoprime.of_mul_left_right (H : IsCoprime (x * y) z) : IsCoprime y z := by\n  rw [mul_comm] at H\n  exact H.of_mul_left_left\n\n"}
{"name":"IsCoprime.of_mul_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH : IsCoprime x (HMul.hMul y z)\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_mul_right_left (H : IsCoprime x (y * z)) : IsCoprime x y := by\n  rw [isCoprime_comm] at H ⊢\n  exact H.of_mul_left_left\n\n"}
{"name":"IsCoprime.of_mul_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nH : IsCoprime x (HMul.hMul y z)\n⊢ IsCoprime x z","decl":"theorem IsCoprime.of_mul_right_right (H : IsCoprime x (y * z)) : IsCoprime x z := by\n  rw [mul_comm] at H\n  exact H.of_mul_right_left\n\n"}
{"name":"IsCoprime.mul_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\n⊢ Iff (IsCoprime (HMul.hMul x y) z) (And (IsCoprime x z) (IsCoprime y z))","decl":"theorem IsCoprime.mul_left_iff : IsCoprime (x * y) z ↔ IsCoprime x z ∧ IsCoprime y z :=\n  ⟨fun H => ⟨H.of_mul_left_left, H.of_mul_left_right⟩, fun ⟨H1, H2⟩ => H1.mul_left H2⟩\n\n"}
{"name":"IsCoprime.mul_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\n⊢ Iff (IsCoprime x (HMul.hMul y z)) (And (IsCoprime x y) (IsCoprime x z))","decl":"theorem IsCoprime.mul_right_iff : IsCoprime x (y * z) ↔ IsCoprime x y ∧ IsCoprime x z := by\n  rw [isCoprime_comm, IsCoprime.mul_left_iff, isCoprime_comm, @isCoprime_comm _ _ z]\n\n"}
{"name":"IsCoprime.of_isCoprime_of_dvd_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime y z\nhdvd : Dvd.dvd x y\n⊢ IsCoprime x z","decl":"theorem IsCoprime.of_isCoprime_of_dvd_left (h : IsCoprime y z) (hdvd : x ∣ y) : IsCoprime x z := by\n  obtain ⟨d, rfl⟩ := hdvd\n  exact IsCoprime.of_mul_left_left h\n\n"}
{"name":"IsCoprime.of_isCoprime_of_dvd_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime z y\nhdvd : Dvd.dvd x y\n⊢ IsCoprime z x","decl":"theorem IsCoprime.of_isCoprime_of_dvd_right (h : IsCoprime z y) (hdvd : x ∣ y) : IsCoprime z x :=\n  (h.symm.of_isCoprime_of_dvd_left hdvd).symm\n\n"}
{"name":"IsCoprime.isUnit_of_dvd","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y : R\nH : IsCoprime x y\nd : Dvd.dvd x y\n⊢ IsUnit x","decl":"theorem IsCoprime.isUnit_of_dvd (H : IsCoprime x y) (d : x ∣ y) : IsUnit x :=\n  let ⟨k, hk⟩ := d\n  isCoprime_self.1 <| IsCoprime.of_mul_right_left <| show IsCoprime x (x * k) from hk ▸ H\n\n"}
{"name":"IsCoprime.isUnit_of_dvd'","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\na b x : R\nh : IsCoprime a b\nha : Dvd.dvd x a\nhb : Dvd.dvd x b\n⊢ IsUnit x","decl":"theorem IsCoprime.isUnit_of_dvd' {a b x : R} (h : IsCoprime a b) (ha : x ∣ a) (hb : x ∣ b) :\n    IsUnit x :=\n  (h.of_isCoprime_of_dvd_left ha).isUnit_of_dvd hb\n\n"}
{"name":"IsCoprime.isRelPrime","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\na b : R\nh : IsCoprime a b\n⊢ IsRelPrime a b","decl":"theorem IsCoprime.isRelPrime {a b : R} (h : IsCoprime a b) : IsRelPrime a b :=\n  fun _ ↦ h.isUnit_of_dvd'\n\n"}
{"name":"IsCoprime.map","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\nx y : R\nH : IsCoprime x y\nS : Type v\ninst✝ : CommSemiring S\nf : RingHom R S\n⊢ IsCoprime (f x) (f y)","decl":"theorem IsCoprime.map (H : IsCoprime x y) {S : Type v} [CommSemiring S] (f : R →+* S) :\n    IsCoprime (f x) (f y) :=\n  let ⟨a, b, h⟩ := H\n  ⟨f a, f b, by rw [← f.map_mul, ← f.map_mul, ← f.map_add, h, f.map_one]⟩\n\n"}
{"name":"IsCoprime.of_add_mul_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime (HAdd.hAdd x (HMul.hMul y z)) y\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_add_mul_left_left (h : IsCoprime (x + y * z) y) : IsCoprime x y :=\n  let ⟨a, b, H⟩ := h\n  ⟨a, a * z + b, by\n    simpa only [add_mul, mul_add, add_assoc, add_comm, add_left_comm, mul_assoc, mul_comm,\n      mul_left_comm] using H⟩\n\n"}
{"name":"IsCoprime.of_add_mul_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime (HAdd.hAdd x (HMul.hMul z y)) y\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_add_mul_right_left (h : IsCoprime (x + z * y) y) : IsCoprime x y := by\n  rw [mul_comm] at h\n  exact h.of_add_mul_left_left\n\n"}
{"name":"IsCoprime.of_add_mul_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime x (HAdd.hAdd y (HMul.hMul x z))\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_add_mul_left_right (h : IsCoprime x (y + x * z)) : IsCoprime x y := by\n  rw [isCoprime_comm] at h ⊢\n  exact h.of_add_mul_left_left\n\n"}
{"name":"IsCoprime.of_add_mul_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime x (HAdd.hAdd y (HMul.hMul z x))\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_add_mul_right_right (h : IsCoprime x (y + z * x)) : IsCoprime x y := by\n  rw [mul_comm] at h\n  exact h.of_add_mul_left_right\n\n"}
{"name":"IsCoprime.of_mul_add_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime (HAdd.hAdd (HMul.hMul y z) x) y\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_mul_add_left_left (h : IsCoprime (y * z + x) y) : IsCoprime x y := by\n  rw [add_comm] at h\n  exact h.of_add_mul_left_left\n\n"}
{"name":"IsCoprime.of_mul_add_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime (HAdd.hAdd (HMul.hMul z y) x) y\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_mul_add_right_left (h : IsCoprime (z * y + x) y) : IsCoprime x y := by\n  rw [add_comm] at h\n  exact h.of_add_mul_right_left\n\n"}
{"name":"IsCoprime.of_mul_add_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime x (HAdd.hAdd (HMul.hMul x z) y)\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_mul_add_left_right (h : IsCoprime x (x * z + y)) : IsCoprime x y := by\n  rw [add_comm] at h\n  exact h.of_add_mul_left_right\n\n"}
{"name":"IsCoprime.of_mul_add_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsCoprime x (HAdd.hAdd (HMul.hMul z x) y)\n⊢ IsCoprime x y","decl":"theorem IsCoprime.of_mul_add_right_right (h : IsCoprime x (z * x + y)) : IsCoprime x y := by\n  rw [add_comm] at h\n  exact h.of_add_mul_right_right\n\n"}
{"name":"IsRelPrime.of_add_mul_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime (HAdd.hAdd x (HMul.hMul y z)) y\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_add_mul_left_left (h : IsRelPrime (x + y * z) y) : IsRelPrime x y :=\n  fun _ hx hy ↦ h (dvd_add hx <| dvd_mul_of_dvd_left hy z) hy\n\n"}
{"name":"IsRelPrime.of_add_mul_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime (HAdd.hAdd x (HMul.hMul z y)) y\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_add_mul_right_left (h : IsRelPrime (x + z * y) y) : IsRelPrime x y :=\n  (mul_comm z y ▸ h).of_add_mul_left_left\n\n"}
{"name":"IsRelPrime.of_add_mul_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime x (HAdd.hAdd y (HMul.hMul x z))\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_add_mul_left_right (h : IsRelPrime x (y + x * z)) : IsRelPrime x y := by\n  rw [isRelPrime_comm] at h ⊢\n  exact h.of_add_mul_left_left\n\n"}
{"name":"IsRelPrime.of_add_mul_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime x (HAdd.hAdd y (HMul.hMul z x))\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_add_mul_right_right (h : IsRelPrime x (y + z * x)) : IsRelPrime x y :=\n  (mul_comm z x ▸ h).of_add_mul_left_right\n\n"}
{"name":"IsRelPrime.of_mul_add_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime (HAdd.hAdd (HMul.hMul y z) x) y\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_mul_add_left_left (h : IsRelPrime (y * z + x) y) : IsRelPrime x y :=\n  (add_comm _ x ▸ h).of_add_mul_left_left\n\n"}
{"name":"IsRelPrime.of_mul_add_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime (HAdd.hAdd (HMul.hMul z y) x) y\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_mul_add_right_left (h : IsRelPrime (z * y + x) y) : IsRelPrime x y :=\n  (add_comm _ x ▸ h).of_add_mul_right_left\n\n"}
{"name":"IsRelPrime.of_mul_add_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime x (HAdd.hAdd (HMul.hMul x z) y)\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_mul_add_left_right (h : IsRelPrime x (x * z + y)) : IsRelPrime x y :=\n  (add_comm _ y ▸ h).of_add_mul_left_right\n\n"}
{"name":"IsRelPrime.of_mul_add_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nx y z : R\nh : IsRelPrime x (HAdd.hAdd (HMul.hMul z x) y)\n⊢ IsRelPrime x y","decl":"theorem IsRelPrime.of_mul_add_right_right (h : IsRelPrime x (z * x + y)) : IsRelPrime x y :=\n  (add_comm _ y ▸ h).of_add_mul_right_right\n\n"}
{"name":"isCoprime_group_smul_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Group G\ninst✝² : MulAction G R\ninst✝¹ : SMulCommClass G R R\ninst✝ : IsScalarTower G R R\nx : G\ny z : R\n⊢ Iff (IsCoprime (HSMul.hSMul x y) z) (IsCoprime y z)","decl":"theorem isCoprime_group_smul_left : IsCoprime (x • y) z ↔ IsCoprime y z :=\n  ⟨fun ⟨a, b, h⟩ => ⟨x • a, b, by rwa [smul_mul_assoc, ← mul_smul_comm]⟩, fun ⟨a, b, h⟩ =>\n    ⟨x⁻¹ • a, b, by rwa [smul_mul_smul_comm, inv_mul_cancel, one_smul]⟩⟩\n\n"}
{"name":"isCoprime_group_smul_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Group G\ninst✝² : MulAction G R\ninst✝¹ : SMulCommClass G R R\ninst✝ : IsScalarTower G R R\nx : G\ny z : R\n⊢ Iff (IsCoprime y (HSMul.hSMul x z)) (IsCoprime y z)","decl":"theorem isCoprime_group_smul_right : IsCoprime y (x • z) ↔ IsCoprime y z :=\n  isCoprime_comm.trans <| (isCoprime_group_smul_left x z y).trans isCoprime_comm\n\n"}
{"name":"isCoprime_group_smul","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\nG : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : Group G\ninst✝² : MulAction G R\ninst✝¹ : SMulCommClass G R R\ninst✝ : IsScalarTower G R R\nx : G\ny z : R\n⊢ Iff (IsCoprime (HSMul.hSMul x y) (HSMul.hSMul x z)) (IsCoprime y z)","decl":"theorem isCoprime_group_smul : IsCoprime (x • y) (x • z) ↔ IsCoprime y z :=\n  (isCoprime_group_smul_left x y (x • z)).trans (isCoprime_group_smul_right x y z)\n\n"}
{"name":"isCoprime_mul_unit_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\nhu : IsUnit x\ny z : R\n⊢ Iff (IsCoprime (HMul.hMul x y) z) (IsCoprime y z)","decl":"theorem isCoprime_mul_unit_left_left (hu : IsUnit x) (y z : R) :\n    IsCoprime (x * y) z ↔ IsCoprime y z :=\n  let ⟨u, hu⟩ := hu\n  hu ▸ isCoprime_group_smul_left u y z\n\n"}
{"name":"isCoprime_mul_unit_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\nhu : IsUnit x\ny z : R\n⊢ Iff (IsCoprime y (HMul.hMul x z)) (IsCoprime y z)","decl":"theorem isCoprime_mul_unit_left_right (hu : IsUnit x) (y z : R) :\n    IsCoprime y (x * z) ↔ IsCoprime y z :=\n  let ⟨u, hu⟩ := hu\n  hu ▸ isCoprime_group_smul_right u y z\n\n"}
{"name":"isCoprime_mul_unit_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\nhu : IsUnit x\ny z : R\n⊢ Iff (IsCoprime (HMul.hMul y x) z) (IsCoprime y z)","decl":"theorem isCoprime_mul_unit_right_left (hu : IsUnit x) (y z : R) :\n    IsCoprime (y * x) z ↔ IsCoprime y z :=\n  mul_comm x y ▸ isCoprime_mul_unit_left_left hu y z\n\n"}
{"name":"isCoprime_mul_unit_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\nhu : IsUnit x\ny z : R\n⊢ Iff (IsCoprime y (HMul.hMul z x)) (IsCoprime y z)","decl":"theorem isCoprime_mul_unit_right_right (hu : IsUnit x) (y z : R) :\n    IsCoprime y (z * x) ↔ IsCoprime y z :=\n  mul_comm x z ▸ isCoprime_mul_unit_left_right hu y z\n\n"}
{"name":"isCoprime_mul_units_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nu v : R\nhu : IsUnit u\nhv : IsUnit v\ny z : R\n⊢ Iff (IsCoprime (HMul.hMul u y) (HMul.hMul v z)) (IsCoprime y z)","decl":"theorem isCoprime_mul_units_left (hu : IsUnit u) (hv : IsUnit v) (y z : R) :\n    IsCoprime (u * y) (v * z) ↔ IsCoprime y z :=\n  Iff.trans\n    (isCoprime_mul_unit_left_left hu _ _)\n    (isCoprime_mul_unit_left_right hv _ _)\n\n"}
{"name":"isCoprime_mul_units_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nu v : R\nhu : IsUnit u\nhv : IsUnit v\ny z : R\n⊢ Iff (IsCoprime (HMul.hMul y u) (HMul.hMul z v)) (IsCoprime y z)","decl":"theorem isCoprime_mul_units_right (hu : IsUnit u) (hv : IsUnit v) (y z : R) :\n    IsCoprime (y * u) (z * v) ↔ IsCoprime y z :=\n  Iff.trans\n    (isCoprime_mul_unit_right_left hu _ _)\n    (isCoprime_mul_unit_right_right hv _ _)\n\n"}
{"name":"isCoprime_mul_unit_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\nhu : IsUnit x\ny z : R\n⊢ Iff (IsCoprime (HMul.hMul x y) (HMul.hMul x z)) (IsCoprime y z)","decl":"theorem isCoprime_mul_unit_left (hu : IsUnit x) (y z : R) :\n    IsCoprime (x * y) (x * z) ↔ IsCoprime y z :=\n  isCoprime_mul_units_left hu hu _ _\n\n"}
{"name":"isCoprime_mul_unit_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nx : R\nhu : IsUnit x\ny z : R\n⊢ Iff (IsCoprime (HMul.hMul y x) (HMul.hMul z x)) (IsCoprime y z)","decl":"theorem isCoprime_mul_unit_right (hu : IsUnit x) (y z : R) :\n    IsCoprime (y * x) (z * x) ↔ IsCoprime y z :=\n  isCoprime_mul_units_right hu hu _ _\n\n"}
{"name":"IsCoprime.add_mul_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime (HAdd.hAdd x (HMul.hMul y z)) y","decl":"theorem add_mul_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + y * z) y :=\n  @of_add_mul_left_left R _ _ _ (-z) <| by simpa only [mul_neg, add_neg_cancel_right] using h\n\n"}
{"name":"IsCoprime.add_mul_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime (HAdd.hAdd x (HMul.hMul z y)) y","decl":"theorem add_mul_right_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (x + z * y) y := by\n  rw [mul_comm]\n  exact h.add_mul_left_left z\n\n"}
{"name":"IsCoprime.add_mul_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime x (HAdd.hAdd y (HMul.hMul x z))","decl":"theorem add_mul_left_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + x * z) := by\n  rw [isCoprime_comm]\n  exact h.symm.add_mul_left_left z\n\n"}
{"name":"IsCoprime.add_mul_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime x (HAdd.hAdd y (HMul.hMul z x))","decl":"theorem add_mul_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (y + z * x) := by\n  rw [isCoprime_comm]\n  exact h.symm.add_mul_right_left z\n\n"}
{"name":"IsCoprime.mul_add_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime (HAdd.hAdd (HMul.hMul y z) x) y","decl":"theorem mul_add_left_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (y * z + x) y := by\n  rw [add_comm]\n  exact h.add_mul_left_left z\n\n"}
{"name":"IsCoprime.mul_add_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime (HAdd.hAdd (HMul.hMul z y) x) y","decl":"theorem mul_add_right_left {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime (z * y + x) y := by\n  rw [add_comm]\n  exact h.add_mul_right_left z\n\n"}
{"name":"IsCoprime.mul_add_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime x (HAdd.hAdd (HMul.hMul x z) y)","decl":"theorem mul_add_left_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (x * z + y) := by\n  rw [add_comm]\n  exact h.add_mul_left_right z\n\n"}
{"name":"IsCoprime.mul_add_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\nz : R\n⊢ IsCoprime x (HAdd.hAdd (HMul.hMul z x) y)","decl":"theorem mul_add_right_right {x y : R} (h : IsCoprime x y) (z : R) : IsCoprime x (z * x + y) := by\n  rw [add_comm]\n  exact h.add_mul_right_right z\n\n"}
{"name":"IsCoprime.add_mul_left_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime (HAdd.hAdd x (HMul.hMul y z)) y) (IsCoprime x y)","decl":"theorem add_mul_left_left_iff {x y z : R} : IsCoprime (x + y * z) y ↔ IsCoprime x y :=\n  ⟨of_add_mul_left_left, fun h => h.add_mul_left_left z⟩\n\n"}
{"name":"IsCoprime.add_mul_right_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime (HAdd.hAdd x (HMul.hMul z y)) y) (IsCoprime x y)","decl":"theorem add_mul_right_left_iff {x y z : R} : IsCoprime (x + z * y) y ↔ IsCoprime x y :=\n  ⟨of_add_mul_right_left, fun h => h.add_mul_right_left z⟩\n\n"}
{"name":"IsCoprime.add_mul_left_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime x (HAdd.hAdd y (HMul.hMul x z))) (IsCoprime x y)","decl":"theorem add_mul_left_right_iff {x y z : R} : IsCoprime x (y + x * z) ↔ IsCoprime x y :=\n  ⟨of_add_mul_left_right, fun h => h.add_mul_left_right z⟩\n\n"}
{"name":"IsCoprime.add_mul_right_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime x (HAdd.hAdd y (HMul.hMul z x))) (IsCoprime x y)","decl":"theorem add_mul_right_right_iff {x y z : R} : IsCoprime x (y + z * x) ↔ IsCoprime x y :=\n  ⟨of_add_mul_right_right, fun h => h.add_mul_right_right z⟩\n\n"}
{"name":"IsCoprime.mul_add_left_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime (HAdd.hAdd (HMul.hMul y z) x) y) (IsCoprime x y)","decl":"theorem mul_add_left_left_iff {x y z : R} : IsCoprime (y * z + x) y ↔ IsCoprime x y :=\n  ⟨of_mul_add_left_left, fun h => h.mul_add_left_left z⟩\n\n"}
{"name":"IsCoprime.mul_add_right_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime (HAdd.hAdd (HMul.hMul z y) x) y) (IsCoprime x y)","decl":"theorem mul_add_right_left_iff {x y z : R} : IsCoprime (z * y + x) y ↔ IsCoprime x y :=\n  ⟨of_mul_add_right_left, fun h => h.mul_add_right_left z⟩\n\n"}
{"name":"IsCoprime.mul_add_left_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime x (HAdd.hAdd (HMul.hMul x z) y)) (IsCoprime x y)","decl":"theorem mul_add_left_right_iff {x y z : R} : IsCoprime x (x * z + y) ↔ IsCoprime x y :=\n  ⟨of_mul_add_left_right, fun h => h.mul_add_left_right z⟩\n\n"}
{"name":"IsCoprime.mul_add_right_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsCoprime x (HAdd.hAdd (HMul.hMul z x) y)) (IsCoprime x y)","decl":"theorem mul_add_right_right_iff {x y z : R} : IsCoprime x (z * x + y) ↔ IsCoprime x y :=\n  ⟨of_mul_add_right_right, fun h => h.mul_add_right_right z⟩\n\n"}
{"name":"IsCoprime.neg_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\n⊢ IsCoprime (Neg.neg x) y","decl":"theorem neg_left {x y : R} (h : IsCoprime x y) : IsCoprime (-x) y := by\n  obtain ⟨a, b, h⟩ := h\n  use -a, b\n  rwa [neg_mul_neg]\n\n"}
{"name":"IsCoprime.neg_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\n⊢ Iff (IsCoprime (Neg.neg x) y) (IsCoprime x y)","decl":"theorem neg_left_iff (x y : R) : IsCoprime (-x) y ↔ IsCoprime x y :=\n  ⟨fun h => neg_neg x ▸ h.neg_left, neg_left⟩\n\n"}
{"name":"IsCoprime.neg_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\n⊢ IsCoprime x (Neg.neg y)","decl":"theorem neg_right {x y : R} (h : IsCoprime x y) : IsCoprime x (-y) :=\n  h.symm.neg_left.symm\n\n"}
{"name":"IsCoprime.neg_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\n⊢ Iff (IsCoprime x (Neg.neg y)) (IsCoprime x y)","decl":"theorem neg_right_iff (x y : R) : IsCoprime x (-y) ↔ IsCoprime x y :=\n  ⟨fun h => neg_neg y ▸ h.neg_right, neg_right⟩\n\n"}
{"name":"IsCoprime.neg_neg","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\nh : IsCoprime x y\n⊢ IsCoprime (Neg.neg x) (Neg.neg y)","decl":"theorem neg_neg {x y : R} (h : IsCoprime x y) : IsCoprime (-x) (-y) :=\n  h.neg_left.neg_right\n\n"}
{"name":"IsCoprime.neg_neg_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\nx y : R\n⊢ Iff (IsCoprime (Neg.neg x) (Neg.neg y)) (IsCoprime x y)","decl":"theorem neg_neg_iff (x y : R) : IsCoprime (-x) (-y) ↔ IsCoprime x y :=\n  (neg_left_iff _ _).trans (neg_right_iff _ _)\n\n"}
{"name":"IsCoprime.abs_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : LinearOrder R\ninst✝ : AddLeftMono R\nx y : R\n⊢ Iff (IsCoprime (abs x) y) (IsCoprime x y)","decl":"lemma abs_left_iff (x y : R) : IsCoprime |x| y ↔ IsCoprime x y := by\n  cases le_or_lt 0 x with\n  | inl h => rw [abs_of_nonneg h]\n  | inr h => rw [abs_of_neg h, IsCoprime.neg_left_iff]\n\n"}
{"name":"IsCoprime.abs_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : LinearOrder R\ninst✝ : AddLeftMono R\nx y : R\nh : IsCoprime x y\n⊢ IsCoprime (abs x) y","decl":"lemma abs_left {x y : R} (h : IsCoprime x y) : IsCoprime |x| y := abs_left_iff _ _ |>.2 h\n\n"}
{"name":"IsCoprime.abs_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : LinearOrder R\ninst✝ : AddLeftMono R\nx y : R\n⊢ Iff (IsCoprime x (abs y)) (IsCoprime x y)","decl":"lemma abs_right_iff (x y : R) : IsCoprime x |y| ↔ IsCoprime x y := by\n  rw [isCoprime_comm, IsCoprime.abs_left_iff, isCoprime_comm]\n\n"}
{"name":"IsCoprime.abs_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : LinearOrder R\ninst✝ : AddLeftMono R\nx y : R\nh : IsCoprime x y\n⊢ IsCoprime x (abs y)","decl":"lemma abs_right {x y : R} (h : IsCoprime x y) : IsCoprime x |y| := abs_right_iff _ _ |>.2 h\n\n"}
{"name":"IsCoprime.abs_abs_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : LinearOrder R\ninst✝ : AddLeftMono R\nx y : R\n⊢ Iff (IsCoprime (abs x) (abs y)) (IsCoprime x y)","decl":"theorem abs_abs_iff (x y : R) : IsCoprime |x| |y| ↔ IsCoprime x y :=\n  (abs_left_iff _ _).trans (abs_right_iff _ _)\n\n"}
{"name":"IsCoprime.abs_abs","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\ninst✝¹ : LinearOrder R\ninst✝ : AddLeftMono R\nx y : R\nh : IsCoprime x y\n⊢ IsCoprime (abs x) (abs y)","decl":"theorem abs_abs {x y : R} (h : IsCoprime x y) : IsCoprime |x| |y| := h.abs_left.abs_right\n\n"}
{"name":"IsCoprime.sq_add_sq_ne_zero","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : LinearOrderedCommRing R\na b : R\nh : IsCoprime a b\n⊢ Ne (HAdd.hAdd (HPow.hPow a 2) (HPow.hPow b 2)) 0","decl":"theorem sq_add_sq_ne_zero {R : Type*} [LinearOrderedCommRing R] {a b : R} (h : IsCoprime a b) :\n    a ^ 2 + b ^ 2 ≠ 0 := by\n  intro h'\n  obtain ⟨ha, hb⟩ := (add_eq_zero_iff_of_nonneg (sq_nonneg _) (sq_nonneg _)).mp h'\n  obtain rfl := pow_eq_zero ha\n  obtain rfl := pow_eq_zero hb\n  exact not_isCoprime_zero_zero h\n\n"}
{"name":"Nat.isCoprime_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"m n : Nat\n⊢ Iff (IsCoprime m n) (Or (Eq m 1) (Eq n 1))","decl":"/-- `IsCoprime` is not a useful definition for `Nat`; consider using `Nat.Coprime` instead. -/\n@[simp]\nlemma Nat.isCoprime_iff {m n : ℕ} : IsCoprime m n ↔ m = 1 ∨ n = 1 := by\n  refine ⟨fun ⟨a, b, H⟩ => ?_, fun h => ?_⟩\n  · simp_rw [Nat.add_eq_one_iff, mul_eq_one, mul_eq_zero] at H\n    exact H.symm.imp (·.1.2) (·.2.2)\n  · obtain rfl | rfl := h\n    · exact isCoprime_one_left\n    · exact isCoprime_one_right\n\n"}
{"name":"PNat.isCoprime_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"m n : PNat\n⊢ Iff (IsCoprime ↑m ↑n) (Or (Eq m 1) (Eq n 1))","decl":"/-- `IsCoprime` is not a useful definition for `PNat`; consider using `Nat.Coprime` instead. -/\nlemma PNat.isCoprime_iff {m n : ℕ+} : IsCoprime (m : ℕ) n ↔ m = 1 ∨ n = 1 := by simp\n\n"}
{"name":"Semifield.isCoprime_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : Semifield R\nm n : R\n⊢ Iff (IsCoprime m n) (Or (Ne m 0) (Ne n 0))","decl":"/-- `IsCoprime` is not a useful definition if an inverse is available. -/\n@[simp]\nlemma Semifield.isCoprime_iff {R : Type*} [Semifield R] {m n : R} :\n    IsCoprime m n ↔ m ≠ 0 ∨ n ≠ 0 := by\n  obtain rfl | hn := eq_or_ne n 0\n  · simp [isCoprime_zero_right]\n  suffices IsCoprime m n by simpa [hn]\n  refine ⟨0, n⁻¹, ?_⟩\n  simp [inv_mul_cancel₀ hn]\n\n"}
{"name":"IsRelPrime.add_mul_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime (HAdd.hAdd x (HMul.hMul y z)) y","decl":"theorem add_mul_left_left (h : IsRelPrime x y) (z : R) : IsRelPrime (x + y * z) y :=\n  @of_add_mul_left_left R _ _ _ (-z) <| by simpa only [mul_neg, add_neg_cancel_right] using h\n\n"}
{"name":"IsRelPrime.add_mul_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime (HAdd.hAdd x (HMul.hMul z y)) y","decl":"theorem add_mul_right_left (h : IsRelPrime x y) (z : R) : IsRelPrime (x + z * y) y :=\n  mul_comm z y ▸ h.add_mul_left_left z\n\n"}
{"name":"IsRelPrime.add_mul_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime x (HAdd.hAdd y (HMul.hMul x z))","decl":"theorem add_mul_left_right (h : IsRelPrime x y) (z : R) : IsRelPrime x (y + x * z) :=\n  (h.symm.add_mul_left_left z).symm\n\n"}
{"name":"IsRelPrime.add_mul_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime x (HAdd.hAdd y (HMul.hMul z x))","decl":"theorem add_mul_right_right (h : IsRelPrime x y) (z : R) : IsRelPrime x (y + z * x) :=\n  (h.symm.add_mul_right_left z).symm\n\n"}
{"name":"IsRelPrime.mul_add_left_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime (HAdd.hAdd (HMul.hMul y z) x) y","decl":"theorem mul_add_left_left (h : IsRelPrime x y) (z : R) : IsRelPrime (y * z + x) y :=\n  add_comm x _ ▸ h.add_mul_left_left z\n\n"}
{"name":"IsRelPrime.mul_add_right_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime (HAdd.hAdd (HMul.hMul z y) x) y","decl":"theorem mul_add_right_left (h : IsRelPrime x y) (z : R) : IsRelPrime (z * y + x) y :=\n  add_comm x _ ▸ h.add_mul_right_left z\n\n"}
{"name":"IsRelPrime.mul_add_left_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime x (HAdd.hAdd (HMul.hMul x z) y)","decl":"theorem mul_add_left_right (h : IsRelPrime x y) (z : R) : IsRelPrime x (x * z + y) :=\n  add_comm y _ ▸ h.add_mul_left_right z\n\n"}
{"name":"IsRelPrime.mul_add_right_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\nz : R\n⊢ IsRelPrime x (HAdd.hAdd (HMul.hMul z x) y)","decl":"theorem mul_add_right_right (h : IsRelPrime x y) (z : R) : IsRelPrime x (z * x + y) :=\n  add_comm y _ ▸ h.add_mul_right_right z\n\n"}
{"name":"IsRelPrime.add_mul_left_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime (HAdd.hAdd x (HMul.hMul y z)) y) (IsRelPrime x y)","decl":"theorem add_mul_left_left_iff : IsRelPrime (x + y * z) y ↔ IsRelPrime x y :=\n  ⟨of_add_mul_left_left, fun h ↦ h.add_mul_left_left z⟩\n\n"}
{"name":"IsRelPrime.add_mul_right_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime (HAdd.hAdd x (HMul.hMul z y)) y) (IsRelPrime x y)","decl":"theorem add_mul_right_left_iff : IsRelPrime (x + z * y) y ↔ IsRelPrime x y :=\n  ⟨of_add_mul_right_left, fun h ↦ h.add_mul_right_left z⟩\n\n"}
{"name":"IsRelPrime.add_mul_left_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime x (HAdd.hAdd y (HMul.hMul x z))) (IsRelPrime x y)","decl":"theorem add_mul_left_right_iff : IsRelPrime x (y + x * z) ↔ IsRelPrime x y :=\n  ⟨of_add_mul_left_right, fun h ↦ h.add_mul_left_right z⟩\n\n"}
{"name":"IsRelPrime.add_mul_right_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime x (HAdd.hAdd y (HMul.hMul z x))) (IsRelPrime x y)","decl":"theorem add_mul_right_right_iff : IsRelPrime x (y + z * x) ↔ IsRelPrime x y :=\n  ⟨of_add_mul_right_right, fun h ↦ h.add_mul_right_right z⟩\n\n"}
{"name":"IsRelPrime.mul_add_left_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime (HAdd.hAdd (HMul.hMul y z) x) y) (IsRelPrime x y)","decl":"theorem mul_add_left_left_iff {x y z : R} : IsRelPrime (y * z + x) y ↔ IsRelPrime x y :=\n  ⟨of_mul_add_left_left, fun h ↦ h.mul_add_left_left z⟩\n\n"}
{"name":"IsRelPrime.mul_add_right_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime (HAdd.hAdd (HMul.hMul z y) x) y) (IsRelPrime x y)","decl":"theorem mul_add_right_left_iff {x y z : R} : IsRelPrime (z * y + x) y ↔ IsRelPrime x y :=\n  ⟨of_mul_add_right_left, fun h ↦ h.mul_add_right_left z⟩\n\n"}
{"name":"IsRelPrime.mul_add_left_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime x (HAdd.hAdd (HMul.hMul x z) y)) (IsRelPrime x y)","decl":"theorem mul_add_left_right_iff {x y z : R} : IsRelPrime x (x * z + y) ↔ IsRelPrime x y :=\n  ⟨of_mul_add_left_right, fun h ↦ h.mul_add_left_right z⟩\n\n"}
{"name":"IsRelPrime.mul_add_right_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y z : R\n⊢ Iff (IsRelPrime x (HAdd.hAdd (HMul.hMul z x) y)) (IsRelPrime x y)","decl":"theorem mul_add_right_right_iff {x y z : R} : IsRelPrime x (z * x + y) ↔ IsRelPrime x y :=\n  ⟨of_mul_add_right_right, fun h ↦ h.mul_add_right_right z⟩\n\n"}
{"name":"IsRelPrime.neg_left","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\n⊢ IsRelPrime (Neg.neg x) y","decl":"theorem neg_left (h : IsRelPrime x y) : IsRelPrime (-x) y := fun _ ↦ (h <| dvd_neg.mp ·)\n"}
{"name":"IsRelPrime.neg_right","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\n⊢ IsRelPrime x (Neg.neg y)","decl":"theorem neg_right (h : IsRelPrime x y) : IsRelPrime x (-y) := h.symm.neg_left.symm\n"}
{"name":"IsRelPrime.neg_neg","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\nh : IsRelPrime x y\n⊢ IsRelPrime (Neg.neg x) (Neg.neg y)","decl":"protected theorem neg_neg (h : IsRelPrime x y) : IsRelPrime (-x) (-y) := h.neg_left.neg_right\n\n"}
{"name":"IsRelPrime.neg_left_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\n⊢ Iff (IsRelPrime (Neg.neg x) y) (IsRelPrime x y)","decl":"theorem neg_left_iff (x y : R) : IsRelPrime (-x) y ↔ IsRelPrime x y :=\n  ⟨fun h ↦ neg_neg x ▸ h.neg_left, neg_left⟩\n\n"}
{"name":"IsRelPrime.neg_right_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\n⊢ Iff (IsRelPrime x (Neg.neg y)) (IsRelPrime x y)","decl":"theorem neg_right_iff (x y : R) : IsRelPrime x (-y) ↔ IsRelPrime x y :=\n  ⟨fun h ↦ neg_neg y ▸ h.neg_right, neg_right⟩\n\n"}
{"name":"IsRelPrime.neg_neg_iff","module":"Mathlib.RingTheory.Coprime.Basic","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nx y : R\n⊢ Iff (IsRelPrime (Neg.neg x) (Neg.neg y)) (IsRelPrime x y)","decl":"theorem neg_neg_iff (x y : R) : IsRelPrime (-x) (-y) ↔ IsRelPrime x y :=\n  (neg_left_iff _ _).trans (neg_right_iff _ _)\n\n"}
