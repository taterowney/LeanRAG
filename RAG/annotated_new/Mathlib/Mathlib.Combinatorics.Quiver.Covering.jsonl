{"name":"Prefunctor.star_fst","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu : U\na✝ : Quiver.Star u\n⊢ Eq (φ.star u a✝).fst (φ.obj a✝.fst)","decl":"/-- A prefunctor induces a map of `Quiver.Star` at every vertex. -/\n@[simps]\ndef Prefunctor.star (u : U) : Quiver.Star u → Quiver.Star (φ.obj u) := fun F =>\n  Quiver.Star.mk (φ.map F.2)\n\n"}
{"name":"Prefunctor.star_snd","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu : U\na✝ : Quiver.Star u\n⊢ Eq (φ.star u a✝).snd (φ.map a✝.snd)","decl":"/-- A prefunctor induces a map of `Quiver.Star` at every vertex. -/\n@[simps]\ndef Prefunctor.star (u : U) : Quiver.Star u → Quiver.Star (φ.obj u) := fun F =>\n  Quiver.Star.mk (φ.map F.2)\n\n"}
{"name":"Prefunctor.costar_snd","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu : U\na✝ : Quiver.Costar u\n⊢ Eq (φ.costar u a✝).snd (φ.map a✝.snd)","decl":"/-- A prefunctor induces a map of `Quiver.Costar` at every vertex. -/\n@[simps]\ndef Prefunctor.costar (u : U) : Quiver.Costar u → Quiver.Costar (φ.obj u) := fun F =>\n  Quiver.Costar.mk (φ.map F.2)\n\n"}
{"name":"Prefunctor.costar_fst","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu : U\na✝ : Quiver.Costar u\n⊢ Eq (φ.costar u a✝).fst (φ.obj a✝.fst)","decl":"/-- A prefunctor induces a map of `Quiver.Costar` at every vertex. -/\n@[simps]\ndef Prefunctor.costar (u : U) : Quiver.Costar u → Quiver.Costar (φ.obj u) := fun F =>\n  Quiver.Costar.mk (φ.map F.2)\n\n"}
{"name":"Prefunctor.star_apply","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu v : U\ne : Quiver.Hom u v\n⊢ Eq (φ.star u (Quiver.Star.mk e)) (Quiver.Star.mk (φ.map e))","decl":"@[simp]\ntheorem Prefunctor.star_apply {u v : U} (e : u ⟶ v) :\n    φ.star u (Quiver.Star.mk e) = Quiver.Star.mk (φ.map e) :=\n  rfl\n\n"}
{"name":"Prefunctor.costar_apply","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu v : U\ne : Quiver.Hom u v\n⊢ Eq (φ.costar v (Quiver.Costar.mk e)) (Quiver.Costar.mk (φ.map e))","decl":"@[simp]\ntheorem Prefunctor.costar_apply {u v : U} (e : u ⟶ v) :\n    φ.costar v (Quiver.Costar.mk e) = Quiver.Costar.mk (φ.map e) :=\n  rfl\n\n"}
{"name":"Prefunctor.star_comp","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝² : Quiver U\nV : Type u_3\ninst✝¹ : Quiver V\nφ : Prefunctor U V\nW : Type u_2\ninst✝ : Quiver W\nψ : Prefunctor V W\nu : U\n⊢ Eq ((φ.comp ψ).star u) (Function.comp (ψ.star (φ.obj u)) (φ.star u))","decl":"theorem Prefunctor.star_comp (u : U) : (φ ⋙q ψ).star u = ψ.star (φ.obj u) ∘ φ.star u :=\n  rfl\n\n"}
{"name":"Prefunctor.costar_comp","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝² : Quiver U\nV : Type u_3\ninst✝¹ : Quiver V\nφ : Prefunctor U V\nW : Type u_2\ninst✝ : Quiver W\nψ : Prefunctor V W\nu : U\n⊢ Eq ((φ.comp ψ).costar u) (Function.comp (ψ.costar (φ.obj u)) (φ.costar u))","decl":"theorem Prefunctor.costar_comp (u : U) : (φ ⋙q ψ).costar u = ψ.costar (φ.obj u) ∘ φ.costar u :=\n  rfl\n\n"}
{"name":"Prefunctor.IsCovering.star_bijective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nself : φ.IsCovering\nu : U\n⊢ Function.Bijective (φ.star u)","decl":"/-- A prefunctor is a covering of quivers if it defines bijections on all stars and costars. -/\nprotected structure Prefunctor.IsCovering : Prop where\n  star_bijective : ∀ u, Bijective (φ.star u)\n  costar_bijective : ∀ u, Bijective (φ.costar u)\n\n"}
{"name":"Prefunctor.IsCovering.costar_bijective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nself : φ.IsCovering\nu : U\n⊢ Function.Bijective (φ.costar u)","decl":"/-- A prefunctor is a covering of quivers if it defines bijections on all stars and costars. -/\nprotected structure Prefunctor.IsCovering : Prop where\n  star_bijective : ∀ u, Bijective (φ.star u)\n  costar_bijective : ∀ u, Bijective (φ.costar u)\n\n"}
{"name":"Prefunctor.IsCovering.map_injective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nhφ : φ.IsCovering\nu v : U\n⊢ Function.Injective fun f => φ.map f","decl":"@[simp]\ntheorem Prefunctor.IsCovering.map_injective (hφ : φ.IsCovering) {u v : U} :\n    Injective fun f : u ⟶ v => φ.map f := by\n  rintro f g he\n  have : φ.star u (Quiver.Star.mk f) = φ.star u (Quiver.Star.mk g) := by simpa using he\n  simpa using (hφ.star_bijective u).left this\n\n"}
{"name":"Prefunctor.IsCovering.comp","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝² : Quiver U\nV : Type u_2\ninst✝¹ : Quiver V\nφ : Prefunctor U V\nW : Type u_3\ninst✝ : Quiver W\nψ : Prefunctor V W\nhφ : φ.IsCovering\nhψ : ψ.IsCovering\n⊢ (φ.comp ψ).IsCovering","decl":"theorem Prefunctor.IsCovering.comp (hφ : φ.IsCovering) (hψ : ψ.IsCovering) : (φ ⋙q ψ).IsCovering :=\n  ⟨fun _ => (hψ.star_bijective _).comp (hφ.star_bijective _),\n   fun _ => (hψ.costar_bijective _).comp (hφ.costar_bijective _)⟩\n\n"}
{"name":"Prefunctor.IsCovering.of_comp_right","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_3\ninst✝² : Quiver U\nV : Type u_1\ninst✝¹ : Quiver V\nφ : Prefunctor U V\nW : Type u_2\ninst✝ : Quiver W\nψ : Prefunctor V W\nhψ : ψ.IsCovering\nhφψ : (φ.comp ψ).IsCovering\n⊢ φ.IsCovering","decl":"theorem Prefunctor.IsCovering.of_comp_right (hψ : ψ.IsCovering) (hφψ : (φ ⋙q ψ).IsCovering) :\n    φ.IsCovering :=\n  ⟨fun _ => (Bijective.of_comp_iff' (hψ.star_bijective _) _).mp (hφψ.star_bijective _),\n   fun _ => (Bijective.of_comp_iff' (hψ.costar_bijective _) _).mp (hφψ.costar_bijective _)⟩\n\n"}
{"name":"Prefunctor.IsCovering.of_comp_left","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝² : Quiver U\nV : Type u_2\ninst✝¹ : Quiver V\nφ : Prefunctor U V\nW : Type u_3\ninst✝ : Quiver W\nψ : Prefunctor V W\nhφ : φ.IsCovering\nhφψ : (φ.comp ψ).IsCovering\nφsur : Function.Surjective φ.obj\n⊢ ψ.IsCovering","decl":"theorem Prefunctor.IsCovering.of_comp_left (hφ : φ.IsCovering) (hφψ : (φ ⋙q ψ).IsCovering)\n    (φsur : Surjective φ.obj) : ψ.IsCovering := by\n  refine ⟨fun v => ?_, fun v => ?_⟩ <;> obtain ⟨u, rfl⟩ := φsur v\n  exacts [(Bijective.of_comp_iff _ (hφ.star_bijective u)).mp (hφψ.star_bijective u),\n    (Bijective.of_comp_iff _ (hφ.costar_bijective u)).mp (hφψ.costar_bijective u)]\n\n"}
{"name":"Prefunctor.symmetrifyStar","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu : U\n⊢ Eq (φ.symmetrify.star u) (Function.comp (⇑(Quiver.symmetrifyStar (φ.obj u)).symm) (Function.comp (Sum.map (φ.star u) (φ.costar u)) ⇑(Quiver.symmetrifyStar u)))","decl":"theorem Prefunctor.symmetrifyStar (u : U) :\n    φ.symmetrify.star u =\n      (Quiver.symmetrifyStar _).symm ∘ Sum.map (φ.star u) (φ.costar u) ∘\n        Quiver.symmetrifyStar u := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [Equiv.eq_symm_comp]\n  ext ⟨v, f | g⟩ <;>\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [Quiver.symmetrifyStar]`\n    simp only [Quiver.symmetrifyStar, Function.comp_apply] <;>\n    erw [Equiv.sigmaSumDistrib_apply, Equiv.sigmaSumDistrib_apply] <;>\n    simp\n\n"}
{"name":"Prefunctor.symmetrifyCostar","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu : U\n⊢ Eq (φ.symmetrify.costar u) (Function.comp (⇑(Quiver.symmetrifyCostar (φ.obj u)).symm) (Function.comp (Sum.map (φ.costar u) (φ.star u)) ⇑(Quiver.symmetrifyCostar u)))","decl":"protected theorem Prefunctor.symmetrifyCostar (u : U) :\n    φ.symmetrify.costar u =\n      (Quiver.symmetrifyCostar _).symm ∘\n        Sum.map (φ.costar u) (φ.star u) ∘ Quiver.symmetrifyCostar u := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [Equiv.eq_symm_comp]\n  ext ⟨v, f | g⟩ <;>\n    -- Porting note (https://github.com/leanprover-community/mathlib4/issues/10745): was `simp [Quiver.symmetrifyCostar]`\n    simp only [Quiver.symmetrifyCostar, Function.comp_apply] <;>\n    erw [Equiv.sigmaSumDistrib_apply, Equiv.sigmaSumDistrib_apply] <;>\n    simp\n\n"}
{"name":"Prefunctor.IsCovering.symmetrify","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nhφ : φ.IsCovering\n⊢ φ.symmetrify.IsCovering","decl":"protected theorem Prefunctor.IsCovering.symmetrify (hφ : φ.IsCovering) :\n    φ.symmetrify.IsCovering := by\n  refine ⟨fun u => ?_, fun u => ?_⟩ <;>\n    -- Porting note: was\n    -- simp [φ.symmetrifyStar, φ.symmetrifyCostar, hφ.star_bijective u, hφ.costar_bijective u]\n    simp only [φ.symmetrifyStar, φ.symmetrifyCostar] <;>\n    erw [EquivLike.comp_bijective, EquivLike.bijective_comp] <;>\n    simp [hφ.star_bijective u, hφ.costar_bijective u]\n\n"}
{"name":"Prefunctor.pathStar_apply","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nu v : U\np : Quiver.Path u v\n⊢ Eq (φ.pathStar u (Quiver.PathStar.mk p)) (Quiver.PathStar.mk (φ.mapPath p))","decl":"@[simp]\ntheorem Prefunctor.pathStar_apply {u v : U} (p : Path u v) :\n    φ.pathStar u (Quiver.PathStar.mk p) = Quiver.PathStar.mk (φ.mapPath p) :=\n  rfl\n\n"}
{"name":"Prefunctor.pathStar_injective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nhφ : ∀ (u : U), Function.Injective (φ.star u)\nu : U\n⊢ Function.Injective (φ.pathStar u)","decl":"theorem Prefunctor.pathStar_injective (hφ : ∀ u, Injective (φ.star u)) (u : U) :\n    Injective (φ.pathStar u) := by\n  dsimp (config := { unfoldPartialApp := true }) [Prefunctor.pathStar, Quiver.PathStar.mk]\n  rintro ⟨v₁, p₁⟩\n  induction' p₁ with x₁ y₁ p₁ e₁ ih <;>\n    rintro ⟨y₂, p₂⟩ <;>\n    cases' p₂ with x₂ _ p₂ e₂ <;>\n    intro h <;>\n    simp at h\n  · rfl\n  · exfalso\n    cases' h with h h'\n    rw [← Path.eq_cast_iff_heq rfl h.symm, Path.cast_cons] at h'\n    exact (Path.nil_ne_cons _ _) h'\n  · exfalso\n    cases' h with h h'\n    rw [← Path.cast_eq_iff_heq rfl h, Path.cast_cons] at h'\n    exact (Path.cons_ne_nil _ _) h'\n  · cases' h with hφy h'\n    rw [← Path.cast_eq_iff_heq rfl hφy, Path.cast_cons, Path.cast_rfl_rfl] at h'\n    have hφx := Path.obj_eq_of_cons_eq_cons h'\n    have hφp := Path.heq_of_cons_eq_cons h'\n    have hφe := HEq.trans (Hom.cast_heq rfl hφy _).symm (Path.hom_heq_of_cons_eq_cons h')\n    have h_path_star : φ.pathStar u ⟨x₁, p₁⟩ = φ.pathStar u ⟨x₂, p₂⟩ := by\n      simp only [Prefunctor.pathStar_apply, Sigma.mk.inj_iff]; exact ⟨hφx, hφp⟩\n    cases ih h_path_star\n    have h_star : φ.star x₁ ⟨y₁, e₁⟩ = φ.star x₁ ⟨y₂, e₂⟩ := by\n      simp only [Prefunctor.star_apply, Sigma.mk.inj_iff]; exact ⟨hφy, hφe⟩\n    cases hφ x₁ h_star\n    rfl\n\n"}
{"name":"Prefunctor.pathStar_surjective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nhφ : ∀ (u : U), Function.Surjective (φ.star u)\nu : U\n⊢ Function.Surjective (φ.pathStar u)","decl":"theorem Prefunctor.pathStar_surjective (hφ : ∀ u, Surjective (φ.star u)) (u : U) :\n    Surjective (φ.pathStar u) := by\n  dsimp (config := { unfoldPartialApp := true }) [Prefunctor.pathStar, Quiver.PathStar.mk]\n  rintro ⟨v, p⟩\n  induction' p with v' v'' p' ev ih\n  · use ⟨u, Path.nil⟩\n    simp only [Prefunctor.mapPath_nil, eq_self_iff_true, heq_iff_eq, and_self_iff]\n  · obtain ⟨⟨u', q'⟩, h⟩ := ih\n    simp only at h\n    obtain ⟨rfl, rfl⟩ := h\n    obtain ⟨⟨u'', eu⟩, k⟩ := hφ u' ⟨_, ev⟩\n    simp only [star_apply, Sigma.mk.inj_iff] at k\n    -- Porting note: was `obtain ⟨rfl, rfl⟩ := k`\n    obtain ⟨rfl, k⟩ := k\n    simp only [heq_eq_eq] at k\n    subst k\n    use ⟨_, q'.cons eu⟩\n    simp only [Prefunctor.mapPath_cons, eq_self_iff_true, heq_iff_eq, and_self_iff]\n\n"}
{"name":"Prefunctor.pathStar_bijective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nhφ : ∀ (u : U), Function.Bijective (φ.star u)\nu : U\n⊢ Function.Bijective (φ.pathStar u)","decl":"theorem Prefunctor.pathStar_bijective (hφ : ∀ u, Bijective (φ.star u)) (u : U) :\n    Bijective (φ.pathStar u) :=\n  ⟨φ.pathStar_injective (fun u => (hφ u).1) _, φ.pathStar_surjective (fun u => (hφ u).2) _⟩\n\n"}
{"name":"Prefunctor.IsCovering.pathStar_bijective","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\nV : Type u_2\ninst✝ : Quiver V\nφ : Prefunctor U V\nhφ : φ.IsCovering\nu : U\n⊢ Function.Bijective (φ.pathStar u)","decl":"protected theorem pathStar_bijective (hφ : φ.IsCovering) (u : U) : Bijective (φ.pathStar u) :=\n  φ.pathStar_bijective hφ.1 u\n\n"}
{"name":"Quiver.starEquivCostar_apply_fst","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasInvolutiveReverse U\nu : U\ne : Quiver.Star u\n⊢ Eq ((Quiver.starEquivCostar u) e).fst e.fst","decl":"/-- In a quiver with involutive inverses, the star and costar at every vertex are equivalent.\nThis map is induced by `Quiver.reverse`. -/\n@[simps]\ndef Quiver.starEquivCostar (u : U) : Quiver.Star u ≃ Quiver.Costar u where\n  toFun e := ⟨e.1, reverse e.2⟩\n  invFun e := ⟨e.1, reverse e.2⟩\n  left_inv e := by simp [Sigma.ext_iff]\n  right_inv e := by simp [Sigma.ext_iff]\n\n"}
{"name":"Quiver.starEquivCostar_symm_apply_snd","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasInvolutiveReverse U\nu : U\ne : Quiver.Costar u\n⊢ Eq ((Quiver.starEquivCostar u).symm e).snd (Quiver.reverse e.snd)","decl":"/-- In a quiver with involutive inverses, the star and costar at every vertex are equivalent.\nThis map is induced by `Quiver.reverse`. -/\n@[simps]\ndef Quiver.starEquivCostar (u : U) : Quiver.Star u ≃ Quiver.Costar u where\n  toFun e := ⟨e.1, reverse e.2⟩\n  invFun e := ⟨e.1, reverse e.2⟩\n  left_inv e := by simp [Sigma.ext_iff]\n  right_inv e := by simp [Sigma.ext_iff]\n\n"}
{"name":"Quiver.starEquivCostar_apply_snd","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasInvolutiveReverse U\nu : U\ne : Quiver.Star u\n⊢ Eq ((Quiver.starEquivCostar u) e).snd (Quiver.reverse e.snd)","decl":"/-- In a quiver with involutive inverses, the star and costar at every vertex are equivalent.\nThis map is induced by `Quiver.reverse`. -/\n@[simps]\ndef Quiver.starEquivCostar (u : U) : Quiver.Star u ≃ Quiver.Costar u where\n  toFun e := ⟨e.1, reverse e.2⟩\n  invFun e := ⟨e.1, reverse e.2⟩\n  left_inv e := by simp [Sigma.ext_iff]\n  right_inv e := by simp [Sigma.ext_iff]\n\n"}
{"name":"Quiver.starEquivCostar_symm_apply_fst","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasInvolutiveReverse U\nu : U\ne : Quiver.Costar u\n⊢ Eq ((Quiver.starEquivCostar u).symm e).fst e.fst","decl":"/-- In a quiver with involutive inverses, the star and costar at every vertex are equivalent.\nThis map is induced by `Quiver.reverse`. -/\n@[simps]\ndef Quiver.starEquivCostar (u : U) : Quiver.Star u ≃ Quiver.Costar u where\n  toFun e := ⟨e.1, reverse e.2⟩\n  invFun e := ⟨e.1, reverse e.2⟩\n  left_inv e := by simp [Sigma.ext_iff]\n  right_inv e := by simp [Sigma.ext_iff]\n\n"}
{"name":"Quiver.starEquivCostar_apply","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasInvolutiveReverse U\nu v : U\ne : Quiver.Hom u v\n⊢ Eq ((Quiver.starEquivCostar u) (Quiver.Star.mk e)) (Quiver.Costar.mk (Quiver.reverse e))","decl":"@[simp]\ntheorem Quiver.starEquivCostar_apply {u v : U} (e : u ⟶ v) :\n    Quiver.starEquivCostar u (Quiver.Star.mk e) = Quiver.Costar.mk (reverse e) :=\n  rfl\n\n"}
{"name":"Quiver.starEquivCostar_symm_apply","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝¹ : Quiver U\ninst✝ : Quiver.HasInvolutiveReverse U\nu v : U\ne : Quiver.Hom u v\n⊢ Eq ((Quiver.starEquivCostar v).symm (Quiver.Costar.mk e)) (Quiver.Star.mk (Quiver.reverse e))","decl":"@[simp]\ntheorem Quiver.starEquivCostar_symm_apply {u v : U} (e : u ⟶ v) :\n    (Quiver.starEquivCostar v).symm (Quiver.Costar.mk e) = Quiver.Star.mk (reverse e) :=\n  rfl\n\n"}
{"name":"Prefunctor.costar_conj_star","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝⁴ : Quiver U\nV : Type u_2\ninst✝³ : Quiver V\nφ : Prefunctor U V\ninst✝² : Quiver.HasInvolutiveReverse U\ninst✝¹ : Quiver.HasInvolutiveReverse V\ninst✝ : φ.MapReverse\nu : U\n⊢ Eq (φ.costar u) (Function.comp (⇑(Quiver.starEquivCostar (φ.obj u))) (Function.comp (φ.star u) ⇑(Quiver.starEquivCostar u).symm))","decl":"theorem Prefunctor.costar_conj_star (u : U) :\n    φ.costar u = Quiver.starEquivCostar (φ.obj u) ∘ φ.star u ∘ (Quiver.starEquivCostar u).symm := by\n  ext ⟨v, f⟩ <;> simp\n\n"}
{"name":"Prefunctor.bijective_costar_iff_bijective_star","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝⁴ : Quiver U\nV : Type u_2\ninst✝³ : Quiver V\nφ : Prefunctor U V\ninst✝² : Quiver.HasInvolutiveReverse U\ninst✝¹ : Quiver.HasInvolutiveReverse V\ninst✝ : φ.MapReverse\nu : U\n⊢ Iff (Function.Bijective (φ.costar u)) (Function.Bijective (φ.star u))","decl":"theorem Prefunctor.bijective_costar_iff_bijective_star (u : U) :\n    Bijective (φ.costar u) ↔ Bijective (φ.star u) := by\n  rw [Prefunctor.costar_conj_star φ, EquivLike.comp_bijective, EquivLike.bijective_comp]\n\n"}
{"name":"Prefunctor.isCovering_of_bijective_star","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝⁴ : Quiver U\nV : Type u_2\ninst✝³ : Quiver V\nφ : Prefunctor U V\ninst✝² : Quiver.HasInvolutiveReverse U\ninst✝¹ : Quiver.HasInvolutiveReverse V\ninst✝ : φ.MapReverse\nh : ∀ (u : U), Function.Bijective (φ.star u)\n⊢ φ.IsCovering","decl":"theorem Prefunctor.isCovering_of_bijective_star (h : ∀ u, Bijective (φ.star u)) : φ.IsCovering :=\n  ⟨h, fun u => (φ.bijective_costar_iff_bijective_star u).2 (h u)⟩\n\n"}
{"name":"Prefunctor.isCovering_of_bijective_costar","module":"Mathlib.Combinatorics.Quiver.Covering","initialProofState":"U : Type u_1\ninst✝⁴ : Quiver U\nV : Type u_2\ninst✝³ : Quiver V\nφ : Prefunctor U V\ninst✝² : Quiver.HasInvolutiveReverse U\ninst✝¹ : Quiver.HasInvolutiveReverse V\ninst✝ : φ.MapReverse\nh : ∀ (u : U), Function.Bijective (φ.costar u)\n⊢ φ.IsCovering","decl":"theorem Prefunctor.isCovering_of_bijective_costar (h : ∀ u, Bijective (φ.costar u)) :\n    φ.IsCovering :=\n  ⟨fun u => (φ.bijective_costar_iff_bijective_star u).1 (h u), h⟩\n\n"}
