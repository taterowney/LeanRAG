{"name":"Set.wellFoundedOn_empty","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\n⊢ EmptyCollection.emptyCollection.WellFoundedOn r","decl":"@[simp]\ntheorem wellFoundedOn_empty (r : α → α → Prop) : WellFoundedOn ∅ r :=\n  wellFounded_of_isEmpty _\n\n"}
{"name":"Set.wellFoundedOn_iff","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\n⊢ Iff (s.WellFoundedOn r) (WellFounded fun a b => And (r a b) (And (Membership.mem s a) (Membership.mem s b)))","decl":"theorem wellFoundedOn_iff :\n    s.WellFoundedOn r ↔ WellFounded fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s := by\n  have f : RelEmbedding (fun (a : s) (b : s) => r a b) fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s :=\n    ⟨⟨(↑), Subtype.coe_injective⟩, by simp⟩\n  refine ⟨fun h => ?_, f.wellFounded⟩\n  rw [WellFounded.wellFounded_iff_has_min]\n  intro t ht\n  by_cases hst : (s ∩ t).Nonempty\n  · rw [← Subtype.preimage_coe_nonempty] at hst\n    rcases h.has_min (Subtype.val ⁻¹' t) hst with ⟨⟨m, ms⟩, mt, hm⟩\n    exact ⟨m, mt, fun x xt ⟨xm, xs, _⟩ => hm ⟨x, xs⟩ xt xm⟩\n  · rcases ht with ⟨m, mt⟩\n    exact ⟨m, mt, fun x _ ⟨_, _, ms⟩ => hst ⟨m, ⟨ms, mt⟩⟩⟩\n\n"}
{"name":"Set.wellFoundedOn_univ","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\n⊢ Iff (Set.univ.WellFoundedOn r) (WellFounded r)","decl":"@[simp]\ntheorem wellFoundedOn_univ : (univ : Set α).WellFoundedOn r ↔ WellFounded r := by\n  simp [wellFoundedOn_iff]\n\n"}
{"name":"WellFounded.wellFoundedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\na✝ : WellFounded r\n⊢ s.WellFoundedOn r","decl":"theorem _root_.WellFounded.wellFoundedOn : WellFounded r → s.WellFoundedOn r :=\n  InvImage.wf _\n\n"}
{"name":"Set.wellFoundedOn_range","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → α → Prop\nf : β → α\n⊢ Iff ((Set.range f).WellFoundedOn r) (WellFounded (Function.onFun r f))","decl":"@[simp]\ntheorem wellFoundedOn_range : (range f).WellFoundedOn r ↔ WellFounded (r on f) := by\n  let f' : β → range f := fun c => ⟨f c, c, rfl⟩\n  refine ⟨fun h => (InvImage.wf f' h).mono fun c c' => id, fun h => ⟨?_⟩⟩\n  rintro ⟨_, c, rfl⟩\n  refine Acc.of_downward_closed f' ?_ _ ?_\n  · rintro _ ⟨_, c', rfl⟩ -\n    exact ⟨c', rfl⟩\n  · exact h.apply _\n\n"}
{"name":"Set.wellFoundedOn_image","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → α → Prop\nf : β → α\ns : Set β\n⊢ Iff ((Set.image f s).WellFoundedOn r) (s.WellFoundedOn (Function.onFun r f))","decl":"@[simp]\ntheorem wellFoundedOn_image {s : Set β} : (f '' s).WellFoundedOn r ↔ s.WellFoundedOn (r on f) := by\n  rw [image_eq_range]; exact wellFoundedOn_range\n\n"}
{"name":"Set.WellFoundedOn.induction","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\nx : α\nhs : s.WellFoundedOn r\nhx : Membership.mem s x\nP : α → Prop\nhP : ∀ (y : α), Membership.mem s y → (∀ (z : α), Membership.mem s z → r z y → P z) → P y\n⊢ P x","decl":"protected theorem induction (hs : s.WellFoundedOn r) (hx : x ∈ s) {P : α → Prop}\n    (hP : ∀ y ∈ s, (∀ z ∈ s, r z y → P z) → P y) : P x := by\n  let Q : s → Prop := fun y => P y\n  change Q ⟨x, hx⟩\n  refine WellFounded.induction hs ⟨x, hx⟩ ?_\n  simpa only [Subtype.forall]\n\n"}
{"name":"Set.WellFoundedOn.mono","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr r' : α → α → Prop\ns t : Set α\nh : t.WellFoundedOn r'\nhle : LE.le r r'\nhst : HasSubset.Subset s t\n⊢ s.WellFoundedOn r","decl":"protected theorem mono (h : t.WellFoundedOn r') (hle : r ≤ r') (hst : s ⊆ t) :\n    s.WellFoundedOn r := by\n  rw [wellFoundedOn_iff] at *\n  exact Subrelation.wf (fun xy => ⟨hle _ _ xy.1, hst xy.2.1, hst xy.2.2⟩) h\n\n"}
{"name":"Set.WellFoundedOn.mono'","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr r' : α → α → Prop\ns : Set α\nh : ∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem s b → r' a b → r a b\na✝ : s.WellFoundedOn r\n⊢ s.WellFoundedOn r'","decl":"theorem mono' (h : ∀ (a) (_ : a ∈ s) (b) (_ : b ∈ s), r' a b → r a b) :\n    s.WellFoundedOn r → s.WellFoundedOn r' :=\n  Subrelation.wf @fun a b => h _ a.2 _ b.2\n\n"}
{"name":"Set.WellFoundedOn.subset","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns t : Set α\nh : t.WellFoundedOn r\nhst : HasSubset.Subset s t\n⊢ s.WellFoundedOn r","decl":"theorem subset (h : t.WellFoundedOn r) (hst : s ⊆ t) : s.WellFoundedOn r :=\n  h.mono le_rfl hst\n\n"}
{"name":"Set.WellFoundedOn.acc_iff_wellFoundedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_6\nr : α → α → Prop\na : α\n⊢ (List.cons (Acc r a) (List.cons ((setOf fun b => Relation.ReflTransGen r b a).WellFoundedOn r) (List.cons ((setOf fun b => Relation.TransGen r b a).WellFoundedOn r) List.nil))).TFAE","decl":"open List in\n/-- `a` is accessible under the relation `r` iff `r` is well-founded on the downward transitive\nclosure of `a` under `r` (including `a` or not). -/\ntheorem acc_iff_wellFoundedOn {α} {r : α → α → Prop} {a : α} :\n    TFAE [Acc r a,\n      WellFoundedOn { b | ReflTransGen r b a } r,\n      WellFoundedOn { b | TransGen r b a } r] := by\n  tfae_have 1 → 2 := by\n    refine fun h => ⟨fun b => InvImage.accessible _ ?_⟩\n    rw [← acc_transGen_iff] at h ⊢\n    obtain h' | h' := reflTransGen_iff_eq_or_transGen.1 b.2\n    · rwa [h'] at h\n    · exact h.inv h'\n  tfae_have 2 → 3 := fun h => h.subset fun _ => TransGen.to_reflTransGen\n  tfae_have 3 → 1 := by\n    refine fun h => Acc.intro _ (fun b hb => (h.apply ⟨b, .single hb⟩).of_fibration Subtype.val ?_)\n    exact fun ⟨c, hc⟩ d h => ⟨⟨d, .head h hc⟩, h, rfl⟩\n  tfae_finish\n\n"}
{"name":"Set.IsStrictOrder.subset","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\n⊢ IsStrictOrder α fun a b => And (r a b) (And (Membership.mem s a) (Membership.mem s b))","decl":"instance IsStrictOrder.subset : IsStrictOrder α fun a b : α => r a b ∧ a ∈ s ∧ b ∈ s where\n  toIsIrrefl := ⟨fun a con => irrefl_of r a con.1⟩\n  toIsTrans := ⟨fun _ _ _ ab bc => ⟨trans_of r ab.1 bc.1, ab.2.1, bc.2.2⟩⟩\n\n"}
{"name":"Set.wellFoundedOn_iff_no_descending_seq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\n⊢ Iff (s.WellFoundedOn r) (∀ (f : RelEmbedding (fun x1 x2 => GT.gt x1 x2) r), Not (∀ (n : Nat), Membership.mem s (f n)))","decl":"theorem wellFoundedOn_iff_no_descending_seq :\n    s.WellFoundedOn r ↔ ∀ f : ((· > ·) : ℕ → ℕ → Prop) ↪r r, ¬∀ n, f n ∈ s := by\n  simp only [wellFoundedOn_iff, RelEmbedding.wellFounded_iff_no_descending_seq, ← not_exists, ←\n    not_nonempty_iff, not_iff_not]\n  constructor\n  · rintro ⟨⟨f, hf⟩⟩\n    have H : ∀ n, f n ∈ s := fun n => (hf.2 n.lt_succ_self).2.2\n    refine ⟨⟨f, ?_⟩, H⟩\n    simpa only [H, and_true] using @hf\n  · rintro ⟨⟨f, hf⟩, hfs : ∀ n, f n ∈ s⟩\n    refine ⟨⟨f, ?_⟩⟩\n    simpa only [hfs, and_true] using @hf\n\n"}
{"name":"Set.WellFoundedOn.union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns t : Set α\nhs : s.WellFoundedOn r\nht : t.WellFoundedOn r\n⊢ (Union.union s t).WellFoundedOn r","decl":"theorem WellFoundedOn.union (hs : s.WellFoundedOn r) (ht : t.WellFoundedOn r) :\n    (s ∪ t).WellFoundedOn r := by\n  rw [wellFoundedOn_iff_no_descending_seq] at *\n  rintro f hf\n  rcases Nat.exists_subseq_of_forall_mem_union f hf with ⟨g, hg | hg⟩\n  exacts [hs (g.dual.ltEmbedding.trans f) hg, ht (g.dual.ltEmbedding.trans f) hg]\n\n"}
{"name":"Set.wellFoundedOn_union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns t : Set α\n⊢ Iff ((Union.union s t).WellFoundedOn r) (And (s.WellFoundedOn r) (t.WellFoundedOn r))","decl":"@[simp]\ntheorem wellFoundedOn_union : (s ∪ t).WellFoundedOn r ↔ s.WellFoundedOn r ∧ t.WellFoundedOn r :=\n  ⟨fun h => ⟨h.subset subset_union_left, h.subset subset_union_right⟩, fun h =>\n    h.1.union h.2⟩\n\n"}
{"name":"Set.isWF_empty","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LT α\n⊢ EmptyCollection.emptyCollection.IsWF","decl":"@[simp]\ntheorem isWF_empty : IsWF (∅ : Set α) :=\n  wellFounded_of_isEmpty _\n\n"}
{"name":"Set.isWF_univ_iff","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LT α\n⊢ Iff Set.univ.IsWF (WellFounded fun x1 x2 => LT.lt x1 x2)","decl":"theorem isWF_univ_iff : IsWF (univ : Set α) ↔ WellFounded ((· < ·) : α → α → Prop) := by\n  simp [IsWF, wellFoundedOn_iff]\n\n"}
{"name":"Set.IsWF.mono","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LT α\ns t : Set α\nh : t.IsWF\nst : HasSubset.Subset s t\n⊢ s.IsWF","decl":"theorem IsWF.mono (h : IsWF t) (st : s ⊆ t) : IsWF s := h.subset st\n\n"}
{"name":"Set.IsWF.of_wellFoundedLT","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝¹ : LT α\ns : Set α\ninst✝ : WellFoundedLT α\n⊢ s.IsWF","decl":"lemma IsWF.of_wellFoundedLT [WellFoundedLT α] : IsWF s :=\n  (isWF_univ_iff.2 wellFounded_lt).mono (subset_univ _)\n\n"}
{"name":"Set.IsWF.union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns t : Set α\nhs : s.IsWF\nht : t.IsWF\n⊢ (Union.union s t).IsWF","decl":"protected nonrec theorem IsWF.union (hs : IsWF s) (ht : IsWF t) : IsWF (s ∪ t) := hs.union ht\n\n"}
{"name":"Set.isWF_union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns t : Set α\n⊢ Iff (Union.union s t).IsWF (And s.IsWF t.IsWF)","decl":"@[simp] theorem isWF_union : IsWF (s ∪ t) ↔ IsWF s ∧ IsWF t := wellFoundedOn_union\n\n"}
{"name":"Set.isWF_iff_no_descending_seq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\n⊢ Iff s.IsWF (∀ (f : Nat → α), StrictAnti f → Not (∀ (n : Nat), Membership.mem s (f (OrderDual.toDual n))))","decl":"theorem isWF_iff_no_descending_seq :\n    IsWF s ↔ ∀ f : ℕ → α, StrictAnti f → ¬∀ n, f (OrderDual.toDual n) ∈ s :=\n  wellFoundedOn_iff_no_descending_seq.trans\n    ⟨fun H f hf => H ⟨⟨f, hf.injective⟩, hf.lt_iff_lt⟩, fun H f => H f fun _ _ => f.map_rel_iff.2⟩\n\n"}
{"name":"Set.PartiallyWellOrderedOn.mono","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns t : Set α\nht : t.PartiallyWellOrderedOn r\nh : HasSubset.Subset s t\n⊢ s.PartiallyWellOrderedOn r","decl":"theorem PartiallyWellOrderedOn.mono (ht : t.PartiallyWellOrderedOn r) (h : s ⊆ t) :\n    s.PartiallyWellOrderedOn r := fun f hf => ht f fun n => h <| hf n\n\n"}
{"name":"Set.partiallyWellOrderedOn_empty","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\n⊢ EmptyCollection.emptyCollection.PartiallyWellOrderedOn r","decl":"@[simp]\ntheorem partiallyWellOrderedOn_empty (r : α → α → Prop) : PartiallyWellOrderedOn ∅ r := fun _ h =>\n  (h 0).elim\n\n"}
{"name":"Set.PartiallyWellOrderedOn.union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns t : Set α\nhs : s.PartiallyWellOrderedOn r\nht : t.PartiallyWellOrderedOn r\n⊢ (Union.union s t).PartiallyWellOrderedOn r","decl":"theorem PartiallyWellOrderedOn.union (hs : s.PartiallyWellOrderedOn r)\n    (ht : t.PartiallyWellOrderedOn r) : (s ∪ t).PartiallyWellOrderedOn r := by\n  rintro f hf\n  rcases Nat.exists_subseq_of_forall_mem_union f hf with ⟨g, hgs | hgt⟩\n  · rcases hs _ hgs with ⟨m, n, hlt, hr⟩\n    exact ⟨g m, g n, g.strictMono hlt, hr⟩\n  · rcases ht _ hgt with ⟨m, n, hlt, hr⟩\n    exact ⟨g m, g n, g.strictMono hlt, hr⟩\n\n"}
{"name":"Set.partiallyWellOrderedOn_union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns t : Set α\n⊢ Iff ((Union.union s t).PartiallyWellOrderedOn r) (And (s.PartiallyWellOrderedOn r) (t.PartiallyWellOrderedOn r))","decl":"@[simp]\ntheorem partiallyWellOrderedOn_union :\n    (s ∪ t).PartiallyWellOrderedOn r ↔ s.PartiallyWellOrderedOn r ∧ t.PartiallyWellOrderedOn r :=\n  ⟨fun h => ⟨h.mono subset_union_left, h.mono subset_union_right⟩, fun h =>\n    h.1.union h.2⟩\n\n"}
{"name":"Set.PartiallyWellOrderedOn.image_of_monotone_on","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → α → Prop\nr' : β → β → Prop\nf : α → β\ns : Set α\nhs : s.PartiallyWellOrderedOn r\nhf : ∀ (a₁ : α), Membership.mem s a₁ → ∀ (a₂ : α), Membership.mem s a₂ → r a₁ a₂ → r' (f a₁) (f a₂)\n⊢ (Set.image f s).PartiallyWellOrderedOn r'","decl":"theorem PartiallyWellOrderedOn.image_of_monotone_on (hs : s.PartiallyWellOrderedOn r)\n    (hf : ∀ a₁ ∈ s, ∀ a₂ ∈ s, r a₁ a₂ → r' (f a₁) (f a₂)) : (f '' s).PartiallyWellOrderedOn r' := by\n  intro g' hg'\n  choose g hgs heq using hg'\n  obtain rfl : f ∘ g = g' := funext heq\n  obtain ⟨m, n, hlt, hmn⟩ := hs g hgs\n  exact ⟨m, n, hlt, hf _ (hgs m) _ (hgs n) hmn⟩\n\n"}
{"name":"IsAntichain.finite_of_partiallyWellOrderedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\nha : IsAntichain r s\nhp : s.PartiallyWellOrderedOn r\n⊢ s.Finite","decl":"theorem _root_.IsAntichain.finite_of_partiallyWellOrderedOn (ha : IsAntichain r s)\n    (hp : s.PartiallyWellOrderedOn r) : s.Finite := by\n  refine not_infinite.1 fun hi => ?_\n  obtain ⟨m, n, hmn, h⟩ := hp (fun n => hi.natEmbedding _ n) fun n => (hi.natEmbedding _ n).2\n  exact hmn.ne ((hi.natEmbedding _).injective <| Subtype.val_injective <|\n    ha.eq (hi.natEmbedding _ m).2 (hi.natEmbedding _ n).2 h)\n\n"}
{"name":"Set.Finite.partiallyWellOrderedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\nhs : s.Finite\n⊢ s.PartiallyWellOrderedOn r","decl":"protected theorem Finite.partiallyWellOrderedOn (hs : s.Finite) : s.PartiallyWellOrderedOn r := by\n  intro f hf\n  obtain ⟨m, n, hmn, h⟩ := hs.exists_lt_map_eq_of_forall_mem hf\n  exact ⟨m, n, hmn, h.subst <| refl (f m)⟩\n\n"}
{"name":"IsAntichain.partiallyWellOrderedOn_iff","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\nhs : IsAntichain r s\n⊢ Iff (s.PartiallyWellOrderedOn r) s.Finite","decl":"theorem _root_.IsAntichain.partiallyWellOrderedOn_iff (hs : IsAntichain r s) :\n    s.PartiallyWellOrderedOn r ↔ s.Finite :=\n  ⟨hs.finite_of_partiallyWellOrderedOn, Finite.partiallyWellOrderedOn⟩\n\n"}
{"name":"Set.partiallyWellOrderedOn_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsRefl α r\na : α\n⊢ (Singleton.singleton a).PartiallyWellOrderedOn r","decl":"@[simp]\ntheorem partiallyWellOrderedOn_singleton (a : α) : PartiallyWellOrderedOn {a} r :=\n  (finite_singleton a).partiallyWellOrderedOn\n\n"}
{"name":"Set.Subsingleton.partiallyWellOrderedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\nhs : s.Subsingleton\n⊢ s.PartiallyWellOrderedOn r","decl":"@[nontriviality]\ntheorem Subsingleton.partiallyWellOrderedOn (hs : s.Subsingleton) : PartiallyWellOrderedOn s r :=\n  hs.finite.partiallyWellOrderedOn\n\n"}
{"name":"Set.partiallyWellOrderedOn_insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\na : α\ninst✝ : IsRefl α r\n⊢ Iff ((Insert.insert a s).PartiallyWellOrderedOn r) (s.PartiallyWellOrderedOn r)","decl":"@[simp]\ntheorem partiallyWellOrderedOn_insert :\n    PartiallyWellOrderedOn (insert a s) r ↔ PartiallyWellOrderedOn s r := by\n  simp only [← singleton_union, partiallyWellOrderedOn_union,\n    partiallyWellOrderedOn_singleton, true_and]\n\n"}
{"name":"Set.PartiallyWellOrderedOn.insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\nh : s.PartiallyWellOrderedOn r\na : α\n⊢ (Insert.insert a s).PartiallyWellOrderedOn r","decl":"protected theorem PartiallyWellOrderedOn.insert (h : PartiallyWellOrderedOn s r) (a : α) :\n    PartiallyWellOrderedOn (insert a s) r :=\n  partiallyWellOrderedOn_insert.2 h\n\n"}
{"name":"Set.partiallyWellOrderedOn_iff_finite_antichains","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝¹ : IsRefl α r\ninst✝ : IsSymm α r\n⊢ Iff (s.PartiallyWellOrderedOn r) (∀ (t : Set α), HasSubset.Subset t s → IsAntichain r t → t.Finite)","decl":"theorem partiallyWellOrderedOn_iff_finite_antichains [IsSymm α r] :\n    s.PartiallyWellOrderedOn r ↔ ∀ t, t ⊆ s → IsAntichain r t → t.Finite := by\n  refine ⟨fun h t ht hrt => hrt.finite_of_partiallyWellOrderedOn (h.mono ht), ?_⟩\n  rintro hs f hf\n  by_contra! H\n  refine infinite_range_of_injective (fun m n hmn => ?_) (hs _ (range_subset_iff.2 hf) ?_)\n  · obtain h | h | h := lt_trichotomy m n\n    · refine (H _ _ h ?_).elim\n      rw [hmn]\n      exact refl _\n    · exact h\n    · refine (H _ _ h ?_).elim\n      rw [hmn]\n      exact refl _\n  rintro _ ⟨m, hm, rfl⟩ _ ⟨n, hn, rfl⟩ hmn\n  obtain h | h := (ne_of_apply_ne _ hmn).lt_or_lt\n  · exact H _ _ h\n  · exact mt symm (H _ _ h)\n\n"}
{"name":"Set.PartiallyWellOrderedOn.exists_monotone_subseq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝¹ : IsRefl α r\ninst✝ : IsTrans α r\nh : s.PartiallyWellOrderedOn r\nf : Nat → α\nhf : ∀ (n : Nat), Membership.mem s (f n)\n⊢ Exists fun g => ∀ (m n : Nat), LE.le m n → r (f (g m)) (f (g n))","decl":"theorem PartiallyWellOrderedOn.exists_monotone_subseq (h : s.PartiallyWellOrderedOn r) (f : ℕ → α)\n    (hf : ∀ n, f n ∈ s) : ∃ g : ℕ ↪o ℕ, ∀ m n : ℕ, m ≤ n → r (f (g m)) (f (g n)) := by\n  obtain ⟨g, h1 | h2⟩ := exists_increasing_or_nonincreasing_subseq r f\n  · refine ⟨g, fun m n hle => ?_⟩\n    obtain hlt | rfl := hle.lt_or_eq\n    exacts [h1 m n hlt, refl_of r _]\n  · exfalso\n    obtain ⟨m, n, hlt, hle⟩ := h (f ∘ g) fun n => hf _\n    exact h2 m n hlt hle\n\n"}
{"name":"Set.partiallyWellOrderedOn_iff_exists_monotone_subseq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝¹ : IsRefl α r\ninst✝ : IsTrans α r\n⊢ Iff (s.PartiallyWellOrderedOn r) (∀ (f : Nat → α), (∀ (n : Nat), Membership.mem s (f n)) → Exists fun g => ∀ (m n : Nat), LE.le m n → r (f (g m)) (f (g n)))","decl":"theorem partiallyWellOrderedOn_iff_exists_monotone_subseq :\n    s.PartiallyWellOrderedOn r ↔\n      ∀ f : ℕ → α, (∀ n, f n ∈ s) → ∃ g : ℕ ↪o ℕ, ∀ m n : ℕ, m ≤ n → r (f (g m)) (f (g n)) := by\n  constructor <;> intro h f hf\n  · exact h.exists_monotone_subseq f hf\n  · obtain ⟨g, gmon⟩ := h f hf\n    exact ⟨g 0, g 1, g.lt_iff_lt.2 Nat.zero_lt_one, gmon _ _ (Nat.zero_le 1)⟩\n\n"}
{"name":"Set.PartiallyWellOrderedOn.prod","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\nr : α → α → Prop\nr' : β → β → Prop\ns : Set α\ninst✝¹ : IsRefl α r\ninst✝ : IsTrans α r\nt : Set β\nhs : s.PartiallyWellOrderedOn r\nht : t.PartiallyWellOrderedOn r'\n⊢ (SProd.sprod s t).PartiallyWellOrderedOn fun x y => And (r x.1 y.1) (r' x.2 y.2)","decl":"protected theorem PartiallyWellOrderedOn.prod {t : Set β} (hs : PartiallyWellOrderedOn s r)\n    (ht : PartiallyWellOrderedOn t r') :\n    PartiallyWellOrderedOn (s ×ˢ t) fun x y : α × β => r x.1 y.1 ∧ r' x.2 y.2 := by\n  intro f hf\n  obtain ⟨g₁, h₁⟩ := hs.exists_monotone_subseq (Prod.fst ∘ f) fun n => (hf n).1\n  obtain ⟨m, n, hlt, hle⟩ := ht (Prod.snd ∘ f ∘ g₁) fun n => (hf _).2\n  exact ⟨g₁ m, g₁ n, g₁.strictMono hlt, h₁ _ _ hlt.le, hle⟩\n\n"}
{"name":"Set.PartiallyWellOrderedOn.wellFoundedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\ninst✝ : IsPreorder α r\nh : s.PartiallyWellOrderedOn r\n⊢ s.WellFoundedOn fun a b => And (r a b) (Not (r b a))","decl":"theorem PartiallyWellOrderedOn.wellFoundedOn [IsPreorder α r] (h : s.PartiallyWellOrderedOn r) :\n    s.WellFoundedOn fun a b => r a b ∧ ¬r b a := by\n  letI : Preorder α :=\n    { le := r\n      le_refl := refl_of r\n      le_trans := fun _ _ _ => trans_of r }\n  change s.WellFoundedOn (· < ·)\n  replace h : s.PartiallyWellOrderedOn (· ≤ ·) := h -- Porting note: was `change _ at h`\n  rw [wellFoundedOn_iff_no_descending_seq]\n  intro f hf\n  obtain ⟨m, n, hlt, hle⟩ := h f hf\n  exact (f.map_rel_iff.2 hlt).not_le hle\n\n"}
{"name":"Set.IsPWO.mono","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns t : Set α\nht : t.IsPWO\na✝ : HasSubset.Subset s t\n⊢ s.IsPWO","decl":"nonrec theorem IsPWO.mono (ht : t.IsPWO) : s ⊆ t → s.IsPWO := ht.mono\n\n"}
{"name":"Set.IsPWO.exists_monotone_subseq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nh : s.IsPWO\nf : Nat → α\nhf : ∀ (n : Nat), Membership.mem s (f n)\n⊢ Exists fun g => Monotone (Function.comp f ⇑g)","decl":"nonrec theorem IsPWO.exists_monotone_subseq (h : s.IsPWO) (f : ℕ → α) (hf : ∀ n, f n ∈ s) :\n    ∃ g : ℕ ↪o ℕ, Monotone (f ∘ g) :=\n  h.exists_monotone_subseq f hf\n\n"}
{"name":"Set.isPWO_iff_exists_monotone_subseq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\n⊢ Iff s.IsPWO (∀ (f : Nat → α), (∀ (n : Nat), Membership.mem s (f n)) → Exists fun g => Monotone (Function.comp f ⇑g))","decl":"theorem isPWO_iff_exists_monotone_subseq :\n    s.IsPWO ↔ ∀ f : ℕ → α, (∀ n, f n ∈ s) → ∃ g : ℕ ↪o ℕ, Monotone (f ∘ g) :=\n  partiallyWellOrderedOn_iff_exists_monotone_subseq\n\n"}
{"name":"Set.IsPWO.isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nh : s.IsPWO\n⊢ s.IsWF","decl":"protected theorem IsPWO.isWF (h : s.IsPWO) : s.IsWF := by\n  simpa only [← lt_iff_le_not_le] using h.wellFoundedOn\n\n"}
{"name":"Set.IsPWO.prod","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nt : Set β\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (SProd.sprod s t).IsPWO","decl":"nonrec theorem IsPWO.prod {t : Set β} (hs : s.IsPWO) (ht : t.IsPWO) : IsPWO (s ×ˢ t) :=\n  hs.prod ht\n\n"}
{"name":"Set.IsPWO.image_of_monotoneOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nhs : s.IsPWO\nf : α → β\nhf : MonotoneOn f s\n⊢ (Set.image f s).IsPWO","decl":"theorem IsPWO.image_of_monotoneOn (hs : s.IsPWO) {f : α → β} (hf : MonotoneOn f s) :\n    IsPWO (f '' s) :=\n  hs.image_of_monotone_on hf\n\n"}
{"name":"Set.IsPWO.image_of_monotone","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nhs : s.IsPWO\nf : α → β\nhf : Monotone f\n⊢ (Set.image f s).IsPWO","decl":"theorem IsPWO.image_of_monotone (hs : s.IsPWO) {f : α → β} (hf : Monotone f) : IsPWO (f '' s) :=\n  hs.image_of_monotone_on (hf.monotoneOn _)\n\n"}
{"name":"Set.IsPWO.union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns t : Set α\nhs : s.IsPWO\nht : t.IsPWO\n⊢ (Union.union s t).IsPWO","decl":"protected nonrec theorem IsPWO.union (hs : IsPWO s) (ht : IsPWO t) : IsPWO (s ∪ t) :=\n  hs.union ht\n\n"}
{"name":"Set.isPWO_union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns t : Set α\n⊢ Iff (Union.union s t).IsPWO (And s.IsPWO t.IsPWO)","decl":"@[simp]\ntheorem isPWO_union : IsPWO (s ∪ t) ↔ IsPWO s ∧ IsPWO t :=\n  partiallyWellOrderedOn_union\n\n"}
{"name":"Set.Finite.isPWO","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nhs : s.Finite\n⊢ s.IsPWO","decl":"protected theorem Finite.isPWO (hs : s.Finite) : IsPWO s := hs.partiallyWellOrderedOn\n\n"}
{"name":"Set.isPWO_of_finite","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝¹ : Preorder α\ns : Set α\ninst✝ : Finite α\n⊢ s.IsPWO","decl":"@[simp] theorem isPWO_of_finite [Finite α] : s.IsPWO := s.toFinite.isPWO\n\n"}
{"name":"Set.isPWO_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na : α\n⊢ (Singleton.singleton a).IsPWO","decl":"@[simp] theorem isPWO_singleton (a : α) : IsPWO ({a} : Set α) := (finite_singleton a).isPWO\n\n"}
{"name":"Set.isPWO_empty","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\n⊢ EmptyCollection.emptyCollection.IsPWO","decl":"@[simp] theorem isPWO_empty : IsPWO (∅ : Set α) := finite_empty.isPWO\n\n"}
{"name":"Set.Subsingleton.isPWO","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nhs : s.Subsingleton\n⊢ s.IsPWO","decl":"protected theorem Subsingleton.isPWO (hs : s.Subsingleton) : IsPWO s := hs.finite.isPWO\n\n"}
{"name":"Set.isPWO_insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (Insert.insert a s).IsPWO s.IsPWO","decl":"@[simp]\ntheorem isPWO_insert {a} : IsPWO (insert a s) ↔ IsPWO s := by\n  simp only [← singleton_union, isPWO_union, isPWO_singleton, true_and]\n\n"}
{"name":"Set.IsPWO.insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nh : s.IsPWO\na : α\n⊢ (Insert.insert a s).IsPWO","decl":"protected theorem IsPWO.insert (h : IsPWO s) (a : α) : IsPWO (insert a s) :=\n  isPWO_insert.2 h\n\n"}
{"name":"Set.Finite.isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nhs : s.Finite\n⊢ s.IsWF","decl":"protected theorem Finite.isWF (hs : s.Finite) : IsWF s := hs.isPWO.isWF\n\n"}
{"name":"Set.isWF_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na : α\n⊢ (Singleton.singleton a).IsWF","decl":"@[simp] theorem isWF_singleton {a : α} : IsWF ({a} : Set α) := (finite_singleton a).isWF\n\n"}
{"name":"Set.Subsingleton.isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nhs : s.Subsingleton\n⊢ s.IsWF","decl":"protected theorem Subsingleton.isWF (hs : s.Subsingleton) : IsWF s := hs.isPWO.isWF\n\n"}
{"name":"Set.isWF_insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\na : α\n⊢ Iff (Insert.insert a s).IsWF s.IsWF","decl":"@[simp]\ntheorem isWF_insert {a} : IsWF (insert a s) ↔ IsWF s := by\n  simp only [← singleton_union, isWF_union, isWF_singleton, true_and]\n\n"}
{"name":"Set.IsWF.insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nh : s.IsWF\na : α\n⊢ (Insert.insert a s).IsWF","decl":"protected theorem IsWF.insert (h : IsWF s) (a : α) : IsWF (insert a s) :=\n  isWF_insert.2 h\n\n"}
{"name":"Set.Finite.wellFoundedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\nhs : s.Finite\n⊢ s.WellFoundedOn r","decl":"protected theorem Finite.wellFoundedOn (hs : s.Finite) : s.WellFoundedOn r :=\n  letI := partialOrderOfSO r\n  hs.isWF\n\n"}
{"name":"Set.wellFoundedOn_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\na : α\n⊢ (Singleton.singleton a).WellFoundedOn r","decl":"@[simp]\ntheorem wellFoundedOn_singleton : WellFoundedOn ({a} : Set α) r :=\n  (finite_singleton a).wellFoundedOn\n\n"}
{"name":"Set.Subsingleton.wellFoundedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\nhs : s.Subsingleton\n⊢ s.WellFoundedOn r","decl":"protected theorem Subsingleton.wellFoundedOn (hs : s.Subsingleton) : s.WellFoundedOn r :=\n  hs.finite.wellFoundedOn\n\n"}
{"name":"Set.wellFoundedOn_insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\na : α\n⊢ Iff ((Insert.insert a s).WellFoundedOn r) (s.WellFoundedOn r)","decl":"@[simp]\ntheorem wellFoundedOn_insert : WellFoundedOn (insert a s) r ↔ WellFoundedOn s r := by\n  simp only [← singleton_union, wellFoundedOn_union, wellFoundedOn_singleton, true_and]\n\n"}
{"name":"Set.wellFoundedOn_sdiff_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\na : α\n⊢ Iff ((SDiff.sdiff s (Singleton.singleton a)).WellFoundedOn r) (s.WellFoundedOn r)","decl":"@[simp]\ntheorem wellFoundedOn_sdiff_singleton : WellFoundedOn (s \\ {a}) r ↔ WellFoundedOn s r := by\n  simp only [← wellFoundedOn_insert (a := a), insert_diff_singleton, mem_insert_iff, true_or,\n    insert_eq_of_mem]\n\n"}
{"name":"Set.WellFoundedOn.insert","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\nh : s.WellFoundedOn r\na : α\n⊢ (Insert.insert a s).WellFoundedOn r","decl":"protected theorem WellFoundedOn.insert (h : WellFoundedOn s r) (a : α) :\n    WellFoundedOn (insert a s) r :=\n  wellFoundedOn_insert.2 h\n\n"}
{"name":"Set.WellFoundedOn.sdiff_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Set α\nh : s.WellFoundedOn r\na : α\n⊢ (SDiff.sdiff s (Singleton.singleton a)).WellFoundedOn r","decl":"protected theorem WellFoundedOn.sdiff_singleton (h : WellFoundedOn s r) (a : α) :\n    WellFoundedOn (s \\ {a}) r :=\n  wellFoundedOn_sdiff_singleton.2 h\n\n"}
{"name":"Set.WellFoundedOn.mapsTo","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_6\nβ : Type u_7\nr : α → α → Prop\nf : β → α\ns : Set α\nt : Set β\nh : Set.MapsTo f t s\nhw : s.WellFoundedOn r\n⊢ t.WellFoundedOn (Function.onFun r f)","decl":"lemma WellFoundedOn.mapsTo {α β : Type*} {r : α → α → Prop} (f : β → α)\n    {s : Set α} {t : Set β} (h : MapsTo f t s) (hw : s.WellFoundedOn r) :\n    t.WellFoundedOn (r on f) := by\n  exact InvImage.wf (fun x : t ↦ ⟨f x, h x.prop⟩) hw\n\n"}
{"name":"Set.IsWF.isPWO","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Set α\nhs : s.IsWF\n⊢ s.IsPWO","decl":"protected theorem IsWF.isPWO (hs : s.IsWF) : s.IsPWO := by\n  intro f hf\n  lift f to ℕ → s using hf\n  rcases hs.has_min (range f) (range_nonempty _) with ⟨_, ⟨m, rfl⟩, hm⟩\n  simp only [forall_mem_range, not_lt] at hm\n  exact ⟨m, m + 1, by omega, hm _⟩\n\n"}
{"name":"Set.isPWO_iff_isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Set α\n⊢ Iff s.IsPWO s.IsWF","decl":"/-- In a linear order, the predicates `Set.IsPWO` and `Set.IsWF` are equivalent. -/\ntheorem isPWO_iff_isWF : s.IsPWO ↔ s.IsWF :=\n  ⟨IsPWO.isWF, IsWF.isPWO⟩\n\n"}
{"name":"Set.isWF_iff_isPWO","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Set α\n⊢ Iff s.IsWF s.IsPWO","decl":"@[deprecated isPWO_iff_isWF (since := \"2025-01-21\")]\ntheorem isWF_iff_isPWO : s.IsWF ↔ s.IsPWO :=\n  isPWO_iff_isWF.symm\n\n"}
{"name":"Set.IsPWO.of_linearOrder","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝¹ : LinearOrder α\ns : Set α\ninst✝ : WellFoundedLT α\n⊢ s.IsPWO","decl":"/--\nIf `α` is a linear order with well-founded `<`, then any set in it is a partially well-ordered set.\nNote this does not hold without the linearity assumption.\n-/\nlemma IsPWO.of_linearOrder [WellFoundedLT α] : s.IsPWO := IsWF.of_wellFoundedLT.isPWO\n\n"}
{"name":"Finset.partiallyWellOrderedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsRefl α r\ns : Finset α\n⊢ (↑s).PartiallyWellOrderedOn r","decl":"@[simp]\nprotected theorem partiallyWellOrderedOn [IsRefl α r] (s : Finset α) :\n    (s : Set α).PartiallyWellOrderedOn r :=\n  s.finite_toSet.partiallyWellOrderedOn\n\n"}
{"name":"Finset.isPWO","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Finset α\n⊢ (↑s).IsPWO","decl":"@[simp]\nprotected theorem isPWO [Preorder α] (s : Finset α) : Set.IsPWO (↑s : Set α) :=\n  s.partiallyWellOrderedOn\n\n"}
{"name":"Finset.isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Finset α\n⊢ (↑s).IsWF","decl":"@[simp]\nprotected theorem isWF [Preorder α] (s : Finset α) : Set.IsWF (↑s : Set α) :=\n  s.finite_toSet.isWF\n\n"}
{"name":"Finset.wellFoundedOn","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Finset α\n⊢ (↑s).WellFoundedOn r","decl":"@[simp]\nprotected theorem wellFoundedOn [IsStrictOrder α r] (s : Finset α) :\n    Set.WellFoundedOn (↑s : Set α) r :=\n  letI := partialOrderOfSO r\n  s.isWF\n\n"}
{"name":"Finset.wellFoundedOn_sup","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Finset ι\nf : ι → Set α\n⊢ Iff ((s.sup f).WellFoundedOn r) (∀ (i : ι), Membership.mem s i → (f i).WellFoundedOn r)","decl":"theorem wellFoundedOn_sup [IsStrictOrder α r] (s : Finset ι) {f : ι → Set α} :\n    (s.sup f).WellFoundedOn r ↔ ∀ i ∈ s, (f i).WellFoundedOn r :=\n  Finset.cons_induction_on s (by simp) fun a s ha hs => by simp [-sup_set_eq_biUnion, hs]\n\n"}
{"name":"Finset.partiallyWellOrderedOn_sup","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\nr : α → α → Prop\ns : Finset ι\nf : ι → Set α\n⊢ Iff ((s.sup f).PartiallyWellOrderedOn r) (∀ (i : ι), Membership.mem s i → (f i).PartiallyWellOrderedOn r)","decl":"theorem partiallyWellOrderedOn_sup (s : Finset ι) {f : ι → Set α} :\n    (s.sup f).PartiallyWellOrderedOn r ↔ ∀ i ∈ s, (f i).PartiallyWellOrderedOn r :=\n  Finset.cons_induction_on s (by simp) fun a s ha hs => by simp [-sup_set_eq_biUnion, hs]\n\n"}
{"name":"Finset.isWF_sup","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Preorder α\ns : Finset ι\nf : ι → Set α\n⊢ Iff (s.sup f).IsWF (∀ (i : ι), Membership.mem s i → (f i).IsWF)","decl":"theorem isWF_sup [Preorder α] (s : Finset ι) {f : ι → Set α} :\n    (s.sup f).IsWF ↔ ∀ i ∈ s, (f i).IsWF :=\n  s.wellFoundedOn_sup\n\n"}
{"name":"Finset.isPWO_sup","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Preorder α\ns : Finset ι\nf : ι → Set α\n⊢ Iff (s.sup f).IsPWO (∀ (i : ι), Membership.mem s i → (f i).IsPWO)","decl":"theorem isPWO_sup [Preorder α] (s : Finset ι) {f : ι → Set α} :\n    (s.sup f).IsPWO ↔ ∀ i ∈ s, (f i).IsPWO :=\n  s.partiallyWellOrderedOn_sup\n\n"}
{"name":"Finset.wellFoundedOn_bUnion","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\nr : α → α → Prop\ninst✝ : IsStrictOrder α r\ns : Finset ι\nf : ι → Set α\n⊢ Iff ((Set.iUnion fun i => Set.iUnion fun h => f i).WellFoundedOn r) (∀ (i : ι), Membership.mem s i → (f i).WellFoundedOn r)","decl":"@[simp]\ntheorem wellFoundedOn_bUnion [IsStrictOrder α r] (s : Finset ι) {f : ι → Set α} :\n    (⋃ i ∈ s, f i).WellFoundedOn r ↔ ∀ i ∈ s, (f i).WellFoundedOn r := by\n  simpa only [Finset.sup_eq_iSup] using s.wellFoundedOn_sup\n\n"}
{"name":"Finset.partiallyWellOrderedOn_bUnion","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\nr : α → α → Prop\ns : Finset ι\nf : ι → Set α\n⊢ Iff ((Set.iUnion fun i => Set.iUnion fun h => f i).PartiallyWellOrderedOn r) (∀ (i : ι), Membership.mem s i → (f i).PartiallyWellOrderedOn r)","decl":"@[simp]\ntheorem partiallyWellOrderedOn_bUnion (s : Finset ι) {f : ι → Set α} :\n    (⋃ i ∈ s, f i).PartiallyWellOrderedOn r ↔ ∀ i ∈ s, (f i).PartiallyWellOrderedOn r := by\n  simpa only [Finset.sup_eq_iSup] using s.partiallyWellOrderedOn_sup\n\n"}
{"name":"Finset.isWF_bUnion","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Preorder α\ns : Finset ι\nf : ι → Set α\n⊢ Iff (Set.iUnion fun i => Set.iUnion fun h => f i).IsWF (∀ (i : ι), Membership.mem s i → (f i).IsWF)","decl":"@[simp]\ntheorem isWF_bUnion [Preorder α] (s : Finset ι) {f : ι → Set α} :\n    (⋃ i ∈ s, f i).IsWF ↔ ∀ i ∈ s, (f i).IsWF :=\n  s.wellFoundedOn_bUnion\n\n"}
{"name":"Finset.isPWO_bUnion","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝ : Preorder α\ns : Finset ι\nf : ι → Set α\n⊢ Iff (Set.iUnion fun i => Set.iUnion fun h => f i).IsPWO (∀ (i : ι), Membership.mem s i → (f i).IsPWO)","decl":"@[simp]\ntheorem isPWO_bUnion [Preorder α] (s : Finset ι) {f : ι → Set α} :\n    (⋃ i ∈ s, f i).IsPWO ↔ ∀ i ∈ s, (f i).IsPWO :=\n  s.partiallyWellOrderedOn_bUnion\n\n"}
{"name":"Set.IsWF.min_mem","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\nhs : s.IsWF\nhn : s.Nonempty\n⊢ Membership.mem s (hs.min hn)","decl":"theorem IsWF.min_mem (hs : IsWF s) (hn : s.Nonempty) : hs.min hn ∈ s :=\n  (WellFounded.min hs univ (nonempty_iff_univ_nonempty.1 hn.to_subtype)).2\n\n"}
{"name":"Set.IsWF.not_lt_min","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\na : α\nhs : s.IsWF\nhn : s.Nonempty\nha : Membership.mem s a\n⊢ Not (LT.lt a (hs.min hn))","decl":"nonrec theorem IsWF.not_lt_min (hs : IsWF s) (hn : s.Nonempty) (ha : a ∈ s) : ¬a < hs.min hn :=\n  hs.not_lt_min univ (nonempty_iff_univ_nonempty.1 hn.to_subtype) (mem_univ (⟨a, ha⟩ : s))\n\n"}
{"name":"Set.IsWF.min_of_subset_not_lt_min","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns t : Set α\nhs : s.IsWF\nhsn : s.Nonempty\nht : t.IsWF\nhtn : t.Nonempty\nhst : HasSubset.Subset s t\n⊢ Not (LT.lt (hs.min hsn) (ht.min htn))","decl":"theorem IsWF.min_of_subset_not_lt_min {hs : s.IsWF} {hsn : s.Nonempty} {ht : t.IsWF}\n    {htn : t.Nonempty} (hst : s ⊆ t) : ¬hs.min hsn < ht.min htn :=\n  ht.not_lt_min htn (hst (min_mem hs hsn))\n\n"}
{"name":"Set.isWF_min_singleton","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\na : α\nhs : (Singleton.singleton a).IsWF\nhn : (Singleton.singleton a).Nonempty\n⊢ Eq (hs.min hn) a","decl":"@[simp]\ntheorem isWF_min_singleton (a) {hs : IsWF ({a} : Set α)} {hn : ({a} : Set α).Nonempty} :\n    hs.min hn = a :=\n  eq_of_mem_singleton (IsWF.min_mem hs hn)\n\n"}
{"name":"Set.IsWF.min_eq_of_lt","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : Preorder α\ns : Set α\na : α\nhs : s.IsWF\nha : Membership.mem s a\nhlt : ∀ (b : α), Membership.mem s b → Ne b a → LT.lt a b\n⊢ Eq (hs.min ⋯) a","decl":"theorem IsWF.min_eq_of_lt (hs : s.IsWF) (ha : a ∈ s) (hlt : ∀ b ∈ s, b ≠ a → a < b) :\n    hs.min (nonempty_of_mem ha) = a := by\n  by_contra h\n  exact (hs.not_lt_min (nonempty_of_mem ha) ha) (hlt (hs.min (nonempty_of_mem ha))\n    (hs.min_mem (nonempty_of_mem ha)) h)\n\n"}
{"name":"Set.IsWF.min_eq_of_le","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : PartialOrder α\ns : Set α\na : α\nhs : s.IsWF\nha : Membership.mem s a\nhle : ∀ (b : α), Membership.mem s b → LE.le a b\n⊢ Eq (hs.min ⋯) a","decl":"theorem IsWF.min_eq_of_le (hs : s.IsWF) (ha : a ∈ s) (hle : ∀ b ∈ s, a ≤ b) :\n    hs.min (nonempty_of_mem ha) = a :=\n  (eq_of_le_of_not_lt (hle (hs.min (nonempty_of_mem ha))\n    (hs.min_mem (nonempty_of_mem ha))) (hs.not_lt_min (nonempty_of_mem ha) ha)).symm\n\n"}
{"name":"Set.IsWF.min_le","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Set α\na : α\nhs : s.IsWF\nhn : s.Nonempty\nha : Membership.mem s a\n⊢ LE.le (hs.min hn) a","decl":"theorem IsWF.min_le (hs : s.IsWF) (hn : s.Nonempty) (ha : a ∈ s) : hs.min hn ≤ a :=\n  le_of_not_lt (hs.not_lt_min hn ha)\n\n"}
{"name":"Set.IsWF.le_min_iff","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns : Set α\na : α\nhs : s.IsWF\nhn : s.Nonempty\n⊢ Iff (LE.le a (hs.min hn)) (∀ (b : α), Membership.mem s b → LE.le a b)","decl":"theorem IsWF.le_min_iff (hs : s.IsWF) (hn : s.Nonempty) : a ≤ hs.min hn ↔ ∀ b, b ∈ s → a ≤ b :=\n  ⟨fun ha _b hb => le_trans ha (hs.min_le hn hb), fun h => h _ (hs.min_mem _)⟩\n\n"}
{"name":"Set.IsWF.min_le_min_of_subset","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Set α\nhs : s.IsWF\nhsn : s.Nonempty\nht : t.IsWF\nhtn : t.Nonempty\nhst : HasSubset.Subset s t\n⊢ LE.le (ht.min htn) (hs.min hsn)","decl":"theorem IsWF.min_le_min_of_subset {hs : s.IsWF} {hsn : s.Nonempty} {ht : t.IsWF} {htn : t.Nonempty}\n    (hst : s ⊆ t) : ht.min htn ≤ hs.min hsn :=\n  (IsWF.le_min_iff _ _).2 fun _b hb => ht.min_le htn (hst hb)\n\n"}
{"name":"Set.IsWF.min_union","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LinearOrder α\ns t : Set α\nhs : s.IsWF\nhsn : s.Nonempty\nht : t.IsWF\nhtn : t.Nonempty\n⊢ Eq (⋯.min ⋯) (Min.min (hs.min hsn) (ht.min htn))","decl":"theorem IsWF.min_union (hs : s.IsWF) (hsn : s.Nonempty) (ht : t.IsWF) (htn : t.Nonempty) :\n    (hs.union ht).min (union_nonempty.2 (Or.intro_left _ hsn)) =\n      Min.min (hs.min hsn) (ht.min htn) := by\n  refine le_antisymm (le_min (IsWF.min_le_min_of_subset subset_union_left)\n    (IsWF.min_le_min_of_subset subset_union_right)) ?_\n  rw [min_le_iff]\n  exact ((mem_union _ _ _).1 ((hs.union ht).min_mem (union_nonempty.2 (.inl hsn)))).imp\n    (hs.min_le _) (ht.min_le _)\n\n"}
{"name":"BddBelow.wellFoundedOn_lt","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : BddBelow s\n⊢ s.WellFoundedOn fun x1 x2 => LT.lt x1 x2","decl":"theorem BddBelow.wellFoundedOn_lt : BddBelow s → s.WellFoundedOn (· < ·) := by\n  rw [wellFoundedOn_iff_no_descending_seq]\n  rintro ⟨a, ha⟩ f hf\n  refine infinite_range_of_injective f.injective ?_\n  exact (finite_Icc a <| f 0).subset <| range_subset_iff.2 <| fun n =>\n    ⟨ha <| hf _,\n      antitone_iff_forall_lt.2 (fun a b hab => (f.map_rel_iff.2 hab).le) <| Nat.zero_le _⟩\n\n"}
{"name":"BddAbove.wellFoundedOn_gt","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : BddAbove s\n⊢ s.WellFoundedOn fun x1 x2 => GT.gt x1 x2","decl":"theorem BddAbove.wellFoundedOn_gt : BddAbove s → s.WellFoundedOn (· > ·) :=\n  fun h => h.dual.wellFoundedOn_lt\n\n"}
{"name":"BddBelow.isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ns : Set α\ninst✝¹ : Preorder α\ninst✝ : LocallyFiniteOrder α\na✝ : BddBelow s\n⊢ s.IsWF","decl":"theorem BddBelow.isWF : BddBelow s → IsWF s :=\n  BddBelow.wellFoundedOn_lt\n\n"}
{"name":"Set.PartiallyWellOrderedOn.iff_forall_not_isBadSeq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ns : Set α\n⊢ Iff (s.PartiallyWellOrderedOn r) (∀ (f : Nat → α), Not (Set.PartiallyWellOrderedOn.IsBadSeq r s f))","decl":"theorem iff_forall_not_isBadSeq (r : α → α → Prop) (s : Set α) :\n    s.PartiallyWellOrderedOn r ↔ ∀ f, ¬IsBadSeq r s f :=\n  forall_congr' fun f => by simp [IsBadSeq]\n\n"}
{"name":"Set.PartiallyWellOrderedOn.exists_min_bad_of_exists_bad","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\nrk : α → Nat\ns : Set α\na✝ : Exists fun f => Set.PartiallyWellOrderedOn.IsBadSeq r s f\n⊢ Exists fun f => And (Set.PartiallyWellOrderedOn.IsBadSeq r s f) (∀ (n : Nat), Set.PartiallyWellOrderedOn.IsMinBadSeq r rk s n f)","decl":"theorem exists_min_bad_of_exists_bad (r : α → α → Prop) (rk : α → ℕ) (s : Set α) :\n    (∃ f, IsBadSeq r s f) → ∃ f, IsBadSeq r s f ∧ ∀ n, IsMinBadSeq r rk s n f := by\n  rintro ⟨f0, hf0 : IsBadSeq r s f0⟩\n  let fs : ∀ n : ℕ, { f : ℕ → α // IsBadSeq r s f ∧ IsMinBadSeq r rk s n f } := by\n    refine Nat.rec ?_ fun n fn => ?_\n    · exact ⟨(minBadSeqOfBadSeq r rk s 0 f0 hf0).1, (minBadSeqOfBadSeq r rk s 0 f0 hf0).2.2⟩\n    · exact ⟨(minBadSeqOfBadSeq r rk s (n + 1) fn.1 fn.2.1).1,\n        (minBadSeqOfBadSeq r rk s (n + 1) fn.1 fn.2.1).2.2⟩\n  have h : ∀ m n, m ≤ n → (fs m).1 m = (fs n).1 m := fun m n mn => by\n    obtain ⟨k, rfl⟩ := Nat.exists_eq_add_of_le mn; clear mn\n    induction' k with k ih\n    · rfl\n    · rw [ih, (minBadSeqOfBadSeq r rk s (m + k + 1) (fs (m + k)).1 (fs (m + k)).2.1).2.1 m\n        (Nat.lt_succ_iff.2 (Nat.add_le_add_left k.zero_le m))]\n      rfl\n  refine ⟨fun n => (fs n).1 n, ⟨fun n => (fs n).2.1.1 n, fun m n mn => ?_⟩, fun n g hg1 hg2 => ?_⟩\n  · dsimp\n    rw [h m n mn.le]\n    exact (fs n).2.1.2 m n mn\n  · refine (fs n).2.2 g (fun m mn => ?_) hg2\n    rw [← h m n mn.le, ← hg1 m mn]\n\n"}
{"name":"Set.PartiallyWellOrderedOn.iff_not_exists_isMinBadSeq","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\nrk : α → Nat\ns : Set α\n⊢ Iff (s.PartiallyWellOrderedOn r) (Not (Exists fun f => And (Set.PartiallyWellOrderedOn.IsBadSeq r s f) (∀ (n : Nat), Set.PartiallyWellOrderedOn.IsMinBadSeq r rk s n f)))","decl":"theorem iff_not_exists_isMinBadSeq (rk : α → ℕ) {s : Set α} :\n    s.PartiallyWellOrderedOn r ↔ ¬∃ f, IsBadSeq r s f ∧ ∀ n, IsMinBadSeq r rk s n f := by\n  rw [iff_forall_not_isBadSeq, ← not_exists, not_congr]\n  constructor\n  · apply exists_min_bad_of_exists_bad\n  · rintro ⟨f, hf1, -⟩\n    exact ⟨f, hf1⟩\n\n"}
{"name":"Set.PartiallyWellOrderedOn.partiallyWellOrderedOn_sublistForall₂","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nr : α → α → Prop\ninst✝¹ : IsRefl α r\ninst✝ : IsTrans α r\ns : Set α\nh : s.PartiallyWellOrderedOn r\n⊢ (setOf fun l => ∀ (x : α), Membership.mem l x → Membership.mem s x).PartiallyWellOrderedOn (List.SublistForall₂ r)","decl":"/-- Higman's Lemma, which states that for any reflexive, transitive relation `r` which is\n  partially well-ordered on a set `s`, the relation `List.SublistForall₂ r` is partially\n  well-ordered on the set of lists of elements of `s`. That relation is defined so that\n  `List.SublistForall₂ r l₁ l₂` whenever `l₁` related pointwise by `r` to a sublist of `l₂`. -/\ntheorem partiallyWellOrderedOn_sublistForall₂ (r : α → α → Prop) [IsRefl α r] [IsTrans α r]\n    {s : Set α} (h : s.PartiallyWellOrderedOn r) :\n    { l : List α | ∀ x, x ∈ l → x ∈ s }.PartiallyWellOrderedOn (List.SublistForall₂ r) := by\n  rcases isEmpty_or_nonempty α\n  · exact subsingleton_of_subsingleton.partiallyWellOrderedOn\n  inhabit α\n  rw [iff_not_exists_isMinBadSeq List.length]\n  rintro ⟨f, hf1, hf2⟩\n  have hnil : ∀ n, f n ≠ List.nil := fun n con =>\n    hf1.2 n n.succ n.lt_succ_self (con.symm ▸ List.SublistForall₂.nil)\n  have : ∀ n, (f n).headI ∈ s :=\n    fun n => hf1.1 n _ (List.head!_mem_self (hnil n))\n  obtain ⟨g, hg⟩ := h.exists_monotone_subseq (fun n => (f n).headI) this\n  have hf' :=\n    hf2 (g 0) (fun n => if n < g 0 then f n else List.tail (f (g (n - g 0))))\n      (fun m hm => (if_pos hm).symm) ?_\n  swap\n  · simp only [if_neg (lt_irrefl (g 0)), Nat.sub_self]\n    rw [List.length_tail, ← Nat.pred_eq_sub_one]\n    exact Nat.pred_lt fun con => hnil _ (List.length_eq_zero.1 con)\n  rw [IsBadSeq] at hf'\n  push_neg at hf'\n  obtain ⟨m, n, mn, hmn⟩ := hf' fun n x hx => by\n    split_ifs at hx with hn\n    exacts [hf1.1 _ _ hx, hf1.1 _ _ (List.tail_subset _ hx)]\n  by_cases hn : n < g 0\n  · apply hf1.2 m n mn\n    rwa [if_pos hn, if_pos (mn.trans hn)] at hmn\n  · obtain ⟨n', rfl⟩ := Nat.exists_eq_add_of_le (not_lt.1 hn)\n    rw [if_neg hn, add_comm (g 0) n', Nat.add_sub_cancel_right] at hmn\n    split_ifs at hmn with hm\n    · apply hf1.2 m (g n') (lt_of_lt_of_le hm (g.monotone n'.zero_le))\n      exact _root_.trans hmn (List.tail_sublistForall₂_self _)\n    · rw [← Nat.sub_lt_iff_lt_add (le_of_not_lt hm)] at mn\n      apply hf1.2 _ _ (g.lt_iff_lt.2 mn)\n      rw [← List.cons_head!_tail (hnil (g (m - g 0))), ← List.cons_head!_tail (hnil (g n'))]\n      exact List.SublistForall₂.cons (hg _ _ (le_of_lt mn)) hmn\n\n"}
{"name":"Set.PartiallyWellOrderedOn.subsetProdLex","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ns : Set (Lex (Prod α β))\nhα : (Set.image (fun x => (ofLex x).1) s).IsPWO\nhβ : ∀ (a : α), (setOf fun y => Membership.mem s (toLex { fst := a, snd := y })).IsPWO\n⊢ s.IsPWO","decl":"theorem subsetProdLex [PartialOrder α] [Preorder β] {s : Set (α ×ₗ β)}\n    (hα : ((fun (x : α ×ₗ β) => (ofLex x).1)'' s).IsPWO)\n    (hβ : ∀ a, {y | toLex (a, y) ∈ s}.IsPWO) : s.IsPWO := by\n  intro f hf\n  rw [isPWO_iff_exists_monotone_subseq] at hα\n  obtain ⟨g, hg⟩ : ∃ (g : (ℕ ↪o ℕ)), Monotone fun n => (ofLex f (g n)).1 :=\n    hα (fun n => (ofLex f n).1) (fun k => mem_image_of_mem (fun x => (ofLex x).1) (hf k))\n  have hhg : ∀ n, (ofLex f (g 0)).1 ≤ (ofLex f (g n)).1 := fun n => hg n.zero_le\n  by_cases hc : ∃ n, (ofLex f (g 0)).1 < (ofLex f (g n)).1\n  · obtain ⟨n, hn⟩ := hc\n    use (g 0), (g n)\n    constructor\n    · by_contra hx\n      simp_all\n    · exact Prod.Lex.toLex_le_toLex.mpr <| .inl hn\n  · have hhc : ∀ n, (ofLex f (g 0)).1 = (ofLex f (g n)).1 := by\n      intro n\n      rw [not_exists] at hc\n      exact (hhg n).eq_of_not_lt (hc n)\n    obtain ⟨g', hg'⟩ : ∃ g' : ℕ ↪o ℕ, Monotone ((fun n ↦ (ofLex f (g (g' n))).2)) := by\n      simp_rw [isPWO_iff_exists_monotone_subseq] at hβ\n      apply hβ (ofLex f (g 0)).1 fun n ↦ (ofLex f (g n)).2\n      intro n\n      rw [hhc n]\n      simpa using hf _\n    use (g (g' 0)), (g (g' 1))\n    suffices (f (g (g' 0))) ≤ (f (g (g' 1))) by simpa\n    · refine Prod.Lex.toLex_le_toLex.mpr <| .inr ⟨?_, ?_⟩\n      · exact (hhc (g' 0)).symm.trans (hhc (g' 1))\n      · exact hg' (Nat.zero_le 1)\n\n"}
{"name":"Set.PartiallyWellOrderedOn.imageProdLex","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ns : Set (Lex (Prod α β))\nhαβ : s.IsPWO\n⊢ (Set.image (fun x => (ofLex x).1) s).IsPWO","decl":"theorem imageProdLex [PartialOrder α] [Preorder β] {s : Set (α ×ₗ β)}\n    (hαβ : s.IsPWO) : ((fun (x : α ×ₗ β) => (ofLex x).1)'' s).IsPWO :=\n  IsPWO.image_of_monotone hαβ Prod.Lex.monotone_fst\n\n"}
{"name":"Set.PartiallyWellOrderedOn.fiberProdLex","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ns : Set (Lex (Prod α β))\nhαβ : s.IsPWO\na : α\n⊢ (setOf fun y => Membership.mem s (toLex { fst := a, snd := y })).IsPWO","decl":"theorem fiberProdLex [PartialOrder α] [Preorder β] {s : Set (α ×ₗ β)}\n    (hαβ : s.IsPWO) (a : α) : {y | toLex (a, y) ∈ s}.IsPWO := by\n  let f : α ×ₗ β → β := fun x => (ofLex x).2\n  have h : {y | toLex (a, y) ∈ s} = f '' (s ∩ (fun x ↦ (ofLex x).1) ⁻¹' {a}) := by\n    ext x\n    simp [f]\n  rw [h]\n  apply IsPWO.image_of_monotoneOn (hαβ.mono inter_subset_left)\n  rintro b ⟨-, hb⟩ c ⟨-, hc⟩ hbc\n  simp only [mem_preimage, mem_singleton_iff] at hb hc\n  have : (ofLex b).1 < (ofLex c).1 ∨ (ofLex b).1 = (ofLex c).1 ∧ f b ≤ f c :=\n    Prod.Lex.toLex_le_toLex.mp hbc\n  simp_all only [lt_self_iff_false, true_and, false_or]\n\n"}
{"name":"Set.PartiallyWellOrderedOn.ProdLex_iff","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\ninst✝¹ : PartialOrder α\ninst✝ : Preorder β\ns : Set (Lex (Prod α β))\n⊢ Iff s.IsPWO (And (Set.image (fun x => (ofLex x).1) s).IsPWO (∀ (a : α), (setOf fun y => Membership.mem s (toLex { fst := a, snd := y })).IsPWO))","decl":"theorem ProdLex_iff [PartialOrder α] [Preorder β] {s : Set (α ×ₗ β)} :\n    s.IsPWO ↔\n      ((fun (x : α ×ₗ β) ↦ (ofLex x).1) '' s).IsPWO ∧ ∀ a, {y | toLex (a, y) ∈ s}.IsPWO :=\n  ⟨fun h ↦ ⟨imageProdLex h, fiberProdLex h⟩, fun h ↦ subsetProdLex h.1 h.2⟩\n\n"}
{"name":"WellFounded.isWF","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\ninst✝ : LT α\nh : WellFounded fun x1 x2 => LT.lt x1 x2\ns : Set α\n⊢ s.IsWF","decl":"theorem WellFounded.isWF [LT α] (h : WellFounded ((· < ·) : α → α → Prop)) (s : Set α) : s.IsWF :=\n  (Set.isWF_univ_iff.2 h).mono s.subset_univ\n\n"}
{"name":"Pi.isPWO","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nα : ι → Type u_6\ninst✝² : (i : ι) → LinearOrder (α i)\ninst✝¹ : ∀ (i : ι), IsWellOrder (α i) fun x1 x2 => LT.lt x1 x2\ninst✝ : Finite ι\ns : Set ((i : ι) → α i)\n⊢ s.IsPWO","decl":"/-- A version of **Dickson's lemma** any subset of functions `Π s : σ, α s` is partially well\nordered, when `σ` is a `Fintype` and each `α s` is a linear well order.\nThis includes the classical case of Dickson's lemma that `ℕ ^ n` is a well partial order.\nSome generalizations would be possible based on this proof, to include cases where the target is\npartially well ordered, and also to consider the case of `Set.PartiallyWellOrderedOn` instead of\n`Set.IsPWO`. -/\ntheorem Pi.isPWO {α : ι → Type*} [∀ i, LinearOrder (α i)] [∀ i, IsWellOrder (α i) (· < ·)]\n    [Finite ι] (s : Set (∀ i, α i)) : s.IsPWO := by\n  cases nonempty_fintype ι\n  suffices ∀ (s : Finset ι) (f : ℕ → ∀ s, α s),\n    ∃ g : ℕ ↪o ℕ, ∀ ⦃a b : ℕ⦄, a ≤ b → ∀ x, x ∈ s → (f ∘ g) a x ≤ (f ∘ g) b x by\n    refine isPWO_iff_exists_monotone_subseq.2 fun f _ => ?_\n    simpa only [Finset.mem_univ, true_imp_iff] using this Finset.univ f\n  refine Finset.cons_induction ?_ ?_\n  · intro f\n    exists RelEmbedding.refl (· ≤ ·)\n    simp only [IsEmpty.forall_iff, imp_true_iff, forall_const, Finset.not_mem_empty]\n  · intro x s hx ih f\n    obtain ⟨g, hg⟩ :=\n      (IsWellFounded.wf.isWF univ).isPWO.exists_monotone_subseq (fun n => f n x) mem_univ\n    obtain ⟨g', hg'⟩ := ih (f ∘ g)\n    refine ⟨g'.trans g, fun a b hab => (Finset.forall_mem_cons _ _).2 ?_⟩\n    exact ⟨hg (OrderHomClass.mono g' hab), hg' hab⟩\n\n"}
{"name":"WellFounded.prod_lex_of_wellFoundedOn_fiber","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nrα : α → α → Prop\nrβ : β → β → Prop\nf : γ → α\ng : γ → β\nhα : WellFounded (Function.onFun rα f)\nhβ : ∀ (a : α), (Set.preimage f (Singleton.singleton a)).WellFoundedOn (Function.onFun rβ g)\n⊢ WellFounded (Function.onFun (Prod.Lex rα rβ) fun c => { fst := f c, snd := g c })","decl":"/-- Stronger version of `WellFounded.prod_lex`. Instead of requiring `rβ on g` to be well-founded,\nwe only require it to be well-founded on fibers of `f`. -/\ntheorem WellFounded.prod_lex_of_wellFoundedOn_fiber (hα : WellFounded (rα on f))\n    (hβ : ∀ a, (f ⁻¹' {a}).WellFoundedOn (rβ on g)) :\n    WellFounded (Prod.Lex rα rβ on fun c => (f c, g c)) := by\n  refine ((psigma_lex (wellFoundedOn_range.2 hα) fun a => hβ a).onFun\n    (f := fun c => ⟨⟨_, c, rfl⟩, c, rfl⟩)).mono fun c c' h => ?_\n  obtain h' | h' := Prod.lex_iff.1 h\n  · exact PSigma.Lex.left _ _ h'\n  · dsimp only [InvImage, (· on ·)] at h' ⊢\n    convert PSigma.Lex.right (⟨_, c', rfl⟩ : range f) _ using 1; swap\n    exacts [⟨c, h'.1⟩, PSigma.subtype_ext (Subtype.ext h'.1) rfl, h'.2]\n\n"}
{"name":"Set.WellFoundedOn.prod_lex_of_wellFoundedOn_fiber","module":"Mathlib.Order.WellFoundedSet","initialProofState":"α : Type u_2\nβ : Type u_3\nγ : Type u_4\nrα : α → α → Prop\nrβ : β → β → Prop\nf : γ → α\ng : γ → β\ns : Set γ\nhα : s.WellFoundedOn (Function.onFun rα f)\nhβ : ∀ (a : α), (Inter.inter s (Set.preimage f (Singleton.singleton a))).WellFoundedOn (Function.onFun rβ g)\n⊢ s.WellFoundedOn (Function.onFun (Prod.Lex rα rβ) fun c => { fst := f c, snd := g c })","decl":"theorem Set.WellFoundedOn.prod_lex_of_wellFoundedOn_fiber (hα : s.WellFoundedOn (rα on f))\n    (hβ : ∀ a, (s ∩ f ⁻¹' {a}).WellFoundedOn (rβ on g)) :\n    s.WellFoundedOn (Prod.Lex rα rβ on fun c => (f c, g c)) :=\n  WellFounded.prod_lex_of_wellFoundedOn_fiber hα\n    fun a ↦ ((hβ a).onFun (f := fun x => ⟨x, x.1.2, x.2⟩)).mono (fun _ _ h ↦ ‹_›)\n\n"}
{"name":"WellFounded.sigma_lex_of_wellFoundedOn_fiber","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nγ : Type u_4\nπ : ι → Type u_5\nrι : ι → ι → Prop\nrπ : (i : ι) → π i → π i → Prop\nf : γ → ι\ng : (i : ι) → γ → π i\nhι : WellFounded (Function.onFun rι f)\nhπ : ∀ (i : ι), (Set.preimage f (Singleton.singleton i)).WellFoundedOn (Function.onFun (rπ i) (g i))\n⊢ WellFounded (Function.onFun (Sigma.Lex rι rπ) fun c => ⟨f c, g (f c) c⟩)","decl":"/-- Stronger version of `PSigma.lex_wf`. Instead of requiring `rπ on g` to be well-founded, we only\nrequire it to be well-founded on fibers of `f`. -/\ntheorem WellFounded.sigma_lex_of_wellFoundedOn_fiber (hι : WellFounded (rι on f))\n    (hπ : ∀ i, (f ⁻¹' {i}).WellFoundedOn (rπ i on g i)) :\n    WellFounded (Sigma.Lex rι rπ on fun c => ⟨f c, g (f c) c⟩) := by\n  refine ((psigma_lex (wellFoundedOn_range.2 hι) fun a => hπ a).onFun\n    (f := fun c => ⟨⟨_, c, rfl⟩, c, rfl⟩)).mono fun c c' h => ?_\n  obtain h' | ⟨h', h''⟩ := Sigma.lex_iff.1 h\n  · exact PSigma.Lex.left _ _ h'\n  · dsimp only [InvImage, (· on ·)] at h' ⊢\n    convert PSigma.Lex.right (⟨_, c', rfl⟩ : range f) _ using 1; swap\n    · exact ⟨c, h'⟩\n    · exact PSigma.subtype_ext (Subtype.ext h') rfl\n    · dsimp only [Subtype.coe_mk] at *\n      revert h'\n      generalize f c = d\n      rintro rfl h''\n      exact h''\n\n"}
{"name":"Set.WellFoundedOn.sigma_lex_of_wellFoundedOn_fiber","module":"Mathlib.Order.WellFoundedSet","initialProofState":"ι : Type u_1\nγ : Type u_4\nπ : ι → Type u_5\nrι : ι → ι → Prop\nrπ : (i : ι) → π i → π i → Prop\nf : γ → ι\ng : (i : ι) → γ → π i\ns : Set γ\nhι : s.WellFoundedOn (Function.onFun rι f)\nhπ : ∀ (i : ι), (Inter.inter s (Set.preimage f (Singleton.singleton i))).WellFoundedOn (Function.onFun (rπ i) (g i))\n⊢ s.WellFoundedOn (Function.onFun (Sigma.Lex rι rπ) fun c => ⟨f c, g (f c) c⟩)","decl":"theorem Set.WellFoundedOn.sigma_lex_of_wellFoundedOn_fiber (hι : s.WellFoundedOn (rι on f))\n    (hπ : ∀ i, (s ∩ f ⁻¹' {i}).WellFoundedOn (rπ i on g i)) :\n    s.WellFoundedOn (Sigma.Lex rι rπ on fun c => ⟨f c, g (f c) c⟩) := by\n  show WellFounded (Sigma.Lex rι rπ on fun c : s => ⟨f c, g (f c) c⟩)\n  exact\n    @WellFounded.sigma_lex_of_wellFoundedOn_fiber _ s _ _ rπ (fun c => f c) (fun i c => g _ c) hι\n      fun i => ((hπ i).onFun (f := fun x => ⟨x, x.1.2, x.2⟩)).mono (fun b c h => ‹_›)\n\n"}
