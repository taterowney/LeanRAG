{"name":"TensorProduct.isTensorProduct","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Type u_4\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nN : Type u_8\ninst✝¹ : AddCommMonoid N\ninst✝ : Module R N\n⊢ IsTensorProduct (TensorProduct.mk R M N)","decl":"theorem TensorProduct.isTensorProduct : IsTensorProduct (TensorProduct.mk R M N) := by\n  delta IsTensorProduct\n  convert_to Function.Bijective (LinearMap.id : M ⊗[R] N →ₗ[R] M ⊗[R] N) using 2\n  · apply TensorProduct.ext'\n    simp\n  · exact Function.bijective_id\n\n"}
{"name":"IsTensorProduct.equiv_apply","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\nh : IsTensorProduct f\na✝ : TensorProduct R M₁ M₂\n⊢ Eq (h.equiv a✝) ((TensorProduct.lift f) a✝)","decl":"/-- If `M` is the tensor product of `M₁` and `M₂`, it is linearly equivalent to `M₁ ⊗[R] M₂`. -/\n@[simps! apply]\nnoncomputable def IsTensorProduct.equiv (h : IsTensorProduct f) : M₁ ⊗[R] M₂ ≃ₗ[R] M :=\n  LinearEquiv.ofBijective _ h\n\n"}
{"name":"IsTensorProduct.equiv_toLinearMap","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\nh : IsTensorProduct f\n⊢ Eq (↑h.equiv) (TensorProduct.lift f)","decl":"@[simp]\ntheorem IsTensorProduct.equiv_toLinearMap (h : IsTensorProduct f) :\n    h.equiv.toLinearMap = TensorProduct.lift f :=\n  rfl\n\n"}
{"name":"IsTensorProduct.equiv_symm_apply","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\nh : IsTensorProduct f\nx₁ : M₁\nx₂ : M₂\n⊢ Eq (h.equiv.symm ((f x₁) x₂)) (TensorProduct.tmul R x₁ x₂)","decl":"@[simp]\ntheorem IsTensorProduct.equiv_symm_apply (h : IsTensorProduct f) (x₁ : M₁) (x₂ : M₂) :\n    h.equiv.symm (f x₁ x₂) = x₁ ⊗ₜ x₂ := by\n  apply h.equiv.injective\n  refine (h.equiv.apply_symm_apply _).trans ?_\n  simp\n\n"}
{"name":"IsTensorProduct.lift_eq","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁸ : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\nM' : Type u_5\ninst✝⁷ : AddCommMonoid M₁\ninst✝⁶ : AddCommMonoid M₂\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M₁\ninst✝² : Module R M₂\ninst✝¹ : Module R M\ninst✝ : Module R M'\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\nh : IsTensorProduct f\nf' : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M')\nx₁ : M₁\nx₂ : M₂\n⊢ Eq ((h.lift f') ((f x₁) x₂)) ((f' x₁) x₂)","decl":"theorem IsTensorProduct.lift_eq (h : IsTensorProduct f) (f' : M₁ →ₗ[R] M₂ →ₗ[R] M') (x₁ : M₁)\n    (x₂ : M₂) : h.lift f' (f x₁ x₂) = f' x₁ x₂ := by\n  delta IsTensorProduct.lift\n  simp\n\n"}
{"name":"IsTensorProduct.map_eq","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝¹² : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\ninst✝¹¹ : AddCommMonoid M₁\ninst✝¹⁰ : AddCommMonoid M₂\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M₁\ninst✝⁷ : Module R M₂\ninst✝⁶ : Module R M\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\nN₁ : Type u_6\nN₂ : Type u_7\nN : Type u_8\ninst✝⁵ : AddCommMonoid N₁\ninst✝⁴ : AddCommMonoid N₂\ninst✝³ : AddCommMonoid N\ninst✝² : Module R N₁\ninst✝¹ : Module R N₂\ninst✝ : Module R N\ng : LinearMap (RingHom.id R) N₁ (LinearMap (RingHom.id R) N₂ N)\nhf : IsTensorProduct f\nhg : IsTensorProduct g\ni₁ : LinearMap (RingHom.id R) M₁ N₁\ni₂ : LinearMap (RingHom.id R) M₂ N₂\nx₁ : M₁\nx₂ : M₂\n⊢ Eq ((hf.map hg i₁ i₂) ((f x₁) x₂)) ((g (i₁ x₁)) (i₂ x₂))","decl":"theorem IsTensorProduct.map_eq (hf : IsTensorProduct f) (hg : IsTensorProduct g) (i₁ : M₁ →ₗ[R] N₁)\n    (i₂ : M₂ →ₗ[R] N₂) (x₁ : M₁) (x₂ : M₂) : hf.map hg i₁ i₂ (f x₁ x₂) = g (i₁ x₁) (i₂ x₂) := by\n  delta IsTensorProduct.map\n  simp\n\n"}
{"name":"IsTensorProduct.inductionOn","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\nh : IsTensorProduct f\nC : M → Prop\nm : M\nh0 : C 0\nhtmul : ∀ (x : M₁) (y : M₂), C ((f x) y)\nhadd : ∀ (x y : M), C x → C y → C (HAdd.hAdd x y)\n⊢ C m","decl":"theorem IsTensorProduct.inductionOn (h : IsTensorProduct f) {C : M → Prop} (m : M) (h0 : C 0)\n    (htmul : ∀ x y, C (f x y)) (hadd : ∀ x y, C x → C y → C (x + y)) : C m := by\n  rw [← h.equiv.right_inv m]\n  generalize h.equiv.invFun m = y\n  change C (TensorProduct.lift f y)\n  induction y with\n  | zero => rwa [map_zero]\n  | tmul _ _ =>\n    rw [TensorProduct.lift.tmul]\n    apply htmul\n  | add _ _ _ _ =>\n    rw [map_add]\n    apply hadd <;> assumption\n\n"}
{"name":"IsTensorProduct.of_equiv","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM₁ : Type u_2\nM₂ : Type u_3\nM : Type u_4\ninst✝⁵ : AddCommMonoid M₁\ninst✝⁴ : AddCommMonoid M₂\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M₁\ninst✝¹ : Module R M₂\ninst✝ : Module R M\nf : LinearMap (RingHom.id R) M₁ (LinearMap (RingHom.id R) M₂ M)\ne : LinearEquiv (RingHom.id R) (TensorProduct R M₁ M₂) M\nhe : ∀ (x : M₁) (y : M₂), Eq (e (TensorProduct.tmul R x y)) ((f x) y)\n⊢ IsTensorProduct f","decl":"lemma IsTensorProduct.of_equiv (e : M₁ ⊗[R] M₂ ≃ₗ[R] M) (he : ∀ x y, e (x ⊗ₜ y) = f x y) :\n    IsTensorProduct f := by\n  have : TensorProduct.lift f = e := by\n    ext x y\n    simp [he]\n  simpa [IsTensorProduct, this] using e.bijective\n\n"}
{"name":"IsBaseChange.lift_eq","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : AddCommMonoid N\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module S N\ninst✝⁴ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\nQ : Type u_3\ninst✝³ : AddCommMonoid Q\ninst✝² : Module S Q\ninst✝¹ : Module R Q\ninst✝ : IsScalarTower R S Q\ng : LinearMap (RingHom.id R) M Q\nx : M\n⊢ Eq ((h.lift g) (f x)) (g x)","decl":"nonrec theorem IsBaseChange.lift_eq (g : M →ₗ[R] Q) (x : M) : h.lift g (f x) = g x := by\n  have hF : ∀ (s : S) (m : M), h.lift g (s • f m) = s • g m := h.lift_eq _\n  convert hF 1 x <;> rw [one_smul]\n\n"}
{"name":"IsBaseChange.lift_comp","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : AddCommMonoid N\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module S N\ninst✝⁴ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\nQ : Type u_3\ninst✝³ : AddCommMonoid Q\ninst✝² : Module S Q\ninst✝¹ : Module R Q\ninst✝ : IsScalarTower R S Q\ng : LinearMap (RingHom.id R) M Q\n⊢ Eq ((↑R (h.lift g)).comp f) g","decl":"theorem IsBaseChange.lift_comp (g : M →ₗ[R] Q) : ((h.lift g).restrictScalars R).comp f = g :=\n  LinearMap.ext (h.lift_eq g)\n\n"}
{"name":"IsBaseChange.inductionOn","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\nx : N\nP : N → Prop\nh₁ : P 0\nh₂ : ∀ (m : M), P (f m)\nh₃ : ∀ (s : S) (n : N), P n → P (HSMul.hSMul s n)\nh₄ : ∀ (n₁ n₂ : N), P n₁ → P n₂ → P (HAdd.hAdd n₁ n₂)\n⊢ P x","decl":"@[elab_as_elim]\nnonrec theorem IsBaseChange.inductionOn (x : N) (P : N → Prop) (h₁ : P 0) (h₂ : ∀ m : M, P (f m))\n    (h₃ : ∀ (s : S) (n), P n → P (s • n)) (h₄ : ∀ n₁ n₂, P n₁ → P n₂ → P (n₁ + n₂)) : P x :=\n  h.inductionOn x h₁ (fun _ _ => h₃ _ _ (h₂ _)) h₄\n\n"}
{"name":"IsBaseChange.algHom_ext","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹⁰ : AddCommMonoid M\ninst✝⁹ : AddCommMonoid N\ninst✝⁸ : CommSemiring R\ninst✝⁷ : CommSemiring S\ninst✝⁶ : Algebra R S\ninst✝⁵ : Module R M\ninst✝⁴ : Module R N\ninst✝³ : Module S N\ninst✝² : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\nQ : Type u_3\ninst✝¹ : AddCommMonoid Q\ninst✝ : Module S Q\ng₁ g₂ : LinearMap (RingHom.id S) N Q\ne : ∀ (x : M), Eq (g₁ (f x)) (g₂ (f x))\n⊢ Eq g₁ g₂","decl":"theorem IsBaseChange.algHom_ext (g₁ g₂ : N →ₗ[S] Q) (e : ∀ x, g₁ (f x) = g₂ (f x)) : g₁ = g₂ := by\n  ext x\n  refine h.inductionOn x _ ?_ ?_ ?_ ?_\n  · rw [map_zero, map_zero]\n  · assumption\n  · intro s n e'\n    rw [g₁.map_smul, g₂.map_smul, e']\n  · intro x y e₁ e₂\n    rw [map_add, map_add, e₁, e₂]\n\n"}
{"name":"IsBaseChange.algHom_ext'","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹² : AddCommMonoid M\ninst✝¹¹ : AddCommMonoid N\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\ninst✝⁷ : Module R M\ninst✝⁶ : Module R N\ninst✝⁵ : Module S N\ninst✝⁴ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\nQ : Type u_3\ninst✝³ : AddCommMonoid Q\ninst✝² : Module S Q\ninst✝¹ : Module R Q\ninst✝ : IsScalarTower R S Q\ng₁ g₂ : LinearMap (RingHom.id S) N Q\ne : Eq ((↑R g₁).comp f) ((↑R g₂).comp f)\n⊢ Eq g₁ g₂","decl":"theorem IsBaseChange.algHom_ext' [Module R Q] [IsScalarTower R S Q] (g₁ g₂ : N →ₗ[S] Q)\n    (e : (g₁.restrictScalars R).comp f = (g₂.restrictScalars R).comp f) : g₁ = g₂ :=\n  h.algHom_ext g₁ g₂ (LinearMap.congr_fun e)\n\n"}
{"name":"TensorProduct.isBaseChange","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nS : Type v₃\ninst✝⁴ : AddCommMonoid M\ninst✝³ : CommSemiring R\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : Module R M\n⊢ IsBaseChange S ((TensorProduct.mk R S M) 1)","decl":"theorem TensorProduct.isBaseChange : IsBaseChange S (TensorProduct.mk R S M 1) := by\n  delta IsBaseChange\n  convert TensorProduct.isTensorProduct R S M using 1\n  ext s x\n  change s • (1 : S) ⊗ₜ[R] x = s ⊗ₜ[R] x\n  rw [TensorProduct.smul_tmul']\n  congr 1\n  exact mul_one _\n\n"}
{"name":"IsBaseChange.equiv_tmul","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\ns : S\nm : M\n⊢ Eq (h.equiv (TensorProduct.tmul R s m)) (HSMul.hSMul s (f m))","decl":"theorem IsBaseChange.equiv_tmul (s : S) (m : M) : h.equiv (s ⊗ₜ m) = s • f m :=\n  TensorProduct.lift.tmul s m\n\n"}
{"name":"IsBaseChange.equiv_symm_apply","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange S f\nm : M\n⊢ Eq (h.equiv.symm (f m)) (TensorProduct.tmul R 1 m)","decl":"theorem IsBaseChange.equiv_symm_apply (m : M) : h.equiv.symm (f m) = 1 ⊗ₜ m := by\n  rw [h.equiv.symm_apply_eq, h.equiv_tmul, one_smul]\n\n"}
{"name":"IsBaseChange.of_equiv","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\ne : LinearEquiv (RingHom.id S) (TensorProduct R S M) N\nhe : ∀ (x : M), Eq (e (TensorProduct.tmul R 1 x)) (f x)\n⊢ IsBaseChange S f","decl":"lemma IsBaseChange.of_equiv (e : S ⊗[R] M ≃ₗ[S] N) (he : ∀ x, e (1 ⊗ₜ x) = f x) :\n    IsBaseChange S f := by\n  apply IsTensorProduct.of_equiv (e.restrictScalars R)\n  intro x y\n  simp [show x ⊗ₜ[R] y = x • (1 ⊗ₜ[R] y) by simp [smul_tmul'], he]\n\n"}
{"name":"isBaseChange_tensorProduct_map","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹⁹ : AddCommMonoid M\ninst✝¹⁸ : AddCommMonoid N\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : Algebra R S\ninst✝¹⁴ : Module R M\ninst✝¹³ : Module R N\ninst✝¹² : Module S N\ninst✝¹¹ : IsScalarTower R S N\nP : Type u_2\ninst✝¹⁰ : AddCommMonoid P\ninst✝⁹ : Module R P\nA : Type u_4\ninst✝⁸ : CommSemiring A\ninst✝⁷ : Algebra R A\ninst✝⁶ : Algebra S A\ninst✝⁵ : IsScalarTower R S A\ninst✝⁴ : Module S M\ninst✝³ : IsScalarTower R S M\ninst✝² : Module A N\ninst✝¹ : IsScalarTower S A N\ninst✝ : IsScalarTower R A N\nf : LinearMap (RingHom.id S) M N\nhf : IsBaseChange A f\n⊢ IsBaseChange A (TensorProduct.AlgebraTensorModule.map f LinearMap.id)","decl":"/-- If `N` is the base change of `M` to `A`, then `N ⊗[R] P` is the base change\nof `M ⊗[R] P` to `A`. This is simply the isomorphism\n`A ⊗[S] (M ⊗[R] P) ≃ₗ[A] (A ⊗[S] M) ⊗[R] P`. -/\nlemma isBaseChange_tensorProduct_map {f : M →ₗ[S] N} (hf : IsBaseChange A f) :\n    IsBaseChange A (AlgebraTensorModule.map f (LinearMap.id (R := R) (M := P))) := by\n  let e : A ⊗[S] M ⊗[R] P ≃ₗ[A] N ⊗[R] P := (AlgebraTensorModule.assoc R S A A M P).symm.trans\n    (AlgebraTensorModule.congr hf.equiv (LinearEquiv.refl R P))\n  refine IsBaseChange.of_equiv e (fun x ↦ ?_)\n  induction' x with m p _ _ h1 h2\n  · simp\n  · simp [e, IsBaseChange.equiv_tmul]\n  · simp [tmul_add, h1, h2]\n\n"}
{"name":"IsBaseChange.of_lift_unique","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\nh : ∀ (Q : Type (max v₁ v₂ v₃)) [inst : AddCommMonoid Q] [inst_1 : Module R Q] [inst_2 : Module S Q] [inst_3 : IsScalarTower R S Q] (g : LinearMap (RingHom.id R) M Q), ExistsUnique fun g' => Eq ((↑R g').comp f) g\n⊢ IsBaseChange S f","decl":"theorem IsBaseChange.of_lift_unique\n    (h : ∀ (Q : Type max v₁ v₂ v₃) [AddCommMonoid Q],\n      ∀ [Module R Q] [Module S Q], ∀ [IsScalarTower R S Q],\n        ∀ g : M →ₗ[R] Q, ∃! g' : N →ₗ[S] Q, (g'.restrictScalars R).comp f = g) :\n    IsBaseChange S f := by\n  obtain ⟨g, hg, -⟩ :=\n    h (ULift.{v₂} <| S ⊗[R] M)\n      (ULift.moduleEquiv.symm.toLinearMap.comp <| TensorProduct.mk R S M 1)\n  let f' : S ⊗[R] M →ₗ[R] N :=\n    TensorProduct.lift (((LinearMap.flip (AlgHom.toLinearMap (Algebra.ofId S\n      (Module.End S (M →ₗ[R] N))))) f).restrictScalars R)\n  change Function.Bijective f'\n  let f'' : S ⊗[R] M →ₗ[S] N := by\n    refine\n      { f' with\n        map_smul' := fun s x =>\n          TensorProduct.induction_on x ?_ (fun s' y => smul_assoc s s' _) fun x y hx hy => ?_ }\n    · dsimp; rw [map_zero, smul_zero, map_zero, smul_zero]\n    · dsimp at *; rw [smul_add, map_add, map_add, smul_add, hx, hy]\n  simp_rw [DFunLike.ext_iff, LinearMap.comp_apply, LinearMap.restrictScalars_apply] at hg\n  let fe : S ⊗[R] M ≃ₗ[S] N :=\n    LinearEquiv.ofLinear f'' (ULift.moduleEquiv.toLinearMap.comp g) ?_ ?_\n  · exact fe.bijective\n  · rw [← LinearMap.cancel_left (ULift.moduleEquiv : ULift.{max v₁ v₃} N ≃ₗ[S] N).symm.injective]\n    refine (h (ULift.{max v₁ v₃} N) <| ULift.moduleEquiv.symm.toLinearMap.comp f).unique ?_ rfl\n    ext x\n    simp only [LinearMap.comp_apply, LinearMap.restrictScalars_apply, hg]\n    apply one_smul\n  · ext x\n    change (g <| (1 : S) • f x).down = _\n    rw [one_smul, hg]\n    rfl\n\n"}
{"name":"IsBaseChange.iff_lift_unique","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : AddCommMonoid N\ninst✝⁶ : CommSemiring R\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : Module R M\ninst✝² : Module R N\ninst✝¹ : Module S N\ninst✝ : IsScalarTower R S N\nf : LinearMap (RingHom.id R) M N\n⊢ Iff (IsBaseChange S f) (∀ (Q : Type (max v₁ v₂ v₃)) [inst : AddCommMonoid Q] [inst_1 : Module R Q] [inst_2 : Module S Q] [inst_3 : IsScalarTower R S Q] (g : LinearMap (RingHom.id R) M Q), ExistsUnique fun g' => Eq ((↑R g').comp f) g)","decl":"theorem IsBaseChange.iff_lift_unique :\n    IsBaseChange S f ↔\n      ∀ (Q : Type max v₁ v₂ v₃) [AddCommMonoid Q],\n        ∀ [Module R Q] [Module S Q],\n          ∀ [IsScalarTower R S Q],\n            ∀ g : M →ₗ[R] Q, ∃! g' : N →ₗ[S] Q, (g'.restrictScalars R).comp f = g :=\n  ⟨fun h => by\n    intros Q _ _ _ _ g\n    exact ⟨h.lift g, h.lift_comp g, fun g' e => h.algHom_ext' _ _ (e.trans (h.lift_comp g).symm)⟩,\n    IsBaseChange.of_lift_unique f⟩\n\n"}
{"name":"IsBaseChange.ofEquiv","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\ninst✝⁴ : AddCommMonoid M\ninst✝³ : AddCommMonoid N\ninst✝² : CommSemiring R\ninst✝¹ : Module R M\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\n⊢ IsBaseChange R ↑e","decl":"theorem IsBaseChange.ofEquiv (e : M ≃ₗ[R] N) : IsBaseChange R e.toLinearMap := by\n  apply IsBaseChange.of_lift_unique\n  intro Q I₁ I₂ I₃ I₄ g\n  have : I₂ = I₃ := by\n    ext r q\n    show (by let _ := I₂; exact r • q) = (by let _ := I₃; exact r • q)\n    dsimp\n    rw [← one_smul R q, smul_smul, ← @smul_assoc _ _ _ (id _) (id _) (id _) I₄, smul_eq_mul]\n  cases this\n  refine\n    ⟨g.comp e.symm.toLinearMap, by\n      ext\n      simp, ?_⟩\n  rintro y (rfl : _ = _)\n  ext\n  simp\n\n"}
{"name":"IsBaseChange.comp","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹⁹ : AddCommMonoid M\ninst✝¹⁸ : AddCommMonoid N\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : Algebra R S\ninst✝¹⁴ : Module R M\ninst✝¹³ : Module R N\ninst✝¹² : Module S N\ninst✝¹¹ : IsScalarTower R S N\nT : Type u_4\nO : Type u_5\ninst✝¹⁰ : CommSemiring T\ninst✝⁹ : Algebra R T\ninst✝⁸ : Algebra S T\ninst✝⁷ : IsScalarTower R S T\ninst✝⁶ : AddCommMonoid O\ninst✝⁵ : Module R O\ninst✝⁴ : Module S O\ninst✝³ : Module T O\ninst✝² : IsScalarTower S T O\ninst✝¹ : IsScalarTower R S O\ninst✝ : IsScalarTower R T O\nf : LinearMap (RingHom.id R) M N\nhf : IsBaseChange S f\ng : LinearMap (RingHom.id S) N O\nhg : IsBaseChange T g\n⊢ IsBaseChange T ((↑R g).comp f)","decl":"theorem IsBaseChange.comp {f : M →ₗ[R] N} (hf : IsBaseChange S f) {g : N →ₗ[S] O}\n    (hg : IsBaseChange T g) : IsBaseChange T ((g.restrictScalars R).comp f) := by\n  apply IsBaseChange.of_lift_unique\n  intro Q _ _ _ _ i\n  letI := Module.compHom Q (algebraMap S T)\n  haveI : IsScalarTower S T Q :=\n    ⟨fun x y z => by\n      rw [Algebra.smul_def, mul_smul]\n      rfl⟩\n  have : IsScalarTower R S Q := by\n    refine ⟨fun x y z => ?_⟩\n    change (IsScalarTower.toAlgHom R S T) (x • y) • z = x • algebraMap S T y • z\n    rw [map_smul, smul_assoc]\n    rfl\n  refine\n    ⟨hg.lift (hf.lift i), by\n      ext\n      simp [IsBaseChange.lift_eq], ?_⟩\n  rintro g' (e : _ = _)\n  refine hg.algHom_ext' _ _ (hf.algHom_ext' _ _ ?_)\n  rw [IsBaseChange.lift_comp, IsBaseChange.lift_comp, ← e]\n  ext\n  rfl\n\n"}
{"name":"IsBaseChange.of_comp","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹⁹ : AddCommMonoid M\ninst✝¹⁸ : AddCommMonoid N\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : Algebra R S\ninst✝¹⁴ : Module R M\ninst✝¹³ : Module R N\ninst✝¹² : Module S N\ninst✝¹¹ : IsScalarTower R S N\nT : Type u_4\nO : Type u_5\ninst✝¹⁰ : CommSemiring T\ninst✝⁹ : Algebra R T\ninst✝⁸ : Algebra S T\ninst✝⁷ : IsScalarTower R S T\ninst✝⁶ : AddCommMonoid O\ninst✝⁵ : Module R O\ninst✝⁴ : Module S O\ninst✝³ : Module T O\ninst✝² : IsScalarTower S T O\ninst✝¹ : IsScalarTower R S O\ninst✝ : IsScalarTower R T O\nf : LinearMap (RingHom.id R) M N\nhf : IsBaseChange S f\nh : LinearMap (RingHom.id S) N O\nhc : IsBaseChange T ((↑R h).comp f)\n⊢ IsBaseChange T h","decl":"/-- If `N` is the base change of `M` to `S` and `O` the base change of `M` to `T`, then\n`O` is the base change of `N` to `T`. -/\nlemma IsBaseChange.of_comp {f : M →ₗ[R] N} (hf : IsBaseChange S f) {h : N →ₗ[S] O}\n    (hc : IsBaseChange T ((h : N →ₗ[R] O) ∘ₗ f)) :\n    IsBaseChange T h := by\n  apply IsBaseChange.of_lift_unique\n  intro Q _ _ _ _ r\n  letI : Module R Q := inferInstanceAs (Module R (RestrictScalars R S Q))\n  haveI : IsScalarTower R S Q := IsScalarTower.of_algebraMap_smul fun r ↦ congrFun rfl\n  haveI : IsScalarTower R T Q := IsScalarTower.of_algebraMap_smul fun r x ↦ by\n    simp [IsScalarTower.algebraMap_apply R S T]\n  let r' : M →ₗ[R] Q := r ∘ₗ f\n  let q : O →ₗ[T] Q := hc.lift r'\n  refine ⟨q, ?_, ?_⟩\n  · apply hf.algHom_ext'\n    simp [r', q, LinearMap.comp_assoc, hc.lift_comp]\n  · intro q' hq'\n    apply hc.algHom_ext'\n    apply_fun LinearMap.restrictScalars R at hq'\n    rw [← LinearMap.comp_assoc]\n    rw [show q'.restrictScalars R ∘ₗ h.restrictScalars R = _ from hq', hc.lift_comp]\n\n"}
{"name":"IsBaseChange.comp_iff","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nM : Type v₁\nN : Type v₂\nS : Type v₃\ninst✝¹⁹ : AddCommMonoid M\ninst✝¹⁸ : AddCommMonoid N\ninst✝¹⁷ : CommSemiring R\ninst✝¹⁶ : CommSemiring S\ninst✝¹⁵ : Algebra R S\ninst✝¹⁴ : Module R M\ninst✝¹³ : Module R N\ninst✝¹² : Module S N\ninst✝¹¹ : IsScalarTower R S N\nT : Type u_4\nO : Type u_5\ninst✝¹⁰ : CommSemiring T\ninst✝⁹ : Algebra R T\ninst✝⁸ : Algebra S T\ninst✝⁷ : IsScalarTower R S T\ninst✝⁶ : AddCommMonoid O\ninst✝⁵ : Module R O\ninst✝⁴ : Module S O\ninst✝³ : Module T O\ninst✝² : IsScalarTower S T O\ninst✝¹ : IsScalarTower R S O\ninst✝ : IsScalarTower R T O\nf : LinearMap (RingHom.id R) M N\nhf : IsBaseChange S f\nh : LinearMap (RingHom.id S) N O\n⊢ Iff (IsBaseChange T ((↑R h).comp f)) (IsBaseChange T h)","decl":"/-- If `N` is the base change `M` to `S`, then `O` is the base change of `M` to `T` if and\nonly if `O` is the base change of `N` to `T`. -/\nlemma IsBaseChange.comp_iff {f : M →ₗ[R] N} (hf : IsBaseChange S f) {h : N →ₗ[S] O} :\n    IsBaseChange T ((h : N →ₗ[R] O) ∘ₗ f) ↔ IsBaseChange T h :=\n  ⟨fun hc ↦ IsBaseChange.of_comp hf hc, fun hh ↦ IsBaseChange.comp hf hh⟩\n\n"}
{"name":"Algebra.IsPushout.out","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝⁷ : CommSemiring R'\ninst✝⁶ : CommSemiring S'\ninst✝⁵ : Algebra R R'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R' S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nself : Algebra.IsPushout R S R' S'\n⊢ IsBaseChange S (IsScalarTower.toAlgHom R R' S').toLinearMap","decl":"/-- A type-class stating that the following diagram of scalar towers\nR  →  S\n↓     ↓\nR' →  S'\nis a pushout diagram (i.e. `S' = S ⊗[R] R'`)\n-/\n@[mk_iff]\nclass Algebra.IsPushout : Prop where\n  out : IsBaseChange S (toAlgHom R R' S').toLinearMap\n\n"}
{"name":"Algebra.isPushout_iff","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝⁷ : CommSemiring R'\ninst✝⁶ : CommSemiring S'\ninst✝⁵ : Algebra R R'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R' S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\n⊢ Iff (Algebra.IsPushout R S R' S') (IsBaseChange S (IsScalarTower.toAlgHom R R' S').toLinearMap)","decl":"/-- A type-class stating that the following diagram of scalar towers\nR  →  S\n↓     ↓\nR' →  S'\nis a pushout diagram (i.e. `S' = S ⊗[R] R'`)\n-/\n@[mk_iff]\nclass Algebra.IsPushout : Prop where\n  out : IsBaseChange S (toAlgHom R R' S').toLinearMap\n\n"}
{"name":"Algebra.IsPushout.symm","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝⁷ : CommSemiring R'\ninst✝⁶ : CommSemiring S'\ninst✝⁵ : Algebra R R'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R' S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\nh : Algebra.IsPushout R S R' S'\n⊢ Algebra.IsPushout R R' S S'","decl":"@[symm]\ntheorem Algebra.IsPushout.symm (h : Algebra.IsPushout R S R' S') : Algebra.IsPushout R R' S S' := by\n  let _ := (Algebra.TensorProduct.includeRight : R' →ₐ[R] S ⊗ R').toRingHom.toAlgebra\n  let e : R' ⊗[R] S ≃ₗ[R'] S' := by\n    refine { (_root_.TensorProduct.comm R R' S).trans <|\n      h.1.equiv.restrictScalars R with map_smul' := ?_ }\n    intro r x\n    change\n      h.1.equiv (TensorProduct.comm R R' S (r • x)) = r • h.1.equiv (TensorProduct.comm R R' S x)\n    refine TensorProduct.induction_on x ?_ ?_ ?_\n    · simp only [smul_zero, map_zero]\n    · intro x y\n      simp only [smul_tmul', smul_eq_mul, TensorProduct.comm_tmul, smul_def,\n        TensorProduct.algebraMap_apply, id.map_eq_id, RingHom.id_apply, TensorProduct.tmul_mul_tmul,\n        one_mul, h.1.equiv_tmul, AlgHom.toLinearMap_apply, map_mul, IsScalarTower.coe_toAlgHom']\n      ring\n    · intro x y hx hy\n      rw [map_add, map_add, smul_add, map_add, map_add, hx, hy, smul_add]\n  have :\n    (toAlgHom R S S').toLinearMap =\n      (e.toLinearMap.restrictScalars R).comp (TensorProduct.mk R R' S 1) := by\n    ext\n    simp [e, h.1.equiv_tmul, Algebra.smul_def]\n  constructor\n  rw [this]\n  exact (TensorProduct.isBaseChange R S R').comp (IsBaseChange.ofEquiv e)\n\n"}
{"name":"Algebra.IsPushout.comm","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹⁰ : CommSemiring R\ninst✝⁹ : CommSemiring S\ninst✝⁸ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝⁷ : CommSemiring R'\ninst✝⁶ : CommSemiring S'\ninst✝⁵ : Algebra R R'\ninst✝⁴ : Algebra S S'\ninst✝³ : Algebra R' S'\ninst✝² : Algebra R S'\ninst✝¹ : IsScalarTower R R' S'\ninst✝ : IsScalarTower R S S'\n⊢ Iff (Algebra.IsPushout R S R' S') (Algebra.IsPushout R R' S S')","decl":"theorem Algebra.IsPushout.comm : Algebra.IsPushout R S R' S' ↔ Algebra.IsPushout R R' S S' :=\n  ⟨Algebra.IsPushout.symm, Algebra.IsPushout.symm⟩\n\n"}
{"name":"TensorProduct.isPushout","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\n⊢ Algebra.IsPushout R S T (TensorProduct R S T)","decl":"instance TensorProduct.isPushout {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]\n    [Algebra R S] [Algebra R T] : Algebra.IsPushout R S T (TensorProduct R S T) :=\n  ⟨TensorProduct.isBaseChange R T S⟩\n\n"}
{"name":"TensorProduct.isPushout'","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_8\nS : Type u_9\nT : Type u_10\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : CommRing T\ninst✝¹ : Algebra R S\ninst✝ : Algebra R T\n⊢ Algebra.IsPushout R T S (TensorProduct R S T)","decl":"instance TensorProduct.isPushout' {R S T : Type*} [CommRing R] [CommRing S] [CommRing T]\n    [Algebra R S] [Algebra R T] : Algebra.IsPushout R T S (TensorProduct R S T) :=\n  Algebra.IsPushout.symm inferInstance\n\n"}
{"name":"Algebra.pushoutDesc_apply","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝⁹ : CommSemiring R'\ninst✝⁸ : CommSemiring S'\ninst✝⁷ : Algebra R R'\ninst✝⁶ : Algebra S S'\ninst✝⁵ : Algebra R' S'\ninst✝⁴ : Algebra R S'\ninst✝³ : IsScalarTower R R' S'\ninst✝² : IsScalarTower R S S'\nH : Algebra.IsPushout R S R' S'\nA : Type u_8\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : AlgHom R S A\ng : AlgHom R R' A\nhf : ∀ (x : S) (y : R'), Eq (HMul.hMul (f x) (g y)) (HMul.hMul (g y) (f x))\na : S'\n⊢ Eq ((Algebra.pushoutDesc S' f g hf) a) ((⋯.lift g.toLinearMap) a)","decl":"/-- If `S' = S ⊗[R] R'`, then any pair of `R`-algebra homomorphisms `f : S → A` and `g : R' → A`\nsuch that `f x` and `g y` commutes for all `x, y` descends to a (unique) homomorphism `S' → A`.\n-/\n@[simps! (config := .lemmasOnly) apply]\nnoncomputable def Algebra.pushoutDesc [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S →ₐ[R] A) (g : R' →ₐ[R] A) (hf : ∀ x y, f x * g y = g y * f x) :\n    S' →ₐ[R] A := by\n  letI := Module.compHom A f.toRingHom\n  haveI : IsScalarTower R S A :=\n    { smul_assoc := fun r s a =>\n        show f (r • s) * a = r • (f s * a) by rw [map_smul, smul_mul_assoc] }\n  haveI : IsScalarTower S A A := { smul_assoc := fun r a b => mul_assoc _ _ _ }\n  have : ∀ x, H.out.lift g.toLinearMap (algebraMap R' S' x) = g x := H.out.lift_eq _\n  refine AlgHom.ofLinearMap ((H.out.lift g.toLinearMap).restrictScalars R) ?_ ?_\n  · dsimp only [LinearMap.restrictScalars_apply]\n    rw [← (algebraMap R' S').map_one, this, map_one]\n  · intro x y\n    refine H.out.inductionOn x _ ?_ ?_ ?_ ?_\n    · rw [zero_mul, map_zero, zero_mul]\n    rotate_left\n    · intro s s' e\n      dsimp only [LinearMap.restrictScalars_apply] at e ⊢\n      rw [LinearMap.map_smul, smul_mul_assoc, LinearMap.map_smul, e, smul_mul_assoc]\n    · intro s s' e₁ e₂\n      dsimp only [LinearMap.restrictScalars_apply] at e₁ e₂ ⊢\n      rw [add_mul, map_add, map_add, add_mul, e₁, e₂]\n    intro x\n    dsimp\n    rw [this]\n    refine H.out.inductionOn y _ ?_ ?_ ?_ ?_\n    · rw [mul_zero, map_zero, mul_zero]\n    · intro y\n      dsimp\n      rw [← map_mul, this, this, map_mul]\n    · intro s s' e\n      rw [mul_comm, smul_mul_assoc, LinearMap.map_smul, LinearMap.map_smul, mul_comm, e]\n      change f s * (g x * _) = g x * (f s * _)\n      rw [← mul_assoc, ← mul_assoc, hf]\n    · intro s s' e₁ e₂\n      rw [mul_add, map_add, map_add, mul_add, e₁, e₂]\n\n"}
{"name":"Algebra.pushoutDesc_left","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹³ : CommSemiring R\ninst✝¹² : CommSemiring S\ninst✝¹¹ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝¹⁰ : CommSemiring R'\ninst✝⁹ : CommSemiring S'\ninst✝⁸ : Algebra R R'\ninst✝⁷ : Algebra S S'\ninst✝⁶ : Algebra R' S'\ninst✝⁵ : Algebra R S'\ninst✝⁴ : IsScalarTower R R' S'\ninst✝³ : IsScalarTower R S S'\ninst✝² : Algebra.IsPushout R S R' S'\nA : Type u_8\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : AlgHom R S A\ng : AlgHom R R' A\nH : ∀ (x : S) (y : R'), Eq (HMul.hMul (f x) (g y)) (HMul.hMul (g y) (f x))\nx : S\n⊢ Eq ((Algebra.pushoutDesc S' f g H) ((algebraMap S S') x)) (f x)","decl":"@[simp]\ntheorem Algebra.pushoutDesc_left [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S →ₐ[R] A) (g : R' →ₐ[R] A) (H) (x : S) :\n    Algebra.pushoutDesc S' f g H (algebraMap S S' x) = f x := by\n  letI := Module.compHom A f.toRingHom\n  haveI : IsScalarTower R S A :=\n    { smul_assoc := fun r s a =>\n        show f (r • s) * a = r • (f s * a) by rw [map_smul, smul_mul_assoc] }\n  haveI : IsScalarTower S A A := { smul_assoc := fun r a b => mul_assoc _ _ _ }\n  rw [Algebra.algebraMap_eq_smul_one, pushoutDesc_apply, map_smul, ←\n    Algebra.pushoutDesc_apply S' f g H, map_one]\n  exact mul_one (f x)\n\n"}
{"name":"Algebra.lift_algHom_comp_left","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹³ : CommSemiring R\ninst✝¹² : CommSemiring S\ninst✝¹¹ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝¹⁰ : CommSemiring R'\ninst✝⁹ : CommSemiring S'\ninst✝⁸ : Algebra R R'\ninst✝⁷ : Algebra S S'\ninst✝⁶ : Algebra R' S'\ninst✝⁵ : Algebra R S'\ninst✝⁴ : IsScalarTower R R' S'\ninst✝³ : IsScalarTower R S S'\ninst✝² : Algebra.IsPushout R S R' S'\nA : Type u_8\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : AlgHom R S A\ng : AlgHom R R' A\nH : ∀ (x : S) (y : R'), Eq (HMul.hMul (f x) (g y)) (HMul.hMul (g y) (f x))\n⊢ Eq ((Algebra.pushoutDesc S' f g H).comp (IsScalarTower.toAlgHom R S S')) f","decl":"theorem Algebra.lift_algHom_comp_left [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S →ₐ[R] A) (g : R' →ₐ[R] A) (H) :\n    (Algebra.pushoutDesc S' f g H).comp (toAlgHom R S S') = f :=\n  AlgHom.ext fun x => (Algebra.pushoutDesc_left S' f g H x :)\n\n"}
{"name":"Algebra.pushoutDesc_right","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹³ : CommSemiring R\ninst✝¹² : CommSemiring S\ninst✝¹¹ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝¹⁰ : CommSemiring R'\ninst✝⁹ : CommSemiring S'\ninst✝⁸ : Algebra R R'\ninst✝⁷ : Algebra S S'\ninst✝⁶ : Algebra R' S'\ninst✝⁵ : Algebra R S'\ninst✝⁴ : IsScalarTower R R' S'\ninst✝³ : IsScalarTower R S S'\ninst✝² : Algebra.IsPushout R S R' S'\nA : Type u_8\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : AlgHom R S A\ng : AlgHom R R' A\nH : ∀ (x : S) (y : R'), Eq (HMul.hMul (f x) (g y)) (HMul.hMul (g y) (f x))\nx : R'\n⊢ Eq ((Algebra.pushoutDesc S' f g H) ((algebraMap R' S') x)) (g x)","decl":"@[simp]\ntheorem Algebra.pushoutDesc_right [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S →ₐ[R] A) (g : R' →ₐ[R] A) (H) (x : R') :\n    Algebra.pushoutDesc S' f g H (algebraMap R' S' x) = g x :=\n  letI := Module.compHom A f.toRingHom\n  haveI : IsScalarTower R S A :=\n    { smul_assoc := fun r s a =>\n        show f (r • s) * a = r • (f s * a) by rw [map_smul, smul_mul_assoc] }\n  IsBaseChange.lift_eq _ _ _\n\n"}
{"name":"Algebra.lift_algHom_comp_right","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹³ : CommSemiring R\ninst✝¹² : CommSemiring S\ninst✝¹¹ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝¹⁰ : CommSemiring R'\ninst✝⁹ : CommSemiring S'\ninst✝⁸ : Algebra R R'\ninst✝⁷ : Algebra S S'\ninst✝⁶ : Algebra R' S'\ninst✝⁵ : Algebra R S'\ninst✝⁴ : IsScalarTower R R' S'\ninst✝³ : IsScalarTower R S S'\ninst✝² : Algebra.IsPushout R S R' S'\nA : Type u_8\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf : AlgHom R S A\ng : AlgHom R R' A\nH : ∀ (x : S) (y : R'), Eq (HMul.hMul (f x) (g y)) (HMul.hMul (g y) (f x))\n⊢ Eq ((Algebra.pushoutDesc S' f g H).comp (IsScalarTower.toAlgHom R R' S')) g","decl":"theorem Algebra.lift_algHom_comp_right [Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] (f : S →ₐ[R] A) (g : R' →ₐ[R] A) (H) :\n    (Algebra.pushoutDesc S' f g H).comp (toAlgHom R R' S') = g :=\n  AlgHom.ext fun x => (Algebra.pushoutDesc_right S' f g H x :)\n\n"}
{"name":"Algebra.IsPushout.algHom_ext","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝¹² : CommSemiring R\ninst✝¹¹ : CommSemiring S\ninst✝¹⁰ : Algebra R S\nR' : Type u_6\nS' : Type u_7\ninst✝⁹ : CommSemiring R'\ninst✝⁸ : CommSemiring S'\ninst✝⁷ : Algebra R R'\ninst✝⁶ : Algebra S S'\ninst✝⁵ : Algebra R' S'\ninst✝⁴ : Algebra R S'\ninst✝³ : IsScalarTower R R' S'\ninst✝² : IsScalarTower R S S'\nH : Algebra.IsPushout R S R' S'\nA : Type u_8\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nf g : AlgHom R S' A\nh₁ : Eq (f.comp (IsScalarTower.toAlgHom R R' S')) (g.comp (IsScalarTower.toAlgHom R R' S'))\nh₂ : Eq (f.comp (IsScalarTower.toAlgHom R S S')) (g.comp (IsScalarTower.toAlgHom R S S'))\n⊢ Eq f g","decl":"@[ext (iff := false)]\ntheorem Algebra.IsPushout.algHom_ext [H : Algebra.IsPushout R S R' S'] {A : Type*} [Semiring A]\n    [Algebra R A] {f g : S' →ₐ[R] A} (h₁ : f.comp (toAlgHom R R' S') = g.comp (toAlgHom R R' S'))\n    (h₂ : f.comp (toAlgHom R S S') = g.comp (toAlgHom R S S')) : f = g := by\n  ext x\n  refine H.1.inductionOn x _ ?_ ?_ ?_ ?_\n  · simp only [map_zero]\n  · exact AlgHom.congr_fun h₁\n  · intro s s' e\n    rw [Algebra.smul_def, map_mul, map_mul, e]\n    congr 1\n    exact (AlgHom.congr_fun h₂ s :)\n  · intro s₁ s₂ e₁ e₂\n    rw [map_add, map_add, e₁, e₂]\n\n"}
{"name":"Algebra.IsPushout.comp_iff","module":"Mathlib.RingTheory.IsTensorProduct","initialProofState":"R : Type u_1\nS : Type v₃\ninst✝²⁷ : CommSemiring R\ninst✝²⁶ : CommSemiring S\ninst✝²⁵ : Algebra R S\nT : Type u_4\ninst✝²⁴ : CommSemiring T\ninst✝²³ : Algebra R T\ninst✝²² : Algebra S T\ninst✝²¹ : IsScalarTower R S T\nR' : Type u_6\nS' : Type u_7\ninst✝²⁰ : CommSemiring R'\ninst✝¹⁹ : CommSemiring S'\ninst✝¹⁸ : Algebra R R'\ninst✝¹⁷ : Algebra S S'\ninst✝¹⁶ : Algebra R' S'\ninst✝¹⁵ : Algebra R S'\ninst✝¹⁴ : IsScalarTower R R' S'\ninst✝¹³ : IsScalarTower R S S'\nT' : Type u_8\ninst✝¹² : CommRing T'\ninst✝¹¹ : Algebra R T'\ninst✝¹⁰ : Algebra S' T'\ninst✝⁹ : Algebra S T'\ninst✝⁸ : Algebra T T'\ninst✝⁷ : Algebra R' T'\ninst✝⁶ : IsScalarTower R T T'\ninst✝⁵ : IsScalarTower S T T'\ninst✝⁴ : IsScalarTower S S' T'\ninst✝³ : IsScalarTower R R' T'\ninst✝² : IsScalarTower R S' T'\ninst✝¹ : IsScalarTower R' S' T'\ninst✝ : Algebra.IsPushout R S R' S'\n⊢ Iff (Algebra.IsPushout R T R' T') (Algebra.IsPushout S T S' T')","decl":"/--\nLet the following be a commutative diagram of rings\n```\n  R  →  S  →  T\n  ↓     ↓     ↓\n  R' →  S' →  T'\n```\nwhere the left-hand square is a pushout. Then the following are equivalent:\n- the big rectangle is a pushout.\n- the right-hand square is a pushout.\n\nNote that this is essentially the isomorphism `T ⊗[S] (S ⊗[R] R') ≃ₐ[T] T ⊗[R] R'`.\n-/\nlemma Algebra.IsPushout.comp_iff {T' : Type*} [CommRing T'] [Algebra R T']\n    [Algebra S' T'] [Algebra S T'] [Algebra T T'] [Algebra R' T']\n    [IsScalarTower R T T'] [IsScalarTower S T T'] [IsScalarTower S S' T']\n    [IsScalarTower R R' T'] [IsScalarTower R S' T'] [IsScalarTower R' S' T']\n    [Algebra.IsPushout R S R' S'] :\n    Algebra.IsPushout R T R' T' ↔ Algebra.IsPushout S T S' T' := by\n  let f : R' →ₗ[R] S' := (IsScalarTower.toAlgHom R R' S').toLinearMap\n  haveI : IsScalarTower R S T' := IsScalarTower.of_algebraMap_eq <| fun x ↦ by\n    rw [algebraMap_apply R S' T', algebraMap_apply R S S', ← algebraMap_apply S S' T']\n  have heq : (toAlgHom S S' T').toLinearMap.restrictScalars R ∘ₗ f =\n      (toAlgHom R R' T').toLinearMap := by\n    ext x\n    simp [f, ← IsScalarTower.algebraMap_apply]\n  rw [isPushout_iff, isPushout_iff, ← heq, IsBaseChange.comp_iff]\n  exact Algebra.IsPushout.out\n\n"}
