{"name":"CategoryTheory.Limits.hasPullbackHorizPaste","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\n⊢ CategoryTheory.Limits.HasPullback (CategoryTheory.CategoryStruct.comp f' f) g","decl":"instance hasPullbackHorizPaste : HasPullback (f' ≫ f) g :=\n  HasLimit.mk {\n    cone := (pullback.cone f g).pasteHoriz (pullback.cone f' (pullback.fst f g)) rfl\n    isLimit := pasteHorizIsPullback rfl (pullback.isLimit f g)\n      (pullback.isLimit f' (pullback.fst f g))\n  }\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').hom (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f' f) g)) (CategoryTheory.Limits.pullback.fst f' (CategoryTheory.Limits.pullback.fst f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_hom_fst :\n    (pullbackRightPullbackFstIso f g f').hom ≫ pullback.fst (f' ≫ f) g =\n      pullback.fst f' (pullback.fst f g) :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f' f) g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f' (CategoryTheory.Limits.pullback.fst f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_hom_fst :\n    (pullbackRightPullbackFstIso f g f').hom ≫ pullback.fst (f' ≫ f) g =\n      pullback.fst f' (pullback.fst f g) :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').hom (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f' f) g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f' (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_hom_snd :\n    (pullbackRightPullbackFstIso f g f').hom ≫ pullback.snd _ _ =\n      pullback.snd f' (pullback.fst f g) ≫ pullback.snd f g :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f' f) g) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f' (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_hom_snd :\n    (pullbackRightPullbackFstIso f g f').hom ≫ pullback.snd _ _ =\n      pullback.snd f' (pullback.fst f g) ≫ pullback.snd f g :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').inv (CategoryTheory.Limits.pullback.fst f' (CategoryTheory.Limits.pullback.fst f g))) (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f' f) g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_fst :\n    (pullbackRightPullbackFstIso f g f').inv ≫ pullback.fst f' (pullback.fst f g) =\n      pullback.fst (f' ≫ f) g :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f' (CategoryTheory.Limits.pullback.fst f g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f' f) g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_fst :\n    (pullbackRightPullbackFstIso f g f').inv ≫ pullback.fst f' (pullback.fst f g) =\n      pullback.fst (f' ≫ f) g :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f' (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.snd f g))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f' f) g)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_snd_snd :\n    (pullbackRightPullbackFstIso f g f').inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f' (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.CategoryStruct.comp f' f) g) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_snd_snd :\n    (pullbackRightPullbackFstIso f g f').inv ≫ pullback.snd _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f' (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.Limits.pullback.fst f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f' f) g) f')","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_snd_fst :\n    (pullbackRightPullbackFstIso f g f').inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ f' := by\n  rw [← pullback.condition]\n  exact pullbackRightPullbackFstIso_inv_fst_assoc f g f' _\n\n"}
{"name":"CategoryTheory.Limits.pullbackRightPullbackFstIso_inv_snd_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\nf' : Quiver.Hom W X\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback f' (CategoryTheory.Limits.pullback.fst f g)\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackRightPullbackFstIso f g f').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f' (CategoryTheory.Limits.pullback.fst f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.CategoryStruct.comp f' f) g) (CategoryTheory.CategoryStruct.comp f' h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackRightPullbackFstIso_inv_snd_fst :\n    (pullbackRightPullbackFstIso f g f').inv ≫ pullback.snd _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ f' := by\n  rw [← pullback.condition]\n  exact pullbackRightPullbackFstIso_inv_fst_assoc f g f' _\n\n"}
{"name":"CategoryTheory.Limits.hasPullbackVertPaste","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\n⊢ CategoryTheory.Limits.HasPullback f (CategoryTheory.CategoryStruct.comp g' g)","decl":"instance hasPullbackVertPaste : HasPullback f (g' ≫ g) :=\n  HasLimit.mk {\n    cone := (pullback.cone f g).pasteVert (pullback.cone (pullback.snd f g) g') rfl\n    isLimit := pasteVertIsPullback rfl (pullback.isLimit f g)\n      (pullback.isLimit (pullback.snd f g) g')\n  }\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_hom_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f (CategoryTheory.CategoryStruct.comp g' g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f g) g') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_hom_fst :\n    (pullbackLeftPullbackSndIso f g g').hom ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_hom_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').hom (CategoryTheory.Limits.pullback.fst f (CategoryTheory.CategoryStruct.comp g' g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f g) g') (CategoryTheory.Limits.pullback.fst f g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_hom_fst :\n    (pullbackLeftPullbackSndIso f g g').hom ≫ pullback.fst _ _ =\n      pullback.fst _ _ ≫ pullback.fst _ _ :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_hom_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').hom (CategoryTheory.Limits.pullback.snd f (CategoryTheory.CategoryStruct.comp g' g))) (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.snd f g) g')","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_hom_snd :\n    (pullbackLeftPullbackSndIso f g g').hom ≫ pullback.snd _ _ = pullback.snd _ _ :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_hom_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (CategoryTheory.CategoryStruct.comp g' g)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.snd f g) g') h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_hom_snd :\n    (pullbackLeftPullbackSndIso f g g').hom ≫ pullback.snd _ _ = pullback.snd _ _ :=\n  IsLimit.conePointUniqueUpToIso_hom_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_inv_fst","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f g) g') (CategoryTheory.Limits.pullback.fst f g))) (CategoryTheory.Limits.pullback.fst f (CategoryTheory.CategoryStruct.comp g' g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_inv_fst :\n    (pullbackLeftPullbackSndIso f g g').inv ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_inv_fst_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\nZ : C\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f g) g') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst f (CategoryTheory.CategoryStruct.comp g' g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_inv_fst :\n    (pullbackLeftPullbackSndIso f g g').inv ≫ pullback.fst _ _ ≫ pullback.fst _ _ =\n      pullback.fst _ _ :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.left\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_inv_snd_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').inv (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.snd f g) g')) (CategoryTheory.Limits.pullback.snd f (CategoryTheory.CategoryStruct.comp g' g))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_inv_snd_snd :\n    (pullbackLeftPullbackSndIso f g g').inv ≫ pullback.snd _ _ = pullback.snd _ _ :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_inv_snd_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\nZ : C\nh : Quiver.Hom W Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd (CategoryTheory.Limits.pullback.snd f g) g') h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (CategoryTheory.CategoryStruct.comp g' g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_inv_snd_snd :\n    (pullbackLeftPullbackSndIso f g g').inv ≫ pullback.snd _ _ = pullback.snd _ _ :=\n  IsLimit.conePointUniqueUpToIso_inv_comp _ _ WalkingCospan.right\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_inv_fst_snd","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Z\ng : Quiver.Hom Y Z\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f g) g') (CategoryTheory.Limits.pullback.snd f g))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (CategoryTheory.CategoryStruct.comp g' g)) g')","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_inv_fst_snd :\n    (pullbackLeftPullbackSndIso f g g').inv ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ g' := by\n  rw [pullback.condition]\n  exact pullbackLeftPullbackSndIso_inv_snd_snd_assoc f g g' g'\n\n"}
{"name":"CategoryTheory.Limits.pullbackLeftPullbackSndIso_inv_fst_snd_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Z✝\ng : Quiver.Hom Y Z✝\ng' : Quiver.Hom W Y\ninst✝¹ : CategoryTheory.Limits.HasPullback f g\ninst✝ : CategoryTheory.Limits.HasPullback (CategoryTheory.Limits.pullback.snd f g) g'\nZ : C\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullbackLeftPullbackSndIso f g g').inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.fst (CategoryTheory.Limits.pullback.snd f g) g') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f g) h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pullback.snd f (CategoryTheory.CategoryStruct.comp g' g)) (CategoryTheory.CategoryStruct.comp g' h))","decl":"@[reassoc (attr := simp)]\ntheorem pullbackLeftPullbackSndIso_inv_fst_snd :\n    (pullbackLeftPullbackSndIso f g g').inv ≫ pullback.fst _ _ ≫ pullback.snd _ _ =\n      pullback.snd _ _ ≫ g' := by\n  rw [pullback.condition]\n  exact pullbackLeftPullbackSndIso_inv_snd_snd_assoc f g g' g'\n\n"}
{"name":"CategoryTheory.Limits.instHasPushoutComp","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng' : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\n⊢ CategoryTheory.Limits.HasPushout f (CategoryTheory.CategoryStruct.comp g g')","decl":"instance : HasPushout f (g ≫ g') :=\n  HasColimit.mk {\n    cocone := (pushout.cocone f g).pasteHoriz (pushout.cocone (pushout.inr f g) g') rfl\n    isColimit := pasteHorizIsPushout rfl (pushout.isColimit f g)\n      (pushout.isColimit (pushout.inr f g) g')\n  }\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutLeftPushoutInrIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ng' : Quiver.Hom Z✝ W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.Limits.pushout.inr f g) g') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.pushout.inr f g) g') h))","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutLeftPushoutInrIso_inv :\n    (pushout.inl f (g ≫ g')) ≫ (pushoutLeftPushoutInrIso f g g').inv =\n      (pushout.inl f g) ≫ (pushout.inl (pushout.inr f g) g') :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutLeftPushoutInrIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng' : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.pushout.inr f g) g'))","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutLeftPushoutInrIso_inv :\n    (pushout.inl f (g ≫ g')) ≫ (pushoutLeftPushoutInrIso f g g').inv =\n      (pushout.inl f g) ≫ (pushout.inl (pushout.inr f g) g') :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng' : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.pushout.inr f g) g') (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').hom) (CategoryTheory.Limits.pushout.inr f (CategoryTheory.CategoryStruct.comp g g'))","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutLeftPushoutInrIso_hom :\n    (pushout.inr (pushout.inr f g) g') ≫ (pushoutLeftPushoutInrIso f g g').hom =\n      (pushout.inr f (g ≫ g')) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (pasteHorizIsPushout _ _ _) _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ng' : Quiver.Hom Z✝ W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f (CategoryTheory.CategoryStruct.comp g g')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.pushout.inr f g) g') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f (CategoryTheory.CategoryStruct.comp g g')) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutLeftPushoutInrIso_hom :\n    (pushout.inr (pushout.inr f g) g') ≫ (pushoutLeftPushoutInrIso f g g').hom =\n      (pushout.inr f (g ≫ g')) :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (pasteHorizIsPushout _ _ _) _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng' : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').inv) (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.pushout.inr f g) g')","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutLeftPushoutInrIso_inv :\n    (pushout.inr f (g ≫ g')) ≫ (pushoutLeftPushoutInrIso f g g').inv =\n      (pushout.inr (pushout.inr f g) g') :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutLeftPushoutInrIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ng' : Quiver.Hom Z✝ W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.Limits.pushout.inr f g) g') Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f (CategoryTheory.CategoryStruct.comp g g')) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.Limits.pushout.inr f g) g') h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutLeftPushoutInrIso_inv :\n    (pushout.inr f (g ≫ g')) ≫ (pushoutLeftPushoutInrIso f g g').inv =\n      (pushout.inr (pushout.inr f g) g') :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inl_inl_pushoutLeftPushoutInrIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ng' : Quiver.Hom Z✝ W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f (CategoryTheory.CategoryStruct.comp g g')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.pushout.inr f g) g') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f (CategoryTheory.CategoryStruct.comp g g')) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_inl_pushoutLeftPushoutInrIso_hom :\n    (pushout.inl f g) ≫ (pushout.inl (pushout.inr f g) g') ≫\n      (pushoutLeftPushoutInrIso f g g').hom = (pushout.inl f (g ≫ g')) := by\n  rw [← Category.assoc]\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom (pasteHorizIsPushout _ _ _) _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inl_inl_pushoutLeftPushoutInrIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng' : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.pushout.inr f g) g') (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').hom)) (CategoryTheory.Limits.pushout.inl f (CategoryTheory.CategoryStruct.comp g g'))","decl":"@[reassoc (attr := simp)]\ntheorem inl_inl_pushoutLeftPushoutInrIso_hom :\n    (pushout.inl f g) ≫ (pushout.inl (pushout.inr f g) g') ≫\n      (pushoutLeftPushoutInrIso f g g').hom = (pushout.inl f (g ≫ g')) := by\n  rw [← Category.assoc]\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom (pasteHorizIsPushout _ _ _) _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inr_inl_pushoutLeftPushoutInrIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\ng' : Quiver.Hom Z✝ W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f (CategoryTheory.CategoryStruct.comp g g')) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.pushout.inr f g) g') (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').hom h))) (CategoryTheory.CategoryStruct.comp g' (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f (CategoryTheory.CategoryStruct.comp g g')) h))","decl":"@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutLeftPushoutInrIso_hom :\n    pushout.inr f g ≫ pushout.inl (pushout.inr f g) g' ≫ (pushoutLeftPushoutInrIso f g g').hom =\n      g' ≫ pushout.inr f (g ≫ g') := by\n  rw [← Category.assoc, ← Iso.eq_comp_inv, Category.assoc, inr_pushoutLeftPushoutInrIso_inv,\n    pushout.condition]\n\n"}
{"name":"CategoryTheory.Limits.inr_inl_pushoutLeftPushoutInrIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\ng' : Quiver.Hom Z W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout (CategoryTheory.Limits.pushout.inr f g) g'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.Limits.pushout.inr f g) g') (CategoryTheory.Limits.pushoutLeftPushoutInrIso f g g').hom)) (CategoryTheory.CategoryStruct.comp g' (CategoryTheory.Limits.pushout.inr f (CategoryTheory.CategoryStruct.comp g g')))","decl":"@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutLeftPushoutInrIso_hom :\n    pushout.inr f g ≫ pushout.inl (pushout.inr f g) g' ≫ (pushoutLeftPushoutInrIso f g g').hom =\n      g' ≫ pushout.inr f (g ≫ g') := by\n  rw [← Category.assoc, ← Iso.eq_comp_inv, Category.assoc, inr_pushoutLeftPushoutInrIso_inv,\n    pushout.condition]\n\n"}
{"name":"CategoryTheory.Limits.hasPushoutVertPaste","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\n⊢ CategoryTheory.Limits.HasPushout (CategoryTheory.CategoryStruct.comp f f') g","decl":"instance hasPushoutVertPaste : HasPushout (f ≫ f') g :=\n  HasColimit.mk {\n    cocone := (pushout.cocone f g).pasteVert (pushout.cocone f' (pushout.inl f g)) rfl\n    isColimit := pasteVertIsPushout rfl (pushout.isColimit f g)\n      (pushout.isColimit f' (pushout.inl f g))\n  }\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutRightPushoutInlIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f' (CategoryTheory.Limits.pushout.inl f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp f f') g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f' (CategoryTheory.Limits.pushout.inl f g)) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutRightPushoutInlIso_inv :\n    pushout.inl _ _ ≫ (pushoutRightPushoutInlIso f g f').inv = pushout.inl _ _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutRightPushoutInlIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp f f') g) (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').inv) (CategoryTheory.Limits.pushout.inl f' (CategoryTheory.Limits.pushout.inl f g))","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutRightPushoutInlIso_inv :\n    pushout.inl _ _ ≫ (pushoutRightPushoutInlIso f g f').inv = pushout.inl _ _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inr_inr_pushoutRightPushoutInlIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f' (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').hom)) (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp f f') g)","decl":"@[reassoc (attr := simp)]\ntheorem inr_inr_pushoutRightPushoutInlIso_hom :\n    pushout.inr _ _ ≫ pushout.inr _ _ ≫ (pushoutRightPushoutInlIso f g f').hom =\n      pushout.inr _ _ := by\n  rw [← Category.assoc]\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom (pasteVertIsPushout rfl _ _) _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inr_inr_pushoutRightPushoutInlIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.CategoryStruct.comp f f') g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f' (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').hom h))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp f f') g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inr_inr_pushoutRightPushoutInlIso_hom :\n    pushout.inr _ _ ≫ pushout.inr _ _ ≫ (pushoutRightPushoutInlIso f g f').hom =\n      pushout.inr _ _ := by\n  rw [← Category.assoc]\n  apply IsColimit.comp_coconePointUniqueUpToIso_hom (pasteVertIsPushout rfl _ _) _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutRightPushoutInlIso_inv_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout f' (CategoryTheory.Limits.pushout.inl f g)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp f f') g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f' (CategoryTheory.Limits.pushout.inl f g)) h))","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutRightPushoutInlIso_inv :\n    pushout.inr _ _ ≫ (pushoutRightPushoutInlIso f g f').inv =\n      pushout.inr _ _ ≫ pushout.inr _ _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inr_pushoutRightPushoutInlIso_inv","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr (CategoryTheory.CategoryStruct.comp f f') g) (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').inv) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f g) (CategoryTheory.Limits.pushout.inr f' (CategoryTheory.Limits.pushout.inl f g)))","decl":"@[reassoc (attr := simp)]\ntheorem inr_pushoutRightPushoutInlIso_inv :\n    pushout.inr _ _ ≫ (pushoutRightPushoutInlIso f g f').inv =\n      pushout.inr _ _ ≫ pushout.inr _ _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_inv _ _ WalkingSpan.right\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutRightPushoutInlIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.CategoryStruct.comp f f') g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f' (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp f f') g) h)","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutRightPushoutInlIso_hom :\n    pushout.inl _ _ ≫ (pushoutRightPushoutInlIso f g f').hom = pushout.inl _ _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (pasteVertIsPushout rfl _ _) _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inl_pushoutRightPushoutInlIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f' (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').hom) (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp f f') g)","decl":"@[reassoc (attr := simp)]\ntheorem inl_pushoutRightPushoutInlIso_hom :\n    pushout.inl _ _ ≫ (pushoutRightPushoutInlIso f g f').hom = pushout.inl _ _ :=\n  IsColimit.comp_coconePointUniqueUpToIso_hom (pasteVertIsPushout rfl _ _) _ WalkingSpan.left\n\n"}
{"name":"CategoryTheory.Limits.inr_inl_pushoutRightPushoutInlIso_hom","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f' (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').hom)) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp f f') g))","decl":"@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutRightPushoutInlIso_hom :\n    pushout.inl _ _ ≫ pushout.inr _ _ ≫ (pushoutRightPushoutInlIso f g f').hom =\n      f' ≫ pushout.inl _ _ := by\n  rw [← Category.assoc, ← pushout.condition, Category.assoc, inl_pushoutRightPushoutInlIso_hom]\n\n"}
{"name":"CategoryTheory.Limits.inr_inl_pushoutRightPushoutInlIso_hom_assoc","module":"Mathlib.CategoryTheory.Limits.Shapes.Pullback.Pasting","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nW X Y Z✝ : C\nf : Quiver.Hom X Y\ng : Quiver.Hom X Z✝\nf' : Quiver.Hom Y W\ninst✝¹ : CategoryTheory.Limits.HasPushout f g\ninst✝ : CategoryTheory.Limits.HasPushout f' (CategoryTheory.Limits.pushout.inl f g)\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.pushout (CategoryTheory.CategoryStruct.comp f f') g) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl f g) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inr f' (CategoryTheory.Limits.pushout.inl f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushoutRightPushoutInlIso f g f').hom h))) (CategoryTheory.CategoryStruct.comp f' (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.pushout.inl (CategoryTheory.CategoryStruct.comp f f') g) h))","decl":"@[reassoc (attr := simp)]\ntheorem inr_inl_pushoutRightPushoutInlIso_hom :\n    pushout.inl _ _ ≫ pushout.inr _ _ ≫ (pushoutRightPushoutInlIso f g f').hom =\n      f' ≫ pushout.inl _ _ := by\n  rw [← Category.assoc, ← pushout.condition, Category.assoc, inl_pushoutRightPushoutInlIso_hom]\n\n"}
