{"name":"Homeomorph.mk.sizeOf_spec","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : SizeOf X\ninst‚úù : SizeOf Y\ntoEquiv : Equiv X Y\ncontinuous_toFun : autoParam (Continuous toEquiv.toFun) _auto‚úù\ncontinuous_invFun : autoParam (Continuous toEquiv.invFun) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { toEquiv := toEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf toEquiv)) (SizeOf.sizeOf continuous_toFun)) (SizeOf.sizeOf continuous_invFun))","decl":"/-- Homeomorphism between `X` and `Y`, also called topological isomorphism -/\nstructure Homeomorph (X : Type*) (Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]\n    extends X ‚âÉ Y where\n  /-- The forward map of a homeomorphism is a continuous function. -/\n  continuous_toFun : Continuous toFun := by continuity\n  /-- The inverse map of a homeomorphism is a continuous function. -/\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"Homeomorph.continuous_invFun","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nself : Homeomorph X Y\n‚ä¢ Continuous self.invFun","decl":"/-- Homeomorphism between `X` and `Y`, also called topological isomorphism -/\nstructure Homeomorph (X : Type*) (Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]\n    extends X ‚âÉ Y where\n  /-- The forward map of a homeomorphism is a continuous function. -/\n  continuous_toFun : Continuous toFun := by continuity\n  /-- The inverse map of a homeomorphism is a continuous function. -/\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"Homeomorph.continuous_toFun","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nself : Homeomorph X Y\n‚ä¢ Continuous self.toFun","decl":"/-- Homeomorphism between `X` and `Y`, also called topological isomorphism -/\nstructure Homeomorph (X : Type*) (Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]\n    extends X ‚âÉ Y where\n  /-- The forward map of a homeomorphism is a continuous function. -/\n  continuous_toFun : Continuous toFun := by continuity\n  /-- The inverse map of a homeomorphism is a continuous function. -/\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"Homeomorph.mk.injEq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ntoEquiv‚úù : Equiv X Y\ncontinuous_toFun‚úù : autoParam (Continuous toEquiv‚úù.toFun) _auto‚úù\ncontinuous_invFun‚úù : autoParam (Continuous toEquiv‚úù.invFun) _auto‚úù\ntoEquiv : Equiv X Y\ncontinuous_toFun : autoParam (Continuous toEquiv.toFun) _auto‚úù\ncontinuous_invFun : autoParam (Continuous toEquiv.invFun) _auto‚úù\n‚ä¢ Eq (Eq { toEquiv := toEquiv‚úù, continuous_toFun := continuous_toFun‚úù, continuous_invFun := continuous_invFun‚úù } { toEquiv := toEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }) (Eq toEquiv‚úù toEquiv)","decl":"/-- Homeomorphism between `X` and `Y`, also called topological isomorphism -/\nstructure Homeomorph (X : Type*) (Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]\n    extends X ‚âÉ Y where\n  /-- The forward map of a homeomorphism is a continuous function. -/\n  continuous_toFun : Continuous toFun := by continuity\n  /-- The inverse map of a homeomorphism is a continuous function. -/\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"Homeomorph.mk.inj","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_5\nY : Type u_6\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ntoEquiv‚úù : Equiv X Y\ncontinuous_toFun‚úù : autoParam (Continuous toEquiv‚úù.toFun) _auto‚úù\ncontinuous_invFun‚úù : autoParam (Continuous toEquiv‚úù.invFun) _auto‚úù\ntoEquiv : Equiv X Y\ncontinuous_toFun : autoParam (Continuous toEquiv.toFun) _auto‚úù\ncontinuous_invFun : autoParam (Continuous toEquiv.invFun) _auto‚úù\nx‚úù : Eq { toEquiv := toEquiv‚úù, continuous_toFun := continuous_toFun‚úù, continuous_invFun := continuous_invFun‚úù } { toEquiv := toEquiv, continuous_toFun := continuous_toFun, continuous_invFun := continuous_invFun }\n‚ä¢ Eq toEquiv‚úù toEquiv","decl":"/-- Homeomorphism between `X` and `Y`, also called topological isomorphism -/\nstructure Homeomorph (X : Type*) (Y : Type*) [TopologicalSpace X] [TopologicalSpace Y]\n    extends X ‚âÉ Y where\n  /-- The forward map of a homeomorphism is a continuous function. -/\n  continuous_toFun : Continuous toFun := by continuity\n  /-- The inverse map of a homeomorphism is a continuous function. -/\n  continuous_invFun : Continuous invFun := by continuity\n\n"}
{"name":"Homeomorph.toEquiv_injective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Function.Injective Homeomorph.toEquiv","decl":"theorem toEquiv_injective : Function.Injective (toEquiv : X ‚âÉ‚Çú Y ‚Üí X ‚âÉ Y)\n  | ‚ü®_, _, _‚ü©, ‚ü®_, _, _‚ü©, rfl => rfl\n\n"}
{"name":"Homeomorph.homeomorph_mk_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\na : Equiv X Y\nb : Continuous a.toFun\nc : Continuous a.invFun\n‚ä¢ Eq ‚áë{ toEquiv := a, continuous_toFun := b, continuous_invFun := c } ‚áëa","decl":"@[simp] theorem homeomorph_mk_coe (a : X ‚âÉ Y) (b c) : (Homeomorph.mk a b c : X ‚Üí Y) = a :=\n  rfl\n\n"}
{"name":"Homeomorph.symm_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq h.symm.symm h","decl":"@[simp] theorem symm_symm (h : X ‚âÉ‚Çú Y) : h.symm.symm = h := rfl\n\n"}
{"name":"Homeomorph.symm_bijective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Function.Bijective Homeomorph.symm","decl":"theorem symm_bijective : Function.Bijective (Homeomorph.symm : (X ‚âÉ‚Çú Y) ‚Üí Y ‚âÉ‚Çú X) :=\n  Function.bijective_iff_has_inverse.mpr ‚ü®_, symm_symm, symm_symm‚ü©\n\n"}
{"name":"Homeomorph.coe_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq ‚áëh.toEquiv ‚áëh","decl":"@[simp]\ntheorem coe_toEquiv (h : X ‚âÉ‚Çú Y) : ‚áëh.toEquiv = h :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_symm_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq ‚áëh.symm ‚áëh.symm","decl":"@[simp]\ntheorem coe_symm_toEquiv (h : X ‚âÉ‚Çú Y) : ‚áëh.toEquiv.symm = h.symm :=\n  rfl\n\n"}
{"name":"Homeomorph.ext","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh h' : Homeomorph X Y\nH : ‚àÄ (x : X), Eq (h x) (h' x)\n‚ä¢ Eq h h'","decl":"@[ext]\ntheorem ext {h h' : X ‚âÉ‚Çú Y} (H : ‚àÄ x, h x = h' x) : h = h' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"Homeomorph.ext_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh h' : Homeomorph X Y\n‚ä¢ Iff (Eq h h') (‚àÄ (x : X), Eq (h x) (h' x))","decl":"@[ext]\ntheorem ext {h h' : X ‚âÉ‚Çú Y} (H : ‚àÄ x, h x = h' x) : h = h' :=\n  DFunLike.ext _ _ H\n\n"}
{"name":"Homeomorph.refl_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_7\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (‚áë(Homeomorph.refl X)) id","decl":"/-- Identity map as a homeomorphism. -/\n@[simps! (config := .asFn) apply]\nprotected def refl (X : Type*) [TopologicalSpace X] : X ‚âÉ‚Çú X where\n  continuous_toFun := continuous_id\n  continuous_invFun := continuous_id\n  toEquiv := Equiv.refl X\n\n"}
{"name":"Homeomorph.trans_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh‚ÇÅ : Homeomorph X Y\nh‚ÇÇ : Homeomorph Y Z\nx : X\n‚ä¢ Eq ((h‚ÇÅ.trans h‚ÇÇ) x) (h‚ÇÇ (h‚ÇÅ x))","decl":"@[simp]\ntheorem trans_apply (h‚ÇÅ : X ‚âÉ‚Çú Y) (h‚ÇÇ : Y ‚âÉ‚Çú Z) (x : X) : h‚ÇÅ.trans h‚ÇÇ x = h‚ÇÇ (h‚ÇÅ x) :=\n  rfl\n\n"}
{"name":"Homeomorph.symm_trans_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : Homeomorph X Y\ng : Homeomorph Y Z\nz : Z\n‚ä¢ Eq ((f.trans g).symm z) (f.symm (g.symm z))","decl":"@[simp]\ntheorem symm_trans_apply (f : X ‚âÉ‚Çú Y) (g : Y ‚âÉ‚Çú Z) (z : Z) :\n    (f.trans g).symm z = f.symm (g.symm z) := rfl\n\n"}
{"name":"Homeomorph.homeomorph_mk_coe_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\na : Equiv X Y\nb : Continuous a.toFun\nc : Continuous a.invFun\n‚ä¢ Eq ‚áë{ toEquiv := a, continuous_toFun := b, continuous_invFun := c }.symm ‚áëa.symm","decl":"@[simp]\ntheorem homeomorph_mk_coe_symm (a : X ‚âÉ Y) (b c) :\n    ((Homeomorph.mk a b c).symm : Y ‚Üí X) = a.symm :=\n  rfl\n\n"}
{"name":"Homeomorph.refl_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (Homeomorph.refl X).symm (Homeomorph.refl X)","decl":"@[simp]\ntheorem refl_symm : (Homeomorph.refl X).symm = Homeomorph.refl X :=\n  rfl\n\n"}
{"name":"Homeomorph.continuous","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Continuous ‚áëh","decl":"@[continuity, fun_prop]\nprotected theorem continuous (h : X ‚âÉ‚Çú Y) : Continuous h :=\n  h.continuous_toFun\n\n-- otherwise `by continuity` can't prove continuity of `h.to_equiv.symm`\n"}
{"name":"Homeomorph.continuous_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Continuous ‚áëh.symm","decl":"@[continuity]\nprotected theorem continuous_symm (h : X ‚âÉ‚Çú Y) : Continuous h.symm :=\n  h.continuous_invFun\n\n"}
{"name":"Homeomorph.apply_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ny : Y\n‚ä¢ Eq (h (h.symm y)) y","decl":"@[simp]\ntheorem apply_symm_apply (h : X ‚âÉ‚Çú Y) (y : Y) : h (h.symm y) = y :=\n  h.toEquiv.apply_symm_apply y\n\n"}
{"name":"Homeomorph.symm_apply_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\nx : X\n‚ä¢ Eq (h.symm (h x)) x","decl":"@[simp]\ntheorem symm_apply_apply (h : X ‚âÉ‚Çú Y) (x : X) : h.symm (h x) = x :=\n  h.toEquiv.symm_apply_apply x\n\n"}
{"name":"Homeomorph.self_trans_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (h.trans h.symm) (Homeomorph.refl X)","decl":"@[simp]\ntheorem self_trans_symm (h : X ‚âÉ‚Çú Y) : h.trans h.symm = Homeomorph.refl X := by\n  ext\n  apply symm_apply_apply\n\n"}
{"name":"Homeomorph.symm_trans_self","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (h.symm.trans h) (Homeomorph.refl Y)","decl":"@[simp]\ntheorem symm_trans_self (h : X ‚âÉ‚Çú Y) : h.symm.trans h = Homeomorph.refl Y := by\n  ext\n  apply apply_symm_apply\n\n"}
{"name":"Homeomorph.bijective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Function.Bijective ‚áëh","decl":"protected theorem bijective (h : X ‚âÉ‚Çú Y) : Function.Bijective h :=\n  h.toEquiv.bijective\n\n"}
{"name":"Homeomorph.injective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Function.Injective ‚áëh","decl":"protected theorem injective (h : X ‚âÉ‚Çú Y) : Function.Injective h :=\n  h.toEquiv.injective\n\n"}
{"name":"Homeomorph.surjective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Function.Surjective ‚áëh","decl":"protected theorem surjective (h : X ‚âÉ‚Çú Y) : Function.Surjective h :=\n  h.toEquiv.surjective\n\n"}
{"name":"Homeomorph.symm_comp_self","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Function.comp ‚áëh.symm ‚áëh) id","decl":"@[simp]\ntheorem symm_comp_self (h : X ‚âÉ‚Çú Y) : h.symm ‚àò h = id :=\n  funext h.symm_apply_apply\n\n"}
{"name":"Homeomorph.self_comp_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Function.comp ‚áëh ‚áëh.symm) id","decl":"@[simp]\ntheorem self_comp_symm (h : X ‚âÉ‚Çú Y) : h ‚àò h.symm = id :=\n  funext h.apply_symm_apply\n\n"}
{"name":"Homeomorph.range_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Set.range ‚áëh) Set.univ","decl":"@[simp]\ntheorem range_coe (h : X ‚âÉ‚Çú Y) : range h = univ :=\n  h.surjective.range_eq\n\n"}
{"name":"Homeomorph.image_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Set.image ‚áëh.symm) (Set.preimage ‚áëh)","decl":"theorem image_symm (h : X ‚âÉ‚Çú Y) : image h.symm = preimage h :=\n  funext h.symm.toEquiv.image_eq_preimage\n\n"}
{"name":"Homeomorph.preimage_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Set.preimage ‚áëh.symm) (Set.image ‚áëh)","decl":"theorem preimage_symm (h : X ‚âÉ‚Çú Y) : preimage h.symm = image h :=\n  (funext h.toEquiv.image_eq_preimage).symm\n\n"}
{"name":"Homeomorph.image_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set Y\n‚ä¢ Eq (Set.image (‚áëh) (Set.preimage (‚áëh) s)) s","decl":"@[simp]\ntheorem image_preimage (h : X ‚âÉ‚Çú Y) (s : Set Y) : h '' (h ‚Åª¬π' s) = s :=\n  h.toEquiv.image_preimage s\n\n"}
{"name":"Homeomorph.preimage_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Eq (Set.preimage (‚áëh) (Set.image (‚áëh) s)) s","decl":"@[simp]\ntheorem preimage_image (h : X ‚âÉ‚Çú Y) (s : Set X) : h ‚Åª¬π' (h '' s) = s :=\n  h.toEquiv.preimage_image s\n\n"}
{"name":"Homeomorph.image_eq_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Eq (Set.image (‚áëh) s) (Set.preimage (‚áëh.symm) s)","decl":"theorem image_eq_preimage (h : X ‚âÉ‚Çú Y) (s : Set X) : h '' s = h.symm ‚Åª¬π' s :=\n  h.toEquiv.image_eq_preimage s\n\n"}
{"name":"Homeomorph.image_compl","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Eq (Set.image (‚áëh) (HasCompl.compl s)) (HasCompl.compl (Set.image (‚áëh) s))","decl":"lemma image_compl (h : X ‚âÉ‚Çú Y) (s : Set X) : h '' (s·∂ú) = (h '' s)·∂ú :=\n  h.toEquiv.image_compl s\n\n"}
{"name":"Homeomorph.isInducing","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsInducing ‚áëh","decl":"lemma isInducing (h : X ‚âÉ‚Çú Y) : IsInducing h :=\n  .of_comp h.continuous h.symm.continuous <| by simp only [symm_comp_self, IsInducing.id]\n\n"}
{"name":"Homeomorph.inducing","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsInducing ‚áëh","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing := isInducing\n\n"}
{"name":"Homeomorph.induced_eq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (TopologicalSpace.induced (‚áëh) inst‚úù) inst‚úù¬π","decl":"theorem induced_eq (h : X ‚âÉ‚Çú Y) : TopologicalSpace.induced h ‚Äπ_‚Ä∫ = ‚Äπ_‚Ä∫ := h.isInducing.1.symm\n\n"}
{"name":"Homeomorph.isQuotientMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsQuotientMap ‚áëh","decl":"theorem isQuotientMap (h : X ‚âÉ‚Çú Y) : IsQuotientMap h :=\n  IsQuotientMap.of_comp h.symm.continuous h.continuous <| by\n    simp only [self_comp_symm, IsQuotientMap.id]\n\n"}
{"name":"Homeomorph.quotientMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsQuotientMap ‚áëh","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap := isQuotientMap\n\n"}
{"name":"Homeomorph.coinduced_eq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (TopologicalSpace.coinduced (‚áëh) inst‚úù¬π) inst‚úù","decl":"theorem coinduced_eq (h : X ‚âÉ‚Çú Y) : TopologicalSpace.coinduced h ‚Äπ_‚Ä∫ = ‚Äπ_‚Ä∫ :=\n  h.isQuotientMap.2.symm\n\n"}
{"name":"Homeomorph.isEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsEmbedding ‚áëh","decl":"theorem isEmbedding (h : X ‚âÉ‚Çú Y) : IsEmbedding h := ‚ü®h.isInducing, h.injective‚ü©\n\n"}
{"name":"Homeomorph.embedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsEmbedding ‚áëh","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding := isEmbedding\n\n"}
{"name":"Homeomorph.secondCountableTopology","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : SecondCountableTopology Y\nh : Homeomorph X Y\n‚ä¢ SecondCountableTopology X","decl":"protected theorem secondCountableTopology [SecondCountableTopology Y]\n    (h : X ‚âÉ‚Çú Y) : SecondCountableTopology X :=\n  h.isInducing.secondCountableTopology\n\n"}
{"name":"Homeomorph.isCompact_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\n‚ä¢ Iff (IsCompact (Set.image (‚áëh) s)) (IsCompact s)","decl":"/-- If `h : X ‚Üí Y` is a homeomorphism, `h(s)` is compact iff `s` is. -/\n@[simp]\ntheorem isCompact_image {s : Set X} (h : X ‚âÉ‚Çú Y) : IsCompact (h '' s) ‚Üî IsCompact s :=\n  h.isEmbedding.isCompact_iff.symm\n\n"}
{"name":"Homeomorph.isCompact_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set Y\nh : Homeomorph X Y\n‚ä¢ Iff (IsCompact (Set.preimage (‚áëh) s)) (IsCompact s)","decl":"/-- If `h : X ‚Üí Y` is a homeomorphism, `h‚Åª¬π(s)` is compact iff `s` is. -/\n@[simp]\ntheorem isCompact_preimage {s : Set Y} (h : X ‚âÉ‚Çú Y) : IsCompact (h ‚Åª¬π' s) ‚Üî IsCompact s := by\n  rw [‚Üê image_symm]; exact h.symm.isCompact_image\n\n"}
{"name":"Homeomorph.isSigmaCompact_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\n‚ä¢ Iff (IsSigmaCompact (Set.image (‚áëh) s)) (IsSigmaCompact s)","decl":"/-- If `h : X ‚Üí Y` is a homeomorphism, `s` is œÉ-compact iff `h(s)` is. -/\n@[simp]\ntheorem isSigmaCompact_image {s : Set X} (h : X ‚âÉ‚Çú Y) :\n    IsSigmaCompact (h '' s) ‚Üî IsSigmaCompact s :=\n  h.isEmbedding.isSigmaCompact_iff.symm\n\n"}
{"name":"Homeomorph.isSigmaCompact_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set Y\nh : Homeomorph X Y\n‚ä¢ Iff (IsSigmaCompact (Set.preimage (‚áëh) s)) (IsSigmaCompact s)","decl":"/-- If `h : X ‚Üí Y` is a homeomorphism, `h‚Åª¬π(s)` is œÉ-compact iff `s` is. -/\n@[simp]\ntheorem isSigmaCompact_preimage {s : Set Y} (h : X ‚âÉ‚Çú Y) :\n    IsSigmaCompact (h ‚Åª¬π' s) ‚Üî IsSigmaCompact s := by\n  rw [‚Üê image_symm]; exact h.symm.isSigmaCompact_image\n\n"}
{"name":"Homeomorph.isPreconnected_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\n‚ä¢ Iff (IsPreconnected (Set.image (‚áëh) s)) (IsPreconnected s)","decl":"@[simp]\ntheorem isPreconnected_image {s : Set X} (h : X ‚âÉ‚Çú Y) :\n    IsPreconnected (h '' s) ‚Üî IsPreconnected s :=\n  ‚ü®fun hs ‚Ü¶ by simpa only [image_symm, preimage_image]\n    using hs.image _ h.symm.continuous.continuousOn,\n    fun hs ‚Ü¶ hs.image _ h.continuous.continuousOn‚ü©\n\n"}
{"name":"Homeomorph.isPreconnected_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set Y\nh : Homeomorph X Y\n‚ä¢ Iff (IsPreconnected (Set.preimage (‚áëh) s)) (IsPreconnected s)","decl":"@[simp]\ntheorem isPreconnected_preimage {s : Set Y} (h : X ‚âÉ‚Çú Y) :\n    IsPreconnected (h ‚Åª¬π' s) ‚Üî IsPreconnected s := by\n  rw [‚Üê image_symm, isPreconnected_image]\n\n"}
{"name":"Homeomorph.isConnected_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\n‚ä¢ Iff (IsConnected (Set.image (‚áëh) s)) (IsConnected s)","decl":"@[simp]\ntheorem isConnected_image {s : Set X} (h : X ‚âÉ‚Çú Y) :\n    IsConnected (h '' s) ‚Üî IsConnected s :=\n  image_nonempty.and h.isPreconnected_image\n\n"}
{"name":"Homeomorph.isConnected_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set Y\nh : Homeomorph X Y\n‚ä¢ Iff (IsConnected (Set.preimage (‚áëh) s)) (IsConnected s)","decl":"@[simp]\ntheorem isConnected_preimage {s : Set Y} (h : X ‚âÉ‚Çú Y) :\n    IsConnected (h ‚Åª¬π' s) ‚Üî IsConnected s := by\n  rw [‚Üê image_symm, isConnected_image]\n\n"}
{"name":"Homeomorph.image_connectedComponentIn","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nh : Homeomorph X Y\nx : X\nhx : Membership.mem s x\n‚ä¢ Eq (Set.image (‚áëh) (connectedComponentIn s x)) (connectedComponentIn (Set.image (‚áëh) s) (h x))","decl":"theorem image_connectedComponentIn {s : Set X} (h : X ‚âÉ‚Çú Y) {x : X} (hx : x ‚àà s) :\n    h '' connectedComponentIn s x = connectedComponentIn (h '' s) (h x) := by\n  refine (h.continuous.image_connectedComponentIn_subset hx).antisymm ?_\n  have := h.symm.continuous.image_connectedComponentIn_subset (mem_image_of_mem h hx)\n  rwa [image_subset_iff, h.preimage_symm, h.image_symm, h.preimage_image, h.symm_apply_apply]\n    at this\n\n"}
{"name":"Homeomorph.comap_cocompact","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Filter.comap (‚áëh) (Filter.cocompact Y)) (Filter.cocompact X)","decl":"@[simp]\ntheorem comap_cocompact (h : X ‚âÉ‚Çú Y) : comap h (cocompact Y) = cocompact X :=\n  (comap_cocompact_le h.continuous).antisymm <|\n    (hasBasis_cocompact.le_basis_iff (hasBasis_cocompact.comap h)).2 fun K hK =>\n      ‚ü®h ‚Åª¬π' K, h.isCompact_preimage.2 hK, Subset.rfl‚ü©\n\n"}
{"name":"Homeomorph.map_cocompact","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Filter.map (‚áëh) (Filter.cocompact X)) (Filter.cocompact Y)","decl":"@[simp]\ntheorem map_cocompact (h : X ‚âÉ‚Çú Y) : map h (cocompact X) = cocompact Y := by\n  rw [‚Üê h.comap_cocompact, map_comap_of_surjective h.surjective]\n\n"}
{"name":"Homeomorph.compactSpace","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : CompactSpace X\nh : Homeomorph X Y\n‚ä¢ CompactSpace Y","decl":"protected theorem compactSpace [CompactSpace X] (h : X ‚âÉ‚Çú Y) : CompactSpace Y where\n  isCompact_univ := h.symm.isCompact_preimage.2 isCompact_univ\n\n"}
{"name":"Homeomorph.t0Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T0Space X\nh : Homeomorph X Y\n‚ä¢ T0Space Y","decl":"protected theorem t0Space [T0Space X] (h : X ‚âÉ‚Çú Y) : T0Space Y := h.symm.isEmbedding.t0Space\n"}
{"name":"Homeomorph.t1Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T1Space X\nh : Homeomorph X Y\n‚ä¢ T1Space Y","decl":"protected theorem t1Space [T1Space X] (h : X ‚âÉ‚Çú Y) : T1Space Y := h.symm.isEmbedding.t1Space\n"}
{"name":"Homeomorph.t2Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T2Space X\nh : Homeomorph X Y\n‚ä¢ T2Space Y","decl":"protected theorem t2Space [T2Space X] (h : X ‚âÉ‚Çú Y) : T2Space Y := h.symm.isEmbedding.t2Space\n"}
{"name":"Homeomorph.t25Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T25Space X\nh : Homeomorph X Y\n‚ä¢ T25Space Y","decl":"protected theorem t25Space [T25Space X] (h : X ‚âÉ‚Çú Y) : T25Space Y := h.symm.isEmbedding.t25Space\n"}
{"name":"Homeomorph.t3Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T3Space X\nh : Homeomorph X Y\n‚ä¢ T3Space Y","decl":"protected theorem t3Space [T3Space X] (h : X ‚âÉ‚Çú Y) : T3Space Y := h.symm.isEmbedding.t3Space\n\n"}
{"name":"Homeomorph.isDenseEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ IsDenseEmbedding ‚áëh","decl":"theorem isDenseEmbedding (h : X ‚âÉ‚Çú Y) : IsDenseEmbedding h :=\n  { h.isEmbedding with dense := h.surjective.denseRange }\n\n"}
{"name":"Homeomorph.totallyDisconnectedSpace","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ntdc : TotallyDisconnectedSpace X\n‚ä¢ TotallyDisconnectedSpace Y","decl":"protected lemma totallyDisconnectedSpace (h : X ‚âÉ‚Çú Y) [tdc : TotallyDisconnectedSpace X] :\n    TotallyDisconnectedSpace Y :=\n  (totallyDisconnectedSpace_iff Y).mpr\n    (h.range_coe ‚ñ∏ ((IsEmbedding.isTotallyDisconnected_range h.isEmbedding).mpr tdc))\n\n"}
{"name":"Homeomorph.denseEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ IsDenseEmbedding ‚áëh","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding := isDenseEmbedding\n\n"}
{"name":"Homeomorph.isOpen_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set Y\n‚ä¢ Iff (IsOpen (Set.preimage (‚áëh) s)) (IsOpen s)","decl":"@[simp]\ntheorem isOpen_preimage (h : X ‚âÉ‚Çú Y) {s : Set Y} : IsOpen (h ‚Åª¬π' s) ‚Üî IsOpen s :=\n  h.isQuotientMap.isOpen_preimage\n\n"}
{"name":"Homeomorph.isOpen_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Iff (IsOpen (Set.image (‚áëh) s)) (IsOpen s)","decl":"@[simp]\ntheorem isOpen_image (h : X ‚âÉ‚Çú Y) {s : Set X} : IsOpen (h '' s) ‚Üî IsOpen s := by\n  rw [‚Üê preimage_symm, isOpen_preimage]\n\n"}
{"name":"Homeomorph.isOpenMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ IsOpenMap ‚áëh","decl":"protected theorem isOpenMap (h : X ‚âÉ‚Çú Y) : IsOpenMap h := fun _ => h.isOpen_image.2\n\n"}
{"name":"Homeomorph.isClosed_preimage","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set Y\n‚ä¢ Iff (IsClosed (Set.preimage (‚áëh) s)) (IsClosed s)","decl":"@[simp]\ntheorem isClosed_preimage (h : X ‚âÉ‚Çú Y) {s : Set Y} : IsClosed (h ‚Åª¬π' s) ‚Üî IsClosed s := by\n  simp only [‚Üê isOpen_compl_iff, ‚Üê preimage_compl, isOpen_preimage]\n\n"}
{"name":"Homeomorph.isClosed_image","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Iff (IsClosed (Set.image (‚áëh) s)) (IsClosed s)","decl":"@[simp]\ntheorem isClosed_image (h : X ‚âÉ‚Çú Y) {s : Set X} : IsClosed (h '' s) ‚Üî IsClosed s := by\n  rw [‚Üê preimage_symm, isClosed_preimage]\n\n"}
{"name":"Homeomorph.isClosedMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ IsClosedMap ‚áëh","decl":"protected theorem isClosedMap (h : X ‚âÉ‚Çú Y) : IsClosedMap h := fun _ => h.isClosed_image.2\n\n"}
{"name":"Homeomorph.isOpenEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsOpenEmbedding ‚áëh","decl":"theorem isOpenEmbedding (h : X ‚âÉ‚Çú Y) : IsOpenEmbedding h :=\n  .of_isEmbedding_isOpenMap h.isEmbedding h.isOpenMap\n\n"}
{"name":"Homeomorph.openEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsOpenEmbedding ‚áëh","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding := isOpenEmbedding\n\n"}
{"name":"Homeomorph.isClosedEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsClosedEmbedding ‚áëh","decl":"theorem isClosedEmbedding (h : X ‚âÉ‚Çú Y) : IsClosedEmbedding h :=\n  .of_isEmbedding_isClosedMap h.isEmbedding h.isClosedMap\n\n"}
{"name":"Homeomorph.closedEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Topology.IsClosedEmbedding ‚áëh","decl":"@[deprecated (since := \"2024-10-20\")]\nalias closedEmbedding := isClosedEmbedding\n\n"}
{"name":"Homeomorph.normalSpace","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : NormalSpace X\nh : Homeomorph X Y\n‚ä¢ NormalSpace Y","decl":"protected theorem normalSpace [NormalSpace X] (h : X ‚âÉ‚Çú Y) : NormalSpace Y :=\n  h.symm.isClosedEmbedding.normalSpace\n\n"}
{"name":"Homeomorph.t4Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T4Space X\nh : Homeomorph X Y\n‚ä¢ T4Space Y","decl":"protected theorem t4Space [T4Space X] (h : X ‚âÉ‚Çú Y) : T4Space Y := h.symm.isClosedEmbedding.t4Space\n"}
{"name":"Homeomorph.t5Space","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : T5Space X\nh : Homeomorph X Y\n‚ä¢ T5Space Y","decl":"protected theorem t5Space [T5Space X] (h : X ‚âÉ‚Çú Y) : T5Space Y := h.symm.isClosedEmbedding.t5Space\n\n"}
{"name":"Homeomorph.preimage_closure","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set Y\n‚ä¢ Eq (Set.preimage (‚áëh) (closure s)) (closure (Set.preimage (‚áëh) s))","decl":"theorem preimage_closure (h : X ‚âÉ‚Çú Y) (s : Set Y) : h ‚Åª¬π' closure s = closure (h ‚Åª¬π' s) :=\n  h.isOpenMap.preimage_closure_eq_closure_preimage h.continuous _\n\n"}
{"name":"Homeomorph.image_closure","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Eq (Set.image (‚áëh) (closure s)) (closure (Set.image (‚áëh) s))","decl":"theorem image_closure (h : X ‚âÉ‚Çú Y) (s : Set X) : h '' closure s = closure (h '' s) := by\n  rw [‚Üê preimage_symm, preimage_closure]\n\n"}
{"name":"Homeomorph.preimage_interior","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set Y\n‚ä¢ Eq (Set.preimage (‚áëh) (interior s)) (interior (Set.preimage (‚áëh) s))","decl":"theorem preimage_interior (h : X ‚âÉ‚Çú Y) (s : Set Y) : h ‚Åª¬π' interior s = interior (h ‚Åª¬π' s) :=\n  h.isOpenMap.preimage_interior_eq_interior_preimage h.continuous _\n\n"}
{"name":"Homeomorph.image_interior","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Eq (Set.image (‚áëh) (interior s)) (interior (Set.image (‚áëh) s))","decl":"theorem image_interior (h : X ‚âÉ‚Çú Y) (s : Set X) : h '' interior s = interior (h '' s) := by\n  rw [‚Üê preimage_symm, preimage_interior]\n\n"}
{"name":"Homeomorph.preimage_frontier","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set Y\n‚ä¢ Eq (Set.preimage (‚áëh) (frontier s)) (frontier (Set.preimage (‚áëh) s))","decl":"theorem preimage_frontier (h : X ‚âÉ‚Çú Y) (s : Set Y) : h ‚Åª¬π' frontier s = frontier (h ‚Åª¬π' s) :=\n  h.isOpenMap.preimage_frontier_eq_frontier_preimage h.continuous _\n\n"}
{"name":"Homeomorph.image_frontier","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ns : Set X\n‚ä¢ Eq (Set.image (‚áëh) (frontier s)) (frontier (Set.image (‚áëh) s))","decl":"theorem image_frontier (h : X ‚âÉ‚Çú Y) (s : Set X) : h '' frontier s = frontier (h '' s) := by\n  rw [‚Üê preimage_symm, preimage_frontier]\n\n"}
{"name":"HasCompactSupport.comp_homeomorph","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nM : Type u_7\ninst‚úù : Zero M\nf : Y ‚Üí M\nhf : HasCompactSupport f\nœÜ : Homeomorph X Y\n‚ä¢ HasCompactSupport (Function.comp f ‚áëœÜ)","decl":"@[to_additive]\ntheorem _root_.HasCompactMulSupport.comp_homeomorph {M} [One M] {f : Y ‚Üí M}\n    (hf : HasCompactMulSupport f) (œÜ : X ‚âÉ‚Çú Y) : HasCompactMulSupport (f ‚àò œÜ) :=\n  hf.comp_isClosedEmbedding œÜ.isClosedEmbedding\n\n"}
{"name":"HasCompactMulSupport.comp_homeomorph","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\nM : Type u_7\ninst‚úù : One M\nf : Y ‚Üí M\nhf : HasCompactMulSupport f\nœÜ : Homeomorph X Y\n‚ä¢ HasCompactMulSupport (Function.comp f ‚áëœÜ)","decl":"@[to_additive]\ntheorem _root_.HasCompactMulSupport.comp_homeomorph {M} [One M] {f : Y ‚Üí M}\n    (hf : HasCompactMulSupport f) (œÜ : X ‚âÉ‚Çú Y) : HasCompactMulSupport (f ‚àò œÜ) :=\n  hf.comp_isClosedEmbedding œÜ.isClosedEmbedding\n\n"}
{"name":"Homeomorph.map_nhds_eq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\nx : X\n‚ä¢ Eq (Filter.map (‚áëh) (nhds x)) (nhds (h x))","decl":"@[simp]\ntheorem map_nhds_eq (h : X ‚âÉ‚Çú Y) (x : X) : map h (ùìù x) = ùìù (h x) :=\n  h.isEmbedding.map_nhds_of_mem _ (by simp)\n\n"}
{"name":"Homeomorph.map_punctured_nhds_eq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\nx : X\n‚ä¢ Eq (Filter.map (‚áëh) (nhdsWithin x (HasCompl.compl (Singleton.singleton x)))) (nhdsWithin (h x) (HasCompl.compl (Singleton.singleton (h x))))","decl":"@[simp]\ntheorem map_punctured_nhds_eq (h : X ‚âÉ‚Çú Y) (x : X) : map h (ùìù[‚â†] x) = ùìù[‚â†] (h x) := by\n  convert h.isEmbedding.map_nhdsWithin_eq ({x}·∂ú) x\n  rw [h.image_compl, Set.image_singleton]\n\n"}
{"name":"Homeomorph.symm_map_nhds_eq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\nx : X\n‚ä¢ Eq (Filter.map (‚áëh.symm) (nhds (h x))) (nhds x)","decl":"theorem symm_map_nhds_eq (h : X ‚âÉ‚Çú Y) (x : X) : map h.symm (ùìù (h x)) = ùìù x := by\n  rw [h.symm.map_nhds_eq, h.symm_apply_apply]\n\n"}
{"name":"Homeomorph.nhds_eq_comap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\nx : X\n‚ä¢ Eq (nhds x) (Filter.comap (‚áëh) (nhds (h x)))","decl":"theorem nhds_eq_comap (h : X ‚âÉ‚Çú Y) (x : X) : ùìù x = comap h (ùìù (h x)) :=\n  h.isInducing.nhds_eq_comap x\n\n"}
{"name":"Homeomorph.comap_nhds_eq","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\ny : Y\n‚ä¢ Eq (Filter.comap (‚áëh) (nhds y)) (nhds (h.symm y))","decl":"@[simp]\ntheorem comap_nhds_eq (h : X ‚âÉ‚Çú Y) (y : Y) : comap h (ùìù y) = ùìù (h.symm y) := by\n  rw [h.nhds_eq_comap, h.apply_symm_apply]\n\n"}
{"name":"Homeomorph.comap_coclosedCompact","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Filter.comap (‚áëh) (Filter.coclosedCompact Y)) (Filter.coclosedCompact X)","decl":"@[simp]\ntheorem comap_coclosedCompact (h : X ‚âÉ‚Çú Y) : comap h (coclosedCompact Y) = coclosedCompact X :=\n  (hasBasis_coclosedCompact.comap h).eq_of_same_basis <| by\n    simpa [comp_def] using hasBasis_coclosedCompact.comp_surjective h.injective.preimage_surjective\n\n"}
{"name":"Homeomorph.map_coclosedCompact","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Eq (Filter.map (‚áëh) (Filter.coclosedCompact X)) (Filter.coclosedCompact Y)","decl":"@[simp]\ntheorem map_coclosedCompact (h : X ‚âÉ‚Çú Y) : map h (coclosedCompact X) = coclosedCompact Y := by\n  rw [‚Üê h.comap_coclosedCompact, map_comap_of_surjective h.surjective]\n\n"}
{"name":"Homeomorph.locallyConnectedSpace","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ni : LocallyConnectedSpace Y\nh : Homeomorph X Y\n‚ä¢ LocallyConnectedSpace X","decl":"/-- If the codomain of a homeomorphism is a locally connected space, then the domain is also\na locally connected space. -/\ntheorem locallyConnectedSpace [i : LocallyConnectedSpace Y] (h : X ‚âÉ‚Çú Y) :\n    LocallyConnectedSpace X := by\n  have : ‚àÄ x, (ùìù x).HasBasis (fun s ‚Ü¶ IsOpen s ‚àß h x ‚àà s ‚àß IsConnected s)\n      (h.symm '' ¬∑) := fun x ‚Ü¶ by\n    rw [‚Üê h.symm_map_nhds_eq]\n    exact (i.1 _).map _\n  refine locallyConnectedSpace_of_connected_bases _ _ this fun _ _ hs ‚Ü¶ ?_\n  exact hs.2.2.2.image _ h.symm.continuous.continuousOn\n\n"}
{"name":"Homeomorph.locallyCompactSpace_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ Iff (LocallyCompactSpace X) (LocallyCompactSpace Y)","decl":"/-- The codomain of a homeomorphism is a locally compact space if and only if\nthe domain is a locally compact space. -/\ntheorem locallyCompactSpace_iff (h : X ‚âÉ‚Çú Y) :\n    LocallyCompactSpace X ‚Üî LocallyCompactSpace Y := by\n  exact ‚ü®fun _ => h.symm.isOpenEmbedding.locallyCompactSpace,\n    fun _ => h.isClosedEmbedding.locallyCompactSpace‚ü©\n\n"}
{"name":"Homeomorph.homeomorphOfContinuousOpen_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nh‚ÇÅ : Continuous ‚áëe\nh‚ÇÇ : IsOpenMap ‚áëe\n‚ä¢ Eq (Homeomorph.homeomorphOfContinuousOpen e h‚ÇÅ h‚ÇÇ).toEquiv e","decl":"/-- If a bijective map `e : X ‚âÉ Y` is continuous and open, then it is a homeomorphism. -/\n@[simps toEquiv]\ndef homeomorphOfContinuousOpen (e : X ‚âÉ Y) (h‚ÇÅ : Continuous e) (h‚ÇÇ : IsOpenMap e) : X ‚âÉ‚Çú Y where\n  continuous_toFun := h‚ÇÅ\n  continuous_invFun := e.continuous_symm_iff.2 h‚ÇÇ\n  toEquiv := e\n\n"}
{"name":"Homeomorph.homeomorphOfContinuousOpen_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nh‚ÇÅ : Continuous ‚áëe\nh‚ÇÇ : IsOpenMap ‚áëe\n‚ä¢ Eq ‚áë(Homeomorph.homeomorphOfContinuousOpen e h‚ÇÅ h‚ÇÇ) ‚áëe","decl":"@[simp]\ntheorem homeomorphOfContinuousOpen_apply (e : X ‚âÉ Y) (h‚ÇÅ : Continuous e) (h‚ÇÇ : IsOpenMap e) :\n    ‚áë(homeomorphOfContinuousOpen e h‚ÇÅ h‚ÇÇ) = e := rfl\n\n"}
{"name":"Homeomorph.homeomorphOfContinuousOpen_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nh‚ÇÅ : Continuous ‚áëe\nh‚ÇÇ : IsOpenMap ‚áëe\n‚ä¢ Eq ‚áë(Homeomorph.homeomorphOfContinuousOpen e h‚ÇÅ h‚ÇÇ).symm ‚áëe.symm","decl":"@[simp]\ntheorem homeomorphOfContinuousOpen_symm_apply (e : X ‚âÉ Y) (h‚ÇÅ : Continuous e) (h‚ÇÇ : IsOpenMap e) :\n    ‚áë(homeomorphOfContinuousOpen e h‚ÇÅ h‚ÇÇ).symm = e.symm := rfl\n\n"}
{"name":"Homeomorph.comp_continuousOn_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Z ‚Üí X\ns : Set Z\n‚ä¢ Iff (ContinuousOn (Function.comp (‚áëh) f) s) (ContinuousOn f s)","decl":"@[simp]\ntheorem comp_continuousOn_iff (h : X ‚âÉ‚Çú Y) (f : Z ‚Üí X) (s : Set Z) :\n    ContinuousOn (h ‚àò f) s ‚Üî ContinuousOn f s :=\n  h.isInducing.continuousOn_iff.symm\n\n"}
{"name":"Homeomorph.comp_continuous_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Z ‚Üí X\n‚ä¢ Iff (Continuous (Function.comp (‚áëh) f)) (Continuous f)","decl":"@[simp]\ntheorem comp_continuous_iff (h : X ‚âÉ‚Çú Y) {f : Z ‚Üí X} : Continuous (h ‚àò f) ‚Üî Continuous f :=\n  h.isInducing.continuous_iff.symm\n\n"}
{"name":"Homeomorph.comp_continuous_iff'","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Y ‚Üí Z\n‚ä¢ Iff (Continuous (Function.comp f ‚áëh)) (Continuous f)","decl":"@[simp]\ntheorem comp_continuous_iff' (h : X ‚âÉ‚Çú Y) {f : Y ‚Üí Z} : Continuous (f ‚àò h) ‚Üî Continuous f :=\n  h.isQuotientMap.continuous_iff.symm\n\n"}
{"name":"Homeomorph.comp_continuousAt_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Z ‚Üí X\nz : Z\n‚ä¢ Iff (ContinuousAt (Function.comp (‚áëh) f) z) (ContinuousAt f z)","decl":"theorem comp_continuousAt_iff (h : X ‚âÉ‚Çú Y) (f : Z ‚Üí X) (z : Z) :\n    ContinuousAt (h ‚àò f) z ‚Üî ContinuousAt f z :=\n  h.isInducing.continuousAt_iff.symm\n\n"}
{"name":"Homeomorph.comp_continuousAt_iff'","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Y ‚Üí Z\nx : X\n‚ä¢ Iff (ContinuousAt (Function.comp f ‚áëh) x) (ContinuousAt f (h x))","decl":"theorem comp_continuousAt_iff' (h : X ‚âÉ‚Çú Y) (f : Y ‚Üí Z) (x : X) :\n    ContinuousAt (f ‚àò h) x ‚Üî ContinuousAt f (h x) :=\n  h.isInducing.continuousAt_iff' (by simp)\n\n"}
{"name":"Homeomorph.comp_continuousWithinAt_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Z ‚Üí X\ns : Set Z\nz : Z\n‚ä¢ Iff (ContinuousWithinAt f s z) (ContinuousWithinAt (Function.comp (‚áëh) f) s z)","decl":"theorem comp_continuousWithinAt_iff (h : X ‚âÉ‚Çú Y) (f : Z ‚Üí X) (s : Set Z) (z : Z) :\n    ContinuousWithinAt f s z ‚Üî ContinuousWithinAt (h ‚àò f) s z :=\n  h.isInducing.continuousWithinAt_iff\n\n"}
{"name":"Homeomorph.comp_isOpenMap_iff","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Z ‚Üí X\n‚ä¢ Iff (IsOpenMap (Function.comp (‚áëh) f)) (IsOpenMap f)","decl":"@[simp]\ntheorem comp_isOpenMap_iff (h : X ‚âÉ‚Çú Y) {f : Z ‚Üí X} : IsOpenMap (h ‚àò f) ‚Üî IsOpenMap f := by\n  refine ‚ü®?_, fun hf => h.isOpenMap.comp hf‚ü©\n  intro hf\n  rw [‚Üê Function.id_comp f, ‚Üê h.symm_comp_self, Function.comp_assoc]\n  exact h.symm.isOpenMap.comp hf\n\n"}
{"name":"Homeomorph.comp_isOpenMap_iff'","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nh : Homeomorph X Y\nf : Y ‚Üí Z\n‚ä¢ Iff (IsOpenMap (Function.comp f ‚áëh)) (IsOpenMap f)","decl":"@[simp]\ntheorem comp_isOpenMap_iff' (h : X ‚âÉ‚Çú Y) {f : Y ‚Üí Z} : IsOpenMap (f ‚àò h) ‚Üî IsOpenMap f := by\n  refine ‚ü®?_, fun hf => hf.comp h.isOpenMap‚ü©\n  intro hf\n  rw [‚Üê Function.comp_id f, ‚Üê h.self_comp_symm, ‚Üê Function.comp_assoc]\n  exact hf.comp h.symm.isOpenMap\n\n"}
{"name":"Homeomorph.subtype_symm_apply_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\np : X ‚Üí Prop\nq : Y ‚Üí Prop\nh : Homeomorph X Y\nh_iff : ‚àÄ (x : X), Iff (p x) (q (h x))\nb : Subtype fun b => q b\n‚ä¢ Eq (‚Üë((h.subtype h_iff).symm b)) (h.symm ‚Üëb)","decl":"/-- A homeomorphism `h : X ‚âÉ‚Çú Y` lifts to a homeomorphism between subtypes corresponding to\npredicates `p : X ‚Üí Prop` and `q : Y ‚Üí Prop` so long as `p = q ‚àò h`. -/\n@[simps!]\ndef subtype {p : X ‚Üí Prop} {q : Y ‚Üí Prop} (h : X ‚âÉ‚Çú Y) (h_iff : ‚àÄ x, p x ‚Üî q (h x)) :\n    {x // p x} ‚âÉ‚Çú {y // q y} where\n  continuous_toFun := by simpa [Equiv.coe_subtypeEquiv_eq_map] using h.continuous.subtype_map _\n  continuous_invFun := by simpa [Equiv.coe_subtypeEquiv_eq_map] using\n    h.symm.continuous.subtype_map _\n  __ := h.subtypeEquiv h_iff\n\n"}
{"name":"Homeomorph.subtype_apply_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\np : X ‚Üí Prop\nq : Y ‚Üí Prop\nh : Homeomorph X Y\nh_iff : ‚àÄ (x : X), Iff (p x) (q (h x))\na : Subtype fun a => p a\n‚ä¢ Eq (‚Üë((h.subtype h_iff) a)) (h ‚Üëa)","decl":"/-- A homeomorphism `h : X ‚âÉ‚Çú Y` lifts to a homeomorphism between subtypes corresponding to\npredicates `p : X ‚Üí Prop` and `q : Y ‚Üí Prop` so long as `p = q ‚àò h`. -/\n@[simps!]\ndef subtype {p : X ‚Üí Prop} {q : Y ‚Üí Prop} (h : X ‚âÉ‚Çú Y) (h_iff : ‚àÄ x, p x ‚Üî q (h x)) :\n    {x // p x} ‚âÉ‚Çú {y // q y} where\n  continuous_toFun := by simpa [Equiv.coe_subtypeEquiv_eq_map] using h.continuous.subtype_map _\n  continuous_invFun := by simpa [Equiv.coe_subtypeEquiv_eq_map] using\n    h.symm.continuous.subtype_map _\n  __ := h.subtypeEquiv h_iff\n\n"}
{"name":"Homeomorph.subtype_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\np : X ‚Üí Prop\nq : Y ‚Üí Prop\nh : Homeomorph X Y\nh_iff : ‚àÄ (x : X), Iff (p x) (q (h x))\n‚ä¢ Eq (h.subtype h_iff).toEquiv (h.subtypeEquiv h_iff)","decl":"@[simp]\nlemma subtype_toEquiv {p : X ‚Üí Prop} {q : Y ‚Üí Prop} (h : X ‚âÉ‚Çú Y) (h_iff : ‚àÄ x, p x ‚Üî q (h x)) :\n    (h.subtype h_iff).toEquiv = h.toEquiv.subtypeEquiv h_iff :=\n  rfl\n\n"}
{"name":"Homeomorph.prodCongr_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\nX' : Type u_5\nY' : Type u_6\ninst‚úù¬π : TopologicalSpace X'\ninst‚úù : TopologicalSpace Y'\nh‚ÇÅ : Homeomorph X X'\nh‚ÇÇ : Homeomorph Y Y'\n‚ä¢ Eq (h‚ÇÅ.prodCongr h‚ÇÇ).symm (h‚ÇÅ.symm.prodCongr h‚ÇÇ.symm)","decl":"@[simp]\ntheorem prodCongr_symm (h‚ÇÅ : X ‚âÉ‚Çú X') (h‚ÇÇ : Y ‚âÉ‚Çú Y') :\n    (h‚ÇÅ.prodCongr h‚ÇÇ).symm = h‚ÇÅ.symm.prodCongr h‚ÇÇ.symm :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_prodCongr","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\nX' : Type u_5\nY' : Type u_6\ninst‚úù¬π : TopologicalSpace X'\ninst‚úù : TopologicalSpace Y'\nh‚ÇÅ : Homeomorph X X'\nh‚ÇÇ : Homeomorph Y Y'\n‚ä¢ Eq (‚áë(h‚ÇÅ.prodCongr h‚ÇÇ)) (Prod.map ‚áëh‚ÇÅ ‚áëh‚ÇÇ)","decl":"@[simp]\ntheorem coe_prodCongr (h‚ÇÅ : X ‚âÉ‚Çú X') (h‚ÇÇ : Y ‚âÉ‚Çú Y') : ‚áë(h‚ÇÅ.prodCongr h‚ÇÇ) = Prod.map h‚ÇÅ h‚ÇÇ :=\n  rfl\n\n-- Commutativity and associativity of the disjoint union of topological spaces,\n-- and the sum with an empty space.\n"}
{"name":"Homeomorph.sumComm_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq (Homeomorph.sumComm X Y).symm (Homeomorph.sumComm Y X)","decl":"@[simp]\ntheorem sumComm_symm : (sumComm X Y).symm = sumComm Y X :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_sumComm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq (‚áë(Homeomorph.sumComm X Y)) Sum.swap","decl":"@[simp]\ntheorem coe_sumComm : ‚áë(sumComm X Y) = Sum.swap :=\n  rfl\n\n"}
{"name":"Homeomorph.continuous_sumAssoc","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\n‚ä¢ Continuous ‚áë(Equiv.sumAssoc X Y Z)","decl":"@[continuity, fun_prop]\nlemma continuous_sumAssoc : Continuous (Equiv.sumAssoc X Y Z) :=\n  Continuous.sum_elim (by fun_prop) (by fun_prop)\n\n"}
{"name":"Homeomorph.continuous_sumAssoc_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\n‚ä¢ Continuous ‚áë(Equiv.sumAssoc X Y Z).symm","decl":"@[continuity, fun_prop]\nlemma continuous_sumAssoc_symm : Continuous (Equiv.sumAssoc X Y Z).symm :=\n  Continuous.sum_elim (by fun_prop) (by fun_prop)\n\n"}
{"name":"Homeomorph.sumAssoc_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\n‚ä¢ Eq (Homeomorph.sumAssoc X Y Z).toEquiv (Equiv.sumAssoc X Y Z)","decl":"@[simp]\nlemma sumAssoc_toEquiv : (sumAssoc X Y Z).toEquiv = Equiv.sumAssoc X Y Z := rfl\n\n"}
{"name":"Homeomorph.sumSumSumComm_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nW : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace W\ninst‚úù : TopologicalSpace Z\n‚ä¢ Eq (Homeomorph.sumSumSumComm X Y W Z).toEquiv (Equiv.sumSumSumComm X Y W Z)","decl":"@[simp]\nlemma sumSumSumComm_toEquiv : (sumSumSumComm X Y W Z).toEquiv = (Equiv.sumSumSumComm X Y W Z) := rfl\n\n"}
{"name":"Homeomorph.sumSumSumComm_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nW : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace W\ninst‚úù : TopologicalSpace Z\n‚ä¢ Eq (Homeomorph.sumSumSumComm X Y W Z).symm (Homeomorph.sumSumSumComm X W Y Z)","decl":"@[simp]\nlemma sumSumSumComm_symm : (sumSumSumComm X Y W Z).symm = (sumSumSumComm X W Y Z) := rfl\n\n"}
{"name":"Homeomorph.sumEmpty_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : IsEmpty Y\n‚ä¢ Eq (‚áë(Homeomorph.sumEmpty X Y)) (Sum.elim id fun a => isEmptyElim a)","decl":"/-- The sum of `X` with any empty topological space is homeomorphic to `X`. -/\n@[simps! (config := .asFn) apply]\ndef sumEmpty [IsEmpty Y] : X ‚äï Y ‚âÉ‚Çú X where\n  toEquiv := Equiv.sumEmpty X Y\n  continuous_toFun := Continuous.sum_elim continuous_id (by fun_prop)\n  continuous_invFun := continuous_inl\n\n"}
{"name":"Homeomorph.coe_emptySum","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : IsEmpty Y\n‚ä¢ Eq (Homeomorph.emptySum X Y).toEquiv (Equiv.emptySum Y X)","decl":"@[simp] theorem coe_emptySum [IsEmpty Y] : (emptySum X Y).toEquiv = Equiv.emptySum Y X := rfl\n\n"}
{"name":"Homeomorph.prodComm_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq (Homeomorph.prodComm X Y).symm (Homeomorph.prodComm Y X)","decl":"@[simp]\ntheorem prodComm_symm : (prodComm X Y).symm = prodComm Y X :=\n  rfl\n\n"}
{"name":"Homeomorph.coe_prodComm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\n‚ä¢ Eq (‚áë(Homeomorph.prodComm X Y)) Prod.swap","decl":"@[simp]\ntheorem coe_prodComm : ‚áë(prodComm X Y) = Prod.swap :=\n  rfl\n\n"}
{"name":"Homeomorph.prodAssoc_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\n‚ä¢ Eq (Homeomorph.prodAssoc X Y Z).toEquiv (Equiv.prodAssoc X Y Z)","decl":"@[simp]\nlemma prodAssoc_toEquiv : (prodAssoc X Y Z).toEquiv = Equiv.prodAssoc X Y Z := rfl\n\n"}
{"name":"Homeomorph.prodProdProdComm_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nW : Type u_3\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace W\ninst‚úù : TopologicalSpace Z\n‚ä¢ Eq (Homeomorph.prodProdProdComm X Y W Z).symm (Homeomorph.prodProdProdComm X W Y Z)","decl":"@[simp]\ntheorem prodProdProdComm_symm : (prodProdProdComm X Y W Z).symm = prodProdProdComm X W Y Z :=\n  rfl\n\n"}
{"name":"Homeomorph.prodPUnit_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq ‚áë(Homeomorph.prodPUnit X) fun p => p.1","decl":"/-- `X √ó {*}` is homeomorphic to `X`. -/\n@[simps! (config := .asFn) apply]\ndef prodPUnit : X √ó PUnit ‚âÉ‚Çú X where\n  toEquiv := Equiv.prodPUnit X\n  continuous_toFun := continuous_fst\n  continuous_invFun := continuous_id.prod_mk continuous_const\n\n"}
{"name":"Homeomorph.coe_punitProd","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (‚áë(Homeomorph.punitProd X)) Prod.snd","decl":"@[simp] theorem coe_punitProd : ‚áë(punitProd X) = Prod.snd := rfl\n\n"}
{"name":"Homeomorph.homeomorphOfUnique_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : Unique X\ninst‚úù : Unique Y\na‚úù : X\n‚ä¢ Eq ((Homeomorph.homeomorphOfUnique X Y) a‚úù) Inhabited.default","decl":"/-- If both `X` and `Y` have a unique element, then `X ‚âÉ‚Çú Y`. -/\n@[simps!]\ndef homeomorphOfUnique [Unique X] [Unique Y] : X ‚âÉ‚Çú Y :=\n  { Equiv.ofUnique X Y with\n    continuous_toFun := continuous_const\n    continuous_invFun := continuous_const }\n\n"}
{"name":"Homeomorph.homeomorphOfUnique_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : Unique X\ninst‚úù : Unique Y\na‚úù : Y\n‚ä¢ Eq ((Homeomorph.homeomorphOfUnique X Y).symm a‚úù) Inhabited.default","decl":"/-- If both `X` and `Y` have a unique element, then `X ‚âÉ‚Çú Y`. -/\n@[simps!]\ndef homeomorphOfUnique [Unique X] [Unique Y] : X ‚âÉ‚Çú Y :=\n  { Equiv.ofUnique X Y with\n    continuous_toFun := continuous_const\n    continuous_invFun := continuous_const }\n\n"}
{"name":"Homeomorph.piUnique_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œ± : Type u_7\ninst‚úù¬π : Unique Œ±\nf : Œ± ‚Üí Type u_8\ninst‚úù : (x : Œ±) ‚Üí TopologicalSpace (f x)\n‚ä¢ Eq ‚áë(Homeomorph.piUnique f) fun f => f Inhabited.default","decl":"/-- The product `Œ† t : Œ±, f t` of a family of topological spaces is homeomorphic to the\nspace `f ‚¨ù` when `Œ±` only contains `‚¨ù`.\n\nThis is `Equiv.piUnique` as a `Homeomorph`.\n-/\n@[simps! (config := .asFn)]\ndef piUnique {Œ± : Type*} [Unique Œ±] (f : Œ± ‚Üí Type*) [‚àÄ x, TopologicalSpace (f x)] :\n    (Œ† t, f t) ‚âÉ‚Çú f default :=\n  homeomorphOfContinuousOpen (Equiv.piUnique f) (continuous_apply default) (isOpenMap_eval _)\n\n"}
{"name":"Homeomorph.piUnique_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œ± : Type u_7\ninst‚úù¬π : Unique Œ±\nf : Œ± ‚Üí Type u_8\ninst‚úù : (x : Œ±) ‚Üí TopologicalSpace (f x)\n‚ä¢ Eq (‚áë(Homeomorph.piUnique f).symm) uniqueElim","decl":"/-- The product `Œ† t : Œ±, f t` of a family of topological spaces is homeomorphic to the\nspace `f ‚¨ù` when `Œ±` only contains `‚¨ù`.\n\nThis is `Equiv.piUnique` as a `Homeomorph`.\n-/\n@[simps! (config := .asFn)]\ndef piUnique {Œ± : Type*} [Unique Œ±] (f : Œ± ‚Üí Type*) [‚àÄ x, TopologicalSpace (f x)] :\n    (Œ† t, f t) ‚âÉ‚Çú f default :=\n  homeomorphOfContinuousOpen (Equiv.piUnique f) (continuous_apply default) (isOpenMap_eval _)\n\n"}
{"name":"Homeomorph.piCongrLeft_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nŒπ' : Type u_8\nY : Œπ' ‚Üí Type u_9\ninst‚úù : (j : Œπ') ‚Üí TopologicalSpace (Y j)\ne : Equiv Œπ Œπ'\na‚úù : (b : Œπ) ‚Üí Y (e.symm.symm b)\na : Œπ'\n‚ä¢ Eq ((Homeomorph.piCongrLeft e) a‚úù a) ((Equiv.piCongrLeft' Y e.symm).symm a‚úù a)","decl":"/-- `Equiv.piCongrLeft` as a homeomorphism: this is the natural homeomorphism\n`Œ† i, Y (e i) ‚âÉ‚Çú Œ† j, Y j` obtained from a bijection `Œπ ‚âÉ Œπ'`. -/\n@[simps! apply toEquiv]\ndef piCongrLeft {Œπ Œπ' : Type*} {Y : Œπ' ‚Üí Type*} [‚àÄ j, TopologicalSpace (Y j)]\n    (e : Œπ ‚âÉ Œπ') : (‚àÄ i, Y (e i)) ‚âÉ‚Çú ‚àÄ j, Y j where\n  continuous_toFun := continuous_pi <| e.forall_congr_right.mp fun i ‚Ü¶ by\n    simpa only [Equiv.toFun_as_coe, Equiv.piCongrLeft_apply_apply] using continuous_apply i\n  continuous_invFun := Pi.continuous_precomp' e\n  toEquiv := Equiv.piCongrLeft _ e\n\n"}
{"name":"Homeomorph.piCongrLeft_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nŒπ' : Type u_8\nY : Œπ' ‚Üí Type u_9\ninst‚úù : (j : Œπ') ‚Üí TopologicalSpace (Y j)\ne : Equiv Œπ Œπ'\n‚ä¢ Eq (Homeomorph.piCongrLeft e).toEquiv (Equiv.piCongrLeft Y e)","decl":"/-- `Equiv.piCongrLeft` as a homeomorphism: this is the natural homeomorphism\n`Œ† i, Y (e i) ‚âÉ‚Çú Œ† j, Y j` obtained from a bijection `Œπ ‚âÉ Œπ'`. -/\n@[simps! apply toEquiv]\ndef piCongrLeft {Œπ Œπ' : Type*} {Y : Œπ' ‚Üí Type*} [‚àÄ j, TopologicalSpace (Y j)]\n    (e : Œπ ‚âÉ Œπ') : (‚àÄ i, Y (e i)) ‚âÉ‚Çú ‚àÄ j, Y j where\n  continuous_toFun := continuous_pi <| e.forall_congr_right.mp fun i ‚Ü¶ by\n    simpa only [Equiv.toFun_as_coe, Equiv.piCongrLeft_apply_apply] using continuous_apply i\n  continuous_invFun := Pi.continuous_precomp' e\n  toEquiv := Equiv.piCongrLeft _ e\n\n"}
{"name":"Homeomorph.piCongrRight_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nY‚ÇÅ : Œπ ‚Üí Type u_8\nY‚ÇÇ : Œπ ‚Üí Type u_9\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Y‚ÇÅ i)\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (Y‚ÇÇ i)\nF : (i : Œπ) ‚Üí Homeomorph (Y‚ÇÅ i) (Y‚ÇÇ i)\n‚ä¢ Eq (Homeomorph.piCongrRight F).toEquiv (Equiv.piCongrRight fun i => (F i).toEquiv)","decl":"/-- `Equiv.piCongrRight` as a homeomorphism: this is the natural homeomorphism\n`Œ† i, Y‚ÇÅ i ‚âÉ‚Çú Œ† j, Y‚ÇÇ i` obtained from homeomorphisms `Y‚ÇÅ i ‚âÉ‚Çú Y‚ÇÇ i` for each `i`. -/\n@[simps! apply toEquiv]\ndef piCongrRight {Œπ : Type*} {Y‚ÇÅ Y‚ÇÇ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Y‚ÇÅ i)]\n    [‚àÄ i, TopologicalSpace (Y‚ÇÇ i)] (F : ‚àÄ i, Y‚ÇÅ i ‚âÉ‚Çú Y‚ÇÇ i) : (‚àÄ i, Y‚ÇÅ i) ‚âÉ‚Çú ‚àÄ i, Y‚ÇÇ i where\n  continuous_toFun := Pi.continuous_postcomp' fun i ‚Ü¶ (F i).continuous\n  continuous_invFun := Pi.continuous_postcomp' fun i ‚Ü¶ (F i).symm.continuous\n  toEquiv := Equiv.piCongrRight fun i => (F i).toEquiv\n\n"}
{"name":"Homeomorph.piCongrRight_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nY‚ÇÅ : Œπ ‚Üí Type u_8\nY‚ÇÇ : Œπ ‚Üí Type u_9\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Y‚ÇÅ i)\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (Y‚ÇÇ i)\nF : (i : Œπ) ‚Üí Homeomorph (Y‚ÇÅ i) (Y‚ÇÇ i)\na‚úù : (i : Œπ) ‚Üí Y‚ÇÅ i\ni : Œπ\n‚ä¢ Eq ((Homeomorph.piCongrRight F) a‚úù i) ((F i) (a‚úù i))","decl":"/-- `Equiv.piCongrRight` as a homeomorphism: this is the natural homeomorphism\n`Œ† i, Y‚ÇÅ i ‚âÉ‚Çú Œ† j, Y‚ÇÇ i` obtained from homeomorphisms `Y‚ÇÅ i ‚âÉ‚Çú Y‚ÇÇ i` for each `i`. -/\n@[simps! apply toEquiv]\ndef piCongrRight {Œπ : Type*} {Y‚ÇÅ Y‚ÇÇ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Y‚ÇÅ i)]\n    [‚àÄ i, TopologicalSpace (Y‚ÇÇ i)] (F : ‚àÄ i, Y‚ÇÅ i ‚âÉ‚Çú Y‚ÇÇ i) : (‚àÄ i, Y‚ÇÅ i) ‚âÉ‚Çú ‚àÄ i, Y‚ÇÇ i where\n  continuous_toFun := Pi.continuous_postcomp' fun i ‚Ü¶ (F i).continuous\n  continuous_invFun := Pi.continuous_postcomp' fun i ‚Ü¶ (F i).symm.continuous\n  toEquiv := Equiv.piCongrRight fun i => (F i).toEquiv\n\n"}
{"name":"Homeomorph.piCongrRight_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nY‚ÇÅ : Œπ ‚Üí Type u_8\nY‚ÇÇ : Œπ ‚Üí Type u_9\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Y‚ÇÅ i)\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (Y‚ÇÇ i)\nF : (i : Œπ) ‚Üí Homeomorph (Y‚ÇÅ i) (Y‚ÇÇ i)\n‚ä¢ Eq (Homeomorph.piCongrRight F).symm (Homeomorph.piCongrRight fun i => (F i).symm)","decl":"@[simp]\ntheorem piCongrRight_symm {Œπ : Type*} {Y‚ÇÅ Y‚ÇÇ : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (Y‚ÇÅ i)]\n    [‚àÄ i, TopologicalSpace (Y‚ÇÇ i)] (F : ‚àÄ i, Y‚ÇÅ i ‚âÉ‚Çú Y‚ÇÇ i) :\n    (piCongrRight F).symm = piCongrRight fun i => (F i).symm :=\n  rfl\n\n"}
{"name":"Homeomorph.piCongr_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ‚ÇÅ : Type u_7\nŒπ‚ÇÇ : Type u_8\nY‚ÇÅ : Œπ‚ÇÅ ‚Üí Type u_9\nY‚ÇÇ : Œπ‚ÇÇ ‚Üí Type u_10\ninst‚úù¬π : (i‚ÇÅ : Œπ‚ÇÅ) ‚Üí TopologicalSpace (Y‚ÇÅ i‚ÇÅ)\ninst‚úù : (i‚ÇÇ : Œπ‚ÇÇ) ‚Üí TopologicalSpace (Y‚ÇÇ i‚ÇÇ)\ne : Equiv Œπ‚ÇÅ Œπ‚ÇÇ\nF : (i‚ÇÅ : Œπ‚ÇÅ) ‚Üí Homeomorph (Y‚ÇÅ i‚ÇÅ) (Y‚ÇÇ (e i‚ÇÅ))\na‚úù : (i : Œπ‚ÇÅ) ‚Üí Y‚ÇÅ i\ni‚ÇÇ : Œπ‚ÇÇ\n‚ä¢ Eq ((Homeomorph.piCongr e F) a‚úù i‚ÇÇ) (Eq.rec ((F (e.symm i‚ÇÇ)) (a‚úù (e.symm i‚ÇÇ))) ‚ãØ)","decl":"/-- `Equiv.piCongr` as a homeomorphism: this is the natural homeomorphism\n`Œ† i‚ÇÅ, Y‚ÇÅ i ‚âÉ‚Çú Œ† i‚ÇÇ, Y‚ÇÇ i‚ÇÇ` obtained from a bijection `Œπ‚ÇÅ ‚âÉ Œπ‚ÇÇ` and homeomorphisms\n`Y‚ÇÅ i‚ÇÅ ‚âÉ‚Çú Y‚ÇÇ (e i‚ÇÅ)` for each `i‚ÇÅ : Œπ‚ÇÅ`. -/\n@[simps! apply toEquiv]\ndef piCongr {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} {Y‚ÇÅ : Œπ‚ÇÅ ‚Üí Type*} {Y‚ÇÇ : Œπ‚ÇÇ ‚Üí Type*}\n    [‚àÄ i‚ÇÅ, TopologicalSpace (Y‚ÇÅ i‚ÇÅ)] [‚àÄ i‚ÇÇ, TopologicalSpace (Y‚ÇÇ i‚ÇÇ)]\n    (e : Œπ‚ÇÅ ‚âÉ Œπ‚ÇÇ) (F : ‚àÄ i‚ÇÅ, Y‚ÇÅ i‚ÇÅ ‚âÉ‚Çú Y‚ÇÇ (e i‚ÇÅ)) : (‚àÄ i‚ÇÅ, Y‚ÇÅ i‚ÇÅ) ‚âÉ‚Çú ‚àÄ i‚ÇÇ, Y‚ÇÇ i‚ÇÇ :=\n  (Homeomorph.piCongrRight F).trans (Homeomorph.piCongrLeft e)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: align the order of universes with `Equiv.ulift`\n"}
{"name":"Homeomorph.piCongr_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ‚ÇÅ : Type u_7\nŒπ‚ÇÇ : Type u_8\nY‚ÇÅ : Œπ‚ÇÅ ‚Üí Type u_9\nY‚ÇÇ : Œπ‚ÇÇ ‚Üí Type u_10\ninst‚úù¬π : (i‚ÇÅ : Œπ‚ÇÅ) ‚Üí TopologicalSpace (Y‚ÇÅ i‚ÇÅ)\ninst‚úù : (i‚ÇÇ : Œπ‚ÇÇ) ‚Üí TopologicalSpace (Y‚ÇÇ i‚ÇÇ)\ne : Equiv Œπ‚ÇÅ Œπ‚ÇÇ\nF : (i‚ÇÅ : Œπ‚ÇÅ) ‚Üí Homeomorph (Y‚ÇÅ i‚ÇÅ) (Y‚ÇÇ (e i‚ÇÅ))\n‚ä¢ Eq (Homeomorph.piCongr e F).toEquiv ((Equiv.piCongrRight fun i => (F i).toEquiv).trans (Equiv.piCongrLeft Y‚ÇÇ e))","decl":"/-- `Equiv.piCongr` as a homeomorphism: this is the natural homeomorphism\n`Œ† i‚ÇÅ, Y‚ÇÅ i ‚âÉ‚Çú Œ† i‚ÇÇ, Y‚ÇÇ i‚ÇÇ` obtained from a bijection `Œπ‚ÇÅ ‚âÉ Œπ‚ÇÇ` and homeomorphisms\n`Y‚ÇÅ i‚ÇÅ ‚âÉ‚Çú Y‚ÇÇ (e i‚ÇÅ)` for each `i‚ÇÅ : Œπ‚ÇÅ`. -/\n@[simps! apply toEquiv]\ndef piCongr {Œπ‚ÇÅ Œπ‚ÇÇ : Type*} {Y‚ÇÅ : Œπ‚ÇÅ ‚Üí Type*} {Y‚ÇÇ : Œπ‚ÇÇ ‚Üí Type*}\n    [‚àÄ i‚ÇÅ, TopologicalSpace (Y‚ÇÅ i‚ÇÅ)] [‚àÄ i‚ÇÇ, TopologicalSpace (Y‚ÇÇ i‚ÇÇ)]\n    (e : Œπ‚ÇÅ ‚âÉ Œπ‚ÇÇ) (F : ‚àÄ i‚ÇÅ, Y‚ÇÅ i‚ÇÅ ‚âÉ‚Çú Y‚ÇÇ (e i‚ÇÅ)) : (‚àÄ i‚ÇÅ, Y‚ÇÅ i‚ÇÅ) ‚âÉ‚Çú ‚àÄ i‚ÇÇ, Y‚ÇÇ i‚ÇÇ :=\n  (Homeomorph.piCongrRight F).trans (Homeomorph.piCongrLeft e)\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: align the order of universes with `Equiv.ulift`\n"}
{"name":"Homeomorph.sumArrowHomeomorphProdArrow_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Type u_7\nŒπ' : Type u_8\nf : Sum Œπ Œπ' ‚Üí X\n‚ä¢ Eq (Homeomorph.sumArrowHomeomorphProdArrow f) { fst := Function.comp f Sum.inl, snd := Function.comp f Sum.inr }","decl":"/-- The natural homeomorphism `(Œπ ‚äï Œπ' ‚Üí X) ‚âÉ‚Çú (Œπ ‚Üí X) √ó (Œπ' ‚Üí X)`.\n`Equiv.sumArrowEquivProdArrow` as a homeomorphism. -/\n@[simps!]\ndef sumArrowHomeomorphProdArrow {Œπ Œπ' : Type*} : (Œπ ‚äï Œπ' ‚Üí X) ‚âÉ‚Çú (Œπ ‚Üí X) √ó (Œπ' ‚Üí X)  where\n  toEquiv := Equiv.sumArrowEquivProdArrow _ _ _\n  continuous_toFun := by\n    simp only [Equiv.sumArrowEquivProdArrow, Equiv.coe_fn_mk, continuous_prod_mk]\n    continuity\n  continuous_invFun := continuous_pi fun i ‚Ü¶ match i with\n    | .inl i => by apply (continuous_apply _).comp' continuous_fst\n    | .inr i => by apply (continuous_apply _).comp' continuous_snd\n\n"}
{"name":"Homeomorph.sumArrowHomeomorphProdArrow_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nŒπ : Type u_7\nŒπ' : Type u_8\np : Prod (Œπ ‚Üí X) (Œπ' ‚Üí X)\na‚úù : Sum Œπ Œπ'\n‚ä¢ Eq (Homeomorph.sumArrowHomeomorphProdArrow.symm p a‚úù) (Sum.elim p.1 p.2 a‚úù)","decl":"/-- The natural homeomorphism `(Œπ ‚äï Œπ' ‚Üí X) ‚âÉ‚Çú (Œπ ‚Üí X) √ó (Œπ' ‚Üí X)`.\n`Equiv.sumArrowEquivProdArrow` as a homeomorphism. -/\n@[simps!]\ndef sumArrowHomeomorphProdArrow {Œπ Œπ' : Type*} : (Œπ ‚äï Œπ' ‚Üí X) ‚âÉ‚Çú (Œπ ‚Üí X) √ó (Œπ' ‚Üí X)  where\n  toEquiv := Equiv.sumArrowEquivProdArrow _ _ _\n  continuous_toFun := by\n    simp only [Equiv.sumArrowEquivProdArrow, Equiv.coe_fn_mk, continuous_prod_mk]\n    continuity\n  continuous_invFun := continuous_pi fun i ‚Ü¶ match i with\n    | .inl i => by apply (continuous_apply _).comp' continuous_fst\n    | .inr i => by apply (continuous_apply _).comp' continuous_snd\n\n"}
{"name":"Fin.continuous_append","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nm n : Nat\n‚ä¢ Continuous fun p => Fin.append p.1 p.2","decl":"theorem _root_.Fin.continuous_append (m n : ‚Ñï) :\n    Continuous fun (p : (Fin m ‚Üí X) √ó (Fin n ‚Üí X)) ‚Ü¶ Fin.append p.1 p.2 := by\n  suffices Continuous (Fin.appendEquiv m n) by exact this\n  rw [Fin.appendEquiv_eq_Homeomorph]\n  exact Homeomorph.continuous_toFun _\n\n"}
{"name":"Fin.appendHomeomorph_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nm n : Nat\nf : Fin (HAdd.hAdd m n) ‚Üí X\n‚ä¢ Eq ((Fin.appendHomeomorph m n).symm f) { fst := fun i => f (Fin.castAdd n i), snd := fun i => f (Fin.natAdd m i) }","decl":"/-- The natural homeomorphism between `(Fin m ‚Üí X) √ó (Fin n ‚Üí X)` and `Fin (m + n) ‚Üí X`.\n`Fin.appendEquiv` as a homeomorphism.-/\n@[simps!]\ndef _root_.Fin.appendHomeomorph (m n : ‚Ñï) : (Fin m ‚Üí X) √ó (Fin n ‚Üí X) ‚âÉ‚Çú (Fin (m + n) ‚Üí X) where\n  toEquiv := Fin.appendEquiv m n\n  continuous_toFun := Fin.continuous_append m n\n  continuous_invFun := by\n    rw [Fin.appendEquiv_eq_Homeomorph]\n    exact Homeomorph.continuous_invFun _\n\n"}
{"name":"Fin.appendHomeomorph_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nm n : Nat\nfg : Prod (Fin m ‚Üí X) (Fin n ‚Üí X)\na‚úù : Fin (HAdd.hAdd m n)\n‚ä¢ Eq ((Fin.appendHomeomorph m n) fg a‚úù) (Fin.append fg.1 fg.2 a‚úù)","decl":"/-- The natural homeomorphism between `(Fin m ‚Üí X) √ó (Fin n ‚Üí X)` and `Fin (m + n) ‚Üí X`.\n`Fin.appendEquiv` as a homeomorphism.-/\n@[simps!]\ndef _root_.Fin.appendHomeomorph (m n : ‚Ñï) : (Fin m ‚Üí X) √ó (Fin n ‚Üí X) ‚âÉ‚Çú (Fin (m + n) ‚Üí X) where\n  toEquiv := Fin.appendEquiv m n\n  continuous_toFun := Fin.continuous_append m n\n  continuous_invFun := by\n    rw [Fin.appendEquiv_eq_Homeomorph]\n    exact Homeomorph.continuous_invFun _\n\n"}
{"name":"Fin.appendHomeomorph_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\nm n : Nat\n‚ä¢ Eq (Fin.appendHomeomorph m n).toEquiv (Fin.appendEquiv m n)","decl":"@[simp]\ntheorem _root_.Fin.appendHomeomorph_toEquiv (m n : ‚Ñï) :\n    (Fin.appendHomeomorph (X := X) m n).toEquiv = Fin.appendEquiv m n :=\n  rfl\n\n"}
{"name":"Homeomorph.sumProdDistrib_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\na‚úù : Prod (Sum X Y) Z\n‚ä¢ Eq (Homeomorph.sumProdDistrib a‚úù) ((Equiv.sumProdDistrib X Y Z) a‚úù)","decl":"/-- `(X ‚äï Y) √ó Z` is homeomorphic to `X √ó Z ‚äï Y √ó Z`. -/\n@[simps!]\ndef sumProdDistrib : (X ‚äï Y) √ó Z ‚âÉ‚Çú (X √ó Z) ‚äï (Y √ó Z) :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sumProdDistrib X Y Z).symm\n        ((continuous_inl.prodMap continuous_id).sum_elim\n          (continuous_inr.prodMap continuous_id)) <|\n      (isOpenMap_inl.prodMap IsOpenMap.id).sum_elim (isOpenMap_inr.prodMap IsOpenMap.id)\n\n"}
{"name":"Homeomorph.sumProdDistrib_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\na‚úù : Sum (Prod X Z) (Prod Y Z)\n‚ä¢ Eq (Homeomorph.sumProdDistrib.symm a‚úù) ((Equiv.sumProdDistrib X Y Z).symm a‚úù)","decl":"/-- `(X ‚äï Y) √ó Z` is homeomorphic to `X √ó Z ‚äï Y √ó Z`. -/\n@[simps!]\ndef sumProdDistrib : (X ‚äï Y) √ó Z ‚âÉ‚Çú (X √ó Z) ‚äï (Y √ó Z) :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sumProdDistrib X Y Z).symm\n        ((continuous_inl.prodMap continuous_id).sum_elim\n          (continuous_inr.prodMap continuous_id)) <|\n      (isOpenMap_inl.prodMap IsOpenMap.id).sum_elim (isOpenMap_inr.prodMap IsOpenMap.id)\n\n"}
{"name":"Homeomorph.sigmaProdDistrib_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nŒπ : Type u_7\nX : Œπ ‚Üí Type u_8\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (X i)\na‚úù : Sigma fun i => Prod (X i) Y\n‚ä¢ Eq (Homeomorph.sigmaProdDistrib.symm a‚úù) { fst := ‚ü®a‚úù.fst, a‚úù.snd.1‚ü©, snd := a‚úù.snd.2 }","decl":"/-- `(Œ£ i, X i) √ó Y` is homeomorphic to `Œ£ i, (X i √ó Y)`. -/\n@[simps! apply symm_apply toEquiv]\ndef sigmaProdDistrib : (Œ£ i, X i) √ó Y ‚âÉ‚Çú Œ£ i, X i √ó Y :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sigmaProdDistrib X Y).symm\n      (continuous_sigma fun _ => continuous_sigmaMk.fst'.prod_mk continuous_snd)\n      (isOpenMap_sigma.2 fun _ => isOpenMap_sigmaMk.prodMap IsOpenMap.id)\n\n"}
{"name":"Homeomorph.sigmaProdDistrib_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nŒπ : Type u_7\nX : Œπ ‚Üí Type u_8\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (X i)\n‚ä¢ Eq Homeomorph.sigmaProdDistrib.toEquiv (Equiv.sigmaProdDistrib X Y)","decl":"/-- `(Œ£ i, X i) √ó Y` is homeomorphic to `Œ£ i, (X i √ó Y)`. -/\n@[simps! apply symm_apply toEquiv]\ndef sigmaProdDistrib : (Œ£ i, X i) √ó Y ‚âÉ‚Çú Œ£ i, X i √ó Y :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sigmaProdDistrib X Y).symm\n      (continuous_sigma fun _ => continuous_sigmaMk.fst'.prod_mk continuous_snd)\n      (isOpenMap_sigma.2 fun _ => isOpenMap_sigmaMk.prodMap IsOpenMap.id)\n\n"}
{"name":"Homeomorph.sigmaProdDistrib_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nŒπ : Type u_7\nX : Œπ ‚Üí Type u_8\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (X i)\na‚úù : Prod (Sigma fun i => X i) Y\n‚ä¢ Eq (Homeomorph.sigmaProdDistrib a‚úù) ‚ü®a‚úù.1.fst, { fst := a‚úù.1.snd, snd := a‚úù.2 }‚ü©","decl":"/-- `(Œ£ i, X i) √ó Y` is homeomorphic to `Œ£ i, (X i √ó Y)`. -/\n@[simps! apply symm_apply toEquiv]\ndef sigmaProdDistrib : (Œ£ i, X i) √ó Y ‚âÉ‚Çú Œ£ i, X i √ó Y :=\n  Homeomorph.symm <|\n    homeomorphOfContinuousOpen (Equiv.sigmaProdDistrib X Y).symm\n      (continuous_sigma fun _ => continuous_sigmaMk.fst'.prod_mk continuous_snd)\n      (isOpenMap_sigma.2 fun _ => isOpenMap_sigmaMk.prodMap IsOpenMap.id)\n\n"}
{"name":"Homeomorph.funUnique_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nX : Type u_8\ninst‚úù¬π : Unique Œπ\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (‚áë(Homeomorph.funUnique Œπ X).symm) uniqueElim","decl":"/-- If `Œπ` has a unique element, then `Œπ ‚Üí X` is homeomorphic to `X`. -/\n@[simps! (config := .asFn)]\ndef funUnique (Œπ X : Type*) [Unique Œπ] [TopologicalSpace X] : (Œπ ‚Üí X) ‚âÉ‚Çú X where\n  toEquiv := Equiv.funUnique Œπ X\n  continuous_toFun := continuous_apply _\n  continuous_invFun := continuous_pi fun _ => continuous_id\n\n"}
{"name":"Homeomorph.funUnique_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\nX : Type u_8\ninst‚úù¬π : Unique Œπ\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq ‚áë(Homeomorph.funUnique Œπ X) fun f => f Inhabited.default","decl":"/-- If `Œπ` has a unique element, then `Œπ ‚Üí X` is homeomorphic to `X`. -/\n@[simps! (config := .asFn)]\ndef funUnique (Œπ X : Type*) [Unique Œπ] [TopologicalSpace X] : (Œπ ‚Üí X) ‚âÉ‚Çú X where\n  toEquiv := Equiv.funUnique Œπ X\n  continuous_toFun := continuous_apply _\n  continuous_invFun := continuous_pi fun _ => continuous_id\n\n"}
{"name":"Homeomorph.piFinTwo_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Fin 2 ‚Üí Type u\ninst‚úù : (i : Fin 2) ‚Üí TopologicalSpace (X i)\n‚ä¢ Eq ‚áë(Homeomorph.piFinTwo X) fun f => { fst := f 0, snd := f 1 }","decl":"/-- Homeomorphism between dependent functions `Œ† i : Fin 2, X i` and `X 0 √ó X 1`. -/\n@[simps! (config := .asFn)]\ndef piFinTwo.{u} (X : Fin 2 ‚Üí Type u) [‚àÄ i, TopologicalSpace (X i)] : (‚àÄ i, X i) ‚âÉ‚Çú X 0 √ó X 1 where\n  toEquiv := piFinTwoEquiv X\n  continuous_toFun := (continuous_apply 0).prod_mk (continuous_apply 1)\n  continuous_invFun := continuous_pi <| Fin.forall_fin_two.2 ‚ü®continuous_fst, continuous_snd‚ü©\n\n"}
{"name":"Homeomorph.piFinTwo_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Fin 2 ‚Üí Type u\ninst‚úù : (i : Fin 2) ‚Üí TopologicalSpace (X i)\n‚ä¢ Eq ‚áë(Homeomorph.piFinTwo X).symm fun p => Fin.cons p.1 (Fin.cons p.2 finZeroElim)","decl":"/-- Homeomorphism between dependent functions `Œ† i : Fin 2, X i` and `X 0 √ó X 1`. -/\n@[simps! (config := .asFn)]\ndef piFinTwo.{u} (X : Fin 2 ‚Üí Type u) [‚àÄ i, TopologicalSpace (X i)] : (‚àÄ i, X i) ‚âÉ‚Çú X 0 √ó X 1 where\n  toEquiv := piFinTwoEquiv X\n  continuous_toFun := (continuous_apply 0).prod_mk (continuous_apply 1)\n  continuous_invFun := continuous_pi <| Fin.forall_fin_two.2 ‚ü®continuous_fst, continuous_snd‚ü©\n\n"}
{"name":"Homeomorph.finTwoArrow_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq ‚áëHomeomorph.finTwoArrow fun f => { fst := f 0, snd := f 1 }","decl":"/-- Homeomorphism between `X¬≤ = Fin 2 ‚Üí X` and `X √ó X`. -/\n@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 ‚Üí X) ‚âÉ‚Çú X √ó X :=\n  { piFinTwo fun _ => X with toEquiv := finTwoArrowEquiv X }\n\n"}
{"name":"Homeomorph.finTwoArrow_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq ‚áëHomeomorph.finTwoArrow.symm fun x => Matrix.vecCons x.1 (Matrix.vecCons x.2 Matrix.vecEmpty)","decl":"/-- Homeomorphism between `X¬≤ = Fin 2 ‚Üí X` and `X √ó X`. -/\n@[simps! (config := .asFn)]\ndef finTwoArrow : (Fin 2 ‚Üí X) ‚âÉ‚Çú X √ó X :=\n  { piFinTwo fun _ => X with toEquiv := finTwoArrowEquiv X }\n\n"}
{"name":"Homeomorph.image_symm_apply_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Homeomorph X Y\ns : Set X\ny : ‚Üë(Set.image (‚áëe.toEquiv) s)\n‚ä¢ Eq (‚Üë((e.image s).symm y)) (e.symm ‚Üëy)","decl":"/-- A subset of a topological space is homeomorphic to its image under a homeomorphism.\n-/\n@[simps!]\ndef image (e : X ‚âÉ‚Çú Y) (s : Set X) : s ‚âÉ‚Çú e '' s where\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: by continuity!\n  continuous_toFun := e.continuous.continuousOn.restrict_mapsTo (mapsTo_image _ _)\n  continuous_invFun := (e.symm.continuous.comp continuous_subtype_val).codRestrict _\n  toEquiv := e.toEquiv.image s\n\n"}
{"name":"Homeomorph.image_apply_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Homeomorph X Y\ns : Set X\nx : ‚Üës\n‚ä¢ Eq (‚Üë((e.image s) x)) (e ‚Üëx)","decl":"/-- A subset of a topological space is homeomorphic to its image under a homeomorphism.\n-/\n@[simps!]\ndef image (e : X ‚âÉ‚Çú Y) (s : Set X) : s ‚âÉ‚Çú e '' s where\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: by continuity!\n  continuous_toFun := e.continuous.continuousOn.restrict_mapsTo (mapsTo_image _ _)\n  continuous_invFun := (e.symm.continuous.comp continuous_subtype_val).codRestrict _\n  toEquiv := e.toEquiv.image s\n\n"}
{"name":"Homeomorph.Set.univ_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_7\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq (‚áë(Homeomorph.Set.univ X)) Subtype.val","decl":"/-- `Set.univ X` is homeomorphic to `X`. -/\n@[simps! (config := .asFn)]\ndef Set.univ (X : Type*) [TopologicalSpace X] : (univ : Set X) ‚âÉ‚Çú X where\n  toEquiv := Equiv.Set.univ X\n  continuous_toFun := continuous_subtype_val\n  continuous_invFun := continuous_id.subtype_mk _\n\n"}
{"name":"Homeomorph.Set.univ_symm_apply_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_7\ninst‚úù : TopologicalSpace X\na : X\n‚ä¢ Eq (‚Üë((Homeomorph.Set.univ X).symm a)) a","decl":"/-- `Set.univ X` is homeomorphic to `X`. -/\n@[simps! (config := .asFn)]\ndef Set.univ (X : Type*) [TopologicalSpace X] : (univ : Set X) ‚âÉ‚Çú X where\n  toEquiv := Equiv.Set.univ X\n  continuous_toFun := continuous_subtype_val\n  continuous_invFun := continuous_id.subtype_mk _\n\n"}
{"name":"Homeomorph.Set.prod_symm_apply_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : Prod (Subtype fun a => s a) (Subtype fun b => t b)\n‚ä¢ Eq ‚Üë((Homeomorph.Set.prod s t).symm x) { fst := ‚Üëx.1, snd := ‚Üëx.2 }","decl":"/-- `s √óÀ¢ t` is homeomorphic to `s √ó t`. -/\n@[simps!]\ndef Set.prod (s : Set X) (t : Set Y) : ‚Ü•(s √óÀ¢ t) ‚âÉ‚Çú s √ó t where\n  toEquiv := Equiv.Set.prod s t\n  continuous_toFun :=\n    (continuous_subtype_val.fst.subtype_mk _).prod_mk (continuous_subtype_val.snd.subtype_mk _)\n  continuous_invFun :=\n    (continuous_subtype_val.fst'.prod_mk continuous_subtype_val.snd').subtype_mk _\n\n"}
{"name":"Homeomorph.Set.prod_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ns : Set X\nt : Set Y\nx : Subtype fun c => And (s c.1) (t c.2)\n‚ä¢ Eq ((Homeomorph.Set.prod s t) x) { fst := ‚ü®(‚Üëx).1, ‚ãØ‚ü©, snd := ‚ü®(‚Üëx).2, ‚ãØ‚ü© }","decl":"/-- `s √óÀ¢ t` is homeomorphic to `s √ó t`. -/\n@[simps!]\ndef Set.prod (s : Set X) (t : Set Y) : ‚Ü•(s √óÀ¢ t) ‚âÉ‚Çú s √ó t where\n  toEquiv := Equiv.Set.prod s t\n  continuous_toFun :=\n    (continuous_subtype_val.fst.subtype_mk _).prod_mk (continuous_subtype_val.snd.subtype_mk _)\n  continuous_invFun :=\n    (continuous_subtype_val.fst'.prod_mk continuous_subtype_val.snd').subtype_mk _\n\n"}
{"name":"Homeomorph.piEquivPiSubtypeProd_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\np : Œπ ‚Üí Prop\nY : Œπ ‚Üí Type u_8\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Y i)\ninst‚úù : DecidablePred p\nf : (i : Œπ) ‚Üí Y i\n‚ä¢ Eq ((Homeomorph.piEquivPiSubtypeProd p Y) f) { fst := fun x => f ‚Üëx, snd := fun x => f ‚Üëx }","decl":"/-- The topological space `Œ† i, Y i` can be split as a product by separating the indices in Œπ\n  depending on whether they satisfy a predicate p or not. -/\n@[simps!]\ndef piEquivPiSubtypeProd (p : Œπ ‚Üí Prop) (Y : Œπ ‚Üí Type*) [‚àÄ i, TopologicalSpace (Y i)]\n    [DecidablePred p] : (‚àÄ i, Y i) ‚âÉ‚Çú (‚àÄ i : { x // p x }, Y i) √ó ‚àÄ i : { x // ¬¨p x }, Y i where\n  toEquiv := Equiv.piEquivPiSubtypeProd p Y\n  continuous_toFun := by\n    apply Continuous.prod_mk <;> exact continuous_pi fun j => continuous_apply j.1\n  continuous_invFun :=\n    continuous_pi fun j => by\n      dsimp only [Equiv.piEquivPiSubtypeProd]; split_ifs\n      exacts [(continuous_apply _).comp continuous_fst, (continuous_apply _).comp continuous_snd]\n\n"}
{"name":"Homeomorph.piEquivPiSubtypeProd_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\np : Œπ ‚Üí Prop\nY : Œπ ‚Üí Type u_8\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (Y i)\ninst‚úù : DecidablePred p\nf : Prod ((i : Subtype fun x => p x) ‚Üí Y ‚Üëi) ((i : Subtype fun x => Not (p x)) ‚Üí Y ‚Üëi)\nx : Œπ\n‚ä¢ Eq ((Homeomorph.piEquivPiSubtypeProd p Y).symm f x) (dite (p x) (fun h => f.1 ‚ü®x, h‚ü©) fun h => f.2 ‚ü®x, h‚ü©)","decl":"/-- The topological space `Œ† i, Y i` can be split as a product by separating the indices in Œπ\n  depending on whether they satisfy a predicate p or not. -/\n@[simps!]\ndef piEquivPiSubtypeProd (p : Œπ ‚Üí Prop) (Y : Œπ ‚Üí Type*) [‚àÄ i, TopologicalSpace (Y i)]\n    [DecidablePred p] : (‚àÄ i, Y i) ‚âÉ‚Çú (‚àÄ i : { x // p x }, Y i) √ó ‚àÄ i : { x // ¬¨p x }, Y i where\n  toEquiv := Equiv.piEquivPiSubtypeProd p Y\n  continuous_toFun := by\n    apply Continuous.prod_mk <;> exact continuous_pi fun j => continuous_apply j.1\n  continuous_invFun :=\n    continuous_pi fun j => by\n      dsimp only [Equiv.piEquivPiSubtypeProd]; split_ifs\n      exacts [(continuous_apply _).comp continuous_fst, (continuous_apply _).comp continuous_snd]\n\n"}
{"name":"Homeomorph.piSplitAt_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\ninst‚úù¬π : DecidableEq Œπ\ni : Œπ\nY : Œπ ‚Üí Type u_8\ninst‚úù : (j : Œπ) ‚Üí TopologicalSpace (Y j)\nf : Prod (Y i) ((j : Subtype fun j => Ne j i) ‚Üí Y ‚Üëj)\nj : Œπ\n‚ä¢ Eq ((Homeomorph.piSplitAt i Y).symm f j) (dite (Eq j i) (fun h => Eq.rec f.1 ‚ãØ) fun h => f.2 ‚ü®j, h‚ü©)","decl":"/-- A product of topological spaces can be split as the binary product of one of the spaces and\n  the product of all the remaining spaces. -/\n@[simps!]\ndef piSplitAt (Y : Œπ ‚Üí Type*) [‚àÄ j, TopologicalSpace (Y j)] :\n    (‚àÄ j, Y j) ‚âÉ‚Çú Y i √ó ‚àÄ j : { j // j ‚â† i }, Y j where\n  toEquiv := Equiv.piSplitAt i Y\n  continuous_toFun := (continuous_apply i).prod_mk (continuous_pi fun j => continuous_apply j.1)\n  continuous_invFun :=\n    continuous_pi fun j => by\n      dsimp only [Equiv.piSplitAt]\n      split_ifs with h\n      ¬∑ subst h\n        exact continuous_fst\n      ¬∑ exact (continuous_apply _).comp continuous_snd\n\n"}
{"name":"Homeomorph.piSplitAt_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_7\ninst‚úù¬π : DecidableEq Œπ\ni : Œπ\nY : Œπ ‚Üí Type u_8\ninst‚úù : (j : Œπ) ‚Üí TopologicalSpace (Y j)\nf : (j : Œπ) ‚Üí Y j\n‚ä¢ Eq ((Homeomorph.piSplitAt i Y) f) { fst := f i, snd := fun j => f ‚Üëj }","decl":"/-- A product of topological spaces can be split as the binary product of one of the spaces and\n  the product of all the remaining spaces. -/\n@[simps!]\ndef piSplitAt (Y : Œπ ‚Üí Type*) [‚àÄ j, TopologicalSpace (Y j)] :\n    (‚àÄ j, Y j) ‚âÉ‚Çú Y i √ó ‚àÄ j : { j // j ‚â† i }, Y j where\n  toEquiv := Equiv.piSplitAt i Y\n  continuous_toFun := (continuous_apply i).prod_mk (continuous_pi fun j => continuous_apply j.1)\n  continuous_invFun :=\n    continuous_pi fun j => by\n      dsimp only [Equiv.piSplitAt]\n      split_ifs with h\n      ¬∑ subst h\n        exact continuous_fst\n      ¬∑ exact (continuous_apply _).comp continuous_snd\n\n"}
{"name":"Homeomorph.funSplitAt_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nŒπ : Type u_7\ninst‚úù : DecidableEq Œπ\ni : Œπ\nf : (j : Œπ) ‚Üí (fun a => Y) j\n‚ä¢ Eq ((Homeomorph.funSplitAt Y i) f) { fst := f i, snd := fun j => f ‚Üëj }","decl":"/-- A product of copies of a topological space can be split as the binary product of one copy and\n  the product of all the remaining copies. -/\n@[simps!]\ndef funSplitAt : (Œπ ‚Üí Y) ‚âÉ‚Çú Y √ó ({ j // j ‚â† i } ‚Üí Y) :=\n  piSplitAt i _\n\n"}
{"name":"Homeomorph.funSplitAt_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"Y : Type u_2\ninst‚úù¬π : TopologicalSpace Y\nŒπ : Type u_7\ninst‚úù : DecidableEq Œπ\ni : Œπ\nf : Prod ((fun a => Y) i) ((j : Subtype fun j => Ne j i) ‚Üí (fun a => Y) ‚Üëj)\nj : Œπ\n‚ä¢ Eq ((Homeomorph.funSplitAt Y i).symm f j) (dite (Eq j i) (fun h => f.1) fun h => f.2 ‚ü®j, ‚ãØ‚ü©)","decl":"/-- A product of copies of a topological space can be split as the binary product of one copy and\n  the product of all the remaining copies. -/\n@[simps!]\ndef funSplitAt : (Œπ ‚Üí Y) ‚âÉ‚Çú Y √ó ({ j // j ‚â† i } ‚Üí Y) :=\n  piSplitAt i _\n\n"}
{"name":"Equiv.toHomeomorph_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nhe : ‚àÄ (s : Set Y), Iff (IsOpen (Set.preimage (‚áëe) s)) (IsOpen s)\n‚ä¢ Eq (e.toHomeomorph he).toEquiv e","decl":"/-- An equiv between topological spaces respecting openness is a homeomorphism. -/\n@[simps toEquiv]\ndef toHomeomorph (e : X ‚âÉ Y) (he : ‚àÄ s, IsOpen (e ‚Åª¬π' s) ‚Üî IsOpen s) : X ‚âÉ‚Çú Y where\n  toEquiv := e\n  continuous_toFun := continuous_def.2 fun _ ‚Ü¶ (he _).2\n  continuous_invFun := continuous_def.2 fun s ‚Ü¶ by convert (he _).1; simp\n\n"}
{"name":"Equiv.coe_toHomeomorph","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nhe : ‚àÄ (s : Set Y), Iff (IsOpen (Set.preimage (‚áëe) s)) (IsOpen s)\n‚ä¢ Eq ‚áë(e.toHomeomorph he) ‚áëe","decl":"@[simp] lemma coe_toHomeomorph (e : X ‚âÉ Y) (he) : ‚áë(e.toHomeomorph he) = e := rfl\n"}
{"name":"Equiv.toHomeomorph_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nhe : ‚àÄ (s : Set Y), Iff (IsOpen (Set.preimage (‚áëe) s)) (IsOpen s)\nx : X\n‚ä¢ Eq ((e.toHomeomorph he) x) (e x)","decl":"lemma toHomeomorph_apply (e : X ‚âÉ Y) (he) (x : X) : e.toHomeomorph he x = e x := rfl\n\n"}
{"name":"Equiv.toHomeomorph_refl","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ Eq ((Equiv.refl X).toHomeomorph ‚ãØ) (Homeomorph.refl X)","decl":"@[simp] lemma toHomeomorph_refl :\n  (Equiv.refl X).toHomeomorph (fun _s ‚Ü¶ Iff.rfl) = Homeomorph.refl _ := rfl\n\n"}
{"name":"Equiv.toHomeomorph_symm","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\ne : Equiv X Y\nhe : ‚àÄ (s : Set Y), Iff (IsOpen (Set.preimage (‚áëe) s)) (IsOpen s)\n‚ä¢ Eq (e.toHomeomorph he).symm (e.symm.toHomeomorph ‚ãØ)","decl":"@[simp] lemma toHomeomorph_symm (e : X ‚âÉ Y) (he) :\n  (e.toHomeomorph he).symm = e.symm.toHomeomorph fun s ‚Ü¶ by convert (he _).symm; simp := rfl\n\n"}
{"name":"Equiv.toHomeomorph_trans","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_5\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\ne : Equiv X Y\nf : Equiv Y Z\nhe : ‚àÄ (s : Set Y), Iff (IsOpen (Set.preimage (‚áëe) s)) (IsOpen s)\nhf : ‚àÄ (s : Set Z), Iff (IsOpen (Set.preimage (‚áëf) s)) (IsOpen s)\n‚ä¢ Eq ((e.trans f).toHomeomorph ‚ãØ) ((e.toHomeomorph he).trans (f.toHomeomorph hf))","decl":"lemma toHomeomorph_trans (e : X ‚âÉ Y) (f : Y ‚âÉ Z) (he hf) :\n    (e.trans f).toHomeomorph (fun _s ‚Ü¶ (he _).trans (hf _)) =\n    (e.toHomeomorph he).trans (f.toHomeomorph hf) := rfl\n\n"}
{"name":"Equiv.toHomeomorphOfIsInducing_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : Equiv X Y\nhf : Topology.IsInducing ‚áëf\n‚ä¢ Eq (f.toHomeomorphOfIsInducing hf).toEquiv f","decl":"/-- An inducing equiv between topological spaces is a homeomorphism. -/\n@[simps toEquiv] -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11215): TODO: was `@[simps]`\ndef toHomeomorphOfIsInducing (f : X ‚âÉ Y) (hf : IsInducing f) : X ‚âÉ‚Çú Y :=\n  { f with\n    continuous_toFun := hf.continuous\n    continuous_invFun := hf.continuous_iff.2 <| by simpa using continuous_id }\n\n"}
{"name":"Continuous.continuous_symm_of_equiv_compact_to_t2","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : CompactSpace X\ninst‚úù : T2Space Y\nf : Equiv X Y\nhf : Continuous ‚áëf\n‚ä¢ Continuous ‚áëf.symm","decl":"theorem continuous_symm_of_equiv_compact_to_t2 [CompactSpace X] [T2Space Y] {f : X ‚âÉ Y}\n    (hf : Continuous f) : Continuous f.symm := by\n  rw [continuous_iff_isClosed]\n  intro C hC\n  have hC' : IsClosed (f '' C) := (hC.isCompact.image hf).isClosed\n  rwa [Equiv.image_eq_preimage] at hC'\n\n"}
{"name":"Continuous.homeoOfEquivCompactToT2_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : CompactSpace X\ninst‚úù : T2Space Y\nf : Equiv X Y\nhf : Continuous ‚áëf\n‚ä¢ Eq hf.homeoOfEquivCompactToT2.toEquiv f","decl":"/-- Continuous equivalences from a compact space to a T2 space are homeomorphisms.\n\nThis is not true when T2 is weakened to T1\n(see `Continuous.homeoOfEquivCompactToT2.t1_counterexample`). -/\n@[simps toEquiv] -- Porting note: was `@[simps]`\ndef homeoOfEquivCompactToT2 [CompactSpace X] [T2Space Y] {f : X ‚âÉ Y} (hf : Continuous f) : X ‚âÉ‚Çú Y :=\n  { f with\n    continuous_toFun := hf\n    continuous_invFun := hf.continuous_symm_of_equiv_compact_to_t2 }\n\n"}
{"name":"IsHomeomorph.isOpenMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nself : IsHomeomorph f\n‚ä¢ IsOpenMap f","decl":"/-- Predicate saying that `f` is a homeomorphism.\n\nThis should be used only when `f` is a concrete function whose continuous inverse is not easy to\nwrite down. Otherwise, `Homeomorph` should be preferred as it bundles the continuous inverse.\n\nHaving both `Homeomorph` and `IsHomeomorph` is justified by the fact that so many function\nproperties are unbundled in the topology part of the library, and by the fact that a homeomorphism\nis not merely a continuous bijection, that is `IsHomeomorph f` is not equivalent to\n`Continuous f ‚àß Bijective f` but to `Continuous f ‚àß Bijective f ‚àß IsOpenMap f`. -/\nstructure IsHomeomorph (f : X ‚Üí Y) : Prop where\n  continuous : Continuous f\n  isOpenMap : IsOpenMap f\n  bijective : Bijective f\n\n"}
{"name":"IsHomeomorph.continuous","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nself : IsHomeomorph f\n‚ä¢ Continuous f","decl":"/-- Predicate saying that `f` is a homeomorphism.\n\nThis should be used only when `f` is a concrete function whose continuous inverse is not easy to\nwrite down. Otherwise, `Homeomorph` should be preferred as it bundles the continuous inverse.\n\nHaving both `Homeomorph` and `IsHomeomorph` is justified by the fact that so many function\nproperties are unbundled in the topology part of the library, and by the fact that a homeomorphism\nis not merely a continuous bijection, that is `IsHomeomorph f` is not equivalent to\n`Continuous f ‚àß Bijective f` but to `Continuous f ‚àß Bijective f ‚àß IsOpenMap f`. -/\nstructure IsHomeomorph (f : X ‚Üí Y) : Prop where\n  continuous : Continuous f\n  isOpenMap : IsOpenMap f\n  bijective : Bijective f\n\n"}
{"name":"IsHomeomorph.bijective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nself : IsHomeomorph f\n‚ä¢ Function.Bijective f","decl":"/-- Predicate saying that `f` is a homeomorphism.\n\nThis should be used only when `f` is a concrete function whose continuous inverse is not easy to\nwrite down. Otherwise, `Homeomorph` should be preferred as it bundles the continuous inverse.\n\nHaving both `Homeomorph` and `IsHomeomorph` is justified by the fact that so many function\nproperties are unbundled in the topology part of the library, and by the fact that a homeomorphism\nis not merely a continuous bijection, that is `IsHomeomorph f` is not equivalent to\n`Continuous f ‚àß Bijective f` but to `Continuous f ‚àß Bijective f ‚àß IsOpenMap f`. -/\nstructure IsHomeomorph (f : X ‚Üí Y) : Prop where\n  continuous : Continuous f\n  isOpenMap : IsOpenMap f\n  bijective : Bijective f\n\n"}
{"name":"Homeomorph.isHomeomorph","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nh : Homeomorph X Y\n‚ä¢ IsHomeomorph ‚áëh","decl":"protected theorem Homeomorph.isHomeomorph (h : X ‚âÉ‚Çú Y) : IsHomeomorph h :=\n  ‚ü®h.continuous, h.isOpenMap, h.bijective‚ü©\n\n"}
{"name":"IsHomeomorph.injective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Function.Injective f","decl":"protected lemma injective : Function.Injective f := hf.bijective.injective\n"}
{"name":"IsHomeomorph.surjective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Function.Surjective f","decl":"protected lemma surjective : Function.Surjective f := hf.bijective.surjective\n\n"}
{"name":"IsHomeomorph.homeomorph_symm_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\nb : Y\n‚ä¢ Eq ((IsHomeomorph.homeomorph f hf).symm b) (Function.surjInv ‚ãØ b)","decl":"variable (f) in\n/-- Bundled homeomorphism constructed from a map that is a homeomorphism. -/\n@[simps! toEquiv apply symm_apply]\nnoncomputable def homeomorph : X ‚âÉ‚Çú Y where\n  continuous_toFun := hf.1\n  continuous_invFun := by\n    rw [continuous_iff_continuousOn_univ, ‚Üê hf.bijective.2.range_eq]\n    exact hf.isOpenMap.continuousOn_range_of_leftInverse (leftInverse_surjInv hf.bijective)\n  toEquiv := Equiv.ofBijective f hf.bijective\n\n"}
{"name":"IsHomeomorph.homeomorph_apply","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\na‚úù : X\n‚ä¢ Eq ((IsHomeomorph.homeomorph f hf) a‚úù) (f a‚úù)","decl":"variable (f) in\n/-- Bundled homeomorphism constructed from a map that is a homeomorphism. -/\n@[simps! toEquiv apply symm_apply]\nnoncomputable def homeomorph : X ‚âÉ‚Çú Y where\n  continuous_toFun := hf.1\n  continuous_invFun := by\n    rw [continuous_iff_continuousOn_univ, ‚Üê hf.bijective.2.range_eq]\n    exact hf.isOpenMap.continuousOn_range_of_leftInverse (leftInverse_surjInv hf.bijective)\n  toEquiv := Equiv.ofBijective f hf.bijective\n\n"}
{"name":"IsHomeomorph.homeomorph_toEquiv","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Eq (IsHomeomorph.homeomorph f hf).toEquiv (Equiv.ofBijective f ‚ãØ)","decl":"variable (f) in\n/-- Bundled homeomorphism constructed from a map that is a homeomorphism. -/\n@[simps! toEquiv apply symm_apply]\nnoncomputable def homeomorph : X ‚âÉ‚Çú Y where\n  continuous_toFun := hf.1\n  continuous_invFun := by\n    rw [continuous_iff_continuousOn_univ, ‚Üê hf.bijective.2.range_eq]\n    exact hf.isOpenMap.continuousOn_range_of_leftInverse (leftInverse_surjInv hf.bijective)\n  toEquiv := Equiv.ofBijective f hf.bijective\n\n"}
{"name":"IsHomeomorph.isClosedMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ IsClosedMap f","decl":"protected lemma isClosedMap : IsClosedMap f := (hf.homeomorph f).isClosedMap\n"}
{"name":"IsHomeomorph.isInducing","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsInducing f","decl":"lemma isInducing : IsInducing f := (hf.homeomorph f).isInducing\n"}
{"name":"IsHomeomorph.isQuotientMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsQuotientMap f","decl":"lemma isQuotientMap : IsQuotientMap f := (hf.homeomorph f).isQuotientMap\n"}
{"name":"IsHomeomorph.isEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsEmbedding f","decl":"lemma isEmbedding : IsEmbedding f := (hf.homeomorph f).isEmbedding\n"}
{"name":"IsHomeomorph.isOpenEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"lemma isOpenEmbedding : IsOpenEmbedding f := (hf.homeomorph f).isOpenEmbedding\n"}
{"name":"IsHomeomorph.isClosedEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"lemma isClosedEmbedding : IsClosedEmbedding f := (hf.homeomorph f).isClosedEmbedding\n"}
{"name":"IsHomeomorph.isDenseEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ IsDenseEmbedding f","decl":"lemma isDenseEmbedding : IsDenseEmbedding f := (hf.homeomorph f).isDenseEmbedding\n\n"}
{"name":"IsHomeomorph.inducing","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsInducing f","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing := isInducing\n\n"}
{"name":"IsHomeomorph.embedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsEmbedding f","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding := isEmbedding\n\n"}
{"name":"IsHomeomorph.quotientMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsQuotientMap f","decl":"@[deprecated (since := \"2024-10-22\")]\nalias quotientMap := isQuotientMap\n\n"}
{"name":"IsHomeomorph.closedEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsClosedEmbedding f","decl":"@[deprecated (since := \"2024-10-20\")] alias closedEmbedding := isClosedEmbedding\n"}
{"name":"IsHomeomorph.openEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ Topology.IsOpenEmbedding f","decl":"@[deprecated (since := \"2024-10-18\")]\nalias openEmbedding := isOpenEmbedding\n\n"}
{"name":"IsHomeomorph.denseEmbedding","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\nhf : IsHomeomorph f\n‚ä¢ IsDenseEmbedding f","decl":"@[deprecated (since := \"2024-09-30\")]\nalias denseEmbedding := isDenseEmbedding\n\n"}
{"name":"isHomeomorph_iff_exists_homeomorph","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (IsHomeomorph f) (Exists fun h => Eq (‚áëh) f)","decl":"/-- A map is a homeomorphism iff it is the map underlying a bundled homeomorphism `h : X ‚âÉ‚Çú Y`. -/\nlemma isHomeomorph_iff_exists_homeomorph : IsHomeomorph f ‚Üî ‚àÉ h : X ‚âÉ‚Çú Y, h = f :=\n  ‚ü®fun hf => ‚ü®hf.homeomorph f, rfl‚ü©, fun ‚ü®h, h'‚ü© => h' ‚ñ∏ h.isHomeomorph‚ü©\n\n"}
{"name":"isHomeomorph_iff_exists_inverse","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (IsHomeomorph f) (And (Continuous f) (Exists fun g => And (Function.LeftInverse g f) (And (Function.RightInverse g f) (Continuous g))))","decl":"/-- A map is a homeomorphism iff it is continuous and has a continuous inverse. -/\nlemma isHomeomorph_iff_exists_inverse : IsHomeomorph f ‚Üî Continuous f ‚àß ‚àÉ g : Y ‚Üí X,\n    LeftInverse g f ‚àß RightInverse g f ‚àß Continuous g := by\n  refine ‚ü®fun hf ‚Ü¶ ‚ü®hf.continuous, ?_‚ü©, fun ‚ü®hf, g, hg‚ü© ‚Ü¶ ?_‚ü©\n  ¬∑ let h := hf.homeomorph f\n    exact ‚ü®h.symm, h.left_inv, h.right_inv, h.continuous_invFun‚ü©\n  ¬∑ exact (Homeomorph.mk ‚ü®f, g, hg.1, hg.2.1‚ü© hf hg.2.2).isHomeomorph\n\n"}
{"name":"isHomeomorph_iff_isEmbedding_surjective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (IsHomeomorph f) (And (Topology.IsEmbedding f) (Function.Surjective f))","decl":"/-- A map is a homeomorphism iff it is a surjective embedding. -/\nlemma isHomeomorph_iff_isEmbedding_surjective : IsHomeomorph f ‚Üî IsEmbedding f ‚àß Surjective f where\n  mp hf := ‚ü®hf.isEmbedding, hf.surjective‚ü©\n  mpr h := ‚ü®h.1.continuous, ((isOpenEmbedding_iff f).2 ‚ü®h.1, h.2.range_eq ‚ñ∏ isOpen_univ‚ü©).isOpenMap,\n    h.1.injective, h.2‚ü©\n\n"}
{"name":"isHomeomorph_iff_embedding_surjective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (IsHomeomorph f) (And (Topology.IsEmbedding f) (Function.Surjective f))","decl":"@[deprecated (since := \"2024-10-26\")]\nalias isHomeomorph_iff_embedding_surjective := isHomeomorph_iff_isEmbedding_surjective\n\n"}
{"name":"isHomeomorph_iff_continuous_isClosedMap_bijective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬π : TopologicalSpace X\ninst‚úù : TopologicalSpace Y\nf : X ‚Üí Y\n‚ä¢ Iff (IsHomeomorph f) (And (Continuous f) (And (IsClosedMap f) (Function.Bijective f)))","decl":"/-- A map is a homeomorphism iff it is continuous, closed and bijective. -/\nlemma isHomeomorph_iff_continuous_isClosedMap_bijective  : IsHomeomorph f ‚Üî\n    Continuous f ‚àß IsClosedMap f ‚àß Function.Bijective f :=\n  ‚ü®fun hf => ‚ü®hf.continuous, hf.isClosedMap, hf.bijective‚ü©, fun ‚ü®hf, hf', hf''‚ü© =>\n    ‚ü®hf, fun _ hu => isClosed_compl_iff.1 (image_compl_eq hf'' ‚ñ∏ hf' _ hu.isClosed_compl), hf''‚ü©‚ü©\n\n"}
{"name":"isHomeomorph_iff_continuous_bijective","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\nf : X ‚Üí Y\ninst‚úù¬π : CompactSpace X\ninst‚úù : T2Space Y\n‚ä¢ Iff (IsHomeomorph f) (And (Continuous f) (Function.Bijective f))","decl":"/-- A map from a compact space to a T2 space is a homeomorphism iff it is continuous and\n  bijective. -/\nlemma isHomeomorph_iff_continuous_bijective [CompactSpace X] [T2Space Y] :\n    IsHomeomorph f ‚Üî Continuous f ‚àß Bijective f := by\n  rw [isHomeomorph_iff_continuous_isClosedMap_bijective]\n  refine and_congr_right fun hf ‚Ü¶ ?_\n  rw [eq_true hf.isClosedMap, true_and]\n\n"}
{"name":"IsHomeomorph.id","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\ninst‚úù : TopologicalSpace X\n‚ä¢ IsHomeomorph id","decl":"protected lemma IsHomeomorph.id : IsHomeomorph (@id X) := ‚ü®continuous_id, .id, bijective_id‚ü©\n\n"}
{"name":"IsHomeomorph.comp","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≤ : TopologicalSpace X\ninst‚úù¬π : TopologicalSpace Y\ninst‚úù : TopologicalSpace Z\nf : X ‚Üí Y\ng : Y ‚Üí Z\nhg : IsHomeomorph g\nhf : IsHomeomorph f\n‚ä¢ IsHomeomorph (Function.comp g f)","decl":"lemma IsHomeomorph.comp {g : Y ‚Üí Z} (hg : IsHomeomorph g) (hf : IsHomeomorph f) :\n    IsHomeomorph (g ‚àò f) := ‚ü®hg.1.comp hf.1, hg.2.comp hf.2, hg.3.comp hf.3‚ü©\n\n"}
{"name":"IsHomeomorph.sumMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\nW : Type u_5\ninst‚úù : TopologicalSpace W\nf : X ‚Üí Y\ng : Z ‚Üí W\nhf : IsHomeomorph f\nhg : IsHomeomorph g\n‚ä¢ IsHomeomorph (Sum.map f g)","decl":"lemma IsHomeomorph.sumMap {g : Z ‚Üí W} (hf : IsHomeomorph f) (hg : IsHomeomorph g) :\n    IsHomeomorph (Sum.map f g) := ‚ü®hf.1.sum_map hg.1, hf.2.sumMap hg.2, hf.3.sum_map hg.3‚ü©\n\n"}
{"name":"IsHomeomorph.prodMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"X : Type u_1\nY : Type u_2\nZ : Type u_4\ninst‚úù¬≥ : TopologicalSpace X\ninst‚úù¬≤ : TopologicalSpace Y\ninst‚úù¬π : TopologicalSpace Z\nW : Type u_5\ninst‚úù : TopologicalSpace W\nf : X ‚Üí Y\ng : Z ‚Üí W\nhf : IsHomeomorph f\nhg : IsHomeomorph g\n‚ä¢ IsHomeomorph (Prod.map f g)","decl":"lemma IsHomeomorph.prodMap {g : Z ‚Üí W} (hf : IsHomeomorph f) (hg : IsHomeomorph g) :\n    IsHomeomorph (Prod.map f g) := ‚ü®hf.1.prodMap hg.1, hf.2.prodMap hg.2, hf.3.prodMap hg.3‚ü©\n\n"}
{"name":"IsHomeomorph.sigmaMap","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_6\nŒ∫ : Type u_7\nX : Œπ ‚Üí Type u_8\nY : Œ∫ ‚Üí Type u_9\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : (i : Œ∫) ‚Üí TopologicalSpace (Y i)\nf : Œπ ‚Üí Œ∫\nhf : Function.Bijective f\ng : (i : Œπ) ‚Üí X i ‚Üí Y (f i)\nhg : ‚àÄ (i : Œπ), IsHomeomorph (g i)\n‚ä¢ IsHomeomorph (Sigma.map f g)","decl":"lemma IsHomeomorph.sigmaMap {Œπ Œ∫ : Type*} {X : Œπ ‚Üí Type*} {Y : Œ∫ ‚Üí Type*}\n    [‚àÄ i, TopologicalSpace (X i)] [‚àÄ i, TopologicalSpace (Y i)] {f : Œπ ‚Üí Œ∫}\n    (hf : Bijective f) {g : (i : Œπ) ‚Üí X i ‚Üí Y (f i)} (hg : ‚àÄ i, IsHomeomorph (g i)) :\n    IsHomeomorph (Sigma.map f g) := by\n  simp_rw [isHomeomorph_iff_isEmbedding_surjective,] at hg ‚ä¢\n  exact ‚ü®(isEmbedding_sigmaMap hf.1).2 fun i ‚Ü¶ (hg i).1, hf.2.sigma_map fun i ‚Ü¶ (hg i).2‚ü©\n\n"}
{"name":"IsHomeomorph.pi_map","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œπ : Type u_6\nX : Œπ ‚Üí Type u_7\nY : Œπ ‚Üí Type u_8\ninst‚úù¬π : (i : Œπ) ‚Üí TopologicalSpace (X i)\ninst‚úù : (i : Œπ) ‚Üí TopologicalSpace (Y i)\nf : (i : Œπ) ‚Üí X i ‚Üí Y i\nh : ‚àÄ (i : Œπ), IsHomeomorph (f i)\n‚ä¢ IsHomeomorph fun x i => f i (x i)","decl":"lemma IsHomeomorph.pi_map {Œπ : Type*} {X Y : Œπ ‚Üí Type*} [‚àÄ i, TopologicalSpace (X i)]\n    [‚àÄ i, TopologicalSpace (Y i)] {f : (i : Œπ) ‚Üí X i ‚Üí Y i} (h : ‚àÄ i, IsHomeomorph (f i)) :\n    IsHomeomorph (fun (x : ‚àÄ i, X i) i ‚Ü¶ f i (x i)) :=\n  (Homeomorph.piCongrRight fun i ‚Ü¶ (h i).homeomorph (f i)).isHomeomorph\n\n"}
{"name":"HomeomorphClass.inv_continuous","module":"Mathlib.Topology.Homeomorph","initialProofState":"F : Type u_6\nA : outParam (Type u_7)\nB : outParam (Type u_8)\ninst‚úù¬π : TopologicalSpace A\ninst‚úù : TopologicalSpace B\nh : EquivLike F A B\nself : HomeomorphClass F A B\nf : F\n‚ä¢ Continuous (EquivLike.inv f)","decl":"/-- `HomeomorphClass F A B` states that `F` is a type of homeomorphisms.-/\nclass HomeomorphClass (F : Type*) (A B : outParam Type*)\n    [TopologicalSpace A] [TopologicalSpace B] [h : EquivLike F A B] : Prop where\n  map_continuous : ‚àÄ (f : F), Continuous f\n  inv_continuous : ‚àÄ (f : F), Continuous (h.inv f)\n\n"}
{"name":"HomeomorphClass.map_continuous","module":"Mathlib.Topology.Homeomorph","initialProofState":"F : Type u_6\nA : outParam (Type u_7)\nB : outParam (Type u_8)\ninst‚úù¬π : TopologicalSpace A\ninst‚úù : TopologicalSpace B\nh : EquivLike F A B\nself : HomeomorphClass F A B\nf : F\n‚ä¢ Continuous ‚áëf","decl":"/-- `HomeomorphClass F A B` states that `F` is a type of homeomorphisms.-/\nclass HomeomorphClass (F : Type*) (A B : outParam Type*)\n    [TopologicalSpace A] [TopologicalSpace B] [h : EquivLike F A B] : Prop where\n  map_continuous : ‚àÄ (f : F), Continuous f\n  inv_continuous : ‚àÄ (f : F), Continuous (h.inv f)\n\n"}
{"name":"HomeomorphClass.coe_coe","module":"Mathlib.Topology.Homeomorph","initialProofState":"F : Type u_6\nŒ± : Type u_7\nŒ≤ : Type u_8\ninst‚úù¬≤ : TopologicalSpace Œ±\ninst‚úù¬π : TopologicalSpace Œ≤\ninst‚úù : EquivLike F Œ± Œ≤\nh : HomeomorphClass F Œ± Œ≤\nf : F\n‚ä¢ Eq ‚áë‚Üëf ‚áëf","decl":"@[simp]\ntheorem coe_coe [h : HomeomorphClass F Œ± Œ≤] (f : F) : ‚áë(h.toHomeomorph f) = ‚áëf := rfl\n\n"}
{"name":"HomeomorphClass.toHomeomorph_injective","module":"Mathlib.Topology.Homeomorph","initialProofState":"F : Type u_6\nŒ± : Type u_7\nŒ≤ : Type u_8\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : EquivLike F Œ± Œ≤\ninst‚úù : HomeomorphClass F Œ± Œ≤\n‚ä¢ Function.Injective HomeomorphClass.toHomeomorph","decl":"theorem toHomeomorph_injective [HomeomorphClass F Œ± Œ≤] : Function.Injective ((‚Üë) : F ‚Üí Œ± ‚âÉ‚Çú Œ≤) :=\n  fun _ _ e ‚Ü¶ DFunLike.ext _ _ fun a ‚Ü¶ congr_arg (fun e : Œ± ‚âÉ‚Çú Œ≤ ‚Ü¶ e.toFun a) e\n\n"}
{"name":"HomeomorphClass.instContinuousMapClass","module":"Mathlib.Topology.Homeomorph","initialProofState":"F : Type u_6\nŒ± : Type u_7\nŒ≤ : Type u_8\ninst‚úù¬≥ : TopologicalSpace Œ±\ninst‚úù¬≤ : TopologicalSpace Œ≤\ninst‚úù¬π : EquivLike F Œ± Œ≤\ninst‚úù : HomeomorphClass F Œ± Œ≤\n‚ä¢ ContinuousMapClass F Œ± Œ≤","decl":"instance [HomeomorphClass F Œ± Œ≤] : ContinuousMapClass F Œ± Œ≤ where\n  map_continuous  f := map_continuous f\n\n"}
{"name":"HomeomorphClass.instHomeomorph","module":"Mathlib.Topology.Homeomorph","initialProofState":"Œ± : Type u_7\nŒ≤ : Type u_8\ninst‚úù¬π : TopologicalSpace Œ±\ninst‚úù : TopologicalSpace Œ≤\n‚ä¢ HomeomorphClass (Homeomorph Œ± Œ≤) Œ± Œ≤","decl":"instance : HomeomorphClass (Œ± ‚âÉ‚Çú Œ≤) Œ± Œ≤ where\n  map_continuous e := e.continuous_toFun\n  inv_continuous e := e.continuous_invFun\n\n"}
