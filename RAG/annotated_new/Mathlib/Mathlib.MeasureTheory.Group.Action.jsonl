{"name":"MeasureTheory.VAddInvariantMeasure.zero","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝¹ : MeasurableSpace α\ninst✝ : VAdd M α\n⊢ MeasureTheory.VAddInvariantMeasure M α 0","decl":"@[to_additive]\ninstance zero [MeasurableSpace α] [SMul M α] : SMulInvariantMeasure M α (0 : Measure α) :=\n  ⟨fun _ _ _ => rfl⟩\n\n"}
{"name":"MeasureTheory.SMulInvariantMeasure.zero","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝¹ : MeasurableSpace α\ninst✝ : SMul M α\n⊢ MeasureTheory.SMulInvariantMeasure M α 0","decl":"@[to_additive]\ninstance zero [MeasurableSpace α] [SMul M α] : SMulInvariantMeasure M α (0 : Measure α) :=\n  ⟨fun _ _ _ => rfl⟩\n\n"}
{"name":"MeasureTheory.VAddInvariantMeasure.add","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝² : VAdd M α\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.VAddInvariantMeasure M α μ\ninst✝ : MeasureTheory.VAddInvariantMeasure M α ν\n⊢ MeasureTheory.VAddInvariantMeasure M α (HAdd.hAdd μ ν)","decl":"@[to_additive]\ninstance add [SMulInvariantMeasure M α μ] [SMulInvariantMeasure M α ν] :\n    SMulInvariantMeasure M α (μ + ν) :=\n  ⟨fun c _s hs =>\n    show _ + _ = _ + _ from\n      congr_arg₂ (· + ·) (measure_preimage_smul c hs) (measure_preimage_smul c hs)⟩\n\n"}
{"name":"MeasureTheory.SMulInvariantMeasure.add","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝² : SMul M α\nm : MeasurableSpace α\nμ ν : MeasureTheory.Measure α\ninst✝¹ : MeasureTheory.SMulInvariantMeasure M α μ\ninst✝ : MeasureTheory.SMulInvariantMeasure M α ν\n⊢ MeasureTheory.SMulInvariantMeasure M α (HAdd.hAdd μ ν)","decl":"@[to_additive]\ninstance add [SMulInvariantMeasure M α μ] [SMulInvariantMeasure M α ν] :\n    SMulInvariantMeasure M α (μ + ν) :=\n  ⟨fun c _s hs =>\n    show _ + _ = _ + _ from\n      congr_arg₂ (· + ·) (measure_preimage_smul c hs) (measure_preimage_smul c hs)⟩\n\n"}
{"name":"MeasureTheory.VAddInvariantMeasure.vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝¹ : VAdd M α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure M α μ\nc : ENNReal\n⊢ MeasureTheory.VAddInvariantMeasure M α (HSMul.hSMul c μ)","decl":"@[to_additive]\ninstance smul [SMulInvariantMeasure M α μ] (c : ℝ≥0∞) : SMulInvariantMeasure M α (c • μ) :=\n  ⟨fun a _s hs => show c • _ = c • _ from congr_arg (c • ·) (measure_preimage_smul a hs)⟩\n\n"}
{"name":"MeasureTheory.SMulInvariantMeasure.smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝¹ : SMul M α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure M α μ\nc : ENNReal\n⊢ MeasureTheory.SMulInvariantMeasure M α (HSMul.hSMul c μ)","decl":"@[to_additive]\ninstance smul [SMulInvariantMeasure M α μ] (c : ℝ≥0∞) : SMulInvariantMeasure M α (c • μ) :=\n  ⟨fun a _s hs => show c • _ = c • _ from congr_arg (c • ·) (measure_preimage_smul a hs)⟩\n\n"}
{"name":"MeasureTheory.VAddInvariantMeasure.vadd_nnreal","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝¹ : VAdd M α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure M α μ\nc : NNReal\n⊢ MeasureTheory.VAddInvariantMeasure M α (HSMul.hSMul c μ)","decl":"@[to_additive]\ninstance smul_nnreal [SMulInvariantMeasure M α μ] (c : ℝ≥0) : SMulInvariantMeasure M α (c • μ) :=\n  SMulInvariantMeasure.smul c\n\n"}
{"name":"MeasureTheory.SMulInvariantMeasure.smul_nnreal","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\ninst✝¹ : SMul M α\nm : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure M α μ\nc : NNReal\n⊢ MeasureTheory.SMulInvariantMeasure M α (HSMul.hSMul c μ)","decl":"@[to_additive]\ninstance smul_nnreal [SMulInvariantMeasure M α μ] (c : ℝ≥0) : SMulInvariantMeasure M α (c • μ) :=\n  SMulInvariantMeasure.smul c\n\n"}
{"name":"MeasureTheory.measure_preimage_vadd_le","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : VAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ LE.le (μ (Set.preimage (fun x => HVAdd.hVAdd c x) s)) (μ s)","decl":"/-- See also `measure_preimage_smul_of_nullMeasurableSet` and `measure_preimage_smul`. -/\n@[to_additive \"See also `measure_preimage_smul_of_nullMeasurableSet` and `measure_preimage_smul`.\"]\ntheorem measure_preimage_smul_le (c : G) (s : Set α) : μ ((c • ·) ⁻¹' s) ≤ μ s :=\n  (outerMeasure_le_iff (m := .map (c • ·) μ.1)).2\n    (fun _s hs ↦ (SMulInvariantMeasure.measure_preimage_smul _ hs).le) _\n\n"}
{"name":"MeasureTheory.measure_preimage_smul_le","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : SMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ LE.le (μ (Set.preimage (fun x => HSMul.hSMul c x) s)) (μ s)","decl":"/-- See also `measure_preimage_smul_of_nullMeasurableSet` and `measure_preimage_smul`. -/\n@[to_additive \"See also `measure_preimage_smul_of_nullMeasurableSet` and `measure_preimage_smul`.\"]\ntheorem measure_preimage_smul_le (c : G) (s : Set α) : μ ((c • ·) ⁻¹' s) ≤ μ s :=\n  (outerMeasure_le_iff (m := .map (c • ·) μ.1)).2\n    (fun _s hs ↦ (SMulInvariantMeasure.measure_preimage_smul _ hs).le) _\n\n"}
{"name":"MeasureTheory.tendsto_vadd_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : VAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\n⊢ Filter.Tendsto (fun x => HVAdd.hVAdd c x) (MeasureTheory.ae μ) (MeasureTheory.ae μ)","decl":"/-- See also `smul_ae`. -/\n@[to_additive \"See also `vadd_ae`.\"]\ntheorem tendsto_smul_ae (c : G) : Filter.Tendsto (c • ·) (ae μ) (ae μ) := fun _s hs ↦\n  eq_bot_mono (measure_preimage_smul_le μ c _) hs\n\n"}
{"name":"MeasureTheory.tendsto_smul_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : SMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\n⊢ Filter.Tendsto (fun x => HSMul.hSMul c x) (MeasureTheory.ae μ) (MeasureTheory.ae μ)","decl":"/-- See also `smul_ae`. -/\n@[to_additive \"See also `vadd_ae`.\"]\ntheorem tendsto_smul_ae (c : G) : Filter.Tendsto (c • ·) (ae μ) (ae μ) := fun _s hs ↦\n  eq_bot_mono (measure_preimage_smul_le μ c _) hs\n\n"}
{"name":"MeasureTheory.measure_preimage_vadd_null","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : VAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\ns : Set α\nh : Eq (μ s) 0\nc : G\n⊢ Eq (μ (Set.preimage (fun x => HVAdd.hVAdd c x) s)) 0","decl":"@[to_additive]\ntheorem measure_preimage_smul_null (h : μ s = 0) (c : G) : μ ((c • ·) ⁻¹' s) = 0 :=\n  eq_bot_mono (measure_preimage_smul_le μ c _) h\n\n"}
{"name":"MeasureTheory.measure_preimage_smul_null","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : SMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\ns : Set α\nh : Eq (μ s) 0\nc : G\n⊢ Eq (μ (Set.preimage (fun x => HSMul.hSMul c x) s)) 0","decl":"@[to_additive]\ntheorem measure_preimage_smul_null (h : μ s = 0) (c : G) : μ ((c • ·) ⁻¹' s) = 0 :=\n  eq_bot_mono (measure_preimage_smul_le μ c _) h\n\n"}
{"name":"MeasureTheory.measure_preimage_vadd_of_nullMeasurableSet","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : VAdd G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nc : G\n⊢ Eq (μ (Set.preimage (fun x => HVAdd.hVAdd c x) s)) (μ s)","decl":"@[to_additive]\ntheorem measure_preimage_smul_of_nullMeasurableSet (hs : NullMeasurableSet s μ) (c : G) :\n    μ ((c • ·) ⁻¹' s) = μ s := by\n  rw [← measure_toMeasurable s,\n    ← SMulInvariantMeasure.measure_preimage_smul c (measurableSet_toMeasurable μ s)]\n  exact measure_congr (tendsto_smul_ae μ c hs.toMeasurable_ae_eq) |>.symm\n\n"}
{"name":"MeasureTheory.measure_preimage_smul_of_nullMeasurableSet","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝¹ : SMul G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nc : G\n⊢ Eq (μ (Set.preimage (fun x => HSMul.hSMul c x) s)) (μ s)","decl":"@[to_additive]\ntheorem measure_preimage_smul_of_nullMeasurableSet (hs : NullMeasurableSet s μ) (c : G) :\n    μ ((c • ·) ⁻¹' s) = μ s := by\n  rw [← measure_toMeasurable s,\n    ← SMulInvariantMeasure.measure_preimage_smul c (measurableSet_toMeasurable μ s)]\n  exact measure_congr (tendsto_smul_ae μ c hs.toMeasurable_ae_eq) |>.symm\n\n"}
{"name":"MeasureTheory.measure_preimage_vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Eq (μ (Set.preimage (fun x => HVAdd.hVAdd c x) s)) (μ s)","decl":"@[to_additive (attr := simp)]\ntheorem measure_preimage_smul (c : G) (s : Set α) : μ ((c • ·) ⁻¹' s) = μ s :=\n  (measure_preimage_smul_le μ c s).antisymm <| by\n    simpa [preimage_preimage] using measure_preimage_smul_le μ c⁻¹ ((c • ·) ⁻¹' s)\n\n"}
{"name":"MeasureTheory.measure_preimage_smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Eq (μ (Set.preimage (fun x => HSMul.hSMul c x) s)) (μ s)","decl":"@[to_additive (attr := simp)]\ntheorem measure_preimage_smul (c : G) (s : Set α) : μ ((c • ·) ⁻¹' s) = μ s :=\n  (measure_preimage_smul_le μ c s).antisymm <| by\n    simpa [preimage_preimage] using measure_preimage_smul_le μ c⁻¹ ((c • ·) ⁻¹' s)\n\n"}
{"name":"MeasureTheory.measure_vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Eq (μ (HVAdd.hVAdd c s)) (μ s)","decl":"@[to_additive (attr := simp)]\ntheorem measure_smul (c : G) (s : Set α) : μ (c • s) = μ s := by\n  simpa only [preimage_smul_inv] using measure_preimage_smul μ c⁻¹ s\n\n"}
{"name":"MeasureTheory.measure_smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Eq (μ (HSMul.hSMul c s)) (μ s)","decl":"@[to_additive (attr := simp)]\ntheorem measure_smul (c : G) (s : Set α) : μ (c • s) = μ s := by\n  simpa only [preimage_smul_inv] using measure_preimage_smul μ c⁻¹ s\n\n"}
{"name":"MeasureTheory.measure_vadd_eq_zero_iff","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\ns : Set α\nc : G\n⊢ Iff (Eq (μ (HVAdd.hVAdd c s)) 0) (Eq (μ s) 0)","decl":"@[to_additive]\ntheorem measure_smul_eq_zero_iff {s} (c : G) : μ (c • s) = 0 ↔ μ s = 0 := by\n  rw [measure_smul]\n\n"}
{"name":"MeasureTheory.measure_smul_eq_zero_iff","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\ns : Set α\nc : G\n⊢ Iff (Eq (μ (HSMul.hSMul c s)) 0) (Eq (μ s) 0)","decl":"@[to_additive]\ntheorem measure_smul_eq_zero_iff {s} (c : G) : μ (c • s) = 0 ↔ μ s = 0 := by\n  rw [measure_smul]\n\n"}
{"name":"MeasureTheory.measure_smul_null","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\ns : Set α\nh : Eq (μ s) 0\nc : G\n⊢ Eq (μ (HSMul.hSMul c s)) 0","decl":"@[to_additive]\ntheorem measure_smul_null {s} (h : μ s = 0) (c : G) : μ (c • s) = 0 :=\n  (measure_smul_eq_zero_iff _).2 h\n\n"}
{"name":"MeasureTheory.measure_vadd_null","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\ns : Set α\nh : Eq (μ s) 0\nc : G\n⊢ Eq (μ (HVAdd.hVAdd c s)) 0","decl":"@[to_additive]\ntheorem measure_smul_null {s} (h : μ s = 0) (c : G) : μ (c • s) = 0 :=\n  (measure_smul_eq_zero_iff _).2 h\n\n"}
{"name":"MeasureTheory.smul_mem_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Iff (Membership.mem (MeasureTheory.ae μ) (HSMul.hSMul c s)) (Membership.mem (MeasureTheory.ae μ) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_ae (c : G) {s : Set α} : c • s ∈ ae μ ↔ s ∈ ae μ := by\n  simp only [mem_ae_iff, ← smul_set_compl, measure_smul_eq_zero_iff]\n\n"}
{"name":"MeasureTheory.vadd_mem_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Iff (Membership.mem (MeasureTheory.ae μ) (HVAdd.hVAdd c s)) (Membership.mem (MeasureTheory.ae μ) s)","decl":"@[to_additive (attr := simp)]\ntheorem smul_mem_ae (c : G) {s : Set α} : c • s ∈ ae μ ↔ s ∈ ae μ := by\n  simp only [mem_ae_iff, ← smul_set_compl, measure_smul_eq_zero_iff]\n\n"}
{"name":"MeasureTheory.vadd_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\n⊢ Eq (HVAdd.hVAdd c (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive (attr := simp)]\ntheorem smul_ae (c : G) : c • ae μ = ae μ := by\n  ext s\n  simp only [mem_smul_filter, preimage_smul, smul_mem_ae]\n\n"}
{"name":"MeasureTheory.smul_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\n⊢ Eq (HSMul.hSMul c (MeasureTheory.ae μ)) (MeasureTheory.ae μ)","decl":"@[to_additive (attr := simp)]\ntheorem smul_ae (c : G) : c • ae μ = ae μ := by\n  ext s\n  simp only [mem_smul_filter, preimage_smul, smul_mem_ae]\n\n"}
{"name":"MeasureTheory.eventuallyConst_vadd_set_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Iff (Filter.EventuallyConst (HVAdd.hVAdd c s) (MeasureTheory.ae μ)) (Filter.EventuallyConst s (MeasureTheory.ae μ))","decl":"@[to_additive (attr := simp)]\ntheorem eventuallyConst_smul_set_ae (c : G) {s : Set α} :\n    EventuallyConst (c • s : Set α) (ae μ) ↔ EventuallyConst s (ae μ) := by\n  rw [← preimage_smul_inv, eventuallyConst_preimage, Filter.map_smul, smul_ae]\n\n"}
{"name":"MeasureTheory.eventuallyConst_smul_set_ae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns : Set α\n⊢ Iff (Filter.EventuallyConst (HSMul.hSMul c s) (MeasureTheory.ae μ)) (Filter.EventuallyConst s (MeasureTheory.ae μ))","decl":"@[to_additive (attr := simp)]\ntheorem eventuallyConst_smul_set_ae (c : G) {s : Set α} :\n    EventuallyConst (c • s : Set α) (ae μ) ↔ EventuallyConst s (ae μ) := by\n  rw [← preimage_smul_inv, eventuallyConst_preimage, Filter.map_smul, smul_ae]\n\n"}
{"name":"MeasureTheory.vadd_set_ae_le","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns t : Set α\n⊢ Iff ((MeasureTheory.ae μ).EventuallyLE (HVAdd.hVAdd c s) (HVAdd.hVAdd c t)) ((MeasureTheory.ae μ).EventuallyLE s t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_ae_le (c : G) {s t : Set α} : c • s ≤ᵐ[μ] c • t ↔ s ≤ᵐ[μ] t := by\n  simp only [ae_le_set, ← smul_set_sdiff, measure_smul_eq_zero_iff]\n\n"}
{"name":"MeasureTheory.smul_set_ae_le","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns t : Set α\n⊢ Iff ((MeasureTheory.ae μ).EventuallyLE (HSMul.hSMul c s) (HSMul.hSMul c t)) ((MeasureTheory.ae μ).EventuallyLE s t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_ae_le (c : G) {s t : Set α} : c • s ≤ᵐ[μ] c • t ↔ s ≤ᵐ[μ] t := by\n  simp only [ae_le_set, ← smul_set_sdiff, measure_smul_eq_zero_iff]\n\n"}
{"name":"MeasureTheory.vadd_set_ae_eq","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : AddGroup G\ninst✝¹ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure G α μ\nc : G\ns t : Set α\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq (HVAdd.hVAdd c s) (HVAdd.hVAdd c t)) ((MeasureTheory.ae μ).EventuallyEq s t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_ae_eq (c : G) {s t : Set α} : c • s =ᵐ[μ] c • t ↔ s =ᵐ[μ] t := by\n  simp only [Filter.eventuallyLE_antisymm_iff, smul_set_ae_le]\n\n"}
{"name":"MeasureTheory.smul_set_ae_eq","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝² : Group G\ninst✝¹ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure G α μ\nc : G\ns t : Set α\n⊢ Iff ((MeasureTheory.ae μ).EventuallyEq (HSMul.hSMul c s) (HSMul.hSMul c t)) ((MeasureTheory.ae μ).EventuallyEq s t)","decl":"@[to_additive (attr := simp)]\ntheorem smul_set_ae_eq (c : G) {s t : Set α} : c • s =ᵐ[μ] c • t ↔ s =ᵐ[μ] t := by\n  simp only [Filter.eventuallyLE_antisymm_iff, smul_set_ae_le]\n\n"}
{"name":"MeasureTheory.measurePreserving_vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\nm : MeasurableSpace α\ninst✝³ : MeasurableSpace M\ninst✝² : VAdd M α\ninst✝¹ : MeasurableVAdd M α\nc : M\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure M α μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HVAdd.hVAdd c x) μ μ","decl":"@[to_additive (attr := simp)]\ntheorem measurePreserving_smul : MeasurePreserving (c • ·) μ μ :=\n  { measurable := measurable_const_smul c\n    map_eq := by\n      ext1 s hs\n      rw [map_apply (measurable_const_smul c) hs]\n      exact SMulInvariantMeasure.measure_preimage_smul c hs }\n\n"}
{"name":"MeasureTheory.measurePreserving_smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\nm : MeasurableSpace α\ninst✝³ : MeasurableSpace M\ninst✝² : SMul M α\ninst✝¹ : MeasurableSMul M α\nc : M\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure M α μ\n⊢ MeasureTheory.MeasurePreserving (fun x => HSMul.hSMul c x) μ μ","decl":"@[to_additive (attr := simp)]\ntheorem measurePreserving_smul : MeasurePreserving (c • ·) μ μ :=\n  { measurable := measurable_const_smul c\n    map_eq := by\n      ext1 s hs\n      rw [map_apply (measurable_const_smul c) hs]\n      exact SMulInvariantMeasure.measure_preimage_smul c hs }\n\n"}
{"name":"MeasureTheory.map_vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\nm : MeasurableSpace α\ninst✝³ : MeasurableSpace M\ninst✝² : VAdd M α\ninst✝¹ : MeasurableVAdd M α\nc : M\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure M α μ\n⊢ Eq (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd c x) μ) μ","decl":"@[to_additive (attr := simp)]\ntheorem map_smul : map (c • ·) μ = μ :=\n  (measurePreserving_smul c μ).map_eq\n\n"}
{"name":"MeasureTheory.map_smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type v\nα : Type w\nm : MeasurableSpace α\ninst✝³ : MeasurableSpace M\ninst✝² : SMul M α\ninst✝¹ : MeasurableSMul M α\nc : M\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure M α μ\n⊢ Eq (MeasureTheory.Measure.map (fun x => HSMul.hSMul c x) μ) μ","decl":"@[to_additive (attr := simp)]\ntheorem map_smul : map (c • ·) μ = μ :=\n  (measurePreserving_smul c μ).map_eq\n\n"}
{"name":"MeasureTheory.MeasurePreserving.smulInvariantMeasure_iterateMulAct","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"α : Type w\nf : α → α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.MeasurePreserving f μ μ\n⊢ MeasureTheory.SMulInvariantMeasure (IterateMulAct f) α μ","decl":"@[to_additive]\ntheorem MeasurePreserving.smulInvariantMeasure_iterateMulAct\n    {f : α → α} {_ : MeasurableSpace α} {μ : Measure α} (hf : MeasurePreserving f μ μ) :\n    SMulInvariantMeasure (IterateMulAct f) α μ :=\n  ⟨fun n _s hs ↦ (hf.iterate n.val).measure_preimage hs.nullMeasurableSet⟩\n\n"}
{"name":"MeasureTheory.MeasurePreserving.vaddInvariantMeasure_iterateAddAct","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"α : Type w\nf : α → α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhf : MeasureTheory.MeasurePreserving f μ μ\n⊢ MeasureTheory.VAddInvariantMeasure (IterateAddAct f) α μ","decl":"@[to_additive]\ntheorem MeasurePreserving.smulInvariantMeasure_iterateMulAct\n    {f : α → α} {_ : MeasurableSpace α} {μ : Measure α} (hf : MeasurePreserving f μ μ) :\n    SMulInvariantMeasure (IterateMulAct f) α μ :=\n  ⟨fun n _s hs ↦ (hf.iterate n.val).measure_preimage hs.nullMeasurableSet⟩\n\n"}
{"name":"MeasureTheory.vaddInvariantMeasure_iterateAddAct","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"α : Type w\nf : α → α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhf : Measurable f\n⊢ Iff (MeasureTheory.VAddInvariantMeasure (IterateAddAct f) α μ) (MeasureTheory.MeasurePreserving f μ μ)","decl":"@[to_additive]\ntheorem smulInvariantMeasure_iterateMulAct\n    {f : α → α} {_ : MeasurableSpace α} {μ : Measure α} (hf : Measurable f) :\n    SMulInvariantMeasure (IterateMulAct f) α μ ↔ MeasurePreserving f μ μ :=\n  ⟨fun _ ↦\n    have := hf.measurableSMul₂_iterateMulAct\n    measurePreserving_smul (IterateMulAct.mk (f := f) 1) μ,\n    MeasurePreserving.smulInvariantMeasure_iterateMulAct⟩\n\n"}
{"name":"MeasureTheory.smulInvariantMeasure_iterateMulAct","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"α : Type w\nf : α → α\nx✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nhf : Measurable f\n⊢ Iff (MeasureTheory.SMulInvariantMeasure (IterateMulAct f) α μ) (MeasureTheory.MeasurePreserving f μ μ)","decl":"@[to_additive]\ntheorem smulInvariantMeasure_iterateMulAct\n    {f : α → α} {_ : MeasurableSpace α} {μ : Measure α} (hf : Measurable f) :\n    SMulInvariantMeasure (IterateMulAct f) α μ ↔ MeasurePreserving f μ μ :=\n  ⟨fun _ ↦\n    have := hf.measurableSMul₂_iterateMulAct\n    measurePreserving_smul (IterateMulAct.mk (f := f) 1) μ,\n    MeasurePreserving.smulInvariantMeasure_iterateMulAct⟩\n\n"}
{"name":"MeasureTheory.vaddInvariantMeasure_map","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type uM\nα : Type uα\nβ : Type uβ\ninst✝⁶ : MeasurableSpace M\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : VAdd M α\ninst✝² : VAdd M β\ninst✝¹ : MeasurableVAdd M β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure M α μ\nf : α → β\nhsmul : ∀ (m : M) (a : α), Eq (f (HVAdd.hVAdd m a)) (HVAdd.hVAdd m (f a))\nhf : Measurable f\n⊢ MeasureTheory.VAddInvariantMeasure M β (MeasureTheory.Measure.map f μ)","decl":"@[to_additive]\ntheorem smulInvariantMeasure_map [SMul M α] [SMul M β]\n    [MeasurableSMul M β]\n    (μ : Measure α) [SMulInvariantMeasure M α μ] (f : α → β)\n    (hsmul : ∀ (m : M) a, f (m • a) = m • f a) (hf : Measurable f) :\n    SMulInvariantMeasure M β (map f μ) where\n  measure_preimage_smul m S hS := calc\n    map f μ ((m • ·) ⁻¹' S)\n    _ = μ (f ⁻¹' ((m • ·) ⁻¹' S)) := map_apply hf <| hS.preimage (measurable_const_smul _)\n    _ = μ ((m • f ·) ⁻¹' S) := by rw [preimage_preimage]\n    _ = μ ((f <| m • ·) ⁻¹' S) := by simp_rw [hsmul]\n    _ = μ ((m • ·) ⁻¹' (f ⁻¹' S)) := by rw [← preimage_preimage]\n    _ = μ (f ⁻¹' S) := by rw [SMulInvariantMeasure.measure_preimage_smul m (hS.preimage hf)]\n    _ = map f μ S := (map_apply hf hS).symm\n\n"}
{"name":"MeasureTheory.smulInvariantMeasure_map","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type uM\nα : Type uα\nβ : Type uβ\ninst✝⁶ : MeasurableSpace M\ninst✝⁵ : MeasurableSpace α\ninst✝⁴ : MeasurableSpace β\ninst✝³ : SMul M α\ninst✝² : SMul M β\ninst✝¹ : MeasurableSMul M β\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure M α μ\nf : α → β\nhsmul : ∀ (m : M) (a : α), Eq (f (HSMul.hSMul m a)) (HSMul.hSMul m (f a))\nhf : Measurable f\n⊢ MeasureTheory.SMulInvariantMeasure M β (MeasureTheory.Measure.map f μ)","decl":"@[to_additive]\ntheorem smulInvariantMeasure_map [SMul M α] [SMul M β]\n    [MeasurableSMul M β]\n    (μ : Measure α) [SMulInvariantMeasure M α μ] (f : α → β)\n    (hsmul : ∀ (m : M) a, f (m • a) = m • f a) (hf : Measurable f) :\n    SMulInvariantMeasure M β (map f μ) where\n  measure_preimage_smul m S hS := calc\n    map f μ ((m • ·) ⁻¹' S)\n    _ = μ (f ⁻¹' ((m • ·) ⁻¹' S)) := map_apply hf <| hS.preimage (measurable_const_smul _)\n    _ = μ ((m • f ·) ⁻¹' S) := by rw [preimage_preimage]\n    _ = μ ((f <| m • ·) ⁻¹' S) := by simp_rw [hsmul]\n    _ = μ ((m • ·) ⁻¹' (f ⁻¹' S)) := by rw [← preimage_preimage]\n    _ = μ (f ⁻¹' S) := by rw [SMulInvariantMeasure.measure_preimage_smul m (hS.preimage hf)]\n    _ = map f μ S := (map_apply hf hS).symm\n\n"}
{"name":"MeasureTheory.vaddInvariantMeasure_map_vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type uM\nN : Type uN\nα : Type uα\ninst✝⁸ : MeasurableSpace M\ninst✝⁷ : MeasurableSpace N\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : VAdd M α\ninst✝⁴ : VAdd N α\ninst✝³ : VAddCommClass N M α\ninst✝² : MeasurableVAdd M α\ninst✝¹ : MeasurableVAdd N α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.VAddInvariantMeasure M α μ\nn : N\n⊢ MeasureTheory.VAddInvariantMeasure M α (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd n x) μ)","decl":"@[to_additive]\ninstance smulInvariantMeasure_map_smul [SMul M α] [SMul N α] [SMulCommClass N M α]\n    [MeasurableSMul M α] [MeasurableSMul N α]\n    (μ : Measure α) [SMulInvariantMeasure M α μ] (n : N) :\n    SMulInvariantMeasure M α (map (n • ·) μ) :=\n  smulInvariantMeasure_map μ _ (smul_comm n) <| measurable_const_smul _\n\n"}
{"name":"MeasureTheory.smulInvariantMeasure_map_smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"M : Type uM\nN : Type uN\nα : Type uα\ninst✝⁸ : MeasurableSpace M\ninst✝⁷ : MeasurableSpace N\ninst✝⁶ : MeasurableSpace α\ninst✝⁵ : SMul M α\ninst✝⁴ : SMul N α\ninst✝³ : SMulCommClass N M α\ninst✝² : MeasurableSMul M α\ninst✝¹ : MeasurableSMul N α\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SMulInvariantMeasure M α μ\nn : N\n⊢ MeasureTheory.SMulInvariantMeasure M α (MeasureTheory.Measure.map (fun x => HSMul.hSMul n x) μ)","decl":"@[to_additive]\ninstance smulInvariantMeasure_map_smul [SMul M α] [SMul N α] [SMulCommClass N M α]\n    [MeasurableSMul M α] [MeasurableSMul N α]\n    (μ : Measure α) [SMulInvariantMeasure M α μ] (n : N) :\n    SMulInvariantMeasure M α (map (n • ·) μ) :=\n  smulInvariantMeasure_map μ _ (smul_comm n) <| measurable_const_smul _\n\n"}
{"name":"MeasureTheory.smulInvariantMeasure_tfae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝³ : Group G\ninst✝² : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableSMul G α\n⊢ (List.cons (MeasureTheory.SMulInvariantMeasure G α μ) (List.cons (∀ (c : G) (s : Set α), MeasurableSet s → Eq (μ (Set.preimage (fun x => HSMul.hSMul c x) s)) (μ s)) (List.cons (∀ (c : G) (s : Set α), MeasurableSet s → Eq (μ (HSMul.hSMul c s)) (μ s)) (List.cons (∀ (c : G) (s : Set α), Eq (μ (Set.preimage (fun x => HSMul.hSMul c x) s)) (μ s)) (List.cons (∀ (c : G) (s : Set α), Eq (μ (HSMul.hSMul c s)) (μ s)) (List.cons (∀ (c : G), Eq (MeasureTheory.Measure.map (fun x => HSMul.hSMul c x) μ) μ) (List.cons (∀ (c : G), MeasureTheory.MeasurePreserving (fun x => HSMul.hSMul c x) μ μ) List.nil))))))).TFAE","decl":"variable [MeasurableSpace G] [MeasurableSMul G α] in\n/-- Equivalent definitions of a measure invariant under a multiplicative action of a group.\n\n- 0: `SMulInvariantMeasure G α μ`;\n\n- 1: for every `c : G` and a measurable set `s`, the measure of the preimage of `s` under scalar\n     multiplication by `c` is equal to the measure of `s`;\n\n- 2: for every `c : G` and a measurable set `s`, the measure of the image `c • s` of `s` under\n     scalar multiplication by `c` is equal to the measure of `s`;\n\n- 3, 4: properties 2, 3 for any set, including non-measurable ones;\n\n- 5: for any `c : G`, scalar multiplication by `c` maps `μ` to `μ`;\n\n- 6: for any `c : G`, scalar multiplication by `c` is a measure preserving map. -/\n@[to_additive]\ntheorem smulInvariantMeasure_tfae :\n    List.TFAE\n      [SMulInvariantMeasure G α μ,\n        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,\n        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,\n        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,\n        ∀ (c : G) (s), μ (c • s) = μ s,\n        ∀ c : G, Measure.map (c • ·) μ = μ,\n        ∀ c : G, MeasurePreserving (c • ·) μ μ] := by\n  tfae_have 1 ↔ 2 := ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  tfae_have 1 → 6 := fun h c => (measurePreserving_smul c μ).map_eq\n  tfae_have 6 → 7 := fun H c => ⟨measurable_const_smul c, H c⟩\n  tfae_have 7 → 4 := fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)\n  tfae_have 4 → 5\n  | H, c, s => by\n    rw [← preimage_smul_inv]\n    apply H\n  tfae_have 5 → 3 := fun H c s _ => H c s\n  tfae_have 3 → 2\n  | H, c, s, hs => by\n    rw [preimage_smul]\n    exact H c⁻¹ s hs\n  tfae_finish\n\n"}
{"name":"MeasureTheory.vaddInvariantMeasure_tfae","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝³ : AddGroup G\ninst✝² : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableVAdd G α\n⊢ (List.cons (MeasureTheory.VAddInvariantMeasure G α μ) (List.cons (∀ (c : G) (s : Set α), MeasurableSet s → Eq (μ (Set.preimage (fun x => HVAdd.hVAdd c x) s)) (μ s)) (List.cons (∀ (c : G) (s : Set α), MeasurableSet s → Eq (μ (HVAdd.hVAdd c s)) (μ s)) (List.cons (∀ (c : G) (s : Set α), Eq (μ (Set.preimage (fun x => HVAdd.hVAdd c x) s)) (μ s)) (List.cons (∀ (c : G) (s : Set α), Eq (μ (HVAdd.hVAdd c s)) (μ s)) (List.cons (∀ (c : G), Eq (MeasureTheory.Measure.map (fun x => HVAdd.hVAdd c x) μ) μ) (List.cons (∀ (c : G), MeasureTheory.MeasurePreserving (fun x => HVAdd.hVAdd c x) μ μ) List.nil))))))).TFAE","decl":"variable [MeasurableSpace G] [MeasurableSMul G α] in\n/-- Equivalent definitions of a measure invariant under a multiplicative action of a group.\n\n- 0: `SMulInvariantMeasure G α μ`;\n\n- 1: for every `c : G` and a measurable set `s`, the measure of the preimage of `s` under scalar\n     multiplication by `c` is equal to the measure of `s`;\n\n- 2: for every `c : G` and a measurable set `s`, the measure of the image `c • s` of `s` under\n     scalar multiplication by `c` is equal to the measure of `s`;\n\n- 3, 4: properties 2, 3 for any set, including non-measurable ones;\n\n- 5: for any `c : G`, scalar multiplication by `c` maps `μ` to `μ`;\n\n- 6: for any `c : G`, scalar multiplication by `c` is a measure preserving map. -/\n@[to_additive]\ntheorem smulInvariantMeasure_tfae :\n    List.TFAE\n      [SMulInvariantMeasure G α μ,\n        ∀ (c : G) (s), MeasurableSet s → μ ((c • ·) ⁻¹' s) = μ s,\n        ∀ (c : G) (s), MeasurableSet s → μ (c • s) = μ s,\n        ∀ (c : G) (s), μ ((c • ·) ⁻¹' s) = μ s,\n        ∀ (c : G) (s), μ (c • s) = μ s,\n        ∀ c : G, Measure.map (c • ·) μ = μ,\n        ∀ c : G, MeasurePreserving (c • ·) μ μ] := by\n  tfae_have 1 ↔ 2 := ⟨fun h => h.1, fun h => ⟨h⟩⟩\n  tfae_have 1 → 6 := fun h c => (measurePreserving_smul c μ).map_eq\n  tfae_have 6 → 7 := fun H c => ⟨measurable_const_smul c, H c⟩\n  tfae_have 7 → 4 := fun H c => (H c).measure_preimage_emb (measurableEmbedding_const_smul c)\n  tfae_have 4 → 5\n  | H, c, s => by\n    rw [← preimage_smul_inv]\n    apply H\n  tfae_have 5 → 3 := fun H c s _ => H c s\n  tfae_have 3 → 2\n  | H, c, s, hs => by\n    rw [preimage_smul]\n    exact H c⁻¹ s hs\n  tfae_finish\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.vadd","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁴ : AddGroup G\ninst✝³ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableVAdd G α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nc : G\n⊢ MeasureTheory.NullMeasurableSet (HVAdd.hVAdd c s) μ","decl":"variable [MeasurableSpace G] [MeasurableSMul G α] in\n@[to_additive]\ntheorem NullMeasurableSet.smul {s} (hs : NullMeasurableSet s μ) (c : G) :\n    NullMeasurableSet (c • s) μ := by\n  simpa only [← preimage_smul_inv] using\n    hs.preimage (measurePreserving_smul _ _).quasiMeasurePreserving\n\n"}
{"name":"MeasureTheory.NullMeasurableSet.smul","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁴ : Group G\ninst✝³ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝² : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝¹ : MeasurableSpace G\ninst✝ : MeasurableSMul G α\ns : Set α\nhs : MeasureTheory.NullMeasurableSet s μ\nc : G\n⊢ MeasureTheory.NullMeasurableSet (HSMul.hSMul c s) μ","decl":"variable [MeasurableSpace G] [MeasurableSMul G α] in\n@[to_additive]\ntheorem NullMeasurableSet.smul {s} (hs : NullMeasurableSet s μ) (c : G) :\n    NullMeasurableSet (c • s) μ := by\n  simpa only [← preimage_smul_inv] using\n    hs.preimage (measurePreserving_smul _ _).quasiMeasurePreserving\n\n"}
{"name":"MeasureTheory.measure_isOpen_pos_of_vaddInvariant_of_compact_ne_zero","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousConstVAdd G α\ninst✝ : AddAction.IsMinimal G α\nK U : Set α\nhK : IsCompact K\nhμK : Ne (μ K) 0\nhU : IsOpen U\nhne : U.Nonempty\n⊢ LT.lt 0 (μ U)","decl":"include G in\n/-- If measure `μ` is invariant under a group action and is nonzero on a compact set `K`, then it is\npositive on any nonempty open set. In case of a regular measure, one can assume `μ ≠ 0` instead of\n`μ K ≠ 0`, see `MeasureTheory.measure_isOpen_pos_of_smulInvariant_of_ne_zero`. -/\n@[to_additive]\ntheorem measure_isOpen_pos_of_smulInvariant_of_compact_ne_zero (hK : IsCompact K) (hμK : μ K ≠ 0)\n    (hU : IsOpen U) (hne : U.Nonempty) : 0 < μ U :=\n  let ⟨t, ht⟩ := hK.exists_finite_cover_smul G hU hne\n  pos_iff_ne_zero.2 fun hμU =>\n    hμK <|\n      measure_mono_null ht <|\n        (measure_biUnion_null_iff t.countable_toSet).2 fun _ _ => by rwa [measure_smul]\n\n"}
{"name":"MeasureTheory.measure_isOpen_pos_of_smulInvariant_of_compact_ne_zero","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁵ : Group G\ninst✝⁴ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousConstSMul G α\ninst✝ : MulAction.IsMinimal G α\nK U : Set α\nhK : IsCompact K\nhμK : Ne (μ K) 0\nhU : IsOpen U\nhne : U.Nonempty\n⊢ LT.lt 0 (μ U)","decl":"include G in\n/-- If measure `μ` is invariant under a group action and is nonzero on a compact set `K`, then it is\npositive on any nonempty open set. In case of a regular measure, one can assume `μ ≠ 0` instead of\n`μ K ≠ 0`, see `MeasureTheory.measure_isOpen_pos_of_smulInvariant_of_ne_zero`. -/\n@[to_additive]\ntheorem measure_isOpen_pos_of_smulInvariant_of_compact_ne_zero (hK : IsCompact K) (hμK : μ K ≠ 0)\n    (hU : IsOpen U) (hne : U.Nonempty) : 0 < μ U :=\n  let ⟨t, ht⟩ := hK.exists_finite_cover_smul G hU hne\n  pos_iff_ne_zero.2 fun hμU =>\n    hμK <|\n      measure_mono_null ht <|\n        (measure_biUnion_null_iff t.countable_toSet).2 fun _ _ => by rwa [measure_smul]\n\n"}
{"name":"MeasureTheory.isLocallyFiniteMeasure_of_vaddInvariant","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁵ : AddGroup G\ninst✝⁴ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousConstVAdd G α\ninst✝ : AddAction.IsMinimal G α\nU : Set α\nhU : IsOpen U\nhne : U.Nonempty\nhμU : Ne (μ U) Top.top\n⊢ MeasureTheory.IsLocallyFiniteMeasure μ","decl":"@[to_additive]\ntheorem isLocallyFiniteMeasure_of_smulInvariant (hU : IsOpen U) (hne : U.Nonempty) (hμU : μ U ≠ ∞) :\n    IsLocallyFiniteMeasure μ :=\n  ⟨fun x =>\n    let ⟨g, hg⟩ := hU.exists_smul_mem G x hne\n    ⟨(g • ·) ⁻¹' U, (hU.preimage (continuous_id.const_smul _)).mem_nhds hg,\n      Ne.lt_top <| by rwa [measure_preimage_smul]⟩⟩\n\n"}
{"name":"MeasureTheory.isLocallyFiniteMeasure_of_smulInvariant","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁵ : Group G\ninst✝⁴ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝³ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝² : TopologicalSpace α\ninst✝¹ : ContinuousConstSMul G α\ninst✝ : MulAction.IsMinimal G α\nU : Set α\nhU : IsOpen U\nhne : U.Nonempty\nhμU : Ne (μ U) Top.top\n⊢ MeasureTheory.IsLocallyFiniteMeasure μ","decl":"@[to_additive]\ntheorem isLocallyFiniteMeasure_of_smulInvariant (hU : IsOpen U) (hne : U.Nonempty) (hμU : μ U ≠ ∞) :\n    IsLocallyFiniteMeasure μ :=\n  ⟨fun x =>\n    let ⟨g, hg⟩ := hU.exists_smul_mem G x hne\n    ⟨(g • ·) ⁻¹' U, (hU.preimage (continuous_id.const_smul _)).mem_nhds hg,\n      Ne.lt_top <| by rwa [measure_preimage_smul]⟩⟩\n\n"}
{"name":"MeasureTheory.measure_isOpen_pos_of_vaddInvariant_of_ne_zero","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝³ : TopologicalSpace α\ninst✝² : ContinuousConstVAdd G α\ninst✝¹ : AddAction.IsMinimal G α\nU : Set α\ninst✝ : μ.Regular\nhμ : Ne μ 0\nhU : IsOpen U\nhne : U.Nonempty\n⊢ LT.lt 0 (μ U)","decl":"@[to_additive]\ntheorem measure_isOpen_pos_of_smulInvariant_of_ne_zero (hμ : μ ≠ 0) (hU : IsOpen U)\n    (hne : U.Nonempty) : 0 < μ U :=\n  let ⟨_K, hK, hμK⟩ := Regular.exists_isCompact_not_null.mpr hμ\n  measure_isOpen_pos_of_smulInvariant_of_compact_ne_zero G hK hμK hU hne\n\n"}
{"name":"MeasureTheory.measure_isOpen_pos_of_smulInvariant_of_ne_zero","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝³ : TopologicalSpace α\ninst✝² : ContinuousConstSMul G α\ninst✝¹ : MulAction.IsMinimal G α\nU : Set α\ninst✝ : μ.Regular\nhμ : Ne μ 0\nhU : IsOpen U\nhne : U.Nonempty\n⊢ LT.lt 0 (μ U)","decl":"@[to_additive]\ntheorem measure_isOpen_pos_of_smulInvariant_of_ne_zero (hμ : μ ≠ 0) (hU : IsOpen U)\n    (hne : U.Nonempty) : 0 < μ U :=\n  let ⟨_K, hK, hμK⟩ := Regular.exists_isCompact_not_null.mpr hμ\n  measure_isOpen_pos_of_smulInvariant_of_compact_ne_zero G hK hμK hU hne\n\n"}
{"name":"MeasureTheory.measure_pos_iff_nonempty_of_vaddInvariant","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝³ : TopologicalSpace α\ninst✝² : ContinuousConstVAdd G α\ninst✝¹ : AddAction.IsMinimal G α\nU : Set α\ninst✝ : μ.Regular\nhμ : Ne μ 0\nhU : IsOpen U\n⊢ Iff (LT.lt 0 (μ U)) U.Nonempty","decl":"@[to_additive]\ntheorem measure_pos_iff_nonempty_of_smulInvariant (hμ : μ ≠ 0) (hU : IsOpen U) :\n    0 < μ U ↔ U.Nonempty :=\n  ⟨fun h => nonempty_of_measure_ne_zero h.ne',\n    measure_isOpen_pos_of_smulInvariant_of_ne_zero G hμ hU⟩\n\n"}
{"name":"MeasureTheory.measure_pos_iff_nonempty_of_smulInvariant","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝³ : TopologicalSpace α\ninst✝² : ContinuousConstSMul G α\ninst✝¹ : MulAction.IsMinimal G α\nU : Set α\ninst✝ : μ.Regular\nhμ : Ne μ 0\nhU : IsOpen U\n⊢ Iff (LT.lt 0 (μ U)) U.Nonempty","decl":"@[to_additive]\ntheorem measure_pos_iff_nonempty_of_smulInvariant (hμ : μ ≠ 0) (hU : IsOpen U) :\n    0 < μ U ↔ U.Nonempty :=\n  ⟨fun h => nonempty_of_measure_ne_zero h.ne',\n    measure_isOpen_pos_of_smulInvariant_of_ne_zero G hμ hU⟩\n\n"}
{"name":"MeasureTheory.measure_eq_zero_iff_eq_empty_of_vaddInvariant","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁶ : AddGroup G\ninst✝⁵ : AddAction G α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.VAddInvariantMeasure G α μ\ninst✝³ : TopologicalSpace α\ninst✝² : ContinuousConstVAdd G α\ninst✝¹ : AddAction.IsMinimal G α\nU : Set α\ninst✝ : μ.Regular\nhμ : Ne μ 0\nhU : IsOpen U\n⊢ Iff (Eq (μ U) 0) (Eq U EmptyCollection.emptyCollection)","decl":"@[to_additive]\ntheorem measure_eq_zero_iff_eq_empty_of_smulInvariant (hμ : μ ≠ 0) (hU : IsOpen U) :\n    μ U = 0 ↔ U = ∅ := by\n  rw [← not_iff_not, ← Ne, ← pos_iff_ne_zero,\n    measure_pos_iff_nonempty_of_smulInvariant G hμ hU, nonempty_iff_ne_empty]\n\n"}
{"name":"MeasureTheory.measure_eq_zero_iff_eq_empty_of_smulInvariant","module":"Mathlib.MeasureTheory.Group.Action","initialProofState":"G : Type u\nα : Type w\nm : MeasurableSpace α\ninst✝⁶ : Group G\ninst✝⁵ : MulAction G α\nμ : MeasureTheory.Measure α\ninst✝⁴ : MeasureTheory.SMulInvariantMeasure G α μ\ninst✝³ : TopologicalSpace α\ninst✝² : ContinuousConstSMul G α\ninst✝¹ : MulAction.IsMinimal G α\nU : Set α\ninst✝ : μ.Regular\nhμ : Ne μ 0\nhU : IsOpen U\n⊢ Iff (Eq (μ U) 0) (Eq U EmptyCollection.emptyCollection)","decl":"@[to_additive]\ntheorem measure_eq_zero_iff_eq_empty_of_smulInvariant (hμ : μ ≠ 0) (hU : IsOpen U) :\n    μ U = 0 ↔ U = ∅ := by\n  rw [← not_iff_not, ← Ne, ← pos_iff_ne_zero,\n    measure_pos_iff_nonempty_of_smulInvariant G hμ hU, nonempty_iff_ne_empty]\n\n"}
