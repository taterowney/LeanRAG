{"name":"contMDiffOn_continuousLinearMapCoordChange","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nn : WithTop ENat\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²⁷ : NontriviallyNormedField 𝕜\ninst✝²⁶ : (x : B) → AddCommGroup (E₁ x)\ninst✝²⁵ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁴ : NormedAddCommGroup F₁\ninst✝²³ : NormedSpace 𝕜 F₁\ninst✝²² : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²¹ : (x : B) → TopologicalSpace (E₁ x)\ninst✝²⁰ : (x : B) → AddCommGroup (E₂ x)\ninst✝¹⁹ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁸ : NormedAddCommGroup F₂\ninst✝¹⁷ : NormedSpace 𝕜 F₂\ninst✝¹⁶ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁵ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁴ : NormedAddCommGroup EB\ninst✝¹³ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝¹² : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝¹¹ : TopologicalSpace B\ninst✝¹⁰ : ChartedSpace HB B\ninst✝⁹ : FiberBundle F₁ E₁\ninst✝⁸ : VectorBundle 𝕜 F₁ E₁\ninst✝⁷ : FiberBundle F₂ E₂\ninst✝⁶ : VectorBundle 𝕜 F₂ E₂\ne₁ e₁' : Trivialization F₁ Bundle.TotalSpace.proj\ne₂ e₂' : Trivialization F₂ Bundle.TotalSpace.proj\ninst✝⁵ : ContMDiffVectorBundle n F₁ E₁ IB\ninst✝⁴ : ContMDiffVectorBundle n F₂ E₂ IB\ninst✝³ : MemTrivializationAtlas e₁\ninst✝² : MemTrivializationAtlas e₁'\ninst✝¹ : MemTrivializationAtlas e₂\ninst✝ : MemTrivializationAtlas e₂'\n⊢ ContMDiffOn IB (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂) (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂))) n (Pretrivialization.continuousLinearMapCoordChange (RingHom.id 𝕜) e₁ e₁' e₂ e₂') (Inter.inter (Inter.inter e₁.baseSet e₂.baseSet) (Inter.inter e₁'.baseSet e₂'.baseSet))","decl":"theorem contMDiffOn_continuousLinearMapCoordChange\n    [ContMDiffVectorBundle n F₁ E₁ IB] [ContMDiffVectorBundle n F₂ E₂ IB]\n    [MemTrivializationAtlas e₁] [MemTrivializationAtlas e₁']\n    [MemTrivializationAtlas e₂] [MemTrivializationAtlas e₂'] :\n    ContMDiffOn IB 𝓘(𝕜, (F₁ →L[𝕜] F₂) →L[𝕜] F₁ →L[𝕜] F₂) n\n      (continuousLinearMapCoordChange (RingHom.id 𝕜) e₁ e₁' e₂ e₂')\n      (e₁.baseSet ∩ e₂.baseSet ∩ (e₁'.baseSet ∩ e₂'.baseSet)) := by\n  have h₁ := contMDiffOn_coordChangeL (IB := IB) e₁' e₁ (n := n)\n  have h₂ := contMDiffOn_coordChangeL (IB := IB) e₂ e₂' (n := n)\n  refine (h₁.mono ?_).cle_arrowCongr (h₂.mono ?_) <;> mfld_set_tac\n\n"}
{"name":"smoothOn_continuousLinearMapCoordChange","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nn : WithTop ENat\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²⁷ : NontriviallyNormedField 𝕜\ninst✝²⁶ : (x : B) → AddCommGroup (E₁ x)\ninst✝²⁵ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁴ : NormedAddCommGroup F₁\ninst✝²³ : NormedSpace 𝕜 F₁\ninst✝²² : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²¹ : (x : B) → TopologicalSpace (E₁ x)\ninst✝²⁰ : (x : B) → AddCommGroup (E₂ x)\ninst✝¹⁹ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁸ : NormedAddCommGroup F₂\ninst✝¹⁷ : NormedSpace 𝕜 F₂\ninst✝¹⁶ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁵ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁴ : NormedAddCommGroup EB\ninst✝¹³ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝¹² : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝¹¹ : TopologicalSpace B\ninst✝¹⁰ : ChartedSpace HB B\ninst✝⁹ : FiberBundle F₁ E₁\ninst✝⁸ : VectorBundle 𝕜 F₁ E₁\ninst✝⁷ : FiberBundle F₂ E₂\ninst✝⁶ : VectorBundle 𝕜 F₂ E₂\ne₁ e₁' : Trivialization F₁ Bundle.TotalSpace.proj\ne₂ e₂' : Trivialization F₂ Bundle.TotalSpace.proj\ninst✝⁵ : ContMDiffVectorBundle n F₁ E₁ IB\ninst✝⁴ : ContMDiffVectorBundle n F₂ E₂ IB\ninst✝³ : MemTrivializationAtlas e₁\ninst✝² : MemTrivializationAtlas e₁'\ninst✝¹ : MemTrivializationAtlas e₂\ninst✝ : MemTrivializationAtlas e₂'\n⊢ ContMDiffOn IB (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂) (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂))) n (Pretrivialization.continuousLinearMapCoordChange (RingHom.id 𝕜) e₁ e₁' e₂ e₂') (Inter.inter (Inter.inter e₁.baseSet e₂.baseSet) (Inter.inter e₁'.baseSet e₂'.baseSet))","decl":"@[deprecated (since := \"2024-11-21\")]\nalias smoothOn_continuousLinearMapCoordChange := contMDiffOn_continuousLinearMapCoordChange\n\n"}
{"name":"hom_chart","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²¹ : NontriviallyNormedField 𝕜\ninst✝²⁰ : (x : B) → AddCommGroup (E₁ x)\ninst✝¹⁹ : (x : B) → Module 𝕜 (E₁ x)\ninst✝¹⁸ : NormedAddCommGroup F₁\ninst✝¹⁷ : NormedSpace 𝕜 F₁\ninst✝¹⁶ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝¹⁵ : (x : B) → TopologicalSpace (E₁ x)\ninst✝¹⁴ : (x : B) → AddCommGroup (E₂ x)\ninst✝¹³ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹² : NormedAddCommGroup F₂\ninst✝¹¹ : NormedSpace 𝕜 F₂\ninst✝¹⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝⁹ : (x : B) → TopologicalSpace (E₂ x)\nHB : Type u_9\ninst✝⁸ : TopologicalSpace HB\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : ChartedSpace HB B\ninst✝⁵ : FiberBundle F₁ E₁\ninst✝⁴ : VectorBundle 𝕜 F₁ E₁\ninst✝³ : FiberBundle F₂ E₂\ninst✝² : VectorBundle 𝕜 F₂ E₂\ninst✝¹ : ∀ (x : B), TopologicalAddGroup (E₂ x)\ninst✝ : ∀ (x : B), ContinuousSMul 𝕜 (E₂ x)\ny₀ y : Bundle.TotalSpace (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂) (Bundle.ContinuousLinearMap (RingHom.id 𝕜) E₁ E₂)\n⊢ Eq (↑(chartAt (ModelProd HB (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) y₀) y) { fst := ↑(chartAt HB y₀.proj) y.proj, snd := ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ y₀.proj y.proj y₀.proj y.proj y.snd }","decl":"theorem hom_chart (y₀ y : LE₁E₂) :\n    chartAt (ModelProd HB (F₁ →L[𝕜] F₂)) y₀ y =\n      (chartAt HB y₀.1 y.1, inCoordinates F₁ E₁ F₂ E₂ y₀.1 y.1 y₀.1 y.1 y.2) := by\n  rw [FiberBundle.chartedSpace_chartAt, trans_apply, PartialHomeomorph.prod_apply,\n    Trivialization.coe_coe, PartialHomeomorph.refl_apply, Function.id_def,\n    hom_trivializationAt_apply]\n\n"}
{"name":"contMDiffAt_hom_bundle","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nM : Type u_5\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²⁸ : NontriviallyNormedField 𝕜\ninst✝²⁷ : (x : B) → AddCommGroup (E₁ x)\ninst✝²⁶ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁵ : NormedAddCommGroup F₁\ninst✝²⁴ : NormedSpace 𝕜 F₁\ninst✝²³ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²² : (x : B) → TopologicalSpace (E₁ x)\ninst✝²¹ : (x : B) → AddCommGroup (E₂ x)\ninst✝²⁰ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁹ : NormedAddCommGroup F₂\ninst✝¹⁸ : NormedSpace 𝕜 F₂\ninst✝¹⁷ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁶ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁵ : NormedAddCommGroup EB\ninst✝¹⁴ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝¹³ : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝¹² : TopologicalSpace B\ninst✝¹¹ : ChartedSpace HB B\nEM : Type u_10\ninst✝¹⁰ : NormedAddCommGroup EM\ninst✝⁹ : NormedSpace 𝕜 EM\nHM : Type u_11\ninst✝⁸ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : ChartedSpace HM M\ninst✝⁵ : FiberBundle F₁ E₁\ninst✝⁴ : VectorBundle 𝕜 F₁ E₁\ninst✝³ : FiberBundle F₂ E₂\ninst✝² : VectorBundle 𝕜 F₂ E₂\ninst✝¹ : ∀ (x : B), TopologicalAddGroup (E₂ x)\ninst✝ : ∀ (x : B), ContinuousSMul 𝕜 (E₂ x)\nf : M → Bundle.TotalSpace (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂) (Bundle.ContinuousLinearMap (RingHom.id 𝕜) E₁ E₂)\nx₀ : M\nn : ENat\n⊢ Iff (ContMDiffAt IM (IB.prod (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂))) (↑n) f x₀) (And (ContMDiffAt IM IB (↑n) (fun x => (f x).proj) x₀) (ContMDiffAt IM (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) (↑n) (fun x => ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ (f x₀).proj (f x).proj (f x₀).proj (f x).proj (f x).snd) x₀))","decl":"theorem contMDiffAt_hom_bundle (f : M → LE₁E₂) {x₀ : M} {n : ℕ∞} :\n    ContMDiffAt IM (IB.prod 𝓘(𝕜, F₁ →L[𝕜] F₂)) n f x₀ ↔\n      ContMDiffAt IM IB n (fun x => (f x).1) x₀ ∧\n        ContMDiffAt IM 𝓘(𝕜, F₁ →L[𝕜] F₂) n\n          (fun x => inCoordinates F₁ E₁ F₂ E₂ (f x₀).1 (f x).1 (f x₀).1 (f x).1 (f x).2) x₀ :=\n  contMDiffAt_totalSpace ..\n\n"}
{"name":"smoothAt_hom_bundle","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nM : Type u_5\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²⁸ : NontriviallyNormedField 𝕜\ninst✝²⁷ : (x : B) → AddCommGroup (E₁ x)\ninst✝²⁶ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁵ : NormedAddCommGroup F₁\ninst✝²⁴ : NormedSpace 𝕜 F₁\ninst✝²³ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²² : (x : B) → TopologicalSpace (E₁ x)\ninst✝²¹ : (x : B) → AddCommGroup (E₂ x)\ninst✝²⁰ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁹ : NormedAddCommGroup F₂\ninst✝¹⁸ : NormedSpace 𝕜 F₂\ninst✝¹⁷ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁶ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁵ : NormedAddCommGroup EB\ninst✝¹⁴ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝¹³ : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝¹² : TopologicalSpace B\ninst✝¹¹ : ChartedSpace HB B\nEM : Type u_10\ninst✝¹⁰ : NormedAddCommGroup EM\ninst✝⁹ : NormedSpace 𝕜 EM\nHM : Type u_11\ninst✝⁸ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁷ : TopologicalSpace M\ninst✝⁶ : ChartedSpace HM M\ninst✝⁵ : FiberBundle F₁ E₁\ninst✝⁴ : VectorBundle 𝕜 F₁ E₁\ninst✝³ : FiberBundle F₂ E₂\ninst✝² : VectorBundle 𝕜 F₂ E₂\ninst✝¹ : ∀ (x : B), TopologicalAddGroup (E₂ x)\ninst✝ : ∀ (x : B), ContinuousSMul 𝕜 (E₂ x)\nf : M → Bundle.TotalSpace (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂) (Bundle.ContinuousLinearMap (RingHom.id 𝕜) E₁ E₂)\nx₀ : M\nn : ENat\n⊢ Iff (ContMDiffAt IM (IB.prod (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂))) (↑n) f x₀) (And (ContMDiffAt IM IB (↑n) (fun x => (f x).proj) x₀) (ContMDiffAt IM (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) (↑n) (fun x => ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ (f x₀).proj (f x).proj (f x₀).proj (f x).proj (f x).snd) x₀))","decl":"@[deprecated (since := \"2024-11-21\")] alias smoothAt_hom_bundle := contMDiffAt_hom_bundle\n\n\n"}
{"name":"Bundle.ContinuousLinearMap.vectorPrebundle.isContMDiff","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nn : WithTop ENat\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²³ : NontriviallyNormedField 𝕜\ninst✝²² : (x : B) → AddCommGroup (E₁ x)\ninst✝²¹ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁰ : NormedAddCommGroup F₁\ninst✝¹⁹ : NormedSpace 𝕜 F₁\ninst✝¹⁸ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝¹⁷ : (x : B) → TopologicalSpace (E₁ x)\ninst✝¹⁶ : (x : B) → AddCommGroup (E₂ x)\ninst✝¹⁵ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁴ : NormedAddCommGroup F₂\ninst✝¹³ : NormedSpace 𝕜 F₂\ninst✝¹² : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹¹ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁰ : NormedAddCommGroup EB\ninst✝⁹ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝⁸ : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : ChartedSpace HB B\ninst✝⁵ : FiberBundle F₁ E₁\ninst✝⁴ : VectorBundle 𝕜 F₁ E₁\ninst✝³ : FiberBundle F₂ E₂\ninst✝² : VectorBundle 𝕜 F₂ E₂\ninst✝¹ : ∀ (x : B), TopologicalAddGroup (E₂ x)\ninst✝ : ∀ (x : B), ContinuousSMul 𝕜 (E₂ x)\n⊢ VectorPrebundle.IsContMDiff IB (Bundle.ContinuousLinearMap.vectorPrebundle (RingHom.id 𝕜) F₁ E₁ F₂ E₂) n","decl":"instance Bundle.ContinuousLinearMap.vectorPrebundle.isContMDiff :\n    (Bundle.ContinuousLinearMap.vectorPrebundle (RingHom.id 𝕜) F₁ E₁ F₂ E₂).IsContMDiff IB n where\n  exists_contMDiffCoordChange := by\n    rintro _ ⟨e₁, e₂, he₁, he₂, rfl⟩ _ ⟨e₁', e₂', he₁', he₂', rfl⟩\n    exact ⟨continuousLinearMapCoordChange (RingHom.id 𝕜) e₁ e₁' e₂ e₂',\n      contMDiffOn_continuousLinearMapCoordChange,\n      continuousLinearMapCoordChange_apply (RingHom.id 𝕜) e₁ e₁' e₂ e₂'⟩\n\n"}
{"name":"Bundle.ContinuousLinearMap.vectorPrebundle.isSmooth","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nn : WithTop ENat\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²³ : NontriviallyNormedField 𝕜\ninst✝²² : (x : B) → AddCommGroup (E₁ x)\ninst✝²¹ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁰ : NormedAddCommGroup F₁\ninst✝¹⁹ : NormedSpace 𝕜 F₁\ninst✝¹⁸ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝¹⁷ : (x : B) → TopologicalSpace (E₁ x)\ninst✝¹⁶ : (x : B) → AddCommGroup (E₂ x)\ninst✝¹⁵ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁴ : NormedAddCommGroup F₂\ninst✝¹³ : NormedSpace 𝕜 F₂\ninst✝¹² : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹¹ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁰ : NormedAddCommGroup EB\ninst✝⁹ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝⁸ : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : ChartedSpace HB B\ninst✝⁵ : FiberBundle F₁ E₁\ninst✝⁴ : VectorBundle 𝕜 F₁ E₁\ninst✝³ : FiberBundle F₂ E₂\ninst✝² : VectorBundle 𝕜 F₂ E₂\ninst✝¹ : ∀ (x : B), TopologicalAddGroup (E₂ x)\ninst✝ : ∀ (x : B), ContinuousSMul 𝕜 (E₂ x)\n⊢ VectorPrebundle.IsContMDiff IB (Bundle.ContinuousLinearMap.vectorPrebundle (RingHom.id 𝕜) F₁ E₁ F₂ E₂) n","decl":"@[deprecated (since := \"2025-01-09\")]\nalias Bundle.ContinuousLinearMap.vectorPrebundle.isSmooth :=\n  Bundle.ContinuousLinearMap.vectorPrebundle.isContMDiff\n\n"}
{"name":"ContMDiffVectorBundle.continuousLinearMap","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nB : Type u_2\nF₁ : Type u_3\nF₂ : Type u_4\nn : WithTop ENat\nE₁ : B → Type u_6\nE₂ : B → Type u_7\ninst✝²³ : NontriviallyNormedField 𝕜\ninst✝²² : (x : B) → AddCommGroup (E₁ x)\ninst✝²¹ : (x : B) → Module 𝕜 (E₁ x)\ninst✝²⁰ : NormedAddCommGroup F₁\ninst✝¹⁹ : NormedSpace 𝕜 F₁\ninst✝¹⁸ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝¹⁷ : (x : B) → TopologicalSpace (E₁ x)\ninst✝¹⁶ : (x : B) → AddCommGroup (E₂ x)\ninst✝¹⁵ : (x : B) → Module 𝕜 (E₂ x)\ninst✝¹⁴ : NormedAddCommGroup F₂\ninst✝¹³ : NormedSpace 𝕜 F₂\ninst✝¹² : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹¹ : (x : B) → TopologicalSpace (E₂ x)\nEB : Type u_8\ninst✝¹⁰ : NormedAddCommGroup EB\ninst✝⁹ : NormedSpace 𝕜 EB\nHB : Type u_9\ninst✝⁸ : TopologicalSpace HB\nIB : ModelWithCorners 𝕜 EB HB\ninst✝⁷ : TopologicalSpace B\ninst✝⁶ : ChartedSpace HB B\ninst✝⁵ : FiberBundle F₁ E₁\ninst✝⁴ : VectorBundle 𝕜 F₁ E₁\ninst✝³ : FiberBundle F₂ E₂\ninst✝² : VectorBundle 𝕜 F₂ E₂\ninst✝¹ : ∀ (x : B), TopologicalAddGroup (E₂ x)\ninst✝ : ∀ (x : B), ContinuousSMul 𝕜 (E₂ x)\n⊢ ContMDiffVectorBundle n (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂) (Bundle.ContinuousLinearMap (RingHom.id 𝕜) E₁ E₂) IB","decl":"instance ContMDiffVectorBundle.continuousLinearMap :\n    ContMDiffVectorBundle n (F₁ →L[𝕜] F₂) (Bundle.ContinuousLinearMap (RingHom.id 𝕜) E₁ E₂) IB :=\n  (Bundle.ContinuousLinearMap.vectorPrebundle (RingHom.id 𝕜) F₁ E₁ F₂ E₂).contMDiffVectorBundle IB\n\n"}
{"name":"ContMDiffWithinAt.clm_apply_of_inCoordinates","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nF₁ : Type u_2\nF₂ : Type u_3\nB₁ : Type u_4\nB₂ : Type u_5\nM : Type u_6\nE₁ : B₁ → Type u_7\nE₂ : B₂ → Type u_8\ninst✝³¹ : NontriviallyNormedField 𝕜\ninst✝³⁰ : (x : B₁) → AddCommGroup (E₁ x)\ninst✝²⁹ : (x : B₁) → Module 𝕜 (E₁ x)\ninst✝²⁸ : NormedAddCommGroup F₁\ninst✝²⁷ : NormedSpace 𝕜 F₁\ninst✝²⁶ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²⁵ : (x : B₁) → TopologicalSpace (E₁ x)\ninst✝²⁴ : (x : B₂) → AddCommGroup (E₂ x)\ninst✝²³ : (x : B₂) → Module 𝕜 (E₂ x)\ninst✝²² : NormedAddCommGroup F₂\ninst✝²¹ : NormedSpace 𝕜 F₂\ninst✝²⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁹ : (x : B₂) → TopologicalSpace (E₂ x)\nEB₁ : Type u_9\ninst✝¹⁸ : NormedAddCommGroup EB₁\ninst✝¹⁷ : NormedSpace 𝕜 EB₁\nHB₁ : Type u_10\ninst✝¹⁶ : TopologicalSpace HB₁\nIB₁ : ModelWithCorners 𝕜 EB₁ HB₁\ninst✝¹⁵ : TopologicalSpace B₁\ninst✝¹⁴ : ChartedSpace HB₁ B₁\nEB₂ : Type u_11\ninst✝¹³ : NormedAddCommGroup EB₂\ninst✝¹² : NormedSpace 𝕜 EB₂\nHB₂ : Type u_12\ninst✝¹¹ : TopologicalSpace HB₂\nIB₂ : ModelWithCorners 𝕜 EB₂ HB₂\ninst✝¹⁰ : TopologicalSpace B₂\ninst✝⁹ : ChartedSpace HB₂ B₂\nEM : Type u_13\ninst✝⁸ : NormedAddCommGroup EM\ninst✝⁷ : NormedSpace 𝕜 EM\nHM : Type u_14\ninst✝⁶ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : ChartedSpace HM M\nn : WithTop ENat\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : VectorBundle 𝕜 F₁ E₁\ninst✝¹ : FiberBundle F₂ E₂\ninst✝ : VectorBundle 𝕜 F₂ E₂\nb₁ : M → B₁\nb₂ : M → B₂\nm₀ : M\nϕ : (m : M) → ContinuousLinearMap (RingHom.id 𝕜) (E₁ (b₁ m)) (E₂ (b₂ m))\nv : (m : M) → E₁ (b₁ m)\ns : Set M\nhϕ : ContMDiffWithinAt IM (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) n (fun m => ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) s m₀\nhv : ContMDiffWithinAt IM (IB₁.prod (modelWithCornersSelf 𝕜 F₁)) n (fun m => { proj := b₁ m, snd := v m }) s m₀\nhb₂ : ContMDiffWithinAt IM IB₂ n b₂ s m₀\n⊢ ContMDiffWithinAt IM (IB₂.prod (modelWithCornersSelf 𝕜 F₂)) n (fun m => { proj := b₂ m, snd := (ϕ m) (v m) }) s m₀","decl":"/-- Consider a `C^n` map `v : M → E₁` to a vector bundle, over a basemap `b₁ : M → B₁`, and\nanother basemap `b₂ : M → B₂`. Given linear maps `ϕ m : E₁ (b₁ m) → E₂ (b₂ m)` depending smoothly\non `m`, one can apply `ϕ m` to `g m`, and the resulting map is `C^n`.\n\nNote that the smoothness of `ϕ` can not be always be stated as smoothness of a map into a manifold,\nas the pullback bundles `b₁ *ᵖ E₁` and `b₂ *ᵖ E₂` only make sense when `b₁` and `b₂` are globally\nsmooth, but we want to apply this lemma with only local information. Therefore, we formulate it\nusing smoothness of `ϕ` read in coordinates.\n\nVersion for `ContMDiffWithinAt`. We also give a version for `ContMDiffAt`, but no version for\n`ContMDiffOn` or `ContMDiff` as our assumption, written in coordinates, only makes sense around\na point.\n -/\nlemma ContMDiffWithinAt.clm_apply_of_inCoordinates\n    (hϕ : ContMDiffWithinAt IM 𝓘(𝕜, F₁ →L[𝕜] F₂) n\n      (fun m ↦ inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) s m₀)\n    (hv : ContMDiffWithinAt IM (IB₁.prod 𝓘(𝕜, F₁)) n (fun m ↦ (v m : TotalSpace F₁ E₁)) s m₀)\n    (hb₂ : ContMDiffWithinAt IM IB₂ n b₂ s m₀) :\n    ContMDiffWithinAt IM (IB₂.prod 𝓘(𝕜, F₂)) n (fun m ↦ (ϕ m (v m) : TotalSpace F₂ E₂)) s m₀ := by\n  rw [← contMDiffWithinAt_insert_self] at hϕ hv hb₂ ⊢\n  rw [contMDiffWithinAt_totalSpace] at hv ⊢\n  refine ⟨hb₂, ?_⟩\n  apply (ContMDiffWithinAt.clm_apply hϕ hv.2).congr_of_eventuallyEq_of_mem ?_ (mem_insert m₀ s)\n  have A : ∀ᶠ m in 𝓝[insert m₀ s] m₀, b₁ m ∈ (trivializationAt F₁ E₁ (b₁ m₀)).baseSet := by\n    apply hv.1.continuousWithinAt\n    apply (trivializationAt F₁ E₁ (b₁ m₀)).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' (b₁ m₀)\n  have A' : ∀ᶠ m in 𝓝[insert m₀ s] m₀, b₂ m ∈ (trivializationAt F₂ E₂ (b₂ m₀)).baseSet := by\n    apply hb₂.continuousWithinAt\n    apply (trivializationAt F₂ E₂ (b₂ m₀)).open_baseSet.mem_nhds\n    exact FiberBundle.mem_baseSet_trivializationAt' (b₂ m₀)\n  filter_upwards [A, A'] with m hm h'm\n  rw [inCoordinates_eq hm h'm]\n  simp only [coe_comp', ContinuousLinearEquiv.coe_coe, Trivialization.continuousLinearEquivAt_apply,\n    Trivialization.continuousLinearEquivAt_symm_apply, Function.comp_apply]\n  congr\n  rw [Trivialization.symm_apply_apply_mk (trivializationAt F₁ E₁ (b₁ m₀)) hm (v m)]\n\n"}
{"name":"ContMDiffAt.clm_apply_of_inCoordinates","module":"Mathlib.Geometry.Manifold.VectorBundle.Hom","initialProofState":"𝕜 : Type u_1\nF₁ : Type u_2\nF₂ : Type u_3\nB₁ : Type u_4\nB₂ : Type u_5\nM : Type u_6\nE₁ : B₁ → Type u_7\nE₂ : B₂ → Type u_8\ninst✝³¹ : NontriviallyNormedField 𝕜\ninst✝³⁰ : (x : B₁) → AddCommGroup (E₁ x)\ninst✝²⁹ : (x : B₁) → Module 𝕜 (E₁ x)\ninst✝²⁸ : NormedAddCommGroup F₁\ninst✝²⁷ : NormedSpace 𝕜 F₁\ninst✝²⁶ : TopologicalSpace (Bundle.TotalSpace F₁ E₁)\ninst✝²⁵ : (x : B₁) → TopologicalSpace (E₁ x)\ninst✝²⁴ : (x : B₂) → AddCommGroup (E₂ x)\ninst✝²³ : (x : B₂) → Module 𝕜 (E₂ x)\ninst✝²² : NormedAddCommGroup F₂\ninst✝²¹ : NormedSpace 𝕜 F₂\ninst✝²⁰ : TopologicalSpace (Bundle.TotalSpace F₂ E₂)\ninst✝¹⁹ : (x : B₂) → TopologicalSpace (E₂ x)\nEB₁ : Type u_9\ninst✝¹⁸ : NormedAddCommGroup EB₁\ninst✝¹⁷ : NormedSpace 𝕜 EB₁\nHB₁ : Type u_10\ninst✝¹⁶ : TopologicalSpace HB₁\nIB₁ : ModelWithCorners 𝕜 EB₁ HB₁\ninst✝¹⁵ : TopologicalSpace B₁\ninst✝¹⁴ : ChartedSpace HB₁ B₁\nEB₂ : Type u_11\ninst✝¹³ : NormedAddCommGroup EB₂\ninst✝¹² : NormedSpace 𝕜 EB₂\nHB₂ : Type u_12\ninst✝¹¹ : TopologicalSpace HB₂\nIB₂ : ModelWithCorners 𝕜 EB₂ HB₂\ninst✝¹⁰ : TopologicalSpace B₂\ninst✝⁹ : ChartedSpace HB₂ B₂\nEM : Type u_13\ninst✝⁸ : NormedAddCommGroup EM\ninst✝⁷ : NormedSpace 𝕜 EM\nHM : Type u_14\ninst✝⁶ : TopologicalSpace HM\nIM : ModelWithCorners 𝕜 EM HM\ninst✝⁵ : TopologicalSpace M\ninst✝⁴ : ChartedSpace HM M\nn : WithTop ENat\ninst✝³ : FiberBundle F₁ E₁\ninst✝² : VectorBundle 𝕜 F₁ E₁\ninst✝¹ : FiberBundle F₂ E₂\ninst✝ : VectorBundle 𝕜 F₂ E₂\nb₁ : M → B₁\nb₂ : M → B₂\nm₀ : M\nϕ : (m : M) → ContinuousLinearMap (RingHom.id 𝕜) (E₁ (b₁ m)) (E₂ (b₂ m))\nv : (m : M) → E₁ (b₁ m)\nhϕ : ContMDiffAt IM (modelWithCornersSelf 𝕜 (ContinuousLinearMap (RingHom.id 𝕜) F₁ F₂)) n (fun m => ContinuousLinearMap.inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) m₀\nhv : ContMDiffAt IM (IB₁.prod (modelWithCornersSelf 𝕜 F₁)) n (fun m => { proj := b₁ m, snd := v m }) m₀\nhb₂ : ContMDiffAt IM IB₂ n b₂ m₀\n⊢ ContMDiffAt IM (IB₂.prod (modelWithCornersSelf 𝕜 F₂)) n (fun m => { proj := b₂ m, snd := (ϕ m) (v m) }) m₀","decl":"/-- Consider a `C^n` map `v : M → E₁` to a vector bundle, over a basemap `b₁ : M → B₁`, and\nanother basemap `b₂ : M → B₂`. Given linear maps `ϕ m : E₁ (b₁ m) → E₂ (b₂ m)` depending smoothly\non `m`, one can apply `ϕ m` to `g m`, and the resulting map is `C^n`.\n\nNote that the smoothness of `ϕ` can not be always be stated as smoothness of a map into a manifold,\nas the pullback bundles `b₁ *ᵖ E₁` and `b₂ *ᵖ E₂` only make sense when `b₁` and `b₂` are globally\nsmooth, but we want to apply this lemma with only local information. Therefore, we formulate it\nusing smoothness of `ϕ` read in coordinates.\n\nVersion for `ContMDiffAt`. We also give a version for `ContMDiffWithinAt`, but no version for\n`ContMDiffOn` or `ContMDiff` as our assumption, written in coordinates, only makes sense around\na point.\n -/\nlemma ContMDiffAt.clm_apply_of_inCoordinates\n    (hϕ : ContMDiffAt IM 𝓘(𝕜, F₁ →L[𝕜] F₂) n\n      (fun m ↦ inCoordinates F₁ E₁ F₂ E₂ (b₁ m₀) (b₁ m) (b₂ m₀) (b₂ m) (ϕ m)) m₀)\n    (hv : ContMDiffAt IM (IB₁.prod 𝓘(𝕜, F₁)) n (fun m ↦ (v m : TotalSpace F₁ E₁)) m₀)\n    (hb₂ : ContMDiffAt IM IB₂ n b₂ m₀) :\n    ContMDiffAt IM (IB₂.prod 𝓘(𝕜, F₂)) n (fun m ↦ (ϕ m (v m) : TotalSpace F₂ E₂)) m₀ := by\n  rw [← contMDiffWithinAt_univ] at hϕ hv hb₂ ⊢\n  exact ContMDiffWithinAt.clm_apply_of_inCoordinates hϕ hv hb₂\n\n"}
