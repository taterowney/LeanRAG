{"name":"IsNilpotent.charpoly_eq_X_pow_finrank","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nφ : Module.End R M\nh : IsNilpotent φ\n⊢ Eq (LinearMap.charpoly φ) (HPow.hPow Polynomial.X (Module.finrank R M))","decl":"lemma IsNilpotent.charpoly_eq_X_pow_finrank {φ : Module.End R M} (h : IsNilpotent φ) :\n    φ.charpoly = X ^ finrank R M := by\n  rw [← sub_eq_zero]\n  apply IsNilpotent.eq_zero\n  rw [finrank_eq_card_chooseBasisIndex]\n  apply Matrix.isNilpotent_charpoly_sub_pow_of_isNilpotent\n  exact h.map (LinearMap.toMatrixAlgEquiv (chooseBasis R M))\n\n"}
{"name":"LinearMap.isNilpotent_iff_charpoly","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : IsDomain R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Finite R M\ninst✝ : Module.Free R M\nφ : Module.End R M\n⊢ Iff (IsNilpotent φ) (Eq (LinearMap.charpoly φ) (HPow.hPow Polynomial.X (Module.finrank R M)))","decl":"lemma isNilpotent_iff_charpoly (φ : End R M) :\n    IsNilpotent φ ↔ charpoly φ = X ^ finrank R M :=\n  ⟨IsNilpotent.charpoly_eq_X_pow_finrank,\n    fun h ↦ ⟨finrank R M, by rw [← @aeval_X_pow R, ← h, aeval_self_charpoly φ]⟩⟩\n\n"}
{"name":"LinearMap.charpoly_nilpotent_tfae","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R M\ninst✝ : IsNoetherian R M\nφ : Module.End R M\n⊢ (List.cons (IsNilpotent φ) (List.cons (Eq (LinearMap.charpoly φ) (HPow.hPow Polynomial.X (Module.finrank R M))) (List.cons (∀ (m : M), Exists fun n => Eq ((HPow.hPow φ n) m) 0) (List.cons (Eq (LinearMap.charpoly φ).natTrailingDegree (Module.finrank R M)) List.nil)))).TFAE","decl":"open Module.Free in\nlemma charpoly_nilpotent_tfae [IsNoetherian R M] (φ : Module.End R M) :\n    List.TFAE [\n      IsNilpotent φ,\n      φ.charpoly = X ^ finrank R M,\n      ∀ m : M, ∃ (n : ℕ), (φ ^ n) m = 0,\n      natTrailingDegree φ.charpoly = finrank R M ] := by\n  tfae_have 1 → 2 := IsNilpotent.charpoly_eq_X_pow_finrank\n  tfae_have 2 → 3\n  | h, m => by\n    use finrank R M\n    suffices φ ^ finrank R M = 0 by simp only [this, LinearMap.zero_apply]\n    simpa only [h, map_pow, aeval_X] using φ.aeval_self_charpoly\n  tfae_have 3 → 1\n  | h => by\n    obtain ⟨n, hn⟩ := Filter.eventually_atTop.mp <| φ.eventually_iSup_ker_pow_eq\n    use n\n    ext x\n    rw [zero_apply, ← mem_ker, ← hn n le_rfl]\n    obtain ⟨k, hk⟩ := h x\n    rw [← mem_ker] at hk\n    exact Submodule.mem_iSup_of_mem _ hk\n  tfae_have 2 ↔ 4 := by\n    rw [← φ.charpoly_natDegree, φ.charpoly_monic.eq_X_pow_iff_natTrailingDegree_eq_natDegree]\n  tfae_finish\n\n"}
{"name":"LinearMap.charpoly_eq_X_pow_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"R : Type u_1\nM : Type u_3\ninst✝⁶ : CommRing R\ninst✝⁵ : IsDomain R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : Module.Finite R M\ninst✝¹ : Module.Free R M\ninst✝ : IsNoetherian R M\nφ : Module.End R M\n⊢ Iff (Eq (LinearMap.charpoly φ) (HPow.hPow Polynomial.X (Module.finrank R M))) (∀ (m : M), Exists fun n => Eq ((HPow.hPow φ n) m) 0)","decl":"lemma charpoly_eq_X_pow_iff [IsNoetherian R M] (φ : Module.End R M) :\n    φ.charpoly = X ^ finrank R M ↔ ∀ m : M, ∃ (n : ℕ), (φ ^ n) m = 0 :=\n  (charpoly_nilpotent_tfae φ).out 1 2\n\n"}
{"name":"LinearMap.hasEigenvalue_zero_tfae","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"K : Type u_2\nM : Type u_3\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : Module.Finite K M\nφ : Module.End K M\n⊢ (List.cons (φ.HasEigenvalue 0) (List.cons ((minpoly K φ).IsRoot 0) (List.cons (Eq (Polynomial.constantCoeff (LinearMap.charpoly φ)) 0) (List.cons (Eq (LinearMap.det φ) 0) (List.cons (LT.lt Bot.bot (LinearMap.ker φ)) (List.cons (Exists fun m => And (Ne m 0) (Eq (φ m) 0)) List.nil)))))).TFAE","decl":"open Module.Free in\nlemma hasEigenvalue_zero_tfae (φ : Module.End K M) :\n    List.TFAE [\n      Module.End.HasEigenvalue φ 0,\n      IsRoot (minpoly K φ) 0,\n      constantCoeff φ.charpoly = 0,\n      LinearMap.det φ = 0,\n      ⊥ < ker φ,\n      ∃ (m : M), m ≠ 0 ∧ φ m = 0 ] := by\n  tfae_have 1 ↔ 2 := Module.End.hasEigenvalue_iff_isRoot\n  tfae_have 2 → 3 := by\n    obtain ⟨F, hF⟩ := minpoly_dvd_charpoly φ\n    simp only [IsRoot.def, constantCoeff_apply, coeff_zero_eq_eval_zero, hF, eval_mul]\n    intro h; rw [h, zero_mul]\n  tfae_have 3 → 4 := by\n    rw [← LinearMap.det_toMatrix (chooseBasis K M), Matrix.det_eq_sign_charpoly_coeff,\n      constantCoeff_apply, charpoly]\n    intro h; rw [h, mul_zero]\n  tfae_have 4 → 5 := bot_lt_ker_of_det_eq_zero\n  tfae_have 5 → 6 := by\n    contrapose!\n    simp only [not_bot_lt_iff, eq_bot_iff]\n    intro h x\n    simp only [mem_ker, Submodule.mem_bot]\n    contrapose!\n    apply h\n  tfae_have 6 → 1\n  | ⟨x, h1, h2⟩ => by\n    apply Module.End.hasEigenvalue_of_hasEigenvector ⟨_, h1⟩\n    simpa only [Module.End.eigenspace_zero, mem_ker] using h2\n  tfae_finish\n\n"}
{"name":"LinearMap.charpoly_constantCoeff_eq_zero_iff","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"K : Type u_2\nM : Type u_3\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : Module.Finite K M\nφ : Module.End K M\n⊢ Iff (Eq (Polynomial.constantCoeff (LinearMap.charpoly φ)) 0) (Exists fun m => And (Ne m 0) (Eq (φ m) 0))","decl":"lemma charpoly_constantCoeff_eq_zero_iff (φ : Module.End K M) :\n    constantCoeff φ.charpoly = 0 ↔ ∃ (m : M), m ≠ 0 ∧ φ m = 0 :=\n  (hasEigenvalue_zero_tfae φ).out 2 5\n\n"}
{"name":"LinearMap.not_hasEigenvalue_zero_tfae","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"K : Type u_2\nM : Type u_3\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : Module.Finite K M\nφ : Module.End K M\n⊢ (List.cons (Not (φ.HasEigenvalue 0)) (List.cons (Not ((minpoly K φ).IsRoot 0)) (List.cons (Ne (Polynomial.constantCoeff (LinearMap.charpoly φ)) 0) (List.cons (Ne (LinearMap.det φ) 0) (List.cons (Eq (LinearMap.ker φ) Bot.bot) (List.cons (∀ (m : M), Eq (φ m) 0 → Eq m 0) List.nil)))))).TFAE","decl":"open Module.Free in\nlemma not_hasEigenvalue_zero_tfae (φ : Module.End K M) :\n    List.TFAE [\n      ¬ Module.End.HasEigenvalue φ 0,\n      ¬ IsRoot (minpoly K φ) 0,\n      constantCoeff φ.charpoly ≠ 0,\n      LinearMap.det φ ≠ 0,\n      ker φ = ⊥,\n      ∀ (m : M), φ m = 0 → m = 0 ] := by\n  have := (hasEigenvalue_zero_tfae φ).not\n  dsimp only [List.map] at this\n  push_neg at this\n  have aux₁ : ∀ m, (m ≠ 0 → φ m ≠ 0) ↔ (φ m = 0 → m = 0) := by intro m; apply not_imp_not\n  have aux₂ : ker φ = ⊥ ↔ ¬ ⊥ < ker φ := by rw [bot_lt_iff_ne_bot, not_not]\n  simpa only [aux₁, aux₂] using this\n\n"}
{"name":"LinearMap.finrank_maxGenEigenspace","module":"Mathlib.LinearAlgebra.Eigenspace.Zero","initialProofState":"K : Type u_2\nM : Type u_3\ninst✝³ : Field K\ninst✝² : AddCommGroup M\ninst✝¹ : Module K M\ninst✝ : Module.Finite K M\nφ : Module.End K M\n⊢ Eq (Module.finrank K (Subtype fun x => Membership.mem (φ.maxGenEigenspace 0) x)) (LinearMap.charpoly φ).natTrailingDegree","decl":"open Module.Free in\nlemma finrank_maxGenEigenspace (φ : Module.End K M) :\n    finrank K (φ.maxGenEigenspace 0) = natTrailingDegree (φ.charpoly) := by\n  set V := φ.maxGenEigenspace 0\n  have hV : V = ⨆ (n : ℕ), ker (φ ^ n) := by\n    simp [V, ← Module.End.iSup_genEigenspace_eq, Module.End.genEigenspace_nat]\n  let W := ⨅ (n : ℕ), LinearMap.range (φ ^ n)\n  have hVW : IsCompl V W := by\n    rw [hV]\n    exact LinearMap.isCompl_iSup_ker_pow_iInf_range_pow φ\n  have hφV : ∀ x ∈ V, φ x ∈ V := by\n    simp only [V, Module.End.mem_maxGenEigenspace, zero_smul, sub_zero,\n      forall_exists_index]\n    intro x n hx\n    use n\n    rw [← LinearMap.mul_apply, ← pow_succ, pow_succ', LinearMap.mul_apply, hx, map_zero]\n  have hφW : ∀ x ∈ W, φ x ∈ W := by\n    simp only [W, Submodule.mem_iInf, mem_range]\n    intro x H n\n    obtain ⟨y, rfl⟩ := H n\n    use φ y\n    rw [← LinearMap.mul_apply, ← pow_succ, pow_succ', LinearMap.mul_apply]\n  let F := φ.restrict hφV\n  let G := φ.restrict hφW\n  let ψ := F.prodMap G\n  let e := Submodule.prodEquivOfIsCompl V W hVW\n  let bV := chooseBasis K V\n  let bW := chooseBasis K W\n  let b := bV.prod bW\n  have hψ : ψ = e.symm.conj φ := by\n    apply b.ext\n    simp only [Basis.prod_apply, coe_inl, coe_inr, prodMap_apply, LinearEquiv.conj_apply,\n      LinearEquiv.symm_symm, Submodule.coe_prodEquivOfIsCompl, coe_comp, LinearEquiv.coe_coe,\n      Function.comp_apply, coprod_apply, Submodule.coe_subtype, map_add, Sum.forall, Sum.elim_inl,\n      map_zero, ZeroMemClass.coe_zero, add_zero, LinearEquiv.eq_symm_apply, and_self,\n      Submodule.coe_prodEquivOfIsCompl', restrict_coe_apply, implies_true, Sum.elim_inr, zero_add,\n      e, V, W, ψ, F, G, b]\n  rw [← e.symm.charpoly_conj φ, ← hψ, charpoly_prodMap,\n    natTrailingDegree_mul (charpoly_monic _).ne_zero (charpoly_monic _).ne_zero]\n  have hG : natTrailingDegree (charpoly G) = 0 := by\n    apply Polynomial.natTrailingDegree_eq_zero_of_constantCoeff_ne_zero\n    apply ((not_hasEigenvalue_zero_tfae G).out 2 5).mpr\n    intro x hx\n    apply Subtype.ext\n    suffices x.1 ∈ V ⊓ W by rwa [hVW.inf_eq_bot, Submodule.mem_bot] at this\n    suffices x.1 ∈ V from ⟨this, x.2⟩\n    simp only [Module.End.mem_maxGenEigenspace, zero_smul, sub_zero, V]\n    use 1\n    rw [pow_one]\n    rwa [Subtype.ext_iff] at hx\n  rw [hG, add_zero, eq_comm]\n  apply ((charpoly_nilpotent_tfae F).out 2 3).mp\n  simp only [Subtype.forall, Module.End.mem_maxGenEigenspace, zero_smul, sub_zero, V, F]\n  rintro x ⟨n, hx⟩\n  use n\n  apply Subtype.ext\n  rw [ZeroMemClass.coe_zero]\n  refine .trans ?_ hx\n  generalize_proofs h'\n  clear hx\n  induction n with\n  | zero => simp only [pow_zero, one_apply]\n  | succ n ih => simp only [pow_succ', LinearMap.mul_apply, ih, restrict_apply]\n\n"}
