{"name":"Equiv.left_inv","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nself : Equiv α β\n⊢ Function.LeftInverse self.invFun self.toFun","decl":"/-- `α ≃ β` is the type of functions from `α → β` with a two-sided inverse. -/\nstructure Equiv (α : Sort*) (β : Sort _) where\n  protected toFun : α → β\n  protected invFun : β → α\n  protected left_inv : LeftInverse invFun toFun\n  protected right_inv : RightInverse invFun toFun\n\n"}
{"name":"Equiv.mk.inj","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ntoFun✝ : α → β\ninvFun✝ : β → α\nleft_inv✝ : Function.LeftInverse invFun✝ toFun✝\nright_inv✝ : Function.RightInverse invFun✝ toFun✝\ntoFun : α → β\ninvFun : β → α\nleft_inv : Function.LeftInverse invFun toFun\nright_inv : Function.RightInverse invFun toFun\nx✝ : Eq { toFun := toFun✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }\n⊢ And (Eq toFun✝ toFun) (Eq invFun✝ invFun)","decl":"/-- `α ≃ β` is the type of functions from `α → β` with a two-sided inverse. -/\nstructure Equiv (α : Sort*) (β : Sort _) where\n  protected toFun : α → β\n  protected invFun : β → α\n  protected left_inv : LeftInverse invFun toFun\n  protected right_inv : RightInverse invFun toFun\n\n"}
{"name":"Equiv.mk.injEq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ntoFun✝ : α → β\ninvFun✝ : β → α\nleft_inv✝ : Function.LeftInverse invFun✝ toFun✝\nright_inv✝ : Function.RightInverse invFun✝ toFun✝\ntoFun : α → β\ninvFun : β → α\nleft_inv : Function.LeftInverse invFun toFun\nright_inv : Function.RightInverse invFun toFun\n⊢ Eq (Eq { toFun := toFun✝, invFun := invFun✝, left_inv := left_inv✝, right_inv := right_inv✝ } { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) (And (Eq toFun✝ toFun) (Eq invFun✝ invFun))","decl":"/-- `α ≃ β` is the type of functions from `α → β` with a two-sided inverse. -/\nstructure Equiv (α : Sort*) (β : Sort _) where\n  protected toFun : α → β\n  protected invFun : β → α\n  protected left_inv : LeftInverse invFun toFun\n  protected right_inv : RightInverse invFun toFun\n\n"}
{"name":"Equiv.right_inv","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nself : Equiv α β\n⊢ Function.RightInverse self.invFun self.toFun","decl":"/-- `α ≃ β` is the type of functions from `α → β` with a two-sided inverse. -/\nstructure Equiv (α : Sort*) (β : Sort _) where\n  protected toFun : α → β\n  protected invFun : β → α\n  protected left_inv : LeftInverse invFun toFun\n  protected right_inv : RightInverse invFun toFun\n\n"}
{"name":"Equiv.mk.sizeOf_spec","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ninst✝¹ : SizeOf α\ninst✝ : SizeOf β\ntoFun : α → β\ninvFun : β → α\nleft_inv : Function.LeftInverse invFun toFun\nright_inv : Function.RightInverse invFun toFun\n⊢ Eq (SizeOf.sizeOf { toFun := toFun, invFun := invFun, left_inv := left_inv, right_inv := right_inv }) 1","decl":"/-- `α ≃ β` is the type of functions from `α → β` with a two-sided inverse. -/\nstructure Equiv (α : Sort*) (β : Sort _) where\n  protected toFun : α → β\n  protected invFun : β → α\n  protected left_inv : LeftInverse invFun toFun\n  protected right_inv : RightInverse invFun toFun\n\n"}
{"name":"EquivLike.coe_coe","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nF : Sort u_1\ninst✝ : EquivLike F α β\ne : F\n⊢ Eq ⇑↑e ⇑e","decl":"@[simp, norm_cast]\nlemma _root_.EquivLike.coe_coe {F} [EquivLike F α β] (e : F) :\n    ((e : α ≃ β) : α → β) = e := rfl\n\n"}
{"name":"Equiv.coe_fn_mk","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\ng : β → α\nl : Function.LeftInverse g f\nr : Function.RightInverse g f\n⊢ Eq (⇑{ toFun := f, invFun := g, left_inv := l, right_inv := r }) f","decl":"@[simp] theorem coe_fn_mk (f : α → β) (g l r) : (Equiv.mk f g l r : α → β) = f :=\n  rfl\n\n"}
{"name":"Equiv.coe_fn_injective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\n⊢ Function.Injective fun e => ⇑e","decl":"/-- The map `(r ≃ s) → (r → s)` is injective. -/\ntheorem coe_fn_injective : @Function.Injective (α ≃ β) (α → β) (fun e => e) :=\n  DFunLike.coe_injective'\n\n"}
{"name":"Equiv.coe_inj","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne₁ e₂ : Equiv α β\n⊢ Iff (Eq ⇑e₁ ⇑e₂) (Eq e₁ e₂)","decl":"protected theorem coe_inj {e₁ e₂ : α ≃ β} : (e₁ : α → β) = e₂ ↔ e₁ = e₂ :=\n  @DFunLike.coe_fn_eq _ _ _ _ e₁ e₂\n\n"}
{"name":"Equiv.ext_iff","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf g : Equiv α β\n⊢ Iff (Eq f g) (∀ (x : α), Eq (f x) (g x))","decl":"@[ext] theorem ext {f g : Equiv α β} (H : ∀ x, f x = g x) : f = g := DFunLike.ext f g H\n\n"}
{"name":"Equiv.ext","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf g : Equiv α β\nH : ∀ (x : α), Eq (f x) (g x)\n⊢ Eq f g","decl":"@[ext] theorem ext {f g : Equiv α β} (H : ∀ x, f x = g x) : f = g := DFunLike.ext f g H\n\n"}
{"name":"Equiv.congr_arg","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\nx x' : α\na✝ : Eq x x'\n⊢ Eq (f x) (f x')","decl":"protected theorem congr_arg {f : Equiv α β} {x x' : α} : x = x' → f x = f x' :=\n  DFunLike.congr_arg f\n\n"}
{"name":"Equiv.congr_fun","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf g : Equiv α β\nh : Eq f g\nx : α\n⊢ Eq (f x) (g x)","decl":"protected theorem congr_fun {f g : Equiv α β} (h : f = g) (x : α) : f x = g x :=\n  DFunLike.congr_fun h x\n\n"}
{"name":"Equiv.Perm.ext","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nσ τ : Equiv.Perm α\nH : ∀ (x : α), Eq (σ x) (τ x)\n⊢ Eq σ τ","decl":"@[ext] theorem Perm.ext {σ τ : Equiv.Perm α} (H : ∀ x, σ x = τ x) : σ = τ := Equiv.ext H\n\n"}
{"name":"Equiv.Perm.ext_iff","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nσ τ : Equiv.Perm α\n⊢ Iff (Eq σ τ) (∀ (x : α), Eq (σ x) (τ x))","decl":"@[ext] theorem Perm.ext {σ τ : Equiv.Perm α} (H : ∀ x, σ x = τ x) : σ = τ := Equiv.ext H\n\n"}
{"name":"Equiv.Perm.congr_arg","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nf : Equiv.Perm α\nx x' : α\na✝ : Eq x x'\n⊢ Eq (f x) (f x')","decl":"protected theorem Perm.congr_arg {f : Equiv.Perm α} {x x' : α} : x = x' → f x = f x' :=\n  Equiv.congr_arg\n\n"}
{"name":"Equiv.Perm.congr_fun","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nf g : Equiv.Perm α\nh : Eq f g\nx : α\n⊢ Eq (f x) (g x)","decl":"protected theorem Perm.congr_fun {f g : Equiv.Perm α} (h : f = g) (x : α) : f x = g x :=\n  Equiv.congr_fun h x\n\n"}
{"name":"Equiv.left_inv'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Function.LeftInverse ⇑e.symm ⇑e","decl":"theorem left_inv' (e : α ≃ β) : Function.LeftInverse e.symm e := e.left_inv\n"}
{"name":"Equiv.right_inv'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Function.RightInverse ⇑e.symm ⇑e","decl":"theorem right_inv' (e : α ≃ β) : Function.RightInverse e.symm e := e.right_inv\n\n"}
{"name":"Equiv.instTrans_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"a✝ : Sort u_2\nb✝ : Sort u_1\nc✝ : Sort u_3\ne₁ : Equiv a✝ b✝\ne₂ : Equiv b✝ c✝\n⊢ Eq (Trans.trans e₁ e₂) (e₁.trans e₂)","decl":"@[simps]\ninstance : Trans Equiv Equiv Equiv where\n  trans := Equiv.trans\n\n-- Porting note: this is not a syntactic tautology any more because\n-- the coercion from `e` to a function is now `DFunLike.coe` not `e.toFun`\n"}
{"name":"Equiv.toFun_as_coe","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq e.toFun ⇑e","decl":"@[simp, mfld_simps] theorem toFun_as_coe (e : α ≃ β) : e.toFun = e := rfl\n\n"}
{"name":"Equiv.invFun_as_coe","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq e.invFun ⇑e.symm","decl":"@[simp, mfld_simps] theorem invFun_as_coe (e : α ≃ β) : e.invFun = e.symm := rfl\n\n"}
{"name":"Equiv.injective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Function.Injective ⇑e","decl":"protected theorem injective (e : α ≃ β) : Injective e := EquivLike.injective e\n\n"}
{"name":"Equiv.surjective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Function.Surjective ⇑e","decl":"protected theorem surjective (e : α ≃ β) : Surjective e := EquivLike.surjective e\n\n"}
{"name":"Equiv.bijective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Function.Bijective ⇑e","decl":"protected theorem bijective (e : α ≃ β) : Bijective e := EquivLike.bijective e\n\n"}
{"name":"Equiv.subsingleton","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\ninst✝ : Subsingleton β\n⊢ Subsingleton α","decl":"protected theorem subsingleton (e : α ≃ β) [Subsingleton β] : Subsingleton α :=\n  e.injective.subsingleton\n\n"}
{"name":"Equiv.subsingleton.symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\ninst✝ : Subsingleton α\n⊢ Subsingleton β","decl":"protected theorem subsingleton.symm (e : α ≃ β) [Subsingleton α] : Subsingleton β :=\n  e.symm.injective.subsingleton\n\n"}
{"name":"Equiv.subsingleton_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Iff (Subsingleton α) (Subsingleton β)","decl":"theorem subsingleton_congr (e : α ≃ β) : Subsingleton α ↔ Subsingleton β :=\n  ⟨fun _ => e.symm.subsingleton, fun _ => e.subsingleton⟩\n\n"}
{"name":"Equiv.equiv_subsingleton_cod","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Subsingleton β\n⊢ Subsingleton (Equiv α β)","decl":"instance equiv_subsingleton_cod [Subsingleton β] : Subsingleton (α ≃ β) :=\n  ⟨fun _ _ => Equiv.ext fun _ => Subsingleton.elim _ _⟩\n\n"}
{"name":"Equiv.equiv_subsingleton_dom","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ninst✝ : Subsingleton α\n⊢ Subsingleton (Equiv α β)","decl":"instance equiv_subsingleton_dom [Subsingleton α] : Subsingleton (α ≃ β) :=\n  ⟨fun f _ => Equiv.ext fun _ => @Subsingleton.elim _ (Equiv.subsingleton.symm f) _ _⟩\n\n"}
{"name":"Equiv.Perm.subsingleton_eq_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\ninst✝ : Subsingleton α\ne : Equiv.Perm α\n⊢ Eq e (Equiv.refl α)","decl":"theorem Perm.subsingleton_eq_refl [Subsingleton α] (e : Perm α) : e = Equiv.refl α :=\n  Subsingleton.elim _ _\n\n"}
{"name":"Equiv.nonempty_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Iff (Nonempty α) (Nonempty β)","decl":"theorem nonempty_congr (e : α ≃ β) : Nonempty α ↔ Nonempty β := Nonempty.congr e e.symm\n\n"}
{"name":"Equiv.nonempty","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\ninst✝ : Nonempty β\n⊢ Nonempty α","decl":"protected theorem nonempty (e : α ≃ β) [Nonempty β] : Nonempty α := e.nonempty_congr.mpr ‹_›\n\n"}
{"name":"Equiv.coe_fn_symm_mk","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\ng : β → α\nl : Function.LeftInverse g f\nr : Function.RightInverse g f\n⊢ Eq (⇑{ toFun := f, invFun := g, left_inv := l, right_inv := r }.symm) g","decl":"@[simp] theorem coe_fn_symm_mk (f : α → β) (g l r) : ((Equiv.mk f g l r).symm : β → α) = g := rfl\n\n"}
{"name":"Equiv.coe_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\n⊢ Eq (⇑(Equiv.refl α)) id","decl":"@[simp] theorem coe_refl : (Equiv.refl α : α → α) = id := rfl\n\n"}
{"name":"Equiv.Perm.coe_subsingleton","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\ninst✝ : Subsingleton α\ne : Equiv.Perm α\n⊢ Eq (⇑e) id","decl":"/-- This cannot be a `simp` lemmas as it incorrectly matches against `e : α ≃ synonym α`, when\n`synonym α` is semireducible. This makes a mess of `Multiplicative.ofAdd` etc. -/\ntheorem Perm.coe_subsingleton {α : Type*} [Subsingleton α] (e : Perm α) : (e : α → α) = id := by\n  rw [Perm.subsingleton_eq_refl e, coe_refl]\n\n-- Porting note: marking this as `@[simp]` because `simp` doesn't fire on `coe_refl`\n-- in an expression such as `Equiv.refl a x`\n"}
{"name":"Equiv.refl_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nx : α\n⊢ Eq ((Equiv.refl α) x) x","decl":"@[simp] theorem refl_apply (x : α) : Equiv.refl α x = x := rfl\n\n"}
{"name":"Equiv.coe_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nf : Equiv α β\ng : Equiv β γ\n⊢ Eq (⇑(f.trans g)) (Function.comp ⇑g ⇑f)","decl":"@[simp] theorem coe_trans (f : α ≃ β) (g : β ≃ γ) : (f.trans g : α → γ) = g ∘ f := rfl\n\n-- Porting note: marking this as `@[simp]` because `simp` doesn't fire on `coe_trans`\n-- in an expression such as `Equiv.trans f g x`\n"}
{"name":"Equiv.trans_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nf : Equiv α β\ng : Equiv β γ\na : α\n⊢ Eq ((f.trans g) a) (g (f a))","decl":"@[simp] theorem trans_apply (f : α ≃ β) (g : β ≃ γ) (a : α) : (f.trans g) a = g (f a) := rfl\n\n"}
{"name":"Equiv.apply_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\nx : β\n⊢ Eq (e (e.symm x)) x","decl":"@[simp] theorem apply_symm_apply (e : α ≃ β) (x : β) : e (e.symm x) = x := e.right_inv x\n\n"}
{"name":"Equiv.symm_apply_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\nx : α\n⊢ Eq (e.symm (e x)) x","decl":"@[simp] theorem symm_apply_apply (e : α ≃ β) (x : α) : e.symm (e x) = x := e.left_inv x\n\n"}
{"name":"Equiv.symm_comp_self","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq (Function.comp ⇑e.symm ⇑e) id","decl":"@[simp] theorem symm_comp_self (e : α ≃ β) : e.symm ∘ e = id := funext e.symm_apply_apply\n\n"}
{"name":"Equiv.self_comp_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq (Function.comp ⇑e ⇑e.symm) id","decl":"@[simp] theorem self_comp_symm (e : α ≃ β) : e ∘ e.symm = id := funext e.apply_symm_apply\n\n"}
{"name":"EquivLike.apply_coe_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nF : Sort u_1\ninst✝ : EquivLike F α β\ne : F\nx : β\n⊢ Eq (e ((↑e).symm x)) x","decl":"@[simp] lemma _root_.EquivLike.apply_coe_symm_apply {F} [EquivLike F α β] (e : F) (x : β) :\n    e ((e : α ≃ β).symm x) = x :=\n  (e : α ≃ β).apply_symm_apply x\n\n"}
{"name":"EquivLike.coe_symm_apply_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nF : Sort u_1\ninst✝ : EquivLike F α β\ne : F\nx : α\n⊢ Eq ((↑e).symm (e x)) x","decl":"@[simp] lemma _root_.EquivLike.coe_symm_apply_apply {F} [EquivLike F α β] (e : F) (x : α) :\n    (e : α ≃ β).symm (e x) = x :=\n  (e : α ≃ β).symm_apply_apply x\n\n"}
{"name":"EquivLike.coe_symm_comp_self","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nF : Sort u_1\ninst✝ : EquivLike F α β\ne : F\n⊢ Eq (Function.comp ⇑(↑e).symm ⇑e) id","decl":"@[simp] lemma _root_.EquivLike.coe_symm_comp_self {F} [EquivLike F α β] (e : F) :\n    (e : α ≃ β).symm ∘ e = id :=\n  (e : α ≃ β).symm_comp_self\n\n"}
{"name":"EquivLike.self_comp_coe_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nF : Sort u_1\ninst✝ : EquivLike F α β\ne : F\n⊢ Eq (Function.comp ⇑e ⇑(↑e).symm) id","decl":"@[simp] lemma _root_.EquivLike.self_comp_coe_symm {F} [EquivLike F α β] (e : F) :\n    e ∘ (e : α ≃ β).symm = id :=\n  (e : α ≃ β).self_comp_symm\n\n"}
{"name":"Equiv.symm_trans_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nf : Equiv α β\ng : Equiv β γ\na : γ\n⊢ Eq ((f.trans g).symm a) (f.symm (g.symm a))","decl":"@[simp] theorem symm_trans_apply (f : α ≃ β) (g : β ≃ γ) (a : γ) :\n    (f.trans g).symm a = f.symm (g.symm a) := rfl\n\n"}
{"name":"Equiv.symm_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\nb : α\n⊢ Eq (f.symm.symm b) (f b)","decl":"theorem symm_symm_apply (f : α ≃ β) (b : α) : f.symm.symm b = f b := rfl\n\n"}
{"name":"Equiv.apply_eq_iff_eq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\nx y : α\n⊢ Iff (Eq (f x) (f y)) (Eq x y)","decl":"theorem apply_eq_iff_eq (f : α ≃ β) {x y : α} : f x = f y ↔ x = y := EquivLike.apply_eq_iff_eq f\n\n"}
{"name":"Equiv.apply_eq_iff_eq_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nx : α\ny : β\nf : Equiv α β\n⊢ Iff (Eq (f x) y) (Eq x (f.symm y))","decl":"theorem apply_eq_iff_eq_symm_apply {x : α} {y : β} (f : α ≃ β) : f x = y ↔ x = f.symm y := by\n  conv_lhs => rw [← apply_symm_apply f y]\n  rw [apply_eq_iff_eq]\n\n"}
{"name":"Equiv.cast_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α β : Sort u_1\nh : Eq α β\nx : α\n⊢ Eq ((Equiv.cast h) x) (cast h x)","decl":"@[simp] theorem cast_apply {α β} (h : α = β) (x : α) : Equiv.cast h x = cast h x := rfl\n\n"}
{"name":"Equiv.cast_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α β : Sort u_1\nh : Eq α β\n⊢ Eq (Equiv.cast h).symm (Equiv.cast ⋯)","decl":"@[simp] theorem cast_symm {α β} (h : α = β) : (Equiv.cast h).symm = Equiv.cast h.symm := rfl\n\n"}
{"name":"Equiv.cast_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nh : optParam (Eq α α) ⋯\n⊢ Eq (Equiv.cast h) (Equiv.refl α)","decl":"@[simp] theorem cast_refl {α} (h : α = α := rfl) : Equiv.cast h = Equiv.refl α := rfl\n\n"}
{"name":"Equiv.cast_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α β γ : Sort u_1\nh : Eq α β\nh2 : Eq β γ\n⊢ Eq ((Equiv.cast h).trans (Equiv.cast h2)) (Equiv.cast ⋯)","decl":"@[simp] theorem cast_trans {α β γ} (h : α = β) (h2 : β = γ) :\n    (Equiv.cast h).trans (Equiv.cast h2) = Equiv.cast (h.trans h2) :=\n  ext fun x => by substs h h2; rfl\n\n"}
{"name":"Equiv.cast_eq_iff_heq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α β : Sort u_1\nh : Eq α β\na : α\nb : β\n⊢ Iff (Eq ((Equiv.cast h) a) b) (HEq a b)","decl":"theorem cast_eq_iff_heq {α β} (h : α = β) {a : α} {b : β} : Equiv.cast h a = b ↔ HEq a b := by\n  subst h; simp [coe_refl]\n\n"}
{"name":"Equiv.symm_apply_eq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ne : Equiv α β\nx : β\ny : α\n⊢ Iff (Eq (e.symm x) y) (Eq x (e y))","decl":"theorem symm_apply_eq {α β} (e : α ≃ β) {x y} : e.symm x = y ↔ x = e y :=\n  ⟨fun H => by simp [H.symm], fun H => by simp [H]⟩\n\n"}
{"name":"Equiv.eq_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\ne : Equiv α β\nx : β\ny : α\n⊢ Iff (Eq y (e.symm x)) (Eq (e y) x)","decl":"theorem eq_symm_apply {α β} (e : α ≃ β) {x y} : y = e.symm x ↔ e y = x :=\n  (eq_comm.trans e.symm_apply_eq).trans eq_comm\n\n"}
{"name":"Equiv.symm_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq e.symm.symm e","decl":"@[simp] theorem symm_symm (e : α ≃ β) : e.symm.symm = e := rfl\n\n"}
{"name":"Equiv.symm_bijective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\n⊢ Function.Bijective Equiv.symm","decl":"theorem symm_bijective : Function.Bijective (Equiv.symm : (α ≃ β) → β ≃ α) :=\n  Function.bijective_iff_has_inverse.mpr ⟨_, symm_symm, symm_symm⟩\n\n"}
{"name":"Equiv.trans_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq (e.trans (Equiv.refl β)) e","decl":"@[simp] theorem trans_refl (e : α ≃ β) : e.trans (Equiv.refl β) = e := by cases e; rfl\n\n"}
{"name":"Equiv.refl_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\n⊢ Eq (Equiv.refl α).symm (Equiv.refl α)","decl":"@[simp] theorem refl_symm : (Equiv.refl α).symm = Equiv.refl α := rfl\n\n"}
{"name":"Equiv.refl_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq ((Equiv.refl α).trans e) e","decl":"@[simp] theorem refl_trans (e : α ≃ β) : (Equiv.refl α).trans e = e := by cases e; rfl\n\n"}
{"name":"Equiv.symm_trans_self","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq (e.symm.trans e) (Equiv.refl β)","decl":"@[simp] theorem symm_trans_self (e : α ≃ β) : e.symm.trans e = Equiv.refl β := ext <| by simp\n\n"}
{"name":"Equiv.self_trans_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq (e.trans e.symm) (Equiv.refl α)","decl":"@[simp] theorem self_trans_symm (e : α ≃ β) : e.trans e.symm = Equiv.refl α := ext <| by simp\n\n"}
{"name":"Equiv.trans_assoc","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nδ : Sort u_1\nab : Equiv α β\nbc : Equiv β γ\ncd : Equiv γ δ\n⊢ Eq ((ab.trans bc).trans cd) (ab.trans (bc.trans cd))","decl":"theorem trans_assoc {δ} (ab : α ≃ β) (bc : β ≃ γ) (cd : γ ≃ δ) :\n    (ab.trans bc).trans cd = ab.trans (bc.trans cd) := Equiv.ext fun _ => rfl\n\n"}
{"name":"Equiv.leftInverse_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\n⊢ Function.LeftInverse ⇑f.symm ⇑f","decl":"theorem leftInverse_symm (f : Equiv α β) : LeftInverse f.symm f := f.left_inv\n\n"}
{"name":"Equiv.rightInverse_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\n⊢ Function.RightInverse ⇑f.symm ⇑f","decl":"theorem rightInverse_symm (f : Equiv α β) : Function.RightInverse f.symm f := f.right_inv\n\n"}
{"name":"Equiv.injective_comp","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ne : Equiv α β\nf : β → γ\n⊢ Iff (Function.Injective (Function.comp f ⇑e)) (Function.Injective f)","decl":"theorem injective_comp (e : α ≃ β) (f : β → γ) : Injective (f ∘ e) ↔ Injective f :=\n  EquivLike.injective_comp e f\n\n"}
{"name":"Equiv.comp_injective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nf : α → β\ne : Equiv β γ\n⊢ Iff (Function.Injective (Function.comp (⇑e) f)) (Function.Injective f)","decl":"theorem comp_injective (f : α → β) (e : β ≃ γ) : Injective (e ∘ f) ↔ Injective f :=\n  EquivLike.comp_injective f e\n\n"}
{"name":"Equiv.surjective_comp","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ne : Equiv α β\nf : β → γ\n⊢ Iff (Function.Surjective (Function.comp f ⇑e)) (Function.Surjective f)","decl":"theorem surjective_comp (e : α ≃ β) (f : β → γ) : Surjective (f ∘ e) ↔ Surjective f :=\n  EquivLike.surjective_comp e f\n\n"}
{"name":"Equiv.comp_surjective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nf : α → β\ne : Equiv β γ\n⊢ Iff (Function.Surjective (Function.comp (⇑e) f)) (Function.Surjective f)","decl":"theorem comp_surjective (f : α → β) (e : β ≃ γ) : Surjective (e ∘ f) ↔ Surjective f :=\n  EquivLike.comp_surjective f e\n\n"}
{"name":"Equiv.bijective_comp","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ne : Equiv α β\nf : β → γ\n⊢ Iff (Function.Bijective (Function.comp f ⇑e)) (Function.Bijective f)","decl":"theorem bijective_comp (e : α ≃ β) (f : β → γ) : Bijective (f ∘ e) ↔ Bijective f :=\n  EquivLike.bijective_comp e f\n\n"}
{"name":"Equiv.comp_bijective","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nf : α → β\ne : Equiv β γ\n⊢ Iff (Function.Bijective (Function.comp (⇑e) f)) (Function.Bijective f)","decl":"theorem comp_bijective (f : α → β) (e : β ≃ γ) : Bijective (e ∘ f) ↔ Bijective f :=\n  EquivLike.comp_bijective f e\n\n"}
{"name":"Equiv.equivCongr_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Eq ((Equiv.refl α).equivCongr (Equiv.refl β)) (Equiv.refl (Equiv α β))","decl":"@[simp] theorem equivCongr_refl {α β} :\n    (Equiv.refl α).equivCongr (Equiv.refl β) = Equiv.refl (α ≃ β) := by ext; rfl\n\n"}
{"name":"Equiv.equivCongr_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nδ : Sort u_1\nab : Equiv α β\ncd : Equiv γ δ\n⊢ Eq (ab.equivCongr cd).symm (ab.symm.equivCongr cd.symm)","decl":"@[simp] theorem equivCongr_symm {δ} (ab : α ≃ β) (cd : γ ≃ δ) :\n    (ab.equivCongr cd).symm = ab.symm.equivCongr cd.symm := by ext; rfl\n\n"}
{"name":"Equiv.equivCongr_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nδ : Sort u_1\nε : Sort u_2\nζ : Sort u_3\nab : Equiv α β\nde : Equiv δ ε\nbc : Equiv β γ\nef : Equiv ε ζ\n⊢ Eq ((ab.equivCongr de).trans (bc.equivCongr ef)) ((ab.trans bc).equivCongr (de.trans ef))","decl":"@[simp] theorem equivCongr_trans {δ ε ζ} (ab : α ≃ β) (de : δ ≃ ε) (bc : β ≃ γ) (ef : ε ≃ ζ) :\n    (ab.equivCongr de).trans (bc.equivCongr ef) = (ab.trans bc).equivCongr (de.trans ef) := by\n  ext; rfl\n\n"}
{"name":"Equiv.equivCongr_refl_left","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\nbg : Equiv β γ\ne : Equiv α β\n⊢ Eq (((Equiv.refl α).equivCongr bg) e) (e.trans bg)","decl":"@[simp] theorem equivCongr_refl_left {α β γ} (bg : β ≃ γ) (e : α ≃ β) :\n    (Equiv.refl α).equivCongr bg e = e.trans bg := rfl\n\n"}
{"name":"Equiv.equivCongr_refl_right","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nab e : Equiv α β\n⊢ Eq ((ab.equivCongr (Equiv.refl β)) e) (ab.symm.trans e)","decl":"@[simp] theorem equivCongr_refl_right {α β} (ab e : α ≃ β) :\n    ab.equivCongr (Equiv.refl β) e = ab.symm.trans e := rfl\n\n"}
{"name":"Equiv.equivCongr_apply_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\nδ : Sort u_1\nab : Equiv α β\ncd : Equiv γ δ\ne : Equiv α γ\nx : β\n⊢ Eq (((ab.equivCongr cd) e) x) (cd (e (ab.symm x)))","decl":"@[simp] theorem equivCongr_apply_apply {δ} (ab : α ≃ β) (cd : γ ≃ δ) (e : α ≃ γ) (x) :\n    ab.equivCongr cd e x = cd (e (ab.symm x)) := rfl\n\n"}
{"name":"Equiv.permCongr_def","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α' : Type u_1\nβ' : Type u_2\ne : Equiv α' β'\np : Equiv.Perm α'\n⊢ Eq (e.permCongr p) ((e.symm.trans p).trans e)","decl":"theorem permCongr_def (p : Equiv.Perm α') : e.permCongr p = (e.symm.trans p).trans e := rfl\n\n"}
{"name":"Equiv.permCongr_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α' : Type u_1\nβ' : Type u_2\ne : Equiv α' β'\n⊢ Eq (e.permCongr (Equiv.refl α')) (Equiv.refl β')","decl":"@[simp] theorem permCongr_refl : e.permCongr (Equiv.refl _) = Equiv.refl _ := by\n  simp [permCongr_def]\n\n"}
{"name":"Equiv.permCongr_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α' : Type u_1\nβ' : Type u_2\ne : Equiv α' β'\n⊢ Eq e.permCongr.symm e.symm.permCongr","decl":"@[simp] theorem permCongr_symm : e.permCongr.symm = e.symm.permCongr := rfl\n\n"}
{"name":"Equiv.permCongr_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α' : Type u_1\nβ' : Type u_2\ne : Equiv α' β'\np : Equiv.Perm α'\nx : β'\n⊢ Eq ((e.permCongr p) x) (e (p (e.symm x)))","decl":"@[simp] theorem permCongr_apply (p : Equiv.Perm α') (x) : e.permCongr p x = e (p (e.symm x)) := rfl\n\n"}
{"name":"Equiv.permCongr_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α' : Type u_1\nβ' : Type u_2\ne : Equiv α' β'\np : Equiv.Perm β'\nx : α'\n⊢ Eq ((e.permCongr.symm p) x) (e.symm (p (e x)))","decl":"theorem permCongr_symm_apply (p : Equiv.Perm β') (x) :\n    e.permCongr.symm p x = e.symm (p (e x)) := rfl\n\n"}
{"name":"Equiv.permCongr_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α' : Type u_1\nβ' : Type u_2\ne : Equiv α' β'\np p' : Equiv.Perm α'\n⊢ Eq (Equiv.trans (e.permCongr p) (e.permCongr p')) (e.permCongr (Equiv.trans p p'))","decl":"theorem permCongr_trans (p p' : Equiv.Perm α') :\n    (e.permCongr p).trans (e.permCongr p') = e.permCongr (p.trans p') := by\n  ext; simp only [trans_apply, comp_apply, permCongr_apply, symm_apply_apply]\n\n"}
{"name":"Equiv.ulift_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type v\n⊢ Eq (⇑Equiv.ulift) ULift.down","decl":"/-- `ULift α` is equivalent to `α`. -/\n@[simps (config := .asFn) apply]\nprotected def ulift {α : Type v} : ULift.{u} α ≃ α :=\n  ⟨ULift.down, ULift.up, ULift.up_down, ULift.down_up.{v, u}⟩\n\n"}
{"name":"Equiv.plift_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\n⊢ Eq (⇑Equiv.plift) PLift.down","decl":"/-- `PLift α` is equivalent to `α`. -/\n@[simps (config := .asFn) apply]\nprotected def plift : PLift α ≃ α := ⟨PLift.down, PLift.up, PLift.up_down, PLift.down_up⟩\n\n"}
{"name":"Equiv.arrowCongr_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nβ₁ : Sort u_2\nα₂ : Sort u_3\nβ₂ : Sort u_4\ne₁ : Equiv α₁ α₂\ne₂ : Equiv β₁ β₂\nf : α₁ → β₁\na✝ : α₂\n⊢ Eq ((e₁.arrowCongr e₂) f a✝) (Function.comp (⇑e₂) (Function.comp f ⇑e₁.symm) a✝)","decl":"/-- If `α₁` is equivalent to `α₂` and `β₁` is equivalent to `β₂`, then the type of maps `α₁ → β₁`\nis equivalent to the type of maps `α₂ → β₂`. -/\n-- Porting note: removing `congr` attribute\n@[simps apply]\ndef arrowCongr {α₁ β₁ α₂ β₂ : Sort*} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) : (α₁ → β₁) ≃ (α₂ → β₂) where\n  toFun f := e₂ ∘ f ∘ e₁.symm\n  invFun f := e₂.symm ∘ f ∘ e₁\n  left_inv f := funext fun x => by simp only [comp_apply, symm_apply_apply]\n  right_inv f := funext fun x => by simp only [comp_apply, apply_symm_apply]\n\n"}
{"name":"Equiv.arrowCongr_comp","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nβ₁ : Sort u_2\nγ₁ : Sort u_3\nα₂ : Sort u_4\nβ₂ : Sort u_5\nγ₂ : Sort u_6\nea : Equiv α₁ α₂\neb : Equiv β₁ β₂\nec : Equiv γ₁ γ₂\nf : α₁ → β₁\ng : β₁ → γ₁\n⊢ Eq ((ea.arrowCongr ec) (Function.comp g f)) (Function.comp ((eb.arrowCongr ec) g) ((ea.arrowCongr eb) f))","decl":"theorem arrowCongr_comp {α₁ β₁ γ₁ α₂ β₂ γ₂ : Sort*} (ea : α₁ ≃ α₂) (eb : β₁ ≃ β₂) (ec : γ₁ ≃ γ₂)\n    (f : α₁ → β₁) (g : β₁ → γ₁) :\n    arrowCongr ea ec (g ∘ f) = arrowCongr eb ec g ∘ arrowCongr ea eb f := by\n  ext; simp only [comp, arrowCongr_apply, eb.symm_apply_apply]\n\n"}
{"name":"Equiv.arrowCongr_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\n⊢ Eq ((Equiv.refl α).arrowCongr (Equiv.refl β)) (Equiv.refl (α → β))","decl":"@[simp] theorem arrowCongr_refl {α β : Sort*} :\n    arrowCongr (Equiv.refl α) (Equiv.refl β) = Equiv.refl (α → β) := rfl\n\n"}
{"name":"Equiv.arrowCongr_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nα₂ : Sort u_2\nα₃ : Sort u_3\nβ₁ : Sort u_4\nβ₂ : Sort u_5\nβ₃ : Sort u_6\ne₁ : Equiv α₁ α₂\ne₁' : Equiv β₁ β₂\ne₂ : Equiv α₂ α₃\ne₂' : Equiv β₂ β₃\n⊢ Eq ((e₁.trans e₂).arrowCongr (e₁'.trans e₂')) ((e₁.arrowCongr e₁').trans (e₂.arrowCongr e₂'))","decl":"@[simp] theorem arrowCongr_trans {α₁ α₂ α₃ β₁ β₂ β₃ : Sort*}\n    (e₁ : α₁ ≃ α₂) (e₁' : β₁ ≃ β₂) (e₂ : α₂ ≃ α₃) (e₂' : β₂ ≃ β₃) :\n    arrowCongr (e₁.trans e₂) (e₁'.trans e₂') = (arrowCongr e₁ e₁').trans (arrowCongr e₂ e₂') := rfl\n\n"}
{"name":"Equiv.arrowCongr_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nα₂ : Sort u_2\nβ₁ : Sort u_3\nβ₂ : Sort u_4\ne₁ : Equiv α₁ α₂\ne₂ : Equiv β₁ β₂\n⊢ Eq (e₁.arrowCongr e₂).symm (e₁.symm.arrowCongr e₂.symm)","decl":"@[simp] theorem arrowCongr_symm {α₁ α₂ β₁ β₂ : Sort*} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) :\n    (arrowCongr e₁ e₂).symm = arrowCongr e₁.symm e₂.symm := rfl\n\n"}
{"name":"Equiv.arrowCongr'_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Type u_1\nβ₁ : Type u_2\nα₂ : Type u_3\nβ₂ : Type u_4\nhα : Equiv α₁ α₂\nhβ : Equiv β₁ β₂\nf : α₁ → β₁\na✝ : α₂\n⊢ Eq ((hα.arrowCongr' hβ) f a✝) (hβ (f (hα.symm a✝)))","decl":"/-- A version of `Equiv.arrowCongr` in `Type`, rather than `Sort`.\n\nThe `equiv_rw` tactic is not able to use the default `Sort` level `Equiv.arrowCongr`,\nbecause Lean's universe rules will not unify `?l_1` with `imax (1 ?m_1)`.\n-/\n-- Porting note: removing `congr` attribute\n@[simps! apply]\ndef arrowCongr' {α₁ β₁ α₂ β₂ : Type*} (hα : α₁ ≃ α₂) (hβ : β₁ ≃ β₂) : (α₁ → β₁) ≃ (α₂ → β₂) :=\n  Equiv.arrowCongr hα hβ\n\n"}
{"name":"Equiv.arrowCongr'_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\n⊢ Eq ((Equiv.refl α).arrowCongr' (Equiv.refl β)) (Equiv.refl (α → β))","decl":"@[simp] theorem arrowCongr'_refl {α β : Type*} :\n    arrowCongr' (Equiv.refl α) (Equiv.refl β) = Equiv.refl (α → β) := rfl\n\n"}
{"name":"Equiv.arrowCongr'_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\nα₃ : Type u_5\nβ₃ : Type u_6\ne₁ : Equiv α₁ α₂\ne₁' : Equiv β₁ β₂\ne₂ : Equiv α₂ α₃\ne₂' : Equiv β₂ β₃\n⊢ Eq ((e₁.trans e₂).arrowCongr' (e₁'.trans e₂')) ((e₁.arrowCongr' e₁').trans (e₂.arrowCongr' e₂'))","decl":"@[simp] theorem arrowCongr'_trans {α₁ α₂ β₁ β₂ α₃ β₃ : Type*}\n    (e₁ : α₁ ≃ α₂) (e₁' : β₁ ≃ β₂) (e₂ : α₂ ≃ α₃) (e₂' : β₂ ≃ β₃) :\n    arrowCongr' (e₁.trans e₂) (e₁'.trans e₂') = (arrowCongr' e₁ e₁').trans (arrowCongr' e₂ e₂') :=\n  rfl\n\n"}
{"name":"Equiv.arrowCongr'_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ₁ : Type u_3\nβ₂ : Type u_4\ne₁ : Equiv α₁ α₂\ne₂ : Equiv β₁ β₂\n⊢ Eq (e₁.arrowCongr' e₂).symm (e₁.symm.arrowCongr' e₂.symm)","decl":"@[simp] theorem arrowCongr'_symm {α₁ α₂ β₁ β₂ : Type*} (e₁ : α₁ ≃ α₂) (e₂ : β₁ ≃ β₂) :\n    (arrowCongr' e₁ e₂).symm = arrowCongr' e₁.symm e₂.symm := rfl\n\n"}
{"name":"Equiv.conj_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\nf : α → α\na✝ : β\n⊢ Eq (e.conj f a✝) (e (f (e.symm a✝)))","decl":"/-- Conjugate a map `f : α → α` by an equivalence `α ≃ β`. -/\n@[simps! apply] def conj (e : α ≃ β) : (α → α) ≃ (β → β) := arrowCongr e e\n\n"}
{"name":"Equiv.conj_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\n⊢ Eq (Equiv.refl α).conj (Equiv.refl (α → α))","decl":"@[simp] theorem conj_refl : conj (Equiv.refl α) = Equiv.refl (α → α) := rfl\n\n"}
{"name":"Equiv.conj_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\n⊢ Eq e.conj.symm e.symm.conj","decl":"@[simp] theorem conj_symm (e : α ≃ β) : e.conj.symm = e.symm.conj := rfl\n\n"}
{"name":"Equiv.conj_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nγ : Sort w\ne₁ : Equiv α β\ne₂ : Equiv β γ\n⊢ Eq (e₁.trans e₂).conj (e₁.conj.trans e₂.conj)","decl":"@[simp] theorem conj_trans (e₁ : α ≃ β) (e₂ : β ≃ γ) :\n    (e₁.trans e₂).conj = e₁.conj.trans e₂.conj := rfl\n\n-- This should not be a simp lemma as long as `(∘)` is reducible:\n-- when `(∘)` is reducible, Lean can unify `f₁ ∘ f₂` with any `g` using\n-- `f₁ := g` and `f₂ := fun x ↦ x`. This causes nontermination.\n"}
{"name":"Equiv.conj_comp","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\ne : Equiv α β\nf₁ f₂ : α → α\n⊢ Eq (e.conj (Function.comp f₁ f₂)) (Function.comp (e.conj f₁) (e.conj f₂))","decl":"theorem conj_comp (e : α ≃ β) (f₁ f₂ : α → α) : e.conj (f₁ ∘ f₂) = e.conj f₁ ∘ e.conj f₂ := by\n  apply arrowCongr_comp\n\n"}
{"name":"Equiv.eq_comp_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ne : Equiv α β\nf : β → γ\ng : α → γ\n⊢ Iff (Eq f (Function.comp g ⇑e.symm)) (Eq (Function.comp f ⇑e) g)","decl":"theorem eq_comp_symm {α β γ} (e : α ≃ β) (f : β → γ) (g : α → γ) : f = g ∘ e.symm ↔ f ∘ e = g :=\n  (e.arrowCongr (Equiv.refl γ)).symm_apply_eq.symm\n\n"}
{"name":"Equiv.comp_symm_eq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ne : Equiv α β\nf : β → γ\ng : α → γ\n⊢ Iff (Eq (Function.comp g ⇑e.symm) f) (Eq g (Function.comp f ⇑e))","decl":"theorem comp_symm_eq {α β γ} (e : α ≃ β) (f : β → γ) (g : α → γ) : g ∘ e.symm = f ↔ g = f ∘ e :=\n  (e.arrowCongr (Equiv.refl γ)).eq_symm_apply.symm\n\n"}
{"name":"Equiv.eq_symm_comp","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ne : Equiv α β\nf : γ → α\ng : γ → β\n⊢ Iff (Eq f (Function.comp (⇑e.symm) g)) (Eq (Function.comp (⇑e) f) g)","decl":"theorem eq_symm_comp {α β γ} (e : α ≃ β) (f : γ → α) (g : γ → β) : f = e.symm ∘ g ↔ e ∘ f = g :=\n  ((Equiv.refl γ).arrowCongr e).eq_symm_apply\n\n"}
{"name":"Equiv.symm_comp_eq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_1\nβ : Sort u_2\nγ : Sort u_3\ne : Equiv α β\nf : γ → α\ng : γ → β\n⊢ Iff (Eq (Function.comp (⇑e.symm) g) f) (Eq g (Function.comp (⇑e) f))","decl":"theorem symm_comp_eq {α β γ} (e : α ≃ β) (f : γ → α) (g : γ → β) : e.symm ∘ g = f ↔ g = e ∘ f :=\n  ((Equiv.refl γ).arrowCongr e).symm_apply_eq\n\n"}
{"name":"Equiv.trans_eq_refl_iff_eq_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\ng : Equiv β α\n⊢ Iff (Eq (f.trans g) (Equiv.refl α)) (Eq f g.symm)","decl":"theorem trans_eq_refl_iff_eq_symm {f : α ≃ β} {g : β ≃ α} :\n    f.trans g = Equiv.refl α ↔ f = g.symm := by\n  rw [← Equiv.coe_inj, coe_trans, coe_refl, ← eq_symm_comp, comp_id, Equiv.coe_inj]\n\n"}
{"name":"Equiv.trans_eq_refl_iff_symm_eq","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\ng : Equiv β α\n⊢ Iff (Eq (f.trans g) (Equiv.refl α)) (Eq f.symm g)","decl":"theorem trans_eq_refl_iff_symm_eq {f : α ≃ β} {g : β ≃ α} :\n    f.trans g = Equiv.refl α ↔ f.symm = g := by\n  rw [trans_eq_refl_iff_eq_symm]\n  exact ⟨fun h ↦ h ▸ rfl, fun h ↦ h ▸ rfl⟩\n\n"}
{"name":"Equiv.eq_symm_iff_trans_eq_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\ng : Equiv β α\n⊢ Iff (Eq f g.symm) (Eq (f.trans g) (Equiv.refl α))","decl":"theorem eq_symm_iff_trans_eq_refl {f : α ≃ β} {g : β ≃ α} :\n    f = g.symm ↔ f.trans g = Equiv.refl α :=\n  trans_eq_refl_iff_eq_symm.symm\n\n"}
{"name":"Equiv.symm_eq_iff_trans_eq_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : Equiv α β\ng : Equiv β α\n⊢ Iff (Eq f.symm g) (Eq (f.trans g) (Equiv.refl α))","decl":"theorem symm_eq_iff_trans_eq_refl {f : α ≃ β} {g : β ≃ α} :\n    f.symm = g ↔ f.trans g = Equiv.refl α :=\n  trans_eq_refl_iff_symm_eq.symm\n\n"}
{"name":"Equiv.piUnique_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\ninst✝ : Unique α\nβ : α → Sort u_1\n⊢ Eq (⇑(Equiv.piUnique β).symm) uniqueElim","decl":"/-- The equivalence `(∀ i, β i) ≃ β ⋆` when the domain of `β` only contains `⋆` -/\n@[simps (config := .asFn)]\ndef piUnique [Unique α] (β : α → Sort*) : (∀ i, β i) ≃ β default where\n  toFun f := f default\n  invFun := uniqueElim\n  left_inv f := by ext i; cases Unique.eq_default i; rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.piUnique_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\ninst✝ : Unique α\nβ : α → Sort u_1\n⊢ Eq ⇑(Equiv.piUnique β) fun f => f Inhabited.default","decl":"/-- The equivalence `(∀ i, β i) ≃ β ⋆` when the domain of `β` only contains `⋆` -/\n@[simps (config := .asFn)]\ndef piUnique [Unique α] (β : α → Sort*) : (∀ i, β i) ≃ β default where\n  toFun f := f default\n  invFun := uniqueElim\n  left_inv f := by ext i; cases Unique.eq_default i; rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.funUnique_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort u_1\ninst✝ : Unique α\n⊢ Eq ⇑(Equiv.funUnique α β) fun f => f Inhabited.default","decl":"/-- If `α` has a unique term, then the type of function `α → β` is equivalent to `β`. -/\n@[simps! (config := .asFn) apply symm_apply]\ndef funUnique (α β) [Unique.{u} α] : (α → β) ≃ β := piUnique _\n\n"}
{"name":"Equiv.funUnique_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort u_1\ninst✝ : Unique α\n⊢ Eq (⇑(Equiv.funUnique α β).symm) uniqueElim","decl":"/-- If `α` has a unique term, then the type of function `α → β` is equivalent to `β`. -/\n@[simps! (config := .asFn) apply symm_apply]\ndef funUnique (α β) [Unique.{u} α] : (α → β) ≃ β := piUnique _\n\n"}
{"name":"Equiv.psigmaEquivSigma_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_2\nβ : α → Type u_1\na : PSigma fun i => β i\n⊢ Eq ((Equiv.psigmaEquivSigma β) a) ⟨a.fst, a.snd⟩","decl":"/-- A `PSigma`-type is equivalent to the corresponding `Sigma`-type. -/\n@[simps apply symm_apply]\ndef psigmaEquivSigma {α} (β : α → Type*) : (Σ' i, β i) ≃ Σ i, β i where\n  toFun a := ⟨a.1, a.2⟩\n  invFun a := ⟨a.1, a.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.psigmaEquivSigma_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_2\nβ : α → Type u_1\na : Sigma fun i => β i\n⊢ Eq ((Equiv.psigmaEquivSigma β).symm a) ⟨a.fst, a.snd⟩","decl":"/-- A `PSigma`-type is equivalent to the corresponding `Sigma`-type. -/\n@[simps apply symm_apply]\ndef psigmaEquivSigma {α} (β : α → Type*) : (Σ' i, β i) ≃ Σ i, β i where\n  toFun a := ⟨a.1, a.2⟩\n  invFun a := ⟨a.1, a.2⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.psigmaEquivSigmaPLift_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_2\nβ : α → Sort u_1\na : PSigma fun i => β i\n⊢ Eq ((Equiv.psigmaEquivSigmaPLift β) a) ⟨{ down := a.fst }, { down := a.snd }⟩","decl":"/-- A `PSigma`-type is equivalent to the corresponding `Sigma`-type. -/\n@[simps apply symm_apply]\ndef psigmaEquivSigmaPLift {α} (β : α → Sort*) : (Σ' i, β i) ≃ Σ i : PLift α, PLift (β i.down) where\n  toFun a := ⟨PLift.up a.1, PLift.up a.2⟩\n  invFun a := ⟨a.1.down, a.2.down⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.psigmaEquivSigmaPLift_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_2\nβ : α → Sort u_1\na : Sigma fun i => PLift (β i.down)\n⊢ Eq ((Equiv.psigmaEquivSigmaPLift β).symm a) ⟨a.fst.down, a.snd.down⟩","decl":"/-- A `PSigma`-type is equivalent to the corresponding `Sigma`-type. -/\n@[simps apply symm_apply]\ndef psigmaEquivSigmaPLift {α} (β : α → Sort*) : (Σ' i, β i) ≃ Σ i : PLift α, PLift (β i.down) where\n  toFun a := ⟨PLift.up a.1, PLift.up a.2⟩\n  invFun a := ⟨a.1.down, a.2.down⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n\n"}
{"name":"Equiv.psigmaCongrRight_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ₁ : α → Sort u_1\nβ₂ : α → Sort u_2\nF : (a : α) → Equiv (β₁ a) (β₂ a)\na : PSigma fun a => β₁ a\n⊢ Eq ((Equiv.psigmaCongrRight F) a) ⟨a.fst, (F a.fst) a.snd⟩","decl":"/-- A family of equivalences `Π a, β₁ a ≃ β₂ a` generates an equivalence between `Σ' a, β₁ a` and\n`Σ' a, β₂ a`. -/\n@[simps apply]\ndef psigmaCongrRight {β₁ β₂ : α → Sort*} (F : ∀ a, β₁ a ≃ β₂ a) : (Σ' a, β₁ a) ≃ Σ' a, β₂ a where\n  toFun a := ⟨a.1, F a.1 a.2⟩\n  invFun a := ⟨a.1, (F a.1).symm a.2⟩\n  left_inv | ⟨a, b⟩ => congr_arg (PSigma.mk a) <| symm_apply_apply (F a) b\n  right_inv | ⟨a, b⟩ => congr_arg (PSigma.mk a) <| apply_symm_apply (F a) b\n\n"}
{"name":"Equiv.psigmaCongrRight_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_4\nβ₁ : α → Sort u_1\nβ₂ : α → Sort u_2\nβ₃ : α → Sort u_3\nF : (a : α) → Equiv (β₁ a) (β₂ a)\nG : (a : α) → Equiv (β₂ a) (β₃ a)\n⊢ Eq ((Equiv.psigmaCongrRight F).trans (Equiv.psigmaCongrRight G)) (Equiv.psigmaCongrRight fun a => (F a).trans (G a))","decl":"theorem psigmaCongrRight_trans {α} {β₁ β₂ β₃ : α → Sort*}\n    (F : ∀ a, β₁ a ≃ β₂ a) (G : ∀ a, β₂ a ≃ β₃ a) :\n    (psigmaCongrRight F).trans (psigmaCongrRight G) =\n      psigmaCongrRight fun a => (F a).trans (G a) := rfl\n\n"}
{"name":"Equiv.psigmaCongrRight_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_3\nβ₁ : α → Sort u_1\nβ₂ : α → Sort u_2\nF : (a : α) → Equiv (β₁ a) (β₂ a)\n⊢ Eq (Equiv.psigmaCongrRight F).symm (Equiv.psigmaCongrRight fun a => (F a).symm)","decl":"theorem psigmaCongrRight_symm {α} {β₁ β₂ : α → Sort*} (F : ∀ a, β₁ a ≃ β₂ a) :\n    (psigmaCongrRight F).symm = psigmaCongrRight fun a => (F a).symm := rfl\n\n"}
{"name":"Equiv.psigmaCongrRight_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u_2\nβ : α → Sort u_1\n⊢ Eq (Equiv.psigmaCongrRight fun a => Equiv.refl (β a)) (Equiv.refl (PSigma fun a => β a))","decl":"@[simp]\ntheorem psigmaCongrRight_refl {α} {β : α → Sort*} :\n    (psigmaCongrRight fun a => Equiv.refl (β a)) = Equiv.refl (Σ' a, β a) := rfl\n\n"}
{"name":"Equiv.sigmaCongrRight_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_3\nβ₁ : α → Type u_1\nβ₂ : α → Type u_2\nF : (a : α) → Equiv (β₁ a) (β₂ a)\na : Sigma fun a => β₁ a\n⊢ Eq ((Equiv.sigmaCongrRight F) a) ⟨a.fst, (F a.fst) a.snd⟩","decl":"/-- A family of equivalences `Π a, β₁ a ≃ β₂ a` generates an equivalence between `Σ a, β₁ a` and\n`Σ a, β₂ a`. -/\n@[simps apply]\ndef sigmaCongrRight {α} {β₁ β₂ : α → Type*} (F : ∀ a, β₁ a ≃ β₂ a) : (Σ a, β₁ a) ≃ Σ a, β₂ a where\n  toFun a := ⟨a.1, F a.1 a.2⟩\n  invFun a := ⟨a.1, (F a.1).symm a.2⟩\n  left_inv | ⟨a, b⟩ => congr_arg (Sigma.mk a) <| symm_apply_apply (F a) b\n  right_inv | ⟨a, b⟩ => congr_arg (Sigma.mk a) <| apply_symm_apply (F a) b\n\n"}
{"name":"Equiv.sigmaCongrRight_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_4\nβ₁ : α → Type u_1\nβ₂ : α → Type u_2\nβ₃ : α → Type u_3\nF : (a : α) → Equiv (β₁ a) (β₂ a)\nG : (a : α) → Equiv (β₂ a) (β₃ a)\n⊢ Eq ((Equiv.sigmaCongrRight F).trans (Equiv.sigmaCongrRight G)) (Equiv.sigmaCongrRight fun a => (F a).trans (G a))","decl":"theorem sigmaCongrRight_trans {α} {β₁ β₂ β₃ : α → Type*}\n    (F : ∀ a, β₁ a ≃ β₂ a) (G : ∀ a, β₂ a ≃ β₃ a) :\n    (sigmaCongrRight F).trans (sigmaCongrRight G) =\n      sigmaCongrRight fun a => (F a).trans (G a) := rfl\n\n"}
{"name":"Equiv.sigmaCongrRight_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_3\nβ₁ : α → Type u_1\nβ₂ : α → Type u_2\nF : (a : α) → Equiv (β₁ a) (β₂ a)\n⊢ Eq (Equiv.sigmaCongrRight F).symm (Equiv.sigmaCongrRight fun a => (F a).symm)","decl":"theorem sigmaCongrRight_symm {α} {β₁ β₂ : α → Type*} (F : ∀ a, β₁ a ≃ β₂ a) :\n    (sigmaCongrRight F).symm = sigmaCongrRight fun a => (F a).symm := rfl\n\n"}
{"name":"Equiv.sigmaCongrRight_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_2\nβ : α → Type u_1\n⊢ Eq (Equiv.sigmaCongrRight fun a => Equiv.refl (β a)) (Equiv.refl (Sigma fun a => β a))","decl":"@[simp]\ntheorem sigmaCongrRight_refl {α} {β : α → Type*} :\n    (sigmaCongrRight fun a => Equiv.refl (β a)) = Equiv.refl (Σ a, β a) := rfl\n\n"}
{"name":"Equiv.Perm.sigmaCongrRight_trans","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\nβ : α → Type u_2\nF G : (a : α) → Equiv.Perm (β a)\n⊢ Eq (Equiv.trans (Equiv.Perm.sigmaCongrRight F) (Equiv.Perm.sigmaCongrRight G)) (Equiv.Perm.sigmaCongrRight fun a => Equiv.trans (F a) (G a))","decl":"@[simp] theorem sigmaCongrRight_trans {α} {β : α → Sort _}\n    (F : ∀ a, Perm (β a)) (G : ∀ a, Perm (β a)) :\n    (sigmaCongrRight F).trans (sigmaCongrRight G) = sigmaCongrRight fun a => (F a).trans (G a) :=\n  Equiv.sigmaCongrRight_trans F G\n\n"}
{"name":"Equiv.Perm.sigmaCongrRight_symm","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\nβ : α → Type u_2\nF : (a : α) → Equiv.Perm (β a)\n⊢ Eq (Equiv.symm (Equiv.Perm.sigmaCongrRight F)) (Equiv.Perm.sigmaCongrRight fun a => Equiv.symm (F a))","decl":"@[simp] theorem sigmaCongrRight_symm {α} {β : α → Sort _} (F : ∀ a, Perm (β a)) :\n    (sigmaCongrRight F).symm = sigmaCongrRight fun a => (F a).symm :=\n  Equiv.sigmaCongrRight_symm F\n\n"}
{"name":"Equiv.Perm.sigmaCongrRight_refl","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\nβ : α → Type u_2\n⊢ Eq (Equiv.Perm.sigmaCongrRight fun a => Equiv.refl (β a)) (Equiv.refl (Sigma fun a => β a))","decl":"@[simp] theorem sigmaCongrRight_refl {α} {β : α → Sort _} :\n    (sigmaCongrRight fun a => Equiv.refl (β a)) = Equiv.refl (Σ a, β a) :=\n  Equiv.sigmaCongrRight_refl\n\n"}
{"name":"Equiv.sigmaCongrLeft_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Type u_1\nα₂ : Type u_2\nβ : α₂ → Type u_3\ne : Equiv α₁ α₂\na : Sigma fun a => β (e a)\n⊢ Eq (e.sigmaCongrLeft a) ⟨e a.fst, a.snd⟩","decl":"/-- An equivalence `f : α₁ ≃ α₂` generates an equivalence between `Σ a, β (f a)` and `Σ a, β a`. -/\n@[simps apply] def sigmaCongrLeft {α₁ α₂ : Type*} {β : α₂ → Sort _} (e : α₁ ≃ α₂) :\n    (Σ a : α₁, β (e a)) ≃ Σ a : α₂, β a where\n  toFun a := ⟨e a.1, a.2⟩\n  invFun a := ⟨e.symm a.1, (e.right_inv' a.1).symm ▸ a.2⟩\n  -- Porting note: this was a pretty gnarly match already, and it got worse after porting\n  left_inv := fun ⟨a, b⟩ =>\n    match (motive := ∀ a' (h : a' = a), Sigma.mk _ (congr_arg e h.symm ▸ b) = ⟨a, b⟩)\n      e.symm (e a), e.left_inv a with\n    | _, rfl => rfl\n  right_inv := fun ⟨a, b⟩ =>\n    match (motive := ∀ a' (h : a' = a), Sigma.mk a' (h.symm ▸ b) = ⟨a, b⟩)\n      e (e.symm a), e.apply_symm_apply _ with\n    | _, rfl => rfl\n\n"}
{"name":"Equiv.sigmaEquivProd_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\na : Prod α β\n⊢ Eq ((Equiv.sigmaEquivProd α β).symm a) ⟨a.fst, a.snd⟩","decl":"/-- `Sigma` type with a constant fiber is equivalent to the product. -/\n@[simps (config := { attrs := [`mfld_simps] }) apply symm_apply]\ndef sigmaEquivProd (α β : Type*) : (Σ _ : α, β) ≃ α × β :=\n  ⟨fun a => ⟨a.1, a.2⟩, fun a => ⟨a.1, a.2⟩, fun ⟨_, _⟩ => rfl, fun ⟨_, _⟩ => rfl⟩\n\n"}
{"name":"Equiv.sigmaEquivProd_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Type u_1\nβ : Type u_2\na : Sigma fun x => β\n⊢ Eq ((Equiv.sigmaEquivProd α β) a) { fst := a.fst, snd := a.snd }","decl":"/-- `Sigma` type with a constant fiber is equivalent to the product. -/\n@[simps (config := { attrs := [`mfld_simps] }) apply symm_apply]\ndef sigmaEquivProd (α β : Type*) : (Σ _ : α, β) ≃ α × β :=\n  ⟨fun a => ⟨a.1, a.2⟩, fun a => ⟨a.1, a.2⟩, fun ⟨_, _⟩ => rfl, fun ⟨_, _⟩ => rfl⟩\n\n"}
{"name":"Equiv.forall_congr_right","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nq : β → Prop\ne : Equiv α β\n⊢ Iff (∀ (a : α), q (e a)) (∀ (b : β), q b)","decl":"protected lemma forall_congr_right : (∀ a, q (e a)) ↔ ∀ b, q b :=\n  ⟨fun h a ↦ by simpa using h (e.symm a), fun h _ ↦ h _⟩\n\n"}
{"name":"Equiv.forall_congr_left","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\ne : Equiv α β\n⊢ Iff (∀ (a : α), p a) (∀ (b : β), p (e.symm b))","decl":"protected lemma forall_congr_left : (∀ a, p a) ↔ ∀ b, p (e.symm b) :=\n  e.symm.forall_congr_right.symm\n\n"}
{"name":"Equiv.forall_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (a : α), Iff (p a) (q (e a))\n⊢ Iff (∀ (a : α), p a) (∀ (b : β), q b)","decl":"protected lemma forall_congr (h : ∀ a, p a ↔ q (e a)) : (∀ a, p a) ↔ ∀ b, q b :=\n  e.forall_congr_left.trans (by simp [h])\n\n"}
{"name":"Equiv.forall_congr'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (b : β), Iff (p (e.symm b)) (q b)\n⊢ Iff (∀ (a : α), p a) (∀ (b : β), q b)","decl":"protected lemma forall_congr' (h : ∀ b, p (e.symm b) ↔ q b) : (∀ a, p a) ↔ ∀ b, q b :=\n  e.forall_congr_left.trans (by simp [h])\n\n"}
{"name":"Equiv.exists_congr_right","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nq : β → Prop\ne : Equiv α β\n⊢ Iff (Exists fun a => q (e a)) (Exists fun b => q b)","decl":"protected lemma exists_congr_right : (∃ a, q (e a)) ↔ ∃ b, q b :=\n  ⟨fun ⟨_, h⟩ ↦ ⟨_, h⟩, fun ⟨a, h⟩ ↦ ⟨e.symm a, by simpa using h⟩⟩\n\n"}
{"name":"Equiv.exists_congr_left","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\ne : Equiv α β\n⊢ Iff (Exists fun a => p a) (Exists fun b => p (e.symm b))","decl":"protected lemma exists_congr_left : (∃ a, p a) ↔ ∃ b, p (e.symm b) :=\n  e.symm.exists_congr_right.symm\n\n"}
{"name":"Equiv.exists_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (a : α), Iff (p a) (q (e a))\n⊢ Iff (Exists fun a => p a) (Exists fun b => q b)","decl":"protected lemma exists_congr (h : ∀ a, p a ↔ q (e a)) : (∃ a, p a) ↔ ∃ b, q b :=\n  e.exists_congr_left.trans <| by simp [h]\n\n"}
{"name":"Equiv.exists_congr'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (b : β), Iff (p (e.symm b)) (q b)\n⊢ Iff (Exists fun a => p a) (Exists fun b => q b)","decl":"protected lemma exists_congr' (h : ∀ b, p (e.symm b) ↔ q b) : (∃ a, p a) ↔ ∃ b, q b :=\n  e.exists_congr_left.trans <| by simp [h]\n\n"}
{"name":"Equiv.existsUnique_congr_right","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nq : β → Prop\ne : Equiv α β\n⊢ Iff (ExistsUnique fun a => q (e a)) (ExistsUnique fun b => q b)","decl":"protected lemma existsUnique_congr_right : (∃! a, q (e a)) ↔ ∃! b, q b :=\n  e.exists_congr <| by simpa using fun _ _ ↦ e.forall_congr (by simp)\n\n"}
{"name":"Equiv.existsUnique_congr_left","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\ne : Equiv α β\n⊢ Iff (ExistsUnique fun a => p a) (ExistsUnique fun b => p (e.symm b))","decl":"protected lemma existsUnique_congr_left : (∃! a, p a) ↔ ∃! b, p (e.symm b) :=\n  e.symm.existsUnique_congr_right.symm\n\n"}
{"name":"Equiv.existsUnique_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (a : α), Iff (p a) (q (e a))\n⊢ Iff (ExistsUnique fun a => p a) (ExistsUnique fun b => q b)","decl":"protected lemma existsUnique_congr (h : ∀ a, p a ↔ q (e a)) : (∃! a, p a) ↔ ∃! b, q b :=\n  e.existsUnique_congr_left.trans <| by simp [h]\n\n"}
{"name":"Equiv.existsUnique_congr'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\np : α → Prop\nq : β → Prop\ne : Equiv α β\nh : ∀ (b : β), Iff (p (e.symm b)) (q b)\n⊢ Iff (ExistsUnique fun a => p a) (ExistsUnique fun b => q b)","decl":"protected lemma existsUnique_congr' (h : ∀ b, p (e.symm b) ↔ q b) : (∃! a, p a) ↔ ∃! b, q b :=\n  e.existsUnique_congr_left.trans <| by simp [h]\n\n-- We next build some higher arity versions of `Equiv.forall_congr`.\n-- Although they appear to just be repeated applications of `Equiv.forall_congr`,\n-- unification of metavariables works better with these versions.\n-- In particular, they are necessary in `equiv_rw`.\n-- (Stopping at ternary functions seems reasonable: at least in 1-categorical mathematics,\n-- it's rare to have axioms involving more than 3 elements at once.)\n\n"}
{"name":"Equiv.forall₂_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nα₂ : Sort u_2\nβ₁ : Sort u_3\nβ₂ : Sort u_4\np : α₁ → β₁ → Prop\nq : α₂ → β₂ → Prop\neα : Equiv α₁ α₂\neβ : Equiv β₁ β₂\nh : ∀ {x : α₁} {y : β₁}, Iff (p x y) (q (eα x) (eβ y))\n⊢ Iff (∀ (x : α₁) (y : β₁), p x y) (∀ (x : α₂) (y : β₂), q x y)","decl":"protected theorem forall₂_congr {α₁ α₂ β₁ β₂ : Sort*} {p : α₁ → β₁ → Prop} {q : α₂ → β₂ → Prop}\n    (eα : α₁ ≃ α₂) (eβ : β₁ ≃ β₂) (h : ∀ {x y}, p x y ↔ q (eα x) (eβ y)) :\n    (∀ x y, p x y) ↔ ∀ x y, q x y :=\n  eα.forall_congr fun _ ↦ eβ.forall_congr <| @h _\n\n"}
{"name":"Equiv.forall₂_congr'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nα₂ : Sort u_2\nβ₁ : Sort u_3\nβ₂ : Sort u_4\np : α₁ → β₁ → Prop\nq : α₂ → β₂ → Prop\neα : Equiv α₁ α₂\neβ : Equiv β₁ β₂\nh : ∀ {x : α₂} {y : β₂}, Iff (p (eα.symm x) (eβ.symm y)) (q x y)\n⊢ Iff (∀ (x : α₁) (y : β₁), p x y) (∀ (x : α₂) (y : β₂), q x y)","decl":"protected theorem forall₂_congr' {α₁ α₂ β₁ β₂ : Sort*} {p : α₁ → β₁ → Prop} {q : α₂ → β₂ → Prop}\n    (eα : α₁ ≃ α₂) (eβ : β₁ ≃ β₂) (h : ∀ {x y}, p (eα.symm x) (eβ.symm y) ↔ q x y) :\n    (∀ x y, p x y) ↔ ∀ x y, q x y := (Equiv.forall₂_congr eα.symm eβ.symm h.symm).symm\n\n"}
{"name":"Equiv.forall₃_congr","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nα₂ : Sort u_2\nβ₁ : Sort u_3\nβ₂ : Sort u_4\nγ₁ : Sort u_5\nγ₂ : Sort u_6\np : α₁ → β₁ → γ₁ → Prop\nq : α₂ → β₂ → γ₂ → Prop\neα : Equiv α₁ α₂\neβ : Equiv β₁ β₂\neγ : Equiv γ₁ γ₂\nh : ∀ {x : α₁} {y : β₁} {z : γ₁}, Iff (p x y z) (q (eα x) (eβ y) (eγ z))\n⊢ Iff (∀ (x : α₁) (y : β₁) (z : γ₁), p x y z) (∀ (x : α₂) (y : β₂) (z : γ₂), q x y z)","decl":"protected theorem forall₃_congr\n    {α₁ α₂ β₁ β₂ γ₁ γ₂ : Sort*} {p : α₁ → β₁ → γ₁ → Prop} {q : α₂ → β₂ → γ₂ → Prop}\n    (eα : α₁ ≃ α₂) (eβ : β₁ ≃ β₂) (eγ : γ₁ ≃ γ₂) (h : ∀ {x y z}, p x y z ↔ q (eα x) (eβ y) (eγ z)) :\n    (∀ x y z, p x y z) ↔ ∀ x y z, q x y z :=\n  Equiv.forall₂_congr _ _ <| Equiv.forall_congr _ <| @h _ _\n\n"}
{"name":"Equiv.forall₃_congr'","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α₁ : Sort u_1\nα₂ : Sort u_2\nβ₁ : Sort u_3\nβ₂ : Sort u_4\nγ₁ : Sort u_5\nγ₂ : Sort u_6\np : α₁ → β₁ → γ₁ → Prop\nq : α₂ → β₂ → γ₂ → Prop\neα : Equiv α₁ α₂\neβ : Equiv β₁ β₂\neγ : Equiv γ₁ γ₂\nh : ∀ {x : α₂} {y : β₂} {z : γ₂}, Iff (p (eα.symm x) (eβ.symm y) (eγ.symm z)) (q x y z)\n⊢ Iff (∀ (x : α₁) (y : β₁) (z : γ₁), p x y z) (∀ (x : α₂) (y : β₂) (z : γ₂), q x y z)","decl":"protected theorem forall₃_congr'\n    {α₁ α₂ β₁ β₂ γ₁ γ₂ : Sort*} {p : α₁ → β₁ → γ₁ → Prop} {q : α₂ → β₂ → γ₂ → Prop}\n    (eα : α₁ ≃ α₂) (eβ : β₁ ≃ β₂) (eγ : γ₁ ≃ γ₂)\n    (h : ∀ {x y z}, p (eα.symm x) (eβ.symm y) (eγ.symm z) ↔ q x y z) :\n    (∀ x y z, p x y z) ↔ ∀ x y z, q x y z :=\n  (Equiv.forall₃_congr eα.symm eβ.symm eγ.symm h.symm).symm\n\n"}
{"name":"Equiv.ofBijective_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nhf : Function.Bijective f\na✝ : α\n⊢ Eq ((Equiv.ofBijective f hf) a✝) (f a✝)","decl":"/-- If `f` is a bijective function, then its domain is equivalent to its codomain. -/\n@[simps apply]\nnoncomputable def ofBijective (f : α → β) (hf : Bijective f) : α ≃ β where\n  toFun := f\n  invFun := surjInv hf.surjective\n  left_inv := leftInverse_surjInv hf\n  right_inv := rightInverse_surjInv _\n\n"}
{"name":"Equiv.ofBijective_apply_symm_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nhf : Function.Bijective f\nx : β\n⊢ Eq (f ((Equiv.ofBijective f hf).symm x)) x","decl":"lemma ofBijective_apply_symm_apply (f : α → β) (hf : Bijective f) (x : β) :\n    f ((ofBijective f hf).symm x) = x :=\n  (ofBijective f hf).apply_symm_apply x\n\n"}
{"name":"Equiv.ofBijective_symm_apply_apply","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nf : α → β\nhf : Function.Bijective f\nx : α\n⊢ Eq ((Equiv.ofBijective f hf).symm (f x)) x","decl":"@[simp]\nlemma ofBijective_symm_apply_apply (f : α → β) (hf : Bijective f) (x : α) :\n    (ofBijective f hf).symm (f x) = x :=\n  (ofBijective f hf).symm_apply_apply x\n\n"}
{"name":"Quot.congr_mk","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nra : α → α → Prop\nrb : β → β → Prop\ne : Equiv α β\neq : ∀ (a₁ a₂ : α), Iff (ra a₁ a₂) (rb (e a₁) (e a₂))\na : α\n⊢ Eq ((Quot.congr e eq) (Quot.mk ra a)) (Quot.mk rb (e a))","decl":"@[simp] theorem congr_mk {ra : α → α → Prop} {rb : β → β → Prop} (e : α ≃ β)\n    (eq : ∀ a₁ a₂ : α, ra a₁ a₂ ↔ rb (e a₁) (e a₂)) (a : α) :\n    Quot.congr e eq (Quot.mk ra a) = Quot.mk rb (e a) := rfl\n\n"}
{"name":"Quotient.congr_mk","module":"Mathlib.Logic.Equiv.Defs","initialProofState":"α : Sort u\nβ : Sort v\nra : Setoid α\nrb : Setoid β\ne : Equiv α β\neq : ∀ (a₁ a₂ : α), Iff (ra a₁ a₂) (rb (e a₁) (e a₂))\na : α\n⊢ Eq ((Quotient.congr e eq) (Quotient.mk ra a)) (Quotient.mk rb (e a))","decl":"@[simp] theorem congr_mk {ra : Setoid α} {rb : Setoid β} (e : α ≃ β)\n    (eq : ∀ a₁ a₂ : α, ra a₁ a₂ ↔ rb (e a₁) (e a₂)) (a : α) :\n    Quotient.congr e eq (Quotient.mk ra a) = Quotient.mk rb (e a) := rfl\n\n"}
