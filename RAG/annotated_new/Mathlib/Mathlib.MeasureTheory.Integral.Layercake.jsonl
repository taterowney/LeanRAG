{"name":"MeasureTheory.countable_meas_le_ne_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\nR : Type u_2\ninst✝¹ : MeasurableSpace α\nμ : MeasureTheory.Measure α\ninst✝ : LinearOrder R\ng : α → R\n⊢ (setOf fun t => Ne (μ (setOf fun a => LE.le t (g a))) (μ (setOf fun a => LT.lt t (g a)))).Countable","decl":"theorem countable_meas_le_ne_meas_lt (g : α → R) :\n    {t : R | μ {a : α | t ≤ g a} ≠ μ {a : α | t < g a}}.Countable := by\n  -- the target set is contained in the set of points where the function `t ↦ μ {a : α | t ≤ g a}`\n  -- jumps down on the right of `t`. This jump set is countable for any function.\n  let F : R → ℝ≥0∞ := fun t ↦ μ {a : α | t ≤ g a}\n  apply (countable_image_gt_image_Ioi F).mono\n  intro t ht\n  have : μ {a | t < g a} < μ {a | t ≤ g a} :=\n    lt_of_le_of_ne (measure_mono (fun a ha ↦ le_of_lt ha)) (Ne.symm ht)\n  exact ⟨μ {a | t < g a}, this, fun s hs ↦ measure_mono (fun a ha ↦ hs.trans_le ha)⟩\n\n"}
{"name":"MeasureTheory.meas_le_ae_eq_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝³ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nR : Type u_3\ninst✝² : LinearOrder R\ninst✝¹ : MeasurableSpace R\nν : MeasureTheory.Measure R\ninst✝ : MeasureTheory.NoAtoms ν\ng : α → R\n⊢ (MeasureTheory.ae ν).EventuallyEq (fun t => μ (setOf fun a => LE.le t (g a))) fun t => μ (setOf fun a => LT.lt t (g a))","decl":"theorem meas_le_ae_eq_meas_lt {R : Type*} [LinearOrder R] [MeasurableSpace R]\n    (ν : Measure R) [NoAtoms ν] (g : α → R) :\n    (fun t => μ {a : α | t ≤ g a}) =ᵐ[ν] fun t => μ {a : α | t < g a} :=\n  Set.Countable.measure_zero (countable_meas_le_ne_meas_lt μ g) _\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝¹ : MeasurableSpace α\nf : α → Real\ng : Real → Real\nμ : MeasureTheory.Measure α\ninst✝ : MeasureTheory.SFinite μ\nf_nn : LE.le 0 f\nf_mble : Measurable f\ng_intble : ∀ (t : Real), GT.gt t 0 → IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_mble : Measurable g\ng_nn : ∀ (t : Real), GT.gt t 0 → LE.le 0 (g t)\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f ω) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (μ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- An auxiliary version of the layer cake formula (Cavalieri's principle, tail probability\nformula), with a measurability assumption that would also essentially follow from the\nintegrability assumptions, and a sigma-finiteness assumption.\n\nSee `MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul` and\n`MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul` for the main formulations of the layer\ncake formula. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite\n    (μ : Measure α) [SFinite μ]\n    (f_nn : 0 ≤ f) (f_mble : Measurable f)\n    (g_intble : ∀ t > 0, IntervalIntegrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : ∀ t > 0, 0 ≤ g t) :\n    ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ =\n      ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n  have g_intble' : ∀ t : ℝ, 0 ≤ t → IntervalIntegrable g volume 0 t := by\n    intro t ht\n    cases' eq_or_lt_of_le ht with h h\n    · simp [← h]\n    · exact g_intble t h\n  have integrand_eq : ∀ ω,\n      ENNReal.ofReal (∫ t in (0)..f ω, g t) = ∫⁻ t in Ioc 0 (f ω), ENNReal.ofReal (g t) := by\n    intro ω\n    have g_ae_nn : 0 ≤ᵐ[volume.restrict (Ioc 0 (f ω))] g := by\n      filter_upwards [self_mem_ae_restrict (measurableSet_Ioc : MeasurableSet (Ioc 0 (f ω)))]\n        with x hx using g_nn x hx.1\n    rw [← ofReal_integral_eq_lintegral_ofReal (g_intble' (f ω) (f_nn ω)).1 g_ae_nn]\n    congr\n    exact intervalIntegral.integral_of_le (f_nn ω)\n  rw [lintegral_congr integrand_eq]\n  simp_rw [← lintegral_indicator measurableSet_Ioc]\n  -- Porting note: was part of `simp_rw` on the previous line, but didn't trigger.\n  rw [← lintegral_indicator measurableSet_Ioi, lintegral_lintegral_swap]\n  · apply congr_arg\n    funext s\n    have aux₁ :\n      (fun x => (Ioc 0 (f x)).indicator (fun t : ℝ => ENNReal.ofReal (g t)) s) = fun x =>\n        ENNReal.ofReal (g s) * (Ioi (0 : ℝ)).indicator (fun _ => 1) s *\n          (Ici s).indicator (fun _ : ℝ => (1 : ℝ≥0∞)) (f x) := by\n      funext a\n      by_cases h : s ∈ Ioc (0 : ℝ) (f a)\n      · simp only [h, show s ∈ Ioi (0 : ℝ) from h.1, show f a ∈ Ici s from h.2, indicator_of_mem,\n          mul_one]\n      · have h_copy := h\n        simp only [mem_Ioc, not_and, not_le] at h\n        by_cases h' : 0 < s\n        · simp only [h_copy, h h', indicator_of_not_mem, not_false_iff, mem_Ici, not_le, mul_zero]\n        · have : s ∉ Ioi (0 : ℝ) := h'\n          simp only [this, h', indicator_of_not_mem, not_false_iff, mul_zero,\n            zero_mul, mem_Ioc, false_and]\n    simp_rw [aux₁]\n    rw [lintegral_const_mul']\n    swap\n    · apply ENNReal.mul_ne_top ENNReal.ofReal_ne_top\n      by_cases h : (0 : ℝ) < s <;> · simp [h]\n    simp_rw [show\n        (fun a => (Ici s).indicator (fun _ : ℝ => (1 : ℝ≥0∞)) (f a)) = fun a =>\n          {a : α | s ≤ f a}.indicator (fun _ => 1) a\n        by funext a; by_cases h : s ≤ f a <;> simp [h]]\n    rw [lintegral_indicator₀]\n    swap; · exact f_mble.nullMeasurable measurableSet_Ici\n    rw [lintegral_one, Measure.restrict_apply MeasurableSet.univ, univ_inter, indicator_mul_left,\n      mul_assoc,\n      show\n        (Ioi 0).indicator (fun _x : ℝ => (1 : ℝ≥0∞)) s * μ {a : α | s ≤ f a} =\n          (Ioi 0).indicator (fun _x : ℝ => 1 * μ {a : α | s ≤ f a}) s\n        by by_cases h : 0 < s <;> simp [h]]\n    simp_rw [mul_comm _ (ENNReal.ofReal _), one_mul]\n    rfl\n  have aux₂ :\n    (Function.uncurry fun (x : α) (y : ℝ) =>\n        (Ioc 0 (f x)).indicator (fun t : ℝ => ENNReal.ofReal (g t)) y) =\n      {p : α × ℝ | p.2 ∈ Ioc 0 (f p.1)}.indicator fun p => ENNReal.ofReal (g p.2) := by\n    funext p\n    cases p with | mk p_fst p_snd => ?_\n    rw [Function.uncurry_apply_pair]\n    by_cases h : p_snd ∈ Ioc 0 (f p_fst)\n    · have h' : (p_fst, p_snd) ∈ {p : α × ℝ | p.snd ∈ Ioc 0 (f p.fst)} := h\n      rw [Set.indicator_of_mem h', Set.indicator_of_mem h]\n    · have h' : (p_fst, p_snd) ∉ {p : α × ℝ | p.snd ∈ Ioc 0 (f p.fst)} := h\n      rw [Set.indicator_of_not_mem h', Set.indicator_of_not_mem h]\n  rw [aux₂]\n  have mble₀ : MeasurableSet {p : α × ℝ | p.snd ∈ Ioc 0 (f p.fst)} := by\n    simpa only [mem_univ, Pi.zero_apply, true_and] using\n      measurableSet_region_between_oc measurable_zero f_mble MeasurableSet.univ\n  exact (ENNReal.measurable_ofReal.comp (g_mble.comp measurable_snd)).aemeasurable.indicator₀\n    mble₀.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul_of_measurable","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\ng : Real → Real\nμ : MeasureTheory.Measure α\nf_nn : LE.le 0 f\nf_mble : Measurable f\ng_intble : ∀ (t : Real), GT.gt t 0 → IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_mble : Measurable g\ng_nn : ∀ (t : Real), GT.gt t 0 → LE.le 0 (g t)\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f ω) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (μ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- An auxiliary version of the layer cake formula (Cavalieri's principle, tail probability\nformula), with a measurability assumption that would also essentially follow from the\nintegrability assumptions.\nCompared to `lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite`, we remove\nthe sigma-finite assumption.\n\nSee `MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul` and\n`MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul` for the main formulations of the layer\ncake formula. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable (μ : Measure α)\n    (f_nn : 0 ≤ f) (f_mble : Measurable f)\n    (g_intble : ∀ t > 0, IntervalIntegrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : ∀ t > 0, 0 ≤ g t) :\n    ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ =\n      ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n  /- We will reduce to the sigma-finite case, after excluding two easy cases where the result\n  is more or less obvious. -/\n  have f_nonneg : ∀ ω, 0 ≤ f ω := fun ω ↦ f_nn ω\n  -- trivial case where `g` is ae zero. Then both integrals vanish.\n  by_cases H1 : g =ᵐ[volume.restrict (Ioi (0 : ℝ))] 0\n  · have A : ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ = 0 := by\n      have : ∀ ω, ∫ t in (0)..f ω, g t = ∫ t in (0)..f ω, 0 := by\n        intro ω\n        simp_rw [intervalIntegral.integral_of_le (f_nonneg ω)]\n        apply integral_congr_ae\n        exact ae_restrict_of_ae_restrict_of_subset Ioc_subset_Ioi_self H1\n      simp [this]\n    have B : ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) = 0 := by\n      have : (fun t ↦ μ {a : α | t ≤ f a} * ENNReal.ofReal (g t))\n        =ᵐ[volume.restrict (Ioi (0 : ℝ))] 0 := by\n          filter_upwards [H1] with t ht using by simp [ht]\n      simp [lintegral_congr_ae this]\n    rw [A, B]\n  -- easy case where both sides are obviously infinite: for some `s`, one has\n  -- `μ {a : α | s < f a} = ∞` and moreover `g` is not ae zero on `[0, s]`.\n  by_cases H2 : ∃ s > 0, 0 < ∫ t in (0)..s, g t ∧ μ {a : α | s < f a} = ∞\n  · rcases H2 with ⟨s, s_pos, hs, h's⟩\n    rw [intervalIntegral.integral_of_le s_pos.le] at hs\n    /- The first integral is infinite, as for `t ∈ [0, s]` one has `μ {a : α | t ≤ f a} = ∞`,\n    and moreover the additional integral `g` is not uniformly zero. -/\n    have A : ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) = ∞ := by\n      rw [eq_top_iff]\n      calc\n      ∞ = ∫⁻ t in Ioc 0 s, ∞ * ENNReal.ofReal (g t) := by\n          have I_pos : ∫⁻ (a : ℝ) in Ioc 0 s, ENNReal.ofReal (g a) ≠ 0 := by\n            rw [← ofReal_integral_eq_lintegral_ofReal (g_intble s s_pos).1]\n            · simpa only [not_lt, ne_eq, ENNReal.ofReal_eq_zero, not_le] using hs\n            · filter_upwards [ae_restrict_mem measurableSet_Ioc] with t ht using g_nn _ ht.1\n          rw [lintegral_const_mul, ENNReal.top_mul I_pos]\n          exact ENNReal.measurable_ofReal.comp g_mble\n      _ ≤ ∫⁻ t in Ioc 0 s, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n          apply setLIntegral_mono' measurableSet_Ioc (fun x hx ↦ ?_)\n          rw [← h's]\n          gcongr\n          exact fun a ha ↦ hx.2.trans (le_of_lt ha)\n      _ ≤ ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) :=\n          lintegral_mono_set Ioc_subset_Ioi_self\n    /- The second integral is infinite, as one integrates among other things on those `ω` where\n    `f ω > s`: this is an infinite measure set, and on it the integrand is bounded below\n    by `∫ t in 0..s, g t` which is positive. -/\n    have B : ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ = ∞ := by\n      rw [eq_top_iff]\n      calc\n      ∞ = ∫⁻ _ in {a | s < f a}, ENNReal.ofReal (∫ t in (0)..s, g t) ∂μ := by\n          simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter,\n            h's, ne_eq, ENNReal.ofReal_eq_zero, not_le]\n          rw [ENNReal.mul_top]\n          simpa [intervalIntegral.integral_of_le s_pos.le] using hs\n      _ ≤ ∫⁻ ω in {a | s < f a}, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ := by\n          apply setLIntegral_mono' (measurableSet_lt measurable_const f_mble) (fun a ha ↦ ?_)\n          apply ENNReal.ofReal_le_ofReal\n          apply intervalIntegral.integral_mono_interval le_rfl s_pos.le (le_of_lt ha)\n          · filter_upwards [ae_restrict_mem measurableSet_Ioc] with t ht using g_nn _ ht.1\n          · exact g_intble _ (s_pos.trans ha)\n      _ ≤ ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ := setLIntegral_le_lintegral _ _\n    rw [A, B]\n  /- It remains to handle the interesting case, where `g` is not zero, but both integrals are\n  not obviously infinite. Let `M` be the largest number such that `g = 0` on `[0, M]`. Then we\n  may restrict `μ` to the points where `f ω > M` (as the other ones do not contribute to the\n  integral). The restricted measure `ν` is sigma-finite, as `μ` gives finite measure to\n  `{ω | f ω > a}` for any `a > M` (otherwise, we would be in the easy case above), so that\n  one can write (a full measure subset of) the space as the countable union of the finite measure\n  sets `{ω | f ω > uₙ}` for `uₙ` a sequence decreasing to `M`. Therefore,\n  this case follows from the case where the measure is sigma-finite, applied to `ν`. -/\n  push_neg at H2\n  have M_bdd : BddAbove {s : ℝ | g =ᵐ[volume.restrict (Ioc (0 : ℝ) s)] 0} := by\n    contrapose! H1\n    have : ∀ (n : ℕ), g =ᵐ[volume.restrict (Ioc (0 : ℝ) n)] 0 := by\n      intro n\n      rcases not_bddAbove_iff.1 H1 n with ⟨s, hs, ns⟩\n      exact ae_restrict_of_ae_restrict_of_subset (Ioc_subset_Ioc_right ns.le) hs\n    have Hg : g =ᵐ[volume.restrict (⋃ (n : ℕ), (Ioc (0 : ℝ) n))] 0 :=\n      (ae_restrict_iUnion_iff _ _).2 this\n    have : (⋃ (n : ℕ), (Ioc (0 : ℝ) n)) = Ioi 0 :=\n      iUnion_Ioc_eq_Ioi_self_iff.2 (fun x _ ↦ exists_nat_ge x)\n    rwa [this] at Hg\n  -- let `M` be the largest number such that `g` vanishes ae on `(0, M]`.\n  let M : ℝ := sSup {s : ℝ | g =ᵐ[volume.restrict (Ioc (0 : ℝ) s)] 0}\n  have zero_mem : 0 ∈ {s : ℝ | g =ᵐ[volume.restrict (Ioc (0 : ℝ) s)] 0} := by simpa using trivial\n  have M_nonneg : 0 ≤ M := le_csSup M_bdd zero_mem\n  -- Then the function `g` indeed vanishes ae on `(0, M]`.\n  have hgM : g =ᵐ[volume.restrict (Ioc (0 : ℝ) M)] 0 := by\n    rw [← restrict_Ioo_eq_restrict_Ioc]\n    obtain ⟨u, -, uM, ulim⟩ : ∃ u, StrictMono u ∧ (∀ (n : ℕ), u n < M) ∧ Tendsto u atTop (𝓝 M) :=\n      exists_seq_strictMono_tendsto M\n    have I : ∀ n, g =ᵐ[volume.restrict (Ioc (0 : ℝ) (u n))] 0 := by\n      intro n\n      obtain ⟨s, hs, uns⟩ : ∃ s, g =ᶠ[ae (Measure.restrict volume (Ioc 0 s))] 0 ∧ u n < s :=\n        exists_lt_of_lt_csSup (Set.nonempty_of_mem zero_mem) (uM n)\n      exact ae_restrict_of_ae_restrict_of_subset (Ioc_subset_Ioc_right uns.le) hs\n    have : g =ᵐ[volume.restrict (⋃ n, Ioc (0 : ℝ) (u n))] 0 := (ae_restrict_iUnion_iff _ _).2 I\n    apply ae_restrict_of_ae_restrict_of_subset _ this\n    rintro x ⟨x_pos, xM⟩\n    obtain ⟨n, hn⟩ : ∃ n, x < u n := ((tendsto_order.1 ulim).1 _ xM).exists\n    exact mem_iUnion.2 ⟨n, ⟨x_pos, hn.le⟩⟩\n  -- Let `ν` be the restriction of `μ` to those points where `f a > M`.\n  let ν := μ.restrict {a : α | M < f a}\n  -- This measure is sigma-finite (this is the whole point of the argument).\n  have : SigmaFinite ν := by\n    obtain ⟨u, -, uM, ulim⟩ : ∃ u, StrictAnti u ∧ (∀ (n : ℕ), M < u n) ∧ Tendsto u atTop (𝓝 M) :=\n      exists_seq_strictAnti_tendsto M\n    let s : ν.FiniteSpanningSetsIn univ :=\n    { set := fun n ↦ {a | f a ≤ M} ∪ {a | u n < f a}\n      set_mem := fun _ ↦ trivial\n      finite := by\n        intro n\n        have I : ν {a | f a ≤ M} = 0 := by\n          rw [Measure.restrict_apply (measurableSet_le f_mble measurable_const)]\n          convert measure_empty (μ := μ)\n          rw [← disjoint_iff_inter_eq_empty]\n          exact disjoint_left.mpr (fun a ha ↦ by simpa using ha)\n        have J : μ {a | u n < f a} < ∞ := by\n          rw [lt_top_iff_ne_top]\n          apply H2 _ (M_nonneg.trans_lt (uM n))\n          by_contra H3\n          rw [not_lt, intervalIntegral.integral_of_le (M_nonneg.trans (uM n).le)] at H3\n          have g_nn_ae : ∀ᵐ t ∂(volume.restrict (Ioc 0 (u n))), 0 ≤ g t := by\n            filter_upwards [ae_restrict_mem measurableSet_Ioc] with s hs using g_nn _ hs.1\n          have Ig : ∫ (t : ℝ) in Ioc 0 (u n), g t = 0 :=\n            le_antisymm H3 (integral_nonneg_of_ae g_nn_ae)\n          have J : ∀ᵐ t ∂(volume.restrict (Ioc 0 (u n))), g t = 0 :=\n            (integral_eq_zero_iff_of_nonneg_ae g_nn_ae\n              (g_intble (u n) (M_nonneg.trans_lt (uM n))).1).1 Ig\n          have : u n ≤ M := le_csSup M_bdd J\n          exact lt_irrefl _ (this.trans_lt (uM n))\n        refine lt_of_le_of_lt (measure_union_le _ _) ?_\n        rw [I, zero_add]\n        apply lt_of_le_of_lt _ J\n        exact restrict_le_self _\n      spanning := by\n        apply eq_univ_iff_forall.2 (fun a ↦ ?_)\n        rcases le_or_lt (f a) M with ha|ha\n        · exact mem_iUnion.2 ⟨0, Or.inl ha⟩\n        · obtain ⟨n, hn⟩ : ∃ n, u n < f a := ((tendsto_order.1 ulim).2 _ ha).exists\n          exact mem_iUnion.2 ⟨n, Or.inr hn⟩ }\n    exact ⟨⟨s⟩⟩\n  -- the first integrals with respect to `μ` and to `ν` coincide, as points with `f a ≤ M` are\n  -- weighted by zero as `g` vanishes there.\n  have A : ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ\n         = ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂ν := by\n    have meas : MeasurableSet {a | M < f a} := measurableSet_lt measurable_const f_mble\n    have I : ∫⁻ ω in {a | M < f a}ᶜ, ENNReal.ofReal (∫ t in (0).. f ω, g t) ∂μ\n             = ∫⁻ _ in {a | M < f a}ᶜ, 0 ∂μ := by\n      apply setLIntegral_congr_fun meas.compl (Eventually.of_forall (fun s hs ↦ ?_))\n      have : ∫ (t : ℝ) in (0)..f s, g t = ∫ (t : ℝ) in (0)..f s, 0 := by\n        simp_rw [intervalIntegral.integral_of_le (f_nonneg s)]\n        apply integral_congr_ae\n        apply ae_mono (restrict_mono ?_ le_rfl) hgM\n        apply Ioc_subset_Ioc_right\n        simpa using hs\n      simp [this]\n    simp only [lintegral_const, zero_mul] at I\n    rw [← lintegral_add_compl _ meas, I, add_zero]\n  -- the second integrals with respect to `μ` and to `ν` coincide, as points with `f a ≤ M` do not\n  -- contribute to either integral since the weight `g` vanishes.\n  have B : ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t)\n           = ∫⁻ t in Ioi 0, ν {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n    have B1 : ∫⁻ t in Ioc 0 M, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t)\n         = ∫⁻ t in Ioc 0 M, ν {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n      apply lintegral_congr_ae\n      filter_upwards [hgM] with t ht\n      simp [ht]\n    have B2 : ∫⁻ t in Ioi M, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t)\n              = ∫⁻ t in Ioi M, ν {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n      apply setLIntegral_congr_fun measurableSet_Ioi (Eventually.of_forall (fun t ht ↦ ?_))\n      rw [Measure.restrict_apply (measurableSet_le measurable_const f_mble)]\n      congr 3\n      exact (inter_eq_left.2 (fun a ha ↦ (mem_Ioi.1 ht).trans_le ha)).symm\n    have I : Ioi (0 : ℝ) = Ioc (0 : ℝ) M ∪ Ioi M := (Ioc_union_Ioi_eq_Ioi M_nonneg).symm\n    have J : Disjoint (Ioc 0 M) (Ioi M) := Ioc_disjoint_Ioi le_rfl\n    rw [I, lintegral_union measurableSet_Ioi J, lintegral_union measurableSet_Ioi J, B1, B2]\n  -- therefore, we may replace the integrals wrt `μ` with integrals wrt `ν`, and apply the\n  -- result for sigma-finite measures.\n  rw [A, B]\n  exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite\n    ν f_nn f_mble g_intble g_mble g_nn\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\ng : Real → Real\nμ : MeasureTheory.Measure α\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_mble : AEMeasurable f μ\ng_intble : ∀ (t : Real), GT.gt t 0 → IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_nn : Filter.Eventually (fun t => LE.le 0 (g t)) (MeasureTheory.ae (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)))\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f ω) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (μ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- The layer cake formula / **Cavalieri's principle** / tail probability formula:\n\nLet `f` be a non-negative measurable function on a measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G ∘ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `μ {ω | f(ω) ≥ t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `∫⁻ (G ∘ f) ∂μ = ∫⁻ t in 0..∞, g(t) * μ {ω | f(ω) ≥ t}`.\n\nSee `MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul` for a version with sets of the form\n`{ω | f(ω) > t}` instead. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul (μ : Measure α) (f_nn : 0 ≤ᵐ[μ] f)\n    (f_mble : AEMeasurable f μ) (g_intble : ∀ t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : ∀ᵐ t ∂volume.restrict (Ioi 0), 0 ≤ g t) :\n    ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ =\n      ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) := by\n  obtain ⟨G, G_mble, G_nn, g_eq_G⟩ : ∃ G : ℝ → ℝ, Measurable G ∧ 0 ≤ G\n      ∧ g =ᵐ[volume.restrict (Ioi 0)] G := by\n    refine AEMeasurable.exists_measurable_nonneg ?_ g_nn\n    exact aemeasurable_Ioi_of_forall_Ioc fun t ht => (g_intble t ht).1.1.aemeasurable\n  have g_eq_G_on : ∀ t, g =ᵐ[volume.restrict (Ioc 0 t)] G := fun t =>\n    ae_mono (Measure.restrict_mono Ioc_subset_Ioi_self le_rfl) g_eq_G\n  have G_intble : ∀ t > 0, IntervalIntegrable G volume 0 t := by\n    refine fun t t_pos => ⟨(g_intble t t_pos).1.congr_fun_ae (g_eq_G_on t), ?_⟩\n    rw [Ioc_eq_empty_of_le t_pos.lt.le]\n    exact integrableOn_empty\n  obtain ⟨F, F_mble, F_nn, f_eq_F⟩ : ∃ F : α → ℝ, Measurable F ∧ 0 ≤ F ∧ f =ᵐ[μ] F := by\n    refine ⟨fun ω ↦ max (f_mble.mk f ω) 0, f_mble.measurable_mk.max measurable_const,\n        fun ω ↦ le_max_right _ _, ?_⟩\n    filter_upwards [f_mble.ae_eq_mk, f_nn] with ω hω h'ω\n    rw [← hω]\n    exact (max_eq_left h'ω).symm\n  have eq₁ :\n    ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} * ENNReal.ofReal (g t) =\n      ∫⁻ t in Ioi 0, μ {a : α | t ≤ F a} * ENNReal.ofReal (G t) := by\n    apply lintegral_congr_ae\n    filter_upwards [g_eq_G] with t ht\n    rw [ht]\n    congr 1\n    apply measure_congr\n    filter_upwards [f_eq_F] with a ha using by simp [setOf, ha]\n  have eq₂ : ∀ᵐ ω ∂μ,\n      ENNReal.ofReal (∫ t in (0)..f ω, g t) = ENNReal.ofReal (∫ t in (0)..F ω, G t) := by\n    filter_upwards [f_eq_F] with ω fω_nn\n    rw [fω_nn]\n    congr 1\n    refine intervalIntegral.integral_congr_ae ?_\n    have fω_nn : 0 ≤ F ω := F_nn ω\n    rw [uIoc_of_le fω_nn, ←\n      ae_restrict_iff' (measurableSet_Ioc : MeasurableSet (Ioc (0 : ℝ) (F ω)))]\n    exact g_eq_G_on (F ω)\n  simp_rw [lintegral_congr_ae eq₂, eq₁]\n  exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable μ F_nn F_mble\n          G_intble G_mble (fun t _ => G_nn t)\n\n"}
{"name":"MeasureTheory.lintegral_eq_lintegral_meas_le","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\nμ : MeasureTheory.Measure α\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_mble : AEMeasurable f μ\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (f ω)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => μ (setOf fun a => LE.le t (f a)))","decl":"/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in 0..∞, μ {ω | f(ω) ≥ t}`.\n\nSee `MeasureTheory.lintegral_eq_lintegral_meas_lt` for a version with sets of the form\n`{ω | f(ω) > t}` instead. -/\ntheorem lintegral_eq_lintegral_meas_le (μ : Measure α) (f_nn : 0 ≤ᵐ[μ] f)\n    (f_mble : AEMeasurable f μ) :\n    ∫⁻ ω, ENNReal.ofReal (f ω) ∂μ = ∫⁻ t in Ioi 0, μ {a : α | t ≤ f a} := by\n  set cst := fun _ : ℝ => (1 : ℝ)\n  have cst_intble : ∀ t > 0, IntervalIntegrable cst volume 0 t := fun _ _ =>\n    intervalIntegrable_const\n  have key :=\n    lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble cst_intble\n      (Eventually.of_forall fun _ => zero_le_one)\n  simp_rw [cst, ENNReal.ofReal_one, mul_one] at key\n  rw [← key]\n  congr with ω\n  simp only [intervalIntegral.integral_const, sub_zero, Algebra.id.smul_eq_mul, mul_one]\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\ng : Real → Real\nμ : MeasureTheory.Measure α\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_mble : AEMeasurable f μ\ng_intble : ∀ (t : Real), GT.gt t 0 → IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_nn : Filter.Eventually (fun t => LE.le 0 (g t)) (MeasureTheory.ae (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)))\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f ω) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (μ (setOf fun a => LT.lt t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- The layer cake formula / Cavalieri's principle / tail probability formula:\n\nLet `f` be a non-negative measurable function on a measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G ∘ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `μ {ω | f(ω) > t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `∫⁻ (G ∘ f) ∂μ = ∫⁻ t in 0..∞, g(t) * μ {ω | f(ω) > t}`.\n\nSee `lintegral_comp_eq_lintegral_meas_le_mul` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. -/\ntheorem lintegral_comp_eq_lintegral_meas_lt_mul (μ : Measure α) (f_nn : 0 ≤ᵐ[μ] f)\n    (f_mble : AEMeasurable f μ) (g_intble : ∀ t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : ∀ᵐ t ∂volume.restrict (Ioi 0), 0 ≤ g t) :\n    ∫⁻ ω, ENNReal.ofReal (∫ t in (0)..f ω, g t) ∂μ =\n      ∫⁻ t in Ioi 0, μ {a : α | t < f a} * ENNReal.ofReal (g t) := by\n  rw [lintegral_comp_eq_lintegral_meas_le_mul μ f_nn f_mble g_intble g_nn]\n  apply lintegral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f]\n    with t ht\n  rw [ht]\n\n"}
{"name":"MeasureTheory.lintegral_eq_lintegral_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nf : α → Real\nμ : MeasureTheory.Measure α\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_mble : AEMeasurable f μ\n⊢ Eq (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (f ω)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => μ (setOf fun a => LT.lt t (f a)))","decl":"/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `∫⁻ f ∂μ = ∫⁻ t in 0..∞, μ {ω | f(ω) > t}`.\n\nSee `lintegral_eq_lintegral_meas_le` for a version with sets of the form `{ω | f(ω) ≥ t}`\ninstead. -/\ntheorem lintegral_eq_lintegral_meas_lt (μ : Measure α)\n    (f_nn : 0 ≤ᵐ[μ] f) (f_mble : AEMeasurable f μ) :\n    ∫⁻ ω, ENNReal.ofReal (f ω) ∂μ = ∫⁻ t in Ioi 0, μ {a : α | t < f a} := by\n  rw [lintegral_eq_lintegral_meas_le μ f_nn f_mble]\n  apply lintegral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f]\n    with t ht\n  rw [ht]\n\n"}
{"name":"MeasureTheory.Integrable.integral_eq_integral_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nf_intble : MeasureTheory.Integrable f μ\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ Eq (MeasureTheory.integral μ fun ω => f ω) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => (μ (setOf fun a => LT.lt t (f a))).toReal)","decl":"/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor an integrable a.e.-nonnegative real-valued function `f`, the Bochner integral of `f` can be\nwritten (roughly speaking) as: `∫ f ∂μ = ∫ t in 0..∞, μ {ω | f(ω) > t}`.\n\nSee `MeasureTheory.lintegral_eq_lintegral_meas_lt` for a version with Lebesgue integral `∫⁻`\ninstead. -/\ntheorem Integrable.integral_eq_integral_meas_lt\n    (f_intble : Integrable f μ) (f_nn : 0 ≤ᵐ[μ] f) :\n    ∫ ω, f ω ∂μ = ∫ t in Set.Ioi 0, ENNReal.toReal (μ {a : α | t < f a}) := by\n  have key := lintegral_eq_lintegral_meas_lt μ f_nn f_intble.aemeasurable\n  have lhs_finite : ∫⁻ (ω : α), ENNReal.ofReal (f ω) ∂μ < ∞ := Integrable.lintegral_lt_top f_intble\n  have rhs_finite : ∫⁻ (t : ℝ) in Set.Ioi 0, μ {a | t < f a} < ∞ := by simp only [← key, lhs_finite]\n  have rhs_integrand_finite : ∀ (t : ℝ), t > 0 → μ {a | t < f a} < ∞ :=\n    fun t ht ↦ measure_gt_lt_top f_intble ht\n  convert (ENNReal.toReal_eq_toReal lhs_finite.ne rhs_finite.ne).mpr key\n  · exact integral_eq_lintegral_of_nonneg_ae f_nn f_intble.aestronglyMeasurable\n  · have aux := @integral_eq_lintegral_of_nonneg_ae _ _ ((volume : Measure ℝ).restrict (Set.Ioi 0))\n      (fun t ↦ ENNReal.toReal (μ {a : α | t < f a})) ?_ ?_\n    · rw [aux]\n      congr 1\n      apply setLIntegral_congr_fun measurableSet_Ioi (Eventually.of_forall _)\n      exact fun t t_pos ↦ ENNReal.ofReal_toReal (rhs_integrand_finite t t_pos).ne\n    · exact Eventually.of_forall (fun x ↦ by simp only [Pi.zero_apply, ENNReal.toReal_nonneg])\n    · apply Measurable.aestronglyMeasurable\n      refine Measurable.ennreal_toReal ?_\n      exact Antitone.measurable (fun _ _ hst ↦ measure_mono (fun _ h ↦ lt_of_le_of_lt hst h))\n\n"}
{"name":"MeasureTheory.Integrable.integral_eq_integral_meas_le","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nf_intble : MeasureTheory.Integrable f μ\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\n⊢ Eq (MeasureTheory.integral μ fun ω => f ω) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => (μ (setOf fun a => LE.le t (f a))).toReal)","decl":"theorem Integrable.integral_eq_integral_meas_le\n    (f_intble : Integrable f μ) (f_nn : 0 ≤ᵐ[μ] f) :\n    ∫ ω, f ω ∂μ = ∫ t in Set.Ioi 0, ENNReal.toReal (μ {a : α | t ≤ f a}) := by\n  rw [Integrable.integral_eq_integral_meas_lt f_intble f_nn]\n  apply integral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt μ (volume.restrict (Ioi 0)) f] with t ht\n  exact congrArg ENNReal.toReal ht.symm\n\n"}
{"name":"MeasureTheory.Integrable.integral_eq_integral_Ioc_meas_le","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"α : Type u_1\ninst✝ : MeasurableSpace α\nμ : MeasureTheory.Measure α\nf : α → Real\nM : Real\nf_intble : MeasureTheory.Integrable f μ\nf_nn : (MeasureTheory.ae μ).EventuallyLE 0 f\nf_bdd : (MeasureTheory.ae μ).EventuallyLE f fun x => M\n⊢ Eq (MeasureTheory.integral μ fun ω => f ω) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 M)) fun t => (μ (setOf fun a => LE.le t (f a))).toReal)","decl":"lemma Integrable.integral_eq_integral_Ioc_meas_le {f : α → ℝ} {M : ℝ}\n    (f_intble : Integrable f μ) (f_nn : 0 ≤ᵐ[μ] f) (f_bdd : f ≤ᵐ[μ] (fun _ ↦ M)) :\n    ∫ ω, f ω ∂μ = ∫ t in Ioc 0 M, ENNReal.toReal (μ {a : α | t ≤ f a}) := by\n  rw [f_intble.integral_eq_integral_meas_le f_nn]\n  rw [setIntegral_eq_of_subset_of_ae_diff_eq_zero\n      nullMeasurableSet_Ioi Ioc_subset_Ioi_self ?_]\n  apply Eventually.of_forall (fun t ht ↦ ?_)\n  have htM : M < t := by simp_all only [mem_diff, mem_Ioi, mem_Ioc, not_and, not_le]\n  have obs : μ {a | M < f a} = 0 := by\n    rw [measure_zero_iff_ae_nmem]\n    filter_upwards [f_bdd] with a ha using not_lt.mpr ha\n  rw [ENNReal.toReal_eq_zero_iff]\n  exact Or.inl <| measure_mono_null (fun a ha ↦ lt_of_lt_of_le htM ha) obs\n\n"}
