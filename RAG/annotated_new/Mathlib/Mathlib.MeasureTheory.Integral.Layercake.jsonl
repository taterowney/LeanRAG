{"name":"MeasureTheory.countable_meas_le_ne_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\nR : Type u_2\ninstâœÂ¹ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : LinearOrder R\ng : Î± â†’ R\nâŠ¢ (setOf fun t => Ne (Î¼ (setOf fun a => LE.le t (g a))) (Î¼ (setOf fun a => LT.lt t (g a)))).Countable","decl":"theorem countable_meas_le_ne_meas_lt (g : Î± â†’ R) :\n    {t : R | Î¼ {a : Î± | t â‰¤ g a} â‰  Î¼ {a : Î± | t < g a}}.Countable := by\n  -- the target set is contained in the set of points where the function `t â†¦ Î¼ {a : Î± | t â‰¤ g a}`\n  -- jumps down on the right of `t`. This jump set is countable for any function.\n  let F : R â†’ â„â‰¥0âˆ := fun t â†¦ Î¼ {a : Î± | t â‰¤ g a}\n  apply (countable_image_gt_image_Ioi F).mono\n  intro t ht\n  have : Î¼ {a | t < g a} < Î¼ {a | t â‰¤ g a} :=\n    lt_of_le_of_ne (measure_mono (fun a ha â†¦ le_of_lt ha)) (Ne.symm ht)\n  exact âŸ¨Î¼ {a | t < g a}, this, fun s hs â†¦ measure_mono (fun a ha â†¦ hs.trans_le ha)âŸ©\n\n"}
{"name":"MeasureTheory.meas_le_ae_eq_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœÂ³ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nR : Type u_3\ninstâœÂ² : LinearOrder R\ninstâœÂ¹ : MeasurableSpace R\nÎ½ : MeasureTheory.Measure R\ninstâœ : MeasureTheory.NoAtoms Î½\ng : Î± â†’ R\nâŠ¢ (MeasureTheory.ae Î½).EventuallyEq (fun t => Î¼ (setOf fun a => LE.le t (g a))) fun t => Î¼ (setOf fun a => LT.lt t (g a))","decl":"theorem meas_le_ae_eq_meas_lt {R : Type*} [LinearOrder R] [MeasurableSpace R]\n    (Î½ : Measure R) [NoAtoms Î½] (g : Î± â†’ R) :\n    (fun t => Î¼ {a : Î± | t â‰¤ g a}) =áµ[Î½] fun t => Î¼ {a : Î± | t < g a} :=\n  Set.Countable.measure_zero (countable_meas_le_ne_meas_lt Î¼ g) _\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœÂ¹ : MeasurableSpace Î±\nf : Î± â†’ Real\ng : Real â†’ Real\nÎ¼ : MeasureTheory.Measure Î±\ninstâœ : MeasureTheory.SFinite Î¼\nf_nn : LE.le 0 f\nf_mble : Measurable f\ng_intble : âˆ€ (t : Real), GT.gt t 0 â†’ IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_mble : Measurable g\ng_nn : âˆ€ (t : Real), GT.gt t 0 â†’ LE.le 0 (g t)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun Ï‰ => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f Ï‰) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (Î¼ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- An auxiliary version of the layer cake formula (Cavalieri's principle, tail probability\nformula), with a measurability assumption that would also essentially follow from the\nintegrability assumptions, and a sigma-finiteness assumption.\n\nSee `MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul` and\n`MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul` for the main formulations of the layer\ncake formula. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite\n    (Î¼ : Measure Î±) [SFinite Î¼]\n    (f_nn : 0 â‰¤ f) (f_mble : Measurable f)\n    (g_intble : âˆ€ t > 0, IntervalIntegrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : âˆ€ t > 0, 0 â‰¤ g t) :\n    âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ =\n      âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n  have g_intble' : âˆ€ t : â„, 0 â‰¤ t â†’ IntervalIntegrable g volume 0 t := by\n    intro t ht\n    cases' eq_or_lt_of_le ht with h h\n    Â· simp [â† h]\n    Â· exact g_intble t h\n  have integrand_eq : âˆ€ Ï‰,\n      ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) = âˆ«â» t in Ioc 0 (f Ï‰), ENNReal.ofReal (g t) := by\n    intro Ï‰\n    have g_ae_nn : 0 â‰¤áµ[volume.restrict (Ioc 0 (f Ï‰))] g := by\n      filter_upwards [self_mem_ae_restrict (measurableSet_Ioc : MeasurableSet (Ioc 0 (f Ï‰)))]\n        with x hx using g_nn x hx.1\n    rw [â† ofReal_integral_eq_lintegral_ofReal (g_intble' (f Ï‰) (f_nn Ï‰)).1 g_ae_nn]\n    congr\n    exact intervalIntegral.integral_of_le (f_nn Ï‰)\n  rw [lintegral_congr integrand_eq]\n  simp_rw [â† lintegral_indicator measurableSet_Ioc]\n  -- Porting note: was part of `simp_rw` on the previous line, but didn't trigger.\n  rw [â† lintegral_indicator measurableSet_Ioi, lintegral_lintegral_swap]\n  Â· apply congr_arg\n    funext s\n    have auxâ‚ :\n      (fun x => (Ioc 0 (f x)).indicator (fun t : â„ => ENNReal.ofReal (g t)) s) = fun x =>\n        ENNReal.ofReal (g s) * (Ioi (0 : â„)).indicator (fun _ => 1) s *\n          (Ici s).indicator (fun _ : â„ => (1 : â„â‰¥0âˆ)) (f x) := by\n      funext a\n      by_cases h : s âˆˆ Ioc (0 : â„) (f a)\n      Â· simp only [h, show s âˆˆ Ioi (0 : â„) from h.1, show f a âˆˆ Ici s from h.2, indicator_of_mem,\n          mul_one]\n      Â· have h_copy := h\n        simp only [mem_Ioc, not_and, not_le] at h\n        by_cases h' : 0 < s\n        Â· simp only [h_copy, h h', indicator_of_not_mem, not_false_iff, mem_Ici, not_le, mul_zero]\n        Â· have : s âˆ‰ Ioi (0 : â„) := h'\n          simp only [this, h', indicator_of_not_mem, not_false_iff, mul_zero,\n            zero_mul, mem_Ioc, false_and]\n    simp_rw [auxâ‚]\n    rw [lintegral_const_mul']\n    swap\n    Â· apply ENNReal.mul_ne_top ENNReal.ofReal_ne_top\n      by_cases h : (0 : â„) < s <;> Â· simp [h]\n    simp_rw [show\n        (fun a => (Ici s).indicator (fun _ : â„ => (1 : â„â‰¥0âˆ)) (f a)) = fun a =>\n          {a : Î± | s â‰¤ f a}.indicator (fun _ => 1) a\n        by funext a; by_cases h : s â‰¤ f a <;> simp [h]]\n    rw [lintegral_indicatorâ‚€]\n    swap; Â· exact f_mble.nullMeasurable measurableSet_Ici\n    rw [lintegral_one, Measure.restrict_apply MeasurableSet.univ, univ_inter, indicator_mul_left,\n      mul_assoc,\n      show\n        (Ioi 0).indicator (fun _x : â„ => (1 : â„â‰¥0âˆ)) s * Î¼ {a : Î± | s â‰¤ f a} =\n          (Ioi 0).indicator (fun _x : â„ => 1 * Î¼ {a : Î± | s â‰¤ f a}) s\n        by by_cases h : 0 < s <;> simp [h]]\n    simp_rw [mul_comm _ (ENNReal.ofReal _), one_mul]\n    rfl\n  have auxâ‚‚ :\n    (Function.uncurry fun (x : Î±) (y : â„) =>\n        (Ioc 0 (f x)).indicator (fun t : â„ => ENNReal.ofReal (g t)) y) =\n      {p : Î± Ã— â„ | p.2 âˆˆ Ioc 0 (f p.1)}.indicator fun p => ENNReal.ofReal (g p.2) := by\n    funext p\n    cases p with | mk p_fst p_snd => ?_\n    rw [Function.uncurry_apply_pair]\n    by_cases h : p_snd âˆˆ Ioc 0 (f p_fst)\n    Â· have h' : (p_fst, p_snd) âˆˆ {p : Î± Ã— â„ | p.snd âˆˆ Ioc 0 (f p.fst)} := h\n      rw [Set.indicator_of_mem h', Set.indicator_of_mem h]\n    Â· have h' : (p_fst, p_snd) âˆ‰ {p : Î± Ã— â„ | p.snd âˆˆ Ioc 0 (f p.fst)} := h\n      rw [Set.indicator_of_not_mem h', Set.indicator_of_not_mem h]\n  rw [auxâ‚‚]\n  have mbleâ‚€ : MeasurableSet {p : Î± Ã— â„ | p.snd âˆˆ Ioc 0 (f p.fst)} := by\n    simpa only [mem_univ, Pi.zero_apply, true_and] using\n      measurableSet_region_between_oc measurable_zero f_mble MeasurableSet.univ\n  exact (ENNReal.measurable_ofReal.comp (g_mble.comp measurable_snd)).aemeasurable.indicatorâ‚€\n    mbleâ‚€.nullMeasurableSet\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul_of_measurable","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ Real\ng : Real â†’ Real\nÎ¼ : MeasureTheory.Measure Î±\nf_nn : LE.le 0 f\nf_mble : Measurable f\ng_intble : âˆ€ (t : Real), GT.gt t 0 â†’ IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_mble : Measurable g\ng_nn : âˆ€ (t : Real), GT.gt t 0 â†’ LE.le 0 (g t)\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun Ï‰ => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f Ï‰) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (Î¼ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- An auxiliary version of the layer cake formula (Cavalieri's principle, tail probability\nformula), with a measurability assumption that would also essentially follow from the\nintegrability assumptions.\nCompared to `lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite`, we remove\nthe sigma-finite assumption.\n\nSee `MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul` and\n`MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul` for the main formulations of the layer\ncake formula. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul_of_measurable (Î¼ : Measure Î±)\n    (f_nn : 0 â‰¤ f) (f_mble : Measurable f)\n    (g_intble : âˆ€ t > 0, IntervalIntegrable g volume 0 t) (g_mble : Measurable g)\n    (g_nn : âˆ€ t > 0, 0 â‰¤ g t) :\n    âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ =\n      âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n  /- We will reduce to the sigma-finite case, after excluding two easy cases where the result\n  is more or less obvious. -/\n  have f_nonneg : âˆ€ Ï‰, 0 â‰¤ f Ï‰ := fun Ï‰ â†¦ f_nn Ï‰\n  -- trivial case where `g` is ae zero. Then both integrals vanish.\n  by_cases H1 : g =áµ[volume.restrict (Ioi (0 : â„))] 0\n  Â· have A : âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ = 0 := by\n      have : âˆ€ Ï‰, âˆ« t in (0)..f Ï‰, g t = âˆ« t in (0)..f Ï‰, 0 := by\n        intro Ï‰\n        simp_rw [intervalIntegral.integral_of_le (f_nonneg Ï‰)]\n        apply integral_congr_ae\n        exact ae_restrict_of_ae_restrict_of_subset Ioc_subset_Ioi_self H1\n      simp [this]\n    have B : âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) = 0 := by\n      have : (fun t â†¦ Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t))\n        =áµ[volume.restrict (Ioi (0 : â„))] 0 := by\n          filter_upwards [H1] with t ht using by simp [ht]\n      simp [lintegral_congr_ae this]\n    rw [A, B]\n  -- easy case where both sides are obviously infinite: for some `s`, one has\n  -- `Î¼ {a : Î± | s < f a} = âˆ` and moreover `g` is not ae zero on `[0, s]`.\n  by_cases H2 : âˆƒ s > 0, 0 < âˆ« t in (0)..s, g t âˆ§ Î¼ {a : Î± | s < f a} = âˆ\n  Â· rcases H2 with âŸ¨s, s_pos, hs, h'sâŸ©\n    rw [intervalIntegral.integral_of_le s_pos.le] at hs\n    /- The first integral is infinite, as for `t âˆˆ [0, s]` one has `Î¼ {a : Î± | t â‰¤ f a} = âˆ`,\n    and moreover the additional integral `g` is not uniformly zero. -/\n    have A : âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) = âˆ := by\n      rw [eq_top_iff]\n      calc\n      âˆ = âˆ«â» t in Ioc 0 s, âˆ * ENNReal.ofReal (g t) := by\n          have I_pos : âˆ«â» (a : â„) in Ioc 0 s, ENNReal.ofReal (g a) â‰  0 := by\n            rw [â† ofReal_integral_eq_lintegral_ofReal (g_intble s s_pos).1]\n            Â· simpa only [not_lt, ne_eq, ENNReal.ofReal_eq_zero, not_le] using hs\n            Â· filter_upwards [ae_restrict_mem measurableSet_Ioc] with t ht using g_nn _ ht.1\n          rw [lintegral_const_mul, ENNReal.top_mul I_pos]\n          exact ENNReal.measurable_ofReal.comp g_mble\n      _ â‰¤ âˆ«â» t in Ioc 0 s, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n          apply setLIntegral_mono' measurableSet_Ioc (fun x hx â†¦ ?_)\n          rw [â† h's]\n          gcongr\n          exact fun a ha â†¦ hx.2.trans (le_of_lt ha)\n      _ â‰¤ âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) :=\n          lintegral_mono_set Ioc_subset_Ioi_self\n    /- The second integral is infinite, as one integrates among other things on those `Ï‰` where\n    `f Ï‰ > s`: this is an infinite measure set, and on it the integrand is bounded below\n    by `âˆ« t in 0..s, g t` which is positive. -/\n    have B : âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ = âˆ := by\n      rw [eq_top_iff]\n      calc\n      âˆ = âˆ«â» _ in {a | s < f a}, ENNReal.ofReal (âˆ« t in (0)..s, g t) âˆ‚Î¼ := by\n          simp only [lintegral_const, MeasurableSet.univ, Measure.restrict_apply, univ_inter,\n            h's, ne_eq, ENNReal.ofReal_eq_zero, not_le]\n          rw [ENNReal.mul_top]\n          simpa [intervalIntegral.integral_of_le s_pos.le] using hs\n      _ â‰¤ âˆ«â» Ï‰ in {a | s < f a}, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ := by\n          apply setLIntegral_mono' (measurableSet_lt measurable_const f_mble) (fun a ha â†¦ ?_)\n          apply ENNReal.ofReal_le_ofReal\n          apply intervalIntegral.integral_mono_interval le_rfl s_pos.le (le_of_lt ha)\n          Â· filter_upwards [ae_restrict_mem measurableSet_Ioc] with t ht using g_nn _ ht.1\n          Â· exact g_intble _ (s_pos.trans ha)\n      _ â‰¤ âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ := setLIntegral_le_lintegral _ _\n    rw [A, B]\n  /- It remains to handle the interesting case, where `g` is not zero, but both integrals are\n  not obviously infinite. Let `M` be the largest number such that `g = 0` on `[0, M]`. Then we\n  may restrict `Î¼` to the points where `f Ï‰ > M` (as the other ones do not contribute to the\n  integral). The restricted measure `Î½` is sigma-finite, as `Î¼` gives finite measure to\n  `{Ï‰ | f Ï‰ > a}` for any `a > M` (otherwise, we would be in the easy case above), so that\n  one can write (a full measure subset of) the space as the countable union of the finite measure\n  sets `{Ï‰ | f Ï‰ > uâ‚™}` for `uâ‚™` a sequence decreasing to `M`. Therefore,\n  this case follows from the case where the measure is sigma-finite, applied to `Î½`. -/\n  push_neg at H2\n  have M_bdd : BddAbove {s : â„ | g =áµ[volume.restrict (Ioc (0 : â„) s)] 0} := by\n    contrapose! H1\n    have : âˆ€ (n : â„•), g =áµ[volume.restrict (Ioc (0 : â„) n)] 0 := by\n      intro n\n      rcases not_bddAbove_iff.1 H1 n with âŸ¨s, hs, nsâŸ©\n      exact ae_restrict_of_ae_restrict_of_subset (Ioc_subset_Ioc_right ns.le) hs\n    have Hg : g =áµ[volume.restrict (â‹ƒ (n : â„•), (Ioc (0 : â„) n))] 0 :=\n      (ae_restrict_iUnion_iff _ _).2 this\n    have : (â‹ƒ (n : â„•), (Ioc (0 : â„) n)) = Ioi 0 :=\n      iUnion_Ioc_eq_Ioi_self_iff.2 (fun x _ â†¦ exists_nat_ge x)\n    rwa [this] at Hg\n  -- let `M` be the largest number such that `g` vanishes ae on `(0, M]`.\n  let M : â„ := sSup {s : â„ | g =áµ[volume.restrict (Ioc (0 : â„) s)] 0}\n  have zero_mem : 0 âˆˆ {s : â„ | g =áµ[volume.restrict (Ioc (0 : â„) s)] 0} := by simpa using trivial\n  have M_nonneg : 0 â‰¤ M := le_csSup M_bdd zero_mem\n  -- Then the function `g` indeed vanishes ae on `(0, M]`.\n  have hgM : g =áµ[volume.restrict (Ioc (0 : â„) M)] 0 := by\n    rw [â† restrict_Ioo_eq_restrict_Ioc]\n    obtain âŸ¨u, -, uM, ulimâŸ© : âˆƒ u, StrictMono u âˆ§ (âˆ€ (n : â„•), u n < M) âˆ§ Tendsto u atTop (ğ“ M) :=\n      exists_seq_strictMono_tendsto M\n    have I : âˆ€ n, g =áµ[volume.restrict (Ioc (0 : â„) (u n))] 0 := by\n      intro n\n      obtain âŸ¨s, hs, unsâŸ© : âˆƒ s, g =á¶ [ae (Measure.restrict volume (Ioc 0 s))] 0 âˆ§ u n < s :=\n        exists_lt_of_lt_csSup (Set.nonempty_of_mem zero_mem) (uM n)\n      exact ae_restrict_of_ae_restrict_of_subset (Ioc_subset_Ioc_right uns.le) hs\n    have : g =áµ[volume.restrict (â‹ƒ n, Ioc (0 : â„) (u n))] 0 := (ae_restrict_iUnion_iff _ _).2 I\n    apply ae_restrict_of_ae_restrict_of_subset _ this\n    rintro x âŸ¨x_pos, xMâŸ©\n    obtain âŸ¨n, hnâŸ© : âˆƒ n, x < u n := ((tendsto_order.1 ulim).1 _ xM).exists\n    exact mem_iUnion.2 âŸ¨n, âŸ¨x_pos, hn.leâŸ©âŸ©\n  -- Let `Î½` be the restriction of `Î¼` to those points where `f a > M`.\n  let Î½ := Î¼.restrict {a : Î± | M < f a}\n  -- This measure is sigma-finite (this is the whole point of the argument).\n  have : SigmaFinite Î½ := by\n    obtain âŸ¨u, -, uM, ulimâŸ© : âˆƒ u, StrictAnti u âˆ§ (âˆ€ (n : â„•), M < u n) âˆ§ Tendsto u atTop (ğ“ M) :=\n      exists_seq_strictAnti_tendsto M\n    let s : Î½.FiniteSpanningSetsIn univ :=\n    { set := fun n â†¦ {a | f a â‰¤ M} âˆª {a | u n < f a}\n      set_mem := fun _ â†¦ trivial\n      finite := by\n        intro n\n        have I : Î½ {a | f a â‰¤ M} = 0 := by\n          rw [Measure.restrict_apply (measurableSet_le f_mble measurable_const)]\n          convert measure_empty (Î¼ := Î¼)\n          rw [â† disjoint_iff_inter_eq_empty]\n          exact disjoint_left.mpr (fun a ha â†¦ by simpa using ha)\n        have J : Î¼ {a | u n < f a} < âˆ := by\n          rw [lt_top_iff_ne_top]\n          apply H2 _ (M_nonneg.trans_lt (uM n))\n          by_contra H3\n          rw [not_lt, intervalIntegral.integral_of_le (M_nonneg.trans (uM n).le)] at H3\n          have g_nn_ae : âˆ€áµ t âˆ‚(volume.restrict (Ioc 0 (u n))), 0 â‰¤ g t := by\n            filter_upwards [ae_restrict_mem measurableSet_Ioc] with s hs using g_nn _ hs.1\n          have Ig : âˆ« (t : â„) in Ioc 0 (u n), g t = 0 :=\n            le_antisymm H3 (integral_nonneg_of_ae g_nn_ae)\n          have J : âˆ€áµ t âˆ‚(volume.restrict (Ioc 0 (u n))), g t = 0 :=\n            (integral_eq_zero_iff_of_nonneg_ae g_nn_ae\n              (g_intble (u n) (M_nonneg.trans_lt (uM n))).1).1 Ig\n          have : u n â‰¤ M := le_csSup M_bdd J\n          exact lt_irrefl _ (this.trans_lt (uM n))\n        refine lt_of_le_of_lt (measure_union_le _ _) ?_\n        rw [I, zero_add]\n        apply lt_of_le_of_lt _ J\n        exact restrict_le_self _\n      spanning := by\n        apply eq_univ_iff_forall.2 (fun a â†¦ ?_)\n        rcases le_or_lt (f a) M with ha|ha\n        Â· exact mem_iUnion.2 âŸ¨0, Or.inl haâŸ©\n        Â· obtain âŸ¨n, hnâŸ© : âˆƒ n, u n < f a := ((tendsto_order.1 ulim).2 _ ha).exists\n          exact mem_iUnion.2 âŸ¨n, Or.inr hnâŸ© }\n    exact âŸ¨âŸ¨sâŸ©âŸ©\n  -- the first integrals with respect to `Î¼` and to `Î½` coincide, as points with `f a â‰¤ M` are\n  -- weighted by zero as `g` vanishes there.\n  have A : âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼\n         = âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î½ := by\n    have meas : MeasurableSet {a | M < f a} := measurableSet_lt measurable_const f_mble\n    have I : âˆ«â» Ï‰ in {a | M < f a}á¶œ, ENNReal.ofReal (âˆ« t in (0).. f Ï‰, g t) âˆ‚Î¼\n             = âˆ«â» _ in {a | M < f a}á¶œ, 0 âˆ‚Î¼ := by\n      apply setLIntegral_congr_fun meas.compl (Eventually.of_forall (fun s hs â†¦ ?_))\n      have : âˆ« (t : â„) in (0)..f s, g t = âˆ« (t : â„) in (0)..f s, 0 := by\n        simp_rw [intervalIntegral.integral_of_le (f_nonneg s)]\n        apply integral_congr_ae\n        apply ae_mono (restrict_mono ?_ le_rfl) hgM\n        apply Ioc_subset_Ioc_right\n        simpa using hs\n      simp [this]\n    simp only [lintegral_const, zero_mul] at I\n    rw [â† lintegral_add_compl _ meas, I, add_zero]\n  -- the second integrals with respect to `Î¼` and to `Î½` coincide, as points with `f a â‰¤ M` do not\n  -- contribute to either integral since the weight `g` vanishes.\n  have B : âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t)\n           = âˆ«â» t in Ioi 0, Î½ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n    have B1 : âˆ«â» t in Ioc 0 M, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t)\n         = âˆ«â» t in Ioc 0 M, Î½ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n      apply lintegral_congr_ae\n      filter_upwards [hgM] with t ht\n      simp [ht]\n    have B2 : âˆ«â» t in Ioi M, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t)\n              = âˆ«â» t in Ioi M, Î½ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n      apply setLIntegral_congr_fun measurableSet_Ioi (Eventually.of_forall (fun t ht â†¦ ?_))\n      rw [Measure.restrict_apply (measurableSet_le measurable_const f_mble)]\n      congr 3\n      exact (inter_eq_left.2 (fun a ha â†¦ (mem_Ioi.1 ht).trans_le ha)).symm\n    have I : Ioi (0 : â„) = Ioc (0 : â„) M âˆª Ioi M := (Ioc_union_Ioi_eq_Ioi M_nonneg).symm\n    have J : Disjoint (Ioc 0 M) (Ioi M) := Ioc_disjoint_Ioi le_rfl\n    rw [I, lintegral_union measurableSet_Ioi J, lintegral_union measurableSet_Ioi J, B1, B2]\n  -- therefore, we may replace the integrals wrt `Î¼` with integrals wrt `Î½`, and apply the\n  -- result for sigma-finite measures.\n  rw [A, B]\n  exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable_of_sigmaFinite\n    Î½ f_nn f_mble g_intble g_mble g_nn\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_le_mul","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ Real\ng : Real â†’ Real\nÎ¼ : MeasureTheory.Measure Î±\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nf_mble : AEMeasurable f Î¼\ng_intble : âˆ€ (t : Real), GT.gt t 0 â†’ IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_nn : Filter.Eventually (fun t => LE.le 0 (g t)) (MeasureTheory.ae (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)))\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun Ï‰ => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f Ï‰) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (Î¼ (setOf fun a => LE.le t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- The layer cake formula / **Cavalieri's principle** / tail probability formula:\n\nLet `f` be a non-negative measurable function on a measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G âˆ˜ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `Î¼ {Ï‰ | f(Ï‰) â‰¥ t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `âˆ«â» (G âˆ˜ f) âˆ‚Î¼ = âˆ«â» t in 0..âˆ, g(t) * Î¼ {Ï‰ | f(Ï‰) â‰¥ t}`.\n\nSee `MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul` for a version with sets of the form\n`{Ï‰ | f(Ï‰) > t}` instead. -/\ntheorem lintegral_comp_eq_lintegral_meas_le_mul (Î¼ : Measure Î±) (f_nn : 0 â‰¤áµ[Î¼] f)\n    (f_mble : AEMeasurable f Î¼) (g_intble : âˆ€ t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : âˆ€áµ t âˆ‚volume.restrict (Ioi 0), 0 â‰¤ g t) :\n    âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ =\n      âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) := by\n  obtain âŸ¨G, G_mble, G_nn, g_eq_GâŸ© : âˆƒ G : â„ â†’ â„, Measurable G âˆ§ 0 â‰¤ G\n      âˆ§ g =áµ[volume.restrict (Ioi 0)] G := by\n    refine AEMeasurable.exists_measurable_nonneg ?_ g_nn\n    exact aemeasurable_Ioi_of_forall_Ioc fun t ht => (g_intble t ht).1.1.aemeasurable\n  have g_eq_G_on : âˆ€ t, g =áµ[volume.restrict (Ioc 0 t)] G := fun t =>\n    ae_mono (Measure.restrict_mono Ioc_subset_Ioi_self le_rfl) g_eq_G\n  have G_intble : âˆ€ t > 0, IntervalIntegrable G volume 0 t := by\n    refine fun t t_pos => âŸ¨(g_intble t t_pos).1.congr_fun_ae (g_eq_G_on t), ?_âŸ©\n    rw [Ioc_eq_empty_of_le t_pos.lt.le]\n    exact integrableOn_empty\n  obtain âŸ¨F, F_mble, F_nn, f_eq_FâŸ© : âˆƒ F : Î± â†’ â„, Measurable F âˆ§ 0 â‰¤ F âˆ§ f =áµ[Î¼] F := by\n    refine âŸ¨fun Ï‰ â†¦ max (f_mble.mk f Ï‰) 0, f_mble.measurable_mk.max measurable_const,\n        fun Ï‰ â†¦ le_max_right _ _, ?_âŸ©\n    filter_upwards [f_mble.ae_eq_mk, f_nn] with Ï‰ hÏ‰ h'Ï‰\n    rw [â† hÏ‰]\n    exact (max_eq_left h'Ï‰).symm\n  have eqâ‚ :\n    âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} * ENNReal.ofReal (g t) =\n      âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ F a} * ENNReal.ofReal (G t) := by\n    apply lintegral_congr_ae\n    filter_upwards [g_eq_G] with t ht\n    rw [ht]\n    congr 1\n    apply measure_congr\n    filter_upwards [f_eq_F] with a ha using by simp [setOf, ha]\n  have eqâ‚‚ : âˆ€áµ Ï‰ âˆ‚Î¼,\n      ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) = ENNReal.ofReal (âˆ« t in (0)..F Ï‰, G t) := by\n    filter_upwards [f_eq_F] with Ï‰ fÏ‰_nn\n    rw [fÏ‰_nn]\n    congr 1\n    refine intervalIntegral.integral_congr_ae ?_\n    have fÏ‰_nn : 0 â‰¤ F Ï‰ := F_nn Ï‰\n    rw [uIoc_of_le fÏ‰_nn, â†\n      ae_restrict_iff' (measurableSet_Ioc : MeasurableSet (Ioc (0 : â„) (F Ï‰)))]\n    exact g_eq_G_on (F Ï‰)\n  simp_rw [lintegral_congr_ae eqâ‚‚, eqâ‚]\n  exact lintegral_comp_eq_lintegral_meas_le_mul_of_measurable Î¼ F_nn F_mble\n          G_intble G_mble (fun t _ => G_nn t)\n\n"}
{"name":"MeasureTheory.lintegral_eq_lintegral_meas_le","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ Real\nÎ¼ : MeasureTheory.Measure Î±\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nf_mble : AEMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun Ï‰ => ENNReal.ofReal (f Ï‰)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => Î¼ (setOf fun a => LE.le t (f a)))","decl":"/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `âˆ«â» f âˆ‚Î¼ = âˆ«â» t in 0..âˆ, Î¼ {Ï‰ | f(Ï‰) â‰¥ t}`.\n\nSee `MeasureTheory.lintegral_eq_lintegral_meas_lt` for a version with sets of the form\n`{Ï‰ | f(Ï‰) > t}` instead. -/\ntheorem lintegral_eq_lintegral_meas_le (Î¼ : Measure Î±) (f_nn : 0 â‰¤áµ[Î¼] f)\n    (f_mble : AEMeasurable f Î¼) :\n    âˆ«â» Ï‰, ENNReal.ofReal (f Ï‰) âˆ‚Î¼ = âˆ«â» t in Ioi 0, Î¼ {a : Î± | t â‰¤ f a} := by\n  set cst := fun _ : â„ => (1 : â„)\n  have cst_intble : âˆ€ t > 0, IntervalIntegrable cst volume 0 t := fun _ _ =>\n    intervalIntegrable_const\n  have key :=\n    lintegral_comp_eq_lintegral_meas_le_mul Î¼ f_nn f_mble cst_intble\n      (Eventually.of_forall fun _ => zero_le_one)\n  simp_rw [cst, ENNReal.ofReal_one, mul_one] at key\n  rw [â† key]\n  congr with Ï‰\n  simp only [intervalIntegral.integral_const, sub_zero, Algebra.id.smul_eq_mul, mul_one]\n\n"}
{"name":"MeasureTheory.lintegral_comp_eq_lintegral_meas_lt_mul","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ Real\ng : Real â†’ Real\nÎ¼ : MeasureTheory.Measure Î±\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nf_mble : AEMeasurable f Î¼\ng_intble : âˆ€ (t : Real), GT.gt t 0 â†’ IntervalIntegrable g MeasureTheory.MeasureSpace.volume 0 t\ng_nn : Filter.Eventually (fun t => LE.le 0 (g t)) (MeasureTheory.ae (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)))\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun Ï‰ => ENNReal.ofReal (intervalIntegral (fun t => g t) 0 (f Ï‰) MeasureTheory.MeasureSpace.volume)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => HMul.hMul (Î¼ (setOf fun a => LT.lt t (f a))) (ENNReal.ofReal (g t)))","decl":"/-- The layer cake formula / Cavalieri's principle / tail probability formula:\n\nLet `f` be a non-negative measurable function on a measure space. Let `G` be an\nincreasing absolutely continuous function on the positive real line, vanishing at the origin,\nwith derivative `G' = g`. Then the integral of the composition `G âˆ˜ f` can be written as\nthe integral over the positive real line of the \"tail measures\" `Î¼ {Ï‰ | f(Ï‰) > t}` of `f`\nweighted by `g`.\n\nRoughly speaking, the statement is: `âˆ«â» (G âˆ˜ f) âˆ‚Î¼ = âˆ«â» t in 0..âˆ, g(t) * Î¼ {Ï‰ | f(Ï‰) > t}`.\n\nSee `lintegral_comp_eq_lintegral_meas_le_mul` for a version with sets of the form `{Ï‰ | f(Ï‰) â‰¥ t}`\ninstead. -/\ntheorem lintegral_comp_eq_lintegral_meas_lt_mul (Î¼ : Measure Î±) (f_nn : 0 â‰¤áµ[Î¼] f)\n    (f_mble : AEMeasurable f Î¼) (g_intble : âˆ€ t > 0, IntervalIntegrable g volume 0 t)\n    (g_nn : âˆ€áµ t âˆ‚volume.restrict (Ioi 0), 0 â‰¤ g t) :\n    âˆ«â» Ï‰, ENNReal.ofReal (âˆ« t in (0)..f Ï‰, g t) âˆ‚Î¼ =\n      âˆ«â» t in Ioi 0, Î¼ {a : Î± | t < f a} * ENNReal.ofReal (g t) := by\n  rw [lintegral_comp_eq_lintegral_meas_le_mul Î¼ f_nn f_mble g_intble g_nn]\n  apply lintegral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt Î¼ (volume.restrict (Ioi 0)) f]\n    with t ht\n  rw [ht]\n\n"}
{"name":"MeasureTheory.lintegral_eq_lintegral_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nf : Î± â†’ Real\nÎ¼ : MeasureTheory.Measure Î±\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nf_mble : AEMeasurable f Î¼\nâŠ¢ Eq (MeasureTheory.lintegral Î¼ fun Ï‰ => ENNReal.ofReal (f Ï‰)) (MeasureTheory.lintegral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => Î¼ (setOf fun a => LT.lt t (f a)))","decl":"/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor a nonnegative function `f` on a measure space, the Lebesgue integral of `f` can\nbe written (roughly speaking) as: `âˆ«â» f âˆ‚Î¼ = âˆ«â» t in 0..âˆ, Î¼ {Ï‰ | f(Ï‰) > t}`.\n\nSee `lintegral_eq_lintegral_meas_le` for a version with sets of the form `{Ï‰ | f(Ï‰) â‰¥ t}`\ninstead. -/\ntheorem lintegral_eq_lintegral_meas_lt (Î¼ : Measure Î±)\n    (f_nn : 0 â‰¤áµ[Î¼] f) (f_mble : AEMeasurable f Î¼) :\n    âˆ«â» Ï‰, ENNReal.ofReal (f Ï‰) âˆ‚Î¼ = âˆ«â» t in Ioi 0, Î¼ {a : Î± | t < f a} := by\n  rw [lintegral_eq_lintegral_meas_le Î¼ f_nn f_mble]\n  apply lintegral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt Î¼ (volume.restrict (Ioi 0)) f]\n    with t ht\n  rw [ht]\n\n"}
{"name":"MeasureTheory.Integrable.integral_eq_integral_meas_lt","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nf_intble : MeasureTheory.Integrable f Î¼\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun Ï‰ => f Ï‰) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => (Î¼ (setOf fun a => LT.lt t (f a))).toReal)","decl":"/-- The standard case of the layer cake formula / Cavalieri's principle / tail probability formula:\n\nFor an integrable a.e.-nonnegative real-valued function `f`, the Bochner integral of `f` can be\nwritten (roughly speaking) as: `âˆ« f âˆ‚Î¼ = âˆ« t in 0..âˆ, Î¼ {Ï‰ | f(Ï‰) > t}`.\n\nSee `MeasureTheory.lintegral_eq_lintegral_meas_lt` for a version with Lebesgue integral `âˆ«â»`\ninstead. -/\ntheorem Integrable.integral_eq_integral_meas_lt\n    (f_intble : Integrable f Î¼) (f_nn : 0 â‰¤áµ[Î¼] f) :\n    âˆ« Ï‰, f Ï‰ âˆ‚Î¼ = âˆ« t in Set.Ioi 0, ENNReal.toReal (Î¼ {a : Î± | t < f a}) := by\n  have key := lintegral_eq_lintegral_meas_lt Î¼ f_nn f_intble.aemeasurable\n  have lhs_finite : âˆ«â» (Ï‰ : Î±), ENNReal.ofReal (f Ï‰) âˆ‚Î¼ < âˆ := Integrable.lintegral_lt_top f_intble\n  have rhs_finite : âˆ«â» (t : â„) in Set.Ioi 0, Î¼ {a | t < f a} < âˆ := by simp only [â† key, lhs_finite]\n  have rhs_integrand_finite : âˆ€ (t : â„), t > 0 â†’ Î¼ {a | t < f a} < âˆ :=\n    fun t ht â†¦ measure_gt_lt_top f_intble ht\n  convert (ENNReal.toReal_eq_toReal lhs_finite.ne rhs_finite.ne).mpr key\n  Â· exact integral_eq_lintegral_of_nonneg_ae f_nn f_intble.aestronglyMeasurable\n  Â· have aux := @integral_eq_lintegral_of_nonneg_ae _ _ ((volume : Measure â„).restrict (Set.Ioi 0))\n      (fun t â†¦ ENNReal.toReal (Î¼ {a : Î± | t < f a})) ?_ ?_\n    Â· rw [aux]\n      congr 1\n      apply setLIntegral_congr_fun measurableSet_Ioi (Eventually.of_forall _)\n      exact fun t t_pos â†¦ ENNReal.ofReal_toReal (rhs_integrand_finite t t_pos).ne\n    Â· exact Eventually.of_forall (fun x â†¦ by simp only [Pi.zero_apply, ENNReal.toReal_nonneg])\n    Â· apply Measurable.aestronglyMeasurable\n      refine Measurable.ennreal_toReal ?_\n      exact Antitone.measurable (fun _ _ hst â†¦ measure_mono (fun _ h â†¦ lt_of_le_of_lt hst h))\n\n"}
{"name":"MeasureTheory.Integrable.integral_eq_integral_meas_le","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nf_intble : MeasureTheory.Integrable f Î¼\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun Ï‰ => f Ï‰) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioi 0)) fun t => (Î¼ (setOf fun a => LE.le t (f a))).toReal)","decl":"theorem Integrable.integral_eq_integral_meas_le\n    (f_intble : Integrable f Î¼) (f_nn : 0 â‰¤áµ[Î¼] f) :\n    âˆ« Ï‰, f Ï‰ âˆ‚Î¼ = âˆ« t in Set.Ioi 0, ENNReal.toReal (Î¼ {a : Î± | t â‰¤ f a}) := by\n  rw [Integrable.integral_eq_integral_meas_lt f_intble f_nn]\n  apply integral_congr_ae\n  filter_upwards [meas_le_ae_eq_meas_lt Î¼ (volume.restrict (Ioi 0)) f] with t ht\n  exact congrArg ENNReal.toReal ht.symm\n\n"}
{"name":"MeasureTheory.Integrable.integral_eq_integral_Ioc_meas_le","module":"Mathlib.MeasureTheory.Integral.Layercake","initialProofState":"Î± : Type u_1\ninstâœ : MeasurableSpace Î±\nÎ¼ : MeasureTheory.Measure Î±\nf : Î± â†’ Real\nM : Real\nf_intble : MeasureTheory.Integrable f Î¼\nf_nn : (MeasureTheory.ae Î¼).EventuallyLE 0 f\nf_bdd : (MeasureTheory.ae Î¼).EventuallyLE f fun x => M\nâŠ¢ Eq (MeasureTheory.integral Î¼ fun Ï‰ => f Ï‰) (MeasureTheory.integral (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 M)) fun t => (Î¼ (setOf fun a => LE.le t (f a))).toReal)","decl":"lemma Integrable.integral_eq_integral_Ioc_meas_le {f : Î± â†’ â„} {M : â„}\n    (f_intble : Integrable f Î¼) (f_nn : 0 â‰¤áµ[Î¼] f) (f_bdd : f â‰¤áµ[Î¼] (fun _ â†¦ M)) :\n    âˆ« Ï‰, f Ï‰ âˆ‚Î¼ = âˆ« t in Ioc 0 M, ENNReal.toReal (Î¼ {a : Î± | t â‰¤ f a}) := by\n  rw [f_intble.integral_eq_integral_meas_le f_nn]\n  rw [setIntegral_eq_of_subset_of_ae_diff_eq_zero\n      nullMeasurableSet_Ioi Ioc_subset_Ioi_self ?_]\n  apply Eventually.of_forall (fun t ht â†¦ ?_)\n  have htM : M < t := by simp_all only [mem_diff, mem_Ioi, mem_Ioc, not_and, not_le]\n  have obs : Î¼ {a | M < f a} = 0 := by\n    rw [measure_zero_iff_ae_nmem]\n    filter_upwards [f_bdd] with a ha using not_lt.mpr ha\n  rw [ENNReal.toReal_eq_zero_iff]\n  exact Or.inl <| measure_mono_null (fun a ha â†¦ lt_of_lt_of_le htM ha) obs\n\n"}
