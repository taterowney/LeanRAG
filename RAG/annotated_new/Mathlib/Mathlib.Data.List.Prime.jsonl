{"name":"Prime.dvd_prod_iff","module":"Mathlib.Data.List.Prime","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np : M\nL : List M\npp : Prime p\n⊢ Iff (Dvd.dvd p L.prod) (Exists fun a => And (Membership.mem L a) (Dvd.dvd p a))","decl":"/-- Prime `p` divides the product of a list `L` iff it divides some `a ∈ L` -/\ntheorem Prime.dvd_prod_iff {p : M} {L : List M} (pp : Prime p) : p ∣ L.prod ↔ ∃ a ∈ L, p ∣ a := by\n  constructor\n  · intro h\n    induction' L with L_hd L_tl L_ih\n    · rw [prod_nil] at h\n      exact absurd h pp.not_dvd_one\n    · rw [prod_cons] at h\n      cases' pp.dvd_or_dvd h with hd hd\n      · exact ⟨L_hd, mem_cons_self L_hd L_tl, hd⟩\n      · obtain ⟨x, hx1, hx2⟩ := L_ih hd\n        exact ⟨x, mem_cons_of_mem L_hd hx1, hx2⟩\n  · exact fun ⟨a, ha1, ha2⟩ => dvd_trans ha2 (dvd_prod ha1)\n\n"}
{"name":"Prime.not_dvd_prod","module":"Mathlib.Data.List.Prime","initialProofState":"M : Type u_1\ninst✝ : CommMonoidWithZero M\np : M\nL : List M\npp : Prime p\nhL : ∀ (a : M), Membership.mem L a → Not (Dvd.dvd p a)\n⊢ Not (Dvd.dvd p L.prod)","decl":"theorem Prime.not_dvd_prod {p : M} {L : List M} (pp : Prime p) (hL : ∀ a ∈ L, ¬p ∣ a) :\n    ¬p ∣ L.prod :=\n  mt (Prime.dvd_prod_iff pp).1 <| not_exists.2 fun a => not_and.2 (hL a)\n\n"}
{"name":"mem_list_primes_of_dvd_prod","module":"Mathlib.Data.List.Prime","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : Subsingleton (Units M)\np : M\nhp : Prime p\nL : List M\nhL : ∀ (q : M), Membership.mem L q → Prime q\nhpL : Dvd.dvd p L.prod\n⊢ Membership.mem L p","decl":"theorem mem_list_primes_of_dvd_prod {p : M} (hp : Prime p) {L : List M} (hL : ∀ q ∈ L, Prime q)\n    (hpL : p ∣ L.prod) : p ∈ L := by\n  obtain ⟨x, hx1, hx2⟩ := hp.dvd_prod_iff.mp hpL\n  rwa [(prime_dvd_prime_iff_eq hp (hL x hx1)).mp hx2]\n\n"}
{"name":"perm_of_prod_eq_prod","module":"Mathlib.Data.List.Prime","initialProofState":"M : Type u_1\ninst✝¹ : CancelCommMonoidWithZero M\ninst✝ : Subsingleton (Units M)\nl₁ l₂ : List M\na✝² : Eq l₁.prod l₂.prod\na✝¹ : ∀ (p : M), Membership.mem l₁ p → Prime p\na✝ : ∀ (p : M), Membership.mem l₂ p → Prime p\n⊢ l₁.Perm l₂","decl":"theorem perm_of_prod_eq_prod :\n    ∀ {l₁ l₂ : List M}, l₁.prod = l₂.prod → (∀ p ∈ l₁, Prime p) → (∀ p ∈ l₂, Prime p) → Perm l₁ l₂\n  | [], [], _, _, _ => Perm.nil\n  | [], a :: l, h₁, _, h₃ =>\n    have ha : a ∣ 1 := prod_nil (M := M) ▸ h₁.symm ▸ (prod_cons (l := l)).symm ▸ dvd_mul_right _ _\n    absurd ha (Prime.not_dvd_one (h₃ a (mem_cons_self _ _)))\n  | a :: l, [], h₁, h₂, _ =>\n    have ha : a ∣ 1 := prod_nil (M := M) ▸ h₁ ▸ (prod_cons (l := l)).symm ▸ dvd_mul_right _ _\n    absurd ha (Prime.not_dvd_one (h₂ a (mem_cons_self _ _)))\n  | a :: l₁, b :: l₂, h, hl₁, hl₂ => by\n    classical\n      have hl₁' : ∀ p ∈ l₁, Prime p := fun p hp => hl₁ p (mem_cons_of_mem _ hp)\n      have hl₂' : ∀ p ∈ (b :: l₂).erase a, Prime p := fun p hp => hl₂ p (mem_of_mem_erase hp)\n      have ha : a ∈ b :: l₂ :=\n        mem_list_primes_of_dvd_prod (hl₁ a (mem_cons_self _ _)) hl₂\n          (h ▸ by rw [prod_cons]; exact dvd_mul_right _ _)\n      have hb : b :: l₂ ~ a :: (b :: l₂).erase a := perm_cons_erase ha\n      have hl : prod l₁ = prod ((b :: l₂).erase a) :=\n        (mul_right_inj' (hl₁ a (mem_cons_self _ _)).ne_zero).1 <| by\n          rwa [← prod_cons, ← prod_cons, ← hb.prod_eq]\n      exact Perm.trans ((perm_of_prod_eq_prod hl hl₁' hl₂').cons _) hb.symm\n\n"}
