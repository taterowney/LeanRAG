{"name":"Submodule.FG.exists_rTensor_fg_inclusion_eq","module":"Mathlib.Algebra.Colimit.TensorProduct","initialProofState":"R : Type u_1\nM : Type u_2\nP : Type u_3\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid P\ninst✝ : Module R P\nN : Submodule R P\nhN : N.FG\nx y : TensorProduct R (Subtype fun x => Membership.mem N x) M\neq : Eq ((LinearMap.rTensor M N.subtype) x) ((LinearMap.rTensor M N.subtype) y)\n⊢ Exists fun N' => And N'.FG (Exists fun h => Eq ((LinearMap.rTensor M (Submodule.inclusion h)) x) ((LinearMap.rTensor M (Submodule.inclusion h)) y))","decl":"theorem Submodule.FG.exists_rTensor_fg_inclusion_eq {N : Submodule R P} (hN : N.FG)\n    {x y : N ⊗[R] M} (eq : N.subtype.rTensor M x = N.subtype.rTensor M y) :\n    ∃ N', N'.FG ∧ ∃ h : N ≤ N', (N.inclusion h).rTensor M x = (N.inclusion h).rTensor M y := by\n  classical\n  lift N to {N : Submodule R P // N.FG} using hN\n  apply_fun (Module.fgSystem.equiv R P).symm.toLinearMap.rTensor M at eq\n  apply_fun directLimitLeft _ _ at eq\n  simp_rw [← LinearMap.rTensor_comp_apply, ← (LinearEquiv.eq_toLinearMap_symm_comp _ _).mpr\n    (Module.fgSystem.equiv_comp_of N), directLimitLeft_rTensor_of] at eq\n  have ⟨N', le, eq⟩ := Module.DirectLimit.exists_eq_of_of_eq eq\n  exact ⟨_, N'.2, le, eq⟩\n"}
