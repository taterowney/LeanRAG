{"name":"CategoryTheory.IsSubterminal.def","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA : C\n⊢ Iff (CategoryTheory.IsSubterminal A) (∀ ⦃Z : C⦄ (f g : Quiver.Hom Z A), Eq f g)","decl":"theorem IsSubterminal.def : IsSubterminal A ↔ ∀ ⦃Z : C⦄ (f g : Z ⟶ A), f = g :=\n  Iff.rfl\n\n"}
{"name":"CategoryTheory.IsSubterminal.mono_isTerminal_from","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA : C\nhA : CategoryTheory.IsSubterminal A\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ CategoryTheory.Mono (hT.from A)","decl":"/-- If `A` is subterminal, the unique morphism from it to a terminal object is a monomorphism.\nThe converse of `isSubterminal_of_mono_isTerminal_from`.\n-/\ntheorem IsSubterminal.mono_isTerminal_from (hA : IsSubterminal A) {T : C} (hT : IsTerminal T) :\n    Mono (hT.from A) :=\n  { right_cancellation := fun _ _ _ => hA _ _ }\n\n"}
{"name":"CategoryTheory.IsSubterminal.mono_terminal_from","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nhA : CategoryTheory.IsSubterminal A\n⊢ CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)","decl":"/-- If `A` is subterminal, the unique morphism from it to the terminal object is a monomorphism.\nThe converse of `isSubterminal_of_mono_terminal_from`.\n-/\ntheorem IsSubterminal.mono_terminal_from [HasTerminal C] (hA : IsSubterminal A) :\n    Mono (terminal.from A) :=\n  hA.mono_isTerminal_from terminalIsTerminal\n\n"}
{"name":"CategoryTheory.isSubterminal_of_mono_isTerminal_from","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA T : C\nhT : CategoryTheory.Limits.IsTerminal T\ninst✝ : CategoryTheory.Mono (hT.from A)\n⊢ CategoryTheory.IsSubterminal A","decl":"/-- If the unique morphism from `A` to a terminal object is a monomorphism, `A` is subterminal.\nThe converse of `IsSubterminal.mono_isTerminal_from`.\n-/\ntheorem isSubterminal_of_mono_isTerminal_from {T : C} (hT : IsTerminal T) [Mono (hT.from A)] :\n    IsSubterminal A := fun Z f g => by\n  rw [← cancel_mono (hT.from A)]\n  apply hT.hom_ext\n\n"}
{"name":"CategoryTheory.isSubterminal_of_mono_terminal_from","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nA : C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Mono (CategoryTheory.Limits.terminal.from A)\n⊢ CategoryTheory.IsSubterminal A","decl":"/-- If the unique morphism from `A` to the terminal object is a monomorphism, `A` is subterminal.\nThe converse of `IsSubterminal.mono_terminal_from`.\n-/\ntheorem isSubterminal_of_mono_terminal_from [HasTerminal C] [Mono (terminal.from A)] :\n    IsSubterminal A := fun Z f g => by\n  rw [← cancel_mono (terminal.from A)]\n  subsingleton\n\n"}
{"name":"CategoryTheory.isSubterminal_of_isTerminal","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nT : C\nhT : CategoryTheory.Limits.IsTerminal T\n⊢ CategoryTheory.IsSubterminal T","decl":"theorem isSubterminal_of_isTerminal {T : C} (hT : IsTerminal T) : IsSubterminal T := fun _ _ _ =>\n  hT.hom_ext _ _\n\n"}
{"name":"CategoryTheory.isSubterminal_of_terminal","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ CategoryTheory.IsSubterminal (CategoryTheory.Limits.terminal C)","decl":"theorem isSubterminal_of_terminal [HasTerminal C] : IsSubterminal (⊤_ C) := fun _ _ _ => by\n  subsingleton\n\n"}
{"name":"CategoryTheory.IsSubterminal.isIso_diag","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : C\nhA : CategoryTheory.IsSubterminal A\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A A\n⊢ CategoryTheory.IsIso (CategoryTheory.Limits.diag A)","decl":"/-- If `A` is subterminal, its diagonal morphism is an isomorphism.\nThe converse of `isSubterminal_of_isIso_diag`.\n-/\ntheorem IsSubterminal.isIso_diag (hA : IsSubterminal A) [HasBinaryProduct A A] : IsIso (diag A) :=\n  ⟨⟨Limits.prod.fst,\n      ⟨by simp, by\n        rw [IsSubterminal.def] at hA\n        aesop_cat⟩⟩⟩\n\n"}
{"name":"CategoryTheory.isSubterminal_of_isIso_diag","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} C\nA : C\ninst✝¹ : CategoryTheory.Limits.HasBinaryProduct A A\ninst✝ : CategoryTheory.IsIso (CategoryTheory.Limits.diag A)\n⊢ CategoryTheory.IsSubterminal A","decl":"/-- If the diagonal morphism of `A` is an isomorphism, then it is subterminal.\nThe converse of `isSubterminal.isIso_diag`.\n-/\ntheorem isSubterminal_of_isIso_diag [HasBinaryProduct A A] [IsIso (diag A)] : IsSubterminal A :=\n  fun Z f g => by\n  have : (Limits.prod.fst : A ⨯ A ⟶ _) = Limits.prod.snd := by simp [← cancel_epi (diag A)]\n  rw [← prod.lift_fst f g, this, prod.lift_snd]\n\n"}
{"name":"CategoryTheory.IsSubterminal.isoDiag_hom","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : C\nhA : CategoryTheory.IsSubterminal A\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A A\n⊢ Eq hA.isoDiag.hom (CategoryTheory.inv (CategoryTheory.Limits.diag A))","decl":"/-- If `A` is subterminal, it is isomorphic to `A ⨯ A`. -/\n@[simps!]\ndef IsSubterminal.isoDiag (hA : IsSubterminal A) [HasBinaryProduct A A] : A ⨯ A ≅ A := by\n  letI := IsSubterminal.isIso_diag hA\n  apply (asIso (diag A)).symm\n\n"}
{"name":"CategoryTheory.IsSubterminal.isoDiag_inv","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\nA : C\nhA : CategoryTheory.IsSubterminal A\ninst✝ : CategoryTheory.Limits.HasBinaryProduct A A\n⊢ Eq hA.isoDiag.inv (CategoryTheory.Limits.diag A)","decl":"/-- If `A` is subterminal, it is isomorphic to `A ⨯ A`. -/\n@[simps!]\ndef IsSubterminal.isoDiag (hA : IsSubterminal A) [HasBinaryProduct A A] : A ⨯ A ≅ A := by\n  letI := IsSubterminal.isIso_diag hA\n  apply (asIso (diag A)).symm\n\n"}
{"name":"CategoryTheory.subterminalInclusion_obj","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : CategoryTheory.FullSubcategory fun A => CategoryTheory.IsSubterminal A\n⊢ Eq ((CategoryTheory.subterminalInclusion C).obj self) self.obj","decl":"/-- The inclusion of the subterminal objects into the original category. -/\n@[simps!]\ndef subterminalInclusion : Subterminals C ⥤ C :=\n  fullSubcategoryInclusion _\n\n"}
{"name":"CategoryTheory.subterminalInclusion_map","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.InducedCategory C CategoryTheory.FullSubcategory.obj\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.subterminalInclusion C).map f) f","decl":"/-- The inclusion of the subterminal objects into the original category. -/\n@[simps!]\ndef subterminalInclusion : Subterminals C ⥤ C :=\n  fullSubcategoryInclusion _\n\n"}
{"name":"CategoryTheory.instFullSubterminalsSubterminalInclusion","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.subterminalInclusion C).Full","decl":"instance (C : Type u₁) [Category.{v₁} C] : (subterminalInclusion C).Full :=\n  FullSubcategory.full _\n\n"}
{"name":"CategoryTheory.instFaithfulSubterminalsSubterminalInclusion","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ (CategoryTheory.subterminalInclusion C).Faithful","decl":"instance (C : Type u₁) [Category.{v₁} C] : (subterminalInclusion C).Faithful :=\n  FullSubcategory.faithful _\n\n"}
{"name":"CategoryTheory.subterminals_thin","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : CategoryTheory.Subterminals C\n⊢ Subsingleton (Quiver.Hom X Y)","decl":"instance subterminals_thin (X Y : Subterminals C) : Subsingleton (X ⟶ Y) :=\n  ⟨fun f g => Y.2 f g⟩\n\n"}
{"name":"CategoryTheory.subterminalsEquivMonoOverTerminal_functor_obj_obj","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nX : CategoryTheory.Subterminals C\n⊢ Eq ((CategoryTheory.subterminalsEquivMonoOverTerminal C).functor.obj X).obj (CategoryTheory.Over.mk (CategoryTheory.Limits.terminal.from X.obj))","decl":"/--\nThe category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n-/\n@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C ≌ MonoOver (⊤_ C) where\n  functor :=\n    { obj := fun X => ⟨Over.mk (terminal.from X.1), X.2.mono_terminal_from⟩\n      map := fun f => MonoOver.homMk f (by ext1 ⟨⟨⟩⟩)\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  inverse :=\n    { obj := fun X =>\n        ⟨X.obj.left, fun Z f g => by\n          rw [← cancel_mono X.arrow]\n          subsingleton⟩\n      map := fun f => f.1\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  -- Porting note: the original definition was triggering a timeout, using `NatIso.ofComponents`\n  -- in the definition of the natural isomorphisms makes the situation slightly better\n  unitIso := NatIso.ofComponents (fun X => Iso.refl X) (by subsingleton)\n  counitIso := NatIso.ofComponents (fun X => MonoOver.isoMk (Iso.refl _)) (by subsingleton)\n  functor_unitIso_comp := by subsingleton\n  -- With `aesop` filling the auto-params this was taking 20s or so\n\n"}
{"name":"CategoryTheory.subterminalsEquivMonoOverTerminal_counitIso","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ Eq (CategoryTheory.subterminalsEquivMonoOverTerminal C).counitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.MonoOver.isoMk (CategoryTheory.Iso.refl (({ obj := fun X => { obj := X.obj.left, property := ⋯ }, map := fun {X Y} f => f.left, map_id := ⋯, map_comp := ⋯ }.comp { obj := fun X => { obj := CategoryTheory.Over.mk (CategoryTheory.Limits.terminal.from X.obj), property := ⋯ }, map := fun {X Y} f => CategoryTheory.MonoOver.homMk f ⋯, map_id := ⋯, map_comp := ⋯ }).obj X).obj.left) ⋯) ⋯)","decl":"/--\nThe category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n-/\n@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C ≌ MonoOver (⊤_ C) where\n  functor :=\n    { obj := fun X => ⟨Over.mk (terminal.from X.1), X.2.mono_terminal_from⟩\n      map := fun f => MonoOver.homMk f (by ext1 ⟨⟨⟩⟩)\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  inverse :=\n    { obj := fun X =>\n        ⟨X.obj.left, fun Z f g => by\n          rw [← cancel_mono X.arrow]\n          subsingleton⟩\n      map := fun f => f.1\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  -- Porting note: the original definition was triggering a timeout, using `NatIso.ofComponents`\n  -- in the definition of the natural isomorphisms makes the situation slightly better\n  unitIso := NatIso.ofComponents (fun X => Iso.refl X) (by subsingleton)\n  counitIso := NatIso.ofComponents (fun X => MonoOver.isoMk (Iso.refl _)) (by subsingleton)\n  functor_unitIso_comp := by subsingleton\n  -- With `aesop` filling the auto-params this was taking 20s or so\n\n"}
{"name":"CategoryTheory.subterminalsEquivMonoOverTerminal_functor_map","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nX✝ Y✝ : CategoryTheory.Subterminals C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.subterminalsEquivMonoOverTerminal C).functor.map f) (CategoryTheory.MonoOver.homMk f ⋯)","decl":"/--\nThe category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n-/\n@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C ≌ MonoOver (⊤_ C) where\n  functor :=\n    { obj := fun X => ⟨Over.mk (terminal.from X.1), X.2.mono_terminal_from⟩\n      map := fun f => MonoOver.homMk f (by ext1 ⟨⟨⟩⟩)\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  inverse :=\n    { obj := fun X =>\n        ⟨X.obj.left, fun Z f g => by\n          rw [← cancel_mono X.arrow]\n          subsingleton⟩\n      map := fun f => f.1\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  -- Porting note: the original definition was triggering a timeout, using `NatIso.ofComponents`\n  -- in the definition of the natural isomorphisms makes the situation slightly better\n  unitIso := NatIso.ofComponents (fun X => Iso.refl X) (by subsingleton)\n  counitIso := NatIso.ofComponents (fun X => MonoOver.isoMk (Iso.refl _)) (by subsingleton)\n  functor_unitIso_comp := by subsingleton\n  -- With `aesop` filling the auto-params this was taking 20s or so\n\n"}
{"name":"CategoryTheory.subterminalsEquivMonoOverTerminal_inverse_map","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nX✝ Y✝ : CategoryTheory.MonoOver (CategoryTheory.Limits.terminal C)\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.subterminalsEquivMonoOverTerminal C).inverse.map f) f.left","decl":"/--\nThe category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n-/\n@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C ≌ MonoOver (⊤_ C) where\n  functor :=\n    { obj := fun X => ⟨Over.mk (terminal.from X.1), X.2.mono_terminal_from⟩\n      map := fun f => MonoOver.homMk f (by ext1 ⟨⟨⟩⟩)\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  inverse :=\n    { obj := fun X =>\n        ⟨X.obj.left, fun Z f g => by\n          rw [← cancel_mono X.arrow]\n          subsingleton⟩\n      map := fun f => f.1\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  -- Porting note: the original definition was triggering a timeout, using `NatIso.ofComponents`\n  -- in the definition of the natural isomorphisms makes the situation slightly better\n  unitIso := NatIso.ofComponents (fun X => Iso.refl X) (by subsingleton)\n  counitIso := NatIso.ofComponents (fun X => MonoOver.isoMk (Iso.refl _)) (by subsingleton)\n  functor_unitIso_comp := by subsingleton\n  -- With `aesop` filling the auto-params this was taking 20s or so\n\n"}
{"name":"CategoryTheory.subterminalsEquivMonoOverTerminal_inverse_obj_obj","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\nX : CategoryTheory.MonoOver (CategoryTheory.Limits.terminal C)\n⊢ Eq ((CategoryTheory.subterminalsEquivMonoOverTerminal C).inverse.obj X).obj X.obj.left","decl":"/--\nThe category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n-/\n@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C ≌ MonoOver (⊤_ C) where\n  functor :=\n    { obj := fun X => ⟨Over.mk (terminal.from X.1), X.2.mono_terminal_from⟩\n      map := fun f => MonoOver.homMk f (by ext1 ⟨⟨⟩⟩)\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  inverse :=\n    { obj := fun X =>\n        ⟨X.obj.left, fun Z f g => by\n          rw [← cancel_mono X.arrow]\n          subsingleton⟩\n      map := fun f => f.1\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  -- Porting note: the original definition was triggering a timeout, using `NatIso.ofComponents`\n  -- in the definition of the natural isomorphisms makes the situation slightly better\n  unitIso := NatIso.ofComponents (fun X => Iso.refl X) (by subsingleton)\n  counitIso := NatIso.ofComponents (fun X => MonoOver.isoMk (Iso.refl _)) (by subsingleton)\n  functor_unitIso_comp := by subsingleton\n  -- With `aesop` filling the auto-params this was taking 20s or so\n\n"}
{"name":"CategoryTheory.subterminalsEquivMonoOverTerminal_unitIso","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ Eq (CategoryTheory.subterminalsEquivMonoOverTerminal C).unitIso (CategoryTheory.NatIso.ofComponents (fun X => CategoryTheory.Iso.refl X) ⋯)","decl":"/--\nThe category of subterminal objects is equivalent to the category of monomorphisms to the terminal\nobject (which is in turn equivalent to the subobjects of the terminal object).\n-/\n@[simps]\ndef subterminalsEquivMonoOverTerminal [HasTerminal C] : Subterminals C ≌ MonoOver (⊤_ C) where\n  functor :=\n    { obj := fun X => ⟨Over.mk (terminal.from X.1), X.2.mono_terminal_from⟩\n      map := fun f => MonoOver.homMk f (by ext1 ⟨⟨⟩⟩)\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  inverse :=\n    { obj := fun X =>\n        ⟨X.obj.left, fun Z f g => by\n          rw [← cancel_mono X.arrow]\n          subsingleton⟩\n      map := fun f => f.1\n      map_id := fun _ => rfl\n      map_comp := fun _ _ => rfl }\n  -- Porting note: the original definition was triggering a timeout, using `NatIso.ofComponents`\n  -- in the definition of the natural isomorphisms makes the situation slightly better\n  unitIso := NatIso.ofComponents (fun X => Iso.refl X) (by subsingleton)\n  counitIso := NatIso.ofComponents (fun X => MonoOver.isoMk (Iso.refl _)) (by subsingleton)\n  functor_unitIso_comp := by subsingleton\n  -- With `aesop` filling the auto-params this was taking 20s or so\n\n"}
{"name":"CategoryTheory.subterminals_to_monoOver_terminal_comp_forget","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ Eq ((CategoryTheory.subterminalsEquivMonoOverTerminal C).functor.comp ((CategoryTheory.MonoOver.forget (CategoryTheory.Limits.terminal C)).comp (CategoryTheory.Over.forget (CategoryTheory.Limits.terminal C)))) (CategoryTheory.subterminalInclusion C)","decl":"@[simp]\ntheorem subterminals_to_monoOver_terminal_comp_forget [HasTerminal C] :\n    (subterminalsEquivMonoOverTerminal C).functor ⋙ MonoOver.forget _ ⋙ Over.forget _ =\n      subterminalInclusion C :=\n  rfl\n\n"}
{"name":"CategoryTheory.monoOver_terminal_to_subterminals_comp","module":"Mathlib.CategoryTheory.Subterminal","initialProofState":"C : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} C\ninst✝ : CategoryTheory.Limits.HasTerminal C\n⊢ Eq ((CategoryTheory.subterminalsEquivMonoOverTerminal C).inverse.comp (CategoryTheory.subterminalInclusion C)) ((CategoryTheory.MonoOver.forget (CategoryTheory.Limits.terminal C)).comp (CategoryTheory.Over.forget (CategoryTheory.Limits.terminal C)))","decl":"@[simp]\ntheorem monoOver_terminal_to_subterminals_comp [HasTerminal C] :\n    (subterminalsEquivMonoOverTerminal C).inverse ⋙ subterminalInclusion C =\n      MonoOver.forget _ ⋙ Over.forget _ :=\n  rfl\n\n"}
