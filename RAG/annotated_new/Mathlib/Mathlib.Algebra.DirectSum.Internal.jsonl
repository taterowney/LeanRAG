{"name":"SetLike.algebraMap_mem_graded","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nS : Type u_3\nR : Type u_4\ninst✝⁴ : Zero ι\ninst✝³ : CommSemiring S\ninst✝² : Semiring R\ninst✝¹ : Algebra S R\nA : ι → Submodule S R\ninst✝ : SetLike.GradedOne A\ns : S\n⊢ Membership.mem (A 0) ((algebraMap S R) s)","decl":"theorem SetLike.algebraMap_mem_graded [Zero ι] [CommSemiring S] [Semiring R] [Algebra S R]\n    (A : ι → Submodule S R) [SetLike.GradedOne A] (s : S) : algebraMap S R s ∈ A 0 := by\n  rw [Algebra.algebraMap_eq_smul_one]\n  exact (A 0).smul_mem s <| SetLike.one_mem_graded _\n\n"}
{"name":"SetLike.natCast_mem_graded","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁴ : Zero ι\ninst✝³ : AddMonoidWithOne R\ninst✝² : SetLike σ R\ninst✝¹ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝ : SetLike.GradedOne A\nn : Nat\n⊢ Membership.mem (A 0) ↑n","decl":"theorem SetLike.natCast_mem_graded [Zero ι] [AddMonoidWithOne R] [SetLike σ R]\n    [AddSubmonoidClass σ R] (A : ι → σ) [SetLike.GradedOne A] (n : ℕ) : (n : R) ∈ A 0 := by\n  induction n with\n  | zero =>\n    rw [Nat.cast_zero]\n    exact zero_mem (A 0)\n  | succ _ n_ih =>\n    rw [Nat.cast_succ]\n    exact add_mem n_ih (SetLike.one_mem_graded _)\n\n"}
{"name":"SetLike.intCast_mem_graded","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁴ : Zero ι\ninst✝³ : AddGroupWithOne R\ninst✝² : SetLike σ R\ninst✝¹ : AddSubgroupClass σ R\nA : ι → σ\ninst✝ : SetLike.GradedOne A\nz : Int\n⊢ Membership.mem (A 0) ↑z","decl":"theorem SetLike.intCast_mem_graded [Zero ι] [AddGroupWithOne R] [SetLike σ R]\n    [AddSubgroupClass σ R] (A : ι → σ) [SetLike.GradedOne A] (z : ℤ) : (z : R) ∈ A 0 := by\n  induction z\n  · rw [Int.ofNat_eq_coe, Int.cast_natCast]\n    exact SetLike.natCast_mem_graded _ _\n  · rw [Int.cast_negSucc]\n    exact neg_mem (SetLike.natCast_mem_graded _ _)\n\n"}
{"name":"DirectSum.coeRingHom_of","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring R\ninst✝³ : SetLike σ R\ninst✝² : AddSubmonoidClass σ R\nA : ι → σ\ninst✝¹ : AddMonoid ι\ninst✝ : SetLike.GradedMonoid A\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq ((DirectSum.coeRingHom A) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) x)) ↑x","decl":"/-- The canonical ring isomorphism between `⨁ i, A i` and `R`-/\n@[simp]\ntheorem coeRingHom_of [AddMonoid ι] [SetLike.GradedMonoid A] (i : ι) (x : A i) :\n    (coeRingHom A : _ →+* R) (of (fun i => A i) i x) = x :=\n  DirectSum.toSemiring_of _ _ _ _ _\n\n"}
{"name":"DirectSum.coe_mul_apply","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Semiring R\ninst✝⁴ : SetLike σ R\ninst✝³ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝² : AddMonoid ι\ninst✝¹ : SetLike.GradedMonoid A\ninst✝ : (i : ι) → (x : Subtype fun x => Membership.mem (A i) x) → Decidable (Ne x 0)\nr r' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nn : ι\n⊢ Eq (↑((HMul.hMul r r') n)) ((Finset.filter (fun ij => Eq (HAdd.hAdd ij.1 ij.2) n) (SProd.sprod (DFinsupp.support r) (DFinsupp.support r'))).sum fun ij => HMul.hMul ↑(r ij.1) ↑(r' ij.2))","decl":"theorem coe_mul_apply [AddMonoid ι] [SetLike.GradedMonoid A]\n    [∀ (i : ι) (x : A i), Decidable (x ≠ 0)] (r r' : ⨁ i, A i) (n : ι) :\n    ((r * r') n : R) =\n      ∑ ij ∈ (r.support ×ˢ r'.support).filter (fun ij : ι × ι => ij.1 + ij.2 = n),\n        (r ij.1 * r' ij.2 : R) := by\n  rw [mul_eq_sum_support_ghas_mul, DFinsupp.finset_sum_apply, AddSubmonoidClass.coe_finset_sum]\n  simp_rw [coe_of_apply, apply_ite, ZeroMemClass.coe_zero, ← Finset.sum_filter, SetLike.coe_gMul]\n\n"}
{"name":"DirectSum.coe_mul_apply_eq_dfinsupp_sum","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁶ : DecidableEq ι\ninst✝⁵ : Semiring R\ninst✝⁴ : SetLike σ R\ninst✝³ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝² : AddMonoid ι\ninst✝¹ : SetLike.GradedMonoid A\ninst✝ : (i : ι) → (x : Subtype fun x => Membership.mem (A i) x) → Decidable (Ne x 0)\nr r' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nn : ι\n⊢ Eq (↑((HMul.hMul r r') n)) (DFinsupp.sum r fun i ri => DFinsupp.sum r' fun j rj => ite (Eq (HAdd.hAdd i j) n) (HMul.hMul ↑ri ↑rj) 0)","decl":"theorem coe_mul_apply_eq_dfinsupp_sum [AddMonoid ι] [SetLike.GradedMonoid A]\n    [∀ (i : ι) (x : A i), Decidable (x ≠ 0)] (r r' : ⨁ i, A i) (n : ι) :\n    ((r * r') n : R) = r.sum fun i ri => r'.sum fun j rj => if i + j = n then (ri * rj : R)\n      else 0 := by\n  rw [mul_eq_dfinsupp_sum]\n  iterate 2 rw [DFinsupp.sum_apply, DFinsupp.sum, AddSubmonoidClass.coe_finset_sum]; congr; ext\n  dsimp only\n  split_ifs with h\n  · subst h\n    rw [of_eq_same]\n    rfl\n  · rw [of_eq_of_ne _ _ _ h]\n    rfl\n\n"}
{"name":"DirectSum.coe_of_mul_apply_aux","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring R\ninst✝³ : SetLike σ R\ninst✝² : AddSubmonoidClass σ R\nA : ι → σ\ninst✝¹ : AddMonoid ι\ninst✝ : SetLike.GradedMonoid A\ni : ι\nr : Subtype fun x => Membership.mem (A i) x\nr' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nj n : ι\nH : ∀ (x : ι), Iff (Eq (HAdd.hAdd i x) n) (Eq x j)\n⊢ Eq (↑((HMul.hMul ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r) r') n)) (HMul.hMul ↑r ↑(r' j))","decl":"theorem coe_of_mul_apply_aux [AddMonoid ι] [SetLike.GradedMonoid A] {i : ι} (r : A i)\n    (r' : ⨁ i, A i) {j n : ι} (H : ∀ x : ι, i + x = n ↔ x = j) :\n    ((of (fun i => A i) i r * r') n : R) = r * r' j := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum]\n    apply (DFinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, zero_mul, ite_self]\n      exact DFinsupp.sum_zero\n    simp_rw [DFinsupp.sum, H, Finset.sum_ite_eq']\n    split_ifs with h\n    · rfl\n    rw [DFinsupp.not_mem_support_iff.mp h, ZeroMemClass.coe_zero, mul_zero]\n\n"}
{"name":"DirectSum.coe_mul_of_apply_aux","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring R\ninst✝³ : SetLike σ R\ninst✝² : AddSubmonoidClass σ R\nA : ι → σ\ninst✝¹ : AddMonoid ι\ninst✝ : SetLike.GradedMonoid A\nr : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\ni : ι\nr' : Subtype fun x => Membership.mem (A i) x\nj n : ι\nH : ∀ (x : ι), Iff (Eq (HAdd.hAdd x i) n) (Eq x j)\n⊢ Eq (↑((HMul.hMul r ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r')) n)) (HMul.hMul ↑(r j) ↑r')","decl":"theorem coe_mul_of_apply_aux [AddMonoid ι] [SetLike.GradedMonoid A] (r : ⨁ i, A i) {i : ι}\n    (r' : A i) {j n : ι} (H : ∀ x : ι, x + i = n ↔ x = j) :\n    ((r * of (fun i => A i) i r') n : R) = r j * r' := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum, DFinsupp.sum_comm]\n    apply (DFinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, mul_zero, ite_self]\n      exact DFinsupp.sum_zero\n    simp_rw [DFinsupp.sum, H, Finset.sum_ite_eq']\n    split_ifs with h\n    · rfl\n    rw [DFinsupp.not_mem_support_iff.mp h, ZeroMemClass.coe_zero, zero_mul]\n\n"}
{"name":"DirectSum.coe_of_mul_apply_add","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring R\ninst✝³ : SetLike σ R\ninst✝² : AddSubmonoidClass σ R\nA : ι → σ\ninst✝¹ : AddLeftCancelMonoid ι\ninst✝ : SetLike.GradedMonoid A\ni : ι\nr : Subtype fun x => Membership.mem (A i) x\nr' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nj : ι\n⊢ Eq (↑((HMul.hMul ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r) r') (HAdd.hAdd i j))) (HMul.hMul ↑r ↑(r' j))","decl":"theorem coe_of_mul_apply_add [AddLeftCancelMonoid ι] [SetLike.GradedMonoid A] {i : ι} (r : A i)\n    (r' : ⨁ i, A i) (j : ι) : ((of (fun i => A i) i r * r') (i + j) : R) = r * r' j :=\n  coe_of_mul_apply_aux _ _ _ fun _x => ⟨fun h => add_left_cancel h, fun h => h ▸ rfl⟩\n\n"}
{"name":"DirectSum.coe_mul_of_apply_add","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : Semiring R\ninst✝³ : SetLike σ R\ninst✝² : AddSubmonoidClass σ R\nA : ι → σ\ninst✝¹ : AddRightCancelMonoid ι\ninst✝ : SetLike.GradedMonoid A\nr : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\ni : ι\nr' : Subtype fun x => Membership.mem (A i) x\nj : ι\n⊢ Eq (↑((HMul.hMul r ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r')) (HAdd.hAdd j i))) (HMul.hMul ↑(r j) ↑r')","decl":"theorem coe_mul_of_apply_add [AddRightCancelMonoid ι] [SetLike.GradedMonoid A] (r : ⨁ i, A i)\n    {i : ι} (r' : A i) (j : ι) : ((r * of (fun i => A i) i r') (j + i) : R) = r j * r' :=\n  coe_mul_of_apply_aux _ _ _ fun _x => ⟨fun h => add_right_cancel h, fun h => h ▸ rfl⟩\n\n"}
{"name":"DirectSum.coe_of_mul_apply_of_not_le","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Semiring R\ninst✝⁵ : SetLike σ R\ninst✝⁴ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝³ : AddCommMonoid ι\ninst✝² : PartialOrder ι\ninst✝¹ : CanonicallyOrderedAdd ι\ninst✝ : SetLike.GradedMonoid A\ni : ι\nr : Subtype fun x => Membership.mem (A i) x\nr' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nn : ι\nh : Not (LE.le i n)\n⊢ Eq (↑((HMul.hMul ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r) r') n)) 0","decl":"theorem coe_of_mul_apply_of_not_le {i : ι} (r : A i) (r' : ⨁ i, A i) (n : ι) (h : ¬i ≤ n) :\n    ((of (fun i => A i) i r * r') n : R) = 0 := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum]\n    apply (DFinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, zero_mul, ite_self]\n      exact DFinsupp.sum_zero\n    · rw [DFinsupp.sum, Finset.sum_ite_of_false, Finset.sum_const_zero]\n      exact fun x _ H => h ((self_le_add_right i x).trans_eq H)\n\n"}
{"name":"DirectSum.coe_mul_of_apply_of_not_le","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁷ : DecidableEq ι\ninst✝⁶ : Semiring R\ninst✝⁵ : SetLike σ R\ninst✝⁴ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝³ : AddCommMonoid ι\ninst✝² : PartialOrder ι\ninst✝¹ : CanonicallyOrderedAdd ι\ninst✝ : SetLike.GradedMonoid A\nr : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\ni : ι\nr' : Subtype fun x => Membership.mem (A i) x\nn : ι\nh : Not (LE.le i n)\n⊢ Eq (↑((HMul.hMul r ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r')) n)) 0","decl":"theorem coe_mul_of_apply_of_not_le (r : ⨁ i, A i) {i : ι} (r' : A i) (n : ι) (h : ¬i ≤ n) :\n    ((r * of (fun i => A i) i r') n : R) = 0 := by\n  classical\n    rw [coe_mul_apply_eq_dfinsupp_sum, DFinsupp.sum_comm]\n    apply (DFinsupp.sum_single_index _).trans\n    swap\n    · simp_rw [ZeroMemClass.coe_zero, mul_zero, ite_self]\n      exact DFinsupp.sum_zero\n    · rw [DFinsupp.sum, Finset.sum_ite_of_false, Finset.sum_const_zero]\n      exact fun x _ H => h ((self_le_add_left i x).trans_eq H)\n\n"}
{"name":"DirectSum.coe_mul_of_apply_of_le","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : Semiring R\ninst✝⁸ : SetLike σ R\ninst✝⁷ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝⁶ : AddCommMonoid ι\ninst✝⁵ : PartialOrder ι\ninst✝⁴ : CanonicallyOrderedAdd ι\ninst✝³ : SetLike.GradedMonoid A\ninst✝² : Sub ι\ninst✝¹ : OrderedSub ι\ninst✝ : AddLeftReflectLE ι\nr : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\ni : ι\nr' : Subtype fun x => Membership.mem (A i) x\nn : ι\nh : LE.le i n\n⊢ Eq (↑((HMul.hMul r ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r')) n)) (HMul.hMul ↑(r (HSub.hSub n i)) ↑r')","decl":"theorem coe_mul_of_apply_of_le (r : ⨁ i, A i) {i : ι} (r' : A i) (n : ι) (h : i ≤ n) :\n    ((r * of (fun i => A i) i r') n : R) = r (n - i) * r' :=\n  coe_mul_of_apply_aux _ _ _ fun _x => (eq_tsub_iff_add_eq_of_le h).symm\n\n"}
{"name":"DirectSum.coe_of_mul_apply_of_le","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝¹⁰ : DecidableEq ι\ninst✝⁹ : Semiring R\ninst✝⁸ : SetLike σ R\ninst✝⁷ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝⁶ : AddCommMonoid ι\ninst✝⁵ : PartialOrder ι\ninst✝⁴ : CanonicallyOrderedAdd ι\ninst✝³ : SetLike.GradedMonoid A\ninst✝² : Sub ι\ninst✝¹ : OrderedSub ι\ninst✝ : AddLeftReflectLE ι\ni : ι\nr : Subtype fun x => Membership.mem (A i) x\nr' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nn : ι\nh : LE.le i n\n⊢ Eq (↑((HMul.hMul ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r) r') n)) (HMul.hMul ↑r ↑(r' (HSub.hSub n i)))","decl":"theorem coe_of_mul_apply_of_le {i : ι} (r : A i) (r' : ⨁ i, A i) (n : ι) (h : i ≤ n) :\n    ((of (fun i => A i) i r * r') n : R) = r * r' (n - i) :=\n  coe_of_mul_apply_aux _ _ _ fun x => by rw [eq_tsub_iff_add_eq_of_le h, add_comm]\n\n"}
{"name":"DirectSum.coe_mul_of_apply","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝¹¹ : DecidableEq ι\ninst✝¹⁰ : Semiring R\ninst✝⁹ : SetLike σ R\ninst✝⁸ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝⁷ : AddCommMonoid ι\ninst✝⁶ : PartialOrder ι\ninst✝⁵ : CanonicallyOrderedAdd ι\ninst✝⁴ : SetLike.GradedMonoid A\ninst✝³ : Sub ι\ninst✝² : OrderedSub ι\ninst✝¹ : AddLeftReflectLE ι\nr : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\ni : ι\nr' : Subtype fun x => Membership.mem (A i) x\nn : ι\ninst✝ : Decidable (LE.le i n)\n⊢ Eq (↑((HMul.hMul r ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r')) n)) (ite (LE.le i n) (HMul.hMul ↑(r (HSub.hSub n i)) ↑r') 0)","decl":"theorem coe_mul_of_apply (r : ⨁ i, A i) {i : ι} (r' : A i) (n : ι) [Decidable (i ≤ n)] :\n    ((r * of (fun i => A i) i r') n : R) = if i ≤ n then (r (n - i) : R) * r' else 0 := by\n  split_ifs with h\n  exacts [coe_mul_of_apply_of_le _ _ _ n h, coe_mul_of_apply_of_not_le _ _ _ n h]\n\n"}
{"name":"DirectSum.coe_of_mul_apply","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝¹¹ : DecidableEq ι\ninst✝¹⁰ : Semiring R\ninst✝⁹ : SetLike σ R\ninst✝⁸ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝⁷ : AddCommMonoid ι\ninst✝⁶ : PartialOrder ι\ninst✝⁵ : CanonicallyOrderedAdd ι\ninst✝⁴ : SetLike.GradedMonoid A\ninst✝³ : Sub ι\ninst✝² : OrderedSub ι\ninst✝¹ : AddLeftReflectLE ι\ni : ι\nr : Subtype fun x => Membership.mem (A i) x\nr' : DirectSum ι fun i => Subtype fun x => Membership.mem (A i) x\nn : ι\ninst✝ : Decidable (LE.le i n)\n⊢ Eq (↑((HMul.hMul ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) r) r') n)) (ite (LE.le i n) (HMul.hMul ↑r ↑(r' (HSub.hSub n i))) 0)","decl":"theorem coe_of_mul_apply {i : ι} (r : A i) (r' : ⨁ i, A i) (n : ι) [Decidable (i ≤ n)] :\n    ((of (fun i => A i) i r * r') n : R) = if i ≤ n then (r * r' (n - i) : R) else 0 := by\n  split_ifs with h\n  exacts [coe_of_mul_apply_of_le _ _ _ n h, coe_of_mul_apply_of_not_le _ _ _ n h]\n\n"}
{"name":"Submodule.setLike.coe_galgebra_toFun","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"S : Type u_3\nR : Type u_4\nι : Type u_5\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring S\ninst✝² : Semiring R\ninst✝¹ : Algebra S R\nA : ι → Submodule S R\ninst✝ : SetLike.GradedMonoid A\ns : S\n⊢ Eq (↑(DirectSum.GAlgebra.toFun s)) ((algebraMap S R) s)","decl":"@[simp]\ntheorem setLike.coe_galgebra_toFun {ι} [AddMonoid ι] [CommSemiring S] [Semiring R] [Algebra S R]\n    (A : ι → Submodule S R) [SetLike.GradedMonoid A] (s : S) :\n    (DirectSum.GAlgebra.toFun (A := fun i => A i) s) = (algebraMap S R s : R) :=\n  rfl\n\n"}
{"name":"Submodule.nat_power_gradedMonoid","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"S : Type u_3\nR : Type u_4\ninst✝² : CommSemiring S\ninst✝¹ : Semiring R\ninst✝ : Algebra S R\np : Submodule S R\n⊢ SetLike.GradedMonoid fun i => HPow.hPow p i","decl":"/-- A direct sum of powers of a submodule of an algebra has a multiplicative structure. -/\ninstance nat_power_gradedMonoid [CommSemiring S] [Semiring R] [Algebra S R] (p : Submodule S R) :\n    SetLike.GradedMonoid fun i : ℕ => p ^ i where\n  one_mem := by\n    rw [← one_le, pow_zero]\n  mul_mem i j p q hp hq := by\n    rw [pow_add]\n    exact Submodule.mul_mem_mul hp hq\n\n"}
{"name":"Submodule.iSup_eq_toSubmodule_range","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nS : Type u_3\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring S\ninst✝² : Semiring R\ninst✝¹ : Algebra S R\nA : ι → Submodule S R\ninst✝ : SetLike.GradedMonoid A\n⊢ Eq (iSup fun i => A i) (Subalgebra.toSubmodule (DirectSum.coeAlgHom A).range)","decl":"/-- The supremum of submodules that form a graded monoid is a subalgebra, and equal to the range of\n`DirectSum.coeAlgHom`. -/\ntheorem Submodule.iSup_eq_toSubmodule_range [AddMonoid ι] [CommSemiring S] [Semiring R]\n    [Algebra S R] (A : ι → Submodule S R) [SetLike.GradedMonoid A] :\n    ⨆ i, A i = Subalgebra.toSubmodule (DirectSum.coeAlgHom A).range :=\n  (Submodule.iSup_eq_range_dfinsupp_lsum A).trans <| SetLike.coe_injective rfl\n\n"}
{"name":"DirectSum.coeAlgHom_of","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nS : Type u_3\nR : Type u_4\ninst✝⁵ : DecidableEq ι\ninst✝⁴ : AddMonoid ι\ninst✝³ : CommSemiring S\ninst✝² : Semiring R\ninst✝¹ : Algebra S R\nA : ι → Submodule S R\ninst✝ : SetLike.GradedMonoid A\ni : ι\nx : Subtype fun x => Membership.mem (A i) x\n⊢ Eq ((DirectSum.coeAlgHom A) ((DirectSum.of (fun i => Subtype fun x => Membership.mem (A i) x) i) x)) ↑x","decl":"@[simp]\ntheorem DirectSum.coeAlgHom_of [AddMonoid ι] [CommSemiring S] [Semiring R] [Algebra S R]\n    (A : ι → Submodule S R) [SetLike.GradedMonoid A] (i : ι) (x : A i) :\n    DirectSum.coeAlgHom A (DirectSum.of (fun i => A i) i x) = x :=\n  DirectSum.toSemiring_of _ (by rfl) (fun _ _ => (by rfl)) _ _\n\n"}
{"name":"SetLike.GradeZero.coe_natCast","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁴ : Semiring R\ninst✝³ : AddMonoid ι\ninst✝² : SetLike σ R\ninst✝¹ : AddSubmonoidClass σ R\nA : ι → σ\ninst✝ : SetLike.GradedMonoid A\nn : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast] theorem coe_natCast (n : ℕ) : (n : A 0) = (n : R) := rfl\n\n"}
{"name":"SetLike.GradeZero.coe_ofNat","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁵ : Semiring R\ninst✝⁴ : AddMonoid ι\ninst✝³ : SetLike σ R\ninst✝² : AddSubmonoidClass σ R\nA : ι → σ\ninst✝¹ : SetLike.GradedMonoid A\nn : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast] theorem coe_ofNat (n : ℕ) [n.AtLeastTwo] :\n    (ofNat(n) : A 0) = (ofNat(n) : R) := rfl\n\n"}
{"name":"SetLike.GradeZero.coe_intCast","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nσ : Type u_2\nR : Type u_4\ninst✝⁴ : Ring R\ninst✝³ : AddMonoid ι\ninst✝² : SetLike σ R\ninst✝¹ : AddSubgroupClass σ R\nA : ι → σ\ninst✝ : SetLike.GradedMonoid A\nz : Int\n⊢ Eq ↑↑z ↑z","decl":"theorem coe_intCast (z : ℤ) : (z : A 0) = (z : R) := rfl\n\n"}
{"name":"SetLike.GradeZero.coe_algebraMap","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nS : Type u_3\nR : Type u_4\ninst✝⁴ : CommSemiring S\ninst✝³ : Semiring R\ninst✝² : Algebra S R\ninst✝¹ : AddMonoid ι\nA : ι → Submodule S R\ninst✝ : SetLike.GradedMonoid A\ns : S\n⊢ Eq (↑((algebraMap S (Subtype fun x => Membership.mem (A 0) x)) s)) ((algebraMap S R) s)","decl":"@[simp, norm_cast] theorem coe_algebraMap (s : S) :\n    ↑(algebraMap _ (A 0) s) = algebraMap _ R s := rfl\n\n"}
{"name":"SetLike.homogeneous_zero_submodule","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nS : Type u_3\nR : Type u_4\ninst✝³ : Zero ι\ninst✝² : Semiring S\ninst✝¹ : AddCommMonoid R\ninst✝ : Module S R\nA : ι → Submodule S R\n⊢ SetLike.Homogeneous A 0","decl":"theorem SetLike.homogeneous_zero_submodule [Zero ι] [Semiring S] [AddCommMonoid R] [Module S R]\n    (A : ι → Submodule S R) : SetLike.Homogeneous A (0 : R) :=\n  ⟨0, Submodule.zero_mem _⟩\n\n"}
{"name":"SetLike.Homogeneous.smul","module":"Mathlib.Algebra.DirectSum.Internal","initialProofState":"ι : Type u_1\nS : Type u_3\nR : Type u_4\ninst✝² : CommSemiring S\ninst✝¹ : Semiring R\ninst✝ : Algebra S R\nA : ι → Submodule S R\ns : S\nr : R\nhr : SetLike.Homogeneous A r\n⊢ SetLike.Homogeneous A (HSMul.hSMul s r)","decl":"theorem SetLike.Homogeneous.smul [CommSemiring S] [Semiring R] [Algebra S R] {A : ι → Submodule S R}\n    {s : S} {r : R} (hr : SetLike.Homogeneous A r) : SetLike.Homogeneous A (s • r) :=\n  let ⟨i, hi⟩ := hr\n  ⟨i, Submodule.smul_mem _ _ hi⟩\n\n"}
