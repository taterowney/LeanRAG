{"name":"Polynomial.coeff_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\ni : Nat\n⊢ Eq ((p.scaleRoots s).coeff i) (HMul.hMul (p.coeff i) (HPow.hPow s (HSub.hSub p.natDegree i)))","decl":"@[simp]\ntheorem coeff_scaleRoots (p : R[X]) (s : R) (i : ℕ) :\n    (scaleRoots p s).coeff i = coeff p i * s ^ (p.natDegree - i) := by\n  simp +contextual [scaleRoots, coeff_monomial]\n\n"}
{"name":"Polynomial.coeff_scaleRoots_natDegree","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\n⊢ Eq ((p.scaleRoots s).coeff p.natDegree) p.leadingCoeff","decl":"theorem coeff_scaleRoots_natDegree (p : R[X]) (s : R) :\n    (scaleRoots p s).coeff p.natDegree = p.leadingCoeff := by\n  rw [leadingCoeff, coeff_scaleRoots, tsub_self, pow_zero, mul_one]\n\n"}
{"name":"Polynomial.zero_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\ns : R\n⊢ Eq (Polynomial.scaleRoots 0 s) 0","decl":"@[simp]\ntheorem zero_scaleRoots (s : R) : scaleRoots 0 s = 0 := by\n  ext\n  simp\n\n"}
{"name":"Polynomial.scaleRoots_ne_zero","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\nhp : Ne p 0\ns : R\n⊢ Ne (p.scaleRoots s) 0","decl":"theorem scaleRoots_ne_zero {p : R[X]} (hp : p ≠ 0) (s : R) : scaleRoots p s ≠ 0 := by\n  intro h\n  have : p.coeff p.natDegree ≠ 0 := mt leadingCoeff_eq_zero.mp hp\n  have : (scaleRoots p s).coeff p.natDegree = 0 :=\n    congr_fun (congr_arg (coeff : R[X] → ℕ → R) h) p.natDegree\n  rw [coeff_scaleRoots_natDegree] at this\n  contradiction\n\n"}
{"name":"Polynomial.support_scaleRoots_le","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\n⊢ LE.le (p.scaleRoots s).support p.support","decl":"theorem support_scaleRoots_le (p : R[X]) (s : R) : (scaleRoots p s).support ≤ p.support := by\n  intro\n  simpa using left_ne_zero_of_mul\n\n"}
{"name":"Polynomial.support_scaleRoots_eq","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\nhs : Membership.mem (nonZeroDivisors R) s\n⊢ Eq (p.scaleRoots s).support p.support","decl":"theorem support_scaleRoots_eq (p : R[X]) {s : R} (hs : s ∈ nonZeroDivisors R) :\n    (scaleRoots p s).support = p.support :=\n  le_antisymm (support_scaleRoots_le p s)\n    (by intro i\n        simp only [coeff_scaleRoots, Polynomial.mem_support_iff]\n        intro p_ne_zero ps_zero\n        have := pow_mem hs (p.natDegree - i) _ ps_zero\n        contradiction)\n\n"}
{"name":"Polynomial.degree_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\n⊢ Eq (p.scaleRoots s).degree p.degree","decl":"@[simp]\ntheorem degree_scaleRoots (p : R[X]) {s : R} : degree (scaleRoots p s) = degree p := by\n  haveI := Classical.propDecidable\n  by_cases hp : p = 0\n  · rw [hp, zero_scaleRoots]\n  refine le_antisymm (Finset.sup_mono (support_scaleRoots_le p s)) (degree_le_degree ?_)\n  rw [coeff_scaleRoots_natDegree]\n  intro h\n  have := leadingCoeff_eq_zero.mp h\n  contradiction\n\n"}
{"name":"Polynomial.natDegree_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\n⊢ Eq (p.scaleRoots s).natDegree p.natDegree","decl":"@[simp]\ntheorem natDegree_scaleRoots (p : R[X]) (s : R) : natDegree (scaleRoots p s) = natDegree p := by\n  simp only [natDegree, degree_scaleRoots]\n\n"}
{"name":"Polynomial.monic_scaleRoots_iff","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\ns : R\n⊢ Iff (p.scaleRoots s).Monic p.Monic","decl":"theorem monic_scaleRoots_iff {p : R[X]} (s : R) : Monic (scaleRoots p s) ↔ Monic p := by\n  simp only [Monic, leadingCoeff, natDegree_scaleRoots, coeff_scaleRoots_natDegree]\n\n"}
{"name":"Polynomial.map_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring R\ninst✝ : Semiring S\np : Polynomial R\nx : R\nf : RingHom R S\nh : Ne (f p.leadingCoeff) 0\n⊢ Eq (Polynomial.map f (p.scaleRoots x)) ((Polynomial.map f p).scaleRoots (f x))","decl":"theorem map_scaleRoots (p : R[X]) (x : R) (f : R →+* S) (h : f p.leadingCoeff ≠ 0) :\n    (p.scaleRoots x).map f = (p.map f).scaleRoots (f x) := by\n  ext\n  simp [Polynomial.natDegree_map_of_leadingCoeff_ne_zero _ h]\n\n"}
{"name":"Polynomial.scaleRoots_C","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr c : R\n⊢ Eq ((Polynomial.C c).scaleRoots r) (Polynomial.C c)","decl":"@[simp]\nlemma scaleRoots_C (r c : R) : (C c).scaleRoots r = C c := by\n  ext; simp\n\n"}
{"name":"Polynomial.scaleRoots_one","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.scaleRoots 1) p","decl":"@[simp]\nlemma scaleRoots_one (p : R[X]) :\n    p.scaleRoots 1 = p := by ext; simp\n\n"}
{"name":"Polynomial.scaleRoots_zero","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\np : Polynomial R\n⊢ Eq (p.scaleRoots 0) (HSMul.hSMul p.leadingCoeff (HPow.hPow Polynomial.X p.natDegree))","decl":"@[simp]\nlemma scaleRoots_zero (p : R[X]) :\n    p.scaleRoots 0 = p.leadingCoeff • X ^ p.natDegree := by\n  ext n\n  simp only [coeff_scaleRoots, ne_eq, tsub_eq_zero_iff_le, not_le, zero_pow_eq, mul_ite,\n    mul_one, mul_zero, coeff_smul, coeff_X_pow, smul_eq_mul]\n  split_ifs with h₁ h₂ h₂\n  · subst h₂; rfl\n  · exact coeff_eq_zero_of_natDegree_lt (lt_of_le_of_ne h₁ (Ne.symm h₂))\n  · exact (h₁ h₂.ge).elim\n  · rfl\n\n"}
{"name":"Polynomial.one_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : Semiring R\nr : R\n⊢ Eq (Polynomial.scaleRoots 1 r) 1","decl":"@[simp]\nlemma one_scaleRoots (r : R) :\n    (1 : R[X]).scaleRoots r = 1 := by ext; simp\n\n"}
{"name":"Polynomial.scaleRoots_eval₂_mul_of_commute","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"S : Type u_2\nA : Type u_3\ninst✝¹ : Semiring S\ninst✝ : Semiring A\np : Polynomial S\nf : RingHom S A\na : A\ns : S\nhsa : Commute (f s) a\nhf : ∀ (s₁ s₂ : S), Commute (f s₁) (f s₂)\n⊢ Eq (Polynomial.eval₂ f (HMul.hMul (f s) a) (p.scaleRoots s)) (HMul.hMul (HPow.hPow (f s) p.natDegree) (Polynomial.eval₂ f a p))","decl":"theorem scaleRoots_eval₂_mul_of_commute {p : S[X]} (f : S →+* A) (a : A) (s : S)\n    (hsa : Commute (f s) a) (hf : ∀ s₁ s₂, Commute (f s₁) (f s₂)) :\n    eval₂ f (f s * a) (scaleRoots p s) = f s ^ p.natDegree * eval₂ f a p := by\n   calc\n    _ = (scaleRoots p s).support.sum fun i =>\n          f (coeff p i * s ^ (p.natDegree - i)) * (f s * a) ^ i := by\n      simp [eval₂_eq_sum, sum_def]\n    _ = p.support.sum fun i => f (coeff p i * s ^ (p.natDegree - i)) * (f s * a) ^ i :=\n      (Finset.sum_subset (support_scaleRoots_le p s) fun i _hi hi' => by\n        let this : coeff p i * s ^ (p.natDegree - i) = 0 := by simpa using hi'\n        simp [this])\n    _ = p.support.sum fun i : ℕ => f (p.coeff i) * f s ^ (p.natDegree - i + i) * a ^ i :=\n      (Finset.sum_congr rfl fun i _hi => by\n        simp_rw [f.map_mul, f.map_pow, pow_add, hsa.mul_pow, mul_assoc])\n    _ = p.support.sum fun i : ℕ => f s ^ p.natDegree * (f (p.coeff i) * a ^ i) :=\n      Finset.sum_congr rfl fun i hi => by\n        rw [mul_assoc, ← map_pow, (hf _ _).left_comm, map_pow, tsub_add_cancel_of_le]\n        exact le_natDegree_of_ne_zero (Polynomial.mem_support_iff.mp hi)\n    _ = f s ^ p.natDegree * eval₂ f a p := by simp [← Finset.mul_sum, eval₂_eq_sum, sum_def]\n\n"}
{"name":"Polynomial.scaleRoots_eval₂_mul","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring S\ninst✝ : CommSemiring R\np : Polynomial S\nf : RingHom S R\nr : R\ns : S\n⊢ Eq (Polynomial.eval₂ f (HMul.hMul (f s) r) (p.scaleRoots s)) (HMul.hMul (HPow.hPow (f s) p.natDegree) (Polynomial.eval₂ f r p))","decl":"theorem scaleRoots_eval₂_mul {p : S[X]} (f : S →+* R) (r : R) (s : S) :\n    eval₂ f (f s * r) (scaleRoots p s) = f s ^ p.natDegree * eval₂ f r p :=\n  scaleRoots_eval₂_mul_of_commute f r s (mul_comm _ _) fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Polynomial.scaleRoots_eval₂_eq_zero","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : Semiring S\ninst✝ : CommSemiring R\np : Polynomial S\nf : RingHom S R\nr : R\ns : S\nhr : Eq (Polynomial.eval₂ f r p) 0\n⊢ Eq (Polynomial.eval₂ f (HMul.hMul (f s) r) (p.scaleRoots s)) 0","decl":"theorem scaleRoots_eval₂_eq_zero {p : S[X]} (f : S →+* R) {r : R} {s : S} (hr : eval₂ f r p = 0) :\n    eval₂ f (f s * r) (scaleRoots p s) = 0 := by rw [scaleRoots_eval₂_mul, hr, mul_zero]\n\n"}
{"name":"Polynomial.scaleRoots_aeval_eq_zero","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\nA : Type u_3\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\np : Polynomial R\na : A\nr : R\nha : Eq ((Polynomial.aeval a) p) 0\n⊢ Eq ((Polynomial.aeval (HMul.hMul ((algebraMap R A) r) a)) (p.scaleRoots r)) 0","decl":"theorem scaleRoots_aeval_eq_zero [Algebra R A] {p : R[X]} {a : A} {r : R} (ha : aeval a p = 0) :\n    aeval (algebraMap R A r * a) (scaleRoots p r) = 0 := by\n  rw [aeval_def, scaleRoots_eval₂_mul_of_commute, ← aeval_def, ha, mul_zero]\n  · apply Algebra.commutes\n  · intros; rw [Commute, SemiconjBy, ← map_mul, ← map_mul, mul_comm]\n\n"}
{"name":"Polynomial.scaleRoots_eval₂_eq_zero_of_eval₂_div_eq_zero","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"S : Type u_2\nK : Type u_4\ninst✝¹ : Semiring S\ninst✝ : Field K\np : Polynomial S\nf : RingHom S K\nhf : Function.Injective ⇑f\nr s : S\nhr : Eq (Polynomial.eval₂ f (HDiv.hDiv (f r) (f s)) p) 0\nhs : Membership.mem (nonZeroDivisors S) s\n⊢ Eq (Polynomial.eval₂ f (f r) (p.scaleRoots s)) 0","decl":"theorem scaleRoots_eval₂_eq_zero_of_eval₂_div_eq_zero {p : S[X]} {f : S →+* K}\n    (hf : Function.Injective f) {r s : S} (hr : eval₂ f (f r / f s) p = 0)\n    (hs : s ∈ nonZeroDivisors S) : eval₂ f (f r) (scaleRoots p s) = 0 := by\n  -- if we don't specify the type with `(_ : S)`, the proof is much slower\n  nontriviality S using Subsingleton.eq_zero (_ : S)\n  convert @scaleRoots_eval₂_eq_zero _ _ _ _ p f _ s hr\n  rw [← mul_div_assoc, mul_comm, mul_div_cancel_right₀]\n  exact map_ne_zero_of_mem_nonZeroDivisors _ hf hs\n\n"}
{"name":"Polynomial.scaleRoots_aeval_eq_zero_of_aeval_div_eq_zero","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\nK : Type u_4\ninst✝² : CommSemiring R\ninst✝¹ : Field K\ninst✝ : Algebra R K\ninj : Function.Injective ⇑(algebraMap R K)\np : Polynomial R\nr s : R\nhr : Eq ((Polynomial.aeval (HDiv.hDiv ((algebraMap R K) r) ((algebraMap R K) s))) p) 0\nhs : Membership.mem (nonZeroDivisors R) s\n⊢ Eq ((Polynomial.aeval ((algebraMap R K) r)) (p.scaleRoots s)) 0","decl":"theorem scaleRoots_aeval_eq_zero_of_aeval_div_eq_zero [Algebra R K]\n    (inj : Function.Injective (algebraMap R K)) {p : R[X]} {r s : R}\n    (hr : aeval (algebraMap R K r / algebraMap R K s) p = 0) (hs : s ∈ nonZeroDivisors R) :\n    aeval (algebraMap R K r) (scaleRoots p s) = 0 :=\n  scaleRoots_eval₂_eq_zero_of_eval₂_div_eq_zero inj hr hs\n\n"}
{"name":"Polynomial.scaleRoots_mul","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np : Polynomial R\nr s : R\n⊢ Eq (p.scaleRoots (HMul.hMul r s)) ((p.scaleRoots r).scaleRoots s)","decl":"@[simp]\nlemma scaleRoots_mul (p : R[X]) (r s) :\n    p.scaleRoots (r * s) = (p.scaleRoots r).scaleRoots s := by\n  ext; simp [mul_pow, mul_assoc]\n\n"}
{"name":"Polynomial.mul_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\n⊢ Eq (HSMul.hSMul (HPow.hPow r (HSub.hSub (HAdd.hAdd p.natDegree q.natDegree) (HMul.hMul p q).natDegree)) ((HMul.hMul p q).scaleRoots r)) (HMul.hMul (p.scaleRoots r) (q.scaleRoots r))","decl":"/-- Multiplication and `scaleRoots` commute up to a power of `r`. The factor disappears if we\nassume that the product of the leading coeffs does not vanish. See `Polynomial.mul_scaleRoots'`. -/\nlemma mul_scaleRoots (p q : R[X]) (r : R) :\n    r ^ (natDegree p + natDegree q - natDegree (p * q)) • (p * q).scaleRoots r =\n      p.scaleRoots r * q.scaleRoots r := by\n  ext n; simp only [coeff_scaleRoots, coeff_smul, smul_eq_mul]\n  trans (∑ x ∈ Finset.antidiagonal n, coeff p x.1 * coeff q x.2) *\n    r ^ (natDegree p + natDegree q - n)\n  · rw [← coeff_mul]\n    cases lt_or_le (natDegree (p * q)) n with\n    | inl h => simp only [coeff_eq_zero_of_natDegree_lt h, zero_mul, mul_zero]\n    | inr h =>\n      rw [mul_comm, mul_assoc, ← pow_add, add_comm, tsub_add_tsub_cancel natDegree_mul_le h]\n  · rw [coeff_mul, Finset.sum_mul]\n    apply Finset.sum_congr rfl\n    simp only [Finset.mem_antidiagonal, coeff_scaleRoots, Prod.forall]\n    intros a b e\n    cases lt_or_le (natDegree p) a with\n    | inl h => simp only [coeff_eq_zero_of_natDegree_lt h, zero_mul, mul_zero]\n    | inr ha =>\n      cases lt_or_le (natDegree q) b with\n      | inl h => simp only [coeff_eq_zero_of_natDegree_lt h, zero_mul, mul_zero]\n      | inr hb =>\n        simp only [← e, mul_assoc, mul_comm (r ^ (_ - a)), ← pow_add]\n        rw [add_comm (_ - _), tsub_add_tsub_comm ha hb]\n\n"}
{"name":"Polynomial.mul_scaleRoots'","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nh : Ne (HMul.hMul p.leadingCoeff q.leadingCoeff) 0\n⊢ Eq ((HMul.hMul p q).scaleRoots r) (HMul.hMul (p.scaleRoots r) (q.scaleRoots r))","decl":"lemma mul_scaleRoots' (p q : R[X]) (r : R) (h : leadingCoeff p * leadingCoeff q ≠ 0) :\n    (p * q).scaleRoots r = p.scaleRoots r * q.scaleRoots r := by\n  rw [← mul_scaleRoots, natDegree_mul' h, tsub_self, pow_zero, one_smul]\n\n"}
{"name":"Polynomial.mul_scaleRoots_of_noZeroDivisors","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np q : Polynomial R\nr : R\ninst✝ : NoZeroDivisors R\n⊢ Eq ((HMul.hMul p q).scaleRoots r) (HMul.hMul (p.scaleRoots r) (q.scaleRoots r))","decl":"lemma mul_scaleRoots_of_noZeroDivisors (p q : R[X]) (r : R) [NoZeroDivisors R] :\n    (p * q).scaleRoots r = p.scaleRoots r * q.scaleRoots r := by\n  by_cases hp : p = 0; · simp [hp]\n  by_cases hq : q = 0; · simp [hq]\n  apply mul_scaleRoots'\n  simp only [ne_eq, mul_eq_zero, leadingCoeff_eq_zero, hp, hq, or_self, not_false_eq_true]\n\n"}
{"name":"Polynomial.add_scaleRoots_of_natDegree_eq","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nh : Eq p.natDegree q.natDegree\n⊢ Eq (HSMul.hSMul (HPow.hPow r (HSub.hSub p.natDegree (HAdd.hAdd p q).natDegree)) ((HAdd.hAdd p q).scaleRoots r)) (HAdd.hAdd (p.scaleRoots r) (q.scaleRoots r))","decl":"lemma add_scaleRoots_of_natDegree_eq (p q : R[X]) (r : R) (h : natDegree p = natDegree q) :\n    r ^ (natDegree p - natDegree (p + q)) • (p + q).scaleRoots r =\n      p.scaleRoots r + q.scaleRoots r := by\n  ext n; simp only [coeff_smul, coeff_scaleRoots, coeff_add, smul_eq_mul,\n    mul_comm (r ^ _), ← pow_add, ← h, ← add_mul, add_comm (_ - n)]\n  #adaptation_note /-- v4.7.0-rc1\n  Previously `mul_assoc` was part of the `simp only` above, and this `rw` was not needed.\n  but this now causes a max rec depth error. -/\n  rw [mul_assoc, ← pow_add]\n  cases lt_or_le (natDegree (p + q)) n with\n  | inl hn => simp only [← coeff_add, coeff_eq_zero_of_natDegree_lt hn, zero_mul]\n  | inr hn =>\n      rw [add_comm (_ - n), tsub_add_tsub_cancel (natDegree_add_le_of_degree_le le_rfl h.ge) hn]\n\n"}
{"name":"Polynomial.scaleRoots_dvd'","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nhr : IsUnit r\nhpq : Dvd.dvd p q\n⊢ Dvd.dvd (p.scaleRoots r) (q.scaleRoots r)","decl":"lemma scaleRoots_dvd' (p q : R[X]) {r : R} (hr : IsUnit r)\n    (hpq : p ∣ q) : p.scaleRoots r ∣ q.scaleRoots r := by\n  obtain ⟨a, rfl⟩ := hpq\n  rw [← ((hr.pow (natDegree p + natDegree a - natDegree (p * a))).map\n    (algebraMap R R[X])).dvd_mul_left, ← Algebra.smul_def, mul_scaleRoots]\n  exact dvd_mul_right (scaleRoots p r) (scaleRoots a r)\n\n"}
{"name":"Polynomial.scaleRoots_dvd","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np q : Polynomial R\nr : R\ninst✝ : NoZeroDivisors R\nhpq : Dvd.dvd p q\n⊢ Dvd.dvd (p.scaleRoots r) (q.scaleRoots r)","decl":"lemma scaleRoots_dvd (p q : R[X]) {r : R} [NoZeroDivisors R] (hpq : p ∣ q) :\n    p.scaleRoots r ∣ q.scaleRoots r := by\n  obtain ⟨a, rfl⟩ := hpq\n  rw [mul_scaleRoots_of_noZeroDivisors]\n  exact dvd_mul_right (scaleRoots p r) (scaleRoots a r)\n"}
{"name":"Dvd.dvd.scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\np q : Polynomial R\nr : R\ninst✝ : NoZeroDivisors R\nhpq : Dvd.dvd p q\n⊢ Dvd.dvd (p.scaleRoots r) (q.scaleRoots r)","decl":"alias _root_.Dvd.dvd.scaleRoots := scaleRoots_dvd\n\n"}
{"name":"Polynomial.scaleRoots_dvd_iff","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nhr : IsUnit r\n⊢ Iff (Dvd.dvd (p.scaleRoots r) (q.scaleRoots r)) (Dvd.dvd p q)","decl":"lemma scaleRoots_dvd_iff (p q : R[X]) {r : R} (hr : IsUnit r) :\n    p.scaleRoots r ∣ q.scaleRoots r ↔ p ∣ q := by\n  refine ⟨?_ ∘ scaleRoots_dvd' _ _ (hr.unit⁻¹).isUnit, scaleRoots_dvd' p q hr⟩\n  simp [← scaleRoots_mul, scaleRoots_one]\n"}
{"name":"IsUnit.scaleRoots_dvd_iff","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nhr : IsUnit r\n⊢ Iff (Dvd.dvd (p.scaleRoots r) (q.scaleRoots r)) (Dvd.dvd p q)","decl":"alias _root_.IsUnit.scaleRoots_dvd_iff := scaleRoots_dvd_iff\n\n"}
{"name":"Polynomial.isCoprime_scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nhr : IsUnit r\nh : IsCoprime p q\n⊢ IsCoprime (p.scaleRoots r) (q.scaleRoots r)","decl":"lemma isCoprime_scaleRoots (p q : R[X]) (r : R) (hr : IsUnit r) (h : IsCoprime p q) :\n    IsCoprime (p.scaleRoots r) (q.scaleRoots r) := by\n  obtain ⟨a, b, e⟩ := h\n  let s : R := ↑hr.unit⁻¹\n  have : natDegree (a * p) = natDegree (b * q) := by\n    apply natDegree_eq_of_natDegree_add_eq_zero\n    rw [e, natDegree_one]\n  use s ^ natDegree (a * p) • s ^ (natDegree a + natDegree p - natDegree (a * p)) • a.scaleRoots r\n  use s ^ natDegree (a * p) • s ^ (natDegree b + natDegree q - natDegree (b * q)) • b.scaleRoots r\n  simp only [s, smul_mul_assoc, ← mul_scaleRoots, smul_smul, Units.smul_def, mul_assoc,\n    ← mul_pow, IsUnit.val_inv_mul, one_pow, mul_one, ← smul_add, one_smul, e, natDegree_one,\n    one_scaleRoots, ← add_scaleRoots_of_natDegree_eq _ _ _ this, tsub_zero]\n"}
{"name":"IsCoprime.scaleRoots","module":"Mathlib.RingTheory.Polynomial.ScaleRoots","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\np q : Polynomial R\nr : R\nhr : IsUnit r\nh : IsCoprime p q\n⊢ IsCoprime (p.scaleRoots r) (q.scaleRoots r)","decl":"alias _root_.IsCoprime.scaleRoots := isCoprime_scaleRoots\n\n"}
