{"name":"LieModule.eventually_genWeightSpace_smul_add_eq_bot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nhχ₁ : Ne χ₁ 0\n⊢ Filter.Eventually (fun k => Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul k χ₁) χ₂)) Bot.bot) Filter.atTop","decl":"lemma eventually_genWeightSpace_smul_add_eq_bot :\n    ∀ᶠ (k : ℕ) in Filter.atTop, genWeightSpace M (k • χ₁ + χ₂) = ⊥ := by\n  let f : ℕ → L → R := fun k ↦ k • χ₁ + χ₂\n  suffices Injective f by\n    rw [← Nat.cofinite_eq_atTop, Filter.eventually_cofinite, ← finite_image_iff this.injOn]\n    apply (finite_genWeightSpace_ne_bot R L M).subset\n    simp [f]\n  intro k l hkl\n  replace hkl : (k : ℤ) • χ₁ = (l : ℤ) • χ₁ := by\n    simpa only [f, add_left_inj, natCast_zsmul] using hkl\n  exact Nat.cast_inj.mp <| smul_left_injective ℤ hχ₁ hkl\n\n"}
{"name":"LieModule.exists_genWeightSpace_smul_add_eq_bot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nhχ₁ : Ne χ₁ 0\n⊢ Exists fun k => And (GT.gt k 0) (Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul k χ₁) χ₂)) Bot.bot)","decl":"lemma exists_genWeightSpace_smul_add_eq_bot :\n    ∃ k > 0, genWeightSpace M (k • χ₁ + χ₂) = ⊥ :=\n  (Nat.eventually_pos.and <| eventually_genWeightSpace_smul_add_eq_bot M χ₁ χ₂ hχ₁).exists\n\n"}
{"name":"LieModule.exists₂_genWeightSpace_smul_add_eq_bot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nhχ₁ : Ne χ₁ 0\n⊢ Exists fun p => And (LT.lt p 0) (Exists fun q => And (GT.gt q 0) (And (Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul p χ₁) χ₂)) Bot.bot) (Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul q χ₁) χ₂)) Bot.bot)))","decl":"lemma exists₂_genWeightSpace_smul_add_eq_bot :\n    ∃ᵉ (p < (0 : ℤ)) (q > (0 : ℤ)),\n      genWeightSpace M (p • χ₁ + χ₂) = ⊥ ∧\n      genWeightSpace M (q • χ₁ + χ₂) = ⊥ := by\n  obtain ⟨q, hq₀, hq⟩ := exists_genWeightSpace_smul_add_eq_bot M χ₁ χ₂ hχ₁\n  obtain ⟨p, hp₀, hp⟩ := exists_genWeightSpace_smul_add_eq_bot M (-χ₁) χ₂ (neg_ne_zero.mpr hχ₁)\n  refine ⟨-(p : ℤ), by simpa, q, by simpa, ?_, ?_⟩\n  · rw [neg_smul, ← smul_neg, natCast_zsmul]\n    exact hp\n  · rw [natCast_zsmul]\n    exact hq\n\n"}
{"name":"LieModule.genWeightSpaceChain_def","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\np q : Int\n⊢ Eq (LieModule.genWeightSpaceChain M χ₁ χ₂ p q) (iSup fun k => iSup fun h => LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul k χ₁) χ₂))","decl":"lemma genWeightSpaceChain_def :\n    genWeightSpaceChain M χ₁ χ₂ p q = ⨆ k ∈ Ioo p q, genWeightSpace M (k • χ₁ + χ₂) :=\n  rfl\n\n"}
{"name":"LieModule.genWeightSpaceChain_def'","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\np q : Int\n⊢ Eq (LieModule.genWeightSpaceChain M χ₁ χ₂ p q) (iSup fun k => iSup fun h => LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul k χ₁) χ₂))","decl":"lemma genWeightSpaceChain_def' :\n    genWeightSpaceChain M χ₁ χ₂ p q = ⨆ k ∈ Finset.Ioo p q, genWeightSpace M (k • χ₁ + χ₂) := by\n  have : ∀ (k : ℤ), k ∈ Ioo p q ↔ k ∈ Finset.Ioo p q := by simp\n  simp_rw [genWeightSpaceChain_def, this]\n\n"}
{"name":"LieModule.genWeightSpaceChain_neg","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\np q : Int\n⊢ Eq (LieModule.genWeightSpaceChain M (Neg.neg χ₁) χ₂ (Neg.neg q) (Neg.neg p)) (LieModule.genWeightSpaceChain M χ₁ χ₂ p q)","decl":"@[simp]\nlemma genWeightSpaceChain_neg :\n    genWeightSpaceChain M (-χ₁) χ₂ (-q) (-p) = genWeightSpaceChain M χ₁ χ₂ p q := by\n  let e : ℤ ≃ ℤ := neg_involutive.toPerm\n  simp_rw [genWeightSpaceChain, ← e.biSup_comp (Ioo p q)]\n  simp [e, -mem_Ioo, neg_mem_Ioo_iff]\n\n"}
{"name":"LieModule.genWeightSpace_le_genWeightSpaceChain","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\ninst✝ : LieRing.IsNilpotent L\nχ₁ χ₂ : L → R\np q k : Int\nhk : Membership.mem (Set.Ioo p q) k\n⊢ LE.le (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul k χ₁) χ₂)) (LieModule.genWeightSpaceChain M χ₁ χ₂ p q)","decl":"lemma genWeightSpace_le_genWeightSpaceChain {k : ℤ} (hk : k ∈ Ioo p q) :\n    genWeightSpace M (k • χ₁ + χ₂) ≤ genWeightSpaceChain M χ₁ χ₂ p q :=\n  le_biSup (fun i ↦ genWeightSpace M (i • χ₁ + χ₂)) hk\n\n"}
{"name":"LieModule.lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_right","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\nH : LieSubalgebra R L\nα χ : (Subtype fun x => Membership.mem H x) → R\np q : Int\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nhq : Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul q α) χ)) Bot.bot\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H α) x\ny : M\nhy : Membership.mem (LieModule.genWeightSpaceChain M α χ p q) y\n⊢ Membership.mem (LieModule.genWeightSpaceChain M α χ p q) (Bracket.bracket x y)","decl":"lemma lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_right [LieRing.IsNilpotent H]\n    (hq : genWeightSpace M (q • α + χ) = ⊥)\n    {x : L} (hx : x ∈ rootSpace H α)\n    {y : M} (hy : y ∈ genWeightSpaceChain M α χ p q) :\n    ⁅x, y⁆ ∈ genWeightSpaceChain M α χ p q := by\n  rw [genWeightSpaceChain, iSup_subtype'] at hy\n  induction hy using LieSubmodule.iSup_induction' with\n  | hN k z hz =>\n    obtain ⟨k, hk⟩ := k\n    suffices genWeightSpace M ((k + 1) • α + χ) ≤ genWeightSpaceChain M α χ p q by\n      apply this\n      -- was `simpa using [...]` and very slow\n      -- (https://github.com/leanprover-community/mathlib4/issues/19751)\n      simpa only [zsmul_eq_mul, Int.cast_add, Pi.intCast_def, Int.cast_one] using\n        (rootSpaceWeightSpaceProduct R L H M α (k • α + χ) ((k + 1) • α + χ)\n            (by rw [add_smul]; abel) (⟨x, hx⟩ ⊗ₜ ⟨z, hz⟩)).property\n    rw [genWeightSpaceChain]\n    rcases eq_or_ne (k + 1) q with rfl | hk'; · simp only [hq, bot_le]\n    replace hk' : k + 1 ∈ Ioo p q := ⟨by linarith [hk.1], lt_of_le_of_ne hk.2 hk'⟩\n    exact le_biSup (fun k ↦ genWeightSpace M (k • α + χ)) hk'\n  | h0 => simp\n  | hadd _ _ _ _ hz₁ hz₂ => rw [lie_add]; exact add_mem hz₁ hz₂\n\n"}
{"name":"LieModule.lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_left","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁷ : CommRing R\ninst✝⁶ : LieRing L\ninst✝⁵ : LieAlgebra R L\nM : Type u_3\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : LieRingModule L M\ninst✝¹ : LieModule R L M\nH : LieSubalgebra R L\nα χ : (Subtype fun x => Membership.mem H x) → R\np q : Int\ninst✝ : LieRing.IsNilpotent (Subtype fun x => Membership.mem H x)\nhp : Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul p α) χ)) Bot.bot\nx : L\nhx : Membership.mem (LieAlgebra.rootSpace H (Neg.neg α)) x\ny : M\nhy : Membership.mem (LieModule.genWeightSpaceChain M α χ p q) y\n⊢ Membership.mem (LieModule.genWeightSpaceChain M α χ p q) (Bracket.bracket x y)","decl":"lemma lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_left [LieRing.IsNilpotent H]\n    (hp : genWeightSpace M (p • α + χ) = ⊥)\n    {x : L} (hx : x ∈ rootSpace H (-α))\n    {y : M} (hy : y ∈ genWeightSpaceChain M α χ p q) :\n    ⁅x, y⁆ ∈ genWeightSpaceChain M α χ p q := by\n  replace hp : genWeightSpace M ((-p) • (-α) + χ) = ⊥ := by rwa [smul_neg, neg_smul, neg_neg]\n  rw [← genWeightSpaceChain_neg] at hy ⊢\n  exact lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_right M (-α) χ (-q) (-p) hp hx hy\n\n"}
{"name":"LieModule.trace_toEnd_genWeightSpaceChain_eq_zero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝⁸ : CommRing R\ninst✝⁷ : LieRing L\ninst✝⁶ : LieAlgebra R L\nM : Type u_3\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : LieRingModule L M\ninst✝² : LieModule R L M\nH : LieSubalgebra R L\nα χ : (Subtype fun x => Membership.mem H x) → R\np q : Int\ninst✝¹ : H.IsCartanSubalgebra\ninst✝ : IsNoetherian R L\nhp : Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul p α) χ)) Bot.bot\nhq : Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul q α) χ)) Bot.bot\nx : Subtype fun x => Membership.mem H x\nhx : Membership.mem (LieAlgebra.corootSpace α) x\n⊢ Eq ((LinearMap.trace R (Subtype fun x => Membership.mem (LieModule.genWeightSpaceChain M α χ p q) x)) ((LieModule.toEnd R (Subtype fun x => Membership.mem H x) (Subtype fun x => Membership.mem (LieModule.genWeightSpaceChain M α χ p q) x)) x)) 0","decl":"lemma trace_toEnd_genWeightSpaceChain_eq_zero\n    (hp : genWeightSpace M (p • α + χ) = ⊥)\n    (hq : genWeightSpace M (q • α + χ) = ⊥)\n    {x : H} (hx : x ∈ corootSpace α) :\n    LinearMap.trace R _ (toEnd R H (genWeightSpaceChain M α χ p q) x) = 0 := by\n  rw [LieAlgebra.mem_corootSpace'] at hx\n  induction hx using Submodule.span_induction\n  · next u hu =>\n    obtain ⟨y, hy, z, hz, hyz⟩ := hu\n    let f : Module.End R (genWeightSpaceChain M α χ p q) :=\n      { toFun := fun ⟨m, hm⟩ ↦ ⟨⁅(y : L), m⁆,\n          lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_right M α χ p q hq hy hm⟩\n        map_add' := fun _ _ ↦ by simp\n        map_smul' := fun t m ↦ by simp }\n    let g : Module.End R (genWeightSpaceChain M α χ p q) :=\n      { toFun := fun ⟨m, hm⟩ ↦ ⟨⁅(z : L), m⁆,\n          lie_mem_genWeightSpaceChain_of_genWeightSpace_eq_bot_left M α χ p q hp hz hm⟩\n        map_add' := fun _ _ ↦ by simp\n        map_smul' := fun t m ↦ by simp }\n    have hfg : toEnd R H _ u = ⁅f, g⁆ := by\n      ext\n      rw [toEnd_apply_apply, LieSubmodule.coe_bracket, LieSubalgebra.coe_bracket_of_module, ← hyz]\n      simp only [lie_lie, LieHom.lie_apply, LinearMap.coe_mk, AddHom.coe_mk, Module.End.lie_apply,\n      AddSubgroupClass.coe_sub, f, g]\n    simp [hfg]\n  · simp\n  · simp_all\n  · simp_all\n\n"}
{"name":"LieModule.exists_forall_mem_corootSpace_smul_add_eq_zero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹³ : CommRing R\ninst✝¹² : LieRing L\ninst✝¹¹ : LieAlgebra R L\nM : Type u_3\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : LieRingModule L M\ninst✝⁷ : LieModule R L M\nH : LieSubalgebra R L\nα χ : (Subtype fun x => Membership.mem H x) → R\ninst✝⁶ : H.IsCartanSubalgebra\ninst✝⁵ : IsNoetherian R L\ninst✝⁴ : IsDomain R\ninst✝³ : IsPrincipalIdealRing R\ninst✝² : CharZero R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nhα : Ne α 0\nhχ : Ne (LieModule.genWeightSpace M χ) Bot.bot\n⊢ Exists fun a => Exists fun b => And (LT.lt 0 b) (∀ (x : Subtype fun x => Membership.mem H x), Membership.mem (LieAlgebra.corootSpace α) x → Eq (HAdd.hAdd (HSMul.hSMul a α) (HSMul.hSMul b χ) x) 0)","decl":"/-- Given a (potential) root `α` relative to a Cartan subalgebra `H`, if we restrict to the ideal\n`I = corootSpace α` of `H` (informally, `I = ⁅H(α), H(-α)⁆`), we may find an\nintegral linear combination between `α` and any weight `χ` of a representation.\n\nThis is Proposition 4.4 from [carter2005] and is a key step in the proof that the roots of a\nsemisimple Lie algebra form a root system. It shows that the restriction of `α` to `I` vanishes iff\nthe restriction of every root to `I` vanishes (which cannot happen in a semisimple Lie algebra). -/\nlemma exists_forall_mem_corootSpace_smul_add_eq_zero\n    [IsDomain R] [IsPrincipalIdealRing R] [CharZero R] [NoZeroSMulDivisors R M] [IsNoetherian R M]\n    (hα : α ≠ 0) (hχ : genWeightSpace M χ ≠ ⊥) :\n    ∃ a b : ℤ, 0 < b ∧ ∀ x ∈ corootSpace α, (a • α + b • χ) x = 0 := by\n  obtain ⟨p, hp₀, q, hq₀, hp, hq⟩ := exists₂_genWeightSpace_smul_add_eq_bot M α χ hα\n  let a := ∑ i ∈ Finset.Ioo p q, finrank R (genWeightSpace M (i • α + χ)) • i\n  let b := ∑ i ∈ Finset.Ioo p q, finrank R (genWeightSpace M (i • α + χ))\n  have hb : 0 < b := by\n    replace hχ : Nontrivial (genWeightSpace M χ) := by rwa [LieSubmodule.nontrivial_iff_ne_bot]\n    refine Finset.sum_pos' (fun _ _ ↦ zero_le _) ⟨0, Finset.mem_Ioo.mpr ⟨hp₀, hq₀⟩, ?_⟩\n    rw [zero_smul, zero_add]\n    exact finrank_pos\n  refine ⟨a, b, Int.ofNat_pos.mpr hb, fun x hx ↦ ?_⟩\n  let N : ℤ → Submodule R M := fun k ↦ genWeightSpace M (k • α + χ)\n  have h₁ : iSupIndep fun (i : Finset.Ioo p q) ↦ N i := by\n    rw [← LieSubmodule.iSupIndep_iff_toSubmodule]\n    refine (iSupIndep_genWeightSpace R H M).comp fun i j hij ↦ ?_\n    exact SetCoe.ext <| smul_left_injective ℤ hα <| by rwa [add_left_inj] at hij\n  have h₂ : ∀ i, MapsTo (toEnd R H M x) ↑(N i) ↑(N i) := fun _ _ ↦ LieSubmodule.lie_mem _\n  have h₃ : genWeightSpaceChain M α χ p q = ⨆ i ∈ Finset.Ioo p q, N i := by\n    simp_rw [N, genWeightSpaceChain_def', LieSubmodule.iSup_toSubmodule]\n  rw [← trace_toEnd_genWeightSpaceChain_eq_zero M α χ p q hp hq hx,\n    ← LieSubmodule.toEnd_restrict_eq_toEnd]\n  -- The lines below illustrate the cost of treating `LieSubmodule` as both a\n  -- `Submodule` and a `LieSubmodule` simultaneously.\n  erw [LinearMap.trace_eq_sum_trace_restrict_of_eq_biSup _ h₁ h₂ (genWeightSpaceChain M α χ p q) h₃]\n  simp_rw [N, LieSubmodule.toEnd_restrict_eq_toEnd]\n  dsimp [N]\n  convert_to _ =\n    ∑ k ∈ Finset.Ioo p q, (LinearMap.trace R { x // x ∈ (genWeightSpace M (k • α + χ)) })\n      ((toEnd R { x // x ∈ H } { x // x ∈ genWeightSpace M (k • α + χ) }) x)\n  simp_rw [a, b, trace_toEnd_genWeightSpace, Pi.add_apply, Pi.smul_apply, smul_add,\n    ← smul_assoc, Finset.sum_add_distrib, ← Finset.sum_smul, natCast_zsmul]\n\n"}
{"name":"LieModule.chainTopCoeff_neg","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainTopCoeff (Neg.neg α) β) (LieModule.chainBotCoeff α β)","decl":"@[simp] lemma chainTopCoeff_neg : chainTopCoeff (-α) β = chainBotCoeff α β := rfl\n"}
{"name":"LieModule.chainBotCoeff_neg","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainBotCoeff (Neg.neg α) β) (LieModule.chainTopCoeff α β)","decl":"@[simp] lemma chainBotCoeff_neg : chainBotCoeff (-α) β = chainTopCoeff α β := by\n  rw [← chainTopCoeff_neg, neg_neg]\n\n"}
{"name":"LieModule.chainTopCoeff_zero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainTopCoeff 0 β) 0","decl":"@[simp] lemma chainTopCoeff_zero : chainTopCoeff 0 β = 0 := dif_pos rfl\n"}
{"name":"LieModule.chainBotCoeff_zero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainBotCoeff 0 β) 0","decl":"@[simp] lemma chainBotCoeff_zero : chainBotCoeff 0 β = 0 := dif_pos neg_zero\n\n"}
{"name":"LieModule.chainTopCoeff_add_one","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\n⊢ Eq (HAdd.hAdd (LieModule.chainTopCoeff α β) 1) (Nat.find ⋯)","decl":"lemma chainTopCoeff_add_one :\n    letI := Classical.propDecidable\n    chainTopCoeff α β + 1 =\n      Nat.find (eventually_genWeightSpace_smul_add_eq_bot M α β hα).exists := by\n  classical\n  rw [chainTopCoeff, dif_neg hα]\n  apply Nat.succ_pred_eq_of_pos\n  rw [zero_lt_iff]\n  intro e\n  have : genWeightSpace M (0 • α + β : L → R) = ⊥ := by\n    rw [← e]\n    exact Nat.find_spec (eventually_genWeightSpace_smul_add_eq_bot M α β hα).exists\n  exact β.genWeightSpace_ne_bot _ (by simpa only [zero_smul, zero_add] using this)\n\n"}
{"name":"LieModule.genWeightSpace_chainTopCoeff_add_one_nsmul_add","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\n⊢ Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd (LieModule.chainTopCoeff α β) 1) α) ⇑β)) Bot.bot","decl":"lemma genWeightSpace_chainTopCoeff_add_one_nsmul_add :\n    genWeightSpace M ((chainTopCoeff α β + 1) • α + β : L → R) = ⊥ := by\n  classical\n  rw [chainTopCoeff_add_one _ _ hα]\n  exact Nat.find_spec (eventually_genWeightSpace_smul_add_eq_bot M α β hα).exists\n\n"}
{"name":"LieModule.genWeightSpace_chainTopCoeff_add_one_zsmul_add","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\n⊢ Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul (HAdd.hAdd (↑(LieModule.chainTopCoeff α β)) 1) α) ⇑β)) Bot.bot","decl":"lemma genWeightSpace_chainTopCoeff_add_one_zsmul_add :\n    genWeightSpace M ((chainTopCoeff α β + 1 : ℤ) • α + β : L → R) = ⊥ := by\n  rw [← genWeightSpace_chainTopCoeff_add_one_nsmul_add α β hα, ← Nat.cast_smul_eq_nsmul ℤ,\n    Nat.cast_add, Nat.cast_one]\n\n"}
{"name":"LieModule.genWeightSpace_chainBotCoeff_sub_one_zsmul_sub","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\n⊢ Eq (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul (HSub.hSub (Neg.neg ↑(LieModule.chainBotCoeff α β)) 1) α) ⇑β)) Bot.bot","decl":"lemma genWeightSpace_chainBotCoeff_sub_one_zsmul_sub :\n    genWeightSpace M ((-chainBotCoeff α β - 1 : ℤ) • α + β : L → R) = ⊥ := by\n  rw [sub_eq_add_neg, ← neg_add, neg_smul, ← smul_neg, chainBotCoeff,\n    genWeightSpace_chainTopCoeff_add_one_zsmul_add _ _ (by simpa using hα)]\n\n"}
{"name":"LieModule.genWeightSpace_nsmul_add_ne_bot_of_le","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nn : Nat\nhn : LE.le n (LieModule.chainTopCoeff α β)\n⊢ Ne (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul n α) ⇑β)) Bot.bot","decl":"lemma genWeightSpace_nsmul_add_ne_bot_of_le {n} (hn : n ≤ chainTopCoeff α β) :\n    genWeightSpace M (n • α + β : L → R) ≠ ⊥ := by\n  by_cases hα : α = 0\n  · rw [hα, smul_zero, zero_add]; exact β.genWeightSpace_ne_bot\n  classical\n  rw [← Nat.lt_succ, Nat.succ_eq_add_one, chainTopCoeff_add_one _ _ hα] at hn\n  exact Nat.find_min (eventually_genWeightSpace_smul_add_eq_bot M α β hα).exists hn\n\n"}
{"name":"LieModule.genWeightSpace_zsmul_add_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nn : Int\nhn : LE.le (Neg.neg ↑(LieModule.chainBotCoeff α β)) n\nhn' : LE.le n ↑(LieModule.chainTopCoeff α β)\n⊢ Ne (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul n α) ⇑β)) Bot.bot","decl":"lemma genWeightSpace_zsmul_add_ne_bot {n : ℤ}\n    (hn : -chainBotCoeff α β ≤ n) (hn' : n ≤ chainTopCoeff α β) :\n      genWeightSpace M (n • α + β : L → R) ≠ ⊥ := by\n  rcases n with (n | n)\n  · simp only [Int.ofNat_eq_coe, Nat.cast_le, Nat.cast_smul_eq_nsmul] at hn' ⊢\n    exact genWeightSpace_nsmul_add_ne_bot_of_le α β hn'\n  · simp only [Int.negSucc_eq, ← Nat.cast_succ, neg_le_neg_iff, Nat.cast_le] at hn ⊢\n    rw [neg_smul, ← smul_neg, Nat.cast_smul_eq_nsmul]\n    exact genWeightSpace_nsmul_add_ne_bot_of_le (-α) β hn\n\n"}
{"name":"LieModule.genWeightSpace_neg_zsmul_add_ne_bot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nn : Nat\nhn : LE.le n (LieModule.chainBotCoeff α β)\n⊢ Ne (LieModule.genWeightSpace M (HAdd.hAdd (HSMul.hSMul (Neg.neg ↑n) α) ⇑β)) Bot.bot","decl":"lemma genWeightSpace_neg_zsmul_add_ne_bot {n : ℕ} (hn : n ≤ chainBotCoeff α β) :\n    genWeightSpace M ((-n : ℤ) • α + β : L → R) ≠ ⊥ := by\n  apply genWeightSpace_zsmul_add_ne_bot α β <;> omega\n\n"}
{"name":"LieModule.coe_chainTop'","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (⇑(LieModule.chainTop α β)) (HAdd.hAdd (HSMul.hSMul (LieModule.chainTopCoeff α β) α) ⇑β)","decl":"lemma coe_chainTop' : (chainTop α β : L → R) = chainTopCoeff α β • α + β := rfl\n\n"}
{"name":"LieModule.coe_chainTop","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (⇑(LieModule.chainTop α β)) (HAdd.hAdd (HSMul.hSMul (↑(LieModule.chainTopCoeff α β)) α) ⇑β)","decl":"@[simp] lemma coe_chainTop : (chainTop α β : L → R) = (chainTopCoeff α β : ℤ) • α + β := by\n  rw [Nat.cast_smul_eq_nsmul ℤ]; rfl\n"}
{"name":"LieModule.coe_chainBot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (⇑(LieModule.chainBot α β)) (HAdd.hAdd (HSMul.hSMul (Neg.neg ↑(LieModule.chainBotCoeff α β)) α) ⇑β)","decl":"@[simp] lemma coe_chainBot : (chainBot α β : L → R) = (-chainBotCoeff α β : ℤ) • α + β := rfl\n\n"}
{"name":"LieModule.chainTop_neg","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainTop (Neg.neg α) β) (LieModule.chainBot α β)","decl":"@[simp] lemma chainTop_neg : chainTop (-α) β = chainBot α β := by ext; simp\n"}
{"name":"LieModule.chainBot_neg","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainBot (Neg.neg α) β) (LieModule.chainTop α β)","decl":"@[simp] lemma chainBot_neg : chainBot (-α) β = chainTop α β := by ext; simp\n\n"}
{"name":"LieModule.chainTop_zero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainTop 0 β) β","decl":"@[simp] lemma chainTop_zero : chainTop 0 β = β := by ext; simp\n"}
{"name":"LieModule.chainBot_zero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nβ : LieModule.Weight R L M\n⊢ Eq (LieModule.chainBot 0 β) β","decl":"@[simp] lemma chainBot_zero : chainBot 0 β = β := by ext; simp\n\n"}
{"name":"LieModule.genWeightSpace_add_chainTop","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\n⊢ Eq (LieModule.genWeightSpace M (HAdd.hAdd α ⇑(LieModule.chainTop α β))) Bot.bot","decl":"lemma genWeightSpace_add_chainTop :\n    genWeightSpace M (α + chainTop α β : L → R) = ⊥ := by\n  rw [coe_chainTop', ← add_assoc, ← succ_nsmul',\n    genWeightSpace_chainTopCoeff_add_one_nsmul_add _ _ hα]\n\n"}
{"name":"LieModule.genWeightSpace_neg_add_chainBot","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\n⊢ Eq (LieModule.genWeightSpace M (HAdd.hAdd (Neg.neg α) ⇑(LieModule.chainBot α β))) Bot.bot","decl":"lemma genWeightSpace_neg_add_chainBot :\n    genWeightSpace M (-α + chainBot α β : L → R) = ⊥ := by\n  rw [← chainTop_neg, genWeightSpace_add_chainTop _ _ (by simpa using hα)]\n\n"}
{"name":"LieModule.chainTop_isNonZero'","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα : L → R\nβ : LieModule.Weight R L M\nhα : Ne α 0\nhα' : Ne (LieModule.genWeightSpace M α) Bot.bot\n⊢ (LieModule.chainTop α β).IsNonZero","decl":"lemma chainTop_isNonZero' (hα' : genWeightSpace M α ≠ ⊥) :\n    (chainTop α β).IsNonZero := by\n  by_contra e\n  apply hα'\n  rw [← add_zero (α : L → R), ← e, genWeightSpace_add_chainTop _ _ hα]\n\n"}
{"name":"LieModule.chainTop_isNonZero","module":"Mathlib.Algebra.Lie.Weights.Chain","initialProofState":"R : Type u_1\nL : Type u_2\ninst✝¹⁰ : CommRing R\ninst✝⁹ : LieRing L\ninst✝⁸ : LieAlgebra R L\nM : Type u_3\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : LieRingModule L M\ninst✝⁴ : LieModule R L M\ninst✝³ : LieRing.IsNilpotent L\ninst✝² : NoZeroSMulDivisors Int R\ninst✝¹ : NoZeroSMulDivisors R M\ninst✝ : IsNoetherian R M\nα β : LieModule.Weight R L M\nhα : α.IsNonZero\n⊢ (LieModule.chainTop (⇑α) β).IsNonZero","decl":"lemma chainTop_isNonZero (α β : Weight R L M) (hα : α.IsNonZero) :\n    (chainTop α β).IsNonZero :=\n  chainTop_isNonZero' α β hα α.2\n\n"}
