{"name":"CategoryTheory.Functorial.map_comp'","module":"Mathlib.CategoryTheory.Functor.Functorial","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : C ‚Üí D\nself : CategoryTheory.Functorial F\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.Functorial.map' (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Functorial.map' f) (CategoryTheory.Functorial.map' g))","decl":"/-- An unbundled functor. -/\nclass Functorial (F : C ‚Üí D) : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functorial map extends to an action on morphisms. -/\n  map' : ‚àÄ {X Y : C}, (X ‚ü∂ Y) ‚Üí (F X ‚ü∂ F Y)\n  /-- A functorial map preserves identities. -/\n  map_id' : ‚àÄ X : C, map' (ùüô X) = ùüô (F X) := by aesop_cat\n  /-- A functorial map preserves composition of morphisms. -/\n  map_comp' : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map' (f ‚â´ g) = map' f ‚â´ map' g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.Functorial.map_id'","module":"Mathlib.CategoryTheory.Functor.Functorial","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : C ‚Üí D\nself : CategoryTheory.Functorial F\nX : C\n‚ä¢ Eq (CategoryTheory.Functorial.map' (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (F X))","decl":"/-- An unbundled functor. -/\nclass Functorial (F : C ‚Üí D) : Type max v‚ÇÅ v‚ÇÇ u‚ÇÅ u‚ÇÇ where\n  /-- A functorial map extends to an action on morphisms. -/\n  map' : ‚àÄ {X Y : C}, (X ‚ü∂ Y) ‚Üí (F X ‚ü∂ F Y)\n  /-- A functorial map preserves identities. -/\n  map_id' : ‚àÄ X : C, map' (ùüô X) = ùüô (F X) := by aesop_cat\n  /-- A functorial map preserves composition of morphisms. -/\n  map_comp' : ‚àÄ {X Y Z : C} (f : X ‚ü∂ Y) (g : Y ‚ü∂ Z), map' (f ‚â´ g) = map' f ‚â´ map' g := by\n    aesop_cat\n\n"}
{"name":"CategoryTheory.map'_as_map","module":"Mathlib.CategoryTheory.Functor.Functorial","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : C ‚Üí D\ninst‚úù : CategoryTheory.Functorial F\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.Functorial.map' f) (CategoryTheory.map F f)","decl":"@[simp]\ntheorem map'_as_map {F : C ‚Üí D} [Functorial.{v‚ÇÅ, v‚ÇÇ} F] {X Y : C} {f : X ‚ü∂ Y} :\n    Functorial.map'.{v‚ÇÅ, v‚ÇÇ} f = map F f :=\n  rfl\n\n"}
{"name":"CategoryTheory.Functorial.map_id","module":"Mathlib.CategoryTheory.Functor.Functorial","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : C ‚Üí D\ninst‚úù : CategoryTheory.Functorial F\nX : C\n‚ä¢ Eq (CategoryTheory.map F (CategoryTheory.CategoryStruct.id X)) (CategoryTheory.CategoryStruct.id (F X))","decl":"@[simp]\ntheorem Functorial.map_id {F : C ‚Üí D} [Functorial.{v‚ÇÅ, v‚ÇÇ} F] {X : C} : map F (ùüô X) = ùüô (F X) :=\n  Functorial.map_id' X\n\n"}
{"name":"CategoryTheory.Functorial.map_comp","module":"Mathlib.CategoryTheory.Functor.Functorial","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬≤ : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : C ‚Üí D\ninst‚úù : CategoryTheory.Functorial F\nX Y Z : C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n‚ä¢ Eq (CategoryTheory.map F (CategoryTheory.CategoryStruct.comp f g)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.map F f) (CategoryTheory.map F g))","decl":"@[simp]\ntheorem Functorial.map_comp {F : C ‚Üí D} [Functorial.{v‚ÇÅ, v‚ÇÇ} F] {X Y Z : C} {f : X ‚ü∂ Y}\n    {g : Y ‚ü∂ Z} : map F (f ‚â´ g) = map F f ‚â´ map F g :=\n  Functorial.map_comp' f g\n\n"}
{"name":"CategoryTheory.map_functorial_obj","module":"Mathlib.CategoryTheory.Functor.Functorial","initialProofState":"C : Type u‚ÇÅ\ninst‚úù¬π : CategoryTheory.Category.{v‚ÇÅ, u‚ÇÅ} C\nD : Type u‚ÇÇ\ninst‚úù : CategoryTheory.Category.{v‚ÇÇ, u‚ÇÇ} D\nF : CategoryTheory.Functor C D\nX Y : C\nf : Quiver.Hom X Y\n‚ä¢ Eq (CategoryTheory.map F.obj f) (F.map f)","decl":"@[simp]\ntheorem map_functorial_obj (F : C ‚•§ D) {X Y : C} (f : X ‚ü∂ Y) : map F.obj f = F.map f :=\n  rfl\n\n"}
