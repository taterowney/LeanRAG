{"name":"Module.FinitePresentation.out","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nself : Module.FinitePresentation R M\n⊢ Exists fun s => And (Eq (Submodule.span R ↑s) Top.top) (LinearMap.ker (Finsupp.linearCombination R Subtype.val)).FG","decl":"/--\nA module is finitely presented if it is finitely generated by some set `s`\nand the kernel of the presentation `Rˢ → M` is also finitely generated.\n-/\nclass Module.FinitePresentation : Prop where\n  out : ∃ (s : Finset M), Submodule.span R (s : Set M) = ⊤ ∧\n    (LinearMap.ker (Finsupp.linearCombination R ((↑) : s → M))).FG\n\n"}
{"name":"instFiniteOfFinitePresentation","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nh : Module.FinitePresentation R M\n⊢ Module.Finite R M","decl":"instance (priority := 100) [h : Module.FinitePresentation R M] : Module.Finite R M := by\n  obtain ⟨s, hs₁, _⟩ := h\n  exact ⟨s, hs₁⟩\n\n"}
{"name":"Module.FinitePresentation.exists_fin","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u\nM : Type u_1\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nfp : Module.FinitePresentation R M\n⊢ Exists fun n => Exists fun K => Exists fun x => K.FG","decl":"theorem Module.FinitePresentation.exists_fin [fp : Module.FinitePresentation R M] :\n    ∃ (n : ℕ) (K : Submodule R (Fin n → R)) (_ : M ≃ₗ[R] (Fin n → R) ⧸ K), K.FG := by\n  have ⟨ι, ⟨hι₁, hι₂⟩⟩ := fp\n  refine ⟨_, LinearMap.ker (linearCombination R Subtype.val ∘ₗ\n    (lcongr ι.equivFin (.refl ..) ≪≫ₗ linearEquivFunOnFinite R R _).symm.toLinearMap),\n    (LinearMap.quotKerEquivOfSurjective _ <| LinearMap.range_eq_top.mp ?_).symm, ?_⟩\n  · simpa [range_linearCombination] using hι₁\n  · simpa [LinearMap.ker_comp, Submodule.comap_equiv_eq_map_symm] using hι₂.map _\n\n"}
{"name":"Module.FinitePresentation.equiv_quotient","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u\nM : Type u_1\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.FinitePresentation R M\ninst✝ : Small.{v, u} R\n⊢ Exists fun L => Exists fun x => Exists fun x_1 => Exists fun K => Exists fun x_2 => And (Module.Free R L) (And (Module.Finite R L) K.FG)","decl":"/-- A finitely presented module is isomorphic to the quotient of a finite free module by a finitely\ngenerated submodule. -/\ntheorem Module.FinitePresentation.equiv_quotient [Module.FinitePresentation R M] [Small.{v} R] :\n    ∃ (L : Type v) (_ : AddCommGroup L) (_ : Module R L) (K : Submodule R L)\n      (_ : M ≃ₗ[R] L ⧸ K), Module.Free R L ∧ Module.Finite R L ∧ K.FG :=\n  have ⟨_n, _K, e, fg⟩ := Module.FinitePresentation.exists_fin R M\n  let es := linearEquivShrink\n  ⟨_, inferInstance, inferInstance, _, e ≪≫ₗ Submodule.Quotient.equiv _ _ (es ..) rfl,\n    .of_equiv (es ..), .equiv (es ..), fg.map (es ..).toLinearMap⟩\n\n"}
{"name":"Module.finitePresentation_of_finite","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherianRing R\nh : Module.Finite R M\n⊢ Module.FinitePresentation R M","decl":"lemma Module.finitePresentation_of_finite [IsNoetherianRing R] [h : Module.Finite R M] :\n    Module.FinitePresentation R M := by\n  obtain ⟨s, hs⟩ := h\n  exact ⟨s, hs, IsNoetherian.noetherian _⟩\n\n"}
{"name":"Module.finitePresentation_iff_finite","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsNoetherianRing R\n⊢ Iff (Module.FinitePresentation R M) (Module.Finite R M)","decl":"lemma Module.finitePresentation_iff_finite [IsNoetherianRing R] :\n    Module.FinitePresentation R M ↔ Module.Finite R M :=\n  ⟨fun _ ↦ inferInstance, fun _ ↦ finitePresentation_of_finite R M⟩\n\n"}
{"name":"Module.finitePresentation_of_free_of_surjective","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Module.Free R M\ninst✝ : Module.Finite R M\nl : LinearMap (RingHom.id R) M N\nhl : Function.Surjective ⇑l\nhl' : (LinearMap.ker l).FG\n⊢ Module.FinitePresentation R N","decl":"lemma Module.finitePresentation_of_free_of_surjective [Module.Free R M] [Module.Finite R M]\n    (l : M →ₗ[R] N)\n    (hl : Function.Surjective l) (hl' : (LinearMap.ker l).FG) :\n    Module.FinitePresentation R N := by\n  classical\n  let b := Module.Free.chooseBasis R M\n  let π : Free.ChooseBasisIndex R M → (Set.finite_range (l ∘ b)).toFinset :=\n    fun i ↦ ⟨l (b i), by simp⟩\n  have : π.Surjective := fun ⟨x, hx⟩ ↦ by\n    obtain ⟨y, rfl⟩ : ∃ a, l (b a) = x := by simpa using hx\n    exact ⟨y, rfl⟩\n  choose σ hσ using this\n  have hπ : Subtype.val ∘ π = l ∘ b := rfl\n  have hσ₁ : π ∘ σ = id := by ext i; exact congr_arg Subtype.val (hσ i)\n  have hσ₂ : l ∘ b ∘ σ = Subtype.val := by ext i; exact congr_arg Subtype.val (hσ i)\n  refine ⟨(Set.finite_range (l ∘ b)).toFinset,\n    by simpa [Set.range_comp, LinearMap.range_eq_top], ?_⟩\n  let f : M →ₗ[R] (Set.finite_range (l ∘ b)).toFinset →₀ R :=\n    Finsupp.lmapDomain _ _ π ∘ₗ b.repr.toLinearMap\n  convert hl'.map f\n  ext x; simp only [LinearMap.mem_ker, Submodule.mem_map]\n  constructor\n  · intro hx\n    refine ⟨b.repr.symm (x.mapDomain σ), ?_, ?_⟩\n    · simp [Finsupp.apply_linearCombination, hσ₂, hx]\n    · simp only [f, LinearMap.comp_apply, b.repr.apply_symm_apply,\n        LinearEquiv.coe_toLinearMap, Finsupp.lmapDomain_apply]\n      rw [← Finsupp.mapDomain_comp, hσ₁, Finsupp.mapDomain_id]\n  · rintro ⟨y, hy, rfl⟩\n    simp [f, hπ, ← Finsupp.apply_linearCombination, hy]\n\n-- Ideally this should be an instance but it makes mathlib much slower.\n"}
{"name":"Module.finitePresentation_of_projective","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Projective R M\ninst✝ : Module.Finite R M\n⊢ Module.FinitePresentation R M","decl":"variable (R M) in\nlemma Module.finitePresentation_of_projective [Projective R M] [Module.Finite R M] :\n    FinitePresentation R M :=\n  have ⟨_n, _f, _g, surj, _, hfg⟩ := Finite.exists_comp_eq_id_of_projective R M\n  Module.finitePresentation_of_free_of_surjective _ surj\n    (Finite.iff_fg.mp <| LinearMap.ker_eq_range_of_comp_eq_id hfg ▸ inferInstance)\n\n"}
{"name":"Module.finitePresentation_of_free","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : Module.Projective R M\ninst✝ : Module.Finite R M\n⊢ Module.FinitePresentation R M","decl":"@[deprecated (since := \"2024-11-06\")]\nalias Module.finitePresentation_of_free := Module.finitePresentation_of_projective\n\n"}
{"name":"instFinitePresentation","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\ninst✝ : Ring R\n⊢ Module.FinitePresentation R R","decl":"instance : Module.FinitePresentation R R := Module.finitePresentation_of_projective _ _\n"}
{"name":"instFinitePresentationFinsupp","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nι : Type u_2\ninst✝ : Finite ι\n⊢ Module.FinitePresentation R (Finsupp ι R)","decl":"instance : Module.FinitePresentation R (ι →₀ R) := Module.finitePresentation_of_projective _ _\n"}
{"name":"instFinitePresentationForall","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\ninst✝¹ : Ring R\nι : Type u_2\ninst✝ : Finite ι\n⊢ Module.FinitePresentation R (ι → R)","decl":"instance : Module.FinitePresentation R (ι → R) := Module.finitePresentation_of_projective _ _\n\n"}
{"name":"Module.finitePresentation_of_surjective","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁴ : Ring R\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\nh : Module.FinitePresentation R M\nl : LinearMap (RingHom.id R) M N\nhl : Function.Surjective ⇑l\nhl' : (LinearMap.ker l).FG\n⊢ Module.FinitePresentation R N","decl":"lemma Module.finitePresentation_of_surjective [h : Module.FinitePresentation R M] (l : M →ₗ[R] N)\n    (hl : Function.Surjective l) (hl' : (LinearMap.ker l).FG) :\n    Module.FinitePresentation R N := by\n  classical\n  obtain ⟨s, hs, hs'⟩ := h\n  obtain ⟨t, ht⟩ := hl'\n  have H : Function.Surjective (Finsupp.linearCombination R ((↑) : s → M)) :=\n    LinearMap.range_eq_top.mp\n      (by rw [range_linearCombination, Subtype.range_val, ← hs]; rfl)\n  apply Module.finitePresentation_of_free_of_surjective (l ∘ₗ linearCombination R Subtype.val)\n    (hl.comp H)\n  choose σ hσ using (show _ from H)\n  have : Finsupp.linearCombination R Subtype.val '' (σ '' t) = t := by\n    simp only [Set.image_image, hσ, Set.image_id']\n  rw [LinearMap.ker_comp, ← ht, ← this, ← Submodule.map_span, Submodule.comap_map_eq,\n    ← Finset.coe_image]\n  exact Submodule.FG.sup ⟨_, rfl⟩ hs'\n\n"}
{"name":"Module.FinitePresentation.fg_ker","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.Finite R M\nh : Module.FinitePresentation R N\nl : LinearMap (RingHom.id R) M N\nhl : Function.Surjective ⇑l\n⊢ (LinearMap.ker l).FG","decl":"lemma Module.FinitePresentation.fg_ker [Module.Finite R M]\n    [h : Module.FinitePresentation R N] (l : M →ₗ[R] N) (hl : Function.Surjective l) :\n    (LinearMap.ker l).FG := by\n  classical\n  obtain ⟨s, hs, hs'⟩ := h\n  have H : Function.Surjective (Finsupp.linearCombination R ((↑) : s → N)) :=\n    LinearMap.range_eq_top.mp\n      (by rw [range_linearCombination, Subtype.range_val, ← hs]; rfl)\n  obtain ⟨f, hf⟩ : ∃ f : (s →₀ R) →ₗ[R] M, l ∘ₗ f = (Finsupp.linearCombination R Subtype.val) := by\n    choose f hf using show _ from hl\n    exact ⟨Finsupp.linearCombination R (fun i ↦ f i), by ext; simp [hf]⟩\n  have : (LinearMap.ker l).map (LinearMap.range f).mkQ = ⊤ := by\n    rw [← top_le_iff]\n    rintro x -\n    obtain ⟨x, rfl⟩ := Submodule.mkQ_surjective _ x\n    obtain ⟨y, hy⟩ := H (l x)\n    rw [← hf, LinearMap.comp_apply, eq_comm, ← sub_eq_zero, ← map_sub] at hy\n    exact ⟨_, hy, by simp⟩\n  apply Submodule.fg_of_fg_map_of_fg_inf_ker f.range.mkQ\n  · rw [this]\n    exact Module.Finite.fg_top\n  · rw [Submodule.ker_mkQ, inf_comm, ← Submodule.map_comap_eq, ← LinearMap.ker_comp, hf]\n    exact hs'.map f\n\n"}
{"name":"Module.FinitePresentation.fg_ker_iff","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\ninst✝⁵ : Ring R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\ninst✝ : Module.FinitePresentation R M\nl : LinearMap (RingHom.id R) M N\nhl : Function.Surjective ⇑l\n⊢ Iff (LinearMap.ker l).FG (Module.FinitePresentation R N)","decl":"lemma Module.FinitePresentation.fg_ker_iff [Module.FinitePresentation R M]\n    (l : M →ₗ[R] N) (hl : Function.Surjective l) :\n    Submodule.FG (LinearMap.ker l) ↔ Module.FinitePresentation R N :=\n  ⟨finitePresentation_of_surjective l hl, fun _ ↦ fg_ker l hl⟩\n\n"}
{"name":"Module.finitePresentation_of_ker","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_3\nN : Type u_2\ninst✝⁶ : Ring R\ninst✝⁵ : AddCommGroup M\ninst✝⁴ : Module R M\ninst✝³ : AddCommGroup N\ninst✝² : Module R N\ninst✝¹ : Module.FinitePresentation R N\nl : LinearMap (RingHom.id R) M N\nhl : Function.Surjective ⇑l\ninst✝ : Module.FinitePresentation R (Subtype fun x => Membership.mem (LinearMap.ker l) x)\n⊢ Module.FinitePresentation R M","decl":"lemma Module.finitePresentation_of_ker [Module.FinitePresentation R N]\n    (l : M →ₗ[R] N) (hl : Function.Surjective l) [Module.FinitePresentation R (LinearMap.ker l)] :\n    Module.FinitePresentation R M := by\n  obtain ⟨s, hs⟩ : (⊤ : Submodule R M).FG := by\n    apply Submodule.fg_of_fg_map_of_fg_inf_ker l\n    · rw [Submodule.map_top, LinearMap.range_eq_top.mpr hl]; exact Module.Finite.fg_top\n    · rw [top_inf_eq, ← Submodule.fg_top]; exact Module.Finite.fg_top\n  refine ⟨s, hs, ?_⟩\n  let π := Finsupp.linearCombination R ((↑) : s → M)\n  have H : Function.Surjective π :=\n    LinearMap.range_eq_top.mp\n      (by rw [range_linearCombination, Subtype.range_val, ← hs]; rfl)\n  have inst : Module.Finite R (LinearMap.ker (l ∘ₗ π)) := by\n    constructor\n    rw [Submodule.fg_top]; exact Module.FinitePresentation.fg_ker _ (hl.comp H)\n  letI : AddCommGroup (LinearMap.ker (l ∘ₗ π)) := inferInstance\n  let f : LinearMap.ker (l ∘ₗ π) →ₗ[R] LinearMap.ker l := LinearMap.restrict π (fun x ↦ id)\n  have e : π ∘ₗ Submodule.subtype _ = Submodule.subtype _ ∘ₗ f := by ext; rfl\n  have hf : Function.Surjective f := by\n    rw [← LinearMap.range_eq_top]\n    apply Submodule.map_injective_of_injective (Submodule.injective_subtype _)\n    rw [Submodule.map_top, Submodule.range_subtype, ← LinearMap.range_comp, ← e,\n      LinearMap.range_comp, Submodule.range_subtype, LinearMap.ker_comp,\n      Submodule.map_comap_eq_of_surjective H]\n  show (LinearMap.ker π).FG\n  have : LinearMap.ker π ≤ LinearMap.ker (l ∘ₗ π) :=\n    Submodule.comap_mono (f := π) (bot_le (a := LinearMap.ker l))\n  rw [← inf_eq_right.mpr this, ← Submodule.range_subtype (LinearMap.ker _),\n    ← Submodule.map_comap_eq, ← LinearMap.ker_comp, e, LinearMap.ker_comp f,\n    LinearMap.ker_eq_bot.mpr (Submodule.injective_subtype (LinearMap.ker l)), Submodule.comap_bot]\n  exact (Module.FinitePresentation.fg_ker f hf).map (Submodule.subtype _)\n\n"}
{"name":"Module.finitePresentation_of_split_exact","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_2\nM : Type u_4\nN : Type u_3\ninst✝⁷ : Ring R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\nP : Type u_1\ninst✝² : AddCommGroup P\ninst✝¹ : Module R P\ninst✝ : Module.FinitePresentation R N\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nl : LinearMap (RingHom.id R) P N\nhl : Eq (g.comp l) LinearMap.id\nhf : Function.Injective ⇑f\nH : Function.Exact ⇑f ⇑g\n⊢ Module.FinitePresentation R M","decl":"/-- Given a split exact sequence `0 → M → N → P → 0` with `N` finitely presented,\nthen `M` is also finitely presented. -/\nlemma Module.finitePresentation_of_split_exact\n    {P : Type*} [AddCommGroup P] [Module R P]\n    [Module.FinitePresentation R N]\n    (f : M →ₗ[R] N) (g : N →ₗ[R] P) (l : P →ₗ[R] N) (hl : g ∘ₗ l = .id)\n    (hf : Function.Injective f) (H : Function.Exact f g) :\n    Module.FinitePresentation R M := by\n  have hg : Function.Surjective g := Function.LeftInverse.surjective (DFunLike.congr_fun hl)\n  have := Module.Finite.of_surjective g hg\n  obtain ⟨e, rfl, rfl⟩ := ((Function.Exact.split_tfae' H).out 0 2 rfl rfl).mp\n    ⟨hf, l, hl⟩\n  refine Module.finitePresentation_of_surjective (LinearMap.fst _ _ _ ∘ₗ e.toLinearMap)\n    (Prod.fst_surjective.comp e.surjective) ?_\n  rw [LinearMap.ker_comp, Submodule.comap_equiv_eq_map_symm,\n    LinearMap.exact_iff.mp Function.Exact.inr_fst, ← Submodule.map_top]\n  exact .map _ (.map _ (Module.Finite.fg_top))\n\n"}
{"name":"Module.finitePresentation_of_projective_of_exact","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_2\nM : Type u_4\nN : Type u_3\ninst✝⁸ : Ring R\ninst✝⁷ : AddCommGroup M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommGroup N\ninst✝⁴ : Module R N\nP : Type u_1\ninst✝³ : AddCommGroup P\ninst✝² : Module R P\ninst✝¹ : Module.FinitePresentation R N\ninst✝ : Module.Projective R P\nf : LinearMap (RingHom.id R) M N\ng : LinearMap (RingHom.id R) N P\nhf : Function.Injective ⇑f\nhg : Function.Surjective ⇑g\nH : Function.Exact ⇑f ⇑g\n⊢ Module.FinitePresentation R M","decl":"/-- Given an exact sequence `0 → M → N → P → 0`\nwith `N` finitely presented and `P` projective, then `M` is also finitely presented. -/\nlemma Module.finitePresentation_of_projective_of_exact\n    {P : Type*} [AddCommGroup P] [Module R P]\n    [Module.FinitePresentation R N] [Module.Projective R P]\n    (f : M →ₗ[R] N) (g : N →ₗ[R] P)\n    (hf : Function.Injective f) (hg : Function.Surjective g) (H : Function.Exact f g) :\n    Module.FinitePresentation R M :=\n  have ⟨l, hl⟩ := Module.projective_lifting_property g .id hg\n  Module.finitePresentation_of_split_exact f g l hl hf H\n\n"}
{"name":"instFinitePresentationTensorProduct","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_2\nM : Type u_3\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\nA : Type u_1\ninst✝² : CommRing A\ninst✝¹ : Algebra R A\ninst✝ : Module.FinitePresentation R M\n⊢ Module.FinitePresentation A (TensorProduct R A M)","decl":"open TensorProduct in\ninstance {A} [CommRing A] [Algebra R A] [Module.FinitePresentation R M] :\n    Module.FinitePresentation A (A ⊗[R] M) := by\n  classical\n  obtain ⟨n, f, hf⟩ := Module.Finite.exists_fin' R M\n  have inst := Module.finitePresentation_of_projective A (A ⊗[R] (Fin n → R))\n  apply Module.finitePresentation_of_surjective (f.baseChange A)\n    (LinearMap.lTensor_surjective A hf)\n  have : Function.Exact ((LinearMap.ker f).subtype.baseChange A) (f.baseChange A) :=\n    lTensor_exact A f.exact_subtype_ker_map hf\n  rw [LinearMap.exact_iff] at this\n  rw [this, ← Submodule.map_top]\n  apply Submodule.FG.map\n  have : Module.Finite R (LinearMap.ker f) :=\n    ⟨(Submodule.fg_top _).mpr (Module.FinitePresentation.fg_ker f hf)⟩\n  exact Module.Finite.fg_top (R := A) (M := A ⊗[R] LinearMap.ker f)\n\n"}
{"name":"FinitePresentation.of_isBaseChange","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_2\nM : Type u_4\nN : Type u_3\ninst✝⁹ : CommRing R\ninst✝⁸ : AddCommGroup M\ninst✝⁷ : Module R M\ninst✝⁶ : AddCommGroup N\ninst✝⁵ : Module R N\nA : Type u_1\ninst✝⁴ : CommRing A\ninst✝³ : Algebra R A\ninst✝² : Module A N\ninst✝¹ : IsScalarTower R A N\nf : LinearMap (RingHom.id R) M N\nh : IsBaseChange A f\ninst✝ : Module.FinitePresentation R M\n⊢ Module.FinitePresentation A N","decl":"open TensorProduct in\nlemma FinitePresentation.of_isBaseChange\n    {A} [CommRing A] [Algebra R A] [Module A N] [IsScalarTower R A N]\n    (f : M →ₗ[R] N) (h : IsBaseChange A f) [Module.FinitePresentation R M] :\n    Module.FinitePresentation A N :=\n  Module.finitePresentation_of_surjective\n    h.equiv.toLinearMap h.equiv.surjective (by simpa using Submodule.fg_bot)\n\n"}
{"name":"instFinitePresentationLocalizationLocalizedModule","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : CommRing R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\nS : Submonoid R\ninst✝ : Module.FinitePresentation R M\n⊢ Module.FinitePresentation (Localization S) (LocalizedModule S M)","decl":"open TensorProduct in\ninstance (S : Submonoid R) [Module.FinitePresentation R M] :\n    Module.FinitePresentation (Localization S) (LocalizedModule S M) :=\n  FinitePresentation.of_isBaseChange (LocalizedModule.mkLinearMap S M)\n    ((isLocalizedModule_iff_isBaseChange S _ _).mp inferInstance)\n\n"}
{"name":"Module.FinitePresentation.exists_lift_of_isLocalizedModule","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_4\nN' : Type u_3\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nS : Submonoid R\nf : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S f\nh : Module.FinitePresentation R M\ng : LinearMap (RingHom.id R) M N'\n⊢ Exists fun h => Exists fun s => Eq (f.comp h) (HSMul.hSMul s g)","decl":"lemma Module.FinitePresentation.exists_lift_of_isLocalizedModule\n    [h : Module.FinitePresentation R M] (g : M →ₗ[R] N') :\n    ∃ (h : M →ₗ[R] N) (s : S), f ∘ₗ h = s • g := by\n  obtain ⟨σ, hσ, τ, hτ⟩ := h\n  let π := Finsupp.linearCombination R ((↑) : σ → M)\n  have hπ : Function.Surjective π :=\n    LinearMap.range_eq_top.mp\n      (by rw [range_linearCombination, Subtype.range_val, ← hσ]; rfl)\n  classical\n  choose s hs using IsLocalizedModule.surj S f\n  let i : σ → N :=\n    fun x ↦ (∏ j ∈ σ.erase x.1, (s (g j)).2) • (s (g x)).1\n  let s₀ := ∏ j ∈ σ, (s (g j)).2\n  have hi : f ∘ₗ Finsupp.linearCombination R i = (s₀ • g) ∘ₗ π := by\n    ext j\n    simp only [LinearMap.coe_comp, Function.comp_apply, Finsupp.lsingle_apply,\n      linearCombination_single, one_smul, LinearMap.map_smul_of_tower, ← hs, LinearMap.smul_apply,\n      i, s₀, π]\n    rw [← mul_smul, Finset.prod_erase_mul]\n    exact j.prop\n  have : ∀ x : τ, ∃ s : S, s • (Finsupp.linearCombination R i x) = 0 := by\n    intros x\n    convert_to ∃ s : S, s • (Finsupp.linearCombination R i x) = s • 0\n    · simp only [smul_zero]\n    apply IsLocalizedModule.exists_of_eq (S := S) (f := f)\n    rw [← LinearMap.comp_apply, map_zero, hi, LinearMap.comp_apply]\n    convert map_zero (s₀ • g)\n    rw [← LinearMap.mem_ker, ← hτ]\n    exact Submodule.subset_span x.prop\n  choose s' hs' using this\n  let s₁ := ∏ i : τ, s' i\n  have : LinearMap.ker π ≤ LinearMap.ker (s₁ • Finsupp.linearCombination R i) := by\n    rw [← hτ, Submodule.span_le]\n    intro x hxσ\n    simp only [s₁]\n    rw [SetLike.mem_coe, LinearMap.mem_ker, LinearMap.smul_apply,\n      ← Finset.prod_erase_mul _ _ (Finset.mem_univ ⟨x, hxσ⟩), mul_smul]\n    convert smul_zero _\n    exact hs' ⟨x, hxσ⟩\n  refine ⟨Submodule.liftQ _ _ this ∘ₗ\n    (LinearMap.quotKerEquivOfSurjective _ hπ).symm.toLinearMap, s₁ * s₀, ?_⟩\n  ext x\n  obtain ⟨x, rfl⟩ := hπ x\n  rw [← LinearMap.comp_apply, ← LinearMap.comp_apply, mul_smul, LinearMap.smul_comp, ← hi,\n    ← LinearMap.comp_smul, LinearMap.comp_assoc, LinearMap.comp_assoc]\n  congr 2\n  convert Submodule.liftQ_mkQ _ _ this using 2\n  ext x\n  apply (LinearMap.quotKerEquivOfSurjective _ hπ).injective\n  simp [LinearMap.quotKerEquivOfSurjective]\n\n"}
{"name":"Module.Finite.exists_smul_of_comp_eq_of_isLocalizedModule","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_1\nM : Type u_2\nN : Type u_3\nN' : Type u_4\ninst✝⁷ : CommRing R\ninst✝⁶ : AddCommGroup M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommGroup N\ninst✝³ : Module R N\ninst✝² : AddCommGroup N'\ninst✝¹ : Module R N'\nS : Submonoid R\nf : LinearMap (RingHom.id R) N N'\ninst✝ : IsLocalizedModule S f\nhM : Module.Finite R M\ng₁ g₂ : LinearMap (RingHom.id R) M N\nh : Eq (f.comp g₁) (f.comp g₂)\n⊢ Exists fun s => Eq (HSMul.hSMul s g₁) (HSMul.hSMul s g₂)","decl":"lemma Module.Finite.exists_smul_of_comp_eq_of_isLocalizedModule\n    [hM : Module.Finite R M] (g₁ g₂ : M →ₗ[R] N) (h : f.comp g₁ = f.comp g₂) :\n    ∃ (s : S), s • g₁ = s • g₂ := by\n  classical\n  have : ∀ x, ∃ s : S, s • g₁ x = s • g₂ x := fun x ↦\n    IsLocalizedModule.exists_of_eq (S := S) (f := f) (LinearMap.congr_fun h x)\n  choose s hs using this\n  obtain ⟨σ, hσ⟩ := hM\n  use σ.prod s\n  rw [← sub_eq_zero, ← LinearMap.ker_eq_top, ← top_le_iff, ← hσ, Submodule.span_le]\n  intro x hx\n  simp only [SetLike.mem_coe, LinearMap.mem_ker, LinearMap.sub_apply, LinearMap.smul_apply,\n    sub_eq_zero, ← Finset.prod_erase_mul σ s hx, mul_smul, hs]\n\n"}
{"name":"exists_bijective_map_powers","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nS : Submonoid R\nM' : Type u_1\ninst✝⁷ : AddCommGroup M'\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN' : Type u_2\ninst✝⁴ : AddCommGroup N'\ninst✝³ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝² : IsLocalizedModule S g\ninst✝¹ : Module.Finite R M\ninst✝ : Module.FinitePresentation R N\nl : LinearMap (RingHom.id R) M N\nhf : Function.Bijective ⇑((IsLocalizedModule.map S f g) l)\n⊢ Exists fun r => And (Membership.mem S r) (∀ (t : R), Dvd.dvd r t → Function.Bijective ⇑((LocalizedModule.map (Submonoid.powers t)) l))","decl":"/--\nLet `M` be a finite `R`-module, and `N` be a finitely presented `R`-module.\nIf `l : M →ₗ[R] N` is a linear map whose localization at `S : Submonoid R` is bijective,\nthen `l` is already bijective under the localization at some `r ∈ S`.\n-/\nlemma exists_bijective_map_powers [Module.Finite R M] [Module.FinitePresentation R N]\n    (l : M →ₗ[R] N) (hf : Function.Bijective (IsLocalizedModule.map S f g l)) :\n    ∃ r, r ∈ S ∧ ∀ t, r ∣ t → Function.Bijective (LocalizedModule.map (.powers t) l) := by\n  let e : M' ≃ₗ[R] N' := LinearEquiv.ofBijective _ hf\n  obtain ⟨l', s₀, H⟩ := Module.FinitePresentation.exists_lift_of_isLocalizedModule S f\n    (e.symm.toLinearMap.comp g)\n  have H₁ : g ∘ₗ l ∘ₗ l' = g ∘ₗ (s₀ • LinearMap.id) := by\n    ext a; simpa [-EmbeddingLike.apply_eq_iff_eq, e] using congr(e ($H a))\n  obtain ⟨s₁, hs₁⟩ := Module.Finite.exists_smul_of_comp_eq_of_isLocalizedModule S g _ _ H₁\n  have H₂ : f ∘ₗ l' ∘ₗ l = f ∘ₗ (s₀ • LinearMap.id) := by\n    rw [← LinearMap.comp_assoc, H, LinearMap.smul_comp, LinearMap.comp_assoc,\n      ← IsLocalizedModule.map_comp S f g l, ← LinearMap.comp_assoc]\n    show s₀ • (e.symm.toLinearMap ∘ₗ e.toLinearMap) ∘ₗ _ = _\n    simp [LinearMap.comp_smul]\n  obtain ⟨s₂, hs₂⟩ := Module.Finite.exists_smul_of_comp_eq_of_isLocalizedModule S f _ _ H₂\n  refine ⟨s₀ * s₁ * s₂, (s₀ * s₁ * s₂).2, fun t ht ↦ ?_⟩\n  let Rₛ := Localization (.powers t)\n  let lₛ := LocalizedModule.map (.powers t) l\n  have hu₀ : IsUnit (algebraMap R Rₛ s₀) := isUnit_of_dvd_unit\n      (hu := IsLocalization.map_units (M := .powers t) Rₛ ⟨t, Submonoid.mem_powers t⟩)\n      (map_dvd (algebraMap R Rₛ) (dvd_trans ⟨s₁ * s₂, by simp [mul_assoc]⟩ ht))\n  have hu₁ : IsUnit (algebraMap R Rₛ s₁) := isUnit_of_dvd_unit\n      (hu := IsLocalization.map_units (M := .powers t) Rₛ ⟨t, Submonoid.mem_powers t⟩)\n      (map_dvd (algebraMap R Rₛ) (dvd_trans ⟨s₀ * s₂, by ring⟩ ht))\n  have hu₂ : IsUnit (algebraMap R Rₛ s₂) := isUnit_of_dvd_unit\n      (hu := IsLocalization.map_units (M := .powers t) Rₛ ⟨t, Submonoid.mem_powers t⟩)\n      (map_dvd (algebraMap R Rₛ) (dvd_trans ⟨s₀ * s₁, by ring⟩ ht))\n  let lₛ' := LocalizedModule.map (.powers t) l'\n  have H_left : ((hu₀.unit⁻¹).1 • lₛ') ∘ₗ lₛ = LinearMap.id := by\n    apply ((Module.End_isUnit_iff _).mp (hu₂.map (algebraMap Rₛ (Module.End Rₛ _)))).1\n    apply ((Module.End_isUnit_iff _).mp (hu₀.map (algebraMap Rₛ (Module.End Rₛ _)))).1\n    simp only [Module.algebraMap_end_apply, algebraMap_smul, LinearMap.map_smul_of_tower]\n    rw [LinearMap.smul_comp, ← smul_assoc s₀.1, Algebra.smul_def s₀.1, IsUnit.mul_val_inv, one_smul]\n    apply LinearMap.restrictScalars_injective R\n    apply IsLocalizedModule.ext (.powers t) (LocalizedModule.mkLinearMap (.powers t) M)\n      (IsLocalizedModule.map_units (LocalizedModule.mkLinearMap (.powers t) M))\n    ext x\n    have : s₂.1 • l' (l x) = s₂.1 • s₀.1 • x := congr($hs₂ x)\n    simp [lₛ, lₛ', LocalizedModule.smul'_mk, this]\n  have H_right : lₛ ∘ₗ ((hu₀.unit⁻¹).1 • lₛ') = LinearMap.id := by\n    apply ((Module.End_isUnit_iff _).mp (hu₁.map (algebraMap Rₛ (Module.End Rₛ _)))).1\n    apply ((Module.End_isUnit_iff _).mp (hu₀.map (algebraMap Rₛ (Module.End Rₛ _)))).1\n    simp only [Module.algebraMap_end_apply, algebraMap_smul, LinearMap.map_smul_of_tower]\n    rw [LinearMap.comp_smul, ← smul_assoc s₀.1, Algebra.smul_def s₀.1, IsUnit.mul_val_inv, one_smul]\n    apply LinearMap.restrictScalars_injective R\n    apply IsLocalizedModule.ext (.powers t) (LocalizedModule.mkLinearMap (.powers t) N)\n      (IsLocalizedModule.map_units (LocalizedModule.mkLinearMap (.powers t) N))\n    ext x\n    have : s₁.1 • l (l' x) = s₁.1 • s₀.1 • x := congr($hs₁ x)\n    simp [lₛ, lₛ', LocalizedModule.smul'_mk, this]\n  let eₛ : LocalizedModule (.powers t) M ≃ₗ[Rₛ] LocalizedModule (.powers t) N :=\n    { __ := lₛ,\n      invFun := ((hu₀.unit⁻¹).1 • lₛ'),\n      left_inv := fun x ↦ congr($H_left x),\n      right_inv := fun x ↦ congr($H_right x) }\n  exact eₛ.bijective\n\n"}
{"name":"Module.FinitePresentation.exists_lift_equiv_of_isLocalizedModule","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹² : CommRing R\ninst✝¹¹ : AddCommGroup M\ninst✝¹⁰ : Module R M\ninst✝⁹ : AddCommGroup N\ninst✝⁸ : Module R N\nS : Submonoid R\nM' : Type u_1\ninst✝⁷ : AddCommGroup M'\ninst✝⁶ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁵ : IsLocalizedModule S f\nN' : Type u_2\ninst✝⁴ : AddCommGroup N'\ninst✝³ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝² : IsLocalizedModule S g\ninst✝¹ : Module.FinitePresentation R M\ninst✝ : Module.FinitePresentation R N\nl : LinearEquiv (RingHom.id R) M' N'\n⊢ Exists fun r => Exists fun hr => Exists fun l' => Eq ((LocalizedModule.lift (Submonoid.powers r) g ⋯).comp (↑R ↑l')) ((↑l).comp (LocalizedModule.lift (Submonoid.powers r) f ⋯))","decl":"open IsLocalizedModule in\n/--\nLet `M` `N` be a finitely presented `R`-modules.\nAny `Mₛ ≃ₗ[R] Nₛ` between the localizations at `S : Submonoid R` can be lifted to an\nisomorphism between `Mᵣ ≃ₗ[R] Nᵣ` for some `r ∈ S`.\n-/\nlemma Module.FinitePresentation.exists_lift_equiv_of_isLocalizedModule\n    [Module.FinitePresentation R M] [Module.FinitePresentation R N]\n    (l : M' ≃ₗ[R] N') :\n    ∃ (r : R) (hr : r ∈ S)\n      (l' : LocalizedModule (.powers r) M ≃ₗ[Localization (.powers r)]\n        LocalizedModule (.powers r) N),\n      (LocalizedModule.lift (.powers r) g fun s ↦ map_units g ⟨s.1, SetLike.le_def.mp\n        (Submonoid.powers_le.mpr hr) s.2⟩) ∘ₗ l'.toLinearMap =\n        l ∘ₗ (LocalizedModule.lift (.powers r) f fun s ↦ map_units f ⟨s.1, SetLike.le_def.mp\n        (Submonoid.powers_le.mpr hr) s.2⟩) := by\n  obtain ⟨l', s, H⟩ := Module.FinitePresentation.exists_lift_of_isLocalizedModule S g (l ∘ₗ f)\n  have : Function.Bijective (IsLocalizedModule.map S f g l') := by\n    have : IsLocalizedModule.map S f g l' = (s • LinearMap.id) ∘ₗ l := by\n      apply IsLocalizedModule.ext S f (IsLocalizedModule.map_units g)\n      apply LinearMap.ext fun x ↦ ?_\n      simp only [LinearMap.coe_comp, Function.comp_apply, IsLocalizedModule.map_apply,\n        Basis.coe_repr_symm, LinearMap.coe_restrictScalars]\n      rw [← LinearMap.comp_apply, H]\n      simp\n    rw [this]\n    exact ((Module.End_isUnit_iff _).mp (IsLocalizedModule.map_units g s)).comp l.bijective\n  obtain ⟨r, hr, hr'⟩ := exists_bijective_map_powers S f g _ this\n  let rs : Submonoid R := (.powers <| r * s)\n  let Rᵣₛ := Localization rs\n  have hsu : IsUnit (algebraMap R Rᵣₛ s) := isUnit_of_dvd_unit\n      (hu := IsLocalization.map_units (M := rs) Rᵣₛ ⟨_, Submonoid.mem_powers _⟩)\n      (map_dvd (algebraMap R Rᵣₛ) ⟨r, mul_comm _ _⟩)\n  have : Function.Bijective ((hsu.unit⁻¹).1 • LocalizedModule.map rs l') :=\n    ((Module.End_isUnit_iff _).mp ((hsu.unit⁻¹).isUnit.map (algebraMap _ (End Rᵣₛ\n      (LocalizedModule rs N))))).comp (hr' (r * s) (dvd_mul_right _ _))\n  refine ⟨r * s, mul_mem hr s.2, LinearEquiv.ofBijective _ this, ?_⟩\n  apply IsLocalizedModule.ext rs (LocalizedModule.mkLinearMap rs M) fun x ↦ map_units g\n    ⟨x.1, SetLike.le_def.mp (Submonoid.powers_le.mpr (mul_mem hr s.2)) x.2⟩\n  ext x\n  apply ((Module.End_isUnit_iff _).mp (IsLocalizedModule.map_units g s)).1\n  have : ∀ x, g (l' x) = s.1 • (l (f x)) := LinearMap.congr_fun H\n  simp only [rs, LinearMap.coe_comp, LinearMap.coe_restrictScalars, LinearEquiv.coe_coe,\n    Function.comp_apply, LocalizedModule.mkLinearMap_apply, LinearEquiv.ofBijective_apply,\n    LinearMap.smul_apply, LocalizedModule.map_mk, algebraMap_end_apply]\n  rw [← map_smul, ← smul_assoc, Algebra.smul_def s.1, hsu.mul_val_inv, one_smul]\n  simp only [LocalizedModule.lift_mk, OneMemClass.coe_one, map_one, IsUnit.unit_one,\n    inv_one, Units.val_one, LinearMap.one_apply, this]\n\n"}
{"name":"Module.FinitePresentation.isLocalizedModule_map","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝¹¹ : CommRing R\ninst✝¹⁰ : AddCommGroup M\ninst✝⁹ : Module R M\ninst✝⁸ : AddCommGroup N\ninst✝⁷ : Module R N\nS : Submonoid R\nM' : Type u_1\ninst✝⁶ : AddCommGroup M'\ninst✝⁵ : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝⁴ : IsLocalizedModule S f\nN' : Type u_2\ninst✝³ : AddCommGroup N'\ninst✝² : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝¹ : IsLocalizedModule S g\ninst✝ : Module.FinitePresentation R M\n⊢ IsLocalizedModule S (IsLocalizedModule.map S f g)","decl":"instance Module.FinitePresentation.isLocalizedModule_map [Module.FinitePresentation R M] :\n    IsLocalizedModule S (IsLocalizedModule.map S f g) := by\n  constructor\n  · intro s\n    rw [Module.End_isUnit_iff]\n    have := (Module.End_isUnit_iff _).mp (IsLocalizedModule.map_units (S := S) (f := g) s)\n    constructor\n    · exact fun _ _ e ↦ LinearMap.ext fun m ↦ this.left (LinearMap.congr_fun e m)\n    · intro h\n      use ((IsLocalizedModule.map_units (S := S) (f := g) s).unit⁻¹).1 ∘ₗ h\n      ext x\n      exact Module.End_isUnit_apply_inv_apply_of_isUnit\n        (IsLocalizedModule.map_units (S := S) (f := g) s) (h x)\n  · intro h\n    obtain ⟨h', s, e⟩ := Module.FinitePresentation.exists_lift_of_isLocalizedModule S g (h ∘ₗ f)\n    refine ⟨⟨h', s⟩, ?_⟩\n    apply IsLocalizedModule.ext S f (IsLocalizedModule.map_units g)\n    refine e.symm.trans (by ext; simp)\n  · intro h₁ h₂ e\n    apply Module.Finite.exists_smul_of_comp_eq_of_isLocalizedModule S g\n    ext x\n    simpa using LinearMap.congr_fun e (f x)\n\n"}
{"name":"Module.FinitePresentation.isLocalizedModule_mapExtendScalars","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_4\nM : Type u_5\nN : Type u_6\ninst✝¹⁸ : CommRing R\ninst✝¹⁷ : AddCommGroup M\ninst✝¹⁶ : Module R M\ninst✝¹⁵ : AddCommGroup N\ninst✝¹⁴ : Module R N\nS : Submonoid R\nM' : Type u_1\ninst✝¹³ : AddCommGroup M'\ninst✝¹² : Module R M'\nf : LinearMap (RingHom.id R) M M'\ninst✝¹¹ : IsLocalizedModule S f\nN' : Type u_2\ninst✝¹⁰ : AddCommGroup N'\ninst✝⁹ : Module R N'\ng : LinearMap (RingHom.id R) N N'\ninst✝⁸ : IsLocalizedModule S g\nRₛ : Type u_3\ninst✝⁷ : CommRing Rₛ\ninst✝⁶ : Algebra R Rₛ\ninst✝⁵ : Module Rₛ M'\ninst✝⁴ : Module Rₛ N'\ninst✝³ : IsScalarTower R Rₛ M'\ninst✝² : IsScalarTower R Rₛ N'\ninst✝¹ : IsLocalization S Rₛ\ninst✝ : Module.FinitePresentation R M\n⊢ IsLocalizedModule S (IsLocalizedModule.mapExtendScalars S f g Rₛ)","decl":"instance Module.FinitePresentation.isLocalizedModule_mapExtendScalars\n    (Rₛ) [CommRing Rₛ] [Algebra R Rₛ] [Module Rₛ M'] [Module Rₛ N']\n    [IsScalarTower R Rₛ M'] [IsScalarTower R Rₛ N'] [IsLocalization S Rₛ]\n    [Module.FinitePresentation R M] :\n      IsLocalizedModule S (IsLocalizedModule.mapExtendScalars S f g Rₛ) :=\n  IsLocalizedModule.of_linearEquiv _ _ _\n\n"}
{"name":"instIsLocalizedModuleLinearMapIdLocalizationLocalizedModuleMapOfFinitePresentation","module":"Mathlib.Algebra.Module.FinitePresentation","initialProofState":"R : Type u_3\nM : Type u_4\nN : Type u_5\ninst✝⁵ : CommRing R\ninst✝⁴ : AddCommGroup M\ninst✝³ : Module R M\ninst✝² : AddCommGroup N\ninst✝¹ : Module R N\nS : Submonoid R\ninst✝ : Module.FinitePresentation R M\n⊢ IsLocalizedModule S (LocalizedModule.map S)","decl":"instance [Module.FinitePresentation R M] :\n    IsLocalizedModule S (LocalizedModule.map S (M := M) (N := N)) :=\n  Module.FinitePresentation.isLocalizedModule_mapExtendScalars _ _ _ _\n\n"}
