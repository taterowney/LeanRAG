{"name":"EuclideanGeometry.continuousAt_angle","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nx : Prod P (Prod P P)\nhx12 : Ne x.1 x.2.1\nhx32 : Ne x.2.2 x.2.1\n⊢ ContinuousAt (fun y => EuclideanGeometry.angle y.1 y.2.1 y.2.2) x","decl":"theorem continuousAt_angle {x : P × P × P} (hx12 : x.1 ≠ x.2.1) (hx32 : x.2.2 ≠ x.2.1) :\n    ContinuousAt (fun y : P × P × P => ∠ y.1 y.2.1 y.2.2) x := by\n  let f : P × P × P → V × V := fun y => (y.1 -ᵥ y.2.1, y.2.2 -ᵥ y.2.1)\n  have hf1 : (f x).1 ≠ 0 := by simp [f, hx12]\n  have hf2 : (f x).2 ≠ 0 := by simp [f, hx32]\n  exact (InnerProductGeometry.continuousAt_angle hf1 hf2).comp\n    ((continuous_fst.vsub continuous_snd.fst).prod_mk\n      (continuous_snd.snd.vsub continuous_snd.fst)).continuousAt\n\n"}
{"name":"AffineIsometry.angle_map","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝⁷ : NormedAddCommGroup V\ninst✝⁶ : InnerProductSpace Real V\ninst✝⁵ : MetricSpace P\ninst✝⁴ : NormedAddTorsor V P\nV₂ : Type u_3\nP₂ : Type u_4\ninst✝³ : NormedAddCommGroup V₂\ninst✝² : InnerProductSpace Real V₂\ninst✝¹ : MetricSpace P₂\ninst✝ : NormedAddTorsor V₂ P₂\nf : AffineIsometry Real P P₂\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.angle (f p₁) (f p₂) (f p₃)) (EuclideanGeometry.angle p₁ p₂ p₃)","decl":"@[simp]\ntheorem _root_.AffineIsometry.angle_map {V₂ P₂ : Type*} [NormedAddCommGroup V₂]\n    [InnerProductSpace ℝ V₂] [MetricSpace P₂] [NormedAddTorsor V₂ P₂]\n    (f : P →ᵃⁱ[ℝ] P₂) (p₁ p₂ p₃ : P) : ∠ (f p₁) (f p₂) (f p₃) = ∠ p₁ p₂ p₃ := by\n  simp_rw [angle, ← AffineIsometry.map_vsub, LinearIsometry.angle_map]\n\n"}
{"name":"AffineSubspace.angle_coe","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\ns : AffineSubspace Real P\np₁ p₂ p₃ : Subtype fun x => Membership.mem s x\n⊢ Eq (EuclideanGeometry.angle ↑p₁ ↑p₂ ↑p₃) (EuclideanGeometry.angle p₁ p₂ p₃)","decl":"@[simp, norm_cast]\ntheorem _root_.AffineSubspace.angle_coe {s : AffineSubspace ℝ P} (p₁ p₂ p₃ : s) :\n    haveI : Nonempty s := ⟨p₁⟩\n    ∠ (p₁ : P) (p₂ : P) (p₃ : P) = ∠ p₁ p₂ p₃ :=\n  haveI : Nonempty s := ⟨p₁⟩\n  s.subtypeₐᵢ.angle_map p₁ p₂ p₃\n\n"}
{"name":"EuclideanGeometry.angle_const_vadd","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nv : V\np₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.angle (HVAdd.hVAdd v p₁) (HVAdd.hVAdd v p₂) (HVAdd.hVAdd v p₃)) (EuclideanGeometry.angle p₁ p₂ p₃)","decl":"/-- Angles are translation invariant -/\n@[simp]\ntheorem angle_const_vadd (v : V) (p₁ p₂ p₃ : P) : ∠ (v +ᵥ p₁) (v +ᵥ p₂) (v +ᵥ p₃) = ∠ p₁ p₂ p₃ :=\n  (AffineIsometryEquiv.constVAdd ℝ P v).toAffineIsometry.angle_map _ _ _\n\n"}
{"name":"EuclideanGeometry.angle_vadd_const","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\nv₁ v₂ v₃ : V\np : P\n⊢ Eq (EuclideanGeometry.angle (HVAdd.hVAdd v₁ p) (HVAdd.hVAdd v₂ p) (HVAdd.hVAdd v₃ p)) (EuclideanGeometry.angle v₁ v₂ v₃)","decl":"/-- Angles are translation invariant -/\n@[simp]\ntheorem angle_vadd_const (v₁ v₂ v₃ : V) (p : P) : ∠ (v₁ +ᵥ p) (v₂ +ᵥ p) (v₃ +ᵥ p) = ∠ v₁ v₂ v₃ :=\n  (AffineIsometryEquiv.vaddConst ℝ p).toAffineIsometry.angle_map _ _ _\n\n"}
{"name":"EuclideanGeometry.angle_const_vsub","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np p₁ p₂ p₃ : P\n⊢ Eq (EuclideanGeometry.angle (VSub.vsub p p₁) (VSub.vsub p p₂) (VSub.vsub p p₃)) (EuclideanGeometry.angle p₁ p₂ p₃)","decl":"/-- Angles are translation invariant -/\n@[simp]\ntheorem angle_const_vsub (p p₁ p₂ p₃ : P) : ∠ (p -ᵥ p₁) (p -ᵥ p₂) (p -ᵥ p₃) = ∠ p₁ p₂ p₃ :=\n  (AffineIsometryEquiv.constVSub ℝ p).toAffineIsometry.angle_map _ _ _\n\n"}
{"name":"EuclideanGeometry.angle_vsub_const","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ p : P\n⊢ Eq (EuclideanGeometry.angle (VSub.vsub p₁ p) (VSub.vsub p₂ p) (VSub.vsub p₃ p)) (EuclideanGeometry.angle p₁ p₂ p₃)","decl":"/-- Angles are translation invariant -/\n@[simp]\ntheorem angle_vsub_const (p₁ p₂ p₃ p : P) : ∠ (p₁ -ᵥ p) (p₂ -ᵥ p) (p₃ -ᵥ p) = ∠ p₁ p₂ p₃ :=\n  (AffineIsometryEquiv.vaddConst ℝ p).symm.toAffineIsometry.angle_map _ _ _\n\n"}
{"name":"EuclideanGeometry.angle_add_const","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nv₁ v₂ v₃ v : V\n⊢ Eq (EuclideanGeometry.angle (HAdd.hAdd v₁ v) (HAdd.hAdd v₂ v) (HAdd.hAdd v₃ v)) (EuclideanGeometry.angle v₁ v₂ v₃)","decl":"/-- Angles in a vector space are translation invariant -/\n@[simp]\ntheorem angle_add_const (v₁ v₂ v₃ : V) (v : V) : ∠ (v₁ + v) (v₂ + v) (v₃ + v) = ∠ v₁ v₂ v₃ :=\n  angle_vadd_const _ _ _ _\n\n"}
{"name":"EuclideanGeometry.angle_const_add","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nv v₁ v₂ v₃ : V\n⊢ Eq (EuclideanGeometry.angle (HAdd.hAdd v v₁) (HAdd.hAdd v v₂) (HAdd.hAdd v v₃)) (EuclideanGeometry.angle v₁ v₂ v₃)","decl":"/-- Angles in a vector space are translation invariant -/\n@[simp]\ntheorem angle_const_add (v : V) (v₁ v₂ v₃ : V) : ∠ (v + v₁) (v + v₂) (v + v₃) = ∠ v₁ v₂ v₃ :=\n  angle_const_vadd _ _ _ _\n\n"}
{"name":"EuclideanGeometry.angle_sub_const","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nv₁ v₂ v₃ v : V\n⊢ Eq (EuclideanGeometry.angle (HSub.hSub v₁ v) (HSub.hSub v₂ v) (HSub.hSub v₃ v)) (EuclideanGeometry.angle v₁ v₂ v₃)","decl":"/-- Angles in a vector space are translation invariant -/\n@[simp]\ntheorem angle_sub_const (v₁ v₂ v₃ : V) (v : V) : ∠ (v₁ - v) (v₂ - v) (v₃ - v) = ∠ v₁ v₂ v₃ := by\n  simpa only [vsub_eq_sub] using angle_vsub_const v₁ v₂ v₃ v\n\n"}
{"name":"EuclideanGeometry.angle_const_sub","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nv v₁ v₂ v₃ : V\n⊢ Eq (EuclideanGeometry.angle (HSub.hSub v v₁) (HSub.hSub v v₂) (HSub.hSub v v₃)) (EuclideanGeometry.angle v₁ v₂ v₃)","decl":"/-- Angles in a vector space are invariant to inversion -/\n@[simp]\ntheorem angle_const_sub (v : V) (v₁ v₂ v₃ : V) : ∠ (v - v₁) (v - v₂) (v - v₃) = ∠ v₁ v₂ v₃ := by\n  simpa only [vsub_eq_sub] using angle_const_vsub v v₁ v₂ v₃\n\n"}
{"name":"EuclideanGeometry.angle_neg","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\ninst✝¹ : NormedAddCommGroup V\ninst✝ : InnerProductSpace Real V\nv₁ v₂ v₃ : V\n⊢ Eq (EuclideanGeometry.angle (Neg.neg v₁) (Neg.neg v₂) (Neg.neg v₃)) (EuclideanGeometry.angle v₁ v₂ v₃)","decl":"/-- Angles in a vector space are invariant to inversion -/\n@[simp]\ntheorem angle_neg (v₁ v₂ v₃ : V) : ∠ (-v₁) (-v₂) (-v₃) = ∠ v₁ v₂ v₃ := by\n  simpa only [zero_sub] using angle_const_sub 0 v₁ v₂ v₃\n\n"}
{"name":"EuclideanGeometry.angle_comm","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\n⊢ Eq (EuclideanGeometry.angle p1 p2 p3) (EuclideanGeometry.angle p3 p2 p1)","decl":"/-- The angle at a point does not depend on the order of the other two\npoints. -/\nnonrec theorem angle_comm (p1 p2 p3 : P) : ∠ p1 p2 p3 = ∠ p3 p2 p1 :=\n  angle_comm _ _\n\n"}
{"name":"EuclideanGeometry.angle_nonneg","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\n⊢ LE.le 0 (EuclideanGeometry.angle p1 p2 p3)","decl":"/-- The angle at a point is nonnegative. -/\nnonrec theorem angle_nonneg (p1 p2 p3 : P) : 0 ≤ ∠ p1 p2 p3 :=\n  angle_nonneg _ _\n\n"}
{"name":"EuclideanGeometry.angle_le_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\n⊢ LE.le (EuclideanGeometry.angle p1 p2 p3) Real.pi","decl":"/-- The angle at a point is at most π. -/\nnonrec theorem angle_le_pi (p1 p2 p3 : P) : ∠ p1 p2 p3 ≤ π :=\n  angle_le_pi _ _\n\n"}
{"name":"EuclideanGeometry.angle_self_left","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₀ p : P\n⊢ Eq (EuclideanGeometry.angle p₀ p₀ p) (HDiv.hDiv Real.pi 2)","decl":"/-- The angle ∠AAB at a point is always `π / 2`. -/\n@[simp] lemma angle_self_left (p₀ p : P) : ∠ p₀ p₀ p = π / 2 := by\n  unfold angle\n  rw [vsub_self]\n  exact angle_zero_left _\n\n"}
{"name":"EuclideanGeometry.angle_self_right","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₀ p : P\n⊢ Eq (EuclideanGeometry.angle p p₀ p₀) (HDiv.hDiv Real.pi 2)","decl":"/-- The angle ∠ABB at a point is always `π / 2`. -/\n@[simp] lemma angle_self_right (p₀ p : P) : ∠ p p₀ p₀ = π / 2 := by rw [angle_comm, angle_self_left]\n\n"}
{"name":"EuclideanGeometry.angle_self_of_ne","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np p₀ : P\nh : Ne p p₀\n⊢ Eq (EuclideanGeometry.angle p p₀ p) 0","decl":"/-- The angle ∠ABA at a point is `0`, unless `A = B`. -/\ntheorem angle_self_of_ne (h : p ≠ p₀) : ∠ p p₀ p = 0 := angle_self <| vsub_ne_zero.2 h\n\n\n"}
{"name":"EuclideanGeometry.angle_eq_zero_of_angle_eq_pi_left","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) Real.pi\n⊢ Eq (EuclideanGeometry.angle p2 p1 p3) 0","decl":"/-- If the angle ∠ABC at a point is π, the angle ∠BAC is 0. -/\ntheorem angle_eq_zero_of_angle_eq_pi_left {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = π) : ∠ p2 p1 p3 = 0 := by\n  unfold angle at h\n  rw [angle_eq_pi_iff] at h\n  rcases h with ⟨hp1p2, ⟨r, ⟨hr, hpr⟩⟩⟩\n  unfold angle\n  rw [angle_eq_zero_iff]\n  rw [← neg_vsub_eq_vsub_rev, neg_ne_zero] at hp1p2\n  use hp1p2, -r + 1, add_pos (neg_pos_of_neg hr) zero_lt_one\n  rw [add_smul, ← neg_vsub_eq_vsub_rev p1 p2, smul_neg]\n  simp [← hpr]\n\n"}
{"name":"EuclideanGeometry.angle_eq_zero_of_angle_eq_pi_right","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) Real.pi\n⊢ Eq (EuclideanGeometry.angle p2 p3 p1) 0","decl":"/-- If the angle ∠ABC at a point is π, the angle ∠BCA is 0. -/\ntheorem angle_eq_zero_of_angle_eq_pi_right {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = π) :\n    ∠ p2 p3 p1 = 0 := by\n  rw [angle_comm] at h\n  exact angle_eq_zero_of_angle_eq_pi_left h\n\n"}
{"name":"EuclideanGeometry.angle_eq_angle_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 p4 : P\nh : Eq (EuclideanGeometry.angle p2 p3 p4) Real.pi\n⊢ Eq (EuclideanGeometry.angle p1 p2 p3) (EuclideanGeometry.angle p1 p2 p4)","decl":"/-- If ∠BCD = π, then ∠ABC = ∠ABD. -/\ntheorem angle_eq_angle_of_angle_eq_pi (p1 : P) {p2 p3 p4 : P} (h : ∠ p2 p3 p4 = π) :\n    ∠ p1 p2 p3 = ∠ p1 p2 p4 := by\n  unfold angle at *\n  rcases angle_eq_pi_iff.1 h with ⟨_, ⟨r, ⟨hr, hpr⟩⟩⟩\n  rw [eq_comm]\n  convert angle_smul_right_of_pos (p1 -ᵥ p2) (p3 -ᵥ p2) (add_pos (neg_pos_of_neg hr) zero_lt_one)\n  rw [add_smul, ← neg_vsub_eq_vsub_rev p2 p3, smul_neg, neg_smul, ← hpr]\n  simp\n\n"}
{"name":"EuclideanGeometry.angle_add_angle_eq_pi_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 p4 : P\nh : Eq (EuclideanGeometry.angle p2 p3 p4) Real.pi\n⊢ Eq (HAdd.hAdd (EuclideanGeometry.angle p1 p3 p2) (EuclideanGeometry.angle p1 p3 p4)) Real.pi","decl":"/-- If ∠BCD = π, then ∠ACB + ∠ACD = π. -/\nnonrec theorem angle_add_angle_eq_pi_of_angle_eq_pi (p1 : P) {p2 p3 p4 : P} (h : ∠ p2 p3 p4 = π) :\n    ∠ p1 p3 p2 + ∠ p1 p3 p4 = π := by\n  unfold angle at h\n  rw [angle_comm p1 p3 p2, angle_comm p1 p3 p4]\n  unfold angle\n  exact angle_add_angle_eq_pi_of_angle_eq_pi _ h\n\n"}
{"name":"EuclideanGeometry.angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 p4 p5 : P\nhapc : Eq (EuclideanGeometry.angle p1 p5 p3) Real.pi\nhbpd : Eq (EuclideanGeometry.angle p2 p5 p4) Real.pi\n⊢ Eq (EuclideanGeometry.angle p1 p5 p2) (EuclideanGeometry.angle p3 p5 p4)","decl":"/-- **Vertical Angles Theorem**: angles opposite each other, formed by two intersecting straight\nlines, are equal. -/\ntheorem angle_eq_angle_of_angle_eq_pi_of_angle_eq_pi {p1 p2 p3 p4 p5 : P} (hapc : ∠ p1 p5 p3 = π)\n    (hbpd : ∠ p2 p5 p4 = π) : ∠ p1 p5 p2 = ∠ p3 p5 p4 := by\n  linarith [angle_add_angle_eq_pi_of_angle_eq_pi p1 hbpd, angle_comm p4 p5 p1,\n    angle_add_angle_eq_pi_of_angle_eq_pi p4 hapc, angle_comm p4 p5 p3]\n\n"}
{"name":"EuclideanGeometry.left_dist_ne_zero_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) Real.pi\n⊢ Ne (Dist.dist p1 p2) 0","decl":"/-- If ∠ABC = π then dist A B ≠ 0. -/\ntheorem left_dist_ne_zero_of_angle_eq_pi {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = π) : dist p1 p2 ≠ 0 := by\n  by_contra heq\n  rw [dist_eq_zero] at heq\n  rw [heq, angle_self_left] at h\n  exact Real.pi_ne_zero (by linarith)\n\n"}
{"name":"EuclideanGeometry.right_dist_ne_zero_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) Real.pi\n⊢ Ne (Dist.dist p3 p2) 0","decl":"/-- If ∠ABC = π then dist C B ≠ 0. -/\ntheorem right_dist_ne_zero_of_angle_eq_pi {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = π) : dist p3 p2 ≠ 0 :=\n  left_dist_ne_zero_of_angle_eq_pi <| (angle_comm _ _ _).trans h\n\n"}
{"name":"EuclideanGeometry.dist_eq_add_dist_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) Real.pi\n⊢ Eq (Dist.dist p1 p3) (HAdd.hAdd (Dist.dist p1 p2) (Dist.dist p3 p2))","decl":"/-- If ∠ABC = π, then (dist A C) = (dist A B) + (dist B C). -/\ntheorem dist_eq_add_dist_of_angle_eq_pi {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = π) :\n    dist p1 p3 = dist p1 p2 + dist p3 p2 := by\n  rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]\n  exact norm_sub_eq_add_norm_of_angle_eq_pi h\n\n"}
{"name":"EuclideanGeometry.dist_eq_add_dist_iff_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nhp1p2 : Ne p1 p2\nhp3p2 : Ne p3 p2\n⊢ Iff (Eq (Dist.dist p1 p3) (HAdd.hAdd (Dist.dist p1 p2) (Dist.dist p3 p2))) (Eq (EuclideanGeometry.angle p1 p2 p3) Real.pi)","decl":"/-- If A ≠ B and C ≠ B then ∠ABC = π if and only if (dist A C) = (dist A B) + (dist B C). -/\ntheorem dist_eq_add_dist_iff_angle_eq_pi {p1 p2 p3 : P} (hp1p2 : p1 ≠ p2) (hp3p2 : p3 ≠ p2) :\n    dist p1 p3 = dist p1 p2 + dist p3 p2 ↔ ∠ p1 p2 p3 = π := by\n  rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]\n  exact\n    norm_sub_eq_add_norm_iff_angle_eq_pi (fun he => hp1p2 (vsub_eq_zero_iff_eq.1 he)) fun he =>\n      hp3p2 (vsub_eq_zero_iff_eq.1 he)\n\n"}
{"name":"EuclideanGeometry.dist_eq_abs_sub_dist_of_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (EuclideanGeometry.angle p1 p2 p3) 0\n⊢ Eq (Dist.dist p1 p3) (abs (HSub.hSub (Dist.dist p1 p2) (Dist.dist p3 p2)))","decl":"/-- If ∠ABC = 0, then (dist A C) = abs ((dist A B) - (dist B C)). -/\ntheorem dist_eq_abs_sub_dist_of_angle_eq_zero {p1 p2 p3 : P} (h : ∠ p1 p2 p3 = 0) :\n    dist p1 p3 = |dist p1 p2 - dist p3 p2| := by\n  rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]\n  exact norm_sub_eq_abs_sub_norm_of_angle_eq_zero h\n\n"}
{"name":"EuclideanGeometry.dist_eq_abs_sub_dist_iff_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nhp1p2 : Ne p1 p2\nhp3p2 : Ne p3 p2\n⊢ Iff (Eq (Dist.dist p1 p3) (abs (HSub.hSub (Dist.dist p1 p2) (Dist.dist p3 p2)))) (Eq (EuclideanGeometry.angle p1 p2 p3) 0)","decl":"/-- If A ≠ B and C ≠ B then ∠ABC = 0 if and only if (dist A C) = abs ((dist A B) - (dist B C)). -/\ntheorem dist_eq_abs_sub_dist_iff_angle_eq_zero {p1 p2 p3 : P} (hp1p2 : p1 ≠ p2) (hp3p2 : p3 ≠ p2) :\n    dist p1 p3 = |dist p1 p2 - dist p3 p2| ↔ ∠ p1 p2 p3 = 0 := by\n  rw [dist_eq_norm_vsub V, dist_eq_norm_vsub V, dist_eq_norm_vsub V, ← vsub_sub_vsub_cancel_right]\n  exact\n    norm_sub_eq_abs_sub_norm_iff_angle_eq_zero (fun he => hp1p2 (vsub_eq_zero_iff_eq.1 he))\n      fun he => hp3p2 (vsub_eq_zero_iff_eq.1 he)\n\n"}
{"name":"EuclideanGeometry.angle_midpoint_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 : P\nhp1p2 : Ne p1 p2\n⊢ Eq (EuclideanGeometry.angle p1 (midpoint Real p1 p2) p2) Real.pi","decl":"/-- If M is the midpoint of the segment AB, then ∠AMB = π. -/\ntheorem angle_midpoint_eq_pi (p1 p2 : P) (hp1p2 : p1 ≠ p2) : ∠ p1 (midpoint ℝ p1 p2) p2 = π := by\n  simp only [angle, left_vsub_midpoint, invOf_eq_inv, right_vsub_midpoint, inv_pos, zero_lt_two,\n    angle_smul_right_of_pos, angle_smul_left_of_pos]\n  rw [← neg_vsub_eq_vsub_rev p1 p2]\n  apply angle_self_neg_of_nonzero\n  simpa only [ne_eq, vsub_eq_zero_iff_eq]\n\n"}
{"name":"EuclideanGeometry.angle_left_midpoint_eq_pi_div_two_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (Dist.dist p3 p1) (Dist.dist p3 p2)\n⊢ Eq (EuclideanGeometry.angle p3 (midpoint Real p1 p2) p1) (HDiv.hDiv Real.pi 2)","decl":"/-- If M is the midpoint of the segment AB and C is the same distance from A as it is from B\nthen ∠CMA = π / 2. -/\ntheorem angle_left_midpoint_eq_pi_div_two_of_dist_eq {p1 p2 p3 : P} (h : dist p3 p1 = dist p3 p2) :\n    ∠ p3 (midpoint ℝ p1 p2) p1 = π / 2 := by\n  let m : P := midpoint ℝ p1 p2\n  have h1 : p3 -ᵥ p1 = p3 -ᵥ m - (p1 -ᵥ m) := (vsub_sub_vsub_cancel_right p3 p1 m).symm\n  have h2 : p3 -ᵥ p2 = p3 -ᵥ m + (p1 -ᵥ m) := by\n    rw [left_vsub_midpoint, ← midpoint_vsub_right, vsub_add_vsub_cancel]\n  rw [dist_eq_norm_vsub V p3 p1, dist_eq_norm_vsub V p3 p2, h1, h2] at h\n  exact (norm_add_eq_norm_sub_iff_angle_eq_pi_div_two (p3 -ᵥ m) (p1 -ᵥ m)).mp h.symm\n\n"}
{"name":"EuclideanGeometry.angle_right_midpoint_eq_pi_div_two_of_dist_eq","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np1 p2 p3 : P\nh : Eq (Dist.dist p3 p1) (Dist.dist p3 p2)\n⊢ Eq (EuclideanGeometry.angle p3 (midpoint Real p1 p2) p2) (HDiv.hDiv Real.pi 2)","decl":"/-- If M is the midpoint of the segment AB and C is the same distance from A as it is from B\nthen ∠CMB = π / 2. -/\ntheorem angle_right_midpoint_eq_pi_div_two_of_dist_eq {p1 p2 p3 : P} (h : dist p3 p1 = dist p3 p2) :\n    ∠ p3 (midpoint ℝ p1 p2) p2 = π / 2 := by\n  rw [midpoint_comm p1 p2, angle_left_midpoint_eq_pi_div_two_of_dist_eq h.symm]\n\n"}
{"name":"Sbtw.angle₁₂₃_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi","decl":"/-- If the second of three points is strictly between the other two, the angle at that point\nis π. -/\ntheorem _root_.Sbtw.angle₁₂₃_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₁ p₂ p₃ = π := by\n  rw [angle, angle_eq_pi_iff]\n  rcases h with ⟨⟨r, ⟨hr0, hr1⟩, hp₂⟩, hp₂p₁, hp₂p₃⟩\n  refine ⟨vsub_ne_zero.2 hp₂p₁.symm, -(1 - r) / r, ?_⟩\n  have hr0' : r ≠ 0 := by\n    rintro rfl\n    rw [← hp₂] at hp₂p₁\n    simp at hp₂p₁\n  have hr1' : r ≠ 1 := by\n    rintro rfl\n    rw [← hp₂] at hp₂p₃\n    simp at hp₂p₃\n  replace hr0 := hr0.lt_of_ne hr0'.symm\n  replace hr1 := hr1.lt_of_ne hr1'\n  refine ⟨div_neg_of_neg_of_pos (Left.neg_neg_iff.2 (sub_pos.2 hr1)) hr0, ?_⟩\n  rw [← hp₂, AffineMap.lineMap_apply, vsub_vadd_eq_vsub_sub, vsub_vadd_eq_vsub_sub, vsub_self,\n    zero_sub, smul_neg, smul_smul, div_mul_cancel₀ _ hr0', neg_smul, neg_neg, sub_eq_iff_eq_add, ←\n    add_smul, sub_add_cancel, one_smul]\n\n"}
{"name":"Sbtw.angle₃₂₁_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₃ p₂ p₁) Real.pi","decl":"/-- If the second of three points is strictly between the other two, the angle at that point\n(reversed) is π. -/\ntheorem _root_.Sbtw.angle₃₂₁_eq_pi {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₃ p₂ p₁ = π := by\n  rw [← h.angle₁₂₃_eq_pi, angle_comm]\n\n"}
{"name":"EuclideanGeometry.angle_eq_pi_iff_sbtw","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi) (Sbtw Real p₁ p₂ p₃)","decl":"/-- The angle between three points is π if and only if the second point is strictly between the\nother two. -/\ntheorem angle_eq_pi_iff_sbtw {p₁ p₂ p₃ : P} : ∠ p₁ p₂ p₃ = π ↔ Sbtw ℝ p₁ p₂ p₃ := by\n  refine ⟨?_, fun h => h.angle₁₂₃_eq_pi⟩\n  rw [angle, angle_eq_pi_iff]\n  rintro ⟨hp₁p₂, r, hr, hp₃p₂⟩\n  refine ⟨⟨1 / (1 - r), ⟨div_nonneg zero_le_one (sub_nonneg.2 (hr.le.trans zero_le_one)),\n    (div_le_one (sub_pos.2 (hr.trans zero_lt_one))).2 ((le_sub_self_iff 1).2 hr.le)⟩, ?_⟩,\n    (vsub_ne_zero.1 hp₁p₂).symm, ?_⟩\n  · rw [← eq_vadd_iff_vsub_eq] at hp₃p₂\n    rw [AffineMap.lineMap_apply, hp₃p₂, vadd_vsub_assoc, ← neg_vsub_eq_vsub_rev p₂ p₁, smul_neg, ←\n      neg_smul, smul_add, smul_smul, ← add_smul, eq_comm, eq_vadd_iff_vsub_eq]\n    convert (one_smul ℝ (p₂ -ᵥ p₁)).symm\n    field_simp [(sub_pos.2 (hr.trans zero_lt_one)).ne.symm]\n    ring\n  · rw [ne_comm, ← @vsub_ne_zero V, hp₃p₂, smul_ne_zero_iff]\n    exact ⟨hr.ne, hp₁p₂⟩\n\n"}
{"name":"Wbtw.angle₂₁₃_eq_zero_of_ne","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\nhp₂p₁ : Ne p₂ p₁\n⊢ Eq (EuclideanGeometry.angle p₂ p₁ p₃) 0","decl":"/-- If the second of three points is weakly between the other two, and not equal to the first,\nthe angle at the first point is zero. -/\ntheorem _root_.Wbtw.angle₂₁₃_eq_zero_of_ne {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) (hp₂p₁ : p₂ ≠ p₁) :\n    ∠ p₂ p₁ p₃ = 0 := by\n  rw [angle, angle_eq_zero_iff]\n  rcases h with ⟨r, ⟨hr0, hr1⟩, rfl⟩\n  have hr0' : r ≠ 0 := by\n    rintro rfl\n    simp at hp₂p₁\n  replace hr0 := hr0.lt_of_ne hr0'.symm\n  refine ⟨vsub_ne_zero.2 hp₂p₁, r⁻¹, inv_pos.2 hr0, ?_⟩\n  rw [AffineMap.lineMap_apply, vadd_vsub_assoc, vsub_self, add_zero, smul_smul,\n    inv_mul_cancel₀ hr0', one_smul]\n\n"}
{"name":"Sbtw.angle₂₁₃_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₂ p₁ p₃) 0","decl":"/-- If the second of three points is strictly between the other two, the angle at the first point\nis zero. -/\ntheorem _root_.Sbtw.angle₂₁₃_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₂ p₁ p₃ = 0 :=\n  h.wbtw.angle₂₁₃_eq_zero_of_ne h.ne_left\n\n"}
{"name":"Wbtw.angle₃₁₂_eq_zero_of_ne","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\nhp₂p₁ : Ne p₂ p₁\n⊢ Eq (EuclideanGeometry.angle p₃ p₁ p₂) 0","decl":"/-- If the second of three points is weakly between the other two, and not equal to the first,\nthe angle at the first point (reversed) is zero. -/\ntheorem _root_.Wbtw.angle₃₁₂_eq_zero_of_ne {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) (hp₂p₁ : p₂ ≠ p₁) :\n    ∠ p₃ p₁ p₂ = 0 := by rw [← h.angle₂₁₃_eq_zero_of_ne hp₂p₁, angle_comm]\n\n"}
{"name":"Sbtw.angle₃₁₂_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₃ p₁ p₂) 0","decl":"/-- If the second of three points is strictly between the other two, the angle at the first point\n(reversed) is zero. -/\ntheorem _root_.Sbtw.angle₃₁₂_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₃ p₁ p₂ = 0 :=\n  h.wbtw.angle₃₁₂_eq_zero_of_ne h.ne_left\n\n"}
{"name":"Wbtw.angle₂₃₁_eq_zero_of_ne","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\nhp₂p₃ : Ne p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₂ p₃ p₁) 0","decl":"/-- If the second of three points is weakly between the other two, and not equal to the third,\nthe angle at the third point is zero. -/\ntheorem _root_.Wbtw.angle₂₃₁_eq_zero_of_ne {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) (hp₂p₃ : p₂ ≠ p₃) :\n    ∠ p₂ p₃ p₁ = 0 :=\n  h.symm.angle₂₁₃_eq_zero_of_ne hp₂p₃\n\n"}
{"name":"Sbtw.angle₂₃₁_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₂ p₃ p₁) 0","decl":"/-- If the second of three points is strictly between the other two, the angle at the third point\nis zero. -/\ntheorem _root_.Sbtw.angle₂₃₁_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₂ p₃ p₁ = 0 :=\n  h.wbtw.angle₂₃₁_eq_zero_of_ne h.ne_right\n\n"}
{"name":"Wbtw.angle₁₃₂_eq_zero_of_ne","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Wbtw Real p₁ p₂ p₃\nhp₂p₃ : Ne p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₁ p₃ p₂) 0","decl":"/-- If the second of three points is weakly between the other two, and not equal to the third,\nthe angle at the third point (reversed) is zero. -/\ntheorem _root_.Wbtw.angle₁₃₂_eq_zero_of_ne {p₁ p₂ p₃ : P} (h : Wbtw ℝ p₁ p₂ p₃) (hp₂p₃ : p₂ ≠ p₃) :\n    ∠ p₁ p₃ p₂ = 0 :=\n  h.symm.angle₃₁₂_eq_zero_of_ne hp₂p₃\n\n"}
{"name":"Sbtw.angle₁₃₂_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Sbtw Real p₁ p₂ p₃\n⊢ Eq (EuclideanGeometry.angle p₁ p₃ p₂) 0","decl":"/-- If the second of three points is strictly between the other two, the angle at the third point\n(reversed) is zero. -/\ntheorem _root_.Sbtw.angle₁₃₂_eq_zero {p₁ p₂ p₃ : P} (h : Sbtw ℝ p₁ p₂ p₃) : ∠ p₁ p₃ p₂ = 0 :=\n  h.wbtw.angle₁₃₂_eq_zero_of_ne h.ne_right\n\n"}
{"name":"EuclideanGeometry.angle_eq_zero_iff_ne_and_wbtw","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.angle p₁ p₂ p₃) 0) (Or (And (Ne p₁ p₂) (Wbtw Real p₂ p₁ p₃)) (And (Ne p₃ p₂) (Wbtw Real p₂ p₃ p₁)))","decl":"/-- The angle between three points is zero if and only if one of the first and third points is\nweakly between the other two, and not equal to the second. -/\ntheorem angle_eq_zero_iff_ne_and_wbtw {p₁ p₂ p₃ : P} :\n    ∠ p₁ p₂ p₃ = 0 ↔ p₁ ≠ p₂ ∧ Wbtw ℝ p₂ p₁ p₃ ∨ p₃ ≠ p₂ ∧ Wbtw ℝ p₂ p₃ p₁ := by\n  constructor\n  · rw [angle, angle_eq_zero_iff]\n    rintro ⟨hp₁p₂, r, hr0, hp₃p₂⟩\n    rcases le_or_lt 1 r with (hr1 | hr1)\n    · refine Or.inl ⟨vsub_ne_zero.1 hp₁p₂, r⁻¹, ⟨(inv_pos.2 hr0).le, inv_le_one_of_one_le₀ hr1⟩, ?_⟩\n      rw [AffineMap.lineMap_apply, hp₃p₂, smul_smul, inv_mul_cancel₀ hr0.ne.symm, one_smul,\n        vsub_vadd]\n    · refine Or.inr ⟨?_, r, ⟨hr0.le, hr1.le⟩, ?_⟩\n      · rw [← @vsub_ne_zero V, hp₃p₂, smul_ne_zero_iff]\n        exact ⟨hr0.ne.symm, hp₁p₂⟩\n      · rw [AffineMap.lineMap_apply, ← hp₃p₂, vsub_vadd]\n  · rintro (⟨hp₁p₂, h⟩ | ⟨hp₃p₂, h⟩)\n    · exact h.angle₂₁₃_eq_zero_of_ne hp₁p₂\n    · exact h.angle₃₁₂_eq_zero_of_ne hp₃p₂\n\n"}
{"name":"EuclideanGeometry.angle_eq_zero_iff_eq_and_ne_or_sbtw","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (EuclideanGeometry.angle p₁ p₂ p₃) 0) (Or (And (Eq p₁ p₃) (Ne p₁ p₂)) (Or (Sbtw Real p₂ p₁ p₃) (Sbtw Real p₂ p₃ p₁)))","decl":"/-- The angle between three points is zero if and only if one of the first and third points is\nstrictly between the other two, or those two points are equal but not equal to the second. -/\ntheorem angle_eq_zero_iff_eq_and_ne_or_sbtw {p₁ p₂ p₃ : P} :\n    ∠ p₁ p₂ p₃ = 0 ↔ p₁ = p₃ ∧ p₁ ≠ p₂ ∨ Sbtw ℝ p₂ p₁ p₃ ∨ Sbtw ℝ p₂ p₃ p₁ := by\n  rw [angle_eq_zero_iff_ne_and_wbtw]\n  by_cases hp₁p₂ : p₁ = p₂; · simp [hp₁p₂]\n  by_cases hp₁p₃ : p₁ = p₃; · simp [hp₁p₃]\n  by_cases hp₃p₂ : p₃ = p₂; · simp [hp₃p₂]\n  simp [hp₁p₂, hp₁p₃, Ne.symm hp₁p₃, Sbtw, hp₃p₂]\n\n"}
{"name":"EuclideanGeometry.collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))) (Or (Eq p₁ p₂) (Or (Eq p₃ p₂) (Or (Eq (EuclideanGeometry.angle p₁ p₂ p₃) 0) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi))))","decl":"/-- Three points are collinear if and only if the first or third point equals the second or the\nangle between them is 0 or π. -/\ntheorem collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi {p₁ p₂ p₃ : P} :\n    Collinear ℝ ({p₁, p₂, p₃} : Set P) ↔ p₁ = p₂ ∨ p₃ = p₂ ∨ ∠ p₁ p₂ p₃ = 0 ∨ ∠ p₁ p₂ p₃ = π := by\n  refine ⟨fun h => ?_, fun h => ?_⟩\n  · replace h := h.wbtw_or_wbtw_or_wbtw\n    by_cases h₁₂ : p₁ = p₂\n    · exact Or.inl h₁₂\n    by_cases h₃₂ : p₃ = p₂\n    · exact Or.inr (Or.inl h₃₂)\n    rw [or_iff_right h₁₂, or_iff_right h₃₂]\n    rcases h with (h | h | h)\n    · exact Or.inr (angle_eq_pi_iff_sbtw.2 ⟨h, Ne.symm h₁₂, Ne.symm h₃₂⟩)\n    · exact Or.inl (h.angle₃₁₂_eq_zero_of_ne h₃₂)\n    · exact Or.inl (h.angle₂₃₁_eq_zero_of_ne h₁₂)\n  · rcases h with (rfl | rfl | h | h)\n    · simpa using collinear_pair ℝ p₁ p₃\n    · simpa using collinear_pair ℝ p₁ p₃\n    · rw [angle_eq_zero_iff_ne_and_wbtw] at h\n      rcases h with (⟨-, h⟩ | ⟨-, h⟩)\n      · rw [Set.insert_comm]\n        exact h.collinear\n      · rw [Set.insert_comm, Set.pair_comm]\n        exact h.collinear\n    · rw [angle_eq_pi_iff_sbtw] at h\n      exact h.wbtw.collinear\n\n"}
{"name":"EuclideanGeometry.collinear_of_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.angle p₁ p₂ p₃) 0\n⊢ Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- If the angle between three points is 0, they are collinear. -/\ntheorem collinear_of_angle_eq_zero {p₁ p₂ p₃ : P} (h : ∠ p₁ p₂ p₃ = 0) :\n    Collinear ℝ ({p₁, p₂, p₃} : Set P) :=\n  collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi.2 <| Or.inr <| Or.inr <| Or.inl h\n\n"}
{"name":"EuclideanGeometry.collinear_of_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi\n⊢ Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- If the angle between three points is π, they are collinear. -/\ntheorem collinear_of_angle_eq_pi {p₁ p₂ p₃ : P} (h : ∠ p₁ p₂ p₃ = π) :\n    Collinear ℝ ({p₁, p₂, p₃} : Set P) :=\n  collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi.2 <| Or.inr <| Or.inr <| Or.inr h\n\n"}
{"name":"EuclideanGeometry.angle_ne_zero_of_not_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ Ne (EuclideanGeometry.angle p₁ p₂ p₃) 0","decl":"/-- If three points are not collinear, the angle between them is nonzero. -/\ntheorem angle_ne_zero_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear ℝ ({p₁, p₂, p₃} : Set P)) :\n    ∠ p₁ p₂ p₃ ≠ 0 :=\n  mt collinear_of_angle_eq_zero h\n\n"}
{"name":"EuclideanGeometry.angle_ne_pi_of_not_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ Ne (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi","decl":"/-- If three points are not collinear, the angle between them is not π. -/\ntheorem angle_ne_pi_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear ℝ ({p₁, p₂, p₃} : Set P)) :\n    ∠ p₁ p₂ p₃ ≠ π :=\n  mt collinear_of_angle_eq_pi h\n\n"}
{"name":"EuclideanGeometry.angle_pos_of_not_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ LT.lt 0 (EuclideanGeometry.angle p₁ p₂ p₃)","decl":"/-- If three points are not collinear, the angle between them is positive. -/\ntheorem angle_pos_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear ℝ ({p₁, p₂, p₃} : Set P)) :\n    0 < ∠ p₁ p₂ p₃ :=\n  (angle_nonneg _ _ _).lt_of_ne (angle_ne_zero_of_not_collinear h).symm\n\n"}
{"name":"EuclideanGeometry.angle_lt_pi_of_not_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ LT.lt (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi","decl":"/-- If three points are not collinear, the angle between them is less than π. -/\ntheorem angle_lt_pi_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear ℝ ({p₁, p₂, p₃} : Set P)) :\n    ∠ p₁ p₂ p₃ < π :=\n  (angle_le_pi _ _ _).lt_of_ne <| angle_ne_pi_of_not_collinear h\n\n"}
{"name":"EuclideanGeometry.cos_eq_one_iff_angle_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (Real.cos (EuclideanGeometry.angle p₁ p₂ p₃)) 1) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) 0)","decl":"/-- The cosine of the angle between three points is 1 if and only if the angle is 0. -/\nnonrec theorem cos_eq_one_iff_angle_eq_zero {p₁ p₂ p₃ : P} :\n    Real.cos (∠ p₁ p₂ p₃) = 1 ↔ ∠ p₁ p₂ p₃ = 0 :=\n  cos_eq_one_iff_angle_eq_zero\n\n"}
{"name":"EuclideanGeometry.cos_eq_zero_iff_angle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (Real.cos (EuclideanGeometry.angle p₁ p₂ p₃)) 0) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) (HDiv.hDiv Real.pi 2))","decl":"/-- The cosine of the angle between three points is 0 if and only if the angle is π / 2. -/\nnonrec theorem cos_eq_zero_iff_angle_eq_pi_div_two {p₁ p₂ p₃ : P} :\n    Real.cos (∠ p₁ p₂ p₃) = 0 ↔ ∠ p₁ p₂ p₃ = π / 2 :=\n  cos_eq_zero_iff_angle_eq_pi_div_two\n\n"}
{"name":"EuclideanGeometry.cos_eq_neg_one_iff_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (Real.cos (EuclideanGeometry.angle p₁ p₂ p₃)) (-1)) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi)","decl":"/-- The cosine of the angle between three points is -1 if and only if the angle is π. -/\nnonrec theorem cos_eq_neg_one_iff_angle_eq_pi {p₁ p₂ p₃ : P} :\n    Real.cos (∠ p₁ p₂ p₃) = -1 ↔ ∠ p₁ p₂ p₃ = π :=\n  cos_eq_neg_one_iff_angle_eq_pi\n\n"}
{"name":"EuclideanGeometry.sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (Real.sin (EuclideanGeometry.angle p₁ p₂ p₃)) 0) (Or (Eq (EuclideanGeometry.angle p₁ p₂ p₃) 0) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) Real.pi))","decl":"/-- The sine of the angle between three points is 0 if and only if the angle is 0 or π. -/\nnonrec theorem sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi {p₁ p₂ p₃ : P} :\n    Real.sin (∠ p₁ p₂ p₃) = 0 ↔ ∠ p₁ p₂ p₃ = 0 ∨ ∠ p₁ p₂ p₃ = π :=\n  sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi\n\n"}
{"name":"EuclideanGeometry.sin_eq_one_iff_angle_eq_pi_div_two","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Eq (Real.sin (EuclideanGeometry.angle p₁ p₂ p₃)) 1) (Eq (EuclideanGeometry.angle p₁ p₂ p₃) (HDiv.hDiv Real.pi 2))","decl":"/-- The sine of the angle between three points is 1 if and only if the angle is π / 2. -/\nnonrec theorem sin_eq_one_iff_angle_eq_pi_div_two {p₁ p₂ p₃ : P} :\n    Real.sin (∠ p₁ p₂ p₃) = 1 ↔ ∠ p₁ p₂ p₃ = π / 2 :=\n  sin_eq_one_iff_angle_eq_pi_div_two\n\n"}
{"name":"EuclideanGeometry.collinear_iff_eq_or_eq_or_sin_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\n⊢ Iff (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))) (Or (Eq p₁ p₂) (Or (Eq p₃ p₂) (Eq (Real.sin (EuclideanGeometry.angle p₁ p₂ p₃)) 0)))","decl":"/-- Three points are collinear if and only if the first or third point equals the second or\nthe sine of the angle between three points is zero. -/\ntheorem collinear_iff_eq_or_eq_or_sin_eq_zero {p₁ p₂ p₃ : P} :\n    Collinear ℝ ({p₁, p₂, p₃} : Set P) ↔ p₁ = p₂ ∨ p₃ = p₂ ∨ Real.sin (∠ p₁ p₂ p₃) = 0 := by\n  rw [sin_eq_zero_iff_angle_eq_zero_or_angle_eq_pi,\n    collinear_iff_eq_or_eq_or_angle_eq_zero_or_angle_eq_pi]\n\n"}
{"name":"EuclideanGeometry.sin_pos_of_not_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ LT.lt 0 (Real.sin (EuclideanGeometry.angle p₁ p₂ p₃))","decl":"/-- If three points are not collinear, the sine of the angle between them is positive. -/\ntheorem sin_pos_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear ℝ ({p₁, p₂, p₃} : Set P)) :\n    0 < Real.sin (∠ p₁ p₂ p₃) :=\n  Real.sin_pos_of_pos_of_lt_pi (angle_pos_of_not_collinear h) (angle_lt_pi_of_not_collinear h)\n\n"}
{"name":"EuclideanGeometry.sin_ne_zero_of_not_collinear","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Not (Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃))))\n⊢ Ne (Real.sin (EuclideanGeometry.angle p₁ p₂ p₃)) 0","decl":"/-- If three points are not collinear, the sine of the angle between them is nonzero. -/\ntheorem sin_ne_zero_of_not_collinear {p₁ p₂ p₃ : P} (h : ¬Collinear ℝ ({p₁, p₂, p₃} : Set P)) :\n    Real.sin (∠ p₁ p₂ p₃) ≠ 0 :=\n  ne_of_gt (sin_pos_of_not_collinear h)\n\n"}
{"name":"EuclideanGeometry.collinear_of_sin_eq_zero","module":"Mathlib.Geometry.Euclidean.Angle.Unoriented.Affine","initialProofState":"V : Type u_1\nP : Type u_2\ninst✝³ : NormedAddCommGroup V\ninst✝² : InnerProductSpace Real V\ninst✝¹ : MetricSpace P\ninst✝ : NormedAddTorsor V P\np₁ p₂ p₃ : P\nh : Eq (Real.sin (EuclideanGeometry.angle p₁ p₂ p₃)) 0\n⊢ Collinear Real (Insert.insert p₁ (Insert.insert p₂ (Singleton.singleton p₃)))","decl":"/-- If the sine of the angle between three points is 0, they are collinear. -/\ntheorem collinear_of_sin_eq_zero {p₁ p₂ p₃ : P} (h : Real.sin (∠ p₁ p₂ p₃) = 0) :\n    Collinear ℝ ({p₁, p₂, p₃} : Set P) := by\n  revert h\n  contrapose\n  exact sin_ne_zero_of_not_collinear\n\n"}
