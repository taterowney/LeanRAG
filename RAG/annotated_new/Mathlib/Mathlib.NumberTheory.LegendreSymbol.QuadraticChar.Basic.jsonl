{"name":"quadraticCharFun_eq_zero_iff","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\n⊢ Iff (Eq (quadraticCharFun F a) 0) (Eq a 0)","decl":"/-- Some basic API lemmas -/\ntheorem quadraticCharFun_eq_zero_iff {a : F} : quadraticCharFun F a = 0 ↔ a = 0 := by\n  simp only [quadraticCharFun]\n  by_cases ha : a = 0\n  · simp only [ha, if_true]\n  · simp only [ha, if_false]\n    split_ifs <;> simp only [neg_eq_zero, one_ne_zero, not_false_iff]\n\n"}
{"name":"quadraticCharFun_zero","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\n⊢ Eq (quadraticCharFun F 0) 0","decl":"@[simp]\ntheorem quadraticCharFun_zero : quadraticCharFun F 0 = 0 := by\n  simp only [quadraticCharFun, if_true]\n\n"}
{"name":"quadraticCharFun_one","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\n⊢ Eq (quadraticCharFun F 1) 1","decl":"@[simp]\ntheorem quadraticCharFun_one : quadraticCharFun F 1 = 1 := by\n  simp only [quadraticCharFun, one_ne_zero, IsSquare.one, if_true, if_false]\n\n"}
{"name":"quadraticCharFun_eq_one_of_char_two","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Eq (ringChar F) 2\na : F\nha : Ne a 0\n⊢ Eq (quadraticCharFun F a) 1","decl":"/-- If `ringChar F = 2`, then `quadraticCharFun F` takes the value `1` on nonzero elements. -/\ntheorem quadraticCharFun_eq_one_of_char_two (hF : ringChar F = 2) {a : F} (ha : a ≠ 0) :\n    quadraticCharFun F a = 1 := by\n  simp only [quadraticCharFun, ha, if_false, ite_eq_left_iff]\n  exact fun h ↦ (h (FiniteField.isSquare_of_char_two hF a)).elim\n\n"}
{"name":"quadraticCharFun_eq_pow_of_char_ne_two","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\na : F\nha : Ne a 0\n⊢ Eq (quadraticCharFun F a) (ite (Eq (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2)) 1) 1 (-1))","decl":"/-- If `ringChar F` is odd, then `quadraticCharFun F a` can be computed in\nterms of `a ^ (Fintype.card F / 2)`. -/\ntheorem quadraticCharFun_eq_pow_of_char_ne_two (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    quadraticCharFun F a = if a ^ (Fintype.card F / 2) = 1 then 1 else -1 := by\n  simp only [quadraticCharFun, ha, if_false]\n  simp_rw [FiniteField.isSquare_iff hF ha]\n\n"}
{"name":"quadraticCharFun_mul","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na b : F\n⊢ Eq (quadraticCharFun F (HMul.hMul a b)) (HMul.hMul (quadraticCharFun F a) (quadraticCharFun F b))","decl":"/-- The quadratic character is multiplicative. -/\ntheorem quadraticCharFun_mul (a b : F) :\n    quadraticCharFun F (a * b) = quadraticCharFun F a * quadraticCharFun F b := by\n  by_cases ha : a = 0\n  · rw [ha, zero_mul, quadraticCharFun_zero, zero_mul]\n  -- now `a ≠ 0`\n  by_cases hb : b = 0\n  · rw [hb, mul_zero, quadraticCharFun_zero, mul_zero]\n  -- now `a ≠ 0` and `b ≠ 0`\n  have hab := mul_ne_zero ha hb\n  by_cases hF : ringChar F = 2\n  ·-- case `ringChar F = 2`\n    rw [quadraticCharFun_eq_one_of_char_two hF ha, quadraticCharFun_eq_one_of_char_two hF hb,\n      quadraticCharFun_eq_one_of_char_two hF hab, mul_one]\n  · -- case of odd characteristic\n    rw [quadraticCharFun_eq_pow_of_char_ne_two hF ha, quadraticCharFun_eq_pow_of_char_ne_two hF hb,\n      quadraticCharFun_eq_pow_of_char_ne_two hF hab, mul_pow]\n    cases' FiniteField.pow_dichotomy hF hb with hb' hb'\n    · simp only [hb', mul_one, if_true]\n    · have h := Ring.neg_one_ne_one_of_char_ne_two hF\n      -- `-1 ≠ 1`\n      simp only [hb', mul_neg, mul_one, h, if_false]\n      cases' FiniteField.pow_dichotomy hF ha with ha' ha' <;>\n        simp only [ha', h, neg_neg, if_true, if_false]\n\n"}
{"name":"quadraticChar_apply","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\n⊢ Eq ((quadraticChar F) a) (quadraticCharFun F a)","decl":"/-- The quadratic character as a multiplicative character. -/\n@[simps]\ndef quadraticChar : MulChar F ℤ where\n  toFun := quadraticCharFun F\n  map_one' := quadraticCharFun_one\n  map_mul' := quadraticCharFun_mul\n  map_nonunit' a ha := by rw [of_not_not (mt Ne.isUnit ha)]; exact quadraticCharFun_zero\n\n"}
{"name":"quadraticChar_eq_zero_iff","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\n⊢ Iff (Eq ((quadraticChar F) a) 0) (Eq a 0)","decl":"/-- The value of the quadratic character on `a` is zero iff `a = 0`. -/\ntheorem quadraticChar_eq_zero_iff {a : F} : quadraticChar F a = 0 ↔ a = 0 :=\n  quadraticCharFun_eq_zero_iff\n\n"}
{"name":"quadraticChar_zero","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\n⊢ Eq ((quadraticChar F) 0) 0","decl":"theorem quadraticChar_zero : quadraticChar F 0 = 0 := by\n  simp only [quadraticChar_apply, quadraticCharFun_zero]\n\n"}
{"name":"quadraticChar_one_iff_isSquare","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\nha : Ne a 0\n⊢ Iff (Eq ((quadraticChar F) a) 1) (IsSquare a)","decl":"/-- For nonzero `a : F`, `quadraticChar F a = 1 ↔ IsSquare a`. -/\ntheorem quadraticChar_one_iff_isSquare {a : F} (ha : a ≠ 0) :\n    quadraticChar F a = 1 ↔ IsSquare a := by\n  simp only [quadraticChar_apply, quadraticCharFun, ha, if_false, ite_eq_left_iff,\n    (by omega : (-1 : ℤ) ≠ 1), imp_false, not_not, reduceCtorEq]\n\n"}
{"name":"quadraticChar_sq_one'","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\nha : Ne a 0\n⊢ Eq ((quadraticChar F) (HPow.hPow a 2)) 1","decl":"/-- The quadratic character takes the value `1` on nonzero squares. -/\ntheorem quadraticChar_sq_one' {a : F} (ha : a ≠ 0) : quadraticChar F (a ^ 2) = 1 := by\n  simp only [quadraticChar_apply, quadraticCharFun, sq_eq_zero_iff, ha, IsSquare.sq, if_true,\n    if_false]\n\n"}
{"name":"quadraticChar_sq_one","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\nha : Ne a 0\n⊢ Eq (HPow.hPow ((quadraticChar F) a) 2) 1","decl":"/-- The square of the quadratic character on nonzero arguments is `1`. -/\ntheorem quadraticChar_sq_one {a : F} (ha : a ≠ 0) : quadraticChar F a ^ 2 = 1 := by\n  rwa [pow_two, ← map_mul, ← pow_two, quadraticChar_sq_one']\n\n"}
{"name":"quadraticChar_dichotomy","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\nha : Ne a 0\n⊢ Or (Eq ((quadraticChar F) a) 1) (Eq ((quadraticChar F) a) (-1))","decl":"/-- The quadratic character is `1` or `-1` on nonzero arguments. -/\ntheorem quadraticChar_dichotomy {a : F} (ha : a ≠ 0) :\n    quadraticChar F a = 1 ∨ quadraticChar F a = -1 :=\n  sq_eq_one_iff.1 <| quadraticChar_sq_one ha\n\n"}
{"name":"quadraticChar_eq_neg_one_iff_not_one","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\nha : Ne a 0\n⊢ Iff (Eq ((quadraticChar F) a) (-1)) (Not (Eq ((quadraticChar F) a) 1))","decl":"/-- The quadratic character is `1` or `-1` on nonzero arguments. -/\ntheorem quadraticChar_eq_neg_one_iff_not_one {a : F} (ha : a ≠ 0) :\n    quadraticChar F a = -1 ↔ ¬quadraticChar F a = 1 :=\n  ⟨fun h ↦ by rw [h]; omega, fun h₂ ↦ (or_iff_right h₂).mp (quadraticChar_dichotomy ha)⟩\n\n"}
{"name":"quadraticChar_neg_one_iff_not_isSquare","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\na : F\n⊢ Iff (Eq ((quadraticChar F) a) (-1)) (Not (IsSquare a))","decl":"/-- For `a : F`, `quadraticChar F a = -1 ↔ ¬ IsSquare a`. -/\ntheorem quadraticChar_neg_one_iff_not_isSquare {a : F} : quadraticChar F a = -1 ↔ ¬IsSquare a := by\n  by_cases ha : a = 0\n  · simp only [ha, MulChar.map_zero, zero_eq_neg, one_ne_zero, IsSquare.zero, not_true]\n  · rw [quadraticChar_eq_neg_one_iff_not_one ha, quadraticChar_one_iff_isSquare ha]\n\n"}
{"name":"quadraticChar_exists_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Exists fun a => Eq ((quadraticChar F) a) (-1)","decl":"/-- If `F` has odd characteristic, then `quadraticChar F` takes the value `-1`. -/\ntheorem quadraticChar_exists_neg_one (hF : ringChar F ≠ 2) : ∃ a, quadraticChar F a = -1 :=\n  (FiniteField.exists_nonsquare hF).imp fun _ h₁ ↦ quadraticChar_neg_one_iff_not_isSquare.mpr h₁\n\n"}
{"name":"quadraticChar_exists_neg_one'","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Exists fun a => Eq ((quadraticChar F) ↑a) (-1)","decl":"/-- If `F` has odd characteristic, then `quadraticChar F` takes the value `-1` on some unit. -/\nlemma quadraticChar_exists_neg_one' (hF : ringChar F ≠ 2) : ∃ a : Fˣ, quadraticChar F a = -1 := by\n  refine (fun ⟨a, ha⟩ ↦ ⟨IsUnit.unit ?_, ha⟩) (quadraticChar_exists_neg_one hF)\n  contrapose ha\n  exact ne_of_eq_of_ne ((quadraticChar F).map_nonunit ha) (mt zero_eq_neg.mp one_ne_zero)\n\n"}
{"name":"quadraticChar_eq_one_of_char_two","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Eq (ringChar F) 2\na : F\nha : Ne a 0\n⊢ Eq ((quadraticChar F) a) 1","decl":"/-- If `ringChar F = 2`, then `quadraticChar F` takes the value `1` on nonzero elements. -/\ntheorem quadraticChar_eq_one_of_char_two (hF : ringChar F = 2) {a : F} (ha : a ≠ 0) :\n    quadraticChar F a = 1 :=\n  quadraticCharFun_eq_one_of_char_two hF ha\n\n"}
{"name":"quadraticChar_eq_pow_of_char_ne_two","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\na : F\nha : Ne a 0\n⊢ Eq ((quadraticChar F) a) (ite (Eq (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2)) 1) 1 (-1))","decl":"/-- If `ringChar F` is odd, then `quadraticChar F a` can be computed in\nterms of `a ^ (Fintype.card F / 2)`. -/\ntheorem quadraticChar_eq_pow_of_char_ne_two (hF : ringChar F ≠ 2) {a : F} (ha : a ≠ 0) :\n    quadraticChar F a = if a ^ (Fintype.card F / 2) = 1 then 1 else -1 :=\n  quadraticCharFun_eq_pow_of_char_ne_two hF ha\n\n"}
{"name":"quadraticChar_eq_pow_of_char_ne_two'","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\na : F\n⊢ Eq (↑((quadraticChar F) a)) (HPow.hPow a (HDiv.hDiv (Fintype.card F) 2))","decl":"theorem quadraticChar_eq_pow_of_char_ne_two' (hF : ringChar F ≠ 2) (a : F) :\n    (quadraticChar F a : F) = a ^ (Fintype.card F / 2) := by\n  by_cases ha : a = 0\n  · have : 0 < Fintype.card F / 2 := Nat.div_pos Fintype.one_lt_card two_pos\n    simp only [ha, quadraticChar_apply, quadraticCharFun_zero, Int.cast_zero, zero_pow this.ne']\n  · rw [quadraticChar_eq_pow_of_char_ne_two hF ha]\n    by_cases ha' : a ^ (Fintype.card F / 2) = 1\n    · simp only [ha', if_true, Int.cast_one]\n    · have ha'' := Or.resolve_left (FiniteField.pow_dichotomy hF ha) ha'\n      simp only [ha'', Int.cast_ite, Int.cast_one, Int.cast_neg, ite_eq_right_iff]\n      exact Eq.symm\n\n"}
{"name":"quadraticChar_isQuadratic","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\n⊢ (quadraticChar F).IsQuadratic","decl":"/-- The quadratic character is quadratic as a multiplicative character. -/\ntheorem quadraticChar_isQuadratic : (quadraticChar F).IsQuadratic := by\n  intro a\n  by_cases ha : a = 0\n  · left; rw [ha]; exact quadraticChar_zero\n  · right; exact quadraticChar_dichotomy ha\n\n"}
{"name":"quadraticChar_ne_one","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Ne (quadraticChar F) 1","decl":"/-- The quadratic character is nontrivial as a multiplicative character\nwhen the domain has odd characteristic. -/\ntheorem quadraticChar_ne_one (hF : ringChar F ≠ 2) : quadraticChar F ≠ 1 := by\n  rcases quadraticChar_exists_neg_one' hF with ⟨a, ha⟩\n  intro hχ\n  simp only [hχ, one_apply a.isUnit, one_ne_zero, reduceCtorEq] at ha\n\n"}
{"name":"quadraticChar_card_sqrts","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\na : F\n⊢ Eq (↑(setOf fun x => Eq (HPow.hPow x 2) a).toFinset.card) (HAdd.hAdd ((quadraticChar F) a) 1)","decl":"open Finset in\n/-- The number of solutions to `x^2 = a` is determined by the quadratic character. -/\ntheorem quadraticChar_card_sqrts (hF : ringChar F ≠ 2) (a : F) :\n    #{x : F | x ^ 2 = a}.toFinset = quadraticChar F a + 1 := by\n  -- we consider the cases `a = 0`, `a` is a nonzero square and `a` is a nonsquare in turn\n  by_cases h₀ : a = 0\n  · simp only [h₀, sq_eq_zero_iff, Set.setOf_eq_eq_singleton, Set.toFinset_card,\n    Set.card_singleton, Int.ofNat_succ, Int.ofNat_zero, MulChar.map_zero]\n  · set s := {x : F | x ^ 2 = a}.toFinset\n    by_cases h : IsSquare a\n    · rw [(quadraticChar_one_iff_isSquare h₀).mpr h]\n      rcases h with ⟨b, h⟩\n      rw [h, mul_self_eq_zero] at h₀\n      have h₁ : s = [b, -b].toFinset := by\n        ext1\n        rw [← pow_two] at h\n        simp only [Set.toFinset_setOf, h, mem_filter, mem_univ, true_and, List.toFinset_cons,\n          List.toFinset_nil, insert_emptyc_eq, mem_insert, mem_singleton, s]\n        exact sq_eq_sq_iff_eq_or_eq_neg\n      norm_cast\n      rw [h₁, List.toFinset_cons, List.toFinset_cons, List.toFinset_nil]\n      exact card_pair (Ne.symm (mt (Ring.eq_self_iff_eq_zero_of_char_ne_two hF).mp h₀))\n    · rw [quadraticChar_neg_one_iff_not_isSquare.mpr h]\n      simp only [neg_add_cancel, Int.natCast_eq_zero, card_eq_zero]\n      ext1\n      -- Porting note(https://github.com/leanprover-community/mathlib4/issues/5026):\n      -- added (Set.mem_toFinset), Set.mem_setOf\n      simp only [s, (Set.mem_toFinset), Set.mem_setOf, not_mem_empty, iff_false]\n      rw [isSquare_iff_exists_sq] at h\n      exact fun h' ↦ h ⟨_, h'.symm⟩\n\n"}
{"name":"quadraticChar_sum_zero","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Eq (Finset.univ.sum fun a => (quadraticChar F) a) 0","decl":"/-- The sum over the values of the quadratic character is zero when the characteristic is odd. -/\ntheorem quadraticChar_sum_zero (hF : ringChar F ≠ 2) : ∑ a : F, quadraticChar F a = 0 :=\n  sum_eq_zero_of_ne_one (quadraticChar_ne_one hF)\n\n"}
{"name":"quadraticChar_neg_one","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝² : Field F\ninst✝¹ : Fintype F\ninst✝ : DecidableEq F\nhF : Ne (ringChar F) 2\n⊢ Eq ((quadraticChar F) (-1)) (ZMod.χ₄ ↑(Fintype.card F))","decl":"/-- The value of the quadratic character at `-1` -/\ntheorem quadraticChar_neg_one [DecidableEq F] (hF : ringChar F ≠ 2) :\n    quadraticChar F (-1) = χ₄ (Fintype.card F) := by\n  have h := quadraticChar_eq_pow_of_char_ne_two hF (neg_ne_zero.mpr one_ne_zero)\n  rw [h, χ₄_eq_neg_one_pow (FiniteField.odd_card_of_char_ne_two hF)]\n  generalize Fintype.card F / 2 = n\n  cases' Nat.even_or_odd n with h₂ h₂\n  · simp only [Even.neg_one_pow h₂, if_true]\n  · simp only [Odd.neg_one_pow h₂, Ring.neg_one_ne_one_of_char_ne_two hF, ite_false]\n\n"}
{"name":"FiniteField.isSquare_neg_one_iff","module":"Mathlib.NumberTheory.LegendreSymbol.QuadraticChar.Basic","initialProofState":"F : Type u_1\ninst✝¹ : Field F\ninst✝ : Fintype F\n⊢ Iff (IsSquare (-1)) (Ne (HMod.hMod (Fintype.card F) 4) 3)","decl":"/-- `-1` is a square in `F` iff `#F` is not congruent to `3` mod `4`. -/\ntheorem FiniteField.isSquare_neg_one_iff : IsSquare (-1 : F) ↔ Fintype.card F % 4 ≠ 3 := by\n  classical -- suggested by the linter (instead of `[DecidableEq F]`)\n  by_cases hF : ringChar F = 2\n  · simp only [FiniteField.isSquare_of_char_two hF, Ne, true_iff]\n    exact fun hf ↦\n      one_ne_zero <|\n        (Nat.odd_of_mod_four_eq_three hf).symm.trans <| FiniteField.even_card_of_char_two hF\n  · have h₁ := FiniteField.odd_card_of_char_ne_two hF\n    rw [← quadraticChar_one_iff_isSquare (neg_ne_zero.mpr (one_ne_zero' F)),\n      quadraticChar_neg_one hF, χ₄_nat_eq_if_mod_four, h₁]\n    omega\n\n"}
