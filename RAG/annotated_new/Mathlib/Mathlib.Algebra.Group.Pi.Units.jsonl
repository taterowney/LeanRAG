{"name":"MulEquiv.val_inv_piUnits_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nf : Units ((i : ι) → M i)\ni : ι\n⊢ Eq (↑(Inv.inv (MulEquiv.piUnits f i))) (f.inv i)","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.val_neg_piAddUnits_symm_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nf : (i : ι) → AddUnits (M i)\nx✝ : ι\n⊢ Eq (↑(Neg.neg (AddEquiv.piAddUnits.symm f)) x✝) (f x✝).neg","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.val_piAddUnits_symm_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nf : (i : ι) → AddUnits (M i)\nx✝ : ι\n⊢ Eq (↑(AddEquiv.piAddUnits.symm f) x✝) ↑(f x✝)","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulEquiv.val_inv_piUnits_symm_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nf : (i : ι) → Units (M i)\nx✝ : ι\n⊢ Eq (↑(Inv.inv (MulEquiv.piUnits.symm f)) x✝) (f x✝).inv","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulEquiv.val_piUnits_symm_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nf : (i : ι) → Units (M i)\nx✝ : ι\n⊢ Eq (↑(MulEquiv.piUnits.symm f) x✝) ↑(f x✝)","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.val_piAddUnits_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nf : AddUnits ((i : ι) → M i)\ni : ι\n⊢ Eq (↑(AddEquiv.piAddUnits f i)) (↑f i)","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"AddEquiv.val_neg_piAddUnits_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nf : AddUnits ((i : ι) → M i)\ni : ι\n⊢ Eq (↑(Neg.neg (AddEquiv.piAddUnits f i))) (f.neg i)","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"MulEquiv.val_piUnits_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nf : Units ((i : ι) → M i)\ni : ι\n⊢ Eq (↑(MulEquiv.piUnits f i)) (↑f i)","decl":"open Units in\n/-- The monoid equivalence between units of a product,\nand the product of the units of each monoid. -/\n@[to_additive (attr := simps)\n  \"The additive-monoid equivalence between (additive) units of a product,\n  and the product of the (additive) units of each monoid.\"]\ndef MulEquiv.piUnits : (Π i, M i)ˣ ≃* Π i, (M i)ˣ where\n  toFun f i := ⟨f.val i, f.inv i, congr_fun f.val_inv i, congr_fun f.inv_val i⟩\n  invFun f := ⟨(val <| f ·), (inv <| f ·), funext (val_inv <| f ·), funext (inv_val <| f ·)⟩\n  left_inv _ := rfl\n  right_inv _ := rfl\n  map_mul' _ _ := rfl\n\n"}
{"name":"Pi.isUnit_iff","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nx : (i : ι) → M i\n⊢ Iff (IsUnit x) (∀ (i : ι), IsUnit (x i))","decl":"@[to_additive]\nlemma Pi.isUnit_iff :\n    IsUnit x ↔ ∀ i, IsUnit (x i) := by\n  simp_rw [isUnit_iff_exists, funext_iff, ← forall_and]\n  exact Classical.skolem (p := fun i y ↦ x i * y = 1 ∧ y * x i = 1).symm\n\n"}
{"name":"Pi.isAddUnit_iff","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nx : (i : ι) → M i\n⊢ Iff (IsAddUnit x) (∀ (i : ι), IsAddUnit (x i))","decl":"@[to_additive]\nlemma Pi.isUnit_iff :\n    IsUnit x ↔ ∀ i, IsUnit (x i) := by\n  simp_rw [isUnit_iff_exists, funext_iff, ← forall_and]\n  exact Classical.skolem (p := fun i y ↦ x i * y = 1 ∧ y * x i = 1).symm\n\n"}
{"name":"IsUnit.apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nx : (i : ι) → M i\na✝ : IsUnit x\ni : ι\n⊢ IsUnit (x i)","decl":"@[to_additive]\nalias ⟨IsUnit.apply, _⟩ := Pi.isUnit_iff\n\n"}
{"name":"IsAddUnit.apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nx : (i : ι) → M i\na✝ : IsAddUnit x\ni : ι\n⊢ IsAddUnit (x i)","decl":"@[to_additive]\nalias ⟨IsUnit.apply, _⟩ := Pi.isUnit_iff\n\n"}
{"name":"IsUnit.val_inv_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → Monoid (M i)\nx : (i : ι) → M i\nhx : IsUnit x\ni : ι\n⊢ Eq (↑(Inv.inv hx.unit) i) ↑(Inv.inv ⋯.unit)","decl":"@[to_additive]\nlemma IsUnit.val_inv_apply (hx : IsUnit x) (i : ι) : (hx.unit⁻¹).1 i = (hx.apply i).unit⁻¹ := by\n  rw [← Units.inv_eq_val_inv, ← MulEquiv.val_inv_piUnits_apply]; congr; ext; rfl\n"}
{"name":"IsAddUnit.val_neg_apply","module":"Mathlib.Algebra.Group.Pi.Units","initialProofState":"ι : Type u_1\nM : ι → Type u_2\ninst✝ : (i : ι) → AddMonoid (M i)\nx : (i : ι) → M i\nhx : IsAddUnit x\ni : ι\n⊢ Eq (↑(Neg.neg hx.addUnit) i) ↑(Neg.neg ⋯.addUnit)","decl":"@[to_additive]\nlemma IsUnit.val_inv_apply (hx : IsUnit x) (i : ι) : (hx.unit⁻¹).1 i = (hx.apply i).unit⁻¹ := by\n  rw [← Units.inv_eq_val_inv, ← MulEquiv.val_inv_piUnits_apply]; congr; ext; rfl\n"}
