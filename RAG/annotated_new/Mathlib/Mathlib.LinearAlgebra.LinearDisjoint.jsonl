{"name":"Submodule.linearDisjoint_iff","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Iff (M.LinearDisjoint N) (Function.Injective ⇑(M.mulMap N))","decl":"/-- Two submodules `M` and `N` in an algebra `S` over `R` are linearly disjoint if the natural map\n`M ⊗[R] N →ₗ[R] S` induced by multiplication in `S` is injective. -/\n@[mk_iff]\nprotected structure LinearDisjoint : Prop where\n  injective : Function.Injective (mulMap M N)\n\n"}
{"name":"Submodule.LinearDisjoint.injective","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nself : M.LinearDisjoint N\n⊢ Function.Injective ⇑(M.mulMap N)","decl":"/-- Two submodules `M` and `N` in an algebra `S` over `R` are linearly disjoint if the natural map\n`M ⊗[R] N →ₗ[R] S` induced by multiplication in `S` is injective. -/\n@[mk_iff]\nprotected structure LinearDisjoint : Prop where\n  injective : Function.Injective (mulMap M N)\n\n"}
{"name":"Submodule.LinearDisjoint.val_mulMap_tmul","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nm : Subtype fun x => Membership.mem M x\nn : Subtype fun x => Membership.mem N x\n⊢ Eq (↑(H.mulMap (TensorProduct.tmul R m n))) (HMul.hMul ↑m ↑n)","decl":"@[simp]\ntheorem LinearDisjoint.val_mulMap_tmul (H : M.LinearDisjoint N) (m : M) (n : N) :\n    (H.mulMap (m ⊗ₜ[R] n) : S) = m.1 * n.1 := rfl\n\n"}
{"name":"Submodule.LinearDisjoint.of_subsingleton","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\ninst✝ : Subsingleton R\n⊢ M.LinearDisjoint N","decl":"@[nontriviality]\ntheorem LinearDisjoint.of_subsingleton [Subsingleton R] : M.LinearDisjoint N :=\n  haveI : Subsingleton S := Module.subsingleton R S\n  ⟨Function.injective_of_subsingleton _⟩\n\n"}
{"name":"Submodule.LinearDisjoint.of_subsingleton_top","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommSemiring R\ninst✝² : Semiring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\ninst✝ : Subsingleton S\n⊢ M.LinearDisjoint N","decl":"@[nontriviality]\ntheorem LinearDisjoint.of_subsingleton_top [Subsingleton S] : M.LinearDisjoint N :=\n  ⟨Function.injective_of_subsingleton _⟩\n\n"}
{"name":"Submodule.linearDisjoint_op","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Iff (M.LinearDisjoint N) ((Submodule.equivOpposite.symm (MulOpposite.op N)).LinearDisjoint (Submodule.equivOpposite.symm (MulOpposite.op M)))","decl":"/-- Linear disjointness is preserved by taking multiplicative opposite. -/\ntheorem linearDisjoint_op :\n    M.LinearDisjoint N ↔ (equivOpposite.symm (MulOpposite.op N)).LinearDisjoint\n      (equivOpposite.symm (MulOpposite.op M)) := by\n  simp only [linearDisjoint_iff, mulMap_op, LinearMap.coe_comp,\n    LinearEquiv.coe_coe, EquivLike.comp_injective, EquivLike.injective_comp]\n\n"}
{"name":"Submodule.LinearDisjoint.op","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\na✝ : M.LinearDisjoint N\n⊢ (Submodule.equivOpposite.symm (MulOpposite.op N)).LinearDisjoint (Submodule.equivOpposite.symm (MulOpposite.op M))","decl":"alias ⟨LinearDisjoint.op, LinearDisjoint.of_op⟩ := linearDisjoint_op\n\n"}
{"name":"Submodule.LinearDisjoint.of_op","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\na✝ : (Submodule.equivOpposite.symm (MulOpposite.op N)).LinearDisjoint (Submodule.equivOpposite.symm (MulOpposite.op M))\n⊢ M.LinearDisjoint N","decl":"alias ⟨LinearDisjoint.op, LinearDisjoint.of_op⟩ := linearDisjoint_op\n\n"}
{"name":"Submodule.LinearDisjoint.symm_of_commute","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nhc : ∀ (m : Subtype fun x => Membership.mem M x) (n : Subtype fun x => Membership.mem N x), Commute ↑m ↑n\n⊢ N.LinearDisjoint M","decl":"/-- Linear disjointness is symmetric if elements in the module commute. -/\ntheorem LinearDisjoint.symm_of_commute (H : M.LinearDisjoint N)\n    (hc : ∀ (m : M) (n : N), Commute m.1 n.1) : N.LinearDisjoint M := by\n  rw [linearDisjoint_iff, mulMap_comm_of_commute M N hc]\n  exact ((TensorProduct.comm R N M).toEquiv.injective_comp _).2 H.injective\n\n"}
{"name":"Submodule.linearDisjoint_comm_of_commute","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nhc : ∀ (m : Subtype fun x => Membership.mem M x) (n : Subtype fun x => Membership.mem N x), Commute ↑m ↑n\n⊢ Iff (M.LinearDisjoint N) (N.LinearDisjoint M)","decl":"/-- Linear disjointness is symmetric if elements in the module commute. -/\ntheorem linearDisjoint_comm_of_commute\n    (hc : ∀ (m : M) (n : N), Commute m.1 n.1) : M.LinearDisjoint N ↔ N.LinearDisjoint M :=\n  ⟨fun H ↦ H.symm_of_commute hc, fun H ↦ H.symm_of_commute fun _ _ ↦ (hc _ _).symm⟩\n\n"}
{"name":"Submodule.LinearDisjoint.map","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁶ : CommSemiring R\ninst✝⁵ : Semiring S\ninst✝⁴ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nT : Type w\ninst✝³ : Semiring T\ninst✝² : Algebra R T\nF : Type u_1\ninst✝¹ : FunLike F S T\ninst✝ : AlgHomClass F R S T\nf : F\nhf : Function.Injective ⇑f\n⊢ (Submodule.map f M).LinearDisjoint (Submodule.map f N)","decl":"/-- Linear disjointness is preserved by injective algebra homomorphisms. -/\ntheorem map (H : M.LinearDisjoint N) {T : Type w} [Semiring T] [Algebra R T]\n    {F : Type*} [FunLike F S T] [AlgHomClass F R S T] (f : F) (hf : Function.Injective f) :\n    (M.map f).LinearDisjoint (N.map f) := by\n  rw [linearDisjoint_iff] at H ⊢\n  have : _ ∘ₗ\n    (TensorProduct.congr (M.equivMapOfInjective f hf) (N.equivMapOfInjective f hf)).toLinearMap\n      = _ := M.mulMap_map_comp_eq N f\n  replace H : Function.Injective ((f : S →ₗ[R] T) ∘ₗ mulMap M N) := hf.comp H\n  simpa only [← this, LinearMap.coe_comp, LinearEquiv.coe_coe, EquivLike.injective_comp] using H\n\n"}
{"name":"Submodule.LinearDisjoint.of_basis_left'","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nι : Type u_1\nm : Basis ι R (Subtype fun x => Membership.mem M x)\nH : Function.Injective ⇑(Submodule.mulLeftMap N ⇑m)\n⊢ M.LinearDisjoint N","decl":"/-- If `{ m_i }` is an `R`-basis of `M`, which is also `N`-linearly independent\n(in this result it is stated as `Submodule.mulLeftMap` is injective),\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_basis_left' {ι : Type*} (m : Basis ι R M)\n    (H : Function.Injective (mulLeftMap N m)) : M.LinearDisjoint N := by\n  classical simp_rw [mulLeftMap_eq_mulMap_comp, ← Basis.coe_repr_symm,\n    ← LinearEquiv.coe_rTensor, LinearEquiv.comp_coe, LinearMap.coe_comp,\n    LinearEquiv.coe_coe, EquivLike.injective_comp] at H\n  exact ⟨H⟩\n\n"}
{"name":"Submodule.LinearDisjoint.of_basis_right'","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nι : Type u_1\nn : Basis ι R (Subtype fun x => Membership.mem N x)\nH : Function.Injective ⇑(M.mulRightMap ⇑n)\n⊢ M.LinearDisjoint N","decl":"/-- If `{ n_i }` is an `R`-basis of `N`, which is also `M`-linearly independent\n(in this result it is stated as `Submodule.mulRightMap` is injective),\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_basis_right' {ι : Type*} (n : Basis ι R N)\n    (H : Function.Injective (mulRightMap M n)) : M.LinearDisjoint N := by\n  classical simp_rw [mulRightMap_eq_mulMap_comp, ← Basis.coe_repr_symm,\n    ← LinearEquiv.coe_lTensor, LinearEquiv.comp_coe, LinearMap.coe_comp,\n    LinearEquiv.coe_coe, EquivLike.injective_comp] at H\n  exact ⟨H⟩\n\n"}
{"name":"Submodule.LinearDisjoint.of_basis_mul'","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nκ : Type u_1\nι : Type u_2\nm : Basis κ R (Subtype fun x => Membership.mem M x)\nn : Basis ι R (Subtype fun x => Membership.mem N x)\nH : Function.Injective ⇑(Finsupp.linearCombination R fun i => HMul.hMul ↑(m i.1) ↑(n i.2))\n⊢ M.LinearDisjoint N","decl":"/-- If `{ m_i }` is an `R`-basis of `M`, if `{ n_i }` is an `R`-basis of `N`,\nsuch that the family `{ m_i * n_j }` in `S` is `R`-linearly independent\n(in this result it is stated as the relevant `Finsupp.linearCombination` is injective),\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_basis_mul' {κ ι : Type*} (m : Basis κ R M) (n : Basis ι R N)\n    (H : Function.Injective (Finsupp.linearCombination R fun i : κ × ι ↦ (m i.1 * n i.2 : S))) :\n    M.LinearDisjoint N := by\n  let i0 := (finsuppTensorFinsupp' R κ ι).symm\n  let i1 := TensorProduct.congr m.repr n.repr\n  let i := mulMap M N ∘ₗ (i0.trans i1.symm).toLinearMap\n  have : i = Finsupp.linearCombination R fun i : κ × ι ↦ (m i.1 * n i.2 : S) := by\n    ext x\n    simp [i, i0, i1, finsuppTensorFinsupp'_symm_single_eq_single_one_tmul]\n  simp_rw [← this, i, LinearMap.coe_comp, LinearEquiv.coe_coe, EquivLike.injective_comp] at H\n  exact ⟨H⟩\n\n"}
{"name":"Submodule.LinearDisjoint.bot_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\n⊢ Bot.bot.LinearDisjoint N","decl":"/-- The zero module is linearly disjoint with any other submodules. -/\ntheorem bot_left : (⊥ : Submodule R S).LinearDisjoint N :=\n  ⟨Function.injective_of_subsingleton _⟩\n\n"}
{"name":"Submodule.LinearDisjoint.bot_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\n⊢ M.LinearDisjoint Bot.bot","decl":"/-- The zero module is linearly disjoint with any other submodules. -/\ntheorem bot_right : M.LinearDisjoint (⊥ : Submodule R S) :=\n  ⟨Function.injective_of_subsingleton _⟩\n\n"}
{"name":"Submodule.LinearDisjoint.one_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nN : Submodule R S\n⊢ Submodule.LinearDisjoint 1 N","decl":"/-- The image of `R` in `S` is linearly disjoint with any other submodules. -/\ntheorem one_left : (1 : Submodule R S).LinearDisjoint N := by\n  rw [linearDisjoint_iff, ← Algebra.toSubmodule_bot, mulMap_one_left_eq]\n  exact N.injective_subtype.comp N.lTensorOne.injective\n\n"}
{"name":"Submodule.LinearDisjoint.one_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM : Submodule R S\n⊢ M.LinearDisjoint 1","decl":"/-- The image of `R` in `S` is linearly disjoint with any other submodules. -/\ntheorem one_right : M.LinearDisjoint (1 : Submodule R S) := by\n  rw [linearDisjoint_iff, ← Algebra.toSubmodule_bot, mulMap_one_right_eq]\n  exact M.injective_subtype.comp M.rTensorOne.injective\n\n"}
{"name":"Submodule.LinearDisjoint.of_linearDisjoint_fg_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : ∀ (M' : Submodule R S), LE.le M' M → M'.FG → M'.LinearDisjoint N\n⊢ M.LinearDisjoint N","decl":"/-- If for any finitely generated submodules `M'` of `M`, `M'` and `N` are linearly disjoint,\nthen `M` and `N` themselves are linearly disjoint. -/\ntheorem of_linearDisjoint_fg_left\n    (H : ∀ M' : Submodule R S, M' ≤ M → M'.FG → M'.LinearDisjoint N) :\n    M.LinearDisjoint N := (linearDisjoint_iff _ _).2 fun x y hxy ↦ by\n  obtain ⟨M', hM, hFG, h⟩ :=\n    TensorProduct.exists_finite_submodule_left_of_finite' {x, y} (Set.toFinite _)\n  rw [Module.Finite.iff_fg] at hFG\n  obtain ⟨x', hx'⟩ := h (show x ∈ {x, y} by simp)\n  obtain ⟨y', hy'⟩ := h (show y ∈ {x, y} by simp)\n  rw [← hx', ← hy']; congr\n  exact (H M' hM hFG).injective (by simp [← mulMap_comp_rTensor _ hM, hx', hy', hxy])\n\n"}
{"name":"Submodule.LinearDisjoint.of_linearDisjoint_fg_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : ∀ (N' : Submodule R S), LE.le N' N → N'.FG → M.LinearDisjoint N'\n⊢ M.LinearDisjoint N","decl":"/-- If for any finitely generated submodules `N'` of `N`, `M` and `N'` are linearly disjoint,\nthen `M` and `N` themselves are linearly disjoint. -/\ntheorem of_linearDisjoint_fg_right\n    (H : ∀ N' : Submodule R S, N' ≤ N → N'.FG → M.LinearDisjoint N') :\n    M.LinearDisjoint N := (linearDisjoint_iff _ _).2 fun x y hxy ↦ by\n  obtain ⟨N', hN, hFG, h⟩ :=\n    TensorProduct.exists_finite_submodule_right_of_finite' {x, y} (Set.toFinite _)\n  rw [Module.Finite.iff_fg] at hFG\n  obtain ⟨x', hx'⟩ := h (show x ∈ {x, y} by simp)\n  obtain ⟨y', hy'⟩ := h (show y ∈ {x, y} by simp)\n  rw [← hx', ← hy']; congr\n  exact (H N' hN hFG).injective (by simp [← mulMap_comp_lTensor _ hN, hx', hy', hxy])\n\n"}
{"name":"Submodule.LinearDisjoint.of_linearDisjoint_fg","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : Semiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : ∀ (M' N' : Submodule R S), LE.le M' M → LE.le N' N → M'.FG → N'.FG → M'.LinearDisjoint N'\n⊢ M.LinearDisjoint N","decl":"/-- If for any finitely generated submodules `M'` and `N'` of `M` and `N`, respectively,\n`M'` and `N'` are linearly disjoint, then `M` and `N` themselves are linearly disjoint. -/\ntheorem of_linearDisjoint_fg\n    (H : ∀ (M' N' : Submodule R S), M' ≤ M → N' ≤ N → M'.FG → N'.FG → M'.LinearDisjoint N') :\n    M.LinearDisjoint N :=\n  of_linearDisjoint_fg_left _ _ fun _ hM hM' ↦\n    of_linearDisjoint_fg_right _ _ fun _ hN hN' ↦ H _ _ hM hN hM' hN'\n\n"}
{"name":"Submodule.LinearDisjoint.symm","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\n⊢ N.LinearDisjoint M","decl":"/-- Linear disjointness is symmetric in a commutative ring. -/\ntheorem LinearDisjoint.symm (H : M.LinearDisjoint N) : N.LinearDisjoint M :=\n  H.symm_of_commute fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Submodule.linearDisjoint_comm","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommSemiring R\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nM N : Submodule R S\n⊢ Iff (M.LinearDisjoint N) (N.LinearDisjoint M)","decl":"/-- Linear disjointness is symmetric in a commutative ring. -/\ntheorem linearDisjoint_comm : M.LinearDisjoint N ↔ N.LinearDisjoint M :=\n  ⟨LinearDisjoint.symm, LinearDisjoint.symm⟩\n\n"}
{"name":"Submodule.LinearDisjoint.linearIndependent_left_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\nι : Type u_1\nm : ι → Subtype fun x => Membership.mem M x\nhm : LinearIndependent R m\n⊢ Eq (LinearMap.ker (Submodule.mulLeftMap N m)) Bot.bot","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if `N` is a flat `R`-module, then for any family of\n`R`-linearly independent elements `{ m_i }` of `M`, they are also `N`-linearly independent,\nin the sense that the `R`-linear map from `ι →₀ N` to `S` which maps `{ n_i }`\nto the sum of `m_i * n_i` (`Submodule.mulLeftMap N m`) has trivial kernel. -/\ntheorem linearIndependent_left_of_flat (H : M.LinearDisjoint N) [Module.Flat R N]\n    {ι : Type*} {m : ι → M} (hm : LinearIndependent R m) : LinearMap.ker (mulLeftMap N m) = ⊥ := by\n  refine LinearMap.ker_eq_bot_of_injective ?_\n  classical simp_rw [mulLeftMap_eq_mulMap_comp, LinearMap.coe_comp, LinearEquiv.coe_coe,\n    ← Function.comp_assoc, EquivLike.injective_comp]\n  rw [LinearIndependent] at hm\n  exact H.injective.comp (Module.Flat.rTensor_preserves_injective_linearMap (M := N) _ hm)\n\n"}
{"name":"Submodule.LinearDisjoint.of_basis_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nM N : Submodule R S\nι : Type u_1\nm : Basis ι R (Subtype fun x => Membership.mem M x)\nH : Eq (LinearMap.ker (Submodule.mulLeftMap N ⇑m)) Bot.bot\n⊢ M.LinearDisjoint N","decl":"/-- If `{ m_i }` is an `R`-basis of `M`, which is also `N`-linearly independent,\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_basis_left {ι : Type*} (m : Basis ι R M)\n    (H : LinearMap.ker (mulLeftMap N m) = ⊥) : M.LinearDisjoint N := by\n  -- need this instance otherwise `LinearMap.ker_eq_bot` does not work\n  letI : AddCommGroup (ι →₀ N) := Finsupp.instAddCommGroup\n  exact of_basis_left' M N m (LinearMap.ker_eq_bot.1 H)\n\n"}
{"name":"Submodule.LinearDisjoint.linearIndependent_right_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\nι : Type u_1\nn : ι → Subtype fun x => Membership.mem N x\nhn : LinearIndependent R n\n⊢ Eq (LinearMap.ker (M.mulRightMap n)) Bot.bot","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if `M` is a flat `R`-module, then for any family of\n`R`-linearly independent elements `{ n_i }` of `N`, they are also `M`-linearly independent,\nin the sense that the `R`-linear map from `ι →₀ M` to `S` which maps `{ m_i }`\nto the sum of `m_i * n_i` (`Submodule.mulRightMap M n`) has trivial kernel. -/\ntheorem linearIndependent_right_of_flat (H : M.LinearDisjoint N) [Module.Flat R M]\n    {ι : Type*} {n : ι → N} (hn : LinearIndependent R n) : LinearMap.ker (mulRightMap M n) = ⊥ := by\n  refine LinearMap.ker_eq_bot_of_injective ?_\n  classical simp_rw [mulRightMap_eq_mulMap_comp, LinearMap.coe_comp, LinearEquiv.coe_coe,\n    ← Function.comp_assoc, EquivLike.injective_comp]\n  rw [LinearIndependent] at hn\n  exact H.injective.comp (Module.Flat.lTensor_preserves_injective_linearMap (M := M) _ hn)\n\n"}
{"name":"Submodule.LinearDisjoint.of_basis_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nM N : Submodule R S\nι : Type u_1\nn : Basis ι R (Subtype fun x => Membership.mem N x)\nH : Eq (LinearMap.ker (M.mulRightMap ⇑n)) Bot.bot\n⊢ M.LinearDisjoint N","decl":"/-- If `{ n_i }` is an `R`-basis of `N`, which is also `M`-linearly independent,\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_basis_right {ι : Type*} (n : Basis ι R N)\n    (H : LinearMap.ker (mulRightMap M n) = ⊥) : M.LinearDisjoint N := by\n  -- need this instance otherwise `LinearMap.ker_eq_bot` does not work\n  letI : AddCommGroup (ι →₀ M) := Finsupp.instAddCommGroup\n  exact of_basis_right' M N n (LinearMap.ker_eq_bot.1 H)\n\n"}
{"name":"Submodule.LinearDisjoint.linearIndependent_mul_of_flat_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\nκ : Type u_1\nι : Type u_2\nm : κ → Subtype fun x => Membership.mem M x\nn : ι → Subtype fun x => Membership.mem N x\nhm : LinearIndependent R m\nhn : LinearIndependent R n\n⊢ LinearIndependent R fun i => HMul.hMul ↑(m i.1) ↑(n i.2)","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if `M` is flat, then for any family of\n`R`-linearly independent elements `{ m_i }` of `M`, and any family of\n`R`-linearly independent elements `{ n_j }` of `N`, the family `{ m_i * n_j }` in `S` is\nalso `R`-linearly independent. -/\ntheorem linearIndependent_mul_of_flat_left (H : M.LinearDisjoint N) [Module.Flat R M]\n    {κ ι : Type*} {m : κ → M} {n : ι → N} (hm : LinearIndependent R m)\n    (hn : LinearIndependent R n) : LinearIndependent R fun (i : κ × ι) ↦ (m i.1).1 * (n i.2).1 := by\n  rw [LinearIndependent] at hm hn ⊢\n  let i0 := (finsuppTensorFinsupp' R κ ι).symm\n  let i1 := LinearMap.rTensor (ι →₀ R) (Finsupp.linearCombination R m)\n  let i2 := LinearMap.lTensor M (Finsupp.linearCombination R n)\n  let i := mulMap M N ∘ₗ i2 ∘ₗ i1 ∘ₗ i0.toLinearMap\n  have h1 : Function.Injective i1 := Module.Flat.rTensor_preserves_injective_linearMap _ hm\n  have h2 : Function.Injective i2 := Module.Flat.lTensor_preserves_injective_linearMap _ hn\n  have h : Function.Injective i := H.injective.comp h2 |>.comp h1 |>.comp i0.injective\n  have : i = Finsupp.linearCombination R fun i ↦ (m i.1).1 * (n i.2).1 := by\n    ext x\n    simp [i, i0, i1, i2, finsuppTensorFinsupp'_symm_single_eq_single_one_tmul]\n  rwa [this] at h\n\n"}
{"name":"Submodule.LinearDisjoint.linearIndependent_mul_of_flat_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\nκ : Type u_1\nι : Type u_2\nm : κ → Subtype fun x => Membership.mem M x\nn : ι → Subtype fun x => Membership.mem N x\nhm : LinearIndependent R m\nhn : LinearIndependent R n\n⊢ LinearIndependent R fun i => HMul.hMul ↑(m i.1) ↑(n i.2)","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if `N` is flat, then for any family of\n`R`-linearly independent elements `{ m_i }` of `M`, and any family of\n`R`-linearly independent elements `{ n_j }` of `N`, the family `{ m_i * n_j }` in `S` is\nalso `R`-linearly independent. -/\ntheorem linearIndependent_mul_of_flat_right (H : M.LinearDisjoint N) [Module.Flat R N]\n    {κ ι : Type*} {m : κ → M} {n : ι → N} (hm : LinearIndependent R m)\n    (hn : LinearIndependent R n) : LinearIndependent R fun (i : κ × ι) ↦ (m i.1).1 * (n i.2).1 := by\n  rw [LinearIndependent] at hm hn ⊢\n  let i0 := (finsuppTensorFinsupp' R κ ι).symm\n  let i1 := LinearMap.lTensor (κ →₀ R) (Finsupp.linearCombination R n)\n  let i2 := LinearMap.rTensor N (Finsupp.linearCombination R m)\n  let i := mulMap M N ∘ₗ i2 ∘ₗ i1 ∘ₗ i0.toLinearMap\n  have h1 : Function.Injective i1 := Module.Flat.lTensor_preserves_injective_linearMap _ hn\n  have h2 : Function.Injective i2 := Module.Flat.rTensor_preserves_injective_linearMap _ hm\n  have h : Function.Injective i := H.injective.comp h2 |>.comp h1 |>.comp i0.injective\n  have : i = Finsupp.linearCombination R fun i ↦ (m i.1).1 * (n i.2).1 := by\n    ext x\n    simp [i, i0, i1, i2, finsuppTensorFinsupp'_symm_single_eq_single_one_tmul]\n  rwa [this] at h\n\n"}
{"name":"Submodule.LinearDisjoint.linearIndependent_mul_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem M x)) (Module.Flat R (Subtype fun x => Membership.mem N x))\nκ : Type u_1\nι : Type u_2\nm : κ → Subtype fun x => Membership.mem M x\nn : ι → Subtype fun x => Membership.mem N x\nhm : LinearIndependent R m\nhn : LinearIndependent R n\n⊢ LinearIndependent R fun i => HMul.hMul ↑(m i.1) ↑(n i.2)","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if one of `M` and `N` is flat, then for any family of\n`R`-linearly independent elements `{ m_i }` of `M`, and any family of\n`R`-linearly independent elements `{ n_j }` of `N`, the family `{ m_i * n_j }` in `S` is\nalso `R`-linearly independent. -/\ntheorem linearIndependent_mul_of_flat (H : M.LinearDisjoint N)\n    (hf : Module.Flat R M ∨ Module.Flat R N)\n    {κ ι : Type*} {m : κ → M} {n : ι → N} (hm : LinearIndependent R m)\n    (hn : LinearIndependent R n) : LinearIndependent R fun (i : κ × ι) ↦ (m i.1).1 * (n i.2).1 := by\n  rcases hf with _ | _\n  · exact H.linearIndependent_mul_of_flat_left hm hn\n  · exact H.linearIndependent_mul_of_flat_right hm hn\n\n"}
{"name":"Submodule.LinearDisjoint.of_basis_mul","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nM N : Submodule R S\nκ : Type u_1\nι : Type u_2\nm : Basis κ R (Subtype fun x => Membership.mem M x)\nn : Basis ι R (Subtype fun x => Membership.mem N x)\nH : LinearIndependent R fun i => HMul.hMul ↑(m i.1) ↑(n i.2)\n⊢ M.LinearDisjoint N","decl":"/-- If `{ m_i }` is an `R`-basis of `M`, if `{ n_j }` is an `R`-basis of `N`,\nsuch that the family `{ m_i * n_j }` in `S` is `R`-linearly independent,\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_basis_mul {κ ι : Type*} (m : Basis κ R M) (n : Basis ι R N)\n    (H : LinearIndependent R fun (i : κ × ι) ↦ (m i.1).1 * (n i.2).1) : M.LinearDisjoint N := by\n  rw [LinearIndependent] at H\n  exact of_basis_mul' M N m n H\n\n"}
{"name":"Submodule.LinearDisjoint.of_le_left_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nM' : Submodule R S\nh : LE.le M' M\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\n⊢ M'.LinearDisjoint N","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if `N` is flat, then for any submodule `M'` of `M`,\n`M'` and `N` are also linearly disjoint. -/\ntheorem of_le_left_of_flat (H : M.LinearDisjoint N) {M' : Submodule R S}\n    (h : M' ≤ M) [Module.Flat R N] : M'.LinearDisjoint N := by\n  let i := mulMap M N ∘ₗ (inclusion h).rTensor N\n  have hi : Function.Injective i := H.injective.comp <|\n    Module.Flat.rTensor_preserves_injective_linearMap _ <| inclusion_injective h\n  have : i = mulMap M' N := by ext; simp [i]\n  exact ⟨this ▸ hi⟩\n\n"}
{"name":"Submodule.LinearDisjoint.of_le_right_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nN' : Submodule R S\nh : LE.le N' N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\n⊢ M.LinearDisjoint N'","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, if `M` is flat, then for any submodule `N'` of `N`,\n`M` and `N'` are also linearly disjoint. -/\ntheorem of_le_right_of_flat (H : M.LinearDisjoint N) {N' : Submodule R S}\n    (h : N' ≤ N) [Module.Flat R M] : M.LinearDisjoint N' := by\n  let i := mulMap M N ∘ₗ (inclusion h).lTensor M\n  have hi : Function.Injective i := H.injective.comp <|\n    Module.Flat.lTensor_preserves_injective_linearMap _ <| inclusion_injective h\n  have : i = mulMap M N' := by ext; simp [i]\n  exact ⟨this ▸ hi⟩\n\n"}
{"name":"Submodule.LinearDisjoint.of_le_of_flat_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nM' N' : Submodule R S\nhm : LE.le M' M\nhn : LE.le N' N\ninst✝¹ : Module.Flat R (Subtype fun x => Membership.mem N x)\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M' x)\n⊢ M'.LinearDisjoint N'","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, `M'` and `N'` are submodules of `M` and `N`,\nrespectively, such that `N` and `M'` are flat, then `M'` and `N'` are also linearly disjoint. -/\ntheorem of_le_of_flat_right (H : M.LinearDisjoint N) {M' N' : Submodule R S}\n    (hm : M' ≤ M) (hn : N' ≤ N) [Module.Flat R N] [Module.Flat R M'] :\n    M'.LinearDisjoint N' := (H.of_le_left_of_flat hm).of_le_right_of_flat hn\n\n"}
{"name":"Submodule.LinearDisjoint.of_le_of_flat_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nM' N' : Submodule R S\nhm : LE.le M' M\nhn : LE.le N' N\ninst✝¹ : Module.Flat R (Subtype fun x => Membership.mem M x)\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N' x)\n⊢ M'.LinearDisjoint N'","decl":"variable {M N} in\n/-- If `M` and `N` are linearly disjoint, `M'` and `N'` are submodules of `M` and `N`,\nrespectively, such that `M` and `N'` are flat, then `M'` and `N'` are also linearly disjoint. -/\ntheorem of_le_of_flat_left (H : M.LinearDisjoint N) {M' N' : Submodule R S}\n    (hm : M' ≤ M) (hn : N' ≤ N) [Module.Flat R M] [Module.Flat R N'] :\n    M'.LinearDisjoint N' := (H.of_le_right_of_flat hn).of_le_left_of_flat hm\n\n"}
{"name":"Submodule.LinearDisjoint.of_left_le_one_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nh : LE.le M 1\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\n⊢ M.LinearDisjoint N","decl":"/-- If `N` is flat, `M` is contained in `i(R)`, where `i : R → S` is the structure map,\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_left_le_one_of_flat (h : M ≤ 1) [Module.Flat R N] :\n    M.LinearDisjoint N := (one_left N).of_le_left_of_flat h\n\n"}
{"name":"Submodule.LinearDisjoint.of_right_le_one_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nh : LE.le N 1\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\n⊢ M.LinearDisjoint N","decl":"/-- If `M` is flat, `N` is contained in `i(R)`, where `i : R → S` is the structure map,\nthen `M` and `N` are linearly disjoint. -/\ntheorem of_right_le_one_of_flat (h : N ≤ 1) [Module.Flat R M] :\n    M.LinearDisjoint N := (one_right M).of_le_right_of_flat h\n\n"}
{"name":"Submodule.LinearDisjoint.not_linearIndependent_pair_of_commute_of_flat_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝¹ : Nontrivial R\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\na b : Subtype fun x => Membership.mem (Min.min M N) x\nhc : Commute ↑a ↑b\n⊢ Not (LinearIndependent R (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)))","decl":"/-- If `M` and `N` are linearly disjoint, if `M` is flat, then any two commutative\nelements of `↥(M ⊓ N)` are not `R`-linearly independent (namely, their span is not `R ^ 2`). -/\ntheorem not_linearIndependent_pair_of_commute_of_flat_left [Module.Flat R M]\n    (a b : ↥(M ⊓ N)) (hc : Commute a.1 b.1) : ¬LinearIndependent R ![a, b] := fun h ↦ by\n  let n : Fin 2 → N := (inclusion inf_le_right) ∘ ![a, b]\n  have hn : LinearIndependent R n := h.map' _ (ker_inclusion _ _ _)\n  -- need this instance otherwise it only has semigroup structure\n  letI : AddCommGroup (Fin 2 →₀ M) := Finsupp.instAddCommGroup\n  let m : Fin 2 →₀ M := .single 0 ⟨b.1, b.2.1⟩ - .single 1 ⟨a.1, a.2.1⟩\n  have hm : mulRightMap M n m = 0 := by simp [m, n, show _ * _ = _ * _ from hc]\n  rw [← LinearMap.mem_ker, H.linearIndependent_right_of_flat hn, mem_bot] at hm\n  simp only [Fin.isValue, sub_eq_zero, Finsupp.single_eq_single_iff, zero_ne_one, Subtype.mk.injEq,\n    SetLike.coe_eq_coe, false_and, false_or, m] at hm\n  repeat rw [AddSubmonoid.mk_eq_zero, ZeroMemClass.coe_eq_zero] at hm\n  exact h.ne_zero 0 hm.2\n\n"}
{"name":"Submodule.LinearDisjoint.not_linearIndependent_pair_of_commute_of_flat_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : Ring S\ninst✝² : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝¹ : Nontrivial R\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\na b : Subtype fun x => Membership.mem (Min.min M N) x\nhc : Commute ↑a ↑b\n⊢ Not (LinearIndependent R (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)))","decl":"/-- If `M` and `N` are linearly disjoint, if `N` is flat, then any two commutative\nelements of `↥(M ⊓ N)` are not `R`-linearly independent (namely, their span is not `R ^ 2`). -/\ntheorem not_linearIndependent_pair_of_commute_of_flat_right [Module.Flat R N]\n    (a b : ↥(M ⊓ N)) (hc : Commute a.1 b.1) : ¬LinearIndependent R ![a, b] := fun h ↦ by\n  let m : Fin 2 → M := (inclusion inf_le_left) ∘ ![a, b]\n  have hm : LinearIndependent R m := h.map' _ (ker_inclusion _ _ _)\n  -- need this instance otherwise it only has semigroup structure\n  letI : AddCommGroup (Fin 2 →₀ N) := Finsupp.instAddCommGroup\n  let n : Fin 2 →₀ N := .single 0 ⟨b.1, b.2.2⟩ - .single 1 ⟨a.1, a.2.2⟩\n  have hn : mulLeftMap N m n = 0 := by simp [m, n, show _ * _ = _ * _ from hc]\n  rw [← LinearMap.mem_ker, H.linearIndependent_left_of_flat hm, mem_bot] at hn\n  simp only [Fin.isValue, sub_eq_zero, Finsupp.single_eq_single_iff, zero_ne_one, Subtype.mk.injEq,\n    SetLike.coe_eq_coe, false_and, false_or, n] at hn\n  repeat rw [AddSubmonoid.mk_eq_zero, ZeroMemClass.coe_eq_zero] at hn\n  exact h.ne_zero 0 hn.2\n\n"}
{"name":"Submodule.LinearDisjoint.not_linearIndependent_pair_of_commute_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Nontrivial R\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem M x)) (Module.Flat R (Subtype fun x => Membership.mem N x))\na b : Subtype fun x => Membership.mem (Min.min M N) x\nhc : Commute ↑a ↑b\n⊢ Not (LinearIndependent R (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)))","decl":"/-- If `M` and `N` are linearly disjoint, if one of `M` and `N` is flat, then any two commutative\nelements of `↥(M ⊓ N)` are not `R`-linearly independent (namely, their span is not `R ^ 2`). -/\ntheorem not_linearIndependent_pair_of_commute_of_flat (hf : Module.Flat R M ∨ Module.Flat R N)\n    (a b : ↥(M ⊓ N)) (hc : Commute a.1 b.1) : ¬LinearIndependent R ![a, b] := by\n  rcases hf with _ | _\n  · exact H.not_linearIndependent_pair_of_commute_of_flat_left a b hc\n  · exact H.not_linearIndependent_pair_of_commute_of_flat_right a b hc\n\n"}
{"name":"Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : Ring S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem M x)) (Module.Flat R (Subtype fun x => Membership.mem N x))\nhc : ∀ (m n : Subtype fun x => Membership.mem (Min.min M N) x), Commute ↑m ↑n\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Min.min M N) x)) 1","decl":"/-- If `M` and `N` are linearly disjoint, if one of `M` and `N` is flat,\nif any two elements of `↥(M ⊓ N)` are commutative, then the rank of `↥(M ⊓ N)` is at most one. -/\ntheorem rank_inf_le_one_of_commute_of_flat (hf : Module.Flat R M ∨ Module.Flat R N)\n    (hc : ∀ (m n : ↥(M ⊓ N)), Commute m.1 n.1) : Module.rank R ↥(M ⊓ N) ≤ 1 := by\n  nontriviality R\n  refine _root_.rank_le fun s h ↦ ?_\n  by_contra hs\n  rw [not_le, ← Fintype.card_coe, Fintype.one_lt_card_iff_nontrivial] at hs\n  obtain ⟨a, b, hab⟩ := hs.exists_pair_ne\n  refine H.not_linearIndependent_pair_of_commute_of_flat hf a.1 b.1 (hc a.1 b.1) ?_\n  have := h.comp ![a, b] fun i j hij ↦ by\n    fin_cases i <;> fin_cases j\n    · rfl\n    · simp [hab] at hij\n    · simp [hab.symm] at hij\n    · rfl\n  convert this\n  ext i\n  fin_cases i <;> simp\n\n"}
{"name":"Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\nhc : ∀ (m n : Subtype fun x => Membership.mem (Min.min M N) x), Commute ↑m ↑n\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Min.min M N) x)) 1","decl":"/-- If `M` and `N` are linearly disjoint, if `M` is flat,\nif any two elements of `↥(M ⊓ N)` are commutative, then the rank of `↥(M ⊓ N)` is at most one. -/\ntheorem rank_inf_le_one_of_commute_of_flat_left [Module.Flat R M]\n    (hc : ∀ (m n : ↥(M ⊓ N)), Commute m.1 n.1) : Module.rank R ↥(M ⊓ N) ≤ 1 :=\n  H.rank_inf_le_one_of_commute_of_flat (Or.inl ‹_›) hc\n\n"}
{"name":"Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\nhc : ∀ (m n : Subtype fun x => Membership.mem (Min.min M N) x), Commute ↑m ↑n\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Min.min M N) x)) 1","decl":"/-- If `M` and `N` are linearly disjoint, if `N` is flat,\nif any two elements of `↥(M ⊓ N)` are commutative, then the rank of `↥(M ⊓ N)` is at most one. -/\ntheorem rank_inf_le_one_of_commute_of_flat_right [Module.Flat R N]\n    (hc : ∀ (m n : ↥(M ⊓ N)), Commute m.1 n.1) : Module.rank R ↥(M ⊓ N) ≤ 1 :=\n  H.rank_inf_le_one_of_commute_of_flat (Or.inr ‹_›) hc\n\n"}
{"name":"Submodule.LinearDisjoint.rank_le_one_of_commute_of_flat_of_self","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : Ring S\ninst✝¹ : Algebra R S\nM : Submodule R S\nH : M.LinearDisjoint M\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\nhc : ∀ (m n : Subtype fun x => Membership.mem M x), Commute ↑m ↑n\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem M x)) 1","decl":"/-- If `M` and itself are linearly disjoint, if `M` is flat,\nif any two elements of `M` are commutative, then the rank of `M` is at most one. -/\ntheorem rank_le_one_of_commute_of_flat_of_self (H : M.LinearDisjoint M) [Module.Flat R M]\n    (hc : ∀ (m n : M), Commute m.1 n.1) : Module.rank R M ≤ 1 := by\n  rw [← inf_of_le_left (le_refl M)] at hc ⊢\n  exact H.rank_inf_le_one_of_commute_of_flat_left hc\n\n"}
{"name":"Submodule.LinearDisjoint.not_linearIndependent_pair_of_flat_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝¹ : Nontrivial R\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\na b : Subtype fun x => Membership.mem (Min.min M N) x\n⊢ Not (LinearIndependent R (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)))","decl":"/-- The `Submodule.LinearDisjoint.not_linearIndependent_pair_of_commute_of_flat_left`\nfor commutative rings. -/\ntheorem not_linearIndependent_pair_of_flat_left [Module.Flat R M]\n    (a b : ↥(M ⊓ N)) : ¬LinearIndependent R ![a, b] :=\n  H.not_linearIndependent_pair_of_commute_of_flat_left a b (mul_comm _ _)\n\n"}
{"name":"Submodule.LinearDisjoint.not_linearIndependent_pair_of_flat_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝⁴ : CommRing R\ninst✝³ : CommRing S\ninst✝² : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝¹ : Nontrivial R\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\na b : Subtype fun x => Membership.mem (Min.min M N) x\n⊢ Not (LinearIndependent R (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)))","decl":"/-- The `Submodule.LinearDisjoint.not_linearIndependent_pair_of_commute_of_flat_right`\nfor commutative rings. -/\ntheorem not_linearIndependent_pair_of_flat_right [Module.Flat R N]\n    (a b : ↥(M ⊓ N)) : ¬LinearIndependent R ![a, b] :=\n  H.not_linearIndependent_pair_of_commute_of_flat_right a b (mul_comm _ _)\n\n"}
{"name":"Submodule.LinearDisjoint.not_linearIndependent_pair_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Nontrivial R\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem M x)) (Module.Flat R (Subtype fun x => Membership.mem N x))\na b : Subtype fun x => Membership.mem (Min.min M N) x\n⊢ Not (LinearIndependent R (Matrix.vecCons a (Matrix.vecCons b Matrix.vecEmpty)))","decl":"/-- The `Submodule.LinearDisjoint.not_linearIndependent_pair_of_commute_of_flat`\nfor commutative rings. -/\ntheorem not_linearIndependent_pair_of_flat (hf : Module.Flat R M ∨ Module.Flat R N)\n    (a b : ↥(M ⊓ N)) : ¬LinearIndependent R ![a, b] :=\n  H.not_linearIndependent_pair_of_commute_of_flat hf a b (mul_comm _ _)\n\n"}
{"name":"Submodule.LinearDisjoint.rank_inf_le_one_of_flat","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝² : CommRing R\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\nhf : Or (Module.Flat R (Subtype fun x => Membership.mem M x)) (Module.Flat R (Subtype fun x => Membership.mem N x))\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Min.min M N) x)) 1","decl":"/-- The `Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat`\nfor commutative rings. -/\ntheorem rank_inf_le_one_of_flat (hf : Module.Flat R M ∨ Module.Flat R N) :\n    Module.rank R ↥(M ⊓ N) ≤ 1 :=\n  H.rank_inf_le_one_of_commute_of_flat hf fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Submodule.LinearDisjoint.rank_inf_le_one_of_flat_left","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Min.min M N) x)) 1","decl":"/-- The `Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat_left`\nfor commutative rings. -/\ntheorem rank_inf_le_one_of_flat_left [Module.Flat R M] : Module.rank R ↥(M ⊓ N) ≤ 1 :=\n  H.rank_inf_le_one_of_commute_of_flat_left fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Submodule.LinearDisjoint.rank_inf_le_one_of_flat_right","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nM N : Submodule R S\nH : M.LinearDisjoint N\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem N x)\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem (Min.min M N) x)) 1","decl":"/-- The `Submodule.LinearDisjoint.rank_inf_le_one_of_commute_of_flat_right`\nfor commutative rings. -/\ntheorem rank_inf_le_one_of_flat_right [Module.Flat R N] : Module.rank R ↥(M ⊓ N) ≤ 1 :=\n  H.rank_inf_le_one_of_commute_of_flat_right fun _ _ ↦ mul_comm _ _\n\n"}
{"name":"Submodule.LinearDisjoint.rank_le_one_of_flat_of_self","module":"Mathlib.LinearAlgebra.LinearDisjoint","initialProofState":"R : Type u\nS : Type v\ninst✝³ : CommRing R\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nM : Submodule R S\nH : M.LinearDisjoint M\ninst✝ : Module.Flat R (Subtype fun x => Membership.mem M x)\n⊢ LE.le (Module.rank R (Subtype fun x => Membership.mem M x)) 1","decl":"/-- The `Submodule.LinearDisjoint.rank_le_one_of_commute_of_flat_of_self`\nfor commutative rings. -/\ntheorem rank_le_one_of_flat_of_self (H : M.LinearDisjoint M) [Module.Flat R M] :\n    Module.rank R M ≤ 1 :=\n  H.rank_le_one_of_commute_of_flat_of_self fun _ _ ↦ mul_comm _ _\n\n"}
