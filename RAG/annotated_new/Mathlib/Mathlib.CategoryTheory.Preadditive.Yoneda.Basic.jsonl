{"name":"CategoryTheory.preadditiveYonedaObj_obj_isModule","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nY : C\nX : Opposite C\n⊢ Eq ((CategoryTheory.preadditiveYonedaObj Y).obj X).isModule CategoryTheory.Preadditive.moduleEndRight","decl":"/-- The Yoneda embedding for preadditive categories sends an object `Y` to the presheaf sending an\nobject `X` to the `End Y`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveYonedaObj (Y : C) : Cᵒᵖ ⥤ ModuleCat.{v} (End Y) where\n  obj X := ModuleCat.of _ (X.unop ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => f.unop ≫ g\n      map_add' := fun _ _ => comp_add _ _ _ _ _ _\n      map_smul' := fun _ _ => Eq.symm <| Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveYonedaObj_obj_isAddCommGroup","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nY : C\nX : Opposite C\n⊢ Eq ((CategoryTheory.preadditiveYonedaObj Y).obj X).isAddCommGroup (CategoryTheory.Preadditive.homGroup (Opposite.unop X) Y)","decl":"/-- The Yoneda embedding for preadditive categories sends an object `Y` to the presheaf sending an\nobject `X` to the `End Y`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveYonedaObj (Y : C) : Cᵒᵖ ⥤ ModuleCat.{v} (End Y) where\n  obj X := ModuleCat.of _ (X.unop ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => f.unop ≫ g\n      map_add' := fun _ _ => comp_add _ _ _ _ _ _\n      map_smul' := fun _ _ => Eq.symm <| Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveYonedaObj_obj_carrier","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nY : C\nX : Opposite C\n⊢ Eq (↑((CategoryTheory.preadditiveYonedaObj Y).obj X)) (Quiver.Hom (Opposite.unop X) Y)","decl":"/-- The Yoneda embedding for preadditive categories sends an object `Y` to the presheaf sending an\nobject `X` to the `End Y`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveYonedaObj (Y : C) : Cᵒᵖ ⥤ ModuleCat.{v} (End Y) where\n  obj X := ModuleCat.of _ (X.unop ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => f.unop ≫ g\n      map_add' := fun _ _ => comp_add _ _ _ _ _ _\n      map_smul' := fun _ _ => Eq.symm <| Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveYonedaObj_map","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nY : C\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.preadditiveYonedaObj Y).map f) (ModuleCat.ofHom { toFun := fun g => CategoryTheory.CategoryStruct.comp f.unop g, map_add' := ⋯, map_smul' := ⋯ })","decl":"/-- The Yoneda embedding for preadditive categories sends an object `Y` to the presheaf sending an\nobject `X` to the `End Y`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveYonedaObj (Y : C) : Cᵒᵖ ⥤ ModuleCat.{v} (End Y) where\n  obj X := ModuleCat.of _ (X.unop ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => f.unop ≫ g\n      map_add' := fun _ _ => comp_add _ _ _ _ _ _\n      map_smul' := fun _ _ => Eq.symm <| Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveYoneda_obj","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nY : C\n⊢ Eq (CategoryTheory.preadditiveYoneda.obj Y) ((CategoryTheory.preadditiveYonedaObj Y).comp (CategoryTheory.forget₂ (ModuleCat (CategoryTheory.End Y)) AddCommGrp))","decl":"/-- The Yoneda embedding for preadditive categories sends an object `Y` to the presheaf sending an\nobject `X` to the group of morphisms `X ⟶ Y`. At each point, we get an additional `End Y`-module\nstructure, see `preadditiveYonedaObj`.\n-/\n@[simps obj]\ndef preadditiveYoneda : C ⥤ Cᵒᵖ ⥤ AddCommGrp.{v} where\n  obj Y := preadditiveYonedaObj Y ⋙ forget₂ _ _\n  map f :=\n    { app := fun _ => AddCommGrp.ofHom\n        { toFun := fun g => g ≫ f\n          map_zero' := Limits.zero_comp\n          map_add' := fun _ _ => add_comp _ _ _ _ _ _ }\n      naturality := fun _ _ _ => AddCommGrp.ext fun _ => Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveCoyonedaObj_map","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq ((CategoryTheory.preadditiveCoyonedaObj X).map f) (ModuleCat.ofHom { toFun := fun g => CategoryTheory.CategoryStruct.comp g f, map_add' := ⋯, map_smul' := ⋯ })","decl":"/-- The Yoneda embedding for preadditive categories sends an object `X` to the copresheaf sending an\nobject `Y` to the `End X`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveCoyonedaObj (X : Cᵒᵖ) : C ⥤ ModuleCat.{v} (End X) where\n  obj Y := ModuleCat.of _ (unop X ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => g ≫ f\n      map_add' := fun _ _ => add_comp _ _ _ _ _ _\n      map_smul' := fun _ _ => Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveCoyonedaObj_obj_carrier","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\nY : C\n⊢ Eq (↑((CategoryTheory.preadditiveCoyonedaObj X).obj Y)) (Quiver.Hom (Opposite.unop X) Y)","decl":"/-- The Yoneda embedding for preadditive categories sends an object `X` to the copresheaf sending an\nobject `Y` to the `End X`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveCoyonedaObj (X : Cᵒᵖ) : C ⥤ ModuleCat.{v} (End X) where\n  obj Y := ModuleCat.of _ (unop X ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => g ≫ f\n      map_add' := fun _ _ => add_comp _ _ _ _ _ _\n      map_smul' := fun _ _ => Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveCoyonedaObj_obj_isAddCommGroup","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\nY : C\n⊢ Eq ((CategoryTheory.preadditiveCoyonedaObj X).obj Y).isAddCommGroup (CategoryTheory.Preadditive.homGroup (Opposite.unop X) Y)","decl":"/-- The Yoneda embedding for preadditive categories sends an object `X` to the copresheaf sending an\nobject `Y` to the `End X`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveCoyonedaObj (X : Cᵒᵖ) : C ⥤ ModuleCat.{v} (End X) where\n  obj Y := ModuleCat.of _ (unop X ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => g ≫ f\n      map_add' := fun _ _ => add_comp _ _ _ _ _ _\n      map_smul' := fun _ _ => Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveCoyonedaObj_obj_isModule","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\nY : C\n⊢ Eq ((CategoryTheory.preadditiveCoyonedaObj X).obj Y).isModule (CategoryTheory.moduleEndLeft C)","decl":"/-- The Yoneda embedding for preadditive categories sends an object `X` to the copresheaf sending an\nobject `Y` to the `End X`-module of morphisms `X ⟶ Y`.\n-/\n@[simps]\ndef preadditiveCoyonedaObj (X : Cᵒᵖ) : C ⥤ ModuleCat.{v} (End X) where\n  obj Y := ModuleCat.of _ (unop X ⟶ Y)\n  map f := ModuleCat.ofHom\n    { toFun := fun g => g ≫ f\n      map_add' := fun _ _ => add_comp _ _ _ _ _ _\n      map_smul' := fun _ _ => Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.preadditiveCoyoneda_obj","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\n⊢ Eq (CategoryTheory.preadditiveCoyoneda.obj X) ((CategoryTheory.preadditiveCoyonedaObj X).comp (CategoryTheory.forget₂ (ModuleCat (CategoryTheory.End X)) AddCommGrp))","decl":"/-- The Yoneda embedding for preadditive categories sends an object `X` to the copresheaf sending an\nobject `Y` to the group of morphisms `X ⟶ Y`. At each point, we get an additional `End X`-module\nstructure, see `preadditiveCoyonedaObj`.\n-/\n@[simps obj]\ndef preadditiveCoyoneda : Cᵒᵖ ⥤ C ⥤ AddCommGrp.{v} where\n  obj X := preadditiveCoyonedaObj X ⋙ forget₂ _ _\n  map f :=\n    { app := fun _ => AddCommGrp.ofHom\n        { toFun := fun g => f.unop ≫ g\n          map_zero' := Limits.comp_zero\n          map_add' := fun _ _ => comp_add _ _ _ _ _ _ }\n      naturality := fun _ _ _ =>\n        AddCommGrp.ext fun _ => Eq.symm <| Category.assoc _ _ _ }\n\n"}
{"name":"CategoryTheory.additive_yonedaObj","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : C\n⊢ (CategoryTheory.preadditiveYonedaObj X).Additive","decl":"instance additive_yonedaObj (X : C) : Functor.Additive (preadditiveYonedaObj X) where\n\n"}
{"name":"CategoryTheory.additive_yonedaObj'","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : C\n⊢ (CategoryTheory.preadditiveYoneda.obj X).Additive","decl":"instance additive_yonedaObj' (X : C) : Functor.Additive (preadditiveYoneda.obj X) where\n\n"}
{"name":"CategoryTheory.additive_coyonedaObj","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\n⊢ (CategoryTheory.preadditiveCoyonedaObj X).Additive","decl":"instance additive_coyonedaObj (X : Cᵒᵖ) : Functor.Additive (preadditiveCoyonedaObj X) where\n\n"}
{"name":"CategoryTheory.additive_coyonedaObj'","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\nX : Opposite C\n⊢ (CategoryTheory.preadditiveCoyoneda.obj X).Additive","decl":"instance additive_coyonedaObj' (X : Cᵒᵖ) : Functor.Additive (preadditiveCoyoneda.obj X) where\n\n"}
{"name":"CategoryTheory.whiskering_preadditiveYoneda","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ Eq (CategoryTheory.preadditiveYoneda.comp ((CategoryTheory.whiskeringRight (Opposite C) AddCommGrp (Type v)).obj (CategoryTheory.forget AddCommGrp))) CategoryTheory.yoneda","decl":"/-- Composing the preadditive yoneda embedding with the forgetful functor yields the regular\nYoneda embedding.\n-/\n@[simp]\ntheorem whiskering_preadditiveYoneda :\n    preadditiveYoneda ⋙\n        (whiskeringRight Cᵒᵖ AddCommGrp (Type v)).obj (forget AddCommGrp) =\n      yoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskering_preadditiveCoyoneda","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ Eq (CategoryTheory.preadditiveCoyoneda.comp ((CategoryTheory.whiskeringRight C AddCommGrp (Type v)).obj (CategoryTheory.forget AddCommGrp))) CategoryTheory.coyoneda","decl":"/-- Composing the preadditive yoneda embedding with the forgetful functor yields the regular\nYoneda embedding.\n-/\n@[simp]\ntheorem whiskering_preadditiveCoyoneda :\n    preadditiveCoyoneda ⋙\n        (whiskeringRight C AddCommGrp (Type v)).obj (forget AddCommGrp) =\n      coyoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.full_preadditiveYoneda","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.preadditiveYoneda.Full","decl":"instance full_preadditiveYoneda : (preadditiveYoneda : C ⥤ Cᵒᵖ ⥤ AddCommGrp).Full :=\n  let _ : Functor.Full (preadditiveYoneda ⋙\n      (whiskeringRight Cᵒᵖ AddCommGrp (Type v)).obj (forget AddCommGrp)) :=\n    Yoneda.yoneda_full\n  Functor.Full.of_comp_faithful preadditiveYoneda\n    ((whiskeringRight Cᵒᵖ AddCommGrp (Type v)).obj (forget AddCommGrp))\n\n"}
{"name":"CategoryTheory.full_preadditiveCoyoneda","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.preadditiveCoyoneda.Full","decl":"instance full_preadditiveCoyoneda : (preadditiveCoyoneda : Cᵒᵖ ⥤ C ⥤ AddCommGrp).Full :=\n  let _ : Functor.Full (preadditiveCoyoneda ⋙\n      (whiskeringRight C AddCommGrp (Type v)).obj (forget AddCommGrp)) :=\n    Coyoneda.coyoneda_full\n  Functor.Full.of_comp_faithful preadditiveCoyoneda\n    ((whiskeringRight C AddCommGrp (Type v)).obj (forget AddCommGrp))\n\n"}
{"name":"CategoryTheory.faithful_preadditiveYoneda","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.preadditiveYoneda.Faithful","decl":"instance faithful_preadditiveYoneda : (preadditiveYoneda : C ⥤ Cᵒᵖ ⥤ AddCommGrp).Faithful :=\n  Functor.Faithful.of_comp_eq whiskering_preadditiveYoneda\n\n"}
{"name":"CategoryTheory.faithful_preadditiveCoyoneda","module":"Mathlib.CategoryTheory.Preadditive.Yoneda.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\ninst✝ : CategoryTheory.Preadditive C\n⊢ CategoryTheory.preadditiveCoyoneda.Faithful","decl":"instance faithful_preadditiveCoyoneda :\n    (preadditiveCoyoneda : Cᵒᵖ ⥤ C ⥤ AddCommGrp).Faithful :=\n  Functor.Faithful.of_comp_eq whiskering_preadditiveCoyoneda\n\n"}
