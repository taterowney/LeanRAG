{"name":"Real.log_mul_self_monotoneOn","module":"Mathlib.Analysis.SpecialFunctions.Log.Monotone","initialProofState":"⊢ MonotoneOn (fun x => HMul.hMul (Real.log x) x) (setOf fun x => LE.le 1 x)","decl":"theorem log_mul_self_monotoneOn : MonotoneOn (fun x : ℝ => log x * x) { x | 1 ≤ x } := by\n  -- TODO: can be strengthened to exp (-1) ≤ x\n  simp only [MonotoneOn, mem_setOf_eq]\n  intro x hex y hey hxy\n  have y_pos : 0 < y := lt_of_lt_of_le zero_lt_one hey\n  gcongr\n  rwa [le_log_iff_exp_le y_pos, Real.exp_zero]\n\n"}
{"name":"Real.log_div_self_antitoneOn","module":"Mathlib.Analysis.SpecialFunctions.Log.Monotone","initialProofState":"⊢ AntitoneOn (fun x => HDiv.hDiv (Real.log x) x) (setOf fun x => LE.le (Real.exp 1) x)","decl":"theorem log_div_self_antitoneOn : AntitoneOn (fun x : ℝ => log x / x) { x | exp 1 ≤ x } := by\n  simp only [AntitoneOn, mem_setOf_eq]\n  intro x hex y hey hxy\n  have x_pos : 0 < x := (exp_pos 1).trans_le hex\n  have y_pos : 0 < y := (exp_pos 1).trans_le hey\n  have hlogx : 1 ≤ log x := by rwa [le_log_iff_exp_le x_pos]\n  have hyx : 0 ≤ y / x - 1 := by rwa [le_sub_iff_add_le, le_div_iff₀ x_pos, zero_add, one_mul]\n  rw [div_le_iff₀ y_pos, ← sub_le_sub_iff_right (log x)]\n  calc\n    log y - log x = log (y / x) := by rw [log_div y_pos.ne' x_pos.ne']\n    _ ≤ y / x - 1 := log_le_sub_one_of_pos (div_pos y_pos x_pos)\n    _ ≤ log x * (y / x - 1) := le_mul_of_one_le_left hyx hlogx\n    _ = log x / x * y - log x := by ring\n\n"}
{"name":"Real.log_div_self_rpow_antitoneOn","module":"Mathlib.Analysis.SpecialFunctions.Log.Monotone","initialProofState":"a : Real\nha : LT.lt 0 a\n⊢ AntitoneOn (fun x => HDiv.hDiv (Real.log x) (HPow.hPow x a)) (setOf fun x => LE.le (Real.exp (HDiv.hDiv 1 a)) x)","decl":"theorem log_div_self_rpow_antitoneOn {a : ℝ} (ha : 0 < a) :\n    AntitoneOn (fun x : ℝ => log x / x ^ a) { x | exp (1 / a) ≤ x } := by\n  simp only [AntitoneOn, mem_setOf_eq]\n  intro x hex y _ hxy\n  have x_pos : 0 < x := lt_of_lt_of_le (exp_pos (1 / a)) hex\n  have y_pos : 0 < y := by linarith\n  nth_rw 1 [← rpow_one y]\n  nth_rw 1 [← rpow_one x]\n  rw [← div_self (ne_of_lt ha).symm, div_eq_mul_one_div a a, rpow_mul y_pos.le, rpow_mul x_pos.le,\n    log_rpow (rpow_pos_of_pos y_pos a), log_rpow (rpow_pos_of_pos x_pos a), mul_div_assoc,\n    mul_div_assoc, mul_le_mul_left (one_div_pos.mpr ha)]\n  refine log_div_self_antitoneOn ?_ ?_ ?_\n  · simp only [Set.mem_setOf_eq]\n    convert rpow_le_rpow _ hex (le_of_lt ha) using 1\n    · rw [← exp_mul]\n      simp only [Real.exp_eq_exp]\n      field_simp\n    positivity\n  · simp only [Set.mem_setOf_eq]\n    convert rpow_le_rpow _ (_root_.trans hex hxy) (le_of_lt ha) using 1\n    · rw [← exp_mul]\n      simp only [Real.exp_eq_exp]\n      field_simp\n    positivity\n  gcongr\n\n"}
{"name":"Real.log_div_sqrt_antitoneOn","module":"Mathlib.Analysis.SpecialFunctions.Log.Monotone","initialProofState":"⊢ AntitoneOn (fun x => HDiv.hDiv (Real.log x) x.sqrt) (setOf fun x => LE.le (Real.exp 2) x)","decl":"theorem log_div_sqrt_antitoneOn : AntitoneOn (fun x : ℝ => log x / √x) { x | exp 2 ≤ x } := by\n  simp_rw [sqrt_eq_rpow]\n  convert @log_div_self_rpow_antitoneOn (1 / 2) (by norm_num)\n  norm_num\n\n"}
