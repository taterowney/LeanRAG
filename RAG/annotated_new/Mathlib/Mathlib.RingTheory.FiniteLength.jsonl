{"name":"IsFiniteLength.brecOn","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝² : Ring R\nmotive✝ : (M : Type u) → [inst : AddCommGroup M] → [inst_1 : Module R M] → IsFiniteLength R M → Prop\nM : Type u\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nx✝ : IsFiniteLength R M\nih✝ : ∀ (M : Type u) [inst : AddCommGroup M] [inst_1 : Module R M] (x : IsFiniteLength R M), x.below → motive✝ M x\n⊢ motive✝ M x✝","decl":"/-- A module of finite length is either trivial or a simple extension of a module known\nto be of finite length. -/\ninductive IsFiniteLength : ∀ (M : Type u) [AddCommGroup M] [Module R M], Prop\n  | of_subsingleton {M} [AddCommGroup M] [Module R M] [Subsingleton M] : IsFiniteLength M\n  | of_simple_quotient {M} [AddCommGroup M] [Module R M] {N : Submodule R M}\n      [IsSimpleModule R (M ⧸ N)] : IsFiniteLength N → IsFiniteLength M\n\n"}
{"name":"LinearEquiv.isFiniteLength","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nM : Type u_2\nN : Type u_3\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : AddCommGroup N\ninst✝ : Module R N\ne : LinearEquiv (RingHom.id R) M N\nh : IsFiniteLength R M\n⊢ IsFiniteLength R N","decl":"theorem LinearEquiv.isFiniteLength (e : M ≃ₗ[R] N)\n    (h : IsFiniteLength R M) : IsFiniteLength R N := by\n  induction h generalizing N with\n  | of_subsingleton =>\n    have := e.symm.toEquiv.subsingleton; exact .of_subsingleton\n  | @of_simple_quotient M _ _ S _ _ ih =>\n    have : IsSimpleModule R (N ⧸ Submodule.map (e : M →ₗ[R] N) S) :=\n      IsSimpleModule.congr (Submodule.Quotient.equiv S _ e rfl).symm\n    exact .of_simple_quotient (ih <| e.submoduleMap S)\n\n"}
{"name":"exists_compositionSeries_of_isNoetherian_isArtinian","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsNoetherian R M\ninst✝ : IsArtinian R M\n⊢ Exists fun s => And (Eq (RelSeries.head s) Bot.bot) (Eq (RelSeries.last s) Top.top)","decl":"variable (R M) in\ntheorem exists_compositionSeries_of_isNoetherian_isArtinian [IsNoetherian R M] [IsArtinian R M] :\n    ∃ s : CompositionSeries (Submodule R M), s.head = ⊥ ∧ s.last = ⊤ := by\n  obtain ⟨f, f0, n, hn⟩ := exists_covBy_seq_of_wellFoundedLT_wellFoundedGT (Submodule R M)\n  exact ⟨⟨n, fun i ↦ f i, fun i ↦ hn.2 i i.2⟩, f0.eq_bot, hn.1.eq_top⟩\n\n"}
{"name":"isFiniteLength_of_exists_compositionSeries","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nh : Exists fun s => And (Eq (RelSeries.head s) Bot.bot) (Eq (RelSeries.last s) Top.top)\n⊢ IsFiniteLength R M","decl":"theorem isFiniteLength_of_exists_compositionSeries\n    (h : ∃ s : CompositionSeries (Submodule R M), s.head = ⊥ ∧ s.last = ⊤) :\n    IsFiniteLength R M :=\n  Submodule.topEquiv.isFiniteLength <| by\n    obtain ⟨s, s_head, s_last⟩ := h\n    rw [← s_last]\n    suffices ∀ i, IsFiniteLength R (s i) from this (Fin.last _)\n    intro i\n    induction' i using Fin.induction with i ih\n    · change IsFiniteLength R s.head; rw [s_head]; exact .of_subsingleton\n    let cov := s.step i\n    have := (covBy_iff_quot_is_simple cov.le).mp cov\n    have := ((s i.castSucc).comap (s i.succ).subtype).equivMapOfInjective\n      _ (Submodule.injective_subtype _)\n    rw [Submodule.map_comap_subtype, inf_of_le_right cov.le] at this\n    exact .of_simple_quotient (this.symm.isFiniteLength ih)\n\n"}
{"name":"isFiniteLength_iff_isNoetherian_isArtinian","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (IsFiniteLength R M) (And (IsNoetherian R M) (IsArtinian R M))","decl":"theorem isFiniteLength_iff_isNoetherian_isArtinian :\n    IsFiniteLength R M ↔ IsNoetherian R M ∧ IsArtinian R M :=\n  ⟨fun h ↦ h.rec (fun {M} _ _ _ ↦ ⟨inferInstance, inferInstance⟩) fun M _ _ {N} _ _ ⟨_, _⟩ ↦\n    ⟨(isNoetherian_iff_submodule_quotient N).mpr ⟨‹_›, isNoetherian_iff'.mpr inferInstance⟩,\n      (isArtinian_iff_submodule_quotient N).mpr ⟨‹_›, inferInstance⟩⟩,\n    fun ⟨_, _⟩ ↦ isFiniteLength_of_exists_compositionSeries\n      (exists_compositionSeries_of_isNoetherian_isArtinian R M)⟩\n\n"}
{"name":"isFiniteLength_iff_exists_compositionSeries","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝² : Ring R\nM : Type u_2\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Iff (IsFiniteLength R M) (Exists fun s => And (Eq (RelSeries.head s) Bot.bot) (Eq (RelSeries.last s) Top.top))","decl":"theorem isFiniteLength_iff_exists_compositionSeries :\n    IsFiniteLength R M ↔ ∃ s : CompositionSeries (Submodule R M), s.head = ⊥ ∧ s.last = ⊤ :=\n  ⟨fun h ↦ have ⟨_, _⟩ := isFiniteLength_iff_isNoetherian_isArtinian.mp h\n    exists_compositionSeries_of_isNoetherian_isArtinian R M,\n    isFiniteLength_of_exists_compositionSeries⟩\n\n"}
{"name":"IsSemisimpleModule.finite_tfae","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝³ : Ring R\nM : Type u_2\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : IsSemisimpleModule R M\n⊢ (List.cons (Module.Finite R M) (List.cons (IsNoetherian R M) (List.cons (IsArtinian R M) (List.cons (IsFiniteLength R M) (List.cons (Exists fun s => And s.Finite (And (sSupIndep s) (And (Eq (SupSet.sSup s) Top.top) (∀ (m : Submodule R M), Membership.mem s m → IsSimpleModule R (Subtype fun x => Membership.mem m x))))) List.nil))))).TFAE","decl":"theorem IsSemisimpleModule.finite_tfae [IsSemisimpleModule R M] :\n    List.TFAE [Module.Finite R M, IsNoetherian R M, IsArtinian R M, IsFiniteLength R M,\n      ∃ s : Set (Submodule R M), s.Finite ∧ sSupIndep s ∧\n        sSup s = ⊤ ∧ ∀ m ∈ s, IsSimpleModule R m] := by\n  rw [isFiniteLength_iff_isNoetherian_isArtinian]\n  obtain ⟨s, hs⟩ := IsSemisimpleModule.exists_sSupIndep_sSup_simples_eq_top R M\n  tfae_have 1 ↔ 2 := ⟨fun _ ↦ inferInstance, fun _ ↦ inferInstance⟩\n  tfae_have 2 → 5 := fun _ ↦ ⟨s, WellFoundedGT.finite_of_sSupIndep hs.1, hs⟩\n  tfae_have 3 → 5 := fun _ ↦ ⟨s, WellFoundedLT.finite_of_sSupIndep hs.1, hs⟩\n  tfae_have 5 → 4 := fun ⟨s, fin, _, sSup_eq_top, simple⟩ ↦ by\n    rw [← isNoetherian_top_iff, ← Submodule.topEquiv.isArtinian_iff,\n      ← sSup_eq_top, sSup_eq_iSup, ← iSup_subtype'']\n    rw [SetCoe.forall'] at simple\n    have := fin.to_subtype\n    exact ⟨isNoetherian_iSup, isArtinian_iSup⟩\n  tfae_have 4 → 2 := And.left\n  tfae_have 4 → 3 := And.right\n  tfae_finish\n\n"}
{"name":"instIsArtinianOfIsSemisimpleModuleOfFinite","module":"Mathlib.RingTheory.FiniteLength","initialProofState":"R : Type u_1\ninst✝⁴ : Ring R\nM : Type u_2\ninst✝³ : AddCommGroup M\ninst✝² : Module R M\ninst✝¹ : IsSemisimpleModule R M\ninst✝ : Module.Finite R M\n⊢ IsArtinian R M","decl":"instance [IsSemisimpleModule R M] [Module.Finite R M] : IsArtinian R M :=\n  (IsSemisimpleModule.finite_tfae.out 0 2).mp ‹_›\n\n/- The following instances are now automatic:\nexample [IsSemisimpleRing R] : IsNoetherianRing R := inferInstance\nexample [IsSemisimpleRing R] : IsArtinianRing R := inferInstance\n-/\n"}
