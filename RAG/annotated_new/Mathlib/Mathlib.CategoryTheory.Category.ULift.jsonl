{"name":"CategoryTheory.ULift.upFunctor_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.ULift.upFunctor.map f) f","decl":"/-- The functorial version of `ULift.up`. -/\n@[simps]\ndef ULift.upFunctor : C â¥¤ ULift.{uâ‚‚} C where\n  obj := ULift.up\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.upFunctor_obj_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\ndown : C\nâŠ¢ Eq (CategoryTheory.ULift.upFunctor.obj down).down down","decl":"/-- The functorial version of `ULift.up`. -/\n@[simps]\ndef ULift.upFunctor : C â¥¤ ULift.{uâ‚‚} C where\n  obj := ULift.up\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.downFunctor_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nXâœ Yâœ : ULift.{uâ‚‚, uâ‚} C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.ULift.downFunctor.map f) f","decl":"/-- The functorial version of `ULift.down`. -/\n@[simps]\ndef ULift.downFunctor : ULift.{uâ‚‚} C â¥¤ C where\n  obj := ULift.down\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.downFunctor_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nself : ULift.{uâ‚‚, uâ‚} C\nâŠ¢ Eq (CategoryTheory.ULift.downFunctor.obj self) self.down","decl":"/-- The functorial version of `ULift.down`. -/\n@[simps]\ndef ULift.downFunctor : ULift.{uâ‚‚} C â¥¤ C where\n  obj := ULift.down\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.equivalence_functor","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.ULift.equivalence.functor CategoryTheory.ULift.upFunctor","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C â‰Œ ULift.{uâ‚‚} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := ðŸ™ _\n      inv := ðŸ™ _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      inv :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      hom_inv_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp\n      inv_hom_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp }\n  functor_unitIso_comp X := by\n    change ðŸ™ X â‰« ðŸ™ X = ðŸ™ X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_counitIso_inv_app","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nxâœ : ULift.{uâ‚‚, uâ‚} C\nâŠ¢ Eq (CategoryTheory.ULift.equivalence.counitIso.inv.app xâœ) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id (ULift.{uâ‚‚, uâ‚} C)).obj xâœ))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C â‰Œ ULift.{uâ‚‚} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := ðŸ™ _\n      inv := ðŸ™ _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      inv :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      hom_inv_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp\n      inv_hom_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp }\n  functor_unitIso_comp X := by\n    change ðŸ™ X â‰« ðŸ™ X = ðŸ™ X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_unitIso_hom","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.ULift.equivalence.unitIso.hom (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.id C))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C â‰Œ ULift.{uâ‚‚} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := ðŸ™ _\n      inv := ðŸ™ _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      inv :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      hom_inv_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp\n      inv_hom_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp }\n  functor_unitIso_comp X := by\n    change ðŸ™ X â‰« ðŸ™ X = ðŸ™ X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_counitIso_hom_app","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nxâœ : ULift.{uâ‚‚, uâ‚} C\nâŠ¢ Eq (CategoryTheory.ULift.equivalence.counitIso.hom.app xâœ) (CategoryTheory.CategoryStruct.id ((CategoryTheory.ULift.downFunctor.comp CategoryTheory.ULift.upFunctor).obj xâœ))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C â‰Œ ULift.{uâ‚‚} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := ðŸ™ _\n      inv := ðŸ™ _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      inv :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      hom_inv_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp\n      inv_hom_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp }\n  functor_unitIso_comp X := by\n    change ðŸ™ X â‰« ðŸ™ X = ðŸ™ X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_inverse","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.ULift.equivalence.inverse CategoryTheory.ULift.downFunctor","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C â‰Œ ULift.{uâ‚‚} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := ðŸ™ _\n      inv := ðŸ™ _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      inv :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      hom_inv_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp\n      inv_hom_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp }\n  functor_unitIso_comp X := by\n    change ðŸ™ X â‰« ðŸ™ X = ðŸ™ X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_unitIso_inv","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.ULift.equivalence.unitIso.inv (CategoryTheory.CategoryStruct.id (CategoryTheory.ULift.upFunctor.comp CategoryTheory.ULift.downFunctor))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C â‰Œ ULift.{uâ‚‚} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := ðŸ™ _\n      inv := ðŸ™ _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      inv :=\n        { app := fun _ => ðŸ™ _\n          naturality := fun X Y f => by\n            change f â‰« ðŸ™ _ = ðŸ™ _ â‰« f\n            simp }\n      hom_inv_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp\n      inv_hom_id := by\n        ext\n        change ðŸ™ _ â‰« ðŸ™ _ = ðŸ™ _\n        simp }\n  functor_unitIso_comp X := by\n    change ðŸ™ X â‰« ðŸ™ X = ðŸ™ X\n    simp\n\n"}
{"name":"CategoryTheory.objDown_objUp","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u_1\nA : C\nâŠ¢ Eq (CategoryTheory.ULiftHom.objUp A).objDown A","decl":"@[simp]\ntheorem objDown_objUp {C} (A : C) : (ULiftHom.objUp A).objDown = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.objUp_objDown","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u_1\nA : CategoryTheory.ULiftHom C\nâŠ¢ Eq (CategoryTheory.ULiftHom.objUp A.objDown) A","decl":"@[simp]\ntheorem objUp_objDown {C} (A : ULiftHom C) : ULiftHom.objUp A.objDown = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.ULiftHom.up_map_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.ULiftHom.up.map f).down f","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.up : C â¥¤ ULiftHom C where\n  obj := ULiftHom.objUp\n  map f := âŸ¨fâŸ©\n\n"}
{"name":"CategoryTheory.ULiftHom.up_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nA : C\nâŠ¢ Eq (CategoryTheory.ULiftHom.up.obj A) (CategoryTheory.ULiftHom.objUp A)","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.up : C â¥¤ ULiftHom C where\n  obj := ULiftHom.objUp\n  map f := âŸ¨fâŸ©\n\n"}
{"name":"CategoryTheory.ULiftHom.down_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nA : CategoryTheory.ULiftHom C\nâŠ¢ Eq (CategoryTheory.ULiftHom.down.obj A) A.objDown","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.down : ULiftHom C â¥¤ C where\n  obj := ULiftHom.objDown\n  map f := f.down\n\n"}
{"name":"CategoryTheory.ULiftHom.down_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nXâœ Yâœ : CategoryTheory.ULiftHom C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.ULiftHom.down.map f) f.down","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.down : ULiftHom C â¥¤ C where\n  obj := ULiftHom.objDown\n  map f := f.down\n\n"}
{"name":"CategoryTheory.AsSmall.up_obj_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : C\nâŠ¢ Eq (CategoryTheory.AsSmall.up.obj X).down X","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.up : C â¥¤ AsSmall C where\n  obj X := âŸ¨XâŸ©\n  map f := âŸ¨fâŸ©\n\n"}
{"name":"CategoryTheory.AsSmall.up_map_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nXâœ Yâœ : C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.AsSmall.up.map f).down f","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.up : C â¥¤ AsSmall C where\n  obj X := âŸ¨XâŸ©\n  map f := âŸ¨fâŸ©\n\n"}
{"name":"CategoryTheory.AsSmall.down_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX : CategoryTheory.AsSmall C\nâŠ¢ Eq (CategoryTheory.AsSmall.down.obj X) X.down","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.down : AsSmall C â¥¤ C where\n  obj X := ULift.down X\n  map f := f.down\n\n"}
{"name":"CategoryTheory.AsSmall.down_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nXâœ Yâœ : CategoryTheory.AsSmall C\nf : Quiver.Hom Xâœ Yâœ\nâŠ¢ Eq (CategoryTheory.AsSmall.down.map f) f.down","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.down : AsSmall C â¥¤ C where\n  obj X := ULift.down X\n  map f := f.down\n\n"}
{"name":"CategoryTheory.down_comp_assoc","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX Y Zâœ : CategoryTheory.AsSmall C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Zâœ\nZ : C\nh : Quiver.Hom Zâœ.down Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).down h) (CategoryTheory.CategoryStruct.comp f.down (CategoryTheory.CategoryStruct.comp g.down h))","decl":"@[reassoc]\ntheorem down_comp {X Y Z : AsSmall C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : (f â‰« g).down = f.down â‰« g.down :=\n  rfl\n\n"}
{"name":"CategoryTheory.down_comp","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX Y Z : CategoryTheory.AsSmall C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\nâŠ¢ Eq (CategoryTheory.CategoryStruct.comp f g).down (CategoryTheory.CategoryStruct.comp f.down g.down)","decl":"@[reassoc]\ntheorem down_comp {X Y Z : AsSmall C} (f : X âŸ¶ Y) (g : Y âŸ¶ Z) : (f â‰« g).down = f.down â‰« g.down :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nX Y : CategoryTheory.AsSmall C\nh : Eq X Y\nâŠ¢ Eq (CategoryTheory.eqToHom h).down (CategoryTheory.eqToHom â‹¯)","decl":"@[simp]\ntheorem eqToHom_down {X Y : AsSmall C} (h : X = Y) :\n    (eqToHom h).down = eqToHom (congrArg ULift.down h) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_unitIso","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.AsSmall.equiv.unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso â‹¯) â‹¯)","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C â‰Œ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_counitIso","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.AsSmall.equiv.counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso â‹¯) â‹¯)","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C â‰Œ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_inverse","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.AsSmall.equiv.inverse CategoryTheory.AsSmall.down","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C â‰Œ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_functor","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type uâ‚\ninstâœ : CategoryTheory.Category.{vâ‚, uâ‚} C\nâŠ¢ Eq CategoryTheory.AsSmall.equiv.functor CategoryTheory.AsSmall.up","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C â‰Œ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
