{"name":"CategoryTheory.ULift.upFunctor_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ULift.upFunctor.map f) f","decl":"/-- The functorial version of `ULift.up`. -/\n@[simps]\ndef ULift.upFunctor : C ⥤ ULift.{u₂} C where\n  obj := ULift.up\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.upFunctor_obj_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\ndown : C\n⊢ Eq (CategoryTheory.ULift.upFunctor.obj down).down down","decl":"/-- The functorial version of `ULift.up`. -/\n@[simps]\ndef ULift.upFunctor : C ⥤ ULift.{u₂} C where\n  obj := ULift.up\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.downFunctor_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : ULift.{u₂, u₁} C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ULift.downFunctor.map f) f","decl":"/-- The functorial version of `ULift.down`. -/\n@[simps]\ndef ULift.downFunctor : ULift.{u₂} C ⥤ C where\n  obj := ULift.down\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.downFunctor_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nself : ULift.{u₂, u₁} C\n⊢ Eq (CategoryTheory.ULift.downFunctor.obj self) self.down","decl":"/-- The functorial version of `ULift.down`. -/\n@[simps]\ndef ULift.downFunctor : ULift.{u₂} C ⥤ C where\n  obj := ULift.down\n  map f := f\n\n"}
{"name":"CategoryTheory.ULift.equivalence_functor","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.ULift.equivalence.functor CategoryTheory.ULift.upFunctor","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C ≌ ULift.{u₂} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := 𝟙 _\n      inv := 𝟙 _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      inv :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      hom_inv_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp\n      inv_hom_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp }\n  functor_unitIso_comp X := by\n    change 𝟙 X ≫ 𝟙 X = 𝟙 X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_counitIso_inv_app","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nx✝ : ULift.{u₂, u₁} C\n⊢ Eq (CategoryTheory.ULift.equivalence.counitIso.inv.app x✝) (CategoryTheory.CategoryStruct.id ((CategoryTheory.Functor.id (ULift.{u₂, u₁} C)).obj x✝))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C ≌ ULift.{u₂} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := 𝟙 _\n      inv := 𝟙 _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      inv :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      hom_inv_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp\n      inv_hom_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp }\n  functor_unitIso_comp X := by\n    change 𝟙 X ≫ 𝟙 X = 𝟙 X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_unitIso_hom","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.ULift.equivalence.unitIso.hom (CategoryTheory.CategoryStruct.id (CategoryTheory.Functor.id C))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C ≌ ULift.{u₂} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := 𝟙 _\n      inv := 𝟙 _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      inv :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      hom_inv_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp\n      inv_hom_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp }\n  functor_unitIso_comp X := by\n    change 𝟙 X ≫ 𝟙 X = 𝟙 X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_counitIso_hom_app","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nx✝ : ULift.{u₂, u₁} C\n⊢ Eq (CategoryTheory.ULift.equivalence.counitIso.hom.app x✝) (CategoryTheory.CategoryStruct.id ((CategoryTheory.ULift.downFunctor.comp CategoryTheory.ULift.upFunctor).obj x✝))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C ≌ ULift.{u₂} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := 𝟙 _\n      inv := 𝟙 _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      inv :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      hom_inv_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp\n      inv_hom_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp }\n  functor_unitIso_comp X := by\n    change 𝟙 X ≫ 𝟙 X = 𝟙 X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_inverse","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.ULift.equivalence.inverse CategoryTheory.ULift.downFunctor","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C ≌ ULift.{u₂} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := 𝟙 _\n      inv := 𝟙 _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      inv :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      hom_inv_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp\n      inv_hom_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp }\n  functor_unitIso_comp X := by\n    change 𝟙 X ≫ 𝟙 X = 𝟙 X\n    simp\n\n"}
{"name":"CategoryTheory.ULift.equivalence_unitIso_inv","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.ULift.equivalence.unitIso.inv (CategoryTheory.CategoryStruct.id (CategoryTheory.ULift.upFunctor.comp CategoryTheory.ULift.downFunctor))","decl":"/-- The categorical equivalence between `C` and `ULift C`. -/\n@[simps]\ndef ULift.equivalence : C ≌ ULift.{u₂} C where\n  functor := ULift.upFunctor\n  inverse := ULift.downFunctor\n  unitIso :=\n    { hom := 𝟙 _\n      inv := 𝟙 _ }\n  counitIso :=\n    { hom :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      inv :=\n        { app := fun _ => 𝟙 _\n          naturality := fun X Y f => by\n            change f ≫ 𝟙 _ = 𝟙 _ ≫ f\n            simp }\n      hom_inv_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp\n      inv_hom_id := by\n        ext\n        change 𝟙 _ ≫ 𝟙 _ = 𝟙 _\n        simp }\n  functor_unitIso_comp X := by\n    change 𝟙 X ≫ 𝟙 X = 𝟙 X\n    simp\n\n"}
{"name":"CategoryTheory.objDown_objUp","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u_1\nA : C\n⊢ Eq (CategoryTheory.ULiftHom.objUp A).objDown A","decl":"@[simp]\ntheorem objDown_objUp {C} (A : C) : (ULiftHom.objUp A).objDown = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.objUp_objDown","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u_1\nA : CategoryTheory.ULiftHom C\n⊢ Eq (CategoryTheory.ULiftHom.objUp A.objDown) A","decl":"@[simp]\ntheorem objUp_objDown {C} (A : ULiftHom C) : ULiftHom.objUp A.objDown = A :=\n  rfl\n\n"}
{"name":"CategoryTheory.ULiftHom.up_map_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ULiftHom.up.map f).down f","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.up : C ⥤ ULiftHom C where\n  obj := ULiftHom.objUp\n  map f := ⟨f⟩\n\n"}
{"name":"CategoryTheory.ULiftHom.up_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA : C\n⊢ Eq (CategoryTheory.ULiftHom.up.obj A) (CategoryTheory.ULiftHom.objUp A)","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.up : C ⥤ ULiftHom C where\n  obj := ULiftHom.objUp\n  map f := ⟨f⟩\n\n"}
{"name":"CategoryTheory.ULiftHom.down_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nA : CategoryTheory.ULiftHom C\n⊢ Eq (CategoryTheory.ULiftHom.down.obj A) A.objDown","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.down : ULiftHom C ⥤ C where\n  obj := ULiftHom.objDown\n  map f := f.down\n\n"}
{"name":"CategoryTheory.ULiftHom.down_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.ULiftHom C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.ULiftHom.down.map f) f.down","decl":"/-- One half of the quivalence between `C` and `ULiftHom C`. -/\n@[simps]\ndef ULiftHom.down : ULiftHom C ⥤ C where\n  obj := ULiftHom.objDown\n  map f := f.down\n\n"}
{"name":"CategoryTheory.AsSmall.up_obj_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : C\n⊢ Eq (CategoryTheory.AsSmall.up.obj X).down X","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.up : C ⥤ AsSmall C where\n  obj X := ⟨X⟩\n  map f := ⟨f⟩\n\n"}
{"name":"CategoryTheory.AsSmall.up_map_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.AsSmall.up.map f).down f","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.up : C ⥤ AsSmall C where\n  obj X := ⟨X⟩\n  map f := ⟨f⟩\n\n"}
{"name":"CategoryTheory.AsSmall.down_obj","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX : CategoryTheory.AsSmall C\n⊢ Eq (CategoryTheory.AsSmall.down.obj X) X.down","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.down : AsSmall C ⥤ C where\n  obj X := ULift.down X\n  map f := f.down\n\n"}
{"name":"CategoryTheory.AsSmall.down_map","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX✝ Y✝ : CategoryTheory.AsSmall C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (CategoryTheory.AsSmall.down.map f) f.down","decl":"/-- One half of the equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.down : AsSmall C ⥤ C where\n  obj X := ULift.down X\n  map f := f.down\n\n"}
{"name":"CategoryTheory.down_comp_assoc","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z✝ : CategoryTheory.AsSmall C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z✝\nZ : C\nh : Quiver.Hom Z✝.down Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.CategoryStruct.comp f g).down h) (CategoryTheory.CategoryStruct.comp f.down (CategoryTheory.CategoryStruct.comp g.down h))","decl":"@[reassoc]\ntheorem down_comp {X Y Z : AsSmall C} (f : X ⟶ Y) (g : Y ⟶ Z) : (f ≫ g).down = f.down ≫ g.down :=\n  rfl\n\n"}
{"name":"CategoryTheory.down_comp","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y Z : CategoryTheory.AsSmall C\nf : Quiver.Hom X Y\ng : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp f g).down (CategoryTheory.CategoryStruct.comp f.down g.down)","decl":"@[reassoc]\ntheorem down_comp {X Y Z : AsSmall C} (f : X ⟶ Y) (g : Y ⟶ Z) : (f ≫ g).down = f.down ≫ g.down :=\n  rfl\n\n"}
{"name":"CategoryTheory.eqToHom_down","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\nX Y : CategoryTheory.AsSmall C\nh : Eq X Y\n⊢ Eq (CategoryTheory.eqToHom h).down (CategoryTheory.eqToHom ⋯)","decl":"@[simp]\ntheorem eqToHom_down {X Y : AsSmall C} (h : X = Y) :\n    (eqToHom h).down = eqToHom (congrArg ULift.down h) := by\n  subst h\n  rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_unitIso","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.AsSmall.equiv.unitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯) ⋯)","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C ≌ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_counitIso","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.AsSmall.equiv.counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.eqToIso ⋯) ⋯)","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C ≌ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_inverse","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.AsSmall.equiv.inverse CategoryTheory.AsSmall.down","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C ≌ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
{"name":"CategoryTheory.AsSmall.equiv_functor","module":"Mathlib.CategoryTheory.Category.ULift","initialProofState":"C : Type u₁\ninst✝ : CategoryTheory.Category.{v₁, u₁} C\n⊢ Eq CategoryTheory.AsSmall.equiv.functor CategoryTheory.AsSmall.up","decl":"/-- The equivalence between `C` and `AsSmall C`. -/\n@[simps]\ndef AsSmall.equiv : C ≌ AsSmall C where\n  functor := AsSmall.up\n  inverse := AsSmall.down\n  unitIso := NatIso.ofComponents fun _ => eqToIso rfl\n  counitIso := NatIso.ofComponents fun _ => eqToIso <| ULift.ext _ _ rfl\n\n"}
