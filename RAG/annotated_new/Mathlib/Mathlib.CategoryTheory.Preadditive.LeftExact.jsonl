{"name":"CategoryTheory.Functor.preservesBinaryProduct_of_preservesKernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F\nX Y : C\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.pair X Y) F","decl":"/-- A kernel preserving functor between preadditive categories preserves any pair being a limit. -/\nlemma preservesBinaryProduct_of_preservesKernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesLimit (parallelPair f 0) F] {X Y : C} :\n    PreservesLimit (pair X Y) F where\n  preserves {c} hc :=\n    ⟨IsLimit.ofIsoLimit\n      (isLimitMapConeBinaryFanOfPreservesKernels F _ _ (IsLimit.ofIsoLimit hc (isoBinaryFanMk c)))\n      ((Cones.functoriality _ F).mapIso (isoBinaryFanMk c).symm)⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesBinaryProducts_of_preservesKernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A kernel preserving functor between preadditive categories preserves binary products. -/\nlemma preservesBinaryProducts_of_preservesKernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesLimit (parallelPair f 0) F] :\n  PreservesLimitsOfShape (Discrete WalkingPair) F where\n    preservesLimit := preservesLimit_of_iso_diagram F (diagramIsoPair _).symm\n\n"}
{"name":"CategoryTheory.Functor.preservesEqualizer_of_preservesKernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F\nX Y : C\nf g : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- A functor between preadditive categories preserves the equalizer of two\nmorphisms if it preserves all kernels. -/\nlemma preservesEqualizer_of_preservesKernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesLimit (parallelPair f 0) F]\n    {X Y : C} (f g : X ⟶ Y) : PreservesLimit (parallelPair f g) F := by\n  letI := preservesBinaryBiproducts_of_preservesBinaryProducts F\n  haveI := additive_of_preservesBinaryBiproducts F\n  constructor; intro c i\n  let c' := isLimitKernelForkOfFork (i.ofIsoLimit (Fork.isoForkOfι c))\n  dsimp only [kernelForkOfFork_ofι] at c'\n  let iFc := isLimitForkMapOfIsLimit' F _ c'\n  constructor\n  apply IsLimit.ofIsoLimit _ ((Cones.functoriality _ F).mapIso (Fork.isoForkOfι c).symm)\n  apply (isLimitMapConeForkEquiv F (Fork.condition c)).invFun\n  let p : parallelPair (F.map (f - g)) 0 ≅ parallelPair (F.map f - F.map g) 0 :=\n    parallelPair.eqOfHomEq F.map_sub rfl\n  exact\n    IsLimit.ofIsoLimit\n      (isLimitForkOfKernelFork ((IsLimit.postcomposeHomEquiv p _).symm iFc))\n      (Fork.ext (Iso.refl _) (by simp [p]))\n\n"}
{"name":"CategoryTheory.Functor.preservesEqualizers_of_preservesKernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape CategoryTheory.Limits.WalkingParallelPair F","decl":"/-- A functor between preadditive categories preserves all equalizers if it preserves all kernels.\n-/\nlemma preservesEqualizers_of_preservesKernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesLimit (parallelPair f 0) F] :\n    PreservesLimitsOfShape WalkingParallelPair F where\n  preservesLimit {K} := by\n    letI := preservesEqualizer_of_preservesKernels F (K.map WalkingParallelPairHom.left)\n        (K.map WalkingParallelPairHom.right)\n    apply preservesLimit_of_iso_diagram F (diagramIsoParallelPair K).symm\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteLimits_of_preservesKernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝⁴ : CategoryTheory.Limits.HasFiniteProducts C\ninst✝³ : CategoryTheory.Limits.HasEqualizers C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesLimit (CategoryTheory.Limits.parallelPair f 0) F\n⊢ CategoryTheory.Limits.PreservesFiniteLimits F","decl":"/-- A functor between preadditive categories which preserves kernels preserves all finite limits.\n-/\nlemma preservesFiniteLimits_of_preservesKernels [HasFiniteProducts C] [HasEqualizers C]\n    [HasZeroObject C] [HasZeroObject D] [∀ {X Y} (f : X ⟶ Y), PreservesLimit (parallelPair f 0) F] :\n    PreservesFiniteLimits F := by\n  letI := preservesEqualizers_of_preservesKernels F\n  letI := preservesTerminalObject_of_preservesZeroMorphisms F\n  letI := preservesLimitsOfShape_pempty_of_preservesTerminal F\n  letI : PreservesFiniteProducts F := ⟨preservesFiniteProducts_of_preserves_binary_and_terminal F⟩\n  exact preservesFiniteLimits_of_preservesEqualizers_and_finiteProducts F\n\n"}
{"name":"CategoryTheory.Functor.preservesCoproduct_of_preservesCokernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F\nX Y : C\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.pair X Y) F","decl":"/-- A cokernel preserving functor between preadditive categories preserves any pair being\na colimit. -/\nlemma preservesCoproduct_of_preservesCokernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesColimit (parallelPair f 0) F] {X Y : C} :\n    PreservesColimit (pair X Y) F where\n  preserves {c} hc :=\n    ⟨IsColimit.ofIsoColimit\n      (isColimitMapCoconeBinaryCofanOfPreservesCokernels F _ _\n        (IsColimit.ofIsoColimit hc (isoBinaryCofanMk c)))\n      ((Cocones.functoriality _ F).mapIso (isoBinaryCofanMk c).symm)⟩\n\n"}
{"name":"CategoryTheory.Functor.preservesBinaryCoproducts_of_preservesCokernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁵ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁴ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝³ : CategoryTheory.Category.{v₂, u₂} D\ninst✝² : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝¹ : F.PreservesZeroMorphisms\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape (CategoryTheory.Discrete CategoryTheory.Limits.WalkingPair) F","decl":"/-- A cokernel preserving functor between preadditive categories preserves binary coproducts. -/\nlemma preservesBinaryCoproducts_of_preservesCokernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesColimit (parallelPair f 0) F] :\n    PreservesColimitsOfShape (Discrete WalkingPair) F where\n  preservesColimit := preservesColimit_of_iso_diagram F (diagramIsoPair _).symm\n\n"}
{"name":"CategoryTheory.Functor.preservesCoequalizer_of_preservesCokernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F\nX Y : C\nf g : Quiver.Hom X Y\n⊢ CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f g) F","decl":"/-- A functor between preadditive categories preserves the coequalizer of two\nmorphisms if it preserves all cokernels. -/\nlemma preservesCoequalizer_of_preservesCokernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesColimit (parallelPair f 0) F] {X Y : C} (f g : X ⟶ Y) :\n    PreservesColimit (parallelPair f g) F := by\n  letI := preservesBinaryBiproducts_of_preservesBinaryCoproducts F\n  haveI := additive_of_preservesBinaryBiproducts F\n  constructor\n  intro c i\n  let c' := isColimitCokernelCoforkOfCofork (i.ofIsoColimit (Cofork.isoCoforkOfπ c))\n  dsimp only [cokernelCoforkOfCofork_ofπ] at c'\n  let iFc := isColimitCoforkMapOfIsColimit' F _ c'\n  constructor\n  apply\n    IsColimit.ofIsoColimit _ ((Cocones.functoriality _ F).mapIso (Cofork.isoCoforkOfπ c).symm)\n  apply (isColimitMapCoconeCoforkEquiv F (Cofork.condition c)).invFun\n  let p : parallelPair (F.map (f - g)) 0 ≅ parallelPair (F.map f - F.map g) 0 :=\n    parallelPair.ext (Iso.refl _) (Iso.refl _) (by simp) (by simp)\n  exact\n    IsColimit.ofIsoColimit\n      (isColimitCoforkOfCokernelCofork ((IsColimit.precomposeHomEquiv p.symm _).symm iFc))\n      (Cofork.ext (Iso.refl _) (by simp [p]))\n\n"}
{"name":"CategoryTheory.Functor.preservesCoequalizers_of_preservesCokernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝⁶ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁵ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝⁴ : CategoryTheory.Category.{v₂, u₂} D\ninst✝³ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝² : F.PreservesZeroMorphisms\ninst✝¹ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape CategoryTheory.Limits.WalkingParallelPair F","decl":"/-- A functor between preadditive categories preserves all coequalizers if it preserves all kernels.\n-/\nlemma preservesCoequalizers_of_preservesCokernels\n    [∀ {X Y} (f : X ⟶ Y), PreservesColimit (parallelPair f 0) F] :\n    PreservesColimitsOfShape WalkingParallelPair F where\n  preservesColimit {K} := by\n    letI := preservesCoequalizer_of_preservesCokernels F (K.map Limits.WalkingParallelPairHom.left)\n        (K.map Limits.WalkingParallelPairHom.right)\n    apply preservesColimit_of_iso_diagram F (diagramIsoParallelPair K).symm\n\n"}
{"name":"CategoryTheory.Functor.preservesFiniteColimits_of_preservesCokernels","module":"Mathlib.CategoryTheory.Preadditive.LeftExact","initialProofState":"C : Type u₁\ninst✝¹⁰ : CategoryTheory.Category.{v₁, u₁} C\ninst✝⁹ : CategoryTheory.Preadditive C\nD : Type u₂\ninst✝⁸ : CategoryTheory.Category.{v₂, u₂} D\ninst✝⁷ : CategoryTheory.Preadditive D\nF : CategoryTheory.Functor C D\ninst✝⁶ : F.PreservesZeroMorphisms\ninst✝⁵ : CategoryTheory.Limits.HasBinaryBiproducts C\ninst✝⁴ : CategoryTheory.Limits.HasFiniteCoproducts C\ninst✝³ : CategoryTheory.Limits.HasCoequalizers C\ninst✝² : CategoryTheory.Limits.HasZeroObject C\ninst✝¹ : CategoryTheory.Limits.HasZeroObject D\ninst✝ : ∀ {X Y : C} (f : Quiver.Hom X Y), CategoryTheory.Limits.PreservesColimit (CategoryTheory.Limits.parallelPair f 0) F\n⊢ CategoryTheory.Limits.PreservesFiniteColimits F","decl":"/-- A functor between preadditive categories which preserves kernels preserves all finite limits.\n-/\nlemma preservesFiniteColimits_of_preservesCokernels [HasFiniteCoproducts C] [HasCoequalizers C]\n    [HasZeroObject C] [HasZeroObject D]\n    [∀ {X Y} (f : X ⟶ Y), PreservesColimit (parallelPair f 0) F] : PreservesFiniteColimits F := by\n  letI := preservesCoequalizers_of_preservesCokernels F\n  letI := preservesInitialObject_of_preservesZeroMorphisms F\n  letI := preservesColimitsOfShape_pempty_of_preservesInitial F\n  letI : PreservesFiniteCoproducts F := ⟨preservesFiniteCoproductsOfPreservesBinaryAndInitial F⟩\n  exact preservesFiniteColimits_of_preservesCoequalizers_and_finiteCoproducts F\n\n"}
