{"name":"AddUnits.val_le_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoid α\ninst✝ : Preorder α\na b : AddUnits α\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_le_val [Monoid α] [Preorder α] {a b : αˣ} : (a : α) ≤ b ↔ a ≤ b :=\n  Iff.rfl\n\n"}
{"name":"Units.val_le_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : Monoid α\ninst✝ : Preorder α\na b : Units α\n⊢ Iff (LE.le ↑a ↑b) (LE.le a b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_le_val [Monoid α] [Preorder α] {a b : αˣ} : (a : α) ≤ b ↔ a ≤ b :=\n  Iff.rfl\n\n"}
{"name":"AddUnits.val_lt_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoid α\ninst✝ : Preorder α\na b : AddUnits α\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_lt_val [Monoid α] [Preorder α] {a b : αˣ} : (a : α) < b ↔ a < b :=\n  Iff.rfl\n\n"}
{"name":"Units.val_lt_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : Monoid α\ninst✝ : Preorder α\na b : Units α\n⊢ Iff (LT.lt ↑a ↑b) (LT.lt a b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem val_lt_val [Monoid α] [Preorder α] {a b : αˣ} : (a : α) < b ↔ a < b :=\n  Iff.rfl\n\n"}
{"name":"AddUnits.orderEmbeddingVal_apply","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoid α\ninst✝ : LinearOrder α\n⊢ Eq (⇑AddUnits.orderEmbeddingVal) AddUnits.val","decl":"/-- `val : αˣ → α` as an order embedding. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"`val : add_units α → α` as an order embedding.\"]\ndef orderEmbeddingVal [Monoid α] [LinearOrder α] : αˣ ↪o α :=\n  ⟨⟨val, ext⟩, Iff.rfl⟩\n\n"}
{"name":"Units.orderEmbeddingVal_apply","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : Monoid α\ninst✝ : LinearOrder α\n⊢ Eq (⇑Units.orderEmbeddingVal) Units.val","decl":"/-- `val : αˣ → α` as an order embedding. -/\n@[to_additive (attr := simps (config := .asFn))\n  \"`val : add_units α → α` as an order embedding.\"]\ndef orderEmbeddingVal [Monoid α] [LinearOrder α] : αˣ ↪o α :=\n  ⟨⟨val, ext⟩, Iff.rfl⟩\n\n"}
{"name":"Units.max_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : Monoid α\ninst✝ : LinearOrder α\na b : Units α\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem max_val [Monoid α] [LinearOrder α] {a b : αˣ} : (max a b).val = max a.val b.val :=\n  Monotone.map_max orderEmbeddingVal.monotone\n\n"}
{"name":"AddUnits.max_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoid α\ninst✝ : LinearOrder α\na b : AddUnits α\n⊢ Eq (↑(Max.max a b)) (Max.max ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem max_val [Monoid α] [LinearOrder α] {a b : αˣ} : (max a b).val = max a.val b.val :=\n  Monotone.map_max orderEmbeddingVal.monotone\n\n"}
{"name":"AddUnits.min_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : AddMonoid α\ninst✝ : LinearOrder α\na b : AddUnits α\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem min_val [Monoid α] [LinearOrder α] {a b : αˣ} : (min a b).val = min a.val b.val :=\n  Monotone.map_min orderEmbeddingVal.monotone\n\n"}
{"name":"Units.min_val","module":"Mathlib.Algebra.Order.Monoid.Units","initialProofState":"α : Type u_1\ninst✝¹ : Monoid α\ninst✝ : LinearOrder α\na b : Units α\n⊢ Eq (↑(Min.min a b)) (Min.min ↑a ↑b)","decl":"@[to_additive (attr := simp, norm_cast)]\ntheorem min_val [Monoid α] [LinearOrder α] {a b : αˣ} : (min a b).val = min a.val b.val :=\n  Monotone.map_min orderEmbeddingVal.monotone\n\n"}
