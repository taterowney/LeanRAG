{"name":"LinearMap.mulLeft_apply","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na b : A\n⊢ Eq ((LinearMap.mulLeft R a) b) (HMul.hMul a b)","decl":"@[simp]\ntheorem mulLeft_apply (a b : A) : mulLeft R a b = a * b := rfl\n\n"}
{"name":"LinearMap.mulLeft_toAddMonoidHom","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na : A\n⊢ Eq (↑(LinearMap.mulLeft R a)) (AddMonoidHom.mulLeft a)","decl":"@[simp]\ntheorem mulLeft_toAddMonoidHom (a : A) : (mulLeft R a : A →+ A) = AddMonoidHom.mulLeft a := rfl\n\n"}
{"name":"LinearMap.mulLeft_zero_eq_zero","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\n⊢ Eq (LinearMap.mulLeft R 0) 0","decl":"variable (A) in\n@[simp]\ntheorem mulLeft_zero_eq_zero : mulLeft R (0 : A) = 0 := ext fun _ => zero_mul _\n\n"}
{"name":"LinearMap.mulRight_apply","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na b : A\n⊢ Eq ((LinearMap.mulRight R a) b) (HMul.hMul b a)","decl":"@[simp]\ntheorem mulRight_apply (a b : A) : mulRight R a b = b * a := rfl\n\n"}
{"name":"LinearMap.mulRight_toAddMonoidHom","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na : A\n⊢ Eq (↑(LinearMap.mulRight R a)) (AddMonoidHom.mulRight a)","decl":"@[simp]\ntheorem mulRight_toAddMonoidHom (a : A) : (mulRight R a : A →+ A) = AddMonoidHom.mulRight a := rfl\n\n"}
{"name":"LinearMap.mulRight_zero_eq_zero","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalNonAssocSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\n⊢ Eq (LinearMap.mulRight R 0) 0","decl":"variable (A) in\n@[simp]\ntheorem mulRight_zero_eq_zero : mulRight R (0 : A) = 0 := ext fun _ => mul_zero _\n\n"}
{"name":"LinearMap.mul_apply_apply","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\nm x2✝ : A\n⊢ Eq (((LinearMap.mul R A) m) x2✝) (HMul.hMul m x2✝)","decl":"/-- The multiplication in a non-unital non-associative algebra is a bilinear map.\n\nA weaker version of this for semirings exists as `AddMonoidHom.mul`. -/\n@[simps!]\ndef mul : A →ₗ[R] A →ₗ[R] A :=\n  LinearMap.mk₂ R (· * ·) add_mul smul_mul_assoc mul_add mul_smul_comm\n\n"}
{"name":"LinearMap.mul_apply'","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\na b : A\n⊢ Eq (((LinearMap.mul R A) a) b) (HMul.hMul a b)","decl":"@[simp]\ntheorem mul_apply' (a b : A) : mul R A a b = a * b :=\n  rfl\n\n"}
{"name":"LinearMap.mulLeftRight_apply","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\na b x : A\n⊢ Eq ((LinearMap.mulLeftRight R { fst := a, snd := b }) x) (HMul.hMul (HMul.hMul a x) b)","decl":"@[simp]\ntheorem mulLeftRight_apply (a b x : A) : mulLeftRight R (a, b) x = a * x * b :=\n  rfl\n\n"}
{"name":"LinearMap.mul'_apply","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalNonAssocSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\na b : A\n⊢ Eq ((LinearMap.mul' R A) (TensorProduct.tmul R a b)) (HMul.hMul a b)","decl":"@[simp]\ntheorem mul'_apply {a b : A} : mul' R A (a ⊗ₜ b) = a * b :=\n  rfl\n\n"}
{"name":"LinearMap.mulLeft_mul","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalSemiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na b : A\n⊢ Eq (LinearMap.mulLeft R (HMul.hMul a b)) ((LinearMap.mulLeft R a).comp (LinearMap.mulLeft R b))","decl":"@[simp]\ntheorem mulLeft_mul [SMulCommClass R A A] (a b : A) :\n    mulLeft R (a * b) = (mulLeft R a).comp (mulLeft R b) := by\n  ext\n  simp only [mulLeft_apply, comp_apply, mul_assoc]\n\n"}
{"name":"LinearMap.mulRight_mul","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : NonUnitalSemiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na b : A\n⊢ Eq (LinearMap.mulRight R (HMul.hMul a b)) ((LinearMap.mulRight R b).comp (LinearMap.mulRight R a))","decl":"@[simp]\ntheorem mulRight_mul [IsScalarTower R A A] (a b : A) :\n    mulRight R (a * b) = (mulRight R b).comp (mulRight R a) := by\n  ext\n  simp only [mulRight_apply, comp_apply, mul_assoc]\n\n"}
{"name":"NonUnitalAlgHom.coe_lmul_eq_mul","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\n⊢ Eq ⇑(NonUnitalAlgHom.lmul R A) ⇑(LinearMap.mul R A)","decl":"@[simp]\ntheorem _root_.NonUnitalAlgHom.coe_lmul_eq_mul : ⇑(NonUnitalAlgHom.lmul R A) = mul R A :=\n  rfl\n\n"}
{"name":"LinearMap.commute_mulLeft_right","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝⁴ : CommSemiring R\ninst✝³ : NonUnitalSemiring A\ninst✝² : Module R A\ninst✝¹ : SMulCommClass R A A\ninst✝ : IsScalarTower R A A\na b : A\n⊢ Commute (LinearMap.mulLeft R a) (LinearMap.mulRight R b)","decl":"theorem commute_mulLeft_right (a b : A) : Commute (mulLeft R a) (mulRight R b) := by\n  ext c\n  exact (mul_assoc a c b).symm\n\n"}
{"name":"LinearMap.map_mul_iff","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\nB : Type u_3\ninst✝⁸ : CommSemiring R\ninst✝⁷ : NonUnitalSemiring A\ninst✝⁶ : NonUnitalSemiring B\ninst✝⁵ : Module R B\ninst✝⁴ : Module R A\ninst✝³ : SMulCommClass R A A\ninst✝² : IsScalarTower R A A\ninst✝¹ : SMulCommClass R B B\ninst✝ : IsScalarTower R B B\nf : LinearMap (RingHom.id R) A B\n⊢ Iff (∀ (x y : A), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))) (Eq ((LinearMap.mul R A).compr₂ f) (((LinearMap.mul R B).comp f).compl₂ f))","decl":"/-- A `LinearMap` preserves multiplication if pre- and post- composition with `LinearMap.mul` are\nequivalent. By converting the statement into an equality of `LinearMap`s, this lemma allows various\nspecialized `ext` lemmas about `→ₗ[R]` to then be applied.\n\nThis is the `LinearMap` version of `AddMonoidHom.map_mul_iff`. -/\ntheorem map_mul_iff (f : A →ₗ[R] B) :\n    (∀ x y, f (x * y) = f x * f y) ↔\n      (LinearMap.mul R A).compr₂ f = (LinearMap.mul R B ∘ₗ f).compl₂ f :=\n  Iff.symm LinearMap.ext_iff₂\n\n"}
{"name":"LinearMap.mulLeft_one","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\n⊢ Eq (LinearMap.mulLeft R 1) LinearMap.id","decl":"@[simp]\ntheorem mulLeft_one : mulLeft R (1 : A) = LinearMap.id := ext fun _ => one_mul _\n\n"}
{"name":"LinearMap.mulLeft_eq_zero_iff","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na : A\n⊢ Iff (Eq (LinearMap.mulLeft R a) 0) (Eq a 0)","decl":"@[simp]\ntheorem mulLeft_eq_zero_iff (a : A) : mulLeft R a = 0 ↔ a = 0 := by\n  constructor <;> intro h\n  -- Porting note: had to supply `R` explicitly in `@mulLeft_apply` below\n  · rw [← mul_one a, ← mulLeft_apply R a 1, h, LinearMap.zero_apply]\n  · rw [h]\n    exact mulLeft_zero_eq_zero _ _\n\n"}
{"name":"LinearMap.pow_mulLeft","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : SMulCommClass R A A\na : A\nn : Nat\n⊢ Eq (HPow.hPow (LinearMap.mulLeft R a) n) (LinearMap.mulLeft R (HPow.hPow a n))","decl":"@[simp]\ntheorem pow_mulLeft (a : A) (n : ℕ) : mulLeft R a ^ n = mulLeft R (a ^ n) :=\n  match n with\n  | 0 => by rw [pow_zero, pow_zero, mulLeft_one, LinearMap.one_eq_id]\n  | (n + 1) => by rw [pow_succ, pow_succ, mulLeft_mul, LinearMap.mul_eq_comp, pow_mulLeft]\n\n"}
{"name":"LinearMap.mulRight_one","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\n⊢ Eq (LinearMap.mulRight R 1) LinearMap.id","decl":"@[simp]\ntheorem mulRight_one : mulRight R (1 : A) = LinearMap.id := ext fun _ => mul_one _\n\n"}
{"name":"LinearMap.mulRight_eq_zero_iff","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na : A\n⊢ Iff (Eq (LinearMap.mulRight R a) 0) (Eq a 0)","decl":"@[simp]\ntheorem mulRight_eq_zero_iff (a : A) : mulRight R a = 0 ↔ a = 0 := by\n  constructor <;> intro h\n  -- Porting note: had to supply `R` explicitly in `@mulRight_apply` below\n  · rw [← one_mul a, ← mulRight_apply R a 1, h, LinearMap.zero_apply]\n  · rw [h]\n    exact mulRight_zero_eq_zero _ _\n\n"}
{"name":"LinearMap.pow_mulRight","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : Semiring R\ninst✝² : Semiring A\ninst✝¹ : Module R A\ninst✝ : IsScalarTower R A A\na : A\nn : Nat\n⊢ Eq (HPow.hPow (LinearMap.mulRight R a) n) (LinearMap.mulRight R (HPow.hPow a n))","decl":"@[simp]\ntheorem pow_mulRight (a : A) (n : ℕ) : mulRight R a ^ n = mulRight R (a ^ n) :=\n  match n with\n  | 0 => by rw [pow_zero, pow_zero, mulRight_one, LinearMap.one_eq_id]\n  | (n + 1) => by rw [pow_succ, pow_succ', mulRight_mul, LinearMap.mul_eq_comp, pow_mulRight]\n\n"}
{"name":"Algebra.coe_lmul_eq_mul","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq ⇑(Algebra.lmul R A) ⇑(LinearMap.mul R A)","decl":"@[simp]\ntheorem _root_.Algebra.coe_lmul_eq_mul : ⇑(Algebra.lmul R A) = mul R A :=\n  rfl\n\n"}
{"name":"Algebra.lmul_injective","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Function.Injective ⇑(Algebra.lmul R A)","decl":"theorem _root_.Algebra.lmul_injective : Function.Injective (Algebra.lmul R A) :=\n  fun a₁ a₂ h ↦ by simpa using DFunLike.congr_fun h 1\n\n"}
{"name":"Algebra.lmul_isUnit_iff","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\nx : A\n⊢ Iff (IsUnit ((Algebra.lmul R A) x)) (IsUnit x)","decl":"theorem _root_.Algebra.lmul_isUnit_iff {x : A} :\n    IsUnit (Algebra.lmul R A x) ↔ IsUnit x := by\n  rw [Module.End_isUnit_iff, Iff.comm]\n  exact IsUnit.isUnit_iff_mulLeft_bijective\n\n"}
{"name":"LinearMap.toSpanSingleton_eq_algebra_linearMap","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝² : CommSemiring R\ninst✝¹ : Semiring A\ninst✝ : Algebra R A\n⊢ Eq (LinearMap.toSpanSingleton R A 1) (Algebra.linearMap R A)","decl":"theorem toSpanSingleton_eq_algebra_linearMap : toSpanSingleton R A 1 = Algebra.linearMap R A := by\n  ext; simp\n\n"}
{"name":"LinearMap.mulLeft_injective","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroDivisors A\nx : A\nhx : Ne x 0\n⊢ Function.Injective ⇑(LinearMap.mulLeft R x)","decl":"@[deprecated mul_right_injective₀ (since := \"2024-11-18\")]\ntheorem mulLeft_injective [NoZeroDivisors A] {x : A} (hx : x ≠ 0) :\n    Function.Injective (mulLeft R x) :=\n  mul_right_injective₀ hx\n\n"}
{"name":"LinearMap.mulRight_injective","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroDivisors A\nx : A\nhx : Ne x 0\n⊢ Function.Injective ⇑(LinearMap.mulRight R x)","decl":"@[deprecated mul_left_injective₀ (since := \"2024-11-18\")]\ntheorem mulRight_injective [NoZeroDivisors A] {x : A} (hx : x ≠ 0) :\n    Function.Injective (mulRight R x) :=\n  mul_left_injective₀ hx\n\n"}
{"name":"LinearMap.mul_injective","module":"Mathlib.Algebra.Algebra.Bilinear","initialProofState":"R : Type u_1\nA : Type u_2\ninst✝³ : CommSemiring R\ninst✝² : Ring A\ninst✝¹ : Algebra R A\ninst✝ : NoZeroDivisors A\nx : A\nhx : Ne x 0\n⊢ Function.Injective ⇑((LinearMap.mul R A) x)","decl":"@[deprecated mul_right_injective₀ (since := \"2024-11-18\")]\ntheorem mul_injective [NoZeroDivisors A] {x : A} (hx : x ≠ 0) : Function.Injective (mul R A x) :=\n   mul_right_injective₀ hx\n\n"}
