{"name":"CategoryTheory.Pretriangulated.Opposite.commShift_natTrans_op_int","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_3, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_4, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\nG : CategoryTheory.Functor C D\ninst✝¹ : G.CommShift Int\nτ : Quiver.Hom F G\ninst✝ : CategoryTheory.NatTrans.CommShift τ Int\n⊢ CategoryTheory.NatTrans.CommShift (CategoryTheory.NatTrans.op τ) Int","decl":"noncomputable scoped instance commShift_natTrans_op_int {G : C ⥤ D} [G.CommShift ℤ] (τ : F ⟶ G)\n    [NatTrans.CommShift τ ℤ] : NatTrans.CommShift (NatTrans.op τ) ℤ :=\n  inferInstanceAs (NatTrans.CommShift (PullbackShift.natTrans\n    (AddMonoidHom.mk' (fun (n : ℤ) => -n) (by intros; dsimp; omega))\n      (OppositeShift.natTrans ℤ τ)) ℤ)\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.commShift_adjunction_op_int","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁶ : CategoryTheory.Category.{u_4, u_1} C\ninst✝⁵ : CategoryTheory.Category.{u_3, u_2} D\ninst✝⁴ : CategoryTheory.HasShift C Int\ninst✝³ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝² : F.CommShift Int\nG : CategoryTheory.Functor D C\ninst✝¹ : G.CommShift Int\nadj : CategoryTheory.Adjunction F G\ninst✝ : adj.CommShift Int\n⊢ adj.op.CommShift Int","decl":"noncomputable scoped instance commShift_adjunction_op_int {G : D ⥤ C} [G.CommShift ℤ] (adj : F ⊣ G)\n    [Adjunction.CommShift adj ℤ] : Adjunction.CommShift adj.op ℤ := by\n  have eq : adj.op = PullbackShift.adjunction\n    (AddMonoidHom.mk' (fun (n : ℤ) => -n) (by intros; dsimp; omega))\n      (OppositeShift.adjunction ℤ adj) := by\n    ext\n    dsimp [PullbackShift.adjunction, NatTrans.PullbackShift.natIsoId,\n      NatTrans.PullbackShift.natIsoComp, PullbackShift.functor, PullbackShift.natTrans,\n      OppositeShift.adjunction, OppositeShift.natTrans, NatTrans.OppositeShift.natIsoId,\n      NatTrans.OppositeShift.natIsoComp, OppositeShift.functor]\n    simp only [Int.reduceNeg, Category.comp_id, Category.id_comp]\n  rw [eq]\n  exact inferInstanceAs (Adjunction.CommShift (PullbackShift.adjunction\n    (AddMonoidHom.mk' (fun (n : ℤ) => -n) (by intros; dsimp; omega))\n      (OppositeShift.adjunction ℤ adj)) ℤ)\n\n"}
{"name":"CategoryTheory.Functor.op_commShiftIso_hom_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn m : Int\nh : Eq (HAdd.hAdd n m) 0\n⊢ Eq ((F.op.commShiftIso n).hom.app X) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C n m h).hom.app X).unop).op (CategoryTheory.CategoryStruct.comp ((F.commShiftIso m).inv.app (Opposite.unop X)).op ((CategoryTheory.Pretriangulated.shiftFunctorOpIso D n m h).inv.app { unop := F.obj (Opposite.unop X) })))","decl":"@[reassoc]\nlemma op_commShiftIso_hom_app (X : Cᵒᵖ) (n m : ℤ) (h : n + m = 0):\n    (F.op.commShiftIso n).hom.app X =\n      (F.map ((shiftFunctorOpIso C n m h).hom.app X).unop).op ≫\n        ((F.commShiftIso m).inv.app X.unop).op ≫\n        (shiftFunctorOpIso D n m h).inv.app (op (F.obj X.unop)) := by\n  obtain rfl : m = -n := by omega\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.op_commShiftIso_hom_app_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn m : Int\nh✝ : Eq (HAdd.hAdd n m) 0\nZ : Opposite D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (Opposite D) n).obj (F.op.obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).hom.app X) h) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C n m h✝).hom.app X).unop).op (CategoryTheory.CategoryStruct.comp ((F.commShiftIso m).inv.app (Opposite.unop X)).op (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso D n m h✝).inv.app { unop := F.obj (Opposite.unop X) }) h)))","decl":"@[reassoc]\nlemma op_commShiftIso_hom_app (X : Cᵒᵖ) (n m : ℤ) (h : n + m = 0):\n    (F.op.commShiftIso n).hom.app X =\n      (F.map ((shiftFunctorOpIso C n m h).hom.app X).unop).op ≫\n        ((F.commShiftIso m).inv.app X.unop).op ≫\n        (shiftFunctorOpIso D n m h).inv.app (op (F.obj X.unop)) := by\n  obtain rfl : m = -n := by omega\n  rfl\n\n"}
{"name":"CategoryTheory.Functor.op_commShiftIso_inv_app","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn m : Int\nh : Eq (HAdd.hAdd n m) 0\n⊢ Eq ((F.op.commShiftIso n).inv.app X) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso D n m h).hom.app { unop := F.obj (Opposite.unop X) }) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso m).hom.app (Opposite.unop X)).op (F.map ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C n m h).inv.app X).unop).op))","decl":"@[reassoc]\nlemma op_commShiftIso_inv_app (X : Cᵒᵖ) (n m : ℤ) (h : n + m = 0):\n    (F.op.commShiftIso n).inv.app X =\n      (shiftFunctorOpIso D n m h).hom.app (op (F.obj X.unop)) ≫\n        ((F.commShiftIso m).hom.app X.unop).op ≫\n          (F.map ((shiftFunctorOpIso C n m h).inv.app X).unop).op := by\n  rw [← cancel_epi ((F.op.commShiftIso n).hom.app X), Iso.hom_inv_id_app,\n    op_commShiftIso_hom_app _ X n m h, assoc, assoc]\n  simp [← op_comp, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.op_commShiftIso_inv_app_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn m : Int\nh✝ : Eq (HAdd.hAdd n m) 0\nZ : Opposite D\nh : Quiver.Hom (F.op.obj ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app X) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.shiftFunctorOpIso D n m h✝).hom.app { unop := F.obj (Opposite.unop X) }) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso m).hom.app (Opposite.unop X)).op (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.shiftFunctorOpIso C n m h✝).inv.app X).unop).op h)))","decl":"@[reassoc]\nlemma op_commShiftIso_inv_app (X : Cᵒᵖ) (n m : ℤ) (h : n + m = 0):\n    (F.op.commShiftIso n).inv.app X =\n      (shiftFunctorOpIso D n m h).hom.app (op (F.obj X.unop)) ≫\n        ((F.commShiftIso m).hom.app X.unop).op ≫\n          (F.map ((shiftFunctorOpIso C n m h).inv.app X).unop).op := by\n  rw [← cancel_epi ((F.op.commShiftIso n).hom.app X), Iso.hom_inv_id_app,\n    op_commShiftIso_hom_app _ X n m h, assoc, assoc]\n  simp [← op_comp, ← F.map_comp]\n\n"}
{"name":"CategoryTheory.Functor.shift_map_op_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX Y : C\nf : Quiver.Hom X Y\nn : Int\nZ : Opposite D\nh : Quiver.Hom ((CategoryTheory.shiftFunctor (Opposite D) n).obj { unop := F.obj X }) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map (F.map f).op) h) (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app { unop := Y }) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor (Opposite C) n).map f.op).unop).op (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).hom.app { unop := X }) h)))","decl":"@[reassoc]\nlemma shift_map_op {X Y : C} (f : X ⟶ Y) (n : ℤ) :\n    (F.map f).op⟦n⟧' = (F.op.commShiftIso n).inv.app _ ≫\n      (F.map (f.op⟦n⟧').unop).op ≫ (F.op.commShiftIso n).hom.app _ :=\n  (NatIso.naturality_1 (F.op.commShiftIso n) f.op).symm\n\n"}
{"name":"CategoryTheory.Functor.shift_map_op","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX Y : C\nf : Quiver.Hom X Y\nn : Int\n⊢ Eq ((CategoryTheory.shiftFunctor (Opposite D) n).map (F.map f).op) (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app { unop := Y }) (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor (Opposite C) n).map f.op).unop).op ((F.op.commShiftIso n).hom.app { unop := X })))","decl":"@[reassoc]\nlemma shift_map_op {X Y : C} (f : X ⟶ Y) (n : ℤ) :\n    (F.map f).op⟦n⟧' = (F.op.commShiftIso n).inv.app _ ≫\n      (F.map (f.op⟦n⟧').unop).op ≫ (F.op.commShiftIso n).hom.app _ :=\n  (NatIso.naturality_1 (F.op.commShiftIso n) f.op).symm\n\n"}
{"name":"CategoryTheory.Functor.map_shift_unop","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX Y : Opposite C\nf : Quiver.Hom X Y\nn : Int\n⊢ Eq (F.map ((CategoryTheory.shiftFunctor (Opposite C) n).map f).unop) (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app Y).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map (F.map f.unop).op).unop ((F.op.commShiftIso n).hom.app X).unop))","decl":"@[reassoc]\nlemma map_shift_unop {X Y : Cᵒᵖ} (f : X ⟶ Y) (n : ℤ) :\n    F.map ((f⟦n⟧').unop) = ((F.op.commShiftIso n).inv.app Y).unop ≫\n      ((F.map f.unop).op⟦n⟧').unop ≫ ((F.op.commShiftIso n).hom.app X).unop := by\n  simp [shift_map_op]\n\n"}
{"name":"CategoryTheory.Functor.map_shift_unop_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX Y : Opposite C\nf : Quiver.Hom X Y\nn : Int\nZ : D\nh : Quiver.Hom (F.obj (Opposite.unop ((CategoryTheory.shiftFunctor (Opposite C) n).obj X))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.shiftFunctor (Opposite C) n).map f).unop) h) (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app Y).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map (F.map f.unop).op).unop (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).hom.app X).unop h)))","decl":"@[reassoc]\nlemma map_shift_unop {X Y : Cᵒᵖ} (f : X ⟶ Y) (n : ℤ) :\n    F.map ((f⟦n⟧').unop) = ((F.op.commShiftIso n).inv.app Y).unop ≫\n      ((F.map f.unop).op⟦n⟧').unop ≫ ((F.op.commShiftIso n).hom.app X).unop := by\n  simp [shift_map_op]\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_unitIso_hom_app_unop_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\nZ : D\nh : Quiver.Hom (F.obj (Opposite.unop X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app X).unop) h) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso n).hom.app (Opposite.unop ((CategoryTheory.shiftFunctor (Opposite C) n).obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.op.commShiftIso n).inv.app X).unop) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).unitIso.hom.app { unop := F.obj (Opposite.unop X) }).unop h)))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_unitIso_hom_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).unitIso.hom.app X).unop =\n      (F.commShiftIso n).hom.app _ ≫\n        (((F.op).commShiftIso n).inv.app X).unop⟦n⟧' ≫\n        ((opShiftFunctorEquivalence D n).unitIso.hom.app (op _)).unop := by\n  dsimp [opShiftFunctorEquivalence]\n  simp only [map_comp, unop_comp, Quiver.Hom.unop_op, assoc,\n    map_shiftFunctorCompIsoId_hom_app, commShiftIso_hom_naturality_assoc,\n    op_commShiftIso_inv_app _ _ _ _ (add_neg_cancel n)]\n  congr 3\n  rw [← Functor.map_comp_assoc, ← unop_comp,\n    Iso.inv_hom_id_app]\n  dsimp\n  rw [map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_unitIso_hom_app_unop","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\n⊢ Eq (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.hom.app X).unop) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso n).hom.app (Opposite.unop ((CategoryTheory.shiftFunctor (Opposite C) n).obj X))) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.op.commShiftIso n).inv.app X).unop) ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).unitIso.hom.app { unop := F.obj (Opposite.unop X) }).unop))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_unitIso_hom_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).unitIso.hom.app X).unop =\n      (F.commShiftIso n).hom.app _ ≫\n        (((F.op).commShiftIso n).inv.app X).unop⟦n⟧' ≫\n        ((opShiftFunctorEquivalence D n).unitIso.hom.app (op _)).unop := by\n  dsimp [opShiftFunctorEquivalence]\n  simp only [map_comp, unop_comp, Quiver.Hom.unop_op, assoc,\n    map_shiftFunctorCompIsoId_hom_app, commShiftIso_hom_naturality_assoc,\n    op_commShiftIso_inv_app _ _ _ _ (add_neg_cancel n)]\n  congr 3\n  rw [← Functor.map_comp_assoc, ← unop_comp,\n    Iso.inv_hom_id_app]\n  dsimp\n  rw [map_id, id_comp]\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_unitIso_inv_app_unop","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\n⊢ Eq (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app X).unop) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).unitIso.inv.app { unop := F.obj (Opposite.unop X) }).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.op.commShiftIso n).hom.app X).unop) ((F.commShiftIso n).inv.app (Opposite.unop ((CategoryTheory.shiftFunctor (Opposite C) n).obj X)))))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_unitIso_inv_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).unitIso.inv.app X).unop =\n      ((opShiftFunctorEquivalence D n).unitIso.inv.app (op (F.obj X.unop))).unop ≫\n        (((F.op).commShiftIso n).hom.app X).unop⟦n⟧' ≫\n        ((F.commShiftIso n).inv.app _) := by\n  rw [← cancel_mono (F.map ((opShiftFunctorEquivalence C n).unitIso.hom.app X).unop),\n    ← F.map_comp, ← unop_comp, Iso.hom_inv_id_app,\n    map_opShiftFunctorEquivalence_unitIso_hom_app_unop, assoc, assoc,\n    Iso.inv_hom_id_app_assoc, ← Functor.map_comp_assoc, ← unop_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_unitIso_inv_app_unop_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\nZ : D\nh : Quiver.Hom (F.obj (Opposite.unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).inverse.obj ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).functor.obj X)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).unitIso.inv.app X).unop) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).unitIso.inv.app { unop := F.obj (Opposite.unop X) }).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor D n).map ((F.op.commShiftIso n).hom.app X).unop) (CategoryTheory.CategoryStruct.comp ((F.commShiftIso n).inv.app (Opposite.unop ((CategoryTheory.shiftFunctor (Opposite C) n).obj X))) h)))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_unitIso_inv_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).unitIso.inv.app X).unop =\n      ((opShiftFunctorEquivalence D n).unitIso.inv.app (op (F.obj X.unop))).unop ≫\n        (((F.op).commShiftIso n).hom.app X).unop⟦n⟧' ≫\n        ((F.commShiftIso n).inv.app _) := by\n  rw [← cancel_mono (F.map ((opShiftFunctorEquivalence C n).unitIso.hom.app X).unop),\n    ← F.map_comp, ← unop_comp, Iso.hom_inv_id_app,\n    map_opShiftFunctorEquivalence_unitIso_hom_app_unop, assoc, assoc,\n    Iso.inv_hom_id_app_assoc, ← Functor.map_comp_assoc, ← unop_comp]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_counitIso_hom_app_unop","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\n⊢ Eq (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app X).unop) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).counitIso.hom.app { unop := F.obj (Opposite.unop X) }).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map ((F.commShiftIso n).inv.app (Opposite.unop X)).op).unop ((F.op.commShiftIso n).hom.app { unop := (CategoryTheory.shiftFunctor C n).obj (Opposite.unop X) }).unop))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_counitIso_hom_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).counitIso.hom.app X).unop =\n      ((opShiftFunctorEquivalence D n).counitIso.hom.app (op (F.obj X.unop))).unop ≫\n        (((F.commShiftIso n).inv.app X.unop).op⟦n⟧').unop ≫\n          ((F.op.commShiftIso n).hom.app (op (X.unop⟦n⟧))).unop := by\n  apply Quiver.Hom.op_inj\n  dsimp [opShiftFunctorEquivalence]\n  rw [assoc, F.op_commShiftIso_hom_app_assoc _ _ _ (add_neg_cancel n), map_comp,\n    map_shiftFunctorCompIsoId_inv_app_assoc, op_comp, op_comp_assoc, op_comp_assoc,\n    NatTrans.naturality_assoc, op_map, Iso.inv_hom_id_app_assoc, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_counitIso_hom_app_unop_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\nZ : D\nh : Quiver.Hom (F.obj (Opposite.unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).functor.obj ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).inverse.obj X)))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.hom.app X).unop) h) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).counitIso.hom.app { unop := F.obj (Opposite.unop X) }).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map ((F.commShiftIso n).inv.app (Opposite.unop X)).op).unop (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).hom.app { unop := (CategoryTheory.shiftFunctor C n).obj (Opposite.unop X) }).unop h)))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_counitIso_hom_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).counitIso.hom.app X).unop =\n      ((opShiftFunctorEquivalence D n).counitIso.hom.app (op (F.obj X.unop))).unop ≫\n        (((F.commShiftIso n).inv.app X.unop).op⟦n⟧').unop ≫\n          ((F.op.commShiftIso n).hom.app (op (X.unop⟦n⟧))).unop := by\n  apply Quiver.Hom.op_inj\n  dsimp [opShiftFunctorEquivalence]\n  rw [assoc, F.op_commShiftIso_hom_app_assoc _ _ _ (add_neg_cancel n), map_comp,\n    map_shiftFunctorCompIsoId_inv_app_assoc, op_comp, op_comp_assoc, op_comp_assoc,\n    NatTrans.naturality_assoc, op_map, Iso.inv_hom_id_app_assoc, Quiver.Hom.unop_op]\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_counitIso_inv_app_unop","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\n⊢ Eq (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app X).unop) (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app { unop := (CategoryTheory.shiftFunctor C n).obj (Opposite.unop X) }).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map ((F.commShiftIso n).hom.app (Opposite.unop X)).op).unop ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).counitIso.inv.app { unop := F.obj (Opposite.unop X) }).unop))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_counitIso_inv_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).counitIso.inv.app X).unop =\n      ((F.op.commShiftIso n).inv.app (op (X.unop⟦n⟧))).unop ≫\n        (((F.commShiftIso n).hom.app X.unop).op⟦n⟧').unop ≫\n          ((opShiftFunctorEquivalence D n).counitIso.inv.app (op (F.obj X.unop))).unop := by\n  rw [← cancel_epi (F.map ((opShiftFunctorEquivalence C n).counitIso.hom.app X).unop),\n    ← F.map_comp, ← unop_comp, Iso.inv_hom_id_app,\n    map_opShiftFunctorEquivalence_counitIso_hom_app_unop]\n  dsimp\n  simp only [map_id, assoc, Iso.unop_hom_inv_id_app_assoc, ← Functor.map_comp_assoc,\n    ← unop_comp, Iso.inv_hom_id_app_assoc, ← unop_comp_assoc, ← op_comp,\n    Iso.inv_hom_id_app]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.map_opShiftFunctorEquivalence_counitIso_inv_app_unop_assoc","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_4, u_1} C\ninst✝³ : CategoryTheory.Category.{u_3, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nX : Opposite C\nn : Int\nZ : D\nh : Quiver.Hom (F.obj (Opposite.unop X)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence C n).counitIso.inv.app X).unop) h) (CategoryTheory.CategoryStruct.comp ((F.op.commShiftIso n).inv.app { unop := (CategoryTheory.shiftFunctor C n).obj (Opposite.unop X) }).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.shiftFunctor (Opposite D) n).map ((F.commShiftIso n).hom.app (Opposite.unop X)).op).unop (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Pretriangulated.opShiftFunctorEquivalence D n).counitIso.inv.app { unop := F.obj (Opposite.unop X) }).unop h)))","decl":"@[reassoc]\nlemma map_opShiftFunctorEquivalence_counitIso_inv_app_unop (X : Cᵒᵖ) (n : ℤ) :\n    F.map ((opShiftFunctorEquivalence C n).counitIso.inv.app X).unop =\n      ((F.op.commShiftIso n).inv.app (op (X.unop⟦n⟧))).unop ≫\n        (((F.commShiftIso n).hom.app X.unop).op⟦n⟧').unop ≫\n          ((opShiftFunctorEquivalence D n).counitIso.inv.app (op (F.obj X.unop))).unop := by\n  rw [← cancel_epi (F.map ((opShiftFunctorEquivalence C n).counitIso.hom.app X).unop),\n    ← F.map_comp, ← unop_comp, Iso.inv_hom_id_app,\n    map_opShiftFunctorEquivalence_counitIso_hom_app_unop]\n  dsimp\n  simp only [map_id, assoc, Iso.unop_hom_inv_id_app_assoc, ← Functor.map_comp_assoc,\n    ← unop_comp, Iso.inv_hom_id_app_assoc, ← unop_comp_assoc, ← op_comp,\n    Iso.inv_hom_id_app]\n  simp\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleOpCompTriangleOpEquivalenceFunctorApp_hom_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleOpCompTriangleOpEquivalenceFunctorApp T).hom.hom₂ (CategoryTheory.CategoryStruct.id { unop := F.obj T.obj₂ })","decl":"/--\nIf `F : C ⥤ D` commutes with shifts, this expresses the compatibility of `F.mapTriangle`\nwith the equivalences `Pretriangulated.triangleOpEquivalence` on `C` and `D`.\n-/\n@[simps!]\nnoncomputable def mapTriangleOpCompTriangleOpEquivalenceFunctorApp (T : Triangle C) :\n    (triangleOpEquivalence D).functor.obj (op (F.mapTriangle.obj T)) ≅\n      F.op.mapTriangle.obj ((triangleOpEquivalence C).functor.obj (op T)) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n    (by dsimp; simp) (by dsimp; simp) (by\n      dsimp\n      simp only [map_comp, shift_map_op, map_id, comp_id, op_comp, op_unop,\n        map_opShiftFunctorEquivalence_counitIso_inv_app_unop,\n        opShiftFunctorEquivalence_inverse, opShiftFunctorEquivalence_functor,\n        Quiver.Hom.op_unop, assoc, id_comp])\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleOpCompTriangleOpEquivalenceFunctorApp_hom_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleOpCompTriangleOpEquivalenceFunctorApp T).hom.hom₁ (CategoryTheory.CategoryStruct.id { unop := F.obj T.obj₃ })","decl":"/--\nIf `F : C ⥤ D` commutes with shifts, this expresses the compatibility of `F.mapTriangle`\nwith the equivalences `Pretriangulated.triangleOpEquivalence` on `C` and `D`.\n-/\n@[simps!]\nnoncomputable def mapTriangleOpCompTriangleOpEquivalenceFunctorApp (T : Triangle C) :\n    (triangleOpEquivalence D).functor.obj (op (F.mapTriangle.obj T)) ≅\n      F.op.mapTriangle.obj ((triangleOpEquivalence C).functor.obj (op T)) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n    (by dsimp; simp) (by dsimp; simp) (by\n      dsimp\n      simp only [map_comp, shift_map_op, map_id, comp_id, op_comp, op_unop,\n        map_opShiftFunctorEquivalence_counitIso_inv_app_unop,\n        opShiftFunctorEquivalence_inverse, opShiftFunctorEquivalence_functor,\n        Quiver.Hom.op_unop, assoc, id_comp])\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleOpCompTriangleOpEquivalenceFunctorApp_inv_hom₂","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleOpCompTriangleOpEquivalenceFunctorApp T).inv.hom₂ (CategoryTheory.CategoryStruct.id { unop := F.obj T.obj₂ })","decl":"/--\nIf `F : C ⥤ D` commutes with shifts, this expresses the compatibility of `F.mapTriangle`\nwith the equivalences `Pretriangulated.triangleOpEquivalence` on `C` and `D`.\n-/\n@[simps!]\nnoncomputable def mapTriangleOpCompTriangleOpEquivalenceFunctorApp (T : Triangle C) :\n    (triangleOpEquivalence D).functor.obj (op (F.mapTriangle.obj T)) ≅\n      F.op.mapTriangle.obj ((triangleOpEquivalence C).functor.obj (op T)) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n    (by dsimp; simp) (by dsimp; simp) (by\n      dsimp\n      simp only [map_comp, shift_map_op, map_id, comp_id, op_comp, op_unop,\n        map_opShiftFunctorEquivalence_counitIso_inv_app_unop,\n        opShiftFunctorEquivalence_inverse, opShiftFunctorEquivalence_functor,\n        Quiver.Hom.op_unop, assoc, id_comp])\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleOpCompTriangleOpEquivalenceFunctorApp_inv_hom₁","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleOpCompTriangleOpEquivalenceFunctorApp T).inv.hom₁ (CategoryTheory.CategoryStruct.id { unop := F.obj T.obj₃ })","decl":"/--\nIf `F : C ⥤ D` commutes with shifts, this expresses the compatibility of `F.mapTriangle`\nwith the equivalences `Pretriangulated.triangleOpEquivalence` on `C` and `D`.\n-/\n@[simps!]\nnoncomputable def mapTriangleOpCompTriangleOpEquivalenceFunctorApp (T : Triangle C) :\n    (triangleOpEquivalence D).functor.obj (op (F.mapTriangle.obj T)) ≅\n      F.op.mapTriangle.obj ((triangleOpEquivalence C).functor.obj (op T)) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n    (by dsimp; simp) (by dsimp; simp) (by\n      dsimp\n      simp only [map_comp, shift_map_op, map_id, comp_id, op_comp, op_unop,\n        map_opShiftFunctorEquivalence_counitIso_inv_app_unop,\n        opShiftFunctorEquivalence_inverse, opShiftFunctorEquivalence_functor,\n        Quiver.Hom.op_unop, assoc, id_comp])\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleOpCompTriangleOpEquivalenceFunctorApp_hom_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleOpCompTriangleOpEquivalenceFunctorApp T).hom.hom₃ (CategoryTheory.CategoryStruct.id { unop := F.obj T.obj₁ })","decl":"/--\nIf `F : C ⥤ D` commutes with shifts, this expresses the compatibility of `F.mapTriangle`\nwith the equivalences `Pretriangulated.triangleOpEquivalence` on `C` and `D`.\n-/\n@[simps!]\nnoncomputable def mapTriangleOpCompTriangleOpEquivalenceFunctorApp (T : Triangle C) :\n    (triangleOpEquivalence D).functor.obj (op (F.mapTriangle.obj T)) ≅\n      F.op.mapTriangle.obj ((triangleOpEquivalence C).functor.obj (op T)) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n    (by dsimp; simp) (by dsimp; simp) (by\n      dsimp\n      simp only [map_comp, shift_map_op, map_id, comp_id, op_comp, op_unop,\n        map_opShiftFunctorEquivalence_counitIso_inv_app_unop,\n        opShiftFunctorEquivalence_inverse, opShiftFunctorEquivalence_functor,\n        Quiver.Hom.op_unop, assoc, id_comp])\n\n"}
{"name":"CategoryTheory.Functor.mapTriangleOpCompTriangleOpEquivalenceFunctorApp_inv_hom₃","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_1} C\ninst✝³ : CategoryTheory.Category.{u_4, u_2} D\ninst✝² : CategoryTheory.HasShift C Int\ninst✝¹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝ : F.CommShift Int\nT : CategoryTheory.Pretriangulated.Triangle C\n⊢ Eq (F.mapTriangleOpCompTriangleOpEquivalenceFunctorApp T).inv.hom₃ (CategoryTheory.CategoryStruct.id { unop := F.obj T.obj₁ })","decl":"/--\nIf `F : C ⥤ D` commutes with shifts, this expresses the compatibility of `F.mapTriangle`\nwith the equivalences `Pretriangulated.triangleOpEquivalence` on `C` and `D`.\n-/\n@[simps!]\nnoncomputable def mapTriangleOpCompTriangleOpEquivalenceFunctorApp (T : Triangle C) :\n    (triangleOpEquivalence D).functor.obj (op (F.mapTriangle.obj T)) ≅\n      F.op.mapTriangle.obj ((triangleOpEquivalence C).functor.obj (op T)) :=\n  Triangle.isoMk _ _ (Iso.refl _) (Iso.refl _) (Iso.refl _)\n    (by dsimp; simp) (by dsimp; simp) (by\n      dsimp\n      simp only [map_comp, shift_map_op, map_id, comp_id, op_comp, op_unop,\n        map_opShiftFunctorEquivalence_counitIso_inv_app_unop,\n        opShiftFunctorEquivalence_inverse, opShiftFunctorEquivalence_functor,\n        Quiver.Hom.op_unop, assoc, id_comp])\n\n"}
{"name":"CategoryTheory.Pretriangulated.Opposite.functor_isTriangulated_op","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁹ : F.CommShift Int\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject D\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated D\ninst✝ : F.IsTriangulated\n⊢ F.op.IsTriangulated","decl":"open Functor in\n/-- If `F` is triangulated, so is `F.op`.\n-/\nscoped instance functor_isTriangulated_op [F.IsTriangulated] : F.op.IsTriangulated where\n  map_distinguished T dT := by\n    rw [mem_distTriang_op_iff]\n    exact Pretriangulated.isomorphic_distinguished _\n      ((F.map_distinguished _ (unop_distinguished _ dT))) _\n      (((opMapTriangleCompTriangleOpEquivalenceInverse F).symm.app T).unop)\n\n"}
{"name":"CategoryTheory.Functor.isTriangulated_of_op","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹³ : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹² : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹¹ : CategoryTheory.HasShift C Int\ninst✝¹⁰ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁹ : F.CommShift Int\ninst✝⁸ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁷ : CategoryTheory.Preadditive C\ninst✝⁶ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁵ : CategoryTheory.Pretriangulated C\ninst✝⁴ : CategoryTheory.Limits.HasZeroObject D\ninst✝³ : CategoryTheory.Preadditive D\ninst✝² : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝¹ : CategoryTheory.Pretriangulated D\ninst✝ : F.op.IsTriangulated\n⊢ F.IsTriangulated","decl":"/-- If `F.op` is triangulated, so is `F`.\n-/\nlemma isTriangulated_of_op [F.op.IsTriangulated] : F.IsTriangulated where\n  map_distinguished T dT := by\n    have := distinguished_iff_of_iso ((triangleOpEquivalence D).unitIso.app\n      (Opposite.op (F.mapTriangle.obj T))).unop\n    rw [Functor.id_obj, Opposite.unop_op (F.mapTriangle.obj T)] at this\n    rw [← this, Functor.comp_obj, ← mem_distTriang_op_iff, ← Functor.op_obj, ← Functor.comp_obj,\n      distinguished_iff_of_iso ((mapTriangleOpCompTriangleOpEquivalenceFunctor F).app\n      (Opposite.op T))]\n    apply F.op.map_distinguished\n    have := distinguished_iff_of_iso ((triangleOpEquivalence C).unitIso.app (Opposite.op T)).unop\n    rw [Functor.id_obj, Opposite.unop_op T] at this\n    rw [← this, Functor.comp_obj, ← mem_distTriang_op_iff] at dT\n    exact dT\n\n"}
{"name":"CategoryTheory.Functor.op_isTriangulated_iff","module":"Mathlib.CategoryTheory.Triangulated.Opposite.Functor","initialProofState":"C : Type u_1\nD : Type u_2\ninst✝¹² : CategoryTheory.Category.{u_3, u_1} C\ninst✝¹¹ : CategoryTheory.Category.{u_4, u_2} D\ninst✝¹⁰ : CategoryTheory.HasShift C Int\ninst✝⁹ : CategoryTheory.HasShift D Int\nF : CategoryTheory.Functor C D\ninst✝⁸ : F.CommShift Int\ninst✝⁷ : CategoryTheory.Limits.HasZeroObject C\ninst✝⁶ : CategoryTheory.Preadditive C\ninst✝⁵ : ∀ (n : Int), (CategoryTheory.shiftFunctor C n).Additive\ninst✝⁴ : CategoryTheory.Pretriangulated C\ninst✝³ : CategoryTheory.Limits.HasZeroObject D\ninst✝² : CategoryTheory.Preadditive D\ninst✝¹ : ∀ (n : Int), (CategoryTheory.shiftFunctor D n).Additive\ninst✝ : CategoryTheory.Pretriangulated D\n⊢ Iff F.op.IsTriangulated F.IsTriangulated","decl":"open Pretriangulated.Opposite in\n/-- `F` is triangulated if and only if `F.op` is triangulated.\n-/\nlemma op_isTriangulated_iff : F.op.IsTriangulated ↔ F.IsTriangulated :=\n  ⟨fun _ ↦ F.isTriangulated_of_op, fun _ ↦ inferInstance⟩\n\n"}
