{"name":"Nat.factorial_zero","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"⊢ Eq (Nat.factorial 0) 1","decl":"@[simp] theorem factorial_zero : 0! = 1 :=\n  rfl\n\n"}
{"name":"Nat.factorial_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Eq (HAdd.hAdd n 1).factorial (HMul.hMul (HAdd.hAdd n 1) n.factorial)","decl":"theorem factorial_succ (n : ℕ) : (n + 1)! = (n + 1) * n ! :=\n  rfl\n\n\n"}
{"name":"Nat.factorial_one","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"⊢ Eq (Nat.factorial 1) 1","decl":"@[simp] theorem factorial_one : 1! = 1 :=\n  rfl\n\n"}
{"name":"Nat.factorial_two","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"⊢ Eq (Nat.factorial 2) 2","decl":"@[simp] theorem factorial_two : 2! = 2 :=\n  rfl\n\n"}
{"name":"Nat.mul_factorial_pred","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\nhn : LT.lt 0 n\n⊢ Eq (HMul.hMul n (HSub.hSub n 1).factorial) n.factorial","decl":"theorem mul_factorial_pred (hn : 0 < n) : n * (n - 1)! = n ! :=\n  Nat.sub_add_cancel (Nat.succ_le_of_lt hn) ▸ rfl\n\n"}
{"name":"Nat.factorial_pos","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ LT.lt 0 n.factorial","decl":"theorem factorial_pos : ∀ n, 0 < n !\n  | 0 => Nat.zero_lt_one\n  | succ n => Nat.mul_pos (succ_pos _) (factorial_pos n)\n\n"}
{"name":"Nat.factorial_ne_zero","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Ne n.factorial 0","decl":"theorem factorial_ne_zero (n : ℕ) : n ! ≠ 0 :=\n  ne_of_gt (factorial_pos _)\n\n"}
{"name":"Nat.factorial_dvd_factorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ Dvd.dvd m.factorial n.factorial","decl":"theorem factorial_dvd_factorial {m n} (h : m ≤ n) : m ! ∣ n ! := by\n  induction h with\n  | refl => exact Nat.dvd_refl _\n  | step _ ih => exact Nat.dvd_trans ih (Nat.dvd_mul_left _ _)\n\n"}
{"name":"Nat.dvd_factorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\na✝¹ : LT.lt 0 m\na✝ : LE.le m n\n⊢ Dvd.dvd m n.factorial","decl":"theorem dvd_factorial : ∀ {m n}, 0 < m → m ≤ n → m ∣ n !\n  | succ _, _, _, h => Nat.dvd_trans (Nat.dvd_mul_right _ _) (factorial_dvd_factorial h)\n\n"}
{"name":"Nat.factorial_le","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\nh : LE.le m n\n⊢ LE.le m.factorial n.factorial","decl":"@[mono, gcongr]\ntheorem factorial_le {m n} (h : m ≤ n) : m ! ≤ n ! :=\n  le_of_dvd (factorial_pos _) (factorial_dvd_factorial h)\n\n"}
{"name":"Nat.factorial_mul_pow_le_factorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\n⊢ LE.le (HMul.hMul m.factorial (HPow.hPow (HAdd.hAdd m 1) n)) (HAdd.hAdd m n).factorial","decl":"theorem factorial_mul_pow_le_factorial : ∀ {m n : ℕ}, m ! * (m + 1) ^ n ≤ (m + n)!\n  | m, 0 => by simp\n  | m, n + 1 => by\n    rw [← Nat.add_assoc, factorial_succ, Nat.mul_comm (_ + 1), Nat.pow_succ, ← Nat.mul_assoc]\n    exact Nat.mul_le_mul factorial_mul_pow_le_factorial (succ_le_succ (le_add_right _ _))\n\n"}
{"name":"Nat.factorial_lt","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\nhn : LT.lt 0 n\n⊢ Iff (LT.lt n.factorial m.factorial) (LT.lt n m)","decl":"theorem factorial_lt (hn : 0 < n) : n ! < m ! ↔ n < m := by\n  refine ⟨fun h => not_le.mp fun hmn => Nat.not_le_of_lt h (factorial_le hmn), fun h => ?_⟩\n  have : ∀ {n}, 0 < n → n ! < (n + 1)! := by\n    intro k hk\n    rw [factorial_succ, succ_mul, Nat.lt_add_left_iff_pos]\n    exact Nat.mul_pos hk k.factorial_pos\n  induction h generalizing hn with\n  | refl => exact this hn\n  | step hnk ih => exact lt_trans (ih hn) <| this <| lt_trans hn <| lt_of_succ_le hnk\n\n"}
{"name":"Nat.factorial_lt_of_lt","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\nhn : LT.lt 0 n\nh : LT.lt n m\n⊢ LT.lt n.factorial m.factorial","decl":"@[gcongr]\nlemma factorial_lt_of_lt {m n : ℕ} (hn : 0 < n) (h : n < m) : n ! < m ! := (factorial_lt hn).mpr h\n\n"}
{"name":"Nat.one_lt_factorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Iff (LT.lt 1 n.factorial) (LT.lt 1 n)","decl":"@[simp] lemma one_lt_factorial : 1 < n ! ↔ 1 < n := factorial_lt Nat.one_pos\n\n"}
{"name":"Nat.factorial_eq_one","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Iff (Eq n.factorial 1) (LE.le n 1)","decl":"@[simp]\ntheorem factorial_eq_one : n ! = 1 ↔ n ≤ 1 := by\n  constructor\n  · intro h\n    rw [← not_lt, ← one_lt_factorial, h]\n    apply lt_irrefl\n  · rintro (_|_|_) <;> rfl\n\n"}
{"name":"Nat.factorial_inj","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\nhn : LT.lt 1 n\n⊢ Iff (Eq n.factorial m.factorial) (Eq n m)","decl":"theorem factorial_inj (hn : 1 < n) : n ! = m ! ↔ n = m := by\n  refine ⟨fun h => ?_, congr_arg _⟩\n  obtain hnm | rfl | hnm := lt_trichotomy n m\n  · rw [← factorial_lt <| lt_of_succ_lt hn, h] at hnm\n    cases lt_irrefl _ hnm\n  · rfl\n  rw [← one_lt_factorial, h, one_lt_factorial] at hn\n  rw [← factorial_lt <| lt_of_succ_lt hn, h] at hnm\n  cases lt_irrefl _ hnm\n\n"}
{"name":"Nat.factorial_inj'","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"m n : Nat\nh : Or (LT.lt 1 n) (LT.lt 1 m)\n⊢ Iff (Eq n.factorial m.factorial) (Eq n m)","decl":"theorem factorial_inj' (h : 1 < n ∨ 1 < m) : n ! = m ! ↔ n = m := by\n  obtain hn|hm := h\n  · exact factorial_inj hn\n  · rw [eq_comm, factorial_inj hm, eq_comm]\n\n"}
{"name":"Nat.self_le_factorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ LE.le n n.factorial","decl":"theorem self_le_factorial : ∀ n : ℕ, n ≤ n !\n  | 0 => Nat.zero_le _\n  | k + 1 => Nat.le_mul_of_pos_right _ (Nat.one_le_of_lt k.factorial_pos)\n\n"}
{"name":"Nat.lt_factorial_self","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\nhi : LE.le 3 n\n⊢ LT.lt n n.factorial","decl":"theorem lt_factorial_self {n : ℕ} (hi : 3 ≤ n) : n < n ! := by\n  have : 0 < n := by omega\n  have hn : 1 < pred n := le_pred_of_lt (succ_le_iff.mp hi)\n  rw [← succ_pred_eq_of_pos ‹0 < n›, factorial_succ]\n  exact (Nat.lt_mul_iff_one_lt_right (pred n).succ_pos).2\n    ((Nat.lt_of_lt_of_le hn (self_le_factorial _)))\n\n"}
{"name":"Nat.add_factorial_succ_lt_factorial_add_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"i n : Nat\nhi : LE.le 2 i\n⊢ LT.lt (HAdd.hAdd i (HAdd.hAdd n 1).factorial) (HAdd.hAdd (HAdd.hAdd i n) 1).factorial","decl":"theorem add_factorial_succ_lt_factorial_add_succ {i : ℕ} (n : ℕ) (hi : 2 ≤ i) :\n    i + (n + 1)! < (i + n + 1)! := by\n  rw [factorial_succ (i + _), Nat.add_mul, Nat.one_mul]\n  have := (i + n).self_le_factorial\n  refine Nat.add_lt_add_of_lt_of_le (Nat.lt_of_le_of_lt ?_ ((Nat.lt_mul_iff_one_lt_right ?_).2 ?_))\n    (factorial_le ?_) <;> omega\n\n"}
{"name":"Nat.add_factorial_lt_factorial_add","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"i n : Nat\nhi : LE.le 2 i\nhn : LE.le 1 n\n⊢ LT.lt (HAdd.hAdd i n.factorial) (HAdd.hAdd i n).factorial","decl":"theorem add_factorial_lt_factorial_add {i n : ℕ} (hi : 2 ≤ i) (hn : 1 ≤ n) :\n    i + n ! < (i + n)! := by\n  cases hn\n  · rw [factorial_one]\n    exact lt_factorial_self (succ_le_succ hi)\n  exact add_factorial_succ_lt_factorial_add_succ _ hi\n\n"}
{"name":"Nat.add_factorial_succ_le_factorial_add_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"i n : Nat\n⊢ LE.le (HAdd.hAdd i (HAdd.hAdd n 1).factorial) (HAdd.hAdd i (HAdd.hAdd n 1)).factorial","decl":"theorem add_factorial_succ_le_factorial_add_succ (i : ℕ) (n : ℕ) :\n    i + (n + 1)! ≤ (i + (n + 1))! := by\n  cases (le_or_lt (2 : ℕ) i)\n  · rw [← Nat.add_assoc]\n    apply Nat.le_of_lt\n    apply add_factorial_succ_lt_factorial_add_succ\n    assumption\n  · match i with\n    | 0 => simp\n    | 1 =>\n      rw [← Nat.add_assoc, factorial_succ (1 + n), Nat.add_mul, Nat.one_mul, Nat.add_comm 1 n,\n        Nat.add_le_add_iff_right]\n      exact Nat.mul_pos n.succ_pos n.succ.factorial_pos\n    | succ (succ n) => contradiction\n\n"}
{"name":"Nat.add_factorial_le_factorial_add","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"i n : Nat\nn1 : LE.le 1 n\n⊢ LE.le (HAdd.hAdd i n.factorial) (HAdd.hAdd i n).factorial","decl":"theorem add_factorial_le_factorial_add (i : ℕ) {n : ℕ} (n1 : 1 ≤ n) : i + n ! ≤ (i + n)! := by\n  cases' n1 with h\n  · exact self_le_factorial _\n  exact add_factorial_succ_le_factorial_add_succ i h\n\n"}
{"name":"Nat.factorial_mul_pow_sub_le_factorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n m : Nat\nhnm : LE.le n m\n⊢ LE.le (HMul.hMul n.factorial (HPow.hPow n (HSub.hSub m n))) m.factorial","decl":"theorem factorial_mul_pow_sub_le_factorial {n m : ℕ} (hnm : n ≤ m) : n ! * n ^ (m - n) ≤ m ! := by\n  calc\n    _ ≤ n ! * (n + 1) ^ (m - n) := Nat.mul_le_mul_left _ (Nat.pow_le_pow_left n.le_succ _)\n    _ ≤ _ := by simpa [hnm] using @Nat.factorial_mul_pow_le_factorial n (m - n)\n\n"}
{"name":"Nat.factorial_le_pow","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ LE.le n.factorial (HPow.hPow n n)","decl":"lemma factorial_le_pow : ∀ n, n ! ≤ n ^ n\n  | 0 => le_refl _\n  | n + 1 =>\n    calc\n      _ ≤ (n + 1) * n ^ n := Nat.mul_le_mul_left _ n.factorial_le_pow\n      _ ≤ (n + 1) * (n + 1) ^ n := Nat.mul_le_mul_left _ (Nat.pow_le_pow_left n.le_succ _)\n      _ = _ := by rw [pow_succ']\n\n"}
{"name":"Nat.ascFactorial_zero","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Eq (n.ascFactorial 0) 1","decl":"@[simp]\ntheorem ascFactorial_zero (n : ℕ) : n.ascFactorial 0 = 1 :=\n  rfl\n\n"}
{"name":"Nat.ascFactorial_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.ascFactorial k.succ) (HMul.hMul (HAdd.hAdd n k) (n.ascFactorial k))","decl":"theorem ascFactorial_succ {n k : ℕ} : n.ascFactorial k.succ = (n + k) * n.ascFactorial k :=\n  rfl\n\n"}
{"name":"Nat.zero_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.ascFactorial 0 k.succ) 0","decl":"theorem zero_ascFactorial : ∀ (k : ℕ), (0 : ℕ).ascFactorial k.succ = 0\n  | 0 => by\n    rw [ascFactorial_succ, ascFactorial_zero, Nat.zero_add, Nat.zero_mul]\n  | (k+1) => by\n    rw [ascFactorial_succ, zero_ascFactorial k, Nat.mul_zero]\n\n"}
{"name":"Nat.one_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.ascFactorial 1 k) k.factorial","decl":"@[simp]\ntheorem one_ascFactorial : ∀ (k : ℕ), (1 : ℕ).ascFactorial k = k.factorial\n  | 0 => ascFactorial_zero 1\n  | (k+1) => by\n    rw [ascFactorial_succ, one_ascFactorial k, Nat.add_comm, factorial_succ]\n\n"}
{"name":"Nat.succ_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul n (n.succ.ascFactorial k)) (HMul.hMul (HAdd.hAdd n k) (n.ascFactorial k))","decl":"theorem succ_ascFactorial (n : ℕ) :\n    ∀ k, n * n.succ.ascFactorial k = (n + k) * n.ascFactorial k\n  | 0 => by rw [Nat.add_zero, ascFactorial_zero, ascFactorial_zero]\n  | k + 1 => by rw [ascFactorial, Nat.mul_left_comm, succ_ascFactorial n k, ascFactorial, succ_add,\n    ← Nat.add_assoc]\n\n"}
{"name":"Nat.factorial_mul_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul n.factorial ((HAdd.hAdd n 1).ascFactorial k)) (HAdd.hAdd n k).factorial","decl":"/-- `(n + 1).ascFactorial k = (n + k) ! / n !` but without ℕ-division. See\n`Nat.ascFactorial_eq_div` for the version with ℕ-division. -/\ntheorem factorial_mul_ascFactorial (n : ℕ) : ∀ k, n ! * (n + 1).ascFactorial k = (n + k)!\n  | 0 => by rw [ascFactorial_zero, Nat.add_zero, Nat.mul_one]\n  | k + 1 => by\n    rw [ascFactorial_succ, ← Nat.add_assoc, factorial_succ, Nat.mul_comm (n + 1 + k),\n      ← Nat.mul_assoc, factorial_mul_ascFactorial n k, Nat.mul_comm, Nat.add_right_comm]\n\n"}
{"name":"Nat.factorial_mul_ascFactorial'","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\nh : LT.lt 0 n\n⊢ Eq (HMul.hMul (HSub.hSub n 1).factorial (n.ascFactorial k)) (HSub.hSub (HAdd.hAdd n k) 1).factorial","decl":"/-- `n.ascFactorial k = (n + k - 1)! / (n - 1)!` for `n > 0` but without ℕ-division. See\n`Nat.ascFactorial_eq_div` for the version with ℕ-division. Consider using\n`factorial_mul_ascFactorial` to avoid complications of ℕ-subtraction. -/\ntheorem factorial_mul_ascFactorial' (n k : ℕ) (h : 0 < n) :\n    (n - 1) ! * n.ascFactorial k = (n + k - 1)! := by\n  rw [Nat.sub_add_comm h, Nat.sub_one]\n  nth_rw 2 [Nat.eq_add_of_sub_eq h rfl]\n  rw [Nat.sub_one, factorial_mul_ascFactorial]\n\n"}
{"name":"Nat.ascFactorial_eq_div","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n 1).ascFactorial k) (HDiv.hDiv (HAdd.hAdd n k).factorial n.factorial)","decl":"/-- Avoid in favor of `Nat.factorial_mul_ascFactorial` if you can. ℕ-division isn't worth it. -/\ntheorem ascFactorial_eq_div (n k : ℕ) : (n + 1).ascFactorial k = (n + k)! / n ! :=\n  Nat.eq_div_of_mul_eq_right n.factorial_ne_zero (factorial_mul_ascFactorial _ _)\n\n"}
{"name":"Nat.ascFactorial_eq_div'","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\nh : LT.lt 0 n\n⊢ Eq (n.ascFactorial k) (HDiv.hDiv (HSub.hSub (HAdd.hAdd n k) 1).factorial (HSub.hSub n 1).factorial)","decl":"/-- Avoid in favor of `Nat.factorial_mul_ascFactorial'` if you can. ℕ-division isn't worth it. -/\ntheorem ascFactorial_eq_div' (n k : ℕ) (h : 0 < n) :\n    n.ascFactorial k = (n + k - 1)! / (n - 1) ! :=\n  Nat.eq_div_of_mul_eq_right (n - 1).factorial_ne_zero (factorial_mul_ascFactorial' _ _ h)\n\n"}
{"name":"Nat.ascFactorial_of_sub","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul (HSub.hSub n k) ((HAdd.hAdd (HSub.hSub n k) 1).ascFactorial k)) ((HSub.hSub n k).ascFactorial (HAdd.hAdd k 1))","decl":"theorem ascFactorial_of_sub {n k : ℕ} :\n    (n - k) * (n - k + 1).ascFactorial k = (n - k).ascFactorial (k + 1) := by\n  rw [succ_ascFactorial, ascFactorial_succ]\n\n"}
{"name":"Nat.pow_succ_le_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ LE.le (HPow.hPow n k) (n.ascFactorial k)","decl":"theorem pow_succ_le_ascFactorial (n : ℕ) : ∀ k : ℕ, n ^ k ≤ n.ascFactorial k\n  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]\n  | k + 1 => by\n    rw [Nat.pow_succ, Nat.mul_comm, ascFactorial_succ, ← succ_ascFactorial]\n    exact Nat.mul_le_mul (Nat.le_refl n)\n      (Nat.le_trans (Nat.pow_le_pow_left (le_succ n) k) (pow_succ_le_ascFactorial n.succ k))\n\n"}
{"name":"Nat.pow_lt_ascFactorial'","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ LT.lt (HPow.hPow (HAdd.hAdd n 1) (HAdd.hAdd k 2)) ((HAdd.hAdd n 1).ascFactorial (HAdd.hAdd k 2))","decl":"theorem pow_lt_ascFactorial' (n k : ℕ) : (n + 1) ^ (k + 2) < (n + 1).ascFactorial (k + 2) := by\n  rw [Nat.pow_succ, ascFactorial, Nat.mul_comm]\n  exact Nat.mul_lt_mul_of_lt_of_le' (Nat.lt_add_of_pos_right k.succ_pos)\n    (pow_succ_le_ascFactorial n.succ _) (Nat.pow_pos n.succ_pos)\n\n"}
{"name":"Nat.pow_lt_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\na✝ : LE.le 2 k\n⊢ LT.lt (HPow.hPow (HAdd.hAdd n 1) k) ((HAdd.hAdd n 1).ascFactorial k)","decl":"theorem pow_lt_ascFactorial (n : ℕ) : ∀ {k : ℕ}, 2 ≤ k → (n + 1) ^ k < (n + 1).ascFactorial k\n  | 0 => by rintro ⟨⟩\n  | 1 => by intro; contradiction\n  | k + 2 => fun _ => pow_lt_ascFactorial' n k\n\n"}
{"name":"Nat.ascFactorial_le_pow_add","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ LE.le ((HAdd.hAdd n 1).ascFactorial k) (HPow.hPow (HAdd.hAdd n k) k)","decl":"theorem ascFactorial_le_pow_add (n : ℕ) : ∀ k : ℕ, (n+1).ascFactorial k ≤ (n + k) ^ k\n  | 0 => by rw [ascFactorial_zero, Nat.pow_zero]\n  | k + 1 => by\n    rw [ascFactorial_succ, Nat.pow_succ, Nat.mul_comm, ← Nat.add_assoc, Nat.add_right_comm n 1 k]\n    exact Nat.mul_le_mul_right _\n      (Nat.le_trans (ascFactorial_le_pow_add _ k) (Nat.pow_le_pow_left (le_succ _) _))\n\n"}
{"name":"Nat.ascFactorial_lt_pow_add","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\na✝ : LE.le 2 k\n⊢ LT.lt ((HAdd.hAdd n 1).ascFactorial k) (HPow.hPow (HAdd.hAdd n k) k)","decl":"theorem ascFactorial_lt_pow_add (n : ℕ) : ∀ {k : ℕ}, 2 ≤ k → (n + 1).ascFactorial k < (n + k) ^ k\n  | 0 => by rintro ⟨⟩\n  | 1 => by intro; contradiction\n  | k + 2 => fun _ => by\n    rw [Nat.pow_succ, Nat.mul_comm, ascFactorial_succ, succ_add_eq_add_succ n (k + 1)]\n    exact Nat.mul_lt_mul_of_le_of_lt (le_refl _) (Nat.lt_of_le_of_lt (ascFactorial_le_pow_add n _)\n      (Nat.pow_lt_pow_left (Nat.lt_succ_self _) k.succ_ne_zero)) (succ_pos _)\n\n"}
{"name":"Nat.ascFactorial_pos","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ LT.lt 0 ((HAdd.hAdd n 1).ascFactorial k)","decl":"theorem ascFactorial_pos (n k : ℕ) : 0 < (n + 1).ascFactorial k :=\n  Nat.lt_of_lt_of_le (Nat.pow_pos n.succ_pos) (pow_succ_le_ascFactorial (n + 1) k)\n\n"}
{"name":"Nat.descFactorial_zero","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Eq (n.descFactorial 0) 1","decl":"@[simp]\ntheorem descFactorial_zero (n : ℕ) : n.descFactorial 0 = 1 :=\n  rfl\n\n"}
{"name":"Nat.descFactorial_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq (n.descFactorial (HAdd.hAdd k 1)) (HMul.hMul (HSub.hSub n k) (n.descFactorial k))","decl":"@[simp]\ntheorem descFactorial_succ (n k : ℕ) : n.descFactorial (k + 1) = (n - k) * n.descFactorial k :=\n  rfl\n\n"}
{"name":"Nat.zero_descFactorial_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"k : Nat\n⊢ Eq (Nat.descFactorial 0 (HAdd.hAdd k 1)) 0","decl":"theorem zero_descFactorial_succ (k : ℕ) : (0 : ℕ).descFactorial (k + 1) = 0 := by\n  rw [descFactorial_succ, Nat.zero_sub, Nat.zero_mul]\n\n"}
{"name":"Nat.descFactorial_one","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Eq (n.descFactorial 1) n","decl":"theorem descFactorial_one (n : ℕ) : n.descFactorial 1 = n := by simp\n\n"}
{"name":"Nat.succ_descFactorial_succ","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n 1).descFactorial (HAdd.hAdd k 1)) (HMul.hMul (HAdd.hAdd n 1) (n.descFactorial k))","decl":"theorem succ_descFactorial_succ (n : ℕ) :\n    ∀ k : ℕ, (n + 1).descFactorial (k + 1) = (n + 1) * n.descFactorial k\n  | 0 => by rw [descFactorial_zero, descFactorial_one, Nat.mul_one]\n  | succ k => by\n    rw [descFactorial_succ, succ_descFactorial_succ _ k, descFactorial_succ, succ_sub_succ,\n      Nat.mul_left_comm]\n\n"}
{"name":"Nat.succ_descFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq (HMul.hMul (HSub.hSub (HAdd.hAdd n 1) k) ((HAdd.hAdd n 1).descFactorial k)) (HMul.hMul (HAdd.hAdd n 1) (n.descFactorial k))","decl":"theorem succ_descFactorial (n : ℕ) :\n    ∀ k, (n + 1 - k) * (n + 1).descFactorial k = (n + 1) * n.descFactorial k\n  | 0 => by rw [Nat.sub_zero, descFactorial_zero, descFactorial_zero]\n  | k + 1 => by\n    rw [descFactorial, succ_descFactorial _ k, descFactorial_succ, succ_sub_succ, Nat.mul_left_comm]\n\n"}
{"name":"Nat.descFactorial_self","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ Eq (n.descFactorial n) n.factorial","decl":"theorem descFactorial_self : ∀ n : ℕ, n.descFactorial n = n !\n  | 0 => by rw [descFactorial_zero, factorial_zero]\n  | succ n => by rw [succ_descFactorial_succ, descFactorial_self n, factorial_succ]\n\n"}
{"name":"Nat.descFactorial_eq_zero_iff_lt","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Iff (Eq (n.descFactorial k) 0) (LT.lt n k)","decl":"@[simp]\ntheorem descFactorial_eq_zero_iff_lt {n : ℕ} : ∀ {k : ℕ}, n.descFactorial k = 0 ↔ n < k\n  | 0 => by simp only [descFactorial_zero, Nat.one_ne_zero, Nat.not_lt_zero]\n  | succ k => by\n    rw [descFactorial_succ, mul_eq_zero, descFactorial_eq_zero_iff_lt, Nat.lt_succ_iff,\n      Nat.sub_eq_zero_iff_le, Nat.lt_iff_le_and_ne, or_iff_left_iff_imp, and_imp]\n    exact fun h _ => h\n\n"}
{"name":"Nat.descFactorial_of_lt","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\na✝ : LT.lt n k\n⊢ Eq (n.descFactorial k) 0","decl":"alias ⟨_, descFactorial_of_lt⟩ := descFactorial_eq_zero_iff_lt\n\n"}
{"name":"Nat.add_descFactorial_eq_ascFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HAdd.hAdd n k).descFactorial k) ((HAdd.hAdd n 1).ascFactorial k)","decl":"theorem add_descFactorial_eq_ascFactorial (n : ℕ) : ∀ k : ℕ,\n    (n + k).descFactorial k = (n + 1).ascFactorial k\n  | 0 => by rw [ascFactorial_zero, descFactorial_zero]\n  | succ k => by\n    rw [Nat.add_succ, succ_descFactorial_succ, ascFactorial_succ,\n      add_descFactorial_eq_ascFactorial _ k, Nat.add_right_comm]\n\n"}
{"name":"Nat.add_descFactorial_eq_ascFactorial'","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ Eq ((HSub.hSub (HAdd.hAdd n k) 1).descFactorial k) (n.ascFactorial k)","decl":"theorem add_descFactorial_eq_ascFactorial' (n : ℕ) :\n    ∀ k : ℕ, (n + k - 1).descFactorial k = n.ascFactorial k\n  | 0 => by rw [ascFactorial_zero, descFactorial_zero]\n  | succ k => by\n    rw [descFactorial_succ, ascFactorial_succ, ← succ_add_eq_add_succ,\n      add_descFactorial_eq_ascFactorial' _ k, ← succ_ascFactorial, succ_add_sub_one,\n      Nat.add_sub_cancel]\n\n"}
{"name":"Nat.factorial_mul_descFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\na✝ : LE.le k n\n⊢ Eq (HMul.hMul (HSub.hSub n k).factorial (n.descFactorial k)) n.factorial","decl":"/-- `n.descFactorial k = n! / (n - k)!` but without ℕ-division. See `Nat.descFactorial_eq_div`\nfor the version using ℕ-division. -/\ntheorem factorial_mul_descFactorial : ∀ {n k : ℕ}, k ≤ n → (n - k)! * n.descFactorial k = n !\n  | n, 0 => fun _ => by rw [descFactorial_zero, Nat.mul_one, Nat.sub_zero]\n  | 0, succ k => fun h => by\n    exfalso\n    exact not_succ_le_zero k h\n  | succ n, succ k => fun h => by\n    rw [succ_descFactorial_succ, succ_sub_succ, ← Nat.mul_assoc, Nat.mul_comm (n - k)!,\n      Nat.mul_assoc, factorial_mul_descFactorial (Nat.succ_le_succ_iff.1 h), factorial_succ]\n\n"}
{"name":"Nat.descFactorial_mul_descFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"k m n : Nat\nhkm : LE.le k m\n⊢ Eq (HMul.hMul ((HSub.hSub n k).descFactorial (HSub.hSub m k)) (n.descFactorial k)) (n.descFactorial m)","decl":"theorem descFactorial_mul_descFactorial {k m n : ℕ} (hkm : k ≤ m) :\n    (n - k).descFactorial (m - k) * n.descFactorial k = n.descFactorial m := by\n  by_cases hmn : m ≤ n\n  · apply Nat.mul_left_cancel (n - m).factorial_pos\n    rw [factorial_mul_descFactorial hmn, show n - m = (n - k) - (m - k) by omega, ← Nat.mul_assoc,\n      factorial_mul_descFactorial (show m - k ≤ n - k by omega),\n      factorial_mul_descFactorial (le_trans hkm hmn)]\n  · rw [descFactorial_eq_zero_iff_lt.mpr (show n < m by omega)]\n    by_cases hkn : k ≤ n\n    · rw [descFactorial_eq_zero_iff_lt.mpr (show n - k < m - k by omega), Nat.zero_mul]\n    · rw [descFactorial_eq_zero_iff_lt.mpr (show n < k by omega), Nat.mul_zero]\n\n"}
{"name":"Nat.descFactorial_eq_div","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\nh : LE.le k n\n⊢ Eq (n.descFactorial k) (HDiv.hDiv n.factorial (HSub.hSub n k).factorial)","decl":"/-- Avoid in favor of `Nat.factorial_mul_descFactorial` if you can. ℕ-division isn't worth it. -/\ntheorem descFactorial_eq_div {n k : ℕ} (h : k ≤ n) : n.descFactorial k = n ! / (n - k)! := by\n  apply Nat.mul_left_cancel (n - k).factorial_pos\n  rw [factorial_mul_descFactorial h]\n  exact (Nat.mul_div_cancel' <| factorial_dvd_factorial <| Nat.sub_le n k).symm\n\n"}
{"name":"Nat.descFactorial_le","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k m : Nat\nh : LE.le k m\n⊢ LE.le (k.descFactorial n) (m.descFactorial n)","decl":"theorem descFactorial_le (n : ℕ) {k m : ℕ} (h : k ≤ m) :\n    k.descFactorial n ≤ m.descFactorial n := by\n  induction n with\n  | zero => rfl\n  | succ n ih =>\n    rw [descFactorial_succ, descFactorial_succ]\n    exact Nat.mul_le_mul (Nat.sub_le_sub_right h n) ih\n\n"}
{"name":"Nat.pow_sub_le_descFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ LE.le (HPow.hPow (HSub.hSub (HAdd.hAdd n 1) k) k) (n.descFactorial k)","decl":"theorem pow_sub_le_descFactorial (n : ℕ) : ∀ k : ℕ, (n + 1 - k) ^ k ≤ n.descFactorial k\n  | 0 => by rw [descFactorial_zero, Nat.pow_zero]\n  | k + 1 => by\n    rw [descFactorial_succ, Nat.pow_succ, succ_sub_succ, Nat.mul_comm]\n    apply Nat.mul_le_mul_left\n    exact (le_trans (Nat.pow_le_pow_left (Nat.sub_le_sub_right n.le_succ _) k)\n      (pow_sub_le_descFactorial n k))\n\n"}
{"name":"Nat.pow_sub_lt_descFactorial'","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\na✝ : LE.le (HAdd.hAdd k 2) n\n⊢ LT.lt (HPow.hPow (HSub.hSub n (HAdd.hAdd k 1)) (HAdd.hAdd k 2)) (n.descFactorial (HAdd.hAdd k 2))","decl":"theorem pow_sub_lt_descFactorial' {n : ℕ} :\n    ∀ {k : ℕ}, k + 2 ≤ n → (n - (k + 1)) ^ (k + 2) < n.descFactorial (k + 2)\n  | 0, h => by\n    rw [descFactorial_succ, Nat.pow_succ, Nat.pow_one, descFactorial_one]\n    exact Nat.mul_lt_mul_of_pos_left (by omega) (Nat.sub_pos_of_lt h)\n  | k + 1, h => by\n    rw [descFactorial_succ, Nat.pow_succ, Nat.mul_comm]\n    refine Nat.mul_lt_mul_of_pos_left ?_ (Nat.sub_pos_of_lt h)\n    refine Nat.lt_of_le_of_lt (Nat.pow_le_pow_left (Nat.sub_le_sub_right n.le_succ _) _) ?_\n    rw [succ_sub_succ]\n    exact pow_sub_lt_descFactorial' (Nat.le_trans (le_succ _) h)\n\n"}
{"name":"Nat.pow_sub_lt_descFactorial","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\na✝¹ : LE.le 2 k\na✝ : LE.le k n\n⊢ LT.lt (HPow.hPow (HSub.hSub (HAdd.hAdd n 1) k) k) (n.descFactorial k)","decl":"theorem pow_sub_lt_descFactorial {n : ℕ} :\n    ∀ {k : ℕ}, 2 ≤ k → k ≤ n → (n + 1 - k) ^ k < n.descFactorial k\n  | 0 => by rintro ⟨⟩\n  | 1 => by intro; contradiction\n  | k + 2 => fun _ h => by\n    rw [succ_sub_succ]\n    exact pow_sub_lt_descFactorial' h\n\n"}
{"name":"Nat.descFactorial_le_pow","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n k : Nat\n⊢ LE.le (n.descFactorial k) (HPow.hPow n k)","decl":"theorem descFactorial_le_pow (n : ℕ) : ∀ k : ℕ, n.descFactorial k ≤ n ^ k\n  | 0 => by rw [descFactorial_zero, Nat.pow_zero]\n  | k + 1 => by\n    rw [descFactorial_succ, Nat.pow_succ, Nat.mul_comm _ n]\n    exact Nat.mul_le_mul (Nat.sub_le _ _) (descFactorial_le_pow _ k)\n\n"}
{"name":"Nat.descFactorial_lt_pow","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\nhn : LE.le 1 n\nk : Nat\na✝ : LE.le 2 k\n⊢ LT.lt (n.descFactorial k) (HPow.hPow n k)","decl":"theorem descFactorial_lt_pow {n : ℕ} (hn : 1 ≤ n) : ∀ {k : ℕ}, 2 ≤ k → n.descFactorial k < n ^ k\n  | 0 => by rintro ⟨⟩\n  | 1 => by intro; contradiction\n  | k + 2 => fun _ => by\n    rw [descFactorial_succ, pow_succ', Nat.mul_comm, Nat.mul_comm n]\n    exact Nat.mul_lt_mul_of_le_of_lt (descFactorial_le_pow _ _) (Nat.sub_lt hn k.zero_lt_succ)\n      (Nat.pow_pos (Nat.lt_of_succ_le hn))\n\n"}
{"name":"Nat.factorial_two_mul_le","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ LE.le (HMul.hMul 2 n).factorial (HMul.hMul (HPow.hPow (HMul.hMul 2 n) n) n.factorial)","decl":"lemma factorial_two_mul_le (n : ℕ) : (2 * n)! ≤ (2 * n) ^ n * n ! := by\n  rw [Nat.two_mul, ← factorial_mul_ascFactorial, Nat.mul_comm]\n  exact Nat.mul_le_mul_right _ (ascFactorial_le_pow_add _ _)\n\n"}
{"name":"Nat.two_pow_mul_factorial_le_factorial_two_mul","module":"Mathlib.Data.Nat.Factorial.Basic","initialProofState":"n : Nat\n⊢ LE.le (HMul.hMul (HPow.hPow 2 n) n.factorial) (HMul.hMul 2 n).factorial","decl":"lemma two_pow_mul_factorial_le_factorial_two_mul (n : ℕ) : 2 ^ n * n ! ≤ (2 * n) ! := by\n  obtain _ | n := n\n  · simp\n  rw [Nat.mul_comm, Nat.two_mul]\n  calc\n    _ ≤ (n + 1)! * (n + 2) ^ (n + 1) :=\n      Nat.mul_le_mul_left _ (pow_le_pow_of_le_left (le_add_left _ _) _)\n    _ ≤ _ := Nat.factorial_mul_pow_le_factorial\n\n"}
