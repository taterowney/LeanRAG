{"name":"CategoryTheory.linearYoneda_map_app","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nX₁ X₂ : C\nf : Quiver.Hom X₁ X₂\nY : Opposite C\n⊢ Eq (((CategoryTheory.linearYoneda R C).map f).app Y) (ModuleCat.ofHom (CategoryTheory.Linear.rightComp R (Opposite.unop Y) f))","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `X : C` to the `ModuleCat R`-valued presheaf on `C`,\nwith value on `Y : Cᵒᵖ` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearYoneda : C ⥤ Cᵒᵖ ⥤ ModuleCat R where\n  obj X :=\n    { obj := fun Y => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.leftComp R _ f.unop) }\n  map {X₁ X₂} f :=\n    { app := fun Y => @ModuleCat.ofHom R _ (Y.unop ⟶ X₁) (Y.unop ⟶ X₂) _ _ _ _\n        (Linear.rightComp R _ f) }\n\n"}
{"name":"CategoryTheory.linearYoneda_obj_obj_carrier","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nX : C\nY : Opposite C\n⊢ Eq (↑(((CategoryTheory.linearYoneda R C).obj X).obj Y)) (Quiver.Hom (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `X : C` to the `ModuleCat R`-valued presheaf on `C`,\nwith value on `Y : Cᵒᵖ` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearYoneda : C ⥤ Cᵒᵖ ⥤ ModuleCat R where\n  obj X :=\n    { obj := fun Y => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.leftComp R _ f.unop) }\n  map {X₁ X₂} f :=\n    { app := fun Y => @ModuleCat.ofHom R _ (Y.unop ⟶ X₁) (Y.unop ⟶ X₂) _ _ _ _\n        (Linear.rightComp R _ f) }\n\n"}
{"name":"CategoryTheory.linearYoneda_obj_obj_isModule","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nX : C\nY : Opposite C\n⊢ Eq (((CategoryTheory.linearYoneda R C).obj X).obj Y).isModule (CategoryTheory.Linear.homModule (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `X : C` to the `ModuleCat R`-valued presheaf on `C`,\nwith value on `Y : Cᵒᵖ` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearYoneda : C ⥤ Cᵒᵖ ⥤ ModuleCat R where\n  obj X :=\n    { obj := fun Y => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.leftComp R _ f.unop) }\n  map {X₁ X₂} f :=\n    { app := fun Y => @ModuleCat.ofHom R _ (Y.unop ⟶ X₁) (Y.unop ⟶ X₂) _ _ _ _\n        (Linear.rightComp R _ f) }\n\n"}
{"name":"CategoryTheory.linearYoneda_obj_map","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nX : C\nX✝ Y✝ : Opposite C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.linearYoneda R C).obj X).map f) (ModuleCat.ofHom (CategoryTheory.Linear.leftComp R X f.unop))","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `X : C` to the `ModuleCat R`-valued presheaf on `C`,\nwith value on `Y : Cᵒᵖ` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearYoneda : C ⥤ Cᵒᵖ ⥤ ModuleCat R where\n  obj X :=\n    { obj := fun Y => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.leftComp R _ f.unop) }\n  map {X₁ X₂} f :=\n    { app := fun Y => @ModuleCat.ofHom R _ (Y.unop ⟶ X₁) (Y.unop ⟶ X₂) _ _ _ _\n        (Linear.rightComp R _ f) }\n\n"}
{"name":"CategoryTheory.linearYoneda_obj_obj_isAddCommGroup","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nX : C\nY : Opposite C\n⊢ Eq (((CategoryTheory.linearYoneda R C).obj X).obj Y).isAddCommGroup (CategoryTheory.Preadditive.homGroup (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `X : C` to the `ModuleCat R`-valued presheaf on `C`,\nwith value on `Y : Cᵒᵖ` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearYoneda : C ⥤ Cᵒᵖ ⥤ ModuleCat R where\n  obj X :=\n    { obj := fun Y => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.leftComp R _ f.unop) }\n  map {X₁ X₂} f :=\n    { app := fun Y => @ModuleCat.ofHom R _ (Y.unop ⟶ X₁) (Y.unop ⟶ X₂) _ _ _ _\n        (Linear.rightComp R _ f) }\n\n"}
{"name":"CategoryTheory.linearCoyoneda_obj_map","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nY : Opposite C\nX✝ Y✝ : C\nf : Quiver.Hom X✝ Y✝\n⊢ Eq (((CategoryTheory.linearCoyoneda R C).obj Y).map f) (ModuleCat.ofHom (CategoryTheory.Linear.rightComp R (Opposite.unop Y) f))","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `Y : Cᵒᵖ` to the `ModuleCat R`-valued copresheaf on `C`,\nwith value on `X : C` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearCoyoneda : Cᵒᵖ ⥤ C ⥤ ModuleCat R where\n  obj Y :=\n    { obj := fun X => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.rightComp R _ f) }\n  map {Y₁ Y₂} f :=\n    { app := fun X => @ModuleCat.ofHom R _ (unop Y₁ ⟶ X) (unop Y₂ ⟶ X) _ _ _ _\n        (Linear.leftComp _ _ f.unop) }\n\n"}
{"name":"CategoryTheory.linearCoyoneda_obj_obj_isModule","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nY : Opposite C\nX : C\n⊢ Eq (((CategoryTheory.linearCoyoneda R C).obj Y).obj X).isModule (CategoryTheory.Linear.homModule (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `Y : Cᵒᵖ` to the `ModuleCat R`-valued copresheaf on `C`,\nwith value on `X : C` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearCoyoneda : Cᵒᵖ ⥤ C ⥤ ModuleCat R where\n  obj Y :=\n    { obj := fun X => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.rightComp R _ f) }\n  map {Y₁ Y₂} f :=\n    { app := fun X => @ModuleCat.ofHom R _ (unop Y₁ ⟶ X) (unop Y₂ ⟶ X) _ _ _ _\n        (Linear.leftComp _ _ f.unop) }\n\n"}
{"name":"CategoryTheory.linearCoyoneda_obj_obj_carrier","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nY : Opposite C\nX : C\n⊢ Eq (↑(((CategoryTheory.linearCoyoneda R C).obj Y).obj X)) (Quiver.Hom (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `Y : Cᵒᵖ` to the `ModuleCat R`-valued copresheaf on `C`,\nwith value on `X : C` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearCoyoneda : Cᵒᵖ ⥤ C ⥤ ModuleCat R where\n  obj Y :=\n    { obj := fun X => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.rightComp R _ f) }\n  map {Y₁ Y₂} f :=\n    { app := fun X => @ModuleCat.ofHom R _ (unop Y₁ ⟶ X) (unop Y₂ ⟶ X) _ _ _ _\n        (Linear.leftComp _ _ f.unop) }\n\n"}
{"name":"CategoryTheory.linearCoyoneda_map_app","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nY₁ Y₂ : Opposite C\nf : Quiver.Hom Y₁ Y₂\nX : C\n⊢ Eq (((CategoryTheory.linearCoyoneda R C).map f).app X) (ModuleCat.ofHom (CategoryTheory.Linear.leftComp R X f.unop))","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `Y : Cᵒᵖ` to the `ModuleCat R`-valued copresheaf on `C`,\nwith value on `X : C` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearCoyoneda : Cᵒᵖ ⥤ C ⥤ ModuleCat R where\n  obj Y :=\n    { obj := fun X => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.rightComp R _ f) }\n  map {Y₁ Y₂} f :=\n    { app := fun X => @ModuleCat.ofHom R _ (unop Y₁ ⟶ X) (unop Y₂ ⟶ X) _ _ _ _\n        (Linear.leftComp _ _ f.unop) }\n\n"}
{"name":"CategoryTheory.linearCoyoneda_obj_obj_isAddCommGroup","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nY : Opposite C\nX : C\n⊢ Eq (((CategoryTheory.linearCoyoneda R C).obj Y).obj X).isAddCommGroup (CategoryTheory.Preadditive.homGroup (Opposite.unop Y) X)","decl":"/-- The Yoneda embedding for `R`-linear categories `C`,\nsending an object `Y : Cᵒᵖ` to the `ModuleCat R`-valued copresheaf on `C`,\nwith value on `X : C` given by `ModuleCat.of R (unop Y ⟶ X)`. -/\n@[simps]\ndef linearCoyoneda : Cᵒᵖ ⥤ C ⥤ ModuleCat R where\n  obj Y :=\n    { obj := fun X => ModuleCat.of R (unop Y ⟶ X)\n      map := fun f => ModuleCat.ofHom (Linear.rightComp R _ f) }\n  map {Y₁ Y₂} f :=\n    { app := fun X => @ModuleCat.ofHom R _ (unop Y₁ ⟶ X) (unop Y₂ ⟶ X) _ _ _ _\n        (Linear.leftComp _ _ f.unop) }\n\n"}
{"name":"CategoryTheory.linearYoneda_obj_additive","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nX : C\n⊢ ((CategoryTheory.linearYoneda R C).obj X).Additive","decl":"instance linearYoneda_obj_additive (X : C) : ((linearYoneda R C).obj X).Additive where\n\n"}
{"name":"CategoryTheory.linearCoyoneda_obj_additive","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\nY : Opposite C\n⊢ ((CategoryTheory.linearCoyoneda R C).obj Y).Additive","decl":"instance linearCoyoneda_obj_additive (Y : Cᵒᵖ) : ((linearCoyoneda R C).obj Y).Additive where\n\n"}
{"name":"CategoryTheory.whiskering_linearYoneda","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ Eq ((CategoryTheory.linearYoneda R C).comp ((CategoryTheory.whiskeringRight (Opposite C) (ModuleCat R) (Type v)).obj (CategoryTheory.forget (ModuleCat R)))) CategoryTheory.yoneda","decl":"@[simp]\ntheorem whiskering_linearYoneda :\n    linearYoneda R C ⋙ (whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R)) = yoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskering_linearYoneda₂","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ Eq ((CategoryTheory.linearYoneda R C).comp ((CategoryTheory.whiskeringRight (Opposite C) (ModuleCat R) AddCommGrp).obj (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))) CategoryTheory.preadditiveYoneda","decl":"@[simp]\ntheorem whiskering_linearYoneda₂ :\n    linearYoneda R C ⋙ (whiskeringRight _ _ _).obj (forget₂ (ModuleCat.{v} R) AddCommGrp.{v}) =\n      preadditiveYoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskering_linearCoyoneda","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ Eq ((CategoryTheory.linearCoyoneda R C).comp ((CategoryTheory.whiskeringRight C (ModuleCat R) (Type v)).obj (CategoryTheory.forget (ModuleCat R)))) CategoryTheory.coyoneda","decl":"@[simp]\ntheorem whiskering_linearCoyoneda :\n    linearCoyoneda R C ⋙ (whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R)) = coyoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.whiskering_linearCoyoneda₂","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ Eq ((CategoryTheory.linearCoyoneda R C).comp ((CategoryTheory.whiskeringRight C (ModuleCat R) AddCommGrp).obj (CategoryTheory.forget₂ (ModuleCat R) AddCommGrp))) CategoryTheory.preadditiveCoyoneda","decl":"@[simp]\ntheorem whiskering_linearCoyoneda₂ :\n    linearCoyoneda R C ⋙\n        (whiskeringRight _ _ _).obj (forget₂ (ModuleCat.{v} R) AddCommGrp.{v}) =\n      preadditiveCoyoneda :=\n  rfl\n\n"}
{"name":"CategoryTheory.full_linearYoneda","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ (CategoryTheory.linearYoneda R C).Full","decl":"instance full_linearYoneda : (linearYoneda R C).Full :=\n  let _ :  Functor.Full (linearYoneda R C ⋙ (whiskeringRight _ _ _).obj\n    (forget (ModuleCat.{v} R))) := Yoneda.yoneda_full\n  Functor.Full.of_comp_faithful (linearYoneda R C)\n    ((whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R)))\n\n"}
{"name":"CategoryTheory.full_linearCoyoneda","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ (CategoryTheory.linearCoyoneda R C).Full","decl":"instance full_linearCoyoneda : (linearCoyoneda R C).Full :=\n  let _ : Functor.Full (linearCoyoneda R C ⋙ (whiskeringRight _ _ _).obj\n    (forget (ModuleCat.{v} R))) := Coyoneda.coyoneda_full\n  Functor.Full.of_comp_faithful (linearCoyoneda R C)\n    ((whiskeringRight _ _ _).obj (forget (ModuleCat.{v} R)))\n\n"}
{"name":"CategoryTheory.faithful_linearYoneda","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ (CategoryTheory.linearYoneda R C).Faithful","decl":"instance faithful_linearYoneda : (linearYoneda R C).Faithful :=\n  Functor.Faithful.of_comp_eq (whiskering_linearYoneda R C)\n\n"}
{"name":"CategoryTheory.faithful_linearCoyoneda","module":"Mathlib.CategoryTheory.Linear.Yoneda","initialProofState":"R : Type w\ninst✝³ : Ring R\nC : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Preadditive C\ninst✝ : CategoryTheory.Linear R C\n⊢ (CategoryTheory.linearCoyoneda R C).Faithful","decl":"instance faithful_linearCoyoneda : (linearCoyoneda R C).Faithful :=\n  Functor.Faithful.of_comp_eq (whiskering_linearCoyoneda R C)\n\n"}
