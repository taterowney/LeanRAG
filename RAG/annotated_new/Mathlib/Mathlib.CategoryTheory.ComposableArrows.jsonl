{"name":"CategoryTheory.ComposableArrows.map'_self","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\ni : Nat\nhi : autoParam (LE.le i n) _auto‚úù\n‚ä¢ Eq (F.map' i i ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.id (F.obj ‚ü®i, ‚ãØ‚ü©))","decl":"lemma map'_self (i : ‚Ñï) (hi : i ‚â§ n := by valid) :\n    F.map' i i = ùüô _ := F.map_id _\n\n"}
{"name":"CategoryTheory.ComposableArrows.map'_comp","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\ni j k : Nat\nhij : autoParam (LE.le i j) _auto‚úù\nhjk : autoParam (LE.le j k) _auto‚úù\nhk : autoParam (LE.le k n) _auto‚úù\n‚ä¢ Eq (F.map' i k ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (F.map' i j ‚ãØ ‚ãØ) (F.map' j k ‚ãØ ‚ãØ))","decl":"lemma map'_comp (i j k : ‚Ñï) (hij : i ‚â§ j := by valid)\n    (hjk : j ‚â§ k := by valid) (hk : k ‚â§ n := by valid) :\n    F.map' i k = F.map' i j ‚â´ F.map' j k :=\n  F.map_comp _ _\n\n"}
{"name":"CategoryTheory.ComposableArrows.naturality'_assoc","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C n\nœÜ : Quiver.Hom F G\ni j : Nat\nhij : autoParam (LE.le i j) _auto‚úù\nhj : autoParam (LE.le j n) _auto‚úù\nZ : C\nh : Quiver.Hom (G.obj' j ‚ãØ) Z\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map' i j ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.app' œÜ j ‚ãØ) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.app' œÜ i ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map' i j ‚ãØ ‚ãØ) h))","decl":"@[reassoc]\nlemma naturality' (œÜ : F ‚ü∂ G) (i j : ‚Ñï) (hij : i ‚â§ j := by valid)\n    (hj : j ‚â§ n := by valid) :\n    F.map' i j ‚â´ app' œÜ j = app' œÜ i ‚â´ G.map' i j :=\n  œÜ.naturality _\n\n"}
{"name":"CategoryTheory.ComposableArrows.naturality'","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C n\nœÜ : Quiver.Hom F G\ni j : Nat\nhij : autoParam (LE.le i j) _auto‚úù\nhj : autoParam (LE.le j n) _auto‚úù\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (F.map' i j ‚ãØ ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ j ‚ãØ)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.app' œÜ i ‚ãØ) (G.map' i j ‚ãØ ‚ãØ))","decl":"@[reassoc]\nlemma naturality' (œÜ : F ‚ü∂ G) (i j : ‚Ñï) (hij : i ‚â§ j := by valid)\n    (hj : j ‚â§ n := by valid) :\n    F.map' i j ‚â´ app' œÜ j = app' œÜ i ‚â´ G.map' i j :=\n  œÜ.naturality _\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÄ_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : C\nx‚úù : Fin 1\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mk‚ÇÄ X).obj x‚úù) X","decl":"/-- Constructor for `ComposableArrows C 0`. -/\n@[simps!]\ndef mk‚ÇÄ (X : C) : ComposableArrows C 0 := (Functor.const (Fin 1)).obj X\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÄ_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : C\nX‚úù Y‚úù : Fin 1\nx‚úù : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mk‚ÇÄ X).map x‚úù) (CategoryTheory.CategoryStruct.id X)","decl":"/-- Constructor for `ComposableArrows C 0`. -/\n@[simps!]\ndef mk‚ÇÄ (X : C) : ComposableArrows C 0 := (Functor.const (Fin 1)).obj X\n\n"}
{"name":"CategoryTheory.ComposableArrows.Mk‚ÇÅ.map_id","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚ÇÄ X‚ÇÅ : C\nf : Quiver.Hom X‚ÇÄ X‚ÇÅ\ni : Fin 2\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Mk‚ÇÅ.map f i i ‚ãØ) (CategoryTheory.CategoryStruct.id (CategoryTheory.ComposableArrows.Mk‚ÇÅ.obj X‚ÇÄ X‚ÇÅ i))","decl":"lemma map_id (i : Fin 2) : map f i i (by simp) = ùüô _ :=\n  match i with\n    | 0 => rfl\n    | 1 => rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Mk‚ÇÅ.map_comp","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚ÇÄ X‚ÇÅ : C\nf : Quiver.Hom X‚ÇÄ X‚ÇÅ\ni j k : Fin 2\nhij : LE.le i j\nhjk : LE.le j k\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Mk‚ÇÅ.map f i k ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.Mk‚ÇÅ.map f i j hij) (CategoryTheory.ComposableArrows.Mk‚ÇÅ.map f j k hjk))","decl":"lemma map_comp {i j k : Fin 2} (hij : i ‚â§ j) (hjk : j ‚â§ k) :\n    map f i k (hij.trans hjk) = map f i j hij ‚â´ map f j k hjk := by\n  obtain rfl | rfl : i = j ‚à® j = k := by omega\n  ¬∑ rw [map_id, id_comp]\n  ¬∑ rw [map_id, comp_id]\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÅ_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚ÇÄ X‚ÇÅ : C\nf : Quiver.Hom X‚ÇÄ X‚ÇÅ\nX‚úù Y‚úù : Fin (HAdd.hAdd 1 1)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mk‚ÇÅ f).map g) (CategoryTheory.ComposableArrows.Mk‚ÇÅ.map f X‚úù Y‚úù ‚ãØ)","decl":"/-- Constructor for `ComposableArrows C 1`. -/\n@[simps]\ndef mk‚ÇÅ {X‚ÇÄ X‚ÇÅ : C} (f : X‚ÇÄ ‚ü∂ X‚ÇÅ) : ComposableArrows C 1 where\n  obj := Mk‚ÇÅ.obj X‚ÇÄ X‚ÇÅ\n  map g := Mk‚ÇÅ.map f _ _ (leOfHom g)\n  map_id := Mk‚ÇÅ.map_id f\n  map_comp g g' := Mk‚ÇÅ.map_comp f (leOfHom g) (leOfHom g')\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÅ_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX‚ÇÄ X‚ÇÅ : C\nf : Quiver.Hom X‚ÇÄ X‚ÇÅ\na‚úù : Fin 2\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mk‚ÇÅ f).obj a‚úù) (CategoryTheory.ComposableArrows.Mk‚ÇÅ.obj X‚ÇÄ X‚ÇÅ a‚úù)","decl":"/-- Constructor for `ComposableArrows C 1`. -/\n@[simps]\ndef mk‚ÇÅ {X‚ÇÄ X‚ÇÅ : C} (f : X‚ÇÄ ‚ü∂ X‚ÇÅ) : ComposableArrows C 1 where\n  obj := Mk‚ÇÅ.obj X‚ÇÄ X‚ÇÅ\n  map g := Mk‚ÇÅ.map f _ _ (leOfHom g)\n  map_id := Mk‚ÇÅ.map_id f\n  map_comp g g' := Mk‚ÇÅ.map_comp f (leOfHom g) (leOfHom g')\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C n\napp : (i : Fin (HAdd.hAdd n 1)) ‚Üí Quiver.Hom (F.obj i) (G.obj i)\nw : ‚àÄ (i : Nat), LT.lt i n ‚Üí Eq (CategoryTheory.CategoryStruct.comp (F.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (app ‚ü®HAdd.hAdd i 1, ‚ãØ‚ü©)) (CategoryTheory.CategoryStruct.comp (app ‚ü®i, ‚ãØ‚ü©) (G.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ))\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk app w).app i) (app i)","decl":"/-- Constructor for morphisms `F ‚ü∂ G` in `ComposableArrows C n` which takes as inputs\na family of morphisms `F.obj i ‚ü∂ G.obj i` and the naturality condition only for the\nmaps in `Fin (n + 1)` given by inequalities of the form `i ‚â§ i + 1`. -/\n@[simps]\ndef homMk {F G : ComposableArrows C n} (app : ‚àÄ i, F.obj i ‚ü∂ G.obj i)\n    (w : ‚àÄ (i : ‚Ñï) (hi : i < n), F.map' i (i + 1) ‚â´ app _ = app _ ‚â´ G.map' i (i + 1)) :\n    F ‚ü∂ G where\n  app := app\n  naturality := by\n    suffices ‚àÄ (k i j : ‚Ñï) (hj : i + k = j) (hj' : j ‚â§ n),\n        F.map' i j ‚â´ app _ = app _ ‚â´ G.map' i j by\n      rintro ‚ü®i, hi‚ü© ‚ü®j, hj‚ü© hij\n      have hij' := leOfHom hij\n      simp only [Fin.mk_le_mk] at hij'\n      obtain ‚ü®k, hk‚ü© := Nat.le.dest hij'\n      exact this k i j hk (by valid)\n    intro k\n    induction' k with k hk\n    ¬∑ intro i j hj hj'\n      simp only [add_zero] at hj\n      obtain rfl := hj\n      rw [F.map'_self i, G.map'_self i, id_comp, comp_id]\n    ¬∑ intro i j hj hj'\n      rw [‚Üê add_assoc] at hj\n      subst hj\n      rw [F.map'_comp i (i + k) (i + k + 1), G.map'_comp i (i + k) (i + k + 1), assoc,\n        w (i + k) (by valid), reassoc_of% (hk i (i + k) rfl (by valid))]\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk_inv","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C n\napp : (i : Fin (HAdd.hAdd n 1)) ‚Üí CategoryTheory.Iso (F.obj i) (G.obj i)\nw : ‚àÄ (i : Nat), LT.lt i n ‚Üí Eq (CategoryTheory.CategoryStruct.comp (F.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (app ‚ü®HAdd.hAdd i 1, ‚ãØ‚ü©).hom) (CategoryTheory.CategoryStruct.comp (app ‚ü®i, ‚ãØ‚ü©).hom (G.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk app w).inv (CategoryTheory.ComposableArrows.homMk (fun i => (app i).inv) ‚ãØ)","decl":"/-- Constructor for isomorphisms `F ‚âÖ G` in `ComposableArrows C n` which takes as inputs\na family of isomorphisms `F.obj i ‚âÖ G.obj i` and the naturality condition only for the\nmaps in `Fin (n + 1)` given by inequalities of the form `i ‚â§ i + 1`. -/\n@[simps]\ndef isoMk {F G : ComposableArrows C n} (app : ‚àÄ i, F.obj i ‚âÖ G.obj i)\n    (w : ‚àÄ (i : ‚Ñï) (hi : i < n),\n      F.map' i (i + 1) ‚â´ (app _).hom = (app _).hom ‚â´ G.map' i (i + 1)) :\n    F ‚âÖ G where\n  hom := homMk (fun i => (app i).hom) w\n  inv := homMk (fun i => (app i).inv) (fun i hi => by\n    dsimp only\n    rw [‚Üê cancel_epi ((app _).hom), ‚Üê reassoc_of% (w i hi), Iso.hom_inv_id, comp_id,\n      Iso.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk_hom","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C n\napp : (i : Fin (HAdd.hAdd n 1)) ‚Üí CategoryTheory.Iso (F.obj i) (G.obj i)\nw : ‚àÄ (i : Nat), LT.lt i n ‚Üí Eq (CategoryTheory.CategoryStruct.comp (F.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (app ‚ü®HAdd.hAdd i 1, ‚ãØ‚ü©).hom) (CategoryTheory.CategoryStruct.comp (app ‚ü®i, ‚ãØ‚ü©).hom (G.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk app w).hom (CategoryTheory.ComposableArrows.homMk (fun i => (app i).hom) w)","decl":"/-- Constructor for isomorphisms `F ‚âÖ G` in `ComposableArrows C n` which takes as inputs\na family of isomorphisms `F.obj i ‚âÖ G.obj i` and the naturality condition only for the\nmaps in `Fin (n + 1)` given by inequalities of the form `i ‚â§ i + 1`. -/\n@[simps]\ndef isoMk {F G : ComposableArrows C n} (app : ‚àÄ i, F.obj i ‚âÖ G.obj i)\n    (w : ‚àÄ (i : ‚Ñï) (hi : i < n),\n      F.map' i (i + 1) ‚â´ (app _).hom = (app _).hom ‚â´ G.map' i (i + 1)) :\n    F ‚âÖ G where\n  hom := homMk (fun i => (app i).hom) w\n  inv := homMk (fun i => (app i).inv) (fun i hi => by\n    dsimp only\n    rw [‚Üê cancel_epi ((app _).hom), ‚Üê reassoc_of% (w i hi), Iso.hom_inv_id, comp_id,\n      Iso.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C n\nh : ‚àÄ (i : Fin (HAdd.hAdd n 1)), Eq (F.obj i) (G.obj i)\nw : ‚àÄ (i : Nat), LT.lt i n ‚Üí Eq (F.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom ‚ãØ) (CategoryTheory.CategoryStruct.comp (G.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq F G","decl":"lemma ext {F G : ComposableArrows C n} (h : ‚àÄ i, F.obj i = G.obj i)\n    (w : ‚àÄ (i : ‚Ñï) (hi : i < n), F.map' i (i + 1) =\n      eqToHom (h _) ‚â´ G.map' i (i + 1) ‚â´ eqToHom (h _).symm) : F = G :=\n  Functor.ext_of_iso\n    (isoMk (fun i => eqToIso (h i)) (fun i hi => by simp [w i hi])) h (fun _ => rfl)\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÄ_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 0\nf : Quiver.Hom (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\ni : Fin (HAdd.hAdd 0 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÄ f).app i) (CategoryTheory.ComposableArrows.homMk‚ÇÄ.match_1 (fun i => Quiver.Hom (F.obj i) (G.obj i)) i fun isLt => f)","decl":"/-- Constructor for morphisms in `ComposableArrows C 0`. -/\n@[simps!]\ndef homMk‚ÇÄ {F G : ComposableArrows C 0} (f : F.obj' 0 ‚ü∂ G.obj' 0) : F ‚ü∂ G :=\n  homMk (fun i => match i with\n    | ‚ü®0, _‚ü© => f) (fun i hi => by simp at hi)\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÄ_iff","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 0\nœÜ œÜ' : Quiver.Hom F G\n‚ä¢ Iff (Eq œÜ œÜ') (Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ))","decl":"@[ext]\nlemma hom_ext‚ÇÄ {F G : ComposableArrows C 0} {œÜ œÜ' : F ‚ü∂ G}\n    (h : app' œÜ 0 = app' œÜ' 0) :\n    œÜ = œÜ' := by\n  ext i\n  fin_cases i\n  exact h\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÄ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 0\nœÜ œÜ' : Quiver.Hom F G\nh : Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma hom_ext‚ÇÄ {F G : ComposableArrows C 0} {œÜ œÜ' : F ‚ü∂ G}\n    (h : app' œÜ 0 = app' œÜ' 0) :\n    œÜ = œÜ' := by\n  ext i\n  fin_cases i\n  exact h\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÄ_hom_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 0\ne : CategoryTheory.Iso (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\ni : Fin (HAdd.hAdd 0 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.isoMk‚ÇÄ e).hom.app i) (CategoryTheory.ComposableArrows.homMk‚ÇÄ.match_1 (fun i => Quiver.Hom (F.obj i) (G.obj i)) i fun isLt => e.hom)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 0`. -/\n@[simps!]\ndef isoMk‚ÇÄ {F G : ComposableArrows C 0} (e : F.obj' 0 ‚âÖ G.obj' 0) : F ‚âÖ G where\n  hom := homMk‚ÇÄ e.hom\n  inv := homMk‚ÇÄ e.inv\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÄ_inv_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 0\ne : CategoryTheory.Iso (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\ni : Fin (HAdd.hAdd 0 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.isoMk‚ÇÄ e).inv.app i) (CategoryTheory.ComposableArrows.homMk‚ÇÄ.match_1 (fun i => Quiver.Hom (G.obj i) (F.obj i)) i fun isLt => e.inv)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 0`. -/\n@[simps!]\ndef isoMk‚ÇÄ {F G : ComposableArrows C 0} (e : F.obj' 0 ‚âÖ G.obj' 0) : F ‚âÖ G where\n  hom := homMk‚ÇÄ e.hom\n  inv := homMk‚ÇÄ e.inv\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext‚ÇÄ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 0\nh : Eq (F.obj' 0 ‚ãØ) (G.obj 0)\n‚ä¢ Eq F G","decl":"lemma ext‚ÇÄ {F G : ComposableArrows C 0} (h : F.obj' 0 = G.obj 0) : F = G :=\n  ext (fun i => match i with\n    | ‚ü®0, _‚ü© => h) (fun i hi => by simp at hi)\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÄ_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF : CategoryTheory.ComposableArrows C 0\n‚ä¢ Exists fun X => Eq F (CategoryTheory.ComposableArrows.mk‚ÇÄ X)","decl":"lemma mk‚ÇÄ_surjective (F : ComposableArrows C 0) : ‚àÉ (X : C), F = mk‚ÇÄ X :=\n  ‚ü®F.obj' 0, ext‚ÇÄ rfl‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÅ_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 1\nleft : Quiver.Hom (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nright : Quiver.Hom (F.obj' 1 ‚ãØ) (G.obj' 1 ‚ãØ)\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) right) (CategoryTheory.CategoryStruct.comp left (G.map' 0 1 ‚ãØ ‚ãØ))) _auto‚úù\ni : Fin (HAdd.hAdd 1 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÅ left right w).app i) (CategoryTheory.ComposableArrows.homMk‚ÇÅ.match_1 (fun i => Quiver.Hom (F.obj i) (G.obj i)) i (fun isLt => left) fun isLt => right)","decl":"/-- Constructor for morphisms in `ComposableArrows C 1`. -/\n@[simps!]\ndef homMk‚ÇÅ {F G : ComposableArrows C 1}\n    (left : F.obj' 0 ‚ü∂ G.obj' 0) (right : F.obj' 1 ‚ü∂ G.obj' 1)\n    (w : F.map' 0 1 ‚â´ right = left ‚â´ G.map' 0 1 := by aesop_cat) :\n    F ‚ü∂ G :=\n  homMk (fun i => match i with\n      | ‚ü®0, _‚ü© => left\n      | ‚ü®1, _‚ü© => right) (by\n          intro i hi\n          obtain rfl : i = 0 := by simpa using hi\n          exact w)\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÅ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 1\nœÜ œÜ' : Quiver.Hom F G\nh‚ÇÄ : Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)\nh‚ÇÅ : Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma hom_ext‚ÇÅ {F G : ComposableArrows C 1} {œÜ œÜ' : F ‚ü∂ G}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) :\n    œÜ = œÜ' := by\n  ext i\n  match i with\n    | 0 => exact h‚ÇÄ\n    | 1 => exact h‚ÇÅ\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÅ_iff","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 1\nœÜ œÜ' : Quiver.Hom F G\n‚ä¢ Iff (Eq œÜ œÜ') (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)) (Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)))","decl":"@[ext]\nlemma hom_ext‚ÇÅ {F G : ComposableArrows C 1} {œÜ œÜ' : F ‚ü∂ G}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) :\n    œÜ = œÜ' := by\n  ext i\n  match i with\n    | 0 => exact h‚ÇÄ\n    | 1 => exact h‚ÇÅ\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÅ_inv_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 1\nleft : CategoryTheory.Iso (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nright : CategoryTheory.Iso (F.obj' 1 ‚ãØ) (G.obj' 1 ‚ãØ)\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) right.hom) (CategoryTheory.CategoryStruct.comp left.hom (G.map' 0 1 ‚ãØ ‚ãØ))) _auto‚úù\ni : Fin (HAdd.hAdd 1 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.isoMk‚ÇÅ left right w).inv.app i) (CategoryTheory.ComposableArrows.homMk‚ÇÅ.match_1 (fun i => Quiver.Hom (G.obj i) (F.obj i)) i (fun isLt => left.inv) fun isLt => right.inv)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 1`. -/\n@[simps!]\ndef isoMk‚ÇÅ {F G : ComposableArrows C 1}\n    (left : F.obj' 0 ‚âÖ G.obj' 0) (right : F.obj' 1 ‚âÖ G.obj' 1)\n    (w : F.map' 0 1 ‚â´ right.hom = left.hom ‚â´ G.map' 0 1 := by aesop_cat) :\n    F ‚âÖ G where\n  hom := homMk‚ÇÅ left.hom right.hom w\n  inv := homMk‚ÇÅ left.inv right.inv (by\n    rw [‚Üê cancel_mono right.hom, assoc, assoc, w, right.inv_hom_id, left.inv_hom_id_assoc]\n    apply comp_id)\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÅ_hom_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 1\nleft : CategoryTheory.Iso (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nright : CategoryTheory.Iso (F.obj' 1 ‚ãØ) (G.obj' 1 ‚ãØ)\nw : autoParam (Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) right.hom) (CategoryTheory.CategoryStruct.comp left.hom (G.map' 0 1 ‚ãØ ‚ãØ))) _auto‚úù\ni : Fin (HAdd.hAdd 1 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.isoMk‚ÇÅ left right w).hom.app i) (CategoryTheory.ComposableArrows.homMk‚ÇÅ.match_1 (fun i => Quiver.Hom (F.obj i) (G.obj i)) i (fun isLt => left.hom) fun isLt => right.hom)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 1`. -/\n@[simps!]\ndef isoMk‚ÇÅ {F G : ComposableArrows C 1}\n    (left : F.obj' 0 ‚âÖ G.obj' 0) (right : F.obj' 1 ‚âÖ G.obj' 1)\n    (w : F.map' 0 1 ‚â´ right.hom = left.hom ‚â´ G.map' 0 1 := by aesop_cat) :\n    F ‚âÖ G where\n  hom := homMk‚ÇÅ left.hom right.hom w\n  inv := homMk‚ÇÅ left.inv right.inv (by\n    rw [‚Üê cancel_mono right.hom, assoc, assoc, w, right.inv_hom_id, left.inv_hom_id_assoc]\n    apply comp_id)\n\n"}
{"name":"CategoryTheory.ComposableArrows.map'_eq_hom‚ÇÅ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF : CategoryTheory.ComposableArrows C 1\n‚ä¢ Eq (F.map' 0 1 ‚ãØ ‚ãØ) F.hom","decl":"lemma map'_eq_hom‚ÇÅ (F : ComposableArrows C 1) : F.map' 0 1 = F.hom := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext‚ÇÅ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nF G : CategoryTheory.ComposableArrows C 1\nleft : Eq F.left G.left\nright : Eq F.right G.right\nw : Eq F.hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom left) (CategoryTheory.CategoryStruct.comp G.hom (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq F G","decl":"lemma ext‚ÇÅ {F G : ComposableArrows C 1}\n    (left : F.left = G.left) (right : F.right = G.right)\n    (w : F.hom = eqToHom left ‚â´ G.hom ‚â´ eqToHom right.symm) : F = G :=\n  Functor.ext_of_iso (isoMk‚ÇÅ (eqToIso left) (eqToIso right) (by simp [map'_eq_hom‚ÇÅ, w]))\n    (fun i => by fin_cases i <;> assumption)\n    (fun i => by fin_cases i <;> rfl)\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÅ_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.ComposableArrows C 1\n‚ä¢ Exists fun X‚ÇÄ => Exists fun X‚ÇÅ => Exists fun f => Eq X (CategoryTheory.ComposableArrows.mk‚ÇÅ f)","decl":"lemma mk‚ÇÅ_surjective (X : ComposableArrows C 1) : ‚àÉ (X‚ÇÄ X‚ÇÅ : C) (f : X‚ÇÄ ‚ü∂ X‚ÇÅ), X = mk‚ÇÅ f :=\n  ‚ü®_, _, X.map' 0 1, ext‚ÇÅ rfl rfl (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.obj_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.obj F X 0) X","decl":"@[simp]\nlemma obj_zero : obj F X 0 = X := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.obj_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.obj F X 1) (F.obj' 0 ‚ãØ)","decl":"@[simp]\nlemma obj_one : obj F X 1 = F.obj' 0 := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.obj_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\ni : Nat\nhi : LT.lt (HAdd.hAdd i 1) (HAdd.hAdd (HAdd.hAdd n 1) 1)\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.obj F X ‚ü®HAdd.hAdd i 1, hi‚ü©) (F.obj' i ‚ãØ)","decl":"@[simp]\nlemma obj_succ (i : ‚Ñï) (hi : i + 1 < n + 1 + 1) : obj F X ‚ü®i + 1, hi‚ü© = F.obj' i := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_zero_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f 0 0 ‚ãØ) (CategoryTheory.CategoryStruct.id X)","decl":"@[simp]\nlemma map_zero_zero : map F f 0 0 (by simp) = ùüô X := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_one_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f 1 1 ‚ãØ) (F.map (CategoryTheory.CategoryStruct.id ‚ü®0, ‚ãØ‚ü©))","decl":"@[simp]\nlemma map_one_one : map F f 1 1 (by simp) = F.map (ùüô _) := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_zero_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f 0 1 ‚ãØ) f","decl":"@[simp]\nlemma map_zero_one : map F f 0 1 (by simp) = f := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_zero_one'","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f 0 ‚ü®HAdd.hAdd 0 1, ‚ãØ‚ü© ‚ãØ) f","decl":"@[simp]\nlemma map_zero_one' : map F f 0 ‚ü®0 + 1, by simp‚ü© (by simp) = f := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_zero_succ_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\nj : Nat\nhj : LT.lt (HAdd.hAdd j 2) (HAdd.hAdd (HAdd.hAdd n 1) 1)\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f 0 ‚ü®HAdd.hAdd j 2, hj‚ü© ‚ãØ) (CategoryTheory.CategoryStruct.comp f (F.map' 0 (HAdd.hAdd j 1) ‚ãØ ‚ãØ))","decl":"@[simp]\nlemma map_zero_succ_succ (j : ‚Ñï) (hj : j + 2 < n + 1 + 1) :\n    map F f 0 ‚ü®j + 2, hj‚ü© (by simp) = f ‚â´ F.map' 0 (j+1) := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_succ_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\ni j : Nat\nhi : LT.lt (HAdd.hAdd i 1) (HAdd.hAdd (HAdd.hAdd n 1) 1)\nhj : LT.lt (HAdd.hAdd j 1) (HAdd.hAdd (HAdd.hAdd n 1) 1)\nhij : LE.le (HAdd.hAdd i 1) (HAdd.hAdd j 1)\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f ‚ü®HAdd.hAdd i 1, hi‚ü© ‚ü®HAdd.hAdd j 1, hj‚ü© hij) (F.map' i j ‚ãØ ‚ãØ)","decl":"@[simp]\nlemma map_succ_succ (i j : ‚Ñï) (hi : i + 1 < n + 1 + 1) (hj : j + 1 < n + 1 + 1)\n    (hij : i + 1 ‚â§ j + 1) :\n    map F f ‚ü®i + 1, hi‚ü© ‚ü®j + 1, hj‚ü© hij = F.map' i j := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_one_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\nj : Nat\nhj : LT.lt (HAdd.hAdd j 1) (HAdd.hAdd (HAdd.hAdd n 1) 1)\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f 1 ‚ü®HAdd.hAdd j 1, hj‚ü© ‚ãØ) (F.map' 0 j ‚ãØ ‚ãØ)","decl":"@[simp]\nlemma map_one_succ (j : ‚Ñï) (hj : j + 1 < n + 1 + 1) :\n    map F f 1 ‚ü®j + 1, hj‚ü© (by simp [Fin.le_def]) = F.map' 0 j := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_id","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\ni : Fin (HAdd.hAdd (HAdd.hAdd n 1) 1)\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f i i ‚ãØ) (CategoryTheory.CategoryStruct.id (CategoryTheory.ComposableArrows.Precomp.obj F X i))","decl":"lemma map_id (i : Fin (n + 1 + 1)) : map F f i i (by simp) = ùüô _ := by\n  obtain ‚ü®_|_, hi‚ü© := i <;> simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.Precomp.map_comp","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\ni j k : Fin (HAdd.hAdd (HAdd.hAdd n 1) 1)\nhij : LE.le i j\nhjk : LE.le j k\n‚ä¢ Eq (CategoryTheory.ComposableArrows.Precomp.map F f i k ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.ComposableArrows.Precomp.map F f i j hij) (CategoryTheory.ComposableArrows.Precomp.map F f j k hjk))","decl":"lemma map_comp {i j k : Fin (n + 1 + 1)} (hij : i ‚â§ j) (hjk : j ‚â§ k) :\n    map F f i k (hij.trans hjk) = map F f i j hij ‚â´ map F f j k hjk := by\n  obtain ‚ü®i, hi‚ü© := i\n  obtain ‚ü®j, hj‚ü© := j\n  obtain ‚ü®k, hk‚ü© := k\n  cases i\n  ¬∑ obtain _ | _ | j := j\n    ¬∑ dsimp\n      rw [id_comp]\n    ¬∑ obtain _ | _ | k := k\n      ¬∑ simp [Nat.succ.injEq] at hjk\n      ¬∑ simp\n      ¬∑ rfl\n    ¬∑ obtain _ | _ | k := k\n      ¬∑ simp [Fin.ext_iff] at hjk\n      ¬∑ simp [Fin.le_def] at hjk\n        omega\n      ¬∑ dsimp\n        rw [assoc, ‚Üê F.map_comp, homOfLE_comp]\n  ¬∑ obtain _ | j := j\n    ¬∑ simp [Fin.ext_iff] at hij\n    ¬∑ obtain _ | k := k\n      ¬∑ simp [Fin.ext_iff] at hjk\n      ¬∑ dsimp\n        rw [‚Üê F.map_comp, homOfLE_comp]\n\n"}
{"name":"CategoryTheory.ComposableArrows.precomp_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\na‚úù : Fin (HAdd.hAdd (HAdd.hAdd n 1) 1)\n‚ä¢ Eq ((F.precomp f).obj a‚úù) (CategoryTheory.ComposableArrows.Precomp.obj F X a‚úù)","decl":"/-- \"Precomposition\" of `F : ComposableArrows C n` by a morphism `f : X ‚ü∂ F.left`. -/\n@[simps]\ndef precomp {X : C} (f : X ‚ü∂ F.left) : ComposableArrows C (n + 1) where\n  obj := Precomp.obj F X\n  map g := Precomp.map F f _ _ (leOfHom g)\n  map_id := Precomp.map_id F f\n  map_comp g g' := Precomp.map_comp F f (leOfHom g) (leOfHom g')\n\n"}
{"name":"CategoryTheory.ComposableArrows.precomp_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\nX‚úù Y‚úù : Fin (HAdd.hAdd (HAdd.hAdd n 1) 1)\ng : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.precomp f).map g) (CategoryTheory.ComposableArrows.Precomp.map F f X‚úù Y‚úù ‚ãØ)","decl":"/-- \"Precomposition\" of `F : ComposableArrows C n` by a morphism `f : X ‚ü∂ F.left`. -/\n@[simps]\ndef precomp {X : C} (f : X ‚ü∂ F.left) : ComposableArrows C (n + 1) where\n  obj := Precomp.obj F X\n  map g := Precomp.map F f _ _ (leOfHom g)\n  map_id := Precomp.map_id F f\n  map_comp g g' := Precomp.map_comp F f (leOfHom g) (leOfHom g')\n\n"}
{"name":"CategoryTheory.ComposableArrows.whiskerLeft_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn m : Nat\nF : CategoryTheory.ComposableArrows C m\nŒ¶ : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd m 1))\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((F.whiskerLeft Œ¶).obj X) (F.obj (Œ¶.obj X))","decl":"/-- The map `ComposableArrows C m ‚Üí ComposableArrows C n` obtained by precomposition with\na functor `Fin (n + 1) ‚•§ Fin (m + 1)`. -/\n@[simps!]\ndef whiskerLeft (F : ComposableArrows C m) (Œ¶ : Fin (n + 1) ‚•§ Fin (m + 1)) :\n    ComposableArrows C n := Œ¶ ‚ãô F\n\n"}
{"name":"CategoryTheory.ComposableArrows.whiskerLeft_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn m : Nat\nF : CategoryTheory.ComposableArrows C m\nŒ¶ : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd m 1))\nX‚úù Y‚úù : Fin (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((F.whiskerLeft Œ¶).map f) (F.map (Œ¶.map f))","decl":"/-- The map `ComposableArrows C m ‚Üí ComposableArrows C n` obtained by precomposition with\na functor `Fin (n + 1) ‚•§ Fin (m + 1)`. -/\n@[simps!]\ndef whiskerLeft (F : ComposableArrows C m) (Œ¶ : Fin (n + 1) ‚•§ Fin (m + 1)) :\n    ComposableArrows C n := Œ¶ ‚ãô F\n\n"}
{"name":"CategoryTheory.ComposableArrows.whiskerLeftFunctor_obj_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn m : Nat\nŒ¶ : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd m 1))\nF : CategoryTheory.ComposableArrows C m\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.whiskerLeftFunctor Œ¶).obj F).obj X) (F.obj (Œ¶.obj X))","decl":"/-- The functor `ComposableArrows C m ‚•§ ComposableArrows C n` obtained by precomposition with\na functor `Fin (n + 1) ‚•§ Fin (m + 1)`. -/\n@[simps!]\ndef whiskerLeftFunctor (Œ¶ : Fin (n + 1) ‚•§ Fin (m + 1)) :\n    ComposableArrows C m ‚•§ ComposableArrows C n where\n  obj F := F.whiskerLeft Œ¶\n  map f := CategoryTheory.whiskerLeft Œ¶ f\n\n"}
{"name":"CategoryTheory.ComposableArrows.whiskerLeftFunctor_obj_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn m : Nat\nŒ¶ : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd m 1))\nF : CategoryTheory.ComposableArrows C m\nX‚úù Y‚úù : Fin (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.whiskerLeftFunctor Œ¶).obj F).map f) (F.map (Œ¶.map f))","decl":"/-- The functor `ComposableArrows C m ‚•§ ComposableArrows C n` obtained by precomposition with\na functor `Fin (n + 1) ‚•§ Fin (m + 1)`. -/\n@[simps!]\ndef whiskerLeftFunctor (Œ¶ : Fin (n + 1) ‚•§ Fin (m + 1)) :\n    ComposableArrows C m ‚•§ ComposableArrows C n where\n  obj F := F.whiskerLeft Œ¶\n  map f := CategoryTheory.whiskerLeft Œ¶ f\n\n"}
{"name":"CategoryTheory.ComposableArrows.whiskerLeftFunctor_map_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn m : Nat\nŒ¶ : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) (Fin (HAdd.hAdd m 1))\nX‚úù Y‚úù : CategoryTheory.ComposableArrows C m\nf : Quiver.Hom X‚úù Y‚úù\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.whiskerLeftFunctor Œ¶).map f).app X) (f.app (Œ¶.obj X))","decl":"/-- The functor `ComposableArrows C m ‚•§ ComposableArrows C n` obtained by precomposition with\na functor `Fin (n + 1) ‚•§ Fin (m + 1)`. -/\n@[simps!]\ndef whiskerLeftFunctor (Œ¶ : Fin (n + 1) ‚•§ Fin (m + 1)) :\n    ComposableArrows C m ‚•§ ComposableArrows C n where\n  obj F := F.whiskerLeft Œ¶\n  map f := CategoryTheory.whiskerLeft Œ¶ f\n\n"}
{"name":"Fin.succFunctor_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"n : Nat\nx‚úù¬π x‚úù : Fin n\nhij : Quiver.Hom x‚úù¬π x‚úù\n‚ä¢ Eq ((Fin.succFunctor n).map hij) (CategoryTheory.homOfLE ‚ãØ)","decl":"/-- The functor `Fin n ‚•§ Fin (n + 1)` which sends `i` to `i.succ`. -/\n@[simps]\ndef _root_.Fin.succFunctor (n : ‚Ñï) : Fin n ‚•§ Fin (n + 1) where\n  obj i := i.succ\n  map {_ _} hij := homOfLE (Fin.succ_le_succ_iff.2 (leOfHom hij))\n\n"}
{"name":"Fin.succFunctor_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"n : Nat\ni : Fin n\n‚ä¢ Eq ((Fin.succFunctor n).obj i) i.succ","decl":"/-- The functor `Fin n ‚•§ Fin (n + 1)` which sends `i` to `i.succ`. -/\n@[simps]\ndef _root_.Fin.succFunctor (n : ‚Ñï) : Fin n ‚•§ Fin (n + 1) where\n  obj i := i.succ\n  map {_ _} hij := homOfLE (Fin.succ_le_succ_iff.2 (leOfHom hij))\n\n"}
{"name":"CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor_map_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù Y‚úù : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor.map f).app X) (f.app X.succ)","decl":"/-- The functor `ComposableArrows C (n + 1) ‚•§ ComposableArrows C n` which forgets\nthe first arrow. -/\n@[simps!]\ndef Œ¥‚ÇÄFunctor : ComposableArrows C (n + 1) ‚•§ ComposableArrows C n :=\n  whiskerLeftFunctor (Fin.succFunctor (n + 1))\n\n"}
{"name":"CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor_obj_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor.obj F).obj X) (F.obj X.succ)","decl":"/-- The functor `ComposableArrows C (n + 1) ‚•§ ComposableArrows C n` which forgets\nthe first arrow. -/\n@[simps!]\ndef Œ¥‚ÇÄFunctor : ComposableArrows C (n + 1) ‚•§ ComposableArrows C n :=\n  whiskerLeftFunctor (Fin.succFunctor (n + 1))\n\n"}
{"name":"CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor_obj_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nX‚úù Y‚úù : Fin (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor.obj F).map f) (F.map (CategoryTheory.homOfLE ‚ãØ))","decl":"/-- The functor `ComposableArrows C (n + 1) ‚•§ ComposableArrows C n` which forgets\nthe first arrow. -/\n@[simps!]\ndef Œ¥‚ÇÄFunctor : ComposableArrows C (n + 1) ‚•§ ComposableArrows C n :=\n  whiskerLeftFunctor (Fin.succFunctor (n + 1))\n\n"}
{"name":"CategoryTheory.ComposableArrows.precomp_Œ¥‚ÇÄ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C n\nX : C\nf : Quiver.Hom X F.left\n‚ä¢ Eq (F.precomp f).Œ¥‚ÇÄ F","decl":"@[simp]\nlemma precomp_Œ¥‚ÇÄ {X : C} (f : X ‚ü∂ F.left) : (F.precomp f).Œ¥‚ÇÄ = F := rfl\n\n"}
{"name":"Fin.castSuccFunctor_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"n : Nat\nX‚úù Y‚úù : Fin n\nhij : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((Fin.castSuccFunctor n).map hij) hij","decl":"/-- The functor `Fin n ‚•§ Fin (n + 1)` which sends `i` to `i.castSucc`. -/\n@[simps]\ndef _root_.Fin.castSuccFunctor (n : ‚Ñï) : Fin n ‚•§ Fin (n + 1) where\n  obj i := i.castSucc\n  map hij := hij\n\n"}
{"name":"Fin.castSuccFunctor_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"n : Nat\ni : Fin n\n‚ä¢ Eq ((Fin.castSuccFunctor n).obj i) i.castSucc","decl":"/-- The functor `Fin n ‚•§ Fin (n + 1)` which sends `i` to `i.castSucc`. -/\n@[simps]\ndef _root_.Fin.castSuccFunctor (n : ‚Ñï) : Fin n ‚•§ Fin (n + 1) where\n  obj i := i.castSucc\n  map hij := hij\n\n"}
{"name":"CategoryTheory.ComposableArrows.Œ¥lastFunctor_map_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù Y‚úù : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.Œ¥lastFunctor.map f).app X) (f.app X.castSucc)","decl":"/-- The functor `ComposableArrows C (n + 1) ‚•§ ComposableArrows C n` which forgets\nthe last arrow. -/\n@[simps!]\ndef Œ¥lastFunctor : ComposableArrows C (n + 1) ‚•§ ComposableArrows C n :=\n  whiskerLeftFunctor (Fin.castSuccFunctor (n + 1))\n\n"}
{"name":"CategoryTheory.ComposableArrows.Œ¥lastFunctor_obj_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nX‚úù Y‚úù : Fin (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.Œ¥lastFunctor.obj F).map f) (F.map f)","decl":"/-- The functor `ComposableArrows C (n + 1) ‚•§ ComposableArrows C n` which forgets\nthe last arrow. -/\n@[simps!]\ndef Œ¥lastFunctor : ComposableArrows C (n + 1) ‚•§ ComposableArrows C n :=\n  whiskerLeftFunctor (Fin.castSuccFunctor (n + 1))\n\n"}
{"name":"CategoryTheory.ComposableArrows.Œ¥lastFunctor_obj_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.Œ¥lastFunctor.obj F).obj X) (F.obj X.castSucc)","decl":"/-- The functor `ComposableArrows C (n + 1) ‚•§ ComposableArrows C n` which forgets\nthe last arrow. -/\n@[simps!]\ndef Œ¥lastFunctor : ComposableArrows C (n + 1) ‚•§ ComposableArrows C n :=\n  whiskerLeftFunctor (Fin.castSuccFunctor (n + 1))\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMkSucc_app_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nŒ± : Quiver.Hom (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nŒ≤ : Quiver.Hom F.Œ¥‚ÇÄ G.Œ¥‚ÇÄ\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.ComposableArrows.app' Œ≤ 0 ‚ãØ)) (CategoryTheory.CategoryStruct.comp Œ± (G.map' 0 1 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMkSucc Œ± Œ≤ w).app 0) Œ±","decl":"@[simp]\nlemma homMkSucc_app_zero : (homMkSucc Œ± Œ≤ w).app 0 = Œ± := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMkSucc_app_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nŒ± : Quiver.Hom (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nŒ≤ : Quiver.Hom F.Œ¥‚ÇÄ G.Œ¥‚ÇÄ\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.ComposableArrows.app' Œ≤ 0 ‚ãØ)) (CategoryTheory.CategoryStruct.comp Œ± (G.map' 0 1 ‚ãØ ‚ãØ))\ni : Nat\nhi : LT.lt (HAdd.hAdd i 1) (HAdd.hAdd (HAdd.hAdd n 1) 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMkSucc Œ± Œ≤ w).app ‚ü®HAdd.hAdd i 1, hi‚ü©) (CategoryTheory.ComposableArrows.app' Œ≤ i ‚ãØ)","decl":"@[simp]\nlemma homMkSucc_app_succ (i : ‚Ñï) (hi : i + 1 < n + 1 + 1) :\n    (homMkSucc Œ± Œ≤ w).app ‚ü®i + 1, hi‚ü© = app' Œ≤ i := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nf g : Quiver.Hom F G\nh‚ÇÄ : Eq (CategoryTheory.ComposableArrows.app' f 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' g 0 ‚ãØ)\nh‚ÇÅ : Eq (CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor.map f) (CategoryTheory.ComposableArrows.Œ¥‚ÇÄFunctor.map g)\n‚ä¢ Eq f g","decl":"lemma hom_ext_succ {F G : ComposableArrows C (n + 1)} {f g : F ‚ü∂ G}\n    (h‚ÇÄ : app' f 0 = app' g 0) (h‚ÇÅ : Œ¥‚ÇÄFunctor.map f = Œ¥‚ÇÄFunctor.map g) : f = g := by\n  ext ‚ü®i, hi‚ü©\n  obtain _ | i := i\n  ¬∑ exact h‚ÇÄ\n  ¬∑ exact congr_app h‚ÇÅ ‚ü®i, by valid‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMkSucc_inv","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nŒ± : CategoryTheory.Iso (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nŒ≤ : CategoryTheory.Iso F.Œ¥‚ÇÄ G.Œ¥‚ÇÄ\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.ComposableArrows.app' Œ≤.hom 0 ‚ãØ)) (CategoryTheory.CategoryStruct.comp Œ±.hom (G.map' 0 1 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMkSucc Œ± Œ≤ w).inv (CategoryTheory.ComposableArrows.homMkSucc Œ±.inv Œ≤.inv ‚ãØ)","decl":"/-- Inductive construction of isomorphisms in `ComposableArrows C (n + 1)`: in order to\nconstruct an isomorphism `F ‚âÖ G`, it suffices to provide `Œ± : F.obj' 0 ‚âÖ G.obj' 0` and\n`Œ≤ : F.Œ¥‚ÇÄ ‚âÖ G.Œ¥‚ÇÄ` such that `F.map' 0 1 ‚â´ app' Œ≤.hom 0 = Œ±.hom ‚â´ G.map' 0 1`. -/\n@[simps]\ndef isoMkSucc {F G : ComposableArrows C (n + 1)} (Œ± : F.obj' 0 ‚âÖ G.obj' 0)\n    (Œ≤ : F.Œ¥‚ÇÄ ‚âÖ G.Œ¥‚ÇÄ) (w : F.map' 0 1 ‚â´ app' Œ≤.hom 0 = Œ±.hom ‚â´ G.map' 0 1) : F ‚âÖ G where\n  hom := homMkSucc Œ±.hom Œ≤.hom w\n  inv := homMkSucc Œ±.inv Œ≤.inv (by\n    rw [‚Üê cancel_epi Œ±.hom, ‚Üê reassoc_of% w, Œ±.hom_inv_id_assoc, Œ≤.hom_inv_id_app]\n    dsimp\n    rw [comp_id])\n  hom_inv_id := by\n    apply hom_ext_succ\n    ¬∑ simp\n    ¬∑ ext ‚ü®i, hi‚ü©\n      simp\n  inv_hom_id := by\n    apply hom_ext_succ\n    ¬∑ simp\n    ¬∑ ext ‚ü®i, hi‚ü©\n      simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMkSucc_hom","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nŒ± : CategoryTheory.Iso (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nŒ≤ : CategoryTheory.Iso F.Œ¥‚ÇÄ G.Œ¥‚ÇÄ\nw : Eq (CategoryTheory.CategoryStruct.comp (F.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.ComposableArrows.app' Œ≤.hom 0 ‚ãØ)) (CategoryTheory.CategoryStruct.comp Œ±.hom (G.map' 0 1 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMkSucc Œ± Œ≤ w).hom (CategoryTheory.ComposableArrows.homMkSucc Œ±.hom Œ≤.hom w)","decl":"/-- Inductive construction of isomorphisms in `ComposableArrows C (n + 1)`: in order to\nconstruct an isomorphism `F ‚âÖ G`, it suffices to provide `Œ± : F.obj' 0 ‚âÖ G.obj' 0` and\n`Œ≤ : F.Œ¥‚ÇÄ ‚âÖ G.Œ¥‚ÇÄ` such that `F.map' 0 1 ‚â´ app' Œ≤.hom 0 = Œ±.hom ‚â´ G.map' 0 1`. -/\n@[simps]\ndef isoMkSucc {F G : ComposableArrows C (n + 1)} (Œ± : F.obj' 0 ‚âÖ G.obj' 0)\n    (Œ≤ : F.Œ¥‚ÇÄ ‚âÖ G.Œ¥‚ÇÄ) (w : F.map' 0 1 ‚â´ app' Œ≤.hom 0 = Œ±.hom ‚â´ G.map' 0 1) : F ‚âÖ G where\n  hom := homMkSucc Œ±.hom Œ≤.hom w\n  inv := homMkSucc Œ±.inv Œ≤.inv (by\n    rw [‚Üê cancel_epi Œ±.hom, ‚Üê reassoc_of% w, Œ±.hom_inv_id_assoc, Œ≤.hom_inv_id_app]\n    dsimp\n    rw [comp_id])\n  hom_inv_id := by\n    apply hom_ext_succ\n    ¬∑ simp\n    ¬∑ ext ‚ü®i, hi‚ü©\n      simp\n  inv_hom_id := by\n    apply hom_ext_succ\n    ¬∑ simp\n    ¬∑ ext ‚ü®i, hi‚ü©\n      simp\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF G : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\nh‚ÇÄ : Eq (F.obj' 0 ‚ãØ) (G.obj' 0 ‚ãØ)\nh : Eq F.Œ¥‚ÇÄ G.Œ¥‚ÇÄ\nw : Eq (F.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÄ) (CategoryTheory.CategoryStruct.comp (G.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq F G","decl":"lemma ext_succ {F G : ComposableArrows C (n + 1)} (h‚ÇÄ : F.obj' 0 = G.obj' 0)\n    (h : F.Œ¥‚ÇÄ = G.Œ¥‚ÇÄ) (w : F.map' 0 1 = eqToHom h‚ÇÄ ‚â´ G.map' 0 1 ‚â´\n      eqToHom (Functor.congr_obj h.symm 0)) : F = G := by\n  have : ‚àÄ i, F.obj i = G.obj i := by\n    intro ‚ü®i, hi‚ü©\n    cases' i with i\n    ¬∑ exact h‚ÇÄ\n    ¬∑ exact Functor.congr_obj h ‚ü®i, by valid‚ü©\n  exact Functor.ext_of_iso (isoMkSucc (eqToIso h‚ÇÄ) (eqToIso h) (by\n      rw [w]\n      dsimp [app']\n      rw [eqToHom_app, assoc, assoc, eqToHom_trans, eqToHom_refl, comp_id])) this\n    (by rintro ‚ü®_|_, hi‚ü© <;> simp)\n\n"}
{"name":"CategoryTheory.ComposableArrows.precomp_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nF : CategoryTheory.ComposableArrows C (HAdd.hAdd n 1)\n‚ä¢ Exists fun F‚ÇÄ => Exists fun X‚ÇÄ => Exists fun f‚ÇÄ => Eq F (F‚ÇÄ.precomp f‚ÇÄ)","decl":"lemma precomp_surjective (F : ComposableArrows C (n + 1)) :\n    ‚àÉ (F‚ÇÄ : ComposableArrows C n) (X‚ÇÄ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ F‚ÇÄ.left), F = F‚ÇÄ.precomp f‚ÇÄ :=\n  ‚ü®F.Œ¥‚ÇÄ, _, F.map' 0 1, ext_succ rfl (by simp) (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÇ_app_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).app 0) app‚ÇÄ","decl":"@[simp]\nlemma homMk‚ÇÇ_app_zero : (homMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).app 0 = app‚ÇÄ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÇ_app_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).app 1) app‚ÇÅ","decl":"@[simp]\nlemma homMk‚ÇÇ_app_one : (homMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).app 1 = app‚ÇÅ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÇ_app_two","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).app ‚ü®2, ‚ãØ‚ü©) app‚ÇÇ","decl":"@[simp]\nlemma homMk‚ÇÇ_app_two : (homMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).app ‚ü®2, by valid‚ü© = app‚ÇÇ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÇ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\nœÜ œÜ' : Quiver.Hom f g\nh‚ÇÄ : Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)\nh‚ÇÅ : Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)\nh‚ÇÇ : Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma hom_ext‚ÇÇ {f g : ComposableArrows C 2} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÅ h‚ÇÅ h‚ÇÇ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÇ_iff","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\nœÜ œÜ' : Quiver.Hom f g\n‚ä¢ Iff (Eq œÜ œÜ') (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)) (Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ))))","decl":"@[ext]\nlemma hom_ext‚ÇÇ {f g : ComposableArrows C 2} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÅ h‚ÇÅ h‚ÇÇ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÇ_inv","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).inv (CategoryTheory.ComposableArrows.homMk‚ÇÇ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv ‚ãØ ‚ãØ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 2`. -/\n@[simps]\ndef isoMk‚ÇÇ {f g : ComposableArrows C 2}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2) : f ‚âÖ g where\n  hom := homMk‚ÇÇ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom w‚ÇÄ w‚ÇÅ\n  inv := homMk‚ÇÇ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv\n    (by rw [‚Üê cancel_epi app‚ÇÄ.hom, ‚Üê reassoc_of% w‚ÇÄ, app‚ÇÅ.hom_inv_id,\n      comp_id, app‚ÇÄ.hom_inv_id_assoc])\n    (by rw [‚Üê cancel_epi app‚ÇÅ.hom, ‚Üê reassoc_of% w‚ÇÅ, app‚ÇÇ.hom_inv_id,\n      comp_id, app‚ÇÅ.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÇ_hom","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÇ app‚ÇÄ app‚ÇÅ app‚ÇÇ w‚ÇÄ w‚ÇÅ).hom (CategoryTheory.ComposableArrows.homMk‚ÇÇ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom w‚ÇÄ w‚ÇÅ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 2`. -/\n@[simps]\ndef isoMk‚ÇÇ {f g : ComposableArrows C 2}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2) : f ‚âÖ g where\n  hom := homMk‚ÇÇ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom w‚ÇÄ w‚ÇÅ\n  inv := homMk‚ÇÇ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv\n    (by rw [‚Üê cancel_epi app‚ÇÄ.hom, ‚Üê reassoc_of% w‚ÇÄ, app‚ÇÅ.hom_inv_id,\n      comp_id, app‚ÇÄ.hom_inv_id_assoc])\n    (by rw [‚Üê cancel_epi app‚ÇÅ.hom, ‚Üê reassoc_of% w‚ÇÅ, app‚ÇÇ.hom_inv_id,\n      comp_id, app‚ÇÅ.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext‚ÇÇ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 2\nh‚ÇÄ : Eq (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\nh‚ÇÅ : Eq (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\nh‚ÇÇ : Eq (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nw‚ÇÄ : Eq (f.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÄ) (CategoryTheory.CategoryStruct.comp (g.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÅ : Eq (f.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (g.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq f g","decl":"lemma ext‚ÇÇ {f g : ComposableArrows C 2}\n    (h‚ÇÄ : f.obj' 0 = g.obj' 0) (h‚ÇÅ : f.obj' 1 = g.obj' 1) (h‚ÇÇ : f.obj' 2 = g.obj' 2)\n    (w‚ÇÄ : f.map' 0 1 = eqToHom h‚ÇÄ ‚â´ g.map' 0 1 ‚â´ eqToHom h‚ÇÅ.symm)\n    (w‚ÇÅ : f.map' 1 2 = eqToHom h‚ÇÅ ‚â´ g.map' 1 2 ‚â´ eqToHom h‚ÇÇ.symm) : f = g :=\n  ext_succ h‚ÇÄ (ext‚ÇÅ h‚ÇÅ h‚ÇÇ w‚ÇÅ) w‚ÇÄ\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÇ_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.ComposableArrows C 2\n‚ä¢ Exists fun X‚ÇÄ => Exists fun X‚ÇÅ => Exists fun X‚ÇÇ => Exists fun f‚ÇÄ => Exists fun f‚ÇÅ => Eq X (CategoryTheory.ComposableArrows.mk‚ÇÇ f‚ÇÄ f‚ÇÅ)","decl":"lemma mk‚ÇÇ_surjective (X : ComposableArrows C 2) :\n    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ), X = mk‚ÇÇ f‚ÇÄ f‚ÇÅ :=\n  ‚ü®_, _, _, X.map' 0 1, X.map' 1 2, ext‚ÇÇ rfl rfl rfl (by simp) (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÉ_app_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app 0) app‚ÇÄ","decl":"@[simp]\nlemma homMk‚ÇÉ_app_zero : (homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app 0 = app‚ÇÄ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÉ_app_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app 1) app‚ÇÅ","decl":"@[simp]\nlemma homMk‚ÇÉ_app_one : (homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app 1 = app‚ÇÅ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÉ_app_two","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app ‚ü®2, ‚ãØ‚ü©) app‚ÇÇ","decl":"@[simp]\nlemma homMk‚ÇÉ_app_two : (homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app ‚ü®2, by valid‚ü© = app‚ÇÇ :=\n  rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÉ_app_three","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app ‚ü®3, ‚ãØ‚ü©) app‚ÇÉ","decl":"@[simp]\nlemma homMk‚ÇÉ_app_three : (homMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).app ‚ü®3, by valid‚ü© = app‚ÇÉ :=\n  rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÉ_iff","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\nœÜ œÜ' : Quiver.Hom f g\n‚ä¢ Iff (Eq œÜ œÜ') (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)) (Eq (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 3 ‚ãØ)))))","decl":"@[ext]\nlemma hom_ext‚ÇÉ {f g : ComposableArrows C 3} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2)\n    (h‚ÇÉ : app' œÜ 3 = app' œÜ' 3) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÇ h‚ÇÅ h‚ÇÇ h‚ÇÉ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÉ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\nœÜ œÜ' : Quiver.Hom f g\nh‚ÇÄ : Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)\nh‚ÇÅ : Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)\nh‚ÇÇ : Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)\nh‚ÇÉ : Eq (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 3 ‚ãØ)\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma hom_ext‚ÇÉ {f g : ComposableArrows C 3} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2)\n    (h‚ÇÉ : app' œÜ 3 = app' œÜ' 3) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÇ h‚ÇÅ h‚ÇÇ h‚ÇÉ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÉ_hom","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : CategoryTheory.Iso (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÇ.hom (g.map' 2 3 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).hom (CategoryTheory.ComposableArrows.homMk‚ÇÉ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 3`. -/\n@[simps]\ndef isoMk‚ÇÉ {f g : ComposableArrows C 3}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (app‚ÇÉ : f.obj' 3 ‚âÖ g.obj' 3)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2)\n    (w‚ÇÇ : f.map' 2 3 ‚â´ app‚ÇÉ.hom = app‚ÇÇ.hom ‚â´ g.map' 2 3) : f ‚âÖ g where\n  hom := homMk‚ÇÉ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ\n  inv := homMk‚ÇÉ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv\n    (by rw [‚Üê cancel_epi app‚ÇÄ.hom, ‚Üê reassoc_of% w‚ÇÄ, app‚ÇÅ.hom_inv_id,\n      comp_id, app‚ÇÄ.hom_inv_id_assoc])\n    (by rw [‚Üê cancel_epi app‚ÇÅ.hom, ‚Üê reassoc_of% w‚ÇÅ, app‚ÇÇ.hom_inv_id,\n      comp_id, app‚ÇÅ.hom_inv_id_assoc])\n    (by rw [‚Üê cancel_epi app‚ÇÇ.hom, ‚Üê reassoc_of% w‚ÇÇ, app‚ÇÉ.hom_inv_id,\n      comp_id, app‚ÇÇ.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÉ_inv","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : CategoryTheory.Iso (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÇ.hom (g.map' 2 3 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÉ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ w‚ÇÄ w‚ÇÅ w‚ÇÇ).inv (CategoryTheory.ComposableArrows.homMk‚ÇÉ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv ‚ãØ ‚ãØ ‚ãØ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 3`. -/\n@[simps]\ndef isoMk‚ÇÉ {f g : ComposableArrows C 3}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (app‚ÇÉ : f.obj' 3 ‚âÖ g.obj' 3)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2)\n    (w‚ÇÇ : f.map' 2 3 ‚â´ app‚ÇÉ.hom = app‚ÇÇ.hom ‚â´ g.map' 2 3) : f ‚âÖ g where\n  hom := homMk‚ÇÉ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ\n  inv := homMk‚ÇÉ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv\n    (by rw [‚Üê cancel_epi app‚ÇÄ.hom, ‚Üê reassoc_of% w‚ÇÄ, app‚ÇÅ.hom_inv_id,\n      comp_id, app‚ÇÄ.hom_inv_id_assoc])\n    (by rw [‚Üê cancel_epi app‚ÇÅ.hom, ‚Üê reassoc_of% w‚ÇÅ, app‚ÇÇ.hom_inv_id,\n      comp_id, app‚ÇÅ.hom_inv_id_assoc])\n    (by rw [‚Üê cancel_epi app‚ÇÇ.hom, ‚Üê reassoc_of% w‚ÇÇ, app‚ÇÉ.hom_inv_id,\n      comp_id, app‚ÇÇ.hom_inv_id_assoc])\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext‚ÇÉ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 3\nh‚ÇÄ : Eq (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\nh‚ÇÅ : Eq (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\nh‚ÇÇ : Eq (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nh‚ÇÉ : Eq (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nw‚ÇÄ : Eq (f.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÄ) (CategoryTheory.CategoryStruct.comp (g.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÅ : Eq (f.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (g.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÇ : Eq (f.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÇ) (CategoryTheory.CategoryStruct.comp (g.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq f g","decl":"lemma ext‚ÇÉ {f g : ComposableArrows C 3}\n    (h‚ÇÄ : f.obj' 0 = g.obj' 0) (h‚ÇÅ : f.obj' 1 = g.obj' 1) (h‚ÇÇ : f.obj' 2 = g.obj' 2)\n    (h‚ÇÉ : f.obj' 3 = g.obj' 3)\n    (w‚ÇÄ : f.map' 0 1 = eqToHom h‚ÇÄ ‚â´ g.map' 0 1 ‚â´ eqToHom h‚ÇÅ.symm)\n    (w‚ÇÅ : f.map' 1 2 = eqToHom h‚ÇÅ ‚â´ g.map' 1 2 ‚â´ eqToHom h‚ÇÇ.symm)\n    (w‚ÇÇ : f.map' 2 3 = eqToHom h‚ÇÇ ‚â´ g.map' 2 3 ‚â´ eqToHom h‚ÇÉ.symm) : f = g :=\n  ext_succ h‚ÇÄ (ext‚ÇÇ h‚ÇÅ h‚ÇÇ h‚ÇÉ w‚ÇÅ w‚ÇÇ) w‚ÇÄ\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÉ_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.ComposableArrows C 3\n‚ä¢ Exists fun X‚ÇÄ => Exists fun X‚ÇÅ => Exists fun X‚ÇÇ => Exists fun X‚ÇÉ => Exists fun f‚ÇÄ => Exists fun f‚ÇÅ => Exists fun f‚ÇÇ => Eq X (CategoryTheory.ComposableArrows.mk‚ÇÉ f‚ÇÄ f‚ÇÅ f‚ÇÇ)","decl":"lemma mk‚ÇÉ_surjective (X : ComposableArrows C 3) :\n    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ X‚ÇÉ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ), X = mk‚ÇÉ f‚ÇÄ f‚ÇÅ f‚ÇÇ :=\n  ‚ü®_, _, _, _, X.map' 0 1, X.map' 1 2, X.map' 2 3,\n    ext‚ÇÉ rfl rfl rfl rfl (by simp) (by simp) (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÑ_app_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app 0) app‚ÇÄ","decl":"@[simp]\nlemma homMk‚ÇÑ_app_zero : (homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app 0 = app‚ÇÄ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÑ_app_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app 1) app‚ÇÅ","decl":"@[simp]\nlemma homMk‚ÇÑ_app_one : (homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app 1 = app‚ÇÅ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÑ_app_two","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app ‚ü®2, ‚ãØ‚ü©) app‚ÇÇ","decl":"@[simp]\nlemma homMk‚ÇÑ_app_two :\n    (homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app ‚ü®2, by valid‚ü© = app‚ÇÇ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÑ_app_three","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app ‚ü®3, ‚ãØ‚ü©) app‚ÇÉ","decl":"@[simp]\nlemma homMk‚ÇÑ_app_three :\n    (homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app ‚ü®3, by valid‚ü© = app‚ÇÉ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÑ_app_four","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app ‚ü®4, ‚ãØ‚ü©) app‚ÇÑ","decl":"@[simp]\nlemma homMk‚ÇÑ_app_four :\n    (homMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).app ‚ü®4, by valid‚ü© = app‚ÇÑ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÑ_iff","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\nœÜ œÜ' : Quiver.Hom f g\n‚ä¢ Iff (Eq œÜ œÜ') (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 3 ‚ãØ)) (Eq (CategoryTheory.ComposableArrows.app' œÜ 4 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 4 ‚ãØ))))))","decl":"@[ext]\nlemma hom_ext‚ÇÑ {f g : ComposableArrows C 4} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2)\n    (h‚ÇÉ : app' œÜ 3 = app' œÜ' 3) (h‚ÇÑ : app' œÜ 4 = app' œÜ' 4) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÉ h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÑ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\nœÜ œÜ' : Quiver.Hom f g\nh‚ÇÄ : Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)\nh‚ÇÅ : Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)\nh‚ÇÇ : Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)\nh‚ÇÉ : Eq (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 3 ‚ãØ)\nh‚ÇÑ : Eq (CategoryTheory.ComposableArrows.app' œÜ 4 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 4 ‚ãØ)\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma hom_ext‚ÇÑ {f g : ComposableArrows C 4} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2)\n    (h‚ÇÉ : app' œÜ 3 = app' œÜ' 3) (h‚ÇÑ : app' œÜ 4 = app' œÜ' 4) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÉ h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.map'_inv_eq_inv_map'","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn m : Nat\nh : LE.le (HAdd.hAdd n 1) m\nf g : CategoryTheory.ComposableArrows C m\napp : CategoryTheory.Iso (f.obj' n ‚ãØ) (g.obj' n ‚ãØ)\napp' : CategoryTheory.Iso (f.obj' (HAdd.hAdd n 1) ‚ãØ) (g.obj' (HAdd.hAdd n 1) ‚ãØ)\nw : Eq (CategoryTheory.CategoryStruct.comp (f.map' n (HAdd.hAdd n 1) ‚ãØ ‚ãØ) app'.hom) (CategoryTheory.CategoryStruct.comp app.hom (g.map' n (HAdd.hAdd n 1) ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (g.map' n (HAdd.hAdd n 1) ‚ãØ ‚ãØ) app'.inv) (CategoryTheory.CategoryStruct.comp app.inv (f.map' n (HAdd.hAdd n 1) ‚ãØ ‚ãØ))","decl":"lemma map'_inv_eq_inv_map' {n m : ‚Ñï} (h : n+1 ‚â§ m) {f g : ComposableArrows C m}\n    (app : f.obj' n ‚âÖ g.obj' n) (app' : f.obj' (n+1) ‚âÖ g.obj' (n+1))\n    (w : f.map' n (n+1) ‚â´ app'.hom = app.hom ‚â´ g.map' n (n+1)) :\n    map' g n (n+1) ‚â´ app'.inv = app.inv ‚â´ map' f n (n+1) := by\n  rw [‚Üê cancel_epi app.hom, ‚Üê reassoc_of% w, app'.hom_inv_id, comp_id, app.hom_inv_id_assoc]\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÑ_inv","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : CategoryTheory.Iso (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : CategoryTheory.Iso (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÇ.hom (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÉ.hom (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).inv (CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv app‚ÇÑ.inv ‚ãØ ‚ãØ ‚ãØ ‚ãØ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 4`. -/\n@[simps]\ndef isoMk‚ÇÑ {f g : ComposableArrows C 4}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (app‚ÇÉ : f.obj' 3 ‚âÖ g.obj' 3) (app‚ÇÑ : f.obj' 4 ‚âÖ g.obj' 4)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2)\n    (w‚ÇÇ : f.map' 2 3 ‚â´ app‚ÇÉ.hom = app‚ÇÇ.hom ‚â´ g.map' 2 3)\n    (w‚ÇÉ : f.map' 3 4 ‚â´ app‚ÇÑ.hom = app‚ÇÉ.hom ‚â´ g.map' 3 4) :\n    f ‚âÖ g where\n  hom := homMk‚ÇÑ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom app‚ÇÑ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ\n  inv := homMk‚ÇÑ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv app‚ÇÑ.inv\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÄ app‚ÇÅ w‚ÇÄ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÅ app‚ÇÇ w‚ÇÅ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÇ app‚ÇÉ w‚ÇÇ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÉ app‚ÇÑ w‚ÇÉ])\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÑ_hom","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : CategoryTheory.Iso (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : CategoryTheory.Iso (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÇ.hom (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÉ.hom (g.map' 3 4 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÑ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ).hom (CategoryTheory.ComposableArrows.homMk‚ÇÑ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom app‚ÇÑ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 4`. -/\n@[simps]\ndef isoMk‚ÇÑ {f g : ComposableArrows C 4}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (app‚ÇÉ : f.obj' 3 ‚âÖ g.obj' 3) (app‚ÇÑ : f.obj' 4 ‚âÖ g.obj' 4)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2)\n    (w‚ÇÇ : f.map' 2 3 ‚â´ app‚ÇÉ.hom = app‚ÇÇ.hom ‚â´ g.map' 2 3)\n    (w‚ÇÉ : f.map' 3 4 ‚â´ app‚ÇÑ.hom = app‚ÇÉ.hom ‚â´ g.map' 3 4) :\n    f ‚âÖ g where\n  hom := homMk‚ÇÑ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom app‚ÇÑ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ\n  inv := homMk‚ÇÑ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv app‚ÇÑ.inv\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÄ app‚ÇÅ w‚ÇÄ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÅ app‚ÇÇ w‚ÇÅ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÇ app‚ÇÉ w‚ÇÇ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÉ app‚ÇÑ w‚ÇÉ])\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext‚ÇÑ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 4\nh‚ÇÄ : Eq (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\nh‚ÇÅ : Eq (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\nh‚ÇÇ : Eq (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nh‚ÇÉ : Eq (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nh‚ÇÑ : Eq (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nw‚ÇÄ : Eq (f.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÄ) (CategoryTheory.CategoryStruct.comp (g.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÅ : Eq (f.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (g.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÇ : Eq (f.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÇ) (CategoryTheory.CategoryStruct.comp (g.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÉ : Eq (f.map' 3 4 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÉ) (CategoryTheory.CategoryStruct.comp (g.map' 3 4 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq f g","decl":"lemma ext‚ÇÑ {f g : ComposableArrows C 4}\n    (h‚ÇÄ : f.obj' 0 = g.obj' 0) (h‚ÇÅ : f.obj' 1 = g.obj' 1) (h‚ÇÇ : f.obj' 2 = g.obj' 2)\n    (h‚ÇÉ : f.obj' 3 = g.obj' 3) (h‚ÇÑ : f.obj' 4 = g.obj' 4)\n    (w‚ÇÄ : f.map' 0 1 = eqToHom h‚ÇÄ ‚â´ g.map' 0 1 ‚â´ eqToHom h‚ÇÅ.symm)\n    (w‚ÇÅ : f.map' 1 2 = eqToHom h‚ÇÅ ‚â´ g.map' 1 2 ‚â´ eqToHom h‚ÇÇ.symm)\n    (w‚ÇÇ : f.map' 2 3 = eqToHom h‚ÇÇ ‚â´ g.map' 2 3 ‚â´ eqToHom h‚ÇÉ.symm)\n    (w‚ÇÉ : f.map' 3 4 = eqToHom h‚ÇÉ ‚â´ g.map' 3 4 ‚â´ eqToHom h‚ÇÑ.symm) :\n    f = g :=\n  ext_succ h‚ÇÄ (ext‚ÇÉ h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ w‚ÇÅ w‚ÇÇ w‚ÇÉ) w‚ÇÄ\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÑ_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.ComposableArrows C 4\n‚ä¢ Exists fun X‚ÇÄ => Exists fun X‚ÇÅ => Exists fun X‚ÇÇ => Exists fun X‚ÇÉ => Exists fun X‚ÇÑ => Exists fun f‚ÇÄ => Exists fun f‚ÇÅ => Exists fun f‚ÇÇ => Exists fun f‚ÇÉ => Eq X (CategoryTheory.ComposableArrows.mk‚ÇÑ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ)","decl":"lemma mk‚ÇÑ_surjective (X : ComposableArrows C 4) :\n    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ) (f‚ÇÉ : X‚ÇÉ ‚ü∂ X‚ÇÑ),\n      X = mk‚ÇÑ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ :=\n  ‚ü®_, _, _, _, _, X.map' 0 1, X.map' 1 2, X.map' 2 3, X.map' 3 4,\n    ext‚ÇÑ rfl rfl rfl rfl rfl (by simp) (by simp) (by simp) (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÖ_app_zero","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : Quiver.Hom (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ) (CategoryTheory.CategoryStruct.comp app‚ÇÑ (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app 0) app‚ÇÄ","decl":"@[simp]\nlemma homMk‚ÇÖ_app_zero : (homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app 0 = app‚ÇÄ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÖ_app_one","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : Quiver.Hom (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ) (CategoryTheory.CategoryStruct.comp app‚ÇÑ (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app 1) app‚ÇÅ","decl":"@[simp]\nlemma homMk‚ÇÖ_app_one : (homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app 1 = app‚ÇÅ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÖ_app_two","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : Quiver.Hom (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ) (CategoryTheory.CategoryStruct.comp app‚ÇÑ (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®2, ‚ãØ‚ü©) app‚ÇÇ","decl":"@[simp]\nlemma homMk‚ÇÖ_app_two :\n    (homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®2, by valid‚ü© = app‚ÇÇ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÖ_app_three","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : Quiver.Hom (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ) (CategoryTheory.CategoryStruct.comp app‚ÇÑ (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®3, ‚ãØ‚ü©) app‚ÇÉ","decl":"@[simp]\nlemma homMk‚ÇÖ_app_three :\n    (homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®3, by valid‚ü© = app‚ÇÉ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÖ_app_four","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : Quiver.Hom (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ) (CategoryTheory.CategoryStruct.comp app‚ÇÑ (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®4, ‚ãØ‚ü©) app‚ÇÑ","decl":"@[simp]\nlemma homMk‚ÇÖ_app_four :\n    (homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®4, by valid‚ü© = app‚ÇÑ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.homMk‚ÇÖ_app_five","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : Quiver.Hom (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : Quiver.Hom (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : Quiver.Hom (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : Quiver.Hom (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : Quiver.Hom (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : Quiver.Hom (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ) (CategoryTheory.CategoryStruct.comp app‚ÇÄ (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ) (CategoryTheory.CategoryStruct.comp app‚ÇÅ (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ) (CategoryTheory.CategoryStruct.comp app‚ÇÇ (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ) (CategoryTheory.CategoryStruct.comp app‚ÇÉ (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ) (CategoryTheory.CategoryStruct.comp app‚ÇÑ (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®5, ‚ãØ‚ü©) app‚ÇÖ","decl":"@[simp]\nlemma homMk‚ÇÖ_app_five :\n    (homMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).app ‚ü®5, by valid‚ü© = app‚ÇÖ := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÖ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\nœÜ œÜ' : Quiver.Hom f g\nh‚ÇÄ : Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)\nh‚ÇÅ : Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)\nh‚ÇÇ : Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)\nh‚ÇÉ : Eq (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 3 ‚ãØ)\nh‚ÇÑ : Eq (CategoryTheory.ComposableArrows.app' œÜ 4 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 4 ‚ãØ)\nh‚ÇÖ : Eq (CategoryTheory.ComposableArrows.app' œÜ 5 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 5 ‚ãØ)\n‚ä¢ Eq œÜ œÜ'","decl":"@[ext]\nlemma hom_ext‚ÇÖ {f g : ComposableArrows C 5} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2)\n    (h‚ÇÉ : app' œÜ 3 = app' œÜ' 3) (h‚ÇÑ : app' œÜ 4 = app' œÜ' 4) (h‚ÇÖ : app' œÜ 5 = app' œÜ' 5) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÑ h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ h‚ÇÖ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.hom_ext‚ÇÖ_iff","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\nœÜ œÜ' : Quiver.Hom f g\n‚ä¢ Iff (Eq œÜ œÜ') (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 0 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 0 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 1 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 1 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 2 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 2 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 3 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 3 ‚ãØ)) (And (Eq (CategoryTheory.ComposableArrows.app' œÜ 4 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 4 ‚ãØ)) (Eq (CategoryTheory.ComposableArrows.app' œÜ 5 ‚ãØ) (CategoryTheory.ComposableArrows.app' œÜ' 5 ‚ãØ)))))))","decl":"@[ext]\nlemma hom_ext‚ÇÖ {f g : ComposableArrows C 5} {œÜ œÜ' : f ‚ü∂ g}\n    (h‚ÇÄ : app' œÜ 0 = app' œÜ' 0) (h‚ÇÅ : app' œÜ 1 = app' œÜ' 1) (h‚ÇÇ : app' œÜ 2 = app' œÜ' 2)\n    (h‚ÇÉ : app' œÜ 3 = app' œÜ' 3) (h‚ÇÑ : app' œÜ 4 = app' œÜ' 4) (h‚ÇÖ : app' œÜ 5 = app' œÜ' 5) :\n    œÜ = œÜ' :=\n  hom_ext_succ h‚ÇÄ (hom_ext‚ÇÑ h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ h‚ÇÖ)\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÖ_hom","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : CategoryTheory.Iso (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : CategoryTheory.Iso (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : CategoryTheory.Iso (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÇ.hom (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÉ.hom (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÑ.hom (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).hom (CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom app‚ÇÑ.hom app‚ÇÖ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 5`. -/\n@[simps]\ndef isoMk‚ÇÖ {f g : ComposableArrows C 5}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (app‚ÇÉ : f.obj' 3 ‚âÖ g.obj' 3) (app‚ÇÑ : f.obj' 4 ‚âÖ g.obj' 4) (app‚ÇÖ : f.obj' 5 ‚âÖ g.obj' 5)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2)\n    (w‚ÇÇ : f.map' 2 3 ‚â´ app‚ÇÉ.hom = app‚ÇÇ.hom ‚â´ g.map' 2 3)\n    (w‚ÇÉ : f.map' 3 4 ‚â´ app‚ÇÑ.hom = app‚ÇÉ.hom ‚â´ g.map' 3 4)\n    (w‚ÇÑ : f.map' 4 5 ‚â´ app‚ÇÖ.hom = app‚ÇÑ.hom ‚â´ g.map' 4 5) :\n    f ‚âÖ g where\n  hom := homMk‚ÇÖ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom app‚ÇÑ.hom app‚ÇÖ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ\n  inv := homMk‚ÇÖ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv app‚ÇÑ.inv app‚ÇÖ.inv\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÄ app‚ÇÅ w‚ÇÄ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÅ app‚ÇÇ w‚ÇÅ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÇ app‚ÇÉ w‚ÇÇ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÉ app‚ÇÑ w‚ÇÉ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÑ app‚ÇÖ w‚ÇÑ])\n\n"}
{"name":"CategoryTheory.ComposableArrows.isoMk‚ÇÖ_inv","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\napp‚ÇÄ : CategoryTheory.Iso (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\napp‚ÇÅ : CategoryTheory.Iso (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\napp‚ÇÇ : CategoryTheory.Iso (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\napp‚ÇÉ : CategoryTheory.Iso (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\napp‚ÇÑ : CategoryTheory.Iso (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\napp‚ÇÖ : CategoryTheory.Iso (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 0 1 ‚ãØ ‚ãØ) app‚ÇÅ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÄ.hom (g.map' 0 1 ‚ãØ ‚ãØ))\nw‚ÇÅ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 1 2 ‚ãØ ‚ãØ) app‚ÇÇ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÅ.hom (g.map' 1 2 ‚ãØ ‚ãØ))\nw‚ÇÇ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 2 3 ‚ãØ ‚ãØ) app‚ÇÉ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÇ.hom (g.map' 2 3 ‚ãØ ‚ãØ))\nw‚ÇÉ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 3 4 ‚ãØ ‚ãØ) app‚ÇÑ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÉ.hom (g.map' 3 4 ‚ãØ ‚ãØ))\nw‚ÇÑ : Eq (CategoryTheory.CategoryStruct.comp (f.map' 4 5 ‚ãØ ‚ãØ) app‚ÇÖ.hom) (CategoryTheory.CategoryStruct.comp app‚ÇÑ.hom (g.map' 4 5 ‚ãØ ‚ãØ))\n‚ä¢ Eq (CategoryTheory.ComposableArrows.isoMk‚ÇÖ app‚ÇÄ app‚ÇÅ app‚ÇÇ app‚ÇÉ app‚ÇÑ app‚ÇÖ w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ).inv (CategoryTheory.ComposableArrows.homMk‚ÇÖ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv app‚ÇÑ.inv app‚ÇÖ.inv ‚ãØ ‚ãØ ‚ãØ ‚ãØ ‚ãØ)","decl":"/-- Constructor for isomorphisms in `ComposableArrows C 5`. -/\n@[simps]\ndef isoMk‚ÇÖ {f g : ComposableArrows C 5}\n    (app‚ÇÄ : f.obj' 0 ‚âÖ g.obj' 0) (app‚ÇÅ : f.obj' 1 ‚âÖ g.obj' 1) (app‚ÇÇ : f.obj' 2 ‚âÖ g.obj' 2)\n    (app‚ÇÉ : f.obj' 3 ‚âÖ g.obj' 3) (app‚ÇÑ : f.obj' 4 ‚âÖ g.obj' 4) (app‚ÇÖ : f.obj' 5 ‚âÖ g.obj' 5)\n    (w‚ÇÄ : f.map' 0 1 ‚â´ app‚ÇÅ.hom = app‚ÇÄ.hom ‚â´ g.map' 0 1)\n    (w‚ÇÅ : f.map' 1 2 ‚â´ app‚ÇÇ.hom = app‚ÇÅ.hom ‚â´ g.map' 1 2)\n    (w‚ÇÇ : f.map' 2 3 ‚â´ app‚ÇÉ.hom = app‚ÇÇ.hom ‚â´ g.map' 2 3)\n    (w‚ÇÉ : f.map' 3 4 ‚â´ app‚ÇÑ.hom = app‚ÇÉ.hom ‚â´ g.map' 3 4)\n    (w‚ÇÑ : f.map' 4 5 ‚â´ app‚ÇÖ.hom = app‚ÇÑ.hom ‚â´ g.map' 4 5) :\n    f ‚âÖ g where\n  hom := homMk‚ÇÖ app‚ÇÄ.hom app‚ÇÅ.hom app‚ÇÇ.hom app‚ÇÉ.hom app‚ÇÑ.hom app‚ÇÖ.hom w‚ÇÄ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ\n  inv := homMk‚ÇÖ app‚ÇÄ.inv app‚ÇÅ.inv app‚ÇÇ.inv app‚ÇÉ.inv app‚ÇÑ.inv app‚ÇÖ.inv\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÄ app‚ÇÅ w‚ÇÄ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÅ app‚ÇÇ w‚ÇÅ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÇ app‚ÇÉ w‚ÇÇ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÉ app‚ÇÑ w‚ÇÉ])\n    (by rw [map'_inv_eq_inv_map' (by valid) app‚ÇÑ app‚ÇÖ w‚ÇÑ])\n\n"}
{"name":"CategoryTheory.ComposableArrows.ext‚ÇÖ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nf g : CategoryTheory.ComposableArrows C 5\nh‚ÇÄ : Eq (f.obj' 0 ‚ãØ) (g.obj' 0 ‚ãØ)\nh‚ÇÅ : Eq (f.obj' 1 ‚ãØ) (g.obj' 1 ‚ãØ)\nh‚ÇÇ : Eq (f.obj' 2 ‚ãØ) (g.obj' 2 ‚ãØ)\nh‚ÇÉ : Eq (f.obj' 3 ‚ãØ) (g.obj' 3 ‚ãØ)\nh‚ÇÑ : Eq (f.obj' 4 ‚ãØ) (g.obj' 4 ‚ãØ)\nh‚ÇÖ : Eq (f.obj' 5 ‚ãØ) (g.obj' 5 ‚ãØ)\nw‚ÇÄ : Eq (f.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÄ) (CategoryTheory.CategoryStruct.comp (g.map' 0 1 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÅ : Eq (f.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÅ) (CategoryTheory.CategoryStruct.comp (g.map' 1 2 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÇ : Eq (f.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÇ) (CategoryTheory.CategoryStruct.comp (g.map' 2 3 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÉ : Eq (f.map' 3 4 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÉ) (CategoryTheory.CategoryStruct.comp (g.map' 3 4 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\nw‚ÇÑ : Eq (f.map' 4 5 ‚ãØ ‚ãØ) (CategoryTheory.CategoryStruct.comp (CategoryTheory.eqToHom h‚ÇÑ) (CategoryTheory.CategoryStruct.comp (g.map' 4 5 ‚ãØ ‚ãØ) (CategoryTheory.eqToHom ‚ãØ)))\n‚ä¢ Eq f g","decl":"lemma ext‚ÇÖ {f g : ComposableArrows C 5}\n    (h‚ÇÄ : f.obj' 0 = g.obj' 0) (h‚ÇÅ : f.obj' 1 = g.obj' 1) (h‚ÇÇ : f.obj' 2 = g.obj' 2)\n    (h‚ÇÉ : f.obj' 3 = g.obj' 3) (h‚ÇÑ : f.obj' 4 = g.obj' 4) (h‚ÇÖ : f.obj' 5 = g.obj' 5)\n    (w‚ÇÄ : f.map' 0 1 = eqToHom h‚ÇÄ ‚â´ g.map' 0 1 ‚â´ eqToHom h‚ÇÅ.symm)\n    (w‚ÇÅ : f.map' 1 2 = eqToHom h‚ÇÅ ‚â´ g.map' 1 2 ‚â´ eqToHom h‚ÇÇ.symm)\n    (w‚ÇÇ : f.map' 2 3 = eqToHom h‚ÇÇ ‚â´ g.map' 2 3 ‚â´ eqToHom h‚ÇÉ.symm)\n    (w‚ÇÉ : f.map' 3 4 = eqToHom h‚ÇÉ ‚â´ g.map' 3 4 ‚â´ eqToHom h‚ÇÑ.symm)\n    (w‚ÇÑ : f.map' 4 5 = eqToHom h‚ÇÑ ‚â´ g.map' 4 5 ‚â´ eqToHom h‚ÇÖ.symm) :\n    f = g :=\n  ext_succ h‚ÇÄ (ext‚ÇÑ h‚ÇÅ h‚ÇÇ h‚ÇÉ h‚ÇÑ h‚ÇÖ w‚ÇÅ w‚ÇÇ w‚ÇÉ w‚ÇÑ) w‚ÇÄ\n\n"}
{"name":"CategoryTheory.ComposableArrows.mk‚ÇÖ_surjective","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nX : CategoryTheory.ComposableArrows C 5\n‚ä¢ Exists fun X‚ÇÄ => Exists fun X‚ÇÅ => Exists fun X‚ÇÇ => Exists fun X‚ÇÉ => Exists fun X‚ÇÑ => Exists fun X‚ÇÖ => Exists fun f‚ÇÄ => Exists fun f‚ÇÅ => Exists fun f‚ÇÇ => Exists fun f‚ÇÉ => Exists fun f‚ÇÑ => Eq X (CategoryTheory.ComposableArrows.mk‚ÇÖ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ)","decl":"lemma mk‚ÇÖ_surjective (X : ComposableArrows C 5) :\n    ‚àÉ (X‚ÇÄ X‚ÇÅ X‚ÇÇ X‚ÇÉ X‚ÇÑ X‚ÇÖ : C) (f‚ÇÄ : X‚ÇÄ ‚ü∂ X‚ÇÅ) (f‚ÇÅ : X‚ÇÅ ‚ü∂ X‚ÇÇ) (f‚ÇÇ : X‚ÇÇ ‚ü∂ X‚ÇÉ)\n      (f‚ÇÉ : X‚ÇÉ ‚ü∂ X‚ÇÑ) (f‚ÇÑ : X‚ÇÑ ‚ü∂ X‚ÇÖ), X = mk‚ÇÖ f‚ÇÄ f‚ÇÅ f‚ÇÇ f‚ÇÉ f‚ÇÑ :=\n  ‚ü®_, _, _, _, _, _, X.map' 0 1, X.map' 1 2, X.map' 2 3, X.map' 3 4, X.map' 4 5,\n    ext‚ÇÖ rfl rfl rfl rfl rfl rfl (by simp) (by simp) (by simp) (by simp) (by simp)‚ü©\n\n"}
{"name":"CategoryTheory.ComposableArrows.mkOfObjOfMapSucc_exists","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nobj : Fin (HAdd.hAdd n 1) ‚Üí C\nmapSucc : (i : Fin n) ‚Üí Quiver.Hom (obj i.castSucc) (obj i.succ)\n‚ä¢ Exists fun F => Exists fun e => ‚àÄ (i : Nat) (hi : LT.lt i n), Eq (mapSucc ‚ü®i, hi‚ü©) (CategoryTheory.CategoryStruct.comp (e ‚ü®i, ‚ãØ‚ü©).inv (CategoryTheory.CategoryStruct.comp (F.map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (e ‚ü®HAdd.hAdd i 1, ‚ãØ‚ü©).hom))","decl":"lemma mkOfObjOfMapSucc_exists : ‚àÉ (F : ComposableArrows C n) (e : ‚àÄ i, F.obj i ‚âÖ obj i),\n    ‚àÄ (i : ‚Ñï) (hi : i < n), mapSucc ‚ü®i, hi‚ü© =\n      (e ‚ü®i, _‚ü©).inv ‚â´ F.map' i (i + 1) ‚â´ (e ‚ü®i + 1, _‚ü©).hom := by\n  revert obj mapSucc\n  induction' n with n hn\n  ¬∑ intro obj _\n    exact ‚ü®mk‚ÇÄ (obj 0), fun 0 => Iso.refl _, fun i hi => by simp at hi‚ü©\n  ¬∑ intro obj mapSucc\n    obtain ‚ü®F, e, h‚ü© := hn (fun i => obj i.succ) (fun i => mapSucc i.succ)\n    refine ‚ü®F.precomp (mapSucc 0 ‚â´ (e 0).inv), fun i => match i with\n      | 0 => Iso.refl _\n      | ‚ü®i + 1, hi‚ü© => e _, fun i hi => ?_‚ü©\n    obtain _ | i := i\n    ¬∑ dsimp\n      rw [assoc, Iso.inv_hom_id, comp_id]\n      erw [id_comp]\n    ¬∑ exact h i (by valid)\n\n"}
{"name":"CategoryTheory.ComposableArrows.mkOfObjOfMapSucc_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nobj : Fin (HAdd.hAdd n 1) ‚Üí C\nmapSucc : (i : Fin n) ‚Üí Quiver.Hom (obj i.castSucc) (obj i.succ)\ni : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mkOfObjOfMapSucc obj mapSucc).obj i) (obj i)","decl":"@[simp]\nlemma mkOfObjOfMapSucc_obj (i : Fin (n + 1)) :\n    (mkOfObjOfMapSucc obj mapSucc).obj i = obj i := rfl\n\n"}
{"name":"CategoryTheory.ComposableArrows.mkOfObjOfMapSucc_map_succ","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nobj : Fin (HAdd.hAdd n 1) ‚Üí C\nmapSucc : (i : Fin n) ‚Üí Quiver.Hom (obj i.castSucc) (obj i.succ)\ni : Nat\nhi : autoParam (LT.lt i n) _auto‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mkOfObjOfMapSucc obj mapSucc).map' i (HAdd.hAdd i 1) ‚ãØ ‚ãØ) (mapSucc ‚ü®i, hi‚ü©)","decl":"lemma mkOfObjOfMapSucc_map_succ (i : ‚Ñï) (hi : i < n := by valid) :\n    (mkOfObjOfMapSucc obj mapSucc).map' i (i + 1) = mapSucc ‚ü®i, hi‚ü© :=\n  ((mkOfObjOfMapSucc_exists obj mapSucc).choose_spec.choose_spec i hi).symm\n\n"}
{"name":"CategoryTheory.ComposableArrows.mkOfObjOfMapSucc_arrow","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nobj : Fin (HAdd.hAdd n 1) ‚Üí C\nmapSucc : (i : Fin n) ‚Üí Quiver.Hom (obj i.castSucc) (obj i.succ)\ni : Nat\nhi : autoParam (LT.lt i n) _auto‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.mkOfObjOfMapSucc obj mapSucc).arrow i ‚ãØ) (CategoryTheory.ComposableArrows.mk‚ÇÅ (mapSucc ‚ü®i, hi‚ü©))","decl":"lemma mkOfObjOfMapSucc_arrow (i : ‚Ñï) (hi : i < n := by valid) :\n    (mkOfObjOfMapSucc obj mapSucc).arrow i = mk‚ÇÅ (mapSucc ‚ü®i, hi‚ü©) :=\n  ext‚ÇÅ rfl rfl (by simpa using mkOfObjOfMapSucc_map_succ obj mapSucc i hi)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_functor_obj_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX : Opposite (CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C)\nX‚úù Y‚úù : Fin (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.opEquivalence C n).functor.obj X).map f) ((Opposite.unop X).map (‚ãØ.functor.map (CategoryTheory.homOfLE ‚ãØ))).op","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_inverse_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX : CategoryTheory.ComposableArrows (Opposite C) n\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.opEquivalence C n).inverse.obj X) { unop := (‚ãØ.functor.comp (CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).functor).comp (CategoryTheory.Functor.leftOp X) }","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_functor_obj_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù : Opposite (CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C)\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.opEquivalence C n).functor.obj X‚úù).obj X) { unop := (Opposite.unop X‚úù).obj X.rev }","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_unitIso_hom_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX : Opposite (CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.opEquivalence C n).unitIso.hom.app X) (CategoryTheory.CategoryStruct.comp (((CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).symm.trans Fin.revOrderIso.equivalence).symm.funInvIdAssoc (Opposite.unop X)).hom.op (CategoryTheory.whiskerLeft (‚ãØ.functor.comp (CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).functor) (((CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).inverse.comp ‚ãØ.functor).comp (Opposite.unop X)).rightOpLeftOpIso.hom).op)","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_unitIso_inv_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX : Opposite (CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C)\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.opEquivalence C n).unitIso.inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft (‚ãØ.functor.comp (CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).functor) (((CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).inverse.comp ‚ãØ.functor).comp (Opposite.unop X)).rightOpLeftOpIso.inv).op (((CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).symm.trans Fin.revOrderIso.equivalence).symm.funInvIdAssoc (Opposite.unop X)).inv.op)","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_counitIso_hom_app_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù : CategoryTheory.ComposableArrows (Opposite C) n\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.opEquivalence C n).counitIso.hom.app X‚úù).app X) (X‚úù.map (((CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).symm.trans Fin.revOrderIso.equivalence).symm.counitInv.app { unop := X }).unop)","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_inverse_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù Y‚úù : CategoryTheory.ComposableArrows (Opposite C) n\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq ((CategoryTheory.ComposableArrows.opEquivalence C n).inverse.map f) (CategoryTheory.whiskerLeft (‚ãØ.functor.comp (CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).functor) (CategoryTheory.NatTrans.leftOp f)).op","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_counitIso_inv_app_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù : CategoryTheory.ComposableArrows (Opposite C) n\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.opEquivalence C n).counitIso.inv.app X‚úù).app X) (X‚úù.map (((CategoryTheory.orderDualEquivalence (Fin (HAdd.hAdd n 1))).symm.trans Fin.revOrderIso.equivalence).symm.counit.app { unop := X }).unop)","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.ComposableArrows.opEquivalence_functor_map_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù : CategoryTheory.Category.{u_2, u_1} C\nn : Nat\nX‚úù Y‚úù : Opposite (CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C)\nf : Quiver.Hom X‚úù Y‚úù\nx‚úù : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((CategoryTheory.ComposableArrows.opEquivalence C n).functor.map f).app x‚úù) (f.unop.app x‚úù.rev).op","decl":"suppress_compilation in\nvariable (C n) in\n/-- The equivalence `(ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n` obtained\nby reversing the arrows. -/\n@[simps!]\ndef opEquivalence : (ComposableArrows C n)·µí·µñ ‚âå ComposableArrows C·µí·µñ n :=\n  ((orderDualEquivalence (Fin (n + 1))).symm.trans\n      Fin.revOrderIso.equivalence).symm.congrLeft.op.trans\n    (Functor.leftOpRightOpEquiv (Fin (n + 1)) C)\n\n"}
{"name":"CategoryTheory.Functor.mapComposableArrows_obj_map","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nn : Nat\nF : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C\nX‚úù Y‚úù : Fin (HAdd.hAdd n 1)\nf : Quiver.Hom X‚úù Y‚úù\n‚ä¢ Eq (((G.mapComposableArrows n).obj F).map f) (G.map (F.map f))","decl":"/-- The functor `ComposableArrows C n ‚•§ ComposableArrows D n` obtained by postcomposition\nwith a functor `C ‚•§ D`. -/\n@[simps!]\ndef Functor.mapComposableArrows :\n    ComposableArrows C n ‚•§ ComposableArrows D n :=\n  (whiskeringRight _ _ _).obj G\n\n"}
{"name":"CategoryTheory.Functor.mapComposableArrows_obj_obj","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nn : Nat\nF : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((G.mapComposableArrows n).obj F).obj X) (G.obj (F.obj X))","decl":"/-- The functor `ComposableArrows C n ‚•§ ComposableArrows D n` obtained by postcomposition\nwith a functor `C ‚•§ D`. -/\n@[simps!]\ndef Functor.mapComposableArrows :\n    ComposableArrows C n ‚•§ ComposableArrows D n :=\n  (whiskeringRight _ _ _).obj G\n\n"}
{"name":"CategoryTheory.Functor.mapComposableArrows_map_app","module":"Mathlib.CategoryTheory.ComposableArrows","initialProofState":"C : Type u_1\ninst‚úù¬π : CategoryTheory.Category.{u_3, u_1} C\nD : Type u_2\ninst‚úù : CategoryTheory.Category.{u_4, u_2} D\nG : CategoryTheory.Functor C D\nn : Nat\nX‚úù Y‚úù : CategoryTheory.Functor (Fin (HAdd.hAdd n 1)) C\nŒ± : Quiver.Hom X‚úù Y‚úù\nX : Fin (HAdd.hAdd n 1)\n‚ä¢ Eq (((G.mapComposableArrows n).map Œ±).app X) (G.map (Œ±.app X))","decl":"/-- The functor `ComposableArrows C n ‚•§ ComposableArrows D n` obtained by postcomposition\nwith a functor `C ‚•§ D`. -/\n@[simps!]\ndef Functor.mapComposableArrows :\n    ComposableArrows C n ‚•§ ComposableArrows D n :=\n  (whiskeringRight _ _ _).obj G\n\n"}
