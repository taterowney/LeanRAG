{"name":"dNext_eq_dFrom_fromNext","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ni : ι\n⊢ Eq ((dNext i) f) (CategoryTheory.CategoryStruct.comp (C.dFrom i) ((fromNext i) f))","decl":"@[simp]\ntheorem dNext_eq_dFrom_fromNext (f : ∀ i j, C.X i ⟶ D.X j) (i : ι) :\n    dNext i f = C.dFrom i ≫ fromNext i f :=\n  rfl\n\n"}
{"name":"dNext_eq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ni i' : ι\nw : c.Rel i i'\n⊢ Eq ((dNext i) f) (CategoryTheory.CategoryStruct.comp (C.d i i') (f i' i))","decl":"theorem dNext_eq (f : ∀ i j, C.X i ⟶ D.X j) {i i' : ι} (w : c.Rel i i') :\n    dNext i f = C.d i i' ≫ f i' i := by\n  obtain rfl := c.next_eq' w\n  rfl\n\n"}
{"name":"dNext_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ni : ι\nhi : Not (c.Rel i (c.next i))\n⊢ Eq ((dNext i) f) 0","decl":"lemma dNext_eq_zero (f : ∀ i j, C.X i ⟶ D.X j) (i : ι) (hi : ¬ c.Rel i (c.next i)) :\n    dNext i f = 0 := by\n  dsimp [dNext]\n  rw [shape _ _ _ hi, zero_comp]\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"dNext_comp_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\ng : (i j : ι) → Quiver.Hom (D.X i) (E.X j)\ni : ι\n⊢ Eq ((dNext i) fun i j => CategoryTheory.CategoryStruct.comp (f.f i) (g i j)) (CategoryTheory.CategoryStruct.comp (f.f i) ((dNext i) g))","decl":"theorem dNext_comp_left (f : C ⟶ D) (g : ∀ i j, D.X i ⟶ E.X j) (i : ι) :\n    (dNext i fun i j => f.f i ≫ g i j) = f.f i ≫ dNext i g :=\n  (f.comm_assoc _ _ _).symm\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"dNext_comp_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\ni : ι\n⊢ Eq ((dNext i) fun i j => CategoryTheory.CategoryStruct.comp (f i j) (g.f j)) (CategoryTheory.CategoryStruct.comp ((dNext i) f) (g.f i))","decl":"theorem dNext_comp_right (f : ∀ i j, C.X i ⟶ D.X j) (g : D ⟶ E) (i : ι) :\n    (dNext i fun i j => f i j ≫ g.f j) = dNext i f ≫ g.f i :=\n  (assoc _ _ _).symm\n\n"}
{"name":"prevD_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ni : ι\nhi : Not (c.Rel (c.prev i) i)\n⊢ Eq ((prevD i) f) 0","decl":"lemma prevD_eq_zero (f : ∀ i j, C.X i ⟶ D.X j) (i : ι) (hi : ¬ c.Rel (c.prev i) i) :\n    prevD i f = 0 := by\n  dsimp [prevD]\n  rw [shape _ _ _ hi, comp_zero]\n\n"}
{"name":"prevD_eq_toPrev_dTo","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nj : ι\n⊢ Eq ((prevD j) f) (CategoryTheory.CategoryStruct.comp ((toPrev j) f) (D.dTo j))","decl":"@[simp]\ntheorem prevD_eq_toPrev_dTo (f : ∀ i j, C.X i ⟶ D.X j) (j : ι) :\n    prevD j f = toPrev j f ≫ D.dTo j :=\n  rfl\n\n"}
{"name":"prevD_eq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nj j' : ι\nw : c.Rel j' j\n⊢ Eq ((prevD j) f) (CategoryTheory.CategoryStruct.comp (f j j') (D.d j' j))","decl":"theorem prevD_eq (f : ∀ i j, C.X i ⟶ D.X j) {j j' : ι} (w : c.Rel j' j) :\n    prevD j f = f j j' ≫ D.d j' j := by\n  obtain rfl := c.prev_eq' w\n  rfl\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"prevD_comp_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\ng : (i j : ι) → Quiver.Hom (D.X i) (E.X j)\nj : ι\n⊢ Eq ((prevD j) fun i j => CategoryTheory.CategoryStruct.comp (f.f i) (g i j)) (CategoryTheory.CategoryStruct.comp (f.f j) ((prevD j) g))","decl":"theorem prevD_comp_left (f : C ⟶ D) (g : ∀ i j, D.X i ⟶ E.X j) (j : ι) :\n    (prevD j fun i j => f.f i ≫ g i j) = f.f j ≫ prevD j g :=\n  assoc _ _ _\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"prevD_comp_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\nj : ι\n⊢ Eq ((prevD j) fun i j => CategoryTheory.CategoryStruct.comp (f i j) (g.f j)) (CategoryTheory.CategoryStruct.comp ((prevD j) f) (g.f j))","decl":"theorem prevD_comp_right (f : ∀ i j, C.X i ⟶ D.X j) (g : D ⟶ E) (j : ι) :\n    (prevD j fun i j => f i j ≫ g.f j) = prevD j f ≫ g.f j := by\n  dsimp [prevD]\n  simp only [assoc, g.comm]\n\n"}
{"name":"dNext_nat","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nC D : ChainComplex V Nat\ni : Nat\nf : (i j : Nat) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((dNext i) f) (CategoryTheory.CategoryStruct.comp (C.d i (HSub.hSub i 1)) (f (HSub.hSub i 1) i))","decl":"theorem dNext_nat (C D : ChainComplex V ℕ) (i : ℕ) (f : ∀ i j, C.X i ⟶ D.X j) :\n    dNext i f = C.d i (i - 1) ≫ f (i - 1) i := by\n  dsimp [dNext]\n  cases i\n  · simp only [shape, ChainComplex.next_nat_zero, ComplexShape.down_Rel, Nat.one_ne_zero,\n      not_false_iff, zero_comp, reduceCtorEq]\n  · congr <;> simp\n\n"}
{"name":"prevD_nat","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nC D : CochainComplex V Nat\ni : Nat\nf : (i j : Nat) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((prevD i) f) (CategoryTheory.CategoryStruct.comp (f i (HSub.hSub i 1)) (D.d (HSub.hSub i 1) i))","decl":"theorem prevD_nat (C D : CochainComplex V ℕ) (i : ℕ) (f : ∀ i j, C.X i ⟶ D.X j) :\n    prevD i f = f i (i - 1) ≫ D.d (i - 1) i := by\n  dsimp [prevD]\n  cases i\n  · simp only [shape, CochainComplex.prev_nat_zero, ComplexShape.up_Rel, Nat.one_ne_zero,\n      not_false_iff, comp_zero, reduceCtorEq]\n  · congr <;> simp\n\n"}
{"name":"Homotopy.mk.injEq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nhom✝ : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nzero✝ : autoParam (∀ (i j : ι), Not (c.Rel j i) → Eq (hom✝ i j) 0) _auto✝\ncomm✝ : autoParam (∀ (i : ι), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom✝) ((prevD i) hom✝)) (g.f i))) _auto✝\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nzero : autoParam (∀ (i j : ι), Not (c.Rel j i) → Eq (hom i j) 0) _auto✝\ncomm : autoParam (∀ (i : ι), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom) ((prevD i) hom)) (g.f i))) _auto✝\n⊢ Eq (Eq { hom := hom✝, zero := zero✝, comm := comm✝ } { hom := hom, zero := zero, comm := comm }) (Eq hom✝ hom)","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.comm","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nself : Homotopy f g\ni : ι\n⊢ Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) self.hom) ((prevD i) self.hom)) (g.f i))","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nself : Homotopy f g\ni j : ι\na✝ : Not (c.Rel j i)\n⊢ Eq (self.hom i j) 0","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.mk.inj","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nhom✝ : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nzero✝ : autoParam (∀ (i j : ι), Not (c.Rel j i) → Eq (hom✝ i j) 0) _auto✝\ncomm✝ : autoParam (∀ (i : ι), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom✝) ((prevD i) hom✝)) (g.f i))) _auto✝\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nzero : autoParam (∀ (i j : ι), Not (c.Rel j i) → Eq (hom i j) 0) _auto✝\ncomm : autoParam (∀ (i : ι), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom) ((prevD i) hom)) (g.f i))) _auto✝\nx✝ : Eq { hom := hom✝, zero := zero✝, comm := comm✝ } { hom := hom, zero := zero, comm := comm }\n⊢ Eq hom✝ hom","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.ext_iff","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nx y : Homotopy f g\n⊢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.ext","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nx y : Homotopy f g\nhom : Eq x.hom y.hom\n⊢ Eq x y","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf V\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nzero : autoParam (∀ (i j : ι), Not (c.Rel j i) → Eq (hom i j) 0) _auto✝\ncomm : autoParam (∀ (i : ι), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom) ((prevD i) hom)) (g.f i))) _auto✝\n⊢ Eq (SizeOf.sizeOf { hom := hom, zero := zero, comm := comm }) 1","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ⟶ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ⟶ D) where\n  hom : ∀ i j, C.X i ⟶ D.X j\n  zero : ∀ i j, ¬c.Rel j i → hom i j = 0 := by aesop_cat\n  comm : ∀ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.ofEq_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : Eq f g\ni j : ι\n⊢ Eq ((Homotopy.ofEq h).hom i j) (0 i j)","decl":"/-- Equal chain maps are homotopic. -/\n@[simps]\ndef ofEq (h : f = g) : Homotopy f g where\n  hom := 0\n  zero _ _ _ := rfl\n\n"}
{"name":"Homotopy.refl_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : Quiver.Hom C D\ni j : ι\n⊢ Eq ((Homotopy.refl f).hom i j) 0","decl":"/-- Every chain map is homotopic to itself. -/\n@[simps!, refl]\ndef refl (f : C ⟶ D) : Homotopy f f :=\n  ofEq (rfl : f = f)\n\n"}
{"name":"Homotopy.symm_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : Homotopy f g\ni j : ι\n⊢ Eq (h.symm.hom i j) (Neg.neg (h.hom i j))","decl":"/-- `f` is homotopic to `g` iff `g` is homotopic to `f`. -/\n@[simps!, symm]\ndef symm {f g : C ⟶ D} (h : Homotopy f g) : Homotopy g f where\n  hom := -h.hom\n  zero i j w := by rw [Pi.neg_apply, Pi.neg_apply, h.zero i j w, neg_zero]\n  comm i := by\n    rw [AddMonoidHom.map_neg, AddMonoidHom.map_neg, h.comm, ← neg_add, ← add_assoc, neg_add_cancel,\n      zero_add]\n\n"}
{"name":"Homotopy.trans_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\ne f g : Quiver.Hom C D\nh : Homotopy e f\nk : Homotopy f g\ni j : ι\n⊢ Eq ((h.trans k).hom i j) (HAdd.hAdd (h.hom i j) (k.hom i j))","decl":"/-- homotopy is a transitive relation. -/\n@[simps!, trans]\ndef trans {e f g : C ⟶ D} (h : Homotopy e f) (k : Homotopy f g) : Homotopy e g where\n  hom := h.hom + k.hom\n  zero i j w := by rw [Pi.add_apply, Pi.add_apply, h.zero i j w, k.zero i j w, zero_add]\n  comm i := by\n    rw [AddMonoidHom.map_add, AddMonoidHom.map_add, h.comm, k.comm]\n    abel\n\n"}
{"name":"Homotopy.add_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf₁ g₁ f₂ g₂ : Quiver.Hom C D\nh₁ : Homotopy f₁ g₁\nh₂ : Homotopy f₂ g₂\ni j : ι\n⊢ Eq ((h₁.add h₂).hom i j) (HAdd.hAdd (h₁.hom i j) (h₂.hom i j))","decl":"/-- the sum of two homotopies is a homotopy between the sum of the respective morphisms. -/\n@[simps!]\ndef add {f₁ g₁ f₂ g₂ : C ⟶ D} (h₁ : Homotopy f₁ g₁) (h₂ : Homotopy f₂ g₂) :\n    Homotopy (f₁ + f₂) (g₁ + g₂) where\n  hom := h₁.hom + h₂.hom\n  zero i j hij := by rw [Pi.add_apply, Pi.add_apply, h₁.zero i j hij, h₂.zero i j hij, add_zero]\n  comm i := by\n    simp only [HomologicalComplex.add_f_apply, h₁.comm, h₂.comm, AddMonoidHom.map_add]\n    abel\n\n"}
{"name":"Homotopy.smul_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nR : Type u_2\ninst✝¹ : Semiring R\ninst✝ : CategoryTheory.Linear R V\nh : Homotopy f g\na : R\ni j : ι\n⊢ Eq ((h.smul a).hom i j) (HSMul.hSMul a (h.hom i j))","decl":"/-- the scalar multiplication of an homotopy -/\n@[simps!]\ndef smul {R : Type*} [Semiring R] [Linear R V] (h : Homotopy f g) (a : R) :\n    Homotopy (a • f) (a • g) where\n  hom i j := a • h.hom i j\n  zero i j hij := by\n    dsimp\n    rw [h.zero i j hij, smul_zero]\n  comm i := by\n    dsimp\n    rw [h.comm]\n    dsimp [fromNext, toPrev]\n    simp only [smul_add, Linear.comp_smul, Linear.smul_comp]\n\n"}
{"name":"Homotopy.compRight_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\ne f : Quiver.Hom C D\nh : Homotopy e f\ng : Quiver.Hom D E\ni j : ι\n⊢ Eq ((h.compRight g).hom i j) (CategoryTheory.CategoryStruct.comp (h.hom i j) (g.f j))","decl":"/-- homotopy is closed under composition (on the right) -/\n@[simps]\ndef compRight {e f : C ⟶ D} (h : Homotopy e f) (g : D ⟶ E) : Homotopy (e ≫ g) (f ≫ g) where\n  hom i j := h.hom i j ≫ g.f j\n  zero i j w := by dsimp; rw [h.zero i j w, zero_comp]\n  comm i := by rw [comp_f, h.comm i, dNext_comp_right, prevD_comp_right, Preadditive.add_comp,\n    comp_f, Preadditive.add_comp]\n\n"}
{"name":"Homotopy.compLeft_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf g : Quiver.Hom D E\nh : Homotopy f g\ne : Quiver.Hom C D\ni j : ι\n⊢ Eq ((h.compLeft e).hom i j) (CategoryTheory.CategoryStruct.comp (e.f i) (h.hom i j))","decl":"/-- homotopy is closed under composition (on the left) -/\n@[simps]\ndef compLeft {f g : D ⟶ E} (h : Homotopy f g) (e : C ⟶ D) : Homotopy (e ≫ f) (e ≫ g) where\n  hom i j := e.f i ≫ h.hom i j\n  zero i j w := by dsimp; rw [h.zero i j w, comp_zero]\n  comm i := by rw [comp_f, h.comm i, dNext_comp_left, prevD_comp_left, comp_f,\n    Preadditive.comp_add, Preadditive.comp_add]\n\n"}
{"name":"Homotopy.comp_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC₁ C₂ C₃ : HomologicalComplex V c\nf₁ g₁ : Quiver.Hom C₁ C₂\nf₂ g₂ : Quiver.Hom C₂ C₃\nh₁ : Homotopy f₁ g₁\nh₂ : Homotopy f₂ g₂\ni j : ι\n⊢ Eq ((h₁.comp h₂).hom i j) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (h₁.hom i j) (f₂.f j)) (CategoryTheory.CategoryStruct.comp (g₁.f i) (h₂.hom i j)))","decl":"/-- homotopy is closed under composition -/\n@[simps!]\ndef comp {C₁ C₂ C₃ : HomologicalComplex V c} {f₁ g₁ : C₁ ⟶ C₂} {f₂ g₂ : C₂ ⟶ C₃}\n    (h₁ : Homotopy f₁ g₁) (h₂ : Homotopy f₂ g₂) : Homotopy (f₁ ≫ f₂) (g₁ ≫ g₂) :=\n  (h₁.compRight _).trans (h₂.compLeft _)\n\n"}
{"name":"Homotopy.compRightId_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : Quiver.Hom C C\nh : Homotopy f (CategoryTheory.CategoryStruct.id C)\ng : Quiver.Hom C D\ni j : ι\n⊢ Eq ((h.compRightId g).hom i j) (CategoryTheory.CategoryStruct.comp (h.hom i j) (g.f j))","decl":"/-- a variant of `Homotopy.compRight` useful for dealing with homotopy equivalences. -/\n@[simps!]\ndef compRightId {f : C ⟶ C} (h : Homotopy f (𝟙 C)) (g : C ⟶ D) : Homotopy (f ≫ g) g :=\n  (h.compRight g).trans (ofEq <| id_comp _)\n\n"}
{"name":"Homotopy.compLeftId_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nf : Quiver.Hom D D\nh : Homotopy f (CategoryTheory.CategoryStruct.id D)\ng : Quiver.Hom C D\ni j : ι\n⊢ Eq ((h.compLeftId g).hom i j) (CategoryTheory.CategoryStruct.comp (g.f i) (h.hom i j))","decl":"/-- a variant of `Homotopy.compLeft` useful for dealing with homotopy equivalences. -/\n@[simps!]\ndef compLeftId {f : D ⟶ D} (h : Homotopy f (𝟙 D)) (g : C ⟶ D) : Homotopy (g ≫ f) g :=\n  (h.compLeft g).trans (ofEq <| comp_id _)\n\n"}
{"name":"Homotopy.nullHomotopicMap_comp","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Homotopy.nullHomotopicMap hom) g) (Homotopy.nullHomotopicMap fun i j => CategoryTheory.CategoryStruct.comp (hom i j) (g.f j))","decl":"/-- Compatibility of `nullHomotopicMap` with the postcomposition by a morphism\nof complexes. -/\ntheorem nullHomotopicMap_comp (hom : ∀ i j, C.X i ⟶ D.X j) (g : D ⟶ E) :\n    nullHomotopicMap hom ≫ g = nullHomotopicMap fun i j => hom i j ≫ g.f j := by\n  ext n\n  dsimp [nullHomotopicMap, fromNext, toPrev, AddMonoidHom.mk'_apply]\n  simp only [Preadditive.add_comp, assoc, g.comm]\n\n"}
{"name":"Homotopy.nullHomotopicMap'_comp","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nhom : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\n⊢ Eq (CategoryTheory.CategoryStruct.comp (Homotopy.nullHomotopicMap' hom) g) (Homotopy.nullHomotopicMap' fun i j hij => CategoryTheory.CategoryStruct.comp (hom i j hij) (g.f j))","decl":"/-- Compatibility of `nullHomotopicMap'` with the postcomposition by a morphism\nof complexes. -/\ntheorem nullHomotopicMap'_comp (hom : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) (g : D ⟶ E) :\n    nullHomotopicMap' hom ≫ g = nullHomotopicMap' fun i j hij => hom i j hij ≫ g.f j := by\n  ext n\n  erw [nullHomotopicMap_comp]\n  congr\n  ext i j\n  split_ifs\n  · rfl\n  · rw [zero_comp]\n\n"}
{"name":"Homotopy.comp_nullHomotopicMap","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\nhom : (i j : ι) → Quiver.Hom (D.X i) (E.X j)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (Homotopy.nullHomotopicMap hom)) (Homotopy.nullHomotopicMap fun i j => CategoryTheory.CategoryStruct.comp (f.f i) (hom i j))","decl":"/-- Compatibility of `nullHomotopicMap` with the precomposition by a morphism\nof complexes. -/\ntheorem comp_nullHomotopicMap (f : C ⟶ D) (hom : ∀ i j, D.X i ⟶ E.X j) :\n    f ≫ nullHomotopicMap hom = nullHomotopicMap fun i j => f.f i ≫ hom i j := by\n  ext n\n  dsimp [nullHomotopicMap, fromNext, toPrev, AddMonoidHom.mk'_apply]\n  simp only [Preadditive.comp_add, assoc, f.comm_assoc]\n\n"}
{"name":"Homotopy.comp_nullHomotopicMap'","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\nhom : (i j : ι) → c.Rel j i → Quiver.Hom (D.X i) (E.X j)\n⊢ Eq (CategoryTheory.CategoryStruct.comp f (Homotopy.nullHomotopicMap' hom)) (Homotopy.nullHomotopicMap' fun i j hij => CategoryTheory.CategoryStruct.comp (f.f i) (hom i j hij))","decl":"/-- Compatibility of `nullHomotopicMap'` with the precomposition by a morphism\nof complexes. -/\ntheorem comp_nullHomotopicMap' (f : C ⟶ D) (hom : ∀ i j, c.Rel j i → (D.X i ⟶ E.X j)) :\n    f ≫ nullHomotopicMap' hom = nullHomotopicMap' fun i j hij => f.f i ≫ hom i j hij := by\n  ext n\n  erw [comp_nullHomotopicMap]\n  congr\n  ext i j\n  split_ifs\n  · rfl\n  · rw [comp_zero]\n\n"}
{"name":"Homotopy.map_nullHomotopicMap","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nG : CategoryTheory.Functor V W\ninst✝ : G.Additive\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((G.mapHomologicalComplex c).map (Homotopy.nullHomotopicMap hom)) (Homotopy.nullHomotopicMap fun i j => G.map (hom i j))","decl":"/-- Compatibility of `nullHomotopicMap` with the application of additive functors -/\ntheorem map_nullHomotopicMap {W : Type*} [Category W] [Preadditive W] (G : V ⥤ W) [G.Additive]\n    (hom : ∀ i j, C.X i ⟶ D.X j) :\n    (G.mapHomologicalComplex c).map (nullHomotopicMap hom) =\n      nullHomotopicMap (fun i j => by exact G.map (hom i j)) := by\n  ext i\n  dsimp [nullHomotopicMap, dNext, prevD]\n  simp only [G.map_comp, Functor.map_add]\n\n"}
{"name":"Homotopy.map_nullHomotopicMap'","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nG : CategoryTheory.Functor V W\ninst✝ : G.Additive\nhom : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((G.mapHomologicalComplex c).map (Homotopy.nullHomotopicMap' hom)) (Homotopy.nullHomotopicMap' fun i j hij => G.map (hom i j hij))","decl":"/-- Compatibility of `nullHomotopicMap'` with the application of additive functors -/\ntheorem map_nullHomotopicMap' {W : Type*} [Category W] [Preadditive W] (G : V ⥤ W) [G.Additive]\n    (hom : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) :\n    (G.mapHomologicalComplex c).map (nullHomotopicMap' hom) =\n      nullHomotopicMap' fun i j hij => by exact G.map (hom i j hij) := by\n  ext n\n  erw [map_nullHomotopicMap]\n  congr\n  ext i j\n  split_ifs\n  · rfl\n  · rw [G.map_zero]\n\n"}
{"name":"Homotopy.nullHomotopy_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\nzero : ∀ (i j : ι), Not (c.Rel j i) → Eq (hom i j) 0\ni j : ι\n⊢ Eq ((Homotopy.nullHomotopy hom zero).hom i j) (hom i j)","decl":"/-- Tautological construction of the `Homotopy` to zero for maps constructed by\n`nullHomotopicMap`, at least when we have the `zero` condition. -/\n@[simps]\ndef nullHomotopy (hom : ∀ i j, C.X i ⟶ D.X j) (zero : ∀ i j, ¬c.Rel j i → hom i j = 0) :\n    Homotopy (nullHomotopicMap hom) 0 :=\n  { hom := hom\n    zero := zero\n    comm := by\n      intro i\n      rw [HomologicalComplex.zero_f_apply, add_zero]\n      rfl }\n\n"}
{"name":"Homotopy.nullHomotopy'_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nh : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\ni j : ι\n⊢ Eq ((Homotopy.nullHomotopy' h).hom i j) (dite (c.Rel j i) (h i j) fun x => 0)","decl":"open Classical in\n/-- Homotopy to zero for maps constructed with `nullHomotopicMap'` -/\n@[simps!]\ndef nullHomotopy' (h : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) : Homotopy (nullHomotopicMap' h) 0 := by\n  apply nullHomotopy fun i j => dite (c.Rel j i) (h i j) fun _ => 0\n  intro i j hij\n  rw [dite_eq_right_iff]\n  intro hij'\n  exfalso\n  exact hij hij'\n\n"}
{"name":"Homotopy.nullHomotopicMap_f","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₂ k₁ k₀ : ι\nr₂₁ : c.Rel k₂ k₁\nr₁₀ : c.Rel k₁ k₀\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap hom).f k₁) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (C.d k₁ k₀) (hom k₀ k₁)) (CategoryTheory.CategoryStruct.comp (hom k₁ k₂) (D.d k₂ k₁)))","decl":"@[simp]\ntheorem nullHomotopicMap_f {k₂ k₁ k₀ : ι} (r₂₁ : c.Rel k₂ k₁) (r₁₀ : c.Rel k₁ k₀)\n    (hom : ∀ i j, C.X i ⟶ D.X j) :\n    (nullHomotopicMap hom).f k₁ = C.d k₁ k₀ ≫ hom k₀ k₁ + hom k₁ k₂ ≫ D.d k₂ k₁ := by\n  dsimp only [nullHomotopicMap]\n  rw [dNext_eq hom r₁₀, prevD_eq hom r₂₁]\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₂ k₁ k₀ : ι\nr₂₁ : c.Rel k₂ k₁\nr₁₀ : c.Rel k₁ k₀\nh : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap' h).f k₁) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (C.d k₁ k₀) (h k₀ k₁ r₁₀)) (CategoryTheory.CategoryStruct.comp (h k₁ k₂ r₂₁) (D.d k₂ k₁)))","decl":"@[simp]\ntheorem nullHomotopicMap'_f {k₂ k₁ k₀ : ι} (r₂₁ : c.Rel k₂ k₁) (r₁₀ : c.Rel k₁ k₀)\n    (h : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) :\n    (nullHomotopicMap' h).f k₁ = C.d k₁ k₀ ≫ h k₀ k₁ r₁₀ + h k₁ k₂ r₂₁ ≫ D.d k₂ k₁ := by\n  simp only [nullHomotopicMap']\n  rw [nullHomotopicMap_f r₂₁ r₁₀]\n  split_ifs\n  rfl\n\n"}
{"name":"Homotopy.nullHomotopicMap_f_of_not_rel_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₁ k₀ : ι\nr₁₀ : c.Rel k₁ k₀\nhk₀ : ∀ (l : ι), Not (c.Rel k₀ l)\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap hom).f k₀) (CategoryTheory.CategoryStruct.comp (hom k₀ k₁) (D.d k₁ k₀))","decl":"@[simp]\ntheorem nullHomotopicMap_f_of_not_rel_left {k₁ k₀ : ι} (r₁₀ : c.Rel k₁ k₀)\n    (hk₀ : ∀ l : ι, ¬c.Rel k₀ l) (hom : ∀ i j, C.X i ⟶ D.X j) :\n    (nullHomotopicMap hom).f k₀ = hom k₀ k₁ ≫ D.d k₁ k₀ := by\n  dsimp only [nullHomotopicMap]\n  rw [prevD_eq hom r₁₀, dNext, AddMonoidHom.mk'_apply, C.shape, zero_comp, zero_add]\n  exact hk₀ _\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f_of_not_rel_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₁ k₀ : ι\nr₁₀ : c.Rel k₁ k₀\nhk₀ : ∀ (l : ι), Not (c.Rel k₀ l)\nh : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap' h).f k₀) (CategoryTheory.CategoryStruct.comp (h k₀ k₁ r₁₀) (D.d k₁ k₀))","decl":"@[simp]\ntheorem nullHomotopicMap'_f_of_not_rel_left {k₁ k₀ : ι} (r₁₀ : c.Rel k₁ k₀)\n    (hk₀ : ∀ l : ι, ¬c.Rel k₀ l) (h : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) :\n    (nullHomotopicMap' h).f k₀ = h k₀ k₁ r₁₀ ≫ D.d k₁ k₀ := by\n  simp only [nullHomotopicMap']\n  rw [nullHomotopicMap_f_of_not_rel_left r₁₀ hk₀]\n  split_ifs\n  rfl\n\n"}
{"name":"Homotopy.nullHomotopicMap_f_of_not_rel_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₁ k₀ : ι\nr₁₀ : c.Rel k₁ k₀\nhk₁ : ∀ (l : ι), Not (c.Rel l k₁)\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap hom).f k₁) (CategoryTheory.CategoryStruct.comp (C.d k₁ k₀) (hom k₀ k₁))","decl":"@[simp]\ntheorem nullHomotopicMap_f_of_not_rel_right {k₁ k₀ : ι} (r₁₀ : c.Rel k₁ k₀)\n    (hk₁ : ∀ l : ι, ¬c.Rel l k₁) (hom : ∀ i j, C.X i ⟶ D.X j) :\n    (nullHomotopicMap hom).f k₁ = C.d k₁ k₀ ≫ hom k₀ k₁ := by\n  dsimp only [nullHomotopicMap]\n  rw [dNext_eq hom r₁₀, prevD, AddMonoidHom.mk'_apply, D.shape, comp_zero, add_zero]\n  exact hk₁ _\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f_of_not_rel_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₁ k₀ : ι\nr₁₀ : c.Rel k₁ k₀\nhk₁ : ∀ (l : ι), Not (c.Rel l k₁)\nh : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap' h).f k₁) (CategoryTheory.CategoryStruct.comp (C.d k₁ k₀) (h k₀ k₁ r₁₀))","decl":"@[simp]\ntheorem nullHomotopicMap'_f_of_not_rel_right {k₁ k₀ : ι} (r₁₀ : c.Rel k₁ k₀)\n    (hk₁ : ∀ l : ι, ¬c.Rel l k₁) (h : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) :\n    (nullHomotopicMap' h).f k₁ = C.d k₁ k₀ ≫ h k₀ k₁ r₁₀ := by\n  simp only [nullHomotopicMap']\n  rw [nullHomotopicMap_f_of_not_rel_right r₁₀ hk₁]\n  split_ifs\n  rfl\n\n"}
{"name":"Homotopy.nullHomotopicMap_f_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₀ : ι\nhk₀ : ∀ (l : ι), Not (c.Rel k₀ l)\nhk₀' : ∀ (l : ι), Not (c.Rel l k₀)\nhom : (i j : ι) → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap hom).f k₀) 0","decl":"@[simp]\ntheorem nullHomotopicMap_f_eq_zero {k₀ : ι} (hk₀ : ∀ l : ι, ¬c.Rel k₀ l)\n    (hk₀' : ∀ l : ι, ¬c.Rel l k₀) (hom : ∀ i j, C.X i ⟶ D.X j) :\n    (nullHomotopicMap hom).f k₀ = 0 := by\n  dsimp [nullHomotopicMap, dNext, prevD]\n  rw [C.shape, D.shape, zero_comp, comp_zero, add_zero] <;> apply_assumption\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nk₀ : ι\nhk₀ : ∀ (l : ι), Not (c.Rel k₀ l)\nhk₀' : ∀ (l : ι), Not (c.Rel l k₀)\nh : (i j : ι) → c.Rel j i → Quiver.Hom (C.X i) (D.X j)\n⊢ Eq ((Homotopy.nullHomotopicMap' h).f k₀) 0","decl":"@[simp]\ntheorem nullHomotopicMap'_f_eq_zero {k₀ : ι} (hk₀ : ∀ l : ι, ¬c.Rel k₀ l)\n    (hk₀' : ∀ l : ι, ¬c.Rel l k₀) (h : ∀ i j, c.Rel j i → (C.X i ⟶ D.X j)) :\n    (nullHomotopicMap' h).f k₀ = 0 := by\n  simp only [nullHomotopicMap']\n  apply nullHomotopicMap_f_eq_zero hk₀ hk₀'\n\n"}
{"name":"Homotopy.prevD_chainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\nf : (i j : Nat) → Quiver.Hom (P.X i) (Q.X j)\nj : Nat\n⊢ Eq ((prevD j) f) (CategoryTheory.CategoryStruct.comp (f j (HAdd.hAdd j 1)) (Q.d (HAdd.hAdd j 1) j))","decl":"theorem prevD_chainComplex (f : ∀ i j, P.X i ⟶ Q.X j) (j : ℕ) :\n    prevD j f = f j (j + 1) ≫ Q.d _ _ := by\n  dsimp [prevD]\n  have : (ComplexShape.down ℕ).prev j = j + 1 := ChainComplex.prev ℕ j\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.dNext_succ_chainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\nf : (i j : Nat) → Quiver.Hom (P.X i) (Q.X j)\ni : Nat\n⊢ Eq ((dNext (HAdd.hAdd i 1)) f) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd i 1) i) (f i (HAdd.hAdd i 1)))","decl":"theorem dNext_succ_chainComplex (f : ∀ i j, P.X i ⟶ Q.X j) (i : ℕ) :\n    dNext (i + 1) f = P.d _ _ ≫ f i (i + 1) := by\n  dsimp [dNext]\n  have : (ComplexShape.down ℕ).next (i + 1) = i := ChainComplex.next_nat_succ _\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.dNext_zero_chainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\nf : (i j : Nat) → Quiver.Hom (P.X i) (Q.X j)\n⊢ Eq ((dNext 0) f) 0","decl":"theorem dNext_zero_chainComplex (f : ∀ i j, P.X i ⟶ Q.X j) : dNext 0 f = 0 := by\n  dsimp [dNext]\n  rw [P.shape, zero_comp]\n  rw [ChainComplex.next_nat_zero]; dsimp; decide\n\n"}
{"name":"Homotopy.mkInductiveAux₃","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\ni j : Nat\nh : Eq (HAdd.hAdd i 1) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (P.X i) (HomologicalComplex.xPrev Q i)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 509).num 4).num 509).num 62).num 4).num 62).str \"_sorry\").str \"_@\").str \"_hyg\").num 7021))) (HomologicalComplex.xPrevIso Q h).hom) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.xNextIso P h).inv (sorryAx (Unit → Quiver.Hom (HomologicalComplex.xNext P j) (Q.X j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 510).num 27).num 510).num 83).num 27).num 83).str \"_sorry\").str \"_@\").str \"_hyg\").num 7039))))","decl":"theorem mkInductiveAux₃ (i j : ℕ) (h : i + 1 = j) :\n    (mkInductiveAux₂ e zero comm_zero one comm_one succ i).2.1 ≫ (Q.xPrevIso h).hom =\n      (P.xNextIso h).inv ≫ (mkInductiveAux₂ e zero comm_zero one comm_one succ j).1 := by\n  subst j\n  rcases i with (_ | _ | i) <;> simp [mkInductiveAux₂]\n\n"}
{"name":"Homotopy.dNext_cochainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\nf : (i j : Nat) → Quiver.Hom (P.X i) (Q.X j)\nj : Nat\n⊢ Eq ((dNext j) f) (CategoryTheory.CategoryStruct.comp (P.d j (HAdd.hAdd j 1)) (f (HAdd.hAdd j 1) j))","decl":"theorem dNext_cochainComplex (f : ∀ i j, P.X i ⟶ Q.X j) (j : ℕ) :\n    dNext j f = P.d _ _ ≫ f (j + 1) j := by\n  dsimp [dNext]\n  have : (ComplexShape.up ℕ).next j = j + 1 := CochainComplex.next ℕ j\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.prevD_succ_cochainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\nf : (i j : Nat) → Quiver.Hom (P.X i) (Q.X j)\ni : Nat\n⊢ Eq ((prevD (HAdd.hAdd i 1)) f) (CategoryTheory.CategoryStruct.comp (f (HAdd.hAdd i 1) i) (Q.d i (HAdd.hAdd i 1)))","decl":"theorem prevD_succ_cochainComplex (f : ∀ i j, P.X i ⟶ Q.X j) (i : ℕ) :\n    prevD (i + 1) f = f (i + 1) _ ≫ Q.d i (i + 1) := by\n  dsimp [prevD]\n  have : (ComplexShape.up ℕ).prev (i + 1) = i := CochainComplex.prev_nat_succ i\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.prevD_zero_cochainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\nf : (i j : Nat) → Quiver.Hom (P.X i) (Q.X j)\n⊢ Eq ((prevD 0) f) 0","decl":"theorem prevD_zero_cochainComplex (f : ∀ i j, P.X i ⟶ Q.X j) : prevD 0 f = 0 := by\n  dsimp [prevD]\n  rw [Q.shape, comp_zero]\n  rw [CochainComplex.prev_nat_zero]; dsimp; decide\n\n"}
{"name":"Homotopy.mkCoinductiveAux₃","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\ni j : Nat\nh : Eq (HAdd.hAdd i 1) j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.xNextIso P h).inv (sorryAx (Unit → Quiver.Hom (HomologicalComplex.xNext P i) (Q.X i)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 638).num 25).num 638).num 85).num 25).num 85).str \"_sorry\").str \"_@\").str \"_hyg\").num 9993)))) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit → Quiver.Hom (P.X j) (HomologicalComplex.xPrev Q j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 639).num 6).num 639).num 64).num 6).num 64).str \"_sorry\").str \"_@\").str \"_hyg\").num 10011))) (HomologicalComplex.xPrevIso Q h).hom)","decl":"theorem mkCoinductiveAux₃ (i j : ℕ) (h : i + 1 = j) :\n    (P.xNextIso h).inv ≫ (mkCoinductiveAux₂ e zero comm_zero one comm_one succ i).2.1 =\n      (mkCoinductiveAux₂ e zero comm_zero one comm_one succ j).1 ≫ (Q.xPrevIso h).hom := by\n  subst j\n  rcases i with (_ | _ | i) <;> simp [mkCoinductiveAux₂]\n\n"}
{"name":"HomotopyEquiv.mk.injEq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nhom✝ : Quiver.Hom C D\ninv✝ : Quiver.Hom D C\nhomotopyHomInvId✝ : Homotopy (CategoryTheory.CategoryStruct.comp hom✝ inv✝) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId✝ : Homotopy (CategoryTheory.CategoryStruct.comp inv✝ hom✝) (CategoryTheory.CategoryStruct.id D)\nhom : Quiver.Hom C D\ninv : Quiver.Hom D C\nhomotopyHomInvId : Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId : Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id D)\n⊢ Eq (Eq { hom := hom✝, inv := inv✝, homotopyHomInvId := homotopyHomInvId✝, homotopyInvHomId := homotopyInvHomId✝ } { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }) (And (Eq hom✝ hom) (And (Eq inv✝ inv) (And (HEq homotopyHomInvId✝ homotopyHomInvId) (HEq homotopyInvHomId✝ homotopyInvHomId))))","decl":"/-- A homotopy equivalence between two chain complexes consists of a chain map each way,\nand homotopies from the compositions to the identity chain maps.\n\nNote that this contains data;\narguably it might be more useful for many applications if we truncated it to a Prop.\n-/\nstructure HomotopyEquiv (C D : HomologicalComplex V c) where\n  hom : C ⟶ D\n  inv : D ⟶ C\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 C)\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 D)\n\n"}
{"name":"HomotopyEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝³ : CategoryTheory.Category.{v, u} V\ninst✝² : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\ninst✝¹ : SizeOf ι\ninst✝ : SizeOf V\nhom : Quiver.Hom C D\ninv : Quiver.Hom D C\nhomotopyHomInvId : Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId : Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id D)\n⊢ Eq (SizeOf.sizeOf { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf inv)) (SizeOf.sizeOf homotopyHomInvId)) (SizeOf.sizeOf homotopyInvHomId))","decl":"/-- A homotopy equivalence between two chain complexes consists of a chain map each way,\nand homotopies from the compositions to the identity chain maps.\n\nNote that this contains data;\narguably it might be more useful for many applications if we truncated it to a Prop.\n-/\nstructure HomotopyEquiv (C D : HomologicalComplex V c) where\n  hom : C ⟶ D\n  inv : D ⟶ C\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 C)\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 D)\n\n"}
{"name":"HomotopyEquiv.mk.inj","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} V\ninst✝ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nhom✝ : Quiver.Hom C D\ninv✝ : Quiver.Hom D C\nhomotopyHomInvId✝ : Homotopy (CategoryTheory.CategoryStruct.comp hom✝ inv✝) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId✝ : Homotopy (CategoryTheory.CategoryStruct.comp inv✝ hom✝) (CategoryTheory.CategoryStruct.id D)\nhom : Quiver.Hom C D\ninv : Quiver.Hom D C\nhomotopyHomInvId : Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId : Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id D)\nx✝ : Eq { hom := hom✝, inv := inv✝, homotopyHomInvId := homotopyHomInvId✝, homotopyInvHomId := homotopyInvHomId✝ } { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }\n⊢ And (Eq hom✝ hom) (And (Eq inv✝ inv) (And (HEq homotopyHomInvId✝ homotopyHomInvId) (HEq homotopyInvHomId✝ homotopyInvHomId)))","decl":"/-- A homotopy equivalence between two chain complexes consists of a chain map each way,\nand homotopies from the compositions to the identity chain maps.\n\nNote that this contains data;\narguably it might be more useful for many applications if we truncated it to a Prop.\n-/\nstructure HomotopyEquiv (C D : HomologicalComplex V c) where\n  hom : C ⟶ D\n  inv : D ⟶ C\n  homotopyHomInvId : Homotopy (hom ≫ inv) (𝟙 C)\n  homotopyInvHomId : Homotopy (inv ≫ hom) (𝟙 D)\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopy_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst✝ : F.Additive\nf g : Quiver.Hom C D\nh : Homotopy f g\ni j : ι\n⊢ Eq ((F.mapHomotopy h).hom i j) (F.map (h.hom i j))","decl":"/-- An additive functor takes homotopies to homotopies. -/\n@[simps]\ndef Functor.mapHomotopy (F : V ⥤ W) [F.Additive] {f g : C ⟶ D} (h : Homotopy f g) :\n    Homotopy ((F.mapHomologicalComplex c).map f) ((F.mapHomologicalComplex c).map g) where\n  hom i j := F.map (h.hom i j)\n  zero i j w := by dsimp; rw [h.zero i j w, F.map_zero]\n  comm i := by\n    have H := h.comm i\n    dsimp [dNext, prevD] at H ⊢\n    simp [H]\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_homotopyInvHomId","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst✝ : F.Additive\nh : HomotopyEquiv C D\n⊢ Eq (F.mapHomotopyEquiv h).homotopyInvHomId (⋯.mpr (⋯.mpr (F.mapHomotopy h.homotopyInvHomId)))","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ⥤ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_inv","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst✝ : F.Additive\nh : HomotopyEquiv C D\n⊢ Eq (F.mapHomotopyEquiv h).inv ((F.mapHomologicalComplex c).map h.inv)","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ⥤ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_homotopyHomInvId","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst✝ : F.Additive\nh : HomotopyEquiv C D\n⊢ Eq (F.mapHomotopyEquiv h).homotopyHomInvId (⋯.mpr (⋯.mpr (F.mapHomotopy h.homotopyHomInvId)))","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ⥤ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"ι : Type u_1\nV : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} V\ninst✝³ : CategoryTheory.Preadditive V\nc : ComplexShape ι\nC D : HomologicalComplex V c\nW : Type u_2\ninst✝² : CategoryTheory.Category.{u_3, u_2} W\ninst✝¹ : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst✝ : F.Additive\nh : HomotopyEquiv C D\n⊢ Eq (F.mapHomotopyEquiv h).hom ((F.mapHomologicalComplex c).map h.hom)","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ⥤ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [← (F.mapHomologicalComplex c).map_comp, ← (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"Homotopy.homologyMap_eq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"C : Type u_2\ninst✝⁴ : CategoryTheory.Category.{u_3, u_2} C\ninst✝³ : CategoryTheory.Preadditive C\nι : Type u_4\nc : ComplexShape ι\ninst✝² : DecidableRel c.Rel\nK L : HomologicalComplex C c\nf g : Quiver.Hom K L\nho : Homotopy f g\ni : ι\ninst✝¹ : K.HasHomology i\ninst✝ : L.HasHomology i\n⊢ Eq (HomologicalComplex.homologyMap f i) (HomologicalComplex.homologyMap g i)","decl":"lemma Homotopy.homologyMap_eq (ho : Homotopy f g) (i : ι) [K.HasHomology i] [L.HasHomology i] :\n    homologyMap f i = homologyMap g i :=\n  ShortComplex.Homotopy.homologyMap_congr (ho.toShortComplex i)\n\n"}
