{"name":"dNext_eq_dFrom_fromNext","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ni : Œπ\n‚ä¢ Eq ((dNext i) f) (CategoryTheory.CategoryStruct.comp (C.dFrom i) ((fromNext i) f))","decl":"@[simp]\ntheorem dNext_eq_dFrom_fromNext (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) (i : Œπ) :\n    dNext i f = C.dFrom i ‚â´ fromNext i f :=\n  rfl\n\n"}
{"name":"dNext_eq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ni i' : Œπ\nw : c.Rel i i'\n‚ä¢ Eq ((dNext i) f) (CategoryTheory.CategoryStruct.comp (C.d i i') (f i' i))","decl":"theorem dNext_eq (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) {i i' : Œπ} (w : c.Rel i i') :\n    dNext i f = C.d i i' ‚â´ f i' i := by\n  obtain rfl := c.next_eq' w\n  rfl\n\n"}
{"name":"dNext_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ni : Œπ\nhi : Not (c.Rel i (c.next i))\n‚ä¢ Eq ((dNext i) f) 0","decl":"lemma dNext_eq_zero (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) (i : Œπ) (hi : ¬¨ c.Rel i (c.next i)) :\n    dNext i f = 0 := by\n  dsimp [dNext]\n  rw [shape _ _ _ hi, zero_comp]\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"dNext_comp_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\ng : (i j : Œπ) ‚Üí Quiver.Hom (D.X i) (E.X j)\ni : Œπ\n‚ä¢ Eq ((dNext i) fun i j => CategoryTheory.CategoryStruct.comp (f.f i) (g i j)) (CategoryTheory.CategoryStruct.comp (f.f i) ((dNext i) g))","decl":"theorem dNext_comp_left (f : C ‚ü∂ D) (g : ‚àÄ i j, D.X i ‚ü∂ E.X j) (i : Œπ) :\n    (dNext i fun i j => f.f i ‚â´ g i j) = f.f i ‚â´ dNext i g :=\n  (f.comm_assoc _ _ _).symm\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"dNext_comp_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\ni : Œπ\n‚ä¢ Eq ((dNext i) fun i j => CategoryTheory.CategoryStruct.comp (f i j) (g.f j)) (CategoryTheory.CategoryStruct.comp ((dNext i) f) (g.f i))","decl":"theorem dNext_comp_right (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) (g : D ‚ü∂ E) (i : Œπ) :\n    (dNext i fun i j => f i j ‚â´ g.f j) = dNext i f ‚â´ g.f i :=\n  (assoc _ _ _).symm\n\n"}
{"name":"prevD_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ni : Œπ\nhi : Not (c.Rel (c.prev i) i)\n‚ä¢ Eq ((prevD i) f) 0","decl":"lemma prevD_eq_zero (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) (i : Œπ) (hi : ¬¨ c.Rel (c.prev i) i) :\n    prevD i f = 0 := by\n  dsimp [prevD]\n  rw [shape _ _ _ hi, comp_zero]\n\n"}
{"name":"prevD_eq_toPrev_dTo","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nj : Œπ\n‚ä¢ Eq ((prevD j) f) (CategoryTheory.CategoryStruct.comp ((toPrev j) f) (D.dTo j))","decl":"@[simp]\ntheorem prevD_eq_toPrev_dTo (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) (j : Œπ) :\n    prevD j f = toPrev j f ‚â´ D.dTo j :=\n  rfl\n\n"}
{"name":"prevD_eq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nj j' : Œπ\nw : c.Rel j' j\n‚ä¢ Eq ((prevD j) f) (CategoryTheory.CategoryStruct.comp (f j j') (D.d j' j))","decl":"theorem prevD_eq (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) {j j' : Œπ} (w : c.Rel j' j) :\n    prevD j f = f j j' ‚â´ D.d j' j := by\n  obtain rfl := c.prev_eq' w\n  rfl\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"prevD_comp_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\ng : (i j : Œπ) ‚Üí Quiver.Hom (D.X i) (E.X j)\nj : Œπ\n‚ä¢ Eq ((prevD j) fun i j => CategoryTheory.CategoryStruct.comp (f.f i) (g i j)) (CategoryTheory.CategoryStruct.comp (f.f j) ((prevD j) g))","decl":"theorem prevD_comp_left (f : C ‚ü∂ D) (g : ‚àÄ i j, D.X i ‚ü∂ E.X j) (j : Œπ) :\n    (prevD j fun i j => f.f i ‚â´ g i j) = f.f j ‚â´ prevD j g :=\n  assoc _ _ _\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"prevD_comp_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\nj : Œπ\n‚ä¢ Eq ((prevD j) fun i j => CategoryTheory.CategoryStruct.comp (f i j) (g.f j)) (CategoryTheory.CategoryStruct.comp ((prevD j) f) (g.f j))","decl":"theorem prevD_comp_right (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) (g : D ‚ü∂ E) (j : Œπ) :\n    (prevD j fun i j => f i j ‚â´ g.f j) = prevD j f ‚â´ g.f j := by\n  dsimp [prevD]\n  simp only [assoc, g.comm]\n\n"}
{"name":"dNext_nat","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nC D : ChainComplex V Nat\ni : Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((dNext i) f) (CategoryTheory.CategoryStruct.comp (C.d i (HSub.hSub i 1)) (f (HSub.hSub i 1) i))","decl":"theorem dNext_nat (C D : ChainComplex V ‚Ñï) (i : ‚Ñï) (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    dNext i f = C.d i (i - 1) ‚â´ f (i - 1) i := by\n  dsimp [dNext]\n  cases i\n  ¬∑ simp only [shape, ChainComplex.next_nat_zero, ComplexShape.down_Rel, Nat.one_ne_zero,\n      not_false_iff, zero_comp, reduceCtorEq]\n  ¬∑ congr <;> simp\n\n"}
{"name":"prevD_nat","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nC D : CochainComplex V Nat\ni : Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((prevD i) f) (CategoryTheory.CategoryStruct.comp (f i (HSub.hSub i 1)) (D.d (HSub.hSub i 1) i))","decl":"theorem prevD_nat (C D : CochainComplex V ‚Ñï) (i : ‚Ñï) (f : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    prevD i f = f i (i - 1) ‚â´ D.d (i - 1) i := by\n  dsimp [prevD]\n  cases i\n  ¬∑ simp only [shape, CochainComplex.prev_nat_zero, ComplexShape.up_Rel, Nat.one_ne_zero,\n      not_false_iff, comp_zero, reduceCtorEq]\n  ¬∑ congr <;> simp\n\n"}
{"name":"Homotopy.mk.injEq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nhom‚úù : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nzero‚úù : autoParam (‚àÄ (i j : Œπ), Not (c.Rel j i) ‚Üí Eq (hom‚úù i j) 0) _auto‚úù\ncomm‚úù : autoParam (‚àÄ (i : Œπ), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom‚úù) ((prevD i) hom‚úù)) (g.f i))) _auto‚úù\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nzero : autoParam (‚àÄ (i j : Œπ), Not (c.Rel j i) ‚Üí Eq (hom i j) 0) _auto‚úù\ncomm : autoParam (‚àÄ (i : Œπ), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom) ((prevD i) hom)) (g.f i))) _auto‚úù\n‚ä¢ Eq (Eq { hom := hom‚úù, zero := zero‚úù, comm := comm‚úù } { hom := hom, zero := zero, comm := comm }) (Eq hom‚úù hom)","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.comm","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nself : Homotopy f g\ni : Œπ\n‚ä¢ Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) self.hom) ((prevD i) self.hom)) (g.f i))","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nself : Homotopy f g\ni j : Œπ\na‚úù : Not (c.Rel j i)\n‚ä¢ Eq (self.hom i j) 0","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.mk.inj","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nhom‚úù : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nzero‚úù : autoParam (‚àÄ (i j : Œπ), Not (c.Rel j i) ‚Üí Eq (hom‚úù i j) 0) _auto‚úù\ncomm‚úù : autoParam (‚àÄ (i : Œπ), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom‚úù) ((prevD i) hom‚úù)) (g.f i))) _auto‚úù\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nzero : autoParam (‚àÄ (i j : Œπ), Not (c.Rel j i) ‚Üí Eq (hom i j) 0) _auto‚úù\ncomm : autoParam (‚àÄ (i : Œπ), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom) ((prevD i) hom)) (g.f i))) _auto‚úù\nx‚úù : Eq { hom := hom‚úù, zero := zero‚úù, comm := comm‚úù } { hom := hom, zero := zero, comm := comm }\n‚ä¢ Eq hom‚úù hom","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.ext_iff","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nx y : Homotopy f g\n‚ä¢ Iff (Eq x y) (Eq x.hom y.hom)","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.ext","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nx y : Homotopy f g\nhom : Eq x.hom y.hom\n‚ä¢ Eq x y","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\ninst‚úù¬π : SizeOf Œπ\ninst‚úù : SizeOf V\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nzero : autoParam (‚àÄ (i j : Œπ), Not (c.Rel j i) ‚Üí Eq (hom i j) 0) _auto‚úù\ncomm : autoParam (‚àÄ (i : Œπ), Eq (f.f i) (HAdd.hAdd (HAdd.hAdd ((dNext i) hom) ((prevD i) hom)) (g.f i))) _auto‚úù\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, zero := zero, comm := comm }) 1","decl":"/-- A homotopy `h` between chain maps `f` and `g` consists of components `h i j : C.X i ‚ü∂ D.X j`\nwhich are zero unless `c.Rel j i`, satisfying the homotopy condition.\n-/\n@[ext]\nstructure Homotopy (f g : C ‚ü∂ D) where\n  hom : ‚àÄ i j, C.X i ‚ü∂ D.X j\n  zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0 := by aesop_cat\n  comm : ‚àÄ i, f.f i = dNext i hom + prevD i hom + g.f i := by aesop_cat\n\n"}
{"name":"Homotopy.ofEq_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : Eq f g\ni j : Œπ\n‚ä¢ Eq ((Homotopy.ofEq h).hom i j) (0 i j)","decl":"/-- Equal chain maps are homotopic. -/\n@[simps]\ndef ofEq (h : f = g) : Homotopy f g where\n  hom := 0\n  zero _ _ _ := rfl\n\n"}
{"name":"Homotopy.refl_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : Quiver.Hom C D\ni j : Œπ\n‚ä¢ Eq ((Homotopy.refl f).hom i j) 0","decl":"/-- Every chain map is homotopic to itself. -/\n@[simps!, refl]\ndef refl (f : C ‚ü∂ D) : Homotopy f f :=\n  ofEq (rfl : f = f)\n\n"}
{"name":"Homotopy.symm_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nh : Homotopy f g\ni j : Œπ\n‚ä¢ Eq (h.symm.hom i j) (Neg.neg (h.hom i j))","decl":"/-- `f` is homotopic to `g` iff `g` is homotopic to `f`. -/\n@[simps!, symm]\ndef symm {f g : C ‚ü∂ D} (h : Homotopy f g) : Homotopy g f where\n  hom := -h.hom\n  zero i j w := by rw [Pi.neg_apply, Pi.neg_apply, h.zero i j w, neg_zero]\n  comm i := by\n    rw [AddMonoidHom.map_neg, AddMonoidHom.map_neg, h.comm, ‚Üê neg_add, ‚Üê add_assoc, neg_add_cancel,\n      zero_add]\n\n"}
{"name":"Homotopy.trans_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\ne f g : Quiver.Hom C D\nh : Homotopy e f\nk : Homotopy f g\ni j : Œπ\n‚ä¢ Eq ((h.trans k).hom i j) (HAdd.hAdd (h.hom i j) (k.hom i j))","decl":"/-- homotopy is a transitive relation. -/\n@[simps!, trans]\ndef trans {e f g : C ‚ü∂ D} (h : Homotopy e f) (k : Homotopy f g) : Homotopy e g where\n  hom := h.hom + k.hom\n  zero i j w := by rw [Pi.add_apply, Pi.add_apply, h.zero i j w, k.zero i j w, zero_add]\n  comm i := by\n    rw [AddMonoidHom.map_add, AddMonoidHom.map_add, h.comm, k.comm]\n    abel\n\n"}
{"name":"Homotopy.add_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ : Quiver.Hom C D\nh‚ÇÅ : Homotopy f‚ÇÅ g‚ÇÅ\nh‚ÇÇ : Homotopy f‚ÇÇ g‚ÇÇ\ni j : Œπ\n‚ä¢ Eq ((h‚ÇÅ.add h‚ÇÇ).hom i j) (HAdd.hAdd (h‚ÇÅ.hom i j) (h‚ÇÇ.hom i j))","decl":"/-- the sum of two homotopies is a homotopy between the sum of the respective morphisms. -/\n@[simps!]\ndef add {f‚ÇÅ g‚ÇÅ f‚ÇÇ g‚ÇÇ : C ‚ü∂ D} (h‚ÇÅ : Homotopy f‚ÇÅ g‚ÇÅ) (h‚ÇÇ : Homotopy f‚ÇÇ g‚ÇÇ) :\n    Homotopy (f‚ÇÅ + f‚ÇÇ) (g‚ÇÅ + g‚ÇÇ) where\n  hom := h‚ÇÅ.hom + h‚ÇÇ.hom\n  zero i j hij := by rw [Pi.add_apply, Pi.add_apply, h‚ÇÅ.zero i j hij, h‚ÇÇ.zero i j hij, add_zero]\n  comm i := by\n    simp only [HomologicalComplex.add_f_apply, h‚ÇÅ.comm, h‚ÇÇ.comm, AddMonoidHom.map_add]\n    abel\n\n"}
{"name":"Homotopy.smul_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf g : Quiver.Hom C D\nR : Type u_2\ninst‚úù¬π : Semiring R\ninst‚úù : CategoryTheory.Linear R V\nh : Homotopy f g\na : R\ni j : Œπ\n‚ä¢ Eq ((h.smul a).hom i j) (HSMul.hSMul a (h.hom i j))","decl":"/-- the scalar multiplication of an homotopy -/\n@[simps!]\ndef smul {R : Type*} [Semiring R] [Linear R V] (h : Homotopy f g) (a : R) :\n    Homotopy (a ‚Ä¢ f) (a ‚Ä¢ g) where\n  hom i j := a ‚Ä¢ h.hom i j\n  zero i j hij := by\n    dsimp\n    rw [h.zero i j hij, smul_zero]\n  comm i := by\n    dsimp\n    rw [h.comm]\n    dsimp [fromNext, toPrev]\n    simp only [smul_add, Linear.comp_smul, Linear.smul_comp]\n\n"}
{"name":"Homotopy.compRight_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\ne f : Quiver.Hom C D\nh : Homotopy e f\ng : Quiver.Hom D E\ni j : Œπ\n‚ä¢ Eq ((h.compRight g).hom i j) (CategoryTheory.CategoryStruct.comp (h.hom i j) (g.f j))","decl":"/-- homotopy is closed under composition (on the right) -/\n@[simps]\ndef compRight {e f : C ‚ü∂ D} (h : Homotopy e f) (g : D ‚ü∂ E) : Homotopy (e ‚â´ g) (f ‚â´ g) where\n  hom i j := h.hom i j ‚â´ g.f j\n  zero i j w := by dsimp; rw [h.zero i j w, zero_comp]\n  comm i := by rw [comp_f, h.comm i, dNext_comp_right, prevD_comp_right, Preadditive.add_comp,\n    comp_f, Preadditive.add_comp]\n\n"}
{"name":"Homotopy.compLeft_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf g : Quiver.Hom D E\nh : Homotopy f g\ne : Quiver.Hom C D\ni j : Œπ\n‚ä¢ Eq ((h.compLeft e).hom i j) (CategoryTheory.CategoryStruct.comp (e.f i) (h.hom i j))","decl":"/-- homotopy is closed under composition (on the left) -/\n@[simps]\ndef compLeft {f g : D ‚ü∂ E} (h : Homotopy f g) (e : C ‚ü∂ D) : Homotopy (e ‚â´ f) (e ‚â´ g) where\n  hom i j := e.f i ‚â´ h.hom i j\n  zero i j w := by dsimp; rw [h.zero i j w, comp_zero]\n  comm i := by rw [comp_f, h.comm i, dNext_comp_left, prevD_comp_left, comp_f,\n    Preadditive.comp_add, Preadditive.comp_add]\n\n"}
{"name":"Homotopy.comp_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c\nf‚ÇÅ g‚ÇÅ : Quiver.Hom C‚ÇÅ C‚ÇÇ\nf‚ÇÇ g‚ÇÇ : Quiver.Hom C‚ÇÇ C‚ÇÉ\nh‚ÇÅ : Homotopy f‚ÇÅ g‚ÇÅ\nh‚ÇÇ : Homotopy f‚ÇÇ g‚ÇÇ\ni j : Œπ\n‚ä¢ Eq ((h‚ÇÅ.comp h‚ÇÇ).hom i j) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (h‚ÇÅ.hom i j) (f‚ÇÇ.f j)) (CategoryTheory.CategoryStruct.comp (g‚ÇÅ.f i) (h‚ÇÇ.hom i j)))","decl":"/-- homotopy is closed under composition -/\n@[simps!]\ndef comp {C‚ÇÅ C‚ÇÇ C‚ÇÉ : HomologicalComplex V c} {f‚ÇÅ g‚ÇÅ : C‚ÇÅ ‚ü∂ C‚ÇÇ} {f‚ÇÇ g‚ÇÇ : C‚ÇÇ ‚ü∂ C‚ÇÉ}\n    (h‚ÇÅ : Homotopy f‚ÇÅ g‚ÇÅ) (h‚ÇÇ : Homotopy f‚ÇÇ g‚ÇÇ) : Homotopy (f‚ÇÅ ‚â´ f‚ÇÇ) (g‚ÇÅ ‚â´ g‚ÇÇ) :=\n  (h‚ÇÅ.compRight _).trans (h‚ÇÇ.compLeft _)\n\n"}
{"name":"Homotopy.compRightId_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : Quiver.Hom C C\nh : Homotopy f (CategoryTheory.CategoryStruct.id C)\ng : Quiver.Hom C D\ni j : Œπ\n‚ä¢ Eq ((h.compRightId g).hom i j) (CategoryTheory.CategoryStruct.comp (h.hom i j) (g.f j))","decl":"/-- a variant of `Homotopy.compRight` useful for dealing with homotopy equivalences. -/\n@[simps!]\ndef compRightId {f : C ‚ü∂ C} (h : Homotopy f (ùüô C)) (g : C ‚ü∂ D) : Homotopy (f ‚â´ g) g :=\n  (h.compRight g).trans (ofEq <| id_comp _)\n\n"}
{"name":"Homotopy.compLeftId_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nf : Quiver.Hom D D\nh : Homotopy f (CategoryTheory.CategoryStruct.id D)\ng : Quiver.Hom C D\ni j : Œπ\n‚ä¢ Eq ((h.compLeftId g).hom i j) (CategoryTheory.CategoryStruct.comp (g.f i) (h.hom i j))","decl":"/-- a variant of `Homotopy.compLeft` useful for dealing with homotopy equivalences. -/\n@[simps!]\ndef compLeftId {f : D ‚ü∂ D} (h : Homotopy f (ùüô D)) (g : C ‚ü∂ D) : Homotopy (g ‚â´ f) g :=\n  (h.compLeft g).trans (ofEq <| comp_id _)\n\n"}
{"name":"Homotopy.nullHomotopicMap_comp","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Homotopy.nullHomotopicMap hom) g) (Homotopy.nullHomotopicMap fun i j => CategoryTheory.CategoryStruct.comp (hom i j) (g.f j))","decl":"/-- Compatibility of `nullHomotopicMap` with the postcomposition by a morphism\nof complexes. -/\ntheorem nullHomotopicMap_comp (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) (g : D ‚ü∂ E) :\n    nullHomotopicMap hom ‚â´ g = nullHomotopicMap fun i j => hom i j ‚â´ g.f j := by\n  ext n\n  dsimp [nullHomotopicMap, fromNext, toPrev, AddMonoidHom.mk'_apply]\n  simp only [Preadditive.add_comp, assoc, g.comm]\n\n"}
{"name":"Homotopy.nullHomotopicMap'_comp","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nhom : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\ng : Quiver.Hom D E\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (Homotopy.nullHomotopicMap' hom) g) (Homotopy.nullHomotopicMap' fun i j hij => CategoryTheory.CategoryStruct.comp (hom i j hij) (g.f j))","decl":"/-- Compatibility of `nullHomotopicMap'` with the postcomposition by a morphism\nof complexes. -/\ntheorem nullHomotopicMap'_comp (hom : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) (g : D ‚ü∂ E) :\n    nullHomotopicMap' hom ‚â´ g = nullHomotopicMap' fun i j hij => hom i j hij ‚â´ g.f j := by\n  ext n\n  erw [nullHomotopicMap_comp]\n  congr\n  ext i j\n  split_ifs\n  ¬∑ rfl\n  ¬∑ rw [zero_comp]\n\n"}
{"name":"Homotopy.comp_nullHomotopicMap","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\nhom : (i j : Œπ) ‚Üí Quiver.Hom (D.X i) (E.X j)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (Homotopy.nullHomotopicMap hom)) (Homotopy.nullHomotopicMap fun i j => CategoryTheory.CategoryStruct.comp (f.f i) (hom i j))","decl":"/-- Compatibility of `nullHomotopicMap` with the precomposition by a morphism\nof complexes. -/\ntheorem comp_nullHomotopicMap (f : C ‚ü∂ D) (hom : ‚àÄ i j, D.X i ‚ü∂ E.X j) :\n    f ‚â´ nullHomotopicMap hom = nullHomotopicMap fun i j => f.f i ‚â´ hom i j := by\n  ext n\n  dsimp [nullHomotopicMap, fromNext, toPrev, AddMonoidHom.mk'_apply]\n  simp only [Preadditive.comp_add, assoc, f.comm_assoc]\n\n"}
{"name":"Homotopy.comp_nullHomotopicMap'","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D E : HomologicalComplex V c\nf : Quiver.Hom C D\nhom : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (D.X i) (E.X j)\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp f (Homotopy.nullHomotopicMap' hom)) (Homotopy.nullHomotopicMap' fun i j hij => CategoryTheory.CategoryStruct.comp (f.f i) (hom i j hij))","decl":"/-- Compatibility of `nullHomotopicMap'` with the precomposition by a morphism\nof complexes. -/\ntheorem comp_nullHomotopicMap' (f : C ‚ü∂ D) (hom : ‚àÄ i j, c.Rel j i ‚Üí (D.X i ‚ü∂ E.X j)) :\n    f ‚â´ nullHomotopicMap' hom = nullHomotopicMap' fun i j hij => f.f i ‚â´ hom i j hij := by\n  ext n\n  erw [comp_nullHomotopicMap]\n  congr\n  ext i j\n  split_ifs\n  ¬∑ rfl\n  ¬∑ rw [comp_zero]\n\n"}
{"name":"Homotopy.map_nullHomotopicMap","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nG : CategoryTheory.Functor V W\ninst‚úù : G.Additive\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((G.mapHomologicalComplex c).map (Homotopy.nullHomotopicMap hom)) (Homotopy.nullHomotopicMap fun i j => G.map (hom i j))","decl":"/-- Compatibility of `nullHomotopicMap` with the application of additive functors -/\ntheorem map_nullHomotopicMap {W : Type*} [Category W] [Preadditive W] (G : V ‚•§ W) [G.Additive]\n    (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    (G.mapHomologicalComplex c).map (nullHomotopicMap hom) =\n      nullHomotopicMap (fun i j => by exact G.map (hom i j)) := by\n  ext i\n  dsimp [nullHomotopicMap, dNext, prevD]\n  simp only [G.map_comp, Functor.map_add]\n\n"}
{"name":"Homotopy.map_nullHomotopicMap'","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nG : CategoryTheory.Functor V W\ninst‚úù : G.Additive\nhom : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((G.mapHomologicalComplex c).map (Homotopy.nullHomotopicMap' hom)) (Homotopy.nullHomotopicMap' fun i j hij => G.map (hom i j hij))","decl":"/-- Compatibility of `nullHomotopicMap'` with the application of additive functors -/\ntheorem map_nullHomotopicMap' {W : Type*} [Category W] [Preadditive W] (G : V ‚•§ W) [G.Additive]\n    (hom : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) :\n    (G.mapHomologicalComplex c).map (nullHomotopicMap' hom) =\n      nullHomotopicMap' fun i j hij => by exact G.map (hom i j hij) := by\n  ext n\n  erw [map_nullHomotopicMap]\n  congr\n  ext i j\n  split_ifs\n  ¬∑ rfl\n  ¬∑ rw [G.map_zero]\n\n"}
{"name":"Homotopy.nullHomotopy_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\nzero : ‚àÄ (i j : Œπ), Not (c.Rel j i) ‚Üí Eq (hom i j) 0\ni j : Œπ\n‚ä¢ Eq ((Homotopy.nullHomotopy hom zero).hom i j) (hom i j)","decl":"/-- Tautological construction of the `Homotopy` to zero for maps constructed by\n`nullHomotopicMap`, at least when we have the `zero` condition. -/\n@[simps]\ndef nullHomotopy (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) (zero : ‚àÄ i j, ¬¨c.Rel j i ‚Üí hom i j = 0) :\n    Homotopy (nullHomotopicMap hom) 0 :=\n  { hom := hom\n    zero := zero\n    comm := by\n      intro i\n      rw [HomologicalComplex.zero_f_apply, add_zero]\n      rfl }\n\n"}
{"name":"Homotopy.nullHomotopy'_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nh : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\ni j : Œπ\n‚ä¢ Eq ((Homotopy.nullHomotopy' h).hom i j) (dite (c.Rel j i) (h i j) fun x => 0)","decl":"open Classical in\n/-- Homotopy to zero for maps constructed with `nullHomotopicMap'` -/\n@[simps!]\ndef nullHomotopy' (h : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) : Homotopy (nullHomotopicMap' h) 0 := by\n  apply nullHomotopy fun i j => dite (c.Rel j i) (h i j) fun _ => 0\n  intro i j hij\n  rw [dite_eq_right_iff]\n  intro hij'\n  exfalso\n  exact hij hij'\n\n"}
{"name":"Homotopy.nullHomotopicMap_f","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÇ k‚ÇÅ k‚ÇÄ : Œπ\nr‚ÇÇ‚ÇÅ : c.Rel k‚ÇÇ k‚ÇÅ\nr‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap hom).f k‚ÇÅ) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (C.d k‚ÇÅ k‚ÇÄ) (hom k‚ÇÄ k‚ÇÅ)) (CategoryTheory.CategoryStruct.comp (hom k‚ÇÅ k‚ÇÇ) (D.d k‚ÇÇ k‚ÇÅ)))","decl":"@[simp]\ntheorem nullHomotopicMap_f {k‚ÇÇ k‚ÇÅ k‚ÇÄ : Œπ} (r‚ÇÇ‚ÇÅ : c.Rel k‚ÇÇ k‚ÇÅ) (r‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ)\n    (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    (nullHomotopicMap hom).f k‚ÇÅ = C.d k‚ÇÅ k‚ÇÄ ‚â´ hom k‚ÇÄ k‚ÇÅ + hom k‚ÇÅ k‚ÇÇ ‚â´ D.d k‚ÇÇ k‚ÇÅ := by\n  dsimp only [nullHomotopicMap]\n  rw [dNext_eq hom r‚ÇÅ‚ÇÄ, prevD_eq hom r‚ÇÇ‚ÇÅ]\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÇ k‚ÇÅ k‚ÇÄ : Œπ\nr‚ÇÇ‚ÇÅ : c.Rel k‚ÇÇ k‚ÇÅ\nr‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ\nh : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap' h).f k‚ÇÅ) (HAdd.hAdd (CategoryTheory.CategoryStruct.comp (C.d k‚ÇÅ k‚ÇÄ) (h k‚ÇÄ k‚ÇÅ r‚ÇÅ‚ÇÄ)) (CategoryTheory.CategoryStruct.comp (h k‚ÇÅ k‚ÇÇ r‚ÇÇ‚ÇÅ) (D.d k‚ÇÇ k‚ÇÅ)))","decl":"@[simp]\ntheorem nullHomotopicMap'_f {k‚ÇÇ k‚ÇÅ k‚ÇÄ : Œπ} (r‚ÇÇ‚ÇÅ : c.Rel k‚ÇÇ k‚ÇÅ) (r‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ)\n    (h : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) :\n    (nullHomotopicMap' h).f k‚ÇÅ = C.d k‚ÇÅ k‚ÇÄ ‚â´ h k‚ÇÄ k‚ÇÅ r‚ÇÅ‚ÇÄ + h k‚ÇÅ k‚ÇÇ r‚ÇÇ‚ÇÅ ‚â´ D.d k‚ÇÇ k‚ÇÅ := by\n  simp only [nullHomotopicMap']\n  rw [nullHomotopicMap_f r‚ÇÇ‚ÇÅ r‚ÇÅ‚ÇÄ]\n  split_ifs\n  rfl\n\n"}
{"name":"Homotopy.nullHomotopicMap_f_of_not_rel_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÅ k‚ÇÄ : Œπ\nr‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ\nhk‚ÇÄ : ‚àÄ (l : Œπ), Not (c.Rel k‚ÇÄ l)\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap hom).f k‚ÇÄ) (CategoryTheory.CategoryStruct.comp (hom k‚ÇÄ k‚ÇÅ) (D.d k‚ÇÅ k‚ÇÄ))","decl":"@[simp]\ntheorem nullHomotopicMap_f_of_not_rel_left {k‚ÇÅ k‚ÇÄ : Œπ} (r‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ)\n    (hk‚ÇÄ : ‚àÄ l : Œπ, ¬¨c.Rel k‚ÇÄ l) (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    (nullHomotopicMap hom).f k‚ÇÄ = hom k‚ÇÄ k‚ÇÅ ‚â´ D.d k‚ÇÅ k‚ÇÄ := by\n  dsimp only [nullHomotopicMap]\n  rw [prevD_eq hom r‚ÇÅ‚ÇÄ, dNext, AddMonoidHom.mk'_apply, C.shape, zero_comp, zero_add]\n  exact hk‚ÇÄ _\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f_of_not_rel_left","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÅ k‚ÇÄ : Œπ\nr‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ\nhk‚ÇÄ : ‚àÄ (l : Œπ), Not (c.Rel k‚ÇÄ l)\nh : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap' h).f k‚ÇÄ) (CategoryTheory.CategoryStruct.comp (h k‚ÇÄ k‚ÇÅ r‚ÇÅ‚ÇÄ) (D.d k‚ÇÅ k‚ÇÄ))","decl":"@[simp]\ntheorem nullHomotopicMap'_f_of_not_rel_left {k‚ÇÅ k‚ÇÄ : Œπ} (r‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ)\n    (hk‚ÇÄ : ‚àÄ l : Œπ, ¬¨c.Rel k‚ÇÄ l) (h : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) :\n    (nullHomotopicMap' h).f k‚ÇÄ = h k‚ÇÄ k‚ÇÅ r‚ÇÅ‚ÇÄ ‚â´ D.d k‚ÇÅ k‚ÇÄ := by\n  simp only [nullHomotopicMap']\n  rw [nullHomotopicMap_f_of_not_rel_left r‚ÇÅ‚ÇÄ hk‚ÇÄ]\n  split_ifs\n  rfl\n\n"}
{"name":"Homotopy.nullHomotopicMap_f_of_not_rel_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÅ k‚ÇÄ : Œπ\nr‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ\nhk‚ÇÅ : ‚àÄ (l : Œπ), Not (c.Rel l k‚ÇÅ)\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap hom).f k‚ÇÅ) (CategoryTheory.CategoryStruct.comp (C.d k‚ÇÅ k‚ÇÄ) (hom k‚ÇÄ k‚ÇÅ))","decl":"@[simp]\ntheorem nullHomotopicMap_f_of_not_rel_right {k‚ÇÅ k‚ÇÄ : Œπ} (r‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ)\n    (hk‚ÇÅ : ‚àÄ l : Œπ, ¬¨c.Rel l k‚ÇÅ) (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    (nullHomotopicMap hom).f k‚ÇÅ = C.d k‚ÇÅ k‚ÇÄ ‚â´ hom k‚ÇÄ k‚ÇÅ := by\n  dsimp only [nullHomotopicMap]\n  rw [dNext_eq hom r‚ÇÅ‚ÇÄ, prevD, AddMonoidHom.mk'_apply, D.shape, comp_zero, add_zero]\n  exact hk‚ÇÅ _\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f_of_not_rel_right","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÅ k‚ÇÄ : Œπ\nr‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ\nhk‚ÇÅ : ‚àÄ (l : Œπ), Not (c.Rel l k‚ÇÅ)\nh : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap' h).f k‚ÇÅ) (CategoryTheory.CategoryStruct.comp (C.d k‚ÇÅ k‚ÇÄ) (h k‚ÇÄ k‚ÇÅ r‚ÇÅ‚ÇÄ))","decl":"@[simp]\ntheorem nullHomotopicMap'_f_of_not_rel_right {k‚ÇÅ k‚ÇÄ : Œπ} (r‚ÇÅ‚ÇÄ : c.Rel k‚ÇÅ k‚ÇÄ)\n    (hk‚ÇÅ : ‚àÄ l : Œπ, ¬¨c.Rel l k‚ÇÅ) (h : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) :\n    (nullHomotopicMap' h).f k‚ÇÅ = C.d k‚ÇÅ k‚ÇÄ ‚â´ h k‚ÇÄ k‚ÇÅ r‚ÇÅ‚ÇÄ := by\n  simp only [nullHomotopicMap']\n  rw [nullHomotopicMap_f_of_not_rel_right r‚ÇÅ‚ÇÄ hk‚ÇÅ]\n  split_ifs\n  rfl\n\n"}
{"name":"Homotopy.nullHomotopicMap_f_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÄ : Œπ\nhk‚ÇÄ : ‚àÄ (l : Œπ), Not (c.Rel k‚ÇÄ l)\nhk‚ÇÄ' : ‚àÄ (l : Œπ), Not (c.Rel l k‚ÇÄ)\nhom : (i j : Œπ) ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap hom).f k‚ÇÄ) 0","decl":"@[simp]\ntheorem nullHomotopicMap_f_eq_zero {k‚ÇÄ : Œπ} (hk‚ÇÄ : ‚àÄ l : Œπ, ¬¨c.Rel k‚ÇÄ l)\n    (hk‚ÇÄ' : ‚àÄ l : Œπ, ¬¨c.Rel l k‚ÇÄ) (hom : ‚àÄ i j, C.X i ‚ü∂ D.X j) :\n    (nullHomotopicMap hom).f k‚ÇÄ = 0 := by\n  dsimp [nullHomotopicMap, dNext, prevD]\n  rw [C.shape, D.shape, zero_comp, comp_zero, add_zero] <;> apply_assumption\n\n"}
{"name":"Homotopy.nullHomotopicMap'_f_eq_zero","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nk‚ÇÄ : Œπ\nhk‚ÇÄ : ‚àÄ (l : Œπ), Not (c.Rel k‚ÇÄ l)\nhk‚ÇÄ' : ‚àÄ (l : Œπ), Not (c.Rel l k‚ÇÄ)\nh : (i j : Œπ) ‚Üí c.Rel j i ‚Üí Quiver.Hom (C.X i) (D.X j)\n‚ä¢ Eq ((Homotopy.nullHomotopicMap' h).f k‚ÇÄ) 0","decl":"@[simp]\ntheorem nullHomotopicMap'_f_eq_zero {k‚ÇÄ : Œπ} (hk‚ÇÄ : ‚àÄ l : Œπ, ¬¨c.Rel k‚ÇÄ l)\n    (hk‚ÇÄ' : ‚àÄ l : Œπ, ¬¨c.Rel l k‚ÇÄ) (h : ‚àÄ i j, c.Rel j i ‚Üí (C.X i ‚ü∂ D.X j)) :\n    (nullHomotopicMap' h).f k‚ÇÄ = 0 := by\n  simp only [nullHomotopicMap']\n  apply nullHomotopicMap_f_eq_zero hk‚ÇÄ hk‚ÇÄ'\n\n"}
{"name":"Homotopy.prevD_chainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (P.X i) (Q.X j)\nj : Nat\n‚ä¢ Eq ((prevD j) f) (CategoryTheory.CategoryStruct.comp (f j (HAdd.hAdd j 1)) (Q.d (HAdd.hAdd j 1) j))","decl":"theorem prevD_chainComplex (f : ‚àÄ i j, P.X i ‚ü∂ Q.X j) (j : ‚Ñï) :\n    prevD j f = f j (j + 1) ‚â´ Q.d _ _ := by\n  dsimp [prevD]\n  have : (ComplexShape.down ‚Ñï).prev j = j + 1 := ChainComplex.prev ‚Ñï j\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.dNext_succ_chainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (P.X i) (Q.X j)\ni : Nat\n‚ä¢ Eq ((dNext (HAdd.hAdd i 1)) f) (CategoryTheory.CategoryStruct.comp (P.d (HAdd.hAdd i 1) i) (f i (HAdd.hAdd i 1)))","decl":"theorem dNext_succ_chainComplex (f : ‚àÄ i j, P.X i ‚ü∂ Q.X j) (i : ‚Ñï) :\n    dNext (i + 1) f = P.d _ _ ‚â´ f i (i + 1) := by\n  dsimp [dNext]\n  have : (ComplexShape.down ‚Ñï).next (i + 1) = i := ChainComplex.next_nat_succ _\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.dNext_zero_chainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (P.X i) (Q.X j)\n‚ä¢ Eq ((dNext 0) f) 0","decl":"theorem dNext_zero_chainComplex (f : ‚àÄ i j, P.X i ‚ü∂ Q.X j) : dNext 0 f = 0 := by\n  dsimp [dNext]\n  rw [P.shape, zero_comp]\n  rw [ChainComplex.next_nat_zero]; dsimp; decide\n\n"}
{"name":"Homotopy.mkInductiveAux‚ÇÉ","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : ChainComplex V Nat\ni j : Nat\nh : Eq (HAdd.hAdd i 1) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (sorryAx (Unit ‚Üí Quiver.Hom (P.X i) (HomologicalComplex.xPrev Q i)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 509).num 4).num 509).num 62).num 4).num 62).str \"_sorry\").str \"_@\").str \"_hyg\").num 7021))) (HomologicalComplex.xPrevIso Q h).hom) (CategoryTheory.CategoryStruct.comp (HomologicalComplex.xNextIso P h).inv (sorryAx (Unit ‚Üí Quiver.Hom (HomologicalComplex.xNext P j) (Q.X j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 510).num 27).num 510).num 83).num 27).num 83).str \"_sorry\").str \"_@\").str \"_hyg\").num 7039))))","decl":"theorem mkInductiveAux‚ÇÉ (i j : ‚Ñï) (h : i + 1 = j) :\n    (mkInductiveAux‚ÇÇ e zero comm_zero one comm_one succ i).2.1 ‚â´ (Q.xPrevIso h).hom =\n      (P.xNextIso h).inv ‚â´ (mkInductiveAux‚ÇÇ e zero comm_zero one comm_one succ j).1 := by\n  subst j\n  rcases i with (_ | _ | i) <;> simp [mkInductiveAux‚ÇÇ]\n\n"}
{"name":"Homotopy.dNext_cochainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (P.X i) (Q.X j)\nj : Nat\n‚ä¢ Eq ((dNext j) f) (CategoryTheory.CategoryStruct.comp (P.d j (HAdd.hAdd j 1)) (f (HAdd.hAdd j 1) j))","decl":"theorem dNext_cochainComplex (f : ‚àÄ i j, P.X i ‚ü∂ Q.X j) (j : ‚Ñï) :\n    dNext j f = P.d _ _ ‚â´ f (j + 1) j := by\n  dsimp [dNext]\n  have : (ComplexShape.up ‚Ñï).next j = j + 1 := CochainComplex.next ‚Ñï j\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.prevD_succ_cochainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (P.X i) (Q.X j)\ni : Nat\n‚ä¢ Eq ((prevD (HAdd.hAdd i 1)) f) (CategoryTheory.CategoryStruct.comp (f (HAdd.hAdd i 1) i) (Q.d i (HAdd.hAdd i 1)))","decl":"theorem prevD_succ_cochainComplex (f : ‚àÄ i j, P.X i ‚ü∂ Q.X j) (i : ‚Ñï) :\n    prevD (i + 1) f = f (i + 1) _ ‚â´ Q.d i (i + 1) := by\n  dsimp [prevD]\n  have : (ComplexShape.up ‚Ñï).prev (i + 1) = i := CochainComplex.prev_nat_succ i\n  congr 2\n\n-- This is not a simp lemma; the LHS already simplifies.\n"}
{"name":"Homotopy.prevD_zero_cochainComplex","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\nf : (i j : Nat) ‚Üí Quiver.Hom (P.X i) (Q.X j)\n‚ä¢ Eq ((prevD 0) f) 0","decl":"theorem prevD_zero_cochainComplex (f : ‚àÄ i j, P.X i ‚ü∂ Q.X j) : prevD 0 f = 0 := by\n  dsimp [prevD]\n  rw [Q.shape, comp_zero]\n  rw [CochainComplex.prev_nat_zero]; dsimp; decide\n\n"}
{"name":"Homotopy.mkCoinductiveAux‚ÇÉ","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"V : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nP Q : CochainComplex V Nat\ni j : Nat\nh : Eq (HAdd.hAdd i 1) j\n‚ä¢ Eq (CategoryTheory.CategoryStruct.comp (HomologicalComplex.xNextIso P h).inv (sorryAx (Unit ‚Üí Quiver.Hom (HomologicalComplex.xNext P i) (Q.X i)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 638).num 25).num 638).num 85).num 25).num 85).str \"_sorry\").str \"_@\").str \"_hyg\").num 9993)))) (CategoryTheory.CategoryStruct.comp (sorryAx (Unit ‚Üí Quiver.Hom (P.X j) (HomologicalComplex.xPrev Q j)) Bool.true (Function.const Lean.Name Unit.unit ((((((((((Lean.Name.anonymous.num 639).num 6).num 639).num 64).num 6).num 64).str \"_sorry\").str \"_@\").str \"_hyg\").num 10011))) (HomologicalComplex.xPrevIso Q h).hom)","decl":"theorem mkCoinductiveAux‚ÇÉ (i j : ‚Ñï) (h : i + 1 = j) :\n    (P.xNextIso h).inv ‚â´ (mkCoinductiveAux‚ÇÇ e zero comm_zero one comm_one succ i).2.1 =\n      (mkCoinductiveAux‚ÇÇ e zero comm_zero one comm_one succ j).1 ‚â´ (Q.xPrevIso h).hom := by\n  subst j\n  rcases i with (_ | _ | i) <;> simp [mkCoinductiveAux‚ÇÇ]\n\n"}
{"name":"HomotopyEquiv.mk.injEq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nhom‚úù : Quiver.Hom C D\ninv‚úù : Quiver.Hom D C\nhomotopyHomInvId‚úù : Homotopy (CategoryTheory.CategoryStruct.comp hom‚úù inv‚úù) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId‚úù : Homotopy (CategoryTheory.CategoryStruct.comp inv‚úù hom‚úù) (CategoryTheory.CategoryStruct.id D)\nhom : Quiver.Hom C D\ninv : Quiver.Hom D C\nhomotopyHomInvId : Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId : Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id D)\n‚ä¢ Eq (Eq { hom := hom‚úù, inv := inv‚úù, homotopyHomInvId := homotopyHomInvId‚úù, homotopyInvHomId := homotopyInvHomId‚úù } { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }) (And (Eq hom‚úù hom) (And (Eq inv‚úù inv) (And (HEq homotopyHomInvId‚úù homotopyHomInvId) (HEq homotopyInvHomId‚úù homotopyInvHomId))))","decl":"/-- A homotopy equivalence between two chain complexes consists of a chain map each way,\nand homotopies from the compositions to the identity chain maps.\n\nNote that this contains data;\narguably it might be more useful for many applications if we truncated it to a Prop.\n-/\nstructure HomotopyEquiv (C D : HomologicalComplex V c) where\n  hom : C ‚ü∂ D\n  inv : D ‚ü∂ C\n  homotopyHomInvId : Homotopy (hom ‚â´ inv) (ùüô C)\n  homotopyInvHomId : Homotopy (inv ‚â´ hom) (ùüô D)\n\n"}
{"name":"HomotopyEquiv.mk.sizeOf_spec","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬≥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≤ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\ninst‚úù¬π : SizeOf Œπ\ninst‚úù : SizeOf V\nhom : Quiver.Hom C D\ninv : Quiver.Hom D C\nhomotopyHomInvId : Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId : Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id D)\n‚ä¢ Eq (SizeOf.sizeOf { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf hom)) (SizeOf.sizeOf inv)) (SizeOf.sizeOf homotopyHomInvId)) (SizeOf.sizeOf homotopyInvHomId))","decl":"/-- A homotopy equivalence between two chain complexes consists of a chain map each way,\nand homotopies from the compositions to the identity chain maps.\n\nNote that this contains data;\narguably it might be more useful for many applications if we truncated it to a Prop.\n-/\nstructure HomotopyEquiv (C D : HomologicalComplex V c) where\n  hom : C ‚ü∂ D\n  inv : D ‚ü∂ C\n  homotopyHomInvId : Homotopy (hom ‚â´ inv) (ùüô C)\n  homotopyInvHomId : Homotopy (inv ‚â´ hom) (ùüô D)\n\n"}
{"name":"HomotopyEquiv.mk.inj","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù¬π : CategoryTheory.Category.{v, u} V\ninst‚úù : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nhom‚úù : Quiver.Hom C D\ninv‚úù : Quiver.Hom D C\nhomotopyHomInvId‚úù : Homotopy (CategoryTheory.CategoryStruct.comp hom‚úù inv‚úù) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId‚úù : Homotopy (CategoryTheory.CategoryStruct.comp inv‚úù hom‚úù) (CategoryTheory.CategoryStruct.id D)\nhom : Quiver.Hom C D\ninv : Quiver.Hom D C\nhomotopyHomInvId : Homotopy (CategoryTheory.CategoryStruct.comp hom inv) (CategoryTheory.CategoryStruct.id C)\nhomotopyInvHomId : Homotopy (CategoryTheory.CategoryStruct.comp inv hom) (CategoryTheory.CategoryStruct.id D)\nx‚úù : Eq { hom := hom‚úù, inv := inv‚úù, homotopyHomInvId := homotopyHomInvId‚úù, homotopyInvHomId := homotopyInvHomId‚úù } { hom := hom, inv := inv, homotopyHomInvId := homotopyHomInvId, homotopyInvHomId := homotopyInvHomId }\n‚ä¢ And (Eq hom‚úù hom) (And (Eq inv‚úù inv) (And (HEq homotopyHomInvId‚úù homotopyHomInvId) (HEq homotopyInvHomId‚úù homotopyInvHomId)))","decl":"/-- A homotopy equivalence between two chain complexes consists of a chain map each way,\nand homotopies from the compositions to the identity chain maps.\n\nNote that this contains data;\narguably it might be more useful for many applications if we truncated it to a Prop.\n-/\nstructure HomotopyEquiv (C D : HomologicalComplex V c) where\n  hom : C ‚ü∂ D\n  inv : D ‚ü∂ C\n  homotopyHomInvId : Homotopy (hom ‚â´ inv) (ùüô C)\n  homotopyInvHomId : Homotopy (inv ‚â´ hom) (ùüô D)\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopy_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nf g : Quiver.Hom C D\nh : Homotopy f g\ni j : Œπ\n‚ä¢ Eq ((F.mapHomotopy h).hom i j) (F.map (h.hom i j))","decl":"/-- An additive functor takes homotopies to homotopies. -/\n@[simps]\ndef Functor.mapHomotopy (F : V ‚•§ W) [F.Additive] {f g : C ‚ü∂ D} (h : Homotopy f g) :\n    Homotopy ((F.mapHomologicalComplex c).map f) ((F.mapHomologicalComplex c).map g) where\n  hom i j := F.map (h.hom i j)\n  zero i j w := by dsimp; rw [h.zero i j w, F.map_zero]\n  comm i := by\n    have H := h.comm i\n    dsimp [dNext, prevD] at H ‚ä¢\n    simp [H]\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_homotopyInvHomId","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nh : HomotopyEquiv C D\n‚ä¢ Eq (F.mapHomotopyEquiv h).homotopyInvHomId (‚ãØ.mpr (‚ãØ.mpr (F.mapHomotopy h.homotopyInvHomId)))","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ‚•§ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_inv","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nh : HomotopyEquiv C D\n‚ä¢ Eq (F.mapHomotopyEquiv h).inv ((F.mapHomologicalComplex c).map h.inv)","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ‚•§ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_homotopyHomInvId","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nh : HomotopyEquiv C D\n‚ä¢ Eq (F.mapHomotopyEquiv h).homotopyHomInvId (‚ãØ.mpr (‚ãØ.mpr (F.mapHomotopy h.homotopyHomInvId)))","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ‚•§ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"CategoryTheory.Functor.mapHomotopyEquiv_hom","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"Œπ : Type u_1\nV : Type u\ninst‚úù‚Å¥ : CategoryTheory.Category.{v, u} V\ninst‚úù¬≥ : CategoryTheory.Preadditive V\nc : ComplexShape Œπ\nC D : HomologicalComplex V c\nW : Type u_2\ninst‚úù¬≤ : CategoryTheory.Category.{u_3, u_2} W\ninst‚úù¬π : CategoryTheory.Preadditive W\nF : CategoryTheory.Functor V W\ninst‚úù : F.Additive\nh : HomotopyEquiv C D\n‚ä¢ Eq (F.mapHomotopyEquiv h).hom ((F.mapHomologicalComplex c).map h.hom)","decl":"/-- An additive functor preserves homotopy equivalences. -/\n@[simps]\ndef Functor.mapHomotopyEquiv (F : V ‚•§ W) [F.Additive] (h : HomotopyEquiv C D) :\n    HomotopyEquiv ((F.mapHomologicalComplex c).obj C) ((F.mapHomologicalComplex c).obj D) where\n  hom := (F.mapHomologicalComplex c).map h.hom\n  inv := (F.mapHomologicalComplex c).map h.inv\n  homotopyHomInvId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyHomInvId\n  homotopyInvHomId := by\n    rw [‚Üê (F.mapHomologicalComplex c).map_comp, ‚Üê (F.mapHomologicalComplex c).map_id]\n    exact F.mapHomotopy h.homotopyInvHomId\n\n"}
{"name":"Homotopy.homologyMap_eq","module":"Mathlib.Algebra.Homology.Homotopy","initialProofState":"C : Type u_2\ninst‚úù‚Å¥ : CategoryTheory.Category.{u_3, u_2} C\ninst‚úù¬≥ : CategoryTheory.Preadditive C\nŒπ : Type u_4\nc : ComplexShape Œπ\ninst‚úù¬≤ : DecidableRel c.Rel\nK L : HomologicalComplex C c\nf g : Quiver.Hom K L\nho : Homotopy f g\ni : Œπ\ninst‚úù¬π : K.HasHomology i\ninst‚úù : L.HasHomology i\n‚ä¢ Eq (HomologicalComplex.homologyMap f i) (HomologicalComplex.homologyMap g i)","decl":"lemma Homotopy.homologyMap_eq (ho : Homotopy f g) (i : Œπ) [K.HasHomology i] [L.HasHomology i] :\n    homologyMap f i = homologyMap g i :=\n  ShortComplex.Homotopy.homologyMap_congr (ho.toShortComplex i)\n\n"}
