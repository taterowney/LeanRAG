{"name":"Configuration.instFiniteDual","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\ninst✝ : Finite P\n⊢ Finite (Configuration.Dual P)","decl":"instance [Finite P] : Finite (Dual P) :=\n  ‹Finite P›\n\n"}
{"name":"Configuration.Nondegenerate.eq_or_eq","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.Nondegenerate P L\np₁ p₂ : P\nl₁ l₂ : L\na✝³ : Membership.mem l₁ p₁\na✝² : Membership.mem l₁ p₂\na✝¹ : Membership.mem l₂ p₁\na✝ : Membership.mem l₂ p₂\n⊢ Or (Eq p₁ p₂) (Eq l₁ l₂)","decl":"/-- A configuration is nondegenerate if:\n  1) there does not exist a line that passes through all of the points,\n  2) there does not exist a point that is on all of the lines,\n  3) there is at most one line through any two points,\n  4) any two lines have at most one intersection point.\n  Conditions 3 and 4 are equivalent. -/\nclass Nondegenerate : Prop where\n  exists_point : ∀ l : L, ∃ p, p ∉ l\n  exists_line : ∀ p, ∃ l : L, p ∉ l\n  eq_or_eq : ∀ {p₁ p₂ : P} {l₁ l₂ : L}, p₁ ∈ l₁ → p₂ ∈ l₁ → p₁ ∈ l₂ → p₂ ∈ l₂ → p₁ = p₂ ∨ l₁ = l₂\n\n"}
{"name":"Configuration.Nondegenerate.exists_line","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.Nondegenerate P L\np : P\n⊢ Exists fun l => Not (Membership.mem l p)","decl":"/-- A configuration is nondegenerate if:\n  1) there does not exist a line that passes through all of the points,\n  2) there does not exist a point that is on all of the lines,\n  3) there is at most one line through any two points,\n  4) any two lines have at most one intersection point.\n  Conditions 3 and 4 are equivalent. -/\nclass Nondegenerate : Prop where\n  exists_point : ∀ l : L, ∃ p, p ∉ l\n  exists_line : ∀ p, ∃ l : L, p ∉ l\n  eq_or_eq : ∀ {p₁ p₂ : P} {l₁ l₂ : L}, p₁ ∈ l₁ → p₂ ∈ l₁ → p₁ ∈ l₂ → p₂ ∈ l₂ → p₁ = p₂ ∨ l₁ = l₂\n\n"}
{"name":"Configuration.Nondegenerate.exists_point","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.Nondegenerate P L\nl : L\n⊢ Exists fun p => Not (Membership.mem l p)","decl":"/-- A configuration is nondegenerate if:\n  1) there does not exist a line that passes through all of the points,\n  2) there does not exist a point that is on all of the lines,\n  3) there is at most one line through any two points,\n  4) any two lines have at most one intersection point.\n  Conditions 3 and 4 are equivalent. -/\nclass Nondegenerate : Prop where\n  exists_point : ∀ l : L, ∃ p, p ∉ l\n  exists_line : ∀ p, ∃ l : L, p ∉ l\n  eq_or_eq : ∀ {p₁ p₂ : P} {l₁ l₂ : L}, p₁ ∈ l₁ → p₂ ∈ l₁ → p₁ ∈ l₂ → p₂ ∈ l₂ → p₁ = p₂ ∨ l₁ = l₂\n\n"}
{"name":"Configuration.HasPoints.mkPoint_ax","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.HasPoints P L\nl₁ l₂ : L\nh : Ne l₁ l₂\n⊢ And (Membership.mem l₁ (Configuration.HasPoints.mkPoint h)) (Membership.mem l₂ (Configuration.HasPoints.mkPoint h))","decl":"/-- A nondegenerate configuration in which every pair of lines has an intersection point. -/\nclass HasPoints extends Nondegenerate P L where\n  mkPoint : ∀ {l₁ l₂ : L}, l₁ ≠ l₂ → P\n  mkPoint_ax : ∀ {l₁ l₂ : L} (h : l₁ ≠ l₂), mkPoint h ∈ l₁ ∧ mkPoint h ∈ l₂\n\n"}
{"name":"Configuration.HasPoints.toNondegenerate","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.HasPoints P L\n⊢ Configuration.Nondegenerate P L","decl":"/-- A nondegenerate configuration in which every pair of lines has an intersection point. -/\nclass HasPoints extends Nondegenerate P L where\n  mkPoint : ∀ {l₁ l₂ : L}, l₁ ≠ l₂ → P\n  mkPoint_ax : ∀ {l₁ l₂ : L} (h : l₁ ≠ l₂), mkPoint h ∈ l₁ ∧ mkPoint h ∈ l₂\n\n"}
{"name":"Configuration.HasLines.mkLine_ax","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.HasLines P L\np₁ p₂ : P\nh : Ne p₁ p₂\n⊢ And (Membership.mem (Configuration.HasLines.mkLine h) p₁) (Membership.mem (Configuration.HasLines.mkLine h) p₂)","decl":"/-- A nondegenerate configuration in which every pair of points has a line through them. -/\nclass HasLines extends Nondegenerate P L where\n  mkLine : ∀ {p₁ p₂ : P}, p₁ ≠ p₂ → L\n  mkLine_ax : ∀ {p₁ p₂ : P} (h : p₁ ≠ p₂), p₁ ∈ mkLine h ∧ p₂ ∈ mkLine h\n\n"}
{"name":"Configuration.HasLines.toNondegenerate","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.HasLines P L\n⊢ Configuration.Nondegenerate P L","decl":"/-- A nondegenerate configuration in which every pair of points has a line through them. -/\nclass HasLines extends Nondegenerate P L where\n  mkLine : ∀ {p₁ p₂ : P}, p₁ ≠ p₂ → L\n  mkLine_ax : ∀ {p₁ p₂ : P} (h : p₁ ≠ p₂), p₁ ∈ mkLine h ∧ p₂ ∈ mkLine h\n\n"}
{"name":"Configuration.Dual.Nondegenerate","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝¹ : Membership P L\ninst✝ : Configuration.Nondegenerate P L\n⊢ Configuration.Nondegenerate (Configuration.Dual L) (Configuration.Dual P)","decl":"instance Dual.Nondegenerate [Nondegenerate P L] : Nondegenerate (Dual L) (Dual P) where\n  exists_point := @exists_line P L _ _\n  exists_line := @exists_point P L _ _\n  eq_or_eq := @fun l₁ l₂ p₁ p₂ h₁ h₂ h₃ h₄ => (@eq_or_eq P L _ _ p₁ p₂ l₁ l₂ h₁ h₃ h₂ h₄).symm\n\n"}
{"name":"Configuration.HasPoints.existsUnique_point","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝¹ : Membership P L\ninst✝ : Configuration.HasPoints P L\nl₁ l₂ : L\nhl : Ne l₁ l₂\n⊢ ExistsUnique fun p => And (Membership.mem l₁ p) (Membership.mem l₂ p)","decl":"theorem HasPoints.existsUnique_point [HasPoints P L] (l₁ l₂ : L) (hl : l₁ ≠ l₂) :\n    ∃! p, p ∈ l₁ ∧ p ∈ l₂ :=\n  ⟨mkPoint hl, mkPoint_ax hl, fun _ hp =>\n    (eq_or_eq hp.1 (mkPoint_ax hl).1 hp.2 (mkPoint_ax hl).2).resolve_right hl⟩\n\n"}
{"name":"Configuration.HasLines.existsUnique_line","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝¹ : Membership P L\ninst✝ : Configuration.HasLines P L\np₁ p₂ : P\nhp : Ne p₁ p₂\n⊢ ExistsUnique fun l => And (Membership.mem l p₁) (Membership.mem l p₂)","decl":"theorem HasLines.existsUnique_line [HasLines P L] (p₁ p₂ : P) (hp : p₁ ≠ p₂) :\n    ∃! l : L, p₁ ∈ l ∧ p₂ ∈ l :=\n  HasPoints.existsUnique_point (Dual L) (Dual P) p₁ p₂ hp\n\n"}
{"name":"Configuration.Nondegenerate.exists_injective_of_card_le","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.Nondegenerate P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : LE.le (Fintype.card L) (Fintype.card P)\n⊢ Exists fun f => And (Function.Injective f) (∀ (l : L), Not (Membership.mem l (f l)))","decl":"/-- If a nondegenerate configuration has at least as many points as lines, then there exists\n  an injective function `f` from lines to points, such that `f l` does not lie on `l`. -/\ntheorem Nondegenerate.exists_injective_of_card_le [Nondegenerate P L] [Fintype P] [Fintype L]\n    (h : Fintype.card L ≤ Fintype.card P) : ∃ f : L → P, Function.Injective f ∧ ∀ l, f l ∉ l := by\n  classical\n    let t : L → Finset P := fun l => Set.toFinset { p | p ∉ l }\n    suffices ∀ s : Finset L, #s ≤ (s.biUnion t).card by\n      -- Hall's marriage theorem\n      obtain ⟨f, hf1, hf2⟩ := (Finset.all_card_le_biUnion_card_iff_exists_injective t).mp this\n      exact ⟨f, hf1, fun l => Set.mem_toFinset.mp (hf2 l)⟩\n    intro s\n    by_cases hs₀ : #s = 0\n    -- If `s = ∅`, then `#s = 0 ≤ #(s.bUnion t)`\n    · simp_rw [hs₀, zero_le]\n    by_cases hs₁ : #s = 1\n    -- If `s = {l}`, then pick a point `p ∉ l`\n    · obtain ⟨l, rfl⟩ := Finset.card_eq_one.mp hs₁\n      obtain ⟨p, hl⟩ := exists_point (P := P) l\n      rw [Finset.card_singleton, Finset.singleton_biUnion, Nat.one_le_iff_ne_zero]\n      exact Finset.card_ne_zero_of_mem (Set.mem_toFinset.mpr hl)\n    suffices #(s.biUnion t)ᶜ ≤ #sᶜ by\n      -- Rephrase in terms of complements (uses `h`)\n      rw [Finset.card_compl, Finset.card_compl, tsub_le_iff_left] at this\n      replace := h.trans this\n      rwa [← add_tsub_assoc_of_le s.card_le_univ, le_tsub_iff_left (le_add_left s.card_le_univ),\n        add_le_add_iff_right] at this\n    have hs₂ : #(s.biUnion t)ᶜ ≤ 1 := by\n      -- At most one line through two points of `s`\n      refine Finset.card_le_one_iff.mpr @fun p₁ p₂ hp₁ hp₂ => ?_\n      simp_rw [t, Finset.mem_compl, Finset.mem_biUnion, not_exists, not_and,\n        Set.mem_toFinset, Set.mem_setOf_eq, Classical.not_not] at hp₁ hp₂\n      obtain ⟨l₁, l₂, hl₁, hl₂, hl₃⟩ :=\n        Finset.one_lt_card_iff.mp (Nat.one_lt_iff_ne_zero_and_ne_one.mpr ⟨hs₀, hs₁⟩)\n      exact (eq_or_eq (hp₁ l₁ hl₁) (hp₂ l₁ hl₁) (hp₁ l₂ hl₂) (hp₂ l₂ hl₂)).resolve_right hl₃\n    by_cases hs₃ : #sᶜ = 0\n    · rw [hs₃, Nat.le_zero]\n      rw [Finset.card_compl, tsub_eq_zero_iff_le, LE.le.le_iff_eq (Finset.card_le_univ _), eq_comm,\n        Finset.card_eq_iff_eq_univ] at hs₃ ⊢\n      rw [hs₃]\n      rw [Finset.eq_univ_iff_forall] at hs₃ ⊢\n      exact fun p =>\n        Exists.elim (exists_line p)-- If `s = univ`, then show `s.bUnion t = univ`\n        fun l hl => Finset.mem_biUnion.mpr ⟨l, Finset.mem_univ l, Set.mem_toFinset.mpr hl⟩\n    · exact hs₂.trans (Nat.one_le_iff_ne_zero.mpr hs₃)\n\n-- If `s < univ`, then consequence of `hs₂`\n"}
{"name":"Configuration.sum_lineCount_eq_sum_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Eq (Finset.univ.sum fun p => Configuration.lineCount L p) (Finset.univ.sum fun l => Configuration.pointCount P l)","decl":"theorem sum_lineCount_eq_sum_pointCount [Fintype P] [Fintype L] :\n    ∑ p : P, lineCount L p = ∑ l : L, pointCount P l := by\n  classical\n    simp only [lineCount, pointCount, Nat.card_eq_fintype_card, ← Fintype.card_sigma]\n    apply Fintype.card_congr\n    calc\n      (Σp, { l : L // p ∈ l }) ≃ { x : P × L // x.1 ∈ x.2 } :=\n        (Equiv.subtypeProdEquivSigmaSubtype (· ∈ ·)).symm\n      _ ≃ { x : L × P // x.2 ∈ x.1 } := (Equiv.prodComm P L).subtypeEquiv fun x => Iff.rfl\n      _ ≃ Σl, { p // p ∈ l } := Equiv.subtypeProdEquivSigmaSubtype fun (l : L) (p : P) => p ∈ l\n\n"}
{"name":"Configuration.HasLines.pointCount_le_lineCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝² : Membership P L\ninst✝¹ : Configuration.HasLines P L\np : P\nl : L\nh : Not (Membership.mem l p)\ninst✝ : Finite (Subtype fun l => Membership.mem l p)\n⊢ LE.le (Configuration.pointCount P l) (Configuration.lineCount L p)","decl":"theorem HasLines.pointCount_le_lineCount [HasLines P L] {p : P} {l : L} (h : p ∉ l)\n    [Finite { l : L // p ∈ l }] : pointCount P l ≤ lineCount L p := by\n  by_cases hf : Infinite { p : P // p ∈ l }\n  · exact (le_of_eq Nat.card_eq_zero_of_infinite).trans (zero_le (lineCount L p))\n  haveI := fintypeOfNotInfinite hf\n  cases nonempty_fintype { l : L // p ∈ l }\n  rw [lineCount, pointCount, Nat.card_eq_fintype_card, Nat.card_eq_fintype_card]\n  have : ∀ p' : { p // p ∈ l }, p ≠ p' := fun p' hp' => h ((congr_arg (· ∈ l) hp').mpr p'.2)\n  exact\n    Fintype.card_le_of_injective (fun p' => ⟨mkLine (this p'), (mkLine_ax (this p')).1⟩)\n      fun p₁ p₂ hp =>\n      Subtype.ext ((eq_or_eq p₁.2 p₂.2 (mkLine_ax (this p₁)).2\n            ((congr_arg (_ ∈ ·) (Subtype.ext_iff.mp hp)).mpr (mkLine_ax (this p₂)).2)).resolve_right\n          fun h' => (congr_arg (¬p ∈ ·) h').mp h (mkLine_ax (this p₁)).1)\n\n"}
{"name":"Configuration.HasPoints.lineCount_le_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝¹ : Membership P L\ninst✝ : Configuration.HasPoints P L\np : P\nl : L\nh : Not (Membership.mem l p)\nhf : Finite (Subtype fun p => Membership.mem l p)\n⊢ LE.le (Configuration.lineCount L p) (Configuration.pointCount P l)","decl":"theorem HasPoints.lineCount_le_pointCount [HasPoints P L] {p : P} {l : L} (h : p ∉ l)\n    [hf : Finite { p : P // p ∈ l }] : lineCount L p ≤ pointCount P l :=\n  @HasLines.pointCount_le_lineCount (Dual L) (Dual P) _ _ l p h hf\n\n"}
{"name":"Configuration.HasLines.card_le","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ LE.le (Fintype.card P) (Fintype.card L)","decl":"/-- If a nondegenerate configuration has a unique line through any two points, then `|P| ≤ |L|`. -/\ntheorem HasLines.card_le [HasLines P L] [Fintype P] [Fintype L] :\n    Fintype.card P ≤ Fintype.card L := by\n  classical\n  by_contra hc₂\n  obtain ⟨f, hf₁, hf₂⟩ := Nondegenerate.exists_injective_of_card_le (le_of_not_le hc₂)\n  have :=\n    calc\n      ∑ p, lineCount L p = ∑ l, pointCount P l := sum_lineCount_eq_sum_pointCount P L\n      _ ≤ ∑ l, lineCount L (f l) :=\n        (Finset.sum_le_sum fun l _ => HasLines.pointCount_le_lineCount (hf₂ l))\n      _ = ∑ p ∈ univ.map ⟨f, hf₁⟩, lineCount L p := by rw [sum_map]; dsimp\n      _ < ∑ p, lineCount L p := by\n        obtain ⟨p, hp⟩ := not_forall.mp (mt (Fintype.card_le_of_surjective f) hc₂)\n        refine sum_lt_sum_of_subset (subset_univ _) (mem_univ p) ?_ ?_ fun p _ _ ↦ zero_le _\n        · simpa only [Finset.mem_map, exists_prop, Finset.mem_univ, true_and]\n        · rw [lineCount, Nat.card_eq_fintype_card, Fintype.card_pos_iff]\n          obtain ⟨l, _⟩ := @exists_line P L _ _ p\n          exact\n            let this := not_exists.mp hp l\n            ⟨⟨mkLine this, (mkLine_ax this).2⟩⟩\n  exact lt_irrefl _ this\n\n"}
{"name":"Configuration.HasPoints.card_le","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.HasPoints P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ LE.le (Fintype.card L) (Fintype.card P)","decl":"/-- If a nondegenerate configuration has a unique point on any two lines, then `|L| ≤ |P|`. -/\ntheorem HasPoints.card_le [HasPoints P L] [Fintype P] [Fintype L] :\n    Fintype.card L ≤ Fintype.card P :=\n  @HasLines.card_le (Dual L) (Dual P) _ _ _ _\n\n"}
{"name":"Configuration.HasLines.exists_bijective_of_card_eq","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nh : Eq (Fintype.card P) (Fintype.card L)\n⊢ Exists fun f => And (Function.Bijective f) (∀ (l : L), Eq (Configuration.pointCount P l) (Configuration.lineCount L (f l)))","decl":"theorem HasLines.exists_bijective_of_card_eq [HasLines P L] [Fintype P] [Fintype L]\n    (h : Fintype.card P = Fintype.card L) :\n    ∃ f : L → P, Function.Bijective f ∧ ∀ l, pointCount P l = lineCount L (f l) := by\n  classical\n    obtain ⟨f, hf1, hf2⟩ := Nondegenerate.exists_injective_of_card_le (ge_of_eq h)\n    have hf3 := (Fintype.bijective_iff_injective_and_card f).mpr ⟨hf1, h.symm⟩\n    exact ⟨f, hf3, fun l ↦ (sum_eq_sum_iff_of_le fun l _ ↦ pointCount_le_lineCount (hf2 l)).1\n          ((hf3.sum_comp _).trans (sum_lineCount_eq_sum_pointCount P L)).symm _ <| mem_univ _⟩\n\n"}
{"name":"Configuration.HasLines.lineCount_eq_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.HasLines P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Eq (Fintype.card P) (Fintype.card L)\np : P\nl : L\nhpl : Not (Membership.mem l p)\n⊢ Eq (Configuration.lineCount L p) (Configuration.pointCount P l)","decl":"theorem HasLines.lineCount_eq_pointCount [HasLines P L] [Fintype P] [Fintype L]\n    (hPL : Fintype.card P = Fintype.card L) {p : P} {l : L} (hpl : p ∉ l) :\n    lineCount L p = pointCount P l := by\n  classical\n    obtain ⟨f, hf1, hf2⟩ := HasLines.exists_bijective_of_card_eq hPL\n    let s : Finset (P × L) := Set.toFinset { i | i.1 ∈ i.2 }\n    have step1 : ∑ i : P × L, lineCount L i.1 = ∑ i : P × L, pointCount P i.2 := by\n      rw [← Finset.univ_product_univ, Finset.sum_product_right, Finset.sum_product]\n      simp_rw [Finset.sum_const, Finset.card_univ, hPL, sum_lineCount_eq_sum_pointCount]\n    have step2 : ∑ i ∈ s, lineCount L i.1 = ∑ i ∈ s, pointCount P i.2 := by\n      rw [s.sum_finset_product Finset.univ fun p => Set.toFinset { l | p ∈ l }]\n      on_goal 1 =>\n        rw [s.sum_finset_product_right Finset.univ fun l => Set.toFinset { p | p ∈ l }, eq_comm]\n        · refine sum_bijective _ hf1 (by simp) fun l _ ↦ ?_\n          simp_rw [hf2, sum_const, Set.toFinset_card, ← Nat.card_eq_fintype_card]\n          change pointCount P l • _ = lineCount L (f l) • _\n          rw [hf2]\n      all_goals simp_rw [s, Finset.mem_univ, true_and, Set.mem_toFinset]; exact fun p => Iff.rfl\n    have step3 : ∑ i ∈ sᶜ, lineCount L i.1 = ∑ i ∈ sᶜ, pointCount P i.2 := by\n      rwa [← s.sum_add_sum_compl, ← s.sum_add_sum_compl, step2, add_left_cancel_iff] at step1\n    rw [← Set.toFinset_compl] at step3\n    exact\n      ((Finset.sum_eq_sum_iff_of_le fun i hi =>\n              HasLines.pointCount_le_lineCount (by exact Set.mem_toFinset.mp hi)).mp\n          step3.symm (p, l) (Set.mem_toFinset.mpr hpl)).symm\n\n"}
{"name":"Configuration.HasPoints.lineCount_eq_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.HasPoints P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\nhPL : Eq (Fintype.card P) (Fintype.card L)\np : P\nl : L\nhpl : Not (Membership.mem l p)\n⊢ Eq (Configuration.lineCount L p) (Configuration.pointCount P l)","decl":"theorem HasPoints.lineCount_eq_pointCount [HasPoints P L] [Fintype P] [Fintype L]\n    (hPL : Fintype.card P = Fintype.card L) {p : P} {l : L} (hpl : p ∉ l) :\n    lineCount L p = pointCount P l :=\n  (@HasLines.lineCount_eq_pointCount (Dual L) (Dual P) _ _ _ _ hPL.symm l p hpl).symm\n\n"}
{"name":"Configuration.ProjectivePlane.mkLine_ax","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.ProjectivePlane P L\np₁ p₂ : P\nh : Ne p₁ p₂\n⊢ And (Membership.mem (Configuration.ProjectivePlane.mkLine h) p₁) (Membership.mem (Configuration.ProjectivePlane.mkLine h) p₂)","decl":"/-- A projective plane is a nondegenerate configuration in which every pair of lines has\n  an intersection point, every pair of points has a line through them,\n  and which has three points in general position. -/\nclass ProjectivePlane extends HasPoints P L, HasLines P L where\n  exists_config :\n    ∃ (p₁ p₂ p₃ : P) (l₁ l₂ l₃ : L),\n      p₁ ∉ l₂ ∧ p₁ ∉ l₃ ∧ p₂ ∉ l₁ ∧ p₂ ∈ l₂ ∧ p₂ ∈ l₃ ∧ p₃ ∉ l₁ ∧ p₃ ∈ l₂ ∧ p₃ ∉ l₃\n\n"}
{"name":"Configuration.ProjectivePlane.exists_config","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝ : Membership P L\nself : Configuration.ProjectivePlane P L\n⊢ Exists fun p₁ => Exists fun p₂ => Exists fun p₃ => Exists fun l₁ => Exists fun l₂ => Exists fun l₃ => And (Not (Membership.mem l₂ p₁)) (And (Not (Membership.mem l₃ p₁)) (And (Not (Membership.mem l₁ p₂)) (And (Membership.mem l₂ p₂) (And (Membership.mem l₃ p₂) (And (Not (Membership.mem l₁ p₃)) (And (Membership.mem l₂ p₃) (Not (Membership.mem l₃ p₃))))))))","decl":"/-- A projective plane is a nondegenerate configuration in which every pair of lines has\n  an intersection point, every pair of points has a line through them,\n  and which has three points in general position. -/\nclass ProjectivePlane extends HasPoints P L, HasLines P L where\n  exists_config :\n    ∃ (p₁ p₂ p₃ : P) (l₁ l₂ l₃ : L),\n      p₁ ∉ l₂ ∧ p₁ ∉ l₃ ∧ p₂ ∉ l₁ ∧ p₂ ∈ l₂ ∧ p₂ ∈ l₃ ∧ p₃ ∉ l₁ ∧ p₃ ∈ l₂ ∧ p₃ ∉ l₃\n\n"}
{"name":"Configuration.ProjectivePlane.card_points_eq_card_lines","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Fintype L\n⊢ Eq (Fintype.card P) (Fintype.card L)","decl":"theorem card_points_eq_card_lines [Fintype P] [Fintype L] : Fintype.card P = Fintype.card L :=\n  le_antisymm (HasLines.card_le P L) (HasPoints.card_le P L)\n\n"}
{"name":"Configuration.ProjectivePlane.lineCount_eq_lineCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np q : P\n⊢ Eq (Configuration.lineCount L p) (Configuration.lineCount L q)","decl":"theorem lineCount_eq_lineCount [Finite P] [Finite L] (p q : P) : lineCount L p = lineCount L q := by\n  cases nonempty_fintype P\n  cases nonempty_fintype L\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, h₁₂, h₁₃, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  have h := card_points_eq_card_lines P L\n  let n := lineCount L p₂\n  have hp₂ : lineCount L p₂ = n := rfl\n  have hl₁ : pointCount P l₁ = n := (HasLines.lineCount_eq_pointCount h h₂₁).symm.trans hp₂\n  have hp₃ : lineCount L p₃ = n := (HasLines.lineCount_eq_pointCount h h₃₁).trans hl₁\n  have hl₃ : pointCount P l₃ = n := (HasLines.lineCount_eq_pointCount h h₃₃).symm.trans hp₃\n  have hp₁ : lineCount L p₁ = n := (HasLines.lineCount_eq_pointCount h h₁₃).trans hl₃\n  have hl₂ : pointCount P l₂ = n := (HasLines.lineCount_eq_pointCount h h₁₂).symm.trans hp₁\n  suffices ∀ p : P, lineCount L p = n by exact (this p).trans (this q).symm\n  refine fun p =>\n    or_not.elim (fun h₂ => ?_) fun h₂ => (HasLines.lineCount_eq_pointCount h h₂).trans hl₂\n  refine or_not.elim (fun h₃ => ?_) fun h₃ => (HasLines.lineCount_eq_pointCount h h₃).trans hl₃\n  rw [(eq_or_eq h₂ h₂₂ h₃ h₂₃).resolve_right fun h =>\n      h₃₃ ((congr_arg (p₃ ∈ ·) h).mp h₃₂)]\n\n"}
{"name":"Configuration.ProjectivePlane.pointCount_eq_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl m : L\n⊢ Eq (Configuration.pointCount P l) (Configuration.pointCount P m)","decl":"theorem pointCount_eq_pointCount [Finite P] [Finite L] (l m : L) :\n    pointCount P l = pointCount P m := by\n  apply lineCount_eq_lineCount (Dual P)\n\n"}
{"name":"Configuration.ProjectivePlane.lineCount_eq_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\nl : L\n⊢ Eq (Configuration.lineCount L p) (Configuration.pointCount P l)","decl":"theorem lineCount_eq_pointCount [Finite P] [Finite L] (p : P) (l : L) :\n    lineCount L p = pointCount P l :=\n  Exists.elim (exists_point l) fun q hq =>\n    (lineCount_eq_lineCount L p q).trans <| by\n      cases nonempty_fintype P\n      cases nonempty_fintype L\n      exact HasLines.lineCount_eq_pointCount (card_points_eq_card_lines P L) hq\n\n"}
{"name":"Configuration.ProjectivePlane.Dual.order","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\n⊢ Eq (Configuration.ProjectivePlane.order (Configuration.Dual L) (Configuration.Dual P)) (Configuration.ProjectivePlane.order P L)","decl":"theorem Dual.order [Finite P] [Finite L] : order (Dual L) (Dual P) = order P L :=\n  congr_arg (fun n => n - 1) (lineCount_eq_pointCount _ _)\n\n"}
{"name":"Configuration.ProjectivePlane.lineCount_eq","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ Eq (Configuration.lineCount L p) (HAdd.hAdd (Configuration.ProjectivePlane.order P L) 1)","decl":"theorem lineCount_eq [Finite P] [Finite L] (p : P) : lineCount L p = order P L + 1 := by\n  classical\n    obtain ⟨q, -, -, l, -, -, -, -, h, -⟩ := Classical.choose_spec (@exists_config P L _ _)\n    cases nonempty_fintype { l : L // q ∈ l }\n    rw [order, lineCount_eq_lineCount L p q, lineCount_eq_lineCount L (Classical.choose _) q,\n      lineCount, Nat.card_eq_fintype_card, Nat.sub_add_cancel]\n    exact Fintype.card_pos_iff.mpr ⟨⟨l, h⟩⟩\n\n"}
{"name":"Configuration.ProjectivePlane.pointCount_eq","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl : L\n⊢ Eq (Configuration.pointCount P l) (HAdd.hAdd (Configuration.ProjectivePlane.order P L) 1)","decl":"theorem pointCount_eq [Finite P] [Finite L] (l : L) : pointCount P l = order P L + 1 :=\n  (lineCount_eq (Dual P) _).trans (congr_arg (fun n => n + 1) (Dual.order P L))\n\n"}
{"name":"Configuration.ProjectivePlane.one_lt_order","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\n⊢ LT.lt 1 (Configuration.ProjectivePlane.order P L)","decl":"theorem one_lt_order [Finite P] [Finite L] : 1 < order P L := by\n  obtain ⟨p₁, p₂, p₃, l₁, l₂, l₃, -, -, h₂₁, h₂₂, h₂₃, h₃₁, h₃₂, h₃₃⟩ := @exists_config P L _ _\n  cases nonempty_fintype { p : P // p ∈ l₂ }\n  rw [← add_lt_add_iff_right 1, ← pointCount_eq _ l₂, pointCount, Nat.card_eq_fintype_card,\n    Fintype.two_lt_card_iff]\n  simp_rw [Ne, Subtype.ext_iff]\n  have h := mkPoint_ax (P := P) (L := L) fun h => h₂₁ ((congr_arg (p₂ ∈ ·) h).mpr h₂₂)\n  exact\n    ⟨⟨mkPoint _, h.2⟩, ⟨p₂, h₂₂⟩, ⟨p₃, h₃₂⟩, ne_of_mem_of_not_mem h.1 h₂₁,\n      ne_of_mem_of_not_mem h.1 h₃₁, ne_of_mem_of_not_mem h₂₃ h₃₃⟩\n\n"}
{"name":"Configuration.ProjectivePlane.two_lt_lineCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\np : P\n⊢ LT.lt 2 (Configuration.lineCount L p)","decl":"theorem two_lt_lineCount [Finite P] [Finite L] (p : P) : 2 < lineCount L p := by\n  simpa only [lineCount_eq L p, Nat.succ_lt_succ_iff] using one_lt_order P L\n\n"}
{"name":"Configuration.ProjectivePlane.two_lt_pointCount","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Finite L\nl : L\n⊢ LT.lt 2 (Configuration.pointCount P l)","decl":"theorem two_lt_pointCount [Finite P] [Finite L] (l : L) : 2 < pointCount P l := by\n  simpa only [pointCount_eq P l, Nat.succ_lt_succ_iff] using one_lt_order P L\n\n"}
{"name":"Configuration.ProjectivePlane.card_points","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Fintype P\ninst✝ : Finite L\n⊢ Eq (Fintype.card P) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Configuration.ProjectivePlane.order P L) 2) (Configuration.ProjectivePlane.order P L)) 1)","decl":"theorem card_points [Fintype P] [Finite L] : Fintype.card P = order P L ^ 2 + order P L + 1 := by\n  cases nonempty_fintype L\n  obtain ⟨p, -⟩ := @exists_config P L _ _\n  let ϕ : { q // q ≠ p } ≃ Σl : { l : L // p ∈ l }, { q // q ∈ l.1 ∧ q ≠ p } :=\n    { toFun := fun q => ⟨⟨mkLine q.2, (mkLine_ax q.2).2⟩, q, (mkLine_ax q.2).1, q.2⟩\n      invFun := fun lq => ⟨lq.2, lq.2.2.2⟩\n      left_inv := fun q => Subtype.ext rfl\n      right_inv := fun lq =>\n        Sigma.subtype_ext\n          (Subtype.ext\n            ((eq_or_eq (mkLine_ax lq.2.2.2).1 (mkLine_ax lq.2.2.2).2 lq.2.2.1 lq.1.2).resolve_left\n              lq.2.2.2))\n          rfl }\n  classical\n    have h1 : Fintype.card { q // q ≠ p } + 1 = Fintype.card P := by\n      apply (eq_tsub_iff_add_eq_of_le (Nat.succ_le_of_lt (Fintype.card_pos_iff.mpr ⟨p⟩))).mp\n      convert (Fintype.card_subtype_compl _).trans (congr_arg _ (Fintype.card_subtype_eq p))\n    have h2 : ∀ l : { l : L // p ∈ l }, Fintype.card { q // q ∈ l.1 ∧ q ≠ p } = order P L := by\n      intro l\n      rw [← Fintype.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (· ∈ l.val) (· ≠ p)),\n        Fintype.card_subtype_compl fun x : Subtype (· ∈ l.val) => x.val = p, ←\n        Nat.card_eq_fintype_card]\n      refine tsub_eq_of_eq_add ((pointCount_eq P l.1).trans ?_)\n      rw [← Fintype.card_subtype_eq (⟨p, l.2⟩ : { q : P // q ∈ l.1 })]\n      simp_rw [Subtype.ext_iff_val]\n    simp_rw [← h1, Fintype.card_congr ϕ, Fintype.card_sigma, h2, Finset.sum_const, Finset.card_univ]\n    rw [← Nat.card_eq_fintype_card, ← lineCount, lineCount_eq, smul_eq_mul, Nat.succ_mul, sq]\n\n"}
{"name":"Configuration.ProjectivePlane.card_lines","module":"Mathlib.Combinatorics.Configuration","initialProofState":"P : Type u_1\nL : Type u_2\ninst✝³ : Membership P L\ninst✝² : Configuration.ProjectivePlane P L\ninst✝¹ : Finite P\ninst✝ : Fintype L\n⊢ Eq (Fintype.card L) (HAdd.hAdd (HAdd.hAdd (HPow.hPow (Configuration.ProjectivePlane.order P L) 2) (Configuration.ProjectivePlane.order P L)) 1)","decl":"theorem card_lines [Finite P] [Fintype L] : Fintype.card L = order P L ^ 2 + order P L + 1 :=\n  (card_points (Dual L) (Dual P)).trans (congr_arg (fun n => n ^ 2 + n + 1) (Dual.order P L))\n\n"}
{"name":"Configuration.ofField.mem_iff","module":"Mathlib.Combinatorics.Configuration","initialProofState":"K : Type u_3\ninst✝ : Field K\nv w : Projectivization K (Fin 3 → K)\n⊢ Iff (Membership.mem w v) (v.orthogonal w)","decl":"lemma mem_iff (v w : ℙ K (Fin 3 → K)) : v ∈ w ↔ orthogonal v w :=\n  Iff.rfl\n\n-- This lemma can't be moved to the crossProduct file due to heavy imports\n"}
{"name":"Configuration.ofField.crossProduct_eq_zero_of_dotProduct_eq_zero","module":"Mathlib.Combinatorics.Configuration","initialProofState":"K : Type u_3\ninst✝ : Field K\na b c d : Fin 3 → K\nhac : Eq (dotProduct a c) 0\nhbc : Eq (dotProduct b c) 0\nhad : Eq (dotProduct a d) 0\nhbd : Eq (dotProduct b d) 0\n⊢ Or (Eq ((crossProduct a) b) 0) (Eq ((crossProduct c) d) 0)","decl":"lemma crossProduct_eq_zero_of_dotProduct_eq_zero {a b c d : Fin 3 → K} (hac : dotProduct a c = 0)\n    (hbc : dotProduct b c = 0) (had : dotProduct a d = 0) (hbd : dotProduct b d = 0) :\n    crossProduct a b = 0 ∨ crossProduct c d = 0 := by\n  by_contra h\n  simp_rw [not_or, ← ne_eq, crossProduct_ne_zero_iff_linearIndependent] at h\n  let A : Matrix (Fin 2) (Fin 3) K := ![a, b]\n  let B : Matrix (Fin 2) (Fin 3) K := ![c, d]\n  have hAB : A * B.transpose = 0 := by\n    ext i j\n    fin_cases i <;> fin_cases j <;> assumption\n  replace hAB := rank_add_rank_le_card_of_mul_eq_zero hAB\n  rw [rank_transpose, h.1.rank_matrix, h.2.rank_matrix, Fintype.card_fin, Fintype.card_fin] at hAB\n  contradiction\n\n"}
{"name":"Configuration.ofField.eq_or_eq_of_orthogonal","module":"Mathlib.Combinatorics.Configuration","initialProofState":"K : Type u_3\ninst✝ : Field K\na b c d : Projectivization K (Fin 3 → K)\nhac : a.orthogonal c\nhbc : b.orthogonal c\nhad : a.orthogonal d\nhbd : b.orthogonal d\n⊢ Or (Eq a b) (Eq c d)","decl":"lemma eq_or_eq_of_orthogonal {a b c d : ℙ K (Fin 3 → K)} (hac : a.orthogonal c)\n    (hbc : b.orthogonal c) (had : a.orthogonal d) (hbd : b.orthogonal d) :\n    a = b ∨ c = d := by\n  induction' a with a ha\n  induction' b with b hb\n  induction' c with c hc\n  induction' d with d hd\n  rw [mk_eq_mk_iff_crossProduct_eq_zero, mk_eq_mk_iff_crossProduct_eq_zero]\n  exact crossProduct_eq_zero_of_dotProduct_eq_zero hac hbc had hbd\n\n"}
{"name":"Configuration.ofField.instNondegenerateProjectivizationForallFinOfNatNat","module":"Mathlib.Combinatorics.Configuration","initialProofState":"K : Type u_3\ninst✝ : Field K\n⊢ Configuration.Nondegenerate (Projectivization K (Fin 3 → K)) (Projectivization K (Fin 3 → K))","decl":"instance : Nondegenerate (ℙ K (Fin 3 → K)) (ℙ K (Fin 3 → K)) :=\n  { exists_point := exists_not_orthogonal_self\n    exists_line := exists_not_self_orthogonal\n    eq_or_eq := eq_or_eq_of_orthogonal }\n\n"}
