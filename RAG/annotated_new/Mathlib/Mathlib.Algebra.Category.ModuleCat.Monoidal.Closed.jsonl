{"name":"ModuleCat.ihom_map_apply","module":"Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed","initialProofState":"R : Type u\ninst✝ : CommRing R\nM N P : ModuleCat R\nf : Quiver.Hom N P\ng : ↑(ModuleCat.of R (Quiver.Hom M N))\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((CategoryTheory.ihom M).map f)) g) (CategoryTheory.CategoryStruct.comp g f)","decl":"theorem ihom_map_apply {M N P : ModuleCat.{u} R} (f : N ⟶ P) (g : ModuleCat.of R (M ⟶ N)) :\n    (ihom M).map f g = g ≫ f :=\n  rfl\n\n"}
{"name":"ModuleCat.monoidalClosed_curry","module":"Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed","initialProofState":"R : Type u\ninst✝ : CommRing R\nM N P : ModuleCat R\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj M N) P\nx : ↑M\ny : ↑N\n⊢ Eq ((ModuleCat.Hom.hom ((ModuleCat.Hom.hom (CategoryTheory.MonoidalClosed.curry f)) y)) x) ((CategoryTheory.ConcreteCategory.hom f) (TensorProduct.tmul R x y))","decl":"theorem monoidalClosed_curry {M N P : ModuleCat.{u} R} (f : M ⊗ N ⟶ P) (x : M) (y : N) :\n    ((MonoidalClosed.curry f).hom y).hom x = f (x ⊗ₜ[R] y) :=\n  rfl\n\n"}
{"name":"ModuleCat.monoidalClosed_uncurry","module":"Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed","initialProofState":"R : Type u\ninst✝ : CommRing R\nM N P : ModuleCat R\nf : Quiver.Hom N ((CategoryTheory.ihom M).obj P)\nx : ↑M\ny : ↑N\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.MonoidalClosed.uncurry f)) (TensorProduct.tmul R x y)) ((ModuleCat.Hom.hom ((CategoryTheory.ConcreteCategory.hom f) y)) x)","decl":"@[simp]\ntheorem monoidalClosed_uncurry\n    {M N P : ModuleCat.{u} R} (f : N ⟶ M ⟶[ModuleCat.{u} R] P) (x : M) (y : N) :\n    MonoidalClosed.uncurry f (x ⊗ₜ[R] y) = (f y).hom x :=\n  rfl\n\n"}
{"name":"ModuleCat.ihom_ev_app","module":"Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed","initialProofState":"R : Type u\ninst✝ : CommRing R\nM N : ModuleCat R\n⊢ Eq ((CategoryTheory.ihom.ev M).app N) (ModuleCat.ofHom ((TensorProduct.uncurry R ↑M ↑((CategoryTheory.ihom M).obj N) ↑N) ((LinearMap.lcomp R ↑N ↑ModuleCat.homLinearEquiv).comp LinearMap.id.flip)))","decl":"/-- Describes the counit of the adjunction `M ⊗ - ⊣ Hom(M, -)`. Given an `R`-module `N` this\nshould give a map `M ⊗ Hom(M, N) ⟶ N`, so we flip the order of the arguments in the identity map\n`Hom(M, N) ⟶ (M ⟶ N)` and uncurry the resulting map `M ⟶ Hom(M, N) ⟶ N.` -/\ntheorem ihom_ev_app (M N : ModuleCat.{u} R) :\n    (ihom.ev M).app N = ModuleCat.ofHom (TensorProduct.uncurry R M ((ihom M).obj N) N\n      (LinearMap.lcomp _ _ homLinearEquiv.toLinearMap ∘ₗ LinearMap.id.flip)) := by\n  rw [← MonoidalClosed.uncurry_id_eq_ev]\n  ext : 1\n  apply TensorProduct.ext'\n  apply monoidalClosed_uncurry\n\n"}
{"name":"ModuleCat.ihom_coev_app","module":"Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed","initialProofState":"R : Type u\ninst✝ : CommRing R\nM N : ModuleCat R\n⊢ Eq ((CategoryTheory.ihom.coev M).app N) (ModuleCat.ofHom₂ (TensorProduct.mk R ↑(Opposite.unop { unop := M }) ↑((CategoryTheory.Functor.id (ModuleCat R)).obj N)).flip)","decl":"/-- Describes the unit of the adjunction `M ⊗ - ⊣ Hom(M, -)`. Given an `R`-module `N` this should\ndefine a map `N ⟶ Hom(M, M ⊗ N)`, which is given by flipping the arguments in the natural\n`R`-bilinear map `M ⟶ N ⟶ M ⊗ N`. -/\ntheorem ihom_coev_app (M N : ModuleCat.{u} R) :\n    (ihom.coev M).app N = ModuleCat.ofHom₂ (TensorProduct.mk _ _ _).flip :=\n  rfl\n\n"}
{"name":"ModuleCat.monoidalClosed_pre_app","module":"Mathlib.Algebra.Category.ModuleCat.Monoidal.Closed","initialProofState":"R : Type u\ninst✝ : CommRing R\nM N P : ModuleCat R\nf : Quiver.Hom N M\n⊢ Eq ((CategoryTheory.MonoidalClosed.pre f).app P) (ModuleCat.ofHom ((↑ModuleCat.homLinearEquiv.symm).comp ((LinearMap.lcomp R (↑P) (ModuleCat.Hom.hom f)).comp ↑ModuleCat.homLinearEquiv)))","decl":"theorem monoidalClosed_pre_app {M N : ModuleCat.{u} R} (P : ModuleCat.{u} R) (f : N ⟶ M) :\n    (MonoidalClosed.pre f).app P = ofHom (homLinearEquiv.symm.toLinearMap ∘ₗ\n      LinearMap.lcomp _ _ f.hom ∘ₗ homLinearEquiv.toLinearMap) :=\n  rfl\n\n"}
