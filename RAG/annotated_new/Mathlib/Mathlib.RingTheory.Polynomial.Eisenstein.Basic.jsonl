{"name":"Polynomial.IsWeaklyEisensteinAt.mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nf : Polynomial R\nğ“Ÿ : Ideal R\nself : f.IsWeaklyEisensteinAt ğ“Ÿ\nn : Nat\naâœ : LT.lt n f.natDegree\nâŠ¢ Membership.mem ğ“Ÿ (f.coeff n)","decl":"/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *weakly Eisenstein at `ğ“Ÿ`* if `âˆ€ n, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ`. -/\n@[mk_iff]\nstructure IsWeaklyEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where\n  mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ\n\n"}
{"name":"Polynomial.isWeaklyEisensteinAt_iff","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nf : Polynomial R\nğ“Ÿ : Ideal R\nâŠ¢ Iff (f.IsWeaklyEisensteinAt ğ“Ÿ) (âˆ€ {n : Nat}, LT.lt n f.natDegree â†’ Membership.mem ğ“Ÿ (f.coeff n))","decl":"/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *weakly Eisenstein at `ğ“Ÿ`* if `âˆ€ n, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ`. -/\n@[mk_iff]\nstructure IsWeaklyEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where\n  mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ\n\n"}
{"name":"Polynomial.isEisensteinAt_iff","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nf : Polynomial R\nğ“Ÿ : Ideal R\nâŠ¢ Iff (f.IsEisensteinAt ğ“Ÿ) (And (Not (Membership.mem ğ“Ÿ f.leadingCoeff)) (And (âˆ€ {n : Nat}, LT.lt n f.natDegree â†’ Membership.mem ğ“Ÿ (f.coeff n)) (Not (Membership.mem (HPow.hPow ğ“Ÿ 2) (f.coeff 0)))))","decl":"/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `ğ“Ÿ`* if `f.leadingCoeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ` and\n`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where\n  leading : f.leadingCoeff âˆ‰ ğ“Ÿ\n  mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ\n  not_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2\n\n"}
{"name":"Polynomial.IsEisensteinAt.leading","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nf : Polynomial R\nğ“Ÿ : Ideal R\nself : f.IsEisensteinAt ğ“Ÿ\nâŠ¢ Not (Membership.mem ğ“Ÿ f.leadingCoeff)","decl":"/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `ğ“Ÿ`* if `f.leadingCoeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ` and\n`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where\n  leading : f.leadingCoeff âˆ‰ ğ“Ÿ\n  mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ\n  not_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2\n\n"}
{"name":"Polynomial.IsEisensteinAt.mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nf : Polynomial R\nğ“Ÿ : Ideal R\nself : f.IsEisensteinAt ğ“Ÿ\nn : Nat\naâœ : LT.lt n f.natDegree\nâŠ¢ Membership.mem ğ“Ÿ (f.coeff n)","decl":"/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `ğ“Ÿ`* if `f.leadingCoeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ` and\n`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where\n  leading : f.leadingCoeff âˆ‰ ğ“Ÿ\n  mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ\n  not_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2\n\n"}
{"name":"Polynomial.IsEisensteinAt.not_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nf : Polynomial R\nğ“Ÿ : Ideal R\nself : f.IsEisensteinAt ğ“Ÿ\nâŠ¢ Not (Membership.mem (HPow.hPow ğ“Ÿ 2) (f.coeff 0))","decl":"/-- Given an ideal `ğ“Ÿ` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `ğ“Ÿ`* if `f.leadingCoeff âˆ‰ ğ“Ÿ`, `âˆ€ n, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ` and\n`f.coeff 0 âˆ‰ ğ“Ÿ ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (ğ“Ÿ : Ideal R) : Prop where\n  leading : f.leadingCoeff âˆ‰ ğ“Ÿ\n  mem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ\n  not_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.map","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœÂ¹ : CommSemiring R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt ğ“Ÿ\nA : Type v\ninstâœ : CommRing A\nÏ† : RingHom R A\nâŠ¢ (Polynomial.map Ï† f).IsWeaklyEisensteinAt (Ideal.map Ï† ğ“Ÿ)","decl":"theorem map (hf : f.IsWeaklyEisensteinAt ğ“Ÿ) {A : Type v} [CommRing A] (Ï† : R â†’+* A) :\n    (f.map Ï†).IsWeaklyEisensteinAt (ğ“Ÿ.map Ï†) := by\n  refine (isWeaklyEisensteinAt_iff _ _).2 fun hn => ?_\n  rw [coeff_map]\n  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn natDegree_map_le))\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœÂ² : CommRing R\nf : Polynomial R\nS : Type v\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\np : R\nx : S\nhx : Eq ((Polynomial.aeval x) f) 0\nhmo : f.Monic\nhf : f.IsWeaklyEisensteinAt (Submodule.span R (Singleton.singleton p))\nâŠ¢ Exists fun y => And (Membership.mem (Algebra.adjoin R (Singleton.singleton x)) y) (Eq (HMul.hMul ((algebraMap R S) p) y) (HPow.hPow x (Polynomial.map (algebraMap R S) f).natDegree))","decl":"theorem exists_mem_adjoin_mul_eq_pow_natDegree {x : S} (hx : aeval x f = 0) (hmo : f.Monic)\n    (hf : f.IsWeaklyEisensteinAt (Submodule.span R {p})) : âˆƒ y âˆˆ adjoin R ({x} : Set S),\n    (algebraMap R S) p * y = x ^ (f.map (algebraMap R S)).natDegree := by\n  rw [aeval_def, Polynomial.evalâ‚‚_eq_eval_map, eval_eq_sum_range, range_add_one,\n    sum_insert not_mem_range_self, sum_range, (hmo.map (algebraMap R S)).coeff_natDegree,\n    one_mul] at hx\n  replace hx := eq_neg_of_add_eq_zero_left hx\n  have : âˆ€ n < f.natDegree, p âˆ£ f.coeff n := by\n    intro n hn\n    exact mem_span_singleton.1 (by simpa using hf.mem hn)\n  choose! Ï† hÏ† using this\n  conv_rhs at hx =>\n    congr\n    congr\n    Â· skip\n    ext i\n    rw [coeff_map, hÏ† i.1 (lt_of_lt_of_le i.2 natDegree_map_le),\n      RingHom.map_mul, mul_assoc]\n  rw [hx, â† mul_sum, neg_eq_neg_one_mul, â† mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]\n  refine\n    âŸ¨-1 * âˆ‘ i : Fin (f.map (algebraMap R S)).natDegree, (algebraMap R S) (Ï† i.1) * x ^ i.1, ?_, rflâŸ©\n  exact\n    Subalgebra.mul_mem _ (Subalgebra.neg_mem _ (Subalgebra.one_mem _))\n      (Subalgebra.sum_mem _ fun i _ =>\n        Subalgebra.mul_mem _ (Subalgebra.algebraMap_mem _ _)\n          (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœÂ² : CommRing R\nf : Polynomial R\nS : Type v\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\np : R\nx : S\nhx : Eq ((Polynomial.aeval x) f) 0\nhmo : f.Monic\nhf : f.IsWeaklyEisensteinAt (Submodule.span R (Singleton.singleton p))\ni : Nat\naâœ : LE.le (Polynomial.map (algebraMap R S) f).natDegree i\nâŠ¢ Exists fun y => And (Membership.mem (Algebra.adjoin R (Singleton.singleton x)) y) (Eq (HMul.hMul ((algebraMap R S) p) y) (HPow.hPow x i))","decl":"theorem exists_mem_adjoin_mul_eq_pow_natDegree_le {x : S} (hx : aeval x f = 0) (hmo : f.Monic)\n    (hf : f.IsWeaklyEisensteinAt (Submodule.span R {p})) :\n    âˆ€ i, (f.map (algebraMap R S)).natDegree â‰¤ i â†’\n        âˆƒ y âˆˆ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ i := by\n  intro i hi\n  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n  rw [hk, pow_add]\n  obtain âŸ¨y, hy, HâŸ© := exists_mem_adjoin_mul_eq_pow_natDegree hx hmo hf\n  refine âŸ¨y * x ^ k, ?_, ?_âŸ©\n  Â· exact Subalgebra.mul_mem _ hy (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)\n  Â· rw [â† mul_assoc _ y, H]\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_root_of_monic_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommRing R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt ğ“Ÿ\nx : R\nhroot : f.IsRoot x\nhmo : f.Monic\ni : Nat\naâœ : LE.le f.natDegree i\nâŠ¢ Membership.mem ğ“Ÿ (HPow.hPow x i)","decl":"theorem pow_natDegree_le_of_root_of_monic_mem (hf : f.IsWeaklyEisensteinAt ğ“Ÿ)\n    {x : R} (hroot : IsRoot f x) (hmo : f.Monic) :\n    âˆ€ i, f.natDegree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ := by\n  intro i hi\n  obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n  rw [hk, pow_add]\n  suffices x ^ f.natDegree âˆˆ ğ“Ÿ by exact mul_mem_right (x ^ k) ğ“Ÿ this\n  rw [IsRoot.def, eval_eq_sum_range, Finset.range_add_one,\n    Finset.sum_insert Finset.not_mem_range_self, Finset.sum_range, hmo.coeff_natDegree, one_mul] at\n    *\n  rw [eq_neg_of_add_eq_zero_left hroot, Ideal.neg_mem_iff]\n  exact Submodule.sum_mem _ fun i _ => mul_mem_right _ _ (hf.mem (Fin.is_lt i))\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_aeval_zero_of_monic_mem_map","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœÂ² : CommRing R\nğ“Ÿ : Ideal R\nf : Polynomial R\nS : Type v\ninstâœÂ¹ : CommRing S\ninstâœ : Algebra R S\nhf : f.IsWeaklyEisensteinAt ğ“Ÿ\nx : S\nhx : Eq ((Polynomial.aeval x) f) 0\nhmo : f.Monic\ni : Nat\naâœ : LE.le (Polynomial.map (algebraMap R S) f).natDegree i\nâŠ¢ Membership.mem (Ideal.map (algebraMap R S) ğ“Ÿ) (HPow.hPow x i)","decl":"theorem pow_natDegree_le_of_aeval_zero_of_monic_mem_map (hf : f.IsWeaklyEisensteinAt ğ“Ÿ)\n    {x : S} (hx : aeval x f = 0) (hmo : f.Monic) :\n    âˆ€ i, (f.map (algebraMap R S)).natDegree â‰¤ i â†’ x ^ i âˆˆ ğ“Ÿ.map (algebraMap R S) := by\n  suffices x ^ (f.map (algebraMap R S)).natDegree âˆˆ ğ“Ÿ.map (algebraMap R S) by\n    intro i hi\n    obtain âŸ¨k, hkâŸ© := exists_add_of_le hi\n    rw [hk, pow_add]\n    exact mul_mem_right _ _ this\n  rw [aeval_def, evalâ‚‚_eq_eval_map, â† IsRoot.def] at hx\n  exact pow_natDegree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le\n\n"}
{"name":"Polynomial.scaleRoots.isWeaklyEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommRing R\np : Polynomial R\nx : R\nP : Ideal R\nhP : Membership.mem P x\nâŠ¢ (p.scaleRoots x).IsWeaklyEisensteinAt P","decl":"theorem scaleRoots.isWeaklyEisensteinAt (p : R[X]) {x : R} {P : Ideal R} (hP : x âˆˆ P) :\n    (scaleRoots p x).IsWeaklyEisensteinAt P := by\n  refine âŸ¨fun i => ?_âŸ©\n  rw [coeff_scaleRoots]\n  rw [natDegree_scaleRoots, â† tsub_pos_iff_lt] at i\n  exact Ideal.mul_mem_left _ _ (Ideal.pow_mem_of_mem P hP _ i)\n\n"}
{"name":"Polynomial.dvd_pow_natDegree_of_evalâ‚‚_eq_zero","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\nA : Type u_1\ninstâœÂ¹ : CommRing R\ninstâœ : CommRing A\nf : RingHom R A\nhf : Function.Injective â‡‘f\np : Polynomial R\nhp : p.Monic\nx y : R\nz : A\nh : Eq (Polynomial.evalâ‚‚ f z p) 0\nhz : Eq (HMul.hMul (f x) z) (f y)\nâŠ¢ Dvd.dvd x (HPow.hPow y p.natDegree)","decl":"theorem dvd_pow_natDegree_of_evalâ‚‚_eq_zero {f : R â†’+* A} (hf : Function.Injective f) {p : R[X]}\n    (hp : p.Monic) (x y : R) (z : A) (h : p.evalâ‚‚ f z = 0) (hz : f x * z = f y) :\n    x âˆ£ y ^ p.natDegree := by\n  rw [â† natDegree_scaleRoots p x, â† Ideal.mem_span_singleton]\n  refine\n    (scaleRoots.isWeaklyEisensteinAt _\n          (Ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_natDegree_le_of_root_of_monic_mem\n      ?_ ((monic_scaleRoots_iff x).mpr hp) _ le_rfl\n  rw [injective_iff_map_eq_zero'] at hf\n  have : evalâ‚‚ f _ (p.scaleRoots x) = 0 := scaleRoots_evalâ‚‚_eq_zero f h\n  rwa [hz, Polynomial.evalâ‚‚_at_apply, hf] at this\n\n"}
{"name":"Polynomial.dvd_pow_natDegree_of_aeval_eq_zero","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\nA : Type u_1\ninstâœâ´ : CommRing R\ninstâœÂ³ : CommRing A\ninstâœÂ² : Algebra R A\ninstâœÂ¹ : Nontrivial A\ninstâœ : NoZeroSMulDivisors R A\np : Polynomial R\nhp : p.Monic\nx y : R\nz : A\nh : Eq ((Polynomial.aeval z) p) 0\nhz : Eq (HMul.hMul z ((algebraMap R A) x)) ((algebraMap R A) y)\nâŠ¢ Dvd.dvd x (HPow.hPow y p.natDegree)","decl":"theorem dvd_pow_natDegree_of_aeval_eq_zero [Algebra R A] [Nontrivial A] [NoZeroSMulDivisors R A]\n    {p : R[X]} (hp : p.Monic) (x y : R) (z : A) (h : Polynomial.aeval z p = 0)\n    (hz : z * algebraMap R A x = algebraMap R A y) : x âˆ£ y ^ p.natDegree :=\n  dvd_pow_natDegree_of_evalâ‚‚_eq_zero (NoZeroSMulDivisors.algebraMap_injective R A) hp x y z h\n    ((mul_comm _ _).trans hz)\n\n"}
{"name":"Polynomial.Monic.leadingCoeff_not_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.Monic\nh : Ne ğ“Ÿ Top.top\nâŠ¢ Not (Membership.mem ğ“Ÿ f.leadingCoeff)","decl":"theorem _root_.Polynomial.Monic.leadingCoeff_not_mem (hf : f.Monic) (h : ğ“Ÿ â‰  âŠ¤) :\n    Â¬f.leadingCoeff âˆˆ ğ“Ÿ := hf.leadingCoeff.symm â–¸ (Ideal.ne_top_iff_one _).1 h\n\n"}
{"name":"Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.Monic\nh : Ne ğ“Ÿ Top.top\nhmem : âˆ€ {n : Nat}, LT.lt n f.natDegree â†’ Membership.mem ğ“Ÿ (f.coeff n)\nhnot_mem : Not (Membership.mem (HPow.hPow ğ“Ÿ 2) (f.coeff 0))\nâŠ¢ f.IsEisensteinAt ğ“Ÿ","decl":"theorem _root_.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem (hf : f.Monic) (h : ğ“Ÿ â‰  âŠ¤)\n    (hmem : âˆ€ {n}, n < f.natDegree â†’ f.coeff n âˆˆ ğ“Ÿ) (hnot_mem : f.coeff 0 âˆ‰ ğ“Ÿ ^ 2) :\n    f.IsEisensteinAt ğ“Ÿ :=\n  { leading := Polynomial.Monic.leadingCoeff_not_mem hf h\n    mem := fun hn => hmem hn\n    not_mem := hnot_mem }\n\n"}
{"name":"Polynomial.IsEisensteinAt.isWeaklyEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.IsEisensteinAt ğ“Ÿ\nâŠ¢ f.IsWeaklyEisensteinAt ğ“Ÿ","decl":"theorem isWeaklyEisensteinAt (hf : f.IsEisensteinAt ğ“Ÿ) : IsWeaklyEisensteinAt f ğ“Ÿ :=\n  âŸ¨fun h => hf.mem hâŸ©\n\n"}
{"name":"Polynomial.IsEisensteinAt.coeff_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœ : CommSemiring R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.IsEisensteinAt ğ“Ÿ\nn : Nat\nhn : Ne n f.natDegree\nâŠ¢ Membership.mem ğ“Ÿ (f.coeff n)","decl":"theorem coeff_mem (hf : f.IsEisensteinAt ğ“Ÿ) {n : â„•} (hn : n â‰  f.natDegree) : f.coeff n âˆˆ ğ“Ÿ := by\n  cases' ne_iff_lt_or_gt.1 hn with hâ‚ hâ‚‚\n  Â· exact hf.mem hâ‚\n  Â· rw [coeff_eq_zero_of_natDegree_lt hâ‚‚]\n    exact Ideal.zero_mem _\n\n"}
{"name":"Polynomial.IsEisensteinAt.irreducible","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninstâœÂ¹ : CommRing R\ninstâœ : IsDomain R\nğ“Ÿ : Ideal R\nf : Polynomial R\nhf : f.IsEisensteinAt ğ“Ÿ\nhprime : ğ“Ÿ.IsPrime\nhu : f.IsPrimitive\nhfd0 : LT.lt 0 f.natDegree\nâŠ¢ Irreducible f","decl":"/-- If a primitive `f` satisfies `f.IsEisensteinAt ğ“Ÿ`, where `ğ“Ÿ.IsPrime`,\nthen `f` is irreducible. -/\ntheorem irreducible (hf : f.IsEisensteinAt ğ“Ÿ) (hprime : ğ“Ÿ.IsPrime) (hu : f.IsPrimitive)\n    (hfd0 : 0 < f.natDegree) : Irreducible f :=\n  irreducible_of_eisenstein_criterion hprime hf.leading (fun _ hn => hf.mem (coe_lt_degree.1 hn))\n    (natDegree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu\n\n"}
