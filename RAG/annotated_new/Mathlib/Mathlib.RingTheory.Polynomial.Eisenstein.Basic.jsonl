{"name":"Polynomial.IsWeaklyEisensteinAt.mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n𝓟 : Ideal R\nself : f.IsWeaklyEisensteinAt 𝓟\nn : Nat\na✝ : LT.lt n f.natDegree\n⊢ Membership.mem 𝓟 (f.coeff n)","decl":"/-- Given an ideal `𝓟` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *weakly Eisenstein at `𝓟`* if `∀ n, n < f.natDegree → f.coeff n ∈ 𝓟`. -/\n@[mk_iff]\nstructure IsWeaklyEisensteinAt [CommSemiring R] (f : R[X]) (𝓟 : Ideal R) : Prop where\n  mem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟\n\n"}
{"name":"Polynomial.isWeaklyEisensteinAt_iff","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n𝓟 : Ideal R\n⊢ Iff (f.IsWeaklyEisensteinAt 𝓟) (∀ {n : Nat}, LT.lt n f.natDegree → Membership.mem 𝓟 (f.coeff n))","decl":"/-- Given an ideal `𝓟` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *weakly Eisenstein at `𝓟`* if `∀ n, n < f.natDegree → f.coeff n ∈ 𝓟`. -/\n@[mk_iff]\nstructure IsWeaklyEisensteinAt [CommSemiring R] (f : R[X]) (𝓟 : Ideal R) : Prop where\n  mem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟\n\n"}
{"name":"Polynomial.isEisensteinAt_iff","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n𝓟 : Ideal R\n⊢ Iff (f.IsEisensteinAt 𝓟) (And (Not (Membership.mem 𝓟 f.leadingCoeff)) (And (∀ {n : Nat}, LT.lt n f.natDegree → Membership.mem 𝓟 (f.coeff n)) (Not (Membership.mem (HPow.hPow 𝓟 2) (f.coeff 0)))))","decl":"/-- Given an ideal `𝓟` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `𝓟`* if `f.leadingCoeff ∉ 𝓟`, `∀ n, n < f.natDegree → f.coeff n ∈ 𝓟` and\n`f.coeff 0 ∉ 𝓟 ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (𝓟 : Ideal R) : Prop where\n  leading : f.leadingCoeff ∉ 𝓟\n  mem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟\n  not_mem : f.coeff 0 ∉ 𝓟 ^ 2\n\n"}
{"name":"Polynomial.IsEisensteinAt.leading","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n𝓟 : Ideal R\nself : f.IsEisensteinAt 𝓟\n⊢ Not (Membership.mem 𝓟 f.leadingCoeff)","decl":"/-- Given an ideal `𝓟` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `𝓟`* if `f.leadingCoeff ∉ 𝓟`, `∀ n, n < f.natDegree → f.coeff n ∈ 𝓟` and\n`f.coeff 0 ∉ 𝓟 ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (𝓟 : Ideal R) : Prop where\n  leading : f.leadingCoeff ∉ 𝓟\n  mem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟\n  not_mem : f.coeff 0 ∉ 𝓟 ^ 2\n\n"}
{"name":"Polynomial.IsEisensteinAt.mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n𝓟 : Ideal R\nself : f.IsEisensteinAt 𝓟\nn : Nat\na✝ : LT.lt n f.natDegree\n⊢ Membership.mem 𝓟 (f.coeff n)","decl":"/-- Given an ideal `𝓟` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `𝓟`* if `f.leadingCoeff ∉ 𝓟`, `∀ n, n < f.natDegree → f.coeff n ∈ 𝓟` and\n`f.coeff 0 ∉ 𝓟 ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (𝓟 : Ideal R) : Prop where\n  leading : f.leadingCoeff ∉ 𝓟\n  mem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟\n  not_mem : f.coeff 0 ∉ 𝓟 ^ 2\n\n"}
{"name":"Polynomial.IsEisensteinAt.not_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\nf : Polynomial R\n𝓟 : Ideal R\nself : f.IsEisensteinAt 𝓟\n⊢ Not (Membership.mem (HPow.hPow 𝓟 2) (f.coeff 0))","decl":"/-- Given an ideal `𝓟` of a commutative semiring `R`, we say that a polynomial `f : R[X]`\nis *Eisenstein at `𝓟`* if `f.leadingCoeff ∉ 𝓟`, `∀ n, n < f.natDegree → f.coeff n ∈ 𝓟` and\n`f.coeff 0 ∉ 𝓟 ^ 2`. -/\n@[mk_iff]\nstructure IsEisensteinAt [CommSemiring R] (f : R[X]) (𝓟 : Ideal R) : Prop where\n  leading : f.leadingCoeff ∉ 𝓟\n  mem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟\n  not_mem : f.coeff 0 ∉ 𝓟 ^ 2\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.map","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝¹ : CommSemiring R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt 𝓟\nA : Type v\ninst✝ : CommRing A\nφ : RingHom R A\n⊢ (Polynomial.map φ f).IsWeaklyEisensteinAt (Ideal.map φ 𝓟)","decl":"theorem map (hf : f.IsWeaklyEisensteinAt 𝓟) {A : Type v} [CommRing A] (φ : R →+* A) :\n    (f.map φ).IsWeaklyEisensteinAt (𝓟.map φ) := by\n  refine (isWeaklyEisensteinAt_iff _ _).2 fun hn => ?_\n  rw [coeff_map]\n  exact mem_map_of_mem _ (hf.mem (lt_of_lt_of_le hn natDegree_map_le))\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nf : Polynomial R\nS : Type v\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\np : R\nx : S\nhx : Eq ((Polynomial.aeval x) f) 0\nhmo : f.Monic\nhf : f.IsWeaklyEisensteinAt (Submodule.span R (Singleton.singleton p))\n⊢ Exists fun y => And (Membership.mem (Algebra.adjoin R (Singleton.singleton x)) y) (Eq (HMul.hMul ((algebraMap R S) p) y) (HPow.hPow x (Polynomial.map (algebraMap R S) f).natDegree))","decl":"theorem exists_mem_adjoin_mul_eq_pow_natDegree {x : S} (hx : aeval x f = 0) (hmo : f.Monic)\n    (hf : f.IsWeaklyEisensteinAt (Submodule.span R {p})) : ∃ y ∈ adjoin R ({x} : Set S),\n    (algebraMap R S) p * y = x ^ (f.map (algebraMap R S)).natDegree := by\n  rw [aeval_def, Polynomial.eval₂_eq_eval_map, eval_eq_sum_range, range_add_one,\n    sum_insert not_mem_range_self, sum_range, (hmo.map (algebraMap R S)).coeff_natDegree,\n    one_mul] at hx\n  replace hx := eq_neg_of_add_eq_zero_left hx\n  have : ∀ n < f.natDegree, p ∣ f.coeff n := by\n    intro n hn\n    exact mem_span_singleton.1 (by simpa using hf.mem hn)\n  choose! φ hφ using this\n  conv_rhs at hx =>\n    congr\n    congr\n    · skip\n    ext i\n    rw [coeff_map, hφ i.1 (lt_of_lt_of_le i.2 natDegree_map_le),\n      RingHom.map_mul, mul_assoc]\n  rw [hx, ← mul_sum, neg_eq_neg_one_mul, ← mul_assoc (-1 : S), mul_comm (-1 : S), mul_assoc]\n  refine\n    ⟨-1 * ∑ i : Fin (f.map (algebraMap R S)).natDegree, (algebraMap R S) (φ i.1) * x ^ i.1, ?_, rfl⟩\n  exact\n    Subalgebra.mul_mem _ (Subalgebra.neg_mem _ (Subalgebra.one_mem _))\n      (Subalgebra.sum_mem _ fun i _ =>\n        Subalgebra.mul_mem _ (Subalgebra.algebraMap_mem _ _)\n          (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _))\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.exists_mem_adjoin_mul_eq_pow_natDegree_le","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\nf : Polynomial R\nS : Type v\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\np : R\nx : S\nhx : Eq ((Polynomial.aeval x) f) 0\nhmo : f.Monic\nhf : f.IsWeaklyEisensteinAt (Submodule.span R (Singleton.singleton p))\ni : Nat\na✝ : LE.le (Polynomial.map (algebraMap R S) f).natDegree i\n⊢ Exists fun y => And (Membership.mem (Algebra.adjoin R (Singleton.singleton x)) y) (Eq (HMul.hMul ((algebraMap R S) p) y) (HPow.hPow x i))","decl":"theorem exists_mem_adjoin_mul_eq_pow_natDegree_le {x : S} (hx : aeval x f = 0) (hmo : f.Monic)\n    (hf : f.IsWeaklyEisensteinAt (Submodule.span R {p})) :\n    ∀ i, (f.map (algebraMap R S)).natDegree ≤ i →\n        ∃ y ∈ adjoin R ({x} : Set S), (algebraMap R S) p * y = x ^ i := by\n  intro i hi\n  obtain ⟨k, hk⟩ := exists_add_of_le hi\n  rw [hk, pow_add]\n  obtain ⟨y, hy, H⟩ := exists_mem_adjoin_mul_eq_pow_natDegree hx hmo hf\n  refine ⟨y * x ^ k, ?_, ?_⟩\n  · exact Subalgebra.mul_mem _ hy (Subalgebra.pow_mem _ (subset_adjoin (Set.mem_singleton x)) _)\n  · rw [← mul_assoc _ y, H]\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_root_of_monic_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.IsWeaklyEisensteinAt 𝓟\nx : R\nhroot : f.IsRoot x\nhmo : f.Monic\ni : Nat\na✝ : LE.le f.natDegree i\n⊢ Membership.mem 𝓟 (HPow.hPow x i)","decl":"theorem pow_natDegree_le_of_root_of_monic_mem (hf : f.IsWeaklyEisensteinAt 𝓟)\n    {x : R} (hroot : IsRoot f x) (hmo : f.Monic) :\n    ∀ i, f.natDegree ≤ i → x ^ i ∈ 𝓟 := by\n  intro i hi\n  obtain ⟨k, hk⟩ := exists_add_of_le hi\n  rw [hk, pow_add]\n  suffices x ^ f.natDegree ∈ 𝓟 by exact mul_mem_right (x ^ k) 𝓟 this\n  rw [IsRoot.def, eval_eq_sum_range, Finset.range_add_one,\n    Finset.sum_insert Finset.not_mem_range_self, Finset.sum_range, hmo.coeff_natDegree, one_mul] at\n    *\n  rw [eq_neg_of_add_eq_zero_left hroot, Ideal.neg_mem_iff]\n  exact Submodule.sum_mem _ fun i _ => mul_mem_right _ _ (hf.mem (Fin.is_lt i))\n\n"}
{"name":"Polynomial.IsWeaklyEisensteinAt.pow_natDegree_le_of_aeval_zero_of_monic_mem_map","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝² : CommRing R\n𝓟 : Ideal R\nf : Polynomial R\nS : Type v\ninst✝¹ : CommRing S\ninst✝ : Algebra R S\nhf : f.IsWeaklyEisensteinAt 𝓟\nx : S\nhx : Eq ((Polynomial.aeval x) f) 0\nhmo : f.Monic\ni : Nat\na✝ : LE.le (Polynomial.map (algebraMap R S) f).natDegree i\n⊢ Membership.mem (Ideal.map (algebraMap R S) 𝓟) (HPow.hPow x i)","decl":"theorem pow_natDegree_le_of_aeval_zero_of_monic_mem_map (hf : f.IsWeaklyEisensteinAt 𝓟)\n    {x : S} (hx : aeval x f = 0) (hmo : f.Monic) :\n    ∀ i, (f.map (algebraMap R S)).natDegree ≤ i → x ^ i ∈ 𝓟.map (algebraMap R S) := by\n  suffices x ^ (f.map (algebraMap R S)).natDegree ∈ 𝓟.map (algebraMap R S) by\n    intro i hi\n    obtain ⟨k, hk⟩ := exists_add_of_le hi\n    rw [hk, pow_add]\n    exact mul_mem_right _ _ this\n  rw [aeval_def, eval₂_eq_eval_map, ← IsRoot.def] at hx\n  exact pow_natDegree_le_of_root_of_monic_mem (hf.map _) hx (hmo.map _) _ rfl.le\n\n"}
{"name":"Polynomial.scaleRoots.isWeaklyEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommRing R\np : Polynomial R\nx : R\nP : Ideal R\nhP : Membership.mem P x\n⊢ (p.scaleRoots x).IsWeaklyEisensteinAt P","decl":"theorem scaleRoots.isWeaklyEisensteinAt (p : R[X]) {x : R} {P : Ideal R} (hP : x ∈ P) :\n    (scaleRoots p x).IsWeaklyEisensteinAt P := by\n  refine ⟨fun i => ?_⟩\n  rw [coeff_scaleRoots]\n  rw [natDegree_scaleRoots, ← tsub_pos_iff_lt] at i\n  exact Ideal.mul_mem_left _ _ (Ideal.pow_mem_of_mem P hP _ i)\n\n"}
{"name":"Polynomial.dvd_pow_natDegree_of_eval₂_eq_zero","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\nA : Type u_1\ninst✝¹ : CommRing R\ninst✝ : CommRing A\nf : RingHom R A\nhf : Function.Injective ⇑f\np : Polynomial R\nhp : p.Monic\nx y : R\nz : A\nh : Eq (Polynomial.eval₂ f z p) 0\nhz : Eq (HMul.hMul (f x) z) (f y)\n⊢ Dvd.dvd x (HPow.hPow y p.natDegree)","decl":"theorem dvd_pow_natDegree_of_eval₂_eq_zero {f : R →+* A} (hf : Function.Injective f) {p : R[X]}\n    (hp : p.Monic) (x y : R) (z : A) (h : p.eval₂ f z = 0) (hz : f x * z = f y) :\n    x ∣ y ^ p.natDegree := by\n  rw [← natDegree_scaleRoots p x, ← Ideal.mem_span_singleton]\n  refine\n    (scaleRoots.isWeaklyEisensteinAt _\n          (Ideal.mem_span_singleton.mpr <| dvd_refl x)).pow_natDegree_le_of_root_of_monic_mem\n      ?_ ((monic_scaleRoots_iff x).mpr hp) _ le_rfl\n  rw [injective_iff_map_eq_zero'] at hf\n  have : eval₂ f _ (p.scaleRoots x) = 0 := scaleRoots_eval₂_eq_zero f h\n  rwa [hz, Polynomial.eval₂_at_apply, hf] at this\n\n"}
{"name":"Polynomial.dvd_pow_natDegree_of_aeval_eq_zero","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\nA : Type u_1\ninst✝⁴ : CommRing R\ninst✝³ : CommRing A\ninst✝² : Algebra R A\ninst✝¹ : Nontrivial A\ninst✝ : NoZeroSMulDivisors R A\np : Polynomial R\nhp : p.Monic\nx y : R\nz : A\nh : Eq ((Polynomial.aeval z) p) 0\nhz : Eq (HMul.hMul z ((algebraMap R A) x)) ((algebraMap R A) y)\n⊢ Dvd.dvd x (HPow.hPow y p.natDegree)","decl":"theorem dvd_pow_natDegree_of_aeval_eq_zero [Algebra R A] [Nontrivial A] [NoZeroSMulDivisors R A]\n    {p : R[X]} (hp : p.Monic) (x y : R) (z : A) (h : Polynomial.aeval z p = 0)\n    (hz : z * algebraMap R A x = algebraMap R A y) : x ∣ y ^ p.natDegree :=\n  dvd_pow_natDegree_of_eval₂_eq_zero (NoZeroSMulDivisors.algebraMap_injective R A) hp x y z h\n    ((mul_comm _ _).trans hz)\n\n"}
{"name":"Polynomial.Monic.leadingCoeff_not_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.Monic\nh : Ne 𝓟 Top.top\n⊢ Not (Membership.mem 𝓟 f.leadingCoeff)","decl":"theorem _root_.Polynomial.Monic.leadingCoeff_not_mem (hf : f.Monic) (h : 𝓟 ≠ ⊤) :\n    ¬f.leadingCoeff ∈ 𝓟 := hf.leadingCoeff.symm ▸ (Ideal.ne_top_iff_one _).1 h\n\n"}
{"name":"Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.Monic\nh : Ne 𝓟 Top.top\nhmem : ∀ {n : Nat}, LT.lt n f.natDegree → Membership.mem 𝓟 (f.coeff n)\nhnot_mem : Not (Membership.mem (HPow.hPow 𝓟 2) (f.coeff 0))\n⊢ f.IsEisensteinAt 𝓟","decl":"theorem _root_.Polynomial.Monic.isEisensteinAt_of_mem_of_not_mem (hf : f.Monic) (h : 𝓟 ≠ ⊤)\n    (hmem : ∀ {n}, n < f.natDegree → f.coeff n ∈ 𝓟) (hnot_mem : f.coeff 0 ∉ 𝓟 ^ 2) :\n    f.IsEisensteinAt 𝓟 :=\n  { leading := Polynomial.Monic.leadingCoeff_not_mem hf h\n    mem := fun hn => hmem hn\n    not_mem := hnot_mem }\n\n"}
{"name":"Polynomial.IsEisensteinAt.isWeaklyEisensteinAt","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.IsEisensteinAt 𝓟\n⊢ f.IsWeaklyEisensteinAt 𝓟","decl":"theorem isWeaklyEisensteinAt (hf : f.IsEisensteinAt 𝓟) : IsWeaklyEisensteinAt f 𝓟 :=\n  ⟨fun h => hf.mem h⟩\n\n"}
{"name":"Polynomial.IsEisensteinAt.coeff_mem","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝ : CommSemiring R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.IsEisensteinAt 𝓟\nn : Nat\nhn : Ne n f.natDegree\n⊢ Membership.mem 𝓟 (f.coeff n)","decl":"theorem coeff_mem (hf : f.IsEisensteinAt 𝓟) {n : ℕ} (hn : n ≠ f.natDegree) : f.coeff n ∈ 𝓟 := by\n  cases' ne_iff_lt_or_gt.1 hn with h₁ h₂\n  · exact hf.mem h₁\n  · rw [coeff_eq_zero_of_natDegree_lt h₂]\n    exact Ideal.zero_mem _\n\n"}
{"name":"Polynomial.IsEisensteinAt.irreducible","module":"Mathlib.RingTheory.Polynomial.Eisenstein.Basic","initialProofState":"R : Type u\ninst✝¹ : CommRing R\ninst✝ : IsDomain R\n𝓟 : Ideal R\nf : Polynomial R\nhf : f.IsEisensteinAt 𝓟\nhprime : 𝓟.IsPrime\nhu : f.IsPrimitive\nhfd0 : LT.lt 0 f.natDegree\n⊢ Irreducible f","decl":"/-- If a primitive `f` satisfies `f.IsEisensteinAt 𝓟`, where `𝓟.IsPrime`,\nthen `f` is irreducible. -/\ntheorem irreducible (hf : f.IsEisensteinAt 𝓟) (hprime : 𝓟.IsPrime) (hu : f.IsPrimitive)\n    (hfd0 : 0 < f.natDegree) : Irreducible f :=\n  irreducible_of_eisenstein_criterion hprime hf.leading (fun _ hn => hf.mem (coe_lt_degree.1 hn))\n    (natDegree_pos_iff_degree_pos.1 hfd0) hf.not_mem hu\n\n"}
