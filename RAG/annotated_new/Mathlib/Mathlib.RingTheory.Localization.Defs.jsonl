{"name":"isLocalization_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\n⊢ Iff (IsLocalization M S) (And (∀ (y : Subtype fun x => Membership.mem M x), IsUnit ((algebraMap R S) ↑y)) (And (∀ (z : S), Exists fun x => Eq (HMul.hMul z ((algebraMap R S) ↑x.2)) ((algebraMap R S) x.1)) (∀ {x y : R}, Eq ((algebraMap R S) x) ((algebraMap R S) y) → Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y))))","decl":"/-- The typeclass `IsLocalization (M : Submonoid R) S` where `S` is an `R`-algebra\nexpresses that `S` is isomorphic to the localization of `R` at `M`. -/\n@[mk_iff] class IsLocalization : Prop where\n  -- Porting note: add ' to fields, and made new versions of these with either `S` or `M` explicit.\n  /-- Everything in the image of `algebraMap` is a unit -/\n  map_units' : ∀ y : M, IsUnit (algebraMap R S y)\n  /-- The `algebraMap` is surjective -/\n  surj' : ∀ z : S, ∃ x : R × M, z * algebraMap R S x.2 = algebraMap R S x.1\n  /-- The kernel of `algebraMap` is contained in the annihilator of `M`;\n      it is then equal to the annihilator by `map_units'` -/\n  exists_of_eq : ∀ {x y}, algebraMap R S x = algebraMap R S y → ∃ c : M, ↑c * x = ↑c * y\n\n"}
{"name":"IsLocalization.surj'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nself : IsLocalization M S\nz : S\n⊢ Exists fun x => Eq (HMul.hMul z ((algebraMap R S) ↑x.2)) ((algebraMap R S) x.1)","decl":"/-- The typeclass `IsLocalization (M : Submonoid R) S` where `S` is an `R`-algebra\nexpresses that `S` is isomorphic to the localization of `R` at `M`. -/\n@[mk_iff] class IsLocalization : Prop where\n  -- Porting note: add ' to fields, and made new versions of these with either `S` or `M` explicit.\n  /-- Everything in the image of `algebraMap` is a unit -/\n  map_units' : ∀ y : M, IsUnit (algebraMap R S y)\n  /-- The `algebraMap` is surjective -/\n  surj' : ∀ z : S, ∃ x : R × M, z * algebraMap R S x.2 = algebraMap R S x.1\n  /-- The kernel of `algebraMap` is contained in the annihilator of `M`;\n      it is then equal to the annihilator by `map_units'` -/\n  exists_of_eq : ∀ {x y}, algebraMap R S x = algebraMap R S y → ∃ c : M, ↑c * x = ↑c * y\n\n"}
{"name":"IsLocalization.map_units'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nself : IsLocalization M S\ny : Subtype fun x => Membership.mem M x\n⊢ IsUnit ((algebraMap R S) ↑y)","decl":"/-- The typeclass `IsLocalization (M : Submonoid R) S` where `S` is an `R`-algebra\nexpresses that `S` is isomorphic to the localization of `R` at `M`. -/\n@[mk_iff] class IsLocalization : Prop where\n  -- Porting note: add ' to fields, and made new versions of these with either `S` or `M` explicit.\n  /-- Everything in the image of `algebraMap` is a unit -/\n  map_units' : ∀ y : M, IsUnit (algebraMap R S y)\n  /-- The `algebraMap` is surjective -/\n  surj' : ∀ z : S, ∃ x : R × M, z * algebraMap R S x.2 = algebraMap R S x.1\n  /-- The kernel of `algebraMap` is contained in the annihilator of `M`;\n      it is then equal to the annihilator by `map_units'` -/\n  exists_of_eq : ∀ {x y}, algebraMap R S x = algebraMap R S y → ∃ c : M, ↑c * x = ↑c * y\n\n"}
{"name":"IsLocalization.exists_of_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹ : CommSemiring S\ninst✝ : Algebra R S\nself : IsLocalization M S\nx y : R\na✝ : Eq ((algebraMap R S) x) ((algebraMap R S) y)\n⊢ Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y)","decl":"/-- The typeclass `IsLocalization (M : Submonoid R) S` where `S` is an `R`-algebra\nexpresses that `S` is isomorphic to the localization of `R` at `M`. -/\n@[mk_iff] class IsLocalization : Prop where\n  -- Porting note: add ' to fields, and made new versions of these with either `S` or `M` explicit.\n  /-- Everything in the image of `algebraMap` is a unit -/\n  map_units' : ∀ y : M, IsUnit (algebraMap R S y)\n  /-- The `algebraMap` is surjective -/\n  surj' : ∀ z : S, ∃ x : R × M, z * algebraMap R S x.2 = algebraMap R S x.1\n  /-- The kernel of `algebraMap` is contained in the annihilator of `M`;\n      it is then equal to the annihilator by `map_units'` -/\n  exists_of_eq : ∀ {x y}, algebraMap R S x = algebraMap R S y → ∃ c : M, ↑c * x = ↑c * y\n\n"}
{"name":"IsLocalization.map_units","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\ny : Subtype fun x => Membership.mem M x\n⊢ IsUnit ((algebraMap R S) ↑y)","decl":"@[inherit_doc IsLocalization.map_units']\ntheorem map_units : ∀ y : M, IsUnit (algebraMap R S y) :=\n  IsLocalization.map_units'\n\n"}
{"name":"IsLocalization.surj","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\n⊢ Exists fun x => Eq (HMul.hMul z ((algebraMap R S) ↑x.2)) ((algebraMap R S) x.1)","decl":"@[inherit_doc IsLocalization.surj']\ntheorem surj : ∀ z : S, ∃ x : R × M, z * algebraMap R S x.2 = algebraMap R S x.1 :=\n  IsLocalization.surj'\n\n"}
{"name":"IsLocalization.eq_iff_exists","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\n⊢ Iff (Eq ((algebraMap R S) x) ((algebraMap R S) y)) (Exists fun c => Eq (HMul.hMul (↑c) x) (HMul.hMul (↑c) y))","decl":"@[inherit_doc IsLocalization.exists_of_eq]\ntheorem eq_iff_exists {x y} : algebraMap R S x = algebraMap R S y ↔ ∃ c : M, ↑c * x = ↑c * y :=\n  Iff.intro IsLocalization.exists_of_eq fun ⟨c, h⟩ ↦ by\n    apply_fun algebraMap R S at h\n    rw [map_mul, map_mul] at h\n    exact (IsLocalization.map_units S c).mul_right_inj.mp h\n\n"}
{"name":"IsLocalization.of_le","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nN : Submonoid R\nh₁ : LE.le M N\nh₂ : ∀ (r : R), Membership.mem N r → IsUnit ((algebraMap R S) r)\n⊢ IsLocalization N S","decl":"theorem of_le (N : Submonoid R) (h₁ : M ≤ N) (h₂ : ∀ r ∈ N, IsUnit (algebraMap R S r)) :\n    IsLocalization N S where\n  map_units' r := h₂ r r.2\n  surj' s :=\n    have ⟨⟨x, y, hy⟩, H⟩ := IsLocalization.surj M s\n    ⟨⟨x, y, h₁ hy⟩, H⟩\n  exists_of_eq {x y} := by\n    rw [IsLocalization.eq_iff_exists M]\n    rintro ⟨c, hc⟩\n    exact ⟨⟨c, h₁ c.2⟩, hc⟩\n\n"}
{"name":"IsLocalization.of_le_of_exists_dvd","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nN : Submonoid R\nh₁ : LE.le M N\nh₂ : ∀ (n : R), Membership.mem N n → Exists fun m => And (Membership.mem M m) (Dvd.dvd n m)\n⊢ IsLocalization N S","decl":"theorem of_le_of_exists_dvd (N : Submonoid R) (h₁ : M ≤ N) (h₂ : ∀ n ∈ N, ∃ m ∈ M, n ∣ m) :\n    IsLocalization N S :=\n  of_le M N h₁ fun n hn ↦ have ⟨m, hm, dvd⟩ := h₂ n hn\n    isUnit_of_dvd_unit (map_dvd _ dvd) (map_units S ⟨m, hm⟩)\n\n"}
{"name":"IsLocalization.toLocalizationWithZeroMap_toFun","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : R\n⊢ Eq ((↑(IsLocalization.toLocalizationWithZeroMap M S).toMonoidHom).toFun a) ((algebraMap R S) a)","decl":"/-- `IsLocalization.toLocalizationWithZeroMap M S` shows `S` is the monoid localization of\n`R` at `M`. -/\n@[simps]\ndef toLocalizationWithZeroMap : Submonoid.LocalizationWithZeroMap M S where\n  __ := algebraMap R S\n  toFun := algebraMap R S\n  map_units' := IsLocalization.map_units _\n  surj' := IsLocalization.surj _\n  exists_of_eq _ _ := IsLocalization.exists_of_eq\n\n"}
{"name":"IsLocalization.toLocalizationMap_toMap","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Eq (IsLocalization.toLocalizationMap M S).toMap ↑↑(algebraMap R S)","decl":"@[simp]\ntheorem toLocalizationMap_toMap : (toLocalizationMap M S).toMap = (algebraMap R S : R →*₀ S) :=\n  rfl\n\n"}
{"name":"IsLocalization.toLocalizationMap_toMap_apply","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\n⊢ Eq ((IsLocalization.toLocalizationMap M S).toMap x) ((algebraMap R S) x)","decl":"theorem toLocalizationMap_toMap_apply (x) : (toLocalizationMap M S).toMap x = algebraMap R S x :=\n  rfl\n\n"}
{"name":"IsLocalization.surj₂","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz w : S\n⊢ Exists fun z' => Exists fun w' => Exists fun d => And (Eq (HMul.hMul z ((algebraMap R S) ↑d)) ((algebraMap R S) z')) (Eq (HMul.hMul w ((algebraMap R S) ↑d)) ((algebraMap R S) w'))","decl":"theorem surj₂ : ∀ z w : S, ∃ z' w' : R, ∃ d : M,\n    (z * algebraMap R S d = algebraMap R S z') ∧ (w * algebraMap R S d = algebraMap R S w') :=\n  (toLocalizationMap M S).surj₂\n\n"}
{"name":"IsLocalization.toLocalizationMap_sec","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ Eq (IsLocalization.toLocalizationMap M S).sec (IsLocalization.sec M)","decl":"@[simp]\ntheorem toLocalizationMap_sec : (toLocalizationMap M S).sec = sec M :=\n  rfl\n\n"}
{"name":"IsLocalization.sec_spec","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\n⊢ Eq (HMul.hMul z ((algebraMap R S) ↑(IsLocalization.sec M z).2)) ((algebraMap R S) (IsLocalization.sec M z).1)","decl":"/-- Given `z : S`, `IsLocalization.sec M z` is defined to be a pair `(x, y) : R × M` such\nthat `z * f y = f x` (so this lemma is true by definition). -/\ntheorem sec_spec (z : S) :\n    z * algebraMap R S (IsLocalization.sec M z).2 = algebraMap R S (IsLocalization.sec M z).1 :=\n  Classical.choose_spec <| IsLocalization.surj _ z\n\n"}
{"name":"IsLocalization.sec_spec'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\n⊢ Eq ((algebraMap R S) (IsLocalization.sec M z).1) (HMul.hMul ((algebraMap R S) ↑(IsLocalization.sec M z).2) z)","decl":"/-- Given `z : S`, `IsLocalization.sec M z` is defined to be a pair `(x, y) : R × M` such\nthat `z * f y = f x`, so this lemma is just an application of `S`'s commutativity. -/\ntheorem sec_spec' (z : S) :\n    algebraMap R S (IsLocalization.sec M z).1 = algebraMap R S (IsLocalization.sec M z).2 * z := by\n  rw [mul_comm, sec_spec]\n\n"}
{"name":"IsLocalization.subsingleton","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nh : Membership.mem M 0\n⊢ Subsingleton S","decl":"/-- If `M` contains `0` then the localization at `M` is trivial. -/\ntheorem subsingleton (h : 0 ∈ M) : Subsingleton S := (toLocalizationMap M S).subsingleton h\n\n"}
{"name":"IsLocalization.map_right_cancel","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\nc : Subtype fun x => Membership.mem M x\nh : Eq ((algebraMap R S) (HMul.hMul (↑c) x)) ((algebraMap R S) (HMul.hMul (↑c) y))\n⊢ Eq ((algebraMap R S) x) ((algebraMap R S) y)","decl":"theorem map_right_cancel {x y} {c : M} (h : algebraMap R S (c * x) = algebraMap R S (c * y)) :\n    algebraMap R S x = algebraMap R S y :=\n  (toLocalizationMap M S).map_right_cancel h\n\n"}
{"name":"IsLocalization.map_left_cancel","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\nc : Subtype fun x => Membership.mem M x\nh : Eq ((algebraMap R S) (HMul.hMul x ↑c)) ((algebraMap R S) (HMul.hMul y ↑c))\n⊢ Eq ((algebraMap R S) x) ((algebraMap R S) y)","decl":"theorem map_left_cancel {x y} {c : M} (h : algebraMap R S (x * c) = algebraMap R S (y * c)) :\n    algebraMap R S x = algebraMap R S y :=\n  (toLocalizationMap M S).map_left_cancel h\n\n"}
{"name":"IsLocalization.eq_zero_of_fst_eq_zero","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\nx : R\ny : Subtype fun x => Membership.mem M x\nh : Eq (HMul.hMul z ((algebraMap R S) ↑y)) ((algebraMap R S) x)\nhx : Eq x 0\n⊢ Eq z 0","decl":"theorem eq_zero_of_fst_eq_zero {z x} {y : M} (h : z * algebraMap R S y = algebraMap R S x)\n    (hx : x = 0) : z = 0 := by\n  rw [hx, (algebraMap R S).map_zero] at h\n  exact (IsUnit.mul_left_eq_zero (IsLocalization.map_units S y)).1 h\n\n"}
{"name":"IsLocalization.map_eq_zero_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nr : R\n⊢ Iff (Eq ((algebraMap R S) r) 0) (Exists fun m => Eq (HMul.hMul (↑m) r) 0)","decl":"theorem map_eq_zero_iff (r : R) : algebraMap R S r = 0 ↔ ∃ m : M, ↑m * r = 0 := by\n  constructor\n  · intro h\n    obtain ⟨m, hm⟩ := (IsLocalization.eq_iff_exists M S).mp ((algebraMap R S).map_zero.trans h.symm)\n    exact ⟨m, by simpa using hm.symm⟩\n  · rintro ⟨m, hm⟩\n    rw [← (IsLocalization.map_units S m).mul_right_inj, mul_zero, ← RingHom.map_mul, hm,\n      RingHom.map_zero]\n\n"}
{"name":"IsLocalization.mk'_sec","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\n⊢ Eq (IsLocalization.mk' S (IsLocalization.sec M z).1 (IsLocalization.sec M z).2) z","decl":"@[simp]\ntheorem mk'_sec (z : S) : mk' S (IsLocalization.sec M z).1 (IsLocalization.sec M z).2 = z :=\n  (toLocalizationMap M S).mk'_sec _\n\n"}
{"name":"IsLocalization.mk'_mul","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx₁ x₂ : R\ny₁ y₂ : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (HMul.hMul x₁ x₂) (HMul.hMul y₁ y₂)) (HMul.hMul (IsLocalization.mk' S x₁ y₁) (IsLocalization.mk' S x₂ y₂))","decl":"theorem mk'_mul (x₁ x₂ : R) (y₁ y₂ : M) : mk' S (x₁ * x₂) (y₁ * y₂) = mk' S x₁ y₁ * mk' S x₂ y₂ :=\n  (toLocalizationMap M S).mk'_mul _ _ _ _\n\n"}
{"name":"IsLocalization.mk'_one","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\n⊢ Eq (IsLocalization.mk' S x 1) ((algebraMap R S) x)","decl":"theorem mk'_one (x) : mk' S x (1 : M) = algebraMap R S x :=\n  (toLocalizationMap M S).mk'_one _\n\n"}
{"name":"IsLocalization.mk'_spec","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq (HMul.hMul (IsLocalization.mk' S x y) ((algebraMap R S) ↑y)) ((algebraMap R S) x)","decl":"@[simp]\ntheorem mk'_spec (x) (y : M) : mk' S x y * algebraMap R S y = algebraMap R S x :=\n  (toLocalizationMap M S).mk'_spec _ _\n\n"}
{"name":"IsLocalization.mk'_spec'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq (HMul.hMul ((algebraMap R S) ↑y) (IsLocalization.mk' S x y)) ((algebraMap R S) x)","decl":"@[simp]\ntheorem mk'_spec' (x) (y : M) : algebraMap R S y * mk' S x y = algebraMap R S x :=\n  (toLocalizationMap M S).mk'_spec' _ _\n\n"}
{"name":"IsLocalization.mk'_spec_mk","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\nhy : Membership.mem M y\n⊢ Eq (HMul.hMul (IsLocalization.mk' S x ⟨y, hy⟩) ((algebraMap R S) y)) ((algebraMap R S) x)","decl":"@[simp]\ntheorem mk'_spec_mk (x) (y : R) (hy : y ∈ M) :\n    mk' S x ⟨y, hy⟩ * algebraMap R S y = algebraMap R S x :=\n  mk'_spec S x ⟨y, hy⟩\n\n"}
{"name":"IsLocalization.mk'_spec'_mk","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\nhy : Membership.mem M y\n⊢ Eq (HMul.hMul ((algebraMap R S) y) (IsLocalization.mk' S x ⟨y, hy⟩)) ((algebraMap R S) x)","decl":"@[simp]\ntheorem mk'_spec'_mk (x) (y : R) (hy : y ∈ M) :\n    algebraMap R S y * mk' S x ⟨y, hy⟩ = algebraMap R S x :=\n  mk'_spec' S x ⟨y, hy⟩\n\n"}
{"name":"IsLocalization.eq_mk'_iff_mul_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nz : S\n⊢ Iff (Eq z (IsLocalization.mk' S x y)) (Eq (HMul.hMul z ((algebraMap R S) ↑y)) ((algebraMap R S) x))","decl":"theorem eq_mk'_iff_mul_eq {x} {y : M} {z} :\n    z = mk' S x y ↔ z * algebraMap R S y = algebraMap R S x :=\n  (toLocalizationMap M S).eq_mk'_iff_mul_eq\n\n"}
{"name":"IsLocalization.eq_mk'_of_mul_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nz : R\nh : Eq (HMul.hMul z ↑y) x\n⊢ Eq ((algebraMap R S) z) (IsLocalization.mk' S x y)","decl":"theorem eq_mk'_of_mul_eq {x : R} {y : M} {z : R} (h : z * y = x) : (algebraMap R S) z = mk' S x y :=\n  eq_mk'_iff_mul_eq.mpr (by rw [← h, map_mul])\n\n"}
{"name":"IsLocalization.mk'_eq_iff_eq_mul","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nz : S\n⊢ Iff (Eq (IsLocalization.mk' S x y) z) (Eq ((algebraMap R S) x) (HMul.hMul z ((algebraMap R S) ↑y)))","decl":"theorem mk'_eq_iff_eq_mul {x} {y : M} {z} :\n    mk' S x y = z ↔ algebraMap R S x = z * algebraMap R S y :=\n  (toLocalizationMap M S).mk'_eq_iff_eq_mul\n\n"}
{"name":"IsLocalization.mk'_add_eq_iff_add_mul_eq_mul","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nz₁ z₂ : S\n⊢ Iff (Eq (HAdd.hAdd (IsLocalization.mk' S x y) z₁) z₂) (Eq (HAdd.hAdd ((algebraMap R S) x) (HMul.hMul z₁ ((algebraMap R S) ↑y))) (HMul.hMul z₂ ((algebraMap R S) ↑y)))","decl":"theorem mk'_add_eq_iff_add_mul_eq_mul {x} {y : M} {z₁ z₂} :\n    mk' S x y + z₁ = z₂ ↔ algebraMap R S x + z₁ * algebraMap R S y = z₂ * algebraMap R S y := by\n  rw [← mk'_spec S x y, ← IsUnit.mul_left_inj (IsLocalization.map_units S y), right_distrib]\n\n"}
{"name":"IsLocalization.mk'_pow","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nn : Nat\n⊢ Eq (IsLocalization.mk' S (HPow.hPow x n) (HPow.hPow y n)) (HPow.hPow (IsLocalization.mk' S x y) n)","decl":"theorem mk'_pow (x : R) (y : M) (n : ℕ) : mk' S (x ^ n) (y ^ n) = mk' S x y ^ n := by\n  simp_rw [IsLocalization.mk'_eq_iff_eq_mul, SubmonoidClass.coe_pow, map_pow, ← mul_pow]\n  simp\n\n"}
{"name":"IsLocalization.mk'_surjective","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\n⊢ Exists fun x => Exists fun y => Eq (IsLocalization.mk' S x y) z","decl":"theorem mk'_surjective (z : S) : ∃ (x : _) (y : M), mk' S x y = z :=\n  let ⟨r, hr⟩ := IsLocalization.surj _ z\n  ⟨r.1, r.2, (eq_mk'_iff_mul_eq.2 hr).symm⟩\n\n"}
{"name":"IsLocalization.mk'_eq_iff_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx₁ x₂ : R\ny₁ y₂ : Subtype fun x => Membership.mem M x\n⊢ Iff (Eq (IsLocalization.mk' S x₁ y₁) (IsLocalization.mk' S x₂ y₂)) (Eq ((algebraMap R S) (HMul.hMul (↑y₂) x₁)) ((algebraMap R S) (HMul.hMul (↑y₁) x₂)))","decl":"theorem mk'_eq_iff_eq {x₁ x₂} {y₁ y₂ : M} :\n    mk' S x₁ y₁ = mk' S x₂ y₂ ↔ algebraMap R S (y₂ * x₁) = algebraMap R S (y₁ * x₂) :=\n  (toLocalizationMap M S).mk'_eq_iff_eq\n\n"}
{"name":"IsLocalization.mk'_eq_iff_eq'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx₁ x₂ : R\ny₁ y₂ : Subtype fun x => Membership.mem M x\n⊢ Iff (Eq (IsLocalization.mk' S x₁ y₁) (IsLocalization.mk' S x₂ y₂)) (Eq ((algebraMap R S) (HMul.hMul x₁ ↑y₂)) ((algebraMap R S) (HMul.hMul x₂ ↑y₁)))","decl":"theorem mk'_eq_iff_eq' {x₁ x₂} {y₁ y₂ : M} :\n    mk' S x₁ y₁ = mk' S x₂ y₂ ↔ algebraMap R S (x₁ * y₂) = algebraMap R S (x₂ * y₁) :=\n  (toLocalizationMap M S).mk'_eq_iff_eq'\n\n"}
{"name":"IsLocalization.eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na₁ b₁ : R\na₂ b₂ : Subtype fun x => Membership.mem M x\n⊢ Iff (Eq (IsLocalization.mk' S a₁ a₂) (IsLocalization.mk' S b₁ b₂)) (Exists fun c => Eq (HMul.hMul (↑c) (HMul.hMul (↑b₂) a₁)) (HMul.hMul (↑c) (HMul.hMul (↑a₂) b₁)))","decl":"protected theorem eq {a₁ b₁} {a₂ b₂ : M} :\n    mk' S a₁ a₂ = mk' S b₁ b₂ ↔ ∃ c : M, ↑c * (↑b₂ * a₁) = c * (a₂ * b₁) :=\n  (toLocalizationMap M S).eq\n\n"}
{"name":"IsLocalization.mk'_eq_zero_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ns : Subtype fun x => Membership.mem M x\n⊢ Iff (Eq (IsLocalization.mk' S x s) 0) (Exists fun m => Eq (HMul.hMul (↑m) x) 0)","decl":"theorem mk'_eq_zero_iff (x : R) (s : M) : mk' S x s = 0 ↔ ∃ m : M, ↑m * x = 0 := by\n  rw [← (map_units S s).mul_left_inj, mk'_spec, zero_mul, map_eq_zero_iff M]\n\n"}
{"name":"IsLocalization.mk'_zero","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\ns : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S 0 s) 0","decl":"@[simp]\ntheorem mk'_zero (s : M) : IsLocalization.mk' S 0 s = 0 := by\n  rw [eq_comm, IsLocalization.eq_mk'_iff_mul_eq, zero_mul, map_zero]\n\n"}
{"name":"IsLocalization.ne_zero_of_mk'_ne_zero","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nhxy : Ne (IsLocalization.mk' S x y) 0\n⊢ Ne x 0","decl":"theorem ne_zero_of_mk'_ne_zero {x : R} {y : M} (hxy : IsLocalization.mk' S x y ≠ 0) : x ≠ 0 := by\n  rintro rfl\n  exact hxy (IsLocalization.mk'_zero _)\n\n"}
{"name":"IsLocalization.eq_iff_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\nP : Type u_3\ninst✝³ : CommSemiring P\ninst✝² : IsLocalization M S\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization M P\nx y : R\n⊢ Iff (Eq ((algebraMap R S) x) ((algebraMap R S) y)) (Eq ((algebraMap R P) x) ((algebraMap R P) y))","decl":"theorem eq_iff_eq [Algebra R P] [IsLocalization M P] {x y} :\n    algebraMap R S x = algebraMap R S y ↔ algebraMap R P x = algebraMap R P y :=\n  (toLocalizationMap M S).eq_iff_eq (toLocalizationMap M P)\n\n"}
{"name":"IsLocalization.mk'_eq_iff_mk'_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\nP : Type u_3\ninst✝³ : CommSemiring P\ninst✝² : IsLocalization M S\ninst✝¹ : Algebra R P\ninst✝ : IsLocalization M P\nx₁ x₂ : R\ny₁ y₂ : Subtype fun x => Membership.mem M x\n⊢ Iff (Eq (IsLocalization.mk' S x₁ y₁) (IsLocalization.mk' S x₂ y₂)) (Eq (IsLocalization.mk' P x₁ y₁) (IsLocalization.mk' P x₂ y₂))","decl":"theorem mk'_eq_iff_mk'_eq [Algebra R P] [IsLocalization M P] {x₁ x₂} {y₁ y₂ : M} :\n    mk' S x₁ y₁ = mk' S x₂ y₂ ↔ mk' P x₁ y₁ = mk' P x₂ y₂ :=\n  (toLocalizationMap M S).mk'_eq_iff_mk'_eq (toLocalizationMap M P)\n\n"}
{"name":"IsLocalization.mk'_eq_of_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na₁ b₁ : R\na₂ b₂ : Subtype fun x => Membership.mem M x\nH : Eq (HMul.hMul (↑a₂) b₁) (HMul.hMul (↑b₂) a₁)\n⊢ Eq (IsLocalization.mk' S a₁ a₂) (IsLocalization.mk' S b₁ b₂)","decl":"theorem mk'_eq_of_eq {a₁ b₁ : R} {a₂ b₂ : M} (H : ↑a₂ * b₁ = ↑b₂ * a₁) :\n    mk' S a₁ a₂ = mk' S b₁ b₂ :=\n  (toLocalizationMap M S).mk'_eq_of_eq H\n\n"}
{"name":"IsLocalization.mk'_eq_of_eq'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na₁ b₁ : R\na₂ b₂ : Subtype fun x => Membership.mem M x\nH : Eq (HMul.hMul b₁ ↑a₂) (HMul.hMul a₁ ↑b₂)\n⊢ Eq (IsLocalization.mk' S a₁ a₂) (IsLocalization.mk' S b₁ b₂)","decl":"theorem mk'_eq_of_eq' {a₁ b₁ : R} {a₂ b₂ : M} (H : b₁ * ↑a₂ = a₁ * ↑b₂) :\n    mk' S a₁ a₂ = mk' S b₁ b₂ :=\n  (toLocalizationMap M S).mk'_eq_of_eq' H\n\n"}
{"name":"IsLocalization.mk'_cancel","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : R\nb c : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (HMul.hMul a ↑c) (HMul.hMul b c)) (IsLocalization.mk' S a b)","decl":"theorem mk'_cancel (a : R) (b c : M) :\n    mk' S (a * c) (b * c) = mk' S a b := (toLocalizationMap M S).mk'_cancel _ _ _\n\n"}
{"name":"IsLocalization.mk'_self","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\nhx : Membership.mem M x\n⊢ Eq (IsLocalization.mk' S x ⟨x, hx⟩) 1","decl":"@[simp]\ntheorem mk'_self {x : R} (hx : x ∈ M) : mk' S x ⟨x, hx⟩ = 1 :=\n  (toLocalizationMap M S).mk'_self _ hx\n\n"}
{"name":"IsLocalization.mk'_self'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (↑x) x) 1","decl":"@[simp]\ntheorem mk'_self' {x : M} : mk' S (x : R) x = 1 :=\n  (toLocalizationMap M S).mk'_self' _\n\n"}
{"name":"IsLocalization.mk'_self''","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (↑x) x) 1","decl":"theorem mk'_self'' {x : M} : mk' S x.1 x = 1 :=\n  mk'_self' _\n\n"}
{"name":"IsLocalization.mul_mk'_eq_mk'_of_mul","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\nz : Subtype fun x => Membership.mem M x\n⊢ Eq (HMul.hMul ((algebraMap R S) x) (IsLocalization.mk' S y z)) (IsLocalization.mk' S (HMul.hMul x y) z)","decl":"theorem mul_mk'_eq_mk'_of_mul (x y : R) (z : M) :\n    (algebraMap R S) x * mk' S y z = mk' S (x * y) z :=\n  (toLocalizationMap M S).mul_mk'_eq_mk'_of_mul _ _ _\n\n"}
{"name":"IsLocalization.mk'_eq_mul_mk'_one","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S x y) (HMul.hMul ((algebraMap R S) x) (IsLocalization.mk' S 1 y))","decl":"theorem mk'_eq_mul_mk'_one (x : R) (y : M) : mk' S x y = (algebraMap R S) x * mk' S 1 y :=\n  ((toLocalizationMap M S).mul_mk'_one_eq_mk' _ _).symm\n\n"}
{"name":"IsLocalization.mk'_mul_cancel_left","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (HMul.hMul (↑y) x) y) ((algebraMap R S) x)","decl":"@[simp]\ntheorem mk'_mul_cancel_left (x : R) (y : M) : mk' S (y * x : R) y = (algebraMap R S) x :=\n  (toLocalizationMap M S).mk'_mul_cancel_left _ _\n\n"}
{"name":"IsLocalization.mk'_mul_cancel_right","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (HMul.hMul x ↑y) y) ((algebraMap R S) x)","decl":"theorem mk'_mul_cancel_right (x : R) (y : M) : mk' S (x * y) y = (algebraMap R S) x :=\n  (toLocalizationMap M S).mk'_mul_cancel_right _ _\n\n"}
{"name":"IsLocalization.mk'_mul_mk'_eq_one","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : Subtype fun x => Membership.mem M x\n⊢ Eq (HMul.hMul (IsLocalization.mk' S (↑x) y) (IsLocalization.mk' S (↑y) x)) 1","decl":"@[simp]\ntheorem mk'_mul_mk'_eq_one (x y : M) : mk' S (x : R) y * mk' S (y : R) x = 1 := by\n  rw [← mk'_mul, mul_comm]; exact mk'_self _ _\n\n"}
{"name":"IsLocalization.mk'_mul_mk'_eq_one'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\ny : Subtype fun x => Membership.mem M x\nh : Membership.mem M x\n⊢ Eq (HMul.hMul (IsLocalization.mk' S x y) (IsLocalization.mk' S ↑y ⟨x, h⟩)) 1","decl":"theorem mk'_mul_mk'_eq_one' (x : R) (y : M) (h : x ∈ M) : mk' S x y * mk' S (y : R) ⟨x, h⟩ = 1 :=\n  mk'_mul_mk'_eq_one ⟨x, h⟩ _\n\n"}
{"name":"IsLocalization.smul_mk'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx y : R\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (HSMul.hSMul x (IsLocalization.mk' S y m)) (IsLocalization.mk' S (HMul.hMul x y) m)","decl":"theorem smul_mk' (x y : R) (m : M) : x • mk' S y m = mk' S (x * y) m := by\n  nth_rw 2 [← one_mul m]\n  rw [mk'_mul, mk'_one, Algebra.smul_def]\n\n"}
{"name":"IsLocalization.smul_mk'_one","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (HSMul.hSMul x (IsLocalization.mk' S 1 m)) (IsLocalization.mk' S x m)","decl":"@[simp] theorem smul_mk'_one (x : R) (m : M) : x • mk' S 1 m = mk' S x m := by\n  rw [smul_mk', mul_one]\n\n"}
{"name":"IsLocalization.smul_mk'_self","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nm : Subtype fun x => Membership.mem M x\nr : R\n⊢ Eq (HSMul.hSMul (↑m) (IsLocalization.mk' S r m)) ((algebraMap R S) r)","decl":"@[simp] lemma smul_mk'_self {m : M} {r : R} :\n    (m : R) • mk' S r m = algebraMap R S r := by\n  rw [smul_mk', mk'_mul_cancel_left]\n\n"}
{"name":"IsLocalization.invertible_mk'_one_invOf","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\ns : Subtype fun x => Membership.mem M x\n⊢ Eq (Invertible.invOf (IsLocalization.mk' S 1 s)) ((algebraMap R S) ↑s)","decl":"@[simps]\ninstance invertible_mk'_one (s : M) : Invertible (IsLocalization.mk' S (1 : R) s) where\n  invOf := algebraMap R S s\n  invOf_mul_self := by simp\n  mul_invOf_self := by simp\n\n"}
{"name":"IsLocalization.isUnit_comp","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\nj : RingHom S P\ny : Subtype fun x => Membership.mem M x\n⊢ IsUnit ((j.comp (algebraMap R S)) ↑y)","decl":"theorem isUnit_comp (j : S →+* P) (y : M) : IsUnit (j.comp (algebraMap R S) y) :=\n  (toLocalizationMap M S).isUnit_comp j.toMonoidHom _\n\n"}
{"name":"IsLocalization.eq_of_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nx y : R\nh : Eq ((algebraMap R S) x) ((algebraMap R S) y)\n⊢ Eq (g x) (g y)","decl":"/-- Given a localization map `f : R →+* S` for a submonoid `M ⊆ R` and a map of `CommSemiring`s\n`g : R →+* P` such that `g(M) ⊆ Units P`, `f x = f y → g x = g y` for all `x y : R`. -/\ntheorem eq_of_eq {g : R →+* P} (hg : ∀ y : M, IsUnit (g y)) {x y}\n    (h : (algebraMap R S) x = (algebraMap R S) y) : g x = g y :=\n  Submonoid.LocalizationMap.eq_of_eq (toLocalizationMap M S) (g := g.toMonoidHom) hg h\n\n"}
{"name":"IsLocalization.mk'_add","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx₁ x₂ : R\ny₁ y₂ : Subtype fun x => Membership.mem M x\n⊢ Eq (IsLocalization.mk' S (HAdd.hAdd (HMul.hMul x₁ ↑y₂) (HMul.hMul x₂ ↑y₁)) (HMul.hMul y₁ y₂)) (HAdd.hAdd (IsLocalization.mk' S x₁ y₁) (IsLocalization.mk' S x₂ y₂))","decl":"theorem mk'_add (x₁ x₂ : R) (y₁ y₂ : M) :\n    mk' S (x₁ * y₂ + x₂ * y₁) (y₁ * y₂) = mk' S x₁ y₁ + mk' S x₂ y₂ :=\n  mk'_eq_iff_eq_mul.2 <|\n    Eq.symm\n      (by\n        rw [mul_comm (_ + _), mul_add, mul_mk'_eq_mk'_of_mul, mk'_add_eq_iff_add_mul_eq_mul,\n          mul_comm (_ * _), ← mul_assoc, add_comm, ← map_mul, mul_mk'_eq_mk'_of_mul,\n          mk'_add_eq_iff_add_mul_eq_mul]\n        simp only [map_add, Submonoid.coe_mul, map_mul]\n        ring)\n\n"}
{"name":"IsLocalization.mul_add_inv_left","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝¹ : CommSemiring R\nM : Submonoid R\nP : Type u_3\ninst✝ : CommSemiring P\ng : RingHom R P\nh : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\ny : Subtype fun x => Membership.mem M x\nw z₁ z₂ : P\n⊢ Iff (Eq (HAdd.hAdd (HMul.hMul w ↑(Inv.inv ((IsUnit.liftRight ((↑g).restrict M) h) y))) z₁) z₂) (Eq (HAdd.hAdd w (HMul.hMul (g ↑y) z₁)) (HMul.hMul (g ↑y) z₂))","decl":"theorem mul_add_inv_left {g : R →+* P} (h : ∀ y : M, IsUnit (g y)) (y : M) (w z₁ z₂ : P) :\n    w * ↑(IsUnit.liftRight (g.toMonoidHom.restrict M) h y)⁻¹ + z₁ =\n    z₂ ↔ w + g y * z₁ = g y * z₂ := by\n  rw [mul_comm, ← one_mul z₁, ← Units.inv_mul (IsUnit.liftRight (g.toMonoidHom.restrict M) h y),\n    mul_assoc, ← mul_add, Units.inv_mul_eq_iff_eq_mul, Units.inv_mul_cancel_left,\n    IsUnit.coe_liftRight]\n  simp [RingHom.toMonoidHom_eq_coe, MonoidHom.restrict_apply]\n\n"}
{"name":"IsLocalization.lift_spec_mul_add","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nz : S\nw w' v : P\n⊢ Iff (Eq (HAdd.hAdd (HMul.hMul (((IsLocalization.toLocalizationWithZeroMap M S).lift g.toMonoidWithZeroHom hg) z) w) w') v) (Eq (HAdd.hAdd (HMul.hMul (g ((IsLocalization.toLocalizationMap M S).sec z).1) w) (HMul.hMul (g ↑((IsLocalization.toLocalizationMap M S).sec z).2) w')) (HMul.hMul (g ↑((IsLocalization.toLocalizationMap M S).sec z).2) v))","decl":"theorem lift_spec_mul_add {g : R →+* P} (hg : ∀ y : M, IsUnit (g y)) (z w w' v) :\n    ((toLocalizationWithZeroMap M S).lift g.toMonoidWithZeroHom hg) z * w + w' = v ↔\n      g ((toLocalizationMap M S).sec z).1 * w + g ((toLocalizationMap M S).sec z).2 * w' =\n        g ((toLocalizationMap M S).sec z).2 * v := by\n  erw [mul_comm, ← mul_assoc, mul_add_inv_left hg, mul_comm]\n  rfl\n\n"}
{"name":"IsLocalization.lift_mk'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.lift hg) (IsLocalization.mk' S x y)) (HMul.hMul (g x) ↑(Inv.inv ((IsUnit.liftRight ((↑g).restrict M) hg) y)))","decl":"/-- Given a localization map `f : R →+* S` for a submonoid `M ⊆ R` and a map of `CommSemiring`s\n`g : R →* P` such that `g y` is invertible for all `y : M`, the homomorphism induced from\n`S` to `P` maps `f x * (f y)⁻¹` to `g x * (g y)⁻¹` for all `x : R, y ∈ M`. -/\ntheorem lift_mk' (x y) :\n    lift hg (mk' S x y) = g x * ↑(IsUnit.liftRight (g.toMonoidHom.restrict M) hg y)⁻¹ :=\n  (toLocalizationMap M S).lift_mk' _ _ _\n\n"}
{"name":"IsLocalization.lift_mk'_spec","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nx : R\nv : P\ny : Subtype fun x => Membership.mem M x\n⊢ Iff (Eq ((IsLocalization.lift hg) (IsLocalization.mk' S x y)) v) (Eq (g x) (HMul.hMul (g ↑y) v))","decl":"theorem lift_mk'_spec (x v) (y : M) : lift hg (mk' S x y) = v ↔ g x = g y * v :=\n  (toLocalizationMap M S).lift_mk'_spec _ _ _ _\n\n"}
{"name":"IsLocalization.lift_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nx : R\n⊢ Eq ((IsLocalization.lift hg) ((algebraMap R S) x)) (g x)","decl":"@[simp]\ntheorem lift_eq (x : R) : lift hg ((algebraMap R S) x) = g x :=\n  (toLocalizationMap M S).lift_eq _ _\n\n"}
{"name":"IsLocalization.lift_eq_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nx y : Prod R (Subtype fun x => Membership.mem M x)\n⊢ Iff (Eq ((IsLocalization.lift hg) (IsLocalization.mk' S x.1 x.2)) ((IsLocalization.lift hg) (IsLocalization.mk' S y.1 y.2))) (Eq (g (HMul.hMul x.1 ↑y.2)) (g (HMul.hMul y.1 ↑x.2)))","decl":"theorem lift_eq_iff {x y : R × M} :\n    lift hg (mk' S x.1 x.2) = lift hg (mk' S y.1 y.2) ↔ g (x.1 * y.2) = g (y.1 * x.2) :=\n  (toLocalizationMap M S).lift_eq_iff _\n\n"}
{"name":"IsLocalization.lift_comp","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\n⊢ Eq ((IsLocalization.lift hg).comp (algebraMap R S)) g","decl":"@[simp]\ntheorem lift_comp : (lift hg).comp (algebraMap R S) = g :=\n  RingHom.ext <| (DFunLike.ext_iff (F := MonoidHom _ _)).1 <| (toLocalizationMap M S).lift_comp _\n\n"}
{"name":"IsLocalization.lift_of_comp","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\nj : RingHom S P\n⊢ Eq (IsLocalization.lift ⋯) j","decl":"@[simp]\ntheorem lift_of_comp (j : S →+* P) : lift (isUnit_comp M j) = j :=\n  RingHom.ext <| (DFunLike.ext_iff (F := MonoidHom _ _)).1 <|\n    (toLocalizationMap M S).lift_of_comp j.toMonoidHom\n\n"}
{"name":"IsLocalization.monoidHom_ext","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\nj k : MonoidHom S P\nh : Eq (j.comp ↑(algebraMap R S)) (k.comp ↑(algebraMap R S))\n⊢ Eq j k","decl":"/-- See note [partially-applied ext lemmas] -/\ntheorem monoidHom_ext ⦃j k : S →* P⦄\n    (h : j.comp (algebraMap R S : R →* S) = k.comp (algebraMap R S)) : j = k :=\n  Submonoid.LocalizationMap.epic_of_localizationMap (toLocalizationMap M S) <| DFunLike.congr_fun h\n\n"}
{"name":"IsLocalization.ringHom_ext","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\nj k : RingHom S P\nh : Eq (j.comp (algebraMap R S)) (k.comp (algebraMap R S))\n⊢ Eq j k","decl":"/-- See note [partially-applied ext lemmas] -/\ntheorem ringHom_ext ⦃j k : S →+* P⦄ (h : j.comp (algebraMap R S) = k.comp (algebraMap R S)) :\n    j = k :=\n  RingHom.coe_monoidHom_injective <| monoidHom_ext M <| MonoidHom.ext <| RingHom.congr_fun h\n\n"}
{"name":"IsLocalization.ext","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\nj k : S → P\nhj1 : Eq (j 1) 1\nhk1 : Eq (k 1) 1\nhjm : ∀ (a b : S), Eq (j (HMul.hMul a b)) (HMul.hMul (j a) (j b))\nhkm : ∀ (a b : S), Eq (k (HMul.hMul a b)) (HMul.hMul (k a) (k b))\nh : ∀ (a : R), Eq (j ((algebraMap R S) a)) (k ((algebraMap R S) a))\n⊢ Eq j k","decl":"/-- To show `j` and `k` agree on the whole localization, it suffices to show they agree\non the image of the base ring, if they preserve `1` and `*`. -/\nprotected theorem ext (j k : S → P) (hj1 : j 1 = 1) (hk1 : k 1 = 1)\n    (hjm : ∀ a b, j (a * b) = j a * j b) (hkm : ∀ a b, k (a * b) = k a * k b)\n    (h : ∀ a, j (algebraMap R S a) = k (algebraMap R S a)) : j = k :=\n  let j' : MonoidHom S P :=\n    { toFun := j, map_one' := hj1, map_mul' := hjm }\n  let k' : MonoidHom S P :=\n    { toFun := k, map_one' := hk1, map_mul' := hkm }\n  have : j' = k' := monoidHom_ext M (MonoidHom.ext h)\n  show j'.toFun = k'.toFun by rw [this]\n"}
{"name":"IsLocalization.lift_unique","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\nj : RingHom S P\nhj : ∀ (x : R), Eq (j ((algebraMap R S) x)) (g x)\n⊢ Eq (IsLocalization.lift hg) j","decl":"theorem lift_unique {j : S →+* P} (hj : ∀ x, j ((algebraMap R S) x) = g x) : lift hg = j :=\n  RingHom.ext <|\n    (DFunLike.ext_iff (F := MonoidHom _ _)).1 <|\n      Submonoid.LocalizationMap.lift_unique (toLocalizationMap M S) (g := g.toMonoidHom) hg\n        (j := j.toMonoidHom) hj\n\n"}
{"name":"IsLocalization.lift_id","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : S\n⊢ Eq ((IsLocalization.lift ⋯) x) x","decl":"@[simp]\ntheorem lift_id (x) : lift (map_units S : ∀ _ : M, IsUnit _) x = x :=\n  (toLocalizationMap M S).lift_id _\n\n"}
{"name":"IsLocalization.lift_surjective_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\n⊢ Iff (Function.Surjective ⇑(IsLocalization.lift hg)) (∀ (v : P), Exists fun x => Eq (HMul.hMul v (g ↑x.2)) (g x.1))","decl":"theorem lift_surjective_iff :\n    Surjective (lift hg : S → P) ↔ ∀ v : P, ∃ x : R × M, v * g x.2 = g x.1 :=\n  (toLocalizationMap M S).lift_surjective_iff hg\n\n"}
{"name":"IsLocalization.lift_injective_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\ng : RingHom R P\nhg : ∀ (y : Subtype fun x => Membership.mem M x), IsUnit (g ↑y)\n⊢ Iff (Function.Injective ⇑(IsLocalization.lift hg)) (∀ (x y : R), Iff (Eq ((algebraMap R S) x) ((algebraMap R S) y)) (Eq (g x) (g y)))","decl":"theorem lift_injective_iff :\n    Injective (lift hg : S → P) ↔ ∀ x y, algebraMap R S x = algebraMap R S y ↔ g x = g y :=\n  (toLocalizationMap M S).lift_injective_iff hg\n\n"}
{"name":"IsLocalization.injective_iff_map_algebraMap_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\nT : Type u_4\ninst✝ : CommRing T\nf : RingHom S T\n⊢ Iff (Function.Injective ⇑f) (∀ (x y : R), Iff (Eq ((algebraMap R S) x) ((algebraMap R S) y)) (Eq (f ((algebraMap R S) x)) (f ((algebraMap R S) y))))","decl":"variable (M) in\ninclude M in\nlemma injective_iff_map_algebraMap_eq {T} [CommRing T] (f : S →+* T) :\n    Function.Injective f ↔ ∀ x y,\n      algebraMap R S x = algebraMap R S y ↔ f (algebraMap R S x) = f (algebraMap R S y) := by\n  rw [← IsLocalization.lift_of_comp (M := M) f, IsLocalization.lift_injective_iff]\n  simp\n\n"}
{"name":"IsLocalization.map_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\nx : R\n⊢ Eq ((IsLocalization.map Q g hy) ((algebraMap R S) x)) ((algebraMap P Q) (g x))","decl":"@[simp]\ntheorem map_eq (x) : map Q g hy ((algebraMap R S) x) = algebraMap P Q (g x) :=\n  lift_eq (fun y => map_units _ ⟨g y, hy y.2⟩) x\n\n"}
{"name":"IsLocalization.map_comp","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\n⊢ Eq ((IsLocalization.map Q g hy).comp (algebraMap R S)) ((algebraMap P Q).comp g)","decl":"@[simp]\ntheorem map_comp : (map Q g hy).comp (algebraMap R S) = (algebraMap P Q).comp g :=\n  lift_comp fun y => map_units _ ⟨g y, hy y.2⟩\n\n"}
{"name":"IsLocalization.map_mk'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.map Q g hy) (IsLocalization.mk' S x y)) (IsLocalization.mk' Q (g x) ⟨g ↑y, ⋯⟩)","decl":"theorem map_mk' (x) (y : M) : map Q g hy (mk' S x y) = mk' Q (g x) ⟨g y, hy y.2⟩ :=\n  Submonoid.LocalizationMap.map_mk' (toLocalizationMap M S) (g := g.toMonoidHom)\n    (fun y => hy y.2) (k := toLocalizationMap T Q) ..\n\n"}
{"name":"IsLocalization.map_unique","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\nj : RingHom S Q\nhj : ∀ (x : R), Eq (j ((algebraMap R S) x)) ((algebraMap P Q) (g x))\n⊢ Eq (IsLocalization.map Q g hy) j","decl":"theorem map_unique (j : S →+* Q) (hj : ∀ x : R, j (algebraMap R S x) = algebraMap P Q (g x)) :\n    map Q g hy = j :=\n  lift_unique (fun y => map_units _ ⟨g y, hy y.2⟩) hj\n\n"}
{"name":"IsLocalization.map_comp_map","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommSemiring S\ninst✝⁹ : Algebra R S\nP : Type u_3\ninst✝⁸ : CommSemiring P\ninst✝⁷ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝⁶ : CommSemiring Q\ninst✝⁵ : Algebra P Q\ninst✝⁴ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\nA : Type u_5\ninst✝³ : CommSemiring A\nU : Submonoid A\nW : Type u_6\ninst✝² : CommSemiring W\ninst✝¹ : Algebra A W\ninst✝ : IsLocalization U W\nl : RingHom P A\nhl : LE.le T (Submonoid.comap l U)\n⊢ Eq ((IsLocalization.map W l hl).comp (IsLocalization.map Q g hy)) (IsLocalization.map W (l.comp g) ⋯)","decl":"/-- If `CommSemiring` homs `g : R →+* P, l : P →+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\ntheorem map_comp_map {A : Type*} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W]\n    [Algebra A W] [IsLocalization U W] {l : P →+* A} (hl : T ≤ U.comap l) :\n    (map W l hl).comp (map Q g hy : S →+* _) = map W (l.comp g) fun _ hx => hl (hy hx) :=\n  RingHom.ext fun x =>\n    Submonoid.LocalizationMap.map_map (P := P) (toLocalizationMap M S) (fun y => hy y.2)\n      (toLocalizationMap U W) (fun w => hl w.2) x\n\n"}
{"name":"IsLocalization.map_map","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝¹¹ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝¹⁰ : CommSemiring S\ninst✝⁹ : Algebra R S\nP : Type u_3\ninst✝⁸ : CommSemiring P\ninst✝⁷ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝⁶ : CommSemiring Q\ninst✝⁵ : Algebra P Q\ninst✝⁴ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\nA : Type u_5\ninst✝³ : CommSemiring A\nU : Submonoid A\nW : Type u_6\ninst✝² : CommSemiring W\ninst✝¹ : Algebra A W\ninst✝ : IsLocalization U W\nl : RingHom P A\nhl : LE.le T (Submonoid.comap l U)\nx : S\n⊢ Eq ((IsLocalization.map W l hl) ((IsLocalization.map Q g hy) x)) ((IsLocalization.map W (l.comp g) ⋯) x)","decl":"/-- If `CommSemiring` homs `g : R →+* P, l : P →+* A` induce maps of localizations, the composition\nof the induced maps equals the map of localizations induced by `l ∘ g`. -/\ntheorem map_map {A : Type*} [CommSemiring A] {U : Submonoid A} {W} [CommSemiring W] [Algebra A W]\n    [IsLocalization U W] {l : P →+* A} (hl : T ≤ U.comap l) (x : S) :\n    map W l hl (map Q g hy x) = map W (l.comp g) (fun _ hx => hl (hy hx)) x := by\n  rw [← map_comp_map (Q := Q) hy hl]; rfl\n\n"}
{"name":"IsLocalization.map_smul","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nhy : LE.le M (Submonoid.comap g T)\nx : S\nz : R\n⊢ Eq ((IsLocalization.map Q g hy) (HSMul.hSMul z x)) (HSMul.hSMul (g z) ((IsLocalization.map Q g hy) x))","decl":"protected theorem map_smul (x : S) (z : R) : map Q g hy (z • x : S) = g z • map Q g hy x := by\n  rw [Algebra.smul_def, Algebra.smul_def, RingHom.map_mul, map_eq]\n\n"}
{"name":"IsLocalization.map_id_mk'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁶ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁵ : CommSemiring S\ninst✝⁴ : Algebra R S\ninst✝³ : IsLocalization M S\nQ : Type u_5\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra R Q\ninst✝ : IsLocalization M Q\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.map Q (RingHom.id R) ⋯) (IsLocalization.mk' S x y)) (IsLocalization.mk' Q x y)","decl":"@[simp]\ntheorem map_id_mk' {Q : Type*} [CommSemiring Q] [Algebra R Q] [IsLocalization M Q] (x) (y : M) :\n    map Q (RingHom.id R) (le_refl M) (mk' S x y) = mk' Q x y :=\n  map_mk' ..\n\n"}
{"name":"IsLocalization.map_id","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nz : S\nh : optParam (LE.le M (Submonoid.comap (RingHom.id R) M)) ⋯\n⊢ Eq ((IsLocalization.map S (RingHom.id R) h) z) z","decl":"@[simp]\ntheorem map_id (z : S) (h : M ≤ M.comap (RingHom.id R) := le_refl M) :\n    map S (RingHom.id _) h z = z :=\n  lift_id _\n\n"}
{"name":"IsLocalization.ringEquivOfRingEquiv_symm_apply","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nh : RingEquiv R P\nH : Eq (Submonoid.map h.toMonoidHom M) T\na : Q\n⊢ Eq ((IsLocalization.ringEquivOfRingEquiv S Q h H).symm a) ((IsLocalization.map S ↑h.symm ⋯) a)","decl":"/-- If `S`, `Q` are localizations of `R` and `P` at submonoids `M, T` respectively, an\nisomorphism `j : R ≃+* P` such that `j(M) = T` induces an isomorphism of localizations\n`S ≃+* Q`. -/\n@[simps]\nnoncomputable def ringEquivOfRingEquiv (h : R ≃+* P) (H : M.map h.toMonoidHom = T) : S ≃+* Q :=\n  have H' : T.map h.symm.toMonoidHom = M := by\n    rw [← M.map_id, ← H, Submonoid.map_map]\n    congr\n    ext\n    apply h.symm_apply_apply\n  { map Q (h : R →+* P) (M.le_comap_of_map_le (le_of_eq H)) with\n    toFun := map Q (h : R →+* P) (M.le_comap_of_map_le (le_of_eq H))\n    invFun := map S (h.symm : P →+* R) (T.le_comap_of_map_le (le_of_eq H'))\n    left_inv := fun x => by\n      rw [map_map, map_unique _ (RingHom.id _), RingHom.id_apply]\n      simp\n    right_inv := fun x => by\n      rw [map_map, map_unique _ (RingHom.id _), RingHom.id_apply]\n      simp }\n\n"}
{"name":"IsLocalization.ringEquivOfRingEquiv_apply","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nh : RingEquiv R P\nH : Eq (Submonoid.map h.toMonoidHom M) T\na : S\n⊢ Eq ((IsLocalization.ringEquivOfRingEquiv S Q h H) a) ((IsLocalization.map Q ↑h ⋯) a)","decl":"/-- If `S`, `Q` are localizations of `R` and `P` at submonoids `M, T` respectively, an\nisomorphism `j : R ≃+* P` such that `j(M) = T` induces an isomorphism of localizations\n`S ≃+* Q`. -/\n@[simps]\nnoncomputable def ringEquivOfRingEquiv (h : R ≃+* P) (H : M.map h.toMonoidHom = T) : S ≃+* Q :=\n  have H' : T.map h.symm.toMonoidHom = M := by\n    rw [← M.map_id, ← H, Submonoid.map_map]\n    congr\n    ext\n    apply h.symm_apply_apply\n  { map Q (h : R →+* P) (M.le_comap_of_map_le (le_of_eq H)) with\n    toFun := map Q (h : R →+* P) (M.le_comap_of_map_le (le_of_eq H))\n    invFun := map S (h.symm : P →+* R) (T.le_comap_of_map_le (le_of_eq H'))\n    left_inv := fun x => by\n      rw [map_map, map_unique _ (RingHom.id _), RingHom.id_apply]\n      simp\n    right_inv := fun x => by\n      rw [map_map, map_unique _ (RingHom.id _), RingHom.id_apply]\n      simp }\n\n"}
{"name":"IsLocalization.ringEquivOfRingEquiv_eq_map","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nj : RingEquiv R P\nH : Eq (Submonoid.map j.toMonoidHom M) T\n⊢ Eq (↑(IsLocalization.ringEquivOfRingEquiv S Q j H)) (IsLocalization.map Q ↑j ⋯)","decl":"theorem ringEquivOfRingEquiv_eq_map {j : R ≃+* P} (H : M.map j.toMonoidHom = T) :\n    (ringEquivOfRingEquiv S Q j H : S →+* Q) =\n      map Q (j : R →+* P) (M.le_comap_of_map_le (le_of_eq H)) :=\n  rfl\n\n"}
{"name":"IsLocalization.ringEquivOfRingEquiv_eq","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nj : RingEquiv R P\nH : Eq (Submonoid.map j.toMonoidHom M) T\nx : R\n⊢ Eq ((IsLocalization.ringEquivOfRingEquiv S Q j H) ((algebraMap R S) x)) ((algebraMap P Q) (j x))","decl":"theorem ringEquivOfRingEquiv_eq {j : R ≃+* P} (H : M.map j.toMonoidHom = T) (x) :\n    ringEquivOfRingEquiv S Q j H ((algebraMap R S) x) = algebraMap P Q (j x) := by\n  simp\n\n"}
{"name":"IsLocalization.ringEquivOfRingEquiv_mk'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nj : RingEquiv R P\nH : Eq (Submonoid.map j.toMonoidHom M) T\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq ((IsLocalization.ringEquivOfRingEquiv S Q j H) (IsLocalization.mk' S x y)) (IsLocalization.mk' Q (j x) ⟨j ↑y, ⋯⟩)","decl":"theorem ringEquivOfRingEquiv_mk' {j : R ≃+* P} (H : M.map j.toMonoidHom = T) (x : R) (y : M) :\n    ringEquivOfRingEquiv S Q j H (mk' S x y) =\n      mk' Q (j x) ⟨j y, show j y ∈ T from H ▸ Set.mem_image_of_mem j y.2⟩ := by\n  simp [map_mk']\n\n"}
{"name":"IsLocalization.ringEquivOfRingEquiv_symm","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\nT : Submonoid P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\ninst✝ : IsLocalization T Q\nj : RingEquiv R P\nH : Eq (Submonoid.map j.toMonoidHom M) T\n⊢ Eq (IsLocalization.ringEquivOfRingEquiv S Q j H).symm (IsLocalization.ringEquivOfRingEquiv Q S j.symm ⋯)","decl":"@[simp]\ntheorem ringEquivOfRingEquiv_symm {j : R ≃+* P} (H : M.map j.toMonoidHom = T) :\n    (ringEquivOfRingEquiv S Q j H).symm =\n      ringEquivOfRingEquiv Q S j.symm (show T.map j.symm.toMonoidHom = M by\n        erw [← H, ← Submonoid.comap_equiv_eq_map_symm,\n          Submonoid.comap_map_eq_of_injective j.injective]) := rfl\n\n"}
{"name":"IsLocalization.at_units","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nS : Submonoid R\nhS : LE.le S (IsUnit.submonoid R)\n⊢ IsLocalization S R","decl":"lemma at_units (S : Submonoid R)\n    (hS : S ≤ IsUnit.submonoid R) : IsLocalization S R where\n  map_units' y := hS y.prop\n  surj' := fun s ↦ ⟨⟨s, 1⟩, by simp⟩\n  exists_of_eq := fun {x y} (e : x = y) ↦ ⟨1, e ▸ rfl⟩\n\n"}
{"name":"IsLocalization.map_injective_of_injective","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\nh : Function.Injective ⇑g\ninst✝ : IsLocalization (Submonoid.map g M) Q\n⊢ Function.Injective ⇑(IsLocalization.map Q g ⋯)","decl":"/-- Injectivity of a map descends to the map induced on localizations. -/\ntheorem map_injective_of_injective (h : Function.Injective g) [IsLocalization (M.map g) Q] :\n    Function.Injective (map Q g M.le_comap_map : S → Q) :=\n  (toLocalizationMap M S).map_injective_of_injective h (toLocalizationMap (M.map g) Q)\n\n"}
{"name":"IsLocalization.map_surjective_of_surjective","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁷ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝⁶ : CommSemiring S\ninst✝⁵ : Algebra R S\nP : Type u_3\ninst✝⁴ : CommSemiring P\ninst✝³ : IsLocalization M S\ng : RingHom R P\nQ : Type u_4\ninst✝² : CommSemiring Q\ninst✝¹ : Algebra P Q\nh : Function.Surjective ⇑g\ninst✝ : IsLocalization (Submonoid.map g M) Q\n⊢ Function.Surjective ⇑(IsLocalization.map Q g ⋯)","decl":"/-- Surjectivity of a map descends to the map induced on localizations. -/\ntheorem map_surjective_of_surjective (h : Function.Surjective g) [IsLocalization (M.map g) Q] :\n    Function.Surjective (map Q g M.le_comap_map : S → Q) :=\n  (toLocalizationMap M S).map_surjective_of_surjective h (toLocalizationMap (M.map g) Q)\n\n"}
{"name":"IsLocalization.isLocalization_of_base_ringEquiv","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommSemiring S\ninst✝² : Algebra R S\nP : Type u_3\ninst✝¹ : CommSemiring P\ninst✝ : IsLocalization M S\nh : RingEquiv R P\n⊢ IsLocalization (Submonoid.map h.toMonoidHom M) S","decl":"theorem isLocalization_of_base_ringEquiv [IsLocalization M S] (h : R ≃+* P) :\n    haveI := ((algebraMap R S).comp h.symm.toRingHom).toAlgebra\n    IsLocalization (M.map h.toMonoidHom) S := by\n  letI : Algebra P S := ((algebraMap R S).comp h.symm.toRingHom).toAlgebra\n  constructor\n  · rintro ⟨_, ⟨y, hy, rfl⟩⟩\n    convert IsLocalization.map_units S ⟨y, hy⟩\n    dsimp only [RingHom.algebraMap_toAlgebra, RingHom.comp_apply]\n    exact congr_arg _ (h.symm_apply_apply _)\n  · intro y\n    obtain ⟨⟨x, s⟩, e⟩ := IsLocalization.surj M y\n    refine ⟨⟨h x, _, _, s.prop, rfl⟩, ?_⟩\n    dsimp only [RingHom.algebraMap_toAlgebra, RingHom.comp_apply] at e ⊢\n    convert e <;> exact h.symm_apply_apply _\n  · intro x y\n    rw [RingHom.algebraMap_toAlgebra, RingHom.comp_apply, RingHom.comp_apply,\n      IsLocalization.eq_iff_exists M S]\n    simp_rw [← h.toEquiv.apply_eq_iff_eq]\n    change (∃ c : M, h (c * h.symm x) = h (c * h.symm y)) → _\n    simp only [RingEquiv.apply_symm_apply, RingEquiv.map_mul]\n    exact fun ⟨c, e⟩ ↦ ⟨⟨_, _, c.prop, rfl⟩, e⟩\n\n"}
{"name":"IsLocalization.isLocalization_iff_of_base_ringEquiv","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\nP : Type u_3\ninst✝ : CommSemiring P\nh : RingEquiv R P\n⊢ Iff (IsLocalization M S) (IsLocalization (Submonoid.map h.toMonoidHom M) S)","decl":"theorem isLocalization_iff_of_base_ringEquiv (h : R ≃+* P) :\n    IsLocalization M S ↔\n      haveI := ((algebraMap R S).comp h.symm.toRingHom).toAlgebra\n      IsLocalization (M.map h.toMonoidHom) S := by\n  letI : Algebra P S := ((algebraMap R S).comp h.symm.toRingHom).toAlgebra\n  refine ⟨fun _ => isLocalization_of_base_ringEquiv M S h, ?_⟩\n  intro H\n  convert isLocalization_of_base_ringEquiv (Submonoid.map (RingEquiv.toMonoidHom h) M) S h.symm\n  · erw [Submonoid.map_equiv_eq_comap_symm, Submonoid.comap_map_eq_of_injective]\n    exact h.toEquiv.injective\n  rw [RingHom.algebraMap_toAlgebra, RingHom.comp_assoc]\n  simp only [RingHom.comp_id, RingEquiv.symm_symm, RingEquiv.symm_toRingHom_comp_toRingHom]\n  apply Algebra.algebra_ext\n  intro r\n  rw [RingHom.algebraMap_toAlgebra]\n\n"}
{"name":"IsLocalization.nonZeroDivisors_le_comap","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ LE.le (nonZeroDivisors R) (Submonoid.comap (algebraMap R S) (nonZeroDivisors S))","decl":"theorem nonZeroDivisors_le_comap [IsLocalization M S] :\n    nonZeroDivisors R ≤ (nonZeroDivisors S).comap (algebraMap R S) := by\n  rintro a ha b (e : b * algebraMap R S a = 0)\n  obtain ⟨x, s, rfl⟩ := mk'_surjective M b\n  rw [← @mk'_one R _ M, ← mk'_mul, ← (algebraMap R S).map_zero, ← @mk'_one R _ M,\n    IsLocalization.eq] at e\n  obtain ⟨c, e⟩ := e\n  rw [mul_zero, mul_zero, Submonoid.coe_one, one_mul, ← mul_assoc] at e\n  rw [mk'_eq_zero_iff]\n  exact ⟨c, ha _ e⟩\n\n"}
{"name":"IsLocalization.map_nonZeroDivisors_le","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommSemiring R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommSemiring S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ LE.le (Submonoid.map (algebraMap R S) (nonZeroDivisors R)) (nonZeroDivisors S)","decl":"theorem map_nonZeroDivisors_le [IsLocalization M S] :\n    (nonZeroDivisors R).map (algebraMap R S) ≤ nonZeroDivisors S :=\n  Submonoid.map_le_iff_le_comap.mpr (nonZeroDivisors_le_comap M S)\n\n"}
{"name":"Localization.add_mk","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\na : R\nb : Subtype fun x => Membership.mem M x\nc : R\nd : Subtype fun x => Membership.mem M x\n⊢ Eq (HAdd.hAdd (Localization.mk a b) (Localization.mk c d)) (Localization.mk (HAdd.hAdd (HMul.hMul (↑b) c) (HMul.hMul (↑d) a)) (HMul.hMul b d))","decl":"theorem add_mk (a b c d) : (mk a b : Localization M) + mk c d =\n    mk ((b : R) * c + (d : R) * a) (b * d) := by\n  rw [add_comm (b * c) (d * a), mul_comm b d]\n  exact OreLocalization.oreDiv_add_oreDiv\n\n"}
{"name":"Localization.add_mk_self","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\na : R\nb : Subtype fun x => Membership.mem M x\nc : R\n⊢ Eq (HAdd.hAdd (Localization.mk a b) (Localization.mk c b)) (Localization.mk (HAdd.hAdd a c) b)","decl":"theorem add_mk_self (a b c) : (mk a b : Localization M) + mk c b = mk (a + c) b := by\n  rw [add_mk, mk_eq_mk_iff, r_eq_r']\n  refine (r' M).symm ⟨1, ?_⟩\n  simp only [Submonoid.coe_one, Submonoid.coe_mul]\n  ring\n\n"}
{"name":"Localization.mkAddMonoidHom_apply","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nb : Subtype fun x => Membership.mem M x\na : R\n⊢ Eq ((Localization.mkAddMonoidHom b) a) (Localization.mk a b)","decl":"/-- For any given denominator `b : M`, the map `a ↦ a / b` is an `AddMonoidHom` from `R` to\n  `Localization M`-/\n@[simps]\ndef mkAddMonoidHom (b : M) : R →+ Localization M where\n  toFun a := mk a b\n  map_zero' := mk_zero _\n  map_add' _ _ := (add_mk_self _ _ _).symm\n\n"}
{"name":"Localization.mk_sum","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nι : Type u_4\nf : ι → R\ns : Finset ι\nb : Subtype fun x => Membership.mem M x\n⊢ Eq (Localization.mk (s.sum fun i => f i) b) (s.sum fun i => Localization.mk (f i) b)","decl":"theorem mk_sum {ι : Type*} (f : ι → R) (s : Finset ι) (b : M) :\n    mk (∑ i ∈ s, f i) b = ∑ i ∈ s, mk (f i) b :=\n  map_sum (mkAddMonoidHom b) f s\n\n"}
{"name":"Localization.mk_list_sum","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nl : List R\nb : Subtype fun x => Membership.mem M x\n⊢ Eq (Localization.mk l.sum b) (List.map (fun a => Localization.mk a b) l).sum","decl":"theorem mk_list_sum (l : List R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum :=\n  map_list_sum (mkAddMonoidHom b) l\n\n"}
{"name":"Localization.mk_multiset_sum","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nl : Multiset R\nb : Subtype fun x => Membership.mem M x\n⊢ Eq (Localization.mk l.sum b) (Multiset.map (fun a => Localization.mk a b) l).sum","decl":"theorem mk_multiset_sum (l : Multiset R) (b : M) : mk l.sum b = (l.map fun a => mk a b).sum :=\n  (mkAddMonoidHom b).map_multiset_sum l\n\n"}
{"name":"Localization.isLocalization","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\n⊢ IsLocalization M (Localization M)","decl":"instance isLocalization : IsLocalization M (Localization M) where\n  map_units' := (Localization.monoidOf M).map_units\n  surj' := (Localization.monoidOf M).surj\n  exists_of_eq := (Localization.monoidOf M).eq_iff_exists.mp\n\n"}
{"name":"Localization.toLocalizationMap_eq_monoidOf","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\n⊢ Eq (IsLocalization.toLocalizationMap M (Localization M)) (Localization.monoidOf M)","decl":"@[simp]\ntheorem toLocalizationMap_eq_monoidOf : toLocalizationMap M (Localization M) = monoidOf M :=\n  rfl\n\n"}
{"name":"Localization.monoidOf_eq_algebraMap","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nx : R\n⊢ Eq ((Localization.monoidOf M).toMap x) ((algebraMap R (Localization M)) x)","decl":"theorem monoidOf_eq_algebraMap (x) : (monoidOf M).toMap x = algebraMap R (Localization M) x :=\n  rfl\n\n"}
{"name":"Localization.mk_one_eq_algebraMap","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nx : R\n⊢ Eq (Localization.mk x 1) ((algebraMap R (Localization M)) x)","decl":"theorem mk_one_eq_algebraMap (x) : mk x 1 = algebraMap R (Localization M) x :=\n  rfl\n\n"}
{"name":"Localization.mk_eq_mk'_apply","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\nx : R\ny : Subtype fun x => Membership.mem M x\n⊢ Eq (Localization.mk x y) (IsLocalization.mk' (Localization M) x y)","decl":"theorem mk_eq_mk'_apply (x y) : mk x y = IsLocalization.mk' (Localization M) x y := by\n  rw [mk_eq_monoidOf_mk'_apply, mk', toLocalizationMap_eq_monoidOf]\n\n-- Porting note: removed `simp`. Left hand side can be simplified; not clear what normal form should\n--be.\n"}
{"name":"Localization.mk_eq_mk'","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommSemiring R\nM : Submonoid R\n⊢ Eq Localization.mk (IsLocalization.mk' (Localization M))","decl":"theorem mk_eq_mk' : (mk : R → M → Localization M) = IsLocalization.mk' (Localization M) :=\n  mk_eq_monoidOf_mk'\n\n"}
{"name":"Localization.mk_algebraMap","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝² : CommSemiring R\nM : Submonoid R\nA : Type u_4\ninst✝¹ : CommSemiring A\ninst✝ : Algebra A R\nm : A\n⊢ Eq (Localization.mk ((algebraMap A R) m) 1) ((algebraMap A (Localization M)) m)","decl":"theorem mk_algebraMap {A : Type*} [CommSemiring A] [Algebra A R] (m : A) :\n    mk (algebraMap A R m) 1 = algebraMap A (Localization M) m := by\n  rw [mk_eq_mk', mk'_eq_iff_eq_mul, Submonoid.coe_one, map_one, mul_one]; rfl\n\n"}
{"name":"Localization.neg_mk","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nM : Submonoid R\na : R\nb : Subtype fun x => Membership.mem M x\n⊢ Eq (Neg.neg (Localization.mk a b)) (Localization.mk (Neg.neg a) b)","decl":"theorem neg_mk (a b) : -(mk a b : Localization M) = mk (-a) b := OreLocalization.neg_def _ _\n\n"}
{"name":"Localization.sub_mk","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝ : CommRing R\nM : Submonoid R\na c : R\nb d : Subtype fun x => Membership.mem M x\n⊢ Eq (HSub.hSub (Localization.mk a b) (Localization.mk c d)) (Localization.mk (HSub.hSub (HMul.hMul (↑d) a) (HMul.hMul (↑b) c)) (HMul.hMul b d))","decl":"theorem sub_mk (a c) (b d) : (mk a b : Localization M) - mk c d =\n    mk ((d : R) * a - b * c) (b * d) := by\n  rw [sub_eq_add_neg, neg_mk, add_mk, add_comm, mul_neg, ← sub_eq_add_neg]\n\n"}
{"name":"IsLocalization.injective_of_map_algebraMap_zero","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\nT : Type u_5\ninst✝ : CommRing T\nf : RingHom S T\nh : ∀ (x : R), Eq (f ((algebraMap R S) x)) 0 → Eq ((algebraMap R S) x) 0\n⊢ Function.Injective ⇑f","decl":"include M in\nlemma injective_of_map_algebraMap_zero {T} [CommRing T] (f : S →+* T)\n    (h : ∀ x, f (algebraMap R S x) = 0 → algebraMap R S x = 0) :\n    Function.Injective f := by\n  rw [IsLocalization.injective_iff_map_algebraMap_eq M]\n  refine fun x y ↦ ⟨fun hz ↦ hz ▸ rfl, fun hz ↦ ?_⟩\n  rw [← sub_eq_zero, ← map_sub, ← map_sub] at hz\n  apply h at hz\n  rwa [map_sub, sub_eq_zero] at hz\n\n"}
{"name":"IsLocalization.to_map_eq_zero_iff","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nx : R\nhM : LE.le M (nonZeroDivisors R)\n⊢ Iff (Eq ((algebraMap R S) x) 0) (Eq x 0)","decl":"theorem to_map_eq_zero_iff {x : R} (hM : M ≤ nonZeroDivisors R) : algebraMap R S x = 0 ↔ x = 0 := by\n  rw [← (algebraMap R S).map_zero]\n  constructor <;> intro h\n  · cases' (eq_iff_exists M S).mp h with c hc\n    rw [mul_zero, mul_comm] at hc\n    exact hM c.2 x hc\n  · rw [h]\n\n"}
{"name":"IsLocalization.injective","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\nhM : LE.le M (nonZeroDivisors R)\n⊢ Function.Injective ⇑(algebraMap R S)","decl":"protected theorem injective (hM : M ≤ nonZeroDivisors R) : Injective (algebraMap R S) := by\n  rw [injective_iff_map_eq_zero (algebraMap R S)]\n  intro a ha\n  rwa [to_map_eq_zero_iff S hM] at ha\n\n"}
{"name":"IsLocalization.to_map_ne_zero_of_mem_nonZeroDivisors","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\ninst✝ : Nontrivial R\nhM : LE.le M (nonZeroDivisors R)\nx : R\nhx : Membership.mem (nonZeroDivisors R) x\n⊢ Ne ((algebraMap R S) x) 0","decl":"protected theorem to_map_ne_zero_of_mem_nonZeroDivisors [Nontrivial R] (hM : M ≤ nonZeroDivisors R)\n    {x : R} (hx : x ∈ nonZeroDivisors R) : algebraMap R S x ≠ 0 :=\n  show (algebraMap R S).toMonoidWithZeroHom x ≠ 0 from\n    map_ne_zero_of_mem_nonZeroDivisors (algebraMap R S) (IsLocalization.injective S hM) hx\n\n"}
{"name":"IsLocalization.sec_snd_ne_zero","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁴ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝³ : CommRing S\ninst✝² : Algebra R S\ninst✝¹ : IsLocalization M S\ninst✝ : Nontrivial R\nhM : LE.le M (nonZeroDivisors R)\nx : S\n⊢ Ne (↑(IsLocalization.sec M x).2) 0","decl":"theorem sec_snd_ne_zero [Nontrivial R] (hM : M ≤ nonZeroDivisors R) (x : S) :\n    ((sec M x).snd : R) ≠ 0 :=\n  nonZeroDivisors.coe_ne_zero ⟨(sec M x).snd.val, hM (sec M x).snd.property⟩\n\n"}
{"name":"IsLocalization.sec_fst_ne_zero","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"R : Type u_1\ninst✝⁵ : CommRing R\nM : Submonoid R\nS : Type u_2\ninst✝⁴ : CommRing S\ninst✝³ : Algebra R S\ninst✝² : IsLocalization M S\ninst✝¹ : Nontrivial R\ninst✝ : NoZeroDivisors S\nhM : LE.le M (nonZeroDivisors R)\nx : S\nhx : Ne x 0\n⊢ Ne (IsLocalization.sec M x).1 0","decl":"theorem sec_fst_ne_zero [Nontrivial R] [NoZeroDivisors S] (hM : M ≤ nonZeroDivisors R) {x : S}\n    (hx : x ≠ 0) : (sec M x).fst ≠ 0 := by\n  have hsec := sec_spec M x\n  intro hfst\n  rw [hfst, map_zero, mul_eq_zero, _root_.map_eq_zero_iff] at hsec\n  · exact Or.elim hsec hx (sec_snd_ne_zero hM x)\n  · exact IsLocalization.injective S hM\n\n"}
{"name":"IsLocalization.noZeroDivisors_of_le_nonZeroDivisors","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"S : Type u_2\ninst✝⁴ : CommRing S\nA : Type u_6\ninst✝³ : CommRing A\ninst✝² : IsDomain A\ninst✝¹ : Algebra A S\nM : Submonoid A\ninst✝ : IsLocalization M S\nhM : LE.le M (nonZeroDivisors A)\n⊢ NoZeroDivisors S","decl":"/-- A `CommRing` `S` which is the localization of a ring `R` without zero divisors at a subset of\nnon-zero elements does not have zero divisors. -/\ntheorem noZeroDivisors_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M ≤ nonZeroDivisors A) : NoZeroDivisors S :=\n  { eq_zero_or_eq_zero_of_mul_eq_zero := by\n      intro z w h\n      cases' surj M z with x hx\n      cases' surj M w with y hy\n      have :\n        z * w * algebraMap A S y.2 * algebraMap A S x.2 = algebraMap A S x.1 * algebraMap A S y.1 :=\n        by rw [mul_assoc z, hy, ← hx]; ring\n      rw [h, zero_mul, zero_mul, ← (algebraMap A S).map_mul] at this\n      cases' eq_zero_or_eq_zero_of_mul_eq_zero ((to_map_eq_zero_iff S hM).mp this.symm) with H H\n      · exact Or.inl (eq_zero_of_fst_eq_zero hx H)\n      · exact Or.inr (eq_zero_of_fst_eq_zero hy H) }\n\n"}
{"name":"IsLocalization.isDomain_of_le_nonZeroDivisors","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"S : Type u_2\ninst✝⁴ : CommRing S\nA : Type u_6\ninst✝³ : CommRing A\ninst✝² : IsDomain A\ninst✝¹ : Algebra A S\nM : Submonoid A\ninst✝ : IsLocalization M S\nhM : LE.le M (nonZeroDivisors A)\n⊢ IsDomain S","decl":"/-- A `CommRing` `S` which is the localization of an integral domain `R` at a subset of\nnon-zero elements is an integral domain. -/\ntheorem isDomain_of_le_nonZeroDivisors [Algebra A S] {M : Submonoid A} [IsLocalization M S]\n    (hM : M ≤ nonZeroDivisors A) : IsDomain S := by\n  apply @NoZeroDivisors.to_isDomain _ _ (id _) (id _)\n  · exact\n      ⟨⟨(algebraMap A S) 0, (algebraMap A S) 1, fun h =>\n          zero_ne_one (IsLocalization.injective S hM h)⟩⟩\n  · exact noZeroDivisors_of_le_nonZeroDivisors _ hM\n\n"}
{"name":"IsLocalization.isDomain_localization","module":"Mathlib.RingTheory.Localization.Defs","initialProofState":"A : Type u_6\ninst✝¹ : CommRing A\ninst✝ : IsDomain A\nM : Submonoid A\nhM : LE.le M (nonZeroDivisors A)\n⊢ IsDomain (Localization M)","decl":"/-- The localization of an integral domain to a set of non-zero elements is an integral domain. -/\ntheorem isDomain_localization {M : Submonoid A} (hM : M ≤ nonZeroDivisors A) :\n    IsDomain (Localization M) :=\n  isDomain_of_le_nonZeroDivisors _ hM\n\n"}
