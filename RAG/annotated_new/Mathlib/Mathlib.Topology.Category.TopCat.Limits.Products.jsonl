{"name":"TopCat.piFan_pt","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\n⊢ Eq (TopCat.piFan α).pt (TopCat.of ((i : ι) → ↑(α i)))","decl":"/-- The explicit fan of a family of topological spaces given by the pi type. -/\n@[simps! pt π_app]\ndef piFan {ι : Type v} (α : ι → TopCat.{max v u}) : Fan α :=\n  Fan.mk (TopCat.of (∀ i, α i)) (piπ.{v,u} α)\n\n"}
{"name":"TopCat.piFan_π_app","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\nX : CategoryTheory.Discrete ι\n⊢ Eq ((TopCat.piFan α).π.app X) (TopCat.piπ α X.as)","decl":"/-- The explicit fan of a family of topological spaces given by the pi type. -/\n@[simps! pt π_app]\ndef piFan {ι : Type v} (α : ι → TopCat.{max v u}) : Fan α :=\n  Fan.mk (TopCat.of (∀ i, α i)) (piπ.{v,u} α)\n\n"}
{"name":"TopCat.piIsoPi_inv_π","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.piIsoPi α).inv (CategoryTheory.Limits.Pi.π α i)) (TopCat.piπ α i)","decl":"@[reassoc (attr := simp)]\ntheorem piIsoPi_inv_π {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :\n    (piIsoPi α).inv ≫ Pi.π α i = piπ α i := by simp [piIsoPi]\n\n"}
{"name":"TopCat.piIsoPi_inv_π_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\nZ : TopCat\nh : Quiver.Hom (α i) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (TopCat.piIsoPi α).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Pi.π α i) h)) (CategoryTheory.CategoryStruct.comp (TopCat.piπ α i) h)","decl":"@[reassoc (attr := simp)]\ntheorem piIsoPi_inv_π {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :\n    (piIsoPi α).inv ≫ Pi.π α i = piπ α i := by simp [piIsoPi]\n\n"}
{"name":"TopCat.piIsoPi_inv_π_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\nx : (i : ι) → ↑(α i)\n⊢ Eq ((CategoryTheory.Limits.Pi.π α i) ((TopCat.piIsoPi α).inv x)) (x i)","decl":"theorem piIsoPi_inv_π_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : ∀ i, α i) :\n    (Pi.π α i :) ((piIsoPi α).inv x) = x i :=\n  ConcreteCategory.congr_hom (piIsoPi_inv_π α i) x\n\n-- Porting note: needing the type ascription on `∏ᶜ α : TopCat.{max v u}` is unfortunate.\n"}
{"name":"TopCat.piIsoPi_hom_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\nx : ↑(CategoryTheory.Limits.piObj α)\n⊢ Eq ((TopCat.piIsoPi α).hom x i) ((CategoryTheory.Limits.Pi.π α i) x)","decl":"theorem piIsoPi_hom_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι)\n    (x : (∏ᶜ α : TopCat.{max v u})) : (piIsoPi α).hom x i = (Pi.π α i :) x := by\n  have := piIsoPi_inv_π α i\n  rw [Iso.inv_comp_eq] at this\n  exact ConcreteCategory.congr_hom this x\n\n-- Porting note: Lean doesn't automatically reduce TopCat.of X|>.α to X now\n"}
{"name":"TopCat.sigmaCofan_ι_app","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\nX : CategoryTheory.Discrete ι\n⊢ Eq ((TopCat.sigmaCofan α).ι.app X) (TopCat.sigmaι α X.as)","decl":"/-- The explicit cofan of a family of topological spaces given by the sigma type. -/\n@[simps! pt ι_app]\ndef sigmaCofan {ι : Type v} (α : ι → TopCat.{max v u}) : Cofan α :=\n  Cofan.mk (TopCat.of (Σi, α i)) (sigmaι α)\n\n"}
{"name":"TopCat.sigmaCofan_pt","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\n⊢ Eq (TopCat.sigmaCofan α).pt (TopCat.of (Sigma fun i => ↑(α i)))","decl":"/-- The explicit cofan of a family of topological spaces given by the sigma type. -/\n@[simps! pt ι_app]\ndef sigmaCofan {ι : Type v} (α : ι → TopCat.{max v u}) : Cofan α :=\n  Cofan.mk (TopCat.of (Σi, α i)) (sigmaι α)\n\n"}
{"name":"TopCat.sigmaIsoSigma_hom_ι","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι α i) (TopCat.sigmaIsoSigma α).hom) (TopCat.sigmaι α i)","decl":"@[reassoc (attr := simp)]\ntheorem sigmaIsoSigma_hom_ι {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :\n    Sigma.ι α i ≫ (sigmaIsoSigma α).hom = sigmaι α i := by simp [sigmaIsoSigma]\n\n"}
{"name":"TopCat.sigmaIsoSigma_hom_ι_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\nZ : TopCat\nh : Quiver.Hom (TopCat.of (Sigma fun i => ↑(α i))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.Sigma.ι α i) (CategoryTheory.CategoryStruct.comp (TopCat.sigmaIsoSigma α).hom h)) (CategoryTheory.CategoryStruct.comp (TopCat.sigmaι α i) h)","decl":"@[reassoc (attr := simp)]\ntheorem sigmaIsoSigma_hom_ι {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) :\n    Sigma.ι α i ≫ (sigmaIsoSigma α).hom = sigmaι α i := by simp [sigmaIsoSigma]\n\n"}
{"name":"TopCat.sigmaIsoSigma_hom_ι_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\nx : ↑(α i)\n⊢ Eq ((TopCat.sigmaIsoSigma α).hom ((CategoryTheory.Limits.Sigma.ι α i) x)) ⟨i, x⟩","decl":"theorem sigmaIsoSigma_hom_ι_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : α i) :\n    (sigmaIsoSigma α).hom ((Sigma.ι α i :) x) = Sigma.mk i x :=\n  ConcreteCategory.congr_hom (sigmaIsoSigma_hom_ι α i) x\n\n"}
{"name":"TopCat.sigmaIsoSigma_inv_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"ι : Type v\nα : ι → TopCat\ni : ι\nx : ↑(α i)\n⊢ Eq ((TopCat.sigmaIsoSigma α).inv ⟨i, x⟩) ((CategoryTheory.Limits.Sigma.ι α i) x)","decl":"theorem sigmaIsoSigma_inv_apply {ι : Type v} (α : ι → TopCat.{max v u}) (i : ι) (x : α i) :\n    (sigmaIsoSigma α).inv ⟨i, x⟩ = (Sigma.ι α i :) x := by\n  rw [← sigmaIsoSigma_hom_ι_apply, ← comp_app, ← comp_app, Iso.hom_inv_id,\n    Category.comp_id]\n\n-- Porting note: cannot use .topologicalSpace in place .str\n"}
{"name":"TopCat.induced_of_isLimit","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\nC : CategoryTheory.Limits.Cone F\nhC : CategoryTheory.Limits.IsLimit C\n⊢ Eq C.pt.str (iInf fun j => TopologicalSpace.induced (⇑(C.π.app j)) (F.obj j).str)","decl":"theorem induced_of_isLimit {F : J ⥤ TopCat.{max v u}} (C : Cone F) (hC : IsLimit C) :\n    C.pt.str = ⨅ j, (F.obj j).str.induced (C.π.app j) := by\n  let homeo := homeoOfIso (hC.conePointUniqueUpToIso (limitConeInfiIsLimit F))\n  refine homeo.isInducing.eq_induced.trans ?_\n  change induced homeo (⨅ j : J, _) = _\n  simp [induced_iInf, induced_compose]\n  rfl\n\n"}
{"name":"TopCat.limit_topology","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"J : Type v\ninst✝ : CategoryTheory.Category.{w, v} J\nF : CategoryTheory.Functor J TopCat\n⊢ Eq (CategoryTheory.Limits.limit F).str (iInf fun j => TopologicalSpace.induced (⇑(CategoryTheory.Limits.limit.π F j)) (F.obj j).str)","decl":"theorem limit_topology (F : J ⥤ TopCat.{max v u}) :\n    (limit F).str = ⨅ j, (F.obj j).str.induced (limit.π F j) :=\n  induced_of_isLimit _ (limit.isLimit F)\n\n"}
{"name":"TopCat.prodIsoProd_hom_fst_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y Z : TopCat\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).hom (CategoryTheory.CategoryStruct.comp TopCat.prodFst h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)","decl":"@[reassoc (attr := simp)]\ntheorem prodIsoProd_hom_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).hom ≫ prodFst = Limits.prod.fst := by\n  simp [← Iso.eq_inv_comp, prodIsoProd]\n  rfl\n\n"}
{"name":"TopCat.prodIsoProd_hom_fst","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).hom TopCat.prodFst) CategoryTheory.Limits.prod.fst","decl":"@[reassoc (attr := simp)]\ntheorem prodIsoProd_hom_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).hom ≫ prodFst = Limits.prod.fst := by\n  simp [← Iso.eq_inv_comp, prodIsoProd]\n  rfl\n\n"}
{"name":"TopCat.prodIsoProd_hom_snd","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).hom TopCat.prodSnd) CategoryTheory.Limits.prod.snd","decl":"@[reassoc (attr := simp)]\ntheorem prodIsoProd_hom_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).hom ≫ prodSnd = Limits.prod.snd := by\n  simp [← Iso.eq_inv_comp, prodIsoProd]\n  rfl\n\n-- Porting note: need to force Lean to coerce X × Y to a type\n"}
{"name":"TopCat.prodIsoProd_hom_snd_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y Z : TopCat\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).hom (CategoryTheory.CategoryStruct.comp TopCat.prodSnd h)) (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)","decl":"@[reassoc (attr := simp)]\ntheorem prodIsoProd_hom_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).hom ≫ prodSnd = Limits.prod.snd := by\n  simp [← Iso.eq_inv_comp, prodIsoProd]\n  rfl\n\n-- Porting note: need to force Lean to coerce X × Y to a type\n"}
{"name":"TopCat.prodIsoProd_hom_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\nx : ↑(CategoryTheory.Limits.prod X Y)\n⊢ Eq ((X.prodIsoProd Y).hom x) { fst := CategoryTheory.Limits.prod.fst x, snd := CategoryTheory.Limits.prod.snd x }","decl":"theorem prodIsoProd_hom_apply {X Y : TopCat.{u}} (x : ↑ (X ⨯ Y)) :\n    (prodIsoProd X Y).hom x = ((Limits.prod.fst : X ⨯ Y ⟶ _) x,\n    (Limits.prod.snd : X ⨯ Y ⟶ _) x) := by\n  -- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): `ext` didn't pick this up.\n  apply Prod.ext\n  · exact ConcreteCategory.congr_hom (prodIsoProd_hom_fst X Y) x\n  · exact ConcreteCategory.congr_hom (prodIsoProd_hom_snd X Y) x\n\n"}
{"name":"TopCat.prodIsoProd_inv_fst_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\nx : (CategoryTheory.forget TopCat).obj (TopCat.of (Prod ↑X ↑Y))\n⊢ Eq (CategoryTheory.Limits.prod.fst ((X.prodIsoProd Y).inv x)) (TopCat.prodFst x)","decl":"@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv ≫ Limits.prod.fst = prodFst := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"TopCat.prodIsoProd_inv_fst_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y Z : TopCat\nh : Quiver.Hom X Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.fst h)) (CategoryTheory.CategoryStruct.comp TopCat.prodFst h)","decl":"@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv ≫ Limits.prod.fst = prodFst := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"TopCat.prodIsoProd_inv_fst","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).inv CategoryTheory.Limits.prod.fst) TopCat.prodFst","decl":"@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_fst (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv ≫ Limits.prod.fst = prodFst := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"TopCat.prodIsoProd_inv_snd_assoc","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y Z : TopCat\nh : Quiver.Hom Y Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).inv (CategoryTheory.CategoryStruct.comp CategoryTheory.Limits.prod.snd h)) (CategoryTheory.CategoryStruct.comp TopCat.prodSnd h)","decl":"@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv ≫ Limits.prod.snd = prodSnd := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"TopCat.prodIsoProd_inv_snd_apply","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\nx : (CategoryTheory.forget TopCat).obj (TopCat.of (Prod ↑X ↑Y))\n⊢ Eq (CategoryTheory.Limits.prod.snd ((X.prodIsoProd Y).inv x)) (TopCat.prodSnd x)","decl":"@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv ≫ Limits.prod.snd = prodSnd := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"TopCat.prodIsoProd_inv_snd","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\n⊢ Eq (CategoryTheory.CategoryStruct.comp (X.prodIsoProd Y).inv CategoryTheory.Limits.prod.snd) TopCat.prodSnd","decl":"@[reassoc (attr := simp), elementwise]\ntheorem prodIsoProd_inv_snd (X Y : TopCat.{u}) :\n    (prodIsoProd X Y).inv ≫ Limits.prod.snd = prodSnd := by simp [Iso.inv_comp_eq]\n\n"}
{"name":"TopCat.prod_topology","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\n⊢ Eq (CategoryTheory.Limits.prod X Y).str (Min.min (TopologicalSpace.induced (⇑CategoryTheory.Limits.prod.fst) X.str) (TopologicalSpace.induced (⇑CategoryTheory.Limits.prod.snd) Y.str))","decl":"theorem prod_topology {X Y : TopCat.{u}} :\n    (X ⨯ Y).str =\n      induced (Limits.prod.fst : X ⨯ Y ⟶ _) X.str ⊓\n        induced (Limits.prod.snd : X ⨯ Y ⟶ _) Y.str := by\n  let homeo := homeoOfIso (prodIsoProd X Y)\n  refine homeo.isInducing.eq_induced.trans ?_\n  change induced homeo (_ ⊓ _) = _\n  simp [induced_compose]\n  rfl\n\n"}
{"name":"TopCat.range_prod_map","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"W X Y Z : TopCat\nf : Quiver.Hom W Y\ng : Quiver.Hom X Z\n⊢ Eq (Set.range ⇑(CategoryTheory.Limits.prod.map f g)) (Inter.inter (Set.preimage (⇑CategoryTheory.Limits.prod.fst) (Set.range ⇑f)) (Set.preimage (⇑CategoryTheory.Limits.prod.snd) (Set.range ⇑g)))","decl":"theorem range_prod_map {W X Y Z : TopCat.{u}} (f : W ⟶ Y) (g : X ⟶ Z) :\n    Set.range (Limits.prod.map f g) =\n      (Limits.prod.fst : Y ⨯ Z ⟶ _) ⁻¹' Set.range f ∩\n        (Limits.prod.snd : Y ⨯ Z ⟶ _) ⁻¹' Set.range g := by\n  ext x\n  constructor\n  · rintro ⟨y, rfl⟩\n    simp_rw [Set.mem_inter_iff, Set.mem_preimage, Set.mem_range]\n    -- sizable changes in this proof after https://github.com/leanprover-community/mathlib4/pull/13170\n    rw [← CategoryTheory.comp_apply, ← CategoryTheory.comp_apply]\n    simp_rw [Limits.prod.map_fst,\n      Limits.prod.map_snd, CategoryTheory.comp_apply]\n    exact ⟨exists_apply_eq_apply _ _, exists_apply_eq_apply _ _⟩\n  · rintro ⟨⟨x₁, hx₁⟩, ⟨x₂, hx₂⟩⟩\n    use (prodIsoProd W X).inv (x₁, x₂)\n    change (forget TopCat).map _ _ = _\n    apply Concrete.limit_ext\n    rintro ⟨⟨⟩⟩\n    · change limit.π (pair Y Z) _ ((prod.map f g) _) = _\n      erw [← CategoryTheory.comp_apply, Limits.prod.map_fst]\n      change (_ ≫ _ ≫ f) _ = _\n      rw [TopCat.prodIsoProd_inv_fst_assoc,TopCat.comp_app]\n      exact hx₁\n    · change limit.π (pair Y Z) _ ((prod.map f g) _) = _\n      erw [← CategoryTheory.comp_apply, Limits.prod.map_snd]\n      change (_ ≫ _ ≫ g) _ = _\n      rw [TopCat.prodIsoProd_inv_snd_assoc,TopCat.comp_app]\n      exact hx₂\n\n"}
{"name":"TopCat.isInducing_prodMap","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"W X Y Z : TopCat\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nhf : Topology.IsInducing ⇑f\nhg : Topology.IsInducing ⇑g\n⊢ Topology.IsInducing ⇑(CategoryTheory.Limits.prod.map f g)","decl":"theorem isInducing_prodMap {W X Y Z : TopCat.{u}} {f : W ⟶ X} {g : Y ⟶ Z} (hf : IsInducing f)\n    (hg : IsInducing g) : IsInducing (Limits.prod.map f g) := by\n  constructor\n  simp_rw [topologicalSpace_coe, prod_topology, induced_inf, induced_compose, ← coe_comp,\n    prod.map_fst, prod.map_snd, coe_comp, ← induced_compose (g := f), ← induced_compose (g := g)]\n  erw [← hf.eq_induced, ← hg.eq_induced] -- now `erw` after https://github.com/leanprover-community/mathlib4/pull/13170\n  rfl -- `rfl` was not needed before https://github.com/leanprover-community/mathlib4/pull/13170\n\n"}
{"name":"TopCat.inducing_prod_map","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"W X Y Z : TopCat\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nhf : Topology.IsInducing ⇑f\nhg : Topology.IsInducing ⇑g\n⊢ Topology.IsInducing ⇑(CategoryTheory.Limits.prod.map f g)","decl":"@[deprecated (since := \"2024-10-28\")] alias inducing_prod_map := isInducing_prodMap\n\n"}
{"name":"TopCat.isEmbedding_prodMap","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"W X Y Z : TopCat\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nhf : Topology.IsEmbedding ⇑f\nhg : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.prod.map f g)","decl":"theorem isEmbedding_prodMap {W X Y Z : TopCat.{u}} {f : W ⟶ X} {g : Y ⟶ Z} (hf : IsEmbedding f)\n    (hg : IsEmbedding g) : IsEmbedding (Limits.prod.map f g) :=\n  ⟨isInducing_prodMap hf.isInducing hg.isInducing, by\n    haveI := (TopCat.mono_iff_injective _).mpr hf.injective\n    haveI := (TopCat.mono_iff_injective _).mpr hg.injective\n    exact (TopCat.mono_iff_injective _).mp inferInstance⟩\n\n"}
{"name":"TopCat.embedding_prod_map","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"W X Y Z : TopCat\nf : Quiver.Hom W X\ng : Quiver.Hom Y Z\nhf : Topology.IsEmbedding ⇑f\nhg : Topology.IsEmbedding ⇑g\n⊢ Topology.IsEmbedding ⇑(CategoryTheory.Limits.prod.map f g)","decl":"@[deprecated (since := \"2024-10-26\")]\nalias embedding_prod_map := isEmbedding_prodMap\n\n"}
{"name":"TopCat.binaryCofan_isColimit_iff","module":"Mathlib.Topology.Category.TopCat.Limits.Products","initialProofState":"X Y : TopCat\nc : CategoryTheory.Limits.BinaryCofan X Y\n⊢ Iff (Nonempty (CategoryTheory.Limits.IsColimit c)) (And (Topology.IsOpenEmbedding ⇑c.inl) (And (Topology.IsOpenEmbedding ⇑c.inr) (IsCompl (Set.range ⇑c.inl) (Set.range ⇑c.inr))))","decl":"theorem binaryCofan_isColimit_iff {X Y : TopCat} (c : BinaryCofan X Y) :\n    Nonempty (IsColimit c) ↔\n      IsOpenEmbedding c.inl ∧ IsOpenEmbedding c.inr ∧ IsCompl (range c.inl) (range c.inr) := by\n  classical\n    constructor\n    · rintro ⟨h⟩\n      rw [← show _ = c.inl from\n          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ⟨WalkingPair.left⟩,\n        ← show _ = c.inr from\n          h.comp_coconePointUniqueUpToIso_inv (binaryCofanIsColimit X Y) ⟨WalkingPair.right⟩]\n      dsimp\n      refine ⟨(homeoOfIso <| h.coconePointUniqueUpToIso\n        (binaryCofanIsColimit X Y)).symm.isOpenEmbedding.comp .inl,\n          (homeoOfIso <| h.coconePointUniqueUpToIso\n            (binaryCofanIsColimit X Y)).symm.isOpenEmbedding.comp .inr, ?_⟩\n      erw [Set.range_comp, ← eq_compl_iff_isCompl, Set.range_comp _ Sum.inr,\n        ← Set.image_compl_eq (homeoOfIso <| h.coconePointUniqueUpToIso\n            (binaryCofanIsColimit X Y)).symm.bijective, Set.compl_range_inr, Set.image_comp]\n    · rintro ⟨h₁, h₂, h₃⟩\n      have : ∀ x, x ∈ Set.range c.inl ∨ x ∈ Set.range c.inr := by\n        rw [eq_compl_iff_isCompl.mpr h₃.symm]\n        exact fun _ => or_not\n      refine ⟨BinaryCofan.IsColimit.mk _ ?_ ?_ ?_ ?_⟩\n      · intro T f g\n        refine ContinuousMap.mk ?_ ?_\n        · exact fun x =>\n            if h : x ∈ Set.range c.inl then f ((Equiv.ofInjective _ h₁.injective).symm ⟨x, h⟩)\n            else g ((Equiv.ofInjective _ h₂.injective).symm ⟨x, (this x).resolve_left h⟩)\n        rw [continuous_iff_continuousAt]\n        intro x\n        by_cases h : x ∈ Set.range c.inl\n        · revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          · rw [continuousOn_iff_continuous_restrict]\n            convert_to Continuous (f ∘ (Homeomorph.ofIsEmbedding _ h₁.isEmbedding).symm)\n            · ext ⟨x, hx⟩\n              exact dif_pos hx\n            apply Continuous.comp\n            · exact f.continuous_toFun\n            · continuity\n          · exact h₁.isOpen_range\n        · revert h x\n          apply (IsOpen.continuousOn_iff _).mp\n          · rw [continuousOn_iff_continuous_restrict]\n            have : ∀ a, a ∉ Set.range c.inl → a ∈ Set.range c.inr := by\n              rintro a (h : a ∈ (Set.range c.inl)ᶜ)\n              rwa [eq_compl_iff_isCompl.mpr h₃.symm]\n            convert_to Continuous\n                (g ∘ (Homeomorph.ofIsEmbedding _ h₂.isEmbedding).symm ∘ Subtype.map _ this)\n            · ext ⟨x, hx⟩\n              exact dif_neg hx\n            apply Continuous.comp\n            · exact g.continuous_toFun\n            · apply Continuous.comp\n              · continuity\n              · rw [IsEmbedding.subtypeVal.isInducing.continuous_iff]\n                exact continuous_subtype_val\n          · change IsOpen (Set.range c.inl)ᶜ\n            rw [← eq_compl_iff_isCompl.mpr h₃.symm]\n            exact h₂.isOpen_range\n      · intro T f g\n        ext x\n        refine (dif_pos ?_).trans ?_\n        · exact ⟨x, rfl⟩\n        · dsimp\n          conv_lhs => rw [Equiv.ofInjective_symm_apply]\n      · intro T f g\n        ext x\n        refine (dif_neg ?_).trans ?_\n        · rintro ⟨y, e⟩\n          have : c.inr x ∈ Set.range c.inl ⊓ Set.range c.inr := ⟨⟨_, e⟩, ⟨_, rfl⟩⟩\n          rwa [disjoint_iff.mp h₃.1] at this\n        · exact congr_arg g (Equiv.ofInjective_symm_apply _ _)\n      · rintro T _ _ m rfl rfl\n        ext x\n        change m x = dite _ _ _\n        split_ifs <;> exact congr_arg _ (Equiv.apply_ofInjective_symm _ ⟨_, _⟩).symm\n\n"}
