{"name":"Positive.coe_add","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftStrictMono M\nx y : Subtype fun x => LT.lt 0 x\n⊢ Eq (↑(HAdd.hAdd x y)) (HAdd.hAdd ↑x ↑y)","decl":"@[simp, norm_cast]\ntheorem coe_add (x y : { x : M // 0 < x }) : ↑(x + y) = (x + y : M) :=\n  rfl\n\n"}
{"name":"Positive.addLeftStrictMono","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\ninst✝¹ : Preorder M\ninst✝ : AddLeftStrictMono M\n⊢ AddLeftStrictMono (Subtype fun x => LT.lt 0 x)","decl":"instance addLeftStrictMono : AddLeftStrictMono { x : M // 0 < x } :=\n  ⟨fun _ y z hyz => Subtype.coe_lt_coe.1 <| add_lt_add_left (show (y : M) < z from hyz) _⟩\n\n"}
{"name":"Positive.addRightStrictMono","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightStrictMono M\n⊢ AddRightStrictMono (Subtype fun x => LT.lt 0 x)","decl":"instance addRightStrictMono [AddRightStrictMono M] : AddRightStrictMono { x : M // 0 < x } :=\n  ⟨fun _ y z hyz => Subtype.coe_lt_coe.1 <| add_lt_add_right (show (y : M) < z from hyz) _⟩\n\n"}
{"name":"Positive.addLeftReflectLT","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddLeftReflectLT M\n⊢ AddLeftReflectLT (Subtype fun x => LT.lt 0 x)","decl":"instance addLeftReflectLT [AddLeftReflectLT M] : AddLeftReflectLT { x : M // 0 < x } :=\n  ⟨fun _ _ _ h => Subtype.coe_lt_coe.1 <| lt_of_add_lt_add_left h⟩\n\n"}
{"name":"Positive.addRightReflectLT","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightReflectLT M\n⊢ AddRightReflectLT (Subtype fun x => LT.lt 0 x)","decl":"instance addRightReflectLT [AddRightReflectLT M] : AddRightReflectLT { x : M // 0 < x } :=\n  ⟨fun _ _ _ h => Subtype.coe_lt_coe.1 <| lt_of_add_lt_add_right h⟩\n\n"}
{"name":"Positive.addLeftReflectLE","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddLeftReflectLE M\n⊢ AddLeftReflectLE (Subtype fun x => LT.lt 0 x)","decl":"instance addLeftReflectLE [AddLeftReflectLE M] : AddLeftReflectLE { x : M // 0 < x } :=\n  ⟨fun _ _ _ h => Subtype.coe_le_coe.1 <| le_of_add_le_add_left h⟩\n\n"}
{"name":"Positive.addRightReflectLE","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝³ : AddMonoid M\ninst✝² : Preorder M\ninst✝¹ : AddLeftStrictMono M\ninst✝ : AddRightReflectLE M\n⊢ AddRightReflectLE (Subtype fun x => LT.lt 0 x)","decl":"instance addRightReflectLE [AddRightReflectLE M] : AddRightReflectLE { x : M // 0 < x } :=\n  ⟨fun _ _ _ h => Subtype.coe_le_coe.1 <| le_of_add_le_add_right h⟩\n\n"}
{"name":"Positive.addLeftMono","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"M : Type u_1\ninst✝² : AddMonoid M\ninst✝¹ : PartialOrder M\ninst✝ : AddLeftStrictMono M\n⊢ AddLeftMono (Subtype fun x => LT.lt 0 x)","decl":"instance addLeftMono [AddMonoid M] [PartialOrder M] [AddLeftStrictMono M] :\n    AddLeftMono { x : M // 0 < x } :=\n  ⟨@fun _ _ _ h₁ => StrictMono.monotone (fun _ _ h => add_lt_add_left h _) h₁⟩\n\n"}
{"name":"Positive.val_mul","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"R : Type u_2\ninst✝ : StrictOrderedSemiring R\nx y : Subtype fun x => LT.lt 0 x\n⊢ Eq (↑(HMul.hMul x y)) (HMul.hMul ↑x ↑y)","decl":"@[simp]\ntheorem val_mul (x y : { x : R // 0 < x }) : ↑(x * y) = (x * y : R) :=\n  rfl\n\n"}
{"name":"Positive.val_pow","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"R : Type u_2\ninst✝ : StrictOrderedSemiring R\nx : Subtype fun x => LT.lt 0 x\nn : Nat\n⊢ Eq (↑(HPow.hPow x n)) (HPow.hPow (↑x) n)","decl":"@[simp]\ntheorem val_pow (x : { x : R // 0 < x }) (n : ℕ) :\n    ↑(x ^ n) = (x : R) ^ n :=\n  rfl\n\n"}
{"name":"Positive.val_one","module":"Mathlib.Algebra.Order.Positive.Ring","initialProofState":"R : Type u_2\ninst✝ : StrictOrderedSemiring R\n⊢ Eq (↑1) 1","decl":"@[simp]\ntheorem val_one : ((1 : { x : R // 0 < x }) : R) = 1 :=\n  rfl\n\n"}
