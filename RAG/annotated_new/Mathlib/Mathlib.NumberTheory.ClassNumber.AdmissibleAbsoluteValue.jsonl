{"name":"AbsoluteValue.IsAdmissible.exists_partition'","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝ : EuclideanDomain R\nabv : AbsoluteValue R Int\nself : abv.IsAdmissible\nn : Nat\nε : Real\nx✝¹ : LT.lt 0 ε\nb : R\nx✝ : Ne b 0\nA : Fin n → R\n⊢ Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)","decl":"/-- An absolute value `R → ℤ` is admissible if it respects the Euclidean domain\nstructure and a large enough set of elements in `R^n` will contain a pair of\nelements whose remainders are pointwise close together. -/\nstructure IsAdmissible extends IsEuclidean abv where\n  protected card : ℝ → ℕ\n  /-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\n  into `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\n  exists_partition' :\n    ∀ (n : ℕ) {ε : ℝ} (_ : 0 < ε) {b : R} (_ : b ≠ 0) (A : Fin n → R),\n      ∃ t : Fin n → Fin (card ε), ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : ℝ) < abv b • ε\n\n-- Porting note: no docstrings for IsAdmissible\n"}
{"name":"AbsoluteValue.IsAdmissible.toIsEuclidean","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝ : EuclideanDomain R\nabv : AbsoluteValue R Int\nself : abv.IsAdmissible\n⊢ abv.IsEuclidean","decl":"/-- An absolute value `R → ℤ` is admissible if it respects the Euclidean domain\nstructure and a large enough set of elements in `R^n` will contain a pair of\nelements whose remainders are pointwise close together. -/\nstructure IsAdmissible extends IsEuclidean abv where\n  protected card : ℝ → ℕ\n  /-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\n  into `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\n  exists_partition' :\n    ∀ (n : ℕ) {ε : ℝ} (_ : 0 < ε) {b : R} (_ : b ≠ 0) (A : Fin n → R),\n      ∃ t : Fin n → Fin (card ε), ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : ℝ) < abv b • ε\n\n-- Porting note: no docstrings for IsAdmissible\n"}
{"name":"AbsoluteValue.IsAdmissible.mk.inj","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝ : EuclideanDomain R\nabv : AbsoluteValue R Int\ntoIsEuclidean✝ : abv.IsEuclidean\ncard✝ : Real → Nat\nexists_partition'✝ : ∀ (n : Nat) {ε : Real}, LT.lt 0 ε → ∀ {b : R}, Ne b 0 → ∀ (A : Fin n → R), Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)\ntoIsEuclidean : abv.IsEuclidean\ncard : Real → Nat\nexists_partition' : ∀ (n : Nat) {ε : Real}, LT.lt 0 ε → ∀ {b : R}, Ne b 0 → ∀ (A : Fin n → R), Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)\nx✝ : Eq { toIsEuclidean := toIsEuclidean✝, card := card✝, exists_partition' := exists_partition'✝ } { toIsEuclidean := toIsEuclidean, card := card, exists_partition' := exists_partition' }\n⊢ Eq card✝ card","decl":"/-- An absolute value `R → ℤ` is admissible if it respects the Euclidean domain\nstructure and a large enough set of elements in `R^n` will contain a pair of\nelements whose remainders are pointwise close together. -/\nstructure IsAdmissible extends IsEuclidean abv where\n  protected card : ℝ → ℕ\n  /-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\n  into `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\n  exists_partition' :\n    ∀ (n : ℕ) {ε : ℝ} (_ : 0 < ε) {b : R} (_ : b ≠ 0) (A : Fin n → R),\n      ∃ t : Fin n → Fin (card ε), ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : ℝ) < abv b • ε\n\n-- Porting note: no docstrings for IsAdmissible\n"}
{"name":"AbsoluteValue.IsAdmissible.mk.sizeOf_spec","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝¹ : EuclideanDomain R\nabv : AbsoluteValue R Int\ninst✝ : SizeOf R\ntoIsEuclidean : abv.IsEuclidean\ncard : Real → Nat\nexists_partition' : ∀ (n : Nat) {ε : Real}, LT.lt 0 ε → ∀ {b : R}, Ne b 0 → ∀ (A : Fin n → R), Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)\n⊢ Eq (SizeOf.sizeOf { toIsEuclidean := toIsEuclidean, card := card, exists_partition' := exists_partition' }) (HAdd.hAdd 1 (SizeOf.sizeOf toIsEuclidean))","decl":"/-- An absolute value `R → ℤ` is admissible if it respects the Euclidean domain\nstructure and a large enough set of elements in `R^n` will contain a pair of\nelements whose remainders are pointwise close together. -/\nstructure IsAdmissible extends IsEuclidean abv where\n  protected card : ℝ → ℕ\n  /-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\n  into `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\n  exists_partition' :\n    ∀ (n : ℕ) {ε : ℝ} (_ : 0 < ε) {b : R} (_ : b ≠ 0) (A : Fin n → R),\n      ∃ t : Fin n → Fin (card ε), ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : ℝ) < abv b • ε\n\n-- Porting note: no docstrings for IsAdmissible\n"}
{"name":"AbsoluteValue.IsAdmissible.mk.injEq","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝ : EuclideanDomain R\nabv : AbsoluteValue R Int\ntoIsEuclidean✝ : abv.IsEuclidean\ncard✝ : Real → Nat\nexists_partition'✝ : ∀ (n : Nat) {ε : Real}, LT.lt 0 ε → ∀ {b : R}, Ne b 0 → ∀ (A : Fin n → R), Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)\ntoIsEuclidean : abv.IsEuclidean\ncard : Real → Nat\nexists_partition' : ∀ (n : Nat) {ε : Real}, LT.lt 0 ε → ∀ {b : R}, Ne b 0 → ∀ (A : Fin n → R), Exists fun t => ∀ (i₀ i₁ : Fin n), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)\n⊢ Eq (Eq { toIsEuclidean := toIsEuclidean✝, card := card✝, exists_partition' := exists_partition'✝ } { toIsEuclidean := toIsEuclidean, card := card, exists_partition' := exists_partition' }) (Eq card✝ card)","decl":"/-- An absolute value `R → ℤ` is admissible if it respects the Euclidean domain\nstructure and a large enough set of elements in `R^n` will contain a pair of\nelements whose remainders are pointwise close together. -/\nstructure IsAdmissible extends IsEuclidean abv where\n  protected card : ℝ → ℕ\n  /-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\n  into `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\n  exists_partition' :\n    ∀ (n : ℕ) {ε : ℝ} (_ : 0 < ε) {b : R} (_ : b ≠ 0) (A : Fin n → R),\n      ∃ t : Fin n → Fin (card ε), ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : ℝ) < abv b • ε\n\n-- Porting note: no docstrings for IsAdmissible\n"}
{"name":"AbsoluteValue.IsAdmissible.exists_partition","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝¹ : EuclideanDomain R\nabv : AbsoluteValue R Int\nι : Type u_2\ninst✝ : Finite ι\nε : Real\nhε : LT.lt 0 ε\nb : R\nhb : Ne b 0\nA : ι → R\nh : abv.IsAdmissible\n⊢ Exists fun t => ∀ (i₀ i₁ : ι), Eq (t i₀) (t i₁) → LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁) b) (HMod.hMod (A i₀) b)))) (HSMul.hSMul (abv b) ε)","decl":"/-- For all `ε > 0` and finite families `A`, we can partition the remainders of `A` mod `b`\ninto `abv.card ε` sets, such that all elements in each part of remainders are close together. -/\ntheorem exists_partition {ι : Type*} [Finite ι] {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0)\n    (A : ι → R) (h : abv.IsAdmissible) : ∃ t : ι → Fin (h.card ε),\n      ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ % b - A i₀ % b) : ℝ) < abv b • ε := by\n  rcases Finite.exists_equiv_fin ι with ⟨n, ⟨e⟩⟩\n  obtain ⟨t, ht⟩ := h.exists_partition' n hε hb (A ∘ e.symm)\n  refine ⟨t ∘ e, fun i₀ i₁ h ↦ ?_⟩\n  convert (config := {transparency := .default})\n    ht (e i₀) (e i₁) h <;> simp only [e.symm_apply_apply]\n\n"}
{"name":"AbsoluteValue.IsAdmissible.exists_approx_aux","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝ : EuclideanDomain R\nabv : AbsoluteValue R Int\nn : Nat\nh : abv.IsAdmissible\nε : Real\n_hε : LT.lt 0 ε\nb : R\n_hb : Ne b 0\nA : Fin (HPow.hPow (h.card ε) n).succ → Fin n → R\n⊢ Exists fun i₀ => Exists fun i₁ => And (Ne i₀ i₁) (∀ (k : Fin n), LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁ k) b) (HMod.hMod (A i₀ k) b)))) (HSMul.hSMul (abv b) ε))","decl":"/-- Any large enough family of vectors in `R^n` has a pair of elements\nwhose remainders are close together, pointwise. -/\ntheorem exists_approx_aux (n : ℕ) (h : abv.IsAdmissible) :\n    ∀ {ε : ℝ} (_hε : 0 < ε) {b : R} (_hb : b ≠ 0) (A : Fin (h.card ε ^ n).succ → Fin n → R),\n      ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε := by\n  haveI := Classical.decEq R\n  induction' n with n ih\n  · intro ε _hε b _hb A\n    refine ⟨0, 1, ?_, ?_⟩\n    · simp\n    rintro ⟨i, ⟨⟩⟩\n  intro ε hε b hb A\n  let M := h.card ε\n  -- By the \"nicer\" pigeonhole principle, we can find a collection `s`\n  -- of more than `M^n` remainders where the first components lie close together:\n  obtain ⟨s, s_inj, hs⟩ :\n    ∃ s : Fin (M ^ n).succ → Fin (M ^ n.succ).succ,\n      Function.Injective s ∧ ∀ i₀ i₁, (abv (A (s i₁) 0 % b - A (s i₀) 0 % b) : ℝ) < abv b • ε := by\n    -- We can partition the `A`s into `M` subsets where\n    -- the first components lie close together:\n    obtain ⟨t, ht⟩ :\n      ∃ t : Fin (M ^ n.succ).succ → Fin M,\n        ∀ i₀ i₁, t i₀ = t i₁ → (abv (A i₁ 0 % b - A i₀ 0 % b) : ℝ) < abv b • ε :=\n      h.exists_partition hε hb fun x ↦ A x 0\n    -- Since the `M` subsets contain more than `M * M^n` elements total,\n    -- there must be a subset that contains more than `M^n` elements.\n    obtain ⟨s, hs⟩ :=\n      Fintype.exists_lt_card_fiber_of_mul_lt_card (f := t)\n        (by simpa only [Fintype.card_fin, pow_succ'] using Nat.lt_succ_self (M ^ n.succ))\n    refine ⟨fun i ↦ (Finset.univ.filter fun x ↦ t x = s).toList.get <| i.castLE ?_, fun i j h ↦ ?_,\n      fun i₀ i₁ ↦ ht _ _ ?_⟩\n    · rwa [Finset.length_toList]\n    · ext\n      simpa [(Finset.nodup_toList _).getElem_inj_iff] using h\n    · #adaptation_note /-- https://github.com/leanprover/lean4/pull/4400\n      This proof was nicer before.\n      Please feel welcome to improve it, by avoiding use of `List.get` in favour of `GetElem`. -/\n      have : ∀ i h, t ((Finset.univ.filter fun x ↦ t x = s).toList.get ⟨i, h⟩) = s := fun i h ↦\n        (Finset.mem_filter.mp (Finset.mem_toList.mp (List.get_mem _ ⟨i, h⟩))).2\n      simp only [Nat.succ_eq_add_one, Finset.length_toList, List.get_eq_getElem] at this\n      simp only [Nat.succ_eq_add_one, List.get_eq_getElem, Fin.coe_castLE]\n      rw [this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₁.2) hs),\n        this _ (Nat.lt_of_le_of_lt (Nat.le_of_lt_succ i₀.2) hs)]\n  -- Since `s` is large enough, there are two elements of `A ∘ s`\n  -- where the second components lie close together.\n  obtain ⟨k₀, k₁, hk, h⟩ := ih hε hb fun x ↦ Fin.tail (A (s x))\n  refine ⟨s k₀, s k₁, fun h ↦ hk (s_inj h), fun i ↦ Fin.cases ?_ (fun i ↦ ?_) i⟩\n  · exact hs k₀ k₁\n  · exact h i\n\n"}
{"name":"AbsoluteValue.IsAdmissible.exists_approx","module":"Mathlib.NumberTheory.ClassNumber.AdmissibleAbsoluteValue","initialProofState":"R : Type u_1\ninst✝¹ : EuclideanDomain R\nabv : AbsoluteValue R Int\nι : Type u_2\ninst✝ : Fintype ι\nε : Real\nhε : LT.lt 0 ε\nb : R\nhb : Ne b 0\nh : abv.IsAdmissible\nA : Fin (HPow.hPow (h.card ε) (Fintype.card ι)).succ → ι → R\n⊢ Exists fun i₀ => Exists fun i₁ => And (Ne i₀ i₁) (∀ (k : ι), LT.lt (↑(abv (HSub.hSub (HMod.hMod (A i₁ k) b) (HMod.hMod (A i₀ k) b)))) (HSMul.hSMul (abv b) ε))","decl":"/-- Any large enough family of vectors in `R^ι` has a pair of elements\nwhose remainders are close together, pointwise. -/\ntheorem exists_approx {ι : Type*} [Fintype ι] {ε : ℝ} (hε : 0 < ε) {b : R} (hb : b ≠ 0)\n    (h : abv.IsAdmissible) (A : Fin (h.card ε ^ Fintype.card ι).succ → ι → R) :\n    ∃ i₀ i₁, i₀ ≠ i₁ ∧ ∀ k, (abv (A i₁ k % b - A i₀ k % b) : ℝ) < abv b • ε := by\n  let e := Fintype.equivFin ι\n  obtain ⟨i₀, i₁, ne, h⟩ := h.exists_approx_aux (Fintype.card ι) hε hb fun x y ↦ A x (e.symm y)\n  refine ⟨i₀, i₁, ne, fun k ↦ ?_⟩\n  convert h (e k) <;> simp only [e.symm_apply_apply]\n\n"}
