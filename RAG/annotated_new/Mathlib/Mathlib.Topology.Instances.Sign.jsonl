{"name":"instDiscreteTopologySignType","module":"Mathlib.Topology.Instances.Sign","initialProofState":"⊢ DiscreteTopology SignType","decl":"instance : DiscreteTopology SignType :=\n  ⟨rfl⟩\n\n"}
{"name":"continuousAt_sign_of_pos","module":"Mathlib.Topology.Instances.Sign","initialProofState":"α : Type u_1\ninst✝⁴ : Zero α\ninst✝³ : TopologicalSpace α\ninst✝² : PartialOrder α\ninst✝¹ : DecidableRel fun x1 x2 => LT.lt x1 x2\ninst✝ : OrderTopology α\na : α\nh : LT.lt 0 a\n⊢ ContinuousAt (⇑SignType.sign) a","decl":"theorem continuousAt_sign_of_pos {a : α} (h : 0 < a) : ContinuousAt SignType.sign a := by\n  refine (continuousAt_const : ContinuousAt (fun _ => (1 : SignType)) a).congr ?_\n  rw [Filter.EventuallyEq, eventually_nhds_iff]\n  exact ⟨{ x | 0 < x }, fun x hx => (sign_pos hx).symm, isOpen_lt' 0, h⟩\n\n"}
{"name":"continuousAt_sign_of_neg","module":"Mathlib.Topology.Instances.Sign","initialProofState":"α : Type u_1\ninst✝⁴ : Zero α\ninst✝³ : TopologicalSpace α\ninst✝² : PartialOrder α\ninst✝¹ : DecidableRel fun x1 x2 => LT.lt x1 x2\ninst✝ : OrderTopology α\na : α\nh : LT.lt a 0\n⊢ ContinuousAt (⇑SignType.sign) a","decl":"theorem continuousAt_sign_of_neg {a : α} (h : a < 0) : ContinuousAt SignType.sign a := by\n  refine (continuousAt_const : ContinuousAt (fun x => (-1 : SignType)) a).congr ?_\n  rw [Filter.EventuallyEq, eventually_nhds_iff]\n  exact ⟨{ x | x < 0 }, fun x hx => (sign_neg hx).symm, isOpen_gt' 0, h⟩\n\n"}
{"name":"continuousAt_sign_of_ne_zero","module":"Mathlib.Topology.Instances.Sign","initialProofState":"α : Type u_1\ninst✝³ : Zero α\ninst✝² : TopologicalSpace α\ninst✝¹ : LinearOrder α\ninst✝ : OrderTopology α\na : α\nh : Ne a 0\n⊢ ContinuousAt (⇑SignType.sign) a","decl":"theorem continuousAt_sign_of_ne_zero {a : α} (h : a ≠ 0) : ContinuousAt SignType.sign a := by\n  rcases h.lt_or_lt with (h_neg | h_pos)\n  · exact continuousAt_sign_of_neg h_neg\n  · exact continuousAt_sign_of_pos h_pos\n\n"}
