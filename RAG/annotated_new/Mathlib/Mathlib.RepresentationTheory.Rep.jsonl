{"name":"Rep.coe_of","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝³ : CommRing k\ninst✝² : Monoid G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nρ : MonoidHom G (LinearMap (RingHom.id k) V V)\n⊢ Eq (CoeSort.coe (Rep.of ρ)) V","decl":"@[simp]\ntheorem coe_of {V : Type u} [AddCommGroup V] [Module k V] (ρ : G →* V →ₗ[k] V) :\n    (of ρ : Type u) = V :=\n  rfl\n\n"}
{"name":"Rep.of_ρ","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝³ : CommRing k\ninst✝² : Monoid G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nρ : MonoidHom G (LinearMap (RingHom.id k) V V)\n⊢ Eq (Rep.of ρ).ρ ρ","decl":"@[simp]\ntheorem of_ρ {V : Type u} [AddCommGroup V] [Module k V] (ρ : G →* V →ₗ[k] V) : (of ρ).ρ = ρ :=\n  rfl\n\n"}
{"name":"Rep.Action_ρ_eq_ρ","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\n⊢ Eq A.ρ (MonCat.ofHom (((Action.forget (ModuleCat k) (MonCat.of G)).obj A).endRingEquiv.symm.toMonoidHom.comp A.ρ))","decl":"theorem Action_ρ_eq_ρ {A : Rep k G} :\n    Action.ρ A = MonCat.ofHom ((ModuleCat.endRingEquiv _).symm.toMonoidHom.comp A.ρ) :=\n  rfl\n\n"}
{"name":"Rep.ρ_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Rep k G\ng : G\n⊢ Eq (ModuleCat.Hom.hom ((CategoryTheory.ConcreteCategory.hom X.ρ) g)) (X.ρ g)","decl":"@[simp]\nlemma ρ_hom {X : Rep k G} (g : G) : (Action.ρ X g).hom = X.ρ g := rfl\n\n"}
{"name":"Rep.ofHom_ρ","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Rep k G\ng : G\n⊢ Eq (ModuleCat.ofHom (X.ρ g)) ((CategoryTheory.ConcreteCategory.hom X.ρ) g)","decl":"@[simp]\nlemma ofHom_ρ {X : Rep k G} (g : G) : ModuleCat.ofHom (X.ρ g) = Action.ρ X g := rfl\n\n"}
{"name":"Rep.of_ρ_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝³ : CommRing k\ninst✝² : Monoid G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\nρ : Representation k G V\ng : ↑(MonCat.of G)\n⊢ Eq ((Rep.of ρ).ρ g) (ρ g)","decl":"/-- Allows us to apply lemmas about the underlying `ρ`, which would take an element `g : G` rather\nthan `g : MonCat.of G` as an argument. -/\ntheorem of_ρ_apply {V : Type u} [AddCommGroup V] [Module k V] (ρ : Representation k G V)\n    (g : MonCat.of G) : (Rep.of ρ).ρ g = ρ (g : G) :=\n  rfl\n\n"}
{"name":"Rep.ρ_inv_self_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k : Type u\ninst✝¹ : CommRing k\nG : Type u\ninst✝ : Group G\nA : Rep k G\ng : G\nx : CoeSort.coe A\n⊢ Eq ((A.ρ (Inv.inv g)) ((A.ρ g) x)) x","decl":"@[simp]\ntheorem ρ_inv_self_apply {G : Type u} [Group G] (A : Rep k G) (g : G) (x : A) :\n    A.ρ g⁻¹ (A.ρ g x) = x :=\n  show (A.ρ g⁻¹ * A.ρ g) x = x by rw [← map_mul, inv_mul_cancel, map_one, LinearMap.one_apply]\n\n"}
{"name":"Rep.ρ_self_inv_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k : Type u\ninst✝¹ : CommRing k\nG : Type u\ninst✝ : Group G\nA : Rep k G\ng : G\nx : CoeSort.coe A\n⊢ Eq ((A.ρ g) ((A.ρ (Inv.inv g)) x)) x","decl":"@[simp]\ntheorem ρ_self_inv_apply {G : Type u} [Group G] {A : Rep k G} (g : G) (x : A) :\n    A.ρ g (A.ρ g⁻¹ x) = x :=\n  show (A.ρ g * A.ρ g⁻¹) x = x by rw [← map_mul, mul_inv_cancel, map_one, LinearMap.one_apply]\n\n"}
{"name":"Rep.hom_comm_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA B : Rep k G\nf : Quiver.Hom A B\ng : G\nx : CoeSort.coe A\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom f.hom) ((A.ρ g) x)) ((B.ρ g) ((CategoryTheory.ConcreteCategory.hom f.hom) x))","decl":"theorem hom_comm_apply {A B : Rep k G} (f : A ⟶ B) (g : G) (x : A) :\n    f.hom (A.ρ g x) = B.ρ g (f.hom x) :=\n  LinearMap.ext_iff.1 (ModuleCat.hom_ext_iff.mp (f.comm g)) x\n\n"}
{"name":"Rep.trivial_def","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝³ : CommRing k\ninst✝² : Monoid G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\ng : G\nv : V\n⊢ Eq (((Rep.trivial k G V).ρ g) v) v","decl":"theorem trivial_def {V : Type u} [AddCommGroup V] [Module k V] (g : G) (v : V) :\n    (trivial k G V).ρ g v = v :=\n  rfl\n\n"}
{"name":"Rep.instIsTrivialTrivial","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝³ : CommRing k\ninst✝² : Monoid G\nV : Type u\ninst✝¹ : AddCommGroup V\ninst✝ : Module k V\n⊢ (Rep.trivial k G V).IsTrivial","decl":"instance {V : Type u} [AddCommGroup V] [Module k V] :\n    IsTrivial (Rep.trivial k G V) where\n\n"}
{"name":"Rep.instIsTrivialOfOfIsTrivial","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝⁴ : CommRing k\ninst✝³ : Monoid G\nV : Type u\ninst✝² : AddCommGroup V\ninst✝¹ : Module k V\nρ : Representation k G V\ninst✝ : ρ.IsTrivial\n⊢ (Rep.of ρ).IsTrivial","decl":"instance {V : Type u} [AddCommGroup V] [Module k V] (ρ : Representation k G V) [ρ.IsTrivial] :\n    IsTrivial (Rep.of ρ) where\n\n-- Porting note: the two following instances were found automatically in mathlib3\n"}
{"name":"Rep.instPreservesLimitsModuleCatForget₂","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ CategoryTheory.Limits.PreservesLimits (CategoryTheory.forget₂ (Rep k G) (ModuleCat k))","decl":"noncomputable instance : PreservesLimits (forget₂ (Rep k G) (ModuleCat.{u} k)) :=\n  Action.preservesLimits_forget.{u} _ _\n\n"}
{"name":"Rep.instPreservesColimitsModuleCatForget₂","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ CategoryTheory.Limits.PreservesColimits (CategoryTheory.forget₂ (Rep k G) (ModuleCat k))","decl":"noncomputable instance : PreservesColimits (forget₂ (Rep k G) (ModuleCat.{u} k)) :=\n  Action.preservesColimits_forget.{u} _ _\n\n/- Porting note: linter complains `simp` unfolds some types in the LHS, so\nhave removed `@[simp]`. -/\n"}
{"name":"Rep.MonoidalCategory.braiding_hom_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA B : Rep k G\nx : CoeSort.coe A\ny : CoeSort.coe B\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.BraidedCategory.braiding A B).hom.hom) (TensorProduct.tmul k x y)) (TensorProduct.tmul k y x)","decl":"theorem MonoidalCategory.braiding_hom_apply {A B : Rep k G} (x : A) (y : B) :\n    Action.Hom.hom (β_ A B).hom (TensorProduct.tmul k x y) = TensorProduct.tmul k y x :=\n  rfl\n\n/- Porting note: linter complains `simp` unfolds some types in the LHS, so\nhave removed `@[simp]`. -/\n"}
{"name":"Rep.MonoidalCategory.braiding_inv_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA B : Rep k G\nx : CoeSort.coe A\ny : CoeSort.coe B\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.BraidedCategory.braiding A B).inv.hom) (TensorProduct.tmul k y x)) (TensorProduct.tmul k x y)","decl":"theorem MonoidalCategory.braiding_inv_apply {A B : Rep k G} (x : A) (y : B) :\n    Action.Hom.hom (β_ A B).inv (TensorProduct.tmul k y x) = TensorProduct.tmul k x y :=\n  rfl\n\n"}
{"name":"Rep.linearization_obj_ρ","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Action (Type u) (MonCat.of G)\ng : G\nx : Finsupp X.V k\n⊢ Eq ((((Rep.linearization k G).obj X).ρ g) x) ((Finsupp.lmapDomain k k ((CategoryTheory.ConcreteCategory.hom X.ρ) g)) x)","decl":"@[simp]\ntheorem linearization_obj_ρ (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V →₀ k) :\n    ((linearization k G).obj X).ρ g x = Finsupp.lmapDomain k k (X.ρ g) x :=\n  rfl\n\n"}
{"name":"Rep.linearization_of","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Action (Type u) (MonCat.of G)\ng : G\nx : X.V\n⊢ Eq ((((Rep.linearization k G).obj X).ρ g) (Finsupp.single x 1)) (Finsupp.single ((CategoryTheory.ConcreteCategory.hom X.ρ) g x) 1)","decl":"theorem linearization_of (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V) :\n    ((linearization k G).obj X).ρ g (Finsupp.single x (1 : k))\n      = Finsupp.single (X.ρ g x) (1 : k) := by\n  rw [linearization_obj_ρ, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single]\n\n-- Porting note (https://github.com/leanprover-community/mathlib4/issues/11041): helps fixing `linearizationTrivialIso` since change in behaviour of `ext`.\n"}
{"name":"Rep.linearization_single","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Action (Type u) (MonCat.of G)\ng : G\nx : X.V\nr : k\n⊢ Eq ((((Rep.linearization k G).obj X).ρ g) (Finsupp.single x r)) (Finsupp.single ((CategoryTheory.ConcreteCategory.hom X.ρ) g x) r)","decl":"theorem linearization_single (X : Action (Type u) (MonCat.of G)) (g : G) (x : X.V) (r : k) :\n    ((linearization k G).obj X).ρ g (Finsupp.single x r) = Finsupp.single (X.ρ g x) r := by\n  rw [linearization_obj_ρ, Finsupp.lmapDomain_apply, Finsupp.mapDomain_single]\n\n"}
{"name":"Rep.linearization_map_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX Y : Action (Type u) (MonCat.of G)\nf : Quiver.Hom X Y\n⊢ Eq ((Rep.linearization k G).map f).hom (ModuleCat.ofHom (Finsupp.lmapDomain k k f.hom))","decl":"@[simp]\ntheorem linearization_map_hom : ((linearization k G).map f).hom =\n    ModuleCat.ofHom (Finsupp.lmapDomain k k f.hom) :=\n  rfl\n\n"}
{"name":"Rep.linearization_map_hom_single","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX Y : Action (Type u) (MonCat.of G)\nf : Quiver.Hom X Y\nx : X.V\nr : k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom ((Rep.linearization k G).map f).hom) (Finsupp.single x r)) (Finsupp.single (f.hom x) r)","decl":"theorem linearization_map_hom_single (x : X.V) (r : k) :\n    ((linearization k G).map f).hom (Finsupp.single x r) = Finsupp.single (f.hom x) r :=\n  Finsupp.mapDomain_single\n\n"}
{"name":"Rep.linearization_μ_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX Y : Action (Type u) (MonCat.of G)\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.μ (Rep.linearization k G) X Y).hom (ModuleCat.ofHom ↑(finsuppTensorFinsupp' k X.V Y.V))","decl":"@[simp]\ntheorem linearization_μ_hom (X Y : Action (Type u) (MonCat.of G)) :\n    (μ (linearization k G) X Y).hom =\n      ModuleCat.ofHom (finsuppTensorFinsupp' k X.V Y.V).toLinearMap :=\n  rfl\n\n"}
{"name":"Rep.linearization_δ_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX Y : Action (Type u) (MonCat.of G)\n⊢ Eq (CategoryTheory.Functor.OplaxMonoidal.δ (Rep.linearization k G) X Y).hom (ModuleCat.ofHom ↑(finsuppTensorFinsupp' k X.V Y.V).symm)","decl":"@[simp]\ntheorem linearization_δ_hom (X Y : Action (Type u) (MonCat.of G)) :\n    (δ (linearization k G) X Y).hom =\n      ModuleCat.ofHom (finsuppTensorFinsupp' k X.V Y.V).symm.toLinearMap :=\n  rfl\n\n"}
{"name":"Rep.linearization_ε_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\n⊢ Eq (CategoryTheory.Functor.LaxMonoidal.ε (Rep.linearization k G)).hom (ModuleCat.ofHom (Finsupp.lsingle PUnit.unit))","decl":"@[simp]\ntheorem linearization_ε_hom : (ε (linearization k G)).hom =\n    ModuleCat.ofHom (Finsupp.lsingle PUnit.unit) :=\n  rfl\n\n"}
{"name":"Rep.linearization_η_hom_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nr : k\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (CategoryTheory.Functor.OplaxMonoidal.η (Rep.linearization k G)).hom) (Finsupp.single PUnit.unit r)) r","decl":"theorem linearization_η_hom_apply (r : k) :\n    (η (linearization k G)).hom (Finsupp.single PUnit.unit r) = r :=\n  (εIso (linearization k G)).hom_inv_id_apply r\n\n"}
{"name":"Rep.linearizationTrivialIso_inv_hom_hom_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Type u\na : ↑((Rep.linearization k G).obj { V := X, ρ := 1 }).V\n⊢ Eq ((ModuleCat.Hom.hom (Rep.linearizationTrivialIso k G X).inv.hom) a) a","decl":"/-- The linearization of a type `X` on which `G` acts trivially is the trivial `G`-representation\non `k[X]`. -/\n@[simps!]\nnoncomputable def linearizationTrivialIso (X : Type u) :\n    (linearization k G).obj (Action.mk X 1) ≅ trivial k G (X →₀ k) :=\n  Action.mkIso (Iso.refl _) fun _ => ModuleCat.hom_ext <| Finsupp.lhom_ext' fun _ => LinearMap.ext\n    fun _ => linearization_single ..\n\n"}
{"name":"Rep.linearizationTrivialIso_hom_hom_hom_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nX : Type u\na : ↑((Rep.linearization k G).obj { V := X, ρ := 1 }).V\n⊢ Eq ((ModuleCat.Hom.hom (Rep.linearizationTrivialIso k G X).hom.hom) a) a","decl":"/-- The linearization of a type `X` on which `G` acts trivially is the trivial `G`-representation\non `k[X]`. -/\n@[simps!]\nnoncomputable def linearizationTrivialIso (X : Type u) :\n    (linearization k G).obj (Action.mk X 1) ≅ trivial k G (X →₀ k) :=\n  Action.mkIso (Iso.refl _) fun _ => ModuleCat.hom_ext <| Finsupp.lhom_ext' fun _ => LinearMap.ext\n    fun _ => linearization_single ..\n\n"}
{"name":"Rep.ofDistribMulAction_ρ_apply_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G A : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Monoid G\ninst✝³ : AddCommGroup A\ninst✝² : Module k A\ninst✝¹ : DistribMulAction G A\ninst✝ : SMulCommClass G k A\ng : G\na : A\n⊢ Eq (((Rep.ofDistribMulAction k G A).ρ g) a) (HSMul.hSMul g a)","decl":"@[simp] theorem ofDistribMulAction_ρ_apply_apply (g : G) (a : A) :\n    (ofDistribMulAction k G A).ρ g a = g • a := rfl\n\n"}
{"name":"Rep.ofMulDistribMulAction_ρ_apply_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"M G : Type\ninst✝² : Monoid M\ninst✝¹ : CommGroup G\ninst✝ : MulDistribMulAction M G\ng : M\na : Additive G\n⊢ Eq (((Rep.ofMulDistribMulAction M G).ρ g) a) (Additive.ofMul (HSMul.hSMul g (Additive.toMul a)))","decl":"@[simp] theorem ofMulDistribMulAction_ρ_apply_apply (g : M) (a : Additive G) :\n    (ofMulDistribMulAction M G).ρ g a = Additive.ofMul (g • a.toMul) := rfl\n\n"}
{"name":"Rep.leftRegularHom_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\nx : CoeSort.coe A\n⊢ Eq (A.leftRegularHom x).hom (ModuleCat.ofHom ((Finsupp.lift (↑A.1) k G) fun g => (A.ρ g) x))","decl":"/-- Given an element `x : A`, there is a natural morphism of representations `k[G] ⟶ A` sending\n`g ↦ A.ρ(g)(x).` -/\n@[simps]\nnoncomputable def leftRegularHom (A : Rep k G) (x : A) : Rep.ofMulAction k G G ⟶ A where\n  hom := ModuleCat.ofHom <| Finsupp.lift _ _ _ fun g => A.ρ g x\n  comm g := by\n    ext : 1\n    refine Finsupp.lhom_ext' fun y => LinearMap.ext_ring ?_\n/- Porting note: rest of broken proof was\n    simpa only [LinearMap.comp_apply, ModuleCat.comp_def, Finsupp.lsingle_apply, Finsupp.lift_apply,\n      Action_ρ_eq_ρ, of_ρ_apply, Representation.ofMulAction_single, Finsupp.sum_single_index,\n      zero_smul, one_smul, smul_eq_mul, A.ρ.map_mul] -/\n    simp only [LinearMap.comp_apply, ModuleCat.hom_comp, Finsupp.lsingle_apply]\n    erw [Finsupp.lift_apply, Finsupp.lift_apply, Representation.ofMulAction_single (G := G)]\n    simp only [Finsupp.sum_single_index, zero_smul, one_smul, smul_eq_mul, A.ρ.map_mul, of_ρ]\n    rfl\n\n"}
{"name":"Rep.leftRegularHom_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\nx : CoeSort.coe A\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (A.leftRegularHom x).hom) (Finsupp.single 1 1)) x","decl":"theorem leftRegularHom_apply {A : Rep k G} (x : A) :\n    (leftRegularHom A x).hom (Finsupp.single 1 1) = x := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [leftRegularHom_hom, Finsupp.lift_apply, Finsupp.sum_single_index, one_smul,\n    A.ρ.map_one, LinearMap.one_apply]\n  rw [zero_smul]\n\n"}
{"name":"Rep.leftRegularHomEquiv_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\nf : Quiver.Hom (Rep.ofMulAction k G G) A\n⊢ Eq (A.leftRegularHomEquiv f) ((CategoryTheory.ConcreteCategory.hom f.hom) (Finsupp.single 1 1))","decl":"/-- Given a `k`-linear `G`-representation `A`, there is a `k`-linear isomorphism between\nrepresentation morphisms `Hom(k[G], A)` and `A`. -/\n@[simps]\nnoncomputable def leftRegularHomEquiv (A : Rep k G) : (Rep.ofMulAction k G G ⟶ A) ≃ₗ[k] A where\n  toFun f := f.hom (Finsupp.single 1 1)\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun x := leftRegularHom A x\n  left_inv f := by\n    refine Action.Hom.ext (ModuleCat.hom_ext (Finsupp.lhom_ext' fun x : G => LinearMap.ext_ring ?_))\n    have :\n      f.hom ((ofMulAction k G G).ρ x (Finsupp.single (1 : G) (1 : k))) =\n        A.ρ x (f.hom (Finsupp.single (1 : G) (1 : k))) :=\n      LinearMap.ext_iff.1 (ModuleCat.hom_ext_iff.mp (f.comm x)) (Finsupp.single 1 1)\n    simp only [leftRegularHom_hom, LinearMap.comp_apply, Finsupp.lsingle_apply,\n      Finsupp.lift_apply, ← this, coe_of, of_ρ, Representation.ofMulAction_single x (1 : G) (1 : k),\n      smul_eq_mul, mul_one, zero_smul, Finsupp.sum_single_index, one_smul,\n      ConcreteCategory.hom_ofHom]\n    -- Mismatched `Zero k` instances\n    rfl\n  right_inv x := leftRegularHom_apply x\n\n"}
{"name":"Rep.leftRegularHomEquiv_symm_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\nx : CoeSort.coe A\n⊢ Eq (A.leftRegularHomEquiv.symm x) (A.leftRegularHom x)","decl":"/-- Given a `k`-linear `G`-representation `A`, there is a `k`-linear isomorphism between\nrepresentation morphisms `Hom(k[G], A)` and `A`. -/\n@[simps]\nnoncomputable def leftRegularHomEquiv (A : Rep k G) : (Rep.ofMulAction k G G ⟶ A) ≃ₗ[k] A where\n  toFun f := f.hom (Finsupp.single 1 1)\n  map_add' _ _ := rfl\n  map_smul' _ _ := rfl\n  invFun x := leftRegularHom A x\n  left_inv f := by\n    refine Action.Hom.ext (ModuleCat.hom_ext (Finsupp.lhom_ext' fun x : G => LinearMap.ext_ring ?_))\n    have :\n      f.hom ((ofMulAction k G G).ρ x (Finsupp.single (1 : G) (1 : k))) =\n        A.ρ x (f.hom (Finsupp.single (1 : G) (1 : k))) :=\n      LinearMap.ext_iff.1 (ModuleCat.hom_ext_iff.mp (f.comm x)) (Finsupp.single 1 1)\n    simp only [leftRegularHom_hom, LinearMap.comp_apply, Finsupp.lsingle_apply,\n      Finsupp.lift_apply, ← this, coe_of, of_ρ, Representation.ofMulAction_single x (1 : G) (1 : k),\n      smul_eq_mul, mul_one, zero_smul, Finsupp.sum_single_index, one_smul,\n      ConcreteCategory.hom_ofHom]\n    -- Mismatched `Zero k` instances\n    rfl\n  right_inv x := leftRegularHom_apply x\n\n"}
{"name":"Rep.leftRegularHomEquiv_symm_single","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nA : Rep k G\nx : CoeSort.coe A\ng : G\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (A.leftRegularHomEquiv.symm x).hom) (Finsupp.single g 1)) ((A.ρ g) x)","decl":"theorem leftRegularHomEquiv_symm_single {A : Rep k G} (x : A) (g : G) :\n    ((leftRegularHomEquiv A).symm x).hom (Finsupp.single g 1) = A.ρ g x := by\n  -- This used to be `rw`, but we need `erw` after https://github.com/leanprover/lean4/pull/2644\n  erw [leftRegularHomEquiv_symm_apply, leftRegularHom_hom, Finsupp.lift_apply,\n    Finsupp.sum_single_index, one_smul]\n  rw [zero_smul]\n\n"}
{"name":"Rep.ihom_map_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA X Y : Rep k G\nf : Quiver.Hom X Y\n⊢ Eq (A.ihom.map f).hom (ModuleCat.ofHom ((LinearMap.llcomp k (CoeSort.coe A) (CoeSort.coe X) (CoeSort.coe Y)) (ModuleCat.Hom.hom f.hom)))","decl":"/-- Given a `k`-linear `G`-representation `(A, ρ₁)`, this is the 'internal Hom' functor sending\n`(B, ρ₂)` to the representation `Homₖ(A, B)` that maps `g : G` and `f : A →ₗ[k] B` to\n`(ρ₂ g) ∘ₗ f ∘ₗ (ρ₁ g⁻¹)`. -/\n@[simps]\nprotected def ihom (A : Rep k G) : Rep k G ⥤ Rep k G where\n  obj B := Rep.of (Representation.linHom A.ρ B.ρ)\n  map := fun {X} {Y} f =>\n    { hom := ModuleCat.ofHom (LinearMap.llcomp k _ _ _ f.hom.hom)\n      comm := fun g => ModuleCat.hom_ext <| LinearMap.ext fun x => LinearMap.ext fun y => by\n        show f.hom (X.ρ g _) = _\n        simp only [hom_comm_apply]; rfl }\n  map_id := fun _ => by ext; rfl\n  map_comp := fun _ _ => by ext; rfl\n\n"}
{"name":"Rep.ihom_obj","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B : Rep k G\n⊢ Eq (A.ihom.obj B) (Rep.of (A.ρ.linHom B.ρ))","decl":"/-- Given a `k`-linear `G`-representation `(A, ρ₁)`, this is the 'internal Hom' functor sending\n`(B, ρ₂)` to the representation `Homₖ(A, B)` that maps `g : G` and `f : A →ₗ[k] B` to\n`(ρ₂ g) ∘ₗ f ∘ₗ (ρ₁ g⁻¹)`. -/\n@[simps]\nprotected def ihom (A : Rep k G) : Rep k G ⥤ Rep k G where\n  obj B := Rep.of (Representation.linHom A.ρ B.ρ)\n  map := fun {X} {Y} f =>\n    { hom := ModuleCat.ofHom (LinearMap.llcomp k _ _ _ f.hom.hom)\n      comm := fun g => ModuleCat.hom_ext <| LinearMap.ext fun x => LinearMap.ext fun y => by\n        show f.hom (X.ρ g _) = _\n        simp only [hom_comm_apply]; rfl }\n  map_id := fun _ => by ext; rfl\n  map_comp := fun _ _ => by ext; rfl\n\n"}
{"name":"Rep.ihom_obj_ρ_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B : Rep k G\ng : G\nx : LinearMap (RingHom.id k) (CoeSort.coe A) (CoeSort.coe B)\n⊢ Eq (((A.ihom.obj B).ρ g) x) ((B.ρ g).comp (x.comp (A.ρ (Inv.inv g))))","decl":"@[simp] theorem ihom_obj_ρ_apply {A B : Rep k G} (g : G) (x : A →ₗ[k] B) :\n    ((Rep.ihom A).obj B).ρ g x = B.ρ g ∘ₗ x ∘ₗ A.ρ g⁻¹ :=\n  rfl\n\n"}
{"name":"Rep.homEquiv_apply_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A B) C\n⊢ Eq ((A.homEquiv B C) f).hom (ModuleCat.ofHom (TensorProduct.curry (ModuleCat.Hom.hom f.hom)).flip)","decl":"/-- Porting note: if we generate this with `@[simps]` the linter complains some types in the LHS\nsimplify. -/\ntheorem homEquiv_apply_hom (f : A ⊗ B ⟶ C) :\n    (homEquiv A B C f).hom = ModuleCat.ofHom (TensorProduct.curry f.hom.hom).flip := rfl\n\n"}
{"name":"Rep.homEquiv_symm_apply_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\nf : Quiver.Hom B (A.ihom.obj C)\n⊢ Eq ((A.homEquiv B C).symm f).hom (ModuleCat.ofHom ((TensorProduct.uncurry k (CoeSort.coe A) (CoeSort.coe B) (CoeSort.coe C)) (ModuleCat.Hom.hom f.hom).flip))","decl":"/-- Porting note: if we generate this with `@[simps]` the linter complains some types in the LHS\nsimplify. -/\ntheorem homEquiv_symm_apply_hom (f : B ⟶ (Rep.ihom A).obj C) :\n    ((homEquiv A B C).symm f).hom =\n      ModuleCat.ofHom (TensorProduct.uncurry k A B C f.hom.hom.flip) := rfl\n\n"}
{"name":"Rep.ihom_obj_ρ_def","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B : Rep k G\n⊢ Eq ((CategoryTheory.ihom A).obj B).ρ (A.ihom.obj B).ρ","decl":"@[simp]\ntheorem ihom_obj_ρ_def (A B : Rep k G) : ((ihom A).obj B).ρ = ((Rep.ihom A).obj B).ρ :=\n  rfl\n\n"}
{"name":"Rep.homEquiv_def","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\n⊢ Eq ((CategoryTheory.ihom.adjunction A).homEquiv B C) (A.homEquiv B C)","decl":"@[simp]\ntheorem homEquiv_def (A B C : Rep k G) : (ihom.adjunction A).homEquiv B C = Rep.homEquiv A B C :=\n  congrFun (congrFun (Adjunction.mkOfHomEquiv_homEquiv _) _) _\n\n"}
{"name":"Rep.ihom_ev_app_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B : Rep k G\n⊢ Eq ((CategoryTheory.ihom.ev A).app B).hom (ModuleCat.ofHom ((TensorProduct.uncurry k (CoeSort.coe A) (LinearMap (RingHom.id k) (CoeSort.coe A) (CoeSort.coe B)) (CoeSort.coe B)) LinearMap.id.flip))","decl":"@[simp]\ntheorem ihom_ev_app_hom (A B : Rep k G) :\n    Action.Hom.hom ((ihom.ev A).app B) = ModuleCat.ofHom\n      (TensorProduct.uncurry k A (A →ₗ[k] B) B LinearMap.id.flip) := by\n  ext; rfl\n\n"}
{"name":"Rep.ihom_coev_app_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B : Rep k G\n⊢ Eq ((CategoryTheory.ihom.coev A).app B).hom (ModuleCat.ofHom (TensorProduct.mk k (CoeSort.coe A) ↑((CategoryTheory.Functor.id (Rep k G)).obj B).1).flip)","decl":"@[simp] theorem ihom_coev_app_hom (A B : Rep k G) :\n    Action.Hom.hom ((ihom.coev A).app B) = ModuleCat.ofHom (TensorProduct.mk k _ _).flip :=\n  ModuleCat.hom_ext <| LinearMap.ext fun _ => LinearMap.ext fun _ => rfl\n\n"}
{"name":"Rep.MonoidalClosed.linearHomEquiv_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A B) C\n⊢ Eq ((Rep.MonoidalClosed.linearHomEquiv A B C) f).hom (ModuleCat.ofHom (TensorProduct.curry (ModuleCat.Hom.hom f.hom)).flip)","decl":"@[simp, nolint simpNF]\ntheorem MonoidalClosed.linearHomEquiv_hom (f : A ⊗ B ⟶ C) :\n    (MonoidalClosed.linearHomEquiv A B C f).hom =\n      ModuleCat.ofHom (TensorProduct.curry f.hom.hom).flip :=\n  rfl\n\n-- `simpNF` times out\n"}
{"name":"Rep.MonoidalClosed.linearHomEquivComm_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\nf : Quiver.Hom (CategoryTheory.MonoidalCategoryStruct.tensorObj A B) C\n⊢ Eq ((Rep.MonoidalClosed.linearHomEquivComm A B C) f).hom (ModuleCat.ofHom (TensorProduct.curry (ModuleCat.Hom.hom f.hom)))","decl":"@[simp, nolint simpNF]\ntheorem MonoidalClosed.linearHomEquivComm_hom (f : A ⊗ B ⟶ C) :\n    (MonoidalClosed.linearHomEquivComm A B C f).hom =\n      ModuleCat.ofHom (TensorProduct.curry f.hom.hom) :=\n  rfl\n\n"}
{"name":"Rep.MonoidalClosed.linearHomEquiv_symm_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\nf : Quiver.Hom B ((CategoryTheory.ihom A).obj C)\n⊢ Eq ((Rep.MonoidalClosed.linearHomEquiv A B C).symm f).hom (ModuleCat.ofHom ((TensorProduct.uncurry k (CoeSort.coe A) (CoeSort.coe B) (CoeSort.coe C)) (ModuleCat.Hom.hom f.hom).flip))","decl":"theorem MonoidalClosed.linearHomEquiv_symm_hom (f : B ⟶ A ⟶[Rep k G] C) :\n    ((MonoidalClosed.linearHomEquiv A B C).symm f).hom =\n      ModuleCat.ofHom (TensorProduct.uncurry k A B C f.hom.hom.flip) := by\n  simp [linearHomEquiv]\n  rfl\n\n"}
{"name":"Rep.MonoidalClosed.linearHomEquivComm_symm_hom","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Group G\nA B C : Rep k G\nf : Quiver.Hom A ((CategoryTheory.ihom B).obj C)\n⊢ Eq ((Rep.MonoidalClosed.linearHomEquivComm A B C).symm f).hom (ModuleCat.ofHom ((TensorProduct.uncurry k (CoeSort.coe A) (CoeSort.coe B) (CoeSort.coe C)) (ModuleCat.Hom.hom f.hom)))","decl":"theorem MonoidalClosed.linearHomEquivComm_symm_hom (f : A ⟶ B ⟶[Rep k G] C) :\n    ((MonoidalClosed.linearHomEquivComm A B C).symm f).hom =\n      ModuleCat.ofHom (TensorProduct.uncurry k A B C f.hom.hom) :=\n  ModuleCat.hom_ext <| TensorProduct.ext' fun _ _ => rfl\n\n"}
{"name":"Representation.repOfTprodIso_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Monoid G\nV W : Type u\ninst✝³ : AddCommGroup V\ninst✝² : AddCommGroup W\ninst✝¹ : Module k V\ninst✝ : Module k W\nρ : Representation k G V\nτ : Representation k G W\nx : TensorProduct k V W\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ρ.repOfTprodIso τ).hom.hom) x) x","decl":"theorem repOfTprodIso_apply (x : TensorProduct k V W) : (repOfTprodIso ρ τ).hom.hom x = x :=\n  rfl\n\n"}
{"name":"Representation.repOfTprodIso_inv_apply","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝⁵ : CommRing k\ninst✝⁴ : Monoid G\nV W : Type u\ninst✝³ : AddCommGroup V\ninst✝² : AddCommGroup W\ninst✝¹ : Module k V\ninst✝ : Module k W\nρ : Representation k G V\nτ : Representation k G W\nx : TensorProduct k V W\n⊢ Eq ((CategoryTheory.ConcreteCategory.hom (ρ.repOfTprodIso τ).inv.hom) x) x","decl":"theorem repOfTprodIso_inv_apply (x : TensorProduct k V W) : (repOfTprodIso ρ τ).inv.hom x = x :=\n  rfl\n\n"}
{"name":"Rep.to_Module_monoidAlgebra_map_aux","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k : Type u_1\nG : Type u_2\ninst✝⁵ : CommRing k\ninst✝⁴ : Monoid G\nV : Type u_3\nW : Type u_4\ninst✝³ : AddCommGroup V\ninst✝² : AddCommGroup W\ninst✝¹ : Module k V\ninst✝ : Module k W\nρ : MonoidHom G (LinearMap (RingHom.id k) V V)\nσ : MonoidHom G (LinearMap (RingHom.id k) W W)\nf : LinearMap (RingHom.id k) V W\nw : ∀ (g : G), Eq (f.comp (ρ g)) ((σ g).comp f)\nr : MonoidAlgebra k G\nx : V\n⊢ Eq (f ((((MonoidAlgebra.lift k G (LinearMap (RingHom.id k) V V)) ρ) r) x)) ((((MonoidAlgebra.lift k G (LinearMap (RingHom.id k) W W)) σ) r) (f x))","decl":"/-- Auxiliary lemma for `toModuleMonoidAlgebra`. -/\ntheorem to_Module_monoidAlgebra_map_aux {k G : Type*} [CommRing k] [Monoid G] (V W : Type*)\n    [AddCommGroup V] [AddCommGroup W] [Module k V] [Module k W] (ρ : G →* V →ₗ[k] V)\n    (σ : G →* W →ₗ[k] W) (f : V →ₗ[k] W) (w : ∀ g : G, f.comp (ρ g) = (σ g).comp f)\n    (r : MonoidAlgebra k G) (x : V) :\n    f ((((MonoidAlgebra.lift k G (V →ₗ[k] V)) ρ) r) x) =\n      (((MonoidAlgebra.lift k G (W →ₗ[k] W)) σ) r) (f x) := by\n  apply MonoidAlgebra.induction_on r\n  · intro g\n    simp only [one_smul, MonoidAlgebra.lift_single, MonoidAlgebra.of_apply]\n    exact LinearMap.congr_fun (w g) x\n  · intro g h gw hw; simp only [map_add, add_left_inj, LinearMap.add_apply, hw, gw]\n  · intro r g w\n    simp only [map_smul, w, RingHom.id_apply, LinearMap.smul_apply, LinearMap.map_smulₛₗ]\n\n"}
{"name":"Rep.ofModuleMonoidAlgebra_obj_coe","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nM : ModuleCat (MonoidAlgebra k G)\n⊢ Eq (CoeSort.coe (Rep.ofModuleMonoidAlgebra.obj M)) (RestrictScalars k (MonoidAlgebra k G) ↑M)","decl":"theorem ofModuleMonoidAlgebra_obj_coe (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (ofModuleMonoidAlgebra.obj M : Type u) = RestrictScalars k (MonoidAlgebra k G) M :=\n  rfl\n\n"}
{"name":"Rep.ofModuleMonoidAlgebra_obj_ρ","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nM : ModuleCat (MonoidAlgebra k G)\n⊢ Eq (Rep.ofModuleMonoidAlgebra.obj M).ρ (Representation.ofModule ↑M)","decl":"theorem ofModuleMonoidAlgebra_obj_ρ (M : ModuleCat.{u} (MonoidAlgebra k G)) :\n    (ofModuleMonoidAlgebra.obj M).ρ = Representation.ofModule M :=\n  rfl\n\n"}
{"name":"Rep.unit_iso_comm","module":"Mathlib.RepresentationTheory.Rep","initialProofState":"k G : Type u\ninst✝¹ : CommRing k\ninst✝ : Monoid G\nV : Rep k G\ng : G\nx : CoeSort.coe V\n⊢ Eq (Rep.unitIsoAddEquiv ((V.ρ g).toFun x)) (((Rep.ofModuleMonoidAlgebra.obj (Rep.toModuleMonoidAlgebra.obj V)).ρ g).toFun (Rep.unitIsoAddEquiv x))","decl":"theorem unit_iso_comm (V : Rep k G) (g : G) (x : V) :\n    unitIsoAddEquiv ((V.ρ g).toFun x) = ((ofModuleMonoidAlgebra.obj\n      (toModuleMonoidAlgebra.obj V)).ρ g).toFun (unitIsoAddEquiv x) := by\n  dsimp [unitIsoAddEquiv, ofModuleMonoidAlgebra, toModuleMonoidAlgebra]\n  simp only [AddEquiv.apply_eq_iff_eq, AddEquiv.apply_symm_apply,\n    Representation.asModuleEquiv_symm_map_rho, Representation.ofModule_asModule_act]\n\n"}
