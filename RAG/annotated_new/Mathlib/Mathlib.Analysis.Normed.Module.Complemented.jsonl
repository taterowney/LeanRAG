{"name":"ContinuousLinearMap.ker_closedComplemented_of_finiteDimensional_range","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\ninstâœâ¶ : NontriviallyNormedField ğ•œ\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\ninstâœÂ¹ : CompleteSpace ğ•œ\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\ninstâœ : FiniteDimensional ğ•œ (Subtype fun x => Membership.mem (LinearMap.range f) x)\nâŠ¢ (LinearMap.ker f).ClosedComplemented","decl":"theorem ker_closedComplemented_of_finiteDimensional_range (f : E â†’L[ğ•œ] F)\n    [FiniteDimensional ğ•œ (range f)] : (ker f).ClosedComplemented := by\n  set f' : E â†’L[ğ•œ] range f := f.codRestrict _ (LinearMap.mem_range_self (f : E â†’â‚—[ğ•œ] F))\n  rcases f'.exists_right_inverse_of_surjective (f : E â†’â‚—[ğ•œ] F).range_rangeRestrict with âŸ¨g, hgâŸ©\n  simpa only [f', ker_codRestrict]\n    using f'.closedComplemented_ker_of_rightInverse g (ContinuousLinearMap.ext_iff.1 hg)\n\n"}
{"name":"ContinuousLinearMap.coe_equivProdOfSurjectiveOfIsCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace (Prod F G)\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\nâŠ¢ Eq â†‘â†‘(f.equivProdOfSurjectiveOfIsCompl g hf hg hfg) â†‘(f.prod g)","decl":"@[simp]\ntheorem coe_equivProdOfSurjectiveOfIsCompl {f : E â†’L[ğ•œ] F} {g : E â†’L[ğ•œ] G} (hf : range f = âŠ¤)\n    (hg : range g = âŠ¤) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg : E â†’â‚—[ğ•œ] F Ã— G) = f.prod g := rfl\n\n"}
{"name":"ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl_toLinearEquiv","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace (Prod F G)\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\nâŠ¢ Eq (f.equivProdOfSurjectiveOfIsCompl g hf hg hfg).toLinearEquiv ((â†‘f).equivProdOfSurjectiveOfIsCompl (â†‘g) hf hg hfg)","decl":"@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_toLinearEquiv {f : E â†’L[ğ•œ] F} {g : E â†’L[ğ•œ] G}\n    (hf : range f = âŠ¤) (hg : range g = âŠ¤) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg).toLinearEquiv =\n      LinearMap.equivProdOfSurjectiveOfIsCompl f g hf hg hfg := rfl\n\n"}
{"name":"ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl_apply","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninstâœâ¸ : NontriviallyNormedField ğ•œ\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\ninstâœÂ¹ : CompleteSpace E\ninstâœ : CompleteSpace (Prod F G)\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\ng : ContinuousLinearMap (RingHom.id ğ•œ) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\nx : E\nâŠ¢ Eq ((f.equivProdOfSurjectiveOfIsCompl g hf hg hfg) x) { fst := f x, snd := g x }","decl":"@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_apply {f : E â†’L[ğ•œ] F} {g : E â†’L[ğ•œ] G} (hf : range f = âŠ¤)\n    (hg : range g = âŠ¤) (hfg : IsCompl (ker f) (ker g)) (x : E) :\n    equivProdOfSurjectiveOfIsCompl f g hf hg hfg x = (f x, g x) := rfl\n\n"}
{"name":"Submodule.coe_prodEquivOfClosedCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np q : Subspace ğ•œ E\nh : IsCompl p q\nhp : IsClosed â†‘p\nhq : IsClosed â†‘q\nâŠ¢ Eq â‡‘(Submodule.prodEquivOfClosedCompl p q h hp hq) â‡‘(Submodule.prodEquivOfIsCompl p q h)","decl":"@[simp]\ntheorem coe_prodEquivOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    â‡‘(p.prodEquivOfClosedCompl q h hp hq) = p.prodEquivOfIsCompl q h := rfl\n\n"}
{"name":"Submodule.coe_prodEquivOfClosedCompl_symm","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np q : Subspace ğ•œ E\nh : IsCompl p q\nhp : IsClosed â†‘p\nhq : IsClosed â†‘q\nâŠ¢ Eq â‡‘(Submodule.prodEquivOfClosedCompl p q h hp hq).symm â‡‘(Submodule.prodEquivOfIsCompl p q h).symm","decl":"@[simp]\ntheorem coe_prodEquivOfClosedCompl_symm (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    â‡‘(p.prodEquivOfClosedCompl q h hp hq).symm = (p.prodEquivOfIsCompl q h).symm := rfl\n\n"}
{"name":"Submodule.coe_continuous_linearProjOfClosedCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np q : Subspace ğ•œ E\nh : IsCompl p q\nhp : IsClosed â†‘p\nhq : IsClosed â†‘q\nâŠ¢ Eq (â†‘(Submodule.linearProjOfClosedCompl p q h hp hq)) (Submodule.linearProjOfIsCompl p q h)","decl":"@[simp]\ntheorem coe_continuous_linearProjOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    (p.linearProjOfClosedCompl q h hp hq : E â†’â‚—[ğ•œ] p) = p.linearProjOfIsCompl q h := rfl\n\n"}
{"name":"Submodule.coe_continuous_linearProjOfClosedCompl'","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np q : Subspace ğ•œ E\nh : IsCompl p q\nhp : IsClosed â†‘p\nhq : IsClosed â†‘q\nâŠ¢ Eq â‡‘(Submodule.linearProjOfClosedCompl p q h hp hq) â‡‘(Submodule.linearProjOfIsCompl p q h)","decl":"@[simp]\ntheorem coe_continuous_linearProjOfClosedCompl' (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    â‡‘(p.linearProjOfClosedCompl q h hp hq) = p.linearProjOfIsCompl q h := rfl\n\n"}
{"name":"Submodule.ClosedComplemented.of_isCompl_isClosed","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np q : Subspace ğ•œ E\nh : IsCompl p q\nhp : IsClosed â†‘p\nhq : IsClosed â†‘q\nâŠ¢ Submodule.ClosedComplemented p","decl":"theorem ClosedComplemented.of_isCompl_isClosed (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) : p.ClosedComplemented :=\n  âŸ¨p.linearProjOfClosedCompl q h hp hq, Submodule.linearProjOfIsCompl_apply_left hâŸ©\n\n"}
{"name":"Submodule.IsCompl.closedComplemented_of_isClosed","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np q : Subspace ğ•œ E\nh : IsCompl p q\nhp : IsClosed â†‘p\nhq : IsClosed â†‘q\nâŠ¢ Submodule.ClosedComplemented p","decl":"alias IsCompl.closedComplemented_of_isClosed := ClosedComplemented.of_isCompl_isClosed\n\n"}
{"name":"Submodule.closedComplemented_iff_isClosed_exists_isClosed_isCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœÂ³ : NontriviallyNormedField ğ•œ\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\ninstâœ : CompleteSpace E\np : Subspace ğ•œ E\nâŠ¢ Iff (Submodule.ClosedComplemented p) (And (IsClosed â†‘p) (Exists fun q => And (IsClosed â†‘q) (IsCompl p q)))","decl":"theorem closedComplemented_iff_isClosed_exists_isClosed_isCompl :\n    p.ClosedComplemented â†”\n      IsClosed (p : Set E) âˆ§ âˆƒ q : Submodule ğ•œ E, IsClosed (q : Set E) âˆ§ IsCompl p q :=\n  âŸ¨fun h => âŸ¨h.isClosed, h.exists_isClosed_isComplâŸ©,\n    fun âŸ¨hp, âŸ¨_, hq, hpqâŸ©âŸ© => .of_isCompl_isClosed hpq hp hqâŸ©\n\n"}
{"name":"Submodule.ClosedComplemented.of_quotient_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"ğ•œ : Type u_1\nE : Type u_2\ninstâœâµ : NontriviallyNormedField ğ•œ\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ninstâœÂ² : CompleteSpace E\np : Subspace ğ•œ E\ninstâœÂ¹ : CompleteSpace ğ•œ\ninstâœ : FiniteDimensional ğ•œ (HasQuotient.Quotient E p)\nhp : IsClosed â†‘p\nâŠ¢ Submodule.ClosedComplemented p","decl":"theorem ClosedComplemented.of_quotient_finiteDimensional [CompleteSpace ğ•œ]\n    [FiniteDimensional ğ•œ (E â§¸ p)] (hp : IsClosed (p : Set E)) : p.ClosedComplemented := by\n  obtain âŸ¨q, hqâŸ© : âˆƒ q, IsCompl p q := p.exists_isCompl\n  haveI : FiniteDimensional ğ•œ q := (p.quotientEquivOfIsCompl q hq).finiteDimensional\n  exact .of_isCompl_isClosed hq hp q.closed_of_finiteDimensional\n\n"}
