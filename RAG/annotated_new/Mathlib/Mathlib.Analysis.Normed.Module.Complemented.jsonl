{"name":"ContinuousLinearMap.ker_closedComplemented_of_finiteDimensional_range","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\ninst✝⁶ : NontriviallyNormedField 𝕜\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\ninst✝¹ : CompleteSpace 𝕜\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\ninst✝ : FiniteDimensional 𝕜 (Subtype fun x => Membership.mem (LinearMap.range f) x)\n⊢ (LinearMap.ker f).ClosedComplemented","decl":"theorem ker_closedComplemented_of_finiteDimensional_range (f : E →L[𝕜] F)\n    [FiniteDimensional 𝕜 (range f)] : (ker f).ClosedComplemented := by\n  set f' : E →L[𝕜] range f := f.codRestrict _ (LinearMap.mem_range_self (f : E →ₗ[𝕜] F))\n  rcases f'.exists_right_inverse_of_surjective (f : E →ₗ[𝕜] F).range_rangeRestrict with ⟨g, hg⟩\n  simpa only [f', ker_codRestrict]\n    using f'.closedComplemented_ker_of_rightInverse g (ContinuousLinearMap.ext_iff.1 hg)\n\n"}
{"name":"ContinuousLinearMap.coe_equivProdOfSurjectiveOfIsCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace (Prod F G)\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\ng : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\n⊢ Eq ↑↑(f.equivProdOfSurjectiveOfIsCompl g hf hg hfg) ↑(f.prod g)","decl":"@[simp]\ntheorem coe_equivProdOfSurjectiveOfIsCompl {f : E →L[𝕜] F} {g : E →L[𝕜] G} (hf : range f = ⊤)\n    (hg : range g = ⊤) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg : E →ₗ[𝕜] F × G) = f.prod g := rfl\n\n"}
{"name":"ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl_toLinearEquiv","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace (Prod F G)\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\ng : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\n⊢ Eq (f.equivProdOfSurjectiveOfIsCompl g hf hg hfg).toLinearEquiv ((↑f).equivProdOfSurjectiveOfIsCompl (↑g) hf hg hfg)","decl":"@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_toLinearEquiv {f : E →L[𝕜] F} {g : E →L[𝕜] G}\n    (hf : range f = ⊤) (hg : range g = ⊤) (hfg : IsCompl (ker f) (ker g)) :\n    (equivProdOfSurjectiveOfIsCompl f g hf hg hfg).toLinearEquiv =\n      LinearMap.equivProdOfSurjectiveOfIsCompl f g hf hg hfg := rfl\n\n"}
{"name":"ContinuousLinearMap.equivProdOfSurjectiveOfIsCompl_apply","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\nF : Type u_3\nG : Type u_4\ninst✝⁸ : NontriviallyNormedField 𝕜\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\ninst✝¹ : CompleteSpace E\ninst✝ : CompleteSpace (Prod F G)\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\ng : ContinuousLinearMap (RingHom.id 𝕜) E G\nhf : Eq (LinearMap.range f) Top.top\nhg : Eq (LinearMap.range g) Top.top\nhfg : IsCompl (LinearMap.ker f) (LinearMap.ker g)\nx : E\n⊢ Eq ((f.equivProdOfSurjectiveOfIsCompl g hf hg hfg) x) { fst := f x, snd := g x }","decl":"@[simp]\ntheorem equivProdOfSurjectiveOfIsCompl_apply {f : E →L[𝕜] F} {g : E →L[𝕜] G} (hf : range f = ⊤)\n    (hg : range g = ⊤) (hfg : IsCompl (ker f) (ker g)) (x : E) :\n    equivProdOfSurjectiveOfIsCompl f g hf hg hfg x = (f x, g x) := rfl\n\n"}
{"name":"Submodule.coe_prodEquivOfClosedCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np q : Subspace 𝕜 E\nh : IsCompl p q\nhp : IsClosed ↑p\nhq : IsClosed ↑q\n⊢ Eq ⇑(Submodule.prodEquivOfClosedCompl p q h hp hq) ⇑(Submodule.prodEquivOfIsCompl p q h)","decl":"@[simp]\ntheorem coe_prodEquivOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    ⇑(p.prodEquivOfClosedCompl q h hp hq) = p.prodEquivOfIsCompl q h := rfl\n\n"}
{"name":"Submodule.coe_prodEquivOfClosedCompl_symm","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np q : Subspace 𝕜 E\nh : IsCompl p q\nhp : IsClosed ↑p\nhq : IsClosed ↑q\n⊢ Eq ⇑(Submodule.prodEquivOfClosedCompl p q h hp hq).symm ⇑(Submodule.prodEquivOfIsCompl p q h).symm","decl":"@[simp]\ntheorem coe_prodEquivOfClosedCompl_symm (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    ⇑(p.prodEquivOfClosedCompl q h hp hq).symm = (p.prodEquivOfIsCompl q h).symm := rfl\n\n"}
{"name":"Submodule.coe_continuous_linearProjOfClosedCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np q : Subspace 𝕜 E\nh : IsCompl p q\nhp : IsClosed ↑p\nhq : IsClosed ↑q\n⊢ Eq (↑(Submodule.linearProjOfClosedCompl p q h hp hq)) (Submodule.linearProjOfIsCompl p q h)","decl":"@[simp]\ntheorem coe_continuous_linearProjOfClosedCompl (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    (p.linearProjOfClosedCompl q h hp hq : E →ₗ[𝕜] p) = p.linearProjOfIsCompl q h := rfl\n\n"}
{"name":"Submodule.coe_continuous_linearProjOfClosedCompl'","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np q : Subspace 𝕜 E\nh : IsCompl p q\nhp : IsClosed ↑p\nhq : IsClosed ↑q\n⊢ Eq ⇑(Submodule.linearProjOfClosedCompl p q h hp hq) ⇑(Submodule.linearProjOfIsCompl p q h)","decl":"@[simp]\ntheorem coe_continuous_linearProjOfClosedCompl' (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) :\n    ⇑(p.linearProjOfClosedCompl q h hp hq) = p.linearProjOfIsCompl q h := rfl\n\n"}
{"name":"Submodule.ClosedComplemented.of_isCompl_isClosed","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np q : Subspace 𝕜 E\nh : IsCompl p q\nhp : IsClosed ↑p\nhq : IsClosed ↑q\n⊢ Submodule.ClosedComplemented p","decl":"theorem ClosedComplemented.of_isCompl_isClosed (h : IsCompl p q) (hp : IsClosed (p : Set E))\n    (hq : IsClosed (q : Set E)) : p.ClosedComplemented :=\n  ⟨p.linearProjOfClosedCompl q h hp hq, Submodule.linearProjOfIsCompl_apply_left h⟩\n\n"}
{"name":"Submodule.IsCompl.closedComplemented_of_isClosed","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np q : Subspace 𝕜 E\nh : IsCompl p q\nhp : IsClosed ↑p\nhq : IsClosed ↑q\n⊢ Submodule.ClosedComplemented p","decl":"alias IsCompl.closedComplemented_of_isClosed := ClosedComplemented.of_isCompl_isClosed\n\n"}
{"name":"Submodule.closedComplemented_iff_isClosed_exists_isClosed_isCompl","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝³ : NontriviallyNormedField 𝕜\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\ninst✝ : CompleteSpace E\np : Subspace 𝕜 E\n⊢ Iff (Submodule.ClosedComplemented p) (And (IsClosed ↑p) (Exists fun q => And (IsClosed ↑q) (IsCompl p q)))","decl":"theorem closedComplemented_iff_isClosed_exists_isClosed_isCompl :\n    p.ClosedComplemented ↔\n      IsClosed (p : Set E) ∧ ∃ q : Submodule 𝕜 E, IsClosed (q : Set E) ∧ IsCompl p q :=\n  ⟨fun h => ⟨h.isClosed, h.exists_isClosed_isCompl⟩,\n    fun ⟨hp, ⟨_, hq, hpq⟩⟩ => .of_isCompl_isClosed hpq hp hq⟩\n\n"}
{"name":"Submodule.ClosedComplemented.of_quotient_finiteDimensional","module":"Mathlib.Analysis.Normed.Module.Complemented","initialProofState":"𝕜 : Type u_1\nE : Type u_2\ninst✝⁵ : NontriviallyNormedField 𝕜\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ninst✝² : CompleteSpace E\np : Subspace 𝕜 E\ninst✝¹ : CompleteSpace 𝕜\ninst✝ : FiniteDimensional 𝕜 (HasQuotient.Quotient E p)\nhp : IsClosed ↑p\n⊢ Submodule.ClosedComplemented p","decl":"theorem ClosedComplemented.of_quotient_finiteDimensional [CompleteSpace 𝕜]\n    [FiniteDimensional 𝕜 (E ⧸ p)] (hp : IsClosed (p : Set E)) : p.ClosedComplemented := by\n  obtain ⟨q, hq⟩ : ∃ q, IsCompl p q := p.exists_isCompl\n  haveI : FiniteDimensional 𝕜 q := (p.quotientEquivOfIsCompl q hq).finiteDimensional\n  exact .of_isCompl_isClosed hq hp q.closed_of_finiteDimensional\n\n"}
