{"name":"Int.negOnePow_def","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq n.negOnePow (HPow.hPow (-1) n)","decl":"lemma negOnePow_def (n : ℤ) : n.negOnePow = (-1 : ℤˣ) ^ n := rfl\n\n"}
{"name":"Int.negOnePow_add","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n₁ n₂ : Int\n⊢ Eq (HAdd.hAdd n₁ n₂).negOnePow (HMul.hMul n₁.negOnePow n₂.negOnePow)","decl":"lemma negOnePow_add (n₁ n₂ : ℤ) :\n    (n₁ + n₂).negOnePow =  n₁.negOnePow * n₂.negOnePow :=\n  zpow_add _ _ _\n\n"}
{"name":"Int.negOnePow_zero","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"⊢ Eq (Int.negOnePow 0) 1","decl":"@[simp]\nlemma negOnePow_zero : negOnePow 0 = 1 := rfl\n\n"}
{"name":"Int.negOnePow_one","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"⊢ Eq (Int.negOnePow 1) (-1)","decl":"@[simp]\nlemma negOnePow_one : negOnePow 1 = -1 := rfl\n\n"}
{"name":"Int.negOnePow_succ","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (HAdd.hAdd n 1).negOnePow (Neg.neg n.negOnePow)","decl":"lemma negOnePow_succ (n : ℤ) : (n + 1).negOnePow = - n.negOnePow := by\n  rw [negOnePow_add, negOnePow_one, mul_neg, mul_one]\n\n"}
{"name":"Int.negOnePow_even","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\nhn : Even n\n⊢ Eq n.negOnePow 1","decl":"lemma negOnePow_even (n : ℤ) (hn : Even n) : n.negOnePow = 1 := by\n  obtain ⟨k, rfl⟩ := hn\n  rw [negOnePow_add, units_mul_self]\n\n"}
{"name":"Int.negOnePow_two_mul","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (HMul.hMul 2 n).negOnePow 1","decl":"@[simp]\nlemma negOnePow_two_mul (n : ℤ) : (2 * n).negOnePow = 1 :=\n  negOnePow_even _ ⟨n, two_mul n⟩\n\n"}
{"name":"Int.negOnePow_odd","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\nhn : Odd n\n⊢ Eq n.negOnePow (-1)","decl":"lemma negOnePow_odd (n : ℤ) (hn : Odd n) : n.negOnePow = -1 := by\n  obtain ⟨k, rfl⟩ := hn\n  simp only [negOnePow_add, negOnePow_two_mul, negOnePow_one, mul_neg, mul_one]\n\n"}
{"name":"Int.negOnePow_two_mul_add_one","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (HAdd.hAdd (HMul.hMul 2 n) 1).negOnePow (-1)","decl":"@[simp]\nlemma negOnePow_two_mul_add_one (n : ℤ) : (2 * n + 1).negOnePow = -1 :=\n  negOnePow_odd _ ⟨n, rfl⟩\n\n"}
{"name":"Int.negOnePow_eq_one_iff","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Iff (Eq n.negOnePow 1) (Even n)","decl":"lemma negOnePow_eq_one_iff (n : ℤ) : n.negOnePow = 1 ↔ Even n := by\n  constructor\n  · intro h\n    rw [← Int.not_odd_iff_even]\n    intro h'\n    simp only [negOnePow_odd _ h'] at h\n    contradiction\n  · exact negOnePow_even n\n\n"}
{"name":"Int.negOnePow_eq_neg_one_iff","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Iff (Eq n.negOnePow (-1)) (Odd n)","decl":"lemma negOnePow_eq_neg_one_iff (n : ℤ) : n.negOnePow = -1 ↔ Odd n := by\n  constructor\n  · intro h\n    rw [← Int.not_even_iff_odd]\n    intro h'\n    rw [negOnePow_even _ h'] at h\n    contradiction\n  · exact negOnePow_odd n\n\n"}
{"name":"Int.abs_negOnePow","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (abs ↑n.negOnePow) 1","decl":"@[simp]\ntheorem abs_negOnePow (n : ℤ) : |(n.negOnePow : ℤ)| = 1 := by\n  rw [abs_eq_natAbs, Int.units_natAbs, Nat.cast_one]\n\n"}
{"name":"Int.negOnePow_neg","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (Neg.neg n).negOnePow n.negOnePow","decl":"@[simp]\nlemma negOnePow_neg (n : ℤ) : (-n).negOnePow = n.negOnePow := by\n  dsimp [negOnePow]\n  simp only [zpow_neg, ← inv_zpow, inv_neg, inv_one]\n\n"}
{"name":"Int.negOnePow_abs","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (abs n).negOnePow n.negOnePow","decl":"@[simp]\nlemma negOnePow_abs (n : ℤ) : |n|.negOnePow = n.negOnePow := by\n  obtain h|h := abs_choice n <;> simp only [h, negOnePow_neg]\n\n"}
{"name":"Int.negOnePow_sub","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n₁ n₂ : Int\n⊢ Eq (HSub.hSub n₁ n₂).negOnePow (HMul.hMul n₁.negOnePow n₂.negOnePow)","decl":"lemma negOnePow_sub (n₁ n₂ : ℤ) :\n    (n₁ - n₂).negOnePow = n₁.negOnePow * n₂.negOnePow := by\n  simp only [sub_eq_add_neg, negOnePow_add, negOnePow_neg]\n\n"}
{"name":"Int.negOnePow_eq_iff","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n₁ n₂ : Int\n⊢ Iff (Eq n₁.negOnePow n₂.negOnePow) (Even (HSub.hSub n₁ n₂))","decl":"lemma negOnePow_eq_iff (n₁ n₂ : ℤ) :\n    n₁.negOnePow = n₂.negOnePow ↔ Even (n₁ - n₂) := by\n  by_cases h₂ : Even n₂\n  · rw [negOnePow_even _ h₂, Int.even_sub, negOnePow_eq_one_iff]\n    tauto\n  · rw [Int.not_even_iff_odd] at h₂\n    rw [negOnePow_odd _ h₂, Int.even_sub, negOnePow_eq_neg_one_iff,\n      ← Int.not_odd_iff_even, ← Int.not_odd_iff_even]\n    tauto\n\n"}
{"name":"Int.negOnePow_mul_self","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Int\n⊢ Eq (HMul.hMul n n).negOnePow n.negOnePow","decl":"@[simp]\nlemma negOnePow_mul_self (n : ℤ) : (n * n).negOnePow = n.negOnePow := by\n  simpa [mul_sub, negOnePow_eq_iff] using n.even_mul_pred_self\n\n"}
{"name":"Int.cast_negOnePow","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"K : Type u_1\nn : Int\ninst✝ : Field K\n⊢ Eq (↑↑n.negOnePow) (HPow.hPow (-1) n)","decl":"lemma cast_negOnePow (K : Type*) (n : ℤ) [Field K] : n.negOnePow = (-1 : K) ^ n := by\n  rcases even_or_odd' n with ⟨k, rfl | rfl⟩\n  · simp [zpow_mul, zpow_ofNat]\n  · rw [zpow_add_one₀ (by norm_num), zpow_mul, zpow_ofNat]\n    simp\n\n"}
{"name":"Int.coe_negOnePow","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"K : Type u_1\nn : Int\ninst✝ : Field K\n⊢ Eq (↑↑n.negOnePow) (HPow.hPow (-1) n)","decl":"@[deprecated (since := \"2024-10-20\")] alias coe_negOnePow := cast_negOnePow\n\n"}
{"name":"Int.cast_negOnePow_natCast","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"R : Type u_1\ninst✝ : Ring R\nn : Nat\n⊢ Eq (↑↑(↑n).negOnePow) (HPow.hPow (-1) n)","decl":"lemma cast_negOnePow_natCast (R : Type*) [Ring R] (n : ℕ) : negOnePow n = (-1 : R) ^ n := by\n  obtain ⟨k, rfl | rfl⟩ := Nat.even_or_odd' n <;> simp [pow_succ, pow_mul]\n\n"}
{"name":"Int.coe_negOnePow_natCast","module":"Mathlib.Algebra.Ring.NegOnePow","initialProofState":"n : Nat\n⊢ Eq (↑(↑n).negOnePow) (HPow.hPow (-1) n)","decl":"lemma coe_negOnePow_natCast (n : ℕ) : negOnePow n = (-1 : ℤ) ^ n := cast_negOnePow_natCast ..\n\n"}
