{"name":"memPartition_zero","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\n⊢ Eq (memPartition f 0) (Singleton.singleton Set.univ)","decl":"@[simp]\nlemma memPartition_zero (f : ℕ → Set α) : memPartition f 0 = {univ} := rfl\n\n"}
{"name":"memPartition_succ","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\n⊢ Eq (memPartition f (HAdd.hAdd n 1)) (setOf fun s => Exists fun u => And (Membership.mem (memPartition f n) u) (Or (Eq s (Inter.inter u (f n))) (Eq s (SDiff.sdiff u (f n)))))","decl":"lemma memPartition_succ (f : ℕ → Set α) (n : ℕ) :\n    memPartition f (n + 1) = {s | ∃ u ∈ memPartition f n, s = u ∩ f n ∨ s = u \\ f n} :=\n  rfl\n\n"}
{"name":"disjoint_memPartition","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\nu v : Set α\nhu : Membership.mem (memPartition f n) u\nhv : Membership.mem (memPartition f n) v\nhuv : Ne u v\n⊢ Disjoint u v","decl":"lemma disjoint_memPartition (f : ℕ → Set α) (n : ℕ) {u v : Set α}\n    (hu : u ∈ memPartition f n) (hv : v ∈ memPartition f n) (huv : u ≠ v) :\n    Disjoint u v := by\n  revert u v\n  induction n with\n  | zero =>\n    intro u v hu hv huv\n    simp only [memPartition_zero, mem_insert_iff, mem_singleton_iff] at hu hv\n    rw [hu, hv] at huv\n    exact absurd rfl huv\n  | succ n ih =>\n    intro u v hu hv huv\n    rw [memPartition_succ] at hu hv\n    obtain ⟨u', hu', hu'_eq⟩ := hu\n    obtain ⟨v', hv', hv'_eq⟩ := hv\n    rcases hu'_eq with rfl | rfl <;> rcases hv'_eq with rfl | rfl\n    · refine Disjoint.mono inter_subset_left inter_subset_left (ih hu' hv' ?_)\n      exact fun huv' ↦ huv (huv' ▸ rfl)\n    · exact Disjoint.mono_left inter_subset_right Set.disjoint_sdiff_right\n    · exact Disjoint.mono_right inter_subset_right Set.disjoint_sdiff_left\n    · refine Disjoint.mono diff_subset diff_subset (ih hu' hv' ?_)\n      exact fun huv' ↦ huv (huv' ▸ rfl)\n\n"}
{"name":"sUnion_memPartition","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\n⊢ Eq (memPartition f n).sUnion Set.univ","decl":"@[simp]\nlemma sUnion_memPartition (f : ℕ → Set α) (n : ℕ) : ⋃₀ memPartition f n = univ := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [memPartition_succ]\n    ext x\n    have : x ∈ ⋃₀ memPartition f n := by simp [ih]\n    simp only [mem_sUnion, mem_iUnion, mem_insert_iff, mem_singleton_iff, exists_prop, mem_univ,\n      iff_true] at this ⊢\n    obtain ⟨t, ht, hxt⟩ := this\n    by_cases hxf : x ∈ f n\n    · exact ⟨t ∩ f n, ⟨t, ht, Or.inl rfl⟩, hxt, hxf⟩\n    · exact ⟨t \\ f n, ⟨t, ht, Or.inr rfl⟩, hxt, hxf⟩\n\n"}
{"name":"finite_memPartition","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\n⊢ (memPartition f n).Finite","decl":"lemma finite_memPartition (f : ℕ → Set α) (n : ℕ) : Set.Finite (memPartition f n) := by\n  induction n with\n  | zero => simp\n  | succ n ih =>\n    rw [memPartition_succ]\n    have : Finite (memPartition f n) := Set.finite_coe_iff.mp ih\n    rw [← Set.finite_coe_iff]\n    simp_rw [setOf_exists, ← exists_prop, setOf_exists, setOf_or]\n    refine Finite.Set.finite_biUnion (memPartition f n) _ (fun u _ ↦ ?_)\n    rw [Set.finite_coe_iff]\n    simp\n\n"}
{"name":"instFinite_memPartition","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\n⊢ Finite ↑(memPartition f n)","decl":"instance instFinite_memPartition (f : ℕ → Set α) (n : ℕ) : Finite (memPartition f n) :=\n  Set.finite_coe_iff.mp (finite_memPartition _ _)\n\n"}
{"name":"memPartitionSet_zero","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\na : α\n⊢ Eq (memPartitionSet f 0 a) Set.univ","decl":"@[simp]\nlemma memPartitionSet_zero (f : ℕ → Set α) (a : α) : memPartitionSet f 0 a = univ := by\n  simp [memPartitionSet]\n\n"}
{"name":"memPartitionSet_succ","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\na : α\ninst✝ : Decidable (Membership.mem (f n) a)\n⊢ Eq (memPartitionSet f (HAdd.hAdd n 1) a) (ite (Membership.mem (f n) a) (Inter.inter (memPartitionSet f n a) (f n)) (SDiff.sdiff (memPartitionSet f n a) (f n)))","decl":"lemma memPartitionSet_succ (f : ℕ → Set α) (n : ℕ) (a : α) [Decidable (a ∈ f n)] :\n    memPartitionSet f (n + 1) a\n      = if a ∈ f n then memPartitionSet f n a ∩ f n else memPartitionSet f n a \\ f n := by\n  simp [memPartitionSet]\n\n"}
{"name":"memPartitionSet_mem","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\na : α\n⊢ Membership.mem (memPartition f n) (memPartitionSet f n a)","decl":"lemma memPartitionSet_mem (f : ℕ → Set α) (n : ℕ) (a : α) :\n    memPartitionSet f n a ∈ memPartition f n := by\n  induction n with\n  | zero => simp [memPartitionSet]\n  | succ n ih =>\n    classical\n    rw [memPartitionSet_succ, memPartition_succ]\n    refine ⟨memPartitionSet f n a, ?_⟩\n    split_ifs <;> simp [ih]\n\n"}
{"name":"mem_memPartitionSet","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\na : α\n⊢ Membership.mem (memPartitionSet f n a) a","decl":"lemma mem_memPartitionSet (f : ℕ → Set α) (n : ℕ) (a : α) : a ∈ memPartitionSet f n a := by\n  induction n with\n  | zero => simp [memPartitionSet]\n  | succ n ih =>\n    classical\n    rw [memPartitionSet_succ]\n    split_ifs with h <;> exact ⟨ih, h⟩\n\n"}
{"name":"memPartitionSet_eq_iff","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\na : α\ns : Set α\nhs : Membership.mem (memPartition f n) s\n⊢ Iff (Eq (memPartitionSet f n a) s) (Membership.mem s a)","decl":"lemma memPartitionSet_eq_iff {f : ℕ → Set α} {n : ℕ} (a : α) {s : Set α}\n    (hs : s ∈ memPartition f n) :\n    memPartitionSet f n a = s ↔ a ∈ s := by\n  refine ⟨fun h ↦ h ▸ mem_memPartitionSet f n a, fun h ↦ ?_⟩\n  by_contra h_ne\n  have h_disj : Disjoint s (memPartitionSet f n a) :=\n    disjoint_memPartition f n hs (memPartitionSet_mem f n a) (Ne.symm h_ne)\n  refine absurd h_disj ?_\n  rw [not_disjoint_iff_nonempty_inter]\n  exact ⟨a, h, mem_memPartitionSet f n a⟩\n\n"}
{"name":"memPartitionSet_of_mem","module":"Mathlib.Data.Set.MemPartition","initialProofState":"α : Type u_1\nf : Nat → Set α\nn : Nat\na : α\ns : Set α\nhs : Membership.mem (memPartition f n) s\nha : Membership.mem s a\n⊢ Eq (memPartitionSet f n a) s","decl":"lemma memPartitionSet_of_mem {f : ℕ → Set α} {n : ℕ} {a : α} {s : Set α}\n    (hs : s ∈ memPartition f n) (ha : a ∈ s) :\n    memPartitionSet f n a = s :=\n  (memPartitionSet_eq_iff a hs).mpr ha\n"}
