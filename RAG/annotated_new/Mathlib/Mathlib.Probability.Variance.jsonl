{"name":"ProbabilityTheory.evariance_lt_top","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ LT.lt (ProbabilityTheory.evariance X μ) Top.top","decl":"theorem evariance_lt_top [IsFiniteMeasure μ] (hX : Memℒp X 2 μ) : evariance X μ < ∞ := by\n  have := ENNReal.pow_lt_top (hX.sub <| memℒp_const <| μ[X]).2 2\n  rw [eLpNorm_eq_lintegral_rpow_enorm two_ne_zero ENNReal.ofNat_ne_top, ← ENNReal.rpow_two] at this\n  simp only [ENNReal.toReal_ofNat, Pi.sub_apply, ENNReal.one_toReal, one_div] at this\n  rw [← ENNReal.rpow_mul, inv_mul_cancel₀ (two_ne_zero : (2 : ℝ) ≠ 0), ENNReal.rpow_one] at this\n  simp_rw [ENNReal.rpow_two] at this\n  exact this\n\n"}
{"name":"ProbabilityTheory.evariance_ne_top","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ Ne (ProbabilityTheory.evariance X μ) Top.top","decl":"lemma evariance_ne_top [IsFiniteMeasure μ] (hX : Memℒp X 2 μ) : evariance X μ ≠ ∞ :=\n  (evariance_lt_top hX).ne\n\n"}
{"name":"ProbabilityTheory.evariance_eq_top","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhXm : MeasureTheory.AEStronglyMeasurable X μ\nhX : Not (MeasureTheory.Memℒp X 2 μ)\n⊢ Eq (ProbabilityTheory.evariance X μ) Top.top","decl":"theorem evariance_eq_top [IsFiniteMeasure μ] (hXm : AEStronglyMeasurable X μ) (hX : ¬Memℒp X 2 μ) :\n    evariance X μ = ∞ := by\n  by_contra h\n  rw [← Ne, ← lt_top_iff_ne_top] at h\n  have : Memℒp (fun ω => X ω - μ[X]) 2 μ := by\n    refine ⟨hXm.sub aestronglyMeasurable_const, ?_⟩\n    rw [eLpNorm_eq_lintegral_rpow_enorm two_ne_zero ENNReal.ofNat_ne_top]\n    simp only [ENNReal.toReal_ofNat, ENNReal.one_toReal, ENNReal.rpow_two, Ne]\n    exact ENNReal.rpow_lt_top_of_nonneg (by linarith) h.ne\n  refine hX ?_\n  convert this.add (memℒp_const μ[X])\n  ext ω\n  rw [Pi.add_apply, sub_add_cancel]\n\n"}
{"name":"ProbabilityTheory.evariance_lt_top_iff_memℒp","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\n⊢ Iff (LT.lt (ProbabilityTheory.evariance X μ) Top.top) (MeasureTheory.Memℒp X 2 μ)","decl":"theorem evariance_lt_top_iff_memℒp [IsFiniteMeasure μ] (hX : AEStronglyMeasurable X μ) :\n    evariance X μ < ∞ ↔ Memℒp X 2 μ where\n  mp := by contrapose!; rw [top_le_iff]; exact evariance_eq_top hX\n  mpr := evariance_lt_top\n\n"}
{"name":"ProbabilityTheory.evariance_eq_top_iff","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.AEStronglyMeasurable X μ\n⊢ Iff (Eq (ProbabilityTheory.evariance X μ) Top.top) (Not (MeasureTheory.Memℒp X 2 μ))","decl":"lemma evariance_eq_top_iff [IsFiniteMeasure μ] (hX : AEStronglyMeasurable X μ) :\n    evariance X μ = ∞ ↔ ¬ Memℒp X 2 μ := by simp [← evariance_lt_top_iff_memℒp hX]\n\n"}
{"name":"ProbabilityTheory.ofReal_variance","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ Eq (ENNReal.ofReal (ProbabilityTheory.variance X μ)) (ProbabilityTheory.evariance X μ)","decl":"theorem ofReal_variance [IsFiniteMeasure μ] (hX : Memℒp X 2 μ) :\n    .ofReal (variance X μ) = evariance X μ := by\n  rw [variance, ENNReal.ofReal_toReal]\n  exact evariance_ne_top hX\n\n"}
{"name":"MeasureTheory.Memℒp.evariance_lt_top","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ LT.lt (ProbabilityTheory.evariance X μ) Top.top","decl":"protected alias _root_.MeasureTheory.Memℒp.evariance_lt_top := evariance_lt_top\n"}
{"name":"MeasureTheory.Memℒp.evariance_ne_top","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ Ne (ProbabilityTheory.evariance X μ) Top.top","decl":"protected alias _root_.MeasureTheory.Memℒp.evariance_ne_top := evariance_ne_top\n"}
{"name":"MeasureTheory.Memℒp.ofReal_variance_eq","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ Eq (ENNReal.ofReal (ProbabilityTheory.variance X μ)) (ProbabilityTheory.evariance X μ)","decl":"protected alias _root_.MeasureTheory.Memℒp.ofReal_variance_eq := ofReal_variance\n\n"}
{"name":"ProbabilityTheory.evariance_eq_lintegral_ofReal","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.evariance X μ) (MeasureTheory.lintegral μ fun ω => ENNReal.ofReal (HPow.hPow (HSub.hSub (X ω) (MeasureTheory.integral μ fun x => X x)) 2))","decl":"variable (X μ) in\ntheorem evariance_eq_lintegral_ofReal :\n    evariance X μ = ∫⁻ ω, ENNReal.ofReal ((X ω - μ[X]) ^ 2) ∂μ := by\n  simp [evariance, ← enorm_pow, Real.enorm_of_nonneg (sq_nonneg _)]\n\n"}
{"name":"ProbabilityTheory.variance_eq_integral","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\n⊢ Eq (ProbabilityTheory.variance X μ) (MeasureTheory.integral μ fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.integral μ fun x => X x)) 2)","decl":"lemma variance_eq_integral (hX : AEMeasurable X μ) : Var[X ; μ] = ∫ ω, (X ω - μ[X]) ^ 2 ∂μ := by\n  simp [variance, evariance, toReal_enorm, ← integral_toReal ((hX.sub_const _).enorm.pow_const _) <|\n    .of_forall fun _ ↦ ENNReal.pow_lt_top enorm_lt_top _]\n\n"}
{"name":"ProbabilityTheory.variance_of_integral_eq_zero","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\nhXint : Eq (MeasureTheory.integral μ fun x => X x) 0\n⊢ Eq (ProbabilityTheory.variance X μ) (MeasureTheory.integral μ fun ω => HPow.hPow (X ω) 2)","decl":"lemma variance_of_integral_eq_zero (hX : AEMeasurable X μ) (hXint : μ[X] = 0) :\n    variance X μ = ∫ ω, X ω ^ 2 ∂μ := by\n  simp [variance_eq_integral hX, hXint]\n\n"}
{"name":"MeasureTheory.Memℒp.variance_eq","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\n⊢ Eq (ProbabilityTheory.variance X μ) (MeasureTheory.integral μ fun ω => HPow.hPow (HSub.hSub (X ω) (MeasureTheory.integral μ fun x => X x)) 2)","decl":"@[deprecated (since := \"2025-01-23\")]\nalias _root_.MeasureTheory.Memℒp.variance_eq := variance_eq_integral\n\n"}
{"name":"MeasureTheory.Memℒp.variance_eq_of_integral_eq_zero","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\nhXint : Eq (MeasureTheory.integral μ fun x => X x) 0\n⊢ Eq (ProbabilityTheory.variance X μ) (MeasureTheory.integral μ fun ω => HPow.hPow (X ω) 2)","decl":"@[deprecated (since := \"2025-01-23\")]\nalias _root_.MeasureTheory.Memℒp.variance_eq_of_integral_eq_zero := variance_of_integral_eq_zero\n\n"}
{"name":"ProbabilityTheory.evariance_zero","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.evariance 0 μ) 0","decl":"@[simp]\ntheorem evariance_zero : evariance 0 μ = 0 := by simp [evariance]\n\n"}
{"name":"ProbabilityTheory.evariance_eq_zero_iff","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\nhX : AEMeasurable X μ\n⊢ Iff (Eq (ProbabilityTheory.evariance X μ) 0) ((MeasureTheory.ae μ).EventuallyEq X fun x => MeasureTheory.integral μ fun x => X x)","decl":"theorem evariance_eq_zero_iff (hX : AEMeasurable X μ) :\n    evariance X μ = 0 ↔ X =ᵐ[μ] fun _ => μ[X] := by\n  simp [evariance, lintegral_eq_zero_iff' ((hX.sub_const _).enorm.pow_const _), EventuallyEq,\n    sub_eq_zero]\n\n"}
{"name":"ProbabilityTheory.evariance_mul","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nc : Real\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.evariance (fun ω => HMul.hMul c (X ω)) μ) (HMul.hMul (ENNReal.ofReal (HPow.hPow c 2)) (ProbabilityTheory.evariance X μ))","decl":"theorem evariance_mul (c : ℝ) (X : Ω → ℝ) (μ : Measure Ω) :\n    evariance (fun ω => c * X ω) μ = ENNReal.ofReal (c ^ 2) * evariance X μ := by\n  rw [evariance, evariance, ← lintegral_const_mul' _ _ ENNReal.ofReal_lt_top.ne]\n  congr with ω\n  rw [integral_mul_left, ← mul_sub, enorm_mul, mul_pow, ← enorm_pow,\n    Real.enorm_of_nonneg (sq_nonneg _)]\n\n"}
{"name":"ProbabilityTheory.variance_zero","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.variance 0 μ) 0","decl":"@[simp]\ntheorem variance_zero (μ : Measure Ω) : variance 0 μ = 0 := by\n  simp only [variance, evariance_zero, ENNReal.zero_toReal]\n\n"}
{"name":"ProbabilityTheory.variance_nonneg","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ LE.le 0 (ProbabilityTheory.variance X μ)","decl":"theorem variance_nonneg (X : Ω → ℝ) (μ : Measure Ω) : 0 ≤ variance X μ :=\n  ENNReal.toReal_nonneg\n\n"}
{"name":"ProbabilityTheory.variance_mul","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nc : Real\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.variance (fun ω => HMul.hMul c (X ω)) μ) (HMul.hMul (HPow.hPow c 2) (ProbabilityTheory.variance X μ))","decl":"theorem variance_mul (c : ℝ) (X : Ω → ℝ) (μ : Measure Ω) :\n    variance (fun ω => c * X ω) μ = c ^ 2 * variance X μ := by\n  rw [variance, evariance_mul, ENNReal.toReal_mul, ENNReal.toReal_ofReal (sq_nonneg _)]\n  rfl\n\n"}
{"name":"ProbabilityTheory.variance_smul","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nc : Real\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.variance (HSMul.hSMul c X) μ) (HMul.hMul (HPow.hPow c 2) (ProbabilityTheory.variance X μ))","decl":"theorem variance_smul (c : ℝ) (X : Ω → ℝ) (μ : Measure Ω) :\n    variance (c • X) μ = c ^ 2 * variance X μ :=\n  variance_mul c X μ\n\n"}
{"name":"ProbabilityTheory.variance_smul'","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nA : Type u_2\ninst✝¹ : CommSemiring A\ninst✝ : Algebra A Real\nc : A\nX : Ω → Real\nμ : MeasureTheory.Measure Ω\n⊢ Eq (ProbabilityTheory.variance (HSMul.hSMul c X) μ) (HSMul.hSMul (HPow.hPow c 2) (ProbabilityTheory.variance X μ))","decl":"theorem variance_smul' {A : Type*} [CommSemiring A] [Algebra A ℝ] (c : A) (X : Ω → ℝ)\n    (μ : Measure Ω) : variance (c • X) μ = c ^ 2 • variance X μ := by\n  convert variance_smul (algebraMap A ℝ c) X μ using 1\n  · congr; simp only [algebraMap_smul]\n  · simp only [Algebra.smul_def, map_pow]\n\n"}
{"name":"ProbabilityTheory.variance_def'","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nX : Ω → Real\nhX : MeasureTheory.Memℒp X 2 μ\n⊢ Eq (ProbabilityTheory.variance X μ) (HSub.hSub (MeasureTheory.integral μ fun x => HPow.hPow X 2 x) (HPow.hPow (MeasureTheory.integral μ fun x => X x) 2))","decl":"theorem variance_def' [IsProbabilityMeasure μ] {X : Ω → ℝ} (hX : Memℒp X 2 μ) :\n    variance X μ = μ[X ^ 2] - μ[X] ^ 2 := by\n  simp only [variance_eq_integral hX.aestronglyMeasurable.aemeasurable, sub_sq']\n  rw [integral_sub, integral_add]; rotate_left\n  · exact hX.integrable_sq\n  · apply integrable_const\n  · apply hX.integrable_sq.add\n    apply integrable_const\n  · exact ((hX.integrable one_le_two).const_mul 2).mul_const' _\n  simp only [Pi.pow_apply, integral_const, measure_univ, ENNReal.one_toReal, smul_eq_mul, one_mul,\n    Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, integral_mul_right, integral_mul_left]\n  ring\n\n"}
{"name":"ProbabilityTheory.variance_le_expectation_sq","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nX : Ω → Real\nhm : MeasureTheory.AEStronglyMeasurable X μ\n⊢ LE.le (ProbabilityTheory.variance X μ) (MeasureTheory.integral μ fun x => HPow.hPow X 2 x)","decl":"theorem variance_le_expectation_sq [IsProbabilityMeasure μ] {X : Ω → ℝ}\n    (hm : AEStronglyMeasurable X μ) : variance X μ ≤ μ[X ^ 2] := by\n  by_cases hX : Memℒp X 2 μ\n  · rw [variance_def' hX]\n    simp only [sq_nonneg, sub_le_self_iff]\n  rw [variance, evariance_eq_lintegral_ofReal, ← integral_eq_lintegral_of_nonneg_ae]\n  · by_cases hint : Integrable X μ; swap\n    · simp only [integral_undef hint, Pi.pow_apply, Pi.sub_apply, sub_zero]\n      exact le_rfl\n    · rw [integral_undef]\n      · exact integral_nonneg fun a => sq_nonneg _\n      intro h\n      have A : Memℒp (X - fun ω : Ω => μ[X]) 2 μ :=\n        (memℒp_two_iff_integrable_sq (hint.aestronglyMeasurable.sub aestronglyMeasurable_const)).2 h\n      have B : Memℒp (fun _ : Ω => μ[X]) 2 μ := memℒp_const _\n      apply hX\n      convert A.add B\n      simp\n  · exact Eventually.of_forall fun x => sq_nonneg _\n  · exact (AEMeasurable.pow_const (hm.aemeasurable.sub_const _) _).aestronglyMeasurable\n\n"}
{"name":"ProbabilityTheory.evariance_def'","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nX : Ω → Real\nhX : MeasureTheory.AEStronglyMeasurable X μ\n⊢ Eq (ProbabilityTheory.evariance X μ) (HSub.hSub (MeasureTheory.lintegral μ fun ω => HPow.hPow (ENorm.enorm (X ω)) 2) (ENNReal.ofReal (HPow.hPow (MeasureTheory.integral μ fun x => X x) 2)))","decl":"theorem evariance_def' [IsProbabilityMeasure μ] {X : Ω → ℝ} (hX : AEStronglyMeasurable X μ) :\n    evariance X μ = (∫⁻ ω, ‖X ω‖ₑ ^ 2 ∂μ) - ENNReal.ofReal (μ[X] ^ 2) := by\n  by_cases hℒ : Memℒp X 2 μ\n  · rw [← ofReal_variance hℒ, variance_def' hℒ, ENNReal.ofReal_sub _ (sq_nonneg _)]\n    congr\n    simp_rw [← enorm_pow, enorm]\n    rw [lintegral_coe_eq_integral]\n    · simp\n    · simpa using hℒ.abs.integrable_sq\n  · symm\n    rw [evariance_eq_top hX hℒ, ENNReal.sub_eq_top_iff]\n    refine ⟨?_, ENNReal.ofReal_ne_top⟩\n    rw [Memℒp, not_and] at hℒ\n    specialize hℒ hX\n    simp only [eLpNorm_eq_lintegral_rpow_enorm two_ne_zero ENNReal.ofNat_ne_top, not_lt, top_le_iff,\n      ENNReal.toReal_ofNat, one_div, ENNReal.rpow_eq_top_iff, inv_lt_zero, inv_pos, and_true,\n      or_iff_not_imp_left, not_and_or, zero_lt_two] at hℒ\n    exact mod_cast hℒ fun _ => zero_le_two\n\n"}
{"name":"ProbabilityTheory.meas_ge_le_evariance_div_sq","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nX : Ω → Real\nhX : MeasureTheory.AEStronglyMeasurable X μ\nc : NNReal\nhc : Ne c 0\n⊢ LE.le (μ (setOf fun ω => LE.le (↑c) (abs (HSub.hSub (X ω) (MeasureTheory.integral μ fun x => X x))))) (HDiv.hDiv (ProbabilityTheory.evariance X μ) (HPow.hPow (↑c) 2))","decl":"/-- **Chebyshev's inequality** for `ℝ≥0∞`-valued variance. -/\ntheorem meas_ge_le_evariance_div_sq {X : Ω → ℝ} (hX : AEStronglyMeasurable X μ) {c : ℝ≥0}\n    (hc : c ≠ 0) : μ {ω | ↑c ≤ |X ω - μ[X]|} ≤ evariance X μ / c ^ 2 := by\n  have A : (c : ℝ≥0∞) ≠ 0 := by rwa [Ne, ENNReal.coe_eq_zero]\n  have B : AEStronglyMeasurable (fun _ : Ω => μ[X]) μ := aestronglyMeasurable_const\n  convert meas_ge_le_mul_pow_eLpNorm μ two_ne_zero ENNReal.ofNat_ne_top (hX.sub B) A using 1\n  · congr\n    simp only [Pi.sub_apply, ENNReal.coe_le_coe, ← Real.norm_eq_abs, ← coe_nnnorm,\n      NNReal.coe_le_coe, ENNReal.ofReal_coe_nnreal]\n  · rw [eLpNorm_eq_lintegral_rpow_enorm two_ne_zero ENNReal.ofNat_ne_top]\n    simp only [show ENNReal.ofNNReal (c ^ 2) = (ENNReal.ofNNReal c) ^ 2 by norm_cast,\n      ENNReal.toReal_ofNat, one_div, Pi.sub_apply]\n    rw [div_eq_mul_inv, ENNReal.inv_pow, mul_comm, ENNReal.rpow_two]\n    congr\n    simp_rw [← ENNReal.rpow_mul, inv_mul_cancel₀ (two_ne_zero : (2 : ℝ) ≠ 0), ENNReal.rpow_two,\n      ENNReal.rpow_one, evariance]\n\n\n"}
{"name":"ProbabilityTheory.meas_ge_le_variance_div_sq","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsFiniteMeasure μ\nX : Ω → Real\nhX : MeasureTheory.Memℒp X 2 μ\nc : Real\nhc : LT.lt 0 c\n⊢ LE.le (μ (setOf fun ω => LE.le c (abs (HSub.hSub (X ω) (MeasureTheory.integral μ fun x => X x))))) (ENNReal.ofReal (HDiv.hDiv (ProbabilityTheory.variance X μ) (HPow.hPow c 2)))","decl":"/-- **Chebyshev's inequality**: one can control the deviation probability of a real random variable\nfrom its expectation in terms of the variance. -/\ntheorem meas_ge_le_variance_div_sq [IsFiniteMeasure μ] {X : Ω → ℝ} (hX : Memℒp X 2 μ) {c : ℝ}\n    (hc : 0 < c) : μ {ω | c ≤ |X ω - μ[X]|} ≤ ENNReal.ofReal (variance X μ / c ^ 2) := by\n  rw [ENNReal.ofReal_div_of_pos (sq_pos_of_ne_zero hc.ne.symm), hX.ofReal_variance_eq]\n  convert @meas_ge_le_evariance_div_sq _ _ _ _ hX.1 c.toNNReal (by simp [hc]) using 1\n  · simp only [Real.coe_toNNReal', max_le_iff, abs_nonneg, and_true]\n  · rw [ENNReal.ofReal_pow hc.le]\n    rfl\n\n-- Porting note: supplied `MeasurableSpace Ω` argument of `h` by unification\n"}
{"name":"ProbabilityTheory.IndepFun.variance_add","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nX Y : Ω → Real\nhX : MeasureTheory.Memℒp X 2 μ\nhY : MeasureTheory.Memℒp Y 2 μ\nh : ProbabilityTheory.IndepFun X Y μ\n⊢ Eq (ProbabilityTheory.variance (HAdd.hAdd X Y) μ) (HAdd.hAdd (ProbabilityTheory.variance X μ) (ProbabilityTheory.variance Y μ))","decl":"/-- The variance of the sum of two independent random variables is the sum of the variances. -/\ntheorem IndepFun.variance_add [IsProbabilityMeasure μ] {X Y : Ω → ℝ} (hX : Memℒp X 2 μ)\n    (hY : Memℒp Y 2 μ) (h : IndepFun X Y μ) : variance (X + Y) μ = variance X μ + variance Y μ :=\n  calc\n    variance (X + Y) μ = μ[fun a => X a ^ 2 + Y a ^ 2 + 2 * X a * Y a] - μ[X + Y] ^ 2 := by\n      simp [variance_def' (hX.add hY), add_sq']\n    _ = μ[X ^ 2] + μ[Y ^ 2] + (2 : ℝ) * μ[X * Y] - (μ[X] + μ[Y]) ^ 2 := by\n      simp only [Pi.add_apply, Pi.pow_apply, Pi.mul_apply, mul_assoc]\n      rw [integral_add, integral_add, integral_add, integral_mul_left]\n      · exact hX.integrable one_le_two\n      · exact hY.integrable one_le_two\n      · exact hX.integrable_sq\n      · exact hY.integrable_sq\n      · exact hX.integrable_sq.add hY.integrable_sq\n      · apply Integrable.const_mul\n        exact h.integrable_mul (hX.integrable one_le_two) (hY.integrable one_le_two)\n    _ = μ[X ^ 2] + μ[Y ^ 2] + 2 * (μ[X] * μ[Y]) - (μ[X] + μ[Y]) ^ 2 := by\n      congr\n      exact h.integral_mul_of_integrable (hX.integrable one_le_two) (hY.integrable one_le_two)\n    _ = variance X μ + variance Y μ := by simp only [variance_def', hX, hY, Pi.pow_apply]; ring\n\n-- Porting note: supplied `MeasurableSpace Ω` argument of `hs`, `h` by unification\n"}
{"name":"ProbabilityTheory.IndepFun.variance_sum","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\nι : Type u_2\nX : ι → Ω → Real\ns : Finset ι\nhs : ∀ (i : ι), Membership.mem s i → MeasureTheory.Memℒp (X i) 2 μ\nh : (↑s).Pairwise fun i j => ProbabilityTheory.IndepFun (X i) (X j) μ\n⊢ Eq (ProbabilityTheory.variance (s.sum fun i => X i) μ) (s.sum fun i => ProbabilityTheory.variance (X i) μ)","decl":"/-- The variance of a finite sum of pairwise independent random variables is the sum of the\nvariances. -/\ntheorem IndepFun.variance_sum [IsProbabilityMeasure μ] {ι : Type*} {X : ι → Ω → ℝ}\n    {s : Finset ι} (hs : ∀ i ∈ s, Memℒp (X i) 2 μ)\n    (h : Set.Pairwise ↑s fun i j => IndepFun (X i) (X j) μ) :\n    variance (∑ i ∈ s, X i) μ = ∑ i ∈ s, variance (X i) μ := by\n  classical\n  induction' s using Finset.induction_on with k s ks IH\n  · simp only [Finset.sum_empty, variance_zero]\n  rw [variance_def' (memℒp_finset_sum' _ hs), sum_insert ks, sum_insert ks]\n  simp only [add_sq']\n  calc\n    μ[(X k ^ 2 + (∑ i ∈ s, X i) ^ 2 + 2 * X k * ∑ i ∈ s, X i : Ω → ℝ)] - μ[X k + ∑ i ∈ s, X i] ^ 2 =\n        μ[X k ^ 2] + μ[(∑ i ∈ s, X i) ^ 2] + μ[2 * X k * ∑ i ∈ s, X i] -\n          (μ[X k] + μ[∑ i ∈ s, X i]) ^ 2 := by\n      rw [integral_add', integral_add', integral_add']\n      · exact Memℒp.integrable one_le_two (hs _ (mem_insert_self _ _))\n      · apply integrable_finset_sum' _ fun i hi => ?_\n        exact Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi))\n      · exact Memℒp.integrable_sq (hs _ (mem_insert_self _ _))\n      · apply Memℒp.integrable_sq\n        exact memℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)\n      · apply Integrable.add\n        · exact Memℒp.integrable_sq (hs _ (mem_insert_self _ _))\n        · apply Memℒp.integrable_sq\n          exact memℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi)\n      · rw [mul_assoc]\n        apply Integrable.const_mul _ (2 : ℝ)\n        rw [mul_sum, sum_fn]\n        apply integrable_finset_sum _ fun i hi => ?_\n        apply IndepFun.integrable_mul _ (Memℒp.integrable one_le_two (hs _ (mem_insert_self _ _)))\n          (Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)))\n        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)\n        exact fun hki => ks (hki.symm ▸ hi)\n    _ = variance (X k) μ + variance (∑ i ∈ s, X i) μ +\n        (μ[2 * X k * ∑ i ∈ s, X i] - 2 * μ[X k] * μ[∑ i ∈ s, X i]) := by\n      rw [variance_def' (hs _ (mem_insert_self _ _)),\n        variance_def' (memℒp_finset_sum' _ fun i hi => hs _ (mem_insert_of_mem hi))]\n      ring\n    _ = variance (X k) μ + variance (∑ i ∈ s, X i) μ := by\n      simp_rw [Pi.mul_apply, Pi.ofNat_apply, Nat.cast_ofNat, sum_apply, mul_sum, mul_assoc,\n        add_right_eq_self]\n      rw [integral_finset_sum s fun i hi => ?_]; swap\n      · apply Integrable.const_mul _ (2 : ℝ)\n        apply IndepFun.integrable_mul _ (Memℒp.integrable one_le_two (hs _ (mem_insert_self _ _)))\n          (Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)))\n        apply h (mem_insert_self _ _) (mem_insert_of_mem hi)\n        exact fun hki => ks (hki.symm ▸ hi)\n      rw [integral_finset_sum s fun i hi =>\n          Memℒp.integrable one_le_two (hs _ (mem_insert_of_mem hi)),\n        mul_sum, mul_sum, ← sum_sub_distrib]\n      apply Finset.sum_eq_zero fun i hi => ?_\n      rw [integral_mul_left, IndepFun.integral_mul', sub_self]\n      · apply h (mem_insert_self _ _) (mem_insert_of_mem hi)\n        exact fun hki => ks (hki.symm ▸ hi)\n      · exact Memℒp.aestronglyMeasurable (hs _ (mem_insert_self _ _))\n      · exact Memℒp.aestronglyMeasurable (hs _ (mem_insert_of_mem hi))\n    _ = variance (X k) μ + ∑ i ∈ s, variance (X i) μ := by\n      rw [IH (fun i hi => hs i (mem_insert_of_mem hi))\n          (h.mono (by simp only [coe_insert, Set.subset_insert]))]\n\n"}
{"name":"ProbabilityTheory.variance_le_sub_mul_sub","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\na b : Real\nX : Ω → Real\nh : Filter.Eventually (fun ω => Membership.mem (Set.Icc a b) (X ω)) (MeasureTheory.ae μ)\nhX : AEMeasurable X μ\n⊢ LE.le (ProbabilityTheory.variance X μ) (HMul.hMul (HSub.hSub b (MeasureTheory.integral μ fun x => X x)) (HSub.hSub (MeasureTheory.integral μ fun x => X x) a))","decl":"/-- **The Bhatia-Davis inequality on variance**\n\nThe variance of a random variable `X` satisfying `a ≤ X ≤ b` almost everywhere is at most\n`(b - 𝔼 X) * (𝔼 X - a)`. -/\nlemma variance_le_sub_mul_sub [IsProbabilityMeasure μ] {a b : ℝ} {X : Ω → ℝ}\n    (h : ∀ᵐ ω ∂μ, X ω ∈ Set.Icc a b) (hX : AEMeasurable X μ) :\n    variance X μ ≤ (b - μ[X]) * (μ[X] - a) := by\n  have ha : ∀ᵐ ω ∂μ, a ≤ X ω := h.mono fun ω h => h.1\n  have hb : ∀ᵐ ω ∂μ, X ω ≤ b := h.mono fun ω h => h.2\n  have hX_int₂ : Integrable (fun ω ↦ -X ω ^ 2) μ :=\n    (memℒp_of_bounded h hX.aestronglyMeasurable 2).integrable_sq.neg\n  have hX_int₁ : Integrable (fun ω ↦ (a + b) * X ω) μ :=\n    ((integrable_const (max |a| |b|)).mono' hX.aestronglyMeasurable\n      (by filter_upwards [ha, hb] with ω using abs_le_max_abs_abs)).const_mul (a + b)\n  have h0 : 0 ≤ - μ[X ^ 2] + (a + b) * μ[X] - a * b :=\n    calc\n      _ ≤ ∫ ω, (b - X ω) * (X ω - a) ∂μ := by\n        apply integral_nonneg_of_ae\n        filter_upwards [ha, hb] with ω ha' hb'\n        exact mul_nonneg (by linarith : 0 ≤ b - X ω) (by linarith : 0 ≤ X ω - a)\n      _ = ∫ ω, - X ω ^ 2 + (a + b) * X ω - a * b ∂μ :=\n        integral_congr_ae <| ae_of_all μ fun ω ↦ by ring\n      _ = ∫ ω, - X ω ^ 2 + (a + b) * X ω ∂μ - ∫ _, a * b ∂μ :=\n        integral_sub (by fun_prop) (integrable_const (a * b))\n      _ = ∫ ω, - X ω ^ 2 + (a + b) * X ω ∂μ - a * b := by simp\n      _ = - μ[X ^ 2] + (a + b) * μ[X] - a * b := by\n        simp [← integral_neg, ← integral_mul_left, integral_add hX_int₂ hX_int₁]\n  calc\n    _ ≤ (a + b) * μ[X] - a * b - μ[X] ^ 2 := by\n      rw [variance_def' (memℒp_of_bounded h hX.aestronglyMeasurable 2)]\n      linarith\n    _ = (b - μ[X]) * (μ[X] - a) := by ring\n\n"}
{"name":"ProbabilityTheory.variance_le_sq_of_bounded","module":"Mathlib.Probability.Variance","initialProofState":"Ω : Type u_1\nmΩ : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\ninst✝ : MeasureTheory.IsProbabilityMeasure μ\na b : Real\nX : Ω → Real\nh : Filter.Eventually (fun ω => Membership.mem (Set.Icc a b) (X ω)) (MeasureTheory.ae μ)\nhX : AEMeasurable X μ\n⊢ LE.le (ProbabilityTheory.variance X μ) (HPow.hPow (HDiv.hDiv (HSub.hSub b a) 2) 2)","decl":"/-- **Popoviciu's inequality on variance**\n\nThe variance of a random variable `X` satisfying `a ≤ X ≤ b` almost everywhere is at most\n`((b - a) / 2) ^ 2`. -/\nlemma variance_le_sq_of_bounded [IsProbabilityMeasure μ] {a b : ℝ} {X : Ω → ℝ}\n    (h : ∀ᵐ ω ∂μ, X ω ∈ Set.Icc a b) (hX : AEMeasurable X μ) :\n    variance X μ ≤ ((b - a) / 2) ^ 2 :=\n  calc\n    _ ≤ (b - μ[X]) * (μ[X] - a) := variance_le_sub_mul_sub h hX\n    _ = ((b - a) / 2) ^ 2 - (μ[X] - (b + a) / 2) ^ 2 := by ring\n    _ ≤ ((b - a) / 2) ^ 2 := sub_le_self _ (sq_nonneg _)\n\n"}
