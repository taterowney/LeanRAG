{"name":"MonCat.FilteredColimits.M.mk_eq","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J MonCatMax\nx y : Sigma fun j => ↑(F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)\n⊢ Eq (MonCat.FilteredColimits.M.mk F x) (MonCat.FilteredColimits.M.mk F y)","decl":"@[to_additive]\ntheorem M.mk_eq (x y : Σ j, F.obj j)\n    (h : ∃ (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k), F.map f x.2 = F.map g y.2) :\n    M.mk.{v, u} F x = M.mk F y :=\n  Quot.eqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel (F ⋙ forget MonCat) x y h)\n\n"}
{"name":"AddMonCat.FilteredColimits.M.mk_eq","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J AddMonCatMax\nx y : Sigma fun j => ↑(F.obj j)\nh : Exists fun k => Exists fun f => Exists fun g => Eq ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)\n⊢ Eq (AddMonCat.FilteredColimits.M.mk F x) (AddMonCat.FilteredColimits.M.mk F y)","decl":"@[to_additive]\ntheorem M.mk_eq (x y : Σ j, F.obj j)\n    (h : ∃ (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k), F.map f x.2 = F.map g y.2) :\n    M.mk.{v, u} F x = M.mk F y :=\n  Quot.eqvGen_sound (Types.FilteredColimit.eqvGen_quot_rel_of_rel (F ⋙ forget MonCat) x y h)\n\n"}
{"name":"MonCat.FilteredColimits.colimit_one_eq","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J MonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nj : J\n⊢ Eq 1 (MonCat.FilteredColimits.M.mk F ⟨j, 1⟩)","decl":"/-- The definition of the \"one\" in the colimit is independent of the chosen object of `J`.\nIn particular, this lemma allows us to \"unfold\" the definition of `colimit_one` at a custom chosen\nobject `j`.\n-/\n@[to_additive\n      \"The definition of the \\\"zero\\\" in the colimit is independent of the chosen object\n      of `J`. In particular, this lemma allows us to \\\"unfold\\\" the definition of `colimit_zero` at\n      a custom chosen object `j`.\"]\ntheorem colimit_one_eq (j : J) : (1 : M.{v, u} F) = M.mk F ⟨j, 1⟩ := by\n  apply M.mk_eq\n  refine ⟨max' _ j, IsFiltered.leftToMax _ j, IsFiltered.rightToMax _ j, ?_⟩\n  simp\n\n"}
{"name":"AddMonCat.FilteredColimits.colimit_zero_eq","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J AddMonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nj : J\n⊢ Eq 0 (AddMonCat.FilteredColimits.M.mk F ⟨j, 0⟩)","decl":"/-- The definition of the \"one\" in the colimit is independent of the chosen object of `J`.\nIn particular, this lemma allows us to \"unfold\" the definition of `colimit_one` at a custom chosen\nobject `j`.\n-/\n@[to_additive\n      \"The definition of the \\\"zero\\\" in the colimit is independent of the chosen object\n      of `J`. In particular, this lemma allows us to \\\"unfold\\\" the definition of `colimit_zero` at\n      a custom chosen object `j`.\"]\ntheorem colimit_one_eq (j : J) : (1 : M.{v, u} F) = M.mk F ⟨j, 1⟩ := by\n  apply M.mk_eq\n  refine ⟨max' _ j, IsFiltered.leftToMax _ j, IsFiltered.rightToMax _ j, ?_⟩\n  simp\n\n"}
{"name":"AddMonCat.FilteredColimits.colimitAddAux_eq_of_rel_left","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J AddMonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nx x' y : Sigma fun j => ↑(F.obj j)\nhxx' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget AddMonCat)) x x'\n⊢ Eq (AddMonCat.FilteredColimits.colimitAddAux F x y) (AddMonCat.FilteredColimits.colimitAddAux F x' y)","decl":"/-- Multiplication in the colimit is well-defined in the left argument. -/\n@[to_additive \"Addition in the colimit is well-defined in the left argument.\"]\ntheorem colimitMulAux_eq_of_rel_left {x x' y : Σ j, F.obj j}\n    (hxx' : Types.FilteredColimit.Rel (F ⋙ forget MonCat) x x') :\n    colimitMulAux.{v, u} F x y = colimitMulAux.{v, u} F x' y := by\n  obtain ⟨j₁, x⟩ := x; obtain ⟨j₂, y⟩ := y; obtain ⟨j₃, x'⟩ := x'\n  obtain ⟨l, f, g, hfg⟩ := hxx'\n  simp? at hfg says\n    simp only [Functor.comp_obj, Functor.comp_map, ConcreteCategory.forget_map_eq_coe] at hfg\n  obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ :=\n    IsFiltered.tulip (IsFiltered.leftToMax j₁ j₂) (IsFiltered.rightToMax j₁ j₂)\n      (IsFiltered.rightToMax j₃ j₂) (IsFiltered.leftToMax j₃ j₂) f g\n  apply M.mk_eq\n  use s, α, γ\n  dsimp\n  simp_rw [MonoidHom.map_mul]\n  -- Porting note: Lean cannot seem to use lemmas from concrete categories directly\n  change (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _ =\n    (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _\n  simp_rw [← F.map_comp, h₁, h₂, h₃, F.map_comp]\n  congr 1\n  change F.map _ (F.map _ _) = F.map _ (F.map _ _)\n  rw [hfg]\n\n"}
{"name":"MonCat.FilteredColimits.colimitMulAux_eq_of_rel_left","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J MonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nx x' y : Sigma fun j => ↑(F.obj j)\nhxx' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget MonCat)) x x'\n⊢ Eq (MonCat.FilteredColimits.colimitMulAux F x y) (MonCat.FilteredColimits.colimitMulAux F x' y)","decl":"/-- Multiplication in the colimit is well-defined in the left argument. -/\n@[to_additive \"Addition in the colimit is well-defined in the left argument.\"]\ntheorem colimitMulAux_eq_of_rel_left {x x' y : Σ j, F.obj j}\n    (hxx' : Types.FilteredColimit.Rel (F ⋙ forget MonCat) x x') :\n    colimitMulAux.{v, u} F x y = colimitMulAux.{v, u} F x' y := by\n  obtain ⟨j₁, x⟩ := x; obtain ⟨j₂, y⟩ := y; obtain ⟨j₃, x'⟩ := x'\n  obtain ⟨l, f, g, hfg⟩ := hxx'\n  simp? at hfg says\n    simp only [Functor.comp_obj, Functor.comp_map, ConcreteCategory.forget_map_eq_coe] at hfg\n  obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ :=\n    IsFiltered.tulip (IsFiltered.leftToMax j₁ j₂) (IsFiltered.rightToMax j₁ j₂)\n      (IsFiltered.rightToMax j₃ j₂) (IsFiltered.leftToMax j₃ j₂) f g\n  apply M.mk_eq\n  use s, α, γ\n  dsimp\n  simp_rw [MonoidHom.map_mul]\n  -- Porting note: Lean cannot seem to use lemmas from concrete categories directly\n  change (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _ =\n    (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _\n  simp_rw [← F.map_comp, h₁, h₂, h₃, F.map_comp]\n  congr 1\n  change F.map _ (F.map _ _) = F.map _ (F.map _ _)\n  rw [hfg]\n\n"}
{"name":"AddMonCat.FilteredColimits.colimitAddAux_eq_of_rel_right","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J AddMonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nx y y' : Sigma fun j => ↑(F.obj j)\nhyy' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget AddMonCat)) y y'\n⊢ Eq (AddMonCat.FilteredColimits.colimitAddAux F x y) (AddMonCat.FilteredColimits.colimitAddAux F x y')","decl":"/-- Multiplication in the colimit is well-defined in the right argument. -/\n@[to_additive \"Addition in the colimit is well-defined in the right argument.\"]\ntheorem colimitMulAux_eq_of_rel_right {x y y' : Σ j, F.obj j}\n    (hyy' : Types.FilteredColimit.Rel (F ⋙ forget MonCat) y y') :\n    colimitMulAux.{v, u} F x y = colimitMulAux.{v, u} F x y' := by\n  obtain ⟨j₁, y⟩ := y; obtain ⟨j₂, x⟩ := x; obtain ⟨j₃, y'⟩ := y'\n  obtain ⟨l, f, g, hfg⟩ := hyy'\n  simp only [Functor.comp_obj, Functor.comp_map, forget_map] at hfg\n  obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ :=\n    IsFiltered.tulip (IsFiltered.rightToMax j₂ j₁) (IsFiltered.leftToMax j₂ j₁)\n      (IsFiltered.leftToMax j₂ j₃) (IsFiltered.rightToMax j₂ j₃) f g\n  apply M.mk_eq\n  use s, α, γ\n  dsimp\n  simp_rw [MonoidHom.map_mul]\n  -- Porting note: Lean cannot seem to use lemmas from concrete categories directly\n  change (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _ =\n    (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _\n  simp_rw [← F.map_comp, h₁, h₂, h₃, F.map_comp]\n  congr 1\n  change F.map _ (F.map _ _) = F.map _ (F.map _ _)\n  rw [hfg]\n\n"}
{"name":"MonCat.FilteredColimits.colimitMulAux_eq_of_rel_right","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J MonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nx y y' : Sigma fun j => ↑(F.obj j)\nhyy' : CategoryTheory.Limits.Types.FilteredColimit.Rel (F.comp (CategoryTheory.forget MonCat)) y y'\n⊢ Eq (MonCat.FilteredColimits.colimitMulAux F x y) (MonCat.FilteredColimits.colimitMulAux F x y')","decl":"/-- Multiplication in the colimit is well-defined in the right argument. -/\n@[to_additive \"Addition in the colimit is well-defined in the right argument.\"]\ntheorem colimitMulAux_eq_of_rel_right {x y y' : Σ j, F.obj j}\n    (hyy' : Types.FilteredColimit.Rel (F ⋙ forget MonCat) y y') :\n    colimitMulAux.{v, u} F x y = colimitMulAux.{v, u} F x y' := by\n  obtain ⟨j₁, y⟩ := y; obtain ⟨j₂, x⟩ := x; obtain ⟨j₃, y'⟩ := y'\n  obtain ⟨l, f, g, hfg⟩ := hyy'\n  simp only [Functor.comp_obj, Functor.comp_map, forget_map] at hfg\n  obtain ⟨s, α, β, γ, h₁, h₂, h₃⟩ :=\n    IsFiltered.tulip (IsFiltered.rightToMax j₂ j₁) (IsFiltered.leftToMax j₂ j₁)\n      (IsFiltered.leftToMax j₂ j₃) (IsFiltered.rightToMax j₂ j₃) f g\n  apply M.mk_eq\n  use s, α, γ\n  dsimp\n  simp_rw [MonoidHom.map_mul]\n  -- Porting note: Lean cannot seem to use lemmas from concrete categories directly\n  change (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _ =\n    (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _\n  simp_rw [← F.map_comp, h₁, h₂, h₃, F.map_comp]\n  congr 1\n  change F.map _ (F.map _ _) = F.map _ (F.map _ _)\n  rw [hfg]\n\n"}
{"name":"AddMonCat.FilteredColimits.colimit_add_mk_eq","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J AddMonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nx y : Sigma fun j => ↑(F.obj j)\nk : J\nf : Quiver.Hom x.fst k\ng : Quiver.Hom y.fst k\n⊢ Eq (HAdd.hAdd (AddMonCat.FilteredColimits.M.mk F x) (AddMonCat.FilteredColimits.M.mk F y)) (AddMonCat.FilteredColimits.M.mk F ⟨k, HAdd.hAdd ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)⟩)","decl":"/-- Multiplication in the colimit is independent of the chosen \"maximum\" in the filtered category.\nIn particular, this lemma allows us to \"unfold\" the definition of the multiplication of `x` and `y`,\nusing a custom object `k` and morphisms `f : x.1 ⟶ k` and `g : y.1 ⟶ k`.\n-/\n@[to_additive\n      \"Addition in the colimit is independent of the chosen \\\"maximum\\\" in the filtered\n      category. In particular, this lemma allows us to \\\"unfold\\\" the definition of the addition of\n      `x` and `y`, using a custom object `k` and morphisms `f : x.1 ⟶ k` and `g : y.1 ⟶ k`.\"]\ntheorem colimit_mul_mk_eq (x y : Σ j, F.obj j) (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k) :\n    M.mk.{v, u} F x * M.mk F y = M.mk F ⟨k, F.map f x.2 * F.map g y.2⟩ := by\n  obtain ⟨j₁, x⟩ := x; obtain ⟨j₂, y⟩ := y\n  obtain ⟨s, α, β, h₁, h₂⟩ := IsFiltered.bowtie (IsFiltered.leftToMax j₁ j₂) f\n    (IsFiltered.rightToMax j₁ j₂) g\n  refine M.mk_eq F _ _ ?_\n  use s, α, β\n  dsimp\n  simp_rw [MonoidHom.map_mul]\n  -- Porting note: Lean cannot seem to use lemmas from concrete categories directly\n  change (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _ =\n    (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _\n  simp_rw [← F.map_comp, h₁, h₂]\n\n"}
{"name":"MonCat.FilteredColimits.colimit_mul_mk_eq","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J MonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nx y : Sigma fun j => ↑(F.obj j)\nk : J\nf : Quiver.Hom x.fst k\ng : Quiver.Hom y.fst k\n⊢ Eq (HMul.hMul (MonCat.FilteredColimits.M.mk F x) (MonCat.FilteredColimits.M.mk F y)) (MonCat.FilteredColimits.M.mk F ⟨k, HMul.hMul ((CategoryTheory.ConcreteCategory.hom (F.map f)) x.snd) ((CategoryTheory.ConcreteCategory.hom (F.map g)) y.snd)⟩)","decl":"/-- Multiplication in the colimit is independent of the chosen \"maximum\" in the filtered category.\nIn particular, this lemma allows us to \"unfold\" the definition of the multiplication of `x` and `y`,\nusing a custom object `k` and morphisms `f : x.1 ⟶ k` and `g : y.1 ⟶ k`.\n-/\n@[to_additive\n      \"Addition in the colimit is independent of the chosen \\\"maximum\\\" in the filtered\n      category. In particular, this lemma allows us to \\\"unfold\\\" the definition of the addition of\n      `x` and `y`, using a custom object `k` and morphisms `f : x.1 ⟶ k` and `g : y.1 ⟶ k`.\"]\ntheorem colimit_mul_mk_eq (x y : Σ j, F.obj j) (k : J) (f : x.1 ⟶ k) (g : y.1 ⟶ k) :\n    M.mk.{v, u} F x * M.mk F y = M.mk F ⟨k, F.map f x.2 * F.map g y.2⟩ := by\n  obtain ⟨j₁, x⟩ := x; obtain ⟨j₂, y⟩ := y\n  obtain ⟨s, α, β, h₁, h₂⟩ := IsFiltered.bowtie (IsFiltered.leftToMax j₁ j₂) f\n    (IsFiltered.rightToMax j₁ j₂) g\n  refine M.mk_eq F _ _ ?_\n  use s, α, β\n  dsimp\n  simp_rw [MonoidHom.map_mul]\n  -- Porting note: Lean cannot seem to use lemmas from concrete categories directly\n  change (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _ =\n    (F.map _ ≫ F.map _) _ * (F.map _ ≫ F.map _) _\n  simp_rw [← F.map_comp, h₁, h₂]\n\n"}
{"name":"AddMonCat.FilteredColimits.cocone_naturality","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J AddMonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (AddMonCat.FilteredColimits.coconeMorphism F j')) (AddMonCat.FilteredColimits.coconeMorphism F j)","decl":"@[to_additive (attr := simp)]\ntheorem cocone_naturality {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ coconeMorphism.{v, u} F j' = coconeMorphism F j :=\n  MonCat.ext fun x =>\n    congr_fun ((Types.TypeMax.colimitCocone (F ⋙ forget MonCat)).ι.naturality f) x\n\n"}
{"name":"MonCat.FilteredColimits.cocone_naturality","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"J : Type v\ninst✝¹ : CategoryTheory.SmallCategory J\nF : CategoryTheory.Functor J MonCatMax\ninst✝ : CategoryTheory.IsFiltered J\nj j' : J\nf : Quiver.Hom j j'\n⊢ Eq (CategoryTheory.CategoryStruct.comp (F.map f) (MonCat.FilteredColimits.coconeMorphism F j')) (MonCat.FilteredColimits.coconeMorphism F j)","decl":"@[to_additive (attr := simp)]\ntheorem cocone_naturality {j j' : J} (f : j ⟶ j') :\n    F.map f ≫ coconeMorphism.{v, u} F j' = coconeMorphism F j :=\n  MonCat.ext fun x =>\n    congr_fun ((Types.TypeMax.colimitCocone (F ⋙ forget MonCat)).ι.naturality f) x\n\n"}
{"name":"AddMonCat.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget AddMonCat)","decl":"@[to_additive]\ninstance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget MonCat.{u}) :=\n  ⟨fun J hJ1 _ => letI hJ1' : Category J := hJ1\n    ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n      (Types.TypeMax.colimitCoconeIsColimit (F ⋙ forget MonCat.{u}))⟩⟩\n"}
{"name":"MonCat.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget MonCat)","decl":"@[to_additive]\ninstance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget MonCat.{u}) :=\n  ⟨fun J hJ1 _ => letI hJ1' : Category J := hJ1\n    ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n      (Types.TypeMax.colimitCoconeIsColimit (F ⋙ forget MonCat.{u}))⟩⟩\n"}
{"name":"AddCommMonCat.FilteredColimits.forget₂AddMonPreservesFilteredColimits","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ AddCommMonCat AddMonCat)","decl":"@[to_additive forget₂AddMonPreservesFilteredColimits]\nnoncomputable instance forget₂Mon_preservesFilteredColimits :\n  PreservesFilteredColimits (forget₂ CommMonCat MonCat.{u}) :=\n⟨fun J hJ1 _ => letI hJ3 : Category J := hJ1\n  ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n    (MonCat.FilteredColimits.colimitCoconeIsColimit (F ⋙ forget₂ CommMonCat MonCat.{u}))⟩⟩\n\n"}
{"name":"CommMonCat.FilteredColimits.forget₂Mon_preservesFilteredColimits","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget₂ CommMonCat MonCat)","decl":"@[to_additive forget₂AddMonPreservesFilteredColimits]\nnoncomputable instance forget₂Mon_preservesFilteredColimits :\n  PreservesFilteredColimits (forget₂ CommMonCat MonCat.{u}) :=\n⟨fun J hJ1 _ => letI hJ3 : Category J := hJ1\n  ⟨fun {F} => preservesColimit_of_preserves_colimit_cocone (colimitCoconeIsColimit.{u, u} F)\n    (MonCat.FilteredColimits.colimitCoconeIsColimit (F ⋙ forget₂ CommMonCat MonCat.{u}))⟩⟩\n\n"}
{"name":"CommMonCat.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget CommMonCat)","decl":"@[to_additive]\nnoncomputable instance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget CommMonCat.{u}) :=\n  Limits.comp_preservesFilteredColimits (forget₂ CommMonCat MonCat) (forget MonCat)\n\n"}
{"name":"AddCommMonCat.FilteredColimits.forget_preservesFilteredColimits","module":"Mathlib.Algebra.Category.MonCat.FilteredColimits","initialProofState":"⊢ CategoryTheory.Limits.PreservesFilteredColimits (CategoryTheory.forget AddCommMonCat)","decl":"@[to_additive]\nnoncomputable instance forget_preservesFilteredColimits :\n    PreservesFilteredColimits (forget CommMonCat.{u}) :=\n  Limits.comp_preservesFilteredColimits (forget₂ CommMonCat MonCat) (forget MonCat)\n\n"}
