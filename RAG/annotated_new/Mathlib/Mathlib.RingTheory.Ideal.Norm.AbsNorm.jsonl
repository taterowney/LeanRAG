{"name":"Submodule.cardQuot_apply","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nS : Submodule R M\n⊢ Eq S.cardQuot (Nat.card (HasQuotient.Quotient M S))","decl":"theorem cardQuot_apply (S : Submodule R M) : cardQuot S = Nat.card (M ⧸ S) := by\n  rfl\n\n"}
{"name":"Submodule.cardQuot_bot","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝³ : Ring R\ninst✝² : AddCommGroup M\ninst✝¹ : Module R M\ninst✝ : Infinite M\n⊢ Eq Bot.bot.cardQuot 0","decl":"@[simp]\ntheorem cardQuot_bot [Infinite M] : cardQuot (⊥ : Submodule R M) = 0 :=\n  AddSubgroup.index_bot.trans Nat.card_eq_zero_of_infinite\n\n"}
{"name":"Submodule.cardQuot_top","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\n⊢ Eq Top.top.cardQuot 1","decl":"@[simp]\ntheorem cardQuot_top : cardQuot (⊤ : Submodule R M) = 1 :=\n  AddSubgroup.index_top\n\n"}
{"name":"Submodule.cardQuot_eq_one_iff","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"R : Type u_1\nM : Type u_2\ninst✝² : Ring R\ninst✝¹ : AddCommGroup M\ninst✝ : Module R M\nP : Submodule R M\n⊢ Iff (Eq P.cardQuot 1) (Eq P Top.top)","decl":"@[simp]\ntheorem cardQuot_eq_one_iff {P : Submodule R M} : cardQuot P = 1 ↔ P = ⊤ :=\n  AddSubgroup.index_eq_one.trans (by simp [SetLike.ext_iff])\n\n"}
{"name":"cardQuot_mul_of_coprime","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nI J : Ideal S\ncoprime : IsCoprime I J\n⊢ Eq (Submodule.cardQuot (HMul.hMul I J)) (HMul.hMul (Submodule.cardQuot I) (Submodule.cardQuot J))","decl":"/-- Multiplicity of the ideal norm, for coprime ideals.\nThis is essentially just a repackaging of the Chinese Remainder Theorem.\n-/\ntheorem cardQuot_mul_of_coprime\n    {I J : Ideal S} (coprime : IsCoprime I J) : cardQuot (I * J) = cardQuot I * cardQuot J := by\n  rw [cardQuot_apply, cardQuot_apply, cardQuot_apply,\n    Nat.card_congr (Ideal.quotientMulEquivQuotientProd I J coprime).toEquiv,\n    Nat.card_prod]\n\n"}
{"name":"Ideal.mul_add_mem_pow_succ_inj","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝ : CommRing S\nP : Ideal S\ni : Nat\na d d' e e' : S\na_mem : Membership.mem (HPow.hPow P i) a\ne_mem : Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) e\ne'_mem : Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) e'\nh : Membership.mem P (HSub.hSub d d')\n⊢ Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) (HSub.hSub (HAdd.hAdd (HMul.hMul a d) e) (HAdd.hAdd (HMul.hMul a d') e'))","decl":"/-- If the `d` from `Ideal.exists_mul_add_mem_pow_succ` is unique, up to `P`,\nthen so are the `c`s, up to `P ^ (i + 1)`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem Ideal.mul_add_mem_pow_succ_inj (P : Ideal S) {i : ℕ} (a d d' e e' : S) (a_mem : a ∈ P ^ i)\n    (e_mem : e ∈ P ^ (i + 1)) (e'_mem : e' ∈ P ^ (i + 1)) (h : d - d' ∈ P) :\n    a * d + e - (a * d' + e') ∈ P ^ (i + 1) := by\n  have : a * d - a * d' ∈ P ^ (i + 1) := by\n    simp only [← mul_sub]\n    exact Ideal.mul_mem_mul a_mem h\n  convert Ideal.add_mem _ this (Ideal.sub_mem _ e_mem e'_mem) using 1\n  ring\n\n"}
{"name":"Ideal.exists_mul_add_mem_pow_succ","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝¹ : CommRing S\nP : Ideal S\nP_prime : P.IsPrime\ninst✝ : IsDedekindDomain S\nhP : Ne P Bot.bot\ni : Nat\na c : S\na_mem : Membership.mem (HPow.hPow P i) a\na_not_mem : Not (Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) a)\nc_mem : Membership.mem (HPow.hPow P i) c\n⊢ Exists fun d => Exists fun e => And (Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) e) (Eq (HAdd.hAdd (HMul.hMul a d) e) c)","decl":"/-- If `a ∈ P^i \\ P^(i+1)` and `c ∈ P^i`, then `a * d + e = c` for `e ∈ P^(i+1)`.\n`Ideal.mul_add_mem_pow_succ_unique` shows the choice of `d` is unique, up to `P`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem Ideal.exists_mul_add_mem_pow_succ [IsDedekindDomain S] (hP : P ≠ ⊥)\n    {i : ℕ} (a c : S) (a_mem : a ∈ P ^ i)\n    (a_not_mem : a ∉ P ^ (i + 1)) (c_mem : c ∈ P ^ i) :\n    ∃ d : S, ∃ e ∈ P ^ (i + 1), a * d + e = c := by\n  suffices eq_b : P ^ i = Ideal.span {a} ⊔ P ^ (i + 1) by\n    rw [eq_b] at c_mem\n    simp only [mul_comm a]\n    exact Ideal.mem_span_singleton_sup.mp c_mem\n  refine (Ideal.eq_prime_pow_of_succ_lt_of_le hP (lt_of_le_of_ne le_sup_right ?_)\n    (sup_le (Ideal.span_le.mpr (Set.singleton_subset_iff.mpr a_mem))\n      (Ideal.pow_succ_lt_pow hP i).le)).symm\n  contrapose! a_not_mem with this\n  rw [this]\n  exact mem_sup.mpr ⟨a, mem_span_singleton_self a, 0, by simp, by simp⟩\n\n"}
{"name":"Ideal.mem_prime_of_mul_mem_pow","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝¹ : CommRing S\ninst✝ : IsDedekindDomain S\nP : Ideal S\nP_prime : P.IsPrime\nhP : Ne P Bot.bot\ni : Nat\na b : S\na_not_mem : Not (Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) a)\nab_mem : Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) (HMul.hMul a b)\n⊢ Membership.mem P b","decl":"theorem Ideal.mem_prime_of_mul_mem_pow [IsDedekindDomain S] {P : Ideal S} [P_prime : P.IsPrime]\n    (hP : P ≠ ⊥) {i : ℕ} {a b : S} (a_not_mem : a ∉ P ^ (i + 1)) (ab_mem : a * b ∈ P ^ (i + 1)) :\n    b ∈ P := by\n  simp only [← Ideal.span_singleton_le_iff_mem, ← Ideal.dvd_iff_le, pow_succ, ←\n    Ideal.span_singleton_mul_span_singleton] at a_not_mem ab_mem ⊢\n  exact (prime_pow_succ_dvd_mul (Ideal.prime_of_isPrime hP P_prime) ab_mem).resolve_left a_not_mem\n\n"}
{"name":"Ideal.mul_add_mem_pow_succ_unique","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝¹ : CommRing S\nP : Ideal S\nP_prime : P.IsPrime\ninst✝ : IsDedekindDomain S\nhP : Ne P Bot.bot\ni : Nat\na d d' e e' : S\na_not_mem : Not (Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) a)\ne_mem : Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) e\ne'_mem : Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) e'\nh : Membership.mem (HPow.hPow P (HAdd.hAdd i 1)) (HSub.hSub (HAdd.hAdd (HMul.hMul a d) e) (HAdd.hAdd (HMul.hMul a d') e'))\n⊢ Membership.mem P (HSub.hSub d d')","decl":"/-- The choice of `d` in `Ideal.exists_mul_add_mem_pow_succ` is unique, up to `P`.\nInspired by [Neukirch], proposition 6.1 -/\ntheorem Ideal.mul_add_mem_pow_succ_unique [IsDedekindDomain S] (hP : P ≠ ⊥)\n    {i : ℕ} (a d d' e e' : S)\n    (a_not_mem : a ∉ P ^ (i + 1)) (e_mem : e ∈ P ^ (i + 1)) (e'_mem : e' ∈ P ^ (i + 1))\n    (h : a * d + e - (a * d' + e') ∈ P ^ (i + 1)) : d - d' ∈ P := by\n  have h' : a * (d - d') ∈ P ^ (i + 1) := by\n    convert Ideal.add_mem _ h (Ideal.sub_mem _ e'_mem e_mem) using 1\n    ring\n  exact Ideal.mem_prime_of_mul_mem_pow hP a_not_mem h'\n\n"}
{"name":"cardQuot_pow_of_prime","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝¹ : CommRing S\nP : Ideal S\nP_prime : P.IsPrime\ninst✝ : IsDedekindDomain S\nhP : Ne P Bot.bot\ni : Nat\n⊢ Eq (Submodule.cardQuot (HPow.hPow P i)) (HPow.hPow (Submodule.cardQuot P) i)","decl":"/-- Multiplicity of the ideal norm, for powers of prime ideals. -/\ntheorem cardQuot_pow_of_prime [IsDedekindDomain S] (hP : P ≠ ⊥) {i : ℕ} :\n    cardQuot (P ^ i) = cardQuot P ^ i := by\n  induction' i with i ih\n  · simp\n  have : P ^ (i + 1) < P ^ i := Ideal.pow_succ_lt_pow hP i\n  suffices hquot : map (P ^ i.succ).mkQ (P ^ i) ≃ S ⧸ P by\n    rw [pow_succ' (cardQuot P), ← ih, cardQuot_apply (P ^ i.succ), ←\n      card_quotient_mul_card_quotient (P ^ i) (P ^ i.succ) this.le, cardQuot_apply (P ^ i),\n      cardQuot_apply P, Nat.card_congr hquot]\n  choose a a_mem a_not_mem using SetLike.exists_of_lt this\n  choose f g hg hf using fun c (hc : c ∈ P ^ i) =>\n    Ideal.exists_mul_add_mem_pow_succ hP a c a_mem a_not_mem hc\n  choose k hk_mem hk_eq using fun c' (hc' : c' ∈ map (mkQ (P ^ i.succ)) (P ^ i)) =>\n    Submodule.mem_map.mp hc'\n  refine Equiv.ofBijective (fun c' => Quotient.mk'' (f (k c' c'.prop) (hk_mem c' c'.prop))) ⟨?_, ?_⟩\n  · rintro ⟨c₁', hc₁'⟩ ⟨c₂', hc₂'⟩ h\n    rw [Subtype.mk_eq_mk, ← hk_eq _ hc₁', ← hk_eq _ hc₂', mkQ_apply, mkQ_apply,\n      Submodule.Quotient.eq, ← hf _ (hk_mem _ hc₁'), ← hf _ (hk_mem _ hc₂')]\n    refine Ideal.mul_add_mem_pow_succ_inj _ _ _ _ _ _ a_mem (hg _ _) (hg _ _) ?_\n    simpa only [Submodule.Quotient.mk''_eq_mk, Submodule.Quotient.mk''_eq_mk,\n      Submodule.Quotient.eq] using h\n  · intro d'\n    refine Quotient.inductionOn' d' fun d => ?_\n    have hd' := (mem_map (f := mkQ (P ^ i.succ))).mpr ⟨a * d, Ideal.mul_mem_right d _ a_mem, rfl⟩\n    refine ⟨⟨_, hd'⟩, ?_⟩\n    simp only [Submodule.Quotient.mk''_eq_mk, Ideal.Quotient.mk_eq_mk, Ideal.Quotient.eq,\n      Subtype.coe_mk]\n    refine\n      Ideal.mul_add_mem_pow_succ_unique hP a _ _ _ _ a_not_mem (hg _ (hk_mem _ hd')) (zero_mem _) ?_\n    rw [hf, add_zero]\n    exact (Submodule.Quotient.eq _).mp (hk_eq _ hd')\n\n"}
{"name":"cardQuot_mul","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝² : CommRing S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI J : Ideal S\n⊢ Eq (Submodule.cardQuot (HMul.hMul I J)) (HMul.hMul (Submodule.cardQuot I) (Submodule.cardQuot J))","decl":"/-- Multiplicativity of the ideal norm in number rings. -/\ntheorem cardQuot_mul [IsDedekindDomain S] [Module.Free ℤ S] (I J : Ideal S) :\n    cardQuot (I * J) = cardQuot I * cardQuot J := by\n  let b := Module.Free.chooseBasis ℤ S\n  haveI : Infinite S := Infinite.of_surjective _ b.repr.toEquiv.surjective\n  exact UniqueFactorizationMonoid.multiplicative_of_coprime cardQuot I J (cardQuot_bot _ _)\n      (fun {I J} hI => by simp [Ideal.isUnit_iff.mp hI, Ideal.mul_top])\n      (fun {I} i hI =>\n        have : Ideal.IsPrime I := Ideal.isPrime_of_prime hI\n        cardQuot_pow_of_prime hI.ne_zero)\n      fun {I J} hIJ => cardQuot_mul_of_coprime <| Ideal.isCoprime_iff_sup_eq.mpr\n        (Ideal.isUnit_iff.mp\n          (hIJ (Ideal.dvd_iff_le.mpr le_sup_left) (Ideal.dvd_iff_le.mpr le_sup_right)))\n\n"}
{"name":"Ideal.absNorm_apply","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\n⊢ Eq (Ideal.absNorm I) (Submodule.cardQuot I)","decl":"theorem absNorm_apply (I : Ideal S) : absNorm I = cardQuot I := rfl\n\n"}
{"name":"Ideal.absNorm_bot","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\n⊢ Eq (Ideal.absNorm Bot.bot) 0","decl":"@[simp]\ntheorem absNorm_bot : absNorm (⊥ : Ideal S) = 0 := by rw [← Ideal.zero_eq_bot, _root_.map_zero]\n\n"}
{"name":"Ideal.absNorm_top","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\n⊢ Eq (Ideal.absNorm Top.top) 1","decl":"@[simp]\ntheorem absNorm_top : absNorm (⊤ : Ideal S) = 1 := by rw [← Ideal.one_eq_top, map_one]\n\n"}
{"name":"Ideal.absNorm_eq_one_iff","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\n⊢ Iff (Eq (Ideal.absNorm I) 1) (Eq I Top.top)","decl":"@[simp]\ntheorem absNorm_eq_one_iff {I : Ideal S} : absNorm I = 1 ↔ I = ⊤ := by\n  rw [absNorm_apply, cardQuot_eq_one_iff]\n\n"}
{"name":"Ideal.absNorm_ne_zero_iff","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\n⊢ Iff (Ne (Ideal.absNorm I) 0) (Finite (HasQuotient.Quotient S I))","decl":"theorem absNorm_ne_zero_iff (I : Ideal S) : Ideal.absNorm I ≠ 0 ↔ Finite (S ⧸ I) :=\n  ⟨fun h => Nat.finite_of_card_ne_zero h, fun h =>\n    (@AddSubgroup.finiteIndex_of_finite_quotient _ _ _ h).finiteIndex⟩\n\n"}
{"name":"Ideal.absNorm_dvd_absNorm_of_le","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI J : Ideal S\nh : LE.le J I\n⊢ Dvd.dvd (Ideal.absNorm I) (Ideal.absNorm J)","decl":"theorem absNorm_dvd_absNorm_of_le {I J : Ideal S} (h : J ≤ I) : Ideal.absNorm I ∣ Ideal.absNorm J :=\n  map_dvd absNorm (dvd_iff_le.mpr h)\n\n"}
{"name":"Ideal.irreducible_of_irreducible_absNorm","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\nhI : Irreducible (Ideal.absNorm I)\n⊢ Irreducible I","decl":"theorem irreducible_of_irreducible_absNorm {I : Ideal S} (hI : Irreducible (Ideal.absNorm I)) :\n    Irreducible I :=\n  irreducible_iff.mpr\n    ⟨fun h =>\n      hI.not_unit (by simpa only [Ideal.isUnit_iff, Nat.isUnit_iff, absNorm_eq_one_iff] using h),\n      by\n      rintro a b rfl\n      simpa only [Ideal.isUnit_iff, Nat.isUnit_iff, absNorm_eq_one_iff] using\n        hI.isUnit_or_isUnit (_root_.map_mul absNorm a b)⟩\n\n"}
{"name":"Ideal.isPrime_of_irreducible_absNorm","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\nhI : Irreducible (Ideal.absNorm I)\n⊢ I.IsPrime","decl":"theorem isPrime_of_irreducible_absNorm {I : Ideal S} (hI : Irreducible (Ideal.absNorm I)) :\n    I.IsPrime :=\n  isPrime_of_prime\n    (UniqueFactorizationMonoid.irreducible_iff_prime.mp (irreducible_of_irreducible_absNorm hI))\n\n"}
{"name":"Ideal.prime_of_irreducible_absNorm_span","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\na : S\nha : Ne a 0\nhI : Irreducible (Ideal.absNorm (Ideal.span (Singleton.singleton a)))\n⊢ Prime a","decl":"theorem prime_of_irreducible_absNorm_span {a : S} (ha : a ≠ 0)\n    (hI : Irreducible (Ideal.absNorm (Ideal.span ({a} : Set S)))) : Prime a :=\n  (Ideal.span_singleton_prime ha).mp (isPrime_of_irreducible_absNorm hI)\n\n"}
{"name":"Ideal.absNorm_mem","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\n⊢ Membership.mem I ↑(Ideal.absNorm I)","decl":"theorem absNorm_mem (I : Ideal S) : ↑(Ideal.absNorm I) ∈ I := by\n  rw [absNorm_apply, cardQuot, ← Ideal.Quotient.eq_zero_iff_mem, map_natCast,\n    Quotient.index_eq_zero]\n\n"}
{"name":"Ideal.span_singleton_absNorm_le","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\n⊢ LE.le (Ideal.span (Singleton.singleton ↑(Ideal.absNorm I))) I","decl":"theorem span_singleton_absNorm_le (I : Ideal S) : Ideal.span {(Ideal.absNorm I : S)} ≤ I := by\n  simp only [Ideal.span_le, Set.singleton_subset_iff, SetLike.mem_coe, Ideal.absNorm_mem I]\n\n"}
{"name":"Ideal.span_singleton_absNorm","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝³ : CommRing S\ninst✝² : Nontrivial S\ninst✝¹ : IsDedekindDomain S\ninst✝ : Module.Free Int S\nI : Ideal S\nhI : Nat.Prime (Ideal.absNorm I)\n⊢ Eq (Ideal.span (Singleton.singleton ↑(Ideal.absNorm I))) (Ideal.comap (algebraMap Int S) I)","decl":"theorem span_singleton_absNorm {I : Ideal S} (hI : (Ideal.absNorm I).Prime) :\n    Ideal.span (singleton (Ideal.absNorm I : ℤ)) = I.comap (algebraMap ℤ S) := by\n  have : Ideal.IsPrime (Ideal.span (singleton (Ideal.absNorm I : ℤ))) := by\n    rwa [Ideal.span_singleton_prime (Int.ofNat_ne_zero.mpr hI.ne_zero), ← Nat.prime_iff_prime_int]\n  apply (this.isMaximal _).eq_of_le\n  · exact ((isPrime_of_irreducible_absNorm\n      ((Nat.irreducible_iff_nat_prime _).mpr hI)).comap (algebraMap ℤ S)).ne_top\n  · rw [span_singleton_le_iff_mem, mem_comap, algebraMap_int_eq, map_natCast]\n    exact absNorm_mem I\n  · rw [Ne, span_singleton_eq_bot]\n    exact Int.ofNat_ne_zero.mpr hI.ne_zero\n\n"}
{"name":"Ideal.natAbs_det_equiv","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁶ : CommRing S\ninst✝⁵ : Nontrivial S\ninst✝⁴ : IsDedekindDomain S\ninst✝³ : Module.Free Int S\ninst✝² : Module.Finite Int S\nI : Ideal S\nE : Type u_2\ninst✝¹ : EquivLike E S (Subtype fun x => Membership.mem I x)\ninst✝ : AddEquivClass E S (Subtype fun x => Membership.mem I x)\ne : E\n⊢ Eq (LinearMap.det ((↑Int (Submodule.subtype I)).comp (↑e).toIntLinearMap)).natAbs (Ideal.absNorm I)","decl":"/-- Let `e : S ≃ I` be an additive isomorphism (therefore a `ℤ`-linear equiv).\nThen an alternative way to compute the norm of `I` is given by taking the determinant of `e`.\nSee `natAbs_det_basis_change` for a more familiar formulation of this result. -/\ntheorem natAbs_det_equiv (I : Ideal S) {E : Type*} [EquivLike E S I] [AddEquivClass E S I] (e : E) :\n    Int.natAbs\n        (LinearMap.det\n          ((Submodule.subtype I).restrictScalars ℤ ∘ₗ AddMonoidHom.toIntLinearMap (e : S →+ I))) =\n      Ideal.absNorm I := by\n  -- `S ⧸ I` might be infinite if `I = ⊥`, but then `e` can't be an equiv.\n  by_cases hI : I = ⊥\n  · subst hI\n    have : (1 : S) ≠ 0 := one_ne_zero\n    have : (1 : S) = 0 := EquivLike.injective e (Subsingleton.elim _ _)\n    contradiction\n  let ι := Module.Free.ChooseBasisIndex ℤ S\n  let b := Module.Free.chooseBasis ℤ S\n  cases isEmpty_or_nonempty ι\n  · nontriviality S\n    exact (not_nontrivial_iff_subsingleton.mpr\n      (Function.Surjective.subsingleton b.repr.toEquiv.symm.surjective) (by infer_instance)).elim\n  -- Thus `(S ⧸ I)` is isomorphic to a product of `ZMod`s, so it is a fintype.\n  letI := Ideal.fintypeQuotientOfFreeOfNeBot I hI\n  -- Use the Smith normal form to choose a nice basis for `I`.\n  letI := Classical.decEq ι\n  let a := I.smithCoeffs b hI\n  let b' := I.ringBasis b hI\n  let ab := I.selfBasis b hI\n  have ab_eq := I.selfBasis_def b hI\n  let e' : S ≃ₗ[ℤ] I := b'.equiv ab (Equiv.refl _)\n  let f : S →ₗ[ℤ] S := (I.subtype.restrictScalars ℤ).comp (e' : S →ₗ[ℤ] I)\n  let f_apply : ∀ x, f x = b'.equiv ab (Equiv.refl _) x := fun x => rfl\n  suffices (LinearMap.det f).natAbs = Ideal.absNorm I by\n    calc\n      _ = (LinearMap.det ((Submodule.subtype I).restrictScalars ℤ ∘ₗ\n            (AddEquiv.toIntLinearEquiv e : S ≃ₗ[ℤ] I))).natAbs := rfl\n      _ = (LinearMap.det ((Submodule.subtype I).restrictScalars ℤ ∘ₗ _)).natAbs :=\n            Int.natAbs_eq_iff_associated.mpr (LinearMap.associated_det_comp_equiv _ _ _)\n      _ = absNorm I := this\n  have ha : ∀ i, f (b' i) = a i • b' i := by\n    intro i; rw [f_apply, b'.equiv_apply, Equiv.refl_apply, ab_eq]\n  -- `det f` is equal to `∏ i, a i`,\n  letI := Classical.decEq ι\n  calc\n    Int.natAbs (LinearMap.det f) = Int.natAbs (LinearMap.toMatrix b' b' f).det := by\n      rw [LinearMap.det_toMatrix]\n    _ = Int.natAbs (Matrix.diagonal a).det := ?_\n    _ = Int.natAbs (∏ i, a i) := by rw [Matrix.det_diagonal]\n    _ = ∏ i, Int.natAbs (a i) := map_prod Int.natAbsHom a Finset.univ\n    _ = Nat.card (S ⧸ I) := ?_\n    _ = absNorm I := (Submodule.cardQuot_apply _).symm\n  -- since `LinearMap.toMatrix b' b' f` is the diagonal matrix with `a` along the diagonal.\n  · congr 2; ext i j\n    rw [LinearMap.toMatrix_apply, ha, LinearEquiv.map_smul, Basis.repr_self, Finsupp.smul_single,\n      smul_eq_mul, mul_one]\n    by_cases h : i = j\n    · rw [h, Matrix.diagonal_apply_eq, Finsupp.single_eq_same]\n    · rw [Matrix.diagonal_apply_ne _ h, Finsupp.single_eq_of_ne (Ne.symm h)]\n  -- Now we map everything through the linear equiv `S ≃ₗ (ι → ℤ)`,\n  -- which maps `(S ⧸ I)` to `Π i, ZMod (a i).nat_abs`.\n  haveI : ∀ i, NeZero (a i).natAbs := fun i =>\n    ⟨Int.natAbs_ne_zero.mpr (Ideal.smithCoeffs_ne_zero b I hI i)⟩\n  simp_rw [Nat.card_congr (Ideal.quotientEquivPiZMod I b hI).toEquiv, Nat.card_pi, Nat.card_zmod, a]\n\n"}
{"name":"Ideal.natAbs_det_basis_change","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁶ : CommRing S\ninst✝⁵ : Nontrivial S\ninst✝⁴ : IsDedekindDomain S\ninst✝³ : Module.Free Int S\ninst✝² : Module.Finite Int S\nι : Type u_2\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq ι\nb : Basis ι Int S\nI : Ideal S\nbI : Basis ι Int (Subtype fun x => Membership.mem I x)\n⊢ Eq (b.det (Function.comp Subtype.val ⇑bI)).natAbs (Ideal.absNorm I)","decl":"/-- Let `b` be a basis for `S` over `ℤ` and `bI` a basis for `I` over `ℤ` of the same dimension.\nThen an alternative way to compute the norm of `I` is given by taking the determinant of `bI`\nover `b`. -/\ntheorem natAbs_det_basis_change {ι : Type*} [Fintype ι] [DecidableEq ι] (b : Basis ι ℤ S)\n    (I : Ideal S) (bI : Basis ι ℤ I) : (b.det ((↑) ∘ bI)).natAbs = Ideal.absNorm I := by\n  let e := b.equiv bI (Equiv.refl _)\n  calc\n    (b.det ((Submodule.subtype I).restrictScalars ℤ ∘ bI)).natAbs =\n        (LinearMap.det ((Submodule.subtype I).restrictScalars ℤ ∘ₗ (e : S →ₗ[ℤ] I))).natAbs := by\n      rw [Basis.det_comp_basis]\n    _ = _ := natAbs_det_equiv I e\n\n"}
{"name":"Ideal.absNorm_span_singleton","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nr : S\n⊢ Eq (Ideal.absNorm (Ideal.span (Singleton.singleton r))) ((Algebra.norm Int) r).natAbs","decl":"@[simp]\ntheorem absNorm_span_singleton (r : S) :\n    absNorm (span ({r} : Set S)) = (Algebra.norm ℤ r).natAbs := by\n  rw [Algebra.norm_apply]\n  by_cases hr : r = 0\n  · simp only [hr, Ideal.span_zero, Algebra.coe_lmul_eq_mul, eq_self_iff_true, Ideal.absNorm_bot,\n      LinearMap.det_zero'', Set.singleton_zero, _root_.map_zero, Int.natAbs_zero]\n  letI := Ideal.fintypeQuotientOfFreeOfNeBot (span {r}) (mt span_singleton_eq_bot.mp hr)\n  let b := Module.Free.chooseBasis ℤ S\n  rw [← natAbs_det_equiv _ (b.equiv (basisSpanSingleton b hr) (Equiv.refl _))]\n  congr\n  refine b.ext fun i => ?_\n  simp\n\n"}
{"name":"Ideal.absNorm_dvd_norm_of_mem","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nI : Ideal S\nx : S\nh : Membership.mem I x\n⊢ Dvd.dvd (↑(Ideal.absNorm I)) ((Algebra.norm Int) x)","decl":"theorem absNorm_dvd_norm_of_mem {I : Ideal S} {x : S} (h : x ∈ I) :\n    ↑(Ideal.absNorm I) ∣ Algebra.norm ℤ x := by\n  rw [← Int.dvd_natAbs, ← absNorm_span_singleton x, Int.natCast_dvd_natCast]\n  exact absNorm_dvd_absNorm_of_le ((span_singleton_le_iff_mem _).mpr h)\n\n"}
{"name":"Ideal.absNorm_span_insert","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nr : S\ns : Set S\n⊢ Dvd.dvd (Ideal.absNorm (Ideal.span (Insert.insert r s))) (GCDMonoid.gcd (Ideal.absNorm (Ideal.span s)) ((Algebra.norm Int) r).natAbs)","decl":"@[simp]\ntheorem absNorm_span_insert (r : S) (s : Set S) :\n    absNorm (span (insert r s)) ∣ gcd (absNorm (span s)) (Algebra.norm ℤ r).natAbs :=\n  (dvd_gcd_iff _ _ _).mpr\n    ⟨absNorm_dvd_absNorm_of_le (span_mono (Set.subset_insert _ _)),\n      _root_.trans\n        (absNorm_dvd_absNorm_of_le (span_mono (Set.singleton_subset_iff.mpr (Set.mem_insert _ _))))\n        (by rw [absNorm_span_singleton])⟩\n\n"}
{"name":"Ideal.absNorm_eq_zero_iff","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nI : Ideal S\n⊢ Iff (Eq (Ideal.absNorm I) 0) (Eq I Bot.bot)","decl":"theorem absNorm_eq_zero_iff {I : Ideal S} : Ideal.absNorm I = 0 ↔ I = ⊥ := by\n  constructor\n  · intro hI\n    rw [← le_bot_iff]\n    intros x hx\n    rw [mem_bot, ← Algebra.norm_eq_zero_iff (R := ℤ), ← Int.natAbs_eq_zero,\n      ← Ideal.absNorm_span_singleton, ← zero_dvd_iff, ← hI]\n    apply Ideal.absNorm_dvd_absNorm_of_le\n    rwa [Ideal.span_singleton_le_iff_mem]\n  · rintro rfl\n    exact absNorm_bot\n\n"}
{"name":"Ideal.absNorm_ne_zero_iff_mem_nonZeroDivisors","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nI : Ideal S\n⊢ Iff (Ne (Ideal.absNorm I) 0) (Membership.mem (nonZeroDivisors (Ideal S)) I)","decl":"theorem absNorm_ne_zero_iff_mem_nonZeroDivisors {I : Ideal S} :\n    absNorm I ≠ 0 ↔ I ∈ (Ideal S)⁰ := by\n  simp_rw [ne_eq, Ideal.absNorm_eq_zero_iff, mem_nonZeroDivisors_iff_ne_zero, Submodule.zero_eq_bot]\n\n"}
{"name":"Ideal.absNorm_pos_iff_mem_nonZeroDivisors","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nI : Ideal S\n⊢ Iff (LT.lt 0 (Ideal.absNorm I)) (Membership.mem (nonZeroDivisors (Ideal S)) I)","decl":"theorem absNorm_pos_iff_mem_nonZeroDivisors {I : Ideal S} :\n    0 < absNorm I ↔ I ∈ (Ideal S)⁰ := by\n  rw [← absNorm_ne_zero_iff_mem_nonZeroDivisors, Nat.pos_iff_ne_zero]\n\n"}
{"name":"Ideal.absNorm_ne_zero_of_nonZeroDivisors","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal S)) x\n⊢ Ne (Ideal.absNorm ↑I) 0","decl":"theorem absNorm_ne_zero_of_nonZeroDivisors (I : (Ideal S)⁰) : absNorm (I : Ideal S) ≠ 0 :=\n  absNorm_ne_zero_iff_mem_nonZeroDivisors.mpr (SetLike.coe_mem I)\n\n"}
{"name":"Ideal.absNorm_pos_of_nonZeroDivisors","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nI : Subtype fun x => Membership.mem (nonZeroDivisors (Ideal S)) x\n⊢ LT.lt 0 (Ideal.absNorm ↑I)","decl":"theorem absNorm_pos_of_nonZeroDivisors (I : (Ideal S)⁰) : 0 < absNorm (I : Ideal S) :=\n  absNorm_pos_iff_mem_nonZeroDivisors.mpr (SetLike.coe_mem I)\n\n"}
{"name":"Ideal.finite_setOf_absNorm_eq","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁵ : CommRing S\ninst✝⁴ : Nontrivial S\ninst✝³ : IsDedekindDomain S\ninst✝² : Module.Free Int S\ninst✝¹ : Module.Finite Int S\ninst✝ : CharZero S\nn : Nat\n⊢ (setOf fun I => Eq (Ideal.absNorm I) n).Finite","decl":"theorem finite_setOf_absNorm_eq [CharZero S] (n : ℕ) :\n    {I : Ideal S | Ideal.absNorm I = n}.Finite := by\n  obtain hn | hn := Nat.eq_zero_or_pos n\n  · simp only [hn, absNorm_eq_zero_iff, Set.setOf_eq_eq_singleton, Set.finite_singleton]\n  · let f := fun I : Ideal S => Ideal.map (Ideal.Quotient.mk (@Ideal.span S _ {↑n})) I\n    refine Set.Finite.of_finite_image (f := f) ?_ ?_\n    · suffices Finite (S ⧸ @Ideal.span S _ {↑n}) by\n        let g := ((↑) : Ideal (S ⧸ @Ideal.span S _ {↑n}) → Set (S ⧸ @Ideal.span S _ {↑n}))\n        refine Set.Finite.of_finite_image (f := g) ?_ SetLike.coe_injective.injOn\n        exact Set.Finite.subset Set.finite_univ (Set.subset_univ _)\n      rw [← absNorm_ne_zero_iff, absNorm_span_singleton]\n      simpa only [Ne, Int.natAbs_eq_zero, Algebra.norm_eq_zero_iff, Nat.cast_eq_zero] using\n        ne_of_gt hn\n    · intro I hI J hJ h\n      rw [← comap_map_mk (span_singleton_absNorm_le I), ← hI.symm, ←\n        comap_map_mk (span_singleton_absNorm_le J), ← hJ.symm]\n      congr\n\n"}
{"name":"Ideal.finite_setOf_absNorm_le","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁵ : CommRing S\ninst✝⁴ : Nontrivial S\ninst✝³ : IsDedekindDomain S\ninst✝² : Module.Free Int S\ninst✝¹ : Module.Finite Int S\ninst✝ : CharZero S\nn : Nat\n⊢ (setOf fun I => LE.le (Ideal.absNorm I) n).Finite","decl":"theorem finite_setOf_absNorm_le [CharZero S] (n : ℕ) :\n    {I : Ideal S | Ideal.absNorm I ≤ n}.Finite := by\n  rw [show {I : Ideal S | Ideal.absNorm I ≤ n} =\n    (⋃ i ∈ Set.Icc 0 n, {I : Ideal S | Ideal.absNorm I = i}) by ext; simp]\n  refine Set.Finite.biUnion (Set.finite_Icc 0 n) (fun i _ => Ideal.finite_setOf_absNorm_eq i)\n\n"}
{"name":"Ideal.card_norm_le_eq_card_norm_le_add_one","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁵ : CommRing S\ninst✝⁴ : Nontrivial S\ninst✝³ : IsDedekindDomain S\ninst✝² : Module.Free Int S\ninst✝¹ : Module.Finite Int S\nn : Nat\ninst✝ : CharZero S\n⊢ Eq (Nat.card (Subtype fun I => LE.le (Ideal.absNorm I) n)) (HAdd.hAdd (Nat.card (Subtype fun I => LE.le (Ideal.absNorm ↑I) n)) 1)","decl":"theorem card_norm_le_eq_card_norm_le_add_one (n : ℕ) [CharZero S] :\n    Nat.card {I : Ideal S // absNorm I ≤ n} =\n      Nat.card {I : (Ideal S)⁰ // absNorm (I : Ideal S) ≤ n} + 1 := by\n  classical\n  have : Finite {I : Ideal S // I ∈ (Ideal S)⁰ ∧ absNorm I ≤ n} :=\n    (finite_setOf_absNorm_le n).subset fun _ ⟨_, h⟩ ↦ h\n  have : Finite {I : Ideal S // I ∉ (Ideal S)⁰ ∧ absNorm I ≤ n} :=\n    (finite_setOf_absNorm_le n).subset fun _ ⟨_, h⟩ ↦ h\n  rw [Nat.card_congr (Equiv.subtypeSubtypeEquivSubtypeInter (fun I ↦ I ∈ (Ideal S)⁰)\n    (fun I ↦ absNorm I ≤ n))]\n  let e : {I : Ideal S // absNorm I ≤ n} ≃ {I : Ideal S // I ∈ (Ideal S)⁰ ∧ absNorm I ≤ n} ⊕\n      {I : Ideal S // I ∉ (Ideal S)⁰ ∧ absNorm I ≤ n} := by\n    refine (Equiv.subtypeEquivRight ?_).trans (subtypeOrEquiv _ _ ?_)\n    · intro _\n      simp_rw [← or_and_right, em, true_and]\n    · exact Pi.disjoint_iff.mpr fun I ↦ Prop.disjoint_iff.mpr (by tauto)\n  simp_rw [Nat.card_congr e, Nat.card_sum, add_right_inj]\n  conv_lhs =>\n    enter [1, 1, I]\n    rw [← absNorm_ne_zero_iff_mem_nonZeroDivisors, ne_eq, not_not, and_iff_left_iff_imp.mpr\n      (fun h ↦ by rw [h]; exact Nat.zero_le n), absNorm_eq_zero_iff]\n  rw [Nat.card_unique]\n\n"}
{"name":"Ideal.norm_dvd_iff","module":"Mathlib.RingTheory.Ideal.Norm.AbsNorm","initialProofState":"S : Type u_1\ninst✝⁴ : CommRing S\ninst✝³ : Nontrivial S\ninst✝² : IsDedekindDomain S\ninst✝¹ : Module.Free Int S\ninst✝ : Module.Finite Int S\nx : S\nhx : Prime ((Algebra.norm Int) x)\ny : Int\n⊢ Iff (Dvd.dvd ((Algebra.norm Int) x) y) (Dvd.dvd x ↑y)","decl":"theorem norm_dvd_iff {x : S} (hx : Prime (Algebra.norm ℤ x)) {y : ℤ} :\n    Algebra.norm ℤ x ∣ y ↔ x ∣ y := by\n  rw [← Ideal.mem_span_singleton (y := x), ← eq_intCast (algebraMap ℤ S), ← Ideal.mem_comap,\n    ← Ideal.span_singleton_absNorm, Ideal.mem_span_singleton, Ideal.absNorm_span_singleton,\n    Int.natAbs_dvd]\n  rwa [Ideal.absNorm_span_singleton, ← Int.prime_iff_natAbs_prime]\n\n"}
