{"name":"IsChain.empty","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsChain r EmptyCollection.emptyCollection","decl":"@[simp] lemma IsChain.empty : IsChain r ∅ := pairwise_empty _\n"}
{"name":"IsChain.singleton","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\na : α\n⊢ IsChain r (Singleton.singleton a)","decl":"@[simp] lemma IsChain.singleton : IsChain r {a} := pairwise_singleton ..\n\n"}
{"name":"isChain_empty","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsChain r EmptyCollection.emptyCollection","decl":"@[deprecated (since := \"2024-11-25\")] alias isChain_empty := IsChain.empty\n\n"}
{"name":"Set.Subsingleton.isChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : s.Subsingleton\n⊢ IsChain r s","decl":"theorem Set.Subsingleton.isChain (hs : s.Subsingleton) : IsChain r s :=\n  hs.pairwise _\n\n"}
{"name":"IsChain.mono","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\na✝¹ : HasSubset.Subset s t\na✝ : IsChain r t\n⊢ IsChain r s","decl":"theorem IsChain.mono : s ⊆ t → IsChain r t → IsChain r s :=\n  Set.Pairwise.mono\n\n"}
{"name":"IsChain.mono_rel","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nr' : α → α → Prop\nh : IsChain r s\nh_imp : ∀ (x y : α), r x y → r' x y\n⊢ IsChain r' s","decl":"theorem IsChain.mono_rel {r' : α → α → Prop} (h : IsChain r s) (h_imp : ∀ x y, r x y → r' x y) :\n    IsChain r' s :=\n  h.mono' fun x y => Or.imp (h_imp x y) (h_imp y x)\n\n"}
{"name":"IsChain.symm","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nh : IsChain r s\n⊢ IsChain (flip r) s","decl":"/-- This can be used to turn `IsChain (≥)` into `IsChain (≤)` and vice-versa. -/\ntheorem IsChain.symm (h : IsChain r s) : IsChain (flip r) s :=\n  h.mono' fun _ _ => Or.symm\n\n"}
{"name":"isChain_of_trichotomous","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ninst✝ : IsTrichotomous α r\ns : Set α\n⊢ IsChain r s","decl":"theorem isChain_of_trichotomous [IsTrichotomous α r] (s : Set α) : IsChain r s :=\n  fun a _ b _ hab => (trichotomous_of r a b).imp_right fun h => h.resolve_left hab\n\n"}
{"name":"IsChain.insert","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\na : α\nhs : IsChain r s\nha : ∀ (b : α), Membership.mem s b → Ne a b → Or (r a b) (r b a)\n⊢ IsChain r (Insert.insert a s)","decl":"protected theorem IsChain.insert (hs : IsChain r s) (ha : ∀ b ∈ s, a ≠ b → a ≺ b ∨ b ≺ a) :\n    IsChain r (insert a s) :=\n  hs.insert_of_symmetric (fun _ _ => Or.symm) ha\n\n"}
{"name":"IsChain.pair","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\na b : α\nh : r a b\n⊢ IsChain r (Insert.insert a (Singleton.singleton b))","decl":"lemma IsChain.pair (h : r a b) : IsChain r {a, b} :=\n  IsChain.singleton.insert fun _ hb _ ↦ .inl <| (eq_of_mem_singleton hb).symm.recOn ‹_›\n\n"}
{"name":"isChain_univ_iff","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ Iff (IsChain r Set.univ) (IsTrichotomous α r)","decl":"theorem isChain_univ_iff : IsChain r (univ : Set α) ↔ IsTrichotomous α r := by\n  refine ⟨fun h => ⟨fun a b => ?_⟩, fun h => @isChain_of_trichotomous _ _ h univ⟩\n  rw [or_left_comm, or_iff_not_imp_left]\n  exact h trivial trivial\n\n"}
{"name":"IsChain.image","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\nf : α → β\nh : ∀ (x y : α), r x y → s (f x) (f y)\nc : Set α\nhrc : IsChain r c\n⊢ IsChain s (Set.image f c)","decl":"theorem IsChain.image (r : α → α → Prop) (s : β → β → Prop) (f : α → β)\n    (h : ∀ x y, r x y → s (f x) (f y)) {c : Set α} (hrc : IsChain r c) : IsChain s (f '' c) :=\n  fun _ ⟨_, ha₁, ha₂⟩ _ ⟨_, hb₁, hb₂⟩ =>\n  ha₂ ▸ hb₂ ▸ fun hxy => (hrc ha₁ hb₁ <| ne_of_apply_ne f hxy).imp (h _ _) (h _ _)\n\n"}
{"name":"isChain_union","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\n⊢ Iff (IsChain r (Union.union s t)) (And (IsChain r s) (And (IsChain r t) (∀ (a : α), Membership.mem s a → ∀ (b : α), Membership.mem t b → Ne a b → Or (r a b) (r b a))))","decl":"lemma isChain_union {s t : Set α} :\n    IsChain r (s ∪ t) ↔ IsChain r s ∧ IsChain r t ∧ ∀ a ∈ s, ∀ b ∈ t, a ≠ b → r a b ∨ r b a := by\n  rw [IsChain, IsChain, IsChain, pairwise_union_of_symmetric fun _ _ ↦ Or.symm]\n\n"}
{"name":"Monotone.isChain_image","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ns : Set α\nf : α → β\nhf : Monotone f\nhs : IsChain (fun x1 x2 => LE.le x1 x2) s\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) (Set.image f s)","decl":"lemma Monotone.isChain_image [Preorder α] [Preorder β] {s : Set α} {f : α → β}\n    (hf : Monotone f) (hs : IsChain (· ≤ ·) s) : IsChain (· ≤ ·) (f '' s) :=\n  hs.image _ _ _ (fun _ _ a ↦ hf a)\n\n"}
{"name":"Monotone.isChain_range","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : LinearOrder α\ninst✝ : Preorder β\nf : α → β\nhf : Monotone f\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) (Set.range f)","decl":"theorem Monotone.isChain_range [LinearOrder α] [Preorder β] {f : α → β} (hf : Monotone f) :\n    IsChain (· ≤ ·) (range f) := by\n  rw [← image_univ]\n  exact hf.isChain_image (isChain_of_trichotomous _)\n\n"}
{"name":"IsChain.lt_of_le","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Set α\nh : IsChain (fun x1 x2 => LE.le x1 x2) s\n⊢ IsChain (fun x1 x2 => LT.lt x1 x2) s","decl":"theorem IsChain.lt_of_le [PartialOrder α] {s : Set α} (h : IsChain (· ≤ ·) s) :\n    IsChain (· < ·) s := fun _a ha _b hb hne ↦\n  (h ha hb hne).imp hne.lt_of_le hne.lt_of_le'\n\n"}
{"name":"IsChain.total","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nx y : α\ninst✝ : IsRefl α r\nh : IsChain r s\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Or (r x y) (r y x)","decl":"theorem IsChain.total (h : IsChain r s) (hx : x ∈ s) (hy : y ∈ s) : x ≺ y ∨ y ≺ x :=\n  (eq_or_ne x y).elim (fun e => Or.inl <| e ▸ refl _) (h hx hy)\n\n"}
{"name":"IsChain.directedOn","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝ : IsRefl α r\nH : IsChain r s\n⊢ DirectedOn r s","decl":"theorem IsChain.directedOn (H : IsChain r s) : DirectedOn r s := fun x hx y hy =>\n  ((H.total hx hy).elim fun h => ⟨y, hy, h, refl _⟩) fun h => ⟨x, hx, refl _, h⟩\n\n"}
{"name":"IsChain.directed","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ninst✝ : IsRefl α r\nf : β → α\nc : Set β\nh : IsChain (Order.Preimage f r) c\n⊢ Directed r fun x => f ↑x","decl":"protected theorem IsChain.directed {f : β → α} {c : Set β} (h : IsChain (f ⁻¹'o r) c) :\n    Directed r fun x : { a : β // a ∈ c } => f x :=\n  fun ⟨a, ha⟩ ⟨b, hb⟩ =>\n    (by_cases fun hab : a = b => by\n      simp only [hab, exists_prop, and_self_iff, Subtype.exists]\n      exact ⟨b, hb, refl _⟩)\n    fun hab => ((h ha hb hab).elim fun h => ⟨⟨b, hb⟩, h, refl _⟩) fun h => ⟨⟨a, ha⟩, refl _, h⟩\n\n"}
{"name":"IsChain.exists3","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\ninst✝¹ : IsRefl α r\nhchain : IsChain r s\ninst✝ : IsTrans α r\na b c : α\nmem1 : Membership.mem s a\nmem2 : Membership.mem s b\nmem3 : Membership.mem s c\n⊢ Exists fun z => Exists fun x => And (r a z) (And (r b z) (r c z))","decl":"theorem IsChain.exists3 (hchain : IsChain r s) [IsTrans α r] {a b c} (mem1 : a ∈ s) (mem2 : b ∈ s)\n    (mem3 : c ∈ s) : ∃ (z : _) (_ : z ∈ s), r a z ∧ r b z ∧ r c z := by\n  rcases directedOn_iff_directed.mpr (IsChain.directed hchain) a mem1 b mem2 with ⟨z, mem4, H1, H2⟩\n  rcases directedOn_iff_directed.mpr (IsChain.directed hchain) z mem4 c mem3 with\n    ⟨z', mem5, H3, H4⟩\n  exact ⟨z', mem5, _root_.trans H1 H3, _root_.trans H2 H3, H4⟩\n\n"}
{"name":"IsChain.le_of_not_lt","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nhs : IsChain (fun x1 x2 => LE.le x1 x2) s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\nh : Not (LT.lt x y)\n⊢ LE.le y x","decl":"lemma IsChain.le_of_not_lt [Preorder α] (hs : IsChain (· ≤ ·) s)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) (h : ¬ x < y) : y ≤ x := by\n  cases hs.total hx hy with\n  | inr h' => exact h'\n  | inl h' => simpa [lt_iff_le_not_le, h'] using h\n\n"}
{"name":"IsChain.not_lt","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nhs : IsChain (fun x1 x2 => LE.le x1 x2) s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Iff (Not (LT.lt x y)) (LE.le y x)","decl":"lemma IsChain.not_lt [Preorder α] (hs : IsChain (· ≤ ·) s)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) : ¬ x < y ↔ y ≤ x :=\n  ⟨(hs.le_of_not_lt hx hy ·), fun h h' ↦ h'.not_le h⟩\n\n"}
{"name":"IsChain.lt_of_not_le","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nhs : IsChain (fun x1 x2 => LE.le x1 x2) s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\nh : Not (LE.le x y)\n⊢ LT.lt y x","decl":"lemma IsChain.lt_of_not_le [Preorder α] (hs : IsChain (· ≤ ·) s)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) (h : ¬ x ≤ y) : y < x :=\n  (hs.total hx hy).elim (h · |>.elim) (lt_of_le_not_le · h)\n\n"}
{"name":"IsChain.not_le","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ns : Set α\ninst✝ : Preorder α\nhs : IsChain (fun x1 x2 => LE.le x1 x2) s\nx y : α\nhx : Membership.mem s x\nhy : Membership.mem s y\n⊢ Iff (Not (LE.le x y)) (LT.lt y x)","decl":"lemma IsChain.not_le [Preorder α] (hs : IsChain (· ≤ ·) s)\n    {x y : α} (hx : x ∈ s) (hy : y ∈ s) : ¬ x ≤ y ↔ y < x :=\n  ⟨(hs.lt_of_not_le hx hy ·), fun h h' ↦ h'.not_lt h⟩\n\n"}
{"name":"IsMaxChain.isChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nh : IsMaxChain r s\n⊢ IsChain r s","decl":"theorem IsMaxChain.isChain (h : IsMaxChain r s) : IsChain r s :=\n  h.1\n\n"}
{"name":"IsMaxChain.not_superChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns t : Set α\nh : IsMaxChain r s\n⊢ Not (SuperChain r s t)","decl":"theorem IsMaxChain.not_superChain (h : IsMaxChain r s) : ¬SuperChain r s t := fun ht =>\n  ht.2.ne <| h.2 ht.1 ht.2.1\n\n"}
{"name":"IsMaxChain.bot_mem","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : LE α\ninst✝ : OrderBot α\nh : IsMaxChain (fun x1 x2 => LE.le x1 x2) s\n⊢ Membership.mem s Bot.bot","decl":"theorem IsMaxChain.bot_mem [LE α] [OrderBot α] (h : IsMaxChain (· ≤ ·) s) : ⊥ ∈ s :=\n  (h.2 (h.1.insert fun _ _ _ => Or.inl bot_le) <| subset_insert _ _).symm ▸ mem_insert _ _\n\n"}
{"name":"IsMaxChain.top_mem","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ns : Set α\ninst✝¹ : LE α\ninst✝ : OrderTop α\nh : IsMaxChain (fun x1 x2 => LE.le x1 x2) s\n⊢ Membership.mem s Top.top","decl":"theorem IsMaxChain.top_mem [LE α] [OrderTop α] (h : IsMaxChain (· ≤ ·) s) : ⊤ ∈ s :=\n  (h.2 (h.1.insert fun _ _ _ => Or.inr le_top) <| subset_insert _ _).symm ▸ mem_insert _ _\n\n"}
{"name":"IsMaxChain.image","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\nr : α → α → Prop\ns : β → β → Prop\ne : RelIso r s\nc : Set α\nhc : IsMaxChain r c\n⊢ IsMaxChain s (Set.image (⇑e) c)","decl":"lemma IsMaxChain.image {s : β → β → Prop} (e : r ≃r s) {c : Set α} (hc : IsMaxChain r c) :\n    IsMaxChain s (e '' c) where\n  left := hc.isChain.image _ _ _ fun _ _ ↦ by exact e.map_rel_iff.2\n  right t ht hf := by\n    rw [← e.coe_fn_toEquiv, ← e.toEquiv.eq_preimage_iff_image_eq, preimage_equiv_eq_image_symm]\n    exact hc.2 (ht.image _ _ _ fun _ _ ↦ by exact e.symm.map_rel_iff.2)\n      ((e.toEquiv.subset_symm_image _ _).2 hf)\n\n"}
{"name":"succChain_spec","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nh : Exists fun t => And (IsChain r s) (SuperChain r s t)\n⊢ SuperChain r s (SuccChain r s)","decl":"theorem succChain_spec (h : ∃ t, IsChain r s ∧ SuperChain r s t) :\n    SuperChain r s (SuccChain r s) := by\n  have : IsChain r s ∧ SuperChain r s h.choose := h.choose_spec\n  simpa [SuccChain, dif_pos, exists_and_left.mp h] using this.2\n\n"}
{"name":"IsChain.succ","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs : IsChain r s\n⊢ IsChain r (SuccChain r s)","decl":"open Classical in\ntheorem IsChain.succ (hs : IsChain r s) : IsChain r (SuccChain r s) :=\n  if h : ∃ t, IsChain r s ∧ SuperChain r s t then (succChain_spec h).1\n  else by\n    rw [exists_and_left] at h\n    simpa [SuccChain, dif_neg, h] using hs\n\n"}
{"name":"IsChain.superChain_succChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\nhs₁ : IsChain r s\nhs₂ : Not (IsMaxChain r s)\n⊢ SuperChain r s (SuccChain r s)","decl":"theorem IsChain.superChain_succChain (hs₁ : IsChain r s) (hs₂ : ¬IsMaxChain r s) :\n    SuperChain r s (SuccChain r s) := by\n  simp only [IsMaxChain, _root_.not_and, not_forall, exists_prop, exists_and_left] at hs₂\n  obtain ⟨t, ht, hst⟩ := hs₂ hs₁\n  exact succChain_spec ⟨t, hs₁, ht, ssubset_iff_subset_ne.2 hst⟩\n\n"}
{"name":"subset_succChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\ns : Set α\n⊢ HasSubset.Subset s (SuccChain r s)","decl":"open Classical in\ntheorem subset_succChain : s ⊆ SuccChain r s :=\n  if h : ∃ t, IsChain r s ∧ SuperChain r s t then (succChain_spec h).2.1\n  else by\n    rw [exists_and_left] at h\n    simp [SuccChain, dif_neg, h, Subset.rfl]\n\n"}
{"name":"ChainClosure.brecOn","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nmotive✝ : (a : Set α) → ChainClosure r a → Prop\na✝ : Set α\nx✝ : ChainClosure r a✝\nih✝ : ∀ (a : Set α) (x : ChainClosure r a), x.below → motive✝ a x\n⊢ motive✝ a✝ x✝","decl":"/-- Predicate for whether a set is reachable from `∅` using `SuccChain` and `⋃₀`. -/\ninductive ChainClosure (r : α → α → Prop) : Set α → Prop\n  | succ : ∀ {s}, ChainClosure r s → ChainClosure r (SuccChain r s)\n  | union : ∀ {s}, (∀ a ∈ s, ChainClosure r a) → ChainClosure r (⋃₀s)\n\n"}
{"name":"chainClosure_empty","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ ChainClosure r EmptyCollection.emptyCollection","decl":"theorem chainClosure_empty : ChainClosure r ∅ := by\n  have : ChainClosure r (⋃₀∅) := ChainClosure.union fun a h => (not_mem_empty _ h).elim\n  simpa using this\n\n"}
{"name":"chainClosure_maxChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ ChainClosure r (maxChain r)","decl":"theorem chainClosure_maxChain : ChainClosure r (maxChain r) :=\n  ChainClosure.union fun _ => id\n\n"}
{"name":"ChainClosure.total","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nc₁ c₂ : Set α\nhc₁ : ChainClosure r c₁\nhc₂ : ChainClosure r c₂\n⊢ Or (HasSubset.Subset c₁ c₂) (HasSubset.Subset c₂ c₁)","decl":"theorem ChainClosure.total (hc₁ : ChainClosure r c₁) (hc₂ : ChainClosure r c₂) :\n    c₁ ⊆ c₂ ∨ c₂ ⊆ c₁ :=\n  ((chainClosure_succ_total_aux hc₂) fun _ hc₃ => chainClosure_succ_total hc₃ hc₁).imp_left\n    subset_succChain.trans\n\n"}
{"name":"ChainClosure.succ_fixpoint","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nc₁ c₂ : Set α\nhc₁ : ChainClosure r c₁\nhc₂ : ChainClosure r c₂\nhc : Eq (SuccChain r c₂) c₂\n⊢ HasSubset.Subset c₁ c₂","decl":"theorem ChainClosure.succ_fixpoint (hc₁ : ChainClosure r c₁) (hc₂ : ChainClosure r c₂)\n    (hc : SuccChain r c₂ = c₂) : c₁ ⊆ c₂ := by\n  induction hc₁ with\n  | succ hc₁ h => exact (chainClosure_succ_total hc₁ hc₂ h).elim (fun h => h ▸ hc.subset) id\n  | union _ ih => exact sUnion_subset ih\n\n"}
{"name":"ChainClosure.succ_fixpoint_iff","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nc : Set α\nhc : ChainClosure r c\n⊢ Iff (Eq (SuccChain r c) c) (Eq c (maxChain r))","decl":"theorem ChainClosure.succ_fixpoint_iff (hc : ChainClosure r c) :\n    SuccChain r c = c ↔ c = maxChain r :=\n  ⟨fun h => (subset_sUnion_of_mem hc).antisymm <| chainClosure_maxChain.succ_fixpoint hc h,\n    fun h => subset_succChain.antisymm' <| (subset_sUnion_of_mem hc.succ).trans h.symm.subset⟩\n\n"}
{"name":"ChainClosure.isChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\nc : Set α\nhc : ChainClosure r c\n⊢ IsChain r c","decl":"theorem ChainClosure.isChain (hc : ChainClosure r c) : IsChain r c := by\n  induction hc with\n  | succ _ h => exact h.succ\n  | union hs h =>\n    exact fun c₁ ⟨t₁, ht₁, (hc₁ : c₁ ∈ t₁)⟩ c₂ ⟨t₂, ht₂, (hc₂ : c₂ ∈ t₂)⟩ hneq =>\n      ((hs _ ht₁).total <| hs _ ht₂).elim (fun ht => h t₂ ht₂ (ht hc₁) hc₂ hneq) fun ht =>\n        h t₁ ht₁ hc₁ (ht hc₂) hneq\n\n"}
{"name":"maxChain_spec","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nr : α → α → Prop\n⊢ IsMaxChain r (maxChain r)","decl":"/-- **Hausdorff's maximality principle**\n\nThere exists a maximal totally ordered set of `α`.\nNote that we do not require `α` to be partially ordered by `r`. -/\ntheorem maxChain_spec : IsMaxChain r (maxChain r) :=\n  by_contradiction fun h =>\n    let ⟨_, H⟩ := chainClosure_maxChain.isChain.superChain_succChain h\n    H.ne (chainClosure_maxChain.succ_fixpoint_iff.mpr rfl).symm\n\n"}
{"name":"Flag.mk.injEq","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_3\ninst✝ : LE α\ncarrier✝ : Set α\nChain'✝ : IsChain (fun x1 x2 => LE.le x1 x2) carrier✝\nmax_chain'✝ : ∀ ⦃s : Set α⦄, IsChain (fun x1 x2 => LE.le x1 x2) s → HasSubset.Subset carrier✝ s → Eq carrier✝ s\ncarrier : Set α\nChain' : IsChain (fun x1 x2 => LE.le x1 x2) carrier\nmax_chain' : ∀ ⦃s : Set α⦄, IsChain (fun x1 x2 => LE.le x1 x2) s → HasSubset.Subset carrier s → Eq carrier s\n⊢ Eq (Eq { carrier := carrier✝, Chain' := Chain'✝, max_chain' := max_chain'✝ } { carrier := carrier, Chain' := Chain', max_chain' := max_chain' }) (Eq carrier✝ carrier)","decl":"/-- The type of flags, aka maximal chains, of an order. -/\nstructure Flag (α : Type*) [LE α] where\n  /-- The `carrier` of a flag is the underlying set. -/\n  carrier : Set α\n  /-- By definition, a flag is a chain -/\n  Chain' : IsChain (· ≤ ·) carrier\n  /-- By definition, a flag is a maximal chain -/\n  max_chain' : ∀ ⦃s⦄, IsChain (· ≤ ·) s → carrier ⊆ s → carrier = s\n\n"}
{"name":"Flag.mk.inj","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_3\ninst✝ : LE α\ncarrier✝ : Set α\nChain'✝ : IsChain (fun x1 x2 => LE.le x1 x2) carrier✝\nmax_chain'✝ : ∀ ⦃s : Set α⦄, IsChain (fun x1 x2 => LE.le x1 x2) s → HasSubset.Subset carrier✝ s → Eq carrier✝ s\ncarrier : Set α\nChain' : IsChain (fun x1 x2 => LE.le x1 x2) carrier\nmax_chain' : ∀ ⦃s : Set α⦄, IsChain (fun x1 x2 => LE.le x1 x2) s → HasSubset.Subset carrier s → Eq carrier s\nx✝ : Eq { carrier := carrier✝, Chain' := Chain'✝, max_chain' := max_chain'✝ } { carrier := carrier, Chain' := Chain', max_chain' := max_chain' }\n⊢ Eq carrier✝ carrier","decl":"/-- The type of flags, aka maximal chains, of an order. -/\nstructure Flag (α : Type*) [LE α] where\n  /-- The `carrier` of a flag is the underlying set. -/\n  carrier : Set α\n  /-- By definition, a flag is a chain -/\n  Chain' : IsChain (· ≤ ·) carrier\n  /-- By definition, a flag is a maximal chain -/\n  max_chain' : ∀ ⦃s⦄, IsChain (· ≤ ·) s → carrier ⊆ s → carrier = s\n\n"}
{"name":"Flag.Chain'","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_3\ninst✝ : LE α\nself : Flag α\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) self.carrier","decl":"/-- The type of flags, aka maximal chains, of an order. -/\nstructure Flag (α : Type*) [LE α] where\n  /-- The `carrier` of a flag is the underlying set. -/\n  carrier : Set α\n  /-- By definition, a flag is a chain -/\n  Chain' : IsChain (· ≤ ·) carrier\n  /-- By definition, a flag is a maximal chain -/\n  max_chain' : ∀ ⦃s⦄, IsChain (· ≤ ·) s → carrier ⊆ s → carrier = s\n\n"}
{"name":"Flag.max_chain'","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_3\ninst✝ : LE α\nself : Flag α\ns : Set α\na✝¹ : IsChain (fun x1 x2 => LE.le x1 x2) s\na✝ : HasSubset.Subset self.carrier s\n⊢ Eq self.carrier s","decl":"/-- The type of flags, aka maximal chains, of an order. -/\nstructure Flag (α : Type*) [LE α] where\n  /-- The `carrier` of a flag is the underlying set. -/\n  carrier : Set α\n  /-- By definition, a flag is a chain -/\n  Chain' : IsChain (· ≤ ·) carrier\n  /-- By definition, a flag is a maximal chain -/\n  max_chain' : ∀ ⦃s⦄, IsChain (· ≤ ·) s → carrier ⊆ s → carrier = s\n\n"}
{"name":"Flag.mk.sizeOf_spec","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_3\ninst✝¹ : LE α\ninst✝ : SizeOf α\ncarrier : Set α\nChain' : IsChain (fun x1 x2 => LE.le x1 x2) carrier\nmax_chain' : ∀ ⦃s : Set α⦄, IsChain (fun x1 x2 => LE.le x1 x2) s → HasSubset.Subset carrier s → Eq carrier s\n⊢ Eq (SizeOf.sizeOf { carrier := carrier, Chain' := Chain', max_chain' := max_chain' }) 1","decl":"/-- The type of flags, aka maximal chains, of an order. -/\nstructure Flag (α : Type*) [LE α] where\n  /-- The `carrier` of a flag is the underlying set. -/\n  carrier : Set α\n  /-- By definition, a flag is a chain -/\n  Chain' : IsChain (· ≤ ·) carrier\n  /-- By definition, a flag is a maximal chain -/\n  max_chain' : ∀ ⦃s⦄, IsChain (· ≤ ·) s → carrier ⊆ s → carrier = s\n\n"}
{"name":"Flag.ext_iff","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Flag α\n⊢ Iff (Eq s t) (Eq ↑s ↑t)","decl":"@[ext]\ntheorem ext : (s : Set α) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"Flag.ext","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns t : Flag α\na✝ : Eq ↑s ↑t\n⊢ Eq s t","decl":"@[ext]\ntheorem ext : (s : Set α) = t → s = t :=\n  SetLike.ext'\n\n"}
{"name":"Flag.mem_coe_iff","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Flag α\na : α\n⊢ Iff (Membership.mem (↑s) a) (Membership.mem s a)","decl":"theorem mem_coe_iff : a ∈ (s : Set α) ↔ a ∈ s :=\n  Iff.rfl\n\n"}
{"name":"Flag.coe_mk","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Set α\nh₁ : IsChain (fun x1 x2 => LE.le x1 x2) s\nh₂ : ∀ ⦃s_1 : Set α⦄, IsChain (fun x1 x2 => LE.le x1 x2) s_1 → HasSubset.Subset s s_1 → Eq s s_1\n⊢ Eq (↑{ carrier := s, Chain' := h₁, max_chain' := h₂ }) s","decl":"@[simp]\ntheorem coe_mk (s : Set α) (h₁ h₂) : (mk s h₁ h₂ : Set α) = s :=\n  rfl\n\n"}
{"name":"Flag.mk_coe","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Flag α\n⊢ Eq { carrier := ↑s, Chain' := ⋯, max_chain' := ⋯ } s","decl":"@[simp]\ntheorem mk_coe (s : Flag α) : mk (s : Set α) s.Chain' s.max_chain' = s :=\n  ext rfl\n\n"}
{"name":"Flag.chain_le","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Flag α\n⊢ IsChain (fun x1 x2 => LE.le x1 x2) ↑s","decl":"theorem chain_le (s : Flag α) : IsChain (· ≤ ·) (s : Set α) :=\n  s.Chain'\n\n"}
{"name":"Flag.maxChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\ns : Flag α\n⊢ IsMaxChain (fun x1 x2 => LE.le x1 x2) ↑s","decl":"protected theorem maxChain (s : Flag α) : IsMaxChain (· ≤ ·) (s : Set α) :=\n  ⟨s.chain_le, s.max_chain'⟩\n\n"}
{"name":"Flag.top_mem","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : OrderTop α\ns : Flag α\n⊢ Membership.mem s Top.top","decl":"theorem top_mem [OrderTop α] (s : Flag α) : (⊤ : α) ∈ s :=\n  s.maxChain.top_mem\n\n"}
{"name":"Flag.bot_mem","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝¹ : LE α\ninst✝ : OrderBot α\ns : Flag α\n⊢ Membership.mem s Bot.bot","decl":"theorem bot_mem [OrderBot α] (s : Flag α) : (⊥ : α) ∈ s :=\n  s.maxChain.bot_mem\n\n"}
{"name":"Flag.coe_ofIsMaxChain","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : LE α\nc : Set α\nhc : IsMaxChain (fun x1 x2 => LE.le x1 x2) c\n⊢ Eq (↑(Flag.ofIsMaxChain c hc)) c","decl":"@[simp, norm_cast]\nlemma coe_ofIsMaxChain (c : Set α) (hc) : ofIsMaxChain c hc = c := rfl\n\n"}
{"name":"Flag.le_or_le","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na b : α\ns : Flag α\nha : Membership.mem s a\nhb : Membership.mem s b\n⊢ Or (LE.le a b) (LE.le b a)","decl":"protected theorem le_or_le (s : Flag α) (ha : a ∈ s) (hb : b ∈ s) : a ≤ b ∨ b ≤ a :=\n  s.chain_le.total ha hb\n\n"}
{"name":"Flag.mem_iff_forall_le_or_ge","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : Preorder α\na : α\ns : Flag α\n⊢ Iff (Membership.mem s a) (∀ ⦃b : α⦄, Membership.mem s b → Or (LE.le a b) (LE.le b a))","decl":"lemma mem_iff_forall_le_or_ge : a ∈ s ↔ ∀ ⦃b⦄, b ∈ s → a ≤ b ∨ b ≤ a :=\n  ⟨fun ha b => s.le_or_le ha, fun hb =>\n    of_not_not fun ha =>\n      Set.ne_insert_of_not_mem _ ‹_› <|\n        s.maxChain.2 (s.chain_le.insert fun c hc _ => hb hc) <| Set.subset_insert _ _⟩\n\n"}
{"name":"Flag.coe_map","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\ns : Flag α\n⊢ Eq (↑((Flag.map e) s)) (Set.image ⇑e ↑s)","decl":"@[simp, norm_cast] lemma coe_map (e : α ≃o β) (s : Flag α) : ↑(map e s) = e '' s := rfl\n\n"}
{"name":"Flag.symm_map","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\nβ : Type u_2\ninst✝¹ : Preorder α\ninst✝ : Preorder β\ne : OrderIso α β\n⊢ Eq (Flag.map e).symm (Flag.map e.symm)","decl":"@[simp] lemma symm_map (e : α ≃o β) : (map e).symm = map e.symm := rfl\n\n"}
{"name":"Flag.chain_lt","module":"Mathlib.Order.Chain","initialProofState":"α : Type u_1\ninst✝ : PartialOrder α\ns : Flag α\n⊢ IsChain (fun x1 x2 => LT.lt x1 x2) ↑s","decl":"theorem chain_lt (s : Flag α) : IsChain (· < ·) (s : Set α) := s.chain_le.lt_of_le\n\n"}
