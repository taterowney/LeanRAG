{"name":"Basis.ofRepr.sizeOf_spec","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : SizeOf ι\ninst✝¹ : SizeOf R\ninst✝ : SizeOf M\nrepr : LinearEquiv (RingHom.id R) M (Finsupp ι R)\n⊢ Eq (SizeOf.sizeOf { repr := repr }) (HAdd.hAdd 1 (SizeOf.sizeOf repr))","decl":"/-- A `Basis ι R M` for a module `M` is the type of `ι`-indexed `R`-bases of `M`.\n\nThe basis vectors are available as `DFunLike.coe (b : Basis ι R M) : ι → M`.\nTo turn a linear independent family of vectors spanning `M` into a basis, use `Basis.mk`.\nThey are internally represented as linear equivs `M ≃ₗ[R] (ι →₀ R)`,\navailable as `Basis.repr`.\n-/\nstructure Basis where\n  /-- `Basis.ofRepr` constructs a basis given an assignment of coordinates to each vector. -/\n  ofRepr ::\n    /-- `repr` is the linear equivalence sending a vector `x` to its coordinates:\n    the `c`s such that `x = ∑ i, c i`. -/\n    repr : M ≃ₗ[R] ι →₀ R\n\n"}
{"name":"Basis.ofRepr.inj","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nrepr✝ repr : LinearEquiv (RingHom.id R) M (Finsupp ι R)\nx✝ : Eq { repr := repr✝ } { repr := repr }\n⊢ Eq repr✝ repr","decl":"/-- A `Basis ι R M` for a module `M` is the type of `ι`-indexed `R`-bases of `M`.\n\nThe basis vectors are available as `DFunLike.coe (b : Basis ι R M) : ι → M`.\nTo turn a linear independent family of vectors spanning `M` into a basis, use `Basis.mk`.\nThey are internally represented as linear equivs `M ≃ₗ[R] (ι →₀ R)`,\navailable as `Basis.repr`.\n-/\nstructure Basis where\n  /-- `Basis.ofRepr` constructs a basis given an assignment of coordinates to each vector. -/\n  ofRepr ::\n    /-- `repr` is the linear equivalence sending a vector `x` to its coordinates:\n    the `c`s such that `x = ∑ i, c i`. -/\n    repr : M ≃ₗ[R] ι →₀ R\n\n"}
{"name":"Basis.ofRepr.injEq","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nrepr✝ repr : LinearEquiv (RingHom.id R) M (Finsupp ι R)\n⊢ Eq (Eq { repr := repr✝ } { repr := repr }) (Eq repr✝ repr)","decl":"/-- A `Basis ι R M` for a module `M` is the type of `ι`-indexed `R`-bases of `M`.\n\nThe basis vectors are available as `DFunLike.coe (b : Basis ι R M) : ι → M`.\nTo turn a linear independent family of vectors spanning `M` into a basis, use `Basis.mk`.\nThey are internally represented as linear equivs `M ≃ₗ[R] (ι →₀ R)`,\navailable as `Basis.repr`.\n-/\nstructure Basis where\n  /-- `Basis.ofRepr` constructs a basis given an assignment of coordinates to each vector. -/\n  ofRepr ::\n    /-- `repr` is the linear equivalence sending a vector `x` to its coordinates:\n    the `c`s such that `x = ∑ i, c i`. -/\n    repr : M ≃ₗ[R] ι →₀ R\n\n"}
{"name":"Basis.repr_injective","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\n⊢ Function.Injective Basis.repr","decl":"theorem repr_injective : Injective (repr : Basis ι R M → M ≃ₗ[R] ι →₀ R) := fun f g h => by\n  cases f; cases g; congr\n\n"}
{"name":"Basis.coe_ofRepr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ne : LinearEquiv (RingHom.id R) M (Finsupp ι R)\n⊢ Eq ⇑{ repr := e } fun i => e.symm (Finsupp.single i 1)","decl":"@[simp]\ntheorem coe_ofRepr (e : M ≃ₗ[R] ι →₀ R) : ⇑(ofRepr e) = fun i => e.symm (Finsupp.single i 1) :=\n  rfl\n\n"}
{"name":"Basis.injective","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\ninst✝ : Nontrivial R\n⊢ Function.Injective ⇑b","decl":"protected theorem injective [Nontrivial R] : Injective b :=\n  b.repr.symm.injective.comp fun _ _ => (Finsupp.single_left_inj (one_ne_zero : (1 : R) ≠ 0)).mp\n\n"}
{"name":"Basis.repr_symm_single_one","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\n⊢ Eq (b.repr.symm (Finsupp.single i 1)) (b i)","decl":"theorem repr_symm_single_one : b.repr.symm (Finsupp.single i 1) = b i :=\n  rfl\n\n"}
{"name":"Basis.repr_symm_single","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\nc : R\n⊢ Eq (b.repr.symm (Finsupp.single i c)) (HSMul.hSMul c (b i))","decl":"theorem repr_symm_single : b.repr.symm (Finsupp.single i c) = c • b i :=\n  calc\n    b.repr.symm (Finsupp.single i c) = b.repr.symm (c • Finsupp.single i (1 : R)) := by\n      { rw [Finsupp.smul_single', mul_one] }\n    _ = c • b i := by rw [LinearEquiv.map_smul, repr_symm_single_one]\n\n"}
{"name":"Basis.repr_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\n⊢ Eq (b.repr (b i)) (Finsupp.single i 1)","decl":"@[simp]\ntheorem repr_self : b.repr (b i) = Finsupp.single i 1 :=\n  LinearEquiv.apply_symm_apply _ _\n\n"}
{"name":"Basis.repr_self_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\ni j : ι\ninst✝ : Decidable (Eq i j)\n⊢ Eq ((b.repr (b i)) j) (ite (Eq i j) 1 0)","decl":"theorem repr_self_apply (j) [Decidable (i = j)] : b.repr (b i) j = if i = j then 1 else 0 := by\n  rw [repr_self, Finsupp.single_apply]\n\n"}
{"name":"Basis.repr_symm_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nv : Finsupp ι R\n⊢ Eq (b.repr.symm v) ((Finsupp.linearCombination R ⇑b) v)","decl":"@[simp]\ntheorem repr_symm_apply (v) : b.repr.symm v = Finsupp.linearCombination R b v :=\n  calc\n    b.repr.symm v = b.repr.symm (v.sum Finsupp.single) := by simp\n    _ = v.sum fun i vi => b.repr.symm (Finsupp.single i vi) := map_finsupp_sum ..\n    _ = Finsupp.linearCombination R b v := by simp only [repr_symm_single,\n                                                         Finsupp.linearCombination_apply]\n\n"}
{"name":"Basis.coe_repr_symm","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq (↑b.repr.symm) (Finsupp.linearCombination R ⇑b)","decl":"@[simp]\ntheorem coe_repr_symm : ↑b.repr.symm = Finsupp.linearCombination R b :=\n  LinearMap.ext fun v => b.repr_symm_apply v\n\n"}
{"name":"Basis.repr_linearCombination","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nv : Finsupp ι R\n⊢ Eq (b.repr ((Finsupp.linearCombination R ⇑b) v)) v","decl":"@[simp]\ntheorem repr_linearCombination (v) : b.repr (Finsupp.linearCombination _ b v) = v := by\n  rw [← b.coe_repr_symm]\n  exact b.repr.apply_symm_apply v\n\n"}
{"name":"Basis.repr_total","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nv : Finsupp ι R\n⊢ Eq (b.repr ((Finsupp.linearCombination R ⇑b) v)) v","decl":"@[deprecated (since := \"2024-08-29\")] alias repr_total := repr_linearCombination\n\n"}
{"name":"Basis.linearCombination_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\n⊢ Eq ((Finsupp.linearCombination R ⇑b) (b.repr x)) x","decl":"@[simp]\ntheorem linearCombination_repr : Finsupp.linearCombination _ b (b.repr x) = x := by\n  rw [← b.coe_repr_symm]\n  exact b.repr.symm_apply_apply x\n\n"}
{"name":"Basis.total_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\n⊢ Eq ((Finsupp.linearCombination R ⇑b) (b.repr x)) x","decl":"@[deprecated (since := \"2024-08-29\")] alias total_repr := linearCombination_repr\n\n"}
{"name":"Basis.repr_range","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq (LinearMap.range ↑b.repr) (Finsupp.supported R R Set.univ)","decl":"theorem repr_range : LinearMap.range (b.repr : M →ₗ[R] ι →₀ R) = Finsupp.supported R R univ := by\n  rw [LinearEquiv.range, Finsupp.supported_univ]\n\n"}
{"name":"Basis.mem_span_repr_support","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nm : M\n⊢ Membership.mem (Submodule.span R (Set.image ⇑b ↑(b.repr m).support)) m","decl":"theorem mem_span_repr_support (m : M) : m ∈ span R (b '' (b.repr m).support) :=\n  (Finsupp.mem_span_image_iff_linearCombination _).2\n    ⟨b.repr m, by simp [Finsupp.mem_supported_support]⟩\n\n"}
{"name":"Basis.repr_support_subset_of_mem_span","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ns : Set ι\nm : M\nhm : Membership.mem (Submodule.span R (Set.image (⇑b) s)) m\n⊢ HasSubset.Subset (↑(b.repr m).support) s","decl":"theorem repr_support_subset_of_mem_span (s : Set ι) {m : M}\n    (hm : m ∈ span R (b '' s)) : ↑(b.repr m).support ⊆ s := by\n  rcases (Finsupp.mem_span_image_iff_linearCombination _).1 hm with ⟨l, hl, rfl⟩\n  rwa [repr_linearCombination, ← Finsupp.mem_supported R l]\n\n"}
{"name":"Basis.mem_span_image","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nm : M\ns : Set ι\n⊢ Iff (Membership.mem (Submodule.span R (Set.image (⇑b) s)) m) (HasSubset.Subset (↑(b.repr m).support) s)","decl":"theorem mem_span_image {m : M} {s : Set ι} : m ∈ span R (b '' s) ↔ ↑(b.repr m).support ⊆ s :=\n  ⟨repr_support_subset_of_mem_span _ _, fun h ↦\n    span_mono (image_subset _ h) (mem_span_repr_support b _)⟩\n\n"}
{"name":"Basis.self_mem_span_image","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\ninst✝ : Nontrivial R\ni : ι\ns : Set ι\n⊢ Iff (Membership.mem (Submodule.span R (Set.image (⇑b) s)) (b i)) (Membership.mem s i)","decl":"@[simp]\ntheorem self_mem_span_image [Nontrivial R] {i : ι} {s : Set ι} :\n    b i ∈ span R (b '' s) ↔ i ∈ s := by\n  simp [mem_span_image, Finsupp.support_single_ne_zero]\n\n"}
{"name":"Basis.coord_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\na✝ : M\n⊢ Eq ((b.coord i) a✝) ((b.repr a✝) i)","decl":"/-- `b.coord i` is the linear function giving the `i`'th coordinate of a vector\nwith respect to the basis `b`.\n\n`b.coord i` is an element of the dual space. In particular, for\nfinite-dimensional spaces it is the `ι`th basis vector of the dual space.\n-/\n@[simps!]\ndef coord : M →ₗ[R] R :=\n  Finsupp.lapply i ∘ₗ ↑b.repr\n\n"}
{"name":"Basis.forall_coord_eq_zero_iff","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\n⊢ Iff (∀ (i : ι), Eq ((b.coord i) x) 0) (Eq x 0)","decl":"theorem forall_coord_eq_zero_iff {x : M} : (∀ i, b.coord i x = 0) ↔ x = 0 :=\n  Iff.trans (by simp only [b.coord_apply, DFunLike.ext_iff, Finsupp.zero_apply])\n    b.repr.map_eq_zero_iff\n\n"}
{"name":"Basis.coe_sumCoords","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq ⇑b.sumCoords fun m => (b.repr m).sum fun x => id","decl":"@[simp]\ntheorem coe_sumCoords : (b.sumCoords : M → R) = fun m => (b.repr m).sum fun _ => id :=\n  rfl\n\n"}
{"name":"Basis.coe_sumCoords_of_fintype","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\ninst✝ : Fintype ι\n⊢ Eq ⇑b.sumCoords ⇑(Finset.univ.sum fun i => b.coord i)","decl":"@[simp high]\ntheorem coe_sumCoords_of_fintype [Fintype ι] : (b.sumCoords : M → R) = ∑ i, b.coord i := by\n  ext m\n  -- Porting note: - `eq_self_iff_true`\n  --               + `comp_apply` `LinearMap.coeFn_sum`\n  simp only [sumCoords, Finsupp.sum_fintype, LinearMap.id_coe, LinearEquiv.coe_coe, coord_apply,\n    id, Fintype.sum_apply, imp_true_iff, Finsupp.coe_lsum, LinearMap.coe_comp, comp_apply,\n    LinearMap.coeFn_sum]\n\n"}
{"name":"Basis.sumCoords_self_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\n⊢ Eq (b.sumCoords (b i)) 1","decl":"@[simp]\ntheorem sumCoords_self_apply : b.sumCoords (b i) = 1 := by\n  simp only [Basis.sumCoords, LinearMap.id_coe, LinearEquiv.coe_coe, id, Basis.repr_self,\n    Function.comp_apply, Finsupp.coe_lsum, LinearMap.coe_comp, Finsupp.sum_single_index]\n\n"}
{"name":"Basis.dvd_coord_smul","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\nm : M\nr : R\n⊢ Dvd.dvd r ((b.coord i) (HSMul.hSMul r m))","decl":"theorem dvd_coord_smul (i : ι) (m : M) (r : R) : r ∣ b.coord i (r • m) :=\n  ⟨b.coord i m, by simp⟩\n\n"}
{"name":"Basis.coord_repr_symm","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\nf : Finsupp ι R\n⊢ Eq ((b.coord i) (b.repr.symm f)) (f i)","decl":"theorem coord_repr_symm (b : Basis ι R M) (i : ι) (f : ι →₀ R) :\n    b.coord i (b.repr.symm f) = f i := by\n  simp only [repr_symm_apply, coord_apply, repr_linearCombination]\n\n"}
{"name":"Basis.ext","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nb : Basis ι R M\nR₁ : Type u_10\ninst✝² : Semiring R₁\nσ : RingHom R R₁\nM₁ : Type u_11\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nf₁ f₂ : LinearMap σ M M₁\nh : ∀ (i : ι), Eq (f₁ (b i)) (f₂ (b i))\n⊢ Eq f₁ f₂","decl":"/-- Two linear maps are equal if they are equal on basis vectors. -/\ntheorem ext {f₁ f₂ : M →ₛₗ[σ] M₁} (h : ∀ i, f₁ (b i) = f₂ (b i)) : f₁ = f₂ := by\n  ext x\n  rw [← b.linearCombination_repr x, Finsupp.linearCombination_apply, Finsupp.sum]\n  simp only [map_sum, LinearMap.map_smulₛₗ, h]\n\n"}
{"name":"Basis.ext'","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\nb : Basis ι R M\nR₁ : Type u_10\ninst✝⁴ : Semiring R₁\nσ : RingHom R R₁\nσ' : RingHom R₁ R\ninst✝³ : RingHomInvPair σ σ'\ninst✝² : RingHomInvPair σ' σ\nM₁ : Type u_11\ninst✝¹ : AddCommMonoid M₁\ninst✝ : Module R₁ M₁\nf₁ f₂ : LinearEquiv σ M M₁\nh : ∀ (i : ι), Eq (f₁ (b i)) (f₂ (b i))\n⊢ Eq f₁ f₂","decl":"/-- Two linear equivs are equal if they are equal on basis vectors. -/\ntheorem ext' {f₁ f₂ : M ≃ₛₗ[σ] M₁} (h : ∀ i, f₁ (b i) = f₂ (b i)) : f₁ = f₂ := by\n  ext x\n  rw [← b.linearCombination_repr x, Finsupp.linearCombination_apply, Finsupp.sum]\n  simp only [map_sum, LinearEquiv.map_smulₛₗ, h]\n\n"}
{"name":"Basis.ext_elem_iff","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx y : M\n⊢ Iff (Eq x y) (∀ (i : ι), Eq ((b.repr x) i) ((b.repr y) i))","decl":"/-- Two elements are equal iff their coordinates are equal. -/\ntheorem ext_elem_iff {x y : M} : x = y ↔ ∀ i, b.repr x i = b.repr y i := by\n  simp only [← DFunLike.ext_iff, EmbeddingLike.apply_eq_iff_eq]\n\n"}
{"name":"Basis.ext_elem","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx y : M\na✝ : ∀ (i : ι), Eq ((b.repr x) i) ((b.repr y) i)\n⊢ Eq x y","decl":"alias ⟨_, _root_.Basis.ext_elem⟩ := ext_elem_iff\n\n"}
{"name":"Basis.repr_eq_iff","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nf : LinearMap (RingHom.id R) M (Finsupp ι R)\n⊢ Iff (Eq (↑b.repr) f) (∀ (i : ι), Eq (f (b i)) (Finsupp.single i 1))","decl":"theorem repr_eq_iff {b : Basis ι R M} {f : M →ₗ[R] ι →₀ R} :\n    ↑b.repr = f ↔ ∀ i, f (b i) = Finsupp.single i 1 :=\n  ⟨fun h i => h ▸ b.repr_self i, fun h => b.ext fun i => (b.repr_self i).trans (h i).symm⟩\n\n"}
{"name":"Basis.repr_eq_iff'","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M (Finsupp ι R)\n⊢ Iff (Eq b.repr f) (∀ (i : ι), Eq (f (b i)) (Finsupp.single i 1))","decl":"theorem repr_eq_iff' {b : Basis ι R M} {f : M ≃ₗ[R] ι →₀ R} :\n    b.repr = f ↔ ∀ i, f (b i) = Finsupp.single i 1 :=\n  ⟨fun h i => h ▸ b.repr_self i, fun h => b.ext' fun i => (b.repr_self i).trans (h i).symm⟩\n\n"}
{"name":"Basis.apply_eq_iff","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\ni : ι\n⊢ Iff (Eq (b i) x) (Eq (b.repr x) (Finsupp.single i 1))","decl":"theorem apply_eq_iff {b : Basis ι R M} {x : M} {i : ι} : b i = x ↔ b.repr x = Finsupp.single i 1 :=\n  ⟨fun h => h ▸ b.repr_self i, fun h => b.repr.injective ((b.repr_self i).trans h.symm)⟩\n\n"}
{"name":"Basis.repr_apply_eq","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nf : M → ι → R\nhadd : ∀ (x y : M), Eq (f (HAdd.hAdd x y)) (HAdd.hAdd (f x) (f y))\nhsmul : ∀ (c : R) (x : M), Eq (f (HSMul.hSMul c x)) (HSMul.hSMul c (f x))\nf_eq : ∀ (i : ι), Eq (f (b i)) ⇑(Finsupp.single i 1)\nx : M\ni : ι\n⊢ Eq ((b.repr x) i) (f x i)","decl":"/-- An unbundled version of `repr_eq_iff` -/\ntheorem repr_apply_eq (f : M → ι → R) (hadd : ∀ x y, f (x + y) = f x + f y)\n    (hsmul : ∀ (c : R) (x : M), f (c • x) = c • f x) (f_eq : ∀ i, f (b i) = Finsupp.single i 1)\n    (x : M) (i : ι) : b.repr x i = f x i := by\n  let f_i : M →ₗ[R] R :=\n    { toFun := fun x => f x i\n      -- Porting note (https://github.com/leanprover-community/mathlib4/issues/12129): additional beta reduction needed\n      map_add' := fun _ _ => by beta_reduce; rw [hadd, Pi.add_apply]\n      map_smul' := fun _ _ => by simp [hsmul, Pi.smul_apply] }\n  have : Finsupp.lapply i ∘ₗ ↑b.repr = f_i := by\n    refine b.ext fun j => ?_\n    show b.repr (b j) i = f (b j) i\n    rw [b.repr_self, f_eq]\n  calc\n    b.repr x i = f_i x := by\n      { rw [← this]\n        rfl }\n    _ = f x i := rfl\n\n"}
{"name":"Basis.eq_ofRepr_eq_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb₁ b₂ : Basis ι R M\nh : ∀ (x : M) (i : ι), Eq ((b₁.repr x) i) ((b₂.repr x) i)\n⊢ Eq b₁ b₂","decl":"/-- Two bases are equal if they assign the same coordinates. -/\ntheorem eq_ofRepr_eq_repr {b₁ b₂ : Basis ι R M} (h : ∀ x i, b₁.repr x i = b₂.repr x i) : b₁ = b₂ :=\n  repr_injective <| by ext; apply h\n\n"}
{"name":"Basis.eq_of_apply_eq_iff","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb₁ b₂ : Basis ι R M\n⊢ Iff (Eq b₁ b₂) (∀ (i : ι), Eq (b₁ i) (b₂ i))","decl":"/-- Two bases are equal if their basis vectors are the same. -/\n@[ext]\ntheorem eq_of_apply_eq {b₁ b₂ : Basis ι R M} : (∀ i, b₁ i = b₂ i) → b₁ = b₂ :=\n  DFunLike.ext _ _\n\n"}
{"name":"Basis.eq_of_apply_eq","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb₁ b₂ : Basis ι R M\na✝ : ∀ (i : ι), Eq (b₁ i) (b₂ i)\n⊢ Eq b₁ b₂","decl":"/-- Two bases are equal if their basis vectors are the same. -/\n@[ext]\ntheorem eq_of_apply_eq {b₁ b₂ : Basis ι R M} : (∀ i, b₁ i = b₂ i) → b₁ = b₂ :=\n  DFunLike.ext _ _\n\n"}
{"name":"Basis.map_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (b.map f).repr (f.symm.trans b.repr)","decl":"/-- Apply the linear equivalence `f` to the basis vectors. -/\n@[simps]\nprotected def map : Basis ι R M' :=\n  ofRepr (f.symm.trans b.repr)\n\n"}
{"name":"Basis.map_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M'\ni : ι\n⊢ Eq ((b.map f) i) (f (b i))","decl":"@[simp]\ntheorem map_apply (i) : b.map f i = f (b i) :=\n  rfl\n\n"}
{"name":"Basis.coe_map","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (⇑(b.map f)) (Function.comp ⇑f ⇑b)","decl":"theorem coe_map : (b.map f : ι → M') = f ∘ b :=\n  rfl\n\n"}
{"name":"Basis.smul_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nG : Type u_10\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M\ninst✝ : SMulCommClass G R M\ng : G\nb : Basis ι R M\ni : ι\n⊢ Eq ((HSMul.hSMul g b) i) (HSMul.hSMul g (b i))","decl":"@[simp]\ntheorem smul_apply (g : G) (b : Basis ι R M) (i : ι) : (g • b) i = g • b i := rfl\n\n"}
{"name":"Basis.coe_smul","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nG : Type u_10\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M\ninst✝ : SMulCommClass G R M\ng : G\nb : Basis ι R M\n⊢ Eq (⇑(HSMul.hSMul g b)) (HSMul.hSMul g ⇑b)","decl":"@[norm_cast] theorem coe_smul (g : G) (b : Basis ι R M) : ⇑(g • b) = g • ⇑b := rfl\n\n"}
{"name":"Basis.smul_eq_map","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\ng : LinearEquiv (RingHom.id R) M M\nb : Basis ι R M\n⊢ Eq (HSMul.hSMul g b) (b.map g)","decl":"/-- When the group in question is the automorphisms, `•` coincides with `Basis.map`. -/\n@[simp]\ntheorem smul_eq_map (g : M ≃ₗ[R] M) (b : Basis ι R M) : g • b = b.map g := rfl\n\n"}
{"name":"Basis.repr_smul","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\nG : Type u_10\ninst✝² : Group G\ninst✝¹ : DistribMulAction G M\ninst✝ : SMulCommClass G R M\ng : G\nb : Basis ι R M\n⊢ Eq (HSMul.hSMul g b).repr ((DistribMulAction.toLinearEquiv R M g).symm.trans b.repr)","decl":"@[simp] theorem repr_smul (g : G) (b : Basis ι R M) :\n    (g • b).repr = (DistribMulAction.toLinearEquiv _ _ g).symm.trans b.repr := rfl\n\n"}
{"name":"Basis.instSMulCommClass","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁹ : Semiring R\ninst✝⁸ : AddCommMonoid M\ninst✝⁷ : Module R M\nG : Type u_10\nG' : Type u_11\ninst✝⁶ : Group G\ninst✝⁵ : Group G'\ninst✝⁴ : DistribMulAction G M\ninst✝³ : DistribMulAction G' M\ninst✝² : SMulCommClass G R M\ninst✝¹ : SMulCommClass G' R M\ninst✝ : SMulCommClass G G' M\n⊢ SMulCommClass G G' (Basis ι R M)","decl":"instance [SMulCommClass G G' M] : SMulCommClass G G' (Basis ι R M) where\n  smul_comm _g _g' _b := DFunLike.ext _ _ fun _ => smul_comm _ _ _\n\n"}
{"name":"Basis.instIsScalarTower","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝¹⁰ : Semiring R\ninst✝⁹ : AddCommMonoid M\ninst✝⁸ : Module R M\nG : Type u_10\nG' : Type u_11\ninst✝⁷ : Group G\ninst✝⁶ : Group G'\ninst✝⁵ : DistribMulAction G M\ninst✝⁴ : DistribMulAction G' M\ninst✝³ : SMulCommClass G R M\ninst✝² : SMulCommClass G' R M\ninst✝¹ : SMul G G'\ninst✝ : IsScalarTower G G' M\n⊢ IsScalarTower G G' (Basis ι R M)","decl":"instance [SMul G G'] [IsScalarTower G G' M] : IsScalarTower G G' (Basis ι R M) where\n  smul_assoc _g _g' _b := DFunLike.ext _ _ fun _ => smul_assoc _ _ _\n\n"}
{"name":"Basis.mapCoeffs_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\nR' : Type u_10\ninst✝¹ : Semiring R'\ninst✝ : Module R' M\nf : RingEquiv R R'\nh : ∀ (c : R) (x : M), Eq (HSMul.hSMul (f c) x) (HSMul.hSMul c x)\n⊢ Eq (b.mapCoeffs f h).repr ((LinearEquiv.restrictScalars R' b.repr).trans (Finsupp.mapRange.linearEquiv (Module.compHom.toLinearEquiv f.symm).symm))","decl":"/-- If `R` and `R'` are isomorphic rings that act identically on a module `M`,\nthen a basis for `M` as `R`-module is also a basis for `M` as `R'`-module.\n\nSee also `Basis.algebraMapCoeffs` for the case where `f` is equal to `algebraMap`.\n-/\n@[simps (config := { simpRhs := true })]\ndef mapCoeffs (h : ∀ (c) (x : M), f c • x = c • x) : Basis ι R' M := by\n  letI : Module R' R := Module.compHom R (↑f.symm : R' →+* R)\n  haveI : IsScalarTower R' R M :=\n    { smul_assoc := fun x y z => by\n        -- Porting note: `dsimp [(· • ·)]` is unavailable because\n        --               `HSMul.hsmul` becomes `SMul.smul`.\n        change (f.symm x * y) • z = x • (y • z)\n        rw [mul_smul, ← h, f.apply_symm_apply] }\n  exact ofRepr <| (b.repr.restrictScalars R').trans <|\n    Finsupp.mapRange.linearEquiv (Module.compHom.toLinearEquiv f.symm).symm\n\n"}
{"name":"Basis.mapCoeffs_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\nR' : Type u_10\ninst✝¹ : Semiring R'\ninst✝ : Module R' M\nf : RingEquiv R R'\nh : ∀ (c : R) (x : M), Eq (HSMul.hSMul (f c) x) (HSMul.hSMul c x)\ni : ι\n⊢ Eq ((b.mapCoeffs f h) i) (b i)","decl":"theorem mapCoeffs_apply (i : ι) : b.mapCoeffs f h i = b i :=\n  apply_eq_iff.mpr <| by\n    -- Porting note: in Lean 3, these were automatically inferred from the definition of\n    -- `mapCoeffs`.\n    letI : Module R' R := Module.compHom R (↑f.symm : R' →+* R)\n    haveI : IsScalarTower R' R M :=\n    { smul_assoc := fun x y z => by\n        -- Porting note: `dsimp [(· • ·)]` is unavailable because\n        --               `HSMul.hsmul` becomes `SMul.smul`.\n        change (f.symm x * y) • z = x • (y • z)\n        rw [mul_smul, ← h, f.apply_symm_apply] }\n    simp\n\n"}
{"name":"Basis.coe_mapCoeffs","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\nR' : Type u_10\ninst✝¹ : Semiring R'\ninst✝ : Module R' M\nf : RingEquiv R R'\nh : ∀ (c : R) (x : M), Eq (HSMul.hSMul (f c) x) (HSMul.hSMul c x)\n⊢ Eq ⇑(b.mapCoeffs f h) ⇑b","decl":"@[simp]\ntheorem coe_mapCoeffs : (b.mapCoeffs f h : ι → M) = b :=\n  funext <| b.mapCoeffs_apply f h\n\n"}
{"name":"Basis.reindex_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ne : Equiv ι ι'\ni' : ι'\n⊢ Eq ((b.reindex e) i') (b (e.symm i'))","decl":"theorem reindex_apply (i' : ι') : b.reindex e i' = b (e.symm i') :=\n  show (b.repr.trans (Finsupp.domLCongr e)).symm (Finsupp.single i' 1) =\n    b.repr.symm (Finsupp.single (e.symm i') 1)\n  by rw [LinearEquiv.symm_trans_apply, Finsupp.domLCongr_symm, Finsupp.domLCongr_single]\n\n"}
{"name":"Basis.coe_reindex","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ne : Equiv ι ι'\n⊢ Eq (⇑(b.reindex e)) (Function.comp ⇑b ⇑e.symm)","decl":"@[simp]\ntheorem coe_reindex : (b.reindex e : ι' → M) = b ∘ e.symm :=\n  funext (b.reindex_apply e)\n\n"}
{"name":"Basis.repr_reindex_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\ne : Equiv ι ι'\ni' : ι'\n⊢ Eq (((b.reindex e).repr x) i') ((b.repr x) (e.symm i'))","decl":"theorem repr_reindex_apply (i' : ι') : (b.reindex e).repr x i' = b.repr x (e.symm i') :=\n  show (Finsupp.domLCongr e : _ ≃ₗ[R] _) (b.repr x) i' = _ by simp\n\n"}
{"name":"Basis.repr_reindex","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\ne : Equiv ι ι'\n⊢ Eq ((b.reindex e).repr x) (Finsupp.mapDomain (⇑e) (b.repr x))","decl":"@[simp]\ntheorem repr_reindex : (b.reindex e).repr x = (b.repr x).mapDomain e :=\n  DFunLike.ext _ _ <| by simp [repr_reindex_apply]\n\n"}
{"name":"Basis.reindex_refl","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq (b.reindex (Equiv.refl ι)) b","decl":"@[simp]\ntheorem reindex_refl : b.reindex (Equiv.refl ι) = b :=\n  eq_of_apply_eq fun i => by simp\n\n"}
{"name":"Basis.range_reindex","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ne : Equiv ι ι'\n⊢ Eq (Set.range ⇑(b.reindex e)) (Set.range ⇑b)","decl":"/-- `simp` can prove this as `Basis.coe_reindex` + `EquivLike.range_comp` -/\ntheorem range_reindex : Set.range (b.reindex e) = Set.range b := by\n  simp [coe_reindex, range_comp]\n\n"}
{"name":"Basis.sumCoords_reindex","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ne : Equiv ι ι'\n⊢ Eq (b.reindex e).sumCoords b.sumCoords","decl":"@[simp]\ntheorem sumCoords_reindex : (b.reindex e).sumCoords = b.sumCoords := by\n  ext x\n  simp only [coe_sumCoords, repr_reindex]\n  exact Finsupp.sum_mapDomain_index (fun _ => rfl) fun _ _ _ => rfl\n\n"}
{"name":"Basis.reindexRange_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\nh : optParam (Membership.mem (Set.range ⇑b) (b i)) ⋯\n⊢ Eq (b.reindexRange ⟨b i, h⟩) (b i)","decl":"theorem reindexRange_self (i : ι) (h := Set.mem_range_self i) : b.reindexRange ⟨b i, h⟩ = b i := by\n  by_cases htr : Nontrivial R\n  · letI := htr\n    simp [htr, reindexRange, reindex_apply, Equiv.apply_ofInjective_symm b.injective,\n      Subtype.coe_mk]\n  · letI : Subsingleton R := not_nontrivial_iff_subsingleton.mp htr\n    letI := Module.subsingleton R M\n    simp [reindexRange, eq_iff_true_of_subsingleton]\n\n"}
{"name":"Basis.reindexRange_repr_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\ni : ι\n⊢ Eq (b.reindexRange.repr (b i)) (Finsupp.single ⟨b i, ⋯⟩ 1)","decl":"theorem reindexRange_repr_self (i : ι) :\n    b.reindexRange.repr (b i) = Finsupp.single ⟨b i, mem_range_self i⟩ 1 :=\n  calc\n    b.reindexRange.repr (b i) = b.reindexRange.repr (b.reindexRange ⟨b i, mem_range_self i⟩) :=\n      congr_arg _ (b.reindexRange_self _ _).symm\n    _ = Finsupp.single ⟨b i, mem_range_self i⟩ 1 := b.reindexRange.repr_self _\n\n"}
{"name":"Basis.reindexRange_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : ↑(Set.range ⇑b)\n⊢ Eq (b.reindexRange x) ↑x","decl":"@[simp]\ntheorem reindexRange_apply (x : range b) : b.reindexRange x = x := by\n  rcases x with ⟨bi, ⟨i, rfl⟩⟩\n  exact b.reindexRange_self i\n\n"}
{"name":"Basis.reindexRange_repr'","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx bi : M\ni : ι\nh : Eq (b i) bi\n⊢ Eq ((b.reindexRange.repr x) ⟨bi, ⋯⟩) ((b.repr x) i)","decl":"theorem reindexRange_repr' (x : M) {bi : M} {i : ι} (h : b i = bi) :\n    b.reindexRange.repr x ⟨bi, ⟨i, h⟩⟩ = b.repr x i := by\n  nontriviality\n  subst h\n  apply (b.repr_apply_eq (fun x i => b.reindexRange.repr x ⟨b i, _⟩) _ _ _ x i).symm\n  · intro x y\n    ext i\n    simp only [Pi.add_apply, LinearEquiv.map_add, Finsupp.coe_add]\n  · intro c x\n    ext i\n    simp only [Pi.smul_apply, LinearEquiv.map_smul, Finsupp.coe_smul]\n  · intro i\n    ext j\n    simp only [reindexRange_repr_self]\n    apply Finsupp.single_apply_left (f := fun i => (⟨b i, _⟩ : Set.range b))\n    exact fun i j h => b.injective (Subtype.mk.inj h)\n\n"}
{"name":"Basis.reindexRange_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\ni : ι\nh : optParam (Membership.mem (Set.range ⇑b) (b i)) ⋯\n⊢ Eq ((b.reindexRange.repr x) ⟨b i, h⟩) ((b.repr x) i)","decl":"@[simp]\ntheorem reindexRange_repr (x : M) (i : ι) (h := Set.mem_range_self i) :\n    b.reindexRange.repr x ⟨b i, h⟩ = b.repr x i :=\n  b.reindexRange_repr' _ rfl\n\n"}
{"name":"Basis.reindexFinsetRange_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq M\ni : ι\nh : optParam (Membership.mem (Finset.image (⇑b) Finset.univ) (b i)) ⋯\n⊢ Eq (b.reindexFinsetRange ⟨b i, h⟩) (b i)","decl":"theorem reindexFinsetRange_self (i : ι) (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindexFinsetRange ⟨b i, h⟩ = b i := by\n  rw [reindexFinsetRange, reindex_apply, reindexRange_apply]\n  rfl\n\n"}
{"name":"Basis.reindexFinsetRange_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq M\nx : Subtype fun x => Membership.mem (Finset.image (⇑b) Finset.univ) x\n⊢ Eq (b.reindexFinsetRange x) ↑x","decl":"@[simp]\ntheorem reindexFinsetRange_apply (x : Finset.univ.image b) : b.reindexFinsetRange x = x := by\n  rcases x with ⟨bi, hbi⟩\n  rcases Finset.mem_image.mp hbi with ⟨i, -, rfl⟩\n  exact b.reindexFinsetRange_self i\n\n"}
{"name":"Basis.reindexFinsetRange_repr_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq M\ni : ι\n⊢ Eq (b.reindexFinsetRange.repr (b i)) (Finsupp.single ⟨b i, ⋯⟩ 1)","decl":"theorem reindexFinsetRange_repr_self (i : ι) :\n    b.reindexFinsetRange.repr (b i) =\n      Finsupp.single ⟨b i, Finset.mem_image_of_mem b (Finset.mem_univ i)⟩ 1 := by\n  ext ⟨bi, hbi⟩\n  rw [reindexFinsetRange, repr_reindex, Finsupp.mapDomain_equiv_apply, reindexRange_repr_self]\n  -- Porting note: replaced a `convert; refl` with `simp`\n  simp [Finsupp.single_apply]\n\n"}
{"name":"Basis.reindexFinsetRange_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\nb : Basis ι R M\ninst✝¹ : Fintype ι\ninst✝ : DecidableEq M\nx : M\ni : ι\nh : optParam (Membership.mem (Finset.image (⇑b) Finset.univ) (b i)) ⋯\n⊢ Eq ((b.reindexFinsetRange.repr x) ⟨b i, h⟩) ((b.repr x) i)","decl":"@[simp]\ntheorem reindexFinsetRange_repr (x : M) (i : ι)\n    (h := Finset.mem_image_of_mem b (Finset.mem_univ i)) :\n    b.reindexFinsetRange.repr x ⟨b i, h⟩ = b.repr x i := by simp [reindexFinsetRange]\n\n"}
{"name":"Basis.mem_span","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\nx : M\n⊢ Membership.mem (Submodule.span R (Set.range ⇑b)) x","decl":"protected theorem mem_span (x : M) : x ∈ span R (range b) :=\n  span_mono (image_subset_range _ _) (mem_span_repr_support b x)\n\n"}
{"name":"Basis.span_eq","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq (Submodule.span R (Set.range ⇑b)) Top.top","decl":"@[simp]\nprotected theorem span_eq : span R (range b) = ⊤ :=\n  eq_top_iff.mpr fun x _ => b.mem_span x\n\n"}
{"name":"Basis.index_nonempty","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\ninst✝ : Nontrivial M\n⊢ Nonempty ι","decl":"theorem index_nonempty (b : Basis ι R M) [Nontrivial M] : Nonempty ι := by\n  obtain ⟨x, y, ne⟩ : ∃ x y : M, x ≠ y := Nontrivial.exists_pair_ne\n  obtain ⟨i, _⟩ := not_forall.mp (mt b.ext_elem_iff.2 ne)\n  exact ⟨i⟩\n\n"}
{"name":"Basis.mem_submodule_iff","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nP : Submodule R M\nb : Basis ι R (Subtype fun x => Membership.mem P x)\nx : M\n⊢ Iff (Membership.mem P x) (Exists fun c => Eq x (c.sum fun i x => HSMul.hSMul x ↑(b i)))","decl":"/-- If the submodule `P` has a basis, `x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem mem_submodule_iff {P : Submodule R M} (b : Basis ι R P) {x : M} :\n    x ∈ P ↔ ∃ c : ι →₀ R, x = Finsupp.sum c fun i x => x • (b i : M) := by\n  conv_lhs =>\n    rw [← P.range_subtype, ← Submodule.map_top, ← b.span_eq, Submodule.map_span, ← Set.range_comp,\n        ← Finsupp.range_linearCombination]\n  simp [@eq_comm _ x, Function.comp, Finsupp.linearCombination_apply]\n\n"}
{"name":"Basis.constr_def","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\nf : ι → M'\n⊢ Eq ((b.constr S) f) ((Finsupp.linearCombination R id).comp ((Finsupp.lmapDomain R R f).comp ↑b.repr))","decl":"theorem constr_def (f : ι → M') :\n    constr (M' := M') b S f = linearCombination R id ∘ₗ Finsupp.lmapDomain R R f ∘ₗ ↑b.repr :=\n  rfl\n\n"}
{"name":"Basis.constr_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\nf : ι → M'\nx : M\n⊢ Eq (((b.constr S) f) x) ((b.repr x).sum fun b a => HSMul.hSMul a (f b))","decl":"theorem constr_apply (f : ι → M') (x : M) :\n    constr (M' := M') b S f x = (b.repr x).sum fun b a => a • f b := by\n  simp only [constr_def, LinearMap.comp_apply, lmapDomain_apply, linearCombination_apply]\n  rw [Finsupp.sum_mapDomain_index] <;> simp [add_smul]\n\n"}
{"name":"Basis.constr_basis","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\nf : ι → M'\ni : ι\n⊢ Eq (((b.constr S) f) (b i)) (f i)","decl":"@[simp]\ntheorem constr_basis (f : ι → M') (i : ι) : (constr (M' := M') b S f : M → M') (b i) = f i := by\n  simp [Basis.constr_apply, b.repr_self]\n\n"}
{"name":"Basis.constr_eq","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\ng : ι → M'\nf : LinearMap (RingHom.id R) M M'\nh : ∀ (i : ι), Eq (g i) (f (b i))\n⊢ Eq ((b.constr S) g) f","decl":"theorem constr_eq {g : ι → M'} {f : M →ₗ[R] M'} (h : ∀ i, g i = f (b i)) :\n    constr (M' := M') b S g = f :=\n  b.ext fun i => (b.constr_basis S g i).trans (h i)\n\n"}
{"name":"Basis.constr_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\nf : LinearMap (RingHom.id R) M M'\n⊢ Eq ((b.constr S) fun i => f (b i)) f","decl":"theorem constr_self (f : M →ₗ[R] M') : (constr (M' := M') b S fun i => f (b i)) = f :=\n  b.constr_eq S fun _ => rfl\n\n"}
{"name":"Basis.constr_range","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\nf : ι → M'\n⊢ Eq (LinearMap.range ((b.constr S) f)) (Submodule.span R (Set.range f))","decl":"theorem constr_range {f : ι → M'} :\n    LinearMap.range (constr (M' := M') b S f) = span R (range f) := by\n  rw [b.constr_def S f, LinearMap.range_comp, LinearMap.range_comp, LinearEquiv.range, ←\n    Finsupp.supported_univ, Finsupp.lmapDomain_supported, ← Set.image_univ, ←\n    Finsupp.span_image_eq_map_linearCombination, Set.image_id]\n\n"}
{"name":"Basis.constr_comp","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁷ : Semiring R\ninst✝⁶ : AddCommMonoid M\ninst✝⁵ : Module R M\ninst✝⁴ : AddCommMonoid M'\ninst✝³ : Module R M'\nb : Basis ι R M\nS : Type u_10\ninst✝² : Semiring S\ninst✝¹ : Module S M'\ninst✝ : SMulCommClass R S M'\nf : LinearMap (RingHom.id R) M' M'\nv : ι → M'\n⊢ Eq ((b.constr S) (Function.comp (⇑f) v)) (f.comp ((b.constr S) v))","decl":"@[simp]\ntheorem constr_comp (f : M' →ₗ[R] M') (v : ι → M') :\n    constr (M' := M') b S (f ∘ v) = f.comp (constr (M' := M') b S v) :=\n  b.ext fun i => by simp only [Basis.constr_basis, LinearMap.comp_apply, Function.comp]\n\n"}
{"name":"Basis.equiv_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\ni : ι\nb' : Basis ι' R M'\ne : Equiv ι ι'\n⊢ Eq ((b.equiv b' e) (b i)) (b' (e i))","decl":"@[simp]\ntheorem equiv_apply : b.equiv b' e (b i) = b' (e i) := by simp [Basis.equiv]\n\n"}
{"name":"Basis.equiv_refl","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝² : Semiring R\ninst✝¹ : AddCommMonoid M\ninst✝ : Module R M\nb : Basis ι R M\n⊢ Eq (b.equiv b (Equiv.refl ι)) (LinearEquiv.refl R M)","decl":"@[simp]\ntheorem equiv_refl : b.equiv b (Equiv.refl ι) = LinearEquiv.refl R M :=\n  b.ext' fun i => by simp\n\n"}
{"name":"Basis.equiv_symm","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ne : Equiv ι ι'\n⊢ Eq (b.equiv b' e).symm (b'.equiv b e.symm)","decl":"@[simp]\ntheorem equiv_symm : (b.equiv b' e).symm = b'.equiv b e.symm :=\n  b'.ext' fun i => (b.equiv b' e).injective (by simp)\n\n"}
{"name":"Basis.equiv_trans","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\nM' : Type u_7\nM'' : Type u_8\ninst✝⁶ : Semiring R\ninst✝⁵ : AddCommMonoid M\ninst✝⁴ : Module R M\ninst✝³ : AddCommMonoid M'\ninst✝² : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ninst✝¹ : AddCommMonoid M''\ninst✝ : Module R M''\nι'' : Type u_10\nb'' : Basis ι'' R M''\ne : Equiv ι ι'\ne' : Equiv ι' ι''\n⊢ Eq ((b.equiv b' e).trans (b'.equiv b'' e')) (b.equiv b'' (e.trans e'))","decl":"@[simp]\ntheorem equiv_trans {ι'' : Type*} (b'' : Basis ι'' R M'') (e : ι ≃ ι') (e' : ι' ≃ ι'') :\n    (b.equiv b' e).trans (b'.equiv b'' e') = b.equiv b'' (e.trans e') :=\n  b.ext' fun i => by simp\n\n"}
{"name":"Basis.map_equiv","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\ne : Equiv ι ι'\n⊢ Eq (b.map (b.equiv b' e)) (b'.reindex e.symm)","decl":"@[simp]\ntheorem map_equiv (b : Basis ι R M) (b' : Basis ι' R M') (e : ι ≃ ι') :\n    b.map (b.equiv b' e) = b'.reindex e.symm := by\n  ext i\n  simp\n\n"}
{"name":"Basis.singleton_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_10\nR : Type u_11\ninst✝¹ : Unique ι\ninst✝ : Semiring R\ni : ι\n⊢ Eq ((Basis.singleton ι R) i) 1","decl":"@[simp]\ntheorem singleton_apply (ι R : Type*) [Unique ι] [Semiring R] (i) : Basis.singleton ι R i = 1 :=\n  apply_eq_iff.mpr (by simp [Basis.singleton])\n\n"}
{"name":"Basis.singleton_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_10\nR : Type u_11\ninst✝¹ : Unique ι\ninst✝ : Semiring R\nx : R\ni : ι\n⊢ Eq (((Basis.singleton ι R).repr x) i) x","decl":"@[simp]\ntheorem singleton_repr (ι R : Type*) [Unique ι] [Semiring R] (x i) :\n    (Basis.singleton ι R).repr x i = x := by simp [Basis.singleton, Unique.eq_default i]\n\n"}
{"name":"Module.card_fintype","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : Fintype ι\nb : Basis ι R M\ninst✝¹ : Fintype R\ninst✝ : Fintype M\n⊢ Eq (Fintype.card M) (HPow.hPow (Fintype.card R) (Fintype.card ι))","decl":"theorem Module.card_fintype [Fintype ι] (b : Basis ι R M) [Fintype R] [Fintype M] :\n    card M = card R ^ card ι := by\n  classical\n    calc\n      card M = card (ι → R) := card_congr b.equivFun.toEquiv\n      _ = card R ^ card ι := card_fun\n\n"}
{"name":"Basis.equivFun_symm_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\nb : Basis ι R M\nx : ι → R\n⊢ Eq (b.equivFun.symm x) (Finset.univ.sum fun i => HSMul.hSMul (x i) (b i))","decl":"/-- Given a basis `v` indexed by `ι`, the canonical linear equivalence between `ι → R` and `M` maps\na function `x : ι → R` to the linear combination `∑_i x i • v i`. -/\n@[simp]\ntheorem Basis.equivFun_symm_apply [Fintype ι] (b : Basis ι R M) (x : ι → R) :\n    b.equivFun.symm x = ∑ i, x i • b i := by\n  simp [Basis.equivFun, Finsupp.linearCombination_apply, sum_fintype, equivFunOnFinite]\n\n"}
{"name":"Basis.equivFun_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite ι\nb : Basis ι R M\nu : M\n⊢ Eq (b.equivFun u) ⇑(b.repr u)","decl":"@[simp]\ntheorem Basis.equivFun_apply [Finite ι] (b : Basis ι R M) (u : M) : b.equivFun u = b.repr u :=\n  rfl\n\n"}
{"name":"Basis.map_equivFun","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁵ : Semiring R\ninst✝⁴ : AddCommMonoid M\ninst✝³ : Module R M\ninst✝² : AddCommMonoid M'\ninst✝¹ : Module R M'\ninst✝ : Finite ι\nb : Basis ι R M\nf : LinearEquiv (RingHom.id R) M M'\n⊢ Eq (b.map f).equivFun (f.symm.trans b.equivFun)","decl":"@[simp]\ntheorem Basis.map_equivFun [Finite ι] (b : Basis ι R M) (f : M ≃ₗ[R] M') :\n    (b.map f).equivFun = f.symm.trans b.equivFun :=\n  rfl\n\n"}
{"name":"Basis.sum_equivFun","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\nb : Basis ι R M\nu : M\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul (b.equivFun u i) (b i)) u","decl":"theorem Basis.sum_equivFun [Fintype ι] (b : Basis ι R M) (u : M) :\n    ∑ i, b.equivFun u i • b i = u := by\n  rw [← b.equivFun_symm_apply, b.equivFun.symm_apply_apply]\n\n"}
{"name":"Basis.sum_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\nb : Basis ι R M\nu : M\n⊢ Eq (Finset.univ.sum fun i => HSMul.hSMul ((b.repr u) i) (b i)) u","decl":"theorem Basis.sum_repr [Fintype ι] (b : Basis ι R M) (u : M) : ∑ i, b.repr u i • b i = u :=\n  b.sum_equivFun u\n\n"}
{"name":"Basis.equivFun_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\nb : Basis ι R M\ni j : ι\n⊢ Eq (b.equivFun (b i) j) (ite (Eq i j) 1 0)","decl":"@[simp]\ntheorem Basis.equivFun_self [Finite ι] [DecidableEq ι] (b : Basis ι R M) (i j : ι) :\n    b.equivFun (b i) j = if i = j then 1 else 0 := by rw [b.equivFun_apply, b.repr_self_apply]\n\n"}
{"name":"Basis.repr_sum_self","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\nb : Basis ι R M\nc : ι → R\n⊢ Eq (⇑(b.repr (Finset.univ.sum fun i => HSMul.hSMul (c i) (b i)))) c","decl":"theorem Basis.repr_sum_self [Fintype ι] (b : Basis ι R M) (c : ι → R) :\n    b.repr (∑ i, c i • b i) = c := by\n  simp_rw [← b.equivFun_symm_apply, ← b.equivFun_apply, b.equivFun.apply_symm_apply]\n\n"}
{"name":"Basis.ofEquivFun_repr_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite ι\ne : LinearEquiv (RingHom.id R) M (ι → R)\nx : M\ni : ι\n⊢ Eq (((Basis.ofEquivFun e).repr x) i) (e x i)","decl":"@[simp]\ntheorem Basis.ofEquivFun_repr_apply [Finite ι] (e : M ≃ₗ[R] ι → R) (x : M) (i : ι) :\n    (Basis.ofEquivFun e).repr x i = e x i :=\n  rfl\n\n"}
{"name":"Basis.coe_ofEquivFun","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝⁴ : Semiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : Finite ι\ninst✝ : DecidableEq ι\ne : LinearEquiv (RingHom.id R) M (ι → R)\n⊢ Eq ⇑(Basis.ofEquivFun e) fun i => e.symm (Pi.single i 1)","decl":"@[simp]\ntheorem Basis.coe_ofEquivFun [Finite ι] [DecidableEq ι] (e : M ≃ₗ[R] ι → R) :\n    (Basis.ofEquivFun e : ι → M) = fun i => e.symm (Pi.single i 1) :=\n  funext fun i =>\n    e.injective <|\n      funext fun j => by\n        simp [Basis.ofEquivFun, ← Finsupp.single_eq_pi_single]\n\n"}
{"name":"Basis.ofEquivFun_equivFun","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite ι\nv : Basis ι R M\n⊢ Eq (Basis.ofEquivFun v.equivFun) v","decl":"@[simp]\ntheorem Basis.ofEquivFun_equivFun [Finite ι] (v : Basis ι R M) :\n    Basis.ofEquivFun v.equivFun = v :=\n  Basis.repr_injective <| by ext; rfl\n\n"}
{"name":"Basis.equivFun_ofEquivFun","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite ι\ne : LinearEquiv (RingHom.id R) M (ι → R)\n⊢ Eq (Basis.ofEquivFun e).equivFun e","decl":"@[simp]\ntheorem Basis.equivFun_ofEquivFun [Finite ι] (e : M ≃ₗ[R] ι → R) :\n    (Basis.ofEquivFun e).equivFun = e := by\n  ext j\n  simp_rw [Basis.equivFun_apply, Basis.ofEquivFun_repr_apply]\n\n"}
{"name":"Basis.constr_apply_fintype","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁸ : Semiring R\ninst✝⁷ : AddCommMonoid M\ninst✝⁶ : Module R M\ninst✝⁵ : AddCommMonoid M'\ninst✝⁴ : Module R M'\nS : Type u_10\ninst✝³ : Semiring S\ninst✝² : Module S M'\ninst✝¹ : SMulCommClass R S M'\ninst✝ : Fintype ι\nb : Basis ι R M\nf : ι → M'\nx : M\n⊢ Eq (((b.constr S) f) x) (Finset.univ.sum fun i => HSMul.hSMul (b.equivFun x i) (f i))","decl":"@[simp]\ntheorem Basis.constr_apply_fintype [Fintype ι] (b : Basis ι R M) (f : ι → M') (x : M) :\n    (constr (M' := M') b S f : M → M') x = ∑ i, b.equivFun x i • f i := by\n  simp [b.constr_apply, b.equivFun_apply, Finsupp.sum_fintype]\n\n"}
{"name":"Basis.mem_submodule_iff'","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Fintype ι\nP : Submodule R M\nb : Basis ι R (Subtype fun x => Membership.mem P x)\nx : M\n⊢ Iff (Membership.mem P x) (Exists fun c => Eq x (Finset.univ.sum fun i => HSMul.hSMul (c i) ↑(b i)))","decl":"/-- If the submodule `P` has a finite basis,\n`x ∈ P` iff it is a linear combination of basis vectors. -/\ntheorem Basis.mem_submodule_iff' [Fintype ι] {P : Submodule R M} (b : Basis ι R P) {x : M} :\n    x ∈ P ↔ ∃ c : ι → R, x = ∑ i, c i • (b i : M) :=\n  b.mem_submodule_iff.trans <|\n    Finsupp.equivFunOnFinite.exists_congr_left.trans <|\n      exists_congr fun c => by simp [Finsupp.sum_fintype, Finsupp.equivFunOnFinite]\n\n"}
{"name":"Basis.coord_equivFun_symm","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : Semiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\ninst✝ : Finite ι\nb : Basis ι R M\ni : ι\nf : ι → R\n⊢ Eq ((b.coord i) (b.equivFun.symm f)) (f i)","decl":"theorem Basis.coord_equivFun_symm [Finite ι] (b : Basis ι R M) (i : ι) (f : ι → R) :\n    b.coord i (b.equivFun.symm f) = f i :=\n  b.coord_repr_symm i (Finsupp.equivFunOnFinite.symm f)\n\n"}
{"name":"Basis.equiv'_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\nf : M → M'\ng : M' → M\nhf : ∀ (i : ι), Membership.mem (Set.range ⇑b') (f (b i))\nhg : ∀ (i : ι'), Membership.mem (Set.range ⇑b) (g (b' i))\nhgf : ∀ (i : ι), Eq (g (f (b i))) (b i)\nhfg : ∀ (i : ι'), Eq (f (g (b' i))) (b' i)\ni : ι\n⊢ Eq ((b.equiv' b' f g hf hg hgf hfg) (b i)) (f (b i))","decl":"@[simp]\ntheorem equiv'_apply (f : M → M') (g : M' → M) (hf hg hgf hfg) (i : ι) :\n    b.equiv' b' f g hf hg hgf hfg (b i) = f (b i) :=\n  b.constr_basis R _ _\n\n"}
{"name":"Basis.equiv'_symm_apply","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nι' : Type u_2\nR : Type u_3\nM : Type u_6\nM' : Type u_7\ninst✝⁴ : CommSemiring R\ninst✝³ : AddCommMonoid M\ninst✝² : Module R M\ninst✝¹ : AddCommMonoid M'\ninst✝ : Module R M'\nb : Basis ι R M\nb' : Basis ι' R M'\nf : M → M'\ng : M' → M\nhf : ∀ (i : ι), Membership.mem (Set.range ⇑b') (f (b i))\nhg : ∀ (i : ι'), Membership.mem (Set.range ⇑b) (g (b' i))\nhgf : ∀ (i : ι), Eq (g (f (b i))) (b i)\nhfg : ∀ (i : ι'), Eq (f (g (b' i))) (b' i)\ni : ι'\n⊢ Eq ((b.equiv' b' f g hf hg hgf hfg).symm (b' i)) (g (b' i))","decl":"@[simp]\ntheorem equiv'_symm_apply (f : M → M') (g : M' → M) (hf hg hgf hfg) (i : ι') :\n    (b.equiv' b' f g hf hg hgf hfg).symm (b' i) = g (b' i) :=\n  b'.constr_basis R _ _\n\n"}
{"name":"Basis.sum_repr_mul_repr","module":"Mathlib.LinearAlgebra.Basis.Defs","initialProofState":"ι : Type u_1\nR : Type u_3\nM : Type u_6\ninst✝³ : CommSemiring R\ninst✝² : AddCommMonoid M\ninst✝¹ : Module R M\nb : Basis ι R M\nι' : Type u_10\ninst✝ : Fintype ι'\nb' : Basis ι' R M\nx : M\ni : ι\n⊢ Eq (Finset.univ.sum fun j => HMul.hMul ((b.repr (b' j)) i) ((b'.repr x) j)) ((b.repr x) i)","decl":"theorem sum_repr_mul_repr {ι'} [Fintype ι'] (b' : Basis ι' R M) (x : M) (i : ι) :\n    (∑ j : ι', b.repr (b' j) i * b'.repr x j) = b.repr x i := by\n  conv_rhs => rw [← b'.sum_repr x]\n  simp_rw [map_sum, map_smul, Finset.sum_apply']\n  refine Finset.sum_congr rfl fun j _ => ?_\n  rw [Finsupp.smul_apply, smul_eq_mul, mul_comm]\n\n"}
