{"name":"ax_grothendieck_of_locally_finite","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"ι : Type u_1\nK : Type u_2\nR : Type u_3\ninst✝⁴ : Field K\ninst✝³ : Finite K\ninst✝² : CommRing R\ninst✝¹ : Finite ι\ninst✝ : Algebra K R\nalg : Algebra.IsAlgebraic K R\nps : ι → MvPolynomial ι R\nS : Set (ι → R)\nhm : Set.MapsTo (fun v i => (MvPolynomial.eval v) (ps i)) S S\nhinj : Set.InjOn (fun v i => (MvPolynomial.eval v) (ps i)) S\n⊢ Set.SurjOn (fun v i => (MvPolynomial.eval v) (ps i)) S S","decl":"/-- Any injective polynomial map over an algebraic extension of a finite field is surjective. -/\ntheorem ax_grothendieck_of_locally_finite {ι K R : Type*} [Field K] [Finite K] [CommRing R]\n    [Finite ι] [Algebra K R] [alg : Algebra.IsAlgebraic K R] (ps : ι → MvPolynomial ι R)\n    (S : Set (ι → R))\n    (hm : S.MapsTo (fun v i => eval v (ps i)) S)\n    (hinj : S.InjOn (fun v i => eval v (ps i))) :\n    S.SurjOn (fun v i => eval v (ps i)) S := by\n  have is_int : ∀ x : R, IsIntegral K x := fun x => isAlgebraic_iff_isIntegral.1\n    (alg.isAlgebraic x)\n  classical\n  intro v hvS\n  cases nonempty_fintype ι\n  /- `s` is the set of all coefficients of the polynomial, as well as all of\n    the coordinates of `v`, the point I am trying to find the preimage of. -/\n  let s : Finset R :=\n    (Finset.biUnion (univ : Finset ι) fun i => (ps i).support.image fun x => coeff x (ps i)) ∪\n      (univ : Finset ι).image v\n  have hv : ∀ i, v i ∈ Algebra.adjoin K (s : Set R) := fun j =>\n    Algebra.subset_adjoin (mem_union_right _ (mem_image.2 ⟨j, mem_univ _, rfl⟩))\n  have hs₁ : ∀ (i : ι) (k : ι →₀ ℕ),\n      k ∈ (ps i).support → coeff k (ps i) ∈ Algebra.adjoin K (s : Set R) :=\n    fun i k hk => Algebra.subset_adjoin\n      (mem_union_left _ (mem_biUnion.2 ⟨i, mem_univ _, mem_image_of_mem _ hk⟩))\n  have := isNoetherian_adjoin_finset s fun x _ => is_int x\n  have := Module.IsNoetherian.finite K (Algebra.adjoin K (s : Set R))\n  have : Finite (Algebra.adjoin K (s : Set R)) := Module.finite_of_finite K\n  -- The restriction of the polynomial map, `ps`, to the subalgebra generated by `s`\n  let S' : Set (ι → Algebra.adjoin K (s : Set R)) :=\n    (fun v => Subtype.val ∘ v) ⁻¹' S\n  let res : S' → S' := fun x => ⟨fun i =>\n    ⟨eval (fun j : ι => (x.1 j : R)) (ps i), eval_mem (hs₁ _) fun i => (x.1 i).2⟩,\n      hm x.2⟩\n  have hres_surj : Function.Surjective res := by\n    rw [← Finite.injective_iff_surjective]\n    intro x y hxy\n    ext i\n    simp only [Subtype.ext_iff, funext_iff] at hxy\n    exact congr_fun (hinj x.2 y.2 (funext hxy)) i\n  rcases hres_surj ⟨fun i => ⟨v i, hv i⟩, hvS⟩ with ⟨⟨w, hwS'⟩, hw⟩\n  refine ⟨fun i => w i, hwS', ?_⟩\n  simpa [Subtype.ext_iff, funext_iff] using hw\n\n"}
{"name":"FirstOrder.realize_genericPolyMapSurjOnOfInjOn","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝³ : Finite α\nK : Type u_3\ninst✝² : Field K\ninst✝¹ : FirstOrder.Ring.CompatibleRing K\ninst✝ : Fintype ι\nφ : FirstOrder.Language.ring.Formula (Sum α ι)\nmons : ι → Finset (Finsupp ι Nat)\n⊢ Iff (FirstOrder.Language.Sentence.Realize K (FirstOrder.genericPolyMapSurjOnOfInjOn φ mons))\n    (∀ (v : α → K) (p : Subtype fun p => ∀ (i : ι), HasSubset.Subset (p i).support (mons i)),\n      let f := fun v i => (MvPolynomial.eval v) (↑p i);\n      let S := fun x => φ.Realize (Sum.elim v x);\n      Set.MapsTo f S S → Set.InjOn f S → Set.SurjOn f S S)","decl":"theorem realize_genericPolyMapSurjOnOfInjOn\n    [Fintype ι] (φ : ring.Formula (α ⊕ ι)) (mons : ι → Finset (ι →₀ ℕ)) :\n    (K ⊨ genericPolyMapSurjOnOfInjOn φ mons) ↔\n      ∀ (v : α → K) (p : { p : ι → MvPolynomial ι K // (∀ i, (p i).support ⊆ mons i) }),\n        let f : (ι → K) → (ι → K) := fun v i => eval v (p.1 i)\n        let S : Set (ι → K) := fun x => φ.Realize (Sum.elim v x)\n        S.MapsTo f S → S.InjOn f → S.SurjOn f S := by\n  classical\n  have injOnAlt : ∀ {S : Set (ι → K)} (f : (ι → K) → (ι → K)),\n      S.InjOn f ↔ ∀ x y, x ∈ S → y ∈ S → f x = f y → x = y := by\n    simp [Set.InjOn]; tauto\n  simp only [Sentence.Realize, Formula.Realize, genericPolyMapSurjOnOfInjOn, Formula.relabel,\n    Function.comp_def, Sum.map, id_eq, Equiv.sumAssoc, Equiv.coe_fn_symm_mk, Sum.elim_inr,\n    realize_iAlls, realize_imp, realize_relabel, Fin.natAdd_zero, realize_subst, realize_iInf,\n    Finset.mem_univ, realize_bdEqual, Term.realize_relabel, true_imp_iff,\n    Equiv.forall_congr_left (Equiv.curry (Fin 2) ι K), Equiv.curry_symm_apply, Function.uncurry,\n    Fin.forall_fin_succ_pi, Fin.forall_fin_zero_pi, realize_iExs, realize_inf, Sum.forall_sum,\n    Set.MapsTo, Set.mem_def, injOnAlt, funext_iff, Set.SurjOn, Set.image, setOf,\n    Set.subset_def, Equiv.forall_congr_left (mvPolynomialSupportLEEquiv mons)]\n  simp +singlePass only [← Sum.elim_comp_inl_inr]\n  -- was `simp` and very slow (https://github.com/leanprover-community/mathlib4/issues/19751)\n  simp only [Function.comp_def, Sum.elim_inl, Sum.elim_inr, Fin.castAdd_zero, Fin.cast_eq_self,\n    Nat.add_zero, Term.realize_var, Term.realize_relabel, realize_termOfFreeCommRing,\n    lift_genericPolyMap, Nat.reduceAdd, Fin.isValue, Function.uncurry_apply_pair, Fin.cons_zero,\n    Fin.cons_one, ↓reduceIte, one_ne_zero]\n\n"}
{"name":"FirstOrder.ACF_models_genericPolyMapSurjOnOfInjOn_of_prime","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite α\ninst✝ : Fintype ι\np : Nat\nhp : Nat.Prime p\nφ : FirstOrder.Language.ring.Formula (Sum α ι)\nmons : ι → Finset (Finsupp ι Nat)\n⊢ (FirstOrder.Language.Theory.ACF p).ModelsBoundedFormula (FirstOrder.genericPolyMapSurjOnOfInjOn φ mons)","decl":"theorem ACF_models_genericPolyMapSurjOnOfInjOn_of_prime [Fintype ι]\n    {p : ℕ} (hp : p.Prime) (φ : ring.Formula (α ⊕ ι)) (mons : ι → Finset (ι →₀ ℕ)) :\n    Theory.ACF p ⊨ᵇ genericPolyMapSurjOnOfInjOn φ mons := by\n  classical\n  have : Fact p.Prime := ⟨hp⟩\n  letI := compatibleRingOfRing (AlgebraicClosure (ZMod p))\n  have : CharP (AlgebraicClosure (ZMod p)) p :=\n    charP_of_injective_algebraMap\n      (RingHom.injective (algebraMap (ZMod p) (AlgebraicClosure (ZMod p)))) p\n  rw [← (ACF_isComplete (Or.inl hp)).realize_sentence_iff _\n    (AlgebraicClosure (ZMod p)), realize_genericPolyMapSurjOnOfInjOn]\n  rintro v ⟨f, _⟩\n  exact ax_grothendieck_of_locally_finite (K := ZMod p) (ι := ι) f _\n\n"}
{"name":"FirstOrder.ACF_models_genericPolyMapSurjOnOfInjOn_of_prime_or_zero","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"ι : Type u_1\nα : Type u_2\ninst✝¹ : Finite α\ninst✝ : Fintype ι\np : Nat\nhp : Or (Nat.Prime p) (Eq p 0)\nφ : FirstOrder.Language.ring.Formula (Sum α ι)\nmons : ι → Finset (Finsupp ι Nat)\n⊢ (FirstOrder.Language.Theory.ACF p).ModelsBoundedFormula (FirstOrder.genericPolyMapSurjOnOfInjOn φ mons)","decl":"theorem ACF_models_genericPolyMapSurjOnOfInjOn_of_prime_or_zero\n    [Fintype ι] {p : ℕ} (hp : p.Prime ∨ p = 0)\n    (φ : ring.Formula (α ⊕ ι)) (mons : ι → Finset (ι →₀ ℕ)) :\n    Theory.ACF p ⊨ᵇ genericPolyMapSurjOnOfInjOn φ mons := by\n  rcases hp with hp | rfl\n  · exact ACF_models_genericPolyMapSurjOnOfInjOn_of_prime hp φ mons\n  · rw [ACF_zero_realize_iff_infinite_ACF_prime_realize]\n    convert Set.infinite_univ (α := Nat.Primes)\n    rw [Set.eq_univ_iff_forall]\n    intro ⟨p, hp⟩\n    exact ACF_models_genericPolyMapSurjOnOfInjOn_of_prime hp φ mons\n\n"}
{"name":"ax_grothendieck_of_definable","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"K : Type u_1\nι : Type u_2\ninst✝³ : Field K\ninst✝² : IsAlgClosed K\ninst✝¹ : Finite ι\ninst✝ : FirstOrder.Ring.CompatibleRing K\nc : Set K\nS : Set (ι → K)\nhS : c.Definable FirstOrder.Language.ring S\nps : ι → MvPolynomial ι K\na✝¹ : Set.MapsTo (fun v i => (MvPolynomial.eval v) (ps i)) S S\na✝ : Set.InjOn (fun v i => (MvPolynomial.eval v) (ps i)) S\n⊢ Set.SurjOn (fun v i => (MvPolynomial.eval v) (ps i)) S S","decl":"/-- A slight generalization of the **Ax-Grothendieck** theorem\n\nIf `K` is an algebraically closed field, `ι` is a finite type, and `S` is a definable subset of\n`ι → K`, then any injective polynomial map `S → S`  is also surjective on `S`. -/\ntheorem ax_grothendieck_of_definable [CompatibleRing K] {c : Set K}\n    (S : Set (ι → K)) (hS : c.Definable Language.ring S)\n    (ps : ι → MvPolynomial ι K) :\n    S.MapsTo (fun v i => eval v (ps i)) S →\n    S.InjOn (fun v i => eval v (ps i)) →\n    S.SurjOn (fun v i => eval v (ps i)) S := by\n  letI := Fintype.ofFinite ι\n  let p : ℕ := ringChar K\n  have : CharP K p := ⟨ringChar.spec K⟩\n  rw [Set.definable_iff_finitely_definable] at hS\n  rcases hS with ⟨c, _, hS⟩\n  rw [Set.definable_iff_exists_formula_sum] at hS\n  rcases hS with ⟨φ, hφ⟩\n  rw [hφ]\n  have := ACF_models_genericPolyMapSurjOnOfInjOn_of_prime_or_zero\n    (CharP.char_is_prime_or_zero K p) φ (fun i => (ps i).support)\n  rw [← (ACF_isComplete (CharP.char_is_prime_or_zero K p)).realize_sentence_iff _ K,\n    realize_genericPolyMapSurjOnOfInjOn] at this\n  exact this Subtype.val ⟨ps, fun i => Set.Subset.refl _⟩\n\n"}
{"name":"ax_grothendieck_zeroLocus","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"K : Type u_1\nι : Type u_2\ninst✝² : Field K\ninst✝¹ : IsAlgClosed K\ninst✝ : Finite ι\nI : Ideal (MvPolynomial ι K)\np : ι → MvPolynomial ι K\n⊢ let S := MvPolynomial.zeroLocus I;\n  Set.MapsTo (fun v i => (MvPolynomial.eval v) (p i)) S S → Set.InjOn (fun v i => (MvPolynomial.eval v) (p i)) S → Set.SurjOn (fun v i => (MvPolynomial.eval v) (p i)) S S","decl":"/-- The **Ax-Grothendieck** theorem\n\nIf `K` is an algebraically closed field, and `S : Set (ι → K)` is the `zeroLocus` of an ideal\nof the multivariable polynomial ring, then any injective polynomial map `S → S`  is also\nsurjective on `S`. -/\ntheorem ax_grothendieck_zeroLocus\n    (I : Ideal (MvPolynomial ι K))\n    (p : ι → MvPolynomial ι K) :\n    let S := zeroLocus I\n    S.MapsTo (fun v i => eval v (p i)) S →\n    S.InjOn (fun v i => eval v (p i)) →\n    S.SurjOn (fun v i => eval v (p i)) S := by\n  letI := compatibleRingOfRing K\n  intro S\n  obtain ⟨s, rfl⟩ : I.FG := IsNoetherian.noetherian I\n  exact ax_grothendieck_of_definable S (mvPolynomial_zeroLocus_definable s) p\n\n"}
{"name":"ax_grothendieck_univ","module":"Mathlib.FieldTheory.AxGrothendieck","initialProofState":"K : Type u_1\nι : Type u_2\ninst✝² : Field K\ninst✝¹ : IsAlgClosed K\ninst✝ : Finite ι\np : ι → MvPolynomial ι K\na✝ : Function.Injective fun v i => (MvPolynomial.eval v) (p i)\n⊢ Function.Surjective fun v i => (MvPolynomial.eval v) (p i)","decl":"/-- A special case of the **Ax-Grothendieck** theorem\n\nAny injective polynomial map `K^n → K^n` is also surjective if `K` is an\nalgberaically closed field. -/\ntheorem ax_grothendieck_univ (p : ι → MvPolynomial ι K) :\n    (fun v i => eval v (p i)).Injective →\n    (fun v i => eval v (p i)).Surjective := by\n  simpa [Set.injective_iff_injOn_univ, Set.surjective_iff_surjOn_univ] using\n      ax_grothendieck_zeroLocus 0 p\n"}
