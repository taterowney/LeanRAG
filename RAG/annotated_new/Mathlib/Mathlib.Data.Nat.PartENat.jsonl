{"name":"PartENat.dom_some","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\n⊢ (↑x).Dom","decl":"@[simp]\ntheorem dom_some (x : ℕ) : (some x).Dom :=\n  trivial\n\n"}
{"name":"PartENat.some_eq_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\n⊢ Eq ↑n ↑n","decl":"theorem some_eq_natCast (n : ℕ) : some n = n :=\n  rfl\n\n"}
{"name":"PartENat.instCharZero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ CharZero PartENat","decl":"instance : CharZero PartENat where\n  cast_injective := Part.some_injective\n\n"}
{"name":"PartENat.natCast_inj","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : Nat\n⊢ Iff (Eq ↑x ↑y) (Eq x y)","decl":"/-- Alias of `Nat.cast_inj` specialized to `PartENat` --/\ntheorem natCast_inj {x y : ℕ} : (x : PartENat) = y ↔ x = y :=\n  Nat.cast_inj\n\n"}
{"name":"PartENat.dom_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\n⊢ (↑x).Dom","decl":"@[simp]\ntheorem dom_natCast (x : ℕ) : (x : PartENat).Dom :=\n  trivial\n\n"}
{"name":"PartENat.dom_ofNat","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\ninst✝ : x.AtLeastTwo\n⊢ (OfNat.ofNat x).Dom","decl":"@[simp]\ntheorem dom_ofNat (x : ℕ) [x.AtLeastTwo] : (ofNat(x) : PartENat).Dom :=\n  trivial\n\n"}
{"name":"PartENat.dom_zero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Part.Dom 0","decl":"@[simp]\ntheorem dom_zero : (0 : PartENat).Dom :=\n  trivial\n\n"}
{"name":"PartENat.dom_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Part.Dom 1","decl":"@[simp]\ntheorem dom_one : (1 : PartENat).Dom :=\n  trivial\n\n"}
{"name":"PartENat.instCanLiftNatCastDom","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ CanLift PartENat Nat Nat.cast Part.Dom","decl":"instance : CanLift PartENat ℕ (↑) Dom :=\n  ⟨fun n hn => ⟨n.get hn, Part.some_get _⟩⟩\n\n"}
{"name":"PartENat.le_def","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\n⊢ Iff (LE.le x y) (Exists fun h => ∀ (hy : y.Dom), LE.le (x.get ⋯) (y.get hy))","decl":"theorem le_def (x y : PartENat) :\n    x ≤ y ↔ ∃ h : y.Dom → x.Dom, ∀ hy : y.Dom, x.get (h hy) ≤ y.get hy :=\n  Iff.rfl\n\n"}
{"name":"PartENat.casesOn'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : PartENat → Prop\na : PartENat\na✝¹ : P Top.top\na✝ : ∀ (n : Nat), P ↑n\n⊢ P a","decl":"@[elab_as_elim]\nprotected theorem casesOn' {P : PartENat → Prop} :\n    ∀ a : PartENat, P ⊤ → (∀ n : ℕ, P (some n)) → P a :=\n  Part.induction_on\n\n"}
{"name":"PartENat.casesOn","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : PartENat → Prop\na : PartENat\na✝¹ : P Top.top\na✝ : ∀ (n : Nat), P ↑n\n⊢ P a","decl":"@[elab_as_elim]\nprotected theorem casesOn {P : PartENat → Prop} : ∀ a : PartENat, P ⊤ → (∀ n : ℕ, P n) → P a := by\n  exact PartENat.casesOn'\n\n-- not a simp lemma as we will provide a `LinearOrderedAddCommMonoidWithTop` instance later\n"}
{"name":"PartENat.top_add","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Eq (HAdd.hAdd Top.top x) Top.top","decl":"theorem top_add (x : PartENat) : ⊤ + x = ⊤ :=\n  Part.ext' (iff_of_eq (false_and _)) fun h => h.left.elim\n\n-- not a simp lemma as we will provide a `LinearOrderedAddCommMonoidWithTop` instance later\n"}
{"name":"PartENat.add_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Eq (HAdd.hAdd x Top.top) Top.top","decl":"theorem add_top (x : PartENat) : x + ⊤ = ⊤ := by rw [add_comm, top_add]\n\n"}
{"name":"PartENat.natCast_get","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\nh : x.Dom\n⊢ Eq (↑(x.get h)) x","decl":"@[simp]\ntheorem natCast_get {x : PartENat} (h : x.Dom) : (x.get h : PartENat) = x := by\n  exact Part.ext' (iff_of_true trivial h) fun _ _ => rfl\n\n"}
{"name":"PartENat.get_natCast'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\nh : (↑x).Dom\n⊢ Eq ((↑x).get h) x","decl":"@[simp, norm_cast]\ntheorem get_natCast' (x : ℕ) (h : (x : PartENat).Dom) : get (x : PartENat) h = x := by\n  rw [← natCast_inj, natCast_get]\n\n"}
{"name":"PartENat.get_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\n⊢ Eq ((↑x).get ⋯) x","decl":"theorem get_natCast {x : ℕ} : get (x : PartENat) (dom_natCast x) = x :=\n  get_natCast' _ _\n\n"}
{"name":"PartENat.coe_add_get","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\ny : PartENat\nh : (HAdd.hAdd (↑x) y).Dom\n⊢ Eq ((HAdd.hAdd (↑x) y).get h) (HAdd.hAdd x (y.get ⋯))","decl":"theorem coe_add_get {x : ℕ} {y : PartENat} (h : ((x : PartENat) + y).Dom) :\n    get ((x : PartENat) + y) h = x + get y h.2 := by\n  rfl\n\n"}
{"name":"PartENat.get_add","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nh : (HAdd.hAdd x y).Dom\n⊢ Eq ((HAdd.hAdd x y).get h) (HAdd.hAdd (x.get ⋯) (y.get ⋯))","decl":"@[simp]\ntheorem get_add {x y : PartENat} (h : (x + y).Dom) : get (x + y) h = x.get h.1 + y.get h.2 :=\n  rfl\n\n"}
{"name":"PartENat.get_zero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"h : Part.Dom 0\n⊢ Eq (Part.get 0 h) 0","decl":"@[simp]\ntheorem get_zero (h : (0 : PartENat).Dom) : (0 : PartENat).get h = 0 :=\n  rfl\n\n"}
{"name":"PartENat.get_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"h : Part.Dom 1\n⊢ Eq (Part.get 1 h) 1","decl":"@[simp]\ntheorem get_one (h : (1 : PartENat).Dom) : (1 : PartENat).get h = 1 :=\n  rfl\n\n"}
{"name":"PartENat.get_ofNat'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\ninst✝ : x.AtLeastTwo\nh : (OfNat.ofNat x).Dom\n⊢ Eq ((OfNat.ofNat x).get h) (OfNat.ofNat x)","decl":"@[simp]\ntheorem get_ofNat' (x : ℕ) [x.AtLeastTwo] (h : (ofNat(x) : PartENat).Dom) :\n    Part.get (ofNat(x) : PartENat) h = ofNat(x) :=\n  get_natCast' x h\n\n"}
{"name":"PartENat.get_eq_iff_eq_some","module":"Mathlib.Data.Nat.PartENat","initialProofState":"a : PartENat\nha : a.Dom\nb : Nat\n⊢ Iff (Eq (a.get ha) b) (Eq a ↑b)","decl":"nonrec theorem get_eq_iff_eq_some {a : PartENat} {ha : a.Dom} {b : ℕ} : a.get ha = b ↔ a = some b :=\n  get_eq_iff_eq_some\n\n"}
{"name":"PartENat.get_eq_iff_eq_coe","module":"Mathlib.Data.Nat.PartENat","initialProofState":"a : PartENat\nha : a.Dom\nb : Nat\n⊢ Iff (Eq (a.get ha) b) (Eq a ↑b)","decl":"theorem get_eq_iff_eq_coe {a : PartENat} {ha : a.Dom} {b : ℕ} : a.get ha = b ↔ a = b := by\n  rw [get_eq_iff_eq_some]\n  rfl\n\n"}
{"name":"PartENat.dom_of_le_of_dom","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\na✝¹ : LE.le x y\na✝ : y.Dom\n⊢ x.Dom","decl":"theorem dom_of_le_of_dom {x y : PartENat} : x ≤ y → y.Dom → x.Dom := fun ⟨h, _⟩ => h\n\n"}
{"name":"PartENat.dom_of_le_some","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\ny : Nat\nh : LE.le x ↑y\n⊢ x.Dom","decl":"theorem dom_of_le_some {x : PartENat} {y : ℕ} (h : x ≤ some y) : x.Dom :=\n  dom_of_le_of_dom h trivial\n\n"}
{"name":"PartENat.dom_of_le_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\ny : Nat\nh : LE.le x ↑y\n⊢ x.Dom","decl":"theorem dom_of_le_natCast {x : PartENat} {y : ℕ} (h : x ≤ y) : x.Dom := by\n  exact dom_of_le_some h\n\n"}
{"name":"PartENat.lt_def","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\n⊢ Iff (LT.lt x y) (Exists fun hx => ∀ (hy : y.Dom), LT.lt (x.get hx) (y.get hy))","decl":"theorem lt_def (x y : PartENat) : x < y ↔ ∃ hx : x.Dom, ∀ hy : y.Dom, x.get hx < y.get hy := by\n  rw [lt_iff_le_not_le, le_def, le_def, not_exists]\n  constructor\n  · rintro ⟨⟨hyx, H⟩, h⟩\n    by_cases hx : x.Dom\n    · use hx\n      intro hy\n      specialize H hy\n      specialize h fun _ => hy\n      rw [not_forall] at h\n      cases' h with hx' h\n      rw [not_le] at h\n      exact h\n    · specialize h fun hx' => (hx hx').elim\n      rw [not_forall] at h\n      cases' h with hx' h\n      exact (hx hx').elim\n  · rintro ⟨hx, H⟩\n    exact ⟨⟨fun _ => hx, fun hy => (H hy).le⟩, fun hxy h => not_lt_of_le (h _) (H _)⟩\n\n"}
{"name":"PartENat.instZeroLEOneClass","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ ZeroLEOneClass PartENat","decl":"instance : ZeroLEOneClass PartENat where\n  zero_le_one := bot_le\n\n"}
{"name":"PartENat.coe_le_coe","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : Nat\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"/-- Alias of `Nat.cast_le` specialized to `PartENat` --/\ntheorem coe_le_coe {x y : ℕ} : (x : PartENat) ≤ y ↔ x ≤ y := Nat.cast_le\n\n"}
{"name":"PartENat.coe_lt_coe","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : Nat\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"/-- Alias of `Nat.cast_lt` specialized to `PartENat` --/\ntheorem coe_lt_coe {x y : ℕ} : (x : PartENat) < y ↔ x < y := Nat.cast_lt\n\n"}
{"name":"PartENat.get_le_get","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nhx : x.Dom\nhy : y.Dom\n⊢ Iff (LE.le (x.get hx) (y.get hy)) (LE.le x y)","decl":"@[simp]\ntheorem get_le_get {x y : PartENat} {hx : x.Dom} {hy : y.Dom} : x.get hx ≤ y.get hy ↔ x ≤ y := by\n  conv =>\n    lhs\n    rw [← coe_le_coe, natCast_get, natCast_get]\n\n"}
{"name":"PartENat.le_coe_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\nn : Nat\n⊢ Iff (LE.le x ↑n) (Exists fun h => LE.le (x.get h) n)","decl":"theorem le_coe_iff (x : PartENat) (n : ℕ) : x ≤ n ↔ ∃ h : x.Dom, x.get h ≤ n := by\n  show (∃ h : True → x.Dom, _) ↔ ∃ h : x.Dom, x.get h ≤ n\n  simp only [forall_prop_of_true, dom_natCast, get_natCast']\n\n"}
{"name":"PartENat.lt_coe_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\nn : Nat\n⊢ Iff (LT.lt x ↑n) (Exists fun h => LT.lt (x.get h) n)","decl":"theorem lt_coe_iff (x : PartENat) (n : ℕ) : x < n ↔ ∃ h : x.Dom, x.get h < n := by\n  simp only [lt_def, forall_prop_of_true, get_natCast', dom_natCast]\n\n"}
{"name":"PartENat.coe_le_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\nx : PartENat\n⊢ Iff (LE.le (↑n) x) (∀ (h : x.Dom), LE.le n (x.get h))","decl":"theorem coe_le_iff (n : ℕ) (x : PartENat) : (n : PartENat) ≤ x ↔ ∀ h : x.Dom, n ≤ x.get h := by\n  rw [← some_eq_natCast]\n  simp only [le_def, exists_prop_of_true, dom_some, forall_true_iff]\n  rfl\n\n"}
{"name":"PartENat.coe_lt_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\nx : PartENat\n⊢ Iff (LT.lt (↑n) x) (∀ (h : x.Dom), LT.lt n (x.get h))","decl":"theorem coe_lt_iff (n : ℕ) (x : PartENat) : (n : PartENat) < x ↔ ∀ h : x.Dom, n < x.get h := by\n  rw [← some_eq_natCast]\n  simp only [lt_def, exists_prop_of_true, dom_some, forall_true_iff]\n  rfl\n\n"}
{"name":"PartENat.eq_zero_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Eq x 0) (LE.le x 0)","decl":"nonrec theorem eq_zero_iff {x : PartENat} : x = 0 ↔ x ≤ 0 :=\n  eq_bot_iff\n\n"}
{"name":"PartENat.ne_zero_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Ne x 0) (LT.lt Bot.bot x)","decl":"theorem ne_zero_iff {x : PartENat} : x ≠ 0 ↔ ⊥ < x :=\n  bot_lt_iff_ne_bot.symm\n\n"}
{"name":"PartENat.dom_of_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\na✝ : LT.lt x y\n⊢ x.Dom","decl":"theorem dom_of_lt {x y : PartENat} : x < y → x.Dom :=\n  PartENat.casesOn x not_top_lt fun _ _ => dom_natCast _\n\n"}
{"name":"PartENat.top_eq_none","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq Top.top Part.none","decl":"theorem top_eq_none : (⊤ : PartENat) = Part.none :=\n  rfl\n\n"}
{"name":"PartENat.natCast_lt_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\n⊢ LT.lt (↑x) Top.top","decl":"@[simp]\ntheorem natCast_lt_top (x : ℕ) : (x : PartENat) < ⊤ :=\n  Ne.lt_top fun h => absurd (congr_arg Dom h) <| by simp only [dom_natCast]; exact true_ne_false\n\n"}
{"name":"PartENat.zero_lt_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ LT.lt 0 Top.top","decl":"@[simp]\ntheorem zero_lt_top : (0 : PartENat) < ⊤ :=\n  natCast_lt_top 0\n\n"}
{"name":"PartENat.one_lt_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ LT.lt 1 Top.top","decl":"@[simp]\ntheorem one_lt_top : (1 : PartENat) < ⊤ :=\n  natCast_lt_top 1\n\n"}
{"name":"PartENat.ofNat_lt_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\ninst✝ : x.AtLeastTwo\n⊢ LT.lt (OfNat.ofNat x) Top.top","decl":"@[simp]\ntheorem ofNat_lt_top (x : ℕ) [x.AtLeastTwo] : (ofNat(x) : PartENat) < ⊤ :=\n  natCast_lt_top x\n\n"}
{"name":"PartENat.natCast_ne_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\n⊢ Ne (↑x) Top.top","decl":"@[simp]\ntheorem natCast_ne_top (x : ℕ) : (x : PartENat) ≠ ⊤ :=\n  ne_of_lt (natCast_lt_top x)\n\n"}
{"name":"PartENat.zero_ne_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Ne 0 Top.top","decl":"@[simp]\ntheorem zero_ne_top : (0 : PartENat) ≠ ⊤ :=\n  natCast_ne_top 0\n\n"}
{"name":"PartENat.one_ne_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Ne 1 Top.top","decl":"@[simp]\ntheorem one_ne_top : (1 : PartENat) ≠ ⊤ :=\n  natCast_ne_top 1\n\n"}
{"name":"PartENat.ofNat_ne_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\ninst✝ : x.AtLeastTwo\n⊢ Ne (OfNat.ofNat x) Top.top","decl":"@[simp]\ntheorem ofNat_ne_top (x : ℕ) [x.AtLeastTwo] : (ofNat(x) : PartENat) ≠ ⊤ :=\n  natCast_ne_top x\n\n"}
{"name":"PartENat.not_isMax_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : Nat\n⊢ Not (IsMax ↑x)","decl":"theorem not_isMax_natCast (x : ℕ) : ¬IsMax (x : PartENat) :=\n  not_isMax_of_lt (natCast_lt_top x)\n\n"}
{"name":"PartENat.ne_top_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Ne x Top.top) (Exists fun n => Eq x ↑n)","decl":"theorem ne_top_iff {x : PartENat} : x ≠ ⊤ ↔ ∃ n : ℕ, x = n := by\n  simpa only [← some_eq_natCast] using Part.ne_none_iff\n\n"}
{"name":"PartENat.ne_top_iff_dom","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Ne x Top.top) x.Dom","decl":"theorem ne_top_iff_dom {x : PartENat} : x ≠ ⊤ ↔ x.Dom := by\n  classical exact not_iff_comm.1 Part.eq_none_iff'.symm\n\n"}
{"name":"PartENat.not_dom_iff_eq_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Not x.Dom) (Eq x Top.top)","decl":"theorem not_dom_iff_eq_top {x : PartENat} : ¬x.Dom ↔ x = ⊤ :=\n  Iff.not_left ne_top_iff_dom.symm\n\n"}
{"name":"PartENat.ne_top_of_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nh : LT.lt x y\n⊢ Ne x Top.top","decl":"theorem ne_top_of_lt {x y : PartENat} (h : x < y) : x ≠ ⊤ :=\n  ne_of_lt <| lt_of_lt_of_le h le_top\n\n"}
{"name":"PartENat.eq_top_iff_forall_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Eq x Top.top) (∀ (n : Nat), LT.lt (↑n) x)","decl":"theorem eq_top_iff_forall_lt (x : PartENat) : x = ⊤ ↔ ∀ n : ℕ, (n : PartENat) < x := by\n  constructor\n  · rintro rfl n\n    exact natCast_lt_top _\n  · contrapose!\n    rw [ne_top_iff]\n    rintro ⟨n, rfl⟩\n    exact ⟨n, irrefl _⟩\n\n"}
{"name":"PartENat.eq_top_iff_forall_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (Eq x Top.top) (∀ (n : Nat), LE.le (↑n) x)","decl":"theorem eq_top_iff_forall_le (x : PartENat) : x = ⊤ ↔ ∀ n : ℕ, (n : PartENat) ≤ x :=\n  (eq_top_iff_forall_lt x).trans\n    ⟨fun h n => (h n).le, fun h n => lt_of_lt_of_le (coe_lt_coe.mpr n.lt_succ_self) (h (n + 1))⟩\n\n"}
{"name":"PartENat.pos_iff_one_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Iff (LT.lt 0 x) (LE.le 1 x)","decl":"theorem pos_iff_one_le {x : PartENat} : 0 < x ↔ 1 ≤ x :=\n  PartENat.casesOn x\n    (by simp only [le_top, natCast_lt_top, ← @Nat.cast_zero PartENat])\n    fun n => by\n      rw [← Nat.cast_zero, ← Nat.cast_one, PartENat.coe_lt_coe, PartENat.coe_le_coe]\n      rfl\n\n"}
{"name":"PartENat.isTotal","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ IsTotal PartENat fun x1 x2 => LE.le x1 x2","decl":"instance isTotal : IsTotal PartENat (· ≤ ·) where\n  total x y :=\n    PartENat.casesOn (P := fun z => z ≤ y ∨ y ≤ z) x (Or.inr le_top)\n      (PartENat.casesOn y (fun _ => Or.inl le_top) fun x y =>\n        (le_total x y).elim (Or.inr ∘ coe_le_coe.2) (Or.inl ∘ coe_le_coe.2))\n\n"}
{"name":"PartENat.instCanonicallyOrderedAdd","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ CanonicallyOrderedAdd PartENat","decl":"instance : CanonicallyOrderedAdd PartENat :=\n  { le_self_add := fun a b =>\n      PartENat.casesOn b (le_top.trans_eq (add_top _).symm) fun _ =>\n        PartENat.casesOn a (top_add _).ge fun _ =>\n          (coe_le_coe.2 le_self_add).trans_eq (Nat.cast_add _ _)\n    exists_add_of_le := fun {a b} =>\n      PartENat.casesOn b (fun _ => ⟨⊤, (add_top _).symm⟩) fun b =>\n        PartENat.casesOn a (fun h => ((natCast_lt_top _).not_le h).elim) fun a h =>\n          ⟨(b - a : ℕ), by\n            rw [← Nat.cast_add, natCast_inj, add_comm, tsub_add_cancel_of_le (coe_le_coe.1 h)]⟩ }\n\n"}
{"name":"PartENat.eq_natCast_sub_of_add_eq_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nn : Nat\nh : Eq (HAdd.hAdd x y) ↑n\n⊢ Eq x ↑(HSub.hSub n (y.get ⋯))","decl":"theorem eq_natCast_sub_of_add_eq_natCast {x y : PartENat} {n : ℕ} (h : x + y = n) :\n    x = ↑(n - y.get (dom_of_le_natCast ((le_add_left le_rfl).trans_eq h))) := by\n  lift x to ℕ using dom_of_le_natCast ((le_add_right le_rfl).trans_eq h)\n  lift y to ℕ using dom_of_le_natCast ((le_add_left le_rfl).trans_eq h)\n  rw [← Nat.cast_add, natCast_inj] at h\n  rw [get_natCast, natCast_inj, eq_tsub_of_add_eq h]\n\n"}
{"name":"PartENat.add_lt_add_right","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y z : PartENat\nh : LT.lt x y\nhz : Ne z Top.top\n⊢ LT.lt (HAdd.hAdd x z) (HAdd.hAdd y z)","decl":"protected theorem add_lt_add_right {x y z : PartENat} (h : x < y) (hz : z ≠ ⊤) : x + z < y + z := by\n  rcases ne_top_iff.mp (ne_top_of_lt h) with ⟨m, rfl⟩\n  rcases ne_top_iff.mp hz with ⟨k, rfl⟩\n  induction' y using PartENat.casesOn with n\n  · rw [top_add]\n    -- Porting note: was apply_mod_cast natCast_lt_top\n    norm_cast; apply natCast_lt_top\n  norm_cast at h\n  -- Porting note: was `apply_mod_cast add_lt_add_right h`\n  norm_cast; apply add_lt_add_right h\n\n"}
{"name":"PartENat.add_lt_add_iff_right","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y z : PartENat\nhz : Ne z Top.top\n⊢ Iff (LT.lt (HAdd.hAdd x z) (HAdd.hAdd y z)) (LT.lt x y)","decl":"protected theorem add_lt_add_iff_right {x y z : PartENat} (hz : z ≠ ⊤) : x + z < y + z ↔ x < y :=\n  ⟨lt_of_add_lt_add_right, fun h => PartENat.add_lt_add_right h hz⟩\n\n"}
{"name":"PartENat.add_lt_add_iff_left","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y z : PartENat\nhz : Ne z Top.top\n⊢ Iff (LT.lt (HAdd.hAdd z x) (HAdd.hAdd z y)) (LT.lt x y)","decl":"protected theorem add_lt_add_iff_left {x y z : PartENat} (hz : z ≠ ⊤) : z + x < z + y ↔ x < y := by\n  rw [add_comm z, add_comm z, PartENat.add_lt_add_iff_right hz]\n\n"}
{"name":"PartENat.lt_add_iff_pos_right","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nhx : Ne x Top.top\n⊢ Iff (LT.lt x (HAdd.hAdd x y)) (LT.lt 0 y)","decl":"protected theorem lt_add_iff_pos_right {x y : PartENat} (hx : x ≠ ⊤) : x < x + y ↔ 0 < y := by\n  conv_rhs => rw [← PartENat.add_lt_add_iff_left hx]\n  rw [add_zero]\n\n"}
{"name":"PartENat.lt_add_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\nhx : Ne x Top.top\n⊢ LT.lt x (HAdd.hAdd x 1)","decl":"theorem lt_add_one {x : PartENat} (hx : x ≠ ⊤) : x < x + 1 := by\n  rw [PartENat.lt_add_iff_pos_right hx]\n  norm_cast\n\n"}
{"name":"PartENat.le_of_lt_add_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nh : LT.lt x (HAdd.hAdd y 1)\n⊢ LE.le x y","decl":"theorem le_of_lt_add_one {x y : PartENat} (h : x < y + 1) : x ≤ y := by\n  induction' y using PartENat.casesOn with n\n  · apply le_top\n  rcases ne_top_iff.mp (ne_top_of_lt h) with ⟨m, rfl⟩\n  -- Porting note: was `apply_mod_cast Nat.le_of_lt_succ; apply_mod_cast h`\n  norm_cast; apply Nat.le_of_lt_succ; norm_cast at h\n\n"}
{"name":"PartENat.add_one_le_of_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nh : LT.lt x y\n⊢ LE.le (HAdd.hAdd x 1) y","decl":"theorem add_one_le_of_lt {x y : PartENat} (h : x < y) : x + 1 ≤ y := by\n  induction' y using PartENat.casesOn with n\n  · apply le_top\n  rcases ne_top_iff.mp (ne_top_of_lt h) with ⟨m, rfl⟩\n  -- Porting note: was `apply_mod_cast Nat.succ_le_of_lt; apply_mod_cast h`\n  norm_cast; apply Nat.succ_le_of_lt; norm_cast at h\n\n"}
{"name":"PartENat.add_one_le_iff_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nhx : Ne x Top.top\n⊢ Iff (LE.le (HAdd.hAdd x 1) y) (LT.lt x y)","decl":"theorem add_one_le_iff_lt {x y : PartENat} (hx : x ≠ ⊤) : x + 1 ≤ y ↔ x < y := by\n  refine ⟨fun h => ?_, add_one_le_of_lt⟩\n  rcases ne_top_iff.mp hx with ⟨m, rfl⟩\n  induction' y using PartENat.casesOn with n\n  · apply natCast_lt_top\n  -- Porting note: was `apply_mod_cast Nat.lt_of_succ_le; apply_mod_cast h`\n  norm_cast; apply Nat.lt_of_succ_le; norm_cast at h\n\n"}
{"name":"PartENat.coe_succ_le_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\ne : PartENat\n⊢ Iff (LE.le (↑n.succ) e) (LT.lt (↑n) e)","decl":"theorem coe_succ_le_iff {n : ℕ} {e : PartENat} : ↑n.succ ≤ e ↔ ↑n < e := by\n  rw [Nat.succ_eq_add_one n, Nat.cast_add, Nat.cast_one, add_one_le_iff_lt (natCast_ne_top n)]\n\n"}
{"name":"PartENat.lt_add_one_iff_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nhx : Ne x Top.top\n⊢ Iff (LT.lt x (HAdd.hAdd y 1)) (LE.le x y)","decl":"theorem lt_add_one_iff_lt {x y : PartENat} (hx : x ≠ ⊤) : x < y + 1 ↔ x ≤ y := by\n  refine ⟨le_of_lt_add_one, fun h => ?_⟩\n  rcases ne_top_iff.mp hx with ⟨m, rfl⟩\n  induction' y using PartENat.casesOn with n\n  · rw [top_add]\n    apply natCast_lt_top\n  -- Porting note: was `apply_mod_cast Nat.lt_succ_of_le; apply_mod_cast h`\n  norm_cast; apply Nat.lt_succ_of_le; norm_cast at h\n\n"}
{"name":"PartENat.lt_coe_succ_iff_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\nn : Nat\nhx : Ne x Top.top\n⊢ Iff (LT.lt x ↑n.succ) (LE.le x ↑n)","decl":"lemma lt_coe_succ_iff_le {x : PartENat} {n : ℕ} (hx : x ≠ ⊤) : x < n.succ ↔ x ≤ n := by\n  rw [Nat.succ_eq_add_one n, Nat.cast_add, Nat.cast_one, lt_add_one_iff_lt hx]\n\n"}
{"name":"PartENat.add_eq_top_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"a b : PartENat\n⊢ Iff (Eq (HAdd.hAdd a b) Top.top) (Or (Eq a Top.top) (Eq b Top.top))","decl":"theorem add_eq_top_iff {a b : PartENat} : a + b = ⊤ ↔ a = ⊤ ∨ b = ⊤ := by\n  refine PartENat.casesOn a ?_ ?_\n  <;> refine PartENat.casesOn b ?_ ?_\n  <;> simp [top_add, add_top]\n  simp only [← Nat.cast_add, PartENat.natCast_ne_top, forall_const, not_false_eq_true]\n\n"}
{"name":"PartENat.add_right_cancel_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"a b c : PartENat\nhc : Ne c Top.top\n⊢ Iff (Eq (HAdd.hAdd a c) (HAdd.hAdd b c)) (Eq a b)","decl":"protected theorem add_right_cancel_iff {a b c : PartENat} (hc : c ≠ ⊤) : a + c = b + c ↔ a = b := by\n  rcases ne_top_iff.1 hc with ⟨c, rfl⟩\n  refine PartENat.casesOn a ?_ ?_\n  <;> refine PartENat.casesOn b ?_ ?_\n  <;> simp [add_eq_top_iff, natCast_ne_top, @eq_comm _ (⊤ : PartENat), top_add]\n  simp only [← Nat.cast_add, add_left_cancel_iff, PartENat.natCast_inj, add_comm, forall_const]\n\n"}
{"name":"PartENat.add_left_cancel_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"a b c : PartENat\nha : Ne a Top.top\n⊢ Iff (Eq (HAdd.hAdd a b) (HAdd.hAdd a c)) (Eq b c)","decl":"protected theorem add_left_cancel_iff {a b c : PartENat} (ha : a ≠ ⊤) : a + b = a + c ↔ b = c := by\n  rw [add_comm a, add_comm a, PartENat.add_right_cancel_iff ha]\n\n"}
{"name":"PartENat.toWithTop_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ letFun Part.noneDecidable fun this => Eq Top.top.toWithTop Top.top","decl":"theorem toWithTop_top :\n    have : Decidable (⊤ : PartENat).Dom := Part.noneDecidable\n    toWithTop ⊤ = ⊤ :=\n  rfl\n\n"}
{"name":"PartENat.toWithTop_top'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"h : Decidable Top.top.Dom\n⊢ Eq Top.top.toWithTop Top.top","decl":"@[simp]\ntheorem toWithTop_top' {h : Decidable (⊤ : PartENat).Dom} : toWithTop ⊤ = ⊤ := by\n  convert toWithTop_top\n\n"}
{"name":"PartENat.toWithTop_zero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ letFun (Part.someDecidable 0) fun this => Eq (PartENat.toWithTop 0) 0","decl":"theorem toWithTop_zero :\n    have : Decidable (0 : PartENat).Dom := someDecidable 0\n    toWithTop 0 = 0 :=\n  rfl\n\n"}
{"name":"PartENat.toWithTop_zero'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"h : Decidable (Part.Dom 0)\n⊢ Eq (PartENat.toWithTop 0) 0","decl":"@[simp]\ntheorem toWithTop_zero' {h : Decidable (0 : PartENat).Dom} : toWithTop 0 = 0 := by\n  convert toWithTop_zero\n\n"}
{"name":"PartENat.toWithTop_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ letFun (Part.someDecidable 1) fun this => Eq (PartENat.toWithTop 1) 1","decl":"theorem toWithTop_one :\n    have : Decidable (1 : PartENat).Dom := someDecidable 1\n    toWithTop 1 = 1 :=\n  rfl\n\n"}
{"name":"PartENat.toWithTop_one'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"h : Decidable (Part.Dom 1)\n⊢ Eq (PartENat.toWithTop 1) 1","decl":"@[simp]\ntheorem toWithTop_one' {h : Decidable (1 : PartENat).Dom} : toWithTop 1 = 1 := by\n  convert toWithTop_one\n\n"}
{"name":"PartENat.toWithTop_some","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\n⊢ Eq (↑n).toWithTop ↑n","decl":"theorem toWithTop_some (n : ℕ) : toWithTop (some n) = n :=\n  rfl\n\n"}
{"name":"PartENat.toWithTop_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\nx✝ : Decidable (↑n).Dom\n⊢ Eq (↑n).toWithTop ↑n","decl":"theorem toWithTop_natCast (n : ℕ) {_ : Decidable (n : PartENat).Dom} : toWithTop n = n := by\n  simp only [← toWithTop_some]\n  congr\n\n"}
{"name":"PartENat.toWithTop_natCast'","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\nx✝ : Decidable (↑n).Dom\n⊢ Eq (↑n).toWithTop ↑n","decl":"@[simp]\ntheorem toWithTop_natCast' (n : ℕ) {_ : Decidable (n : PartENat).Dom} :\n    toWithTop (n : PartENat) = n := by\n  rw [toWithTop_natCast n]\n\n"}
{"name":"PartENat.toWithTop_ofNat","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\nx✝ : Decidable (Part.Dom (OfNat.ofNat n))\n⊢ Eq (OfNat.ofNat n).toWithTop (OfNat.ofNat n)","decl":"@[simp]\ntheorem toWithTop_ofNat (n : ℕ) [n.AtLeastTwo] {_ : Decidable (OfNat.ofNat n : PartENat).Dom} :\n    toWithTop (ofNat(n) : PartENat) = OfNat.ofNat n := toWithTop_natCast' n\n\n-- Porting note: statement changed. Mathlib 3 statement was\n-- ```\n-- @[simp] lemma to_with_top_le {x y : part_enat} :\n--   Π [decidable x.dom] [decidable y.dom], by exactI to_with_top x ≤ to_with_top y ↔ x ≤ y :=\n-- ```\n-- This used to be really slow to typecheck when the definition of `ENat`\n-- was still `deriving AddCommMonoidWithOne`. Now that I removed that it is fine.\n-- (The problem was that the last `simp` got stuck at `CharZero ℕ∞ ≟ CharZero ℕ∞` where\n-- one side used `instENatAddCommMonoidWithOne` and the other used\n-- `NonAssocSemiring.toAddCommMonoidWithOne`. Now the former doesn't exist anymore.)\n"}
{"name":"PartENat.toWithTop_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\nhx : Decidable x.Dom\nhy : Decidable y.Dom\n⊢ Iff (LE.le x.toWithTop y.toWithTop) (LE.le x y)","decl":"@[simp]\ntheorem toWithTop_le {x y : PartENat} [hx : Decidable x.Dom] [hy : Decidable y.Dom] :\n    toWithTop x ≤ toWithTop y ↔ x ≤ y := by\n  induction y using PartENat.casesOn generalizing hy\n  · simp\n  induction x using PartENat.casesOn generalizing hx\n  · simp\n  · simp -- Porting note: this takes too long.\n\n/-\nPorting note: As part of the investigation above, I noticed that Lean4 does not\nfind the following two instances which it could find in Lean3 automatically:\n```\n#synth Decidable (⊤ : PartENat).Dom\nvariable {n : ℕ}\n#synth Decidable (n : PartENat).Dom\n```\n-/\n\n"}
{"name":"PartENat.toWithTop_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\ninst✝¹ : Decidable x.Dom\ninst✝ : Decidable y.Dom\n⊢ Iff (LT.lt x.toWithTop y.toWithTop) (LT.lt x y)","decl":"@[simp]\ntheorem toWithTop_lt {x y : PartENat} [Decidable x.Dom] [Decidable y.Dom] :\n    toWithTop x < toWithTop y ↔ x < y :=\n  lt_iff_lt_of_le_iff_le toWithTop_le\n\n"}
{"name":"PartENat.ofENat_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (↑Top.top) Top.top","decl":"@[simp, norm_cast]\nlemma ofENat_top : ofENat ⊤ = ⊤ := rfl\n\n"}
{"name":"PartENat.ofENat_coe","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\n⊢ Eq ↑↑n ↑n","decl":"@[simp, norm_cast]\nlemma ofENat_coe (n : ℕ) : ofENat n = n := rfl\n\n"}
{"name":"PartENat.ofENat_zero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (↑0) 0","decl":"@[simp, norm_cast]\ntheorem ofENat_zero : ofENat 0 = 0 := rfl\n\n"}
{"name":"PartENat.ofENat_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (↑1) 1","decl":"@[simp, norm_cast]\ntheorem ofENat_one : ofENat 1 = 1 := rfl\n\n"}
{"name":"PartENat.ofENat_ofNat","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (↑(OfNat.ofNat n)) (OfNat.ofNat n)","decl":"@[simp, norm_cast]\ntheorem ofENat_ofNat (n : Nat) [n.AtLeastTwo] : ofENat ofNat(n) = OfNat.ofNat n :=\n  rfl\n\n"}
{"name":"PartENat.toWithTop_ofENat","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : ENat\nx✝ : Decidable (↑n).Dom\n⊢ Eq (↑n).toWithTop n","decl":"@[simp, norm_cast]\ntheorem toWithTop_ofENat (n : ℕ∞) {_ : Decidable (n : PartENat).Dom} : toWithTop (↑n) = n := by\n  cases n with\n  | top => simp\n  | coe n => simp\n\n"}
{"name":"PartENat.ofENat_toWithTop","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\nx✝ : Decidable x.Dom\n⊢ Eq (↑x.toWithTop) x","decl":"@[simp, norm_cast]\ntheorem ofENat_toWithTop (x : PartENat) {_ : Decidable (x : PartENat).Dom} : toWithTop x = x := by\n  induction x using PartENat.casesOn <;> simp\n\n"}
{"name":"PartENat.ofENat_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : ENat\n⊢ Iff (LE.le ↑x ↑y) (LE.le x y)","decl":"@[simp, norm_cast]\ntheorem ofENat_le {x y : ℕ∞} : ofENat x ≤ ofENat y ↔ x ≤ y := by\n  classical\n  rw [← toWithTop_le, toWithTop_ofENat, toWithTop_ofENat]\n\n"}
{"name":"PartENat.ofENat_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : ENat\n⊢ Iff (LT.lt ↑x ↑y) (LT.lt x y)","decl":"@[simp, norm_cast]\ntheorem ofENat_lt {x y : ℕ∞} : ofENat x < ofENat y ↔ x < y := by\n  classical\n  rw [← toWithTop_lt, toWithTop_ofENat, toWithTop_ofENat]\n\n"}
{"name":"PartENat.toWithTop_add","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\n⊢ Eq (HAdd.hAdd x y).toWithTop (HAdd.hAdd x.toWithTop y.toWithTop)","decl":"open scoped Classical in\n@[simp]\ntheorem toWithTop_add {x y : PartENat} : toWithTop (x + y) = toWithTop x + toWithTop y := by\n  refine PartENat.casesOn y ?_ ?_ <;> refine PartENat.casesOn x ?_ ?_\n  -- Porting note: was `simp [← Nat.cast_add, ← ENat.coe_add]`\n  · simp only [add_top, toWithTop_top', _root_.add_top]\n  · simp only [add_top, toWithTop_top', toWithTop_natCast', _root_.add_top, forall_const]\n  · simp only [top_add, toWithTop_top', toWithTop_natCast', _root_.top_add, forall_const]\n  · simp_rw [toWithTop_natCast', ← Nat.cast_add, toWithTop_natCast', forall_const]\n\n"}
{"name":"PartENat.withTopEquiv_symm_apply","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : ENat\n⊢ Eq (PartENat.withTopEquiv.symm x) ↑x","decl":"open scoped Classical in\n/-- `Equiv` between `PartENat` and `ℕ∞` (for the order isomorphism see\n`withTopOrderIso`). -/\n@[simps]\nnoncomputable def withTopEquiv : PartENat ≃ ℕ∞ where\n  toFun x := toWithTop x\n  invFun x := ↑x\n  left_inv x := by simp\n  right_inv x := by simp\n\n"}
{"name":"PartENat.withTopEquiv_apply","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x : PartENat\n⊢ Eq (PartENat.withTopEquiv x) x.toWithTop","decl":"open scoped Classical in\n/-- `Equiv` between `PartENat` and `ℕ∞` (for the order isomorphism see\n`withTopOrderIso`). -/\n@[simps]\nnoncomputable def withTopEquiv : PartENat ≃ ℕ∞ where\n  toFun x := toWithTop x\n  invFun x := ↑x\n  left_inv x := by simp\n  right_inv x := by simp\n\n"}
{"name":"PartENat.withTopEquiv_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (PartENat.withTopEquiv Top.top) Top.top","decl":"theorem withTopEquiv_top : withTopEquiv ⊤ = ⊤ := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_natCast","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\n⊢ Eq (PartENat.withTopEquiv ↑n) ↑n","decl":"theorem withTopEquiv_natCast (n : Nat) : withTopEquiv n = n := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_zero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (PartENat.withTopEquiv 0) 0","decl":"theorem withTopEquiv_zero : withTopEquiv 0 = 0 := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (PartENat.withTopEquiv 1) 1","decl":"theorem withTopEquiv_one : withTopEquiv 1 = 1 := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_ofNat","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (PartENat.withTopEquiv (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"theorem withTopEquiv_ofNat (n : Nat) [n.AtLeastTwo] :\n    withTopEquiv ofNat(n) = OfNat.ofNat n := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\n⊢ Iff (LE.le (PartENat.withTopEquiv x) (PartENat.withTopEquiv y)) (LE.le x y)","decl":"theorem withTopEquiv_le {x y : PartENat} : withTopEquiv x ≤ withTopEquiv y ↔ x ≤ y := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : PartENat\n⊢ Iff (LT.lt (PartENat.withTopEquiv x) (PartENat.withTopEquiv y)) (LT.lt x y)","decl":"theorem withTopEquiv_lt {x y : PartENat} : withTopEquiv x < withTopEquiv y ↔ x < y := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_top","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (PartENat.withTopEquiv.symm Top.top) Top.top","decl":"theorem withTopEquiv_symm_top : withTopEquiv.symm ⊤ = ⊤ := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_coe","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\n⊢ Eq (PartENat.withTopEquiv.symm ↑n) ↑n","decl":"theorem withTopEquiv_symm_coe (n : Nat) : withTopEquiv.symm n = n := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_zero","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (PartENat.withTopEquiv.symm 0) 0","decl":"theorem withTopEquiv_symm_zero : withTopEquiv.symm 0 = 0 := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_one","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ Eq (PartENat.withTopEquiv.symm 1) 1","decl":"theorem withTopEquiv_symm_one : withTopEquiv.symm 1 = 1 := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_ofNat","module":"Mathlib.Data.Nat.PartENat","initialProofState":"n : Nat\ninst✝ : n.AtLeastTwo\n⊢ Eq (PartENat.withTopEquiv.symm (OfNat.ofNat n)) (OfNat.ofNat n)","decl":"theorem withTopEquiv_symm_ofNat (n : Nat) [n.AtLeastTwo] :\n    withTopEquiv.symm ofNat(n) = OfNat.ofNat n := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : ENat\n⊢ Iff (LE.le (PartENat.withTopEquiv.symm x) (PartENat.withTopEquiv.symm y)) (LE.le x y)","decl":"theorem withTopEquiv_symm_le {x y : ℕ∞} : withTopEquiv.symm x ≤ withTopEquiv.symm y ↔ x ≤ y := by\n  simp\n\n"}
{"name":"PartENat.withTopEquiv_symm_lt","module":"Mathlib.Data.Nat.PartENat","initialProofState":"x y : ENat\n⊢ Iff (LT.lt (PartENat.withTopEquiv.symm x) (PartENat.withTopEquiv.symm y)) (LT.lt x y)","decl":"theorem withTopEquiv_symm_lt {x y : ℕ∞} : withTopEquiv.symm x < withTopEquiv.symm y ↔ x < y := by\n  simp\n\n"}
{"name":"PartENat.lt_wf","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ WellFounded fun x1 x2 => LT.lt x1 x2","decl":"theorem lt_wf : @WellFounded PartENat (· < ·) := by\n  classical\n    change WellFounded fun a b : PartENat => a < b\n    simp_rw [← withTopEquiv_lt]\n    exact InvImage.wf _ wellFounded_lt\n\n"}
{"name":"PartENat.instWellFoundedLT","module":"Mathlib.Data.Nat.PartENat","initialProofState":"⊢ WellFoundedLT PartENat","decl":"instance : WellFoundedLT PartENat :=\n  ⟨lt_wf⟩\n\n"}
{"name":"PartENat.find_get","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nh : (PartENat.find P).Dom\n⊢ Eq ((PartENat.find P).get h) (Nat.find h)","decl":"@[simp]\ntheorem find_get (h : (find P).Dom) : (find P).get h = Nat.find h :=\n  rfl\n\n"}
{"name":"PartENat.find_dom","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nh : Exists fun n => P n\n⊢ (PartENat.find P).Dom","decl":"theorem find_dom (h : ∃ n, P n) : (find P).Dom :=\n  h\n\n"}
{"name":"PartENat.lt_find","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nh : ∀ (m : Nat), LE.le m n → Not (P m)\n⊢ LT.lt (↑n) (PartENat.find P)","decl":"theorem lt_find (n : ℕ) (h : ∀ m ≤ n, ¬P m) : (n : PartENat) < find P := by\n  rw [coe_lt_iff]\n  intro h₁\n  rw [find_get]\n  have h₂ := @Nat.find_spec P _ h₁\n  revert h₂\n  contrapose!\n  exact h _\n\n"}
{"name":"PartENat.lt_find_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\n⊢ Iff (LT.lt (↑n) (PartENat.find P)) (∀ (m : Nat), LE.le m n → Not (P m))","decl":"theorem lt_find_iff (n : ℕ) : (n : PartENat) < find P ↔ ∀ m ≤ n, ¬P m := by\n  refine ⟨?_, lt_find P n⟩\n  intro h m hm\n  by_cases H : (find P).Dom\n  · apply Nat.find_min H\n    rw [coe_lt_iff] at h\n    specialize h H\n    exact lt_of_le_of_lt hm h\n  · exact not_exists.mp H m\n\n"}
{"name":"PartENat.find_le","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\nn : Nat\nh : P n\n⊢ LE.le (PartENat.find P) ↑n","decl":"theorem find_le (n : ℕ) (h : P n) : find P ≤ n := by\n  rw [le_coe_iff]\n  exact ⟨⟨_, h⟩, @Nat.find_min' P _ _ _ h⟩\n\n"}
{"name":"PartENat.find_eq_top_iff","module":"Mathlib.Data.Nat.PartENat","initialProofState":"P : Nat → Prop\ninst✝ : DecidablePred P\n⊢ Iff (Eq (PartENat.find P) Top.top) (∀ (n : Nat), Not (P n))","decl":"theorem find_eq_top_iff : find P = ⊤ ↔ ∀ n, ¬P n :=\n  (eq_top_iff_forall_lt _).trans\n    ⟨fun h n => (lt_find_iff P n).mp (h n) _ le_rfl, fun h n => lt_find P n fun _ _ => h _⟩\n\n"}
