{"name":"MeasureTheory.isStoppingTime_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\ni : ι\n⊢ MeasureTheory.IsStoppingTime f fun x => i","decl":"theorem isStoppingTime_const [Preorder ι] (f : Filtration ι m) (i : ι) :\n    IsStoppingTime f fun _ => i := fun j => by simp only [MeasurableSet.const]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le (τ ω) i)","decl":"protected theorem IsStoppingTime.measurableSet_le (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | τ ω ≤ i} :=\n  hτ i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_pred","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : PredOrder ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"theorem IsStoppingTime.measurableSet_lt_of_pred [PredOrder ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | τ ω < i} := by\n  by_cases hi_min : IsMin i\n  · suffices {ω : Ω | τ ω < i} = ∅ by rw [this]; exact @MeasurableSet.empty _ (f i)\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false]\n    rw [isMin_iff_forall_not_lt] at hi_min\n    exact hi_min (τ ω)\n  have : {ω : Ω | τ ω < i} = τ ⁻¹' Set.Iic (pred i) := by ext; simp [Iic_pred_of_not_isMin hi_min]\n  rw [this]\n  exact f.mono (pred_le i) _ (hτ.measurableSet_le <| pred i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : PartialOrder ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\ni : ι\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"protected theorem measurableSet_eq_of_countable_range (hτ : IsStoppingTime f τ)\n    (h_countable : (Set.range τ).Countable) (i : ι) : MeasurableSet[f i] {ω | τ ω = i} := by\n  have : {ω | τ ω = i} = {ω | τ ω ≤ i} \\ ⋃ (j ∈ Set.range τ) (_ : j < i), {ω | τ ω ≤ j} := by\n    ext1 a\n    simp only [Set.mem_setOf_eq, Set.mem_range, Set.iUnion_exists, Set.iUnion_iUnion_eq',\n      Set.mem_diff, Set.mem_iUnion, exists_prop, not_exists, not_and, not_le]\n    constructor <;> intro h\n    · simp only [h, lt_iff_le_not_le, le_refl, and_imp, imp_self, imp_true_iff, and_self_iff]\n    · exact h.1.eq_or_lt.resolve_right fun h_lt => h.2 a h_lt le_rfl\n  rw [this]\n  refine (hτ.measurableSet_le i).diff ?_\n  refine MeasurableSet.biUnion h_countable fun j _ => ?_\n  classical\n  rw [Set.iUnion_eq_if]\n  split_ifs with hji\n  · exact f.mono hji.le _ (hτ.measurableSet_le j)\n  · exact @MeasurableSet.empty _ (f i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : PartialOrder ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"protected theorem measurableSet_eq_of_countable [Countable ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | τ ω = i} :=\n  hτ.measurableSet_eq_of_countable_range (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : PartialOrder ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"protected theorem measurableSet_lt_of_countable_range (hτ : IsStoppingTime f τ)\n    (h_countable : (Set.range τ).Countable) (i : ι) : MeasurableSet[f i] {ω | τ ω < i} := by\n  have : {ω | τ ω < i} = {ω | τ ω ≤ i} \\ {ω | τ ω = i} := by ext1 ω; simp [lt_iff_le_and_ne]\n  rw [this]\n  exact (hτ.measurableSet_le i).diff (hτ.measurableSet_eq_of_countable_range h_countable i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : PartialOrder ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"protected theorem measurableSet_lt_of_countable [Countable ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | τ ω < i} :=\n  hτ.measurableSet_lt_of_countable_range (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nι : Type u_4\ninst✝ : LinearOrder ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le i (τ ω))","decl":"protected theorem measurableSet_ge_of_countable_range {ι} [LinearOrder ι] {τ : Ω → ι}\n    {f : Filtration ι m} (hτ : IsStoppingTime f τ) (h_countable : (Set.range τ).Countable) (i : ι) :\n    MeasurableSet[f i] {ω | i ≤ τ ω} := by\n  have : {ω | i ≤ τ ω} = {ω | τ ω < i}ᶜ := by\n    ext1 ω; simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hτ.measurableSet_lt_of_countable_range h_countable i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nι : Type u_4\ninst✝¹ : LinearOrder ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le i (τ ω))","decl":"protected theorem measurableSet_ge_of_countable {ι} [LinearOrder ι] {τ : Ω → ι} {f : Filtration ι m}\n    [Countable ι] (hτ : IsStoppingTime f τ) (i : ι) : MeasurableSet[f i] {ω | i ≤ τ ω} :=\n  hτ.measurableSet_ge_of_countable_range (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_gt","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt i (τ ω))","decl":"theorem IsStoppingTime.measurableSet_gt (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | i < τ ω} := by\n  have : {ω | i < τ ω} = {ω | τ ω ≤ i}ᶜ := by\n    ext1 ω; simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_le]\n  rw [this]\n  exact (hτ.measurableSet_le i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_isLUB","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\nh_lub : IsLUB (Set.Iio i) i\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"/-- Auxiliary lemma for `MeasureTheory.IsStoppingTime.measurableSet_lt`. -/\ntheorem IsStoppingTime.measurableSet_lt_of_isLUB (hτ : IsStoppingTime f τ) (i : ι)\n    (h_lub : IsLUB (Set.Iio i) i) : MeasurableSet[f i] {ω | τ ω < i} := by\n  by_cases hi_min : IsMin i\n  · suffices {ω | τ ω < i} = ∅ by rw [this]; exact @MeasurableSet.empty _ (f i)\n    ext1 ω\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false]\n    exact isMin_iff_forall_not_lt.mp hi_min (τ ω)\n  obtain ⟨seq, -, -, h_tendsto, h_bound⟩ :\n      ∃ seq : ℕ → ι, Monotone seq ∧ (∀ j, seq j ≤ i) ∧ Tendsto seq atTop (𝓝 i) ∧ ∀ j, seq j < i :=\n    h_lub.exists_seq_monotone_tendsto (not_isMin_iff.mp hi_min)\n  have h_Ioi_eq_Union : Set.Iio i = ⋃ j, {k | k ≤ seq j} := by\n    ext1 k\n    simp only [Set.mem_Iio, Set.mem_iUnion, Set.mem_setOf_eq]\n    refine ⟨fun hk_lt_i => ?_, fun h_exists_k_le_seq => ?_⟩\n    · rw [tendsto_atTop'] at h_tendsto\n      have h_nhds : Set.Ici k ∈ 𝓝 i :=\n        mem_nhds_iff.mpr ⟨Set.Ioi k, Set.Ioi_subset_Ici le_rfl, isOpen_Ioi, hk_lt_i⟩\n      obtain ⟨a, ha⟩ : ∃ a : ℕ, ∀ b : ℕ, b ≥ a → k ≤ seq b := h_tendsto (Set.Ici k) h_nhds\n      exact ⟨a, ha a le_rfl⟩\n    · obtain ⟨j, hk_seq_j⟩ := h_exists_k_le_seq\n      exact hk_seq_j.trans_lt (h_bound j)\n  have h_lt_eq_preimage : {ω | τ ω < i} = τ ⁻¹' Set.Iio i := by\n    ext1 ω; simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_Iio]\n  rw [h_lt_eq_preimage, h_Ioi_eq_Union]\n  simp only [Set.preimage_iUnion, Set.preimage_setOf_eq]\n  exact MeasurableSet.iUnion fun n => f.mono (h_bound n).le _ (hτ.measurableSet_le (seq n))\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"theorem IsStoppingTime.measurableSet_lt (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | τ ω < i} := by\n  obtain ⟨i', hi'_lub⟩ : ∃ i', IsLUB (Set.Iio i) i' := exists_lub_Iio i\n  cases' lub_Iio_eq_self_or_Iio_eq_Iic i hi'_lub with hi'_eq_i h_Iio_eq_Iic\n  · rw [← hi'_eq_i] at hi'_lub ⊢\n    exact hτ.measurableSet_lt_of_isLUB i' hi'_lub\n  · have h_lt_eq_preimage : {ω : Ω | τ ω < i} = τ ⁻¹' Set.Iio i := rfl\n    rw [h_lt_eq_preimage, h_Iio_eq_Iic]\n    exact f.mono (lub_Iio_le i hi'_lub) _ (hτ.measurableSet_le i')\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le i (τ ω))","decl":"theorem IsStoppingTime.measurableSet_ge (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | i ≤ τ ω} := by\n  have : {ω | i ≤ τ ω} = {ω | τ ω < i}ᶜ := by\n    ext1 ω; simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hτ.measurableSet_lt i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"theorem IsStoppingTime.measurableSet_eq (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[f i] {ω | τ ω = i} := by\n  have : {ω | τ ω = i} = {ω | τ ω ≤ i} ∩ {ω | τ ω ≥ i} := by\n    ext1 ω; simp only [Set.mem_setOf_eq, Set.mem_inter_iff, le_antisymm_iff]\n  rw [this]\n  exact (hτ.measurableSet_le i).inter (hτ.measurableSet_ge i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni j : ι\nhle : LE.le i j\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"theorem IsStoppingTime.measurableSet_eq_le (hτ : IsStoppingTime f τ) {i j : ι} (hle : i ≤ j) :\n    MeasurableSet[f j] {ω | τ ω = i} :=\n  f.mono hle _ <| hτ.measurableSet_eq i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni j : ι\nhle : LE.le i j\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"theorem IsStoppingTime.measurableSet_lt_le (hτ : IsStoppingTime f τ) {i j : ι} (hle : i ≤ j) :\n    MeasurableSet[f j] {ω | τ ω < i} :=\n  f.mono hle _ <| hτ.measurableSet_lt i\n\n"}
{"name":"MeasureTheory.isStoppingTime_of_measurableSet_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\ninst✝ : Countable ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : ∀ (i : ι), MeasurableSet (setOf fun ω => Eq (τ ω) i)\n⊢ MeasureTheory.IsStoppingTime f τ","decl":"theorem isStoppingTime_of_measurableSet_eq [Preorder ι] [Countable ι] {f : Filtration ι m}\n    {τ : Ω → ι} (hτ : ∀ i, MeasurableSet[f i] {ω | τ ω = i}) : IsStoppingTime f τ := by\n  intro i\n  rw [show {ω | τ ω ≤ i} = ⋃ k ≤ i, {ω | τ ω = k} by ext; simp]\n  refine MeasurableSet.biUnion (Set.to_countable _) fun k hk => ?_\n  exact f.mono hk _ (hτ k)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.max","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasureTheory.IsStoppingTime f fun ω => Max.max (τ ω) (π ω)","decl":"protected theorem max [LinearOrder ι] {f : Filtration ι m} {τ π : Ω → ι} (hτ : IsStoppingTime f τ)\n    (hπ : IsStoppingTime f π) : IsStoppingTime f fun ω => max (τ ω) (π ω) := by\n  intro i\n  simp_rw [max_le_iff, Set.setOf_and]\n  exact (hτ i).inter (hπ i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.max_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasureTheory.IsStoppingTime f fun ω => Max.max (τ ω) i","decl":"protected theorem max_const [LinearOrder ι] {f : Filtration ι m} {τ : Ω → ι}\n    (hτ : IsStoppingTime f τ) (i : ι) : IsStoppingTime f fun ω => max (τ ω) i :=\n  hτ.max (isStoppingTime_const f i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.min","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasureTheory.IsStoppingTime f fun ω => Min.min (τ ω) (π ω)","decl":"protected theorem min [LinearOrder ι] {f : Filtration ι m} {τ π : Ω → ι} (hτ : IsStoppingTime f τ)\n    (hπ : IsStoppingTime f π) : IsStoppingTime f fun ω => min (τ ω) (π ω) := by\n  intro i\n  simp_rw [min_le_iff, Set.setOf_or]\n  exact (hτ i).union (hπ i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.min_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasureTheory.IsStoppingTime f fun ω => Min.min (τ ω) i","decl":"protected theorem min_const [LinearOrder ι] {f : Filtration ι m} {τ : Ω → ι}\n    (hτ : IsStoppingTime f τ) (i : ι) : IsStoppingTime f fun ω => min (τ ω) i :=\n  hτ.min (isStoppingTime_const f i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.add_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : AddGroup ι\ninst✝² : Preorder ι\ninst✝¹ : AddRightMono ι\ninst✝ : AddLeftMono ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\nhi : LE.le 0 i\n⊢ MeasureTheory.IsStoppingTime f fun ω => HAdd.hAdd (τ ω) i","decl":"theorem add_const [AddGroup ι] [Preorder ι] [AddRightMono ι]\n    [AddLeftMono ι] {f : Filtration ι m} {τ : Ω → ι} (hτ : IsStoppingTime f τ)\n    {i : ι} (hi : 0 ≤ i) : IsStoppingTime f fun ω => τ ω + i := by\n  intro j\n  simp_rw [← le_sub_iff_add_le]\n  exact f.mono (sub_le_self j hi) _ (hτ (j - i))\n\n"}
{"name":"MeasureTheory.IsStoppingTime.add_const_nat","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nf : MeasureTheory.Filtration Nat m\nτ : Ω → Nat\nhτ : MeasureTheory.IsStoppingTime f τ\ni : Nat\n⊢ MeasureTheory.IsStoppingTime f fun ω => HAdd.hAdd (τ ω) i","decl":"theorem add_const_nat {f : Filtration ℕ m} {τ : Ω → ℕ} (hτ : IsStoppingTime f τ) {i : ℕ} :\n    IsStoppingTime f fun ω => τ ω + i := by\n  refine isStoppingTime_of_measurableSet_eq fun j => ?_\n  by_cases hij : i ≤ j\n  · simp_rw [eq_comm, ← Nat.sub_eq_iff_eq_add hij, eq_comm]\n    exact f.mono (j.sub_le i) _ (hτ.measurableSet_eq (j - i))\n  · rw [not_le] at hij\n    convert @MeasurableSet.empty _ (f.1 j)\n    ext ω\n    simp only [Set.mem_empty_iff_false, iff_false, Set.mem_setOf]\n    omega\n\n-- generalize to certain countable type?\n"}
{"name":"MeasureTheory.IsStoppingTime.add","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nf : MeasureTheory.Filtration Nat m\nτ π : Ω → Nat\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasureTheory.IsStoppingTime f (HAdd.hAdd τ π)","decl":"theorem add {f : Filtration ℕ m} {τ π : Ω → ℕ} (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π) :\n    IsStoppingTime f (τ + π) := by\n  intro i\n  rw [(_ : {ω | (τ + π) ω ≤ i} = ⋃ k ≤ i, {ω | π ω = k} ∩ {ω | τ ω + k ≤ i})]\n  · exact MeasurableSet.iUnion fun k =>\n      MeasurableSet.iUnion fun hk => (hπ.measurableSet_eq_le hk).inter (hτ.add_const_nat i)\n  ext ω\n  simp only [Pi.add_apply, Set.mem_setOf_eq, Set.mem_iUnion, Set.mem_inter_iff, exists_prop]\n  refine ⟨fun h => ⟨π ω, by omega, rfl, h⟩, ?_⟩\n  rintro ⟨j, hj, rfl, h⟩\n  assumption\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ns : Set Ω\n⊢ Iff (MeasurableSet s) (∀ (i : ι), MeasurableSet (Inter.inter s (setOf fun ω => LE.le (τ ω) i)))","decl":"protected theorem measurableSet (hτ : IsStoppingTime f τ) (s : Set Ω) :\n    MeasurableSet[hτ.measurableSpace] s ↔ ∀ i : ι, MeasurableSet[f i] (s ∩ {ω | τ ω ≤ i}) :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_mono","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\nhle : LE.le τ π\n⊢ LE.le hτ.measurableSpace hπ.measurableSpace","decl":"theorem measurableSpace_mono (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π) (hle : τ ≤ π) :\n    hτ.measurableSpace ≤ hπ.measurableSpace := by\n  intro s hs i\n  rw [(_ : s ∩ {ω | π ω ≤ i} = s ∩ {ω | τ ω ≤ i} ∩ {ω | π ω ≤ i})]\n  · exact (hs i).inter (hπ i)\n  · ext\n    simp only [Set.mem_inter_iff, iff_self_and, and_congr_left_iff, Set.mem_setOf_eq]\n    intro hle' _\n    exact le_trans (hle _) hle'\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ LE.le hτ.measurableSpace m","decl":"theorem measurableSpace_le_of_countable [Countable ι] (hτ : IsStoppingTime f τ) :\n    hτ.measurableSpace ≤ m := by\n  intro s hs\n  change ∀ i, MeasurableSet[f i] (s ∩ {ω | τ ω ≤ i}) at hs\n  rw [(_ : s = ⋃ i, s ∩ {ω | τ ω ≤ i})]\n  · exact MeasurableSet.iUnion fun i => f.le i _ (hs i)\n  · ext ω; constructor <;> rw [Set.mem_iUnion]\n    · exact fun hx => ⟨τ ω, hx, le_rfl⟩\n    · rintro ⟨_, hx, _⟩\n      exact hx\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝¹ : Filter.atTop.IsCountablyGenerated\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ LE.le hτ.measurableSpace m","decl":"theorem measurableSpace_le [IsCountablyGenerated (atTop : Filter ι)] [IsDirected ι (· ≤ ·)]\n    (hτ : IsStoppingTime f τ) : hτ.measurableSpace ≤ m := by\n  intro s hs\n  cases isEmpty_or_nonempty ι\n  · haveI : IsEmpty Ω := ⟨fun ω => IsEmpty.false (τ ω)⟩\n    apply Subsingleton.measurableSet\n  · change ∀ i, MeasurableSet[f i] (s ∩ {ω | τ ω ≤ i}) at hs\n    obtain ⟨seq : ℕ → ι, h_seq_tendsto⟩ := (atTop : Filter ι).exists_seq_tendsto\n    rw [(_ : s = ⋃ n, s ∩ {ω | τ ω ≤ seq n})]\n    · exact MeasurableSet.iUnion fun i => f.le (seq i) _ (hs (seq i))\n    · ext ω; constructor <;> rw [Set.mem_iUnion]\n      · intro hx\n        suffices ∃ i, τ ω ≤ seq i from ⟨this.choose, hx, this.choose_spec⟩\n        rw [tendsto_atTop] at h_seq_tendsto\n        exact (h_seq_tendsto (τ ω)).exists\n      · rintro ⟨_, hx, _⟩\n        exact hx\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝² : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝¹ : Filter.atTop.IsCountablyGenerated\ninst✝ : IsDirected ι fun x1 x2 => LE.le x1 x2\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ LE.le hτ.measurableSpace m","decl":"@[deprecated (since := \"2024-12-25\")] alias measurableSpace_le' := measurableSpace_le\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\ni : ι\n⊢ Eq ⋯.measurableSpace (↑f i)","decl":"@[simp]\ntheorem measurableSpace_const (f : Filtration ι m) (i : ι) :\n    (isStoppingTime_const f i).measurableSpace = f i := by\n  ext1 s\n  change MeasurableSet[(isStoppingTime_const f i).measurableSpace] s ↔ MeasurableSet[f i] s\n  rw [IsStoppingTime.measurableSet]\n  constructor <;> intro h\n  · specialize h i\n    simpa only [le_refl, Set.setOf_true, Set.inter_univ] using h\n  · intro j\n    by_cases hij : i ≤ j\n    · simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    · simp only [hij, Set.setOf_false, Set.inter_empty, @MeasurableSet.empty _ (f.1 j)]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_eq_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ns : Set Ω\ni : ι\n⊢ Iff (MeasurableSet (Inter.inter s (setOf fun ω => Eq (τ ω) i))) (MeasurableSet (Inter.inter s (setOf fun ω => Eq (τ ω) i)))","decl":"theorem measurableSet_inter_eq_iff (hτ : IsStoppingTime f τ) (s : Set Ω) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] (s ∩ {ω | τ ω = i}) ↔\n      MeasurableSet[f i] (s ∩ {ω | τ ω = i}) := by\n  have : ∀ j, {ω : Ω | τ ω = i} ∩ {ω : Ω | τ ω ≤ j} = {ω : Ω | τ ω = i} ∩ {_ω | i ≤ j} := by\n    intro j\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    intro hxi\n    rw [hxi]\n  constructor <;> intro h\n  · specialize h i\n    simpa only [Set.inter_assoc, this, le_refl, Set.setOf_true, Set.inter_univ] using h\n  · intro j\n    rw [Set.inter_assoc, this]\n    by_cases hij : i ≤ j\n    · simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    · simp [hij]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_le_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\nhτ_le : ∀ (ω : Ω), LE.le (τ ω) i\n⊢ LE.le hτ.measurableSpace (↑f i)","decl":"theorem measurableSpace_le_of_le_const (hτ : IsStoppingTime f τ) {i : ι} (hτ_le : ∀ ω, τ ω ≤ i) :\n    hτ.measurableSpace ≤ f i :=\n  (measurableSpace_mono hτ _ hτ_le).trans (measurableSpace_const _ _).le\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nn : ι\nhτ_le : ∀ (ω : Ω), LE.le (τ ω) n\n⊢ LE.le hτ.measurableSpace m","decl":"theorem measurableSpace_le_of_le (hτ : IsStoppingTime f τ) {n : ι} (hτ_le : ∀ ω, τ ω ≤ n) :\n    hτ.measurableSpace ≤ m :=\n  (hτ.measurableSpace_le_of_le_const hτ_le).trans (f.le n)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.le_measurableSpace_of_const_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : Preorder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\nhτ_le : ∀ (ω : Ω), LE.le i (τ ω)\n⊢ LE.le (↑f i) hτ.measurableSpace","decl":"theorem le_measurableSpace_of_const_le (hτ : IsStoppingTime f τ) {i : ι} (hτ_le : ∀ ω, i ≤ τ ω) :\n    f i ≤ hτ.measurableSpace :=\n  (measurableSpace_const _ _).symm.le.trans (measurableSpace_mono _ hτ hτ_le)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.sigmaFinite_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nι : Type u_4\ninst✝³ : SemilatticeSup ι\ninst✝² : OrderBot ι\ninst✝¹ : Filter.atTop.IsCountablyGenerated\nμ : MeasureTheory.Measure Ω\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : MeasureTheory.SigmaFiniteFiltration μ f\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ MeasureTheory.SigmaFinite (μ.trim ⋯)","decl":"instance sigmaFinite_stopping_time {ι} [SemilatticeSup ι] [OrderBot ι]\n    [(Filter.atTop : Filter ι).IsCountablyGenerated] {μ : Measure Ω} {f : Filtration ι m}\n    {τ : Ω → ι} [SigmaFiniteFiltration μ f] (hτ : IsStoppingTime f τ) :\n    SigmaFinite (μ.trim hτ.measurableSpace_le) := by\n  refine @sigmaFiniteTrim_mono _ _ ?_ _ _ _ ?_ ?_\n  · exact f ⊥\n  · exact hτ.le_measurableSpace_of_const_le fun _ => bot_le\n  · infer_instance\n\n"}
{"name":"MeasureTheory.IsStoppingTime.sigmaFinite_stopping_time_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nm : MeasurableSpace Ω\nι : Type u_4\ninst✝² : SemilatticeSup ι\ninst✝¹ : OrderBot ι\nμ : MeasureTheory.Measure Ω\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : MeasureTheory.SigmaFiniteFiltration μ f\nhτ : MeasureTheory.IsStoppingTime f τ\nn : ι\nhτ_le : ∀ (ω : Ω), LE.le (τ ω) n\n⊢ MeasureTheory.SigmaFinite (μ.trim ⋯)","decl":"instance sigmaFinite_stopping_time_of_le {ι} [SemilatticeSup ι] [OrderBot ι] {μ : Measure Ω}\n    {f : Filtration ι m} {τ : Ω → ι} [SigmaFiniteFiltration μ f] (hτ : IsStoppingTime f τ) {n : ι}\n    (hτ_le : ∀ ω, τ ω ≤ n) : SigmaFinite (μ.trim (hτ.measurableSpace_le_of_le hτ_le)) := by\n  refine @sigmaFiniteTrim_mono _ _ ?_ _ _ _ ?_ ?_\n  · exact f ⊥\n  · exact hτ.le_measurableSpace_of_const_le fun _ => bot_le\n  · infer_instance\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_le'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le (τ ω) i)","decl":"protected theorem measurableSet_le' (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω ≤ i} := by\n  intro j\n  have : {ω : Ω | τ ω ≤ i} ∩ {ω : Ω | τ ω ≤ j} = {ω : Ω | τ ω ≤ min i j} := by\n    ext1 ω; simp only [Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff]\n  rw [this]\n  exact f.mono (min_le_right i j) _ (hτ _)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_gt'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt i (τ ω))","decl":"protected theorem measurableSet_gt' (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | i < τ ω} := by\n  have : {ω : Ω | i < τ ω} = {ω : Ω | τ ω ≤ i}ᶜ := by ext1 ω; simp\n  rw [this]\n  exact (hτ.measurableSet_le' i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"protected theorem measurableSet_eq' [TopologicalSpace ι] [OrderTopology ι]\n    [FirstCountableTopology ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω = i} := by\n  rw [← Set.univ_inter {ω | τ ω = i}, measurableSet_inter_eq_iff, Set.univ_inter]\n  exact hτ.measurableSet_eq i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le i (τ ω))","decl":"protected theorem measurableSet_ge' [TopologicalSpace ι] [OrderTopology ι]\n    [FirstCountableTopology ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | i ≤ τ ω} := by\n  have : {ω | i ≤ τ ω} = {ω | τ ω = i} ∪ {ω | i < τ ω} := by\n    ext1 ω\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm]\n  rw [this]\n  exact (hτ.measurableSet_eq' i).union (hτ.measurableSet_gt' i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝³ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝² : TopologicalSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : FirstCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"protected theorem measurableSet_lt' [TopologicalSpace ι] [OrderTopology ι]\n    [FirstCountableTopology ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω < i} := by\n  have : {ω | τ ω < i} = {ω | τ ω ≤ i} \\ {ω | τ ω = i} := by\n    ext1 ω\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hτ.measurableSet_le' i).diff (hτ.measurableSet_eq' i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable_range'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\ni : ι\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"protected theorem measurableSet_eq_of_countable_range' (hτ : IsStoppingTime f τ)\n    (h_countable : (Set.range τ).Countable) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω = i} := by\n  rw [← Set.univ_inter {ω | τ ω = i}, measurableSet_inter_eq_iff, Set.univ_inter]\n  exact hτ.measurableSet_eq_of_countable_range h_countable i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) i)","decl":"protected theorem measurableSet_eq_of_countable' [Countable ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω = i} :=\n  hτ.measurableSet_eq_of_countable_range' (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable_range'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le i (τ ω))","decl":"protected theorem measurableSet_ge_of_countable_range' (hτ : IsStoppingTime f τ)\n    (h_countable : (Set.range τ).Countable) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | i ≤ τ ω} := by\n  have : {ω | i ≤ τ ω} = {ω | τ ω = i} ∪ {ω | i < τ ω} := by\n    ext1 ω\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm]\n  rw [this]\n  exact (hτ.measurableSet_eq_of_countable_range' h_countable i).union (hτ.measurableSet_gt' i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LE.le i (τ ω))","decl":"protected theorem measurableSet_ge_of_countable' [Countable ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | i ≤ τ ω} :=\n  hτ.measurableSet_ge_of_countable_range' (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable_range'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"protected theorem measurableSet_lt_of_countable_range' (hτ : IsStoppingTime f τ)\n    (h_countable : (Set.range τ).Countable) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω < i} := by\n  have : {ω | τ ω < i} = {ω | τ ω ≤ i} \\ {ω | τ ω = i} := by\n    ext1 ω\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hτ.measurableSet_le' i).diff (hτ.measurableSet_eq_of_countable_range' h_countable i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝ : Countable ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasurableSet (setOf fun ω => LT.lt (τ ω) i)","decl":"protected theorem measurableSet_lt_of_countable' [Countable ι] (hτ : IsStoppingTime f τ) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω < i} :=\n  hτ.measurableSet_lt_of_countable_range' (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nh_countable : (Set.range τ).Countable\n⊢ LE.le hτ.measurableSpace m","decl":"protected theorem measurableSpace_le_of_countable_range (hτ : IsStoppingTime f τ)\n    (h_countable : (Set.range τ).Countable) : hτ.measurableSpace ≤ m := by\n  intro s hs\n  change ∀ i, MeasurableSet[f i] (s ∩ {ω | τ ω ≤ i}) at hs\n  rw [(_ : s = ⋃ i ∈ Set.range τ, s ∩ {ω | τ ω ≤ i})]\n  · exact MeasurableSet.biUnion h_countable fun i _ => f.le i _ (hs i)\n  · ext ω\n    constructor <;> rw [Set.mem_iUnion]\n    · exact fun hx => ⟨τ ω, by simpa using hx⟩\n    · rintro ⟨i, hx⟩\n      simp only [Set.mem_range, Set.iUnion_exists, Set.mem_iUnion, Set.mem_inter_iff,\n        Set.mem_setOf_eq, exists_prop, exists_and_right] at hx\n      exact hx.2.1\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : MeasurableSpace ι\ninst✝² : BorelSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : SecondCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ Measurable τ","decl":"protected theorem measurable [TopologicalSpace ι] [MeasurableSpace ι] [BorelSpace ι]\n    [OrderTopology ι] [SecondCountableTopology ι] (hτ : IsStoppingTime f τ) :\n    Measurable[hτ.measurableSpace] τ :=\n  @measurable_of_Iic ι Ω _ _ _ hτ.measurableSpace _ _ _ _ fun i => hτ.measurableSet_le' i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurable_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : MeasurableSpace ι\ninst✝² : BorelSpace ι\ninst✝¹ : OrderTopology ι\ninst✝ : SecondCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\nhτ_le : ∀ (ω : Ω), LE.le (τ ω) i\n⊢ Measurable τ","decl":"protected theorem measurable_of_le [TopologicalSpace ι] [MeasurableSpace ι] [BorelSpace ι]\n    [OrderTopology ι] [SecondCountableTopology ι] (hτ : IsStoppingTime f τ) {i : ι}\n    (hτ_le : ∀ ω, τ ω ≤ i) : Measurable[f i] τ :=\n  hτ.measurable.mono (measurableSpace_le_of_le_const _ hτ_le) le_rfl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_min","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ Eq ⋯.measurableSpace (Min.min hτ.measurableSpace hπ.measurableSpace)","decl":"theorem measurableSpace_min (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π) :\n    (hτ.min hπ).measurableSpace = hτ.measurableSpace ⊓ hπ.measurableSpace := by\n  refine le_antisymm ?_ ?_\n  · exact le_inf (measurableSpace_mono _ hτ fun _ => min_le_left _ _)\n      (measurableSpace_mono _ hπ fun _ => min_le_right _ _)\n  · intro s\n    change MeasurableSet[hτ.measurableSpace] s ∧ MeasurableSet[hπ.measurableSpace] s →\n      MeasurableSet[(hτ.min hπ).measurableSpace] s\n    simp_rw [IsStoppingTime.measurableSet]\n    have : ∀ i, {ω | min (τ ω) (π ω) ≤ i} = {ω | τ ω ≤ i} ∪ {ω | π ω ≤ i} := by\n      intro i; ext1 ω; simp\n    simp_rw [this, Set.inter_union_distrib_left]\n    exact fun h i => (h.left i).union (h.right i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_min_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\ns : Set Ω\n⊢ Iff (MeasurableSet s) (And (MeasurableSet s) (MeasurableSet s))","decl":"theorem measurableSet_min_iff (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π) (s : Set Ω) :\n    MeasurableSet[(hτ.min hπ).measurableSpace] s ↔\n      MeasurableSet[hτ.measurableSpace] s ∧ MeasurableSet[hπ.measurableSpace] s := by\n  rw [measurableSpace_min hτ hπ]; rfl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_min_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ Eq ⋯.measurableSpace (Min.min hτ.measurableSpace (↑f i))","decl":"theorem measurableSpace_min_const (hτ : IsStoppingTime f τ) {i : ι} :\n    (hτ.min_const i).measurableSpace = hτ.measurableSpace ⊓ f i := by\n  rw [hτ.measurableSpace_min (isStoppingTime_const _ i), measurableSpace_const]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_min_const_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ns : Set Ω\ni : ι\n⊢ Iff (MeasurableSet s) (And (MeasurableSet s) (MeasurableSet s))","decl":"theorem measurableSet_min_const_iff (hτ : IsStoppingTime f τ) (s : Set Ω) {i : ι} :\n    MeasurableSet[(hτ.min_const i).measurableSpace] s ↔\n      MeasurableSet[hτ.measurableSpace] s ∧ MeasurableSet[f i] s := by\n  rw [measurableSpace_min_const hτ]; apply MeasurableSpace.measurableSet_inf\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : OrderTopology ι\ninst✝¹ : MeasurableSpace ι\ninst✝ : BorelSpace ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\ns : Set Ω\nhs : MeasurableSet s\n⊢ MeasurableSet (Inter.inter s (setOf fun ω => LE.le (τ ω) (π ω)))","decl":"theorem measurableSet_inter_le [TopologicalSpace ι] [SecondCountableTopology ι] [OrderTopology ι]\n    [MeasurableSpace ι] [BorelSpace ι] (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π)\n    (s : Set Ω) (hs : MeasurableSet[hτ.measurableSpace] s) :\n    MeasurableSet[(hτ.min hπ).measurableSpace] (s ∩ {ω | τ ω ≤ π ω}) := by\n  simp_rw [IsStoppingTime.measurableSet] at hs ⊢\n  intro i\n  have : s ∩ {ω | τ ω ≤ π ω} ∩ {ω | min (τ ω) (π ω) ≤ i} =\n      s ∩ {ω | τ ω ≤ i} ∩ {ω | min (τ ω) (π ω) ≤ i} ∩\n        {ω | min (τ ω) i ≤ min (min (τ ω) (π ω)) i} := by\n    ext1 ω\n    simp only [min_le_iff, Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff, le_refl, true_and,\n      true_or]\n    by_cases hτi : τ ω ≤ i\n    · simp only [hτi, true_or, and_true, and_congr_right_iff]\n      intro\n      constructor <;> intro h\n      · exact Or.inl h\n      · cases' h with h h\n        · exact h\n        · exact hτi.trans h\n    simp only [hτi, false_or, and_false, false_and, iff_false, not_and, not_le, and_imp]\n    refine fun _ hτ_le_π => lt_of_lt_of_le ?_ hτ_le_π\n    rw [← not_le]\n    exact hτi\n  rw [this]\n  refine ((hs i).inter ((hτ.min hπ) i)).inter ?_\n  apply @measurableSet_le _ _ _ _ _ (Filtration.seq f i) _ _ _ _ _ ?_ ?_\n  · exact (hτ.min_const i).measurable_of_le fun _ => min_le_right _ _\n  · exact ((hτ.min hπ).min_const i).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_le_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : OrderTopology ι\ninst✝¹ : MeasurableSpace ι\ninst✝ : BorelSpace ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\ns : Set Ω\n⊢ Iff (MeasurableSet (Inter.inter s (setOf fun ω => LE.le (τ ω) (π ω)))) (MeasurableSet (Inter.inter s (setOf fun ω => LE.le (τ ω) (π ω))))","decl":"theorem measurableSet_inter_le_iff [TopologicalSpace ι] [SecondCountableTopology ι]\n    [OrderTopology ι] [MeasurableSpace ι] [BorelSpace ι] (hτ : IsStoppingTime f τ)\n    (hπ : IsStoppingTime f π) (s : Set Ω) :\n    MeasurableSet[hτ.measurableSpace] (s ∩ {ω | τ ω ≤ π ω}) ↔\n      MeasurableSet[(hτ.min hπ).measurableSpace] (s ∩ {ω | τ ω ≤ π ω}) := by\n  constructor <;> intro h\n  · have : s ∩ {ω | τ ω ≤ π ω} = s ∩ {ω | τ ω ≤ π ω} ∩ {ω | τ ω ≤ π ω} := by\n      rw [Set.inter_assoc, Set.inter_self]\n    rw [this]\n    exact measurableSet_inter_le _ hπ _ h\n  · rw [measurableSet_min_iff hτ hπ] at h\n    exact h.1\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_le_const_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ : Ω → ι\nhτ : MeasureTheory.IsStoppingTime f τ\ns : Set Ω\ni : ι\n⊢ Iff (MeasurableSet (Inter.inter s (setOf fun ω => LE.le (τ ω) i))) (MeasurableSet (Inter.inter s (setOf fun ω => LE.le (τ ω) i)))","decl":"theorem measurableSet_inter_le_const_iff (hτ : IsStoppingTime f τ) (s : Set Ω) (i : ι) :\n    MeasurableSet[hτ.measurableSpace] (s ∩ {ω | τ ω ≤ i}) ↔\n      MeasurableSet[(hτ.min_const i).measurableSpace] (s ∩ {ω | τ ω ≤ i}) := by\n  rw [IsStoppingTime.measurableSet_min_iff hτ (isStoppingTime_const _ i),\n    IsStoppingTime.measurableSpace_const, IsStoppingTime.measurableSet]\n  refine ⟨fun h => ⟨h, ?_⟩, fun h j => h.1 j⟩\n  specialize h i\n  rwa [Set.inter_assoc, Set.inter_self] at h\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_le_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : OrderTopology ι\ninst✝¹ : MeasurableSpace ι\ninst✝ : BorelSpace ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasurableSet (setOf fun ω => LE.le (τ ω) (π ω))","decl":"theorem measurableSet_le_stopping_time [TopologicalSpace ι] [SecondCountableTopology ι]\n    [OrderTopology ι] [MeasurableSpace ι] [BorelSpace ι] (hτ : IsStoppingTime f τ)\n    (hπ : IsStoppingTime f π) : MeasurableSet[hτ.measurableSpace] {ω | τ ω ≤ π ω} := by\n  rw [hτ.measurableSet]\n  intro j\n  have : {ω | τ ω ≤ π ω} ∩ {ω | τ ω ≤ j} = {ω | min (τ ω) j ≤ min (π ω) j} ∩ {ω | τ ω ≤ j} := by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, min_le_iff, le_min_iff, le_refl,\n      and_congr_left_iff]\n    intro h\n    simp only [h, or_self_iff, and_true]\n    rw [Iff.comm, or_iff_left_iff_imp]\n    exact h.trans\n  rw [this]\n  refine MeasurableSet.inter ?_ (hτ.measurableSet_le j)\n  apply @measurableSet_le _ _ _ _ _ (Filtration.seq f j) _ _ _ _ _ ?_ ?_\n  · exact (hτ.min_const j).measurable_of_le fun _ => min_le_right _ _\n  · exact (hπ.min_const j).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_stopping_time_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : OrderTopology ι\ninst✝¹ : MeasurableSpace ι\ninst✝ : BorelSpace ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasurableSet (setOf fun ω => LE.le (τ ω) (π ω))","decl":"theorem measurableSet_stopping_time_le [TopologicalSpace ι] [SecondCountableTopology ι]\n    [OrderTopology ι] [MeasurableSpace ι] [BorelSpace ι] (hτ : IsStoppingTime f τ)\n    (hπ : IsStoppingTime f π) : MeasurableSet[hπ.measurableSpace] {ω | τ ω ≤ π ω} := by\n  suffices MeasurableSet[(hτ.min hπ).measurableSpace] {ω : Ω | τ ω ≤ π ω} by\n    rw [measurableSet_min_iff hτ hπ] at this; exact this.2\n  rw [← Set.univ_inter {ω : Ω | τ ω ≤ π ω}, ← hτ.measurableSet_inter_le_iff hπ, Set.univ_inter]\n  exact measurableSet_le_stopping_time hτ hπ\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁸ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\ninst✝⁷ : AddGroup ι\ninst✝⁶ : TopologicalSpace ι\ninst✝⁵ : MeasurableSpace ι\ninst✝⁴ : BorelSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : MeasurableSingletonClass ι\ninst✝¹ : SecondCountableTopology ι\ninst✝ : MeasurableSub₂ ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) (π ω))","decl":"theorem measurableSet_eq_stopping_time [AddGroup ι] [TopologicalSpace ι] [MeasurableSpace ι]\n    [BorelSpace ι] [OrderTopology ι] [MeasurableSingletonClass ι] [SecondCountableTopology ι]\n    [MeasurableSub₂ ι] (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω = π ω} := by\n  rw [hτ.measurableSet]\n  intro j\n  have : {ω | τ ω = π ω} ∩ {ω | τ ω ≤ j} =\n      {ω | min (τ ω) j = min (π ω) j} ∩ {ω | τ ω ≤ j} ∩ {ω | π ω ≤ j} := by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine ⟨fun h => ⟨⟨?_, h.2⟩, ?_⟩, fun h => ⟨?_, h.1.2⟩⟩\n    · rw [h.1]\n    · rw [← h.1]; exact h.2\n    · cases' h with h' hσ_le\n      cases' h' with h_eq hτ_le\n      rwa [min_eq_left hτ_le, min_eq_left hσ_le] at h_eq\n  rw [this]\n  refine\n    MeasurableSet.inter (MeasurableSet.inter ?_ (hτ.measurableSet_le j)) (hπ.measurableSet_le j)\n  apply measurableSet_eq_fun\n  · exact (hτ.min_const j).measurable_of_le fun _ => min_le_right _ _\n  · exact (hπ.min_const j).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_stopping_time_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁷ : LinearOrder ι\nf : MeasureTheory.Filtration ι m\nτ π : Ω → ι\ninst✝⁶ : Countable ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : MeasurableSpace ι\ninst✝³ : BorelSpace ι\ninst✝² : OrderTopology ι\ninst✝¹ : MeasurableSingletonClass ι\ninst✝ : SecondCountableTopology ι\nhτ : MeasureTheory.IsStoppingTime f τ\nhπ : MeasureTheory.IsStoppingTime f π\n⊢ MeasurableSet (setOf fun ω => Eq (τ ω) (π ω))","decl":"theorem measurableSet_eq_stopping_time_of_countable [Countable ι] [TopologicalSpace ι]\n    [MeasurableSpace ι] [BorelSpace ι] [OrderTopology ι] [MeasurableSingletonClass ι]\n    [SecondCountableTopology ι] (hτ : IsStoppingTime f τ) (hπ : IsStoppingTime f π) :\n    MeasurableSet[hτ.measurableSpace] {ω | τ ω = π ω} := by\n  rw [hτ.measurableSet]\n  intro j\n  have : {ω | τ ω = π ω} ∩ {ω | τ ω ≤ j} =\n      {ω | min (τ ω) j = min (π ω) j} ∩ {ω | τ ω ≤ j} ∩ {ω | π ω ≤ j} := by\n    ext1 ω\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine ⟨fun h => ⟨⟨?_, h.2⟩, ?_⟩, fun h => ⟨?_, h.1.2⟩⟩\n    · rw [h.1]\n    · rw [← h.1]; exact h.2\n    · cases' h with h' hπ_le\n      cases' h' with h_eq hτ_le\n      rwa [min_eq_left hτ_le, min_eq_left hπ_le] at h_eq\n  rw [this]\n  refine\n    MeasurableSet.inter (MeasurableSet.inter ?_ (hτ.measurableSet_le j)) (hπ.measurableSet_le j)\n  apply measurableSet_eq_fun_of_countable\n  · exact (hτ.min_const j).measurable_of_le fun _ => min_le_right _ _\n  · exact (hπ.min_const j).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.stoppedValue_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nu : ι → Ω → β\ni : ι\n⊢ Eq (MeasureTheory.stoppedValue u fun x => i) (u i)","decl":"theorem stoppedValue_const (u : ι → Ω → β) (i : ι) : (stoppedValue u fun _ => i) = u i :=\n  rfl\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : LinearOrder ι\nu : ι → Ω → β\nτ : Ω → ι\n⊢ Eq (MeasureTheory.stoppedProcess u τ) fun i => MeasureTheory.stoppedValue u fun ω => Min.min i (τ ω)","decl":"theorem stoppedProcess_eq_stoppedValue {u : ι → Ω → β} {τ : Ω → ι} :\n    stoppedProcess u τ = fun i => stoppedValue u fun ω => min i (τ ω) :=\n  rfl\n\n"}
{"name":"MeasureTheory.stoppedValue_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : LinearOrder ι\nu : ι → Ω → β\nτ σ : Ω → ι\n⊢ Eq (MeasureTheory.stoppedValue (MeasureTheory.stoppedProcess u τ) σ) (MeasureTheory.stoppedValue u fun ω => Min.min (σ ω) (τ ω))","decl":"theorem stoppedValue_stoppedProcess {u : ι → Ω → β} {τ σ : Ω → ι} :\n    stoppedValue (stoppedProcess u τ) σ = stoppedValue u fun ω => min (σ ω) (τ ω) :=\n  rfl\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : LinearOrder ι\nu : ι → Ω → β\nτ : Ω → ι\ni : ι\nω : Ω\nh : LE.le i (τ ω)\n⊢ Eq (MeasureTheory.stoppedProcess u τ i ω) (u i ω)","decl":"theorem stoppedProcess_eq_of_le {u : ι → Ω → β} {τ : Ω → ι} {i : ι} {ω : Ω} (h : i ≤ τ ω) :\n    stoppedProcess u τ i ω = u i ω := by simp [stoppedProcess, min_eq_left h]\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_of_ge","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\ninst✝ : LinearOrder ι\nu : ι → Ω → β\nτ : Ω → ι\ni : ι\nω : Ω\nh : LE.le (τ ω) i\n⊢ Eq (MeasureTheory.stoppedProcess u τ i ω) (u (τ ω) ω)","decl":"theorem stoppedProcess_eq_of_ge {u : ι → Ω → β} {τ : Ω → ι} {i : ι} {ω : Ω} (h : τ ω ≤ i) :\n    stoppedProcess u τ i ω = u (τ ω) ω := by simp [stoppedProcess, min_eq_right h]\n\n"}
{"name":"MeasureTheory.progMeasurable_min_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁶ : LinearOrder ι\ninst✝⁵ : MeasurableSpace ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : SecondCountableTopology ι\ninst✝¹ : BorelSpace ι\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : TopologicalSpace.MetrizableSpace ι\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ MeasureTheory.ProgMeasurable f fun i ω => Min.min i (τ ω)","decl":"theorem progMeasurable_min_stopping_time [MetrizableSpace ι] (hτ : IsStoppingTime f τ) :\n    ProgMeasurable f fun i ω => min i (τ ω) := by\n  intro i\n  let m_prod : MeasurableSpace (Set.Iic i × Ω) := Subtype.instMeasurableSpace.prod (f i)\n  let m_set : ∀ t : Set (Set.Iic i × Ω), MeasurableSpace t := fun _ =>\n    @Subtype.instMeasurableSpace (Set.Iic i × Ω) _ m_prod\n  let s := {p : Set.Iic i × Ω | τ p.2 ≤ i}\n  have hs : MeasurableSet[m_prod] s := @measurable_snd (Set.Iic i) Ω _ (f i) _ (hτ i)\n  have h_meas_fst : ∀ t : Set (Set.Iic i × Ω),\n      Measurable[m_set t] fun x : t => ((x : Set.Iic i × Ω).fst : ι) :=\n    fun t => (@measurable_subtype_coe (Set.Iic i × Ω) m_prod _).fst.subtype_val\n  apply Measurable.stronglyMeasurable\n  refine measurable_of_restrict_of_restrict_compl hs ?_ ?_\n  · refine @Measurable.min _ _ _ _ _ (m_set s) _ _ _ _ _ (h_meas_fst s) ?_\n    refine @measurable_of_Iic ι s _ _ _ (m_set s) _ _ _ _ fun j => ?_\n    have h_set_eq : (fun x : s => τ (x : Set.Iic i × Ω).snd) ⁻¹' Set.Iic j =\n        (fun x : s => (x : Set.Iic i × Ω).snd) ⁻¹' {ω | τ ω ≤ min i j} := by\n      ext1 ω\n      simp only [Set.mem_preimage, Set.mem_Iic, iff_and_self, le_min_iff, Set.mem_setOf_eq]\n      exact fun _ => ω.prop\n    rw [h_set_eq]\n    suffices h_meas : @Measurable _ _ (m_set s) (f i) fun x : s ↦ (x : Set.Iic i × Ω).snd from\n      h_meas (f.mono (min_le_left _ _) _ (hτ.measurableSet_le (min i j)))\n    exact measurable_snd.comp (@measurable_subtype_coe _ m_prod _)\n  · letI sc := sᶜ\n    suffices h_min_eq_left :\n      (fun x : sc => min (↑(x : Set.Iic i × Ω).fst) (τ (x : Set.Iic i × Ω).snd)) = fun x : sc =>\n        ↑(x : Set.Iic i × Ω).fst by\n      simp +unfoldPartialApp only [sc, Set.restrict, h_min_eq_left]\n      exact h_meas_fst _\n    ext1 ω\n    rw [min_eq_left]\n    have hx_fst_le : ↑(ω : Set.Iic i × Ω).fst ≤ i := (ω : Set.Iic i × Ω).fst.prop\n    refine hx_fst_le.trans (le_of_lt ?_)\n    convert ω.prop\n    simp only [sc, s, not_le, Set.mem_compl_iff, Set.mem_setOf_eq]\n\n"}
{"name":"MeasureTheory.ProgMeasurable.stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁷ : LinearOrder ι\ninst✝⁶ : MeasurableSpace ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : OrderTopology ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : BorelSpace ι\ninst✝¹ : TopologicalSpace β\nu : ι → Ω → β\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : TopologicalSpace.MetrizableSpace ι\nh : MeasureTheory.ProgMeasurable f u\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ MeasureTheory.ProgMeasurable f (MeasureTheory.stoppedProcess u τ)","decl":"theorem ProgMeasurable.stoppedProcess [MetrizableSpace ι] (h : ProgMeasurable f u)\n    (hτ : IsStoppingTime f τ) : ProgMeasurable f (stoppedProcess u τ) :=\n  h.comp (progMeasurable_min_stopping_time hτ) fun _ _ => min_le_left _ _\n\n"}
{"name":"MeasureTheory.ProgMeasurable.adapted_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁷ : LinearOrder ι\ninst✝⁶ : MeasurableSpace ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : OrderTopology ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : BorelSpace ι\ninst✝¹ : TopologicalSpace β\nu : ι → Ω → β\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : TopologicalSpace.MetrizableSpace ι\nh : MeasureTheory.ProgMeasurable f u\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u τ)","decl":"theorem ProgMeasurable.adapted_stoppedProcess [MetrizableSpace ι] (h : ProgMeasurable f u)\n    (hτ : IsStoppingTime f τ) : Adapted f (MeasureTheory.stoppedProcess u τ) :=\n  (h.stoppedProcess hτ).adapted\n\n"}
{"name":"MeasureTheory.ProgMeasurable.stronglyMeasurable_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁷ : LinearOrder ι\ninst✝⁶ : MeasurableSpace ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : OrderTopology ι\ninst✝³ : SecondCountableTopology ι\ninst✝² : BorelSpace ι\ninst✝¹ : TopologicalSpace β\nu : ι → Ω → β\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝ : TopologicalSpace.MetrizableSpace ι\nhu : MeasureTheory.ProgMeasurable f u\nhτ : MeasureTheory.IsStoppingTime f τ\ni : ι\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedProcess u τ i)","decl":"theorem ProgMeasurable.stronglyMeasurable_stoppedProcess [MetrizableSpace ι]\n    (hu : ProgMeasurable f u) (hτ : IsStoppingTime f τ) (i : ι) :\n    StronglyMeasurable (MeasureTheory.stoppedProcess u τ i) :=\n  (hu.adapted_stoppedProcess hτ i).mono (f.le _)\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_stoppedValue_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁶ : LinearOrder ι\ninst✝⁵ : MeasurableSpace ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : SecondCountableTopology ι\ninst✝¹ : BorelSpace ι\ninst✝ : TopologicalSpace β\nu : ι → Ω → β\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\nh : MeasureTheory.ProgMeasurable f u\nhτ : MeasureTheory.IsStoppingTime f τ\nn : ι\nhτ_le : ∀ (ω : Ω), LE.le (τ ω) n\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedValue u τ)","decl":"theorem stronglyMeasurable_stoppedValue_of_le (h : ProgMeasurable f u) (hτ : IsStoppingTime f τ)\n    {n : ι} (hτ_le : ∀ ω, τ ω ≤ n) : StronglyMeasurable[f n] (stoppedValue u τ) := by\n  have : stoppedValue u τ =\n      (fun p : Set.Iic n × Ω => u (↑p.fst) p.snd) ∘ fun ω => (⟨τ ω, hτ_le ω⟩, ω) := by\n    ext1 ω; simp only [stoppedValue, Function.comp_apply, Subtype.coe_mk]\n  rw [this]\n  refine StronglyMeasurable.comp_measurable (h n) ?_\n  exact (hτ.measurable_of_le hτ_le).subtype_mk.prod_mk measurable_id\n\n"}
{"name":"MeasureTheory.measurable_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁹ : LinearOrder ι\ninst✝⁸ : MeasurableSpace ι\ninst✝⁷ : TopologicalSpace ι\ninst✝⁶ : OrderTopology ι\ninst✝⁵ : SecondCountableTopology ι\ninst✝⁴ : BorelSpace ι\ninst✝³ : TopologicalSpace β\nu : ι → Ω → β\nτ : Ω → ι\nf : MeasureTheory.Filtration ι m\ninst✝² : TopologicalSpace.MetrizableSpace β\ninst✝¹ : MeasurableSpace β\ninst✝ : BorelSpace β\nhf_prog : MeasureTheory.ProgMeasurable f u\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ Measurable (MeasureTheory.stoppedValue u τ)","decl":"theorem measurable_stoppedValue [MetrizableSpace β] [MeasurableSpace β] [BorelSpace β]\n    (hf_prog : ProgMeasurable f u) (hτ : IsStoppingTime f τ) :\n    Measurable[hτ.measurableSpace] (stoppedValue u τ) := by\n  have h_str_meas : ∀ i, StronglyMeasurable[f i] (stoppedValue u fun ω => min (τ ω) i) := fun i =>\n    stronglyMeasurable_stoppedValue_of_le hf_prog (hτ.min_const i) fun _ => min_le_right _ _\n  intro t ht i\n  suffices stoppedValue u τ ⁻¹' t ∩ {ω : Ω | τ ω ≤ i} =\n      (stoppedValue u fun ω => min (τ ω) i) ⁻¹' t ∩ {ω : Ω | τ ω ≤ i} by\n    rw [this]; exact ((h_str_meas i).measurable ht).inter (hτ.measurableSet_le i)\n  ext1 ω\n  simp only [stoppedValue, Set.mem_inter_iff, Set.mem_preimage, Set.mem_setOf_eq,\n    and_congr_left_iff]\n  intro h\n  rw [min_eq_left h]\n\n"}
{"name":"MeasureTheory.stoppedValue_eq_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝ : AddCommMonoid E\ns : Finset ι\nhbdd : ∀ (ω : Ω), Membership.mem s (τ ω)\n⊢ Eq (MeasureTheory.stoppedValue u τ) (s.sum fun i => (setOf fun ω => Eq (τ ω) i).indicator (u i))","decl":"theorem stoppedValue_eq_of_mem_finset [AddCommMonoid E] {s : Finset ι} (hbdd : ∀ ω, τ ω ∈ s) :\n    stoppedValue u τ = ∑ i ∈ s, Set.indicator {ω | τ ω = i} (u i) := by\n  ext y\n  classical\n  rw [stoppedValue, Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  suffices Finset.filter (fun i => y ∈ {ω : Ω | τ ω = i}) s = ({τ y} : Finset ι) by\n    rw [this, Finset.sum_singleton]\n  ext1 ω\n  simp only [Set.mem_setOf_eq, Finset.mem_filter, Finset.mem_singleton]\n  constructor <;> intro h\n  · exact h.2.symm\n  · refine ⟨?_, h.symm⟩; rw [h]; exact hbdd y\n\n"}
{"name":"MeasureTheory.stoppedValue_eq'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝² : Preorder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : AddCommMonoid E\nN : ι\nhbdd : ∀ (ω : Ω), LE.le (τ ω) N\n⊢ Eq (MeasureTheory.stoppedValue u τ) ((Finset.Iic N).sum fun i => (setOf fun ω => Eq (τ ω) i).indicator (u i))","decl":"theorem stoppedValue_eq' [Preorder ι] [LocallyFiniteOrderBot ι] [AddCommMonoid E] {N : ι}\n    (hbdd : ∀ ω, τ ω ≤ N) :\n    stoppedValue u τ = ∑ i ∈ Finset.Iic N, Set.indicator {ω | τ ω = i} (u i) :=\n  stoppedValue_eq_of_mem_finset fun ω => Finset.mem_Iic.mpr (hbdd ω)\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝¹ : LinearOrder ι\ninst✝ : AddCommMonoid E\ns : Finset ι\nn : ι\nhbdd : ∀ (ω : Ω), LT.lt (τ ω) n → Membership.mem s (τ ω)\n⊢ Eq (MeasureTheory.stoppedProcess u τ n) (HAdd.hAdd ((setOf fun a => LE.le n (τ a)).indicator (u n)) ((Finset.filter (fun x => LT.lt x n) s).sum fun i => (setOf fun ω => Eq (τ ω) i).indicator (u i)))","decl":"theorem stoppedProcess_eq_of_mem_finset [LinearOrder ι] [AddCommMonoid E] {s : Finset ι} (n : ι)\n    (hbdd : ∀ ω, τ ω < n → τ ω ∈ s) : stoppedProcess u τ n = Set.indicator {a | n ≤ τ a} (u n) +\n      ∑ i ∈ s.filter (· < n), Set.indicator {ω | τ ω = i} (u i) := by\n  ext ω\n  rw [Pi.add_apply, Finset.sum_apply]\n  rcases le_or_lt n (τ ω) with h | h\n  · rw [stoppedProcess_eq_of_le h, Set.indicator_of_mem, Finset.sum_eq_zero, add_zero]\n    · intro m hm\n      refine Set.indicator_of_not_mem ?_ _\n      rw [Finset.mem_filter] at hm\n      exact (hm.2.trans_le h).ne'\n    · exact h\n  · rw [stoppedProcess_eq_of_ge (le_of_lt h), Finset.sum_eq_single_of_mem (τ ω)]\n    · rw [Set.indicator_of_not_mem, zero_add, Set.indicator_of_mem] <;> rw [Set.mem_setOf]\n      exact not_le.2 h\n    · rw [Finset.mem_filter]\n      exact ⟨hbdd ω h, h⟩\n    · intro b _ hneq\n      rw [Set.indicator_of_not_mem]\n      rw [Set.mem_setOf]\n      exact hneq.symm\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq''","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝² : LinearOrder ι\ninst✝¹ : LocallyFiniteOrderBot ι\ninst✝ : AddCommMonoid E\nn : ι\n⊢ Eq (MeasureTheory.stoppedProcess u τ n) (HAdd.hAdd ((setOf fun a => LE.le n (τ a)).indicator (u n)) ((Finset.Iio n).sum fun i => (setOf fun ω => Eq (τ ω) i).indicator (u i)))","decl":"theorem stoppedProcess_eq'' [LinearOrder ι] [LocallyFiniteOrderBot ι] [AddCommMonoid E] (n : ι) :\n    stoppedProcess u τ n = Set.indicator {a | n ≤ τ a} (u n) +\n      ∑ i ∈ Finset.Iio n, Set.indicator {ω | τ ω = i} (u i) := by\n  have h_mem : ∀ ω, τ ω < n → τ ω ∈ Finset.Iio n := fun ω h => Finset.mem_Iio.mpr h\n  rw [stoppedProcess_eq_of_mem_finset n h_mem]\n  congr with i\n  simp\n\n"}
{"name":"MeasureTheory.memℒp_stoppedValue_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\np : ENNReal\nu : ι → Ω → E\ninst✝¹ : PartialOrder ι\nℱ : MeasureTheory.Filtration ι m\ninst✝ : NormedAddCommGroup E\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Memℒp (u n) p μ\ns : Finset ι\nhbdd : ∀ (ω : Ω), Membership.mem s (τ ω)\n⊢ MeasureTheory.Memℒp (MeasureTheory.stoppedValue u τ) p μ","decl":"theorem memℒp_stoppedValue_of_mem_finset (hτ : IsStoppingTime ℱ τ) (hu : ∀ n, Memℒp (u n) p μ)\n    {s : Finset ι} (hbdd : ∀ ω, τ ω ∈ s) : Memℒp (stoppedValue u τ) p μ := by\n  rw [stoppedValue_eq_of_mem_finset hbdd]\n  refine memℒp_finset_sum' _ fun i _ => Memℒp.indicator ?_ (hu i)\n  refine ℱ.le i {a : Ω | τ a = i} (hτ.measurableSet_eq_of_countable_range ?_ i)\n  refine ((Finset.finite_toSet s).subset fun ω hω => ?_).countable\n  obtain ⟨y, rfl⟩ := hω\n  exact hbdd y\n\n"}
{"name":"MeasureTheory.memℒp_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\np : ENNReal\nu : ι → Ω → E\ninst✝² : PartialOrder ι\nℱ : MeasureTheory.Filtration ι m\ninst✝¹ : NormedAddCommGroup E\ninst✝ : LocallyFiniteOrderBot ι\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Memℒp (u n) p μ\nN : ι\nhbdd : ∀ (ω : Ω), LE.le (τ ω) N\n⊢ MeasureTheory.Memℒp (MeasureTheory.stoppedValue u τ) p μ","decl":"theorem memℒp_stoppedValue [LocallyFiniteOrderBot ι] (hτ : IsStoppingTime ℱ τ)\n    (hu : ∀ n, Memℒp (u n) p μ) {N : ι} (hbdd : ∀ ω, τ ω ≤ N) : Memℒp (stoppedValue u τ) p μ :=\n  memℒp_stoppedValue_of_mem_finset hτ hu fun ω => Finset.mem_Iic.mpr (hbdd ω)\n\n"}
{"name":"MeasureTheory.integrable_stoppedValue_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝¹ : PartialOrder ι\nℱ : MeasureTheory.Filtration ι m\ninst✝ : NormedAddCommGroup E\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Integrable (u n) μ\ns : Finset ι\nhbdd : ∀ (ω : Ω), Membership.mem s (τ ω)\n⊢ MeasureTheory.Integrable (MeasureTheory.stoppedValue u τ) μ","decl":"theorem integrable_stoppedValue_of_mem_finset (hτ : IsStoppingTime ℱ τ)\n    (hu : ∀ n, Integrable (u n) μ) {s : Finset ι} (hbdd : ∀ ω, τ ω ∈ s) :\n    Integrable (stoppedValue u τ) μ := by\n  simp_rw [← memℒp_one_iff_integrable] at hu ⊢\n  exact memℒp_stoppedValue_of_mem_finset hτ hu hbdd\n\n"}
{"name":"MeasureTheory.integrable_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝² : PartialOrder ι\nℱ : MeasureTheory.Filtration ι m\ninst✝¹ : NormedAddCommGroup E\ninst✝ : LocallyFiniteOrderBot ι\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Integrable (u n) μ\nN : ι\nhbdd : ∀ (ω : Ω), LE.le (τ ω) N\n⊢ MeasureTheory.Integrable (MeasureTheory.stoppedValue u τ) μ","decl":"theorem integrable_stoppedValue [LocallyFiniteOrderBot ι] (hτ : IsStoppingTime ℱ τ)\n    (hu : ∀ n, Integrable (u n) μ) {N : ι} (hbdd : ∀ ω, τ ω ≤ N) :\n    Integrable (stoppedValue u τ) μ :=\n  integrable_stoppedValue_of_mem_finset hτ hu fun ω => Finset.mem_Iic.mpr (hbdd ω)\n\n"}
{"name":"MeasureTheory.memℒp_stoppedProcess_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\np : ENNReal\nu : ι → Ω → E\ninst✝⁴ : LinearOrder ι\ninst✝³ : TopologicalSpace ι\ninst✝² : OrderTopology ι\ninst✝¹ : FirstCountableTopology ι\nℱ : MeasureTheory.Filtration ι m\ninst✝ : NormedAddCommGroup E\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Memℒp (u n) p μ\nn : ι\ns : Finset ι\nhbdd : ∀ (ω : Ω), LT.lt (τ ω) n → Membership.mem s (τ ω)\n⊢ MeasureTheory.Memℒp (MeasureTheory.stoppedProcess u τ n) p μ","decl":"theorem memℒp_stoppedProcess_of_mem_finset (hτ : IsStoppingTime ℱ τ) (hu : ∀ n, Memℒp (u n) p μ)\n    (n : ι) {s : Finset ι} (hbdd : ∀ ω, τ ω < n → τ ω ∈ s) : Memℒp (stoppedProcess u τ n) p μ := by\n  rw [stoppedProcess_eq_of_mem_finset n hbdd]\n  refine Memℒp.add ?_ ?_\n  · exact Memℒp.indicator (ℱ.le n {a : Ω | n ≤ τ a} (hτ.measurableSet_ge n)) (hu n)\n  · suffices Memℒp (fun ω => ∑ i ∈ s.filter (· < n), {a : Ω | τ a = i}.indicator (u i) ω) p μ by\n      convert this using 1; ext1 ω; simp only [Finset.sum_apply]\n    refine memℒp_finset_sum _ fun i _ => Memℒp.indicator ?_ (hu i)\n    exact ℱ.le i {a : Ω | τ a = i} (hτ.measurableSet_eq i)\n\n"}
{"name":"MeasureTheory.memℒp_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\np : ENNReal\nu : ι → Ω → E\ninst✝⁵ : LinearOrder ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : FirstCountableTopology ι\nℱ : MeasureTheory.Filtration ι m\ninst✝¹ : NormedAddCommGroup E\ninst✝ : LocallyFiniteOrderBot ι\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Memℒp (u n) p μ\nn : ι\n⊢ MeasureTheory.Memℒp (MeasureTheory.stoppedProcess u τ n) p μ","decl":"theorem memℒp_stoppedProcess [LocallyFiniteOrderBot ι] (hτ : IsStoppingTime ℱ τ)\n    (hu : ∀ n, Memℒp (u n) p μ) (n : ι) : Memℒp (stoppedProcess u τ n) p μ :=\n  memℒp_stoppedProcess_of_mem_finset hτ hu n fun _ h => Finset.mem_Iio.mpr h\n\n"}
{"name":"MeasureTheory.integrable_stoppedProcess_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝⁴ : LinearOrder ι\ninst✝³ : TopologicalSpace ι\ninst✝² : OrderTopology ι\ninst✝¹ : FirstCountableTopology ι\nℱ : MeasureTheory.Filtration ι m\ninst✝ : NormedAddCommGroup E\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Integrable (u n) μ\nn : ι\ns : Finset ι\nhbdd : ∀ (ω : Ω), LT.lt (τ ω) n → Membership.mem s (τ ω)\n⊢ MeasureTheory.Integrable (MeasureTheory.stoppedProcess u τ n) μ","decl":"theorem integrable_stoppedProcess_of_mem_finset (hτ : IsStoppingTime ℱ τ)\n    (hu : ∀ n, Integrable (u n) μ) (n : ι) {s : Finset ι} (hbdd : ∀ ω, τ ω < n → τ ω ∈ s) :\n    Integrable (stoppedProcess u τ n) μ := by\n  simp_rw [← memℒp_one_iff_integrable] at hu ⊢\n  exact memℒp_stoppedProcess_of_mem_finset hτ hu n hbdd\n\n"}
{"name":"MeasureTheory.integrable_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\nμ : MeasureTheory.Measure Ω\nτ : Ω → ι\nE : Type u_4\nu : ι → Ω → E\ninst✝⁵ : LinearOrder ι\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : FirstCountableTopology ι\nℱ : MeasureTheory.Filtration ι m\ninst✝¹ : NormedAddCommGroup E\ninst✝ : LocallyFiniteOrderBot ι\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhu : ∀ (n : ι), MeasureTheory.Integrable (u n) μ\nn : ι\n⊢ MeasureTheory.Integrable (MeasureTheory.stoppedProcess u τ n) μ","decl":"theorem integrable_stoppedProcess [LocallyFiniteOrderBot ι] (hτ : IsStoppingTime ℱ τ)\n    (hu : ∀ n, Integrable (u n) μ) (n : ι) : Integrable (stoppedProcess u τ n) μ :=\n  integrable_stoppedProcess_of_mem_finset hτ hu n fun _ h => Finset.mem_Iio.mpr h\n\n"}
{"name":"MeasureTheory.Adapted.stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁸ : TopologicalSpace β\ninst✝⁷ : TopologicalSpace.PseudoMetrizableSpace β\ninst✝⁶ : LinearOrder ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : SecondCountableTopology ι\ninst✝³ : OrderTopology ι\ninst✝² : MeasurableSpace ι\ninst✝¹ : BorelSpace ι\nf : MeasureTheory.Filtration ι m\nu : ι → Ω → β\nτ : Ω → ι\ninst✝ : TopologicalSpace.MetrizableSpace ι\nhu : MeasureTheory.Adapted f u\nhu_cont : ∀ (ω : Ω), Continuous fun i => u i ω\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u τ)","decl":"/-- The stopped process of an adapted process with continuous paths is adapted. -/\ntheorem Adapted.stoppedProcess [MetrizableSpace ι] (hu : Adapted f u)\n    (hu_cont : ∀ ω, Continuous fun i => u i ω) (hτ : IsStoppingTime f τ) :\n    Adapted f (stoppedProcess u τ) :=\n  ((hu.progMeasurable_of_continuous hu_cont).stoppedProcess hτ).adapted\n\n"}
{"name":"MeasureTheory.Adapted.stoppedProcess_of_discrete","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁸ : TopologicalSpace β\ninst✝⁷ : TopologicalSpace.PseudoMetrizableSpace β\ninst✝⁶ : LinearOrder ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : SecondCountableTopology ι\ninst✝³ : OrderTopology ι\ninst✝² : MeasurableSpace ι\ninst✝¹ : BorelSpace ι\nf : MeasureTheory.Filtration ι m\nu : ι → Ω → β\nτ : Ω → ι\ninst✝ : DiscreteTopology ι\nhu : MeasureTheory.Adapted f u\nhτ : MeasureTheory.IsStoppingTime f τ\n⊢ MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u τ)","decl":"/-- If the indexing order has the discrete topology, then the stopped process of an adapted process\nis adapted. -/\ntheorem Adapted.stoppedProcess_of_discrete [DiscreteTopology ι] (hu : Adapted f u)\n    (hτ : IsStoppingTime f τ) : Adapted f (MeasureTheory.stoppedProcess u τ) :=\n  (hu.progMeasurable_of_discrete.stoppedProcess hτ).adapted\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁸ : TopologicalSpace β\ninst✝⁷ : TopologicalSpace.PseudoMetrizableSpace β\ninst✝⁶ : LinearOrder ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : SecondCountableTopology ι\ninst✝³ : OrderTopology ι\ninst✝² : MeasurableSpace ι\ninst✝¹ : BorelSpace ι\nf : MeasureTheory.Filtration ι m\nu : ι → Ω → β\nτ : Ω → ι\ninst✝ : TopologicalSpace.MetrizableSpace ι\nhu : MeasureTheory.Adapted f u\nhu_cont : ∀ (ω : Ω), Continuous fun i => u i ω\nhτ : MeasureTheory.IsStoppingTime f τ\nn : ι\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedProcess u τ n)","decl":"theorem Adapted.stronglyMeasurable_stoppedProcess [MetrizableSpace ι] (hu : Adapted f u)\n    (hu_cont : ∀ ω, Continuous fun i => u i ω) (hτ : IsStoppingTime f τ) (n : ι) :\n    StronglyMeasurable (MeasureTheory.stoppedProcess u τ n) :=\n  (hu.progMeasurable_of_continuous hu_cont).stronglyMeasurable_stoppedProcess hτ n\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable_stoppedProcess_of_discrete","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁸ : TopologicalSpace β\ninst✝⁷ : TopologicalSpace.PseudoMetrizableSpace β\ninst✝⁶ : LinearOrder ι\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : SecondCountableTopology ι\ninst✝³ : OrderTopology ι\ninst✝² : MeasurableSpace ι\ninst✝¹ : BorelSpace ι\nf : MeasureTheory.Filtration ι m\nu : ι → Ω → β\nτ : Ω → ι\ninst✝ : DiscreteTopology ι\nhu : MeasureTheory.Adapted f u\nhτ : MeasureTheory.IsStoppingTime f τ\nn : ι\n⊢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedProcess u τ n)","decl":"theorem Adapted.stronglyMeasurable_stoppedProcess_of_discrete [DiscreteTopology ι]\n    (hu : Adapted f u) (hτ : IsStoppingTime f τ) (n : ι) :\n    StronglyMeasurable (MeasureTheory.stoppedProcess u τ n) :=\n  hu.progMeasurable_of_discrete.stronglyMeasurable_stoppedProcess hτ n\n\n"}
{"name":"MeasureTheory.stoppedValue_sub_eq_sum","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nu : Nat → Ω → β\nτ π : Ω → Nat\ninst✝ : AddCommGroup β\nhle : LE.le τ π\n⊢ Eq (HSub.hSub (MeasureTheory.stoppedValue u π) (MeasureTheory.stoppedValue u τ)) fun ω => (Finset.Ico (τ ω) (π ω)).sum (fun i => HSub.hSub (u (HAdd.hAdd i 1)) (u i)) ω","decl":"theorem stoppedValue_sub_eq_sum [AddCommGroup β] (hle : τ ≤ π) :\n    stoppedValue u π - stoppedValue u τ = fun ω =>\n      (∑ i ∈ Finset.Ico (τ ω) (π ω), (u (i + 1) - u i)) ω := by\n  ext ω\n  rw [Finset.sum_Ico_eq_sub _ (hle ω), Finset.sum_range_sub, Finset.sum_range_sub]\n  simp [stoppedValue]\n\n"}
{"name":"MeasureTheory.stoppedValue_sub_eq_sum'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nu : Nat → Ω → β\nτ π : Ω → Nat\ninst✝ : AddCommGroup β\nhle : LE.le τ π\nN : Nat\nhbdd : ∀ (ω : Ω), LE.le (π ω) N\n⊢ Eq (HSub.hSub (MeasureTheory.stoppedValue u π) (MeasureTheory.stoppedValue u τ)) fun ω => (Finset.range (HAdd.hAdd N 1)).sum (fun i => (setOf fun ω => And (LE.le (τ ω) i) (LT.lt i (π ω))).indicator (HSub.hSub (u (HAdd.hAdd i 1)) (u i))) ω","decl":"theorem stoppedValue_sub_eq_sum' [AddCommGroup β] (hle : τ ≤ π) {N : ℕ} (hbdd : ∀ ω, π ω ≤ N) :\n    stoppedValue u π - stoppedValue u τ = fun ω =>\n      (∑ i ∈ Finset.range (N + 1), Set.indicator {ω | τ ω ≤ i ∧ i < π ω} (u (i + 1) - u i)) ω := by\n  rw [stoppedValue_sub_eq_sum hle]\n  ext ω\n  simp only [Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  refine Finset.sum_congr ?_ fun _ _ => rfl\n  ext i\n  simp only [Finset.mem_filter, Set.mem_setOf_eq, Finset.mem_range, Finset.mem_Ico]\n  exact ⟨fun h => ⟨lt_trans h.2 (Nat.lt_succ_iff.2 <| hbdd _), h⟩, fun h => h.2⟩\n\n"}
{"name":"MeasureTheory.stoppedValue_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nu : Nat → Ω → β\nτ : Ω → Nat\ninst✝ : AddCommMonoid β\nN : Nat\nhbdd : ∀ (ω : Ω), LE.le (τ ω) N\n⊢ Eq (MeasureTheory.stoppedValue u τ) fun x => (Finset.range (HAdd.hAdd N 1)).sum (fun i => (setOf fun ω => Eq (τ ω) i).indicator (u i)) x","decl":"theorem stoppedValue_eq {N : ℕ} (hbdd : ∀ ω, τ ω ≤ N) : stoppedValue u τ = fun x =>\n    (∑ i ∈ Finset.range (N + 1), Set.indicator {ω | τ ω = i} (u i)) x :=\n  stoppedValue_eq_of_mem_finset fun ω => Finset.mem_range_succ_iff.mpr (hbdd ω)\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nu : Nat → Ω → β\nτ : Ω → Nat\ninst✝ : AddCommMonoid β\nn : Nat\n⊢ Eq (MeasureTheory.stoppedProcess u τ n) (HAdd.hAdd ((setOf fun a => LE.le n (τ a)).indicator (u n)) ((Finset.range n).sum fun i => (setOf fun ω => Eq (τ ω) i).indicator (u i)))","decl":"theorem stoppedProcess_eq (n : ℕ) : stoppedProcess u τ n = Set.indicator {a | n ≤ τ a} (u n) +\n    ∑ i ∈ Finset.range n, Set.indicator {ω | τ ω = i} (u i) := by\n  rw [stoppedProcess_eq'' n]\n  congr with i\n  rw [Finset.mem_Iio, Finset.mem_range]\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nβ : Type u_2\nu : Nat → Ω → β\nτ : Ω → Nat\ninst✝ : AddCommMonoid β\nn : Nat\n⊢ Eq (MeasureTheory.stoppedProcess u τ n) (HAdd.hAdd ((setOf fun a => LE.le (HAdd.hAdd n 1) (τ a)).indicator (u n)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => (setOf fun a => Eq (τ a) i).indicator (u i)))","decl":"theorem stoppedProcess_eq' (n : ℕ) : stoppedProcess u τ n = Set.indicator {a | n + 1 ≤ τ a} (u n) +\n    ∑ i ∈ Finset.range (n + 1), Set.indicator {a | τ a = i} (u i) := by\n  have : {a | n ≤ τ a}.indicator (u n) =\n      {a | n + 1 ≤ τ a}.indicator (u n) + {a | τ a = n}.indicator (u n) := by\n    ext x\n    rw [add_comm, Pi.add_apply, ← Set.indicator_union_of_not_mem_inter]\n    · simp_rw [@eq_comm _ _ n, @le_iff_eq_or_lt _ _ n, Nat.succ_le_iff, Set.setOf_or]\n    · rintro ⟨h₁, h₂⟩\n      rw [Set.mem_setOf] at h₁ h₂\n      exact (Nat.succ_le_iff.1 h₂).ne h₁.symm\n  rw [stoppedProcess_eq, this, Finset.sum_range_succ_comm, ← add_assoc]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.piecewise_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\n𝒢 : MeasureTheory.Filtration ι m\nτ η : Ω → ι\ni : ι\ns : Set Ω\ninst✝ : DecidablePred fun x => Membership.mem s x\nhτ_st : MeasureTheory.IsStoppingTime 𝒢 τ\nhη_st : MeasureTheory.IsStoppingTime 𝒢 η\nhτ : ∀ (ω : Ω), LE.le i (τ ω)\nhη : ∀ (ω : Ω), LE.le i (η ω)\nhs : MeasurableSet s\n⊢ MeasureTheory.IsStoppingTime 𝒢 (s.piecewise τ η)","decl":"/-- Given stopping times `τ` and `η` which are bounded below, `Set.piecewise s τ η` is also\na stopping time with respect to the same filtration. -/\ntheorem IsStoppingTime.piecewise_of_le (hτ_st : IsStoppingTime 𝒢 τ) (hη_st : IsStoppingTime 𝒢 η)\n    (hτ : ∀ ω, i ≤ τ ω) (hη : ∀ ω, i ≤ η ω) (hs : MeasurableSet[𝒢 i] s) :\n    IsStoppingTime 𝒢 (s.piecewise τ η) := by\n  intro n\n  have : {ω | s.piecewise τ η ω ≤ n} = s ∩ {ω | τ ω ≤ n} ∪ sᶜ ∩ {ω | η ω ≤ n} := by\n    ext1 ω\n    simp only [Set.piecewise, Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    by_cases hx : ω ∈ s <;> simp [hx]\n  rw [this]\n  by_cases hin : i ≤ n\n  · have hs_n : MeasurableSet[𝒢 n] s := 𝒢.mono hin _ hs\n    exact (hs_n.inter (hτ_st n)).union (hs_n.compl.inter (hη_st n))\n  · have hτn : ∀ ω, ¬τ ω ≤ n := fun ω hτn => hin ((hτ ω).trans hτn)\n    have hηn : ∀ ω, ¬η ω ≤ n := fun ω hηn => hin ((hη ω).trans hηn)\n    simp [hτn, hηn, @MeasurableSet.empty _ _]\n\n"}
{"name":"MeasureTheory.isStoppingTime_piecewise_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹ : Preorder ι\n𝒢 : MeasureTheory.Filtration ι m\ni j : ι\ns : Set Ω\ninst✝ : DecidablePred fun x => Membership.mem s x\nhij : LE.le i j\nhs : MeasurableSet s\n⊢ MeasureTheory.IsStoppingTime 𝒢 (s.piecewise (fun x => i) fun x => j)","decl":"theorem isStoppingTime_piecewise_const (hij : i ≤ j) (hs : MeasurableSet[𝒢 i] s) :\n    IsStoppingTime 𝒢 (s.piecewise (fun _ => i) fun _ => j) :=\n  (isStoppingTime_const 𝒢 i).piecewise_of_le (isStoppingTime_const 𝒢 j) (fun _ => le_rfl)\n    (fun _ => hij) hs\n\n"}
{"name":"MeasureTheory.stoppedValue_piecewise_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\ns : Set Ω\ninst✝ : DecidablePred fun x => Membership.mem s x\nι' : Type u_4\ni j : ι'\nf : ι' → Ω → Real\n⊢ Eq (MeasureTheory.stoppedValue f (s.piecewise (fun x => i) fun x => j)) (s.piecewise (f i) (f j))","decl":"theorem stoppedValue_piecewise_const {ι' : Type*} {i j : ι'} {f : ι' → Ω → ℝ} :\n    stoppedValue f (s.piecewise (fun _ => i) fun _ => j) = s.piecewise (f i) (f j) := by\n  ext ω; rw [stoppedValue]; by_cases hx : ω ∈ s <;> simp [hx]\n\n"}
{"name":"MeasureTheory.stoppedValue_piecewise_const'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\ns : Set Ω\ninst✝ : DecidablePred fun x => Membership.mem s x\nι' : Type u_4\ni j : ι'\nf : ι' → Ω → Real\n⊢ Eq (MeasureTheory.stoppedValue f (s.piecewise (fun x => i) fun x => j)) (HAdd.hAdd (s.indicator (f i)) ((HasCompl.compl s).indicator (f j)))","decl":"theorem stoppedValue_piecewise_const' {ι' : Type*} {i j : ι'} {f : ι' → Ω → ℝ} :\n    stoppedValue f (s.piecewise (fun _ => i) fun _ => j) =\n    s.indicator (f i) + sᶜ.indicator (f j) := by\n  ext ω; rw [stoppedValue]; by_cases hx : ω ∈ s <;> simp [hx]\n\n"}
{"name":"MeasureTheory.condExp_stopping_time_ae_eq_restrict_eq_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nf : Ω → E\ninst✝¹ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nh_countable : (Set.range τ).Countable\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\ni : ι\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => Eq (τ x) i))).EventuallyEq (MeasureTheory.condExp hτ.measurableSpace μ f) (MeasureTheory.condExp (↑ℱ i) μ f)","decl":"theorem condExp_stopping_time_ae_eq_restrict_eq_of_countable_range [SigmaFiniteFiltration μ ℱ]\n    (hτ : IsStoppingTime ℱ τ) (h_countable : (Set.range τ).Countable)\n    [SigmaFinite (μ.trim (hτ.measurableSpace_le_of_countable_range h_countable))] (i : ι) :\n    μ[f|hτ.measurableSpace] =ᵐ[μ.restrict {x | τ x = i}] μ[f|ℱ i] := by\n  refine condExp_ae_eq_restrict_of_measurableSpace_eq_on\n    (hτ.measurableSpace_le_of_countable_range h_countable) (ℱ.le i)\n    (hτ.measurableSet_eq_of_countable_range' h_countable i) fun t => ?_\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]\n\n"}
{"name":"MeasureTheory.condexp_stopping_time_ae_eq_restrict_eq_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nf : Ω → E\ninst✝¹ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nh_countable : (Set.range τ).Countable\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\ni : ι\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => Eq (τ x) i))).EventuallyEq (MeasureTheory.condExp hτ.measurableSpace μ f) (MeasureTheory.condExp (↑ℱ i) μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stopping_time_ae_eq_restrict_eq_of_countable_range :=\n  condExp_stopping_time_ae_eq_restrict_eq_of_countable_range\n\n"}
{"name":"MeasureTheory.condExp_stopping_time_ae_eq_restrict_eq_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁶ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : CompleteSpace E\nf : Ω → E\ninst✝² : Countable ι\ninst✝¹ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nhτ : MeasureTheory.IsStoppingTime ℱ τ\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\ni : ι\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => Eq (τ x) i))).EventuallyEq (MeasureTheory.condExp hτ.measurableSpace μ f) (MeasureTheory.condExp (↑ℱ i) μ f)","decl":"theorem condExp_stopping_time_ae_eq_restrict_eq_of_countable [Countable ι]\n    [SigmaFiniteFiltration μ ℱ] (hτ : IsStoppingTime ℱ τ)\n    [SigmaFinite (μ.trim hτ.measurableSpace_le_of_countable)] (i : ι) :\n    μ[f|hτ.measurableSpace] =ᵐ[μ.restrict {x | τ x = i}] μ[f|ℱ i] :=\n  condExp_stopping_time_ae_eq_restrict_eq_of_countable_range hτ (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.condexp_stopping_time_ae_eq_restrict_eq_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁶ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace Real E\ninst✝³ : CompleteSpace E\nf : Ω → E\ninst✝² : Countable ι\ninst✝¹ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nhτ : MeasureTheory.IsStoppingTime ℱ τ\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\ni : ι\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => Eq (τ x) i))).EventuallyEq (MeasureTheory.condExp hτ.measurableSpace μ f) (MeasureTheory.condExp (↑ℱ i) μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stopping_time_ae_eq_restrict_eq_of_countable :=\n  condExp_stopping_time_ae_eq_restrict_eq_of_countable\n\n"}
{"name":"MeasureTheory.condExp_min_stopping_time_ae_eq_restrict_le_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nf : Ω → E\ninst✝¹ : Filter.atTop.IsCountablyGenerated\nhτ : MeasureTheory.IsStoppingTime ℱ τ\ni : ι\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => LE.le (τ x) i))).EventuallyEq (MeasureTheory.condExp ⋯.measurableSpace μ f) (MeasureTheory.condExp hτ.measurableSpace μ f)","decl":"theorem condExp_min_stopping_time_ae_eq_restrict_le_const (hτ : IsStoppingTime ℱ τ) (i : ι)\n    [SigmaFinite (μ.trim (hτ.min_const i).measurableSpace_le)] :\n    μ[f|(hτ.min_const i).measurableSpace] =ᵐ[μ.restrict {x | τ x ≤ i}] μ[f|hτ.measurableSpace] := by\n  have : SigmaFinite (μ.trim hτ.measurableSpace_le) :=\n    haveI h_le : (hτ.min_const i).measurableSpace ≤ hτ.measurableSpace := by\n      rw [IsStoppingTime.measurableSpace_min_const]\n      exact inf_le_left\n    sigmaFiniteTrim_mono _ h_le\n  refine (condExp_ae_eq_restrict_of_measurableSpace_eq_on hτ.measurableSpace_le\n    (hτ.min_const i).measurableSpace_le (hτ.measurableSet_le' i) fun t => ?_).symm\n  rw [Set.inter_comm _ t, hτ.measurableSet_inter_le_const_iff]\n\n"}
{"name":"MeasureTheory.condexp_min_stopping_time_ae_eq_restrict_le_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁵ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace Real E\ninst✝² : CompleteSpace E\nf : Ω → E\ninst✝¹ : Filter.atTop.IsCountablyGenerated\nhτ : MeasureTheory.IsStoppingTime ℱ τ\ni : ι\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => LE.le (τ x) i))).EventuallyEq (MeasureTheory.condExp ⋯.measurableSpace μ f) (MeasureTheory.condExp hτ.measurableSpace μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_min_stopping_time_ae_eq_restrict_le_const :=\n  condExp_min_stopping_time_ae_eq_restrict_le_const\n\n"}
{"name":"MeasureTheory.condExp_stopping_time_ae_eq_restrict_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁹ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : CompleteSpace E\nf : Ω → E\ninst✝⁵ : Filter.atTop.IsCountablyGenerated\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : FirstCountableTopology ι\ninst✝¹ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nhτ : MeasureTheory.IsStoppingTime ℱ τ\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\ni : ι\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => Eq (τ x) i))).EventuallyEq (MeasureTheory.condExp hτ.measurableSpace μ f) (MeasureTheory.condExp (↑ℱ i) μ f)","decl":"theorem condExp_stopping_time_ae_eq_restrict_eq [FirstCountableTopology ι]\n    [SigmaFiniteFiltration μ ℱ] (hτ : IsStoppingTime ℱ τ)\n    [SigmaFinite (μ.trim hτ.measurableSpace_le)] (i : ι) :\n    μ[f|hτ.measurableSpace] =ᵐ[μ.restrict {x | τ x = i}] μ[f|ℱ i] := by\n  refine condExp_ae_eq_restrict_of_measurableSpace_eq_on hτ.measurableSpace_le (ℱ.le i)\n    (hτ.measurableSet_eq' i) fun t => ?_\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]\n\n"}
{"name":"MeasureTheory.condexp_stopping_time_ae_eq_restrict_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝⁹ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ : Ω → ι\nE : Type u_4\ninst✝⁸ : NormedAddCommGroup E\ninst✝⁷ : NormedSpace Real E\ninst✝⁶ : CompleteSpace E\nf : Ω → E\ninst✝⁵ : Filter.atTop.IsCountablyGenerated\ninst✝⁴ : TopologicalSpace ι\ninst✝³ : OrderTopology ι\ninst✝² : FirstCountableTopology ι\ninst✝¹ : MeasureTheory.SigmaFiniteFiltration μ ℱ\nhτ : MeasureTheory.IsStoppingTime ℱ τ\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\ni : ι\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => Eq (τ x) i))).EventuallyEq (MeasureTheory.condExp hτ.measurableSpace μ f) (MeasureTheory.condExp (↑ℱ i) μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stopping_time_ae_eq_restrict_eq := condExp_stopping_time_ae_eq_restrict_eq\n\n"}
{"name":"MeasureTheory.condExp_min_stopping_time_ae_eq_restrict_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹⁰ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ σ : Ω → ι\nE : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Real E\ninst✝⁷ : CompleteSpace E\nf : Ω → E\ninst✝⁶ : Filter.atTop.IsCountablyGenerated\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : OrderTopology ι\ninst✝³ : MeasurableSpace ι\ninst✝² : SecondCountableTopology ι\ninst✝¹ : BorelSpace ι\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhσ : MeasureTheory.IsStoppingTime ℱ σ\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => LE.le (τ x) (σ x)))).EventuallyEq (MeasureTheory.condExp ⋯.measurableSpace μ f) (MeasureTheory.condExp hτ.measurableSpace μ f)","decl":"theorem condExp_min_stopping_time_ae_eq_restrict_le [MeasurableSpace ι] [SecondCountableTopology ι]\n    [BorelSpace ι] (hτ : IsStoppingTime ℱ τ) (hσ : IsStoppingTime ℱ σ)\n    [SigmaFinite (μ.trim (hτ.min hσ).measurableSpace_le)] :\n    μ[f|(hτ.min hσ).measurableSpace] =ᵐ[μ.restrict {x | τ x ≤ σ x}] μ[f|hτ.measurableSpace] := by\n  have : SigmaFinite (μ.trim hτ.measurableSpace_le) :=\n    haveI h_le : (hτ.min hσ).measurableSpace ≤ hτ.measurableSpace := by\n      rw [IsStoppingTime.measurableSpace_min]\n      · exact inf_le_left\n      · simp_all only\n    sigmaFiniteTrim_mono _ h_le\n  refine (condExp_ae_eq_restrict_of_measurableSpace_eq_on hτ.measurableSpace_le\n    (hτ.min hσ).measurableSpace_le (hτ.measurableSet_le_stopping_time hσ) fun t => ?_).symm\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_le_iff]; simp_all only\n\n"}
{"name":"MeasureTheory.condexp_min_stopping_time_ae_eq_restrict_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Ω : Type u_1\nι : Type u_3\nm : MeasurableSpace Ω\ninst✝¹⁰ : LinearOrder ι\nμ : MeasureTheory.Measure Ω\nℱ : MeasureTheory.Filtration ι m\nτ σ : Ω → ι\nE : Type u_4\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace Real E\ninst✝⁷ : CompleteSpace E\nf : Ω → E\ninst✝⁶ : Filter.atTop.IsCountablyGenerated\ninst✝⁵ : TopologicalSpace ι\ninst✝⁴ : OrderTopology ι\ninst✝³ : MeasurableSpace ι\ninst✝² : SecondCountableTopology ι\ninst✝¹ : BorelSpace ι\nhτ : MeasureTheory.IsStoppingTime ℱ τ\nhσ : MeasureTheory.IsStoppingTime ℱ σ\ninst✝ : MeasureTheory.SigmaFinite (μ.trim ⋯)\n⊢ (MeasureTheory.ae (μ.restrict (setOf fun x => LE.le (τ x) (σ x)))).EventuallyEq (MeasureTheory.condExp ⋯.measurableSpace μ f) (MeasureTheory.condExp hτ.measurableSpace μ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_min_stopping_time_ae_eq_restrict_le := condExp_min_stopping_time_ae_eq_restrict_le\n\n"}
