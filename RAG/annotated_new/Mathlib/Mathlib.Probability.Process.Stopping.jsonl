{"name":"MeasureTheory.isStoppingTime_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\ni : Î¹\nâŠ¢ MeasureTheory.IsStoppingTime f fun x => i","decl":"theorem isStoppingTime_const [Preorder Î¹] (f : Filtration Î¹ m) (i : Î¹) :\n    IsStoppingTime f fun _ => i := fun j => by simp only [MeasurableSet.const]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le (Ï„ Ï‰) i)","decl":"protected theorem IsStoppingTime.measurableSet_le (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ â‰¤ i} :=\n  hÏ„ i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_pred","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : PredOrder Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"theorem IsStoppingTime.measurableSet_lt_of_pred [PredOrder Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ < i} := by\n  by_cases hi_min : IsMin i\n  Â· suffices {Ï‰ : Î© | Ï„ Ï‰ < i} = âˆ… by rw [this]; exact @MeasurableSet.empty _ (f i)\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false]\n    rw [isMin_iff_forall_not_lt] at hi_min\n    exact hi_min (Ï„ Ï‰)\n  have : {Ï‰ : Î© | Ï„ Ï‰ < i} = Ï„ â»Â¹' Set.Iic (pred i) := by ext; simp [Iic_pred_of_not_isMin hi_min]\n  rw [this]\n  exact f.mono (pred_le i) _ (hÏ„.measurableSet_le <| pred i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : PartialOrder Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_eq_of_countable_range (hÏ„ : IsStoppingTime f Ï„)\n    (h_countable : (Set.range Ï„).Countable) (i : Î¹) : MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ = i} := by\n  have : {Ï‰ | Ï„ Ï‰ = i} = {Ï‰ | Ï„ Ï‰ â‰¤ i} \\ â‹ƒ (j âˆˆ Set.range Ï„) (_ : j < i), {Ï‰ | Ï„ Ï‰ â‰¤ j} := by\n    ext1 a\n    simp only [Set.mem_setOf_eq, Set.mem_range, Set.iUnion_exists, Set.iUnion_iUnion_eq',\n      Set.mem_diff, Set.mem_iUnion, exists_prop, not_exists, not_and, not_le]\n    constructor <;> intro h\n    Â· simp only [h, lt_iff_le_not_le, le_refl, and_imp, imp_self, imp_true_iff, and_self_iff]\n    Â· exact h.1.eq_or_lt.resolve_right fun h_lt => h.2 a h_lt le_rfl\n  rw [this]\n  refine (hÏ„.measurableSet_le i).diff ?_\n  refine MeasurableSet.biUnion h_countable fun j _ => ?_\n  classical\n  rw [Set.iUnion_eq_if]\n  split_ifs with hji\n  Â· exact f.mono hji.le _ (hÏ„.measurableSet_le j)\n  Â· exact @MeasurableSet.empty _ (f i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : PartialOrder Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_eq_of_countable [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ = i} :=\n  hÏ„.measurableSet_eq_of_countable_range (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : PartialOrder Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_lt_of_countable_range (hÏ„ : IsStoppingTime f Ï„)\n    (h_countable : (Set.range Ï„).Countable) (i : Î¹) : MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ < i} := by\n  have : {Ï‰ | Ï„ Ï‰ < i} = {Ï‰ | Ï„ Ï‰ â‰¤ i} \\ {Ï‰ | Ï„ Ï‰ = i} := by ext1 Ï‰; simp [lt_iff_le_and_ne]\n  rw [this]\n  exact (hÏ„.measurableSet_le i).diff (hÏ„.measurableSet_eq_of_countable_range h_countable i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : PartialOrder Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_lt_of_countable [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ < i} :=\n  hÏ„.measurableSet_lt_of_countable_range (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nm : MeasurableSpace Î©\nÎ¹ : Type u_4\ninstâœ : LinearOrder Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le i (Ï„ Ï‰))","decl":"protected theorem measurableSet_ge_of_countable_range {Î¹} [LinearOrder Î¹] {Ï„ : Î© â†’ Î¹}\n    {f : Filtration Î¹ m} (hÏ„ : IsStoppingTime f Ï„) (h_countable : (Set.range Ï„).Countable) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | i â‰¤ Ï„ Ï‰} := by\n  have : {Ï‰ | i â‰¤ Ï„ Ï‰} = {Ï‰ | Ï„ Ï‰ < i}á¶œ := by\n    ext1 Ï‰; simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hÏ„.measurableSet_lt_of_countable_range h_countable i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nm : MeasurableSpace Î©\nÎ¹ : Type u_4\ninstâœÂ¹ : LinearOrder Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le i (Ï„ Ï‰))","decl":"protected theorem measurableSet_ge_of_countable {Î¹} [LinearOrder Î¹] {Ï„ : Î© â†’ Î¹} {f : Filtration Î¹ m}\n    [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) : MeasurableSet[f i] {Ï‰ | i â‰¤ Ï„ Ï‰} :=\n  hÏ„.measurableSet_ge_of_countable_range (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_gt","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt i (Ï„ Ï‰))","decl":"theorem IsStoppingTime.measurableSet_gt (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | i < Ï„ Ï‰} := by\n  have : {Ï‰ | i < Ï„ Ï‰} = {Ï‰ | Ï„ Ï‰ â‰¤ i}á¶œ := by\n    ext1 Ï‰; simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_le]\n  rw [this]\n  exact (hÏ„.measurableSet_le i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_isLUB","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nh_lub : IsLUB (Set.Iio i) i\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"/-- Auxiliary lemma for `MeasureTheory.IsStoppingTime.measurableSet_lt`. -/\ntheorem IsStoppingTime.measurableSet_lt_of_isLUB (hÏ„ : IsStoppingTime f Ï„) (i : Î¹)\n    (h_lub : IsLUB (Set.Iio i) i) : MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ < i} := by\n  by_cases hi_min : IsMin i\n  Â· suffices {Ï‰ | Ï„ Ï‰ < i} = âˆ… by rw [this]; exact @MeasurableSet.empty _ (f i)\n    ext1 Ï‰\n    simp only [Set.mem_setOf_eq, Set.mem_empty_iff_false, iff_false]\n    exact isMin_iff_forall_not_lt.mp hi_min (Ï„ Ï‰)\n  obtain âŸ¨seq, -, -, h_tendsto, h_boundâŸ© :\n      âˆƒ seq : â„• â†’ Î¹, Monotone seq âˆ§ (âˆ€ j, seq j â‰¤ i) âˆ§ Tendsto seq atTop (ğ“ i) âˆ§ âˆ€ j, seq j < i :=\n    h_lub.exists_seq_monotone_tendsto (not_isMin_iff.mp hi_min)\n  have h_Ioi_eq_Union : Set.Iio i = â‹ƒ j, {k | k â‰¤ seq j} := by\n    ext1 k\n    simp only [Set.mem_Iio, Set.mem_iUnion, Set.mem_setOf_eq]\n    refine âŸ¨fun hk_lt_i => ?_, fun h_exists_k_le_seq => ?_âŸ©\n    Â· rw [tendsto_atTop'] at h_tendsto\n      have h_nhds : Set.Ici k âˆˆ ğ“ i :=\n        mem_nhds_iff.mpr âŸ¨Set.Ioi k, Set.Ioi_subset_Ici le_rfl, isOpen_Ioi, hk_lt_iâŸ©\n      obtain âŸ¨a, haâŸ© : âˆƒ a : â„•, âˆ€ b : â„•, b â‰¥ a â†’ k â‰¤ seq b := h_tendsto (Set.Ici k) h_nhds\n      exact âŸ¨a, ha a le_rflâŸ©\n    Â· obtain âŸ¨j, hk_seq_jâŸ© := h_exists_k_le_seq\n      exact hk_seq_j.trans_lt (h_bound j)\n  have h_lt_eq_preimage : {Ï‰ | Ï„ Ï‰ < i} = Ï„ â»Â¹' Set.Iio i := by\n    ext1 Ï‰; simp only [Set.mem_setOf_eq, Set.mem_preimage, Set.mem_Iio]\n  rw [h_lt_eq_preimage, h_Ioi_eq_Union]\n  simp only [Set.preimage_iUnion, Set.preimage_setOf_eq]\n  exact MeasurableSet.iUnion fun n => f.mono (h_bound n).le _ (hÏ„.measurableSet_le (seq n))\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"theorem IsStoppingTime.measurableSet_lt (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ < i} := by\n  obtain âŸ¨i', hi'_lubâŸ© : âˆƒ i', IsLUB (Set.Iio i) i' := exists_lub_Iio i\n  cases' lub_Iio_eq_self_or_Iio_eq_Iic i hi'_lub with hi'_eq_i h_Iio_eq_Iic\n  Â· rw [â† hi'_eq_i] at hi'_lub âŠ¢\n    exact hÏ„.measurableSet_lt_of_isLUB i' hi'_lub\n  Â· have h_lt_eq_preimage : {Ï‰ : Î© | Ï„ Ï‰ < i} = Ï„ â»Â¹' Set.Iio i := rfl\n    rw [h_lt_eq_preimage, h_Iio_eq_Iic]\n    exact f.mono (lub_Iio_le i hi'_lub) _ (hÏ„.measurableSet_le i')\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le i (Ï„ Ï‰))","decl":"theorem IsStoppingTime.measurableSet_ge (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | i â‰¤ Ï„ Ï‰} := by\n  have : {Ï‰ | i â‰¤ Ï„ Ï‰} = {Ï‰ | Ï„ Ï‰ < i}á¶œ := by\n    ext1 Ï‰; simp only [Set.mem_setOf_eq, Set.mem_compl_iff, not_lt]\n  rw [this]\n  exact (hÏ„.measurableSet_lt i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"theorem IsStoppingTime.measurableSet_eq (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ = i} := by\n  have : {Ï‰ | Ï„ Ï‰ = i} = {Ï‰ | Ï„ Ï‰ â‰¤ i} âˆ© {Ï‰ | Ï„ Ï‰ â‰¥ i} := by\n    ext1 Ï‰; simp only [Set.mem_setOf_eq, Set.mem_inter_iff, le_antisymm_iff]\n  rw [this]\n  exact (hÏ„.measurableSet_le i).inter (hÏ„.measurableSet_ge i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni j : Î¹\nhle : LE.le i j\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"theorem IsStoppingTime.measurableSet_eq_le (hÏ„ : IsStoppingTime f Ï„) {i j : Î¹} (hle : i â‰¤ j) :\n    MeasurableSet[f j] {Ï‰ | Ï„ Ï‰ = i} :=\n  f.mono hle _ <| hÏ„.measurableSet_eq i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni j : Î¹\nhle : LE.le i j\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"theorem IsStoppingTime.measurableSet_lt_le (hÏ„ : IsStoppingTime f Ï„) {i j : Î¹} (hle : i â‰¤ j) :\n    MeasurableSet[f j] {Ï‰ | Ï„ Ï‰ < i} :=\n  f.mono hle _ <| hÏ„.measurableSet_lt i\n\n"}
{"name":"MeasureTheory.isStoppingTime_of_measurableSet_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : Preorder Î¹\ninstâœ : Countable Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : âˆ€ (i : Î¹), MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)\nâŠ¢ MeasureTheory.IsStoppingTime f Ï„","decl":"theorem isStoppingTime_of_measurableSet_eq [Preorder Î¹] [Countable Î¹] {f : Filtration Î¹ m}\n    {Ï„ : Î© â†’ Î¹} (hÏ„ : âˆ€ i, MeasurableSet[f i] {Ï‰ | Ï„ Ï‰ = i}) : IsStoppingTime f Ï„ := by\n  intro i\n  rw [show {Ï‰ | Ï„ Ï‰ â‰¤ i} = â‹ƒ k â‰¤ i, {Ï‰ | Ï„ Ï‰ = k} by ext; simp]\n  refine MeasurableSet.biUnion (Set.to_countable _) fun k hk => ?_\n  exact f.mono hk _ (hÏ„ k)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.max","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasureTheory.IsStoppingTime f fun Ï‰ => Max.max (Ï„ Ï‰) (Ï€ Ï‰)","decl":"protected theorem max [LinearOrder Î¹] {f : Filtration Î¹ m} {Ï„ Ï€ : Î© â†’ Î¹} (hÏ„ : IsStoppingTime f Ï„)\n    (hÏ€ : IsStoppingTime f Ï€) : IsStoppingTime f fun Ï‰ => max (Ï„ Ï‰) (Ï€ Ï‰) := by\n  intro i\n  simp_rw [max_le_iff, Set.setOf_and]\n  exact (hÏ„ i).inter (hÏ€ i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.max_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasureTheory.IsStoppingTime f fun Ï‰ => Max.max (Ï„ Ï‰) i","decl":"protected theorem max_const [LinearOrder Î¹] {f : Filtration Î¹ m} {Ï„ : Î© â†’ Î¹}\n    (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) : IsStoppingTime f fun Ï‰ => max (Ï„ Ï‰) i :=\n  hÏ„.max (isStoppingTime_const f i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.min","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasureTheory.IsStoppingTime f fun Ï‰ => Min.min (Ï„ Ï‰) (Ï€ Ï‰)","decl":"protected theorem min [LinearOrder Î¹] {f : Filtration Î¹ m} {Ï„ Ï€ : Î© â†’ Î¹} (hÏ„ : IsStoppingTime f Ï„)\n    (hÏ€ : IsStoppingTime f Ï€) : IsStoppingTime f fun Ï‰ => min (Ï„ Ï‰) (Ï€ Ï‰) := by\n  intro i\n  simp_rw [min_le_iff, Set.setOf_or]\n  exact (hÏ„ i).union (hÏ€ i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.min_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasureTheory.IsStoppingTime f fun Ï‰ => Min.min (Ï„ Ï‰) i","decl":"protected theorem min_const [LinearOrder Î¹] {f : Filtration Î¹ m} {Ï„ : Î© â†’ Î¹}\n    (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) : IsStoppingTime f fun Ï‰ => min (Ï„ Ï‰) i :=\n  hÏ„.min (isStoppingTime_const f i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.add_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : AddGroup Î¹\ninstâœÂ² : Preorder Î¹\ninstâœÂ¹ : AddRightMono Î¹\ninstâœ : AddLeftMono Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nhi : LE.le 0 i\nâŠ¢ MeasureTheory.IsStoppingTime f fun Ï‰ => HAdd.hAdd (Ï„ Ï‰) i","decl":"theorem add_const [AddGroup Î¹] [Preorder Î¹] [AddRightMono Î¹]\n    [AddLeftMono Î¹] {f : Filtration Î¹ m} {Ï„ : Î© â†’ Î¹} (hÏ„ : IsStoppingTime f Ï„)\n    {i : Î¹} (hi : 0 â‰¤ i) : IsStoppingTime f fun Ï‰ => Ï„ Ï‰ + i := by\n  intro j\n  simp_rw [â† le_sub_iff_add_le]\n  exact f.mono (sub_le_self j hi) _ (hÏ„ (j - i))\n\n"}
{"name":"MeasureTheory.IsStoppingTime.add_const_nat","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nm : MeasurableSpace Î©\nf : MeasureTheory.Filtration Nat m\nÏ„ : Î© â†’ Nat\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Nat\nâŠ¢ MeasureTheory.IsStoppingTime f fun Ï‰ => HAdd.hAdd (Ï„ Ï‰) i","decl":"theorem add_const_nat {f : Filtration â„• m} {Ï„ : Î© â†’ â„•} (hÏ„ : IsStoppingTime f Ï„) {i : â„•} :\n    IsStoppingTime f fun Ï‰ => Ï„ Ï‰ + i := by\n  refine isStoppingTime_of_measurableSet_eq fun j => ?_\n  by_cases hij : i â‰¤ j\n  Â· simp_rw [eq_comm, â† Nat.sub_eq_iff_eq_add hij, eq_comm]\n    exact f.mono (j.sub_le i) _ (hÏ„.measurableSet_eq (j - i))\n  Â· rw [not_le] at hij\n    convert @MeasurableSet.empty _ (f.1 j)\n    ext Ï‰\n    simp only [Set.mem_empty_iff_false, iff_false, Set.mem_setOf]\n    omega\n\n-- generalize to certain countable type?\n"}
{"name":"MeasureTheory.IsStoppingTime.add","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nm : MeasurableSpace Î©\nf : MeasureTheory.Filtration Nat m\nÏ„ Ï€ : Î© â†’ Nat\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasureTheory.IsStoppingTime f (HAdd.hAdd Ï„ Ï€)","decl":"theorem add {f : Filtration â„• m} {Ï„ Ï€ : Î© â†’ â„•} (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€) :\n    IsStoppingTime f (Ï„ + Ï€) := by\n  intro i\n  rw [(_ : {Ï‰ | (Ï„ + Ï€) Ï‰ â‰¤ i} = â‹ƒ k â‰¤ i, {Ï‰ | Ï€ Ï‰ = k} âˆ© {Ï‰ | Ï„ Ï‰ + k â‰¤ i})]\n  Â· exact MeasurableSet.iUnion fun k =>\n      MeasurableSet.iUnion fun hk => (hÏ€.measurableSet_eq_le hk).inter (hÏ„.add_const_nat i)\n  ext Ï‰\n  simp only [Pi.add_apply, Set.mem_setOf_eq, Set.mem_iUnion, Set.mem_inter_iff, exists_prop]\n  refine âŸ¨fun h => âŸ¨Ï€ Ï‰, by omega, rfl, hâŸ©, ?_âŸ©\n  rintro âŸ¨j, hj, rfl, hâŸ©\n  assumption\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ns : Set Î©\nâŠ¢ Iff (MeasurableSet s) (âˆ€ (i : Î¹), MeasurableSet (Inter.inter s (setOf fun Ï‰ => LE.le (Ï„ Ï‰) i)))","decl":"protected theorem measurableSet (hÏ„ : IsStoppingTime f Ï„) (s : Set Î©) :\n    MeasurableSet[hÏ„.measurableSpace] s â†” âˆ€ i : Î¹, MeasurableSet[f i] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i}) :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_mono","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nhle : LE.le Ï„ Ï€\nâŠ¢ LE.le hÏ„.measurableSpace hÏ€.measurableSpace","decl":"theorem measurableSpace_mono (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€) (hle : Ï„ â‰¤ Ï€) :\n    hÏ„.measurableSpace â‰¤ hÏ€.measurableSpace := by\n  intro s hs i\n  rw [(_ : s âˆ© {Ï‰ | Ï€ Ï‰ â‰¤ i} = s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i} âˆ© {Ï‰ | Ï€ Ï‰ â‰¤ i})]\n  Â· exact (hs i).inter (hÏ€ i)\n  Â· ext\n    simp only [Set.mem_inter_iff, iff_self_and, and_congr_left_iff, Set.mem_setOf_eq]\n    intro hle' _\n    exact le_trans (hle _) hle'\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ LE.le hÏ„.measurableSpace m","decl":"theorem measurableSpace_le_of_countable [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) :\n    hÏ„.measurableSpace â‰¤ m := by\n  intro s hs\n  change âˆ€ i, MeasurableSet[f i] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i}) at hs\n  rw [(_ : s = â‹ƒ i, s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i})]\n  Â· exact MeasurableSet.iUnion fun i => f.le i _ (hs i)\n  Â· ext Ï‰; constructor <;> rw [Set.mem_iUnion]\n    Â· exact fun hx => âŸ¨Ï„ Ï‰, hx, le_rflâŸ©\n    Â· rintro âŸ¨_, hx, _âŸ©\n      exact hx\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ² : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ¹ : Filter.atTop.IsCountablyGenerated\ninstâœ : IsDirected Î¹ fun x1 x2 => LE.le x1 x2\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ LE.le hÏ„.measurableSpace m","decl":"theorem measurableSpace_le [IsCountablyGenerated (atTop : Filter Î¹)] [IsDirected Î¹ (Â· â‰¤ Â·)]\n    (hÏ„ : IsStoppingTime f Ï„) : hÏ„.measurableSpace â‰¤ m := by\n  intro s hs\n  cases isEmpty_or_nonempty Î¹\n  Â· haveI : IsEmpty Î© := âŸ¨fun Ï‰ => IsEmpty.false (Ï„ Ï‰)âŸ©\n    apply Subsingleton.measurableSet\n  Â· change âˆ€ i, MeasurableSet[f i] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i}) at hs\n    obtain âŸ¨seq : â„• â†’ Î¹, h_seq_tendstoâŸ© := (atTop : Filter Î¹).exists_seq_tendsto\n    rw [(_ : s = â‹ƒ n, s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ seq n})]\n    Â· exact MeasurableSet.iUnion fun i => f.le (seq i) _ (hs (seq i))\n    Â· ext Ï‰; constructor <;> rw [Set.mem_iUnion]\n      Â· intro hx\n        suffices âˆƒ i, Ï„ Ï‰ â‰¤ seq i from âŸ¨this.choose, hx, this.choose_specâŸ©\n        rw [tendsto_atTop] at h_seq_tendsto\n        exact (h_seq_tendsto (Ï„ Ï‰)).exists\n      Â· rintro âŸ¨_, hx, _âŸ©\n        exact hx\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ² : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ¹ : Filter.atTop.IsCountablyGenerated\ninstâœ : IsDirected Î¹ fun x1 x2 => LE.le x1 x2\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ LE.le hÏ„.measurableSpace m","decl":"@[deprecated (since := \"2024-12-25\")] alias measurableSpace_le' := measurableSpace_le\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\ni : Î¹\nâŠ¢ Eq â‹¯.measurableSpace (â†‘f i)","decl":"@[simp]\ntheorem measurableSpace_const (f : Filtration Î¹ m) (i : Î¹) :\n    (isStoppingTime_const f i).measurableSpace = f i := by\n  ext1 s\n  change MeasurableSet[(isStoppingTime_const f i).measurableSpace] s â†” MeasurableSet[f i] s\n  rw [IsStoppingTime.measurableSet]\n  constructor <;> intro h\n  Â· specialize h i\n    simpa only [le_refl, Set.setOf_true, Set.inter_univ] using h\n  Â· intro j\n    by_cases hij : i â‰¤ j\n    Â· simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    Â· simp only [hij, Set.setOf_false, Set.inter_empty, @MeasurableSet.empty _ (f.1 j)]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_eq_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ns : Set Î©\ni : Î¹\nâŠ¢ Iff (MeasurableSet (Inter.inter s (setOf fun Ï‰ => Eq (Ï„ Ï‰) i))) (MeasurableSet (Inter.inter s (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)))","decl":"theorem measurableSet_inter_eq_iff (hÏ„ : IsStoppingTime f Ï„) (s : Set Î©) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] (s âˆ© {Ï‰ | Ï„ Ï‰ = i}) â†”\n      MeasurableSet[f i] (s âˆ© {Ï‰ | Ï„ Ï‰ = i}) := by\n  have : âˆ€ j, {Ï‰ : Î© | Ï„ Ï‰ = i} âˆ© {Ï‰ : Î© | Ï„ Ï‰ â‰¤ j} = {Ï‰ : Î© | Ï„ Ï‰ = i} âˆ© {_Ï‰ | i â‰¤ j} := by\n    intro j\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    intro hxi\n    rw [hxi]\n  constructor <;> intro h\n  Â· specialize h i\n    simpa only [Set.inter_assoc, this, le_refl, Set.setOf_true, Set.inter_univ] using h\n  Â· intro j\n    rw [Set.inter_assoc, this]\n    by_cases hij : i â‰¤ j\n    Â· simp only [hij, Set.setOf_true, Set.inter_univ]\n      exact f.mono hij _ h\n    Â· simp [hij]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_le_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nhÏ„_le : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) i\nâŠ¢ LE.le hÏ„.measurableSpace (â†‘f i)","decl":"theorem measurableSpace_le_of_le_const (hÏ„ : IsStoppingTime f Ï„) {i : Î¹} (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ i) :\n    hÏ„.measurableSpace â‰¤ f i :=\n  (measurableSpace_mono hÏ„ _ hÏ„_le).trans (measurableSpace_const _ _).le\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nn : Î¹\nhÏ„_le : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) n\nâŠ¢ LE.le hÏ„.measurableSpace m","decl":"theorem measurableSpace_le_of_le (hÏ„ : IsStoppingTime f Ï„) {n : Î¹} (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ n) :\n    hÏ„.measurableSpace â‰¤ m :=\n  (hÏ„.measurableSpace_le_of_le_const hÏ„_le).trans (f.le n)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.le_measurableSpace_of_const_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : Preorder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nhÏ„_le : âˆ€ (Ï‰ : Î©), LE.le i (Ï„ Ï‰)\nâŠ¢ LE.le (â†‘f i) hÏ„.measurableSpace","decl":"theorem le_measurableSpace_of_const_le (hÏ„ : IsStoppingTime f Ï„) {i : Î¹} (hÏ„_le : âˆ€ Ï‰, i â‰¤ Ï„ Ï‰) :\n    f i â‰¤ hÏ„.measurableSpace :=\n  (measurableSpace_const _ _).symm.le.trans (measurableSpace_mono _ hÏ„ hÏ„_le)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.sigmaFinite_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nm : MeasurableSpace Î©\nÎ¹ : Type u_4\ninstâœÂ³ : SemilatticeSup Î¹\ninstâœÂ² : OrderBot Î¹\ninstâœÂ¹ : Filter.atTop.IsCountablyGenerated\nÎ¼ : MeasureTheory.Measure Î©\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : MeasureTheory.SigmaFiniteFiltration Î¼ f\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ MeasureTheory.SigmaFinite (Î¼.trim â‹¯)","decl":"instance sigmaFinite_stopping_time {Î¹} [SemilatticeSup Î¹] [OrderBot Î¹]\n    [(Filter.atTop : Filter Î¹).IsCountablyGenerated] {Î¼ : Measure Î©} {f : Filtration Î¹ m}\n    {Ï„ : Î© â†’ Î¹} [SigmaFiniteFiltration Î¼ f] (hÏ„ : IsStoppingTime f Ï„) :\n    SigmaFinite (Î¼.trim hÏ„.measurableSpace_le) := by\n  refine @sigmaFiniteTrim_mono _ _ ?_ _ _ _ ?_ ?_\n  Â· exact f âŠ¥\n  Â· exact hÏ„.le_measurableSpace_of_const_le fun _ => bot_le\n  Â· infer_instance\n\n"}
{"name":"MeasureTheory.IsStoppingTime.sigmaFinite_stopping_time_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nm : MeasurableSpace Î©\nÎ¹ : Type u_4\ninstâœÂ² : SemilatticeSup Î¹\ninstâœÂ¹ : OrderBot Î¹\nÎ¼ : MeasureTheory.Measure Î©\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : MeasureTheory.SigmaFiniteFiltration Î¼ f\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nn : Î¹\nhÏ„_le : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) n\nâŠ¢ MeasureTheory.SigmaFinite (Î¼.trim â‹¯)","decl":"instance sigmaFinite_stopping_time_of_le {Î¹} [SemilatticeSup Î¹] [OrderBot Î¹] {Î¼ : Measure Î©}\n    {f : Filtration Î¹ m} {Ï„ : Î© â†’ Î¹} [SigmaFiniteFiltration Î¼ f] (hÏ„ : IsStoppingTime f Ï„) {n : Î¹}\n    (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ n) : SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_le hÏ„_le)) := by\n  refine @sigmaFiniteTrim_mono _ _ ?_ _ _ _ ?_ ?_\n  Â· exact f âŠ¥\n  Â· exact hÏ„.le_measurableSpace_of_const_le fun _ => bot_le\n  Â· infer_instance\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_le'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_le' (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ â‰¤ i} := by\n  intro j\n  have : {Ï‰ : Î© | Ï„ Ï‰ â‰¤ i} âˆ© {Ï‰ : Î© | Ï„ Ï‰ â‰¤ j} = {Ï‰ : Î© | Ï„ Ï‰ â‰¤ min i j} := by\n    ext1 Ï‰; simp only [Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff]\n  rw [this]\n  exact f.mono (min_le_right i j) _ (hÏ„ _)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_gt'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt i (Ï„ Ï‰))","decl":"protected theorem measurableSet_gt' (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | i < Ï„ Ï‰} := by\n  have : {Ï‰ : Î© | i < Ï„ Ï‰} = {Ï‰ : Î© | Ï„ Ï‰ â‰¤ i}á¶œ := by ext1 Ï‰; simp\n  rw [this]\n  exact (hÏ„.measurableSet_le' i).compl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_eq' [TopologicalSpace Î¹] [OrderTopology Î¹]\n    [FirstCountableTopology Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ = i} := by\n  rw [â† Set.univ_inter {Ï‰ | Ï„ Ï‰ = i}, measurableSet_inter_eq_iff, Set.univ_inter]\n  exact hÏ„.measurableSet_eq i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le i (Ï„ Ï‰))","decl":"protected theorem measurableSet_ge' [TopologicalSpace Î¹] [OrderTopology Î¹]\n    [FirstCountableTopology Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | i â‰¤ Ï„ Ï‰} := by\n  have : {Ï‰ | i â‰¤ Ï„ Ï‰} = {Ï‰ | Ï„ Ï‰ = i} âˆª {Ï‰ | i < Ï„ Ï‰} := by\n    ext1 Ï‰\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm]\n  rw [this]\n  exact (hÏ„.measurableSet_eq' i).union (hÏ„.measurableSet_gt' i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ³ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœÂ² : TopologicalSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : FirstCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_lt' [TopologicalSpace Î¹] [OrderTopology Î¹]\n    [FirstCountableTopology Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ < i} := by\n  have : {Ï‰ | Ï„ Ï‰ < i} = {Ï‰ | Ï„ Ï‰ â‰¤ i} \\ {Ï‰ | Ï„ Ï‰ = i} := by\n    ext1 Ï‰\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hÏ„.measurableSet_le' i).diff (hÏ„.measurableSet_eq' i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable_range'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_eq_of_countable_range' (hÏ„ : IsStoppingTime f Ï„)\n    (h_countable : (Set.range Ï„).Countable) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ = i} := by\n  rw [â† Set.univ_inter {Ï‰ | Ï„ Ï‰ = i}, measurableSet_inter_eq_iff, Set.univ_inter]\n  exact hÏ„.measurableSet_eq_of_countable_range h_countable i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_of_countable'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_eq_of_countable' [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ = i} :=\n  hÏ„.measurableSet_eq_of_countable_range' (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable_range'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le i (Ï„ Ï‰))","decl":"protected theorem measurableSet_ge_of_countable_range' (hÏ„ : IsStoppingTime f Ï„)\n    (h_countable : (Set.range Ï„).Countable) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | i â‰¤ Ï„ Ï‰} := by\n  have : {Ï‰ | i â‰¤ Ï„ Ï‰} = {Ï‰ | Ï„ Ï‰ = i} âˆª {Ï‰ | i < Ï„ Ï‰} := by\n    ext1 Ï‰\n    simp only [le_iff_lt_or_eq, Set.mem_setOf_eq, Set.mem_union]\n    rw [@eq_comm _ i, or_comm]\n  rw [this]\n  exact (hÏ„.measurableSet_eq_of_countable_range' h_countable i).union (hÏ„.measurableSet_gt' i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_ge_of_countable'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le i (Ï„ Ï‰))","decl":"protected theorem measurableSet_ge_of_countable' [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | i â‰¤ Ï„ Ï‰} :=\n  hÏ„.measurableSet_ge_of_countable_range' (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable_range'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_lt_of_countable_range' (hÏ„ : IsStoppingTime f Ï„)\n    (h_countable : (Set.range Ï„).Countable) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ < i} := by\n  have : {Ï‰ | Ï„ Ï‰ < i} = {Ï‰ | Ï„ Ï‰ â‰¤ i} \\ {Ï‰ | Ï„ Ï‰ = i} := by\n    ext1 Ï‰\n    simp only [lt_iff_le_and_ne, Set.mem_setOf_eq, Set.mem_diff]\n  rw [this]\n  exact (hÏ„.measurableSet_le' i).diff (hÏ„.measurableSet_eq_of_countable_range' h_countable i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_lt_of_countable'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœ : Countable Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LT.lt (Ï„ Ï‰) i)","decl":"protected theorem measurableSet_lt_of_countable' [Countable Î¹] (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ < i} :=\n  hÏ„.measurableSet_lt_of_countable_range' (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_le_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nh_countable : (Set.range Ï„).Countable\nâŠ¢ LE.le hÏ„.measurableSpace m","decl":"protected theorem measurableSpace_le_of_countable_range (hÏ„ : IsStoppingTime f Ï„)\n    (h_countable : (Set.range Ï„).Countable) : hÏ„.measurableSpace â‰¤ m := by\n  intro s hs\n  change âˆ€ i, MeasurableSet[f i] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i}) at hs\n  rw [(_ : s = â‹ƒ i âˆˆ Set.range Ï„, s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i})]\n  Â· exact MeasurableSet.biUnion h_countable fun i _ => f.le i _ (hs i)\n  Â· ext Ï‰\n    constructor <;> rw [Set.mem_iUnion]\n    Â· exact fun hx => âŸ¨Ï„ Ï‰, by simpa using hxâŸ©\n    Â· rintro âŸ¨i, hxâŸ©\n      simp only [Set.mem_range, Set.iUnion_exists, Set.mem_iUnion, Set.mem_inter_iff,\n        Set.mem_setOf_eq, exists_prop, exists_and_right] at hx\n      exact hx.2.1\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : MeasurableSpace Î¹\ninstâœÂ² : BorelSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : SecondCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ Measurable Ï„","decl":"protected theorem measurable [TopologicalSpace Î¹] [MeasurableSpace Î¹] [BorelSpace Î¹]\n    [OrderTopology Î¹] [SecondCountableTopology Î¹] (hÏ„ : IsStoppingTime f Ï„) :\n    Measurable[hÏ„.measurableSpace] Ï„ :=\n  @measurable_of_Iic Î¹ Î© _ _ _ hÏ„.measurableSpace _ _ _ _ fun i => hÏ„.measurableSet_le' i\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurable_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : MeasurableSpace Î¹\ninstâœÂ² : BorelSpace Î¹\ninstâœÂ¹ : OrderTopology Î¹\ninstâœ : SecondCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nhÏ„_le : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) i\nâŠ¢ Measurable Ï„","decl":"protected theorem measurable_of_le [TopologicalSpace Î¹] [MeasurableSpace Î¹] [BorelSpace Î¹]\n    [OrderTopology Î¹] [SecondCountableTopology Î¹] (hÏ„ : IsStoppingTime f Ï„) {i : Î¹}\n    (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ i) : Measurable[f i] Ï„ :=\n  hÏ„.measurable.mono (measurableSpace_le_of_le_const _ hÏ„_le) le_rfl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_min","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ Eq â‹¯.measurableSpace (Min.min hÏ„.measurableSpace hÏ€.measurableSpace)","decl":"theorem measurableSpace_min (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€) :\n    (hÏ„.min hÏ€).measurableSpace = hÏ„.measurableSpace âŠ“ hÏ€.measurableSpace := by\n  refine le_antisymm ?_ ?_\n  Â· exact le_inf (measurableSpace_mono _ hÏ„ fun _ => min_le_left _ _)\n      (measurableSpace_mono _ hÏ€ fun _ => min_le_right _ _)\n  Â· intro s\n    change MeasurableSet[hÏ„.measurableSpace] s âˆ§ MeasurableSet[hÏ€.measurableSpace] s â†’\n      MeasurableSet[(hÏ„.min hÏ€).measurableSpace] s\n    simp_rw [IsStoppingTime.measurableSet]\n    have : âˆ€ i, {Ï‰ | min (Ï„ Ï‰) (Ï€ Ï‰) â‰¤ i} = {Ï‰ | Ï„ Ï‰ â‰¤ i} âˆª {Ï‰ | Ï€ Ï‰ â‰¤ i} := by\n      intro i; ext1 Ï‰; simp\n    simp_rw [this, Set.inter_union_distrib_left]\n    exact fun h i => (h.left i).union (h.right i)\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_min_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\ns : Set Î©\nâŠ¢ Iff (MeasurableSet s) (And (MeasurableSet s) (MeasurableSet s))","decl":"theorem measurableSet_min_iff (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€) (s : Set Î©) :\n    MeasurableSet[(hÏ„.min hÏ€).measurableSpace] s â†”\n      MeasurableSet[hÏ„.measurableSpace] s âˆ§ MeasurableSet[hÏ€.measurableSpace] s := by\n  rw [measurableSpace_min hÏ„ hÏ€]; rfl\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSpace_min_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ Eq â‹¯.measurableSpace (Min.min hÏ„.measurableSpace (â†‘f i))","decl":"theorem measurableSpace_min_const (hÏ„ : IsStoppingTime f Ï„) {i : Î¹} :\n    (hÏ„.min_const i).measurableSpace = hÏ„.measurableSpace âŠ“ f i := by\n  rw [hÏ„.measurableSpace_min (isStoppingTime_const _ i), measurableSpace_const]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_min_const_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ns : Set Î©\ni : Î¹\nâŠ¢ Iff (MeasurableSet s) (And (MeasurableSet s) (MeasurableSet s))","decl":"theorem measurableSet_min_const_iff (hÏ„ : IsStoppingTime f Ï„) (s : Set Î©) {i : Î¹} :\n    MeasurableSet[(hÏ„.min_const i).measurableSpace] s â†”\n      MeasurableSet[hÏ„.measurableSpace] s âˆ§ MeasurableSet[f i] s := by\n  rw [measurableSpace_min_const hÏ„]; apply MeasurableSpace.measurableSet_inf\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : MeasurableSpace Î¹\ninstâœ : BorelSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\ns : Set Î©\nhs : MeasurableSet s\nâŠ¢ MeasurableSet (Inter.inter s (setOf fun Ï‰ => LE.le (Ï„ Ï‰) (Ï€ Ï‰)))","decl":"theorem measurableSet_inter_le [TopologicalSpace Î¹] [SecondCountableTopology Î¹] [OrderTopology Î¹]\n    [MeasurableSpace Î¹] [BorelSpace Î¹] (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€)\n    (s : Set Î©) (hs : MeasurableSet[hÏ„.measurableSpace] s) :\n    MeasurableSet[(hÏ„.min hÏ€).measurableSpace] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰}) := by\n  simp_rw [IsStoppingTime.measurableSet] at hs âŠ¢\n  intro i\n  have : s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} âˆ© {Ï‰ | min (Ï„ Ï‰) (Ï€ Ï‰) â‰¤ i} =\n      s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i} âˆ© {Ï‰ | min (Ï„ Ï‰) (Ï€ Ï‰) â‰¤ i} âˆ©\n        {Ï‰ | min (Ï„ Ï‰) i â‰¤ min (min (Ï„ Ï‰) (Ï€ Ï‰)) i} := by\n    ext1 Ï‰\n    simp only [min_le_iff, Set.mem_inter_iff, Set.mem_setOf_eq, le_min_iff, le_refl, true_and,\n      true_or]\n    by_cases hÏ„i : Ï„ Ï‰ â‰¤ i\n    Â· simp only [hÏ„i, true_or, and_true, and_congr_right_iff]\n      intro\n      constructor <;> intro h\n      Â· exact Or.inl h\n      Â· cases' h with h h\n        Â· exact h\n        Â· exact hÏ„i.trans h\n    simp only [hÏ„i, false_or, and_false, false_and, iff_false, not_and, not_le, and_imp]\n    refine fun _ hÏ„_le_Ï€ => lt_of_lt_of_le ?_ hÏ„_le_Ï€\n    rw [â† not_le]\n    exact hÏ„i\n  rw [this]\n  refine ((hs i).inter ((hÏ„.min hÏ€) i)).inter ?_\n  apply @measurableSet_le _ _ _ _ _ (Filtration.seq f i) _ _ _ _ _ ?_ ?_\n  Â· exact (hÏ„.min_const i).measurable_of_le fun _ => min_le_right _ _\n  Â· exact ((hÏ„.min hÏ€).min_const i).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_le_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : MeasurableSpace Î¹\ninstâœ : BorelSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\ns : Set Î©\nâŠ¢ Iff (MeasurableSet (Inter.inter s (setOf fun Ï‰ => LE.le (Ï„ Ï‰) (Ï€ Ï‰)))) (MeasurableSet (Inter.inter s (setOf fun Ï‰ => LE.le (Ï„ Ï‰) (Ï€ Ï‰))))","decl":"theorem measurableSet_inter_le_iff [TopologicalSpace Î¹] [SecondCountableTopology Î¹]\n    [OrderTopology Î¹] [MeasurableSpace Î¹] [BorelSpace Î¹] (hÏ„ : IsStoppingTime f Ï„)\n    (hÏ€ : IsStoppingTime f Ï€) (s : Set Î©) :\n    MeasurableSet[hÏ„.measurableSpace] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰}) â†”\n      MeasurableSet[(hÏ„.min hÏ€).measurableSpace] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰}) := by\n  constructor <;> intro h\n  Â· have : s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} = s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} := by\n      rw [Set.inter_assoc, Set.inter_self]\n    rw [this]\n    exact measurableSet_inter_le _ hÏ€ _ h\n  Â· rw [measurableSet_min_iff hÏ„ hÏ€] at h\n    exact h.1\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_inter_le_const_iff","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ns : Set Î©\ni : Î¹\nâŠ¢ Iff (MeasurableSet (Inter.inter s (setOf fun Ï‰ => LE.le (Ï„ Ï‰) i))) (MeasurableSet (Inter.inter s (setOf fun Ï‰ => LE.le (Ï„ Ï‰) i)))","decl":"theorem measurableSet_inter_le_const_iff (hÏ„ : IsStoppingTime f Ï„) (s : Set Î©) (i : Î¹) :\n    MeasurableSet[hÏ„.measurableSpace] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i}) â†”\n      MeasurableSet[(hÏ„.min_const i).measurableSpace] (s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ i}) := by\n  rw [IsStoppingTime.measurableSet_min_iff hÏ„ (isStoppingTime_const _ i),\n    IsStoppingTime.measurableSpace_const, IsStoppingTime.measurableSet]\n  refine âŸ¨fun h => âŸ¨h, ?_âŸ©, fun h j => h.1 jâŸ©\n  specialize h i\n  rwa [Set.inter_assoc, Set.inter_self] at h\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_le_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : MeasurableSpace Î¹\ninstâœ : BorelSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le (Ï„ Ï‰) (Ï€ Ï‰))","decl":"theorem measurableSet_le_stopping_time [TopologicalSpace Î¹] [SecondCountableTopology Î¹]\n    [OrderTopology Î¹] [MeasurableSpace Î¹] [BorelSpace Î¹] (hÏ„ : IsStoppingTime f Ï„)\n    (hÏ€ : IsStoppingTime f Ï€) : MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} := by\n  rw [hÏ„.measurableSet]\n  intro j\n  have : {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ j} = {Ï‰ | min (Ï„ Ï‰) j â‰¤ min (Ï€ Ï‰) j} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ j} := by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq, min_le_iff, le_min_iff, le_refl,\n      and_congr_left_iff]\n    intro h\n    simp only [h, or_self_iff, and_true]\n    rw [Iff.comm, or_iff_left_iff_imp]\n    exact h.trans\n  rw [this]\n  refine MeasurableSet.inter ?_ (hÏ„.measurableSet_le j)\n  apply @measurableSet_le _ _ _ _ _ (Filtration.seq f j) _ _ _ _ _ ?_ ?_\n  Â· exact (hÏ„.min_const j).measurable_of_le fun _ => min_le_right _ _\n  Â· exact (hÏ€.min_const j).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_stopping_time_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : MeasurableSpace Î¹\ninstâœ : BorelSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasurableSet (setOf fun Ï‰ => LE.le (Ï„ Ï‰) (Ï€ Ï‰))","decl":"theorem measurableSet_stopping_time_le [TopologicalSpace Î¹] [SecondCountableTopology Î¹]\n    [OrderTopology Î¹] [MeasurableSpace Î¹] [BorelSpace Î¹] (hÏ„ : IsStoppingTime f Ï„)\n    (hÏ€ : IsStoppingTime f Ï€) : MeasurableSet[hÏ€.measurableSpace] {Ï‰ | Ï„ Ï‰ â‰¤ Ï€ Ï‰} := by\n  suffices MeasurableSet[(hÏ„.min hÏ€).measurableSpace] {Ï‰ : Î© | Ï„ Ï‰ â‰¤ Ï€ Ï‰} by\n    rw [measurableSet_min_iff hÏ„ hÏ€] at this; exact this.2\n  rw [â† Set.univ_inter {Ï‰ : Î© | Ï„ Ï‰ â‰¤ Ï€ Ï‰}, â† hÏ„.measurableSet_inter_le_iff hÏ€, Set.univ_inter]\n  exact measurableSet_le_stopping_time hÏ„ hÏ€\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¸ : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\ninstâœâ· : AddGroup Î¹\ninstâœâ¶ : TopologicalSpace Î¹\ninstâœâµ : MeasurableSpace Î¹\ninstâœâ´ : BorelSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : MeasurableSingletonClass Î¹\ninstâœÂ¹ : SecondCountableTopology Î¹\ninstâœ : MeasurableSubâ‚‚ Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) (Ï€ Ï‰))","decl":"theorem measurableSet_eq_stopping_time [AddGroup Î¹] [TopologicalSpace Î¹] [MeasurableSpace Î¹]\n    [BorelSpace Î¹] [OrderTopology Î¹] [MeasurableSingletonClass Î¹] [SecondCountableTopology Î¹]\n    [MeasurableSubâ‚‚ Î¹] (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ = Ï€ Ï‰} := by\n  rw [hÏ„.measurableSet]\n  intro j\n  have : {Ï‰ | Ï„ Ï‰ = Ï€ Ï‰} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ j} =\n      {Ï‰ | min (Ï„ Ï‰) j = min (Ï€ Ï‰) j} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ j} âˆ© {Ï‰ | Ï€ Ï‰ â‰¤ j} := by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine âŸ¨fun h => âŸ¨âŸ¨?_, h.2âŸ©, ?_âŸ©, fun h => âŸ¨?_, h.1.2âŸ©âŸ©\n    Â· rw [h.1]\n    Â· rw [â† h.1]; exact h.2\n    Â· cases' h with h' hÏƒ_le\n      cases' h' with h_eq hÏ„_le\n      rwa [min_eq_left hÏ„_le, min_eq_left hÏƒ_le] at h_eq\n  rw [this]\n  refine\n    MeasurableSet.inter (MeasurableSet.inter ?_ (hÏ„.measurableSet_le j)) (hÏ€.measurableSet_le j)\n  apply measurableSet_eq_fun\n  Â· exact (hÏ„.min_const j).measurable_of_le fun _ => min_le_right _ _\n  Â· exact (hÏ€.min_const j).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.IsStoppingTime.measurableSet_eq_stopping_time_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ· : LinearOrder Î¹\nf : MeasureTheory.Filtration Î¹ m\nÏ„ Ï€ : Î© â†’ Î¹\ninstâœâ¶ : Countable Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : MeasurableSpace Î¹\ninstâœÂ³ : BorelSpace Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : MeasurableSingletonClass Î¹\ninstâœ : SecondCountableTopology Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nhÏ€ : MeasureTheory.IsStoppingTime f Ï€\nâŠ¢ MeasurableSet (setOf fun Ï‰ => Eq (Ï„ Ï‰) (Ï€ Ï‰))","decl":"theorem measurableSet_eq_stopping_time_of_countable [Countable Î¹] [TopologicalSpace Î¹]\n    [MeasurableSpace Î¹] [BorelSpace Î¹] [OrderTopology Î¹] [MeasurableSingletonClass Î¹]\n    [SecondCountableTopology Î¹] (hÏ„ : IsStoppingTime f Ï„) (hÏ€ : IsStoppingTime f Ï€) :\n    MeasurableSet[hÏ„.measurableSpace] {Ï‰ | Ï„ Ï‰ = Ï€ Ï‰} := by\n  rw [hÏ„.measurableSet]\n  intro j\n  have : {Ï‰ | Ï„ Ï‰ = Ï€ Ï‰} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ j} =\n      {Ï‰ | min (Ï„ Ï‰) j = min (Ï€ Ï‰) j} âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ j} âˆ© {Ï‰ | Ï€ Ï‰ â‰¤ j} := by\n    ext1 Ï‰\n    simp only [Set.mem_inter_iff, Set.mem_setOf_eq]\n    refine âŸ¨fun h => âŸ¨âŸ¨?_, h.2âŸ©, ?_âŸ©, fun h => âŸ¨?_, h.1.2âŸ©âŸ©\n    Â· rw [h.1]\n    Â· rw [â† h.1]; exact h.2\n    Â· cases' h with h' hÏ€_le\n      cases' h' with h_eq hÏ„_le\n      rwa [min_eq_left hÏ„_le, min_eq_left hÏ€_le] at h_eq\n  rw [this]\n  refine\n    MeasurableSet.inter (MeasurableSet.inter ?_ (hÏ„.measurableSet_le j)) (hÏ€.measurableSet_le j)\n  apply measurableSet_eq_fun_of_countable\n  Â· exact (hÏ„.min_const j).measurable_of_le fun _ => min_le_right _ _\n  Â· exact (hÏ€.min_const j).measurable_of_le fun _ => min_le_right _ _\n\n"}
{"name":"MeasureTheory.stoppedValue_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nu : Î¹ â†’ Î© â†’ Î²\ni : Î¹\nâŠ¢ Eq (MeasureTheory.stoppedValue u fun x => i) (u i)","decl":"theorem stoppedValue_const (u : Î¹ â†’ Î© â†’ Î²) (i : Î¹) : (stoppedValue u fun _ => i) = u i :=\n  rfl\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\ninstâœ : LinearOrder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„) fun i => MeasureTheory.stoppedValue u fun Ï‰ => Min.min i (Ï„ Ï‰)","decl":"theorem stoppedProcess_eq_stoppedValue {u : Î¹ â†’ Î© â†’ Î²} {Ï„ : Î© â†’ Î¹} :\n    stoppedProcess u Ï„ = fun i => stoppedValue u fun Ï‰ => min i (Ï„ Ï‰) :=\n  rfl\n\n"}
{"name":"MeasureTheory.stoppedValue_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\ninstâœ : LinearOrder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ Ïƒ : Î© â†’ Î¹\nâŠ¢ Eq (MeasureTheory.stoppedValue (MeasureTheory.stoppedProcess u Ï„) Ïƒ) (MeasureTheory.stoppedValue u fun Ï‰ => Min.min (Ïƒ Ï‰) (Ï„ Ï‰))","decl":"theorem stoppedValue_stoppedProcess {u : Î¹ â†’ Î© â†’ Î²} {Ï„ Ïƒ : Î© â†’ Î¹} :\n    stoppedValue (stoppedProcess u Ï„) Ïƒ = stoppedValue u fun Ï‰ => min (Ïƒ Ï‰) (Ï„ Ï‰) :=\n  rfl\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\ninstâœ : LinearOrder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\ni : Î¹\nÏ‰ : Î©\nh : LE.le i (Ï„ Ï‰)\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„ i Ï‰) (u i Ï‰)","decl":"theorem stoppedProcess_eq_of_le {u : Î¹ â†’ Î© â†’ Î²} {Ï„ : Î© â†’ Î¹} {i : Î¹} {Ï‰ : Î©} (h : i â‰¤ Ï„ Ï‰) :\n    stoppedProcess u Ï„ i Ï‰ = u i Ï‰ := by simp [stoppedProcess, min_eq_left h]\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_of_ge","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\ninstâœ : LinearOrder Î¹\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\ni : Î¹\nÏ‰ : Î©\nh : LE.le (Ï„ Ï‰) i\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„ i Ï‰) (u (Ï„ Ï‰) Ï‰)","decl":"theorem stoppedProcess_eq_of_ge {u : Î¹ â†’ Î© â†’ Î²} {Ï„ : Î© â†’ Î¹} {i : Î¹} {Ï‰ : Î©} (h : Ï„ Ï‰ â‰¤ i) :\n    stoppedProcess u Ï„ i Ï‰ = u (Ï„ Ï‰) Ï‰ := by simp [stoppedProcess, min_eq_right h]\n\n"}
{"name":"MeasureTheory.progMeasurable_min_stopping_time","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¶ : LinearOrder Î¹\ninstâœâµ : MeasurableSpace Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : SecondCountableTopology Î¹\ninstâœÂ¹ : BorelSpace Î¹\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ MeasureTheory.ProgMeasurable f fun i Ï‰ => Min.min i (Ï„ Ï‰)","decl":"theorem progMeasurable_min_stopping_time [MetrizableSpace Î¹] (hÏ„ : IsStoppingTime f Ï„) :\n    ProgMeasurable f fun i Ï‰ => min i (Ï„ Ï‰) := by\n  intro i\n  let m_prod : MeasurableSpace (Set.Iic i Ã— Î©) := Subtype.instMeasurableSpace.prod (f i)\n  let m_set : âˆ€ t : Set (Set.Iic i Ã— Î©), MeasurableSpace t := fun _ =>\n    @Subtype.instMeasurableSpace (Set.Iic i Ã— Î©) _ m_prod\n  let s := {p : Set.Iic i Ã— Î© | Ï„ p.2 â‰¤ i}\n  have hs : MeasurableSet[m_prod] s := @measurable_snd (Set.Iic i) Î© _ (f i) _ (hÏ„ i)\n  have h_meas_fst : âˆ€ t : Set (Set.Iic i Ã— Î©),\n      Measurable[m_set t] fun x : t => ((x : Set.Iic i Ã— Î©).fst : Î¹) :=\n    fun t => (@measurable_subtype_coe (Set.Iic i Ã— Î©) m_prod _).fst.subtype_val\n  apply Measurable.stronglyMeasurable\n  refine measurable_of_restrict_of_restrict_compl hs ?_ ?_\n  Â· refine @Measurable.min _ _ _ _ _ (m_set s) _ _ _ _ _ (h_meas_fst s) ?_\n    refine @measurable_of_Iic Î¹ s _ _ _ (m_set s) _ _ _ _ fun j => ?_\n    have h_set_eq : (fun x : s => Ï„ (x : Set.Iic i Ã— Î©).snd) â»Â¹' Set.Iic j =\n        (fun x : s => (x : Set.Iic i Ã— Î©).snd) â»Â¹' {Ï‰ | Ï„ Ï‰ â‰¤ min i j} := by\n      ext1 Ï‰\n      simp only [Set.mem_preimage, Set.mem_Iic, iff_and_self, le_min_iff, Set.mem_setOf_eq]\n      exact fun _ => Ï‰.prop\n    rw [h_set_eq]\n    suffices h_meas : @Measurable _ _ (m_set s) (f i) fun x : s â†¦ (x : Set.Iic i Ã— Î©).snd from\n      h_meas (f.mono (min_le_left _ _) _ (hÏ„.measurableSet_le (min i j)))\n    exact measurable_snd.comp (@measurable_subtype_coe _ m_prod _)\n  Â· letI sc := sá¶œ\n    suffices h_min_eq_left :\n      (fun x : sc => min (â†‘(x : Set.Iic i Ã— Î©).fst) (Ï„ (x : Set.Iic i Ã— Î©).snd)) = fun x : sc =>\n        â†‘(x : Set.Iic i Ã— Î©).fst by\n      simp +unfoldPartialApp only [sc, Set.restrict, h_min_eq_left]\n      exact h_meas_fst _\n    ext1 Ï‰\n    rw [min_eq_left]\n    have hx_fst_le : â†‘(Ï‰ : Set.Iic i Ã— Î©).fst â‰¤ i := (Ï‰ : Set.Iic i Ã— Î©).fst.prop\n    refine hx_fst_le.trans (le_of_lt ?_)\n    convert Ï‰.prop\n    simp only [sc, s, not_le, Set.mem_compl_iff, Set.mem_setOf_eq]\n\n"}
{"name":"MeasureTheory.ProgMeasurable.stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ· : LinearOrder Î¹\ninstâœâ¶ : MeasurableSpace Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : OrderTopology Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : BorelSpace Î¹\ninstâœÂ¹ : TopologicalSpace Î²\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nh : MeasureTheory.ProgMeasurable f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ MeasureTheory.ProgMeasurable f (MeasureTheory.stoppedProcess u Ï„)","decl":"theorem ProgMeasurable.stoppedProcess [MetrizableSpace Î¹] (h : ProgMeasurable f u)\n    (hÏ„ : IsStoppingTime f Ï„) : ProgMeasurable f (stoppedProcess u Ï„) :=\n  h.comp (progMeasurable_min_stopping_time hÏ„) fun _ _ => min_le_left _ _\n\n"}
{"name":"MeasureTheory.ProgMeasurable.adapted_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ· : LinearOrder Î¹\ninstâœâ¶ : MeasurableSpace Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : OrderTopology Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : BorelSpace Î¹\ninstâœÂ¹ : TopologicalSpace Î²\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nh : MeasureTheory.ProgMeasurable f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u Ï„)","decl":"theorem ProgMeasurable.adapted_stoppedProcess [MetrizableSpace Î¹] (h : ProgMeasurable f u)\n    (hÏ„ : IsStoppingTime f Ï„) : Adapted f (MeasureTheory.stoppedProcess u Ï„) :=\n  (h.stoppedProcess hÏ„).adapted\n\n"}
{"name":"MeasureTheory.ProgMeasurable.stronglyMeasurable_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ· : LinearOrder Î¹\ninstâœâ¶ : MeasurableSpace Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : OrderTopology Î¹\ninstâœÂ³ : SecondCountableTopology Î¹\ninstâœÂ² : BorelSpace Î¹\ninstâœÂ¹ : TopologicalSpace Î²\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nhu : MeasureTheory.ProgMeasurable f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\ni : Î¹\nâŠ¢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedProcess u Ï„ i)","decl":"theorem ProgMeasurable.stronglyMeasurable_stoppedProcess [MetrizableSpace Î¹]\n    (hu : ProgMeasurable f u) (hÏ„ : IsStoppingTime f Ï„) (i : Î¹) :\n    StronglyMeasurable (MeasureTheory.stoppedProcess u Ï„ i) :=\n  (hu.adapted_stoppedProcess hÏ„ i).mono (f.le _)\n\n"}
{"name":"MeasureTheory.stronglyMeasurable_stoppedValue_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¶ : LinearOrder Î¹\ninstâœâµ : MeasurableSpace Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : SecondCountableTopology Î¹\ninstâœÂ¹ : BorelSpace Î¹\ninstâœ : TopologicalSpace Î²\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\nh : MeasureTheory.ProgMeasurable f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nn : Î¹\nhÏ„_le : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) n\nâŠ¢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedValue u Ï„)","decl":"theorem stronglyMeasurable_stoppedValue_of_le (h : ProgMeasurable f u) (hÏ„ : IsStoppingTime f Ï„)\n    {n : Î¹} (hÏ„_le : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ n) : StronglyMeasurable[f n] (stoppedValue u Ï„) := by\n  have : stoppedValue u Ï„ =\n      (fun p : Set.Iic n Ã— Î© => u (â†‘p.fst) p.snd) âˆ˜ fun Ï‰ => (âŸ¨Ï„ Ï‰, hÏ„_le Ï‰âŸ©, Ï‰) := by\n    ext1 Ï‰; simp only [stoppedValue, Function.comp_apply, Subtype.coe_mk]\n  rw [this]\n  refine StronglyMeasurable.comp_measurable (h n) ?_\n  exact (hÏ„.measurable_of_le hÏ„_le).subtype_mk.prod_mk measurable_id\n\n"}
{"name":"MeasureTheory.measurable_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¹ : LinearOrder Î¹\ninstâœâ¸ : MeasurableSpace Î¹\ninstâœâ· : TopologicalSpace Î¹\ninstâœâ¶ : OrderTopology Î¹\ninstâœâµ : SecondCountableTopology Î¹\ninstâœâ´ : BorelSpace Î¹\ninstâœÂ³ : TopologicalSpace Î²\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\nf : MeasureTheory.Filtration Î¹ m\ninstâœÂ² : TopologicalSpace.MetrizableSpace Î²\ninstâœÂ¹ : MeasurableSpace Î²\ninstâœ : BorelSpace Î²\nhf_prog : MeasureTheory.ProgMeasurable f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ Measurable (MeasureTheory.stoppedValue u Ï„)","decl":"theorem measurable_stoppedValue [MetrizableSpace Î²] [MeasurableSpace Î²] [BorelSpace Î²]\n    (hf_prog : ProgMeasurable f u) (hÏ„ : IsStoppingTime f Ï„) :\n    Measurable[hÏ„.measurableSpace] (stoppedValue u Ï„) := by\n  have h_str_meas : âˆ€ i, StronglyMeasurable[f i] (stoppedValue u fun Ï‰ => min (Ï„ Ï‰) i) := fun i =>\n    stronglyMeasurable_stoppedValue_of_le hf_prog (hÏ„.min_const i) fun _ => min_le_right _ _\n  intro t ht i\n  suffices stoppedValue u Ï„ â»Â¹' t âˆ© {Ï‰ : Î© | Ï„ Ï‰ â‰¤ i} =\n      (stoppedValue u fun Ï‰ => min (Ï„ Ï‰) i) â»Â¹' t âˆ© {Ï‰ : Î© | Ï„ Ï‰ â‰¤ i} by\n    rw [this]; exact ((h_str_meas i).measurable ht).inter (hÏ„.measurableSet_le i)\n  ext1 Ï‰\n  simp only [stoppedValue, Set.mem_inter_iff, Set.mem_preimage, Set.mem_setOf_eq,\n    and_congr_left_iff]\n  intro h\n  rw [min_eq_left h]\n\n"}
{"name":"MeasureTheory.stoppedValue_eq_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœ : AddCommMonoid E\ns : Finset Î¹\nhbdd : âˆ€ (Ï‰ : Î©), Membership.mem s (Ï„ Ï‰)\nâŠ¢ Eq (MeasureTheory.stoppedValue u Ï„) (s.sum fun i => (setOf fun Ï‰ => Eq (Ï„ Ï‰) i).indicator (u i))","decl":"theorem stoppedValue_eq_of_mem_finset [AddCommMonoid E] {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ âˆˆ s) :\n    stoppedValue u Ï„ = âˆ‘ i âˆˆ s, Set.indicator {Ï‰ | Ï„ Ï‰ = i} (u i) := by\n  ext y\n  classical\n  rw [stoppedValue, Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  suffices Finset.filter (fun i => y âˆˆ {Ï‰ : Î© | Ï„ Ï‰ = i}) s = ({Ï„ y} : Finset Î¹) by\n    rw [this, Finset.sum_singleton]\n  ext1 Ï‰\n  simp only [Set.mem_setOf_eq, Finset.mem_filter, Finset.mem_singleton]\n  constructor <;> intro h\n  Â· exact h.2.symm\n  Â· refine âŸ¨?_, h.symmâŸ©; rw [h]; exact hbdd y\n\n"}
{"name":"MeasureTheory.stoppedValue_eq'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ² : Preorder Î¹\ninstâœÂ¹ : LocallyFiniteOrderBot Î¹\ninstâœ : AddCommMonoid E\nN : Î¹\nhbdd : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) N\nâŠ¢ Eq (MeasureTheory.stoppedValue u Ï„) ((Finset.Iic N).sum fun i => (setOf fun Ï‰ => Eq (Ï„ Ï‰) i).indicator (u i))","decl":"theorem stoppedValue_eq' [Preorder Î¹] [LocallyFiniteOrderBot Î¹] [AddCommMonoid E] {N : Î¹}\n    (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) :\n    stoppedValue u Ï„ = âˆ‘ i âˆˆ Finset.Iic N, Set.indicator {Ï‰ | Ï„ Ï‰ = i} (u i) :=\n  stoppedValue_eq_of_mem_finset fun Ï‰ => Finset.mem_Iic.mpr (hbdd Ï‰)\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ¹ : LinearOrder Î¹\ninstâœ : AddCommMonoid E\ns : Finset Î¹\nn : Î¹\nhbdd : âˆ€ (Ï‰ : Î©), LT.lt (Ï„ Ï‰) n â†’ Membership.mem s (Ï„ Ï‰)\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„ n) (HAdd.hAdd ((setOf fun a => LE.le n (Ï„ a)).indicator (u n)) ((Finset.filter (fun x => LT.lt x n) s).sum fun i => (setOf fun Ï‰ => Eq (Ï„ Ï‰) i).indicator (u i)))","decl":"theorem stoppedProcess_eq_of_mem_finset [LinearOrder Î¹] [AddCommMonoid E] {s : Finset Î¹} (n : Î¹)\n    (hbdd : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ s) : stoppedProcess u Ï„ n = Set.indicator {a | n â‰¤ Ï„ a} (u n) +\n      âˆ‘ i âˆˆ s.filter (Â· < n), Set.indicator {Ï‰ | Ï„ Ï‰ = i} (u i) := by\n  ext Ï‰\n  rw [Pi.add_apply, Finset.sum_apply]\n  rcases le_or_lt n (Ï„ Ï‰) with h | h\n  Â· rw [stoppedProcess_eq_of_le h, Set.indicator_of_mem, Finset.sum_eq_zero, add_zero]\n    Â· intro m hm\n      refine Set.indicator_of_not_mem ?_ _\n      rw [Finset.mem_filter] at hm\n      exact (hm.2.trans_le h).ne'\n    Â· exact h\n  Â· rw [stoppedProcess_eq_of_ge (le_of_lt h), Finset.sum_eq_single_of_mem (Ï„ Ï‰)]\n    Â· rw [Set.indicator_of_not_mem, zero_add, Set.indicator_of_mem] <;> rw [Set.mem_setOf]\n      exact not_le.2 h\n    Â· rw [Finset.mem_filter]\n      exact âŸ¨hbdd Ï‰ h, hâŸ©\n    Â· intro b _ hneq\n      rw [Set.indicator_of_not_mem]\n      rw [Set.mem_setOf]\n      exact hneq.symm\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq''","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ² : LinearOrder Î¹\ninstâœÂ¹ : LocallyFiniteOrderBot Î¹\ninstâœ : AddCommMonoid E\nn : Î¹\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„ n) (HAdd.hAdd ((setOf fun a => LE.le n (Ï„ a)).indicator (u n)) ((Finset.Iio n).sum fun i => (setOf fun Ï‰ => Eq (Ï„ Ï‰) i).indicator (u i)))","decl":"theorem stoppedProcess_eq'' [LinearOrder Î¹] [LocallyFiniteOrderBot Î¹] [AddCommMonoid E] (n : Î¹) :\n    stoppedProcess u Ï„ n = Set.indicator {a | n â‰¤ Ï„ a} (u n) +\n      âˆ‘ i âˆˆ Finset.Iio n, Set.indicator {Ï‰ | Ï„ Ï‰ = i} (u i) := by\n  have h_mem : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ Finset.Iio n := fun Ï‰ h => Finset.mem_Iio.mpr h\n  rw [stoppedProcess_eq_of_mem_finset n h_mem]\n  congr with i\n  simp\n\n"}
{"name":"MeasureTheory.memâ„’p_stoppedValue_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\np : ENNReal\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ¹ : PartialOrder Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœ : NormedAddCommGroup E\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Memâ„’p (u n) p Î¼\ns : Finset Î¹\nhbdd : âˆ€ (Ï‰ : Î©), Membership.mem s (Ï„ Ï‰)\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.stoppedValue u Ï„) p Î¼","decl":"theorem memâ„’p_stoppedValue_of_mem_finset (hÏ„ : IsStoppingTime â„± Ï„) (hu : âˆ€ n, Memâ„’p (u n) p Î¼)\n    {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ âˆˆ s) : Memâ„’p (stoppedValue u Ï„) p Î¼ := by\n  rw [stoppedValue_eq_of_mem_finset hbdd]\n  refine memâ„’p_finset_sum' _ fun i _ => Memâ„’p.indicator ?_ (hu i)\n  refine â„±.le i {a : Î© | Ï„ a = i} (hÏ„.measurableSet_eq_of_countable_range ?_ i)\n  refine ((Finset.finite_toSet s).subset fun Ï‰ hÏ‰ => ?_).countable\n  obtain âŸ¨y, rflâŸ© := hÏ‰\n  exact hbdd y\n\n"}
{"name":"MeasureTheory.memâ„’p_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\np : ENNReal\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ² : PartialOrder Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : LocallyFiniteOrderBot Î¹\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Memâ„’p (u n) p Î¼\nN : Î¹\nhbdd : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) N\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.stoppedValue u Ï„) p Î¼","decl":"theorem memâ„’p_stoppedValue [LocallyFiniteOrderBot Î¹] (hÏ„ : IsStoppingTime â„± Ï„)\n    (hu : âˆ€ n, Memâ„’p (u n) p Î¼) {N : Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) : Memâ„’p (stoppedValue u Ï„) p Î¼ :=\n  memâ„’p_stoppedValue_of_mem_finset hÏ„ hu fun Ï‰ => Finset.mem_Iic.mpr (hbdd Ï‰)\n\n"}
{"name":"MeasureTheory.integrable_stoppedValue_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ¹ : PartialOrder Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœ : NormedAddCommGroup E\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Integrable (u n) Î¼\ns : Finset Î¹\nhbdd : âˆ€ (Ï‰ : Î©), Membership.mem s (Ï„ Ï‰)\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.stoppedValue u Ï„) Î¼","decl":"theorem integrable_stoppedValue_of_mem_finset (hÏ„ : IsStoppingTime â„± Ï„)\n    (hu : âˆ€ n, Integrable (u n) Î¼) {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ âˆˆ s) :\n    Integrable (stoppedValue u Ï„) Î¼ := by\n  simp_rw [â† memâ„’p_one_iff_integrable] at hu âŠ¢\n  exact memâ„’p_stoppedValue_of_mem_finset hÏ„ hu hbdd\n\n"}
{"name":"MeasureTheory.integrable_stoppedValue","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœÂ² : PartialOrder Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : LocallyFiniteOrderBot Î¹\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Integrable (u n) Î¼\nN : Î¹\nhbdd : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) N\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.stoppedValue u Ï„) Î¼","decl":"theorem integrable_stoppedValue [LocallyFiniteOrderBot Î¹] (hÏ„ : IsStoppingTime â„± Ï„)\n    (hu : âˆ€ n, Integrable (u n) Î¼) {N : Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) :\n    Integrable (stoppedValue u Ï„) Î¼ :=\n  integrable_stoppedValue_of_mem_finset hÏ„ hu fun Ï‰ => Finset.mem_Iic.mpr (hbdd Ï‰)\n\n"}
{"name":"MeasureTheory.memâ„’p_stoppedProcess_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\np : ENNReal\nu : Î¹ â†’ Î© â†’ E\ninstâœâ´ : LinearOrder Î¹\ninstâœÂ³ : TopologicalSpace Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : FirstCountableTopology Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœ : NormedAddCommGroup E\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Memâ„’p (u n) p Î¼\nn : Î¹\ns : Finset Î¹\nhbdd : âˆ€ (Ï‰ : Î©), LT.lt (Ï„ Ï‰) n â†’ Membership.mem s (Ï„ Ï‰)\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.stoppedProcess u Ï„ n) p Î¼","decl":"theorem memâ„’p_stoppedProcess_of_mem_finset (hÏ„ : IsStoppingTime â„± Ï„) (hu : âˆ€ n, Memâ„’p (u n) p Î¼)\n    (n : Î¹) {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ s) : Memâ„’p (stoppedProcess u Ï„ n) p Î¼ := by\n  rw [stoppedProcess_eq_of_mem_finset n hbdd]\n  refine Memâ„’p.add ?_ ?_\n  Â· exact Memâ„’p.indicator (â„±.le n {a : Î© | n â‰¤ Ï„ a} (hÏ„.measurableSet_ge n)) (hu n)\n  Â· suffices Memâ„’p (fun Ï‰ => âˆ‘ i âˆˆ s.filter (Â· < n), {a : Î© | Ï„ a = i}.indicator (u i) Ï‰) p Î¼ by\n      convert this using 1; ext1 Ï‰; simp only [Finset.sum_apply]\n    refine memâ„’p_finset_sum _ fun i _ => Memâ„’p.indicator ?_ (hu i)\n    exact â„±.le i {a : Î© | Ï„ a = i} (hÏ„.measurableSet_eq i)\n\n"}
{"name":"MeasureTheory.memâ„’p_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\np : ENNReal\nu : Î¹ â†’ Î© â†’ E\ninstâœâµ : LinearOrder Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : FirstCountableTopology Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : LocallyFiniteOrderBot Î¹\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Memâ„’p (u n) p Î¼\nn : Î¹\nâŠ¢ MeasureTheory.Memâ„’p (MeasureTheory.stoppedProcess u Ï„ n) p Î¼","decl":"theorem memâ„’p_stoppedProcess [LocallyFiniteOrderBot Î¹] (hÏ„ : IsStoppingTime â„± Ï„)\n    (hu : âˆ€ n, Memâ„’p (u n) p Î¼) (n : Î¹) : Memâ„’p (stoppedProcess u Ï„ n) p Î¼ :=\n  memâ„’p_stoppedProcess_of_mem_finset hÏ„ hu n fun _ h => Finset.mem_Iio.mpr h\n\n"}
{"name":"MeasureTheory.integrable_stoppedProcess_of_mem_finset","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœâ´ : LinearOrder Î¹\ninstâœÂ³ : TopologicalSpace Î¹\ninstâœÂ² : OrderTopology Î¹\ninstâœÂ¹ : FirstCountableTopology Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœ : NormedAddCommGroup E\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Integrable (u n) Î¼\nn : Î¹\ns : Finset Î¹\nhbdd : âˆ€ (Ï‰ : Î©), LT.lt (Ï„ Ï‰) n â†’ Membership.mem s (Ï„ Ï‰)\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.stoppedProcess u Ï„ n) Î¼","decl":"theorem integrable_stoppedProcess_of_mem_finset (hÏ„ : IsStoppingTime â„± Ï„)\n    (hu : âˆ€ n, Integrable (u n) Î¼) (n : Î¹) {s : Finset Î¹} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ < n â†’ Ï„ Ï‰ âˆˆ s) :\n    Integrable (stoppedProcess u Ï„ n) Î¼ := by\n  simp_rw [â† memâ„’p_one_iff_integrable] at hu âŠ¢\n  exact memâ„’p_stoppedProcess_of_mem_finset hÏ„ hu n hbdd\n\n"}
{"name":"MeasureTheory.integrable_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\nÎ¼ : MeasureTheory.Measure Î©\nÏ„ : Î© â†’ Î¹\nE : Type u_4\nu : Î¹ â†’ Î© â†’ E\ninstâœâµ : LinearOrder Î¹\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : FirstCountableTopology Î¹\nâ„± : MeasureTheory.Filtration Î¹ m\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : LocallyFiniteOrderBot Î¹\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhu : âˆ€ (n : Î¹), MeasureTheory.Integrable (u n) Î¼\nn : Î¹\nâŠ¢ MeasureTheory.Integrable (MeasureTheory.stoppedProcess u Ï„ n) Î¼","decl":"theorem integrable_stoppedProcess [LocallyFiniteOrderBot Î¹] (hÏ„ : IsStoppingTime â„± Ï„)\n    (hu : âˆ€ n, Integrable (u n) Î¼) (n : Î¹) : Integrable (stoppedProcess u Ï„ n) Î¼ :=\n  integrable_stoppedProcess_of_mem_finset hÏ„ hu n fun _ h => Finset.mem_Iio.mpr h\n\n"}
{"name":"MeasureTheory.Adapted.stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¸ : TopologicalSpace Î²\ninstâœâ· : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœâ¶ : LinearOrder Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : SecondCountableTopology Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : BorelSpace Î¹\nf : MeasureTheory.Filtration Î¹ m\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nhu : MeasureTheory.Adapted f u\nhu_cont : âˆ€ (Ï‰ : Î©), Continuous fun i => u i Ï‰\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u Ï„)","decl":"/-- The stopped process of an adapted process with continuous paths is adapted. -/\ntheorem Adapted.stoppedProcess [MetrizableSpace Î¹] (hu : Adapted f u)\n    (hu_cont : âˆ€ Ï‰, Continuous fun i => u i Ï‰) (hÏ„ : IsStoppingTime f Ï„) :\n    Adapted f (stoppedProcess u Ï„) :=\n  ((hu.progMeasurable_of_continuous hu_cont).stoppedProcess hÏ„).adapted\n\n"}
{"name":"MeasureTheory.Adapted.stoppedProcess_of_discrete","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¸ : TopologicalSpace Î²\ninstâœâ· : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœâ¶ : LinearOrder Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : SecondCountableTopology Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : BorelSpace Î¹\nf : MeasureTheory.Filtration Î¹ m\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\ninstâœ : DiscreteTopology Î¹\nhu : MeasureTheory.Adapted f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nâŠ¢ MeasureTheory.Adapted f (MeasureTheory.stoppedProcess u Ï„)","decl":"/-- If the indexing order has the discrete topology, then the stopped process of an adapted process\nis adapted. -/\ntheorem Adapted.stoppedProcess_of_discrete [DiscreteTopology Î¹] (hu : Adapted f u)\n    (hÏ„ : IsStoppingTime f Ï„) : Adapted f (MeasureTheory.stoppedProcess u Ï„) :=\n  (hu.progMeasurable_of_discrete.stoppedProcess hÏ„).adapted\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable_stoppedProcess","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¸ : TopologicalSpace Î²\ninstâœâ· : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœâ¶ : LinearOrder Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : SecondCountableTopology Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : BorelSpace Î¹\nf : MeasureTheory.Filtration Î¹ m\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\ninstâœ : TopologicalSpace.MetrizableSpace Î¹\nhu : MeasureTheory.Adapted f u\nhu_cont : âˆ€ (Ï‰ : Î©), Continuous fun i => u i Ï‰\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nn : Î¹\nâŠ¢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedProcess u Ï„ n)","decl":"theorem Adapted.stronglyMeasurable_stoppedProcess [MetrizableSpace Î¹] (hu : Adapted f u)\n    (hu_cont : âˆ€ Ï‰, Continuous fun i => u i Ï‰) (hÏ„ : IsStoppingTime f Ï„) (n : Î¹) :\n    StronglyMeasurable (MeasureTheory.stoppedProcess u Ï„ n) :=\n  (hu.progMeasurable_of_continuous hu_cont).stronglyMeasurable_stoppedProcess hÏ„ n\n\n"}
{"name":"MeasureTheory.Adapted.stronglyMeasurable_stoppedProcess_of_discrete","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¸ : TopologicalSpace Î²\ninstâœâ· : TopologicalSpace.PseudoMetrizableSpace Î²\ninstâœâ¶ : LinearOrder Î¹\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : SecondCountableTopology Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : MeasurableSpace Î¹\ninstâœÂ¹ : BorelSpace Î¹\nf : MeasureTheory.Filtration Î¹ m\nu : Î¹ â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Î¹\ninstâœ : DiscreteTopology Î¹\nhu : MeasureTheory.Adapted f u\nhÏ„ : MeasureTheory.IsStoppingTime f Ï„\nn : Î¹\nâŠ¢ MeasureTheory.StronglyMeasurable (MeasureTheory.stoppedProcess u Ï„ n)","decl":"theorem Adapted.stronglyMeasurable_stoppedProcess_of_discrete [DiscreteTopology Î¹]\n    (hu : Adapted f u) (hÏ„ : IsStoppingTime f Ï„) (n : Î¹) :\n    StronglyMeasurable (MeasureTheory.stoppedProcess u Ï„ n) :=\n  hu.progMeasurable_of_discrete.stronglyMeasurable_stoppedProcess hÏ„ n\n\n"}
{"name":"MeasureTheory.stoppedValue_sub_eq_sum","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nu : Nat â†’ Î© â†’ Î²\nÏ„ Ï€ : Î© â†’ Nat\ninstâœ : AddCommGroup Î²\nhle : LE.le Ï„ Ï€\nâŠ¢ Eq (HSub.hSub (MeasureTheory.stoppedValue u Ï€) (MeasureTheory.stoppedValue u Ï„)) fun Ï‰ => (Finset.Ico (Ï„ Ï‰) (Ï€ Ï‰)).sum (fun i => HSub.hSub (u (HAdd.hAdd i 1)) (u i)) Ï‰","decl":"theorem stoppedValue_sub_eq_sum [AddCommGroup Î²] (hle : Ï„ â‰¤ Ï€) :\n    stoppedValue u Ï€ - stoppedValue u Ï„ = fun Ï‰ =>\n      (âˆ‘ i âˆˆ Finset.Ico (Ï„ Ï‰) (Ï€ Ï‰), (u (i + 1) - u i)) Ï‰ := by\n  ext Ï‰\n  rw [Finset.sum_Ico_eq_sub _ (hle Ï‰), Finset.sum_range_sub, Finset.sum_range_sub]\n  simp [stoppedValue]\n\n"}
{"name":"MeasureTheory.stoppedValue_sub_eq_sum'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nu : Nat â†’ Î© â†’ Î²\nÏ„ Ï€ : Î© â†’ Nat\ninstâœ : AddCommGroup Î²\nhle : LE.le Ï„ Ï€\nN : Nat\nhbdd : âˆ€ (Ï‰ : Î©), LE.le (Ï€ Ï‰) N\nâŠ¢ Eq (HSub.hSub (MeasureTheory.stoppedValue u Ï€) (MeasureTheory.stoppedValue u Ï„)) fun Ï‰ => (Finset.range (HAdd.hAdd N 1)).sum (fun i => (setOf fun Ï‰ => And (LE.le (Ï„ Ï‰) i) (LT.lt i (Ï€ Ï‰))).indicator (HSub.hSub (u (HAdd.hAdd i 1)) (u i))) Ï‰","decl":"theorem stoppedValue_sub_eq_sum' [AddCommGroup Î²] (hle : Ï„ â‰¤ Ï€) {N : â„•} (hbdd : âˆ€ Ï‰, Ï€ Ï‰ â‰¤ N) :\n    stoppedValue u Ï€ - stoppedValue u Ï„ = fun Ï‰ =>\n      (âˆ‘ i âˆˆ Finset.range (N + 1), Set.indicator {Ï‰ | Ï„ Ï‰ â‰¤ i âˆ§ i < Ï€ Ï‰} (u (i + 1) - u i)) Ï‰ := by\n  rw [stoppedValue_sub_eq_sum hle]\n  ext Ï‰\n  simp only [Finset.sum_apply, Finset.sum_indicator_eq_sum_filter]\n  refine Finset.sum_congr ?_ fun _ _ => rfl\n  ext i\n  simp only [Finset.mem_filter, Set.mem_setOf_eq, Finset.mem_range, Finset.mem_Ico]\n  exact âŸ¨fun h => âŸ¨lt_trans h.2 (Nat.lt_succ_iff.2 <| hbdd _), hâŸ©, fun h => h.2âŸ©\n\n"}
{"name":"MeasureTheory.stoppedValue_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nu : Nat â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Nat\ninstâœ : AddCommMonoid Î²\nN : Nat\nhbdd : âˆ€ (Ï‰ : Î©), LE.le (Ï„ Ï‰) N\nâŠ¢ Eq (MeasureTheory.stoppedValue u Ï„) fun x => (Finset.range (HAdd.hAdd N 1)).sum (fun i => (setOf fun Ï‰ => Eq (Ï„ Ï‰) i).indicator (u i)) x","decl":"theorem stoppedValue_eq {N : â„•} (hbdd : âˆ€ Ï‰, Ï„ Ï‰ â‰¤ N) : stoppedValue u Ï„ = fun x =>\n    (âˆ‘ i âˆˆ Finset.range (N + 1), Set.indicator {Ï‰ | Ï„ Ï‰ = i} (u i)) x :=\n  stoppedValue_eq_of_mem_finset fun Ï‰ => Finset.mem_range_succ_iff.mpr (hbdd Ï‰)\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nu : Nat â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Nat\ninstâœ : AddCommMonoid Î²\nn : Nat\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„ n) (HAdd.hAdd ((setOf fun a => LE.le n (Ï„ a)).indicator (u n)) ((Finset.range n).sum fun i => (setOf fun Ï‰ => Eq (Ï„ Ï‰) i).indicator (u i)))","decl":"theorem stoppedProcess_eq (n : â„•) : stoppedProcess u Ï„ n = Set.indicator {a | n â‰¤ Ï„ a} (u n) +\n    âˆ‘ i âˆˆ Finset.range n, Set.indicator {Ï‰ | Ï„ Ï‰ = i} (u i) := by\n  rw [stoppedProcess_eq'' n]\n  congr with i\n  rw [Finset.mem_Iio, Finset.mem_range]\n\n"}
{"name":"MeasureTheory.stoppedProcess_eq'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ² : Type u_2\nu : Nat â†’ Î© â†’ Î²\nÏ„ : Î© â†’ Nat\ninstâœ : AddCommMonoid Î²\nn : Nat\nâŠ¢ Eq (MeasureTheory.stoppedProcess u Ï„ n) (HAdd.hAdd ((setOf fun a => LE.le (HAdd.hAdd n 1) (Ï„ a)).indicator (u n)) ((Finset.range (HAdd.hAdd n 1)).sum fun i => (setOf fun a => Eq (Ï„ a) i).indicator (u i)))","decl":"theorem stoppedProcess_eq' (n : â„•) : stoppedProcess u Ï„ n = Set.indicator {a | n + 1 â‰¤ Ï„ a} (u n) +\n    âˆ‘ i âˆˆ Finset.range (n + 1), Set.indicator {a | Ï„ a = i} (u i) := by\n  have : {a | n â‰¤ Ï„ a}.indicator (u n) =\n      {a | n + 1 â‰¤ Ï„ a}.indicator (u n) + {a | Ï„ a = n}.indicator (u n) := by\n    ext x\n    rw [add_comm, Pi.add_apply, â† Set.indicator_union_of_not_mem_inter]\n    Â· simp_rw [@eq_comm _ _ n, @le_iff_eq_or_lt _ _ n, Nat.succ_le_iff, Set.setOf_or]\n    Â· rintro âŸ¨hâ‚, hâ‚‚âŸ©\n      rw [Set.mem_setOf] at hâ‚ hâ‚‚\n      exact (Nat.succ_le_iff.1 hâ‚‚).ne hâ‚.symm\n  rw [stoppedProcess_eq, this, Finset.sum_range_succ_comm, â† add_assoc]\n\n"}
{"name":"MeasureTheory.IsStoppingTime.piecewise_of_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : Preorder Î¹\nğ’¢ : MeasureTheory.Filtration Î¹ m\nÏ„ Î· : Î© â†’ Î¹\ni : Î¹\ns : Set Î©\ninstâœ : DecidablePred fun x => Membership.mem s x\nhÏ„_st : MeasureTheory.IsStoppingTime ğ’¢ Ï„\nhÎ·_st : MeasureTheory.IsStoppingTime ğ’¢ Î·\nhÏ„ : âˆ€ (Ï‰ : Î©), LE.le i (Ï„ Ï‰)\nhÎ· : âˆ€ (Ï‰ : Î©), LE.le i (Î· Ï‰)\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.IsStoppingTime ğ’¢ (s.piecewise Ï„ Î·)","decl":"/-- Given stopping times `Ï„` and `Î·` which are bounded below, `Set.piecewise s Ï„ Î·` is also\na stopping time with respect to the same filtration. -/\ntheorem IsStoppingTime.piecewise_of_le (hÏ„_st : IsStoppingTime ğ’¢ Ï„) (hÎ·_st : IsStoppingTime ğ’¢ Î·)\n    (hÏ„ : âˆ€ Ï‰, i â‰¤ Ï„ Ï‰) (hÎ· : âˆ€ Ï‰, i â‰¤ Î· Ï‰) (hs : MeasurableSet[ğ’¢ i] s) :\n    IsStoppingTime ğ’¢ (s.piecewise Ï„ Î·) := by\n  intro n\n  have : {Ï‰ | s.piecewise Ï„ Î· Ï‰ â‰¤ n} = s âˆ© {Ï‰ | Ï„ Ï‰ â‰¤ n} âˆª sá¶œ âˆ© {Ï‰ | Î· Ï‰ â‰¤ n} := by\n    ext1 Ï‰\n    simp only [Set.piecewise, Set.mem_inter_iff, Set.mem_setOf_eq, and_congr_right_iff]\n    by_cases hx : Ï‰ âˆˆ s <;> simp [hx]\n  rw [this]\n  by_cases hin : i â‰¤ n\n  Â· have hs_n : MeasurableSet[ğ’¢ n] s := ğ’¢.mono hin _ hs\n    exact (hs_n.inter (hÏ„_st n)).union (hs_n.compl.inter (hÎ·_st n))\n  Â· have hÏ„n : âˆ€ Ï‰, Â¬Ï„ Ï‰ â‰¤ n := fun Ï‰ hÏ„n => hin ((hÏ„ Ï‰).trans hÏ„n)\n    have hÎ·n : âˆ€ Ï‰, Â¬Î· Ï‰ â‰¤ n := fun Ï‰ hÎ·n => hin ((hÎ· Ï‰).trans hÎ·n)\n    simp [hÏ„n, hÎ·n, @MeasurableSet.empty _ _]\n\n"}
{"name":"MeasureTheory.isStoppingTime_piecewise_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹ : Preorder Î¹\nğ’¢ : MeasureTheory.Filtration Î¹ m\ni j : Î¹\ns : Set Î©\ninstâœ : DecidablePred fun x => Membership.mem s x\nhij : LE.le i j\nhs : MeasurableSet s\nâŠ¢ MeasureTheory.IsStoppingTime ğ’¢ (s.piecewise (fun x => i) fun x => j)","decl":"theorem isStoppingTime_piecewise_const (hij : i â‰¤ j) (hs : MeasurableSet[ğ’¢ i] s) :\n    IsStoppingTime ğ’¢ (s.piecewise (fun _ => i) fun _ => j) :=\n  (isStoppingTime_const ğ’¢ i).piecewise_of_le (isStoppingTime_const ğ’¢ j) (fun _ => le_rfl)\n    (fun _ => hij) hs\n\n"}
{"name":"MeasureTheory.stoppedValue_piecewise_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\ns : Set Î©\ninstâœ : DecidablePred fun x => Membership.mem s x\nÎ¹' : Type u_4\ni j : Î¹'\nf : Î¹' â†’ Î© â†’ Real\nâŠ¢ Eq (MeasureTheory.stoppedValue f (s.piecewise (fun x => i) fun x => j)) (s.piecewise (f i) (f j))","decl":"theorem stoppedValue_piecewise_const {Î¹' : Type*} {i j : Î¹'} {f : Î¹' â†’ Î© â†’ â„} :\n    stoppedValue f (s.piecewise (fun _ => i) fun _ => j) = s.piecewise (f i) (f j) := by\n  ext Ï‰; rw [stoppedValue]; by_cases hx : Ï‰ âˆˆ s <;> simp [hx]\n\n"}
{"name":"MeasureTheory.stoppedValue_piecewise_const'","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\ns : Set Î©\ninstâœ : DecidablePred fun x => Membership.mem s x\nÎ¹' : Type u_4\ni j : Î¹'\nf : Î¹' â†’ Î© â†’ Real\nâŠ¢ Eq (MeasureTheory.stoppedValue f (s.piecewise (fun x => i) fun x => j)) (HAdd.hAdd (s.indicator (f i)) ((HasCompl.compl s).indicator (f j)))","decl":"theorem stoppedValue_piecewise_const' {Î¹' : Type*} {i j : Î¹'} {f : Î¹' â†’ Î© â†’ â„} :\n    stoppedValue f (s.piecewise (fun _ => i) fun _ => j) =\n    s.indicator (f i) + sá¶œ.indicator (f j) := by\n  ext Ï‰; rw [stoppedValue]; by_cases hx : Ï‰ âˆˆ s <;> simp [hx]\n\n"}
{"name":"MeasureTheory.condExp_stopping_time_ae_eq_restrict_eq_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\nf : Î© â†’ E\ninstâœÂ¹ : MeasureTheory.SigmaFiniteFiltration Î¼ â„±\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nh_countable : (Set.range Ï„).Countable\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\ni : Î¹\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => Eq (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f) (MeasureTheory.condExp (â†‘â„± i) Î¼ f)","decl":"theorem condExp_stopping_time_ae_eq_restrict_eq_of_countable_range [SigmaFiniteFiltration Î¼ â„±]\n    (hÏ„ : IsStoppingTime â„± Ï„) (h_countable : (Set.range Ï„).Countable)\n    [SigmaFinite (Î¼.trim (hÏ„.measurableSpace_le_of_countable_range h_countable))] (i : Î¹) :\n    Î¼[f|hÏ„.measurableSpace] =áµ[Î¼.restrict {x | Ï„ x = i}] Î¼[f|â„± i] := by\n  refine condExp_ae_eq_restrict_of_measurableSpace_eq_on\n    (hÏ„.measurableSpace_le_of_countable_range h_countable) (â„±.le i)\n    (hÏ„.measurableSet_eq_of_countable_range' h_countable i) fun t => ?_\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]\n\n"}
{"name":"MeasureTheory.condexp_stopping_time_ae_eq_restrict_eq_of_countable_range","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\nf : Î© â†’ E\ninstâœÂ¹ : MeasureTheory.SigmaFiniteFiltration Î¼ â„±\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nh_countable : (Set.range Ï„).Countable\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\ni : Î¹\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => Eq (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f) (MeasureTheory.condExp (â†‘â„± i) Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stopping_time_ae_eq_restrict_eq_of_countable_range :=\n  condExp_stopping_time_ae_eq_restrict_eq_of_countable_range\n\n"}
{"name":"MeasureTheory.condExp_stopping_time_ae_eq_restrict_eq_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¶ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\nf : Î© â†’ E\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : MeasureTheory.SigmaFiniteFiltration Î¼ â„±\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\ni : Î¹\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => Eq (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f) (MeasureTheory.condExp (â†‘â„± i) Î¼ f)","decl":"theorem condExp_stopping_time_ae_eq_restrict_eq_of_countable [Countable Î¹]\n    [SigmaFiniteFiltration Î¼ â„±] (hÏ„ : IsStoppingTime â„± Ï„)\n    [SigmaFinite (Î¼.trim hÏ„.measurableSpace_le_of_countable)] (i : Î¹) :\n    Î¼[f|hÏ„.measurableSpace] =áµ[Î¼.restrict {x | Ï„ x = i}] Î¼[f|â„± i] :=\n  condExp_stopping_time_ae_eq_restrict_eq_of_countable_range hÏ„ (Set.to_countable _) i\n\n"}
{"name":"MeasureTheory.condexp_stopping_time_ae_eq_restrict_eq_of_countable","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¶ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace Real E\ninstâœÂ³ : CompleteSpace E\nf : Î© â†’ E\ninstâœÂ² : Countable Î¹\ninstâœÂ¹ : MeasureTheory.SigmaFiniteFiltration Î¼ â„±\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\ni : Î¹\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => Eq (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f) (MeasureTheory.condExp (â†‘â„± i) Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stopping_time_ae_eq_restrict_eq_of_countable :=\n  condExp_stopping_time_ae_eq_restrict_eq_of_countable\n\n"}
{"name":"MeasureTheory.condExp_min_stopping_time_ae_eq_restrict_le_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\nf : Î© â†’ E\ninstâœÂ¹ : Filter.atTop.IsCountablyGenerated\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\ni : Î¹\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => LE.le (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp â‹¯.measurableSpace Î¼ f) (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f)","decl":"theorem condExp_min_stopping_time_ae_eq_restrict_le_const (hÏ„ : IsStoppingTime â„± Ï„) (i : Î¹)\n    [SigmaFinite (Î¼.trim (hÏ„.min_const i).measurableSpace_le)] :\n    Î¼[f|(hÏ„.min_const i).measurableSpace] =áµ[Î¼.restrict {x | Ï„ x â‰¤ i}] Î¼[f|hÏ„.measurableSpace] := by\n  have : SigmaFinite (Î¼.trim hÏ„.measurableSpace_le) :=\n    haveI h_le : (hÏ„.min_const i).measurableSpace â‰¤ hÏ„.measurableSpace := by\n      rw [IsStoppingTime.measurableSpace_min_const]\n      exact inf_le_left\n    sigmaFiniteTrim_mono _ h_le\n  refine (condExp_ae_eq_restrict_of_measurableSpace_eq_on hÏ„.measurableSpace_le\n    (hÏ„.min_const i).measurableSpace_le (hÏ„.measurableSet_le' i) fun t => ?_).symm\n  rw [Set.inter_comm _ t, hÏ„.measurableSet_inter_le_const_iff]\n\n"}
{"name":"MeasureTheory.condexp_min_stopping_time_ae_eq_restrict_le_const","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâµ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace Real E\ninstâœÂ² : CompleteSpace E\nf : Î© â†’ E\ninstâœÂ¹ : Filter.atTop.IsCountablyGenerated\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\ni : Î¹\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => LE.le (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp â‹¯.measurableSpace Î¼ f) (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_min_stopping_time_ae_eq_restrict_le_const :=\n  condExp_min_stopping_time_ae_eq_restrict_le_const\n\n"}
{"name":"MeasureTheory.condExp_stopping_time_ae_eq_restrict_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¹ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : CompleteSpace E\nf : Î© â†’ E\ninstâœâµ : Filter.atTop.IsCountablyGenerated\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : FirstCountableTopology Î¹\ninstâœÂ¹ : MeasureTheory.SigmaFiniteFiltration Î¼ â„±\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\ni : Î¹\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => Eq (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f) (MeasureTheory.condExp (â†‘â„± i) Î¼ f)","decl":"theorem condExp_stopping_time_ae_eq_restrict_eq [FirstCountableTopology Î¹]\n    [SigmaFiniteFiltration Î¼ â„±] (hÏ„ : IsStoppingTime â„± Ï„)\n    [SigmaFinite (Î¼.trim hÏ„.measurableSpace_le)] (i : Î¹) :\n    Î¼[f|hÏ„.measurableSpace] =áµ[Î¼.restrict {x | Ï„ x = i}] Î¼[f|â„± i] := by\n  refine condExp_ae_eq_restrict_of_measurableSpace_eq_on hÏ„.measurableSpace_le (â„±.le i)\n    (hÏ„.measurableSet_eq' i) fun t => ?_\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_eq_iff]\n\n"}
{"name":"MeasureTheory.condexp_stopping_time_ae_eq_restrict_eq","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœâ¹ : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ¸ : NormedAddCommGroup E\ninstâœâ· : NormedSpace Real E\ninstâœâ¶ : CompleteSpace E\nf : Î© â†’ E\ninstâœâµ : Filter.atTop.IsCountablyGenerated\ninstâœâ´ : TopologicalSpace Î¹\ninstâœÂ³ : OrderTopology Î¹\ninstâœÂ² : FirstCountableTopology Î¹\ninstâœÂ¹ : MeasureTheory.SigmaFiniteFiltration Î¼ â„±\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\ni : Î¹\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => Eq (Ï„ x) i))).EventuallyEq (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f) (MeasureTheory.condExp (â†‘â„± i) Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_stopping_time_ae_eq_restrict_eq := condExp_stopping_time_ae_eq_restrict_eq\n\n"}
{"name":"MeasureTheory.condExp_min_stopping_time_ae_eq_restrict_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹â° : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ Ïƒ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\ninstâœâ· : CompleteSpace E\nf : Î© â†’ E\ninstâœâ¶ : Filter.atTop.IsCountablyGenerated\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : OrderTopology Î¹\ninstâœÂ³ : MeasurableSpace Î¹\ninstâœÂ² : SecondCountableTopology Î¹\ninstâœÂ¹ : BorelSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhÏƒ : MeasureTheory.IsStoppingTime â„± Ïƒ\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => LE.le (Ï„ x) (Ïƒ x)))).EventuallyEq (MeasureTheory.condExp â‹¯.measurableSpace Î¼ f) (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f)","decl":"theorem condExp_min_stopping_time_ae_eq_restrict_le [MeasurableSpace Î¹] [SecondCountableTopology Î¹]\n    [BorelSpace Î¹] (hÏ„ : IsStoppingTime â„± Ï„) (hÏƒ : IsStoppingTime â„± Ïƒ)\n    [SigmaFinite (Î¼.trim (hÏ„.min hÏƒ).measurableSpace_le)] :\n    Î¼[f|(hÏ„.min hÏƒ).measurableSpace] =áµ[Î¼.restrict {x | Ï„ x â‰¤ Ïƒ x}] Î¼[f|hÏ„.measurableSpace] := by\n  have : SigmaFinite (Î¼.trim hÏ„.measurableSpace_le) :=\n    haveI h_le : (hÏ„.min hÏƒ).measurableSpace â‰¤ hÏ„.measurableSpace := by\n      rw [IsStoppingTime.measurableSpace_min]\n      Â· exact inf_le_left\n      Â· simp_all only\n    sigmaFiniteTrim_mono _ h_le\n  refine (condExp_ae_eq_restrict_of_measurableSpace_eq_on hÏ„.measurableSpace_le\n    (hÏ„.min hÏƒ).measurableSpace_le (hÏ„.measurableSet_le_stopping_time hÏƒ) fun t => ?_).symm\n  rw [Set.inter_comm _ t, IsStoppingTime.measurableSet_inter_le_iff]; simp_all only\n\n"}
{"name":"MeasureTheory.condexp_min_stopping_time_ae_eq_restrict_le","module":"Mathlib.Probability.Process.Stopping","initialProofState":"Î© : Type u_1\nÎ¹ : Type u_3\nm : MeasurableSpace Î©\ninstâœÂ¹â° : LinearOrder Î¹\nÎ¼ : MeasureTheory.Measure Î©\nâ„± : MeasureTheory.Filtration Î¹ m\nÏ„ Ïƒ : Î© â†’ Î¹\nE : Type u_4\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace Real E\ninstâœâ· : CompleteSpace E\nf : Î© â†’ E\ninstâœâ¶ : Filter.atTop.IsCountablyGenerated\ninstâœâµ : TopologicalSpace Î¹\ninstâœâ´ : OrderTopology Î¹\ninstâœÂ³ : MeasurableSpace Î¹\ninstâœÂ² : SecondCountableTopology Î¹\ninstâœÂ¹ : BorelSpace Î¹\nhÏ„ : MeasureTheory.IsStoppingTime â„± Ï„\nhÏƒ : MeasureTheory.IsStoppingTime â„± Ïƒ\ninstâœ : MeasureTheory.SigmaFinite (Î¼.trim â‹¯)\nâŠ¢ (MeasureTheory.ae (Î¼.restrict (setOf fun x => LE.le (Ï„ x) (Ïƒ x)))).EventuallyEq (MeasureTheory.condExp â‹¯.measurableSpace Î¼ f) (MeasureTheory.condExp hÏ„.measurableSpace Î¼ f)","decl":"@[deprecated (since := \"2025-01-21\")]\nalias condexp_min_stopping_time_ae_eq_restrict_le := condExp_min_stopping_time_ae_eq_restrict_le\n\n"}
