{"name":"Valuation.subgroups_basis","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nv : Valuation R Î“â‚€\nâŠ¢ RingSubgroupsBasis fun Î³ => v.ltAddSubgroup Î³","decl":"/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem subgroups_basis : RingSubgroupsBasis fun Î³ : Î“â‚€Ë£ => (v.ltAddSubgroup Î³ : AddSubgroup R) :=\n  { inter := by\n      rintro Î³â‚€ Î³â‚\n      use min Î³â‚€ Î³â‚\n      simp only [ltAddSubgroup, Units.min_val, Units.val_le_val, lt_min_iff,\n        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,\n        forall_const, and_true]\n      tauto\n    mul := by\n      rintro Î³\n      cases' exists_square_le Î³ with Î³â‚€ h\n      use Î³â‚€\n      rintro - âŸ¨r, r_in, s, s_in, rflâŸ©\n      simp only [ltAddSubgroup, AddSubgroup.coe_set_mk, mem_setOf_eq] at r_in s_in\n      calc\n        (v (r * s) : Î“â‚€) = v r * v s := Valuation.map_mul _ _ _\n        _ < Î³â‚€ * Î³â‚€ := by gcongr <;> exact zero_le'\n        _ â‰¤ Î³ := mod_cast h\n    leftMul := by\n      rintro x Î³\n      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)\n      Â· use (1 : Î“â‚€Ë£)\n        rintro y _\n        change v (x * y) < _\n        rw [Valuation.map_mul, Hx, zero_mul]\n        exact Units.zero_lt Î³\n      Â· use Î³xâ»Â¹ * Î³\n        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))\n        change (v (x * y) : Î“â‚€) < Î³\n        rw [Valuation.map_mul, Hx, mul_comm]\n        rw [Units.val_mul, mul_comm] at vy_lt\n        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt\n    rightMul := by\n      rintro x Î³\n      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | âŸ¨Î³x, HxâŸ©)\n      Â· use 1\n        rintro y _\n        change v (y * x) < _\n        rw [Valuation.map_mul, Hx, mul_zero]\n        exact Units.zero_lt Î³\n      Â· use Î³xâ»Â¹ * Î³\n        rintro y (vy_lt : v y < â†‘(Î³xâ»Â¹ * Î³))\n        change (v (y * x) : Î“â‚€) < Î³\n        rw [Valuation.map_mul, Hx]\n        rw [Units.val_mul, mul_comm] at vy_lt\n        simpa using mul_inv_lt_of_lt_mulâ‚€ vy_lt }\n\n"}
{"name":"Valued.is_topological_valuation","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : outParam (Type v)\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nself : Valued R Î“â‚€\ns : Set R\nâŠ¢ Iff (Membership.mem (nhds 0) s) (Exists fun Î³ => HasSubset.Subset (setOf fun x => LT.lt (Valued.v x) â†‘Î³) s)","decl":"/-- A valued ring is a ring that comes equipped with a distinguished valuation. The class `Valued`\nis designed for the situation that there is a canonical valuation on the ring.\n\nTODO: show that there always exists an equivalent valuation taking values in a type belonging to\nthe same universe as the ring.\n\nSee Note [forgetful inheritance] for why we extend `UniformSpace`, `UniformAddGroup`. -/\nclass Valued (R : Type u) [Ring R] (Î“â‚€ : outParam (Type v))\n  [LinearOrderedCommGroupWithZero Î“â‚€] extends UniformSpace R, UniformAddGroup R where\n  v : Valuation R Î“â‚€\n  is_topological_valuation : âˆ€ s, s âˆˆ ğ“ (0 : R) â†” âˆƒ Î³ : Î“â‚€Ë£, { x : R | v x < Î³ } âŠ† s\n\n"}
{"name":"Valued.toUniformAddGroup","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : outParam (Type v)\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\nself : Valued R Î“â‚€\nâŠ¢ UniformAddGroup R","decl":"/-- A valued ring is a ring that comes equipped with a distinguished valuation. The class `Valued`\nis designed for the situation that there is a canonical valuation on the ring.\n\nTODO: show that there always exists an equivalent valuation taking values in a type belonging to\nthe same universe as the ring.\n\nSee Note [forgetful inheritance] for why we extend `UniformSpace`, `UniformAddGroup`. -/\nclass Valued (R : Type u) [Ring R] (Î“â‚€ : outParam (Type v))\n  [LinearOrderedCommGroupWithZero Î“â‚€] extends UniformSpace R, UniformAddGroup R where\n  v : Valuation R Î“â‚€\n  is_topological_valuation : âˆ€ s, s âˆˆ ğ“ (0 : R) â†” âˆƒ Î³ : Î“â‚€Ë£, { x : R | v x < Î³ } âŠ† s\n\n"}
{"name":"Valued.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nâŠ¢ (nhds 0).HasBasis (fun x => True) fun Î³ => setOf fun x => LT.lt (Valued.v x) â†‘Î³","decl":"theorem hasBasis_nhds_zero :\n    (ğ“ (0 : R)).HasBasis (fun _ => True) fun Î³ : Î“â‚€Ë£ => { x | v x < (Î³ : Î“â‚€) } := by\n  simp [Filter.hasBasis_iff, is_topological_valuation]\n\n-- Porting note: Replaced `ğ“¤ R` with `uniformity R`\n"}
{"name":"Valued.hasBasis_uniformity","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nâŠ¢ (uniformity R).HasBasis (fun x => True) fun Î³ => setOf fun p => LT.lt (Valued.v (HSub.hSub p.2 p.1)) â†‘Î³","decl":"theorem hasBasis_uniformity : (uniformity R).HasBasis (fun _ => True)\n    fun Î³ : Î“â‚€Ë£ => { p : R Ã— R | v (p.2 - p.1) < (Î³ : Î“â‚€) } := by\n  rw [uniformity_eq_comap_nhds_zero]\n  exact (hasBasis_nhds_zero R Î“â‚€).comap _\n\n"}
{"name":"Valued.toUniformSpace_eq","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nâŠ¢ Eq Valued.toUniformSpace (TopologicalAddGroup.toUniformSpace R)","decl":"theorem toUniformSpace_eq :\n    toUniformSpace = @TopologicalAddGroup.toUniformSpace R _ v.subgroups_basis.topology _ :=\n  UniformSpace.ext\n    ((hasBasis_uniformity R Î“â‚€).eq_of_same_basis <| v.subgroups_basis.hasBasis_nhds_zero.comap _)\n\n"}
{"name":"Valued.mem_nhds","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\ns : Set R\nx : R\nâŠ¢ Iff (Membership.mem (nhds x) s) (Exists fun Î³ => HasSubset.Subset (setOf fun y => LT.lt (Valued.v (HSub.hSub y x)) â†‘Î³) s)","decl":"theorem mem_nhds {s : Set R} {x : R} : s âˆˆ ğ“ x â†” âˆƒ Î³ : Î“â‚€Ë£, { y | (v (y - x) : Î“â‚€) < Î³ } âŠ† s := by\n  simp only [â† nhds_translation_add_neg x, â† sub_eq_add_neg, preimage_setOf_eq, true_and,\n    ((hasBasis_nhds_zero R Î“â‚€).comap fun y => y - x).mem_iff]\n\n"}
{"name":"Valued.mem_nhds_zero","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\ns : Set R\nâŠ¢ Iff (Membership.mem (nhds 0) s) (Exists fun Î³ => HasSubset.Subset (setOf fun x => LT.lt (Valued.v x) â†‘Î³) s)","decl":"theorem mem_nhds_zero {s : Set R} : s âˆˆ ğ“ (0 : R) â†” âˆƒ Î³ : Î“â‚€Ë£, { x | v x < (Î³ : Î“â‚€) } âŠ† s := by\n  simp only [mem_nhds, sub_zero]\n\n"}
{"name":"Valued.loc_const","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nx : R\nh : Ne (Valued.v x) 0\nâŠ¢ Membership.mem (nhds x) (setOf fun y => Eq (Valued.v y) (Valued.v x))","decl":"theorem loc_const {x : R} (h : (v x : Î“â‚€) â‰  0) : { y : R | v y = v x } âˆˆ ğ“ x := by\n  rw [mem_nhds]\n  use Units.mk0 _ h\n  rw [Units.val_mk0]\n  intro y y_in\n  exact Valuation.map_eq_of_sub_lt _ y_in\n\n"}
{"name":"Valued.instTopologicalRing","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nâŠ¢ TopologicalRing R","decl":"instance (priority := 100) : TopologicalRing R :=\n  (toUniformSpace_eq R Î“â‚€).symm â–¸ v.subgroups_basis.toRingFilterBasis.isTopologicalRing\n\n"}
{"name":"Valued.cauchy_iff","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nF : Filter R\nâŠ¢ Iff (Cauchy F) (And F.NeBot (âˆ€ (Î³ : Units Î“â‚€), Exists fun M => And (Membership.mem F M) (âˆ€ (x : R), Membership.mem M x â†’ âˆ€ (y : R), Membership.mem M y â†’ LT.lt (Valued.v (HSub.hSub y x)) â†‘Î³)))","decl":"theorem cauchy_iff {F : Filter R} : Cauchy F â†”\n    F.NeBot âˆ§ âˆ€ Î³ : Î“â‚€Ë£, âˆƒ M âˆˆ F, âˆ€áµ‰ (x âˆˆ M) (y âˆˆ M), (v (y - x) : Î“â‚€) < Î³ := by\n  rw [toUniformSpace_eq, AddGroupFilterBasis.cauchy_iff]\n  apply and_congr Iff.rfl\n  simp_rw [Valued.v.subgroups_basis.mem_addGroupFilterBasis_iff]\n  constructor\n  Â· intro h Î³\n    exact h _ (Valued.v.subgroups_basis.mem_addGroupFilterBasis _)\n  Â· rintro h - âŸ¨Î³, rflâŸ©\n    exact h Î³\n\n"}
{"name":"Valued.integer_isOpen","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninstâœÂ¹ : Ring R\nÎ“â‚€ : Type v\ninstâœ : LinearOrderedCommGroupWithZero Î“â‚€\n_i : Valued R Î“â‚€\nâŠ¢ IsOpen â†‘Valued.v.integer","decl":"/-- The unit ball of a valued ring is open. -/\ntheorem integer_isOpen : IsOpen (_i.v.integer : Set R) := by\n  rw [isOpen_iff_mem_nhds]\n  intro x hx\n  rw [mem_nhds]\n  exact âŸ¨1,\n    fun y hy => (sub_add_cancel y x).symm â–¸ le_trans (map_add _ _ _) (max_le (le_of_lt hy) hx)âŸ©\n\n"}
{"name":"Valued.valuationSubring_isOpen","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"Î“â‚€ : Type v\ninstâœÂ¹ : LinearOrderedCommGroupWithZero Î“â‚€\nK : Type u\ninstâœ : Field K\nhv : Valued K Î“â‚€\nâŠ¢ IsOpen â†‘Valued.v.valuationSubring","decl":"/-- The valuation subring of a valued field is open. -/\ntheorem valuationSubring_isOpen (K : Type u) [Field K] [hv : Valued K Î“â‚€] :\n    IsOpen (hv.v.valuationSubring : Set K) :=\n  integer_isOpen K\n\n"}
