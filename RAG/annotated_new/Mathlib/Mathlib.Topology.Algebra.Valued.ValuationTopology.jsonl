{"name":"Valuation.subgroups_basis","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nv : Valuation R Γ₀\n⊢ RingSubgroupsBasis fun γ => v.ltAddSubgroup γ","decl":"/-- The basis of open subgroups for the topology on a ring determined by a valuation. -/\ntheorem subgroups_basis : RingSubgroupsBasis fun γ : Γ₀ˣ => (v.ltAddSubgroup γ : AddSubgroup R) :=\n  { inter := by\n      rintro γ₀ γ₁\n      use min γ₀ γ₁\n      simp only [ltAddSubgroup, Units.min_val, Units.val_le_val, lt_min_iff,\n        AddSubgroup.mk_le_mk, setOf_subset_setOf, le_inf_iff, and_imp, imp_self, implies_true,\n        forall_const, and_true]\n      tauto\n    mul := by\n      rintro γ\n      cases' exists_square_le γ with γ₀ h\n      use γ₀\n      rintro - ⟨r, r_in, s, s_in, rfl⟩\n      simp only [ltAddSubgroup, AddSubgroup.coe_set_mk, mem_setOf_eq] at r_in s_in\n      calc\n        (v (r * s) : Γ₀) = v r * v s := Valuation.map_mul _ _ _\n        _ < γ₀ * γ₀ := by gcongr <;> exact zero_le'\n        _ ≤ γ := mod_cast h\n    leftMul := by\n      rintro x γ\n      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)\n      · use (1 : Γ₀ˣ)\n        rintro y _\n        change v (x * y) < _\n        rw [Valuation.map_mul, Hx, zero_mul]\n        exact Units.zero_lt γ\n      · use γx⁻¹ * γ\n        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))\n        change (v (x * y) : Γ₀) < γ\n        rw [Valuation.map_mul, Hx, mul_comm]\n        rw [Units.val_mul, mul_comm] at vy_lt\n        simpa using mul_inv_lt_of_lt_mul₀ vy_lt\n    rightMul := by\n      rintro x γ\n      rcases GroupWithZero.eq_zero_or_unit (v x) with (Hx | ⟨γx, Hx⟩)\n      · use 1\n        rintro y _\n        change v (y * x) < _\n        rw [Valuation.map_mul, Hx, mul_zero]\n        exact Units.zero_lt γ\n      · use γx⁻¹ * γ\n        rintro y (vy_lt : v y < ↑(γx⁻¹ * γ))\n        change (v (y * x) : Γ₀) < γ\n        rw [Valuation.map_mul, Hx]\n        rw [Units.val_mul, mul_comm] at vy_lt\n        simpa using mul_inv_lt_of_lt_mul₀ vy_lt }\n\n"}
{"name":"Valued.is_topological_valuation","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : outParam (Type v)\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nself : Valued R Γ₀\ns : Set R\n⊢ Iff (Membership.mem (nhds 0) s) (Exists fun γ => HasSubset.Subset (setOf fun x => LT.lt (Valued.v x) ↑γ) s)","decl":"/-- A valued ring is a ring that comes equipped with a distinguished valuation. The class `Valued`\nis designed for the situation that there is a canonical valuation on the ring.\n\nTODO: show that there always exists an equivalent valuation taking values in a type belonging to\nthe same universe as the ring.\n\nSee Note [forgetful inheritance] for why we extend `UniformSpace`, `UniformAddGroup`. -/\nclass Valued (R : Type u) [Ring R] (Γ₀ : outParam (Type v))\n  [LinearOrderedCommGroupWithZero Γ₀] extends UniformSpace R, UniformAddGroup R where\n  v : Valuation R Γ₀\n  is_topological_valuation : ∀ s, s ∈ 𝓝 (0 : R) ↔ ∃ γ : Γ₀ˣ, { x : R | v x < γ } ⊆ s\n\n"}
{"name":"Valued.toUniformAddGroup","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : outParam (Type v)\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\nself : Valued R Γ₀\n⊢ UniformAddGroup R","decl":"/-- A valued ring is a ring that comes equipped with a distinguished valuation. The class `Valued`\nis designed for the situation that there is a canonical valuation on the ring.\n\nTODO: show that there always exists an equivalent valuation taking values in a type belonging to\nthe same universe as the ring.\n\nSee Note [forgetful inheritance] for why we extend `UniformSpace`, `UniformAddGroup`. -/\nclass Valued (R : Type u) [Ring R] (Γ₀ : outParam (Type v))\n  [LinearOrderedCommGroupWithZero Γ₀] extends UniformSpace R, UniformAddGroup R where\n  v : Valuation R Γ₀\n  is_topological_valuation : ∀ s, s ∈ 𝓝 (0 : R) ↔ ∃ γ : Γ₀ˣ, { x : R | v x < γ } ⊆ s\n\n"}
{"name":"Valued.hasBasis_nhds_zero","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\n⊢ (nhds 0).HasBasis (fun x => True) fun γ => setOf fun x => LT.lt (Valued.v x) ↑γ","decl":"theorem hasBasis_nhds_zero :\n    (𝓝 (0 : R)).HasBasis (fun _ => True) fun γ : Γ₀ˣ => { x | v x < (γ : Γ₀) } := by\n  simp [Filter.hasBasis_iff, is_topological_valuation]\n\n-- Porting note: Replaced `𝓤 R` with `uniformity R`\n"}
{"name":"Valued.hasBasis_uniformity","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\n⊢ (uniformity R).HasBasis (fun x => True) fun γ => setOf fun p => LT.lt (Valued.v (HSub.hSub p.2 p.1)) ↑γ","decl":"theorem hasBasis_uniformity : (uniformity R).HasBasis (fun _ => True)\n    fun γ : Γ₀ˣ => { p : R × R | v (p.2 - p.1) < (γ : Γ₀) } := by\n  rw [uniformity_eq_comap_nhds_zero]\n  exact (hasBasis_nhds_zero R Γ₀).comap _\n\n"}
{"name":"Valued.toUniformSpace_eq","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\n⊢ Eq Valued.toUniformSpace (TopologicalAddGroup.toUniformSpace R)","decl":"theorem toUniformSpace_eq :\n    toUniformSpace = @TopologicalAddGroup.toUniformSpace R _ v.subgroups_basis.topology _ :=\n  UniformSpace.ext\n    ((hasBasis_uniformity R Γ₀).eq_of_same_basis <| v.subgroups_basis.hasBasis_nhds_zero.comap _)\n\n"}
{"name":"Valued.mem_nhds","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\ns : Set R\nx : R\n⊢ Iff (Membership.mem (nhds x) s) (Exists fun γ => HasSubset.Subset (setOf fun y => LT.lt (Valued.v (HSub.hSub y x)) ↑γ) s)","decl":"theorem mem_nhds {s : Set R} {x : R} : s ∈ 𝓝 x ↔ ∃ γ : Γ₀ˣ, { y | (v (y - x) : Γ₀) < γ } ⊆ s := by\n  simp only [← nhds_translation_add_neg x, ← sub_eq_add_neg, preimage_setOf_eq, true_and,\n    ((hasBasis_nhds_zero R Γ₀).comap fun y => y - x).mem_iff]\n\n"}
{"name":"Valued.mem_nhds_zero","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\ns : Set R\n⊢ Iff (Membership.mem (nhds 0) s) (Exists fun γ => HasSubset.Subset (setOf fun x => LT.lt (Valued.v x) ↑γ) s)","decl":"theorem mem_nhds_zero {s : Set R} : s ∈ 𝓝 (0 : R) ↔ ∃ γ : Γ₀ˣ, { x | v x < (γ : Γ₀) } ⊆ s := by\n  simp only [mem_nhds, sub_zero]\n\n"}
{"name":"Valued.loc_const","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\nx : R\nh : Ne (Valued.v x) 0\n⊢ Membership.mem (nhds x) (setOf fun y => Eq (Valued.v y) (Valued.v x))","decl":"theorem loc_const {x : R} (h : (v x : Γ₀) ≠ 0) : { y : R | v y = v x } ∈ 𝓝 x := by\n  rw [mem_nhds]\n  use Units.mk0 _ h\n  rw [Units.val_mk0]\n  intro y y_in\n  exact Valuation.map_eq_of_sub_lt _ y_in\n\n"}
{"name":"Valued.instTopologicalRing","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\n⊢ TopologicalRing R","decl":"instance (priority := 100) : TopologicalRing R :=\n  (toUniformSpace_eq R Γ₀).symm ▸ v.subgroups_basis.toRingFilterBasis.isTopologicalRing\n\n"}
{"name":"Valued.cauchy_iff","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\nF : Filter R\n⊢ Iff (Cauchy F) (And F.NeBot (∀ (γ : Units Γ₀), Exists fun M => And (Membership.mem F M) (∀ (x : R), Membership.mem M x → ∀ (y : R), Membership.mem M y → LT.lt (Valued.v (HSub.hSub y x)) ↑γ)))","decl":"theorem cauchy_iff {F : Filter R} : Cauchy F ↔\n    F.NeBot ∧ ∀ γ : Γ₀ˣ, ∃ M ∈ F, ∀ᵉ (x ∈ M) (y ∈ M), (v (y - x) : Γ₀) < γ := by\n  rw [toUniformSpace_eq, AddGroupFilterBasis.cauchy_iff]\n  apply and_congr Iff.rfl\n  simp_rw [Valued.v.subgroups_basis.mem_addGroupFilterBasis_iff]\n  constructor\n  · intro h γ\n    exact h _ (Valued.v.subgroups_basis.mem_addGroupFilterBasis _)\n  · rintro h - ⟨γ, rfl⟩\n    exact h γ\n\n"}
{"name":"Valued.integer_isOpen","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"R : Type u\ninst✝¹ : Ring R\nΓ₀ : Type v\ninst✝ : LinearOrderedCommGroupWithZero Γ₀\n_i : Valued R Γ₀\n⊢ IsOpen ↑Valued.v.integer","decl":"/-- The unit ball of a valued ring is open. -/\ntheorem integer_isOpen : IsOpen (_i.v.integer : Set R) := by\n  rw [isOpen_iff_mem_nhds]\n  intro x hx\n  rw [mem_nhds]\n  exact ⟨1,\n    fun y hy => (sub_add_cancel y x).symm ▸ le_trans (map_add _ _ _) (max_le (le_of_lt hy) hx)⟩\n\n"}
{"name":"Valued.valuationSubring_isOpen","module":"Mathlib.Topology.Algebra.Valued.ValuationTopology","initialProofState":"Γ₀ : Type v\ninst✝¹ : LinearOrderedCommGroupWithZero Γ₀\nK : Type u\ninst✝ : Field K\nhv : Valued K Γ₀\n⊢ IsOpen ↑Valued.v.valuationSubring","decl":"/-- The valuation subring of a valued field is open. -/\ntheorem valuationSubring_isOpen (K : Type u) [Field K] [hv : Valued K Γ₀] :\n    IsOpen (hv.v.valuationSubring : Set K) :=\n  integer_isOpen K\n\n"}
