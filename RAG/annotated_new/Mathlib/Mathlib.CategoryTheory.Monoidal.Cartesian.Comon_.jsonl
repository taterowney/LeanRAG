{"name":"counit_eq_from","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\n⊢ Eq A.counit (CategoryTheory.Limits.terminal.from A.X)","decl":"@[simp] theorem counit_eq_from (A : Comon_ C) : A.counit = terminal.from A.X := by ext\n\n"}
{"name":"comul_eq_diag","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\n⊢ Eq A.comul (CategoryTheory.Limits.diag A.X)","decl":"@[simp] theorem comul_eq_diag (A : Comon_ C) : A.comul = diag A.X := by\n  ext\n  · simpa using A.comul_counit =≫ prod.fst\n  · simpa using A.counit_comul =≫ prod.snd\n\n"}
{"name":"iso_cartesianComon__hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\n⊢ Eq (iso_cartesianComon_ A).hom.hom (CategoryTheory.CategoryStruct.id A.X)","decl":"/--\nEvery comonoid object in a cartesian monoidal category is equivalent to\nthe canonical comonoid structure on the underlying object.\n-/\n@[simps] def iso_cartesianComon_ (A : Comon_ C) : A ≅ (cartesianComon_ C).obj A.X :=\n  { hom := { hom := 𝟙 _ }\n    inv := { hom := 𝟙 _ } }\n\n"}
{"name":"iso_cartesianComon__inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\n⊢ Eq (iso_cartesianComon_ A).inv.hom (CategoryTheory.CategoryStruct.id ((cartesianComon_ C).obj A.X).X)","decl":"/--\nEvery comonoid object in a cartesian monoidal category is equivalent to\nthe canonical comonoid structure on the underlying object.\n-/\n@[simps] def iso_cartesianComon_ (A : Comon_ C) : A ≅ (cartesianComon_ C).obj A.X :=\n  { hom := { hom := 𝟙 _ }\n    inv := { hom := 𝟙 _ } }\n\n"}
{"name":"comonEquiv_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq comonEquiv.unitIso (CategoryTheory.NatIso.ofComponents (fun A => iso_cartesianComon_ A) ⋯)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C ≌ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
{"name":"comonEquiv_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq comonEquiv.counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((cartesianComon_ C).comp (Comon_.forget C)).obj x)) ⋯)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C ≌ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
{"name":"comonEquiv_functor","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq comonEquiv.functor (Comon_.forget C)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C ≌ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
{"name":"comonEquiv_inverse","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\ninst✝¹ : CategoryTheory.Limits.HasTerminal C\ninst✝ : CategoryTheory.Limits.HasBinaryProducts C\n⊢ Eq comonEquiv.inverse (cartesianComon_ C)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C ≌ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
