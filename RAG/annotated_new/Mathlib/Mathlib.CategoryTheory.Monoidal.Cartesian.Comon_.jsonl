{"name":"counit_eq_from","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\nâŠ¢ Eq A.counit (CategoryTheory.Limits.terminal.from A.X)","decl":"@[simp] theorem counit_eq_from (A : Comon_ C) : A.counit = terminal.from A.X := by ext\n\n"}
{"name":"comul_eq_diag","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\nâŠ¢ Eq A.comul (CategoryTheory.Limits.diag A.X)","decl":"@[simp] theorem comul_eq_diag (A : Comon_ C) : A.comul = diag A.X := by\n  ext\n  Â· simpa using A.comul_counit =â‰« prod.fst\n  Â· simpa using A.counit_comul =â‰« prod.snd\n\n"}
{"name":"iso_cartesianComon__hom_hom","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\nâŠ¢ Eq (iso_cartesianComon_ A).hom.hom (CategoryTheory.CategoryStruct.id A.X)","decl":"/--\nEvery comonoid object in a cartesian monoidal category is equivalent to\nthe canonical comonoid structure on the underlying object.\n-/\n@[simps] def iso_cartesianComon_ (A : Comon_ C) : A â‰… (cartesianComon_ C).obj A.X :=\n  { hom := { hom := ðŸ™ _ }\n    inv := { hom := ðŸ™ _ } }\n\n"}
{"name":"iso_cartesianComon__inv_hom","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nA : Comon_ C\nâŠ¢ Eq (iso_cartesianComon_ A).inv.hom (CategoryTheory.CategoryStruct.id ((cartesianComon_ C).obj A.X).X)","decl":"/--\nEvery comonoid object in a cartesian monoidal category is equivalent to\nthe canonical comonoid structure on the underlying object.\n-/\n@[simps] def iso_cartesianComon_ (A : Comon_ C) : A â‰… (cartesianComon_ C).obj A.X :=\n  { hom := { hom := ðŸ™ _ }\n    inv := { hom := ðŸ™ _ } }\n\n"}
{"name":"comonEquiv_unitIso","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq comonEquiv.unitIso (CategoryTheory.NatIso.ofComponents (fun A => iso_cartesianComon_ A) â‹¯)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C â‰Œ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
{"name":"comonEquiv_counitIso","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq comonEquiv.counitIso (CategoryTheory.NatIso.ofComponents (fun x => CategoryTheory.Iso.refl (((cartesianComon_ C).comp (Comon_.forget C)).obj x)) â‹¯)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C â‰Œ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
{"name":"comonEquiv_functor","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq comonEquiv.functor (Comon_.forget C)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C â‰Œ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
{"name":"comonEquiv_inverse","module":"Mathlib.CategoryTheory.Monoidal.Cartesian.Comon_","initialProofState":"C : Type u\ninstâœÂ² : CategoryTheory.Category.{v, u} C\ninstâœÂ¹ : CategoryTheory.Limits.HasTerminal C\ninstâœ : CategoryTheory.Limits.HasBinaryProducts C\nâŠ¢ Eq comonEquiv.inverse (cartesianComon_ C)","decl":"/--\nThe category of comonoid objects in a cartesian monoidal category is equivalent\nto the category itself, via the forgetful functor.\n-/\n@[simps] def comonEquiv : Comon_ C â‰Œ C where\n  functor := Comon_.forget C\n  inverse := cartesianComon_ C\n  unitIso := NatIso.ofComponents (fun A => iso_cartesianComon_ A)\n  counitIso := NatIso.ofComponents (fun _ => Iso.refl _)\n"}
