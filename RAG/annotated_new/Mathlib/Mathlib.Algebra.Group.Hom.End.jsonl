{"name":"AddMonoid.End.natCast_apply","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"M : Type uM\ninst✝ : AddCommMonoid M\nn : Nat\nm : M\n⊢ Eq (↑n m) (HSMul.hSMul n m)","decl":"/-- See also `AddMonoid.End.natCast_def`. -/\n@[simp]\nlemma natCast_apply [AddCommMonoid M] (n : ℕ) (m : M) : (↑n : AddMonoid.End M) m = n • m := rfl\n\n"}
{"name":"AddMonoid.End.ofNat_apply","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"M : Type uM\ninst✝¹ : AddCommMonoid M\nn : Nat\ninst✝ : n.AtLeastTwo\nm : M\n⊢ Eq ((OfNat.ofNat n) m) (HSMul.hSMul n m)","decl":"@[simp] lemma ofNat_apply [AddCommMonoid M] (n : ℕ) [n.AtLeastTwo] (m : M) :\n    (ofNat(n) : AddMonoid.End M) m = n • m := rfl\n\n"}
{"name":"AddMonoidHom.mul_apply","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\nx y : R\n⊢ Eq ((AddMonoidHom.mul x) y) (HMul.hMul x y)","decl":"theorem AddMonoidHom.mul_apply (x y : R) : AddMonoidHom.mul x y = x * y :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_mul","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (⇑AddMonoidHom.mul) AddMonoidHom.mulLeft","decl":"@[simp]\ntheorem AddMonoidHom.coe_mul : ⇑(AddMonoidHom.mul : R →+ R →+ R) = AddMonoidHom.mulLeft :=\n  rfl\n\n"}
{"name":"AddMonoidHom.coe_flip_mul","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\n⊢ Eq (⇑AddMonoidHom.mul.flip) AddMonoidHom.mulRight","decl":"@[simp]\ntheorem AddMonoidHom.coe_flip_mul :\n    ⇑(AddMonoidHom.mul : R →+ R →+ R).flip = AddMonoidHom.mulRight :=\n  rfl\n\n"}
{"name":"AddMonoidHom.map_mul_iff","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\nS : Type u_2\ninst✝¹ : NonUnitalNonAssocSemiring R\ninst✝ : NonUnitalNonAssocSemiring S\nf : AddMonoidHom R S\n⊢ Iff (∀ (x y : R), Eq (f (HMul.hMul x y)) (HMul.hMul (f x) (f y))) (Eq (AddMonoidHom.mul.compr₂ f) ((AddMonoidHom.mul.comp f).compl₂ f))","decl":"/-- An `AddMonoidHom` preserves multiplication if pre- and post- composition with\n`AddMonoidHom.mul` are equivalent. By converting the statement into an equality of\n`AddMonoidHom`s, this lemma allows various specialized `ext` lemmas about `→+` to then be applied.\n-/\ntheorem AddMonoidHom.map_mul_iff (f : R →+ S) :\n    (∀ x y, f (x * y) = f x * f y) ↔\n      (AddMonoidHom.mul : R →+ R →+ R).compr₂ f = (AddMonoidHom.mul.comp f).compl₂ f :=\n  Iff.symm AddMonoidHom.ext_iff₂\n\n"}
{"name":"AddMonoidHom.mulLeft_eq_mulRight_iff_forall_commute","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\na : R\n⊢ Iff (Eq (AddMonoidHom.mulLeft a) (AddMonoidHom.mulRight a)) (∀ (b : R), Commute a b)","decl":"lemma AddMonoidHom.mulLeft_eq_mulRight_iff_forall_commute {a : R} :\n    mulLeft a = mulRight a ↔ ∀ b, Commute a b :=\n  DFunLike.ext_iff\n\n"}
{"name":"AddMonoidHom.mulRight_eq_mulLeft_iff_forall_commute","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\nb : R\n⊢ Iff (Eq (AddMonoidHom.mulRight b) (AddMonoidHom.mulLeft b)) (∀ (a : R), Commute a b)","decl":"lemma AddMonoidHom.mulRight_eq_mulLeft_iff_forall_commute {b : R} :\n    mulRight b = mulLeft b ↔ ∀ a, Commute a b :=\n  DFunLike.ext_iff\n\n"}
{"name":"AddMonoid.End.mulLeft_apply_apply","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\nr x✝ : R\n⊢ Eq ((AddMonoid.End.mulLeft r) x✝) (HMul.hMul r x✝)","decl":"/-- The left multiplication map: `(a, b) ↦ a * b`. See also `AddMonoidHom.mulLeft`. -/\n@[simps!]\ndef AddMonoid.End.mulLeft : R →+ AddMonoid.End R :=\n  AddMonoidHom.mul\n\n"}
{"name":"AddMonoid.End.mulRight_apply_apply","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocSemiring R\ny x : R\n⊢ Eq ((AddMonoid.End.mulRight y) x) (HMul.hMul x y)","decl":"/-- The right multiplication map: `(a, b) ↦ b * a`. See also `AddMonoidHom.mulRight`. -/\n@[simps!]\ndef AddMonoid.End.mulRight : R →+ AddMonoid.End R :=\n  (AddMonoidHom.mul : R →+ AddMonoid.End R).flip\n\n"}
{"name":"AddMonoid.End.mulRight_eq_mulLeft","module":"Mathlib.Algebra.Group.Hom.End","initialProofState":"R : Type u_1\ninst✝ : NonUnitalNonAssocCommSemiring R\n⊢ Eq AddMonoid.End.mulRight AddMonoid.End.mulLeft","decl":"lemma mulRight_eq_mulLeft : mulRight = (mulLeft : R →+ AddMonoid.End R) :=\n  AddMonoidHom.ext fun _ =>\n    Eq.symm <| AddMonoidHom.mulLeft_eq_mulRight_iff_forall_commute.2 (.all _)\n\n"}
