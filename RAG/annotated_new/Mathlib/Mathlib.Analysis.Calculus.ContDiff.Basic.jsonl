{"name":"iteratedFDerivWithin_succ_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nn : Nat\nc : F\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ (HAdd.hAdd n 1) (fun x => c) s) 0","decl":"theorem iteratedFDerivWithin_succ_const (n : â„•) (c : F) :\n    iteratedFDerivWithin ğ•œ (n + 1) (fun _ : E â†¦ c) s = 0 := by\n  induction n  with\n  | zero =>\n    ext1\n    simp [iteratedFDerivWithin_succ_eq_comp_left, iteratedFDerivWithin_zero_eq_comp, comp_def]\n  | succ n IH =>\n    rw [iteratedFDerivWithin_succ_eq_comp_left, IH]\n    simp only [Pi.zero_def, comp_def, fderivWithin_const, map_zero]\n\n"}
{"name":"iteratedFDerivWithin_zero_fun","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\ni : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (fun x => 0) s) 0","decl":"@[simp]\ntheorem iteratedFDerivWithin_zero_fun {i : â„•} :\n    iteratedFDerivWithin ğ•œ i (fun _ : E â†¦ (0 : F)) s = 0 := by\n  cases i with\n  | zero => ext; simp\n  | succ i => apply iteratedFDerivWithin_succ_const\n\n"}
{"name":"iteratedFDeriv_zero_fun","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nâŠ¢ Eq (iteratedFDeriv ğ•œ n fun x => 0) 0","decl":"@[simp]\ntheorem iteratedFDeriv_zero_fun {n : â„•} : (iteratedFDeriv ğ•œ n fun _ : E â†¦ (0 : F)) = 0 :=\n  funext fun x â†¦ by simp only [â† iteratedFDerivWithin_univ, iteratedFDerivWithin_zero_fun]\n\n"}
{"name":"contDiff_zero_fun","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n fun x => 0","decl":"theorem contDiff_zero_fun : ContDiff ğ•œ n fun _ : E => (0 : F) :=\n  analyticOnNhd_const.contDiff\n\n"}
{"name":"contDiff_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nc : F\nâŠ¢ ContDiff ğ•œ n fun x => c","decl":"/-- Constants are `C^âˆ`.\n-/\ntheorem contDiff_const {c : F} : ContDiff ğ•œ n fun _ : E => c :=\n  analyticOnNhd_const.contDiff\n\n"}
{"name":"contDiffOn_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nc : F\ns : Set E\nâŠ¢ ContDiffOn ğ•œ n (fun x => c) s","decl":"theorem contDiffOn_const {c : F} {s : Set E} : ContDiffOn ğ•œ n (fun _ : E => c) s :=\n  contDiff_const.contDiffOn\n\n"}
{"name":"contDiffAt_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\nc : F\nâŠ¢ ContDiffAt ğ•œ n (fun x => c) x","decl":"theorem contDiffAt_const {c : F} : ContDiffAt ğ•œ n (fun _ : E => c) x :=\n  contDiff_const.contDiffAt\n\n"}
{"name":"contDiffWithinAt_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nx : E\nn : WithTop ENat\nc : F\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => c) s x","decl":"theorem contDiffWithinAt_const {c : F} : ContDiffWithinAt ğ•œ n (fun _ : E => c) s x :=\n  contDiffAt_const.contDiffWithinAt\n\n"}
{"name":"contDiff_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\ninstâœ : Subsingleton F\nâŠ¢ ContDiff ğ•œ n f","decl":"@[nontriviality]\ntheorem contDiff_of_subsingleton [Subsingleton F] : ContDiff ğ•œ n f := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiff_const\n\n"}
{"name":"contDiffAt_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\ninstâœ : Subsingleton F\nâŠ¢ ContDiffAt ğ•œ n f x","decl":"@[nontriviality]\ntheorem contDiffAt_of_subsingleton [Subsingleton F] : ContDiffAt ğ•œ n f x := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiffAt_const\n\n"}
{"name":"contDiffWithinAt_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ninstâœ : Subsingleton F\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"@[nontriviality]\ntheorem contDiffWithinAt_of_subsingleton [Subsingleton F] : ContDiffWithinAt ğ•œ n f s x := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiffWithinAt_const\n\n"}
{"name":"contDiffOn_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\ninstâœ : Subsingleton F\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"@[nontriviality]\ntheorem contDiffOn_of_subsingleton [Subsingleton F] : ContDiffOn ğ•œ n f s := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiffOn_const\n\n"}
{"name":"iteratedFDerivWithin_const_of_ne","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nhn : Ne n 0\nc : F\ns : Set E\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ n (fun x => c) s) 0","decl":"theorem iteratedFDerivWithin_const_of_ne {n : â„•} (hn : n â‰  0) (c : F) (s : Set E) :\n    iteratedFDerivWithin ğ•œ n (fun _ : E â†¦ c) s = 0 := by\n  cases n with\n  | zero => contradiction\n  | succ n => exact iteratedFDerivWithin_succ_const n c\n\n"}
{"name":"iteratedFDeriv_const_of_ne","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nhn : Ne n 0\nc : F\nâŠ¢ Eq (iteratedFDeriv ğ•œ n fun x => c) 0","decl":"theorem iteratedFDeriv_const_of_ne {n : â„•} (hn : n â‰  0) (c : F) :\n    (iteratedFDeriv ğ•œ n fun _ : E â†¦ c) = 0 := by\n  simp only [â† iteratedFDerivWithin_univ, iteratedFDerivWithin_const_of_ne hn]\n\n"}
{"name":"iteratedFDeriv_succ_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nc : F\nâŠ¢ Eq (iteratedFDeriv ğ•œ (HAdd.hAdd n 1) fun x => c) 0","decl":"theorem iteratedFDeriv_succ_const (n : â„•) (c : F) :\n    (iteratedFDeriv ğ•œ (n + 1) fun _ : E â†¦ c) = 0 :=\n  iteratedFDeriv_const_of_ne (by simp) _\n\n"}
{"name":"contDiffWithinAt_singleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nâŠ¢ ContDiffWithinAt ğ•œ n f (Singleton.singleton x) x","decl":"theorem contDiffWithinAt_singleton : ContDiffWithinAt ğ•œ n f {x} x :=\n  (contDiffWithinAt_const (c := f x)).congr (by simp) rfl\n\n"}
{"name":"IsBoundedLinearMap.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nhf : IsBoundedLinearMap ğ•œ f\nâŠ¢ ContDiff ğ•œ n f","decl":"/-- Unbundled bounded linear functions are `C^n`.\n-/\ntheorem IsBoundedLinearMap.contDiff (hf : IsBoundedLinearMap ğ•œ f) : ContDiff ğ•œ n f :=\n  (ContinuousLinearMap.analyticOnNhd hf.toContinuousLinearMap univ).contDiff\n\n"}
{"name":"ContinuousLinearMap.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : ContinuousLinearMap (RingHom.id ğ•œ) E F\nâŠ¢ ContDiff ğ•œ n â‡‘f","decl":"theorem ContinuousLinearMap.contDiff (f : E â†’L[ğ•œ] F) : ContDiff ğ•œ n f :=\n  f.isBoundedLinearMap.contDiff\n\n"}
{"name":"ContinuousLinearEquiv.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ ContDiff ğ•œ n â‡‘f","decl":"theorem ContinuousLinearEquiv.contDiff (f : E â‰ƒL[ğ•œ] F) : ContDiff ğ•œ n f :=\n  (f : E â†’L[ğ•œ] F).contDiff\n\n"}
{"name":"LinearIsometry.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : LinearIsometry (RingHom.id ğ•œ) E F\nâŠ¢ ContDiff ğ•œ n â‡‘f","decl":"theorem LinearIsometry.contDiff (f : E â†’â‚—áµ¢[ğ•œ] F) : ContDiff ğ•œ n f :=\n  f.toContinuousLinearMap.contDiff\n\n"}
{"name":"LinearIsometryEquiv.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : LinearIsometryEquiv (RingHom.id ğ•œ) E F\nâŠ¢ ContDiff ğ•œ n â‡‘f","decl":"theorem LinearIsometryEquiv.contDiff (f : E â‰ƒâ‚—áµ¢[ğ•œ] F) : ContDiff ğ•œ n f :=\n  (f : E â†’L[ğ•œ] F).contDiff\n\n"}
{"name":"contDiff_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n id","decl":"/-- The identity is `C^n`.\n-/\ntheorem contDiff_id : ContDiff ğ•œ n (id : E â†’ E) :=\n  IsBoundedLinearMap.id.contDiff\n\n"}
{"name":"contDiffWithinAt_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nn : WithTop ENat\ns : Set E\nx : E\nâŠ¢ ContDiffWithinAt ğ•œ n id s x","decl":"theorem contDiffWithinAt_id {s x} : ContDiffWithinAt ğ•œ n (id : E â†’ E) s x :=\n  contDiff_id.contDiffWithinAt\n\n"}
{"name":"contDiffAt_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nn : WithTop ENat\nx : E\nâŠ¢ ContDiffAt ğ•œ n id x","decl":"theorem contDiffAt_id {x} : ContDiffAt ğ•œ n (id : E â†’ E) x :=\n  contDiff_id.contDiffAt\n\n"}
{"name":"contDiffOn_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nn : WithTop ENat\ns : Set E\nâŠ¢ ContDiffOn ğ•œ n id s","decl":"theorem contDiffOn_id {s} : ContDiffOn ğ•œ n (id : E â†’ E) s :=\n  contDiff_id.contDiffOn\n\n"}
{"name":"IsBoundedBilinearMap.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nb : Prod E F â†’ G\nn : WithTop ENat\nhb : IsBoundedBilinearMap ğ•œ b\nâŠ¢ ContDiff ğ•œ n b","decl":"/-- Bilinear functions are `C^n`.\n-/\ntheorem IsBoundedBilinearMap.contDiff (hb : IsBoundedBilinearMap ğ•œ b) : ContDiff ğ•œ n b :=\n  (hb.toContinuousLinearMap.analyticOnNhd_bilinear _).contDiff\n\n"}
{"name":"HasFTaylorSeriesUpToOn.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : HasFTaylorSeriesUpToOn n f p s\nâŠ¢ HasFTaylorSeriesUpToOn n (Function.comp (â‡‘g) f) (fun x k => g.compContinuousMultilinearMap (p x k)) s","decl":"/-- If `f` admits a Taylor series `p` in a set `s`, and `g` is linear, then `g âˆ˜ f` admits a Taylor\nseries whose `k`-th term is given by `g âˆ˜ (p k)`. -/\ntheorem HasFTaylorSeriesUpToOn.continuousLinearMap_comp {n : WithTop â„•âˆ} (g : F â†’L[ğ•œ] G)\n    (hf : HasFTaylorSeriesUpToOn n f p s) :\n    HasFTaylorSeriesUpToOn n (g âˆ˜ f) (fun x k => g.compContinuousMultilinearMap (p x k)) s where\n  zero_eq x hx := congr_arg g (hf.zero_eq x hx)\n  fderivWithin m hm x hx := (ContinuousLinearMap.compContinuousMultilinearMapL ğ•œ\n    (fun _ : Fin m => E) F G g).hasFDerivAt.comp_hasFDerivWithinAt x (hf.fderivWithin m hm x hx)\n  cont m hm := (ContinuousLinearMap.compContinuousMultilinearMapL ğ•œ\n    (fun _ : Fin m => E) F G g).continuous.comp_continuousOn (hf.cont m hm)\n\n"}
{"name":"ContDiffWithinAt.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp (â‡‘g) f) s x","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions in a domain\nat a point. -/\ntheorem ContDiffWithinAt.continuousLinearMap_comp (g : F â†’L[ğ•œ] G)\n    (hf : ContDiffWithinAt ğ•œ n f s x) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x := by\n  match n with\n  | Ï‰ =>\n    obtain âŸ¨u, hu, p, hp, h'pâŸ© := hf\n    refine âŸ¨u, hu, _, hp.continuousLinearMap_comp g, fun i â†¦ ?_âŸ©\n    change AnalyticOn ğ•œ\n      (fun x â†¦ (ContinuousLinearMap.compContinuousMultilinearMapL ğ•œ\n      (fun _ : Fin i â†¦ E) F G g) (p x i)) u\n    apply AnalyticOnNhd.comp_analyticOn _ (h'p i) (Set.mapsTo_univ _ _)\n    exact ContinuousLinearMap.analyticOnNhd _ _\n  | (n : â„•âˆ) =>\n    intro m hm\n    rcases hf m hm with âŸ¨u, hu, p, hpâŸ©\n    exact âŸ¨u, hu, _, hp.continuousLinearMap_comp gâŸ©\n\n"}
{"name":"ContDiffAt.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (Function.comp (â‡‘g) f) x","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions in a domain\nat a point. -/\ntheorem ContDiffAt.continuousLinearMap_comp (g : F â†’L[ğ•œ] G) (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (g âˆ˜ f) x :=\n  ContDiffWithinAt.continuousLinearMap_comp g hf\n\n"}
{"name":"ContDiffOn.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (Function.comp (â‡‘g) f) s","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions on domains. -/\ntheorem ContDiffOn.continuousLinearMap_comp (g : F â†’L[ğ•œ] G) (hf : ContDiffOn ğ•œ n f s) :\n    ContDiffOn ğ•œ n (g âˆ˜ f) s := fun x hx => (hf x hx).continuousLinearMap_comp g\n\n"}
{"name":"ContDiff.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ F\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => g (f x)","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions. -/\ntheorem ContDiff.continuousLinearMap_comp {f : E â†’ F} (g : F â†’L[ğ•œ] G) (hf : ContDiff ğ•œ n f) :\n    ContDiff ğ•œ n fun x => g (f x) :=\n  contDiffOn_univ.1 <| ContDiffOn.continuousLinearMap_comp _ (contDiffOn_univ.2 hf)\n\n"}
{"name":"ContinuousLinearMap.iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nx : E\nn : WithTop ENat\nf : E â†’ F\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Function.comp (â‡‘g) f) s x) (g.compContinuousMultilinearMap (iteratedFDerivWithin ğ•œ i f s x))","decl":"/-- The iterated derivative within a set of the composition with a linear map on the left is\nobtained by applying the linear map to the iterated derivative. -/\ntheorem ContinuousLinearMap.iteratedFDerivWithin_comp_left {f : E â†’ F} (g : F â†’L[ğ•œ] G)\n    (hf : ContDiffWithinAt ğ•œ n f s x) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s x =\n      g.compContinuousMultilinearMap (iteratedFDerivWithin ğ•œ i f s x) := by\n  rcases hf.contDiffOn' hi (by simp) with âŸ¨U, hU, hxU, hfUâŸ©\n  rw [â† iteratedFDerivWithin_inter_open hU hxU, â† iteratedFDerivWithin_inter_open (f := f) hU hxU]\n  rw [insert_eq_of_mem hx] at hfU\n  exact .symm <| (hfU.ftaylorSeriesWithin (hs.inter hU)).continuousLinearMap_comp g\n    |>.eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl (hs.inter hU) âŸ¨hx, hxUâŸ©\n\n"}
{"name":"ContinuousLinearMap.iteratedFDeriv_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nn : WithTop ENat\nf : E â†’ F\ng : ContinuousLinearMap (RingHom.id ğ•œ) F G\nhf : ContDiffAt ğ•œ n f x\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (Function.comp (â‡‘g) f) x) (g.compContinuousMultilinearMap (iteratedFDeriv ğ•œ i f x))","decl":"/-- The iterated derivative of the composition with a linear map on the left is\nobtained by applying the linear map to the iterated derivative. -/\ntheorem ContinuousLinearMap.iteratedFDeriv_comp_left {f : E â†’ F} (g : F â†’L[ğ•œ] G)\n    (hf : ContDiffAt ğ•œ n f x) {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDeriv ğ•œ i (g âˆ˜ f) x = g.compContinuousMultilinearMap (iteratedFDeriv ğ•œ i f x) := by\n  simp only [â† iteratedFDerivWithin_univ]\n  exact g.iteratedFDerivWithin_comp_left hf.contDiffWithinAt uniqueDiffOn_univ (mem_univ x) hi\n\n"}
{"name":"ContinuousLinearEquiv.iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nx : E\ng : ContinuousLinearEquiv (RingHom.id ğ•œ) F G\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\ni : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Function.comp (â‡‘g) f) s x) ((â†‘g).compContinuousMultilinearMap (iteratedFDerivWithin ğ•œ i f s x))","decl":"/-- The iterated derivative within a set of the composition with a linear equiv on the left is\nobtained by applying the linear equiv to the iterated derivative. This is true without\ndifferentiability assumptions. -/\ntheorem ContinuousLinearEquiv.iteratedFDerivWithin_comp_left (g : F â‰ƒL[ğ•œ] G) (f : E â†’ F)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (i : â„•) :\n    iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s x =\n      (g : F â†’L[ğ•œ] G).compContinuousMultilinearMap (iteratedFDerivWithin ğ•œ i f s x) := by\n  induction' i with i IH generalizing x\n  Â· ext1 m\n    simp only [iteratedFDerivWithin_zero_apply, comp_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, coe_coe]\n  Â· ext1 m\n    rw [iteratedFDerivWithin_succ_apply_left]\n    have Z : fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s) s x =\n        fderivWithin ğ•œ (g.compContinuousMultilinearMapL (fun _ : Fin i => E) âˆ˜\n          iteratedFDerivWithin ğ•œ i f s) s x :=\n      fderivWithin_congr' (@IH) hx\n    simp_rw [Z]\n    rw [(g.compContinuousMultilinearMapL fun _ : Fin i => E).comp_fderivWithin (hs x hx)]\n    simp only [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, comp_apply,\n      ContinuousLinearEquiv.compContinuousMultilinearMapL_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, EmbeddingLike.apply_eq_iff_eq]\n    rw [iteratedFDerivWithin_succ_apply_left]\n\n"}
{"name":"LinearIsometry.norm_iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nx : E\nn : WithTop ENat\nf : E â†’ F\ng : LinearIsometry (RingHom.id ğ•œ) F G\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ i (Function.comp (â‡‘g) f) s x)) (Norm.norm (iteratedFDerivWithin ğ•œ i f s x))","decl":"/-- Composition with a linear isometry on the left preserves the norm of the iterated\nderivative within a set. -/\ntheorem LinearIsometry.norm_iteratedFDerivWithin_comp_left {f : E â†’ F} (g : F â†’â‚—áµ¢[ğ•œ] G)\n    (hf : ContDiffWithinAt ğ•œ n f s x) (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) {i : â„•} (hi : i â‰¤ n) :\n    â€–iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s xâ€– = â€–iteratedFDerivWithin ğ•œ i f s xâ€– := by\n  have :\n    iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s x =\n      g.toContinuousLinearMap.compContinuousMultilinearMap (iteratedFDerivWithin ğ•œ i f s x) :=\n    g.toContinuousLinearMap.iteratedFDerivWithin_comp_left hf hs hx hi\n  rw [this]\n  apply LinearIsometry.norm_compContinuousMultilinearMap\n\n"}
{"name":"LinearIsometry.norm_iteratedFDeriv_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nn : WithTop ENat\nf : E â†’ F\ng : LinearIsometry (RingHom.id ğ•œ) F G\nhf : ContDiffAt ğ•œ n f x\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (Norm.norm (iteratedFDeriv ğ•œ i (Function.comp (â‡‘g) f) x)) (Norm.norm (iteratedFDeriv ğ•œ i f x))","decl":"/-- Composition with a linear isometry on the left preserves the norm of the iterated\nderivative. -/\ntheorem LinearIsometry.norm_iteratedFDeriv_comp_left {f : E â†’ F} (g : F â†’â‚—áµ¢[ğ•œ] G)\n    (hf : ContDiffAt ğ•œ n f x) {i : â„•} (hi : i â‰¤ n) :\n    â€–iteratedFDeriv ğ•œ i (g âˆ˜ f) xâ€– = â€–iteratedFDeriv ğ•œ i f xâ€– := by\n  simp only [â† iteratedFDerivWithin_univ]\n  exact g.norm_iteratedFDerivWithin_comp_left hf.contDiffWithinAt uniqueDiffOn_univ (mem_univ x) hi\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nx : E\ng : LinearIsometryEquiv (RingHom.id ğ•œ) F G\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\ni : Nat\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ i (Function.comp (â‡‘g) f) s x)) (Norm.norm (iteratedFDerivWithin ğ•œ i f s x))","decl":"/-- Composition with a linear isometry equiv on the left preserves the norm of the iterated\nderivative within a set. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left (g : F â‰ƒâ‚—áµ¢[ğ•œ] G) (f : E â†’ F)\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (i : â„•) :\n    â€–iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s xâ€– = â€–iteratedFDerivWithin ğ•œ i f s xâ€– := by\n  have :\n    iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s x =\n      (g : F â†’L[ğ•œ] G).compContinuousMultilinearMap (iteratedFDerivWithin ğ•œ i f s x) :=\n    g.toContinuousLinearEquiv.iteratedFDerivWithin_comp_left f hs hx i\n  rw [this]\n  apply LinearIsometry.norm_compContinuousMultilinearMap g.toLinearIsometry\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDeriv_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : LinearIsometryEquiv (RingHom.id ğ•œ) F G\nf : E â†’ F\nx : E\ni : Nat\nâŠ¢ Eq (Norm.norm (iteratedFDeriv ğ•œ i (Function.comp (â‡‘g) f) x)) (Norm.norm (iteratedFDeriv ğ•œ i f x))","decl":"/-- Composition with a linear isometry equiv on the left preserves the norm of the iterated\nderivative. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDeriv_comp_left (g : F â‰ƒâ‚—áµ¢[ğ•œ] G) (f : E â†’ F) (x : E)\n    (i : â„•) : â€–iteratedFDeriv ğ•œ i (g âˆ˜ f) xâ€– = â€–iteratedFDeriv ğ•œ i f xâ€– := by\n  rw [â† iteratedFDerivWithin_univ, â† iteratedFDerivWithin_univ]\n  apply g.norm_iteratedFDerivWithin_comp_left f uniqueDiffOn_univ (mem_univ x) i\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiffWithinAt_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) F G\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n (Function.comp (â‡‘e) f) s x) (ContDiffWithinAt ğ•œ n f s x)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint in a domain. -/\ntheorem ContinuousLinearEquiv.comp_contDiffWithinAt_iff (e : F â‰ƒL[ğ•œ] G) :\n    ContDiffWithinAt ğ•œ n (e âˆ˜ f) s x â†” ContDiffWithinAt ğ•œ n f s x :=\n  âŸ¨fun H => by\n    simpa only [Function.comp_def, e.symm.coe_coe, e.symm_apply_apply] using\n      H.continuousLinearMap_comp (e.symm : G â†’L[ğ•œ] F),\n    fun H => H.continuousLinearMap_comp (e : F â†’L[ğ•œ] G)âŸ©\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiffAt_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) F G\nâŠ¢ Iff (ContDiffAt ğ•œ n (Function.comp (â‡‘e) f) x) (ContDiffAt ğ•œ n f x)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint. -/\ntheorem ContinuousLinearEquiv.comp_contDiffAt_iff (e : F â‰ƒL[ğ•œ] G) :\n    ContDiffAt ğ•œ n (e âˆ˜ f) x â†” ContDiffAt ğ•œ n f x := by\n  simp only [â† contDiffWithinAt_univ, e.comp_contDiffWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiffOn_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) F G\nâŠ¢ Iff (ContDiffOn ğ•œ n (Function.comp (â‡‘e) f) s) (ContDiffOn ğ•œ n f s)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability on\ndomains. -/\ntheorem ContinuousLinearEquiv.comp_contDiffOn_iff (e : F â‰ƒL[ğ•œ] G) :\n    ContDiffOn ğ•œ n (e âˆ˜ f) s â†” ContDiffOn ğ•œ n f s := by\n  simp [ContDiffOn, e.comp_contDiffWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiff_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) F G\nâŠ¢ Iff (ContDiff ğ•œ n (Function.comp (â‡‘e) f)) (ContDiff ğ•œ n f)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability. -/\ntheorem ContinuousLinearEquiv.comp_contDiff_iff (e : F â‰ƒL[ğ•œ] G) :\n    ContDiff ğ•œ n (e âˆ˜ f) â†” ContDiff ğ•œ n f := by\n  simp only [â† contDiffOn_univ, e.comp_contDiffOn_iff]\n\n"}
{"name":"HasFTaylorSeriesUpToOn.compContinuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nn : WithTop ENat\np : E â†’ FormalMultilinearSeries ğ•œ E F\nhf : HasFTaylorSeriesUpToOn n f p s\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ HasFTaylorSeriesUpToOn n (Function.comp f â‡‘g) (fun x k => (p (g x) k).compContinuousLinearMap fun x => g) (Set.preimage (â‡‘g) s)","decl":"/-- If `f` admits a Taylor series `p` in a set `s`, and `g` is linear, then `f âˆ˜ g` admits a Taylor\nseries in `g â»Â¹' s`, whose `k`-th term is given by `p k (g vâ‚, ..., g vâ‚–)` . -/\ntheorem HasFTaylorSeriesUpToOn.compContinuousLinearMap\n    (hf : HasFTaylorSeriesUpToOn n f p s) (g : G â†’L[ğ•œ] E) :\n    HasFTaylorSeriesUpToOn n (f âˆ˜ g) (fun x k => (p (g x) k).compContinuousLinearMap fun _ => g)\n      (g â»Â¹' s) := by\n  let A : âˆ€ m : â„•, (E[Ã—m]â†’L[ğ•œ] F) â†’ G[Ã—m]â†’L[ğ•œ] F := fun m h => h.compContinuousLinearMap fun _ => g\n  have hA : âˆ€ m, IsBoundedLinearMap ğ•œ (A m) := fun m =>\n    isBoundedLinearMap_continuousMultilinearMap_comp_linear g\n  constructor\n  Â· intro x hx\n    simp only [(hf.zero_eq (g x) hx).symm, Function.comp_apply]\n    change (p (g x) 0 fun _ : Fin 0 => g 0) = p (g x) 0 0\n    rw [ContinuousLinearMap.map_zero]\n    rfl\n  Â· intro m hm x hx\n    convert (hA m).hasFDerivAt.comp_hasFDerivWithinAt x\n        ((hf.fderivWithin m hm (g x) hx).comp x g.hasFDerivWithinAt (Subset.refl _))\n    ext y v\n    change p (g x) (Nat.succ m) (g âˆ˜ cons y v) = p (g x) m.succ (cons (g y) (g âˆ˜ v))\n    rw [comp_cons]\n  Â· intro m hm\n    exact (hA m).continuous.comp_continuousOn <| (hf.cont m hm).comp g.continuous.continuousOn <|\n      Subset.refl _\n\n"}
{"name":"ContDiffWithinAt.comp_continuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nx : G\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nhf : ContDiffWithinAt ğ•œ n f s (g x)\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp f â‡‘g) (Set.preimage (â‡‘g) s) x","decl":"/-- Composition by continuous linear maps on the right preserves `C^n` functions at a point on\na domain. -/\ntheorem ContDiffWithinAt.comp_continuousLinearMap {x : G} (g : G â†’L[ğ•œ] E)\n    (hf : ContDiffWithinAt ğ•œ n f s (g x)) : ContDiffWithinAt ğ•œ n (f âˆ˜ g) (g â»Â¹' s) x := by\n  match n with\n  | Ï‰ =>\n    obtain âŸ¨u, hu, p, hp, h'pâŸ© := hf\n    refine âŸ¨g â»Â¹' u, ?_, _, hp.compContinuousLinearMap g, ?_âŸ©\n    Â· refine g.continuous.continuousWithinAt.tendsto_nhdsWithin ?_ hu\n      exact (mapsTo_singleton.2 <| mem_singleton _).union_union (mapsTo_preimage _ _)\n    Â· intro i\n      change AnalyticOn ğ•œ (fun x â†¦\n        ContinuousMultilinearMap.compContinuousLinearMapL (fun _ â†¦ g) (p (g x) i)) (â‡‘g â»Â¹' u)\n      apply AnalyticOn.comp _ _ (Set.mapsTo_univ _ _)\n      Â· exact ContinuousLinearEquiv.analyticOn _ _\n      Â· exact (h'p i).comp (g.analyticOn _) (mapsTo_preimage _ _)\n  | (n : â„•âˆ) =>\n    intro m hm\n    rcases hf m hm with âŸ¨u, hu, p, hpâŸ©\n    refine âŸ¨g â»Â¹' u, ?_, _, hp.compContinuousLinearMap gâŸ©\n    refine g.continuous.continuousWithinAt.tendsto_nhdsWithin ?_ hu\n    exact (mapsTo_singleton.2 <| mem_singleton _).union_union (mapsTo_preimage _ _)\n\n"}
{"name":"ContDiffOn.comp_continuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nâŠ¢ ContDiffOn ğ•œ n (Function.comp f â‡‘g) (Set.preimage (â‡‘g) s)","decl":"/-- Composition by continuous linear maps on the right preserves `C^n` functions on domains. -/\ntheorem ContDiffOn.comp_continuousLinearMap (hf : ContDiffOn ğ•œ n f s) (g : G â†’L[ğ•œ] E) :\n    ContDiffOn ğ•œ n (f âˆ˜ g) (g â»Â¹' s) := fun x hx => (hf (g x) hx).comp_continuousLinearMap g\n\n"}
{"name":"ContDiff.comp_continuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ F\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n (Function.comp f â‡‘g)","decl":"/-- Composition by continuous linear maps on the right preserves `C^n` functions. -/\ntheorem ContDiff.comp_continuousLinearMap {f : E â†’ F} {g : G â†’L[ğ•œ] E} (hf : ContDiff ğ•œ n f) :\n    ContDiff ğ•œ n (f âˆ˜ g) :=\n  contDiffOn_univ.1 <| ContDiffOn.comp_continuousLinearMap (contDiffOn_univ.2 hf) _\n\n"}
{"name":"ContinuousLinearMap.iteratedFDerivWithin_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nn : WithTop ENat\nf : E â†’ F\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nhf : ContDiffOn ğ•œ n f s\nhs : UniqueDiffOn ğ•œ s\nh's : UniqueDiffOn ğ•œ (Set.preimage (â‡‘g) s)\nx : G\nhx : Membership.mem s (g x)\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Function.comp f â‡‘g) (Set.preimage (â‡‘g) s) x) ((iteratedFDerivWithin ğ•œ i f s (g x)).compContinuousLinearMap fun x => g)","decl":"/-- The iterated derivative within a set of the composition with a linear map on the right is\nobtained by composing the iterated derivative with the linear map. -/\ntheorem ContinuousLinearMap.iteratedFDerivWithin_comp_right {f : E â†’ F} (g : G â†’L[ğ•œ] E)\n    (hf : ContDiffOn ğ•œ n f s) (hs : UniqueDiffOn ğ•œ s) (h's : UniqueDiffOn ğ•œ (g â»Â¹' s)) {x : G}\n    (hx : g x âˆˆ s) {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDerivWithin ğ•œ i (f âˆ˜ g) (g â»Â¹' s) x =\n      (iteratedFDerivWithin ğ•œ i f s (g x)).compContinuousLinearMap fun _ => g :=\n  ((((hf.of_le hi).ftaylorSeriesWithin hs).compContinuousLinearMap\n    g).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl h's hx).symm\n\n"}
{"name":"ContinuousLinearEquiv.iteratedFDerivWithin_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\ng : ContinuousLinearEquiv (RingHom.id ğ•œ) G E\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nx : G\nhx : Membership.mem s (g x)\ni : Nat\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Function.comp f â‡‘g) (Set.preimage (â‡‘g) s) x) ((iteratedFDerivWithin ğ•œ i f s (g x)).compContinuousLinearMap fun x => â†‘g)","decl":"/-- The iterated derivative within a set of the composition with a linear equiv on the right is\nobtained by composing the iterated derivative with the linear equiv. -/\ntheorem ContinuousLinearEquiv.iteratedFDerivWithin_comp_right (g : G â‰ƒL[ğ•œ] E) (f : E â†’ F)\n    (hs : UniqueDiffOn ğ•œ s) {x : G} (hx : g x âˆˆ s) (i : â„•) :\n    iteratedFDerivWithin ğ•œ i (f âˆ˜ g) (g â»Â¹' s) x =\n      (iteratedFDerivWithin ğ•œ i f s (g x)).compContinuousLinearMap fun _ => g := by\n  induction' i with i IH generalizing x\n  Â· ext1\n    simp only [iteratedFDerivWithin_zero_apply, comp_apply,\n     ContinuousMultilinearMap.compContinuousLinearMap_apply]\n  Â· ext1 m\n    simp only [ContinuousMultilinearMap.compContinuousLinearMap_apply,\n      ContinuousLinearEquiv.coe_coe, iteratedFDerivWithin_succ_apply_left]\n    have : fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ i (f âˆ˜ g) (g â»Â¹' s)) (g â»Â¹' s) x =\n        fderivWithin ğ•œ\n          (ContinuousMultilinearMap.compContinuousLinearMapEquivL _ (fun _x : Fin i => g) âˆ˜\n            (iteratedFDerivWithin ğ•œ i f s âˆ˜ g)) (g â»Â¹' s) x :=\n      fderivWithin_congr' (@IH) hx\n    rw [this, ContinuousLinearEquiv.comp_fderivWithin _ (g.uniqueDiffOn_preimage_iff.2 hs x hx)]\n    simp only [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, comp_apply,\n      ContinuousMultilinearMap.compContinuousLinearMapEquivL_apply,\n      ContinuousMultilinearMap.compContinuousLinearMap_apply]\n    rw [ContinuousLinearEquiv.comp_right_fderivWithin _ (g.uniqueDiffOn_preimage_iff.2 hs x hx),\n      ContinuousLinearMap.coe_comp', coe_coe, comp_apply, tail_def, tail_def]\n\n"}
{"name":"ContinuousLinearMap.iteratedFDeriv_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id ğ•œ) G E\nf : E â†’ F\nhf : ContDiff ğ•œ n f\nx : G\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (Function.comp f â‡‘g) x) ((iteratedFDeriv ğ•œ i f (g x)).compContinuousLinearMap fun x => g)","decl":"/-- The iterated derivative of the composition with a linear map on the right is\nobtained by composing the iterated derivative with the linear map. -/\ntheorem ContinuousLinearMap.iteratedFDeriv_comp_right (g : G â†’L[ğ•œ] E) {f : E â†’ F}\n    (hf : ContDiff ğ•œ n f) (x : G) {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDeriv ğ•œ i (f âˆ˜ g) x =\n      (iteratedFDeriv ğ•œ i f (g x)).compContinuousLinearMap fun _ => g := by\n  simp only [â† iteratedFDerivWithin_univ]\n  exact g.iteratedFDerivWithin_comp_right hf.contDiffOn uniqueDiffOn_univ uniqueDiffOn_univ\n      (mem_univ _) hi\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\ng : LinearIsometryEquiv (RingHom.id ğ•œ) G E\nf : E â†’ F\nhs : UniqueDiffOn ğ•œ s\nx : G\nhx : Membership.mem s (g x)\ni : Nat\nâŠ¢ Eq (Norm.norm (iteratedFDerivWithin ğ•œ i (Function.comp f â‡‘g) (Set.preimage (â‡‘g) s) x)) (Norm.norm (iteratedFDerivWithin ğ•œ i f s (g x)))","decl":"/-- Composition with a linear isometry on the right preserves the norm of the iterated derivative\nwithin a set. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right (g : G â‰ƒâ‚—áµ¢[ğ•œ] E) (f : E â†’ F)\n    (hs : UniqueDiffOn ğ•œ s) {x : G} (hx : g x âˆˆ s) (i : â„•) :\n    â€–iteratedFDerivWithin ğ•œ i (f âˆ˜ g) (g â»Â¹' s) xâ€– = â€–iteratedFDerivWithin ğ•œ i f s (g x)â€– := by\n  have : iteratedFDerivWithin ğ•œ i (f âˆ˜ g) (g â»Â¹' s) x =\n      (iteratedFDerivWithin ğ•œ i f s (g x)).compContinuousLinearMap fun _ => g :=\n    g.toContinuousLinearEquiv.iteratedFDerivWithin_comp_right f hs hx i\n  rw [this, ContinuousMultilinearMap.norm_compContinuous_linearIsometryEquiv]\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDeriv_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ng : LinearIsometryEquiv (RingHom.id ğ•œ) G E\nf : E â†’ F\nx : G\ni : Nat\nâŠ¢ Eq (Norm.norm (iteratedFDeriv ğ•œ i (Function.comp f â‡‘g) x)) (Norm.norm (iteratedFDeriv ğ•œ i f (g x)))","decl":"/-- Composition with a linear isometry on the right preserves the norm of the iterated derivative\nwithin a set. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDeriv_comp_right (g : G â‰ƒâ‚—áµ¢[ğ•œ] E) (f : E â†’ F) (x : G)\n    (i : â„•) : â€–iteratedFDeriv ğ•œ i (f âˆ˜ g) xâ€– = â€–iteratedFDeriv ğ•œ i f (g x)â€– := by\n  simp only [â† iteratedFDerivWithin_univ]\n  apply g.norm_iteratedFDerivWithin_comp_right f uniqueDiffOn_univ (mem_univ (g x)) i\n\n"}
{"name":"ContinuousLinearEquiv.contDiffWithinAt_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) G E\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n (Function.comp f â‡‘e) (Set.preimage (â‡‘e) s) (e.symm x)) (ContDiffWithinAt ğ•œ n f s x)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint in a domain. -/\ntheorem ContinuousLinearEquiv.contDiffWithinAt_comp_iff (e : G â‰ƒL[ğ•œ] E) :\n    ContDiffWithinAt ğ•œ n (f âˆ˜ e) (e â»Â¹' s) (e.symm x) â†” ContDiffWithinAt ğ•œ n f s x := by\n  constructor\n  Â· intro H\n    simpa [â† preimage_comp, Function.comp_def] using H.comp_continuousLinearMap (e.symm : E â†’L[ğ•œ] G)\n  Â· intro H\n    rw [â† e.apply_symm_apply x, â† e.coe_coe] at H\n    exact H.comp_continuousLinearMap _\n\n"}
{"name":"ContinuousLinearEquiv.contDiffAt_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) G E\nâŠ¢ Iff (ContDiffAt ğ•œ n (Function.comp f â‡‘e) (e.symm x)) (ContDiffAt ğ•œ n f x)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint. -/\ntheorem ContinuousLinearEquiv.contDiffAt_comp_iff (e : G â‰ƒL[ğ•œ] E) :\n    ContDiffAt ğ•œ n (f âˆ˜ e) (e.symm x) â†” ContDiffAt ğ•œ n f x := by\n  rw [â† contDiffWithinAt_univ, â† contDiffWithinAt_univ, â† preimage_univ]\n  exact e.contDiffWithinAt_comp_iff\n\n"}
{"name":"ContinuousLinearEquiv.contDiffOn_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) G E\nâŠ¢ Iff (ContDiffOn ğ•œ n (Function.comp f â‡‘e) (Set.preimage (â‡‘e) s)) (ContDiffOn ğ•œ n f s)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability on\ndomains. -/\ntheorem ContinuousLinearEquiv.contDiffOn_comp_iff (e : G â‰ƒL[ğ•œ] E) :\n    ContDiffOn ğ•œ n (f âˆ˜ e) (e â»Â¹' s) â†” ContDiffOn ğ•œ n f s :=\n  âŸ¨fun H => by simpa [Function.comp_def] using H.comp_continuousLinearMap (e.symm : E â†’L[ğ•œ] G),\n    fun H => H.comp_continuousLinearMap (e : G â†’L[ğ•œ] E)âŸ©\n\n"}
{"name":"ContinuousLinearEquiv.contDiff_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) G E\nâŠ¢ Iff (ContDiff ğ•œ n (Function.comp f â‡‘e)) (ContDiff ğ•œ n f)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability. -/\ntheorem ContinuousLinearEquiv.contDiff_comp_iff (e : G â‰ƒL[ğ•œ] E) :\n    ContDiff ğ•œ n (f âˆ˜ e) â†” ContDiff ğ•œ n f := by\n  rw [â† contDiffOn_univ, â† contDiffOn_univ, â† preimage_univ]\n  exact e.contDiffOn_comp_iff\n\n"}
{"name":"HasFTaylorSeriesUpToOn.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : WithTop ENat\nhf : HasFTaylorSeriesUpToOn n f p s\ng : E â†’ G\nq : E â†’ FormalMultilinearSeries ğ•œ E G\nhg : HasFTaylorSeriesUpToOn n g q s\nâŠ¢ HasFTaylorSeriesUpToOn n (fun y => { fst := f y, snd := g y }) (fun y k => (p y k).prod (q y k)) s","decl":"/-- If two functions `f` and `g` admit Taylor series `p` and `q` in a set `s`, then the cartesian\nproduct of `f` and `g` admits the cartesian product of `p` and `q` as a Taylor series. -/\ntheorem HasFTaylorSeriesUpToOn.prod {n : WithTop â„•âˆ}\n    (hf : HasFTaylorSeriesUpToOn n f p s) {g : E â†’ G}\n    {q : E â†’ FormalMultilinearSeries ğ•œ E G} (hg : HasFTaylorSeriesUpToOn n g q s) :\n    HasFTaylorSeriesUpToOn n (fun y => (f y, g y)) (fun y k => (p y k).prod (q y k)) s := by\n  set L := fun m => ContinuousMultilinearMap.prodL ğ•œ (fun _ : Fin m => E) F G\n  constructor\n  Â· intro x hx; rw [â† hf.zero_eq x hx, â† hg.zero_eq x hx]; rfl\n  Â· intro m hm x hx\n    convert (L m).hasFDerivAt.comp_hasFDerivWithinAt x\n        ((hf.fderivWithin m hm x hx).prod (hg.fderivWithin m hm x hx))\n  Â· intro m hm\n    exact (L m).continuous.comp_continuousOn ((hf.cont m hm).prod (hg.cont m hm))\n\n"}
{"name":"ContDiffWithinAt.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nn : WithTop ENat\ns : Set E\nf : E â†’ F\ng : E â†’ G\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => { fst := f x, snd := g x }) s x","decl":"/-- The cartesian product of `C^n` functions at a point in a domain is `C^n`. -/\ntheorem ContDiffWithinAt.prod {s : Set E} {f : E â†’ F} {g : E â†’ G} (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hg : ContDiffWithinAt ğ•œ n g s x) : ContDiffWithinAt ğ•œ n (fun x : E => (f x, g x)) s x := by\n  match n with\n  | Ï‰ =>\n    obtain âŸ¨u, hu, p, hp, h'pâŸ© := hf\n    obtain âŸ¨v, hv, q, hq, h'qâŸ© := hg\n    refine âŸ¨u âˆ© v, Filter.inter_mem hu hv, _,\n      (hp.mono inter_subset_left).prod (hq.mono inter_subset_right), fun i â†¦ ?_âŸ©\n    change AnalyticOn ğ•œ (fun x â†¦ ContinuousMultilinearMap.prodL _ _ _ _ (p x i, q x i))\n      (u âˆ© v)\n    apply AnalyticOnNhd.comp_analyticOn (LinearIsometryEquiv.analyticOnNhd _ _) _\n      (Set.mapsTo_univ _ _)\n    exact ((h'p i).mono inter_subset_left).prod ((h'q i).mono inter_subset_right)\n  | (n : â„•âˆ) =>\n    intro m hm\n    rcases hf m hm with âŸ¨u, hu, p, hpâŸ©\n    rcases hg m hm with âŸ¨v, hv, q, hqâŸ©\n    exact\n      âŸ¨u âˆ© v, Filter.inter_mem hu hv, _,\n        (hp.mono inter_subset_left).prod (hq.mono inter_subset_right)âŸ©\n\n"}
{"name":"ContDiffOn.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nf : E â†’ F\ng : E â†’ G\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => { fst := f x, snd := g x }) s","decl":"/-- The cartesian product of `C^n` functions on domains is `C^n`. -/\ntheorem ContDiffOn.prod {s : Set E} {f : E â†’ F} {g : E â†’ G} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) : ContDiffOn ğ•œ n (fun x : E => (f x, g x)) s := fun x hx =>\n  (hf x hx).prod (hg x hx)\n\n"}
{"name":"ContDiffAt.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nn : WithTop ENat\nf : E â†’ F\ng : E â†’ G\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => { fst := f x, snd := g x }) x","decl":"/-- The cartesian product of `C^n` functions at a point is `C^n`. -/\ntheorem ContDiffAt.prod {f : E â†’ F} {g : E â†’ G} (hf : ContDiffAt ğ•œ n f x)\n    (hg : ContDiffAt ğ•œ n g x) : ContDiffAt ğ•œ n (fun x : E => (f x, g x)) x :=\n  contDiffWithinAt_univ.1 <|\n    ContDiffWithinAt.prod (contDiffWithinAt_univ.2 hf) (contDiffWithinAt_univ.2 hg)\n\n"}
{"name":"ContDiff.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ F\ng : E â†’ G\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => { fst := f x, snd := g x }","decl":"/-- The cartesian product of `C^n` functions is `C^n`. -/\ntheorem ContDiff.prod {f : E â†’ F} {g : E â†’ G} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g) :\n    ContDiff ğ•œ n fun x : E => (f x, g x) :=\n  contDiffOn_univ.1 <| ContDiffOn.prod (contDiffOn_univ.2 hf) (contDiffOn_univ.2 hg)\n\n"}
{"name":"ContDiffWithinAt.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nst : Set.MapsTo f s t\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t (f x)) (hf : ContDiffWithinAt ğ•œ n f s x) (st : MapsTo f s t) :\n    ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x := by\n  match n with\n  | Ï‰ =>\n    have h'f : ContDiffWithinAt ğ•œ Ï‰ f s x := hf\n    obtain âŸ¨u, hu, p, hp, h'pâŸ© := h'f\n    obtain âŸ¨v, hv, q, hq, h'qâŸ© := hg\n    let w := insert x s âˆ© (u âˆ© f â»Â¹' v)\n    have wv : w âŠ† f â»Â¹' v := fun y hy => hy.2.2\n    have wu : w âŠ† u := fun y hy => hy.2.1\n    refine âŸ¨w, ?_, fun y â†¦ (q (f y)).taylorComp (p y), hq.comp (hp.mono wu) wv, ?_âŸ©\n    Â· apply inter_mem self_mem_nhdsWithin (inter_mem hu ?_)\n      apply (continuousWithinAt_insert_self.2 hf.continuousWithinAt).preimage_mem_nhdsWithin'\n      apply nhdsWithin_mono _ _ hv\n      simp only [image_insert_eq]\n      apply insert_subset_insert\n      exact image_subset_iff.mpr st\n    Â· have : AnalyticOn ğ•œ f w := by\n        have : AnalyticOn ğ•œ (fun y â†¦ (continuousMultilinearCurryFin0 ğ•œ E F).symm (f y)) w :=\n          ((h'p 0).mono wu).congr  fun y hy â†¦ (hp.zero_eq' (wu hy)).symm\n        have : AnalyticOn ğ•œ (fun y â†¦ (continuousMultilinearCurryFin0 ğ•œ E F)\n            ((continuousMultilinearCurryFin0 ğ•œ E F).symm (f y))) w :=\n          AnalyticOnNhd.comp_analyticOn (LinearIsometryEquiv.analyticOnNhd _ _ ) this\n          (mapsTo_univ _ _)\n        simpa using this\n      exact analyticOn_taylorComp h'q (fun n â†¦ (h'p n).mono wu) this wv\n  | (n : â„•âˆ) =>\n    intro m hm\n    rcases hf m hm with âŸ¨u, hu, p, hpâŸ©\n    rcases hg m hm with âŸ¨v, hv, q, hqâŸ©\n    let w := insert x s âˆ© (u âˆ© f â»Â¹' v)\n    have wv : w âŠ† f â»Â¹' v := fun y hy => hy.2.2\n    have wu : w âŠ† u := fun y hy => hy.2.1\n    refine âŸ¨w, ?_, fun y â†¦ (q (f y)).taylorComp (p y), hq.comp (hp.mono wu) wvâŸ©\n    apply inter_mem self_mem_nhdsWithin (inter_mem hu ?_)\n    apply (continuousWithinAt_insert_self.2 hf.continuousWithinAt).preimage_mem_nhdsWithin'\n    apply nhdsWithin_mono _ _ hv\n    simp only [image_insert_eq]\n    apply insert_subset_insert\n    exact image_subset_iff.mpr st\n\n"}
{"name":"ContDiffOn.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nhg : ContDiffOn ğ•œ n g t\nhf : ContDiffOn ğ•œ n f s\nst : Set.MapsTo f s t\nâŠ¢ ContDiffOn ğ•œ n (Function.comp g f) s","decl":"/-- The composition of `C^n` functions on domains is `C^n`. -/\ntheorem ContDiffOn.comp {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (hg : ContDiffOn ğ•œ n g t)\n    (hf : ContDiffOn ğ•œ n f s) (st : MapsTo f s t) : ContDiffOn ğ•œ n (g âˆ˜ f) s :=\n  fun x hx â†¦ ContDiffWithinAt.comp x (hg (f x) (st hx)) (hf x hx) st\n\n"}
{"name":"ContDiffOn.comp_inter","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nhg : ContDiffOn ğ•œ n g t\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (Function.comp g f) (Inter.inter s (Set.preimage f t))","decl":"/-- The composition of `C^n` functions on domains is `C^n`. -/\ntheorem ContDiffOn.comp_inter\n    {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (hg : ContDiffOn ğ•œ n g t)\n    (hf : ContDiffOn ğ•œ n f s) : ContDiffOn ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) :=\n  hg.comp (hf.mono inter_subset_left) inter_subset_right\n\n"}
{"name":"ContDiffOn.comp'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nhg : ContDiffOn ğ•œ n g t\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (Function.comp g f) (Inter.inter s (Set.preimage f t))","decl":"@[deprecated (since := \"2024-10-30\")] alias ContDiffOn.comp' := ContDiffOn.comp_inter\n\n"}
{"name":"ContDiff.comp_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\ng : F â†’ G\nf : E â†’ F\nhg : ContDiff ğ•œ n g\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (Function.comp g f) s","decl":"/-- The composition of a `C^n` function on a domain with a `C^n` function is `C^n`. -/\ntheorem ContDiff.comp_contDiffOn {s : Set E} {g : F â†’ G} {f : E â†’ F} (hg : ContDiff ğ•œ n g)\n    (hf : ContDiffOn ğ•œ n f s) : ContDiffOn ğ•œ n (g âˆ˜ f) s :=\n  (contDiffOn_univ.2 hg).comp hf (mapsTo_univ _ _)\n\n"}
{"name":"ContDiffOn.comp_contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set F\ng : F â†’ G\nf : E â†’ F\nhg : ContDiffOn ğ•œ n g s\nhf : ContDiff ğ•œ n f\nhs : âˆ€ (x : E), Membership.mem s (f x)\nâŠ¢ ContDiff ğ•œ n (Function.comp g f)","decl":"theorem ContDiffOn.comp_contDiff {s : Set F} {g : F â†’ G} {f : E â†’ F} (hg : ContDiffOn ğ•œ n g s)\n    (hf : ContDiff ğ•œ n f) (hs : âˆ€ x, f x âˆˆ s) : ContDiff ğ•œ n (g âˆ˜ f) := by\n  rw [â† contDiffOn_univ] at *\n  exact hg.comp hf fun x _ => hs x\n\n"}
{"name":"ContDiffOn.image_comp_contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\ng : F â†’ G\nf : E â†’ F\nhg : ContDiffOn ğ•œ n g (Set.image f s)\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiffOn ğ•œ n (Function.comp g f) s","decl":"theorem ContDiffOn.image_comp_contDiff {s : Set E} {g : F â†’ G} {f : E â†’ F}\n    (hg : ContDiffOn ğ•œ n g (f '' s)) (hf : ContDiff ğ•œ n f) : ContDiffOn ğ•œ n (g âˆ˜ f) s :=\n  hg.comp hf.contDiffOn (s.mapsTo_image f)\n\n"}
{"name":"ContDiff.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ng : F â†’ G\nf : E â†’ F\nhg : ContDiff ğ•œ n g\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n (Function.comp g f)","decl":"/-- The composition of `C^n` functions is `C^n`. -/\ntheorem ContDiff.comp {g : F â†’ G} {f : E â†’ F} (hg : ContDiff ğ•œ n g) (hf : ContDiff ğ•œ n f) :\n    ContDiff ğ•œ n (g âˆ˜ f) :=\n  contDiffOn_univ.1 <| ContDiffOn.comp (contDiffOn_univ.2 hg) (contDiffOn_univ.2 hf) (subset_univ _)\n\n"}
{"name":"ContDiffWithinAt.comp_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t y\nhf : ContDiffWithinAt ğ•œ n f s x\nst : Set.MapsTo f s t\nhy : Eq (f x) y\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp_of_eq {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} {y : F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t y) (hf : ContDiffWithinAt ğ•œ n f s x) (st : MapsTo f s t)\n    (hy : f x = y) :\n    ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x := by\n  subst hy; exact hg.comp x hf st\n\n"}
{"name":"ContDiffWithinAt.comp_of_mem_nhdsWithin_image","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : Membership.mem (nhdsWithin (f x) (Set.image f s)) t\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_mem_nhdsWithin_image\n    {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t (f x)) (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hs : t âˆˆ ğ“[f '' s] f x) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x :=\n  (hg.mono_of_mem_nhdsWithin hs).comp x hf (subset_preimage_image f s)\n\n"}
{"name":"ContDiffWithinAt.comp_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : Membership.mem (nhdsWithin (f x) (Set.image f s)) t\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.comp_of_mem := ContDiffWithinAt.comp_of_mem_nhdsWithin_image\n\n"}
{"name":"ContDiffWithinAt.comp_of_mem_nhdsWithin_image_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t y\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : Membership.mem (nhdsWithin (f x) (Set.image f s)) t\nhy : Eq (f x) y\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_mem_nhdsWithin_image_of_eq\n    {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} {y : F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t y) (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hs : t âˆˆ ğ“[f '' s] f x) (hy : f x = y) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x := by\n  subst hy; exact hg.comp_of_mem_nhdsWithin_image x hf hs\n\n"}
{"name":"ContDiffWithinAt.comp_inter","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp_inter {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t (f x)) (hf : ContDiffWithinAt ğ•œ n f s x) :\n    ContDiffWithinAt ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x :=\n  hg.comp x (hf.mono inter_subset_left) inter_subset_right\n\n"}
{"name":"ContDiffWithinAt.comp_inter_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t y\nhf : ContDiffWithinAt ğ•œ n f s x\nhy : Eq (f x) y\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp_inter_of_eq {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} {y : F}\n    (x : E) (hg : ContDiffWithinAt ğ•œ n g t y) (hf : ContDiffWithinAt ğ•œ n f s x) (hy : f x = y) :\n    ContDiffWithinAt ğ•œ n (g âˆ˜ f) (s âˆ© f â»Â¹' t) x := by\n  subst hy; exact hg.comp_inter x hf\n\n"}
{"name":"ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : Membership.mem (nhdsWithin x s) (Set.preimage f t)\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin\n    {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t (f x)) (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hs : f â»Â¹' t âˆˆ ğ“[s] x) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x :=\n  (hg.comp_inter x hf).mono_of_mem_nhdsWithin (inter_mem self_mem_nhdsWithin hs)\n\n"}
{"name":"ContDiffWithinAt.comp'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.comp' := ContDiffWithinAt.comp_inter\n\n"}
{"name":"ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F â†’ G\nf : E â†’ F\ny : F\nx : E\nhg : ContDiffWithinAt ğ•œ n g t y\nhf : ContDiffWithinAt ğ•œ n f s x\nhs : Membership.mem (nhdsWithin x s) (Set.preimage f t)\nhy : Eq (f x) y\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin_of_eq\n    {s : Set E} {t : Set F} {g : F â†’ G} {f : E â†’ F} {y : F} (x : E)\n    (hg : ContDiffWithinAt ğ•œ n g t y) (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hs : f â»Â¹' t âˆˆ ğ“[s] x) (hy : f x = y) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x := by\n  subst hy; exact hg.comp_of_preimage_mem_nhdsWithin x hf hs\n\n"}
{"name":"ContDiffAt.comp_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\ng : F â†’ G\nn : WithTop ENat\nx : E\nhg : ContDiffAt ğ•œ n g (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"theorem ContDiffAt.comp_contDiffWithinAt (x : E) (hg : ContDiffAt ğ•œ n g (f x))\n    (hf : ContDiffWithinAt ğ•œ n f s x) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x :=\n  hg.comp x hf (mapsTo_univ _ _)\n\n"}
{"name":"ContDiffAt.comp_contDiffWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\ng : F â†’ G\nn : WithTop ENat\ny : F\nx : E\nhg : ContDiffAt ğ•œ n g y\nhf : ContDiffWithinAt ğ•œ n f s x\nhy : Eq (f x) y\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) s x","decl":"theorem ContDiffAt.comp_contDiffWithinAt_of_eq {y : F} (x : E) (hg : ContDiffAt ğ•œ n g y)\n    (hf : ContDiffWithinAt ğ•œ n f s x) (hy : f x = y) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) s x := by\n  subst hy; exact hg.comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffAt.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : F â†’ G\nn : WithTop ENat\nx : E\nhg : ContDiffAt ğ•œ n g (f x)\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (Function.comp g f) x","decl":"/-- The composition of `C^n` functions at points is `C^n`. -/\nnonrec theorem ContDiffAt.comp (x : E) (hg : ContDiffAt ğ•œ n g (f x)) (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (g âˆ˜ f) x :=\n  hg.comp x hf (mapsTo_univ _ _)\n\n"}
{"name":"ContDiff.comp_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nt : Set E\nx : E\nn : WithTop ENat\ng : F â†’ G\nf : E â†’ F\nh : ContDiff ğ•œ n g\nhf : ContDiffWithinAt ğ•œ n f t x\nâŠ¢ ContDiffWithinAt ğ•œ n (Function.comp g f) t x","decl":"theorem ContDiff.comp_contDiffWithinAt {g : F â†’ G} {f : E â†’ F} (h : ContDiff ğ•œ n g)\n    (hf : ContDiffWithinAt ğ•œ n f t x) : ContDiffWithinAt ğ•œ n (g âˆ˜ f) t x :=\n  haveI : ContDiffWithinAt ğ•œ n g univ (f x) := h.contDiffAt.contDiffWithinAt\n  this.comp x hf (subset_univ _)\n\n"}
{"name":"ContDiff.comp_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ng : F â†’ G\nf : E â†’ F\nx : E\nhg : ContDiff ğ•œ n g\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (Function.comp g f) x","decl":"theorem ContDiff.comp_contDiffAt {g : F â†’ G} {f : E â†’ F} (x : E) (hg : ContDiff ğ•œ n g)\n    (hf : ContDiffAt ğ•œ n f x) : ContDiffAt ğ•œ n (g âˆ˜ f) x :=\n  hg.comp_contDiffWithinAt hf\n\n"}
{"name":"iteratedFDerivWithin_comp_of_eventually_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\ng : F â†’ G\nx : E\nn : WithTop ENat\nt : Set F\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nht : UniqueDiffOn ğ•œ t\nhs : UniqueDiffOn ğ•œ s\nhxs : Membership.mem s x\nhst : Filter.Eventually (fun y => Membership.mem t (f y)) (nhdsWithin x s)\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Function.comp g f) s x) ((ftaylorSeriesWithin ğ•œ g t (f x)).taylorComp (ftaylorSeriesWithin ğ•œ f s x) i)","decl":"theorem iteratedFDerivWithin_comp_of_eventually_mem {t : Set F}\n    (hg : ContDiffWithinAt ğ•œ n g t (f x)) (hf : ContDiffWithinAt ğ•œ n f s x)\n    (ht : UniqueDiffOn ğ•œ t) (hs : UniqueDiffOn ğ•œ s) (hxs : x âˆˆ s) (hst : âˆ€á¶  y in ğ“[s] x, f y âˆˆ t)\n    {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s x =\n      (ftaylorSeriesWithin ğ•œ g t (f x)).taylorComp (ftaylorSeriesWithin ğ•œ f s x) i := by\n  obtain âŸ¨u, hxu, huo, hfu, hguâŸ© : âˆƒ u, x âˆˆ u âˆ§ IsOpen u âˆ§\n      HasFTaylorSeriesUpToOn i f (ftaylorSeriesWithin ğ•œ f s) (s âˆ© u) âˆ§\n      HasFTaylorSeriesUpToOn i g (ftaylorSeriesWithin ğ•œ g t) (f '' (s âˆ© u)) := by\n    have hxt : f x âˆˆ t := hst.self_of_nhdsWithin hxs\n    have hf_tendsto : Tendsto f (ğ“[s] x) (ğ“[t] (f x)) :=\n      tendsto_nhdsWithin_iff.mpr âŸ¨hf.continuousWithinAt, hstâŸ©\n    have Hâ‚ : âˆ€á¶  u in (ğ“[s] x).smallSets,\n        HasFTaylorSeriesUpToOn i f (ftaylorSeriesWithin ğ•œ f s) u :=\n      hf.eventually_hasFTaylorSeriesUpToOn hs hxs hi\n    have Hâ‚‚ : âˆ€á¶  u in (ğ“[s] x).smallSets,\n        HasFTaylorSeriesUpToOn i g (ftaylorSeriesWithin ğ•œ g t) (f '' u) :=\n      hf_tendsto.image_smallSets.eventually (hg.eventually_hasFTaylorSeriesUpToOn ht hxt hi)\n    rcases (nhdsWithin_basis_open _ _).smallSets.eventually_iff.mp (Hâ‚.and Hâ‚‚)\n      with âŸ¨u, âŸ¨hxu, huoâŸ©, huâŸ©\n    exact âŸ¨u, hxu, huo, hu (by simp [inter_comm])âŸ©\n  exact .symm <| (hgu.comp hfu (mapsTo_image _ _)).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl\n    (hs.inter huo) âŸ¨hxs, hxuâŸ© |>.trans <| iteratedFDerivWithin_inter_open huo hxu\n\n"}
{"name":"iteratedFDerivWithin_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nf : E â†’ F\ng : F â†’ G\nx : E\nn : WithTop ENat\nt : Set F\nhg : ContDiffWithinAt ğ•œ n g t (f x)\nhf : ContDiffWithinAt ğ•œ n f s x\nht : UniqueDiffOn ğ•œ t\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nhst : Set.MapsTo f s t\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Function.comp g f) s x) ((ftaylorSeriesWithin ğ•œ g t (f x)).taylorComp (ftaylorSeriesWithin ğ•œ f s x) i)","decl":"theorem iteratedFDerivWithin_comp {t : Set F} (hg : ContDiffWithinAt ğ•œ n g t (f x))\n    (hf : ContDiffWithinAt ğ•œ n f s x) (ht : UniqueDiffOn ğ•œ t) (hs : UniqueDiffOn ğ•œ s)\n    (hx : x âˆˆ s) (hst : MapsTo f s t) {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDerivWithin ğ•œ i (g âˆ˜ f) s x =\n      (ftaylorSeriesWithin ğ•œ g t (f x)).taylorComp (ftaylorSeriesWithin ğ•œ f s x) i :=\n  iteratedFDerivWithin_comp_of_eventually_mem hg hf ht hs hx (eventually_mem_nhdsWithin.mono hst) hi\n\n"}
{"name":"iteratedFDeriv_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nf : E â†’ F\ng : F â†’ G\nx : E\nn : WithTop ENat\nhg : ContDiffAt ğ•œ n g (f x)\nhf : ContDiffAt ğ•œ n f x\ni : Nat\nhi : LE.le (â†‘i) n\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (Function.comp g f) x) ((ftaylorSeries ğ•œ g (f x)).taylorComp (ftaylorSeries ğ•œ f x) i)","decl":"theorem iteratedFDeriv_comp (hg : ContDiffAt ğ•œ n g (f x)) (hf : ContDiffAt ğ•œ n f x)\n    {i : â„•} (hi : i â‰¤ n) :\n    iteratedFDeriv ğ•œ i (g âˆ˜ f) x =\n      (ftaylorSeries ğ•œ g (f x)).taylorComp (ftaylorSeries ğ•œ f x) i := by\n  simp only [â† iteratedFDerivWithin_univ, â† ftaylorSeriesWithin_univ]\n  exact iteratedFDerivWithin_comp hg.contDiffWithinAt hf.contDiffWithinAt\n    uniqueDiffOn_univ uniqueDiffOn_univ (mem_univ _) (mapsTo_univ _ _) hi\n\n"}
{"name":"contDiff_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n Prod.fst","decl":"/-- The first projection in a product is `C^âˆ`. -/\ntheorem contDiff_fst : ContDiff ğ•œ n (Prod.fst : E Ã— F â†’ E) :=\n  IsBoundedLinearMap.contDiff IsBoundedLinearMap.fst\n\n"}
{"name":"ContDiff.fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ Prod F G\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => (f x).1","decl":"/-- Postcomposing `f` with `Prod.fst` is `C^n` -/\ntheorem ContDiff.fst {f : E â†’ F Ã— G} (hf : ContDiff ğ•œ n f) : ContDiff ğ•œ n fun x => (f x).1 :=\n  contDiff_fst.comp hf\n\n"}
{"name":"ContDiff.fst'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ G\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => f x.1","decl":"/-- Precomposing `f` with `Prod.fst` is `C^n` -/\ntheorem ContDiff.fst' {f : E â†’ G} (hf : ContDiff ğ•œ n f) : ContDiff ğ•œ n fun x : E Ã— F => f x.1 :=\n  hf.comp contDiff_fst\n\n"}
{"name":"contDiffOn_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set (Prod E F)\nâŠ¢ ContDiffOn ğ•œ n Prod.fst s","decl":"/-- The first projection on a domain in a product is `C^âˆ`. -/\ntheorem contDiffOn_fst {s : Set (E Ã— F)} : ContDiffOn ğ•œ n (Prod.fst : E Ã— F â†’ E) s :=\n  ContDiff.contDiffOn contDiff_fst\n\n"}
{"name":"ContDiffOn.fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ Prod F G\ns : Set E\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (fun x => (f x).1) s","decl":"theorem ContDiffOn.fst {f : E â†’ F Ã— G} {s : Set E} (hf : ContDiffOn ğ•œ n f s) :\n    ContDiffOn ğ•œ n (fun x => (f x).1) s :=\n  contDiff_fst.comp_contDiffOn hf\n\n"}
{"name":"contDiffAt_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\np : Prod E F\nâŠ¢ ContDiffAt ğ•œ n Prod.fst p","decl":"/-- The first projection at a point in a product is `C^âˆ`. -/\ntheorem contDiffAt_fst {p : E Ã— F} : ContDiffAt ğ•œ n (Prod.fst : E Ã— F â†’ E) p :=\n  contDiff_fst.contDiffAt\n\n"}
{"name":"ContDiffAt.fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ Prod F G\nx : E\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (fun x => (f x).1) x","decl":"/-- Postcomposing `f` with `Prod.fst` is `C^n` at `(x, y)` -/\ntheorem ContDiffAt.fst {f : E â†’ F Ã— G} {x : E} (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (fun x => (f x).1) x :=\n  contDiffAt_fst.comp x hf\n\n"}
{"name":"ContDiffAt.fst'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ G\nx : E\ny : F\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (fun x => f x.1) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.fst` is `C^n` at `(x, y)` -/\ntheorem ContDiffAt.fst' {f : E â†’ G} {x : E} {y : F} (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (fun x : E Ã— F => f x.1) (x, y) :=\n  ContDiffAt.comp (x, y) hf contDiffAt_fst\n\n"}
{"name":"ContDiffAt.fst''","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ G\nx : Prod E F\nhf : ContDiffAt ğ•œ n f x.1\nâŠ¢ ContDiffAt ğ•œ n (fun x => f x.1) x","decl":"/-- Precomposing `f` with `Prod.fst` is `C^n` at `x : E Ã— F` -/\ntheorem ContDiffAt.fst'' {f : E â†’ G} {x : E Ã— F} (hf : ContDiffAt ğ•œ n f x.1) :\n    ContDiffAt ğ•œ n (fun x : E Ã— F => f x.1) x :=\n  hf.comp x contDiffAt_fst\n\n"}
{"name":"contDiffWithinAt_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set (Prod E F)\np : Prod E F\nâŠ¢ ContDiffWithinAt ğ•œ n Prod.fst s p","decl":"/-- The first projection within a domain at a point in a product is `C^âˆ`. -/\ntheorem contDiffWithinAt_fst {s : Set (E Ã— F)} {p : E Ã— F} :\n    ContDiffWithinAt ğ•œ n (Prod.fst : E Ã— F â†’ E) s p :=\n  contDiff_fst.contDiffWithinAt\n\n"}
{"name":"contDiff_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n Prod.snd","decl":"/-- The second projection in a product is `C^âˆ`. -/\ntheorem contDiff_snd : ContDiff ğ•œ n (Prod.snd : E Ã— F â†’ F) :=\n  IsBoundedLinearMap.contDiff IsBoundedLinearMap.snd\n\n"}
{"name":"ContDiff.snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ Prod F G\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => (f x).2","decl":"/-- Postcomposing `f` with `Prod.snd` is `C^n` -/\ntheorem ContDiff.snd {f : E â†’ F Ã— G} (hf : ContDiff ğ•œ n f) : ContDiff ğ•œ n fun x => (f x).2 :=\n  contDiff_snd.comp hf\n\n"}
{"name":"ContDiff.snd'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : F â†’ G\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => f x.2","decl":"/-- Precomposing `f` with `Prod.snd` is `C^n` -/\ntheorem ContDiff.snd' {f : F â†’ G} (hf : ContDiff ğ•œ n f) : ContDiff ğ•œ n fun x : E Ã— F => f x.2 :=\n  hf.comp contDiff_snd\n\n"}
{"name":"contDiffOn_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set (Prod E F)\nâŠ¢ ContDiffOn ğ•œ n Prod.snd s","decl":"/-- The second projection on a domain in a product is `C^âˆ`. -/\ntheorem contDiffOn_snd {s : Set (E Ã— F)} : ContDiffOn ğ•œ n (Prod.snd : E Ã— F â†’ F) s :=\n  ContDiff.contDiffOn contDiff_snd\n\n"}
{"name":"ContDiffOn.snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ Prod F G\ns : Set E\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (fun x => (f x).2) s","decl":"theorem ContDiffOn.snd {f : E â†’ F Ã— G} {s : Set E} (hf : ContDiffOn ğ•œ n f s) :\n    ContDiffOn ğ•œ n (fun x => (f x).2) s :=\n  contDiff_snd.comp_contDiffOn hf\n\n"}
{"name":"contDiffAt_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\np : Prod E F\nâŠ¢ ContDiffAt ğ•œ n Prod.snd p","decl":"/-- The second projection at a point in a product is `C^âˆ`. -/\ntheorem contDiffAt_snd {p : E Ã— F} : ContDiffAt ğ•œ n (Prod.snd : E Ã— F â†’ F) p :=\n  contDiff_snd.contDiffAt\n\n"}
{"name":"ContDiffAt.snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ Prod F G\nx : E\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (fun x => (f x).2) x","decl":"/-- Postcomposing `f` with `Prod.snd` is `C^n` at `x` -/\ntheorem ContDiffAt.snd {f : E â†’ F Ã— G} {x : E} (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (fun x => (f x).2) x :=\n  contDiffAt_snd.comp x hf\n\n"}
{"name":"ContDiffAt.snd'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : F â†’ G\nx : E\ny : F\nhf : ContDiffAt ğ•œ n f y\nâŠ¢ ContDiffAt ğ•œ n (fun x => f x.2) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.snd` is `C^n` at `(x, y)` -/\ntheorem ContDiffAt.snd' {f : F â†’ G} {x : E} {y : F} (hf : ContDiffAt ğ•œ n f y) :\n    ContDiffAt ğ•œ n (fun x : E Ã— F => f x.2) (x, y) :=\n  ContDiffAt.comp (x, y) hf contDiffAt_snd\n\n"}
{"name":"ContDiffAt.snd''","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : F â†’ G\nx : Prod E F\nhf : ContDiffAt ğ•œ n f x.2\nâŠ¢ ContDiffAt ğ•œ n (fun x => f x.2) x","decl":"/-- Precomposing `f` with `Prod.snd` is `C^n` at `x : E Ã— F` -/\ntheorem ContDiffAt.snd'' {f : F â†’ G} {x : E Ã— F} (hf : ContDiffAt ğ•œ n f x.2) :\n    ContDiffAt ğ•œ n (fun x : E Ã— F => f x.2) x :=\n  hf.comp x contDiffAt_snd\n\n"}
{"name":"contDiffWithinAt_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set (Prod E F)\np : Prod E F\nâŠ¢ ContDiffWithinAt ğ•œ n Prod.snd s p","decl":"/-- The second projection within a domain at a point in a product is `C^âˆ`. -/\ntheorem contDiffWithinAt_snd {s : Set (E Ã— F)} {p : E Ã— F} :\n    ContDiffWithinAt ğ•œ n (Prod.snd : E Ã— F â†’ F) s p :=\n  contDiff_snd.contDiffWithinAt\n\n"}
{"name":"ContDiff.compâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiff ğ•œ n fâ‚\nhfâ‚‚ : ContDiff ğ•œ n fâ‚‚\nâŠ¢ ContDiff ğ•œ n fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }","decl":"theorem ContDiff.compâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} (hg : ContDiff ğ•œ n g)\n    (hfâ‚ : ContDiff ğ•œ n fâ‚) (hfâ‚‚ : ContDiff ğ•œ n fâ‚‚) : ContDiff ğ•œ n fun x => g (fâ‚ x, fâ‚‚ x) :=\n  hg.comp <| hfâ‚.prod hfâ‚‚\n\n"}
{"name":"ContDiffAt.compâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nx : F\nhg : ContDiffAt ğ•œ n g { fst := fâ‚ x, snd := fâ‚‚ x }\nhfâ‚ : ContDiffAt ğ•œ n fâ‚ x\nhfâ‚‚ : ContDiffAt ğ•œ n fâ‚‚ x\nâŠ¢ ContDiffAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) x","decl":"theorem ContDiffAt.compâ‚‚ {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {x : F}\n    (hg : ContDiffAt ğ•œ n g (fâ‚ x, fâ‚‚ x))\n    (hfâ‚ : ContDiffAt ğ•œ n fâ‚ x) (hfâ‚‚ : ContDiffAt ğ•œ n fâ‚‚ x) :\n    ContDiffAt ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) x :=\n  hg.comp x (hfâ‚.prod hfâ‚‚)\n\n"}
{"name":"ContDiffAt.compâ‚‚_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nx : F\nhg : ContDiffAt ğ•œ n g { fst := fâ‚ x, snd := fâ‚‚ x }\nhfâ‚ : ContDiffWithinAt ğ•œ n fâ‚ s x\nhfâ‚‚ : ContDiffWithinAt ğ•œ n fâ‚‚ s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s x","decl":"theorem ContDiffAt.compâ‚‚_contDiffWithinAt {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚}\n    {s : Set F} {x : F} (hg : ContDiffAt ğ•œ n g (fâ‚ x, fâ‚‚ x))\n    (hfâ‚ : ContDiffWithinAt ğ•œ n fâ‚ s x) (hfâ‚‚ : ContDiffWithinAt ğ•œ n fâ‚‚ s x) :\n    ContDiffWithinAt ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) s x :=\n  hg.comp_contDiffWithinAt x (hfâ‚.prod hfâ‚‚)\n\n"}
{"name":"ContDiffAt.comp_contDiffWithinAtâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nx : F\nhg : ContDiffAt ğ•œ n g { fst := fâ‚ x, snd := fâ‚‚ x }\nhfâ‚ : ContDiffWithinAt ğ•œ n fâ‚ s x\nhfâ‚‚ : ContDiffWithinAt ğ•œ n fâ‚‚ s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiffAt.comp_contDiffWithinAtâ‚‚ := ContDiffAt.compâ‚‚_contDiffWithinAt\n\n"}
{"name":"ContDiff.compâ‚‚_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nx : F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffAt ğ•œ n fâ‚ x\nhfâ‚‚ : ContDiffAt ğ•œ n fâ‚‚ x\nâŠ¢ ContDiffAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) x","decl":"theorem ContDiff.compâ‚‚_contDiffAt {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {x : F}\n    (hg : ContDiff ğ•œ n g) (hfâ‚ : ContDiffAt ğ•œ n fâ‚ x) (hfâ‚‚ : ContDiffAt ğ•œ n fâ‚‚ x) :\n    ContDiffAt ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) x :=\n  hg.contDiffAt.compâ‚‚ hfâ‚ hfâ‚‚\n\n"}
{"name":"ContDiff.comp_contDiffAtâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nx : F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffAt ğ•œ n fâ‚ x\nhfâ‚‚ : ContDiffAt ğ•œ n fâ‚‚ x\nâŠ¢ ContDiffAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffAtâ‚‚ := ContDiff.compâ‚‚_contDiffAt\n\n"}
{"name":"ContDiff.compâ‚‚_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nx : F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffWithinAt ğ•œ n fâ‚ s x\nhfâ‚‚ : ContDiffWithinAt ğ•œ n fâ‚‚ s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s x","decl":"theorem ContDiff.compâ‚‚_contDiffWithinAt {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚}\n    {s : Set F} {x : F} (hg : ContDiff ğ•œ n g)\n    (hfâ‚ : ContDiffWithinAt ğ•œ n fâ‚ s x) (hfâ‚‚ : ContDiffWithinAt ğ•œ n fâ‚‚ s x) :\n    ContDiffWithinAt ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) s x :=\n  hg.contDiffAt.comp_contDiffWithinAt x  (hfâ‚.prod hfâ‚‚)\n\n"}
{"name":"ContDiff.comp_contDiffWithinAtâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nx : F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffWithinAt ğ•œ n fâ‚ s x\nhfâ‚‚ : ContDiffWithinAt ğ•œ n fâ‚‚ s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffWithinAtâ‚‚ := ContDiff.compâ‚‚_contDiffWithinAt\n\n"}
{"name":"ContDiff.compâ‚‚_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffOn ğ•œ n fâ‚ s\nhfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s\nâŠ¢ ContDiffOn ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s","decl":"theorem ContDiff.compâ‚‚_contDiffOn {g : Eâ‚ Ã— Eâ‚‚ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {s : Set F}\n    (hg : ContDiff ğ•œ n g) (hfâ‚ : ContDiffOn ğ•œ n fâ‚ s) (hfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s) :\n    ContDiffOn ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x)) s :=\n  hg.comp_contDiffOn <| hfâ‚.prod hfâ‚‚\n\n"}
{"name":"ContDiff.comp_contDiff_onâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffOn ğ•œ n fâ‚ s\nhfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s\nâŠ¢ ContDiffOn ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s","decl":"@[deprecated (since := \"2024-10-10\")] alias ContDiff.comp_contDiff_onâ‚‚ := ContDiff.compâ‚‚_contDiffOn\n\n"}
{"name":"ContDiff.comp_contDiffOnâ‚‚","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâµ : NormedAddCommGroup G\ninstâœâ´ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\ninstâœÂ³ : NormedAddCommGroup Eâ‚\ninstâœÂ² : NormedAddCommGroup Eâ‚‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚\ninstâœ : NormedSpace ğ•œ Eâ‚‚\ng : Prod Eâ‚ Eâ‚‚ â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\ns : Set F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffOn ğ•œ n fâ‚ s\nhfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s\nâŠ¢ ContDiffOn ğ•œ n (fun x => g { fst := fâ‚ x, snd := fâ‚‚ x }) s","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffOnâ‚‚ := ContDiff.compâ‚‚_contDiffOn\n\n"}
{"name":"ContDiff.compâ‚ƒ","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\nEâ‚ƒ : Type u_5\ninstâœâµ : NormedAddCommGroup Eâ‚\ninstâœâ´ : NormedAddCommGroup Eâ‚‚\ninstâœÂ³ : NormedAddCommGroup Eâ‚ƒ\ninstâœÂ² : NormedSpace ğ•œ Eâ‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚‚\ninstâœ : NormedSpace ğ•œ Eâ‚ƒ\ng : Prod Eâ‚ (Prod Eâ‚‚ Eâ‚ƒ) â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nfâ‚ƒ : F â†’ Eâ‚ƒ\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiff ğ•œ n fâ‚\nhfâ‚‚ : ContDiff ğ•œ n fâ‚‚\nhfâ‚ƒ : ContDiff ğ•œ n fâ‚ƒ\nâŠ¢ ContDiff ğ•œ n fun x => g { fst := fâ‚ x, snd := { fst := fâ‚‚ x, snd := fâ‚ƒ x } }","decl":"theorem ContDiff.compâ‚ƒ {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ}\n    (hg : ContDiff ğ•œ n g) (hfâ‚ : ContDiff ğ•œ n fâ‚) (hfâ‚‚ : ContDiff ğ•œ n fâ‚‚) (hfâ‚ƒ : ContDiff ğ•œ n fâ‚ƒ) :\n    ContDiff ğ•œ n fun x => g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x) :=\n  hg.compâ‚‚ hfâ‚ <| hfâ‚‚.prod hfâ‚ƒ\n\n"}
{"name":"ContDiff.compâ‚ƒ_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\nEâ‚ƒ : Type u_5\ninstâœâµ : NormedAddCommGroup Eâ‚\ninstâœâ´ : NormedAddCommGroup Eâ‚‚\ninstâœÂ³ : NormedAddCommGroup Eâ‚ƒ\ninstâœÂ² : NormedSpace ğ•œ Eâ‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚‚\ninstâœ : NormedSpace ğ•œ Eâ‚ƒ\ng : Prod Eâ‚ (Prod Eâ‚‚ Eâ‚ƒ) â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nfâ‚ƒ : F â†’ Eâ‚ƒ\ns : Set F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffOn ğ•œ n fâ‚ s\nhfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s\nhfâ‚ƒ : ContDiffOn ğ•œ n fâ‚ƒ s\nâŠ¢ ContDiffOn ğ•œ n (fun x => g { fst := fâ‚ x, snd := { fst := fâ‚‚ x, snd := fâ‚ƒ x } }) s","decl":"theorem ContDiff.compâ‚ƒ_contDiffOn {g : Eâ‚ Ã— Eâ‚‚ Ã— Eâ‚ƒ â†’ G} {fâ‚ : F â†’ Eâ‚} {fâ‚‚ : F â†’ Eâ‚‚} {fâ‚ƒ : F â†’ Eâ‚ƒ}\n    {s : Set F} (hg : ContDiff ğ•œ n g) (hfâ‚ : ContDiffOn ğ•œ n fâ‚ s) (hfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s)\n    (hfâ‚ƒ : ContDiffOn ğ•œ n fâ‚ƒ s) : ContDiffOn ğ•œ n (fun x => g (fâ‚ x, fâ‚‚ x, fâ‚ƒ x)) s :=\n  hg.compâ‚‚_contDiffOn hfâ‚ <| hfâ‚‚.prod hfâ‚ƒ\n\n"}
{"name":"ContDiff.comp_contDiff_onâ‚ƒ","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\nEâ‚ƒ : Type u_5\ninstâœâµ : NormedAddCommGroup Eâ‚\ninstâœâ´ : NormedAddCommGroup Eâ‚‚\ninstâœÂ³ : NormedAddCommGroup Eâ‚ƒ\ninstâœÂ² : NormedSpace ğ•œ Eâ‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚‚\ninstâœ : NormedSpace ğ•œ Eâ‚ƒ\ng : Prod Eâ‚ (Prod Eâ‚‚ Eâ‚ƒ) â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nfâ‚ƒ : F â†’ Eâ‚ƒ\ns : Set F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffOn ğ•œ n fâ‚ s\nhfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s\nhfâ‚ƒ : ContDiffOn ğ•œ n fâ‚ƒ s\nâŠ¢ ContDiffOn ğ•œ n (fun x => g { fst := fâ‚ x, snd := { fst := fâ‚‚ x, snd := fâ‚ƒ x } }) s","decl":"@[deprecated (since := \"2024-10-10\")] alias ContDiff.comp_contDiff_onâ‚ƒ := ContDiff.compâ‚ƒ_contDiffOn\n\n"}
{"name":"ContDiff.comp_contDiffOnâ‚ƒ","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâ¹ : NormedAddCommGroup F\ninstâœâ¸ : NormedSpace ğ•œ F\nG : Type uG\ninstâœâ· : NormedAddCommGroup G\ninstâœâ¶ : NormedSpace ğ•œ G\nn : WithTop ENat\nEâ‚ : Type u_3\nEâ‚‚ : Type u_4\nEâ‚ƒ : Type u_5\ninstâœâµ : NormedAddCommGroup Eâ‚\ninstâœâ´ : NormedAddCommGroup Eâ‚‚\ninstâœÂ³ : NormedAddCommGroup Eâ‚ƒ\ninstâœÂ² : NormedSpace ğ•œ Eâ‚\ninstâœÂ¹ : NormedSpace ğ•œ Eâ‚‚\ninstâœ : NormedSpace ğ•œ Eâ‚ƒ\ng : Prod Eâ‚ (Prod Eâ‚‚ Eâ‚ƒ) â†’ G\nfâ‚ : F â†’ Eâ‚\nfâ‚‚ : F â†’ Eâ‚‚\nfâ‚ƒ : F â†’ Eâ‚ƒ\ns : Set F\nhg : ContDiff ğ•œ n g\nhfâ‚ : ContDiffOn ğ•œ n fâ‚ s\nhfâ‚‚ : ContDiffOn ğ•œ n fâ‚‚ s\nhfâ‚ƒ : ContDiffOn ğ•œ n fâ‚ƒ s\nâŠ¢ ContDiffOn ğ•œ n (fun x => g { fst := fâ‚ x, snd := { fst := fâ‚‚ x, snd := fâ‚ƒ x } }) s","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffOnâ‚ƒ := ContDiff.compâ‚ƒ_contDiffOn\n\n"}
{"name":"ContDiff.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nX : Type u_2\ninstâœÂ¹ : NormedAddCommGroup X\ninstâœ : NormedSpace ğ•œ X\nn : WithTop ENat\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nhg : ContDiff ğ•œ n g\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => (g x).comp (f x)","decl":"theorem ContDiff.clm_comp {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F} (hg : ContDiff ğ•œ n g)\n    (hf : ContDiff ğ•œ n f) : ContDiff ğ•œ n fun x => (g x).comp (f x) :=\n  isBoundedBilinearMap_comp.contDiff.compâ‚‚ (g := fun p => p.1.comp p.2) hg hf\n\n"}
{"name":"ContDiffOn.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nX : Type u_2\ninstâœÂ¹ : NormedAddCommGroup X\ninstâœ : NormedSpace ğ•œ X\nn : WithTop ENat\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set X\nhg : ContDiffOn ğ•œ n g s\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (fun x => (g x).comp (f x)) s","decl":"theorem ContDiffOn.clm_comp {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F} {s : Set X}\n    (hg : ContDiffOn ğ•œ n g s) (hf : ContDiffOn ğ•œ n f s) :\n    ContDiffOn ğ•œ n (fun x => (g x).comp (f x)) s :=\n  (isBoundedBilinearMap_comp (E := E) (F := F) (G := G)).contDiff.compâ‚‚_contDiffOn hg hf\n\n"}
{"name":"ContDiffAt.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nX : Type u_2\ninstâœÂ¹ : NormedAddCommGroup X\ninstâœ : NormedSpace ğ•œ X\nn : WithTop ENat\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\nx : X\nhg : ContDiffAt ğ•œ n g x\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (fun x => (g x).comp (f x)) x","decl":"theorem ContDiffAt.clm_comp {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F} {x : X}\n    (hg : ContDiffAt ğ•œ n g x) (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (fun x => (g x).comp (f x)) x :=\n  (isBoundedBilinearMap_comp (E := E) (G := G)).contDiff.compâ‚‚_contDiffAt hg hf\n\n"}
{"name":"ContDiffWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ³ : NormedAddCommGroup G\ninstâœÂ² : NormedSpace ğ•œ G\nX : Type u_2\ninstâœÂ¹ : NormedAddCommGroup X\ninstâœ : NormedSpace ğ•œ X\nn : WithTop ENat\ng : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nf : X â†’ ContinuousLinearMap (RingHom.id ğ•œ) E F\ns : Set X\nx : X\nhg : ContDiffWithinAt ğ•œ n g s x\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => (g x).comp (f x)) s x","decl":"theorem ContDiffWithinAt.clm_comp {g : X â†’ F â†’L[ğ•œ] G} {f : X â†’ E â†’L[ğ•œ] F} {s : Set X} {x : X}\n    (hg : ContDiffWithinAt ğ•œ n g s x) (hf : ContDiffWithinAt ğ•œ n f s x) :\n    ContDiffWithinAt ğ•œ n (fun x => (g x).comp (f x)) s x :=\n  (isBoundedBilinearMap_comp (E := E) (G := G)).contDiff.compâ‚‚_contDiffWithinAt hg hf\n\n"}
{"name":"ContDiff.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\ng : E â†’ F\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => (f x) (g x)","decl":"theorem ContDiff.clm_apply {f : E â†’ F â†’L[ğ•œ] G} {g : E â†’ F} (hf : ContDiff ğ•œ n f)\n    (hg : ContDiff ğ•œ n g) : ContDiff ğ•œ n fun x => (f x) (g x) :=\n  isBoundedBilinearMap_apply.contDiff.compâ‚‚ hf hg\n\n"}
{"name":"ContDiffOn.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\ng : E â†’ F\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => (f x) (g x)) s","decl":"theorem ContDiffOn.clm_apply {f : E â†’ F â†’L[ğ•œ] G} {g : E â†’ F} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) : ContDiffOn ğ•œ n (fun x => (f x) (g x)) s :=\n  isBoundedBilinearMap_apply.contDiff.compâ‚‚_contDiffOn hf hg\n\n"}
{"name":"ContDiffAt.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\ng : E â†’ F\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => (f x) (g x)) x","decl":"theorem ContDiffAt.clm_apply {f : E â†’ F â†’L[ğ•œ] G} {g : E â†’ F} (hf : ContDiffAt ğ•œ n f x)\n    (hg : ContDiffAt ğ•œ n g x) : ContDiffAt ğ•œ n (fun x => (f x) (g x)) x :=\n  isBoundedBilinearMap_apply.contDiff.compâ‚‚_contDiffAt hf hg\n\n"}
{"name":"ContDiffWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nx : E\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\ng : E â†’ F\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => (f x) (g x)) s x","decl":"theorem ContDiffWithinAt.clm_apply {f : E â†’ F â†’L[ğ•œ] G} {g : E â†’ F}\n    (hf : ContDiffWithinAt ğ•œ n f s x) (hg : ContDiffWithinAt ğ•œ n g s x) :\n    ContDiffWithinAt ğ•œ n (fun x => (f x) (g x)) s x :=\n  isBoundedBilinearMap_apply.contDiff.compâ‚‚_contDiffWithinAt hf hg\n\n-- Porting note: In Lean 3 we had to give implicit arguments in proofs like the following,\n-- to speed up elaboration. In Lean 4 this isn't necessary anymore.\n"}
{"name":"ContDiff.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F ğ•œ\ng : E â†’ G\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => (f x).smulRight (g x)","decl":"theorem ContDiff.smulRight {f : E â†’ F â†’L[ğ•œ] ğ•œ} {g : E â†’ G} (hf : ContDiff ğ•œ n f)\n    (hg : ContDiff ğ•œ n g) : ContDiff ğ•œ n fun x => (f x).smulRight (g x) :=\n  isBoundedBilinearMap_smulRight.contDiff.compâ‚‚ (g := fun p => p.1.smulRight p.2) hf hg\n\n"}
{"name":"ContDiffOn.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F ğ•œ\ng : E â†’ G\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => (f x).smulRight (g x)) s","decl":"theorem ContDiffOn.smulRight {f : E â†’ F â†’L[ğ•œ] ğ•œ} {g : E â†’ G} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) : ContDiffOn ğ•œ n (fun x => (f x).smulRight (g x)) s :=\n  (isBoundedBilinearMap_smulRight (E := F)).contDiff.compâ‚‚_contDiffOn hf hg\n\n"}
{"name":"ContDiffAt.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nx : E\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F ğ•œ\ng : E â†’ G\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => (f x).smulRight (g x)) x","decl":"theorem ContDiffAt.smulRight {f : E â†’ F â†’L[ğ•œ] ğ•œ} {g : E â†’ G} (hf : ContDiffAt ğ•œ n f x)\n    (hg : ContDiffAt ğ•œ n g x) : ContDiffAt ğ•œ n (fun x => (f x).smulRight (g x)) x :=\n  (isBoundedBilinearMap_smulRight (E := F)).contDiff.compâ‚‚_contDiffAt hf hg\n\n"}
{"name":"ContDiffWithinAt.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nx : E\nn : WithTop ENat\nf : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F ğ•œ\ng : E â†’ G\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => (f x).smulRight (g x)) s x","decl":"theorem ContDiffWithinAt.smulRight {f : E â†’ F â†’L[ğ•œ] ğ•œ} {g : E â†’ G}\n    (hf : ContDiffWithinAt ğ•œ n f s x) (hg : ContDiffWithinAt ğ•œ n g s x) :\n    ContDiffWithinAt ğ•œ n (fun x => (f x).smulRight (g x)) s x :=\n  (isBoundedBilinearMap_smulRight (E := F)).contDiff.compâ‚‚_contDiffWithinAt hf hg\n\n"}
{"name":"iteratedFDerivWithin_clm_apply_const_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\ns : Set E\nhs : UniqueDiffOn ğ•œ s\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : ContDiffOn ğ•œ n c s\ni : Nat\nhi : LE.le (â†‘i) n\nx : E\nhx : Membership.mem s x\nu : F\nm : Fin i â†’ E\nâŠ¢ Eq ((iteratedFDerivWithin ğ•œ i (fun y => (c y) u) s x) m) (((iteratedFDerivWithin ğ•œ i c s x) m) u)","decl":"/-- Application of a `ContinuousLinearMap` to a constant commutes with `iteratedFDerivWithin`. -/\ntheorem iteratedFDerivWithin_clm_apply_const_apply\n    {s : Set E} (hs : UniqueDiffOn ğ•œ s) {c : E â†’ F â†’L[ğ•œ] G}\n    (hc : ContDiffOn ğ•œ n c s) {i : â„•} (hi : i â‰¤ n) {x : E} (hx : x âˆˆ s) {u : F} {m : Fin i â†’ E} :\n    (iteratedFDerivWithin ğ•œ i (fun y â†¦ (c y) u) s x) m = (iteratedFDerivWithin ğ•œ i c s x) m u := by\n  induction i generalizing x with\n  | zero => simp\n  | succ i ih =>\n    replace hi : (i : WithTop â„•âˆ) < n := lt_of_lt_of_le (by norm_cast; simp) hi\n    have h_deriv_apply : DifferentiableOn ğ•œ (iteratedFDerivWithin ğ•œ i (fun y â†¦ (c y) u) s) s :=\n      (hc.clm_apply contDiffOn_const).differentiableOn_iteratedFDerivWithin hi hs\n    have h_deriv : DifferentiableOn ğ•œ (iteratedFDerivWithin ğ•œ i c s) s :=\n      hc.differentiableOn_iteratedFDerivWithin hi hs\n    simp only [iteratedFDerivWithin_succ_apply_left]\n    rw [â† fderivWithin_continuousMultilinear_apply_const_apply (hs x hx) (h_deriv_apply x hx)]\n    rw [fderivWithin_congr' (fun x hx â†¦ ih hi.le hx) hx]\n    rw [fderivWithin_clm_apply (hs x hx) (h_deriv.continuousMultilinear_apply_const _ x hx)\n      (differentiableWithinAt_const u)]\n    rw [fderivWithin_const_apply]\n    simp only [ContinuousLinearMap.flip_apply, ContinuousLinearMap.comp_zero, zero_add]\n    rw [fderivWithin_continuousMultilinear_apply_const_apply (hs x hx) (h_deriv x hx)]\n\n"}
{"name":"iteratedFDeriv_clm_apply_const_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nc : E â†’ ContinuousLinearMap (RingHom.id ğ•œ) F G\nhc : ContDiff ğ•œ n c\ni : Nat\nhi : LE.le (â†‘i) n\nx : E\nu : F\nm : Fin i â†’ E\nâŠ¢ Eq ((iteratedFDeriv ğ•œ i (fun y => (c y) u) x) m) (((iteratedFDeriv ğ•œ i c x) m) u)","decl":"/-- Application of a `ContinuousLinearMap` to a constant commutes with `iteratedFDeriv`. -/\ntheorem iteratedFDeriv_clm_apply_const_apply\n    {c : E â†’ F â†’L[ğ•œ] G} (hc : ContDiff ğ•œ n c)\n    {i : â„•} (hi : i â‰¤ n) {x : E} {u : F} {m : Fin i â†’ E} :\n    (iteratedFDeriv ğ•œ i (fun y â†¦ (c y) u) x) m = (iteratedFDeriv ğ•œ i c x) m u := by\n  simp only [â† iteratedFDerivWithin_univ]\n  exact iteratedFDerivWithin_clm_apply_const_apply uniqueDiffOn_univ hc.contDiffOn hi (mem_univ _)\n\n"}
{"name":"contDiff_prodAssoc","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n â‡‘(Equiv.prodAssoc E F G)","decl":"/-- The natural equivalence `(E Ã— F) Ã— G â‰ƒ E Ã— (F Ã— G)` is smooth.\n\nWarning: if you think you need this lemma, it is likely that you can simplify your proof by\nreformulating the lemma that you're applying next using the tips in\nNote [continuity lemma statement]\n-/\ntheorem contDiff_prodAssoc {n : WithTop â„•âˆ} : ContDiff ğ•œ n <| Equiv.prodAssoc E F G :=\n  (LinearIsometryEquiv.prodAssoc ğ•œ E F G).contDiff\n\n"}
{"name":"contDiff_prodAssoc_symm","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n â‡‘(Equiv.prodAssoc E F G).symm","decl":"/-- The natural equivalence `E Ã— (F Ã— G) â‰ƒ (E Ã— F) Ã— G` is smooth.\n\nWarning: see remarks attached to `contDiff_prodAssoc`\n-/\ntheorem contDiff_prodAssoc_symm {n : WithTop â„•âˆ} : ContDiff ğ•œ n <| (Equiv.prodAssoc E F G).symm :=\n  (LinearIsometryEquiv.prodAssoc ğ•œ E F G).symm.contDiff\n\n"}
{"name":"ContDiffWithinAt.hasFDerivWithinAt_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nn : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nt : Set F\nhn : Ne n â†‘Top.top\nxâ‚€ : E\nhf : ContDiffWithinAt ğ•œ (HAdd.hAdd n 1) (Function.uncurry f) (SProd.sprod (Insert.insert xâ‚€ s) t) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContDiffWithinAt ğ•œ n g s xâ‚€\nhgt : Membership.mem (nhdsWithin (g xâ‚€) (Set.image g s)) t\nâŠ¢ Exists fun v => And (Membership.mem (nhdsWithin xâ‚€ (Insert.insert xâ‚€ s)) v) (And (HasSubset.Subset v (Insert.insert xâ‚€ s)) (Exists fun f' => And (âˆ€ (x : E), Membership.mem v x â†’ HasFDerivWithinAt (f x) (f' x) t (g x)) (ContDiffWithinAt ğ•œ n (fun x => f' x) s xâ‚€)))","decl":"/-- One direction of `contDiffWithinAt_succ_iff_hasFDerivWithinAt`, but where all derivatives are\ntaken within the same set. Version for partial derivatives / functions with parameters. If `f x` is\na `C^n+1` family of functions and `g x` is a `C^n` family of points, then the derivative of `f x` at\n`g x` depends in a `C^n` way on `x`. We give a general version of this fact relative to sets which\nmay not have unique derivatives, in the following form.  If `f : E Ã— F â†’ G` is `C^n+1` at\n`(xâ‚€, g(xâ‚€))` in `(s âˆª {xâ‚€}) Ã— t âŠ† E Ã— F` and `g : E â†’ F` is `C^n` at `xâ‚€` within some set `s âŠ† E`,\nthen there is a function `f' : E â†’ F â†’L[ğ•œ] G` that is `C^n` at `xâ‚€` within `s` such that for all `x`\nsufficiently close to `xâ‚€` within `s âˆª {xâ‚€}` the function `y â†¦ f x y` has derivative `f' x` at `g x`\nwithin `t âŠ† F`.  For convenience, we return an explicit set of `x`'s where this holds that is a\nsubset of `s âˆª {xâ‚€}`.  We need one additional condition, namely that `t` is a neighborhood of\n`g(xâ‚€)` within `g '' s`. -/\ntheorem ContDiffWithinAt.hasFDerivWithinAt_nhds {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F} (hn : n â‰  âˆ)\n    {xâ‚€ : E} (hf : ContDiffWithinAt ğ•œ (n + 1) (uncurry f) (insert xâ‚€ s Ã—Ë¢ t) (xâ‚€, g xâ‚€))\n    (hg : ContDiffWithinAt ğ•œ n g s xâ‚€) (hgt : t âˆˆ ğ“[g '' s] g xâ‚€) :\n    âˆƒ v âˆˆ ğ“[insert xâ‚€ s] xâ‚€, v âŠ† insert xâ‚€ s âˆ§ âˆƒ f' : E â†’ F â†’L[ğ•œ] G,\n      (âˆ€ x âˆˆ v, HasFDerivWithinAt (f x) (f' x) t (g x)) âˆ§\n        ContDiffWithinAt ğ•œ n (fun x => f' x) s xâ‚€ := by\n  have hst : insert xâ‚€ s Ã—Ë¢ t âˆˆ ğ“[(fun x => (x, g x)) '' s] (xâ‚€, g xâ‚€) := by\n    refine nhdsWithin_mono _ ?_ (nhdsWithin_prod self_mem_nhdsWithin hgt)\n    simp_rw [image_subset_iff, mk_preimage_prod, preimage_id', subset_inter_iff, subset_insert,\n      true_and, subset_preimage_image]\n  obtain âŸ¨v, hv, hvs, f_an, f', hvf', hf'âŸ© :=\n    (contDiffWithinAt_succ_iff_hasFDerivWithinAt' hn).mp hf\n  refine\n    âŸ¨(fun z => (z, g z)) â»Â¹' v âˆ© insert xâ‚€ s, ?_, inter_subset_right, fun z =>\n      (f' (z, g z)).comp (ContinuousLinearMap.inr ğ•œ E F), ?_, ?_âŸ©\n  Â· refine inter_mem ?_ self_mem_nhdsWithin\n    have := mem_of_mem_nhdsWithin (mem_insert _ _) hv\n    refine mem_nhdsWithin_insert.mpr âŸ¨this, ?_âŸ©\n    refine (continuousWithinAt_id.prod hg.continuousWithinAt).preimage_mem_nhdsWithin' ?_\n    rw [â† nhdsWithin_le_iff] at hst hv âŠ¢\n    exact (hst.trans <| nhdsWithin_mono _ <| subset_insert _ _).trans hv\n  Â· intro z hz\n    have := hvf' (z, g z) hz.1\n    refine this.comp _ (hasFDerivAt_prod_mk_right _ _).hasFDerivWithinAt ?_\n    exact mapsTo'.mpr (image_prod_mk_subset_prod_right hz.2)\n  Â· exact (hf'.continuousLinearMap_comp <| (ContinuousLinearMap.compL ğ•œ F (E Ã— F) G).flip\n      (ContinuousLinearMap.inr ğ•œ E F)).comp_of_mem_nhdsWithin_image xâ‚€\n      (contDiffWithinAt_id.prod hg) hst\n\n"}
{"name":"ContDiffWithinAt.fderivWithin''","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nxâ‚€ : E\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nt : Set F\nhf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (SProd.sprod (Insert.insert xâ‚€ s) t) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContDiffWithinAt ğ•œ m g s xâ‚€\nht : Filter.Eventually (fun x => UniqueDiffWithinAt ğ•œ t (g x)) (nhdsWithin xâ‚€ (Insert.insert xâ‚€ s))\nhmn : LE.le (HAdd.hAdd m 1) n\nhgt : Membership.mem (nhdsWithin (g xâ‚€) (Set.image g s)) t\nâŠ¢ ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€","decl":"/-- The most general lemma stating that `x â†¦ fderivWithin ğ•œ (f x) t (g x)` is `C^n`\nat a point within a set.\nTo show that `x â†¦ D_yf(x,y)g(x)` (taken within `t`) is `C^m` at `xâ‚€` within `s`, we require that\n* `f` is `C^n` at `(xâ‚€, g(xâ‚€))` within `(s âˆª {xâ‚€}) Ã— t` for `n â‰¥ m+1`.\n* `g` is `C^m` at `xâ‚€` within `s`;\n* Derivatives are unique at `g(x)` within `t` for `x` sufficiently close to `xâ‚€` within `s âˆª {xâ‚€}`;\n* `t` is a neighborhood of `g(xâ‚€)` within `g '' s`; -/\ntheorem ContDiffWithinAt.fderivWithin'' {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F}\n    (hf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (insert xâ‚€ s Ã—Ë¢ t) (xâ‚€, g xâ‚€))\n    (hg : ContDiffWithinAt ğ•œ m g s xâ‚€)\n    (ht : âˆ€á¶  x in ğ“[insert xâ‚€ s] xâ‚€, UniqueDiffWithinAt ğ•œ t (g x)) (hmn : m + 1 â‰¤ n)\n    (hgt : t âˆˆ ğ“[g '' s] g xâ‚€) :\n    ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€ := by\n  have : âˆ€ k : â„•, k â‰¤ m â†’ ContDiffWithinAt ğ•œ k (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€ := by\n    intro k hkm\n    obtain âŸ¨v, hv, -, f', hvf', hf'âŸ© :=\n      (hf.of_le <| (add_le_add_right hkm 1).trans hmn).hasFDerivWithinAt_nhds (by simp)\n        (hg.of_le hkm) hgt\n    refine hf'.congr_of_eventuallyEq_insert ?_\n    filter_upwards [hv, ht]\n    exact fun y hy h2y => (hvf' y hy).fderivWithin h2y\n  match m with\n  | Ï‰ =>\n    obtain rfl : n = Ï‰ := by simpa using hmn\n    obtain âŸ¨v, hv, -, f', hvf', hf'âŸ© := hf.hasFDerivWithinAt_nhds (by simp) hg hgt\n    refine hf'.congr_of_eventuallyEq_insert ?_\n    filter_upwards [hv, ht]\n    exact fun y hy h2y => (hvf' y hy).fderivWithin h2y\n  | âˆ =>\n    rw [contDiffWithinAt_infty]\n    exact fun k â†¦ this k (by exact_mod_cast le_top)\n  | (m : â„•) => exact this _ le_rfl\n\n"}
{"name":"ContDiffWithinAt.fderivWithin'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nxâ‚€ : E\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nt : Set F\nhf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (SProd.sprod (Insert.insert xâ‚€ s) t) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContDiffWithinAt ğ•œ m g s xâ‚€\nht : Filter.Eventually (fun x => UniqueDiffWithinAt ğ•œ t (g x)) (nhdsWithin xâ‚€ (Insert.insert xâ‚€ s))\nhmn : LE.le (HAdd.hAdd m 1) n\nhst : HasSubset.Subset s (Set.preimage g t)\nâŠ¢ ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€","decl":"/-- A special case of `ContDiffWithinAt.fderivWithin''` where we require that `s âŠ† gâ»Â¹(t)`. -/\ntheorem ContDiffWithinAt.fderivWithin' {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F}\n    (hf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (insert xâ‚€ s Ã—Ë¢ t) (xâ‚€, g xâ‚€))\n    (hg : ContDiffWithinAt ğ•œ m g s xâ‚€)\n    (ht : âˆ€á¶  x in ğ“[insert xâ‚€ s] xâ‚€, UniqueDiffWithinAt ğ•œ t (g x)) (hmn : m + 1 â‰¤ n)\n    (hst : s âŠ† g â»Â¹' t) : ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€ :=\n  hf.fderivWithin'' hg ht hmn <| mem_of_superset self_mem_nhdsWithin <| image_subset_iff.mpr hst\n\n"}
{"name":"ContDiffWithinAt.fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nxâ‚€ : E\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nt : Set F\nhf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (SProd.sprod s t) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContDiffWithinAt ğ•œ m g s xâ‚€\nht : UniqueDiffOn ğ•œ t\nhmn : LE.le (HAdd.hAdd m 1) n\nhxâ‚€ : Membership.mem s xâ‚€\nhst : HasSubset.Subset s (Set.preimage g t)\nâŠ¢ ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€","decl":"/-- A special case of `ContDiffWithinAt.fderivWithin'` where we require that `xâ‚€ âˆˆ s` and there\nare unique derivatives everywhere within `t`. -/\nprotected theorem ContDiffWithinAt.fderivWithin {f : E â†’ F â†’ G} {g : E â†’ F} {t : Set F}\n    (hf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (s Ã—Ë¢ t) (xâ‚€, g xâ‚€))\n    (hg : ContDiffWithinAt ğ•œ m g s xâ‚€) (ht : UniqueDiffOn ğ•œ t) (hmn : m + 1 â‰¤ n) (hxâ‚€ : xâ‚€ âˆˆ s)\n    (hst : s âŠ† g â»Â¹' t) : ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x)) s xâ‚€ := by\n  rw [â† insert_eq_self.mpr hxâ‚€] at hf\n  refine hf.fderivWithin' hg ?_ hmn hst\n  rw [insert_eq_self.mpr hxâ‚€]\n  exact eventually_of_mem self_mem_nhdsWithin fun x hx => ht _ (hst hx)\n\n"}
{"name":"ContDiffWithinAt.fderivWithin_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\ns : Set E\nxâ‚€ : E\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng k : E â†’ F\nt : Set F\nhf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (SProd.sprod s t) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContDiffWithinAt ğ•œ m g s xâ‚€\nhk : ContDiffWithinAt ğ•œ m k s xâ‚€\nht : UniqueDiffOn ğ•œ t\nhmn : LE.le (HAdd.hAdd m 1) n\nhxâ‚€ : Membership.mem s xâ‚€\nhst : HasSubset.Subset s (Set.preimage g t)\nâŠ¢ ContDiffWithinAt ğ•œ m (fun x => (fderivWithin ğ•œ (f x) t (g x)) (k x)) s xâ‚€","decl":"/-- `x â†¦ fderivWithin ğ•œ (f x) t (g x) (k x)` is smooth at a point within a set. -/\ntheorem ContDiffWithinAt.fderivWithin_apply {f : E â†’ F â†’ G} {g k : E â†’ F} {t : Set F}\n    (hf : ContDiffWithinAt ğ•œ n (Function.uncurry f) (s Ã—Ë¢ t) (xâ‚€, g xâ‚€))\n    (hg : ContDiffWithinAt ğ•œ m g s xâ‚€) (hk : ContDiffWithinAt ğ•œ m k s xâ‚€) (ht : UniqueDiffOn ğ•œ t)\n    (hmn : m + 1 â‰¤ n) (hxâ‚€ : xâ‚€ âˆˆ s) (hst : s âŠ† g â»Â¹' t) :\n    ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ (f x) t (g x) (k x)) s xâ‚€ :=\n  (contDiff_fst.clm_apply contDiff_snd).contDiffAt.comp_contDiffWithinAt xâ‚€\n    ((hf.fderivWithin hg ht hmn hxâ‚€ hst).prod hk)\n\n"}
{"name":"ContDiffWithinAt.fderivWithin_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nxâ‚€ : E\nm n : WithTop ENat\nhf : ContDiffWithinAt ğ•œ n f s xâ‚€\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m 1) n\nhxâ‚€s : Membership.mem s xâ‚€\nâŠ¢ ContDiffWithinAt ğ•œ m (fderivWithin ğ•œ f s) s xâ‚€","decl":"/-- `fderivWithin ğ•œ f s` is smooth at `xâ‚€` within `s`. -/\ntheorem ContDiffWithinAt.fderivWithin_right (hf : ContDiffWithinAt ğ•œ n f s xâ‚€)\n    (hs : UniqueDiffOn ğ•œ s) (hmn : m + 1 â‰¤ n) (hxâ‚€s : xâ‚€ âˆˆ s) :\n    ContDiffWithinAt ğ•œ m (fderivWithin ğ•œ f s) s xâ‚€ :=\n  ContDiffWithinAt.fderivWithin\n    (ContDiffWithinAt.comp (xâ‚€, xâ‚€) hf contDiffWithinAt_snd <| prod_subset_preimage_snd s s)\n    contDiffWithinAt_id hs hmn hxâ‚€s (by rw [preimage_id'])\n\n"}
{"name":"ContDiffWithinAt.fderivWithin_right_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nm n : WithTop ENat\nf : F â†’ G\nk : F â†’ F\ns : Set F\nxâ‚€ : F\nhf : ContDiffWithinAt ğ•œ n f s xâ‚€\nhk : ContDiffWithinAt ğ•œ m k s xâ‚€\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m 1) n\nhxâ‚€s : Membership.mem s xâ‚€\nâŠ¢ ContDiffWithinAt ğ•œ m (fun x => (fderivWithin ğ•œ f s x) (k x)) s xâ‚€","decl":"/-- `x â†¦ fderivWithin ğ•œ f s x (k x)` is smooth at `xâ‚€` within `s`. -/\ntheorem ContDiffWithinAt.fderivWithin_right_apply\n    {f : F â†’ G} {k : F â†’ F} {s : Set F} {xâ‚€ : F}\n    (hf : ContDiffWithinAt ğ•œ n f s xâ‚€) (hk : ContDiffWithinAt ğ•œ m k s xâ‚€)\n    (hs : UniqueDiffOn ğ•œ s) (hmn : m + 1 â‰¤ n) (hxâ‚€s : xâ‚€ âˆˆ s) :\n    ContDiffWithinAt ğ•œ m (fun x => fderivWithin ğ•œ f s x (k x)) s xâ‚€ :=\n  ContDiffWithinAt.fderivWithin_apply\n    (ContDiffWithinAt.comp (xâ‚€, xâ‚€) hf contDiffWithinAt_snd <| prod_subset_preimage_snd s s)\n    contDiffWithinAt_id hk hs hmn hxâ‚€s (by rw [preimage_id'])\n\n-- TODO: can we make a version of `ContDiffWithinAt.fderivWithin` for iterated derivatives?\n"}
{"name":"ContDiffWithinAt.iteratedFDerivWithin_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nxâ‚€ : E\nm n : WithTop ENat\ni : Nat\nhf : ContDiffWithinAt ğ•œ n f s xâ‚€\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m â†‘i) n\nhxâ‚€s : Membership.mem s xâ‚€\nâŠ¢ ContDiffWithinAt ğ•œ m (iteratedFDerivWithin ğ•œ i f s) s xâ‚€","decl":"theorem ContDiffWithinAt.iteratedFDerivWithin_right {i : â„•} (hf : ContDiffWithinAt ğ•œ n f s xâ‚€)\n    (hs : UniqueDiffOn ğ•œ s) (hmn : m + i â‰¤ n) (hxâ‚€s : xâ‚€ âˆˆ s) :\n    ContDiffWithinAt ğ•œ m (iteratedFDerivWithin ğ•œ i f s) s xâ‚€ := by\n  induction' i with i hi generalizing m\n  Â· simp only [CharP.cast_eq_zero, add_zero] at hmn\n    exact (hf.of_le hmn).continuousLinearMap_comp\n      ((continuousMultilinearCurryFin0 ğ•œ E F).symm : _ â†’L[ğ•œ] E [Ã—0]â†’L[ğ•œ] F)\n  Â· rw [Nat.cast_succ, add_comm _ 1, â† add_assoc] at hmn\n    exact ((hi hmn).fderivWithin_right hs le_rfl hxâ‚€s).continuousLinearMap_comp\n      ((continuousMultilinearCurryLeftEquiv ğ•œ (fun _ : Fin (i+1) â†¦ E) F).symm :\n        _ â†’L[ğ•œ] E [Ã—(i+1)]â†’L[ğ•œ] F)\n\n"}
{"name":"ContDiffWithinAt.iteratedFderivWithin_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nxâ‚€ : E\nm n : WithTop ENat\ni : Nat\nhf : ContDiffWithinAt ğ•œ n f s xâ‚€\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m â†‘i) n\nhxâ‚€s : Membership.mem s xâ‚€\nâŠ¢ ContDiffWithinAt ğ•œ m (iteratedFDerivWithin ğ•œ i f s) s xâ‚€","decl":"@[deprecated (since := \"2025-01-15\")]\nalias ContDiffWithinAt.iteratedFderivWithin_right := ContDiffWithinAt.iteratedFDerivWithin_right\n\n"}
{"name":"ContDiffAt.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nxâ‚€ : E\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nhf : ContDiffAt ğ•œ n (Function.uncurry f) { fst := xâ‚€, snd := g xâ‚€ }\nhg : ContDiffAt ğ•œ m g xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffAt ğ•œ m (fun x => fderiv ğ•œ (f x) (g x)) xâ‚€","decl":"/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is smooth at `xâ‚€`. -/\nprotected theorem ContDiffAt.fderiv {f : E â†’ F â†’ G} {g : E â†’ F}\n    (hf : ContDiffAt ğ•œ n (Function.uncurry f) (xâ‚€, g xâ‚€)) (hg : ContDiffAt ğ•œ m g xâ‚€)\n    (hmn : m + 1 â‰¤ n) : ContDiffAt ğ•œ m (fun x => fderiv ğ•œ (f x) (g x)) xâ‚€ := by\n  simp_rw [â† fderivWithin_univ]\n  refine (ContDiffWithinAt.fderivWithin hf.contDiffWithinAt hg.contDiffWithinAt uniqueDiffOn_univ\n    hmn (mem_univ xâ‚€) ?_).contDiffAt univ_mem\n  rw [preimage_univ]\n\n"}
{"name":"ContDiffAt.fderiv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nm n : WithTop ENat\nhf : ContDiffAt ğ•œ n f xâ‚€\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffAt ğ•œ m (fderiv ğ•œ f) xâ‚€","decl":"/-- `fderiv ğ•œ f` is smooth at `xâ‚€`. -/\ntheorem ContDiffAt.fderiv_right (hf : ContDiffAt ğ•œ n f xâ‚€) (hmn : m + 1 â‰¤ n) :\n    ContDiffAt ğ•œ m (fderiv ğ•œ f) xâ‚€ :=\n  ContDiffAt.fderiv (ContDiffAt.comp (xâ‚€, xâ‚€) hf contDiffAt_snd) contDiffAt_id hmn\n\n"}
{"name":"ContDiffAt.iteratedFDeriv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nxâ‚€ : E\nm n : WithTop ENat\ni : Nat\nhf : ContDiffAt ğ•œ n f xâ‚€\nhmn : LE.le (HAdd.hAdd m â†‘i) n\nâŠ¢ ContDiffAt ğ•œ m (iteratedFDeriv ğ•œ i f) xâ‚€","decl":"theorem ContDiffAt.iteratedFDeriv_right {i : â„•} (hf : ContDiffAt ğ•œ n f xâ‚€)\n    (hmn : m + i â‰¤ n) : ContDiffAt ğ•œ m (iteratedFDeriv ğ•œ i f) xâ‚€ := by\n  rw [â† iteratedFDerivWithin_univ, â† contDiffWithinAt_univ] at *\n  exact hf.iteratedFDerivWithin_right uniqueDiffOn_univ hmn trivial\n\n"}
{"name":"ContDiff.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nhf : ContDiff ğ•œ m (Function.uncurry f)\nhg : ContDiff ğ•œ n g\nhnm : LE.le (HAdd.hAdd n 1) m\nâŠ¢ ContDiff ğ•œ n fun x => fderiv ğ•œ (f x) (g x)","decl":"/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is smooth. -/\nprotected theorem ContDiff.fderiv {f : E â†’ F â†’ G} {g : E â†’ F}\n    (hf : ContDiff ğ•œ m <| Function.uncurry f) (hg : ContDiff ğ•œ n g) (hnm : n + 1 â‰¤ m) :\n    ContDiff ğ•œ n fun x => fderiv ğ•œ (f x) (g x) :=\n  contDiff_iff_contDiffAt.mpr fun _ => hf.contDiffAt.fderiv hg.contDiffAt hnm\n\n"}
{"name":"ContDiff.fderiv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nm n : WithTop ENat\nhf : ContDiff ğ•œ n f\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiff ğ•œ m (fderiv ğ•œ f)","decl":"/-- `fderiv ğ•œ f` is smooth. -/\ntheorem ContDiff.fderiv_right (hf : ContDiff ğ•œ n f) (hmn : m + 1 â‰¤ n) :\n    ContDiff ğ•œ m (fderiv ğ•œ f) :=\n  contDiff_iff_contDiffAt.mpr fun _x => hf.contDiffAt.fderiv_right hmn\n\n"}
{"name":"ContDiff.iteratedFDeriv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : E â†’ F\nm n : WithTop ENat\ni : Nat\nhf : ContDiff ğ•œ n f\nhmn : LE.le (HAdd.hAdd m â†‘i) n\nâŠ¢ ContDiff ğ•œ m (iteratedFDeriv ğ•œ i f)","decl":"theorem ContDiff.iteratedFDeriv_right {i : â„•} (hf : ContDiff ğ•œ n f)\n    (hmn : m + i â‰¤ n) : ContDiff ğ•œ m (iteratedFDeriv ğ•œ i f) :=\n  contDiff_iff_contDiffAt.mpr fun _x => hf.contDiffAt.iteratedFDeriv_right hmn\n\n"}
{"name":"Continuous.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nn : WithTop ENat\nf : E â†’ F â†’ G\ng : E â†’ F\nhf : ContDiff ğ•œ n (Function.uncurry f)\nhg : Continuous g\nhn : LE.le 1 n\nâŠ¢ Continuous fun x => fderiv ğ•œ (f x) (g x)","decl":"/-- `x â†¦ fderiv ğ•œ (f x) (g x)` is continuous. -/\ntheorem Continuous.fderiv {f : E â†’ F â†’ G} {g : E â†’ F}\n    (hf : ContDiff ğ•œ n <| Function.uncurry f) (hg : Continuous g) (hn : 1 â‰¤ n) :\n    Continuous fun x => fderiv ğ•œ (f x) (g x) :=\n  (hf.fderiv (contDiff_zero.mpr hg) hn).continuous\n\n"}
{"name":"ContDiff.fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâµ : NormedAddCommGroup E\ninstâœâ´ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ³ : NormedAddCommGroup F\ninstâœÂ² : NormedSpace ğ•œ F\nG : Type uG\ninstâœÂ¹ : NormedAddCommGroup G\ninstâœ : NormedSpace ğ•œ G\nm n : WithTop ENat\nf : E â†’ F â†’ G\ng k : E â†’ F\nhf : ContDiff ğ•œ m (Function.uncurry f)\nhg : ContDiff ğ•œ n g\nhk : ContDiff ğ•œ n k\nhnm : LE.le (HAdd.hAdd n 1) m\nâŠ¢ ContDiff ğ•œ n fun x => (fderiv ğ•œ (f x) (g x)) (k x)","decl":"/-- `x â†¦ fderiv ğ•œ (f x) (g x) (k x)` is smooth. -/\ntheorem ContDiff.fderiv_apply {f : E â†’ F â†’ G} {g k : E â†’ F}\n    (hf : ContDiff ğ•œ m <| Function.uncurry f) (hg : ContDiff ğ•œ n g) (hk : ContDiff ğ•œ n k)\n    (hnm : n + 1 â‰¤ m) : ContDiff ğ•œ n fun x => fderiv ğ•œ (f x) (g x) (k x) :=\n  (hf.fderiv hg hnm).clm_apply hk\n\n"}
{"name":"contDiffOn_fderivWithin_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nm n : WithTop ENat\ns : Set E\nf : E â†’ F\nhf : ContDiffOn ğ•œ n f s\nhs : UniqueDiffOn ğ•œ s\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffOn ğ•œ m (fun p => (fderivWithin ğ•œ f s p.1) p.2) (SProd.sprod s Set.univ)","decl":"/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem contDiffOn_fderivWithin_apply {s : Set E} {f : E â†’ F} (hf : ContDiffOn ğ•œ n f s)\n    (hs : UniqueDiffOn ğ•œ s) (hmn : m + 1 â‰¤ n) :\n    ContDiffOn ğ•œ m (fun p : E Ã— E => (fderivWithin ğ•œ f s p.1 : E â†’L[ğ•œ] F) p.2) (s Ã—Ë¢ univ) :=\n  ((hf.fderivWithin hs hmn).comp contDiffOn_fst (prod_subset_preimage_fst _ _)).clm_apply\n    contDiffOn_snd\n\n"}
{"name":"ContDiffOn.continuousOn_fderivWithin_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\nhs : UniqueDiffOn ğ•œ s\nhn : LE.le 1 n\nâŠ¢ ContinuousOn (fun p => (fderivWithin ğ•œ f s p.1) p.2) (SProd.sprod s Set.univ)","decl":"/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem ContDiffOn.continuousOn_fderivWithin_apply (hf : ContDiffOn ğ•œ n f s) (hs : UniqueDiffOn ğ•œ s)\n    (hn : 1 â‰¤ n) :\n    ContinuousOn (fun p : E Ã— E => (fderivWithin ğ•œ f s p.1 : E â†’ F) p.2) (s Ã—Ë¢ univ) :=\n  (contDiffOn_fderivWithin_apply (m := 0) hf hs hn).continuousOn\n\n"}
{"name":"ContDiff.contDiff_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nm n : WithTop ENat\nf : E â†’ F\nhf : ContDiff ğ•œ n f\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiff ğ•œ m fun p => (fderiv ğ•œ f p.1) p.2","decl":"/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem ContDiff.contDiff_fderiv_apply {f : E â†’ F} (hf : ContDiff ğ•œ n f) (hmn : m + 1 â‰¤ n) :\n    ContDiff ğ•œ m fun p : E Ã— E => (fderiv ğ•œ f p.1 : E â†’L[ğ•œ] F) p.2 := by\n  rw [â† contDiffOn_univ] at hf âŠ¢\n  rw [â† fderivWithin_univ, â† univ_prod_univ]\n  exact contDiffOn_fderivWithin_apply hf uniqueDiffOn_univ hmn\n\n"}
{"name":"hasFTaylorSeriesUpToOn_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÏ† : (i : Î¹) â†’ E â†’ F' i\np' : (i : Î¹) â†’ E â†’ FormalMultilinearSeries ğ•œ E (F' i)\nn : WithTop ENat\nâŠ¢ Iff (HasFTaylorSeriesUpToOn n (fun x i => Ï† i x) (fun x m => ContinuousMultilinearMap.pi fun i => p' i x m) s) (âˆ€ (i : Î¹), HasFTaylorSeriesUpToOn n (Ï† i) (p' i) s)","decl":"theorem hasFTaylorSeriesUpToOn_pi {n : WithTop â„•âˆ} :\n    HasFTaylorSeriesUpToOn n (fun x i => Ï† i x)\n        (fun x m => ContinuousMultilinearMap.pi fun i => p' i x m) s â†”\n      âˆ€ i, HasFTaylorSeriesUpToOn n (Ï† i) (p' i) s := by\n  set pr := @ContinuousLinearMap.proj ğ•œ _ Î¹ F' _ _ _\n  set L : âˆ€ m : â„•, (âˆ€ i, E[Ã—m]â†’L[ğ•œ] F' i) â‰ƒâ‚—áµ¢[ğ•œ] E[Ã—m]â†’L[ğ•œ] âˆ€ i, F' i := fun m =>\n    ContinuousMultilinearMap.piâ‚—áµ¢ _ _\n  refine âŸ¨fun h i => ?_, fun h => âŸ¨fun x hx => ?_, ?_, ?_âŸ©âŸ©\n  Â· exact h.continuousLinearMap_comp (pr i)\n  Â· ext1 i\n    exact (h i).zero_eq x hx\n  Â· intro m hm x hx\n    exact (L m).hasFDerivAt.comp_hasFDerivWithinAt x <|\n      hasFDerivWithinAt_pi.2 fun i => (h i).fderivWithin m hm x hx\n  Â· intro m hm\n    exact (L m).continuous.comp_continuousOn <| continuousOn_pi.2 fun i => (h i).cont m hm\n\n"}
{"name":"hasFTaylorSeriesUpToOn_pi'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nP' : E â†’ FormalMultilinearSeries ğ•œ E ((i : Î¹) â†’ F' i)\nn : WithTop ENat\nâŠ¢ Iff (HasFTaylorSeriesUpToOn n Î¦ P' s) (âˆ€ (i : Î¹), HasFTaylorSeriesUpToOn n (fun x => Î¦ x i) (fun x m => (ContinuousLinearMap.proj i).compContinuousMultilinearMap (P' x m)) s)","decl":"@[simp]\ntheorem hasFTaylorSeriesUpToOn_pi' {n : WithTop â„•âˆ} :\n    HasFTaylorSeriesUpToOn n Î¦ P' s â†”\n      âˆ€ i, HasFTaylorSeriesUpToOn n (fun x => Î¦ x i)\n        (fun x m => (@ContinuousLinearMap.proj ğ•œ _ Î¹ F' _ _ _ i).compContinuousMultilinearMap\n          (P' x m)) s := by\n  convert hasFTaylorSeriesUpToOn_pi (ğ•œ := ğ•œ) (Ï† := fun i x â†¦ Î¦ x i); ext; rfl\n\n"}
{"name":"contDiffWithinAt_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nx : E\nn : WithTop ENat\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (ContDiffWithinAt ğ•œ n Î¦ s x) (âˆ€ (i : Î¹), ContDiffWithinAt ğ•œ n (fun x => Î¦ x i) s x)","decl":"theorem contDiffWithinAt_pi :\n    ContDiffWithinAt ğ•œ n Î¦ s x â†” âˆ€ i, ContDiffWithinAt ğ•œ n (fun x => Î¦ x i) s x := by\n  set pr := @ContinuousLinearMap.proj ğ•œ _ Î¹ F' _ _ _\n  refine âŸ¨fun h i => h.continuousLinearMap_comp (pr i), fun h â†¦ ?_âŸ©\n  match n with\n  | Ï‰ =>\n    choose u hux p hp h'p using h\n    refine âŸ¨â‹‚ i, u i, Filter.iInter_mem.2 hux, _,\n      hasFTaylorSeriesUpToOn_pi.2 fun i => (hp i).mono <| iInter_subset _ _, fun m â†¦ ?_âŸ©\n    set L : (âˆ€ i, E[Ã—m]â†’L[ğ•œ] F' i) â‰ƒâ‚—áµ¢[ğ•œ] E[Ã—m]â†’L[ğ•œ] âˆ€ i, F' i :=\n      ContinuousMultilinearMap.piâ‚—áµ¢ _ _\n    change AnalyticOn ğ•œ (fun x â†¦ L (fun i â†¦ p i x m)) (â‹‚ i, u i)\n    apply (L.analyticOnNhd univ).comp_analyticOn ?_ (mapsTo_univ _ _)\n    exact AnalyticOn.pi (fun i â†¦ (h'p i m).mono (iInter_subset _ _))\n  | (n : â„•âˆ) =>\n    intro m hm\n    choose u hux p hp using fun i => h i m hm\n    exact âŸ¨â‹‚ i, u i, Filter.iInter_mem.2 hux, _,\n      hasFTaylorSeriesUpToOn_pi.2 fun i => (hp i).mono <| iInter_subset _ _âŸ©\n\n"}
{"name":"contDiffOn_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\ns : Set E\nn : WithTop ENat\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (ContDiffOn ğ•œ n Î¦ s) (âˆ€ (i : Î¹), ContDiffOn ğ•œ n (fun x => Î¦ x i) s)","decl":"theorem contDiffOn_pi : ContDiffOn ğ•œ n Î¦ s â†” âˆ€ i, ContDiffOn ğ•œ n (fun x => Î¦ x i) s :=\n  âŸ¨fun h _ x hx => contDiffWithinAt_pi.1 (h x hx) _, fun h x hx =>\n    contDiffWithinAt_pi.2 fun i => h i x hxâŸ©\n\n"}
{"name":"contDiffAt_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (ContDiffAt ğ•œ n Î¦ x) (âˆ€ (i : Î¹), ContDiffAt ğ•œ n (fun x => Î¦ x i) x)","decl":"theorem contDiffAt_pi : ContDiffAt ğ•œ n Î¦ x â†” âˆ€ i, ContDiffAt ğ•œ n (fun x => Î¦ x i) x :=\n  contDiffWithinAt_pi\n\n"}
{"name":"contDiff_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nn : WithTop ENat\nÎ¹ : Type u_3\ninstâœÂ² : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ¹ : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\nÎ¦ : E â†’ (i : Î¹) â†’ F' i\nâŠ¢ Iff (ContDiff ğ•œ n Î¦) (âˆ€ (i : Î¹), ContDiff ğ•œ n fun x => Î¦ x i)","decl":"theorem contDiff_pi : ContDiff ğ•œ n Î¦ â†” âˆ€ i, ContDiff ğ•œ n fun x => Î¦ x i := by\n  simp only [â† contDiffOn_univ, contDiffOn_pi]\n\n"}
{"name":"contDiff_update","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_3\ninstâœÂ³ : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ninstâœ : DecidableEq Î¹\nk : WithTop ENat\nx : (i : Î¹) â†’ F' i\ni : Î¹\nâŠ¢ ContDiff ğ•œ k (Function.update x i)","decl":"theorem contDiff_update [DecidableEq Î¹] (k : WithTop â„•âˆ) (x : âˆ€ i, F' i) (i : Î¹) :\n    ContDiff ğ•œ k (update x i) := by\n  rw [contDiff_pi]\n  intro j\n  dsimp [Function.update]\n  split_ifs with h\n  Â· subst h\n    exact contDiff_id\n  Â· exact contDiff_const\n\n"}
{"name":"contDiff_single","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nÎ¹ : Type u_3\ninstâœÂ³ : Fintype Î¹\nF' : Î¹ â†’ Type u_5\ninstâœÂ² : (i : Î¹) â†’ NormedAddCommGroup (F' i)\ninstâœÂ¹ : (i : Î¹) â†’ NormedSpace ğ•œ (F' i)\ninstâœ : DecidableEq Î¹\nk : WithTop ENat\ni : Î¹\nâŠ¢ ContDiff ğ•œ k (Pi.single i)","decl":"variable (F') in\ntheorem contDiff_single [DecidableEq Î¹] (k : WithTop â„•âˆ) (i : Î¹) :\n    ContDiff ğ•œ k (Pi.single i : F' i â†’ âˆ€ i, F' i) :=\n  contDiff_update k 0 i\n\n"}
{"name":"contDiff_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ² : NormedAddCommGroup E\ninstâœÂ¹ : NormedSpace ğ•œ E\nn : WithTop ENat\nÎ¹ : Type u_3\ninstâœ : Fintype Î¹\ni : Î¹\nâŠ¢ ContDiff ğ•œ n fun f => f i","decl":"theorem contDiff_apply (i : Î¹) : ContDiff ğ•œ n fun f : Î¹ â†’ E => f i :=\n  contDiff_pi.mp contDiff_id i\n\n"}
{"name":"contDiff_apply_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nÎ¹ : Type u_3\nÎ¹' : Type u_4\ninstâœÂ¹ : Fintype Î¹\ninstâœ : Fintype Î¹'\ni : Î¹\nj : Î¹'\nâŠ¢ ContDiff ğ•œ n fun f => f i j","decl":"theorem contDiff_apply_apply (i : Î¹) (j : Î¹') : ContDiff ğ•œ n fun f : Î¹ â†’ Î¹' â†’ E => f i j :=\n  contDiff_pi.mp (contDiff_apply ğ•œ (Î¹' â†’ E) i) j\n\n"}
{"name":"HasFTaylorSeriesUpToOn.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\np : E â†’ FormalMultilinearSeries ğ•œ E F\nn : WithTop ENat\nq : E â†’ FormalMultilinearSeries ğ•œ E F\ng : E â†’ F\nhf : HasFTaylorSeriesUpToOn n f p s\nhg : HasFTaylorSeriesUpToOn n g q s\nâŠ¢ HasFTaylorSeriesUpToOn n (HAdd.hAdd f g) (HAdd.hAdd p q) s","decl":"theorem HasFTaylorSeriesUpToOn.add {n : WithTop â„•âˆ} {q g} (hf : HasFTaylorSeriesUpToOn n f p s)\n    (hg : HasFTaylorSeriesUpToOn n g q s) : HasFTaylorSeriesUpToOn n (f + g) (p + q) s := by\n  exact HasFTaylorSeriesUpToOn.continuousLinearMap_comp\n    (ContinuousLinearMap.fst ğ•œ F F + .snd ğ•œ F F) (hf.prod hg)\n\n-- The sum is smooth.\n"}
{"name":"contDiff_add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n fun p => HAdd.hAdd p.1 p.2","decl":"theorem contDiff_add : ContDiff ğ•œ n fun p : F Ã— F => p.1 + p.2 :=\n  (IsBoundedLinearMap.fst.add IsBoundedLinearMap.snd).contDiff\n\n"}
{"name":"ContDiffWithinAt.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\ns : Set E\nf g : E â†’ F\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => HAdd.hAdd (f x) (g x)) s x","decl":"/-- The sum of two `C^n` functions within a set at a point is `C^n` within this set\nat this point. -/\ntheorem ContDiffWithinAt.add {s : Set E} {f g : E â†’ F} (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hg : ContDiffWithinAt ğ•œ n g s x) : ContDiffWithinAt ğ•œ n (fun x => f x + g x) s x :=\n  contDiff_add.contDiffWithinAt.comp x (hf.prod hg) subset_preimage_univ\n\n"}
{"name":"ContDiffAt.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\nf g : E â†’ F\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => HAdd.hAdd (f x) (g x)) x","decl":"/-- The sum of two `C^n` functions at a point is `C^n` at this point. -/\ntheorem ContDiffAt.add {f g : E â†’ F} (hf : ContDiffAt ğ•œ n f x) (hg : ContDiffAt ğ•œ n g x) :\n    ContDiffAt ğ•œ n (fun x => f x + g x) x := by\n  rw [â† contDiffWithinAt_univ] at *; exact hf.add hg\n\n"}
{"name":"ContDiff.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf g : E â†’ F\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The sum of two `C^n`functions is `C^n`. -/\ntheorem ContDiff.add {f g : E â†’ F} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g) :\n    ContDiff ğ•œ n fun x => f x + g x :=\n  contDiff_add.comp (hf.prod hg)\n\n"}
{"name":"ContDiffOn.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set E\nf g : E â†’ F\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The sum of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.add {s : Set E} {f g : E â†’ F} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) : ContDiffOn ğ•œ n (fun x => f x + g x) s := fun x hx =>\n  (hf x hx).add (hg x hx)\n\n"}
{"name":"iteratedFDerivWithin_add_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nx : E\ni : Nat\nf g : E â†’ F\nhf : ContDiffOn ğ•œ (â†‘i) f s\nhg : ContDiffOn ğ•œ (â†‘i) g s\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (HAdd.hAdd f g) s x) (HAdd.hAdd (iteratedFDerivWithin ğ•œ i f s x) (iteratedFDerivWithin ğ•œ i g s x))","decl":"/-- The iterated derivative of the sum of two functions is the sum of the iterated derivatives.\nSee also `iteratedFDerivWithin_add_apply'`, which uses the spelling `(fun x â†¦ f x + g x)`\ninstead of `f + g`. -/\ntheorem iteratedFDerivWithin_add_apply {f g : E â†’ F} (hf : ContDiffOn ğ•œ i f s)\n    (hg : ContDiffOn ğ•œ i g s) (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ i (f + g) s x =\n      iteratedFDerivWithin ğ•œ i f s x + iteratedFDerivWithin ğ•œ i g s x :=\n  Eq.symm <| ((hf.ftaylorSeriesWithin hu).add\n    (hg.ftaylorSeriesWithin hu)).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl hu hx\n\n"}
{"name":"iteratedFDerivWithin_add_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nx : E\ni : Nat\nf g : E â†’ F\nhf : ContDiffOn ğ•œ (â†‘i) f s\nhg : ContDiffOn ğ•œ (â†‘i) g s\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (fun x => HAdd.hAdd (f x) (g x)) s x) (HAdd.hAdd (iteratedFDerivWithin ğ•œ i f s x) (iteratedFDerivWithin ğ•œ i g s x))","decl":"/-- The iterated derivative of the sum of two functions is the sum of the iterated derivatives.\nThis is the same as `iteratedFDerivWithin_add_apply`, but using the spelling `(fun x â†¦ f x + g x)`\ninstead of `f + g`, which can be handy for some rewrites.\nTODO: use one form consistently. -/\ntheorem iteratedFDerivWithin_add_apply' {f g : E â†’ F} (hf : ContDiffOn ğ•œ i f s)\n    (hg : ContDiffOn ğ•œ i g s) (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ i (fun x => f x + g x) s x =\n      iteratedFDerivWithin ğ•œ i f s x + iteratedFDerivWithin ğ•œ i g s x :=\n  iteratedFDerivWithin_add_apply hf hg hu hx\n\n"}
{"name":"iteratedFDeriv_add_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ni : Nat\nf g : E â†’ F\nhf : ContDiff ğ•œ (â†‘i) f\nhg : ContDiff ğ•œ (â†‘i) g\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (HAdd.hAdd f g) x) (HAdd.hAdd (iteratedFDeriv ğ•œ i f x) (iteratedFDeriv ğ•œ i g x))","decl":"theorem iteratedFDeriv_add_apply {i : â„•} {f g : E â†’ F} (hf : ContDiff ğ•œ i f) (hg : ContDiff ğ•œ i g) :\n    iteratedFDeriv ğ•œ i (f + g) x = iteratedFDeriv ğ•œ i f x + iteratedFDeriv ğ•œ i g x := by\n  simp_rw [â† contDiffOn_univ, â† iteratedFDerivWithin_univ] at hf hg âŠ¢\n  exact iteratedFDerivWithin_add_apply hf hg uniqueDiffOn_univ (Set.mem_univ _)\n\n"}
{"name":"iteratedFDeriv_add_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ni : Nat\nf g : E â†’ F\nhf : ContDiff ğ•œ (â†‘i) f\nhg : ContDiff ğ•œ (â†‘i) g\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (fun x => HAdd.hAdd (f x) (g x)) x) (HAdd.hAdd (iteratedFDeriv ğ•œ i f x) (iteratedFDeriv ğ•œ i g x))","decl":"theorem iteratedFDeriv_add_apply' {i : â„•} {f g : E â†’ F} (hf : ContDiff ğ•œ i f)\n    (hg : ContDiff ğ•œ i g) :\n    iteratedFDeriv ğ•œ i (fun x => f x + g x) x = iteratedFDeriv ğ•œ i f x + iteratedFDeriv ğ•œ i g x :=\n  iteratedFDeriv_add_apply hf hg\n\n"}
{"name":"contDiff_neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n fun p => Neg.neg p","decl":"theorem contDiff_neg : ContDiff ğ•œ n fun p : F => -p :=\n  IsBoundedLinearMap.id.neg.contDiff\n\n"}
{"name":"ContDiffWithinAt.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\ns : Set E\nf : E â†’ F\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => Neg.neg (f x)) s x","decl":"/-- The negative of a `C^n` function within a domain at a point is `C^n` within this domain at\nthis point. -/\ntheorem ContDiffWithinAt.neg {s : Set E} {f : E â†’ F} (hf : ContDiffWithinAt ğ•œ n f s x) :\n    ContDiffWithinAt ğ•œ n (fun x => -f x) s x :=\n  contDiff_neg.contDiffWithinAt.comp x hf subset_preimage_univ\n\n"}
{"name":"ContDiffAt.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\nf : E â†’ F\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (fun x => Neg.neg (f x)) x","decl":"/-- The negative of a `C^n` function at a point is `C^n` at this point. -/\ntheorem ContDiffAt.neg {f : E â†’ F} (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (fun x => -f x) x := by rw [â† contDiffWithinAt_univ] at *; exact hf.neg\n\n"}
{"name":"ContDiff.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ F\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun x => Neg.neg (f x)","decl":"/-- The negative of a `C^n`function is `C^n`. -/\ntheorem ContDiff.neg {f : E â†’ F} (hf : ContDiff ğ•œ n f) : ContDiff ğ•œ n fun x => -f x :=\n  contDiff_neg.comp hf\n\n"}
{"name":"ContDiffOn.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set E\nf : E â†’ F\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (fun x => Neg.neg (f x)) s","decl":"/-- The negative of a `C^n` function on a domain is `C^n`. -/\ntheorem ContDiffOn.neg {s : Set E} {f : E â†’ F} (hf : ContDiffOn ğ•œ n f s) :\n    ContDiffOn ğ•œ n (fun x => -f x) s := fun x hx => (hf x hx).neg\n\n"}
{"name":"iteratedFDerivWithin_neg_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nx : E\ni : Nat\nf : E â†’ F\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (Neg.neg f) s x) (Neg.neg (iteratedFDerivWithin ğ•œ i f s x))","decl":"theorem iteratedFDerivWithin_neg_apply {f : E â†’ F} (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ i (-f) s x = -iteratedFDerivWithin ğ•œ i f s x := by\n  induction' i with i hi generalizing x\n  Â· ext; simp\n  Â· ext h\n    calc\n      iteratedFDerivWithin ğ•œ (i + 1) (-f) s x h =\n          fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ i (-f) s) s x (h 0) (Fin.tail h) :=\n        rfl\n      _ = fderivWithin ğ•œ (-iteratedFDerivWithin ğ•œ i f s) s x (h 0) (Fin.tail h) := by\n        rw [fderivWithin_congr' (@hi) hx]; rfl\n      _ = -(fderivWithin ğ•œ (iteratedFDerivWithin ğ•œ i f s) s) x (h 0) (Fin.tail h) := by\n        rw [Pi.neg_def, fderivWithin_neg (hu x hx)]; rfl\n      _ = -(iteratedFDerivWithin ğ•œ (i + 1) f s) x h := rfl\n\n"}
{"name":"iteratedFDeriv_neg_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\ni : Nat\nf : E â†’ F\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (Neg.neg f) x) (Neg.neg (iteratedFDeriv ğ•œ i f x))","decl":"theorem iteratedFDeriv_neg_apply {i : â„•} {f : E â†’ F} :\n    iteratedFDeriv ğ•œ i (-f) x = -iteratedFDeriv ğ•œ i f x := by\n  simp_rw [â† iteratedFDerivWithin_univ]\n  exact iteratedFDerivWithin_neg_apply uniqueDiffOn_univ (Set.mem_univ _)\n\n"}
{"name":"ContDiffWithinAt.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\ns : Set E\nf g : E â†’ F\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => HSub.hSub (f x) (g x)) s x","decl":"/-- The difference of two `C^n` functions within a set at a point is `C^n` within this set\nat this point. -/\ntheorem ContDiffWithinAt.sub {s : Set E} {f g : E â†’ F} (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hg : ContDiffWithinAt ğ•œ n g s x) : ContDiffWithinAt ğ•œ n (fun x => f x - g x) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiffAt.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\nf g : E â†’ F\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => HSub.hSub (f x) (g x)) x","decl":"/-- The difference of two `C^n` functions at a point is `C^n` at this point. -/\ntheorem ContDiffAt.sub {f g : E â†’ F} (hf : ContDiffAt ğ•œ n f x) (hg : ContDiffAt ğ•œ n g x) :\n    ContDiffAt ğ•œ n (fun x => f x - g x) x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiffOn.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set E\nf g : E â†’ F\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => HSub.hSub (f x) (g x)) s","decl":"/-- The difference of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.sub {s : Set E} {f g : E â†’ F} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) : ContDiffOn ğ•œ n (fun x => f x - g x) s := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiff.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf g : E â†’ F\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => HSub.hSub (f x) (g x)","decl":"/-- The difference of two `C^n` functions is `C^n`. -/\ntheorem ContDiff.sub {f g : E â†’ F} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g) :\n    ContDiff ğ•œ n fun x => f x - g x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiffWithinAt.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nÎ¹ : Type u_3\nf : Î¹ â†’ E â†’ F\ns : Finset Î¹\nt : Set E\nx : E\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ ContDiffWithinAt ğ•œ n (fun x => f i x) t x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => s.sum fun i => f i x) t x","decl":"theorem ContDiffWithinAt.sum {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : Finset Î¹} {t : Set E} {x : E}\n    (h : âˆ€ i âˆˆ s, ContDiffWithinAt ğ•œ n (fun x => f i x) t x) :\n    ContDiffWithinAt ğ•œ n (fun x => âˆ‘ i âˆˆ s, f i x) t x := by\n  classical\n    induction' s using Finset.induction_on with i s is IH\n    Â· simp [contDiffWithinAt_const]\n    Â· simp only [is, Finset.sum_insert, not_false_iff]\n      exact (h _ (Finset.mem_insert_self i s)).add\n        (IH fun j hj => h _ (Finset.mem_insert_of_mem hj))\n\n"}
{"name":"ContDiffAt.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nÎ¹ : Type u_3\nf : Î¹ â†’ E â†’ F\ns : Finset Î¹\nx : E\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ ContDiffAt ğ•œ n (fun x => f i x) x\nâŠ¢ ContDiffAt ğ•œ n (fun x => s.sum fun i => f i x) x","decl":"theorem ContDiffAt.sum {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : Finset Î¹} {x : E}\n    (h : âˆ€ i âˆˆ s, ContDiffAt ğ•œ n (fun x => f i x) x) :\n    ContDiffAt ğ•œ n (fun x => âˆ‘ i âˆˆ s, f i x) x := by\n  rw [â† contDiffWithinAt_univ] at *; exact ContDiffWithinAt.sum h\n\n"}
{"name":"ContDiffOn.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nÎ¹ : Type u_3\nf : Î¹ â†’ E â†’ F\ns : Finset Î¹\nt : Set E\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ ContDiffOn ğ•œ n (fun x => f i x) t\nâŠ¢ ContDiffOn ğ•œ n (fun x => s.sum fun i => f i x) t","decl":"theorem ContDiffOn.sum {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : Finset Î¹} {t : Set E}\n    (h : âˆ€ i âˆˆ s, ContDiffOn ğ•œ n (fun x => f i x) t) :\n    ContDiffOn ğ•œ n (fun x => âˆ‘ i âˆˆ s, f i x) t := fun x hx =>\n  ContDiffWithinAt.sum fun i hi => h i hi x hx\n\n"}
{"name":"ContDiff.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nÎ¹ : Type u_3\nf : Î¹ â†’ E â†’ F\ns : Finset Î¹\nh : âˆ€ (i : Î¹), Membership.mem s i â†’ ContDiff ğ•œ n fun x => f i x\nâŠ¢ ContDiff ğ•œ n fun x => s.sum fun i => f i x","decl":"theorem ContDiff.sum {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {s : Finset Î¹}\n    (h : âˆ€ i âˆˆ s, ContDiff ğ•œ n fun x => f i x) : ContDiff ğ•œ n fun x => âˆ‘ i âˆˆ s, f i x := by\n  simp only [â† contDiffOn_univ] at *; exact ContDiffOn.sum h\n\n"}
{"name":"iteratedFDerivWithin_sum_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\ns : Set E\nÎ¹ : Type u_3\nf : Î¹ â†’ E â†’ F\nu : Finset Î¹\ni : Nat\nx : E\nhs : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nh : âˆ€ (j : Î¹), Membership.mem u j â†’ ContDiffOn ğ•œ (â†‘i) (f j) s\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (fun x => u.sum fun j => f j x) s x) (u.sum fun j => iteratedFDerivWithin ğ•œ i (f j) s x)","decl":"theorem iteratedFDerivWithin_sum_apply {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {u : Finset Î¹} {i : â„•} {x : E}\n    (hs : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) (h : âˆ€ j âˆˆ u, ContDiffOn ğ•œ i (f j) s) :\n    iteratedFDerivWithin ğ•œ i (âˆ‘ j âˆˆ u, f j Â·) s x =\n      âˆ‘ j âˆˆ u, iteratedFDerivWithin ğ•œ i (f j) s x := by\n  induction u using Finset.cons_induction with\n  | empty => ext; simp [hs, hx]\n  | cons a u ha IH =>\n    simp only [Finset.mem_cons, forall_eq_or_imp] at h\n    simp only [Finset.sum_cons]\n    rw [iteratedFDerivWithin_add_apply' h.1 (ContDiffOn.sum h.2) hs hx, IH h.2]\n\n"}
{"name":"iteratedFDeriv_sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nÎ¹ : Type u_3\nf : Î¹ â†’ E â†’ F\nu : Finset Î¹\ni : Nat\nh : âˆ€ (j : Î¹), Membership.mem u j â†’ ContDiff ğ•œ (â†‘i) (f j)\nâŠ¢ Eq (iteratedFDeriv ğ•œ i fun x => u.sum fun j => f j x) (u.sum fun j => iteratedFDeriv ğ•œ i (f j))","decl":"theorem iteratedFDeriv_sum {Î¹ : Type*} {f : Î¹ â†’ E â†’ F} {u : Finset Î¹} {i : â„•}\n    (h : âˆ€ j âˆˆ u, ContDiff ğ•œ i (f j)) :\n    iteratedFDeriv ğ•œ i (âˆ‘ j âˆˆ u, f j Â·) = âˆ‘ j âˆˆ u, iteratedFDeriv ğ•œ i (f j) :=\n  funext fun x â†¦ by simpa [iteratedFDerivWithin_univ] using\n    iteratedFDerivWithin_sum_apply uniqueDiffOn_univ (mem_univ x) fun j hj â†¦ (h j hj).contDiffOn\n\n"}
{"name":"contDiff_mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nâŠ¢ ContDiff ğ•œ n fun p => HMul.hMul p.1 p.2","decl":"theorem contDiff_mul : ContDiff ğ•œ n fun p : ğ”¸ Ã— ğ”¸ => p.1 * p.2 :=\n  (ContinuousLinearMap.mul ğ•œ ğ”¸).isBoundedBilinearMap.contDiff\n\n"}
{"name":"ContDiffWithinAt.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\ns : Set E\nf g : E â†’ ğ”¸\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => HMul.hMul (f x) (g x)) s x","decl":"/-- The product of two `C^n` functions within a set at a point is `C^n` within this set\nat this point. -/\ntheorem ContDiffWithinAt.mul {s : Set E} {f g : E â†’ ğ”¸} (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hg : ContDiffWithinAt ğ•œ n g s x) : ContDiffWithinAt ğ•œ n (fun x => f x * g x) s x :=\n  contDiff_mul.comp_contDiffWithinAt (hf.prod hg)\n\n"}
{"name":"ContDiffAt.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf g : E â†’ ğ”¸\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => HMul.hMul (f x) (g x)) x","decl":"/-- The product of two `C^n` functions at a point is `C^n` at this point. -/\nnonrec theorem ContDiffAt.mul {f g : E â†’ ğ”¸} (hf : ContDiffAt ğ•œ n f x) (hg : ContDiffAt ğ•œ n g x) :\n    ContDiffAt ğ•œ n (fun x => f x * g x) x :=\n  hf.mul hg\n\n"}
{"name":"ContDiffOn.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf g : E â†’ ğ”¸\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.mul {f g : E â†’ ğ”¸} (hf : ContDiffOn ğ•œ n f s) (hg : ContDiffOn ğ•œ n g s) :\n    ContDiffOn ğ•œ n (fun x => f x * g x) s := fun x hx => (hf x hx).mul (hg x hx)\n\n"}
{"name":"ContDiff.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf g : E â†’ ğ”¸\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of two `C^n`functions is `C^n`. -/\ntheorem ContDiff.mul {f g : E â†’ ğ”¸} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g) :\n    ContDiff ğ•œ n fun x => f x * g x :=\n  contDiff_mul.comp (hf.prod hg)\n\n"}
{"name":"contDiffWithinAt_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nx : E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiffWithinAt ğ•œ n (f i) s x\nâŠ¢ ContDiffWithinAt ğ•œ n (t.prod fun i => f i) s x","decl":"theorem contDiffWithinAt_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'}\n    (h : âˆ€ i âˆˆ t, ContDiffWithinAt ğ•œ n (f i) s x) : ContDiffWithinAt ğ•œ n (âˆ i âˆˆ t, f i) s x :=\n  Finset.prod_induction f (fun f => ContDiffWithinAt ğ•œ n f s x) (fun _ _ => ContDiffWithinAt.mul)\n    (contDiffWithinAt_const (c := 1)) h\n\n"}
{"name":"contDiffWithinAt_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nx : E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiffWithinAt ğ•œ n (f i) s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun y => t.prod fun i => f i y) s x","decl":"theorem contDiffWithinAt_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'}\n    (h : âˆ€ i âˆˆ t, ContDiffWithinAt ğ•œ n (f i) s x) :\n    ContDiffWithinAt ğ•œ n (fun y => âˆ i âˆˆ t, f i y) s x := by\n  simpa only [â† Finset.prod_apply] using contDiffWithinAt_prod' h\n\n"}
{"name":"contDiffAt_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiffAt ğ•œ n (f i) x\nâŠ¢ ContDiffAt ğ•œ n (t.prod fun i => f i) x","decl":"theorem contDiffAt_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, ContDiffAt ğ•œ n (f i) x) :\n    ContDiffAt ğ•œ n (âˆ i âˆˆ t, f i) x :=\n  contDiffWithinAt_prod' h\n\n"}
{"name":"contDiffAt_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiffAt ğ•œ n (f i) x\nâŠ¢ ContDiffAt ğ•œ n (fun y => t.prod fun i => f i y) x","decl":"theorem contDiffAt_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, ContDiffAt ğ•œ n (f i) x) :\n    ContDiffAt ğ•œ n (fun y => âˆ i âˆˆ t, f i y) x :=\n  contDiffWithinAt_prod h\n\n"}
{"name":"contDiffOn_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiffOn ğ•œ n (f i) s\nâŠ¢ ContDiffOn ğ•œ n (t.prod fun i => f i) s","decl":"theorem contDiffOn_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, ContDiffOn ğ•œ n (f i) s) :\n    ContDiffOn ğ•œ n (âˆ i âˆˆ t, f i) s := fun x hx => contDiffWithinAt_prod' fun i hi => h i hi x hx\n\n"}
{"name":"contDiffOn_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiffOn ğ•œ n (f i) s\nâŠ¢ ContDiffOn ğ•œ n (fun y => t.prod fun i => f i y) s","decl":"theorem contDiffOn_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, ContDiffOn ğ•œ n (f i) s) :\n    ContDiffOn ğ•œ n (fun y => âˆ i âˆˆ t, f i y) s := fun x hx =>\n  contDiffWithinAt_prod fun i hi => h i hi x hx\n\n"}
{"name":"contDiff_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiff ğ•œ n (f i)\nâŠ¢ ContDiff ğ•œ n (t.prod fun i => f i)","decl":"theorem contDiff_prod' {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, ContDiff ğ•œ n (f i)) :\n    ContDiff ğ•œ n (âˆ i âˆˆ t, f i) :=\n  contDiff_iff_contDiffAt.mpr fun _ => contDiffAt_prod' fun i hi => (h i hi).contDiffAt\n\n"}
{"name":"contDiff_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nğ”¸' : Type u_4\nÎ¹ : Type u_5\ninstâœÂ¹ : NormedCommRing ğ”¸'\ninstâœ : NormedAlgebra ğ•œ ğ”¸'\nt : Finset Î¹\nf : Î¹ â†’ E â†’ ğ”¸'\nh : âˆ€ (i : Î¹), Membership.mem t i â†’ ContDiff ğ•œ n (f i)\nâŠ¢ ContDiff ğ•œ n fun y => t.prod fun i => f i y","decl":"theorem contDiff_prod {t : Finset Î¹} {f : Î¹ â†’ E â†’ ğ”¸'} (h : âˆ€ i âˆˆ t, ContDiff ğ•œ n (f i)) :\n    ContDiff ğ•œ n fun y => âˆ i âˆˆ t, f i y :=\n  contDiff_iff_contDiffAt.mpr fun _ => contDiffAt_prod fun i hi => (h i hi).contDiffAt\n\n"}
{"name":"ContDiff.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : E â†’ ğ”¸\nhf : ContDiff ğ•œ n f\nm : Nat\nâŠ¢ ContDiff ğ•œ n fun x => HPow.hPow (f x) m","decl":"theorem ContDiff.pow {f : E â†’ ğ”¸} (hf : ContDiff ğ•œ n f) : âˆ€ m : â„•, ContDiff ğ•œ n fun x => f x ^ m\n  | 0 => by simpa using contDiff_const\n  | m + 1 => by simpa [pow_succ] using (hf.pow m).mul hf\n\n"}
{"name":"ContDiffWithinAt.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nx : E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : E â†’ ğ”¸\nhf : ContDiffWithinAt ğ•œ n f s x\nm : Nat\nâŠ¢ ContDiffWithinAt ğ•œ n (fun y => HPow.hPow (f y) m) s x","decl":"theorem ContDiffWithinAt.pow {f : E â†’ ğ”¸} (hf : ContDiffWithinAt ğ•œ n f s x) (m : â„•) :\n    ContDiffWithinAt ğ•œ n (fun y => f y ^ m) s x :=\n  (contDiff_id.pow m).comp_contDiffWithinAt hf\n\n"}
{"name":"ContDiffAt.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : E â†’ ğ”¸\nhf : ContDiffAt ğ•œ n f x\nm : Nat\nâŠ¢ ContDiffAt ğ•œ n (fun y => HPow.hPow (f y) m) x","decl":"nonrec theorem ContDiffAt.pow {f : E â†’ ğ”¸} (hf : ContDiffAt ğ•œ n f x) (m : â„•) :\n    ContDiffAt ğ•œ n (fun y => f y ^ m) x :=\n  hf.pow m\n\n"}
{"name":"ContDiffOn.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : WithTop ENat\nğ”¸ : Type u_3\ninstâœÂ¹ : NormedRing ğ”¸\ninstâœ : NormedAlgebra ğ•œ ğ”¸\nf : E â†’ ğ”¸\nhf : ContDiffOn ğ•œ n f s\nm : Nat\nâŠ¢ ContDiffOn ğ•œ n (fun y => HPow.hPow (f y) m) s","decl":"theorem ContDiffOn.pow {f : E â†’ ğ”¸} (hf : ContDiffOn ğ•œ n f s) (m : â„•) :\n    ContDiffOn ğ•œ n (fun y => f y ^ m) s := fun y hy => (hf y hy).pow m\n\n"}
{"name":"ContDiffWithinAt.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nx : E\nğ•œ' : Type u_6\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nn : WithTop ENat\nhf : ContDiffWithinAt ğ•œ n f s x\nc : ğ•œ'\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => HDiv.hDiv (f x) c) s x","decl":"theorem ContDiffWithinAt.div_const {f : E â†’ ğ•œ'} {n} (hf : ContDiffWithinAt ğ•œ n f s x) (c : ğ•œ') :\n    ContDiffWithinAt ğ•œ n (fun x => f x / c) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul contDiffWithinAt_const\n\n"}
{"name":"ContDiffAt.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nğ•œ' : Type u_6\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nn : WithTop ENat\nhf : ContDiffAt ğ•œ n f x\nc : ğ•œ'\nâŠ¢ ContDiffAt ğ•œ n (fun x => HDiv.hDiv (f x) c) x","decl":"nonrec theorem ContDiffAt.div_const {f : E â†’ ğ•œ'} {n} (hf : ContDiffAt ğ•œ n f x) (c : ğ•œ') :\n    ContDiffAt ğ•œ n (fun x => f x / c) x :=\n  hf.div_const c\n\n"}
{"name":"ContDiffOn.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nğ•œ' : Type u_6\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nn : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\nc : ğ•œ'\nâŠ¢ ContDiffOn ğ•œ n (fun x => HDiv.hDiv (f x) c) s","decl":"theorem ContDiffOn.div_const {f : E â†’ ğ•œ'} {n} (hf : ContDiffOn ğ•œ n f s) (c : ğ•œ') :\n    ContDiffOn ğ•œ n (fun x => f x / c) s := fun x hx => (hf x hx).div_const c\n\n"}
{"name":"ContDiff.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nğ•œ' : Type u_6\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nn : WithTop ENat\nhf : ContDiff ğ•œ n f\nc : ğ•œ'\nâŠ¢ ContDiff ğ•œ n fun x => HDiv.hDiv (f x) c","decl":"theorem ContDiff.div_const {f : E â†’ ğ•œ'} {n} (hf : ContDiff ğ•œ n f) (c : ğ•œ') :\n    ContDiff ğ•œ n fun x => f x / c := by simpa only [div_eq_mul_inv] using hf.mul contDiff_const\n\n"}
{"name":"contDiff_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nâŠ¢ ContDiff ğ•œ n fun p => HSMul.hSMul p.1 p.2","decl":"theorem contDiff_smul : ContDiff ğ•œ n fun p : ğ•œ Ã— F => p.1 â€¢ p.2 :=\n  isBoundedBilinearMap_smul.contDiff\n\n"}
{"name":"ContDiffWithinAt.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\ns : Set E\nf : E â†’ ğ•œ\ng : E â†’ F\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => HSMul.hSMul (f x) (g x)) s x","decl":"/-- The scalar multiplication of two `C^n` functions within a set at a point is `C^n` within this\nset at this point. -/\ntheorem ContDiffWithinAt.smul {s : Set E} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hg : ContDiffWithinAt ğ•œ n g s x) : ContDiffWithinAt ğ•œ n (fun x => f x â€¢ g x) s x :=\n  contDiff_smul.contDiffWithinAt.comp x (hf.prod hg) subset_preimage_univ\n\n"}
{"name":"ContDiffAt.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nx : E\nn : WithTop ENat\nf : E â†’ ğ•œ\ng : E â†’ F\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nâŠ¢ ContDiffAt ğ•œ n (fun x => HSMul.hSMul (f x) (g x)) x","decl":"/-- The scalar multiplication of two `C^n` functions at a point is `C^n` at this point. -/\ntheorem ContDiffAt.smul {f : E â†’ ğ•œ} {g : E â†’ F} (hf : ContDiffAt ğ•œ n f x)\n    (hg : ContDiffAt ğ•œ n g x) : ContDiffAt ğ•œ n (fun x => f x â€¢ g x) x := by\n  rw [â† contDiffWithinAt_univ] at *; exact hf.smul hg\n\n"}
{"name":"ContDiff.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nf : E â†’ ğ•œ\ng : E â†’ F\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n fun x => HSMul.hSMul (f x) (g x)","decl":"/-- The scalar multiplication of two `C^n` functions is `C^n`. -/\ntheorem ContDiff.smul {f : E â†’ ğ•œ} {g : E â†’ F} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g) :\n    ContDiff ğ•œ n fun x => f x â€¢ g x :=\n  contDiff_smul.comp (hf.prod hg)\n\n"}
{"name":"ContDiffOn.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\ns : Set E\nf : E â†’ ğ•œ\ng : E â†’ F\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nâŠ¢ ContDiffOn ğ•œ n (fun x => HSMul.hSMul (f x) (g x)) s","decl":"/-- The scalar multiplication of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.smul {s : Set E} {f : E â†’ ğ•œ} {g : E â†’ F} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) : ContDiffOn ğ•œ n (fun x => f x â€¢ g x) s := fun x hx =>\n  (hf x hx).smul (hg x hx)\n\n"}
{"name":"contDiff_const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¶ : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nc : R\nâŠ¢ ContDiff ğ•œ n fun p => HSMul.hSMul c p","decl":"theorem contDiff_const_smul (c : R) : ContDiff ğ•œ n fun p : F => c â€¢ p :=\n  (c â€¢ ContinuousLinearMap.id ğ•œ F).contDiff\n\n"}
{"name":"ContDiffWithinAt.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\ns : Set E\nf : E â†’ F\nx : E\nc : R\nhf : ContDiffWithinAt ğ•œ n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n (fun y => HSMul.hSMul c (f y)) s x","decl":"/-- The scalar multiplication of a constant and a `C^n` function within a set at a point is `C^n`\nwithin this set at this point. -/\ntheorem ContDiffWithinAt.const_smul {s : Set E} {f : E â†’ F} {x : E} (c : R)\n    (hf : ContDiffWithinAt ğ•œ n f s x) : ContDiffWithinAt ğ•œ n (fun y => c â€¢ f y) s x :=\n  (contDiff_const_smul c).contDiffAt.comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffAt.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nf : E â†’ F\nx : E\nc : R\nhf : ContDiffAt ğ•œ n f x\nâŠ¢ ContDiffAt ğ•œ n (fun y => HSMul.hSMul c (f y)) x","decl":"/-- The scalar multiplication of a constant and a `C^n` function at a point is `C^n` at this\npoint. -/\ntheorem ContDiffAt.const_smul {f : E â†’ F} {x : E} (c : R) (hf : ContDiffAt ğ•œ n f x) :\n    ContDiffAt ğ•œ n (fun y => c â€¢ f y) x := by\n  rw [â† contDiffWithinAt_univ] at *; exact hf.const_smul c\n\n"}
{"name":"ContDiff.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\nf : E â†’ F\nc : R\nhf : ContDiff ğ•œ n f\nâŠ¢ ContDiff ğ•œ n fun y => HSMul.hSMul c (f y)","decl":"/-- The scalar multiplication of a constant and a `C^n` function is `C^n`. -/\ntheorem ContDiff.const_smul {f : E â†’ F} (c : R) (hf : ContDiff ğ•œ n f) :\n    ContDiff ğ•œ n fun y => c â€¢ f y :=\n  (contDiff_const_smul c).comp hf\n\n"}
{"name":"ContDiffOn.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\ns : Set E\nf : E â†’ F\nc : R\nhf : ContDiffOn ğ•œ n f s\nâŠ¢ ContDiffOn ğ•œ n (fun y => HSMul.hSMul c (f y)) s","decl":"/-- The scalar multiplication of a constant and a `C^n` on a domain is `C^n`. -/\ntheorem ContDiffOn.const_smul {s : Set E} {f : E â†’ F} (c : R) (hf : ContDiffOn ğ•œ n f s) :\n    ContDiffOn ğ•œ n (fun y => c â€¢ f y) s := fun x hx => (hf x hx).const_smul c\n\n"}
{"name":"iteratedFDerivWithin_const_smul_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\ni : Nat\na : R\nhf : ContDiffWithinAt ğ•œ (â†‘i) f s x\nhu : UniqueDiffOn ğ•œ s\nhx : Membership.mem s x\nâŠ¢ Eq (iteratedFDerivWithin ğ•œ i (HSMul.hSMul a f) s x) (HSMul.hSMul a (iteratedFDerivWithin ğ•œ i f s x))","decl":"theorem iteratedFDerivWithin_const_smul_apply (hf : ContDiffWithinAt ğ•œ i f s x)\n    (hu : UniqueDiffOn ğ•œ s) (hx : x âˆˆ s) :\n    iteratedFDerivWithin ğ•œ i (a â€¢ f) s x = a â€¢ iteratedFDerivWithin ğ•œ i f s x :=\n  (a â€¢ (1 : F â†’L[ğ•œ] F)).iteratedFDerivWithin_comp_left hf hu hx le_rfl\n\n"}
{"name":"iteratedFDeriv_const_smul_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\ni : Nat\na : R\nhf : ContDiffAt ğ•œ (â†‘i) f x\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (HSMul.hSMul a f) x) (HSMul.hSMul a (iteratedFDeriv ğ•œ i f x))","decl":"theorem iteratedFDeriv_const_smul_apply (hf : ContDiffAt ğ•œ i f x) :\n    iteratedFDeriv ğ•œ i (a â€¢ f) x = a â€¢ iteratedFDeriv ğ•œ i f x :=\n  (a â€¢ (1 : F â†’L[ğ•œ] F)).iteratedFDeriv_comp_left hf le_rfl\n\n"}
{"name":"iteratedFDeriv_const_smul_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nR : Type u_3\ninstâœÂ³ : Semiring R\ninstâœÂ² : Module R F\ninstâœÂ¹ : SMulCommClass ğ•œ R F\ninstâœ : ContinuousConstSMul R F\ni : Nat\na : R\nhf : ContDiffAt ğ•œ (â†‘i) f x\nâŠ¢ Eq (iteratedFDeriv ğ•œ i (fun x => HSMul.hSMul a (f x)) x) (HSMul.hSMul a (iteratedFDeriv ğ•œ i f x))","decl":"theorem iteratedFDeriv_const_smul_apply' (hf : ContDiffAt ğ•œ i f x) :\n    iteratedFDeriv ğ•œ i (fun x â†¦ a â€¢ f x) x = a â€¢ iteratedFDeriv ğ•œ i f x :=\n  iteratedFDeriv_const_smul_apply hf\n\n"}
{"name":"ContDiffWithinAt.prod_map'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\nF' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ F'\ns : Set E\nt : Set E'\nf : E â†’ F\ng : E' â†’ F'\np : Prod E E'\nhf : ContDiffWithinAt ğ•œ n f s p.1\nhg : ContDiffWithinAt ğ•œ n g t p.2\nâŠ¢ ContDiffWithinAt ğ•œ n (Prod.map f g) (SProd.sprod s t) p","decl":"/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem ContDiffWithinAt.prod_map' {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'}\n    (hf : ContDiffWithinAt ğ•œ n f s p.1) (hg : ContDiffWithinAt ğ•œ n g t p.2) :\n    ContDiffWithinAt ğ•œ n (Prod.map f g) (s Ã—Ë¢ t) p :=\n  (hf.comp p contDiffWithinAt_fst (prod_subset_preimage_fst _ _)).prod\n    (hg.comp p contDiffWithinAt_snd (prod_subset_preimage_snd _ _))\n\n"}
{"name":"ContDiffWithinAt.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\nF' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ F'\ns : Set E\nt : Set E'\nf : E â†’ F\ng : E' â†’ F'\nx : E\ny : E'\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g t y\nâŠ¢ ContDiffWithinAt ğ•œ n (Prod.map f g) (SProd.sprod s t) { fst := x, snd := y }","decl":"theorem ContDiffWithinAt.prod_map {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'} {x : E}\n    {y : E'} (hf : ContDiffWithinAt ğ•œ n f s x) (hg : ContDiffWithinAt ğ•œ n g t y) :\n    ContDiffWithinAt ğ•œ n (Prod.map f g) (s Ã—Ë¢ t) (x, y) :=\n  ContDiffWithinAt.prod_map' hf hg\n\n"}
{"name":"ContDiffOn.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nE' : Type u_5\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\nF' : Type u_6\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ F'\ns : Set E\nt : Set E'\nf : E â†’ F\ng : E' â†’ F'\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g t\nâŠ¢ ContDiffOn ğ•œ n (Prod.map f g) (SProd.sprod s t)","decl":"/-- The product map of two `C^n` functions on a set is `C^n` on the product set. -/\ntheorem ContDiffOn.prod_map {E' : Type*} [NormedAddCommGroup E'] [NormedSpace ğ•œ E'] {F' : Type*}\n    [NormedAddCommGroup F'] [NormedSpace ğ•œ F'] {s : Set E} {t : Set E'} {f : E â†’ F} {g : E' â†’ F'}\n    (hf : ContDiffOn ğ•œ n f s) (hg : ContDiffOn ğ•œ n g t) : ContDiffOn ğ•œ n (Prod.map f g) (s Ã—Ë¢ t) :=\n  (hf.comp contDiffOn_fst (prod_subset_preimage_fst _ _)).prod\n    (hg.comp contDiffOn_snd (prod_subset_preimage_snd _ _))\n\n"}
{"name":"ContDiffAt.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\nF' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ F'\nf : E â†’ F\ng : E' â†’ F'\nx : E\ny : E'\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g y\nâŠ¢ ContDiffAt ğ•œ n (Prod.map f g) { fst := x, snd := y }","decl":"/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem ContDiffAt.prod_map {f : E â†’ F} {g : E' â†’ F'} {x : E} {y : E'} (hf : ContDiffAt ğ•œ n f x)\n    (hg : ContDiffAt ğ•œ n g y) : ContDiffAt ğ•œ n (Prod.map f g) (x, y) := by\n  rw [ContDiffAt] at *\n  convert hf.prod_map hg\n  simp only [univ_prod_univ]\n\n"}
{"name":"ContDiffAt.prod_map'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\nF' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ F'\nf : E â†’ F\ng : E' â†’ F'\np : Prod E E'\nhf : ContDiffAt ğ•œ n f p.1\nhg : ContDiffAt ğ•œ n g p.2\nâŠ¢ ContDiffAt ğ•œ n (Prod.map f g) p","decl":"/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem ContDiffAt.prod_map' {f : E â†’ F} {g : E' â†’ F'} {p : E Ã— E'} (hf : ContDiffAt ğ•œ n f p.1)\n    (hg : ContDiffAt ğ•œ n g p.2) : ContDiffAt ğ•œ n (Prod.map f g) p := by\n  rcases p with âŸ¨âŸ©\n  exact ContDiffAt.prod_map hf hg\n\n"}
{"name":"ContDiff.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ¸ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ· : NormedAddCommGroup E\ninstâœâ¶ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâµ : NormedAddCommGroup F\ninstâœâ´ : NormedSpace ğ•œ F\nn : WithTop ENat\nE' : Type u_3\ninstâœÂ³ : NormedAddCommGroup E'\ninstâœÂ² : NormedSpace ğ•œ E'\nF' : Type u_4\ninstâœÂ¹ : NormedAddCommGroup F'\ninstâœ : NormedSpace ğ•œ F'\nf : E â†’ F\ng : E' â†’ F'\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nâŠ¢ ContDiff ğ•œ n (Prod.map f g)","decl":"/-- The product map of two `C^n` functions is `C^n`. -/\ntheorem ContDiff.prod_map {f : E â†’ F} {g : E' â†’ F'} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g) :\n    ContDiff ğ•œ n (Prod.map f g) := by\n  rw [contDiff_iff_contDiffAt] at *\n  exact fun âŸ¨x, yâŸ© => (hf x).prod_map (hg y)\n\n"}
{"name":"contDiff_prod_mk_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚€ : F\nâŠ¢ ContDiff ğ•œ n fun e => { fst := e, snd := fâ‚€ }","decl":"theorem contDiff_prod_mk_left (fâ‚€ : F) : ContDiff ğ•œ n fun e : E => (e, fâ‚€) :=\n  contDiff_id.prod contDiff_const\n\n"}
{"name":"contDiff_prod_mk_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\neâ‚€ : E\nâŠ¢ ContDiff ğ•œ n fun f => { fst := eâ‚€, snd := f }","decl":"theorem contDiff_prod_mk_right (eâ‚€ : E) : ContDiff ğ•œ n fun f : F => (eâ‚€, f) :=\n  contDiff_const.prod contDiff_id\n\n"}
{"name":"contDiffAt_ring_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ³ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\nR : Type u_3\ninstâœÂ² : NormedRing R\ninstâœÂ¹ : NormedAlgebra ğ•œ R\ninstâœ : HasSummableGeomSeries R\nx : Units R\nâŠ¢ ContDiffAt ğ•œ n Ring.inverse â†‘x","decl":"/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element, as it is analytic. -/\ntheorem contDiffAt_ring_inverse [HasSummableGeomSeries R] (x : RË£) :\n    ContDiffAt ğ•œ n Ring.inverse (x : R) := by\n  have := AnalyticOnNhd.contDiffOn (analyticOnNhd_inverse (ğ•œ := ğ•œ) (A := R)) (n := n)\n    Units.isOpen.uniqueDiffOn x x.isUnit\n  exact this.contDiffAt (Units.isOpen.mem_nhds x.isUnit)\n\n"}
{"name":"contDiffAt_inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_4\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nx : ğ•œ'\nhx : Ne x 0\nn : WithTop ENat\nâŠ¢ ContDiffAt ğ•œ n Inv.inv x","decl":"theorem contDiffAt_inv {x : ğ•œ'} (hx : x â‰  0) {n} : ContDiffAt ğ•œ n Inv.inv x := by\n  simpa only [Ring.inverse_eq_inv'] using contDiffAt_ring_inverse ğ•œ (Units.mk0 x hx)\n\n"}
{"name":"contDiffOn_inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nğ•œ' : Type u_4\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nn : WithTop ENat\nâŠ¢ ContDiffOn ğ•œ n Inv.inv (HasCompl.compl (Singleton.singleton 0))","decl":"theorem contDiffOn_inv {n} : ContDiffOn ğ•œ n (Inv.inv : ğ•œ' â†’ ğ•œ') {0}á¶œ := fun _ hx =>\n  (contDiffAt_inv ğ•œ hx).contDiffWithinAt\n\n"}
{"name":"ContDiffWithinAt.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nx : E\nğ•œ' : Type u_4\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nn : WithTop ENat\nhf : ContDiffWithinAt ğ•œ n f s x\nhx : Ne (f x) 0\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => Inv.inv (f x)) s x","decl":"theorem ContDiffWithinAt.inv {f : E â†’ ğ•œ'} {n} (hf : ContDiffWithinAt ğ•œ n f s x) (hx : f x â‰  0) :\n    ContDiffWithinAt ğ•œ n (fun x => (f x)â»Â¹) s x :=\n  (contDiffAt_inv ğ•œ hx).comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffOn.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\ns : Set E\nn : WithTop ENat\nğ•œ' : Type u_4\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nhf : ContDiffOn ğ•œ n f s\nh : âˆ€ (x : E), Membership.mem s x â†’ Ne (f x) 0\nâŠ¢ ContDiffOn ğ•œ n (fun x => Inv.inv (f x)) s","decl":"theorem ContDiffOn.inv {f : E â†’ ğ•œ'} (hf : ContDiffOn ğ•œ n f s) (h : âˆ€ x âˆˆ s, f x â‰  0) :\n    ContDiffOn ğ•œ n (fun x => (f x)â»Â¹) s := fun x hx => (hf.contDiffWithinAt hx).inv (h x hx)\n\n"}
{"name":"ContDiffAt.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nx : E\nn : WithTop ENat\nğ•œ' : Type u_4\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nhf : ContDiffAt ğ•œ n f x\nhx : Ne (f x) 0\nâŠ¢ ContDiffAt ğ•œ n (fun x => Inv.inv (f x)) x","decl":"nonrec theorem ContDiffAt.inv {f : E â†’ ğ•œ'} (hf : ContDiffAt ğ•œ n f x) (hx : f x â‰  0) :\n    ContDiffAt ğ•œ n (fun x => (f x)â»Â¹) x :=\n  hf.inv hx\n\n"}
{"name":"ContDiff.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nn : WithTop ENat\nğ•œ' : Type u_4\ninstâœÂ¹ : NormedField ğ•œ'\ninstâœ : NormedAlgebra ğ•œ ğ•œ'\nf : E â†’ ğ•œ'\nhf : ContDiff ğ•œ n f\nh : âˆ€ (x : E), Ne (f x) 0\nâŠ¢ ContDiff ğ•œ n fun x => Inv.inv (f x)","decl":"theorem ContDiff.inv {f : E â†’ ğ•œ'} (hf : ContDiff ğ•œ n f) (h : âˆ€ x, f x â‰  0) :\n    ContDiff ğ•œ n fun x => (f x)â»Â¹ := by\n  rw [contDiff_iff_contDiffAt]; exact fun x => hf.contDiffAt.inv (h x)\n\n-- TODO: generalize to `f g : E â†’ ğ•œ'`\n"}
{"name":"ContDiffWithinAt.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nx : E\nf g : E â†’ ğ•œ\nn : WithTop ENat\nhf : ContDiffWithinAt ğ•œ n f s x\nhg : ContDiffWithinAt ğ•œ n g s x\nhx : Ne (g x) 0\nâŠ¢ ContDiffWithinAt ğ•œ n (fun x => HDiv.hDiv (f x) (g x)) s x","decl":"theorem ContDiffWithinAt.div {f g : E â†’ ğ•œ} {n} (hf : ContDiffWithinAt ğ•œ n f s x)\n    (hg : ContDiffWithinAt ğ•œ n g s x) (hx : g x â‰  0) :\n    ContDiffWithinAt ğ•œ n (fun x => f x / g x) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv hx)\n\n"}
{"name":"ContDiffOn.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\ns : Set E\nf g : E â†’ ğ•œ\nn : WithTop ENat\nhf : ContDiffOn ğ•œ n f s\nhg : ContDiffOn ğ•œ n g s\nhâ‚€ : âˆ€ (x : E), Membership.mem s x â†’ Ne (g x) 0\nâŠ¢ ContDiffOn ğ•œ n (HDiv.hDiv f g) s","decl":"theorem ContDiffOn.div {f g : E â†’ ğ•œ} {n} (hf : ContDiffOn ğ•œ n f s)\n    (hg : ContDiffOn ğ•œ n g s) (hâ‚€ : âˆ€ x âˆˆ s, g x â‰  0) : ContDiffOn ğ•œ n (f / g) s := fun x hx =>\n  (hf x hx).div (hg x hx) (hâ‚€ x hx)\n\n"}
{"name":"ContDiffAt.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nx : E\nf g : E â†’ ğ•œ\nn : WithTop ENat\nhf : ContDiffAt ğ•œ n f x\nhg : ContDiffAt ğ•œ n g x\nhx : Ne (g x) 0\nâŠ¢ ContDiffAt ğ•œ n (fun x => HDiv.hDiv (f x) (g x)) x","decl":"nonrec theorem ContDiffAt.div {f g : E â†’ ğ•œ} {n} (hf : ContDiffAt ğ•œ n f x)\n    (hg : ContDiffAt ğ•œ n g x) (hx : g x â‰  0) : ContDiffAt ğ•œ n (fun x => f x / g x) x :=\n  hf.div hg hx\n\n"}
{"name":"ContDiff.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ¹ : NormedAddCommGroup E\ninstâœ : NormedSpace ğ•œ E\nf g : E â†’ ğ•œ\nn : WithTop ENat\nhf : ContDiff ğ•œ n f\nhg : ContDiff ğ•œ n g\nh0 : âˆ€ (x : E), Ne (g x) 0\nâŠ¢ ContDiff ğ•œ n fun x => HDiv.hDiv (f x) (g x)","decl":"theorem ContDiff.div {f g : E â†’ ğ•œ} {n} (hf : ContDiff ğ•œ n f) (hg : ContDiff ğ•œ n g)\n    (h0 : âˆ€ x, g x â‰  0) : ContDiff ğ•œ n fun x => f x / g x := by\n  simp only [contDiff_iff_contDiffAt] at *\n  exact fun x => (hf x).div (hg x) (h0 x)\n\n"}
{"name":"contDiffAt_map_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nn : WithTop ENat\ninstâœ : CompleteSpace E\ne : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nâŠ¢ ContDiffAt ğ•œ n ContinuousLinearMap.inverse â†‘e","decl":"/-- At a continuous linear equivalence `e : E â‰ƒL[ğ•œ] F` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem contDiffAt_map_inverse [CompleteSpace E] (e : E â‰ƒL[ğ•œ] F) :\n    ContDiffAt ğ•œ n inverse (e : E â†’L[ğ•œ] F) := by\n  nontriviality E\n  -- first, we use the lemma `to_ring_inverse` to rewrite in terms of `Ring.inverse` in the ring\n  -- `E â†’L[ğ•œ] E`\n  let Oâ‚ : (E â†’L[ğ•œ] E) â†’ F â†’L[ğ•œ] E := fun f => f.comp (e.symm : F â†’L[ğ•œ] E)\n  let Oâ‚‚ : (E â†’L[ğ•œ] F) â†’ E â†’L[ğ•œ] E := fun f => (e.symm : F â†’L[ğ•œ] E).comp f\n  have : ContinuousLinearMap.inverse = Oâ‚ âˆ˜ Ring.inverse âˆ˜ Oâ‚‚ := funext (to_ring_inverse e)\n  rw [this]\n  -- `Oâ‚` and `Oâ‚‚` are `ContDiff`,\n  -- so we reduce to proving that `Ring.inverse` is `ContDiff`\n  have hâ‚ : ContDiff ğ•œ n Oâ‚ := contDiff_id.clm_comp contDiff_const\n  have hâ‚‚ : ContDiff ğ•œ n Oâ‚‚ := contDiff_const.clm_comp contDiff_id\n  refine hâ‚.contDiffAt.comp _ (ContDiffAt.comp _ ?_ hâ‚‚.contDiffAt)\n  convert contDiffAt_ring_inverse ğ•œ (1 : (E â†’L[ğ•œ] E)Ë£)\n  simp [Oâ‚‚, one_def]\n\n"}
{"name":"ContinuousLinearMap.IsInvertible.contDiffAt_map_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nn : WithTop ENat\ninstâœ : CompleteSpace E\ne : ContinuousLinearMap (RingHom.id ğ•œ) E F\nhe : e.IsInvertible\nâŠ¢ ContDiffAt ğ•œ n ContinuousLinearMap.inverse e","decl":"/-- At an invertible map `e : M â†’L[R] Mâ‚‚` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem ContinuousLinearMap.IsInvertible.contDiffAt_map_inverse [CompleteSpace E] {e : E â†’L[ğ•œ] F}\n    (he : e.IsInvertible) : ContDiffAt ğ•œ n inverse e := by\n  rcases he with âŸ¨M, rflâŸ©\n  exact _root_.contDiffAt_map_inverse M\n\n"}
{"name":"PartialHomeomorph.contDiffAt_symm","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nn : WithTop ENat\ninstâœ : CompleteSpace E\nf : PartialHomeomorph E F\nfâ‚€' : ContinuousLinearEquiv (RingHom.id ğ•œ) E F\na : F\nha : Membership.mem f.target a\nhfâ‚€' : HasFDerivAt (â†‘f) (â†‘fâ‚€') (â†‘f.symm a)\nhf : ContDiffAt ğ•œ n (â†‘f) (â†‘f.symm a)\nâŠ¢ ContDiffAt ğ•œ n (â†‘f.symm) a","decl":"/-- If `f` is a local homeomorphism and the point `a` is in its target,\nand if `f` is `n` times continuously differentiable at `f.symm a`,\nand if the derivative at `f.symm a` is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.contDiffAt_symm [CompleteSpace E] (f : PartialHomeomorph E F)\n    {fâ‚€' : E â‰ƒL[ğ•œ] F} {a : F} (ha : a âˆˆ f.target)\n    (hfâ‚€' : HasFDerivAt f (fâ‚€' : E â†’L[ğ•œ] F) (f.symm a)) (hf : ContDiffAt ğ•œ n f (f.symm a)) :\n    ContDiffAt ğ•œ n f.symm a := by\n  match n with\n  | Ï‰ =>\n    apply AnalyticAt.contDiffAt\n    exact f.analyticAt_symm ha hf.analyticAt hfâ‚€'.fderiv\n  | (n : â„•âˆ) =>\n    -- We prove this by induction on `n`\n    induction' n using ENat.nat_induction with n IH Itop\n    Â· apply contDiffAt_zero.2\n      exact âŸ¨f.target, IsOpen.mem_nhds f.open_target ha, f.continuousOn_invFunâŸ©\n    Â· obtain âŸ¨f', âŸ¨u, hu, hff'âŸ©, hf'âŸ© := contDiffAt_succ_iff_hasFDerivAt.mp hf\n      apply contDiffAt_succ_iff_hasFDerivAt.2\n      -- For showing `n.succ` times continuous differentiability (the main inductive step), it\n      -- suffices to produce the derivative and show that it is `n` times continuously\n      -- differentiable\n      have eq_fâ‚€' : f' (f.symm a) = fâ‚€' := (hff' (f.symm a) (mem_of_mem_nhds hu)).unique hfâ‚€'\n      -- This follows by a bootstrapping formula expressing the derivative as a\n      -- function of `f` itself\n      refine âŸ¨inverse âˆ˜ f' âˆ˜ f.symm, ?_, ?_âŸ©\n      Â· -- We first check that the derivative of `f` is that formula\n        have h_nhds : { y : E | âˆƒ e : E â‰ƒL[ğ•œ] F, â†‘e = f' y } âˆˆ ğ“ (f.symm a) := by\n          have hfâ‚€' := fâ‚€'.nhds\n          rw [â† eq_fâ‚€'] at hfâ‚€'\n          exact hf'.continuousAt.preimage_mem_nhds hfâ‚€'\n        obtain âŸ¨t, htu, ht, htfâŸ© := mem_nhds_iff.mp (Filter.inter_mem hu h_nhds)\n        use f.target âˆ© f.symm â»Â¹' t\n        refine âŸ¨IsOpen.mem_nhds ?_ ?_, ?_âŸ©\n        Â· exact f.isOpen_inter_preimage_symm ht\n        Â· exact mem_inter ha (mem_preimage.mpr htf)\n        intro x hx\n        obtain âŸ¨hxu, e, heâŸ© := htu hx.2\n        have h_deriv : HasFDerivAt f (e : E â†’L[ğ•œ] F) (f.symm x) := by\n          rw [he]\n          exact hff' (f.symm x) hxu\n        convert f.hasFDerivAt_symm hx.1 h_deriv\n        simp [â† he]\n      Â· -- Then we check that the formula, being a composition of `ContDiff` pieces, is\n        -- itself `ContDiff`\n        have h_derivâ‚ : ContDiffAt ğ•œ n inverse (f' (f.symm a)) := by\n          rw [eq_fâ‚€']\n          exact contDiffAt_map_inverse _\n        have h_derivâ‚‚ : ContDiffAt ğ•œ n f.symm a := by\n          refine IH (hf.of_le ?_)\n          norm_cast\n          exact Nat.le_succ n\n        exact (h_derivâ‚.comp _ hf').comp _ h_derivâ‚‚\n    Â· refine contDiffAt_infty.mpr ?_\n      intro n\n      exact Itop n (contDiffAt_infty.mp hf n)\n\n"}
{"name":"Homeomorph.contDiff_symm","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâµ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ´ : NormedAddCommGroup E\ninstâœÂ³ : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ² : NormedAddCommGroup F\ninstâœÂ¹ : NormedSpace ğ•œ F\nn : WithTop ENat\ninstâœ : CompleteSpace E\nf : Homeomorph E F\nfâ‚€' : E â†’ ContinuousLinearEquiv (RingHom.id ğ•œ) E F\nhfâ‚€' : âˆ€ (a : E), HasFDerivAt (â‡‘f) (â†‘(fâ‚€' a)) a\nhf : ContDiff ğ•œ n â‡‘f\nâŠ¢ ContDiff ğ•œ n â‡‘f.symm","decl":"/-- If `f` is an `n` times continuously differentiable homeomorphism,\nand if the derivative of `f` at each point is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem Homeomorph.contDiff_symm [CompleteSpace E] (f : E â‰ƒâ‚œ F) {fâ‚€' : E â†’ E â‰ƒL[ğ•œ] F}\n    (hfâ‚€' : âˆ€ a, HasFDerivAt f (fâ‚€' a : E â†’L[ğ•œ] F) a) (hf : ContDiff ğ•œ n (f : E â†’ F)) :\n    ContDiff ğ•œ n (f.symm : F â†’ E) :=\n  contDiff_iff_contDiffAt.2 fun x =>\n    f.toPartialHomeomorph.contDiffAt_symm (mem_univ x) (hfâ‚€' _) hf.contDiffAt\n\n"}
{"name":"PartialHomeomorph.contDiffAt_symm_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\ninstâœ : CompleteSpace ğ•œ\nf : PartialHomeomorph ğ•œ ğ•œ\nfâ‚€' a : ğ•œ\nhâ‚€ : Ne fâ‚€' 0\nha : Membership.mem f.target a\nhfâ‚€' : HasDerivAt (â†‘f) fâ‚€' (â†‘f.symm a)\nhf : ContDiffAt ğ•œ n (â†‘f) (â†‘f.symm a)\nâŠ¢ ContDiffAt ğ•œ n (â†‘f.symm) a","decl":"/-- Let `f` be a local homeomorphism of a nontrivially normed field, let `a` be a point in its\ntarget. if `f` is `n` times continuously differentiable at `f.symm a`, and if the derivative at\n`f.symm a` is nonzero, then `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.contDiffAt_symm_deriv [CompleteSpace ğ•œ] (f : PartialHomeomorph ğ•œ ğ•œ)\n    {fâ‚€' a : ğ•œ} (hâ‚€ : fâ‚€' â‰  0) (ha : a âˆˆ f.target) (hfâ‚€' : HasDerivAt f fâ‚€' (f.symm a))\n    (hf : ContDiffAt ğ•œ n f (f.symm a)) : ContDiffAt ğ•œ n f.symm a :=\n  f.contDiffAt_symm ha (hfâ‚€'.hasFDerivAt_equiv hâ‚€) hf\n\n"}
{"name":"Homeomorph.contDiff_symm_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹ : NontriviallyNormedField ğ•œ\nn : WithTop ENat\ninstâœ : CompleteSpace ğ•œ\nf : Homeomorph ğ•œ ğ•œ\nf' : ğ•œ â†’ ğ•œ\nhâ‚€ : âˆ€ (x : ğ•œ), Ne (f' x) 0\nhf' : âˆ€ (x : ğ•œ), HasDerivAt (â‡‘f) (f' x) x\nhf : ContDiff ğ•œ n â‡‘f\nâŠ¢ ContDiff ğ•œ n â‡‘f.symm","decl":"/-- Let `f` be an `n` times continuously differentiable homeomorphism of a nontrivially normed\nfield.  Suppose that the derivative of `f` is never equal to zero. Then `f.symm` is `n` times\ncontinuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem Homeomorph.contDiff_symm_deriv [CompleteSpace ğ•œ] (f : ğ•œ â‰ƒâ‚œ ğ•œ) {f' : ğ•œ â†’ ğ•œ}\n    (hâ‚€ : âˆ€ x, f' x â‰  0) (hf' : âˆ€ x, HasDerivAt f (f' x) x) (hf : ContDiff ğ•œ n (f : ğ•œ â†’ ğ•œ)) :\n    ContDiff ğ•œ n (f.symm : ğ•œ â†’ ğ•œ) :=\n  contDiff_iff_contDiffAt.2 fun x =>\n    f.toPartialHomeomorph.contDiffAt_symm_deriv (hâ‚€ _) (mem_univ x) (hf' _) hf.contDiffAt\n\n"}
{"name":"PartialHomeomorph.restrContDiff_target","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Eq (PartialHomeomorph.restrContDiff ğ•œ f n hn).target (Inter.inter f.target (setOf fun y => And (ContDiffAt ğ•œ n (â†‘f.symm) y) (ContDiffAt ğ•œ n (â†‘f) (â†‘f.symm y))))","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x âˆˆ f.source`, `y = f x âˆˆ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `Ï‰`, but not `âˆ`,\nbecause the set of points of `C^âˆ`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop â„•âˆ) (hn : n â‰  âˆ) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt ğ•œ n f x âˆ§ ContDiffAt ğ•œ n f.symm (f x)}\n      {y | ContDiffAt ğ•œ n f.symm y âˆ§ ContDiffAt ğ•œ n f (f.symm y)} := fun x hx â†¦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ âŸ¨hxs, hxf, hxf'âŸ© â†¦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.restrContDiff_source","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ Eq (PartialHomeomorph.restrContDiff ğ•œ f n hn).source (Inter.inter f.source (setOf fun x => And (ContDiffAt ğ•œ n (â†‘f) x) (ContDiffAt ğ•œ n (â†‘f.symm) (â†‘f x))))","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x âˆˆ f.source`, `y = f x âˆˆ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `Ï‰`, but not `âˆ`,\nbecause the set of points of `C^âˆ`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop â„•âˆ) (hn : n â‰  âˆ) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt ğ•œ n f x âˆ§ ContDiffAt ğ•œ n f.symm (f x)}\n      {y | ContDiffAt ğ•œ n f.symm y âˆ§ ContDiffAt ğ•œ n f (f.symm y)} := fun x hx â†¦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ âŸ¨hxs, hxf, hxf'âŸ© â†¦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.restrContDiff_symm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\naâœ : F\nâŠ¢ Eq (â†‘(PartialHomeomorph.restrContDiff ğ•œ f n hn).symm aâœ) (â†‘f.symm aâœ)","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x âˆˆ f.source`, `y = f x âˆˆ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `Ï‰`, but not `âˆ`,\nbecause the set of points of `C^âˆ`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop â„•âˆ) (hn : n â‰  âˆ) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt ğ•œ n f x âˆ§ ContDiffAt ğ•œ n f.symm (f x)}\n      {y | ContDiffAt ğ•œ n f.symm y âˆ§ ContDiffAt ğ•œ n f (f.symm y)} := fun x hx â†¦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ âŸ¨hxs, hxf, hxf'âŸ© â†¦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.restrContDiff_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\naâœ : E\nâŠ¢ Eq (â†‘(PartialHomeomorph.restrContDiff ğ•œ f n hn) aâœ) (â†‘f aâœ)","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x âˆˆ f.source`, `y = f x âˆˆ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `Ï‰`, but not `âˆ`,\nbecause the set of points of `C^âˆ`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop â„•âˆ) (hn : n â‰  âˆ) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt ğ•œ n f x âˆ§ ContDiffAt ğ•œ n f.symm (f x)}\n      {y | ContDiffAt ğ•œ n f.symm y âˆ§ ContDiffAt ğ•œ n f (f.symm y)} := fun x hx â†¦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ âŸ¨hxs, hxf, hxf'âŸ© â†¦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.contDiffOn_restrContDiff_source","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ ContDiffOn ğ•œ n (â†‘f) (PartialHomeomorph.restrContDiff ğ•œ f n hn).source","decl":"lemma contDiffOn_restrContDiff_source (f : PartialHomeomorph E F) {n : WithTop â„•âˆ} (hn : n â‰  âˆ) :\n    ContDiffOn ğ•œ n f (f.restrContDiff ğ•œ n hn).source := fun _x hx â†¦ hx.2.1.contDiffWithinAt\n\n"}
{"name":"PartialHomeomorph.contDiffOn_restrContDiff_target","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœâ´ : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœÂ³ : NormedAddCommGroup E\ninstâœÂ² : NormedSpace ğ•œ E\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n â†‘Top.top\nâŠ¢ ContDiffOn ğ•œ n (â†‘f.symm) (PartialHomeomorph.restrContDiff ğ•œ f n hn).target","decl":"lemma contDiffOn_restrContDiff_target (f : PartialHomeomorph E F) {n : WithTop â„•âˆ} (hn : n â‰  âˆ) :\n    ContDiffOn ğ•œ n f.symm (f.restrContDiff ğ•œ n hn).target := fun _x hx â†¦ hx.2.1.contDiffWithinAt\n\n"}
{"name":"contDiffOn_succ_iff_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhs : UniqueDiffOn ğ•œ sâ‚‚\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) fâ‚‚ sâ‚‚) (And (DifferentiableOn ğ•œ fâ‚‚ sâ‚‚) (And (Eq n Top.top â†’ AnalyticOn ğ•œ fâ‚‚ sâ‚‚) (ContDiffOn ğ•œ n (derivWithin fâ‚‚ sâ‚‚) sâ‚‚)))","decl":"/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (formulated with `derivWithin`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_derivWithin (hs : UniqueDiffOn ğ•œ sâ‚‚) :\n    ContDiffOn ğ•œ (n + 1) fâ‚‚ sâ‚‚ â†”\n      DifferentiableOn ğ•œ fâ‚‚ sâ‚‚ âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ fâ‚‚ sâ‚‚) âˆ§\n        ContDiffOn ğ•œ n (derivWithin fâ‚‚ sâ‚‚) sâ‚‚ := by\n  rw [contDiffOn_succ_iff_fderivWithin hs, and_congr_right_iff]\n  intro _\n  constructor\n  Â· rintro âŸ¨h', hâŸ©\n    refine âŸ¨h', ?_âŸ©\n    have : derivWithin fâ‚‚ sâ‚‚ = (fun u : ğ•œ â†’L[ğ•œ] F => u 1) âˆ˜ fderivWithin ğ•œ fâ‚‚ sâ‚‚ := by\n      ext x; rfl\n    simp_rw [this]\n    apply ContDiff.comp_contDiffOn _ h\n    exact (isBoundedBilinearMap_apply.isBoundedLinearMap_left _).contDiff\n  Â· rintro âŸ¨h', hâŸ©\n    refine âŸ¨h', ?_âŸ©\n    have : fderivWithin ğ•œ fâ‚‚ sâ‚‚ = smulRight (1 : ğ•œ â†’L[ğ•œ] ğ•œ) âˆ˜ derivWithin fâ‚‚ sâ‚‚ := by\n      ext x; simp [derivWithin]\n    simp only [this]\n    apply ContDiff.comp_contDiffOn _ h\n    have : IsBoundedBilinearMap ğ•œ fun _ : (ğ•œ â†’L[ğ•œ] ğ•œ) Ã— F => _ := isBoundedBilinearMap_smulRight\n    exact (this.isBoundedLinearMap_right _).contDiff\n\n"}
{"name":"contDiffOn_infty_iff_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhs : UniqueDiffOn ğ•œ sâ‚‚\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) fâ‚‚ sâ‚‚) (And (DifferentiableOn ğ•œ fâ‚‚ sâ‚‚) (ContDiffOn ğ•œ (â†‘Top.top) (derivWithin fâ‚‚ sâ‚‚) sâ‚‚))","decl":"theorem contDiffOn_infty_iff_derivWithin (hs : UniqueDiffOn ğ•œ sâ‚‚) :\n    ContDiffOn ğ•œ âˆ fâ‚‚ sâ‚‚ â†” DifferentiableOn ğ•œ fâ‚‚ sâ‚‚ âˆ§ ContDiffOn ğ•œ âˆ (derivWithin fâ‚‚ sâ‚‚) sâ‚‚ := by\n  rw [show âˆ = âˆ + 1 by rfl, contDiffOn_succ_iff_derivWithin hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhs : UniqueDiffOn ğ•œ sâ‚‚\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) fâ‚‚ sâ‚‚) (And (DifferentiableOn ğ•œ fâ‚‚ sâ‚‚) (ContDiffOn ğ•œ (â†‘Top.top) (derivWithin fâ‚‚ sâ‚‚) sâ‚‚))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_derivWithin := contDiffOn_infty_iff_derivWithin\n\n"}
{"name":"contDiffOn_succ_iff_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhs : IsOpen sâ‚‚\nâŠ¢ Iff (ContDiffOn ğ•œ (HAdd.hAdd n 1) fâ‚‚ sâ‚‚) (And (DifferentiableOn ğ•œ fâ‚‚ sâ‚‚) (And (Eq n Top.top â†’ AnalyticOn ğ•œ fâ‚‚ sâ‚‚) (ContDiffOn ğ•œ n (deriv fâ‚‚) sâ‚‚)))","decl":"/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_deriv_of_isOpen (hs : IsOpen sâ‚‚) :\n    ContDiffOn ğ•œ (n + 1) fâ‚‚ sâ‚‚ â†”\n      DifferentiableOn ğ•œ fâ‚‚ sâ‚‚ âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ fâ‚‚ sâ‚‚) âˆ§\n        ContDiffOn ğ•œ n (deriv fâ‚‚) sâ‚‚ := by\n  rw [contDiffOn_succ_iff_derivWithin hs.uniqueDiffOn]\n  exact Iff.rfl.and (Iff.rfl.and (contDiffOn_congr fun _ => derivWithin_of_isOpen hs))\n\n"}
{"name":"contDiffOn_infty_iff_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhs : IsOpen sâ‚‚\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) fâ‚‚ sâ‚‚) (And (DifferentiableOn ğ•œ fâ‚‚ sâ‚‚) (ContDiffOn ğ•œ (â†‘Top.top) (deriv fâ‚‚) sâ‚‚))","decl":"theorem contDiffOn_infty_iff_deriv_of_isOpen (hs : IsOpen sâ‚‚) :\n    ContDiffOn ğ•œ âˆ fâ‚‚ sâ‚‚ â†” DifferentiableOn ğ•œ fâ‚‚ sâ‚‚ âˆ§ ContDiffOn ğ•œ âˆ (deriv fâ‚‚) sâ‚‚ := by\n  rw [show âˆ = âˆ + 1 by rfl, contDiffOn_succ_iff_deriv_of_isOpen hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhs : IsOpen sâ‚‚\nâŠ¢ Iff (ContDiffOn ğ•œ (â†‘Top.top) fâ‚‚ sâ‚‚) (And (DifferentiableOn ğ•œ fâ‚‚ sâ‚‚) (ContDiffOn ğ•œ (â†‘Top.top) (deriv fâ‚‚) sâ‚‚))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_deriv_of_isOpen := contDiffOn_infty_iff_deriv_of_isOpen\n\n"}
{"name":"ContDiffOn.derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nm n : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhf : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚\nhs : UniqueDiffOn ğ•œ sâ‚‚\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffOn ğ•œ m (derivWithin fâ‚‚ sâ‚‚) sâ‚‚","decl":"protected theorem ContDiffOn.derivWithin (hf : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚) (hs : UniqueDiffOn ğ•œ sâ‚‚)\n    (hmn : m + 1 â‰¤ n) : ContDiffOn ğ•œ m (derivWithin fâ‚‚ sâ‚‚) sâ‚‚ :=\n  ((contDiffOn_succ_iff_derivWithin hs).1 (hf.of_le hmn)).2.2\n\n"}
{"name":"ContDiffOn.deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nm n : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nhf : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚\nhs : IsOpen sâ‚‚\nhmn : LE.le (HAdd.hAdd m 1) n\nâŠ¢ ContDiffOn ğ•œ m (deriv fâ‚‚) sâ‚‚","decl":"theorem ContDiffOn.deriv_of_isOpen (hf : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚) (hs : IsOpen sâ‚‚) (hmn : m + 1 â‰¤ n) :\n    ContDiffOn ğ•œ m (deriv fâ‚‚) sâ‚‚ :=\n  (hf.derivWithin hs.uniqueDiffOn hmn).congr fun _ hx => (derivWithin_of_isOpen hs hx).symm\n\n"}
{"name":"ContDiffOn.continuousOn_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nh : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚\nhs : UniqueDiffOn ğ•œ sâ‚‚\nhn : LE.le 1 n\nâŠ¢ ContinuousOn (derivWithin fâ‚‚ sâ‚‚) sâ‚‚","decl":"theorem ContDiffOn.continuousOn_derivWithin (h : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚) (hs : UniqueDiffOn ğ•œ sâ‚‚)\n    (hn : 1 â‰¤ n) : ContinuousOn (derivWithin fâ‚‚ sâ‚‚) sâ‚‚ := by\n  rw [show (1 : WithTop â„•âˆ) = 0 + 1 from rfl] at hn\n  exact ((contDiffOn_succ_iff_derivWithin hs).1 (h.of_le hn)).2.2.continuousOn\n\n"}
{"name":"ContDiffOn.continuousOn_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nsâ‚‚ : Set ğ•œ\nh : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚\nhs : IsOpen sâ‚‚\nhn : LE.le 1 n\nâŠ¢ ContinuousOn (deriv fâ‚‚) sâ‚‚","decl":"theorem ContDiffOn.continuousOn_deriv_of_isOpen (h : ContDiffOn ğ•œ n fâ‚‚ sâ‚‚) (hs : IsOpen sâ‚‚)\n    (hn : 1 â‰¤ n) : ContinuousOn (deriv fâ‚‚) sâ‚‚ := by\n  rw [show (1 : WithTop â„•âˆ) = 0 + 1 from rfl] at hn\n  exact ((contDiffOn_succ_iff_deriv_of_isOpen hs).1 (h.of_le hn)).2.2.continuousOn\n\n"}
{"name":"contDiff_succ_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (HAdd.hAdd n 1) fâ‚‚) (And (Differentiable ğ•œ fâ‚‚) (And (Eq n Top.top â†’ AnalyticOn ğ•œ fâ‚‚ Set.univ) (ContDiff ğ•œ n (deriv fâ‚‚))))","decl":"/-- A function is `C^(n + 1)` if and only if it is differentiable,\n  and its derivative (formulated in terms of `deriv`) is `C^n`. -/\ntheorem contDiff_succ_iff_deriv :\n    ContDiff ğ•œ (n + 1) fâ‚‚ â†” Differentiable ğ•œ fâ‚‚ âˆ§ (n = Ï‰ â†’ AnalyticOn ğ•œ fâ‚‚ univ) âˆ§\n      ContDiff ğ•œ n (deriv fâ‚‚) := by\n  simp only [â† contDiffOn_univ, contDiffOn_succ_iff_deriv_of_isOpen, isOpen_univ,\n    differentiableOn_univ]\n\n"}
{"name":"contDiff_one_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nâŠ¢ Iff (ContDiff ğ•œ 1 fâ‚‚) (And (Differentiable ğ•œ fâ‚‚) (Continuous (deriv fâ‚‚)))","decl":"theorem contDiff_one_iff_deriv :\n    ContDiff ğ•œ 1 fâ‚‚ â†” Differentiable ğ•œ fâ‚‚ âˆ§ Continuous (deriv fâ‚‚) := by\n  rw [show (1 : WithTop â„•âˆ) = 0 + 1 from rfl, contDiff_succ_iff_deriv]\n  simp\n\n"}
{"name":"contDiff_infty_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) fâ‚‚) (And (Differentiable ğ•œ fâ‚‚) (ContDiff ğ•œ (â†‘Top.top) (deriv fâ‚‚)))","decl":"theorem contDiff_infty_iff_deriv :\n    ContDiff ğ•œ âˆ fâ‚‚ â†” Differentiable ğ•œ fâ‚‚ âˆ§ ContDiff ğ•œ âˆ (deriv fâ‚‚) := by\n  rw [show (âˆ : WithTop â„•âˆ) = âˆ + 1 from rfl, contDiff_succ_iff_deriv]\n  simp\n\n"}
{"name":"contDiff_top_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nfâ‚‚ : ğ•œ â†’ F\nâŠ¢ Iff (ContDiff ğ•œ (â†‘Top.top) fâ‚‚) (And (Differentiable ğ•œ fâ‚‚) (ContDiff ğ•œ (â†‘Top.top) (deriv fâ‚‚)))","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiff_top_iff_deriv := contDiff_infty_iff_deriv\n\n"}
{"name":"ContDiff.continuous_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : WithTop ENat\nfâ‚‚ : ğ•œ â†’ F\nh : ContDiff ğ•œ n fâ‚‚\nhn : LE.le 1 n\nâŠ¢ Continuous (deriv fâ‚‚)","decl":"theorem ContDiff.continuous_deriv (h : ContDiff ğ•œ n fâ‚‚) (hn : 1 â‰¤ n) : Continuous (deriv fâ‚‚) := by\n  rw [show (1 : WithTop â„•âˆ) = 0 + 1 from rfl] at hn\n  exact (contDiff_succ_iff_deriv.mp (h.of_le hn)).2.2.continuous\n\n"}
{"name":"ContDiff.iterate_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn : Nat\nfâ‚‚ : ğ•œ â†’ F\naâœ : ContDiff ğ•œ (â†‘Top.top) fâ‚‚\nâŠ¢ ContDiff ğ•œ (â†‘Top.top) (Nat.iterate deriv n fâ‚‚)","decl":"theorem ContDiff.iterate_deriv :\n    âˆ€ (n : â„•) {fâ‚‚ : ğ•œ â†’ F}, ContDiff ğ•œ âˆ fâ‚‚ â†’ ContDiff ğ•œ âˆ (deriv^[n] fâ‚‚)\n  | 0,     _, hf => hf\n  | n + 1, _, hf => ContDiff.iterate_deriv n (contDiff_infty_iff_deriv.mp hf).2\n\n"}
{"name":"ContDiff.iterate_deriv'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ² : NontriviallyNormedField ğ•œ\nF : Type uF\ninstâœÂ¹ : NormedAddCommGroup F\ninstâœ : NormedSpace ğ•œ F\nn k : Nat\nfâ‚‚ : ğ•œ â†’ F\naâœ : ContDiff ğ•œ (â†‘(HAdd.hAdd n k)) fâ‚‚\nâŠ¢ ContDiff ğ•œ (â†‘n) (Nat.iterate deriv k fâ‚‚)","decl":"theorem ContDiff.iterate_deriv' (n : â„•) :\n    âˆ€ (k : â„•) {fâ‚‚ : ğ•œ â†’ F}, ContDiff ğ•œ (n + k : â„•) fâ‚‚ â†’ ContDiff ğ•œ n (deriv^[k] fâ‚‚)\n  | 0,     _, hf => hf\n  | k + 1, _, hf => ContDiff.iterate_deriv' _ k (contDiff_succ_iff_deriv.mp hf).2.2\n\n"}
{"name":"HasFTaylorSeriesUpToOn.restrictScalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nğ•œ' : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\np' : E â†’ FormalMultilinearSeries ğ•œ' E F\nn : WithTop ENat\nh : HasFTaylorSeriesUpToOn n f p' s\nâŠ¢ HasFTaylorSeriesUpToOn n f (fun x => FormalMultilinearSeries.restrictScalars ğ•œ (p' x)) s","decl":"theorem HasFTaylorSeriesUpToOn.restrictScalars {n : WithTop â„•âˆ}\n    (h : HasFTaylorSeriesUpToOn n f p' s) :\n    HasFTaylorSeriesUpToOn n f (fun x => (p' x).restrictScalars ğ•œ) s where\n  zero_eq x hx := h.zero_eq x hx\n  fderivWithin m hm x hx :=\n    set_option maxSynthPendingDepth 2 in\n    ((ContinuousMultilinearMap.restrictScalarsLinear ğ•œ).hasFDerivAt.comp_hasFDerivWithinAt x <|\n        (h.fderivWithin m hm x hx).restrictScalars ğ•œ :)\n  cont m hm := ContinuousMultilinearMap.continuous_restrictScalars.comp_continuousOn (h.cont m hm)\n\n"}
{"name":"ContDiffWithinAt.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nx : E\nn : WithTop ENat\nğ•œ' : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ContDiffWithinAt ğ•œ' n f s x\nâŠ¢ ContDiffWithinAt ğ•œ n f s x","decl":"theorem ContDiffWithinAt.restrict_scalars (h : ContDiffWithinAt ğ•œ' n f s x) :\n    ContDiffWithinAt ğ•œ n f s x := by\n  match n with\n  | Ï‰ =>\n    obtain âŸ¨u, u_mem, p', hp', Hp'âŸ© := h\n    refine âŸ¨u, u_mem, _, hp'.restrictScalars _, fun i â†¦ ?_âŸ©\n    change AnalyticOn ğ•œ (fun x â†¦ ContinuousMultilinearMap.restrictScalarsLinear ğ•œ (p' x i)) u\n    apply AnalyticOnNhd.comp_analyticOn _ (Hp' i).restrictScalars (Set.mapsTo_univ _ _)\n    exact ContinuousLinearMap.analyticOnNhd _ _\n  | (n : â„•âˆ) =>\n    intro m hm\n    rcases h m hm with âŸ¨u, u_mem, p', hp'âŸ©\n    exact âŸ¨u, u_mem, _, hp'.restrictScalars _âŸ©\n\n"}
{"name":"ContDiffOn.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\ns : Set E\nf : E â†’ F\nn : WithTop ENat\nğ•œ' : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ContDiffOn ğ•œ' n f s\nâŠ¢ ContDiffOn ğ•œ n f s","decl":"theorem ContDiffOn.restrict_scalars (h : ContDiffOn ğ•œ' n f s) : ContDiffOn ğ•œ n f s := fun x hx =>\n  (h x hx).restrict_scalars _\n\n"}
{"name":"ContDiffAt.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nf : E â†’ F\nx : E\nn : WithTop ENat\nğ•œ' : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ContDiffAt ğ•œ' n f x\nâŠ¢ ContDiffAt ğ•œ n f x","decl":"theorem ContDiffAt.restrict_scalars (h : ContDiffAt ğ•œ' n f x) : ContDiffAt ğ•œ n f x :=\n  contDiffWithinAt_univ.1 <| h.contDiffWithinAt.restrict_scalars _\n\n"}
{"name":"ContDiff.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"ğ•œ : Type u_1\ninstâœÂ¹â° : NontriviallyNormedField ğ•œ\nE : Type uE\ninstâœâ¹ : NormedAddCommGroup E\ninstâœâ¸ : NormedSpace ğ•œ E\nF : Type uF\ninstâœâ· : NormedAddCommGroup F\ninstâœâ¶ : NormedSpace ğ•œ F\nf : E â†’ F\nn : WithTop ENat\nğ•œ' : Type u_3\ninstâœâµ : NontriviallyNormedField ğ•œ'\ninstâœâ´ : NormedAlgebra ğ•œ ğ•œ'\ninstâœÂ³ : NormedSpace ğ•œ' E\ninstâœÂ² : IsScalarTower ğ•œ ğ•œ' E\ninstâœÂ¹ : NormedSpace ğ•œ' F\ninstâœ : IsScalarTower ğ•œ ğ•œ' F\nh : ContDiff ğ•œ' n f\nâŠ¢ ContDiff ğ•œ n f","decl":"theorem ContDiff.restrict_scalars (h : ContDiff ğ•œ' n f) : ContDiff ğ•œ n f :=\n  contDiff_iff_contDiffAt.2 fun _ => h.contDiffAt.restrict_scalars _\n\n"}
