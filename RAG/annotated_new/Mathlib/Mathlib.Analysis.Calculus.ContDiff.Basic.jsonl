{"name":"iteratedFDerivWithin_succ_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nn : Nat\nc : F\n⊢ Eq (iteratedFDerivWithin 𝕜 (HAdd.hAdd n 1) (fun x => c) s) 0","decl":"theorem iteratedFDerivWithin_succ_const (n : ℕ) (c : F) :\n    iteratedFDerivWithin 𝕜 (n + 1) (fun _ : E ↦ c) s = 0 := by\n  induction n  with\n  | zero =>\n    ext1\n    simp [iteratedFDerivWithin_succ_eq_comp_left, iteratedFDerivWithin_zero_eq_comp, comp_def]\n  | succ n IH =>\n    rw [iteratedFDerivWithin_succ_eq_comp_left, IH]\n    simp only [Pi.zero_def, comp_def, fderivWithin_const, map_zero]\n\n"}
{"name":"iteratedFDerivWithin_zero_fun","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\ni : Nat\n⊢ Eq (iteratedFDerivWithin 𝕜 i (fun x => 0) s) 0","decl":"@[simp]\ntheorem iteratedFDerivWithin_zero_fun {i : ℕ} :\n    iteratedFDerivWithin 𝕜 i (fun _ : E ↦ (0 : F)) s = 0 := by\n  cases i with\n  | zero => ext; simp\n  | succ i => apply iteratedFDerivWithin_succ_const\n\n"}
{"name":"iteratedFDeriv_zero_fun","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\n⊢ Eq (iteratedFDeriv 𝕜 n fun x => 0) 0","decl":"@[simp]\ntheorem iteratedFDeriv_zero_fun {n : ℕ} : (iteratedFDeriv 𝕜 n fun _ : E ↦ (0 : F)) = 0 :=\n  funext fun x ↦ by simp only [← iteratedFDerivWithin_univ, iteratedFDerivWithin_zero_fun]\n\n"}
{"name":"contDiff_zero_fun","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\n⊢ ContDiff 𝕜 n fun x => 0","decl":"theorem contDiff_zero_fun : ContDiff 𝕜 n fun _ : E => (0 : F) :=\n  analyticOnNhd_const.contDiff\n\n"}
{"name":"contDiff_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nc : F\n⊢ ContDiff 𝕜 n fun x => c","decl":"/-- Constants are `C^∞`.\n-/\ntheorem contDiff_const {c : F} : ContDiff 𝕜 n fun _ : E => c :=\n  analyticOnNhd_const.contDiff\n\n"}
{"name":"contDiffOn_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nc : F\ns : Set E\n⊢ ContDiffOn 𝕜 n (fun x => c) s","decl":"theorem contDiffOn_const {c : F} {s : Set E} : ContDiffOn 𝕜 n (fun _ : E => c) s :=\n  contDiff_const.contDiffOn\n\n"}
{"name":"contDiffAt_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\nc : F\n⊢ ContDiffAt 𝕜 n (fun x => c) x","decl":"theorem contDiffAt_const {c : F} : ContDiffAt 𝕜 n (fun _ : E => c) x :=\n  contDiff_const.contDiffAt\n\n"}
{"name":"contDiffWithinAt_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nx : E\nn : WithTop ENat\nc : F\n⊢ ContDiffWithinAt 𝕜 n (fun x => c) s x","decl":"theorem contDiffWithinAt_const {c : F} : ContDiffWithinAt 𝕜 n (fun _ : E => c) s x :=\n  contDiffAt_const.contDiffWithinAt\n\n"}
{"name":"contDiff_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\ninst✝ : Subsingleton F\n⊢ ContDiff 𝕜 n f","decl":"@[nontriviality]\ntheorem contDiff_of_subsingleton [Subsingleton F] : ContDiff 𝕜 n f := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiff_const\n\n"}
{"name":"contDiffAt_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\ninst✝ : Subsingleton F\n⊢ ContDiffAt 𝕜 n f x","decl":"@[nontriviality]\ntheorem contDiffAt_of_subsingleton [Subsingleton F] : ContDiffAt 𝕜 n f x := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiffAt_const\n\n"}
{"name":"contDiffWithinAt_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ninst✝ : Subsingleton F\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"@[nontriviality]\ntheorem contDiffWithinAt_of_subsingleton [Subsingleton F] : ContDiffWithinAt 𝕜 n f s x := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiffWithinAt_const\n\n"}
{"name":"contDiffOn_of_subsingleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\ninst✝ : Subsingleton F\n⊢ ContDiffOn 𝕜 n f s","decl":"@[nontriviality]\ntheorem contDiffOn_of_subsingleton [Subsingleton F] : ContDiffOn 𝕜 n f s := by\n  rw [Subsingleton.elim f fun _ => 0]; exact contDiffOn_const\n\n"}
{"name":"iteratedFDerivWithin_const_of_ne","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nhn : Ne n 0\nc : F\ns : Set E\n⊢ Eq (iteratedFDerivWithin 𝕜 n (fun x => c) s) 0","decl":"theorem iteratedFDerivWithin_const_of_ne {n : ℕ} (hn : n ≠ 0) (c : F) (s : Set E) :\n    iteratedFDerivWithin 𝕜 n (fun _ : E ↦ c) s = 0 := by\n  cases n with\n  | zero => contradiction\n  | succ n => exact iteratedFDerivWithin_succ_const n c\n\n"}
{"name":"iteratedFDeriv_const_of_ne","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nhn : Ne n 0\nc : F\n⊢ Eq (iteratedFDeriv 𝕜 n fun x => c) 0","decl":"theorem iteratedFDeriv_const_of_ne {n : ℕ} (hn : n ≠ 0) (c : F) :\n    (iteratedFDeriv 𝕜 n fun _ : E ↦ c) = 0 := by\n  simp only [← iteratedFDerivWithin_univ, iteratedFDerivWithin_const_of_ne hn]\n\n"}
{"name":"iteratedFDeriv_succ_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nc : F\n⊢ Eq (iteratedFDeriv 𝕜 (HAdd.hAdd n 1) fun x => c) 0","decl":"theorem iteratedFDeriv_succ_const (n : ℕ) (c : F) :\n    (iteratedFDeriv 𝕜 (n + 1) fun _ : E ↦ c) = 0 :=\n  iteratedFDeriv_const_of_ne (by simp) _\n\n"}
{"name":"contDiffWithinAt_singleton","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\n⊢ ContDiffWithinAt 𝕜 n f (Singleton.singleton x) x","decl":"theorem contDiffWithinAt_singleton : ContDiffWithinAt 𝕜 n f {x} x :=\n  (contDiffWithinAt_const (c := f x)).congr (by simp) rfl\n\n"}
{"name":"IsBoundedLinearMap.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\nhf : IsBoundedLinearMap 𝕜 f\n⊢ ContDiff 𝕜 n f","decl":"/-- Unbundled bounded linear functions are `C^n`.\n-/\ntheorem IsBoundedLinearMap.contDiff (hf : IsBoundedLinearMap 𝕜 f) : ContDiff 𝕜 n f :=\n  (ContinuousLinearMap.analyticOnNhd hf.toContinuousLinearMap univ).contDiff\n\n"}
{"name":"ContinuousLinearMap.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : ContinuousLinearMap (RingHom.id 𝕜) E F\n⊢ ContDiff 𝕜 n ⇑f","decl":"theorem ContinuousLinearMap.contDiff (f : E →L[𝕜] F) : ContDiff 𝕜 n f :=\n  f.isBoundedLinearMap.contDiff\n\n"}
{"name":"ContinuousLinearEquiv.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ ContDiff 𝕜 n ⇑f","decl":"theorem ContinuousLinearEquiv.contDiff (f : E ≃L[𝕜] F) : ContDiff 𝕜 n f :=\n  (f : E →L[𝕜] F).contDiff\n\n"}
{"name":"LinearIsometry.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : LinearIsometry (RingHom.id 𝕜) E F\n⊢ ContDiff 𝕜 n ⇑f","decl":"theorem LinearIsometry.contDiff (f : E →ₗᵢ[𝕜] F) : ContDiff 𝕜 n f :=\n  f.toContinuousLinearMap.contDiff\n\n"}
{"name":"LinearIsometryEquiv.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : LinearIsometryEquiv (RingHom.id 𝕜) E F\n⊢ ContDiff 𝕜 n ⇑f","decl":"theorem LinearIsometryEquiv.contDiff (f : E ≃ₗᵢ[𝕜] F) : ContDiff 𝕜 n f :=\n  (f : E →L[𝕜] F).contDiff\n\n"}
{"name":"contDiff_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nn : WithTop ENat\n⊢ ContDiff 𝕜 n id","decl":"/-- The identity is `C^n`.\n-/\ntheorem contDiff_id : ContDiff 𝕜 n (id : E → E) :=\n  IsBoundedLinearMap.id.contDiff\n\n"}
{"name":"contDiffWithinAt_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nn : WithTop ENat\ns : Set E\nx : E\n⊢ ContDiffWithinAt 𝕜 n id s x","decl":"theorem contDiffWithinAt_id {s x} : ContDiffWithinAt 𝕜 n (id : E → E) s x :=\n  contDiff_id.contDiffWithinAt\n\n"}
{"name":"contDiffAt_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nn : WithTop ENat\nx : E\n⊢ ContDiffAt 𝕜 n id x","decl":"theorem contDiffAt_id {x} : ContDiffAt 𝕜 n (id : E → E) x :=\n  contDiff_id.contDiffAt\n\n"}
{"name":"contDiffOn_id","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nn : WithTop ENat\ns : Set E\n⊢ ContDiffOn 𝕜 n id s","decl":"theorem contDiffOn_id {s} : ContDiffOn 𝕜 n (id : E → E) s :=\n  contDiff_id.contDiffOn\n\n"}
{"name":"IsBoundedBilinearMap.contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nb : Prod E F → G\nn : WithTop ENat\nhb : IsBoundedBilinearMap 𝕜 b\n⊢ ContDiff 𝕜 n b","decl":"/-- Bilinear functions are `C^n`.\n-/\ntheorem IsBoundedBilinearMap.contDiff (hb : IsBoundedBilinearMap 𝕜 b) : ContDiff 𝕜 n b :=\n  (hb.toContinuousLinearMap.analyticOnNhd_bilinear _).contDiff\n\n"}
{"name":"HasFTaylorSeriesUpToOn.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\np : E → FormalMultilinearSeries 𝕜 E F\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : HasFTaylorSeriesUpToOn n f p s\n⊢ HasFTaylorSeriesUpToOn n (Function.comp (⇑g) f) (fun x k => g.compContinuousMultilinearMap (p x k)) s","decl":"/-- If `f` admits a Taylor series `p` in a set `s`, and `g` is linear, then `g ∘ f` admits a Taylor\nseries whose `k`-th term is given by `g ∘ (p k)`. -/\ntheorem HasFTaylorSeriesUpToOn.continuousLinearMap_comp {n : WithTop ℕ∞} (g : F →L[𝕜] G)\n    (hf : HasFTaylorSeriesUpToOn n f p s) :\n    HasFTaylorSeriesUpToOn n (g ∘ f) (fun x k => g.compContinuousMultilinearMap (p x k)) s where\n  zero_eq x hx := congr_arg g (hf.zero_eq x hx)\n  fderivWithin m hm x hx := (ContinuousLinearMap.compContinuousMultilinearMapL 𝕜\n    (fun _ : Fin m => E) F G g).hasFDerivAt.comp_hasFDerivWithinAt x (hf.fderivWithin m hm x hx)\n  cont m hm := (ContinuousLinearMap.compContinuousMultilinearMapL 𝕜\n    (fun _ : Fin m => E) F G g).continuous.comp_continuousOn (hf.cont m hm)\n\n"}
{"name":"ContDiffWithinAt.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp (⇑g) f) s x","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions in a domain\nat a point. -/\ntheorem ContDiffWithinAt.continuousLinearMap_comp (g : F →L[𝕜] G)\n    (hf : ContDiffWithinAt 𝕜 n f s x) : ContDiffWithinAt 𝕜 n (g ∘ f) s x := by\n  match n with\n  | ω =>\n    obtain ⟨u, hu, p, hp, h'p⟩ := hf\n    refine ⟨u, hu, _, hp.continuousLinearMap_comp g, fun i ↦ ?_⟩\n    change AnalyticOn 𝕜\n      (fun x ↦ (ContinuousLinearMap.compContinuousMultilinearMapL 𝕜\n      (fun _ : Fin i ↦ E) F G g) (p x i)) u\n    apply AnalyticOnNhd.comp_analyticOn _ (h'p i) (Set.mapsTo_univ _ _)\n    exact ContinuousLinearMap.analyticOnNhd _ _\n  | (n : ℕ∞) =>\n    intro m hm\n    rcases hf m hm with ⟨u, hu, p, hp⟩\n    exact ⟨u, hu, _, hp.continuousLinearMap_comp g⟩\n\n"}
{"name":"ContDiffAt.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\nx : E\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (Function.comp (⇑g) f) x","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions in a domain\nat a point. -/\ntheorem ContDiffAt.continuousLinearMap_comp (g : F →L[𝕜] G) (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (g ∘ f) x :=\n  ContDiffWithinAt.continuousLinearMap_comp g hf\n\n"}
{"name":"ContDiffOn.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (Function.comp (⇑g) f) s","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions on domains. -/\ntheorem ContDiffOn.continuousLinearMap_comp (g : F →L[𝕜] G) (hf : ContDiffOn 𝕜 n f s) :\n    ContDiffOn 𝕜 n (g ∘ f) s := fun x hx => (hf x hx).continuousLinearMap_comp g\n\n"}
{"name":"ContDiff.continuousLinearMap_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → F\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => g (f x)","decl":"/-- Composition by continuous linear maps on the left preserves `C^n` functions. -/\ntheorem ContDiff.continuousLinearMap_comp {f : E → F} (g : F →L[𝕜] G) (hf : ContDiff 𝕜 n f) :\n    ContDiff 𝕜 n fun x => g (f x) :=\n  contDiffOn_univ.1 <| ContDiffOn.continuousLinearMap_comp _ (contDiffOn_univ.2 hf)\n\n"}
{"name":"ContinuousLinearMap.iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx : E\nn : WithTop ENat\nf : E → F\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Function.comp (⇑g) f) s x) (g.compContinuousMultilinearMap (iteratedFDerivWithin 𝕜 i f s x))","decl":"/-- The iterated derivative within a set of the composition with a linear map on the left is\nobtained by applying the linear map to the iterated derivative. -/\ntheorem ContinuousLinearMap.iteratedFDerivWithin_comp_left {f : E → F} (g : F →L[𝕜] G)\n    (hf : ContDiffWithinAt 𝕜 n f s x) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {i : ℕ} (hi : i ≤ n) :\n    iteratedFDerivWithin 𝕜 i (g ∘ f) s x =\n      g.compContinuousMultilinearMap (iteratedFDerivWithin 𝕜 i f s x) := by\n  rcases hf.contDiffOn' hi (by simp) with ⟨U, hU, hxU, hfU⟩\n  rw [← iteratedFDerivWithin_inter_open hU hxU, ← iteratedFDerivWithin_inter_open (f := f) hU hxU]\n  rw [insert_eq_of_mem hx] at hfU\n  exact .symm <| (hfU.ftaylorSeriesWithin (hs.inter hU)).continuousLinearMap_comp g\n    |>.eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl (hs.inter hU) ⟨hx, hxU⟩\n\n"}
{"name":"ContinuousLinearMap.iteratedFDeriv_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nn : WithTop ENat\nf : E → F\ng : ContinuousLinearMap (RingHom.id 𝕜) F G\nhf : ContDiffAt 𝕜 n f x\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDeriv 𝕜 i (Function.comp (⇑g) f) x) (g.compContinuousMultilinearMap (iteratedFDeriv 𝕜 i f x))","decl":"/-- The iterated derivative of the composition with a linear map on the left is\nobtained by applying the linear map to the iterated derivative. -/\ntheorem ContinuousLinearMap.iteratedFDeriv_comp_left {f : E → F} (g : F →L[𝕜] G)\n    (hf : ContDiffAt 𝕜 n f x) {i : ℕ} (hi : i ≤ n) :\n    iteratedFDeriv 𝕜 i (g ∘ f) x = g.compContinuousMultilinearMap (iteratedFDeriv 𝕜 i f x) := by\n  simp only [← iteratedFDerivWithin_univ]\n  exact g.iteratedFDerivWithin_comp_left hf.contDiffWithinAt uniqueDiffOn_univ (mem_univ x) hi\n\n"}
{"name":"ContinuousLinearEquiv.iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx : E\ng : ContinuousLinearEquiv (RingHom.id 𝕜) F G\nf : E → F\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\ni : Nat\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Function.comp (⇑g) f) s x) ((↑g).compContinuousMultilinearMap (iteratedFDerivWithin 𝕜 i f s x))","decl":"/-- The iterated derivative within a set of the composition with a linear equiv on the left is\nobtained by applying the linear equiv to the iterated derivative. This is true without\ndifferentiability assumptions. -/\ntheorem ContinuousLinearEquiv.iteratedFDerivWithin_comp_left (g : F ≃L[𝕜] G) (f : E → F)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (i : ℕ) :\n    iteratedFDerivWithin 𝕜 i (g ∘ f) s x =\n      (g : F →L[𝕜] G).compContinuousMultilinearMap (iteratedFDerivWithin 𝕜 i f s x) := by\n  induction' i with i IH generalizing x\n  · ext1 m\n    simp only [iteratedFDerivWithin_zero_apply, comp_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, coe_coe]\n  · ext1 m\n    rw [iteratedFDerivWithin_succ_apply_left]\n    have Z : fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 i (g ∘ f) s) s x =\n        fderivWithin 𝕜 (g.compContinuousMultilinearMapL (fun _ : Fin i => E) ∘\n          iteratedFDerivWithin 𝕜 i f s) s x :=\n      fderivWithin_congr' (@IH) hx\n    simp_rw [Z]\n    rw [(g.compContinuousMultilinearMapL fun _ : Fin i => E).comp_fderivWithin (hs x hx)]\n    simp only [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, comp_apply,\n      ContinuousLinearEquiv.compContinuousMultilinearMapL_apply,\n      ContinuousLinearMap.compContinuousMultilinearMap_coe, EmbeddingLike.apply_eq_iff_eq]\n    rw [iteratedFDerivWithin_succ_apply_left]\n\n"}
{"name":"LinearIsometry.norm_iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx : E\nn : WithTop ENat\nf : E → F\ng : LinearIsometry (RingHom.id 𝕜) F G\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (Norm.norm (iteratedFDerivWithin 𝕜 i (Function.comp (⇑g) f) s x)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))","decl":"/-- Composition with a linear isometry on the left preserves the norm of the iterated\nderivative within a set. -/\ntheorem LinearIsometry.norm_iteratedFDerivWithin_comp_left {f : E → F} (g : F →ₗᵢ[𝕜] G)\n    (hf : ContDiffWithinAt 𝕜 n f s x) (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) {i : ℕ} (hi : i ≤ n) :\n    ‖iteratedFDerivWithin 𝕜 i (g ∘ f) s x‖ = ‖iteratedFDerivWithin 𝕜 i f s x‖ := by\n  have :\n    iteratedFDerivWithin 𝕜 i (g ∘ f) s x =\n      g.toContinuousLinearMap.compContinuousMultilinearMap (iteratedFDerivWithin 𝕜 i f s x) :=\n    g.toContinuousLinearMap.iteratedFDerivWithin_comp_left hf hs hx hi\n  rw [this]\n  apply LinearIsometry.norm_compContinuousMultilinearMap\n\n"}
{"name":"LinearIsometry.norm_iteratedFDeriv_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nn : WithTop ENat\nf : E → F\ng : LinearIsometry (RingHom.id 𝕜) F G\nhf : ContDiffAt 𝕜 n f x\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (Norm.norm (iteratedFDeriv 𝕜 i (Function.comp (⇑g) f) x)) (Norm.norm (iteratedFDeriv 𝕜 i f x))","decl":"/-- Composition with a linear isometry on the left preserves the norm of the iterated\nderivative. -/\ntheorem LinearIsometry.norm_iteratedFDeriv_comp_left {f : E → F} (g : F →ₗᵢ[𝕜] G)\n    (hf : ContDiffAt 𝕜 n f x) {i : ℕ} (hi : i ≤ n) :\n    ‖iteratedFDeriv 𝕜 i (g ∘ f) x‖ = ‖iteratedFDeriv 𝕜 i f x‖ := by\n  simp only [← iteratedFDerivWithin_univ]\n  exact g.norm_iteratedFDerivWithin_comp_left hf.contDiffWithinAt uniqueDiffOn_univ (mem_univ x) hi\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx : E\ng : LinearIsometryEquiv (RingHom.id 𝕜) F G\nf : E → F\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\ni : Nat\n⊢ Eq (Norm.norm (iteratedFDerivWithin 𝕜 i (Function.comp (⇑g) f) s x)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s x))","decl":"/-- Composition with a linear isometry equiv on the left preserves the norm of the iterated\nderivative within a set. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_left (g : F ≃ₗᵢ[𝕜] G) (f : E → F)\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (i : ℕ) :\n    ‖iteratedFDerivWithin 𝕜 i (g ∘ f) s x‖ = ‖iteratedFDerivWithin 𝕜 i f s x‖ := by\n  have :\n    iteratedFDerivWithin 𝕜 i (g ∘ f) s x =\n      (g : F →L[𝕜] G).compContinuousMultilinearMap (iteratedFDerivWithin 𝕜 i f s x) :=\n    g.toContinuousLinearEquiv.iteratedFDerivWithin_comp_left f hs hx i\n  rw [this]\n  apply LinearIsometry.norm_compContinuousMultilinearMap g.toLinearIsometry\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDeriv_comp_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : LinearIsometryEquiv (RingHom.id 𝕜) F G\nf : E → F\nx : E\ni : Nat\n⊢ Eq (Norm.norm (iteratedFDeriv 𝕜 i (Function.comp (⇑g) f) x)) (Norm.norm (iteratedFDeriv 𝕜 i f x))","decl":"/-- Composition with a linear isometry equiv on the left preserves the norm of the iterated\nderivative. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDeriv_comp_left (g : F ≃ₗᵢ[𝕜] G) (f : E → F) (x : E)\n    (i : ℕ) : ‖iteratedFDeriv 𝕜 i (g ∘ f) x‖ = ‖iteratedFDeriv 𝕜 i f x‖ := by\n  rw [← iteratedFDerivWithin_univ, ← iteratedFDerivWithin_univ]\n  apply g.norm_iteratedFDerivWithin_comp_left f uniqueDiffOn_univ (mem_univ x) i\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiffWithinAt_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) F G\n⊢ Iff (ContDiffWithinAt 𝕜 n (Function.comp (⇑e) f) s x) (ContDiffWithinAt 𝕜 n f s x)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint in a domain. -/\ntheorem ContinuousLinearEquiv.comp_contDiffWithinAt_iff (e : F ≃L[𝕜] G) :\n    ContDiffWithinAt 𝕜 n (e ∘ f) s x ↔ ContDiffWithinAt 𝕜 n f s x :=\n  ⟨fun H => by\n    simpa only [Function.comp_def, e.symm.coe_coe, e.symm_apply_apply] using\n      H.continuousLinearMap_comp (e.symm : G →L[𝕜] F),\n    fun H => H.continuousLinearMap_comp (e : F →L[𝕜] G)⟩\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiffAt_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) F G\n⊢ Iff (ContDiffAt 𝕜 n (Function.comp (⇑e) f) x) (ContDiffAt 𝕜 n f x)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability at a\npoint. -/\ntheorem ContinuousLinearEquiv.comp_contDiffAt_iff (e : F ≃L[𝕜] G) :\n    ContDiffAt 𝕜 n (e ∘ f) x ↔ ContDiffAt 𝕜 n f x := by\n  simp only [← contDiffWithinAt_univ, e.comp_contDiffWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiffOn_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) F G\n⊢ Iff (ContDiffOn 𝕜 n (Function.comp (⇑e) f) s) (ContDiffOn 𝕜 n f s)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability on\ndomains. -/\ntheorem ContinuousLinearEquiv.comp_contDiffOn_iff (e : F ≃L[𝕜] G) :\n    ContDiffOn 𝕜 n (e ∘ f) s ↔ ContDiffOn 𝕜 n f s := by\n  simp [ContDiffOn, e.comp_contDiffWithinAt_iff]\n\n"}
{"name":"ContinuousLinearEquiv.comp_contDiff_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) F G\n⊢ Iff (ContDiff 𝕜 n (Function.comp (⇑e) f)) (ContDiff 𝕜 n f)","decl":"/-- Composition by continuous linear equivs on the left respects higher differentiability. -/\ntheorem ContinuousLinearEquiv.comp_contDiff_iff (e : F ≃L[𝕜] G) :\n    ContDiff 𝕜 n (e ∘ f) ↔ ContDiff 𝕜 n f := by\n  simp only [← contDiffOn_univ, e.comp_contDiffOn_iff]\n\n"}
{"name":"HasFTaylorSeriesUpToOn.compContinuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nn : WithTop ENat\np : E → FormalMultilinearSeries 𝕜 E F\nhf : HasFTaylorSeriesUpToOn n f p s\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ HasFTaylorSeriesUpToOn n (Function.comp f ⇑g) (fun x k => (p (g x) k).compContinuousLinearMap fun x => g) (Set.preimage (⇑g) s)","decl":"/-- If `f` admits a Taylor series `p` in a set `s`, and `g` is linear, then `f ∘ g` admits a Taylor\nseries in `g ⁻¹' s`, whose `k`-th term is given by `p k (g v₁, ..., g vₖ)` . -/\ntheorem HasFTaylorSeriesUpToOn.compContinuousLinearMap\n    (hf : HasFTaylorSeriesUpToOn n f p s) (g : G →L[𝕜] E) :\n    HasFTaylorSeriesUpToOn n (f ∘ g) (fun x k => (p (g x) k).compContinuousLinearMap fun _ => g)\n      (g ⁻¹' s) := by\n  let A : ∀ m : ℕ, (E[×m]→L[𝕜] F) → G[×m]→L[𝕜] F := fun m h => h.compContinuousLinearMap fun _ => g\n  have hA : ∀ m, IsBoundedLinearMap 𝕜 (A m) := fun m =>\n    isBoundedLinearMap_continuousMultilinearMap_comp_linear g\n  constructor\n  · intro x hx\n    simp only [(hf.zero_eq (g x) hx).symm, Function.comp_apply]\n    change (p (g x) 0 fun _ : Fin 0 => g 0) = p (g x) 0 0\n    rw [ContinuousLinearMap.map_zero]\n    rfl\n  · intro m hm x hx\n    convert (hA m).hasFDerivAt.comp_hasFDerivWithinAt x\n        ((hf.fderivWithin m hm (g x) hx).comp x g.hasFDerivWithinAt (Subset.refl _))\n    ext y v\n    change p (g x) (Nat.succ m) (g ∘ cons y v) = p (g x) m.succ (cons (g y) (g ∘ v))\n    rw [comp_cons]\n  · intro m hm\n    exact (hA m).continuous.comp_continuousOn <| (hf.cont m hm).comp g.continuous.continuousOn <|\n      Subset.refl _\n\n"}
{"name":"ContDiffWithinAt.comp_continuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nn : WithTop ENat\nx : G\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\nhf : ContDiffWithinAt 𝕜 n f s (g x)\n⊢ ContDiffWithinAt 𝕜 n (Function.comp f ⇑g) (Set.preimage (⇑g) s) x","decl":"/-- Composition by continuous linear maps on the right preserves `C^n` functions at a point on\na domain. -/\ntheorem ContDiffWithinAt.comp_continuousLinearMap {x : G} (g : G →L[𝕜] E)\n    (hf : ContDiffWithinAt 𝕜 n f s (g x)) : ContDiffWithinAt 𝕜 n (f ∘ g) (g ⁻¹' s) x := by\n  match n with\n  | ω =>\n    obtain ⟨u, hu, p, hp, h'p⟩ := hf\n    refine ⟨g ⁻¹' u, ?_, _, hp.compContinuousLinearMap g, ?_⟩\n    · refine g.continuous.continuousWithinAt.tendsto_nhdsWithin ?_ hu\n      exact (mapsTo_singleton.2 <| mem_singleton _).union_union (mapsTo_preimage _ _)\n    · intro i\n      change AnalyticOn 𝕜 (fun x ↦\n        ContinuousMultilinearMap.compContinuousLinearMapL (fun _ ↦ g) (p (g x) i)) (⇑g ⁻¹' u)\n      apply AnalyticOn.comp _ _ (Set.mapsTo_univ _ _)\n      · exact ContinuousLinearEquiv.analyticOn _ _\n      · exact (h'p i).comp (g.analyticOn _) (mapsTo_preimage _ _)\n  | (n : ℕ∞) =>\n    intro m hm\n    rcases hf m hm with ⟨u, hu, p, hp⟩\n    refine ⟨g ⁻¹' u, ?_, _, hp.compContinuousLinearMap g⟩\n    refine g.continuous.continuousWithinAt.tendsto_nhdsWithin ?_ hu\n    exact (mapsTo_singleton.2 <| mem_singleton _).union_union (mapsTo_preimage _ _)\n\n"}
{"name":"ContDiffOn.comp_continuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nn : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\n⊢ ContDiffOn 𝕜 n (Function.comp f ⇑g) (Set.preimage (⇑g) s)","decl":"/-- Composition by continuous linear maps on the right preserves `C^n` functions on domains. -/\ntheorem ContDiffOn.comp_continuousLinearMap (hf : ContDiffOn 𝕜 n f s) (g : G →L[𝕜] E) :\n    ContDiffOn 𝕜 n (f ∘ g) (g ⁻¹' s) := fun x hx => (hf (g x) hx).comp_continuousLinearMap g\n\n"}
{"name":"ContDiff.comp_continuousLinearMap","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → F\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n (Function.comp f ⇑g)","decl":"/-- Composition by continuous linear maps on the right preserves `C^n` functions. -/\ntheorem ContDiff.comp_continuousLinearMap {f : E → F} {g : G →L[𝕜] E} (hf : ContDiff 𝕜 n f) :\n    ContDiff 𝕜 n (f ∘ g) :=\n  contDiffOn_univ.1 <| ContDiffOn.comp_continuousLinearMap (contDiffOn_univ.2 hf) _\n\n"}
{"name":"ContinuousLinearMap.iteratedFDerivWithin_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nn : WithTop ENat\nf : E → F\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\nhf : ContDiffOn 𝕜 n f s\nhs : UniqueDiffOn 𝕜 s\nh's : UniqueDiffOn 𝕜 (Set.preimage (⇑g) s)\nx : G\nhx : Membership.mem s (g x)\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Function.comp f ⇑g) (Set.preimage (⇑g) s) x) ((iteratedFDerivWithin 𝕜 i f s (g x)).compContinuousLinearMap fun x => g)","decl":"/-- The iterated derivative within a set of the composition with a linear map on the right is\nobtained by composing the iterated derivative with the linear map. -/\ntheorem ContinuousLinearMap.iteratedFDerivWithin_comp_right {f : E → F} (g : G →L[𝕜] E)\n    (hf : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s) (h's : UniqueDiffOn 𝕜 (g ⁻¹' s)) {x : G}\n    (hx : g x ∈ s) {i : ℕ} (hi : i ≤ n) :\n    iteratedFDerivWithin 𝕜 i (f ∘ g) (g ⁻¹' s) x =\n      (iteratedFDerivWithin 𝕜 i f s (g x)).compContinuousLinearMap fun _ => g :=\n  ((((hf.of_le hi).ftaylorSeriesWithin hs).compContinuousLinearMap\n    g).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl h's hx).symm\n\n"}
{"name":"ContinuousLinearEquiv.iteratedFDerivWithin_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\ng : ContinuousLinearEquiv (RingHom.id 𝕜) G E\nf : E → F\nhs : UniqueDiffOn 𝕜 s\nx : G\nhx : Membership.mem s (g x)\ni : Nat\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Function.comp f ⇑g) (Set.preimage (⇑g) s) x) ((iteratedFDerivWithin 𝕜 i f s (g x)).compContinuousLinearMap fun x => ↑g)","decl":"/-- The iterated derivative within a set of the composition with a linear equiv on the right is\nobtained by composing the iterated derivative with the linear equiv. -/\ntheorem ContinuousLinearEquiv.iteratedFDerivWithin_comp_right (g : G ≃L[𝕜] E) (f : E → F)\n    (hs : UniqueDiffOn 𝕜 s) {x : G} (hx : g x ∈ s) (i : ℕ) :\n    iteratedFDerivWithin 𝕜 i (f ∘ g) (g ⁻¹' s) x =\n      (iteratedFDerivWithin 𝕜 i f s (g x)).compContinuousLinearMap fun _ => g := by\n  induction' i with i IH generalizing x\n  · ext1\n    simp only [iteratedFDerivWithin_zero_apply, comp_apply,\n     ContinuousMultilinearMap.compContinuousLinearMap_apply]\n  · ext1 m\n    simp only [ContinuousMultilinearMap.compContinuousLinearMap_apply,\n      ContinuousLinearEquiv.coe_coe, iteratedFDerivWithin_succ_apply_left]\n    have : fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 i (f ∘ g) (g ⁻¹' s)) (g ⁻¹' s) x =\n        fderivWithin 𝕜\n          (ContinuousMultilinearMap.compContinuousLinearMapEquivL _ (fun _x : Fin i => g) ∘\n            (iteratedFDerivWithin 𝕜 i f s ∘ g)) (g ⁻¹' s) x :=\n      fderivWithin_congr' (@IH) hx\n    rw [this, ContinuousLinearEquiv.comp_fderivWithin _ (g.uniqueDiffOn_preimage_iff.2 hs x hx)]\n    simp only [ContinuousLinearMap.coe_comp', ContinuousLinearEquiv.coe_coe, comp_apply,\n      ContinuousMultilinearMap.compContinuousLinearMapEquivL_apply,\n      ContinuousMultilinearMap.compContinuousLinearMap_apply]\n    rw [ContinuousLinearEquiv.comp_right_fderivWithin _ (g.uniqueDiffOn_preimage_iff.2 hs x hx),\n      ContinuousLinearMap.coe_comp', coe_coe, comp_apply, tail_def, tail_def]\n\n"}
{"name":"ContinuousLinearMap.iteratedFDeriv_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ng : ContinuousLinearMap (RingHom.id 𝕜) G E\nf : E → F\nhf : ContDiff 𝕜 n f\nx : G\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDeriv 𝕜 i (Function.comp f ⇑g) x) ((iteratedFDeriv 𝕜 i f (g x)).compContinuousLinearMap fun x => g)","decl":"/-- The iterated derivative of the composition with a linear map on the right is\nobtained by composing the iterated derivative with the linear map. -/\ntheorem ContinuousLinearMap.iteratedFDeriv_comp_right (g : G →L[𝕜] E) {f : E → F}\n    (hf : ContDiff 𝕜 n f) (x : G) {i : ℕ} (hi : i ≤ n) :\n    iteratedFDeriv 𝕜 i (f ∘ g) x =\n      (iteratedFDeriv 𝕜 i f (g x)).compContinuousLinearMap fun _ => g := by\n  simp only [← iteratedFDerivWithin_univ]\n  exact g.iteratedFDerivWithin_comp_right hf.contDiffOn uniqueDiffOn_univ uniqueDiffOn_univ\n      (mem_univ _) hi\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\ng : LinearIsometryEquiv (RingHom.id 𝕜) G E\nf : E → F\nhs : UniqueDiffOn 𝕜 s\nx : G\nhx : Membership.mem s (g x)\ni : Nat\n⊢ Eq (Norm.norm (iteratedFDerivWithin 𝕜 i (Function.comp f ⇑g) (Set.preimage (⇑g) s) x)) (Norm.norm (iteratedFDerivWithin 𝕜 i f s (g x)))","decl":"/-- Composition with a linear isometry on the right preserves the norm of the iterated derivative\nwithin a set. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDerivWithin_comp_right (g : G ≃ₗᵢ[𝕜] E) (f : E → F)\n    (hs : UniqueDiffOn 𝕜 s) {x : G} (hx : g x ∈ s) (i : ℕ) :\n    ‖iteratedFDerivWithin 𝕜 i (f ∘ g) (g ⁻¹' s) x‖ = ‖iteratedFDerivWithin 𝕜 i f s (g x)‖ := by\n  have : iteratedFDerivWithin 𝕜 i (f ∘ g) (g ⁻¹' s) x =\n      (iteratedFDerivWithin 𝕜 i f s (g x)).compContinuousLinearMap fun _ => g :=\n    g.toContinuousLinearEquiv.iteratedFDerivWithin_comp_right f hs hx i\n  rw [this, ContinuousMultilinearMap.norm_compContinuous_linearIsometryEquiv]\n\n"}
{"name":"LinearIsometryEquiv.norm_iteratedFDeriv_comp_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ng : LinearIsometryEquiv (RingHom.id 𝕜) G E\nf : E → F\nx : G\ni : Nat\n⊢ Eq (Norm.norm (iteratedFDeriv 𝕜 i (Function.comp f ⇑g) x)) (Norm.norm (iteratedFDeriv 𝕜 i f (g x)))","decl":"/-- Composition with a linear isometry on the right preserves the norm of the iterated derivative\nwithin a set. -/\ntheorem LinearIsometryEquiv.norm_iteratedFDeriv_comp_right (g : G ≃ₗᵢ[𝕜] E) (f : E → F) (x : G)\n    (i : ℕ) : ‖iteratedFDeriv 𝕜 i (f ∘ g) x‖ = ‖iteratedFDeriv 𝕜 i f (g x)‖ := by\n  simp only [← iteratedFDerivWithin_univ]\n  apply g.norm_iteratedFDerivWithin_comp_right f uniqueDiffOn_univ (mem_univ (g x)) i\n\n"}
{"name":"ContinuousLinearEquiv.contDiffWithinAt_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) G E\n⊢ Iff (ContDiffWithinAt 𝕜 n (Function.comp f ⇑e) (Set.preimage (⇑e) s) (e.symm x)) (ContDiffWithinAt 𝕜 n f s x)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint in a domain. -/\ntheorem ContinuousLinearEquiv.contDiffWithinAt_comp_iff (e : G ≃L[𝕜] E) :\n    ContDiffWithinAt 𝕜 n (f ∘ e) (e ⁻¹' s) (e.symm x) ↔ ContDiffWithinAt 𝕜 n f s x := by\n  constructor\n  · intro H\n    simpa [← preimage_comp, Function.comp_def] using H.comp_continuousLinearMap (e.symm : E →L[𝕜] G)\n  · intro H\n    rw [← e.apply_symm_apply x, ← e.coe_coe] at H\n    exact H.comp_continuousLinearMap _\n\n"}
{"name":"ContinuousLinearEquiv.contDiffAt_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\nx : E\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) G E\n⊢ Iff (ContDiffAt 𝕜 n (Function.comp f ⇑e) (e.symm x)) (ContDiffAt 𝕜 n f x)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability at a\npoint. -/\ntheorem ContinuousLinearEquiv.contDiffAt_comp_iff (e : G ≃L[𝕜] E) :\n    ContDiffAt 𝕜 n (f ∘ e) (e.symm x) ↔ ContDiffAt 𝕜 n f x := by\n  rw [← contDiffWithinAt_univ, ← contDiffWithinAt_univ, ← preimage_univ]\n  exact e.contDiffWithinAt_comp_iff\n\n"}
{"name":"ContinuousLinearEquiv.contDiffOn_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) G E\n⊢ Iff (ContDiffOn 𝕜 n (Function.comp f ⇑e) (Set.preimage (⇑e) s)) (ContDiffOn 𝕜 n f s)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability on\ndomains. -/\ntheorem ContinuousLinearEquiv.contDiffOn_comp_iff (e : G ≃L[𝕜] E) :\n    ContDiffOn 𝕜 n (f ∘ e) (e ⁻¹' s) ↔ ContDiffOn 𝕜 n f s :=\n  ⟨fun H => by simpa [Function.comp_def] using H.comp_continuousLinearMap (e.symm : E →L[𝕜] G),\n    fun H => H.comp_continuousLinearMap (e : G →L[𝕜] E)⟩\n\n"}
{"name":"ContinuousLinearEquiv.contDiff_comp_iff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\nn : WithTop ENat\ne : ContinuousLinearEquiv (RingHom.id 𝕜) G E\n⊢ Iff (ContDiff 𝕜 n (Function.comp f ⇑e)) (ContDiff 𝕜 n f)","decl":"/-- Composition by continuous linear equivs on the right respects higher differentiability. -/\ntheorem ContinuousLinearEquiv.contDiff_comp_iff (e : G ≃L[𝕜] E) :\n    ContDiff 𝕜 n (f ∘ e) ↔ ContDiff 𝕜 n f := by\n  rw [← contDiffOn_univ, ← contDiffOn_univ, ← preimage_univ]\n  exact e.contDiffOn_comp_iff\n\n"}
{"name":"HasFTaylorSeriesUpToOn.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\np : E → FormalMultilinearSeries 𝕜 E F\nn : WithTop ENat\nhf : HasFTaylorSeriesUpToOn n f p s\ng : E → G\nq : E → FormalMultilinearSeries 𝕜 E G\nhg : HasFTaylorSeriesUpToOn n g q s\n⊢ HasFTaylorSeriesUpToOn n (fun y => { fst := f y, snd := g y }) (fun y k => (p y k).prod (q y k)) s","decl":"/-- If two functions `f` and `g` admit Taylor series `p` and `q` in a set `s`, then the cartesian\nproduct of `f` and `g` admits the cartesian product of `p` and `q` as a Taylor series. -/\ntheorem HasFTaylorSeriesUpToOn.prod {n : WithTop ℕ∞}\n    (hf : HasFTaylorSeriesUpToOn n f p s) {g : E → G}\n    {q : E → FormalMultilinearSeries 𝕜 E G} (hg : HasFTaylorSeriesUpToOn n g q s) :\n    HasFTaylorSeriesUpToOn n (fun y => (f y, g y)) (fun y k => (p y k).prod (q y k)) s := by\n  set L := fun m => ContinuousMultilinearMap.prodL 𝕜 (fun _ : Fin m => E) F G\n  constructor\n  · intro x hx; rw [← hf.zero_eq x hx, ← hg.zero_eq x hx]; rfl\n  · intro m hm x hx\n    convert (L m).hasFDerivAt.comp_hasFDerivWithinAt x\n        ((hf.fderivWithin m hm x hx).prod (hg.fderivWithin m hm x hx))\n  · intro m hm\n    exact (L m).continuous.comp_continuousOn ((hf.cont m hm).prod (hg.cont m hm))\n\n"}
{"name":"ContDiffWithinAt.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nn : WithTop ENat\ns : Set E\nf : E → F\ng : E → G\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => { fst := f x, snd := g x }) s x","decl":"/-- The cartesian product of `C^n` functions at a point in a domain is `C^n`. -/\ntheorem ContDiffWithinAt.prod {s : Set E} {f : E → F} {g : E → G} (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (fun x : E => (f x, g x)) s x := by\n  match n with\n  | ω =>\n    obtain ⟨u, hu, p, hp, h'p⟩ := hf\n    obtain ⟨v, hv, q, hq, h'q⟩ := hg\n    refine ⟨u ∩ v, Filter.inter_mem hu hv, _,\n      (hp.mono inter_subset_left).prod (hq.mono inter_subset_right), fun i ↦ ?_⟩\n    change AnalyticOn 𝕜 (fun x ↦ ContinuousMultilinearMap.prodL _ _ _ _ (p x i, q x i))\n      (u ∩ v)\n    apply AnalyticOnNhd.comp_analyticOn (LinearIsometryEquiv.analyticOnNhd _ _) _\n      (Set.mapsTo_univ _ _)\n    exact ((h'p i).mono inter_subset_left).prod ((h'q i).mono inter_subset_right)\n  | (n : ℕ∞) =>\n    intro m hm\n    rcases hf m hm with ⟨u, hu, p, hp⟩\n    rcases hg m hm with ⟨v, hv, q, hq⟩\n    exact\n      ⟨u ∩ v, Filter.inter_mem hu hv, _,\n        (hp.mono inter_subset_left).prod (hq.mono inter_subset_right)⟩\n\n"}
{"name":"ContDiffOn.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nf : E → F\ng : E → G\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => { fst := f x, snd := g x }) s","decl":"/-- The cartesian product of `C^n` functions on domains is `C^n`. -/\ntheorem ContDiffOn.prod {s : Set E} {f : E → F} {g : E → G} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (fun x : E => (f x, g x)) s := fun x hx =>\n  (hf x hx).prod (hg x hx)\n\n"}
{"name":"ContDiffAt.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nn : WithTop ENat\nf : E → F\ng : E → G\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => { fst := f x, snd := g x }) x","decl":"/-- The cartesian product of `C^n` functions at a point is `C^n`. -/\ntheorem ContDiffAt.prod {f : E → F} {g : E → G} (hf : ContDiffAt 𝕜 n f x)\n    (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (fun x : E => (f x, g x)) x :=\n  contDiffWithinAt_univ.1 <|\n    ContDiffWithinAt.prod (contDiffWithinAt_univ.2 hf) (contDiffWithinAt_univ.2 hg)\n\n"}
{"name":"ContDiff.prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → F\ng : E → G\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => { fst := f x, snd := g x }","decl":"/-- The cartesian product of `C^n` functions is `C^n`. -/\ntheorem ContDiff.prod {f : E → F} {g : E → G} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) :\n    ContDiff 𝕜 n fun x : E => (f x, g x) :=\n  contDiffOn_univ.1 <| ContDiffOn.prod (contDiffOn_univ.2 hf) (contDiffOn_univ.2 hg)\n\n"}
{"name":"ContDiffWithinAt.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\nst : Set.MapsTo f s t\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hf : ContDiffWithinAt 𝕜 n f s x) (st : MapsTo f s t) :\n    ContDiffWithinAt 𝕜 n (g ∘ f) s x := by\n  match n with\n  | ω =>\n    have h'f : ContDiffWithinAt 𝕜 ω f s x := hf\n    obtain ⟨u, hu, p, hp, h'p⟩ := h'f\n    obtain ⟨v, hv, q, hq, h'q⟩ := hg\n    let w := insert x s ∩ (u ∩ f ⁻¹' v)\n    have wv : w ⊆ f ⁻¹' v := fun y hy => hy.2.2\n    have wu : w ⊆ u := fun y hy => hy.2.1\n    refine ⟨w, ?_, fun y ↦ (q (f y)).taylorComp (p y), hq.comp (hp.mono wu) wv, ?_⟩\n    · apply inter_mem self_mem_nhdsWithin (inter_mem hu ?_)\n      apply (continuousWithinAt_insert_self.2 hf.continuousWithinAt).preimage_mem_nhdsWithin'\n      apply nhdsWithin_mono _ _ hv\n      simp only [image_insert_eq]\n      apply insert_subset_insert\n      exact image_subset_iff.mpr st\n    · have : AnalyticOn 𝕜 f w := by\n        have : AnalyticOn 𝕜 (fun y ↦ (continuousMultilinearCurryFin0 𝕜 E F).symm (f y)) w :=\n          ((h'p 0).mono wu).congr  fun y hy ↦ (hp.zero_eq' (wu hy)).symm\n        have : AnalyticOn 𝕜 (fun y ↦ (continuousMultilinearCurryFin0 𝕜 E F)\n            ((continuousMultilinearCurryFin0 𝕜 E F).symm (f y))) w :=\n          AnalyticOnNhd.comp_analyticOn (LinearIsometryEquiv.analyticOnNhd _ _ ) this\n          (mapsTo_univ _ _)\n        simpa using this\n      exact analyticOn_taylorComp h'q (fun n ↦ (h'p n).mono wu) this wv\n  | (n : ℕ∞) =>\n    intro m hm\n    rcases hf m hm with ⟨u, hu, p, hp⟩\n    rcases hg m hm with ⟨v, hv, q, hq⟩\n    let w := insert x s ∩ (u ∩ f ⁻¹' v)\n    have wv : w ⊆ f ⁻¹' v := fun y hy => hy.2.2\n    have wu : w ⊆ u := fun y hy => hy.2.1\n    refine ⟨w, ?_, fun y ↦ (q (f y)).taylorComp (p y), hq.comp (hp.mono wu) wv⟩\n    apply inter_mem self_mem_nhdsWithin (inter_mem hu ?_)\n    apply (continuousWithinAt_insert_self.2 hf.continuousWithinAt).preimage_mem_nhdsWithin'\n    apply nhdsWithin_mono _ _ hv\n    simp only [image_insert_eq]\n    apply insert_subset_insert\n    exact image_subset_iff.mpr st\n\n"}
{"name":"ContDiffOn.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nhg : ContDiffOn 𝕜 n g t\nhf : ContDiffOn 𝕜 n f s\nst : Set.MapsTo f s t\n⊢ ContDiffOn 𝕜 n (Function.comp g f) s","decl":"/-- The composition of `C^n` functions on domains is `C^n`. -/\ntheorem ContDiffOn.comp {s : Set E} {t : Set F} {g : F → G} {f : E → F} (hg : ContDiffOn 𝕜 n g t)\n    (hf : ContDiffOn 𝕜 n f s) (st : MapsTo f s t) : ContDiffOn 𝕜 n (g ∘ f) s :=\n  fun x hx ↦ ContDiffWithinAt.comp x (hg (f x) (st hx)) (hf x hx) st\n\n"}
{"name":"ContDiffOn.comp_inter","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nhg : ContDiffOn 𝕜 n g t\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (Function.comp g f) (Inter.inter s (Set.preimage f t))","decl":"/-- The composition of `C^n` functions on domains is `C^n`. -/\ntheorem ContDiffOn.comp_inter\n    {s : Set E} {t : Set F} {g : F → G} {f : E → F} (hg : ContDiffOn 𝕜 n g t)\n    (hf : ContDiffOn 𝕜 n f s) : ContDiffOn 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t) :=\n  hg.comp (hf.mono inter_subset_left) inter_subset_right\n\n"}
{"name":"ContDiffOn.comp'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nhg : ContDiffOn 𝕜 n g t\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (Function.comp g f) (Inter.inter s (Set.preimage f t))","decl":"@[deprecated (since := \"2024-10-30\")] alias ContDiffOn.comp' := ContDiffOn.comp_inter\n\n"}
{"name":"ContDiff.comp_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\ng : F → G\nf : E → F\nhg : ContDiff 𝕜 n g\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (Function.comp g f) s","decl":"/-- The composition of a `C^n` function on a domain with a `C^n` function is `C^n`. -/\ntheorem ContDiff.comp_contDiffOn {s : Set E} {g : F → G} {f : E → F} (hg : ContDiff 𝕜 n g)\n    (hf : ContDiffOn 𝕜 n f s) : ContDiffOn 𝕜 n (g ∘ f) s :=\n  (contDiffOn_univ.2 hg).comp hf (mapsTo_univ _ _)\n\n"}
{"name":"ContDiffOn.comp_contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set F\ng : F → G\nf : E → F\nhg : ContDiffOn 𝕜 n g s\nhf : ContDiff 𝕜 n f\nhs : ∀ (x : E), Membership.mem s (f x)\n⊢ ContDiff 𝕜 n (Function.comp g f)","decl":"theorem ContDiffOn.comp_contDiff {s : Set F} {g : F → G} {f : E → F} (hg : ContDiffOn 𝕜 n g s)\n    (hf : ContDiff 𝕜 n f) (hs : ∀ x, f x ∈ s) : ContDiff 𝕜 n (g ∘ f) := by\n  rw [← contDiffOn_univ] at *\n  exact hg.comp hf fun x _ => hs x\n\n"}
{"name":"ContDiffOn.image_comp_contDiff","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\ng : F → G\nf : E → F\nhg : ContDiffOn 𝕜 n g (Set.image f s)\nhf : ContDiff 𝕜 n f\n⊢ ContDiffOn 𝕜 n (Function.comp g f) s","decl":"theorem ContDiffOn.image_comp_contDiff {s : Set E} {g : F → G} {f : E → F}\n    (hg : ContDiffOn 𝕜 n g (f '' s)) (hf : ContDiff 𝕜 n f) : ContDiffOn 𝕜 n (g ∘ f) s :=\n  hg.comp hf.contDiffOn (s.mapsTo_image f)\n\n"}
{"name":"ContDiff.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ng : F → G\nf : E → F\nhg : ContDiff 𝕜 n g\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n (Function.comp g f)","decl":"/-- The composition of `C^n` functions is `C^n`. -/\ntheorem ContDiff.comp {g : F → G} {f : E → F} (hg : ContDiff 𝕜 n g) (hf : ContDiff 𝕜 n f) :\n    ContDiff 𝕜 n (g ∘ f) :=\n  contDiffOn_univ.1 <| ContDiffOn.comp (contDiffOn_univ.2 hg) (contDiffOn_univ.2 hf) (subset_univ _)\n\n"}
{"name":"ContDiffWithinAt.comp_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\ny : F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t y\nhf : ContDiffWithinAt 𝕜 n f s x\nst : Set.MapsTo f s t\nhy : Eq (f x) y\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp_of_eq {s : Set E} {t : Set F} {g : F → G} {f : E → F} {y : F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t y) (hf : ContDiffWithinAt 𝕜 n f s x) (st : MapsTo f s t)\n    (hy : f x = y) :\n    ContDiffWithinAt 𝕜 n (g ∘ f) s x := by\n  subst hy; exact hg.comp x hf st\n\n"}
{"name":"ContDiffWithinAt.comp_of_mem_nhdsWithin_image","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : Membership.mem (nhdsWithin (f x) (Set.image f s)) t\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_mem_nhdsWithin_image\n    {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hs : t ∈ 𝓝[f '' s] f x) : ContDiffWithinAt 𝕜 n (g ∘ f) s x :=\n  (hg.mono_of_mem_nhdsWithin hs).comp x hf (subset_preimage_image f s)\n\n"}
{"name":"ContDiffWithinAt.comp_of_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : Membership.mem (nhdsWithin (f x) (Set.image f s)) t\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.comp_of_mem := ContDiffWithinAt.comp_of_mem_nhdsWithin_image\n\n"}
{"name":"ContDiffWithinAt.comp_of_mem_nhdsWithin_image_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\ny : F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t y\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : Membership.mem (nhdsWithin (f x) (Set.image f s)) t\nhy : Eq (f x) y\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_mem_nhdsWithin_image_of_eq\n    {s : Set E} {t : Set F} {g : F → G} {f : E → F} {y : F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t y) (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hs : t ∈ 𝓝[f '' s] f x) (hy : f x = y) : ContDiffWithinAt 𝕜 n (g ∘ f) s x := by\n  subst hy; exact hg.comp_of_mem_nhdsWithin_image x hf hs\n\n"}
{"name":"ContDiffWithinAt.comp_inter","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp_inter {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hf : ContDiffWithinAt 𝕜 n f s x) :\n    ContDiffWithinAt 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t) x :=\n  hg.comp x (hf.mono inter_subset_left) inter_subset_right\n\n"}
{"name":"ContDiffWithinAt.comp_inter_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\ny : F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t y\nhf : ContDiffWithinAt 𝕜 n f s x\nhy : Eq (f x) y\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`. -/\ntheorem ContDiffWithinAt.comp_inter_of_eq {s : Set E} {t : Set F} {g : F → G} {f : E → F} {y : F}\n    (x : E) (hg : ContDiffWithinAt 𝕜 n g t y) (hf : ContDiffWithinAt 𝕜 n f s x) (hy : f x = y) :\n    ContDiffWithinAt 𝕜 n (g ∘ f) (s ∩ f ⁻¹' t) x := by\n  subst hy; exact hg.comp_inter x hf\n\n"}
{"name":"ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : Membership.mem (nhdsWithin x s) (Set.preimage f t)\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin\n    {s : Set E} {t : Set F} {g : F → G} {f : E → F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hs : f ⁻¹' t ∈ 𝓝[s] x) : ContDiffWithinAt 𝕜 n (g ∘ f) s x :=\n  (hg.comp_inter x hf).mono_of_mem_nhdsWithin (inter_mem self_mem_nhdsWithin hs)\n\n"}
{"name":"ContDiffWithinAt.comp'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) (Inter.inter s (Set.preimage f t)) x","decl":"@[deprecated (since := \"2024-10-18\")]\nalias ContDiffWithinAt.comp' := ContDiffWithinAt.comp_inter\n\n"}
{"name":"ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nt : Set F\ng : F → G\nf : E → F\ny : F\nx : E\nhg : ContDiffWithinAt 𝕜 n g t y\nhf : ContDiffWithinAt 𝕜 n f s x\nhs : Membership.mem (nhdsWithin x s) (Set.preimage f t)\nhy : Eq (f x) y\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"/-- The composition of `C^n` functions at points in domains is `C^n`,\n  with a weaker condition on `s` and `t`. -/\ntheorem ContDiffWithinAt.comp_of_preimage_mem_nhdsWithin_of_eq\n    {s : Set E} {t : Set F} {g : F → G} {f : E → F} {y : F} (x : E)\n    (hg : ContDiffWithinAt 𝕜 n g t y) (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hs : f ⁻¹' t ∈ 𝓝[s] x) (hy : f x = y) : ContDiffWithinAt 𝕜 n (g ∘ f) s x := by\n  subst hy; exact hg.comp_of_preimage_mem_nhdsWithin x hf hs\n\n"}
{"name":"ContDiffAt.comp_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\ng : F → G\nn : WithTop ENat\nx : E\nhg : ContDiffAt 𝕜 n g (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"theorem ContDiffAt.comp_contDiffWithinAt (x : E) (hg : ContDiffAt 𝕜 n g (f x))\n    (hf : ContDiffWithinAt 𝕜 n f s x) : ContDiffWithinAt 𝕜 n (g ∘ f) s x :=\n  hg.comp x hf (mapsTo_univ _ _)\n\n"}
{"name":"ContDiffAt.comp_contDiffWithinAt_of_eq","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\ng : F → G\nn : WithTop ENat\ny : F\nx : E\nhg : ContDiffAt 𝕜 n g y\nhf : ContDiffWithinAt 𝕜 n f s x\nhy : Eq (f x) y\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) s x","decl":"theorem ContDiffAt.comp_contDiffWithinAt_of_eq {y : F} (x : E) (hg : ContDiffAt 𝕜 n g y)\n    (hf : ContDiffWithinAt 𝕜 n f s x) (hy : f x = y) : ContDiffWithinAt 𝕜 n (g ∘ f) s x := by\n  subst hy; exact hg.comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffAt.comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : F → G\nn : WithTop ENat\nx : E\nhg : ContDiffAt 𝕜 n g (f x)\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (Function.comp g f) x","decl":"/-- The composition of `C^n` functions at points is `C^n`. -/\nnonrec theorem ContDiffAt.comp (x : E) (hg : ContDiffAt 𝕜 n g (f x)) (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (g ∘ f) x :=\n  hg.comp x hf (mapsTo_univ _ _)\n\n"}
{"name":"ContDiff.comp_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nt : Set E\nx : E\nn : WithTop ENat\ng : F → G\nf : E → F\nh : ContDiff 𝕜 n g\nhf : ContDiffWithinAt 𝕜 n f t x\n⊢ ContDiffWithinAt 𝕜 n (Function.comp g f) t x","decl":"theorem ContDiff.comp_contDiffWithinAt {g : F → G} {f : E → F} (h : ContDiff 𝕜 n g)\n    (hf : ContDiffWithinAt 𝕜 n f t x) : ContDiffWithinAt 𝕜 n (g ∘ f) t x :=\n  haveI : ContDiffWithinAt 𝕜 n g univ (f x) := h.contDiffAt.contDiffWithinAt\n  this.comp x hf (subset_univ _)\n\n"}
{"name":"ContDiff.comp_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ng : F → G\nf : E → F\nx : E\nhg : ContDiff 𝕜 n g\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (Function.comp g f) x","decl":"theorem ContDiff.comp_contDiffAt {g : F → G} {f : E → F} (x : E) (hg : ContDiff 𝕜 n g)\n    (hf : ContDiffAt 𝕜 n f x) : ContDiffAt 𝕜 n (g ∘ f) x :=\n  hg.comp_contDiffWithinAt hf\n\n"}
{"name":"iteratedFDerivWithin_comp_of_eventually_mem","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\ng : F → G\nx : E\nn : WithTop ENat\nt : Set F\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\nht : UniqueDiffOn 𝕜 t\nhs : UniqueDiffOn 𝕜 s\nhxs : Membership.mem s x\nhst : Filter.Eventually (fun y => Membership.mem t (f y)) (nhdsWithin x s)\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Function.comp g f) s x) ((ftaylorSeriesWithin 𝕜 g t (f x)).taylorComp (ftaylorSeriesWithin 𝕜 f s x) i)","decl":"theorem iteratedFDerivWithin_comp_of_eventually_mem {t : Set F}\n    (hg : ContDiffWithinAt 𝕜 n g t (f x)) (hf : ContDiffWithinAt 𝕜 n f s x)\n    (ht : UniqueDiffOn 𝕜 t) (hs : UniqueDiffOn 𝕜 s) (hxs : x ∈ s) (hst : ∀ᶠ y in 𝓝[s] x, f y ∈ t)\n    {i : ℕ} (hi : i ≤ n) :\n    iteratedFDerivWithin 𝕜 i (g ∘ f) s x =\n      (ftaylorSeriesWithin 𝕜 g t (f x)).taylorComp (ftaylorSeriesWithin 𝕜 f s x) i := by\n  obtain ⟨u, hxu, huo, hfu, hgu⟩ : ∃ u, x ∈ u ∧ IsOpen u ∧\n      HasFTaylorSeriesUpToOn i f (ftaylorSeriesWithin 𝕜 f s) (s ∩ u) ∧\n      HasFTaylorSeriesUpToOn i g (ftaylorSeriesWithin 𝕜 g t) (f '' (s ∩ u)) := by\n    have hxt : f x ∈ t := hst.self_of_nhdsWithin hxs\n    have hf_tendsto : Tendsto f (𝓝[s] x) (𝓝[t] (f x)) :=\n      tendsto_nhdsWithin_iff.mpr ⟨hf.continuousWithinAt, hst⟩\n    have H₁ : ∀ᶠ u in (𝓝[s] x).smallSets,\n        HasFTaylorSeriesUpToOn i f (ftaylorSeriesWithin 𝕜 f s) u :=\n      hf.eventually_hasFTaylorSeriesUpToOn hs hxs hi\n    have H₂ : ∀ᶠ u in (𝓝[s] x).smallSets,\n        HasFTaylorSeriesUpToOn i g (ftaylorSeriesWithin 𝕜 g t) (f '' u) :=\n      hf_tendsto.image_smallSets.eventually (hg.eventually_hasFTaylorSeriesUpToOn ht hxt hi)\n    rcases (nhdsWithin_basis_open _ _).smallSets.eventually_iff.mp (H₁.and H₂)\n      with ⟨u, ⟨hxu, huo⟩, hu⟩\n    exact ⟨u, hxu, huo, hu (by simp [inter_comm])⟩\n  exact .symm <| (hgu.comp hfu (mapsTo_image _ _)).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl\n    (hs.inter huo) ⟨hxs, hxu⟩ |>.trans <| iteratedFDerivWithin_inter_open huo hxu\n\n"}
{"name":"iteratedFDerivWithin_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nf : E → F\ng : F → G\nx : E\nn : WithTop ENat\nt : Set F\nhg : ContDiffWithinAt 𝕜 n g t (f x)\nhf : ContDiffWithinAt 𝕜 n f s x\nht : UniqueDiffOn 𝕜 t\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nhst : Set.MapsTo f s t\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Function.comp g f) s x) ((ftaylorSeriesWithin 𝕜 g t (f x)).taylorComp (ftaylorSeriesWithin 𝕜 f s x) i)","decl":"theorem iteratedFDerivWithin_comp {t : Set F} (hg : ContDiffWithinAt 𝕜 n g t (f x))\n    (hf : ContDiffWithinAt 𝕜 n f s x) (ht : UniqueDiffOn 𝕜 t) (hs : UniqueDiffOn 𝕜 s)\n    (hx : x ∈ s) (hst : MapsTo f s t) {i : ℕ} (hi : i ≤ n) :\n    iteratedFDerivWithin 𝕜 i (g ∘ f) s x =\n      (ftaylorSeriesWithin 𝕜 g t (f x)).taylorComp (ftaylorSeriesWithin 𝕜 f s x) i :=\n  iteratedFDerivWithin_comp_of_eventually_mem hg hf ht hs hx (eventually_mem_nhdsWithin.mono hst) hi\n\n"}
{"name":"iteratedFDeriv_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nf : E → F\ng : F → G\nx : E\nn : WithTop ENat\nhg : ContDiffAt 𝕜 n g (f x)\nhf : ContDiffAt 𝕜 n f x\ni : Nat\nhi : LE.le (↑i) n\n⊢ Eq (iteratedFDeriv 𝕜 i (Function.comp g f) x) ((ftaylorSeries 𝕜 g (f x)).taylorComp (ftaylorSeries 𝕜 f x) i)","decl":"theorem iteratedFDeriv_comp (hg : ContDiffAt 𝕜 n g (f x)) (hf : ContDiffAt 𝕜 n f x)\n    {i : ℕ} (hi : i ≤ n) :\n    iteratedFDeriv 𝕜 i (g ∘ f) x =\n      (ftaylorSeries 𝕜 g (f x)).taylorComp (ftaylorSeries 𝕜 f x) i := by\n  simp only [← iteratedFDerivWithin_univ, ← ftaylorSeriesWithin_univ]\n  exact iteratedFDerivWithin_comp hg.contDiffWithinAt hf.contDiffWithinAt\n    uniqueDiffOn_univ uniqueDiffOn_univ (mem_univ _) (mapsTo_univ _ _) hi\n\n"}
{"name":"contDiff_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\n⊢ ContDiff 𝕜 n Prod.fst","decl":"/-- The first projection in a product is `C^∞`. -/\ntheorem contDiff_fst : ContDiff 𝕜 n (Prod.fst : E × F → E) :=\n  IsBoundedLinearMap.contDiff IsBoundedLinearMap.fst\n\n"}
{"name":"ContDiff.fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → Prod F G\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => (f x).1","decl":"/-- Postcomposing `f` with `Prod.fst` is `C^n` -/\ntheorem ContDiff.fst {f : E → F × G} (hf : ContDiff 𝕜 n f) : ContDiff 𝕜 n fun x => (f x).1 :=\n  contDiff_fst.comp hf\n\n"}
{"name":"ContDiff.fst'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → G\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => f x.1","decl":"/-- Precomposing `f` with `Prod.fst` is `C^n` -/\ntheorem ContDiff.fst' {f : E → G} (hf : ContDiff 𝕜 n f) : ContDiff 𝕜 n fun x : E × F => f x.1 :=\n  hf.comp contDiff_fst\n\n"}
{"name":"contDiffOn_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set (Prod E F)\n⊢ ContDiffOn 𝕜 n Prod.fst s","decl":"/-- The first projection on a domain in a product is `C^∞`. -/\ntheorem contDiffOn_fst {s : Set (E × F)} : ContDiffOn 𝕜 n (Prod.fst : E × F → E) s :=\n  ContDiff.contDiffOn contDiff_fst\n\n"}
{"name":"ContDiffOn.fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → Prod F G\ns : Set E\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (fun x => (f x).1) s","decl":"theorem ContDiffOn.fst {f : E → F × G} {s : Set E} (hf : ContDiffOn 𝕜 n f s) :\n    ContDiffOn 𝕜 n (fun x => (f x).1) s :=\n  contDiff_fst.comp_contDiffOn hf\n\n"}
{"name":"contDiffAt_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\np : Prod E F\n⊢ ContDiffAt 𝕜 n Prod.fst p","decl":"/-- The first projection at a point in a product is `C^∞`. -/\ntheorem contDiffAt_fst {p : E × F} : ContDiffAt 𝕜 n (Prod.fst : E × F → E) p :=\n  contDiff_fst.contDiffAt\n\n"}
{"name":"ContDiffAt.fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → Prod F G\nx : E\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (fun x => (f x).1) x","decl":"/-- Postcomposing `f` with `Prod.fst` is `C^n` at `(x, y)` -/\ntheorem ContDiffAt.fst {f : E → F × G} {x : E} (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (fun x => (f x).1) x :=\n  contDiffAt_fst.comp x hf\n\n"}
{"name":"ContDiffAt.fst'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → G\nx : E\ny : F\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (fun x => f x.1) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.fst` is `C^n` at `(x, y)` -/\ntheorem ContDiffAt.fst' {f : E → G} {x : E} {y : F} (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (fun x : E × F => f x.1) (x, y) :=\n  ContDiffAt.comp (x, y) hf contDiffAt_fst\n\n"}
{"name":"ContDiffAt.fst''","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → G\nx : Prod E F\nhf : ContDiffAt 𝕜 n f x.1\n⊢ ContDiffAt 𝕜 n (fun x => f x.1) x","decl":"/-- Precomposing `f` with `Prod.fst` is `C^n` at `x : E × F` -/\ntheorem ContDiffAt.fst'' {f : E → G} {x : E × F} (hf : ContDiffAt 𝕜 n f x.1) :\n    ContDiffAt 𝕜 n (fun x : E × F => f x.1) x :=\n  hf.comp x contDiffAt_fst\n\n"}
{"name":"contDiffWithinAt_fst","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set (Prod E F)\np : Prod E F\n⊢ ContDiffWithinAt 𝕜 n Prod.fst s p","decl":"/-- The first projection within a domain at a point in a product is `C^∞`. -/\ntheorem contDiffWithinAt_fst {s : Set (E × F)} {p : E × F} :\n    ContDiffWithinAt 𝕜 n (Prod.fst : E × F → E) s p :=\n  contDiff_fst.contDiffWithinAt\n\n"}
{"name":"contDiff_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\n⊢ ContDiff 𝕜 n Prod.snd","decl":"/-- The second projection in a product is `C^∞`. -/\ntheorem contDiff_snd : ContDiff 𝕜 n (Prod.snd : E × F → F) :=\n  IsBoundedLinearMap.contDiff IsBoundedLinearMap.snd\n\n"}
{"name":"ContDiff.snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → Prod F G\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => (f x).2","decl":"/-- Postcomposing `f` with `Prod.snd` is `C^n` -/\ntheorem ContDiff.snd {f : E → F × G} (hf : ContDiff 𝕜 n f) : ContDiff 𝕜 n fun x => (f x).2 :=\n  contDiff_snd.comp hf\n\n"}
{"name":"ContDiff.snd'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : F → G\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => f x.2","decl":"/-- Precomposing `f` with `Prod.snd` is `C^n` -/\ntheorem ContDiff.snd' {f : F → G} (hf : ContDiff 𝕜 n f) : ContDiff 𝕜 n fun x : E × F => f x.2 :=\n  hf.comp contDiff_snd\n\n"}
{"name":"contDiffOn_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set (Prod E F)\n⊢ ContDiffOn 𝕜 n Prod.snd s","decl":"/-- The second projection on a domain in a product is `C^∞`. -/\ntheorem contDiffOn_snd {s : Set (E × F)} : ContDiffOn 𝕜 n (Prod.snd : E × F → F) s :=\n  ContDiff.contDiffOn contDiff_snd\n\n"}
{"name":"ContDiffOn.snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → Prod F G\ns : Set E\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (fun x => (f x).2) s","decl":"theorem ContDiffOn.snd {f : E → F × G} {s : Set E} (hf : ContDiffOn 𝕜 n f s) :\n    ContDiffOn 𝕜 n (fun x => (f x).2) s :=\n  contDiff_snd.comp_contDiffOn hf\n\n"}
{"name":"contDiffAt_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\np : Prod E F\n⊢ ContDiffAt 𝕜 n Prod.snd p","decl":"/-- The second projection at a point in a product is `C^∞`. -/\ntheorem contDiffAt_snd {p : E × F} : ContDiffAt 𝕜 n (Prod.snd : E × F → F) p :=\n  contDiff_snd.contDiffAt\n\n"}
{"name":"ContDiffAt.snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → Prod F G\nx : E\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (fun x => (f x).2) x","decl":"/-- Postcomposing `f` with `Prod.snd` is `C^n` at `x` -/\ntheorem ContDiffAt.snd {f : E → F × G} {x : E} (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (fun x => (f x).2) x :=\n  contDiffAt_snd.comp x hf\n\n"}
{"name":"ContDiffAt.snd'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : F → G\nx : E\ny : F\nhf : ContDiffAt 𝕜 n f y\n⊢ ContDiffAt 𝕜 n (fun x => f x.2) { fst := x, snd := y }","decl":"/-- Precomposing `f` with `Prod.snd` is `C^n` at `(x, y)` -/\ntheorem ContDiffAt.snd' {f : F → G} {x : E} {y : F} (hf : ContDiffAt 𝕜 n f y) :\n    ContDiffAt 𝕜 n (fun x : E × F => f x.2) (x, y) :=\n  ContDiffAt.comp (x, y) hf contDiffAt_snd\n\n"}
{"name":"ContDiffAt.snd''","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : F → G\nx : Prod E F\nhf : ContDiffAt 𝕜 n f x.2\n⊢ ContDiffAt 𝕜 n (fun x => f x.2) x","decl":"/-- Precomposing `f` with `Prod.snd` is `C^n` at `x : E × F` -/\ntheorem ContDiffAt.snd'' {f : F → G} {x : E × F} (hf : ContDiffAt 𝕜 n f x.2) :\n    ContDiffAt 𝕜 n (fun x : E × F => f x.2) x :=\n  hf.comp x contDiffAt_snd\n\n"}
{"name":"contDiffWithinAt_snd","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set (Prod E F)\np : Prod E F\n⊢ ContDiffWithinAt 𝕜 n Prod.snd s p","decl":"/-- The second projection within a domain at a point in a product is `C^∞`. -/\ntheorem contDiffWithinAt_snd {s : Set (E × F)} {p : E × F} :\n    ContDiffWithinAt 𝕜 n (Prod.snd : E × F → F) s p :=\n  contDiff_snd.contDiffWithinAt\n\n"}
{"name":"ContDiff.comp₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiff 𝕜 n f₁\nhf₂ : ContDiff 𝕜 n f₂\n⊢ ContDiff 𝕜 n fun x => g { fst := f₁ x, snd := f₂ x }","decl":"theorem ContDiff.comp₂ {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} (hg : ContDiff 𝕜 n g)\n    (hf₁ : ContDiff 𝕜 n f₁) (hf₂ : ContDiff 𝕜 n f₂) : ContDiff 𝕜 n fun x => g (f₁ x, f₂ x) :=\n  hg.comp <| hf₁.prod hf₂\n\n"}
{"name":"ContDiffAt.comp₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\nx : F\nhg : ContDiffAt 𝕜 n g { fst := f₁ x, snd := f₂ x }\nhf₁ : ContDiffAt 𝕜 n f₁ x\nhf₂ : ContDiffAt 𝕜 n f₂ x\n⊢ ContDiffAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) x","decl":"theorem ContDiffAt.comp₂ {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} {x : F}\n    (hg : ContDiffAt 𝕜 n g (f₁ x, f₂ x))\n    (hf₁ : ContDiffAt 𝕜 n f₁ x) (hf₂ : ContDiffAt 𝕜 n f₂ x) :\n    ContDiffAt 𝕜 n (fun x => g (f₁ x, f₂ x)) x :=\n  hg.comp x (hf₁.prod hf₂)\n\n"}
{"name":"ContDiffAt.comp₂_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nx : F\nhg : ContDiffAt 𝕜 n g { fst := f₁ x, snd := f₂ x }\nhf₁ : ContDiffWithinAt 𝕜 n f₁ s x\nhf₂ : ContDiffWithinAt 𝕜 n f₂ s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s x","decl":"theorem ContDiffAt.comp₂_contDiffWithinAt {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂}\n    {s : Set F} {x : F} (hg : ContDiffAt 𝕜 n g (f₁ x, f₂ x))\n    (hf₁ : ContDiffWithinAt 𝕜 n f₁ s x) (hf₂ : ContDiffWithinAt 𝕜 n f₂ s x) :\n    ContDiffWithinAt 𝕜 n (fun x => g (f₁ x, f₂ x)) s x :=\n  hg.comp_contDiffWithinAt x (hf₁.prod hf₂)\n\n"}
{"name":"ContDiffAt.comp_contDiffWithinAt₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nx : F\nhg : ContDiffAt 𝕜 n g { fst := f₁ x, snd := f₂ x }\nhf₁ : ContDiffWithinAt 𝕜 n f₁ s x\nhf₂ : ContDiffWithinAt 𝕜 n f₂ s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiffAt.comp_contDiffWithinAt₂ := ContDiffAt.comp₂_contDiffWithinAt\n\n"}
{"name":"ContDiff.comp₂_contDiffAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\nx : F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffAt 𝕜 n f₁ x\nhf₂ : ContDiffAt 𝕜 n f₂ x\n⊢ ContDiffAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) x","decl":"theorem ContDiff.comp₂_contDiffAt {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} {x : F}\n    (hg : ContDiff 𝕜 n g) (hf₁ : ContDiffAt 𝕜 n f₁ x) (hf₂ : ContDiffAt 𝕜 n f₂ x) :\n    ContDiffAt 𝕜 n (fun x => g (f₁ x, f₂ x)) x :=\n  hg.contDiffAt.comp₂ hf₁ hf₂\n\n"}
{"name":"ContDiff.comp_contDiffAt₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\nx : F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffAt 𝕜 n f₁ x\nhf₂ : ContDiffAt 𝕜 n f₂ x\n⊢ ContDiffAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffAt₂ := ContDiff.comp₂_contDiffAt\n\n"}
{"name":"ContDiff.comp₂_contDiffWithinAt","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nx : F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffWithinAt 𝕜 n f₁ s x\nhf₂ : ContDiffWithinAt 𝕜 n f₂ s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s x","decl":"theorem ContDiff.comp₂_contDiffWithinAt {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂}\n    {s : Set F} {x : F} (hg : ContDiff 𝕜 n g)\n    (hf₁ : ContDiffWithinAt 𝕜 n f₁ s x) (hf₂ : ContDiffWithinAt 𝕜 n f₂ s x) :\n    ContDiffWithinAt 𝕜 n (fun x => g (f₁ x, f₂ x)) s x :=\n  hg.contDiffAt.comp_contDiffWithinAt x  (hf₁.prod hf₂)\n\n"}
{"name":"ContDiff.comp_contDiffWithinAt₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nx : F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffWithinAt 𝕜 n f₁ s x\nhf₂ : ContDiffWithinAt 𝕜 n f₂ s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s x","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffWithinAt₂ := ContDiff.comp₂_contDiffWithinAt\n\n"}
{"name":"ContDiff.comp₂_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffOn 𝕜 n f₁ s\nhf₂ : ContDiffOn 𝕜 n f₂ s\n⊢ ContDiffOn 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s","decl":"theorem ContDiff.comp₂_contDiffOn {g : E₁ × E₂ → G} {f₁ : F → E₁} {f₂ : F → E₂} {s : Set F}\n    (hg : ContDiff 𝕜 n g) (hf₁ : ContDiffOn 𝕜 n f₁ s) (hf₂ : ContDiffOn 𝕜 n f₂ s) :\n    ContDiffOn 𝕜 n (fun x => g (f₁ x, f₂ x)) s :=\n  hg.comp_contDiffOn <| hf₁.prod hf₂\n\n"}
{"name":"ContDiff.comp_contDiff_on₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffOn 𝕜 n f₁ s\nhf₂ : ContDiffOn 𝕜 n f₂ s\n⊢ ContDiffOn 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s","decl":"@[deprecated (since := \"2024-10-10\")] alias ContDiff.comp_contDiff_on₂ := ContDiff.comp₂_contDiffOn\n\n"}
{"name":"ContDiff.comp_contDiffOn₂","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁵ : NormedAddCommGroup G\ninst✝⁴ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\ninst✝³ : NormedAddCommGroup E₁\ninst✝² : NormedAddCommGroup E₂\ninst✝¹ : NormedSpace 𝕜 E₁\ninst✝ : NormedSpace 𝕜 E₂\ng : Prod E₁ E₂ → G\nf₁ : F → E₁\nf₂ : F → E₂\ns : Set F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffOn 𝕜 n f₁ s\nhf₂ : ContDiffOn 𝕜 n f₂ s\n⊢ ContDiffOn 𝕜 n (fun x => g { fst := f₁ x, snd := f₂ x }) s","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffOn₂ := ContDiff.comp₂_contDiffOn\n\n"}
{"name":"ContDiff.comp₃","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\nE₃ : Type u_5\ninst✝⁵ : NormedAddCommGroup E₁\ninst✝⁴ : NormedAddCommGroup E₂\ninst✝³ : NormedAddCommGroup E₃\ninst✝² : NormedSpace 𝕜 E₁\ninst✝¹ : NormedSpace 𝕜 E₂\ninst✝ : NormedSpace 𝕜 E₃\ng : Prod E₁ (Prod E₂ E₃) → G\nf₁ : F → E₁\nf₂ : F → E₂\nf₃ : F → E₃\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiff 𝕜 n f₁\nhf₂ : ContDiff 𝕜 n f₂\nhf₃ : ContDiff 𝕜 n f₃\n⊢ ContDiff 𝕜 n fun x => g { fst := f₁ x, snd := { fst := f₂ x, snd := f₃ x } }","decl":"theorem ContDiff.comp₃ {g : E₁ × E₂ × E₃ → G} {f₁ : F → E₁} {f₂ : F → E₂} {f₃ : F → E₃}\n    (hg : ContDiff 𝕜 n g) (hf₁ : ContDiff 𝕜 n f₁) (hf₂ : ContDiff 𝕜 n f₂) (hf₃ : ContDiff 𝕜 n f₃) :\n    ContDiff 𝕜 n fun x => g (f₁ x, f₂ x, f₃ x) :=\n  hg.comp₂ hf₁ <| hf₂.prod hf₃\n\n"}
{"name":"ContDiff.comp₃_contDiffOn","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\nE₃ : Type u_5\ninst✝⁵ : NormedAddCommGroup E₁\ninst✝⁴ : NormedAddCommGroup E₂\ninst✝³ : NormedAddCommGroup E₃\ninst✝² : NormedSpace 𝕜 E₁\ninst✝¹ : NormedSpace 𝕜 E₂\ninst✝ : NormedSpace 𝕜 E₃\ng : Prod E₁ (Prod E₂ E₃) → G\nf₁ : F → E₁\nf₂ : F → E₂\nf₃ : F → E₃\ns : Set F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffOn 𝕜 n f₁ s\nhf₂ : ContDiffOn 𝕜 n f₂ s\nhf₃ : ContDiffOn 𝕜 n f₃ s\n⊢ ContDiffOn 𝕜 n (fun x => g { fst := f₁ x, snd := { fst := f₂ x, snd := f₃ x } }) s","decl":"theorem ContDiff.comp₃_contDiffOn {g : E₁ × E₂ × E₃ → G} {f₁ : F → E₁} {f₂ : F → E₂} {f₃ : F → E₃}\n    {s : Set F} (hg : ContDiff 𝕜 n g) (hf₁ : ContDiffOn 𝕜 n f₁ s) (hf₂ : ContDiffOn 𝕜 n f₂ s)\n    (hf₃ : ContDiffOn 𝕜 n f₃ s) : ContDiffOn 𝕜 n (fun x => g (f₁ x, f₂ x, f₃ x)) s :=\n  hg.comp₂_contDiffOn hf₁ <| hf₂.prod hf₃\n\n"}
{"name":"ContDiff.comp_contDiff_on₃","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\nE₃ : Type u_5\ninst✝⁵ : NormedAddCommGroup E₁\ninst✝⁴ : NormedAddCommGroup E₂\ninst✝³ : NormedAddCommGroup E₃\ninst✝² : NormedSpace 𝕜 E₁\ninst✝¹ : NormedSpace 𝕜 E₂\ninst✝ : NormedSpace 𝕜 E₃\ng : Prod E₁ (Prod E₂ E₃) → G\nf₁ : F → E₁\nf₂ : F → E₂\nf₃ : F → E₃\ns : Set F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffOn 𝕜 n f₁ s\nhf₂ : ContDiffOn 𝕜 n f₂ s\nhf₃ : ContDiffOn 𝕜 n f₃ s\n⊢ ContDiffOn 𝕜 n (fun x => g { fst := f₁ x, snd := { fst := f₂ x, snd := f₃ x } }) s","decl":"@[deprecated (since := \"2024-10-10\")] alias ContDiff.comp_contDiff_on₃ := ContDiff.comp₃_contDiffOn\n\n"}
{"name":"ContDiff.comp_contDiffOn₃","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁹ : NormedAddCommGroup F\ninst✝⁸ : NormedSpace 𝕜 F\nG : Type uG\ninst✝⁷ : NormedAddCommGroup G\ninst✝⁶ : NormedSpace 𝕜 G\nn : WithTop ENat\nE₁ : Type u_3\nE₂ : Type u_4\nE₃ : Type u_5\ninst✝⁵ : NormedAddCommGroup E₁\ninst✝⁴ : NormedAddCommGroup E₂\ninst✝³ : NormedAddCommGroup E₃\ninst✝² : NormedSpace 𝕜 E₁\ninst✝¹ : NormedSpace 𝕜 E₂\ninst✝ : NormedSpace 𝕜 E₃\ng : Prod E₁ (Prod E₂ E₃) → G\nf₁ : F → E₁\nf₂ : F → E₂\nf₃ : F → E₃\ns : Set F\nhg : ContDiff 𝕜 n g\nhf₁ : ContDiffOn 𝕜 n f₁ s\nhf₂ : ContDiffOn 𝕜 n f₂ s\nhf₃ : ContDiffOn 𝕜 n f₃ s\n⊢ ContDiffOn 𝕜 n (fun x => g { fst := f₁ x, snd := { fst := f₂ x, snd := f₃ x } }) s","decl":"@[deprecated (since := \"2024-10-30\")]\nalias ContDiff.comp_contDiffOn₃ := ContDiff.comp₃_contDiffOn\n\n"}
{"name":"ContDiff.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type uG\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nX : Type u_2\ninst✝¹ : NormedAddCommGroup X\ninst✝ : NormedSpace 𝕜 X\nn : WithTop ENat\ng : X → ContinuousLinearMap (RingHom.id 𝕜) F G\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\nhg : ContDiff 𝕜 n g\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => (g x).comp (f x)","decl":"theorem ContDiff.clm_comp {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F} (hg : ContDiff 𝕜 n g)\n    (hf : ContDiff 𝕜 n f) : ContDiff 𝕜 n fun x => (g x).comp (f x) :=\n  isBoundedBilinearMap_comp.contDiff.comp₂ (g := fun p => p.1.comp p.2) hg hf\n\n"}
{"name":"ContDiffOn.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type uG\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nX : Type u_2\ninst✝¹ : NormedAddCommGroup X\ninst✝ : NormedSpace 𝕜 X\nn : WithTop ENat\ng : X → ContinuousLinearMap (RingHom.id 𝕜) F G\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set X\nhg : ContDiffOn 𝕜 n g s\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (fun x => (g x).comp (f x)) s","decl":"theorem ContDiffOn.clm_comp {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F} {s : Set X}\n    (hg : ContDiffOn 𝕜 n g s) (hf : ContDiffOn 𝕜 n f s) :\n    ContDiffOn 𝕜 n (fun x => (g x).comp (f x)) s :=\n  (isBoundedBilinearMap_comp (E := E) (F := F) (G := G)).contDiff.comp₂_contDiffOn hg hf\n\n"}
{"name":"ContDiffAt.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type uG\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nX : Type u_2\ninst✝¹ : NormedAddCommGroup X\ninst✝ : NormedSpace 𝕜 X\nn : WithTop ENat\ng : X → ContinuousLinearMap (RingHom.id 𝕜) F G\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\nx : X\nhg : ContDiffAt 𝕜 n g x\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (fun x => (g x).comp (f x)) x","decl":"theorem ContDiffAt.clm_comp {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F} {x : X}\n    (hg : ContDiffAt 𝕜 n g x) (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (fun x => (g x).comp (f x)) x :=\n  (isBoundedBilinearMap_comp (E := E) (G := G)).contDiff.comp₂_contDiffAt hg hf\n\n"}
{"name":"ContDiffWithinAt.clm_comp","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nG : Type uG\ninst✝³ : NormedAddCommGroup G\ninst✝² : NormedSpace 𝕜 G\nX : Type u_2\ninst✝¹ : NormedAddCommGroup X\ninst✝ : NormedSpace 𝕜 X\nn : WithTop ENat\ng : X → ContinuousLinearMap (RingHom.id 𝕜) F G\nf : X → ContinuousLinearMap (RingHom.id 𝕜) E F\ns : Set X\nx : X\nhg : ContDiffWithinAt 𝕜 n g s x\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => (g x).comp (f x)) s x","decl":"theorem ContDiffWithinAt.clm_comp {g : X → F →L[𝕜] G} {f : X → E →L[𝕜] F} {s : Set X} {x : X}\n    (hg : ContDiffWithinAt 𝕜 n g s x) (hf : ContDiffWithinAt 𝕜 n f s x) :\n    ContDiffWithinAt 𝕜 n (fun x => (g x).comp (f x)) s x :=\n  (isBoundedBilinearMap_comp (E := E) (G := G)).contDiff.comp₂_contDiffWithinAt hg hf\n\n"}
{"name":"ContDiff.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\ng : E → F\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => (f x) (g x)","decl":"theorem ContDiff.clm_apply {f : E → F →L[𝕜] G} {g : E → F} (hf : ContDiff 𝕜 n f)\n    (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n fun x => (f x) (g x) :=\n  isBoundedBilinearMap_apply.contDiff.comp₂ hf hg\n\n"}
{"name":"ContDiffOn.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\ng : E → F\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => (f x) (g x)) s","decl":"theorem ContDiffOn.clm_apply {f : E → F →L[𝕜] G} {g : E → F} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (fun x => (f x) (g x)) s :=\n  isBoundedBilinearMap_apply.contDiff.comp₂_contDiffOn hf hg\n\n"}
{"name":"ContDiffAt.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\ng : E → F\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => (f x) (g x)) x","decl":"theorem ContDiffAt.clm_apply {f : E → F →L[𝕜] G} {g : E → F} (hf : ContDiffAt 𝕜 n f x)\n    (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (fun x => (f x) (g x)) x :=\n  isBoundedBilinearMap_apply.contDiff.comp₂_contDiffAt hf hg\n\n"}
{"name":"ContDiffWithinAt.clm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx : E\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F G\ng : E → F\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => (f x) (g x)) s x","decl":"theorem ContDiffWithinAt.clm_apply {f : E → F →L[𝕜] G} {g : E → F}\n    (hf : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) :\n    ContDiffWithinAt 𝕜 n (fun x => (f x) (g x)) s x :=\n  isBoundedBilinearMap_apply.contDiff.comp₂_contDiffWithinAt hf hg\n\n-- Porting note: In Lean 3 we had to give implicit arguments in proofs like the following,\n-- to speed up elaboration. In Lean 4 this isn't necessary anymore.\n"}
{"name":"ContDiff.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F 𝕜\ng : E → G\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => (f x).smulRight (g x)","decl":"theorem ContDiff.smulRight {f : E → F →L[𝕜] 𝕜} {g : E → G} (hf : ContDiff 𝕜 n f)\n    (hg : ContDiff 𝕜 n g) : ContDiff 𝕜 n fun x => (f x).smulRight (g x) :=\n  isBoundedBilinearMap_smulRight.contDiff.comp₂ (g := fun p => p.1.smulRight p.2) hf hg\n\n"}
{"name":"ContDiffOn.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F 𝕜\ng : E → G\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => (f x).smulRight (g x)) s","decl":"theorem ContDiffOn.smulRight {f : E → F →L[𝕜] 𝕜} {g : E → G} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (fun x => (f x).smulRight (g x)) s :=\n  (isBoundedBilinearMap_smulRight (E := F)).contDiff.comp₂_contDiffOn hf hg\n\n"}
{"name":"ContDiffAt.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx : E\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F 𝕜\ng : E → G\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => (f x).smulRight (g x)) x","decl":"theorem ContDiffAt.smulRight {f : E → F →L[𝕜] 𝕜} {g : E → G} (hf : ContDiffAt 𝕜 n f x)\n    (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (fun x => (f x).smulRight (g x)) x :=\n  (isBoundedBilinearMap_smulRight (E := F)).contDiff.comp₂_contDiffAt hf hg\n\n"}
{"name":"ContDiffWithinAt.smulRight","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx : E\nn : WithTop ENat\nf : E → ContinuousLinearMap (RingHom.id 𝕜) F 𝕜\ng : E → G\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => (f x).smulRight (g x)) s x","decl":"theorem ContDiffWithinAt.smulRight {f : E → F →L[𝕜] 𝕜} {g : E → G}\n    (hf : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g s x) :\n    ContDiffWithinAt 𝕜 n (fun x => (f x).smulRight (g x)) s x :=\n  (isBoundedBilinearMap_smulRight (E := F)).contDiff.comp₂_contDiffWithinAt hf hg\n\n"}
{"name":"iteratedFDerivWithin_clm_apply_const_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\ns : Set E\nhs : UniqueDiffOn 𝕜 s\nc : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : ContDiffOn 𝕜 n c s\ni : Nat\nhi : LE.le (↑i) n\nx : E\nhx : Membership.mem s x\nu : F\nm : Fin i → E\n⊢ Eq ((iteratedFDerivWithin 𝕜 i (fun y => (c y) u) s x) m) (((iteratedFDerivWithin 𝕜 i c s x) m) u)","decl":"/-- Application of a `ContinuousLinearMap` to a constant commutes with `iteratedFDerivWithin`. -/\ntheorem iteratedFDerivWithin_clm_apply_const_apply\n    {s : Set E} (hs : UniqueDiffOn 𝕜 s) {c : E → F →L[𝕜] G}\n    (hc : ContDiffOn 𝕜 n c s) {i : ℕ} (hi : i ≤ n) {x : E} (hx : x ∈ s) {u : F} {m : Fin i → E} :\n    (iteratedFDerivWithin 𝕜 i (fun y ↦ (c y) u) s x) m = (iteratedFDerivWithin 𝕜 i c s x) m u := by\n  induction i generalizing x with\n  | zero => simp\n  | succ i ih =>\n    replace hi : (i : WithTop ℕ∞) < n := lt_of_lt_of_le (by norm_cast; simp) hi\n    have h_deriv_apply : DifferentiableOn 𝕜 (iteratedFDerivWithin 𝕜 i (fun y ↦ (c y) u) s) s :=\n      (hc.clm_apply contDiffOn_const).differentiableOn_iteratedFDerivWithin hi hs\n    have h_deriv : DifferentiableOn 𝕜 (iteratedFDerivWithin 𝕜 i c s) s :=\n      hc.differentiableOn_iteratedFDerivWithin hi hs\n    simp only [iteratedFDerivWithin_succ_apply_left]\n    rw [← fderivWithin_continuousMultilinear_apply_const_apply (hs x hx) (h_deriv_apply x hx)]\n    rw [fderivWithin_congr' (fun x hx ↦ ih hi.le hx) hx]\n    rw [fderivWithin_clm_apply (hs x hx) (h_deriv.continuousMultilinear_apply_const _ x hx)\n      (differentiableWithinAt_const u)]\n    rw [fderivWithin_const_apply]\n    simp only [ContinuousLinearMap.flip_apply, ContinuousLinearMap.comp_zero, zero_add]\n    rw [fderivWithin_continuousMultilinear_apply_const_apply (hs x hx) (h_deriv x hx)]\n\n"}
{"name":"iteratedFDeriv_clm_apply_const_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nc : E → ContinuousLinearMap (RingHom.id 𝕜) F G\nhc : ContDiff 𝕜 n c\ni : Nat\nhi : LE.le (↑i) n\nx : E\nu : F\nm : Fin i → E\n⊢ Eq ((iteratedFDeriv 𝕜 i (fun y => (c y) u) x) m) (((iteratedFDeriv 𝕜 i c x) m) u)","decl":"/-- Application of a `ContinuousLinearMap` to a constant commutes with `iteratedFDeriv`. -/\ntheorem iteratedFDeriv_clm_apply_const_apply\n    {c : E → F →L[𝕜] G} (hc : ContDiff 𝕜 n c)\n    {i : ℕ} (hi : i ≤ n) {x : E} {u : F} {m : Fin i → E} :\n    (iteratedFDeriv 𝕜 i (fun y ↦ (c y) u) x) m = (iteratedFDeriv 𝕜 i c x) m u := by\n  simp only [← iteratedFDerivWithin_univ]\n  exact iteratedFDerivWithin_clm_apply_const_apply uniqueDiffOn_univ hc.contDiffOn hi (mem_univ _)\n\n"}
{"name":"contDiff_prodAssoc","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\n⊢ ContDiff 𝕜 n ⇑(Equiv.prodAssoc E F G)","decl":"/-- The natural equivalence `(E × F) × G ≃ E × (F × G)` is smooth.\n\nWarning: if you think you need this lemma, it is likely that you can simplify your proof by\nreformulating the lemma that you're applying next using the tips in\nNote [continuity lemma statement]\n-/\ntheorem contDiff_prodAssoc {n : WithTop ℕ∞} : ContDiff 𝕜 n <| Equiv.prodAssoc E F G :=\n  (LinearIsometryEquiv.prodAssoc 𝕜 E F G).contDiff\n\n"}
{"name":"contDiff_prodAssoc_symm","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\n⊢ ContDiff 𝕜 n ⇑(Equiv.prodAssoc E F G).symm","decl":"/-- The natural equivalence `E × (F × G) ≃ (E × F) × G` is smooth.\n\nWarning: see remarks attached to `contDiff_prodAssoc`\n-/\ntheorem contDiff_prodAssoc_symm {n : WithTop ℕ∞} : ContDiff 𝕜 n <| (Equiv.prodAssoc E F G).symm :=\n  (LinearIsometryEquiv.prodAssoc 𝕜 E F G).symm.contDiff\n\n"}
{"name":"ContDiffWithinAt.hasFDerivWithinAt_nhds","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nn : WithTop ENat\nf : E → F → G\ng : E → F\nt : Set F\nhn : Ne n ↑Top.top\nx₀ : E\nhf : ContDiffWithinAt 𝕜 (HAdd.hAdd n 1) (Function.uncurry f) (SProd.sprod (Insert.insert x₀ s) t) { fst := x₀, snd := g x₀ }\nhg : ContDiffWithinAt 𝕜 n g s x₀\nhgt : Membership.mem (nhdsWithin (g x₀) (Set.image g s)) t\n⊢ Exists fun v => And (Membership.mem (nhdsWithin x₀ (Insert.insert x₀ s)) v) (And (HasSubset.Subset v (Insert.insert x₀ s)) (Exists fun f' => And (∀ (x : E), Membership.mem v x → HasFDerivWithinAt (f x) (f' x) t (g x)) (ContDiffWithinAt 𝕜 n (fun x => f' x) s x₀)))","decl":"/-- One direction of `contDiffWithinAt_succ_iff_hasFDerivWithinAt`, but where all derivatives are\ntaken within the same set. Version for partial derivatives / functions with parameters. If `f x` is\na `C^n+1` family of functions and `g x` is a `C^n` family of points, then the derivative of `f x` at\n`g x` depends in a `C^n` way on `x`. We give a general version of this fact relative to sets which\nmay not have unique derivatives, in the following form.  If `f : E × F → G` is `C^n+1` at\n`(x₀, g(x₀))` in `(s ∪ {x₀}) × t ⊆ E × F` and `g : E → F` is `C^n` at `x₀` within some set `s ⊆ E`,\nthen there is a function `f' : E → F →L[𝕜] G` that is `C^n` at `x₀` within `s` such that for all `x`\nsufficiently close to `x₀` within `s ∪ {x₀}` the function `y ↦ f x y` has derivative `f' x` at `g x`\nwithin `t ⊆ F`.  For convenience, we return an explicit set of `x`'s where this holds that is a\nsubset of `s ∪ {x₀}`.  We need one additional condition, namely that `t` is a neighborhood of\n`g(x₀)` within `g '' s`. -/\ntheorem ContDiffWithinAt.hasFDerivWithinAt_nhds {f : E → F → G} {g : E → F} {t : Set F} (hn : n ≠ ∞)\n    {x₀ : E} (hf : ContDiffWithinAt 𝕜 (n + 1) (uncurry f) (insert x₀ s ×ˢ t) (x₀, g x₀))\n    (hg : ContDiffWithinAt 𝕜 n g s x₀) (hgt : t ∈ 𝓝[g '' s] g x₀) :\n    ∃ v ∈ 𝓝[insert x₀ s] x₀, v ⊆ insert x₀ s ∧ ∃ f' : E → F →L[𝕜] G,\n      (∀ x ∈ v, HasFDerivWithinAt (f x) (f' x) t (g x)) ∧\n        ContDiffWithinAt 𝕜 n (fun x => f' x) s x₀ := by\n  have hst : insert x₀ s ×ˢ t ∈ 𝓝[(fun x => (x, g x)) '' s] (x₀, g x₀) := by\n    refine nhdsWithin_mono _ ?_ (nhdsWithin_prod self_mem_nhdsWithin hgt)\n    simp_rw [image_subset_iff, mk_preimage_prod, preimage_id', subset_inter_iff, subset_insert,\n      true_and, subset_preimage_image]\n  obtain ⟨v, hv, hvs, f_an, f', hvf', hf'⟩ :=\n    (contDiffWithinAt_succ_iff_hasFDerivWithinAt' hn).mp hf\n  refine\n    ⟨(fun z => (z, g z)) ⁻¹' v ∩ insert x₀ s, ?_, inter_subset_right, fun z =>\n      (f' (z, g z)).comp (ContinuousLinearMap.inr 𝕜 E F), ?_, ?_⟩\n  · refine inter_mem ?_ self_mem_nhdsWithin\n    have := mem_of_mem_nhdsWithin (mem_insert _ _) hv\n    refine mem_nhdsWithin_insert.mpr ⟨this, ?_⟩\n    refine (continuousWithinAt_id.prod hg.continuousWithinAt).preimage_mem_nhdsWithin' ?_\n    rw [← nhdsWithin_le_iff] at hst hv ⊢\n    exact (hst.trans <| nhdsWithin_mono _ <| subset_insert _ _).trans hv\n  · intro z hz\n    have := hvf' (z, g z) hz.1\n    refine this.comp _ (hasFDerivAt_prod_mk_right _ _).hasFDerivWithinAt ?_\n    exact mapsTo'.mpr (image_prod_mk_subset_prod_right hz.2)\n  · exact (hf'.continuousLinearMap_comp <| (ContinuousLinearMap.compL 𝕜 F (E × F) G).flip\n      (ContinuousLinearMap.inr 𝕜 E F)).comp_of_mem_nhdsWithin_image x₀\n      (contDiffWithinAt_id.prod hg) hst\n\n"}
{"name":"ContDiffWithinAt.fderivWithin''","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx₀ : E\nm n : WithTop ENat\nf : E → F → G\ng : E → F\nt : Set F\nhf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (SProd.sprod (Insert.insert x₀ s) t) { fst := x₀, snd := g x₀ }\nhg : ContDiffWithinAt 𝕜 m g s x₀\nht : Filter.Eventually (fun x => UniqueDiffWithinAt 𝕜 t (g x)) (nhdsWithin x₀ (Insert.insert x₀ s))\nhmn : LE.le (HAdd.hAdd m 1) n\nhgt : Membership.mem (nhdsWithin (g x₀) (Set.image g s)) t\n⊢ ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀","decl":"/-- The most general lemma stating that `x ↦ fderivWithin 𝕜 (f x) t (g x)` is `C^n`\nat a point within a set.\nTo show that `x ↦ D_yf(x,y)g(x)` (taken within `t`) is `C^m` at `x₀` within `s`, we require that\n* `f` is `C^n` at `(x₀, g(x₀))` within `(s ∪ {x₀}) × t` for `n ≥ m+1`.\n* `g` is `C^m` at `x₀` within `s`;\n* Derivatives are unique at `g(x)` within `t` for `x` sufficiently close to `x₀` within `s ∪ {x₀}`;\n* `t` is a neighborhood of `g(x₀)` within `g '' s`; -/\ntheorem ContDiffWithinAt.fderivWithin'' {f : E → F → G} {g : E → F} {t : Set F}\n    (hf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (insert x₀ s ×ˢ t) (x₀, g x₀))\n    (hg : ContDiffWithinAt 𝕜 m g s x₀)\n    (ht : ∀ᶠ x in 𝓝[insert x₀ s] x₀, UniqueDiffWithinAt 𝕜 t (g x)) (hmn : m + 1 ≤ n)\n    (hgt : t ∈ 𝓝[g '' s] g x₀) :\n    ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀ := by\n  have : ∀ k : ℕ, k ≤ m → ContDiffWithinAt 𝕜 k (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀ := by\n    intro k hkm\n    obtain ⟨v, hv, -, f', hvf', hf'⟩ :=\n      (hf.of_le <| (add_le_add_right hkm 1).trans hmn).hasFDerivWithinAt_nhds (by simp)\n        (hg.of_le hkm) hgt\n    refine hf'.congr_of_eventuallyEq_insert ?_\n    filter_upwards [hv, ht]\n    exact fun y hy h2y => (hvf' y hy).fderivWithin h2y\n  match m with\n  | ω =>\n    obtain rfl : n = ω := by simpa using hmn\n    obtain ⟨v, hv, -, f', hvf', hf'⟩ := hf.hasFDerivWithinAt_nhds (by simp) hg hgt\n    refine hf'.congr_of_eventuallyEq_insert ?_\n    filter_upwards [hv, ht]\n    exact fun y hy h2y => (hvf' y hy).fderivWithin h2y\n  | ∞ =>\n    rw [contDiffWithinAt_infty]\n    exact fun k ↦ this k (by exact_mod_cast le_top)\n  | (m : ℕ) => exact this _ le_rfl\n\n"}
{"name":"ContDiffWithinAt.fderivWithin'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx₀ : E\nm n : WithTop ENat\nf : E → F → G\ng : E → F\nt : Set F\nhf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (SProd.sprod (Insert.insert x₀ s) t) { fst := x₀, snd := g x₀ }\nhg : ContDiffWithinAt 𝕜 m g s x₀\nht : Filter.Eventually (fun x => UniqueDiffWithinAt 𝕜 t (g x)) (nhdsWithin x₀ (Insert.insert x₀ s))\nhmn : LE.le (HAdd.hAdd m 1) n\nhst : HasSubset.Subset s (Set.preimage g t)\n⊢ ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀","decl":"/-- A special case of `ContDiffWithinAt.fderivWithin''` where we require that `s ⊆ g⁻¹(t)`. -/\ntheorem ContDiffWithinAt.fderivWithin' {f : E → F → G} {g : E → F} {t : Set F}\n    (hf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (insert x₀ s ×ˢ t) (x₀, g x₀))\n    (hg : ContDiffWithinAt 𝕜 m g s x₀)\n    (ht : ∀ᶠ x in 𝓝[insert x₀ s] x₀, UniqueDiffWithinAt 𝕜 t (g x)) (hmn : m + 1 ≤ n)\n    (hst : s ⊆ g ⁻¹' t) : ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀ :=\n  hf.fderivWithin'' hg ht hmn <| mem_of_superset self_mem_nhdsWithin <| image_subset_iff.mpr hst\n\n"}
{"name":"ContDiffWithinAt.fderivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx₀ : E\nm n : WithTop ENat\nf : E → F → G\ng : E → F\nt : Set F\nhf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (SProd.sprod s t) { fst := x₀, snd := g x₀ }\nhg : ContDiffWithinAt 𝕜 m g s x₀\nht : UniqueDiffOn 𝕜 t\nhmn : LE.le (HAdd.hAdd m 1) n\nhx₀ : Membership.mem s x₀\nhst : HasSubset.Subset s (Set.preimage g t)\n⊢ ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀","decl":"/-- A special case of `ContDiffWithinAt.fderivWithin'` where we require that `x₀ ∈ s` and there\nare unique derivatives everywhere within `t`. -/\nprotected theorem ContDiffWithinAt.fderivWithin {f : E → F → G} {g : E → F} {t : Set F}\n    (hf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (s ×ˢ t) (x₀, g x₀))\n    (hg : ContDiffWithinAt 𝕜 m g s x₀) (ht : UniqueDiffOn 𝕜 t) (hmn : m + 1 ≤ n) (hx₀ : x₀ ∈ s)\n    (hst : s ⊆ g ⁻¹' t) : ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x)) s x₀ := by\n  rw [← insert_eq_self.mpr hx₀] at hf\n  refine hf.fderivWithin' hg ?_ hmn hst\n  rw [insert_eq_self.mpr hx₀]\n  exact eventually_of_mem self_mem_nhdsWithin fun x hx => ht _ (hst hx)\n\n"}
{"name":"ContDiffWithinAt.fderivWithin_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\ns : Set E\nx₀ : E\nm n : WithTop ENat\nf : E → F → G\ng k : E → F\nt : Set F\nhf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (SProd.sprod s t) { fst := x₀, snd := g x₀ }\nhg : ContDiffWithinAt 𝕜 m g s x₀\nhk : ContDiffWithinAt 𝕜 m k s x₀\nht : UniqueDiffOn 𝕜 t\nhmn : LE.le (HAdd.hAdd m 1) n\nhx₀ : Membership.mem s x₀\nhst : HasSubset.Subset s (Set.preimage g t)\n⊢ ContDiffWithinAt 𝕜 m (fun x => (fderivWithin 𝕜 (f x) t (g x)) (k x)) s x₀","decl":"/-- `x ↦ fderivWithin 𝕜 (f x) t (g x) (k x)` is smooth at a point within a set. -/\ntheorem ContDiffWithinAt.fderivWithin_apply {f : E → F → G} {g k : E → F} {t : Set F}\n    (hf : ContDiffWithinAt 𝕜 n (Function.uncurry f) (s ×ˢ t) (x₀, g x₀))\n    (hg : ContDiffWithinAt 𝕜 m g s x₀) (hk : ContDiffWithinAt 𝕜 m k s x₀) (ht : UniqueDiffOn 𝕜 t)\n    (hmn : m + 1 ≤ n) (hx₀ : x₀ ∈ s) (hst : s ⊆ g ⁻¹' t) :\n    ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 (f x) t (g x) (k x)) s x₀ :=\n  (contDiff_fst.clm_apply contDiff_snd).contDiffAt.comp_contDiffWithinAt x₀\n    ((hf.fderivWithin hg ht hmn hx₀ hst).prod hk)\n\n"}
{"name":"ContDiffWithinAt.fderivWithin_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx₀ : E\nm n : WithTop ENat\nhf : ContDiffWithinAt 𝕜 n f s x₀\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m 1) n\nhx₀s : Membership.mem s x₀\n⊢ ContDiffWithinAt 𝕜 m (fderivWithin 𝕜 f s) s x₀","decl":"/-- `fderivWithin 𝕜 f s` is smooth at `x₀` within `s`. -/\ntheorem ContDiffWithinAt.fderivWithin_right (hf : ContDiffWithinAt 𝕜 n f s x₀)\n    (hs : UniqueDiffOn 𝕜 s) (hmn : m + 1 ≤ n) (hx₀s : x₀ ∈ s) :\n    ContDiffWithinAt 𝕜 m (fderivWithin 𝕜 f s) s x₀ :=\n  ContDiffWithinAt.fderivWithin\n    (ContDiffWithinAt.comp (x₀, x₀) hf contDiffWithinAt_snd <| prod_subset_preimage_snd s s)\n    contDiffWithinAt_id hs hmn hx₀s (by rw [preimage_id'])\n\n"}
{"name":"ContDiffWithinAt.fderivWithin_right_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nm n : WithTop ENat\nf : F → G\nk : F → F\ns : Set F\nx₀ : F\nhf : ContDiffWithinAt 𝕜 n f s x₀\nhk : ContDiffWithinAt 𝕜 m k s x₀\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m 1) n\nhx₀s : Membership.mem s x₀\n⊢ ContDiffWithinAt 𝕜 m (fun x => (fderivWithin 𝕜 f s x) (k x)) s x₀","decl":"/-- `x ↦ fderivWithin 𝕜 f s x (k x)` is smooth at `x₀` within `s`. -/\ntheorem ContDiffWithinAt.fderivWithin_right_apply\n    {f : F → G} {k : F → F} {s : Set F} {x₀ : F}\n    (hf : ContDiffWithinAt 𝕜 n f s x₀) (hk : ContDiffWithinAt 𝕜 m k s x₀)\n    (hs : UniqueDiffOn 𝕜 s) (hmn : m + 1 ≤ n) (hx₀s : x₀ ∈ s) :\n    ContDiffWithinAt 𝕜 m (fun x => fderivWithin 𝕜 f s x (k x)) s x₀ :=\n  ContDiffWithinAt.fderivWithin_apply\n    (ContDiffWithinAt.comp (x₀, x₀) hf contDiffWithinAt_snd <| prod_subset_preimage_snd s s)\n    contDiffWithinAt_id hk hs hmn hx₀s (by rw [preimage_id'])\n\n-- TODO: can we make a version of `ContDiffWithinAt.fderivWithin` for iterated derivatives?\n"}
{"name":"ContDiffWithinAt.iteratedFDerivWithin_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx₀ : E\nm n : WithTop ENat\ni : Nat\nhf : ContDiffWithinAt 𝕜 n f s x₀\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m ↑i) n\nhx₀s : Membership.mem s x₀\n⊢ ContDiffWithinAt 𝕜 m (iteratedFDerivWithin 𝕜 i f s) s x₀","decl":"theorem ContDiffWithinAt.iteratedFDerivWithin_right {i : ℕ} (hf : ContDiffWithinAt 𝕜 n f s x₀)\n    (hs : UniqueDiffOn 𝕜 s) (hmn : m + i ≤ n) (hx₀s : x₀ ∈ s) :\n    ContDiffWithinAt 𝕜 m (iteratedFDerivWithin 𝕜 i f s) s x₀ := by\n  induction' i with i hi generalizing m\n  · simp only [CharP.cast_eq_zero, add_zero] at hmn\n    exact (hf.of_le hmn).continuousLinearMap_comp\n      ((continuousMultilinearCurryFin0 𝕜 E F).symm : _ →L[𝕜] E [×0]→L[𝕜] F)\n  · rw [Nat.cast_succ, add_comm _ 1, ← add_assoc] at hmn\n    exact ((hi hmn).fderivWithin_right hs le_rfl hx₀s).continuousLinearMap_comp\n      ((continuousMultilinearCurryLeftEquiv 𝕜 (fun _ : Fin (i+1) ↦ E) F).symm :\n        _ →L[𝕜] E [×(i+1)]→L[𝕜] F)\n\n"}
{"name":"ContDiffWithinAt.iteratedFderivWithin_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx₀ : E\nm n : WithTop ENat\ni : Nat\nhf : ContDiffWithinAt 𝕜 n f s x₀\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m ↑i) n\nhx₀s : Membership.mem s x₀\n⊢ ContDiffWithinAt 𝕜 m (iteratedFDerivWithin 𝕜 i f s) s x₀","decl":"@[deprecated (since := \"2025-01-15\")]\nalias ContDiffWithinAt.iteratedFderivWithin_right := ContDiffWithinAt.iteratedFDerivWithin_right\n\n"}
{"name":"ContDiffAt.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nx₀ : E\nm n : WithTop ENat\nf : E → F → G\ng : E → F\nhf : ContDiffAt 𝕜 n (Function.uncurry f) { fst := x₀, snd := g x₀ }\nhg : ContDiffAt 𝕜 m g x₀\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffAt 𝕜 m (fun x => fderiv 𝕜 (f x) (g x)) x₀","decl":"/-- `x ↦ fderiv 𝕜 (f x) (g x)` is smooth at `x₀`. -/\nprotected theorem ContDiffAt.fderiv {f : E → F → G} {g : E → F}\n    (hf : ContDiffAt 𝕜 n (Function.uncurry f) (x₀, g x₀)) (hg : ContDiffAt 𝕜 m g x₀)\n    (hmn : m + 1 ≤ n) : ContDiffAt 𝕜 m (fun x => fderiv 𝕜 (f x) (g x)) x₀ := by\n  simp_rw [← fderivWithin_univ]\n  refine (ContDiffWithinAt.fderivWithin hf.contDiffWithinAt hg.contDiffWithinAt uniqueDiffOn_univ\n    hmn (mem_univ x₀) ?_).contDiffAt univ_mem\n  rw [preimage_univ]\n\n"}
{"name":"ContDiffAt.fderiv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nm n : WithTop ENat\nhf : ContDiffAt 𝕜 n f x₀\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffAt 𝕜 m (fderiv 𝕜 f) x₀","decl":"/-- `fderiv 𝕜 f` is smooth at `x₀`. -/\ntheorem ContDiffAt.fderiv_right (hf : ContDiffAt 𝕜 n f x₀) (hmn : m + 1 ≤ n) :\n    ContDiffAt 𝕜 m (fderiv 𝕜 f) x₀ :=\n  ContDiffAt.fderiv (ContDiffAt.comp (x₀, x₀) hf contDiffAt_snd) contDiffAt_id hmn\n\n"}
{"name":"ContDiffAt.iteratedFDeriv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nx₀ : E\nm n : WithTop ENat\ni : Nat\nhf : ContDiffAt 𝕜 n f x₀\nhmn : LE.le (HAdd.hAdd m ↑i) n\n⊢ ContDiffAt 𝕜 m (iteratedFDeriv 𝕜 i f) x₀","decl":"theorem ContDiffAt.iteratedFDeriv_right {i : ℕ} (hf : ContDiffAt 𝕜 n f x₀)\n    (hmn : m + i ≤ n) : ContDiffAt 𝕜 m (iteratedFDeriv 𝕜 i f) x₀ := by\n  rw [← iteratedFDerivWithin_univ, ← contDiffWithinAt_univ] at *\n  exact hf.iteratedFDerivWithin_right uniqueDiffOn_univ hmn trivial\n\n"}
{"name":"ContDiff.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nm n : WithTop ENat\nf : E → F → G\ng : E → F\nhf : ContDiff 𝕜 m (Function.uncurry f)\nhg : ContDiff 𝕜 n g\nhnm : LE.le (HAdd.hAdd n 1) m\n⊢ ContDiff 𝕜 n fun x => fderiv 𝕜 (f x) (g x)","decl":"/-- `x ↦ fderiv 𝕜 (f x) (g x)` is smooth. -/\nprotected theorem ContDiff.fderiv {f : E → F → G} {g : E → F}\n    (hf : ContDiff 𝕜 m <| Function.uncurry f) (hg : ContDiff 𝕜 n g) (hnm : n + 1 ≤ m) :\n    ContDiff 𝕜 n fun x => fderiv 𝕜 (f x) (g x) :=\n  contDiff_iff_contDiffAt.mpr fun _ => hf.contDiffAt.fderiv hg.contDiffAt hnm\n\n"}
{"name":"ContDiff.fderiv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nm n : WithTop ENat\nhf : ContDiff 𝕜 n f\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiff 𝕜 m (fderiv 𝕜 f)","decl":"/-- `fderiv 𝕜 f` is smooth. -/\ntheorem ContDiff.fderiv_right (hf : ContDiff 𝕜 n f) (hmn : m + 1 ≤ n) :\n    ContDiff 𝕜 m (fderiv 𝕜 f) :=\n  contDiff_iff_contDiffAt.mpr fun _x => hf.contDiffAt.fderiv_right hmn\n\n"}
{"name":"ContDiff.iteratedFDeriv_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : E → F\nm n : WithTop ENat\ni : Nat\nhf : ContDiff 𝕜 n f\nhmn : LE.le (HAdd.hAdd m ↑i) n\n⊢ ContDiff 𝕜 m (iteratedFDeriv 𝕜 i f)","decl":"theorem ContDiff.iteratedFDeriv_right {i : ℕ} (hf : ContDiff 𝕜 n f)\n    (hmn : m + i ≤ n) : ContDiff 𝕜 m (iteratedFDeriv 𝕜 i f) :=\n  contDiff_iff_contDiffAt.mpr fun _x => hf.contDiffAt.iteratedFDeriv_right hmn\n\n"}
{"name":"Continuous.fderiv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nn : WithTop ENat\nf : E → F → G\ng : E → F\nhf : ContDiff 𝕜 n (Function.uncurry f)\nhg : Continuous g\nhn : LE.le 1 n\n⊢ Continuous fun x => fderiv 𝕜 (f x) (g x)","decl":"/-- `x ↦ fderiv 𝕜 (f x) (g x)` is continuous. -/\ntheorem Continuous.fderiv {f : E → F → G} {g : E → F}\n    (hf : ContDiff 𝕜 n <| Function.uncurry f) (hg : Continuous g) (hn : 1 ≤ n) :\n    Continuous fun x => fderiv 𝕜 (f x) (g x) :=\n  (hf.fderiv (contDiff_zero.mpr hg) hn).continuous\n\n"}
{"name":"ContDiff.fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁵ : NormedAddCommGroup E\ninst✝⁴ : NormedSpace 𝕜 E\nF : Type uF\ninst✝³ : NormedAddCommGroup F\ninst✝² : NormedSpace 𝕜 F\nG : Type uG\ninst✝¹ : NormedAddCommGroup G\ninst✝ : NormedSpace 𝕜 G\nm n : WithTop ENat\nf : E → F → G\ng k : E → F\nhf : ContDiff 𝕜 m (Function.uncurry f)\nhg : ContDiff 𝕜 n g\nhk : ContDiff 𝕜 n k\nhnm : LE.le (HAdd.hAdd n 1) m\n⊢ ContDiff 𝕜 n fun x => (fderiv 𝕜 (f x) (g x)) (k x)","decl":"/-- `x ↦ fderiv 𝕜 (f x) (g x) (k x)` is smooth. -/\ntheorem ContDiff.fderiv_apply {f : E → F → G} {g k : E → F}\n    (hf : ContDiff 𝕜 m <| Function.uncurry f) (hg : ContDiff 𝕜 n g) (hk : ContDiff 𝕜 n k)\n    (hnm : n + 1 ≤ m) : ContDiff 𝕜 n fun x => fderiv 𝕜 (f x) (g x) (k x) :=\n  (hf.fderiv hg hnm).clm_apply hk\n\n"}
{"name":"contDiffOn_fderivWithin_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nm n : WithTop ENat\ns : Set E\nf : E → F\nhf : ContDiffOn 𝕜 n f s\nhs : UniqueDiffOn 𝕜 s\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffOn 𝕜 m (fun p => (fderivWithin 𝕜 f s p.1) p.2) (SProd.sprod s Set.univ)","decl":"/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem contDiffOn_fderivWithin_apply {s : Set E} {f : E → F} (hf : ContDiffOn 𝕜 n f s)\n    (hs : UniqueDiffOn 𝕜 s) (hmn : m + 1 ≤ n) :\n    ContDiffOn 𝕜 m (fun p : E × E => (fderivWithin 𝕜 f s p.1 : E →L[𝕜] F) p.2) (s ×ˢ univ) :=\n  ((hf.fderivWithin hs hmn).comp contDiffOn_fst (prod_subset_preimage_fst _ _)).clm_apply\n    contDiffOn_snd\n\n"}
{"name":"ContDiffOn.continuousOn_fderivWithin_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\nhs : UniqueDiffOn 𝕜 s\nhn : LE.le 1 n\n⊢ ContinuousOn (fun p => (fderivWithin 𝕜 f s p.1) p.2) (SProd.sprod s Set.univ)","decl":"/-- If a function is at least `C^1`, its bundled derivative (mapping `(x, v)` to `Df(x) v`) is\ncontinuous. -/\ntheorem ContDiffOn.continuousOn_fderivWithin_apply (hf : ContDiffOn 𝕜 n f s) (hs : UniqueDiffOn 𝕜 s)\n    (hn : 1 ≤ n) :\n    ContinuousOn (fun p : E × E => (fderivWithin 𝕜 f s p.1 : E → F) p.2) (s ×ˢ univ) :=\n  (contDiffOn_fderivWithin_apply (m := 0) hf hs hn).continuousOn\n\n"}
{"name":"ContDiff.contDiff_fderiv_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nm n : WithTop ENat\nf : E → F\nhf : ContDiff 𝕜 n f\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiff 𝕜 m fun p => (fderiv 𝕜 f p.1) p.2","decl":"/-- The bundled derivative of a `C^{n+1}` function is `C^n`. -/\ntheorem ContDiff.contDiff_fderiv_apply {f : E → F} (hf : ContDiff 𝕜 n f) (hmn : m + 1 ≤ n) :\n    ContDiff 𝕜 m fun p : E × E => (fderiv 𝕜 f p.1 : E →L[𝕜] F) p.2 := by\n  rw [← contDiffOn_univ] at hf ⊢\n  rw [← fderivWithin_univ, ← univ_prod_univ]\n  exact contDiffOn_fderivWithin_apply hf uniqueDiffOn_univ hmn\n\n"}
{"name":"hasFTaylorSeriesUpToOn_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_3\ninst✝² : Fintype ι\nF' : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nφ : (i : ι) → E → F' i\np' : (i : ι) → E → FormalMultilinearSeries 𝕜 E (F' i)\nn : WithTop ENat\n⊢ Iff (HasFTaylorSeriesUpToOn n (fun x i => φ i x) (fun x m => ContinuousMultilinearMap.pi fun i => p' i x m) s) (∀ (i : ι), HasFTaylorSeriesUpToOn n (φ i) (p' i) s)","decl":"theorem hasFTaylorSeriesUpToOn_pi {n : WithTop ℕ∞} :\n    HasFTaylorSeriesUpToOn n (fun x i => φ i x)\n        (fun x m => ContinuousMultilinearMap.pi fun i => p' i x m) s ↔\n      ∀ i, HasFTaylorSeriesUpToOn n (φ i) (p' i) s := by\n  set pr := @ContinuousLinearMap.proj 𝕜 _ ι F' _ _ _\n  set L : ∀ m : ℕ, (∀ i, E[×m]→L[𝕜] F' i) ≃ₗᵢ[𝕜] E[×m]→L[𝕜] ∀ i, F' i := fun m =>\n    ContinuousMultilinearMap.piₗᵢ _ _\n  refine ⟨fun h i => ?_, fun h => ⟨fun x hx => ?_, ?_, ?_⟩⟩\n  · exact h.continuousLinearMap_comp (pr i)\n  · ext1 i\n    exact (h i).zero_eq x hx\n  · intro m hm x hx\n    exact (L m).hasFDerivAt.comp_hasFDerivWithinAt x <|\n      hasFDerivWithinAt_pi.2 fun i => (h i).fderivWithin m hm x hx\n  · intro m hm\n    exact (L m).continuous.comp_continuousOn <| continuousOn_pi.2 fun i => (h i).cont m hm\n\n"}
{"name":"hasFTaylorSeriesUpToOn_pi'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nι : Type u_3\ninst✝² : Fintype ι\nF' : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\nP' : E → FormalMultilinearSeries 𝕜 E ((i : ι) → F' i)\nn : WithTop ENat\n⊢ Iff (HasFTaylorSeriesUpToOn n Φ P' s) (∀ (i : ι), HasFTaylorSeriesUpToOn n (fun x => Φ x i) (fun x m => (ContinuousLinearMap.proj i).compContinuousMultilinearMap (P' x m)) s)","decl":"@[simp]\ntheorem hasFTaylorSeriesUpToOn_pi' {n : WithTop ℕ∞} :\n    HasFTaylorSeriesUpToOn n Φ P' s ↔\n      ∀ i, HasFTaylorSeriesUpToOn n (fun x => Φ x i)\n        (fun x m => (@ContinuousLinearMap.proj 𝕜 _ ι F' _ _ _ i).compContinuousMultilinearMap\n          (P' x m)) s := by\n  convert hasFTaylorSeriesUpToOn_pi (𝕜 := 𝕜) (φ := fun i x ↦ Φ x i); ext; rfl\n\n"}
{"name":"contDiffWithinAt_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nx : E\nn : WithTop ENat\nι : Type u_3\ninst✝² : Fintype ι\nF' : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (ContDiffWithinAt 𝕜 n Φ s x) (∀ (i : ι), ContDiffWithinAt 𝕜 n (fun x => Φ x i) s x)","decl":"theorem contDiffWithinAt_pi :\n    ContDiffWithinAt 𝕜 n Φ s x ↔ ∀ i, ContDiffWithinAt 𝕜 n (fun x => Φ x i) s x := by\n  set pr := @ContinuousLinearMap.proj 𝕜 _ ι F' _ _ _\n  refine ⟨fun h i => h.continuousLinearMap_comp (pr i), fun h ↦ ?_⟩\n  match n with\n  | ω =>\n    choose u hux p hp h'p using h\n    refine ⟨⋂ i, u i, Filter.iInter_mem.2 hux, _,\n      hasFTaylorSeriesUpToOn_pi.2 fun i => (hp i).mono <| iInter_subset _ _, fun m ↦ ?_⟩\n    set L : (∀ i, E[×m]→L[𝕜] F' i) ≃ₗᵢ[𝕜] E[×m]→L[𝕜] ∀ i, F' i :=\n      ContinuousMultilinearMap.piₗᵢ _ _\n    change AnalyticOn 𝕜 (fun x ↦ L (fun i ↦ p i x m)) (⋂ i, u i)\n    apply (L.analyticOnNhd univ).comp_analyticOn ?_ (mapsTo_univ _ _)\n    exact AnalyticOn.pi (fun i ↦ (h'p i m).mono (iInter_subset _ _))\n  | (n : ℕ∞) =>\n    intro m hm\n    choose u hux p hp using fun i => h i m hm\n    exact ⟨⋂ i, u i, Filter.iInter_mem.2 hux, _,\n      hasFTaylorSeriesUpToOn_pi.2 fun i => (hp i).mono <| iInter_subset _ _⟩\n\n"}
{"name":"contDiffOn_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\ns : Set E\nn : WithTop ENat\nι : Type u_3\ninst✝² : Fintype ι\nF' : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (ContDiffOn 𝕜 n Φ s) (∀ (i : ι), ContDiffOn 𝕜 n (fun x => Φ x i) s)","decl":"theorem contDiffOn_pi : ContDiffOn 𝕜 n Φ s ↔ ∀ i, ContDiffOn 𝕜 n (fun x => Φ x i) s :=\n  ⟨fun h _ x hx => contDiffWithinAt_pi.1 (h x hx) _, fun h x hx =>\n    contDiffWithinAt_pi.2 fun i => h i x hx⟩\n\n"}
{"name":"contDiffAt_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\nι : Type u_3\ninst✝² : Fintype ι\nF' : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (ContDiffAt 𝕜 n Φ x) (∀ (i : ι), ContDiffAt 𝕜 n (fun x => Φ x i) x)","decl":"theorem contDiffAt_pi : ContDiffAt 𝕜 n Φ x ↔ ∀ i, ContDiffAt 𝕜 n (fun x => Φ x i) x :=\n  contDiffWithinAt_pi\n\n"}
{"name":"contDiff_pi","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nn : WithTop ENat\nι : Type u_3\ninst✝² : Fintype ι\nF' : ι → Type u_5\ninst✝¹ : (i : ι) → NormedAddCommGroup (F' i)\ninst✝ : (i : ι) → NormedSpace 𝕜 (F' i)\nΦ : E → (i : ι) → F' i\n⊢ Iff (ContDiff 𝕜 n Φ) (∀ (i : ι), ContDiff 𝕜 n fun x => Φ x i)","decl":"theorem contDiff_pi : ContDiff 𝕜 n Φ ↔ ∀ i, ContDiff 𝕜 n fun x => Φ x i := by\n  simp only [← contDiffOn_univ, contDiffOn_pi]\n\n"}
{"name":"contDiff_update","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_3\ninst✝³ : Fintype ι\nF' : ι → Type u_5\ninst✝² : (i : ι) → NormedAddCommGroup (F' i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (F' i)\ninst✝ : DecidableEq ι\nk : WithTop ENat\nx : (i : ι) → F' i\ni : ι\n⊢ ContDiff 𝕜 k (Function.update x i)","decl":"theorem contDiff_update [DecidableEq ι] (k : WithTop ℕ∞) (x : ∀ i, F' i) (i : ι) :\n    ContDiff 𝕜 k (update x i) := by\n  rw [contDiff_pi]\n  intro j\n  dsimp [Function.update]\n  split_ifs with h\n  · subst h\n    exact contDiff_id\n  · exact contDiff_const\n\n"}
{"name":"contDiff_single","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nι : Type u_3\ninst✝³ : Fintype ι\nF' : ι → Type u_5\ninst✝² : (i : ι) → NormedAddCommGroup (F' i)\ninst✝¹ : (i : ι) → NormedSpace 𝕜 (F' i)\ninst✝ : DecidableEq ι\nk : WithTop ENat\ni : ι\n⊢ ContDiff 𝕜 k (Pi.single i)","decl":"variable (F') in\ntheorem contDiff_single [DecidableEq ι] (k : WithTop ℕ∞) (i : ι) :\n    ContDiff 𝕜 k (Pi.single i : F' i → ∀ i, F' i) :=\n  contDiff_update k 0 i\n\n"}
{"name":"contDiff_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝² : NormedAddCommGroup E\ninst✝¹ : NormedSpace 𝕜 E\nn : WithTop ENat\nι : Type u_3\ninst✝ : Fintype ι\ni : ι\n⊢ ContDiff 𝕜 n fun f => f i","decl":"theorem contDiff_apply (i : ι) : ContDiff 𝕜 n fun f : ι → E => f i :=\n  contDiff_pi.mp contDiff_id i\n\n"}
{"name":"contDiff_apply_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\nι : Type u_3\nι' : Type u_4\ninst✝¹ : Fintype ι\ninst✝ : Fintype ι'\ni : ι\nj : ι'\n⊢ ContDiff 𝕜 n fun f => f i j","decl":"theorem contDiff_apply_apply (i : ι) (j : ι') : ContDiff 𝕜 n fun f : ι → ι' → E => f i j :=\n  contDiff_pi.mp (contDiff_apply 𝕜 (ι' → E) i) j\n\n"}
{"name":"HasFTaylorSeriesUpToOn.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\np : E → FormalMultilinearSeries 𝕜 E F\nn : WithTop ENat\nq : E → FormalMultilinearSeries 𝕜 E F\ng : E → F\nhf : HasFTaylorSeriesUpToOn n f p s\nhg : HasFTaylorSeriesUpToOn n g q s\n⊢ HasFTaylorSeriesUpToOn n (HAdd.hAdd f g) (HAdd.hAdd p q) s","decl":"theorem HasFTaylorSeriesUpToOn.add {n : WithTop ℕ∞} {q g} (hf : HasFTaylorSeriesUpToOn n f p s)\n    (hg : HasFTaylorSeriesUpToOn n g q s) : HasFTaylorSeriesUpToOn n (f + g) (p + q) s := by\n  exact HasFTaylorSeriesUpToOn.continuousLinearMap_comp\n    (ContinuousLinearMap.fst 𝕜 F F + .snd 𝕜 F F) (hf.prod hg)\n\n-- The sum is smooth.\n"}
{"name":"contDiff_add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\n⊢ ContDiff 𝕜 n fun p => HAdd.hAdd p.1 p.2","decl":"theorem contDiff_add : ContDiff 𝕜 n fun p : F × F => p.1 + p.2 :=\n  (IsBoundedLinearMap.fst.add IsBoundedLinearMap.snd).contDiff\n\n"}
{"name":"ContDiffWithinAt.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\ns : Set E\nf g : E → F\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => HAdd.hAdd (f x) (g x)) s x","decl":"/-- The sum of two `C^n` functions within a set at a point is `C^n` within this set\nat this point. -/\ntheorem ContDiffWithinAt.add {s : Set E} {f g : E → F} (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (fun x => f x + g x) s x :=\n  contDiff_add.contDiffWithinAt.comp x (hf.prod hg) subset_preimage_univ\n\n"}
{"name":"ContDiffAt.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\nf g : E → F\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => HAdd.hAdd (f x) (g x)) x","decl":"/-- The sum of two `C^n` functions at a point is `C^n` at this point. -/\ntheorem ContDiffAt.add {f g : E → F} (hf : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) :\n    ContDiffAt 𝕜 n (fun x => f x + g x) x := by\n  rw [← contDiffWithinAt_univ] at *; exact hf.add hg\n\n"}
{"name":"ContDiff.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf g : E → F\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => HAdd.hAdd (f x) (g x)","decl":"/-- The sum of two `C^n`functions is `C^n`. -/\ntheorem ContDiff.add {f g : E → F} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) :\n    ContDiff 𝕜 n fun x => f x + g x :=\n  contDiff_add.comp (hf.prod hg)\n\n"}
{"name":"ContDiffOn.add","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set E\nf g : E → F\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => HAdd.hAdd (f x) (g x)) s","decl":"/-- The sum of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.add {s : Set E} {f g : E → F} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (fun x => f x + g x) s := fun x hx =>\n  (hf x hx).add (hg x hx)\n\n"}
{"name":"iteratedFDerivWithin_add_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nx : E\ni : Nat\nf g : E → F\nhf : ContDiffOn 𝕜 (↑i) f s\nhg : ContDiffOn 𝕜 (↑i) g s\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ Eq (iteratedFDerivWithin 𝕜 i (HAdd.hAdd f g) s x) (HAdd.hAdd (iteratedFDerivWithin 𝕜 i f s x) (iteratedFDerivWithin 𝕜 i g s x))","decl":"/-- The iterated derivative of the sum of two functions is the sum of the iterated derivatives.\nSee also `iteratedFDerivWithin_add_apply'`, which uses the spelling `(fun x ↦ f x + g x)`\ninstead of `f + g`. -/\ntheorem iteratedFDerivWithin_add_apply {f g : E → F} (hf : ContDiffOn 𝕜 i f s)\n    (hg : ContDiffOn 𝕜 i g s) (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    iteratedFDerivWithin 𝕜 i (f + g) s x =\n      iteratedFDerivWithin 𝕜 i f s x + iteratedFDerivWithin 𝕜 i g s x :=\n  Eq.symm <| ((hf.ftaylorSeriesWithin hu).add\n    (hg.ftaylorSeriesWithin hu)).eq_iteratedFDerivWithin_of_uniqueDiffOn le_rfl hu hx\n\n"}
{"name":"iteratedFDerivWithin_add_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nx : E\ni : Nat\nf g : E → F\nhf : ContDiffOn 𝕜 (↑i) f s\nhg : ContDiffOn 𝕜 (↑i) g s\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ Eq (iteratedFDerivWithin 𝕜 i (fun x => HAdd.hAdd (f x) (g x)) s x) (HAdd.hAdd (iteratedFDerivWithin 𝕜 i f s x) (iteratedFDerivWithin 𝕜 i g s x))","decl":"/-- The iterated derivative of the sum of two functions is the sum of the iterated derivatives.\nThis is the same as `iteratedFDerivWithin_add_apply`, but using the spelling `(fun x ↦ f x + g x)`\ninstead of `f + g`, which can be handy for some rewrites.\nTODO: use one form consistently. -/\ntheorem iteratedFDerivWithin_add_apply' {f g : E → F} (hf : ContDiffOn 𝕜 i f s)\n    (hg : ContDiffOn 𝕜 i g s) (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    iteratedFDerivWithin 𝕜 i (fun x => f x + g x) s x =\n      iteratedFDerivWithin 𝕜 i f s x + iteratedFDerivWithin 𝕜 i g s x :=\n  iteratedFDerivWithin_add_apply hf hg hu hx\n\n"}
{"name":"iteratedFDeriv_add_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ni : Nat\nf g : E → F\nhf : ContDiff 𝕜 (↑i) f\nhg : ContDiff 𝕜 (↑i) g\n⊢ Eq (iteratedFDeriv 𝕜 i (HAdd.hAdd f g) x) (HAdd.hAdd (iteratedFDeriv 𝕜 i f x) (iteratedFDeriv 𝕜 i g x))","decl":"theorem iteratedFDeriv_add_apply {i : ℕ} {f g : E → F} (hf : ContDiff 𝕜 i f) (hg : ContDiff 𝕜 i g) :\n    iteratedFDeriv 𝕜 i (f + g) x = iteratedFDeriv 𝕜 i f x + iteratedFDeriv 𝕜 i g x := by\n  simp_rw [← contDiffOn_univ, ← iteratedFDerivWithin_univ] at hf hg ⊢\n  exact iteratedFDerivWithin_add_apply hf hg uniqueDiffOn_univ (Set.mem_univ _)\n\n"}
{"name":"iteratedFDeriv_add_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ni : Nat\nf g : E → F\nhf : ContDiff 𝕜 (↑i) f\nhg : ContDiff 𝕜 (↑i) g\n⊢ Eq (iteratedFDeriv 𝕜 i (fun x => HAdd.hAdd (f x) (g x)) x) (HAdd.hAdd (iteratedFDeriv 𝕜 i f x) (iteratedFDeriv 𝕜 i g x))","decl":"theorem iteratedFDeriv_add_apply' {i : ℕ} {f g : E → F} (hf : ContDiff 𝕜 i f)\n    (hg : ContDiff 𝕜 i g) :\n    iteratedFDeriv 𝕜 i (fun x => f x + g x) x = iteratedFDeriv 𝕜 i f x + iteratedFDeriv 𝕜 i g x :=\n  iteratedFDeriv_add_apply hf hg\n\n"}
{"name":"contDiff_neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\n⊢ ContDiff 𝕜 n fun p => Neg.neg p","decl":"theorem contDiff_neg : ContDiff 𝕜 n fun p : F => -p :=\n  IsBoundedLinearMap.id.neg.contDiff\n\n"}
{"name":"ContDiffWithinAt.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\ns : Set E\nf : E → F\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => Neg.neg (f x)) s x","decl":"/-- The negative of a `C^n` function within a domain at a point is `C^n` within this domain at\nthis point. -/\ntheorem ContDiffWithinAt.neg {s : Set E} {f : E → F} (hf : ContDiffWithinAt 𝕜 n f s x) :\n    ContDiffWithinAt 𝕜 n (fun x => -f x) s x :=\n  contDiff_neg.contDiffWithinAt.comp x hf subset_preimage_univ\n\n"}
{"name":"ContDiffAt.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\nf : E → F\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (fun x => Neg.neg (f x)) x","decl":"/-- The negative of a `C^n` function at a point is `C^n` at this point. -/\ntheorem ContDiffAt.neg {f : E → F} (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (fun x => -f x) x := by rw [← contDiffWithinAt_univ] at *; exact hf.neg\n\n"}
{"name":"ContDiff.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : E → F\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun x => Neg.neg (f x)","decl":"/-- The negative of a `C^n`function is `C^n`. -/\ntheorem ContDiff.neg {f : E → F} (hf : ContDiff 𝕜 n f) : ContDiff 𝕜 n fun x => -f x :=\n  contDiff_neg.comp hf\n\n"}
{"name":"ContDiffOn.neg","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set E\nf : E → F\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (fun x => Neg.neg (f x)) s","decl":"/-- The negative of a `C^n` function on a domain is `C^n`. -/\ntheorem ContDiffOn.neg {s : Set E} {f : E → F} (hf : ContDiffOn 𝕜 n f s) :\n    ContDiffOn 𝕜 n (fun x => -f x) s := fun x hx => (hf x hx).neg\n\n"}
{"name":"iteratedFDerivWithin_neg_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nx : E\ni : Nat\nf : E → F\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ Eq (iteratedFDerivWithin 𝕜 i (Neg.neg f) s x) (Neg.neg (iteratedFDerivWithin 𝕜 i f s x))","decl":"theorem iteratedFDerivWithin_neg_apply {f : E → F} (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    iteratedFDerivWithin 𝕜 i (-f) s x = -iteratedFDerivWithin 𝕜 i f s x := by\n  induction' i with i hi generalizing x\n  · ext; simp\n  · ext h\n    calc\n      iteratedFDerivWithin 𝕜 (i + 1) (-f) s x h =\n          fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 i (-f) s) s x (h 0) (Fin.tail h) :=\n        rfl\n      _ = fderivWithin 𝕜 (-iteratedFDerivWithin 𝕜 i f s) s x (h 0) (Fin.tail h) := by\n        rw [fderivWithin_congr' (@hi) hx]; rfl\n      _ = -(fderivWithin 𝕜 (iteratedFDerivWithin 𝕜 i f s) s) x (h 0) (Fin.tail h) := by\n        rw [Pi.neg_def, fderivWithin_neg (hu x hx)]; rfl\n      _ = -(iteratedFDerivWithin 𝕜 (i + 1) f s) x h := rfl\n\n"}
{"name":"iteratedFDeriv_neg_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\ni : Nat\nf : E → F\n⊢ Eq (iteratedFDeriv 𝕜 i (Neg.neg f) x) (Neg.neg (iteratedFDeriv 𝕜 i f x))","decl":"theorem iteratedFDeriv_neg_apply {i : ℕ} {f : E → F} :\n    iteratedFDeriv 𝕜 i (-f) x = -iteratedFDeriv 𝕜 i f x := by\n  simp_rw [← iteratedFDerivWithin_univ]\n  exact iteratedFDerivWithin_neg_apply uniqueDiffOn_univ (Set.mem_univ _)\n\n"}
{"name":"ContDiffWithinAt.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\ns : Set E\nf g : E → F\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => HSub.hSub (f x) (g x)) s x","decl":"/-- The difference of two `C^n` functions within a set at a point is `C^n` within this set\nat this point. -/\ntheorem ContDiffWithinAt.sub {s : Set E} {f g : E → F} (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (fun x => f x - g x) s x := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiffAt.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\nf g : E → F\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => HSub.hSub (f x) (g x)) x","decl":"/-- The difference of two `C^n` functions at a point is `C^n` at this point. -/\ntheorem ContDiffAt.sub {f g : E → F} (hf : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) :\n    ContDiffAt 𝕜 n (fun x => f x - g x) x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiffOn.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set E\nf g : E → F\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => HSub.hSub (f x) (g x)) s","decl":"/-- The difference of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.sub {s : Set E} {f g : E → F} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (fun x => f x - g x) s := by\n  simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiff.sub","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf g : E → F\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => HSub.hSub (f x) (g x)","decl":"/-- The difference of two `C^n` functions is `C^n`. -/\ntheorem ContDiff.sub {f g : E → F} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) :\n    ContDiff 𝕜 n fun x => f x - g x := by simpa only [sub_eq_add_neg] using hf.add hg.neg\n\n"}
{"name":"ContDiffWithinAt.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nι : Type u_3\nf : ι → E → F\ns : Finset ι\nt : Set E\nx : E\nh : ∀ (i : ι), Membership.mem s i → ContDiffWithinAt 𝕜 n (fun x => f i x) t x\n⊢ ContDiffWithinAt 𝕜 n (fun x => s.sum fun i => f i x) t x","decl":"theorem ContDiffWithinAt.sum {ι : Type*} {f : ι → E → F} {s : Finset ι} {t : Set E} {x : E}\n    (h : ∀ i ∈ s, ContDiffWithinAt 𝕜 n (fun x => f i x) t x) :\n    ContDiffWithinAt 𝕜 n (fun x => ∑ i ∈ s, f i x) t x := by\n  classical\n    induction' s using Finset.induction_on with i s is IH\n    · simp [contDiffWithinAt_const]\n    · simp only [is, Finset.sum_insert, not_false_iff]\n      exact (h _ (Finset.mem_insert_self i s)).add\n        (IH fun j hj => h _ (Finset.mem_insert_of_mem hj))\n\n"}
{"name":"ContDiffAt.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nι : Type u_3\nf : ι → E → F\ns : Finset ι\nx : E\nh : ∀ (i : ι), Membership.mem s i → ContDiffAt 𝕜 n (fun x => f i x) x\n⊢ ContDiffAt 𝕜 n (fun x => s.sum fun i => f i x) x","decl":"theorem ContDiffAt.sum {ι : Type*} {f : ι → E → F} {s : Finset ι} {x : E}\n    (h : ∀ i ∈ s, ContDiffAt 𝕜 n (fun x => f i x) x) :\n    ContDiffAt 𝕜 n (fun x => ∑ i ∈ s, f i x) x := by\n  rw [← contDiffWithinAt_univ] at *; exact ContDiffWithinAt.sum h\n\n"}
{"name":"ContDiffOn.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nι : Type u_3\nf : ι → E → F\ns : Finset ι\nt : Set E\nh : ∀ (i : ι), Membership.mem s i → ContDiffOn 𝕜 n (fun x => f i x) t\n⊢ ContDiffOn 𝕜 n (fun x => s.sum fun i => f i x) t","decl":"theorem ContDiffOn.sum {ι : Type*} {f : ι → E → F} {s : Finset ι} {t : Set E}\n    (h : ∀ i ∈ s, ContDiffOn 𝕜 n (fun x => f i x) t) :\n    ContDiffOn 𝕜 n (fun x => ∑ i ∈ s, f i x) t := fun x hx =>\n  ContDiffWithinAt.sum fun i hi => h i hi x hx\n\n"}
{"name":"ContDiff.sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nι : Type u_3\nf : ι → E → F\ns : Finset ι\nh : ∀ (i : ι), Membership.mem s i → ContDiff 𝕜 n fun x => f i x\n⊢ ContDiff 𝕜 n fun x => s.sum fun i => f i x","decl":"theorem ContDiff.sum {ι : Type*} {f : ι → E → F} {s : Finset ι}\n    (h : ∀ i ∈ s, ContDiff 𝕜 n fun x => f i x) : ContDiff 𝕜 n fun x => ∑ i ∈ s, f i x := by\n  simp only [← contDiffOn_univ] at *; exact ContDiffOn.sum h\n\n"}
{"name":"iteratedFDerivWithin_sum_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\ns : Set E\nι : Type u_3\nf : ι → E → F\nu : Finset ι\ni : Nat\nx : E\nhs : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\nh : ∀ (j : ι), Membership.mem u j → ContDiffOn 𝕜 (↑i) (f j) s\n⊢ Eq (iteratedFDerivWithin 𝕜 i (fun x => u.sum fun j => f j x) s x) (u.sum fun j => iteratedFDerivWithin 𝕜 i (f j) s x)","decl":"theorem iteratedFDerivWithin_sum_apply {ι : Type*} {f : ι → E → F} {u : Finset ι} {i : ℕ} {x : E}\n    (hs : UniqueDiffOn 𝕜 s) (hx : x ∈ s) (h : ∀ j ∈ u, ContDiffOn 𝕜 i (f j) s) :\n    iteratedFDerivWithin 𝕜 i (∑ j ∈ u, f j ·) s x =\n      ∑ j ∈ u, iteratedFDerivWithin 𝕜 i (f j) s x := by\n  induction u using Finset.cons_induction with\n  | empty => ext; simp [hs, hx]\n  | cons a u ha IH =>\n    simp only [Finset.mem_cons, forall_eq_or_imp] at h\n    simp only [Finset.sum_cons]\n    rw [iteratedFDerivWithin_add_apply' h.1 (ContDiffOn.sum h.2) hs hx, IH h.2]\n\n"}
{"name":"iteratedFDeriv_sum","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nι : Type u_3\nf : ι → E → F\nu : Finset ι\ni : Nat\nh : ∀ (j : ι), Membership.mem u j → ContDiff 𝕜 (↑i) (f j)\n⊢ Eq (iteratedFDeriv 𝕜 i fun x => u.sum fun j => f j x) (u.sum fun j => iteratedFDeriv 𝕜 i (f j))","decl":"theorem iteratedFDeriv_sum {ι : Type*} {f : ι → E → F} {u : Finset ι} {i : ℕ}\n    (h : ∀ j ∈ u, ContDiff 𝕜 i (f j)) :\n    iteratedFDeriv 𝕜 i (∑ j ∈ u, f j ·) = ∑ j ∈ u, iteratedFDeriv 𝕜 i (f j) :=\n  funext fun x ↦ by simpa [iteratedFDerivWithin_univ] using\n    iteratedFDerivWithin_sum_apply uniqueDiffOn_univ (mem_univ x) fun j hj ↦ (h j hj).contDiffOn\n\n"}
{"name":"contDiff_mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\n⊢ ContDiff 𝕜 n fun p => HMul.hMul p.1 p.2","decl":"theorem contDiff_mul : ContDiff 𝕜 n fun p : 𝔸 × 𝔸 => p.1 * p.2 :=\n  (ContinuousLinearMap.mul 𝕜 𝔸).isBoundedBilinearMap.contDiff\n\n"}
{"name":"ContDiffWithinAt.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\ns : Set E\nf g : E → 𝔸\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => HMul.hMul (f x) (g x)) s x","decl":"/-- The product of two `C^n` functions within a set at a point is `C^n` within this set\nat this point. -/\ntheorem ContDiffWithinAt.mul {s : Set E} {f g : E → 𝔸} (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (fun x => f x * g x) s x :=\n  contDiff_mul.comp_contDiffWithinAt (hf.prod hg)\n\n"}
{"name":"ContDiffAt.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf g : E → 𝔸\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => HMul.hMul (f x) (g x)) x","decl":"/-- The product of two `C^n` functions at a point is `C^n` at this point. -/\nnonrec theorem ContDiffAt.mul {f g : E → 𝔸} (hf : ContDiffAt 𝕜 n f x) (hg : ContDiffAt 𝕜 n g x) :\n    ContDiffAt 𝕜 n (fun x => f x * g x) x :=\n  hf.mul hg\n\n"}
{"name":"ContDiffOn.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf g : E → 𝔸\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => HMul.hMul (f x) (g x)) s","decl":"/-- The product of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.mul {f g : E → 𝔸} (hf : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g s) :\n    ContDiffOn 𝕜 n (fun x => f x * g x) s := fun x hx => (hf x hx).mul (hg x hx)\n\n"}
{"name":"ContDiff.mul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf g : E → 𝔸\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => HMul.hMul (f x) (g x)","decl":"/-- The product of two `C^n`functions is `C^n`. -/\ntheorem ContDiff.mul {f g : E → 𝔸} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) :\n    ContDiff 𝕜 n fun x => f x * g x :=\n  contDiff_mul.comp (hf.prod hg)\n\n"}
{"name":"contDiffWithinAt_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nx : E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiffWithinAt 𝕜 n (f i) s x\n⊢ ContDiffWithinAt 𝕜 n (t.prod fun i => f i) s x","decl":"theorem contDiffWithinAt_prod' {t : Finset ι} {f : ι → E → 𝔸'}\n    (h : ∀ i ∈ t, ContDiffWithinAt 𝕜 n (f i) s x) : ContDiffWithinAt 𝕜 n (∏ i ∈ t, f i) s x :=\n  Finset.prod_induction f (fun f => ContDiffWithinAt 𝕜 n f s x) (fun _ _ => ContDiffWithinAt.mul)\n    (contDiffWithinAt_const (c := 1)) h\n\n"}
{"name":"contDiffWithinAt_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nx : E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiffWithinAt 𝕜 n (f i) s x\n⊢ ContDiffWithinAt 𝕜 n (fun y => t.prod fun i => f i y) s x","decl":"theorem contDiffWithinAt_prod {t : Finset ι} {f : ι → E → 𝔸'}\n    (h : ∀ i ∈ t, ContDiffWithinAt 𝕜 n (f i) s x) :\n    ContDiffWithinAt 𝕜 n (fun y => ∏ i ∈ t, f i y) s x := by\n  simpa only [← Finset.prod_apply] using contDiffWithinAt_prod' h\n\n"}
{"name":"contDiffAt_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiffAt 𝕜 n (f i) x\n⊢ ContDiffAt 𝕜 n (t.prod fun i => f i) x","decl":"theorem contDiffAt_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, ContDiffAt 𝕜 n (f i) x) :\n    ContDiffAt 𝕜 n (∏ i ∈ t, f i) x :=\n  contDiffWithinAt_prod' h\n\n"}
{"name":"contDiffAt_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiffAt 𝕜 n (f i) x\n⊢ ContDiffAt 𝕜 n (fun y => t.prod fun i => f i y) x","decl":"theorem contDiffAt_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, ContDiffAt 𝕜 n (f i) x) :\n    ContDiffAt 𝕜 n (fun y => ∏ i ∈ t, f i y) x :=\n  contDiffWithinAt_prod h\n\n"}
{"name":"contDiffOn_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiffOn 𝕜 n (f i) s\n⊢ ContDiffOn 𝕜 n (t.prod fun i => f i) s","decl":"theorem contDiffOn_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, ContDiffOn 𝕜 n (f i) s) :\n    ContDiffOn 𝕜 n (∏ i ∈ t, f i) s := fun x hx => contDiffWithinAt_prod' fun i hi => h i hi x hx\n\n"}
{"name":"contDiffOn_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiffOn 𝕜 n (f i) s\n⊢ ContDiffOn 𝕜 n (fun y => t.prod fun i => f i y) s","decl":"theorem contDiffOn_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, ContDiffOn 𝕜 n (f i) s) :\n    ContDiffOn 𝕜 n (fun y => ∏ i ∈ t, f i y) s := fun x hx =>\n  contDiffWithinAt_prod fun i hi => h i hi x hx\n\n"}
{"name":"contDiff_prod'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiff 𝕜 n (f i)\n⊢ ContDiff 𝕜 n (t.prod fun i => f i)","decl":"theorem contDiff_prod' {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, ContDiff 𝕜 n (f i)) :\n    ContDiff 𝕜 n (∏ i ∈ t, f i) :=\n  contDiff_iff_contDiffAt.mpr fun _ => contDiffAt_prod' fun i hi => (h i hi).contDiffAt\n\n"}
{"name":"contDiff_prod","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\n𝔸' : Type u_4\nι : Type u_5\ninst✝¹ : NormedCommRing 𝔸'\ninst✝ : NormedAlgebra 𝕜 𝔸'\nt : Finset ι\nf : ι → E → 𝔸'\nh : ∀ (i : ι), Membership.mem t i → ContDiff 𝕜 n (f i)\n⊢ ContDiff 𝕜 n fun y => t.prod fun i => f i y","decl":"theorem contDiff_prod {t : Finset ι} {f : ι → E → 𝔸'} (h : ∀ i ∈ t, ContDiff 𝕜 n (f i)) :\n    ContDiff 𝕜 n fun y => ∏ i ∈ t, f i y :=\n  contDiff_iff_contDiffAt.mpr fun _ => contDiffAt_prod fun i hi => (h i hi).contDiffAt\n\n"}
{"name":"ContDiff.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : E → 𝔸\nhf : ContDiff 𝕜 n f\nm : Nat\n⊢ ContDiff 𝕜 n fun x => HPow.hPow (f x) m","decl":"theorem ContDiff.pow {f : E → 𝔸} (hf : ContDiff 𝕜 n f) : ∀ m : ℕ, ContDiff 𝕜 n fun x => f x ^ m\n  | 0 => by simpa using contDiff_const\n  | m + 1 => by simpa [pow_succ] using (hf.pow m).mul hf\n\n"}
{"name":"ContDiffWithinAt.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nx : E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : E → 𝔸\nhf : ContDiffWithinAt 𝕜 n f s x\nm : Nat\n⊢ ContDiffWithinAt 𝕜 n (fun y => HPow.hPow (f y) m) s x","decl":"theorem ContDiffWithinAt.pow {f : E → 𝔸} (hf : ContDiffWithinAt 𝕜 n f s x) (m : ℕ) :\n    ContDiffWithinAt 𝕜 n (fun y => f y ^ m) s x :=\n  (contDiff_id.pow m).comp_contDiffWithinAt hf\n\n"}
{"name":"ContDiffAt.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : E → 𝔸\nhf : ContDiffAt 𝕜 n f x\nm : Nat\n⊢ ContDiffAt 𝕜 n (fun y => HPow.hPow (f y) m) x","decl":"nonrec theorem ContDiffAt.pow {f : E → 𝔸} (hf : ContDiffAt 𝕜 n f x) (m : ℕ) :\n    ContDiffAt 𝕜 n (fun y => f y ^ m) x :=\n  hf.pow m\n\n"}
{"name":"ContDiffOn.pow","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : WithTop ENat\n𝔸 : Type u_3\ninst✝¹ : NormedRing 𝔸\ninst✝ : NormedAlgebra 𝕜 𝔸\nf : E → 𝔸\nhf : ContDiffOn 𝕜 n f s\nm : Nat\n⊢ ContDiffOn 𝕜 n (fun y => HPow.hPow (f y) m) s","decl":"theorem ContDiffOn.pow {f : E → 𝔸} (hf : ContDiffOn 𝕜 n f s) (m : ℕ) :\n    ContDiffOn 𝕜 n (fun y => f y ^ m) s := fun y hy => (hf y hy).pow m\n\n"}
{"name":"ContDiffWithinAt.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nx : E\n𝕜' : Type u_6\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nn : WithTop ENat\nhf : ContDiffWithinAt 𝕜 n f s x\nc : 𝕜'\n⊢ ContDiffWithinAt 𝕜 n (fun x => HDiv.hDiv (f x) c) s x","decl":"theorem ContDiffWithinAt.div_const {f : E → 𝕜'} {n} (hf : ContDiffWithinAt 𝕜 n f s x) (c : 𝕜') :\n    ContDiffWithinAt 𝕜 n (fun x => f x / c) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul contDiffWithinAt_const\n\n"}
{"name":"ContDiffAt.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\n𝕜' : Type u_6\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nn : WithTop ENat\nhf : ContDiffAt 𝕜 n f x\nc : 𝕜'\n⊢ ContDiffAt 𝕜 n (fun x => HDiv.hDiv (f x) c) x","decl":"nonrec theorem ContDiffAt.div_const {f : E → 𝕜'} {n} (hf : ContDiffAt 𝕜 n f x) (c : 𝕜') :\n    ContDiffAt 𝕜 n (fun x => f x / c) x :=\n  hf.div_const c\n\n"}
{"name":"ContDiffOn.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\n𝕜' : Type u_6\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nn : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\nc : 𝕜'\n⊢ ContDiffOn 𝕜 n (fun x => HDiv.hDiv (f x) c) s","decl":"theorem ContDiffOn.div_const {f : E → 𝕜'} {n} (hf : ContDiffOn 𝕜 n f s) (c : 𝕜') :\n    ContDiffOn 𝕜 n (fun x => f x / c) s := fun x hx => (hf x hx).div_const c\n\n"}
{"name":"ContDiff.div_const","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\n𝕜' : Type u_6\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nn : WithTop ENat\nhf : ContDiff 𝕜 n f\nc : 𝕜'\n⊢ ContDiff 𝕜 n fun x => HDiv.hDiv (f x) c","decl":"theorem ContDiff.div_const {f : E → 𝕜'} {n} (hf : ContDiff 𝕜 n f) (c : 𝕜') :\n    ContDiff 𝕜 n fun x => f x / c := by simpa only [div_eq_mul_inv] using hf.mul contDiff_const\n\n"}
{"name":"contDiff_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\n⊢ ContDiff 𝕜 n fun p => HSMul.hSMul p.1 p.2","decl":"theorem contDiff_smul : ContDiff 𝕜 n fun p : 𝕜 × F => p.1 • p.2 :=\n  isBoundedBilinearMap_smul.contDiff\n\n"}
{"name":"ContDiffWithinAt.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\ns : Set E\nf : E → 𝕜\ng : E → F\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\n⊢ ContDiffWithinAt 𝕜 n (fun x => HSMul.hSMul (f x) (g x)) s x","decl":"/-- The scalar multiplication of two `C^n` functions within a set at a point is `C^n` within this\nset at this point. -/\ntheorem ContDiffWithinAt.smul {s : Set E} {f : E → 𝕜} {g : E → F} (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hg : ContDiffWithinAt 𝕜 n g s x) : ContDiffWithinAt 𝕜 n (fun x => f x • g x) s x :=\n  contDiff_smul.contDiffWithinAt.comp x (hf.prod hg) subset_preimage_univ\n\n"}
{"name":"ContDiffAt.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nx : E\nn : WithTop ENat\nf : E → 𝕜\ng : E → F\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\n⊢ ContDiffAt 𝕜 n (fun x => HSMul.hSMul (f x) (g x)) x","decl":"/-- The scalar multiplication of two `C^n` functions at a point is `C^n` at this point. -/\ntheorem ContDiffAt.smul {f : E → 𝕜} {g : E → F} (hf : ContDiffAt 𝕜 n f x)\n    (hg : ContDiffAt 𝕜 n g x) : ContDiffAt 𝕜 n (fun x => f x • g x) x := by\n  rw [← contDiffWithinAt_univ] at *; exact hf.smul hg\n\n"}
{"name":"ContDiff.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf : E → 𝕜\ng : E → F\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n fun x => HSMul.hSMul (f x) (g x)","decl":"/-- The scalar multiplication of two `C^n` functions is `C^n`. -/\ntheorem ContDiff.smul {f : E → 𝕜} {g : E → F} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) :\n    ContDiff 𝕜 n fun x => f x • g x :=\n  contDiff_smul.comp (hf.prod hg)\n\n"}
{"name":"ContDiffOn.smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ns : Set E\nf : E → 𝕜\ng : E → F\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\n⊢ ContDiffOn 𝕜 n (fun x => HSMul.hSMul (f x) (g x)) s","decl":"/-- The scalar multiplication of two `C^n` functions on a domain is `C^n`. -/\ntheorem ContDiffOn.smul {s : Set E} {f : E → 𝕜} {g : E → F} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) : ContDiffOn 𝕜 n (fun x => f x • g x) s := fun x hx =>\n  (hf x hx).smul (hg x hx)\n\n"}
{"name":"contDiff_const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁶ : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nc : R\n⊢ ContDiff 𝕜 n fun p => HSMul.hSMul c p","decl":"theorem contDiff_const_smul (c : R) : ContDiff 𝕜 n fun p : F => c • p :=\n  (c • ContinuousLinearMap.id 𝕜 F).contDiff\n\n"}
{"name":"ContDiffWithinAt.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\ns : Set E\nf : E → F\nx : E\nc : R\nhf : ContDiffWithinAt 𝕜 n f s x\n⊢ ContDiffWithinAt 𝕜 n (fun y => HSMul.hSMul c (f y)) s x","decl":"/-- The scalar multiplication of a constant and a `C^n` function within a set at a point is `C^n`\nwithin this set at this point. -/\ntheorem ContDiffWithinAt.const_smul {s : Set E} {f : E → F} {x : E} (c : R)\n    (hf : ContDiffWithinAt 𝕜 n f s x) : ContDiffWithinAt 𝕜 n (fun y => c • f y) s x :=\n  (contDiff_const_smul c).contDiffAt.comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffAt.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nf : E → F\nx : E\nc : R\nhf : ContDiffAt 𝕜 n f x\n⊢ ContDiffAt 𝕜 n (fun y => HSMul.hSMul c (f y)) x","decl":"/-- The scalar multiplication of a constant and a `C^n` function at a point is `C^n` at this\npoint. -/\ntheorem ContDiffAt.const_smul {f : E → F} {x : E} (c : R) (hf : ContDiffAt 𝕜 n f x) :\n    ContDiffAt 𝕜 n (fun y => c • f y) x := by\n  rw [← contDiffWithinAt_univ] at *; exact hf.const_smul c\n\n"}
{"name":"ContDiff.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\nf : E → F\nc : R\nhf : ContDiff 𝕜 n f\n⊢ ContDiff 𝕜 n fun y => HSMul.hSMul c (f y)","decl":"/-- The scalar multiplication of a constant and a `C^n` function is `C^n`. -/\ntheorem ContDiff.const_smul {f : E → F} (c : R) (hf : ContDiff 𝕜 n f) :\n    ContDiff 𝕜 n fun y => c • f y :=\n  (contDiff_const_smul c).comp hf\n\n"}
{"name":"ContDiffOn.const_smul","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\ns : Set E\nf : E → F\nc : R\nhf : ContDiffOn 𝕜 n f s\n⊢ ContDiffOn 𝕜 n (fun y => HSMul.hSMul c (f y)) s","decl":"/-- The scalar multiplication of a constant and a `C^n` on a domain is `C^n`. -/\ntheorem ContDiffOn.const_smul {s : Set E} {f : E → F} (c : R) (hf : ContDiffOn 𝕜 n f s) :\n    ContDiffOn 𝕜 n (fun y => c • f y) s := fun x hx => (hf x hx).const_smul c\n\n"}
{"name":"iteratedFDerivWithin_const_smul_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\ni : Nat\na : R\nhf : ContDiffWithinAt 𝕜 (↑i) f s x\nhu : UniqueDiffOn 𝕜 s\nhx : Membership.mem s x\n⊢ Eq (iteratedFDerivWithin 𝕜 i (HSMul.hSMul a f) s x) (HSMul.hSMul a (iteratedFDerivWithin 𝕜 i f s x))","decl":"theorem iteratedFDerivWithin_const_smul_apply (hf : ContDiffWithinAt 𝕜 i f s x)\n    (hu : UniqueDiffOn 𝕜 s) (hx : x ∈ s) :\n    iteratedFDerivWithin 𝕜 i (a • f) s x = a • iteratedFDerivWithin 𝕜 i f s x :=\n  (a • (1 : F →L[𝕜] F)).iteratedFDerivWithin_comp_left hf hu hx le_rfl\n\n"}
{"name":"iteratedFDeriv_const_smul_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nx : E\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\ni : Nat\na : R\nhf : ContDiffAt 𝕜 (↑i) f x\n⊢ Eq (iteratedFDeriv 𝕜 i (HSMul.hSMul a f) x) (HSMul.hSMul a (iteratedFDeriv 𝕜 i f x))","decl":"theorem iteratedFDeriv_const_smul_apply (hf : ContDiffAt 𝕜 i f x) :\n    iteratedFDeriv 𝕜 i (a • f) x = a • iteratedFDeriv 𝕜 i f x :=\n  (a • (1 : F →L[𝕜] F)).iteratedFDeriv_comp_left hf le_rfl\n\n"}
{"name":"iteratedFDeriv_const_smul_apply'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nf : E → F\nx : E\nR : Type u_3\ninst✝³ : Semiring R\ninst✝² : Module R F\ninst✝¹ : SMulCommClass 𝕜 R F\ninst✝ : ContinuousConstSMul R F\ni : Nat\na : R\nhf : ContDiffAt 𝕜 (↑i) f x\n⊢ Eq (iteratedFDeriv 𝕜 i (fun x => HSMul.hSMul a (f x)) x) (HSMul.hSMul a (iteratedFDeriv 𝕜 i f x))","decl":"theorem iteratedFDeriv_const_smul_apply' (hf : ContDiffAt 𝕜 i f x) :\n    iteratedFDeriv 𝕜 i (fun x ↦ a • f x) x = a • iteratedFDeriv 𝕜 i f x :=\n  iteratedFDeriv_const_smul_apply hf\n\n"}
{"name":"ContDiffWithinAt.prod_map'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nF' : Type u_4\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜 F'\ns : Set E\nt : Set E'\nf : E → F\ng : E' → F'\np : Prod E E'\nhf : ContDiffWithinAt 𝕜 n f s p.1\nhg : ContDiffWithinAt 𝕜 n g t p.2\n⊢ ContDiffWithinAt 𝕜 n (Prod.map f g) (SProd.sprod s t) p","decl":"/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem ContDiffWithinAt.prod_map' {s : Set E} {t : Set E'} {f : E → F} {g : E' → F'} {p : E × E'}\n    (hf : ContDiffWithinAt 𝕜 n f s p.1) (hg : ContDiffWithinAt 𝕜 n g t p.2) :\n    ContDiffWithinAt 𝕜 n (Prod.map f g) (s ×ˢ t) p :=\n  (hf.comp p contDiffWithinAt_fst (prod_subset_preimage_fst _ _)).prod\n    (hg.comp p contDiffWithinAt_snd (prod_subset_preimage_snd _ _))\n\n"}
{"name":"ContDiffWithinAt.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nF' : Type u_4\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜 F'\ns : Set E\nt : Set E'\nf : E → F\ng : E' → F'\nx : E\ny : E'\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g t y\n⊢ ContDiffWithinAt 𝕜 n (Prod.map f g) (SProd.sprod s t) { fst := x, snd := y }","decl":"theorem ContDiffWithinAt.prod_map {s : Set E} {t : Set E'} {f : E → F} {g : E' → F'} {x : E}\n    {y : E'} (hf : ContDiffWithinAt 𝕜 n f s x) (hg : ContDiffWithinAt 𝕜 n g t y) :\n    ContDiffWithinAt 𝕜 n (Prod.map f g) (s ×ˢ t) (x, y) :=\n  ContDiffWithinAt.prod_map' hf hg\n\n"}
{"name":"ContDiffOn.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nE' : Type u_5\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nF' : Type u_6\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜 F'\ns : Set E\nt : Set E'\nf : E → F\ng : E' → F'\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g t\n⊢ ContDiffOn 𝕜 n (Prod.map f g) (SProd.sprod s t)","decl":"/-- The product map of two `C^n` functions on a set is `C^n` on the product set. -/\ntheorem ContDiffOn.prod_map {E' : Type*} [NormedAddCommGroup E'] [NormedSpace 𝕜 E'] {F' : Type*}\n    [NormedAddCommGroup F'] [NormedSpace 𝕜 F'] {s : Set E} {t : Set E'} {f : E → F} {g : E' → F'}\n    (hf : ContDiffOn 𝕜 n f s) (hg : ContDiffOn 𝕜 n g t) : ContDiffOn 𝕜 n (Prod.map f g) (s ×ˢ t) :=\n  (hf.comp contDiffOn_fst (prod_subset_preimage_fst _ _)).prod\n    (hg.comp contDiffOn_snd (prod_subset_preimage_snd _ _))\n\n"}
{"name":"ContDiffAt.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nF' : Type u_4\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜 F'\nf : E → F\ng : E' → F'\nx : E\ny : E'\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g y\n⊢ ContDiffAt 𝕜 n (Prod.map f g) { fst := x, snd := y }","decl":"/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem ContDiffAt.prod_map {f : E → F} {g : E' → F'} {x : E} {y : E'} (hf : ContDiffAt 𝕜 n f x)\n    (hg : ContDiffAt 𝕜 n g y) : ContDiffAt 𝕜 n (Prod.map f g) (x, y) := by\n  rw [ContDiffAt] at *\n  convert hf.prod_map hg\n  simp only [univ_prod_univ]\n\n"}
{"name":"ContDiffAt.prod_map'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nF' : Type u_4\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜 F'\nf : E → F\ng : E' → F'\np : Prod E E'\nhf : ContDiffAt 𝕜 n f p.1\nhg : ContDiffAt 𝕜 n g p.2\n⊢ ContDiffAt 𝕜 n (Prod.map f g) p","decl":"/-- The product map of two `C^n` functions within a set at a point is `C^n`\nwithin the product set at the product point. -/\ntheorem ContDiffAt.prod_map' {f : E → F} {g : E' → F'} {p : E × E'} (hf : ContDiffAt 𝕜 n f p.1)\n    (hg : ContDiffAt 𝕜 n g p.2) : ContDiffAt 𝕜 n (Prod.map f g) p := by\n  rcases p with ⟨⟩\n  exact ContDiffAt.prod_map hf hg\n\n"}
{"name":"ContDiff.prod_map","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁸ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁷ : NormedAddCommGroup E\ninst✝⁶ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁵ : NormedAddCommGroup F\ninst✝⁴ : NormedSpace 𝕜 F\nn : WithTop ENat\nE' : Type u_3\ninst✝³ : NormedAddCommGroup E'\ninst✝² : NormedSpace 𝕜 E'\nF' : Type u_4\ninst✝¹ : NormedAddCommGroup F'\ninst✝ : NormedSpace 𝕜 F'\nf : E → F\ng : E' → F'\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\n⊢ ContDiff 𝕜 n (Prod.map f g)","decl":"/-- The product map of two `C^n` functions is `C^n`. -/\ntheorem ContDiff.prod_map {f : E → F} {g : E' → F'} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g) :\n    ContDiff 𝕜 n (Prod.map f g) := by\n  rw [contDiff_iff_contDiffAt] at *\n  exact fun ⟨x, y⟩ => (hf x).prod_map (hg y)\n\n"}
{"name":"contDiff_prod_mk_left","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₀ : F\n⊢ ContDiff 𝕜 n fun e => { fst := e, snd := f₀ }","decl":"theorem contDiff_prod_mk_left (f₀ : F) : ContDiff 𝕜 n fun e : E => (e, f₀) :=\n  contDiff_id.prod contDiff_const\n\n"}
{"name":"contDiff_prod_mk_right","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\ne₀ : E\n⊢ ContDiff 𝕜 n fun f => { fst := e₀, snd := f }","decl":"theorem contDiff_prod_mk_right (e₀ : E) : ContDiff 𝕜 n fun f : F => (e₀, f) :=\n  contDiff_const.prod contDiff_id\n\n"}
{"name":"contDiffAt_ring_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝³ : NontriviallyNormedField 𝕜\nn : WithTop ENat\nR : Type u_3\ninst✝² : NormedRing R\ninst✝¹ : NormedAlgebra 𝕜 R\ninst✝ : HasSummableGeomSeries R\nx : Units R\n⊢ ContDiffAt 𝕜 n Ring.inverse ↑x","decl":"/-- In a complete normed algebra, the operation of inversion is `C^n`, for all `n`, at each\ninvertible element, as it is analytic. -/\ntheorem contDiffAt_ring_inverse [HasSummableGeomSeries R] (x : Rˣ) :\n    ContDiffAt 𝕜 n Ring.inverse (x : R) := by\n  have := AnalyticOnNhd.contDiffOn (analyticOnNhd_inverse (𝕜 := 𝕜) (A := R)) (n := n)\n    Units.isOpen.uniqueDiffOn x x.isUnit\n  exact this.contDiffAt (Units.isOpen.mem_nhds x.isUnit)\n\n"}
{"name":"contDiffAt_inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_4\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nx : 𝕜'\nhx : Ne x 0\nn : WithTop ENat\n⊢ ContDiffAt 𝕜 n Inv.inv x","decl":"theorem contDiffAt_inv {x : 𝕜'} (hx : x ≠ 0) {n} : ContDiffAt 𝕜 n Inv.inv x := by\n  simpa only [Ring.inverse_eq_inv'] using contDiffAt_ring_inverse 𝕜 (Units.mk0 x hx)\n\n"}
{"name":"contDiffOn_inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\n𝕜' : Type u_4\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nn : WithTop ENat\n⊢ ContDiffOn 𝕜 n Inv.inv (HasCompl.compl (Singleton.singleton 0))","decl":"theorem contDiffOn_inv {n} : ContDiffOn 𝕜 n (Inv.inv : 𝕜' → 𝕜') {0}ᶜ := fun _ hx =>\n  (contDiffAt_inv 𝕜 hx).contDiffWithinAt\n\n"}
{"name":"ContDiffWithinAt.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nx : E\n𝕜' : Type u_4\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nn : WithTop ENat\nhf : ContDiffWithinAt 𝕜 n f s x\nhx : Ne (f x) 0\n⊢ ContDiffWithinAt 𝕜 n (fun x => Inv.inv (f x)) s x","decl":"theorem ContDiffWithinAt.inv {f : E → 𝕜'} {n} (hf : ContDiffWithinAt 𝕜 n f s x) (hx : f x ≠ 0) :\n    ContDiffWithinAt 𝕜 n (fun x => (f x)⁻¹) s x :=\n  (contDiffAt_inv 𝕜 hx).comp_contDiffWithinAt x hf\n\n"}
{"name":"ContDiffOn.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\ns : Set E\nn : WithTop ENat\n𝕜' : Type u_4\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nhf : ContDiffOn 𝕜 n f s\nh : ∀ (x : E), Membership.mem s x → Ne (f x) 0\n⊢ ContDiffOn 𝕜 n (fun x => Inv.inv (f x)) s","decl":"theorem ContDiffOn.inv {f : E → 𝕜'} (hf : ContDiffOn 𝕜 n f s) (h : ∀ x ∈ s, f x ≠ 0) :\n    ContDiffOn 𝕜 n (fun x => (f x)⁻¹) s := fun x hx => (hf.contDiffWithinAt hx).inv (h x hx)\n\n"}
{"name":"ContDiffAt.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nx : E\nn : WithTop ENat\n𝕜' : Type u_4\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nhf : ContDiffAt 𝕜 n f x\nhx : Ne (f x) 0\n⊢ ContDiffAt 𝕜 n (fun x => Inv.inv (f x)) x","decl":"nonrec theorem ContDiffAt.inv {f : E → 𝕜'} (hf : ContDiffAt 𝕜 n f x) (hx : f x ≠ 0) :\n    ContDiffAt 𝕜 n (fun x => (f x)⁻¹) x :=\n  hf.inv hx\n\n"}
{"name":"ContDiff.inv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nn : WithTop ENat\n𝕜' : Type u_4\ninst✝¹ : NormedField 𝕜'\ninst✝ : NormedAlgebra 𝕜 𝕜'\nf : E → 𝕜'\nhf : ContDiff 𝕜 n f\nh : ∀ (x : E), Ne (f x) 0\n⊢ ContDiff 𝕜 n fun x => Inv.inv (f x)","decl":"theorem ContDiff.inv {f : E → 𝕜'} (hf : ContDiff 𝕜 n f) (h : ∀ x, f x ≠ 0) :\n    ContDiff 𝕜 n fun x => (f x)⁻¹ := by\n  rw [contDiff_iff_contDiffAt]; exact fun x => hf.contDiffAt.inv (h x)\n\n-- TODO: generalize to `f g : E → 𝕜'`\n"}
{"name":"ContDiffWithinAt.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\nx : E\nf g : E → 𝕜\nn : WithTop ENat\nhf : ContDiffWithinAt 𝕜 n f s x\nhg : ContDiffWithinAt 𝕜 n g s x\nhx : Ne (g x) 0\n⊢ ContDiffWithinAt 𝕜 n (fun x => HDiv.hDiv (f x) (g x)) s x","decl":"theorem ContDiffWithinAt.div {f g : E → 𝕜} {n} (hf : ContDiffWithinAt 𝕜 n f s x)\n    (hg : ContDiffWithinAt 𝕜 n g s x) (hx : g x ≠ 0) :\n    ContDiffWithinAt 𝕜 n (fun x => f x / g x) s x := by\n  simpa only [div_eq_mul_inv] using hf.mul (hg.inv hx)\n\n"}
{"name":"ContDiffOn.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\ns : Set E\nf g : E → 𝕜\nn : WithTop ENat\nhf : ContDiffOn 𝕜 n f s\nhg : ContDiffOn 𝕜 n g s\nh₀ : ∀ (x : E), Membership.mem s x → Ne (g x) 0\n⊢ ContDiffOn 𝕜 n (HDiv.hDiv f g) s","decl":"theorem ContDiffOn.div {f g : E → 𝕜} {n} (hf : ContDiffOn 𝕜 n f s)\n    (hg : ContDiffOn 𝕜 n g s) (h₀ : ∀ x ∈ s, g x ≠ 0) : ContDiffOn 𝕜 n (f / g) s := fun x hx =>\n  (hf x hx).div (hg x hx) (h₀ x hx)\n\n"}
{"name":"ContDiffAt.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nx : E\nf g : E → 𝕜\nn : WithTop ENat\nhf : ContDiffAt 𝕜 n f x\nhg : ContDiffAt 𝕜 n g x\nhx : Ne (g x) 0\n⊢ ContDiffAt 𝕜 n (fun x => HDiv.hDiv (f x) (g x)) x","decl":"nonrec theorem ContDiffAt.div {f g : E → 𝕜} {n} (hf : ContDiffAt 𝕜 n f x)\n    (hg : ContDiffAt 𝕜 n g x) (hx : g x ≠ 0) : ContDiffAt 𝕜 n (fun x => f x / g x) x :=\n  hf.div hg hx\n\n"}
{"name":"ContDiff.div","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝¹ : NormedAddCommGroup E\ninst✝ : NormedSpace 𝕜 E\nf g : E → 𝕜\nn : WithTop ENat\nhf : ContDiff 𝕜 n f\nhg : ContDiff 𝕜 n g\nh0 : ∀ (x : E), Ne (g x) 0\n⊢ ContDiff 𝕜 n fun x => HDiv.hDiv (f x) (g x)","decl":"theorem ContDiff.div {f g : E → 𝕜} {n} (hf : ContDiff 𝕜 n f) (hg : ContDiff 𝕜 n g)\n    (h0 : ∀ x, g x ≠ 0) : ContDiff 𝕜 n fun x => f x / g x := by\n  simp only [contDiff_iff_contDiffAt] at *\n  exact fun x => (hf x).div (hg x) (h0 x)\n\n"}
{"name":"contDiffAt_map_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nn : WithTop ENat\ninst✝ : CompleteSpace E\ne : ContinuousLinearEquiv (RingHom.id 𝕜) E F\n⊢ ContDiffAt 𝕜 n ContinuousLinearMap.inverse ↑e","decl":"/-- At a continuous linear equivalence `e : E ≃L[𝕜] F` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem contDiffAt_map_inverse [CompleteSpace E] (e : E ≃L[𝕜] F) :\n    ContDiffAt 𝕜 n inverse (e : E →L[𝕜] F) := by\n  nontriviality E\n  -- first, we use the lemma `to_ring_inverse` to rewrite in terms of `Ring.inverse` in the ring\n  -- `E →L[𝕜] E`\n  let O₁ : (E →L[𝕜] E) → F →L[𝕜] E := fun f => f.comp (e.symm : F →L[𝕜] E)\n  let O₂ : (E →L[𝕜] F) → E →L[𝕜] E := fun f => (e.symm : F →L[𝕜] E).comp f\n  have : ContinuousLinearMap.inverse = O₁ ∘ Ring.inverse ∘ O₂ := funext (to_ring_inverse e)\n  rw [this]\n  -- `O₁` and `O₂` are `ContDiff`,\n  -- so we reduce to proving that `Ring.inverse` is `ContDiff`\n  have h₁ : ContDiff 𝕜 n O₁ := contDiff_id.clm_comp contDiff_const\n  have h₂ : ContDiff 𝕜 n O₂ := contDiff_const.clm_comp contDiff_id\n  refine h₁.contDiffAt.comp _ (ContDiffAt.comp _ ?_ h₂.contDiffAt)\n  convert contDiffAt_ring_inverse 𝕜 (1 : (E →L[𝕜] E)ˣ)\n  simp [O₂, one_def]\n\n"}
{"name":"ContinuousLinearMap.IsInvertible.contDiffAt_map_inverse","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nn : WithTop ENat\ninst✝ : CompleteSpace E\ne : ContinuousLinearMap (RingHom.id 𝕜) E F\nhe : e.IsInvertible\n⊢ ContDiffAt 𝕜 n ContinuousLinearMap.inverse e","decl":"/-- At an invertible map `e : M →L[R] M₂` between Banach spaces, the operation of\ninversion is `C^n`, for all `n`. -/\ntheorem ContinuousLinearMap.IsInvertible.contDiffAt_map_inverse [CompleteSpace E] {e : E →L[𝕜] F}\n    (he : e.IsInvertible) : ContDiffAt 𝕜 n inverse e := by\n  rcases he with ⟨M, rfl⟩\n  exact _root_.contDiffAt_map_inverse M\n\n"}
{"name":"PartialHomeomorph.contDiffAt_symm","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nn : WithTop ENat\ninst✝ : CompleteSpace E\nf : PartialHomeomorph E F\nf₀' : ContinuousLinearEquiv (RingHom.id 𝕜) E F\na : F\nha : Membership.mem f.target a\nhf₀' : HasFDerivAt (↑f) (↑f₀') (↑f.symm a)\nhf : ContDiffAt 𝕜 n (↑f) (↑f.symm a)\n⊢ ContDiffAt 𝕜 n (↑f.symm) a","decl":"/-- If `f` is a local homeomorphism and the point `a` is in its target,\nand if `f` is `n` times continuously differentiable at `f.symm a`,\nand if the derivative at `f.symm a` is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.contDiffAt_symm [CompleteSpace E] (f : PartialHomeomorph E F)\n    {f₀' : E ≃L[𝕜] F} {a : F} (ha : a ∈ f.target)\n    (hf₀' : HasFDerivAt f (f₀' : E →L[𝕜] F) (f.symm a)) (hf : ContDiffAt 𝕜 n f (f.symm a)) :\n    ContDiffAt 𝕜 n f.symm a := by\n  match n with\n  | ω =>\n    apply AnalyticAt.contDiffAt\n    exact f.analyticAt_symm ha hf.analyticAt hf₀'.fderiv\n  | (n : ℕ∞) =>\n    -- We prove this by induction on `n`\n    induction' n using ENat.nat_induction with n IH Itop\n    · apply contDiffAt_zero.2\n      exact ⟨f.target, IsOpen.mem_nhds f.open_target ha, f.continuousOn_invFun⟩\n    · obtain ⟨f', ⟨u, hu, hff'⟩, hf'⟩ := contDiffAt_succ_iff_hasFDerivAt.mp hf\n      apply contDiffAt_succ_iff_hasFDerivAt.2\n      -- For showing `n.succ` times continuous differentiability (the main inductive step), it\n      -- suffices to produce the derivative and show that it is `n` times continuously\n      -- differentiable\n      have eq_f₀' : f' (f.symm a) = f₀' := (hff' (f.symm a) (mem_of_mem_nhds hu)).unique hf₀'\n      -- This follows by a bootstrapping formula expressing the derivative as a\n      -- function of `f` itself\n      refine ⟨inverse ∘ f' ∘ f.symm, ?_, ?_⟩\n      · -- We first check that the derivative of `f` is that formula\n        have h_nhds : { y : E | ∃ e : E ≃L[𝕜] F, ↑e = f' y } ∈ 𝓝 (f.symm a) := by\n          have hf₀' := f₀'.nhds\n          rw [← eq_f₀'] at hf₀'\n          exact hf'.continuousAt.preimage_mem_nhds hf₀'\n        obtain ⟨t, htu, ht, htf⟩ := mem_nhds_iff.mp (Filter.inter_mem hu h_nhds)\n        use f.target ∩ f.symm ⁻¹' t\n        refine ⟨IsOpen.mem_nhds ?_ ?_, ?_⟩\n        · exact f.isOpen_inter_preimage_symm ht\n        · exact mem_inter ha (mem_preimage.mpr htf)\n        intro x hx\n        obtain ⟨hxu, e, he⟩ := htu hx.2\n        have h_deriv : HasFDerivAt f (e : E →L[𝕜] F) (f.symm x) := by\n          rw [he]\n          exact hff' (f.symm x) hxu\n        convert f.hasFDerivAt_symm hx.1 h_deriv\n        simp [← he]\n      · -- Then we check that the formula, being a composition of `ContDiff` pieces, is\n        -- itself `ContDiff`\n        have h_deriv₁ : ContDiffAt 𝕜 n inverse (f' (f.symm a)) := by\n          rw [eq_f₀']\n          exact contDiffAt_map_inverse _\n        have h_deriv₂ : ContDiffAt 𝕜 n f.symm a := by\n          refine IH (hf.of_le ?_)\n          norm_cast\n          exact Nat.le_succ n\n        exact (h_deriv₁.comp _ hf').comp _ h_deriv₂\n    · refine contDiffAt_infty.mpr ?_\n      intro n\n      exact Itop n (contDiffAt_infty.mp hf n)\n\n"}
{"name":"Homeomorph.contDiff_symm","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁵ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁴ : NormedAddCommGroup E\ninst✝³ : NormedSpace 𝕜 E\nF : Type uF\ninst✝² : NormedAddCommGroup F\ninst✝¹ : NormedSpace 𝕜 F\nn : WithTop ENat\ninst✝ : CompleteSpace E\nf : Homeomorph E F\nf₀' : E → ContinuousLinearEquiv (RingHom.id 𝕜) E F\nhf₀' : ∀ (a : E), HasFDerivAt (⇑f) (↑(f₀' a)) a\nhf : ContDiff 𝕜 n ⇑f\n⊢ ContDiff 𝕜 n ⇑f.symm","decl":"/-- If `f` is an `n` times continuously differentiable homeomorphism,\nand if the derivative of `f` at each point is a continuous linear equivalence,\nthen `f.symm` is `n` times continuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem Homeomorph.contDiff_symm [CompleteSpace E] (f : E ≃ₜ F) {f₀' : E → E ≃L[𝕜] F}\n    (hf₀' : ∀ a, HasFDerivAt f (f₀' a : E →L[𝕜] F) a) (hf : ContDiff 𝕜 n (f : E → F)) :\n    ContDiff 𝕜 n (f.symm : F → E) :=\n  contDiff_iff_contDiffAt.2 fun x =>\n    f.toPartialHomeomorph.contDiffAt_symm (mem_univ x) (hf₀' _) hf.contDiffAt\n\n"}
{"name":"PartialHomeomorph.contDiffAt_symm_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜\nn : WithTop ENat\ninst✝ : CompleteSpace 𝕜\nf : PartialHomeomorph 𝕜 𝕜\nf₀' a : 𝕜\nh₀ : Ne f₀' 0\nha : Membership.mem f.target a\nhf₀' : HasDerivAt (↑f) f₀' (↑f.symm a)\nhf : ContDiffAt 𝕜 n (↑f) (↑f.symm a)\n⊢ ContDiffAt 𝕜 n (↑f.symm) a","decl":"/-- Let `f` be a local homeomorphism of a nontrivially normed field, let `a` be a point in its\ntarget. if `f` is `n` times continuously differentiable at `f.symm a`, and if the derivative at\n`f.symm a` is nonzero, then `f.symm` is `n` times continuously differentiable at the point `a`.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem PartialHomeomorph.contDiffAt_symm_deriv [CompleteSpace 𝕜] (f : PartialHomeomorph 𝕜 𝕜)\n    {f₀' a : 𝕜} (h₀ : f₀' ≠ 0) (ha : a ∈ f.target) (hf₀' : HasDerivAt f f₀' (f.symm a))\n    (hf : ContDiffAt 𝕜 n f (f.symm a)) : ContDiffAt 𝕜 n f.symm a :=\n  f.contDiffAt_symm ha (hf₀'.hasFDerivAt_equiv h₀) hf\n\n"}
{"name":"Homeomorph.contDiff_symm_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹ : NontriviallyNormedField 𝕜\nn : WithTop ENat\ninst✝ : CompleteSpace 𝕜\nf : Homeomorph 𝕜 𝕜\nf' : 𝕜 → 𝕜\nh₀ : ∀ (x : 𝕜), Ne (f' x) 0\nhf' : ∀ (x : 𝕜), HasDerivAt (⇑f) (f' x) x\nhf : ContDiff 𝕜 n ⇑f\n⊢ ContDiff 𝕜 n ⇑f.symm","decl":"/-- Let `f` be an `n` times continuously differentiable homeomorphism of a nontrivially normed\nfield.  Suppose that the derivative of `f` is never equal to zero. Then `f.symm` is `n` times\ncontinuously differentiable.\n\nThis is one of the easy parts of the inverse function theorem: it assumes that we already have\nan inverse function. -/\ntheorem Homeomorph.contDiff_symm_deriv [CompleteSpace 𝕜] (f : 𝕜 ≃ₜ 𝕜) {f' : 𝕜 → 𝕜}\n    (h₀ : ∀ x, f' x ≠ 0) (hf' : ∀ x, HasDerivAt f (f' x) x) (hf : ContDiff 𝕜 n (f : 𝕜 → 𝕜)) :\n    ContDiff 𝕜 n (f.symm : 𝕜 → 𝕜) :=\n  contDiff_iff_contDiffAt.2 fun x =>\n    f.toPartialHomeomorph.contDiffAt_symm_deriv (h₀ _) (mem_univ x) (hf' _) hf.contDiffAt\n\n"}
{"name":"PartialHomeomorph.restrContDiff_target","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Eq (PartialHomeomorph.restrContDiff 𝕜 f n hn).target (Inter.inter f.target (setOf fun y => And (ContDiffAt 𝕜 n (↑f.symm) y) (ContDiffAt 𝕜 n (↑f) (↑f.symm y))))","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x ∈ f.source`, `y = f x ∈ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `ω`, but not `∞`,\nbecause the set of points of `C^∞`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop ℕ∞) (hn : n ≠ ∞) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt 𝕜 n f x ∧ ContDiffAt 𝕜 n f.symm (f x)}\n      {y | ContDiffAt 𝕜 n f.symm y ∧ ContDiffAt 𝕜 n f (f.symm y)} := fun x hx ↦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ ⟨hxs, hxf, hxf'⟩ ↦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.restrContDiff_source","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ Eq (PartialHomeomorph.restrContDiff 𝕜 f n hn).source (Inter.inter f.source (setOf fun x => And (ContDiffAt 𝕜 n (↑f) x) (ContDiffAt 𝕜 n (↑f.symm) (↑f x))))","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x ∈ f.source`, `y = f x ∈ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `ω`, but not `∞`,\nbecause the set of points of `C^∞`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop ℕ∞) (hn : n ≠ ∞) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt 𝕜 n f x ∧ ContDiffAt 𝕜 n f.symm (f x)}\n      {y | ContDiffAt 𝕜 n f.symm y ∧ ContDiffAt 𝕜 n f (f.symm y)} := fun x hx ↦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ ⟨hxs, hxf, hxf'⟩ ↦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.restrContDiff_symm_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n ↑Top.top\na✝ : F\n⊢ Eq (↑(PartialHomeomorph.restrContDiff 𝕜 f n hn).symm a✝) (↑f.symm a✝)","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x ∈ f.source`, `y = f x ∈ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `ω`, but not `∞`,\nbecause the set of points of `C^∞`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop ℕ∞) (hn : n ≠ ∞) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt 𝕜 n f x ∧ ContDiffAt 𝕜 n f.symm (f x)}\n      {y | ContDiffAt 𝕜 n f.symm y ∧ ContDiffAt 𝕜 n f (f.symm y)} := fun x hx ↦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ ⟨hxs, hxf, hxf'⟩ ↦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.restrContDiff_apply","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n ↑Top.top\na✝ : E\n⊢ Eq (↑(PartialHomeomorph.restrContDiff 𝕜 f n hn) a✝) (↑f a✝)","decl":"/-- Restrict a partial homeomorphism to the subsets of the source and target\nthat consist of points `x ∈ f.source`, `y = f x ∈ f.target`\nsuch that `f` is `C^n` at `x` and `f.symm` is `C^n` at `y`.\n\nNote that `n` is a natural number or `ω`, but not `∞`,\nbecause the set of points of `C^∞`-smoothness of `f` is not guaranteed to be open. -/\n@[simps! apply symm_apply source target]\ndef restrContDiff (f : PartialHomeomorph E F) (n : WithTop ℕ∞) (hn : n ≠ ∞) :\n    PartialHomeomorph E F :=\n  haveI H : f.IsImage {x | ContDiffAt 𝕜 n f x ∧ ContDiffAt 𝕜 n f.symm (f x)}\n      {y | ContDiffAt 𝕜 n f.symm y ∧ ContDiffAt 𝕜 n f (f.symm y)} := fun x hx ↦ by\n    simp [hx, and_comm]\n  H.restr <| isOpen_iff_mem_nhds.2 fun _ ⟨hxs, hxf, hxf'⟩ ↦\n    inter_mem (f.open_source.mem_nhds hxs) <| (hxf.eventually hn).and <|\n    f.continuousAt hxs (hxf'.eventually hn)\n\n"}
{"name":"PartialHomeomorph.contDiffOn_restrContDiff_source","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ ContDiffOn 𝕜 n (↑f) (PartialHomeomorph.restrContDiff 𝕜 f n hn).source","decl":"lemma contDiffOn_restrContDiff_source (f : PartialHomeomorph E F) {n : WithTop ℕ∞} (hn : n ≠ ∞) :\n    ContDiffOn 𝕜 n f (f.restrContDiff 𝕜 n hn).source := fun _x hx ↦ hx.2.1.contDiffWithinAt\n\n"}
{"name":"PartialHomeomorph.contDiffOn_restrContDiff_target","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝⁴ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝³ : NormedAddCommGroup E\ninst✝² : NormedSpace 𝕜 E\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf : PartialHomeomorph E F\nn : WithTop ENat\nhn : Ne n ↑Top.top\n⊢ ContDiffOn 𝕜 n (↑f.symm) (PartialHomeomorph.restrContDiff 𝕜 f n hn).target","decl":"lemma contDiffOn_restrContDiff_target (f : PartialHomeomorph E F) {n : WithTop ℕ∞} (hn : n ≠ ∞) :\n    ContDiffOn 𝕜 n f.symm (f.restrContDiff 𝕜 n hn).target := fun _x hx ↦ hx.2.1.contDiffWithinAt\n\n"}
{"name":"contDiffOn_succ_iff_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhs : UniqueDiffOn 𝕜 s₂\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f₂ s₂) (And (DifferentiableOn 𝕜 f₂ s₂) (And (Eq n Top.top → AnalyticOn 𝕜 f₂ s₂) (ContDiffOn 𝕜 n (derivWithin f₂ s₂) s₂)))","decl":"/-- A function is `C^(n + 1)` on a domain with unique derivatives if and only if it is\ndifferentiable there, and its derivative (formulated with `derivWithin`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_derivWithin (hs : UniqueDiffOn 𝕜 s₂) :\n    ContDiffOn 𝕜 (n + 1) f₂ s₂ ↔\n      DifferentiableOn 𝕜 f₂ s₂ ∧ (n = ω → AnalyticOn 𝕜 f₂ s₂) ∧\n        ContDiffOn 𝕜 n (derivWithin f₂ s₂) s₂ := by\n  rw [contDiffOn_succ_iff_fderivWithin hs, and_congr_right_iff]\n  intro _\n  constructor\n  · rintro ⟨h', h⟩\n    refine ⟨h', ?_⟩\n    have : derivWithin f₂ s₂ = (fun u : 𝕜 →L[𝕜] F => u 1) ∘ fderivWithin 𝕜 f₂ s₂ := by\n      ext x; rfl\n    simp_rw [this]\n    apply ContDiff.comp_contDiffOn _ h\n    exact (isBoundedBilinearMap_apply.isBoundedLinearMap_left _).contDiff\n  · rintro ⟨h', h⟩\n    refine ⟨h', ?_⟩\n    have : fderivWithin 𝕜 f₂ s₂ = smulRight (1 : 𝕜 →L[𝕜] 𝕜) ∘ derivWithin f₂ s₂ := by\n      ext x; simp [derivWithin]\n    simp only [this]\n    apply ContDiff.comp_contDiffOn _ h\n    have : IsBoundedBilinearMap 𝕜 fun _ : (𝕜 →L[𝕜] 𝕜) × F => _ := isBoundedBilinearMap_smulRight\n    exact (this.isBoundedLinearMap_right _).contDiff\n\n"}
{"name":"contDiffOn_infty_iff_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhs : UniqueDiffOn 𝕜 s₂\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f₂ s₂) (And (DifferentiableOn 𝕜 f₂ s₂) (ContDiffOn 𝕜 (↑Top.top) (derivWithin f₂ s₂) s₂))","decl":"theorem contDiffOn_infty_iff_derivWithin (hs : UniqueDiffOn 𝕜 s₂) :\n    ContDiffOn 𝕜 ∞ f₂ s₂ ↔ DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 ∞ (derivWithin f₂ s₂) s₂ := by\n  rw [show ∞ = ∞ + 1 by rfl, contDiffOn_succ_iff_derivWithin hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhs : UniqueDiffOn 𝕜 s₂\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f₂ s₂) (And (DifferentiableOn 𝕜 f₂ s₂) (ContDiffOn 𝕜 (↑Top.top) (derivWithin f₂ s₂) s₂))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_derivWithin := contDiffOn_infty_iff_derivWithin\n\n"}
{"name":"contDiffOn_succ_iff_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhs : IsOpen s₂\n⊢ Iff (ContDiffOn 𝕜 (HAdd.hAdd n 1) f₂ s₂) (And (DifferentiableOn 𝕜 f₂ s₂) (And (Eq n Top.top → AnalyticOn 𝕜 f₂ s₂) (ContDiffOn 𝕜 n (deriv f₂) s₂)))","decl":"/-- A function is `C^(n + 1)` on an open domain if and only if it is\ndifferentiable there, and its derivative (formulated with `deriv`) is `C^n`. -/\ntheorem contDiffOn_succ_iff_deriv_of_isOpen (hs : IsOpen s₂) :\n    ContDiffOn 𝕜 (n + 1) f₂ s₂ ↔\n      DifferentiableOn 𝕜 f₂ s₂ ∧ (n = ω → AnalyticOn 𝕜 f₂ s₂) ∧\n        ContDiffOn 𝕜 n (deriv f₂) s₂ := by\n  rw [contDiffOn_succ_iff_derivWithin hs.uniqueDiffOn]\n  exact Iff.rfl.and (Iff.rfl.and (contDiffOn_congr fun _ => derivWithin_of_isOpen hs))\n\n"}
{"name":"contDiffOn_infty_iff_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhs : IsOpen s₂\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f₂ s₂) (And (DifferentiableOn 𝕜 f₂ s₂) (ContDiffOn 𝕜 (↑Top.top) (deriv f₂) s₂))","decl":"theorem contDiffOn_infty_iff_deriv_of_isOpen (hs : IsOpen s₂) :\n    ContDiffOn 𝕜 ∞ f₂ s₂ ↔ DifferentiableOn 𝕜 f₂ s₂ ∧ ContDiffOn 𝕜 ∞ (deriv f₂) s₂ := by\n  rw [show ∞ = ∞ + 1 by rfl, contDiffOn_succ_iff_deriv_of_isOpen hs]\n  simp\n\n"}
{"name":"contDiffOn_top_iff_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhs : IsOpen s₂\n⊢ Iff (ContDiffOn 𝕜 (↑Top.top) f₂ s₂) (And (DifferentiableOn 𝕜 f₂ s₂) (ContDiffOn 𝕜 (↑Top.top) (deriv f₂) s₂))","decl":"@[deprecated (since := \"2024-11-27\")]\nalias contDiffOn_top_iff_deriv_of_isOpen := contDiffOn_infty_iff_deriv_of_isOpen\n\n"}
{"name":"ContDiffOn.derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nm n : WithTop ENat\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhf : ContDiffOn 𝕜 n f₂ s₂\nhs : UniqueDiffOn 𝕜 s₂\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffOn 𝕜 m (derivWithin f₂ s₂) s₂","decl":"protected theorem ContDiffOn.derivWithin (hf : ContDiffOn 𝕜 n f₂ s₂) (hs : UniqueDiffOn 𝕜 s₂)\n    (hmn : m + 1 ≤ n) : ContDiffOn 𝕜 m (derivWithin f₂ s₂) s₂ :=\n  ((contDiffOn_succ_iff_derivWithin hs).1 (hf.of_le hmn)).2.2\n\n"}
{"name":"ContDiffOn.deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nm n : WithTop ENat\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nhf : ContDiffOn 𝕜 n f₂ s₂\nhs : IsOpen s₂\nhmn : LE.le (HAdd.hAdd m 1) n\n⊢ ContDiffOn 𝕜 m (deriv f₂) s₂","decl":"theorem ContDiffOn.deriv_of_isOpen (hf : ContDiffOn 𝕜 n f₂ s₂) (hs : IsOpen s₂) (hmn : m + 1 ≤ n) :\n    ContDiffOn 𝕜 m (deriv f₂) s₂ :=\n  (hf.derivWithin hs.uniqueDiffOn hmn).congr fun _ hx => (derivWithin_of_isOpen hs hx).symm\n\n"}
{"name":"ContDiffOn.continuousOn_derivWithin","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nh : ContDiffOn 𝕜 n f₂ s₂\nhs : UniqueDiffOn 𝕜 s₂\nhn : LE.le 1 n\n⊢ ContinuousOn (derivWithin f₂ s₂) s₂","decl":"theorem ContDiffOn.continuousOn_derivWithin (h : ContDiffOn 𝕜 n f₂ s₂) (hs : UniqueDiffOn 𝕜 s₂)\n    (hn : 1 ≤ n) : ContinuousOn (derivWithin f₂ s₂) s₂ := by\n  rw [show (1 : WithTop ℕ∞) = 0 + 1 from rfl] at hn\n  exact ((contDiffOn_succ_iff_derivWithin hs).1 (h.of_le hn)).2.2.continuousOn\n\n"}
{"name":"ContDiffOn.continuousOn_deriv_of_isOpen","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₂ : 𝕜 → F\ns₂ : Set 𝕜\nh : ContDiffOn 𝕜 n f₂ s₂\nhs : IsOpen s₂\nhn : LE.le 1 n\n⊢ ContinuousOn (deriv f₂) s₂","decl":"theorem ContDiffOn.continuousOn_deriv_of_isOpen (h : ContDiffOn 𝕜 n f₂ s₂) (hs : IsOpen s₂)\n    (hn : 1 ≤ n) : ContinuousOn (deriv f₂) s₂ := by\n  rw [show (1 : WithTop ℕ∞) = 0 + 1 from rfl] at hn\n  exact ((contDiffOn_succ_iff_deriv_of_isOpen hs).1 (h.of_le hn)).2.2.continuousOn\n\n"}
{"name":"contDiff_succ_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₂ : 𝕜 → F\n⊢ Iff (ContDiff 𝕜 (HAdd.hAdd n 1) f₂) (And (Differentiable 𝕜 f₂) (And (Eq n Top.top → AnalyticOn 𝕜 f₂ Set.univ) (ContDiff 𝕜 n (deriv f₂))))","decl":"/-- A function is `C^(n + 1)` if and only if it is differentiable,\n  and its derivative (formulated in terms of `deriv`) is `C^n`. -/\ntheorem contDiff_succ_iff_deriv :\n    ContDiff 𝕜 (n + 1) f₂ ↔ Differentiable 𝕜 f₂ ∧ (n = ω → AnalyticOn 𝕜 f₂ univ) ∧\n      ContDiff 𝕜 n (deriv f₂) := by\n  simp only [← contDiffOn_univ, contDiffOn_succ_iff_deriv_of_isOpen, isOpen_univ,\n    differentiableOn_univ]\n\n"}
{"name":"contDiff_one_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\n⊢ Iff (ContDiff 𝕜 1 f₂) (And (Differentiable 𝕜 f₂) (Continuous (deriv f₂)))","decl":"theorem contDiff_one_iff_deriv :\n    ContDiff 𝕜 1 f₂ ↔ Differentiable 𝕜 f₂ ∧ Continuous (deriv f₂) := by\n  rw [show (1 : WithTop ℕ∞) = 0 + 1 from rfl, contDiff_succ_iff_deriv]\n  simp\n\n"}
{"name":"contDiff_infty_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f₂) (And (Differentiable 𝕜 f₂) (ContDiff 𝕜 (↑Top.top) (deriv f₂)))","decl":"theorem contDiff_infty_iff_deriv :\n    ContDiff 𝕜 ∞ f₂ ↔ Differentiable 𝕜 f₂ ∧ ContDiff 𝕜 ∞ (deriv f₂) := by\n  rw [show (∞ : WithTop ℕ∞) = ∞ + 1 from rfl, contDiff_succ_iff_deriv]\n  simp\n\n"}
{"name":"contDiff_top_iff_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nf₂ : 𝕜 → F\n⊢ Iff (ContDiff 𝕜 (↑Top.top) f₂) (And (Differentiable 𝕜 f₂) (ContDiff 𝕜 (↑Top.top) (deriv f₂)))","decl":"@[deprecated (since := \"2024-11-27\")] alias contDiff_top_iff_deriv := contDiff_infty_iff_deriv\n\n"}
{"name":"ContDiff.continuous_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : WithTop ENat\nf₂ : 𝕜 → F\nh : ContDiff 𝕜 n f₂\nhn : LE.le 1 n\n⊢ Continuous (deriv f₂)","decl":"theorem ContDiff.continuous_deriv (h : ContDiff 𝕜 n f₂) (hn : 1 ≤ n) : Continuous (deriv f₂) := by\n  rw [show (1 : WithTop ℕ∞) = 0 + 1 from rfl] at hn\n  exact (contDiff_succ_iff_deriv.mp (h.of_le hn)).2.2.continuous\n\n"}
{"name":"ContDiff.iterate_deriv","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn : Nat\nf₂ : 𝕜 → F\na✝ : ContDiff 𝕜 (↑Top.top) f₂\n⊢ ContDiff 𝕜 (↑Top.top) (Nat.iterate deriv n f₂)","decl":"theorem ContDiff.iterate_deriv :\n    ∀ (n : ℕ) {f₂ : 𝕜 → F}, ContDiff 𝕜 ∞ f₂ → ContDiff 𝕜 ∞ (deriv^[n] f₂)\n  | 0,     _, hf => hf\n  | n + 1, _, hf => ContDiff.iterate_deriv n (contDiff_infty_iff_deriv.mp hf).2\n\n"}
{"name":"ContDiff.iterate_deriv'","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝² : NontriviallyNormedField 𝕜\nF : Type uF\ninst✝¹ : NormedAddCommGroup F\ninst✝ : NormedSpace 𝕜 F\nn k : Nat\nf₂ : 𝕜 → F\na✝ : ContDiff 𝕜 (↑(HAdd.hAdd n k)) f₂\n⊢ ContDiff 𝕜 (↑n) (Nat.iterate deriv k f₂)","decl":"theorem ContDiff.iterate_deriv' (n : ℕ) :\n    ∀ (k : ℕ) {f₂ : 𝕜 → F}, ContDiff 𝕜 (n + k : ℕ) f₂ → ContDiff 𝕜 n (deriv^[k] f₂)\n  | 0,     _, hf => hf\n  | k + 1, _, hf => ContDiff.iterate_deriv' _ k (contDiff_succ_iff_deriv.mp hf).2.2\n\n"}
{"name":"HasFTaylorSeriesUpToOn.restrictScalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\n𝕜' : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\np' : E → FormalMultilinearSeries 𝕜' E F\nn : WithTop ENat\nh : HasFTaylorSeriesUpToOn n f p' s\n⊢ HasFTaylorSeriesUpToOn n f (fun x => FormalMultilinearSeries.restrictScalars 𝕜 (p' x)) s","decl":"theorem HasFTaylorSeriesUpToOn.restrictScalars {n : WithTop ℕ∞}\n    (h : HasFTaylorSeriesUpToOn n f p' s) :\n    HasFTaylorSeriesUpToOn n f (fun x => (p' x).restrictScalars 𝕜) s where\n  zero_eq x hx := h.zero_eq x hx\n  fderivWithin m hm x hx :=\n    set_option maxSynthPendingDepth 2 in\n    ((ContinuousMultilinearMap.restrictScalarsLinear 𝕜).hasFDerivAt.comp_hasFDerivWithinAt x <|\n        (h.fderivWithin m hm x hx).restrictScalars 𝕜 :)\n  cont m hm := ContinuousMultilinearMap.continuous_restrictScalars.comp_continuousOn (h.cont m hm)\n\n"}
{"name":"ContDiffWithinAt.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nx : E\nn : WithTop ENat\n𝕜' : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nh : ContDiffWithinAt 𝕜' n f s x\n⊢ ContDiffWithinAt 𝕜 n f s x","decl":"theorem ContDiffWithinAt.restrict_scalars (h : ContDiffWithinAt 𝕜' n f s x) :\n    ContDiffWithinAt 𝕜 n f s x := by\n  match n with\n  | ω =>\n    obtain ⟨u, u_mem, p', hp', Hp'⟩ := h\n    refine ⟨u, u_mem, _, hp'.restrictScalars _, fun i ↦ ?_⟩\n    change AnalyticOn 𝕜 (fun x ↦ ContinuousMultilinearMap.restrictScalarsLinear 𝕜 (p' x i)) u\n    apply AnalyticOnNhd.comp_analyticOn _ (Hp' i).restrictScalars (Set.mapsTo_univ _ _)\n    exact ContinuousLinearMap.analyticOnNhd _ _\n  | (n : ℕ∞) =>\n    intro m hm\n    rcases h m hm with ⟨u, u_mem, p', hp'⟩\n    exact ⟨u, u_mem, _, hp'.restrictScalars _⟩\n\n"}
{"name":"ContDiffOn.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\ns : Set E\nf : E → F\nn : WithTop ENat\n𝕜' : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nh : ContDiffOn 𝕜' n f s\n⊢ ContDiffOn 𝕜 n f s","decl":"theorem ContDiffOn.restrict_scalars (h : ContDiffOn 𝕜' n f s) : ContDiffOn 𝕜 n f s := fun x hx =>\n  (h x hx).restrict_scalars _\n\n"}
{"name":"ContDiffAt.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nf : E → F\nx : E\nn : WithTop ENat\n𝕜' : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nh : ContDiffAt 𝕜' n f x\n⊢ ContDiffAt 𝕜 n f x","decl":"theorem ContDiffAt.restrict_scalars (h : ContDiffAt 𝕜' n f x) : ContDiffAt 𝕜 n f x :=\n  contDiffWithinAt_univ.1 <| h.contDiffWithinAt.restrict_scalars _\n\n"}
{"name":"ContDiff.restrict_scalars","module":"Mathlib.Analysis.Calculus.ContDiff.Basic","initialProofState":"𝕜 : Type u_1\ninst✝¹⁰ : NontriviallyNormedField 𝕜\nE : Type uE\ninst✝⁹ : NormedAddCommGroup E\ninst✝⁸ : NormedSpace 𝕜 E\nF : Type uF\ninst✝⁷ : NormedAddCommGroup F\ninst✝⁶ : NormedSpace 𝕜 F\nf : E → F\nn : WithTop ENat\n𝕜' : Type u_3\ninst✝⁵ : NontriviallyNormedField 𝕜'\ninst✝⁴ : NormedAlgebra 𝕜 𝕜'\ninst✝³ : NormedSpace 𝕜' E\ninst✝² : IsScalarTower 𝕜 𝕜' E\ninst✝¹ : NormedSpace 𝕜' F\ninst✝ : IsScalarTower 𝕜 𝕜' F\nh : ContDiff 𝕜' n f\n⊢ ContDiff 𝕜 n f","decl":"theorem ContDiff.restrict_scalars (h : ContDiff 𝕜' n f) : ContDiff 𝕜 n f :=\n  contDiff_iff_contDiffAt.2 fun _ => h.contDiffAt.restrict_scalars _\n\n"}
