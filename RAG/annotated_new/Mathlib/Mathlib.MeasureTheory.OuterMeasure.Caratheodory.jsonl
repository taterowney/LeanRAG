{"name":"MeasureTheory.OuterMeasure.isCaratheodory_iff_le'","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Iff (m.IsCaratheodory s) (∀ (t : Set α), LE.le (HAdd.hAdd (m (Inter.inter t s)) (m (SDiff.sdiff t s))) (m t))","decl":"theorem isCaratheodory_iff_le' {s : Set α} :\n    IsCaratheodory m s ↔ ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t :=\n  forall_congr' fun _ => le_antisymm_iff.trans <| and_iff_right <| measure_le_inter_add_diff _ _ _\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_empty","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\n⊢ m.IsCaratheodory EmptyCollection.emptyCollection","decl":"@[simp]\ntheorem isCaratheodory_empty : IsCaratheodory m ∅ := by simp [IsCaratheodory, m.empty, diff_empty]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_compl","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns₁ : Set α\na✝ : m.IsCaratheodory s₁\n⊢ m.IsCaratheodory (HasCompl.compl s₁)","decl":"theorem isCaratheodory_compl : IsCaratheodory m s₁ → IsCaratheodory m s₁ᶜ := by\n  simp [IsCaratheodory, diff_eq, add_comm]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_compl_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Iff (m.IsCaratheodory (HasCompl.compl s)) (m.IsCaratheodory s)","decl":"@[simp]\ntheorem isCaratheodory_compl_iff : IsCaratheodory m sᶜ ↔ IsCaratheodory m s :=\n  ⟨fun h => by simpa using isCaratheodory_compl m h, isCaratheodory_compl m⟩\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_union","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns₁ s₂ : Set α\nh₁ : m.IsCaratheodory s₁\nh₂ : m.IsCaratheodory s₂\n⊢ m.IsCaratheodory (Union.union s₁ s₂)","decl":"theorem isCaratheodory_union (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :\n    IsCaratheodory m (s₁ ∪ s₂) := fun t => by\n  rw [h₁ t, h₂ (t ∩ s₁), h₂ (t \\ s₁), h₁ (t ∩ (s₁ ∪ s₂)), inter_diff_assoc _ _ s₁,\n    Set.inter_assoc _ _ s₁, inter_eq_self_of_subset_right Set.subset_union_left,\n    union_diff_left, h₂ (t ∩ s₁)]\n  simp [diff_eq, add_assoc]\n\n"}
{"name":"MeasureTheory.OuterMeasure.IsCaratheodory.biUnion_of_finite","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\nι : Type u_1\ns : ι → Set α\nt : Set ι\nht : t.Finite\nh : ∀ (i : ι), Membership.mem t i → m.IsCaratheodory (s i)\n⊢ m.IsCaratheodory (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"variable {m} in\nlemma IsCaratheodory.biUnion_of_finite {ι : Type*} {s : ι → Set α} {t : Set ι} (ht : t.Finite)\n    (h : ∀ i ∈ t, m.IsCaratheodory (s i)) :\n    m.IsCaratheodory (⋃ i ∈ t, s i) := by\n  classical\n  lift t to Finset ι using ht\n  induction t using Finset.induction_on with\n  | empty => simp\n  | @insert i t hi IH =>\n    simp only [Finset.mem_coe, Finset.mem_insert, iUnion_iUnion_eq_or_left] at h ⊢\n    exact m.isCaratheodory_union (h _ <| Or.inl rfl) (IH fun _ hj ↦ h _ <| Or.inr hj)\n\n"}
{"name":"MeasureTheory.OuterMeasure.measure_inter_union","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns₁ s₂ : Set α\nh : HasSubset.Subset (Inter.inter s₁ s₂) EmptyCollection.emptyCollection\nh₁ : m.IsCaratheodory s₁\nt : Set α\n⊢ Eq (m (Inter.inter t (Union.union s₁ s₂))) (HAdd.hAdd (m (Inter.inter t s₁)) (m (Inter.inter t s₂)))","decl":"theorem measure_inter_union (h : s₁ ∩ s₂ ⊆ ∅) (h₁ : IsCaratheodory m s₁) {t : Set α} :\n    m (t ∩ (s₁ ∪ s₂)) = m (t ∩ s₁) + m (t ∩ s₂) := by\n  rw [h₁, Set.inter_assoc, Set.union_inter_cancel_left, inter_diff_assoc, union_diff_cancel_left h]\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_iUnion_lt","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Nat → Set α\nn : Nat\na✝ : ∀ (i : Nat), LT.lt i n → m.IsCaratheodory (s i)\n⊢ m.IsCaratheodory (Set.iUnion fun i => Set.iUnion fun h => s i)","decl":"theorem isCaratheodory_iUnion_lt {s : ℕ → Set α} :\n    ∀ {n : ℕ}, (∀ i < n, IsCaratheodory m (s i)) → IsCaratheodory m (⋃ i < n, s i)\n  | 0, _ => by simp [Nat.not_lt_zero]\n  | n + 1, h => by\n    rw [biUnion_lt_succ]\n    exact isCaratheodory_union m\n            (isCaratheodory_iUnion_lt fun i hi => h i <| lt_of_lt_of_le hi <| Nat.le_succ _)\n            (h n (le_refl (n + 1)))\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_inter","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns₁ s₂ : Set α\nh₁ : m.IsCaratheodory s₁\nh₂ : m.IsCaratheodory s₂\n⊢ m.IsCaratheodory (Inter.inter s₁ s₂)","decl":"theorem isCaratheodory_inter (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :\n    IsCaratheodory m (s₁ ∩ s₂) := by\n  rw [← isCaratheodory_compl_iff, Set.compl_inter]\n  exact isCaratheodory_union _ (isCaratheodory_compl _ h₁) (isCaratheodory_compl _ h₂)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_diff","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns₁ s₂ : Set α\nh₁ : m.IsCaratheodory s₁\nh₂ : m.IsCaratheodory s₂\n⊢ m.IsCaratheodory (SDiff.sdiff s₁ s₂)","decl":"lemma isCaratheodory_diff (h₁ : IsCaratheodory m s₁) (h₂ : IsCaratheodory m s₂) :\n    IsCaratheodory m (s₁ \\ s₂) := m.isCaratheodory_inter h₁ (m.isCaratheodory_compl h₂)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_partialSups","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\nι : Type u_1\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\ns : ι → Set α\nh : ∀ (i : ι), m.IsCaratheodory (s i)\ni : ι\n⊢ m.IsCaratheodory ((partialSups s) i)","decl":"lemma isCaratheodory_partialSups {ι : Type*} [PartialOrder ι] [LocallyFiniteOrderBot ι]\n    {s : ι → Set α} (h : ∀ i, m.IsCaratheodory (s i)) (i : ι) :\n    m.IsCaratheodory (partialSups s i) := by\n  simpa only [partialSups_apply, Finset.sup'_eq_sup, Finset.sup_set_eq_biUnion, ← Finset.mem_coe,\n    Finset.coe_Iic] using .biUnion_of_finite (finite_Iic _) (fun j _ ↦ h j)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_disjointed","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\nι : Type u_1\ninst✝¹ : PartialOrder ι\ninst✝ : LocallyFiniteOrderBot ι\ns : ι → Set α\nh : ∀ (i : ι), m.IsCaratheodory (s i)\ni : ι\n⊢ m.IsCaratheodory (disjointed s i)","decl":"lemma isCaratheodory_disjointed {ι : Type*} [PartialOrder ι] [LocallyFiniteOrderBot ι]\n    {s : ι → Set α} (h : ∀ i, m.IsCaratheodory (s i)) (i : ι) :\n    m.IsCaratheodory (disjointed s i) :=\n  disjointedRec (fun _ j ht ↦ m.isCaratheodory_diff ht <| h j) (h i)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_sum","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Nat → Set α\nh : ∀ (i : Nat), m.IsCaratheodory (s i)\nhd : Pairwise (Function.onFun Disjoint s)\nt : Set α\nn : Nat\n⊢ Eq ((Finset.range n).sum fun i => m (Inter.inter t (s i))) (m (Inter.inter t (Set.iUnion fun i => Set.iUnion fun h => s i)))","decl":"theorem isCaratheodory_sum {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i))\n    (hd : Pairwise (Disjoint on s)) {t : Set α} :\n    ∀ {n}, (∑ i ∈ Finset.range n, m (t ∩ s i)) = m (t ∩ ⋃ i < n, s i)\n  | 0 => by simp [Nat.not_lt_zero, m.empty]\n  | Nat.succ n => by\n    rw [biUnion_lt_succ, Finset.sum_range_succ, Set.union_comm, isCaratheodory_sum h hd,\n      m.measure_inter_union _ (h n), add_comm]\n    intro a\n    simpa using fun (h₁ : a ∈ s n) i (hi : i < n) h₂ => (hd (ne_of_gt hi)).le_bot ⟨h₁, h₂⟩\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_iUnion_of_disjoint","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Nat → Set α\nh : ∀ (i : Nat), m.IsCaratheodory (s i)\nhd : Pairwise (Function.onFun Disjoint s)\n⊢ m.IsCaratheodory (Set.iUnion fun i => s i)","decl":"/-- Use `isCaratheodory_iUnion` instead, which does not require the disjoint assumption. -/\ntheorem isCaratheodory_iUnion_of_disjoint {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i))\n    (hd : Pairwise (Disjoint on s)) : IsCaratheodory m (⋃ i, s i) := by\n      apply (isCaratheodory_iff_le' m).mpr\n      intro t\n      have hp : m (t ∩ ⋃ i, s i) ≤ ⨆ n, m (t ∩ ⋃ i < n, s i) := by\n        convert measure_iUnion_le (μ := m) fun i => t ∩ s i using 1\n        · simp [inter_iUnion]\n        · simp [ENNReal.tsum_eq_iSup_nat, isCaratheodory_sum m h hd]\n      refine le_trans (add_le_add_right hp _) ?_\n      rw [ENNReal.iSup_add]\n      refine iSup_le fun n => le_trans (add_le_add_left ?_ _)\n        (ge_of_eq (isCaratheodory_iUnion_lt m (fun i _ => h i) _))\n      refine m.mono (diff_subset_diff_right ?_)\n      exact iUnion₂_subset fun i _ => subset_iUnion _ i\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_iUnion","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Nat → Set α\nh : ∀ (i : Nat), m.IsCaratheodory (s i)\n⊢ m.IsCaratheodory (Set.iUnion fun i => s i)","decl":"lemma isCaratheodory_iUnion {s : ℕ → Set α} (h : ∀ i, m.IsCaratheodory (s i)) :\n    m.IsCaratheodory (⋃ i, s i) := by\n  rw [← iUnion_disjointed]\n  exact m.isCaratheodory_iUnion_of_disjoint (m.isCaratheodory_disjointed h)\n    (disjoint_disjointed _)\n\n"}
{"name":"MeasureTheory.OuterMeasure.f_iUnion","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Nat → Set α\nh : ∀ (i : Nat), m.IsCaratheodory (s i)\nhd : Pairwise (Function.onFun Disjoint s)\n⊢ Eq (m (Set.iUnion fun i => s i)) (tsum fun i => m (s i))","decl":"theorem f_iUnion {s : ℕ → Set α} (h : ∀ i, IsCaratheodory m (s i)) (hd : Pairwise (Disjoint on s)) :\n    m (⋃ i, s i) = ∑' i, m (s i) := by\n  refine le_antisymm (measure_iUnion_le s) ?_\n  rw [ENNReal.tsum_eq_iSup_nat]\n  refine iSup_le fun n => ?_\n  have := @isCaratheodory_sum _ m _ h hd univ n\n  simp only [inter_comm, inter_univ, univ_inter] at this; simp only [this]\n  exact m.mono (iUnion₂_subset fun i _ => subset_iUnion _ i)\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_iff","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Iff (MeasurableSet s) (∀ (t : Set α), Eq (m t) (HAdd.hAdd (m (Inter.inter t s)) (m (SDiff.sdiff t s))))","decl":"theorem isCaratheodory_iff {s : Set α} :\n    MeasurableSet[OuterMeasure.caratheodory m] s ↔ ∀ t, m t = m (t ∩ s) + m (t \\ s) :=\n  Iff.rfl\n\n"}
{"name":"MeasureTheory.OuterMeasure.isCaratheodory_iff_le","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Set α\n⊢ Iff (MeasurableSet s) (∀ (t : Set α), LE.le (HAdd.hAdd (m (Inter.inter t s)) (m (SDiff.sdiff t s))) (m t))","decl":"theorem isCaratheodory_iff_le {s : Set α} :\n    MeasurableSet[OuterMeasure.caratheodory m] s ↔ ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t :=\n  isCaratheodory_iff_le' m\n\n"}
{"name":"MeasureTheory.OuterMeasure.iUnion_eq_of_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u\nm : MeasureTheory.OuterMeasure α\ns : Nat → Set α\nh : ∀ (i : Nat), MeasurableSet (s i)\nhd : Pairwise (Function.onFun Disjoint s)\n⊢ Eq (m (Set.iUnion fun i => s i)) (tsum fun i => m (s i))","decl":"protected theorem iUnion_eq_of_caratheodory {s : ℕ → Set α}\n    (h : ∀ i, MeasurableSet[OuterMeasure.caratheodory m] (s i)) (hd : Pairwise (Disjoint on s)) :\n    m (⋃ i, s i) = ∑' i, m (s i) :=\n  f_iUnion m h hd\n\n"}
{"name":"MeasureTheory.OuterMeasure.ofFunction_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\nm : Set α → ENNReal\ns : Set α\nh₀ : Eq (m EmptyCollection.emptyCollection) 0\nhs : ∀ (t : Set α), LE.le (HAdd.hAdd (m (Inter.inter t s)) (m (SDiff.sdiff t s))) (m t)\n⊢ MeasurableSet s","decl":"theorem ofFunction_caratheodory {m : Set α → ℝ≥0∞} {s : Set α} {h₀ : m ∅ = 0}\n    (hs : ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t) :\n    MeasurableSet[(OuterMeasure.ofFunction m h₀).caratheodory] s := by\n  apply (isCaratheodory_iff_le _).mpr\n  refine fun t => le_iInf fun f => le_iInf fun hf => ?_\n  refine\n    le_trans\n      (add_le_add ((iInf_le_of_le fun i => f i ∩ s) <| iInf_le _ ?_)\n        ((iInf_le_of_le fun i => f i \\ s) <| iInf_le _ ?_))\n      ?_\n  · rw [← iUnion_inter]\n    exact inter_subset_inter_left _ hf\n  · rw [← iUnion_diff]\n    exact diff_subset_diff_left hf\n  · rw [← ENNReal.tsum_add]\n    exact ENNReal.tsum_le_tsum fun i => hs _\n\n"}
{"name":"MeasureTheory.OuterMeasure.boundedBy_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\nm : Set α → ENNReal\ns : Set α\nhs : ∀ (t : Set α), LE.le (HAdd.hAdd (m (Inter.inter t s)) (m (SDiff.sdiff t s))) (m t)\n⊢ MeasurableSet s","decl":"theorem boundedBy_caratheodory {m : Set α → ℝ≥0∞} {s : Set α}\n    (hs : ∀ t, m (t ∩ s) + m (t \\ s) ≤ m t) : MeasurableSet[(boundedBy m).caratheodory] s := by\n  apply ofFunction_caratheodory; intro t\n  rcases t.eq_empty_or_nonempty with h | h\n  · simp [h, Set.not_nonempty_empty]\n  · convert le_trans _ (hs t)\n    · simp [h]\n    exact add_le_add iSup_const_le iSup_const_le\n\n"}
{"name":"MeasureTheory.OuterMeasure.zero_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\n⊢ Eq (MeasureTheory.OuterMeasure.caratheodory 0) Top.top","decl":"@[simp]\ntheorem zero_caratheodory : (0 : OuterMeasure α).caratheodory = ⊤ :=\n  top_unique fun _ _ _ => (add_zero _).symm\n\n"}
{"name":"MeasureTheory.OuterMeasure.top_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\n⊢ Eq Top.top.caratheodory Top.top","decl":"theorem top_caratheodory : (⊤ : OuterMeasure α).caratheodory = ⊤ :=\n  top_unique fun s _ =>\n    (isCaratheodory_iff_le _).2 fun t =>\n      t.eq_empty_or_nonempty.elim (fun ht => by simp [ht]) fun ht => by\n        simp only [ht, top_apply, le_top]\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_add_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\nm₁ m₂ : MeasureTheory.OuterMeasure α\n⊢ LE.le (Min.min m₁.caratheodory m₂.caratheodory) (HAdd.hAdd m₁ m₂).caratheodory","decl":"theorem le_add_caratheodory (m₁ m₂ : OuterMeasure α) :\n    m₁.caratheodory ⊓ m₂.caratheodory ≤ (m₁ + m₂ : OuterMeasure α).caratheodory :=\n  fun s ⟨hs₁, hs₂⟩ t => by simp [hs₁ t, hs₂ t, add_left_comm, add_assoc]\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_sum_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\nι : Type u_2\nm : ι → MeasureTheory.OuterMeasure α\n⊢ LE.le (iInf fun i => (m i).caratheodory) (MeasureTheory.OuterMeasure.sum m).caratheodory","decl":"theorem le_sum_caratheodory {ι} (m : ι → OuterMeasure α) :\n    ⨅ i, (m i).caratheodory ≤ (sum m).caratheodory := fun s h t => by\n  simp [fun i => MeasurableSpace.measurableSet_iInf.1 h i t, ENNReal.tsum_add]\n\n"}
{"name":"MeasureTheory.OuterMeasure.le_smul_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\na : ENNReal\nm : MeasureTheory.OuterMeasure α\n⊢ LE.le m.caratheodory (HSMul.hSMul a m).caratheodory","decl":"theorem le_smul_caratheodory (a : ℝ≥0∞) (m : OuterMeasure α) :\n    m.caratheodory ≤ (a • m).caratheodory := fun s h t => by\n      simp only [smul_apply, smul_eq_mul]\n      rw [(isCaratheodory_iff m).mp h t]\n      simp [mul_add]\n\n"}
{"name":"MeasureTheory.OuterMeasure.dirac_caratheodory","module":"Mathlib.MeasureTheory.OuterMeasure.Caratheodory","initialProofState":"α : Type u_1\na : α\n⊢ Eq (MeasureTheory.OuterMeasure.dirac a).caratheodory Top.top","decl":"@[simp]\ntheorem dirac_caratheodory (a : α) : (dirac a).caratheodory = ⊤ :=\n  top_unique fun s _ t => by\n    by_cases ht : a ∈ t; swap; · simp [ht]\n    by_cases hs : a ∈ s <;> simp [*]\n\n"}
