{"name":"Matrix.Nondegenerate.eq_zero_of_ortho","module":"Mathlib.LinearAlgebra.Matrix.Nondegenerate","initialProofState":"m : Type u_1\nR : Type u_2\ninst✝¹ : Fintype m\ninst✝ : CommRing R\nM : Matrix m m R\nhM : M.Nondegenerate\nv : m → R\nhv : ∀ (w : m → R), Eq (dotProduct v (M.mulVec w)) 0\n⊢ Eq v 0","decl":"/-- If `M` is nondegenerate and `w * M * v = 0` for all `w`, then `v = 0`. -/\ntheorem Nondegenerate.eq_zero_of_ortho {M : Matrix m m R} (hM : Nondegenerate M) {v : m → R}\n    (hv : ∀ w, dotProduct v (M *ᵥ w) = 0) : v = 0 :=\n  hM v hv\n\n"}
{"name":"Matrix.Nondegenerate.exists_not_ortho_of_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Nondegenerate","initialProofState":"m : Type u_1\nR : Type u_2\ninst✝¹ : Fintype m\ninst✝ : CommRing R\nM : Matrix m m R\nhM : M.Nondegenerate\nv : m → R\nhv : Ne v 0\n⊢ Exists fun w => Ne (dotProduct v (M.mulVec w)) 0","decl":"/-- If `M` is nondegenerate and `v ≠ 0`, then there is some `w` such that `w * M * v ≠ 0`. -/\ntheorem Nondegenerate.exists_not_ortho_of_ne_zero {M : Matrix m m R} (hM : Nondegenerate M)\n    {v : m → R} (hv : v ≠ 0) : ∃ w, dotProduct v (M *ᵥ w) ≠ 0 :=\n  not_forall.mp (mt hM.eq_zero_of_ortho hv)\n\n"}
{"name":"Matrix.nondegenerate_of_det_ne_zero","module":"Mathlib.LinearAlgebra.Matrix.Nondegenerate","initialProofState":"m : Type u_1\nA : Type u_3\ninst✝³ : Fintype m\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : DecidableEq m\nM : Matrix m m A\nhM : Ne M.det 0\n⊢ M.Nondegenerate","decl":"/-- If `M` has a nonzero determinant, then `M` as a bilinear form on `n → A` is nondegenerate.\n\nSee also `BilinForm.nondegenerateOfDetNeZero'` and `BilinForm.nondegenerateOfDetNeZero`.\n-/\ntheorem nondegenerate_of_det_ne_zero [DecidableEq m] {M : Matrix m m A} (hM : M.det ≠ 0) :\n    Nondegenerate M := by\n  intro v hv\n  ext i\n  specialize hv (M.cramer (Pi.single i 1))\n  refine (mul_eq_zero.mp ?_).resolve_right hM\n  convert hv\n  simp only [mulVec_cramer M (Pi.single i 1), dotProduct, Pi.smul_apply, smul_eq_mul]\n  rw [Finset.sum_eq_single i, Pi.single_eq_same, mul_one]\n  · intro j _ hj\n    simp [hj]\n  · intros\n    have := Finset.mem_univ i\n    contradiction\n\n"}
{"name":"Matrix.eq_zero_of_vecMul_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Nondegenerate","initialProofState":"m : Type u_1\nA : Type u_3\ninst✝³ : Fintype m\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : DecidableEq m\nM : Matrix m m A\nhM : Ne M.det 0\nv : m → A\nhv : Eq (Matrix.vecMul v M) 0\n⊢ Eq v 0","decl":"theorem eq_zero_of_vecMul_eq_zero [DecidableEq m] {M : Matrix m m A} (hM : M.det ≠ 0) {v : m → A}\n    (hv : v ᵥ* M = 0) : v = 0 :=\n  (nondegenerate_of_det_ne_zero hM).eq_zero_of_ortho fun w => by\n    rw [dotProduct_mulVec, hv, zero_dotProduct]\n\n"}
{"name":"Matrix.eq_zero_of_mulVec_eq_zero","module":"Mathlib.LinearAlgebra.Matrix.Nondegenerate","initialProofState":"m : Type u_1\nA : Type u_3\ninst✝³ : Fintype m\ninst✝² : CommRing A\ninst✝¹ : IsDomain A\ninst✝ : DecidableEq m\nM : Matrix m m A\nhM : Ne M.det 0\nv : m → A\nhv : Eq (M.mulVec v) 0\n⊢ Eq v 0","decl":"theorem eq_zero_of_mulVec_eq_zero [DecidableEq m] {M : Matrix m m A} (hM : M.det ≠ 0) {v : m → A}\n    (hv : M *ᵥ v = 0) : v = 0 :=\n  eq_zero_of_vecMul_eq_zero (by rwa [det_transpose]) ((vecMul_transpose M v).trans hv)\n\n"}
