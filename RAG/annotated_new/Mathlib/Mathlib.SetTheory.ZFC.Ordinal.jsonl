{"name":"ZFSet.isTransitive_empty","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"⊢ EmptyCollection.emptyCollection.IsTransitive","decl":"@[simp]\ntheorem isTransitive_empty : IsTransitive ∅ := fun y hy => (not_mem_empty y hy).elim\n\n"}
{"name":"ZFSet.empty_isTransitive","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"⊢ EmptyCollection.emptyCollection.IsTransitive","decl":"@[deprecated isTransitive_empty (since := \"2024-09-21\")]\nalias empty_isTransitive := isTransitive_empty\n\n"}
{"name":"ZFSet.IsTransitive.subset_of_mem","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nh : x.IsTransitive\na✝ : Membership.mem x y\n⊢ HasSubset.Subset y x","decl":"theorem IsTransitive.subset_of_mem (h : x.IsTransitive) : y ∈ x → y ⊆ x := h y\n\n"}
{"name":"ZFSet.isTransitive_iff_mem_trans","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"z : ZFSet.{u}\n⊢ Iff z.IsTransitive (∀ {x y : ZFSet.{u}}, Membership.mem y x → Membership.mem z y → Membership.mem z x)","decl":"theorem isTransitive_iff_mem_trans : z.IsTransitive ↔ ∀ {x y : ZFSet}, x ∈ y → y ∈ z → x ∈ z :=\n  ⟨fun h _ _ hx hy => h.subset_of_mem hy hx, fun H _ hx _ hy => H hy hx⟩\n\n"}
{"name":"ZFSet.IsTransitive.mem_trans","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"z : ZFSet.{u}\na✝² : z.IsTransitive\nx y : ZFSet.{u}\na✝¹ : Membership.mem y x\na✝ : Membership.mem z y\n⊢ Membership.mem z x","decl":"alias ⟨IsTransitive.mem_trans, _⟩ := isTransitive_iff_mem_trans\n\n"}
{"name":"ZFSet.IsTransitive.inter","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsTransitive\nhy : y.IsTransitive\n⊢ (Inter.inter x y).IsTransitive","decl":"protected theorem IsTransitive.inter (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (x ∩ y).IsTransitive := fun z hz w hw => by\n  rw [mem_inter] at hz ⊢\n  exact ⟨hx.mem_trans hw hz.1, hy.mem_trans hw hz.2⟩\n\n"}
{"name":"ZFSet.IsTransitive.sUnion","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\nh : x.IsTransitive\n⊢ x.sUnion.IsTransitive","decl":"/-- The union of a transitive set is transitive. -/\nprotected theorem IsTransitive.sUnion (h : x.IsTransitive) :\n    (⋃₀ x : ZFSet).IsTransitive := fun y hy z hz => by\n  rcases mem_sUnion.1 hy with ⟨w, hw, hw'⟩\n  exact mem_sUnion_of_mem hz (h.mem_trans hw' hw)\n\n"}
{"name":"ZFSet.IsTransitive.sUnion'","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\nH : ∀ (y : ZFSet.{u}), Membership.mem x y → y.IsTransitive\n⊢ x.sUnion.IsTransitive","decl":"/-- The union of transitive sets is transitive. -/\ntheorem IsTransitive.sUnion' (H : ∀ y ∈ x, IsTransitive y) :\n    (⋃₀ x : ZFSet).IsTransitive := fun y hy z hz => by\n  rcases mem_sUnion.1 hy with ⟨w, hw, hw'⟩\n  exact mem_sUnion_of_mem ((H w hw).mem_trans hz hw') hw\n\n"}
{"name":"ZFSet.IsTransitive.union","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsTransitive\nhy : y.IsTransitive\n⊢ (Union.union x y).IsTransitive","decl":"protected theorem IsTransitive.union (hx : x.IsTransitive) (hy : y.IsTransitive) :\n    (x ∪ y).IsTransitive := by\n  rw [← sUnion_pair]\n  apply IsTransitive.sUnion'\n  intro\n  rw [mem_pair]\n  rintro (rfl | rfl)\n  assumption'\n\n"}
{"name":"ZFSet.IsTransitive.powerset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\nh : x.IsTransitive\n⊢ x.powerset.IsTransitive","decl":"protected theorem IsTransitive.powerset (h : x.IsTransitive) : (powerset x).IsTransitive :=\n  fun y hy z hz => by\n  rw [mem_powerset] at hy ⊢\n  exact h.subset_of_mem (hy hz)\n\n"}
{"name":"ZFSet.isTransitive_iff_sUnion_subset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsTransitive (HasSubset.Subset x.sUnion x)","decl":"theorem isTransitive_iff_sUnion_subset : x.IsTransitive ↔ (⋃₀ x : ZFSet) ⊆ x := by\n  constructor <;>\n  intro h y hy\n  · obtain ⟨z, hz, hz'⟩ := mem_sUnion.1 hy\n    exact h.mem_trans hz' hz\n  · exact fun z hz ↦ h <| mem_sUnion_of_mem hz hy\n\n"}
{"name":"ZFSet.IsTransitive.sUnion_subset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\na✝ : x.IsTransitive\n⊢ HasSubset.Subset x.sUnion x","decl":"alias ⟨IsTransitive.sUnion_subset, _⟩ := isTransitive_iff_sUnion_subset\n\n"}
{"name":"ZFSet.isTransitive_iff_subset_powerset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsTransitive (HasSubset.Subset x x.powerset)","decl":"theorem isTransitive_iff_subset_powerset : x.IsTransitive ↔ x ⊆ powerset x :=\n  ⟨fun h _ hy => mem_powerset.2 <| h.subset_of_mem hy, fun H _ hy _ hz => mem_powerset.1 (H hy) hz⟩\n\n"}
{"name":"ZFSet.IsTransitive.subset_powerset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\na✝ : x.IsTransitive\n⊢ HasSubset.Subset x x.powerset","decl":"alias ⟨IsTransitive.subset_powerset, _⟩ := isTransitive_iff_subset_powerset\n\n"}
{"name":"ZFSet.IsOrdinal.isTransitive","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u_1}\nself : x.IsOrdinal\n⊢ x.IsTransitive","decl":"/-- A set `x` is a von Neumann ordinal when it's a transitive set, that's transitive under `∈`. We\nprove that this further implies that `x` is well-ordered under `∈` in `isOrdinal_iff_isWellOrder`.\n\nThe transitivity condition `a ∈ b → b ∈ c → a ∈ c` can be written without assuming `a ∈ x` and\n`b ∈ x`. The lemma `isOrdinal_iff_isTrans` shows this condition is equivalent to the usual one. -/\nstructure IsOrdinal (x : ZFSet) : Prop where\n  /-- An ordinal is a transitive set. -/\n  isTransitive : x.IsTransitive\n  /-- The membership operation within an ordinal is transitive. -/\n  mem_trans' {y z w : ZFSet} : y ∈ z → z ∈ w → w ∈ x → y ∈ w\n\n"}
{"name":"ZFSet.IsOrdinal.mem_trans'","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u_1}\nself : x.IsOrdinal\ny z w : ZFSet.{u_1}\na✝² : Membership.mem z y\na✝¹ : Membership.mem w z\na✝ : Membership.mem x w\n⊢ Membership.mem w y","decl":"/-- A set `x` is a von Neumann ordinal when it's a transitive set, that's transitive under `∈`. We\nprove that this further implies that `x` is well-ordered under `∈` in `isOrdinal_iff_isWellOrder`.\n\nThe transitivity condition `a ∈ b → b ∈ c → a ∈ c` can be written without assuming `a ∈ x` and\n`b ∈ x`. The lemma `isOrdinal_iff_isTrans` shows this condition is equivalent to the usual one. -/\nstructure IsOrdinal (x : ZFSet) : Prop where\n  /-- An ordinal is a transitive set. -/\n  isTransitive : x.IsTransitive\n  /-- The membership operation within an ordinal is transitive. -/\n  mem_trans' {y z w : ZFSet} : y ∈ z → z ∈ w → w ∈ x → y ∈ w\n\n"}
{"name":"ZFSet.IsOrdinal.subset_of_mem","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nh : x.IsOrdinal\na✝ : Membership.mem x y\n⊢ HasSubset.Subset y x","decl":"theorem subset_of_mem (h : x.IsOrdinal) : y ∈ x → y ⊆ x :=\n  h.isTransitive.subset_of_mem\n\n"}
{"name":"ZFSet.IsOrdinal.mem_trans","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y z : ZFSet.{u}\nh : z.IsOrdinal\na✝¹ : Membership.mem y x\na✝ : Membership.mem z y\n⊢ Membership.mem z x","decl":"theorem mem_trans (h : z.IsOrdinal) : x ∈ y → y ∈ z → x ∈ z :=\n  h.isTransitive.mem_trans\n\n"}
{"name":"ZFSet.IsOrdinal.isTrans","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\nh : x.IsOrdinal\n⊢ IsTrans (Subtype fun x_1 => Membership.mem x x_1) (Subrel (fun x1 x2 => Membership.mem x2 x1) fun x_1 => Membership.mem x x_1)","decl":"protected theorem isTrans (h : x.IsOrdinal) : IsTrans _ (Subrel (· ∈ ·) (· ∈ x)) :=\n  ⟨fun _ _ c hab hbc => h.mem_trans' hab hbc c.2⟩\n\n"}
{"name":"ZFSet.isOrdinal_iff_isTrans","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsOrdinal (And x.IsTransitive (IsTrans (Subtype fun x_1 => Membership.mem x x_1) (Subrel (fun x1 x2 => Membership.mem x2 x1) fun x_1 => Membership.mem x x_1)))","decl":"/-- The simplified form of transitivity used within `IsOrdinal` yields an equivalent definition to\nthe standard one. -/\ntheorem _root_.ZFSet.isOrdinal_iff_isTrans :\n    x.IsOrdinal ↔ x.IsTransitive ∧ IsTrans _ (Subrel (· ∈ ·) (· ∈ x)) where\n  mp h := ⟨h.isTransitive, h.isTrans⟩\n  mpr := by\n    rintro ⟨h₁, ⟨h₂⟩⟩\n    refine ⟨h₁, fun {y z w} hyz hzw hwx ↦ ?_⟩\n    have hzx := h₁.mem_trans hzw hwx\n    exact h₂ ⟨y, h₁.mem_trans hyz hzx⟩ ⟨z, hzx⟩ ⟨w, hwx⟩ hyz hzw\n\n"}
{"name":"ZFSet.IsOrdinal.mem","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : Membership.mem x y\n⊢ y.IsOrdinal","decl":"protected theorem mem (hx : x.IsOrdinal) (hy : y ∈ x) : y.IsOrdinal :=\n  have := hx.isTrans\n  let f : _ ↪r Subrel (· ∈ ·) (· ∈ x) := Subrel.inclusionEmbedding (· ∈ ·) (hx.subset_of_mem hy)\n  isOrdinal_iff_isTrans.2 ⟨fun _ hz _ ha ↦ hx.mem_trans' ha hz hy, f.isTrans⟩\n\n"}
{"name":"ZFSet.isOrdinal_iff_forall_mem_isTransitive","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsOrdinal (And x.IsTransitive (∀ (y : ZFSet.{u}), Membership.mem x y → y.IsTransitive))","decl":"/-- An ordinal is a transitive set of transitive sets. -/\ntheorem _root_.ZFSet.isOrdinal_iff_forall_mem_isTransitive :\n    x.IsOrdinal ↔ x.IsTransitive ∧ ∀ y ∈ x, y.IsTransitive where\n  mp h := ⟨h.isTransitive, fun _ hy ↦ (h.mem hy).isTransitive⟩\n  mpr := fun ⟨h₁, h₂⟩ ↦ ⟨h₁, fun hyz hzw hwx ↦ (h₂ _ hwx).mem_trans hyz hzw⟩\n\n"}
{"name":"ZFSet.isOrdinal_iff_forall_mem_isOrdinal","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsOrdinal (And x.IsTransitive (∀ (y : ZFSet.{u}), Membership.mem x y → y.IsOrdinal))","decl":"/-- An ordinal is a transitive set of ordinals. -/\ntheorem _root_.ZFSet.isOrdinal_iff_forall_mem_isOrdinal :\n    x.IsOrdinal ↔ x.IsTransitive ∧ ∀ y ∈ x, y.IsOrdinal where\n  mp h := ⟨h.isTransitive, fun _ ↦ h.mem⟩\n  mpr := fun ⟨h₁, h₂⟩ ↦ isOrdinal_iff_forall_mem_isTransitive.2\n    ⟨h₁, fun y hy ↦ (h₂ y hy).isTransitive⟩\n\n"}
{"name":"ZFSet.IsOrdinal.subset_iff_eq_or_mem","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\n⊢ Iff (HasSubset.Subset x y) (Or (Eq x y) (Membership.mem y x))","decl":"theorem subset_iff_eq_or_mem (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x ⊆ y ↔ x = y ∨ x ∈ y := by\n  constructor\n  · revert hx hy\n    apply Sym2.GameAdd.induction mem_wf _ x y\n    intro x y IH hx hy hxy\n    by_cases hyx : y ⊆ x\n    · exact Or.inl (subset_antisymm hxy hyx)\n    · obtain ⟨m, hm, hm'⟩ := mem_wf.has_min (y.toSet \\ x.toSet) (Set.diff_nonempty.2 hyx)\n      have hmy : m ∈ y := show m ∈ y.toSet from Set.mem_of_mem_diff hm\n      have hmx : m ⊆ x := by\n        intro z hzm\n        by_contra hzx\n        exact hm' _ ⟨hy.mem_trans hzm hmy, hzx⟩ hzm\n      obtain rfl | H := IH m x (Sym2.GameAdd.fst_snd hmy) (hy.mem hmy) hx hmx\n      · exact Or.inr hmy\n      · cases Set.not_mem_of_mem_diff hm H\n  · rintro (rfl | h)\n    · rfl\n    · exact hy.subset_of_mem h\n\n"}
{"name":"ZFSet.IsOrdinal.eq_or_mem_of_subset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\na✝ : HasSubset.Subset x y\n⊢ Or (Eq x y) (Membership.mem y x)","decl":"alias ⟨eq_or_mem_of_subset, _⟩ := subset_iff_eq_or_mem\n\n"}
{"name":"ZFSet.IsOrdinal.mem_of_subset_of_mem","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y z : ZFSet.{u}\nh : x.IsOrdinal\nhz : z.IsOrdinal\nhx : HasSubset.Subset x y\nhy : Membership.mem z y\n⊢ Membership.mem z x","decl":"theorem mem_of_subset_of_mem (h : x.IsOrdinal) (hz : z.IsOrdinal) (hx : x ⊆ y) (hy : y ∈ z) :\n    x ∈ z := by\n  obtain rfl | hx := h.eq_or_mem_of_subset (hz.mem hy) hx\n  · exact hy\n  · exact hz.mem_trans hx hy\n\n"}
{"name":"ZFSet.IsOrdinal.not_mem_iff_subset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\n⊢ Iff (Not (Membership.mem y x)) (HasSubset.Subset y x)","decl":"theorem not_mem_iff_subset (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x ∉ y ↔ y ⊆ x := by\n  refine ⟨?_, fun hxy hyx ↦ mem_irrefl _ (hxy hyx)⟩\n  revert hx hy\n  apply Sym2.GameAdd.induction mem_wf _ x y\n  intros x y IH hx hy hyx z hzy\n  by_contra hzx\n  exact hyx (mem_of_subset_of_mem hx hy (IH z x (Sym2.GameAdd.fst_snd hzy) (hy.mem hzy) hx hzx) hzy)\n\n"}
{"name":"ZFSet.IsOrdinal.not_subset_iff_mem","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\n⊢ Iff (Not (HasSubset.Subset x y)) (Membership.mem x y)","decl":"theorem not_subset_iff_mem (hx : x.IsOrdinal) (hy : y.IsOrdinal) : ¬ x ⊆ y ↔ y ∈ x := by\n  rw [not_iff_comm, not_mem_iff_subset hy hx]\n\n"}
{"name":"ZFSet.IsOrdinal.mem_or_subset","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\n⊢ Or (Membership.mem y x) (HasSubset.Subset y x)","decl":"theorem mem_or_subset (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x ∈ y ∨ y ⊆ x := by\n  rw [or_iff_not_imp_left, not_mem_iff_subset hx hy]\n  exact id\n\n"}
{"name":"ZFSet.IsOrdinal.subset_total","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\n⊢ Or (HasSubset.Subset x y) (HasSubset.Subset y x)","decl":"theorem subset_total (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x ⊆ y ∨ y ⊆ x := by\n  obtain h | h := mem_or_subset hx hy\n  · exact Or.inl (hy.subset_of_mem h)\n  · exact Or.inr h\n\n"}
{"name":"ZFSet.IsOrdinal.mem_trichotomous","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x y : ZFSet.{u}\nhx : x.IsOrdinal\nhy : y.IsOrdinal\n⊢ Or (Membership.mem y x) (Or (Eq x y) (Membership.mem x y))","decl":"theorem mem_trichotomous (hx : x.IsOrdinal) (hy : y.IsOrdinal) : x ∈ y ∨ x = y ∨ y ∈ x := by\n  rw [eq_comm, ← subset_iff_eq_or_mem hy hx]\n  exact mem_or_subset hx hy\n\n"}
{"name":"ZFSet.IsOrdinal.isTrichotomous","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\nh : x.IsOrdinal\n⊢ IsTrichotomous (Subtype fun x_1 => Membership.mem x x_1) (Subrel (fun x1 x2 => Membership.mem x2 x1) fun x_1 => Membership.mem x x_1)","decl":"protected theorem isTrichotomous (h : x.IsOrdinal) : IsTrichotomous _ (Subrel (· ∈ ·) (· ∈ x)) :=\n  ⟨fun ⟨a, ha⟩ ⟨b, hb⟩ ↦ by simpa using mem_trichotomous (h.mem ha) (h.mem hb)⟩\n\n"}
{"name":"ZFSet.isOrdinal_iff_isTrichotomous","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsOrdinal (And x.IsTransitive (IsTrichotomous (Subtype fun x_1 => Membership.mem x x_1) (Subrel (fun x1 x2 => Membership.mem x2 x1) fun x_1 => Membership.mem x x_1)))","decl":"/-- An ordinal is a transitive set, trichotomous under membership. -/\ntheorem _root_.ZFSet.isOrdinal_iff_isTrichotomous :\n    x.IsOrdinal ↔ x.IsTransitive ∧ IsTrichotomous _ (Subrel (· ∈ ·) (· ∈ x)) where\n  mp h := ⟨h.isTransitive, h.isTrichotomous⟩\n  mpr := by\n    rintro ⟨h₁, h₂⟩\n    rw [isOrdinal_iff_isTrans]\n    refine ⟨h₁, ⟨@fun y z w hyz hzw ↦ ?_⟩⟩\n    obtain hyw | rfl | hwy := trichotomous_of (Subrel (· ∈ ·) (· ∈ x)) y w\n    · exact hyw\n    · cases asymm hyz hzw\n    · cases mem_wf.asymmetric₃ _ _ _ hyz hzw hwy\n\n"}
{"name":"ZFSet.IsOrdinal.isWellOrder","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\nh : x.IsOrdinal\n⊢ IsWellOrder (Subtype fun x_1 => Membership.mem x x_1) (Subrel (fun x1 x2 => Membership.mem x2 x1) fun x_1 => Membership.mem x x_1)","decl":"protected theorem isWellOrder (h : x.IsOrdinal) : IsWellOrder _ (Subrel (· ∈ ·) (· ∈ x)) where\n  wf := (Subrel.relEmbedding _ _).wellFounded mem_wf\n  trans := h.isTrans.1\n  trichotomous := h.isTrichotomous.1\n\n"}
{"name":"ZFSet.isOrdinal_iff_isWellOrder","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"x : ZFSet.{u}\n⊢ Iff x.IsOrdinal (And x.IsTransitive (IsWellOrder (Subtype fun x_1 => Membership.mem x x_1) (Subrel (fun x1 x2 => Membership.mem x2 x1) fun x_1 => Membership.mem x x_1)))","decl":"/-- An ordinal is a transitive set, well-ordered under membership. -/\ntheorem _root_.ZFSet.isOrdinal_iff_isWellOrder : x.IsOrdinal ↔\n    x.IsTransitive ∧ IsWellOrder _ (Subrel (· ∈ ·) (· ∈ x)) := by\n  use fun h ↦ ⟨h.isTransitive, h.isWellOrder⟩\n  rintro ⟨h₁, h₂⟩\n  refine isOrdinal_iff_isTrans.2 ⟨h₁, ?_⟩\n  infer_instance\n\n"}
{"name":"ZFSet.isOrdinal_empty","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"⊢ EmptyCollection.emptyCollection.IsOrdinal","decl":"@[simp]\ntheorem isOrdinal_empty : IsOrdinal ∅ :=\n  ⟨isTransitive_empty, fun _ _ H ↦ (not_mem_empty _ H).elim⟩\n\n"}
{"name":"ZFSet.isOrdinal_not_mem_univ","module":"Mathlib.SetTheory.ZFC.Ordinal","initialProofState":"⊢ Not (Membership.mem Class.univ ZFSet.IsOrdinal)","decl":"/-- The **Burali-Forti paradox**: ordinals form a proper class. -/\ntheorem isOrdinal_not_mem_univ : IsOrdinal ∉ Class.univ.{u} := by\n  rintro ⟨x, hx, -⟩\n  suffices IsOrdinal x by\n    apply Class.mem_irrefl x\n    rwa [Class.coe_mem, hx]\n  refine ⟨fun y hy z hz ↦ ?_, fun hyz hzw hwx ↦ ?_⟩ <;> rw [← Class.coe_apply, hx] at *\n  exacts [hy.mem hz, hwx.mem_trans hyz hzw]\n\n"}
