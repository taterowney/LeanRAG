{"name":"Order.Ideal.PrimePair.mk.injEq","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\nI✝ : Order.Ideal P\nF✝ : Order.PFilter P\nisCompl_I_F✝ : IsCompl ↑I✝ ↑F✝\nI : Order.Ideal P\nF : Order.PFilter P\nisCompl_I_F : IsCompl ↑I ↑F\n⊢ Eq (Eq { I := I✝, F := F✝, isCompl_I_F := isCompl_I_F✝ } { I := I, F := F, isCompl_I_F := isCompl_I_F }) (And (Eq I✝ I) (Eq F✝ F))","decl":"/-- A pair of an `Order.Ideal` and an `Order.PFilter` which form a partition of `P`.\n-/\nstructure PrimePair (P : Type*) [Preorder P] where\n  I : Ideal P\n  F : PFilter P\n  isCompl_I_F : IsCompl (I : Set P) F\n\n"}
{"name":"Order.Ideal.PrimePair.mk.inj","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\nI✝ : Order.Ideal P\nF✝ : Order.PFilter P\nisCompl_I_F✝ : IsCompl ↑I✝ ↑F✝\nI : Order.Ideal P\nF : Order.PFilter P\nisCompl_I_F : IsCompl ↑I ↑F\nx✝ : Eq { I := I✝, F := F✝, isCompl_I_F := isCompl_I_F✝ } { I := I, F := F, isCompl_I_F := isCompl_I_F }\n⊢ And (Eq I✝ I) (Eq F✝ F)","decl":"/-- A pair of an `Order.Ideal` and an `Order.PFilter` which form a partition of `P`.\n-/\nstructure PrimePair (P : Type*) [Preorder P] where\n  I : Ideal P\n  F : PFilter P\n  isCompl_I_F : IsCompl (I : Set P) F\n\n"}
{"name":"Order.Ideal.PrimePair.isCompl_I_F","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_2\ninst✝ : Preorder P\nself : Order.Ideal.PrimePair P\n⊢ IsCompl ↑self.I ↑self.F","decl":"/-- A pair of an `Order.Ideal` and an `Order.PFilter` which form a partition of `P`.\n-/\nstructure PrimePair (P : Type*) [Preorder P] where\n  I : Ideal P\n  F : PFilter P\n  isCompl_I_F : IsCompl (I : Set P) F\n\n"}
{"name":"Order.Ideal.PrimePair.mk.sizeOf_spec","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_2\ninst✝¹ : Preorder P\ninst✝ : SizeOf P\nI : Order.Ideal P\nF : Order.PFilter P\nisCompl_I_F : IsCompl ↑I ↑F\n⊢ Eq (SizeOf.sizeOf { I := I, F := F, isCompl_I_F := isCompl_I_F }) (HAdd.hAdd (HAdd.hAdd (HAdd.hAdd 1 (SizeOf.sizeOf I)) (SizeOf.sizeOf F)) (SizeOf.sizeOf isCompl_I_F))","decl":"/-- A pair of an `Order.Ideal` and an `Order.PFilter` which form a partition of `P`.\n-/\nstructure PrimePair (P : Type*) [Preorder P] where\n  I : Ideal P\n  F : PFilter P\n  isCompl_I_F : IsCompl (I : Set P) F\n\n"}
{"name":"Order.Ideal.PrimePair.compl_I_eq_F","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ Eq (HasCompl.compl ↑IF.I) ↑IF.F","decl":"theorem compl_I_eq_F : (IF.I : Set P)ᶜ = IF.F :=\n  IF.isCompl_I_F.compl_eq\n\n"}
{"name":"Order.Ideal.PrimePair.compl_F_eq_I","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ Eq (HasCompl.compl ↑IF.F) ↑IF.I","decl":"theorem compl_F_eq_I : (IF.F : Set P)ᶜ = IF.I :=\n  IF.isCompl_I_F.eq_compl.symm\n\n"}
{"name":"Order.Ideal.PrimePair.I_isProper","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ IF.I.IsProper","decl":"theorem I_isProper : IsProper IF.I := by\n  cases' IF.F.nonempty with w h\n  apply isProper_of_not_mem (_ : w ∉ IF.I)\n  rwa [← IF.compl_I_eq_F] at h\n\n"}
{"name":"Order.Ideal.PrimePair.disjoint","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ Disjoint ↑IF.I ↑IF.F","decl":"protected theorem disjoint : Disjoint (IF.I : Set P) IF.F :=\n  IF.isCompl_I_F.disjoint\n\n"}
{"name":"Order.Ideal.PrimePair.I_union_F","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ Eq (Union.union ↑IF.I ↑IF.F) Set.univ","decl":"theorem I_union_F : (IF.I : Set P) ∪ IF.F = Set.univ :=\n  IF.isCompl_I_F.sup_eq_top\n\n"}
{"name":"Order.Ideal.PrimePair.F_union_I","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ Eq (Union.union ↑IF.F ↑IF.I) Set.univ","decl":"theorem F_union_I : (IF.F : Set P) ∪ IF.I = Set.univ :=\n  IF.isCompl_I_F.symm.sup_eq_top\n\n"}
{"name":"Order.Ideal.IsPrime.toIsProper","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nI : Order.Ideal P\nself : I.IsPrime\n⊢ I.IsProper","decl":"/-- An ideal `I` is prime if its complement is a filter.\n-/\n@[mk_iff]\nclass IsPrime [Preorder P] (I : Ideal P) extends IsProper I : Prop where\n  compl_filter : IsPFilter (I : Set P)ᶜ\n\n"}
{"name":"Order.Ideal.isPrime_iff","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nI : Order.Ideal P\n⊢ Iff I.IsPrime (And I.IsProper (Order.IsPFilter (HasCompl.compl ↑I)))","decl":"/-- An ideal `I` is prime if its complement is a filter.\n-/\n@[mk_iff]\nclass IsPrime [Preorder P] (I : Ideal P) extends IsProper I : Prop where\n  compl_filter : IsPFilter (I : Set P)ᶜ\n\n"}
{"name":"Order.Ideal.IsPrime.compl_filter","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nI : Order.Ideal P\nself : I.IsPrime\n⊢ Order.IsPFilter (HasCompl.compl ↑I)","decl":"/-- An ideal `I` is prime if its complement is a filter.\n-/\n@[mk_iff]\nclass IsPrime [Preorder P] (I : Ideal P) extends IsProper I : Prop where\n  compl_filter : IsPFilter (I : Set P)ᶜ\n\n"}
{"name":"Order.Ideal.PrimePair.I_isPrime","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ IF.I.IsPrime","decl":"theorem PrimePair.I_isPrime (IF : PrimePair P) : IsPrime IF.I :=\n  { IF.I_isProper with\n    compl_filter := by\n      rw [IF.compl_I_eq_F]\n      exact IF.F.isPFilter }\n\n"}
{"name":"Order.Ideal.IsPrime.mem_or_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : SemilatticeInf P\nI : Order.Ideal P\nhI : I.IsPrime\nx y : P\na✝ : Membership.mem I (Min.min x y)\n⊢ Or (Membership.mem I x) (Membership.mem I y)","decl":"theorem IsPrime.mem_or_mem (hI : IsPrime I) {x y : P} : x ⊓ y ∈ I → x ∈ I ∨ y ∈ I := by\n  contrapose!\n  let F := hI.compl_filter.toPFilter\n  show x ∈ F ∧ y ∈ F → x ⊓ y ∈ F\n  exact fun h => inf_mem h.1 h.2\n\n"}
{"name":"Order.Ideal.IsPrime.of_mem_or_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeInf P\nI : Order.Ideal P\ninst✝ : I.IsProper\nhI : ∀ {x y : P}, Membership.mem I (Min.min x y) → Or (Membership.mem I x) (Membership.mem I y)\n⊢ I.IsPrime","decl":"theorem IsPrime.of_mem_or_mem [IsProper I] (hI : ∀ {x y : P}, x ⊓ y ∈ I → x ∈ I ∨ y ∈ I) :\n    IsPrime I := by\n  rw [isPrime_iff]\n  use ‹_›\n  refine .of_def ?_ ?_ ?_\n  · exact Set.nonempty_compl.2 (I.isProper_iff.1 ‹_›)\n  · intro x hx y hy\n    exact ⟨x ⊓ y, fun h => (hI h).elim hx hy, inf_le_left, inf_le_right⟩\n  · exact @mem_compl_of_ge _ _ _\n\n"}
{"name":"Order.Ideal.isPrime_iff_mem_or_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝¹ : SemilatticeInf P\nI : Order.Ideal P\ninst✝ : I.IsProper\n⊢ Iff I.IsPrime (∀ {x y : P}, Membership.mem I (Min.min x y) → Or (Membership.mem I x) (Membership.mem I y))","decl":"theorem isPrime_iff_mem_or_mem [IsProper I] : IsPrime I ↔ ∀ {x y : P}, x ⊓ y ∈ I → x ∈ I ∨ y ∈ I :=\n  ⟨IsPrime.mem_or_mem, IsPrime.of_mem_or_mem⟩\n\n"}
{"name":"Order.Ideal.IsMaximal.isPrime","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝¹ : DistribLattice P\nI : Order.Ideal P\ninst✝ : I.IsMaximal\n⊢ I.IsPrime","decl":"instance (priority := 100) IsMaximal.isPrime [IsMaximal I] : IsPrime I := by\n  rw [isPrime_iff_mem_or_mem]\n  intro x y\n  contrapose!\n  rintro ⟨hx, hynI⟩ hxy\n  apply hynI\n  let J := I ⊔ principal x\n  have hJuniv : (J : Set P) = Set.univ :=\n    IsMaximal.maximal_proper (lt_sup_principal_of_not_mem ‹_›)\n  have hyJ : y ∈ (J : Set P) := Set.eq_univ_iff_forall.mp hJuniv y\n  rw [coe_sup_eq] at hyJ\n  rcases hyJ with ⟨a, ha, b, hb, hy⟩\n  rw [hy]\n  refine sup_mem ha (I.lower (le_inf hb ?_) hxy)\n  rw [hy]\n  exact le_sup_right\n\n"}
{"name":"Order.Ideal.IsPrime.mem_or_compl_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : BooleanAlgebra P\nx : P\nI : Order.Ideal P\nhI : I.IsPrime\n⊢ Or (Membership.mem I x) (Membership.mem I (HasCompl.compl x))","decl":"theorem IsPrime.mem_or_compl_mem (hI : IsPrime I) : x ∈ I ∨ xᶜ ∈ I := by\n  apply hI.mem_or_mem\n  rw [inf_compl_eq_bot]\n  exact I.bot_mem\n\n"}
{"name":"Order.Ideal.IsPrime.mem_compl_of_not_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : BooleanAlgebra P\nx : P\nI : Order.Ideal P\nhI : I.IsPrime\nhxnI : Not (Membership.mem I x)\n⊢ Membership.mem I (HasCompl.compl x)","decl":"theorem IsPrime.mem_compl_of_not_mem (hI : IsPrime I) (hxnI : x ∉ I) : xᶜ ∈ I :=\n  hI.mem_or_compl_mem.resolve_left hxnI\n\n"}
{"name":"Order.Ideal.isPrime_of_mem_or_compl_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝¹ : BooleanAlgebra P\nI : Order.Ideal P\ninst✝ : I.IsProper\nh : ∀ {x : P}, Or (Membership.mem I x) (Membership.mem I (HasCompl.compl x))\n⊢ I.IsPrime","decl":"theorem isPrime_of_mem_or_compl_mem [IsProper I] (h : ∀ {x : P}, x ∈ I ∨ xᶜ ∈ I) : IsPrime I := by\n  simp only [isPrime_iff_mem_or_mem, or_iff_not_imp_left]\n  intro x y hxy hxI\n  have hxcI : xᶜ ∈ I := h.resolve_left hxI\n  have ass : x ⊓ y ⊔ y ⊓ xᶜ ∈ I := sup_mem hxy (I.lower inf_le_right hxcI)\n  rwa [inf_comm, sup_inf_inf_compl] at ass\n\n"}
{"name":"Order.Ideal.isPrime_iff_mem_or_compl_mem","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝¹ : BooleanAlgebra P\nI : Order.Ideal P\ninst✝ : I.IsProper\n⊢ Iff I.IsPrime (∀ {x : P}, Or (Membership.mem I x) (Membership.mem I (HasCompl.compl x)))","decl":"theorem isPrime_iff_mem_or_compl_mem [IsProper I] : IsPrime I ↔ ∀ {x : P}, x ∈ I ∨ xᶜ ∈ I :=\n  ⟨fun h _ => h.mem_or_compl_mem, isPrime_of_mem_or_compl_mem⟩\n\n"}
{"name":"Order.Ideal.IsPrime.isMaximal","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝¹ : BooleanAlgebra P\nI : Order.Ideal P\ninst✝ : I.IsPrime\n⊢ I.IsMaximal","decl":"instance (priority := 100) IsPrime.isMaximal [IsPrime I] : IsMaximal I := by\n  simp only [isMaximal_iff, Set.eq_univ_iff_forall, IsPrime.toIsProper, true_and]\n  intro J hIJ x\n  rcases Set.exists_of_ssubset hIJ with ⟨y, hyJ, hyI⟩\n  suffices ass : x ⊓ y ⊔ x ⊓ yᶜ ∈ J by rwa [sup_inf_inf_compl] at ass\n  exact\n    sup_mem (J.lower inf_le_right hyJ)\n      (hIJ.le <| I.lower inf_le_right <| IsPrime.mem_compl_of_not_mem ‹_› hyI)\n\n"}
{"name":"Order.PFilter.IsPrime.compl_ideal","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nF : Order.PFilter P\nself : F.IsPrime\n⊢ Order.IsIdeal (HasCompl.compl ↑F)","decl":"/-- A filter `F` is prime if its complement is an ideal.\n-/\n@[mk_iff]\nclass IsPrime (F : PFilter P) : Prop where\n  compl_ideal : IsIdeal (F : Set P)ᶜ\n\n"}
{"name":"Order.PFilter.isPrime_iff","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nF : Order.PFilter P\n⊢ Iff F.IsPrime (Order.IsIdeal (HasCompl.compl ↑F))","decl":"/-- A filter `F` is prime if its complement is an ideal.\n-/\n@[mk_iff]\nclass IsPrime (F : PFilter P) : Prop where\n  compl_ideal : IsIdeal (F : Set P)ᶜ\n\n"}
{"name":"Order.Ideal.PrimePair.F_isPrime","module":"Mathlib.Order.PrimeIdeal","initialProofState":"P : Type u_1\ninst✝ : Preorder P\nIF : Order.Ideal.PrimePair P\n⊢ IF.F.IsPrime","decl":"theorem _root_.Order.Ideal.PrimePair.F_isPrime (IF : Ideal.PrimePair P) : IsPrime IF.F :=\n  {\n    compl_ideal := by\n      rw [IF.compl_F_eq_I]\n      exact IF.I.isIdeal }\n\n"}
