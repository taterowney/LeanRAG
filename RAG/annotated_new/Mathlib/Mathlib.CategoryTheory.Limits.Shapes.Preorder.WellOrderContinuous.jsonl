{"name":"CategoryTheory.Functor.IsWellOrderContinuous.nonempty_isColimit","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.WellOrderContinuous","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝ : PartialOrder J\nF : CategoryTheory.Functor J C\nself : F.IsWellOrderContinuous\nm : J\nhm : Order.IsSuccLimit m\n⊢ Nonempty (CategoryTheory.Limits.IsColimit ((Set.principalSegIio m).cocone F))","decl":"/-- A functor `F : J ⥤ C` is well-order-continuous if for any limit element `m : J`,\n`F.obj m` identifies to the colimit of the `F.obj j` for `j < m`. -/\nclass IsWellOrderContinuous (F : J ⥤ C) : Prop where\n  nonempty_isColimit (m : J) (hm : Order.IsSuccLimit m) :\n    Nonempty (IsColimit ((Set.principalSegIio m).cocone F))\n\n"}
{"name":"CategoryTheory.Functor.instIsWellOrderContinuousNat","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.WellOrderContinuous","initialProofState":"C : Type u\ninst✝ : CategoryTheory.Category.{v, u} C\nF : CategoryTheory.Functor Nat C\n⊢ F.IsWellOrderContinuous","decl":"instance (F : ℕ ⥤ C) : F.IsWellOrderContinuous where\n  nonempty_isColimit m hm := by simp at hm\n\n"}
{"name":"CategoryTheory.Functor.isWellOrderContinuous_of_iso","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.WellOrderContinuous","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝¹ : PartialOrder J\nF G : CategoryTheory.Functor J C\ne : CategoryTheory.Iso F G\ninst✝ : F.IsWellOrderContinuous\n⊢ G.IsWellOrderContinuous","decl":"lemma isWellOrderContinuous_of_iso {F G : J ⥤ C} (e : F ≅ G) [F.IsWellOrderContinuous] :\n    G.IsWellOrderContinuous where\n  nonempty_isColimit (m : J) (hm : Order.IsSuccLimit m) :=\n    ⟨(IsColimit.precomposeHomEquiv (isoWhiskerLeft _ e) _).1\n      (IsColimit.ofIsoColimit (F.isColimitOfIsWellOrderContinuous m hm)\n        (Cocones.ext (e.app _)))⟩\n\n"}
{"name":"CategoryTheory.Functor.instIsWellOrderContinuousCompFunctor","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.WellOrderContinuous","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : PartialOrder J\nF : CategoryTheory.Functor J C\nJ' : Type w'\ninst✝¹ : PartialOrder J'\nf : InitialSeg (fun x1 x2 => LT.lt x1 x2) fun x1 x2 => LT.lt x1 x2\ninst✝ : F.IsWellOrderContinuous\n⊢ (⋯.functor.comp F).IsWellOrderContinuous","decl":"instance (F : J ⥤ C) {J' : Type w'} [PartialOrder J'] (f : J' ≤i J)\n    [F.IsWellOrderContinuous] :\n    (f.monotone.functor ⋙ F).IsWellOrderContinuous where\n  nonempty_isColimit m' hm' := ⟨F.isColimitOfIsWellOrderContinuous'\n    ((Set.principalSegIio m').transInitial f) (by simpa)⟩\n\n"}
{"name":"CategoryTheory.Functor.instIsWellOrderContinuousCompFunctorEquivalence","module":"Mathlib.CategoryTheory.Limits.Shapes.Preorder.WellOrderContinuous","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type w\ninst✝² : PartialOrder J\nF : CategoryTheory.Functor J C\nJ' : Type w'\ninst✝¹ : PartialOrder J'\ne : OrderIso J' J\ninst✝ : F.IsWellOrderContinuous\n⊢ (e.equivalence.functor.comp F).IsWellOrderContinuous","decl":"instance (F : J ⥤ C) {J' : Type w'} [PartialOrder J'] (e : J' ≃o J)\n    [F.IsWellOrderContinuous] :\n    (e.equivalence.functor ⋙ F).IsWellOrderContinuous :=\n  inferInstanceAs (e.toInitialSeg.monotone.functor ⋙ F).IsWellOrderContinuous\n\n"}
