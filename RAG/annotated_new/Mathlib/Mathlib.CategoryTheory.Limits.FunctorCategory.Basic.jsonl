{"name":"CategoryTheory.Limits.limit.lift_π_app_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimit H\nc : CategoryTheory.Limits.Cone H\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((H.obj j).obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.lift H c).app k) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.π H j).app k) h)) (CategoryTheory.CategoryStruct.comp ((c.π.app j).app k) h)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_π_app (H : J ⥤ K ⥤ C) [HasLimit H] (c : Cone H) (j : J) (k : K) :\n    (limit.lift H c).app k ≫ (limit.π H j).app k = (c.π.app j).app k :=\n  congr_app (limit.lift_π c j) k\n\n"}
{"name":"CategoryTheory.Limits.limit.lift_π_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimit H\nc : CategoryTheory.Limits.Cone H\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.lift H c).app k) ((CategoryTheory.Limits.limit.π H j).app k)) ((c.π.app j).app k)","decl":"@[reassoc (attr := simp)]\ntheorem limit.lift_π_app (H : J ⥤ K ⥤ C) [HasLimit H] (c : Cone H) (j : J) (k : K) :\n    (limit.lift H c).app k ≫ (limit.π H j).app k = (c.π.app j).app k :=\n  congr_app (limit.lift_π c j) k\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_desc_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimit H\nc : CategoryTheory.Limits.Cocone H\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι H j).app k) ((CategoryTheory.Limits.colimit.desc H c).app k)) ((c.ι.app j).app k)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_desc_app (H : J ⥤ K ⥤ C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\n    (colimit.ι H j).app k ≫ (colimit.desc H c).app k = (c.ι.app j).app k :=\n  congr_app (colimit.ι_desc c j) k\n\n"}
{"name":"CategoryTheory.Limits.colimit.ι_desc_app_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimit H\nc : CategoryTheory.Limits.Cocone H\nj : J\nk : K\nZ : C\nh : Quiver.Hom (c.pt.obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι H j).app k) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.desc H c).app k) h)) (CategoryTheory.CategoryStruct.comp ((c.ι.app j).app k) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimit.ι_desc_app (H : J ⥤ K ⥤ C) [HasColimit H] (c : Cocone H) (j : J) (k : K) :\n    (colimit.ι H j).app k ≫ (colimit.desc H c).app k = (c.ι.app j).app k :=\n  congr_app (colimit.ι_desc c j) k\n\n"}
{"name":"CategoryTheory.Limits.combineCones_pt_obj","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nc : (k : K) → CategoryTheory.Limits.LimitCone (F.flip.obj k)\nk : K\n⊢ Eq ((CategoryTheory.Limits.combineCones F c).pt.obj k) (c k).cone.pt","decl":"/-- Given a functor `F` and a collection of limit cones for each diagram `X ↦ F X k`, we can stitch\nthem together to give a cone for the diagram `F`.\n`combinedIsLimit` shows that the new cone is limiting, and `evalCombined` shows it is\n(essentially) made up of the original cones.\n-/\n@[simps]\ndef combineCones (F : J ⥤ K ⥤ C) (c : ∀ k : K, LimitCone (F.flip.obj k)) : Cone F where\n  pt :=\n    { obj := fun k => (c k).cone.pt\n      map := fun {k₁} {k₂} f => (c k₂).isLimit.lift ⟨_, (c k₁).cone.π ≫ F.flip.map f⟩\n      map_id := fun k =>\n        (c k).isLimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k₁} {k₂} {k₃} f₁ f₂ => (c k₃).isLimit.hom_ext fun j => by simp }\n  π :=\n    { app := fun j => { app := fun k => (c k).cone.π.app j }\n      naturality := fun j₁ j₂ g => by ext k; exact (c k).cone.π.naturality g }\n\n"}
{"name":"CategoryTheory.Limits.combineCones_pt_map","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nc : (k : K) → CategoryTheory.Limits.LimitCone (F.flip.obj k)\nk₁ k₂ : K\nf : Quiver.Hom k₁ k₂\n⊢ Eq ((CategoryTheory.Limits.combineCones F c).pt.map f) ((c k₂).isLimit.lift { pt := (c k₁).cone.pt, π := CategoryTheory.CategoryStruct.comp (c k₁).cone.π (F.flip.map f) })","decl":"/-- Given a functor `F` and a collection of limit cones for each diagram `X ↦ F X k`, we can stitch\nthem together to give a cone for the diagram `F`.\n`combinedIsLimit` shows that the new cone is limiting, and `evalCombined` shows it is\n(essentially) made up of the original cones.\n-/\n@[simps]\ndef combineCones (F : J ⥤ K ⥤ C) (c : ∀ k : K, LimitCone (F.flip.obj k)) : Cone F where\n  pt :=\n    { obj := fun k => (c k).cone.pt\n      map := fun {k₁} {k₂} f => (c k₂).isLimit.lift ⟨_, (c k₁).cone.π ≫ F.flip.map f⟩\n      map_id := fun k =>\n        (c k).isLimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k₁} {k₂} {k₃} f₁ f₂ => (c k₃).isLimit.hom_ext fun j => by simp }\n  π :=\n    { app := fun j => { app := fun k => (c k).cone.π.app j }\n      naturality := fun j₁ j₂ g => by ext k; exact (c k).cone.π.naturality g }\n\n"}
{"name":"CategoryTheory.Limits.combineCones_π_app_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nc : (k : K) → CategoryTheory.Limits.LimitCone (F.flip.obj k)\nj : J\nk : K\n⊢ Eq (((CategoryTheory.Limits.combineCones F c).π.app j).app k) ((c k).cone.π.app j)","decl":"/-- Given a functor `F` and a collection of limit cones for each diagram `X ↦ F X k`, we can stitch\nthem together to give a cone for the diagram `F`.\n`combinedIsLimit` shows that the new cone is limiting, and `evalCombined` shows it is\n(essentially) made up of the original cones.\n-/\n@[simps]\ndef combineCones (F : J ⥤ K ⥤ C) (c : ∀ k : K, LimitCone (F.flip.obj k)) : Cone F where\n  pt :=\n    { obj := fun k => (c k).cone.pt\n      map := fun {k₁} {k₂} f => (c k₂).isLimit.lift ⟨_, (c k₁).cone.π ≫ F.flip.map f⟩\n      map_id := fun k =>\n        (c k).isLimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k₁} {k₂} {k₃} f₁ f₂ => (c k₃).isLimit.hom_ext fun j => by simp }\n  π :=\n    { app := fun j => { app := fun k => (c k).cone.π.app j }\n      naturality := fun j₁ j₂ g => by ext k; exact (c k).cone.π.naturality g }\n\n"}
{"name":"CategoryTheory.Limits.combineCocones_pt_map","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nc : (k : K) → CategoryTheory.Limits.ColimitCocone (F.flip.obj k)\nk₁ k₂ : K\nf : Quiver.Hom k₁ k₂\n⊢ Eq ((CategoryTheory.Limits.combineCocones F c).pt.map f) ((c k₁).isColimit.desc { pt := (c k₂).cocone.pt, ι := CategoryTheory.CategoryStruct.comp (F.flip.map f) (c k₂).cocone.ι })","decl":"/--\nGiven a functor `F` and a collection of colimit cocones for each diagram `X ↦ F X k`, we can stitch\nthem together to give a cocone for the diagram `F`.\n`combinedIsColimit` shows that the new cocone is colimiting, and `evalCombined` shows it is\n(essentially) made up of the original cocones.\n-/\n@[simps]\ndef combineCocones (F : J ⥤ K ⥤ C) (c : ∀ k : K, ColimitCocone (F.flip.obj k)) : Cocone F where\n  pt :=\n    { obj := fun k => (c k).cocone.pt\n      map := fun {k₁} {k₂} f => (c k₁).isColimit.desc ⟨_, F.flip.map f ≫ (c k₂).cocone.ι⟩\n      map_id := fun k =>\n        (c k).isColimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k₁} {k₂} {k₃} f₁ f₂ => (c k₁).isColimit.hom_ext fun j => by simp }\n  ι :=\n    { app := fun j => { app := fun k => (c k).cocone.ι.app j }\n      naturality := fun j₁ j₂ g => by ext k; exact (c k).cocone.ι.naturality g }\n\n"}
{"name":"CategoryTheory.Limits.combineCocones_pt_obj","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nc : (k : K) → CategoryTheory.Limits.ColimitCocone (F.flip.obj k)\nk : K\n⊢ Eq ((CategoryTheory.Limits.combineCocones F c).pt.obj k) (c k).cocone.pt","decl":"/--\nGiven a functor `F` and a collection of colimit cocones for each diagram `X ↦ F X k`, we can stitch\nthem together to give a cocone for the diagram `F`.\n`combinedIsColimit` shows that the new cocone is colimiting, and `evalCombined` shows it is\n(essentially) made up of the original cocones.\n-/\n@[simps]\ndef combineCocones (F : J ⥤ K ⥤ C) (c : ∀ k : K, ColimitCocone (F.flip.obj k)) : Cocone F where\n  pt :=\n    { obj := fun k => (c k).cocone.pt\n      map := fun {k₁} {k₂} f => (c k₁).isColimit.desc ⟨_, F.flip.map f ≫ (c k₂).cocone.ι⟩\n      map_id := fun k =>\n        (c k).isColimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k₁} {k₂} {k₃} f₁ f₂ => (c k₁).isColimit.hom_ext fun j => by simp }\n  ι :=\n    { app := fun j => { app := fun k => (c k).cocone.ι.app j }\n      naturality := fun j₁ j₂ g => by ext k; exact (c k).cocone.ι.naturality g }\n\n"}
{"name":"CategoryTheory.Limits.combineCocones_ι_app_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nc : (k : K) → CategoryTheory.Limits.ColimitCocone (F.flip.obj k)\nj : J\nk : K\n⊢ Eq (((CategoryTheory.Limits.combineCocones F c).ι.app j).app k) ((c k).cocone.ι.app j)","decl":"/--\nGiven a functor `F` and a collection of colimit cocones for each diagram `X ↦ F X k`, we can stitch\nthem together to give a cocone for the diagram `F`.\n`combinedIsColimit` shows that the new cocone is colimiting, and `evalCombined` shows it is\n(essentially) made up of the original cocones.\n-/\n@[simps]\ndef combineCocones (F : J ⥤ K ⥤ C) (c : ∀ k : K, ColimitCocone (F.flip.obj k)) : Cocone F where\n  pt :=\n    { obj := fun k => (c k).cocone.pt\n      map := fun {k₁} {k₂} f => (c k₁).isColimit.desc ⟨_, F.flip.map f ≫ (c k₂).cocone.ι⟩\n      map_id := fun k =>\n        (c k).isColimit.hom_ext fun j => by\n          dsimp\n          simp\n      map_comp := fun {k₁} {k₂} {k₃} f₁ f₂ => (c k₁).isColimit.hom_ext fun j => by simp }\n  ι :=\n    { app := fun j => { app := fun k => (c k).cocone.ι.app j }\n      naturality := fun j₁ j₂ g => by ext k; exact (c k).cocone.ι.naturality g }\n\n"}
{"name":"CategoryTheory.Limits.pointwiseCocone_pt","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\n⊢ Eq (CategoryTheory.Limits.pointwiseCocone F).pt (F.flip.comp CategoryTheory.Limits.colim)","decl":"/--\nAn alternative colimit cocone in the functor category `K ⥤ C` in the case where `C` has\n`J`-shaped colimits, with cocone point `F.flip ⋙ colim`.\n-/\n@[simps]\nnoncomputable def pointwiseCocone [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C) : Cocone F where\n  pt := F.flip ⋙ colim\n  ι := {\n    app X := { app Y := (colimit.ι _ X : (F.flip.obj Y).obj X ⟶ _) }\n    naturality X Y f := by\n      ext x\n      simp only [Functor.const_obj_obj, Functor.comp_obj, colim_obj, NatTrans.comp_app,\n        Functor.const_obj_map, Category.comp_id]\n      change (F.flip.obj x).map f ≫ _ = _\n      rw [colimit.w] }\n\n"}
{"name":"CategoryTheory.Limits.pointwiseCocone_ι_app_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : J\nY : K\n⊢ Eq (((CategoryTheory.Limits.pointwiseCocone F).ι.app X).app Y) (CategoryTheory.Limits.colimit.ι (F.flip.obj Y) X)","decl":"/--\nAn alternative colimit cocone in the functor category `K ⥤ C` in the case where `C` has\n`J`-shaped colimits, with cocone point `F.flip ⋙ colim`.\n-/\n@[simps]\nnoncomputable def pointwiseCocone [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C) : Cocone F where\n  pt := F.flip ⋙ colim\n  ι := {\n    app X := { app Y := (colimit.ι _ X : (F.flip.obj Y).obj X ⟶ _) }\n    naturality X Y f := by\n      ext x\n      simp only [Functor.const_obj_obj, Functor.comp_obj, colim_obj, NatTrans.comp_app,\n        Functor.const_obj_map, Category.comp_id]\n      change (F.flip.obj x).map f ≫ _ = _\n      rw [colimit.w] }\n\n"}
{"name":"CategoryTheory.Limits.functorCategoryHasLimit","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : ∀ (k : K), CategoryTheory.Limits.HasLimit (F.flip.obj k)\n⊢ CategoryTheory.Limits.HasLimit F","decl":"instance functorCategoryHasLimit (F : J ⥤ K ⥤ C) [∀ k, HasLimit (F.flip.obj k)] : HasLimit F :=\n  HasLimit.mk\n    { cone := combineCones F fun _ => getLimitCone _\n      isLimit := combinedIsLimit _ _ }\n\n"}
{"name":"CategoryTheory.Limits.functorCategoryHasLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\n⊢ CategoryTheory.Limits.HasLimitsOfShape J (CategoryTheory.Functor K C)","decl":"instance functorCategoryHasLimitsOfShape [HasLimitsOfShape J C] : HasLimitsOfShape J (K ⥤ C) where\n  has_limit _ := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.functorCategoryHasColimit","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : ∀ (k : K), CategoryTheory.Limits.HasColimit (F.flip.obj k)\n⊢ CategoryTheory.Limits.HasColimit F","decl":"instance functorCategoryHasColimit (F : J ⥤ K ⥤ C) [∀ k, HasColimit (F.flip.obj k)] :\n    HasColimit F :=\n  HasColimit.mk\n    { cocone := combineCocones F fun _ => getColimitCocone _\n      isColimit := combinedIsColimit _ _ }\n\n"}
{"name":"CategoryTheory.Limits.functorCategoryHasColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\n⊢ CategoryTheory.Limits.HasColimitsOfShape J (CategoryTheory.Functor K C)","decl":"instance functorCategoryHasColimitsOfShape [HasColimitsOfShape J C] :\n    HasColimitsOfShape J (K ⥤ C) where\n  has_colimit _ := inferInstance\n\n-- Porting note: previously Lean could see through the binders and infer_instance sufficed\n"}
{"name":"CategoryTheory.Limits.functorCategoryHasLimitsOfSize","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfSize.{v₁, u₁, v, u} C\n⊢ CategoryTheory.Limits.HasLimitsOfSize.{v₁, u₁, max u₂ v, max (max (max u u₂) v) v₂} (CategoryTheory.Functor K C)","decl":"instance functorCategoryHasLimitsOfSize [HasLimitsOfSize.{v₁, u₁} C] :\n    HasLimitsOfSize.{v₁, u₁} (K ⥤ C) where\n  has_limits_of_shape := fun _ _ => inferInstance\n\n-- Porting note: previously Lean could see through the binders and infer_instance sufficed\n"}
{"name":"CategoryTheory.Limits.functorCategoryHasColimitsOfSize","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, v, u} C\n⊢ CategoryTheory.Limits.HasColimitsOfSize.{v₁, u₁, max u₂ v, max (max (max u u₂) v) v₂} (CategoryTheory.Functor K C)","decl":"instance functorCategoryHasColimitsOfSize [HasColimitsOfSize.{v₁, u₁} C] :\n    HasColimitsOfSize.{v₁, u₁} (K ⥤ C) where\n  has_colimits_of_shape := fun _ _ => inferInstance\n\n"}
{"name":"CategoryTheory.Limits.hasLimitCompEvaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nk : K\ninst✝ : CategoryTheory.Limits.HasLimit (F.flip.obj k)\n⊢ CategoryTheory.Limits.HasLimit (F.comp ((CategoryTheory.evaluation K C).obj k))","decl":"instance hasLimitCompEvaluation (F : J ⥤ K ⥤ C) (k : K) [HasLimit (F.flip.obj k)] :\n    HasLimit (F ⋙ (evaluation _ _).obj k) :=\n  hasLimitOfIso (F := F.flip.obj k) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.evaluation_preservesLimit","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : ∀ (k : K), CategoryTheory.Limits.HasLimit (F.flip.obj k)\nk : K\n⊢ CategoryTheory.Limits.PreservesLimit F ((CategoryTheory.evaluation K C).obj k)","decl":"instance evaluation_preservesLimit (F : J ⥤ K ⥤ C) [∀ k, HasLimit (F.flip.obj k)] (k : K) :\n    PreservesLimit F ((evaluation K C).obj k) :=\n    -- Porting note: added a let because X was not inferred\n  let X : (k : K) → LimitCone (F.flip.obj k) := fun k => getLimitCone (F.flip.obj k)\n  preservesLimit_of_preserves_limit_cone (combinedIsLimit _ X) <|\n    IsLimit.ofIsoLimit (limit.isLimit _) (evaluateCombinedCones F X k).symm\n\n"}
{"name":"CategoryTheory.Limits.evaluation_preservesLimitsOfShape","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nk : K\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J ((CategoryTheory.evaluation K C).obj k)","decl":"instance evaluation_preservesLimitsOfShape [HasLimitsOfShape J C] (k : K) :\n    PreservesLimitsOfShape J ((evaluation K C).obj k) where\n  preservesLimit := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_π_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (((CategoryTheory.evaluation K C).obj k).obj (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F k).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.evaluation K C).obj k)) j) h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.π F j).app k) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_hom_π [HasLimitsOfShape J C] (F : J ⥤ K ⥤ C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).hom ≫ limit.π (F ⋙ (evaluation K C).obj k) j =\n      (limit.π F j).app k := by\n  dsimp [limitObjIsoLimitCompEvaluation]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_hom_π","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F k).hom (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.evaluation K C).obj k)) j)) ((CategoryTheory.Limits.limit.π F j).app k)","decl":"@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_hom_π [HasLimitsOfShape J C] (F : J ⥤ K ⥤ C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).hom ≫ limit.π (F ⋙ (evaluation K C).obj k) j =\n      (limit.π F j).app k := by\n  dsimp [limitObjIsoLimitCompEvaluation]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_inv_π_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F k).inv ((CategoryTheory.Limits.limit.π F j).app k)) (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.evaluation K C).obj k)) j)","decl":"@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_inv_π_app [HasLimitsOfShape J C] (F : J ⥤ K ⥤ C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).inv ≫ (limit.π F j).app k =\n      limit.π (F ⋙ (evaluation K C).obj k) j := by\n  dsimp [limitObjIsoLimitCompEvaluation]\n  rw [Iso.inv_comp_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_inv_π_app_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((F.obj j).obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F k).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit.π F j).app k) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.evaluation K C).obj k)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_inv_π_app [HasLimitsOfShape J C] (F : J ⥤ K ⥤ C) (j : J)\n    (k : K) :\n    (limitObjIsoLimitCompEvaluation F k).inv ≫ (limit.π F j).app k =\n      limit.π (F ⋙ (evaluation K C).obj k) j := by\n  dsimp [limitObjIsoLimitCompEvaluation]\n  rw [Iso.inv_comp_eq]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit_map_limitObjIsoLimitCompEvaluation_hom","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\ni j : K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit F).map f) (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F j).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F i).hom (CategoryTheory.Limits.limMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))))","decl":"@[reassoc (attr := simp)]\ntheorem limit_map_limitObjIsoLimitCompEvaluation_hom [HasLimitsOfShape J C] {i j : K}\n    (F : J ⥤ K ⥤ C) (f : i ⟶ j) : (limit F).map f ≫ (limitObjIsoLimitCompEvaluation _ _).hom =\n    (limitObjIsoLimitCompEvaluation _ _).hom ≫ limMap (whiskerLeft _ ((evaluation _ _).map f)) := by\n  ext\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limit_map_limitObjIsoLimitCompEvaluation_hom_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\ni j : K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nf : Quiver.Hom i j\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.limit (F.comp ((CategoryTheory.evaluation K C).obj j))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit F).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F j).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))) h))","decl":"@[reassoc (attr := simp)]\ntheorem limit_map_limitObjIsoLimitCompEvaluation_hom [HasLimitsOfShape J C] {i j : K}\n    (F : J ⥤ K ⥤ C) (f : i ⟶ j) : (limit F).map f ≫ (limitObjIsoLimitCompEvaluation _ _).hom =\n    (limitObjIsoLimitCompEvaluation _ _).hom ≫ limMap (whiskerLeft _ ((evaluation _ _).map f)) := by\n  ext\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_inv_limit_map","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\ni j : K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F i).inv ((CategoryTheory.Limits.limit F).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))) (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F j).inv)","decl":"@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_inv_limit_map [HasLimitsOfShape J C] {i j : K}\n    (F : J ⥤ K ⥤ C) (f : i ⟶ j) : (limitObjIsoLimitCompEvaluation _ _).inv ≫ (limit F).map f =\n    limMap (whiskerLeft _ ((evaluation _ _).map f)) ≫ (limitObjIsoLimitCompEvaluation _ _).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv,\n    limit_map_limitObjIsoLimitCompEvaluation_hom]\n\n"}
{"name":"CategoryTheory.Limits.limitObjIsoLimitCompEvaluation_inv_limit_map_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\ni j : K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nf : Quiver.Hom i j\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.limit F).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F i).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.limit F).map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F j).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem limitObjIsoLimitCompEvaluation_inv_limit_map [HasLimitsOfShape J C] {i j : K}\n    (F : J ⥤ K ⥤ C) (f : i ⟶ j) : (limitObjIsoLimitCompEvaluation _ _).inv ≫ (limit F).map f =\n    limMap (whiskerLeft _ ((evaluation _ _).map f)) ≫ (limitObjIsoLimitCompEvaluation _ _).inv := by\n  rw [Iso.inv_comp_eq, ← Category.assoc, Iso.eq_comp_inv,\n    limit_map_limitObjIsoLimitCompEvaluation_hom]\n\n"}
{"name":"CategoryTheory.Limits.limit_obj_ext_iff","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nk : K\nW : C\nf g : Quiver.Hom W ((CategoryTheory.Limits.limit H).obj k)\n⊢ Iff (Eq f g) (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.Limits.limit.π H j).app k)) (CategoryTheory.CategoryStruct.comp g ((CategoryTheory.Limits.limit.π H j).app k)))","decl":"@[ext]\ntheorem limit_obj_ext {H : J ⥤ K ⥤ C} [HasLimitsOfShape J C] {k : K} {W : C}\n    {f g : W ⟶ (limit H).obj k}\n    (w : ∀ j, f ≫ (Limits.limit.π H j).app k = g ≫ (Limits.limit.π H j).app k) : f = g := by\n  apply (cancel_mono (limitObjIsoLimitCompEvaluation H k).hom).1\n  ext j\n  simpa using w j\n\n"}
{"name":"CategoryTheory.Limits.limit_obj_ext","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nk : K\nW : C\nf g : Quiver.Hom W ((CategoryTheory.Limits.limit H).obj k)\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp f ((CategoryTheory.Limits.limit.π H j).app k)) (CategoryTheory.CategoryStruct.comp g ((CategoryTheory.Limits.limit.π H j).app k))\n⊢ Eq f g","decl":"@[ext]\ntheorem limit_obj_ext {H : J ⥤ K ⥤ C} [HasLimitsOfShape J C] {k : K} {W : C}\n    {f g : W ⟶ (limit H).obj k}\n    (w : ∀ j, f ≫ (Limits.limit.π H j).app k = g ≫ (Limits.limit.π H j).app k) : f = g := by\n  apply (cancel_mono (limitObjIsoLimitCompEvaluation H k).hom).1\n  ext j\n  simpa using w j\n\n"}
{"name":"CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit_hom_whiskerLeft_π_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nj : J\nZ : CategoryTheory.Functor D C\nh : Quiver.Hom (G.comp (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit F G).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.limit.π F j)) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringLeftIsoCompLimit_hom_whiskerLeft_π (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasLimitsOfShape J C] (j : J) :\n    (limitCompWhiskeringLeftIsoCompLimit F G).hom ≫ whiskerLeft G (limit.π F j) =\n      limit.π (F ⋙ (whiskeringLeft _ _ _).obj G) j := by\n  ext d\n  simp [limitCompWhiskeringLeftIsoCompLimit]\n\n"}
{"name":"CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit_hom_whiskerLeft_π","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit F G).hom (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.limit.π F j))) (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringLeftIsoCompLimit_hom_whiskerLeft_π (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasLimitsOfShape J C] (j : J) :\n    (limitCompWhiskeringLeftIsoCompLimit F G).hom ≫ whiskerLeft G (limit.π F j) =\n      limit.π (F ⋙ (whiskeringLeft _ _ _).obj G) j := by\n  ext d\n  simp [limitCompWhiskeringLeftIsoCompLimit]\n\n"}
{"name":"CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit_inv_π_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nj : J\nZ : CategoryTheory.Functor D C\nh : Quiver.Hom (((CategoryTheory.whiskeringLeft D K C).obj G).obj (F.obj j)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit F G).inv (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.limit.π F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringLeftIsoCompLimit_inv_π (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasLimitsOfShape J C] (j : J) :\n    (limitCompWhiskeringLeftIsoCompLimit F G).inv ≫ limit.π (F ⋙ (whiskeringLeft _ _ _).obj G) j =\n      whiskerLeft G (limit.π F j) := by\n  simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit_inv_π","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitCompWhiskeringLeftIsoCompLimit F G).inv (CategoryTheory.Limits.limit.π (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j)) (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.limit.π F j))","decl":"@[reassoc (attr := simp)]\ntheorem limitCompWhiskeringLeftIsoCompLimit_inv_π (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasLimitsOfShape J C] (j : J) :\n    (limitCompWhiskeringLeftIsoCompLimit F G).inv ≫ limit.π (F ⋙ (whiskeringLeft _ _ _).obj G) j =\n      whiskerLeft G (limit.π F j) := by\n  simp [Iso.inv_comp_eq]\n\n"}
{"name":"CategoryTheory.Limits.hasColimitCompEvaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nk : K\ninst✝ : CategoryTheory.Limits.HasColimit (F.flip.obj k)\n⊢ CategoryTheory.Limits.HasColimit (F.comp ((CategoryTheory.evaluation K C).obj k))","decl":"instance hasColimitCompEvaluation (F : J ⥤ K ⥤ C) (k : K) [HasColimit (F.flip.obj k)] :\n    HasColimit (F ⋙ (evaluation _ _).obj k) :=\n  hasColimitOfIso (F := F.flip.obj k) (Iso.refl _)\n\n"}
{"name":"CategoryTheory.Limits.evaluation_preservesColimit","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : ∀ (k : K), CategoryTheory.Limits.HasColimit (F.flip.obj k)\nk : K\n⊢ CategoryTheory.Limits.PreservesColimit F ((CategoryTheory.evaluation K C).obj k)","decl":"instance evaluation_preservesColimit (F : J ⥤ K ⥤ C) [∀ k, HasColimit (F.flip.obj k)] (k : K) :\n    PreservesColimit F ((evaluation K C).obj k) :=\n  -- Porting note: added a let because X was not inferred\n  let X : (k : K) → ColimitCocone (F.flip.obj k) := fun k => getColimitCocone (F.flip.obj k)\n  preservesColimit_of_preserves_colimit_cocone (combinedIsColimit _ X) <|\n    IsColimit.ofIsoColimit (colimit.isColimit _) (evaluateCombinedCocones F X k).symm\n\n"}
{"name":"CategoryTheory.Limits.evaluation_preservesColimitsOfShape","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nk : K\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J ((CategoryTheory.evaluation K C).obj k)","decl":"instance evaluation_preservesColimitsOfShape [HasColimitsOfShape J C] (k : K) :\n    PreservesColimitsOfShape J ((evaluation K C).obj k) where\n  preservesColimit := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_ι_inv","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.evaluation K C).obj k)) j) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F k).inv) ((CategoryTheory.Limits.colimit.ι F j).app k)","decl":"@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_ι_inv [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C) (j : J)\n    (k : K) :\n    colimit.ι (F ⋙ (evaluation K C).obj k) j ≫ (colimitObjIsoColimitCompEvaluation F k).inv =\n      (colimit.ι F j).app k := by\n  dsimp [colimitObjIsoColimitCompEvaluation]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_ι_inv_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.colimit F).obj k) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.evaluation K C).obj k)) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F k).inv h)) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι F j).app k) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_ι_inv [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C) (j : J)\n    (k : K) :\n    colimit.ι (F ⋙ (evaluation K C).obj k) j ≫ (colimitObjIsoColimitCompEvaluation F k).inv =\n      (colimit.ι F j).app k := by\n  dsimp [colimitObjIsoColimitCompEvaluation]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_ι_app_hom","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι F j).app k) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F k).hom) (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.evaluation K C).obj k)) j)","decl":"@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_ι_app_hom [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C)\n    (j : J) (k : K) :\n    (colimit.ι F j).app k ≫ (colimitObjIsoColimitCompEvaluation F k).hom =\n      colimit.ι (F ⋙ (evaluation K C).obj k) j := by\n  dsimp [colimitObjIsoColimitCompEvaluation]\n  rw [← Iso.eq_comp_inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_ι_app_hom_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nj : J\nk : K\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp ((CategoryTheory.evaluation K C).obj k))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι F j).app k) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F k).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.evaluation K C).obj k)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_ι_app_hom [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C)\n    (j : J) (k : K) :\n    (colimit.ι F j).app k ≫ (colimitObjIsoColimitCompEvaluation F k).hom =\n      colimit.ι (F ⋙ (evaluation K C).obj k) j := by\n  dsimp [colimitObjIsoColimitCompEvaluation]\n  rw [← Iso.eq_comp_inv]\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_inv_colimit_map","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ni j : K\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F i).inv ((CategoryTheory.Limits.colimit F).map f)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F j).inv)","decl":"@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_inv_colimit_map [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C)\n    {i j : K} (f : i ⟶ j) :\n    (colimitObjIsoColimitCompEvaluation _ _).inv ≫ (colimit F).map f =\n      colimMap (whiskerLeft _ ((evaluation _ _).map f)) ≫\n        (colimitObjIsoColimitCompEvaluation _ _).inv := by\n  ext\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation_inv_colimit_map_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ni j : K\nf : Quiver.Hom i j\nZ : C\nh : Quiver.Hom ((CategoryTheory.Limits.colimit F).obj j) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F i).inv (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit F).map f) h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F j).inv h))","decl":"@[reassoc (attr := simp)]\ntheorem colimitObjIsoColimitCompEvaluation_inv_colimit_map [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C)\n    {i j : K} (f : i ⟶ j) :\n    (colimitObjIsoColimitCompEvaluation _ _).inv ≫ (colimit F).map f =\n      colimMap (whiskerLeft _ ((evaluation _ _).map f)) ≫\n        (colimitObjIsoColimitCompEvaluation _ _).inv := by\n  ext\n  dsimp\n  simp\n\n"}
{"name":"CategoryTheory.Limits.colimit_map_colimitObjIsoColimitCompEvaluation_hom","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ni j : K\nf : Quiver.Hom i j\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit F).map f) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F j).hom) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F i).hom (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))))","decl":"@[reassoc (attr := simp)]\ntheorem colimit_map_colimitObjIsoColimitCompEvaluation_hom [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C)\n    {i j : K} (f : i ⟶ j) :\n    (colimit F).map f ≫ (colimitObjIsoColimitCompEvaluation _ _).hom =\n      (colimitObjIsoColimitCompEvaluation _ _).hom ≫\n        colimMap (whiskerLeft _ ((evaluation _ _).map f)) := by\n  rw [← Iso.inv_comp_eq, ← Category.assoc, ← Iso.eq_comp_inv,\n    colimitObjIsoColimitCompEvaluation_inv_colimit_map]\n\n"}
{"name":"CategoryTheory.Limits.colimit_map_colimitObjIsoColimitCompEvaluation_hom_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ni j : K\nf : Quiver.Hom i j\nZ : C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp ((CategoryTheory.evaluation K C).obj j))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit F).map f) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F j).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F i).hom (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap (CategoryTheory.whiskerLeft F ((CategoryTheory.evaluation K C).map f))) h))","decl":"@[reassoc (attr := simp)]\ntheorem colimit_map_colimitObjIsoColimitCompEvaluation_hom [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C)\n    {i j : K} (f : i ⟶ j) :\n    (colimit F).map f ≫ (colimitObjIsoColimitCompEvaluation _ _).hom =\n      (colimitObjIsoColimitCompEvaluation _ _).hom ≫\n        colimMap (whiskerLeft _ ((evaluation _ _).map f)) := by\n  rw [← Iso.inv_comp_eq, ← Category.assoc, ← Iso.eq_comp_inv,\n    colimitObjIsoColimitCompEvaluation_inv_colimit_map]\n\n"}
{"name":"CategoryTheory.Limits.colimit_obj_ext_iff","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nk : K\nW : C\nf g : Quiver.Hom ((CategoryTheory.Limits.colimit H).obj k) W\n⊢ Iff (Eq f g) (∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι H j).app k) f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι H j).app k) g))","decl":"@[ext]\ntheorem colimit_obj_ext {H : J ⥤ K ⥤ C} [HasColimitsOfShape J C] {k : K} {W : C}\n    {f g : (colimit H).obj k ⟶ W} (w : ∀ j, (colimit.ι H j).app k ≫ f = (colimit.ι H j).app k ≫ g) :\n    f = g := by\n  apply (cancel_epi (colimitObjIsoColimitCompEvaluation H k).inv).1\n  ext j\n  simpa using w j\n\n"}
{"name":"CategoryTheory.Limits.colimit_obj_ext","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nH : CategoryTheory.Functor J (CategoryTheory.Functor K C)\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nk : K\nW : C\nf g : Quiver.Hom ((CategoryTheory.Limits.colimit H).obj k) W\nw : ∀ (j : J), Eq (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι H j).app k) f) (CategoryTheory.CategoryStruct.comp ((CategoryTheory.Limits.colimit.ι H j).app k) g)\n⊢ Eq f g","decl":"@[ext]\ntheorem colimit_obj_ext {H : J ⥤ K ⥤ C} [HasColimitsOfShape J C] {k : K} {W : C}\n    {f g : (colimit H).obj k ⟶ W} (w : ∀ j, (colimit.ι H j).app k ≫ f = (colimit.ι H j).app k ≫ g) :\n    f = g := by\n  apply (cancel_epi (colimitObjIsoColimitCompEvaluation H k).inv).1\n  ext j\n  simpa using w j\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitCompWhiskeringLeftIsoCompColimit_hom_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nj : J\nZ : CategoryTheory.Functor D C\nh : Quiver.Hom (G.comp (CategoryTheory.Limits.colimit F)) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitCompWhiskeringLeftIsoCompColimit F G).hom h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.colimit.ι F j)) h)","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitCompWhiskeringLeftIsoCompColimit_hom (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasColimitsOfShape J C] (j : J) :\n    colimit.ι (F ⋙ (whiskeringLeft _ _ _).obj G) j ≫\n      (colimitCompWhiskeringLeftIsoCompColimit F G).hom = whiskerLeft G (colimit.ι F j) := by\n  ext d\n  simp [colimitCompWhiskeringLeftIsoCompColimit]\n\n"}
{"name":"CategoryTheory.Limits.ι_colimitCompWhiskeringLeftIsoCompColimit_hom","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j) (CategoryTheory.Limits.colimitCompWhiskeringLeftIsoCompColimit F G).hom) (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.colimit.ι F j))","decl":"@[reassoc (attr := simp)]\ntheorem ι_colimitCompWhiskeringLeftIsoCompColimit_hom (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasColimitsOfShape J C] (j : J) :\n    colimit.ι (F ⋙ (whiskeringLeft _ _ _).obj G) j ≫\n      (colimitCompWhiskeringLeftIsoCompColimit F G).hom = whiskerLeft G (colimit.ι F j) := by\n  ext d\n  simp [colimitCompWhiskeringLeftIsoCompColimit]\n\n"}
{"name":"CategoryTheory.Limits.whiskerLeft_ι_colimitCompWhiskeringLeftIsoCompColimit_inv","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nj : J\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.colimit.ι F j)) (CategoryTheory.Limits.colimitCompWhiskeringLeftIsoCompColimit F G).inv) (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_ι_colimitCompWhiskeringLeftIsoCompColimit_inv (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasColimitsOfShape J C] (j : J) :\n    whiskerLeft G (colimit.ι F j) ≫ (colimitCompWhiskeringLeftIsoCompColimit F G).inv =\n      colimit.ι (F ⋙ (whiskeringLeft _ _ _).obj G) j := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.whiskerLeft_ι_colimitCompWhiskeringLeftIsoCompColimit_inv_assoc","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝⁴ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝³ : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor D K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nj : J\nZ : CategoryTheory.Functor D C\nh : Quiver.Hom (CategoryTheory.Limits.colimit (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G))) Z\n⊢ Eq (CategoryTheory.CategoryStruct.comp (CategoryTheory.whiskerLeft G (CategoryTheory.Limits.colimit.ι F j)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitCompWhiskeringLeftIsoCompColimit F G).inv h)) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimit.ι (F.comp ((CategoryTheory.whiskeringLeft D K C).obj G)) j) h)","decl":"@[reassoc (attr := simp)]\ntheorem whiskerLeft_ι_colimitCompWhiskeringLeftIsoCompColimit_inv (F : J ⥤ K ⥤ C) (G : D ⥤ K)\n    [HasColimitsOfShape J C] (j : J) :\n    whiskerLeft G (colimit.ι F j) ≫ (colimitCompWhiskeringLeftIsoCompColimit F G).inv =\n      colimit.ι (F ⋙ (whiskeringLeft _ _ _).obj G) j := by\n  simp [Iso.comp_inv_eq]\n\n"}
{"name":"CategoryTheory.Limits.evaluationPreservesLimits","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimits C\nk : K\n⊢ CategoryTheory.Limits.PreservesLimits ((CategoryTheory.evaluation K C).obj k)","decl":"instance evaluationPreservesLimits [HasLimits C] (k : K) :\n    PreservesLimits ((evaluation K C).obj k) where\n  preservesLimitsOfShape {_} _𝒥 := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.preservesLimit_of_evaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor J D\nH : ∀ (k : K), CategoryTheory.Limits.PreservesLimit G (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesLimit G F","decl":"/-- `F : D ⥤ K ⥤ C` preserves the limit of some `G : J ⥤ D` if it does for each `k : K`. -/\nlemma preservesLimit_of_evaluation (F : D ⥤ K ⥤ C) (G : J ⥤ D)\n    (H : ∀ k : K, PreservesLimit G (F ⋙ (evaluation K C).obj k : D ⥤ C)) : PreservesLimit G F :=\n  ⟨fun {c} hc => ⟨by\n    apply evaluationJointlyReflectsLimits\n    intro X\n    haveI := H X\n    change IsLimit ((F ⋙ (evaluation K C).obj X).mapCone c)\n    exact isLimitOfPreserves _ hc⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitOfEvaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor J D\nH : ∀ (k : K), CategoryTheory.Limits.PreservesLimit G (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesLimit G F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesLimitOfEvaluation (F : D ⥤ K ⥤ C) (G : J ⥤ D)\n    (H : ∀ k : K, PreservesLimit G (F ⋙ (evaluation K C).obj k : D ⥤ C)) :\n    PreservesLimit G F :=\n  preservesLimit_of_evaluation _ _ H\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShape_of_evaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nJ : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\nx✝ : ∀ (k : K), CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"/-- `F : D ⥤ K ⥤ C` preserves limits of shape `J` if it does for each `k : K`. -/\nlemma preservesLimitsOfShape_of_evaluation (F : D ⥤ K ⥤ C) (J : Type*) [Category J]\n    (_ : ∀ k : K, PreservesLimitsOfShape J (F ⋙ (evaluation K C).obj k)) :\n    PreservesLimitsOfShape J F :=\n  ⟨fun {G} => preservesLimit_of_evaluation F G fun _ => PreservesLimitsOfShape.preservesLimit⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfShapeOfEvaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nJ : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\nH : ∀ (k : K), CategoryTheory.Limits.PreservesLimitsOfShape J (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesLimitsOfShape J F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfShapeOfEvaluation (F : D ⥤ K ⥤ C) (J : Type*) [Category J]\n    (H : ∀ k : K, PreservesLimitsOfShape J (F ⋙ (evaluation K C).obj k)) :\n    PreservesLimitsOfShape J F :=\n  preservesLimitsOfShape_of_evaluation _ _ H\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_of_evaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nx✝ : ∀ (k : K), CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v', v, u', u} (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v', max u₂ v, u', max (max (max u u₂) v) v₂} F","decl":"/-- `F : D ⥤ K ⥤ C` preserves all limits if it does for each `k : K`. -/\nlemma preservesLimits_of_evaluation (F : D ⥤ K ⥤ C)\n    (_ : ∀ k : K, PreservesLimitsOfSize.{w', w} (F ⋙ (evaluation K C).obj k)) :\n    PreservesLimitsOfSize.{w', w} F :=\n  ⟨fun {L} _ =>\n    preservesLimitsOfShape_of_evaluation F L fun _ => PreservesLimitsOfSize.preservesLimitsOfShape⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesLimitsOfEvaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nH : ∀ (k : K), CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v', v, u', u} (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v', max u₂ v, u', max (max (max u u₂) v) v₂} F","decl":"@[deprecated \"No deprecation message was provided.\" (since := \"2024-11-19\")]\nlemma preservesLimitsOfEvaluation (F : D ⥤ K ⥤ C)\n    (H : ∀ k : K, PreservesLimitsOfSize.{w', w} (F ⋙ (evaluation K C).obj k)) :\n    PreservesLimitsOfSize.{w', w} F :=\n  preservesLimits_of_evaluation _ H\n\n"}
{"name":"CategoryTheory.Limits.preservesLimits_const","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\n⊢ CategoryTheory.Limits.PreservesLimitsOfSize.{w', w, v, max u' v, u, max (max (max u u') v) v'} (CategoryTheory.Functor.const D)","decl":"/-- The constant functor `C ⥤ (D ⥤ C)` preserves limits. -/\ninstance preservesLimits_const : PreservesLimitsOfSize.{w', w} (const D : C ⥤ _) :=\n  preservesLimits_of_evaluation _ fun _ =>\n    preservesLimits_of_natIso <| Iso.symm <| constCompEvaluationObj _ _\n\n"}
{"name":"CategoryTheory.Limits.evaluation_preservesColimits","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimits C\nk : K\n⊢ CategoryTheory.Limits.PreservesColimits ((CategoryTheory.evaluation K C).obj k)","decl":"instance evaluation_preservesColimits [HasColimits C] (k : K) :\n    PreservesColimits ((evaluation K C).obj k) where\n  preservesColimitsOfShape := inferInstance\n\n"}
{"name":"CategoryTheory.Limits.preservesColimit_of_evaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor J D\nH : ∀ (k : K), CategoryTheory.Limits.PreservesColimit G (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesColimit G F","decl":"/-- `F : D ⥤ K ⥤ C` preserves the colimit of some `G : J ⥤ D` if it does for each `k : K`. -/\nlemma preservesColimit_of_evaluation (F : D ⥤ K ⥤ C) (G : J ⥤ D)\n    (H : ∀ k, PreservesColimit G (F ⋙ (evaluation K C).obj k)) : PreservesColimit G F :=\n  ⟨fun {c} hc => ⟨by\n    apply evaluationJointlyReflectsColimits\n    intro X\n    haveI := H X\n    change IsColimit ((F ⋙ (evaluation K C).obj X).mapCocone c)\n    exact isColimitOfPreserves _ hc⟩⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitOfEvaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nJ : Type u₁\ninst✝¹ : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nG : CategoryTheory.Functor J D\nH : ∀ (k : K), CategoryTheory.Limits.PreservesColimit G (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesColimit G F","decl":"@[deprecated \"No deprecation message was provided.\"  (since := \"2024-11-19\")]\nlemma preservesColimitOfEvaluation (F : D ⥤ K ⥤ C) (G : J ⥤ D)\n    (H : ∀ k, PreservesColimit G (F ⋙ (evaluation K C).obj k)) : PreservesColimit G F :=\n  preservesColimit_of_evaluation _ _ H\n\n"}
{"name":"CategoryTheory.Limits.preservesColimitsOfShape_of_evaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝² : CategoryTheory.Category.{v', u'} D\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nJ : Type u_1\ninst✝ : CategoryTheory.Category.{u_2, u_1} J\nx✝ : ∀ (k : K), CategoryTheory.Limits.PreservesColimitsOfShape J (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesColimitsOfShape J F","decl":"/-- `F : D ⥤ K ⥤ C` preserves all colimits of shape `J` if it does for each `k : K`. -/\nlemma preservesColimitsOfShape_of_evaluation (F : D ⥤ K ⥤ C) (J : Type*) [Category J]\n    (_ : ∀ k : K, PreservesColimitsOfShape J (F ⋙ (evaluation K C).obj k)) :\n    PreservesColimitsOfShape J F :=\n  ⟨fun {G} => preservesColimit_of_evaluation F G fun _ => PreservesColimitsOfShape.preservesColimit⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_of_evaluation","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝² : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝¹ : CategoryTheory.Category.{v', u'} D\nK : Type u₂\ninst✝ : CategoryTheory.Category.{v₂, u₂} K\nF : CategoryTheory.Functor D (CategoryTheory.Functor K C)\nx✝ : ∀ (k : K), CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v', v, u', u} (F.comp ((CategoryTheory.evaluation K C).obj k))\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v', max u₂ v, u', max (max (max u u₂) v) v₂} F","decl":"/-- `F : D ⥤ K ⥤ C` preserves all colimits if it does for each `k : K`. -/\nlemma preservesColimits_of_evaluation (F : D ⥤ K ⥤ C)\n    (_ : ∀ k : K, PreservesColimitsOfSize.{w', w} (F ⋙ (evaluation K C).obj k)) :\n    PreservesColimitsOfSize.{w', w} F :=\n  ⟨fun {L} _ =>\n    preservesColimitsOfShape_of_evaluation F L fun _ =>\n      PreservesColimitsOfSize.preservesColimitsOfShape⟩\n\n"}
{"name":"CategoryTheory.Limits.preservesColimits_const","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝¹ : CategoryTheory.Category.{v, u} C\nD : Type u'\ninst✝ : CategoryTheory.Category.{v', u'} D\n⊢ CategoryTheory.Limits.PreservesColimitsOfSize.{w', w, v, max u' v, u, max (max (max u u') v) v'} (CategoryTheory.Functor.const D)","decl":"/-- The constant functor `C ⥤ (D ⥤ C)` preserves colimits. -/\ninstance preservesColimits_const : PreservesColimitsOfSize.{w', w} (const D : C ⥤ _) :=\n  preservesColimits_of_evaluation _ fun _ =>\n    preservesColimits_of_natIso <| Iso.symm <| constCompEvaluationObj _ _\n\n"}
{"name":"CategoryTheory.Limits.limitIsoFlipCompLim_inv_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.limitIsoFlipCompLim F).inv.app X) (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F X).inv","decl":"/-- The limit of a diagram `F : J ⥤ K ⥤ C` is isomorphic to the functor given by\nthe individual limits on objects. -/\n@[simps!]\ndef limitIsoFlipCompLim [HasLimitsOfShape J C] (F : J ⥤ K ⥤ C) : limit F ≅ F.flip ⋙ lim :=\n  NatIso.ofComponents (limitObjIsoLimitCompEvaluation F)\n\n"}
{"name":"CategoryTheory.Limits.limitIsoFlipCompLim_hom_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.limitIsoFlipCompLim F).hom.app X) (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F X).hom","decl":"/-- The limit of a diagram `F : J ⥤ K ⥤ C` is isomorphic to the functor given by\nthe individual limits on objects. -/\n@[simps!]\ndef limitIsoFlipCompLim [HasLimitsOfShape J C] (F : J ⥤ K ⥤ C) : limit F ≅ F.flip ⋙ lim :=\n  NatIso.ofComponents (limitObjIsoLimitCompEvaluation F)\n\n"}
{"name":"CategoryTheory.Limits.limitFlipIsoCompLim_inv_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor K (CategoryTheory.Functor J C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.limitFlipIsoCompLim F).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasLimit.isoOfNatIso (CategoryTheory.flipCompEvaluation F X)).inv (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F.flip X).inv)","decl":"/-- A variant of `limitIsoFlipCompLim` where the arguments of `F` are flipped. -/\n@[simps!]\ndef limitFlipIsoCompLim [HasLimitsOfShape J C] (F : K ⥤ J ⥤ C) : limit F.flip ≅ F ⋙ lim :=\n  let f := fun k =>\n    limitObjIsoLimitCompEvaluation F.flip k ≪≫ HasLimit.isoOfNatIso (flipCompEvaluation _ _)\n  NatIso.ofComponents f\n\n"}
{"name":"CategoryTheory.Limits.limitFlipIsoCompLim_hom_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nF : CategoryTheory.Functor K (CategoryTheory.Functor J C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.limitFlipIsoCompLim F).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation F.flip X).hom (CategoryTheory.Limits.HasLimit.isoOfNatIso (CategoryTheory.flipCompEvaluation F X)).hom)","decl":"/-- A variant of `limitIsoFlipCompLim` where the arguments of `F` are flipped. -/\n@[simps!]\ndef limitFlipIsoCompLim [HasLimitsOfShape J C] (F : K ⥤ J ⥤ C) : limit F.flip ≅ F ⋙ lim :=\n  let f := fun k =>\n    limitObjIsoLimitCompEvaluation F.flip k ≪≫ HasLimit.isoOfNatIso (flipCompEvaluation _ _)\n  NatIso.ofComponents f\n\n"}
{"name":"CategoryTheory.Limits.limitIsoSwapCompLim_inv_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.limitIsoSwapCompLim G).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limMap ((CategoryTheory.flipIsoCurrySwapUncurry G).inv.app X)) (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation G X).inv)","decl":"/-- For a functor `G : J ⥤ K ⥤ C`, its limit `K ⥤ C` is given by `(G' : K ⥤ J ⥤ C) ⋙ lim`.\nNote that this does not require `K` to be small.\n-/\n@[simps!]\ndef limitIsoSwapCompLim [HasLimitsOfShape J C] (G : J ⥤ K ⥤ C) :\n    limit G ≅ curry.obj (Prod.swap K J ⋙ uncurry.obj G) ⋙ lim :=\n  limitIsoFlipCompLim G ≪≫ isoWhiskerRight (flipIsoCurrySwapUncurry _) _\n\n"}
{"name":"CategoryTheory.Limits.limitIsoSwapCompLim_hom_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasLimitsOfShape J C\nG : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.limitIsoSwapCompLim G).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.limitObjIsoLimitCompEvaluation G X).hom (CategoryTheory.Limits.limMap ((CategoryTheory.flipIsoCurrySwapUncurry G).hom.app X)))","decl":"/-- For a functor `G : J ⥤ K ⥤ C`, its limit `K ⥤ C` is given by `(G' : K ⥤ J ⥤ C) ⋙ lim`.\nNote that this does not require `K` to be small.\n-/\n@[simps!]\ndef limitIsoSwapCompLim [HasLimitsOfShape J C] (G : J ⥤ K ⥤ C) :\n    limit G ≅ curry.obj (Prod.swap K J ⋙ uncurry.obj G) ⋙ lim :=\n  limitIsoFlipCompLim G ≪≫ isoWhiskerRight (flipIsoCurrySwapUncurry _) _\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoFlipCompColim_inv_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.colimitIsoFlipCompColim F).inv.app X) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F X).inv","decl":"/-- The colimit of a diagram `F : J ⥤ K ⥤ C` is isomorphic to the functor given by\nthe individual colimits on objects. -/\n@[simps!]\ndef colimitIsoFlipCompColim [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C) : colimit F ≅ F.flip ⋙ colim :=\n  NatIso.ofComponents (colimitObjIsoColimitCompEvaluation F)\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoFlipCompColim_hom_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.colimitIsoFlipCompColim F).hom.app X) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F X).hom","decl":"/-- The colimit of a diagram `F : J ⥤ K ⥤ C` is isomorphic to the functor given by\nthe individual colimits on objects. -/\n@[simps!]\ndef colimitIsoFlipCompColim [HasColimitsOfShape J C] (F : J ⥤ K ⥤ C) : colimit F ≅ F.flip ⋙ colim :=\n  NatIso.ofComponents (colimitObjIsoColimitCompEvaluation F)\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipIsoCompColim_inv_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor K (CategoryTheory.Functor J C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.colimitFlipIsoCompColim F).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.flipCompEvaluation F X)).inv (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F.flip X).inv)","decl":"/-- A variant of `colimit_iso_flip_comp_colim` where the arguments of `F` are flipped. -/\n@[simps!]\ndef colimitFlipIsoCompColim [HasColimitsOfShape J C] (F : K ⥤ J ⥤ C) : colimit F.flip ≅ F ⋙ colim :=\n  let f := fun _ =>\n      colimitObjIsoColimitCompEvaluation _ _ ≪≫ HasColimit.isoOfNatIso (flipCompEvaluation _ _)\n  NatIso.ofComponents f\n\n"}
{"name":"CategoryTheory.Limits.colimitFlipIsoCompColim_hom_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nF : CategoryTheory.Functor K (CategoryTheory.Functor J C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.colimitFlipIsoCompColim F).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation F.flip X).hom (CategoryTheory.Limits.HasColimit.isoOfNatIso (CategoryTheory.flipCompEvaluation F X)).hom)","decl":"/-- A variant of `colimit_iso_flip_comp_colim` where the arguments of `F` are flipped. -/\n@[simps!]\ndef colimitFlipIsoCompColim [HasColimitsOfShape J C] (F : K ⥤ J ⥤ C) : colimit F.flip ≅ F ⋙ colim :=\n  let f := fun _ =>\n      colimitObjIsoColimitCompEvaluation _ _ ≪≫ HasColimit.isoOfNatIso (flipCompEvaluation _ _)\n  NatIso.ofComponents f\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoSwapCompColim_inv_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.colimitIsoSwapCompColim G).inv.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimMap ((CategoryTheory.flipIsoCurrySwapUncurry G).inv.app X)) (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation G X).inv)","decl":"/-- For a functor `G : J ⥤ K ⥤ C`, its colimit `K ⥤ C` is given by `(G' : K ⥤ J ⥤ C) ⋙ colim`.\nNote that this does not require `K` to be small.\n-/\n@[simps!]\ndef colimitIsoSwapCompColim [HasColimitsOfShape J C] (G : J ⥤ K ⥤ C) :\n    colimit G ≅ curry.obj (Prod.swap K J ⋙ uncurry.obj G) ⋙ colim :=\n  colimitIsoFlipCompColim G ≪≫ isoWhiskerRight (flipIsoCurrySwapUncurry _) _\n\n"}
{"name":"CategoryTheory.Limits.colimitIsoSwapCompColim_hom_app","module":"Mathlib.CategoryTheory.Limits.FunctorCategory.Basic","initialProofState":"C : Type u\ninst✝³ : CategoryTheory.Category.{v, u} C\nJ : Type u₁\ninst✝² : CategoryTheory.Category.{v₁, u₁} J\nK : Type u₂\ninst✝¹ : CategoryTheory.Category.{v₂, u₂} K\ninst✝ : CategoryTheory.Limits.HasColimitsOfShape J C\nG : CategoryTheory.Functor J (CategoryTheory.Functor K C)\nX : K\n⊢ Eq ((CategoryTheory.Limits.colimitIsoSwapCompColim G).hom.app X) (CategoryTheory.CategoryStruct.comp (CategoryTheory.Limits.colimitObjIsoColimitCompEvaluation G X).hom (CategoryTheory.Limits.colimMap ((CategoryTheory.flipIsoCurrySwapUncurry G).hom.app X)))","decl":"/-- For a functor `G : J ⥤ K ⥤ C`, its colimit `K ⥤ C` is given by `(G' : K ⥤ J ⥤ C) ⋙ colim`.\nNote that this does not require `K` to be small.\n-/\n@[simps!]\ndef colimitIsoSwapCompColim [HasColimitsOfShape J C] (G : J ⥤ K ⥤ C) :\n    colimit G ≅ curry.obj (Prod.swap K J ⋙ uncurry.obj G) ⋙ colim :=\n  colimitIsoFlipCompColim G ≪≫ isoWhiskerRight (flipIsoCurrySwapUncurry _) _\n\n"}
