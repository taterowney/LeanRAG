{"name":"MvPolynomial.isLocalization","module":"Mathlib.RingTheory.MvPolynomial.Localization","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_3\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\n⊢ IsLocalization (Submonoid.map MvPolynomial.C M) (MvPolynomial σ S)","decl":"/--\nIf `S` is the localization of `R` at a submonoid `M`, then `MvPolynomial σ S`\nis the localization of `MvPolynomial σ R` at `M.map MvPolynomial.C`.\n\nSee also `Polynomial.isLocalization` for the univariate case. -/\ninstance isLocalization : IsLocalization (M.map <| C (σ := σ)) (MvPolynomial σ S) :=\n  isLocalizedModule_iff_isLocalization.mp <| (isLocalizedModule_iff_isBaseChange M S _).mpr <|\n    .of_equiv (algebraTensorAlgEquiv _ _).toLinearEquiv fun _ ↦ by simp\n\n"}
{"name":"MvPolynomial.isLocalization_C_mk'","module":"Mathlib.RingTheory.MvPolynomial.Localization","initialProofState":"σ : Type u_1\nR : Type u_2\ninst✝³ : CommRing R\nM : Submonoid R\nS : Type u_3\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\ninst✝ : IsLocalization M S\na : R\nm : Subtype fun x => Membership.mem M x\n⊢ Eq (MvPolynomial.C (IsLocalization.mk' S a m)) (IsLocalization.mk' (MvPolynomial σ S) (MvPolynomial.C a) ⟨MvPolynomial.C ↑m, ⋯⟩)","decl":"lemma isLocalization_C_mk' (a : R) (m : M) :\n    C (IsLocalization.mk' S a m) = IsLocalization.mk' (MvPolynomial σ S) (C (σ := σ) a)\n      ⟨C m, Submonoid.mem_map_of_mem C m.property⟩ := by\n  simp_rw [IsLocalization.eq_mk'_iff_mul_eq, algebraMap_def, map_C, ← map_mul,\n    IsLocalization.mk'_spec]\n\n"}
{"name":"IsLocalization.Away.mvPolynomialQuotientEquiv_apply","module":"Mathlib.RingTheory.MvPolynomial.Localization","initialProofState":"R : Type u_2\ninst✝³ : CommRing R\nS : Type u_3\ninst✝² : CommRing S\ninst✝¹ : Algebra R S\nr : R\ninst✝ : IsLocalization.Away r S\np : MvPolynomial Unit R\n⊢ Eq ((IsLocalization.Away.mvPolynomialQuotientEquiv S r) ((Ideal.Quotient.mk (Ideal.span (Singleton.singleton (HSub.hSub (HMul.hMul (MvPolynomial.C r) (MvPolynomial.X Unit.unit)) 1)))) p)) ((MvPolynomial.aeval fun x => IsLocalization.Away.invSelf r) p)","decl":"@[simp]\nlemma mvPolynomialQuotientEquiv_apply (p : MvPolynomial Unit R) :\n    mvPolynomialQuotientEquiv S r (Ideal.Quotient.mk _ p) = aeval (S₁ := S) (fun _ ↦ invSelf r) p :=\n  rfl\n\n"}
